/* This file has been generated by the Hex-Rays decompiler.
   Copyright (c) 2007-2017 Hex-Rays <info@hex-rays.com>

   Detected compiler: GNU C++
*/

#include <math.h>
#include <defs.h>

#include <stdarg.h>


//-------------------------------------------------------------------------
// Function declarations

void init_proc(void); // idb
void sub_8049BC0();
// int usleep(__useconds_t useconds);
// int mkdir(const char *path, __mode_t mode);
// double cos(double x);
// uint32_t ntohl(uint32_t netlong);
// int __cdecl std::string::operator=(_DWORD, _DWORD); weak
// int rename(const char *old, const char *new);
// _DWORD __cdecl std::string::compare(std::string *this, const std::string *); idb
// int execl(const char *path, const char *arg, ...);
// char *strncat(char *dest, const char *src, size_t n);
// int vsprintf(char *s, const char *format, __gnuc_va_list arg);
// char *strchr(const char *s, int c);
// int __cdecl std::allocator<char>::allocator(_DWORD); weak
// double atan(double x);
// ssize_t write(int fd, const void *buf, size_t n);
// struct tm *localtime(const time_t *timer);
// ssize_t recvfrom(int fd, void *buf, size_t n, int flags, struct sockaddr *addr, socklen_t *addr_len);
// int fileno(FILE *stream);
// int strcmp(const char *s1, const char *s2);
// int isspace(int);
// int close(int fd);
// double asin(double x);
// void *dlsym(void *handle, const char *name);
// int fprintf(FILE *stream, const char *format, ...);
// __pid_t fork(void);
// char *getenv(const char *name);
// __sighandler_t signal(int sig, __sighandler_t handler);
// int __cdecl std::string::string(_DWORD, _DWORD, _DWORD); weak
// int fflush(FILE *stream);
// int seteuid(__uid_t uid);
// int unlink(const char *name);
// int select(int nfds, fd_set *readfds, fd_set *writefds, fd_set *exceptfds, struct timeval *timeout);
// int vsnprintf(char *s, size_t maxlen, const char *format, __gnuc_va_list arg);
// char *strerror(int errnum);
// int tcsetattr(int fd, int optional_actions, const struct termios *termios_p);
// struct passwd *getpwuid(__uid_t uid);
// int __cdecl __deregister_frame_info_bases(_DWORD); weak
// int *__errno_location(void);
// int ftell(FILE *stream);
// _DWORD std::string::c_str(std::string *this); idb
// int system(const char *command);
// int chmod(const char *file, __mode_t mode);
// int tolower(int c);
// int access(const char *name, int type);
// int __cdecl std::string::operator=(_DWORD, _DWORD); weak
// void *malloc(size_t size);
// _DWORD __cdecl std::string::~string(std::string *this); idb
// size_t fread(void *ptr, size_t size, size_t n, FILE *stream);
// void *memmove(void *dest, const void *src, size_t n);
// int __cdecl std::string::operator[](_DWORD, _DWORD); weak
// ssize_t sendto(int fd, const void *buf, size_t n, int flags, const struct sockaddr *addr, socklen_t addr_len);
// int remove(const char *filename);
// double rint(double x);
// _DWORD std::string::string(std::string *this); idb
// int __sigsetjmp(struct __jmp_buf_tag *env, int savemask);
// int __xstat(int ver, const char *filename, struct stat *stat_buf);
// int setsockopt(int fd, int level, int optname, const void *optval, socklen_t optlen);
// int fseek(FILE *stream, int off, int whence);
// time_t time(time_t *timer);
// int fputs(const char *s, FILE *stream);
// char *strstr(const char *haystack, const char *needle);
// size_t strlen(const char *s);
// void longjmp(struct __jmp_buf_tag env[1], int val);
// unsigned int sleep(unsigned int seconds);
// void qsort(void *base, size_t nmemb, size_t size, __compar_fn_t compar);
// double atof(const char *nptr);
// double atan2(double y, double x);
// int strncmp(const char *s1, const char *s2, size_t n);
// in_addr_t inet_addr(const char *cp);
// double floor(double x);
// int memcmp(const void *s1, const void *s2, size_t n);
// _DWORD __cdecl std::string::erase(std::string *this, unsigned int, unsigned int); idb
// pthread_t pthread_self(void);
// int __cdecl std::string::operator+=(_DWORD, _DWORD); weak
// char *dlerror(void);
// int __cdecl __register_frame_info_bases(_DWORD, _DWORD, _DWORD, _DWORD); weak
// _DWORD __cdecl std::string::find(std::string *this, const char *, unsigned int); idb
// int toupper(int c);
// float sqrtf(float x);
// void *realloc(void *ptr, size_t size);
// char *strcat(char *dest, const char *src);
// double tan(double x);
// char *asctime(const struct tm *tp);
// int printf(const char *format, ...);
// int bind(int fd, const struct sockaddr *addr, socklen_t len);
// __uid_t getuid(void);
// int fcntl(int fd, int cmd, ...);
// void *memcpy(void *dest, const void *src, size_t n);
// double sqrt(double x);
// _DWORD __cdecl std::string::string(std::string *this, const std::string *); idb
// int __cdecl std::allocator<char>::~allocator(_DWORD); weak
// int fclose(FILE *stream);
// char *strrchr(const char *s, int c);
// char *ctime(const time_t *timer);
// int isdigit(int);
// int rmdir(const char *path);
// int closedir(DIR *dirp);
// int gettimeofday(struct timeval *tv, __timezone_ptr_t tz);
// void srand(unsigned int seed);
// DIR *opendir(const char *name);
// int snprintf(char *s, size_t maxlen, const char *format, ...);
// int gethostname(char *name, size_t len);
// struct hostent *gethostbyname(const char *name);
// int strcasecmp(const char *s1, const char *s2);
// int dlclose(void *handle);
// void exit(int status);
// int atoi(const char *nptr);
// int sscanf(const char *s, const char *format, ...);
// void free(void *ptr);
// int ioctl(int fd, unsigned int request, ...);
// uint16_t htons(uint16_t hostshort);
// char *getcwd(char *buf, size_t size);
// int __stdcall __cxa_begin_catch(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD); weak
// int isatty(int fd);
// double acos(double x);
// void *memset(void *s, int c, size_t n);
// void _exit(int status);
// int strncasecmp(const char *s1, const char *s2, size_t n);
// char *strncpy(char *dest, const char *src, size_t n);
// int __cdecl std::string::operator+=(_DWORD, _DWORD); weak
// FILE *fopen(const char *filename, const char *modes);
// _DWORD __cdecl operator new[](unsigned int); idb
// void __cdecl operator delete[](void *); idb
// int sprintf(char *s, const char *format, ...);
// size_t fwrite(const void *ptr, size_t size, size_t n, FILE *s);
// double sin(double x);
// int socket(int domain, int type, int protocol);
// struct dirent *readdir(DIR *dirp);
// int rand(void);
// double log(double x);
// int tcgetattr(int fd, struct termios *termios_p);
// ssize_t read(int fd, void *buf, size_t nbytes);
// __uid_t geteuid(void);
// int __gmon_start__(void); weak
// double ceil(double x);
// void *dlopen(const char *file, int mode);
// char *strcpy(char *dest, const char *src);
void sub_804A4E0();
int sub_804A540();
int __cdecl sub_804A5A4(int a1);
void *__cdecl sub_804A5E8(size_t n);
void __cdecl sub_804A61C(int a1);
void SourceError(int a1, char *format, ...);
void SourceWarning(int a1, char *format, ...);
_DWORD *__cdecl sub_804A710(_DWORD *a1, int a2, int a3);
void __cdecl sub_804A782(_DWORD *a1, _DWORD *a2, _DWORD *a3);
void __cdecl sub_804A81E(int a1, int a2);
_DWORD *__cdecl sub_804A898(void *src);
void __cdecl sub_804A908(int a1);
int __cdecl sub_804A922(int, void *dest); // idb
int __cdecl sub_804AA78(int, void *src); // idb
signed int __cdecl sub_804AAB2(int a1, _DWORD *a2, int a3, int a4);
int __cdecl sub_804AE5A(int, char *dest); // idb
int __cdecl sub_804AF18(char *dest, char *src); // idb
int __cdecl sub_804AFB8(int a1);
int *__cdecl sub_804B018(int *a1, int a2);
int __cdecl sub_804B05A(int, char *s2); // idb
int __cdecl sub_804B0C0(int, char *s2); // idb
int __cdecl sub_804B10C(int, char *s2); // idb
void __cdecl sub_804B168(int a1);
int __cdecl sub_804B1DC(int a1);
int __cdecl sub_804B2DA(int, void *src, int, int, int); // idb
int __cdecl sub_804B550(int, void *, int, int, int); // idb
int __cdecl sub_804BA0A(int, void *, int); // idb
char *__cdecl sub_804BA84(char *a1);
signed int __cdecl sub_804BB0E(int a1);
int __cdecl sub_804BD8C(int, char *s1); // idb
_BOOL4 __cdecl sub_804BE88(int a1);
_DWORD *__cdecl sub_804BEB8(_DWORD *a1);
signed int __cdecl sub_804BEE4(int a1);
signed int __cdecl sub_804C0A4(int a1);
int __cdecl sub_804C640(char *s); // idb
int __cdecl sub_804C7DA(int, char *s); // idb
int __cdecl sub_804C822(char *s); // idb
int __cdecl sub_804C866(char *s2); // idb
int sub_804C8AA();
int __cdecl sub_804C8E4(int a1, int a2);
int __cdecl sub_804CA40(int a1);
signed int __cdecl sub_804CA90(_DWORD *a1, int a2);
signed int __cdecl sub_804CB86(_DWORD *a1);
signed int __cdecl sub_804CBA2(_DWORD *a1);
signed int __cdecl sub_804CBBE(_DWORD *a1);
signed int __cdecl sub_804CC4E(_DWORD *a1);
signed int __cdecl sub_804CC9C(int a1);
signed int __cdecl sub_804CDAC(int a1, char *a2, _DWORD *a3, double *a4, int a5);
signed int __cdecl sub_804DD32(int a1, _DWORD *a2, double *a3, int a4);
signed int __cdecl sub_804E07C(int a1, _DWORD *a2, double *a3, int a4);
signed int __cdecl sub_804E428(_DWORD *a1);
signed int __cdecl sub_804E4D4(_DWORD *a1);
int __cdecl sub_804E53C(int a1);
int __cdecl sub_804E55C(int a1);
signed int __cdecl sub_804E5B4(int a1);
int __cdecl sub_804E5F0(int a1);
signed int __cdecl sub_804E668(int a1);
signed int __cdecl sub_804E758(int a1);
signed int __cdecl sub_804E83E(int a1);
signed int __cdecl sub_804E95A(int a1);
signed int __cdecl sub_804EA56(int a1);
signed int __cdecl sub_804EB7E(int a1);
int __cdecl sub_804ECB0(int, char *s); // idb
int __cdecl sub_804EEAC(int, char *s2); // idb
int __cdecl sub_804EF50(int, int, int, char *s); // idb
int __cdecl sub_804F230(int, char *s); // idb
int __cdecl sub_804F274(int, char *s2); // idb
int __cdecl sub_804F2EE(int, int, int, void *dest); // idb
int __cdecl sub_804F380(int, char *s2); // idb
int __cdecl sub_804F3DC(int a1);
int __cdecl sub_804F3FC(int, void *src); // idb
int __cdecl sub_804F416(int, char *src); // idb
_DWORD *__cdecl sub_804F498(char *src);
_DWORD *__cdecl sub_804F580(void *a1, size_t n, char *src);
void __cdecl sub_804F676(_DWORD *a1);
int __cdecl sub_804F7F6(char *src); // idb
signed int __cdecl sub_804F866(signed int a1);
int __cdecl sub_804F8C6(signed int a1, int a2);
int __cdecl sub_804F98C(signed int a1, int a2);
int __cdecl sub_804FA52(int, char *dest, int); // idb
int *sub_804FAEC();
long double __cdecl sub_804FB38(float a1);
int __cdecl sub_804FB54(int a1, int a2);
void sub_804FD26(int a1, char *format, ...);
void sub_804FD90(int a1, char *format, ...);
int __cdecl sub_804FDFA(int a1, int a2);
signed int __cdecl sub_804FE42(int a1);
signed int __cdecl sub_804FF92(int a1, char *a2);
signed int __cdecl sub_80501AA(_DWORD *a1, int a2, int a3);
signed int __cdecl sub_80503CE(int a1, int a2);
int __cdecl sub_805048E(_BYTE *a1, __int16 a2, _DWORD *a3, long double *a4);
signed int __cdecl sub_8050746(int a1, int a2);
signed int __cdecl sub_8050B78(int a1, int a2);
int __cdecl sub_8050C96(int, char *dest); // idb
int __cdecl sub_8050D74(int, void *src); // idb
int __cdecl sub_8050E1C(int, void *dest); // idb
int __cdecl sub_80510BA(int, char *s2); // idb
int __cdecl sub_805115E(int, int, int, void *); // idb
int __cdecl sub_8051488(int, void *dest); // idb
int __cdecl sub_80514CC(int, char *s2); // idb
int __cdecl sub_805153E(int, int, int, void *dest); // idb
int __cdecl sub_80515C6(int, char *s2); // idb
int __cdecl sub_8051632(int, void *src); // idb
char *__cdecl sub_8051694(char *dest);
char *__cdecl sub_80516DE(char *dest);
long double __cdecl sub_8051728(int a1);
int __cdecl sub_80517FA(int a1);
void *__cdecl sub_80518C2(_DWORD *a1);
_BOOL4 __cdecl sub_8051932(int a1);
int __cdecl sub_805195E(int, char *s); // idb
char *__cdecl sub_80519D8(char *src);
char *__cdecl sub_8051B20(void *a1, size_t n, char *src);
void __cdecl sub_8051BEE(int a1);
char *getBuildNumber();
_BOOL4 sub_8051C54();
void *__cdecl sub_8051C66(_DWORD *a1, _DWORD *a2);
int *__cdecl Com_LoadBsp(int a1);
void sub_8051E5C();
void SND_ErrorCleanup();
int __cdecl sub_8051E92(int a1);
signed int __cdecl sub_8051E9C(int a1);
signed int sub_8051F6A();
char *__cdecl sub_8051F7E(char *s);
int __cdecl sub_8051F9E(char *s2, int); // idb
void *CM_Shutdown();
int __cdecl sub_805202A(int a1, int a2);
void __cdecl sub_805208A(int a1, char *a2, int a3, _DWORD *a4);
void *sub_80524EA();
int __cdecl sub_80524F4(int a1);
int __cdecl sub_8052518(int a1, _DWORD *a2, _DWORD *a3);
void *__cdecl sub_8052556(size_t a1);
void sub_805256A();
void sub_8052570();
size_t __cdecl sub_8052576(int a1);
int sub_805258A();
int sub_8052598();
int __cdecl sub_80525A6(_DWORD *a1, _DWORD *a2);
int __cdecl sub_80525D6(int a1);
int __cdecl sub_80525E0(_DWORD *a1);
_DWORD *sub_8052728();
int __cdecl sub_8052768(_DWORD *a1);
long double __cdecl sub_80529AE(int a1, int a2, int a3, int a4, int a5, float *a6);
_DWORD *__cdecl sub_8052B12(void *src, int a2, int a3, int a4);
void __cdecl sub_8052FD4(void *src, int a2, int a3);
int __cdecl sub_805319E(unsigned __int16 *a1);
int __cdecl sub_8053200(int a1);
signed int __cdecl sub_8053354(_DWORD *a1);
int __cdecl sub_80534B8(_DWORD *a1, _DWORD *a2);
signed int __cdecl sub_80538BC(_DWORD *a1, char a2);
int __cdecl sub_8053A80(int a1);
int __cdecl sub_8053B7E(int a1, _DWORD *a2);
int __cdecl sub_8053D34(_DWORD *a1);
int __cdecl sub_8053E0E(_DWORD *a1);
int __cdecl sub_8053EC2(_DWORD *a1);
signed int __cdecl sub_8053FC0(_DWORD *a1);
signed int __cdecl sub_8054220(_DWORD *a1);
signed int __cdecl sub_805448C(_DWORD *a1);
signed int __cdecl sub_805461E(_DWORD *a1);
int __cdecl sub_805474E(_DWORD *a1);
void *__cdecl sub_80548DC(size_t *a1);
void *__cdecl sub_8054936(int *a1);
int __cdecl sub_8054A26(_DWORD *a1, char a2);
void *__cdecl sub_8054B6C(char *s, int a2);
int sub_8054D08();
void Com_CleanupBsp();
size_t __cdecl sub_8054E72(int a1, _DWORD *a2);
void sub_8054FE2();
long double __cdecl sub_8054FF8(float a1);
int __cdecl sub_8055012(float, float); // idb
int __cdecl sub_8055036(float, float); // idb
int __cdecl sub_805505A(int a1, int a2);
int __cdecl sub_8055080(int a1);
int __cdecl sub_805508A(_DWORD *a1, int a2, int a3, int a4);
int __cdecl sub_80550AE(_DWORD *a1, _DWORD *a2);
int __cdecl sub_80550DE(int, float, int); // idb
double __cdecl sub_8055116(_DWORD); // weak
int __cdecl sub_8055154(__int16 a1);
int __cdecl sub_8055168(int a1);
double __cdecl sub_8055170(_DWORD); // weak
long double __cdecl sub_8055184(float a1, float a2, float a3);
long double __cdecl sub_80551AE(float a1);
int __cdecl sub_80551CE(int a1, int a2, int a3);
long double __cdecl sub_80551EE(float a1);
_BOOL4 __cdecl sub_8055200(int a1, float *a2, float *a3);
void __cdecl sub_80553B2(int a1, float *a2, int a3);
void __cdecl sub_80558EC(int a1, int a2, int a3);
int __cdecl sub_8055B48(int a1, int a2, int a3);
void __cdecl sub_8055C74(int a1, int a2, int a3);
void __cdecl sub_8055CFE(int a1, int a2, int a3);
signed int __cdecl sub_8055D4C(int a1, unsigned __int16 *a2, int a3);
signed int __cdecl sub_8055E02(float *a1, float *a2, float *a3, float *a4, float *a5, float *a6, float *a7, float *a8);
long double __cdecl sub_8055F88(float a1);
int __cdecl sub_8055FA2(_DWORD *a1, _DWORD *a2);
int __cdecl sub_8055FD2(float *a1, float *a2, float *a3);
int __cdecl sub_8056016(float *a1, float *a2, float *a3);
int __cdecl sub_805605A(int, float, int, int); // idb
long double __cdecl sub_80560AE(float *a1, float *a2);
long double __cdecl sub_80560E2(float *a1);
void __cdecl sub_8056116(float *a1, float *a2, int a3);
void __cdecl sub_805628C(int a1, int a2, float a3, int a4);
void __cdecl sub_8056E42(float *a1, int a2, int a3);
long double __cdecl sub_805739C(float a1);
int __cdecl sub_80573BC(float, float); // idb
int __cdecl sub_80573E0(float *a1, float *a2, float *a3);
long double __cdecl sub_805740C(float *a1, float *a2);
long double __cdecl sub_805742E(float *a1);
int __cdecl sub_8057450(_DWORD *a1, int a2, int a3, int a4);
int __cdecl sub_8057474(int, float, int); // idb
long double __cdecl sub_80574AC(float a1, float a2, float a3);
void *__cdecl sub_80574D8(int a1);
void __cdecl sub_8057520(void *ptr);
float *__cdecl sub_8057656(int a1, float a2);
void *__cdecl sub_80578D2(void *src);
int *__cdecl sub_805791A(int a1, int a2, float a3, float a4);
long double __cdecl sub_8057DB2(float a1);
int __cdecl sub_8057DCC(_DWORD *a1, _DWORD *a2);
int __cdecl sub_8057DFC(float *a1, float *a2, float *a3);
int __cdecl sub_8057E40(float *a1, float *a2, float *a3);
int __cdecl sub_8057E84(int, float, int); // idb
int __cdecl sub_8057EBC(int, float, int, int); // idb
long double __cdecl sub_8057F10(float *a1, float *a2);
void *__cdecl sub_8057F44(size_t a1);
void *__cdecl sub_8057F58(size_t a1);
int __cdecl sub_8057F6C(char *s2);
signed int __cdecl sub_8057F90(int a1, int a2, float *a3, float *a4, int a5);
unsigned int __cdecl sub_805809A(int a1, float *a2, float *a3, int a4);
int __cdecl sub_8058162(_DWORD *a1, _DWORD *a2);
int __cdecl sub_8058192(float *a1, float *a2, float *a3);
signed int __cdecl sub_80581D8(int a1, float *a2, float *a3, float *a4);
signed int __cdecl sub_80582EC(int a1, char *a2, float *a3, float *a4, float *a5);
char *sub_80583FA();
int __cdecl sub_80588E0(_DWORD *a1, _DWORD *a2);
int __cdecl sub_8058910(float *a1, float *a2, float *a3);
int __cdecl sub_8058954(int, float, int); // idb
int __cdecl sub_805898C(float *a1, int a2);
int __cdecl sub_8058A2C(float *a1);
int __cdecl sub_8058A48(_DWORD *a1, int a2);
int __cdecl sub_8058ABE(int a1, int a2);
int __cdecl sub_8058B66(_DWORD *a1, _DWORD *a2, int a3, int a4, _DWORD *a5);
int __cdecl sub_8058BD8(float *a1, unsigned __int8 *a2);
int __cdecl sub_8058D88(float *a1, int a2);
int __cdecl sub_8058E94(float *a1, int a2, float *a3, float *a4);
char *__cdecl sub_8058F82(int a1);
int __cdecl sub_8058FC4(_DWORD *a1, _DWORD *a2);
int __cdecl sub_8058FF4(float *a1, float *a2, float *a3);
long double __cdecl sub_8059038(float *a1, float *a2);
int __cdecl sub_805906C(_DWORD *a1);
int __cdecl sub_80590B0(_DWORD *a1, _DWORD *a2);
signed int __cdecl sub_80590DE(_DWORD *a1, _DWORD *a2, int a3);
int __cdecl sub_8059154(int a1);
int __cdecl sub_805919A(int a1);
long double __cdecl sub_80591BC(int a1);
int __cdecl sub_80591DE(int a1, float *a2);
int *__cdecl sub_805924A(int a1, int a2);
unsigned int __cdecl sub_80592B6(float *a1, int a2);
void __cdecl sub_80592F2(float *a1, int a2, int a3);
int __cdecl sub_8059432(int a1, unsigned __int8 *a2, int a3);
int __cdecl sub_80595CA(int a1, int a2, int a3);
int __cdecl sub_8059674(int a1, int a2, int a3);
void __cdecl sub_80596DA(int a1, int a2);
int __cdecl sub_8059A48(float *a1, int a2);
void __cdecl sub_8059BBC(float *a1, _DWORD *a2, int a3);
void __cdecl sub_8059FDC(int a1, unsigned __int8 *a2, _DWORD *a3, float *a4, float *a5);
_BOOL4 __cdecl sub_805A3A4(int a1, int a2, float *a3);
void __cdecl sub_805A4AA(int a1, unsigned __int16 *a2, float *a3);
int __cdecl sub_805A564(int, int, int, int, float, int); // idb
int __cdecl sub_805A75A(int, int, float, float, int); // idb
void __cdecl sub_805AA0E(int a1, int a2);
void __cdecl sub_805AE54(int a1, int a2, _DWORD *a3, float *a4, float *a5);
_BOOL4 __cdecl sub_805B198(int a1);
void __cdecl sub_805B210(int a1, float *a2, float *a3, int a4, int a5, int a6, int a7);
void __cdecl sub_805B690(void *s, int a2, int a3, int a4, int a5, int a6, int a7);
void __cdecl sub_805B6F2(float *a1, int a2, int a3, int a4, int a5, int a6, int a7, float *a8, float *a9);
void __cdecl sub_805B972(void *s, int a2, int a3, int a4, int a5, int a6, int a7, int a8, int a9);
int __cdecl sub_805B9E2(float *a1, int a2);
int __cdecl sub_805BCEE(int a1, unsigned __int8 *a2, _DWORD *a3, float *a4);
int __cdecl sub_805C0BC(int a1, int a2);
int __cdecl sub_805C16E(int a1, unsigned __int16 *a2, float *a3);
_BOOL4 __cdecl sub_805C23C(int a1, int a2, int a3, int a4, float a5, int a6);
_BOOL4 __cdecl sub_805C370(int a1, int a2, float a3, float a4, int a5);
signed int __cdecl sub_805C534(int a1, int a2);
int __cdecl sub_805C9DE(int a1, int a2, _DWORD *a3, float *a4, float *a5);
int __cdecl sub_805CCFA(int a1, int a2, int a3, int a4, int a5, int a6, int a7);
int __cdecl sub_805D124(int a1, int a2, int a3, int a4, int a5, int a6, int a7, float *a8, float *a9);
long double __cdecl sub_805D34E(float a1, float a2, float a3);
long double __cdecl sub_805D378(float a1);
long double __cdecl sub_805D392(float a1);
_BOOL4 __cdecl sub_805D3B2(float a1);
int __cdecl sub_805D3CA(float, float); // idb
int __cdecl sub_805D3EE(float, float); // idb
long double __cdecl sub_805D412(float *a1, float *a2);
int __cdecl sub_805D434(_DWORD *a1);
int __cdecl sub_805D45E(_DWORD *a1, _DWORD *a2);
unsigned int __cdecl sub_805D48E(_DWORD *a1);
int __cdecl sub_805D4CC(float *a1, float *a2, float *a3);
int __cdecl sub_805D510(float *a1, float *a2, float *a3);
long double __cdecl sub_805D554(float *a1, float *a2);
signed int __cdecl sub_805D588(float *a1, float *a2);
long double __cdecl sub_805D5F2(float *a1);
int __cdecl sub_805D626(_DWORD *a1, _DWORD *a2);
int *__cdecl sub_805D668(int a1);
signed int __cdecl sub_805D6DC(int a1, int a2, int a3, float a4);
int __cdecl sub_805D852(float, float); // idb
int __cdecl sub_805D876(float, float); // idb
long double __cdecl sub_805D89A(float a1, float a2, float a3);
int __cdecl sub_805D8C4(float *a1, float *a2);
__int64 sub_805D9A8();
int sub_805DA8E();
int __cdecl sub_805DAA0(unsigned __int16 *a1);
int __cdecl sub_805DCC8(unsigned __int16 *a1, unsigned __int16 a2);
int __cdecl sub_805DD50(_WORD *a1, unsigned __int16 a2);
int __cdecl sub_805DDD0(int a1, float *a2, float *a3);
int __cdecl sub_805E18C(int a1, _DWORD *a2, _DWORD *a3, int a4);
int __cdecl sub_805E3D8(int a1);
int sub_805E51A();
void __cdecl sub_805E56A(unsigned __int16 a1, int a2);
int __cdecl sub_805E782(int a1, int a2, int a3, int a4, int a5);
void __cdecl sub_805E7C6(int a1, unsigned __int16 a2, _DWORD *a3, float *a4, float *a5);
void __cdecl sub_805EA28(float *a1, _DWORD *a2, _DWORD *a3, int a4);
signed int __cdecl sub_805EAD0(int a1, unsigned __int16 a2, _DWORD *a3, float *a4);
signed int __cdecl sub_805ED1E(_DWORD *a1, _DWORD *a2, int a3);
void __cdecl sub_805ED88(int a1, unsigned __int16 a2, _DWORD *a3, float *a4, float *a5);
void __cdecl sub_805F0A4(int a1, float *a2);
int __cdecl sub_805F10E(_DWORD *a1, unsigned __int16 a2, _DWORD *a3, float *a4);
int __cdecl sub_805F3F6(int a1);
void __cdecl sub_805F42C(int a1, unsigned __int16 a2, _DWORD *a3, float *a4, float *a5);
void __cdecl sub_805F61E(_DWORD *a1, float *a2);
signed int __cdecl sub_805F686(_DWORD *a1, unsigned __int16 a2, float *a3, float *a4);
signed int __cdecl sub_805F8C6(int a1);
long double __cdecl sub_805F8F8(float a1, float a2, float a3);
long double __cdecl sub_805F922(float a1);
_BOOL4 __cdecl sub_805F93C(float a1);
int __cdecl sub_805F954(float, float); // idb
int __cdecl sub_805F978(float, float); // idb
int __cdecl sub_805F99C(_DWORD *a1, _DWORD *a2);
int __cdecl sub_805F9BC(float *a1, float *a2, float *a3);
int __cdecl sub_805F9E8(_DWORD *a1, _DWORD *a2);
int __cdecl sub_805FA18(_DWORD *a1, _DWORD *a2);
int sub_805FA5E();
int *Cbuf_Init();
void __cdecl Cbuf_AddText(char *s);
void __cdecl Cbuf_InsertText(char *s);
// void __usercall Cbuf_ExecuteText(long double fst7_0@<st0>, int a1, char *s);
// int __usercall sub_805FCB2@<eax>(long double a1@<st0>);
// int __usercall Cbuf_Execute@<eax>(long double a1@<st0>);
signed int __cdecl sub_805FE0A(_BYTE *a1);
void sub_805FE66();
void sub_805FEF2();
void sub_805FF92();
int Cmd_Argc();
int sub_805FFE6();
char *__cdecl Cmd_Argv(unsigned int a1);
char *__cdecl sub_806001C(unsigned int a1);
char *__cdecl sub_8060048(int a1, char *dest, int a3);
char *__cdecl sub_8060074(int a1, char *dest, int a3);
char *__cdecl sub_80600A0(int a1);
char *__cdecl sub_8060118(char *dest, int a2);
int __cdecl Cmd_TokenizeStringInternal(_BYTE *a1, int a2, int a3, _BYTE *a4);
int __cdecl sub_80603CC(_BYTE *a1, int a2);
int __cdecl sub_80603FC(_BYTE *a1, int a2);
int __cdecl Cmd_TokenizeString(_BYTE *a1);
int __cdecl sub_8060448(_BYTE *a1);
int __cdecl sub_8060464(char *s1); // idb
void __cdecl Cmd_AddCommand(char *s1, int a2);
void __cdecl Cmd_RemoveCommand(char *s1);
int __cdecl sub_8060598(char *s1, int, int); // idb
void sub_80605C0();
int __cdecl sub_8060604(void (__cdecl *a1)(int));
_DWORD *__cdecl sub_8060634(char *s1, int a2);
// int __usercall Cmd_ExecuteString@<eax>(long double a1@<st0>, _BYTE *a2);
// int __usercall sub_8060754@<eax>(long double a1@<st0>, _BYTE *a2);
void sub_8060768();
void Cmd_Init();
size_t __cdecl FS_FileRead(void *ptr, size_t size, size_t n, FILE *stream);
size_t __cdecl FS_FileWrite(void *ptr, size_t size, size_t n, FILE *s);
FILE *__cdecl FS_FileOpen(char *filename, char *modes);
int __cdecl FS_FileClose(FILE *stream); // idb
int __cdecl FS_FileSeek(FILE *stream, int off, int whence); // idb
int Hunk_ClearTempMemoryHigh();
void sub_8060924();
char *__cdecl sub_806092A(char *a1, int a2, int a3);
int sub_8060964();
void CL_SwitchToLocalClient();
void __cdecl Com_PrintMessage(int a1, char *s);
void Com_Printf(char *format, ...);
void Com_DPrintf(char *format, ...);
// void *__usercall Com_ShutdownInternal@<eax>(long double a1@<st0>, int a2);
// void *__usercall sub_8060BFA@<eax>(long double a1@<st0>, int a2);
int Hunk_ClearTempMemory();
int __cdecl sub_8060C2E(char *s2); // idb
// void __usercall Com_SetErrorMessage(long double a1@<st0>, char *src);
// void *__usercall Com_ErrorCleanup@<eax>(long double a1@<st0>);
void __noreturn Com_Error(int a1, char *format, ...);
// void __usercall __noreturn Com_Quit_f(long double a1@<st0>);
char *__cdecl Com_ParseCommandLine(char *a1);
signed int Com_SafeMode();
// int __usercall Com_StartupVariable@<eax>(long double a1@<st0>, char *s2);
signed int Com_AddStartupCommands();
void __cdecl sub_80611E6(char *a1);
void *Com_InitPushEvent();
int __cdecl sub_806136C(int *a1);
int sub_806141C();
_DWORD *__stdcall sub_8061498(_DWORD *a1);
// int __usercall sub_8061526@<eax>(long double a1@<st0>);
int sub_80617B4();
int Com_Milliseconds();
int sub_80618CE();
void __noreturn sub_806191E();
void sub_806195A();
void sub_80619C8();
bool Scr_Settings();
void Com_SetCinematic();
// void __usercall Com_InitDvars(long double a1@<st0>);
// int __usercall Com_RunAutoExec@<eax>(long double a1@<st0>);
// int __usercall Com_ExecStartupConfigs@<eax>(long double a1@<st0>, int a2);
// int __usercall Com_InitPlayerProfiles@<eax>(long double a1@<st0>);
// void __usercall Com_Init_Try_Block_Function(long double a1@<st0>, char *a2);
// void __usercall Com_Init(long double a1@<st0>, char *a2);
void __cdecl Com_WriteConfigToFile(char *src);
void __cdecl Com_WriteDefaultConfigToFile(char *src);
void sub_8062112();
void Com_WriteConfig_f();
void Com_WriteDefaults_f();
signed int __cdecl sub_806228A(signed int a1);
int sub_80623A4();
// void __usercall Com_Frame_Try_Block_Function(long double a1@<st0>);
void sub_80624CC();
int sub_80624D2();
// void __usercall Com_Frame(long double a1@<st0>);
void *Com_CloseLogFile();
void Com_Close();
_DWORD *__cdecl sub_8062590(_DWORD *a1);
// void *__usercall Com_Restart@<eax>(long double a1@<st0>);
int __cdecl sub_8062622(int a1);
_DWORD *__cdecl sub_806263E(int a1);
int __cdecl sub_806265A(_DWORD *a1);
int __cdecl sub_8062676(int a1);
void __cdecl sub_8062684(int a1);
int __cdecl sub_80626A8(_BYTE *a1, int a2, int a3, int a4, int a5);
signed int sub_8062782();
int __cdecl sub_806278C(float, char *s, int, int); // idb
int __cdecl sub_8062808(float); // idb
void sub_806283E();
int __cdecl sub_8062844(int a1, int a2);
int __cdecl sub_806289C(int a1);
int sub_80628E4();
int __cdecl sub_8062988(signed __int16 ***a1, unsigned __int16 a2, int a3, int a4);
int *sub_8062A0C();
int __cdecl sub_8062A66(signed __int16 ***a1, unsigned __int16 a2, int a3, int a4);
int __cdecl sub_8062AEC(int a1);
int __cdecl sub_8062B4C(int a1);
void *Com_InitDObj();
void Com_ShutdownDObj();
void sub_8062C40();
int __cdecl sub_8062C50(void (__cdecl *a1)(_DWORD));
int __cdecl Dvar_GetCombinedString(char *s, int a2);
// signed int __usercall Dvar_Command@<eax>(long double a1@<st0>);
signed int __cdecl sub_8062E4C(int a1);
// signed int __usercall sub_8063088@<eax>(long double a1@<st0>);
// signed int __usercall Dvar_Toggle_f@<eax>(long double a1@<st0>);
// void __usercall Dvar_TogglePrint_f(long double a1@<st0>);
// void __usercall Dvar_Set_f(long double a1@<st0>);
// void __usercall Dvar_RegisterBool_f(long double a1@<st0>);
// void __usercall Dvar_RegisterInt_f(long double a1@<st0>);
void Dvar_RegisterFloat_f();
// void __usercall Dvar_SetU_f(long double a1@<st0>);
// void __usercall Dvar_SetS_f(long double a1@<st0>);
// void __usercall Dvar_SetA_f(long double a1@<st0>);
// void __usercall Dvar_SetFromDvar_f(long double a1@<st0>);
void Dvar_Reset_f();
int __cdecl Dvar_WriteVariables(int a1);
int __cdecl Dvar_WriteDefaults(int a1);
void Dvar_List_f();
void __cdecl Com_DvarDump(int a1);
void Dvar_Dump_f();
int __cdecl sub_8063CD4(int a1, int a2, unsigned __int16 a3);
char *__cdecl sub_8063D30(unsigned __int16 a1);
char *__cdecl sub_8063D92(unsigned __int16 a1);
void sub_8063DF4();
signed int __cdecl sub_8063F00(char *a1);
int __cdecl FS_SV_FOpenFileWrite(char *src); // idb
int __cdecl FS_SV_FOpenFileRead(char *src, int); // idb
int __cdecl FS_SV_Rename(char *a1, char *a2);
void *__cdecl sub_806451C(char *s, char a2);
signed int __cdecl sub_8064574(int a1, unsigned int a2, int a3);
int __cdecl sub_8064616(_DWORD *a1);
_DWORD *__cdecl sub_8064644(void *ptr, void *a2, void *a3);
int __cdecl FS_GetModList(char *, int); // idb
void FS_Dir_f();
void FS_NewDir_f();
void FS_TouchFile_f();
int __cdecl sub_8064ECC(char *haystack, int); // idb
signed int __cdecl sub_8064FF8(char *a1, int a2, int a3);
void sub_80652E2();
void FS_AddCommands();
// _DWORD *__usercall FS_SetRestrictions@<eax>(long double a1@<st0>);
char *sub_8065448();
char *sub_80654C0();
char *sub_806554C();
char *sub_80655C4();
char *sub_8065670();
char *sub_8065774();
void *__cdecl FS_PureServerSetLoadedIwds(_BYTE *a1, _BYTE *a2);
int __cdecl sub_8065AD2(_BYTE *a1, _BYTE *a2);
void *__cdecl sub_8065BE0(char *s);
int __cdecl sub_8065D50(char a1, int a2);
int __cdecl sub_8065DBA(int a1);
int __cdecl sub_8065DEE(int a1);
_DWORD *__cdecl sub_8065E3E(int a1, _DWORD *a2);
_DWORD *__cdecl sub_8065E5E(int a1, int a2, int a3);
int __cdecl sub_8065EE6(int a1, int a2);
void __cdecl sub_8065FA6(int a1, int a2);
void __cdecl sub_806610E(_DWORD *a1, unsigned __int8 a2);
int __cdecl sub_8066394(_DWORD *a1, _DWORD *a2, int a3);
int __cdecl sub_80663F6(_DWORD *a1, _DWORD *a2, int a3, int *a4);
int __cdecl sub_8066466(int a1, int a2, int a3);
int *__cdecl sub_80664CC(int a1, int a2, int a3);
int __cdecl sub_8066550(int a1, int a2, int a3, int *a4);
int __cdecl sub_806658E(_DWORD *a1, int a2);
int __cdecl sub_8066838(int a1, int a2);
int __cdecl sub_8066A70(void *s); // idb
_DWORD *__cdecl sub_8066C14(_DWORD *a1);
void *__cdecl sub_8066C54(int a1, void *src, int a3);
void *__cdecl sub_8066D50(int a1, void *s);
void *__cdecl sub_8066E12(int *a1, int a2);
unsigned int __cdecl sub_806751E(int a1, int a2, unsigned int a3);
unsigned int __cdecl sub_80675C6(int a1, int a2, unsigned int a3);
int __cdecl sub_8067642(void *src, int); // idb
int sub_806769E(void *a1, int a2, ...);
int __cdecl sub_8067718(void *s, int, int); // idb
_DWORD *__cdecl sub_806775C(_DWORD *a1);
int *__cdecl sub_80677A2(int *a1, int a2, int a3);
_DWORD *__cdecl sub_8067868(_DWORD *a1);
_DWORD *__cdecl sub_80678C6(_DWORD *a1);
signed int __cdecl sub_8067960(_DWORD *a1, int a2);
signed int __cdecl sub_8067A0E(_DWORD *a1);
int __cdecl sub_8067A8E(unsigned __int8 *a1, int a2, int a3);
int __cdecl sub_8067AE2(int a1, _BYTE *a2, int a3);
_DWORD *__cdecl sub_8067B4C(_DWORD *a1, char a2);
int __cdecl sub_8067B84(int, void *src, size_t n); // idb
_DWORD *__cdecl sub_8067BDA(_DWORD *a1, __int16 a2);
_DWORD *__cdecl sub_8067C2A(_DWORD *a1, int a2);
_DWORD *__cdecl sub_8067C78(_DWORD *a1, int a2, int a3);
int __cdecl sub_8067CE4(int, char *s); // idb
int __cdecl sub_8067D96(int, char *s); // idb
_DWORD *__cdecl sub_8067EA6(int a1, float a2);
signed int __cdecl sub_8067EE8(_DWORD *a1);
signed int __cdecl sub_8067F32(_DWORD *a1);
signed int __cdecl sub_8067F90(_DWORD *a1);
unsigned __int64 __cdecl sub_8067FEC(_DWORD *a1);
void *__cdecl sub_8068062(_DWORD *a1);
void *__cdecl sub_80680CC(_DWORD *a1);
void *__cdecl sub_8068146(_DWORD *a1);
long double __cdecl sub_80681C8(_DWORD *a1);
void *__cdecl sub_80681EC(int a1, void *dest, size_t n);
int *__cdecl sub_806825C(int *a1, int a2, int a3, int a4, int a5);
int __cdecl sub_80682A0(_DWORD *a1, int a2, int a3, int a4);
int *__cdecl sub_80682E8(int *a1, int a2, int a3, int a4);
int __cdecl sub_806830C(_DWORD *a1, int a2, int a3);
_DWORD *__cdecl sub_80683AE(_DWORD *a1, __int16 a2, __int16 a3, __int16 a4);
int __cdecl sub_80683EC(_DWORD *a1, __int16 a2, int a3);
_BYTE *__cdecl sub_8068424(char *s, int a2, int a3);
void __cdecl sub_80684E6(int a1, void *s);
int __cdecl sub_8068660(signed int a1, signed int a2);
_BYTE *__cdecl sub_80686A6(char a1, _BYTE *a2, _BYTE *a3);
_BYTE *__cdecl sub_8068ADE(_DWORD *a1, int a2, int a3, int a4);
int *__cdecl sub_8068E1C(int *a1, int a2, int a3, int a4);
_DWORD *__cdecl sub_8069142(int *a1, int a2, int a3, int a4, signed int a5, int a6);
_DWORD *__cdecl sub_80691FC(int *a1, int *a2, int *a3, int a4, signed int a5, int a6, int a7, int a8);
_DWORD *__cdecl sub_806938C(int *a1, int *a2, int *a3, int a4);
_DWORD *__cdecl sub_80693DA(int *a1, int *a2, int *a3, int a4);
_DWORD *__cdecl sub_8069428(int *a1, int *a2, int *a3, int a4);
void __cdecl sub_80694A0(_DWORD *a1, int a2, int a3, _DWORD *a4, int a5);
int __cdecl sub_80697D8(_DWORD *a1, int a2, int a3, int a4, int a5);
int __cdecl sub_806988A(int, void *src, void *dest, int, int, int, int); // idb
int __cdecl sub_80699C8(int, void *src, void *dest, int); // idb
int __cdecl sub_8069A0E(int, void *src, void *dest, int); // idb
int __cdecl sub_8069A54(int, void *src, void *dest, int); // idb
int __cdecl sub_8069AC4(int *a1, int a2, int a3, int a4);
void *__cdecl sub_8069C10(_DWORD *a1, int a2, int a3, int a4);
_DWORD *__cdecl sub_8069D40(int *a1, char *a2, _DWORD *a3);
void *__cdecl sub_806A608(_DWORD *a1, char *a2, char *a3);
int *sub_806AC6A();
int *sub_806ACDE();
int __cdecl sub_806ACF6(__int16 a1);
int __cdecl sub_806AD0A(int a1);
char *__cdecl sub_806AD14(int a1, int a2, int a3, int a4, int a5);
void *__cdecl sub_806AE1A(void **a1);
int __cdecl sub_806AF0A(int a1, int a2, int a3);
void __cdecl sub_806AF90(int a1, int a2, int a3);
void __cdecl sub_806B012(int a1, int a2, int a3);
_DWORD *__cdecl sub_806B09A(_DWORD *a1);
void sub_806B3D2();
// void __usercall Netchan_Init(long double a1@<st0>, unsigned __int16 a2);
void *__cdecl sub_806B510(int a1, void *s, int a3, int a4, int a5, int a6, int a7, int a8);
_BOOL4 __cdecl sub_806B58C(int a1);
_BOOL4 __cdecl sub_806B7AC(int a1, size_t n, void *src);
signed int __cdecl sub_806B9CA(int a1, _DWORD *a2);
int __cdecl sub_806BE8E(int a1, int a2);
_BOOL4 __cdecl sub_806BF64(char a1, int a2, int a3, int a4, int a5, char a6);
int __cdecl sub_806BF92(int a1, int a2);
_BOOL4 __cdecl sub_806C08C(char a1, int a2, int a3, int a4, int a5, char a6);
signed int __cdecl sub_806C0BA(int a1);
signed int __cdecl sub_806C0E0(int *a1, int a2);
int __cdecl sub_806C0FA(int, void *s, int); // idb
int __cdecl sub_806C240(int, void *s, int); // idb
int __cdecl sub_806C262(int, size_t n, void *src, int, int, __int16); // idb
int __cdecl sub_806C32C(int a1, size_t n, void *src, int a4, int a5, int a6, int a7, int a8);
_BOOL4 __cdecl sub_806C40C(int a1, int a2, int a3, int a4, int a5, int a6, char *s);
_BOOL4 __cdecl sub_806C57E(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8);
int __cdecl sub_806C69C(int a1, int a2, int a3, int a4, int a5, int a6, void *src, size_t n);
int __cdecl sub_806C750(char *s1, void *s); // idb
int __cdecl sub_806C8B8(int a1);
int sub_806C8C0();
void *sub_806C8EA();
int __cdecl sub_806C918(int a1);
char *__cdecl sub_806C926(int a1);
int sub_806C95E();
int __cdecl sub_806CA12(_DWORD *a1, unsigned int a2, int a3);
char *__cdecl sub_806CA94(_DWORD *a1, unsigned int a2, int a3);
int __cdecl sub_806CADC(int a1, int a2, char a3, char a4, char a5);
_DWORD *__cdecl sub_806CE74(int a1, int a2, int a3);
void *__cdecl sub_806CED4(size_t n);
int __cdecl sub_806CEF0(int a1);
int __cdecl sub_806CF7E(int a1, __int16 a2, int a3, int a4, __int16 a5);
int __cdecl sub_806D074(int a1);
int __cdecl sub_806D084(int, int, int, int, char *s, int, int, int); // idb
int __cdecl sub_806D2DC(int a1, int a2);
int __cdecl sub_806D3B4(int a1);
int __cdecl sub_806D43C(char *a1, int *a2, int a3);
char *__cdecl sub_806D55A(char *a1, int a2);
_BOOL4 __cdecl sub_806D5A6(int a1, int a2, int a3);
int __cdecl sub_806D668(int a1, int a2, int a3);
// _DWORD *__userpurge sub_806D8CE@<eax>(_DWORD *a1, char *a2);
int __cdecl sub_806D982(char *a1, char *s, _DWORD *a3, int a4);
int __cdecl sub_806D9EC(int a1);
int __cdecl sub_806DA0A(int a1);
int __cdecl sub_806DA66(int a1);
int __cdecl sub_806DA94(int a1, unsigned __int8 a2);
int __cdecl sub_806DAD8(int a1, int a2, int a3);
int sub_806DEC6();
int sub_806DEEA();
int __cdecl sub_806DF0E(int a1);
int __cdecl sub_806DF32(unsigned __int16 a1);
int __cdecl sub_806DF60(unsigned __int16 a1);
int __cdecl sub_806DF8E(unsigned __int8 a1);
int __cdecl sub_806DFBA(int a1);
int __cdecl sub_806DFDE(int a1);
int __cdecl sub_806E004(int a1);
int __cdecl sub_806E028(int a1, int a2);
void __cdecl sub_806E042(int a1);
int __cdecl sub_806E07A(int a1, int a2, _DWORD *a3);
void __cdecl sub_806E09C(signed int a1, int a2);
int __cdecl sub_806E250(int a1, int a2, _DWORD *a3);
int __cdecl sub_806E272(int a1, int a2);
void __cdecl sub_806E2B4(int a1);
void __cdecl sub_806E2EE(int a1);
signed int __cdecl sub_806E326(int a1, int a2, int a3);
int __cdecl sub_806E36A(int a1, int a2, char a3, int a4);
int __cdecl sub_806E4CA(int a1);
int __cdecl sub_806E53A(_DWORD *a1, int a2);
int __cdecl sub_806E59A(char a1, int a2, _DWORD *a3);
void __cdecl sub_806E5EC(signed int a1);
void __cdecl sub_806E614(signed int a1);
_DWORD *__cdecl sub_806E638(_DWORD *a1, int a2, _DWORD *a3);
_DWORD *__cdecl sub_806E69A(_DWORD *a1, size_t *a2);
int __cdecl sub_806E714(int a1, signed int a2, int a3);
void __cdecl sub_806E846(int a1, signed int a2, _DWORD *a3);
void __cdecl sub_806E94E(int a1, int a2, _DWORD *a3);
_DWORD *__cdecl sub_806EA5A(int a1, _DWORD *a2);
void __cdecl sub_806EB94(int a1, int a2, int a3);
_DWORD *__cdecl sub_806EC16(_DWORD *a1, int a2, _DWORD *a3);
void __cdecl sub_806EC38(int a1, int a2, int a3);
int __cdecl sub_806ECA0(int a1, int a2, _DWORD *a3);
int __cdecl sub_806ECC2(int a1, int a2);
int __cdecl sub_806ED18(int a1, int a2, _DWORD *a3);
int __cdecl sub_806ED3A(int a1, int a2);
int __cdecl sub_806ED90(int a1, int a2);
void __cdecl sub_806EE00(int *a1);
char *__cdecl sub_806EEC6(int *a1);
void sub_806EF26();
void __cdecl sub_806EF32(int a1);
void __cdecl sub_806EF6A(int a1);
void __cdecl sub_806EFA2(int a1);
void __cdecl sub_806EFDA(int a1, int a2, int a3);
void __cdecl sub_806F024(int a1);
void __cdecl sub_806F05C(int a1);
void __cdecl sub_806F094(int a1);
void __cdecl sub_806F0CC(int a1);
void __cdecl sub_806F104(int a1);
void __cdecl sub_806F13C(int a1);
void __cdecl sub_806F174(int a1);
void __cdecl sub_806F1AC(int a1, int a2, int a3);
void __cdecl sub_806F230(int a1, int a2, int a3);
_DWORD *__cdecl sub_806F2B2(_DWORD *a1, int a2, _DWORD *a3);
void __cdecl sub_806F2D4(int a1);
void __cdecl sub_806F30C(int a1, int a2);
void __cdecl sub_806F356(int a1, int a2);
void __cdecl sub_806F3A0(int a1, int a2);
void __cdecl sub_806F3EA(int a1);
int __cdecl sub_806F422(unsigned int a1, int a2);
int __cdecl sub_806F48C(_DWORD *a1, int a2, int a3, int a4);
int __cdecl sub_806F4E8(_DWORD *a1, int a2, int a3, int a4);
int __cdecl sub_806F530(_DWORD *a1, int a2, int a3, int a4, int a5);
char *__cdecl sub_806F58C(int a1, int a2);
int sub_806F6FE();
void __cdecl sub_806F722(int a1);
void __cdecl sub_806F75A(int a1, _DWORD *a2, int a3, int a4, int a5);
void __cdecl sub_806F798(_DWORD *a1, _DWORD *a2, int a3, int a4, int a5);
_DWORD *__cdecl sub_806F7DE(int *a1, int a2);
void __cdecl sub_806F7F8(_DWORD *a1, _DWORD *a2, int a3, int a4, int a5);
void __cdecl sub_806F83E(signed int *a1, int a2);
int __cdecl sub_806F96C(int *a1);
int __cdecl sub_806F9A0(int *a1, int a2);
int __cdecl sub_806F9EA(int a1);
_DWORD *__cdecl sub_806FA26(_DWORD *a1);
int __cdecl sub_806FA70(unsigned int a1, int a2, char a3);
void __cdecl sub_806FADC(_DWORD *a1, int a2);
void __cdecl sub_806FE34(_DWORD *a1, int a2);
int __cdecl sub_806FE7E(int a1);
void __cdecl sub_806FEF6(_DWORD *a1, int a2, char a3, int a4);
void __cdecl sub_806FF6C(int a1, int a2, char a3, int a4, int a5, int a6);
int __cdecl sub_806FFF8(_DWORD *a1, int a2, char a3, int a4);
int __cdecl sub_807007C(int a1, int a2, char a3, int a4, int a5);
void __cdecl sub_80700FE(_DWORD *a1, int a2, char a3, int a4, int a5);
void __cdecl sub_8070184(_DWORD *a1, int a2, char a3, int a4, int a5, int a6);
int __cdecl sub_8070216(_DWORD *a1);
void __cdecl sub_8070242(int a1, int a2, char a3, int a4);
int __cdecl sub_80702D8(_DWORD *a1);
_DWORD *__cdecl sub_807035E(_DWORD *a1, unsigned int *a2);
unsigned int __cdecl sub_80703B6(int a1, int *a2);
signed int __cdecl sub_80703E6(int a1);
_BOOL4 __cdecl sub_807040A(int a1);
void __cdecl sub_8070430(signed int a1, int a2);
void __cdecl sub_8070496(signed int a1, int a2);
unsigned int __cdecl sub_80704FA(_DWORD *a1, int *a2, char a3, int a4);
unsigned int __cdecl sub_807071E(int a1, _DWORD *a2, _DWORD *a3, int a4, char a5, int a6);
int __cdecl sub_807098C(int a1, _DWORD *a2, char a3);
int __cdecl sub_8070AA8(int a1);
int __cdecl sub_8070B86(int a1, int a2, int a3, int a4);
unsigned int __cdecl sub_8070C7A(int a1);
unsigned int __cdecl sub_8070CB2(int a1, unsigned __int8 a2, int a3);
void __cdecl sub_8070D46(int a1, int a2);
char *__cdecl sub_8070DF8(int a1, char **a2);
signed int __cdecl sub_8070EE4(int *a1, int a2, int a3);
signed int __cdecl sub_8070FC0(int *a1, int a2, int a3, int a4);
void __cdecl sub_807112A(int a1, int a2, int a3);
signed int __cdecl sub_8071180(_DWORD *a1, _DWORD *a2);
int __cdecl sub_8071370(_DWORD *a1, _DWORD *a2, int a3);
void __cdecl sub_8071552(int a1, int a2);
unsigned int __cdecl sub_8071586(int a1, int a2, int a3, int a4, int a5);
unsigned int __cdecl sub_807162A(int a1, int a2, int a3, int a4, int a5);
signed int __cdecl sub_80716CE(int a1, int a2, int a3, int a4, _DWORD *a5);
signed int __cdecl sub_807179C(int a1, int a2, int a3, int a4, _DWORD *a5, int a6);
void __cdecl sub_80718AE(signed int *a1, _DWORD *a2, char a3, int a4, int a5);
_DWORD *__cdecl sub_8071934(int a1, _DWORD *a2);
int __cdecl sub_807194E(_DWORD *a1, _DWORD *a2);
int __cdecl sub_80719D8(_DWORD *a1, _DWORD *a2, int a3);
void __cdecl sub_8071B6C(_DWORD *a1, int a2);
void __cdecl sub_8071BA0(signed int *a1, int a2);
_DWORD *__cdecl sub_8071CB0(int a1, _DWORD *a2);
void __cdecl sub_8071D0A(_DWORD *a1, int a2, int a3);
_DWORD *__cdecl sub_8071D66(int *a1, int a2);
void __cdecl sub_8071D92(_DWORD *a1, int a2, int a3);
void __cdecl sub_8071E6A(_DWORD *a1, int a2, int a3);
int sub_8071EB6();
int sub_8071EFA();
_BOOL4 __cdecl sub_8071F3E(_DWORD *a1);
signed int __cdecl sub_8071F50(int a1);
signed int __cdecl sub_8071F86(int a1, int a2, int a3);
void __cdecl sub_8072088(signed int *a1, _DWORD *a2, int a3, int a4, int a5);
_DWORD *__cdecl sub_80720EE(int a1, int a2, _DWORD *a3);
unsigned int __cdecl sub_8072108(int a1, int a2);
void __cdecl sub_807212A(_DWORD *a1, int a2, _DWORD *a3);
void __cdecl sub_807216E(int a1, _DWORD *a2);
void __cdecl sub_80721A0(_DWORD *a1, int a2, int a3, int a4);
void __cdecl sub_8072210(int a1);
unsigned int __cdecl sub_807225A(_DWORD *a1, int a2, int a3, unsigned __int8 a4, int a5, int a6, _DWORD **a7);
void __cdecl sub_807233A(int a1, _DWORD *a2, size_t *a3);
int __cdecl sub_8072382(_DWORD *a1, int a2, int a3, int a4, int a5, unsigned __int8 a6, int a7, int a8, int *a9, _DWORD **a10);
void __cdecl sub_80725C2(int a1, int a2, signed int *a3, size_t *a4, size_t *a5);
_DWORD *__cdecl sub_80726C0(_DWORD *a1);
_DWORD *__cdecl sub_807270E(_DWORD *a1);
int __cdecl sub_807275C(_DWORD *a1, _DWORD *a2, int a3, int a4, int a5, int *a6);
int __cdecl sub_8072AE6(_DWORD *a1, int a2, int *a3, size_t *a4);
int __cdecl sub_8072C7E(int a1, int a2, int a3, _DWORD *a4, int a5, int a6, int a7, int *a8, int *a9);
int __cdecl sub_80730A4(int a1, int a2, int a3, int a4, int *a5, size_t *a6, size_t *a7);
void __cdecl sub_80732BA(signed int *a1, int a2, int a3);
_DWORD *__cdecl sub_807331C(int a1, _DWORD *a2);
void __cdecl sub_8073336(signed int *a1, int a2, int a3);
int __cdecl sub_8073398(int a1, int a2);
int __cdecl sub_80733DA(int a1, _DWORD *a2);
int __cdecl sub_807341C(int a1, int a2);
int __cdecl sub_807345E(int a1, int a2, int a3, int a4, int a5);
int __cdecl sub_8073538(int a1, _DWORD *a2);
int __cdecl sub_8073560(int a1, int a2, int a3, int a4, int a5);
void __cdecl sub_80736AC(int a1, int *a2, int a3, int a4, int a5);
void __cdecl sub_80737A2(int a1, _DWORD *a2, int a3, int a4, int a5);
int compar(const void *, const void *); // idb
signed int __cdecl sub_807384C(int a1);
void __cdecl sub_80738A8(_DWORD *a1, int a2);
void __cdecl sub_8073964(int a1);
char *__cdecl sub_8073980(int a1, char a2, int a3, int a4);
int __cdecl sub_8073BC8(int a1, signed int *a2);
char *__cdecl sub_8073DBC(_DWORD *a1, int a2, int a3, char a4, int a5, int a6);
void __cdecl sub_8074020(int a1, int a2);
char *__cdecl sub_807407E(int a1, _DWORD *a2);
char *__cdecl sub_8074158(int a1, _DWORD *a2);
void sub_8074230();
int __cdecl sub_8074236(int a1, int a2, unsigned __int8 a3);
int __cdecl sub_807428E(int a1, int a2);
int __cdecl sub_80742B0(int a1, int a2);
void __cdecl sub_80742D2(int a1, unsigned __int8 a2, int a3, _DWORD *a4);
void __cdecl sub_8074842(size_t *a1, signed int *a2);
int __cdecl sub_8074A7A(int a1, char a2, int a3, _DWORD *a4);
int __cdecl sub_8074AF6(int a1, signed int *a2);
void __cdecl sub_8074B34(int a1, _DWORD *a2, size_t *a3);
char *__cdecl sub_8074B7C(int a1, int a2, int a3, int *a4);
void __cdecl sub_8074C6A(int *a1, int a2, int a3);
int __cdecl sub_8074CB6(int *a1, _DWORD *a2);
char *__cdecl sub_8074CD2(char **a1);
char *__cdecl sub_8074DEE(int a1, int a2, int a3, int a4, _DWORD *a5);
int __cdecl sub_8074ED8(int *a1, int a2, signed int **a3);
void __cdecl sub_8074F74(int a1);
char *__cdecl sub_807501A(int *a1, _DWORD **a2);
char *__cdecl sub_807509C(int *a1, _DWORD **a2);
char *__cdecl sub_80751B4(int a1);
int __cdecl sub_80752BA(int a1);
int __cdecl sub_8075354(int a1);
int __cdecl sub_80753A6(int a1);
char *__cdecl sub_80753DE(int *a1, int a2, int a3);
int __cdecl sub_8075710(int a1);
void sub_8075758();
int __cdecl sub_807578C(int *a1);
int __cdecl sub_80757AC(_DWORD *a1);
_BOOL4 __cdecl sub_80757CC(int a1);
signed int __cdecl sub_8075828(_BYTE *a1);
int __cdecl sub_8075874(int, char *s); // idb
void *sub_80759A6();
unsigned int *sub_80759D2();
int __cdecl sub_80759F2(int a1);
int __cdecl sub_8075A60(void *s2); // idb
void sub_8075ABA();
int sub_8075B54();
int __cdecl sub_8075B72(int a1);
int __cdecl sub_8075BBE(int a1, int a2);
int __cdecl sub_8075C54(char *a1);
int sub_8075E10();
int sub_8075E1E();
int __cdecl sub_8075ECE(int a1, int a2);
void *sub_8075F0E();
void sub_8075F74();
int __cdecl sub_8075FE8(int a1);
void sub_8076040();
int *sub_8076134();
int __cdecl sub_80761F6(int a1);
int __cdecl sub_807626A(int a1, int a2);
signed int __cdecl sub_80763CA(int a1, int a2);
int __cdecl sub_80765A0(int a1);
int *sub_80766E6();
void __cdecl sub_8076776(int a1, int a2);
int __cdecl sub_80767AA(int a1);
int __cdecl sub_807682A(int a1);
int __cdecl sub_80768E2(int a1, int a2);
int __cdecl sub_8076960(int a1);
int __cdecl sub_8076A2A(int a1);
int __cdecl sub_8076A50(int a1, int a2);
void *sub_8076A72();
signed int __cdecl sub_8076A9A(int a1, unsigned int a2, int a3);
void __cdecl sub_8076B14(void *ptr);
_BOOL4 __cdecl sub_8076B6C(int a1, int a2);
void sub_8076B9C();
void sub_8076C84();
void __cdecl sub_8076D92(int a1, int a2);
int sub_8076FAE();
char *__cdecl sub_8077016(int a1);
char *__cdecl sub_80773B6(unsigned int a1);
char *__cdecl sub_8077474(unsigned int a1);
int __cdecl sub_807752A(unsigned int a1, int a2);
int __cdecl sub_8077554(_BYTE *a1, int a2, _DWORD *a3, _DWORD *a4);
int __cdecl sub_80775A6(int a1, int a2);
signed int __cdecl sub_80775E4(unsigned int a1, int a2, int *a3);
char *sub_80776B8();
int __cdecl sub_8077750(char *s, int, int, int, int, int); // idb
int __cdecl sub_80778BC(int, char *s, int, int); // idb
size_t __cdecl sub_807799E(int a1, char *s, int a3, int a4);
int __cdecl sub_8077AE8(_BYTE *a1, int a2, _DWORD *a3, int a4);
void __cdecl sub_8077B96(int a1, int a2, _BYTE *a3, int a4);
int __cdecl sub_8077C92(int, int, char *s, size_t maxlen); // idb
int __cdecl sub_8077D5A(unsigned int a1);
void __cdecl sub_8077DBA(int a1, char *a2, int a3);
int __cdecl sub_8077EF6(int, int, char *s, size_t maxlen); // idb
char *sub_8077FFE(int a1, char *format, ...);
void __noreturn sub_80780F6(int a1, char *format, ...);
void __cdecl sub_807818C(int a1, char *a2, int a3, int a4);
void __cdecl sub_8078282(char *a1, int a2, int a3, void *a4);
// _DWORD *__userpurge sub_8078390@<eax>(_DWORD *a1, int a2);
// _DWORD *__userpurge sub_80783A2@<eax>(_DWORD *a1, int a2);
// size_t *__userpurge sub_80783B4@<eax>(size_t *a1, int a2);
// int __userpurge sub_80783DE@<eax>(int a1, int a2, int a3);
// int __userpurge sub_8078412@<eax>(int a1, int a2, int a3, int a4);
// int __userpurge sub_8078450@<eax>(int a1, int a2, int a3);
// int __userpurge sub_8078484@<eax>(int a1, int a2, int a3, int a4, int a5);
// int __userpurge sub_80784CC@<eax>(int a1, int a2, int a3, int a4);
// int __userpurge sub_807850A@<eax>(int a1, int a2, int a3, int a4, int a5, int a6);
// int __userpurge sub_807855C@<eax>(int a1, int a2, int a3, int a4, int a5);
// int __userpurge sub_80785A4@<eax>(int a1, int a2, int a3, int a4, int a5, int a6, int a7);
// int __userpurge sub_8078600@<eax>(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8);
// int __userpurge sub_8078666@<eax>(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, int a9);
// int __userpurge sub_80786D6@<eax>(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, int a9, int a10);
// int __userpurge sub_8078750@<eax>(int a1, int a2);
// _DWORD *__userpurge sub_80787A6@<eax>(_DWORD *a1, int a2, _DWORD *a3);
// _DWORD *__userpurge sub_80787EC@<eax>(_DWORD *a1, int a2, int a3);
int __cdecl sub_8078878(int a1);
int __cdecl sub_807888A(int a1);
int __cdecl sub_8078896(int a1);
int __cdecl sub_80788C2(_BYTE *a1);
int __cdecl sub_80788FC(int a1);
int __cdecl sub_807891E(int a1);
int __cdecl sub_8078946(int a1);
unsigned int __cdecl sub_8078962(char *a1, unsigned int a2);
unsigned int sub_8078A24();
void sub_8078AB2();
void sub_8078AD0();
int __cdecl sub_8078AE8(void *s2, size_t n); // idb
int __cdecl sub_8078CC6(void *s2); // idb
int __cdecl sub_8078CEA(char *s); // idb
int __cdecl sub_8078D94(int a1, unsigned __int8 a2);
int __cdecl sub_8078DEC(void *s2, int a2, size_t n);
int __cdecl sub_8079290(char *s, int a2);
int __cdecl sub_80792C4(char *s, int); // idb
int __cdecl sub_80792E6(int a1, int a2, size_t n);
int __cdecl sub_807939E(char *s, int a2);
int __cdecl sub_80793D2(char *s, int); // idb
int __cdecl sub_80793F4(int a1, int a2);
int __cdecl sub_80794D8(int a1, unsigned __int8 a2);
int __cdecl sub_807951E(int a1);
int __cdecl sub_8079544(int a1, int a2, unsigned int a3);
int __cdecl sub_80796A2(int a1);
int __cdecl sub_80796DA(int a1);
int __cdecl sub_8079746(int a1, unsigned int a2);
int __cdecl sub_8079790(_WORD *a1, int a2);
int __cdecl sub_80797CA(int, char *s); // idb
int __cdecl sub_8079808(char *s); // idb
int __cdecl sub_8079824(float); // idb
int __cdecl sub_807986A(int a1);
int __cdecl sub_80798B0(float *a1);
void __cdecl sub_8079910(unsigned __int8 a1);
void sub_80799B6();
void sub_8079A58();
_BYTE *__cdecl sub_8079B84(_BYTE *a1, char *a2, int a3);
int __cdecl sub_8079C2A(char *a1);
size_t __cdecl I_strlen(char *s);
void sub_8079C84();
unsigned int __cdecl sub_8079C94(int a1);
unsigned int __cdecl sub_8079CC8(int a1);
unsigned int __cdecl sub_8079CDC(int a1);
unsigned int __cdecl sub_8079CF0(int a1);
_BOOL4 __cdecl sub_8079D48(int a1);
int sub_8079D6E(const void *, const void *); // idb
void sub_8079DEE();
void sub_807A298();
int sub_807A29E();
int *sub_807A368();
int sub_807A3B6();
unsigned int __cdecl sub_807A3E8(int a1);
int __cdecl sub_807A402(int a1, int a2);
int __cdecl sub_807A4D2(int a1, int a2);
int __cdecl sub_807A514(int a1, unsigned int a2, int a3);
int __cdecl sub_807AA14(int a1, unsigned int a2, int a3);
int __cdecl sub_807AAC0(int a1, unsigned int a2, int a3);
int __cdecl sub_807AB96(int a1, unsigned int a2);
int __cdecl sub_807ABDE(int a1, unsigned int a2);
int __cdecl sub_807AC26(int a1, unsigned int a2);
int __cdecl sub_807AC94(__int16 *a1, int a2);
int __cdecl sub_807AEBA(int a1);
int __cdecl sub_807AF82(int a1);
int __cdecl sub_807AFAC(int a1, int a2);
int __cdecl sub_807B004(int a1);
int __cdecl sub_807B04E(int a1);
int __cdecl sub_807B084(int a1);
int __cdecl sub_807B110(int a1);
int __cdecl sub_807B128(int a1, int a2);
int __cdecl sub_807B190(int a1);
unsigned int __cdecl sub_807B1C8(int a1);
unsigned int __cdecl sub_807B1DC(int a1);
unsigned int __cdecl sub_807B1F0(int a1);
unsigned int __cdecl sub_807B22A(unsigned int a1);
int __cdecl sub_807B25E(int a1);
int __cdecl sub_807B360(int a1);
int sub_807B3A8();
int __cdecl sub_807B4A0(int a1);
int sub_807B562();
int sub_807B5A0();
int __cdecl sub_807B5EA(int a1, __int16 a2);
int sub_807B658();
int __cdecl sub_807B6AC(__int16 a1);
int __cdecl sub_807B700(__int16 a1, int a2);
int __cdecl sub_807B766(int a1);
int __cdecl sub_807B778(int a1);
int __cdecl sub_807B7BA(int a1);
int __cdecl sub_807B7DC(int a1);
int __cdecl sub_807B8D4(int a1);
int sub_807B936();
_DWORD *__cdecl sub_807B968(_DWORD *a1);
int __cdecl sub_807B9A6(int a1);
int __cdecl sub_807B9CA(int a1);
int __cdecl sub_807BA14(signed int a1, int a2);
int __cdecl sub_807BA64(signed int a1, int a2);
_BOOL4 __cdecl sub_807BAB4(int a1);
int __cdecl sub_807BADA(int a1);
int __cdecl sub_807BAEC(int a1, int a2);
int __cdecl sub_807BB10(int a1, int a2);
int __cdecl sub_807BB34(int a1, int a2);
int __cdecl sub_807BB58(int a1, int a2);
int __cdecl sub_807BB82(int a1, int a2);
int __cdecl sub_807BBA6(int a1, int a2);
int __cdecl sub_807BBCA(int a1, int a2);
// int *__userpurge sub_807BC7C@<eax>(int *a1, int a2, int a3);
// _DWORD *__userpurge sub_807BF2C@<eax>(_DWORD *a1, unsigned int a2);
int __cdecl sub_807BF8E(int a1, int a2, int a3);
int __cdecl sub_807C060(int a1, int a2);
int __cdecl sub_807C084(int a1, int a2);
int __cdecl sub_807C0A8(int a1, unsigned int a2);
int __cdecl sub_807C0CC(int a1, unsigned int a2);
int __cdecl sub_807C0F0(int a1, int a2);
int __cdecl sub_807C11A(int a1, int a2);
int __cdecl sub_807C144(int a1, int a2);
int __cdecl sub_807C16E(int a1, int a2);
int __cdecl sub_807C1CC(int a1);
int __cdecl sub_807C228(int a1, int a2);
int __cdecl sub_807C248(int a1, int a2);
int __cdecl sub_807C26C(int a1, int a2);
int __cdecl sub_807C290(int a1, int a2);
int __cdecl sub_807C2F6(int a1, int a2);
int __cdecl sub_807C45C(int a1, int *a2);
int __cdecl sub_807C4C2(int a1, int *a2);
__int16 *__cdecl sub_807C4FC(int a1);
signed int __cdecl sub_807C51C(int a1, unsigned int a2, signed int *a3);
unsigned int __cdecl sub_807C5E2(int a1);
signed int __cdecl sub_807C628(int a1, signed int *a2);
// int *__userpurge sub_807C66A@<eax>(int *a1, int a2);
int __cdecl sub_807C6AE(int a1);
// int *__userpurge sub_807C72C@<eax>(int *a1, int a2, int a3);
// int *__userpurge sub_807C83C@<eax>(int *a1, int a2);
void __cdecl sub_807C8B2(int *a1);
int __cdecl sub_807C9AC(int a1);
int __cdecl sub_807C9CE(int a1);
int __cdecl sub_807CA16(int a1);
unsigned int __cdecl sub_807CA72(int a1);
int __cdecl sub_807CA86(int a1);
int __cdecl sub_807CAD2(int a1);
int __cdecl sub_807CB1E(int a1);
_BOOL4 __cdecl sub_807CB3E(int a1);
_BOOL4 __cdecl sub_807CBAA(int a1);
void __cdecl sub_807CBD8(int *a1);
void __cdecl sub_807CC38(float *a1);
signed int __cdecl sub_807CCCE(int *a1);
signed int __cdecl sub_807CDD0(int *a1);
int __cdecl sub_807CEE4(int a1);
void __cdecl sub_807CF1E(_DWORD *a1);
int __cdecl sub_807CFFA(int a1, int *a2);
void __cdecl sub_807D08C(int *a1, int *a2);
void __cdecl sub_807D15A(int *a1, int *a2);
void __cdecl sub_807D1D4(int *a1, int a2);
void __cdecl sub_807D3B6(int *a1, int *a2);
void __cdecl sub_807D3F4(int *a1, int *a2);
void __cdecl sub_807D432(int *a1, int *a2);
void __cdecl sub_807D470(int *a1, int *a2);
_BOOL4 __cdecl sub_807D6D6(int *a1, int *a2);
void __cdecl sub_807D702(int *a1, int *a2);
_BOOL4 __cdecl sub_807D784(int *a1, int *a2);
void __cdecl sub_807D7B0(int *a1, int *a2);
_BOOL4 __cdecl sub_807D832(int *a1, int *a2);
void __cdecl sub_807D85E(int *a1, int *a2);
void __cdecl sub_807D8A4(int *a1, int *a2);
void __cdecl sub_807D8EA(int *a1, int *a2);
void __cdecl sub_807DB42(int *a1, int *a2);
void __cdecl sub_807DC40(int *a1, int *a2);
void __cdecl sub_807DCA6(int *a1, int *a2);
void __cdecl sub_807DD64(int *a1, int *a2);
void __cdecl sub_807DDD2(int a1, int *a2, int *a3);
_BOOL4 __cdecl sub_807DF52(int a1);
int __cdecl sub_807DF7C(int a1);
void __cdecl sub_807DF90(int a1, int a2);
int sub_807E04A();
unsigned int *sub_807E0C6();
int __cdecl sub_807E13C(int a1);
int __cdecl sub_807E182(int a1);
int __cdecl sub_807E1F6(int, void *s2, __int16); // idb
int __cdecl sub_807E2EA(int a1, int a2);
int __cdecl sub_807E346(int a1, int a2);
int __cdecl sub_807E3A6(int a1, int a2);
int __cdecl sub_807E43A(int a1, int *a2);
int __cdecl sub_807E502(int a1, int *a2);
void __cdecl sub_807E5E0(int *a1, int *a2);
int __cdecl sub_807E856(int a1);
void __cdecl sub_807EB00(int a1, int *a2);
int __cdecl sub_807ED9A(int a1);
// _WORD *__userpurge sub_807EDC4@<eax>(_WORD *a1, int a2);
int __cdecl sub_807EDFC(int a1, int a2);
int __cdecl sub_807EECE(int a1, int a2, int a3);
long double __cdecl sub_807EF24(int a1, int a2);
long double __cdecl sub_807EF84(int a1);
long double __cdecl sub_807EFAE(int a1);
long double __cdecl sub_807F006(int a1);
long double __cdecl sub_807F072(int a1, float *a2);
int __cdecl sub_807F168(char *s1, int); // idb
int __cdecl sub_807F1EE(char *src);
int __cdecl sub_807F47A(int a1, char *a2);
int __cdecl sub_807F554(int a1);
signed int __cdecl sub_807F568(int a1);
void sub_807F64C();
int __cdecl sub_807F676(int a1);
signed int __cdecl sub_807F6F2(char a1);
int sub_807F740();
int __cdecl sub_807F74E(int, char *s); // idb
int __cdecl sub_807F7E0(int a1);
long double __cdecl sub_807F7F4(float a1);
void sub_807F810();
int sub_807F834();
int sub_807F8F6();
int Scr_Init();
bool __cdecl sub_807F988(int a1, int a2, int a3);
void Scr_Shutdown();
void Scr_Abort();
int __cdecl sub_807F9F2(int a1);
void sub_807FA00();
int sub_807FA9C();
int sub_807FACC();
int sub_807FAEE();
int __cdecl sub_807FB08(unsigned __int8 *a1, int a2, int a3, _DWORD *a4, int a5);
void *__cdecl sub_8081F8C(_DWORD *a1);
char *__cdecl sub_8081FD6(int *a1, char *a2, int a3, int a4, _DWORD *a5);
int __cdecl sub_8082366(int a1, int a2, int a3, int a4, int a5);
int __cdecl sub_80823CE(int a1, int a2);
int __cdecl sub_808244A(int a1, int a2, _DWORD *a3, int a4, int *a5);
int __cdecl sub_8082572(int a1);
int __cdecl sub_80825C2(int a1, _DWORD *a2, int a3);
int __cdecl sub_8082754(int a1, int a2, int a3);
int __cdecl sub_80828BE(int a1, int a2, char a3);
int __cdecl sub_8082A4A(int a1);
int __cdecl sub_8082AC0(int a1, int a2);
int __cdecl sub_8082B7E(int a1);
int __cdecl sub_8082C1A(int a1, int a2);
int __cdecl sub_8082D9A(int a1, int a2);
_BOOL4 __cdecl sub_8082E74(unsigned int a1);
signed int __cdecl sub_8082EE2(unsigned int a1);
int __cdecl sub_8082F56(int a1, int a2, int *a3);
int __cdecl sub_8083426(int a1, int a2, int a3, int a4);
int __cdecl sub_80834DC(int a1);
int __cdecl sub_8083640(int a1);
unsigned int __cdecl sub_80836CA(int a1);
int sub_80837B0();
int __cdecl sub_80837EC(int a1, char *a2, int a3);
int __cdecl sub_808398E(int a1, int a2);
int __cdecl sub_8083A1A(int a1, int a2, int a3, int a4);
int __cdecl sub_8083AAC(int a1, int a2);
int __cdecl sub_8083B14(int a1, int a2, int a3, int a4);
int __cdecl sub_8083B8E(unsigned __int16 a1);
int __cdecl sub_8083BAA(char *a1, int a2);
void sub_8083C5C();
int __cdecl sub_8083CBA(int a1, int a2, int a3, char a4, int a5);
signed int __cdecl sub_8083D82(int a1, int *a2, int a3);
int sub_8083E96();
unsigned int *__cdecl sub_8083EDA(int a1, int a2);
_BOOL4 sub_8084030();
int __cdecl sub_808404C(unsigned int a1);
// unsigned __int16 *__userpurge sub_80840DA@<eax>(unsigned __int16 *a1, unsigned int a2, int a3);
// _DWORD *__userpurge sub_808423E@<eax>(_DWORD *a1, unsigned int a2);
long double __cdecl sub_8084320(unsigned int a1);
int __cdecl sub_80843C0(unsigned int a1);
int __cdecl sub_8084434(unsigned int a1);
int __cdecl sub_808456A(unsigned int a1);
int __cdecl sub_8084586(unsigned int a1);
int __cdecl sub_80845C8(unsigned int a1);
int __cdecl sub_80845E4(unsigned int a1);
int __cdecl sub_808464E(unsigned int a1);
int __cdecl sub_80846DC(unsigned int a1);
void __cdecl sub_80846F8(unsigned int a1, _DWORD *a2);
int __cdecl sub_8084788(unsigned int a1);
// _WORD *__userpurge sub_808481E@<eax>(_WORD *a1, unsigned int a2);
int __cdecl sub_808491A(unsigned int a1);
int __cdecl sub_80849A8(unsigned int a1);
int __cdecl sub_80849F8(unsigned int a1);
int __cdecl sub_8084A50(unsigned int a1);
int sub_8084AEE();
int __cdecl Scr_AddBool(int a1);
int __cdecl Scr_AddInt(int a1);
int __cdecl Scr_AddFloat(int a1);
int __cdecl sub_8084B64(int a1);
int Scr_AddUndefined();
int __cdecl sub_8084BA2(int a1);
int __cdecl sub_8084BD2(int a1, int a2);
int sub_8084BF4();
int __cdecl Scr_AddString(char *s); // idb
int __cdecl sub_8084C54(char *s); // idb
int __cdecl sub_8084C8E(int a1);
_DWORD *__cdecl Scr_AddVector(_DWORD *a1);
int sub_8084CF0();
int sub_8084D1C();
int __cdecl sub_8084D6E(unsigned int a1);
void __cdecl sub_8084DB4(int a1);
void __cdecl sub_8084DD2(int a1, int a2);
void __cdecl sub_8084DF0(int a1);
void __cdecl sub_8084E14(int a1, int a2);
void __cdecl sub_8084E30(int a1);
signed int __cdecl sub_8084E4E(int a1, int a2, int a3, int a4);
// _DWORD *__userpurge sub_8084ECA@<eax>(_DWORD *a1, char *a2, int a3, int a4);
signed int __cdecl sub_8084F28(int a1, int a2);
signed int __cdecl sub_8084F6A(int a1, int a2, int a3);
int sub_8084F9A();
void sub_8084FD2();
int sub_8084FE0();
int __cdecl sub_80850EE(float); // idb
int __cdecl sub_8085124(_DWORD *a1, _DWORD *a2);
int __cdecl sub_8085154(int a1);
int __cdecl sub_808516A(unsigned __int8 *a1);
int __cdecl sub_8085180(int **a1);
int __cdecl sub_80851A2(int *a1);
int __cdecl sub_80851C2(int *a1, int a2);
int __cdecl sub_80851E6(__int16 **a1);
int __cdecl sub_80851FC(int **a1);
long double __cdecl sub_8085210(float **a1);
int __cdecl sub_8085238(int **a1);
int __cdecl sub_808524C(__int16 **a1);
int __cdecl sub_8085274(int a1);
int __cdecl sub_80852B8(void *s2, int); // idb
signed int __cdecl sub_80852E8(char *a1, int a2);
int __cdecl sub_8085425(char *s); // idb
int __cdecl sub_8085448(char *s); // idb
signed int sub_808546B();
signed int sub_8086881();
signed int sub_8086AF2();
int __cdecl sub_8086BCA(signed int a1);
int sub_8086C86();
int __cdecl sub_8086D87(FILE *stream); // idb
int __cdecl sub_8086DCB(int a1);
int sub_8086E2A();
_DWORD *__cdecl sub_8086E67(FILE *stream, int a2);
int __cdecl sub_8086F30(int, FILE *stream); // idb
int __cdecl sub_8086F8F(int a1);
_DWORD *__cdecl sub_8086FEC(int a1, unsigned int a2);
_DWORD *__cdecl sub_80870EE(int a1, int a2);
void __cdecl __noreturn sub_8087193(int a1);
void *__cdecl sub_80871C1(size_t size);
void *__cdecl sub_80871D4(void *ptr, size_t size);
void __cdecl sub_80871EE(void *ptr);
int sub_8087201();
int __cdecl sub_808724F(_DWORD *a1, char a2);
signed int sub_80872FC();
signed int sub_8087306();
char *sub_808AA30();
char *sub_808AB48();
void *__cdecl sub_808AC6A(char *s);
// void __usercall sub_808AC7E(long double a1@<st0>);
// void __usercall sub_808AD76(long double a1@<st0>, int a2);
// void __usercall sub_808AFE0(long double a1@<st0>);
// void __usercall sub_808AFF4(long double a1@<st0>);
char *sub_808B008();
// void __usercall sub_808B06A(long double a1@<st0>);
// int __usercall sub_808B24C@<eax>(long double a1@<st0>, int a2, char *dest, int a4);
// int __usercall sub_808B2F2@<eax>(long double a1@<st0>, char *dest, int a3);
// int __usercall sub_808B406@<eax>(long double a1@<st0>, char *dest, int a3);
// int __usercall sub_808B494@<eax>(long double a1@<st0>);
// void __usercall sub_808B4DE(long double a1@<st0>);
// void __usercall sub_808B532(long double a1@<st0>);
void sub_808B586();
// int __usercall sub_808B5BA@<eax>(long double a1@<st0>);
// int __usercall sub_808B5D6@<eax>(long double a1@<st0>);
// int __usercall sub_808B5F2@<eax>(long double a1@<st0>);
void sub_808B63C();
void sub_808B8DC();
void sub_808B9A2();
void sub_808BACE();
void sub_808BADE();
void sub_808BB06();
void sub_808BB2E();
// void *__usercall sub_808BB9E@<eax>(long double a1@<st0>);
void sub_808BBB2();
void sub_808BBC0();
void sub_808BBCE();
void sub_808BBDC();
void sub_808BDFC();
void sub_808BE02();
void sub_808BE32();
// void __usercall sub_808BE54(long double a1@<st0>, int a2, int a3, int a4, int a5, int a6);
// void __usercall sub_808C21C(long double a1@<st0>, int a2, int a3, int a4, int a5, int a6, int a7);
signed int __cdecl sub_808C34C(int a1);
signed int __cdecl sub_808C3D0(int a1);
unsigned int sub_808C46E();
int __cdecl sub_808C4CE(int a1);
// void __usercall sub_808C4FA(long double a1@<st0>, int a2);
void __cdecl sub_808C626(char *a1);
void __cdecl sub_808C7CA(char a1, int a2, int a3, int a4, int a5);
// int __usercall sub_808D026@<eax>(long double a1@<st0>, int a2);
// void __usercall sub_808D08E(long double a1@<st0>);
// void __usercall sub_808D0E6(long double a1@<st0>, int a2, int a3, int a4, int a5, int a6);
int sub_808DC2C();
// void __usercall sub_808DC8C(long double a1@<st0>, char *a2, char *a3);
_DWORD *__cdecl sub_808DEA6(_DWORD *a1, _DWORD *a2);
// int __usercall sub_808DECA@<eax>(long double a1@<st0>, char *a2);
int __cdecl sub_808E1F0(_DWORD *a1, _DWORD *a2);
int *__cdecl sub_808E2BE(int a1);
int *__cdecl sub_808E348(int a1);
// int __usercall sub_808E398@<eax>(long double a1@<st0>, char *a2);
int __cdecl sub_808E3C4(int a1);
// void __usercall sub_808E404(long double a1@<st0>, int a2);
char *__cdecl sub_808E508(int a1);
int *__cdecl sub_808E544(int a1, _DWORD *a2);
// void __usercall sub_808EC4A(long double a1@<st0>, char *a2);
int __cdecl sub_808EC66(int a1);
int __cdecl sub_808EEEC(int a1);
int __cdecl sub_808EEFE(int a1);
int __cdecl sub_808F0E6(int a1);
void __cdecl sub_808F13C(int a1);
void __cdecl sub_808F18C(int a1);
double __cdecl sub_808F1DC(_DWORD, _DWORD); // weak
// void __usercall sub_808F1F6(long double a1@<st0>, int a2, _BYTE *a3, int a4);
// signed int __usercall sub_808F288@<eax>(long double a1@<st0>, int a2, _DWORD *a3);
// int __usercall sub_808F488@<eax>(long double a1@<st0>, _DWORD *a2, int *a3);
// void __usercall sub_808F510(long double a1@<st0>, char *a2, _DWORD *a3, int a4);
// void __usercall sub_808F82A(long double a1@<st0>, int a2, _DWORD *a3);
// int __usercall sub_808FAC6@<eax>(long double a1@<st0>);
signed int __cdecl sub_808FD2A(_BYTE *a1, _BYTE *a2, int a3);
int __cdecl sub_808FDE4(int a1);
int __cdecl sub_808FE02(int a1);
int __cdecl sub_808FE20(_DWORD *a1);
int __cdecl sub_808FE68(int a1);
int __cdecl sub_808FE96(int a1, int a2, int a3);
// void __usercall sub_808FF0A(long double a1@<st0>, int a2, char *a3);
int __cdecl sub_808FF44(int a1);
signed int __cdecl sub_808FFBC(float *a1, int a2);
unsigned int __cdecl sub_80901C2(float *a1, float *a2, int a3);
char *__cdecl sub_80903BC(char *dest, int a2);
void *__cdecl sub_8090408(size_t a1);
void *__cdecl sub_8090438(size_t n, int a2);
_DWORD *__cdecl sub_8090470(size_t size);
void __cdecl sub_8090484(void *ptr);
int __cdecl sub_8090498(int a1, int a2, int a3, int a4, int a5);
int __cdecl sub_80904C6(int a1, _DWORD *a2);
void *__cdecl sub_809050C(size_t a1);
void *__cdecl sub_8090520(size_t a1);
int __cdecl sub_8090534(char *s1); // idb
void __cdecl sub_8090584(int *a1);
unsigned int sub_80905C8();
int __cdecl sub_80905FA(int a1);
int __cdecl sub_8090666(int *a1, int a2);
signed int __cdecl sub_80906EE(int *a1, int a2);
int __cdecl sub_8090776(int *a1, float a2, int a3);
int __cdecl sub_80907BC(int *a1, float a2);
int __cdecl sub_80907EE(int *a1, int a2, int a3);
int *__cdecl sub_8090820(int *a1, int a2);
int *__cdecl sub_809084A(int *a1, int a2);
int __cdecl sub_8090874(int *a1);
int __cdecl sub_8090898(int *a1, int a2);
int __cdecl sub_80908D8(int *a1);
void __cdecl sub_80908FC(int *a1);
int __cdecl sub_8090928(int *a1);
signed int __cdecl sub_809094C(int *a1, int a2, int a3);
signed int __cdecl sub_809097E(int *a1, int a2, int a3);
int __cdecl sub_80909B0(int *a1);
void sub_80909E8();
_BOOL4 __cdecl sub_80909EE(char *s);
void *sub_8090A48();
_BOOL4 __cdecl sub_8090A5A(int *a1);
int sub_8090A82();
void sub_8090A96();
int __cdecl sub_8090AAA(char *dest, int); // idb
int __cdecl sub_8090AFE(int a1);
int __cdecl sub_8090B42(int a1);
signed int __cdecl sub_8090B5E(int a1);
// void __usercall SV_ShutdownGameProgs(long double a1@<st0>);
// void __usercall sub_8090BE6(long double a1@<st0>);
// void __usercall sub_8090CD2(long double a1@<st0>, int a2, int a3);
// void __usercall sub_8090D6A(long double a1@<st0>, int a2);
// void __usercall sub_8090D9C(long double a1@<st0>, int a2);
// signed int __usercall CL_ForwardCommandToServer@<eax>(long double a1@<st0>);
int __cdecl sub_8090DE8(float *a1, float *a2, float *a3);
int __cdecl sub_8090E14(int, float, int); // idb
int __cdecl sub_8090E3A(_DWORD *a1, _DWORD *a2);
int __cdecl sub_8090E6C(int a1, char *s1);
char *__cdecl sub_809107E(int a1, char *dest, int a3);
char *__cdecl sub_8091108(int a1);
char *__cdecl sub_8091134(int a1, int a2, char *s1);
int __cdecl sub_80911AA(int, int, char *s1, char *); // idb
char *__cdecl sub_8091246(int a1, char *src);
char *__cdecl sub_80912F0(int a1, char *dest, int a3);
int sub_8091372();
// void __usercall sub_809147E(long double a1@<st0>, char *a2);
// void __usercall sub_80914E6(long double a1@<st0>);
// int __usercall sub_80915D0@<eax>(long double a1@<st0>);
void __cdecl sub_809188A(char *a1);
void *sub_8091998();
void *__cdecl sub_80919F4(int a1);
void sub_8091A70();
void sub_8091AB2();
int sub_8091B5A();
int sub_8091B68();
// void __usercall sub_8091C02(long double a1@<st0>, char *a2);
_BOOL4 sub_809215C();
// char *__usercall SV_Init@<eax>(long double a1@<st0>);
// int *__usercall sub_80927DA@<eax>(long double a1@<st0>, int a2);
// int __usercall sub_80928B4@<eax>(long double a1@<st0>);
// void __usercall SV_Shutdown(long double a1@<st0>, int a2);
int __cdecl sub_80929F8(_DWORD *a1, _DWORD *a2);
_BYTE *__cdecl sub_8092A28(_BYTE *a1);
signed int __cdecl sub_8092AB6(_BYTE *a1, _BYTE *a2);
signed int __cdecl sub_8092B3C(int a1, char *a2);
int __cdecl sub_8092C6C(int a1);
int __cdecl sub_8092D5C(int, int, char *s); // idb
int sub_809301C(int a1, int a2, char *format, ...);
int __cdecl sub_809315A(char a1, int a2, int a3, int a4, int a5, _DWORD *a6);
int __cdecl sub_8093288(int a1, int a2, int a3, int a4, int a5);
int __cdecl sub_80936D4(int a1, int a2, int a3, int a4, int a5);
_BOOL4 __cdecl sub_8093980(int a1, int a2, int a3, int a4, int a5);
// void __usercall sub_8093F1E(long double a1@<st0>, int a2, int a3, int a4, int a5, int a6, _DWORD *a7);
// void __usercall sub_80941AE(long double a1@<st0>, int a2, int a3, int a4, int a5, int a6, _DWORD *a7);
int sub_809443E();
int __cdecl sub_8094586(int a1);
// int __usercall sub_80945AC@<eax>(long double a1@<st0>);
signed int sub_80946DA();
// void __usercall sub_8094780(long double a1@<st0>);
// int __usercall sub_809479A@<eax>(long double a1@<st0>, char *a2);
// int __usercall sub_8094980@<eax>(long double a1@<st0>);
// void __usercall sub_80949DE(long double a1@<st0>, int a2);
int *sub_8094E38();
void __cdecl sub_8094F02(int a1);
void sub_8094FFC();
void sub_809505E();
_BOOL4 __cdecl sub_809507C(char *s);
// int __usercall sub_80951B4@<eax>(long double a1@<st0>, int a2, int a3, int a4, int a5, int a6);
void sub_809544E();
int __cdecl sub_8095454(int a1, _BYTE *a2, int a3);
int __cdecl sub_80954DE(int a1, _BYTE *a2, int a3);
int __cdecl sub_809558C(int a1);
int __cdecl sub_80955A2(int, void *src, size_t n); // idb
int __cdecl sub_80955EA(int a1);
int __cdecl sub_8095626(size_t n, void *src, int a3, int a4, int a5, int a6, int a7);
int sub_8095696();
int __cdecl sub_8095742(int a1);
int __cdecl sub_80960BA(float, float); // idb
int __cdecl sub_80960DE(float, float); // idb
long double __cdecl sub_8096102(float a1, float a2, float a3);
int *__cdecl sub_809612C(int a1, int a2, int a3, int a4, int a5, int *a6);
_DWORD *__cdecl sub_80962A0(int a1, int a2, int a3, int a4, int a5, int *a6);
int __cdecl sub_80963EC(char *a1, int *a2);
_DWORD *__cdecl sub_80966D6(_DWORD *a1, _DWORD *a2);
int __cdecl sub_80967E4(_DWORD *a1, _DWORD *a2, signed int a3);
void __cdecl sub_80968B8(int a1);
_DWORD *__cdecl sub_8096970(int a1, _DWORD *a2);
_DWORD *__cdecl sub_8096996(int a1, _DWORD *a2);
int __cdecl sub_80969BC(float *a1, int a2, _DWORD *a3);
int __cdecl sub_8096C56(int a1, int a2, float *a3, int a4, _DWORD *a5);
_DWORD *__cdecl sub_8096E9E(int a1);
_DWORD *__cdecl sub_8097A28(int *a1);
signed int __cdecl sub_8097B54(int a1, _DWORD *a2, void *a3);
signed int __cdecl sub_8097BD0(int a1, int a2, int a3);
signed int __cdecl sub_8097EDA(int a1, int *a2, _DWORD *a3, void *a4);
int __cdecl sub_809822C(char *a1);
int __cdecl sub_80988F4(int a1, signed int a2);
// int __usercall sub_80989C6@<eax>(long double a1@<st0>, int a2, int a3);
// int __usercall sub_8098C0E@<eax>(long double a1@<st0>, int a2);
int sub_8098E3A();
// void __usercall sub_8099AF2(long double a1@<st0>);
long double __cdecl sub_8099D74(float a1, float a2, float a3);
int __cdecl sub_8099D8A(_DWORD *a1);
int __cdecl sub_8099DB4(_DWORD *a1, _DWORD *a2);
int __cdecl sub_8099DE4(int a1, _DWORD *a2);
int __cdecl sub_8099EC6(_DWORD *a1);
int __cdecl sub_809A000(int a1);
int __cdecl sub_809A01E(int a1, int a2);
char *__cdecl sub_809A040(char a1, int a2, int a3);
void __cdecl sub_809A112(int a1, _DWORD *a2);
void __cdecl sub_809A1EA(int a1, _DWORD *a2);
signed int __cdecl sub_809A368(int a1);
int __cdecl sub_809A3BA(int a1);
void __cdecl sub_809A3E6(int a1);
int __cdecl sub_809A45E(int a1);
void __cdecl sub_809AB88(int a1, int a2, int a3);
void __cdecl sub_809AD2C(int a1, int a2, int a3);
signed int __cdecl sub_809B1A0(_DWORD *a1, int a2);
signed int __cdecl sub_809B30E(_DWORD *a1, int a2);
void __cdecl sub_809B6A8(void *s, int a2, int a3, int a4, int a5, int a6, int a7, int a8, int a9, int a10);
signed int __cdecl sub_809B9E2(float *a1, float *a2, float *a3, float *a4, int a5, int a6, int a7, int a8, int a9);
int *__cdecl sub_809BC5C(int *a1, float *a2, float *a3, float *a4, float *a5, int a6, int a7, int a8);
signed int __cdecl sub_809BE82(int a1, int a2, int a3, int a4, int a5, int a6);
void __cdecl sub_809C0CE(void *s, int a2, int a3, int a4, int a5, int a6);
int __cdecl sub_809C18C(float *a1, int a2, int a3);
int __cdecl sub_809C294(float); // idb
int __cdecl sub_809C2CA(float *a1, float *a2, float *a3);
int __cdecl sub_809C2F6(_DWORD *a1, _DWORD *a2);
int __cdecl sub_809C326(float *a1, float *a2, float *a3);
int __cdecl sub_809C36A(float *a1, float *a2, float *a3);
int __cdecl sub_809C3AE(int, float, int); // idb
int RefreshQuitOnErrorCondition();
int QuitOnError();
_BOOL4 FS_Initialized();
void FS_CheckFileSystemStarted();
signed int __cdecl FS_IwdIsPure(int a1);
int FS_LoadStack();
_BOOL4 __cdecl FS_UseSearchPath(int a1);
signed int __cdecl FS_LanguageHasAssets(int a1);
int __cdecl FS_HashFileName(int a1, int a2);
int __cdecl FS_HandleForFile(int a1);
int __cdecl FS_FileForHandle(int a1);
int __cdecl FS_filelength(int a1);
_BYTE *__cdecl sub_809C748(_BYTE *a1);
void *__cdecl FS_BuildOSPath_Internal(void *src, char *s, char *a3, void *dest, int a5);
void *__cdecl FS_BuildOSPath(void *src, char *s, char *a3, void *dest);
int __cdecl FS_CreatePath(char *haystack); // idb
void __cdecl FS_CopyFile(char *filename, char *haystack);
int __cdecl sub_809CACA(char *filename); // idb
int __cdecl sub_809CADE(char *); // idb
int __cdecl sub_809CB58(char *, char *); // idb
void *__cdecl FS_FCloseFile(int a1);
int __cdecl FS_GetHandleAndOpenFile(char *src, char *filename, char *modes, int); // idb
int __cdecl FS_FOpenFileWrite(char *src); // idb
int __cdecl FS_FOpenTextFileWrite(char *src); // idb
int __cdecl FS_FOpenFileAppend(char *src); // idb
signed int __cdecl FS_FilenameCompare(char *a1, char *a2);
int __cdecl sub_809D1C6(char *filename, char *); // idb
char *__cdecl sub_809D424(char *haystack, int a2, char a3);
_BOOL4 __cdecl sub_809D498(char *s1);
_BOOL4 __cdecl sub_809D516(_BYTE *a1);
signed int __cdecl FS_IsBackupSubStr(char a1);
signed int __cdecl FS_SanitizeFilename(int a1, int a2);
int __cdecl sub_809D6A2(char *); // idb
int __cdecl FS_FOpenFileRead_Internal(int a1, int *a2, int a3, int a4);
int __cdecl FS_FOpenFileReadStream(int a1, int *a2, int a3);
int __cdecl FS_FOpenFileRead(int a1, int *a2, int a3);
signed int __cdecl FS_TouchFile(int a1);
char *__cdecl sub_809E0E4(char *a1);
_BOOL4 __cdecl sub_809E1DA(char *a1);
_BOOL4 __cdecl sub_809E256(char *a1, int a2);
signed int __cdecl FS_Read(int a1, unsigned int a2, int a3);
size_t __cdecl sub_809E454(char *a1, size_t a2, int a3);
size_t FS_Printf(int a1, char *format, ...);
int __cdecl sub_809E580(int, int off, int); // idb
signed int __cdecl FS_ReadFile(_BYTE *a1, _DWORD *a2);
void Com_ResetParseSessions();
void __cdecl FS_FreeFile(void *ptr);
int __cdecl sub_809E99E(char *src, int, int); // idb
int __cdecl sub_809EA28(int, char *filename); // idb
int sub_809EB4A();
char *__cdecl FS_LoadZipFile(char *filename, char *a2);
int __cdecl sub_809F09C(char *src, char *dest, int); // idb
int __cdecl sub_809F12A(char *src, int, int); // idb
_DWORD *__cdecl FS_ListFilteredFiles(int a1, int a2, char *a3, int a4, int a5, int a6);
_DWORD *__cdecl sub_809F7B2(int a1, char *a2, int a3, int a4);
_DWORD *__cdecl sub_809F7F2(int a1, char *a2, int a3, int a4, int a5);
_BOOL4 __cdecl sub_809F830(char *a1, int a2);
_DWORD *__cdecl sub_809F98A(int a1, char *a2, int a3, int a4, int a5, int a6);
void __cdecl FS_FreeFileList(void *ptr);
int __cdecl FS_GetFileList(int, char *, int, char *dest, int); // idb
_BYTE *__cdecl FS_ConvertPath(_BYTE *a1);
signed int __cdecl FS_PathCmp(char *a1, char *a2);
void __cdecl FS_SortFileList(void *dest, int a2);
void __cdecl FS_DisplayPath(int a1);
void FS_FullPath_f();
void FS_Path_f();
int __cdecl IwdFileLanguage(char *s); // idb
int iwdsort(const void *, const void *); // idb
void **__cdecl FS_AddSearchPath(void **a1);
void __cdecl FS_AddIwdFilesForGameDirectory(void *a1, char *src);
void __cdecl FS_AddGameDirectoryInternal(char *a1, char *src, int a3, int a4);
void __cdecl FS_AddGameDirectory(char *a1, char *src);
void *__cdecl FS_ShutdownSearchPaths(void *ptr);
int FS_ShutdownServerIwdNames();
int FS_ShutdownServerReferencedIwds();
void FS_Shutdown();
// signed int __usercall FS_RegisterDvars@<eax>(long double a1@<st0>);
// void __usercall FS_Startup(long double a1@<st0>, char *src);
_DWORD *FS_ClearIwdReferences();
// char *__usercall FS_InitFilesystem@<eax>(long double a1@<st0>);
// char *__usercall FS_Restart@<eax>(long double a1@<st0>, int a2);
// signed int __usercall sub_80A119C@<eax>(long double a1@<st0>, int a2);
int __cdecl FS_FOpenFileByMode(char *src, int, int); // idb
int __cdecl sub_80A1330(int a1);
int __cdecl sub_80A1380(int a1);
char *sub_80A139C();
int __cdecl LittleLong(int a1);
int __cdecl sub_80A13EE(char *filename, struct stat *stat_buf); // idb
long double sub_80A1410();
long double sub_80A142E();
float *__cdecl sub_80A1442(float *a1, float *a2);
int __cdecl sub_80A14BA(int, float, int); // idb
int __cdecl sub_80A1516(float, float, int); // idb
int __cdecl sub_80A158C(int, float, int); // idb
signed int __cdecl sub_80A15FA(signed int a1, float *a2, int a3);
signed int __cdecl sub_80A16B2(signed int a1, float *a2, int a3);
signed int __cdecl sub_80A1788(signed int a1, float *a2, int a3);
long double __cdecl sub_80A1866(float a1, float a2, float a3, float a4);
void __cdecl sub_80A1902(float a1, float a2, float a3, float a4);
long double __cdecl sub_80A1986(float a1, float a2, float a3, float a4);
int __cdecl sub_80A1A02(float, float, float, float); // idb
long double __cdecl sub_80A1B68(float a1);
int __cdecl sub_80A1C2A(float *a1);
double __cdecl sub_80A1D86(_DWORD, _DWORD); // weak
long double __cdecl sub_80A1DB2(float *a1, float *a2);
void __cdecl sub_80A1E7C(float *a1, float *a2);
long double __cdecl sub_80A1EA8(float *a1, float *a2);
int __cdecl sub_80A1ED8(float *a1, float *a2, float *a3);
_DWORD *__cdecl sub_80A1FA2(float *a1, _DWORD *a2, _DWORD *a3);
long double __cdecl sub_80A20C0(float *a1);
long double __cdecl sub_80A215E(float *a1);
long double __cdecl sub_80A21D6(float *a1);
long double __cdecl sub_80A2298(float *a1, int a2);
long double __cdecl sub_80A2342(float *a1, int a2);
int *__cdecl sub_80A2672(int a1, int a2, int a3, float a4);
int __cdecl sub_80A28D8(int, float); // idb
int __cdecl sub_80A295E(int a1, int a2, float *a3);
long double __cdecl sub_80A29F6(float *a1);
long double __cdecl sub_80A2A84(float *a1);
long double __cdecl sub_80A2AF6(float *a1);
long double __cdecl sub_80A2BC8(float *a1);
int __cdecl sub_80A2C7E(float *a1, int a2);
int __cdecl sub_80A2DBE(float *a1, int a2);
void __cdecl sub_80A2EC2(float *a1, int a2, float *a3, float *a4);
void __cdecl sub_80A303A(float a1, int a2, int a3);
void __cdecl sub_80A30BA(float *a1, float *a2);
void __cdecl sub_80A318C(float *a1, float *a2, float *a3, float *a4);
int __cdecl sub_80A3416(void *s); // idb
void *__cdecl sub_80A345E(void *dest);
int __cdecl sub_80A358E(float *a1, float *a2, float *a3);
int __cdecl sub_80A3C8E(float *a1, float *a2, float *a3);
int __cdecl sub_80A442E(_DWORD *a1, _DWORD *a2);
int __cdecl sub_80A45BE(float *a1, float *a2);
int __cdecl sub_80A47DE(int a1, int a2);
int __cdecl sub_80A4E52(float *a1, float *a2, float *a3);
int __cdecl sub_80A5028(float *a1, float *a2, float *a3);
int __cdecl sub_80A50D2(float *a1, float *a2, float *a3);
int __cdecl sub_80A5194(float *a1, float *a2, float *a3);
int __cdecl sub_80A530C(int, float); // idb
int __cdecl sub_80A5372(float *a1, float *a2, float *a3);
unsigned int __cdecl sub_80A5494(_DWORD *a1, unsigned int *a2);
int __cdecl sub_80A54E2(float *a1, float *a2);
long double __cdecl sub_80A5662(float *a1);
long double __cdecl sub_80A5706(float a1);
long double __cdecl sub_80A5774(float *a1);
void __cdecl sub_80A57E8(float a1, int a2);
void __cdecl sub_80A5834(float a1, int a2);
void __cdecl sub_80A5880(float a1, int a2);
int __cdecl sub_80A58CC(float, int, int); // idb
int __cdecl sub_80A5918(int, float); // idb
int __cdecl sub_80A59B0(int, float); // idb
int __cdecl sub_80A5A48(int, float); // idb
int __cdecl sub_80A5AE0(void *s, float, float, int); // idb
int __cdecl sub_80A5B9C(void *s, float, float, float); // idb
long double __cdecl sub_80A5F4C(float a1);
long double __cdecl sub_80A6000(float a1, float a2);
int __cdecl sub_80A6062(float *a1, float *a2, float *a3);
long double __cdecl sub_80A60CE(float a1);
long double __cdecl sub_80A6112(float a1);
long double __cdecl sub_80A6154(float a1);
long double __cdecl sub_80A61D2(float a1);
int __cdecl sub_80A6258(float, float); // idb
double __cdecl sub_80A626E(_DWORD, _DWORD); // weak
double __cdecl sub_80A62FC(_DWORD, _DWORD); // weak
// void __usercall sub_80A6450(long double a1@<st0>, float *a2, float *a3);
void __cdecl sub_80A64CE(float *a1, float *a2);
void __cdecl sub_80A660A(float *a1, float *a2, float *a3);
void __cdecl sub_80A6B48(float *a1, float *a2, float *a3, float *a4);
void __cdecl sub_80A6CC8(int a1, int a2, int a3, int a4);
int __cdecl sub_80A6FE6(_DWORD *a1, _DWORD *a2);
int __cdecl sub_80A70C0(int, float, float, float, int); // idb
int __cdecl sub_80A7146(float *a1, int a2);
int __cdecl sub_80A718E(float, int); // idb
int __cdecl sub_80A71F4(int a1, int a2);
int __cdecl sub_80A7338(int a1, int a2);
signed int __cdecl sub_80A7CE6(float *a1, float *a2, float *a3, float *a4);
int __cdecl sub_80A7D80(float *a1, float *a2, int a3);
signed int __cdecl sub_80A7E1A(float *a1, float *a2, int a3);
int __cdecl sub_80A81F8(int, float, int, float, float, float, float); // idb
_BOOL4 __cdecl sub_80A831C(int a1, int a2, int a3, float a4);
int __cdecl sub_80A84C6(_DWORD *a1, int a2, _DWORD *a3);
int __cdecl sub_80A8610(float *a1, int a2, float *a3, float *a4);
int __cdecl sub_80A8664(int, float, float); // idb
int __cdecl sub_80A86CC(float, int); // idb
int __cdecl sub_80A8712(int a1);
long double __cdecl sub_80A8720(float a1, float a2);
int __cdecl sub_80A8776(int a1, int a2);
int __cdecl sub_80A87D8(float *a1, int a2);
void __cdecl sub_80A8972(float a1, int a2, int a3);
long double __cdecl sub_80A8A66(int a1, int a2, char a3);
long double __cdecl sub_80A8B40(float a1);
long double __cdecl sub_80A8B5A(float a1);
int __cdecl sub_80A8B7A(float, float); // idb
long double __cdecl sub_80A8B9E(float a1, float a2, float a3);
int __cdecl sub_80A8BDC(int a1);
int __cdecl sub_80A8BE6(float); // idb
void __cdecl sub_80A8C1C(float a1, int a2, int a3);
int __cdecl sub_80A8C4A(double, int, int); // idb
int __cdecl sub_80A8C78(_DWORD *a1);
int __cdecl sub_80A8C94(_DWORD *a1, int a2, int a3);
int __cdecl sub_80A8CAC(float *a1, float *a2, float *a3);
long double __cdecl sub_80A8CD8(float *a1, float *a2);
void __cdecl sub_80A8CFA(float *a1);
int __cdecl sub_80A8D26(_DWORD *a1);
int __cdecl sub_80A8D50(_DWORD *a1, int a2, int a3, int a4);
int __cdecl sub_80A8D74(_DWORD *a1, _DWORD *a2);
int __cdecl sub_80A8DA4(float *a1, float *a2, float *a3);
int __cdecl sub_80A8DE8(float *a1, float *a2, float *a3);
int __cdecl sub_80A8E2C(int, float, int); // idb
int __cdecl sub_80A8E64(float *a1, float *a2, float *a3);
int __cdecl sub_80A8EA8(int, float, int, int); // idb
long double __cdecl sub_80A8EFC(float *a1, float *a2);
signed int __cdecl sub_80A8F30(float *a1, float *a2);
void __cdecl sub_80A8F9A(float *a1);
int __cdecl sub_80A8FD8(int, float, int); // idb
long double __cdecl sub_80A9024(float *a1);
long double __cdecl sub_80A906A(float a1, float a2, float a3);
float *__cdecl sub_80A9094(float *a1, float *a2, float *a3);
int __cdecl sub_80A913C(float *a1, float *a2);
void __cdecl Z_FreeInternal(void *ptr);
void __cdecl sub_80A9268(void *ptr);
void __noreturn sub_80A9290();
void *__cdecl sub_80A92AC(size_t size);
void *__cdecl sub_80A92C0(size_t size);
void *__cdecl Z_MallocInternal(size_t size);
void *__cdecl sub_80A9324(size_t size);
void *__cdecl sub_80A934E(size_t size);
void *__cdecl sub_80A9362(size_t size);
char *__cdecl sub_80A93B0(char *src);
char *__cdecl sub_80A93E4(int a1, char *src);
void sub_80A945A();
void sub_80A9530();
// void __usercall Com_InitHunkMemory(long double a1@<st0>);
void *sub_80A96D6();
int __cdecl sub_80A9742(int, char *s2, int); // idb
int __cdecl sub_80A97A6(int, char *s2); // idb
_BOOL4 __cdecl sub_80A97DE(size_t a1);
int __cdecl sub_80A981E(char, char *src, int, int); // idb
int __cdecl sub_80A98A0(char a1, int a2, int (__cdecl *a3)(signed int));
int __cdecl sub_80A98DC(int, char *s2, int); // idb
unsigned int *__cdecl Hunk_ClearDataFor(unsigned int *a1, unsigned int a2, unsigned int a3);
unsigned int *Hunk_ClearData();
int __cdecl sub_80A9A8E(int a1, int a2, void (__cdecl *a3)(_DWORD, int), int a4);
unsigned int *__cdecl sub_80A9AEC(unsigned int *a1, void (__cdecl *a2)(_DWORD, int), int a3, char a4);
int sub_80A9B52();
unsigned int *__cdecl sub_80A9B5C(int a1);
unsigned int *__cdecl sub_80A9B80(int a1);
unsigned int *Hunk_Clear();
void *__cdecl Hunk_AllocInternal(size_t n);
void *__cdecl Hunk_AllocAlignInternal(size_t n, int a2);
size_t __cdecl sub_80A9CF0(int a1);
int sub_80A9DB4();
void *__cdecl sub_80A9DC4(size_t n);
void *__cdecl sub_80A9DE0(size_t n, int a2);
int sub_80A9ECE();
_DWORD *__cdecl Hunk_AllocateTempMemory(size_t size);
unsigned int __cdecl sub_80AA00A(int a1);
void __cdecl sub_80AA0C8(void *ptr);
int sub_80AA124();
int sub_80AA13C();
int __cdecl sub_80AA15A(int a1);
int __cdecl sub_80AA194(int a1);
int __cdecl sub_80AA1BC(int a1);
char *__cdecl sub_80AA1CA(int a1);
int __cdecl sub_80AA1F6(int *a1, int a2);
int __cdecl sub_80AA22A(int *a1);
char *__cdecl sub_80AA240(int *a1);
void LargeLocalReset();
char *__cdecl sub_80AA268(char *s, char *a2, int a3);
int __cdecl Com_Filter(int, char *, int); // idb
int __cdecl sub_80AA618(int a1, int a2, int a3);
int __cdecl sub_80AA70C(int a1, int a2);
void *__cdecl Com_Memcpy(void *dest, void *src, size_t n);
void *__cdecl sub_80AA83E(void *s, int c, size_t n);
int __cdecl sub_80AA860(_BYTE *a1);
int __cdecl sub_80AA8AA(char *a1);
int __cdecl sub_80AA91A(char **a1);
int __cdecl sub_80AA976(char *a1, int a2);
signed int __cdecl sub_80AAA06(char *a1, int a2);
char *__cdecl sub_80AAA84(int a1, char *s);
void sub_80AABBA();
void __cdecl sub_80AAD12(char *src, int s2, int a3);
int __cdecl sub_80AAEDC(int a1);
int __cdecl sub_80AAF4A(char *a1);
int __cdecl sub_80AAF92(int a1);
int __cdecl sub_80AB0E2(char *a1);
int sub_80AB104();
void *sub_80AB112();
_DWORD *__cdecl sub_80AB11C(size_t size);
void *__cdecl sub_80AB130(size_t a1);
signed int __cdecl sub_80AB144(_BYTE *a1, _BYTE *a2, int a3);
int sub_80AB1DC();
long double __cdecl sub_80AB204(char *s1, int a2);
char *__cdecl sub_80AB28A(char *dest, char *src, char *s1);
signed int __cdecl sub_80AB40A(_BYTE *a1);
int __cdecl sub_80AB496(char *a1, int a2, int a3);
int __cdecl sub_80AB5B2(char *a1, int a2, int a3);
int __cdecl sub_80AB650(char *a1, int a2, int a3);
int __cdecl sub_80AB6C2(char *s, char *s2, char *src, int a4);
void __cdecl sub_80AB830(char *s1, int a2, int a3);
char *__cdecl sub_80AB8F4(char *haystack, int a2);
void __cdecl sub_80AB93E(char *a1, char *s2, int a3, char *s, int a5, int a6, int a7);
signed int __cdecl sub_80ABEF8(int a1);
int __cdecl sub_80AC1A8(_DWORD *a1);
void sub_80AC22C();
_DWORD *__cdecl sub_80AC246(int a1);
void sub_80AC576();
_DWORD *__cdecl sub_80AC582(char *s1, char *s2, char *src);
signed int __cdecl sub_80AC880(int a1, int a2);
int __cdecl sub_80AC8A0(int a1, int *a2, int (__cdecl *a3)(char *, int), unsigned __int8 a4);
signed int __cdecl sub_80ACAF4(int a1, int a2);
void __cdecl sub_80ACB66(int a1, int a2);
int __cdecl sub_80ACC2E(_DWORD *a1, int a2, int a3);
int __cdecl sub_80ACC4E(int a1, int a2, int a3, int a4, int a5);
int __cdecl sub_80ACE9A(int a1, _DWORD *a2);
signed int __cdecl sub_80AD3E6(char a1, char *src, float *a3);
signed int __cdecl sub_80AD6F6(int a1, float *a2);
_DWORD *__cdecl sub_80AD920(_DWORD *a1);
signed int __cdecl sub_80AD964(char *a1);
char *__cdecl sub_80ADA6A(char *a1);
size_t __cdecl sub_80ADBCA(char *a1, char *a2, int a3);
void __cdecl sub_80ADC96(int a1, char *a2);
void __cdecl sub_80ADFEA(char *a1, char *s2);
void __cdecl sub_80AEB14(char *filename, char *a2);
void sub_80AEC4E();
long double __cdecl sub_80AEE5E(float a1, float a2, float a3);
long double __cdecl sub_80AEE9C(float a1, float a2, float a3);
int __cdecl Dvar_SetInAutoExec(unsigned __int8 a1);
int Dvar_IsSystemActive();
int __cdecl sub_80AEEEC(int a1);
signed int __cdecl sub_80AEF62(int a1);
char *__cdecl sub_80AEFD0(int a1);
int __cdecl sub_80AF012(int a1);
void __cdecl sub_80AF06A(int a1);
char *__cdecl sub_80AF080(char *src);
void __cdecl sub_80AF094(void *ptr);
char *__cdecl sub_80AF0A8(char *s);
void __cdecl sub_80AF180(void *ptr);
int __cdecl sub_80AF1CE(int a1);
int __cdecl sub_80AF20A(int a1);
int __cdecl sub_80AF246(int a1);
char *__cdecl sub_80AF282(int a1, char *s1);
char *__cdecl sub_80AF316(int a1, char *s1);
char *__cdecl sub_80AF3AA(int a1, char *s1);
void *__cdecl sub_80AF43E(_DWORD *a1);
void *__cdecl sub_80AF474(int a1, char *nptr);
char *__cdecl sub_80AF502(int a1, float *a2);
_BOOL4 __cdecl sub_80AF6DE(char *nptr);
int __cdecl sub_80AF704(char *nptr); // idb
long double __cdecl sub_80AF718(char *nptr);
char *__cdecl sub_80AF738(char *s);
char *__cdecl sub_80AF782(char *s);
char *__cdecl sub_80AF7D6(char *s);
int __cdecl sub_80AF834(int, char *s1); // idb
// int __usercall sub_80AF95E@<eax>(long double a1@<st0>, char *s, int a3);
// float *__userpurge sub_80AFA9E@<eax>(long double a1@<st0>, float *a2, char a3, int a4, int a5, char *nptr);
char *__cdecl Dvar_DisplayableValue(int a1);
char *__cdecl Dvar_DisplayableResetValue(int a1);
char *__cdecl Dvar_DisplayableLatchedValue(int a1);
int __cdecl sub_80AFBFE(int, int, float, float); // idb
int __cdecl sub_80AFC80(int, int, float, float); // idb
// float *__userpurge sub_80AFCF6@<eax>(float *a1, char a2, float a3, float a4, float a5, float a6);
signed int __cdecl sub_80AFE1A(char a1, int a2, float a3, float a4);
int __cdecl sub_80AFF9A(int, int, int, char *s, size_t maxlen); // idb
char *__cdecl sub_80B009A(int a1, int a2, int a3, char *s, size_t maxlen, int a6);
char *__cdecl sub_80B0410(int a1, int a2, int a3, char *s, size_t maxlen);
char *__cdecl sub_80B045A(int a1, int a2, int a3, char *s, size_t maxlen, int a6);
void __cdecl sub_80B04A4(unsigned __int8 a1, int a2, int a3);
int __cdecl sub_80B04FE(int, char *s1, char *s2); // idb
char *__cdecl sub_80B0620(int a1, char *s1);
int __cdecl Dvar_HasLatchedValue(int a1);
int __cdecl sub_80B06F8(int a1);
void __cdecl sub_80B072A(int a1, char *s1, int a3);
int __cdecl Dvar_FindMalleableVar(char *a1);
int __cdecl Dvar_FindVar(char *a1);
int __cdecl Dvar_ClearModified(int a1);
int __cdecl Dvar_GetBool(char *a1);
int __cdecl Dvar_GetInt(char *a1);
long double __cdecl sub_80B0C60(char *a1);
char *__cdecl sub_80B0CAC(char *a1);
char *__cdecl sub_80B0CFA(char *a1);
char *__cdecl sub_80B0D48(char *a1);
void *__cdecl sub_80B0D96(char *a1);
char *__cdecl sub_80B0DE0(char *a1);
// int __usercall sub_80B0E28@<eax>(long double a1@<st0>, int a2, float *a3);
// int __usercall sub_80B0ED2@<eax>(long double a1@<st0>, char *a2, float *a3);
void *sub_80B0F16();
void __cdecl sub_80B0FF8(int a1);
void __cdecl sub_80B10CE(int a1, __int16 a2);
int __cdecl sub_80B1120(__int16 a1);
char *__cdecl sub_80B1164(int a1, char *s1);
char *__cdecl sub_80B1208(int a1, char *s1);
char *__cdecl sub_80B1222(int a1, char *s1);
// int __usercall sub_80B1334@<eax>(long double a1@<st0>, int a2, int a3, int a4, int a5, char *s1, int a7, int a8);
// _DWORD *__userpurge sub_80B1498@<eax>(_DWORD *a1, int a2, int a3);
// int __usercall sub_80B14CC@<eax>(long double a1@<st0>, int a2, int a3, unsigned __int8 a4, unsigned __int16 a5, int a6, int a7, int a8);
int __cdecl sub_80B15C0(int a1, int a2, int a3, __int16 a4, int a5, int a6, int a7);
void __cdecl sub_80B1634(int a1);
char *__cdecl sub_80B165C(int a1);
// void __usercall Dvar_Reregister(long double a1@<st0>, int a2, int a3, int a4, int a5, char *s1, int a7, int a8);
char *__cdecl Dvar_RegisterNew(char *src, int a2, int a3, char *s, int a5, int a6);
// char *__usercall Dvar_RegisterVariant@<eax>(long double a1@<st0>, char *src, int a3, int a4, char *s1, int a6, int a7);
// char *__usercall Dvar_RegisterBool@<eax>(long double a1@<st0>, char *src, int a3, int a4);
// char *__usercall Dvar_RegisterInt@<eax>(long double a1@<st0>, char *src, int a3, int a4, int a5, int a6);
// char *__usercall Dvar_RegisterFloat@<eax>(long double a1@<st0>, char *src, int a3, int a4, int a5, int a6);
// char *__usercall sub_80B1C7E@<eax>(long double a1@<st0>, char *src, int a3, int a4, int a5, int a6, int a7);
// char *__usercall sub_80B1CE8@<eax>(long double a1@<st0>, char *src, int a3, int a4, int a5, int a6, int a7, int a8);
// char *__usercall sub_80B1D5A@<eax>(long double a1@<st0>, char *src, int a3, int a4, int a5, int a6, int a7, int a8, int a9);
// char *__usercall Dvar_RegisterString@<eax>(long double a1@<st0>, char *src, int a3, int a4);
// char *__usercall sub_80B1E32@<eax>(long double a1@<st0>, char *src, int a3, int a4, int a5);
// char *__usercall sub_80B1EA0@<eax>(long double a1@<st0>, char *src, float a3, float a4, float a5, float a6, int a7);
void __cdecl sub_80B1FDA(int a1, char a2, int a3);
void __cdecl sub_80B2030(int a1, char *a2, int a3);
void __cdecl sub_80B2096(int a1, char *a2, int a3);
void __cdecl sub_80B20F0(int a1, int a2, int a3, int a4);
void __cdecl sub_80B216A(int a1, int a2, int a3, int a4, int a5);
void __cdecl sub_80B21FC(int a1, int a2, int a3, int a4, int a5, int a6);
void __cdecl sub_80B229C(int a1, char *src, int a3);
// void __usercall sub_80B230A(long double a1@<st0>, int a2, float a3, float a4, float a5, float a6, int a7);
void __cdecl Dvar_SetBool(int a1, char a2);
void __cdecl Dvar_SetInt(int a1, char *a2);
void __cdecl sub_80B24AC(int a1, char *a2);
void __cdecl sub_80B24CE(int a1, int a2, int a3);
void __cdecl sub_80B24F8(int a1, int a2, int a3, int a4);
void __cdecl sub_80B2528(int a1, int a2, int a3, int a4, int a5);
void __cdecl Dvar_SetString(int a1, char *src);
// void __usercall sub_80B2582(long double a1@<st0>, int a2, float a3, float a4, float a5, float a6);
// void __usercall sub_80B25BA(long double a1@<st0>, int a2, char *src, int a4);
// void __usercall sub_80B269C(long double a1@<st0>, int a2, char *src);
// void __usercall sub_80B26BE(long double a1@<st0>, char *src, int a3);
// void __usercall Dvar_SetIntByName(long double a1@<st0>, char *src, int a3);
void __cdecl sub_80B2792(char *src, int a2);
void __cdecl sub_80B27EC(char *src, int a2, int a3);
void __cdecl sub_80B2854(char *src, int a2, int a3, int a4);
void __cdecl sub_80B28CA(char *src, int a2, int a3, int a4, int a5);
// void __usercall sub_80B294E(long double a1@<st0>, char *src, char *a3);
// void __usercall sub_80B2998(long double a1@<st0>, char *src, int a3, int a4, int a5, int a6);
// char *__usercall sub_80B2A6A@<eax>(long double a1@<st0>, char *src, char *a3, int a4);
// char *__usercall sub_80B2AC2@<eax>(long double a1@<st0>, char *src, char *a3);
// char *__usercall Dvar_SetCommand@<eax>(long double a1@<st0>, char *src, char *a3);
int __cdecl sub_80B2B42(int a1, int a2);
void __cdecl sub_80B2B5A(int a1, int a2);
int sub_80B2B80();
// void __usercall Dvar_Init(long double a1@<st0>);
int sub_80B2C06();
signed int sub_80B2C3C();
size_t __cdecl sub_80B2C82(int a1, unsigned __int16 a2);
// int __usercall sub_80B2D56@<eax>(long double a1@<st0>, int a2, int a3);
int __cdecl sub_80B2E34(unsigned __int16 a1, int a2);
int __cdecl sub_80B2E78(int, int, char *s, size_t maxlen); // idb
// int __usercall sub_80B2F1A@<eax>(long double a1@<st0>, int a2, size_t n, char *a4, char src);
int __cdecl sub_80B30FE(float, float); // idb
int __cdecl sub_80B3122(float, float); // idb
int __cdecl sub_80B3146(float); // idb
int __cdecl sub_80B317C(_DWORD *a1);
int __cdecl sub_80B3198(_DWORD *a1, int a2, int a3);
int __cdecl sub_80B31B0(_DWORD *a1, _DWORD *a2);
signed int __cdecl sub_80B31D0(float *a1, float *a2);
int __cdecl sub_80B321E(_DWORD *a1);
int __cdecl sub_80B3248(_DWORD *a1, int a2, int a3, int a4);
int __cdecl sub_80B326C(_DWORD *a1, _DWORD *a2);
signed int __cdecl sub_80B329C(float *a1, float *a2);
int __cdecl sub_80B3306(_DWORD *a1);
int __cdecl sub_80B333C(_DWORD *a1, int a2, int a3, int a4, int a5);
int __cdecl sub_80B336A(_DWORD *a1, _DWORD *a2);
signed int __cdecl sub_80B33AA(float *a1, float *a2);
_DWORD *__cdecl sub_80B3432(_DWORD *a1, _DWORD *a2);
_BOOL4 __cdecl sub_80B3442(_DWORD *a1, _DWORD *a2);
signed int __cdecl sub_80B3458(_BYTE *a1, _BYTE *a2, int a3);
long double __cdecl sub_80B34F0(float a1, float a2, float a3);
int __cdecl sub_80B351C(int a1, size_t n, void *src);
int __cdecl sub_80B353E(int a1, int a2, int a3, char a4);
void *__cdecl sub_80B35E6(void *s);
int __cdecl sub_80B3636(int, size_t n, void *src); // idb
int __cdecl sub_80B36E4(int, char *s); // idb
int __cdecl sub_80B3710(int a1, int a2);
int __cdecl sub_80B3796(int, size_t n, void *dest); // idb
void *__cdecl sub_80B3844(int a1);
void *sub_80B38E8();
int __cdecl sub_80B38F2(int a1);
char *__cdecl sub_80B396A(char *src);
_DWORD *sub_80B3A3C();
_DWORD *CM_Cleanup();
bool __cdecl sub_80B3B00(int a1);
int sub_80B3B6C();
void __noreturn sub_80B3BFE(char *format, ...);
void Com_ScriptWarning(char *format, ...);
int sub_80B3D92();
int __cdecl sub_80B3DEC(_DWORD *a1, _DWORD *a2);
int __cdecl sub_80B3E58(_DWORD *a1, _DWORD *a2);
_BYTE *__cdecl sub_80B3EC8(_BYTE *a1, _DWORD *a2);
int __cdecl sub_80B3F36(_BYTE *a1);
int sub_80B4072();
_BYTE *__cdecl sub_80B408C(_BYTE **a1, int a2);
char *__cdecl sub_80B4220(char **a1, int a2);
char *__cdecl Com_Parse(char **a1);
char *__cdecl sub_80B4848(char **a1);
int __cdecl sub_80B48D0(int, char *s2, int); // idb
signed int __cdecl sub_80B494C(char **a1, int a2);
_BYTE *__cdecl sub_80B49B8(_DWORD *a1);
int __cdecl sub_80B4A1C(char **a1);
char *__cdecl sub_80B4A72(char **a1);
long double __cdecl sub_80B4AEE(char **a1);
long double __cdecl sub_80B4B1C(char **a1);
int __cdecl sub_80B4B4A(char **a1);
int __cdecl sub_80B4B6C(char **a1);
int __cdecl sub_80B4B8E(char **a1, int a2, int a3);
int __cdecl sub_80B4C14(char **a1, int a2, int a3, int a4);
int __cdecl sub_80B4C8E(char **a1, int a2, int a3, int a4, int a5);
signed int __cdecl sub_80B4D14(char a1);
int __cdecl sub_80B4D44(_BYTE *a1);
void *__cdecl sub_80B4D74(void *src, char *s, char *a3, void *dest, int a5);
_BYTE *__cdecl sub_80B4E42(_BYTE *a1);
_BYTE *__cdecl sub_80B4E98(_BYTE *a1, _BYTE *a2);
char *__cdecl sub_80B4ED6(void *src, void *dest);
char *__cdecl Com_DefaultExtension(char *s, size_t maxlen, int a3);
int __cdecl sub_80B4F9A(__int16 a1);
int __cdecl sub_80B4FB8(int a1);
int __cdecl sub_80B4FCE(int a1, int a2);
int __cdecl sub_80B4FF6(__int16 a1);
int __cdecl sub_80B5014(int a1);
int __cdecl sub_80B502A(int a1);
int __cdecl sub_80B5040(int a1);
int __cdecl sub_80B5056(__int16 a1);
int __cdecl sub_80B508E(__int16 a1);
int __cdecl sub_80B50A2(int a1);
int __cdecl sub_80B50FE(int a1);
unsigned __int64 __cdecl sub_80B5106(__int64 a1);
__int64 __cdecl sub_80B5242(__int64 a1);
long double __cdecl sub_80B525C(int a1);
void __cdecl sub_80B5290(float a1);
int __cdecl sub_80B52A4(int a1);
int __cdecl sub_80B52D2(char a1);
void sub_80B52E6();
void sub_80B5332();
void Swap_Init();
signed int __cdecl sub_80B53C8(signed int a1);
signed int __cdecl sub_80B53EE(signed int a1);
signed int __cdecl sub_80B5414(signed int a1);
signed int __cdecl sub_80B5448(signed int a1);
signed int __cdecl sub_80B546E(signed int a1);
char *__cdecl I_strncpyz(char *dest, char *src, int a3);
signed int __cdecl sub_80B550A(char *a1, char *a2, int a3);
signed int __cdecl I_strncmp(char *a1, char *a2, int a3);
signed int __cdecl I_stricmp(char *a1, char *a2);
signed int __cdecl sub_80B5642(char *a1, char *a2);
signed int __cdecl sub_80B5664(char *a1, char *a2);
_BYTE *__cdecl sub_80B573C(_BYTE *a1);
_BYTE *__cdecl sub_80B577E(_BYTE *a1);
char *__cdecl sub_80B57C0(char *s, int a2, char *src);
int __cdecl sub_80B5814(_BYTE *a1);
char *__cdecl sub_80B587C(char *a1);
signed int __cdecl sub_80B5904(char a1);
int Com_sprintf(char *s, size_t maxlen, char *format, ...);
_BOOL4 __cdecl sub_80B5970(unsigned int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, int a9, int a10, int a11, int a12, int a13, int a14, int a15, int a16, int a17, int a18, int a19, int a20, int a21, int a22, int a23, int a24, int a25, int a26, int a27, int a28, int a29, int a30, int a31, int a32, int a33, int a34, int a35, int a36, int a37, int a38, int a39, int a40, int a41, int a42, int a43, int a44, int a45, int a46, int a47, int a48, int a49, int a50, int a51, int a52, int a53, int a54, int a55, int a56, int a57, int a58, int a59, int a60, int a61, int a62, int a63);
char *va(char *format, ...);
int __cdecl sub_80B5A86(int a1);
char *__cdecl sub_80B5B30(char *s, int a2);
char *__cdecl sub_80B5D40(char *s, char *s1);
char *__cdecl sub_80B5E72(char *s, char *s1);
_BOOL4 __cdecl sub_80B5FA4(char *s);
void __cdecl sub_80B5FF6(char *s, char *s1, int a3);
void __cdecl sub_80B622A(char *s, char *s1, int a3);
_BOOL4 __cdecl sub_80B645E(int a1, int a2, int a3, char *s, int a5, int a6, int a7);
long double __cdecl sub_80B6688(float a1);
long double __cdecl sub_80B66A6(float a1);
void __cdecl sub_80B66C0(int a1, int a2, float a3, float a4, float a5);
int __cdecl sub_80B6758(float *a1, float *a2, float *a3);
int __cdecl sub_80B6806(float *a1, float *a2, float *a3);
float *__cdecl sub_80B68EE(float *a1, float *a2, float *a3);
int __cdecl sub_80B6998(float *a1, float *a2, float *a3);
long double __cdecl sub_80B6D1E(float a1);
long double __cdecl sub_80B6D38(float a1);
int __cdecl sub_80B6D58(int a1);
long double __cdecl sub_80B6D62(float a1);
int __cdecl sub_80B6D74(_DWORD *a1, int a2, int a3, int a4);
int __cdecl sub_80B6D98(int, float, int, int); // idb
long double __cdecl sub_80B6DEC(float *a1, float *a2);
int __cdecl sub_80B6E20(char *s1); // idb
const char *__cdecl sub_80B6EB2(signed int a1);
int DObjInit();
int DObjShutdown();
void sub_80B6F64();
void __cdecl sub_80B6F74(int a1);
int __cdecl sub_80B712C(int a1, int a2);
int __cdecl sub_80B71A8(int a1);
int __cdecl sub_80B73C0(int a1, int a2, int a3);
int *__cdecl sub_80B75A8(int a1, int a2);
int __cdecl sub_80B7796(int a1, int a2);
signed int __cdecl sub_80B77C2(int a1, int a2);
int *__cdecl sub_80B7822(int a1, int a2);
_DWORD *__cdecl sub_80B7D70(_DWORD *a1, int a2);
int __cdecl sub_80B7DFC(int a1);
int __cdecl sub_80B7EFC(signed __int16 ***a1, unsigned int a2, int a3, int a4, __int16 a5);
_DWORD *__cdecl sub_80B812E(const void *a1, int a2, int a3);
int __cdecl sub_80B819E(int a1);
int __cdecl sub_80B821A(unsigned __int8 *a1, _DWORD *a2, _WORD *a3, _DWORD *a4, _WORD *a5);
int __cdecl sub_80B8380(int a1);
_BOOL4 __cdecl sub_80B83A2(int a1, int a2);
int __cdecl sub_80B840A(int a1);
int *__cdecl sub_80B8424(int a1, int a2, int *a3);
int __cdecl sub_80B8490(int a1, int a2);
int __cdecl sub_80B84A0(int a1, _DWORD *a2, _DWORD *a3);
int __cdecl sub_80B84D2(int a1);
signed int __cdecl sub_80B858C(int a1, int a2, int a3);
signed int __cdecl sub_80B8616(int a1, int a2, int a3);
const char *__cdecl sub_80B8768(int a1, int a2, int a3, int a4);
int __cdecl sub_80B87BE(int, int, void *s, int); // idb
int __cdecl sub_80B8AF6(int a1, int a2);
int __cdecl sub_80B8B16(int a1, int a2);
int __cdecl sub_80B8BB6(int a1);
signed int __cdecl sub_80B8BC0(int a1);
int __cdecl sub_80B8C0C(int a1);
int __cdecl sub_80B8C18(float *a1, float *a2, float *a3);
void __cdecl sub_80B8CA6(int a1, float *a2, float *a3, int a4, int a5);
int __cdecl sub_80B955A(int a1, float *a2, float *a3, int a4, int a5);
int __cdecl sub_80B9676(int, int, float); // idb
long double __cdecl sub_80B9698(int a1);
signed int __cdecl sub_80B96F8(int a1, int a2);
int __cdecl sub_80B9748(int a1, _DWORD *a2, float *a3, int a4);
signed int __cdecl sub_80B98CC(int a1, int a2, int a3, float *a4);
signed int __cdecl sub_80B994A(int a1, int a2, int a3, _DWORD *a4, float *a5);
signed int __cdecl sub_80B99C6(int a1, int a2, int a3, _DWORD *a4, float *a5);
int __cdecl sub_80B9A48(float); // idb
void __cdecl sub_80B9A6E(float a1, int a2, int a3);
int __cdecl sub_80B9A9C(_DWORD *a1, _DWORD *a2);
long double __cdecl sub_80B9ABC(float *a1, float *a2);
int __cdecl sub_80B9ADE(_DWORD *a1);
int __cdecl sub_80B9B08(_DWORD *a1, int a2, int a3, int a4);
int __cdecl sub_80B9B2C(_DWORD *a1, _DWORD *a2);
int __cdecl sub_80B9B5C(float *a1, float *a2, float *a3);
int __cdecl sub_80B9BA0(float *a1, float *a2, float *a3);
int __cdecl sub_80B9BE4(int, float, int); // idb
int __cdecl sub_80B9C1C(int, float, int, int); // idb
long double __cdecl sub_80B9C70(float *a1, float *a2);
long double __cdecl sub_80B9CA4(float *a1);
int __cdecl sub_80B9CD8(_DWORD *a1, int a2, int a3, int a4, int a5);
long double __cdecl sub_80B9D06(float a1, float a2, float a3);
long double __cdecl sub_80B9D30(float *a1);
signed int __cdecl sub_80B9D76(signed int a1);
// float __usercall sub_80B9DC6@<eax>(float *a1, float *a2);
// float __usercall sub_80B9E7A@<eax>(float *a1, float *a2);
// float __usercall sub_80B9FB2@<eax>(float *a1, float *a2);
bool XAnimInit();
int XAnimShutdown();
void sub_80BA246();
int __cdecl sub_80BA256(int a1);
int __cdecl sub_80BA2DE(char *s2); // idb
int __cdecl sub_80BA2FA(const void *a1, int (__cdecl *a2)(signed int));
unsigned __int16 *__cdecl sub_80BA3AE(char *src, int a2);
char *__cdecl sub_80BA4D8(int a1, int a2, char *s);
char *__cdecl sub_80BA57A(int a1, int a2, char *s, int a4, int a5, int a6);
char **__cdecl sub_80BA626(char *s, int a2, int a3);
int __cdecl sub_80BA6D0(int a1, int (__cdecl *a2)(int, int));
int __cdecl sub_80BA704(int a1);
int __cdecl sub_80BA7BC(int a1);
_DWORD *__cdecl sub_80BA7E4(int a1, int (__cdecl *a2)(int));
int __cdecl sub_80BA836(_DWORD *a1, int (__cdecl *a2)(_DWORD *, int));
int __cdecl sub_80BA87C(int a1);
int __cdecl sub_80BA886(int a1, int a2, int a3);
__int16 __cdecl sub_80BAACE(float a1, signed int a2, int a3);
int __cdecl sub_80BAB16(int, float, int); // idb
int __cdecl sub_80BAB6C(int, float, int); // idb
int __cdecl sub_80BABCE(int, float, int); // idb
int __cdecl sub_80BAC36(int, int, float, int, int); // idb
int __cdecl sub_80BAD76(int a1, _DWORD *a2, int a3);
int __cdecl sub_80BADE6(unsigned __int16 *a1, float *a2);
int __cdecl sub_80BAE2E(int a1, int a2);
int __cdecl sub_80BAE6E(unsigned __int16 *a1, _DWORD *a2);
int __cdecl sub_80BAEBA(unsigned __int16 **a1, _DWORD *a2);
int __cdecl sub_80BAEEC(int a1, int a2, signed int a3, int *a4, float *a5);
int __cdecl sub_80BB060(int a1, int a2, signed int a3, int *a4, float *a5);
int __cdecl sub_80BB0BA(signed __int16 *a1, float a2, signed int a3, float *a4);
int __cdecl sub_80BB15E(int a1, float a2, signed int a3, int a4);
int __cdecl sub_80BB1AC(unsigned __int16 *a1, float a2, signed int a3, _DWORD *a4);
int __cdecl sub_80BB25E(unsigned __int16 **a1, float a2, signed int a3, _DWORD *a4);
int __cdecl sub_80BB29E(int a1, int a2, signed int a3, int *a4, float *a5);
int __cdecl sub_80BB444(int a1, int a2, signed int a3, int *a4, float *a5);
int __cdecl sub_80BB49E(signed __int16 *a1, float a2, signed int a3, float *a4);
int __cdecl sub_80BB542(int a1, float a2, signed int a3, int a4);
int __cdecl sub_80BB590(unsigned __int16 *a1, float a2, signed int a3, _DWORD *a4);
int __cdecl sub_80BB642(unsigned __int16 **a1, float a2, signed int a3, _DWORD *a4);
int __cdecl sub_80BB682(int, float, int, int); // idb
void __cdecl sub_80BB77C(float *a1, float *a2);
int __cdecl sub_80BB82A(int, float, float, float, int, int); // idb
int __cdecl sub_80BB9A8(int, float, float, int); // idb
int __cdecl sub_80BBA2E(int a1);
int __cdecl sub_80BBA62(int a1, int a2);
long double __cdecl sub_80BBAD0(_DWORD *a1, int a2);
int __cdecl sub_80BBC06(int, float); // idb
long double __cdecl sub_80BBC94(int a1, int a2, float a3, float a4);
long double __cdecl sub_80BBDC8(int a1, int a2, int a3, int a4, int a5, float a6);
int __cdecl sub_80BBED6(int, int, float, int); // idb
void __cdecl sub_80BBF7C(int a1, int a2, float a3);
void __cdecl sub_80BC382(int a1, int a2, int a3, int a4, float a5);
void __cdecl sub_80BC52E(int a1, int a2, float a3, int a4);
_WORD *__cdecl sub_80BC8C8(_WORD *a1);
int __cdecl sub_80BC912(int a1, int a2);
signed int __cdecl sub_80BCA42(int a1);
int __cdecl sub_80BCAB4(_DWORD *a1, int a2);
int __cdecl sub_80BCB3A(int, int, int, float, int, int, int); // idb
int __cdecl sub_80BCE1C(int a1, int a2, int a3);
long double __cdecl sub_80BCE56(int a1, int a2, int a3, int a4, int a5, float a6);
long double __cdecl sub_80BCF74(int a1, int a2, float a3);
void __cdecl sub_80BD2FC(int a1, int a2, int a3, float a4);
void __cdecl sub_80BD62C(int a1, int a2, float a3, int a4, int a5, int a6, int a7, int a8);
void __cdecl sub_80BDE00(int *a1, int a2, int a3);
void __cdecl sub_80BE1F4(int a1, int a2, float a3, int a4, int a5, int a6);
long double __cdecl sub_80BE760(int a1, int a2);
signed int __cdecl sub_80BE794(int a1, int a2);
long double __cdecl sub_80BE7D2(int a1, int a2);
long double __cdecl sub_80BE816(int a1, int a2);
int __cdecl sub_80BE8E4(int a1, int a2);
int __cdecl sub_80BE8F4(int a1, int a2, int a3);
void *__cdecl sub_80BE908(int a1, int a2);
int __cdecl sub_80BE940(int a1);
char *__cdecl sub_80BE94C(int a1, int a2);
int __cdecl sub_80BEA0E(int a1);
int __cdecl sub_80BEA18(int a1);
int __cdecl sub_80BEA24(int, int, float); // idb
int __cdecl sub_80BEA94(int, float); // idb
void __cdecl sub_80BEAEE(int a1, float a2);
int __cdecl sub_80BEB76(int, float, int); // idb
int *__cdecl sub_80BEC88(int a1, int a2);
void __cdecl sub_80BEEE4(int **a1);
int __cdecl sub_80BEF2C(int a1, int a2, _DWORD *a3, _DWORD *a4, char a5);
int __cdecl sub_80BEFE2(int a1, int a2, _DWORD *a3, _DWORD *a4);
int __cdecl sub_80BF08C(int, int, int, int, float, float); // idb
int __cdecl sub_80BF1A4(int, int, int, int, float); // idb
int __cdecl sub_80BF2AE(int a1, int a2);
int __cdecl sub_80BF346(int a1, int a2, float a3);
int __cdecl sub_80BF3FE(_DWORD *a1, int a2, float a3);
int __cdecl sub_80BF482(_DWORD *a1, int a2, float a3);
int __cdecl sub_80BF4DC(int, int, float, float); // idb
void __cdecl sub_80BF62C(int a1, int a2, float a3, float a4, int a5, int a6, int a7);
int __cdecl sub_80BF6AC(int, int, int, float, float, int, int, int); // idb
int __cdecl sub_80BF81E(int, int, float, float, int, int, int); // idb
int __cdecl sub_80BF89E(_DWORD *a1, int a2, float a3);
int __cdecl sub_80BF8F8(_DWORD *a1, int a2);
int __cdecl sub_80BF980(int a1);
int __cdecl sub_80BFA1E(_DWORD *a1);
int __cdecl sub_80BFA44(_DWORD *a1, int a2);
int __cdecl sub_80BFB06(int, int, float, int, int, int, int, int); // idb
int __cdecl sub_80BFD38(int a1, int a2, int a3);
void *__cdecl sub_80BFD6A(size_t n);
int __cdecl sub_80BFD86(_DWORD *a1, int a2, unsigned __int8 a3);
int __cdecl sub_80BFF8E(_DWORD *a1, int a2);
int __cdecl sub_80C006C(_DWORD *a1);
signed int __cdecl sub_80C0088(int a1, int a2);
_BOOL4 __cdecl sub_80C00CA(int a1, int a2);
char *__cdecl sub_80C00E2(_DWORD *a1, int a2, int a3);
void __cdecl sub_80C0164(_DWORD *a1, float *a2, _WORD *a3);
signed int __cdecl sub_80C01C8(_DWORD *a1, int a2);
int __cdecl sub_80C02D8(_DWORD *a1, int a2, int a3);
int __cdecl sub_80C0354(int, int, float, int, int, int, int, int); // idb
int __cdecl sub_80C03EA(int a1, int a2, int a3);
int __cdecl sub_80C040C(int a1, int a2);
signed int __cdecl sub_80C044E(int a1, int a2, int a3);
void __cdecl sub_80C04C6(int a1, int a2, float a3, int a4, int a5, int a6, int a7, int a8);
int __cdecl sub_80C05DA(_DWORD *a1, _DWORD *a2);
int __cdecl sub_80C063C(int a1, int a2);
int __cdecl sub_80C072E(_DWORD *a1, int a2);
int __cdecl sub_80C078E(int a1, int a2);
void __cdecl sub_80C0820(int a1, int a2, float a3, int a4);
void __cdecl sub_80C08C6(int a1, int a2, float a3, int a4);
void __cdecl sub_80C096C(int a1, int a2, float a3, int a4);
int __cdecl sub_80C0A1E(int, int, int, float, int, int); // idb
void __cdecl sub_80C0B94(int a1, int a2, float a3, int a4);
void __cdecl sub_80C0C3A(int a1, int a2, float a3, int a4);
void __cdecl sub_80C0CE0(int a1, int a2, float a3, int a4);
int __cdecl sub_80C0D92(int, int, int, float, int, int); // idb
long double __cdecl sub_80C0F08(float a1);
long double __cdecl sub_80C0F22(float a1);
int __cdecl sub_80C0F86(_DWORD *a1);
int __cdecl sub_80C0FA2(_DWORD *a1, _DWORD *a2);
int __cdecl sub_80C0FC2(int, float, int); // idb
int __cdecl sub_80C0FE8(int, float, int, int); // idb
long double __cdecl sub_80C101E(float *a1);
int __cdecl sub_80C1040(_DWORD *a1);
int __cdecl sub_80C106A(_DWORD *a1, _DWORD *a2);
int __cdecl sub_80C109A(float *a1, float *a2, float *a3);
int __cdecl sub_80C10DE(float *a1, float *a2, float *a3);
int __cdecl sub_80C1122(int, int, float, int); // idb
int __cdecl sub_80C118C(int, float, int); // idb
int __cdecl sub_80C11C4(int, float, int, int); // idb
int __cdecl sub_80C1218(_DWORD *a1);
int __cdecl sub_80C124E(int, float, int); // idb
int __cdecl sub_80C129A(int, float, int, int); // idb
long double __cdecl sub_80C130A(float *a1);
int __cdecl sub_80C1350(int, int, float, int); // idb
void __cdecl sub_80C13AA(int a1, float a2, int a3, int a4, float a5, int a6);
void __cdecl sub_80C1422(int a1, float a2, int a3, int a4, float a5, int a6);
int __cdecl sub_80C150E(int, float, int, int); // idb
int __cdecl sub_80C1544(int, float, int, int); // idb
int __cdecl sub_80C15B4(int, float, int); // idb
void __cdecl sub_80C1608(int a1, float a2, int a3, int a4, float a5, int a6);
int __cdecl sub_80C16B4(signed __int16 *a1, float *a2);
long double __cdecl sub_80C16D4(int a1, int a2, float a3);
long double __cdecl sub_80C1706(float a1, float a2, float a3);
signed int __cdecl sub_80C1718(const void **a1, signed __int16 *a2);
signed int __cdecl sub_80C17FA(const void **a1, signed __int16 *a2);
signed int __cdecl sub_80C1886(int a1, char **a2, unsigned __int16 *a3, int (__cdecl *a4)(int));
unsigned __int16 *__cdecl sub_80C19AE(int a1, int (__cdecl *a2)(int));
long double __cdecl sub_80C2C4E(float a1);
int __cdecl sub_80C2C6E(_DWORD *a1, _DWORD *a2);
int __cdecl sub_80C2C9E(const void **a1);
int __cdecl sub_80C2CD4(const void **a1);
long double __cdecl sub_80C2D0A(const void **a1);
int __cdecl sub_80C2D44(int a1);
int __cdecl sub_80C2D62(signed __int16 *a1);
int *__cdecl sub_80C2DB2(int a1);
void *sub_80C2E74();
void *sub_80C2EF2();
_DWORD *__cdecl sub_80C2F0E(int a1);
int __cdecl sub_80C306A(int (__cdecl *a1)(signed int));
int __cdecl sub_80C3090(char *s2); // idb
int __cdecl sub_80C30AC(char *src, int, int); // idb
int __cdecl sub_80C30D6(char *s2); // idb
int __cdecl sub_80C30F2(char *src, int, int); // idb
int __cdecl sub_80C311C(char *s2); // idb
int __cdecl sub_80C3138(char *src, int); // idb
int *__cdecl sub_80C3172(_DWORD *a1, const void *a2);
int __cdecl sub_80C3264(char *s2, int, int); // idb
int __cdecl sub_80C3314(int a1);
int __cdecl sub_80C3324(signed __int16 **a1, int a2);
int __cdecl sub_80C337C(int a1, _DWORD *a2, _DWORD *a3);
int __cdecl sub_80C33CA(int a1);
signed int __cdecl sub_80C33FE(int a1, int a2, int a3, float *a4, float *a5, int a6);
int __cdecl sub_80C3820(char *s1); // idb
int __cdecl sub_80C3888(float, float); // idb
int __cdecl sub_80C38AC(_DWORD *a1, _DWORD *a2);
int __cdecl sub_80C38DC(float *a1, float *a2, float *a3);
int __cdecl sub_80C3920(int, float, int, int); // idb
long double __cdecl sub_80C3974(float *a1, float *a2);
long double __cdecl sub_80C39A8(float a1, float a2, float a3);
int __cdecl sub_80C3A0A(float *a1, float *a2, float *a3);
int __cdecl sub_80C3AB4(float *a1, float *a2, float *a3);
signed int __cdecl sub_80C3B60(const void **a1, signed __int16 *a2);
void *__cdecl sub_80C3C42(signed __int16 *a1);
int __cdecl sub_80C3DE8(int a1, int a2, int (__cdecl *a3)(int));
signed int __cdecl sub_80C4280(int a1, const void **a2, int a3);
_DWORD *__cdecl sub_80C43F4(const void **a1, _DWORD *a2, int (__cdecl *a3)(int));
int __cdecl sub_80C468A(int, char *s2, int); // idb
int __cdecl sub_80C470E(int a1, int (__cdecl *a2)(int), int (__cdecl *a3)(int));
int sub_80C4E50();
int sub_80C4E5A();
int __cdecl sub_80C4E74(int, char *s2, int, int, int); // idb
signed int __cdecl sub_80C4F0E(int a1, int a2);
int __cdecl sub_80C4FAA(int a1, int (__cdecl *a2)(int), int (__cdecl *a3)(int));
signed int __cdecl sub_80C501A(int a1, float *a2, _DWORD *a3, _DWORD *a4);
long double __cdecl sub_80C51F0(float a1);
int __cdecl sub_80C5210(_DWORD *a1);
int __cdecl sub_80C523A(_DWORD *a1, int a2, int a3, int a4);
int __cdecl sub_80C525E(_DWORD *a1, _DWORD *a2);
int __cdecl sub_80C528E(float *a1, float *a2, float *a3);
int __cdecl sub_80C52D2(float *a1, float *a2, float *a3);
long double __cdecl sub_80C532E(float *a1);
int __cdecl sub_80C53E0(const void **a1);
int __cdecl sub_80C5414(int a1);
const char *__cdecl sub_80C5432(int a1, int a2, int a3);
int __cdecl sub_80C5482(int a1, _DWORD *a2, int a3, _DWORD *a4);
int __cdecl sub_80C54C2(int a1);
int __cdecl sub_80C54CE(signed __int16 **a1);
int __cdecl sub_80C54DC(_DWORD *a1);
long double __cdecl sub_80C5506(int a1);
int __cdecl sub_80C5556(int, float); // idb
int __cdecl sub_80C5628(unsigned int a1, unsigned __int8 *a2, unsigned int a3);
signed int __cdecl sub_80C5874(int a1, int *a2, int a3, int a4, signed int a5);
signed int __cdecl sub_80C5988(_DWORD *a1, signed int a2, _BYTE *a3, int a4);
signed int __cdecl sub_80C59D0(_DWORD *a1, signed int a2, int a3, int a4, signed int a5, signed int a6, _BYTE *a7, int a8);
signed int __cdecl sub_80C5ECE(_DWORD *a1);
int __cdecl sub_80C6104(int a1, __int16 a2);
size_t __cdecl sub_80C613D(int a1);
signed int __cdecl sub_80C620B(int a1, int a2);
signed int __cdecl sub_80C65F4(int a1);
unsigned int __cdecl sub_80C6A0C(int a1, void *dest, int a3);
int __cdecl sub_80C6AC0(int a1);
int __cdecl sub_80C6BCD(_DWORD *a1, unsigned int a2);
int __cdecl sub_80C6E57(int a1);
signed int __cdecl sub_80C70A8(int *a1, int a2);
int __cdecl sub_80C8044(int a1, int a2, _DWORD *a3);
_DWORD *__cdecl sub_80C8114(int a1, int a2, int a3);
int __cdecl sub_80C8256(int a1, int a2, int a3);
int __cdecl sub_80C969D(int a1, int a2);
int __cdecl sub_80C9712(int, void *src, size_t n); // idb
_BOOL4 __cdecl sub_80C9753(_DWORD *a1);
int __cdecl sub_80C9764(char a1, char a2, int a3, int a4, int a5);
int __cdecl sub_80C97C9(_DWORD *a1, int *a2, int a3);
int __cdecl sub_80CA538(int a1, int a2);
signed int __cdecl sub_80CA558(int a1, int a2, int a3, int a4, _DWORD *a5, int *a6);
signed int __cdecl sub_80CAC68(_DWORD *a1);
signed int __cdecl sub_80CACFD(_DWORD *a1);
signed int __cdecl sub_80CAD79(_DWORD *a1, int a2, _BYTE *a3, int a4);
signed int __cdecl sub_80CAF10(_DWORD *a1, _BYTE *a2, int a3);
signed int __cdecl sub_80CAF39(unsigned __int8 **a1, int a2);
signed int __cdecl sub_80CB75C(int *a1, unsigned int a2, unsigned int a3, int a4, int a5, _DWORD *a6, unsigned int *a7, int a8, _DWORD *a9, int *a10);
signed int __cdecl sub_80CBF7B(int *a1, unsigned int *a2, _DWORD *a3, int a4, int a5);
signed int __cdecl sub_80CC064(unsigned int a1, unsigned int a2, int *a3, unsigned int *a4, unsigned int *a5, _DWORD *a6, _DWORD *a7, int a8, int a9);
int __cdecl sub_80CC247(_DWORD *a1, _DWORD *a2, _DWORD *a3, _DWORD *a4);
int __cdecl sub_80CC278(int a1, _DWORD *a2, int a3);
void sub_80CC478();
int __cdecl sub_80CC47D(int a1);
int __cdecl sub_80CC515(int a1);
int __cdecl sub_80CC5D2(int a1, int a2, int a3);
int *__cdecl sub_80CC794(_DWORD *a1, int a2);
int __cdecl sub_80CCAD0(int a1, int a2, int a3);
int __cdecl sub_80CCB86(_DWORD *a1, int a2);
int __cdecl sub_80CCF25(_WORD *a1, int a2, int a3);
int __cdecl sub_80CD0B8(int a1, int a2, int a3);
signed int __cdecl sub_80CDA7E(int a1);
int __cdecl sub_80CDB3D(int a1, int a2, int a3, int a4);
int *__cdecl sub_80CDFE1(int a1, _BYTE *a2, int a3, int a4);
int __cdecl sub_80CE10F(int a1);
int __cdecl sub_80CE57D(int a1, _BYTE *a2, int a3, int a4);
int __cdecl sub_80CEA8B(int a1, int a2, int a3);
bool __cdecl sub_80CF236(int a1);
unsigned int __cdecl sub_80CF2D0(unsigned int a1, int a2);
int __cdecl sub_80CF2FE(int a1);
int __cdecl sub_80CF3C1(int a1);
int *__cdecl sub_80CF458(_DWORD *a1, _BYTE *a2, int a3, int a4);
int __cdecl sub_80CF610(FILE *stream, int); // idb
int __cdecl sub_80CF648(FILE *stream, int); // idb
signed int __cdecl sub_80CF67F(char *a1, char *a2);
int __cdecl sub_80CF724(char *s1, char *s2, int); // idb
int __cdecl sub_80CF76E(FILE *stream); // idb
_DWORD *__cdecl sub_80CF90C(char *filename, void *src);
void *__cdecl unzOpen(char *filename);
signed int __cdecl sub_80CFC62(int a1);
signed int __cdecl unzGetGlobalInfo(int a1, _DWORD *a2);
int __cdecl sub_80CFCED(int a1, int *a2);
int __cdecl sub_80CFD61(int, int, int, void *ptr, int, void *, int, void *, int); // idb
int __cdecl unzGetCurrentFileInfo(int, int, void *ptr, int, void *, int, void *, int); // idb
signed int __cdecl unzGoToFirstFile(_DWORD *a1);
signed int __cdecl unzGoToNextFile(_DWORD *a1);
signed int __cdecl sub_80D0417(int a1, _DWORD *a2);
signed int __cdecl unzSetCurrentFileInfoPosition(int a1, int a2);
signed int __cdecl sub_80D060A(int a1, _DWORD *a2, _DWORD *a3, int *a4);
signed int __cdecl unzOpenCurrentFile(_DWORD *a1);
signed int __cdecl sub_80D0AA8(int a1, int a2, unsigned int a3);
signed int __cdecl sub_80D0D98(int a1);
signed int __cdecl sub_80D0F1A(int a1);
void *__cdecl sub_80D1096(int a1, int a2, int a3);
void __cdecl sub_80D10AD(int a1, void *ptr);
void sub_80D1178();
ssize_t tty_FlushIn();
ssize_t sub_80D11A8();
int sub_80D120E();
int sub_80D1256();
int Sys_ConsoleInputShutdown();
unsigned int __cdecl sub_80D12EC(_DWORD *a1);
int sub_80D13C8();
int sub_80D140A();
void __cdecl __noreturn Sys_Exit(int status); // idb
void __noreturn Sys_Quit();
// char *__usercall Sys_Init@<eax>(long double a1@<st0>);
void __noreturn Sys_Error(char *format, ...);
int Sys_Warn(char *format, ...);
__time_t __cdecl sub_80D1658(char *filename);
void handler();
// void __usercall Sys_ConsoleInputInit(long double a1@<st0>);
char *Sys_ConsoleInput();
void __cdecl Sys_UnloadGame(void *handle);
void sub_80D1D86();
void __cdecl __noreturn sub_80D1DA6(int a1, int a2);
void __noreturn sub_80D1DDC();
void *__cdecl Sys_LoadDll(int a1, char *dest, int a3, int a4);
void sub_80D2168();
signed int __cdecl sub_80D216E(int a1, int a2, int a3, int a4);
int __cdecl sub_80D2194(int, int off, int); // idb
int __cdecl Sys_QueEvent(int a1, int a2, int a3, int a4, int a5, int a6);
_DWORD *__stdcall sub_80D2262(_DWORD *a1);
int __cdecl sub_80D24F4(char *s); // idb
void Sys_ConfigureFPU();
int __cdecl Sys_PrintBinVersion(int a1);
void __cdecl sub_80D25D2(char *file, int a2);
__pid_t __cdecl sub_80D266A(char *s);
// void __usercall Sys_StartProcess(long double a1@<st0>, char *src, int a3);
// void __usercall Sys_OpenURL(long double a1@<st0>, int a2, int a3);
void __cdecl Sys_ParseArgs(int a1, int a2);
// void __usercall __noreturn main(long double a1@<st0>, int a2, char **a3);
void __noreturn Sys_LoadRenderer();
void __noreturn Sys_UnloadRenderer();
int __cdecl sub_80D2B64(int, void *s); // idb
int __cdecl sub_80D2BE2(int a1, int a2);
char *__cdecl sub_80D2C0E(int a1, int a2);
int __cdecl sub_80D2C58(char *cp, void *s); // idb
int __cdecl sub_80D2CF0(char *cp, int); // idb
signed int __cdecl Sys_GetPacket(int *a1, int a2);
int __cdecl Sys_SendPacket(size_t n, void *buf, int, int, int, int, int); // idb
signed int __cdecl Sys_IsLANAddress(int a1, int a2);
int sub_80D30D2();
struct hostent *sub_80D313E();
// struct hostent *__usercall sub_80D330E@<eax>(long double a1@<st0>);
// struct hostent *__usercall NET_Init@<eax>(long double a1@<st0>);
int __cdecl sub_80D3438(char *cp, int a2);
int sub_80D360E();
char *sub_80D3636();
int __cdecl sub_80D3654(int a1);
int Sys_MilliSeconds();
int sub_80D37B0();
void __cdecl sub_80D3824(float *a1);
int __cdecl sub_80D3874(char *path); // idb
DIR *__cdecl sub_80D3890(int a1, _BYTE *a2, int a3, int a4, DIR *a5);
void *__cdecl Sys_ListFiles(char *name, char *s, int a3, int a4, int a5);
void __cdecl Sys_FreeFileList(void *ptr);
char *sub_80D3F0E();
char *__cdecl Sys_SetDefaultCDPath(char *src);
char *Sys_DefaultCDPath();
char *sub_80D3F64();
char *__cdecl sub_80D3F8A(char *src);
char *Sys_DefaultInstallPath();
char *__cdecl sub_80D3FD4(char *src);
char *Sys_DefaultHomePath();
void sub_80D40EA();
const char *sub_80D40F0();
_BYTE *__cdecl strlwr(_BYTE *a1);
int __cdecl sub_80D416A(char *s); // idb
int __cdecl sub_80D425A(char *s); // idb
int Sys_InitMainThread();
_BOOL4 Sys_IsMainThread();
int __cdecl Sys_SetValue(int a1, int a2);
int __cdecl Sys_GetValue(int a1);
// char *__usercall sub_80D4560@<eax>(long double a1@<st0>);
void SND_ShutdownChannels();
int __cdecl sub_80D45C4(int a1);
void __noreturn sub_80D4624(char *format, ...);
int __cdecl sub_80D46AC(char *src); // idb
int __cdecl sub_80D4832(char *a1);
signed int __cdecl sub_80D48C6(char *a1, int *a2, int a3);
char *__cdecl sub_80D4970(char *s, int a2, int a3, int a4);
int __cdecl sub_80D49D8(int a1, int a2);
int sub_80D4A08();
unsigned __int16 *__cdecl sub_80D4A32(unsigned int a1);
void *__cdecl sub_80D4ABE(int a1);
void *sub_80D4BC2();
void *__cdecl sub_80D4ED4(int a1, int a2, int a3, void *s);
signed int __cdecl sub_80D5250(char **a1, _DWORD *a2);
size_t __cdecl sub_80D5424(char **a1, _DWORD *a2, int a3);
_DWORD *__cdecl sub_80D5B94(int a1, int a2, int a3);
signed int __cdecl sub_80D688A(int a1, _DWORD *a2);
_DWORD *__cdecl sub_80D6944(int a1, _DWORD *a2);
signed int __cdecl sub_80D69B2(_DWORD *a1, int a2, signed int a3, int a4, int a5, int a6, int a7);
int __cdecl sub_80D6B7C(int, char *src, int, int, int, int); // idb
signed int __cdecl sub_80D6BC4(_DWORD *a1, signed __int16 *a2, int a3, int a4, int a5);
signed int __cdecl sub_80D6D82(_DWORD *a1, int a2, int a3, int a4);
signed int __cdecl sub_80D6EDC(_DWORD *a1, int a2, int a3);
signed int __cdecl sub_80D6FCA(_DWORD *a1, int a2, int a3, int a4);
int __cdecl sub_80D70AA(int a1, unsigned int a2);
int __cdecl sub_80D70E2(int a1, int a2, int a3, int a4);
unsigned int __cdecl sub_80D7180(int a1, int a2, int a3);
int __cdecl sub_80D72B8(int a1, unsigned int a2);
int __cdecl sub_80D72F8(float **a1);
_BOOL4 __cdecl sub_80D74DE(int a1, int a2);
_BOOL4 __cdecl sub_80D7534(int a1, int a2);
_BOOL4 __cdecl sub_80D7588(int a1, int a2);
void __cdecl sub_80D75DC(signed int *a1, signed int *a2, int a3, int a4);
unsigned int __cdecl sub_80D7D06(signed int *a1, unsigned int a2, int a3, int a4);
void __cdecl sub_80D8052(int a1, _DWORD *a2);
void __cdecl sub_80D80B8(float a1, float a2, float a3, float a4, int a5, int a6);
void __cdecl sub_80D82A4(int a1, int a2);
int __cdecl sub_80D8882(_DWORD *a1, int a2);
void *__cdecl sub_80D8C3E(int a1, int a2, int a3, int a4, void *s);
int *__cdecl sub_80D93D8(int a1, float a2, int a3);
void __cdecl sub_80D94B8(int a1, float a2, int a3);
signed int __cdecl sub_80D954C(int a1, int a2, int a3, int a4, signed int a5);
unsigned int __cdecl sub_80D9698(int a1, _DWORD *a2, signed int *a3);
int __cdecl sub_80D978C(int a1, _DWORD *a2, int a3, int a4);
int sub_80D99BE();
// _DWORD *__userpurge sub_80D9A8A@<eax>(_DWORD *a1, char *a2, int a3);
int sub_80D9ADE();
int sub_80D9B7E();
long double __cdecl sub_80D9C30(float a1);
long double __cdecl sub_80D9C4A(float a1);
void __cdecl sub_80D9CAE(float a1, int a2, int a3);
int __cdecl sub_80D9CDC(_DWORD *a1);
int __cdecl sub_80D9D06(_DWORD *a1, int a2, int a3, int a4);
int __cdecl sub_80D9D2A(_DWORD *a1, _DWORD *a2);
int __cdecl sub_80D9D5A(float *a1, float *a2, float *a3);
int __cdecl sub_80D9D9E(int, float, int, int); // idb
long double __cdecl sub_80D9DF2(float *a1);
double __cdecl sub_80D9E26(_DWORD); // weak
long double __cdecl sub_80D9E64(float a1);
int __cdecl sub_80D9E84(int a1, int a2);
int __cdecl sub_80D9EAA(int a1, int a2);
// char *__usercall sub_80D9EE8@<eax>(long double a1@<st0>);
int __cdecl sub_80D9FF4(int a1);
signed int __cdecl sub_80DA016(int a1, int a2, float *a3);
_BOOL4 __cdecl sub_80DA0A4(int a1);
int __cdecl sub_80DA0CA(int a1);
int __cdecl sub_80DA0F4(int a1);
long double __cdecl sub_80DA1A6(int a1);
long double __cdecl sub_80DA1F8(int a1);
void __cdecl sub_80DA238(int a1, int a2);
long double __cdecl sub_80DA2CA(int a1);
void __cdecl sub_80DA31C(int a1, int a2, float a3);
unsigned int __cdecl sub_80DA424(int a1, int *a2);
int __cdecl sub_80DA52E(int a1, int a2);
signed int __cdecl sub_80DA584(int a1, int *a2);
long double __cdecl sub_80DA70C(float a1);
int __cdecl sub_80DA72C(int, float, int); // idb
int __cdecl sub_80DA752(_DWORD *a1, int a2, int a3, int a4);
int __cdecl sub_80DA776(_DWORD *a1, _DWORD *a2);
int __cdecl sub_80DA7A6(int, float, int); // idb
int __cdecl sub_80DA7DE(int, float, int, int); // idb
long double __cdecl sub_80DA832(float *a1, float *a2);
// char *__usercall sub_80DA868@<eax>(long double a1@<st0>);
void *__cdecl sub_80DA9B8(size_t n);
void __cdecl sub_80DA9D4(int a1);
signed int __cdecl sub_80DA9FC(int a1);
signed int __cdecl sub_80DAA36(int a1);
int __cdecl sub_80DAA8E(int a1);
int __cdecl sub_80DAAF2(int a1, signed int a2, float *a3);
int __cdecl sub_80DAC38(float, float); // idb
int __cdecl sub_80DACB8(int **a1, int a2);
int __cdecl sub_80DAE2E(int a1, int a2, int a3);
int __cdecl sub_80DAF36(int, int, int, float); // idb
void __cdecl sub_80DB380(int a1);
void sub_80DB6CA();
signed int __cdecl sub_80DB6DA(int a1, _DWORD *a2, float *a3, unsigned int *a4);
void __cdecl sub_80DB964(int *a1, _DWORD *a2);
int __cdecl sub_80DBB3C(int a1, int a2, int a3);
// void __usercall sub_80DBD56(long double a1@<st0>, int a2);
int __cdecl sub_80DBE96(int a1);
_BOOL4 __cdecl sub_80DBEB0(int a1);
long double __cdecl sub_80DBF16(float a1);
int __cdecl sub_80DBF30(_DWORD *a1, int a2, int a3, int a4);
int __cdecl sub_80DBF54(_DWORD *a1, _DWORD *a2);
unsigned int __cdecl sub_80DBF84(_DWORD *a1, unsigned int *a2);
int __cdecl sub_80DBFC2(float *a1, float *a2, float *a3);
int __cdecl sub_80DC006(float *a1, float *a2, float *a3);
int __cdecl sub_80DC04A(int, float, int); // idb
int __cdecl sub_80DC082(int, float, int, int); // idb
long double __cdecl sub_80DC0D6(float *a1, float *a2);
// char *__usercall sub_80DC10C@<eax>(long double a1@<st0>);
int __cdecl sub_80DCAE6(int a1);
char *__cdecl sub_80DCB02(char *s1);
_BOOL4 __cdecl sub_80DCBB6(float *a1, int a2, int a3);
_BOOL4 __cdecl sub_80DCC7A(_DWORD *a1, _DWORD *a2, int a3);
int __cdecl sub_80DCEB0(int a1, int a2, int a3);
int __cdecl sub_80DD224(_DWORD *a1, int a2, int a3);
int __cdecl sub_80DD452(_DWORD *a1, int a2, _DWORD *a3);
int __cdecl sub_80DD554(int a1, unsigned __int8 a2, int a3);
int __cdecl sub_80DD59E(int a1, int a2, int a3, unsigned __int8 a4);
int __cdecl sub_80DDAD0(int, int, int, int, float, int, int, int, int, int, int, int, int, float); // idb
int __cdecl sub_80DE734(int, int, int, int, float, int, int, int, int, int, int, int, int, float); // idb
int __cdecl sub_80DE918(_DWORD *a1);
int __cdecl sub_80DE942(_DWORD *a1, int a2, int a3, int a4);
int __cdecl sub_80DE966(_DWORD *a1, _DWORD *a2);
unsigned int __cdecl sub_80DE996(_DWORD *a1, unsigned int *a2);
int __cdecl sub_80DE9D4(float *a1, float *a2, float *a3);
int __cdecl sub_80DEA18(float *a1, float *a2, float *a3);
int __cdecl sub_80DEA5C(int, float, int); // idb
int __cdecl sub_80DEA94(int, float, int, int); // idb
long double __cdecl sub_80DEAE8(float *a1, float *a2);
double __cdecl sub_80DEB1C(_DWORD); // weak
long double __cdecl sub_80DEB5A(float a1);
int __cdecl sub_80DEB7A(int, int, float, int); // idb
int __cdecl sub_80DEBE4(int a1, void *a2, int a3, int a4, int a5, int a6, int a7, int a8);
int __cdecl sub_80DEC3C(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8);
int __cdecl sub_80DED2E(int a1, int a2);
int __cdecl sub_80DED50(int a1, int a2);
int __cdecl sub_80DEDB0(float *a1, float *a2, int a3);
signed int __cdecl sub_80DEE0E(int a1);
int __cdecl sub_80DEE4A(int a1, int a2);
int __cdecl sub_80DEFE8(int, float, int); // idb
long double __cdecl sub_80DF0DA(int a1, float a2, int a3);
void __cdecl sub_80DF16A(int a1, int a2, int a3, float a4, float a5);
long double __cdecl sub_80DF2DE(int a1, float a2, float a3, float a4);
long double __cdecl sub_80DF3FA(int a1, int a2);
long double __cdecl sub_80DF534(int *a1, int a2);
long double __cdecl sub_80DF7FC(signed int a1);
// int __usercall sub_80DF868@<eax>(long double a1@<st0>, int a2, int a3);
int __cdecl sub_80DFAFC(int a1);
void __cdecl sub_80DFB3A(int a1, int a2);
int __cdecl sub_80DFCD4(int a1, int a2);
int __cdecl sub_80DFE82(int *a1, int a2);
int __cdecl sub_80E02FE(int a1, int a2);
int __cdecl sub_80E037E(int a1, int a2);
int __cdecl sub_80E05C8(int a1, int a2);
int __cdecl sub_80E088C(int a1, int a2);
int __cdecl sub_80E0906(int a1);
int __cdecl sub_80E0938(int a1);
int __cdecl sub_80E0968(int a1);
int __cdecl sub_80E0984(int a1);
void __cdecl sub_80E09A0(int a1, int a2);
signed int __cdecl sub_80E0DA2(int *a1, _DWORD *a2, int a3);
_DWORD *__cdecl sub_80E0F86(int a1, _DWORD *a2);
_DWORD *__cdecl sub_80E117E(int *a1, _DWORD *a2);
signed int __cdecl sub_80E1522(int a1, int a2, int a3);
long double __cdecl sub_80E1562(int a1, int a2, float *a3);
long double __cdecl sub_80E168A(_DWORD *a1, int a2, int a3);
void __cdecl sub_80E178C(int *a1, int a2);
void __cdecl sub_80E1F20(int a1, int a2);
char __cdecl sub_80E2CDE(int a1, int a2, char a3, char a4, int a5);
_BOOL4 __cdecl sub_80E2EA6(int *a1);
int __cdecl sub_80E2F4E(float); // idb
void __cdecl sub_80E3008(int a1, int a2);
int __cdecl sub_80E4060(int a1);
_DWORD *__cdecl sub_80E4212(_DWORD *a1, int a2);
void __cdecl sub_80E42D0(int a1, float a2, int a3, int a4);
// int __usercall sub_80E4688@<eax>(long double a1@<st0>, int a2, float a3, int a4);
void __cdecl sub_80E4794(int a1, float a2, int a3, int a4);
// void __usercall sub_80E54DC(long double a1@<st0>, unsigned __int8 *a2, int a3);
int __cdecl sub_80E5820(int a1);
int __cdecl sub_80E5844(_DWORD *a1);
int __cdecl sub_80E58EE(int a1);
int __cdecl sub_80E5902(int a1);
int __cdecl sub_80E5936(int a1, int *a2);
int __cdecl sub_80E5D4A(int a1, int a2);
void __cdecl sub_80E6200(int a1);
int __cdecl sub_80E6D30(_DWORD *a1);
long double __cdecl sub_80E6DF4(int a1, int a2);
long double __cdecl sub_80E6E42(float a1);
long double __cdecl sub_80E6E5C(float a1);
int __cdecl sub_80E6E7C(float, float); // idb
int __cdecl sub_80E6EA0(float, float); // idb
int __cdecl sub_80E6EC4(int a1, int a2, int a3);
long double __cdecl sub_80E6F06(float a1);
unsigned int __cdecl sub_80E6F12(unsigned int a1);
int __cdecl sub_80E6F38(_DWORD *a1, _DWORD *a2);
int __cdecl sub_80E6F58(float *a1, float *a2, float *a3);
int __cdecl sub_80E6F84(float *a1, float *a2, float *a3);
int __cdecl sub_80E6FB0(int, float, int); // idb
int __cdecl sub_80E6FD6(int, float, int, int); // idb
long double __cdecl sub_80E700C(float *a1, float *a2);
long double __cdecl sub_80E702E(float *a1);
double __cdecl sub_80E7050(_DWORD); // weak
int __cdecl sub_80E707C(_DWORD *a1);
int __cdecl sub_80E70A6(_DWORD *a1, int a2, int a3, int a4);
int __cdecl sub_80E70CA(_DWORD *a1, _DWORD *a2);
unsigned int __cdecl sub_80E70FA(_DWORD *a1, unsigned int *a2);
int __cdecl sub_80E7138(float *a1, float *a2, float *a3);
int __cdecl sub_80E717C(float *a1, float *a2, float *a3);
int __cdecl sub_80E71C0(int, float, int); // idb
int __cdecl sub_80E71F8(int, float, int, int); // idb
long double __cdecl sub_80E724C(float *a1, float *a2);
long double __cdecl sub_80E7280(float *a1);
double __cdecl sub_80E72B4(_DWORD); // weak
long double __cdecl sub_80E72F2(float a1, float a2, float a3);
int __cdecl sub_80E731C(int a1, int a2, int a3);
unsigned int __cdecl sub_80E733C(unsigned int a1);
signed int __cdecl sub_80E7348(unsigned __int8 *a1, _DWORD *a2, _DWORD *a3);
long double __cdecl sub_80E7448(float *a1, int a2, int a3, _DWORD *a4);
_BOOL4 __cdecl sub_80E750E(int *a1, int a2, int a3);
void __cdecl sub_80E7CC0(int *a1, int a2, int a3);
long double __cdecl sub_80E86BE(float a1);
int __cdecl sub_80E86D8(float); // idb
int __cdecl sub_80E870E(float *a1, float *a2, float *a3);
long double __cdecl sub_80E873A(float *a1, float *a2);
int __cdecl sub_80E875C(_DWORD *a1);
int __cdecl sub_80E8786(_DWORD *a1, int a2, int a3, int a4);
int __cdecl sub_80E87AA(_DWORD *a1, _DWORD *a2);
int __cdecl sub_80E87DA(float *a1, float *a2, float *a3);
int __cdecl sub_80E881E(int, float, int); // idb
int __cdecl sub_80E8856(int, float, int, int); // idb
long double __cdecl sub_80E88AA(float *a1, float *a2);
void sub_80E88E0();
int __cdecl sub_80E88F0(int a1);
int __cdecl sub_80E89A8(int a1);
int __cdecl sub_80E8B16(int a1);
_BYTE *__cdecl sub_80E8C8C(int a1);
int __cdecl sub_80E8E44(int a1);
_BYTE *__cdecl sub_80E8FBA(int a1, int a2);
int sub_80E90C8();
int __cdecl sub_80E9154(int a1);
int __cdecl sub_80E9188(int a1, void (__cdecl *a2)(int));
int sub_80E91DC();
int __cdecl sub_80E9210(int a1, int a2);
unsigned int __cdecl sub_80E9240(int a1, int a2);
int __cdecl sub_80E9270(int a1);
int *__cdecl sub_80E9280(int a1);
int sub_80E9322();
int __cdecl sub_80E9336(int a1);
int __cdecl sub_80E9356(int a1);
int __cdecl sub_80E936C(int a1);
int __cdecl sub_80E93C4(char *a1);
int __cdecl sub_80E9430(char *a1);
signed int __cdecl sub_80E949C(char *a1);
int __cdecl sub_80E94F0(char *s1, int); // idb
int __cdecl sub_80E958C(char *s1); // idb
int sub_80E95A8();
int __cdecl sub_80E95EE(_DWORD *a1);
int __cdecl sub_80E963A(int a1, int a2);
int __cdecl sub_80E973E(int a1);
signed int __cdecl sub_80E9758(int a1);
signed int __cdecl sub_80E9782(int a1);
signed int __cdecl sub_80E97BE(int a1);
int __cdecl sub_80E97F0(int a1, int a2);
_BOOL4 __cdecl sub_80E9882(int a1);
signed int __cdecl sub_80E98CA(int a1, int a2);
signed int __cdecl sub_80E9A9E(int a1, int a2, int a3);
signed int __cdecl sub_80E9B54(int a1, int a2, int a3);
signed int __cdecl sub_80E9C10(int a1, int a2);
signed int __cdecl sub_80E9C6A(int a1, int a2, int a3);
int __cdecl sub_80E9DE0(int a1, int a2);
int __cdecl sub_80E9FD2(int a1, int a2);
float *__cdecl sub_80EA198(int a1, int a2, float *a3, float *a4);
signed int __cdecl sub_80EA28E(int a1);
_BOOL4 __cdecl sub_80EA2B6(_DWORD *a1, int a2);
signed int __cdecl sub_80EA3DA(int a1);
int __cdecl sub_80EA40E(int a1, int a2);
unsigned int __cdecl sub_80EA53E(int a1);
void __cdecl sub_80EA568(float **a1, int a2);
int __cdecl sub_80EA838(int a1);
int __cdecl sub_80EA850(int a1);
void __cdecl sub_80EA868(int a1);
void __cdecl sub_80EA950(float **a1, int a2);
signed int __cdecl sub_80EABAA(_DWORD *a1);
int __cdecl sub_80EAC7A(int a1);
int __cdecl sub_80EAC94(int a1);
int __cdecl sub_80EACAE(int a1);
int __cdecl sub_80EACC8(int a1, int a2);
int __cdecl sub_80EAD0C(int a1);
int __cdecl sub_80EAE8C(int a1, int a2, int a3);
int __cdecl sub_80EAEC8(int a1);
_BOOL4 __cdecl sub_80EAEF2(int a1);
int __cdecl sub_80EAF30(int a1);
signed int __cdecl sub_80EAF58(int a1, int a2);
int __cdecl sub_80EB180(_DWORD *a1);
int __cdecl sub_80EB2E8(_DWORD *a1);
int __cdecl sub_80EB3D0(_DWORD *a1);
int __cdecl sub_80EB4FC(_DWORD *a1, int a2);
int __cdecl sub_80EB738(unsigned __int8 *a1);
int __cdecl sub_80EBA76(int a1);
signed int __cdecl sub_80EBA9E(int a1);
int __cdecl sub_80EBBA8(_DWORD *a1);
int __cdecl sub_80EBD80(_DWORD *a1, int a2);
int __cdecl sub_80EBE96(_DWORD *a1, int a2);
int __cdecl sub_80EBFC8(int a1);
char __cdecl sub_80EBFF0(int a1);
int __cdecl sub_80EC22A(int a1);
void __cdecl sub_80EC2BA(_BYTE *a1, int a2);
signed int __cdecl sub_80EC560(_BYTE *a1, int a2);
int __cdecl sub_80EC7D2(unsigned __int8 *a1);
signed int __cdecl sub_80ECA14(_BYTE *a1, int a2);
int __cdecl sub_80ECA78(int a1, int a2);
signed int sub_80ECC42();
signed int __cdecl sub_80ECC4C(_DWORD *a1);
int __cdecl sub_80ECD62(int a1);
void __cdecl sub_80ECDD6(int a1);
signed int __cdecl sub_80ECE56(_DWORD *a1, int a2);
int __cdecl sub_80ECF70(_DWORD *a1);
int __cdecl sub_80ECFF2(int a1);
int __cdecl sub_80ED01A(int *a1, int a2);
int __cdecl sub_80ED212(_DWORD *a1);
int __cdecl sub_80ED282(_DWORD *a1);
int __cdecl sub_80ED2F2(_DWORD *a1);
int __cdecl sub_80ED382(_DWORD *a1);
int __cdecl sub_80ED3DE(int *a1);
unsigned int __cdecl sub_80ED50A(_DWORD *a1);
int __cdecl sub_80ED592(int a1);
int __cdecl sub_80ED5AE(int *a1);
signed int __cdecl sub_80ED780(_DWORD *a1, int a2);
int __cdecl sub_80ED84E(int a1);
int __cdecl sub_80ED87A(int a1);
int __cdecl sub_80ED8A6(int a1);
_DWORD *__cdecl sub_80ED8D2(_DWORD *a1);
int __cdecl sub_80ED928(_DWORD *a1);
int __cdecl sub_80ED97E(_DWORD *a1);
_DWORD *__cdecl sub_80ED9E0(_DWORD *a1);
int __cdecl sub_80EDA06(_DWORD *a1);
int __cdecl sub_80EDA78(int a1);
_DWORD *__cdecl sub_80EDB00(int a1);
float *__cdecl sub_80EDF3A(int a1, int a2);
int __cdecl sub_80EE212(_DWORD *a1);
int __cdecl sub_80EE226(int a1, float *a2, int a3);
long double __cdecl sub_80EE4AA(int a1);
long double __cdecl sub_80EE506(int a1, float a2, float a3, float a4);
long double __cdecl sub_80EE5C6(int a1, float a2, float a3, float a4);
void __cdecl sub_80EE640(_DWORD **a1, float *a2);
void __cdecl sub_80EEA0C(float **a1, float *a2);
float *__cdecl sub_80EEA7C(float **a1, float *a2);
int __cdecl sub_80EED76(float **a1, float *a2);
void __cdecl sub_80EEF38(float **a1, float *a2);
int __cdecl sub_80EF12E(int, int, float, float, float, float, float, float); // idb
int __cdecl sub_80EF336(_DWORD **a1, float *a2);
int __cdecl sub_80EF52C(int a1, int a2);
void __cdecl sub_80EF61E(float **a1, float *a2);
int __cdecl sub_80EF7AA(float **a1, float *a2);
int __cdecl sub_80EFA86(float **a1, float *a2);
void __cdecl sub_80EFC4A(_DWORD **a1, float *a2);
void __cdecl sub_80EFD94(float **a1, float *a2);
int __cdecl sub_80EFDF0(int, int, int, int, float, int); // idb
int __cdecl sub_80F0110(int a1, char *s);
long double __cdecl sub_80F0198(float a1);
int __cdecl sub_80F01B2(float, float); // idb
int __cdecl sub_80F01D6(float, float); // idb
int __cdecl sub_80F01FA(int a1, int a2);
long double __cdecl sub_80F0220(float a1, float a2, float a3);
long double __cdecl sub_80F025E(float a1);
long double __cdecl sub_80F026A(float *a1);
int __cdecl sub_80F028C(_DWORD *a1);
int __cdecl sub_80F02B6(_DWORD *a1, _DWORD *a2);
int __cdecl sub_80F02E6(float *a1, float *a2, float *a3);
int __cdecl sub_80F032A(int, float, int); // idb
int __cdecl sub_80F0362(int, float, int, int); // idb
long double __cdecl sub_80F03B6(float a1, float a2, float a3);
int __cdecl sub_80F03E0(int a1, int a2, int a3);
int __cdecl sub_80F0400(int a1, int a2);
int __cdecl sub_80F0450(char *s1); // idb
char *__cdecl sub_80F049E(int a1);
int sub_80F04AE();
_DWORD *sub_80F04EA();
int __cdecl sub_80F065E(char *s1, int, int); // idb
int __cdecl sub_80F06B4(int a1, char *s1, int a3);
signed int __cdecl sub_80F09D6(signed int *a1);
void __cdecl sub_80F0A52(int a1);
void __cdecl sub_80F0AA6(int a1);
char *__cdecl sub_80F0B8E(int a1, char *s);
char *__cdecl sub_80F0BE2(int a1, char *s);
char ***__cdecl sub_80F0BFC(char ***a1);
int __cdecl sub_80F0C4E(int a1, char *a2);
char ***sub_80F0F9E();
// int __usercall sub_80F0FEC@<eax>(long double a1@<st0>, int a2, int a3, int a4, int a5, float a6, int a7);
// int __usercall sub_80F10F4@<eax>(long double a1@<st0>, int a2, int a3, int a4, int a5, int a6, int a7, int a8, int a9);
void __cdecl sub_80F15AA(void *s, int a2, int a3, int a4, int a5, int a6, int a7);
int __cdecl sub_80F166C(float *a1, int a2, int a3);
int __cdecl sub_80F172C(float, float); // idb
int __cdecl sub_80F1750(float, float); // idb
int __cdecl sub_80F1774(_DWORD *a1);
int __cdecl sub_80F179E(_DWORD *a1, _DWORD *a2);
long double __cdecl sub_80F17CE(float a1, float a2, float a3);
void *__cdecl sub_80F17F8(char *s, int a2);
signed int __cdecl sub_80F187E(int a1);
int __cdecl sub_80F1A0A(int, char *s1, int, int); // idb
int __cdecl sub_80F1A74(char *s); // idb
char *__cdecl sub_80F1B86(float *a1);
int __cdecl sub_80F1C24(char, char *src, int, int); // idb
signed int __cdecl sub_80F1D3A(int a1, int a2, _BYTE *a3, int a4, int *a5);
signed int __cdecl sub_80F1F7E(int a1);
int __cdecl sub_80F20C8(int a1);
int __cdecl sub_80F2350(int a1);
int __cdecl sub_80F2362(int a1, int a2);
int __cdecl sub_80F24C6(int a1);
int __cdecl sub_80F275E(int a1, int *a2);
// signed int __usercall sub_80F29CA@<eax>(long double a1@<st0>, int a2);
int __cdecl sub_80F2B22(int a1);
int __cdecl sub_80F2B86(int *a1, int a2);
int __cdecl sub_80F2EC0(int a1, int a2);
int __cdecl sub_80F2F2E(int a1);
void __cdecl sub_80F2FA4(int a1, int a2, int a3, int a4);
int __cdecl sub_80F34E0(_DWORD *a1, int a2, int a3);
// int __usercall sub_80F35DA@<eax>(long double a1@<st0>, int *a2, int *a3);
// int __usercall sub_80F3EA4@<eax>(long double a1@<st0>, int a2);
// int __usercall sub_80F3F74@<eax>(long double a1@<st0>, int *a2);
int __cdecl sub_80F40C4(int a1);
int __cdecl sub_80F41C2(int a1);
int __cdecl sub_80F467C(int a1, char a2);
signed int __cdecl sub_80F4696(int a1, _DWORD *a2);
signed int __cdecl sub_80F474A(int a1);
signed int __cdecl sub_80F4B46(int *a1, int a2);
signed int __cdecl sub_80F4BA4(int a1);
// int __usercall sub_80F4DBE@<eax>(long double a1@<st0>, int a2);
int __cdecl sub_80F53E0(int a1, signed int a2);
int __cdecl sub_80F543C(float *a1, float *a2, float *a3);
int __cdecl sub_80F5468(int, float, int); // idb
long double __cdecl sub_80F548E(float *a1);
double __cdecl sub_80F54B0(_DWORD); // weak
int __cdecl sub_80F54DC(_DWORD *a1);
int __cdecl sub_80F5506(_DWORD *a1, int a2, int a3, int a4);
int __cdecl sub_80F552A(_DWORD *a1, _DWORD *a2);
int __cdecl sub_80F555A(float *a1, float *a2, float *a3);
int __cdecl sub_80F559E(float *a1, float *a2, float *a3);
long double __cdecl sub_80F55E2(float *a1, float *a2);
long double __cdecl sub_80F5616(float a1);
void __cdecl sub_80F5638(int a1, _DWORD *a2);
void __cdecl sub_80F565E(int a1);
int __cdecl sub_80F572C(int a1);
void __cdecl sub_80F57A4(int a1);
int __cdecl sub_80F5868(int a1);
int __cdecl sub_80F58E0(_DWORD *a1);
void __cdecl sub_80F598C(int a1);
int __cdecl sub_80F59B4(int a1);
int __cdecl sub_80F59F2(int a1);
int __cdecl sub_80F5A22(int a1);
int __cdecl sub_80F5A7C(int a1);
int __cdecl sub_80F5AD2(int a1);
void __cdecl sub_80F5B5E(int a1);
int __cdecl sub_80F5C30(int a1);
__int16 __cdecl sub_80F5CC8(int a1);
int __cdecl sub_80F5D08(int a1);
int __cdecl sub_80F5D2A(int a1);
int __cdecl sub_80F5D4C(int a1);
void **sub_80F5D66();
int __cdecl sub_80F5DBC(int a1, int a2);
int __cdecl sub_80F5E1E(int a1, int a2);
// int __usercall sub_80F5E80@<eax>(long double a1@<st0>, int a2, _DWORD *a3);
void __cdecl sub_80F61BE(int a1, float *a2);
void __cdecl sub_80F63A0(int a1, int a2, float *a3, float *a4);
char *__cdecl sub_80F63D4(char *a1, char *a2, int a3);
int __cdecl sub_80F6506(int a1);
// const char *__usercall sub_80F6722@<eax>(long double a1@<st0>, int a2, __int16 a3);
int __cdecl sub_80F6954(int a1);
// int __usercall sub_80F69B4@<eax>(long double a1@<st0>, int a2, _DWORD *a3, _DWORD *a4);
// void __usercall sub_80F6D74(long double a1@<st0>, int a2);
int __cdecl sub_80F6ED0(int a1, float *a2, int a3);
int *__cdecl sub_80F721C(int *a1, int a2);
int __cdecl sub_80F736E(float *a1, float *a2, float *a3);
int __cdecl sub_80F739A(_DWORD *a1, _DWORD *a2);
int __cdecl sub_80F73CA(int, float, int, int); // idb
int __cdecl sub_80F7420(int a1);
signed int __cdecl sub_80F761E(int a1);
int __cdecl sub_80F76F8(int a1);
_BOOL4 __cdecl sub_80F77E2(int a1);
int __cdecl sub_80F77FE(int a1);
int __cdecl sub_80F78C4(int a1);
int __cdecl sub_80F798A(int a1);
int __cdecl sub_80F7A4A(int a1);
int __cdecl sub_80F7B40(int a1);
int __cdecl sub_80F7C36(int a1);
int __cdecl sub_80F7D32(int a1);
int __cdecl sub_80F7E38(int a1);
int __cdecl sub_80F7F72(int a1);
int __cdecl sub_80F80CC(int a1);
// int __usercall sub_80F81F8@<eax>(long double a1@<st0>, int a2);
_DWORD *__cdecl sub_80F8280(int a1);
int __cdecl sub_80F82F8(int a1);
int __cdecl sub_80F839A(int a1);
int __cdecl sub_80F843C(int a1);
int __cdecl sub_80F84DE(int a1);
int __cdecl sub_80F8558(int a1);
int __cdecl sub_80F85E6(int a1);
int __cdecl sub_80F8684(int a1);
int __cdecl sub_80F8738(int a1);
int __cdecl sub_80F87C0(int a1);
int __cdecl sub_80F882E(int a1);
int __cdecl sub_80F88EE(int a1);
int __cdecl sub_80F8A04(int a1);
int __cdecl sub_80F9448(int a1);
int __cdecl sub_80F9528(int a1);
int __cdecl sub_80F9600(int a1);
int __cdecl sub_80F96D8(int a1);
int __cdecl sub_80F9766(int a1);
int __cdecl sub_80F97F4(int a1);
signed int __cdecl sub_80F991C(int a1);
int __cdecl sub_80F9C02(int a1);
int __cdecl sub_80F9D6C(int a1);
int __cdecl sub_80F9F20(int a1);
int __cdecl sub_80FA064(int a1);
int __cdecl sub_80FA1B2(int a1);
int __cdecl sub_80FA2AC(int a1);
int __cdecl sub_80FA332(int a1);
// int __usercall sub_80FA3B8@<eax>(long double a1@<st0>, int a2);
int __cdecl sub_80FA45A(int a1);
// int __usercall sub_80FA50A@<eax>(long double a1@<st0>, int a2);
void __cdecl sub_80FA820(int a1);
int __cdecl sub_80FA9EE(int a1);
int __cdecl sub_80FAA98(int a1);
int __cdecl sub_80FAB1A(int a1);
unsigned int __cdecl sub_80FAB9A(int a1);
void __cdecl sub_80FAC1A(int a1);
void __cdecl sub_80FADAC(int a1);
void __cdecl sub_80FAED6(int a1);
void __cdecl sub_80FB054(int a1);
int __cdecl sub_80FB194(int a1);
int __cdecl sub_80FB224(int a1);
void __cdecl sub_80FB2D4(int a1);
void __cdecl sub_80FB3A4(int a1);
int __cdecl sub_80FB474(int a1);
int __cdecl sub_80FB5B4(int a1);
int (__cdecl *__cdecl sub_80FB640(char **a1))(__int16);
int __cdecl sub_80FB6C4(_DWORD *a1);
int __cdecl sub_80FB6EE(_DWORD *a1, _DWORD *a2);
int __cdecl sub_80FB71E(float *a1, float *a2, float *a3);
int __cdecl sub_80FB762(int, float, int); // idb
int __cdecl sub_80FB79C(int a1);
int __cdecl sub_80FB982(int a1);
signed int __cdecl sub_80FB996(int a1);
void *__cdecl sub_80FBA44(int a1);
_BYTE *__cdecl sub_80FBB0A(_BYTE *a1, _BYTE *a2);
int __cdecl sub_80FBB62(int, char *nptr); // idb
void __cdecl sub_80FBD50(char *s);
void sub_80FBE00();
// char *__usercall sub_80FBE1C@<eax>(long double a1@<st0>, int *a2);
char *__cdecl sub_80FC25E(int a1);
signed int __cdecl sub_80FC74E(int a1);
signed int __cdecl sub_80FC7E2(int a1);
signed int __cdecl sub_80FC876(int a1);
signed int __cdecl sub_80FC904(int a1);
signed int __cdecl sub_80FC9A8(int a1);
int __cdecl sub_80FCA4C(int *a1);
_DWORD *__cdecl sub_80FCAE6(char *a1);
signed int __cdecl sub_80FCD40(int a1, int a2);
_BOOL4 __cdecl sub_80FCEA8(int a1);
void __cdecl sub_80FCEC4(int a1, int a2, int a3, int a4, int a5, int a6);
void __cdecl sub_80FCFC8(int a1, int a2, int a3, char *src);
void __cdecl sub_80FD38E(int a1, int a2, int a3);
void __cdecl sub_80FD3F0(int *a1);
void __cdecl sub_80FD5B6(int a1);
int __cdecl sub_80FD692(int a1);
// signed int __usercall sub_80FD6E8@<eax>(long double a1@<st0>, int a2);
int __cdecl sub_80FE496(int a1);
int __cdecl sub_80FE6BE(int a1);
void sub_80FE822();
int __cdecl sub_80FE84C(int *a1);
int sub_80FE98A();
// void __usercall sub_80FE998(long double a1@<st0>, int a2);
int __cdecl sub_80FEDEE(_DWORD *a1);
int __cdecl sub_80FEE18(_DWORD *a1, int a2, int a3, int a4);
int __cdecl sub_80FEE3C(_DWORD *a1, _DWORD *a2);
int __cdecl sub_80FEE6C(int, float, int, int); // idb
char *__cdecl sub_80FEEC0(char *dest, char *src);
_BOOL4 sub_80FEEDA();
__int16 __cdecl sub_80FF17A(int a1, int a2, int a3);
signed int __cdecl sub_80FF26A(char *a1);
int __cdecl sub_80FF2CA(int a1, int *a2, int *a3, int a4, unsigned int a5, int a6, _DWORD *a7, int a8, int a9);
long double __cdecl sub_80FF652(int a1, int a2);
__int16 __cdecl sub_80FF6B0(int a1, int *a2, int *a3, _DWORD *a4, _DWORD *a5, signed int a6, int a7, unsigned int a8, int a9, int a10);
__int16 __cdecl sub_80FF7C8(int *a1, int *a2, int *a3, float *a4, _DWORD *a5, signed int a6, int a7, unsigned int a8, int a9, int a10);
long double __cdecl sub_80FFA56(int a1, float *a2);
int __cdecl sub_80FFE10(int, int, int, float, float, float, int, int); // idb
int __cdecl sub_81003E6(int a1);
signed int __cdecl sub_81003F6(__int16 a1);
int __cdecl sub_810043E(_DWORD *a1, _DWORD *a2);
int __cdecl sub_810046E(float *a1, float *a2, float *a3);
int __cdecl sub_81004B2(float *a1, float *a2, float *a3);
int __cdecl sub_81004F6(int, float, int); // idb
int __cdecl sub_810052E(int, float, int, int); // idb
double __cdecl sub_8100582(_DWORD); // weak
long double __cdecl sub_81005C0(float a1);
void sub_81005E0();
void __cdecl sub_81005E6(int a1, int a2, int a3, float a4);
int *__cdecl sub_81007DE(int a1, float a2, int a3, int a4, int a5);
int *__cdecl sub_8100884(int a1, float a2, int a3);
void __cdecl sub_8100A5A(int a1, float a2, float a3, float a4);
void __cdecl sub_8100C02(float a1, int a2, int a3);
int __cdecl sub_8100C30(_DWORD *a1, _DWORD *a2);
int __cdecl sub_8100C50(_DWORD *a1, int a2, int a3, int a4);
int __cdecl sub_8100C74(_DWORD *a1, _DWORD *a2);
int __cdecl sub_8100CA4(float *a1, float *a2, float *a3);
int __cdecl sub_8100CE8(float *a1, float *a2, float *a3);
int __cdecl sub_8100D2C(int, float, int, int); // idb
_DWORD *__cdecl sub_8100D80(_DWORD *a1);
_DWORD *__cdecl sub_8100E1E(_DWORD *a1);
int __cdecl sub_8100EDA(int a1, int a2);
_DWORD *__cdecl sub_8100F68(_DWORD *a1);
int *__cdecl sub_8100F84(_DWORD *a1);
void *sub_8100FE6();
void __cdecl sub_810104E(int a1, int a2, int a3, int a4);
int __cdecl sub_8101188(int a1, int a2, int a3);
int *__cdecl sub_81011D0(int a1, int a2);
int __cdecl sub_810121A(int a1, int a2);
// int __usercall sub_810125C@<eax>(long double a1@<st0>, _BYTE *a2);
_DWORD *__cdecl sub_810132E(unsigned __int8 *a1);
int __cdecl sub_8101390(int a1);
int __cdecl sub_81013E8(int a1);
// float __usercall sub_8101410@<eax>(int a1);
void __cdecl sub_810145A(int a1, int a2);
int __cdecl sub_8101494(int a1, int a2);
void __cdecl sub_81014CE(int a1, int a2);
int __cdecl sub_8101508(int a1, int a2);
void __cdecl sub_8101542(int a1, int a2);
int __cdecl sub_810157C(int a1, int a2);
void __cdecl sub_81015B6(int a1, int a2);
int __cdecl sub_81015F0(int a1, int a2);
void __cdecl sub_810162A(int a1, int a2);
int __cdecl sub_8101664(int a1, int a2);
int __cdecl sub_810169E(int a1, int a2);
int __cdecl sub_8101716(int a1, int a2);
__int16 **__cdecl sub_810178E(int a1);
int sub_81017D2();
int sub_810180E();
int sub_810187A();
void **sub_810193A();
int __cdecl sub_8101988(int a1);
int __cdecl sub_81019C2(int a1);
void __cdecl sub_8101A12(int a1);
void __cdecl sub_8101A84(int a1);
void __cdecl sub_8101B14(int a1);
int __cdecl sub_8101B92(int a1);
int __cdecl sub_8101C94(int a1, int a2, int a3);
int __cdecl sub_8101D48(int a1, int a2, int a3);
int __cdecl sub_8101F16(int a1);
int __cdecl sub_8101F3A(int a1);
int __cdecl sub_8101F5E(int a1);
int __cdecl sub_8101F82(int a1);
int __cdecl sub_8101FA6(int a1);
int __cdecl sub_8101FCA(int a1);
// float __usercall sub_8101FEE@<eax>(int a1);
int __cdecl sub_8102030(int a1);
int __cdecl sub_8102068(int a1);
int __cdecl sub_810212C(int a1);
int __cdecl sub_8102242(int a1);
_DWORD *__cdecl sub_810232A(int a1);
_DWORD *__cdecl sub_810234C(int a1);
int (__cdecl *__cdecl sub_810236E(char **a1))(int);
int **__cdecl sub_81023F2(_DWORD *a1, int a2, unsigned __int8 a3);
int __cdecl sub_810255C(float, float); // idb
int __cdecl sub_8102580(float, float); // idb
int __cdecl sub_81025A4(float); // idb
int __cdecl sub_81025DA(float); // idb
long double __cdecl sub_8102608(float a1, float a2, float a3);
int __cdecl sub_8102634(int a1, int a2);
int __cdecl sub_8102704(int a1, int a2, int a3, int a4);
signed int __cdecl sub_81029D4(int a1, int *a2);
signed int __cdecl sub_8102BE2(int a1, int *a2, _DWORD *a3, int a4);
signed int __cdecl sub_8103530(int a1, int *a2);
// unsigned __int16 *__usercall sub_81037F0@<eax>(long double a1@<st0>, int a2, int *a3, int a4);
// unsigned __int16 *__usercall sub_810381C@<eax>(long double a1@<st0>, unsigned __int16 *s, int *a3, int a4);
// int __usercall sub_8103B6A@<eax>(long double a1@<st0>);
int __cdecl sub_8103CB2(char **a1, int a2);
// int __usercall sub_8103D3C@<eax>(long double a1@<st0>, int a2, _DWORD *a3, _DWORD *a4, int a5);
int __cdecl sub_8103F44(int, int, float, int); // idb
_DWORD *__cdecl sub_810404E(int a1, int a2, int a3);
int __cdecl sub_8104600(_DWORD *a1);
void *sub_8104A02();
int sub_8104A30();
int sub_8104AEC();
int __cdecl sub_8104C84(int a1, int a2);
int __cdecl sub_8104D86(int a1);
int __cdecl sub_8104EA2(int a1);
// int __usercall sub_8104EB2@<eax>(long double a1@<st0>, int a2, int a3);
int __cdecl sub_81050FE(int a1, int a2, int a3, _DWORD *a4);
int __cdecl sub_81052AA(int a1, int a2);
int __cdecl sub_8105382(int a1, int *a2, _DWORD *a3);
float *__cdecl sub_81053B6(float *a1);
int __cdecl sub_81058A0(int *a1);
int __cdecl sub_810592C(float *a1);
void __cdecl sub_8105956(_DWORD *a1);
int __cdecl sub_8105D5E(float); // idb
int __cdecl sub_8105D94(_DWORD *a1);
int __cdecl sub_8105DBE(_DWORD *a1, int a2, int a3, int a4);
int __cdecl sub_8105DE2(_DWORD *a1, _DWORD *a2);
int __cdecl sub_8105E12(float *a1, float *a2, float *a3);
int __cdecl sub_8105E56(float *a1, float *a2, float *a3);
int __cdecl sub_8105E9A(float *a1, float *a2, float *a3);
int __cdecl sub_8105EF6(int, float, int); // idb
int __cdecl sub_8105F2E(int, float, int, int); // idb
long double __cdecl sub_8105F82(float *a1, float *a2);
long double __cdecl sub_8105FB6(float *a1);
signed int __cdecl sub_8105FEA(int a1);
// char *__usercall sub_8106014@<eax>(long double a1@<st0>);
int sub_810695E();
int __cdecl sub_8106968(int a1);
long double sub_8106976();
int __cdecl sub_810698A(int a1);
int __cdecl sub_81069A6(int a1);
int __cdecl sub_81069C2(int a1, int a2);
int __cdecl sub_81069E2(int a1);
// int __usercall sub_81069FC@<eax>(long double a1@<st0>);
int __cdecl sub_8106A7C(signed __int16 ***a1, unsigned __int16 a2, int a3, int a4);
int *sub_8106AAC();
int *sub_8106B36();
void *__cdecl sub_8106BF2(size_t a1);
// int __usercall sub_8106C06@<eax>(long double a1@<st0>, int a2, unsigned int seed, int a4, int a5);
// unsigned int *__usercall sub_8107058@<eax>(long double a1@<st0>, int a2);
int sub_8107186();
int sub_81071FE(const void *, const void *); // idb
void sub_8107356();
// void __usercall sub_8107428(long double a1@<st0>);
void sub_8107502(char *format, ...);
// void __usercall sub_8107644(long double a1@<st0>);
int sub_8107848();
int sub_8107962();
int __cdecl sub_81079C8(int a1);
void sub_8107A40();
int __cdecl sub_8107A7C(int a1);
// void __usercall sub_8107AC4(long double a1@<st0>, _DWORD *s);
// void __usercall sub_8107CA2(long double a1@<st0>, int a2);
void __cdecl sub_8108090(void *s, int a2, int a3, int a4, int a5, int a6, int a7);
signed int __cdecl sub_81080E6(float *a1, float *a2, float *a3, float *a4, int a5, int a6);
void __cdecl sub_8108134(void *s, int a2, int a3, int a4, int a5, int a6);
signed int __cdecl sub_810818A(float *a1, float *a2, int a3, int a4);
int *__cdecl sub_81081DA(int *a1, float *a2, float *a3, int a4, int a5);
void sub_8108222();
// int __usercall sub_8108228@<eax>(long double a1@<st0>, void *s);
int __cdecl sub_810823C(_DWORD *a1);
// int __usercall sub_810825C@<eax>(long double a1@<st0>, void *s);
int __cdecl sub_8108270(int a1, _DWORD *a2, _DWORD *a3);
// int __usercall sub_8108354@<eax>(long double a1@<st0>, void *s);
int __cdecl sub_8108368(int a1);
// int __usercall sub_810839E@<eax>(long double a1@<st0>, void *s);
int *sub_81083B2();
int __cdecl sub_81083E8(int a1, int a2, int a3);
int __cdecl sub_81084EA(_DWORD *a1, int *a2);
void __cdecl sub_81085B8(int a1, int a2);
int __cdecl sub_8109236(int a1, int a2);
int *__cdecl sub_8109348(_DWORD *a1, int *a2);
int __cdecl sub_81093B8(_DWORD *a1, int *a2);
int __cdecl sub_810948E(_DWORD *a1);
unsigned int __cdecl sub_810950C(int a1);
int __cdecl sub_8109672(_DWORD *a1);
signed int __cdecl sub_81096DE(int a1, int a2, int a3);
signed int __cdecl sub_8109984(int a1, int a2);
char *__cdecl sub_81099D6(_DWORD *a1);
int __cdecl sub_8109A68(int a1);
signed int __cdecl sub_8109C76(int *a1, int a2);
_BOOL4 __cdecl sub_8109D26(int a1, int a2);
int __cdecl sub_8109E54(int a1);
_BOOL4 __cdecl sub_8109EC0(int a1, int a2);
void __cdecl sub_8109F46(int a1, int a2);
int __cdecl sub_810A21A(int a1, char *s1);
int __cdecl sub_810A7F2(int a1);
long double __cdecl sub_810A840(float a1);
long double __cdecl sub_810A85A(float a1, float a2, float a3);
int __cdecl sub_810A898(float *a1, float *a2, float *a3);
int __cdecl sub_810A8C4(_DWORD *a1);
int __cdecl sub_810A8EE(_DWORD *a1, int a2, int a3, int a4);
int __cdecl sub_810A912(_DWORD *a1, _DWORD *a2);
int __cdecl sub_810A942(float *a1, float *a2, float *a3);
int __cdecl sub_810A986(float *a1, float *a2, float *a3);
int __cdecl sub_810A9CA(int, float, int, int); // idb
long double __cdecl sub_810AA1E(float *a1, float *a2);
long double __cdecl sub_810AA52(float a1, float a2, float a3);
void __cdecl sub_810AAB4(int a1, float *a2, int a3, int a4);
_BOOL4 __cdecl sub_810AD10(int a1, int a2);
int __cdecl sub_810B07A(int a1, int a2, int a3, float *a4);
int __cdecl sub_810B4D8(int a1);
void __cdecl sub_810B894(void *s, int a2, int a3, int a4, int a5);
int __cdecl sub_810B90E(void *s, int, int, int); // idb
long double __cdecl sub_810B988(float a1);
int __cdecl sub_810B9B6(int a1);
int __cdecl sub_810BB8C(float *a1, int a2);
unsigned __int8 *__cdecl sub_810BC36(unsigned __int8 *a1);
int __cdecl sub_810C1F6(_DWORD *a1, _DWORD *a2, float *a3, int a4, int a5);
int __cdecl sub_810C4A0(_DWORD *a1, _DWORD *a2, float *a3);
long double __cdecl sub_810C6D2(float a1);
int __cdecl sub_810C6EC(_DWORD *a1);
int __cdecl sub_810C716(_DWORD *a1, _DWORD *a2);
int __cdecl sub_810C746(float *a1, float *a2, float *a3);
int __cdecl sub_810C78A(float *a1, float *a2, float *a3);
int __cdecl sub_810C7CE(int, float, int); // idb
int __cdecl sub_810C806(int, float, int, int); // idb
long double __cdecl sub_810C85A(float *a1, float *a2);
double __cdecl sub_810C88E(_DWORD); // weak
long double __cdecl sub_810C8CC(float a1);
int __cdecl sub_810C8EC(int *a1, int a2);
unsigned int __cdecl sub_810C9F0(float *a1, int a2);
int *__cdecl sub_810CA2C(int a1, int a2);
int __cdecl sub_810CA98(int a1, float *a2);
signed int __cdecl sub_810CB04(int a1, int a2, float *a3, float *a4);
int __cdecl sub_810D058(int a1, float *a2, float *a3, _DWORD *a4);
int __cdecl sub_810D672(int a1);
int __cdecl sub_810D966(_DWORD *a1);
unsigned int *__cdecl sub_810D9B8(int a1);
unsigned int *__cdecl sub_810DBA6(int a1);
unsigned int *__cdecl sub_810DBBA(int a1);
int __cdecl sub_810DBCE(_DWORD *a1, int a2, int a3, int a4);
int __cdecl sub_810DBF2(_DWORD *a1, _DWORD *a2);
unsigned int __cdecl sub_810DC22(_DWORD *a1);
int __cdecl sub_810DC60(float *a1, float *a2, float *a3);
int __cdecl sub_810DCA4(float *a1, float *a2, float *a3);
long double __cdecl sub_810DCE8(float *a1, float *a2);
int __cdecl sub_810DD1C(char *s); // idb
void sub_810DD38();
int __cdecl sub_810DD70(int a1, char *s, int a3);
int sub_810DDEE();
// int __usercall sub_810DEE2@<eax>(long double a1@<st0>);
int sub_810DF4E();
// int __usercall sub_810DF86@<eax>(long double a1@<st0>);
int *sub_810E010();
int __cdecl sub_810E03A(int a1);
int __cdecl sub_810E074(int a1);
int sub_810E128();
int sub_810E13C();
int sub_810E150();
int sub_810E164();
int sub_810E178();
int sub_810E18C();
void sub_810E1DC();
void __cdecl __noreturn sub_810E202(int a1, char *format);
void __cdecl sub_810E21E(int a1, int a2, signed int a3);
int __cdecl sub_810E290(signed int a1, signed int a2, int a3, int a4, int a5);
int __cdecl sub_810E5D8(int a1, int a2);
int sub_810E64A();
int sub_810E676();
void sub_810E6A2();
void sub_810E780();
void sub_810E7A6();
void sub_810E7E4();
int sub_810E810();
int sub_810E876();
int sub_810E89C();
int sub_810E918();
int sub_810E948();
int sub_810E980();
// void __usercall sub_810E9BE(long double a1@<st0>);
int sub_810EB8A();
unsigned int sub_810EBA0();
int sub_810EBF0();
int __cdecl sub_810EC7C(int a1);
int sub_810ECE4();
int sub_810ED66();
_DWORD *sub_810EDD4();
// void __usercall sub_810EE34(long double a1@<st0>);
int sub_810EF04();
int sub_810EF92();
// void __usercall sub_810EFCA(long double a1@<st0>, int a2);
// void __usercall sub_810F0BA(long double a1@<st0>, int a2);
// _DWORD *__usercall sub_810F1E4@<eax>(long double a1@<st0>, int a2);
int __cdecl sub_810F206(int a1);
int __cdecl sub_810F250(int a1);
int __cdecl sub_810F2BE(int a1);
int __cdecl sub_810F324(int a1);
// void __usercall sub_810F392(long double a1@<st0>, int a2);
// int __usercall sub_810F5A8@<eax>(long double a1@<st0>, int a2);
int __cdecl sub_810F5CA(int a1);
_DWORD *__cdecl sub_810F658(int a1);
_DWORD *__cdecl sub_810F690(int a1);
int __cdecl sub_810F6D6(int a1);
// int __usercall sub_810F760@<eax>(long double a1@<st0>, int a2);
int sub_810F872();
int __cdecl sub_810F8A4(int a1);
int __cdecl sub_810F914(int a1);
int __cdecl sub_810F984(int a1);
int __cdecl sub_810F9D2(int a1);
// int __usercall sub_810FA1A@<eax>(long double a1@<st0>, int a2);
// int __usercall sub_810FA8A@<eax>(long double a1@<st0>, int a2);
int __cdecl sub_810FAD8(int a1);
void __cdecl sub_810FB4A(int a1);
_DWORD *__cdecl sub_810FC60(int a1);
_DWORD *__cdecl sub_810FCA8(int a1);
void __cdecl sub_810FCF0(int a1);
int __cdecl sub_810FD84(int a1);
int __cdecl sub_810FDD2(int a1);
void __cdecl sub_810FE44(int a1);
int __cdecl sub_810FFAA(int, char *s1); // idb
int __cdecl sub_811006E(int a1);
int __cdecl sub_8110172(int a1);
int __cdecl sub_8110196(int a1);
int __cdecl sub_81101E4(int a1);
unsigned int __cdecl sub_8110232(int a1);
int __cdecl sub_8110260(int a1);
int __cdecl sub_811028E(int a1);
int __cdecl sub_81102CE(int a1);
int *sub_811030E();
signed int __cdecl sub_8110346(_DWORD *a1, int a2);
int __cdecl sub_81103B0(int a1);
_DWORD *__cdecl sub_8110408(_DWORD *a1);
int __cdecl sub_8110446(int a1, unsigned int a2);
int sub_8110514();
_DWORD *sub_81106B6();
int sub_811073A();
int sub_8110814();
signed int sub_8110886();
int sub_811097C();
char *sub_8110A1C();
void sub_8110B02();
void sub_8110BEE();
int sub_8110C8C();
int sub_8110CA0();
int sub_8110DA4();
int sub_8110EAC();
void sub_8110EC2();
int __cdecl sub_8110FC2(char *a1);
void sub_8111054();
int __cdecl sub_811114A(char *a1);
void sub_81111F2();
int __cdecl sub_81112E8(char *a1);
int sub_8111390();
int sub_81115C2();
int sub_8111684();
_DWORD *sub_8111786();
void sub_811181C();
int sub_8111876();
int sub_81118AA();
int sub_8111918();
int sub_811198E();
int sub_81119C0();
int sub_81119F2();
int sub_8111A56();
int sub_8111AD0();
int sub_8111B4A();
void sub_8111B82();
int sub_8111C46();
int sub_8111C8E();
int sub_8111CD6();
int sub_8111D04();
int sub_8111D32();
int sub_8111DB8();
_DWORD *sub_8111E00();
_DWORD *sub_8111E46();
_DWORD *sub_8111E7E();
_DWORD *sub_8111EC6();
_DWORD *sub_8111F0E();
int sub_8111F56();
int sub_8111F9A();
void sub_81120A2();
int sub_811213C();
int sub_81122AC();
void sub_81122F0();
int sub_811239C();
int sub_811242C();
int sub_811245E();
int sub_8112490();
int sub_811251A();
char *sub_811256E();
void sub_81125B4();
void sub_811268C();
int sub_811272E();
int sub_8112836();
int sub_81128D2();
_DWORD *sub_81128EC();
int sub_8112A04();
int sub_8112B24();
int sub_8112B60();
void __cdecl sub_8112BAC(int a1, int a2);
int sub_8112C1C();
int sub_8112E4E();
int sub_8112FDE();
void __cdecl sub_8113294(int a1, float a2, float a3, float a4, float a5, float a6, float a7, float a8);
void sub_81133D0();
void sub_8113488();
int sub_811355A();
int sub_81135BA();
signed int sub_81135FA();
void sub_81136B8();
int sub_81137DA();
int sub_811384E();
int sub_81138D2();
int sub_8113952();
void sub_8113A4A();
int sub_8113AA0();
int sub_8113B6E();
int sub_8113C58();
int sub_8113C8A();
// float __usercall sub_8113D32@<eax>();
void __cdecl sub_8113E1A(int a1);
int __cdecl sub_8113FA2(int a1);
int __cdecl sub_8114006(int a1);
_DWORD *__cdecl sub_81140EC(int a1);
void __cdecl sub_811416E(int a1);
void __cdecl sub_81141E2(int a1);
void __cdecl sub_811424A(int a1);
void __cdecl sub_81142BE(int a1);
int __cdecl sub_8114326(int a1);
int __cdecl sub_811451A(int a1);
// void __usercall sub_81145B4(long double a1@<st0>);
// void __usercall sub_811462C(long double a1@<st0>);
// void __usercall sub_81146E2(long double a1@<st0>);
// int *__usercall sub_8114750@<eax>(long double a1@<st0>);
// char *__usercall sub_8114772@<eax>(long double a1@<st0>);
int sub_81148C4();
int sub_811491A();
int sub_8114966();
int sub_81149B2();
int sub_8114A5A();
int sub_8114AEA();
int sub_8114B54();
// void __usercall sub_8114B9A(long double a1@<st0>);
// void __usercall sub_8114BE0(long double a1@<st0>);
int sub_8114C26();
unsigned int sub_8114C98();
int sub_8114F2C();
int sub_8115014();
int sub_8115138();
int sub_81152F0();
void *sub_8115462();
int sub_8115490();
void __cdecl sub_81154B6(int a1);
int __cdecl sub_81155E4(int a1);
int __cdecl sub_81156CC(int a1);
int __cdecl sub_811579A(int a1);
int __cdecl sub_8115824(char **a1, _DWORD *a2);
int __cdecl sub_81158C2(char **a1, _DWORD *a2);
int (__cdecl *__cdecl sub_811595C(char **a1, _DWORD *a2))(__int16);
int __cdecl sub_81159D4(int a1);
int __cdecl sub_8115A18(_DWORD *a1);
int __cdecl sub_8115A46(_DWORD *a1);
_DWORD *__cdecl sub_8115AA2(_DWORD *a1);
int __cdecl sub_8115AC2(int *a1);
int sub_8115AE2();
int __cdecl sub_8115DD2(char *a1);
_BOOL4 __cdecl sub_8115E3C(char *a1);
int sub_8115E66();
int sub_8115E94();
int __cdecl sub_8115EC2(int *a1);
int __cdecl sub_8115EF6(int *a1);
int __cdecl sub_8115F2A(int *a1, int *a2, int *a3, int a4, int a5, unsigned int a6, int a7, _DWORD *a8, _DWORD *a9, int a10, int a11);
int __cdecl sub_8116004(int *a1, int *a2, int *a3, int a4, unsigned int a5, int a6, _DWORD *a7, int a8, int a9, int a10);
int __cdecl sub_81160D4(int, char *, char *, char *s); // idb
int __cdecl sub_811611C(int, char *s); // idb
int __cdecl sub_8116158(float); // idb
void __cdecl sub_811618E(float a1, int a2, int a3);
int __cdecl sub_81161BC(_DWORD *a1);
int __cdecl sub_81161E6(_DWORD *a1, int a2, int a3, int a4);
int __cdecl sub_811620A(_DWORD *a1, _DWORD *a2);
int __cdecl sub_811623A(float *a1, float *a2, float *a3);
int __cdecl sub_811627E(float *a1, float *a2, float *a3);
int __cdecl sub_81162C2(int, float, int); // idb
long double __cdecl sub_81162FA(float *a1, float *a2);
long double __cdecl sub_811632E(float *a1);
double __cdecl sub_8116362(_DWORD); // weak
long double __cdecl sub_81163A0(float a1);
int __cdecl sub_81163C0(int, int, float, float, float, int, int, int); // idb
int __cdecl sub_81165A0(int a1);
int __cdecl sub_81167BA(int, int, float, float, float, int, int, int, int, int, int, int); // idb
int __cdecl sub_8116B6E(int, int, float, float, float, int, int, int, int, int, int, int); // idb
int __cdecl sub_8116F18(int, int, float, float, float); // idb
int __cdecl sub_8116FAA(int, int, float); // idb
int __cdecl sub_8117050(int, int, float, float, float); // idb
int __cdecl sub_81170E2(int, int, float, float, float); // idb
int __cdecl sub_8117174(int a1);
int __cdecl sub_8117316(int a1);
// int __usercall sub_811734C@<eax>(long double a1@<st0>, int a2);
int __cdecl sub_8117398(int a1);
void __cdecl sub_81173F6(float *a1, float *a2, float *a3);
int __cdecl sub_81174FA(int a1);
int __cdecl sub_81175DC(int a1);
int __cdecl sub_81176A6(int a1, int a2);
int __cdecl sub_81177AC(int a1);
int __cdecl sub_81177C8(int a1);
int __cdecl sub_81177E4(int a1);
int __cdecl sub_8117800(int a1);
int __cdecl sub_8117938(int a1, int a2);
int __cdecl sub_8117A3E(int a1);
int __cdecl sub_8117A5A(int a1);
int __cdecl sub_8117A76(int a1);
int __cdecl sub_8117A92(int a1);
void __cdecl sub_8117B74(int a1);
void __cdecl sub_8117C76(int a1);
int (__cdecl *__cdecl sub_8117D6A(char **a1))(__int16);
int __cdecl sub_8117DEE(_DWORD *a1, _DWORD *a2);
int __cdecl sub_8117E1E(float *a1, float *a2, float *a3);
int __cdecl sub_8117E62(int, float, int); // idb
int __cdecl sub_8117E9A(int, float, int, int); // idb
double __cdecl sub_8117EEE(_DWORD); // weak
long double __cdecl sub_8117F2C(float a1);
int __cdecl sub_8117F4C(char *s1, int, int); // idb
int __cdecl sub_8117F76(char *s1, int, int); // idb
int __cdecl sub_8117FB2(char *s1, int, int); // idb
int __cdecl sub_8117FEC(char *s1, int, int); // idb
void sub_811804C();
int __cdecl sub_8118060(char *s1, char *nptr); // idb
int __cdecl sub_8118148(char *s1, char *nptr, int); // idb
void __cdecl sub_8118180(char *s1, char *s, int a3);
int __cdecl sub_8118320(_DWORD *a1);
int sub_8118398();
char **__cdecl sub_811841C(int a1, int a2);
int __cdecl sub_8118504(int *a1, int *a2);
int __cdecl sub_811852A(char *s1); // idb
// void __usercall sub_81185EA(long double a1@<st0>);
// signed int __usercall sub_81186D2@<eax>(long double a1@<st0>, int a2);
void **sub_81187B8();
int sub_8118806();
signed int __cdecl sub_8118822(int a1, int a2);
int __cdecl sub_81188EE(int a1, int a2, int a3);
signed int __cdecl sub_81189D2(int a1, int a2, int a3);
char *__cdecl sub_8118A22(int a1, int a2);
int __cdecl sub_8118AAC(int a1, int a2, int a3);
char *__cdecl sub_8118BCC(char *a1, int a2, int a3);
int *__cdecl sub_8118C0E(int a1);
void __cdecl sub_8118C98(int *a1);
int __cdecl Scr_AddEntity(int *a1);
int __cdecl sub_8118CDE(unsigned int a1);
void __cdecl sub_8118D3A(int a1);
int __cdecl sub_8118D6E(int a1);
int __cdecl sub_8118D98(unsigned int a1);
int __cdecl sub_8118DF4(int *a1, int a2, int a3);
int __cdecl sub_8118E22(int *a1, int a2, int a3);
int __cdecl Scr_Notify(int *a1, unsigned __int16 a2, int a3);
int sub_8118E82();
int sub_8118F7E();
signed int __cdecl sub_81190B6(int *a1, int a2);
int sub_81190DA();
// signed int __usercall sub_81192E0@<eax>(long double a1@<st0>);
void *sub_811932A();
int __cdecl sub_81193A8(_DWORD *a1);
int __cdecl sub_81193D2(_DWORD *a1, _DWORD *a2);
signed int __cdecl sub_8119404(char *a1, _DWORD *a2);
void sub_811956E();
void __cdecl sub_8119642(char *a1);
char *sub_81196D0();
void sub_8119772();
void sub_81197C2();
signed int sub_8119892();
int __cdecl sub_81199B4(char *nptr); // idb
// signed int __usercall sub_8119AD4@<eax>(long double a1@<st0>);
_BOOL4 __cdecl sub_8119C40(int a1, int a2);
int __cdecl sub_8119CB8(int a1);
int sub_8119EF2();
int __cdecl sub_8119F76(int, float, int, int); // idb
int __cdecl sub_8119FCC(int *a1, int *a2);
int __cdecl sub_811A074(int a1);
void __cdecl sub_811A0AE(int a1, int a2);
int __cdecl sub_811A106(int a1);
int __cdecl sub_811A1B8(int *a1);
int __cdecl sub_811A1DE(int *a1, int *a2);
int __cdecl sub_811A20A(int a1);
int __cdecl sub_811A250(int a1);
int __cdecl sub_811A3F0(int a1);
int __cdecl sub_811A4FC(int a1, int a2);
int __cdecl sub_811A62A(int a1);
int __cdecl sub_811A6A6(int a1);
_BOOL4 __cdecl sub_811A6EE(int a1, signed int a2);
int __cdecl sub_811A826(int *a1, int *a2, int a3, signed int a4);
int __cdecl sub_811A8D2(int *a1, int *a2);
int *__cdecl sub_811A902(int *a1, int *a2, int a3, int a4, signed int a5);
int *__cdecl sub_811A944(int *a1, int a2, int *a3, int a4, signed int a5);
int __cdecl sub_811A986(int a1);
int __cdecl sub_811AA18(int *a1, _DWORD *a2, float *a3, int a4, signed int a5);
int __cdecl sub_811AC06(int *a1, _DWORD *a2, float *a3, int a4, signed int a5);
int __cdecl sub_811ADB6(int a1);
int __cdecl sub_811ADFA(_DWORD *a1, _DWORD *a2);
int __cdecl sub_811AE2A(float *a1, float *a2, float *a3);
int __cdecl sub_811AE70(char *s2, int a2, int a3, int a4, int a5);
int __cdecl sub_811AF6E(char *s2); // idb
int __cdecl sub_811AFBA(char *src); // idb
int __cdecl sub_811B00C(char *s2); // idb
int __cdecl sub_811B0F8(int a1);
int __cdecl sub_811B108(int a1);
char *__cdecl sub_811B124(int a1);
int __cdecl sub_811B13C(char *s2); // idb
int __cdecl sub_811B170(char *s2); // idb
int __cdecl sub_811B1A4(char *s2); // idb
int __cdecl sub_811B1D8(char *s2); // idb
// _DWORD *__usercall sub_811B20E@<eax>(long double a1@<st0>, int a2);
int __cdecl sub_811B3EA(int, char *s2); // idb
int __cdecl sub_811B422(int, char *s1); // idb
// int __usercall sub_811B470@<eax>(long double a1@<st0>, int a2, char *s2, int a4, int a5);
// int __usercall sub_811B528@<eax>(long double a1@<st0>, int a2, char *s2, int a4);
// _DWORD *__usercall sub_811B6C2@<eax>(long double a1@<st0>, int a2);
// signed int __usercall sub_811B720@<eax>(long double a1@<st0>, int *a2, int *a3, int a4);
// signed int __usercall sub_811B86E@<eax>(long double a1@<st0>, int *a2, int *a3, int a4);
// signed int __usercall sub_811B8BA@<eax>(long double a1@<st0>, int *a2, int *a3, int a4, _DWORD *a5, float *a6);
// int __usercall sub_811B928@<eax>(long double a1@<st0>, _DWORD *a2);
// int __usercall sub_811BA8A@<eax>(long double a1@<st0>, _DWORD *a2, int a3);
// _DWORD *__usercall sub_811BAF4@<eax>(long double a1@<st0>, int a2, int a3);
int __cdecl sub_811BB3A(int a1, int a2);
int __cdecl sub_811BC46(int a1, float *a2);
int __cdecl sub_811BC88(int a1, int a2);
void __cdecl sub_811BD52(int a1, signed int a2);
int __cdecl sub_811BE86(_DWORD *a1);
int __cdecl sub_811BEEE(int *a1);
int __cdecl sub_811BF04(int *a1, int a2);
int *__cdecl sub_811BF30(int a1);
int *__cdecl sub_811BFC4(int a1, int a2);
int __cdecl sub_811C056(int *a1, int a2);
signed int __cdecl sub_811C0B2(int a1, int a2, float *a3);
signed int __cdecl sub_811C16A(int a1, int a2, float *a3);
char *__cdecl sub_811C1EE(int a1, int a2, __int16 a3);
char *__cdecl sub_811C272(int a1, int a2, char *a3);
int __cdecl sub_811C2FA(unsigned __int16 a1);
int __cdecl sub_811C3CC(int a1);
int sub_811C444();
_BOOL4 __cdecl sub_811C4F8(int a1);
int sub_811C546();
// _DWORD *__usercall sub_811C614@<eax>(long double a1@<st0>);
int *__cdecl sub_811C6AE(int *a1);
signed int __cdecl sub_811C830(_DWORD *a1);
// int __usercall sub_811C87C@<eax>(long double a1@<st0>);
int __cdecl sub_811C996(_DWORD *a1);
// int __usercall sub_811C9C0@<eax>(long double a1@<st0>, void *s);
int __cdecl sub_811CB00(int *a1);
int __cdecl sub_811CB34(_DWORD *a1, int a2);
int __cdecl sub_811CC24(int a1);
int __cdecl sub_811CD6C(int a1, int a2, unsigned __int8 a3);
int __cdecl sub_811CDA2(_DWORD *a1, int a2, int a3);
int __cdecl sub_811CE66(_DWORD *a1, int a2);
int __cdecl sub_811CE9E(_DWORD *a1, int a2);
int __cdecl sub_811CEFE(int a1, char **a2);
int __cdecl sub_811CF36(_DWORD *a1, _DWORD *a2);
int __cdecl sub_811CF96(_DWORD *a1, _DWORD *a2);
_BOOL4 __cdecl sub_811CFF6(int a1, int a2);
int __cdecl sub_811D098(int, char *s); // idb
int __cdecl sub_811D0D2(_DWORD *a1);
int __cdecl sub_811D0FC(_DWORD *a1, _DWORD *a2);
int __cdecl sub_811D12C(float *a1, float *a2, float *a3);
int __cdecl sub_811D170(float *a1, float *a2, float *a3);
long double __cdecl sub_811D1B4(float *a1, float *a2);
int __cdecl sub_811D220(int, int, int, float, float, float, void *s, int); // idb
__int16 __cdecl sub_811D3B4(int a1, int a2, float a3, float a4, float a5);
int *__cdecl sub_811D53A(int a1, int a2);
float *__cdecl sub_811D5E0(float *a1, float *a2);
int __cdecl sub_811D638(float, int, int, float); // idb
int __cdecl sub_811D6EC(int, float); // idb
int __cdecl sub_811D7E6(int, void *s); // idb
int __cdecl sub_811D95C(int a1);
void __cdecl sub_811DA00(int *a1, int *a2, float *a3, float *a4, float a5, signed int a6, int a7, _DWORD *a8, int a9);
int __cdecl sub_811DF44(int, int, int, int, float); // idb
int __cdecl sub_811DFF4(int, float, int, int, int); // idb
int __cdecl sub_811E0C2(_DWORD *a1, int a2, int a3);
int __cdecl sub_811E18A(int, float, int); // idb
_BOOL4 __cdecl sub_811E2C2(int a1, int a2);
void __cdecl sub_811E35C(int a1, float *a2);
int __cdecl sub_811E3E0(int a1, int a2);
int __cdecl sub_811E56A(int a1);
int __cdecl sub_811E586(_DWORD *a1);
__int16 __cdecl sub_811E5E0(int a1);
signed int __cdecl sub_811E696(int a1, int a2);
void sub_811E8E4();
int __cdecl sub_811E940(char *s1); // idb
int __cdecl sub_811E97A(int a1, int a2);
int __cdecl sub_811E9B4(int a1, int a2);
long double __cdecl sub_811E9EE(float a1, float a2, float a3);
void __cdecl sub_811EA04(float a1, int a2, int a3);
int __cdecl sub_811EA32(_DWORD *a1, _DWORD *a2);
int __cdecl sub_811EA62(float *a1, float *a2, float *a3);
int __cdecl sub_811EAA6(int, float, int); // idb
int __cdecl sub_811EADE(int, float, int, int); // idb
long double __cdecl sub_811EB32(float *a1, float *a2);
double __cdecl sub_811EB66(_DWORD); // weak
long double __cdecl sub_811EBA4(float a1);
int __cdecl sub_811EBC4(int *a1, int a2);
signed int __cdecl sub_811ECE4(int a1);
int __cdecl sub_811EDD4(int *a1);
int __cdecl sub_811EE84(int *a1);
int sub_811EFC8(const void *, const void *); // idb
size_t __cdecl sub_811F004(int a1, void *base);
int __cdecl sub_811F61A(int a1, int a2);
_BYTE *__cdecl sub_811F6A6(int a1);
_BYTE *__cdecl sub_811F736(int a1);
int __cdecl sub_811FABE(void *s, int, int, int, int, int, int); // idb
void __cdecl sub_811FB7A(int *a1);
long double __cdecl sub_811FEDE(float a1);
int __cdecl sub_811FEEA(float *a1, float *a2, float *a3);
int __cdecl sub_811FF2E(float *a1, float *a2, float *a3);
int __cdecl sub_811FF72(int, float, int); // idb
int __cdecl sub_811FFAA(int, float, int, int); // idb
long double __cdecl sub_811FFFE(float *a1, float *a2);
long double __cdecl sub_8120032(float *a1);
int sub_8120068();
int __cdecl sub_8120708(int a1);
int __cdecl sub_812074C(int a1, int a2);
int __cdecl sub_8120794(int a1, int a2);
void *__cdecl sub_81207DC(int *a1);
int __cdecl sub_8120872(int *a1);
int __cdecl sub_81208D4(int *a1);
int __cdecl sub_8120936(int *a1, int a2);
_BYTE **__cdecl sub_8120968(int *a1, _BYTE *a2, int a3);
int __cdecl sub_8120AA2(int *a1, const char **a2);
int __cdecl sub_8120B02(int *a1, int a2);
int __cdecl sub_8120B70(int *a1, int a2);
int __cdecl sub_8120BDC(int *a1, int a2);
int __cdecl sub_8120BFA(int *a1, char *a2, int a3);
_BYTE **__cdecl sub_8120F84(int a1, char *a2, int a3);
const char **__cdecl sub_8120FCA(int a1, const char ***a2);
int __cdecl sub_8121006(int a1, int *a2);
int __cdecl sub_8121040(int a1, int *a2);
int __cdecl sub_812107A(int a1, int a2);
int __cdecl sub_81210B2(int a1, char a2);
int __cdecl sub_81210DA(int a1);
int __cdecl sub_8121100(int *a1);
long double __cdecl sub_8121126(int *a1);
int __cdecl sub_8121152(int *a1, char a2);
int sub_812117A(int *a1, ...);
int __cdecl sub_812119C(_DWORD *a1, int a2, int a3, int a4);
int __cdecl sub_812123C(int *a1, int *a2);
_DWORD *__cdecl sub_8121272(_DWORD *a1, int a2, int a3, int a4);
_DWORD *__cdecl sub_8121304(_DWORD *a1, int a2, int a3, int a4, int a5);
_DWORD *__cdecl sub_81213C4(int a1, int a2, int a3, int a4, int a5, float a6, float a7);
_DWORD *__cdecl sub_81216CE(int a1, int a2, float a3, int a4, int a5);
int __cdecl sub_81218EE(float, float); // idb
long double __cdecl sub_8121912(float a1, float a2, float a3);
_DWORD *__cdecl sub_812193C(_DWORD *a1, int a2);
long double __cdecl sub_8121962(float a1, float a2, float a3, float a4);
long double __cdecl sub_812197E(int a1, float a2);
long double __cdecl sub_8121A60(int a1, float a2);
_DWORD *__cdecl sub_8121AAC(void *src, int a2, int a3);
int __cdecl sub_8121C40(int a1);
unsigned int *FxMem_Init();
_DWORD *__cdecl sub_8121C8A(int a1, int a2, int a3);
int __cdecl sub_8121D9A(int a1);
int __cdecl sub_8121E02(int a1);
char *__cdecl sub_8121E22(char *a1);
void __cdecl sub_8121E7C(int a1, int a2);
// _DWORD *__userpurge sub_8121EF6@<eax>(_DWORD *a1, _DWORD *a2);
int __cdecl sub_8121FB2(int a1);
int __cdecl sub_8122008(_DWORD *a1);
_DWORD *__cdecl sub_81220BE(_DWORD *a1, _DWORD *a2);
_DWORD *__cdecl sub_81220FC(int *a1, int *a2);
void *__cdecl sub_81221F2(size_t a1);
int __cdecl sub_8122206(char *s2); // idb
_DWORD *__cdecl sub_812222A(_DWORD *a1);
int __cdecl sub_812226E(_DWORD *a1);
int __cdecl sub_81222A6(_DWORD *a1);
int __cdecl sub_81222DE(int a1);
void sub_8122316();
int sub_812231C();
void sub_8122326();
_BOOL4 __cdecl sub_812232C(int a1, int *a2);
int __cdecl sub_8122382(int a1);
signed int __cdecl sub_81223CE(int a1);
int __cdecl sub_8122472(int a1, int a2, int a3);
int __cdecl sub_8122490(int a1);
_DWORD *__cdecl sub_81224B2(int a1, _DWORD *a2);
int sub_81224D2();
int __cdecl sub_81224DC(int a1, int *a2);
void sub_8122668();
void __cdecl sub_812266E(int a1, int a2);
int __cdecl sub_81227C4(_DWORD *a1);
int __cdecl sub_81227F0(_DWORD *a1);
int __cdecl sub_812281C(_DWORD *a1);
int __cdecl sub_8122850(_DWORD *a1);
int __cdecl sub_8122884(char *a1);
void __cdecl sub_81228B8(int a1);
int __cdecl sub_81229F0(int a1);
void __cdecl sub_8122A2E(int a1);
signed int __cdecl sub_8122A76(float *a1);
int __cdecl sub_8122BB2(_DWORD *a1, _DWORD *a2);
void __cdecl sub_8122C06(int a1, int a2);
void __cdecl sub_8122C3C(int a1, int a2);
int __cdecl sub_8122EAC(int a1, int a2, int a3, int a4);
int __cdecl sub_8122EDA(int a1, int a2, int a3, int a4);
long double __cdecl sub_8122F08(int a1, int a2, int a3, float a4);
signed int __cdecl sub_8122FEA(int a1);
long double __cdecl sub_8123068(int a1, float a2, float a3);
_BOOL4 __cdecl sub_812309A(int a1, int a2, float a3);
int __cdecl sub_8123100(int a1);
int __cdecl sub_8123134(int, int, float, int, float, int); // idb
_BOOL4 __cdecl sub_812325E(int a1);
signed int __cdecl sub_81232B2(int a1, float *a2);
int __cdecl sub_8123660(int, float, int, int); // idb
int __cdecl sub_81237F4(int, float, int, int); // idb
int __cdecl sub_8123988(int, float, int, int); // idb
int __cdecl sub_8123A0A(int, float, int); // idb
int __cdecl sub_8123B94(int, float, int); // idb
int __cdecl sub_8123D1E(int a1, signed int a2, int a3);
int __cdecl sub_8123D56(int a1, signed int a2, float *a3);
int __cdecl sub_8123E30(int a1, _DWORD *a2);
int __cdecl sub_8123EA4(int, float, int, int); // idb
void __cdecl sub_8123F5C(int a1);
void __cdecl sub_8123FE0(int a1);
void __cdecl sub_8124080(int a1);
int __cdecl sub_812410E(int a1);
int __cdecl sub_812427C(int a1);
int __cdecl sub_812430C(int a1);
signed int sub_812447E();
_BYTE **__cdecl sub_8124488(char *a1, int *a2);
int __cdecl sub_8124824(_DWORD *a1, _DWORD *a2);
_DWORD *__cdecl sub_81249E6(_DWORD *a1);
int __cdecl sub_8124A02(_DWORD *a1);
int __cdecl sub_8124A36(_DWORD *a1);
int __cdecl sub_8124A6A(char *a1);
int __cdecl sub_8124A9E(int a1);
void __cdecl sub_8124ADC(int a1);
signed int __cdecl sub_8124AF8(float *a1);
signed int sub_8124C2C();
_BYTE **__cdecl sub_8124C36(char *a1, int *a2);
void __cdecl sub_8124C68(_DWORD *a1);
void __cdecl sub_8124CB6(_DWORD *a1);
int __cdecl sub_8124D04(_DWORD *a1);
int __cdecl sub_8124D38(_DWORD *a1);
int __cdecl sub_8124D6C(char *a1);
void sub_8124DA0();
// int __usercall sub_8124DA6@<eax>(long double a1@<st0>, float *a2);
void __cdecl sub_8124E0C(int a1);
void __cdecl sub_8124EE4(int a1);
void __cdecl sub_8124F00(int a1, int a2);
void __cdecl sub_8124F52(int a1);
signed int __cdecl sub_8124FE0(int a1);
signed int sub_8125198();
_BYTE **__cdecl sub_81251A2(char *a1, int *a2);
int __cdecl sub_8125230(_DWORD *a1, _DWORD *a2);
_DWORD *__cdecl sub_812528A(_DWORD *a1);
int __cdecl sub_81252A6(_DWORD *a1);
int __cdecl sub_81252DA(_DWORD *a1);
int __cdecl sub_812530E(char *a1);
void sub_8125342();
int __cdecl sub_8125348(float *a1);
void __cdecl sub_81253A0(int a1);
signed int __cdecl sub_81253BC(float *a1);
signed int sub_81254B2();
_BYTE **__cdecl sub_81254BC(char *a1, int *a2);
_DWORD *__cdecl sub_81254EE(_DWORD *a1);
_DWORD *__cdecl sub_812550A(_DWORD *a1);
int __cdecl sub_8125526(_DWORD *a1);
int __cdecl sub_812555A(_DWORD *a1);
int __cdecl sub_812558E(char *a1);
void __cdecl sub_81255C2(float *a1);
int __cdecl sub_81255E8(float *a1);
void __cdecl sub_8125640(int a1, int a2);
void __cdecl sub_8125692(int a1);
signed int __cdecl sub_81256AE(int a1);
void __cdecl sub_81257C8(int a1);
void __cdecl sub_8125848(float *a1, float *a2);
signed int sub_812592A();
_BYTE **__cdecl sub_8125934(char *a1, int *a2);
int __cdecl sub_81259AA(_DWORD *a1, _DWORD *a2);
_DWORD *__cdecl sub_8125A04(_DWORD *a1);
int __cdecl sub_8125A20(_DWORD *a1);
int __cdecl sub_8125A54(_DWORD *a1);
int __cdecl sub_8125A88(char *a1);
int __cdecl sub_8125ABC(float *a1);
void __cdecl sub_8125B14(int a1);
signed int __cdecl sub_8125B30(float *a1);
signed int sub_8125C78();
_BYTE **__cdecl sub_8125C82(char *a1, int *a2);
_DWORD *__cdecl sub_8125CB8(_DWORD *a1);
int __cdecl sub_8125CD4(_DWORD *a1);
int __cdecl sub_8125D08(_DWORD *a1);
int __cdecl sub_8125D3C(char *a1);
int sub_8125D70();
void __cdecl sub_8125D7A(int a1);
signed int __cdecl sub_8125DBE(int a1);
int __cdecl sub_8126034(int a1, int a2, float *a3);
int __cdecl sub_81265F4(int a1);
signed int sub_8126652();
int __cdecl sub_812665C(int a1, int *a2);
_DWORD *__cdecl sub_812677E(_DWORD *a1);
_DWORD *__cdecl sub_812679A(_DWORD *a1);
int __cdecl sub_81267B6(_DWORD *a1);
int __cdecl sub_81267EA(_DWORD *a1);
int __cdecl sub_812681E(char *a1);
void __cdecl sub_8126852(int a1, int a2);
int __cdecl sub_81268CA(int a1);
void __cdecl sub_8126908(_DWORD *a1);
signed int __cdecl sub_8126952(int a1);
void __cdecl sub_81269F8(int a1);
int __cdecl sub_8126A7C(int a1);
signed int sub_8126AFA();
_BYTE **__cdecl sub_8126B04(int a1, int *a2);
int __cdecl sub_8126BA8(_DWORD *a1, _DWORD *a2);
signed int __cdecl sub_8126C0A(int a1);
int __cdecl sub_8126C40(int a1);
void __cdecl sub_8126D3C(int a1);
signed int sub_8126E24();
_BYTE **__cdecl sub_8126E2E(int a1, int *a2);
_DWORD *__cdecl sub_8126E48(int a1, int a2);
long double __cdecl sub_8126F5E(float a1);
int __cdecl sub_8126F78(float, float); // idb
int __cdecl sub_8126F9C(int a1, int a2);
long double __cdecl sub_8126FC2(float a1, float a2, float a3);
int __cdecl sub_8127000(int a1, int a2, int a3);
long double __cdecl sub_8127042(float a1, float a2, float a3);
int __cdecl sub_8127084(float); // idb
int __cdecl sub_81270BA(_DWORD *a1);
int __cdecl sub_81270E4(_DWORD *a1, int a2, int a3, int a4);
int __cdecl sub_8127108(_DWORD *a1, _DWORD *a2);
int __cdecl sub_8127138(_DWORD *a1, _DWORD *a2);
int __cdecl sub_8127166(float *a1, float *a2, float *a3);
int __cdecl sub_81271AA(float *a1, float *a2, float *a3);
int __cdecl sub_81271EE(int, float, int); // idb
int __cdecl sub_8127226(int, float, int, int); // idb
long double __cdecl sub_812727A(float *a1, float *a2);
signed int __cdecl sub_81272AE(float *a1, float *a2);
long double __cdecl sub_8127318(float *a1);
double __cdecl sub_812734C(_DWORD); // weak
int __cdecl sub_812738A(float *a1, _BYTE *a2);
long double __cdecl sub_8127490(float a1, float a2, float a3);
long double __cdecl sub_81274BA(float a1);
int __cdecl sub_81274DA(int a1, int a2, int a3);
int __cdecl sub_81274FA(int a1, int a2);
int __cdecl sub_8127520(int, int, float, int); // idb
_DWORD *ctor_001();
long double __cdecl sub_81275A6(int a1, float a2);
int __cdecl sub_81275C6(int, int, float); // idb
long double __cdecl sub_8127604(int a1, int a2, float a3, float a4);
int __cdecl sub_8127650(int, int, float, int, float); // idb
long double __cdecl sub_81276E0(int a1, float a2);
long double __cdecl sub_8127702(int a1, int a2, float a3, float a4);
void *__cdecl sub_8127752(int a1);
int __cdecl sub_812776E(char *a1);
_DWORD *__cdecl sub_812778A(_DWORD *a1);
_DWORD *__cdecl sub_8127798(_DWORD *a1, _DWORD *a2);
int __cdecl sub_81277B6(int *a1);
_DWORD *__cdecl sub_81277D4(int *a1, _DWORD *a2);
_BOOL4 __cdecl sub_812782E(_DWORD *a1);
_DWORD *__cdecl sub_8127840(int *a1, _DWORD *a2);
int __cdecl sub_812787E(int a1);
long double sub_8127888();
void sub_8127890();
int __cdecl sub_8127896(int a1);
int __cdecl sub_81278B0(char *a1);
int __cdecl sub_81278CC(char *a1);
int __cdecl sub_81278E8(_DWORD *a1);
int __cdecl sub_812791C(char *a1);
int sub_8127950();
int __cdecl sub_812795A(char *a1);
int __cdecl sub_8127976(char *a1);
int __cdecl sub_8127992(char *a1);
int __cdecl sub_81279AE(char *a1);
int __cdecl sub_81279CA(char *a1);
int __cdecl sub_81279E6(char *a1);
float *__cdecl sub_8127A02(float *a1);
int __cdecl sub_8127A2E(char *a1);
int __cdecl sub_8127A4A(int a1);
int __cdecl sub_8127A56(int *a1);
int sub_8127A7C(int *a1, ...);
_BYTE **__cdecl sub_8127A9E(int a1, char *a2);
_BYTE **__cdecl sub_8127AC0(int a1, char *a2);
_BYTE **__cdecl sub_8127AE2(int a1, char *a2);
_BYTE **__cdecl sub_8127B04(int a1, char *a2);
_DWORD *__cdecl sub_8127B26(_DWORD *a1);
_DWORD *__cdecl sub_8127B3E(_DWORD *a1);
_DWORD *__cdecl sub_8127B56(_DWORD *a1);
_DWORD *__cdecl sub_8127B6E(_DWORD *a1);
_DWORD *__cdecl sub_8127B86(_DWORD *a1);
_DWORD *__cdecl sub_8127B9E(_DWORD *a1);
_DWORD *__cdecl sub_8127BB6(_DWORD *a1);
_DWORD *__cdecl sub_8127BCE(_DWORD *a1);
_DWORD *__cdecl sub_8127BE6(_DWORD *a1);
_DWORD *__cdecl sub_8127BFE(_DWORD *a1);
long double __cdecl sub_8127C16(int a1, float a2);
int __cdecl sub_8127C62(int, int, float); // idb
_DWORD *__cdecl sub_8127CAA(_DWORD *a1);
void *__cdecl sub_8127CB8(int *a1, int a2);
int __cdecl sub_8127D96(int a1, int a2);
int __cdecl sub_8127DDE(int *a1, char *a2);
int __cdecl sub_8127E76(int *a1, char *a2);
int __cdecl sub_8127F0E(int *a1, char *a2);
int __cdecl sub_8127FA6(int *a1, char *a2);
int __cdecl sub_812803E(int *a1, char *a2);
int __cdecl sub_81280D6(int *a1, char *a2);
int __cdecl sub_812816E(int *a1, char *a2);
int __cdecl sub_8128206(int *a1, char *a2);
int __cdecl sub_812829E(int *a1, char *a2);
int __cdecl sub_8128336(int *a1, char *a2);
int __cdecl sub_81283CE(int, float, int); // idb
void __cdecl sub_8128426(int a1, float a2);
int __cdecl sub_81284AE(int a1, int a2);
int __cdecl sub_81284F6(int a1, int a2);
int __cdecl sub_812853E(int a1, int a2);
int __cdecl sub_8128586(int a1, int a2);
int __cdecl sub_81285CE(int a1, int a2);
int __cdecl sub_8128616(int a1, int a2);
int __cdecl sub_812865E(int a1, int a2);
int __cdecl sub_81286A6(int a1, int a2);
int __cdecl sub_81286EE(int a1, int a2);
int __cdecl sub_812873E(int a1);
// _DWORD *__userpurge sub_812875E@<eax>(_DWORD *a1, int a2);
int __cdecl sub_81287D0(int a1);
int __cdecl sub_81287EA(int a1, char a2, int a3);
void sub_8128844();
void __cdecl sub_8128858(int *a1, _DWORD *a2, float *a3);
void __cdecl sub_8128900(int *a1, _DWORD *a2, float *a3, _DWORD *a4);
void __cdecl sub_8128962(int *a1, _DWORD *a2, float *a3, _DWORD *a4, _DWORD *a5);
signed int __cdecl sub_81289D8(int a1, float *a2);
void __cdecl sub_8128ACC(int *a1, _DWORD *a2, float *a3, _DWORD *a4, _DWORD *a5);
long double __cdecl sub_8128E8A(int a1, int a2);
int __cdecl sub_8128EFA(int a1, int a2, int a3);
void __cdecl sub_8128FA2(int a1, int a2);
long double __cdecl sub_812905E(int a1, int a2);
void sub_8129104();
_BOOL4 __cdecl sub_812910A(int a1, _DWORD *a2, int *a3);
int __cdecl sub_81291DE(int a1, float *a2, int a3);
void __cdecl sub_8129250(int *a1, float *a2, float *a3, signed int a4, int a5);
int __cdecl sub_8129488(int a1, int a2, int a3, _DWORD *a4, float *a5, _DWORD *a6, signed int a7, int a8);
int *__cdecl sub_8129558(int a1, int *a2);
_BYTE **__cdecl sub_812966C(int a1, int a2);
void sub_8129736();
const char **__cdecl sub_8129746(char *s2);
signed int __cdecl sub_81297A0(int a1);
void *__cdecl sub_81297F2(char *s2);
int __cdecl sub_81298BC(int a1);
_DWORD *__cdecl sub_812993E(int a1, int a2);
long double __cdecl sub_812997C(float a1);
long double __cdecl sub_8129996(float a1, float a2, float a3);
int __cdecl sub_81299D8(_DWORD *a1);
int __cdecl sub_8129A02(_DWORD *a1, int a2, int a3, int a4);
int __cdecl sub_8129A26(_DWORD *a1, _DWORD *a2);
_DWORD *ctor_002();
_DWORD *__cdecl sub_8129BAC(int a1);
int __cdecl sub_8129BC2(int a1);
void *__cdecl sub_8129BD8(int a1);
int __cdecl sub_8129BF4(char *a1);
_DWORD *__cdecl sub_8129C10(_DWORD *a1);
_DWORD *__cdecl sub_8129C28(_DWORD *a1);
void *__cdecl sub_8129C40(int *a1, int a2);
int __cdecl sub_8129D1E(int a1, int a2);
int __cdecl sub_8129D66(int *a1, char *a2);
void *__cdecl sub_8129E00(size_t n);
int __cdecl sub_8129E1C(int a1);
signed int __cdecl sub_8129E52(int a1, int a2);
void *sub_8129F2C();
void *__cdecl sub_8129F6A(_BYTE *a1);
void __cdecl sub_812A004(int a1, int a2);
_BOOL4 __cdecl sub_812A03C(int a1);
signed int __cdecl sub_812A074(int a1);
char **__cdecl sub_812A0D2(int a1, char *s);
int __cdecl sub_812A418(int a1);
int __cdecl sub_812A452(int a1, int a2);
int __cdecl sub_812A50C(int a1, int a2);
_BYTE *__cdecl sub_812A52C(_BYTE *a1, _BYTE *a2);
signed int __cdecl sub_812A552(_BYTE *a1, _BYTE *a2, int a3);
int __cdecl sub_812A5EA(int a1);
int __cdecl sub_812A5F4(int a1);
int __cdecl sub_812A600(int a1);
int __cdecl sub_812A60C(int a1);
_DWORD *__cdecl sub_812A642(_DWORD *a1);
_DWORD *__cdecl sub_812A670(_DWORD *a1);
signed int __cdecl sub_812A6B4(_DWORD *a1, int a2);
int __cdecl sub_812A776(int *a1, int a2);
void __cdecl sub_812A882(int a1, int a2, float a3);
void __cdecl sub_812AAD2(int a1, int a2, float a3);
signed int __cdecl sub_812AB74(int a1, float *a2, float a3, int a4);
signed int __cdecl sub_812ABF4(int a1, float *a2, float a3);
signed int __cdecl sub_812AC82(int a1, float *a2, float *a3, float a4, float a5, int a6);
int __cdecl sub_812AD4E(int, void *s, int, int, int, int, int, int); // idb
void sub_812ADC0();
int __cdecl sub_812ADC6(int a1, int a2);
int sub_812ADD4();
int __cdecl sub_812ADDE(int a1, int a2);
int sub_812AE52();
int sub_812AE5C();
void sub_812AE66();
void sub_812AE72();
int __cdecl sub_812AE78(int a1);
void __cdecl sub_812AEA8(float a1, int a2, int a3);
int __cdecl sub_812AED6(_DWORD *a1, _DWORD *a2);
unsigned int __cdecl sub_812AF06(_DWORD *a1, unsigned int *a2);
int __cdecl sub_812AF44(int, float, int); // idb
int __cdecl sub_812AF7C(int, float, int, int); // idb
long double __cdecl sub_812AFD0(float *a1, float *a2);
int __cdecl sub_812B004(_DWORD *a1);
int __cdecl sub_812B566(int a1);
int *__cdecl sub_812B5B6(int a1, void *s);
int *__cdecl sub_812B68C(int a1, int a2);
int __cdecl sub_812B73A(int, char *s, int, int); // idb
int __cdecl sub_812B7A4(int, char *s, int, int); // idb
int __cdecl sub_812B850(int, char *s, int); // idb
int __cdecl sub_812BA42(int, char *s); // idb
int __cdecl sub_812BAAE(int, char *s); // idb
int __cdecl sub_812BB1A(int, char *s); // idb
int __cdecl sub_812BB76(int, char *s); // idb
int __cdecl sub_812BBEC(int, char *s); // idb
int __cdecl sub_812BC48(int, char *s); // idb
int __cdecl sub_812BCA4(int, char *s); // idb
int __cdecl sub_812BD9A(int, char *s); // idb
int __cdecl sub_812BE34(int, char *s); // idb
int __cdecl sub_812BECE(int, char *s); // idb
int __cdecl sub_812BF2C(int, char *s); // idb
int __cdecl sub_812BF8A(int, char *s); // idb
int __cdecl sub_812BFE8(int, char *s); // idb
long double __cdecl sub_812C046(int a1, float a2, float a3);
int __cdecl sub_812C07A(int, int, float, float, int, int); // idb
int __cdecl sub_812C1E6(int, float, float, int, int); // idb
int __cdecl sub_812C294(int, float, float, float, int, int); // idb
int __cdecl sub_812C354(int, char *s); // idb
int __cdecl sub_812C46E(int, char *s); // idb
int __cdecl sub_812C508(int, char *s); // idb
int __cdecl sub_812C5A2(int, char *s); // idb
int __cdecl sub_812C812(int, char *s2, int, int); // idb
int __cdecl sub_812C8A0(int, char *s, int, int); // idb
int __cdecl sub_812C978(int, char *s); // idb
int __cdecl sub_812C9A6(int, char *s); // idb
int __cdecl sub_812C9D4(int, char *s); // idb
int __cdecl sub_812CC8A(int, char *s); // idb
int __cdecl sub_812CCE8(int, char *s); // idb
int __cdecl sub_812CD46(int, char *s); // idb
int __cdecl sub_812CDA4(int, char *nptr); // idb
_BOOL4 __cdecl sub_812CDE8(int a1, char *nptr);
int __cdecl sub_812CE28(int, char *nptr); // idb
_BOOL4 __cdecl sub_812CE6C(int a1, char *nptr);
int __cdecl sub_812CEB4(int, char *nptr); // idb
_BOOL4 __cdecl sub_812CEF8(int a1, char *nptr);
int __cdecl sub_812CF38(int, char *nptr); // idb
int __cdecl sub_812CF7C(int, int, char *s, int); // idb
int __cdecl sub_812D010(int, int, char *s, int); // idb
int __cdecl sub_812D0A8(int, int, char *s, int); // idb
int __cdecl sub_812D13C(int, int, char *s, int); // idb
int __cdecl sub_812D1D2(int, int, char *s, int); // idb
int __cdecl sub_812D246(int, int, char *s, int); // idb
signed int __cdecl sub_812D2B4(int a1, int a2);
signed int __cdecl sub_812D392(int a1, int a2);
signed int __cdecl sub_812D4A0(int a1, int a2);
signed int __cdecl sub_812D5BC(int a1, int a2);
signed int __cdecl sub_812D6D8(int a1, int a2);
signed int __cdecl sub_812D7F4(int a1, int a2);
void __cdecl sub_812D8FC(int a1, int a2, int a3);
void __cdecl sub_812DA14(int a1, int a2, int a3);
int __cdecl sub_812DB0C(int, char *s, int); // idb
signed int __cdecl sub_812DB62(int a1, int a2, int a3, int a4);
int __cdecl sub_812DDDE(int, char *src); // idb
int __cdecl sub_812DE08(char *dest, void *s, int); // idb
int __cdecl sub_812F060(char *dest, int); // idb
void sub_812F0A2(char *format, ...);
int sub_812F0DE();
int __cdecl sub_812F0E8(char *s1); // idb
int __cdecl sub_812F15A(_DWORD *a1, int a2, int a3);
long double __cdecl sub_812F170(float *a1);
long double __cdecl sub_812F1B8(int a1, float a2);
int __cdecl sub_812F1D0(float, float); // idb
long double __cdecl sub_812F1F4(float a1, float a2, float a3);
int __cdecl sub_812F232(_DWORD *a1, _DWORD *a2);
signed int __cdecl sub_812F262(float *a1, float *a2);
long double __cdecl sub_812F2CC(float a1, float a2, float a3);
int __cdecl sub_812F2F6(int *a1, int *a2);
int __cdecl sub_812F318(int a1);
int __cdecl sub_812F324(int a1);
int __cdecl sub_812F330(int a1);
int __cdecl sub_812F33C(int a1);
void sub_812F348();
void sub_812F34E();
int __cdecl sub_812F386(int a1, int a2);
void __cdecl sub_812F3CC(_DWORD *a1, float *a2);
void __cdecl sub_812F3F0(_DWORD *a1, float *a2, _DWORD *a3);
void __cdecl sub_812F41A(_DWORD *a1, float *a2, _DWORD *a3, _DWORD *a4);
void __cdecl sub_812F44C(_DWORD *a1, float *a2, _DWORD *a3, _DWORD *a4);
signed int __cdecl sub_812F47E(char a1);
int sub_812F498();
int sub_812F4AC();
void __cdecl sub_812F4C0(int a1, float a2);
int __cdecl sub_812F4EE(int a1);
int __cdecl sub_812F528(int a1);
double __cdecl sub_812F544(_DWORD); // weak
char *__cdecl sub_812F560(char **a1, char a2, char a3);
void *__cdecl sub_812F7FC(_DWORD *a1, int a2);
void *__cdecl sub_812F83A(_DWORD *a1, int a2);
void __cdecl sub_812F878(void **a1);
void __cdecl sub_812F88E(void **a1);
int __cdecl sub_812F8A4(int, char *s, int, int); // idb
void __cdecl sub_812F9F8(void **a1);
_DWORD *__cdecl sub_812FA42(_DWORD *a1, int a2);
_DWORD *__cdecl sub_812FA6E(_DWORD *a1, int a2);
int __cdecl sub_812FA9A(int, int, char *s); // idb
int __cdecl sub_812FB56(int, int, char *s); // idb
int __cdecl sub_812FB9A(int, int, char *s); // idb
int __cdecl sub_812FBDE(int a1);
int __cdecl sub_812FC1C(int a1);
void *__cdecl sub_812FC5A(int a1, int *a2);
_BOOL4 __cdecl sub_812FD7E(int a1);
int __cdecl sub_812FDB4(int a1);
int __cdecl sub_812FDE2(int, char *s, int); // idb
signed int __cdecl sub_812FEC2(int a1, char **a2, int *a3);
signed int __cdecl sub_812FF62(int a1, int *a2, int a3);
int __cdecl sub_813025C(int a1, int a2, int a3);
int __cdecl sub_81302C2(int a1);
int __cdecl sub_81302D6(int a1);
int __cdecl sub_8130352(int a1);
int *__cdecl sub_8130452(int a1, int *a2);
int __cdecl sub_813055A(int a1, int a2, int *a3, int *a4, int *a5);
void *__cdecl sub_8130652(int a1, char *s, char *a3, int a4);
int __cdecl sub_8130726(int *a1, int a2);
void *__cdecl sub_813075E(int a1, char *s, int a3);
int __cdecl sub_81307D4(int *a1, int a2);
int __cdecl sub_813080C(int, char *s1); // idb
signed int __cdecl sub_8130866(int a1, char **a2, int *a3);
signed int __cdecl sub_8130A3A(int a1, int *a2, int a3);
int __cdecl sub_8130C0A(int, char *s2); // idb
int __cdecl sub_8130C66(int, char *s2, int); // idb
int __cdecl sub_8130CD6(int a1);
int __cdecl sub_8130D0A(int a1);
int __cdecl sub_8130D4E(int a1);
int __cdecl sub_8130D92(int a1, char **a2, char a3, unsigned __int8 a4);
int __cdecl sub_8130E6E(int a1);
int sub_8130E9A(int a1, ...);
int __cdecl sub_8130EC0(int a1);
int __cdecl sub_8130ECC(int a1, int a2);
void *__cdecl sub_8130EDA(size_t size);
void __cdecl sub_8130EEE(void *ptr);
int __cdecl sub_8130F02(int a1, int a2);
int __cdecl sub_8130F10(int a1);
int __cdecl sub_8130F1C(int a1, int a2);
int __cdecl sub_8130F2A(int a1, int a2);
void *__cdecl sub_8130F38(size_t size);
void __cdecl sub_8130F4C(void *ptr);
int __cdecl sub_8130F60(int a1, unsigned __int8 a2);
int __cdecl sub_8130F78(int a1, unsigned __int8 a2);
size_t __cdecl sub_8130F90(float *a1);
void *__cdecl sub_8131042(void *a1);
int sub_8131180();
int __cdecl sub_813127A(char a1);
int sub_81312E4();
int sub_813130E();
void sub_8131328();
signed int __cdecl sub_8131338(char a1);
int __cdecl sub_813142A(_DWORD *a1, char a2);
int __cdecl sub_8131468(int a1, char a2);
int __cdecl sub_81314B8(int a1, char a2);
void sub_8131508();
char *sub_813150E();
char *sub_813155A();
long double __cdecl sub_81315A6(float *a1, float *a2);
int sub_8131708();
long double __cdecl sub_81317D0(float *a1, float *a2);
int sub_8131926();
int sub_81319C4();
int __cdecl sub_8131A62(int a1);
int __cdecl sub_8131B58(_DWORD *a1, int *a2);
int __cdecl sub_8131BB6(int a1);
int __cdecl sub_8131CA6(int a1, int a2);
int __cdecl sub_8131CD8(int a1);
int sub_81321D6(const void *, const void *); // idb
int sub_81322B8(const void *, const void *); // idb
void __cdecl sub_81322F4(void *a1, size_t nmemb);
int sub_81323E6();
int sub_81324A6();
int __cdecl sub_8132566(int a1);
int sub_813261C();
int __cdecl sub_81326C8(int a1);
int sub_813277E();
void sub_8132838();
float *__cdecl sub_8132948(int a1, float *a2, float *a3, float *a4);
void __cdecl sub_8132E4E(int a1, int a2, float *a3, float *a4, int a5);
int __cdecl sub_8133120(int a1, int a2, int a3, signed int a4);
signed int __cdecl sub_8133176(int *a1, _DWORD *a2, float *a3);
int __cdecl sub_8133348(int a1);
int __cdecl sub_813338E(int a1, int a2, signed int a3, int a4);
int __cdecl sub_813350E(int a1, _DWORD *a2, float *a3, float *a4, float *a5);
signed int __cdecl sub_81337F2(int *a1, float *a2, float *a3, signed int a4, int a5);
_DWORD *__cdecl sub_813392A(int *a1, float *a2, float *a3);
void __cdecl sub_8133C04(int *a1, float *a2, float *a3, signed int a4, int a5);
signed int __cdecl sub_8133D9E(int *a1, float *a2, float *a3, int a4, int a5);
float *__cdecl sub_8133F44(int *a1, float *a2, float *a3, signed int a4);
void __cdecl sub_813431A(int a1, float *a2, float *a3);
void __cdecl sub_8134368(int a1, float *a2, float *a3);
void __cdecl sub_8134432(int a1, float *a2, float *a3);
signed int __cdecl sub_81344EE(int *a1, float *a2, float *a3);
signed int __cdecl sub_8134642(int *a1, float *a2, float *a3, signed int a4, int a5);
signed int __cdecl sub_81347FC(int *a1, int a2, float *a3);
signed int __cdecl sub_813493C(int *a1, float *a2, float *a3, signed int a4, int a5);
int sub_8134AAE();
int sub_8134C2A();
int sub_8134C64();
void sub_8134C9E();
int *__cdecl sub_8134D0C(int a1, int a2);
long double __cdecl sub_8134D5C(float a1);
void __cdecl sub_8134D76(float a1, int a2, int a3);
int __cdecl sub_8134DA4(_DWORD *a1, int a2, int a3, int a4);
int __cdecl sub_8134DC8(_DWORD *a1, _DWORD *a2);
int __cdecl sub_8134DF8(float *a1, float *a2, float *a3);
int __cdecl sub_8134E3C(float *a1, float *a2, float *a3);
int __cdecl sub_8134E80(int, float, int); // idb
int __cdecl sub_8134EB8(int, float, int, int); // idb
long double __cdecl sub_8134F0C(float *a1, float *a2);
double __cdecl sub_8134F40(_DWORD); // weak
int __cdecl sub_8134F7E(int a1, int a2);
int __cdecl sub_8134FDC(int a1, int a2);
long double __cdecl sub_813503A(float a1);
int __cdecl sub_813505A(_DWORD *a1);
int __cdecl sub_8135084(_DWORD *a1, _DWORD *a2);
int *ctor_003();
int __cdecl sub_81350CE(int a1, int a2);
int __cdecl sub_81350EA(int a1, _DWORD *a2);
int __cdecl sub_813511E(int a1, _DWORD *a2);
int __cdecl sub_8135152(int a1, _DWORD *a2);
int __cdecl sub_8135186(int a1, int a2);
int __cdecl sub_8135198(int a1, int a2);
int __cdecl sub_81351A6(int a1, int a2);
int __cdecl sub_81351B4(int a1, int a2);
int __cdecl sub_81351C2(int a1, int a2);
int __cdecl sub_81351D0(int a1, int a2);
int __cdecl sub_81351DE(int a1);
int __cdecl sub_81351EC(int a1);
int __cdecl sub_81351F8(int a1);
int __cdecl sub_8135204(int a1, int a2);
int __cdecl sub_8135216(int a1, int a2);
void *__cdecl sub_8135228(int a1);
_DWORD *__cdecl sub_8135244(_DWORD *a1);
int __cdecl sub_8135260(int a1, int a2);
int __cdecl sub_813526E(int a1, int a2);
int __cdecl sub_813527C(int a1, int a2);
int __cdecl sub_813528E(int a1, int a2);
int __cdecl sub_813529C(int a1, int a2);
int __cdecl sub_81352AE(int a1, unsigned __int8 a2);
int __cdecl sub_81352CA(int a1, int a2);
int __cdecl sub_81352DC(int a1, int a2);
int __cdecl sub_81352EE(int a1, int a2);
int __cdecl sub_8135300(int a1, int a2);
int __cdecl sub_8135312(int a1, int a2);
int __cdecl sub_8135324(int a1, int a2);
int __cdecl sub_8135336(int a1, int a2);
int __cdecl sub_8135348(int a1, int a2);
int __cdecl sub_813535A(int a1, int a2);
int __cdecl sub_813536C(int a1, int a2);
void *__cdecl sub_813537E(int a1);
void *__cdecl sub_813539A(int a1);
int __cdecl sub_81353B6(int a1, _DWORD *a2);
void *__cdecl sub_81353D6(int a1);
int __cdecl sub_81353F2(int a1, _DWORD *a2);
void *__cdecl sub_8135412(int a1);
int __cdecl sub_813542E(int a1, _DWORD *a2);
void *__cdecl sub_813544E(int a1);
int __cdecl sub_813546A(int a1, _DWORD *a2);
void *__cdecl sub_8135488(int a1);
int __cdecl sub_81354A4(int a1, int a2);
int __cdecl sub_81354B6(int a1, _DWORD *a2);
int __cdecl sub_81354D6(int a1, _DWORD *a2);
int __cdecl sub_81354F6(int a1, int a2);
int __cdecl sub_8135508(int a1, int a2);
int __cdecl sub_813551A(int a1, int a2);
int __cdecl sub_813552C(int a1, int a2);
int __cdecl sub_813553E(int a1, _DWORD *a2);
int __cdecl sub_813555E(int a1, _DWORD *a2);
int __cdecl sub_813557E(int a1, _DWORD *a2);
void *__cdecl sub_813559E(int a1);
int __cdecl sub_81355BA(int a1);
void *sub_81355C8();
void __cdecl sub_81355DC(void *ptr);
void *__cdecl sub_81355F0(int *a1, int a2);
void *__cdecl sub_81356CE(int *a1, int a2);
void *__cdecl sub_81357AC(int *a1, int a2);
void *__cdecl sub_813588A(int *a1, int a2);
void *__cdecl sub_8135968(int *a1, int a2);
void *__cdecl sub_8135A46(int *a1, int a2);
void *__cdecl sub_8135B24(int *a1, int a2);
void *__cdecl sub_8135C02(int *a1, int a2);
unsigned int Language_UpdateCurrentAsian();
int sub_8135D0C();
// unsigned int __usercall SEH_InitLanguage@<eax>(long double a1@<st0>);
// unsigned int __usercall SEH_UpdateLanguageInfo@<eax>(long double a1@<st0>);
int sub_8135FAE();
void sub_8135FBC();
signed int __cdecl SEH_StringEd_SetLanguageStrings(signed int a1);
int __cdecl sub_813608C(_BYTE *a1);
char *__cdecl sub_81360E2(char *src);
int __cdecl sub_81361BE(char *dest, int a2, int a3, int a4);
int __cdecl sub_81362A4(char *a1, int a2, int a3);
_BOOL4 __cdecl sub_81367A0(__int16 a1);
_BOOL4 __cdecl sub_8136800(unsigned int a1);
_BOOL4 __cdecl sub_813688A(unsigned __int8 a1, unsigned __int8 a2);
_BOOL4 __cdecl sub_81368E6(unsigned int a1);
signed int __cdecl sub_8136980(unsigned __int8 a1, unsigned __int8 a2);
_BOOL4 __cdecl sub_81369BE(unsigned int a1);
int __cdecl sub_8136A38(unsigned __int8 **a1, signed int *a2);
int Language_IsAsian();
int __cdecl sub_8136CE6(_BYTE *a1);
char *__cdecl sub_8136D72(signed int a1);
signed int __cdecl sub_8136DA2(char *a1, signed int *a2);
signed int __cdecl sub_8136E02(unsigned __int8 a1, unsigned __int8 a2);
int __cdecl sub_8136E40(__int16 a1);
int __cdecl sub_8136E64(__int16 a1);
int __cdecl sub_8136E88(__int16 a1);
int __cdecl sub_8136EAC(_BYTE *a1);
void __cdecl sub_8136EE2(void *a1);
void __cdecl sub_8136EF6(char *a1, int a2, int a3);
int __cdecl sub_813707E(int a1, int a2);
int __cdecl sub_81370C4(_DWORD *a1);
char *__cdecl sub_8137110(int a1, char *src);
char *__cdecl sub_813718C(int a1, char *src);
char *__cdecl sub_813722A(int a1, char *a2);
char *__cdecl sub_813727A(int a1, char *src);
int __cdecl sub_81372A4(int, char *src); // idb
int __cdecl sub_81372FC(int, char *s, int); // idb
int __cdecl sub_8137378(int, char *haystack); // idb
std::string *__stdcall sub_8137430(std::string *a1, int a2, int a3);
char *__cdecl sub_81374D8(int a1, char *a2);
int __cdecl sub_81375AC(int, int, char *dest); // idb
std::string *__stdcall sub_81376E8(std::string *a1, int a2, _BYTE *a3);
char *__cdecl sub_813785C(int a1, char *s2, int a3);
int __cdecl sub_8137CD2(int a1);
int __cdecl sub_8137CE8(int a1, int a2);
int __cdecl sub_8137EEC(int, int, char *s1, int); // idb
char *__cdecl sub_813803A(std::string *a1);
char *__cdecl sub_81380F6(char *src, int a2);
int __cdecl sub_813821E(int a1);
int sub_8138320();
int sub_8138336();
void sub_813839E();
char *__cdecl sub_81383EC(unsigned __int8 a1);
_BOOL4 __cdecl sub_8138490(_DWORD *a1, _DWORD *a2);
// int *__userpurge sub_81384A6@<eax>(int *a1, int a2, std::string *a3);
// _DWORD *__userpurge sub_81384D2@<eax>(_DWORD *a1, int a2);
int __cdecl sub_81384F8(int, std::string *); // idb
int __cdecl sub_8138676(_DWORD *a1);
_BOOL4 __cdecl sub_813868A(_DWORD *a1, _DWORD *a2);
// int *__userpurge sub_81386A0@<eax>(int *a1, int a2, int *a3, std::string *a4);
char *__cdecl sub_81386E6(char *s, int c);
char *__cdecl sub_8138700(char *s, int c);
char *__cdecl sub_813871A(char *haystack, char *needle);
int __cdecl sub_8138734(int a1);
int __cdecl sub_81387C6(int a1);
void *sub_8138860();
void __cdecl sub_8138874(void *ptr);
int __cdecl sub_8138888(int a1);
int __cdecl sub_8138892(int a1);
int __cdecl sub_81388A6(int a1);
int __cdecl sub_8138918(int a1);
int __cdecl sub_8138926(std::string *); // idb
void __cdecl sub_8138948(int a1, void *ptr);
int __cdecl sub_81389A0(int a1);
int __cdecl sub_81389AE(int a1);
int __cdecl sub_81389BC(int *a1, int *a2);
int __cdecl sub_81389DA(int a1);
void sub_8138A06();
int __cdecl sub_8138A0C(int a1);
void *__cdecl sub_8138A3C(int a1);
int __cdecl sub_8138A6C(int a1);
void sub_8138A90();
void *__cdecl sub_8138A96(int a1);
void *__cdecl sub_8138AB2(int a1, int a2);
int __cdecl sub_8138ACE(int a1);
int __cdecl sub_8138B26(int a1);
int __cdecl sub_8138B2E(int a1);
void __cdecl sub_8138B3A(int a1, void *ptr);
int __cdecl sub_8138B62(int, std::string *, std::string *); // idb
int __cdecl sub_8138B80(std::string *, std::string *); // idb
// _DWORD *__userpurge sub_8138B9E@<eax>(_DWORD *a1, int a2);
// int *__userpurge sub_8138BC4@<eax>(int *a1, int a2, std::string *a3);
// _DWORD *__userpurge sub_8138CD6@<eax>(_DWORD *a1, int a2, std::string *a3);
// _DWORD *__userpurge sub_8138D02@<eax>(_DWORD *a1, int a2, std::string *a3);
int __cdecl sub_8138D96(_DWORD *a1);
int __stdcall sub_8138DA4(int a1);
int __stdcall sub_8138DCA(int a1);
int __cdecl sub_8138DD4(std::string *, std::string *, std::string *); // idb
// int *__userpurge sub_8138E2A@<eax>(int *a1, int a2, int *a3, std::string *a4);
// int __userpurge sub_81390FA@<eax>(int a1, int a2, std::string *a3);
int __cdecl sub_81392DC(int a1);
int __cdecl sub_81392F2(int a1);
void sub_81392FE();
int __cdecl sub_8139304(int a1);
void __cdecl sub_81393A2(int a1);
int __cdecl sub_81393B6(int a1);
void __cdecl sub_81393C2(int a1, void *ptr);
void __cdecl sub_81393E4(int a1, void *ptr);
void __cdecl sub_81393F8(int a1);
int __cdecl sub_813943C(std::string *); // idb
int __cdecl sub_8139450(int a1);
int __cdecl sub_8139472(int a1);
int __cdecl sub_813947E(int a1, int a2);
int __cdecl sub_8139486(_DWORD *a1, int a2);
int __cdecl sub_81394A2(int a1);
int __cdecl sub_81394C4(int a1, int a2);
int __cdecl sub_81394CC(int a1);
// _DWORD *__userpurge sub_81394D8@<eax>(_DWORD *a1, int a2, int a3, int a4, std::string *a5);
int __cdecl sub_8139676(int a1);
// _DWORD *__userpurge sub_8139682@<eax>(_DWORD *a1, int a2);
int __cdecl sub_81396B0(int a1, int *a2, unsigned __int8 *a3);
_DWORD *__cdecl sub_81396D6(_DWORD *a1, _DWORD *a2);
void __cdecl sub_813988E(int a1);
int __cdecl sub_81398AC(int, std::string *); // idb
std::string *__cdecl sub_8139920(int a1, std::string *a2);
int __cdecl sub_813999C(int a1, int a2);
void sub_81399A4();
int __cdecl sub_81399AA(int a1, _DWORD *a2);
int __cdecl sub_8139A36(int a1, _DWORD *a2);
int __cdecl sub_8139AC2(std::string *, std::string *); // idb
int sub_8139B20();
void term_proc(void); // idb

//-------------------------------------------------------------------------
// Data declarations

char byte_813A549 = '\0'; // idb
char aExeErrCouldntL_1[20] = "EXE_ERR_COULDNT_LOAD"; // idb
char aExeErrWrongMap[29] = "EXE_ERR_WRONG_MAP_VERSION_NUM"; // idb
char byte_813AE20 = '\x15'; // idb
char aExeErrCouldntL[20] = "EXE_ERR_COULDNT_LOAD"; // idb
char byte_813AEC0 = '\x15'; // idb
char byte_813AEE5 = '\x15'; // idb
char byte_813AF20 = '\x15'; // idb
char byte_813AF45 = '\x15'; // idb
char byte_813AF6C = '\x15'; // idb
char byte_813AFA0 = '\x15'; // idb
char byte_813AFE0 = '\x15'; // idb
char byte_813B020 = '\x15'; // idb
char byte_813B080 = '\x15'; // idb
char byte_813B0E0 = '\x15'; // idb
char byte_813B120 = '\x15'; // idb
char byte_813B141 = '\x15'; // idb
char byte_813B180 = '\x15'; // idb
char byte_813B1C0 = '\x15'; // idb
char byte_813B200 = '\x15'; // idb
char byte_813B260 = '\x15'; // idb
char byte_813B2A0 = '\x15'; // idb
char byte_813B2E0 = '\x15'; // idb
char byte_813B320 = '\x15'; // idb
char byte_813B360 = '\x15'; // idb
char byte_813B381 = '\x15'; // idb
char byte_813B3C0 = '\x15'; // idb
char byte_813B400 = '\x15'; // idb
char byte_813B440 = '\x15'; // idb
char byte_813B468 = '\x15'; // idb
char byte_813B4A0 = '\x15'; // idb
char byte_813B4E0 = '\x15'; // idb
char byte_813B520 = '\x15'; // idb
char byte_813B560 = '\x15'; // idb
char byte_813B5C0 = '\x15'; // idb
char byte_813B620 = '\x15'; // idb
char byte_813B680 = '\x15'; // idb
char byte_813B6E0 = '\x15'; // idb
char byte_813B740 = '\x15'; // idb
char aExeErrCouldntL_0[20] = "EXE_ERR_COULDNT_LOAD"; // idb
char byte_813B860 = '\x15'; // idb
char byte_813B8A0 = '\x15'; // idb
char byte_813B8E0 = '\x15'; // idb
char byte_813B920 = '\x15'; // idb
char byte_813B960 = '\x15'; // idb
char byte_813B980 = '\x15'; // idb
char byte_813B9C0 = '\x15'; // idb
char byte_813BA00 = '\x15'; // idb
char byte_813BB60 = '\x15'; // idb
_UNKNOWN unk_813BC6B; // weak
_UNKNOWN unk_813BDA4; // weak
char byte_813BF00 = '\x15'; // idb
char byte_813BF60 = '\x15'; // idb
char byte_813BF74 = '\x15'; // idb
char byte_813C2EC = '\x15'; // idb
char aSurialc[] = { 'S', '\0', 'U', '\0', 'R', '\0', 'I', '\0', 'A', '\0', 'L', '\0', 'C', '\0' }; // idb
char byte_813C8A0 = '\0'; // idb
_UNKNOWN unk_813CD62; // weak
char *off_813D120 = "pos.trTime"; // weak
char *off_813D460 = "absmin[1]"; // weak
char *off_813D8E0 = "team"; // weak
char *off_813DE80 = "commandTime"; // weak
_UNKNOWN unk_813E42E; // weak
char byte_813E560 = '\x15'; // idb
char byte_813E9E0 = '\x15'; // idb
char byte_813EA4D = '\x15'; // idb
char byte_813ED81 = '\x15'; // idb
_UNKNOWN unk_813F86C; // weak
char byte_813F960 = '\x15'; // idb
char byte_813FA00 = '\x15'; // idb
char byte_813FA40 = '\x15'; // idb
char byte_813FAC0 = '\x15'; // idb
char byte_81400D1 = '\x15'; // idb
char byte_81400F1 = '\x15'; // idb
char byte_814010C = '\x15'; // idb
char byte_8140128 = '\x15'; // idb
char byte_8140180 = '\x15'; // idb
char byte_8140CE0 = '\x15'; // idb
__int16 word_81410A0[256] =
{
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  94,
  92,
  1,
  4,
  33,
  92,
  92,
  89,
  32,
  19,
  11,
  12,
  30,
  28,
  37,
  29,
  38,
  31,
  35,
  40,
  42,
  22,
  41,
  23,
  39,
  90,
  13,
  14,
  18,
  90,
  90,
  90,
  90,
  90,
  90,
  90,
  90,
  90,
  90,
  90,
  90,
  90,
  90,
  90,
  90,
  9,
  17,
  10,
  34,
  3,
  3,
  4,
  21,
  0,
  7,
  0,
  88,
  0,
  0,
  0,
  66,
  0,
  16,
  59,
  64,
  55,
  62,
  56,
  63,
  36,
  0,
  87,
  6,
  5,
  65,
  0,
  35,
  0,
  71,
  26,
  24,
  20,
  25,
  27,
  90,
  0,
  58,
  90,
  90,
  90,
  90,
  90,
  90,
  90,
  90,
  90,
  90,
  51,
  90,
  90,
  90,
  90,
  90,
  90,
  90,
  90,
  90,
  90,
  90,
  57,
  15,
  2,
  0,
  0,
  0,
  0,
  8,
  0,
  0,
  5,
  0,
  36,
  60,
  61,
  91,
  90,
  90,
  90,
  90,
  90,
  90,
  90,
  90,
  54,
  90,
  90,
  90,
  90,
  90,
  90,
  90,
  90,
  90,
  90,
  90,
  90,
  0,
  0,
  0,
  0,
  91,
  50,
  90,
  77,
  90,
  90,
  52,
  90,
  90,
  49,
  90,
  90,
  90,
  90,
  47,
  90,
  90,
  83,
  90,
  44,
  90,
  0,
  0,
  0,
  67,
  79,
  90,
  90,
  81,
  82,
  48,
  90,
  90,
  90,
  90,
  90,
  90,
  90,
  53,
  0,
  0,
  0,
  90,
  90,
  90,
  75,
  90,
  90,
  43,
  76,
  45,
  90,
  90,
  0,
  0,
  0,
  90,
  90,
  78,
  90,
  90,
  90,
  90,
  0,
  70,
  0,
  90,
  80,
  90,
  86,
  90,
  72,
  69,
  0,
  90,
  90,
  46,
  90,
  90,
  0,
  84,
  85,
  90,
  90,
  0,
  90,
  90,
  0,
  90,
  90,
  0,
  90,
  73,
  0,
  90,
  68,
  90,
  74,
  0
}; // idb
char byte_81412A0[] = { '\0' }; // weak
char byte_81416A0[] = { '\0' }; // weak
__int16 word_81417A0[272] =
{
  0,
  427,
  426,
  0,
  0,
  56,
  57,
  428,
  431,
  431,
  425,
  404,
  56,
  45,
  431,
  403,
  58,
  431,
  431,
  402,
  51,
  431,
  50,
  48,
  64,
  71,
  404,
  431,
  53,
  400,
  56,
  431,
  393,
  431,
  431,
  398,
  54,
  43,
  60,
  55,
  65,
  71,
  72,
  73,
  66,
  78,
  80,
  83,
  84,
  85,
  86,
  89,
  431,
  93,
  431,
  431,
  431,
  402,
  416,
  431,
  113,
  431,
  0,
  431,
  373,
  372,
  367,
  431,
  117,
  431,
  431,
  431,
  431,
  431,
  431,
  431,
  107,
  374,
  431,
  431,
  0,
  431,
  395,
  113,
  122,
  431,
  390,
  431,
  431,
  431,
  389,
  382,
  0,
  431,
  98,
  106,
  115,
  116,
  118,
  119,
  122,
  120,
  123,
  125,
  381,
  124,
  128,
  126,
  130,
  131,
  136,
  133,
  137,
  146,
  138,
  144,
  431,
  431,
  431,
  368,
  373,
  366,
  164,
  431,
  0,
  351,
  0,
  386,
  385,
  431,
  431,
  374,
  154,
  157,
  155,
  158,
  162,
  160,
  165,
  167,
  373,
  170,
  172,
  171,
  175,
  173,
  176,
  177,
  181,
  186,
  188,
  190,
  191,
  357,
  357,
  354,
  361,
  368,
  367,
  193,
  366,
  192,
  197,
  365,
  199,
  200,
  364,
  202,
  201,
  209,
  203,
  363,
  207,
  214,
  362,
  217,
  220,
  221,
  340,
  338,
  349,
  431,
  224,
  223,
  230,
  358,
  357,
  356,
  225,
  227,
  231,
  234,
  233,
  236,
  237,
  355,
  335,
  346,
  349,
  238,
  243,
  246,
  351,
  251,
  252,
  350,
  349,
  348,
  253,
  256,
  339,
  338,
  341,
  254,
  263,
  344,
  262,
  257,
  273,
  260,
  335,
  431,
  326,
  261,
  341,
  275,
  340,
  276,
  279,
  431,
  327,
  278,
  280,
  338,
  282,
  285,
  318,
  329,
  323,
  286,
  284,
  291,
  291,
  292,
  292,
  295,
  293,
  302,
  300,
  307,
  250,
  297,
  431,
  302,
  228,
  431,
  341,
  345,
  349,
  351,
  355,
  359,
  198,
  361,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0
}; // idb
__int16 word_81419C0[272] =
{
  0,
  256,
  256,
  255,
  3,
  257,
  257,
  255,
  255,
  255,
  255,
  255,
  258,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  259,
  255,
  255,
  255,
  259,
  259,
  259,
  259,
  259,
  259,
  259,
  259,
  259,
  259,
  259,
  259,
  259,
  259,
  259,
  259,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  258,
  255,
  258,
  255,
  255,
  255,
  255,
  255,
  260,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  261,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  259,
  262,
  255,
  259,
  259,
  259,
  259,
  259,
  259,
  259,
  259,
  259,
  259,
  259,
  259,
  259,
  259,
  259,
  259,
  259,
  259,
  259,
  259,
  259,
  259,
  255,
  255,
  255,
  255,
  255,
  255,
  260,
  255,
  260,
  255,
  261,
  255,
  255,
  255,
  255,
  263,
  259,
  259,
  259,
  259,
  259,
  259,
  259,
  259,
  259,
  259,
  259,
  259,
  259,
  259,
  259,
  259,
  259,
  259,
  259,
  259,
  259,
  255,
  255,
  255,
  255,
  263,
  259,
  259,
  259,
  259,
  259,
  259,
  259,
  259,
  259,
  259,
  259,
  259,
  259,
  259,
  259,
  259,
  259,
  259,
  259,
  259,
  255,
  255,
  255,
  255,
  259,
  259,
  259,
  259,
  259,
  259,
  259,
  259,
  259,
  259,
  259,
  259,
  259,
  259,
  255,
  255,
  255,
  259,
  259,
  259,
  259,
  259,
  259,
  259,
  259,
  259,
  259,
  259,
  255,
  255,
  255,
  259,
  259,
  259,
  259,
  259,
  259,
  259,
  255,
  255,
  255,
  259,
  259,
  259,
  259,
  259,
  259,
  255,
  255,
  259,
  259,
  259,
  259,
  259,
  255,
  259,
  259,
  259,
  259,
  255,
  259,
  259,
  255,
  259,
  259,
  255,
  259,
  259,
  255,
  259,
  255,
  259,
  259,
  0,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0
}; // idb
__int16 word_8141BE0[496] =
{
  0,
  8,
  10,
  9,
  11,
  12,
  13,
  14,
  15,
  16,
  17,
  18,
  19,
  20,
  21,
  22,
  23,
  24,
  25,
  26,
  27,
  28,
  29,
  30,
  31,
  32,
  32,
  33,
  8,
  34,
  35,
  32,
  36,
  37,
  38,
  39,
  40,
  41,
  42,
  32,
  43,
  32,
  44,
  32,
  45,
  32,
  46,
  47,
  48,
  49,
  50,
  32,
  51,
  32,
  32,
  52,
  53,
  54,
  55,
  9,
  9,
  61,
  63,
  68,
  72,
  74,
  76,
  69,
  57,
  57,
  78,
  92,
  75,
  73,
  86,
  87,
  79,
  64,
  89,
  90,
  70,
  80,
  92,
  92,
  62,
  65,
  81,
  82,
  92,
  83,
  95,
  98,
  96,
  92,
  92,
  66,
  77,
  84,
  94,
  92,
  92,
  92,
  105,
  101,
  103,
  97,
  92,
  99,
  92,
  100,
  104,
  92,
  92,
  92,
  92,
  116,
  102,
  92,
  61,
  108,
  109,
  114,
  123,
  106,
  111,
  76,
  92,
  107,
  115,
  82,
  113,
  83,
  112,
  84,
  92,
  127,
  110,
  127,
  132,
  84,
  128,
  62,
  133,
  92,
  92,
  124,
  92,
  92,
  92,
  117,
  92,
  92,
  92,
  92,
  92,
  136,
  92,
  138,
  92,
  92,
  135,
  92,
  139,
  134,
  92,
  92,
  92,
  137,
  141,
  123,
  140,
  144,
  92,
  146,
  92,
  142,
  147,
  143,
  151,
  145,
  148,
  150,
  92,
  92,
  152,
  92,
  92,
  149,
  92,
  159,
  92,
  160,
  124,
  92,
  162,
  92,
  163,
  158,
  92,
  92,
  92,
  92,
  131,
  92,
  92,
  92,
  166,
  161,
  167,
  92,
  164,
  168,
  169,
  171,
  92,
  165,
  92,
  173,
  92,
  92,
  92,
  92,
  174,
  170,
  175,
  92,
  172,
  92,
  92,
  92,
  92,
  92,
  183,
  177,
  182,
  92,
  186,
  92,
  188,
  176,
  189,
  191,
  92,
  185,
  187,
  92,
  192,
  184,
  92,
  92,
  190,
  92,
  92,
  92,
  193,
  92,
  92,
  195,
  92,
  92,
  203,
  92,
  92,
  204,
  92,
  92,
  92,
  200,
  207,
  194,
  199,
  92,
  201,
  206,
  92,
  205,
  208,
  209,
  202,
  92,
  92,
  92,
  92,
  213,
  92,
  92,
  252,
  216,
  92,
  92,
  92,
  92,
  226,
  214,
  223,
  215,
  217,
  218,
  219,
  224,
  225,
  92,
  228,
  92,
  92,
  231,
  92,
  92,
  92,
  227,
  92,
  233,
  92,
  92,
  92,
  232,
  234,
  240,
  242,
  92,
  92,
  92,
  235,
  92,
  238,
  92,
  246,
  237,
  92,
  239,
  92,
  248,
  249,
  243,
  245,
  92,
  251,
  254,
  250,
  247,
  244,
  253,
  8,
  8,
  8,
  8,
  56,
  56,
  56,
  56,
  60,
  92,
  60,
  60,
  91,
  91,
  122,
  92,
  122,
  122,
  126,
  241,
  126,
  126,
  157,
  157,
  92,
  236,
  92,
  92,
  230,
  229,
  92,
  222,
  221,
  220,
  92,
  92,
  92,
  92,
  212,
  211,
  210,
  92,
  92,
  92,
  92,
  198,
  197,
  196,
  92,
  92,
  92,
  92,
  92,
  92,
  92,
  181,
  180,
  179,
  178,
  92,
  92,
  128,
  128,
  156,
  155,
  154,
  153,
  92,
  92,
  130,
  129,
  76,
  125,
  121,
  120,
  119,
  58,
  118,
  93,
  92,
  88,
  85,
  71,
  67,
  59,
  58,
  255,
  9,
  9,
  7,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  0,
  0,
  0,
  0,
  0,
  0
}; // idb
__int16 word_8141FC0[496] =
{
  0,
  3,
  3,
  3,
  3,
  3,
  3,
  3,
  3,
  3,
  3,
  3,
  3,
  3,
  3,
  3,
  3,
  3,
  3,
  3,
  3,
  3,
  3,
  3,
  3,
  3,
  3,
  3,
  3,
  3,
  3,
  3,
  3,
  3,
  3,
  3,
  3,
  3,
  3,
  3,
  3,
  3,
  3,
  3,
  3,
  3,
  3,
  3,
  3,
  3,
  3,
  3,
  3,
  3,
  3,
  3,
  3,
  3,
  3,
  5,
  6,
  12,
  13,
  16,
  20,
  22,
  23,
  16,
  5,
  6,
  24,
  37,
  22,
  20,
  28,
  28,
  24,
  13,
  30,
  30,
  16,
  24,
  36,
  39,
  12,
  13,
  24,
  25,
  38,
  25,
  37,
  39,
  38,
  40,
  44,
  13,
  23,
  25,
  36,
  41,
  42,
  43,
  44,
  41,
  42,
  38,
  45,
  40,
  46,
  40,
  43,
  47,
  48,
  49,
  50,
  53,
  41,
  51,
  60,
  47,
  48,
  51,
  68,
  45,
  49,
  76,
  94,
  46,
  51,
  83,
  50,
  83,
  49,
  76,
  95,
  84,
  48,
  84,
  94,
  83,
  84,
  60,
  95,
  96,
  97,
  68,
  98,
  99,
  101,
  53,
  100,
  102,
  105,
  103,
  107,
  98,
  106,
  100,
  108,
  109,
  97,
  111,
  101,
  96,
  110,
  112,
  114,
  99,
  103,
  122,
  102,
  107,
  115,
  109,
  113,
  105,
  110,
  106,
  114,
  108,
  111,
  113,
  132,
  134,
  115,
  133,
  135,
  112,
  137,
  133,
  136,
  134,
  122,
  138,
  136,
  139,
  137,
  132,
  141,
  143,
  142,
  145,
  262,
  144,
  146,
  147,
  141,
  135,
  142,
  148,
  138,
  143,
  144,
  146,
  149,
  139,
  150,
  148,
  151,
  152,
  161,
  159,
  149,
  145,
  150,
  162,
  147,
  164,
  165,
  168,
  167,
  170,
  161,
  152,
  159,
  172,
  165,
  169,
  168,
  151,
  169,
  172,
  173,
  164,
  167,
  175,
  173,
  162,
  176,
  177,
  170,
  183,
  182,
  188,
  175,
  189,
  254,
  177,
  184,
  190,
  189,
  192,
  191,
  189,
  193,
  194,
  199,
  183,
  192,
  176,
  182,
  200,
  184,
  191,
  201,
  190,
  193,
  194,
  188,
  203,
  204,
  208,
  213,
  199,
  209,
  217,
  250,
  203,
  219,
  223,
  216,
  214,
  217,
  200,
  213,
  201,
  204,
  208,
  209,
  214,
  216,
  218,
  219,
  225,
  227,
  223,
  231,
  228,
  232,
  218,
  234,
  227,
  240,
  235,
  239,
  225,
  228,
  235,
  239,
  242,
  243,
  246,
  228,
  245,
  232,
  251,
  243,
  231,
  248,
  234,
  253,
  245,
  246,
  240,
  242,
  249,
  248,
  253,
  247,
  244,
  241,
  251,
  256,
  256,
  256,
  256,
  257,
  257,
  257,
  257,
  258,
  238,
  258,
  258,
  259,
  259,
  260,
  237,
  260,
  260,
  261,
  236,
  261,
  261,
  263,
  263,
  233,
  230,
  226,
  224,
  222,
  220,
  215,
  212,
  211,
  210,
  207,
  206,
  205,
  202,
  198,
  197,
  196,
  195,
  187,
  186,
  185,
  180,
  179,
  178,
  174,
  171,
  166,
  163,
  160,
  158,
  157,
  156,
  155,
  154,
  153,
  140,
  131,
  128,
  127,
  125,
  121,
  120,
  119,
  104,
  91,
  90,
  86,
  82,
  77,
  66,
  65,
  64,
  58,
  57,
  35,
  32,
  29,
  26,
  19,
  15,
  11,
  10,
  7,
  2,
  1,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  0,
  0,
  0,
  0,
  0,
  0
}; // idb
char byte_8142A4E = '\0'; // idb
char aC_2[4] = "%c \""; // idb
char byte_814309B = '\0'; // idb
char aError_1[6] = "error\n"; // idb
char aError_2[6] = "error\n"; // idb
char aErrorExeServer_0[33] = "error\nEXE_SERVER_IS_DIFFERENT_VER"; // idb
char aC_3[4] = "%c \""; // idb
char aExeCantautodlg[21] = "EXE_CANTAUTODLGAMEIWD"; // idb
char aExeAutodlServe[30] = "EXE_AUTODL_SERVERDISABLED_PURE"; // idb
char aExeAutodlServe_0[25] = "EXE_AUTODL_SERVERDISABLED"; // idb
char aExeAutodlFilen[26] = "EXE_AUTODL_FILENOTONSERVER"; // idb
char byte_8143DA0 = '\x15'; // idb
char byte_8143DE0 = '\x15'; // idb
char byte_8143E20 = '\x15'; // idb
char byte_8143E80 = '\x15'; // idb
char byte_8143EDA = '\x15'; // idb
char byte_8143FA0 = '\x15'; // idb
char byte_8143FC3 = '\0'; // idb
char byte_8143FE0 = '\x15'; // idb
char byte_8144020 = '\x15'; // idb
char byte_8144060 = '\x15'; // idb
char byte_81440A0 = '\x15'; // idb
char byte_81440E0 = '\x15'; // idb
char byte_8144120 = '\x15'; // idb
char byte_814414D = '\x15'; // idb
char byte_8144180 = '\x15'; // idb
_UNKNOWN unk_8144940; // weak
_UNKNOWN unk_8144980; // weak
_UNKNOWN unk_81449C0; // weak
_UNKNOWN unk_8144A00; // weak
_UNKNOWN unk_8144A40; // weak
_UNKNOWN unk_8144A80; // weak
_UNKNOWN unk_8144AC0; // weak
char byte_8145200 = '\x15'; // idb
char byte_8145240 = '\x15'; // idb
char byte_8145280 = '\x15'; // idb
char byte_81452C0 = '\x15'; // idb
char byte_8145300 = '\x15'; // idb
char byte_8145340 = '\x15'; // idb
char byte_8145380 = '\x15'; // idb
char byte_81454E0 = '\x15'; // idb
char byte_8145520 = '\x15'; // idb
char byte_8145690 = '\x15'; // idb
char byte_81456C0 = '\x15'; // idb
char byte_8145733 = '\x15'; // idb
char byte_8145760 = '\x15'; // idb
char byte_81457E0 = '\x15'; // idb
char byte_8145820 = '\x15'; // idb
char byte_8145895 = '\0'; // idb
char byte_8145896 = '\x15'; // idb
char aExeUnpureclien_0[24] = "EXE_UNPURECLIENTDETECTED"; // idb
char byte_814595B = '\x15'; // idb
char byte_8145973 = '\x15'; // idb
char byte_8145E1D = '\x15'; // idb
_UNKNOWN unk_8145E60; // weak
_UNKNOWN unk_8145E68; // weak
_UNKNOWN unk_8145E74; // weak
_UNKNOWN unk_8145FA0; // weak
char byte_8146220 = '\x15'; // idb
char byte_81462E0 = '\x15'; // idb
char byte_8146340 = '\x15'; // idb
char byte_81463A0 = '\x15'; // idb
char byte_8146400 = '\x15'; // idb
char byte_8146480 = '\x15'; // idb
char byte_81464E0 = '\x15'; // idb
char byte_8146580 = '\x15'; // idb
char byte_81465E0 = '\x15'; // idb
char byte_81467C0 = '\x15'; // idb
char byte_8147777 = '\0'; // idb
char byte_8147800 = '\x15'; // idb
char byte_81479C0 = '\x15'; // idb
char byte_8147A00 = '\x15'; // idb
char byte_8147AA0 = '\x15'; // idb
char byte_8147AE0 = '\x15'; // idb
char byte_8147CC0 = '\x15'; // idb
_UNKNOWN unk_8147CE0; // weak
_UNKNOWN unk_8147CE1; // weak
_UNKNOWN unk_8147CE3; // weak
__int16 a0123456789[10] = { 48, 49, 50, 51, 52, 53, 54, 55, 56, 57 }; // weak
_UNKNOWN unk_81483E1; // weak
_UNKNOWN unk_814846A; // weak
char byte_81484A0 = '\x15'; // idb
char byte_81484E0 = '\x15'; // idb
char byte_8148508 = '\x15'; // idb
char byte_8148520 = '\x15'; // idb
_UNKNOWN unk_8148660; // weak
char byte_8148700 = '\x15'; // idb
char byte_8148720 = '\x15'; // idb
_UNKNOWN unk_814874D; // weak
char byte_8148760 = '\x15'; // idb
char byte_81487A0 = '\x15'; // idb
char byte_81487E0 = '\x15'; // idb
char byte_8148820 = '\x15'; // idb
char byte_8148860 = '\x15'; // idb
char byte_81488A0 = '\x15'; // idb
char byte_81488E0 = '\x15'; // idb
char byte_8148920 = '\x15'; // idb
char byte_8148980 = '\x15'; // idb
char byte_81489C4 = '\x15'; // idb
char byte_8148D20 = '\x15'; // idb
char byte_8148E87 = '\x15'; // idb
char byte_8148EA0 = '\x15'; // idb
_UNKNOWN unk_8148F07; // weak
char byte_81490E0 = '\x15'; // idb
char byte_8149140 = '\x15'; // idb
char byte_81491A0 = '\x15'; // idb
char byte_81491E0 = '\x15'; // idb
char byte_8149220 = '\x15'; // idb
char byte_8149280 = '\x15'; // idb
_UNKNOWN unk_81493E0; // weak
__int16 word_81497A0[] = { 0 }; // weak
__int16 word_81497A2[] = { 0 }; // weak
__int16 word_81497A4[] = { 0 }; // weak
__int16 word_81497A6[] = { 0 }; // weak
int (__cdecl *off_81497A8[27])(int, int) =
{
  &sub_80C70A8,
  (int (__cdecl *)(int, int))0x40004,
  (int (__cdecl *)(int, int))0x40008,
  &loc_80C733F,
  (int (__cdecl *)(int, int))0x50004,
  (int (__cdecl *)(int, int))0x80010,
  &loc_80C733F,
  (int (__cdecl *)(int, int))0x60004,
  (int (__cdecl *)(int, int))0x200020,
  &loc_80C733F,
  (int (__cdecl *)(int, int))0x40004,
  (int (__cdecl *)(int, int))0x100010,
  &loc_80C78FE,
  (int (__cdecl *)(int, int))0x100008,
  (int (__cdecl *)(int, int))0x200020,
  &loc_80C78FE,
  (int (__cdecl *)(int, int))0x100008,
  (int (__cdecl *)(int, int))0x800080,
  &loc_80C78FE,
  (int (__cdecl *)(int, int))0x200008,
  (int (__cdecl *)(int, int))0x1000080,
  &loc_80C78FE,
  (int (__cdecl *)(int, int))0x800020,
  (int (__cdecl *)(int, int))0x4000102,
  &loc_80C78FE,
  (int (__cdecl *)(int, int))0x1020020,
  (int (__cdecl *)(int, int))0x10000102
}; // idb
int dword_8149820[19] = { 16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15 }; // idb
_UNKNOWN unk_8149A80; // weak
_UNKNOWN unk_8149B00; // weak
_UNKNOWN unk_8149B80; // weak
_UNKNOWN unk_8149C00; // weak
int dword_8149DE0[] = { 0 }; // weak
int dword_8149E60[] = { 0 }; // weak
_UNKNOWN unk_8149F40; // weak
_UNKNOWN unk_814A3C0; // weak
char byte_814A540[] = { '\0' }; // weak
int dword_814A740[32] =
{
  0,
  1,
  2,
  3,
  4,
  5,
  6,
  7,
  8,
  10,
  12,
  14,
  16,
  20,
  24,
  28,
  32,
  40,
  48,
  56,
  64,
  80,
  96,
  112,
  128,
  160,
  192,
  224,
  0,
  0,
  0,
  0
}; // idb
int dword_814A7C0[30] =
{
  0,
  1,
  2,
  3,
  4,
  6,
  8,
  12,
  16,
  24,
  32,
  48,
  64,
  96,
  128,
  192,
  256,
  384,
  512,
  768,
  1024,
  1536,
  2048,
  3072,
  4096,
  6144,
  8192,
  12288,
  16384,
  24576
}; // idb
char byte_814AE9F = '\0'; // idb
_UNKNOWN unk_814B1CE; // weak
char byte_814B63B = '\x15'; // idb
char byte_814B64E = '\x15'; // idb
char byte_814B6C0 = '\x15'; // idb
char byte_814B780 = '\x15'; // idb
_UNKNOWN unk_814B7C0; // weak
char byte_814BB40 = '\x15'; // idb
char byte_814BFE0 = '\x15'; // idb
char byte_814C020 = '\x15'; // idb
char byte_814C140 = '\x15'; // idb
int dword_814D70C[7] = { 140, 141, 142, 143, 185, 186, 4294967295 }; // idb
char byte_814DB20 = '\x15'; // idb
char byte_814DB64 = '\x15'; // idb
char byte_814DC20 = '\x15'; // idb
char byte_814E260 = '\x15'; // idb
char byte_814E2C0 = '\x15'; // idb
char byte_814E320 = '\x15'; // idb
char byte_814E3A0 = '\x15'; // idb
char byte_814E400 = '\x15'; // idb
char byte_814E440 = '\x15'; // idb
char byte_814E4A0 = '\x15'; // idb
char byte_814E500 = '\x15'; // idb
char byte_814E800 = '\x15'; // idb
char byte_814FFCE = '\x15'; // idb
char byte_814FFE7 = '\x15'; // idb
char byte_8150020 = '\x15'; // idb
char byte_8150060 = '\x15'; // idb
char byte_81500A0 = '\x15'; // idb
char byte_81500E0 = '\x15'; // idb
char byte_8150120 = '\x15'; // idb
char byte_8150160 = '\x15'; // idb
char byte_81501A0 = '\x15'; // idb
char byte_81501E0 = '\x15'; // idb
char byte_8150220 = '\x15'; // idb
char byte_8150246 = '\x15'; // idb
_UNKNOWN unk_81503AC; // weak
char byte_8150540 = '\x15'; // idb
char byte_8150580 = '\x15'; // idb
char byte_81505C0 = '\x15'; // idb
char byte_8150600 = '\x15'; // idb
char byte_8150640 = '\x15'; // idb
char byte_8150662 = '\x15'; // idb
char byte_8150A80[32] =
{
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0'
}; // idb
char *off_8150B80 = "name"; // weak
char byte_8150CC0 = '\x15'; // idb
char *off_81518E0 = "giveweapon"; // weak
int (__cdecl *off_81518E4[183])(__int16) =
{
  &sub_80F7420,
  NULL,
  &aTakeweapon,
  &sub_80F761E,
  NULL,
  &aTakeallweapons,
  &sub_80F76F8,
  NULL,
  &aGetcurrentweap,
  &sub_80F77FE,
  NULL,
  &aGetcurrentoffh,
  &sub_80F78C4,
  NULL,
  &aHasweapon,
  &sub_80F798A,
  NULL,
  &aSwitchtoweapon,
  &sub_80F7A4A,
  NULL,
  &aSwitchtooffhan,
  &sub_80F7B40,
  NULL,
  &aGivestartammo,
  &sub_80F7C36,
  NULL,
  &aGivemaxammo,
  &sub_80F7D32,
  NULL,
  &aGetfractionsta,
  &sub_80F7E38,
  NULL,
  &aGetfractionmax,
  &sub_80F7F72,
  NULL,
  &aSetorigin,
  &sub_80F80CC,
  NULL,
  &aSetplayerangle,
  &sub_80F81F8,
  NULL,
  &aGetplayerangle,
  &sub_80F8280,
  NULL,
  &aUsebuttonpress,
  &sub_80F82F8,
  NULL,
  &aAttackbuttonpr,
  &sub_80F839A,
  NULL,
  &aMeleebuttonpre,
  &sub_80F843C,
  NULL,
  &aPlayerads,
  &sub_80F84DE,
  NULL,
  &aIsonground,
  &sub_80F8558,
  NULL,
  &aPingplayer,
  &sub_80F85E6,
  NULL,
  &aSetviewmodel,
  &sub_80F8684,
  NULL,
  &aGetviewmodel,
  &sub_80F8738,
  NULL,
  &aSayall,
  &sub_80FB2D4,
  NULL,
  &aSayteam,
  &sub_80FB3A4,
  NULL,
  &aShowscoreboard,
  &sub_80F87C0,
  NULL,
  &aSetspawnweapon,
  &sub_80F882E,
  NULL,
  &aDropitem,
  &sub_80F88EE,
  NULL,
  &aFinishplayerda,
  &sub_80F8A04,
  NULL,
  &aSuicide,
  &sub_80F9448,
  NULL,
  &aOpenmenu,
  &sub_80F9528,
  NULL,
  &aOpenmenunomous,
  &sub_80F9600,
  NULL,
  &aClosemenu,
  &sub_80F96D8,
  NULL,
  &aCloseingamemen,
  &sub_80F9766,
  NULL,
  &aFreezecontrols,
  &sub_80FAA98,
  NULL,
  &aDisableweapon,
  &sub_80FAB1A,
  NULL,
  &aEnableweapon,
  &sub_80FAB9A,
  NULL,
  &aSetreverb,
  &sub_80FAC1A,
  NULL,
  &aDeactivatereve,
  &sub_80FADAC,
  NULL,
  &aSetchannelvolu,
  &sub_80FAED6,
  NULL,
  &aDeactivatechan,
  &sub_80FB054,
  NULL,
  &aGetweaponslotw,
  &sub_80F97F4,
  NULL,
  &aSetweaponslotw,
  &sub_80F991C,
  NULL,
  &aGetweaponslota,
  &sub_80F9C02,
  NULL,
  &aSetweaponslota,
  &sub_80F9D6C,
  NULL,
  &aGetweaponslotc,
  &sub_80F9F20,
  NULL,
  &aSetweaponslotc,
  &sub_80FA064,
  NULL,
  &aSetweaponclipa,
  &sub_80FA1B2,
  NULL,
  &aIprintln,
  &sub_80FA2AC,
  NULL,
  &aIprintlnbold,
  &sub_80FA332,
  NULL,
  &aSpawn,
  &sub_80FA3B8,
  NULL,
  &aSetentertime,
  &sub_80FA45A,
  NULL,
  &aCloneplayer,
  &sub_80FA50A,
  NULL,
  &aSetclientcvar,
  &sub_80FA820,
  NULL,
  &aIslookingat,
  &sub_80FB194,
  NULL,
  &aPlaylocalsound,
  &sub_80FB224,
  NULL,
  &aIstalking,
  &sub_80FA9EE,
  NULL,
  &aAllowspectatet,
  &sub_80FB474,
  NULL,
  &aGetguid,
  &sub_80FB5B4,
  NULL,
  NULL,
  NULL,
  NULL,
  NULL,
  NULL,
  NULL,
  NULL
}; // idb
char aCGameBadclient[22] = "%c \"GAME_BADCLIENTSLOT"; // idb
char aCGameClientnot_0[24] = "%c \"GAME_CLIENTNOTACTIVE"; // idb
char aCGameUsernoton[24] = "%c \"GAME_USERNOTONSERVER"; // idb
char byte_8151D60 = '\x15'; // idb
char aC_4[4] = "%c \""; // idb
_UNKNOWN unk_8151D8E; // weak
_UNKNOWN unk_8151D91; // weak
_UNKNOWN unk_8151D94; // weak
char byte_8151D95 = '\x15'; // idb
char byte_8151DA9 = '\x15'; // idb
char byte_8151DBA = '\x15'; // idb
char aS_33[3] = "%s("; // idb
char aC_5[4] = "%c \""; // idb
char aCGameVotecomma[24] = "%c \"GAME_VOTECOMMANDSARE"; // idb
char aC_6[4] = "%c \""; // idb
char aGameVoteGamety[18] = "GAME_VOTE_GAMETYPE"; // idb
char aGameVoteMap[13] = "GAME_VOTE_MAP"; // idb
char aGameVoteGamety_0[18] = "GAME_VOTE_GAMETYPE"; // idb
char aGameVoteKick[14] = "GAME_VOTE_KICK"; // idb
char aCGameCalledavo[20] = "%c \"GAME_CALLEDAVOTE"; // idb
char aCGameUsage[14] = "%c \"GAME_USAGE"; // idb
char aCGameUnknowncl[29] = "%c \"GAME_UNKNOWNCLIENTCOMMAND"; // idb
char byte_8152520 = '\x15'; // idb
char byte_8152560 = '\x15'; // idb
char byte_81525A0 = '\x15'; // idb
char byte_81525E0 = '\x15'; // idb
char byte_8152620 = '\x15'; // idb
int dword_81527A0[] = { 0 }; // weak
int dword_81527A4[22] = { 1, 0, 2, 0, 4, 1, 3, 1, 5, 2, 3, 2, 6, 3, 7, 4, 5, 4, 6, 5, 7, 6 }; // idb
__int16 *off_8152E40[112] =
{
  &aXyz,
  (__int16 *)4,
  (__int16 *)1,
  NULL,
  NULL,
  NULL,
  NULL,
  (__int16 *)0x8152DDE,
  (__int16 *)8,
  (__int16 *)1,
  NULL,
  NULL,
  NULL,
  NULL,
  (__int16 *)0x8152DE0,
  (__int16 *)0xC,
  (__int16 *)1,
  NULL,
  NULL,
  NULL,
  NULL,
  &aFontscale_0,
  (__int16 *)0x10,
  (__int16 *)1,
  (__int16 *)0xFFFFFFFF,
  NULL,
  &sub_8101410,
  NULL,
  &aFont_0,
  (__int16 *)0x14,
  NULL,
  (__int16 *)0xFFFFFFFF,
  NULL,
  &sub_810145A,
  &sub_8101494,
  &aAlignx,
  (__int16 *)0x18,
  NULL,
  (__int16 *)3,
  (__int16 *)2,
  &sub_81014CE,
  &sub_8101508,
  &aAligny,
  (__int16 *)0x18,
  NULL,
  (__int16 *)3,
  NULL,
  &sub_8101542,
  &sub_810157C,
  &aHorzalign,
  (__int16 *)0x1C,
  NULL,
  (__int16 *)7,
  (__int16 *)3,
  &sub_81015B6,
  &sub_81015F0,
  &aVertalign,
  (__int16 *)0x1C,
  NULL,
  (__int16 *)7,
  NULL,
  &sub_810162A,
  &sub_8101664,
  &aColor_0,
  (__int16 *)0x20,
  NULL,
  (__int16 *)0xFFFFFFFF,
  NULL,
  &sub_810125C,
  &sub_810132E,
  &aAlpha_0,
  (__int16 *)0x20,
  NULL,
  (__int16 *)0xFFFFFFFF,
  NULL,
  &sub_8101390,
  &sub_81013E8,
  &aLabel_0,
  (__int16 *)0x30,
  NULL,
  (__int16 *)0xFFFFFFFF,
  NULL,
  &sub_81011D0,
  NULL,
  &aSort_0,
  (__int16 *)0x78,
  (__int16 *)1,
  NULL,
  NULL,
  NULL,
  NULL,
  &aForeground_0,
  (__int16 *)0x7C,
  NULL,
  (__int16 *)0xFFFFFFFF,
  NULL,
  &sub_810121A,
  NULL,
  &aArchived,
  (__int16 *)0x88,
  NULL,
  (__int16 *)0xFFFFFFFF,
  NULL,
  &sub_810121A,
  NULL,
  NULL,
  NULL,
  NULL,
  NULL,
  NULL,
  NULL,
  NULL
}; // idb
char *off_81530E0 = "settext"; // weak
int (__cdecl *off_81530E4[54])(int) =
{
  &sub_81019C2,
  NULL,
  &aSetplayernames,
  &sub_8101A12,
  NULL,
  &aSetmapnamestri,
  &sub_8101B14,
  NULL,
  &aSetgametypestr,
  &sub_8101A84,
  NULL,
  &aSetshader,
  &sub_8101B92,
  NULL,
  &aSettimer_0,
  &sub_8101F16,
  NULL,
  &aSettimerup_0,
  &sub_8101F3A,
  NULL,
  &aSettenthstimer_1,
  &sub_8101F5E,
  NULL,
  &aSettenthstimer_2,
  &sub_8101F82,
  NULL,
  &aSetclock_0,
  &sub_8101FA6,
  NULL,
  &aSetclockup_0,
  &sub_8101FCA,
  NULL,
  &aSetvalue,
  &sub_8101FEE,
  NULL,
  &aSetwaypoint,
  &sub_8102030,
  NULL,
  &aFadeovertime,
  &sub_8102068,
  NULL,
  &aScaleovertime,
  &sub_810212C,
  NULL,
  &aMoveovertime,
  &sub_8102242,
  NULL,
  &aReset_0,
  &sub_810232A,
  NULL,
  &aDestroy,
  &sub_810234C,
  NULL,
  NULL
}; // idb
char aCGamePickupCli[29] = "%c \"GAME_PICKUP_CLIPONLY_AMMO"; // idb
char aCGamePickupAmm[20] = "%c \"GAME_PICKUP_AMMO"; // idb
char aCGamePickupHea[22] = "%c \"GAME_PICKUP_HEALTH"; // idb
char aCGamePickupCan[33] = "%c \"GAME_PICKUP_CANTCARRYMOREAMMO"; // idb
char byte_8153420 = '\x15'; // idb
char byte_81534F7 = '\0'; // idb
char byte_8153A87 = '\x15'; // idb
char byte_8153AE0 = '\x15'; // idb
char byte_8153B80 = '\x15'; // idb
char byte_8153BE0 = '\x15'; // idb
char byte_8153C20 = '\x15'; // idb
_UNKNOWN unk_8153CDC; // weak
char byte_8153D40 = '\x15'; // idb
_UNKNOWN unk_8153DE0; // weak
char byte_8153E60 = '\x15'; // idb
char byte_8153EC0 = '\x15'; // idb
char byte_8153EE0 = '\x15'; // idb
char byte_8153FCE = '\0'; // idb
_UNKNOWN unk_8157110; // weak
char *off_8157300 = "moveto"; // weak
int (__cdecl *off_8157304[39])(__int16) =
{
  &sub_81174FA,
  NULL,
  &aMovex,
  &sub_81177AC,
  NULL,
  &aMovey,
  &sub_81177C8,
  NULL,
  &aMovez,
  &sub_81177E4,
  NULL,
  &aMovegravity,
  &sub_81175DC,
  NULL,
  &aRotateto,
  &sub_8117800,
  NULL,
  &aRotatepitch,
  &sub_8117A3E,
  NULL,
  &aRotateyaw,
  &sub_8117A5A,
  NULL,
  &aRotateroll,
  &sub_8117A76,
  NULL,
  &aRotatevelocity,
  &sub_8117A92,
  NULL,
  &aSolid_0,
  &sub_8117B74,
  NULL,
  &aNotsolid,
  &sub_8117C76,
  NULL,
  NULL,
  NULL,
  NULL,
  NULL
}; // idb
char byte_8157544 = '\0'; // idb
char byte_81576A0 = '\x15'; // idb
char byte_8157717 = '\x15'; // idb
char *off_8157780[48] =
{
  "classname",
  (char *)0x168,
  (char *)3,
  &sub_811804C,
  &unk_8157733,
  (char *)0x138,
  (char *)4,
  &sub_81159D4,
  &unk_815773A,
  (char *)0x164,
  (char *)8,
  &sub_811804C,
  "spawnflags",
  (char *)0x170,
  NULL,
  &sub_811804C,
  &unk_8157740,
  (char *)0x16A,
  (char *)3,
  NULL,
  &unk_8157747,
  (char *)0x16C,
  (char *)3,
  NULL,
  &unk_8157752,
  (char *)0x1A0,
  NULL,
  NULL,
  &unk_8157758,
  (char *)0x194,
  NULL,
  &sub_8115A46,
  &unk_815775F,
  (char *)0x19C,
  NULL,
  NULL,
  &unk_8157763,
  (char *)0x144,
  (char *)4,
  &sub_8115A18,
  NULL,
  NULL,
  NULL,
  NULL,
  NULL,
  NULL,
  NULL,
  NULL
}; // idb
char aCGameServer[15] = "%c \"GAME_SERVER"; // idb
_UNKNOWN unk_8157A40; // weak
char byte_8157B80 = '\x15'; // idb
char byte_8157BDF = '\x15'; // idb
_UNKNOWN unk_8157C43; // weak
char byte_8157C61 = '\x15'; // idb
float flt_8157C80[] = {  0.0 }; // weak
float flt_8157C84[8] = {  0.0,  1.0,  1.0,  1.0, -1.0, -1.0,  1.0, -1.0 }; // idb
char byte_8157D40 = '\x15'; // idb
_UNKNOWN unk_8157DAC; // weak
char byte_8157DD0 = '\0'; // idb
_UNKNOWN unk_81581A2; // weak
int (__cdecl *off_8158268[2])(int) = { &sub_81278E8, &sub_812791C }; // weak
int (__cdecl *off_81582A8[2])(int) = { &sub_81267EA, &sub_812681E }; // weak
int (__cdecl *off_81582E8[4])(int) = { &sub_8125D08, &sub_8125D3C, &sub_81228B8, &sub_8125DBE }; // weak
int (__cdecl *off_8158328[6])(int) =
{
  &sub_8125A54,
  &sub_8125A88,
  &sub_81228B8,
  &sub_8125B30,
  &sub_8125ABC,
  &sub_8125B14
}; // weak
int (__cdecl *off_8158368[6])(int) =
{
  &sub_812555A,
  &sub_812558E,
  &sub_81228B8,
  &sub_81256AE,
  &sub_81255E8,
  &sub_8125692
}; // weak
int (__cdecl *off_81583A8[2])(int) = { &sub_81252DA, &sub_812530E }; // weak
int (__cdecl *off_81583E8[2])(int) = { &sub_8124D38, &sub_8124D6C }; // weak
int (__cdecl *off_8158428[6])(int) =
{
  &sub_8124A36,
  &sub_8124A6A,
  &sub_81228B8,
  &sub_8124AF8,
  &sub_8124A9E,
  &sub_8124ADC
}; // weak
int (__cdecl *off_8158468[6])(int) =
{
  &sub_8122850,
  &sub_8122884,
  &sub_81228B8,
  &sub_8122A76,
  &sub_81229F0,
  &sub_8122A2E
}; // weak
int (__cdecl *off_81584A8[2])(int) = { &sub_81222A6, &sub_81222DE }; // weak
char *off_8158A40 = "depthHack"; // weak
char *off_8158C20 = "org2fromTrace"; // weak
_UNKNOWN unk_8158CD6; // weak
char asc_8159580[] = { '\"', '\0', ']', '\0', '\t', '\0' }; // idb
char asc_8159594[] = { '}', '\0', '{', '\0', '[', '\0' }; // idb
_UNKNOWN unk_8159A3C; // weak
_UNKNOWN unk_8159A60; // weak
int *off_815A008 = &dword_8185790; // weak
char *s1 = "if"; // idb
int (__cdecl *off_815A024)(int) = &sub_804E4D4; // weak
char *off_815A0C0 = "evalint"; // idb
int (__cdecl *off_815A0C4)(int) = &sub_804E95A; // weak
char *off_815A160 = ">>="; // weak
int off_815A3DC = 135839236; // weak
char *off_815A3E0 = "EXE_SERVER_DISCONNECTED"; // idb
void *off_815A498 = &unk_81E6160; // weak
_UNKNOWN unk_815A4A0; // weak
int dword_815A4E0[40] =
{
  0,
  1,
  3,
  7,
  15,
  31,
  63,
  127,
  255,
  511,
  1023,
  2047,
  4095,
  8191,
  16383,
  32767,
  65535,
  131071,
  262143,
  524287,
  1048575,
  2097151,
  4194303,
  8388607,
  16777215,
  33554431,
  67108863,
  134217727,
  268435455,
  536870911,
  1073741823,
  2147483647,
  4294967295,
  0,
  0,
  0,
  0,
  0,
  0,
  0
}; // idb
char *off_815A580 = "origin[0]"; // weak
int dword_815A5E4[93] =
{
  8,
  4294967197,
  135515156,
  0,
  4,
  135515161,
  32,
  32,
  135515172,
  4,
  4294967197,
  135515174,
  28,
  6,
  135515186,
  16,
  0,
  135515196,
  60,
  8,
  135515210,
  52,
  10,
  135515216,
  56,
  10,
  135515223,
  40,
  32,
  135515237,
  36,
  32,
  135515252,
  44,
  16,
  135515261,
  112,
  0,
  135515267,
  104,
  32,
  135515272,
  12,
  4294967197,
  135515274,
  24,
  4,
  135515283,
  120,
  0,
  135515288,
  116,
  8,
  135515293,
  20,
  4,
  135515298,
  72,
  32,
  135515313,
  76,
  16,
  135515323,
  68,
  10,
  135515334,
  48,
  8,
  135515340,
  64,
  10,
  135515350,
  96,
  32,
  135515364,
  100,
  16,
  135515373,
  80,
  4294967197,
  135515379,
  84,
  4294967197,
  135515385,
  92,
  6,
  135515401,
  88,
  4,
  135515414,
  108,
  32,
  135515423
}; // idb
int dword_815A760[255] =
{
  250315,
  41193,
  6292,
  7106,
  3730,
  3750,
  6110,
  23283,
  33317,
  6950,
  7838,
  9714,
  9257,
  17259,
  3949,
  1778,
  8288,
  1604,
  1590,
  1663,
  1100,
  1213,
  1238,
  1134,
  1749,
  1059,
  1246,
  1149,
  1273,
  4486,
  2805,
  3472,
  21819,
  1159,
  1670,
  1066,
  1043,
  1012,
  1053,
  1070,
  1726,
  888,
  1180,
  850,
  960,
  780,
  1752,
  3296,
  10630,
  4514,
  5881,
  2685,
  4650,
  3837,
  2093,
  1867,
  2584,
  1949,
  1972,
  940,
  1134,
  1788,
  1670,
  1206,
  5719,
  6128,
  7222,
  6654,
  3710,
  3795,
  1492,
  1524,
  2215,
  1140,
  1355,
  971,
  2180,
  1248,
  1328,
  1195,
  1770,
  1078,
  1264,
  1266,
  1168,
  965,
  1155,
  1186,
  1347,
  1228,
  1529,
  1600,
  2617,
  2048,
  2546,
  3275,
  2410,
  3585,
  2504,
  2800,
  2675,
  6146,
  3663,
  2840,
  14253,
  3164,
  2221,
  1687,
  3208,
  2739,
  3512,
  4796,
  4091,
  3515,
  5288,
  4016,
  7937,
  6031,
  5360,
  3924,
  4892,
  3743,
  4566,
  4807,
  5852,
  6400,
  6225,
  8291,
  23243,
  7838,
  7073,
  8935,
  5437,
  4483,
  3641,
  5256,
  5312,
  5328,
  5370,
  3492,
  2458,
  1694,
  1821,
  2121,
  1916,
  1149,
  1516,
  1367,
  1236,
  1029,
  1258,
  1104,
  1245,
  1006,
  1149,
  1025,
  1241,
  952,
  1287,
  997,
  1713,
  1009,
  1187,
  879,
  1099,
  929,
  1078,
  951,
  1656,
  930,
  1153,
  1030,
  1262,
  1062,
  1214,
  1060,
  1621,
  930,
  1106,
  912,
  1034,
  892,
  1158,
  990,
  1175,
  850,
  1121,
  903,
  1087,
  920,
  1144,
  1056,
  3462,
  2240,
  4397,
  12136,
  7758,
  1345,
  1307,
  3278,
  1950,
  886,
  1023,
  1112,
  1077,
  1042,
  1061,
  1071,
  1484,
  1001,
  1096,
  915,
  1052,
  995,
  1070,
  876,
  1111,
  851,
  1059,
  805,
  1112,
  923,
  1103,
  817,
  1899,
  1872,
  976,
  841,
  1127,
  956,
  1159,
  950,
  7791,
  954,
  1289,
  933,
  1127,
  3207,
  1020,
  927,
  1355,
  768,
  1040,
  745,
  952,
  805,
  1073,
  740,
  1013,
  805,
  1008,
  796,
  996,
  1057,
  11457
}; // idb
char dword_815AB5C[] = { '', '4', '\0', '\0' }; // idb
char off_815AB60[] = { '\x80', '', '\x13', '\b' }; // idb
char *off_815AB68 = "loopsync"; // idb
__int16 word_815AB80[] = { 0 }; // weak
__int16 word_815AB82[] = { 0 }; // weak
char byte_815AB84[] = { 'e' }; // weak
char *off_815AB88 = "entity"; // weak
char off_815ABC0[] = { '$', '\xFB', '\x13', '\b' }; // idb
__int16 word_815AC60[144] =
{
  65535,
  0,
  0,
  0,
  0,
  3,
  3,
  3,
  3,
  3,
  3,
  3,
  3,
  3,
  3,
  3,
  3,
  3,
  3,
  3,
  3,
  3,
  3,
  3,
  3,
  3,
  7,
  7,
  8,
  8,
  9,
  9,
  10,
  10,
  11,
  11,
  12,
  12,
  13,
  13,
  6,
  6,
  6,
  6,
  6,
  6,
  6,
  6,
  6,
  6,
  6,
  6,
  6,
  6,
  6,
  6,
  6,
  6,
  6,
  6,
  6,
  15,
  15,
  15,
  15,
  15,
  4,
  4,
  4,
  4,
  4,
  4,
  4,
  4,
  4,
  4,
  4,
  4,
  4,
  4,
  4,
  4,
  4,
  4,
  4,
  4,
  4,
  4,
  4,
  4,
  4,
  4,
  19,
  19,
  20,
  20,
  5,
  5,
  5,
  5,
  5,
  5,
  5,
  5,
  22,
  22,
  22,
  22,
  21,
  21,
  14,
  14,
  14,
  23,
  23,
  23,
  16,
  16,
  17,
  17,
  18,
  18,
  24,
  24,
  24,
  24,
  2,
  2,
  25,
  1,
  1,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0
}; // idb
__int16 word_815AD80[144] =
{
  2,
  3,
  2,
  2,
  2,
  1,
  3,
  3,
  3,
  3,
  3,
  3,
  3,
  3,
  3,
  3,
  3,
  3,
  3,
  3,
  3,
  3,
  3,
  3,
  2,
  2,
  1,
  0,
  1,
  1,
  3,
  1,
  3,
  2,
  1,
  5,
  1,
  2,
  4,
  5,
  3,
  1,
  1,
  2,
  2,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  2,
  1,
  2,
  2,
  1,
  1,
  1,
  3,
  4,
  1,
  2,
  3,
  3,
  2,
  1,
  2,
  2,
  2,
  3,
  3,
  3,
  3,
  3,
  3,
  3,
  3,
  3,
  3,
  5,
  5,
  1,
  5,
  5,
  1,
  1,
  1,
  4,
  4,
  1,
  1,
  0,
  1,
  2,
  3,
  5,
  7,
  5,
  8,
  7,
  3,
  1,
  3,
  2,
  1,
  2,
  0,
  3,
  1,
  0,
  3,
  1,
  0,
  3,
  1,
  3,
  1,
  3,
  1,
  7,
  5,
  1,
  1,
  2,
  0,
  2,
  3,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0
}; // idb
__int16 word_815AEA0[256] =
{
  0,
  130,
  0,
  0,
  0,
  0,
  45,
  46,
  109,
  0,
  0,
  0,
  0,
  0,
  0,
  41,
  42,
  0,
  0,
  0,
  49,
  50,
  51,
  52,
  53,
  0,
  0,
  0,
  60,
  0,
  29,
  84,
  0,
  87,
  88,
  58,
  59,
  89,
  0,
  0,
  109,
  0,
  0,
  0,
  4,
  0,
  0,
  34,
  55,
  36,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  47,
  0,
  48,
  0,
  56,
  43,
  44,
  57,
  24,
  25,
  0,
  0,
  0,
  0,
  0,
  37,
  0,
  0,
  0,
  33,
  0,
  0,
  0,
  0,
  64,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  54,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  70,
  71,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  96,
  28,
  128,
  0,
  0,
  124,
  125,
  126,
  129,
  97,
  104,
  0,
  0,
  93,
  107,
  0,
  108,
  40,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  103,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  21,
  22,
  23,
  0,
  0,
  61,
  65,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  106,
  0,
  0,
  30,
  0,
  0,
  0,
  0,
  0,
  90,
  91,
  62,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  38,
  114,
  0,
  0,
  105,
  35,
  0,
  100,
  0,
  109,
  82,
  0,
  83,
  0,
  85,
  0,
  86,
  39,
  0,
  0,
  0,
  0,
  95,
  0,
  0,
  116,
  0,
  0,
  109,
  113,
  123,
  99,
  0,
  102,
  0,
  101,
  122,
  0,
  0
}; // idb
__int16 word_815B0A0[32] =
{
  3,
  4,
  55,
  58,
  139,
  140,
  59,
  204,
  46,
  47,
  48,
  49,
  50,
  60,
  61,
  62,
  210,
  212,
  214,
  53,
  240,
  57,
  142,
  219,
  133,
  56,
  0,
  0,
  0,
  0,
  0,
  0
}; // idb
__int16 word_815B0E0[] = { 65268 }; // weak
__int16 word_815B2E0[] = { 0 }; // weak
__int16 word_815B4E0[32] =
{
  0,
  0,
  0,
  949,
  192,
  31,
  2,
  0,
  65520,
  0,
  0,
  176,
  65500,
  6,
  65426,
  770,
  0,
  0,
  0,
  65507,
  0,
  65496,
  124,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0
}; // idb
__int16 word_815B520[2064] =
{
  83,
  98,
  182,
  74,
  45,
  129,
  31,
  127,
  51,
  110,
  174,
  54,
  1,
  68,
  2,
  72,
  67,
  67,
  3,
  69,
  66,
  79,
  73,
  110,
  127,
  111,
  143,
  72,
  6,
  74,
  84,
  217,
  76,
  44,
  227,
  5,
  6,
  7,
  128,
  77,
  9,
  78,
  10,
  74,
  63,
  229,
  100,
  101,
  102,
  63,
  64,
  175,
  144,
  80,
  81,
  65,
  66,
  144,
  11,
  141,
  228,
  12,
  82,
  51,
  15,
  16,
  28,
  130,
  231,
  112,
  216,
  230,
  17,
  18,
  19,
  20,
  21,
  22,
  23,
  24,
  141,
  30,
  73,
  146,
  51,
  141,
  63,
  131,
  132,
  51,
  30,
  234,
  126,
  134,
  232,
  72,
  235,
  151,
  28,
  152,
  29,
  30,
  103,
  112,
  31,
  110,
  111,
  115,
  176,
  33,
  34,
  72,
  35,
  36,
  37,
  38,
  39,
  144,
  103,
  41,
  110,
  117,
  236,
  8,
  177,
  74,
  104,
  178,
  179,
  112,
  206,
  119,
  111,
  115,
  19,
  180,
  181,
  197,
  121,
  196,
  118,
  120,
  104,
  194,
  221,
  72,
  110,
  117,
  195,
  200,
  19,
  218,
  103,
  74,
  75,
  220,
  105,
  119,
  32,
  207,
  110,
  30,
  106,
  107,
  121,
  108,
  118,
  120,
  222,
  226,
  237,
  109,
  105,
  225,
  238,
  242,
  104,
  30,
  246,
  245,
  74,
  247,
  2,
  249,
  19,
  1,
  241,
  76,
  77,
  78,
  27,
  26,
  94,
  79,
  43,
  75,
  239,
  80,
  13,
  81,
  113,
  0,
  149,
  141,
  141,
  251,
  105,
  51,
  51,
  0,
  0,
  30,
  0,
  0,
  114,
  115,
  116,
  117,
  118,
  119,
  120,
  121,
  122,
  123,
  124,
  125,
  0,
  141,
  0,
  47,
  0,
  51,
  223,
  224,
  98,
  99,
  100,
  101,
  102,
  0,
  141,
  0,
  0,
  141,
  51,
  0,
  0,
  51,
  0,
  0,
  0,
  141,
  0,
  141,
  0,
  51,
  0,
  51,
  0,
  98,
  98,
  98,
  98,
  98,
  98,
  127,
  98,
  0,
  17,
  248,
  96,
  97,
  98,
  99,
  100,
  101,
  102,
  68,
  0,
  0,
  252,
  67,
  98,
  69,
  66,
  98,
  98,
  98,
  98,
  98,
  0,
  72,
  6,
  98,
  6,
  6,
  98,
  98,
  98,
  98,
  98,
  98,
  98,
  98,
  98,
  68,
  98,
  98,
  48,
  67,
  93,
  69,
  66,
  0,
  0,
  0,
  0,
  0,
  6,
  72,
  6,
  0,
  98,
  0,
  98,
  98,
  0,
  127,
  98,
  0,
  98,
  98,
  98,
  98,
  98,
  0,
  98,
  98,
  98,
  98,
  98,
  98,
  98,
  98,
  63,
  19,
  73,
  127,
  127,
  31,
  63,
  63,
  63,
  63,
  63,
  63,
  63,
  63,
  63,
  63,
  63,
  63,
  63,
  63,
  63,
  63,
  63,
  63,
  63,
  63,
  63,
  0,
  0,
  0,
  73,
  63,
  63,
  63,
  63,
  63,
  5,
  0,
  0,
  63,
  0,
  0,
  0,
  8,
  0,
  8,
  8,
  8,
  8,
  63,
  63,
  63,
  63,
  63,
  63,
  63,
  63,
  63,
  63,
  63,
  63,
  63,
  0,
  20,
  0,
  28,
  63,
  63,
  63,
  8,
  63,
  8,
  32,
  74,
  75,
  0,
  63,
  30,
  32,
  32,
  32,
  32,
  32,
  32,
  32,
  32,
  32,
  32,
  32,
  32,
  32,
  32,
  32,
  32,
  32,
  32,
  32,
  32,
  32,
  18,
  0,
  74,
  75,
  32,
  32,
  32,
  32,
  76,
  77,
  78,
  0,
  32,
  0,
  79,
  0,
  0,
  0,
  80,
  13,
  81,
  13,
  13,
  13,
  13,
  13,
  13,
  13,
  13,
  13,
  13,
  13,
  13,
  14,
  32,
  0,
  76,
  77,
  78,
  32,
  32,
  32,
  79,
  32,
  47,
  13,
  80,
  13,
  81,
  32,
  92,
  47,
  0,
  47,
  47,
  47,
  47,
  47,
  47,
  47,
  47,
  47,
  47,
  47,
  47,
  47,
  47,
  47,
  47,
  47,
  47,
  15,
  0,
  0,
  0,
  47,
  0,
  0,
  92,
  0,
  0,
  0,
  0,
  47,
  0,
  0,
  0,
  0,
  0,
  17,
  0,
  17,
  17,
  17,
  17,
  17,
  17,
  17,
  17,
  17,
  17,
  17,
  17,
  17,
  17,
  47,
  16,
  0,
  0,
  0,
  47,
  47,
  47,
  0,
  47,
  17,
  0,
  17,
  0,
  0,
  47,
  11,
  0,
  48,
  0,
  0,
  0,
  0,
  0,
  0,
  48,
  0,
  48,
  48,
  48,
  48,
  48,
  48,
  48,
  48,
  48,
  48,
  48,
  48,
  48,
  48,
  48,
  48,
  48,
  48,
  12,
  0,
  0,
  0,
  48,
  0,
  0,
  0,
  0,
  0,
  10,
  0,
  48,
  0,
  0,
  0,
  19,
  0,
  19,
  19,
  19,
  19,
  19,
  19,
  19,
  19,
  19,
  19,
  19,
  19,
  19,
  19,
  19,
  19,
  48,
  0,
  0,
  9,
  0,
  48,
  48,
  48,
  19,
  48,
  19,
  7,
  0,
  0,
  0,
  48,
  0,
  5,
  0,
  5,
  5,
  5,
  5,
  5,
  5,
  5,
  5,
  5,
  5,
  5,
  5,
  5,
  5,
  5,
  5,
  5,
  5,
  5,
  5,
  0,
  0,
  0,
  0,
  5,
  20,
  5,
  20,
  20,
  20,
  20,
  20,
  20,
  20,
  20,
  20,
  20,
  20,
  20,
  20,
  20,
  20,
  20,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  20,
  0,
  20,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  18,
  0,
  18,
  18,
  18,
  18,
  18,
  18,
  18,
  18,
  18,
  18,
  18,
  18,
  18,
  18,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  18,
  0,
  18,
  0,
  0,
  0,
  0,
  14,
  0,
  14,
  14,
  14,
  14,
  14,
  14,
  14,
  14,
  14,
  14,
  14,
  14,
  92,
  93,
  94,
  95,
  96,
  97,
  98,
  99,
  100,
  101,
  102,
  0,
  14,
  0,
  14,
  0,
  0,
  0,
  52,
  0,
  0,
  0,
  0,
  0,
  15,
  0,
  15,
  15,
  15,
  15,
  15,
  15,
  15,
  15,
  15,
  15,
  15,
  15,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  15,
  0,
  15,
  0,
  0,
  0,
  0,
  0,
  0,
  16,
  0,
  16,
  16,
  16,
  16,
  16,
  16,
  16,
  16,
  16,
  16,
  16,
  16,
  52,
  11,
  0,
  11,
  11,
  11,
  11,
  11,
  11,
  11,
  11,
  0,
  16,
  0,
  16,
  0,
  0,
  0,
  0,
  0,
  0,
  52,
  0,
  0,
  0,
  0,
  52,
  11,
  0,
  11,
  12,
  0,
  12,
  12,
  12,
  12,
  12,
  12,
  12,
  12,
  10,
  0,
  10,
  10,
  10,
  10,
  10,
  10,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  12,
  0,
  12,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  10,
  9,
  10,
  9,
  9,
  9,
  9,
  9,
  0,
  7,
  0,
  7,
  7,
  7,
  90,
  91,
  92,
  93,
  94,
  95,
  96,
  97,
  98,
  99,
  100,
  101,
  102,
  9,
  0,
  9,
  0,
  0,
  0,
  0,
  0,
  7,
  0,
  7,
  0,
  5,
  5,
  5,
  5,
  5,
  5,
  5,
  5,
  5,
  5,
  5,
  5,
  5,
  5,
  5,
  5,
  5,
  5,
  0,
  42,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  68,
  69,
  0,
  0,
  70,
  71,
  0,
  0,
  201,
  52,
  52,
  85,
  86,
  87,
  88,
  89,
  90,
  91,
  92,
  93,
  94,
  95,
  96,
  97,
  98,
  99,
  100,
  101,
  102,
  0,
  0,
  0,
  0,
  52,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  52,
  0,
  0,
  52,
  145,
  0,
  0,
  0,
  0,
  0,
  0,
  52,
  0,
  52,
  0,
  0,
  0,
  147,
  148,
  0,
  0,
  150,
  0,
  0,
  0,
  0,
  154,
  155,
  156,
  157,
  158,
  159,
  160,
  161,
  162,
  163,
  164,
  165,
  166,
  167,
  168,
  169,
  170,
  171,
  173,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  183,
  0,
  0,
  184,
  185,
  186,
  187,
  188,
  189,
  190,
  191,
  192,
  193,
  85,
  86,
  87,
  88,
  89,
  90,
  91,
  92,
  93,
  94,
  95,
  96,
  97,
  98,
  99,
  100,
  101,
  102,
  198,
  0,
  0,
  0,
  0,
  203,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  5,
  6,
  7,
  8,
  135,
  9,
  0,
  10,
  0,
  0,
  145,
  0,
  0,
  0,
  209,
  211,
  213,
  215,
  0,
  0,
  0,
  0,
  0,
  11,
  0,
  0,
  12,
  0,
  0,
  15,
  16,
  0,
  0,
  0,
  136,
  0,
  0,
  17,
  18,
  19,
  20,
  21,
  22,
  23,
  24,
  25,
  0,
  26,
  27,
  89,
  90,
  91,
  92,
  93,
  94,
  95,
  96,
  97,
  98,
  99,
  100,
  101,
  102,
  28,
  0,
  29,
  30,
  0,
  243,
  31,
  244,
  32,
  137,
  138,
  33,
  34,
  0,
  35,
  36,
  37,
  38,
  39,
  40,
  0,
  41,
  5,
  6,
  7,
  8,
  0,
  9,
  0,
  10,
  88,
  89,
  90,
  91,
  92,
  93,
  94,
  95,
  96,
  97,
  98,
  99,
  100,
  101,
  102,
  11,
  0,
  0,
  12,
  0,
  0,
  15,
  16,
  0,
  0,
  0,
  136,
  0,
  0,
  17,
  18,
  19,
  20,
  21,
  22,
  23,
  24,
  25,
  0,
  26,
  27,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  28,
  0,
  29,
  30,
  0,
  0,
  31,
  0,
  32,
  137,
  138,
  33,
  34,
  0,
  35,
  36,
  37,
  38,
  39,
  40,
  153,
  41,
  5,
  6,
  7,
  8,
  250,
  9,
  0,
  10,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  11,
  0,
  0,
  12,
  0,
  0,
  15,
  16,
  0,
  0,
  0,
  136,
  0,
  0,
  17,
  18,
  19,
  20,
  21,
  22,
  23,
  24,
  25,
  0,
  26,
  27,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  28,
  0,
  29,
  30,
  0,
  0,
  31,
  0,
  32,
  137,
  138,
  33,
  34,
  0,
  35,
  36,
  37,
  38,
  39,
  40,
  0,
  41,
  5,
  6,
  7,
  8,
  253,
  9,
  0,
  10,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  11,
  0,
  0,
  12,
  0,
  0,
  15,
  16,
  0,
  0,
  0,
  136,
  0,
  0,
  17,
  18,
  19,
  20,
  21,
  22,
  23,
  24,
  25,
  0,
  26,
  27,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  28,
  0,
  29,
  30,
  0,
  0,
  31,
  0,
  32,
  137,
  138,
  33,
  34,
  0,
  35,
  36,
  37,
  38,
  39,
  40,
  0,
  41,
  5,
  6,
  7,
  8,
  0,
  9,
  0,
  10,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  11,
  0,
  0,
  12,
  0,
  0,
  15,
  16,
  0,
  0,
  0,
  136,
  0,
  0,
  17,
  18,
  19,
  20,
  21,
  22,
  23,
  24,
  25,
  0,
  26,
  27,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  28,
  0,
  29,
  30,
  0,
  0,
  31,
  0,
  32,
  137,
  138,
  33,
  34,
  0,
  35,
  36,
  37,
  38,
  39,
  40,
  0,
  41,
  5,
  6,
  7,
  8,
  0,
  9,
  0,
  10,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  11,
  0,
  0,
  12,
  13,
  14,
  15,
  16,
  0,
  0,
  0,
  0,
  0,
  0,
  17,
  18,
  19,
  20,
  21,
  22,
  23,
  24,
  25,
  0,
  26,
  27,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  28,
  0,
  29,
  30,
  0,
  0,
  31,
  0,
  32,
  0,
  0,
  33,
  34,
  0,
  35,
  36,
  37,
  38,
  39,
  40,
  0,
  41,
  5,
  6,
  7,
  8,
  0,
  9,
  0,
  10,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  11,
  0,
  0,
  12,
  0,
  0,
  15,
  16,
  0,
  0,
  0,
  0,
  0,
  0,
  17,
  18,
  19,
  20,
  21,
  22,
  23,
  24,
  25,
  0,
  26,
  27,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  28,
  0,
  29,
  30,
  0,
  0,
  31,
  0,
  32,
  0,
  0,
  33,
  34,
  0,
  35,
  36,
  37,
  38,
  39,
  40,
  0,
  41,
  5,
  6,
  7,
  0,
  0,
  9,
  0,
  172,
  64,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  11,
  0,
  0,
  12,
  13,
  14,
  15,
  16,
  5,
  6,
  7,
  0,
  0,
  9,
  0,
  10,
  19,
  20,
  21,
  22,
  23,
  24,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  11,
  0,
  0,
  12,
  13,
  14,
  15,
  16,
  0,
  28,
  0,
  29,
  30,
  0,
  0,
  0,
  19,
  20,
  21,
  22,
  23,
  24,
  0,
  35,
  36,
  0,
  0,
  0,
  0,
  0,
  41,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  28,
  0,
  29,
  30,
  5,
  6,
  7,
  0,
  0,
  9,
  0,
  172,
  0,
  0,
  35,
  36,
  0,
  0,
  0,
  0,
  0,
  41,
  0,
  0,
  0,
  0,
  0,
  11,
  0,
  0,
  12,
  13,
  14,
  15,
  16,
  5,
  6,
  7,
  0,
  0,
  9,
  0,
  10,
  19,
  20,
  21,
  22,
  23,
  24,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  11,
  0,
  0,
  12,
  0,
  0,
  15,
  16,
  0,
  28,
  0,
  29,
  30,
  0,
  0,
  0,
  19,
  20,
  21,
  22,
  23,
  24,
  0,
  35,
  36,
  0,
  0,
  0,
  0,
  0,
  41,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  28,
  0,
  29,
  30,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  35,
  36,
  0,
  0,
  0,
  202,
  0,
  41,
  85,
  86,
  87,
  88,
  89,
  90,
  91,
  92,
  93,
  94,
  95,
  96,
  97,
  98,
  99,
  100,
  101,
  102,
  205,
  0,
  0,
  85,
  86,
  87,
  88,
  89,
  90,
  91,
  92,
  93,
  94,
  95,
  96,
  97,
  98,
  99,
  100,
  101,
  102,
  233,
  0,
  0,
  85,
  86,
  87,
  88,
  89,
  90,
  91,
  92,
  93,
  94,
  95,
  96,
  97,
  98,
  99,
  100,
  101,
  102,
  199,
  85,
  86,
  87,
  88,
  89,
  90,
  91,
  92,
  93,
  94,
  95,
  96,
  97,
  98,
  99,
  100,
  101,
  102,
  208,
  85,
  86,
  87,
  88,
  89,
  90,
  91,
  92,
  93,
  94,
  95,
  96,
  97,
  98,
  99,
  100,
  101,
  102,
  86,
  87,
  88,
  89,
  90,
  91,
  92,
  93,
  94,
  95,
  96,
  97,
  98,
  99,
  100,
  101,
  102,
  87,
  88,
  89,
  90,
  91,
  92,
  93,
  94,
  95,
  96,
  97,
  98,
  99,
  100,
  101,
  102,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0
}; // idb
__int16 word_815C540[] = { 40 }; // weak
int dword_815D548 = 1; // weak
char *off_815D560 = "userinfo"; // weak
int dword_815D6E0 = 2; // weak
int dword_815D6E4 = 1; // weak
_UNKNOWN unk_815D6E8; // weak
_UNKNOWN unk_815D6F4; // weak
int dword_815DE98 = 2309737967; // weak
int dword_815DEA0[] = { 0 }; // weak
char *off_815DF00[13] =
{
  "auto",
  "auto2d",
  "menu",
  "weapon",
  "voice",
  "item",
  "body",
  "local",
  "music",
  "announcer",
  "shellshock",
  "off",
  "on"
}; // weak
char *off_815DF2C[2] = { "off", "on" }; // weak
char *off_815DF30 = "on"; // weak
char *off_815DF40[14] =
{
  "+=",
  "-=",
  "*=",
  "/=",
  "&=",
  "|=",
  "++",
  "--",
  "&&",
  "||",
  "<=",
  ">=",
  "==",
  "!="
}; // weak
_UNKNOWN unk_815DF80; // weak
int dword_816294C[] = { 0 }; // weak
char *off_8162960 = "bark"; // weak
int dword_8162968[260] =
{
  1048576,
  0,
  0,
  135563781,
  0,
  2097152,
  0,
  0,
  135563787,
  0,
  3145728,
  0,
  0,
  135563794,
  0,
  4194304,
  0,
  0,
  135563800,
  0,
  5242880,
  0,
  0,
  135563809,
  0,
  6291456,
  0,
  0,
  135563814,
  0,
  7340032,
  0,
  0,
  135563820,
  1,
  8388608,
  2,
  0,
  135563828,
  1,
  9437184,
  16,
  0,
  135563834,
  0,
  10485760,
  0,
  0,
  135563840,
  0,
  11534336,
  0,
  0,
  135563847,
  0,
  12582912,
  0,
  0,
  135563851,
  0,
  13631488,
  0,
  0,
  135563857,
  0,
  14680064,
  0,
  0,
  135563861,
  0,
  15728640,
  0,
  0,
  135563867,
  0,
  16777216,
  0,
  0,
  135563875,
  0,
  17825792,
  0,
  0,
  135563880,
  0,
  18874368,
  0,
  0,
  135563885,
  0,
  19922944,
  0,
  0,
  135563890,
  1,
  20971520,
  32,
  0,
  135563896,
  0,
  22020096,
  0,
  0,
  135563901,
  0,
  23068672,
  0,
  0,
  135563909,
  0,
  9437184,
  0,
  0,
  135563921,
  1,
  0,
  128,
  0,
  135563933,
  1,
  0,
  4096,
  0,
  135563944,
  1,
  0,
  8192,
  0,
  135563953,
  1,
  0,
  65536,
  0,
  135563964,
  1,
  0,
  131072,
  0,
  135563976,
  1,
  0,
  512,
  0,
  135563988,
  1,
  0,
  1024,
  0,
  135563997,
  1,
  0,
  2147483648,
  0,
  135564004,
  1,
  16384,
  0,
  0,
  135564013,
  0,
  0,
  134217728,
  0,
  135564020,
  0,
  0,
  268435456,
  0,
  135564031,
  1,
  2147483648,
  0,
  0,
  135564038,
  0,
  0,
  64,
  0,
  135564051,
  1,
  0,
  0,
  4,
  135564058,
  0,
  4,
  2048,
  0,
  135564062,
  0,
  65536,
  0,
  0,
  135564074,
  0,
  262144,
  0,
  0,
  135564087,
  0,
  2,
  0,
  0,
  135564093,
  0,
  16,
  0,
  0,
  135564102,
  0,
  32,
  0,
  0,
  135564110,
  0,
  8,
  0,
  0,
  135564117,
  0,
  1,
  0,
  0,
  135564126,
  0,
  33554432,
  16777216,
  0,
  135564135,
  0,
  67108864,
  16777216,
  0,
  135564146,
  0,
  8192,
  0,
  0,
  135564154,
  0,
  128,
  0,
  0,
  135564161,
  0,
  2048,
  0,
  0,
  135564172,
  0,
  1024,
  0,
  0,
  135564183,
  0,
  131072,
  0,
  0,
  0,
  0
}; // idb
char *off_8162D84 = "1.1.4"; // weak
int dword_8162DA0 = 9; // weak
int dword_8162DA4 = 5; // weak
_UNKNOWN unk_8162DC0; // weak
_UNKNOWN unk_8163DC0; // weak
int dword_8163EC0[17] =
{
  0,
  1,
  3,
  7,
  15,
  31,
  63,
  127,
  255,
  511,
  1023,
  2047,
  4095,
  8191,
  16383,
  32767,
  65535
}; // idb
void *off_8163F04 = &unk_8149F40; // weak
void *off_8163F18 = &unk_814A3C0; // weak
_UNKNOWN unk_8163F2C; // weak
char *off_8163F50[5] =
{
  "stream error",
  "data error",
  "insufficient memory",
  "buffer error",
  "incompatible version"
}; // weak
char *off_8163F58[3] = { "insufficient memory", "buffer error", "incompatible version" }; // weak
char *off_8163F5C[2] = { "buffer error", "incompatible version" }; // weak
int dword_8163F80 = 1; // weak
int dword_8163F84 = 4294967295; // weak
char byte_8163FA0 = '\0'; // idb
char off_81643C0[] = { '`', '\xB2', '\x14', '\b' }; // idb
char *off_81643E0 = "RELAXED"; // weak
char *off_8164420 = "** UNUSED **"; // weak
char *off_8164580 = "PAIN"; // weak
char *off_8164620 = "** UNUSED **"; // weak
char *off_8164760 = "PLAYERANIMTYPE"; // weak
int dword_81647C0[] = { 0 }; // weak
int off_81647C4[16] =
{
  139942976,
  0,
  135677632,
  1,
  135677584,
  0,
  135676960,
  1,
  0,
  1,
  0,
  1,
  0,
  1,
  135677720,
  1
}; // idb
_UNKNOWN off_8164808; // weak
char *off_8164820 = "defines"; // weak
int dword_8164860[] = { 1 }; // weak
int dword_8164864[] = { 8 }; // weak
float flt_8164868[21] =
{
   57.0,
  ?flt,
  ?flt,
   51.0,
  ?flt,
  ?flt,
   45.0,
  ?flt,
  ?flt,
   39.0,
  ?flt,
  ?flt,
   33.0,
  ?flt,
  ?flt,
   27.0,
  ?flt,
  ?flt,
   21.0,
   0.0,
   0.0
}; // idb
char *off_81648C0 = "mp_mantle_root"; // idb
_UNKNOWN unk_8164C20; // weak
int dword_8164C28[] = { 0 }; // weak
int dword_8164C2C[] = { 0 }; // weak
int dword_8164C34[] = { 0 }; // weak
int dword_8164C3C[1441] =
{
  0,
  0,
  0,
  0,
  0,
  135584964,
  135584964,
  135584964,
  135584964,
  135584964,
  0,
  0,
  0,
  0,
  0,
  0,
  135584964,
  135584964,
  135584964,
  135584964,
  135584964,
  0,
  0,
  0,
  0,
  0,
  0,
  135584964,
  135584964,
  135584964,
  135584964,
  135584964,
  0,
  0,
  0,
  0,
  0,
  0,
  135584964,
  135584964,
  135584964,
  135584964,
  135584964,
  0,
  0,
  0,
  0,
  0,
  0,
  135584964,
  135584964,
  135584964,
  135584964,
  135584964,
  0,
  0,
  0,
  0,
  0,
  0,
  135584964,
  135584964,
  135584964,
  135584964,
  135584964,
  0,
  0,
  0,
  0,
  0,
  0,
  135584964,
  135584964,
  135584964,
  135584964,
  135584964,
  0,
  0,
  0,
  0,
  0,
  0,
  135584964,
  135584964,
  135584964,
  135584964,
  135584964,
  0,
  0,
  0,
  0,
  0,
  0,
  135584964,
  135584964,
  135584964,
  135584964,
  135584964,
  0,
  0,
  0,
  0,
  0,
  0,
  135584964,
  135584964,
  135584964,
  135584964,
  135584964,
  0,
  0,
  0,
  0,
  0,
  0,
  135584964,
  135584964,
  135584964,
  135584964,
  135584964,
  0,
  0,
  0,
  0,
  0,
  0,
  135584964,
  135584964,
  135584964,
  135584964,
  135584964,
  0,
  0,
  0,
  0,
  0,
  0,
  135584964,
  135584964,
  135584964,
  135584964,
  135584964,
  0,
  0,
  0,
  0,
  0,
  0,
  135584964,
  135584964,
  135584964,
  135584964,
  135584964,
  0,
  0,
  0,
  0,
  0,
  0,
  135584964,
  135584964,
  135584964,
  135584964,
  135584964,
  0,
  0,
  0,
  0,
  0,
  0,
  135584964,
  135584964,
  135584964,
  135584964,
  135584964,
  0,
  0,
  0,
  0,
  0,
  0,
  135584964,
  135584964,
  135584964,
  135584964,
  135584964,
  0,
  0,
  0,
  0,
  0,
  0,
  135584964,
  135584964,
  135584964,
  135584964,
  135584964,
  0,
  0,
  0,
  0,
  0,
  0,
  135584964,
  135584964,
  135584964,
  135584964,
  135584964,
  0,
  0,
  0,
  0,
  0,
  0,
  135584964,
  135584964,
  135584964,
  135584964,
  135584964,
  0,
  0,
  0,
  0,
  0,
  0,
  135584964,
  135584964,
  135584964,
  135584964,
  135584964,
  0,
  0,
  0,
  0,
  0,
  0,
  135584964,
  135584964,
  135584964,
  135584964,
  135584964,
  0,
  0,
  0,
  0,
  0,
  0,
  135584964,
  135584964,
  135584964,
  135584964,
  135584964,
  0,
  0,
  0,
  0,
  0,
  0,
  135584964,
  135584964,
  135584964,
  135584964,
  135584964,
  0,
  0,
  0,
  0,
  0,
  0,
  135584964,
  135584964,
  135584964,
  135584964,
  135584964,
  0,
  0,
  0,
  0,
  0,
  0,
  135584964,
  135584964,
  135584964,
  135584964,
  135584964,
  0,
  0,
  0,
  0,
  0,
  0,
  135584964,
  135584964,
  135584964,
  135584964,
  135584964,
  0,
  0,
  0,
  0,
  0,
  0,
  135584964,
  135584964,
  135584964,
  135584964,
  135584964,
  0,
  0,
  0,
  0,
  0,
  0,
  135584964,
  135584964,
  135584964,
  135584964,
  135584964,
  0,
  0,
  0,
  0,
  0,
  0,
  135584964,
  135584964,
  135584964,
  135584964,
  135584964,
  0,
  0,
  0,
  0,
  0,
  0,
  135584964,
  135584964,
  135584964,
  135584964,
  135584964,
  0,
  0,
  0,
  0,
  0,
  0,
  135584964,
  135584964,
  135584964,
  135584964,
  135584964,
  0,
  0,
  0,
  0,
  0,
  0,
  135584964,
  135584964,
  135584964,
  135584964,
  135584964,
  0,
  0,
  0,
  0,
  0,
  0,
  135584964,
  135584964,
  135584964,
  135584964,
  135584964,
  0,
  0,
  0,
  0,
  0,
  0,
  135584964,
  135584964,
  135584964,
  135584964,
  135584964,
  0,
  0,
  0,
  0,
  0,
  0,
  135584964,
  135584964,
  135584964,
  135584964,
  135584964,
  0,
  0,
  0,
  0,
  0,
  0,
  135584964,
  135584964,
  135584964,
  135584964,
  135584964,
  0,
  0,
  0,
  0,
  0,
  0,
  135584964,
  135584964,
  135584964,
  135584964,
  135584964,
  0,
  0,
  0,
  0,
  0,
  0,
  135584964,
  135584964,
  135584964,
  135584964,
  135584964,
  0,
  0,
  0,
  0,
  0,
  0,
  135584964,
  135584964,
  135584964,
  135584964,
  135584964,
  0,
  0,
  0,
  0,
  0,
  0,
  135584964,
  135584964,
  135584964,
  135584964,
  135584964,
  0,
  0,
  0,
  0,
  0,
  0,
  135584964,
  135584964,
  135584964,
  135584964,
  135584964,
  0,
  0,
  0,
  0,
  0,
  0,
  135584964,
  135584964,
  135584964,
  135584964,
  135584964,
  0,
  0,
  0,
  0,
  0,
  0,
  135584964,
  135584964,
  135584964,
  135584964,
  135584964,
  0,
  0,
  0,
  0,
  0,
  0,
  135584964,
  135584964,
  135584964,
  135584964,
  135584964,
  0,
  0,
  0,
  0,
  0,
  0,
  135584964,
  135584964,
  135584964,
  135584964,
  135584964,
  0,
  0,
  0,
  0,
  0,
  0,
  135584964,
  135584964,
  135584964,
  135584964,
  135584964,
  0,
  0,
  0,
  0,
  0,
  0,
  135584964,
  135584964,
  135584964,
  135584964,
  135584964,
  0,
  0,
  0,
  0,
  0,
  0,
  135584964,
  135584964,
  135584964,
  135584964,
  135584964,
  0,
  0,
  0,
  0,
  0,
  0,
  135584964,
  135584964,
  135584964,
  135584964,
  135584964,
  0,
  0,
  0,
  0,
  0,
  0,
  135584964,
  135584964,
  135584964,
  135584964,
  135584964,
  0,
  0,
  0,
  0,
  0,
  0,
  135584964,
  135584964,
  135584964,
  135584964,
  135584964,
  0,
  0,
  0,
  0,
  0,
  0,
  135584964,
  135584964,
  135584964,
  135584964,
  135584964,
  0,
  0,
  0,
  0,
  0,
  0,
  135584964,
  135584964,
  135584964,
  135584964,
  135584964,
  0,
  0,
  0,
  0,
  0,
  0,
  135584964,
  135584964,
  135584964,
  135584964,
  135584964,
  0,
  0,
  0,
  0,
  0,
  0,
  135584964,
  135584964,
  135584964,
  135584964,
  135584964,
  0,
  0,
  0,
  0,
  0,
  0,
  135584964,
  135584964,
  135584964,
  135584964,
  135584964,
  0,
  0,
  0,
  0,
  0,
  0,
  135584964,
  135584964,
  135584964,
  135584964,
  135584964,
  0,
  0,
  0,
  0,
  0,
  0,
  135584964,
  135584964,
  135584964,
  135584964,
  135584964,
  0,
  0,
  0,
  0,
  0,
  0,
  135584964,
  135584964,
  135584964,
  135584964,
  135584964,
  0,
  0,
  0,
  0,
  0,
  0,
  135584964,
  135584964,
  135584964,
  135584964,
  135584964,
  0,
  0,
  0,
  0,
  0,
  0,
  135584964,
  135584964,
  135584964,
  135584964,
  135584964,
  0,
  0,
  0,
  0,
  0,
  0,
  135584964,
  135584964,
  135584964,
  135584964,
  135584964,
  0,
  0,
  0,
  0,
  0,
  0,
  135584964,
  135584964,
  135584964,
  135584964,
  135584964,
  0,
  0,
  0,
  0,
  0,
  0,
  135584964,
  135584964,
  135584964,
  135584964,
  135584964,
  0,
  0,
  0,
  0,
  0,
  0,
  135584964,
  135584964,
  135584964,
  135584964,
  135584964,
  0,
  0,
  0,
  0,
  0,
  0,
  135584964,
  135584964,
  135584964,
  135584964,
  135584964,
  0,
  0,
  0,
  0,
  0,
  0,
  135584964,
  135584964,
  135584964,
  135584964,
  135584964,
  0,
  0,
  0,
  0,
  0,
  0,
  135584964,
  135584964,
  135584964,
  135584964,
  135584964,
  0,
  0,
  0,
  0,
  0,
  0,
  135584964,
  135584964,
  135584964,
  135584964,
  135584964,
  0,
  0,
  0,
  0,
  0,
  0,
  135584964,
  135584964,
  135584964,
  135584964,
  135584964,
  0,
  0,
  0,
  0,
  0,
  0,
  135584964,
  135584964,
  135584964,
  135584964,
  135584964,
  0,
  0,
  0,
  0,
  0,
  0,
  135584964,
  135584964,
  135584964,
  135584964,
  135584964,
  0,
  0,
  0,
  0,
  0,
  0,
  135584964,
  135584964,
  135584964,
  135584964,
  135584964,
  0,
  0,
  0,
  0,
  0,
  0,
  135584964,
  135584964,
  135584964,
  135584964,
  135584964,
  0,
  0,
  0,
  0,
  0,
  0,
  135584964,
  135584964,
  135584964,
  135584964,
  135584964,
  0,
  0,
  0,
  0,
  0,
  0,
  135584964,
  135584964,
  135584964,
  135584964,
  135584964,
  0,
  0,
  0,
  0,
  0,
  0,
  135584964,
  135584964,
  135584964,
  135584964,
  135584964,
  0,
  0,
  0,
  0,
  0,
  0,
  135584964,
  135584964,
  135584964,
  135584964,
  135584964,
  0,
  0,
  0,
  0,
  0,
  0,
  135584964,
  135584964,
  135584964,
  135584964,
  135584964,
  0,
  0,
  0,
  0,
  0,
  0,
  135584964,
  135584964,
  135584964,
  135584964,
  135584964,
  0,
  0,
  0,
  0,
  0,
  0,
  135584964,
  135584964,
  135584964,
  135584964,
  135584964,
  0,
  0,
  0,
  0,
  0,
  0,
  135584964,
  135584964,
  135584964,
  135584964,
  135584964,
  0,
  0,
  0,
  0,
  0,
  0,
  135584964,
  135584964,
  135584964,
  135584964,
  135584964,
  0,
  0,
  0,
  0,
  0,
  0,
  135584964,
  135584964,
  135584964,
  135584964,
  135584964,
  0,
  0,
  0,
  0,
  0,
  0,
  135584964,
  135584964,
  135584964,
  135584964,
  135584964,
  0,
  0,
  0,
  0,
  0,
  0,
  135584964,
  135584964,
  135584964,
  135584964,
  135584964,
  0,
  0,
  0,
  0,
  0,
  0,
  135584964,
  135584964,
  135584964,
  135584964,
  135584964,
  0,
  0,
  0,
  0,
  0,
  0,
  135584964,
  135584964,
  135584964,
  135584964,
  135584964,
  0,
  0,
  0,
  0,
  0,
  0,
  135584964,
  135584964,
  135584964,
  135584964,
  135584964,
  0,
  0,
  0,
  0,
  0,
  0,
  135584964,
  135584964,
  135584964,
  135584964,
  135584964,
  0,
  0,
  0,
  0,
  0,
  0,
  135584964,
  135584964,
  135584964,
  135584964,
  135584964,
  0,
  0,
  0,
  0,
  0,
  0,
  135584964,
  135584964,
  135584964,
  135584964,
  135584964,
  0,
  0,
  0,
  0,
  0,
  0,
  135584964,
  135584964,
  135584964,
  135584964,
  135584964,
  0,
  0,
  0,
  0,
  0,
  0,
  135584964,
  135584964,
  135584964,
  135584964,
  135584964,
  0,
  0,
  0,
  0,
  0,
  0,
  135584964,
  135584964,
  135584964,
  135584964,
  135584964,
  0,
  0,
  0,
  0,
  0,
  0,
  135584964,
  135584964,
  135584964,
  135584964,
  135584964,
  0,
  0,
  0,
  0,
  0,
  0,
  135584964,
  135584964,
  135584964,
  135584964,
  135584964,
  0,
  0,
  0,
  0,
  0,
  0,
  135584964,
  135584964,
  135584964,
  135584964,
  135584964,
  0,
  0,
  0,
  0,
  0,
  0,
  135584964,
  135584964,
  135584964,
  135584964,
  135584964,
  0,
  0,
  0,
  0,
  0,
  0,
  135584964,
  135584964,
  135584964,
  135584964,
  135584964,
  0,
  0,
  0,
  0,
  0,
  0,
  135584964,
  135584964,
  135584964,
  135584964,
  135584964,
  0,
  0,
  0,
  0,
  0,
  0,
  135584964,
  135584964,
  135584964,
  135584964,
  135584964,
  0,
  0,
  0,
  0,
  0,
  0,
  135584964,
  135584964,
  135584964,
  135584964,
  135584964,
  0,
  0,
  0,
  0,
  0,
  0,
  135584964,
  135584964,
  135584964,
  135584964,
  135584964,
  0,
  0,
  0,
  0,
  0,
  0,
  135584964,
  135584964,
  135584964,
  135584964,
  135584964,
  0,
  0,
  0,
  0,
  0,
  0,
  135584964,
  135584964,
  135584964,
  135584964,
  135584964,
  0,
  0,
  0,
  0,
  0,
  0,
  135584964,
  135584964,
  135584964,
  135584964,
  135584964,
  0,
  0,
  0,
  0,
  0,
  0,
  135584964,
  135584964,
  135584964,
  135584964,
  135584964,
  0,
  0,
  0,
  0,
  0,
  0,
  135584964,
  135584964,
  135584964,
  135584964,
  135584964,
  0,
  0,
  0,
  0,
  0,
  0,
  135584964,
  135584964,
  135584964,
  135584964,
  135584964,
  0,
  0,
  0,
  0,
  0,
  0,
  135584964,
  135584964,
  135584964,
  135584964,
  135584964,
  0,
  0,
  0,
  0,
  0,
  0,
  135584964,
  135584964,
  135584964,
  135584964,
  135584964,
  0,
  0,
  0,
  0,
  0,
  0,
  135584964,
  135584964,
  135584964,
  135584964,
  135584964,
  0,
  0,
  0,
  0,
  0,
  0,
  135584964,
  135584964,
  135584964,
  135584964,
  135584964,
  0,
  0,
  0,
  0,
  0,
  0,
  135584964,
  135584964,
  135584964,
  135584964,
  135584964,
  0,
  0,
  0,
  0,
  0,
  0,
  135584964,
  135584964,
  135584964,
  135584964,
  135584964,
  0,
  0,
  0,
  0,
  0,
  0,
  135584964,
  135584964,
  135584964,
  135584964,
  135584964,
  0,
  0,
  0,
  0,
  0,
  0,
  135584964,
  135584964,
  135584964,
  135584964,
  135584964,
  0,
  0,
  0,
  0,
  0,
  0,
  135584964,
  135584964,
  135584964,
  135584964,
  135584964,
  0,
  0,
  0,
  0,
  0,
  0,
  135584964,
  135584964,
  135584964,
  135584964,
  135584964,
  0,
  0,
  0,
  0,
  0,
  0,
  135584964,
  135584964,
  135584964,
  135584964,
  135584964,
  0,
  0,
  0,
  0,
  0,
  0,
  135584964,
  135584964,
  135584964,
  135584964,
  135584964,
  0,
  0,
  0,
  0,
  0,
  0,
  135584964,
  135584964,
  135584964,
  135584964,
  135584964,
  0,
  0,
  0,
  0,
  0,
  0,
  135584964,
  135584964,
  135584964,
  135584964,
  135584964,
  0,
  0,
  0,
  0,
  0,
  0,
  135584964,
  135584964,
  135584964,
  135584964,
  135584964,
  0,
  0,
  0,
  0,
  0,
  0,
  135584964,
  135584964,
  135584964,
  135584964,
  135584964,
  0,
  0,
  0,
  0,
  0,
  0,
  135584964,
  135584964,
  135584964,
  135584964,
  135584964,
  0,
  0,
  0,
  0,
  0,
  135584965,
  135584983,
  135585003,
  0,
  135585023,
  135585041,
  10,
  3,
  0,
  0,
  0,
  135585054,
  135585072,
  135585092,
  0,
  135585112,
  135585130,
  50,
  3,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0
}; // idb
_UNKNOWN unk_81662E0; // weak
_UNKNOWN unk_8166360; // weak
_UNKNOWN unk_81663E0; // weak
_UNKNOWN unk_81664C0; // weak
int (__cdecl *off_8166520)(void *s, int, int, int, int, int, int) = &sub_80F15AA; // weak
int dword_8166528[] = { 0 }; // weak
char *off_8166540[15] =
{
  "bullet",
  "grenade",
  "projectile",
  "binoculars",
  "none",
  "primary",
  "primaryb",
  "grenade",
  "rocket",
  "none",
  "none",
  "crosshair",
  "FG42",
  "Springfield",
  "binoculars"
}; // weak
char *off_8166550 = "none"; // idb
char *off_816655C[8] =
{
  "grenade",
  "rocket",
  "none",
  "none",
  "crosshair",
  "FG42",
  "Springfield",
  "binoculars"
}; // weak
char *off_8166568[5] = { "none", "crosshair", "FG42", "Springfield", "binoculars" }; // weak
char *off_8166580[17] =
{
  "rifle",
  "mg",
  "smg",
  "spread",
  "pistol",
  "grenade",
  "rocketlauncher",
  "turret",
  "non-player",
  "item",
  "stand",
  "duck",
  "prone",
  "None",
  "Frag Grenade",
  "Smoke Grenade",
  "displayName"
}; // weak
char *off_81665A8[7] =
{
  "stand",
  "duck",
  "prone",
  "None",
  "Frag Grenade",
  "Smoke Grenade",
  "displayName"
}; // weak
char *off_81665B4[4] = { "None", "Frag Grenade", "Smoke Grenade", "displayName" }; // weak
char *off_81665C0 = "displayName"; // weak
char *off_81676E8[2] = { "aivsai", "aivsplayer" }; // weak
_UNKNOWN unk_81676F4; // weak
_UNKNOWN unk_8167700; // weak
_UNKNOWN unk_816770C; // weak
char *off_8167718 = "GAME_GC_HOLDYOURPOSITION"; // idb
char *off_8167740 = "none"; // idb
_UNKNOWN unk_816778C; // weak
_UNKNOWN unk_816779F; // weak
char *off_81677C0 = "MOD_UNKNOWN"; // idb
char *off_8167800[9] =
{
  "default",
  "bigfixed",
  "smallfixed",
  "left",
  "center",
  "right",
  "top",
  "middle",
  "bottom"
}; // weak
char *off_816780C[6] = { "left", "center", "right", "top", "middle", "bottom" }; // weak
char *off_8167818[3] = { "top", "middle", "bottom" }; // weak
char *off_8167840[16] =
{
  "subleft",
  "left",
  "center",
  "right",
  "fullscreen",
  "noscale",
  "alignto640",
  "center_safearea",
  "subtop",
  "top",
  "middle",
  "bottom",
  "fullscreen",
  "noscale",
  "alignto480",
  "center_safearea"
}; // weak
char *off_8167860[8] =
{
  "subtop",
  "top",
  "middle",
  "bottom",
  "fullscreen",
  "noscale",
  "alignto480",
  "center_safearea"
}; // weak
int dword_8167880[] = { 0 }; // weak
int dword_8167884[] = { 0 }; // weak
int dword_8167888[] = { 0 }; // weak
int dword_816788C[] = { 0 }; // weak
int dword_8167890[] = { 0 }; // weak
int dword_8167894[] = { 0 }; // weak
int dword_8167898[] = { 0 }; // weak
int dword_816789C[] = { 0 }; // weak
int dword_81678A0[] = { 0 }; // weak
int dword_81678A4[190] =
{
  0,
  0,
  0,
  0,
  135373278,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  135374338,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  135374076,
  135374338,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  135375058,
  135375106,
  135375172,
  0,
  0,
  0,
  0,
  135357856,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  135357856,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  135312600,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  3,
  4,
  135312600,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  5,
  6,
  0,
  0,
  0,
  0,
  0,
  0,
  135262922,
  135220038,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  135262922,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  135220038,
  0,
  0,
  135242972,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  135305832,
  0,
  0,
  0,
  135307078,
  0,
  0,
  135306358,
  0,
  0,
  135305686,
  0,
  0,
  0,
  135307078,
  0,
  0,
  135306358,
  0,
  0,
  135281824,
  0,
  0,
  135280624,
  0,
  0,
  0,
  0,
  0,
  0,
  135284224,
  0,
  0,
  135280624,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  135280624,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  135322034,
  0,
  0,
  0,
  0,
  0,
  135383488,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0
}; // idb
char off_8167BA0[] = { '', '=', '\x15', '\b' }; // idb
char *off_8167BC0 = "print"; // weak
int (*off_8167BC4)() = &sub_810E18C; // weak
int dword_8167BC8[] = { 1 }; // weak
char *off_8168280 = "attach"; // weak
int (__cdecl *off_8168284)(int) = &sub_810EFCA; // weak
int dword_8168288[] = { 0 }; // weak
char *off_8168560 = "info_null"; // weak
char byte_8168610 = '\x01'; // weak
void *off_8168614 = &unk_89A2D00; // weak
void *off_8168618 = &unk_89A9E00; // weak
void *off_816861C = &unk_89ABA80; // weak
int off_8168620 = 144401376; // idb
char *off_8168640 = "english"; // weak
int g_languages[] = { 0 }; // weak
_UNKNOWN unk_81686B0; // weak
int (*off_8185784)() = &ctor_003; // weak
int dword_8185794 = 0; // weak
FILE *stdout; // idb
FILE *stderr; // idb
int _ctype_b; // weak
int stdin; // weak
char byte_8185A6C; // weak
_UNKNOWN unk_8185A70; // weak
int dword_8185AA0; // weak
int dword_8185AA4; // idb
char *dword_8185AC0[66]; // idb
void *dword_8185BC8; // idb
size_t dword_8185BCC; // idb
int dword_8185BD0; // weak
char *dest; // idb
int dword_8185BE4; // weak
int dword_8185BE8; // weak
int dword_8185BEC; // weak
void *dword_8185BF0; // idb
int dword_8185BF4; // weak
int dword_8185BF8; // weak
int dword_8185BFC; // weak
int dword_8185C00; // weak
int dword_8185C04; // weak
int dword_8185C08; // weak
int dword_8185C0C; // weak
void *dword_8185C10; // idb
int dword_8185C14; // weak
int dword_8185C18; // weak
int dword_8185C1C; // weak
int dword_8185C20; // weak
int dword_8185C24; // weak
int dword_8185C28; // weak
int dword_8185C2C; // weak
int dword_8185C30; // weak
int dword_8185C34; // weak
int dword_8185C38; // weak
int dword_8185C3C; // weak
int dword_8185C40; // weak
int dword_8185C44; // weak
int dword_8185C48; // weak
int dword_8185C4C; // weak
int dword_8185C50; // weak
int dword_8185C54; // weak
int dword_8185C58; // weak
__int16 word_8185C5C; // weak
int dword_8185C60; // weak
int dword_8185C64; // weak
size_t n; // idb
void *dword_8185C6C; // idb
int dword_8185C70; // weak
int dword_8185C74; // weak
void *dword_8185C78; // idb
int dword_8185C7C; // weak
_UNKNOWN unk_8185C80; // weak
int dword_8185CA0; // weak
int dword_8185CA4; // weak
_UNKNOWN unk_8185CA8; // weak
_UNKNOWN unk_8185CB4; // weak
int dword_8185CC0; // weak
int dword_8185CEC; // weak
int dword_8185CF4; // weak
int dword_8185CF8; // weak
int dword_8185CFC; // weak
void *dword_8185D00; // idb
int dword_8185D0C; // weak
int dword_8185D10; // weak
float flt_8185D14; // weak
float flt_8185D80[3]; // idb
float flt_8185D8C[3]; // idb
char byte_8185D98; // weak
__int16 word_8185D9A; // weak
int dword_8185D9C[]; // weak
int dword_8185DA0[]; // weak
_UNKNOWN unk_8185DA4; // weak
_UNKNOWN unk_8185DA6; // weak
_UNKNOWN unk_8185DA8; // weak
_UNKNOWN unk_8185DAC; // weak
__int16 word_8185DAE[]; // weak
char algn_8185DB0[16]; // weak
float flt_8185DC0; // weak
__int16 word_8185DC4; // weak
__int16 word_818BD96; // weak
int dword_818BE00; // weak
int dword_818BE04[]; // weak
int dword_818BE08[]; // weak
int dword_818BE0C[]; // weak
_UNKNOWN unk_818BE80; // weak
int dword_819BE80; // weak
char *dword_819BF00[512]; // idb
_UNKNOWN unk_819C700; // weak
int dword_819E900; // weak
char byte_819E980; // idb
int com_errorType; // weak
int logfile; // weak
int com_viewlog; // weak
int com_developer; // weak
int com_developer_script; // weak
int com_timescale; // weak
float flt_819EF08; // weak
int com_fixedtime; // weak
int com_maxfps; // weak
int com_sv_running; // weak
int com_logfile; // weak
int version; // idb
int shortversion; // weak
int com_introPlayed; // weak
int cl_paused; // weak
int nextmap; // idb
int dword_819EF30; // weak
int sv_paused; // weak
int com_animCheck; // weak
int sv.start_frameTime; // weak
int dword_819EF44; // weak
int com_codeTimeScale; // weak
int com_frameNumber; // weak
int com_errorEntered; // weak
int com_fixedConsolePosition; // weak
int com_fullyInitialized; // weak
char com_errorMessage[4095]; // idb
char byte_819FF7F; // weak
int ui_errorMessage; // idb
int ui_errorTitle; // weak
int dword_819FF88; // weak
int dword_819FF8C; // weak
int dword_81A0000[]; // weak
int dword_81A0004[]; // weak
int dword_81A0008[]; // weak
int dword_81A000C[]; // weak
int dword_81A0010[]; // weak
int dword_81A0014[]; // weak
int dword_81A1C88; // weak
int dword_81A1C90; // weak
char *dword_81A1C94; // idb
int dword_81A1C98; // idb
int (__cdecl *dword_81A1C9C)(_DWORD); // weak
int dword_81A1CA0; // weak
int currentTime; // weak
int errorCount; // weak
int dword_81A1CB0; // weak
char *dword_81A1CC0[32]; // idb
int dword_81A1D40; // weak
_UNKNOWN unk_81D3D80; // weak
int dword_81D4580; // weak
__int16 word_81D4600[1152]; // idb
__int16 word_81D4F00[1024]; // idb
int dword_81D5700; // weak
int dword_81D5704; // weak
char byte_81D5780; // idb
char byte_81D5B80; // idb
char byte_81D7D00; // idb
char byte_81D9D00; // idb
char byte_81DBD00; // idb
char byte_81DDD00; // idb
char byte_81DFD00; // idb
char byte_81DFD01[]; // weak
char byte_81DFD02[16382]; // idb
char byte_81E3D00; // idb
_UNKNOWN unk_81E5D00; // weak
_UNKNOWN unk_81E6100; // weak
int dword_81E6144; // weak
_UNKNOWN unk_81E6860; // weak
_UNKNOWN unk_81ED87C; // weak
int dword_81ED884; // weak
int dword_81F4898; // weak
_UNKNOWN unk_81F48A0; // weak
char byte_81F4C9F; // weak
_UNKNOWN unk_81F4CA0; // weak
char byte_81F6C9F; // weak
_UNKNOWN unk_81F6CA0; // weak
char byte_81F709F; // weak
int dword_81F7100; // weak
int dword_81F7104; // weak
int dword_81F7108; // weak
int dword_81F710C; // weak
int dword_81F7110; // weak
int dword_81F7114; // weak
int dword_81F7118; // weak
int dword_81F711C; // weak
_UNKNOWN unk_81F7180; // weak
char byte_82021A0[64]; // idb
_UNKNOWN unk_82021E0; // weak
int dword_8202218; // weak
int dword_8202220; // weak
int dword_8202224; // weak
__int16 word_8202228[256]; // idb
int dword_8202428; // weak
int dword_8202440; // weak
int dword_8202444; // idb
int dword_8202448; // weak
int dword_820244C[128]; // idb
int dword_820264C[128]; // idb
int dword_820284C[]; // weak
int dword_8202850; // weak
int dword_8202854; // weak
char byte_8202858; // weak
int dword_8202860; // weak
int dword_8202864; // weak
int dword_8202868; // weak
int dword_820286C; // weak
int dword_8202870; // weak
int dword_8202874; // weak
int dword_8202878; // weak
char byte_820287C; // weak
char byte_820287D; // weak
int dword_8202880; // idb
char byte_8202884; // weak
char byte_8202885; // weak
char byte_8202886; // weak
int dword_8202888; // weak
char byte_820288C; // weak
char byte_820288D; // weak
int dword_8202890; // weak
char byte_8202894; // weak
char byte_8202895; // weak
int dword_8202898; // weak
int dword_820289C; // weak
int dword_82028A0; // weak
int dword_82028A4; // weak
int dword_82028A8; // weak
int dword_82028AC; // weak
char byte_82028B0; // weak
int dword_82028B4; // weak
int dword_82028B8; // weak
int dword_82028BC[]; // weak
int dword_82028C0[]; // weak
int dword_82028C4[]; // weak
int dword_8202A40; // weak
int dword_8202A44; // weak
int dword_8202A48; // weak
int dword_8202A4C; // weak
int dword_8202A50; // weak
int dword_8202A54; // weak
int dword_8202A58; // weak
int dword_8202A5C; // weak
int dword_8202A60; // weak
char byte_8202A64; // weak
char byte_8202A65; // weak
int dword_8202A68; // weak
int dword_8202A6C; // weak
int dword_8202A70; // weak
int dword_8202A74; // weak
int dword_8202A78[1058]; // idb
int dword_8203B00[]; // weak
int dword_8203B04[131070]; // idb
_BYTE byte_8283B00[512]; // idb
char byte_8283D00[]; // weak
__int16 word_8283E00[18]; // idb
int dword_8283E24; // weak
char dword_8283E28[]; // idb
int dword_8283E80; // weak
void *dword_8283EA0; // idb
int dword_8283EA4; // weak
int dword_8283EA8; // weak
void *dword_8283EAC; // idb
int dword_8283EB0; // weak
int dword_8283EB4; // weak
int dword_8283EB8; // weak
int dword_8283EBC; // weak
int dword_8283EC0; // weak
void *dword_8283EC4; // idb
int dword_8283EC8; // weak
int dword_8283ECC; // weak
int dword_8283ED0; // weak
void *dword_8283ED4; // idb
int dword_8283ED8; // weak
char dword_8283EDC[]; // idb
char dword_8283EE0[]; // idb
__int16 word_8283F00[]; // weak
__int16 word_8283F02[32766]; // idb
char byte_8293F00; // weak
int dword_8293F04; // weak
int dword_8293F84; // weak
__int16 word_8294000[]; // weak
__int16 word_8294002[]; // weak
int dword_8294004[]; // weak
int dword_8294008[]; // weak
__int16 word_829400C[]; // weak
__int16 word_829400E[524280]; // idb
int dword_8394000; // weak
int dword_8394004; // weak
__int16 word_8394008; // weak
char byte_839400A; // weak
char byte_839400B; // weak
char byte_839400C; // weak
char dword_8394010[]; // idb
int dword_8394014; // weak
int dword_8394018; // weak
int dword_839401C; // weak
int dword_8394020; // weak
int dword_8394024; // weak
int dword_8394028; // weak
int dword_839402C; // weak
int dword_8394030; // weak
int dword_8394034; // weak
char byte_8394038; // weak
int dword_839403C; // weak
int dword_8394040; // weak
int dword_8394044; // weak
int dword_8394048; // weak
int dword_839404C; // weak
_UNKNOWN unk_83D4100; // weak
int dword_83D553C; // weak
int dword_83D5580; // weak
int dword_83D5584; // weak
int dword_83D5590; // weak
int dword_83D5594; // weak
int dword_83D5598; // weak
int dword_83D7600; // weak
int dword_83D7604; // weak
int dword_83D7608; // weak
int dword_83D760C; // weak
int dword_83D7610; // weak
char byte_83D7614; // weak
char byte_83D7615; // weak
char byte_83D7616; // weak
int dword_83D7618; // weak
int dword_83D761C; // weak
int dword_83D7620[]; // weak
int dword_83D7624[]; // weak
int dword_83D7628[186]; // idb
_UNKNOWN unk_83D7920; // weak
int dword_83D7924; // weak
_UNKNOWN unk_83DB918; // weak
int dword_83DB9A0; // idb
int dword_83DB9A4; // weak
int dword_83DB9A8; // weak
FILE *stream; // idb
FILE *dword_83DB9B0; // idb
int dword_83DB9B4; // weak
int dword_83DB9B8; // weak
int dword_83DB9BC; // idb
char byte_83DB9C0; // weak
int dword_83DB9C4; // weak
char byte_83DB9C8; // weak
int dword_83DB9CC; // weak
int dword_83DB9D0; // weak
int dword_83DB9D4; // weak
int dword_83DB9D8; // weak
_UNKNOWN unk_83DB9E0; // weak
int dword_83DF9E8; // weak
int dword_83DF9EC; // weak
int dword_83DFA00; // weak
_UNKNOWN unk_83DFA8F; // weak
int dword_841FA80; // weak
int dword_841FA84; // weak
int dword_841FA88; // weak
int dword_841FB00; // weak
int dword_841FB04; // idb
int dword_841FB08; // weak
void *dword_841FB0C; // idb
int dword_841FB10; // weak
int dword_841FB14; // weak
int dword_841FB18; // weak
int dword_841FB1C; // weak
int dword_841FB20; // weak
int dword_841FB24; // weak
int dword_841FB28; // weak
int dword_841FB2C; // weak
void *dword_841FB30; // idb
void *dword_841FB34; // idb
int dword_841FB38; // weak
int dword_841FB3C; // weak
int dword_841FB40; // weak
int dword_841FB44; // weak
void *dword_841FB48; // idb
void *dword_841FB4C; // idb
void *dword_841FB50; // idb
int dword_841FB54; // weak
int dword_841FB58; // weak
int dword_841FB5C[]; // weak
int dword_841FB60[]; // weak
int dword_841FB64[]; // weak
int dword_841FB68[]; // weak
int dword_841FB6C[]; // weak
int dword_841FB70[]; // weak
int dword_841FB78[]; // weak
int dword_841FB80[]; // weak
int dword_841FB84[]; // weak
int dword_841FB88[1332]; // idb
_UNKNOWN unk_8421085; // weak
int dword_842BB5C; // idb
int dword_842BB60; // idb
__int16 dword_842BB64; // idb
int dword_842BB68; // idb
int dword_842BB6C; // idb
int dword_842BB70; // idb
int dword_842BB74; // idb
__int16 dword_842BB78; // idb
int dword_842BB7C; // idb
int dword_842BB80; // idb
int dword_842BB84; // weak
int dword_842BB88[]; // weak
int dword_842BB8C[60]; // idb
int dword_842BC80; // weak
int dword_842BC84; // weak
int dword_842BC88; // weak
int dword_842BC8C; // weak
int dword_842BC90; // weak
char *dword_842C098[2049]; // idb
_UNKNOWN unk_842DF24; // weak
_UNKNOWN unk_842DF26; // weak
_UNKNOWN unk_842E084; // weak
_UNKNOWN unk_842E09C; // weak
int dword_842E18C[]; // weak
int dword_842E190[]; // weak
int dword_842E194[95139]; // idb
int dword_848B098; // weak
int dword_848B09C; // weak
int dword_848B0A0; // weak
int dword_848B0A4; // weak
int dword_848B0A8; // weak
int dword_848B0AC; // weak
int dword_848B0B0; // weak
int dword_848B0B4; // weak
int dword_848B0B8[]; // weak
int dword_848B0BC[18]; // idb
int dword_848B104; // weak
int dword_848B108; // weak
int dword_848B10C; // weak
int dword_848B110; // weak
int dword_848B114[]; // weak
int dword_848B118[18]; // idb
int dword_848B160; // weak
int dword_848B164; // weak
int dword_848B168; // weak
float flt_848B16C; // weak
int dword_848B170; // weak
char byte_848B174[64]; // idb
int dword_848B1B4; // weak
int dword_848B1B8; // weak
int dword_848B1BC; // weak
int dword_848B1C0; // weak
int dword_848B1C4; // weak
int dword_848B1C8; // weak
int dword_848B1CC; // weak
int dword_848B1D0; // weak
int dword_848B1D4; // weak
int dword_848B1D8; // weak
int dword_848B1DC; // weak
int dword_848B1E0; // weak
int dword_848B1E4; // weak
int dword_848B1E8; // weak
int dword_848B1EC; // weak
int dword_848B1F0; // weak
int dword_848B1F4; // idb
int dword_848B1F8; // weak
int dword_848B1FC; // weak
int dword_848B200; // weak
int dword_848B204; // weak
int dword_848B208; // weak
int dword_848B20C; // weak
int dword_848B210; // weak
int dword_848B214; // weak
int dword_848B218; // weak
int dword_848B21C; // weak
int dword_848B220; // idb
int dword_848B224; // weak
int dword_848B228; // weak
int dword_848B22C; // weak
int dword_848B230; // weak
int dword_848B234; // idb
int dword_848B238; // idb
int dword_848B23C; // idb
int dword_848B240; // idb
int dword_848B244; // weak
int dword_848B248; // weak
_BYTE byte_848B260[1024]; // idb
int dword_848B660; // weak
char byte_848B664; // weak
char byte_848B665; // weak
char byte_848B666; // weak
char byte_848B667; // weak
__int16 word_848B668; // weak
int dword_848B674; // weak
char byte_848B67C; // weak
int dword_848B6A0; // weak
int fs_loadStack; // weak
char byte_848B6C0[256]; // idb
int fs_debug; // weak
int fs_homepath; // weak
int fs_basepath; // idb
int fs_basegame; // weak
int fs_useOldAssets; // weak
int fs_cdpath; // weak
int fs_copyfiles; // weak
int fs_gameDirVar; // idb
int fs_restrict; // weak
int fs_ignoreLocalized; // weak
void *fs_searchpaths; // idb
char fs_packFiles[]; // idb
char dword_848B7F0[]; // idb
int fs_checksumFeed; // weak
int dword_848B800[]; // weak
int dword_848B804[]; // weak
int dword_848B808[]; // weak
int dword_848B80C[]; // weak
int dword_848B810[]; // weak
int dword_848B814[]; // weak
int dword_848B818[4473]; // idb
int fs_numServerIwds; // weak
int dword_848FF20[1024]; // idb
void *dword_8490F20[1024]; // idb
int dword_8491F20; // weak
int dword_8491F40[1024]; // idb
char *dword_8492F40[1024]; // idb
char lastValidBase; // idb
char lastValidGame; // idb
_UNKNOWN unk_8494136; // weak
char byte_8494140[128]; // idb
int dword_84941C0; // weak
int com_dedicated; // weak
int dword_8494220[1024]; // idb
int dword_8495220; // weak
int g_largeLocalPos; // weak
_UNKNOWN unk_8495280; // weak
char hunk_low.permanent[]; // idb
char hunk_low.temp[]; // idb
char hunk_high.permanent[]; // idb
char hunk_high.temp[]; // idb
int dword_8515294; // weak
void *dword_8515298; // idb
size_t s_hunkTotal; // idb
int dword_85152C4; // weak
int dword_85152C8[1025]; // idb
int dword_85162CC[]; // weak
int dword_85162D0[]; // weak
int dword_85162D8; // weak
int dword_85162DC; // weak
int dword_85162E0; // weak
int dword_85162E4; // weak
int dword_85162E8; // weak
int dword_85162EC; // weak
int dword_85162F0; // weak
int dword_85162F4; // weak
int dword_8516300; // weak
int dword_8516304; // weak
int dword_8516308; // weak
int dword_851630C; // weak
char byte_8516350; // weak
_UNKNOWN unk_8516354; // weak
int dword_8516BE0; // weak
int dword_8516BE4; // weak
_UNKNOWN unk_8516BE8; // weak
float dword_8516C28[527]; // idb
char byte_8517468; // weak
char byte_8517469; // weak
char byte_8517480[1056]; // idb
int sortedDvars; // weak
int dword_85178A4; // weak
int dvar_modifiedFlags; // weak
_UNKNOWN unk_85178C0; // weak
char dword_8522CC0[]; // idb
int dword_8522CE0[256]; // idb
_UNKNOWN unk_85230E0; // weak
int dword_8523110; // weak
char isDvarSystemActive; // weak
char isLoadingAutoExecGlobalFlag; // weak
int loc_language; // weak
int loc_forceEnglish; // weak
int loc_translate; // weak
int loc_warnings; // weak
int loc_warningsAsErrors; // weak
_UNKNOWN unk_8523A1C; // weak
_UNKNOWN unk_8523A40; // weak
int (__cdecl *dword_8527A40)(_DWORD); // weak
int (__cdecl *dword_8527A44)(_DWORD); // weak
int (__cdecl *dword_8527A48)(_DWORD); // weak
int (__cdecl *dword_8527A4C)(_DWORD); // weak
int (__cdecl *dword_8527A50)(_DWORD, _DWORD); // weak
int (__cdecl *dword_8527A54)(_DWORD); // weak
int (__cdecl *dword_8527A58)(_DWORD); // weak
int dword_8527A5C; // weak
int dword_8527A68; // weak
_UNKNOWN unk_8527A80; // weak
__int16 word_8527A88[]; // weak
__int16 word_8527A8A[]; // weak
int dword_8527A8C[]; // weak
int dword_8527A90[]; // weak
__int16 word_8527A94; // weak
__int16 word_8527A96[]; // weak
_UNKNOWN unk_8527A98; // weak
int dword_8527A9C[]; // weak
int dword_8527AA0[]; // weak
int dword_8527AA4[40950]; // idb
int dword_854FA80; // idb
_UNKNOWN unk_854FAA0; // weak
_DWORD dword_854FAAC[381]; // idb
int dword_85500A0; // weak
char byte_85500A4; // weak
_UNKNOWN unk_85500C0; // weak
_UNKNOWN unk_85500C4; // weak
_UNKNOWN unk_85500CC; // weak
_UNKNOWN unk_8550130; // weak
_DWORD dword_8550144[10]; // idb
char byte_855016C; // weak
__int16 word_855016E; // weak
char byte_8550180[]; // weak
float flt_8550184[16]; // idb
int saved_euid; // weak
int dword_85501C8; // weak
int dword_85501CC; // weak
int dword_85501D0; // weak
int dword_85501D4; // weak
int dword_85501D8; // weak
struct termios termios_p; // idb
int dword_8550220; // weak
_UNKNOWN unk_8550228; // weak
char byte_8550238; // idb
_DWORD dword_8550340[2240]; // idb
int dword_8552640; // weak
int dword_8552644; // weak
int dword_8552648; // weak
char buf[256]; // idb
int dword_8552760[]; // weak
int dword_8552764[]; // weak
int dword_8552768[]; // weak
int dword_855276C[]; // weak
int dword_8552770[]; // weak
int dword_8552774[]; // weak
int dword_8553F60; // weak
int dword_8553F64; // weak
_UNKNOWN unk_8553F80; // weak
int dword_8557F80; // weak
int fd; // idb
int dword_8557F9C; // weak
int dword_8557FA0; // weak
char byte_8557FC0[]; // weak
char byte_8557FC1[]; // weak
char byte_8557FC2[]; // weak
char byte_8557FC3[8316]; // idb
char byte_855A040[64]; // idb
char byte_855A080[256]; // idb
char byte_855A180; // idb
char path; // idb
int dword_855A380; // weak
int dword_855A384; // weak
char byte_855A3A0[255]; // idb
char byte_855A49F; // weak
int dword_855A4A0[5]; // idb
int dword_855A4B4; // weak
int dword_855A4B8; // weak
void *dword_855A4E0; // idb
int dword_855A4E4; // weak
int dword_855A500[]; // weak
_UNKNOWN unk_855A540; // weak
int dword_855CC50; // weak
int dword_855CC60[]; // weak
int dword_855CC64[286]; // idb
int dword_855D0E0[]; // weak
int dword_855D0E4[286]; // idb
int dword_855D560; // weak
int dword_855D564; // weak
int dword_855D568; // weak
int dword_855D56C; // weak
_UNKNOWN unk_855D580; // weak
int dword_8575C20; // weak
int dword_8575C40[]; // weak
int dword_8575C44[254]; // idb
int dword_8576040; // weak
int dword_8576044; // weak
int dword_8576048; // weak
int dword_857604C; // weak
int dword_8576050; // weak
int dword_8576054; // weak
int dword_8576058; // weak
int dword_857605C; // weak
int dword_8576060; // weak
int dword_8576064; // weak
int dword_8576068; // weak
int dword_857606C; // idb
int dword_8576074; // weak
int dword_8576078; // weak
int dword_857607C; // weak
int dword_8576080; // weak
int dword_8576084; // weak
int dword_8576088; // weak
int dword_857608C; // weak
int dword_8576090; // weak
int dword_8576094; // weak
int dword_8576098; // weak
int dword_857609C; // weak
int dword_85760A0; // weak
int dword_85760A4; // weak
int dword_85760A8; // weak
int dword_85760AC; // weak
int dword_85760B0; // weak
int dword_85760B4; // weak
int dword_85760B8; // weak
int dword_85760BC; // weak
int dword_85760C0; // weak
int dword_85760C4; // weak
int dword_85760C8; // weak
int dword_85760CC; // weak
int dword_85760D0; // weak
int dword_85760D4; // weak
int dword_85760D8; // weak
int dword_85760DC; // weak
int dword_85760E0; // weak
int dword_85760E4; // weak
int dword_85760E8; // weak
int dword_85760EC; // weak
int dword_85760F0; // weak
int dword_85760F4; // weak
int dword_85760F8; // weak
int dword_85760FC; // weak
int dword_8576100; // weak
int dword_8576104; // weak
int dword_8576108; // weak
int dword_857610C; // weak
int dword_8576110; // weak
int dword_8576114; // weak
int dword_8576118; // weak
int dword_857611C; // weak
int dword_8576120; // weak
int dword_8576140; // weak
int dword_8576160[128]; // idb
int dword_8576360[128]; // idb
int dword_8576560; // weak
int dword_8576580[128]; // idb
int dword_8576780; // weak
int dword_85767A0[128]; // idb
int dword_85769A0; // weak
char **dword_85769C0[385]; // idb
int dword_8576FC4; // idb
char *dword_8576FE0[134]; // idb
int dword_85771F8; // weak
int dword_8577200[520]; // idb
int dword_8577A20; // weak
_UNKNOWN unk_8577A40; // weak
_UNKNOWN unk_8577B60; // weak
float dword_8577F60[18]; // idb
int dword_8577FA8; // weak
__int16 word_8577FC0[]; // weak
int dword_8578000[]; // weak
int dword_8578080[]; // weak
int dword_8578084[35805]; // idb
int dword_859B000[]; // weak
int dword_859B400; // weak
int dword_859B404; // weak
char dword_859B40C[]; // idb
int dword_859B410; // weak
int dword_859B414; // weak
int dword_859B418; // weak
int dword_859B41C; // idb
int dword_859B420; // weak
_DWORD dword_859B424[112]; // idb
int dword_859B5E4; // weak
int dword_859B5E8; // weak
int dword_859B5EC; // idb
int dword_859B5F0; // weak
int dword_859B5F4; // weak
char dword_859B5F8[]; // idb
char dword_859B600[]; // idb
char dword_859B604[]; // idb
int dword_859B60C; // weak
int dword_859B610; // weak
int dword_859B614; // weak
size_t nmemb; // idb
char dword_859B61C[]; // idb
char byte_859B71C[1024]; // idb
char byte_859BB1C[1024]; // idb
char dword_859BF1C[]; // idb
int dword_859BF20; // weak
char dword_859BF24[]; // idb
char dword_859BF28[]; // idb
int dword_859BF2C; // weak
char byte_859C748; // weak
int dword_859C74C; // weak
char *dword_859C750; // idb
char *nptr[640]; // idb
int dword_859D154; // weak
int dword_859D158[32]; // idb
int dword_859D1D8; // weak
int dword_859D1DC; // weak
int dword_859D1E4; // weak
_UNKNOWN unk_859D1E8; // weak
int dword_859DDE8[]; // weak
int dword_859DDEC[]; // weak
int dword_859DDF0[]; // weak
int dword_859E9E8; // weak
int dword_859E9EC; // weak
int dword_859E9F0; // weak
int dword_859E9F4; // weak
int dword_859E9F8; // weak
int dword_859E9FC; // weak
int dword_859EA00; // weak
int dword_859EA04; // weak
int dword_859EA08[]; // weak
void *dword_859EA0C; // idb
int dword_859EA10[]; // weak
_UNKNOWN unk_859EA40; // weak
int dword_86525F4; // weak
int dword_8652608; // weak
int dword_865261C; // weak
int dword_8652620; // weak
int dword_8652624; // weak
int dword_8652628; // weak
int dword_865262C; // weak
int dword_8652630; // weak
int dword_8652634; // weak
int dword_8652638; // weak
_UNKNOWN unk_8652644; // weak
_UNKNOWN unk_8652668; // weak
_UNKNOWN unk_86529CC; // weak
_UNKNOWN unk_8652A1C; // weak
int dword_8652AE0[19026]; // idb
_UNKNOWN unk_8665480; // weak
int dword_8665488[]; // weak
int dword_8665548[]; // weak
float flt_86655B8[]; // weak
float flt_86655BC[]; // weak
float flt_86655C0[]; // weak
int dword_86655D8[]; // weak
__int16 word_86655E8[]; // weak
__int16 word_86655F4[]; // weak
int dword_8665614[]; // weak
_UNKNOWN unk_86656B0; // weak
int dword_86F1020; // weak
char byte_86F111C; // weak
_UNKNOWN unk_86F1188; // weak
int dword_86F1190; // weak
_UNKNOWN unk_86F1250; // weak
_UNKNOWN unk_86F1480; // weak
int dword_8793D80; // weak
int dword_8793D84; // weak
int dword_8793D88; // weak
int dword_8793D8C; // weak
int dword_8793D90; // weak
int dword_8793D94; // weak
int dword_8793D98; // weak
int dword_8793D9C; // weak
int dword_8793DA0; // weak
int dword_8793DA4; // weak
int dword_8793DA8; // weak
int dword_8793DAC; // weak
int dword_8793DB0; // weak
int dword_8793DB4; // weak
int dword_8793DB8; // weak
int dword_8793DBC; // weak
int dword_8793DC0; // weak
int dword_8793DC4; // weak
int dword_8793DC8; // weak
int dword_8793DCC; // weak
int dword_8793DD0; // weak
int dword_8793DD4; // weak
int dword_8793DD8; // weak
int dword_8793DDC; // weak
int dword_8793DE0; // weak
int dword_8793DE4; // weak
int dword_8793DE8; // weak
int dword_8793DEC; // weak
int dword_8793DF0; // weak
int dword_8793DF4; // weak
int dword_8793DFC; // weak
int dword_8793E00; // weak
int dword_8793E04; // idb
int dword_8793E0C; // weak
int dword_8793E10; // weak
int dword_8793E14; // weak
int dword_8793E18; // weak
int dword_8793E1C; // weak
int dword_8793E20; // weak
int dword_8793E24; // weak
int dword_8793E28; // weak
int dword_8793E2C; // weak
int dword_8793E30; // weak
int dword_8793E34; // weak
int dword_8793E38; // weak
int dword_8793E3C; // weak
int dword_8793E40; // weak
int dword_8793E44; // weak
int dword_8793E48; // weak
int dword_8793E4C; // weak
int dword_8793E50; // weak
int dword_8793E54; // weak
int dword_8793E58; // weak
int dword_8793E60[544]; // idb
_UNKNOWN unk_8794700; // weak
int dword_879C700; // weak
int dword_879C780; // weak
int dword_879C788; // weak
int dword_879C78C; // weak
int dword_879C790; // weak
int dword_879C794; // weak
int dword_879C798; // weak
int dword_879C79C; // weak
int dword_879C7A8; // weak
_UNKNOWN unk_879C7AC; // weak
int dword_879D82C; // weak
int dword_879D830; // weak
int dword_879D834; // weak
int dword_879D838[]; // weak
int dword_879D83C[2448]; // idb
int dword_879FE80[]; // weak
int dword_879FE84[2046]; // idb
int dword_87A1E80; // weak
int dword_87A1EA0[256]; // idb
__int16 word_87A22A0; // weak
__int16 word_87A22A2; // weak
__int16 word_87A22A4; // weak
__int16 word_87A22A6; // weak
__int16 word_87A22A8; // weak
__int16 word_87A22AA; // weak
__int16 word_87A22AC; // weak
__int16 word_87A22AE; // weak
__int16 word_87A22B0; // weak
__int16 word_87A22B2; // weak
__int16 word_87A22B4; // weak
__int16 word_87A22B6; // weak
__int16 word_87A22B8; // weak
__int16 word_87A22BA; // weak
__int16 word_87A22BC; // weak
__int16 word_87A22BE; // weak
__int16 word_87A22C0; // weak
__int16 word_87A22C2; // weak
__int16 word_87A22C4; // weak
__int16 word_87A22C6; // weak
__int16 word_87A22C8; // weak
__int16 word_87A22CA; // weak
__int16 word_87A22CC; // weak
__int16 word_87A22CE; // weak
__int16 word_87A22D0; // weak
__int16 word_87A22D2; // weak
__int16 word_87A22D4; // weak
__int16 word_87A22D6; // weak
__int16 word_87A22D8; // weak
__int16 word_87A22DA; // weak
__int16 word_87A22DC; // weak
__int16 word_87A22DE; // weak
__int16 word_87A22E0; // weak
__int16 word_87A22E2; // weak
__int16 word_87A22E4; // weak
__int16 word_87A22E6; // weak
__int16 word_87A22E8; // weak
__int16 word_87A22EA; // weak
__int16 word_87A22EC; // weak
__int16 word_87A22EE; // weak
__int16 word_87A22F0; // weak
__int16 word_87A22F2; // weak
__int16 word_87A22F4; // weak
__int16 word_87A22F6; // weak
__int16 word_87A22F8; // weak
__int16 word_87A22FA; // weak
__int16 word_87A22FC; // weak
__int16 word_87A22FE; // weak
__int16 word_87A2300; // weak
__int16 word_87A2302; // weak
__int16 word_87A2304; // weak
__int16 word_87A2306; // weak
__int16 word_87A2308; // weak
__int16 word_87A230A; // weak
__int16 word_87A230C; // weak
__int16 word_87A230E; // weak
__int16 word_87A2310; // weak
__int16 word_87A2312; // weak
__int16 word_87A2314; // weak
__int16 word_87A2316; // weak
__int16 word_87A2318; // weak
__int16 word_87A231A; // weak
__int16 word_87A231C; // weak
__int16 word_87A231E; // weak
__int16 word_87A2320; // weak
__int16 word_87A2322; // weak
__int16 word_87A2324; // weak
__int16 word_87A2326; // weak
__int16 word_87A2328; // weak
__int16 word_87A232A; // weak
__int16 word_87A232C; // weak
__int16 word_87A232E; // weak
__int16 word_87A2330; // weak
__int16 word_87A2332; // weak
__int16 word_87A2334; // weak
__int16 word_87A2336; // weak
__int16 word_87A2338; // weak
__int16 word_87A233A; // weak
__int16 word_87A233C; // weak
__int16 word_87A233E; // weak
__int16 word_87A2340; // weak
__int16 word_87A2342; // weak
__int16 word_87A2344; // weak
__int16 word_87A2346; // weak
__int16 word_87A2348; // weak
__int16 word_87A234A; // weak
__int16 word_87A234C; // weak
__int16 word_87A234E; // weak
__int16 word_87A2350; // weak
__int16 word_87A2352; // weak
_UNKNOWN unk_87A2380; // weak
int dword_89A2380; // weak
int dword_89A2388; // weak
_UNKNOWN unk_89A238C; // weak
_UNKNOWN unk_89A2394; // weak
_UNKNOWN unk_89A239C; // weak
_UNKNOWN unk_89A23A4; // weak
_UNKNOWN unk_89A23AC; // weak
_UNKNOWN unk_89A23B4; // weak
_UNKNOWN unk_89A23BC; // weak
_UNKNOWN unk_89A23C4; // weak
_UNKNOWN unk_89A23CC; // weak
_UNKNOWN unk_89A23D4; // weak
_UNKNOWN unk_89A23E0; // weak
int dword_89A2400[]; // weak
int dword_89A2800; // weak
_UNKNOWN unk_89A2804; // weak
int dword_89A280C[2]; // idb
void *dword_89A2814; // idb
int dword_89A2818; // weak
int dword_89A2828; // weak
char byte_89A2840[]; // weak
_UNKNOWN unk_89A2841; // weak
int dword_89A2C80; // weak
int dword_89A2C84; // weak
int dword_89A2C88; // weak
int dword_89A2C8C; // weak
int dword_89A2C90; // weak
int dword_89A2C98; // weak
int dword_89A2CA0; // weak
size_t dword_89A9D80; // idb
int dword_89A9D88; // weak
int dword_89AD6A0; // weak
_UNKNOWN unk_89AD700; // weak
int dword_89B63A0; // weak
int dword_89B63A4; // weak
char dword_89B63A8[]; // idb
int dword_89B63AC; // weak
int dword_89B63B0; // weak
int dword_89B63B4; // weak
int dword_89B63B8; // weak
int dword_89B63C4; // weak
int dword_89B63C8; // weak
int dword_89B63CC; // weak
_UNKNOWN unk_89B63E0; // weak
int dword_89B64DC[]; // weak
int dword_89B64E0[]; // weak
float flt_89B64E4[3598]; // idb
size_t dword_89B9D20; // idb
int dword_89B9D40[]; // weak
float flt_89B9D44[3598]; // idb
int dword_89BD580; // weak
int g_currentAsian; // weak
char byte_89BD5C0[1024]; // idb
int dword_89BD9C0; // weak
_UNKNOWN unk_89BD9E0; // weak
int dword_89BE1E0; // weak
int dword_89BE200; // idb
char byte_89BE220[64]; // idb
char byte_89BE260[64]; // idb
char byte_89BE2A0[64]; // idb
char byte_89BE2E0[63]; // idb
char byte_89BE31F; // weak
char s[1024]; // idb
int dword_89BE720; // weak
char *ptr; // idb
int dword_89BE728; // weak
int dword_89BE72C; // weak
int dword_89BE730; // weak
int dword_89BE734; // weak
int dword_89BE738; // weak
size_t size; // idb
_UNKNOWN unk_89BE740; // weak
_UNKNOWN unk_89BEB26; // weak
int dword_89BEB2C; // weak
int dword_89BEB30; // weak
_UNKNOWN unk_89BEB40; // weak
int dword_89BFAE0; // weak
// extern _UNKNOWN _gmon_start__; weak


//----- (08049B90) --------------------------------------------------------
void init_proc(void)
{
  if ( &_gmon_start__ )
    __gmon_start__();
  sub_804A540();
  sub_8139B20();
}
// 804A470: using guessed type int __gmon_start__(void);

//----- (08049BC0) --------------------------------------------------------
void sub_8049BC0()
{
  JUMPOUT(0);
}

//----- (0804A4B0) --------------------------------------------------------
#error "804A4B3: positive sp value has been found (funcsize=2)"

//----- (0804A4E0) --------------------------------------------------------
void sub_804A4E0()
{
  int *v0; // eax
  void (*i)(void); // edx

  if ( !byte_8185A6C )
  {
    v0 = off_815A008;
    for ( i = (void (*)(void))*off_815A008; *off_815A008; i = (void (*)(void))*off_815A008 )
    {
      off_815A008 = v0 + 1;
      i();
      v0 = off_815A008;
    }
    if ( __deregister_frame_info_bases )
      __deregister_frame_info_bases(&unk_81686B0);
    byte_8185A6C = 1;
  }
}
// 8049E10: using guessed type int __cdecl __deregister_frame_info_bases(_DWORD);
// 815A008: using guessed type int *off_815A008;
// 8185A6C: using guessed type char byte_8185A6C;

//----- (0804A540) --------------------------------------------------------
int sub_804A540()
{
  int result; // eax

  if ( __register_frame_info_bases )
    __register_frame_info_bases(&unk_81686B0, &unk_8185A70, 0, 135813016);
  result = dword_8185794;
  if ( dword_8185794 )
    result = 0;
  return result;
}
// 0: invalid function type has been ignored
// 804A0B0: using guessed type int __cdecl __register_frame_info_bases(_DWORD, _DWORD, _DWORD, _DWORD);
// 8185794: using guessed type int dword_8185794;

//----- (0804A5A4) --------------------------------------------------------
int __cdecl sub_804A5A4(int a1)
{
  _DWORD *v3; // [esp+14h] [ebp-4h]

  v3 = Z_MallocInternal(a1 + 4);
  if ( !v3 )
    return 0;
  *v3 = 305419896;
  return (int)(v3 + 1);
}

//----- (0804A5E8) --------------------------------------------------------
void *__cdecl sub_804A5E8(size_t n)
{
  void *s; // ST14_4

  s = (void *)sub_804A5A4(n);
  memset(s, 0, n);
  return s;
}

//----- (0804A61C) --------------------------------------------------------
void __cdecl sub_804A61C(int a1)
{
  if ( *(_DWORD *)(a1 - 4) == 305419896 )
    Z_FreeInternal((void *)(a1 - 4));
}

//----- (0804A644) --------------------------------------------------------
void SourceError(int a1, char *format, ...)
{
  char s; // [esp+20h] [ebp-408h]
  va_list va; // [esp+438h] [ebp+10h]

  va_start(va, format);
  vsprintf(&s, format, va);
  Com_Printf("^1Error: file %s, line %d: %s\n", *(_DWORD *)(a1 + 132), *(_DWORD *)(*(_DWORD *)(a1 + 132) + 92), &s);
}

//----- (0804A6AA) --------------------------------------------------------
void SourceWarning(int a1, char *format, ...)
{
  char s; // [esp+20h] [ebp-408h]
  va_list va; // [esp+438h] [ebp+10h]

  va_start(va, format);
  vsprintf(&s, format, va);
  Com_Printf("^3Warning: file %s, line %d: %s\n", *(_DWORD *)(a1 + 132), *(_DWORD *)(*(_DWORD *)(a1 + 132) + 92), &s);
}

//----- (0804A710) --------------------------------------------------------
_DWORD *__cdecl sub_804A710(_DWORD *a1, int a2, int a3)
{
  _DWORD *result; // eax

  result = (_DWORD *)sub_804A5A4(16);
  *result = a2;
  result[2] = a1[33];
  result[1] = a3 != 0;
  a1[38] += result[1];
  result[3] = a1[37];
  a1[37] = result;
  return result;
}

//----- (0804A782) --------------------------------------------------------
void __cdecl sub_804A782(_DWORD *a1, _DWORD *a2, _DWORD *a3)
{
  _DWORD *v3; // [esp+10h] [ebp-8h]

  *a2 = 0;
  *a3 = 0;
  v3 = (_DWORD *)a1[37];
  if ( v3 )
  {
    if ( *(_DWORD *)(a1[37] + 8) == a1[33] )
    {
      *a2 = *v3;
      *a3 = v3[1];
      a1[37] = *(_DWORD *)(a1[37] + 12);
      a1[38] -= v3[1];
      sub_804A61C((int)v3);
    }
  }
}

//----- (0804A81E) --------------------------------------------------------
void __cdecl sub_804A81E(int a1, int a2)
{
  int i; // [esp+14h] [ebp-4h]

  for ( i = *(_DWORD *)(a1 + 132); i; i = *(_DWORD *)(i + 1184) )
  {
    if ( !I_stricmp((char *)i, (char *)a2) )
    {
      SourceError(a1, "%s recursively included", a2);
      return;
    }
  }
  *(_DWORD *)(a2 + 1184) = *(_DWORD *)(a1 + 132);
  *(_DWORD *)(a1 + 132) = a2;
}

//----- (0804A898) --------------------------------------------------------
_DWORD *__cdecl sub_804A898(void *src)
{
  _DWORD *dest; // [esp+14h] [ebp-4h]

  dest = (_DWORD *)sub_804A5A4(1068);
  if ( !dest )
    Com_Error(0, "EXE_ERR_OUT_OF_MEMORY");
  memcpy(dest, src, 0x42Cu);
  dest[266] = 0;
  ++dword_8185AA0;
  return dest;
}
// 8185AA0: using guessed type int dword_8185AA0;

//----- (0804A908) --------------------------------------------------------
void __cdecl sub_804A908(int a1)
{
  sub_804A61C(a1);
  --dword_8185AA0;
}
// 8185AA0: using guessed type int dword_8185AA0;

//----- (0804A922) --------------------------------------------------------
int __cdecl sub_804A922(int a1, void *dest)
{
  char v4; // [esp+18h] [ebp-10h]
  char v5; // [esp+1Ch] [ebp-Ch]
  int v6; // [esp+20h] [ebp-8h]
  int v7; // [esp+24h] [ebp-4h]

  while ( !*(_DWORD *)(a1 + 136) )
  {
    if ( sub_8050E1C(*(_DWORD *)(a1 + 132), dest) )
      return 1;
    if ( sub_8051932(*(_DWORD *)(a1 + 132)) )
    {
      while ( *(_DWORD *)(a1 + 148) && *(_DWORD *)(*(_DWORD *)(a1 + 148) + 8) == *(_DWORD *)(a1 + 132) )
      {
        SourceWarning(a1, "missing #endif");
        sub_804A782((_DWORD *)a1, &v5, &v4);
      }
    }
    if ( !*(_DWORD *)(*(_DWORD *)(a1 + 132) + 1184) )
      return 0;
    v6 = *(_DWORD *)(a1 + 132);
    *(_DWORD *)(a1 + 132) = *(_DWORD *)(*(_DWORD *)(a1 + 132) + 1184);
    sub_8051BEE(v6);
  }
  memcpy(dest, *(const void **)(a1 + 136), 0x42Cu);
  v7 = *(_DWORD *)(a1 + 136);
  *(_DWORD *)(a1 + 136) = *(_DWORD *)(*(_DWORD *)(a1 + 136) + 1064);
  sub_804A908(v7);
  return 1;
}

//----- (0804AA78) --------------------------------------------------------
int __cdecl sub_804AA78(int a1, void *src)
{
  _DWORD *v2; // eax

  v2 = sub_804A898(src);
  v2[266] = *(_DWORD *)(a1 + 136);
  *(_DWORD *)(a1 + 136) = v2;
  return 1;
}

//----- (0804AAB2) --------------------------------------------------------
signed int __cdecl sub_804AAB2(int a1, _DWORD *a2, int a3, int a4)
{
  signed int v5; // [esp+10h] [ebp-458h]
  int v6; // [esp+14h] [ebp-454h]
  int v7; // [esp+18h] [ebp-450h]
  signed int v8; // [esp+1Ch] [ebp-44Ch]
  signed int v9; // [esp+20h] [ebp-448h]
  int i; // [esp+24h] [ebp-444h]
  _DWORD *v11; // [esp+28h] [ebp-440h]
  _DWORD *v12; // [esp+2Ch] [ebp-43Ch]
  char s1; // [esp+30h] [ebp-438h]

  if ( sub_804A922(a1, &s1) )
  {
    if ( a2[3] <= a4 )
    {
      for ( i = 0; i < a2[3]; ++i )
        *(_DWORD *)(a3 + 4 * i) = 0;
      if ( !strcmp(&s1, "(") )
      {
        v9 = 0;
        v7 = 0;
        v6 = 0;
        while ( !v9 )
        {
          if ( v7 >= a4 )
          {
            SourceError(a1, "define %s with too many parms", *a2);
            return 0;
          }
          if ( v7 >= a2[3] )
          {
            SourceWarning(a1, "define %s has too many parms", *a2);
            return 0;
          }
          *(_DWORD *)(a3 + 4 * v7) = 0;
          v8 = 1;
          v11 = 0;
          while ( 1 )
          {
            while ( 1 )
            {
              if ( !sub_804A922(a1, &s1) )
              {
                SourceError(a1, "define %s incomplete", *a2);
                return 0;
              }
              if ( !strcmp(&s1, ",") && v6 <= 0 )
              {
                if ( v8 )
                  SourceWarning(a1, "too many comma's");
                goto LABEL_36;
              }
              v8 = 0;
              if ( strcmp(&s1, "(") )
                break;
              ++v6;
            }
            if ( !strcmp(&s1, ")") && --v6 <= 0 )
              break;
            if ( v7 < a2[3] )
            {
              v12 = sub_804A898(&s1);
              v12[266] = 0;
              if ( v11 )
                v11[266] = v12;
              else
                *(_DWORD *)(a3 + 4 * v7) = v12;
              v11 = v12;
            }
          }
          if ( !*(_DWORD *)(a3 + 4 * a2[3] - 4) )
            SourceWarning(a1, "too few define parms");
          v9 = 1;
LABEL_36:
          ++v7;
        }
        v5 = 1;
      }
      else
      {
        sub_804AA78(a1, &s1);
        SourceError(a1, "define %s missing parms", *a2);
        v5 = 0;
      }
    }
    else
    {
      SourceError(a1, "define with more than %d parameters", a4);
      v5 = 0;
    }
  }
  else
  {
    SourceError(a1, "define %s missing parms", *a2);
    v5 = 0;
  }
  return v5;
}

//----- (0804AE5A) --------------------------------------------------------
int __cdecl sub_804AE5A(int a1, char *dest)
{
  size_t v2; // eax
  size_t v3; // eax
  char *src; // [esp+14h] [ebp-4h]

  *((_DWORD *)dest + 256) = 1;
  *((_DWORD *)dest + 262) = 0;
  *((_DWORD *)dest + 263) = 0;
  *dest = 0;
  strcat(dest, "\"");
  for ( src = (char *)a1; src; src = (char *)*((_DWORD *)src + 266) )
  {
    v2 = strlen(dest);
    strncat(dest, src, 1024 - v2);
  }
  v3 = strlen(dest);
  strncat(dest, "\"", 1024 - v3);
  return 1;
}

//----- (0804AF18) --------------------------------------------------------
int __cdecl sub_804AF18(char *dest, char *src)
{
  signed int v3; // [esp+10h] [ebp-8h]

  if ( *((_DWORD *)dest + 256) != 4 || *((_DWORD *)src + 256) != 4 && *((_DWORD *)src + 256) != 3 )
  {
    if ( *((_DWORD *)dest + 256) != 1 || *((_DWORD *)src + 256) != 1 )
    {
      v3 = 0;
    }
    else
    {
      dest[strlen(dest) - 1] = 0;
      strcat(dest, src + 1);
      v3 = 1;
    }
  }
  else
  {
    strcat(dest, src);
    v3 = 1;
  }
  return v3;
}

//----- (0804AFB8) --------------------------------------------------------
int __cdecl sub_804AFB8(int a1)
{
  int i; // [esp+0h] [ebp-8h]
  int v3; // [esp+4h] [ebp-4h]

  v3 = 0;
  for ( i = 0; *(_BYTE *)(i + a1); ++i )
    v3 += *(char *)(i + a1) * (i + 119);
  return ((v3 >> 20) ^ (v3 >> 10) ^ v3) & 0x3FF;
}

//----- (0804B018) --------------------------------------------------------
int *__cdecl sub_804B018(int *a1, int a2)
{
  int v2; // eax
  int v3; // ecx
  int *result; // eax

  v2 = sub_804AFB8(*a1);
  a1[7] = *(_DWORD *)(a2 + 4 * v2);
  v3 = 4 * v2;
  result = a1;
  *(_DWORD *)(a2 + v3) = a1;
  return result;
}

//----- (0804B05A) --------------------------------------------------------
int __cdecl sub_804B05A(int a1, char *s2)
{
  int i; // [esp+14h] [ebp-4h]

  for ( i = *(_DWORD *)(a1 + 4 * sub_804AFB8((int)s2)); i; i = *(_DWORD *)(i + 28) )
  {
    if ( !strcmp(*(const char **)i, s2) )
      return i;
  }
  return 0;
}

//----- (0804B0C0) --------------------------------------------------------
int __cdecl sub_804B0C0(int a1, char *s2)
{
  int i; // [esp+14h] [ebp-4h]

  for ( i = a1; i; i = *(_DWORD *)(i + 24) )
  {
    if ( !strcmp(*(const char **)i, s2) )
      return i;
  }
  return 0;
}

//----- (0804B10C) --------------------------------------------------------
int __cdecl sub_804B10C(int a1, char *s2)
{
  int v4; // [esp+10h] [ebp-8h]
  char *s1; // [esp+14h] [ebp-4h]

  v4 = 0;
  for ( s1 = *(char **)(a1 + 16); s1; s1 = (char *)*((_DWORD *)s1 + 266) )
  {
    if ( !strcmp(s1, s2) )
      return v4;
    ++v4;
  }
  return -1;
}

//----- (0804B168) --------------------------------------------------------
void __cdecl sub_804B168(int a1)
{
  int v1; // ST10_4
  int v2; // ST10_4
  int i; // [esp+14h] [ebp-4h]
  int j; // [esp+14h] [ebp-4h]

  for ( i = *(_DWORD *)(a1 + 16); i; i = v1 )
  {
    v1 = *(_DWORD *)(i + 1064);
    sub_804A908(i);
  }
  for ( j = *(_DWORD *)(a1 + 20); j; j = v2 )
  {
    v2 = *(_DWORD *)(j + 1064);
    sub_804A908(j);
  }
  sub_804A61C(a1);
}

//----- (0804B1DC) --------------------------------------------------------
int __cdecl sub_804B1DC(int a1)
{
  int result; // eax
  size_t v2; // eax
  char *s; // [esp+10h] [ebp-48h]
  int v4; // [esp+14h] [ebp-44h]
  const char *v5; // [esp+18h] [ebp-40h]
  int v6; // [esp+1Ch] [ebp-3Ch]
  const char *v7; // [esp+20h] [ebp-38h]
  int v8; // [esp+24h] [ebp-34h]
  const char *v9; // [esp+28h] [ebp-30h]
  int v10; // [esp+2Ch] [ebp-2Ch]
  int v11; // [esp+30h] [ebp-28h]
  int v12; // [esp+34h] [ebp-24h]
  void *v13; // [esp+48h] [ebp-10h]
  int i; // [esp+4Ch] [ebp-Ch]

  s = "__LINE__";
  v4 = 1;
  v5 = "__FILE__";
  v6 = 2;
  v7 = "__DATE__";
  v8 = 3;
  v9 = "__TIME__";
  v10 = 4;
  v11 = 0;
  v12 = 0;
  for ( i = 0; ; ++i )
  {
    result = i;
    if ( !(&s)[2 * i] )
      break;
    v2 = strlen((&s)[2 * i]);
    v13 = (void *)sub_804A5A4(v2 + 33);
    memset(v13, 0, 0x20u);
    *(_DWORD *)v13 = (char *)v13 + 32;
    strcpy(*(char **)v13, (&s)[2 * i]);
    *((_DWORD *)v13 + 1) |= 1u;
    *((_DWORD *)v13 + 2) = *(&v4 + 2 * i);
    sub_804B018((int *)v13, *(_DWORD *)(a1 + 144));
  }
  return result;
}

//----- (0804B2DA) --------------------------------------------------------
int __cdecl sub_804B2DA(int a1, void *src, int a3, int a4, int a5)
{
  char *ptr; // ST18_4
  char *v6; // ebx
  char *v7; // ST18_4
  char *v8; // ebx
  time_t timer; // [esp+1Ch] [ebp-Ch]
  char *s; // [esp+20h] [ebp-8h]

  s = (char *)sub_804A898(src);
  switch ( *(_DWORD *)(a3 + 8) )
  {
    case 0:
    case 5:
      *(_DWORD *)a4 = 0;
      *(_DWORD *)a5 = 0;
      break;
    case 1:
      sprintf(s, "%d", *((_DWORD *)src + 264));
      *((_DWORD *)s + 258) = *((_DWORD *)src + 264);
      *(long double *)(s + 1036) = (long double)*((signed int *)src + 264);
      *((_DWORD *)s + 256) = 3;
      *((_DWORD *)s + 257) = 4104;
      *(_DWORD *)a4 = s;
      *(_DWORD *)a5 = s;
      break;
    case 2:
      strcpy(s, *(const char **)(a1 + 132));
      *((_DWORD *)s + 256) = 4;
      *((_DWORD *)s + 257) = strlen(s);
      *(_DWORD *)a4 = s;
      *(_DWORD *)a5 = s;
      break;
    case 3:
      timer = time(0);
      ptr = ctime(&timer);
      strcpy(s, "\"");
      strncat(s, ptr + 4, 7u);
      strncat(s + 7, ptr + 20, 4u);
      strcat(s, "\"");
      free(ptr);
      *((_DWORD *)s + 256) = 4;
      v6 = s;
      *((_DWORD *)v6 + 257) = strlen(s);
      *(_DWORD *)a4 = s;
      *(_DWORD *)a5 = s;
      break;
    case 4:
      timer = time(0);
      v7 = ctime(&timer);
      strcpy(s, "\"");
      strncat(s, v7 + 11, 8u);
      strcat(s, "\"");
      free(v7);
      *((_DWORD *)s + 256) = 4;
      v8 = s;
      *((_DWORD *)v8 + 257) = strlen(s);
      *(_DWORD *)a4 = s;
      *(_DWORD *)a5 = s;
      break;
  }
  return 1;
}

//----- (0804B550) --------------------------------------------------------
int __cdecl sub_804B550(int a1, void *a2, int a3, int a4, int a5)
{
  int j; // [esp+28h] [ebp-660h]
  int v8; // [esp+2Ch] [ebp-65Ch]
  int v9; // [esp+2Ch] [ebp-65Ch]
  char dest; // [esp+30h] [ebp-658h]
  void *v11; // [esp+460h] [ebp-228h]
  char *v12; // [esp+464h] [ebp-224h]
  _DWORD *v13; // [esp+468h] [ebp-220h]
  char *src; // [esp+46Ch] [ebp-21Ch]
  char *v15; // [esp+470h] [ebp-218h]
  _DWORD *v16; // [esp+474h] [ebp-214h]
  void *i; // [esp+478h] [ebp-210h]
  char *s2; // [esp+47Ch] [ebp-20Ch]
  int v19[130]; // [esp+480h] [ebp-208h]

  if ( *(_DWORD *)(a3 + 8) )
    return sub_804B2DA(a1, a2, a3, a4, a5);
  if ( *(_DWORD *)(a3 + 12) && !sub_804AAB2(a1, (_DWORD *)a3, (int)v19, 128) )
    return 0;
  v13 = 0;
  v12 = 0;
  for ( s2 = *(char **)(a3 + 20); s2; s2 = (char *)*((_DWORD *)s2 + 266) )
  {
    v8 = -1;
    if ( *((_DWORD *)s2 + 256) == 4 )
      v8 = sub_804B10C(a3, s2);
    if ( v8 < 0 )
    {
      if ( *s2 != 35 || s2[1] )
      {
        v16 = sub_804A898(s2);
      }
      else
      {
        if ( *((_DWORD *)s2 + 266) )
          v9 = sub_804B10C(a3, *((char **)s2 + 266));
        else
          v9 = -1;
        if ( v9 < 0 )
        {
          SourceWarning(a1, "stringizing operator without define parameter");
          continue;
        }
        s2 = (char *)*((_DWORD *)s2 + 266);
        if ( !sub_804AE5A(v19[v9], &dest) )
        {
          SourceError(a1, "can't stringize tokens");
          return 0;
        }
        v16 = sub_804A898(&dest);
      }
      v16[266] = 0;
      if ( v12 )
        *((_DWORD *)v12 + 266) = v16;
      else
        v13 = v16;
      v12 = (char *)v16;
    }
    else
    {
      for ( i = (void *)v19[v8]; i; i = (void *)*((_DWORD *)i + 266) )
      {
        v16 = sub_804A898(i);
        v16[266] = 0;
        if ( v12 )
          *((_DWORD *)v12 + 266) = v16;
        else
          v13 = v16;
        v12 = (char *)v16;
      }
    }
  }
  v16 = v13;
  while ( v16 )
  {
    if ( v16[266]
      && *(_BYTE *)v16[266] == 35
      && *(_BYTE *)(v16[266] + 1) == 35
      && (v15 = (char *)v16, (src = *(char **)(v16[266] + 1064)) != 0) )
    {
      if ( !sub_804AF18(v15, src) )
      {
        SourceError(a1, "can't merge %s with %s", v15, src);
        return 0;
      }
      sub_804A908(*((_DWORD *)v15 + 266));
      *((_DWORD *)v15 + 266) = *((_DWORD *)src + 266);
      if ( src == v12 )
        v12 = v15;
      sub_804A908((int)src);
    }
    else
    {
      v16 = (_DWORD *)v16[266];
    }
  }
  *(_DWORD *)a4 = v13;
  *(_DWORD *)a5 = v12;
  for ( j = 0; j < *(_DWORD *)(a3 + 12); ++j )
  {
    for ( i = (void *)v19[j]; i; i = v11 )
    {
      v11 = (void *)*((_DWORD *)i + 266);
      sub_804A908((int)i);
    }
  }
  return 1;
}
// 804B550: using guessed type int var_208[130];

//----- (0804BA0A) --------------------------------------------------------
int __cdecl sub_804BA0A(int a1, void *a2, int a3)
{
  int v5; // [esp+20h] [ebp-8h]
  int v6; // [esp+24h] [ebp-4h]

  if ( !sub_804B550(a1, a2, a3, (int)&v6, (int)&v5) )
    return 0;
  if ( !v6 || !v5 )
    return 0;
  *(_DWORD *)(v5 + 1064) = *(_DWORD *)(a1 + 136);
  *(_DWORD *)(a1 + 136) = v6;
  return 1;
}

//----- (0804BA84) --------------------------------------------------------
char *__cdecl sub_804BA84(char *a1)
{
  char *result; // eax
  char *dest; // [esp+14h] [ebp-4h]
  char *desta; // [esp+14h] [ebp-4h]

  dest = a1;
  while ( *dest )
  {
    if ( *dest != 92 && *dest != 47 || dest[1] != 92 && dest[1] != 47 )
      ++dest;
    else
      strcpy(dest, dest + 1);
  }
  for ( desta = a1; ; ++desta )
  {
    result = desta;
    if ( !*desta )
      break;
    if ( *desta == 47 || *desta == 92 )
      *desta = 47;
  }
  return result;
}

//----- (0804BB0E) --------------------------------------------------------
signed int __cdecl sub_804BB0E(int a1)
{
  signed int v2; // [esp+1Ch] [ebp-48Ch]
  char dest; // [esp+20h] [ebp-488h]
  char src; // [esp+60h] [ebp-448h]
  int v5; // [esp+460h] [ebp-48h]
  int v6; // [esp+484h] [ebp-24h]
  char *v7; // [esp+49Ch] [ebp-Ch]

  if ( *(_DWORD *)(a1 + 152) > 0 )
    return 1;
  if ( sub_804A922(a1, &src) )
  {
    if ( v6 <= 0 )
    {
      if ( v5 == 1 )
      {
        sub_8051694(&src);
        sub_804BA84(&src);
        v7 = sub_80519D8(&src);
        if ( !v7 )
        {
          strcpy(&dest, (const char *)(a1 + 64));
          strcat(&dest, &src);
          v7 = sub_80519D8(&dest);
        }
      }
      else
      {
        if ( v5 != 5 || src != 60 )
        {
          SourceError(a1, "#include without file name");
          return 0;
        }
        strcpy(&dest, (const char *)(a1 + 64));
        while ( sub_804A922(a1, &src) )
        {
          if ( v6 > 0 )
          {
            sub_804AA78(a1, &src);
            break;
          }
          if ( v5 == 5 && src == 62 )
            break;
          strncat(&dest, &src, 0x40u);
        }
        if ( src != 62 )
          SourceWarning(a1, "#include missing trailing >");
        if ( !dest )
        {
          SourceError(a1, "#include without file name between < >");
          return 0;
        }
        sub_804BA84(&dest);
        v7 = sub_80519D8(&dest);
      }
      if ( v7 )
      {
        sub_804A81E(a1, (int)v7);
        v2 = 1;
      }
      else
      {
        SourceError(a1, "file %s not found", &dest);
        v2 = 0;
      }
    }
    else
    {
      SourceError(a1, "#include without file name");
      v2 = 0;
    }
  }
  else
  {
    SourceError(a1, "#include without file name");
    v2 = 0;
  }
  return v2;
}

//----- (0804BD8C) --------------------------------------------------------
int __cdecl sub_804BD8C(int a1, char *s1)
{
  int v4; // [esp+10h] [ebp-8h]
  signed int v5; // [esp+14h] [ebp-4h]

  v5 = 0;
  do
  {
    if ( !sub_804A922(a1, s1) )
      return 0;
    if ( *((_DWORD *)s1 + 265) > v5 )
    {
      sub_804AA78(a1, s1);
      return 0;
    }
    if ( *((_DWORD *)s1 + 256) == 4 )
    {
      v4 = sub_804B05A(*(_DWORD *)(a1 + 144), s1);
      if ( v4 )
      {
        if ( !sub_804BA0A(a1, s1, v4) )
          return 0;
        if ( !sub_804A922(a1, s1) )
          return 0;
      }
    }
    v5 = 1;
  }
  while ( !strcmp(s1, "\\") );
  return 1;
}

//----- (0804BE88) --------------------------------------------------------
_BOOL4 __cdecl sub_804BE88(int a1)
{
  return *(_DWORD *)(a1 + 1052) - *(_DWORD *)(a1 + 1048) > 0;
}

//----- (0804BEB8) --------------------------------------------------------
_DWORD *__cdecl sub_804BEB8(_DWORD *a1)
{
  _DWORD *result; // eax

  a1[262] = 0;
  a1[263] = 0;
  result = a1;
  a1[265] = 0;
  return result;
}

//----- (0804BEE4) --------------------------------------------------------
signed int __cdecl sub_804BEE4(int a1)
{
  signed int v2; // [esp+10h] [ebp-448h]
  int v3; // [esp+14h] [ebp-444h]
  int v4; // [esp+18h] [ebp-440h]
  int i; // [esp+1Ch] [ebp-43Ch]
  char s2; // [esp+20h] [ebp-438h]
  int v7; // [esp+420h] [ebp-38h]

  if ( *(_DWORD *)(a1 + 152) > 0 )
    return 1;
  if ( sub_804BD8C(a1, &s2) )
  {
    if ( v7 == 4 )
    {
      v3 = sub_804AFB8((int)&s2);
      v4 = 0;
      for ( i = *(_DWORD *)(*(_DWORD *)(a1 + 144) + 4 * v3); i; i = *(_DWORD *)(i + 28) )
      {
        if ( !strcmp(*(const char **)i, &s2) )
        {
          if ( *(_BYTE *)(i + 4) & 1 )
          {
            SourceWarning(a1, "can't undef %s", &s2);
          }
          else
          {
            if ( v4 )
              *(_DWORD *)(v4 + 28) = *(_DWORD *)(i + 28);
            else
              *(_DWORD *)(*(_DWORD *)(a1 + 144) + 4 * v3) = *(_DWORD *)(i + 28);
            sub_804B168(i);
          }
          break;
        }
        v4 = i;
      }
      v2 = 1;
    }
    else
    {
      sub_804AA78(a1, &s2);
      SourceError(a1, "expected name, found %s", &s2);
      v2 = 0;
    }
  }
  else
  {
    SourceError(a1, "undef without name");
    v2 = 0;
  }
  return v2;
}

//----- (0804C0A4) --------------------------------------------------------
signed int __cdecl sub_804C0A4(int a1)
{
  size_t v1; // eax
  _BYTE *v4; // [esp+14h] [ebp-444h]
  char **v5; // [esp+14h] [ebp-444h]
  char *v6; // [esp+18h] [ebp-440h]
  char *v7; // [esp+18h] [ebp-440h]
  char *s1; // [esp+1Ch] [ebp-43Ch]
  char *s1a; // [esp+1Ch] [ebp-43Ch]
  char s; // [esp+20h] [ebp-438h]
  int v11; // [esp+420h] [ebp-38h]

  if ( *(_DWORD *)(a1 + 152) > 0 )
    return 1;
  if ( !sub_804BD8C(a1, &s) )
  {
    SourceError(a1, "#define without name");
    return 0;
  }
  if ( v11 != 4 )
  {
    sub_804AA78(a1, &s);
    SourceError(a1, "expected name after #define, found %s", &s);
    return 0;
  }
  v4 = (_BYTE *)sub_804B05A(*(_DWORD *)(a1 + 144), &s);
  if ( v4 )
  {
    if ( v4[4] & 1 )
    {
      SourceError(a1, "can't redefine %s", &s);
      return 0;
    }
    SourceWarning(a1, "redefinition of %s", &s);
    sub_804AA78(a1, &s);
    if ( !sub_804BEE4(a1) )
      return 0;
    sub_804B05A(*(_DWORD *)(a1 + 144), &s);
  }
  v1 = strlen(&s);
  v5 = (char **)sub_804A5A4(v1 + 33);
  memset(v5, 0, 0x20u);
  *v5 = (char *)(v5 + 8);
  strcpy(*v5, &s);
  sub_804B018((int *)v5, *(_DWORD *)(a1 + 144));
  if ( !sub_804BD8C(a1, &s) )
    return 1;
  if ( sub_804BE88((int)&s) || strcmp(&s, "(") )
    goto LABEL_34;
  v6 = 0;
  if ( sub_804F274(a1, ")") )
  {
LABEL_32:
    if ( !sub_804BD8C(a1, &s) )
      return 1;
LABEL_34:
    v7 = 0;
    do
    {
      s1a = (char *)sub_804A898(&s);
      if ( *((_DWORD *)s1a + 256) == 4 && !strcmp(s1a, *v5) )
      {
        SourceError(a1, "recursive define (removed recursion)");
      }
      else
      {
        sub_804BEB8(s1a);
        *((_DWORD *)s1a + 266) = 0;
        if ( v7 )
          *((_DWORD *)v7 + 266) = s1a;
        else
          v5[5] = s1a;
        v7 = s1a;
      }
    }
    while ( sub_804BD8C(a1, &s) );
    if ( !v7 || strcmp(v5[5], "##") && strcmp(v7, "##") )
      return 1;
    SourceError(a1, "define with misplaced ##");
    return 0;
  }
  do
  {
    if ( !sub_804BD8C(a1, &s) )
    {
      SourceError(a1, "expected define parameter");
      return 0;
    }
    if ( v11 != 4 )
    {
      SourceError(a1, "invalid define parameter");
      return 0;
    }
    if ( sub_804B10C((int)v5, &s) >= 0 )
    {
      SourceError(a1, "two the same define parameters");
      return 0;
    }
    s1 = (char *)sub_804A898(&s);
    sub_804BEB8(s1);
    *((_DWORD *)s1 + 266) = 0;
    if ( v6 )
      *((_DWORD *)v6 + 266) = s1;
    else
      v5[4] = s1;
    v6 = s1;
    ++v5[3];
    if ( !sub_804BD8C(a1, &s) )
    {
      SourceError(a1, "define parameters not terminated");
      return 0;
    }
    if ( !strcmp(&s, ")") )
      goto LABEL_32;
  }
  while ( !strcmp(&s, ",") );
  SourceError(a1, "define not terminated");
  return 0;
}

//----- (0804C640) --------------------------------------------------------
int __cdecl sub_804C640(char *s)
{
  size_t v1; // eax
  int v4; // [esp+20h] [ebp-4F8h]
  signed int j; // [esp+24h] [ebp-4F4h]
  signed int v6; // [esp+28h] [ebp-4F0h]
  int i; // [esp+2Ch] [ebp-4ECh]
  char dest; // [esp+30h] [ebp-4E8h]
  char *v9; // [esp+B4h] [ebp-464h]
  int v10; // [esp+B8h] [ebp-460h]
  int v11; // [esp+BCh] [ebp-45Ch]
  _DWORD *v12; // [esp+C0h] [ebp-458h]
  char *v13; // [esp+50Ch] [ebp-Ch]

  v1 = strlen(s);
  v13 = sub_8051B20(s, v1, "*extern");
  memset(&dest, 0, 0x4C8u);
  strncpy(&dest, "*extern", 0x40u);
  v9 = v13;
  v12 = sub_804A5E8(0x1000u);
  v6 = sub_804C0A4((int)&dest);
  for ( i = v10; i; i = v10 )
  {
    v10 = *(_DWORD *)(v10 + 1064);
    sub_804A908(i);
  }
  v4 = 0;
  for ( j = 0; j <= 1023; ++j )
  {
    if ( v12[j] )
    {
      v4 = v12[j];
      break;
    }
  }
  sub_804A61C((int)v12);
  sub_8051BEE((int)v13);
  if ( v6 > 0 )
    return v4;
  if ( v11 )
    sub_804B168(v4);
  return 0;
}

//----- (0804C7DA) --------------------------------------------------------
int __cdecl sub_804C7DA(int a1, char *s)
{
  int *v4; // [esp+14h] [ebp-4h]

  v4 = (int *)sub_804C640(s);
  if ( !v4 )
    return 0;
  sub_804B018(v4, *(_DWORD *)(a1 + 144));
  return 1;
}

//----- (0804C822) --------------------------------------------------------
int __cdecl sub_804C822(char *s)
{
  int v3; // [esp+14h] [ebp-4h]

  v3 = sub_804C640(s);
  if ( !v3 )
    return 0;
  *(_DWORD *)(v3 + 24) = dword_8185AA4;
  dword_8185AA4 = v3;
  return 1;
}

//----- (0804C866) --------------------------------------------------------
int __cdecl sub_804C866(char *s2)
{
  int v3; // [esp+14h] [ebp-4h]

  v3 = sub_804B0C0(dword_8185AA4, s2);
  if ( !v3 )
    return 0;
  sub_804B168(v3);
  return 1;
}

//----- (0804C8AA) --------------------------------------------------------
int sub_804C8AA()
{
  int result; // eax
  int i; // [esp+4h] [ebp-4h]

  result = dword_8185AA4;
  for ( i = dword_8185AA4; i; i = dword_8185AA4 )
  {
    dword_8185AA4 = *(_DWORD *)(dword_8185AA4 + 24);
    sub_804B168(i);
    result = dword_8185AA4;
  }
  return result;
}

//----- (0804C8E4) --------------------------------------------------------
int __cdecl sub_804C8E4(int a1, int a2)
{
  size_t v2; // eax
  _DWORD *v4; // [esp+8h] [ebp-10h]
  _DWORD *v5; // [esp+8h] [ebp-10h]
  _DWORD *v6; // [esp+Ch] [ebp-Ch]
  _DWORD *v7; // [esp+Ch] [ebp-Ch]
  _DWORD *src; // [esp+10h] [ebp-8h]
  _DWORD *srca; // [esp+10h] [ebp-8h]
  int v10; // [esp+14h] [ebp-4h]

  v2 = strlen(*(const char **)a2);
  v10 = sub_804A5A4(v2 + 33);
  *(_DWORD *)v10 = v10 + 32;
  strcpy(*(char **)v10, *(const char **)a2);
  *(_DWORD *)(v10 + 4) = *(_DWORD *)(a2 + 4);
  *(_DWORD *)(v10 + 8) = *(_DWORD *)(a2 + 8);
  *(_DWORD *)(v10 + 12) = *(_DWORD *)(a2 + 12);
  *(_DWORD *)(v10 + 24) = 0;
  *(_DWORD *)(v10 + 28) = 0;
  *(_DWORD *)(v10 + 20) = 0;
  v4 = 0;
  for ( src = *(_DWORD **)(a2 + 20); src; src = (_DWORD *)src[266] )
  {
    v6 = sub_804A898(src);
    v6[266] = 0;
    if ( v4 )
      v4[266] = v6;
    else
      *(_DWORD *)(v10 + 20) = v6;
    v4 = v6;
  }
  *(_DWORD *)(v10 + 16) = 0;
  v5 = 0;
  for ( srca = *(_DWORD **)(a2 + 16); srca; srca = (_DWORD *)srca[266] )
  {
    v7 = sub_804A898(srca);
    v7[266] = 0;
    if ( v5 )
      v5[266] = v7;
    else
      *(_DWORD *)(v10 + 16) = v7;
    v5 = v7;
  }
  return v10;
}

//----- (0804CA40) --------------------------------------------------------
int __cdecl sub_804CA40(int a1)
{
  int result; // eax
  int *v2; // ST10_4
  int i; // [esp+14h] [ebp-4h]

  result = dword_8185AA4;
  for ( i = dword_8185AA4; i; i = *(_DWORD *)(i + 24) )
  {
    v2 = (int *)sub_804C8E4(a1, i);
    sub_804B018(v2, *(_DWORD *)(a1 + 144));
    result = *(_DWORD *)(i + 24);
  }
  return result;
}

//----- (0804CA90) --------------------------------------------------------
signed int __cdecl sub_804CA90(_DWORD *a1, int a2)
{
  int v2; // ST1C_4
  signed int v4; // [esp+14h] [ebp-444h]
  char s2; // [esp+20h] [ebp-438h]
  int v6; // [esp+420h] [ebp-38h]

  if ( sub_804BD8C((int)a1, &s2) )
  {
    if ( v6 == 4 )
    {
      v2 = sub_804B05A(a1[36], &s2);
      sub_804A710(a1, a2, (a2 != 8) ^ (v2 == 0));
      v4 = 1;
    }
    else
    {
      sub_804AA78((int)a1, &s2);
      SourceError((int)a1, "expected name after #ifdef, found %s", &s2);
      v4 = 0;
    }
  }
  else
  {
    SourceError((int)a1, "#ifdef without name");
    v4 = 0;
  }
  return v4;
}

//----- (0804CB86) --------------------------------------------------------
signed int __cdecl sub_804CB86(_DWORD *a1)
{
  return sub_804CA90(a1, 8);
}

//----- (0804CBA2) --------------------------------------------------------
signed int __cdecl sub_804CBA2(_DWORD *a1)
{
  return sub_804CA90(a1, 16);
}

//----- (0804CBBE) --------------------------------------------------------
signed int __cdecl sub_804CBBE(_DWORD *a1)
{
  signed int v2; // [esp+Ch] [ebp-Ch]
  char v3[4]; // [esp+10h] [ebp-8h]
  int v4; // [esp+14h] [ebp-4h]

  sub_804A782(a1, &v4, v3);
  if ( v4 )
  {
    if ( v4 == 2 )
    {
      SourceError((int)a1, "#else after #else");
      v2 = 0;
    }
    else
    {
      sub_804A710(a1, 2, *(_DWORD *)v3 == 0);
      v2 = 1;
    }
  }
  else
  {
    SourceError((int)a1, "misplaced #else");
    v2 = 0;
  }
  return v2;
}

//----- (0804CC4E) --------------------------------------------------------
signed int __cdecl sub_804CC4E(_DWORD *a1)
{
  char v3; // [esp+10h] [ebp-8h]
  int v4; // [esp+14h] [ebp-4h]

  sub_804A782(a1, &v4, &v3);
  if ( v4 )
    return 1;
  SourceError((int)a1, "misplaced #endif");
  return 0;
}

//----- (0804CC9C) --------------------------------------------------------
signed int __cdecl sub_804CC9C(int a1)
{
  signed int v2; // [esp+4h] [ebp-4h]

  switch ( a1 )
  {
    case 5:
      v2 = 7;
      break;
    case 6:
      v2 = 6;
      break;
    case 7:
      v2 = 12;
      break;
    case 8:
      v2 = 12;
      break;
    case 9:
      v2 = 11;
      break;
    case 10:
      v2 = 11;
      break;
    case 21:
      v2 = 13;
      break;
    case 22:
      v2 = 13;
      break;
    case 26:
      v2 = 15;
      break;
    case 27:
      v2 = 15;
      break;
    case 28:
      v2 = 15;
      break;
    case 29:
      v2 = 14;
      break;
    case 30:
      v2 = 14;
      break;
    case 32:
      v2 = 10;
      break;
    case 33:
      v2 = 8;
      break;
    case 34:
      v2 = 9;
      break;
    case 35:
      v2 = 16;
      break;
    case 36:
      v2 = 16;
      break;
    case 37:
      v2 = 12;
      break;
    case 38:
      v2 = 12;
      break;
    case 42:
      v2 = 5;
      break;
    case 43:
      v2 = 5;
      break;
    default:
      v2 = 0;
      break;
  }
  return v2;
}

//----- (0804CDAC) --------------------------------------------------------
signed int __cdecl sub_804CDAC(int a1, char *a2, _DWORD *a3, double *a4, int a5)
{
  long double v5; // ST24_12
  char *v6; // ebx
  double v8; // [esp+38h] [ebp-C10h]
  double v9; // [esp+48h] [ebp-C00h]
  double v10; // [esp+58h] [ebp-BF0h]
  double v11; // [esp+68h] [ebp-BE0h]
  double v12; // [esp+78h] [ebp-BD0h]
  double v13; // [esp+88h] [ebp-BC0h]
  unsigned __int8 v14; // [esp+9Bh] [ebp-BADh]
  signed int v15; // [esp+A0h] [ebp-BA8h]
  unsigned __int8 v16; // [esp+ABh] [ebp-B9Dh]
  signed int v17; // [esp+B0h] [ebp-B98h]
  double v18; // [esp+B8h] [ebp-B90h]
  signed int v19; // [esp+C4h] [ebp-B84h]
  signed int v21; // [esp+DCh] [ebp-B6Ch]
  char v22[1548]; // [esp+E0h] [ebp-B68h]
  int v23; // [esp+6ECh] [ebp-55Ch]
  char v24[1280]; // [esp+6F0h] [ebp-558h]
  int v25; // [esp+BF0h] [ebp-58h]
  int v26; // [esp+BF4h] [ebp-54h]
  double v27; // [esp+BF8h] [ebp-50h]
  int v28; // [esp+C04h] [ebp-44h]
  int v29; // [esp+C08h] [ebp-40h]
  int v30; // [esp+C0Ch] [ebp-3Ch]
  int v31; // [esp+C10h] [ebp-38h]
  int v32; // [esp+C14h] [ebp-34h]
  int v33; // [esp+C18h] [ebp-30h]
  char *s1; // [esp+C1Ch] [ebp-2Ch]
  int v35; // [esp+C20h] [ebp-28h]
  char *v36; // [esp+C24h] [ebp-24h]
  char *v37; // [esp+C28h] [ebp-20h]
  char *v38; // [esp+C2Ch] [ebp-1Ch]
  char *j; // [esp+C30h] [ebp-18h]
  char *v40; // [esp+C34h] [ebp-14h]
  char *v41; // [esp+C38h] [ebp-10h]
  char *i; // [esp+C3Ch] [ebp-Ch]

  v33 = 0;
  v32 = 0;
  v31 = 0;
  v30 = 0;
  v29 = 0;
  v28 = 0;
  v27 = 0.0;
  v26 = 0;
  v25 = 0;
  v23 = 0;
  v21 = 0;
  v40 = 0;
  v41 = 0;
  v37 = 0;
  v38 = 0;
  if ( a3 )
    *a3 = 0;
  if ( a4 )
    *a4 = 0.0;
  for ( s1 = a2; s1; s1 = (char *)*((_DWORD *)s1 + 266) )
  {
    v19 = *((_DWORD *)s1 + 256);
    if ( v19 == 4 )
    {
      if ( v30 || v29 )
      {
        SourceError(a1, "syntax error in #if/#elif");
        v31 = 1;
      }
      else if ( !strcmp(s1, "defined") )
      {
        s1 = (char *)*((_DWORD *)s1 + 266);
        if ( !strcmp(s1, "(") )
        {
          v33 = 1;
          s1 = (char *)*((_DWORD *)s1 + 266);
        }
        if ( s1 && *((_DWORD *)s1 + 256) == 4 )
        {
          if ( v21 <= 63 )
          {
            j = &v22[24 * v21++];
            if ( sub_804B05A(*(_DWORD *)(a1 + 144), s1) )
            {
              *(_DWORD *)j = 1;
              *(double *)(j + 4) = 1.0;
            }
            else
            {
              *(_DWORD *)j = 0;
              *(double *)(j + 4) = 0.0;
            }
            *((_DWORD *)j + 3) = v32;
            *((_DWORD *)j + 5) = 0;
            *((_DWORD *)j + 4) = v37;
            if ( v37 )
              *((_DWORD *)v37 + 5) = j;
            else
              v38 = j;
            v37 = j;
            if ( !v33 || (s1 = (char *)*((_DWORD *)s1 + 266)) != 0 && !strcmp(s1, ")") )
            {
              v33 = 0;
              v30 = 1;
            }
            else
            {
              SourceError(a1, "defined without ) in #if/#elif");
              v31 = 1;
            }
          }
          else
          {
            SourceError(a1, "out of value space\n");
            v31 = 1;
          }
        }
        else
        {
          SourceError(a1, "defined without name in #if/#elif");
          v31 = 1;
        }
      }
      else
      {
        SourceError(a1, "undefined name %s in #if/#elif", s1);
        v31 = 1;
      }
    }
    else if ( v19 > 4 )
    {
      if ( v19 != 5 )
      {
LABEL_80:
        SourceError(a1, "unknown %s in #if/#elif", s1);
        v31 = 1;
        goto LABEL_81;
      }
      if ( v29 )
      {
        SourceError(a1, "misplaced minus sign in #if/#elif");
        v31 = 1;
      }
      else if ( *((_DWORD *)s1 + 257) == 44 )
      {
        ++v32;
      }
      else if ( *((_DWORD *)s1 + 257) == 45 )
      {
        if ( --v32 < 0 )
        {
          SourceError(a1, "too many ) in #if/#elsif");
          v31 = 1;
        }
      }
      else if ( a5
             || *((_DWORD *)s1 + 257) != 35
             && *((_DWORD *)s1 + 257) != 28
             && *((_DWORD *)s1 + 257) != 21
             && *((_DWORD *)s1 + 257) != 22
             && *((_DWORD *)s1 + 257) != 32
             && *((_DWORD *)s1 + 257) != 33
             && *((_DWORD *)s1 + 257) != 34 )
      {
        switch ( *((_DWORD *)s1 + 257) )
        {
          case 5:
          case 6:
          case 7:
          case 8:
          case 9:
          case 0xA:
          case 0x15:
          case 0x16:
          case 0x1A:
          case 0x1B:
          case 0x1C:
          case 0x1D:
          case 0x20:
          case 0x21:
          case 0x22:
          case 0x25:
          case 0x26:
          case 0x2A:
          case 0x2B:
            goto LABEL_69;
          case 0x10:
          case 0x11:
            SourceError(a1, "++ or -- used in #if/#elif");
            break;
          case 0x1E:
            if ( v30 )
            {
LABEL_69:
              if ( !v30 )
              {
                SourceError(a1, "operator %s after operator in #if/#elif", s1);
                v31 = 1;
              }
            }
            else
            {
              v29 = 1;
            }
            break;
          case 0x23:
          case 0x24:
            if ( v30 )
            {
              SourceError(a1, "! or ~ after value in #if/#elif");
              v31 = 1;
            }
            break;
          default:
            SourceError(a1, "invalid operator %s in #if/#elif", s1);
            v31 = 1;
            break;
        }
        if ( !v31 && !v29 )
        {
          if ( v23 <= 63 )
          {
            i = &v24[20 * v23++];
            *(_DWORD *)i = *((_DWORD *)s1 + 257);
            v6 = i;
            *((_DWORD *)v6 + 1) = sub_804CC9C(*((_DWORD *)s1 + 257));
            *((_DWORD *)i + 2) = v32;
            *((_DWORD *)i + 4) = 0;
            *((_DWORD *)i + 3) = v40;
            if ( v40 )
              *((_DWORD *)v40 + 4) = i;
            else
              v41 = i;
            v40 = i;
            v30 = 0;
          }
          else
          {
            SourceError(a1, "out of operator space\n");
            v31 = 1;
          }
        }
      }
      else
      {
        SourceError(a1, "illigal operator %s on floating point operands\n", s1);
        v31 = 1;
      }
    }
    else
    {
      if ( v19 != 3 )
        goto LABEL_80;
      if ( v30 )
      {
        SourceError(a1, "syntax error in #if/#elif");
        v31 = 1;
      }
      else if ( v21 <= 63 )
      {
        j = &v22[24 * v21++];
        if ( v29 )
        {
          *(_DWORD *)j = -*((_DWORD *)s1 + 258);
          LODWORD(v5) = *((_DWORD *)s1 + 259);
          *(_QWORD *)((char *)&v5 + 4) = *((_QWORD *)s1 + 130);
          *(double *)(j + 4) = -v5;
        }
        else
        {
          *(_DWORD *)j = *((_DWORD *)s1 + 258);
          *(double *)(j + 4) = *(long double *)(s1 + 1036);
        }
        *((_DWORD *)j + 3) = v32;
        *((_DWORD *)j + 5) = 0;
        *((_DWORD *)j + 4) = v37;
        if ( v37 )
          *((_DWORD *)v37 + 5) = j;
        else
          v38 = j;
        v37 = j;
        v30 = 1;
        v29 = 0;
      }
      else
      {
        SourceError(a1, "out of value space\n");
        v31 = 1;
      }
    }
LABEL_81:
    if ( v31 )
      break;
  }
  if ( !v31 )
  {
    if ( v30 )
    {
      if ( v32 )
      {
        SourceError(a1, "too many ( in #if/#elif");
        v31 = 1;
      }
    }
    else
    {
      SourceError(a1, "trailing operator in #if/#elif");
      v31 = 1;
    }
  }
  v26 = 0;
  v28 = 0;
  v27 = 0.0;
  while ( !v31 && v41 )
  {
    j = v38;
    for ( i = v41;
          *((_DWORD *)i + 4)
       && *((_DWORD *)i + 2) <= *(_DWORD *)(*((_DWORD *)i + 4) + 8)
       && (*((_DWORD *)i + 2) != *(_DWORD *)(*((_DWORD *)i + 4) + 8)
        || *((_DWORD *)i + 1) < *(_DWORD *)(*((_DWORD *)i + 4) + 4));
          i = (char *)*((_DWORD *)i + 4) )
    {
      if ( *(_DWORD *)i != 36 && *(_DWORD *)i != 35 )
        j = (char *)*((_DWORD *)j + 5);
      if ( !j )
      {
        SourceError(a1, "mising values in #if/#elif");
        v31 = 1;
        break;
      }
    }
    if ( v31 )
      break;
    v36 = j;
    v35 = *((_DWORD *)j + 5);
    switch ( *(_DWORD *)i )
    {
      case 5:
        v17 = 0;
        if ( *(_DWORD *)v36 && *(_DWORD *)v35 )
          v17 = 1;
        *(_DWORD *)v36 = v17;
        v16 = 0;
        if ( *(double *)(v36 + 4) != 0.0 && *(double *)(v35 + 4) != 0.0 )
          v16 = 1;
        *(double *)(v36 + 4) = (long double)v16;
        break;
      case 6:
        v15 = 0;
        if ( *(_DWORD *)v36 || *(_DWORD *)v35 )
          v15 = 1;
        *(_DWORD *)v36 = v15;
        v14 = 0;
        if ( *(double *)(v36 + 4) != 0.0 || *(double *)(v35 + 4) != 0.0 )
          v14 = 1;
        *(double *)(v36 + 4) = (long double)v14;
        break;
      case 7:
        *(_DWORD *)v36 = *(_DWORD *)v36 >= *(_DWORD *)v35;
        if ( *(double *)(v36 + 4) < (long double)*(double *)(v35 + 4) )
          v13 = 0.0;
        else
          v13 = 1.0;
        *(double *)(v36 + 4) = v13;
        break;
      case 8:
        *(_DWORD *)v36 = *(_DWORD *)v36 <= *(_DWORD *)v35;
        if ( *(double *)(v35 + 4) < (long double)*(double *)(v36 + 4) )
          v12 = 0.0;
        else
          v12 = 1.0;
        *(double *)(v36 + 4) = v12;
        break;
      case 9:
        *(_DWORD *)v36 = *(_DWORD *)v36 == *(_DWORD *)v35;
        if ( *(double *)(v36 + 4) == *(double *)(v35 + 4) )
          v11 = 1.0;
        else
          v11 = 0.0;
        *(double *)(v36 + 4) = v11;
        break;
      case 0xA:
        *(_DWORD *)v36 = *(_DWORD *)v36 != *(_DWORD *)v35;
        if ( *(double *)(v36 + 4) == *(double *)(v35 + 4) )
          v10 = 0.0;
        else
          v10 = 1.0;
        *(double *)(v36 + 4) = v10;
        break;
      case 0x15:
        *(_DWORD *)v36 >>= *(_BYTE *)v35;
        break;
      case 0x16:
        *(_DWORD *)v36 <<= *(_BYTE *)v35;
        break;
      case 0x1A:
        *(_DWORD *)v36 *= *(_DWORD *)v35;
        *(double *)(v36 + 4) = *(double *)(v36 + 4) * *(double *)(v35 + 4);
        break;
      case 0x1B:
        if ( *(_DWORD *)v35 && *(double *)(v35 + 4) != 0.0 )
        {
          *(_DWORD *)v36 /= *(_DWORD *)v35;
          *(double *)(v36 + 4) = *(double *)(v36 + 4) / *(double *)(v35 + 4);
        }
        else
        {
          SourceError(a1, "divide by zero in #if/#elif\n");
          v31 = 1;
        }
        break;
      case 0x1C:
        if ( *(_DWORD *)v35 )
        {
          *(_DWORD *)v36 %= *(_DWORD *)v35;
        }
        else
        {
          SourceError(a1, "divide by zero in #if/#elif\n");
          v31 = 1;
        }
        break;
      case 0x1D:
        *(_DWORD *)v36 += *(_DWORD *)v35;
        *(double *)(v36 + 4) = *(double *)(v36 + 4) + *(double *)(v35 + 4);
        break;
      case 0x1E:
        *(_DWORD *)v36 -= *(_DWORD *)v35;
        *(double *)(v36 + 4) = *(double *)(v36 + 4) - *(double *)(v35 + 4);
        break;
      case 0x20:
        *(_DWORD *)v36 &= *(_DWORD *)v35;
        break;
      case 0x21:
        *(_DWORD *)v36 |= *(_DWORD *)v35;
        break;
      case 0x22:
        *(_DWORD *)v36 ^= *(_DWORD *)v35;
        break;
      case 0x23:
        *(_DWORD *)v36 = ~*(_DWORD *)v36;
        break;
      case 0x24:
        *(_DWORD *)v36 = *(_DWORD *)v36 == 0;
        if ( *(double *)(v36 + 4) == 0.0 )
          v18 = 1.0;
        else
          v18 = 0.0;
        *(double *)(v36 + 4) = v18;
        break;
      case 0x25:
        *(_DWORD *)v36 = *(_DWORD *)v36 > *(_DWORD *)v35;
        if ( *(double *)(v36 + 4) <= (long double)*(double *)(v35 + 4) )
          v9 = 0.0;
        else
          v9 = 1.0;
        *(double *)(v36 + 4) = v9;
        break;
      case 0x26:
        *(_DWORD *)v36 = *(_DWORD *)v36 < *(_DWORD *)v35;
        if ( *(double *)(v35 + 4) <= (long double)*(double *)(v36 + 4) )
          v8 = 0.0;
        else
          v8 = 1.0;
        *(double *)(v36 + 4) = v8;
        break;
      case 0x2A:
        if ( v26 )
        {
          if ( a5 )
          {
            if ( !v28 )
              *(_DWORD *)v36 = *(_DWORD *)v35;
          }
          else if ( v27 == 0.0 )
          {
            *(double *)(v36 + 4) = *(double *)(v35 + 4);
          }
          v26 = 0;
        }
        else
        {
          SourceError(a1, ": without ? in #if/#elif");
          v31 = 1;
        }
        break;
      case 0x2B:
        if ( v26 )
        {
          SourceError(a1, "? after ? in #if/#elif");
          v31 = 1;
        }
        else
        {
          v28 = *(_DWORD *)v36;
          v27 = *(double *)(v36 + 4);
          v26 = 1;
        }
        break;
      default:
        break;
    }
    if ( v31 )
      break;
    v25 = *(_DWORD *)i;
    if ( *(_DWORD *)i != 36 && *(_DWORD *)i != 35 )
    {
      if ( *(_DWORD *)i != 43 )
        j = (char *)*((_DWORD *)j + 5);
      if ( *((_DWORD *)j + 4) )
        *(_DWORD *)(*((_DWORD *)j + 4) + 20) = *((_DWORD *)j + 5);
      else
        v38 = (char *)*((_DWORD *)j + 5);
      if ( *((_DWORD *)j + 5) )
        *(_DWORD *)(*((_DWORD *)j + 5) + 16) = *((_DWORD *)j + 4);
      else
        v37 = (char *)*((_DWORD *)j + 4);
    }
    if ( *((_DWORD *)i + 3) )
      *(_DWORD *)(*((_DWORD *)i + 3) + 16) = *((_DWORD *)i + 4);
    else
      v41 = (char *)*((_DWORD *)i + 4);
    if ( *((_DWORD *)i + 4) )
      *(_DWORD *)(*((_DWORD *)i + 4) + 12) = *((_DWORD *)i + 3);
    else
      v40 = (char *)*((_DWORD *)i + 3);
  }
  if ( v38 )
  {
    if ( a3 )
      *a3 = *(_DWORD *)v38;
    if ( a4 )
      *a4 = *(double *)(v38 + 4);
  }
  for ( i = v41; i; i = v40 )
    v40 = (char *)*((_DWORD *)i + 4);
  for ( j = v38; j; j = v37 )
    v37 = (char *)*((_DWORD *)j + 5);
  if ( !v31 )
    return 1;
  if ( a3 )
    *a3 = 0;
  if ( a4 )
    *a4 = 0.0;
  return 0;
}
// 804CDAC: using guessed type char var_B68[1548];
// 804CDAC: using guessed type char var_558[1280];

//----- (0804DD32) --------------------------------------------------------
signed int __cdecl sub_804DD32(int a1, _DWORD *a2, double *a3, int a4)
{
  int v4; // ST30_4
  signed int v6; // [esp+24h] [ebp-454h]
  signed int v7; // [esp+28h] [ebp-450h]
  int v8; // [esp+2Ch] [ebp-44Ch]
  char *v9; // [esp+34h] [ebp-444h]
  char *v10; // [esp+34h] [ebp-444h]
  char *v11; // [esp+34h] [ebp-444h]
  int i; // [esp+34h] [ebp-444h]
  char *v13; // [esp+38h] [ebp-440h]
  char *v14; // [esp+3Ch] [ebp-43Ch]
  char s1; // [esp+40h] [ebp-438h]
  int v16; // [esp+440h] [ebp-38h]

  v7 = 0;
  if ( a2 )
    *a2 = 0;
  if ( a3 )
    *a3 = 0.0;
  if ( sub_804BD8C(a1, &s1) )
  {
    v14 = 0;
    v13 = 0;
    do
    {
      if ( v16 == 4 )
      {
        if ( v7 )
        {
          v7 = 0;
          v9 = (char *)sub_804A898(&s1);
          *((_DWORD *)v9 + 266) = 0;
          if ( v13 )
            *((_DWORD *)v13 + 266) = v9;
          else
            v14 = v9;
          v13 = v9;
        }
        else if ( !strcmp(&s1, "defined") )
        {
          v7 = 1;
          v10 = (char *)sub_804A898(&s1);
          *((_DWORD *)v10 + 266) = 0;
          if ( v13 )
            *((_DWORD *)v13 + 266) = v10;
          else
            v14 = v10;
          v13 = v10;
        }
        else
        {
          v8 = sub_804B05A(*(_DWORD *)(a1 + 144), &s1);
          if ( !v8 )
          {
            SourceError(a1, "can't evaluate %s, not defined", &s1);
            return 0;
          }
          if ( !sub_804BA0A(a1, &s1, v8) )
            return 0;
        }
      }
      else
      {
        if ( v16 != 3 && v16 != 5 )
        {
          SourceError(a1, "can't evaluate %s", &s1);
          return 0;
        }
        v11 = (char *)sub_804A898(&s1);
        *((_DWORD *)v11 + 266) = 0;
        if ( v13 )
          *((_DWORD *)v13 + 266) = v11;
        else
          v14 = v11;
        v13 = v11;
      }
    }
    while ( sub_804BD8C(a1, &s1) );
    if ( sub_804CDAC(a1, v14, a2, a3, a4) )
    {
      for ( i = (int)v14; i; i = v4 )
      {
        v4 = *(_DWORD *)(i + 1064);
        sub_804A908(i);
      }
      v6 = 1;
    }
    else
    {
      v6 = 0;
    }
  }
  else
  {
    SourceError(a1, "no value after #if/#elif");
    v6 = 0;
  }
  return v6;
}

//----- (0804E07C) --------------------------------------------------------
signed int __cdecl sub_804E07C(int a1, _DWORD *a2, double *a3, int a4)
{
  int v4; // ST30_4
  int v7; // [esp+2Ch] [ebp-45Ch]
  char *v8; // [esp+34h] [ebp-454h]
  char *v9; // [esp+34h] [ebp-454h]
  char *v10; // [esp+34h] [ebp-454h]
  int i; // [esp+34h] [ebp-454h]
  char *v12; // [esp+38h] [ebp-450h]
  char *v13; // [esp+3Ch] [ebp-44Ch]
  char s1; // [esp+40h] [ebp-448h]
  int v15; // [esp+440h] [ebp-48h]
  int v16; // [esp+478h] [ebp-10h]
  int v17; // [esp+47Ch] [ebp-Ch]

  v16 = 0;
  if ( a2 )
    *a2 = 0;
  if ( a3 )
    *a3 = 0.0;
  if ( !sub_804A922(a1, &s1) )
  {
    SourceError(a1, "no leading ( after $evalint/$evalfloat");
    return 0;
  }
  if ( !sub_804A922(a1, &s1) )
  {
    SourceError(a1, "nothing to evaluate");
    return 0;
  }
  v17 = 1;
  v13 = 0;
  v12 = 0;
  do
  {
    if ( v15 == 4 )
    {
      if ( v16 )
      {
        v16 = 0;
        v8 = (char *)sub_804A898(&s1);
        *((_DWORD *)v8 + 266) = 0;
        if ( v12 )
          *((_DWORD *)v12 + 266) = v8;
        else
          v13 = v8;
        v12 = v8;
      }
      else if ( !strcmp(&s1, "defined") )
      {
        v16 = 1;
        v9 = (char *)sub_804A898(&s1);
        *((_DWORD *)v9 + 266) = 0;
        if ( v12 )
          *((_DWORD *)v12 + 266) = v9;
        else
          v13 = v9;
        v12 = v9;
      }
      else
      {
        v7 = sub_804B05A(*(_DWORD *)(a1 + 144), &s1);
        if ( !v7 )
        {
          SourceError(a1, "can't evaluate %s, not defined", &s1);
          return 0;
        }
        if ( !sub_804BA0A(a1, &s1, v7) )
          return 0;
      }
      continue;
    }
    if ( v15 != 3 && v15 != 5 )
    {
      SourceError(a1, "can't evaluate %s", &s1);
      return 0;
    }
    if ( s1 == 40 )
    {
      ++v17;
    }
    else if ( s1 == 41 )
    {
      --v17;
    }
    if ( v17 <= 0 )
      break;
    v10 = (char *)sub_804A898(&s1);
    *((_DWORD *)v10 + 266) = 0;
    if ( v12 )
      *((_DWORD *)v12 + 266) = v10;
    else
      v13 = v10;
    v12 = v10;
  }
  while ( sub_804A922(a1, &s1) );
  if ( !sub_804CDAC(a1, v13, a2, a3, a4) )
    return 0;
  for ( i = (int)v13; i; i = v4 )
  {
    v4 = *(_DWORD *)(i + 1064);
    sub_804A908(i);
  }
  return 1;
}

//----- (0804E428) --------------------------------------------------------
signed int __cdecl sub_804E428(_DWORD *a1)
{
  signed int v2; // [esp+18h] [ebp-10h]
  char v3[4]; // [esp+1Ch] [ebp-Ch]
  int v4; // [esp+20h] [ebp-8h]
  int v5; // [esp+24h] [ebp-4h]

  sub_804A782(a1, &v4, v3);
  if ( v4 && v4 != 2 )
  {
    if ( sub_804DD32((int)a1, &v5, 0, 1) )
    {
      *(_DWORD *)v3 = v5 == 0;
      sub_804A710(a1, 4, *(int *)v3);
      v2 = 1;
    }
    else
    {
      v2 = 0;
    }
  }
  else
  {
    SourceError((int)a1, "misplaced #elif");
    v2 = 0;
  }
  return v2;
}

//----- (0804E4D4) --------------------------------------------------------
signed int __cdecl sub_804E4D4(_DWORD *a1)
{
  int v3; // [esp+24h] [ebp-4h]

  if ( !sub_804DD32((int)a1, &v3, 0, 1) )
    return 0;
  sub_804A710(a1, 1, v3 == 0);
  return 1;
}

//----- (0804E53C) --------------------------------------------------------
int __cdecl sub_804E53C(int a1)
{
  SourceError(a1, "#line directive not supported");
  return 0;
}

//----- (0804E55C) --------------------------------------------------------
int __cdecl sub_804E55C(int a1)
{
  char dest; // [esp+10h] [ebp-438h]

  strcpy(&dest, &byte_813A549);
  sub_804A922(a1, &dest);
  SourceError(a1, "#error directive: %s", &dest);
  return 0;
}

//----- (0804E5B4) --------------------------------------------------------
signed int __cdecl sub_804E5B4(int a1)
{
  char s1; // [esp+10h] [ebp-438h]

  SourceWarning(a1, "#pragma directive not supported");
  while ( sub_804BD8C(a1, &s1) )
    ;
  return 1;
}

//----- (0804E5F0) --------------------------------------------------------
int __cdecl sub_804E5F0(int a1)
{
  char dest; // [esp+10h] [ebp-438h]
  int v3; // [esp+410h] [ebp-38h]
  int v4; // [esp+414h] [ebp-34h]
  int v5; // [esp+428h] [ebp-20h]
  int v6; // [esp+42Ch] [ebp-1Ch]
  int v7; // [esp+430h] [ebp-18h]
  int v8; // [esp+434h] [ebp-14h]

  v7 = *(_DWORD *)(*(_DWORD *)(a1 + 132) + 92);
  v5 = *(_DWORD *)(*(_DWORD *)(a1 + 132) + 68);
  v6 = *(_DWORD *)(*(_DWORD *)(a1 + 132) + 68);
  v8 = 0;
  strcpy(&dest, "-");
  v3 = 5;
  v4 = 30;
  return sub_804AA78(a1, &dest);
}

//----- (0804E668) --------------------------------------------------------
signed int __cdecl sub_804E668(int a1)
{
  int v2; // [esp+18h] [ebp-450h]
  char s; // [esp+20h] [ebp-448h]
  int v5; // [esp+420h] [ebp-48h]
  int v6; // [esp+424h] [ebp-44h]
  int v7; // [esp+438h] [ebp-30h]
  int v8; // [esp+43Ch] [ebp-2Ch]
  int v9; // [esp+440h] [ebp-28h]
  int v10; // [esp+444h] [ebp-24h]
  int v11; // [esp+45Ch] [ebp-Ch]

  if ( !sub_804DD32(a1, &v11, 0, 1) )
    return 0;
  v9 = *(_DWORD *)(*(_DWORD *)(a1 + 132) + 92);
  v7 = *(_DWORD *)(*(_DWORD *)(a1 + 132) + 68);
  v8 = *(_DWORD *)(*(_DWORD *)(a1 + 132) + 68);
  v10 = 0;
  v2 = v11;
  if ( v11 < 0 )
    v2 = -v11;
  sprintf(&s, "%d", v2);
  v5 = 3;
  v6 = 12296;
  sub_804AA78(a1, &s);
  if ( v11 < 0 )
    sub_804E5F0(a1);
  return 1;
}

//----- (0804E758) --------------------------------------------------------
signed int __cdecl sub_804E758(int a1)
{
  float v1; // ST00_4
  long double v2; // fst7
  char s; // [esp+20h] [ebp-448h]
  int v6; // [esp+420h] [ebp-48h]
  int v7; // [esp+424h] [ebp-44h]
  int v8; // [esp+438h] [ebp-30h]
  int v9; // [esp+43Ch] [ebp-2Ch]
  int v10; // [esp+440h] [ebp-28h]
  int v11; // [esp+444h] [ebp-24h]
  double v12; // [esp+458h] [ebp-10h]

  if ( !sub_804DD32(a1, 0, &v12, 0) )
    return 0;
  v10 = *(_DWORD *)(*(_DWORD *)(a1 + 132) + 92);
  v8 = *(_DWORD *)(*(_DWORD *)(a1 + 132) + 68);
  v9 = *(_DWORD *)(*(_DWORD *)(a1 + 132) + 68);
  v11 = 0;
  v1 = v12;
  v2 = sub_804FB38(v1);
  sprintf(&s, "%1.2f", (double)v2);
  v6 = 3;
  v7 = 10248;
  sub_804AA78(a1, &s);
  if ( v12 < 0.0 )
    sub_804E5F0(a1);
  return 1;
}

//----- (0804E83E) --------------------------------------------------------
signed int __cdecl sub_804E83E(int a1)
{
  int v2; // [esp+18h] [ebp-440h]
  int i; // [esp+1Ch] [ebp-43Ch]
  char s2; // [esp+20h] [ebp-438h]
  int v5; // [esp+420h] [ebp-38h]
  int v6; // [esp+444h] [ebp-14h]

  if ( sub_804A922(a1, &s2) )
  {
    if ( v6 <= 0 )
    {
      if ( v5 == 4 )
      {
        for ( i = 0; (&s1)[2 * i]; ++i )
        {
          if ( !strcmp((&s1)[2 * i], &s2) )
            return (*(&off_815A024 + 2 * i))(a1);
        }
      }
      SourceError(a1, "unknown precompiler directive %s", &s2);
      v2 = 0;
    }
    else
    {
      sub_804AA78(a1, &s2);
      SourceError(a1, "found # at end of line");
      v2 = 0;
    }
  }
  else
  {
    SourceError(a1, "found # without name");
    v2 = 0;
  }
  return v2;
}
// 815A024: using guessed type int (__cdecl *off_815A024)(int);

//----- (0804E95A) --------------------------------------------------------
signed int __cdecl sub_804E95A(int a1)
{
  int v2; // [esp+18h] [ebp-450h]
  char s; // [esp+20h] [ebp-448h]
  int v5; // [esp+420h] [ebp-48h]
  int v6; // [esp+424h] [ebp-44h]
  int v7; // [esp+428h] [ebp-40h]
  long double v8; // [esp+42Ch] [ebp-3Ch]
  int v9; // [esp+438h] [ebp-30h]
  int v10; // [esp+43Ch] [ebp-2Ch]
  int v11; // [esp+440h] [ebp-28h]
  int v12; // [esp+444h] [ebp-24h]
  int v13; // [esp+45Ch] [ebp-Ch]

  if ( !sub_804E07C(a1, &v13, 0, 1) )
    return 0;
  v11 = *(_DWORD *)(*(_DWORD *)(a1 + 132) + 92);
  v9 = *(_DWORD *)(*(_DWORD *)(a1 + 132) + 68);
  v10 = *(_DWORD *)(*(_DWORD *)(a1 + 132) + 68);
  v12 = 0;
  v2 = v13;
  if ( v13 < 0 )
    v2 = -v13;
  sprintf(&s, "%d", v2);
  v5 = 3;
  v6 = 12296;
  v7 = v13;
  v8 = (long double)v13;
  sub_804AA78(a1, &s);
  if ( v13 < 0 )
    sub_804E5F0(a1);
  return 1;
}

//----- (0804EA56) --------------------------------------------------------
signed int __cdecl sub_804EA56(int a1)
{
  float v1; // ST00_4
  long double v2; // fst7
  char s; // [esp+30h] [ebp-448h]
  int v6; // [esp+430h] [ebp-48h]
  int v7; // [esp+434h] [ebp-44h]
  int v8; // [esp+438h] [ebp-40h]
  long double v9; // [esp+43Ch] [ebp-3Ch]
  int v10; // [esp+448h] [ebp-30h]
  int v11; // [esp+44Ch] [ebp-2Ch]
  int v12; // [esp+450h] [ebp-28h]
  int v13; // [esp+454h] [ebp-24h]
  double v14; // [esp+468h] [ebp-10h]

  if ( !sub_804E07C(a1, 0, &v14, 0) )
    return 0;
  v12 = *(_DWORD *)(*(_DWORD *)(a1 + 132) + 92);
  v10 = *(_DWORD *)(*(_DWORD *)(a1 + 132) + 68);
  v11 = *(_DWORD *)(*(_DWORD *)(a1 + 132) + 68);
  v13 = 0;
  v1 = v14;
  v2 = sub_804FB38(v1);
  sprintf(&s, "%1.2f", (double)v2);
  v6 = 3;
  v7 = 10248;
  v8 = (signed __int64)v14;
  v9 = v14;
  sub_804AA78(a1, &s);
  if ( v14 < 0.0 )
    sub_804E5F0(a1);
  return 1;
}

//----- (0804EB7E) --------------------------------------------------------
signed int __cdecl sub_804EB7E(int a1)
{
  int v2; // [esp+18h] [ebp-440h]
  int i; // [esp+1Ch] [ebp-43Ch]
  char s2; // [esp+20h] [ebp-438h]
  int v5; // [esp+420h] [ebp-38h]
  int v6; // [esp+444h] [ebp-14h]

  if ( sub_804A922(a1, &s2) )
  {
    if ( v6 <= 0 )
    {
      if ( v5 == 4 )
      {
        for ( i = 0; (&off_815A0C0)[2 * i]; ++i )
        {
          if ( !strcmp((&off_815A0C0)[2 * i], &s2) )
            return (*(&off_815A0C4 + 2 * i))(a1);
        }
      }
      sub_804AA78(a1, &s2);
      SourceError(a1, "unknown precompiler directive %s", &s2);
      v2 = 0;
    }
    else
    {
      sub_804AA78(a1, &s2);
      SourceError(a1, "found $ at end of line");
      v2 = 0;
    }
  }
  else
  {
    SourceError(a1, "found $ without name");
    v2 = 0;
  }
  return v2;
}
// 815A0C4: using guessed type int (__cdecl *off_815A0C4)(int);

//----- (0804ECB0) --------------------------------------------------------
int __cdecl sub_804ECB0(int a1, char *s)
{
  size_t v2; // ebx
  char src; // [esp+20h] [ebp-448h]
  _BYTE v6[3]; // [esp+21h] [ebp-447h]
  int v7; // [esp+420h] [ebp-48h]
  int v8; // [esp+45Ch] [ebp-Ch]

  while ( 1 )
  {
    do
    {
      while ( 1 )
      {
        while ( 1 )
        {
          if ( !sub_804A922(a1, s) )
            return 0;
          if ( *((_DWORD *)s + 256) != 5 || *s != 35 )
            break;
          if ( !sub_804E83E(a1) )
            return 0;
        }
        if ( *((_DWORD *)s + 256) != 5 || *s != 36 )
          break;
        if ( !sub_804EB7E(a1) )
          return 0;
      }
      if ( *((_DWORD *)s + 256) == 1 && sub_804ECB0(a1, &src) )
      {
        if ( v7 == 1 )
        {
          s[strlen(s) - 1] = 0;
          v2 = strlen(s);
          if ( strlen(v6) + v2 + 1 > 0x3FF )
          {
            SourceError(a1, "string longer than MAX_TOKEN %d\n", 1024);
            return 0;
          }
          strcat(s, v6);
        }
        else
        {
          sub_804F3FC(a1, &src);
        }
      }
    }
    while ( *(_DWORD *)(a1 + 152) );
    if ( *((_DWORD *)s + 256) != 4 )
      break;
    v8 = sub_804B05A(*(_DWORD *)(a1 + 144), s);
    if ( !v8 )
      break;
    if ( !sub_804BA0A(a1, s, v8) )
      return 0;
  }
  memcpy((void *)(a1 + 156), s, 0x42Cu);
  return 1;
}

//----- (0804EEAC) --------------------------------------------------------
int __cdecl sub_804EEAC(int a1, char *s2)
{
  signed int v3; // [esp+1Ch] [ebp-43Ch]
  char s1; // [esp+20h] [ebp-438h]

  if ( sub_804ECB0(a1, &s1) )
  {
    if ( !strcmp(&s1, s2) )
    {
      v3 = 1;
    }
    else
    {
      SourceError(a1, "expected %s, found %s", s2, &s1);
      v3 = 0;
    }
  }
  else
  {
    SourceError(a1, "couldn't find expected %s", s2);
    v3 = 0;
  }
  return v3;
}

//----- (0804EF50) --------------------------------------------------------
int __cdecl sub_804EF50(int a1, int a2, int a3, char *s)
{
  char dest; // [esp+20h] [ebp-408h]

  if ( !sub_804ECB0(a1, s) )
  {
    SourceError(a1, "couldn't read expected token");
    return 0;
  }
  if ( *((_DWORD *)s + 256) != a2 )
  {
    strcpy(&dest, &byte_813A549);
    if ( a2 == 1 )
      strcpy(&dest, "string");
    if ( a2 == 2 )
      strcpy(&dest, "literal");
    if ( a2 == 3 )
      strcpy(&dest, "number");
    if ( a2 == 4 )
      strcpy(&dest, "name");
    if ( a2 == 5 )
      strcpy(&dest, "punctuation");
    SourceError(a1, "expected a %s, found %s", &dest, s);
    return 0;
  }
  if ( *((_DWORD *)s + 256) != 3 )
  {
    if ( *((_DWORD *)s + 256) == 5 && *((_DWORD *)s + 257) != a3 )
    {
      SourceError(a1, "found %s", s);
      return 0;
    }
    return 1;
  }
  if ( (a3 & *((_DWORD *)s + 257)) == a3 )
    return 1;
  if ( a3 & 8 )
    strcpy(&dest, "decimal");
  if ( a3 & 0x100 )
    strcpy(&dest, "hex");
  if ( a3 & 0x200 )
    strcpy(&dest, "octal");
  if ( a3 & 0x400 )
    strcpy(&dest, "binary");
  if ( a3 & 0x2000 )
    strcat(&dest, " long");
  if ( a3 & 0x4000 )
    strcat(&dest, " unsigned");
  if ( a3 & 0x800 )
    strcat(&dest, " float");
  if ( a3 & 0x1000 )
    strcat(&dest, " integer");
  SourceError(a1, "expected %s, found %s", &dest, s);
  return 0;
}

//----- (0804F230) --------------------------------------------------------
int __cdecl sub_804F230(int a1, char *s)
{
  if ( sub_804ECB0(a1, s) )
    return 1;
  SourceError(a1, "couldn't read expected token");
  return 0;
}

//----- (0804F274) --------------------------------------------------------
int __cdecl sub_804F274(int a1, char *s2)
{
  char s1; // [esp+20h] [ebp-438h]

  if ( !sub_804ECB0(a1, &s1) )
    return 0;
  if ( !strcmp(&s1, s2) )
    return 1;
  sub_804AA78(a1, &s1);
  return 0;
}

//----- (0804F2EE) --------------------------------------------------------
int __cdecl sub_804F2EE(int a1, int a2, int a3, void *dest)
{
  signed int v5; // [esp+1Ch] [ebp-43Ch]
  char src; // [esp+20h] [ebp-438h]
  int v7; // [esp+420h] [ebp-38h]
  int v8; // [esp+424h] [ebp-34h]

  if ( !sub_804ECB0(a1, &src) )
    return 0;
  if ( v7 != a2 || (v8 & a3) != a3 )
  {
    sub_804AA78(a1, &src);
    v5 = 0;
  }
  else
  {
    memcpy(dest, &src, 0x42Cu);
    v5 = 1;
  }
  return v5;
}

//----- (0804F380) --------------------------------------------------------
int __cdecl sub_804F380(int a1, char *s2)
{
  char s1; // [esp+20h] [ebp-438h]

  while ( sub_804ECB0(a1, &s1) )
  {
    if ( !strcmp(&s1, s2) )
      return 1;
  }
  return 0;
}

//----- (0804F3DC) --------------------------------------------------------
int __cdecl sub_804F3DC(int a1)
{
  return sub_804AA78(a1, (void *)(a1 + 156));
}

//----- (0804F3FC) --------------------------------------------------------
int __cdecl sub_804F3FC(int a1, void *src)
{
  return sub_804AA78(a1, src);
}

//----- (0804F416) --------------------------------------------------------
int __cdecl sub_804F416(int a1, char *src)
{
  int result; // eax

  strncpy((char *)(a1 + 64), src, 0x40u);
  result = strlen((const char *)(a1 + 64));
  if ( *(_BYTE *)(a1 + result + 63) != 92 )
  {
    result = strlen((const char *)(a1 + 64));
    if ( *(_BYTE *)(a1 + result + 63) != 47 )
      result = (int)strcat((char *)(a1 + 64), "/");
  }
  return result;
}

//----- (0804F498) --------------------------------------------------------
_DWORD *__cdecl sub_804F498(char *src)
{
  _DWORD *s; // ST20_4
  char *v4; // [esp+1Ch] [ebp-Ch]

  v4 = sub_80519D8(src);
  if ( !v4 )
    return 0;
  *((_DWORD *)v4 + 296) = 0;
  s = (_DWORD *)sub_804A5A4(1224);
  memset(s, 0, 0x4C8u);
  strncpy((char *)s, src, 0x40u);
  s[33] = v4;
  s[34] = 0;
  s[35] = 0;
  s[37] = 0;
  s[38] = 0;
  s[36] = sub_804A5E8(0x1000u);
  sub_804CA40((int)s);
  return s;
}

//----- (0804F580) --------------------------------------------------------
_DWORD *__cdecl sub_804F580(void *a1, size_t n, char *src)
{
  _DWORD *s; // ST20_4
  char *v6; // [esp+1Ch] [ebp-Ch]

  v6 = sub_8051B20(a1, n, src);
  if ( !v6 )
    return 0;
  *((_DWORD *)v6 + 296) = 0;
  s = (_DWORD *)sub_804A5A4(1224);
  memset(s, 0, 0x4C8u);
  strncpy((char *)s, src, 0x40u);
  s[33] = v6;
  s[34] = 0;
  s[35] = 0;
  s[37] = 0;
  s[38] = 0;
  s[36] = sub_804A5E8(0x1000u);
  sub_804CA40((int)s);
  return s;
}

//----- (0804F676) --------------------------------------------------------
void __cdecl sub_804F676(_DWORD *a1)
{
  int v1; // ST1C_4
  int v2; // ST18_4
  int v3; // ST14_4
  int v4; // ST10_4
  signed int i; // [esp+Ch] [ebp-1Ch]

  while ( a1[33] )
  {
    v1 = a1[33];
    a1[33] = *(_DWORD *)(a1[33] + 1184);
    sub_8051BEE(v1);
  }
  while ( a1[34] )
  {
    v2 = a1[34];
    a1[34] = *(_DWORD *)(a1[34] + 1064);
    sub_804A908(v2);
  }
  for ( i = 0; i <= 1023; ++i )
  {
    while ( *(_DWORD *)(a1[36] + 4 * i) )
    {
      v3 = *(_DWORD *)(a1[36] + 4 * i);
      *(_DWORD *)(a1[36] + 4 * i) = *(_DWORD *)(*(_DWORD *)(a1[36] + 4 * i) + 28);
      sub_804B168(v3);
    }
  }
  while ( a1[37] )
  {
    v4 = a1[37];
    a1[37] = *(_DWORD *)(a1[37] + 12);
    sub_804A61C(v4);
  }
  if ( a1[36] )
    sub_804A61C(a1[36]);
  sub_804A61C((int)a1);
}

//----- (0804F7F6) --------------------------------------------------------
int __cdecl sub_804F7F6(char *src)
{
  signed int i; // [esp+10h] [ebp-8h]
  char *v4; // [esp+14h] [ebp-4h]

  for ( i = 1; i <= 63 && dword_8185AC0[i]; ++i )
    ;
  if ( i > 63 )
    return 0;
  v4 = (char *)sub_804F498(src);
  if ( !v4 )
    return 0;
  dword_8185AC0[i] = v4;
  return i;
}

//----- (0804F866) --------------------------------------------------------
signed int __cdecl sub_804F866(signed int a1)
{
  if ( a1 <= 0 || a1 > 63 )
    return 0;
  if ( !dword_8185AC0[a1] )
    return 0;
  sub_804F676(dword_8185AC0[a1]);
  dword_8185AC0[a1] = 0;
  return 1;
}

//----- (0804F8C6) --------------------------------------------------------
int __cdecl sub_804F8C6(signed int a1, int a2)
{
  int v4; // [esp+1Ch] [ebp-43Ch]
  char src; // [esp+20h] [ebp-438h]
  int v6; // [esp+420h] [ebp-38h]
  int v7; // [esp+424h] [ebp-34h]
  int v8; // [esp+428h] [ebp-30h]
  long double v9; // [esp+42Ch] [ebp-2Ch]

  if ( a1 <= 0 || a1 > 63 )
    return 0;
  if ( !dword_8185AC0[a1] )
    return 0;
  v4 = sub_804ECB0((int)dword_8185AC0[a1], &src);
  strcpy((char *)(a2 + 16), &src);
  *(_DWORD *)a2 = v6;
  *(_DWORD *)(a2 + 4) = v7;
  *(_DWORD *)(a2 + 8) = v8;
  *(float *)(a2 + 12) = v9;
  if ( *(_DWORD *)a2 == 1 )
    sub_8051694((char *)(a2 + 16));
  return v4;
}

//----- (0804F98C) --------------------------------------------------------
int __cdecl sub_804F98C(signed int a1, int a2)
{
  int v4; // [esp+1Ch] [ebp-43Ch]
  char src; // [esp+20h] [ebp-438h]
  int v6; // [esp+420h] [ebp-38h]
  int v7; // [esp+424h] [ebp-34h]
  int v8; // [esp+428h] [ebp-30h]
  long double v9; // [esp+42Ch] [ebp-2Ch]

  if ( a1 <= 0 || a1 > 63 )
    return 0;
  if ( !dword_8185AC0[a1] )
    return 0;
  v4 = sub_804BD8C((int)dword_8185AC0[a1], &src);
  strcpy((char *)(a2 + 16), &src);
  *(_DWORD *)a2 = v6;
  *(_DWORD *)(a2 + 4) = v7;
  *(_DWORD *)(a2 + 8) = v8;
  *(float *)(a2 + 12) = v9;
  if ( *(_DWORD *)a2 == 1 )
    sub_8051694((char *)(a2 + 16));
  return v4;
}

//----- (0804FA52) --------------------------------------------------------
int __cdecl sub_804FA52(int a1, char *dest, int a3)
{
  char *src; // [esp+14h] [ebp-4h]

  if ( a1 <= 0 || a1 > 63 )
    return 0;
  if ( !dword_8185AC0[a1] )
    return 0;
  src = (char *)*((_DWORD *)dword_8185AC0[a1] + 33);
  if ( src )
  {
    strcpy(dest, src);
    *(_DWORD *)a3 = *((_DWORD *)src + 23);
  }
  else
  {
    strcpy(dest, dword_8185AC0[a1]);
    *(_DWORD *)a3 = 0;
  }
  return 1;
}

//----- (0804FAEC) --------------------------------------------------------
int *sub_804FAEC()
{
  int *result; // eax
  int i; // [esp+14h] [ebp-4h]

  for ( i = 1; i <= 63; ++i )
  {
    if ( dword_8185AC0[i] )
      Com_Printf("^1Error: file %s still open in precompiler\n", *((_DWORD *)dword_8185AC0[i] + 33));
    result = &i;
  }
  return result;
}

//----- (0804FB38) --------------------------------------------------------
long double __cdecl sub_804FB38(float a1)
{
  return (float)fabs(a1);
}

//----- (0804FB54) --------------------------------------------------------
int __cdecl sub_804FB54(int a1, int a2)
{
  int result; // eax
  size_t v3; // ebx
  const char **v4; // [esp+14h] [ebp-14h]
  int v5; // [esp+18h] [ebp-10h]
  int j; // [esp+1Ch] [ebp-Ch]
  int i; // [esp+20h] [ebp-8h]

  if ( !*(_DWORD *)(a1 + 112) )
    *(_DWORD *)(a1 + 112) = sub_804A5A4(1024);
  memset(*(void **)(a1 + 112), 0, 0x400u);
  for ( i = 0; ; ++i )
  {
    result = a2;
    if ( !*(_DWORD *)(a2 + 12 * i) )
      break;
    v4 = (const char **)(a2 + 12 * i);
    v5 = 0;
    for ( j = *(_DWORD *)(*(_DWORD *)(a1 + 112) + 4 * **(char **)(a2 + 12 * i)); j; j = *(_DWORD *)(j + 8) )
    {
      v3 = strlen(*(const char **)j);
      if ( v3 < strlen(*v4) )
      {
        v4[2] = (const char *)j;
        if ( v5 )
          *(_DWORD *)(v5 + 8) = v4;
        else
          *(_DWORD *)(*(_DWORD *)(a1 + 112) + 4 * **v4) = v4;
        break;
      }
      v5 = j;
    }
    if ( !j )
    {
      v4[2] = 0;
      if ( v5 )
        *(_DWORD *)(v5 + 8) = v4;
      else
        *(_DWORD *)(*(_DWORD *)(a1 + 112) + 4 * **v4) = v4;
    }
  }
  return result;
}

//----- (0804FD26) --------------------------------------------------------
void sub_804FD26(int a1, char *format, ...)
{
  char s; // [esp+20h] [ebp-408h]
  va_list va; // [esp+438h] [ebp+10h]

  va_start(va, format);
  if ( !(*(_BYTE *)(a1 + 104) & 1) )
  {
    vsprintf(&s, format, va);
    Com_Printf("^1Error: file %s, line %d: %s\n", a1, *(_DWORD *)(a1 + 92), &s);
  }
}

//----- (0804FD90) --------------------------------------------------------
void sub_804FD90(int a1, char *format, ...)
{
  char s; // [esp+20h] [ebp-408h]
  va_list va; // [esp+438h] [ebp+10h]

  va_start(va, format);
  if ( !(*(_DWORD *)(a1 + 104) & 2) )
  {
    vsprintf(&s, format, va);
    Com_Printf("^3Warning: file %s, line %d: %s\n", a1, *(_DWORD *)(a1 + 92), &s);
  }
}

//----- (0804FDFA) --------------------------------------------------------
int __cdecl sub_804FDFA(int a1, int a2)
{
  int result; // eax

  if ( a2 )
  {
    sub_804FB54(a1, a2);
    result = a2;
    *(_DWORD *)(a1 + 108) = a2;
  }
  else
  {
    sub_804FB54(a1, (int)&off_815A160);
    result = a1;
    *(_DWORD *)(a1 + 108) = &off_815A160;
  }
  return result;
}
// 815A160: using guessed type char *off_815A160;

//----- (0804FE42) --------------------------------------------------------
signed int __cdecl sub_804FE42(int a1)
{
  while ( 1 )
  {
    while ( **(_BYTE **)(a1 + 68) <= 32 )
    {
      if ( !**(_BYTE **)(a1 + 68) )
        return 0;
      if ( **(_BYTE **)(a1 + 68) == 10 )
        ++*(_DWORD *)(a1 + 92);
      ++*(_DWORD *)(a1 + 68);
    }
    if ( **(_BYTE **)(a1 + 68) != 47 )
      break;
    if ( *(_BYTE *)(*(_DWORD *)(a1 + 68) + 1) == 47 )
    {
      ++*(_DWORD *)(a1 + 68);
      do
      {
        if ( !*(_BYTE *)++*(_DWORD *)(a1 + 68) )
          return 0;
      }
      while ( **(_BYTE **)(a1 + 68) != 10 );
      ++*(_DWORD *)(a1 + 92);
      if ( !*(_BYTE *)++*(_DWORD *)(a1 + 68) )
        return 0;
    }
    else
    {
      if ( *(_BYTE *)(*(_DWORD *)(a1 + 68) + 1) != 42 )
        return 1;
      ++*(_DWORD *)(a1 + 68);
      do
      {
        if ( !*(_BYTE *)++*(_DWORD *)(a1 + 68) )
          return 0;
        if ( **(_BYTE **)(a1 + 68) == 10 )
          ++*(_DWORD *)(a1 + 92);
      }
      while ( **(_BYTE **)(a1 + 68) != 42 || *(_BYTE *)(*(_DWORD *)(a1 + 68) + 1) != 47 );
      if ( !*(_BYTE *)++*(_DWORD *)(a1 + 68) )
        return 0;
      if ( !*(_BYTE *)++*(_DWORD *)(a1 + 68) )
        return 0;
    }
  }
  return 1;
}

//----- (0804FF92) --------------------------------------------------------
signed int __cdecl sub_804FF92(int a1, char *a2)
{
  int v3; // [esp+Ch] [ebp-Ch]
  int v4; // [esp+Ch] [ebp-Ch]
  int v5; // [esp+10h] [ebp-8h]
  int v6; // [esp+10h] [ebp-8h]
  char v7; // [esp+14h] [ebp-4h]
  signed int v8; // [esp+14h] [ebp-4h]
  int v9; // [esp+14h] [ebp-4h]
  signed int v10; // [esp+14h] [ebp-4h]

  switch ( *(_BYTE *)++*(_DWORD *)(a1 + 68) )
  {
    case 0x22:
      v7 = 34;
      goto LABEL_37;
    case 0x27:
      v7 = 39;
      goto LABEL_37;
    case 0x3F:
      v7 = 63;
      goto LABEL_37;
    case 0x5C:
      v7 = 92;
      goto LABEL_37;
    case 0x61:
      v7 = 7;
      goto LABEL_37;
    case 0x62:
      v7 = 8;
      goto LABEL_37;
    case 0x66:
      v7 = 12;
      goto LABEL_37;
    case 0x6E:
      v7 = 10;
      goto LABEL_37;
    case 0x72:
      v7 = 13;
      goto LABEL_37;
    case 0x74:
      v7 = 9;
      goto LABEL_37;
    case 0x76:
      v7 = 11;
      goto LABEL_37;
    case 0x78:
      ++*(_DWORD *)(a1 + 68);
      v3 = 0;
      v5 = 0;
      break;
    default:
      if ( **(_BYTE **)(a1 + 68) <= 47 || **(_BYTE **)(a1 + 68) > 57 )
        sub_804FD26(a1, "unknown escape char");
      v4 = 0;
      v6 = 0;
      while ( 1 )
      {
        v10 = **(char **)(a1 + 68);
        if ( v10 <= 47 || v10 > 57 )
          break;
        v6 = v10 - 48 + 10 * v6;
        ++v4;
        ++*(_DWORD *)(a1 + 68);
      }
      --*(_DWORD *)(a1 + 68);
      if ( v6 > 255 )
      {
        sub_804FD90(a1, "too large value in escape character");
        LOBYTE(v6) = -1;
      }
      v7 = v6;
      goto LABEL_37;
  }
  while ( 1 )
  {
    v8 = **(char **)(a1 + 68);
    if ( v8 > 47 && v8 <= 57 )
    {
      v9 = v8 - 48;
      goto LABEL_23;
    }
    if ( v8 > 64 && v8 <= 90 )
    {
      v9 = v8 - 55;
      goto LABEL_23;
    }
    if ( v8 <= 96 || v8 > 122 )
      break;
    v9 = v8 - 87;
LABEL_23:
    v5 = v9 + 16 * v5;
    ++v3;
    ++*(_DWORD *)(a1 + 68);
  }
  --*(_DWORD *)(a1 + 68);
  if ( v5 > 255 )
  {
    sub_804FD90(a1, "too large value in escape character");
    LOBYTE(v5) = -1;
  }
  v7 = v5;
LABEL_37:
  ++*(_DWORD *)(a1 + 68);
  *a2 = v7;
  return 1;
}

//----- (080501AA) --------------------------------------------------------
signed int __cdecl sub_80501AA(_DWORD *a1, int a2, int a3)
{
  _BYTE *v3; // edx
  _BYTE *v4; // edx
  int v5; // ST20_4
  int v8; // [esp+18h] [ebp-10h]
  int v9; // [esp+1Ch] [ebp-Ch]
  signed int v10; // [esp+20h] [ebp-8h]

  if ( a3 == 34 )
    *(_DWORD *)(a2 + 1024) = 1;
  else
    *(_DWORD *)(a2 + 1024) = 2;
  v3 = (_BYTE *)a1[17]++;
  *(_BYTE *)a2 = *v3;
  v10 = 1;
  while ( 1 )
  {
    while ( 1 )
    {
      while ( 1 )
      {
        if ( v10 > 1021 )
        {
          sub_804FD26((int)a1, "string longer than MAX_TOKEN = %d", 1024);
          return 0;
        }
        if ( *(_BYTE *)a1[17] != 92 || a1[26] & 8 )
          break;
        if ( !sub_804FF92((int)a1, (char *)(a2 + v10)) )
        {
          *(_BYTE *)(v10 + a2) = 0;
          return 0;
        }
        ++v10;
      }
      if ( *(char *)a1[17] == a3 )
        break;
      if ( !*(_BYTE *)a1[17] )
      {
        *(_BYTE *)(v10 + a2) = 0;
        sub_804FD26((int)a1, "missing trailing quote");
        return 0;
      }
      if ( *(_BYTE *)a1[17] == 10 )
      {
        *(_BYTE *)(v10 + a2) = 0;
        sub_804FD26((int)a1, "newline inside string %s", a2);
        return 0;
      }
      v4 = (_BYTE *)a1[17]++;
      *(_BYTE *)(a2 + v10++) = *v4;
    }
    ++a1[17];
    if ( a1[26] & 4 )
      break;
    v8 = a1[17];
    v9 = a1[23];
    if ( !sub_804FE42((int)a1) )
    {
      a1[17] = v8;
      a1[23] = v9;
      break;
    }
    if ( *(char *)a1[17] != a3 )
    {
      a1[17] = v8;
      a1[23] = v9;
      break;
    }
    ++a1[17];
  }
  *(_BYTE *)(a2 + v10) = a3;
  v5 = v10 + 1;
  *(_BYTE *)(v5 + a2) = 0;
  *(_DWORD *)(a2 + 1028) = v5;
  return 1;
}

//----- (080503CE) --------------------------------------------------------
signed int __cdecl sub_80503CE(int a1, int a2)
{
  _BYTE *v2; // edx
  char v5; // [esp+1Fh] [ebp-9h]
  signed int v6; // [esp+20h] [ebp-8h]

  v6 = 0;
  *(_DWORD *)(a2 + 1024) = 4;
  do
  {
    v2 = (_BYTE *)(*(_DWORD *)(a1 + 68))++;
    *(_BYTE *)(a2 + v6++) = *v2;
    if ( v6 > 1023 )
    {
      sub_804FD26(a1, "name longer than MAX_TOKEN = %d", 1024);
      return 0;
    }
    v5 = **(_BYTE **)(a1 + 68);
  }
  while ( v5 > 96 && v5 <= 122 || v5 > 64 && v5 <= 90 || v5 > 47 && v5 <= 57 || v5 == 95 );
  *(_BYTE *)(v6 + a2) = 0;
  *(_DWORD *)(a2 + 1028) = v6;
  return 1;
}

//----- (0805048E) --------------------------------------------------------
int __cdecl sub_805048E(_BYTE *a1, __int16 a2, _DWORD *a3, long double *a4)
{
  signed __int64 v4; // rax
  signed int v6; // [esp+Ch] [ebp-Ch]
  _BYTE *i; // [esp+20h] [ebp+8h]
  _BYTE *j; // [esp+20h] [ebp+8h]
  _BYTE *k; // [esp+20h] [ebp+8h]

  v6 = 0;
  *a3 = 0;
  *(_DWORD *)a4 = 0;
  *((_DWORD *)a4 + 1) = 0;
  *((_DWORD *)a4 + 2) = 0;
  if ( a2 & 0x800 )
  {
    while ( *a1 )
    {
      LODWORD(v4) = a1;
      if ( *a1 == 46 )
      {
        if ( v6 )
          return v4;
        v6 = 10;
        ++a1;
      }
      if ( v6 )
      {
        *a4 = (long double)((char)*a1 - 48) / (long double)(unsigned int)v6 + *a4;
        v6 *= 10;
      }
      else
      {
        *a4 = *a4 * 10.0 + (long double)((char)*a1 - 48);
      }
      ++a1;
    }
    v4 = (signed __int64)*a4;
    *a3 = v4;
  }
  else if ( a2 & 8 )
  {
    while ( *a1 )
      *a3 = (char)*a1++ + 10 * *a3 - 48;
    LODWORD(v4) = *a3;
    *a4 = (long double)(unsigned int)*a3;
  }
  else if ( a2 & 0x100 )
  {
    for ( i = a1 + 2; *i; ++i )
    {
      *a3 *= 16;
      if ( *i <= 96 || *i > 102 )
      {
        if ( *i <= 64 || *i > 70 )
          *a3 = *a3 + (char)*i - 48;
        else
          *a3 = *a3 + (char)*i - 55;
      }
      else
      {
        *a3 = *a3 + (char)*i - 87;
      }
    }
    LODWORD(v4) = *a3;
    *a4 = (long double)(unsigned int)*a3;
  }
  else if ( a2 & 0x200 )
  {
    for ( j = a1 + 1; *j; ++j )
      *a3 = (char)*j + 8 * *a3 - 48;
    LODWORD(v4) = *a3;
    *a4 = (long double)(unsigned int)*a3;
  }
  else
  {
    LODWORD(v4) = a2 & 0x400;
    if ( a2 & 0x400 )
    {
      for ( k = a1 + 2; *k; ++k )
        *a3 = (char)*k + 2 * *a3 - 48;
      LODWORD(v4) = *a3;
      *a4 = (long double)(unsigned int)*a3;
    }
  }
  return v4;
}

//----- (08050746) --------------------------------------------------------
signed int __cdecl sub_8050746(int a1, int a2)
{
  _BYTE *v2; // edx
  _BYTE *v3; // edx
  _BYTE *v4; // edx
  _BYTE *v5; // edx
  _BYTE *v6; // edx
  _BYTE *v7; // edx
  _BYTE *v8; // edx
  int v9; // edx
  char i; // [esp+23h] [ebp-15h]
  char j; // [esp+23h] [ebp-15h]
  char v14; // [esp+23h] [ebp-15h]
  char v15; // [esp+23h] [ebp-15h]
  signed int v16; // [esp+24h] [ebp-14h]
  signed int v17; // [esp+28h] [ebp-10h]
  signed int k; // [esp+2Ch] [ebp-Ch]
  signed int v19; // [esp+30h] [ebp-8h]

  v19 = 0;
  *(_DWORD *)(a2 + 1024) = 3;
  if ( **(_BYTE **)(a1 + 68) == 48
    && (*(_BYTE *)(*(_DWORD *)(a1 + 68) + 1) == 120 || *(_BYTE *)(*(_DWORD *)(a1 + 68) + 1) == 88) )
  {
    v2 = (_BYTE *)(*(_DWORD *)(a1 + 68))++;
    *(_BYTE *)a2 = *v2;
    v3 = (_BYTE *)(*(_DWORD *)(a1 + 68))++;
    *(_BYTE *)(a2 + 1) = *v3;
    v19 = 2;
    for ( i = **(_BYTE **)(a1 + 68); i > 47 && i <= 57 || i > 96 && i <= 102 || i > 64 && i <= 65; i = **(_BYTE **)(a1 + 68) )
    {
      v4 = (_BYTE *)(*(_DWORD *)(a1 + 68))++;
      *(_BYTE *)(a2 + v19++) = *v4;
      if ( v19 > 1023 )
      {
        sub_804FD26(a1, "hexadecimal number longer than MAX_TOKEN = %d", 1024);
        return 0;
      }
    }
    *(_DWORD *)(a2 + 1028) |= 0x100u;
    goto LABEL_41;
  }
  if ( **(_BYTE **)(a1 + 68) == 48
    && (*(_BYTE *)(*(_DWORD *)(a1 + 68) + 1) == 98 || *(_BYTE *)(*(_DWORD *)(a1 + 68) + 1) == 66) )
  {
    v5 = (_BYTE *)(*(_DWORD *)(a1 + 68))++;
    *(_BYTE *)a2 = *v5;
    v6 = (_BYTE *)(*(_DWORD *)(a1 + 68))++;
    *(_BYTE *)(a2 + 1) = *v6;
    v19 = 2;
    for ( j = **(_BYTE **)(a1 + 68); j == 48 || j == 49; j = **(_BYTE **)(a1 + 68) )
    {
      v7 = (_BYTE *)(*(_DWORD *)(a1 + 68))++;
      *(_BYTE *)(a2 + v19++) = *v7;
      if ( v19 > 1023 )
      {
        sub_804FD26(a1, "binary number longer than MAX_TOKEN = %d", 1024);
        return 0;
      }
    }
    *(_DWORD *)(a2 + 1028) |= 0x400u;
    goto LABEL_41;
  }
  v17 = 0;
  v16 = 0;
  if ( **(_BYTE **)(a1 + 68) == 48 )
    v17 = 1;
  while ( 1 )
  {
    v14 = **(_BYTE **)(a1 + 68);
    if ( v14 != 46 )
      break;
    v16 = 1;
LABEL_34:
    v8 = (_BYTE *)(*(_DWORD *)(a1 + 68))++;
    *(_BYTE *)(a2 + v19++) = *v8;
    if ( v19 > 1022 )
    {
      sub_804FD26(a1, "number longer than MAX_TOKEN = %d", 1024);
      return 0;
    }
  }
  if ( v14 == 56 || v14 == 57 )
  {
    v17 = 0;
    goto LABEL_34;
  }
  if ( v14 > 47 && v14 <= 57 )
    goto LABEL_34;
  if ( v17 )
    v9 = *(_DWORD *)(a2 + 1028) | 0x200;
  else
    v9 = *(_DWORD *)(a2 + 1028) | 8;
  *(_DWORD *)(a2 + 1028) = v9;
  if ( v16 )
    *(_DWORD *)(a2 + 1028) |= 0x800u;
LABEL_41:
  for ( k = 0; k <= 1; ++k )
  {
    v15 = **(_BYTE **)(a1 + 68);
    if ( v15 != 108 && v15 != 76 || *(_DWORD *)(a2 + 1028) & 0x2000 )
    {
      if ( (v15 == 117 || v15 == 85) && !(*(_DWORD *)(a2 + 1028) & 0x4800) )
      {
        ++*(_DWORD *)(a1 + 68);
        *(_DWORD *)(a2 + 1028) |= 0x4000u;
      }
    }
    else
    {
      ++*(_DWORD *)(a1 + 68);
      *(_DWORD *)(a2 + 1028) |= 0x2000u;
    }
  }
  *(_BYTE *)(v19 + a2) = 0;
  sub_805048E((_BYTE *)a2, *(_DWORD *)(a2 + 1028), (_DWORD *)(a2 + 1032), (long double *)(a2 + 1036));
  if ( !(*(_DWORD *)(a2 + 1028) & 0x800) )
    *(_DWORD *)(a2 + 1028) |= 0x1000u;
  return 1;
}

//----- (08050B78) --------------------------------------------------------
signed int __cdecl sub_8050B78(int a1, int a2)
{
  _BYTE *v2; // edx
  _BYTE *v3; // edx
  _BYTE *v4; // edx
  signed int v6; // [esp+14h] [ebp-4h]

  *(_DWORD *)(a2 + 1024) = 2;
  v2 = (_BYTE *)(*(_DWORD *)(a1 + 68))++;
  *(_BYTE *)a2 = *v2;
  if ( **(_BYTE **)(a1 + 68) )
  {
    if ( **(_BYTE **)(a1 + 68) == 92 )
    {
      if ( !sub_804FF92(a1, (char *)(a2 + 1)) )
        return 0;
    }
    else
    {
      v3 = (_BYTE *)(*(_DWORD *)(a1 + 68))++;
      *(_BYTE *)(a2 + 1) = *v3;
    }
    if ( **(_BYTE **)(a1 + 68) != 39 )
    {
      sub_804FD90(a1, "too many characters in literal, ignored");
      while ( **(_BYTE **)(a1 + 68) && **(_BYTE **)(a1 + 68) != 39 && **(_BYTE **)(a1 + 68) != 10 )
        ++*(_DWORD *)(a1 + 68);
      if ( **(_BYTE **)(a1 + 68) == 39 )
        ++*(_DWORD *)(a1 + 68);
    }
    v4 = (_BYTE *)(*(_DWORD *)(a1 + 68))++;
    *(_BYTE *)(a2 + 2) = *v4;
    *(_BYTE *)(a2 + 3) = 0;
    *(_DWORD *)(a2 + 1028) = *(char *)(a2 + 1);
    v6 = 1;
  }
  else
  {
    sub_804FD26(a1, "end of file before trailing '");
    v6 = 0;
  }
  return v6;
}

//----- (08050C96) --------------------------------------------------------
int __cdecl sub_8050C96(int a1, char *dest)
{
  int i; // [esp+1Ch] [ebp-Ch]
  char *s; // [esp+20h] [ebp-8h]
  size_t n; // [esp+24h] [ebp-4h]

  for ( i = *(_DWORD *)(*(_DWORD *)(a1 + 112) + 4 * **(char **)(a1 + 68)); i; i = *(_DWORD *)(i + 8) )
  {
    s = *(char **)i;
    n = strlen(*(const char **)i);
    if ( n + *(_DWORD *)(a1 + 68) <= *(_DWORD *)(a1 + 72) && !strncmp(*(const char **)(a1 + 68), s, n) )
    {
      strncpy(dest, s, 0x400u);
      *(_DWORD *)(a1 + 68) += n;
      *((_DWORD *)dest + 256) = 5;
      *((_DWORD *)dest + 257) = *(_DWORD *)(i + 4);
      return 1;
    }
  }
  return 0;
}

//----- (08050D74) --------------------------------------------------------
int __cdecl sub_8050D74(int a1, void *src)
{
  _BYTE *v2; // edx
  signed int v5; // [esp+10h] [ebp-8h]

  v5 = 0;
  while ( **(_BYTE **)(a1 + 68) > 32 && **(_BYTE **)(a1 + 68) != 59 )
  {
    if ( v5 > 1023 )
    {
      sub_804FD26(a1, "primitive token longer than MAX_TOKEN = %d", 1024);
      return 0;
    }
    v2 = (_BYTE *)(*(_DWORD *)(a1 + 68))++;
    *((_BYTE *)src + v5++) = *v2;
  }
  *((_BYTE *)src + v5) = 0;
  memcpy((void *)(a1 + 116), src, 0x42Cu);
  return 1;
}

//----- (08050E1C) --------------------------------------------------------
int __cdecl sub_8050E1C(int a1, void *dest)
{
  signed int v3; // [esp+10h] [ebp-8h]

  if ( *(_DWORD *)(a1 + 100) )
  {
    *(_DWORD *)(a1 + 100) = 0;
    memcpy(dest, (const void *)(a1 + 116), 0x42Cu);
    v3 = 1;
  }
  else
  {
    *(_DWORD *)(a1 + 76) = *(_DWORD *)(a1 + 68);
    *(_DWORD *)(a1 + 96) = *(_DWORD *)(a1 + 92);
    memset(dest, 0, 0x42Cu);
    *(_DWORD *)(a1 + 80) = *(_DWORD *)(a1 + 68);
    *((_DWORD *)dest + 262) = *(_DWORD *)(a1 + 68);
    if ( sub_804FE42(a1) )
    {
      *(_DWORD *)(a1 + 84) = *(_DWORD *)(a1 + 68);
      *((_DWORD *)dest + 263) = *(_DWORD *)(a1 + 68);
      *((_DWORD *)dest + 264) = *(_DWORD *)(a1 + 92);
      *((_DWORD *)dest + 265) = *(_DWORD *)(a1 + 92) - *(_DWORD *)(a1 + 96);
      if ( **(_BYTE **)(a1 + 68) == 34 )
      {
        if ( !sub_80501AA((_DWORD *)a1, (int)dest, 34) )
          return 0;
      }
      else if ( **(_BYTE **)(a1 + 68) == 39 )
      {
        if ( !sub_80501AA((_DWORD *)a1, (int)dest, 39) )
          return 0;
      }
      else if ( (**(_BYTE **)(a1 + 68) <= 47 || **(_BYTE **)(a1 + 68) > 57)
             && (**(_BYTE **)(a1 + 68) != 46
              || *(_BYTE *)(*(_DWORD *)(a1 + 68) + 1) <= 47
              || *(_BYTE *)(*(_DWORD *)(a1 + 68) + 1) > 57) )
      {
        if ( *(_DWORD *)(a1 + 104) & 0x10 )
          return sub_8050D74(a1, dest);
        if ( (**(_BYTE **)(a1 + 68) <= 96 || **(_BYTE **)(a1 + 68) > 122)
          && (**(_BYTE **)(a1 + 68) <= 64 || **(_BYTE **)(a1 + 68) > 90)
          && **(_BYTE **)(a1 + 68) != 95 )
        {
          if ( !sub_8050C96(a1, (char *)dest) )
          {
            sub_804FD26(a1, "can't read token");
            return 0;
          }
        }
        else if ( !sub_80503CE(a1, (int)dest) )
        {
          return 0;
        }
      }
      else if ( !sub_8050746(a1, (int)dest) )
      {
        return 0;
      }
      memcpy((void *)(a1 + 116), dest, 0x42Cu);
      return 1;
    }
    v3 = 0;
  }
  return v3;
}

//----- (080510BA) --------------------------------------------------------
int __cdecl sub_80510BA(int a1, char *s2)
{
  signed int v3; // [esp+1Ch] [ebp-43Ch]
  char s1; // [esp+20h] [ebp-438h]

  if ( sub_8050E1C(a1, &s1) )
  {
    if ( !strcmp(&s1, s2) )
    {
      v3 = 1;
    }
    else
    {
      sub_804FD26(a1, "expected %s, found %s", s2, &s1);
      v3 = 0;
    }
  }
  else
  {
    sub_804FD26(a1, "couldn't find expected %s", s2);
    v3 = 0;
  }
  return v3;
}

//----- (0805115E) --------------------------------------------------------
int __cdecl sub_805115E(int a1, int a2, int a3, void *a4)
{
  char dest; // [esp+30h] [ebp-408h]

  if ( !sub_8050E1C(a1, a4) )
  {
    sub_804FD26(a1, "couldn't read expected token");
    return 0;
  }
  if ( *((_DWORD *)a4 + 256) != a2 )
  {
    if ( a2 == 1 )
      strcpy(&dest, "string");
    if ( a2 == 2 )
      strcpy(&dest, "literal");
    if ( a2 == 3 )
      strcpy(&dest, "number");
    if ( a2 == 4 )
      strcpy(&dest, "name");
    if ( a2 == 5 )
      strcpy(&dest, "punctuation");
    sub_804FD26(a1, "expected a %s, found %s", &dest, a4);
    return 0;
  }
  if ( *((_DWORD *)a4 + 256) != 3 )
  {
    if ( *((_DWORD *)a4 + 256) == 5 )
    {
      if ( a3 < 0 )
      {
        sub_804FD26(a1, "BUG: wrong punctuation subtype");
        return 0;
      }
      if ( *((_DWORD *)a4 + 257) != a3 )
      {
        sub_804FD26(
          a1,
          "expected %s, found %s",
          *(_DWORD *)(*(_DWORD *)(a1 + 108) + 12 * a3),
          *(_DWORD *)(*(_DWORD *)(a1 + 108) + 12 * a3 + 4),
          *(_DWORD *)(*(_DWORD *)(a1 + 108) + 12 * a3 + 8),
          a4);
        return 0;
      }
    }
    return 1;
  }
  if ( (a3 & *((_DWORD *)a4 + 257)) == a3 )
    return 1;
  if ( a3 & 8 )
    strcpy(&dest, "decimal");
  if ( a3 & 0x100 )
    strcpy(&dest, "hex");
  if ( a3 & 0x200 )
    strcpy(&dest, "octal");
  if ( a3 & 0x400 )
    strcpy(&dest, "binary");
  if ( a3 & 0x2000 )
    strcat(&dest, " long");
  if ( a3 & 0x4000 )
    strcat(&dest, " unsigned");
  if ( a3 & 0x800 )
    strcat(&dest, " float");
  if ( a3 & 0x1000 )
    strcat(&dest, " integer");
  sub_804FD26(a1, "expected %s, found %s", &dest, a4);
  return 0;
}

//----- (08051488) --------------------------------------------------------
int __cdecl sub_8051488(int a1, void *dest)
{
  if ( sub_8050E1C(a1, dest) )
    return 1;
  sub_804FD26(a1, "couldn't read expected token");
  return 0;
}

//----- (080514CC) --------------------------------------------------------
int __cdecl sub_80514CC(int a1, char *s2)
{
  char s1; // [esp+20h] [ebp-438h]

  if ( !sub_8050E1C(a1, &s1) )
    return 0;
  if ( !strcmp(&s1, s2) )
    return 1;
  *(_DWORD *)(a1 + 68) = *(_DWORD *)(a1 + 76);
  return 0;
}

//----- (0805153E) --------------------------------------------------------
int __cdecl sub_805153E(int a1, int a2, int a3, void *dest)
{
  signed int v5; // [esp+1Ch] [ebp-43Ch]
  char src; // [esp+20h] [ebp-438h]
  int v7; // [esp+420h] [ebp-38h]
  int v8; // [esp+424h] [ebp-34h]

  if ( !sub_8050E1C(a1, &src) )
    return 0;
  if ( v7 != a2 || (v8 & a3) != a3 )
  {
    *(_DWORD *)(a1 + 68) = *(_DWORD *)(a1 + 76);
    v5 = 0;
  }
  else
  {
    memcpy(dest, &src, 0x42Cu);
    v5 = 1;
  }
  return v5;
}

//----- (080515C6) --------------------------------------------------------
int __cdecl sub_80515C6(int a1, char *s2)
{
  char s1; // [esp+20h] [ebp-438h]

  while ( sub_8050E1C(a1, &s1) )
  {
    if ( !strcmp(&s1, s2) )
      return 1;
  }
  return 0;
}

//----- (08051632) --------------------------------------------------------
int __cdecl sub_8051632(int a1, void *src)
{
  int result; // eax

  memcpy((void *)(a1 + 116), src, 0x42Cu);
  result = a1;
  *(_DWORD *)(a1 + 100) = 1;
  return result;
}

//----- (08051694) --------------------------------------------------------
char *__cdecl sub_8051694(char *dest)
{
  char *result; // eax

  if ( *dest == 34 )
    strcpy(dest, dest + 1);
  result = &dest[strlen(dest) - 1];
  if ( *result == 34 )
  {
    result = &dest[strlen(dest) - 1];
    *result = 0;
  }
  return result;
}

//----- (080516DE) --------------------------------------------------------
char *__cdecl sub_80516DE(char *dest)
{
  char *result; // eax

  if ( *dest == 39 )
    strcpy(dest, dest + 1);
  result = &dest[strlen(dest) - 1];
  if ( *result == 39 )
  {
    result = &dest[strlen(dest) - 1];
    *result = 0;
  }
  return result;
}

//----- (08051728) --------------------------------------------------------
long double __cdecl sub_8051728(int a1)
{
  long double v2; // [esp+10h] [ebp-448h]
  char s1; // [esp+20h] [ebp-438h]
  int v4; // [esp+420h] [ebp-38h]
  long double v5; // [esp+42Ch] [ebp-2Ch]

  v2 = 1.0;
  sub_8051488(a1, &s1);
  if ( !strcmp(&s1, "-") )
  {
    LODWORD(v2) = 0;
    *(_QWORD *)((char *)&v2 + 4) = 211104085049344LL;
    sub_805115E(a1, 3, 0, &s1);
  }
  else if ( v4 != 3 )
  {
    sub_804FD26(a1, "expected float value, found %s\n", &s1);
  }
  return v2 * v5;
}

//----- (080517FA) --------------------------------------------------------
int __cdecl sub_80517FA(int a1)
{
  signed int v2; // [esp+1Ch] [ebp-43Ch]
  char s1; // [esp+20h] [ebp-438h]
  int v4; // [esp+420h] [ebp-38h]
  int v5; // [esp+424h] [ebp-34h]
  int v6; // [esp+428h] [ebp-30h]

  v2 = 1;
  sub_8051488(a1, &s1);
  if ( !strcmp(&s1, "-") )
  {
    v2 = -1;
    sub_805115E(a1, 3, 4096, &s1);
  }
  else if ( v4 != 3 || v5 == 2048 )
  {
    sub_804FD26(a1, "expected integer value, found %s\n", &s1);
  }
  return v6 * v2;
}

//----- (080518C2) --------------------------------------------------------
void *__cdecl sub_80518C2(_DWORD *a1)
{
  a1[17] = a1[16];
  a1[19] = a1[16];
  a1[20] = 0;
  a1[21] = 0;
  a1[25] = 0;
  a1[23] = 1;
  a1[24] = 1;
  return memset(a1 + 29, 0, 0x42Cu);
}

//----- (08051932) --------------------------------------------------------
_BOOL4 __cdecl sub_8051932(int a1)
{
  return *(_DWORD *)(a1 + 68) >= *(_DWORD *)(a1 + 72);
}

//----- (0805195E) --------------------------------------------------------
int __cdecl sub_805195E(int a1, char *s)
{
  char v4; // [esp+13h] [ebp-5h]
  size_t n; // [esp+14h] [ebp-4h]

  v4 = *s;
  n = strlen(s);
  while ( 1 )
  {
    if ( !sub_804FE42(a1) )
      return 0;
    if ( **(_BYTE **)(a1 + 68) == v4 && !strncmp(*(const char **)(a1 + 68), s, n) )
      break;
    ++*(_DWORD *)(a1 + 68);
  }
  return 1;
}

//----- (080519D8) --------------------------------------------------------
char *__cdecl sub_80519D8(char *src)
{
  char *dest; // ST14_4
  int v4; // [esp+1Ch] [ebp-5Ch]
  char s; // [esp+20h] [ebp-58h]
  int v6; // [esp+6Ch] [ebp-Ch]

  Com_sprintf(&s, 0x40u, "%s", src);
  v4 = FS_FOpenFileRead((int)&s, &v6, 1);
  if ( !v6 )
    return 0;
  dest = (char *)sub_804A5E8(v4 + 1189);
  strcpy(dest, src);
  *((_DWORD *)dest + 16) = dest + 1188;
  *(_BYTE *)(*((_DWORD *)dest + 16) + v4) = 0;
  *((_DWORD *)dest + 22) = v4;
  *((_DWORD *)dest + 17) = *((_DWORD *)dest + 16);
  *((_DWORD *)dest + 19) = *((_DWORD *)dest + 16);
  *((_DWORD *)dest + 18) = *((_DWORD *)dest + 16) + v4;
  *((_DWORD *)dest + 25) = 0;
  *((_DWORD *)dest + 23) = 1;
  *((_DWORD *)dest + 24) = 1;
  sub_804FDFA((int)dest, 0);
  FS_Read(*((_DWORD *)dest + 16), v4, v6);
  FS_FCloseFile(v6);
  *((_DWORD *)dest + 22) = sub_80B3F36(*((_BYTE **)dest + 16));
  return dest;
}

//----- (08051B20) --------------------------------------------------------
char *__cdecl sub_8051B20(void *a1, size_t n, char *src)
{
  char *v3; // eax
  char *v4; // ST14_4
  char *dest; // ST10_4

  v3 = (char *)sub_804A5E8(n + 1189);
  v4 = v3;
  dest = v3;
  strcpy(v3, src);
  *((_DWORD *)dest + 16) = v4 + 1188;
  *(_BYTE *)(*((_DWORD *)dest + 16) + n) = 0;
  *((_DWORD *)dest + 22) = n;
  *((_DWORD *)dest + 17) = *((_DWORD *)dest + 16);
  *((_DWORD *)dest + 19) = *((_DWORD *)dest + 16);
  *((_DWORD *)dest + 18) = *((_DWORD *)dest + 16) + n;
  *((_DWORD *)dest + 25) = 0;
  *((_DWORD *)dest + 23) = 1;
  *((_DWORD *)dest + 24) = 1;
  sub_804FDFA((int)dest, 0);
  memcpy(*((void **)dest + 16), a1, n);
  return dest;
}

//----- (08051BEE) --------------------------------------------------------
void __cdecl sub_8051BEE(int a1)
{
  if ( *(_DWORD *)(a1 + 112) )
    sub_804A61C(*(_DWORD *)(a1 + 112));
  sub_804A61C(a1);
}

//----- (08051C18) --------------------------------------------------------
char *getBuildNumber()
{
  sprintf(s, "%d %s %s", 696, "Oct 24 2005", "17:45:05");
  return s;
}

//----- (08051C54) --------------------------------------------------------
_BOOL4 sub_8051C54()
{
  return dword_8185BC8 != 0;
}

//----- (08051C66) --------------------------------------------------------
void *__cdecl sub_8051C66(_DWORD *a1, _DWORD *a2)
{
  if ( a1 )
    *a1 = dword_8185BCC;
  if ( a2 )
    *a2 = dword_8185BD0;
  return dword_8185BC8;
}
// 8185BD0: using guessed type int dword_8185BD0;

//----- (08051C90) --------------------------------------------------------
int *__cdecl Com_LoadBsp(int a1)
{
  char *v1; // eax
  char *v2; // eax
  int *v3; // ebx
  _DWORD *v4; // ebx
  int *result; // eax
  char *v6; // eax
  _DWORD *v7; // esi
  int v8; // ebx
  _DWORD *v9; // esi
  int v10; // ebx
  char v11[4]; // [esp+14h] [ebp-14h]
  int i; // [esp+18h] [ebp-10h]
  int v13; // [esp+1Ch] [ebp-Ch]

  dword_8185BCC = FS_FOpenFileRead(a1, (int *)v11, 0);
  if ( !*(_DWORD *)v11 )
  {
    v1 = va(aExeErrCouldntL_1, a1);
    Com_Error(1, v1);
  }
  dword_8185BC8 = sub_80A9324(dword_8185BCC);
  v13 = FS_Read((int)dword_8185BC8, dword_8185BCC, *(int *)v11);
  FS_FCloseFile(*(int *)v11);
  if ( v13 != dword_8185BCC || dword_8185BCC <= 0x13F )
  {
    Z_FreeInternal(dword_8185BC8);
    v2 = va(aExeErrCouldntL_1, a1);
    Com_Error(1, v2);
  }
  dword_8185BD0 = sub_8067642(dword_8185BC8, dword_8185BCC);
  v3 = (int *)dword_8185BC8;
  *v3 = sub_8051E92(*(_DWORD *)dword_8185BC8);
  v4 = dword_8185BC8;
  v4[1] = sub_8051E92(*((_DWORD *)dword_8185BC8 + 1));
  if ( *(_DWORD *)dword_8185BC8 != 1347633737 || (result = (int *)dword_8185BC8, *((_DWORD *)dword_8185BC8 + 1) != 4) )
  {
    Z_FreeInternal(dword_8185BC8);
    v6 = va(aExeErrWrongMap, a1);
    Com_Error(1, v6);
  }
  for ( i = 0; i != 39; ++i )
  {
    v7 = dword_8185BC8;
    v8 = i;
    v7[2 * v8 + 2] = sub_8051E92(*((_DWORD *)dword_8185BC8 + 2 * i + 2));
    v9 = dword_8185BC8;
    v10 = i;
    v9[2 * v10 + 3] = sub_8051E92(*((_DWORD *)dword_8185BC8 + 2 * i + 3));
    result = &i;
  }
  return result;
}
// 8185BD0: using guessed type int dword_8185BD0;

//----- (08051E5C) --------------------------------------------------------
void sub_8051E5C()
{
  Z_FreeInternal(dword_8185BC8);
  dword_8185BC8 = 0;
}

//----- (08051E7C) --------------------------------------------------------
void SND_ErrorCleanup()
{
  if ( (unsigned __int8)sub_8051C54() )
    sub_8051E5C();
}

//----- (08051E92) --------------------------------------------------------
int __cdecl sub_8051E92(int a1)
{
  return a1;
}

//----- (08051E9C) --------------------------------------------------------
signed int __cdecl sub_8051E9C(int a1)
{
  char *v1; // ST08_4
  signed int result; // eax

  v1 = (char *)&unk_8523A1C + 24 * a1;
  *(_DWORD *)v1 = 0;
  *((_DWORD *)v1 + 3) = Hunk_AllocInternal(2 * dword_8185C44);
  *((_DWORD *)v1 + 1) = Hunk_AllocInternal(4 * dword_8185C2C);
  *((_DWORD *)v1 + 2) = Hunk_AllocInternal(4 * dword_8185C24);
  *((_DWORD *)v1 + 4) = Hunk_AllocInternal(0x30u);
  qmemcpy(*((void **)v1 + 4), (const void *)dword_8185C7C, 0x30u);
  *((_DWORD *)v1 + 5) = Hunk_AllocInternal(0x48u);
  result = 72;
  qmemcpy(*((void **)v1 + 5), &unk_8185C80, 0x48u);
  return result;
}
// 8185C24: using guessed type int dword_8185C24;
// 8185C2C: using guessed type int dword_8185C2C;
// 8185C44: using guessed type int dword_8185C44;
// 8185C7C: using guessed type int dword_8185C7C;

//----- (08051F6A) --------------------------------------------------------
signed int sub_8051F6A()
{
  return sub_8051E9C(0);
}

//----- (08051F7E) --------------------------------------------------------
char *__cdecl sub_8051F7E(char *s)
{
  sub_8054B6C(s, 1);
  return sub_80583FA();
}

//----- (08051F9E) --------------------------------------------------------
int __cdecl sub_8051F9E(char *s2, int a2)
{
  int result; // eax

  if ( !s2 || !*s2 )
    Com_Error(1, &byte_813AE20);
  if ( !dest || strcasecmp(dest, s2) )
  {
    sub_8051F7E(s2);
    sub_8051F6A();
  }
  result = dword_8185CEC;
  *(_DWORD *)a2 = dword_8185CEC;
  return result;
}
// 8185CEC: using guessed type int dword_8185CEC;

//----- (08052006) --------------------------------------------------------
void *CM_Shutdown()
{
  return sub_80AA83E(&dest, 0, 0x110u);
}

//----- (0805202A) --------------------------------------------------------
int __cdecl sub_805202A(int a1, int a2)
{
  int result; // eax
  int i; // [esp+14h] [ebp-4h]

  for ( i = 0; ; ++i )
  {
    result = i;
    if ( i >= a2 )
      break;
    *(_DWORD *)(a1 + 4 * i) = sub_80525D6(*(_DWORD *)(a1 + 4 * i));
  }
  return result;
}

//----- (0805208A) --------------------------------------------------------
void __cdecl sub_805208A(int a1, char *a2, int a3, _DWORD *a4)
{
  unsigned int v4; // [esp+14h] [ebp-2E4h]
  char *v5; // [esp+18h] [ebp-2E0h]
  char *v6; // [esp+1Ch] [ebp-2DCh]
  int v7; // [esp+20h] [ebp-2D8h]
  unsigned int v8; // [esp+24h] [ebp-2D4h]
  char *v9; // [esp+28h] [ebp-2D0h]
  char *v10; // [esp+2Ch] [ebp-2CCh]
  int v11; // [esp+30h] [ebp-2C8h]
  int v12; // [esp+34h] [ebp-2C4h]
  size_t v13; // [esp+38h] [ebp-2C0h]
  int v14; // [esp+3Ch] [ebp-2BCh]
  int i; // [esp+40h] [ebp-2B8h]
  size_t v16; // [esp+44h] [ebp-2B4h]
  int v17; // [esp+48h] [ebp-2B0h]
  int v18; // [esp+4Ch] [ebp-2ACh]
  char v19; // [esp+50h] [ebp-2A8h]
  int v20; // [esp+54h] [ebp-2A4h]
  int v21[77]; // [esp+5Ch] [ebp-29Ch]
  char v22; // [esp+190h] [ebp-168h]
  char v23[4]; // [esp+194h] [ebp-164h]
  int v24; // [esp+198h] [ebp-160h]
  int v25[79]; // [esp+19Ch] [ebp-15Ch]
  char *v26; // [esp+2D8h] [ebp-20h]
  void *ptr; // [esp+2DCh] [ebp-1Ch]

  v18 = FS_FOpenFileRead((int)dest, &v11, 0);
  if ( !v11 )
    Com_Error(1, aExeErrCouldntL, dest);
  ptr = Z_MallocInternal(v18 + 1);
  FS_Read((int)ptr, v18, v11);
  *((_BYTE *)ptr + v18) = 0;
  FS_FCloseFile(v11);
  v10 = &v22;
  v9 = (char *)ptr;
  v8 = 320;
  if ( (unsigned int)&v22 & 4 )
  {
    *(_DWORD *)&v22 = *(_DWORD *)ptr;
    v10 = v23;
    v9 = (char *)ptr + 4;
    v8 = 316;
  }
  qmemcpy(v10, v9, 4 * (v8 >> 2));
  v7 = sub_80525D6(*(int *)v23);
  if ( v7 != 4 && v7 != 61 )
    Com_Error(1, "bad bsp version %d", *(_DWORD *)v23);
  v14 = 39;
  sub_805202A((int)&v22, 39);
  v6 = &v19;
  v5 = &v22;
  v4 = 320;
  if ( (unsigned int)&v19 & 4 )
  {
    *(_DWORD *)&v19 = *(_DWORD *)&v22;
    v6 = (char *)&v20;
    v5 = v23;
    v4 = 316;
  }
  qmemcpy(v6, v5, 4 * (v4 >> 2));
  v11 = sub_809EB4A();
  if ( !v11 )
    Com_Error(1, "Failed to open file %s for writing", dest);
  v16 = 8 * v14 + 8;
  v17 = 8 * v14 + 8;
  for ( i = 0; i < v14; ++i )
  {
    if ( i == a1 )
      *(&v24 + 2 * i) = a3;
    v25[2 * i] = v17;
    v17 += (*(&v24 + 2 * i) + 3) & 0xFFFFFFFC;
  }
  sub_805202A((int)&v22, v14);
  sub_809E454(&v22, v16, v11);
  sub_805202A((int)&v22, v14);
  v12 = 0;
  for ( i = 0; i < v14; ++i )
  {
    if ( *(&v24 + 2 * i) )
    {
      v26 = i == a1 ? a2 : (char *)ptr + v21[2 * i];
      sub_809E454(v26, *(&v24 + 2 * i), v11);
      v13 = ((*(&v24 + 2 * i) + 3) & 0xFFFFFFFC) - *(&v24 + 2 * i);
      if ( v13 )
        sub_809E454((char *)&v12, v13, v11);
    }
  }
  FS_FCloseFile(v11);
  Z_FreeInternal(ptr);
  if ( a4 )
  {
    v17 = FS_ReadFile(dest, &ptr);
    *a4 = sub_8067642(ptr, v17);
    FS_FreeFile(ptr);
  }
}
// 805208A: using guessed type int var_15C[79];
// 805208A: using guessed type int var_29C[77];

//----- (080524EA) --------------------------------------------------------
void *sub_80524EA()
{
  return dword_8185C78;
}

//----- (080524F4) --------------------------------------------------------
int __cdecl sub_80524F4(int a1)
{
  return *(signed __int16 *)(dword_8185C08 + 44 * a1 + 40);
}
// 8185C08: using guessed type int dword_8185C08;

//----- (08052518) --------------------------------------------------------
int __cdecl sub_8052518(int a1, _DWORD *a2, _DWORD *a3)
{
  _DWORD *v3; // ST14_4

  v3 = (_DWORD *)sub_8059154(a1);
  sub_80525A6(v3, a2);
  return sub_80525A6(v3 + 3, a3);
}

//----- (08052556) --------------------------------------------------------
void *__cdecl sub_8052556(size_t a1)
{
  return Hunk_AllocInternal(a1);
}

//----- (0805256A) --------------------------------------------------------
void sub_805256A()
{
  ;
}

//----- (08052570) --------------------------------------------------------
void sub_8052570()
{
  ;
}

//----- (08052576) --------------------------------------------------------
size_t __cdecl sub_8052576(int a1)
{
  return sub_80A9CF0(a1);
}

//----- (0805258A) --------------------------------------------------------
int sub_805258A()
{
  return sub_80AA124();
}

//----- (08052598) --------------------------------------------------------
int sub_8052598()
{
  return sub_80A9DB4();
}

//----- (080525A6) --------------------------------------------------------
int __cdecl sub_80525A6(_DWORD *a1, _DWORD *a2)
{
  int result; // eax

  *a2 = *a1;
  a2[1] = a1[1];
  result = a1[2];
  a2[2] = result;
  return result;
}

//----- (080525D6) --------------------------------------------------------
int __cdecl sub_80525D6(int a1)
{
  return a1;
}

//----- (080525E0) --------------------------------------------------------
int __cdecl sub_80525E0(_DWORD *a1)
{
  int result; // eax
  signed int v2; // [esp+14h] [ebp-14h]
  int v3; // [esp+18h] [ebp-10h]
  _DWORD *v4; // [esp+1Ch] [ebp-Ch]
  char *src; // [esp+20h] [ebp-8h]

  src = (char *)(dword_8185CFC + a1[1]);
  if ( *a1 % 0x48u )
    Com_Error(1, &byte_813AEC0);
  v2 = *a1 / 0x48u;
  if ( v2 <= 0 )
    Com_Error(1, &byte_813AEE5);
  dword_8185BF0 = (char *)sub_8052556(72 * v2 + 72) + 72;
  dword_8185BEC = v2;
  Com_Memcpy(dword_8185BF0, src, 72 * v2);
  result = sub_8055168(1);
  if ( result != 1 )
  {
    v4 = dword_8185BF0;
    v3 = 0;
    while ( 1 )
    {
      result = v3;
      if ( v3 >= v2 )
        break;
      v4[17] = sub_8055168(v4[17]);
      v4[16] = sub_8055168(v4[16]);
      ++v3;
      src += 72;
      v4 += 18;
    }
  }
  return result;
}
// 8185BEC: using guessed type int dword_8185BEC;
// 8185CFC: using guessed type int dword_8185CFC;

//----- (08052728) --------------------------------------------------------
_DWORD *sub_8052728()
{
  _DWORD *s; // ST14_4

  s = (_DWORD *)sub_8079C94(20);
  memset(s, 0, 0x14u);
  s[2] = -8388609;
  return s;
}

//----- (08052768) --------------------------------------------------------
int __cdecl sub_8052768(_DWORD *a1)
{
  int result; // eax
  int v2; // ebx
  int v3; // esi
  int v4; // eax
  int v5; // ebx
  int v6; // esi
  int v7; // eax
  int v8; // esi
  float v9; // ST1C_4
  long double v10; // fst7
  float v11; // ST00_4
  int v12; // ebx
  float v13[4]; // [esp+20h] [ebp-38h]
  int v14; // [esp+30h] [ebp-28h]
  int v15; // [esp+34h] [ebp-24h]
  int v16; // [esp+38h] [ebp-20h]
  int v17; // [esp+3Ch] [ebp-1Ch]
  int i; // [esp+40h] [ebp-18h]
  int v19; // [esp+44h] [ebp-14h]
  int v20; // [esp+48h] [ebp-10h]
  int v21; // [esp+4Ch] [ebp-Ch]

  v21 = dword_8185CFC + a1[1];
  if ( *a1 % 0x30u )
    Com_Error(1, &byte_813AF20);
  v17 = *a1 / 0x30u;
  if ( v17 <= 0 )
    Com_Error(1, &byte_813AF45);
  v14 = 72 * v17;
  dword_8185C58 = (int)sub_8052556(72 * v17);
  dword_8185C54 = v17;
  if ( v17 > 1023 )
    Com_Error(1, &byte_813AF6C, 22);
  v19 = 0;
  while ( 1 )
  {
    result = v19;
    if ( v19 >= v17 )
      break;
    v20 = dword_8185C58 + 72 * v19;
    for ( i = 0; i <= 2; ++i )
    {
      v2 = v20;
      v3 = i;
      v4 = sub_8055080(v21 + 4 * i);
      *(float *)(v2 + 4 * v3) = sub_8055170(v4) - 1.0;
      v5 = v20;
      v6 = i;
      v7 = sub_8055080(v21 + 4 * i + 12);
      *(float *)(v5 + 4 * v6 + 12) = sub_8055170(v7) + 1.0;
      v8 = i;
      v9 = sub_8054FF8(*(float *)(v20 + 4 * i + 12));
      v10 = sub_8054FF8(*(float *)(v20 + 4 * i));
      v11 = v10;
      sub_8055012(v11, v9);
      v13[v8] = v10;
    }
    v12 = v20;
    *(float *)(v12 + 24) = sub_8055116(v13);
    if ( v19 )
    {
      v16 = sub_8055168(*(_DWORD *)(v21 + 36));
      *(_WORD *)(v20 + 30) = v16;
      if ( *(unsigned __int16 *)(v20 + 30) != v16 )
        Com_Error(1, &byte_813AFA0, 22);
      v15 = sub_8055168(*(_DWORD *)(v21 + 32));
      *(_WORD *)(v20 + 28) = v15;
      if ( *(unsigned __int16 *)(v20 + 28) != v15 )
        Com_Error(1, &byte_813AFE0, 22);
    }
    ++v19;
    v21 += 48;
  }
  return result;
}
// 8055116: using guessed type double __cdecl sub_8055116(_DWORD);
// 8055170: using guessed type double __cdecl sub_8055170(_DWORD);
// 8185C54: using guessed type int dword_8185C54;
// 8185C58: using guessed type int dword_8185C58;
// 8185CFC: using guessed type int dword_8185CFC;
// 8052768: using guessed type float var_38[4];

//----- (080529AE) --------------------------------------------------------
long double __cdecl sub_80529AE(int a1, int a2, int a3, int a4, int a5, float *a6)
{
  float v6; // ST04_4
  long double v7; // fst7
  float v8; // ST00_4
  float v9; // ST14_4
  float v11; // [esp+14h] [ebp-24h]
  float v12; // [esp+18h] [ebp-20h]
  float v13; // [esp+1Ch] [ebp-1Ch]
  int v14; // [esp+20h] [ebp-18h]
  int v15; // [esp+24h] [ebp-14h]
  int i; // [esp+2Ch] [ebp-Ch]
  int v17; // [esp+30h] [ebp-8h]
  int v18; // [esp+34h] [ebp-4h]

  v18 = -1;
  v17 = -1;
  v13 = -3.4028235e38;
  v12 = 3.4028235e38;
  for ( i = 0; i < a2; ++i )
  {
    v15 = dword_8185C60 + 48 * *(unsigned __int16 *)(a1 + 2 * i);
    if ( *(float *)(v15 + 4 * a3) < (long double)*a6 )
    {
      if ( *a6 >= (long double)*(float *)(v15 + 4 * a3 + 16) )
      {
        ++v17;
        if ( *(float *)(v15 + 4 * a3 + 16) > (long double)v13 )
          v13 = *(float *)(v15 + 4 * a3 + 16);
      }
    }
    else
    {
      ++v18;
      if ( v12 > (long double)*(float *)(v15 + 4 * a3) )
        v12 = *(float *)(v15 + 4 * a3);
    }
  }
  v14 = sub_805505A(v17, v18);
  *a6 = (v13 + v12) * 0.5;
  if ( v14 <= 0 )
  {
    v11 = 0.0;
  }
  else
  {
    v6 = *(float *)(a5 + 4 * a3) - v13;
    v7 = v12 - *(float *)(a4 + 4 * a3);
    v8 = v7;
    sub_8055036(v8, v6);
    v9 = v7;
    v11 = (long double)v14 * v9;
  }
  return v11;
}
// 8185C60: using guessed type int dword_8185C60;

//----- (08052B12) --------------------------------------------------------
_DWORD *__cdecl sub_8052B12(void *src, int a2, int a3, int a4)
{
  long double v4; // fst7
  float v5; // ST04_4
  long double v6; // fst7
  float v7; // ST04_4
  int v8; // ST2C_4
  float v11; // [esp+28h] [ebp-70h]
  int v12[4]; // [esp+30h] [ebp-68h]
  float v13[4]; // [esp+40h] [ebp-58h]
  int v14; // [esp+50h] [ebp-48h]
  int v15; // [esp+54h] [ebp-44h]
  void *dest; // [esp+58h] [ebp-40h]
  size_t n; // [esp+5Ch] [ebp-3Ch]
  int v18; // [esp+60h] [ebp-38h]
  int v19; // [esp+64h] [ebp-34h]
  _DWORD *v20; // [esp+68h] [ebp-30h]
  int v21; // [esp+6Ch] [ebp-2Ch]
  float v22; // [esp+70h] [ebp-28h]
  float v23; // [esp+74h] [ebp-24h]
  float v24; // [esp+78h] [ebp-20h]
  float v25; // [esp+7Ch] [ebp-1Ch]
  int v26; // [esp+80h] [ebp-18h]
  int v27; // [esp+84h] [ebp-14h]
  int j; // [esp+88h] [ebp-10h]
  unsigned __int8 i; // [esp+8Fh] [ebp-9h]

  v20 = sub_8052728();
  v22 = 0.0;
  v21 = -1;
  v23 = 0.0;
  for ( i = 0; i <= 2u; ++i )
  {
    for ( j = 0; j < a2; ++j )
    {
      v27 = *((unsigned __int16 *)src + j);
      v26 = dword_8185C60 + 48 * v27;
      v24 = *(float *)(dword_8185C60 + 48 * v27 + 4 * i);
      v25 = sub_80529AE((int)src, a2, i, a3, a4, &v24);
      if ( v25 > (long double)v22 )
      {
        v22 = v25;
        v21 = i;
        v23 = v24;
      }
      v24 = *(float *)(v26 + 4 * i + 16);
      v25 = sub_80529AE((int)src, a2, i, a3, a4, &v24);
      if ( v25 > (long double)v22 )
      {
        v22 = v25;
        v21 = i;
        v23 = v24;
      }
    }
  }
  if ( v21 >= 0 )
  {
    n = 2 * a2;
    dest = (void *)sub_8052576(2 * a2);
    memcpy(dest, src, 2 * a2);
    v15 = 0;
    for ( j = 0; j < a2; ++j )
    {
      v27 = *((unsigned __int16 *)dest + j);
      v26 = dword_8185C60 + 48 * v27;
      if ( *(float *)(dword_8185C60 + 48 * v27 + 4 * v21) < (long double)v23
        && v23 < (long double)*(float *)(v26 + 4 * v21 + 16) )
      {
        *((_WORD *)src + v15++) = v27;
      }
    }
    if ( v15 )
    {
      v19 = sub_8052B12(src, v15, a3, a4);
      *((_WORD *)v20 + 1) = -1;
      v20[1] = *(_DWORD *)(v19 + 4);
      src = (char *)src + 2 * v15;
    }
    v11 = 3.4028235e38;
    *(_BYTE *)v20 = v21;
    *((float *)v20 + 2) = v23;
    v14 = 0;
LABEL_27:
    if ( v14 > 1 )
    {
      *((float *)v20 + 3) = v11;
      return v20;
    }
    v15 = 0;
    for ( j = 0; ; ++j )
    {
      if ( j >= a2 )
      {
        sub_80550AE((_DWORD *)a3, v13);
        sub_80550AE((_DWORD *)a4, v12);
        if ( v14 )
          *(float *)&v12[v21] = v23 - v11;
        else
          v13[v21] = v23 + v11;
        v18 = sub_8052B12(src, v15, (int)v13, (int)v12);
        v8 = -858993459 * ((v18 - (signed int)v20) >> 2);
        *((_WORD *)v20 + v14 + 8) = -13107 * ((v18 - (signed int)v20) >> 2);
        if ( *((unsigned __int16 *)v20 + v14 + 8) != v8 )
          Com_Error(1, &byte_813B080);
        v20[1] |= *(_DWORD *)(v18 + 4);
        src = (char *)src + 2 * v15;
        ++v14;
        goto LABEL_27;
      }
      v27 = *((unsigned __int16 *)dest + j);
      v26 = dword_8185C60 + 48 * v27;
      if ( v14 )
      {
        if ( *(float *)(v26 + 4 * v21 + 16) > (long double)v23 )
          continue;
        v6 = v23 - *(float *)(v26 + 4 * v21 + 16);
        v7 = v6;
        sub_8055036(v11, v7);
        v11 = v6;
      }
      else
      {
        if ( v23 > (long double)*(float *)(v26 + 4 * v21) )
          continue;
        v4 = *(float *)(v26 + 4 * v21) - v23;
        v5 = v4;
        sub_8055036(v11, v5);
        v11 = v4;
      }
      *((_WORD *)src + v15++) = v27;
    }
  }
  *((_WORD *)v20 + 1) = a2;
  if ( *((signed __int16 *)v20 + 1) != a2 )
    Com_Error(1, &byte_813B020);
  for ( j = 0; j < a2; ++j )
  {
    v27 = *((unsigned __int16 *)src + j);
    v26 = dword_8185C60 + 48 * v27;
    v20[1] |= *(_DWORD *)(dword_8185C60 + 48 * v27 + 12);
  }
  v20[2] = src;
  return v20;
}
// 8185C60: using guessed type int dword_8185C60;
// 8052B12: using guessed type int var_68[4];

//----- (08052FD4) --------------------------------------------------------
void __cdecl sub_8052FD4(void *src, int a2, int a3)
{
  signed int j; // [esp+10h] [ebp-38h]
  signed int k; // [esp+10h] [ebp-38h]
  int v5; // [esp+14h] [ebp-34h]
  int i; // [esp+1Ch] [ebp-2Ch]
  int v7[4]; // [esp+20h] [ebp-28h]
  int v8[6]; // [esp+30h] [ebp-18h]

  if ( a2 )
  {
    sub_805508A(v8, 2139095039, 2139095039, 2139095039);
    sub_805508A(v7, -8388609, -8388609, -8388609);
    for ( i = 0; i < a2; ++i )
    {
      v5 = dword_8185C60 + 48 * *((unsigned __int16 *)src + i);
      for ( j = 0; j <= 2; ++j )
      {
        if ( *(float *)&v8[j] > (long double)*(float *)(v5 + 4 * j) )
          v8[j] = *(_DWORD *)(v5 + 4 * j);
        if ( *(float *)(v5 + 4 * j + 16) > (long double)*(float *)&v7[j] )
          v7[j] = *(_DWORD *)(v5 + 4 * j + 16);
      }
    }
    sub_80550AE(v8, (_DWORD *)(a3 + 12));
    sub_80550AE(v7, (_DWORD *)(a3 + 24));
    for ( k = 0; k <= 2; ++k )
    {
      *(float *)(a3 + 4 * k + 12) = *(float *)(a3 + 4 * k + 12) - 0.125;
      *(float *)(a3 + 4 * k + 24) = *(float *)(a3 + 4 * k + 24) + 0.125;
    }
    sub_8052570();
    *(_DWORD *)(a3 + 36) = -858993459 * (((char *)sub_8052B12(src, a2, (int)v8, (int)v7) - (_BYTE *)dword_8185C10) >> 2);
    sub_8052598();
  }
}
// 8185C60: using guessed type int dword_8185C60;
// 8052FD4: using guessed type int var_18[6];
// 8052FD4: using guessed type int var_28[4];

//----- (0805319E) --------------------------------------------------------
int __cdecl sub_805319E(unsigned __int16 *a1)
{
  signed int i; // [esp+0h] [ebp-8h]
  int v3; // [esp+4h] [ebp-4h]

  v3 = 0;
  for ( i = 0; i < a1[1]; ++i )
    v3 |= *((_DWORD *)dword_8185BF0 + 18 * *(unsigned __int16 *)(dword_8185C50 + 32 * (i + *a1) + 24) + 17);
  return v3;
}
// 8185C50: using guessed type int dword_8185C50;

//----- (08053200) --------------------------------------------------------
int __cdecl sub_8053200(int a1)
{
  int result; // eax
  int v2; // eax
  int v3; // [esp+14h] [ebp-24h]
  int v4; // [esp+1Ch] [ebp-1Ch]
  _WORD *src; // [esp+20h] [ebp-18h]
  int i; // [esp+24h] [ebp-14h]
  int v7; // [esp+28h] [ebp-10h]
  int v8; // [esp+2Ch] [ebp-Ch]
  int v9; // [esp+30h] [ebp-8h]

  v9 = dword_8185CFC + *(_DWORD *)(a1 + 4);
  v7 = 0;
  while ( 1 )
  {
    result = v7;
    if ( v7 >= dword_8185C54 )
      break;
    if ( v7 )
    {
      v8 = dword_8185C58 + 72 * v7;
      v4 = sub_8055168(*(_DWORD *)(v9 + 44));
      src = sub_8052556(2 * v4);
      v3 = 0;
      for ( i = 0; i < v4; ++i )
      {
        v2 = sub_8055168(*(_DWORD *)(v9 + 40));
        src[i] = i + v2;
        if ( (unsigned __int16)src[i] != i + v2 )
          Com_Error(1, &byte_813B0E0, 22);
        v3 |= *(_DWORD *)(dword_8185C60 + 48 * (i + v2) + 12);
      }
      *(_DWORD *)(v8 + 32) = v3;
      *(_DWORD *)(v8 + 36) = sub_805319E((unsigned __int16 *)(v8 + 28));
      sub_8052FD4(src, v4, v8 + 28);
    }
    ++v7;
    v9 += 48;
  }
  return result;
}
// 8185C54: using guessed type int dword_8185C54;
// 8185C58: using guessed type int dword_8185C58;
// 8185C60: using guessed type int dword_8185C60;
// 8185CFC: using guessed type int dword_8185CFC;

//----- (08053354) --------------------------------------------------------
signed int __cdecl sub_8053354(_DWORD *a1)
{
  signed int result; // eax
  int v2; // eax
  signed int v3; // [esp+1Ch] [ebp-1Ch]
  signed int i; // [esp+20h] [ebp-18h]
  signed int v5; // [esp+24h] [ebp-14h]
  _DWORD *v6; // [esp+28h] [ebp-10h]
  int *v7; // [esp+30h] [ebp-8h]

  v7 = (int *)(dword_8185CFC + a1[1]);
  if ( *a1 % 0x24u )
    Com_Error(1, &byte_813B120);
  v3 = *a1 / 0x24u;
  if ( v3 <= 0 )
    Com_Error(1, &byte_813B141);
  dword_8185C00 = (int)sub_8052556(8 * v3);
  dword_8185BFC = v3;
  v6 = (_DWORD *)dword_8185C00;
  v5 = 0;
  while ( 1 )
  {
    result = v5;
    if ( v5 >= v3 )
      break;
    *v6 = dword_8185CF8 + 20 * sub_8055168(*v7);
    for ( i = 0; i <= 1; ++i )
    {
      v2 = sub_8055168(v7[i + 1]);
      *((_WORD *)v6 + i + 2) = v2;
      if ( *((signed __int16 *)v6 + i + 2) != v2 )
        Com_Error(1, &byte_813B180, 21);
    }
    ++v5;
    v6 += 2;
    v7 += 9;
  }
  return result;
}
// 8185BFC: using guessed type int dword_8185BFC;
// 8185C00: using guessed type int dword_8185C00;
// 8185CF8: using guessed type int dword_8185CF8;
// 8185CFC: using guessed type int dword_8185CFC;

//----- (080534B8) --------------------------------------------------------
int __cdecl sub_80534B8(_DWORD *a1, _DWORD *a2)
{
  int result; // eax
  int v3; // eax
  int v4; // eax
  _DWORD *v5; // [esp+18h] [ebp-50h]
  _DWORD *v6; // [esp+20h] [ebp-48h]
  signed int v7; // [esp+34h] [ebp-34h]
  int v8; // [esp+3Ch] [ebp-2Ch]
  int v9; // [esp+3Ch] [ebp-2Ch]
  int v10; // [esp+40h] [ebp-28h]
  int v11; // [esp+44h] [ebp-24h]
  signed int i; // [esp+48h] [ebp-20h]
  int v13; // [esp+48h] [ebp-20h]
  int v14; // [esp+4Ch] [ebp-1Ch]
  _DWORD *v15; // [esp+50h] [ebp-18h]
  _DWORD *v16; // [esp+54h] [ebp-14h]
  int *v17; // [esp+58h] [ebp-10h]
  __int16 *v18; // [esp+5Ch] [ebp-Ch]

  v18 = (__int16 *)(dword_8185CFC + a1[1]);
  if ( *a1 & 3 )
    Com_Error(1, &byte_813B1C0);
  v11 = *a1 >> 2;
  v17 = (int *)(dword_8185CFC + a2[1]);
  if ( *a2 & 7 )
    Com_Error(1, &byte_813B1C0);
  v10 = (*a2 >> 3) - 6 * v11;
  if ( v10 < 0 )
    Com_Error(1, &byte_813B200);
  if ( *a2 >> 3 == 6 * v11 )
    v6 = 0;
  else
    v6 = sub_8052556(8 * v10);
  dword_8185BF8 = (int)v6;
  dword_8185BF4 = v10;
  v15 = v6;
  dword_8185C60 = (int)sub_8052556(48 * (v11 + 1));
  word_8185C5C = v11;
  if ( (unsigned __int16)v11 != v11 )
    Com_Error(1, &byte_813B260, 22);
  v16 = (_DWORD *)dword_8185C60;
  v14 = 0;
  while ( 1 )
  {
    result = v14;
    if ( v14 >= v11 )
      break;
    v16[7] = (signed __int16)sub_8055154(*v18) - 6;
    if ( v16[7] < 0 )
      Com_Error(1, &byte_813B2A0, 22);
    if ( v16[7] )
      v5 = v15;
    else
      v5 = 0;
    v16[8] = v5;
    for ( i = 0; i <= 2; ++i )
    {
      v7 = 0;
      while ( v7 <= 1 )
      {
        if ( v7 )
        {
          v4 = sub_8055080((int)v17);
          *(float *)&v16[i + 4] = sub_8055170(v4);
        }
        else
        {
          v3 = sub_8055080((int)v17);
          *(float *)&v16[i] = sub_8055170(v3);
        }
        v8 = sub_8055168(v17[1]);
        if ( v8 < 0 || v8 >= dword_8185BEC )
          Com_Error(1, &byte_813B2E0, v8);
        *((_WORD *)v16 + i + 3 * v7 + 18) = v8;
        if ( *((signed __int16 *)v16 + i + 3 * v7 + 18) != v8 )
          Com_Error(1, &byte_813B320, 22);
        ++v7;
        v17 += 2;
      }
    }
    v13 = 0;
    while ( v13 < v16[7] )
    {
      *v15 = dword_8185CF8 + 20 * sub_8055168(*v17);
      v15[1] = sub_8055168(v17[1]);
      if ( v15[1] < 0 || v15[1] >= dword_8185BEC )
        Com_Error(1, &byte_813B2E0, v15[1]);
      ++v13;
      v17 += 2;
      v15 += 2;
    }
    v9 = (signed __int16)sub_8055154(v18[1]);
    if ( v9 < 0 || v9 >= dword_8185BEC )
      Com_Error(1, &byte_813B2E0, v9);
    v16[3] = *((_DWORD *)dword_8185BF0 + 18 * v9 + 17) & 0xDFFFFFFB;
    ++v14;
    v16 += 12;
    v18 += 2;
  }
  return result;
}
// 8055170: using guessed type double __cdecl sub_8055170(_DWORD);
// 8185BEC: using guessed type int dword_8185BEC;
// 8185BF4: using guessed type int dword_8185BF4;
// 8185BF8: using guessed type int dword_8185BF8;
// 8185C5C: using guessed type __int16 word_8185C5C;
// 8185C60: using guessed type int dword_8185C60;
// 8185CF8: using guessed type int dword_8185CF8;
// 8185CFC: using guessed type int dword_8185CFC;

//----- (080538BC) --------------------------------------------------------
signed int __cdecl sub_80538BC(_DWORD *a1, char a2)
{
  signed int result; // eax
  int v3; // eax
  int v4; // eax
  int v5; // [esp+20h] [ebp-18h]
  signed int v6; // [esp+24h] [ebp-14h]
  int *v7; // [esp+28h] [ebp-10h]
  unsigned __int16 *v8; // [esp+2Ch] [ebp-Ch]
  signed int v9; // [esp+30h] [ebp-8h]

  v7 = (int *)(dword_8185CFC + a1[1]);
  if ( *a1 % 0x24u )
    Com_Error(1, &byte_813B360);
  v6 = *a1 / 0x24u;
  if ( v6 <= 0 )
    Com_Error(1, &byte_813B381);
  dword_8185C08 = (int)sub_8052556(44 * v6);
  dword_8185C04 = v6;
  v5 = 0;
  v8 = (unsigned __int16 *)dword_8185C08;
  v9 = 0;
  while ( 1 )
  {
    result = v9;
    if ( v9 >= v6 )
      break;
    if ( a2 )
    {
      v5 = sub_8055168(*v7);
      v8[20] = v5;
      if ( (signed __int16)v8[20] != v5 )
        Com_Error(1, &byte_813B3C0, 21);
    }
    v3 = sub_8055168(v7[2]);
    *v8 = v3;
    if ( *v8 != v3 )
      Com_Error(1, &byte_813B400, 21);
    v4 = sub_8055168(v7[3]);
    v8[1] = v4;
    if ( v8[1] != v4 )
      Com_Error(1, &byte_813B440, 21);
    if ( a2 )
    {
      if ( v5 >= dword_8185C64 )
        dword_8185C64 = v5 + 1;
    }
    ++v9;
    v7 += 9;
    v8 += 22;
  }
  return result;
}
// 8185C04: using guessed type int dword_8185C04;
// 8185C08: using guessed type int dword_8185C08;
// 8185C64: using guessed type int dword_8185C64;
// 8185CFC: using guessed type int dword_8185CFC;

//----- (08053A80) --------------------------------------------------------
int __cdecl sub_8053A80(int a1)
{
  int result; // eax
  int i; // [esp+18h] [ebp-20h]
  int v3; // [esp+1Ch] [ebp-1Ch]
  int v4; // [esp+20h] [ebp-18h]
  int v5; // [esp+24h] [ebp-14h]
  int v6; // [esp+28h] [ebp-10h]
  int v7; // [esp+2Ch] [ebp-Ch]
  int v8; // [esp+30h] [ebp-8h]

  v6 = dword_8185CFC + *(_DWORD *)(a1 + 4);
  v7 = dword_8185C08;
  v8 = 0;
  while ( 1 )
  {
    result = v8;
    if ( v8 >= dword_8185C04 )
      break;
    v5 = sub_8055168(*(_DWORD *)(v6 + 20));
    v4 = sub_8055168(*(_DWORD *)(v6 + 16));
    v3 = 0;
    for ( i = 0; i < v5; ++i )
      v3 |= *(_DWORD *)(dword_8185C60 + 48 * *(unsigned __int16 *)(dword_8185C18 + 2 * (v4 + i)) + 12);
    *(_DWORD *)(v7 + 4) = v3;
    *(_DWORD *)(v7 + 8) = sub_805319E((unsigned __int16 *)v7);
    sub_8052FD4((void *)(dword_8185C18 + 2 * v4), v5, v7);
    ++v8;
    v6 += 36;
    v7 += 44;
  }
  return result;
}
// 8185C04: using guessed type int dword_8185C04;
// 8185C08: using guessed type int dword_8185C08;
// 8185C18: using guessed type int dword_8185C18;
// 8185C60: using guessed type int dword_8185C60;
// 8185CFC: using guessed type int dword_8185CFC;

//----- (08053B7E) --------------------------------------------------------
int __cdecl sub_8053B7E(int a1, _DWORD *a2)
{
  int result; // eax
  int v3; // eax
  int v4; // eax
  char v5; // [esp+Fh] [ebp-29h]
  char v6; // [esp+17h] [ebp-21h]
  int v7; // [esp+1Ch] [ebp-1Ch]
  int v8; // [esp+20h] [ebp-18h]
  int v9; // [esp+24h] [ebp-14h]
  signed int i; // [esp+28h] [ebp-10h]
  int v11; // [esp+2Ch] [ebp-Ch]

  v8 = a1 + a2[1];
  if ( *a2 & 0xF )
    Com_Error(1, &byte_813B120);
  v7 = *a2 >> 4;
  if ( v7 <= 0 )
    Com_Error(1, &byte_813B468);
  dword_8185CF8 = (int)sub_8052556(20 * v7);
  dword_8185CF4 = v7;
  v9 = dword_8185CF8;
  v11 = 0;
  while ( 1 )
  {
    result = v11;
    if ( v11 >= v7 )
      break;
    v6 = 0;
    for ( i = 0; i <= 2; ++i )
    {
      v3 = sub_8055080(v8 + 4 * i);
      *(float *)(v9 + 4 * i) = sub_8055170(v3);
      if ( *(float *)(v9 + 4 * i) < 0.0 )
        v6 |= 1 << i;
    }
    v4 = sub_8055080(v8 + 12);
    *(float *)(v9 + 12) = sub_8055170(v4);
    if ( *(float *)v9 == 1.0 )
    {
      v5 = 0;
    }
    else if ( *(float *)(v9 + 4) == 1.0 )
    {
      v5 = 1;
    }
    else if ( *(float *)(v9 + 8) == 1.0 )
    {
      v5 = 2;
    }
    else
    {
      v5 = 3;
    }
    *(_BYTE *)(v9 + 16) = v5;
    *(_BYTE *)(v9 + 17) = v6;
    ++v11;
    v8 += 16;
    v9 += 20;
  }
  return result;
}
// 8055170: using guessed type double __cdecl sub_8055170(_DWORD);
// 8185CF4: using guessed type int dword_8185CF4;
// 8185CF8: using guessed type int dword_8185CF8;

//----- (08053D34) --------------------------------------------------------
int __cdecl sub_8053D34(_DWORD *a1)
{
  int result; // eax
  int v2; // eax
  int v3; // [esp+18h] [ebp-10h]
  int *v4; // [esp+1Ch] [ebp-Ch]
  _WORD *v5; // [esp+20h] [ebp-8h]
  int v6; // [esp+24h] [ebp-4h]

  v4 = (int *)(dword_8185CFC + a1[1]);
  if ( *a1 & 3 )
    Com_Error(1, &byte_813B4A0);
  v3 = *a1 >> 2;
  dword_8185C18 = (int)sub_8052556(2 * v3 + 2);
  dword_8185C14 = v3;
  v5 = (_WORD *)dword_8185C18;
  v6 = 0;
  while ( 1 )
  {
    result = v6;
    if ( v6 >= v3 )
      break;
    v2 = sub_8055168(*v4);
    *v5 = v2;
    if ( (unsigned __int16)*v5 != v2 )
      Com_Error(1, &byte_813B4E0, 22);
    ++v6;
    ++v4;
    ++v5;
  }
  return result;
}
// 8185C14: using guessed type int dword_8185C14;
// 8185C18: using guessed type int dword_8185C18;
// 8185CFC: using guessed type int dword_8185CFC;

//----- (08053E0E) --------------------------------------------------------
int __cdecl sub_8053E0E(_DWORD *a1)
{
  int result; // eax
  int v2; // [esp+18h] [ebp-10h]
  int *v3; // [esp+1Ch] [ebp-Ch]
  int *v4; // [esp+20h] [ebp-8h]
  int v5; // [esp+24h] [ebp-4h]

  v3 = (int *)(dword_8185CFC + a1[1]);
  if ( *a1 & 3 )
    Com_Error(1, &byte_813B520);
  v2 = *a1 >> 2;
  dword_8185C20 = (int)sub_8052556(4 * v2);
  dword_8185C1C = v2;
  v4 = (int *)dword_8185C20;
  v5 = 0;
  while ( 1 )
  {
    result = v5;
    if ( v5 >= v2 )
      break;
    *v4 = sub_8055168(*v3);
    ++v5;
    ++v3;
    ++v4;
  }
  return result;
}
// 8185C1C: using guessed type int dword_8185C1C;
// 8185C20: using guessed type int dword_8185C20;
// 8185CFC: using guessed type int dword_8185CFC;

//----- (08053EC2) --------------------------------------------------------
int __cdecl sub_8053EC2(_DWORD *a1)
{
  int result; // eax
  int v2; // eax
  int v3; // eax
  int v4; // eax
  int v5; // [esp+14h] [ebp-14h]
  int v6; // [esp+18h] [ebp-10h]
  float *v7; // [esp+1Ch] [ebp-Ch]
  int v8; // [esp+20h] [ebp-8h]

  v6 = dword_8185CFC + a1[1];
  if ( *a1 & 0xF )
    Com_Error(1, &byte_813B560);
  v5 = *a1 >> 4;
  dword_8185C28 = (int)sub_8052556(12 * v5);
  dword_8185C24 = v5;
  v7 = (float *)dword_8185C28;
  v8 = 0;
  while ( 1 )
  {
    result = v8;
    if ( v8 >= v5 )
      break;
    v2 = sub_8055080(v6 + 4);
    *v7 = sub_8055170(v2);
    v3 = sub_8055080(v6 + 8);
    v7[1] = sub_8055170(v3);
    v4 = sub_8055080(v6 + 12);
    v7[2] = sub_8055170(v4);
    ++v8;
    v6 += 16;
    v7 += 3;
  }
  return result;
}
// 8055170: using guessed type double __cdecl sub_8055170(_DWORD);
// 8185C24: using guessed type int dword_8185C24;
// 8185C28: using guessed type int dword_8185C28;
// 8185CFC: using guessed type int dword_8185CFC;

//----- (08053FC0) --------------------------------------------------------
signed int __cdecl sub_8053FC0(_DWORD *a1)
{
  signed int result; // eax
  int v2; // eax
  int v3; // eax
  int v4; // eax
  int v5; // eax
  int v6; // eax
  int v7; // eax
  int v8; // eax
  int v9; // eax
  int v10; // eax
  int v11; // eax
  int v12; // eax
  int v13; // eax
  int v14; // eax
  float v15; // ST1C_4
  float v16; // ST18_4
  signed int v17; // [esp+24h] [ebp-14h]
  int v18; // [esp+28h] [ebp-10h]
  float *v19; // [esp+2Ch] [ebp-Ch]
  signed int v20; // [esp+30h] [ebp-8h]

  v18 = dword_8185CFC + a1[1];
  if ( *a1 % 0x38u )
    Com_Error(1, &byte_813B5C0);
  v17 = *a1 / 0x38u;
  dword_8185C30 = (int)sub_8052556(48 * v17);
  dword_8185C2C = v17;
  v19 = (float *)dword_8185C30;
  v20 = 0;
  while ( 1 )
  {
    result = v20;
    if ( v20 >= v17 )
      break;
    v2 = sub_8055080(v18 + 4);
    *v19 = sub_8055170(v2);
    v3 = sub_8055080(v18 + 8);
    v19[1] = sub_8055170(v3);
    v4 = sub_8055080(v18 + 12);
    v19[2] = sub_8055170(v4);
    v5 = sub_8055080(v18 + 16);
    v19[3] = sub_8055170(v5);
    v6 = sub_8055080(v18 + 20);
    v19[4] = sub_8055170(v6);
    v7 = sub_8055080(v18 + 24);
    v19[5] = sub_8055170(v7);
    v8 = sub_8055080(v18 + 28);
    v19[6] = sub_8055170(v8);
    v9 = sub_8055080(v18 + 32);
    v19[7] = sub_8055170(v9);
    v10 = sub_8055080(v18 + 36);
    v19[8] = sub_8055170(v10);
    v11 = sub_8055080(v18 + 40);
    v19[9] = sub_8055170(v11);
    v12 = sub_8055080(v18 + 44);
    v19[10] = sub_8055170(v12);
    v13 = sub_8055080(v18 + 48);
    v19[11] = sub_8055170(v13);
    v14 = sub_8055080(v18 + 52);
    v15 = sub_8055170(v14);
    v16 = 1.0 / v15;
    sub_80550DE((int)(v19 + 9), v16, (int)(v19 + 9));
    ++v20;
    v18 += 56;
    v19 += 12;
  }
  return result;
}
// 8055170: using guessed type double __cdecl sub_8055170(_DWORD);
// 8185C2C: using guessed type int dword_8185C2C;
// 8185C30: using guessed type int dword_8185C30;
// 8185CFC: using guessed type int dword_8185CFC;

//----- (08054220) --------------------------------------------------------
signed int __cdecl sub_8054220(_DWORD *a1)
{
  signed int result; // eax
  int v2; // eax
  int v3; // eax
  int v4; // eax
  int v5; // eax
  int v6; // eax
  int v7; // eax
  int v8; // eax
  int v9; // eax
  int v10; // eax
  int v11; // eax
  int v12; // eax
  int v13; // eax
  signed int i; // [esp+1Ch] [ebp-1Ch]
  signed int v15; // [esp+20h] [ebp-18h]
  int v16; // [esp+24h] [ebp-14h]
  float *v17; // [esp+28h] [ebp-10h]
  signed int v18; // [esp+2Ch] [ebp-Ch]

  v16 = dword_8185CFC + a1[1];
  if ( *a1 % 0x48u )
    Com_Error(1, &byte_813B620);
  v15 = *a1 / 0x48u;
  dword_8185C38 = (int)sub_8052556(72 * v15);
  dword_8185C34 = v15;
  v17 = (float *)dword_8185C38;
  v18 = 0;
  while ( 1 )
  {
    result = v18;
    if ( v18 >= v15 )
      break;
    v2 = sub_8055080(v16);
    *v17 = sub_8055170(v2);
    v3 = sub_8055080(v16 + 4);
    v17[1] = sub_8055170(v3);
    v4 = sub_8055080(v16 + 8);
    v17[2] = sub_8055170(v4);
    v5 = sub_8055080(v16 + 12);
    v17[3] = sub_8055170(v5);
    v6 = sub_8055080(v16 + 16);
    v17[4] = sub_8055170(v6);
    v7 = sub_8055080(v16 + 20);
    v17[5] = sub_8055170(v7);
    v8 = sub_8055080(v16 + 24);
    v17[6] = sub_8055170(v8);
    v9 = sub_8055080(v16 + 28);
    v17[7] = sub_8055170(v9);
    v10 = sub_8055080(v16 + 32);
    v17[8] = sub_8055170(v10);
    v11 = sub_8055080(v16 + 36);
    v17[9] = sub_8055170(v11);
    v12 = sub_8055080(v16 + 40);
    v17[10] = sub_8055170(v12);
    v13 = sub_8055080(v16 + 44);
    v17[11] = sub_8055170(v13);
    for ( i = 0; i <= 2; ++i )
    {
      LODWORD(v17[i + 15]) = sub_8055168(*(_DWORD *)(v16 + 4 * i + 60));
      LODWORD(v17[i + 12]) = sub_8055168(*(_DWORD *)(v16 + 4 * i + 48));
    }
    ++v18;
    v16 += 72;
    v17 += 18;
  }
  return result;
}
// 8055170: using guessed type double __cdecl sub_8055170(_DWORD);
// 8185C34: using guessed type int dword_8185C34;
// 8185C38: using guessed type int dword_8185C38;
// 8185CFC: using guessed type int dword_8185CFC;

//----- (0805448C) --------------------------------------------------------
signed int __cdecl sub_805448C(_DWORD *a1)
{
  signed int result; // eax
  int v2; // eax
  int v3; // eax
  int v4; // eax
  int v5; // eax
  int v6; // eax
  int v7; // eax
  int v8; // eax
  signed int v9; // [esp+14h] [ebp-14h]
  int v10; // [esp+18h] [ebp-10h]
  float *v11; // [esp+1Ch] [ebp-Ch]
  signed int v12; // [esp+20h] [ebp-8h]

  v10 = dword_8185CFC + a1[1];
  if ( *a1 % 0x1Cu )
    Com_Error(1, &byte_813B680);
  v9 = *a1 / 0x1Cu;
  dword_8185C40 = (int)sub_8052556(28 * v9);
  dword_8185C3C = v9;
  v11 = (float *)dword_8185C40;
  v12 = 0;
  while ( 1 )
  {
    result = v12;
    if ( v12 >= v9 )
      break;
    v2 = sub_8055080(v10);
    *v11 = sub_8055170(v2);
    v3 = sub_8055080(v10 + 4);
    v11[1] = sub_8055170(v3);
    v4 = sub_8055080(v10 + 8);
    v11[2] = sub_8055170(v4);
    v5 = sub_8055080(v10 + 12);
    v11[3] = sub_8055170(v5);
    v6 = sub_8055080(v10 + 16);
    v11[4] = sub_8055170(v6);
    v7 = sub_8055080(v10 + 20);
    v11[5] = sub_8055170(v7);
    v8 = sub_8055080(v10 + 24);
    v11[6] = sub_8055170(v8);
    ++v12;
    v10 += 28;
    v11 += 7;
  }
  return result;
}
// 8055170: using guessed type double __cdecl sub_8055170(_DWORD);
// 8185C3C: using guessed type int dword_8185C3C;
// 8185C40: using guessed type int dword_8185C40;
// 8185CFC: using guessed type int dword_8185CFC;

//----- (0805461E) --------------------------------------------------------
signed int __cdecl sub_805461E(_DWORD *a1)
{
  signed int result; // eax
  signed int v2; // [esp+14h] [ebp-14h]
  int v3; // [esp+18h] [ebp-10h]
  int v4; // [esp+1Ch] [ebp-Ch]
  signed int v5; // [esp+20h] [ebp-8h]

  v3 = dword_8185CFC + a1[1];
  if ( *a1 % 0xCu )
    Com_Error(1, &byte_813B6E0);
  v2 = *a1 / 0xCu;
  dword_8185C48 = (int)sub_8052556(12 * v2);
  dword_8185C44 = v2;
  v4 = dword_8185C48;
  v5 = 0;
  while ( 1 )
  {
    result = v5;
    if ( v5 >= v2 )
      break;
    *(_BYTE *)v4 = *(_BYTE *)(v3 + 2);
    *(_BYTE *)(v4 + 1) = *(_BYTE *)(v3 + 3);
    *(_DWORD *)(v4 + 4) = dword_8185C38 + 72 * sub_8055168(*(_DWORD *)(v3 + 4));
    *(_DWORD *)(v4 + 8) = dword_8185C40 + 28 * sub_8055168(*(_DWORD *)(v3 + 8));
    ++v5;
    v3 += 12;
    v4 += 12;
  }
  return result;
}
// 8185C38: using guessed type int dword_8185C38;
// 8185C40: using guessed type int dword_8185C40;
// 8185C44: using guessed type int dword_8185C44;
// 8185C48: using guessed type int dword_8185C48;
// 8185CFC: using guessed type int dword_8185CFC;

//----- (0805474E) --------------------------------------------------------
int __cdecl sub_805474E(_DWORD *a1)
{
  int result; // eax
  int v2; // eax
  int v3; // eax
  int v4; // eax
  int v5; // eax
  int v6; // eax
  int v7; // eax
  int v8; // [esp+14h] [ebp-14h]
  int v9; // [esp+18h] [ebp-10h]
  int v10; // [esp+1Ch] [ebp-Ch]
  int v11; // [esp+20h] [ebp-8h]

  v9 = dword_8185CFC + a1[1];
  if ( *a1 & 0x1F )
    Com_Error(1, &byte_813B740);
  v8 = *a1 >> 5;
  dword_8185C50 = (int)sub_8052556(32 * v8);
  dword_8185C4C = v8;
  v10 = dword_8185C50;
  v11 = 0;
  while ( 1 )
  {
    result = v11;
    if ( v11 >= v8 )
      break;
    v2 = sub_8055080(v9);
    *(float *)v10 = sub_8055170(v2);
    v3 = sub_8055080(v9 + 4);
    *(float *)(v10 + 4) = sub_8055170(v3);
    v4 = sub_8055080(v9 + 8);
    *(float *)(v10 + 8) = sub_8055170(v4);
    v5 = sub_8055080(v9 + 12);
    *(float *)(v10 + 12) = sub_8055170(v5);
    v6 = sub_8055080(v9 + 16);
    *(float *)(v10 + 16) = sub_8055170(v6);
    v7 = sub_8055080(v9 + 20);
    *(float *)(v10 + 20) = sub_8055170(v7);
    *(_WORD *)(v10 + 24) = sub_8055154(*(_WORD *)(v9 + 24));
    *(_WORD *)(v10 + 26) = sub_8055154(*(_WORD *)(v9 + 26));
    *(_DWORD *)(v10 + 28) = sub_8055168(*(_DWORD *)(v9 + 28));
    ++v11;
    v9 += 32;
    v10 += 32;
  }
  return result;
}
// 8055170: using guessed type double __cdecl sub_8055170(_DWORD);
// 8185C4C: using guessed type int dword_8185C4C;
// 8185C50: using guessed type int dword_8185C50;
// 8185CFC: using guessed type int dword_8185CFC;

//----- (080548DC) --------------------------------------------------------
void *__cdecl sub_80548DC(size_t *a1)
{
  dword_8185C74 = *a1;
  dword_8185C78 = sub_8052556(*a1);
  return Com_Memcpy(dword_8185C78, (void *)(dword_8185CFC + a1[1]), *a1);
}
// 8185C74: using guessed type int dword_8185C74;
// 8185CFC: using guessed type int dword_8185CFC;

//----- (08054936) --------------------------------------------------------
void *__cdecl sub_8054936(int *a1)
{
  void *result; // eax
  int *v2; // ST10_4
  int v3; // [esp+14h] [ebp-4h]

  v3 = *a1;
  if ( *a1 )
  {
    v2 = (int *)(dword_8185CFC + a1[1]);
    dword_8185C70 = 1;
    dword_8185C64 = sub_8055168(*v2);
    n = sub_8055168(v2[1]);
    dword_8185C6C = sub_8052556(v3 - 8);
    result = Com_Memcpy(dword_8185C6C, v2 + 2, v3 - 8);
  }
  else
  {
    n = (dword_8185C64 + 31) & 0xFFFFFFE0;
    dword_8185C6C = sub_8052556((dword_8185C64 + 31) & 0xFFFFFFE0);
    result = sub_80AA83E(dword_8185C6C, 255, n);
  }
  return result;
}
// 8185C64: using guessed type int dword_8185C64;
// 8185C70: using guessed type int dword_8185C70;
// 8185CFC: using guessed type int dword_8185CFC;

//----- (08054A26) --------------------------------------------------------
int __cdecl sub_8054A26(_DWORD *a1, char a2)
{
  unsigned int v2; // eax
  int n; // ST1C_4
  char *v4; // ST18_4

  sub_80534B8(a1 + 14, a1 + 12);
  sub_8053D34(a1 + 56);
  sub_805474E(a1 + 70);
  sub_80538BC(a1 + 54, a2);
  sub_8052768(a1 + 72);
  sub_805256A();
  sub_8079C84();
  dword_8185C10 = (void *)(sub_8079C94(0) - 20);
  sub_8053A80((int)(a1 + 54));
  sub_8053200((int)(a1 + 72));
  sub_8054D08();
  dword_8185C10 = (char *)dword_8185C10 + 20;
  v2 = sub_8079C94(0);
  n = 4 * ((signed int)(v2 - (_DWORD)dword_8185C10) >> 2);
  dword_8185C0C = -858993459 * ((signed int)(v2 - (_DWORD)dword_8185C10) >> 2) + 1;
  v4 = (char *)sub_8052556(20 * (-858993459 * ((signed int)(v2 - (_DWORD)dword_8185C10) >> 2) + 1));
  memcpy(v4 + 20, dword_8185C10, n);
  dword_8185C10 = v4;
  return sub_805258A();
}
// 8185C0C: using guessed type int dword_8185C0C;

//----- (08054B6C) --------------------------------------------------------
void *__cdecl sub_8054B6C(char *s, int a2)
{
  size_t v2; // eax
  void *result; // eax
  _DWORD *v4; // [esp+10h] [ebp-8h]

  sub_80AA83E(&dest, 0, 0x110u);
  sub_80AA83E(&dword_8185CF4, 0, 0xCu);
  v2 = strlen(s);
  dest = (char *)sub_8052556(v2 + 1);
  strcpy(dest, s);
  v4 = sub_8051C66(0, &dword_8185CEC);
  dword_8185CFC = (int)v4;
  sub_80525E0(v4 + 2);
  sub_8053B7E(dword_8185CFC, v4 + 10);
  sub_8054A26(v4, a2);
  sub_8053354(v4 + 52);
  sub_8053E0E(v4 + 58);
  sub_8053EC2(v4 + 60);
  sub_8053FC0(v4 + 62);
  sub_8054220(v4 + 64);
  sub_805448C(v4 + 66);
  sub_805461E(v4 + 68);
  if ( (_BYTE)a2 )
  {
    sub_8054936(v4 + 74);
  }
  else if ( v4[74] )
  {
    Com_Error(1, "In single player, do not compile the bsp with visibility", 21);
  }
  result = sub_80548DC(v4 + 76);
  dword_8185CFC = 0;
  return result;
}
// 8185CEC: using guessed type int dword_8185CEC;
// 8185CF4: using guessed type int dword_8185CF4;
// 8185CFC: using guessed type int dword_8185CFC;

//----- (08054D08) --------------------------------------------------------
int sub_8054D08()
{
  char *v0; // eax
  int result; // eax

  dword_8185C7C = dword_8185C60 + 48 * (unsigned __int16)word_8185C5C;
  *(_DWORD *)(dword_8185C7C + 28) = 0;
  *(_DWORD *)(dword_8185C7C + 32) = 0;
  *(_DWORD *)(dword_8185C7C + 12) = -1;
  dword_8185CA0 = -1;
  dword_8185CA4 = 0;
  sub_805508A(&unk_8185CA8, 2139095039, 2139095039, 2139095039);
  sub_805508A(&unk_8185CB4, -8388609, -8388609, -8388609);
  *(_WORD *)(dword_8185C7C + 36) = -1;
  *(_WORD *)(dword_8185C7C + 38) = -1;
  *(_WORD *)(dword_8185C7C + 40) = -1;
  *(_WORD *)(dword_8185C7C + 42) = -1;
  *(_WORD *)(dword_8185C7C + 44) = -1;
  *(_WORD *)(dword_8185C7C + 46) = -1;
  v0 = (char *)sub_8052728();
  dword_8185CC0 = -858993459 * ((v0 - (_BYTE *)dword_8185C10) >> 2);
  *((_WORD *)v0 + 1) = 1;
  *((_DWORD *)v0 + 2) = dword_8185C18 + 2 * dword_8185C14;
  result = (unsigned __int16)word_8185C5C;
  *(_WORD *)(dword_8185C18 + 2 * dword_8185C14) = word_8185C5C;
  return result;
}
// 8185C14: using guessed type int dword_8185C14;
// 8185C18: using guessed type int dword_8185C18;
// 8185C5C: using guessed type __int16 word_8185C5C;
// 8185C60: using guessed type int dword_8185C60;
// 8185C7C: using guessed type int dword_8185C7C;
// 8185CA0: using guessed type int dword_8185CA0;
// 8185CA4: using guessed type int dword_8185CA4;
// 8185CC0: using guessed type int dword_8185CC0;

//----- (08054E4A) --------------------------------------------------------
void Com_CleanupBsp()
{
  dword_8185CFC = 0;
}
// 8185CFC: using guessed type int dword_8185CFC;

//----- (08054E72) --------------------------------------------------------
size_t __cdecl sub_8054E72(int a1, _DWORD *a2)
{
  int v2; // eax
  size_t v4; // [esp+10h] [ebp-158h]
  size_t size; // [esp+14h] [ebp-154h]
  int v6; // [esp+18h] [ebp-150h]
  unsigned int i; // [esp+1Ch] [ebp-14Ch]
  int v8[2]; // [esp+20h] [ebp-148h]
  int v9; // [esp+28h] [ebp-140h]
  int v10[79]; // [esp+2Ch] [ebp-13Ch]

  FS_FOpenFileRead((int)dest, &v6, 0);
  if ( !v6 )
    Com_Error(1, aExeErrCouldntL_0, dest);
  FS_Read((int)v8, 0x140u, v6);
  for ( i = 0; i <= 0x4F; ++i )
  {
    v2 = sub_8055168(v8[i]);
    v8[i] = v2;
  }
  size = *(&v9 + 2 * a1);
  if ( size )
  {
    sub_809E580(v6, v10[2 * a1] - 320, 0);
    dword_8185D00 = Hunk_AllocateTempMemory(size);
    FS_Read((int)dword_8185D00, size, v6);
    FS_FCloseFile(v6);
    *a2 = dword_8185D00;
    v4 = size;
  }
  else
  {
    FS_FCloseFile(v6);
    v4 = 0;
  }
  return v4;
}
// 8054E72: using guessed type int var_148[2];
// 8054E72: using guessed type int var_13C[79];

//----- (08054FE2) --------------------------------------------------------
void sub_8054FE2()
{
  sub_80AA0C8(dword_8185D00);
}

//----- (08054FF8) --------------------------------------------------------
long double __cdecl sub_8054FF8(float a1)
{
  return (float)fabs(a1);
}

//----- (08055012) --------------------------------------------------------
void __cdecl sub_8055012(float a1, float a2)
{
  float v2; // ST00_4

  v2 = a1 - a2;
  sub_8055184(v2, a1, a2);
}

//----- (08055036) --------------------------------------------------------
void __cdecl sub_8055036(float a1, float a2)
{
  float v2; // ST00_4

  v2 = a2 - a1;
  sub_8055184(v2, a1, a2);
}

//----- (0805505A) --------------------------------------------------------
int __cdecl sub_805505A(int a1, int a2)
{
  return sub_80551CE(a2 - a1, a1, a2);
}

//----- (08055080) --------------------------------------------------------
int __cdecl sub_8055080(int a1)
{
  return *(_DWORD *)a1;
}

//----- (0805508A) --------------------------------------------------------
int __cdecl sub_805508A(_DWORD *a1, int a2, int a3, int a4)
{
  int result; // eax

  *a1 = a2;
  a1[1] = a3;
  result = a4;
  a1[2] = a4;
  return result;
}

//----- (080550AE) --------------------------------------------------------
int __cdecl sub_80550AE(_DWORD *a1, _DWORD *a2)
{
  int result; // eax

  *a2 = *a1;
  a2[1] = a1[1];
  result = a1[2];
  a2[2] = result;
  return result;
}

//----- (080550DE) --------------------------------------------------------
int __cdecl sub_80550DE(int a1, float a2, int a3)
{
  int result; // eax

  *(float *)a3 = a2 * *(float *)a1;
  *(float *)(a3 + 4) = a2 * *(float *)(a1 + 4);
  result = a1 + 8;
  *(float *)(a3 + 8) = a2 * *(float *)(a1 + 8);
  return result;
}

//----- (08055116) --------------------------------------------------------
void __cdecl sub_8055116(float *a1)
{
  float v1; // ST00_4

  v1 = *a1 * *a1 + a1[1] * a1[1] + a1[2] * a1[2];
  sub_80551AE(v1);
}

//----- (08055154) --------------------------------------------------------
int __cdecl sub_8055154(__int16 a1)
{
  return a1;
}

//----- (08055168) --------------------------------------------------------
int __cdecl sub_8055168(int a1)
{
  return a1;
}

//----- (08055170) --------------------------------------------------------
void __cdecl sub_8055170(float a1)
{
  sub_80551EE(a1);
}

//----- (08055184) --------------------------------------------------------
long double __cdecl sub_8055184(float a1, float a2, float a3)
{
  float v4; // [esp+0h] [ebp-4h]

  if ( a1 < 0.0 )
    v4 = a3;
  else
    v4 = a2;
  return v4;
}

//----- (080551AE) --------------------------------------------------------
long double __cdecl sub_80551AE(float a1)
{
  return (float)sqrt(a1);
}

//----- (080551CE) --------------------------------------------------------
int __cdecl sub_80551CE(int a1, int a2, int a3)
{
  int v4; // [esp+0h] [ebp-4h]

  if ( a1 < 0 )
    v4 = a3;
  else
    v4 = a2;
  return v4;
}

//----- (080551EE) --------------------------------------------------------
long double __cdecl sub_80551EE(float a1)
{
  return a1;
}

//----- (08055200) --------------------------------------------------------
_BOOL4 __cdecl sub_8055200(int a1, float *a2, float *a3)
{
  long double v3; // fst7
  long double v4; // fst7
  long double v5; // fst7
  float v6; // ST00_4
  long double v7; // fst7
  float v8; // ST00_4
  long double v9; // fst7
  float v10; // ST00_4
  long double v11; // fst7
  float v14; // [esp+20h] [ebp-28h]
  float v15; // [esp+24h] [ebp-24h]
  float v16; // [esp+28h] [ebp-20h]
  float v17; // [esp+30h] [ebp-18h]
  float v18; // [esp+34h] [ebp-14h]
  float v19; // [esp+38h] [ebp-10h]

  sub_8056016((float *)(a1 + 56), a2, &v17);
  sub_8055FD2(a3, (float *)(a1 + 92), &v14);
  v3 = sub_8055F88(v17);
  if ( v3 > v14 + *(float *)(a1 + 80) )
    return 1;
  v4 = sub_8055F88(v18);
  if ( v4 > v15 + *(float *)(a1 + 84) )
    return 1;
  v5 = sub_8055F88(v19);
  if ( v5 > v16 + *(float *)(a1 + 88) )
    return 1;
  if ( *(_DWORD *)(a1 + 136) )
    return 0;
  v6 = *(float *)(a1 + 72) * v19 - *(float *)(a1 + 76) * v18;
  v7 = sub_8055F88(v6);
  if ( v7 > v15 * *(float *)(a1 + 88) + v16 * *(float *)(a1 + 84) )
    return 1;
  v8 = *(float *)(a1 + 76) * v17 - *(float *)(a1 + 68) * v19;
  v9 = sub_8055F88(v8);
  if ( v9 > v16 * *(float *)(a1 + 80) + v14 * *(float *)(a1 + 88) )
    return 1;
  v10 = *(float *)(a1 + 68) * v18 - *(float *)(a1 + 72) * v17;
  v11 = sub_8055F88(v10);
  return v11 > v14 * *(float *)(a1 + 84) + v15 * *(float *)(a1 + 80);
}

//----- (080553B2) --------------------------------------------------------
void __cdecl sub_80553B2(int a1, float *a2, int a3)
{
  float v3; // ST3C_4
  float v4; // ST00_4
  float v5; // ST2C_4
  int v6; // [esp+1Ch] [ebp-ACh]
  int v7; // [esp+20h] [ebp-A8h]
  int v8; // [esp+24h] [ebp-A4h]
  float v9; // [esp+28h] [ebp-A0h]
  float v10; // [esp+30h] [ebp-98h]
  float v11; // [esp+34h] [ebp-94h]
  float v12; // [esp+38h] [ebp-90h]
  int v13; // [esp+40h] [ebp-88h]
  float v14; // [esp+48h] [ebp-80h]
  float v15; // [esp+5Ch] [ebp-6Ch]
  float v16; // [esp+60h] [ebp-68h]
  float v17; // [esp+64h] [ebp-64h]
  float v18; // [esp+68h] [ebp-60h]
  int v19; // [esp+6Ch] [ebp-5Ch]
  float v20; // [esp+70h] [ebp-58h]
  int v21; // [esp+74h] [ebp-54h]
  float v22; // [esp+78h] [ebp-50h]
  float v23; // [esp+7Ch] [ebp-4Ch]
  int v24; // [esp+80h] [ebp-48h]
  int v25; // [esp+94h] [ebp-34h]
  float v26; // [esp+98h] [ebp-30h]
  float v27; // [esp+9Ch] [ebp-2Ch]
  int v28; // [esp+A0h] [ebp-28h]
  int i; // [esp+BCh] [ebp-Ch]

  v9 = *(float *)(a1 + 144);
  if ( a2[2] < 0.0 )
    HIBYTE(v9) ^= 0x80u;
  sub_8055FA2((_DWORD *)a1, &v13);
  v14 = v14 - v9;
  v17 = *(float *)(a1 + 140);
  v12 = sub_80560AE((float *)&v13, a2) - a2[3];
  if ( v12 < (long double)v17 )
  {
    LODWORD(v18) = LODWORD(v17) ^ 0x80000000;
    if ( COERCE_FLOAT(LODWORD(v17) ^ 0x80000000) < (long double)v12 )
    {
      v25 = 0;
      sub_805605A((int)&v13, COERCE_FLOAT(LODWORD(v12) ^ 0x80000000), (int)a2, (int)&v28);
      v27 = sub_80560AE((float *)&v28, a2 + 4) - a2[7];
      v26 = sub_80560AE((float *)&v28, a2 + 8) - a2[11];
      v8 = v25;
      if ( v27 + v26 > 1.0 )
        v8 = v25 | 1;
      v25 = v8;
      v7 = v8;
      if ( v27 < 0.0 )
        v7 = v8 | 2;
      v25 = v7;
      v6 = v7;
      if ( v26 < 0.0 )
        v6 = v7 | 4;
      v25 = v6;
      if ( v6 )
      {
        for ( i = 0; i <= 2; ++i )
        {
          if ( (v25 >> i) & 1 )
          {
            v22 = a2[i + 15];
            if ( v22 >= 0.0 )
            {
              v21 = dword_8185C30 + 48 * LODWORD(v22);
              sub_8056016((float *)&v13, (float *)(dword_8185C30 + 48 * LODWORD(v22)), (float *)&v24);
              v23 = sub_80560AE((float *)&v24, (float *)(v21 + 36));
              v4 = v23 - 0.5;
              if ( sub_8055F88(v4) <= 0.5 )
              {
                v5 = sub_80560E2((float *)(v21 + 36));
                v23 = v23 / v5;
                sub_805605A((int)&v24, COERCE_FLOAT(LODWORD(v23) ^ 0x80000000), v21 + 36, (int)&v24);
                if ( *(float *)(a1 + 140) * *(float *)(a1 + 140) > sub_80560E2((float *)&v24) )
                {
                  *(_BYTE *)(a3 + 35) = 1;
                  *(_BYTE *)(a3 + 34) = 1;
                  *(_DWORD *)a3 = 0;
                  return;
                }
              }
            }
          }
          else
          {
            v20 = a2[i + 12];
            if ( v20 >= 0.0 )
            {
              v19 = dword_8185C28 + 12 * LODWORD(v20);
              sub_8056016((float *)&v13, (float *)(dword_8185C28 + 12 * LODWORD(v20)), (float *)&v24);
              if ( *(float *)(a1 + 140) * *(float *)(a1 + 140) > sub_80560E2((float *)&v24) )
              {
                *(_BYTE *)(a3 + 35) = 1;
                *(_BYTE *)(a3 + 34) = 1;
                *(_DWORD *)a3 = 0;
                return;
              }
            }
          }
        }
      }
      else
      {
        *(_BYTE *)(a3 + 35) = 1;
        *(_BYTE *)(a3 + 34) = 1;
        *(_DWORD *)a3 = 0;
      }
    }
    else
    {
      v3 = v9 + v9;
      v15 = v3 * a2[2] + v12;
      if ( v18 < (long double)v15 )
      {
        v16 = (v18 - v12) / a2[2];
        v11 = sub_80560AE((float *)&v13, a2 + 4) - a2[7];
        v10 = sub_80560AE((float *)&v13, a2 + 8) - a2[11];
        v27 = v16 * a2[6] + v11;
        if ( v27 < 0.0 || (v26 = v16 * a2[10] + v10, v26 < 0.0) || v27 + v26 > 1.0 )
        {
          if ( v17 <= (long double)v15 )
            v16 = (v17 - v12) / a2[2];
          else
            v16 = v9 + v9;
          v27 = v16 * a2[6] + v11;
          if ( v27 >= 0.0 )
          {
            v26 = v16 * a2[10] + v10;
            if ( v26 >= 0.0 && v27 + v26 <= 1.0 )
            {
              *(_BYTE *)(a3 + 35) = 1;
              *(_BYTE *)(a3 + 34) = 1;
              *(_DWORD *)a3 = 0;
            }
          }
        }
        else
        {
          *(_BYTE *)(a3 + 35) = 1;
          *(_BYTE *)(a3 + 34) = 1;
          *(_DWORD *)a3 = 0;
        }
      }
    }
  }
}
// 8185C28: using guessed type int dword_8185C28;
// 8185C30: using guessed type int dword_8185C30;

//----- (080558EC) --------------------------------------------------------
void __cdecl sub_80558EC(int a1, int a2, int a3)
{
  int v3; // [esp+18h] [ebp-20h]
  signed int i; // [esp+1Ch] [ebp-1Ch]
  signed int j; // [esp+1Ch] [ebp-1Ch]
  signed int k; // [esp+20h] [ebp-18h]
  __int16 v7; // [esp+26h] [ebp-12h]
  unsigned __int8 *v8; // [esp+28h] [ebp-10h]
  int v9; // [esp+2Ch] [ebp-Ch]
  int v10; // [esp+30h] [ebp-8h]
  signed int v11; // [esp+34h] [ebp-4h]

  if ( !(unsigned __int8)sub_8055200(a1, (float *)a2, (float *)(a2 + 12)) )
  {
    if ( *(_WORD *)(a2 + 26) )
    {
      v11 = 0;
      v10 = dword_8185C50 + 32 * *(_DWORD *)(a2 + 28);
      while ( v11 < *(unsigned __int16 *)(a2 + 26) )
      {
        sub_80558EC(a1, v10, a3);
        ++v11;
        v10 += 32;
      }
    }
    else
    {
      v9 = *(_DWORD *)(a2 + 28);
      v7 = *(_WORD *)(a1 + 160);
      if ( *(unsigned __int16 *)(*(_DWORD *)(a1 + 172) + 2 * v9) != v7 )
      {
        *(_WORD *)(*(_DWORD *)(a1 + 172) + 2 * v9) = v7;
        v8 = (unsigned __int8 *)(dword_8185C48 + 12 * v9);
        if ( *(_DWORD *)(a1 + 132) )
        {
          for ( i = 0; i < *v8; ++i )
            sub_8056116((float *)a1, (float *)(*((_DWORD *)v8 + 1) + 72 * i), a3);
        }
        else
        {
          for ( j = 0; j < *v8; ++j )
          {
            v3 = *((_DWORD *)v8 + 1) + 72 * j;
            sub_805628C(a1, v3, *(float *)(a1 + 144), a3);
            if ( *(float *)(v3 + 8) < 0.0 )
              sub_805628C(a1, v3, COERCE_FLOAT(*(_DWORD *)(a1 + 144) ^ 0x80000000), a3);
          }
          if ( (*(float *)(a1 + 36) != 0.0 || *(float *)(a1 + 40) != 0.0) && *(float *)(a1 + 144) != 0.0 )
          {
            for ( k = 0; k < v8[1]; ++k )
              sub_8056E42((float *)a1, *((_DWORD *)v8 + 2) + 28 * k, a3);
          }
        }
      }
    }
  }
}
// 8185C48: using guessed type int dword_8185C48;
// 8185C50: using guessed type int dword_8185C50;

//----- (08055B48) --------------------------------------------------------
int __cdecl sub_8055B48(int a1, int a2, int a3)
{
  int result; // eax
  int j; // [esp+10h] [ebp-18h]
  __int16 v5; // [esp+16h] [ebp-12h]
  unsigned __int8 *v6; // [esp+18h] [ebp-10h]
  int v7; // [esp+1Ch] [ebp-Ch]
  int i; // [esp+20h] [ebp-8h]
  int v9; // [esp+24h] [ebp-4h]

  result = sub_8055200(a1, (float *)a2, (float *)(a2 + 12));
  if ( !(_BYTE)result )
  {
    if ( *(_WORD *)(a2 + 26) )
    {
      v9 = 0;
      for ( i = dword_8185C50 + 32 * *(_DWORD *)(a2 + 28); ; i += 32 )
      {
        result = *(unsigned __int16 *)(a2 + 26);
        if ( v9 >= result )
          break;
        sub_8055B48(a1, i, a3);
        ++v9;
      }
    }
    else
    {
      v7 = *(_DWORD *)(a2 + 28);
      v5 = *(_WORD *)(a1 + 160);
      result = v5;
      if ( *(unsigned __int16 *)(*(_DWORD *)(a1 + 172) + 2 * v7) != v5 )
      {
        *(_WORD *)(*(_DWORD *)(a1 + 172) + 2 * v7) = v5;
        v6 = (unsigned __int8 *)(dword_8185C48 + 12 * v7);
        for ( j = 0; ; ++j )
        {
          result = *v6;
          if ( j >= result )
            break;
          sub_80553B2(a1, (float *)(*((_DWORD *)v6 + 1) + 72 * j), a3);
        }
      }
    }
  }
  return result;
}
// 8185C48: using guessed type int dword_8185C48;
// 8185C50: using guessed type int dword_8185C50;

//----- (08055C74) --------------------------------------------------------
void __cdecl sub_8055C74(int a1, int a2, int a3)
{
  float v3; // ST14_4
  char *v4; // [esp+10h] [ebp-8h]

  v4 = (char *)dword_8185BF0 + 72 * *(unsigned __int16 *)(a2 + 24);
  if ( *(_DWORD *)(a1 + 128) & *((_DWORD *)v4 + 17) )
  {
    v3 = *(float *)a3;
    sub_80558EC(a1, a2, a3);
    if ( v3 > (long double)*(float *)a3 )
    {
      *(_DWORD *)(a3 + 16) = *((_DWORD *)v4 + 16);
      *(_DWORD *)(a3 + 20) = *((_DWORD *)v4 + 17);
      *(_DWORD *)(a3 + 24) = v4;
    }
  }
}

//----- (08055CFE) --------------------------------------------------------
void __cdecl sub_8055CFE(int a1, int a2, int a3)
{
  if ( *(_DWORD *)(a1 + 128) & *((_DWORD *)dword_8185BF0 + 18 * *(unsigned __int16 *)(a2 + 24) + 17) )
    sub_8055C74(a1, a2, a3);
}

//----- (08055D4C) --------------------------------------------------------
signed int __cdecl sub_8055D4C(int a1, unsigned __int16 *a2, int a3)
{
  signed int result; // eax
  int v4; // [esp+Ch] [ebp-Ch]
  char *v5; // [esp+10h] [ebp-8h]
  signed int i; // [esp+14h] [ebp-4h]

  for ( i = 0; ; ++i )
  {
    result = a2[1];
    if ( i >= result )
      break;
    v4 = dword_8185C50 + 32 * (i + *a2);
    v5 = (char *)dword_8185BF0 + 72 * *(unsigned __int16 *)(v4 + 24);
    if ( *(_DWORD *)(a1 + 128) & *((_DWORD *)v5 + 17) )
    {
      sub_8055B48(a1, v4, a3);
      if ( *(_BYTE *)(a3 + 34) )
      {
        *(_DWORD *)(a3 + 16) = *((_DWORD *)v5 + 16);
        *(_DWORD *)(a3 + 20) = *((_DWORD *)v5 + 17);
        result = (signed int)v5;
        *(_DWORD *)(a3 + 24) = v5;
        return result;
      }
    }
  }
  return result;
}
// 8185C50: using guessed type int dword_8185C50;

//----- (08055E02) --------------------------------------------------------
signed int __cdecl sub_8055E02(float *a1, float *a2, float *a3, float *a4, float *a5, float *a6, float *a7, float *a8)
{
  float v10; // [esp+1Ch] [ebp-6Ch]
  char v11; // [esp+20h] [ebp-68h]
  char v12; // [esp+30h] [ebp-58h]
  char v13; // [esp+40h] [ebp-48h]
  char v14; // [esp+50h] [ebp-38h]
  char v15; // [esp+60h] [ebp-28h]
  float v16; // [esp+78h] [ebp-10h]
  float v17; // [esp+7Ch] [ebp-Ch]

  sub_8056016(a4, a3, (float *)&v15);
  sub_8056016(a5, a3, (float *)&v14);
  sub_80A1ED8(a2, (float *)&v14, (float *)&v12);
  v10 = sub_80560AE((float *)&v15, (float *)&v12);
  if ( v10 < 0.001 )
    return 0;
  sub_8056016(a1, a3, (float *)&v13);
  v17 = sub_80560AE((float *)&v13, (float *)&v12);
  if ( v17 < 0.0 || v17 > (long double)v10 )
    return 0;
  sub_80A1ED8((float *)&v13, (float *)&v15, (float *)&v11);
  v16 = sub_80560AE(a2, (float *)&v11);
  if ( v16 < 0.0 || v17 + v16 > (long double)v10 )
    return 0;
  *a6 = sub_80560AE((float *)&v14, (float *)&v11) / v10;
  if ( a7 )
    *a7 = v17 / v10;
  if ( a8 )
    *a8 = v16 / v10;
  return 1;
}

//----- (08055F88) --------------------------------------------------------
long double __cdecl sub_8055F88(float a1)
{
  return (float)fabs(a1);
}

//----- (08055FA2) --------------------------------------------------------
int __cdecl sub_8055FA2(_DWORD *a1, _DWORD *a2)
{
  int result; // eax

  *a2 = *a1;
  a2[1] = a1[1];
  result = a1[2];
  a2[2] = result;
  return result;
}

//----- (08055FD2) --------------------------------------------------------
int __cdecl sub_8055FD2(float *a1, float *a2, float *a3)
{
  int result; // eax

  *a3 = *a1 + *a2;
  a3[1] = a1[1] + a2[1];
  result = (int)(a1 + 2);
  a3[2] = a1[2] + a2[2];
  return result;
}

//----- (08056016) --------------------------------------------------------
int __cdecl sub_8056016(float *a1, float *a2, float *a3)
{
  int result; // eax

  *a3 = *a1 - *a2;
  a3[1] = a1[1] - a2[1];
  result = (int)(a1 + 2);
  a3[2] = a1[2] - a2[2];
  return result;
}

//----- (0805605A) --------------------------------------------------------
int __cdecl sub_805605A(int a1, float a2, int a3, int a4)
{
  int result; // eax

  *(float *)a4 = a2 * *(float *)a3 + *(float *)a1;
  *(float *)(a4 + 4) = a2 * *(float *)(a3 + 4) + *(float *)(a1 + 4);
  result = a3 + 8;
  *(float *)(a4 + 8) = a2 * *(float *)(a3 + 8) + *(float *)(a1 + 8);
  return result;
}

//----- (080560AE) --------------------------------------------------------
long double __cdecl sub_80560AE(float *a1, float *a2)
{
  return *a1 * *a2 + a1[1] * a2[1] + a1[2] * a2[2];
}

//----- (080560E2) --------------------------------------------------------
long double __cdecl sub_80560E2(float *a1)
{
  return *a1 * *a1 + a1[1] * a1[1] + a1[2] * a1[2];
}

//----- (08056116) --------------------------------------------------------
void __cdecl sub_8056116(float *a1, float *a2, int a3)
{
  long double v3; // fst7
  float v4; // [esp+18h] [ebp-30h]
  float v5; // [esp+1Ch] [ebp-2Ch]
  int v6; // [esp+20h] [ebp-28h]
  float v7; // [esp+30h] [ebp-18h]
  float v8; // [esp+34h] [ebp-14h]
  float v9; // [esp+38h] [ebp-10h]
  float v10; // [esp+3Ch] [ebp-Ch]

  v9 = sub_80560AE(a1 + 3, a2) - a2[3];
  if ( v9 < 0.0 )
  {
    v10 = sub_80560AE(a1, a2) - a2[3];
    if ( v10 > 0.0 )
    {
      v3 = (v10 - 0.125) / (v10 - v9);
      v8 = v3;
      sub_80573BC(v8, 0.0);
      v8 = v3;
      if ( v8 < (long double)*(float *)a3 )
      {
        v7 = v10 / (v10 - v9);
        sub_805605A((int)a1, v7, (int)(a1 + 9), (int)&v6);
        v5 = sub_80560AE((float *)&v6, a2 + 4) - a2[7];
        if ( v5 >= -0.001 && v5 <= 1.001 )
        {
          v4 = sub_80560AE((float *)&v6, a2 + 8) - a2[11];
          if ( v4 >= -0.001 && v5 + v4 <= 1.001 )
          {
            *(float *)a3 = v8;
            sub_8055FA2(a2, (_DWORD *)(a3 + 4));
          }
        }
      }
    }
  }
}

//----- (0805628C) --------------------------------------------------------
void __cdecl sub_805628C(int a1, int a2, float a3, int a4)
{
  float v4; // ST28_4
  long double v5; // fst6
  float v6; // ST00_4
  long double v7; // fst7
  float v8; // ST00_4
  long double v9; // fst7
  float v10; // ST04_4
  int v11; // [esp+14h] [ebp-D4h]
  int v12; // [esp+18h] [ebp-D0h]
  float v13; // [esp+1Ch] [ebp-CCh]
  float v14; // [esp+20h] [ebp-C8h]
  float v15; // [esp+24h] [ebp-C4h]
  float v16; // [esp+2Ch] [ebp-BCh]
  float v17[2]; // [esp+30h] [ebp-B8h]
  float v18; // [esp+38h] [ebp-B0h]
  int v19; // [esp+40h] [ebp-A8h]
  float v20; // [esp+48h] [ebp-A0h]
  int v21; // [esp+50h] [ebp-98h]
  int v22; // [esp+54h] [ebp-94h]
  float *v23; // [esp+58h] [ebp-90h]
  int v24; // [esp+5Ch] [ebp-8Ch]
  float v25; // [esp+60h] [ebp-88h]
  float v26; // [esp+64h] [ebp-84h]
  float v27; // [esp+68h] [ebp-80h]
  float v28; // [esp+6Ch] [ebp-7Ch]
  float v29; // [esp+70h] [ebp-78h]
  float v30; // [esp+74h] [ebp-74h]
  float v31; // [esp+78h] [ebp-70h]
  float v32; // [esp+80h] [ebp-68h]
  float v33; // [esp+84h] [ebp-64h]
  int v34; // [esp+90h] [ebp-58h]
  float v35; // [esp+A0h] [ebp-48h]
  int v36; // [esp+A4h] [ebp-44h]
  float v37; // [esp+A8h] [ebp-40h]
  float v38; // [esp+ACh] [ebp-3Ch]
  float v39; // [esp+B0h] [ebp-38h]
  float v40; // [esp+B4h] [ebp-34h]
  float v41; // [esp+B8h] [ebp-30h]
  float v42; // [esp+C8h] [ebp-20h]
  float v43; // [esp+CCh] [ebp-1Ch]
  float v44; // [esp+D0h] [ebp-18h]
  float v45; // [esp+D4h] [ebp-14h]
  float v46; // [esp+D8h] [ebp-10h]
  int i; // [esp+DCh] [ebp-Ch]

  sub_8055FA2((_DWORD *)(a1 + 12), v17);
  v18 = v18 - a3;
  v45 = *(float *)(a1 + 140) + 0.125;
  v43 = sub_80560AE(v17, (float *)a2) - *(float *)(a2 + 12);
  if ( v43 < (long double)v45 )
  {
    sub_8055FA2((_DWORD *)a1, &v19);
    v20 = v20 - a3;
    v44 = sub_80560AE((float *)&v19, (float *)a2) - *(float *)(a2 + 12);
    v13 = v44 - v43;
    if ( v13 > 0.000099999997 )
    {
      LODWORD(v46) = LODWORD(v45) ^ 0x80000000;
      if ( COERCE_FLOAT(LODWORD(v45) ^ 0x80000000) < (long double)v44 )
      {
        if ( v44 - v45 > 0.0 )
        {
          v42 = (v44 - v45) / v13;
          if ( v42 > (long double)*(float *)a4 )
            return;
          sub_805605A((int)&v19, v42, a1 + 36, (int)&v39);
        }
        else
        {
          v42 = 0.0;
          sub_8055FA2(&v19, &v39);
        }
        v38 = sub_80560AE(&v39, (float *)(a2 + 16)) - *(float *)(a2 + 28);
        v37 = sub_80560AE(&v39, (float *)(a2 + 32)) - *(float *)(a2 + 44);
        v5 = v38 + v37;
        v36 = v5 > 1.0;
        v12 = v5 > 1.0;
        if ( v38 < 0.0 )
          v12 |= 2u;
        v36 = v12;
        v11 = v12;
        if ( v37 < 0.0 )
          v11 = v12 | 4;
        v36 = v11;
        if ( v11 )
        {
          for ( i = 0; i <= 2; ++i )
          {
            if ( (v36 >> i) & 1 )
            {
              v24 = *(_DWORD *)(a2 + 4 * i + 60);
              if ( v24 >= 0 && *(_DWORD *)(*(_DWORD *)(a1 + 164) + 4 * v24) != *(_DWORD *)(a1 + 160) )
              {
                *(_DWORD *)(*(_DWORD *)(a1 + 164) + 4 * v24) = *(_DWORD *)(a1 + 160);
                v23 = (float *)(dword_8185C30 + 48 * v24);
                sub_8056016((float *)&v19, (float *)(dword_8185C30 + 48 * v24), (float *)&v34);
                v29 = sub_80560AE((float *)&v34, v23 + 3);
                v30 = sub_80560AE((float *)&v34, v23 + 6);
                v32 = sub_80560AE((float *)(a1 + 36), v23 + 3);
                v33 = sub_80560AE((float *)(a1 + 36), v23 + 6);
                v26 = sub_805740C(&v32, &v29);
                if ( v26 < 0.0 )
                {
                  v35 = sub_805740C(&v29, &v29);
                  v25 = v35 - v45 * v45;
                  if ( v25 > 0.0 )
                  {
                    v27 = sub_805742E(&v32);
                    v28 = v26 * v26 - v27 * v25;
                    if ( v28 > 0.0 )
                    {
                      v7 = sub_805739C(v28);
                      v42 = (-v7 - v26) / v27;
                      if ( *(float *)a4 > (long double)v42 )
                      {
                        sub_805605A((int)&v34, v42, a1 + 36, (int)&v34);
                        v41 = sub_80560AE((float *)&v34, v23 + 9);
                        v8 = v41 - 0.5;
                        if ( sub_8055F88(v8) <= 0.5 )
                        {
                          v39 = (v42 * v32 + v29) / v45;
                          v40 = (v42 * v33 + v30) / v45;
                          sub_8057474((int)(v23 + 3), v39, a4 + 4);
                          sub_805605A(a4 + 4, v40, (int)(v23 + 6), a4 + 4);
                          if ( *(float *)(a2 + 8) >= 0.69999999
                            && *(float *)(a4 + 12) >= 0.0
                            && *(float *)(a4 + 12) < 0.69999999
                            && v20 > (long double)v18 )
                          {
                            sub_8055FA2((_DWORD *)a2, (_DWORD *)(a4 + 4));
                          }
                          *(float *)a4 = v42;
                        }
                      }
                    }
                  }
                  else
                  {
                    v31 = sub_80560AE((float *)&v34, v23 + 9);
                    v6 = v31 - 0.5;
                    if ( sub_8055F88(v6) <= 0.5 )
                    {
                      sub_8057474((int)(v23 + 3), v29, a4 + 4);
                      sub_805605A(a4 + 4, v30, (int)(v23 + 6), a4 + 4);
                      sub_80A20C0((float *)(a4 + 4));
                      if ( *(float *)(a2 + 8) >= 0.69999999
                        && *(float *)(a4 + 12) >= 0.0
                        && *(float *)(a4 + 12) < 0.69999999
                        && v20 > (long double)v18 )
                      {
                        sub_8055FA2((_DWORD *)a2, (_DWORD *)(a4 + 4));
                      }
                      *(_DWORD *)a4 = 0;
                      if ( *(float *)(a1 + 140) * *(float *)(a1 + 140) > (long double)v35 )
                        *(_BYTE *)(a4 + 35) = 1;
                      return;
                    }
                  }
                }
              }
            }
            else
            {
              v22 = *(_DWORD *)(a2 + 4 * i + 48);
              if ( v22 >= 0 && *(_DWORD *)(*(_DWORD *)(a1 + 168) + 4 * v22) != *(_DWORD *)(a1 + 160) )
              {
                *(_DWORD *)(*(_DWORD *)(a1 + 168) + 4 * v22) = *(_DWORD *)(a1 + 160);
                v21 = dword_8185C28 + 12 * v22;
                sub_8056016((float *)&v19, (float *)(dword_8185C28 + 12 * v22), (float *)&v34);
                v26 = sub_80560AE((float *)(a1 + 36), (float *)&v34);
                if ( v26 < 0.0 )
                {
                  v35 = sub_80560AE((float *)&v34, (float *)&v34);
                  v25 = v35 - v45 * v45;
                  if ( v25 <= 0.0 )
                  {
                    v42 = 1.0 / sub_805739C(v35);
                    sub_8057474((int)&v34, v42, a4 + 4);
                    if ( *(float *)(a2 + 8) >= 0.69999999
                      && *(float *)(a4 + 12) >= 0.0
                      && *(float *)(a4 + 12) < 0.69999999
                      && v20 > (long double)v18 )
                    {
                      sub_8055FA2((_DWORD *)a2, (_DWORD *)(a4 + 4));
                    }
                    *(_DWORD *)a4 = 0;
                    if ( *(float *)(a1 + 140) * *(float *)(a1 + 140) > (long double)v35 )
                      *(_BYTE *)(a4 + 35) = 1;
                    return;
                  }
                  v27 = *(float *)(a1 + 52);
                  v28 = v26 * v26 - v27 * v25;
                  if ( v28 >= 0.0 )
                  {
                    v9 = sub_805739C(v28);
                    v42 = (-v9 - v26) / v27;
                    if ( *(float *)a4 > (long double)v42 )
                    {
                      sub_805605A((int)&v34, v42, a1 + 36, a4 + 4);
                      v10 = 1.0 / v45;
                      sub_8057474(a4 + 4, v10, a4 + 4);
                      if ( *(float *)(a2 + 8) >= 0.69999999
                        && *(float *)(a4 + 12) >= 0.0
                        && *(float *)(a4 + 12) < 0.69999999
                        && v20 > (long double)v18 )
                      {
                        sub_8055FA2((_DWORD *)a2, (_DWORD *)(a4 + 4));
                      }
                      *(float *)a4 = v42;
                    }
                  }
                }
              }
            }
          }
        }
        else
        {
          sub_8055FA2((_DWORD *)a2, (_DWORD *)(a4 + 4));
          *(float *)a4 = v42;
          if ( *(float *)(a1 + 140) > (long double)v44 )
            *(_BYTE *)(a4 + 35) = 1;
        }
      }
      else
      {
        v4 = a3 + a3;
        v16 = v4 * *(float *)(a2 + 8) + v44;
        if ( v46 < (long double)v16 )
        {
          v42 = (v46 - v44) / *(float *)(a2 + 8);
          v15 = sub_80560AE((float *)&v19, (float *)(a2 + 16)) - *(float *)(a2 + 28);
          v14 = sub_80560AE((float *)&v19, (float *)(a2 + 32)) - *(float *)(a2 + 44);
          v38 = v42 * *(float *)(a2 + 24) + v15;
          if ( v38 < 0.0 || (v37 = v42 * *(float *)(a2 + 40) + v14, v37 < 0.0) || v38 + v37 > 1.0 )
          {
            if ( v45 <= (long double)v16 )
              v42 = (v45 - v44) / *(float *)(a2 + 8);
            else
              v42 = a3 + a3;
            v38 = v42 * *(float *)(a2 + 24) + v15;
            if ( v38 >= 0.0 )
            {
              v37 = v42 * *(float *)(a2 + 40) + v14;
              if ( v37 >= 0.0 && v38 + v37 <= 1.0 )
              {
                sub_8055FA2((_DWORD *)a2, (_DWORD *)(a4 + 4));
                *(_DWORD *)a4 = 0;
                *(_BYTE *)(a4 + 35) = 1;
              }
            }
          }
          else
          {
            sub_8055FA2((_DWORD *)a2, (_DWORD *)(a4 + 4));
            *(_DWORD *)a4 = 0;
            *(_BYTE *)(a4 + 35) = 1;
          }
        }
      }
    }
  }
}
// 8185C28: using guessed type int dword_8185C28;
// 8185C30: using guessed type int dword_8185C30;

//----- (08056E42) --------------------------------------------------------
void __cdecl sub_8056E42(float *a1, int a2, int a3)
{
  float v3; // ST00_4
  float v4; // ST2C_4
  float v5; // ST00_4
  float v6; // ST28_4
  float v7; // ST00_4
  float v8; // [esp+30h] [ebp-68h]
  float v9; // [esp+34h] [ebp-64h]
  float v10; // [esp+38h] [ebp-60h]
  float v11; // [esp+40h] [ebp-58h]
  float v12; // [esp+44h] [ebp-54h]
  float v13; // [esp+48h] [ebp-50h]
  float v14; // [esp+4Ch] [ebp-4Ch]
  char v15; // [esp+50h] [ebp-48h]
  float v16; // [esp+5Ch] [ebp-3Ch]
  int v17; // [esp+60h] [ebp-38h]
  float v18; // [esp+64h] [ebp-34h]
  float v19; // [esp+68h] [ebp-30h]
  float v20; // [esp+7Ch] [ebp-1Ch]
  float v21; // [esp+80h] [ebp-18h]
  float v22; // [esp+84h] [ebp-14h]
  float v23; // [esp+88h] [ebp-10h]
  float v24; // [esp+8Ch] [ebp-Ch]

  v22 = sub_805740C(a1 + 9, (float *)a2);
  if ( v22 >= 0.0 )
    return;
  v24 = a1[35] + 0.125;
  v23 = sub_805740C(a1, (float *)a2) - *(float *)(a2 + 8);
  v21 = (v24 - v23) / v22;
  if ( v21 >= (long double)*(float *)a3 || -v24 > v21 * a1[12] )
    return;
  sub_805605A((int)a1, v21, (int)(a1 + 9), (int)&v17);
  v20 = *(float *)(a2 + 4) * *(float *)&v17 - *(float *)a2 * v18 - *(float *)(a2 + 20);
  if ( v20 < 0.0 )
  {
    v8 = *(float *)(a2 + 4) * *(float *)(a2 + 20) + *(float *)a2 * *(float *)(a2 + 8);
    v9 = *(float *)(a2 + 4) * *(float *)(a2 + 8) - *(float *)a2 * *(float *)(a2 + 20);
    sub_80573E0(a1, &v8, (float *)&v15);
    v14 = sub_805740C(a1 + 9, (float *)&v15);
    if ( v14 >= 0.0 )
      return;
    v13 = sub_805740C((float *)&v15, (float *)&v15);
    v11 = v13 - v24 * v24;
    if ( v11 < 0.0 )
    {
      v10 = *(float *)(a2 + 12);
      v3 = v10 - a1[2];
      if ( sub_8055F88(v3) <= a1[36] )
      {
        sub_8057450((_DWORD *)(a3 + 4), *(_DWORD *)a2, *(_DWORD *)(a2 + 4), 0);
        *(_DWORD *)a3 = 0;
        if ( a1[35] * a1[35] > (long double)v13 )
          *(_BYTE *)(a3 + 35) = 1;
      }
      return;
    }
    v12 = v14 * v14 - a1[13] * v11;
    if ( v12 < 0.0 )
      return;
    LODWORD(v4) = LODWORD(v14) ^ 0x80000000;
    v21 = (v4 - sub_805739C(v12)) / a1[13];
    if ( v21 >= (long double)*(float *)a3 || v21 <= 0.0 )
      return;
    sub_805605A((int)a1, v21, (int)(a1 + 9), (int)&v17);
    v20 = 0.0;
    goto LABEL_26;
  }
  if ( v20 <= (long double)*(float *)(a2 + 24) )
  {
    if ( v21 < 0.0 )
      v21 = 0.0;
LABEL_26:
    v16 = v20 * *(float *)(a2 + 16) + *(float *)(a2 + 12);
    v7 = v19 - v16;
    if ( sub_8055F88(v7) <= a1[36] )
    {
      *(float *)a3 = v21;
      sub_8057450((_DWORD *)(a3 + 4), *(_DWORD *)a2, *(_DWORD *)(a2 + 4), 0);
    }
    return;
  }
  v8 = (*(float *)(a2 + 20) + *(float *)(a2 + 24)) * *(float *)(a2 + 4) + *(float *)a2 * *(float *)(a2 + 8);
  v9 = *(float *)(a2 + 4) * *(float *)(a2 + 8) - (*(float *)(a2 + 20) + *(float *)(a2 + 24)) * *(float *)a2;
  sub_80573E0(a1, &v8, (float *)&v15);
  v14 = sub_805740C(a1 + 9, (float *)&v15);
  if ( v14 >= 0.0 )
    return;
  v13 = sub_805740C((float *)&v15, (float *)&v15);
  v11 = v13 - v24 * v24;
  if ( v11 >= 0.0 )
  {
    v12 = v14 * v14 - a1[13] * v11;
    if ( v12 < 0.0 )
      return;
    LODWORD(v6) = LODWORD(v14) ^ 0x80000000;
    v21 = (v6 - sub_805739C(v12)) / a1[13];
    if ( v21 >= (long double)*(float *)a3 || v21 <= 0.0 )
      return;
    sub_805605A((int)a1, v21, (int)(a1 + 9), (int)&v17);
    v20 = *(float *)(a2 + 24);
    goto LABEL_26;
  }
  v10 = *(float *)(a2 + 16) * *(float *)(a2 + 24) + *(float *)(a2 + 12);
  v5 = a1[2] - v10;
  if ( sub_8055F88(v5) <= a1[36] )
  {
    sub_8057450((_DWORD *)(a3 + 4), *(_DWORD *)a2, *(_DWORD *)(a2 + 4), 0);
    *(_DWORD *)a3 = 0;
    if ( a1[35] * a1[35] > (long double)v13 )
      *(_BYTE *)(a3 + 35) = 1;
  }
}

//----- (0805739C) --------------------------------------------------------
long double __cdecl sub_805739C(float a1)
{
  return (float)sqrt(a1);
}

//----- (080573BC) --------------------------------------------------------
void __cdecl sub_80573BC(float a1, float a2)
{
  float v2; // ST00_4

  v2 = a1 - a2;
  sub_80574AC(v2, a1, a2);
}

//----- (080573E0) --------------------------------------------------------
int __cdecl sub_80573E0(float *a1, float *a2, float *a3)
{
  int result; // eax

  *a3 = *a1 - *a2;
  result = (int)(a1 + 1);
  a3[1] = a1[1] - a2[1];
  return result;
}

//----- (0805740C) --------------------------------------------------------
long double __cdecl sub_805740C(float *a1, float *a2)
{
  return *a1 * *a2 + a1[1] * a2[1];
}

//----- (0805742E) --------------------------------------------------------
long double __cdecl sub_805742E(float *a1)
{
  return *a1 * *a1 + a1[1] * a1[1];
}

//----- (08057450) --------------------------------------------------------
int __cdecl sub_8057450(_DWORD *a1, int a2, int a3, int a4)
{
  int result; // eax

  *a1 = a2;
  a1[1] = a3;
  result = a4;
  a1[2] = a4;
  return result;
}

//----- (08057474) --------------------------------------------------------
int __cdecl sub_8057474(int a1, float a2, int a3)
{
  int result; // eax

  *(float *)a3 = a2 * *(float *)a1;
  *(float *)(a3 + 4) = a2 * *(float *)(a1 + 4);
  result = a1 + 8;
  *(float *)(a3 + 8) = a2 * *(float *)(a1 + 8);
  return result;
}

//----- (080574AC) --------------------------------------------------------
long double __cdecl sub_80574AC(float a1, float a2, float a3)
{
  float v4; // [esp+0h] [ebp-4h]

  if ( a1 < 0.0 )
    v4 = a3;
  else
    v4 = a2;
  return v4;
}

//----- (080574D8) --------------------------------------------------------
void *__cdecl sub_80574D8(int a1)
{
  if ( ++dword_8185D0C > dword_8185D10 )
    dword_8185D10 = dword_8185D0C;
  return Z_MallocInternal(12 * a1 + 4);
}
// 8185D0C: using guessed type int dword_8185D0C;
// 8185D10: using guessed type int dword_8185D10;

//----- (08057520) --------------------------------------------------------
void __cdecl sub_8057520(void *ptr)
{
  if ( *(_DWORD *)ptr == -559030611 )
    Com_Error(0, &byte_813B860);
  *(_DWORD *)ptr = -559030611;
  --dword_8185D0C;
  Z_FreeInternal(ptr);
}
// 8185D0C: using guessed type int dword_8185D0C;

//----- (08057656) --------------------------------------------------------
float *__cdecl sub_8057656(int a1, float a2)
{
  float *v2; // ST1C_4
  int v4; // [esp+20h] [ebp-48h]
  int v5; // [esp+28h] [ebp-40h]
  int v6; // [esp+30h] [ebp-38h]
  int v7; // [esp+40h] [ebp-28h]
  float v8; // [esp+50h] [ebp-18h]
  float v9; // [esp+54h] [ebp-14h]
  int v10; // [esp+58h] [ebp-10h]
  int i; // [esp+5Ch] [ebp-Ch]

  v9 = -131072.0;
  v10 = -1;
  for ( i = 0; i <= 2; ++i )
  {
    v8 = sub_8057DB2(*(float *)(a1 + 4 * i));
    if ( v8 > (long double)v9 )
    {
      v10 = i;
      v9 = v8;
    }
  }
  if ( v10 == -1 )
    Com_Error(1, &byte_813B8A0);
  sub_8057DCC(&unk_8145E68, &v4);
  if ( v10 >= 0 )
  {
    if ( v10 <= 1 )
    {
      v5 = 1065353216;
    }
    else if ( v10 == 2 )
    {
      v4 = 1065353216;
    }
  }
  v8 = sub_8057F10((float *)&v4, (float *)a1);
  sub_8057EBC((int)&v4, COERCE_FLOAT(LODWORD(v8) ^ 0x80000000), a1, (int)&v4);
  sub_80A2298((float *)&v4, (int)&v4);
  sub_8057E84(a1, a2, (int)&v7);
  sub_80A1ED8((float *)&v4, (float *)a1, (float *)&v6);
  sub_8057E84((int)&v4, 131072.0, (int)&v4);
  sub_8057E84((int)&v6, 131072.0, (int)&v6);
  v2 = (float *)sub_80574D8(4);
  sub_8057E40((float *)&v7, (float *)&v6, v2 + 1);
  sub_8057DFC(v2 + 1, (float *)&v4, v2 + 1);
  sub_8057DFC((float *)&v7, (float *)&v6, v2 + 4);
  sub_8057DFC(v2 + 4, (float *)&v4, v2 + 4);
  sub_8057DFC((float *)&v7, (float *)&v6, v2 + 7);
  sub_8057E40(v2 + 7, (float *)&v4, v2 + 7);
  sub_8057E40((float *)&v7, (float *)&v6, v2 + 10);
  sub_8057E40(v2 + 10, (float *)&v4, v2 + 10);
  *(_DWORD *)v2 = 4;
  return v2;
}

//----- (080578D2) --------------------------------------------------------
void *__cdecl sub_80578D2(void *src)
{
  void *dest; // ST10_4

  dest = sub_80574D8(*(_DWORD *)src);
  Com_Memcpy(dest, src, 12 * *(_DWORD *)src + 4);
  return dest;
}

//----- (0805791A) --------------------------------------------------------
int *__cdecl sub_805791A(int a1, int a2, float a3, float a4)
{
  int *result; // eax
  int v5; // [esp+28h] [ebp-280h]
  int *v6; // [esp+2Ch] [ebp-27Ch]
  int v7[4]; // [esp+30h] [ebp-278h]
  char *v8; // [esp+40h] [ebp-268h]
  _DWORD *v9; // [esp+44h] [ebp-264h]
  int j; // [esp+48h] [ebp-260h]
  int i; // [esp+4Ch] [ebp-25Ch]
  int v12; // [esp+50h] [ebp-258h]
  int v13; // [esp+54h] [ebp-254h]
  int v14; // [esp+58h] [ebp-250h]
  int v15; // [esp+60h] [ebp-248h]
  int v16[67]; // [esp+64h] [ebp-244h]
  int *v17; // [esp+170h] [ebp-138h]
  float v18[70]; // [esp+174h] [ebp-134h]
  void *ptr; // [esp+28Ch] [ebp-1Ch]

  ptr = *(void **)a1;
  v14 = 0;
  v13 = 0;
  v12 = 0;
  for ( i = 0; i < *(_DWORD *)ptr; ++i )
  {
    flt_8185D14 = sub_8057F10((float *)ptr + 3 * i + 1, (float *)a2);
    flt_8185D14 = flt_8185D14 - a3;
    (&v17)[i] = (int *)LODWORD(flt_8185D14);
    if ( flt_8185D14 <= (long double)a4 )
    {
      if ( -a4 <= (long double)flt_8185D14 )
        *(&v15 + i) = 2;
      else
        *(&v15 + i) = 1;
    }
    else
    {
      *(&v15 + i) = 0;
    }
    ++*(&v12 + *(&v15 + i));
  }
  *(&v15 + i) = v15;
  result = v17;
  (&v17)[i] = v17;
  if ( v12 )
  {
    if ( v13 )
    {
      v5 = *(_DWORD *)ptr + 4;
      v6 = (int *)sub_80574D8(v5);
      for ( i = 0; i < *(_DWORD *)ptr; ++i )
      {
        v9 = (char *)ptr + 12 * i + 4;
        if ( *(&v15 + i) == 2 )
        {
          sub_8057DCC(v9, &v6[3 * *v6 + 1]);
          ++*v6;
        }
        else
        {
          if ( !*(&v15 + i) )
          {
            sub_8057DCC(v9, &v6[3 * *v6 + 1]);
            ++*v6;
          }
          if ( v16[i] != 2 && v16[i] != *(&v15 + i) )
          {
            v8 = (char *)ptr + 12 * ((i + 1) % *(_DWORD *)ptr) + 4;
            flt_8185D14 = *(float *)&(&v17)[i] / (*(float *)&(&v17)[i] - v18[i]);
            for ( j = 0; j <= 2; ++j )
            {
              if ( *(float *)(a2 + 4 * j) == 1.0 )
              {
                *(float *)&v7[j] = a3;
              }
              else if ( *(float *)(a2 + 4 * j) == -1.0 )
              {
                v7[j] = LODWORD(a3) ^ 0x80000000;
              }
              else
              {
                *(float *)&v7[j] = (*(float *)&v8[4 * j] - *(float *)&v9[j]) * flt_8185D14 + *(float *)&v9[j];
              }
            }
            sub_8057DCC(v7, &v6[3 * *v6 + 1]);
            ++*v6;
          }
        }
      }
      if ( *v6 > v5 )
        Com_Error(1, &byte_813B8E0);
      if ( *v6 > 64 )
        Com_Error(1, &byte_813B920);
      sub_8057520(ptr);
      result = v6;
      *(_DWORD *)a1 = v6;
    }
  }
  else
  {
    sub_8057520(ptr);
    result = (int *)a1;
    *(_DWORD *)a1 = 0;
  }
  return result;
}
// 8185D14: using guessed type float flt_8185D14;
// 805791A: using guessed type int var_244[67];
// 805791A: using guessed type float var_134[70];
// 805791A: using guessed type int var_278[4];

//----- (08057DB2) --------------------------------------------------------
long double __cdecl sub_8057DB2(float a1)
{
  return (float)fabs(a1);
}

//----- (08057DCC) --------------------------------------------------------
int __cdecl sub_8057DCC(_DWORD *a1, _DWORD *a2)
{
  int result; // eax

  *a2 = *a1;
  a2[1] = a1[1];
  result = a1[2];
  a2[2] = result;
  return result;
}

//----- (08057DFC) --------------------------------------------------------
int __cdecl sub_8057DFC(float *a1, float *a2, float *a3)
{
  int result; // eax

  *a3 = *a1 + *a2;
  a3[1] = a1[1] + a2[1];
  result = (int)(a1 + 2);
  a3[2] = a1[2] + a2[2];
  return result;
}

//----- (08057E40) --------------------------------------------------------
int __cdecl sub_8057E40(float *a1, float *a2, float *a3)
{
  int result; // eax

  *a3 = *a1 - *a2;
  a3[1] = a1[1] - a2[1];
  result = (int)(a1 + 2);
  a3[2] = a1[2] - a2[2];
  return result;
}

//----- (08057E84) --------------------------------------------------------
int __cdecl sub_8057E84(int a1, float a2, int a3)
{
  int result; // eax

  *(float *)a3 = a2 * *(float *)a1;
  *(float *)(a3 + 4) = a2 * *(float *)(a1 + 4);
  result = a1 + 8;
  *(float *)(a3 + 8) = a2 * *(float *)(a1 + 8);
  return result;
}

//----- (08057EBC) --------------------------------------------------------
int __cdecl sub_8057EBC(int a1, float a2, int a3, int a4)
{
  int result; // eax

  *(float *)a4 = a2 * *(float *)a3 + *(float *)a1;
  *(float *)(a4 + 4) = a2 * *(float *)(a3 + 4) + *(float *)(a1 + 4);
  result = a3 + 8;
  *(float *)(a4 + 8) = a2 * *(float *)(a3 + 8) + *(float *)(a1 + 8);
  return result;
}

//----- (08057F10) --------------------------------------------------------
long double __cdecl sub_8057F10(float *a1, float *a2)
{
  return *a1 * *a2 + a1[1] * a2[1] + a1[2] * a2[2];
}

//----- (08057F44) --------------------------------------------------------
void *__cdecl sub_8057F44(size_t a1)
{
  return Hunk_AllocInternal(a1);
}

//----- (08057F58) --------------------------------------------------------
void *__cdecl sub_8057F58(size_t a1)
{
  return Hunk_AllocInternal(a1);
}

//----- (08057F6C) --------------------------------------------------------
int __cdecl sub_8057F6C(char *s2)
{
  return sub_80C3264(s2, (int)sub_8057F44, (int)sub_8057F58);
}

//----- (08057F90) --------------------------------------------------------
signed int __cdecl sub_8057F90(int a1, int a2, float *a3, float *a4, int a5)
{
  int v5; // eax
  signed int result; // eax
  float v7[4]; // [esp+20h] [ebp-58h]
  char v8; // [esp+30h] [ebp-48h]
  char v9; // [esp+40h] [ebp-38h]
  char v10; // [esp+50h] [ebp-28h]
  int v11; // [esp+6Ch] [ebp-Ch]

  sub_8058192(a3, (float *)(a1 + 8), (float *)&v8);
  sub_80A4E52((float *)&v8, (float *)(a1 + 20), (float *)&v9);
  sub_8058192(a4, (float *)(a1 + 8), (float *)&v8);
  sub_80A4E52((float *)&v8, (float *)(a1 + 20), (float *)&v10);
  v5 = sub_80C54DC(*(_DWORD **)(a1 + 4));
  v11 = v5;
  result = sub_80C33FE(*(_DWORD *)(a1 + 4), a2, v5, (float *)&v9, (float *)&v10, a5);
  if ( result >= 0 )
  {
    *(_WORD *)(a2 + 28) = 1022;
    sub_80A5028((float *)(a2 + 4), (float *)(a1 + 20), v7);
    sub_80A20C0(v7);
    result = sub_8058162(v7, (_DWORD *)(a2 + 4));
  }
  return result;
}

//----- (0805809A) --------------------------------------------------------
unsigned int __cdecl sub_805809A(int a1, float *a2, float *a3, int a4)
{
  int v5; // [esp+20h] [ebp-78h]
  char v6; // [esp+50h] [ebp-48h]
  char v7; // [esp+60h] [ebp-38h]
  char v8; // [esp+70h] [ebp-28h]
  int v9; // [esp+8Ch] [ebp-Ch]

  sub_8058192(a2, (float *)(a1 + 8), (float *)&v6);
  sub_80A4E52((float *)&v6, (float *)(a1 + 20), (float *)&v7);
  sub_8058192(a3, (float *)(a1 + 8), (float *)&v6);
  sub_80A4E52((float *)&v6, (float *)(a1 + 20), (float *)&v8);
  v5 = 1065353216;
  v9 = sub_80C54DC(*(_DWORD **)(a1 + 4));
  return (unsigned int)sub_80C33FE(*(_DWORD *)(a1 + 4), (int)&v5, v9, (float *)&v7, (float *)&v8, a4) >> 31;
}

//----- (08058162) --------------------------------------------------------
int __cdecl sub_8058162(_DWORD *a1, _DWORD *a2)
{
  int result; // eax

  *a2 = *a1;
  a2[1] = a1[1];
  result = a1[2];
  a2[2] = result;
  return result;
}

//----- (08058192) --------------------------------------------------------
int __cdecl sub_8058192(float *a1, float *a2, float *a3)
{
  int result; // eax

  *a3 = *a1 - *a2;
  a3[1] = a1[1] - a2[1];
  result = (int)(a1 + 2);
  a3[2] = a1[2] - a2[2];
  return result;
}

//----- (080581D8) --------------------------------------------------------
signed int __cdecl sub_80581D8(int a1, float *a2, float *a3, float *a4)
{
  signed int result; // eax
  int v5; // [esp+10h] [ebp-38h]
  int v6; // [esp+1Ch] [ebp-2Ch]
  int v7; // [esp+28h] [ebp-20h]

  sub_80588E0(a2, (_DWORD *)(a1 + 8));
  sub_80A7146(a3, (int)&v5);
  sub_8058954((int)&v5, *a4, (int)&v5);
  sub_8058954((int)&v6, a4[1], (int)&v6);
  sub_8058954((int)&v7, a4[2], (int)&v7);
  sub_80A45BE((float *)&v5, (float *)(a1 + 20));
  result = sub_80C501A(*(_DWORD *)(a1 + 4), (float *)&v5, (_DWORD *)(a1 + 56), (_DWORD *)(a1 + 68));
  if ( result )
  {
    sub_8058910((float *)(a1 + 56), a2, (float *)(a1 + 56));
    result = sub_8058910((float *)(a1 + 68), a2, (float *)(a1 + 68));
  }
  return result;
}

//----- (080582EC) --------------------------------------------------------
signed int __cdecl sub_80582EC(int a1, char *a2, float *a3, float *a4, float *a5)
{
  int v5; // eax

  if ( !a2 || !*a2 )
    Com_Error(1, &byte_813B960);
  if ( *a5 == 0.0 )
    Com_Error(1, &byte_813B980, a2);
  if ( a5[1] == 0.0 )
    Com_Error(1, &byte_813B9C0, a2);
  if ( a5[2] == 0.0 )
    Com_Error(1, &byte_813BA00, a2);
  v5 = sub_8057F6C(a2);
  if ( !v5 )
    return 0;
  *(_DWORD *)(a1 + 4) = v5;
  sub_80581D8(a1, a3, a4, a5);
  return 1;
}

//----- (080583FA) --------------------------------------------------------
char *sub_80583FA()
{
  char *result; // eax
  int v1; // [esp+28h] [ebp-110h]
  signed int v2; // [esp+2Ch] [ebp-10Ch]
  signed int v3; // [esp+2Ch] [ebp-10Ch]
  float v4; // [esp+30h] [ebp-108h]
  float v5; // [esp+34h] [ebp-104h]
  float v6; // [esp+38h] [ebp-100h]
  int v7; // [esp+40h] [ebp-F8h]
  int v8; // [esp+44h] [ebp-F4h]
  int v9; // [esp+48h] [ebp-F0h]
  int v10; // [esp+50h] [ebp-E8h]
  int v11; // [esp+54h] [ebp-E4h]
  int v12; // [esp+58h] [ebp-E0h]
  char s1; // [esp+60h] [ebp-D8h]
  char dest; // [esp+A0h] [ebp-98h]
  char v15; // [esp+E0h] [ebp-58h]
  char v16; // [esp+E7h] [ebp-51h]
  void *v17; // [esp+128h] [ebp-10h]
  char *src; // [esp+12Ch] [ebp-Ch]

  v17 = dword_8185C78;
  dword_8185BE4 = 0;
  dword_8185BE8 = 0;
  while ( 1 )
  {
    result = Com_Parse((char **)&v17);
    src = result;
    if ( !v17 )
      break;
    result = src;
    if ( *src != 123 )
      break;
    v15 = 0;
    v2 = 0;
    while ( 1 )
    {
      src = Com_Parse((char **)&v17);
      if ( !v17 )
        break;
      if ( *src == 125 )
        break;
      strcpy(&dest, src);
      src = Com_Parse((char **)&v17);
      if ( !v17 )
        break;
      strcpy(&s1, src);
      if ( !strcasecmp(&dest, "classname") )
      {
        if ( !strcasecmp(&s1, "misc_model") )
          v2 = 1;
      }
      else if ( !strcasecmp(&dest, "model") )
      {
        strcpy(&v15, &s1);
      }
    }
    if ( v2 && (unsigned __int8)sub_80C3820(&v15) )
      ++dword_8185BE4;
  }
  if ( dword_8185BE4 )
  {
    dword_8185BE8 = (int)sub_8052556(80 * dword_8185BE4);
    v17 = dword_8185C78;
    v1 = 0;
    while ( 1 )
    {
      result = Com_Parse((char **)&v17);
      src = result;
      if ( !v17 )
        break;
      result = src;
      if ( *src != 123 )
        break;
      v15 = 0;
      v12 = 0;
      v11 = 0;
      v10 = 0;
      v9 = 0;
      v8 = 0;
      v7 = 0;
      v6 = 1.0;
      v5 = 1.0;
      v4 = 1.0;
      v3 = 0;
      while ( 1 )
      {
        src = Com_Parse((char **)&v17);
        if ( !v17 )
          break;
        if ( *src == 125 )
          break;
        strcpy(&dest, src);
        src = Com_Parse((char **)&v17);
        if ( !v17 )
          break;
        strcpy(&s1, src);
        if ( !strcasecmp(&dest, "classname") )
        {
          if ( !strcasecmp(&s1, "misc_model") )
            v3 = 1;
        }
        else if ( !strcasecmp(&dest, "model") )
        {
          strcpy(&v15, &s1);
        }
        else if ( !strcasecmp(&dest, "origin") )
        {
          sscanf(&s1, "%f %f %f", &v10, &v11, &v12);
        }
        else if ( !strcasecmp(&dest, "angles") )
        {
          sscanf(&s1, "%f %f %f", &v7, &v8, &v9);
        }
        else if ( !strcasecmp(&dest, "modelscale_vec") )
        {
          sscanf(&s1, "%f %f %f", &v4, &v5, &v6);
        }
        else if ( !strcasecmp(&dest, "modelscale") )
        {
          v6 = atof(&s1);
          v5 = v6;
          v4 = v6;
        }
      }
      if ( v3 && (unsigned __int8)sub_80C3820(&v15) )
      {
        if ( (unsigned __int8)sub_80582EC(dword_8185BE8 + 80 * v1, &v16, (float *)&v10, (float *)&v7, &v4) )
          ++v1;
        else
          --dword_8185BE4;
      }
    }
  }
  return result;
}
// 8185BE4: using guessed type int dword_8185BE4;
// 8185BE8: using guessed type int dword_8185BE8;

//----- (080588E0) --------------------------------------------------------
int __cdecl sub_80588E0(_DWORD *a1, _DWORD *a2)
{
  int result; // eax

  *a2 = *a1;
  a2[1] = a1[1];
  result = a1[2];
  a2[2] = result;
  return result;
}

//----- (08058910) --------------------------------------------------------
int __cdecl sub_8058910(float *a1, float *a2, float *a3)
{
  int result; // eax

  *a3 = *a1 + *a2;
  a3[1] = a1[1] + a2[1];
  result = (int)(a1 + 2);
  a3[2] = a1[2] + a2[2];
  return result;
}

//----- (08058954) --------------------------------------------------------
int __cdecl sub_8058954(int a1, float a2, int a3)
{
  int result; // eax

  *(float *)a3 = a2 * *(float *)a1;
  *(float *)(a3 + 4) = a2 * *(float *)(a1 + 4);
  result = a1 + 8;
  *(float *)(a3 + 8) = a2 * *(float *)(a1 + 8);
  return result;
}

//----- (0805898C) --------------------------------------------------------
int __cdecl sub_805898C(float *a1, int a2)
{
  int v3; // [esp+Ch] [ebp-Ch]
  int v4; // [esp+10h] [ebp-8h]
  float v5; // [esp+14h] [ebp-4h]

  while ( a2 >= 0 )
  {
    v4 = dword_8185C00 + 8 * a2;
    v3 = *(_DWORD *)(dword_8185C00 + 8 * a2);
    if ( *(_BYTE *)(v3 + 16) > 2u )
      v5 = sub_8059038((float *)v3, a1) - *(float *)(v3 + 12);
    else
      v5 = a1[*(unsigned __int8 *)(v3 + 16)] - *(float *)(v3 + 12);
    if ( v5 >= 0.0 )
      a2 = *(signed __int16 *)(v4 + 4);
    else
      a2 = *(signed __int16 *)(v4 + 6);
  }
  return -1 - a2;
}
// 8185C00: using guessed type int dword_8185C00;

//----- (08058A2C) --------------------------------------------------------
int __cdecl sub_8058A2C(float *a1)
{
  return sub_805898C(a1, 0);
}

//----- (08058A48) --------------------------------------------------------
int __cdecl sub_8058A48(_DWORD *a1, int a2)
{
  int result; // eax
  int v3; // [esp+0h] [ebp-8h]

  v3 = -1 - a2;
  if ( *(_WORD *)(dword_8185C08 + 44 * (-1 - a2) + 40) != -1 )
    a1[10] = v3;
  if ( *a1 < a1[1] )
  {
    result = -1 - a2;
    *(_DWORD *)(a1[3] + 4 * (*a1)++) = v3;
  }
  else
  {
    result = (int)a1;
    a1[2] = 1;
  }
  return result;
}
// 8185C08: using guessed type int dword_8185C08;

//----- (08058ABE) --------------------------------------------------------
int __cdecl sub_8058ABE(int a1, int a2)
{
  signed int v3; // [esp+Ch] [ebp-Ch]
  int v4; // [esp+10h] [ebp-8h]

  while ( a2 >= 0 )
  {
    v4 = dword_8185C00 + 8 * a2;
    v3 = sub_80A7E1A((float *)(a1 + 16), (float *)(a1 + 28), *(_DWORD *)(dword_8185C00 + 8 * a2));
    if ( v3 == 1 )
    {
      a2 = *(signed __int16 *)(v4 + 4);
    }
    else
    {
      if ( v3 != 2 )
        sub_8058ABE(a1, *(signed __int16 *)(v4 + 4));
      a2 = *(signed __int16 *)(v4 + 6);
    }
  }
  return sub_8058A48((_DWORD *)a1, a2);
}
// 8185C00: using guessed type int dword_8185C00;

//----- (08058B66) --------------------------------------------------------
int __cdecl sub_8058B66(_DWORD *a1, _DWORD *a2, int a3, int a4, _DWORD *a5)
{
  int v6; // [esp+10h] [ebp-38h]
  int v7; // [esp+14h] [ebp-34h]
  int v8; // [esp+18h] [ebp-30h]
  int v9; // [esp+1Ch] [ebp-2Ch]
  int v10; // [esp+20h] [ebp-28h]
  int v11; // [esp+2Ch] [ebp-1Ch]
  int v12; // [esp+38h] [ebp-10h]

  sub_8058FC4(a1, &v10);
  sub_8058FC4(a2, &v11);
  v6 = 0;
  v7 = a4;
  v9 = a3;
  v12 = 0;
  v8 = 0;
  sub_8058ABE((int)&v6, 0);
  *a5 = v12;
  return v6;
}

//----- (08058BD8) --------------------------------------------------------
int __cdecl sub_8058BD8(float *a1, unsigned __int8 *a2)
{
  signed int v3; // [esp+10h] [ebp-28h]
  int v4; // [esp+1Ch] [ebp-1Ch]
  int v5; // [esp+20h] [ebp-18h]
  signed int j; // [esp+24h] [ebp-14h]
  int v7; // [esp+24h] [ebp-14h]
  _DWORD *v8; // [esp+28h] [ebp-10h]
  signed int i; // [esp+30h] [ebp-8h]

  v4 = 0;
  while ( 1 )
  {
    if ( !*((_WORD *)a2 + 1) )
      goto LABEL_19;
    if ( *((_WORD *)a2 + 1) > 0 )
      break;
    v4 |= sub_8058BD8(a1, a2 + 20);
LABEL_19:
    if ( *((float *)a2 + 2) < (long double)a1[*a2] )
      v3 = 0;
    else
      v3 = 2;
    a2 += 20 * *(unsigned __int16 *)&a2[v3 + 16];
  }
  for ( i = 0; i < *((signed __int16 *)a2 + 1); ++i )
  {
    v8 = (_DWORD *)(dword_8185C60 + 48 * *(unsigned __int16 *)(*((_DWORD *)a2 + 2) + 2 * i));
    for ( j = 0; j <= 2; ++j )
    {
      if ( *(float *)&v8[j] > (long double)a1[j] || a1[j] > (long double)*(float *)&v8[j + 4] )
        goto LABEL_16;
    }
    v5 = v8[8];
    v7 = v8[7];
    while ( v7 )
    {
      if ( sub_8059038(a1, (float *)*(_DWORD *)v5) > *(float *)(*(_DWORD *)v5 + 12) )
        goto LABEL_16;
      --v7;
      v5 += 8;
    }
    v4 |= v8[3];
LABEL_16:
    ;
  }
  return v4;
}
// 8185C60: using guessed type int dword_8185C60;

//----- (08058D88) --------------------------------------------------------
int __cdecl sub_8058D88(float *a1, int a2)
{
  signed int i; // [esp+14h] [ebp-14h]
  int v5; // [esp+1Ch] [ebp-Ch]

  if ( a2 )
    v5 = sub_8059154(a2) + 28;
  else
    v5 = dword_8185C08 + 44 * sub_805898C(a1, 0);
  if ( !*(_DWORD *)(v5 + 36) )
    return 0;
  for ( i = 0; i <= 2; ++i )
  {
    if ( *(float *)(v5 + 4 * i + 12) >= (long double)a1[i] )
      return 0;
    if ( a1[i] >= (long double)*(float *)(v5 + 4 * i + 24) )
      return 0;
  }
  return sub_8058BD8(a1, (unsigned __int8 *)dword_8185C10 + 20 * *(_DWORD *)(v5 + 36));
}
// 8185C08: using guessed type int dword_8185C08;

//----- (08058E94) --------------------------------------------------------
int __cdecl sub_8058E94(float *a1, int a2, float *a3, float *a4)
{
  float v4; // ST1C_4
  char v6; // [esp+20h] [ebp-58h]
  char v7; // [esp+30h] [ebp-48h]
  char v8; // [esp+40h] [ebp-38h]
  float v9[4]; // [esp+50h] [ebp-28h]
  float v10; // [esp+60h] [ebp-18h]
  unsigned int v11; // [esp+64h] [ebp-14h]
  float v12; // [esp+68h] [ebp-10h]

  sub_8058FF4(a1, a3, &v10);
  if ( *a4 != 0.0 || a4[1] != 0.0 || a4[2] != 0.0 )
  {
    sub_80A2EC2(a4, (int)&v8, (float *)&v7, (float *)&v6);
    sub_8058FC4(&v10, v9);
    v10 = sub_8059038(v9, (float *)&v8);
    v4 = sub_8059038(v9, (float *)&v7);
    v11 = LODWORD(v4) ^ 0x80000000;
    v12 = sub_8059038(v9, (float *)&v6);
  }
  return sub_8058D88(&v10, a2);
}

//----- (08058F82) --------------------------------------------------------
char *__cdecl sub_8058F82(int a1)
{
  char *v2; // [esp+0h] [ebp-4h]

  if ( a1 >= 0 && a1 < dword_8185C64 && dword_8185C70 )
    v2 = (char *)dword_8185C6C + n * a1;
  else
    v2 = (char *)dword_8185C6C;
  return v2;
}
// 8185C64: using guessed type int dword_8185C64;
// 8185C70: using guessed type int dword_8185C70;

//----- (08058FC4) --------------------------------------------------------
int __cdecl sub_8058FC4(_DWORD *a1, _DWORD *a2)
{
  int result; // eax

  *a2 = *a1;
  a2[1] = a1[1];
  result = a1[2];
  a2[2] = result;
  return result;
}

//----- (08058FF4) --------------------------------------------------------
int __cdecl sub_8058FF4(float *a1, float *a2, float *a3)
{
  int result; // eax

  *a3 = *a1 - *a2;
  a3[1] = a1[1] - a2[1];
  result = (int)(a1 + 2);
  a3[2] = a1[2] - a2[2];
  return result;
}

//----- (08059038) --------------------------------------------------------
long double __cdecl sub_8059038(float *a1, float *a2)
{
  return *a1 * *a2 + a1[1] * a2[1] + a1[2] * a2[2];
}

//----- (0805906C) --------------------------------------------------------
int __cdecl sub_805906C(_DWORD *a1)
{
  _DWORD *v1; // eax
  int result; // eax

  v1 = (_DWORD *)Sys_GetValue(3);
  *a1 = ++*v1;
  a1[1] = v1[1];
  a1[2] = v1[2];
  a1[3] = v1[3];
  a1[4] = v1[4];
  result = v1[5];
  a1[5] = result;
  return result;
}

//----- (080590B0) --------------------------------------------------------
int __cdecl sub_80590B0(_DWORD *a1, _DWORD *a2)
{
  int v2; // eax
  int result; // eax

  v2 = Sys_GetValue(3);
  *a1 = *(_DWORD *)(v2 + 16);
  result = *(_DWORD *)(v2 + 20);
  *a2 = result;
  return result;
}

//----- (080590DE) --------------------------------------------------------
signed int __cdecl sub_80590DE(_DWORD *a1, _DWORD *a2, int a3)
{
  _DWORD *v4; // [esp+10h] [ebp-8h]
  _DWORD *v5; // [esp+14h] [ebp-4h]

  sub_80590B0(&v5, &v4);
  sub_805D45E(a1, v4);
  sub_805D45E(a2, v4 + 3);
  sub_805D45E(a1, v5);
  sub_805D45E(a2, v5 + 4);
  v5[3] = a3;
  return 1023;
}

//----- (08059154) --------------------------------------------------------
int __cdecl sub_8059154(int a1)
{
  int v3; // [esp+10h] [ebp-8h]
  char v4; // [esp+14h] [ebp-4h]

  if ( a1 < dword_8185C54 )
    return dword_8185C58 + 72 * a1;
  sub_80590B0(&v4, &v3);
  return v3;
}
// 8185C54: using guessed type int dword_8185C54;
// 8185C58: using guessed type int dword_8185C58;

//----- (0805919A) --------------------------------------------------------
int __cdecl sub_805919A(int a1)
{
  int v1; // eax

  v1 = sub_8059154(a1);
  return *(_DWORD *)(v1 + 32) | *(_DWORD *)(v1 + 36);
}

//----- (080591BC) --------------------------------------------------------
long double __cdecl sub_80591BC(int a1)
{
  return *(float *)(sub_8059154(a1) + 24);
}

//----- (080591DE) --------------------------------------------------------
int __cdecl sub_80591DE(int a1, float *a2)
{
  long double v2; // fst7
  int result; // eax
  float v4[6]; // [esp+10h] [ebp-18h]

  sub_805D45E((_DWORD *)a1, v4);
  *(float *)a1 = sub_805D554(a2, v4);
  *(float *)(a1 + 4) = sub_805D554(a2 + 3, v4);
  v2 = sub_805D554(a2 + 6, v4);
  result = a1 + 8;
  *(float *)(a1 + 8) = v2;
  return result;
}

//----- (0805924A) --------------------------------------------------------
int *__cdecl sub_805924A(int a1, int a2)
{
  int *result; // eax
  signed int j; // [esp+0h] [ebp-Ch]
  int i; // [esp+4h] [ebp-8h]

  for ( i = 0; i <= 2; ++i )
  {
    for ( j = 0; j <= 2; ++j )
      *(_DWORD *)(a2 + 4 * (j + 3 * i)) = *(_DWORD *)(a1 + 4 * (i + 3 * j));
    result = &i;
  }
  return result;
}

//----- (080592B6) --------------------------------------------------------
unsigned int __cdecl sub_80592B6(float *a1, int a2)
{
  sub_80A2EC2(a1, a2, (float *)(a2 + 12), (float *)(a2 + 24));
  return sub_805D48E((_DWORD *)(a2 + 12));
}

//----- (080592F2) --------------------------------------------------------
void __cdecl sub_80592F2(float *a1, int a2, int a3)
{
  float *v3; // ST20_4
  float v4; // ST00_4
  float v5; // ST10_4
  float v6; // ST1C_4
  float v7; // ST18_4
  float **v8; // [esp+14h] [ebp-14h]
  int v9; // [esp+24h] [ebp-4h]

  if ( a1[26] <= (long double)*(float *)(a2 + 16)
    && a1[27] <= (long double)*(float *)(a2 + 20)
    && a1[28] <= (long double)*(float *)(a2 + 24)
    && *(float *)a2 <= (long double)a1[29]
    && *(float *)(a2 + 4) <= (long double)a1[30]
    && *(float *)(a2 + 8) <= (long double)a1[31] )
  {
    v8 = *(float ***)(a2 + 32);
    v9 = *(_DWORD *)(a2 + 28);
    while ( v9 )
    {
      v3 = *v8;
      v4 = (*v8)[2] * a1[36];
      v5 = sub_805D378(v4);
      v6 = v3[3] + a1[35] + v5;
      v7 = sub_805D554(a1, v3) - v6;
      if ( v7 > 0.0 )
        return;
      --v9;
      v8 += 2;
    }
    *(_BYTE *)(a3 + 34) = 1;
    *(_BYTE *)(a3 + 35) = 1;
    *(_DWORD *)a3 = 0;
    *(_DWORD *)(a3 + 20) = *(_DWORD *)(a2 + 12);
  }
}

//----- (08059432) --------------------------------------------------------
int __cdecl sub_8059432(int a1, unsigned __int8 *a2, int a3)
{
  int result; // eax
  int v4; // [esp+Ch] [ebp-Ch]
  int i; // [esp+14h] [ebp-4h]

  while ( 1 )
  {
    result = *((_DWORD *)a2 + 1) & *(_DWORD *)(a1 + 128);
    if ( !result )
      break;
    if ( *((_WORD *)a2 + 1) )
    {
      if ( *((_WORD *)a2 + 1) > 0 )
      {
        for ( i = 0; ; ++i )
        {
          result = *((signed __int16 *)a2 + 1);
          if ( i >= result )
            break;
          v4 = dword_8185C60 + 48 * *(unsigned __int16 *)(*((_DWORD *)a2 + 2) + 2 * i);
          if ( *(_DWORD *)(v4 + 12) & *(_DWORD *)(a1 + 128) )
          {
            sub_80592F2((float *)a1, v4, a3);
            result = a3;
            if ( *(_BYTE *)(a3 + 34) )
              break;
          }
        }
        return result;
      }
      sub_8059432(a1, a2 + 20, a3);
      result = a3;
      if ( *(_BYTE *)(a3 + 34) )
        return result;
    }
    if ( *(float *)(a1 + 4 * *a2 + 104) <= (long double)*((float *)a2 + 2) )
    {
      if ( *(float *)(a1 + 4 * *a2 + 116) >= (long double)*((float *)a2 + 2) )
      {
        sub_8059432(a1, &a2[20 * *((unsigned __int16 *)a2 + 8)], a3);
        result = a3;
        if ( *(_BYTE *)(a3 + 34) )
          return result;
      }
      a2 += 20 * *((unsigned __int16 *)a2 + 9);
    }
    else
    {
      a2 += 20 * *((unsigned __int16 *)a2 + 8);
    }
  }
  return result;
}
// 8185C60: using guessed type int dword_8185C60;

//----- (080595CA) --------------------------------------------------------
int __cdecl sub_80595CA(int a1, int a2, int a3)
{
  signed int i; // [esp+10h] [ebp-8h]

  for ( i = 0; i <= 2; ++i )
  {
    if ( *(float *)(a2 + 4 * i + 12) >= (long double)*(float *)(a1 + 4 * i + 116) )
      return 0;
    if ( *(float *)(a1 + 4 * i + 104) >= (long double)*(float *)(a2 + 4 * i + 24) )
      return 0;
  }
  sub_8059432(a1, (unsigned __int8 *)dword_8185C10 + 20 * *(_DWORD *)(a2 + 36), a3);
  return *(unsigned __int8 *)(a3 + 34);
}

//----- (08059674) --------------------------------------------------------
int __cdecl sub_8059674(int a1, int a2, int a3)
{
  int result; // eax

  if ( !(*(_DWORD *)(a2 + 4) & *(_DWORD *)(a1 + 128)) || (result = sub_80595CA(a1, a2, a3)) == 0 )
  {
    result = *(_DWORD *)(a2 + 8) & *(_DWORD *)(a1 + 128);
    if ( result )
      result = sub_8055D4C(a1, (unsigned __int16 *)a2, a3);
  }
  return result;
}

//----- (080596DA) --------------------------------------------------------
void __cdecl sub_80596DA(int a1, int a2)
{
  float v2; // ST18_4
  float v3; // ST14_4
  float v4; // [esp+10h] [ebp-B8h]
  float v5; // [esp+1Ch] [ebp-ACh]
  float v6; // [esp+20h] [ebp-A8h]
  float v7[3]; // [esp+30h] [ebp-98h]
  float v8[2]; // [esp+3Ch] [ebp-8Ch]
  float v9; // [esp+44h] [ebp-84h]
  float v10[2]; // [esp+50h] [ebp-78h]
  float v11; // [esp+58h] [ebp-70h]
  char v12; // [esp+60h] [ebp-68h]
  float v13[2]; // [esp+70h] [ebp-58h]
  float v14; // [esp+78h] [ebp-50h]
  float v15[2]; // [esp+80h] [ebp-48h]
  float v16; // [esp+88h] [ebp-40h]
  float v17[2]; // [esp+90h] [ebp-38h]
  float v18; // [esp+98h] [ebp-30h]
  float v19[2]; // [esp+A0h] [ebp-28h]
  float v20; // [esp+A8h] [ebp-20h]
  int i; // [esp+BCh] [ebp-Ch]

  sub_805D45E((_DWORD *)a1, v19);
  v20 = v20 + *(float *)(a1 + 144);
  sub_805D45E((_DWORD *)a1, v17);
  v18 = v18 - *(float *)(a1 + 144);
  for ( i = 0; i <= 2; ++i )
  {
    v10[i] = (*(float *)(*(_DWORD *)(a1 + 180) + 4 * i) + *(float *)(*(_DWORD *)(a1 + 180) + 4 * i + 12)) * 0.5;
    v7[i] = *(float *)(*(_DWORD *)(a1 + 180) + 4 * i) - v10[i];
    v8[i] = *(float *)(*(_DWORD *)(a1 + 180) + 4 * i + 12) - v10[i];
  }
  if ( v8[0] <= (long double)v9 )
    v4 = v8[0];
  else
    v4 = v9;
  v6 = v9 - v4;
  v5 = (*(float *)(a1 + 140) + v4) * (*(float *)(a1 + 140) + v4);
  sub_805D45E(v10, v15);
  v16 = v16 + v6;
  sub_805D510(v15, v19, (float *)&v12);
  if ( v5 > sub_805D5F2((float *)&v12) )
  {
    *(_BYTE *)(a2 + 34) = 1;
    *(_BYTE *)(a2 + 35) = 1;
    *(_DWORD *)a2 = 0;
  }
  sub_805D510(v15, v17, (float *)&v12);
  if ( v5 > sub_805D5F2((float *)&v12) )
  {
    *(_BYTE *)(a2 + 34) = 1;
    *(_BYTE *)(a2 + 35) = 1;
    *(_DWORD *)a2 = 0;
  }
  sub_805D45E(v10, v13);
  v14 = v14 - v6;
  sub_805D510(v13, v19, (float *)&v12);
  if ( v5 > sub_805D5F2((float *)&v12) )
  {
    *(_BYTE *)(a2 + 34) = 1;
    *(_BYTE *)(a2 + 35) = 1;
    *(_DWORD *)a2 = 0;
  }
  sub_805D510(v13, v17, (float *)&v12);
  if ( v5 > sub_805D5F2((float *)&v12) )
  {
    *(_BYTE *)(a2 + 34) = 1;
    *(_BYTE *)(a2 + 35) = 1;
    *(_DWORD *)a2 = 0;
  }
  v2 = *(float *)(a1 + 8) - v11;
  v3 = v6 + *(float *)(a1 + 100) - *(float *)(a1 + 140);
  if ( v3 >= sub_805D378(v2) )
  {
    v16 = 0.0;
    v20 = 0.0;
    sub_805D510(v19, v15, (float *)&v12);
    if ( v5 > sub_805D5F2((float *)&v12) )
    {
      *(_BYTE *)(a2 + 34) = 1;
      *(_BYTE *)(a2 + 35) = 1;
      *(_DWORD *)a2 = 0;
    }
  }
}
// 80596DA: using guessed type float var_78[2];
// 80596DA: using guessed type float var_98[3];
// 80596DA: using guessed type float var_8C[2];

//----- (08059A48) --------------------------------------------------------
int __cdecl sub_8059A48(float *a1, int a2)
{
  int result; // eax
  int v3; // [esp+10h] [ebp-1048h]
  int v4; // [esp+14h] [ebp-1044h]
  int v5; // [esp+18h] [ebp-1040h]
  int *v6; // [esp+1Ch] [ebp-103Ch]
  float v7[3]; // [esp+20h] [ebp-1038h]
  float v8[3]; // [esp+2Ch] [ebp-102Ch]
  int v9; // [esp+38h] [ebp-1020h]
  int i; // [esp+4Ch] [ebp-100Ch]
  int v11[1026]; // [esp+50h] [ebp-1008h]

  result = a2;
  if ( !*(_BYTE *)(a2 + 34) )
  {
    sub_805D510(a1, a1 + 23, v7);
    sub_805D4CC(a1, a1 + 23, v8);
    for ( i = 0; i <= 2; ++i )
    {
      v7[i] = v7[i] - 1.0;
      v8[i] = v8[i] + 1.0;
    }
    v3 = 0;
    v4 = 1024;
    v6 = v11;
    v9 = 0;
    v5 = 0;
    result = sub_8058ABE((int)&v3, 0);
    if ( v3 )
    {
      for ( i = 0; ; ++i )
      {
        result = i;
        if ( i >= v3 )
          break;
        result = a2;
        if ( *(_BYTE *)(a2 + 34) )
          break;
        sub_8059674((int)a1, dword_8185C08 + 44 * v11[i], a2);
      }
    }
  }
  return result;
}
// 8185C08: using guessed type int dword_8185C08;
// 8059A48: using guessed type float var_1038[3];
// 8059A48: using guessed type float var_102C[3];
// 8059A48: using guessed type int var_1008[1026];

//----- (08059BBC) --------------------------------------------------------
void __cdecl sub_8059BBC(float *a1, _DWORD *a2, int a3)
{
  float v3; // ST00_4
  long double v4; // fst7
  long double v5; // fst7
  float v6; // [esp+18h] [ebp-80h]
  float v7; // [esp+18h] [ebp-80h]
  signed int v8; // [esp+1Ch] [ebp-7Ch]
  int v9[10]; // [esp+20h] [ebp-78h]
  int *v10; // [esp+48h] [ebp-50h]
  int v11; // [esp+4Ch] [ebp-4Ch]
  int i; // [esp+50h] [ebp-48h]
  _DWORD *v13; // [esp+54h] [ebp-44h]
  float v14; // [esp+58h] [ebp-40h]
  float v15; // [esp+5Ch] [ebp-3Ch]
  float v16; // [esp+60h] [ebp-38h]
  int **v17; // [esp+64h] [ebp-34h]
  float **v18; // [esp+68h] [ebp-30h]
  float v19; // [esp+6Ch] [ebp-2Ch]
  int v20; // [esp+70h] [ebp-28h]
  float v21; // [esp+74h] [ebp-24h]
  float v22; // [esp+78h] [ebp-20h]
  float v23; // [esp+7Ch] [ebp-1Ch]
  float v24; // [esp+80h] [ebp-18h]
  float v25; // [esp+84h] [ebp-14h]
  float *v26; // [esp+88h] [ebp-10h]
  int v27; // [esp+8Ch] [ebp-Ch]

  v24 = 0.0;
  v23 = *(float *)a3;
  v20 = 1;
  v17 = 0;
  v14 = -1.0;
  v13 = a2;
  v8 = 0;
  while ( 2 )
  {
    for ( i = 0; i <= 2; ++i )
    {
      v22 = (a1[i] - *(float *)&v13[i]) * v14 - a1[i + 37];
      v21 = (a1[i + 3] - *(float *)&v13[i]) * v14 - a1[i + 37];
      if ( v22 <= 0.0 )
      {
        if ( v21 > 0.0 )
        {
          v7 = v22 * a1[i + 6] * v14;
          if ( v24 >= (long double)v7 )
            return;
          v20 = 0;
          sub_805D3EE(v23, v7);
          v23 = v7;
        }
      }
      else
      {
        sub_805D3EE(v22, 0.125);
        if ( v21 >= 0.0 )
          return;
        v6 = (v22 - 0.125) * a1[i + 6] * v14;
        if ( v6 >= (long double)v23 )
          return;
        if ( v21 > 0.0 )
          v20 = 0;
        if ( v6 <= (long double)v24 )
        {
          if ( v17 )
            continue;
        }
        else
        {
          v24 = v6;
        }
        v11 = *((signed __int16 *)a2 + i + 3 * v8 + 18);
        sub_805D434(v9);
        *(float *)&v9[i] = v14;
        v10 = v9;
        v17 = &v10;
      }
    }
    if ( !v8 )
    {
      v14 = 1.0;
      v13 = a2 + 4;
      v8 = 1;
      continue;
    }
    break;
  }
  v18 = (float **)a2[8];
  v27 = a2[7];
  while ( 2 )
  {
    if ( v27 )
    {
      v26 = *v18;
      v3 = v26[2] * a1[36];
      v16 = sub_805D378(v3);
      v25 = v26[3] + a1[35] + v16;
      v4 = sub_805D554(a1, v26);
      v22 = v4 - v25;
      v5 = sub_805D554(a1 + 3, v26);
      v21 = v5 - v25;
      if ( v22 <= 0.0 )
      {
        if ( v21 > 0.0 )
        {
          v15 = v22 - v21;
          if ( v22 > v23 * v15 )
          {
            v23 = v22 / v15;
            if ( v24 >= (long double)v23 )
              return;
          }
          v20 = 0;
        }
      }
      else
      {
        sub_805D3EE(v22, 0.125);
        if ( v21 >= 0.0 )
          return;
        if ( v21 > 0.0 )
          v20 = 0;
        v15 = v22 - v21;
        v19 = v22 - 0.125;
        if ( v19 <= v24 * v15 )
        {
          if ( !v17 )
            goto LABEL_29;
        }
        else
        {
          v24 = v19 / v15;
          if ( v24 >= (long double)v23 )
            return;
LABEL_29:
          v17 = (int **)v18;
        }
      }
      --v27;
      v18 += 2;
      continue;
    }
    break;
  }
  *(_DWORD *)(a3 + 20) = a2[3];
  if ( v17 )
  {
    *(float *)a3 = v24;
    sub_805D45E(*v17, (_DWORD *)(a3 + 4));
    *(_DWORD *)(a3 + 16) = *((_DWORD *)dword_8185BF0 + 18 * (_DWORD)v17[1] + 16);
    *(_DWORD *)(a3 + 24) = (char *)dword_8185BF0 + 72 * (_DWORD)v17[1];
  }
  else
  {
    *(_BYTE *)(a3 + 35) = 1;
    if ( v20 )
    {
      *(_BYTE *)(a3 + 34) = 1;
      *(_DWORD *)a3 = 0;
    }
  }
}
// 8059BBC: using guessed type int var_78[10];

//----- (08059FDC) --------------------------------------------------------
void __cdecl sub_8059FDC(int a1, unsigned __int8 *a2, _DWORD *a3, float *a4, float *a5)
{
  long double v5; // fst7
  long double v6; // fst7
  long double v7; // fst7
  float v8; // [esp+38h] [ebp-70h]
  float v9; // [esp+3Ch] [ebp-6Ch]
  float v10; // [esp+40h] [ebp-68h]
  float v11; // [esp+44h] [ebp-64h]
  float v12; // [esp+48h] [ebp-60h]
  float v13; // [esp+4Ch] [ebp-5Ch]
  float v14; // [esp+50h] [ebp-58h]
  float v15; // [esp+54h] [ebp-54h]
  _BOOL4 v16; // [esp+58h] [ebp-50h]
  float v17; // [esp+5Ch] [ebp-4Ch]
  float v18; // [esp+60h] [ebp-48h]
  float v19; // [esp+64h] [ebp-44h]
  float v20; // [esp+68h] [ebp-40h]
  float v21; // [esp+6Ch] [ebp-3Ch]
  float v22; // [esp+7Ch] [ebp-2Ch]
  float v23; // [esp+80h] [ebp-28h]
  float v24; // [esp+84h] [ebp-24h]
  float v25; // [esp+88h] [ebp-20h]
  float v26; // [esp+8Ch] [ebp-1Ch]
  float v27; // [esp+90h] [ebp-18h]
  _DWORD *v28; // [esp+94h] [ebp-14h]
  int v29; // [esp+98h] [ebp-10h]
  int i; // [esp+9Ch] [ebp-Ch]

  sub_805D626(a3, &v18);
  while ( *((_DWORD *)a2 + 1) & *(_DWORD *)(a1 + 128) )
  {
    if ( *((_WORD *)a2 + 1) )
    {
      if ( *((_WORD *)a2 + 1) > 0 )
      {
        for ( i = 0; i < *((signed __int16 *)a2 + 1); ++i )
        {
          v29 = *(unsigned __int16 *)(*((_DWORD *)a2 + 2) + 2 * i);
          v28 = (_DWORD *)(dword_8185C60 + 48 * v29);
          if ( *(_DWORD *)(dword_8185C60 + 48 * v29 + 12) & *(_DWORD *)(a1 + 128) )
            sub_8059BBC((float *)a1, v28, (int)a5);
        }
        return;
      }
      sub_8059FDC(a1, a2 + 20, &v18, a4, a5);
    }
    v26 = *(&v18 + *a2) - *((float *)a2 + 2);
    v25 = a4[*a2] - *((float *)a2 + 2);
    v5 = *(float *)(a1 + 4 * *a2 + 92) + 0.125 - *((float *)a2 + 3);
    v27 = v5;
    sub_805D3CA(v26, v25);
    v22 = v5;
    sub_805D3EE(v26, v25);
    v23 = v5;
    if ( v23 < (long double)v27 )
    {
      if ( -v27 < (long double)v22 )
      {
        if ( v21 >= (long double)*a5 )
          return;
        v9 = v25 - v26;
        v8 = sub_805D378(v9);
        v6 = 0.00000047683716;
        if ( v8 <= 0.00000047683716 )
        {
          v16 = 0;
          v15 = 1.0;
          v14 = 0.0;
        }
        else
        {
          v24 = sub_805D34E(v9, COERCE_FLOAT(LODWORD(v26) ^ 0x80000000), v26);
          v17 = 1.0 / v8;
          v14 = (v24 - v27) * v17;
          v6 = (v24 + v27) * v17;
          v15 = v6;
          v16 = sub_805D3B2(v9);
        }
        sub_805D3EE(v15, 1.0);
        v15 = v6;
        v10 = (*a4 - v18) * v15 + v18;
        v11 = (a4[1] - v19) * v15 + v19;
        v12 = (a4[2] - v20) * v15 + v20;
        v7 = (a4[3] - v21) * v15 + v21;
        v13 = v7;
        sub_8059FDC(a1, &a2[20 * *(unsigned __int16 *)&a2[2 * v16 + 16]], &v18, &v10, a5);
        sub_805D3CA(v14, 0.0);
        v14 = v7;
        v18 = (*a4 - v18) * v14 + v18;
        v19 = (a4[1] - v19) * v14 + v19;
        v20 = (a4[2] - v20) * v14 + v20;
        v21 = (a4[3] - v21) * v14 + v21;
        a2 += 20 * *(unsigned __int16 *)&a2[2 * (1 - v16) + 16];
      }
      else
      {
        a2 += 20 * *((unsigned __int16 *)a2 + 9);
      }
    }
    else
    {
      if ( -v27 >= (long double)v22 )
        return;
      a2 += 20 * *((unsigned __int16 *)a2 + 8);
    }
  }
}
// 8185C60: using guessed type int dword_8185C60;

//----- (0805A3A4) --------------------------------------------------------
_BOOL4 __cdecl sub_805A3A4(int a1, int a2, float *a3)
{
  float v5[3]; // [esp+30h] [ebp-48h]
  float v6; // [esp+3Ch] [ebp-3Ch]
  char v7; // [esp+40h] [ebp-38h]
  int v8; // [esp+4Ch] [ebp-2Ch]
  char v9; // [esp+50h] [ebp-28h]
  char v10; // [esp+60h] [ebp-18h]

  sub_805D510((float *)(a2 + 12), (float *)(a1 + 92), (float *)&v10);
  sub_805D4CC((float *)(a2 + 24), (float *)(a1 + 92), (float *)&v9);
  if ( sub_805D6DC(a1, (int)&v10, (int)&v9, *a3) )
    return 0;
  sub_805D45E((_DWORD *)a1, &v7);
  sub_805D45E((_DWORD *)(a1 + 12), v5);
  v8 = 0;
  v6 = *a3;
  sub_8059FDC(a1, (unsigned __int8 *)dword_8185C10 + 20 * *(_DWORD *)(a2 + 36), &v7, v5, a3);
  return 0.0 == *a3;
}

//----- (0805A4AA) --------------------------------------------------------
void __cdecl sub_805A4AA(int a1, unsigned __int16 *a2, float *a3)
{
  signed int i; // [esp+14h] [ebp-4h]

  if ( *a3 != 0.0
    && (!(*((_DWORD *)a2 + 1) & *(_DWORD *)(a1 + 128)) || !(unsigned __int8)sub_805A3A4(a1, (int)a2, a3))
    && *((_DWORD *)a2 + 2) & *(_DWORD *)(a1 + 128) )
  {
    for ( i = 0; i < a2[1] && *a3 != 0.0; ++i )
      sub_8055C74(a1, dword_8185C50 + 32 * (i + *a2), (int)a3);
  }
}
// 8185C50: using guessed type int dword_8185C50;

//----- (0805A564) --------------------------------------------------------
int __cdecl sub_805A564(int a1, int a2, int a3, int a4, float a5, int a6)
{
  float v6; // ST18_4
  long double v7; // fst7
  long double v8; // fst7
  signed int v10; // [esp+1Ch] [ebp-4Ch]
  char v11; // [esp+20h] [ebp-48h]
  float v12; // [esp+34h] [ebp-34h]
  float v13; // [esp+38h] [ebp-30h]
  float v14; // [esp+3Ch] [ebp-2Ch]
  float v15; // [esp+40h] [ebp-28h]
  float v16; // [esp+44h] [ebp-24h]
  float v17; // [esp+48h] [ebp-20h]
  float v18; // [esp+4Ch] [ebp-1Ch]
  char v19; // [esp+50h] [ebp-18h]

  sub_805D510((float *)a2, (float *)a4, (float *)&v19);
  v14 = (a5 + *(float *)(a1 + 140)) * (a5 + *(float *)(a1 + 140));
  v16 = sub_805D554((float *)&v19, (float *)&v19) - v14;
  if ( v16 > 0.0 )
  {
    v17 = sub_805D554((float *)(a1 + 36), (float *)&v19);
    if ( v17 < 0.0 )
    {
      v18 = *(float *)(a1 + 52);
      v15 = v17 * v17 - v18 * v16;
      if ( v15 >= 0.0 )
      {
        v12 = sub_80A2298((float *)&v19, (int)&v11);
        LODWORD(v6) = LODWORD(v17) ^ 0x80000000;
        v7 = sub_805D392(v15);
        v13 = (v6 - v7) / v18 + v12 * 0.125 / v17;
        v8 = v13;
        if ( *(float *)a6 <= (long double)v13 )
        {
          v10 = 1;
        }
        else
        {
          sub_805D3CA(v13, 0.0);
          *(float *)a6 = v8;
          sub_805D45E(&v11, (_DWORD *)(a6 + 4));
          *(_DWORD *)(a6 + 20) = *(_DWORD *)(*(_DWORD *)(a1 + 176) + 12);
          v10 = 0;
        }
      }
      else
      {
        v10 = 1;
      }
    }
    else
    {
      v10 = 1;
    }
  }
  else
  {
    *(_DWORD *)a6 = 0;
    *(_BYTE *)(a6 + 35) = 1;
    sub_80A2298((float *)&v19, a6 + 4);
    *(_DWORD *)(a6 + 20) = *(_DWORD *)(*(_DWORD *)(a1 + 176) + 12);
    sub_805D510((float *)a3, (float *)a4, (float *)&v19);
    if ( v14 >= sub_805D5F2((float *)&v19) )
      *(_BYTE *)(a6 + 34) = 1;
    v10 = 0;
  }
  return v10;
}

//----- (0805A75A) --------------------------------------------------------
int __cdecl sub_805A75A(int a1, int a2, float a3, float a4, int a5)
{
  float v5; // ST10_4
  long double v6; // fst7
  float v7; // ST18_4
  signed int v9; // [esp+14h] [ebp-54h]
  float v10; // [esp+1Ch] [ebp-4Ch]
  float v11; // [esp+1Ch] [ebp-4Ch]
  char v12; // [esp+20h] [ebp-48h]
  float v13; // [esp+30h] [ebp-38h]
  float v14; // [esp+34h] [ebp-34h]
  float v15; // [esp+38h] [ebp-30h]
  float v16; // [esp+3Ch] [ebp-2Ch]
  float v17; // [esp+40h] [ebp-28h]
  float v18; // [esp+44h] [ebp-24h]
  float v19; // [esp+48h] [ebp-20h]
  float v20; // [esp+4Ch] [ebp-1Ch]
  char v21; // [esp+50h] [ebp-18h]
  float v22; // [esp+58h] [ebp-10h]

  sub_805D510((float *)a1, (float *)a2, (float *)&v21);
  v16 = (a4 + *(float *)(a1 + 140)) * (a4 + *(float *)(a1 + 140));
  v18 = sub_805D412((float *)&v21, (float *)&v21) - v16;
  if ( v18 > 0.0 )
  {
    v19 = sub_805D412((float *)(a1 + 36), (float *)&v21);
    if ( v19 < 0.0 )
    {
      v20 = sub_805D412((float *)(a1 + 36), (float *)(a1 + 36));
      v17 = v19 * v19 - v20 * v18;
      if ( v17 >= 0.0 )
      {
        v22 = 0.0;
        v13 = sub_80A2298((float *)&v21, (int)&v12);
        v14 = v13 * 0.125 / v19;
        LODWORD(v5) = LODWORD(v19) ^ 0x80000000;
        v6 = sub_805D392(v17);
        v15 = (v5 - v6) / v20 + v14;
        if ( *(float *)a5 <= (long double)v15 )
        {
          v9 = 1;
        }
        else
        {
          v11 = *(float *)(a1 + 100) - *(float *)(a1 + 140) + a3;
          v7 = (v15 - v14) * *(float *)(a1 + 44) + *(float *)(a1 + 8) - *(float *)(a2 + 8);
          if ( sub_805D378(v7) <= v11 )
          {
            sub_805D3CA(v15, 0.0);
            *(float *)a5 = v11;
            sub_805D45E(&v12, (_DWORD *)(a5 + 4));
            *(_DWORD *)(a5 + 20) = *(_DWORD *)(*(_DWORD *)(a1 + 176) + 12);
            v9 = 0;
          }
          else
          {
            v9 = 1;
          }
        }
      }
      else
      {
        v9 = 1;
      }
    }
    else
    {
      v9 = 1;
    }
  }
  else
  {
    v10 = *(float *)(a1 + 100) - *(float *)(a1 + 140) + a3;
    if ( sub_805D378(v22) <= v10 )
    {
      *(_DWORD *)a5 = 0;
      *(_BYTE *)(a5 + 35) = 1;
      v22 = 0.0;
      sub_80A2298((float *)&v21, a5 + 4);
      *(_DWORD *)(a5 + 20) = *(_DWORD *)(*(_DWORD *)(a1 + 176) + 12);
      sub_805D510((float *)(a1 + 12), (float *)a2, (float *)&v21);
      if ( v10 >= sub_805D378(v22) )
        *(_BYTE *)(a5 + 34) = 1;
      v9 = 0;
    }
    else
    {
      v9 = 1;
    }
  }
  return v9;
}

//----- (0805AA0E) --------------------------------------------------------
void __cdecl sub_805AA0E(int a1, int a2)
{
  float v2; // [esp+2Ch] [ebp-BCh]
  float v3; // [esp+30h] [ebp-B8h]
  float v4[3]; // [esp+40h] [ebp-A8h]
  float v5[2]; // [esp+4Ch] [ebp-9Ch]
  float v6; // [esp+54h] [ebp-94h]
  int v7[4]; // [esp+60h] [ebp-88h]
  int v8; // [esp+70h] [ebp-78h]
  float v9; // [esp+78h] [ebp-70h]
  int v10; // [esp+80h] [ebp-68h]
  float v11; // [esp+88h] [ebp-60h]
  int v12; // [esp+90h] [ebp-58h]
  float v13; // [esp+98h] [ebp-50h]
  int v14; // [esp+A0h] [ebp-48h]
  float v15; // [esp+A8h] [ebp-40h]
  int v16; // [esp+B0h] [ebp-38h]
  float v17; // [esp+B8h] [ebp-30h]
  int v18; // [esp+C0h] [ebp-28h]
  float v19; // [esp+C8h] [ebp-20h]
  int i; // [esp+DCh] [ebp-Ch]

  if ( *(float *)(a1 + 104) <= *(float *)(*(_DWORD *)(a1 + 180) + 12) + 1.0
    && *(float *)(a1 + 108) <= *(float *)(*(_DWORD *)(a1 + 180) + 16) + 1.0
    && *(float *)(a1 + 112) <= *(float *)(*(_DWORD *)(a1 + 180) + 20) + 1.0
    && **(float **)(a1 + 180) - 1.0 <= *(float *)(a1 + 116)
    && *(float *)(*(_DWORD *)(a1 + 180) + 4) - 1.0 <= *(float *)(a1 + 120)
    && *(float *)(*(_DWORD *)(a1 + 180) + 8) - 1.0 <= *(float *)(a1 + 124) )
  {
    sub_805D45E((_DWORD *)a1, &v14);
    v15 = v15 + *(float *)(a1 + 144);
    sub_805D45E((_DWORD *)a1, &v12);
    v13 = v13 - *(float *)(a1 + 144);
    sub_805D45E((_DWORD *)(a1 + 12), &v10);
    v11 = v11 + *(float *)(a1 + 144);
    sub_805D45E((_DWORD *)(a1 + 12), &v8);
    v9 = v9 - *(float *)(a1 + 144);
    for ( i = 0; i <= 2; ++i )
    {
      *(float *)&v7[i] = (*(float *)(*(_DWORD *)(a1 + 180) + 4 * i) + *(float *)(*(_DWORD *)(a1 + 180) + 4 * i + 12))
                       * 0.5;
      v4[i] = *(float *)(*(_DWORD *)(a1 + 180) + 4 * i) - *(float *)&v7[i];
      v5[i] = *(float *)(*(_DWORD *)(a1 + 180) + 4 * i + 12) - *(float *)&v7[i];
    }
    if ( v5[0] <= (long double)v6 )
      v2 = v5[0];
    else
      v2 = v6;
    v3 = v6 - v2;
    sub_805D45E(v7, &v18);
    v19 = v19 + v3;
    sub_805D45E(v7, &v16);
    v17 = v17 - v3;
    if ( v13 <= (long double)v19 )
    {
      if ( v17 > (long double)v15
        && (!sub_805A564(a1, (int)&v14, (int)&v10, (int)&v16, v2, a2) || *(float *)(a1 + 44) <= 0.0) )
      {
        return;
      }
    }
    else if ( !sub_805A564(a1, (int)&v12, (int)&v8, (int)&v18, v2, a2) || *(float *)(a1 + 44) >= 0.0 )
    {
      return;
    }
    if ( sub_805A75A(a1, (int)v7, v3, v2, a2) )
    {
      if ( v9 <= (long double)v19 )
      {
        if ( v17 > (long double)v11 && v15 >= (long double)v17 )
          sub_805A564(a1, (int)&v14, (int)&v10, (int)&v16, v2, a2);
      }
      else if ( v19 >= (long double)v13 )
      {
        sub_805A564(a1, (int)&v12, (int)&v8, (int)&v18, v2, a2);
      }
    }
  }
}
// 805AA0E: using guessed type int var_88[4];
// 805AA0E: using guessed type float var_A8[3];
// 805AA0E: using guessed type float var_9C[2];

//----- (0805AE54) --------------------------------------------------------
void __cdecl sub_805AE54(int a1, int a2, _DWORD *a3, float *a4, float *a5)
{
  long double v5; // fst7
  long double v6; // fst7
  long double v7; // fst7
  long double v8; // fst6
  long double v9; // fst7
  long double v10; // fst7
  float v11; // ST34_4
  long double v12; // fst7
  float v13; // [esp+38h] [ebp-60h]
  float v14; // [esp+3Ch] [ebp-5Ch]
  float v15; // [esp+40h] [ebp-58h]
  float v16; // [esp+44h] [ebp-54h]
  float v17; // [esp+48h] [ebp-50h]
  float v18; // [esp+4Ch] [ebp-4Ch]
  _BOOL4 v19; // [esp+5Ch] [ebp-3Ch]
  float v20; // [esp+60h] [ebp-38h]
  float v21; // [esp+64h] [ebp-34h]
  float v22; // [esp+68h] [ebp-30h]
  float v23; // [esp+6Ch] [ebp-2Ch]
  float v24; // [esp+70h] [ebp-28h]
  float v25; // [esp+74h] [ebp-24h]
  float v26; // [esp+78h] [ebp-20h]
  float v27; // [esp+7Ch] [ebp-1Ch]
  float v28; // [esp+80h] [ebp-18h]
  float v29; // [esp+84h] [ebp-14h]
  int v30; // [esp+88h] [ebp-10h]
  int v31; // [esp+8Ch] [ebp-Ch]

  sub_805D626(a3, &v15);
  while ( a2 >= 0 )
  {
    v31 = dword_8185C00 + 8 * a2;
    v30 = *(_DWORD *)(dword_8185C00 + 8 * a2);
    if ( *(_BYTE *)(v30 + 16) > 2u )
    {
      v6 = sub_805D554((float *)v30, &v15);
      v29 = v6 - *(float *)(v30 + 12);
      v7 = sub_805D554((float *)v30, a4);
      v5 = v7 - *(float *)(v30 + 12);
      v28 = v5;
      if ( *(_DWORD *)(a1 + 132) )
        v27 = 0.125;
      else
        v27 = 2048.0;
    }
    else
    {
      v29 = *(&v15 + *(unsigned __int8 *)(v30 + 16)) - *(float *)(v30 + 12);
      v28 = a4[*(unsigned __int8 *)(v30 + 16)] - *(float *)(v30 + 12);
      v5 = *(float *)(a1 + 4 * *(unsigned __int8 *)(v30 + 16) + 92) + 0.125;
      v27 = v5;
    }
    sub_805D3EE(v29, v28);
    v8 = v5;
    v9 = v27;
    if ( v8 < v27 )
    {
      sub_805D3CA(v29, v28);
      if ( -v27 < v9 )
      {
        if ( v18 >= (long double)*a5 )
          return;
        v14 = v28 - v29;
        v13 = sub_805D378(v14);
        v10 = 0.00000047683716;
        if ( v13 <= 0.00000047683716 )
        {
          v19 = 0;
          v25 = 1.0;
          v24 = 0.0;
        }
        else
        {
          v26 = sub_805D34E(v14, COERCE_FLOAT(LODWORD(v29) ^ 0x80000000), v29);
          v11 = 1.0 / v13;
          v24 = (v26 - v27) * v11;
          v10 = (v26 + v27) * v11;
          v25 = v10;
          v19 = sub_805D3B2(v14);
        }
        sub_805D3EE(v25, 1.0);
        v25 = v10;
        v20 = (*a4 - v15) * v25 + v15;
        v21 = (a4[1] - v16) * v25 + v16;
        v22 = (a4[2] - v17) * v25 + v17;
        v12 = (a4[3] - v18) * v25 + v18;
        v23 = v12;
        sub_805AE54(a1, *(signed __int16 *)(v31 + 2 * v19 + 4), &v15, &v20, a5);
        sub_805D3CA(v24, 0.0);
        v24 = v12;
        v15 = (*a4 - v15) * v24 + v15;
        v16 = (a4[1] - v16) * v24 + v16;
        v17 = (a4[2] - v17) * v24 + v17;
        v18 = (a4[3] - v18) * v24 + v18;
        a2 = *(signed __int16 *)(v31 + 2 * !v19 + 4);
      }
      else
      {
        a2 = *(signed __int16 *)(v31 + 6);
      }
    }
    else
    {
      a2 = *(signed __int16 *)(v31 + 4);
    }
  }
  sub_805A4AA(a1, (unsigned __int16 *)(dword_8185C08 + 44 * (-1 - a2)), a5);
}
// 8185C00: using guessed type int dword_8185C00;
// 8185C08: using guessed type int dword_8185C08;

//----- (0805B198) --------------------------------------------------------
_BOOL4 __cdecl sub_805B198(int a1)
{
  float v1; // ST1C_4
  float v2; // ST18_4
  float v3; // ST14_4
  _BOOL4 result; // eax
  float v5; // [esp+20h] [ebp-18h]
  float v6; // [esp+24h] [ebp-14h]
  float v7; // [esp+28h] [ebp-10h]

  sub_805D510((float *)(a1 + 116), (float *)(a1 + 104), &v5);
  v1 = v5 * v6 * v7;
  v2 = *(float *)(a1 + 92) * *(float *)(a1 + 96) * *(float *)(a1 + 100);
  v3 = v2 * 16.0 * *(float *)(a1 + 48);
  result = v3 > (long double)v1;
  *(_DWORD *)(a1 + 136) = result;
  return result;
}

//----- (0805B210) --------------------------------------------------------
void __cdecl sub_805B210(int a1, float *a2, float *a3, int a4, int a5, int a6, int a7)
{
  int v7; // ebx
  float v8; // [esp+2Ch] [ebp-11Ch]
  float v9[3]; // [esp+30h] [ebp-118h]
  float v10; // [esp+3Ch] [ebp-10Ch]
  char v11; // [esp+40h] [ebp-108h]
  int v12; // [esp+4Ch] [ebp-FCh]
  int v13; // [esp+5Ch] [ebp-ECh]
  float v14[4]; // [esp+60h] [ebp-E8h]
  float v15[2]; // [esp+70h] [ebp-D8h]
  float v16; // [esp+78h] [ebp-D0h]
  float v17[2]; // [esp+7Ch] [ebp-CCh]
  float v18; // [esp+84h] [ebp-C4h]
  float v19[3]; // [esp+94h] [ebp-B4h]
  float v20; // [esp+A0h] [ebp-A8h]
  float v21; // [esp+A4h] [ebp-A4h]
  float v22[3]; // [esp+A8h] [ebp-A0h]
  float v23[3]; // [esp+B4h] [ebp-94h]
  float v24[3]; // [esp+C0h] [ebp-88h]
  float v25; // [esp+CCh] [ebp-7Ch]
  float v26; // [esp+D0h] [ebp-78h]
  float v27; // [esp+D4h] [ebp-74h]
  float v28[2]; // [esp+D8h] [ebp-70h]
  float v29; // [esp+E0h] [ebp-68h]
  float v30[2]; // [esp+E4h] [ebp-64h]
  float v31; // [esp+ECh] [ebp-5Ch]
  int v32; // [esp+F0h] [ebp-58h]
  _BOOL4 v33; // [esp+F4h] [ebp-54h]
  float v34; // [esp+FCh] [ebp-4Ch]
  float v35; // [esp+100h] [ebp-48h]
  float v36; // [esp+104h] [ebp-44h]
  float v37; // [esp+108h] [ebp-40h]
  float v38; // [esp+10Ch] [ebp-3Ch]
  int v39; // [esp+110h] [ebp-38h]
  int v40; // [esp+120h] [ebp-28h]
  int i; // [esp+13Ch] [ebp-Ch]

  v13 = sub_8059154(a6);
  v32 = a7;
  for ( i = 0; i <= 2; ++i )
  {
    v14[i] = (*(float *)(a4 + 4 * i) + *(float *)(a5 + 4 * i)) * 0.5;
    *(&v25 + i) = *(float *)(a5 + 4 * i) - v14[i];
    v15[i] = a2[i] + v14[i];
    v17[i] = a3[i] + v14[i];
    v22[i] = (v15[i] + v17[i]) * 0.5;
    v19[i] = v17[i] - v15[i];
    v23[i] = v19[i] * 0.5;
    v7 = i;
    v24[v7] = sub_805D378(v23[i]);
  }
  sub_805D668((int)v15);
  v21 = sub_805D5F2(v19);
  v20 = sub_805D392(v21);
  if ( v25 <= (long double)v27 )
    v8 = v25;
  else
    v8 = v27;
  v34 = v8;
  v35 = v27 - v8;
  for ( i = 0; i <= 1; ++i )
  {
    if ( v17[i] <= (long double)v15[i] )
    {
      v28[i] = v17[i] - v34;
      v30[i] = v15[i] + v34;
    }
    else
    {
      v28[i] = v15[i] - v34;
      v30[i] = v17[i] + v34;
    }
  }
  if ( v18 <= (long double)v16 )
  {
    v29 = v18 - v35 - v34;
    v31 = v16 + v35 + v34;
  }
  else
  {
    v29 = v16 - v35 - v34;
    v31 = v18 + v35 + v34;
  }
  sub_805B198((int)v15);
  sub_805906C(&v39);
  if ( (unsigned __int8)sub_805D588(a2, a3) )
  {
    v33 = 0;
    if ( a6 )
    {
      if ( a6 == 1023 )
      {
        if ( v32 & *(_DWORD *)(v40 + 12) )
          sub_80596DA((int)v15, a1);
      }
      else if ( !*(_BYTE *)(a1 + 34) )
      {
        sub_8059674((int)v15, v13 + 28, a1);
      }
    }
    else
    {
      sub_8059A48(v15, a1);
    }
  }
  else
  {
    v33 = 0.0 == v25 + v26 + v27;
    v36 = v34;
    v37 = v34;
    v38 = v34 + v35;
    if ( a6 )
    {
      if ( a6 == 1023 )
      {
        if ( v32 & *(_DWORD *)(v40 + 12) )
          sub_805AA0E((int)v15, a1);
      }
      else
      {
        sub_805A4AA((int)v15, (unsigned __int16 *)(v13 + 28), (float *)a1);
      }
    }
    else
    {
      sub_805D45E(v15, &v11);
      v12 = 0;
      sub_805D45E(v17, v9);
      v10 = *(float *)a1;
      sub_805AE54((int)v15, 0, &v11, v9, (float *)a1);
    }
  }
}
// 805B210: using guessed type float var_E8[4];
// 805B210: using guessed type float var_D8[2];
// 805B210: using guessed type float var_CC[2];
// 805B210: using guessed type float var_A0[3];
// 805B210: using guessed type float var_B4[3];
// 805B210: using guessed type float var_94[3];
// 805B210: using guessed type float var_88[3];
// 805B210: using guessed type float var_70[2];
// 805B210: using guessed type float var_64[2];

//----- (0805B690) --------------------------------------------------------
void __cdecl sub_805B690(void *s, int a2, int a3, int a4, int a5, int a6, int a7)
{
  memset(s, 0, 0x24u);
  *(_DWORD *)s = 1065353216;
  sub_805B210((int)s, (float *)a2, (float *)a3, a4, a5, a6, a7);
}

//----- (0805B6F2) --------------------------------------------------------
void __cdecl sub_805B6F2(float *a1, int a2, int a3, int a4, int a5, int a6, int a7, float *a8, float *a9)
{
  signed int v9; // [esp+2Ch] [ebp-DCh]
  float v10; // [esp+30h] [ebp-D8h]
  signed int i; // [esp+3Ch] [ebp-CCh]
  char v12; // [esp+40h] [ebp-C8h]
  char v13; // [esp+70h] [ebp-98h]
  float v14[3]; // [esp+A0h] [ebp-68h]
  float v15[2]; // [esp+ACh] [ebp-5Ch]
  float v16[7]; // [esp+C0h] [ebp-48h]
  int v17; // [esp+DCh] [ebp-2Ch]
  float v18[4]; // [esp+E0h] [ebp-28h]
  float v19[6]; // [esp+F0h] [ebp-18h]

  for ( i = 0; i <= 2; ++i )
  {
    v16[i] = (*(float *)(a4 + 4 * i) + *(float *)(a5 + 4 * i)) * 0.5;
    v14[i] = *(float *)(a4 + 4 * i) - v16[i];
    v15[i] = *(float *)(a5 + 4 * i) - v16[i];
    v19[i] = *(float *)(a2 + 4 * i) + v16[i];
    v18[i] = *(float *)(a3 + 4 * i) + v16[i];
  }
  sub_805D510(v19, a8, v19);
  sub_805D510(v18, a8, v18);
  v9 = 0;
  if ( *a9 != 0.0 || a9[1] != 0.0 || a9[2] != 0.0 )
    v9 = 1;
  v17 = v9;
  if ( v9 )
  {
    sub_80592B6(a9, (int)&v13);
    sub_80591DE((int)v19, (float *)&v13);
    sub_80591DE((int)v18, (float *)&v13);
  }
  v10 = *a1;
  sub_805B210((int)a1, v19, v18, (int)v14, (int)v15, a6, a7);
  if ( v17 )
  {
    if ( v10 > (long double)*a1 )
    {
      sub_805924A((int)&v13, (int)&v12);
      sub_80591DE((int)(a1 + 1), (float *)&v12);
    }
  }
}
// 805B6F2: using guessed type float var_48[7];
// 805B6F2: using guessed type float var_68[3];
// 805B6F2: using guessed type float var_5C[2];
// 805B6F2: using guessed type float var_18[6];
// 805B6F2: using guessed type float var_28[4];

//----- (0805B972) --------------------------------------------------------
void __cdecl sub_805B972(void *s, int a2, int a3, int a4, int a5, int a6, int a7, int a8, int a9)
{
  memset(s, 0, 0x24u);
  *(_DWORD *)s = 1065353216;
  sub_805B6F2((float *)s, a2, a3, a4, a5, a6, a7, (float *)a8, (float *)a9);
}

//----- (0805B9E2) --------------------------------------------------------
int __cdecl sub_805B9E2(float *a1, int a2)
{
  float *v2; // ST4C_4
  float v3; // ST00_4
  float v4; // ST2C_4
  float v5; // ST48_4
  signed int i; // [esp+18h] [ebp-40h]
  int v9; // [esp+1Ch] [ebp-3Ch]
  float v10; // [esp+20h] [ebp-38h]
  signed int j; // [esp+24h] [ebp-34h]
  float v12; // [esp+28h] [ebp-30h]
  float v13; // [esp+28h] [ebp-30h]
  float **v14; // [esp+30h] [ebp-28h]
  float v15; // [esp+34h] [ebp-24h]
  float v16; // [esp+34h] [ebp-24h]
  float v17; // [esp+38h] [ebp-20h]
  float v18; // [esp+38h] [ebp-20h]
  float v19; // [esp+3Ch] [ebp-1Ch]
  float v20; // [esp+3Ch] [ebp-1Ch]
  float v21; // [esp+40h] [ebp-18h]
  float v22; // [esp+44h] [ebp-14h]
  int v23; // [esp+50h] [ebp-8h]

  v22 = 0.0;
  v21 = 1.0;
  v10 = -1.0;
  v9 = a2;
  for ( i = 0; ; i = 1 )
  {
    for ( j = 0; j <= 2; ++j )
    {
      v17 = (a1[j] - *(float *)(v9 + 4 * j)) * v10 - a1[j + 37];
      v15 = (a1[j + 3] - *(float *)(v9 + 4 * j)) * v10 - a1[j + 37];
      if ( v17 <= 0.0 )
      {
        if ( v15 > 0.0 )
        {
          v13 = v17 * a1[j + 6] * v10;
          if ( v22 >= (long double)v13 )
            return 0;
          sub_805D3EE(v21, v13);
          v21 = v13;
        }
      }
      else
      {
        if ( v15 > 0.0 )
          return 0;
        v12 = v17 * a1[j + 6] * v10;
        if ( v12 >= (long double)v21 )
          return 0;
        sub_805D3CA(v22, v12);
        v22 = v21;
      }
    }
    if ( i )
      break;
    v10 = 1.0;
    v9 = a2 + 16;
  }
  v14 = *(float ***)(a2 + 32);
  v23 = *(_DWORD *)(a2 + 28);
  while ( v23 )
  {
    v2 = *v14;
    v3 = (*v14)[2] * a1[36];
    v4 = sub_805D378(v3);
    v5 = v2[3] + a1[35] + v4;
    v18 = sub_805D554(a1, v2) - v5;
    v16 = sub_805D554(a1 + 3, v2) - v5;
    if ( v18 <= 0.0 )
    {
      if ( v16 > 0.0 )
      {
        v20 = v18 - v16;
        if ( v18 > v21 * v20 )
        {
          v21 = v18 / v20;
          if ( v22 >= (long double)v21 )
            return 0;
        }
      }
    }
    else
    {
      v19 = v18 - v16;
      if ( v16 > 0.0 )
        return 0;
      if ( v18 > v22 * v19 )
      {
        v22 = v18 / v19;
        if ( v22 >= (long double)v21 )
          return 0;
      }
    }
    --v23;
    v14 += 2;
  }
  return -1431655765 * ((a2 - dword_8185C60) >> 4) + 1;
}
// 8185C5C: using guessed type __int16 word_8185C5C;
// 8185C60: using guessed type int dword_8185C60;

//----- (0805BCEE) --------------------------------------------------------
int __cdecl sub_805BCEE(int a1, unsigned __int8 *a2, _DWORD *a3, float *a4)
{
  long double v4; // fst7
  long double v5; // fst7
  long double v6; // fst7
  float v9; // [esp+28h] [ebp-70h]
  float v10; // [esp+2Ch] [ebp-6Ch]
  float v11; // [esp+30h] [ebp-68h]
  float v12; // [esp+34h] [ebp-64h]
  float v13; // [esp+38h] [ebp-60h]
  float v14; // [esp+40h] [ebp-58h]
  float v15; // [esp+44h] [ebp-54h]
  _BOOL4 v16; // [esp+48h] [ebp-50h]
  float v17; // [esp+4Ch] [ebp-4Ch]
  float v18; // [esp+50h] [ebp-48h]
  float v19; // [esp+54h] [ebp-44h]
  float v20; // [esp+58h] [ebp-40h]
  float v21; // [esp+68h] [ebp-30h]
  float v22; // [esp+6Ch] [ebp-2Ch]
  float v23; // [esp+70h] [ebp-28h]
  float v24; // [esp+74h] [ebp-24h]
  float v25; // [esp+78h] [ebp-20h]
  float v26; // [esp+7Ch] [ebp-1Ch]
  int v27; // [esp+80h] [ebp-18h]
  int v28; // [esp+84h] [ebp-14h]
  int v29; // [esp+88h] [ebp-10h]
  int i; // [esp+8Ch] [ebp-Ch]

  sub_805D45E(a3, &v18);
  while ( 1 )
  {
    if ( !(*((_DWORD *)a2 + 1) & *(_DWORD *)(a1 + 128)) )
      return 0;
    if ( *((_WORD *)a2 + 1) )
      break;
LABEL_15:
    v25 = *(&v18 + *a2) - *((float *)a2 + 2);
    v24 = a4[*a2] - *((float *)a2 + 2);
    v4 = *(float *)(a1 + 4 * *a2 + 92) + 0.125 - *((float *)a2 + 3);
    v26 = v4;
    sub_805D3CA(v25, v24);
    v21 = v4;
    sub_805D3EE(v25, v24);
    v22 = v4;
    if ( v22 < (long double)v26 )
    {
      if ( -v26 < (long double)v21 )
      {
        v10 = v24 - v25;
        v9 = sub_805D378(v10);
        v5 = 0.00000047683716;
        if ( v9 <= 0.00000047683716 )
        {
          v16 = 0;
          v15 = 1.0;
          v14 = 0.0;
        }
        else
        {
          v23 = sub_805D34E(v10, COERCE_FLOAT(LODWORD(v25) ^ 0x80000000), v25);
          v17 = 1.0 / v9;
          v14 = (v23 - v26) * v17;
          v5 = (v23 + v26) * v17;
          v15 = v5;
          v16 = sub_805D3B2(v10);
        }
        sub_805D3EE(v15, 1.0);
        v15 = v5;
        v11 = (*a4 - v18) * v15 + v18;
        v12 = (a4[1] - v19) * v15 + v19;
        v6 = (a4[2] - v20) * v15 + v20;
        v13 = v6;
        v27 = sub_805BCEE(a1, &a2[20 * *(unsigned __int16 *)&a2[2 * v16 + 16]], &v18, &v11);
        if ( v27 )
          return v27;
        sub_805D3CA(v14, 0.0);
        v14 = v6;
        v18 = (*a4 - v18) * v14 + v18;
        v19 = (a4[1] - v19) * v14 + v19;
        v20 = (a4[2] - v20) * v14 + v20;
        a2 += 20 * *(unsigned __int16 *)&a2[2 * (1 - v16) + 16];
      }
      else
      {
        a2 += 20 * *((unsigned __int16 *)a2 + 9);
      }
    }
    else
    {
      if ( -v26 >= (long double)v21 )
        return 0;
      a2 += 20 * *((unsigned __int16 *)a2 + 8);
    }
  }
  if ( *((_WORD *)a2 + 1) <= 0 )
  {
    v27 = sub_805BCEE(a1, a2 + 20, &v18, a4);
    if ( v27 )
      return v27;
    goto LABEL_15;
  }
  for ( i = 0; i < *((signed __int16 *)a2 + 1); ++i )
  {
    v29 = *(unsigned __int16 *)(*((_DWORD *)a2 + 2) + 2 * i);
    v28 = dword_8185C60 + 48 * v29;
    if ( *(_DWORD *)(dword_8185C60 + 48 * v29 + 12) & *(_DWORD *)(a1 + 128) )
    {
      v27 = sub_805B9E2((float *)a1, v28);
      if ( v27 )
        return v27;
    }
  }
  return 0;
}
// 8185C60: using guessed type int dword_8185C60;

//----- (0805C0BC) --------------------------------------------------------
int __cdecl sub_805C0BC(int a1, int a2)
{
  int v3; // [esp+1Ch] [ebp-2Ch]
  char v4; // [esp+20h] [ebp-28h]
  char v5; // [esp+30h] [ebp-18h]

  sub_805D510((float *)(a2 + 12), (float *)(a1 + 92), (float *)&v5);
  sub_805D4CC((float *)(a2 + 24), (float *)(a1 + 92), (float *)&v4);
  if ( sub_805D6DC(a1, (int)&v5, (int)&v4, 1.0) )
    v3 = 0;
  else
    v3 = sub_805BCEE(a1, (unsigned __int8 *)dword_8185C10 + 20 * *(_DWORD *)(a2 + 36), (_DWORD *)a1, (float *)(a1 + 12));
  return v3;
}

//----- (0805C16E) --------------------------------------------------------
int __cdecl sub_805C16E(int a1, unsigned __int16 *a2, float *a3)
{
  int v5; // [esp+10h] [ebp-8h]
  signed int i; // [esp+14h] [ebp-4h]

  if ( *((_DWORD *)a2 + 1) & *(_DWORD *)(a1 + 128) )
  {
    v5 = sub_805C0BC(a1, (int)a2);
    if ( v5 )
      return v5;
  }
  if ( *((_DWORD *)a2 + 2) & *(_DWORD *)(a1 + 128) )
  {
    for ( i = 0; i < a2[1]; ++i )
    {
      sub_8055CFE(a1, dword_8185C50 + 32 * (i + *a2), (int)a3);
      if ( *a3 != 1.0 )
        return i + *a2 + (unsigned __int16)word_8185C5C + 1;
    }
  }
  return 0;
}
// 8185C50: using guessed type int dword_8185C50;
// 8185C5C: using guessed type __int16 word_8185C5C;

//----- (0805C23C) --------------------------------------------------------
_BOOL4 __cdecl sub_805C23C(int a1, int a2, int a3, int a4, float a5, int a6)
{
  float v6; // ST18_4
  long double v7; // fst7
  char v10; // [esp+20h] [ebp-48h]
  float v11; // [esp+34h] [ebp-34h]
  float v12; // [esp+38h] [ebp-30h]
  float v13; // [esp+3Ch] [ebp-2Ch]
  float v14; // [esp+40h] [ebp-28h]
  float v15; // [esp+44h] [ebp-24h]
  float v16; // [esp+48h] [ebp-20h]
  float v17; // [esp+4Ch] [ebp-1Ch]
  char v18; // [esp+50h] [ebp-18h]

  sub_805D510((float *)a2, (float *)a4, (float *)&v18);
  v13 = (a5 + *(float *)(a1 + 140)) * (a5 + *(float *)(a1 + 140));
  v15 = sub_805D554((float *)&v18, (float *)&v18) - v13;
  if ( v15 <= 0.0 )
    return 0;
  v16 = sub_805D554((float *)(a1 + 36), (float *)&v18);
  if ( v16 >= 0.0 )
    return 1;
  v17 = *(float *)(a1 + 52);
  v14 = v16 * v16 - v17 * v15;
  if ( v14 < 0.0 )
    return 1;
  v11 = sub_80A2298((float *)&v18, (int)&v10);
  LODWORD(v6) = LODWORD(v16) ^ 0x80000000;
  v7 = sub_805D392(v14);
  v12 = (v6 - v7) / v17 + v16 * 0.125 / v11;
  return v12 >= (long double)*(float *)a6;
}

//----- (0805C370) --------------------------------------------------------
_BOOL4 __cdecl sub_805C370(int a1, int a2, float a3, float a4, int a5)
{
  float v5; // ST1C_4
  float v6; // ST10_4
  long double v7; // fst7
  float v8; // ST1C_4
  float v9; // ST18_4
  _BOOL4 v11; // [esp+14h] [ebp-54h]
  char v12; // [esp+20h] [ebp-48h]
  float v13; // [esp+30h] [ebp-38h]
  float v14; // [esp+34h] [ebp-34h]
  float v15; // [esp+38h] [ebp-30h]
  float v16; // [esp+3Ch] [ebp-2Ch]
  float v17; // [esp+40h] [ebp-28h]
  float v18; // [esp+44h] [ebp-24h]
  float v19; // [esp+48h] [ebp-20h]
  float v20; // [esp+4Ch] [ebp-1Ch]
  char v21; // [esp+50h] [ebp-18h]
  float v22; // [esp+58h] [ebp-10h]

  sub_805D510((float *)a1, (float *)a2, (float *)&v21);
  v16 = (a4 + *(float *)(a1 + 140)) * (a4 + *(float *)(a1 + 140));
  v18 = sub_805D412((float *)&v21, (float *)&v21) - v16;
  if ( v18 > 0.0 )
  {
    v19 = sub_805D412((float *)(a1 + 36), (float *)&v21);
    if ( v19 < 0.0 )
    {
      v20 = *(float *)(a1 + 52);
      v17 = v19 * v19 - v20 * v18;
      if ( v17 >= 0.0 )
      {
        v22 = 0.0;
        v13 = sub_80A2298((float *)&v21, (int)&v12);
        v14 = v19 * 0.125 / v13;
        LODWORD(v6) = LODWORD(v19) ^ 0x80000000;
        v7 = sub_805D392(v17);
        v15 = (v6 - v7) / v20 + v14;
        if ( v15 < (long double)*(float *)a5 )
        {
          v8 = *(float *)(a1 + 100) - *(float *)(a1 + 140) + a3;
          v9 = (v15 - v14) * *(float *)(a1 + 44) + *(float *)(a1 + 8) - *(float *)(a2 + 8);
          v11 = sub_805D378(v9) > v8;
        }
        else
        {
          v11 = 1;
        }
      }
      else
      {
        v11 = 1;
      }
    }
    else
    {
      v11 = 1;
    }
  }
  else
  {
    v5 = *(float *)(a1 + 100) - *(float *)(a1 + 140) + a3;
    v11 = sub_805D378(v22) > v5;
  }
  return v11;
}

//----- (0805C534) --------------------------------------------------------
signed int __cdecl sub_805C534(int a1, int a2)
{
  float v3; // [esp+28h] [ebp-C0h]
  float v5; // [esp+30h] [ebp-B8h]
  float v6[3]; // [esp+40h] [ebp-A8h]
  float v7[2]; // [esp+4Ch] [ebp-9Ch]
  float v8; // [esp+54h] [ebp-94h]
  int v9[4]; // [esp+60h] [ebp-88h]
  int v10; // [esp+70h] [ebp-78h]
  float v11; // [esp+78h] [ebp-70h]
  int v12; // [esp+80h] [ebp-68h]
  float v13; // [esp+88h] [ebp-60h]
  int v14; // [esp+90h] [ebp-58h]
  float v15; // [esp+98h] [ebp-50h]
  int v16; // [esp+A0h] [ebp-48h]
  float v17; // [esp+A8h] [ebp-40h]
  int v18; // [esp+B0h] [ebp-38h]
  float v19; // [esp+B8h] [ebp-30h]
  int v20; // [esp+C0h] [ebp-28h]
  float v21; // [esp+C8h] [ebp-20h]
  int i; // [esp+DCh] [ebp-Ch]

  if ( *(float *)(a1 + 104) > *(float *)(*(_DWORD *)(a1 + 180) + 12) + 1.0
    || *(float *)(a1 + 108) > *(float *)(*(_DWORD *)(a1 + 180) + 16) + 1.0
    || *(float *)(a1 + 112) > *(float *)(*(_DWORD *)(a1 + 180) + 20) + 1.0
    || **(float **)(a1 + 180) - 1.0 > *(float *)(a1 + 116)
    || *(float *)(*(_DWORD *)(a1 + 180) + 4) - 1.0 > *(float *)(a1 + 120)
    || *(float *)(*(_DWORD *)(a1 + 180) + 8) - 1.0 > *(float *)(a1 + 124) )
  {
    return 0;
  }
  sub_805D45E((_DWORD *)a1, &v16);
  v17 = v17 + *(float *)(a1 + 144);
  sub_805D45E((_DWORD *)a1, &v14);
  v15 = v15 - *(float *)(a1 + 144);
  sub_805D45E((_DWORD *)(a1 + 12), &v12);
  v13 = v13 + *(float *)(a1 + 144);
  sub_805D45E((_DWORD *)(a1 + 12), &v10);
  v11 = v11 - *(float *)(a1 + 144);
  for ( i = 0; i <= 2; ++i )
  {
    *(float *)&v9[i] = (*(float *)(*(_DWORD *)(a1 + 180) + 4 * i) + *(float *)(*(_DWORD *)(a1 + 180) + 4 * i + 12))
                     * 0.5;
    v6[i] = *(float *)(*(_DWORD *)(a1 + 180) + 4 * i) - *(float *)&v9[i];
    v7[i] = *(float *)(*(_DWORD *)(a1 + 180) + 4 * i + 12) - *(float *)&v9[i];
  }
  if ( v7[0] <= (long double)v8 )
    v3 = v7[0];
  else
    v3 = v8;
  v5 = v8 - v3;
  sub_805D45E(v9, &v20);
  v21 = v21 + v5;
  sub_805D45E(v9, &v18);
  v19 = v19 - v5;
  if ( v15 <= (long double)v21 )
  {
    if ( v19 > (long double)v17 )
    {
      if ( !sub_805C23C(a1, (int)&v16, (int)&v12, (int)&v18, v3, a2) )
        return -1;
      if ( *(float *)(a1 + 44) <= 0.0 )
        return 0;
    }
  }
  else
  {
    if ( !sub_805C23C(a1, (int)&v14, (int)&v10, (int)&v20, v3, a2) )
      return -1;
    if ( *(float *)(a1 + 44) >= 0.0 )
      return 0;
  }
  if ( sub_805C370(a1, (int)v9, v5, v3, a2) )
  {
    if ( v11 <= (long double)v21 )
    {
      if ( v19 > (long double)v13
        && v17 >= (long double)v19
        && !sub_805C23C(a1, (int)&v16, (int)&v12, (int)&v18, v3, a2) )
      {
        return -1;
      }
    }
    else if ( v21 >= (long double)v15 && !sub_805C23C(a1, (int)&v14, (int)&v10, (int)&v20, v3, a2) )
    {
      return -1;
    }
    return 0;
  }
  return -1;
}
// 805C534: using guessed type int var_88[4];
// 805C534: using guessed type float var_A8[3];
// 805C534: using guessed type float var_9C[2];

//----- (0805C9DE) --------------------------------------------------------
int __cdecl sub_805C9DE(int a1, int a2, _DWORD *a3, float *a4, float *a5)
{
  long double v5; // fst7
  long double v6; // fst7
  long double v7; // fst7
  long double v8; // fst6
  long double v9; // fst7
  long double v10; // fst7
  float v11; // ST34_4
  long double v12; // fst7
  float v15; // [esp+38h] [ebp-60h]
  float v16; // [esp+3Ch] [ebp-5Ch]
  float v17; // [esp+40h] [ebp-58h]
  float v18; // [esp+44h] [ebp-54h]
  float v19; // [esp+48h] [ebp-50h]
  int v20; // [esp+58h] [ebp-40h]
  _BOOL4 v21; // [esp+5Ch] [ebp-3Ch]
  float v22; // [esp+60h] [ebp-38h]
  float v23; // [esp+64h] [ebp-34h]
  float v24; // [esp+68h] [ebp-30h]
  float v25; // [esp+70h] [ebp-28h]
  float v26; // [esp+74h] [ebp-24h]
  float v27; // [esp+78h] [ebp-20h]
  float v28; // [esp+7Ch] [ebp-1Ch]
  float v29; // [esp+80h] [ebp-18h]
  float v30; // [esp+84h] [ebp-14h]
  int v31; // [esp+88h] [ebp-10h]
  int v32; // [esp+8Ch] [ebp-Ch]

  sub_805D45E(a3, &v17);
  while ( 1 )
  {
    while ( 1 )
    {
      while ( 1 )
      {
        if ( a2 < 0 )
          return sub_805C16E(a1, (unsigned __int16 *)(dword_8185C08 + 44 * (-1 - a2)), a5);
        v32 = dword_8185C00 + 8 * a2;
        v31 = *(_DWORD *)(dword_8185C00 + 8 * a2);
        if ( *(_BYTE *)(v31 + 16) > 2u )
        {
          v6 = sub_805D554((float *)v31, &v17);
          v30 = v6 - *(float *)(v31 + 12);
          v7 = sub_805D554((float *)v31, a4);
          v5 = v7 - *(float *)(v31 + 12);
          v29 = v5;
          v28 = *(_DWORD *)(a1 + 132) ? 0.125 : 2048.0;
        }
        else
        {
          v30 = *(&v17 + *(unsigned __int8 *)(v31 + 16)) - *(float *)(v31 + 12);
          v29 = a4[*(unsigned __int8 *)(v31 + 16)] - *(float *)(v31 + 12);
          v5 = *(float *)(a1 + 4 * *(unsigned __int8 *)(v31 + 16) + 92) + 0.125;
          v28 = v5;
        }
        sub_805D3EE(v30, v29);
        v8 = v5;
        v9 = v28;
        if ( v8 < v28 )
          break;
        a2 = *(signed __int16 *)(v32 + 4);
      }
      sub_805D3CA(v30, v29);
      if ( -v28 < v9 )
        break;
      a2 = *(signed __int16 *)(v32 + 6);
    }
    v16 = v29 - v30;
    v15 = sub_805D378(v16);
    v10 = 0.00000047683716;
    if ( v15 <= 0.00000047683716 )
    {
      v21 = 0;
      v26 = 1.0;
      v25 = 0.0;
    }
    else
    {
      v27 = sub_805D34E(v16, COERCE_FLOAT(LODWORD(v30) ^ 0x80000000), v30);
      v11 = 1.0 / v15;
      v25 = (v27 - v28) * v11;
      v10 = (v27 + v28) * v11;
      v26 = v10;
      v21 = sub_805D3B2(v16);
    }
    sub_805D3EE(v26, 1.0);
    v26 = v10;
    v22 = (*a4 - v17) * v26 + v17;
    v23 = (a4[1] - v18) * v26 + v18;
    v12 = (a4[2] - v19) * v26 + v19;
    v24 = v12;
    v20 = sub_805C9DE(a1, *(signed __int16 *)(v32 + 2 * v21 + 4), &v17, &v22, a5);
    if ( v20 )
      break;
    sub_805D3CA(v25, 0.0);
    v25 = v12;
    v17 = (*a4 - v17) * v25 + v17;
    v18 = (a4[1] - v18) * v25 + v18;
    v19 = (a4[2] - v19) * v25 + v19;
    a2 = *(signed __int16 *)(v32 + 2 * !v21 + 4);
  }
  return v20;
}
// 8185C00: using guessed type int dword_8185C00;
// 8185C08: using guessed type int dword_8185C08;

//----- (0805CCFA) --------------------------------------------------------
int __cdecl sub_805CCFA(int a1, int a2, int a3, int a4, int a5, int a6, int a7)
{
  int v7; // ebx
  float v9; // [esp+2Ch] [ebp-12Ch]
  int v10; // [esp+30h] [ebp-128h]
  char v11; // [esp+52h] [ebp-106h]
  char v12; // [esp+53h] [ebp-105h]
  int v13; // [esp+68h] [ebp-F0h]
  int v14; // [esp+6Ch] [ebp-ECh]
  float v15[4]; // [esp+70h] [ebp-E8h]
  float v16[2]; // [esp+80h] [ebp-D8h]
  float v17; // [esp+88h] [ebp-D0h]
  float v18[2]; // [esp+8Ch] [ebp-CCh]
  float v19; // [esp+94h] [ebp-C4h]
  float v20[3]; // [esp+A4h] [ebp-B4h]
  float v21; // [esp+B0h] [ebp-A8h]
  float v22; // [esp+B4h] [ebp-A4h]
  float v23[3]; // [esp+B8h] [ebp-A0h]
  float v24[3]; // [esp+C4h] [ebp-94h]
  float v25[3]; // [esp+D0h] [ebp-88h]
  float v26; // [esp+DCh] [ebp-7Ch]
  float v27; // [esp+E0h] [ebp-78h]
  float v28; // [esp+E4h] [ebp-74h]
  float v29[2]; // [esp+E8h] [ebp-70h]
  float v30; // [esp+F0h] [ebp-68h]
  float v31[2]; // [esp+F4h] [ebp-64h]
  float v32; // [esp+FCh] [ebp-5Ch]
  int v33; // [esp+100h] [ebp-58h]
  _BOOL4 v34; // [esp+104h] [ebp-54h]
  float v35; // [esp+10Ch] [ebp-4Ch]
  float v36; // [esp+110h] [ebp-48h]
  float v37; // [esp+114h] [ebp-44h]
  float v38; // [esp+118h] [ebp-40h]
  float v39; // [esp+11Ch] [ebp-3Ch]
  int v40; // [esp+120h] [ebp-38h]
  int v41; // [esp+130h] [ebp-28h]
  int i; // [esp+14Ch] [ebp-Ch]
  int v43; // [esp+160h] [ebp+8h]

  v14 = sub_8059154(a6);
  v10 = 1065353216;
  v12 = 0;
  v11 = 0;
  v33 = a7;
  for ( i = 0; i <= 2; ++i )
  {
    v15[i] = (*(float *)(a4 + 4 * i) + *(float *)(a5 + 4 * i)) * 0.5;
    *(&v26 + i) = *(float *)(a5 + 4 * i) - v15[i];
    v16[i] = *(float *)(a2 + 4 * i) + v15[i];
    v18[i] = *(float *)(a3 + 4 * i) + v15[i];
    v23[i] = (v16[i] + v18[i]) * 0.5;
    v20[i] = v18[i] - v16[i];
    v24[i] = v20[i] * 0.5;
    v7 = i;
    v25[v7] = sub_805D378(v24[i]);
  }
  sub_805D668((int)v16);
  v22 = sub_805D5F2(v20);
  v21 = sub_805D392(v22);
  if ( v26 <= (long double)v28 )
    v9 = v26;
  else
    v9 = v28;
  v35 = v9;
  v36 = v28 - v9;
  for ( i = 0; i <= 1; ++i )
  {
    if ( v18[i] <= (long double)v16[i] )
    {
      v29[i] = v18[i] - v35;
      v31[i] = v16[i] + v35;
    }
    else
    {
      v29[i] = v16[i] - v35;
      v31[i] = v18[i] + v35;
    }
  }
  if ( v19 <= (long double)v17 )
  {
    v30 = v19 - v36 - v35;
    v32 = v17 + v36 + v35;
  }
  else
  {
    v30 = v17 - v36 - v35;
    v32 = v19 + v36 + v35;
  }
  sub_805B198((int)v16);
  v34 = 0.0 == v26 + v27 + v28;
  v37 = v35;
  v38 = v35;
  v39 = v35 + v36;
  sub_805906C(&v40);
  if ( a6 )
  {
    if ( a6 == 1023 )
    {
      if ( v33 & *(_DWORD *)(v41 + 12) )
        v13 = sub_805C534((int)v16, (int)&v10);
      else
        v13 = 0;
    }
    else
    {
      v13 = sub_805C16E((int)v16, (unsigned __int16 *)(v14 + 28), (float *)&v10);
    }
  }
  else
  {
    v13 = 0;
    if ( a1 > 0 )
    {
      v43 = a1 - 1;
      if ( v43 < (unsigned __int16)word_8185C5C )
        v13 = sub_805B9E2(v16, dword_8185C60 + 48 * v43);
    }
    if ( !v13 )
      v13 = sub_805C9DE((int)v16, 0, v16, v18, (float *)&v10);
  }
  return v13;
}
// 8185C5C: using guessed type __int16 word_8185C5C;
// 8185C60: using guessed type int dword_8185C60;
// 805CCFA: using guessed type float var_E8[4];
// 805CCFA: using guessed type float var_D8[2];
// 805CCFA: using guessed type float var_CC[2];
// 805CCFA: using guessed type float var_A0[3];
// 805CCFA: using guessed type float var_B4[3];
// 805CCFA: using guessed type float var_94[3];
// 805CCFA: using guessed type float var_88[3];
// 805CCFA: using guessed type float var_70[2];
// 805CCFA: using guessed type float var_64[2];

//----- (0805D124) --------------------------------------------------------
int __cdecl sub_805D124(int a1, int a2, int a3, int a4, int a5, int a6, int a7, float *a8, float *a9)
{
  signed int v10; // [esp+20h] [ebp-A8h]
  signed int i; // [esp+2Ch] [ebp-9Ch]
  char v12; // [esp+30h] [ebp-98h]
  float v13[3]; // [esp+60h] [ebp-68h]
  float v14[2]; // [esp+6Ch] [ebp-5Ch]
  float v15[7]; // [esp+80h] [ebp-48h]
  int v16; // [esp+9Ch] [ebp-2Ch]
  float v17[4]; // [esp+A0h] [ebp-28h]
  float v18[6]; // [esp+B0h] [ebp-18h]

  for ( i = 0; i <= 2; ++i )
  {
    v15[i] = (*(float *)(a4 + 4 * i) + *(float *)(a5 + 4 * i)) * 0.5;
    v13[i] = *(float *)(a4 + 4 * i) - v15[i];
    v14[i] = *(float *)(a5 + 4 * i) - v15[i];
    v18[i] = *(float *)(a2 + 4 * i) + v15[i];
    v17[i] = *(float *)(a3 + 4 * i) + v15[i];
  }
  sub_805D510(v18, a8, v18);
  sub_805D510(v17, a8, v17);
  v10 = 0;
  if ( *a9 != 0.0 || a9[1] != 0.0 || a9[2] != 0.0 )
    v10 = 1;
  v16 = v10;
  if ( v10 )
  {
    sub_80592B6(a9, (int)&v12);
    sub_80591DE((int)v18, (float *)&v12);
    sub_80591DE((int)v17, (float *)&v12);
  }
  return sub_805CCFA(a1, (int)v18, (int)v17, (int)v13, (int)v14, a6, a7);
}
// 805D124: using guessed type float var_48[7];
// 805D124: using guessed type float var_68[3];
// 805D124: using guessed type float var_5C[2];
// 805D124: using guessed type float var_18[6];
// 805D124: using guessed type float var_28[4];

//----- (0805D34E) --------------------------------------------------------
long double __cdecl sub_805D34E(float a1, float a2, float a3)
{
  float v4; // [esp+0h] [ebp-4h]

  if ( a1 < 0.0 )
    v4 = a3;
  else
    v4 = a2;
  return v4;
}

//----- (0805D378) --------------------------------------------------------
long double __cdecl sub_805D378(float a1)
{
  return (float)fabs(a1);
}

//----- (0805D392) --------------------------------------------------------
long double __cdecl sub_805D392(float a1)
{
  return (float)sqrt(a1);
}

//----- (0805D3B2) --------------------------------------------------------
_BOOL4 __cdecl sub_805D3B2(float a1)
{
  return a1 >= 0.0;
}

//----- (0805D3CA) --------------------------------------------------------
void __cdecl sub_805D3CA(float a1, float a2)
{
  float v2; // ST00_4

  v2 = a1 - a2;
  sub_805D34E(v2, a1, a2);
}

//----- (0805D3EE) --------------------------------------------------------
void __cdecl sub_805D3EE(float a1, float a2)
{
  float v2; // ST00_4

  v2 = a2 - a1;
  sub_805D34E(v2, a1, a2);
}

//----- (0805D412) --------------------------------------------------------
long double __cdecl sub_805D412(float *a1, float *a2)
{
  return *a1 * *a2 + a1[1] * a2[1];
}

//----- (0805D434) --------------------------------------------------------
int __cdecl sub_805D434(_DWORD *a1)
{
  int result; // eax

  *a1 = 0;
  a1[1] = 0;
  result = 0;
  a1[2] = 0;
  return result;
}

//----- (0805D45E) --------------------------------------------------------
int __cdecl sub_805D45E(_DWORD *a1, _DWORD *a2)
{
  int result; // eax

  *a2 = *a1;
  a2[1] = a1[1];
  result = a1[2];
  a2[2] = result;
  return result;
}

//----- (0805D48E) --------------------------------------------------------
unsigned int __cdecl sub_805D48E(_DWORD *a1)
{
  unsigned int result; // eax

  *a1 ^= 0x80000000;
  a1[1] ^= 0x80000000;
  result = a1[2] ^ 0x80000000;
  a1[2] = result;
  return result;
}

//----- (0805D4CC) --------------------------------------------------------
int __cdecl sub_805D4CC(float *a1, float *a2, float *a3)
{
  int result; // eax

  *a3 = *a1 + *a2;
  a3[1] = a1[1] + a2[1];
  result = (int)(a1 + 2);
  a3[2] = a1[2] + a2[2];
  return result;
}

//----- (0805D510) --------------------------------------------------------
int __cdecl sub_805D510(float *a1, float *a2, float *a3)
{
  int result; // eax

  *a3 = *a1 - *a2;
  a3[1] = a1[1] - a2[1];
  result = (int)(a1 + 2);
  a3[2] = a1[2] - a2[2];
  return result;
}

//----- (0805D554) --------------------------------------------------------
long double __cdecl sub_805D554(float *a1, float *a2)
{
  return *a1 * *a2 + a1[1] * a2[1] + a1[2] * a2[2];
}

//----- (0805D588) --------------------------------------------------------
signed int __cdecl sub_805D588(float *a1, float *a2)
{
  signed int v3; // [esp+0h] [ebp-4h]

  v3 = 0;
  if ( *a1 == *a2 && a1[1] == a2[1] && a1[2] == a2[2] )
    v3 = 1;
  return v3;
}

//----- (0805D5F2) --------------------------------------------------------
long double __cdecl sub_805D5F2(float *a1)
{
  return *a1 * *a1 + a1[1] * a1[1] + a1[2] * a1[2];
}

//----- (0805D626) --------------------------------------------------------
int __cdecl sub_805D626(_DWORD *a1, _DWORD *a2)
{
  int result; // eax

  *a2 = *a1;
  a2[1] = a1[1];
  a2[2] = a1[2];
  result = a1[3];
  a2[3] = result;
  return result;
}

//----- (0805D668) --------------------------------------------------------
int *__cdecl sub_805D668(int a1)
{
  int *result; // eax
  float v2; // [esp+0h] [ebp-18h]
  float v3; // [esp+Ch] [ebp-Ch]
  int i; // [esp+10h] [ebp-8h]

  for ( i = 0; i <= 2; ++i )
  {
    v3 = *(float *)(a1 + 4 * i) - *(float *)(a1 + 4 * i + 12);
    if ( v3 == 0.0 )
      v2 = 0.0;
    else
      v2 = 1.0 / v3;
    *(float *)(a1 + 4 * i + 24) = v2;
    result = &i;
  }
  return result;
}

//----- (0805D6DC) --------------------------------------------------------
signed int __cdecl sub_805D6DC(int a1, int a2, int a3, float a4)
{
  int i; // [esp+14h] [ebp-24h]
  signed int j; // [esp+18h] [ebp-20h]
  float v8; // [esp+1Ch] [ebp-1Ch]
  float v9; // [esp+1Ch] [ebp-1Ch]
  float v10; // [esp+20h] [ebp-18h]
  float v11; // [esp+24h] [ebp-14h]
  float v12; // [esp+28h] [ebp-10h]
  float v13; // [esp+2Ch] [ebp-Ch]
  float v14; // [esp+30h] [ebp-8h]

  v14 = 0.0;
  v13 = a4;
  v12 = -1.0;
  for ( i = a2; ; i = a3 )
  {
    for ( j = 0; j <= 2; ++j )
    {
      v11 = (*(float *)(a1 + 4 * j) - *(float *)(i + 4 * j)) * v12;
      v10 = (*(float *)(a1 + 4 * j + 12) - *(float *)(i + 4 * j)) * v12;
      if ( v11 <= 0.0 )
      {
        if ( v10 > 0.0 )
        {
          v9 = v11 * *(float *)(a1 + 4 * j + 24) * v12;
          if ( v14 >= (long double)v9 )
            return 1;
          sub_805D876(v13, v9);
          v13 = v9;
        }
      }
      else
      {
        if ( v10 > 0.0 )
          return 1;
        v8 = v11 * *(float *)(a1 + 4 * j + 24) * v12;
        if ( v8 >= (long double)v13 )
          return 1;
        sub_805D852(v14, v8);
        v14 = v13;
      }
    }
    if ( v12 == 1.0 )
      break;
    v12 = 1.0;
  }
  return 0;
}

//----- (0805D852) --------------------------------------------------------
void __cdecl sub_805D852(float a1, float a2)
{
  float v2; // ST00_4

  v2 = a1 - a2;
  sub_805D89A(v2, a1, a2);
}

//----- (0805D876) --------------------------------------------------------
void __cdecl sub_805D876(float a1, float a2)
{
  float v2; // ST00_4

  v2 = a2 - a1;
  sub_805D89A(v2, a1, a2);
}

//----- (0805D89A) --------------------------------------------------------
long double __cdecl sub_805D89A(float a1, float a2, float a3)
{
  float v4; // [esp+0h] [ebp-4h]

  if ( a1 < 0.0 )
    v4 = a3;
  else
    v4 = a2;
  return v4;
}

//----- (0805D8C4) --------------------------------------------------------
int __cdecl sub_805D8C4(float *a1, float *a2)
{
  int v2; // eax
  _BOOL2 v5; // [esp+24h] [ebp-14h]
  unsigned __int16 v6; // [esp+26h] [ebp-12h]
  float v7; // [esp+28h] [ebp-10h]
  float v8; // [esp+2Ch] [ebp-Ch]

  v6 = word_8185D9A;
  if ( !word_8185D9A )
    return 0;
  sub_805F9BC(a2, a1, &v7);
  v5 = v8 >= (long double)v7;
  if ( *(&v7 + (v8 >= (long double)v7)) <= 512.0 )
    return 0;
  v2 = 24 * v6;
  word_8185D9A = word_8185DAE[12 * v6];
  *(_WORD *)(v2 + 135814572) = v5;
  *(float *)(v2 + 135814568) = (a2[(unsigned __int16)v5] + a1[(unsigned __int16)v5]) * 0.5;
  return v6;
}
// 8185D9A: using guessed type __int16 word_8185D9A;
// 8185DAE: using guessed type __int16 word_8185DAE[];

//----- (0805D9A8) --------------------------------------------------------
__int64 sub_805D9A8()
{
  __int64 result; // rax
  float v1; // [esp+18h] [ebp-10h]
  float v2; // [esp+1Ch] [ebp-Ch]
  unsigned int i; // [esp+24h] [ebp-4h]

  memset(flt_8185D80, 0, 0x601Cu);
  sub_8052518(0, flt_8185D80, flt_8185D8C);
  word_8185D9A = 2;
  for ( i = 2; i <= 0x3FE; ++i )
    word_8185DAE[12 * i] = i + 1;
  word_818BD96 = 0;
  sub_805F9BC(flt_8185D8C, flt_8185D80, &v1);
  word_8185DC4 = v2 >= (long double)v1;
  LODWORD(result) = v2 >= (long double)v1;
  HIDWORD(result) = v2 >= (long double)v1;
  flt_8185DC0 = (flt_8185D8C[(_DWORD)result] + flt_8185D80[HIDWORD(result)]) * 0.5;
  return result;
}
// 8185D9A: using guessed type __int16 word_8185D9A;
// 8185DAE: using guessed type __int16 word_8185DAE[];
// 8185DC0: using guessed type float flt_8185DC0;
// 8185DC4: using guessed type __int16 word_8185DC4;
// 818BD96: using guessed type __int16 word_818BD96;

//----- (0805DA8E) --------------------------------------------------------
int sub_805DA8E()
{
  sub_805D9A8();
  return sub_805E51A();
}

//----- (0805DAA0) --------------------------------------------------------
int __cdecl sub_805DAA0(unsigned __int16 *a1)
{
  int result; // eax
  int j; // eax
  unsigned __int16 v3; // [esp+6h] [ebp-12h]
  int v4; // [esp+8h] [ebp-10h]
  unsigned __int16 v5; // [esp+Eh] [ebp-Ah]
  unsigned __int16 v6; // [esp+Eh] [ebp-Ah]
  int v7; // [esp+10h] [ebp-8h]
  int i; // [esp+14h] [ebp-4h]
  int v9; // [esp+14h] [ebp-4h]

  result = *a1;
  v3 = *a1;
  if ( *a1 )
  {
    v7 = 24 * v3 + 135814556;
    *a1 = 0;
    if ( (unsigned __int16 *)(372 * *((unsigned __int16 *)&unk_8185DA4 + 12 * v3) + 138600228) == a1 )
    {
      *((_WORD *)&unk_8185DA4 + 12 * v3) = a1[1];
    }
    else
    {
      for ( i = 372 * *((unsigned __int16 *)&unk_8185DA4 + 12 * v3) + 138600228;
            (unsigned __int16 *)(372 * *(unsigned __int16 *)(i + 2) + 138600228) != a1;
            i = 372 * *(unsigned __int16 *)(i + 2) + 138600228 )
      {
        ;
      }
      *(_WORD *)(i + 2) = a1[1];
    }
    while ( !*(_WORD *)(v7 + 8) )
    {
      if ( *(_WORD *)(v7 + 10) )
        break;
      if ( *(_WORD *)(v7 + 20) )
        break;
      if ( *(_WORD *)(v7 + 22) )
        break;
      *(_DWORD *)(v7 + 4) = 0;
      if ( !*(_WORD *)(v7 + 18) )
        break;
      v5 = *(_WORD *)(v7 + 18);
      *(_WORD *)(v7 + 18) = word_8185D9A;
      word_8185D9A = v3;
      v7 = 24 * v5 + 135814556;
      if ( *(_WORD *)&algn_8185DB0[24 * v5] == v3 )
        *(_WORD *)&algn_8185DB0[24 * v5] = 0;
      else
        *(_WORD *)&algn_8185DB0[24 * v5 + 2] = 0;
      v3 = v5;
    }
    while ( 1 )
    {
      v4 = dword_8185DA0[6 * *(unsigned __int16 *)(v7 + 20)] | dword_8185DA0[6 * *(unsigned __int16 *)(v7 + 22)];
      if ( *(_WORD *)(v7 + 8) )
      {
        v9 = 372 * *(unsigned __int16 *)(v7 + 8) + 138600228;
        for ( j = sub_808FE68(v9); ; j = sub_808FE68(v9) )
        {
          v4 |= *(_DWORD *)(j + 284);
          if ( !*(_WORD *)(v9 + 2) )
            break;
          v9 = 372 * *(unsigned __int16 *)(v9 + 2) + 138600228;
        }
      }
      *(_DWORD *)(v7 + 4) = v4;
      result = *(unsigned __int16 *)(v7 + 18);
      v6 = *(_WORD *)(v7 + 18);
      if ( !v6 )
        break;
      v7 = 24 * v6 + 135814556;
    }
  }
  return result;
}
// 8185D9A: using guessed type __int16 word_8185D9A;
// 8185DA0: using guessed type int dword_8185DA0[];

//----- (0805DCC8) --------------------------------------------------------
int __cdecl sub_805DCC8(unsigned __int16 *a1, unsigned __int16 a2)
{
  int result; // eax
  unsigned __int16 v3; // [esp+2h] [ebp-Ah]
  unsigned __int16 *i; // [esp+4h] [ebp-8h]

  v3 = -11275 * ((signed int)((char *)a1 - (signed int)&dword_842BC80 - 9240) >> 2);
  for ( i = (unsigned __int16 *)(24 * a2 + 135814564);
        v3 >= (unsigned __int16)(*i - 1);
        i = (unsigned __int16 *)(372 * *i + 138600230) )
  {
    ;
  }
  *a1 = a2;
  a1[1] = *i;
  result = v3 + 1;
  *i = result;
  return result;
}
// 842BC80: using guessed type int dword_842BC80;

//----- (0805DD50) --------------------------------------------------------
int __cdecl sub_805DD50(_WORD *a1, unsigned __int16 a2)
{
  int result; // eax
  unsigned __int16 v3; // [esp+2h] [ebp-Ah]
  _WORD *i; // [esp+4h] [ebp-8h]

  v3 = -13107 * (((signed int)a1 - dword_8185BE8) >> 4);
  for ( i = (_WORD *)(24 * a2 + 135814566);
        v3 >= (unsigned __int16)(*i - 1);
        i = (_WORD *)(dword_8185BE8 + 80 * (unsigned __int16)*i - 80) )
  {
    ;
  }
  *a1 = *i;
  result = v3 + 1;
  *i = result;
  return result;
}
// 8185BE8: using guessed type int dword_8185BE8;

//----- (0805DDD0) --------------------------------------------------------
int __cdecl sub_805DDD0(int a1, float *a2, float *a3)
{
  int result; // eax
  unsigned __int16 v4; // [esp+Eh] [ebp-2Ah]
  unsigned __int16 v5; // [esp+10h] [ebp-28h]
  unsigned __int16 v6; // [esp+12h] [ebp-26h]
  unsigned __int16 v7; // [esp+12h] [ebp-26h]
  unsigned __int16 *v8; // [esp+14h] [ebp-24h]
  int v9; // [esp+18h] [ebp-20h]
  float v10; // [esp+1Ch] [ebp-1Ch]
  int v11; // [esp+20h] [ebp-18h]
  unsigned __int16 *v12; // [esp+24h] [ebp-14h]
  unsigned __int16 *v13; // [esp+28h] [ebp-10h]

  result = a1;
  if ( !byte_8185D98 )
  {
    v11 = *((unsigned __int16 *)&unk_8185DAC + 12 * (unsigned __int16)a1);
    v10 = *((float *)&unk_8185DA8 + 6 * (unsigned __int16)a1);
    v9 = 0;
    v5 = *((_WORD *)&unk_8185DA4 + 12 * (unsigned __int16)a1);
    while ( v5 )
    {
      v13 = (unsigned __int16 *)(372 * v5 + 138600228);
      if ( *((float *)&unk_842DF24 + 93 * v5 + v11 + 89) <= (long double)v10 )
      {
        if ( v10 > (long double)*((float *)&unk_842DF24 + 93 * v5 + v11 + 91) )
        {
          v6 = *(_WORD *)&algn_8185DB0[24 * (unsigned __int16)a1 + 2];
          if ( v6 )
            goto LABEL_13;
          v6 = sub_805D8C4(a2, a3);
          if ( v6 )
          {
            *(_WORD *)&algn_8185DB0[24 * (unsigned __int16)a1 + 2] = v6;
            word_8185DAE[12 * v6] = a1;
            goto LABEL_13;
          }
        }
        goto LABEL_12;
      }
      v6 = *(_WORD *)&algn_8185DB0[24 * (unsigned __int16)a1];
      if ( v6 )
      {
LABEL_13:
        v5 = *((_WORD *)&unk_842DF26 + 186 * v5);
        sub_805DCC8(v13, v6);
        dword_8185DA0[6 * v6] |= *(_DWORD *)(sub_808FE68((int)v13) + 284);
        if ( v9 )
          *(_WORD *)(v9 + 2) = v5;
        else
          *((_WORD *)&unk_8185DA4 + 12 * (unsigned __int16)a1) = v5;
      }
      else
      {
        v6 = sub_805D8C4(a2, a3);
        if ( v6 )
        {
          *(_WORD *)&algn_8185DB0[24 * (unsigned __int16)a1] = v6;
          word_8185DAE[12 * v6] = a1;
          goto LABEL_13;
        }
LABEL_12:
        v9 = 372 * v5 + 138600228;
        v5 = *((_WORD *)&unk_842DF26 + 186 * v5);
      }
    }
    v8 = 0;
    result = *((unsigned __int16 *)&unk_8185DA6 + 12 * (unsigned __int16)a1);
    v4 = *((_WORD *)&unk_8185DA6 + 12 * (unsigned __int16)a1);
    while ( 1 )
    {
      if ( !v4 )
        return result;
      v12 = (unsigned __int16 *)(dword_8185BE8 + 80 * v4 - 80);
      if ( *(float *)&v12[2 * v11 + 28] <= (long double)v10 )
        break;
      v7 = *(_WORD *)&algn_8185DB0[24 * (unsigned __int16)a1];
      if ( v7 )
      {
LABEL_27:
        v4 = *v12;
        sub_805DD50(v12, v7);
        dword_8185D9C[6 * v7] |= sub_80C33CA(*((_DWORD *)v12 + 1));
        if ( v8 )
        {
          result = v4;
          *v8 = v4;
        }
        else
        {
          result = v4;
          *((_WORD *)&unk_8185DA6 + 12 * (unsigned __int16)a1) = v4;
        }
      }
      else
      {
        v7 = sub_805D8C4(a2, a3);
        if ( v7 )
        {
          *(_WORD *)&algn_8185DB0[24 * (unsigned __int16)a1] = v7;
          word_8185DAE[12 * v7] = a1;
          goto LABEL_27;
        }
LABEL_26:
        v8 = v12;
        result = *v12;
        v4 = *v12;
      }
    }
    if ( v10 > (long double)*(float *)&v12[2 * v11 + 34] )
    {
      v7 = *(_WORD *)&algn_8185DB0[24 * (unsigned __int16)a1 + 2];
      if ( v7 )
        goto LABEL_27;
      v7 = sub_805D8C4(a2, a3);
      if ( v7 )
      {
        *(_WORD *)&algn_8185DB0[24 * (unsigned __int16)a1 + 2] = v7;
        word_8185DAE[12 * v7] = a1;
        goto LABEL_27;
      }
    }
    goto LABEL_26;
  }
  return result;
}
// 8185BE8: using guessed type int dword_8185BE8;
// 8185D98: using guessed type char byte_8185D98;
// 8185D9C: using guessed type int dword_8185D9C[];
// 8185DA0: using guessed type int dword_8185DA0[];
// 8185DAE: using guessed type __int16 word_8185DAE[];

//----- (0805E18C) --------------------------------------------------------
int __cdecl sub_805E18C(int a1, _DWORD *a2, _DWORD *a3, int a4)
{
  int v4; // ST1C_4
  int v6; // [esp+20h] [ebp-28h]
  int v7; // [esp+24h] [ebp-24h]
  int v8[2]; // [esp+28h] [ebp-20h]
  int v9[3]; // [esp+30h] [ebp-18h]
  int v10; // [esp+3Ch] [ebp-Ch]
  int v11; // [esp+40h] [ebp-8h]
  unsigned __int16 i; // [esp+46h] [ebp-2h]

  v4 = sub_8059154(a4);
  v6 = *(_DWORD *)(v4 + 32) | *(_DWORD *)(v4 + 36);
  if ( !*(_QWORD *)(v4 + 32) )
    return sub_805DAA0((unsigned __int16 *)a1);
  while ( 1 )
  {
    sub_805F99C(flt_8185D80, v9);
    sub_805F99C(flt_8185D8C, v8);
    for ( i = 1; ; i = *(_WORD *)(v7 + 22) )
    {
      while ( 1 )
      {
        dword_8185DA0[6 * i] |= v6;
        v7 = 24 * i + 135814556;
        v11 = *((unsigned __int16 *)&unk_8185DAC + 12 * i);
        v10 = *((int *)&unk_8185DA8 + 6 * i);
        if ( *(float *)&a2[v11] <= (long double)*(float *)&v10 )
          break;
        v9[v11] = v10;
        if ( !*(_WORD *)(v7 + 20) )
          goto LABEL_13;
        i = *(_WORD *)(v7 + 20);
      }
      if ( *(float *)&v10 <= (long double)*(float *)&a3[v11] )
        break;
      v8[v11] = v10;
      if ( !*(_WORD *)(v7 + 22) )
        goto LABEL_13;
    }
    if ( i == *(_WORD *)a1 && !(*(_DWORD *)(a1 + 352) & ~v6) )
    {
      *(_DWORD *)(a1 + 352) = v6;
      sub_805F99C(a2, (_DWORD *)(a1 + 356));
      return sub_805F99C(a3, (_DWORD *)(a1 + 364));
    }
LABEL_13:
    if ( !*(_WORD *)a1 )
      break;
    if ( i == *(_WORD *)a1 && !(*(_DWORD *)(a1 + 352) & ~v6) )
      goto LABEL_18;
    sub_805DAA0((unsigned __int16 *)a1);
  }
  sub_805DCC8((unsigned __int16 *)a1, i);
LABEL_18:
  *(_DWORD *)(a1 + 352) = v6;
  sub_805F99C(a2, (_DWORD *)(a1 + 356));
  sub_805F99C(a3, (_DWORD *)(a1 + 364));
  return sub_805DDD0(i, (float *)v9, (float *)v8);
}
// 8185DA0: using guessed type int dword_8185DA0[];
// 805E18C: using guessed type int var_18[3];
// 805E18C: using guessed type int var_20[2];

//----- (0805E3D8) --------------------------------------------------------
int __cdecl sub_805E3D8(int a1)
{
  int v2; // [esp+14h] [ebp-24h]
  int v3[2]; // [esp+18h] [ebp-20h]
  int v4[2]; // [esp+20h] [ebp-18h]
  int v5; // [esp+28h] [ebp-10h]
  int v6; // [esp+2Ch] [ebp-Ch]
  int v7; // [esp+30h] [ebp-8h]
  unsigned __int16 i; // [esp+36h] [ebp-2h]

  v5 = sub_80C33CA(*(_DWORD *)(a1 + 4));
  sub_805F99C(flt_8185D80, v4);
  sub_805F99C(flt_8185D8C, v3);
  for ( i = 1; ; i = *(_WORD *)(v2 + 22) )
  {
    while ( 1 )
    {
      dword_8185D9C[6 * i] |= v5;
      v2 = 24 * i + 135814556;
      v7 = *((unsigned __int16 *)&unk_8185DAC + 12 * i);
      v6 = *((int *)&unk_8185DA8 + 6 * i);
      if ( *(float *)(a1 + 4 * v7 + 56) <= (long double)*(float *)&v6 )
        break;
      v4[v7] = v6;
      if ( !*(_WORD *)(v2 + 20) )
        goto LABEL_8;
      i = *(_WORD *)(v2 + 20);
    }
    if ( *(float *)&v6 <= (long double)*(float *)(a1 + 4 * v7 + 68) )
      break;
    v3[v7] = v6;
    if ( !*(_WORD *)(v2 + 22) )
      break;
  }
LABEL_8:
  sub_805DD50((_WORD *)a1, i);
  return sub_805DDD0(i, (float *)v4, (float *)v3);
}
// 8185D9C: using guessed type int dword_8185D9C[];
// 805E3D8: using guessed type int var_18[2];
// 805E3D8: using guessed type int var_20[2];

//----- (0805E51A) --------------------------------------------------------
int sub_805E51A()
{
  int result; // eax
  int v1; // [esp+10h] [ebp-8h]
  int i; // [esp+14h] [ebp-4h]

  v1 = 0;
  for ( i = dword_8185BE8; ; i += 80 )
  {
    result = v1;
    if ( v1 >= dword_8185BE4 )
      break;
    if ( sub_80C33CA(*(_DWORD *)(i + 4)) )
      sub_805E3D8(i);
    ++v1;
  }
  return result;
}
// 8185BE4: using guessed type int dword_8185BE4;
// 8185BE8: using guessed type int dword_8185BE8;

//----- (0805E56A) --------------------------------------------------------
void __cdecl sub_805E56A(unsigned __int16 a1, int a2)
{
  unsigned __int16 i; // [esp+1Ah] [ebp-Eh]
  int v3; // [esp+1Ch] [ebp-Ch]
  int v4; // [esp+20h] [ebp-8h]

  if ( dword_8185DA0[6 * a1] & *(_DWORD *)(a2 + 24) )
  {
    for ( i = *((_WORD *)&unk_8185DA4 + 12 * a1); i; i = *((_WORD *)&unk_842DF26 + 186 * i) )
    {
      v4 = 372 * i + 138600228;
      v3 = sub_808FE68(v4);
      if ( *(_DWORD *)(v3 + 284) & *(_DWORD *)(a2 + 24)
        && *(float *)(v3 + 288) <= (long double)**(float **)(a2 + 8)
        && **(float **)(a2 + 4) <= (long double)*(float *)(v3 + 300)
        && *(float *)(v3 + 292) <= (long double)*(float *)(*(_DWORD *)(a2 + 8) + 4)
        && *(float *)(*(_DWORD *)(a2 + 4) + 4) <= (long double)*(float *)(v3 + 304)
        && *(float *)(v3 + 296) <= (long double)*(float *)(*(_DWORD *)(a2 + 8) + 8)
        && *(float *)(*(_DWORD *)(a2 + 4) + 8) <= (long double)*(float *)(v3 + 308) )
      {
        if ( *(_DWORD *)(a2 + 16) == *(_DWORD *)(a2 + 20) )
        {
          Com_DPrintf("CM_AreaEntities: MAXCOUNT\n");
          return;
        }
        *(_DWORD *)(*(_DWORD *)(a2 + 12) + 4 * (*(_DWORD *)(a2 + 16))++) = 1062196213
                                                                         * ((v4 + -(signed int)&dword_842BC80 - 9240) >> 2);
      }
    }
    if ( *(float *)(*(_DWORD *)(a2 + 8) + 4 * *((unsigned __int16 *)&unk_8185DAC + 12 * a1)) > (long double)*((float *)&unk_8185DA8 + 6 * a1) )
      sub_805E56A(*(unsigned __int16 *)&algn_8185DB0[24 * a1], a2);
    if ( *((float *)&unk_8185DA8 + 6 * a1) > (long double)*(float *)(*(_DWORD *)(a2 + 4)
                                                                   + 4 * *((unsigned __int16 *)&unk_8185DAC + 12 * a1)) )
      sub_805E56A(*(unsigned __int16 *)&algn_8185DB0[24 * a1 + 2], a2);
  }
}
// 8185DA0: using guessed type int dword_8185DA0[];
// 842BC80: using guessed type int dword_842BC80;

//----- (0805E782) --------------------------------------------------------
int __cdecl sub_805E782(int a1, int a2, int a3, int a4, int a5)
{
  char v6; // [esp+10h] [ebp-28h]
  int v7; // [esp+14h] [ebp-24h]
  int v8; // [esp+18h] [ebp-20h]
  int v9; // [esp+1Ch] [ebp-1Ch]
  int v10; // [esp+20h] [ebp-18h]
  int v11; // [esp+24h] [ebp-14h]
  int v12; // [esp+28h] [ebp-10h]

  v7 = a1;
  v8 = a2;
  v9 = a3;
  v10 = 0;
  v11 = a4;
  v12 = a5;
  sub_805E56A(1u, (int)&v6);
  return v10;
}

//----- (0805E7C6) --------------------------------------------------------
void __cdecl sub_805E7C6(int a1, unsigned __int16 a2, _DWORD *a3, float *a4, float *a5)
{
  int v5; // ebx
  float v6; // [esp+20h] [ebp-58h]
  float v7; // [esp+24h] [ebp-54h]
  float v8; // [esp+28h] [ebp-50h]
  float v9; // [esp+2Ch] [ebp-4Ch]
  int v10; // [esp+34h] [ebp-44h]
  unsigned __int16 i; // [esp+3Ah] [ebp-3Eh]
  int v12; // [esp+3Ch] [ebp-3Ch]
  float v13; // [esp+40h] [ebp-38h]
  float v14; // [esp+44h] [ebp-34h]
  float v15; // [esp+48h] [ebp-30h]
  float v16; // [esp+4Ch] [ebp-2Ch]
  _BOOL4 v17; // [esp+5Ch] [ebp-1Ch]
  float v18; // [esp+60h] [ebp-18h]
  float v19; // [esp+64h] [ebp-14h]
  float v20; // [esp+68h] [ebp-10h]
  unsigned __int16 v21; // [esp+6Eh] [ebp-Ah]

  v21 = a2;
  sub_805FA18(a3, &v6);
  while ( 1 )
  {
    v10 = 24 * v21 + 135814556;
    if ( !(dword_8185D9C[6 * v21] & *(_DWORD *)a1) )
      break;
    for ( i = *(_WORD *)(v10 + 10); i; i = *(_WORD *)v12 )
    {
      v12 = dword_8185BE8 + 80 * i - 80;
      if ( *(_DWORD *)a1 & sub_80C33CA(*(_DWORD *)(v12 + 4)) )
      {
        if ( !sub_805D6DC(a1 + 4, v12 + 56, v12 + 68, *a5) )
          sub_8057F90(v12, (int)a5, (float *)(a1 + 4), (float *)(a1 + 16), *(_DWORD *)a1);
      }
    }
    v20 = *(&v6 + *(unsigned __int16 *)(v10 + 16)) - *(float *)(v10 + 12);
    v19 = a4[*(unsigned __int16 *)(v10 + 16)] - *(float *)(v10 + 12);
    if ( v20 * v19 < 0.0 )
    {
      if ( v9 >= (long double)*a5 )
        return;
      v18 = v20 / (v20 - v19);
      v13 = (*a4 - v6) * v18 + v6;
      v14 = (a4[1] - v7) * v18 + v7;
      v15 = (a4[2] - v8) * v18 + v8;
      v16 = (a4[3] - v9) * v18 + v9;
      v17 = sub_805F93C(v19);
      sub_805E7C6(a1, *(unsigned __int16 *)(v10 + 2 * v17 + 20), &v6, &v13, a5);
      v21 = *(_WORD *)(v10 + 2 * (1 - v17) + 20);
      sub_805FA18(&v13, &v6);
    }
    else
    {
      v5 = v10;
      sub_805F978(v20, v19);
      v21 = *(_WORD *)(v5 + 2 * (1 - sub_805F93C(0.0)) + 20);
    }
  }
}
// 8185BE8: using guessed type int dword_8185BE8;
// 8185D9C: using guessed type int dword_8185D9C[];

//----- (0805EA28) --------------------------------------------------------
void __cdecl sub_805EA28(float *a1, _DWORD *a2, _DWORD *a3, int a4)
{
  float v4[3]; // [esp+20h] [ebp-58h]
  float v5; // [esp+2Ch] [ebp-4Ch]
  char v6; // [esp+30h] [ebp-48h]
  int v7; // [esp+3Ch] [ebp-3Ch]
  int v8; // [esp+40h] [ebp-38h]
  int v9; // [esp+44h] [ebp-34h]
  int v10; // [esp+50h] [ebp-28h]

  v8 = a4;
  sub_805F9E8(a2, &v9);
  sub_805F9E8(a3, &v10);
  sub_805D668((int)&v9);
  sub_805F9E8(&v9, &v6);
  v7 = 0;
  sub_805F9E8(&v10, v4);
  v5 = *a1;
  sub_805E7C6((int)&v8, 1u, &v6, v4, a1);
}

//----- (0805EAD0) --------------------------------------------------------
signed int __cdecl sub_805EAD0(int a1, unsigned __int16 a2, _DWORD *a3, float *a4)
{
  int v4; // ebx
  float v7; // [esp+20h] [ebp-58h]
  float v8; // [esp+24h] [ebp-54h]
  float v9; // [esp+28h] [ebp-50h]
  int v10; // [esp+34h] [ebp-44h]
  unsigned __int16 i; // [esp+3Ah] [ebp-3Eh]
  int v12; // [esp+3Ch] [ebp-3Ch]
  float v13; // [esp+40h] [ebp-38h]
  float v14; // [esp+44h] [ebp-34h]
  float v15; // [esp+48h] [ebp-30h]
  _BOOL4 v16; // [esp+5Ch] [ebp-1Ch]
  float v17; // [esp+60h] [ebp-18h]
  float v18; // [esp+64h] [ebp-14h]
  float v19; // [esp+68h] [ebp-10h]
  unsigned __int16 v20; // [esp+6Eh] [ebp-Ah]

  v20 = a2;
  sub_805F9E8(a3, &v7);
  while ( 1 )
  {
    while ( 1 )
    {
      v10 = 24 * v20 + 135814556;
      if ( !(dword_8185D9C[6 * v20] & *(_DWORD *)(a1 + 36)) )
        return 1;
      for ( i = *(_WORD *)(v10 + 10); i; i = *(_WORD *)v12 )
      {
        v12 = dword_8185BE8 + 80 * i - 80;
        if ( *(_DWORD *)(a1 + 36) & sub_80C33CA(*(_DWORD *)(v12 + 4))
          && !sub_805D6DC(a1, v12 + 56, v12 + 68, 1.0)
          && !sub_805809A(v12, (float *)a1, (float *)(a1 + 12), *(_DWORD *)(a1 + 36)) )
        {
          return 0;
        }
      }
      v19 = *(&v7 + *(unsigned __int16 *)(v10 + 16)) - *(float *)(v10 + 12);
      v18 = a4[*(unsigned __int16 *)(v10 + 16)] - *(float *)(v10 + 12);
      if ( v19 * v18 < 0.0 )
        break;
      v4 = v10;
      sub_805F978(v19, v18);
      v20 = *(_WORD *)(v4 + 2 * (1 - sub_805F93C(0.0)) + 20);
    }
    v17 = v19 / (v19 - v18);
    v13 = (*a4 - v7) * v17 + v7;
    v14 = (a4[1] - v8) * v17 + v8;
    v15 = (a4[2] - v9) * v17 + v9;
    v16 = sub_805F93C(v18);
    if ( !sub_805EAD0(a1, *(unsigned __int16 *)(v10 + 2 * v16 + 20), &v7, &v13) )
      break;
    v20 = *(_WORD *)(v10 + 2 * (1 - v16) + 20);
    sub_805F9E8(&v13, &v7);
  }
  return 0;
}
// 8185BE8: using guessed type int dword_8185BE8;
// 8185D9C: using guessed type int dword_8185D9C[];

//----- (0805ED1E) --------------------------------------------------------
signed int __cdecl sub_805ED1E(_DWORD *a1, _DWORD *a2, int a3)
{
  char v4; // [esp+20h] [ebp-38h]
  int v5; // [esp+2Ch] [ebp-2Ch]
  int v6; // [esp+44h] [ebp-14h]

  v6 = a3;
  sub_805F9E8(a1, &v4);
  sub_805F9E8(a2, &v5);
  sub_805D668((int)&v4);
  return sub_805EAD0((int)&v4, 1u, &v4, (float *)&v5);
}

//----- (0805ED88) --------------------------------------------------------
void __cdecl sub_805ED88(int a1, unsigned __int16 a2, _DWORD *a3, float *a4, float *a5)
{
  long double v5; // fst7
  long double v6; // fst6
  long double v7; // fst7
  long double v8; // fst7
  float v9; // ST38_4
  float v10; // ST34_4
  long double v11; // fst7
  float v12; // [esp+3Ch] [ebp-6Ch]
  float v13; // [esp+40h] [ebp-68h]
  float v14; // [esp+44h] [ebp-64h]
  float v15; // [esp+48h] [ebp-60h]
  float v16; // [esp+4Ch] [ebp-5Ch]
  int v17; // [esp+5Ch] [ebp-4Ch]
  unsigned __int16 i; // [esp+62h] [ebp-46h]
  float v19; // [esp+64h] [ebp-44h]
  float v20; // [esp+68h] [ebp-40h]
  int v21; // [esp+6Ch] [ebp-3Ch]
  float v22; // [esp+70h] [ebp-38h]
  float v23; // [esp+74h] [ebp-34h]
  float v24; // [esp+78h] [ebp-30h]
  float v25; // [esp+7Ch] [ebp-2Ch]
  _BOOL4 v26; // [esp+88h] [ebp-20h]
  float v27; // [esp+8Ch] [ebp-1Ch]
  float v28; // [esp+90h] [ebp-18h]
  float v29; // [esp+94h] [ebp-14h]
  float v30; // [esp+98h] [ebp-10h]
  unsigned __int16 v31; // [esp+9Eh] [ebp-Ah]

  v31 = a2;
  sub_805FA18(a3, &v13);
  while ( 1 )
  {
    v17 = 24 * v31 + 135814556;
    if ( !(dword_8185DA0[6 * v31] & *(_DWORD *)(a1 + 80)) )
      break;
    for ( i = *(_WORD *)(v17 + 8); i; i = *(_WORD *)(v21 + 2) )
    {
      v21 = 372 * i + 138600228;
      if ( *(_DWORD *)(a1 + 80) & *((_DWORD *)&unk_842E084 + 93 * i) )
        sub_809AB88(a1, v21, (int)a5);
    }
    v30 = *(&v13 + *(unsigned __int16 *)(v17 + 16)) - *(float *)(v17 + 12);
    v5 = a4[*(unsigned __int16 *)(v17 + 16)] - *(float *)(v17 + 12);
    v29 = v5;
    v20 = *(float *)(a1 + 4 * *(unsigned __int16 *)(v17 + 16) + 24);
    sub_805F978(v30, v29);
    v6 = v5;
    v7 = v20;
    if ( v6 < v20 )
    {
      sub_805F954(v30, v29);
      if ( -v20 < v7 )
      {
        if ( v16 >= (long double)*a5 )
          return;
        v12 = v29 - v30;
        v8 = 0.0;
        if ( v12 == 0.0 )
        {
          v26 = 0;
          v28 = 1.0;
          v27 = 0.0;
        }
        else
        {
          v9 = sub_805F922(v12);
          v10 = sub_805F8F8(v12, COERCE_FLOAT(LODWORD(v30) ^ 0x80000000), v30);
          v19 = 1.0 / v9;
          v27 = (v10 - v20) * v19;
          v8 = (v10 + v20) * v19;
          v28 = v8;
          v26 = sub_805F93C(v12);
        }
        sub_805F978(v28, 1.0);
        v28 = v8;
        v22 = (*a4 - v13) * v28 + v13;
        v23 = (a4[1] - v14) * v28 + v14;
        v24 = (a4[2] - v15) * v28 + v15;
        v11 = (a4[3] - v16) * v28 + v16;
        v25 = v11;
        sub_805ED88(a1, *(unsigned __int16 *)(v17 + 2 * v26 + 20), &v13, &v22, a5);
        sub_805F954(v27, 0.0);
        v27 = v11;
        v13 = (*a4 - v13) * v27 + v13;
        v14 = (a4[1] - v14) * v27 + v14;
        v15 = (a4[2] - v15) * v27 + v15;
        v16 = (a4[3] - v16) * v27 + v16;
        v31 = *(_WORD *)(v17 + 2 * (1 - v26) + 20);
      }
      else
      {
        v31 = *(_WORD *)(v17 + 22);
      }
    }
    else
    {
      v31 = *(_WORD *)(v17 + 20);
    }
  }
}
// 8185DA0: using guessed type int dword_8185DA0[];

//----- (0805F0A4) --------------------------------------------------------
void __cdecl sub_805F0A4(int a1, float *a2)
{
  float v2[3]; // [esp+20h] [ebp-28h]
  float v3; // [esp+2Ch] [ebp-1Ch]
  char v4; // [esp+30h] [ebp-18h]
  int v5; // [esp+3Ch] [ebp-Ch]

  sub_805F9E8((_DWORD *)(a1 + 36), &v4);
  sub_805F9E8((_DWORD *)(a1 + 48), v2);
  v5 = 0;
  v3 = *a2;
  sub_805ED88(a1, 1u, &v4, v2, a2);
}

//----- (0805F10E) --------------------------------------------------------
int __cdecl sub_805F10E(_DWORD *a1, unsigned __int16 a2, _DWORD *a3, float *a4)
{
  long double v4; // fst7
  long double v5; // fst6
  long double v6; // fst7
  long double v7; // fst7
  float v8; // ST28_4
  float v9; // ST24_4
  long double v10; // fst7
  float v13; // [esp+2Ch] [ebp-6Ch]
  float v14; // [esp+30h] [ebp-68h]
  float v15; // [esp+34h] [ebp-64h]
  float v16; // [esp+38h] [ebp-60h]
  int v17; // [esp+48h] [ebp-50h]
  int v18; // [esp+4Eh] [ebp-4Ah]
  float v19; // [esp+54h] [ebp-44h]
  float v20; // [esp+58h] [ebp-40h]
  int v21; // [esp+5Ch] [ebp-3Ch]
  float v22; // [esp+60h] [ebp-38h]
  float v23; // [esp+64h] [ebp-34h]
  float v24; // [esp+68h] [ebp-30h]
  _BOOL4 v25; // [esp+78h] [ebp-20h]
  float v26; // [esp+7Ch] [ebp-1Ch]
  float v27; // [esp+80h] [ebp-18h]
  float v28; // [esp+84h] [ebp-14h]
  float v29; // [esp+88h] [ebp-10h]
  unsigned __int16 v30; // [esp+8Eh] [ebp-Ah]

  v30 = a2;
  sub_805F9E8(a3, &v14);
  while ( 1 )
  {
    while ( 1 )
    {
      while ( 1 )
      {
        v17 = 24 * v30 + 135814556;
        if ( !(dword_8185DA0[6 * v30] & a1[17]) )
          return 0;
        LOWORD(v18) = *(_WORD *)(v17 + 8);
        while ( (_WORD)v18 )
        {
          v21 = 372 * (unsigned __int16)v18 + 138600228;
          *(int *)((char *)&v18 + 2) = sub_809B1A0(a1, v21);
          if ( *(int *)((char *)&v18 + 2) )
            return *(int *)((char *)&v18 + 2);
          v18 = *(unsigned __int16 *)(v21 + 2);
        }
        v29 = *(&v14 + *(unsigned __int16 *)(v17 + 16)) - *(float *)(v17 + 12);
        v4 = a4[*(unsigned __int16 *)(v17 + 16)] - *(float *)(v17 + 12);
        v28 = v4;
        v20 = *(float *)&a1[*(unsigned __int16 *)(v17 + 16) + 6];
        sub_805F978(v29, v28);
        v5 = v4;
        v6 = v20;
        if ( v5 < v20 )
          break;
        v30 = *(_WORD *)(v17 + 20);
      }
      sub_805F954(v29, v28);
      if ( -v20 < v6 )
        break;
      v30 = *(_WORD *)(v17 + 22);
    }
    v13 = v28 - v29;
    v7 = 0.0;
    if ( v13 == 0.0 )
    {
      v25 = 0;
      v27 = 1.0;
      v26 = 0.0;
    }
    else
    {
      v8 = sub_805F922(v13);
      v9 = sub_805F8F8(v13, COERCE_FLOAT(LODWORD(v29) ^ 0x80000000), v29);
      v19 = 1.0 / v8;
      v26 = (v9 - v20) * v19;
      v7 = (v9 + v20) * v19;
      v27 = v7;
      v25 = sub_805F93C(v13);
    }
    sub_805F978(v27, 1.0);
    v27 = v7;
    v22 = (*a4 - v14) * v27 + v14;
    v23 = (a4[1] - v15) * v27 + v15;
    v10 = (a4[2] - v16) * v27 + v16;
    v24 = v10;
    *(int *)((char *)&v18 + 2) = sub_805F10E(a1, *(unsigned __int16 *)(v17 + 2 * v25 + 20), &v14, &v22);
    if ( *(int *)((char *)&v18 + 2) )
      break;
    sub_805F954(v26, 0.0);
    v26 = v10;
    v14 = (*a4 - v14) * v26 + v14;
    v15 = (a4[1] - v15) * v26 + v15;
    v16 = (a4[2] - v16) * v26 + v16;
    v30 = *(_WORD *)(v17 + 2 * (1 - v25) + 20);
  }
  return *(int *)((char *)&v18 + 2);
}
// 8185DA0: using guessed type int dword_8185DA0[];

//----- (0805F3F6) --------------------------------------------------------
int __cdecl sub_805F3F6(int a1)
{
  return sub_805F10E((_DWORD *)a1, 1u, (_DWORD *)(a1 + 36), (float *)(a1 + 48));
}

//----- (0805F42C) --------------------------------------------------------
void __cdecl sub_805F42C(int a1, unsigned __int16 a2, _DWORD *a3, float *a4, float *a5)
{
  int v5; // ebx
  float v6; // [esp+20h] [ebp-58h]
  float v7; // [esp+24h] [ebp-54h]
  float v8; // [esp+28h] [ebp-50h]
  float v9; // [esp+2Ch] [ebp-4Ch]
  int v10; // [esp+34h] [ebp-44h]
  unsigned __int16 i; // [esp+3Ah] [ebp-3Eh]
  int v12; // [esp+3Ch] [ebp-3Ch]
  float v13; // [esp+40h] [ebp-38h]
  float v14; // [esp+44h] [ebp-34h]
  float v15; // [esp+48h] [ebp-30h]
  float v16; // [esp+4Ch] [ebp-2Ch]
  _BOOL4 v17; // [esp+5Ch] [ebp-1Ch]
  float v18; // [esp+60h] [ebp-18h]
  float v19; // [esp+64h] [ebp-14h]
  float v20; // [esp+68h] [ebp-10h]
  unsigned __int16 v21; // [esp+6Eh] [ebp-Ah]

  v21 = a2;
  sub_805FA18(a3, &v6);
  while ( 1 )
  {
    v10 = 24 * v21 + 135814556;
    if ( !(dword_8185DA0[6 * v21] & *(_DWORD *)(a1 + 44)) )
      break;
    for ( i = *(_WORD *)(v10 + 8); i; i = *(_WORD *)(v12 + 2) )
    {
      v12 = 372 * i + 138600228;
      sub_809AD2C(a1, v12, (int)a5);
    }
    v20 = *(&v6 + *(unsigned __int16 *)(v10 + 16)) - *(float *)(v10 + 12);
    v19 = a4[*(unsigned __int16 *)(v10 + 16)] - *(float *)(v10 + 12);
    if ( v20 * v19 < 0.0 )
    {
      if ( v9 >= (long double)*a5 )
        return;
      v18 = v20 / (v20 - v19);
      v13 = (*a4 - v6) * v18 + v6;
      v14 = (a4[1] - v7) * v18 + v7;
      v15 = (a4[2] - v8) * v18 + v8;
      v16 = (a4[3] - v9) * v18 + v9;
      v17 = sub_805F93C(v19);
      sub_805F42C(a1, *(unsigned __int16 *)(v10 + 2 * v17 + 20), &v6, &v13, a5);
      v21 = *(_WORD *)(v10 + 2 * (1 - v17) + 20);
      sub_805FA18(&v13, &v6);
    }
    else
    {
      v5 = v10;
      sub_805F978(v20, v19);
      v21 = *(_WORD *)(v5 + 2 * (1 - sub_805F93C(0.0)) + 20);
    }
  }
}
// 8185DA0: using guessed type int dword_8185DA0[];

//----- (0805F61E) --------------------------------------------------------
void __cdecl sub_805F61E(_DWORD *a1, float *a2)
{
  float v2[3]; // [esp+20h] [ebp-28h]
  float v3; // [esp+2Ch] [ebp-1Ch]
  char v4; // [esp+30h] [ebp-18h]
  int v5; // [esp+3Ch] [ebp-Ch]

  sub_805F9E8(a1, &v4);
  sub_805F9E8(a1 + 3, v2);
  v5 = 0;
  v3 = *a2;
  sub_805F42C((int)a1, 1u, &v4, v2, a2);
}

//----- (0805F686) --------------------------------------------------------
signed int __cdecl sub_805F686(_DWORD *a1, unsigned __int16 a2, float *a3, float *a4)
{
  _BOOL4 v4; // eax
  int v7; // [esp+26h] [ebp-42h]
  int v8; // [esp+28h] [ebp-40h]
  int v9; // [esp+28h] [ebp-40h]
  int v10; // [esp+28h] [ebp-40h]
  signed int v11; // [esp+28h] [ebp-40h]
  float v12; // [esp+30h] [ebp-38h]
  float v13; // [esp+34h] [ebp-34h]
  float v14; // [esp+38h] [ebp-30h]
  _BOOL4 v15; // [esp+4Ch] [ebp-1Ch]
  float v16; // [esp+50h] [ebp-18h]
  float v17; // [esp+54h] [ebp-14h]
  float v18; // [esp+58h] [ebp-10h]
  unsigned __int16 v19; // [esp+5Eh] [ebp-Ah]

  v19 = a2;
  if ( !(dword_8185DA0[6 * a2] & a1[8]) )
    return 0;
  v18 = a3[*((unsigned __int16 *)&unk_8185DAC + 12 * a2)] - *((float *)&unk_8185DA8 + 6 * a2);
  v17 = a4[*((unsigned __int16 *)&unk_8185DAC + 12 * a2)] - *((float *)&unk_8185DA8 + 6 * a2);
  if ( v18 * v17 < 0.0 )
  {
    v16 = v18 / (v18 - v17);
    v12 = (*a4 - *a3) * v16 + *a3;
    v13 = (a4[1] - a3[1]) * v16 + a3[1];
    v14 = (a4[2] - a3[2]) * v16 + a3[2];
    v15 = sub_805F93C(v17);
    v9 = sub_805F686(a1, *((unsigned __int16 *)&dword_8185D9C[6 * a2 + 5] + v15), a3, &v12);
    if ( v9 )
      return v9;
    v10 = sub_805F686(a1, *((unsigned __int16 *)&dword_8185D9C[6 * a2 + 5] + 1 - v15), &v12, a4);
    if ( v10 )
      return v10;
  }
  else
  {
    sub_805F978(v18, v17);
    v4 = sub_805F93C(0.0);
    v8 = sub_805F686(a1, *((unsigned __int16 *)&dword_8185D9C[6 * a2 + 5] + 1 - v4), a3, a4);
    if ( v8 )
      return v8;
  }
  LOWORD(v7) = *((_WORD *)&unk_8185DA4 + 12 * a2);
  while ( (_WORD)v7 )
  {
    v11 = sub_809B30E(a1, 372 * (unsigned __int16)v7 + 138600228);
    if ( v11 )
      return v11;
    v7 = *((unsigned __int16 *)&unk_842DF26 + 186 * (unsigned __int16)v7);
  }
  return 0;
}
// 8185D9C: using guessed type int dword_8185D9C[];
// 8185DA0: using guessed type int dword_8185DA0[];

//----- (0805F8C6) --------------------------------------------------------
signed int __cdecl sub_805F8C6(int a1)
{
  return sub_805F686((_DWORD *)a1, 1u, (float *)a1, (float *)(a1 + 12));
}

//----- (0805F8F8) --------------------------------------------------------
long double __cdecl sub_805F8F8(float a1, float a2, float a3)
{
  float v4; // [esp+0h] [ebp-4h]

  if ( a1 < 0.0 )
    v4 = a3;
  else
    v4 = a2;
  return v4;
}

//----- (0805F922) --------------------------------------------------------
long double __cdecl sub_805F922(float a1)
{
  return (float)fabs(a1);
}

//----- (0805F93C) --------------------------------------------------------
_BOOL4 __cdecl sub_805F93C(float a1)
{
  return a1 >= 0.0;
}

//----- (0805F954) --------------------------------------------------------
void __cdecl sub_805F954(float a1, float a2)
{
  float v2; // ST00_4

  v2 = a1 - a2;
  sub_805F8F8(v2, a1, a2);
}

//----- (0805F978) --------------------------------------------------------
void __cdecl sub_805F978(float a1, float a2)
{
  float v2; // ST00_4

  v2 = a2 - a1;
  sub_805F8F8(v2, a1, a2);
}

//----- (0805F99C) --------------------------------------------------------
int __cdecl sub_805F99C(_DWORD *a1, _DWORD *a2)
{
  int result; // eax

  *a2 = *a1;
  result = a1[1];
  a2[1] = result;
  return result;
}

//----- (0805F9BC) --------------------------------------------------------
int __cdecl sub_805F9BC(float *a1, float *a2, float *a3)
{
  int result; // eax

  *a3 = *a1 - *a2;
  result = (int)(a1 + 1);
  a3[1] = a1[1] - a2[1];
  return result;
}

//----- (0805F9E8) --------------------------------------------------------
int __cdecl sub_805F9E8(_DWORD *a1, _DWORD *a2)
{
  int result; // eax

  *a2 = *a1;
  a2[1] = a1[1];
  result = a1[2];
  a2[2] = result;
  return result;
}

//----- (0805FA18) --------------------------------------------------------
int __cdecl sub_805FA18(_DWORD *a1, _DWORD *a2)
{
  int result; // eax

  *a2 = *a1;
  a2[1] = a1[1];
  a2[2] = a1[2];
  result = a1[3];
  a2[3] = result;
  return result;
}

//----- (0805FA5E) --------------------------------------------------------
int sub_805FA5E()
{
  int result; // eax
  char *v1; // eax

  result = Cmd_Argc();
  if ( result == 2 )
  {
    v1 = Cmd_Argv(1u);
    result = atoi(v1);
    dword_818BE00 = result;
  }
  else
  {
    dword_818BE00 = 1;
  }
  return result;
}
// 818BE00: using guessed type int dword_818BE00;

//----- (0805FA96) --------------------------------------------------------
int *Cbuf_Init()
{
  int *result; // eax
  int i; // [esp+0h] [ebp-4h]

  for ( i = 0; i <= 0; ++i )
  {
    dword_818BE04[3 * i] = (int)&unk_818BE80 + 0x10000 * i;
    dword_818BE08[3 * i] = 0x10000;
    dword_818BE0C[3 * i] = 0;
    result = &i;
  }
  return result;
}
// 818BE04: using guessed type int dword_818BE04[];
// 818BE08: using guessed type int dword_818BE08[];
// 818BE0C: using guessed type int dword_818BE0C[];

//----- (0805FB06) --------------------------------------------------------
void __cdecl Cbuf_AddText(char *s)
{
  size_t n; // [esp+14h] [ebp-4h]

  n = strlen(s);
  if ( (signed int)(n + *(_DWORD *)(off_815A3DC + 8)) < *(_DWORD *)(off_815A3DC + 4) )
  {
    memcpy((void *)(*(_DWORD *)off_815A3DC + *(_DWORD *)(off_815A3DC + 8)), s, n);
    *(_DWORD *)(off_815A3DC + 8) += n;
  }
  else
  {
    Com_Printf("Cbuf_AddText: overflow\n");
  }
}
// 815A3DC: using guessed type int off_815A3DC;

//----- (0805FB7E) --------------------------------------------------------
void __cdecl Cbuf_InsertText(char *s)
{
  int i; // [esp+10h] [ebp-8h]
  size_t v2; // [esp+14h] [ebp-4h]

  v2 = strlen(s) + 1;
  if ( (signed int)(*(_DWORD *)(off_815A3DC + 8) + v2) <= *(_DWORD *)(off_815A3DC + 4) )
  {
    for ( i = *(_DWORD *)(off_815A3DC + 8) - 1; i >= 0; --i )
      *(_BYTE *)(*(_DWORD *)off_815A3DC + i + v2) = *(_BYTE *)(*(_DWORD *)off_815A3DC + i);
    memcpy(*(void **)off_815A3DC, s, v2 - 1);
    *(_BYTE *)(*(_DWORD *)off_815A3DC + v2 - 1) = 10;
    *(_DWORD *)(off_815A3DC + 8) += v2;
  }
  else
  {
    Com_Printf("Cbuf_InsertText overflowed\n");
  }
}
// 815A3DC: using guessed type int off_815A3DC;

//----- (0805FC38) --------------------------------------------------------
void __usercall Cbuf_ExecuteText(long double fst7_0@<st0>, int a1, char *s)
{
  if ( a1 == 1 )
  {
    Cbuf_InsertText(s);
  }
  else if ( a1 > 1 )
  {
    if ( a1 != 2 )
LABEL_13:
      Com_Error(0, &byte_813BB60);
    Cbuf_AddText(s);
  }
  else
  {
    if ( a1 )
      goto LABEL_13;
    if ( s && *s )
      Cmd_ExecuteString(fst7_0, s);
    else
      Cbuf_Execute(fst7_0);
  }
}

//----- (0805FCB2) --------------------------------------------------------
int __usercall sub_805FCB2@<eax>(long double a1@<st0>)
{
  int result; // eax
  unsigned __int8 v2; // [esp+1Ch] [ebp-101Ch]
  char dest[4104]; // [esp+20h] [ebp-1018h]
  void *src; // [esp+1028h] [ebp-10h]
  size_t n; // [esp+102Ch] [ebp-Ch]

  while ( 1 )
  {
    result = off_815A3DC;
    if ( !*(_DWORD *)(off_815A3DC + 8) )
      break;
    if ( dword_818BE00 )
    {
      --dword_818BE00;
      return result;
    }
    src = *(void **)off_815A3DC;
    v2 = 0;
    for ( n = 0; (signed int)n < *(_DWORD *)(off_815A3DC + 8); ++n )
    {
      if ( *((_BYTE *)src + n) == 34 )
        ++v2;
      if ( (v2 ^ 1) & 1 && *((_BYTE *)src + n) == 59 || *((_BYTE *)src + n) == 10 || *((_BYTE *)src + n) == 13 )
        break;
    }
    if ( (signed int)n > 4094 )
      n = 4095;
    memcpy(dest, src, n);
    dest[n] = 0;
    if ( n == *(_DWORD *)(off_815A3DC + 8) )
    {
      *(_DWORD *)(off_815A3DC + 8) = 0;
    }
    else
    {
      *(_DWORD *)(off_815A3DC + 8) -= ++n;
      memmove(src, (char *)src + n, *(_DWORD *)(off_815A3DC + 8));
    }
    Cmd_ExecuteString(a1, dest);
  }
  return result;
}
// 815A3DC: using guessed type int off_815A3DC;
// 818BE00: using guessed type int dword_818BE00;
// 805FCB2: using guessed type char dest[4104];

//----- (0805FDFC) --------------------------------------------------------
int __usercall Cbuf_Execute@<eax>(long double a1@<st0>)
{
  return sub_805FCB2(a1);
}

//----- (0805FE0A) --------------------------------------------------------
signed int __cdecl sub_805FE0A(_BYTE *a1)
{
  char *s; // [esp+14h] [ebp-4h]

  FS_ReadFile(a1, &s);
  if ( !s )
    return 0;
  Com_Printf("execing %s\n", a1);
  Cbuf_InsertText(s);
  FS_FreeFile(s);
  return 1;
}

//----- (0805FE66) --------------------------------------------------------
void sub_805FE66()
{
  char *v0; // eax
  char *v1; // eax
  char dest; // [esp+10h] [ebp-48h]

  if ( Cmd_Argc() == 2 )
  {
    v0 = Cmd_Argv(1u);
    I_strncpyz(&dest, v0, 64);
    Com_DefaultExtension(&dest, 0x40u, (int)".cfg");
    if ( !(unsigned __int8)sub_805FE0A(&dest) )
    {
      v1 = Cmd_Argv(1u);
      Com_Printf("couldn't exec %s\n", v1);
    }
  }
  else
  {
    Com_Printf("exec <filename> : execute a script file\n");
  }
}

//----- (0805FEF2) --------------------------------------------------------
void sub_805FEF2()
{
  char *v0; // eax
  char *v1; // [esp+10h] [ebp-8h]
  int v2; // [esp+14h] [ebp-4h]

  if ( Cmd_Argc() == 2 )
  {
    v1 = Cmd_Argv(1u);
    v2 = Dvar_FindVar(v1);
    if ( v2 )
    {
      if ( *(_BYTE *)(v2 + 6) == 7 || *(_BYTE *)(v2 + 6) == 6 )
      {
        v0 = va("%s\n", *(_DWORD *)(v2 + 8));
        Cbuf_InsertText(v0);
      }
      else
      {
        Com_Printf("%s is not a string-based dvar\n", *(_DWORD *)v2);
      }
    }
    else
    {
      Com_Printf("%s doesn't exist\n", v1);
    }
  }
  else
  {
    Com_Printf("vstr <variablename> : execute a variable command\n");
  }
}

//----- (0805FF92) --------------------------------------------------------
void sub_805FF92()
{
  char *v0; // eax
  int i; // [esp+14h] [ebp-4h]

  for ( i = 1; i < Cmd_Argc(); ++i )
  {
    v0 = Cmd_Argv(i);
    Com_Printf("^3%s ", v0);
  }
  Com_Printf("\n");
}

//----- (0805FFDC) --------------------------------------------------------
int Cmd_Argc()
{
  return dword_819BE80;
}
// 819BE80: using guessed type int dword_819BE80;

//----- (0805FFE6) --------------------------------------------------------
int sub_805FFE6()
{
  return dword_819BE80;
}
// 819BE80: using guessed type int dword_819BE80;

//----- (0805FFF0) --------------------------------------------------------
char *__cdecl Cmd_Argv(unsigned int a1)
{
  char *v2; // [esp+0h] [ebp-4h]

  if ( a1 < dword_819BE80 )
    v2 = dword_819BF00[a1];
  else
    v2 = (char *)&unk_813BC6B;
  return v2;
}
// 819BE80: using guessed type int dword_819BE80;

//----- (0806001C) --------------------------------------------------------
char *__cdecl sub_806001C(unsigned int a1)
{
  char *v2; // [esp+0h] [ebp-4h]

  if ( a1 < dword_819BE80 )
    v2 = dword_819BF00[a1];
  else
    v2 = (char *)&unk_813BC6B;
  return v2;
}
// 819BE80: using guessed type int dword_819BE80;

//----- (08060048) --------------------------------------------------------
char *__cdecl sub_8060048(int a1, char *dest, int a3)
{
  char *v3; // eax

  v3 = Cmd_Argv(a1);
  return I_strncpyz(dest, v3, a3);
}

//----- (08060074) --------------------------------------------------------
char *__cdecl sub_8060074(int a1, char *dest, int a3)
{
  char *v3; // eax

  v3 = sub_806001C(a1);
  return I_strncpyz(dest, v3, a3);
}

//----- (080600A0) --------------------------------------------------------
char *__cdecl sub_80600A0(int a1)
{
  int i; // [esp+14h] [ebp-4h]

  byte_819E980 = 0;
  for ( i = a1; i < dword_819BE80; ++i )
  {
    sub_80B57C0(&byte_819E980, 1024, dword_819BF00[i]);
    if ( i != dword_819BE80 - 1 )
      sub_80B57C0(&byte_819E980, 1024, " ");
  }
  return &byte_819E980;
}
// 819BE80: using guessed type int dword_819BE80;

//----- (08060118) --------------------------------------------------------
char *__cdecl sub_8060118(char *dest, int a2)
{
  char *v2; // eax

  v2 = sub_80600A0(1);
  return I_strncpyz(dest, v2, a2);
}

//----- (08060142) --------------------------------------------------------
int __cdecl Cmd_TokenizeStringInternal(_BYTE *a1, int a2, int a3, _BYTE *a4)
{
  _BYTE *v4; // edx
  _BYTE *v5; // edx
  _BYTE *v6; // edx
  int v9; // [esp+4h] [ebp-8h]
  int v10; // [esp+4h] [ebp-8h]
  _BYTE *v11; // [esp+8h] [ebp-4h]
  _BYTE *v12; // [esp+8h] [ebp-4h]

  v9 = 0;
  v11 = a1;
  while ( 1 )
  {
    if ( v9 == 512 )
      return 0;
    if ( !--a2 )
      break;
    while ( 1 )
    {
      while ( *v11 && *v11 <= 32 )
        ++v11;
      if ( !*v11 )
        return v9;
      if ( *v11 == 47 && v11[1] == 47 )
        return v9;
      if ( *v11 != 47 || v11[1] != 42 )
        break;
      while ( *v11 && (*v11 != 42 || v11[1] != 47) )
        ++v11;
      if ( !*v11 )
        return v9;
      v11 += 2;
    }
    if ( *v11 == 34 )
    {
      *(_DWORD *)(a3 + 4 * v9++) = a4;
      v12 = v11 + 1;
      while ( *v12 && *v12 != 34 )
      {
        if ( *v12 == 92 && v12[1] == 34 )
          ++v12;
        v4 = v12++;
        *a4++ = *v4;
      }
      *a4++ = 0;
      if ( !*v12 )
        return v9;
      v11 = v12 + 1;
      if ( !*v11 )
        return v9;
      if ( *v11 <= 32 )
        ++v11;
    }
    else
    {
      *(_DWORD *)(a3 + 4 * v9++) = a4;
      while ( *v11 > 32 && *v11 != 34 && (*v11 != 47 || v11[1] != 47) && (*v11 != 47 || v11[1] != 42) )
      {
        v5 = v11++;
        *a4++ = *v5;
      }
      *a4++ = 0;
      if ( !*v11 )
        return v9;
      if ( *v11 <= 32 )
        ++v11;
    }
  }
  if ( !*v11 )
    return v9;
  *(_DWORD *)(a3 + 4 * v9) = a4;
  v10 = v9 + 1;
  while ( *v11 )
  {
    v6 = v11++;
    *a4++ = *v6;
  }
  *a4 = 0;
  return v10;
}

//----- (080603CC) --------------------------------------------------------
int __cdecl sub_80603CC(_BYTE *a1, int a2)
{
  int result; // eax

  result = Cmd_TokenizeStringInternal(a1, a2, (int)dword_819BF00, &unk_819C700);
  dword_819BE80 = result;
  return result;
}
// 819BE80: using guessed type int dword_819BE80;

//----- (080603FC) --------------------------------------------------------
int __cdecl sub_80603FC(_BYTE *a1, int a2)
{
  int result; // eax

  result = Cmd_TokenizeStringInternal(a1, a2, (int)dword_819BF00, &unk_819C700);
  dword_819BE80 = result;
  return result;
}
// 819BE80: using guessed type int dword_819BE80;

//----- (0806042C) --------------------------------------------------------
int __cdecl Cmd_TokenizeString(_BYTE *a1)
{
  return sub_80603CC(a1, 0);
}

//----- (08060448) --------------------------------------------------------
int __cdecl sub_8060448(_BYTE *a1)
{
  return sub_80603FC(a1, 0);
}

//----- (08060464) --------------------------------------------------------
int __cdecl sub_8060464(char *s1)
{
  int i; // [esp+14h] [ebp-4h]

  for ( i = dword_819E900; i; i = *(_DWORD *)i )
  {
    if ( !strcmp(s1, *(const char **)(i + 4)) )
      return i;
  }
  return 0;
}
// 819E900: using guessed type int dword_819E900;

//----- (080604B2) --------------------------------------------------------
void __cdecl Cmd_AddCommand(char *s1, int a2)
{
  _DWORD *v2; // ebx

  if ( sub_8060464(s1) )
  {
    if ( a2 )
      Com_Printf("Cmd_AddCommand: %s already defined\n", s1);
  }
  else
  {
    v2 = Z_MallocInternal(0x14u);
    v2[1] = sub_80A93B0(s1);
    v2[4] = a2;
    *v2 = dword_819E900;
    dword_819E900 = (int)v2;
  }
}
// 819E900: using guessed type int dword_819E900;

//----- (0806052A) --------------------------------------------------------
void __cdecl Cmd_RemoveCommand(char *s1)
{
  const char ***i; // [esp+10h] [ebp-8h]
  const char **ptr; // [esp+14h] [ebp-4h]

  for ( i = (const char ***)&dword_819E900; ; i = (const char ***)ptr )
  {
    ptr = *i;
    if ( !*i )
      break;
    if ( !strcmp(s1, ptr[1]) )
    {
      *i = (const char **)*ptr;
      if ( ptr[1] )
        Z_FreeInternal((void *)ptr[1]);
      Z_FreeInternal(ptr);
      return;
    }
  }
}
// 819E900: using guessed type int dword_819E900;

//----- (08060598) --------------------------------------------------------
int __cdecl sub_8060598(char *s1, int a2, int a3)
{
  int v3; // eax
  int v4; // edx
  int result; // eax

  v3 = sub_8060464(s1);
  *(_DWORD *)(v3 + 8) = a2;
  v4 = v3;
  result = a3;
  *(_DWORD *)(v4 + 12) = a3;
  return result;
}

//----- (080605C0) --------------------------------------------------------
void sub_80605C0()
{
  void **ptr; // ST04_4

  while ( dword_819E900 )
  {
    ptr = (void **)dword_819E900;
    dword_819E900 = *(_DWORD *)dword_819E900;
    Z_FreeInternal(ptr[1]);
    Z_FreeInternal(ptr);
  }
}
// 819E900: using guessed type int dword_819E900;

//----- (08060604) --------------------------------------------------------
int __cdecl sub_8060604(void (__cdecl *a1)(int))
{
  int result; // eax
  int *i; // [esp+4h] [ebp-4h]

  result = dword_819E900;
  for ( i = (int *)dword_819E900; i; i = (int *)*i )
  {
    a1(i[1]);
    result = *i;
  }
  return result;
}
// 819E900: using guessed type int dword_819E900;

//----- (08060634) --------------------------------------------------------
_DWORD *__cdecl sub_8060634(char *s1, int a2)
{
  _DWORD *v3; // [esp+20h] [ebp-8h]
  int v4; // [esp+24h] [ebp-4h]

  *(_DWORD *)a2 = 0;
  v4 = sub_8060464(s1);
  if ( *(_DWORD *)(v4 + 8) && *(_DWORD *)(v4 + 12) )
    v3 = sub_809F7B2(*(_DWORD *)(v4 + 8), *(char **)(v4 + 12), 0, a2);
  else
    v3 = 0;
  return v3;
}

//----- (080606A2) --------------------------------------------------------
int __usercall Cmd_ExecuteString@<eax>(long double a1@<st0>, _BYTE *a2)
{
  int result; // eax
  int *i; // [esp+10h] [ebp-8h]
  int v4; // [esp+14h] [ebp-4h]

  Cmd_TokenizeString(a2);
  result = Cmd_Argc();
  if ( result )
  {
    for ( i = &dword_819E900; *i; i = (int *)v4 )
    {
      v4 = *i;
      if ( !I_stricmp(dword_819BF00[0], *(char **)(*i + 4)) )
      {
        *i = *(_DWORD *)v4;
        *(_DWORD *)v4 = dword_819E900;
        dword_819E900 = v4;
        if ( *(_DWORD *)(v4 + 16) )
          return (*(int (**)(void))(v4 + 16))();
        break;
      }
    }
    result = Dvar_Command(a1);
    if ( !result && com_sv_running )
    {
      result = com_sv_running;
      if ( *(_BYTE *)(com_sv_running + 8) )
        result = CL_ForwardCommandToServer(a1);
    }
  }
  return result;
}
// 819E900: using guessed type int dword_819E900;
// 819EF14: using guessed type int com_sv_running;

//----- (08060754) --------------------------------------------------------
int __usercall sub_8060754@<eax>(long double a1@<st0>, _BYTE *a2)
{
  return Cmd_ExecuteString(a1, a2);
}

//----- (08060768) --------------------------------------------------------
void sub_8060768()
{
  char *v0; // [esp+Ch] [ebp-Ch]
  int v1; // [esp+10h] [ebp-8h]
  int i; // [esp+14h] [ebp-4h]

  if ( Cmd_Argc() <= 1 )
    v0 = 0;
  else
    v0 = Cmd_Argv(1u);
  v1 = 0;
  for ( i = dword_819E900; i; i = *(_DWORD *)i )
  {
    if ( !v0 || (unsigned __int8)Com_Filter((int)v0, *(char **)(i + 4), 0) )
    {
      Com_Printf("%s\n", *(_DWORD *)(i + 4));
      ++v1;
    }
  }
  Com_Printf("%i commands\n", v1);
}
// 819E900: using guessed type int dword_819E900;

//----- (0806080A) --------------------------------------------------------
void Cmd_Init()
{
  Cmd_AddCommand("cmdlist", (int)sub_8060768);
  Cmd_AddCommand("exec", (int)sub_805FE66);
  Cmd_AddCommand("vstr", (int)sub_805FEF2);
  Cmd_AddCommand("wait", (int)sub_805FA5E);
}

//----- (08060864) --------------------------------------------------------
size_t __cdecl FS_FileRead(void *ptr, size_t size, size_t n, FILE *stream)
{
  return fread(ptr, size, n, stream);
}

//----- (08060892) --------------------------------------------------------
size_t __cdecl FS_FileWrite(void *ptr, size_t size, size_t n, FILE *s)
{
  return fwrite(ptr, size, n, s);
}

//----- (080608BA) --------------------------------------------------------
FILE *__cdecl FS_FileOpen(char *filename, char *modes)
{
  return fopen(filename, modes);
}

//----- (080608DA) --------------------------------------------------------
int __cdecl FS_FileClose(FILE *stream)
{
  return fclose(stream);
}

//----- (080608EE) --------------------------------------------------------
int __cdecl FS_FileSeek(FILE *stream, int off, int whence)
{
  return fseek(stream, off, whence);
}

//----- (08060918) --------------------------------------------------------
int Hunk_ClearTempMemoryHigh()
{
  return 0;
}

//----- (08060924) --------------------------------------------------------
void sub_8060924()
{
  ;
}

//----- (0806092A) --------------------------------------------------------
char *__cdecl sub_806092A(char *a1, int a2, int a3)
{
  char *result; // eax

  if ( a1 && a2 )
  {
    if ( a3 )
    {
      dword_81A1C94 = a1;
      dword_81A1C98 = a2;
      dword_81A1C9C = (int (__cdecl *)(_DWORD))a3;
      result = a1;
      *a1 = 0;
    }
  }
  return result;
}
// 81A1C9C: using guessed type int (__cdecl *dword_81A1C9C)(_DWORD);

//----- (08060964) --------------------------------------------------------
int sub_8060964()
{
  int result; // eax

  if ( dword_81A1C9C )
    result = dword_81A1C9C(dword_81A1C94);
  dword_81A1C94 = 0;
  dword_81A1C98 = 0;
  dword_81A1C9C = 0;
  return result;
}
// 81A1C9C: invalid function type has been ignored
// 81A1C9C: using guessed type int (__cdecl *dword_81A1C9C)(_DWORD);

//----- (080609A2) --------------------------------------------------------
void CL_SwitchToLocalClient()
{
  ;
}

//----- (080609A8) --------------------------------------------------------
void __cdecl Com_PrintMessage(int a1, char *s)
{
  size_t v2; // ebx
  char *v3; // eax
  size_t v4; // eax
  time_t timer; // [esp+Ch] [ebp-Ch]
  struct tm *tp; // [esp+10h] [ebp-8h]

  if ( dword_81A1C94 )
  {
    if ( a1 != 4 )
    {
      v2 = strlen(s);
      if ( strlen(dword_81A1C94) + v2 > dword_81A1C98 - 1 )
      {
        dword_81A1C9C(dword_81A1C94);
        *dword_81A1C94 = 0;
      }
      sub_80B57C0(dword_81A1C94, dword_81A1C98, s);
    }
  }
  else
  {
    if ( *s == 94 && s[1] )
      s += 2;
    if ( a1 != 4 )
      sub_80D24F4(s);
    if ( com_logfile && *(_DWORD *)(com_logfile + 8) && FS_Initialized() )
    {
      if ( !logfile && !dword_81A1CA0 )
      {
        dword_81A1CA0 = 1;
        time(&timer);
        tp = localtime(&timer);
        logfile = FS_FOpenTextFileWrite("console_mp_server.log");
        v3 = asctime(tp);
        Com_Printf("logfile opened on %s\n", v3);
        dword_81A1CA0 = 0;
      }
      if ( logfile )
      {
        v4 = strlen(s);
        sub_809E454(s, v4, logfile);
        if ( *(_DWORD *)(com_logfile + 8) > 1 )
          sub_80A1380(logfile);
      }
    }
  }
}
// 819EEF4: using guessed type int logfile;
// 819EF18: using guessed type int com_logfile;
// 81A1C9C: using guessed type int (__cdecl *dword_81A1C9C)(_DWORD);
// 81A1CA0: using guessed type int dword_81A1CA0;

//----- (08060B2C) --------------------------------------------------------
void Com_Printf(char *format, ...)
{
  char s; // [esp+10h] [ebp-1018h]
  char v2; // [esp+100Fh] [ebp-19h]
  __gnuc_va_list __varargs; // [esp+101Ch] [ebp-Ch]
  va_list va; // [esp+1034h] [ebp+Ch]

  va_start(va, format);
  va_copy(__varargs, va);
  vsnprintf(&s, 0x1000u, format, va);
  v2 = 0;
  Com_PrintMessage(0, &s);
}

//----- (08060B7C) --------------------------------------------------------
void Com_DPrintf(char *format, ...)
{
  char s; // [esp+10h] [ebp-1018h]
  char v2; // [esp+100Fh] [ebp-19h]
  __gnuc_va_list __varargs; // [esp+101Ch] [ebp-Ch]
  va_list va; // [esp+1034h] [ebp+Ch]

  va_start(va, format);
  if ( com_developer )
  {
    if ( *(_DWORD *)(com_developer + 8) )
    {
      va_copy(__varargs, va);
      vsnprintf(&s, 0x1000u, format, va);
      v2 = 0;
      Com_Printf("%s", &s);
    }
  }
}
// 819EEFC: using guessed type int com_developer;

//----- (08060BE2) --------------------------------------------------------
void *__usercall Com_ShutdownInternal@<eax>(long double a1@<st0>, int a2)
{
  SV_Shutdown(a1, a2);
  return Com_Restart(a1);
}

//----- (08060BFA) --------------------------------------------------------
void *__usercall sub_8060BFA@<eax>(long double a1@<st0>, int a2)
{
  return Com_ShutdownInternal(a1, a2);
}

//----- (08060C0E) --------------------------------------------------------
int Hunk_ClearTempMemory()
{
  sub_80AA124();
  return sub_80A9DB4();
}

//----- (08060C2E) --------------------------------------------------------
int __cdecl sub_8060C2E(char *s2)
{
  int i; // [esp+14h] [ebp-4h]

  for ( i = 0; *(&off_815A3E0)[i]; ++i )
  {
    if ( !strcasecmp((&off_815A3E0)[i], s2) )
      return 1;
  }
  return 0;
}

//----- (08060C86) --------------------------------------------------------
void __usercall Com_SetErrorMessage(long double a1@<st0>, char *src)
{
  ui_errorMessage = (int)Dvar_RegisterString(a1, "com_errorMessage", (int)&unk_813BDA4, 4160);
  ui_errorTitle = (int)Dvar_RegisterString(a1, "com_errorTitle", (int)&unk_813BDA4, 4160);
  Dvar_SetString(ui_errorMessage, src);
}
// 819FF84: using guessed type int ui_errorTitle;

//----- (08060CE4) --------------------------------------------------------
void *__usercall Com_ErrorCleanup@<eax>(long double a1@<st0>)
{
  void *result; // eax
  char dest; // [esp+10h] [ebp-1018h]
  int v3; // [esp+101Ch] [ebp-Ch]

  LargeLocalReset();
  Dvar_SetInAutoExec(0);
  Hunk_ClearTempMemory();
  Hunk_ClearTempMemoryHigh();
  Dvar_SetIntByName(a1, "cl_paused", 0);
  FS_PureServerSetLoadedIwds(&unk_813BDA4, &unk_813BDA4);
  strcpy(&dest, com_errorMessage);
  if ( com_errorType != 3 )
    Com_SetErrorMessage(a1, com_errorMessage);
  if ( com_errorType != 3 )
    Scr_Abort();
  SND_ErrorCleanup();
  Com_CleanupBsp();
  CM_Cleanup();
  Com_ResetParseSessions();
  if ( com_errorType == 1 )
    Cbuf_Init();
  v3 = Sys_MilliSeconds();
  if ( v3 - currentTime > 99 )
  {
    errorCount = 0;
  }
  else if ( ++errorCount > 3 )
  {
    com_errorType = 0;
  }
  currentTime = v3;
  if ( com_errorType != 2 && com_errorType != 1 && com_errorType != 3 )
    Sys_Error("%s", com_errorMessage);
  if ( com_errorType == 2 )
  {
    result = Com_ShutdownInternal(a1, (int)"EXE_DISCONNECTEDFROMOWNLISTENSERVER");
  }
  else
  {
    Com_Printf("********************\nERROR: %s\n********************\n", com_errorMessage);
    result = Com_ShutdownInternal(a1, (int)&dest);
    if ( com_errorType == 1 )
    {
      result = (void *)QuitOnError();
      if ( (_BYTE)result )
        Com_Quit_f(a1);
    }
  }
  com_fixedConsolePosition = 0;
  com_errorEntered = 0;
  return result;
}
// 819EEEC: using guessed type int com_errorType;
// 819EF50: using guessed type int com_errorEntered;
// 819EF54: using guessed type int com_fixedConsolePosition;
// 81A1CA8: using guessed type int currentTime;
// 81A1CAC: using guessed type int errorCount;

//----- (08060E66) --------------------------------------------------------
void __noreturn Com_Error(int a1, char *format, ...)
{
  struct __jmp_buf_tag *v2; // eax
  va_list va; // [esp+28h] [ebp+10h]

  va_start(va, format);
  if ( com_errorEntered )
    Sys_Error("recursive error after: %s", com_errorMessage);
  com_errorEntered = 1;
  vsnprintf(com_errorMessage, 0x1000u, format, va);
  byte_819FF7F = 0;
  if ( a1 != 4 && a1 != 6 )
  {
    if ( a1 == 5 )
      a1 = 1;
    else
      com_fixedConsolePosition = 0;
  }
  else
  {
    a1 = 1;
  }
  com_errorType = a1;
  v2 = (struct __jmp_buf_tag *)Sys_GetValue(2);
  longjmp(v2, -1);
}
// 819EEEC: using guessed type int com_errorType;
// 819EF50: using guessed type int com_errorEntered;
// 819EF54: using guessed type int com_fixedConsolePosition;
// 819FF7F: using guessed type char byte_819FF7F;

//----- (08060F48) --------------------------------------------------------
void __usercall __noreturn Com_Quit_f(long double a1@<st0>)
{
  Com_Printf("quitting...\n");
  if ( !com_errorEntered )
  {
    Hunk_ClearTempMemory();
    SV_Shutdown(a1, (int)"EXE_SERVERQUIT");
    Com_Close();
    Com_CloseLogFile();
    FS_Shutdown();
    FS_ShutdownServerIwdNames();
    FS_ShutdownServerReferencedIwds();
  }
  Sys_Quit();
}
// 819EF50: using guessed type int com_errorEntered;

//----- (08060F9C) --------------------------------------------------------
char *__cdecl Com_ParseCommandLine(char *a1)
{
  char *result; // eax

  dword_81A1CC0[0] = a1;
  dword_81A1CB0 = 1;
  while ( 1 )
  {
    result = a1;
    if ( !*a1 )
      break;
    result = a1;
    if ( *a1 == 43 || (result = a1, *a1 == 10) )
    {
      if ( dword_81A1CB0 == 32 )
        return result;
      dword_81A1CC0[dword_81A1CB0++] = a1 + 1;
      *a1 = 0;
    }
    ++a1;
  }
  return result;
}
// 81A1CB0: using guessed type int dword_81A1CB0;

//----- (08060FFC) --------------------------------------------------------
signed int Com_SafeMode()
{
  char *v0; // eax
  char *v1; // eax
  int i; // [esp+14h] [ebp-4h]

  for ( i = 0; i < dword_81A1CB0; ++i )
  {
    Cmd_TokenizeString(dword_81A1CC0[i]);
    v0 = Cmd_Argv(0);
    if ( I_stricmp(v0, "safe") )
    {
      v1 = Cmd_Argv(0);
      if ( I_stricmp(v1, "dvar_restart") )
        continue;
    }
    *dword_81A1CC0[i] = 0;
    return 1;
  }
  return dword_81A1C88;
}
// 81A1C88: using guessed type int dword_81A1C88;
// 81A1CB0: using guessed type int dword_81A1CB0;

//----- (080610A2) --------------------------------------------------------
int __usercall Com_StartupVariable@<eax>(long double a1@<st0>, char *s2)
{
  int result; // eax
  char *v3; // eax
  char *v4; // eax
  char *v5; // eax
  int i; // [esp+14h] [ebp-4h]

  for ( i = 0; ; ++i )
  {
    result = i;
    if ( i >= dword_81A1CB0 )
      break;
    Cmd_TokenizeString(dword_81A1CC0[i]);
    if ( s2 )
    {
      v3 = Cmd_Argv(1u);
      if ( strcmp(v3, s2) )
        continue;
    }
    v4 = Cmd_Argv(0);
    if ( !strcasecmp(v4, "set") )
    {
      Dvar_Set_f(a1);
    }
    else
    {
      v5 = Cmd_Argv(0);
      if ( !strcasecmp(v5, "seta") )
        Dvar_SetA_f(a1);
    }
  }
  return result;
}
// 81A1CB0: using guessed type int dword_81A1CB0;

//----- (08061150) --------------------------------------------------------
signed int Com_AddStartupCommands()
{
  signed int v1; // [esp+10h] [ebp-8h]
  int i; // [esp+14h] [ebp-4h]

  v1 = 0;
  for ( i = 0; i < dword_81A1CB0; ++i )
  {
    if ( dword_81A1CC0[i] && *dword_81A1CC0[i] )
    {
      if ( sub_80B550A(dword_81A1CC0[i], "set", 3) )
        v1 = 1;
      Cbuf_AddText(dword_81A1CC0[i]);
      Cbuf_AddText("\n");
    }
  }
  return v1;
}
// 81A1CB0: using guessed type int dword_81A1CB0;

//----- (080611E6) --------------------------------------------------------
void __cdecl sub_80611E6(char *a1)
{
  char *v1; // eax
  char *v2; // eax
  char *s; // [esp+1Ch] [ebp-40Ch]
  char *sa; // [esp+1Ch] [ebp-40Ch]
  char v5; // [esp+20h] [ebp-408h]
  char v6; // [esp+220h] [ebp-208h]
  char v7; // [esp+234h] [ebp-1F4h]

  if ( *a1 == 92 )
    ++a1;
  while ( *a1 )
  {
    s = &v6;
    while ( *a1 && *a1 != 92 )
    {
      v1 = a1++;
      *s++ = *v1;
    }
    if ( s - &v6 > 19 )
    {
      *s = 0;
    }
    else
    {
      memset(s, 32, 20 - (s - &v6));
      v7 = 0;
    }
    Com_Printf("%s", &v6);
    if ( !*a1 )
    {
      Com_Printf("MISSING VALUE\n");
      return;
    }
    sa = &v5;
    ++a1;
    while ( *a1 && *a1 != 92 )
    {
      v2 = a1++;
      *sa++ = *v2;
    }
    *sa = 0;
    if ( *a1 )
      ++a1;
    Com_Printf("%s\n", &v5);
  }
}

//----- (08061334) --------------------------------------------------------
void *Com_InitPushEvent()
{
  void *result; // eax

  result = memset(dword_81A0000, 0, 0x1800u);
  dword_819FF88 = 0;
  dword_819FF8C = 0;
  return result;
}
// 819FF88: using guessed type int dword_819FF88;
// 819FF8C: using guessed type int dword_819FF8C;
// 81A0000: using guessed type int dword_81A0000[];

//----- (0806136C) --------------------------------------------------------
int __cdecl sub_806136C(int *a1)
{
  int result; // eax
  int *v2; // [esp+4h] [ebp-4h]

  v2 = &dword_81A0000[6 * (unsigned __int8)dword_819FF88];
  if ( dword_819FF88 - dword_819FF8C <= 255 )
  {
    dword_81A1D40 = 0;
  }
  else
  {
    if ( !dword_81A1D40 )
    {
      dword_81A1D40 = 1;
      Com_Printf("WARNING: Com_PushEvent overflow\n");
    }
    if ( v2[5] )
      Z_FreeInternal((void *)v2[5]);
    ++dword_819FF8C;
  }
  *v2 = *a1;
  v2[1] = a1[1];
  v2[2] = a1[2];
  v2[3] = a1[3];
  v2[4] = a1[4];
  result = a1[5];
  v2[5] = result;
  ++dword_819FF88;
  return result;
}
// 819FF88: using guessed type int dword_819FF88;
// 819FF8C: using guessed type int dword_819FF8C;
// 81A0000: using guessed type int dword_81A0000[];
// 81A1D40: using guessed type int dword_81A1D40;

//----- (0806141C) --------------------------------------------------------
int sub_806141C()
{
  int result; // eax
  int v1; // edx
  int v2; // ST10_4
  int v3; // ST14_4
  int v4; // ST18_4
  int v5; // ST1C_4
  int v6; // ST20_4
  void *ptr; // [esp+24h] [ebp-14h]

  while ( 1 )
  {
    result = dword_819FF88;
    if ( dword_819FF88 <= dword_819FF8C )
      break;
    v1 = 6 * (unsigned __int8)dword_819FF8C;
    v2 = dword_81A0000[v1];
    v3 = dword_81A0004[v1];
    v4 = dword_81A0008[v1];
    v5 = dword_81A000C[v1];
    v6 = dword_81A0010[v1];
    ptr = (void *)dword_81A0014[v1];
    ++dword_819FF8C;
    if ( ptr )
      Z_FreeInternal(ptr);
  }
  return result;
}
// 819FF88: using guessed type int dword_819FF88;
// 819FF8C: using guessed type int dword_819FF8C;
// 81A0000: using guessed type int dword_81A0000[];
// 81A0004: using guessed type int dword_81A0004[];
// 81A0008: using guessed type int dword_81A0008[];
// 81A000C: using guessed type int dword_81A000C[];
// 81A0010: using guessed type int dword_81A0010[];
// 81A0014: using guessed type int dword_81A0014[];

//----- (08061498) --------------------------------------------------------
_DWORD *__stdcall sub_8061498(_DWORD *a1)
{
  int v1; // edx

  if ( dword_819FF88 <= dword_819FF8C )
  {
    sub_80D2262(a1);
  }
  else
  {
    v1 = 6 * (unsigned __int8)(++dword_819FF8C - 1);
    *a1 = dword_81A0000[v1];
    a1[1] = dword_81A0004[v1];
    a1[2] = dword_81A0008[v1];
    a1[3] = dword_81A000C[v1];
    a1[4] = dword_81A0010[v1];
    a1[5] = dword_81A0014[v1];
  }
  return a1;
}
// 819FF88: using guessed type int dword_819FF88;
// 819FF8C: using guessed type int dword_819FF8C;
// 81A0000: using guessed type int dword_81A0000[];
// 81A0004: using guessed type int dword_81A0004[];
// 81A0008: using guessed type int dword_81A0008[];
// 81A000C: using guessed type int dword_81A000C[];
// 81A0010: using guessed type int dword_81A0010[];
// 81A0014: using guessed type int dword_81A0014[];

//----- (08061526) --------------------------------------------------------
int __usercall sub_8061526@<eax>(long double a1@<st0>)
{
  int v1; // ebx
  int v3; // [esp+30h] [ebp-A8h]
  int v4; // [esp+34h] [ebp-A4h]
  int v5; // [esp+38h] [ebp-A0h]
  int v6; // [esp+3Ch] [ebp-9Ch]
  int v7; // [esp+40h] [ebp-98h]
  void *v8; // [esp+44h] [ebp-94h]
  char v9[4]; // [esp+5Ch] [ebp-7Ch]
  char v10; // [esp+60h] [ebp-78h]
  int s; // [esp+70h] [ebp-68h]
  int v12; // [esp+74h] [ebp-64h]
  int v13; // [esp+78h] [ebp-60h]
  int v14; // [esp+7Ch] [ebp-5Ch]
  int v15; // [esp+80h] [ebp-58h]
  int v16; // [esp+90h] [ebp-48h]
  void *dest; // [esp+94h] [ebp-44h]
  unsigned int v18; // [esp+98h] [ebp-40h]
  size_t n; // [esp+9Ch] [ebp-3Ch]
  int v20; // [esp+B0h] [ebp-28h]
  char v21[4]; // [esp+B4h] [ebp-24h]
  int v22; // [esp+B8h] [ebp-20h]
  int v23; // [esp+BCh] [ebp-1Ch]
  int v24; // [esp+C0h] [ebp-18h]
  void *ptr; // [esp+C4h] [ebp-14h]

  sub_80AA1F6((int *)&v10, 0x4000);
  *(_DWORD *)v9 = sub_80AA240((int *)&v10);
  sub_8067718(&v16, *(int *)v9, 0x4000);
  while ( 1 )
  {
    while ( 1 )
    {
      sub_8061498(&v3);
      v20 = v3;
      *(_DWORD *)v21 = v4;
      v22 = v5;
      v23 = v6;
      v24 = v7;
      ptr = v8;
      if ( v4 != 4 )
        break;
      CL_SwitchToLocalClient();
      Cbuf_AddText((char *)ptr);
      Z_FreeInternal(ptr);
      Cbuf_AddText("\n");
    }
    if ( v4 <= 4 )
      break;
    if ( v4 != 5 )
      goto LABEL_7;
    s = *(_DWORD *)ptr;
    v12 = *((_DWORD *)ptr + 1);
    v13 = *((_DWORD *)ptr + 2);
    v14 = *((_DWORD *)ptr + 3);
    v15 = *((_DWORD *)ptr + 4);
    n = v24 - 20;
    if ( v24 - 20 <= v18 )
    {
      memcpy(dest, (char *)ptr + 20, n);
      Z_FreeInternal(ptr);
      if ( *(_BYTE *)(com_sv_running + 8) )
      {
        CL_SwitchToLocalClient();
        sub_80941AE(a1, s, v12, v13, v14, v15, &v16);
      }
    }
    else
    {
      Z_FreeInternal(ptr);
      Com_Printf("Com_EventLoop: oversize packet\n");
    }
  }
  if ( v4 )
LABEL_7:
    Com_Error(0, &byte_813BF00, *(_DWORD *)v21);
  while ( sub_806C240(1, &s, (int)&v16) )
  {
    CL_SwitchToLocalClient();
    if ( *(_BYTE *)(com_sv_running + 8) )
      sub_80941AE(a1, s, v12, v13, v14, v15, &v16);
  }
  v1 = v20;
  sub_80AA22A((int *)&v10);
  return v1;
}
// 819EF14: using guessed type int com_sv_running;

//----- (080617B4) --------------------------------------------------------
int sub_80617B4()
{
  int v1; // [esp+20h] [ebp-58h]
  int v2; // [esp+24h] [ebp-54h]
  int v3; // [esp+28h] [ebp-50h]
  int v4; // [esp+2Ch] [ebp-4Ch]
  int v5; // [esp+30h] [ebp-48h]
  void *v6; // [esp+34h] [ebp-44h]
  int i; // [esp+4Ch] [ebp-2Ch]
  int v8; // [esp+50h] [ebp-28h]
  char v9[4]; // [esp+54h] [ebp-24h]
  int v10; // [esp+58h] [ebp-20h]
  int v11; // [esp+5Ch] [ebp-1Ch]
  int v12; // [esp+60h] [ebp-18h]
  void *ptr; // [esp+64h] [ebp-14h]

  for ( i = 0; ; i = 1 )
  {
    sub_8061498(&v1);
    v8 = v1;
    *(_DWORD *)v9 = v2;
    v10 = v3;
    v11 = v4;
    v12 = v5;
    ptr = v6;
    if ( v2 == 4 )
    {
      Cbuf_AddText((char *)ptr);
      Z_FreeInternal(ptr);
      Cbuf_AddText("\n");
      continue;
    }
    if ( v2 <= 4 )
      break;
    if ( v2 != 5 )
      goto LABEL_7;
    Z_FreeInternal(ptr);
  }
  if ( v2 )
LABEL_7:
    Com_Error(0, &byte_813BF00, *(_DWORD *)v9);
  return i;
}

//----- (08061878) --------------------------------------------------------
int Com_Milliseconds()
{
  int v1; // [esp+10h] [ebp-48h]
  int v2; // [esp+14h] [ebp-44h]
  int v3; // [esp+18h] [ebp-40h]
  int v4; // [esp+1Ch] [ebp-3Ch]
  int v5; // [esp+20h] [ebp-38h]
  int v6; // [esp+24h] [ebp-34h]
  int v7; // [esp+30h] [ebp-28h]
  int v8; // [esp+34h] [ebp-24h]
  int v9; // [esp+38h] [ebp-20h]
  int v10; // [esp+3Ch] [ebp-1Ch]
  int v11; // [esp+40h] [ebp-18h]
  int v12; // [esp+44h] [ebp-14h]

  do
  {
    sub_80D2262(&v1);
    v7 = v1;
    v8 = v2;
    v9 = v3;
    v10 = v4;
    v11 = v5;
    v12 = v6;
    if ( v2 )
      sub_806136C(&v7);
  }
  while ( v8 );
  return v7;
}

//----- (080618CE) --------------------------------------------------------
int sub_80618CE()
{
  int result; // eax
  int v1; // [esp+10h] [ebp-48h]
  int v2; // [esp+14h] [ebp-44h]
  int v3; // [esp+18h] [ebp-40h]
  int v4; // [esp+1Ch] [ebp-3Ch]
  int v5; // [esp+20h] [ebp-38h]
  int v6; // [esp+24h] [ebp-34h]
  int v7; // [esp+30h] [ebp-28h]
  int v8; // [esp+34h] [ebp-24h]
  int v9; // [esp+38h] [ebp-20h]
  int v10; // [esp+3Ch] [ebp-1Ch]
  int v11; // [esp+40h] [ebp-18h]
  int v12; // [esp+44h] [ebp-14h]

  while ( 1 )
  {
    sub_80D2262(&v1);
    v7 = v1;
    v8 = v2;
    v9 = v3;
    v10 = v4;
    v11 = v5;
    result = v6;
    v12 = v6;
    if ( !v2 )
      break;
    sub_806136C(&v7);
  }
  return result;
}

//----- (0806191E) --------------------------------------------------------
void __noreturn sub_806191E()
{
  if ( Cmd_Argc() > 1 )
    Com_Error(1, &byte_813BF60);
  Com_Error(0, &byte_813BF74);
}

//----- (0806195A) --------------------------------------------------------
void sub_806195A()
{
  char *v0; // eax
  int v1; // [esp+10h] [ebp-8h]
  float v2; // [esp+14h] [ebp-4h]

  if ( Cmd_Argc() == 2 )
  {
    v0 = Cmd_Argv(1u);
    v2 = atof(v0);
    v1 = Com_Milliseconds();
    while ( (long double)(Com_Milliseconds() - v1) * 0.001 <= v2 )
      ;
  }
  else
  {
    Com_Printf("freeze <seconds>\n");
  }
}

//----- (080619C8) --------------------------------------------------------
void sub_80619C8()
{
  MEMORY[0] = 305419896;
}

//----- (080619D8) --------------------------------------------------------
bool Scr_Settings()
{
  int v1; // [esp+Ch] [ebp-Ch]

  v1 = 0;
  if ( *(_DWORD *)(com_developer + 8) || *(_DWORD *)(com_logfile + 8) )
    v1 = 1;
  return sub_807F988(v1, *(unsigned __int8 *)(com_developer_script + 8), *(_DWORD *)(com_developer + 8));
}
// 819EEFC: using guessed type int com_developer;
// 819EF00: using guessed type int com_developer_script;
// 819EF18: using guessed type int com_logfile;

//----- (08061A36) --------------------------------------------------------
void Com_SetCinematic()
{
  if ( !*(_DWORD *)(com_dedicated + 8) && !*(_BYTE *)(com_introPlayed + 8) )
  {
    Cbuf_AddText("cinematic atvi\n");
    Dvar_SetString(nextmap, "cinematic IW_logo; set nextmap cinematic cod_intro");
    Dvar_SetBool(com_introPlayed, 1);
  }
}
// 819EF24: using guessed type int com_introPlayed;
// 8494204: using guessed type int com_dedicated;

//----- (08061A8E) --------------------------------------------------------
void __usercall Com_InitDvars(long double a1@<st0>)
{
  com_dedicated = (int)Dvar_RegisterInt(a1, "dedicated", 2, 0, 2, 4160);
  com_maxfps = (int)Dvar_RegisterInt(a1, "com_maxfps", 85, 0, 1000, 4097);
  com_developer = (int)Dvar_RegisterInt(a1, "developer", 0, 0, 2, 4096);
  com_developer_script = (int)Dvar_RegisterBool(a1, "developer_script", 0, 4096);
  com_logfile = (int)Dvar_RegisterInt(a1, "logfile", 0, 0, 2, 4096);
  com_timescale = (int)Dvar_RegisterFloat(a1, "timescale", 1065353216, 981668463, 1148846080, 4232);
  com_fixedtime = (int)Dvar_RegisterInt(a1, "fixedtime", 0, 0, 1000, 4224);
  com_viewlog = (int)Dvar_RegisterInt(a1, "viewlog", 0, 0, 2, 4224);
  sv_paused = (int)Dvar_RegisterInt(a1, "sv_paused", 0, 0, 2, 4160);
  cl_paused = (int)Dvar_RegisterInt(a1, "cl_paused", 0, 0, 2, 4160);
  com_sv_running = (int)Dvar_RegisterBool(a1, "sv_running", 0, 4160);
  *((_DWORD *)off_815A498 + 1) = 0;
  com_introPlayed = (int)Dvar_RegisterBool(a1, "com_introPlayed", 0, 4097);
  com_animCheck = (int)Dvar_RegisterBool(a1, "com_animCheck", 0, 4096);
  if ( *(_DWORD *)(com_dedicated + 8) )
  {
    if ( !*(_DWORD *)(com_viewlog + 8) )
      Dvar_SetInt(com_viewlog, (char *)1);
  }
}
// 815A498: using guessed type void *off_815A498;
// 819EEF8: using guessed type int com_viewlog;
// 819EEFC: using guessed type int com_developer;
// 819EF00: using guessed type int com_developer_script;
// 819EF04: using guessed type int com_timescale;
// 819EF0C: using guessed type int com_fixedtime;
// 819EF10: using guessed type int com_maxfps;
// 819EF14: using guessed type int com_sv_running;
// 819EF18: using guessed type int com_logfile;
// 819EF24: using guessed type int com_introPlayed;
// 819EF28: using guessed type int cl_paused;
// 819EF34: using guessed type int sv_paused;
// 819EF3C: using guessed type int com_animCheck;
// 8494204: using guessed type int com_dedicated;

//----- (08061D0E) --------------------------------------------------------
int __usercall Com_RunAutoExec@<eax>(long double a1@<st0>)
{
  Dvar_SetInAutoExec(1u);
  Cbuf_Execute(a1);
  return Dvar_SetInAutoExec(0);
}

//----- (08061D34) --------------------------------------------------------
int __usercall Com_ExecStartupConfigs@<eax>(long double a1@<st0>, int a2)
{
  char *v2; // eax

  Cbuf_AddText("exec default_mp.cfg\n");
  Cbuf_AddText("exec language.cfg\n");
  if ( a2 )
  {
    v2 = va("exec %s\n", a2);
    Cbuf_AddText(v2);
  }
  Cbuf_Execute(a1);
  Com_RunAutoExec(a1);
  if ( Com_SafeMode() )
    Cbuf_AddText("exec safemode_mp_server.cfg\n");
  return Cbuf_Execute(a1);
}

//----- (08061D9A) --------------------------------------------------------
int __usercall Com_InitPlayerProfiles@<eax>(long double a1@<st0>)
{
  return Com_ExecStartupConfigs(a1, (int)"config_mp_server.cfg");
}

//----- (08061DAE) --------------------------------------------------------
void __usercall Com_Init_Try_Block_Function(long double a1@<st0>, char *a2)
{
  char *v2; // eax
  char *src; // ST24_4
  unsigned __int16 v4; // ax
  int i; // [esp+20h] [ebp-8h]

  Com_Printf("%s %s build %s %s\n", "CoD2 MP", "1.0", "linux-i386", "Oct 24 2005");
  Com_InitPushEvent();
  Com_ParseCommandLine(a2);
  Swap_Init();
  Cbuf_Init();
  Cmd_Init();
  Com_StartupVariable(a1, 0);
  Com_StartupVariable(a1, "developer");
  FS_InitFilesystem(a1);
  Com_InitDvars(a1);
  for ( i = 0; i <= 0; ++i )
  {
    CL_SwitchToLocalClient();
    Com_InitPlayerProfiles(a1);
  }
  CL_SwitchToLocalClient();
  Cbuf_Execute(a1);
  sub_806283E();
  Com_StartupVariable(a1, 0);
  Com_InitHunkMemory(a1);
  dvar_modifiedFlags &= 0xFFFFFFFE;
  com_codeTimeScale = 1065353216;
  if ( *(_DWORD *)(com_developer + 8) )
  {
    Cmd_AddCommand("error", (int)sub_806191E);
    Cmd_AddCommand("crash", (int)sub_80619C8);
    Cmd_AddCommand("freeze", (int)sub_806195A);
  }
  Cmd_AddCommand("quit", (int)Com_Quit_f);
  Cmd_AddCommand("writeconfig", (int)Com_WriteConfig_f);
  Cmd_AddCommand("writedefaults", (int)Com_WriteDefaults_f);
  v2 = getBuildNumber();
  src = va("%s %s build %s %s", "CoD2 MP", "1.0", v2, "linux-i386");
  version = (int)Dvar_RegisterString(a1, "version", (int)&unk_813BDA4, 4160);
  Dvar_SetString(version, src);
  shortversion = (int)Dvar_RegisterString(a1, "shortversion", (int)"1.0", 4164);
  FxMem_Init();
  Sys_Init(a1);
  v4 = Com_Milliseconds();
  Netchan_Init(a1, v4);
  Scr_Init();
  Scr_Settings();
  XAnimInit();
  DObjInit();
  SV_Init(a1);
  NET_Init(a1);
  sv.start_frameTime = Com_Milliseconds();
  Com_AddStartupCommands();
  Com_SetCinematic();
  com_fullyInitialized = 1;
  Com_Printf("--- Common Initialization Complete ---\n");
  Cbuf_Execute(a1);
  if ( !*(_BYTE *)(com_sv_running + 8) )
    sub_80624CC();
}
// 819EEFC: using guessed type int com_developer;
// 819EF14: using guessed type int com_sv_running;
// 819EF20: using guessed type int shortversion;
// 819EF40: using guessed type int sv.start_frameTime;
// 819EF48: using guessed type int com_codeTimeScale;
// 819EF58: using guessed type int com_fullyInitialized;
// 85178A8: using guessed type int dvar_modifiedFlags;

//----- (08062004) --------------------------------------------------------
void __usercall Com_Init(long double a1@<st0>, char *a2)
{
  struct __jmp_buf_tag *v2; // eax
  char *v3; // eax

  v2 = (struct __jmp_buf_tag *)Sys_GetValue(2);
  if ( __sigsetjmp(v2, 0) )
  {
    v3 = va("Error during initialization:\n%s\n", com_errorMessage);
    Sys_Error(v3);
  }
  Com_Init_Try_Block_Function(a1, a2);
}

//----- (0806205E) --------------------------------------------------------
void __cdecl Com_WriteConfigToFile(char *src)
{
  int v1; // [esp+14h] [ebp-4h]

  v1 = FS_FOpenFileWrite(src);
  if ( v1 )
  {
    FS_Printf(v1, "// generated by Call of Duty, do not modify\n");
    Dvar_WriteVariables(v1);
    FS_FCloseFile(v1);
  }
  else
  {
    Com_Printf("Couldn't write %s.\n", src);
  }
}

//----- (080620B8) --------------------------------------------------------
void __cdecl Com_WriteDefaultConfigToFile(char *src)
{
  int v1; // [esp+14h] [ebp-4h]

  v1 = FS_FOpenFileWrite(src);
  if ( v1 )
  {
    FS_Printf(v1, "// generated by Call of Duty, do not modify\n");
    Dvar_WriteDefaults(v1);
    FS_FCloseFile(v1);
  }
  else
  {
    Com_Printf("Couldn't write %s.\n", src);
  }
}

//----- (08062112) --------------------------------------------------------
void sub_8062112()
{
  char dest; // [esp+10h] [ebp-48h]

  if ( com_fullyInitialized )
  {
    if ( !(((unsigned __int8)dvar_modifiedFlags ^ 1) & 1) )
    {
      dvar_modifiedFlags &= 0xFFFFFFFE;
      I_strncpyz(&dest, "config_mp_server.cfg", 64);
      Com_WriteConfigToFile(&dest);
    }
  }
}
// 819EF58: using guessed type int com_fullyInitialized;
// 85178A8: using guessed type int dvar_modifiedFlags;

//----- (08062164) --------------------------------------------------------
void Com_WriteConfig_f()
{
  char *v0; // eax
  char dest; // [esp+10h] [ebp-48h]

  if ( Cmd_Argc() == 2 )
  {
    v0 = Cmd_Argv(1u);
    I_strncpyz(&dest, v0, 64);
    Com_DefaultExtension(&dest, 0x40u, (int)".cfg");
    Com_Printf("Writing %s.\n", &dest);
    Com_WriteConfigToFile(&dest);
  }
  else
  {
    Com_Printf("Usage: writeconfig <filename>\n");
  }
}

//----- (080621E0) --------------------------------------------------------
void Com_WriteDefaults_f()
{
  char *v0; // eax
  char dest; // [esp+10h] [ebp-48h]

  if ( Cmd_Argc() == 2 )
  {
    v0 = Cmd_Argv(1u);
    I_strncpyz(&dest, v0, 64);
    Com_DefaultExtension(&dest, 0x40u, (int)".cfg");
    Com_Printf("Writing %s.\n", &dest);
    Com_WriteDefaultConfigToFile(&dest);
  }
  else
  {
    Com_Printf("Usage: writedefaults <filename>\n");
  }
}

//----- (0806228A) --------------------------------------------------------
signed int __cdecl sub_806228A(signed int a1)
{
  float v1; // ST00_4
  float v2; // ST08_4
  float v4; // [esp+8h] [ebp-10h]
  signed int v5; // [esp+Ch] [ebp-Ch]
  char v6; // [esp+13h] [ebp-5h]
  signed int v7; // [esp+14h] [ebp-4h]

  v5 = a1;
  if ( *(_DWORD *)(com_fixedtime + 8) )
  {
    a1 = *(_DWORD *)(com_fixedtime + 8);
    v6 = 1;
  }
  else if ( *(float *)(com_timescale + 8) != 1.0 || *(float *)&com_codeTimeScale != 1.0 )
  {
    v1 = (long double)a1 * *(float *)(com_timescale + 8) * *(float *)&com_codeTimeScale;
    a1 = sub_8062808(v1);
    v6 = 1;
  }
  else
  {
    v6 = 0;
  }
  if ( a1 <= 0 )
    a1 = 1;
  if ( *(_DWORD *)(com_dedicated + 8) )
  {
    if ( a1 > 500 && a1 <= 499999 )
      Com_Printf("Hitch warning: %i msec frame time\n", a1);
    v7 = 5000;
  }
  else if ( *(_BYTE *)(com_sv_running + 8) )
  {
    v7 = 200;
  }
  else
  {
    v7 = 5000;
  }
  if ( a1 > v7 )
    a1 = v7;
  if ( v6 && v5 )
  {
    v2 = (long double)a1;
    v4 = v2 / (long double)v5;
  }
  else
  {
    v4 = 1.0;
  }
  flt_819EF08 = v4;
  return a1;
}
// 819EF04: using guessed type int com_timescale;
// 819EF08: using guessed type float flt_819EF08;
// 819EF0C: using guessed type int com_fixedtime;
// 819EF14: using guessed type int com_sv_running;
// 819EF48: using guessed type int com_codeTimeScale;
// 8494204: using guessed type int com_dedicated;

//----- (080623A4) --------------------------------------------------------
int sub_80623A4()
{
  int result; // eax
  int v1; // ST00_4

  result = com_viewlog;
  if ( *(_BYTE *)(com_viewlog + 7) )
  {
    if ( !*(_DWORD *)(com_dedicated + 8) )
    {
      v1 = *(_DWORD *)(com_viewlog + 8);
      sub_80D40EA();
    }
    result = Dvar_ClearModified(com_viewlog);
  }
  return result;
}
// 819EEF8: using guessed type int com_viewlog;
// 8494204: using guessed type int com_dedicated;

//----- (080623EA) --------------------------------------------------------
void __usercall Com_Frame_Try_Block_Function(long double a1@<st0>)
{
  int v1; // ST14_4
  int v2; // [esp+10h] [ebp-8h]
  signed int v3; // [esp+14h] [ebp-4h]

  sub_8062112();
  sub_80623A4();
  sub_806C918(*(unsigned __int8 *)(com_animCheck + 8));
  v2 = 1;
  if ( *(_DWORD *)(com_maxfps + 8) > 0 && !*(_DWORD *)(com_dedicated + 8) )
  {
    v2 = 1000 / *(_DWORD *)(com_maxfps + 8);
    if ( !v2 )
      v2 = 1;
  }
  while ( 1 )
  {
    sv.start_frameTime = sub_8061526(a1);
    if ( dword_819EF44 > sv.start_frameTime )
      dword_819EF44 = sv.start_frameTime;
    v3 = sv.start_frameTime - dword_819EF44;
    if ( sv.start_frameTime - dword_819EF44 >= v2 )
      break;
    sub_80D3654(0);
  }
  Cbuf_Execute(a1);
  dword_819EF44 = sv.start_frameTime;
  v1 = sub_806228A(v3);
  CL_SwitchToLocalClient();
  sub_80949DE(a1, v1);
}
// 819EF0C: using guessed type int com_fixedtime;
// 819EF10: using guessed type int com_maxfps;
// 819EF3C: using guessed type int com_animCheck;
// 819EF40: using guessed type int sv.start_frameTime;
// 819EF44: using guessed type int dword_819EF44;
// 8494204: using guessed type int com_dedicated;

//----- (080624CC) --------------------------------------------------------
void sub_80624CC()
{
  ;
}

//----- (080624D2) --------------------------------------------------------
int sub_80624D2()
{
  int result; // eax

  result = Sys_MilliSeconds();
  dword_819EF44 = result;
  return result;
}
// 819EF44: using guessed type int dword_819EF44;

//----- (080624EA) --------------------------------------------------------
void __usercall Com_Frame(long double a1@<st0>)
{
  struct __jmp_buf_tag *v1; // eax

  sub_806283E();
  v1 = (struct __jmp_buf_tag *)Sys_GetValue(2);
  if ( !__sigsetjmp(v1, 0) )
  {
    Com_Frame_Try_Block_Function(a1);
    ++com_frameNumber;
  }
  if ( com_errorEntered )
    Com_ErrorCleanup(a1);
}
// 819EF4C: using guessed type int com_frameNumber;
// 819EF50: using guessed type int com_errorEntered;

//----- (0806253C) --------------------------------------------------------
void *Com_CloseLogFile()
{
  void *result; // eax

  if ( logfile )
  {
    result = FS_FCloseFile(logfile);
    logfile = 0;
  }
  return result;
}
// 819EEF4: using guessed type int logfile;

//----- (08062564) --------------------------------------------------------
void Com_Close()
{
  Com_ShutdownDObj();
  DObjShutdown();
  XAnimShutdown();
  CM_Shutdown();
  SND_ShutdownChannels();
  Hunk_Clear();
  Scr_Shutdown();
}

//----- (08062590) --------------------------------------------------------
_DWORD *__cdecl sub_8062590(_DWORD *a1)
{
  _DWORD *result; // eax

  memset(a1 + 6, 0, 0x100u);
  *a1 = 0;
  a1[1] = 0;
  result = a1;
  a1[2] = 256;
  return result;
}

//----- (080625D4) --------------------------------------------------------
void *__usercall Com_Restart@<eax>(long double a1@<st0>)
{
  SV_ShutdownGameProgs(a1);
  Com_ShutdownDObj();
  DObjShutdown();
  XAnimShutdown();
  CM_Shutdown();
  SND_ShutdownChannels();
  Hunk_Clear();
  Scr_Init();
  Scr_Settings();
  com_fixedConsolePosition = 0;
  XAnimInit();
  DObjInit();
  return Com_InitDObj();
}
// 819EF54: using guessed type int com_fixedConsolePosition;

//----- (08062622) --------------------------------------------------------
int __cdecl sub_8062622(int a1)
{
  return sub_8076A2A(a1);
}

//----- (0806263E) --------------------------------------------------------
_DWORD *__cdecl sub_806263E(int a1)
{
  return sub_80BA7E4(a1, sub_8062622);
}

//----- (0806265A) --------------------------------------------------------
int __cdecl sub_806265A(_DWORD *a1)
{
  return sub_80BA836(a1, (int (__cdecl *)(_DWORD *, int))sub_8076A50);
}

//----- (08062676) --------------------------------------------------------
int __cdecl sub_8062676(int a1)
{
  int result; // eax

  result = a1;
  dword_81A1C90 = a1;
  return result;
}
// 81A1C90: using guessed type int dword_81A1C90;

//----- (08062684) --------------------------------------------------------
void __cdecl sub_8062684(int a1)
{
  if ( a1 == dword_81A1C90 )
  {
    dword_81A1C90 = 0;
    sub_80E88E0();
  }
}
// 81A1C90: using guessed type int dword_81A1C90;

//----- (080626A8) --------------------------------------------------------
int __cdecl sub_80626A8(_BYTE *a1, int a2, int a3, int a4, int a5)
{
  int i; // [esp+0h] [ebp-8h]
  int j; // [esp+0h] [ebp-8h]
  signed int v8; // [esp+4h] [ebp-4h]

  v8 = 0;
  if ( a5 )
  {
    if ( *a1 )
    {
      for ( i = 0; i < a4 - a3 && a1[i]; ++i )
      {
        if ( a1[i] <= 32 )
        {
          v8 = 1;
          break;
        }
      }
    }
    else
    {
      v8 = 1;
    }
  }
  if ( v8 && a3 < a4 )
    *(_BYTE *)(a2 + a3++) = 34;
  for ( j = 0; a3 < a4 && a1[j]; ++j )
    *(_BYTE *)(a2 + a3++) = a1[j];
  if ( v8 && a3 < a4 )
    *(_BYTE *)(a2 + a3++) = 34;
  return a3;
}

//----- (08062782) --------------------------------------------------------
signed int sub_8062782()
{
  return 46;
}

//----- (0806278C) --------------------------------------------------------
int __cdecl sub_806278C(float a1, char *s, int a3, int a4)
{
  int result; // eax
  unsigned __int8 v5; // [esp+23h] [ebp-5h]
  unsigned int i; // [esp+24h] [ebp-4h]

  snprintf(s, a3 - 1, "%.*f", a4, a1);
  s[a3 - 1] = 0;
  result = sub_8062782();
  v5 = result;
  if ( (_BYTE)result != 46 )
  {
    for ( i = 0; ; ++i )
    {
      result = i;
      if ( i >= a3 )
        break;
      if ( s[i] == 46 )
      {
        result = v5;
        s[i] = v5;
        return result;
      }
    }
  }
  return result;
}

//----- (08062808) --------------------------------------------------------
int __cdecl sub_8062808(float a1)
{
  return (signed int)floor(a1 + 0.5);
}

//----- (0806283E) --------------------------------------------------------
void sub_806283E()
{
  ;
}

//----- (08062844) --------------------------------------------------------
int __cdecl sub_8062844(int a1, int a2)
{
  int v3; // [esp+0h] [ebp-4h]
  int v4; // [esp+Ch] [ebp+8h]

  v4 = 1152 * a2 + a1;
  if ( word_81D4600[v4] )
    v3 = 100 * word_81D4600[v4] + 135929216;
  else
    v3 = 0;
  return v3;
}

//----- (0806289C) --------------------------------------------------------
int __cdecl sub_806289C(int a1)
{
  int v2; // [esp+0h] [ebp-4h]

  if ( word_81D4F00[a1] )
    v2 = 100 * word_81D4F00[a1] + 135929216;
  else
    v2 = 0;
  return v2;
}

//----- (080628E4) --------------------------------------------------------
int sub_80628E4()
{
  int i; // [esp+4h] [ebp-4h]
  signed int j; // [esp+4h] [ebp-4h]

  for ( i = dword_81D5700 + 1; i <= 2047; ++i )
  {
    if ( !*(_BYTE *)(i + 136134016) )
    {
      dword_81D5700 = i;
      *(_BYTE *)(i + 136134016) = 1;
      --dword_81D4580;
      return i;
    }
  }
  for ( j = 1; j <= dword_81D5700; ++j )
  {
    if ( !*(_BYTE *)(j + 136134016) )
    {
      dword_81D5700 = j;
      *(_BYTE *)(j + 136134016) = 1;
      --dword_81D4580;
      return j;
    }
  }
  return 0;
}
// 81D4580: using guessed type int dword_81D4580;
// 81D5700: using guessed type int dword_81D5700;

//----- (08062988) --------------------------------------------------------
int __cdecl sub_8062988(signed __int16 ***a1, unsigned __int16 a2, int a3, int a4)
{
  int v4; // eax
  int result; // eax

  v4 = sub_80628E4();
  word_81D4600[a4] = v4;
  result = sub_80B7EFC(a1, a2, a3, 100 * v4 + 135929216, 0);
  if ( !dword_81D4580 )
    Com_Error(1, &byte_813C2EC);
  return result;
}
// 81D4580: using guessed type int dword_81D4580;

//----- (08062A0C) --------------------------------------------------------
int *sub_8062A0C()
{
  int *result; // eax
  int i; // [esp+14h] [ebp-4h]

  for ( i = 0; i <= 1151; ++i )
  {
    if ( word_81D4600[i] )
      sub_80B840A(100 * word_81D4600[i] + 135929216);
    result = &i;
  }
  return result;
}

//----- (08062A66) --------------------------------------------------------
int __cdecl sub_8062A66(signed __int16 ***a1, unsigned __int16 a2, int a3, int a4)
{
  int v4; // eax
  int result; // eax

  v4 = sub_80628E4();
  word_81D4F00[a4] = v4;
  result = sub_80B7EFC(a1, a2, a3, 100 * v4 + 135929216, a4 + 1);
  if ( !dword_81D4580 )
    Com_Error(1, &byte_813C2EC);
  return result;
}
// 81D4580: using guessed type int dword_81D4580;

//----- (08062AEC) --------------------------------------------------------
int __cdecl sub_8062AEC(int a1)
{
  int result; // eax
  int v2; // [esp+4h] [ebp-4h]

  result = word_81D4600[a1];
  v2 = word_81D4600[a1];
  if ( word_81D4600[a1] )
  {
    word_81D4600[a1] = 0;
    *(_BYTE *)(v2 + 136134016) = 0;
    ++dword_81D4580;
    result = sub_80B819E(100 * v2 + 135929216);
  }
  return result;
}
// 81D4580: using guessed type int dword_81D4580;

//----- (08062B4C) --------------------------------------------------------
int __cdecl sub_8062B4C(int a1)
{
  int result; // eax
  int v2; // [esp+4h] [ebp-4h]

  result = word_81D4F00[a1];
  v2 = word_81D4F00[a1];
  if ( word_81D4F00[a1] )
  {
    word_81D4F00[a1] = 0;
    *(_BYTE *)(v2 + 136134016) = 0;
    ++dword_81D4580;
    result = sub_80B819E(100 * v2 + 135929216);
  }
  return result;
}
// 81D4580: using guessed type int dword_81D4580;

//----- (08062BAC) --------------------------------------------------------
void *Com_InitDObj()
{
  void *result; // eax

  sub_80AA83E(&unk_81D3D80, 0, 0x800u);
  dword_81D4580 = 2047;
  sub_80AA83E(word_81D4600, 0, 0x900u);
  result = sub_80AA83E(word_81D4F00, 0, 0x800u);
  dword_81D5700 = 1;
  dword_81D5704 = 1;
  return result;
}
// 81D4580: using guessed type int dword_81D4580;
// 81D5700: using guessed type int dword_81D5700;
// 81D5704: using guessed type int dword_81D5704;

//----- (08062C26) --------------------------------------------------------
void Com_ShutdownDObj()
{
  if ( dword_81D5704 )
    dword_81D5704 = 0;
}
// 81D5704: using guessed type int dword_81D5704;

//----- (08062C40) --------------------------------------------------------
void sub_8062C40()
{
  dword_81D5704 = 0;
}
// 81D5704: using guessed type int dword_81D5704;

//----- (08062C50) --------------------------------------------------------
int __cdecl sub_8062C50(void (__cdecl *a1)(_DWORD))
{
  int result; // eax
  _DWORD *i; // [esp+4h] [ebp-4h]

  result = sortedDvars;
  for ( i = (_DWORD *)sortedDvars; i; i = (_DWORD *)i[7] )
  {
    a1(*i);
    result = i[7];
  }
  return result;
}
// 85178A0: using guessed type int sortedDvars;

//----- (08062C80) --------------------------------------------------------
int __cdecl Dvar_GetCombinedString(char *s, int a2)
{
  int result; // eax
  char *v3; // eax
  size_t v4; // eax
  char *v5; // eax
  size_t v6; // [esp+18h] [ebp-10h]
  int v7; // [esp+1Ch] [ebp-Ch]
  int v8; // [esp+20h] [ebp-8h]
  int i; // [esp+24h] [ebp-4h]

  v8 = Cmd_Argc();
  *s = 0;
  v7 = 0;
  for ( i = a2; ; ++i )
  {
    result = i;
    if ( i >= v8 )
      break;
    v3 = Cmd_Argv(i);
    v4 = strlen(v3 + 1);
    v6 = v4;
    result = v7 + v4;
    if ( result > 4093 )
      break;
    v5 = Cmd_Argv(i);
    sub_80B57C0(s, 4096, v5);
    if ( i != v8 - 1 )
      sub_80B57C0(s, 4096, " ");
    v7 += v6;
  }
  return result;
}

//----- (08062D2C) --------------------------------------------------------
signed int __usercall Dvar_Command@<eax>(long double a1@<st0>)
{
  char *v1; // eax
  char *v2; // ebx
  char *v3; // eax
  char *v4; // eax
  char *v5; // eax
  signed int v7; // [esp+1Ch] [ebp-101Ch]
  char v8; // [esp+20h] [ebp-1018h]
  int v9; // [esp+102Ch] [ebp-Ch]

  v1 = Cmd_Argv(0);
  v9 = Dvar_FindVar(v1);
  if ( !v9 )
    return 0;
  if ( Cmd_Argc() == 1 )
  {
    v2 = Dvar_DisplayableResetValue(v9);
    v3 = Dvar_DisplayableValue(v9);
    Com_Printf("\"%s\" is: \"%s^7\" default: \"%s^7\"\n", *(_DWORD *)v9, v3, v2);
    if ( (unsigned __int8)Dvar_HasLatchedValue(v9) )
    {
      v4 = Dvar_DisplayableLatchedValue(v9);
      Com_Printf("latched: \"%s\"\n", v4);
    }
    sub_80B04A4(*(_BYTE *)(v9 + 6), *(_DWORD *)(v9 + 20), *(_DWORD *)(v9 + 24));
    v7 = 1;
  }
  else
  {
    Dvar_GetCombinedString(&v8, 1);
    v5 = Cmd_Argv(0);
    Dvar_SetCommand(a1, v5, &v8);
    v7 = 1;
  }
  return v7;
}

//----- (08062E4C) --------------------------------------------------------
signed int __cdecl sub_8062E4C(int a1)
{
  signed int v2; // [esp+14h] [ebp-4h]

  switch ( *(unsigned __int8 *)(a1 + 6) )
  {
    case 0u:
      sub_80B1FDA(a1, *(_BYTE *)(a1 + 8) ^ 1, 1);
      v2 = 1;
      break;
    case 1u:
      if ( *(float *)(a1 + 20) > 0.0 || *(float *)(a1 + 24) < 1.0 )
      {
        if ( *(float *)(a1 + 8) == *(float *)(a1 + 20) )
          sub_80B2096(a1, *(char **)(a1 + 24), 1);
        else
          sub_80B2096(a1, *(char **)(a1 + 20), 1);
      }
      else if ( *(float *)(a1 + 8) == 0.0 )
      {
        sub_80B2096(a1, (char *)0x3F800000, 1);
      }
      else
      {
        sub_80B2096(a1, 0, 1);
      }
      v2 = 1;
      break;
    case 2u:
    case 3u:
    case 4u:
    case 7u:
    case 8u:
      Com_Printf("'toggle' with no arguments makes no sense for dvar '%s'\n", *(_DWORD *)a1);
      v2 = 0;
      break;
    case 5u:
      if ( *(_DWORD *)(a1 + 20) > 0 || *(_DWORD *)(a1 + 24) <= 0 )
      {
        if ( *(_DWORD *)(a1 + 8) == *(_DWORD *)(a1 + 20) )
          sub_80B2030(a1, *(char **)(a1 + 24), 1);
        else
          sub_80B2030(a1, *(char **)(a1 + 20), 1);
      }
      else if ( *(_DWORD *)(a1 + 8) )
      {
        sub_80B2030(a1, 0, 1);
      }
      else
      {
        sub_80B2030(a1, (char *)1, 1);
      }
      v2 = 1;
      break;
    case 6u:
      if ( *(_DWORD *)(a1 + 20) )
        sub_80B2030(a1, (char *)((*(_DWORD *)(a1 + 8) + 1) % *(_DWORD *)(a1 + 20)), 1);
      v2 = 1;
      break;
    default:
      v2 = 0;
      break;
  }
  return v2;
}

//----- (08063088) --------------------------------------------------------
signed int __usercall sub_8063088@<eax>(long double a1@<st0>)
{
  char *v1; // eax
  char *v2; // eax
  signed int v4; // [esp+8h] [ebp-20h]
  char *v5; // [esp+Ch] [ebp-1Ch]
  char *v6; // [esp+Ch] [ebp-1Ch]
  char *s2; // [esp+10h] [ebp-18h]
  char *s2a; // [esp+10h] [ebp-18h]
  unsigned int i; // [esp+14h] [ebp-14h]
  const char *s1; // [esp+18h] [ebp-10h]
  int v11; // [esp+1Ch] [ebp-Ch]
  char *src; // [esp+20h] [ebp-8h]

  if ( Cmd_Argc() > 1 )
  {
    src = Cmd_Argv(1u);
    v11 = Dvar_FindVar(src);
    if ( v11 )
    {
      if ( Cmd_Argc() == 2 )
      {
        v4 = (unsigned __int8)sub_8062E4C(v11);
      }
      else
      {
        s1 = Dvar_DisplayableValue(v11);
        for ( i = 2; (signed int)(i + 1) < Cmd_Argc(); ++i )
        {
          s2 = Cmd_Argv(i);
          if ( *(_BYTE *)(v11 + 6) == 6 )
          {
            v5 = (char *)sub_80AF474(v11, s2);
            if ( *v5 )
              s2 = v5;
          }
          if ( !strcasecmp(s1, s2) )
          {
            v2 = Cmd_Argv(i + 1);
            Dvar_SetCommand(a1, src, v2);
            return 1;
          }
        }
        s2a = Cmd_Argv(2u);
        if ( *(_BYTE *)(v11 + 6) == 6 )
        {
          v6 = (char *)sub_80AF474(v11, s2a);
          if ( *v6 )
            s2a = v6;
        }
        Dvar_SetCommand(a1, src, s2a);
        v4 = 1;
      }
    }
    else
    {
      Com_Printf("toggle failed: dvar '%s' not found.\n", src);
      v4 = 0;
    }
  }
  else
  {
    v1 = Cmd_Argv(0);
    Com_Printf("USAGE: %s <variable> <optional value sequence>\n", v1);
    v4 = 0;
  }
  return v4;
}

//----- (08063222) --------------------------------------------------------
signed int __usercall Dvar_Toggle_f@<eax>(long double a1@<st0>)
{
  return sub_8063088(a1);
}

//----- (08063230) --------------------------------------------------------
void __usercall Dvar_TogglePrint_f(long double a1@<st0>)
{
  char *v1; // eax
  char *v2; // ST14_4
  int v3; // eax
  int v4; // ST10_4
  char *v5; // eax

  if ( (unsigned __int8)sub_8063088(a1) )
  {
    v1 = Cmd_Argv(1u);
    v2 = v1;
    v3 = Dvar_FindVar(v1);
    v4 = v3;
    v5 = Dvar_DisplayableValue(v3);
    Com_Printf("%s toggled to %s\n", v2, v5, v5, v4);
  }
}

//----- (08063288) --------------------------------------------------------
void __usercall Dvar_Set_f(long double a1@<st0>)
{
  char *v1; // ST1C_4
  char *v2; // eax
  char *v3; // eax
  char v4; // [esp+20h] [ebp-1018h]
  int v5; // [esp+102Ch] [ebp-Ch]

  v5 = Cmd_Argc();
  if ( v5 > 2 )
  {
    v1 = Cmd_Argv(1u);
    if ( (unsigned __int8)sub_80AEF62((int)v1) )
    {
      Dvar_GetCombinedString(&v4, 2);
      v3 = Cmd_Argv(1u);
      Dvar_SetCommand(a1, v3, &v4);
    }
    else
    {
      v2 = Cmd_Argv(1u);
      Com_Printf("invalid variable name: %s\n", v2);
    }
  }
  else
  {
    Com_Printf("USAGE: set <variable> <value>\n");
  }
}

//----- (08063328) --------------------------------------------------------
void __usercall Dvar_RegisterBool_f(long double a1@<st0>)
{
  char *v1; // eax
  char *v2; // eax
  bool v3; // [esp+1Bh] [ebp-Dh]
  char *src; // [esp+1Ch] [ebp-Ch]
  int v5; // [esp+20h] [ebp-8h]

  if ( Cmd_Argc() == 3 )
  {
    src = Cmd_Argv(1u);
    v2 = Cmd_Argv(2u);
    v3 = atoi(v2) != 0;
    v5 = Dvar_FindVar(src);
    if ( v5 && (*(_BYTE *)(v5 + 6) != 7 || !(*(_WORD *)(v5 + 4) & 0x4000)) )
    {
      if ( *(_BYTE *)(v5 + 6) )
        Com_Printf("dvar '%s' is not a boolean dvar\n", *(_DWORD *)v5);
    }
    else
    {
      Dvar_RegisterBool(a1, src, v3, 0x4000);
    }
  }
  else
  {
    v1 = Cmd_Argv(0);
    Com_Printf("USAGE: %s <name> <default>\n", v1);
  }
}

//----- (080633F4) --------------------------------------------------------
void __usercall Dvar_RegisterInt_f(long double a1@<st0>)
{
  char *v1; // eax
  char *v2; // eax
  char *v3; // eax
  char *v4; // eax
  int v5; // [esp+20h] [ebp-18h]
  int v6; // [esp+24h] [ebp-14h]
  int v7; // [esp+28h] [ebp-10h]
  char *src; // [esp+2Ch] [ebp-Ch]
  int v9; // [esp+30h] [ebp-8h]

  if ( Cmd_Argc() == 5 )
  {
    src = Cmd_Argv(1u);
    v2 = Cmd_Argv(2u);
    v7 = atoi(v2);
    v3 = Cmd_Argv(3u);
    v6 = atoi(v3);
    v4 = Cmd_Argv(4u);
    v5 = atoi(v4);
    if ( v6 <= v5 )
    {
      v9 = Dvar_FindVar(src);
      if ( v9 && (*(_BYTE *)(v9 + 6) != 7 || !(*(_WORD *)(v9 + 4) & 0x4000)) )
      {
        if ( *(_BYTE *)(v9 + 6) != 5 && *(_BYTE *)(v9 + 6) != 6 )
          Com_Printf("dvar '%s' is not an integer dvar\n", *(_DWORD *)v9);
      }
      else
      {
        Dvar_RegisterInt(a1, src, v7, v6, v5, 0x4000);
      }
    }
    else
    {
      Com_Printf("dvar %s: min %i should not be greater than max %i\n", src, v6, v5);
    }
  }
  else
  {
    v1 = Cmd_Argv(0);
    Com_Printf("USAGE: %s <name> <default> <min> <max>\n", v1);
  }
}

//----- (0806352E) --------------------------------------------------------
void Dvar_RegisterFloat_f()
{
  char *v0; // eax
  char *v1; // eax
  char *v2; // eax
  char *v3; // eax
  int v4; // [esp+20h] [ebp-18h]
  int v5; // [esp+24h] [ebp-14h]
  int v6; // [esp+28h] [ebp-10h]
  char *src; // [esp+2Ch] [ebp-Ch]
  int v8; // [esp+30h] [ebp-8h]

  if ( Cmd_Argc() == 5 )
  {
    src = Cmd_Argv(1u);
    v1 = Cmd_Argv(2u);
    *(float *)&v6 = atof(v1);
    v2 = Cmd_Argv(3u);
    *(float *)&v5 = atof(v2);
    v3 = Cmd_Argv(4u);
    *(float *)&v4 = atof(v3);
    if ( *(float *)&v5 <= (long double)*(float *)&v4 )
    {
      v8 = Dvar_FindVar(src);
      if ( v8 && (*(_BYTE *)(v8 + 6) != 7 || !(*(_WORD *)(v8 + 4) & 0x4000)) )
      {
        if ( *(_BYTE *)(v8 + 6) != 1 )
          Com_Printf("dvar '%s' is not an integer dvar\n", *(_DWORD *)v8);
      }
      else
      {
        Dvar_RegisterFloat(*(float *)&v4, src, v6, v5, v4, 0x4000);
      }
    }
    else
    {
      Com_Printf("dvar %s: min %g should not be greater than max %g\n", src, (_QWORD)v5, (_QWORD)v4);
    }
  }
  else
  {
    v0 = Cmd_Argv(0);
    Com_Printf("USAGE: %s <name> <default> <min> <max>\n", v0);
  }
}

//----- (08063664) --------------------------------------------------------
void __usercall Dvar_SetU_f(long double a1@<st0>)
{
  char *v1; // eax
  int v2; // [esp+14h] [ebp-4h]

  if ( Cmd_Argc() > 2 )
  {
    Dvar_Set_f(a1);
    v1 = Cmd_Argv(1u);
    v2 = Dvar_FindVar(v1);
    if ( v2 )
      sub_80B2B42(v2, 2);
  }
  else
  {
    Com_Printf("USAGE: setu <variable> <value>\n");
  }
}

//----- (080636BC) --------------------------------------------------------
void __usercall Dvar_SetS_f(long double a1@<st0>)
{
  char *v1; // eax
  int v2; // [esp+14h] [ebp-4h]

  if ( Cmd_Argc() > 2 )
  {
    Dvar_Set_f(a1);
    v1 = Cmd_Argv(1u);
    v2 = Dvar_FindVar(v1);
    if ( v2 )
      sub_80B2B42(v2, 4);
  }
  else
  {
    Com_Printf("USAGE: sets <variable> <value>\n");
  }
}

//----- (08063714) --------------------------------------------------------
void __usercall Dvar_SetA_f(long double a1@<st0>)
{
  char *v1; // eax
  int v2; // [esp+14h] [ebp-4h]

  if ( Cmd_Argc() > 2 )
  {
    Dvar_Set_f(a1);
    v1 = Cmd_Argv(1u);
    v2 = Dvar_FindVar(v1);
    if ( v2 )
      sub_80B2B42(v2, 1);
  }
  else
  {
    Com_Printf("USAGE: seta <variable> <value>\n");
  }
}

//----- (0806376C) --------------------------------------------------------
void __usercall Dvar_SetFromDvar_f(long double a1@<st0>)
{
  char *v1; // eax
  char *v2; // eax
  char *v3; // ebx
  char *v4; // eax
  int v5; // [esp+10h] [ebp-8h]

  if ( Cmd_Argc() == 3 )
  {
    v1 = Cmd_Argv(2u);
    v5 = Dvar_FindVar(v1);
    if ( v5 )
    {
      v3 = Dvar_DisplayableValue(v5);
      v4 = Cmd_Argv(1u);
      Dvar_SetCommand(a1, v4, v3);
    }
    else
    {
      v2 = Cmd_Argv(2u);
      Com_Printf("dvar '%s' doesn't exist\n", v2);
    }
  }
  else
  {
    Com_Printf("USAGE: setfromdvar <dest_dvar> <source_dvar>\n");
  }
}

//----- (080637F2) --------------------------------------------------------
void Dvar_Reset_f()
{
  char *v0; // eax
  int v1; // [esp+14h] [ebp-4h]

  if ( Cmd_Argc() == 2 )
  {
    v0 = Cmd_Argv(1u);
    v1 = Dvar_FindVar(v0);
    if ( v1 )
      sub_80B2B5A(v1, 1);
  }
  else
  {
    Com_Printf("USAGE: reset <variable>\n");
  }
}

//----- (08063844) --------------------------------------------------------
int __cdecl Dvar_WriteVariables(int a1)
{
  int result; // eax
  char *v2; // eax
  int i; // [esp+14h] [ebp-4h]

  result = sortedDvars;
  for ( i = sortedDvars; i; i = *(_DWORD *)(i + 28) )
  {
    if ( I_stricmp(*(char **)i, "cl_cdkey") )
    {
      if ( !(((unsigned __int8)*(_WORD *)(i + 4) ^ 1) & 1) )
      {
        v2 = Dvar_DisplayableLatchedValue(i);
        FS_Printf(a1, "seta %s \"%s\"\n", *(_DWORD *)i, v2);
      }
    }
    result = *(_DWORD *)(i + 28);
  }
  return result;
}
// 85178A0: using guessed type int sortedDvars;

//----- (080638BE) --------------------------------------------------------
int __cdecl Dvar_WriteDefaults(int a1)
{
  int result; // eax
  char *v2; // eax
  int i; // [esp+14h] [ebp-4h]

  result = sortedDvars;
  for ( i = sortedDvars; i; i = *(_DWORD *)(i + 28) )
  {
    if ( I_stricmp(*(char **)i, "cl_cdkey") )
    {
      if ( !(*(_WORD *)(i + 4) & 0x40C0) )
      {
        v2 = Dvar_DisplayableResetValue(i);
        FS_Printf(a1, "set %s \"%s\"\n", *(_DWORD *)i, v2);
      }
    }
    result = *(_DWORD *)(i + 28);
  }
  return result;
}
// 85178A0: using guessed type int sortedDvars;

//----- (0806393A) --------------------------------------------------------
void Dvar_List_f()
{
  char *v0; // eax
  char *v1; // [esp+10h] [ebp-8h]
  char **i; // [esp+14h] [ebp-4h]

  if ( Cmd_Argc() <= 1 )
    v1 = 0;
  else
    v1 = Cmd_Argv(1u);
  for ( i = (char **)sortedDvars; i; i = (char **)i[7] )
  {
    if ( !v1 || (unsigned __int8)Com_Filter((int)v1, *i, 0) )
    {
      if ( (_WORD)i[1] & 0x404 )
        Com_Printf(aSurialc);
      else
        Com_Printf(" ");
      if ( (_WORD)i[1] & 2 )
        Com_Printf(&aSurialc[2]);
      else
        Com_Printf(" ");
      if ( (_WORD)i[1] & 0x40 )
        Com_Printf(&aSurialc[4]);
      else
        Com_Printf(" ");
      if ( (_WORD)i[1] & 0x10 )
        Com_Printf(&aSurialc[6]);
      else
        Com_Printf(" ");
      if ( (_WORD)i[1] & 1 )
        Com_Printf(&aSurialc[8]);
      else
        Com_Printf(" ");
      if ( (_WORD)i[1] & 0x20 )
        Com_Printf(&aSurialc[10]);
      else
        Com_Printf(" ");
      if ( *((_BYTE *)i + 4) >= 0 )
        Com_Printf(" ");
      else
        Com_Printf(&aSurialc[12]);
      v0 = Dvar_DisplayableValue((int)i);
      Com_Printf(" %s \"%s\"\n", *i, v0);
    }
  }
  Com_Printf("\n%i total dvars\n", *(_DWORD *)dword_8522CC0);
}
// 85178A0: using guessed type int sortedDvars;

//----- (08063B04) --------------------------------------------------------
void __cdecl Com_DvarDump(int a1)
{
  char *v1; // ebx
  char *v2; // eax
  char *v3; // eax
  char s; // [esp+20h] [ebp-2018h]
  int v5; // [esp+2024h] [ebp-14h]
  char v6[4]; // [esp+2028h] [ebp-10h]
  _DWORD *v7; // [esp+202Ch] [ebp-Ch]

  if ( Cmd_Argc() <= 1 )
    v5 = 0;
  else
    v5 = (int)Cmd_Argv(1u);
  if ( a1 || com_logfile && *(_DWORD *)(com_logfile + 8) )
  {
    *(_DWORD *)v6 = 0;
    Com_PrintMessage(a1, "=============================== DVAR DUMP ========================================\n");
    v7 = (_DWORD *)sortedDvars;
    while ( v7 )
    {
      if ( !v5 || (unsigned __int8)Com_Filter(v5, (char *)*v7, 0) )
      {
        if ( (unsigned __int8)Dvar_HasLatchedValue((int)v7) )
        {
          v1 = Dvar_DisplayableLatchedValue((int)v7);
          v2 = Dvar_DisplayableValue((int)v7);
          Com_sprintf(&s, 0x2000u, "      %s \"%s\" -- latched \"%s\"\n", *v7, v2, v1);
        }
        else
        {
          v3 = Dvar_DisplayableValue((int)v7);
          Com_sprintf(&s, 0x2000u, "      %s \"%s\"\n", *v7, v3);
        }
        Com_PrintMessage(a1, &s);
      }
      v7 = (_DWORD *)v7[7];
      ++*(_DWORD *)v6;
    }
    Com_sprintf(&s, 0x2000u, "\n%i total dvars\n%i dvar indexes\n", *(_DWORD *)v6, *(_DWORD *)dword_8522CC0);
    Com_PrintMessage(a1, &s);
    Com_PrintMessage(a1, "=============================== END DVAR DUMP =====================================\n");
  }
}
// 819EF18: using guessed type int com_logfile;
// 85178A0: using guessed type int sortedDvars;

//----- (08063CC0) --------------------------------------------------------
void Dvar_Dump_f()
{
  Com_DvarDump(0);
}

//----- (08063CD4) --------------------------------------------------------
int __cdecl sub_8063CD4(int a1, int a2, unsigned __int16 a3)
{
  int result; // eax
  char *v4; // eax
  int i; // [esp+14h] [ebp-4h]

  result = sortedDvars;
  for ( i = sortedDvars; i; i = *(_DWORD *)(i + 28) )
  {
    if ( a3 & *(_WORD *)(i + 4) )
    {
      v4 = Dvar_DisplayableValue(i);
      sub_80911AA(a1, a2, *(char **)i, v4);
    }
    result = *(_DWORD *)(i + 28);
  }
  return result;
}
// 85178A0: using guessed type int sortedDvars;

//----- (08063D30) --------------------------------------------------------
char *__cdecl sub_8063D30(unsigned __int16 a1)
{
  char *v1; // eax
  int i; // [esp+14h] [ebp-4h]

  byte_81D5780 = 0;
  for ( i = sortedDvars; i; i = *(_DWORD *)(i + 28) )
  {
    if ( a1 & *(_WORD *)(i + 4) )
    {
      v1 = Dvar_DisplayableValue(i);
      sub_80B5FF6(&byte_81D5780, *(char **)i, (int)v1);
    }
  }
  return &byte_81D5780;
}
// 85178A0: using guessed type int sortedDvars;

//----- (08063D92) --------------------------------------------------------
char *__cdecl sub_8063D92(unsigned __int16 a1)
{
  char *v1; // eax
  int i; // [esp+14h] [ebp-4h]

  byte_81D5B80 = 0;
  for ( i = sortedDvars; i; i = *(_DWORD *)(i + 28) )
  {
    if ( a1 & *(_WORD *)(i + 4) )
    {
      v1 = Dvar_DisplayableValue(i);
      sub_80B622A(&byte_81D5B80, *(char **)i, (int)v1);
    }
  }
  return &byte_81D5B80;
}
// 85178A0: using guessed type int sortedDvars;

//----- (08063DF4) --------------------------------------------------------
void sub_8063DF4()
{
  Cmd_AddCommand("toggle", (int)Dvar_Toggle_f);
  Cmd_AddCommand("togglep", (int)Dvar_TogglePrint_f);
  Cmd_AddCommand("set", (int)Dvar_Set_f);
  Cmd_AddCommand("sets", (int)Dvar_SetS_f);
  Cmd_AddCommand("seta", (int)Dvar_SetA_f);
  Cmd_AddCommand("setfromdvar", (int)Dvar_SetFromDvar_f);
  Cmd_AddCommand("reset", (int)Dvar_Reset_f);
  Cmd_AddCommand("dvarlist", (int)Dvar_List_f);
  Cmd_AddCommand("dvardump", (int)Dvar_Dump_f);
  Cmd_AddCommand("dvar_bool", (int)Dvar_RegisterBool_f);
  Cmd_AddCommand("dvar_int", (int)Dvar_RegisterInt_f);
  Cmd_AddCommand("dvar_float", (int)Dvar_RegisterFloat_f);
  Cmd_AddCommand("setu", (int)Dvar_SetU_f);
}

//----- (08063F00) --------------------------------------------------------
signed int __cdecl sub_8063F00(char *a1)
{
  int v2; // [esp+1Ch] [ebp-11Ch]
  char s; // [esp+20h] [ebp-118h]
  FILE *stream; // [esp+12Ch] [ebp-Ch]

  FS_BuildOSPath(*(void **)(fs_homepath + 8), a1, &byte_813C8A0, &s);
  *((_BYTE *)&v2 + strlen(&s) + 3) = 0;
  stream = FS_FileOpen(&s, "rb");
  if ( !stream )
    return 0;
  FS_FileClose(stream);
  return 1;
}
// 848B7C4: using guessed type int fs_homepath;

//----- (08063F90) --------------------------------------------------------
int __cdecl FS_SV_FOpenFileWrite(char *src)
{
  int v1; // ebx
  int v4; // [esp+1Ch] [ebp-10Ch]
  char s; // [esp+20h] [ebp-108h]

  FS_CheckFileSystemStarted();
  FS_BuildOSPath(*(void **)(fs_homepath + 8), src, &byte_813C8A0, &s);
  *((_BYTE *)&v4 + strlen(&s) + 3) = 0;
  v4 = FS_HandleForFile(0);
  dword_848B814[71 * v4] = 0;
  if ( *(_DWORD *)(fs_debug + 8) )
    Com_Printf("FS_SV_FOpenFileWrite: %s\n", &s);
  if ( FS_CreatePath(&s) )
    return 0;
  Com_DPrintf("writing to: %s\n", &s);
  v1 = 71 * v4;
  dword_848B800[v1] = (int)FS_FileOpen(&s, "wb");
  I_strncpyz((char *)(284 * v4 + 138983452), src, 256);
  dword_848B808[71 * v4] = 0;
  if ( !dword_848B800[71 * v4] )
    v4 = 0;
  return v4;
}
// 848B7C0: using guessed type int fs_debug;
// 848B7C4: using guessed type int fs_homepath;
// 848B800: using guessed type int dword_848B800[];
// 848B808: using guessed type int dword_848B808[];
// 848B814: using guessed type int dword_848B814[];

//----- (08064100) --------------------------------------------------------
int __cdecl FS_SV_FOpenFileRead(char *src, int a2)
{
  int v2; // ebx
  int v3; // ebx
  int v4; // ebx
  int v6; // [esp+18h] [ebp-110h]
  int v7; // [esp+1Ch] [ebp-10Ch]
  char s; // [esp+20h] [ebp-108h]

  FS_CheckFileSystemStarted();
  v7 = FS_HandleForFile(0);
  dword_848B814[71 * v7] = 0;
  I_strncpyz((char *)(284 * v7 + 138983452), src, 256);
  FS_BuildOSPath(*(void **)(fs_homepath + 8), src, &byte_813C8A0, &s);
  *((_BYTE *)&v7 + strlen(&s) + 3) = 0;
  if ( *(_DWORD *)(fs_debug + 8) )
    Com_Printf("FS_SV_FOpenFileRead (fs_homepath): %s\n", &s);
  v2 = 71 * v7;
  dword_848B800[v2] = (int)FS_FileOpen(&s, "rb");
  dword_848B808[71 * v7] = 0;
  if ( !dword_848B800[71 * v7] && I_stricmp(*(char **)(fs_homepath + 8), *(char **)(fs_basepath + 8)) )
  {
    FS_BuildOSPath(*(void **)(fs_basepath + 8), src, &byte_813C8A0, &s);
    *((_BYTE *)&v7 + strlen(&s) + 3) = 0;
    if ( *(_DWORD *)(fs_debug + 8) )
      Com_Printf("FS_SV_FOpenFileRead (fs_basepath): %s\n", &s);
    v3 = 71 * v7;
    dword_848B800[v3] = (int)FS_FileOpen(&s, "rb");
    dword_848B808[71 * v7] = 0;
    if ( !dword_848B800[71 * v7] )
      v7 = 0;
  }
  if ( !dword_848B800[71 * v7] )
  {
    FS_BuildOSPath(*(void **)(fs_cdpath + 8), src, &byte_813C8A0, &s);
    *((_BYTE *)&v7 + strlen(&s) + 3) = 0;
    if ( *(_DWORD *)(fs_debug + 8) )
      Com_Printf("FS_SV_FOpenFileRead (fs_cdpath) : %s\n", &s);
    v4 = 71 * v7;
    dword_848B800[v4] = (int)FS_FileOpen(&s, "rb");
    dword_848B808[71 * v7] = 0;
    if ( !dword_848B800[71 * v7] )
      v7 = 0;
  }
  *(_DWORD *)a2 = v7;
  if ( v7 )
    v6 = FS_filelength(v7);
  else
    v6 = 0;
  return v6;
}
// 848B7C0: using guessed type int fs_debug;
// 848B7C4: using guessed type int fs_homepath;
// 848B7D4: using guessed type int fs_cdpath;
// 848B800: using guessed type int dword_848B800[];
// 848B808: using guessed type int dword_848B808[];
// 848B814: using guessed type int dword_848B814[];

//----- (08064420) --------------------------------------------------------
int __cdecl FS_SV_Rename(char *a1, char *a2)
{
  int result; // eax
  char v3; // [esp+Fh] [ebp-209h]
  char newa; // [esp+10h] [ebp-208h]
  char v5; // [esp+10Fh] [ebp-109h]
  char s; // [esp+110h] [ebp-108h]

  FS_CheckFileSystemStarted();
  FS_BuildOSPath(*(void **)(fs_homepath + 8), a1, &byte_813C8A0, &s);
  FS_BuildOSPath(*(void **)(fs_homepath + 8), a2, &byte_813C8A0, &newa);
  *(&v5 + strlen(&s)) = 0;
  *(&v3 + strlen(&newa)) = 0;
  if ( *(_DWORD *)(fs_debug + 8) )
    Com_Printf("FS_SV_Rename: %s --> %s\n", &s, &newa);
  result = rename(&s, &newa);
  if ( result )
  {
    FS_CopyFile(&s, &newa);
    result = sub_809CACA(&s);
  }
  return result;
}
// 848B7C0: using guessed type int fs_debug;
// 848B7C4: using guessed type int fs_homepath;

//----- (0806451C) --------------------------------------------------------
void *__cdecl sub_806451C(char *s, char a2)
{
  signed int v3; // [esp+10h] [ebp-8h]
  signed int i; // [esp+14h] [ebp-4h]

  v3 = strlen(s);
  for ( i = 0; i < v3; ++i )
    *(_BYTE *)(i + 136207616) = s[i] + a2;
  *(_BYTE *)(i + 136207616) = 0;
  return &unk_81E5D00;
}

//----- (08064574) --------------------------------------------------------
signed int __cdecl sub_8064574(int a1, unsigned int a2, int a3)
{
  signed int v3; // ST14_4

  FS_CheckFileSystemStarted();
  if ( !a3 )
    return 0;
  if ( !dword_848B818[71 * a3] )
    return FS_Read(a1, a2, a3);
  dword_848B818[71 * a3] = 0;
  v3 = sub_80D216E(a1, a2, 1, a3);
  dword_848B818[71 * a3] = 1;
  return v3;
}

//----- (08064616) --------------------------------------------------------
int __cdecl sub_8064616(_DWORD *a1)
{
  int v2; // [esp+0h] [ebp-4h]

  v2 = 0;
  if ( a1 )
  {
    while ( *a1 )
    {
      ++a1;
      ++v2;
    }
  }
  return v2;
}

//----- (08064644) --------------------------------------------------------
_DWORD *__cdecl sub_8064644(void *ptr, void *a2, void *a3)
{
  int v3; // ST14_4
  int v4; // ST14_4
  int v5; // eax
  _DWORD *v7; // [esp+8h] [ebp-10h]
  _DWORD *v8; // [esp+8h] [ebp-10h]
  _DWORD *v9; // [esp+8h] [ebp-10h]
  _DWORD *v10; // [esp+Ch] [ebp-Ch]
  _DWORD *v11; // [esp+10h] [ebp-8h]

  v3 = sub_8064616(ptr);
  v4 = sub_8064616(a2) + v3;
  v5 = sub_8064616(a3);
  v11 = Z_MallocInternal(4 * (v5 + v4) + 4);
  v10 = v11;
  if ( ptr )
  {
    v7 = ptr;
    while ( *v7 )
    {
      *v10 = *v7;
      ++v7;
      ++v10;
    }
  }
  if ( a2 )
  {
    v8 = a2;
    while ( *v8 )
    {
      *v10 = *v8;
      ++v8;
      ++v10;
    }
  }
  if ( a3 )
  {
    v9 = a3;
    while ( *v9 )
    {
      *v10 = *v9;
      ++v9;
      ++v10;
    }
  }
  *v10 = 0;
  if ( ptr )
    Z_FreeInternal(ptr);
  if ( a2 )
    Z_FreeInternal(a2);
  if ( a3 )
    Z_FreeInternal(a3);
  return v11;
}

//----- (08064774) --------------------------------------------------------
int __cdecl FS_GetModList(char *a1, int a2)
{
  FILE *stream; // ST24_4
  signed int v4; // [esp+28h] [ebp-250h]
  void *v5; // [esp+2Ch] [ebp-24Ch]
  void *v6; // [esp+30h] [ebp-248h]
  void *v7; // [esp+34h] [ebp-244h]
  int v8; // [esp+38h] [ebp-240h]
  int v9; // [esp+3Ch] [ebp-23Ch]
  char dest[256]; // [esp+40h] [ebp-238h]
  char name; // [esp+140h] [ebp-138h]
  char *s; // [esp+244h] [ebp-34h]
  void *ptr; // [esp+248h] [ebp-30h]
  void *v14; // [esp+24Ch] [ebp-2Ch]
  int v15; // [esp+250h] [ebp-28h]
  int v16; // [esp+254h] [ebp-24h]
  int v17; // [esp+258h] [ebp-20h]
  size_t v18; // [esp+25Ch] [ebp-1Ch]
  int v19; // [esp+260h] [ebp-18h]
  int j; // [esp+264h] [ebp-14h]
  int i; // [esp+268h] [ebp-10h]
  int v22; // [esp+26Ch] [ebp-Ch]
  char *v23; // [esp+280h] [ebp+8h]

  v14 = 0;
  ptr = 0;
  v5 = 0;
  v4 = 0;
  *a1 = 0;
  v19 = 0;
  v16 = 0;
  v22 = 0;
  v7 = Sys_ListFiles(*(char **)(fs_homepath + 8), 0, 0, (int)&v8, 1);
  v6 = Sys_ListFiles(*(char **)(fs_basepath + 8), 0, 0, (int)&v8, 1);
  if ( *(_DWORD *)(fs_cdpath + 8) && **(_BYTE **)(fs_cdpath + 8) )
    v5 = Sys_ListFiles(*(char **)(fs_cdpath + 8), 0, 0, (int)&v8, 1);
  v14 = sub_8064644(v7, v6, v5);
  v16 = sub_8064616(v14);
  for ( i = 0; i < v16; ++i )
  {
    s = (char *)*((_DWORD *)v14 + i);
    if ( i )
    {
      v4 = 0;
      for ( j = 0; j < i; ++j )
      {
        if ( !I_stricmp(*((char **)v14 + j), s) )
        {
          v4 = 1;
          break;
        }
      }
    }
    if ( !v4 && sub_80B550A(s, ".", 1) )
    {
      FS_BuildOSPath(*(void **)(fs_basepath + 8), s, &byte_813C8A0, &name);
      v17 = 0;
      ptr = Sys_ListFiles(&name, "iwd", 0, (int)&v17, 0);
      Sys_FreeFileList(ptr);
      if ( v17 <= 0 )
      {
        FS_BuildOSPath(*(void **)(fs_cdpath + 8), s, &byte_813C8A0, &name);
        v17 = 0;
        ptr = Sys_ListFiles(&name, "iwd", 0, (int)&v17, 0);
        Sys_FreeFileList(ptr);
      }
      if ( v17 <= 0 )
      {
        FS_BuildOSPath(*(void **)(fs_homepath + 8), s, &byte_813C8A0, &name);
        v17 = 0;
        ptr = Sys_ListFiles(&name, "iwd", 0, (int)&v17, 0);
        Sys_FreeFileList(ptr);
      }
      if ( v17 > 0 )
      {
        v18 = strlen(s) + 1;
        strcpy(dest, s);
        sub_80B57C0(dest, 256, "/description.txt");
        v15 = FS_SV_FOpenFileRead(dest, (int)&v9);
        if ( v15 > 0 && v9 )
        {
          stream = (FILE *)FS_FileForHandle(v9);
          sub_80AA83E(dest, 0, 0x100u);
          v15 = FS_FileRead(dest, 1u, 0x30u, stream);
          if ( v15 >= 0 )
            dest[v15] = 0;
          FS_FCloseFile(v9);
        }
        else if ( I_stricmp(s, "main") )
        {
          strcpy(dest, s);
        }
        else
        {
          strcpy(dest, "Call of Duty 2 Multiplayer");
        }
        v15 = strlen(dest) + 1;
        if ( (signed int)(v15 + v19 + v18 + 2) >= a2 )
          break;
        strcpy(a1, s);
        v23 = &a1[v18];
        strcpy(v23, dest);
        a1 = &v23[v15];
        v19 += v15 + v18;
        ++v22;
      }
    }
  }
  Sys_FreeFileList(v14);
  return v22;
}
// 848B7C4: using guessed type int fs_homepath;
// 848B7D4: using guessed type int fs_cdpath;
// 8064774: using guessed type char dest[256];

//----- (08064C7C) --------------------------------------------------------
void FS_Dir_f()
{
  int i; // [esp+14h] [ebp-14h]
  int v1; // [esp+18h] [ebp-10h]
  void *ptr; // [esp+1Ch] [ebp-Ch]
  char *v3; // [esp+20h] [ebp-8h]
  char v4[4]; // [esp+24h] [ebp-4h]

  if ( Cmd_Argc() > 1 && Cmd_Argc() <= 3 )
  {
    if ( Cmd_Argc() == 2 )
    {
      *(_DWORD *)v4 = Cmd_Argv(1u);
      v3 = &byte_813C8A0;
    }
    else
    {
      *(_DWORD *)v4 = Cmd_Argv(1u);
      v3 = Cmd_Argv(2u);
    }
    Com_Printf("Directory of %s %s\n", *(_DWORD *)v4, v3);
    Com_Printf("---------------\n");
    ptr = sub_809F7B2(*(int *)v4, v3, 0, (int)&v1);
    for ( i = 0; i < v1; ++i )
      Com_Printf("%s\n", *((_DWORD *)ptr + i));
    FS_FreeFileList(ptr);
  }
  else
  {
    Com_Printf("usage: dir <directory> [extension]\n");
  }
}

//----- (08064D88) --------------------------------------------------------
void FS_NewDir_f()
{
  int i; // [esp+28h] [ebp-10h]
  char v1[4]; // [esp+2Ch] [ebp-Ch]
  void *ptr; // [esp+30h] [ebp-8h]
  int v3; // [esp+34h] [ebp-4h]

  if ( Cmd_Argc() > 1 )
  {
    v3 = (int)Cmd_Argv(1u);
    Com_Printf("---------------\n");
    ptr = FS_ListFilteredFiles((int)fs_searchpaths, (int)&byte_813C8A0, &byte_813C8A0, v3, 0, (int)v1);
    FS_SortFileList(ptr, *(int *)v1);
    for ( i = 0; i < *(_DWORD *)v1; ++i )
    {
      FS_ConvertPath(*((_BYTE **)ptr + i));
      Com_Printf("%s\n", *((_DWORD *)ptr + i));
    }
    Com_Printf("%d files listed\n", *(_DWORD *)v1);
    FS_FreeFileList(ptr);
  }
  else
  {
    Com_Printf("usage: fdir <filter>\n");
    Com_Printf("example: fdir *q3dm*.bsp\n");
  }
}

//----- (08064E98) --------------------------------------------------------
void FS_TouchFile_f()
{
  char *v0; // eax

  if ( Cmd_Argc() == 2 )
  {
    v0 = Cmd_Argv(1u);
    FS_TouchFile((int)v0);
  }
  else
  {
    Com_Printf("Usage: touchFile <file>\n");
  }
}

//----- (08064ECC) --------------------------------------------------------
int __cdecl sub_8064ECC(char *haystack, int a2)
{
  char *v2; // eax
  char *v3; // eax
  char *v4; // eax
  char *v7; // [esp+1Ch] [ebp-5Ch]
  char dest; // [esp+20h] [ebp-58h]
  __int16 v9; // [esp+2Ah] [ebp-4Eh]
  char v10[4]; // [esp+6Ch] [ebp-Ch]

  for ( *(_DWORD *)v10 = 0; *(_DWORD *)v10 <= 24; ++*(_DWORD *)v10 )
  {
    v2 = va("%s/iw_%02d", a2, *(_DWORD *)v10);
    if ( !FS_FilenameCompare(haystack, v2) )
      return 1;
  }
  v7 = strstr(haystack, "localized_");
  if ( v7 )
  {
    strcpy(&dest, haystack);
    *((_BYTE *)&v9 + v7 - haystack) = 0;
    v3 = va("%s/localized_", a2);
    if ( !FS_FilenameCompare(&dest, v3) )
    {
      strcpy(&dest, v7 + 10);
      sub_80B573C(&dest);
      for ( *(_DWORD *)v10 = 0; *(_DWORD *)v10 <= 24; ++*(_DWORD *)v10 )
      {
        v4 = va("_iw%02d", *(_DWORD *)v10);
        if ( strstr(&dest, v4) )
          return 1;
      }
    }
  }
  return 0;
}

//----- (08064FF8) --------------------------------------------------------
signed int __cdecl sub_8064FF8(char *a1, int a2, int a3)
{
  char *v3; // eax
  char *v4; // eax
  char s; // [esp+30h] [ebp-118h]
  int i; // [esp+134h] [ebp-14h]
  int v9; // [esp+138h] [ebp-10h]
  int *j; // [esp+13Ch] [ebp-Ch]

  if ( !dword_8491F20 )
    return 0;
  *a1 = 0;
  for ( i = 0; i < dword_8491F20; ++i )
  {
    v9 = 0;
    if ( !sub_8064ECC(dword_8492F40[i], (int)"main") )
    {
      for ( j = (int *)fs_searchpaths; j; j = (int *)*j )
      {
        if ( j[1] && *(_DWORD *)(j[1] + 772) == dword_8491F40[i] )
        {
          v9 = 1;
          break;
        }
      }
      if ( !v9 && dword_8492F40[i] && *dword_8492F40[i] )
      {
        if ( a3 )
        {
          sub_80B57C0(a1, a2, "@");
          sub_80B57C0(a1, a2, dword_8492F40[i]);
          sub_80B57C0(a1, a2, ".iwd");
          sub_80B57C0(a1, a2, "@");
          v3 = va("%s.iwd", dword_8492F40[i]);
          if ( sub_8063F00(v3) )
          {
            Com_sprintf(&s, 0x100u, "%s.%08x.iwd", dword_8492F40[i], dword_8491F40[i]);
            sub_80B57C0(a1, a2, &s);
          }
          else
          {
            sub_80B57C0(a1, a2, dword_8492F40[i]);
            sub_80B57C0(a1, a2, ".iwd");
          }
        }
        else
        {
          sub_80B57C0(a1, a2, dword_8492F40[i]);
          sub_80B57C0(a1, a2, ".iwd");
          v4 = va("%s.iwd", dword_8492F40[i]);
          if ( sub_8063F00(v4) )
            sub_80B57C0(a1, a2, " (local file exists with wrong checksum)");
          sub_80B57C0(a1, a2, "\n");
        }
      }
    }
  }
  if ( !*a1 )
    return 0;
  Com_Printf("Need iwds: %s\n", a1);
  return 1;
}
// 8491F20: using guessed type int dword_8491F20;

//----- (080652E2) --------------------------------------------------------
void sub_80652E2()
{
  Cmd_RemoveCommand("path");
  Cmd_RemoveCommand("dir");
  Cmd_RemoveCommand("fdir");
  Cmd_RemoveCommand("touchFile");
}

//----- (0806531A) --------------------------------------------------------
void FS_AddCommands()
{
  Cmd_AddCommand("path", (int)FS_Path_f);
  Cmd_AddCommand("fullpath", (int)FS_FullPath_f);
  Cmd_AddCommand("dir", (int)FS_Dir_f);
  Cmd_AddCommand("fdir", (int)FS_NewDir_f);
  Cmd_AddCommand("touchFile", (int)FS_TouchFile_f);
}

//----- (08065386) --------------------------------------------------------
_DWORD *__usercall FS_SetRestrictions@<eax>(long double a1@<st0>)
{
  _DWORD *result; // eax
  _DWORD *i; // [esp+14h] [ebp-4h]

  result = (_DWORD *)fs_restrict;
  if ( *(_BYTE *)(fs_restrict + 8) )
  {
    Dvar_SetBool(fs_restrict, 1);
    Com_Printf("\nRunning in restricted demo mode.\n\n");
    FS_Shutdown();
    FS_Startup(a1, "demomain");
    result = fs_searchpaths;
    for ( i = fs_searchpaths; i; i = (_DWORD *)*i )
    {
      if ( FS_UseSearchPath((int)i) && i[1] && (*(_DWORD *)(i[1] + 772) ^ 0x2261994) != -1277981599 )
        Com_Error(0, "Corrupted iw0.iwd: %u", *(_DWORD *)(i[1] + 772));
      result = (_DWORD *)*i;
    }
  }
  return result;
}
// 848B7E0: using guessed type int fs_restrict;

//----- (08065448) --------------------------------------------------------
char *sub_8065448()
{
  char *v0; // eax
  _DWORD *i; // [esp+14h] [ebp-4h]

  byte_81D7D00 = 0;
  for ( i = fs_searchpaths; i; i = (_DWORD *)*i )
  {
    if ( i[1] )
    {
      if ( !i[3] )
      {
        v0 = va("%i ", *(_DWORD *)(i[1] + 772));
        sub_80B57C0(&byte_81D7D00, 0x2000, v0);
      }
    }
  }
  return &byte_81D7D00;
}

//----- (080654C0) --------------------------------------------------------
char *sub_80654C0()
{
  _DWORD *i; // [esp+14h] [ebp-4h]

  byte_81D9D00 = 0;
  for ( i = fs_searchpaths; i; i = (_DWORD *)*i )
  {
    if ( i[1] && !i[3] )
    {
      if ( byte_81D9D00 )
        sub_80B57C0(&byte_81D9D00, 0x2000, " ");
      sub_80B57C0(&byte_81D9D00, 0x2000, (char *)(i[1] + 256));
    }
  }
  return &byte_81D9D00;
}

//----- (0806554C) --------------------------------------------------------
char *sub_806554C()
{
  char *v0; // eax
  _DWORD *i; // [esp+14h] [ebp-4h]

  byte_81DBD00 = 0;
  for ( i = fs_searchpaths; i; i = (_DWORD *)*i )
  {
    if ( i[1] )
    {
      if ( !i[3] )
      {
        v0 = va("%i ", *(_DWORD *)(i[1] + 776));
        sub_80B57C0(&byte_81DBD00, 0x2000, v0);
      }
    }
  }
  return &byte_81DBD00;
}

//----- (080655C4) --------------------------------------------------------
char *sub_80655C4()
{
  char *v0; // eax
  _DWORD *i; // [esp+14h] [ebp-4h]

  byte_81DDD00 = 0;
  for ( i = fs_searchpaths; i; i = (_DWORD *)*i )
  {
    if ( i[1] && (*(_BYTE *)(i[1] + 784) || sub_80B550A((char *)(i[1] + 512), "main", 4)) )
    {
      v0 = va("%i ", *(_DWORD *)(i[1] + 772));
      sub_80B57C0(&byte_81DDD00, 0x2000, v0);
    }
  }
  return &byte_81DDD00;
}

//----- (08065670) --------------------------------------------------------
char *sub_8065670()
{
  _DWORD *i; // [esp+14h] [ebp-4h]

  byte_81E3D00 = 0;
  for ( i = fs_searchpaths; i; i = (_DWORD *)*i )
  {
    if ( i[1] && (*(_BYTE *)(i[1] + 784) || sub_80B550A((char *)(i[1] + 512), "main", 4)) )
    {
      if ( byte_81E3D00 )
        sub_80B57C0(&byte_81E3D00, 0x2000, " ");
      sub_80B57C0(&byte_81E3D00, 0x2000, (char *)(i[1] + 512));
      sub_80B57C0(&byte_81E3D00, 0x2000, "/");
      sub_80B57C0(&byte_81E3D00, 0x2000, (char *)(i[1] + 256));
    }
  }
  return &byte_81E3D00;
}

//----- (08065774) --------------------------------------------------------
char *sub_8065774()
{
  char *v0; // eax
  char *v1; // eax
  char *v2; // eax
  int v4; // [esp+Ch] [ebp-Ch]
  int v5; // [esp+10h] [ebp-8h]
  _DWORD *i; // [esp+14h] [ebp-4h]

  byte_81DFD00 = 0;
  v4 = fs_checksumFeed;
  v5 = 0;
  byte_81DFD01[strlen(&byte_81DFD00)] = 0;
  byte_81DFD02[strlen(&byte_81DFD00)] = 0;
  *(&byte_81DFD00 + strlen(&byte_81DFD00)) = 64;
  *(&byte_81DFD00 + strlen(&byte_81DFD00)) = 32;
  for ( i = fs_searchpaths; i; i = (_DWORD *)*i )
  {
    if ( i[1] && !i[3] )
    {
      if ( *(_BYTE *)(i[1] + 784) )
      {
        v0 = va("%i ", *(_DWORD *)(i[1] + 776));
        sub_80B57C0(&byte_81DFD00, 0x2000, v0);
        v4 ^= *(_DWORD *)(i[1] + 776);
        ++v5;
      }
    }
  }
  if ( *(_DWORD *)dword_848B7F0 )
  {
    v1 = va("%i ", *(_DWORD *)dword_848B7F0);
    sub_80B57C0(&byte_81DFD00, 0x2000, v1);
  }
  v2 = va("%i ", v5 ^ v4);
  sub_80B57C0(&byte_81DFD00, 0x2000, v2);
  return &byte_81DFD00;
}
// 848B7F4: using guessed type int fs_checksumFeed;

//----- (080658D8) --------------------------------------------------------
void *__cdecl FS_PureServerSetLoadedIwds(_BYTE *a1, _BYTE *a2)
{
  int v2; // ebx
  char *v3; // eax
  int v4; // ebx
  char *v5; // eax
  void *result; // eax
  void *ptr[1024]; // [esp+10h] [ebp-2018h]
  int src[1024]; // [esp+1010h] [ebp-1018h]
  void *v9; // [esp+2010h] [ebp-18h]
  void *v10; // [esp+2014h] [ebp-14h]
  int j; // [esp+2018h] [ebp-10h]
  int i; // [esp+201Ch] [ebp-Ch]

  Cmd_TokenizeString(a1);
  v10 = (void *)Cmd_Argc();
  if ( (signed int)v10 > 1024 )
    v10 = (void *)1024;
  for ( i = 0; i < (signed int)v10; ++i )
  {
    v2 = i;
    v3 = Cmd_Argv(i);
    src[v2] = atoi(v3);
  }
  Cmd_TokenizeString(a2);
  v9 = (void *)Cmd_Argc();
  if ( (signed int)v9 > 1024 )
    v9 = (void *)1024;
  for ( i = 0; i < (signed int)v9; ++i )
  {
    v4 = i;
    v5 = Cmd_Argv(i);
    ptr[v4] = sub_80A93B0(v5);
  }
  if ( v10 != v9 )
    Com_Error(1, "iwd sum/name mismatch");
  if ( v10 == (void *)fs_numServerIwds )
  {
    i = 0;
LABEL_15:
    if ( i >= (signed int)v10 )
    {
      for ( i = 0; ; ++i )
      {
        result = (void *)i;
        if ( i >= (signed int)v9 )
          break;
        Z_FreeInternal(ptr[i]);
      }
      return result;
    }
    for ( j = 0; j < fs_numServerIwds; ++j )
    {
      if ( src[i] == dword_848FF20[j] && !I_stricmp((char *)ptr[i], (char *)dword_8490F20[j]) )
      {
        ++i;
        goto LABEL_15;
      }
    }
  }
  FS_ShutdownServerIwdNames();
  result = v10;
  fs_numServerIwds = (int)v10;
  if ( v10 )
  {
    Com_DPrintf("Connected to a pure server.\n");
    Com_Memcpy(dword_848FF20, src, 4 * fs_numServerIwds);
    result = Com_Memcpy(dword_8490F20, ptr, 4 * fs_numServerIwds);
    *(_DWORD *)dword_848B7F0 = 0;
  }
  return result;
}
// 848FF00: using guessed type int fs_numServerIwds;
// 80658D8: using guessed type int src[1024];

//----- (08065AD2) --------------------------------------------------------
int __cdecl sub_8065AD2(_BYTE *a1, _BYTE *a2)
{
  char *v2; // eax
  char *v3; // eax
  int result; // eax
  int v5; // [esp+8h] [ebp-10h]
  int v6; // [esp+Ch] [ebp-Ch]
  signed int i; // [esp+10h] [ebp-8h]
  signed int j; // [esp+10h] [ebp-8h]

  Cmd_TokenizeString(a1);
  v6 = Cmd_Argc();
  if ( v6 > 1024 )
    v6 = 1024;
  FS_ShutdownServerReferencedIwds();
  for ( i = 0; i < v6; ++i )
  {
    v2 = Cmd_Argv(i);
    dword_8491F40[i] = atoi(v2);
  }
  if ( a2 && *a2 )
  {
    Cmd_TokenizeString(a2);
    v5 = Cmd_Argc();
    if ( v5 > 1024 )
      v5 = 1024;
    if ( v6 != v5 )
      Com_Error(1, "iwd sum/name mismatch");
    for ( j = 0; j < v5; ++j )
    {
      v3 = Cmd_Argv(j);
      dword_8492F40[j] = sub_80A93B0(v3);
    }
  }
  else if ( v6 )
  {
    Com_Error(1, "iwd sum/name mismatch");
  }
  result = v6;
  dword_8491F20 = v6;
  return result;
}
// 8491F20: using guessed type int dword_8491F20;

//----- (08065BE0) --------------------------------------------------------
void *__cdecl sub_8065BE0(char *s)
{
  signed int i; // [esp+10h] [ebp-8h]
  signed int n; // [esp+14h] [ebp-4h]

  if ( !sub_80B550A(s, "maps/mp/", 8) )
    s += 8;
  n = strlen(s);
  if ( !strcasecmp(&s[n - 3], "bsp") )
    n -= 7;
  memcpy(&unk_81E6100, s, n);
  *(_BYTE *)(n + 136208640) = 0;
  for ( i = 0; i < n; ++i )
  {
    if ( *(_BYTE *)(i + 136208640) == 37 )
      *(_BYTE *)(i + 136208640) = 95;
  }
  return &unk_81E6100;
}

//----- (08065D50) --------------------------------------------------------
int __cdecl sub_8065D50(char a1, int a2)
{
  int result; // eax

  if ( !(dword_81E6144 & 7) )
    *(_BYTE *)((dword_81E6144 >> 3) + a2) = 0;
  result = a1 << (dword_81E6144 & 7);
  LOBYTE(result) = *(_BYTE *)((dword_81E6144 >> 3) + a2) | result;
  *(_BYTE *)((dword_81E6144++ >> 3) + a2) = result;
  return result;
}
// 81E6144: using guessed type int dword_81E6144;

//----- (08065DBA) --------------------------------------------------------
int __cdecl sub_8065DBA(int a1)
{
  int v1; // ST00_4

  v1 = ((signed int)*(unsigned __int8 *)((dword_81E6144 >> 3) + a1) >> (dword_81E6144 & 7)) & 1;
  ++dword_81E6144;
  return v1;
}
// 81E6144: using guessed type int dword_81E6144;

//----- (08065DEE) --------------------------------------------------------
int __cdecl sub_8065DEE(int a1)
{
  int v1; // eax
  _DWORD *v2; // ST04_4
  int v4; // [esp+0h] [ebp-8h]

  if ( *(_DWORD *)(a1 + 1048) )
  {
    v2 = *(_DWORD **)(a1 + 1048);
    *(_DWORD *)(a1 + 1048) = *v2;
    v4 = (int)v2;
  }
  else
  {
    v1 = a1 + 4 * (*(_DWORD *)(a1 + 4))++;
    v4 = v1 + 25628;
  }
  return v4;
}

//----- (08065E3E) --------------------------------------------------------
_DWORD *__cdecl sub_8065E3E(int a1, _DWORD *a2)
{
  _DWORD *result; // eax

  *a2 = *(_DWORD *)(a1 + 1048);
  result = a2;
  *(_DWORD *)(a1 + 1048) = a2;
  return result;
}

//----- (08065E5E) --------------------------------------------------------
_DWORD *__cdecl sub_8065E5E(int a1, int a2, int a3)
{
  _DWORD *result; // eax
  _DWORD *v4; // [esp+0h] [ebp-8h]
  _DWORD *v5; // [esp+4h] [ebp-4h]

  v5 = *(_DWORD **)(a2 + 8);
  v4 = *(_DWORD **)(a3 + 8);
  if ( v5 )
  {
    if ( *v5 == a2 )
      *v5 = a3;
    else
      v5[1] = a3;
  }
  else
  {
    *(_DWORD *)(a1 + 8) = a3;
  }
  if ( v4 )
  {
    if ( *v4 == a3 )
      *v4 = a2;
    else
      v4[1] = a2;
  }
  else
  {
    *(_DWORD *)(a1 + 8) = a2;
  }
  *(_DWORD *)(a2 + 8) = v4;
  result = v5;
  *(_DWORD *)(a3 + 8) = v5;
  return result;
}

//----- (08065EE6) --------------------------------------------------------
int __cdecl sub_8065EE6(int a1, int a2)
{
  int v2; // ST00_4
  int v3; // ST00_4
  int result; // eax

  v2 = *(_DWORD *)(a1 + 12);
  *(_DWORD *)(a1 + 12) = *(_DWORD *)(a2 + 12);
  *(_DWORD *)(a2 + 12) = v2;
  v3 = *(_DWORD *)(a1 + 16);
  *(_DWORD *)(a1 + 16) = *(_DWORD *)(a2 + 16);
  *(_DWORD *)(a2 + 16) = v3;
  if ( *(_DWORD *)(a1 + 12) == a1 )
    *(_DWORD *)(a1 + 12) = a2;
  if ( *(_DWORD *)(a2 + 12) == a2 )
    *(_DWORD *)(a2 + 12) = a1;
  if ( *(_DWORD *)(a1 + 12) )
    *(_DWORD *)(*(_DWORD *)(a1 + 12) + 16) = a1;
  if ( *(_DWORD *)(a2 + 12) )
    *(_DWORD *)(*(_DWORD *)(a2 + 12) + 16) = a2;
  if ( *(_DWORD *)(a1 + 16) )
    *(_DWORD *)(*(_DWORD *)(a1 + 16) + 12) = a1;
  result = a2;
  if ( *(_DWORD *)(a2 + 16) )
  {
    result = a2;
    *(_DWORD *)(*(_DWORD *)(a2 + 16) + 12) = a2;
  }
  return result;
}

//----- (08065FA6) --------------------------------------------------------
void __cdecl sub_8065FA6(int a1, int a2)
{
  int v2; // [esp+10h] [ebp-8h]

  if ( a2 )
  {
    if ( *(_DWORD *)(a2 + 12) && *(_DWORD *)(*(_DWORD *)(a2 + 12) + 24) == *(_DWORD *)(a2 + 24) )
    {
      v2 = **(_DWORD **)(a2 + 20);
      if ( v2 != *(_DWORD *)(a2 + 8) )
        sub_8065E5E(a1, v2, a2);
      sub_8065EE6(v2, a2);
    }
    if ( *(_DWORD *)(a2 + 16) && *(_DWORD *)(*(_DWORD *)(a2 + 16) + 24) == *(_DWORD *)(a2 + 24) )
    {
      **(_DWORD **)(a2 + 20) = *(_DWORD *)(a2 + 16);
    }
    else
    {
      **(_DWORD **)(a2 + 20) = 0;
      sub_8065E3E(a1, *(_DWORD **)(a2 + 20));
    }
    ++*(_DWORD *)(a2 + 24);
    if ( *(_DWORD *)(a2 + 12) && *(_DWORD *)(*(_DWORD *)(a2 + 12) + 24) == *(_DWORD *)(a2 + 24) )
    {
      *(_DWORD *)(a2 + 20) = *(_DWORD *)(*(_DWORD *)(a2 + 12) + 20);
    }
    else
    {
      *(_DWORD *)(a2 + 20) = sub_8065DEE(a1);
      **(_DWORD **)(a2 + 20) = a2;
    }
    if ( *(_DWORD *)(a2 + 8) )
    {
      sub_8065FA6(a1, *(_DWORD *)(a2 + 8));
      if ( *(_DWORD *)(a2 + 16) == *(_DWORD *)(a2 + 8) )
      {
        sub_8065EE6(a2, *(_DWORD *)(a2 + 8));
        if ( **(_DWORD **)(a2 + 20) == a2 )
          **(_DWORD **)(a2 + 20) = *(_DWORD *)(a2 + 8);
      }
    }
  }
}

//----- (0806610E) --------------------------------------------------------
void __cdecl sub_806610E(_DWORD *a1, unsigned __int8 a2)
{
  int v2; // ecx
  _DWORD *v3; // [esp+8h] [ebp-10h]
  _DWORD *v4; // [esp+Ch] [ebp-Ch]

  if ( a1[a2 + 5] )
  {
    sub_8065FA6((int)a1, a1[a2 + 5]);
  }
  else
  {
    v4 = &a1[8 * (*a1)++ + 263];
    v3 = &a1[8 * (*a1)++ + 263];
    v3[7] = 257;
    v3[6] = 1;
    v3[3] = *(_DWORD *)(a1[3] + 12);
    if ( *(_DWORD *)(a1[3] + 12) )
    {
      *(_DWORD *)(*(_DWORD *)(a1[3] + 12) + 16) = v3;
      if ( *(_DWORD *)(*(_DWORD *)(a1[3] + 12) + 24) == 1 )
      {
        v3[5] = *(_DWORD *)(*(_DWORD *)(a1[3] + 12) + 20);
      }
      else
      {
        v3[5] = sub_8065DEE((int)a1);
        *(_DWORD *)v3[5] = v3;
      }
    }
    else
    {
      v3[5] = sub_8065DEE((int)a1);
      *(_DWORD *)v3[5] = v3;
    }
    *(_DWORD *)(a1[3] + 12) = v3;
    v3[4] = a1[3];
    v4[7] = a2;
    v4[6] = 1;
    v4[3] = *(_DWORD *)(a1[3] + 12);
    if ( *(_DWORD *)(a1[3] + 12) )
    {
      *(_DWORD *)(*(_DWORD *)(a1[3] + 12) + 16) = v4;
      if ( *(_DWORD *)(*(_DWORD *)(a1[3] + 12) + 24) == 1 )
      {
        v4[5] = *(_DWORD *)(*(_DWORD *)(a1[3] + 12) + 20);
      }
      else
      {
        v4[5] = sub_8065DEE((int)a1);
        *(_DWORD *)v4[5] = v3;
      }
    }
    else
    {
      v4[5] = sub_8065DEE((int)a1);
      *(_DWORD *)v4[5] = v4;
    }
    *(_DWORD *)(a1[3] + 12) = v4;
    v4[4] = a1[3];
    v4[1] = 0;
    *v4 = 0;
    if ( *(_DWORD *)(a1[3] + 8) )
    {
      if ( **(_DWORD **)(a1[3] + 8) == a1[3] )
        **(_DWORD **)(a1[3] + 8) = v3;
      else
        *(_DWORD *)(*(_DWORD *)(a1[3] + 8) + 4) = v3;
    }
    else
    {
      a1[2] = v3;
    }
    v3[1] = v4;
    *v3 = a1[3];
    v3[2] = *(_DWORD *)(a1[3] + 8);
    v2 = a1[3];
    v4[2] = v3;
    *(_DWORD *)(v2 + 8) = v3;
    a1[a2 + 5] = v4;
    sub_8065FA6((int)a1, v3[2]);
  }
}

//----- (08066394) --------------------------------------------------------
int __cdecl sub_8066394(_DWORD *a1, _DWORD *a2, int a3)
{
  int v3; // edx

  while ( a1 && a1[7] == 257 )
  {
    if ( sub_8065DBA(a3) )
      a1 = (_DWORD *)a1[1];
    else
      a1 = (_DWORD *)*a1;
  }
  if ( !a1 )
    return 0;
  v3 = a1[7];
  *a2 = v3;
  return v3;
}

//----- (080663F6) --------------------------------------------------------
int __cdecl sub_80663F6(_DWORD *a1, _DWORD *a2, int a3, int *a4)
{
  int result; // eax

  dword_81E6144 = *a4;
  while ( a1 && a1[7] == 257 )
  {
    if ( sub_8065DBA(a3) )
      a1 = (_DWORD *)a1[1];
    else
      a1 = (_DWORD *)*a1;
  }
  if ( a1 )
  {
    *a2 = a1[7];
    result = dword_81E6144;
    *a4 = dword_81E6144;
  }
  else
  {
    result = (int)a2;
    *a2 = 0;
  }
  return result;
}
// 81E6144: using guessed type int dword_81E6144;

//----- (08066466) --------------------------------------------------------
int __cdecl sub_8066466(int a1, int a2, int a3)
{
  int result; // eax

  result = a1;
  if ( *(_DWORD *)(a1 + 8) )
    result = sub_8066466(*(_DWORD *)(a1 + 8), a1, a3);
  if ( a2 )
  {
    if ( *(_DWORD *)(a1 + 4) == a2 )
      result = sub_8065D50(1, a3);
    else
      result = sub_8065D50(0, a3);
  }
  return result;
}

//----- (080664CC) --------------------------------------------------------
int *__cdecl sub_80664CC(int a1, int a2, int a3)
{
  int *result; // eax
  int i; // [esp+14h] [ebp-4h]

  if ( *(_DWORD *)(a1 + 4 * a2 + 20) )
    return (int *)sub_8066466(*(_DWORD *)(a1 + 4 * a2 + 20), 0, a3);
  result = (int *)sub_80664CC(a1, 256, a3);
  for ( i = 7; i >= 0; --i )
  {
    sub_8065D50((a2 >> i) & 1, a3);
    result = &i;
  }
  return result;
}

//----- (08066550) --------------------------------------------------------
int __cdecl sub_8066550(int a1, int a2, int a3, int *a4)
{
  int result; // eax

  dword_81E6144 = *a4;
  sub_8066466(*(_DWORD *)(a1 + 4 * a2 + 20), 0, a3);
  result = dword_81E6144;
  *a4 = dword_81E6144;
  return result;
}
// 81E6144: using guessed type int dword_81E6144;

//----- (0806658E) --------------------------------------------------------
int __cdecl sub_806658E(_DWORD *a1, int a2)
{
  int result; // eax
  int v3; // eax
  int v4; // edx
  int v5; // ecx
  _DWORD *v6; // edx
  int v7; // ebx
  char *s; // [esp+1Ch] [ebp-6Ch]
  char v9; // [esp+20h] [ebp-68h]
  void *src; // [esp+3Ch] [ebp-4Ch]
  char v11; // [esp+40h] [ebp-48h]
  unsigned __int8 *v12; // [esp+58h] [ebp-30h]
  int v13; // [esp+5Ch] [ebp-2Ch]
  int i; // [esp+60h] [ebp-28h]
  int j; // [esp+64h] [ebp-24h]
  size_t n; // [esp+68h] [ebp-20h]
  int v17; // [esp+6Ch] [ebp-1Ch]

  sub_80AA1F6((int *)&v11, 0x10000);
  src = sub_80AA240((int *)&v11);
  sub_80AA1F6((int *)&v9, 28700);
  s = sub_80AA240((int *)&v9);
  v13 = a1[3] - a2;
  v12 = (unsigned __int8 *)(a1[1] + a2);
  if ( v13 > 0 )
  {
    sub_80AA83E(s, 0, 0x701Cu);
    *((_DWORD *)s + 261) = &s[32 * *(_DWORD *)s + 1052];
    v3 = *((_DWORD *)s + 261);
    ++*(_DWORD *)s;
    *((_DWORD *)s + 4) = v3;
    *((_DWORD *)s + 3) = v3;
    *((_DWORD *)s + 2) = v3;
    *(_DWORD *)(*((_DWORD *)s + 2) + 28) = 256;
    *(_DWORD *)(*((_DWORD *)s + 2) + 24) = 0;
    v4 = *((_DWORD *)s + 3);
    *(_DWORD *)(*((_DWORD *)s + 3) + 16) = 0;
    *(_DWORD *)(v4 + 12) = 0;
    v5 = *((_DWORD *)s + 2);
    v6 = (_DWORD *)*((_DWORD *)s + 2);
    *(_DWORD *)(*((_DWORD *)s + 2) + 4) = 0;
    *v6 = 0;
    *(_DWORD *)(v5 + 8) = 0;
    n = v12[1] + (*v12 << 8);
    if ( (signed int)n > a1[2] - a2 )
      n = a1[2] - a2;
    dword_81E6144 = 16;
    for ( i = 0; i < (signed int)n; ++i )
    {
      v17 = 0;
      if ( dword_81E6144 >> 3 > v13 )
      {
        *((_BYTE *)src + i) = 0;
        break;
      }
      sub_8066394(*((_DWORD **)s + 2), &v17, (int)v12);
      if ( v17 == 256 )
      {
        v17 = 0;
        for ( j = 0; j <= 7; ++j )
        {
          v7 = 2 * v17;
          v17 = sub_8065DBA((int)v12) + v7;
        }
      }
      *((_BYTE *)src + i) = v17;
      sub_806610E(s, v17);
    }
    a1[3] = n + a2;
    Com_Memcpy((void *)(a1[1] + a2), src, n);
    sub_80AA22A((int *)&v9);
    result = sub_80AA22A((int *)&v11);
  }
  else
  {
    sub_80AA22A((int *)&v9);
    result = sub_80AA22A((int *)&v11);
  }
  return result;
}
// 81E6144: using guessed type int dword_81E6144;

//----- (08066838) --------------------------------------------------------
int __cdecl sub_8066838(int a1, int a2)
{
  int result; // eax
  int v3; // eax
  int v4; // edx
  int v5; // ecx
  _DWORD *v6; // edx
  char *s; // [esp+1Ch] [ebp-4Ch]
  char v8; // [esp+20h] [ebp-48h]
  void *src; // [esp+3Ch] [ebp-2Ch]
  char v10; // [esp+40h] [ebp-28h]
  int v11; // [esp+50h] [ebp-18h]
  int v12; // [esp+54h] [ebp-14h]
  int v13; // [esp+58h] [ebp-10h]
  int i; // [esp+5Ch] [ebp-Ch]

  sub_80AA1F6((int *)&v10, 0x10000);
  src = sub_80AA240((int *)&v10);
  sub_80AA1F6((int *)&v8, 28700);
  s = sub_80AA240((int *)&v8);
  v12 = *(_DWORD *)(a1 + 12) - a2;
  v11 = *(_DWORD *)(a1 + 4) + a2;
  if ( v12 > 0 )
  {
    sub_80AA83E(s, 0, 0x701Cu);
    *((_DWORD *)s + 261) = &s[32 * *(_DWORD *)s + 1052];
    v3 = *((_DWORD *)s + 261);
    ++*(_DWORD *)s;
    *((_DWORD *)s + 3) = v3;
    *((_DWORD *)s + 2) = v3;
    *(_DWORD *)(*((_DWORD *)s + 2) + 28) = 256;
    *(_DWORD *)(*((_DWORD *)s + 2) + 24) = 0;
    v4 = *((_DWORD *)s + 3);
    *(_DWORD *)(*((_DWORD *)s + 3) + 16) = 0;
    *(_DWORD *)(v4 + 12) = 0;
    v5 = *((_DWORD *)s + 2);
    v6 = (_DWORD *)*((_DWORD *)s + 2);
    *(_DWORD *)(*((_DWORD *)s + 2) + 4) = 0;
    *v6 = 0;
    *(_DWORD *)(v5 + 8) = 0;
    *((_DWORD *)s + 261) = *((_DWORD *)s + 2);
    *(_BYTE *)src = BYTE1(v12);
    *((_BYTE *)src + 1) = v12;
    dword_81E6144 = 16;
    for ( i = 0; i < v12; ++i )
    {
      v13 = *(unsigned __int8 *)(v11 + i);
      sub_80664CC((int)s, v13, (int)src);
      sub_806610E(s, v13);
    }
    dword_81E6144 += 8;
    *(_DWORD *)(a1 + 12) = a2 + (dword_81E6144 >> 3);
    Com_Memcpy((void *)(*(_DWORD *)(a1 + 4) + a2), src, dword_81E6144 >> 3);
    sub_80AA22A((int *)&v8);
    result = sub_80AA22A((int *)&v10);
  }
  else
  {
    sub_80AA22A((int *)&v8);
    result = sub_80AA22A((int *)&v10);
  }
  return result;
}
// 81E6144: using guessed type int dword_81E6144;

//----- (08066A70) --------------------------------------------------------
int __cdecl sub_8066A70(void *s)
{
  int v1; // eax
  int v2; // edx
  int v3; // ecx
  _DWORD *v4; // edx
  int v5; // eax
  int v6; // edx
  int v7; // ecx
  _DWORD *v8; // edx
  int result; // eax

  sub_80AA83E(s, 0, 0x701Cu);
  sub_80AA83E((char *)s + 28700, 0, 0x701Cu);
  *((_DWORD *)s + 7436) = (char *)s + 32 * *((_DWORD *)s + 7175) + 29752;
  v1 = *((_DWORD *)s + 7436);
  ++*((_DWORD *)s + 7175);
  *((_DWORD *)s + 7179) = v1;
  *((_DWORD *)s + 7178) = v1;
  *((_DWORD *)s + 7177) = v1;
  *(_DWORD *)(*((_DWORD *)s + 7177) + 28) = 256;
  *(_DWORD *)(*((_DWORD *)s + 7177) + 24) = 0;
  v2 = *((_DWORD *)s + 7178);
  *(_DWORD *)(*((_DWORD *)s + 7178) + 16) = 0;
  *(_DWORD *)(v2 + 12) = 0;
  v3 = *((_DWORD *)s + 7177);
  v4 = (_DWORD *)*((_DWORD *)s + 7177);
  *(_DWORD *)(*((_DWORD *)s + 7177) + 4) = 0;
  *v4 = 0;
  *(_DWORD *)(v3 + 8) = 0;
  *((_DWORD *)s + 261) = (char *)s + 32 * *(_DWORD *)s + 1052;
  v5 = *((_DWORD *)s + 261);
  ++*(_DWORD *)s;
  *((_DWORD *)s + 3) = v5;
  *((_DWORD *)s + 2) = v5;
  *(_DWORD *)(*((_DWORD *)s + 2) + 28) = 256;
  *(_DWORD *)(*((_DWORD *)s + 2) + 24) = 0;
  v6 = *((_DWORD *)s + 3);
  *(_DWORD *)(*((_DWORD *)s + 3) + 16) = 0;
  *(_DWORD *)(v6 + 12) = 0;
  v7 = *((_DWORD *)s + 2);
  v8 = (_DWORD *)*((_DWORD *)s + 2);
  *(_DWORD *)(*((_DWORD *)s + 2) + 4) = 0;
  *v8 = 0;
  *(_DWORD *)(v7 + 8) = 0;
  result = *((_DWORD *)s + 2);
  *((_DWORD *)s + 261) = result;
  return result;
}

//----- (08066C14) --------------------------------------------------------
_DWORD *__cdecl sub_8066C14(_DWORD *a1)
{
  _DWORD *result; // eax

  a1[5] = 0;
  a1[4] = 0;
  *a1 = 1732584193;
  a1[1] = -271733879;
  a1[2] = -1732584194;
  result = a1;
  a1[3] = 271733878;
  return result;
}

//----- (08066C54) --------------------------------------------------------
void *__cdecl sub_8066C54(int a1, void *src, int a3)
{
  int v4; // [esp+10h] [ebp-8h]
  int i; // [esp+14h] [ebp-4h]

  v4 = (*(_DWORD *)(a1 + 16) >> 3) & 0x3F;
  *(_DWORD *)(a1 + 16) += 8 * a3;
  if ( *(_DWORD *)(a1 + 16) < (unsigned int)(8 * a3) )
    ++*(_DWORD *)(a1 + 20);
  *(_DWORD *)(a1 + 20) += (unsigned int)a3 >> 29;
  if ( a3 < (unsigned int)(64 - v4) )
  {
    i = 0;
  }
  else
  {
    Com_Memcpy((void *)(a1 + v4 + 24), src, 64 - v4);
    sub_8066E12((int *)a1, a1 + 24);
    for ( i = 64 - v4; i + 63 < (unsigned int)a3; i += 64 )
      sub_8066E12((int *)a1, (int)src + i);
    v4 = 0;
  }
  return Com_Memcpy((void *)(a1 + v4 + 24), (char *)src + i, a3 - i);
}

//----- (08066D50) --------------------------------------------------------
void *__cdecl sub_8066D50(int a1, void *s)
{
  int v3; // [esp+14h] [ebp-14h]
  unsigned int v4; // [esp+1Ch] [ebp-Ch]
  char src; // [esp+20h] [ebp-8h]

  sub_806751E((int)&src, (int)s + 16, 8u);
  v4 = (*((_DWORD *)s + 4) >> 3) & 0x3F;
  if ( v4 > 0x37 )
    v3 = 120 - v4;
  else
    v3 = 56 - v4;
  sub_8066C54((int)s, &unk_815A4A0, v3);
  sub_8066C54((int)s, &src, 8);
  sub_806751E(a1, (int)s, 0x10u);
  return sub_80AA83E(s, 0, 0x58u);
}

//----- (08066E12) --------------------------------------------------------
void *__cdecl sub_8066E12(int *a1, int a2)
{
  int s; // [esp+10h] [ebp-58h]
  int v4; // [esp+14h] [ebp-54h]
  int v5; // [esp+18h] [ebp-50h]
  int v6; // [esp+1Ch] [ebp-4Ch]
  int v7; // [esp+20h] [ebp-48h]
  int v8; // [esp+24h] [ebp-44h]
  int v9; // [esp+28h] [ebp-40h]
  int v10; // [esp+2Ch] [ebp-3Ch]
  int v11; // [esp+30h] [ebp-38h]
  int v12; // [esp+34h] [ebp-34h]
  int v13; // [esp+38h] [ebp-30h]
  int v14; // [esp+3Ch] [ebp-2Ch]
  int v15; // [esp+40h] [ebp-28h]
  int v16; // [esp+44h] [ebp-24h]
  int v17; // [esp+48h] [ebp-20h]
  int v18; // [esp+4Ch] [ebp-1Ch]
  int v19; // [esp+50h] [ebp-18h]
  int v20; // [esp+54h] [ebp-14h]
  int v21; // [esp+58h] [ebp-10h]
  int v22; // [esp+5Ch] [ebp-Ch]

  v22 = *a1;
  v21 = a1[1];
  v20 = a1[2];
  v19 = a1[3];
  sub_80675C6((int)&s, a2, 0x40u);
  v22 += s + (v20 & v21 | v19 & ~v21);
  v22 = __ROL4__(v22, 3);
  v19 += v4 + (v21 & v22 | v20 & ~v22);
  v19 = __ROL4__(v19, 7);
  v20 += v5 + (v22 & v19 | v21 & ~v19);
  v20 = __ROL4__(v20, 11);
  v21 += v6 + (v19 & v20 | v22 & ~v20);
  v21 = __ROL4__(v21, 19);
  v22 += v7 + (v20 & v21 | v19 & ~v21);
  v22 = __ROL4__(v22, 3);
  v19 += v8 + (v21 & v22 | v20 & ~v22);
  v19 = __ROL4__(v19, 7);
  v20 += v9 + (v22 & v19 | v21 & ~v19);
  v20 = __ROL4__(v20, 11);
  v21 += v10 + (v19 & v20 | v22 & ~v20);
  v21 = __ROL4__(v21, 19);
  v22 += v11 + (v20 & v21 | v19 & ~v21);
  v22 = __ROL4__(v22, 3);
  v19 += v12 + (v21 & v22 | v20 & ~v22);
  v19 = __ROL4__(v19, 7);
  v20 += v13 + (v22 & v19 | v21 & ~v19);
  v20 = __ROL4__(v20, 11);
  v21 += v14 + (v19 & v20 | v22 & ~v20);
  v21 = __ROL4__(v21, 19);
  v22 += v15 + (v20 & v21 | v19 & ~v21);
  v22 = __ROL4__(v22, 3);
  v19 += v16 + (v21 & v22 | v20 & ~v22);
  v19 = __ROL4__(v19, 7);
  v20 += v17 + (v22 & v19 | v21 & ~v19);
  v20 = __ROL4__(v20, 11);
  v21 += v18 + (v19 & v20 | v22 & ~v20);
  v21 = __ROL4__(v21, 19);
  v22 += s + (v21 & (v20 | v19) | v20 & v19) + 1518500249;
  v22 = __ROL4__(v22, 3);
  v19 += v7 + (v22 & (v21 | v20) | v21 & v20) + 1518500249;
  v19 = __ROL4__(v19, 5);
  v20 += v11 + (v19 & (v22 | v21) | v22 & v21) + 1518500249;
  v20 = __ROL4__(v20, 9);
  v21 += v15 + (v20 & (v19 | v22) | v19 & v22) + 1518500249;
  v21 = __ROL4__(v21, 13);
  v22 += v4 + (v21 & (v20 | v19) | v20 & v19) + 1518500249;
  v22 = __ROL4__(v22, 3);
  v19 += v8 + (v22 & (v21 | v20) | v21 & v20) + 1518500249;
  v19 = __ROL4__(v19, 5);
  v20 += v12 + (v19 & (v22 | v21) | v22 & v21) + 1518500249;
  v20 = __ROL4__(v20, 9);
  v21 += v16 + (v20 & (v19 | v22) | v19 & v22) + 1518500249;
  v21 = __ROL4__(v21, 13);
  v22 += v5 + (v21 & (v20 | v19) | v20 & v19) + 1518500249;
  v22 = __ROL4__(v22, 3);
  v19 += v9 + (v22 & (v21 | v20) | v21 & v20) + 1518500249;
  v19 = __ROL4__(v19, 5);
  v20 += v13 + (v19 & (v22 | v21) | v22 & v21) + 1518500249;
  v20 = __ROL4__(v20, 9);
  v21 += v17 + (v20 & (v19 | v22) | v19 & v22) + 1518500249;
  v21 = __ROL4__(v21, 13);
  v22 += v6 + (v21 & (v20 | v19) | v20 & v19) + 1518500249;
  v22 = __ROL4__(v22, 3);
  v19 += v10 + (v22 & (v21 | v20) | v21 & v20) + 1518500249;
  v19 = __ROL4__(v19, 5);
  v20 += v14 + (v19 & (v22 | v21) | v22 & v21) + 1518500249;
  v20 = __ROL4__(v20, 9);
  v21 += v18 + (v20 & (v19 | v22) | v19 & v22) + 1518500249;
  v21 = __ROL4__(v21, 13);
  v22 += s + (v19 ^ v21 ^ v20) + 1859775393;
  v22 = __ROL4__(v22, 3);
  v19 += v11 + (v20 ^ v22 ^ v21) + 1859775393;
  v19 = __ROL4__(v19, 9);
  v20 += v7 + (v21 ^ v19 ^ v22) + 1859775393;
  v20 = __ROL4__(v20, 11);
  v21 += v15 + (v22 ^ v20 ^ v19) + 1859775393;
  v21 = __ROL4__(v21, 15);
  v22 += v5 + (v19 ^ v21 ^ v20) + 1859775393;
  v22 = __ROL4__(v22, 3);
  v19 += v13 + (v20 ^ v22 ^ v21) + 1859775393;
  v19 = __ROL4__(v19, 9);
  v20 += v9 + (v21 ^ v19 ^ v22) + 1859775393;
  v20 = __ROL4__(v20, 11);
  v21 += v17 + (v22 ^ v20 ^ v19) + 1859775393;
  v21 = __ROL4__(v21, 15);
  v22 += v4 + (v19 ^ v21 ^ v20) + 1859775393;
  v22 = __ROL4__(v22, 3);
  v19 += v12 + (v20 ^ v22 ^ v21) + 1859775393;
  v19 = __ROL4__(v19, 9);
  v20 += v8 + (v21 ^ v19 ^ v22) + 1859775393;
  v20 = __ROL4__(v20, 11);
  v21 += v16 + (v22 ^ v20 ^ v19) + 1859775393;
  v21 = __ROL4__(v21, 15);
  v22 += v6 + (v19 ^ v21 ^ v20) + 1859775393;
  v22 = __ROL4__(v22, 3);
  v19 += v14 + (v20 ^ v22 ^ v21) + 1859775393;
  v19 = __ROL4__(v19, 9);
  v20 += v10 + (v21 ^ v19 ^ v22) + 1859775393;
  v20 = __ROL4__(v20, 11);
  v21 += v18 + (v22 ^ v20 ^ v19) + 1859775393;
  v21 = __ROL4__(v21, 15);
  *a1 += v22;
  a1[1] += v21;
  a1[2] += v20;
  a1[3] += v19;
  return sub_80AA83E(&s, 0, 0x40u);
}

//----- (0806751E) --------------------------------------------------------
unsigned int __cdecl sub_806751E(int a1, int a2, unsigned int a3)
{
  unsigned int result; // eax
  unsigned int i; // [esp+0h] [ebp-8h]
  int v5; // [esp+4h] [ebp-4h]

  v5 = 0;
  for ( i = 0; ; i += 4 )
  {
    result = i;
    if ( i >= a3 )
      break;
    *(_BYTE *)(i + a1) = *(_BYTE *)(a2 + 4 * v5);
    *(_BYTE *)(a1 + i + 1) = *(_WORD *)(a2 + 4 * v5) >> 8;
    *(_BYTE *)(a1 + i + 2) = *(_DWORD *)(a2 + 4 * v5) >> 16;
    *(_BYTE *)(a1 + i + 3) = *(_DWORD *)(a2 + 4 * v5++) >> 24;
  }
  return result;
}

//----- (080675C6) --------------------------------------------------------
unsigned int __cdecl sub_80675C6(int a1, int a2, unsigned int a3)
{
  unsigned int result; // eax
  unsigned int i; // [esp+0h] [ebp-Ch]
  int v5; // [esp+4h] [ebp-8h]

  v5 = 0;
  for ( i = 0; ; i += 4 )
  {
    result = i;
    if ( i >= a3 )
      break;
    *(_DWORD *)(a1 + 4 * v5++) = (*(unsigned __int8 *)(a2 + i + 2) << 16) | *(unsigned __int16 *)(a2 + i) | (*(unsigned __int8 *)(a2 + i + 3) << 24);
  }
  return result;
}

//----- (08067642) --------------------------------------------------------
int __cdecl sub_8067642(void *src, int a2)
{
  int s; // [esp+10h] [ebp-88h]
  int v4; // [esp+80h] [ebp-18h]
  int v5; // [esp+84h] [ebp-14h]
  int v6; // [esp+88h] [ebp-10h]
  int v7; // [esp+8Ch] [ebp-Ch]

  sub_8066C14(&s);
  sub_8066C54((int)&s, src, a2);
  sub_8066D50((int)&v4, &s);
  return v7 ^ v6 ^ v4 ^ v5;
}

//----- (0806769E) --------------------------------------------------------
int sub_806769E(void *a1, int a2, ...)
{
  int s; // [esp+10h] [ebp-88h]
  int v4; // [esp+80h] [ebp-18h]
  int v5; // [esp+84h] [ebp-14h]
  int v6; // [esp+88h] [ebp-10h]
  int v7; // [esp+8Ch] [ebp-Ch]
  va_list va; // [esp+A8h] [ebp+10h]

  va_start(va, a2);
  sub_8066C14(&s);
  sub_8066C54((int)&s, va, 4);
  sub_8066C54((int)&s, a1, a2);
  sub_8066D50((int)&v4, &s);
  return v7 ^ v6 ^ v4 ^ v5;
}

//----- (08067718) --------------------------------------------------------
int __cdecl sub_8067718(void *s, int a2, int a3)
{
  int result; // eax

  if ( !dword_81F4898 )
    sub_806ACDE();
  memset(s, 0, 0x18u);
  *((_DWORD *)s + 1) = a2;
  result = a3;
  *((_DWORD *)s + 2) = a3;
  return result;
}
// 81F4898: using guessed type int dword_81F4898;

//----- (0806775C) --------------------------------------------------------
_DWORD *__cdecl sub_806775C(_DWORD *a1)
{
  _DWORD *result; // eax

  *a1 = 0;
  a1[4] = 0;
  result = a1;
  a1[5] = 0;
  return result;
}

//----- (080677A2) --------------------------------------------------------
int *__cdecl sub_80677A2(int *a1, int a2, int a3)
{
  int *result; // eax
  int v4; // [esp+0h] [ebp-10h]

  result = (int *)(a1[2] - a1[3]);
  if ( (signed int)result > 3 )
  {
    while ( a3 )
    {
      --a3;
      v4 = a1[5] & 7;
      if ( !v4 )
      {
        a1[5] = 8 * a1[3];
        *(_BYTE *)(a1[1] + a1[3]++) = 0;
      }
      if ( a2 & 1 )
        *(_BYTE *)((a1[5] >> 3) + a1[1]) |= 1 << v4;
      ++a1[5];
      result = &a2;
      a2 >>= 1;
    }
  }
  else
  {
    result = a1;
    *a1 = 1;
  }
  return result;
}

//----- (08067868) --------------------------------------------------------
_DWORD *__cdecl sub_8067868(_DWORD *a1)
{
  _DWORD *result; // eax

  if ( a1[3] < a1[2] )
  {
    if ( !(a1[5] & 7) )
    {
      a1[5] = 8 * a1[3];
      *(_BYTE *)(a1[1] + a1[3]++) = 0;
    }
    result = a1;
    ++result[5];
  }
  else
  {
    result = a1;
    *a1 = 1;
  }
  return result;
}

//----- (080678C6) --------------------------------------------------------
_DWORD *__cdecl sub_80678C6(_DWORD *a1)
{
  _DWORD *result; // eax
  int v2; // [esp+0h] [ebp-10h]

  if ( a1[3] < a1[2] )
  {
    v2 = a1[5] & 7;
    if ( !v2 )
    {
      a1[5] = 8 * a1[3];
      *(_BYTE *)(a1[1] + a1[3]++) = 0;
    }
    *(_BYTE *)((a1[5] >> 3) + a1[1]) |= 1 << v2;
    result = a1;
    ++result[5];
  }
  else
  {
    result = a1;
    *a1 = 1;
  }
  return result;
}

//----- (08067960) --------------------------------------------------------
signed int __cdecl sub_8067960(_DWORD *a1, int a2)
{
  int i; // [esp+4h] [ebp-Ch]
  int v5; // [esp+8h] [ebp-8h]
  int v6; // [esp+Ch] [ebp-4h]

  v6 = 0;
  for ( i = 0; i < a2; ++i )
  {
    v5 = a1[5] & 7;
    if ( !v5 )
    {
      if ( a1[4] >= a1[3] )
      {
        *a1 = 1;
        return -1;
      }
      a1[5] = 8 * a1[4]++;
    }
    v6 |= (((signed int)*(unsigned __int8 *)((a1[5]++ >> 3) + a1[1]) >> v5) & 1) << i;
  }
  return v6;
}

//----- (08067A0E) --------------------------------------------------------
signed int __cdecl sub_8067A0E(_DWORD *a1)
{
  int v4; // [esp+4h] [ebp-8h]

  v4 = a1[5] & 7;
  if ( v4 )
    return ((signed int)*(unsigned __int8 *)((a1[5]++ >> 3) + a1[1]) >> v4) & 1;
  if ( a1[4] < a1[3] )
  {
    a1[5] = 8 * a1[4]++;
    return ((signed int)*(unsigned __int8 *)((a1[5]++ >> 3) + a1[1]) >> v4) & 1;
  }
  *a1 = 1;
  return -1;
}

//----- (08067A8E) --------------------------------------------------------
int __cdecl sub_8067A8E(unsigned __int8 *a1, int a2, int a3)
{
  int v4; // [esp+10h] [ebp-8h]
  int v5; // [esp+14h] [ebp-4h]

  v4 = 0;
  v5 = a3;
  while ( v5 )
  {
    sub_8066550((int)&unk_81E6860, *a1, a2, &v4);
    --v5;
    ++a1;
  }
  return (v4 + 7) >> 3;
}

//----- (08067AE2) --------------------------------------------------------
int __cdecl sub_8067AE2(int a1, _BYTE *a2, int a3)
{
  _BYTE *v4; // [esp+14h] [ebp-14h]
  int v5; // [esp+1Ch] [ebp-Ch]
  int v6; // [esp+20h] [ebp-8h]
  char v7; // [esp+24h] [ebp-4h]

  v6 = 8 * a3;
  v4 = a2;
  v5 = 0;
  while ( v5 < v6 )
  {
    sub_80663F6((_DWORD *)dword_81ED884, &v7, a1, &v5);
    *v4++ = v7;
  }
  return v4 - a2;
}
// 81ED884: using guessed type int dword_81ED884;

//----- (08067B4C) --------------------------------------------------------
_DWORD *__cdecl sub_8067B4C(_DWORD *a1, char a2)
{
  _DWORD *result; // eax

  if ( a1[3] >= a1[2] )
  {
    result = a1;
    *a1 = 1;
  }
  else
  {
    *(_BYTE *)(a1[3] + a1[1]) = a2;
    result = a1;
    ++result[3];
  }
  return result;
}

//----- (08067B84) --------------------------------------------------------
int __cdecl sub_8067B84(int a1, void *src, size_t n)
{
  int result; // eax
  signed int v4; // [esp+14h] [ebp-4h]

  v4 = *(_DWORD *)(a1 + 12) + n;
  if ( v4 > *(_DWORD *)(a1 + 8) )
  {
    result = a1;
    *(_DWORD *)a1 = 1;
  }
  else
  {
    memcpy((void *)(*(_DWORD *)(a1 + 4) + *(_DWORD *)(a1 + 12)), src, n);
    result = v4;
    *(_DWORD *)(a1 + 12) = v4;
  }
  return result;
}

//----- (08067BDA) --------------------------------------------------------
_DWORD *__cdecl sub_8067BDA(_DWORD *a1, __int16 a2)
{
  _DWORD *result; // eax
  int v3; // [esp+4h] [ebp-4h]

  v3 = a1[3] + 2;
  if ( v3 > a1[2] )
  {
    result = a1;
    *a1 = 1;
  }
  else
  {
    *(_WORD *)(a1[1] + a1[3]) = sub_806ACF6(a2);
    result = (_DWORD *)v3;
    a1[3] = v3;
  }
  return result;
}

//----- (08067C2A) --------------------------------------------------------
_DWORD *__cdecl sub_8067C2A(_DWORD *a1, int a2)
{
  _DWORD *result; // eax
  int v3; // [esp+4h] [ebp-4h]

  v3 = a1[3] + 4;
  if ( v3 > a1[2] )
  {
    result = a1;
    *a1 = 1;
  }
  else
  {
    *(_DWORD *)(a1[1] + a1[3]) = sub_806AD0A(a2);
    result = (_DWORD *)v3;
    a1[3] = v3;
  }
  return result;
}

//----- (08067C78) --------------------------------------------------------
_DWORD *__cdecl sub_8067C78(_DWORD *a1, int a2, int a3)
{
  int v3; // eax
  int v4; // edx
  int v5; // ecx
  int v6; // edx
  int *v7; // eax
  _DWORD *result; // eax
  int v9; // [esp+14h] [ebp-14h]

  v9 = a1[3] + 8;
  if ( v9 > a1[2] )
  {
    result = a1;
    *a1 = 1;
  }
  else
  {
    v3 = sub_80B4FCE(a2, a3);
    v5 = v4;
    v6 = v3;
    v7 = (int *)(a1[1] + a1[3]);
    *v7 = v6;
    v7[1] = v5;
    result = (_DWORD *)v9;
    a1[3] = v9;
  }
  return result;
}

//----- (08067CE4) --------------------------------------------------------
int __cdecl sub_8067CE4(int a1, char *s)
{
  int result; // eax
  char *v3; // ebx
  char src[1032]; // [esp+10h] [ebp-418h]
  int i; // [esp+418h] [ebp-10h]
  int v6; // [esp+41Ch] [ebp-Ch]

  v6 = strlen(s);
  if ( v6 <= 1023 )
  {
    for ( i = 0; i < v6; ++i )
    {
      v3 = &src[i];
      *v3 = sub_80B5904(s[i]);
    }
    src[i] = 0;
    result = sub_8067B84(a1, src, v6 + 1);
  }
  else
  {
    Com_Printf("MSG_WriteString: MAX_STRING_CHARS");
    result = sub_8067B84(a1, &unk_813CD62, 1u);
  }
  return result;
}
// 8067CE4: using guessed type char src[1032];

//----- (08067D96) --------------------------------------------------------
int __cdecl sub_8067D96(int a1, char *s)
{
  int result; // eax
  char *v3; // ebx
  char src[8200]; // [esp+10h] [ebp-2018h]
  int i; // [esp+2018h] [ebp-10h]
  int v6; // [esp+201Ch] [ebp-Ch]

  v6 = strlen(s);
  if ( v6 <= 0x1FFF )
  {
    I_strncpyz(src, s, 0x2000);
    for ( i = 0; i < v6; ++i )
    {
      v3 = &src[i];
      *v3 = sub_80B5904(src[i]);
    }
    result = sub_8067B84(a1, src, v6 + 1);
  }
  else
  {
    Com_Printf("MSG_WriteString: BIG_INFO_STRING");
    result = sub_8067B84(a1, &unk_813CD62, 1u);
  }
  return result;
}
// 8067D96: using guessed type char src[8200];

//----- (08067EA6) --------------------------------------------------------
_DWORD *__cdecl sub_8067EA6(int a1, float a2)
{
  return sub_8067BDA((_DWORD *)a1, (signed int)(a2 * 182.04445));
}

//----- (08067EE8) --------------------------------------------------------
signed int __cdecl sub_8067EE8(_DWORD *a1)
{
  signed int v1; // ST04_4
  signed int v3; // [esp+0h] [ebp-8h]

  if ( a1[4] >= a1[3] )
  {
    *a1 = 1;
    v3 = -1;
  }
  else
  {
    v1 = *(unsigned __int8 *)(a1[1] + a1[4]++);
    v3 = v1;
  }
  return v3;
}

//----- (08067F32) --------------------------------------------------------
signed int __cdecl sub_8067F32(_DWORD *a1)
{
  __int16 v1; // ax
  signed int v3; // [esp+Ch] [ebp-Ch]
  int v4; // [esp+10h] [ebp-8h]

  v4 = a1[4] + 2;
  if ( v4 > a1[3] )
  {
    *a1 = 1;
    v3 = -1;
  }
  else
  {
    v1 = sub_806ACF6(*(_WORD *)(a1[1] + a1[4]));
    a1[4] = v4;
    v3 = v1;
  }
  return v3;
}

//----- (08067F90) --------------------------------------------------------
signed int __cdecl sub_8067F90(_DWORD *a1)
{
  int v1; // ST14_4
  signed int v3; // [esp+Ch] [ebp-Ch]
  int v4; // [esp+10h] [ebp-8h]

  v4 = a1[4] + 4;
  if ( v4 > a1[3] )
  {
    *a1 = 1;
    v3 = -1;
  }
  else
  {
    v1 = sub_806AD0A(*(_DWORD *)(a1[1] + a1[4]));
    a1[4] = v4;
    v3 = v1;
  }
  return v3;
}

//----- (08067FEC) --------------------------------------------------------
unsigned __int64 __cdecl sub_8067FEC(_DWORD *a1)
{
  int *v1; // eax
  int v2; // ST20_4
  unsigned int v3; // edx
  unsigned __int64 v5; // [esp+10h] [ebp-18h]
  int v6; // [esp+1Ch] [ebp-Ch]

  v6 = a1[4] + 8;
  if ( v6 > a1[3] )
  {
    *a1 = 1;
    v5 = 0LL;
  }
  else
  {
    v1 = (int *)(a1[1] + a1[4]);
    v2 = sub_80B4FCE(*v1, v1[1]);
    a1[4] = v6;
    v5 = __PAIR__(v3, v2);
  }
  return v5;
}

//----- (08068062) --------------------------------------------------------
void *__cdecl sub_8068062(_DWORD *a1)
{
  signed int v2; // [esp+Ch] [ebp-Ch]
  unsigned int i; // [esp+10h] [ebp-8h]

  for ( i = 0; ; ++i )
  {
    v2 = sub_8067EE8(a1);
    if ( v2 == -1 )
      v2 = 0;
    if ( i <= 0x3FF )
      *(_BYTE *)(i + 136267936) = sub_80B5904(v2);
    if ( !v2 )
      break;
  }
  byte_81F4C9F = 0;
  return &unk_81F48A0;
}
// 81F4C9F: using guessed type char byte_81F4C9F;

//----- (080680CC) --------------------------------------------------------
void *__cdecl sub_80680CC(_DWORD *a1)
{
  signed int v2; // [esp+Ch] [ebp-Ch]
  unsigned int i; // [esp+10h] [ebp-8h]

  for ( i = 0; ; ++i )
  {
    v2 = sub_8067EE8(a1);
    if ( v2 == 37 )
    {
      v2 = 46;
    }
    else if ( v2 == -1 )
    {
      v2 = 0;
    }
    if ( i <= 0x1FFF )
      *(_BYTE *)(i + 136268960) = sub_80B5904(v2);
    if ( !v2 )
      break;
  }
  byte_81F6C9F = 0;
  return &unk_81F4CA0;
}
// 81F6C9F: using guessed type char byte_81F6C9F;

//----- (08068146) --------------------------------------------------------
void *__cdecl sub_8068146(_DWORD *a1)
{
  signed int v2; // [esp+Ch] [ebp-Ch]
  unsigned int i; // [esp+10h] [ebp-8h]

  for ( i = 0; ; ++i )
  {
    v2 = sub_8067EE8(a1);
    if ( v2 == 37 )
    {
      v2 = 46;
    }
    else if ( v2 == 10 || v2 == -1 )
    {
      v2 = 0;
    }
    if ( i <= 0x3FF )
      *(_BYTE *)(i + 136277152) = sub_80B5904(v2);
    if ( !v2 )
      break;
  }
  byte_81F709F = 0;
  return &unk_81F6CA0;
}
// 81F709F: using guessed type char byte_81F709F;

//----- (080681C8) --------------------------------------------------------
long double __cdecl sub_80681C8(_DWORD *a1)
{
  return (long double)sub_8067F32(a1) * 0.0054931641;
}

//----- (080681EC) --------------------------------------------------------
void *__cdecl sub_80681EC(int a1, void *dest, size_t n)
{
  void *result; // eax
  void *v4; // [esp+14h] [ebp-4h]

  v4 = (void *)(*(_DWORD *)(a1 + 16) + n);
  if ( (signed int)v4 > *(_DWORD *)(a1 + 12) )
  {
    *(_DWORD *)a1 = 1;
    result = memset(dest, -1, n);
  }
  else
  {
    memcpy(dest, (const void *)(*(_DWORD *)(a1 + 4) + *(_DWORD *)(a1 + 16)), n);
    result = v4;
    *(_DWORD *)(a1 + 16) = v4;
  }
  return result;
}

//----- (0806825C) --------------------------------------------------------
int *__cdecl sub_806825C(int *a1, int a2, int a3, int a4, int a5)
{
  if ( a3 == a4 )
    return sub_8067868(a1);
  sub_80678C6(a1);
  return sub_80677A2(a1, a4 ^ a2, a5);
}

//----- (080682A0) --------------------------------------------------------
int __cdecl sub_80682A0(_DWORD *a1, int a2, int a3, int a4)
{
  int v5; // [esp+14h] [ebp-4h]

  if ( sub_8067A0E(a1) )
    v5 = a2 & dword_815A4E0[a4] ^ sub_8067960(a1, a4);
  else
    v5 = a3;
  return v5;
}

//----- (080682E8) --------------------------------------------------------
int *__cdecl sub_80682E8(int *a1, int a2, int a3, int a4)
{
  return sub_80677A2(a1, a3 ^ a2, a4);
}

//----- (0806830C) --------------------------------------------------------
int __cdecl sub_806830C(_DWORD *a1, int a2, int a3)
{
  return a2 & dword_815A4E0[a3] ^ sub_8067960(a1, a3);
}

//----- (080683AE) --------------------------------------------------------
_DWORD *__cdecl sub_80683AE(_DWORD *a1, __int16 a2, __int16 a3, __int16 a4)
{
  if ( a3 == a4 )
    return sub_8067868(a1);
  sub_80678C6(a1);
  return sub_8067BDA(a1, a4 ^ a2);
}

//----- (080683EC) --------------------------------------------------------
int __cdecl sub_80683EC(_DWORD *a1, __int16 a2, int a3)
{
  int v4; // [esp+4h] [ebp-4h]

  if ( sub_8067A0E(a1) )
    v4 = (signed __int16)(sub_8067F32(a1) ^ a2);
  else
    v4 = a3;
  return v4;
}

//----- (08068424) --------------------------------------------------------
_BYTE *__cdecl sub_8068424(char *s, int a2, int a3)
{
  _BYTE *result; // eax
  _BYTE *v4; // [esp+1Ch] [ebp-Ch]
  int v5; // [esp+20h] [ebp-8h]
  int v6; // [esp+24h] [ebp-4h]

  v5 = strlen(s);
  if ( v5 >= a3 )
    Com_Printf("WARNING: Reliable command is too long (%i/%i) and will be truncated: '%s'\n", v5, a3, s);
  if ( !v5 )
    Com_Printf("WARNING: Empty reliable command\n");
  v4 = (_BYTE *)a2;
  v6 = 0;
  while ( v6 < a3 && s[v6] )
  {
    *v4 = sub_80B5904(s[v6]);
    if ( *v4 == 37 )
      *v4 = 46;
    ++v6;
    ++v4;
  }
  if ( v6 >= a3 )
  {
    result = (_BYTE *)(a2 + a3 - 1);
    *result = 0;
  }
  else
  {
    result = (_BYTE *)(a2 + v6);
    *(_BYTE *)(a2 + v6) = 0;
  }
  return result;
}

//----- (080684E6) --------------------------------------------------------
void __cdecl sub_80684E6(int a1, void *s)
{
  signed int i; // [esp+1Ch] [ebp-Ch]

  memset(s, 0, 0x1Cu);
  *((_BYTE *)s + 8) = *(_BYTE *)(a1 + 212);
  *((_BYTE *)s + 9) = *(_BYTE *)(a1 + 208);
  for ( i = 0; i <= 1; ++i )
    *((_DWORD *)s + i + 3) = (unsigned __int16)((signed int)(*(float *)(a1 + 4 * i + 232) * 182.04445)
                                              - *(_WORD *)(a1 + 4 * i + 84));
  if ( *(_DWORD *)(a1 + 12) & 0x800000 )
  {
    if ( *(_DWORD *)(a1 + 160) & 8 )
    {
      *((_DWORD *)s + 1) |= 0x100u;
    }
    else if ( *(_DWORD *)(a1 + 160) & 4 )
    {
      *((_DWORD *)s + 1) |= 0x200u;
    }
    if ( *(float *)(a1 + 76) <= 0.0 )
    {
      if ( *(float *)(a1 + 76) < 0.0 )
        *((_DWORD *)s + 1) |= 0x40u;
    }
    else
    {
      *((_DWORD *)s + 1) |= 0x80u;
    }
    if ( *(float *)(a1 + 220) != 0.0 )
      *((_DWORD *)s + 1) |= 0x1000u;
  }
}

//----- (08068660) --------------------------------------------------------
int __cdecl sub_8068660(signed int a1, signed int a2)
{
  signed int v3; // [esp+0h] [ebp-4h]

  v3 = 0;
  if ( a1 <= 10 )
  {
    if ( a1 < -10 )
      v3 = 2;
  }
  else
  {
    v3 = 1;
  }
  if ( a2 > 10 )
    return v3 | 4;
  if ( a2 < -10 )
    v3 |= 8u;
  return v3;
}

//----- (080686A6) --------------------------------------------------------
_BYTE *__cdecl sub_80686A6(char a1, _BYTE *a2, _BYTE *a3)
{
  _BYTE *result; // eax

  if ( a1 & 1 )
  {
    *a2 = 127;
  }
  else if ( a1 & 2 )
  {
    *a2 = -127;
  }
  else
  {
    *a2 = 0;
  }
  if ( a1 & 4 )
  {
    result = a3;
    *a3 = 127;
  }
  else if ( a1 & 8 )
  {
    result = a3;
    *a3 = -127;
  }
  else
  {
    result = a3;
    *a3 = 0;
  }
  return result;
}

//----- (08068ADE) --------------------------------------------------------
_BYTE *__cdecl sub_8068ADE(_DWORD *a1, int a2, int a3, int a4)
{
  _BYTE *result; // eax
  int v5; // ST18_4
  char v6; // ST1C_1
  int v7; // ST18_4
  char v8; // ST1C_1
  int v9; // [esp+34h] [ebp+Ch]
  int v10; // [esp+34h] [ebp+Ch]

  *(_DWORD *)a4 = *(_DWORD *)a3;
  *(_DWORD *)(a4 + 4) = *(_DWORD *)(a3 + 4);
  *(_DWORD *)(a4 + 8) = *(_DWORD *)(a3 + 8);
  *(_DWORD *)(a4 + 12) = *(_DWORD *)(a3 + 12);
  *(_DWORD *)(a4 + 16) = *(_DWORD *)(a3 + 16);
  *(_DWORD *)(a4 + 20) = *(_DWORD *)(a3 + 20);
  *(_DWORD *)(a4 + 24) = *(_DWORD *)(a3 + 24);
  if ( sub_8067A0E(a1) )
    *(_DWORD *)a4 = *(_DWORD *)a3 + sub_8067EE8(a1);
  else
    *(_DWORD *)a4 = sub_8067F90(a1);
  result = (_BYTE *)sub_806830C(a1, a2, 1);
  if ( result )
  {
    *(_DWORD *)(a4 + 4) &= 0xFFFFFFFE;
    if ( sub_806830C(a1, a2, 1) )
    {
      *(_DWORD *)(a4 + 4) |= sub_806830C(a1, a2, 1);
      *(_DWORD *)(a4 + 12) = (unsigned __int16)sub_80683EC(a1, a2, *(_DWORD *)(a3 + 12));
      *(_DWORD *)(a4 + 16) = (unsigned __int16)sub_80683EC(a1, a2, *(_DWORD *)(a3 + 16));
      v7 = sub_8068660(*(char *)(a3 + 24), *(char *)(a3 + 25));
      v8 = sub_80682A0(a1, a2, v7, 4);
      sub_80686A6(v8, (_BYTE *)(a4 + 24), (_BYTE *)(a4 + 25));
      v10 = *(_DWORD *)a4 ^ a2;
      *(_DWORD *)(a4 + 20) = (unsigned __int16)sub_80683EC(a1, v10, *(_DWORD *)(a3 + 20));
      *(_DWORD *)(a4 + 4) &= 1u;
      *(_DWORD *)(a4 + 4) |= 2 * sub_80682A0(a1, v10, *(_DWORD *)(a3 + 4) >> 1, 18);
      *(_BYTE *)(a4 + 8) = sub_80682A0(a1, v10, *(unsigned __int8 *)(a3 + 8), 7);
      result = (_BYTE *)sub_80682A0(a1, v10, *(unsigned __int8 *)(a3 + 9), 7);
      *(_BYTE *)(a4 + 9) = (_BYTE)result;
    }
    else
    {
      v9 = *(_DWORD *)a4 ^ a2;
      *(_DWORD *)(a4 + 4) |= sub_806830C(a1, v9, 1);
      *(_DWORD *)(a4 + 12) = (unsigned __int16)sub_80683EC(a1, v9, *(_DWORD *)(a3 + 12));
      *(_DWORD *)(a4 + 16) = (unsigned __int16)sub_80683EC(a1, v9, *(_DWORD *)(a3 + 16));
      v5 = sub_8068660(*(char *)(a3 + 24), *(char *)(a3 + 25));
      v6 = sub_80682A0(a1, v9, v5, 4);
      result = sub_80686A6(v6, (_BYTE *)(a4 + 24), (_BYTE *)(a4 + 25));
    }
  }
  return result;
}

//----- (08068E1C) --------------------------------------------------------
int *__cdecl sub_8068E1C(int *a1, int a2, int a3, int a4)
{
  int *result; // eax
  int v5; // [esp+14h] [ebp-24h]
  int v6; // [esp+1Ch] [ebp-1Ch]
  int v7; // [esp+20h] [ebp-18h]
  int v8; // [esp+24h] [ebp-14h]
  float v9; // [esp+28h] [ebp-10h]
  int v10; // [esp+2Ch] [ebp-Ch]
  float *v11; // [esp+30h] [ebp-8h]
  _DWORD *v12; // [esp+34h] [ebp-4h]

  v12 = (_DWORD *)(a2 + *(_DWORD *)(a4 + 4));
  v11 = (float *)(a3 + *(_DWORD *)(a4 + 4));
  if ( *v12 == *(_DWORD *)v11 )
    return sub_8067868(a1);
  sub_80678C6(a1);
  if ( *(_DWORD *)(a4 + 8) )
  {
    if ( *(_DWORD *)(a4 + 8) == -99 )
    {
      v9 = *v11;
      v10 = (signed int)v9;
      if ( v9 == 0.0 )
      {
        result = sub_8067868(a1);
      }
      else
      {
        sub_80678C6(a1);
        if ( (long double)v10 != v9 || v10 + 512 < 0 || v10 + 512 > 1023 )
        {
          sub_80678C6(a1);
          result = sub_8067C2A(a1, *(_DWORD *)v11);
        }
        else
        {
          sub_8067868(a1);
          v10 += 512;
          sub_80677A2(a1, v10, 2);
          result = sub_8067B4C(a1, v10 >> 2);
        }
      }
    }
    else if ( *(_DWORD *)(a4 + 8) == -100 )
    {
      if ( *(_DWORD *)v11 )
      {
        sub_80678C6(a1);
        result = sub_8067EA6((int)a1, *v11);
      }
      else
      {
        result = sub_8067868(a1);
      }
    }
    else if ( *(_DWORD *)v11 )
    {
      sub_80678C6(a1);
      v8 = *(_DWORD *)v11;
      v5 = *(_DWORD *)(a4 + 8);
      if ( v5 < 0 )
        v5 = -v5;
      v7 = v5;
      result = (int *)(v5 & 7);
      v6 = v5 & 7;
      if ( v5 & 7 )
      {
        sub_80677A2(a1, v8, v6);
        v7 -= v6;
        result = &v8;
        v8 >>= v6;
      }
      while ( v7 )
      {
        sub_8067B4C(a1, v8);
        v8 >>= 8;
        result = &v7;
        v7 -= 8;
      }
    }
    else
    {
      result = sub_8067868(a1);
    }
  }
  else
  {
    v9 = *v11;
    v10 = (signed int)v9;
    if ( v9 == 0.0 )
    {
      result = sub_8067868(a1);
    }
    else
    {
      sub_80678C6(a1);
      if ( (long double)v10 != v9 || v10 + 4096 < 0 || v10 + 4096 > 0x1FFF )
      {
        sub_80678C6(a1);
        result = sub_8067C2A(a1, *(_DWORD *)v11);
      }
      else
      {
        sub_8067868(a1);
        v10 += 4096;
        sub_80677A2(a1, v10, 5);
        result = sub_8067B4C(a1, v10 >> 5);
      }
    }
  }
  return result;
}

//----- (08069142) --------------------------------------------------------
_DWORD *__cdecl sub_8069142(int *a1, int a2, int a3, int a4, signed int a5, int a6)
{
  _DWORD *result; // eax
  signed int j; // [esp+24h] [ebp-4h]
  signed int i; // [esp+24h] [ebp-4h]

  if ( a4 )
  {
LABEL_7:
    sub_80678C6(a1);
    for ( i = 0; ; ++i )
    {
      result = (_DWORD *)i;
      if ( i >= a5 )
        break;
      sub_8068E1C(a1, a2, a3, a6 + 12 * i);
    }
  }
  else
  {
    for ( j = 0; j < a5; ++j )
    {
      if ( *(_DWORD *)(a2 + *(_DWORD *)(a6 + 12 * j + 4)) != *(_DWORD *)(a3 + *(_DWORD *)(a6 + 12 * j + 4)) )
        goto LABEL_7;
    }
    result = sub_8067868(a1);
  }
  return result;
}

//----- (080691FC) --------------------------------------------------------
_DWORD *__cdecl sub_80691FC(int *a1, int *a2, int *a3, int a4, signed int a5, int a6, int a7, int a8)
{
  _DWORD *result; // eax
  int i; // [esp+1Ch] [ebp-Ch]
  int j; // [esp+1Ch] [ebp-Ch]
  int v11; // [esp+20h] [ebp-8h]
  _DWORD *v12; // [esp+24h] [ebp-4h]
  _DWORD *v13; // [esp+24h] [ebp-4h]

  if ( a3 )
  {
    v11 = 0;
    v12 = 0;
    for ( i = a7; ; i += 12 )
    {
      result = v12;
      if ( (signed int)v12 >= a5 )
        break;
      if ( *(int *)((char *)a2 + *(_DWORD *)(i + 4)) != *(int *)((char *)a3 + *(_DWORD *)(i + 4)) )
        v11 = (int)v12 + 1;
      v12 = (_DWORD *)((char *)v12 + 1);
    }
    if ( v11 )
    {
      if ( a8 )
        sub_80678C6(a1);
      sub_80677A2(a1, *a3, a6);
      sub_8067868(a1);
      sub_80678C6(a1);
      sub_8067B4C(a1, v11);
      v13 = 0;
      for ( j = a7; ; j += 12 )
      {
        result = v13;
        if ( (signed int)v13 >= v11 )
          break;
        sub_8068E1C(a1, (int)a2, (int)a3, j);
        v13 = (_DWORD *)((char *)v13 + 1);
      }
    }
    else if ( a4 )
    {
      if ( a8 )
        sub_80678C6(a1);
      sub_80677A2(a1, *a3, a6);
      sub_8067868(a1);
      result = sub_8067868(a1);
    }
  }
  else
  {
    if ( a8 )
      sub_80678C6(a1);
    sub_80677A2(a1, *a2, a6);
    result = sub_80678C6(a1);
  }
  return result;
}

//----- (0806938C) --------------------------------------------------------
_DWORD *__cdecl sub_806938C(int *a1, int *a2, int *a3, int a4)
{
  return sub_80691FC(a1, a2, a3, a4, 59, 10, (int)&off_813D120, 0);
}
// 813D120: using guessed type char *off_813D120;

//----- (080693DA) --------------------------------------------------------
_DWORD *__cdecl sub_80693DA(int *a1, int *a2, int *a3, int a4)
{
  return sub_80691FC(a1, a2, a3, a4, 68, 10, (int)&off_813D460, 0);
}
// 813D460: using guessed type char *off_813D460;

//----- (08069428) --------------------------------------------------------
_DWORD *__cdecl sub_8069428(int *a1, int *a2, int *a3, int a4)
{
  char s; // [esp+20h] [ebp-78h]
  int v6; // [esp+8Ch] [ebp-Ch]

  v6 = 22;
  if ( !a2 )
  {
    a2 = (int *)&s;
    memset(&s, 0, 0x5Cu);
  }
  return sub_80691FC(a1, a2, a3, a4, v6, 6, (int)&off_813D8E0, 1);
}
// 813D8E0: using guessed type char *off_813D8E0;

//----- (080694A0) --------------------------------------------------------
void __cdecl sub_80694A0(_DWORD *a1, int a2, int a3, _DWORD *a4, int a5)
{
  signed int v5; // ST2C_4
  signed int v6; // ST2C_4
  signed int v7; // [esp+10h] [ebp-28h]
  int v8; // [esp+14h] [ebp-24h]
  int i; // [esp+18h] [ebp-20h]
  signed int v10; // [esp+1Ch] [ebp-1Ch]
  int v11; // [esp+28h] [ebp-10h]
  int v12; // [esp+2Ch] [ebp-Ch]
  int v13; // [esp+2Ch] [ebp-Ch]
  float *v14; // [esp+30h] [ebp-8h]
  float *v15; // [esp+34h] [ebp-4h]

  v15 = (float *)(a2 + a4[1]);
  v14 = (float *)(a3 + a4[1]);
  if ( sub_8067A0E(a1) )
  {
    if ( a4[2] )
    {
      if ( a4[2] == -99 )
      {
        if ( sub_8067A0E(a1) )
        {
          if ( sub_8067A0E(a1) )
          {
            *(_DWORD *)v14 = sub_8067F90(a1);
            if ( a5 )
              Com_Printf("%s:%f ", *a4, *v14);
          }
          else
          {
            v6 = sub_8067960(a1, 2);
            v13 = 4 * sub_8067EE8(a1) + v6 - 512;
            *v14 = (long double)v13;
            if ( a5 )
              Com_Printf("%s:%i ", *a4, v13);
          }
        }
        else
        {
          *v14 = 0.0;
        }
      }
      else if ( a4[2] == -100 )
      {
        if ( sub_8067A0E(a1) )
          *v14 = sub_80681C8(a1);
        else
          *v14 = 0.0;
      }
      else if ( sub_8067A0E(a1) )
      {
        v11 = a4[2] >> 31;
        v8 = a4[2];
        if ( a4[2] < 0 )
          v8 = -v8;
        if ( v8 & 7 )
          v7 = sub_8067960(a1, v8 & 7);
        else
          v7 = 0;
        v10 = v7;
        for ( i = v8 & 7; i < v8; i += 8 )
          v10 |= sub_8067EE8(a1) << i;
        if ( v11 && (v10 >> (v8 - 1)) & 1 )
          v10 |= ~((1 << v8) - 1);
        *(_DWORD *)v14 = v10;
        if ( a5 )
          Com_Printf("%s:%i ", *a4, *(_DWORD *)v14);
      }
      else
      {
        *v14 = 0.0;
      }
    }
    else if ( sub_8067A0E(a1) )
    {
      if ( sub_8067A0E(a1) )
      {
        *(_DWORD *)v14 = sub_8067F90(a1);
        if ( a5 )
          Com_Printf("%s:%f ", *a4, *v14);
      }
      else
      {
        v5 = sub_8067960(a1, 5);
        v12 = 32 * sub_8067EE8(a1) + v5 - 4096;
        *v14 = (long double)v12;
        if ( a5 )
          Com_Printf("%s:%i ", *a4, v12);
      }
    }
    else
    {
      *v14 = 0.0;
    }
  }
  else
  {
    *v14 = *v15;
  }
}

//----- (080697D8) --------------------------------------------------------
int __cdecl sub_80697D8(_DWORD *a1, int a2, int a3, int a4, int a5)
{
  int result; // eax
  int i; // [esp+24h] [ebp-4h]
  int j; // [esp+24h] [ebp-4h]

  if ( sub_8067A0E(a1) )
  {
    for ( i = 0; ; ++i )
    {
      result = i;
      if ( i >= a4 )
        break;
      sub_80694A0(a1, a2, a3, (_DWORD *)(a5 + 12 * i), 0);
    }
  }
  else
  {
    for ( j = 0; ; ++j )
    {
      result = j;
      if ( j >= a4 )
        break;
      *(_DWORD *)(a3 + *(_DWORD *)(a5 + 12 * j + 4)) = *(_DWORD *)(a2 + *(_DWORD *)(a5 + 12 * j + 4));
    }
  }
  return result;
}

//----- (0806988A) --------------------------------------------------------
int __cdecl sub_806988A(int a1, void *src, void *dest, int a4, int a5, int a6, int a7)
{
  int v8; // [esp+1Ch] [ebp-1Ch]
  _DWORD *v9; // [esp+2Ch] [ebp-Ch]
  int v10; // [esp+2Ch] [ebp-Ch]
  int v11; // [esp+30h] [ebp-8h]
  int v12; // [esp+34h] [ebp-4h]
  int v13; // [esp+34h] [ebp-4h]

  if ( sub_8067A0E((_DWORD *)a1) == 1 )
    return 1;
  if ( sub_8067A0E((_DWORD *)a1) )
  {
    v11 = sub_8067EE8((_DWORD *)a1);
    if ( v11 <= a5 )
    {
      *(_DWORD *)dest = a4;
      v12 = 0;
      v9 = (_DWORD *)a7;
      while ( v12 < v11 )
      {
        sub_80694A0((_DWORD *)a1, (int)src, (int)dest, v9, 0);
        ++v12;
        v9 += 3;
      }
      v13 = v11;
      v10 = a7 + 12 * v11;
      while ( v13 < a5 )
      {
        *(_DWORD *)((char *)dest + *(_DWORD *)(v10 + 4)) = *(_DWORD *)((char *)src + *(_DWORD *)(v10 + 4));
        ++v13;
        v10 += 12;
      }
      v8 = 0;
    }
    else
    {
      *(_DWORD *)a1 = 1;
      v8 = 0;
    }
  }
  else
  {
    memcpy(dest, src, 4 * a5 + 4);
    v8 = 0;
  }
  return v8;
}

//----- (080699C8) --------------------------------------------------------
int __cdecl sub_80699C8(int a1, void *src, void *dest, int a4)
{
  return sub_806988A(a1, src, dest, a4, 59, 10, (int)&off_813D120);
}
// 813D120: using guessed type char *off_813D120;

//----- (08069A0E) --------------------------------------------------------
int __cdecl sub_8069A0E(int a1, void *src, void *dest, int a4)
{
  return sub_806988A(a1, src, dest, a4, 68, 10, (int)&off_813D460);
}
// 813D460: using guessed type char *off_813D460;

//----- (08069A54) --------------------------------------------------------
int __cdecl sub_8069A54(int a1, void *src, void *dest, int a4)
{
  char s; // [esp+20h] [ebp-78h]
  int v6; // [esp+8Ch] [ebp-Ch]

  v6 = 22;
  if ( !src )
  {
    src = &s;
    memset(&s, 0, 0x5Cu);
  }
  return sub_806988A(a1, src, dest, a4, v6, 6, (int)&off_813D8E0);
}
// 813D8E0: using guessed type char *off_813D8E0;

//----- (08069AC4) --------------------------------------------------------
int __cdecl sub_8069AC4(int *a1, int a2, int a3, int a4)
{
  int result; // eax
  int v5; // [esp+18h] [ebp-10h]
  int i; // [esp+1Ch] [ebp-Ch]
  unsigned int k; // [esp+20h] [ebp-8h]
  int l; // [esp+20h] [ebp-8h]
  int j; // [esp+24h] [ebp-4h]

  for ( i = 0; i < a4 && *(_DWORD *)(a3 + (i << 7)); ++i )
    ;
  sub_80677A2(a1, i, 5);
  for ( j = 0; ; ++j )
  {
    result = j;
    if ( j >= i )
      break;
    v5 = 0;
    for ( k = 0; k <= 0x1F; ++k )
    {
      if ( *(_DWORD *)(dword_815A5E4[3 * k] + a2 + (j << 7)) != *(_DWORD *)(dword_815A5E4[3 * k] + a3 + (j << 7)) )
        v5 = k;
    }
    sub_80677A2(a1, v5, 5);
    for ( l = 0; l <= v5; ++l )
      sub_8068E1C(a1, a2 + (j << 7), a3 + (j << 7), 12 * l + 135636448);
  }
  return result;
}

//----- (08069C10) --------------------------------------------------------
void *__cdecl sub_8069C10(_DWORD *a1, int a2, int a3, int a4)
{
  signed int v5; // [esp+14h] [ebp-14h]
  signed int v6; // [esp+18h] [ebp-10h]
  unsigned int j; // [esp+1Ch] [ebp-Ch]
  signed int i; // [esp+20h] [ebp-8h]

  v6 = sub_8067960(a1, 5);
  for ( i = 0; i < v6; ++i )
  {
    v5 = sub_8067960(a1, 5);
    for ( j = 0; (signed int)j <= v5; ++j )
      sub_80694A0(a1, a2 + (i << 7), a3 + (i << 7), (_DWORD *)(12 * j + 135636448), 0);
    while ( j <= 0x1F )
    {
      *(_DWORD *)(dword_815A5E4[3 * j] + a3 + (i << 7)) = *(_DWORD *)(dword_815A5E4[3 * j] + a2 + (i << 7));
      ++j;
    }
  }
  return memset((void *)(a3 + (v6 << 7)), 0, (a4 - v6) << 7);
}

//----- (08069D40) --------------------------------------------------------
_DWORD *__cdecl sub_8069D40(int *a1, char *a2, _DWORD *a3)
{
  int v3; // ST34_4
  int v5; // [esp+20h] [ebp-2718h]
  int v6; // [esp+28h] [ebp-2710h]
  int v7; // [esp+2Ch] [ebp-270Ch]
  int v8; // [esp+30h] [ebp-2708h]
  signed int v9; // [esp+34h] [ebp-2704h]
  float *v10; // [esp+3Ch] [ebp-26FCh]
  char **v11; // [esp+44h] [ebp-26F4h]
  char **v12; // [esp+44h] [ebp-26F4h]
  int v13; // [esp+4Ch] [ebp-26ECh]
  int v14; // [esp+50h] [ebp-26E8h]
  int v15; // [esp+54h] [ebp-26E4h]
  int v16; // [esp+58h] [ebp-26E0h]
  int v17; // [esp+5Ch] [ebp-26DCh]
  int v18; // [esp+6Ch] [ebp-26CCh]
  char s; // [esp+70h] [ebp-26C8h]
  int v20; // [esp+2724h] [ebp-14h]
  int j; // [esp+2728h] [ebp-10h]
  int i; // [esp+272Ch] [ebp-Ch]

  if ( !a2 )
  {
    a2 = &s;
    memset(&s, 0, 0x26A8u);
  }
  v20 = 0;
  i = 0;
  v11 = &off_813DE80;
  while ( i < 105 )
  {
    if ( *(_DWORD *)&v11[1][(_DWORD)a2] != *(_DWORD *)&v11[1][(_DWORD)a3] )
      v20 = i + 1;
    ++i;
    v11 += 3;
  }
  sub_8067B4C(a1, v20);
  i = 0;
  v12 = &off_813DE80;
  while ( i < v20 )
  {
    v10 = (float *)&v12[1][(_DWORD)a3];
    if ( *(_DWORD *)&v12[1][(_DWORD)a2] == *(_DWORD *)v10 )
    {
      sub_8067868(a1);
    }
    else
    {
      sub_80678C6(a1);
      if ( v12[2] )
      {
        if ( v12[2] == (char *)-100 )
        {
          if ( *(_DWORD *)v10 )
          {
            sub_80678C6(a1);
            sub_8067EA6((int)a1, *v10);
          }
          else
          {
            sub_8067868(a1);
          }
        }
        else
        {
          v8 = *(_DWORD *)v10;
          v5 = (int)v12[2];
          if ( v5 < 0 )
            v5 = -v5;
          v7 = v5;
          v6 = v5 & 7;
          if ( v5 & 7 )
          {
            sub_80677A2(a1, v8, v6);
            v7 = v5 - v6;
            v8 >>= v6;
          }
          while ( v7 )
          {
            sub_8067B4C(a1, v8);
            v8 >>= 8;
            v7 -= 8;
          }
        }
      }
      else
      {
        v9 = (signed int)*v10;
        if ( (long double)v9 != *v10 || v9 + 4096 < 0 || v9 + 4096 > 0x1FFF )
        {
          sub_80678C6(a1);
          sub_8067C2A(a1, *(_DWORD *)v10);
        }
        else
        {
          sub_8067868(a1);
          v3 = v9 + 4096;
          sub_80677A2(a1, v3, 5);
          sub_8067B4C(a1, v3 >> 5);
        }
      }
    }
    ++i;
    v12 += 3;
  }
  v18 = 0;
  for ( i = 0; i <= 5; ++i )
  {
    if ( a3[i + 75] != *(_DWORD *)&a2[4 * i + 300] )
      v18 |= 1 << i;
  }
  if ( v18 )
  {
    sub_80678C6(a1);
    sub_80677A2(a1, v18, 6);
    if ( v18 & 1 )
      sub_8067BDA(a1, a3[75]);
    if ( v18 & 2 )
      sub_8067BDA(a1, a3[76]);
    if ( v18 & 4 )
      sub_8067BDA(a1, a3[77]);
    if ( v18 & 8 )
      sub_80677A2(a1, a3[78], 6);
    if ( v18 & 0x10 )
      sub_8067BDA(a1, a3[79]);
    if ( v18 & 0x20 )
      sub_8067B4C(a1, a3[80]);
  }
  else
  {
    sub_8067868(a1);
  }
  for ( j = 0; j <= 3; ++j )
  {
    *(&v14 + j) = 0;
    for ( i = 0; i <= 15; ++i )
    {
      if ( a3[16 * j + 81 + i] != *(_DWORD *)&a2[4 * (i + 16 * j) + 324] )
        *(&v14 + j) |= 1 << i;
    }
  }
  if ( v14 || v15 || v16 || v17 )
  {
    sub_80678C6(a1);
    for ( j = 0; j <= 3; ++j )
    {
      if ( *(&v14 + j) )
      {
        sub_80678C6(a1);
        sub_8067BDA(a1, *(&v14 + j));
        for ( i = 0; i <= 15; ++i )
        {
          if ( (*(&v14 + j) >> i) & 1 )
            sub_8067BDA(a1, a3[16 * j + 81 + i]);
        }
      }
      else
      {
        sub_8067868(a1);
      }
    }
  }
  else
  {
    sub_8067868(a1);
  }
  for ( j = 0; j <= 3; ++j )
  {
    v13 = 0;
    for ( i = 0; i <= 15; ++i )
    {
      if ( a3[16 * j + 209 + i] != *(_DWORD *)&a2[4 * (i + 16 * j) + 836] )
        v13 |= 1 << i;
    }
    if ( v13 )
    {
      sub_80678C6(a1);
      sub_8067BDA(a1, v13);
      for ( i = 0; i <= 15; ++i )
      {
        if ( (v13 >> i) & 1 )
          sub_8067BDA(a1, a3[16 * j + 209 + i]);
      }
    }
    else
    {
      sub_8067868(a1);
    }
  }
  if ( !memcmp(a2 + 1508, a3 + 377, 0x1C0u) )
  {
    sub_8067868(a1);
  }
  else
  {
    sub_80678C6(a1);
    for ( i = 0; i <= 15; ++i )
    {
      sub_80677A2(a1, a3[7 * i + 377], 3);
      sub_8069142(a1, (int)&a2[28 * i + 1508], (int)&a3[7 * i + 377], 0, 6, (int)&off_815A580);
    }
  }
  if ( !memcmp(a2 + 1960, a3 + 490, 0x1F00u) )
    return sub_8067868(a1);
  sub_80678C6(a1);
  sub_8069AC4(a1, (int)(a2 + 5928), (int)(a3 + 1482), 31);
  return (_DWORD *)sub_8069AC4(a1, (int)(a2 + 1960), (int)(a3 + 490), 31);
}
// 813DE80: using guessed type char *off_813DE80;
// 815A580: using guessed type char *off_815A580;

//----- (0806A608) --------------------------------------------------------
void *__cdecl sub_806A608(_DWORD *a1, char *a2, char *a3)
{
  int v3; // edx
  signed int v4; // eax
  long double v5; // fst7
  signed int v6; // eax
  int v7; // ebx
  int v8; // ebx
  signed int *v9; // ebx
  void *result; // eax
  signed int v11; // [esp+2Ch] [ebp-271Ch]
  int v12; // [esp+30h] [ebp-2718h]
  unsigned int v13; // [esp+34h] [ebp-2714h]
  char *v14; // [esp+38h] [ebp-2710h]
  char *v15; // [esp+3Ch] [ebp-270Ch]
  char s; // [esp+40h] [ebp-2708h]
  int v17; // [esp+26FCh] [ebp-4Ch]
  int v18; // [esp+2700h] [ebp-48h]
  unsigned int v19; // [esp+2704h] [ebp-44h]
  int v20; // [esp+2708h] [ebp-40h]
  float *v21; // [esp+270Ch] [ebp-3Ch]
  float *v22; // [esp+2710h] [ebp-38h]
  int v23; // [esp+2714h] [ebp-34h]
  int v24; // [esp+2718h] [ebp-30h]
  char **v25; // [esp+271Ch] [ebp-2Ch]
  int v26; // [esp+2720h] [ebp-28h]
  int v27; // [esp+2724h] [ebp-24h]
  int i; // [esp+2728h] [ebp-20h]
  int j; // [esp+272Ch] [ebp-1Ch]

  if ( !a2 )
  {
    a2 = &s;
    memset(&s, 0, 0x26A8u);
  }
  v15 = a3;
  v14 = a2;
  v13 = 9896;
  if ( (unsigned __int8)a3 & 4 )
  {
    *(_DWORD *)a3 = *(_DWORD *)a2;
    v15 = a3 + 4;
    v14 = a2 + 4;
    v13 = 9892;
  }
  qmemcpy(v15, v14, 4 * (v13 >> 2));
  v23 = 0;
  v24 = 105;
  v27 = sub_8067EE8(a1);
  j = 0;
  v25 = &off_813DE80;
  while ( j < v27 )
  {
    v22 = (float *)&v25[1][(_DWORD)a2];
    v21 = (float *)&v25[1][(_DWORD)a3];
    if ( sub_8067A0E(a1) )
    {
      if ( v25[2] )
      {
        if ( v25[2] == (char *)-100 )
        {
          if ( sub_8067A0E(a1) )
          {
            v5 = sub_80681C8(a1);
            *v21 = v5;
          }
          else
          {
            *v21 = 0.0;
          }
        }
        else
        {
          v19 = (unsigned int)v25[2] >> 31;
          v12 = (int)v25[2];
          if ( v19 )
            v12 = -v12;
          v26 = v12;
          v18 = v12 & 7;
          if ( v12 & 7 )
            v11 = sub_8067960(a1, v18);
          else
            v11 = 0;
          v17 = v11;
          for ( i = v18; i < v26; i += 8 )
          {
            v6 = sub_8067EE8(a1);
            v17 |= v6 << i;
          }
          if ( v19 && (v17 >> (v26 - 1)) & 1 )
            v17 |= ~((1 << v26) - 1);
          *(_DWORD *)v21 = v17;
          if ( v23 )
            Com_Printf("%s:%i ", *v25, *(_DWORD *)v21);
        }
      }
      else if ( sub_8067A0E(a1) )
      {
        v4 = sub_8067F90(a1);
        *(_DWORD *)v21 = v4;
        if ( v23 )
          Com_Printf("%s:%f ", *v25, *v21);
      }
      else
      {
        v20 = sub_8067960(a1, 5);
        v3 = 32 * sub_8067EE8(a1);
        v20 += v3;
        v20 -= 4096;
        *v21 = (long double)v20;
        if ( v23 )
          Com_Printf("%s:%i ", *v25, v20);
      }
    }
    else
    {
      *v21 = *v22;
    }
    ++j;
    v25 += 3;
  }
  j = v27;
  v25 = &(&off_813DE80)[3 * v27];
  while ( j < v24 )
  {
    v22 = (float *)&v25[1][(_DWORD)a2];
    v21 = (float *)&v25[1][(_DWORD)a3];
    *v21 = *v22;
    ++j;
    v25 += 3;
  }
  if ( sub_8067A0E(a1) )
  {
    v26 = sub_8067960(a1, 6);
    if ( v26 & 1 )
      *((_DWORD *)a3 + 75) = sub_8067F32(a1);
    if ( v26 & 2 )
      *((_DWORD *)a3 + 76) = sub_8067F32(a1);
    if ( v26 & 4 )
      *((_DWORD *)a3 + 77) = sub_8067F32(a1);
    if ( v26 & 8 )
      *((_DWORD *)a3 + 78) = sub_8067960(a1, 6);
    if ( v26 & 0x10 )
      *((_DWORD *)a3 + 79) = sub_8067F32(a1);
    if ( v26 & 0x20 )
      *((_DWORD *)a3 + 80) = sub_8067EE8(a1);
  }
  if ( sub_8067A0E(a1) )
  {
    for ( i = 0; i <= 3; ++i )
    {
      if ( sub_8067A0E(a1) )
      {
        v26 = sub_8067F32(a1);
        for ( j = 0; j <= 15; ++j )
        {
          if ( (v26 >> j) & 1 )
          {
            v7 = j + 16 * i;
            *(_DWORD *)&a3[4 * v7 + 324] = sub_8067F32(a1);
          }
        }
      }
    }
  }
  for ( i = 0; i <= 3; ++i )
  {
    if ( sub_8067A0E(a1) )
    {
      v26 = sub_8067F32(a1);
      for ( j = 0; j <= 15; ++j )
      {
        if ( (v26 >> j) & 1 )
        {
          v8 = j + 16 * i;
          *(_DWORD *)&a3[4 * v8 + 836] = sub_8067F32(a1);
        }
      }
    }
  }
  if ( sub_8067A0E(a1) )
  {
    for ( j = 0; j <= 15; ++j )
    {
      v9 = (signed int *)&a3[28 * j + 1508];
      *v9 = sub_8067960(a1, 3);
      sub_80697D8(a1, (int)&a2[28 * j + 1508], (int)&a3[28 * j + 1508], 6, (int)&off_815A580);
    }
  }
  result = (void *)sub_8067A0E(a1);
  if ( result )
  {
    sub_8069C10(a1, (int)(a2 + 5928), (int)(a3 + 5928), 31);
    result = sub_8069C10(a1, (int)(a2 + 1960), (int)(a3 + 1960), 31);
  }
  return result;
}
// 813DE80: using guessed type char *off_813DE80;
// 815A580: using guessed type char *off_815A580;

//----- (0806AC6A) --------------------------------------------------------
int *sub_806AC6A()
{
  int *result; // eax
  int j; // [esp+10h] [ebp-8h]
  int i; // [esp+14h] [ebp-4h]

  result = (int *)sub_8066A70(&unk_81E6860);
  for ( i = 0; i <= 255; ++i )
  {
    for ( j = 0; j < dword_815A760[i]; ++j )
    {
      sub_806610E(&unk_81E6860, i);
      sub_806610E(&unk_81ED87C, i);
    }
    result = &i;
  }
  return result;
}

//----- (0806ACDE) --------------------------------------------------------
int *sub_806ACDE()
{
  dword_81F4898 = 1;
  return sub_806AC6A();
}
// 81F4898: using guessed type int dword_81F4898;

//----- (0806ACF6) --------------------------------------------------------
int __cdecl sub_806ACF6(__int16 a1)
{
  return a1;
}

//----- (0806AD0A) --------------------------------------------------------
int __cdecl sub_806AD0A(int a1)
{
  return a1;
}

//----- (0806AD14) --------------------------------------------------------
char *__cdecl sub_806AD14(int a1, int a2, int a3, int a4, int a5)
{
  __int16 v5; // ax
  __int16 v6; // ax

  if ( a1 == 2 )
  {
    Com_sprintf(byte_82021A0, 0x40u, "loopback");
  }
  else if ( a1 == 4 )
  {
    v5 = sub_80B4F9A(a3);
    Com_sprintf(byte_82021A0, 0x40u, "%i.%i.%i.%i:%i", (unsigned __int8)a2, BYTE1(a2), BYTE2(a2), HIBYTE(a2), v5);
  }
  else
  {
    v6 = sub_80B4F9A(a3);
    Com_sprintf(
      byte_82021A0,
      0x40u,
      "%02x%02x%02x%02x.%02x%02x%02x%02x%02x%02x:%i",
      BYTE2(a3),
      HIBYTE(a3),
      (unsigned __int8)a4,
      BYTE1(a4),
      BYTE2(a4),
      HIBYTE(a4),
      (unsigned __int8)a5,
      BYTE1(a5),
      BYTE2(a5),
      HIBYTE(a5),
      v6);
  }
  return byte_82021A0;
}

//----- (0806AE1A) --------------------------------------------------------
void *__cdecl sub_806AE1A(void **a1)
{
  void *result; // eax

  if ( *(_DWORD *)(dword_81F710C + 8) )
  {
    if ( !dword_81F711C )
    {
      if ( *(_BYTE *)(com_sv_running + 8) && (!*((_DWORD *)off_815A498 + 1) || *(_DWORD *)(dword_81F710C + 8) != 2) )
        dword_81F711C = 2;
      else
        dword_81F711C = 1;
      Com_Printf("Net Profiling turned on: %s\n", *(_DWORD *)&dword_815AB5C[4 * dword_81F711C]);
    }
    result = a1;
    if ( !*a1 )
    {
      *a1 = malloc(0x5E0u);
      result = memset(*a1, 0, 0x5E0u);
    }
  }
  else
  {
    if ( dword_81F711C )
    {
      dword_81F711C = 0;
      Com_Printf("Net Profiling turned off\n");
    }
    result = a1;
    if ( *a1 )
    {
      free(*a1);
      result = a1;
      *a1 = 0;
    }
  }
  return result;
}
// 815A498: using guessed type void *off_815A498;
// 819EF14: using guessed type int com_sv_running;
// 81F710C: using guessed type int dword_81F710C;
// 81F711C: using guessed type int dword_81F711C;

//----- (0806AF0A) --------------------------------------------------------
int __cdecl sub_806AF0A(int a1, int a2, int a3)
{
  int v3; // ecx
  int v4; // ST00_4
  int *v5; // ebx
  int result; // eax

  v3 = *(_DWORD *)(a1 + 720) + 1;
  *(_DWORD *)(a1 + 720) = v3 / 60;
  *(_DWORD *)(a1 + 720) = v3 - 60 * *(_DWORD *)(a1 + 720);
  v4 = a1 + 12 * *(_DWORD *)(a1 + 720);
  v5 = (int *)(a1 + 12 * *(_DWORD *)(a1 + 720));
  *v5 = Sys_MilliSeconds();
  *(_DWORD *)(v4 + 4) = a2;
  result = a3;
  *(_DWORD *)(v4 + 8) = a3;
  return result;
}

//----- (0806AF90) --------------------------------------------------------
void __cdecl sub_806AF90(int a1, int a2, int a3)
{
  if ( dword_81F711C )
  {
    sub_806AF0A(*(_DWORD *)(a1 + 32828), a2, a3);
    if ( *(_DWORD *)(dword_81F7110 + 8) & 2 )
    {
      if ( a3 )
        Com_Printf("%s send%s: %i\n", *(_DWORD *)&off_815AB60[4 * *(_DWORD *)(a1 + 4)], " fragment", a2);
      else
        Com_Printf("%s send%s: %i\n", *(_DWORD *)&off_815AB60[4 * *(_DWORD *)(a1 + 4)], &unk_813E42E, a2);
    }
  }
}
// 81F7110: using guessed type int dword_81F7110;
// 81F711C: using guessed type int dword_81F711C;

//----- (0806B012) --------------------------------------------------------
void __cdecl sub_806B012(int a1, int a2, int a3)
{
  if ( dword_81F711C )
  {
    sub_806AF0A(*(_DWORD *)(a1 + 32828) + 752, a2, a3);
    if ( *(_DWORD *)(dword_81F7110 + 8) & 2 )
    {
      if ( a3 )
        Com_Printf("%s recieve%s: %i\n", *(_DWORD *)&off_815AB60[4 * *(_DWORD *)(a1 + 4)], " fragment", a2);
      else
        Com_Printf("%s recieve%s: %i\n", *(_DWORD *)&off_815AB60[4 * *(_DWORD *)(a1 + 4)], &unk_813E42E, a2);
    }
  }
}
// 81F7110: using guessed type int dword_81F7110;
// 81F711C: using guessed type int dword_81F711C;

//----- (0806B09A) --------------------------------------------------------
_DWORD *__cdecl sub_806B09A(_DWORD *a1)
{
  _DWORD *result; // eax
  int v2; // ebx
  int v3; // [esp+10h] [ebp-28h]
  signed int v4; // [esp+14h] [ebp-24h]
  signed int v5; // [esp+18h] [ebp-20h]
  int v6; // [esp+1Ch] [ebp-1Ch]
  int v7; // [esp+20h] [ebp-18h]
  signed int v8; // [esp+24h] [ebp-14h]
  _DWORD *v9; // [esp+28h] [ebp-10h]
  int v10; // [esp+2Ch] [ebp-Ch]
  signed int i; // [esp+30h] [ebp-8h]

  v10 = 0;
  v9 = 0;
  v8 = -1;
  v7 = Sys_MilliSeconds();
  v5 = 0;
  v4 = 9999;
  v3 = 0;
  for ( i = 0; i <= 59; ++i )
  {
    if ( a1[3 * i] && Sys_MilliSeconds() <= a1[3 * i] + 1000 )
    {
      ++v10;
      if ( a1[3 * i + 2] )
        v9 = (_DWORD *)((char *)v9 + 1);
      if ( a1[3 * i] < v7 )
      {
        v8 = i;
        v7 = a1[3 * i];
      }
      v5 += a1[3 * i + 1];
      if ( a1[3 * i + 1] < v4 )
        v4 = a1[3 * i + 1];
      if ( a1[3 * i + 1] > v3 )
        v3 = a1[3 * i + 1];
    }
  }
  if ( v10 )
  {
    if ( v9 )
      a1[185] = 100 * (signed int)v9 / v10;
    else
      a1[185] = 0;
    a1[186] = v3;
    a1[187] = v4;
    v2 = a1[182] + 100;
    if ( v2 < Sys_MilliSeconds() )
    {
      v6 = Sys_MilliSeconds() - v7;
      if ( v8 != -1 )
      {
        v5 -= a1[3 * v8 + 1];
        --v10;
        if ( a1[3 * v8 + 2] )
          v9 = (_DWORD *)((char *)v9 - 1);
      }
      if ( v6 > 0 && v10 )
      {
        if ( v5 )
          a1[181] = (signed int)((long double)v5 / ((long double)v6 * 0.001));
        else
          a1[181] = 0;
        a1[182] = Sys_MilliSeconds();
      }
      else
      {
        a1[181] = 0;
      }
    }
    a1[183] = v10;
    result = v9;
    a1[184] = v9;
  }
  else
  {
    a1[181] = 0;
    a1[182] = 0;
    a1[183] = 0;
    a1[184] = 0;
    a1[185] = 0;
    a1[186] = 0;
    result = a1;
    a1[187] = 0;
  }
  return result;
}

//----- (0806B3D2) --------------------------------------------------------
void sub_806B3D2()
{
  if ( dword_81F711C )
    sub_8095742(1);
  else
    Com_Printf("Network profiling is not on. Set net_profile to turn on network profiling\n");
}
// 81F711C: using guessed type int dword_81F711C;

//----- (0806B3FE) --------------------------------------------------------
void __usercall Netchan_Init(long double a1@<st0>, unsigned __int16 a2)
{
  dword_81F7100 = (int)Dvar_RegisterBool(a1, "showpackets", 0, 4096);
  dword_81F7104 = (int)Dvar_RegisterBool(a1, "showdrop", 0, 4096);
  dword_81F7108 = (int)Dvar_RegisterBool(a1, "packetDebug", 0, 4096);
  dword_81F7118 = a2;
  dword_81F710C = (int)Dvar_RegisterInt(a1, "net_profile", 0, 0, 2, 4096);
  dword_81F7110 = (int)Dvar_RegisterInt(a1, "net_showprofile", 0, 0, 3, 4096);
  dword_81F7114 = (int)Dvar_RegisterBool(a1, "net_lanauthorize", 0, 4096);
  Cmd_AddCommand("net_dumpprofile", (int)sub_806B3D2);
}
// 81F7100: using guessed type int dword_81F7100;
// 81F7104: using guessed type int dword_81F7104;
// 81F7108: using guessed type int dword_81F7108;
// 81F710C: using guessed type int dword_81F710C;
// 81F7110: using guessed type int dword_81F7110;
// 81F7114: using guessed type int dword_81F7114;
// 81F7118: using guessed type int dword_81F7118;

//----- (0806B510) --------------------------------------------------------
void *__cdecl sub_806B510(int a1, void *s, int a3, int a4, int a5, int a6, int a7, int a8)
{
  int *v8; // edx

  memset(s, 0, 0x8040u);
  *((_DWORD *)s + 1) = a1;
  v8 = (int *)((char *)s + 16);
  *v8 = a3;
  v8[1] = a4;
  v8[2] = a5;
  v8[3] = a6;
  v8[4] = a7;
  *((_DWORD *)s + 9) = a8;
  *((_DWORD *)s + 3) = 0;
  *(_DWORD *)s = 1;
  return sub_806AE1A((void **)s + 8207);
}

//----- (0806B58C) --------------------------------------------------------
_BOOL4 __cdecl sub_806B58C(int a1)
{
  int v1; // eax
  int v3; // [esp+28h] [ebp-5B0h]
  int n; // [esp+2Ch] [ebp-5ACh]
  int v5; // [esp+30h] [ebp-5A8h]
  int s; // [esp+5B0h] [ebp-28h]
  void *src; // [esp+5B4h] [ebp-24h]
  size_t v8; // [esp+5BCh] [ebp-1Ch]

  sub_806AE1A((void **)(a1 + 32828));
  sub_8067718(&s, (int)&v5, 1400);
  sub_8067C2A(&s, *(_DWORD *)a1 | 0x80000000);
  if ( *(_DWORD *)(a1 + 4) <= 0 )
    sub_8067BDA(&s, *(_DWORD *)(a1 + 36));
  n = 1300;
  if ( *(_DWORD *)(a1 + 16436) + 1300 > *(_DWORD *)(a1 + 16440) )
    n = *(_DWORD *)(a1 + 16440) - *(_DWORD *)(a1 + 16436);
  sub_8067BDA(&s, *(_DWORD *)(a1 + 16436));
  sub_8067BDA(&s, n);
  sub_8067B84((int)&s, (void *)(a1 + *(_DWORD *)(a1 + 16436) + 16444), n);
  v3 = (unsigned __int8)sub_806C32C(
                          *(_DWORD *)(a1 + 4),
                          v8,
                          src,
                          *(_DWORD *)(a1 + 16),
                          *(_DWORD *)(a1 + 20),
                          *(_DWORD *)(a1 + 24),
                          *(_DWORD *)(a1 + 28),
                          *(_DWORD *)(a1 + 32));
  sub_806AF90(a1, v8, 1);
  if ( *(_BYTE *)(dword_81F7100 + 8) )
  {
    v1 = sub_806C8C0();
    Com_Printf(
      "[client %i] %s send %4i : s=%i fragment=%i,%i\n",
      v1,
      *(_DWORD *)&off_815AB60[4 * *(_DWORD *)(a1 + 4)],
      v8,
      *(_DWORD *)a1 - 1,
      *(_DWORD *)(a1 + 16436),
      n);
  }
  *(_DWORD *)(a1 + 16436) += n;
  if ( *(_DWORD *)(a1 + 16436) == *(_DWORD *)(a1 + 16440) && n != 1300 )
  {
    ++*(_DWORD *)a1;
    *(_DWORD *)(a1 + 16432) = 0;
  }
  return v3 > 0;
}
// 81F7100: using guessed type int dword_81F7100;

//----- (0806B7AC) --------------------------------------------------------
_BOOL4 __cdecl sub_806B7AC(int a1, size_t n, void *src)
{
  int v3; // eax
  _BOOL4 v5; // [esp+28h] [ebp-5B0h]
  int v6; // [esp+2Ch] [ebp-5ACh]
  int v7; // [esp+30h] [ebp-5A8h]
  int s; // [esp+5B0h] [ebp-28h]
  void *v9; // [esp+5B4h] [ebp-24h]
  size_t v10; // [esp+5BCh] [ebp-1Ch]

  if ( (signed int)n > 0x4000 )
    Com_Error(1, &byte_813E560, n);
  *(_DWORD *)(a1 + 16436) = 0;
  if ( (signed int)n <= 1299 )
  {
    sub_806AE1A((void **)(a1 + 32828));
    sub_8067718(&s, (int)&v7, 1400);
    sub_8067C2A(&s, *(_DWORD *)a1);
    ++*(_DWORD *)a1;
    if ( *(_DWORD *)(a1 + 4) <= 0 )
      sub_8067BDA(&s, *(_DWORD *)(a1 + 36));
    if ( *(_BYTE *)(dword_81F7108 + 8) )
      Com_Printf("Adding %i byte payload to packet\n", n);
    sub_8067B84((int)&s, src, n);
    if ( *(_BYTE *)(dword_81F7108 + 8) )
      Com_Printf("Sending %i byte packet\n", v10);
    v6 = (unsigned __int8)sub_806C32C(
                            *(_DWORD *)(a1 + 4),
                            v10,
                            v9,
                            *(_DWORD *)(a1 + 16),
                            *(_DWORD *)(a1 + 20),
                            *(_DWORD *)(a1 + 24),
                            *(_DWORD *)(a1 + 28),
                            *(_DWORD *)(a1 + 32));
    sub_806AF90(a1, v10, 0);
    if ( *(_BYTE *)(dword_81F7100 + 8) )
    {
      v3 = sub_806C8C0();
      Com_Printf(
        "[client %i] %s send %4i : s=%i ack=%i\n",
        v3 + 1,
        *(_DWORD *)&off_815AB60[4 * *(_DWORD *)(a1 + 4)],
        v10,
        *(_DWORD *)a1 - 1,
        *(_DWORD *)(a1 + 12));
    }
    v5 = v6 > 0;
  }
  else
  {
    *(_DWORD *)(a1 + 16432) = 1;
    *(_DWORD *)(a1 + 16440) = n;
    Com_Memcpy((void *)(a1 + 16444), src, n);
    sub_806B58C(a1);
    v5 = 1;
  }
  return v5;
}
// 81F7100: using guessed type int dword_81F7100;
// 81F7108: using guessed type int dword_81F7108;

//----- (0806B9CA) --------------------------------------------------------
signed int __cdecl sub_806B9CA(int a1, _DWORD *a2)
{
  int v2; // eax
  int v3; // eax
  char *v4; // ebx
  int v5; // eax
  char *v6; // ebx
  int v7; // eax
  char *v8; // eax
  char *v9; // eax
  char *v10; // eax
  int v13; // [esp+20h] [ebp-18h]
  signed int n; // [esp+24h] [ebp-14h]
  signed int v15; // [esp+28h] [ebp-10h]
  int v16; // [esp+30h] [ebp-8h]

  sub_806AE1A((void **)(a1 + 32828));
  sub_806775C(a2);
  v16 = sub_8067F90(a2);
  if ( v16 & 0x80000000 )
  {
    v16 &= 0x7FFFFFFFu;
    v13 = 1;
  }
  else
  {
    v13 = 0;
  }
  if ( *(_DWORD *)(a1 + 4) == 1 )
    sub_8067F32(a2);
  if ( v13 )
  {
    v15 = sub_8067F32(a2);
    n = sub_8067F32(a2);
  }
  else
  {
    v15 = 0;
    n = 0;
  }
  sub_806B012(a1, a2[3], v13);
  if ( *(_BYTE *)(dword_81F7100 + 8) )
  {
    if ( v13 )
    {
      v2 = sub_806C8C0();
      Com_Printf(
        "[client %i] %s recv %4i : s=%i fragment=%i,%i\n",
        v2 + 1,
        *(_DWORD *)&off_815AB60[4 * *(_DWORD *)(a1 + 4)],
        a2[3],
        v16,
        v15,
        n);
    }
    else
    {
      v3 = sub_806C8C0();
      Com_Printf(
        "[client %i] %s recv %4i : s=%i\n",
        v3 + 1,
        *(_DWORD *)&off_815AB60[4 * *(_DWORD *)(a1 + 4)],
        a2[3],
        v16);
    }
  }
  if ( v16 <= *(_DWORD *)(a1 + 12) )
  {
    if ( *(_BYTE *)(dword_81F7104 + 8) || *(_BYTE *)(dword_81F7100 + 8) )
    {
      v4 = sub_806AD14(
             *(_DWORD *)(a1 + 16),
             *(_DWORD *)(a1 + 20),
             *(_DWORD *)(a1 + 24),
             *(_DWORD *)(a1 + 28),
             *(_DWORD *)(a1 + 32));
      v5 = sub_806C8C0();
      Com_Printf("[client %i] %s:Out of order packet %i at %i\n", v5 + 1, v4, v16, *(_DWORD *)(a1 + 12));
    }
    return 0;
  }
  *(_DWORD *)(a1 + 8) = v16 - *(_DWORD *)(a1 + 12) - 1;
  if ( *(_DWORD *)(a1 + 8) > 0 && (*(_BYTE *)(dword_81F7104 + 8) || *(_BYTE *)(dword_81F7100 + 8)) )
  {
    v6 = sub_806AD14(
           *(_DWORD *)(a1 + 16),
           *(_DWORD *)(a1 + 20),
           *(_DWORD *)(a1 + 24),
           *(_DWORD *)(a1 + 28),
           *(_DWORD *)(a1 + 32));
    v7 = sub_806C8C0();
    Com_Printf("[client %i] %s: Dropped %i packets at %i\n", v7 + 1, v6, *(_DWORD *)(a1 + 8), v16);
  }
  if ( !v13 )
  {
LABEL_42:
    *(_DWORD *)(a1 + 12) = v16;
    return 1;
  }
  if ( v16 != *(_DWORD *)(a1 + 40) )
  {
    *(_DWORD *)(a1 + 40) = v16;
    *(_DWORD *)(a1 + 44) = 0;
  }
  if ( v15 != *(_DWORD *)(a1 + 44) )
  {
    if ( *(_BYTE *)(dword_81F7104 + 8) || *(_BYTE *)(dword_81F7100 + 8) )
    {
      v8 = sub_806AD14(
             *(_DWORD *)(a1 + 16),
             *(_DWORD *)(a1 + 20),
             *(_DWORD *)(a1 + 24),
             *(_DWORD *)(a1 + 28),
             *(_DWORD *)(a1 + 32));
      Com_Printf("%s:Dropped a message fragment\n", v8, v16);
    }
    return 0;
  }
  if ( n >= 0 && n + a2[4] <= a2[3] && (unsigned int)(n + *(_DWORD *)(a1 + 44)) <= 0x4000 )
  {
    memcpy((void *)(a1 + *(_DWORD *)(a1 + 44) + 48), (const void *)(a2[1] + a2[4]), n);
    *(_DWORD *)(a1 + 44) += n;
    if ( n == 1300 )
      return 0;
    if ( *(_DWORD *)(a1 + 44) > a2[2] )
    {
      v10 = sub_806AD14(
              *(_DWORD *)(a1 + 16),
              *(_DWORD *)(a1 + 20),
              *(_DWORD *)(a1 + 24),
              *(_DWORD *)(a1 + 28),
              *(_DWORD *)(a1 + 32));
      Com_Printf("%s:fragmentLength %i > msg->maxsize\n", v10, *(_DWORD *)(a1 + 44));
      return 0;
    }
    *(_DWORD *)a2[1] = sub_806C8B8(v16);
    memcpy((void *)(a2[1] + 4), (const void *)(a1 + 48), *(_DWORD *)(a1 + 44));
    a2[3] = *(_DWORD *)(a1 + 44) + 4;
    *(_DWORD *)(a1 + 44) = 0;
    sub_806775C(a2);
    sub_8067F90(a2);
    goto LABEL_42;
  }
  if ( *(_BYTE *)(dword_81F7104 + 8) || *(_BYTE *)(dword_81F7100 + 8) )
  {
    v9 = sub_806AD14(
           *(_DWORD *)(a1 + 16),
           *(_DWORD *)(a1 + 20),
           *(_DWORD *)(a1 + 24),
           *(_DWORD *)(a1 + 28),
           *(_DWORD *)(a1 + 32));
    Com_Printf("%s:illegal fragment length\n", v9);
  }
  return 0;
}
// 81F7100: using guessed type int dword_81F7100;
// 81F7104: using guessed type int dword_81F7104;

//----- (0806BE8E) --------------------------------------------------------
int __cdecl sub_806BE8E(int a1, int a2)
{
  if ( *(_DWORD *)a1 != *(_DWORD *)a2 )
    return *(_DWORD *)a1 - *(_DWORD *)a2;
  switch ( *(_DWORD *)a1 )
  {
    case 2:
      return *(unsigned __int16 *)(a1 + 8) - *(unsigned __int16 *)(a2 + 8);
    case 0:
      return *(unsigned __int16 *)(a1 + 8) - *(unsigned __int16 *)(a2 + 8);
    case 4:
      return memcmp((const void *)(a1 + 4), (const void *)(a2 + 4), 4u);
    case 5:
      return memcmp((const void *)(a1 + 10), (const void *)(a2 + 10), 0xAu);
  }
  Com_Printf("NET_CompareBaseAdrSigned: bad address type\n");
  return 0;
}

//----- (0806BF64) --------------------------------------------------------
_BOOL4 __cdecl sub_806BF64(char a1, int a2, int a3, int a4, int a5, char a6)
{
  return sub_806BE8E((int)&a1, (int)&a6) == 0;
}

//----- (0806BF92) --------------------------------------------------------
int __cdecl sub_806BF92(int a1, int a2)
{
  int v3; // [esp+14h] [ebp-4h]

  if ( *(_DWORD *)a1 != *(_DWORD *)a2 )
    return *(_DWORD *)a1 - *(_DWORD *)a2;
  switch ( *(_DWORD *)a1 )
  {
    case 2:
      return 0;
    case 4:
      if ( *(_WORD *)(a1 + 8) == *(_WORD *)(a2 + 8) )
        v3 = memcmp((const void *)(a1 + 4), (const void *)(a2 + 4), 4u);
      else
        v3 = *(unsigned __int16 *)(a1 + 8) - *(unsigned __int16 *)(a2 + 8);
      break;
    case 5:
      if ( *(_WORD *)(a1 + 8) == *(_WORD *)(a2 + 8) )
        v3 = memcmp((const void *)(a1 + 10), (const void *)(a2 + 10), 0xAu);
      else
        v3 = *(unsigned __int16 *)(a1 + 8) - *(unsigned __int16 *)(a2 + 8);
      break;
    default:
      Com_Printf("NET_CompareAdrSigned: bad address type\n");
      v3 = 0;
      break;
  }
  return v3;
}

//----- (0806C08C) --------------------------------------------------------
_BOOL4 __cdecl sub_806C08C(char a1, int a2, int a3, int a4, int a5, char a6)
{
  return sub_806BF92((int)&a1, (int)&a6) == 0;
}

//----- (0806C0BA) --------------------------------------------------------
signed int __cdecl sub_806C0BA(int a1)
{
  signed int v2; // [esp+0h] [ebp-4h]

  v2 = 0;
  if ( a1 == 2 || !a1 )
    v2 = 1;
  return v2;
}

//----- (0806C0E0) --------------------------------------------------------
signed int __cdecl sub_806C0E0(int *a1, int a2)
{
  return Sys_GetPacket(a1, a2);
}

//----- (0806C0FA) --------------------------------------------------------
int __cdecl sub_806C0FA(int a1, void *s, int a3)
{
  int v3; // ST20_4
  char *v6; // [esp+1Ch] [ebp-Ch]

  v6 = (char *)&unk_81F7180 + 22536 * a1;
  if ( *((_DWORD *)v6 + 5633) - *((_DWORD *)v6 + 5632) > 16 )
    *((_DWORD *)v6 + 5632) = *((_DWORD *)v6 + 5633) - 16;
  if ( *((_DWORD *)v6 + 5632) >= *((_DWORD *)v6 + 5633) )
    return 0;
  v3 = (*((_DWORD *)v6 + 5632))++ & 0xF;
  memcpy(*(void **)(a3 + 4), &v6[1408 * v3], *(_DWORD *)&v6[1408 * v3 + 1400]);
  *(_DWORD *)(a3 + 12) = *(_DWORD *)&v6[1408 * v3 + 1400];
  memset(s, 0, 0x14u);
  *(_DWORD *)s = 2;
  *((_WORD *)s + 4) = *(_WORD *)&v6[1408 * v3 + 1404];
  return 1;
}

//----- (0806C240) --------------------------------------------------------
int __cdecl sub_806C240(int a1, void *s, int a3)
{
  return sub_806C0FA(a1, s, a3);
}

//----- (0806C262) --------------------------------------------------------
int __cdecl sub_806C262(int a1, size_t n, void *src, int a4, int a5, __int16 a6)
{
  char *v6; // ST10_4
  int v7; // ST14_4
  int result; // eax
  int v9; // [esp+Ch] [ebp-Ch]

  v9 = 0;
  if ( a1 > 0 )
  {
    if ( a1 == 1 )
      a1 = (unsigned __int16)a6;
  }
  else
  {
    v9 = a1;
    a1 = 1;
  }
  v6 = (char *)&unk_81F7180 + 22536 * a1;
  v7 = (*((_DWORD *)v6 + 5633))++ & 0xF;
  memcpy(&v6[1408 * v7], src, n);
  *(_DWORD *)&v6[1408 * v7 + 1400] = n;
  result = v9;
  *(_DWORD *)&v6[1408 * v7 + 1404] = v9;
  return result;
}

//----- (0806C32C) --------------------------------------------------------
int __cdecl sub_806C32C(int a1, size_t n, void *src, int a4, int a5, int a6, int a7, int a8)
{
  int v8; // eax
  signed int v10; // [esp+24h] [ebp-4h]

  if ( *(_BYTE *)(dword_81F7100 + 8) && *(_DWORD *)src == -1 )
  {
    v8 = sub_806C8C0();
    Com_Printf("[client %i] send packet %4i\n", v8, n);
  }
  if ( a4 == 2 )
  {
    sub_806C262(a1, n, src, 2, a5, a6);
    v10 = 1;
  }
  else if ( a4 == 1 )
  {
    v10 = 0;
  }
  else if ( a4 )
  {
    v10 = (unsigned __int8)Sys_SendPacket(n, src, a4, a5, a6, a7, a8);
  }
  else
  {
    v10 = 0;
  }
  return v10;
}
// 81F7100: using guessed type int dword_81F7100;

//----- (0806C40C) --------------------------------------------------------
_BOOL4 __cdecl sub_806C40C(int a1, int a2, int a3, int a4, int a5, int a6, char *s)
{
  size_t v7; // eax
  size_t v8; // eax
  _BOOL4 v9; // ebx
  _BOOL4 v11; // [esp+28h] [ebp-30h]
  char *v12; // [esp+2Ch] [ebp-2Ch]
  char v13; // [esp+30h] [ebp-28h]
  int v14; // [esp+48h] [ebp-10h]
  size_t n; // [esp+4Ch] [ebp-Ch]

  sub_80AA1F6((int *)&v13, 0x4000);
  v12 = sub_80AA240((int *)&v13);
  *v12 = -1;
  v12[1] = -1;
  v12[2] = -1;
  v12[3] = -1;
  if ( *(_BYTE *)(dword_81F7100 + 8) )
    Com_DPrintf("OOB Print: %s\n", s);
  if ( strlen(s) + 1 <= 0x3FFC )
  {
    v8 = strlen(s);
    memcpy(v12 + 4, s, v8 + 1);
    n = strlen(v12);
    v14 = (unsigned __int8)sub_806C32C(a1, n, v12, a2, a3, a4, a5, a6);
    if ( a1 == 1 )
      sub_80955EA(n);
    v9 = v14 > 0;
    sub_80AA22A((int *)&v13);
    v11 = v9;
  }
  else
  {
    v7 = strlen(s);
    Com_DPrintf("OOB Packet is %i bytes - too large to send\n", v7);
    sub_80AA22A((int *)&v13);
    v11 = 0;
  }
  return v11;
}
// 81F7100: using guessed type int dword_81F7100;

//----- (0806C57E) --------------------------------------------------------
_BOOL4 __cdecl sub_806C57E(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8)
{
  _BOOL4 v8; // ebx
  char *v10; // [esp+2Ch] [ebp-5Ch]
  char v11; // [esp+30h] [ebp-58h]
  int v12; // [esp+4Ch] [ebp-3Ch]
  void *src; // [esp+54h] [ebp-34h]
  size_t n; // [esp+5Ch] [ebp-2Ch]
  int i; // [esp+7Ch] [ebp-Ch]

  sub_80AA1F6((int *)&v11, 0x4000);
  v10 = sub_80AA240((int *)&v11);
  *v10 = -1;
  v10[1] = -1;
  v10[2] = -1;
  v10[3] = -1;
  for ( i = 0; i < a8; ++i )
    v10[i + 4] = *(_BYTE *)(a7 + i);
  src = v10;
  n = a8 + 4;
  v12 = (unsigned __int8)sub_806C32C(a1, a8 + 4, v10, a2, a3, a4, a5, a6);
  if ( a1 == 1 )
    sub_80955EA(n);
  v8 = v12 > 0;
  sub_80AA22A((int *)&v11);
  return v8;
}

//----- (0806C69C) --------------------------------------------------------
int __cdecl sub_806C69C(int a1, int a2, int a3, int a4, int a5, int a6, void *src, size_t n)
{
  int result; // eax
  char v9; // [esp+40h] [ebp-8008h]
  char v10; // [esp+41h] [ebp-8007h]
  char v11; // [esp+42h] [ebp-8006h]
  char v12; // [esp+43h] [ebp-8005h]
  int v13; // [esp+44h] [ebp-8004h]

  v9 = -1;
  v10 = -1;
  v11 = -1;
  v12 = -1;
  memcpy(&v13, src, n);
  result = sub_806C32C(a1, n + 4, &v9, a2, a3, a4, a5, a6);
  if ( a1 == 1 )
    result = sub_80955EA(n + 4);
  return result;
}

//----- (0806C750) --------------------------------------------------------
int __cdecl sub_806C750(char *s1, void *s)
{
  __int16 v2; // ax
  signed int v4; // [esp+18h] [ebp-420h]
  char *nptr; // [esp+1Ch] [ebp-41Ch]
  char haystack; // [esp+20h] [ebp-418h]
  int v7; // [esp+42Ch] [ebp-Ch]

  if ( !strcmp(s1, "localhost") )
  {
    memset(s, 0, 0x14u);
    *(_DWORD *)s = 2;
    v4 = 1;
  }
  else
  {
    I_strncpyz(&haystack, s1, 1024);
    nptr = strstr(&haystack, ":");
    if ( nptr )
      *nptr++ = 0;
    v7 = sub_80D2CF0(&haystack, (int)s);
    if ( v7 )
    {
      if ( *((_BYTE *)s + 4) != -1 || *((_BYTE *)s + 5) != -1 || *((_BYTE *)s + 6) != -1 || *((_BYTE *)s + 7) != -1 )
      {
        if ( nptr )
        {
          v2 = atoi(nptr);
          *((_WORD *)s + 4) = sub_80B4F9A(v2);
        }
        else
        {
          *((_WORD *)s + 4) = sub_80B4F9A(28960);
        }
        v4 = 1;
      }
      else
      {
        *(_DWORD *)s = 1;
        v4 = 0;
      }
    }
    else
    {
      *(_DWORD *)s = 1;
      v4 = 0;
    }
  }
  return v4;
}

//----- (0806C8B8) --------------------------------------------------------
int __cdecl sub_806C8B8(int a1)
{
  return a1;
}

//----- (0806C8C0) --------------------------------------------------------
int sub_806C8C0()
{
  return 0;
}

//----- (0806C8EA) --------------------------------------------------------
void *sub_806C8EA()
{
  void *result; // eax

  result = memset(&unk_82021E0, 0, 0x38u);
  dword_8202218 = 0;
  return result;
}
// 8202218: using guessed type int dword_8202218;

//----- (0806C918) --------------------------------------------------------
int __cdecl sub_806C918(int a1)
{
  int result; // eax

  result = a1;
  dword_8202428 = a1;
  return result;
}
// 8202428: using guessed type int dword_8202428;

//----- (0806C926) --------------------------------------------------------
char *__cdecl sub_806C926(int a1)
{
  int v1; // ST14_4

  v1 = sub_80B4072();
  sub_80B3A3C();
  return sub_8077FFE(v1 - dword_8202220, "%s", a1);
}
// 8202220: using guessed type int dword_8202220;

//----- (0806C95E) --------------------------------------------------------
int sub_806C95E()
{
  int v1; // [esp+Ch] [ebp-Ch]
  signed int i; // [esp+10h] [ebp-8h]
  char *s1; // [esp+14h] [ebp-4h]

  v1 = 0;
  while ( 1 )
  {
    s1 = sub_80B4848((char **)&dword_8202224);
    if ( !*s1 )
      return v1;
    for ( i = 0; (unsigned int)i <= 2 && strcasecmp(s1, (&off_815AB68)[i]); ++i )
      ;
    if ( i == 1 )
    {
      v1 |= 2u;
    }
    else if ( i > 1 )
    {
      if ( i == 2 )
        v1 |= 8u;
      else
LABEL_16:
        sub_806C926((int)"unknown anim property");
    }
    else
    {
      if ( i )
        goto LABEL_16;
      v1 |= 1u;
    }
  }
}
// 8202224: using guessed type int dword_8202224;

//----- (0806CA12) --------------------------------------------------------
int __cdecl sub_806CA12(_DWORD *a1, unsigned int a2, int a3)
{
  int v3; // ST08_4
  int result; // eax
  __int16 *v5; // eax
  __int16 *v6; // edx
  int v7; // [esp+8h] [ebp-10h]
  _DWORD *v8; // [esp+10h] [ebp-8h]
  int v9; // [esp+14h] [ebp-4h]

  v7 = sub_807BB34(a3, a2);
  if ( v7 )
  {
    v5 = sub_807C4FC(v7);
    *a1 = *(_DWORD *)v5;
    v6 = v5;
    result = (int)a1;
    *(_DWORD *)v6 = a1;
  }
  else
  {
    v3 = sub_807C0CC(a3, a2);
    *a1 = 0;
    v9 = 7;
    v8 = a1;
    result = sub_807C45C(v3, (int *)&v8);
  }
  return result;
}

//----- (0806CA94) --------------------------------------------------------
char *__cdecl sub_806CA94(_DWORD *a1, unsigned int a2, int a3)
{
  char *result; // eax

  if ( dword_8202448 )
    result = (char *)sub_806CA12(a1, a2, dword_8202448);
  else
    result = sub_8077FFE(a3, "#using_animtree was not specified");
  return result;
}
// 8202448: using guessed type int dword_8202448;

//----- (0806CADC) --------------------------------------------------------
int __cdecl sub_806CADC(int a1, int a2, char a3, char a4, char a5)
{
  int v5; // eax
  int v6; // eax
  signed int v8; // [esp+20h] [ebp-28h]
  char v9; // [esp+25h] [ebp-23h]
  unsigned __int8 v10; // [esp+26h] [ebp-22h]
  char v11; // [esp+27h] [ebp-21h]
  int v12; // [esp+28h] [ebp-20h]
  int v13; // [esp+2Ch] [ebp-1Ch]
  int v14; // [esp+30h] [ebp-18h]
  int v15; // [esp+34h] [ebp-14h]
  int v16; // [esp+38h] [ebp-10h]
  int v17; // [esp+3Ch] [ebp-Ch]
  char *v18; // [esp+40h] [ebp-8h]
  char v19; // [esp+45h] [ebp-3h]
  char v20; // [esp+46h] [ebp-2h]
  char v21; // [esp+47h] [ebp-1h]

  v21 = a3;
  v20 = a4;
  v19 = a5;
  v15 = 6;
  v16 = 0;
  v17 = 0;
  v12 = 0;
  v11 = 0;
  while ( 1 )
  {
    while ( 1 )
    {
      while ( 1 )
      {
        v18 = Com_Parse((char **)&dword_8202224);
        if ( !dword_8202224 )
        {
          v10 = 1;
          goto LABEL_46;
        }
        if ( !(unsigned __int8)sub_8075828(v18) )
          break;
        if ( v11 )
          sub_807C16E(a1, v16);
        v16 = sub_807939E(v18, 2);
        if ( sub_807BB34(a1, v16) )
          sub_806C926((int)"duplicate animation");
        v17 = sub_807C0A8(a1, v16);
        v9 = 0;
        if ( !v19 && !sub_807BB34(a2, v16) && !dword_8202428 )
          v9 = 1;
        v11 = v9;
        v12 = 0;
        v18 = sub_80B4848((char **)&dword_8202224);
        if ( *v18 )
        {
          if ( (unsigned __int8)sub_8075828(v18) )
            sub_806C926((int)"FIXME: aliases not yet implemented");
          if ( *v18 != 58 || v18[1] )
            sub_806C926((int)"bad token");
          v12 = sub_806C95E();
          v18 = Com_Parse((char **)&dword_8202224);
          if ( *v18 != 123 || v18[1] )
            sub_806C926((int)"properties cannot be applied to primitive animations");
          break;
        }
      }
      if ( *v18 != 123 )
        break;
      if ( v18[1] )
        sub_806C926((int)"bad token");
      if ( *sub_80B4848((char **)&dword_8202224) )
        sub_806C926((int)"token not allowed after '{'");
      if ( !v17 )
        sub_806C926((int)"no animation specified for this block");
      v13 = sub_807CAD2(v17);
      v8 = 0;
      if ( v19 || v12 & 8 && !v11 )
        v8 = 1;
      if ( (unsigned __int8)sub_806CADC(v13, a2, (unsigned __int8)(v11 ^ 1), v12 & 1, v8) )
        sub_806C926((int)"unexpected end of file");
      if ( sub_807C9AC(v13) )
      {
        v14 = v12;
        v5 = sub_807C060(v13, 0);
        sub_807C45C(v5, &v14);
      }
      else
      {
        sub_807C16E(a1, v16);
      }
      v17 = 0;
      v11 = 0;
    }
    if ( *v18 == 125 )
      break;
    sub_806C926((int)"bad token");
  }
  if ( v18[1] )
    sub_806C926((int)"bad token");
  if ( *sub_80B4848((char **)&dword_8202224) )
    sub_806C926((int)"token not allowed after '}'");
  v10 = 0;
LABEL_46:
  if ( v11 )
    sub_807C16E(a1, v16);
  if ( v21 && !sub_807C9AC(a1) )
  {
    if ( v20 )
      v6 = sub_8079290("void_loop", 0);
    else
      v6 = sub_8079290("void", 0);
    v16 = v6;
    sub_807C0A8(a1, v6);
    sub_80796A2(v16);
  }
  return v10;
}
// 8202224: using guessed type int dword_8202224;
// 8202428: using guessed type int dword_8202428;

//----- (0806CE74) --------------------------------------------------------
_DWORD *__cdecl sub_806CE74(int a1, int a2, int a3)
{
  sub_80B396A("Scr_AnimTreeParse");
  dword_8202224 = a1;
  dword_8202220 = a1;
  if ( !(unsigned __int8)sub_806CADC(a2, a3, 1, 0, 0) )
    sub_806C926((int)"bad token");
  return sub_80B3A3C();
}
// 8202220: using guessed type int dword_8202220;
// 8202224: using guessed type int dword_8202224;

//----- (0806CED4) --------------------------------------------------------
void *__cdecl sub_806CED4(size_t n)
{
  return Hunk_AllocAlignInternal(n, 4);
}

//----- (0806CEF0) --------------------------------------------------------
int __cdecl sub_806CEF0(int a1)
{
  int v1; // eax
  int v3; // [esp+Ch] [ebp-Ch]
  int i; // [esp+14h] [ebp-4h]

  v3 = 0;
  for ( i = sub_807C9CE(a1); i; i = sub_807C9CE(i) )
  {
    if ( sub_807CA72(i) <= 0xFFFF )
    {
      if ( sub_807DF7C(i) == 1 )
      {
        v1 = sub_807CB1E(i);
        v3 += sub_806CEF0(v1);
      }
      else
      {
        ++v3;
      }
    }
  }
  if ( v3 )
    ++v3;
  return v3;
}

//----- (0806CF7E) --------------------------------------------------------
int __cdecl sub_806CF7E(int a1, __int16 a2, int a3, int a4, __int16 a5)
{
  int result; // eax
  int v6; // ebx
  int v7; // eax
  _DWORD *v8; // ST14_4
  int v9; // [esp+10h] [ebp-18h]
  _DWORD *i; // [esp+18h] [ebp-10h]
  __int16 *v11; // [esp+1Ch] [ebp-Ch]

  result = sub_807BB34(a1, a4);
  if ( result )
  {
    v11 = sub_807C4FC(result);
    if ( !*(_DWORD *)v11 )
    {
      v6 = sub_8078896(a3);
      v7 = sub_8078896(a4);
      Com_Error(1, &byte_813E9E0, v7, v6);
    }
    LOWORD(v9) = a2;
    HIWORD(v9) = a5;
    for ( i = *(_DWORD **)v11; i; i = v8 )
    {
      v8 = (_DWORD *)*i;
      *i = v9;
    }
    result = (int)v11;
    *(_DWORD *)v11 = 0;
  }
  return result;
}

//----- (0806D074) --------------------------------------------------------
int __cdecl sub_806D074(int a1)
{
  return dword_820264C[a1];
}

//----- (0806D084) --------------------------------------------------------
int __cdecl sub_806D084(int a1, int a2, int a3, int a4, char *s, int a6, int a7, int a8)
{
  char *v8; // ebx
  int v9; // eax
  char *v10; // eax
  unsigned __int16 v12; // [esp+20h] [ebp-18h]
  int v13; // [esp+24h] [ebp-14h]
  int v14; // [esp+28h] [ebp-10h]
  unsigned int v15; // [esp+2Ch] [ebp-Ch]
  int i; // [esp+30h] [ebp-8h]
  int j; // [esp+30h] [ebp-8h]
  int v18; // [esp+4Ch] [ebp+14h]
  int v19; // [esp+54h] [ebp+1Ch]

  v14 = 0;
  for ( i = sub_807C9CE(a1); i; i = sub_807C9CE(i) )
  {
    if ( sub_807CA72(i) <= 0xFFFF )
      ++v14;
  }
  v13 = sub_807BB10(a1, 0);
  if ( v13 )
    v12 = *sub_807C4FC(v13);
  else
    v12 = 0;
  dword_839403C *= 31;
  dword_839403C += a6;
  dword_839403C *= 31;
  dword_839403C += a4;
  dword_839403C *= 31;
  dword_839403C += v14;
  dword_839403C *= 31;
  dword_839403C += v12;
  sub_80BA57A(a3, a6, s, a4, v14, v12);
  v19 = a4;
  v18 = v14 + a4;
  for ( j = sub_807C9CE(a1); j; j = sub_807C9CE(j) )
  {
    v15 = sub_807CA72(j);
    if ( v15 <= 0xFFFF )
    {
      sub_806CF7E(a2, v19, a7, (unsigned __int16)v15, a8);
      if ( sub_807DF7C(j) == 1 )
      {
        v8 = (char *)sub_8078896(v15);
        v9 = sub_807CB1E(j);
        v18 = sub_806D084(v9, a2, a3, v18, v8, v19, a7, a8);
      }
      else
      {
        dword_839403C *= 31;
        dword_839403C += v19;
        v10 = (char *)sub_8078896(v15);
        sub_80BA4D8(a3, v19, v10);
      }
      ++v19;
    }
  }
  return v18;
}
// 839403C: using guessed type int dword_839403C;

//----- (0806D2DC) --------------------------------------------------------
int __cdecl sub_806D2DC(int a1, int a2)
{
  int result; // eax
  int v3; // ebx
  int v4; // eax
  char *v5; // [esp+14h] [ebp-14h]
  __int16 *v6; // [esp+18h] [ebp-10h]
  int i; // [esp+1Ch] [ebp-Ch]
  int v8; // [esp+20h] [ebp-8h]

  result = sub_807C9CE(a1);
  for ( i = result; i; i = result )
  {
    v8 = sub_807CA72(i);
    v6 = sub_807C4FC(i);
    if ( *(_DWORD *)v6 )
    {
      v3 = sub_8078896(a2);
      v4 = sub_8078896(v8);
      v5 = va("animation '%s' not defined in anim tree '%s'", v4, v3);
      if ( sub_80757CC(*(_DWORD *)v6) )
        sub_80780F6(*(_DWORD *)v6, "%s", v5);
      Com_Error(1, &byte_813EA4D, v5);
    }
    result = sub_807C9CE(i);
  }
  return result;
}

//----- (0806D3B4) --------------------------------------------------------
int __cdecl sub_806D3B4(int a1)
{
  int result; // eax
  int v2; // eax
  char *v3; // eax
  unsigned int v4; // [esp+10h] [ebp-8h]
  int i; // [esp+14h] [ebp-4h]

  result = sub_807C9CE(a1);
  for ( i = result; i; i = result )
  {
    v4 = sub_807CA72(i);
    if ( v4 <= 0xFFFF )
    {
      if ( sub_807DF7C(i) == 1 )
      {
        v2 = sub_807CB1E(i);
        sub_806D3B4(v2);
      }
      else
      {
        v3 = (char *)sub_8078896(v4);
        sub_80BA3AE(v3, (int)sub_806CED4);
      }
    }
    result = sub_807C9CE(i);
  }
  return result;
}

//----- (0806D43C) --------------------------------------------------------
int __cdecl sub_806D43C(char *a1, int *a2, int a3)
{
  int v3; // ST1C_4
  int v4; // ST18_4
  int v5; // eax
  int v6; // ST20_4
  int i; // [esp+14h] [ebp-14h]
  int v9; // [esp+18h] [ebp-10h]
  int v10; // [esp+1Ch] [ebp-Ch]
  int v11; // [esp+24h] [ebp-4h]

  v11 = sub_8079C2A(a1);
  v10 = sub_807BB34(dword_8202440, v11);
  if ( v10 )
  {
    v9 = sub_807CB1E(v10);
    *a2 = 0;
    for ( i = 1; i <= dword_820284C[a3]; ++i )
    {
      if ( (unsigned __int16)word_8202228[128 * a3 + i] == v10 )
      {
        *a2 = i;
        break;
      }
    }
    v5 = sub_807C0A8(v9, 0);
  }
  else
  {
    v3 = sub_807C0CC(dword_8202440, v11);
    v4 = sub_807CA86(v3);
    word_8202228[++dword_820284C[a3] + (a3 << 7)] = v3;
    *a2 = dword_820284C[a3];
    v5 = sub_807C0A8(v4, 0);
  }
  v6 = sub_807CAD2(v5);
  sub_80796A2(v11);
  return v6;
}
// 8202440: using guessed type int dword_8202440;
// 820284C: using guessed type int dword_820284C[];

//----- (0806D55A) --------------------------------------------------------
char *__cdecl sub_806D55A(char *a1, int a2)
{
  char *result; // eax

  if ( !(unsigned __int8)sub_8075828(a1) )
    return sub_8077FFE(a2, "bad anim tree name");
  result = (char *)sub_806D43C(a1, &dword_8202854, 1);
  dword_8202448 = (int)result;
  return result;
}
// 8202448: using guessed type int dword_8202448;
// 8202854: using guessed type int dword_8202854;

//----- (0806D5A6) --------------------------------------------------------
_BOOL4 __cdecl sub_806D5A6(int a1, int a2, int a3)
{
  int v3; // ST28_4
  int v6; // [esp+24h] [ebp-54h]
  int v7; // [esp+2Ch] [ebp-4Ch]
  char s; // [esp+30h] [ebp-48h]

  sprintf(&s, "animtrees/%s.atr", a1);
  v6 = *(_DWORD *)dword_8283EE0;
  v7 = sub_807799E(0, &s, 0, 1);
  if ( !v7 )
    return 0;
  v3 = *(_DWORD *)dword_8283EDC;
  *(_DWORD *)dword_8283EDC = &s;
  sub_806CE74(v7, a2, a3);
  *(_DWORD *)dword_8283EDC = v3;
  *(_DWORD *)dword_8283EE0 = v6;
  sub_80A9DB4();
  return sub_807C9AC(a2) != 0;
}

//----- (0806D668) --------------------------------------------------------
int __cdecl sub_806D668(int a1, int a2, int a3)
{
  int v3; // ST20_4
  int v4; // eax
  int result; // eax
  int v6; // eax
  int v7; // eax
  char *v8; // eax
  int v9; // ST38_4
  char *v10; // eax
  char **v11; // ST2C_4
  int v12; // ST28_4
  int v13; // eax
  int v14; // [esp+24h] [ebp-24h]
  int v15; // [esp+30h] [ebp-18h]
  int v16; // [esp+3Ch] [ebp-Ch]
  int v17; // [esp+3Ch] [ebp-Ch]
  char **v18; // [esp+40h] [ebp-8h]
  int v19; // [esp+44h] [ebp-4h]

  v3 = (unsigned __int16)word_8202228[a1 + (a3 << 7)];
  v15 = (unsigned __int16)sub_807CA72(v3);
  v4 = sub_807CB1E(v3);
  v14 = v4;
  result = sub_807BB34(v4, 1);
  if ( !result )
  {
    v16 = sub_807BB34(v14, 0);
    if ( v16 )
    {
      v17 = sub_807CB1E(v16);
      dword_8202444 = sub_807B658();
      v6 = sub_8078896(v15);
      if ( !(unsigned __int8)sub_806D5A6(v6, dword_8202444, v17) )
      {
        v7 = sub_8078896(v15);
        v8 = va("unknown anim tree '%s'", v7);
        Com_Error(1, v8);
      }
      v9 = sub_806CEF0(dword_8202444);
      v10 = (char *)sub_8078896(v15);
      v11 = sub_80BA626(v10, v9, a2);
      v12 = sub_8079290("root", 0);
      sub_806CF7E(v17, 0, v15, v12, a1);
      sub_80796A2(v12);
      sub_806D3B4(dword_8202444);
      sub_806D084(dword_8202444, v17, (int)v11, 1, "root", 0, v15, a1);
      sub_806D2DC(v17, v15);
      sub_807C16E(v14, 0);
      sub_807B7DC(dword_8202444);
      dword_8202444 = 0;
      v19 = 7;
      v18 = v11;
      v13 = sub_807C0A8(v14, 1u);
      sub_807C45C(v13, (int *)&v18);
      sub_80C006C(v11);
      result = (int)v11;
      dword_820244C[a1 + (a3 << 7)] = (int)v11;
    }
    else
    {
      result = 0;
      dword_820244C[a1 + (a3 << 7)] = 0;
    }
  }
  return result;
}

//----- (0806D8CE) --------------------------------------------------------
_DWORD *__userpurge sub_806D8CE@<eax>(_DWORD *a1, char *a2)
{
  int v3; // [esp+8h] [ebp-20h]
  int v4; // [esp+Ch] [ebp-1Ch]
  int v5; // [esp+10h] [ebp-18h]
  int v6; // [esp+14h] [ebp-14h]
  int v7; // [esp+1Ch] [ebp-Ch]
  int v8; // [esp+20h] [ebp-8h]
  int v9; // [esp+24h] [ebp-4h]

  v8 = sub_8079C2A(a2);
  v9 = sub_807BB34(dword_8202440, v8);
  sub_80796A2(v8);
  *a1 = 0;
  if ( v9 )
  {
    v8 = (unsigned __int16)sub_807CA72(v9);
    v9 = sub_807CB1E(v9);
    v7 = sub_807BB34(v9, 1);
    if ( v7 )
    {
      sub_807C66A(&v3, v7);
      v5 = v3;
      v6 = v4;
      *a1 = v3;
    }
  }
  return a1;
}
// 8202440: using guessed type int dword_8202440;

//----- (0806D982) --------------------------------------------------------
int __cdecl sub_806D982(char *a1, char *s, _DWORD *a3, int a4)
{
  int v4; // eax
  char v6; // [esp+10h] [ebp-8h]
  int v7; // [esp+14h] [ebp-4h]

  v7 = sub_807939E(s, 0);
  v4 = sub_806D43C(a1, (int *)&v6, a4);
  sub_806CA12(a3, v7, v4);
  return sub_80796A2(v7);
}

//----- (0806D9EC) --------------------------------------------------------
int __cdecl sub_806D9EC(int a1)
{
  int result; // eax

  if ( !byte_820287C )
    result = sub_80796A2(a1);
  return result;
}
// 820287C: using guessed type char byte_820287C;

//----- (0806DA0A) --------------------------------------------------------
int __cdecl sub_806DA0A(int a1)
{
  int result; // eax
  _WORD *v2; // ebx

  dword_8202860 = sub_8079CC8(2);
  if ( dword_8202A68 == 2 )
    return sub_806D9EC(a1);
  if ( byte_820287C )
    sub_807951E(a1);
  v2 = (_WORD *)dword_8202860;
  result = sub_80759F2(a1);
  *v2 = result;
  return result;
}
// 8202860: using guessed type int dword_8202860;
// 820287C: using guessed type char byte_820287C;
// 8202A68: using guessed type int dword_8202A68;

//----- (0806DA66) --------------------------------------------------------
int __cdecl sub_806DA66(int a1)
{
  unsigned __int8 v1; // ST07_1
  int result; // eax

  v1 = byte_820287C;
  byte_820287C = 1;
  sub_806DA0A(a1);
  result = v1;
  byte_820287C = v1;
  return result;
}
// 820287C: using guessed type char byte_820287C;

//----- (0806DA94) --------------------------------------------------------
int __cdecl sub_806DA94(int a1, unsigned __int8 a2)
{
  if ( dword_8202A68 == 2 )
    return sub_806D9EC(a1);
  if ( byte_820287C )
    sub_807951E(a1);
  return sub_80794D8(a1, a2);
}
// 820287C: using guessed type char byte_820287C;
// 8202A68: using guessed type int dword_8202A68;

//----- (0806DAD8) --------------------------------------------------------
int __cdecl sub_806DAD8(int a1, int a2, int a3)
{
  int result; // eax
  unsigned int v4; // eax
  _BYTE *v5; // edx
  unsigned int v6; // [esp+Ch] [ebp-Ch]
  unsigned int v7; // [esp+Ch] [ebp-Ch]
  int v8; // [esp+10h] [ebp-8h]
  int i; // [esp+14h] [ebp-4h]

  if ( dword_8202A40 )
  {
    v8 = dword_8202A40;
    dword_8202A40 = 0;
    for ( i = 0; i < v8; ++i )
      sub_806EE00((int *)(12 * i + 136325308));
  }
  byte_8202A65 = 0;
  if ( !dword_8202870 || a3 == 2 || a3 == 3 )
    byte_8202A65 = 1;
  dword_8202870 += a2;
  if ( dword_8202874 < dword_8202870 )
    dword_8202874 = dword_8202870;
  if ( a3 && dword_8202878 < dword_8202870 )
    dword_8202878 = dword_8202870;
  dword_839403C *= 31;
  dword_839403C += a1;
  if ( dword_8202A6C )
  {
    dword_8202860 = dword_8202A6C;
    switch ( a1 )
    {
      case 32:
        if ( *(_BYTE *)dword_8202A6C == 30 )
        {
          sub_8076FAE();
          result = dword_8202A6C;
          *(_BYTE *)dword_8202A6C = 31;
          return result;
        }
        v6 = *(unsigned __int8 *)dword_8202A6C - 24;
        if ( v6 > 5 )
          goto LABEL_61;
        sub_8076FAE();
        *(_BYTE *)dword_8202A6C = 31;
        return sub_806DF8E(v6);
      case 35:
        if ( *(_BYTE *)dword_8202A6C == 55 )
        {
          sub_8076FAE();
          result = dword_8202A6C;
          *(_BYTE *)dword_8202A6C = 34;
          return result;
        }
        if ( *(_BYTE *)dword_8202A6C != 54 )
          goto LABEL_61;
        sub_8076FAE();
        result = dword_8202A6C;
        *(_BYTE *)dword_8202A6C = 33;
        return result;
      case 42:
        if ( *(_BYTE *)dword_8202A6C == 38 )
        {
          result = dword_8202A6C;
          *(_BYTE *)dword_8202A6C = 41;
          return result;
        }
        if ( *(_BYTE *)dword_8202A6C == 13 )
        {
          result = dword_8202A6C;
          *(_BYTE *)dword_8202A6C = 39;
          return result;
        }
        if ( *(_BYTE *)dword_8202A6C != 14 )
          goto LABEL_61;
        result = dword_8202A6C;
        *(_BYTE *)dword_8202A6C = 40;
        return result;
      case 46:
        if ( *(_BYTE *)dword_8202A6C == 38 )
        {
          result = dword_8202A6C;
          *(_BYTE *)dword_8202A6C = 45;
          return result;
        }
        if ( *(_BYTE *)dword_8202A6C == 13 )
        {
          result = dword_8202A6C;
          *(_BYTE *)dword_8202A6C = 43;
          return result;
        }
        if ( *(_BYTE *)dword_8202A6C != 14 )
          goto LABEL_61;
        result = dword_8202A6C;
        *(_BYTE *)dword_8202A6C = 44;
        return result;
      case 49:
        if ( *(_BYTE *)dword_8202A6C != 22 )
          goto LABEL_61;
        result = dword_8202A6C;
        *(_BYTE *)dword_8202A6C = 48;
        return result;
      case 57:
        switch ( *(_BYTE *)dword_8202A6C )
        {
          case 0x37:
            sub_8076FAE();
            result = dword_8202A6C;
            *(_BYTE *)dword_8202A6C = 61;
            return result;
          case 0x36:
            sub_8076FAE();
            result = dword_8202A6C;
            *(_BYTE *)dword_8202A6C = 60;
            return result;
          case 0x2D:
            sub_8076FAE();
            result = dword_8202A6C;
            *(_BYTE *)dword_8202A6C = 59;
            return result;
          case 0x2B:
            sub_8076FAE();
            result = dword_8202A6C;
            *(_BYTE *)dword_8202A6C = 56;
            return result;
        }
        if ( *(_BYTE *)dword_8202A6C != 44 )
          goto LABEL_61;
        sub_8076FAE();
        result = dword_8202A6C;
        *(_BYTE *)dword_8202A6C = 58;
        return result;
      case 80:
        if ( *(_BYTE *)dword_8202A6C != 78 )
          goto LABEL_61;
        result = dword_8202A6C;
        *(_BYTE *)dword_8202A6C = 79;
        return result;
      case 82:
        if ( *(_BYTE *)dword_8202A6C != 15 )
          goto LABEL_61;
        sub_8076FAE();
        *(_BYTE *)dword_8202A6C = 80;
        result = dword_8202864;
        if ( *(_BYTE *)dword_8202864 == 78 )
        {
          sub_8079CF0(dword_8202A6C);
          --dword_8202A6C;
          dword_8202864 = 0;
          dword_8202860 = dword_8202A6C;
          result = dword_8202A6C;
          *(_BYTE *)dword_8202A6C = 79;
        }
        return result;
      case 86:
        if ( *(_BYTE *)dword_8202A6C != 15 )
          goto LABEL_61;
        sub_8076FAE();
        result = dword_8202A6C;
        *(_BYTE *)dword_8202A6C = 84;
        return result;
      case 89:
        if ( *(_BYTE *)dword_8202A6C == 30 )
        {
          result = dword_8202A6C;
          *(_BYTE *)dword_8202A6C = 90;
          return result;
        }
        v7 = *(unsigned __int8 *)dword_8202A6C - 24;
        if ( v7 > 5 )
          goto LABEL_61;
        *(_BYTE *)dword_8202A6C = 90;
        result = sub_806DF8E(v7);
        break;
      case 94:
        if ( *(_BYTE *)dword_8202A6C != 92 )
          goto LABEL_61;
        sub_8076FAE();
        result = dword_8202A6C;
        *(_BYTE *)dword_8202A6C = 95;
        return result;
      default:
        goto LABEL_61;
    }
  }
  else
  {
LABEL_61:
    dword_8202864 = dword_8202A6C;
    v4 = sub_8079C94(1);
    dword_8202A6C = v4;
    dword_8202860 = v4;
    v5 = (_BYTE *)v4;
    result = (unsigned __int8)a1;
    *v5 = a1;
  }
  return result;
}
// 8202860: using guessed type int dword_8202860;
// 8202864: using guessed type int dword_8202864;
// 8202870: using guessed type int dword_8202870;
// 8202874: using guessed type int dword_8202874;
// 8202878: using guessed type int dword_8202878;
// 8202A40: using guessed type int dword_8202A40;
// 8202A65: using guessed type char byte_8202A65;
// 8202A6C: using guessed type int dword_8202A6C;
// 839403C: using guessed type int dword_839403C;

//----- (0806DEC6) --------------------------------------------------------
int sub_806DEC6()
{
  return sub_806DAD8(0, 0, 0);
}

//----- (0806DEEA) --------------------------------------------------------
int sub_806DEEA()
{
  return sub_806DAD8(1, -1, 0);
}

//----- (0806DF0E) --------------------------------------------------------
int __cdecl sub_806DF0E(int a1)
{
  unsigned int v1; // eax
  _DWORD *v2; // edx
  int result; // eax

  v1 = sub_8079CC8(4);
  dword_8202860 = v1;
  v2 = (_DWORD *)v1;
  result = a1;
  *v2 = a1;
  return result;
}
// 8202860: using guessed type int dword_8202860;

//----- (0806DF32) --------------------------------------------------------
int __cdecl sub_806DF32(unsigned __int16 a1)
{
  unsigned int v1; // eax
  _WORD *v2; // edx
  int result; // eax

  v1 = sub_8079CC8(2);
  dword_8202860 = v1;
  v2 = (_WORD *)v1;
  result = a1;
  *v2 = a1;
  return result;
}
// 8202860: using guessed type int dword_8202860;

//----- (0806DF60) --------------------------------------------------------
int __cdecl sub_806DF60(unsigned __int16 a1)
{
  unsigned int v1; // eax
  _WORD *v2; // edx
  int result; // eax

  v1 = sub_8079CC8(2);
  dword_8202860 = v1;
  v2 = (_WORD *)v1;
  result = a1;
  *v2 = a1;
  return result;
}
// 8202860: using guessed type int dword_8202860;

//----- (0806DF8E) --------------------------------------------------------
int __cdecl sub_806DF8E(unsigned __int8 a1)
{
  unsigned int v1; // eax
  _BYTE *v2; // edx
  int result; // eax

  v1 = sub_8079C94(1);
  dword_8202860 = v1;
  v2 = (_BYTE *)v1;
  result = a1;
  *v2 = a1;
  return result;
}
// 8202860: using guessed type int dword_8202860;

//----- (0806DFBA) --------------------------------------------------------
int __cdecl sub_806DFBA(int a1)
{
  unsigned int v1; // eax
  _DWORD *v2; // edx
  int result; // eax

  v1 = sub_8079CDC(4);
  dword_8202860 = v1;
  v2 = (_DWORD *)v1;
  result = a1;
  *v2 = a1;
  return result;
}
// 8202860: using guessed type int dword_8202860;

//----- (0806DFDE) --------------------------------------------------------
int __cdecl sub_806DFDE(int a1)
{
  unsigned int v1; // eax
  _WORD *v2; // edx
  int result; // eax

  v1 = sub_8079CC8(2);
  dword_8202860 = v1;
  v2 = (_WORD *)v1;
  result = a1;
  *v2 = a1;
  return result;
}
// 8202860: using guessed type int dword_8202860;

//----- (0806E004) --------------------------------------------------------
int __cdecl sub_806E004(int a1)
{
  unsigned int v1; // eax
  _DWORD *v2; // edx
  int result; // eax

  v1 = sub_8079CC8(4);
  dword_8202860 = v1;
  v2 = (_DWORD *)v1;
  result = a1;
  *v2 = a1;
  return result;
}
// 8202860: using guessed type int dword_8202860;

//----- (0806E028) --------------------------------------------------------
int __cdecl sub_806E028(int a1, int a2)
{
  int result; // eax

  *(_DWORD *)(a2 + 4) = 0;
  result = a1;
  *(_DWORD *)(a2 + 8) = a1;
  return result;
}

//----- (0806E042) --------------------------------------------------------
void __cdecl sub_806E042(int a1)
{
  sub_806DAD8(2, 1, 0);
  sub_8076D92(a1, 1);
}

//----- (0806E07A) --------------------------------------------------------
int __cdecl sub_806E07A(int a1, int a2, _DWORD *a3)
{
  int result; // eax

  a3[1] = 6;
  *a3 = a1;
  result = a2;
  a3[2] = a2;
  return result;
}

//----- (0806E09C) --------------------------------------------------------
void __cdecl sub_806E09C(signed int a1, int a2)
{
  if ( a1 < 0 )
  {
    if ( a1 > -256 )
    {
      sub_806DAD8(5, 1, 0);
      sub_8076D92(a2, 1);
      sub_806DF8E(-(char)a1);
      return;
    }
    if ( a1 > -65536 )
    {
      sub_806DAD8(7, 1, 0);
      sub_8076D92(a2, 1);
      sub_806DF60(-(signed __int16)a1);
      return;
    }
  }
  else
  {
    if ( !a1 )
    {
      sub_806DAD8(3, 1, 0);
      sub_8076D92(a2, 1);
      return;
    }
    if ( a1 <= 255 )
    {
      sub_806DAD8(4, 1, 0);
      sub_8076D92(a2, 1);
      sub_806DF8E(a1);
      return;
    }
    if ( a1 <= 0xFFFF )
    {
      sub_806DAD8(6, 1, 0);
      sub_8076D92(a2, 1);
      sub_806DF60(a1);
      return;
    }
  }
  sub_806DAD8(8, 1, 0);
  sub_8076D92(a2, 1);
  sub_806DF0E(a1);
}

//----- (0806E250) --------------------------------------------------------
int __cdecl sub_806E250(int a1, int a2, _DWORD *a3)
{
  int result; // eax

  a3[1] = 5;
  *a3 = a1;
  result = a2;
  a3[2] = a2;
  return result;
}

//----- (0806E272) --------------------------------------------------------
int __cdecl sub_806E272(int a1, int a2)
{
  sub_806DAD8(9, 1, 0);
  sub_8076D92(a2, 1);
  return sub_806DFBA(a1);
}

//----- (0806E2B4) --------------------------------------------------------
void __cdecl sub_806E2B4(int a1)
{
  if ( dword_8202854 )
    sub_806E09C(dword_8202854, a1);
  else
    sub_8077FFE(a1, "#using_animtree was not specified");
}
// 8202854: using guessed type int dword_8202854;

//----- (0806E2EE) --------------------------------------------------------
void __cdecl sub_806E2EE(int a1)
{
  sub_806DAD8(57, -1, 0);
  sub_8076D92(a1, 0);
}

//----- (0806E326) --------------------------------------------------------
signed int __cdecl sub_806E326(int a1, int a2, int a3)
{
  int i; // [esp+4h] [ebp-4h]

  for ( i = a2; i < *(_DWORD *)(a1 + 12); ++i )
  {
    if ( *(_DWORD *)(a1 + 4 * i + 24) == a3 )
      return i;
  }
  return -1;
}

//----- (0806E36A) --------------------------------------------------------
int __cdecl sub_806E36A(int a1, int a2, char a3, int a4)
{
  int v4; // eax
  int v6; // [esp+10h] [ebp-18h]
  int i; // [esp+18h] [ebp-10h]

  if ( !a4 )
    goto LABEL_20;
  for ( i = 0; ; ++i )
  {
    if ( i >= *(_DWORD *)(a4 + 12) )
      goto LABEL_13;
    if ( i == *(_DWORD *)(a4 + 4) )
    {
      ++*(_DWORD *)(a4 + 4);
      sub_806DAD8(22, 0, 0);
      sub_806DA66(*(_DWORD *)(a4 + 4 * i + 24));
    }
    if ( *(_DWORD *)(a4 + 4 * i + 24) == a1 )
      break;
  }
  sub_806D9EC(a1);
  if ( *(_BYTE *)(a4 + (i >> 3) + 16) & (unsigned __int8)(1 << (i & 7)) )
    return *(_DWORD *)(a4 + 4) - i - 1;
  if ( a3 && !byte_82028B0 )
  {
    *(_BYTE *)(a4 + (i >> 3) + 16) |= 1 << (i & 7);
    return *(_DWORD *)(a4 + 4) - i - 1;
  }
LABEL_13:
  if ( !a3 )
    goto LABEL_21;
  if ( byte_82028B0 )
  {
LABEL_21:
    v4 = sub_8078896(a1);
    sub_8077FFE(a2, "uninitialised variable '%s'", v4);
    v6 = 0;
  }
  else
  {
LABEL_20:
    sub_8077FFE(a2, "unreachable code");
    v6 = 0;
  }
  return v6;
}
// 82028B0: using guessed type char byte_82028B0;

//----- (0806E4CA) --------------------------------------------------------
int __cdecl sub_806E4CA(int a1)
{
  int result; // eax
  int i; // [esp+14h] [ebp-4h]

  result = *(_DWORD *)(a1 + 4);
  if ( result != *(_DWORD *)(a1 + 8) )
  {
    for ( i = *(_DWORD *)(a1 + 4); i < *(_DWORD *)(a1 + 8); ++i )
    {
      sub_806DAD8(22, 0, 0);
      sub_806DA66(*(_DWORD *)(a1 + 4 * i + 24));
    }
    result = a1;
    *(_DWORD *)(a1 + 4) = *(_DWORD *)(a1 + 8);
  }
  return result;
}

//----- (0806E53A) --------------------------------------------------------
int __cdecl sub_806E53A(_DWORD *a1, int a2)
{
  int result; // eax
  int v3; // edx
  int v4; // [esp+14h] [ebp-4h]

  result = (int)a1;
  if ( !*a1 )
  {
    v3 = *(_DWORD *)(a2 + 8);
    result = a1[1] - v3;
    v4 = a1[1] - v3;
    if ( a1[1] != v3 )
    {
      sub_806DAD8(23, 0, 0);
      sub_806DF8E(v4);
      result = a1[2];
      a1[1] = result;
    }
  }
  return result;
}

//----- (0806E59A) --------------------------------------------------------
int __cdecl sub_806E59A(char a1, int a2, _DWORD *a3)
{
  int result; // eax
  int v4; // [esp+10h] [ebp-8h]

  v4 = dword_839403C;
  if ( a1 )
  {
    sub_806DEC6();
    sub_8076D92(a2, 1);
  }
  else
  {
    sub_806E53A(a3, (int)a3);
  }
  result = v4 + 1;
  dword_839403C = v4 + 1;
  return result;
}
// 839403C: using guessed type int dword_839403C;

//----- (0806E5EC) --------------------------------------------------------
void __cdecl sub_806E5EC(signed int a1)
{
  if ( a1 > 1023 )
    Com_Error(1, "MAX_SWITCH_CASES exceeded");
}

//----- (0806E614) --------------------------------------------------------
void __cdecl sub_806E614(signed int a1)
{
  if ( a1 > 63 )
    Com_Error(1, "LOCAL_VAR_STACK_SIZE exceeded");
}

//----- (0806E638) --------------------------------------------------------
_DWORD *__cdecl sub_806E638(_DWORD *a1, int a2, _DWORD *a3)
{
  _DWORD *result; // eax
  int i; // [esp+4h] [ebp-4h]

  result = a3;
  if ( !*a3 )
  {
    for ( i = 0; i < a3[3]; ++i )
    {
      result = (_DWORD *)a3[i + 6];
      if ( result == a1 )
        return result;
    }
    sub_806E614(a3[3]);
    a3[a3[3] + 6] = a1;
    result = a3;
    ++result[3];
  }
  return result;
}

//----- (0806E69A) --------------------------------------------------------
_DWORD *__cdecl sub_806E69A(_DWORD *a1, size_t *a2)
{
  _DWORD *result; // eax
  unsigned int v3; // [esp+10h] [ebp-18h]
  const void *v4; // [esp+14h] [ebp-14h]
  _DWORD *v5; // [esp+18h] [ebp-10h]

  if ( !*a2 )
    *a2 = sub_80A9CF0(280);
  v5 = (_DWORD *)*a2;
  v4 = a1;
  v3 = 280;
  if ( *a2 & 4 )
  {
    *v5 = *a1;
    ++v5;
    v4 = a1 + 1;
    v3 = 276;
  }
  qmemcpy(v5, v4, 4 * (v3 >> 2));
  result = (_DWORD *)*a2;
  *(_DWORD *)(*a2 + 8) = 0;
  return result;
}

//----- (0806E714) --------------------------------------------------------
int __cdecl sub_806E714(int a1, signed int a2, int a3)
{
  int result; // eax
  int v4; // ST04_4
  int v5; // [esp+0h] [ebp-20h]
  int v6; // [esp+8h] [ebp-18h]
  signed int i; // [esp+Ch] [ebp-14h]
  signed int k; // [esp+Ch] [ebp-14h]
  int j; // [esp+10h] [ebp-10h]

  if ( a2 )
  {
    v5 = *(_DWORD *)(*(_DWORD *)a1 + 8);
    for ( i = 1; i < a2; ++i )
    {
      v6 = *(_DWORD *)(a1 + 4 * i);
      if ( *(_DWORD *)(v6 + 8) < v5 )
        v5 = *(_DWORD *)(v6 + 8);
    }
    *(_DWORD *)(a3 + 4) = v5;
    for ( j = 0; ; ++j )
    {
      result = j;
      if ( j >= v5 )
        break;
      if ( !(((signed int)*(unsigned __int8 *)(a3 + (j >> 3) + 16) >> (j & 7)) & 1) )
      {
        v4 = *(_DWORD *)(a3 + 4 * j + 24);
        for ( k = 0; k < a2; ++k )
        {
          if ( ((unsigned __int8)((signed int)*(unsigned __int8 *)(*(_DWORD *)(a1 + 4 * k) + (j >> 3) + 16) >> (j & 7)) ^ 1) & 1 )
            goto LABEL_15;
        }
        *(_BYTE *)(a3 + (j >> 3) + 16) |= 1 << (j & 7);
      }
LABEL_15:
      ;
    }
  }
  return result;
}

//----- (0806E846) --------------------------------------------------------
void __cdecl sub_806E846(int a1, signed int a2, _DWORD *a3)
{
  int v3; // [esp+1Ch] [ebp-Ch]
  signed int i; // [esp+20h] [ebp-8h]
  signed int k; // [esp+20h] [ebp-8h]
  int j; // [esp+24h] [ebp-4h]

  if ( a2 && !*a3 )
  {
    for ( i = 0; i < a2; ++i )
      **(_DWORD **)(a1 + 4 * i) = 0;
    for ( j = 0; j < *(_DWORD *)(*(_DWORD *)a1 + 12); ++j )
    {
      v3 = *(_DWORD *)(*(_DWORD *)a1 + 4 * j + 24);
      if ( sub_806E326((int)a3, 0, *(_DWORD *)(*(_DWORD *)a1 + 4 * j + 24)) < 0 )
      {
        for ( k = 1; k < a2; ++k )
        {
          if ( sub_806E326(*(_DWORD *)(a1 + 4 * k), 0, v3) < 0 )
            goto LABEL_14;
        }
        a3[a3[3]++ + 6] = v3;
      }
LABEL_14:
      ;
    }
  }
}

//----- (0806E94E) --------------------------------------------------------
void __cdecl sub_806E94E(int a1, int a2, _DWORD *a3)
{
  int v3; // [esp+14h] [ebp-14h]
  int v4; // [esp+18h] [ebp-10h]
  int i; // [esp+1Ch] [ebp-Ch]
  signed int v6; // [esp+20h] [ebp-8h]
  int j; // [esp+24h] [ebp-4h]

  if ( a2 && !*a3 )
  {
    for ( i = 0; i < a2; ++i )
    {
      v3 = *(_DWORD *)(a1 + 4 * i);
      *(_DWORD *)(v3 + 8) = a3[3];
      for ( j = 0; j < a3[3]; ++j )
      {
        v4 = a3[j + 6];
        v6 = sub_806E326(v3, j, a3[j + 6]);
        if ( v6 < 0 )
        {
          v6 = *(_DWORD *)(v3 + 12);
          sub_806E614(*(_DWORD *)(v3 + 12));
          ++*(_DWORD *)(v3 + 12);
        }
        while ( v6 > j )
        {
          *(_DWORD *)(v3 + 4 * v6 + 24) = *(_DWORD *)(v3 + 4 * v6 + 20);
          --v6;
        }
        *(_DWORD *)(v3 + 4 * j + 24) = v4;
      }
    }
  }
}

//----- (0806EA5A) --------------------------------------------------------
_DWORD *__cdecl sub_806EA5A(int a1, _DWORD *a2)
{
  _DWORD *result; // eax
  int v3; // [esp+10h] [ebp-18h]
  signed int v4; // [esp+14h] [ebp-14h]
  int i; // [esp+18h] [ebp-10h]

  for ( i = 0; i < a2[2] || i < *(_DWORD *)(a1 + 4); ++i )
  {
    v3 = *(_DWORD *)(a1 + 4 * i + 24);
    v4 = sub_806E326((int)a2, i, *(_DWORD *)(a1 + 4 * i + 24));
    if ( v4 < 0 )
    {
      v4 = a2[3];
      sub_806E614(a2[3]);
      ++a2[3];
    }
    if ( v4 >= a2[2] )
      ++a2[2];
    while ( v4 > i )
    {
      a2[v4 + 6] = a2[v4 + 5];
      --v4;
    }
    a2[i + 6] = v3;
    if ( ((signed int)*(unsigned __int8 *)(a1 + (i >> 3) + 16) >> (i & 7)) & 1 )
      *((_BYTE *)a2 + (i >> 3) + 16) |= 1 << (i & 7);
  }
  a2[1] = *(_DWORD *)(a1 + 4);
  result = a2;
  *a2 = 0;
  return result;
}

//----- (0806EB94) --------------------------------------------------------
void __cdecl sub_806EB94(int a1, int a2, int a3)
{
  int v3; // [esp+14h] [ebp-4h]

  v3 = sub_806E36A(a1, a2, 1, a3);
  if ( v3 )
    sub_806DAD8(50, 0, 0);
  else
    sub_806DAD8(49, 0, 0);
  if ( v3 )
    sub_806DF8E(v3);
  sub_8076D92(a2, 0);
}

//----- (0806EC16) --------------------------------------------------------
_DWORD *__cdecl sub_806EC16(_DWORD *a1, int a2, _DWORD *a3)
{
  return sub_806E638(a1, a2, a3);
}

//----- (0806EC38) --------------------------------------------------------
void __cdecl sub_806EC38(int a1, int a2, int a3)
{
  unsigned __int8 v3; // ST14_1

  v3 = sub_806E36A(a1, a2, 1, a3);
  sub_806DAD8(51, 0, 0);
  sub_806DF8E(v3);
  sub_8076D92(a2, 0);
}

//----- (0806ECA0) --------------------------------------------------------
int __cdecl sub_806ECA0(int a1, int a2, _DWORD *a3)
{
  int result; // eax

  a3[1] = 2;
  *a3 = a1;
  result = a2;
  a3[2] = a2;
  return result;
}

//----- (0806ECC2) --------------------------------------------------------
int __cdecl sub_806ECC2(int a1, int a2)
{
  sub_806DAD8(10, 1, 0);
  sub_8076D92(a2, 1);
  sub_806DFDE(a1);
  return sub_806DA94(a1, 1u);
}

//----- (0806ED18) --------------------------------------------------------
int __cdecl sub_806ED18(int a1, int a2, _DWORD *a3)
{
  int result; // eax

  a3[1] = 3;
  *a3 = a1;
  result = a2;
  a3[2] = a2;
  return result;
}

//----- (0806ED3A) --------------------------------------------------------
int __cdecl sub_806ED3A(int a1, int a2)
{
  sub_806DAD8(11, 1, 0);
  sub_8076D92(a2, 1);
  sub_806DFDE(a1);
  return sub_806DA94(a1, 1u);
}

//----- (0806ED90) --------------------------------------------------------
int __cdecl sub_806ED90(int a1, int a2)
{
  signed int i; // [esp+14h] [ebp-4h]

  sub_806DAD8(12, 1, 0);
  sub_8076D92(a2, 1);
  for ( i = 0; i <= 2; ++i )
    sub_806DFBA(*(_DWORD *)(a1 + 4 * i));
  return sub_807B9CA(a1);
}

//----- (0806EE00) --------------------------------------------------------
void __cdecl sub_806EE00(int *a1)
{
  switch ( a1[1] )
  {
    case 0:
      sub_806E042(a1[2]);
      break;
    case 1:
      return;
    case 2:
      sub_806ECC2(*a1, a1[2]);
      break;
    case 3:
      sub_806ED3A(*a1, a1[2]);
      break;
    case 4:
      sub_806ED90(*a1, a1[2]);
      break;
    case 5:
      sub_806E272(*a1, a1[2]);
      break;
    case 6:
      sub_806E09C(*a1, a1[2]);
      break;
  }
}

//----- (0806EEC6) --------------------------------------------------------
char *__cdecl sub_806EEC6(int *a1)
{
  char *result; // eax
  int v2; // ecx

  if ( dword_8202A40 > 31 )
    return sub_8077FFE(a1[2], "VALUE_STACK_SIZE exceeded");
  v2 = 3 * dword_8202A40;
  dword_82028BC[v2] = *a1;
  dword_82028C0[v2] = a1[1];
  result = (char *)a1[2];
  dword_82028C4[v2] = (int)result;
  ++dword_8202A40;
  return result;
}
// 82028BC: using guessed type int dword_82028BC[];
// 82028C0: using guessed type int dword_82028C0[];
// 82028C4: using guessed type int dword_82028C4[];
// 8202A40: using guessed type int dword_8202A40;

//----- (0806EF26) --------------------------------------------------------
void sub_806EF26()
{
  --dword_8202A40;
}
// 8202A40: using guessed type int dword_8202A40;

//----- (0806EF32) --------------------------------------------------------
void __cdecl sub_806EF32(int a1)
{
  sub_806DAD8(91, 0, 0);
  sub_8076D92(a1, 0);
}

//----- (0806EF6A) --------------------------------------------------------
void __cdecl sub_806EF6A(int a1)
{
  sub_806DAD8(92, 0, 0);
  sub_8076D92(a1, 0);
}

//----- (0806EFA2) --------------------------------------------------------
void __cdecl sub_806EFA2(int a1)
{
  sub_806DAD8(93, 0, 0);
  sub_8076D92(a1, 0);
}

//----- (0806EFDA) --------------------------------------------------------
void __cdecl sub_806EFDA(int a1, int a2, int a3)
{
  sub_8071552(a1, a3);
  sub_806DAD8(118, 0, 0);
  sub_8076D92(a2, 0);
}

//----- (0806F024) --------------------------------------------------------
void __cdecl sub_806F024(int a1)
{
  sub_806DAD8(15, 1, 0);
  sub_8076D92(a1, 1);
}

//----- (0806F05C) --------------------------------------------------------
void __cdecl sub_806F05C(int a1)
{
  sub_806DAD8(16, 1, 0);
  sub_8076D92(a1, 1);
}

//----- (0806F094) --------------------------------------------------------
void __cdecl sub_806F094(int a1)
{
  sub_806DAD8(17, 1, 0);
  sub_8076D92(a1, 1);
}

//----- (0806F0CC) --------------------------------------------------------
void __cdecl sub_806F0CC(int a1)
{
  sub_806DAD8(18, 1, 0);
  sub_8076D92(a1, 1);
}

//----- (0806F104) --------------------------------------------------------
void __cdecl sub_806F104(int a1)
{
  sub_806DAD8(38, 0, 0);
  sub_8076D92(a1, 1);
}

//----- (0806F13C) --------------------------------------------------------
void __cdecl sub_806F13C(int a1)
{
  sub_806DAD8(13, 0, 0);
  sub_8076D92(a1, 1);
}

//----- (0806F174) --------------------------------------------------------
void __cdecl sub_806F174(int a1)
{
  sub_806DAD8(14, 0, 0);
  sub_8076D92(a1, 1);
}

//----- (0806F1AC) --------------------------------------------------------
void __cdecl sub_806F1AC(int a1, int a2, int a3)
{
  int v3; // [esp+10h] [ebp-8h]
  int v4; // [esp+14h] [ebp-4h]

  v4 = sub_806E36A(a1, a2, 0, a3);
  if ( v4 > 5 )
  {
    v3 = 30;
    sub_806DAD8(30, 1, 0);
  }
  else
  {
    v3 = v4 + 24;
    sub_806DAD8(v4 + 24, 1, 0);
  }
  if ( v3 == 30 )
    sub_806DF8E(v4);
  sub_8076D92(a2, 1);
}

//----- (0806F230) --------------------------------------------------------
void __cdecl sub_806F230(int a1, int a2, int a3)
{
  int v3; // [esp+14h] [ebp-4h]

  v3 = sub_806E36A(a1, a2, 1, a3);
  if ( v3 )
    sub_806DAD8(55, 0, 0);
  else
    sub_806DAD8(54, 0, 0);
  if ( v3 )
    sub_806DF8E(v3);
  sub_8076D92(a2, 1);
}

//----- (0806F2B2) --------------------------------------------------------
_DWORD *__cdecl sub_806F2B2(_DWORD *a1, int a2, _DWORD *a3)
{
  return sub_806E638(a1, a2, a3);
}

//----- (0806F2D4) --------------------------------------------------------
void __cdecl sub_806F2D4(int a1)
{
  sub_806DAD8(20, 0, 0);
  sub_8076D92(a1, 1);
}

//----- (0806F30C) --------------------------------------------------------
void __cdecl sub_806F30C(int a1, int a2)
{
  sub_806DAD8(32, -1, 0);
  sub_8076D92(a2, 0);
  sub_8076D92(a1, 1);
}

//----- (0806F356) --------------------------------------------------------
void __cdecl sub_806F356(int a1, int a2)
{
  sub_806DAD8(35, -1, 0);
  sub_8076D92(a2, 0);
  sub_8076D92(a1, 1);
}

//----- (0806F3A0) --------------------------------------------------------
void __cdecl sub_806F3A0(int a1, int a2)
{
  sub_806DAD8(36, -1, 0);
  sub_8076D92(a2, 0);
  sub_8076D92(a1, 0);
}

//----- (0806F3EA) --------------------------------------------------------
void __cdecl sub_806F3EA(int a1)
{
  sub_806DAD8(37, 1, 0);
  sub_8076D92(a1, 1);
}

//----- (0806F422) --------------------------------------------------------
int __cdecl sub_806F422(unsigned int a1, int a2)
{
  sub_806DAD8(19, 1, 0);
  sub_8076D92(a2, 1);
  sub_806DF0E(-1);
  sub_806CA94((_DWORD *)dword_8202860, a1, a2);
  return sub_806D9EC(a1);
}
// 8202860: using guessed type int dword_8202860;

//----- (0806F48C) --------------------------------------------------------
int __cdecl sub_806F48C(_DWORD *a1, int a2, int a3, int a4)
{
  sub_8071D92(a1, a3, a4);
  sub_806DAD8(42, 1, 0);
  sub_8076D92(a3, 0);
  return sub_806DA0A(a2);
}

//----- (0806F4E8) --------------------------------------------------------
int __cdecl sub_806F4E8(_DWORD *a1, int a2, int a3, int a4)
{
  sub_8071D92(a1, a3, a4);
  sub_806DAD8(46, 0, 0);
  return sub_806DA0A(a2);
}

//----- (0806F530) --------------------------------------------------------
int __cdecl sub_806F530(_DWORD *a1, int a2, int a3, int a4, int a5)
{
  sub_8071D92(a1, a3, a5);
  sub_806DAD8(47, 0, 0);
  sub_8076D92(a4, 0);
  return sub_806DA0A(a2);
}

//----- (0806F58C) --------------------------------------------------------
char *__cdecl sub_806F58C(int a1, int a2)
{
  char *result; // eax
  int v3; // [esp+10h] [ebp-18h]
  int v4; // [esp+14h] [ebp-14h]
  unsigned int v5; // [esp+1Ch] [ebp-Ch]
  int v6; // [esp+20h] [ebp-8h]
  int v7; // [esp+24h] [ebp-4h]

  if ( byte_8202A64 )
    return sub_8077FFE(a2, "$ can only be used in the script debugger");
  v4 = sub_8078896(a1);
  if ( *(_BYTE *)v4 == 116 )
  {
    v5 = atoi((const char *)(v4 + 1));
    if ( !v5
      || v5 > 0xFFFD
      || (unsigned __int8)sub_807DF52((unsigned __int16)v5)
      || (v3 = sub_807DF7C((unsigned __int16)v5), v3 < 15)
      || v3 > 18 && v3 != 23 )
    {
      result = sub_8077FFE(a2, "bad expression");
    }
    else
    {
      sub_806DAD8(130, 1, 0);
      result = (char *)sub_806DF32(v5);
    }
  }
  else
  {
    v7 = sub_807F6F2(*(_BYTE *)v4);
    if ( v7 >= 0 )
    {
      v6 = atoi((const char *)(v4 + 1));
      if ( v6 || *(_BYTE *)(v4 + 1) == 48 )
      {
        sub_806DAD8(129, 1, 0);
        sub_806DF0E(v7);
        result = (char *)sub_806DF0E(v6);
      }
      else
      {
        result = sub_8077FFE(a2, "bad expression");
      }
    }
    else
    {
      result = sub_8077FFE(a2, "bad expression");
    }
  }
  return result;
}
// 8202A64: using guessed type char byte_8202A64;

//----- (0806F6FE) --------------------------------------------------------
int sub_806F6FE()
{
  return sub_806DAD8(88, -1, 0);
}

//----- (0806F722) --------------------------------------------------------
void __cdecl sub_806F722(int a1)
{
  sub_806DAD8(89, -1, 0);
  sub_8076D92(a1, 0);
}

//----- (0806F75A) --------------------------------------------------------
void __cdecl sub_806F75A(int a1, _DWORD *a2, int a3, int a4, int a5)
{
  sub_8071B6C(a2, a5);
  sub_8071552(a1, a5);
  sub_806F30C(a3, a4);
}

//----- (0806F798) --------------------------------------------------------
void __cdecl sub_806F798(_DWORD *a1, _DWORD *a2, int a3, int a4, int a5)
{
  sub_8071B6C(a2, a5);
  sub_8071D0A(a1, a3, a5);
  sub_806F356(a3, a4);
}

//----- (0806F7DE) --------------------------------------------------------
_DWORD *__cdecl sub_806F7DE(int *a1, int a2)
{
  return sub_8071D66(a1, a2);
}

//----- (0806F7F8) --------------------------------------------------------
void __cdecl sub_806F7F8(_DWORD *a1, _DWORD *a2, int a3, int a4, int a5)
{
  sub_8071B6C(a2, a5);
  sub_8071D0A(a1, a3, a5);
  sub_806F3A0(a3, a4);
}

//----- (0806F83E) --------------------------------------------------------
void __cdecl sub_806F83E(signed int *a1, int a2)
{
  signed int v2; // [esp+20h] [ebp-8h]

  v2 = *a1;
  if ( *a1 == 15 )
  {
    sub_806F48C((_DWORD *)a1[1], a1[2], a1[3], a2);
  }
  else if ( v2 > 15 )
  {
    if ( v2 == 53 )
    {
      if ( byte_8202A64 )
        sub_8077FFE(a1[2], "self field can only be used in the script debugger");
      else
        sub_8077FFE(a1[2], "self field in assignment expression not currently supported");
    }
    else if ( v2 == 79 )
    {
      sub_806F58C(a1[1], a1[2]);
    }
  }
  else if ( v2 == 4 )
  {
    sub_806F1AC(a1[1], a1[2], a2);
  }
  else if ( v2 == 13 )
  {
    sub_806F75A(a1[1], (_DWORD *)a1[2], a1[3], a1[4], a2);
  }
}
// 8202A64: using guessed type char byte_8202A64;

//----- (0806F96C) --------------------------------------------------------
int __cdecl sub_806F96C(int *a1)
{
  int v2; // [esp+0h] [ebp-8h]
  int i; // [esp+4h] [ebp-4h]

  v2 = 0;
  for ( i = *a1; i; i = *(_DWORD *)(i + 4) )
    ++v2;
  return v2;
}

//----- (0806F9A0) --------------------------------------------------------
int __cdecl sub_806F9A0(int *a1, int a2)
{
  int v3; // [esp+10h] [ebp-8h]
  int i; // [esp+14h] [ebp-4h]

  v3 = 0;
  for ( i = *a1; i; i = *(_DWORD *)(i + 4) )
  {
    sub_8071B6C(**(_DWORD ***)i, a2);
    ++v3;
  }
  return v3;
}

//----- (0806F9EA) --------------------------------------------------------
int __cdecl sub_806F9EA(int a1)
{
  if ( !*(_DWORD *)a1 )
    return 0;
  if ( *(_DWORD *)(*(_DWORD *)a1 + 4) )
    return 0;
  return *(_DWORD *)a1;
}

//----- (0806FA26) --------------------------------------------------------
_DWORD *__cdecl sub_806FA26(_DWORD *a1)
{
  _DWORD *result; // eax
  _DWORD *i; // [esp+14h] [ebp-4h]

  if ( byte_839400A )
  {
    result = (_DWORD *)*a1;
    for ( i = (_DWORD *)*a1; i; i = (_DWORD *)i[1] )
    {
      sub_8076D92(*(_DWORD *)(*i + 4), 0);
      result = (_DWORD *)i[1];
    }
  }
  return result;
}
// 839400A: using guessed type char byte_839400A;

//----- (0806FA70) --------------------------------------------------------
int __cdecl sub_806FA70(unsigned int a1, int a2, char a3)
{
  int v3; // eax

  sub_807951E(a1);
  sub_806D9EC(a1);
  *(_WORD *)dword_82028B4 = a1;
  *(_DWORD *)(dword_82028B4 + 4) = a2;
  *(_BYTE *)(dword_82028B4 + 2) = a3;
  dword_82028B4 += 12;
  v3 = sub_807C0A8(dword_8202A4C, a1);
  return sub_807CA86(v3);
}
// 82028B4: using guessed type int dword_82028B4;
// 8202A4C: using guessed type int dword_8202A4C;

//----- (0806FADC) --------------------------------------------------------
void __cdecl sub_806FADC(_DWORD *a1, int a2)
{
  char *v2; // eax
  int v3; // eax
  int v4; // [esp+18h] [ebp-60h]
  int v5; // [esp+1Ch] [ebp-5Ch]
  int v6; // [esp+20h] [ebp-58h]
  int v7; // [esp+24h] [ebp-54h]
  int v8; // [esp+28h] [ebp-50h]
  int v9; // [esp+2Ch] [ebp-4Ch]
  int v10; // [esp+34h] [ebp-44h]
  int v11; // [esp+38h] [ebp-40h]
  int v12; // [esp+3Ch] [ebp-3Ch]
  int v13; // [esp+40h] [ebp-38h]
  bool v14; // [esp+47h] [ebp-31h]
  int v15; // [esp+48h] [ebp-30h]
  int v16; // [esp+4Ch] [ebp-2Ch]
  int v17; // [esp+50h] [ebp-28h]
  int v18; // [esp+54h] [ebp-24h]
  int v19; // [esp+58h] [ebp-20h]
  int v20; // [esp+5Ch] [ebp-1Ch]
  int v21; // [esp+60h] [ebp-18h]
  int v22; // [esp+64h] [ebp-14h]
  int v23; // [esp+68h] [ebp-10h]
  int v24; // [esp+6Ch] [ebp-Ch]

  if ( dword_8202A68 == 2 )
  {
    sub_806D9EC(a1[1]);
    if ( *a1 == 21 )
    {
      sub_806D9EC(a1[2]);
      --dword_8202A44;
    }
    return;
  }
  v20 = 0;
  if ( *a1 == 20 )
  {
    v10 = 0;
    v19 = sub_807C0A8(dword_8202868, a1[1]);
    sub_806DA94(a1[1], 2u);
    v20 = sub_807CA86(v19);
  }
  else
  {
    v10 = 1;
    v2 = (char *)sub_8078896(a1[1]);
    v15 = sub_8079C2A(v2);
    sub_806D9EC(a1[1]);
    v3 = sub_807BB34(dword_8202A48, v15);
    sub_807C66A(&v8, v3);
    v21 = v8;
    v22 = v9;
    v14 = v9 != 0;
    v16 = sub_806FA70(v15, a2, 0);
    if ( v14 )
    {
      v19 = sub_807BB34(v16, a1[2]);
      if ( !v19 )
      {
        sub_8077FFE(a2, "unknown function");
        return;
      }
      if ( sub_807DF7C(v19) != 1 )
      {
        sub_8077FFE(a2, "unknown function");
        return;
      }
    }
    else
    {
      v19 = sub_807C0A8(v16, a1[2]);
    }
    sub_806DA94(a1[2], 2u);
    v20 = sub_807CA86(v19);
    v13 = sub_807BB34(v20, 1);
    if ( v13 )
    {
      sub_807C66A(&v6, v13);
      v11 = v6;
      v12 = v7;
      if ( v7 == 13 )
      {
        sub_8077FFE(a2, "unknown function");
        return;
      }
      if ( v11 )
      {
        if ( v12 == 7 )
        {
          sub_806E004(v11);
        }
        else if ( dword_8202A68 )
        {
          sub_806E004(v11);
        }
        else
        {
          sub_8077FFE(a2, "normal script cannot reference a function in a /# ... #/ comment");
        }
        return;
      }
    }
  }
  sub_806DF0E(v10);
  v18 = sub_807C0A8(v20, 0);
  sub_807C66A(&v4, v18);
  v23 = v4;
  v24 = v5;
  if ( !v5 )
  {
    v24 = 6;
    v23 = 0;
  }
  v17 = sub_807C0CC(v20, v23 + 2);
  v21 = dword_8202860;
  if ( dword_8202A68 )
    v22 = 12;
  else
    v22 = 7;
  sub_807C4C2(v17, &v21);
  ++v23;
  sub_807C45C(v18, &v23);
  sub_8076D92(a2, 0);
}
// 8202860: using guessed type int dword_8202860;
// 8202868: using guessed type int dword_8202868;
// 8202A44: using guessed type int dword_8202A44;
// 8202A48: using guessed type int dword_8202A48;
// 8202A68: using guessed type int dword_8202A68;

//----- (0806FE34) --------------------------------------------------------
void __cdecl sub_806FE34(_DWORD *a1, int a2)
{
  sub_806DAD8(21, 1, 0);
  sub_8076D92(a2, 3);
  sub_806FADC(a1, a2);
}

//----- (0806FE7E) --------------------------------------------------------
int __cdecl sub_806FE7E(int a1)
{
  int i; // [esp+14h] [ebp-4h]

  for ( i = 0; i < dword_8202A74; ++i )
  {
    if ( dword_8202A78[i] == a1 )
      return i;
  }
  if ( dword_8202A74 == 1024 )
    Com_Error(1, &byte_813ED81);
  dword_8202A78[dword_8202A74++] = a1;
  return i;
}
// 8202A74: using guessed type int dword_8202A74;

//----- (0806FEF6) --------------------------------------------------------
void __cdecl sub_806FEF6(_DWORD *a1, int a2, char a3, int a4)
{
  if ( a3 )
    sub_806DAD8(82, -a2 - 1, 3);
  else
    sub_806DAD8(80, -a2, 3);
  sub_8076D92(a4, 3);
  sub_806FADC(a1, a4);
}

//----- (0806FF6C) --------------------------------------------------------
void __cdecl sub_806FF6C(int a1, int a2, char a3, int a4, int a5, int a6)
{
  sub_8071B6C((_DWORD *)a1, a6);
  if ( a3 )
    sub_806DAD8(83, -a2 - 2, 3);
  else
    sub_806DAD8(81, -a2 - 1, 3);
  sub_8076D92(a5, 0);
  sub_8076D92(a4, 1);
}

//----- (0806FFF8) --------------------------------------------------------
int __cdecl sub_806FFF8(_DWORD *a1, int a2, char a3, int a4)
{
  if ( a3 )
    sub_806DAD8(86, -a2, 2);
  else
    sub_806DAD8(84, 1 - a2, 2);
  sub_8076D92(a4, 3);
  sub_806FADC(a1, a4);
  return sub_806DF0E(a2);
}

//----- (0807007C) --------------------------------------------------------
int __cdecl sub_807007C(int a1, int a2, char a3, int a4, int a5)
{
  sub_8071B6C((_DWORD *)a1, a5);
  if ( a3 )
    sub_806DAD8(87, -a2 - 1, 2);
  else
    sub_806DAD8(85, -a2, 2);
  sub_8076D92(a4, 1);
  return sub_806DF0E(a2);
}

//----- (080700FE) --------------------------------------------------------
void __cdecl sub_80700FE(_DWORD *a1, int a2, char a3, int a4, int a5)
{
  if ( *a1 == 18 )
  {
    sub_806FEF6((_DWORD *)a1[1], a2, a3, a4);
  }
  else if ( *a1 == 22 )
  {
    sub_806FF6C(a1[1], a2, a3, a4, a1[2], a5);
  }
}

//----- (08070184) --------------------------------------------------------
void __cdecl sub_8070184(_DWORD *a1, int a2, char a3, int a4, int a5, int a6)
{
  if ( *a1 == 18 )
  {
    sub_806FFF8((_DWORD *)a1[1], a2, a3, a5);
  }
  else if ( *a1 == 22 )
  {
    sub_807007C(a1[1], a2, a3, a1[2], a6);
  }
  sub_8076D92(a4, 0);
}

//----- (08070216) --------------------------------------------------------
int __cdecl sub_8070216(_DWORD *a1)
{
  int result; // eax

  result = (int)a1;
  if ( *a1 == 26 )
    result = sub_806DAD8(78, 1, 0);
  return result;
}

//----- (08070242) --------------------------------------------------------
void __cdecl sub_8070242(int a1, int a2, char a3, int a4)
{
  if ( *(_DWORD *)a1 == 26 )
  {
    sub_80700FE(*(_DWORD **)(a1 + 4), a2, a3, *(_DWORD *)(a1 + 8), a4);
  }
  else if ( *(_DWORD *)a1 == 30 )
  {
    sub_8070184(*(_DWORD **)(a1 + 4), a2, a3, *(_DWORD *)(a1 + 8), *(_DWORD *)(a1 + 12), a4);
  }
}

//----- (080702D8) --------------------------------------------------------
int __cdecl sub_80702D8(_DWORD *a1)
{
  _DWORD *v3; // [esp+20h] [ebp+8h]
  _DWORD *v4; // [esp+20h] [ebp+8h]

  if ( *a1 != 26 )
    return 0;
  v3 = (_DWORD *)a1[1];
  if ( *v3 != 18 )
    return 0;
  v4 = (_DWORD *)v3[1];
  if ( *v4 != 20 )
    return 0;
  if ( sub_807BB34(dword_8202868, v4[1]) )
    return 0;
  return v4[1];
}
// 8202868: using guessed type int dword_8202868;

//----- (0807035E) --------------------------------------------------------
_DWORD *__cdecl sub_807035E(_DWORD *a1, unsigned int *a2)
{
  _DWORD *result; // eax

  if ( dword_8202A68 )
  {
    result = a1;
    *a1 = 0;
  }
  else
  {
    if ( byte_839400B )
    {
      dword_8202A68 = 1;
    }
    else
    {
      *a2 = sub_8079C94(0);
      dword_8202A68 = 2;
    }
    result = a1;
    *a1 = 1;
  }
  return result;
}
// 8202A68: using guessed type int dword_8202A68;
// 839400B: using guessed type char byte_839400B;

//----- (080703B6) --------------------------------------------------------
unsigned int __cdecl sub_80703B6(int a1, int *a2)
{
  unsigned int result; // eax

  if ( a1 == 1 )
  {
    dword_8202A68 = 0;
    if ( !byte_839400B )
      result = sub_8079CF0(*a2);
  }
  return result;
}
// 8202A68: using guessed type int dword_8202A68;
// 839400B: using guessed type char byte_839400B;

//----- (080703E6) --------------------------------------------------------
signed int __cdecl sub_80703E6(int a1)
{
  signed int v2; // [esp+0h] [ebp-4h]

  if ( a1 )
    v2 = 12;
  else
    v2 = 7;
  return v2;
}

//----- (0807040A) --------------------------------------------------------
_BOOL4 __cdecl sub_807040A(int a1)
{
  return a1 != 7;
}

//----- (08070430) --------------------------------------------------------
void __cdecl sub_8070430(signed int a1, int a2)
{
  int v2; // [esp+14h] [ebp-4h]

  if ( a1 > 5 )
  {
    v2 = 68;
    sub_806DAD8(68, 1 - a1, 1);
  }
  else
  {
    v2 = a1 + 62;
    sub_806DAD8(a1 + 62, 1 - a1, 1);
  }
  sub_8076D92(a2, 1);
  if ( v2 == 68 )
    sub_806DF8E(a1);
}

//----- (08070496) --------------------------------------------------------
void __cdecl sub_8070496(signed int a1, int a2)
{
  int v2; // [esp+14h] [ebp-4h]

  if ( a1 > 5 )
  {
    v2 = 75;
    sub_806DAD8(75, -a1, 1);
  }
  else
  {
    v2 = a1 + 69;
    sub_806DAD8(a1 + 69, -a1, 1);
  }
  sub_8076D92(a2, 1);
  if ( v2 == 75 )
    sub_806DF8E(a1);
}

//----- (080704FA) --------------------------------------------------------
unsigned int __cdecl sub_80704FA(_DWORD *a1, int *a2, char a3, int a4)
{
  unsigned int result; // eax
  unsigned __int16 v5; // ax
  int v6; // [esp+10h] [ebp-38h]
  int v7; // [esp+14h] [ebp-34h]
  int v8; // [esp+18h] [ebp-30h]
  int v9; // [esp+1Ch] [ebp-2Ch]
  int v10; // [esp+24h] [ebp-24h]
  unsigned int v11; // [esp+28h] [ebp-20h]
  int v12; // [esp+2Ch] [ebp-1Ch]
  int v13; // [esp+30h] [ebp-18h]
  int v14; // [esp+34h] [ebp-14h]
  int v15; // [esp+38h] [ebp-10h]
  int v16; // [esp+3Ch] [ebp-Ch]
  int v17; // [esp+40h] [ebp-8h]
  char v18; // [esp+47h] [ebp-1h]

  v18 = a3;
  v16 = sub_80702D8(a1);
  if ( !v16 )
    goto LABEL_19;
  v14 = sub_8078896(v16);
  v15 = a1[2];
  v10 = sub_807BB34(dword_8202A50, v16);
  if ( v10 )
  {
    sub_807C66A(&v6, v10);
    v8 = v6;
    v9 = v7;
    v13 = sub_807040A(v7);
    v12 = v8;
  }
  else
  {
    v13 = 0;
    v12 = sub_8115824((char **)&v14, &v13);
    v10 = sub_807C0CC(dword_8202A50, v16);
    v9 = sub_80703E6(v13);
    v8 = v12;
    sub_807C45C(v10, &v8);
  }
  if ( v12 )
  {
    if ( v13 != 1 || (sub_807035E(&v13, &v11), v13 != 1) || v18 )
    {
      v17 = sub_806F9A0(a2, a4);
      if ( v17 <= 255 )
      {
        sub_806D9EC(v16);
        sub_8070430(v17, v15);
        v5 = sub_806FE7E(v12);
        sub_806DF60(v5);
        sub_806FA26(a2);
        if ( v18 )
          sub_806F6FE();
        result = sub_80703B6(v13, (int *)&v11);
      }
      else
      {
        result = (unsigned int)sub_8077FFE(v15, "parameter count exceeds 256");
      }
    }
    else
    {
      result = (unsigned int)sub_8077FFE(
                               v15,
                               "return value of developer command can not be accessed if not in a /# ... #/ comment");
    }
  }
  else
  {
LABEL_19:
    sub_8070216(a1);
    v17 = sub_806F9A0(a2, a4);
    sub_8070242((int)a1, v17, 0, a4);
    result = (unsigned int)sub_806FA26(a2);
    if ( v18 )
      result = sub_806F6FE();
  }
  return result;
}
// 8202A50: using guessed type int dword_8202A50;

//----- (0807071E) --------------------------------------------------------
unsigned int __cdecl sub_807071E(int a1, _DWORD *a2, _DWORD *a3, int a4, char a5, int a6)
{
  unsigned int result; // eax
  unsigned __int16 v7; // ax
  int (__cdecl *v8)(__int16); // [esp+10h] [ebp-38h]
  int v9; // [esp+14h] [ebp-34h]
  int (__cdecl *v10)(__int16); // [esp+18h] [ebp-30h]
  int v11; // [esp+1Ch] [ebp-2Ch]
  int v12; // [esp+24h] [ebp-24h]
  unsigned int v13; // [esp+28h] [ebp-20h]
  int (__cdecl *v14)(__int16); // [esp+2Ch] [ebp-1Ch]
  int v15; // [esp+30h] [ebp-18h]
  int v16; // [esp+34h] [ebp-14h]
  int v17; // [esp+38h] [ebp-10h]
  int v18; // [esp+3Ch] [ebp-Ch]
  int v19; // [esp+40h] [ebp-8h]
  char v20; // [esp+47h] [ebp-1h]

  v20 = a5;
  v18 = sub_80702D8(a2);
  if ( !v18 )
    goto LABEL_19;
  v16 = sub_8078896(v18);
  v17 = a2[2];
  v12 = sub_807BB34(dword_8202A54, v18);
  if ( v12 )
  {
    sub_807C66A((int *)&v8, v12);
    v10 = v8;
    v11 = v9;
    v15 = sub_807040A(v9);
    v14 = v10;
  }
  else
  {
    v15 = 0;
    v14 = sub_811595C((char **)&v16, &v15);
    v12 = sub_807C0CC(dword_8202A54, v18);
    v11 = sub_80703E6(v15);
    v10 = v14;
    sub_807C45C(v12, (int *)&v10);
  }
  if ( v14 )
  {
    if ( v15 != 1 || (sub_807035E(&v15, &v13), v15 != 1) || v20 )
    {
      v19 = sub_806F9A0(a3, a6);
      sub_8071552(a1, a6);
      if ( v19 <= 255 )
      {
        sub_806D9EC(v18);
        sub_8070496(v19, v17);
        v7 = sub_806FE7E((int)v14);
        sub_806DF60(v7);
        sub_8076D92(a4, 0);
        sub_806FA26(a3);
        if ( v20 )
          sub_806F6FE();
        result = sub_80703B6(v15, (int *)&v13);
      }
      else
      {
        result = (unsigned int)sub_8077FFE(v17, "parameter count exceeds 256");
      }
    }
    else
    {
      result = (unsigned int)sub_8077FFE(
                               v17,
                               "return value of developer command can not be accessed if not in a /# ... #/ comment");
    }
  }
  else
  {
LABEL_19:
    sub_8070216(a2);
    v19 = sub_806F9A0(a3, a6);
    sub_8071552(a1, a6);
    sub_8070242((int)a2, v19, 1, a6);
    sub_8076D92(a4, 0);
    result = (unsigned int)sub_806FA26(a3);
    if ( v20 )
      result = sub_806F6FE();
  }
  return result;
}
// 8202A54: using guessed type int dword_8202A54;

//----- (0807098C) --------------------------------------------------------
int __cdecl sub_807098C(int a1, _DWORD *a2, char a3)
{
  int result; // eax
  int v4; // [esp+8h] [ebp-30h]
  int v5; // [esp+Ch] [ebp-2Ch]
  int v6; // [esp+14h] [ebp-24h]
  int i; // [esp+18h] [ebp-20h]
  int v8; // [esp+1Ch] [ebp-1Ch]
  __int16 *v9; // [esp+20h] [ebp-18h]
  int v10; // [esp+24h] [ebp-14h]
  int v11; // [esp+28h] [ebp-10h]
  int v12; // [esp+2Ch] [ebp-Ch]
  char v13; // [esp+37h] [ebp-1h]

  v13 = a3;
  result = sub_807BB34(a1, 0);
  v10 = result;
  if ( result )
  {
    sub_807C66A(&v4, v10);
    v11 = v4;
    v12 = v5;
    for ( i = 0; ; ++i )
    {
      result = i;
      if ( i >= v11 )
        break;
      v8 = sub_807BB34(a1, i + 2);
      v9 = sub_807C4FC(v8);
      v6 = sub_807DF7C(v8);
      if ( a2[1] == 12 && v6 == 7 )
        sub_80780F6(*(_DWORD *)v9, "normal script cannot reference a function in a /# ... #/ comment");
      if ( !a2[1] )
        sub_80780F6(*(_DWORD *)v9, "unknown function");
      if ( !v13 && **(_DWORD **)v9 == 1 )
        sub_80780F6(*(_DWORD *)v9, "unknown function");
      **(_DWORD **)v9 = *a2;
    }
  }
  return result;
}

//----- (08070AA8) --------------------------------------------------------
int __cdecl sub_8070AA8(int a1)
{
  int result; // eax
  int v2; // [esp+10h] [ebp-28h]
  int v3; // [esp+14h] [ebp-24h]
  int v4; // [esp+18h] [ebp-20h]
  int v5; // [esp+1Ch] [ebp-1Ch]
  int v6; // [esp+20h] [ebp-18h]
  int v7; // [esp+24h] [ebp-14h]
  int v8; // [esp+2Ch] [ebp-Ch]
  int v9; // [esp+30h] [ebp-8h]
  int i; // [esp+34h] [ebp-4h]

  v5 = 0;
  v4 = 0;
  result = sub_807C9CE(a1);
  for ( i = result; i; i = result )
  {
    v9 = sub_807CB1E(i);
    v8 = sub_807BB34(v9, 1);
    if ( v8 )
    {
      sub_807C66A(&v2, v8);
      v6 = v2;
      v7 = v3;
      if ( v3 == 13 )
        sub_807C45C(i, &v4);
      else
        sub_807098C(v9, &v6, 1);
    }
    else
    {
      sub_807098C(v9, &v4, 1);
    }
    result = sub_807C9CE(i);
  }
  return result;
}

//----- (08070B86) --------------------------------------------------------
int __cdecl sub_8070B86(int a1, int a2, int a3, int a4)
{
  int v4; // eax
  int v5; // eax
  int v7; // [esp+1Ch] [ebp-1Ch]
  unsigned int v8; // [esp+20h] [ebp-18h]
  int v9; // [esp+24h] [ebp-14h]
  int v10; // [esp+28h] [ebp-10h]
  int v11; // [esp+2Ch] [ebp-Ch]
  unsigned int v12; // [esp+30h] [ebp-8h]
  int v13; // [esp+34h] [ebp-4h]

  v11 = sub_807C0A8(a1, 1u);
  sub_807C66A((int *)&v8, v11);
  v12 = v8;
  v13 = v9;
  if ( v9 )
  {
    if ( v12 )
    {
      v10 = sub_8077D5A(v12);
      v4 = sub_8078896(a2);
      sub_8077FFE(a3, "function '%s' already defined in '%s'", v4, *((_DWORD *)dword_8283ED4 + 6 * v10 + 1));
    }
    else
    {
      v5 = sub_8078896(a2);
      sub_8077FFE(a3, "function '%s' already defined", v5);
    }
    v7 = 0;
  }
  else
  {
    v13 = a4;
    v12 = 0;
    sub_807C4C2(v11, (int *)&v12);
    v7 = v11;
  }
  return v7;
}

//----- (08070C7A) --------------------------------------------------------
unsigned int __cdecl sub_8070C7A(int a1)
{
  int v1; // eax
  __int16 *v2; // ebx
  unsigned int result; // eax

  v1 = sub_807BB34(a1, 1);
  v2 = sub_807C4FC(v1);
  result = sub_8079C94(0);
  *(_DWORD *)v2 = result;
  return result;
}

//----- (08070CB2) --------------------------------------------------------
unsigned int __cdecl sub_8070CB2(int a1, unsigned __int8 a2, int a3)
{
  unsigned int result; // eax

  result = *(_DWORD *)a1;
  if ( *(_DWORD *)a1 == 23 )
    return sub_80704FA(*(_DWORD **)(a1 + 4), *(int **)(a1 + 8), a2, a3);
  if ( *(_DWORD *)a1 == 24 )
    result = sub_807071E(*(_DWORD *)(a1 + 4), *(_DWORD **)(a1 + 8), *(_DWORD **)(a1 + 12), *(_DWORD *)(a1 + 16), a2, a3);
  return result;
}

//----- (08070D46) --------------------------------------------------------
void __cdecl sub_8070D46(int a1, int a2)
{
  if ( *(_DWORD *)a1 == 23 )
  {
    sub_80704FA(*(_DWORD **)(a1 + 4), *(int **)(a1 + 8), 0, a2);
    sub_806F722(*(_DWORD *)(a1 + 12));
  }
  else if ( *(_DWORD *)a1 == 24 )
  {
    sub_807071E(*(_DWORD *)(a1 + 4), *(_DWORD **)(a1 + 8), *(_DWORD **)(a1 + 12), *(_DWORD *)(a1 + 16), 0, a2);
    sub_806F722(*(_DWORD *)(a1 + 20));
  }
}

//----- (08070DF8) --------------------------------------------------------
char *__cdecl sub_8070DF8(int a1, char **a2)
{
  char *result; // eax
  int v3; // [esp+18h] [ebp-20h]
  signed int i; // [esp+1Ch] [ebp-1Ch]
  int v5[6]; // [esp+20h] [ebp-18h]

  for ( i = 0; i <= 2; ++i )
  {
    v3 = *(_DWORD *)(a1 + 12 * i + 4);
    if ( v3 == 5 )
    {
      v5[2 - i] = *(_DWORD *)(a1 + 12 * i);
    }
    else
    {
      if ( v3 != 6 )
        return sub_8077FFE(*(_DWORD *)(a1 + 12 * i + 8), "type %s is not a float", *(_DWORD *)&off_815ABC0[4 * v3]);
      *(float *)&v5[2 - i] = (long double)*(signed int *)(a1 + 12 * i);
    }
  }
  a2[1] = (char *)4;
  result = (char *)sub_807B968(v5);
  *a2 = result;
  return result;
}
// 8070DF8: using guessed type int var_18[6];

//----- (08070EE4) --------------------------------------------------------
signed int __cdecl sub_8070EE4(int *a1, int a2, int a3)
{
  char v5[52]; // [esp+20h] [ebp-48h]
  int v6; // [esp+54h] [ebp-14h]
  int i; // [esp+58h] [ebp-10h]
  int v8; // [esp+5Ch] [ebp-Ch]

  v8 = sub_806F96C(a1);
  if ( v8 == 1 )
    return (unsigned __int8)sub_807194E(**(_DWORD ***)*a1, (_DWORD *)a3);
  if ( v8 != 3 )
    return 0;
  v6 = 0;
  for ( i = *a1; i; i = *(_DWORD *)(i + 4) )
  {
    if ( (unsigned __int8)sub_807194E(**(_DWORD ***)i, &v5[12 * v6]) ^ 1 )
      return 0;
    ++v6;
  }
  sub_8070DF8((int)v5, (char **)a3);
  *(_DWORD *)(a3 + 8) = a2;
  return 1;
}
// 8070EE4: using guessed type char var_48[52];

//----- (08070FC0) --------------------------------------------------------
signed int __cdecl sub_8070FC0(int *a1, int a2, int a3, int a4)
{
  signed int v5; // [esp+1Ch] [ebp-2Ch]
  int v6[5]; // [esp+20h] [ebp-28h]
  char v7; // [esp+37h] [ebp-11h]
  _DWORD ***i; // [esp+38h] [ebp-10h]
  int v9; // [esp+3Ch] [ebp-Ch]

  v9 = sub_806F96C(a1);
  if ( v9 == 1 )
    return (unsigned __int8)sub_80719D8(**(_DWORD ***)*a1, (_DWORD *)a3, a4);
  if ( v9 == 3 )
  {
    v7 = 1;
    for ( i = (_DWORD ***)*a1; i; i = (_DWORD ***)i[1] )
    {
      if ( v7 )
      {
        v7 = sub_80719D8(**i, v6, a4);
        if ( v7 )
          sub_806EEC6(v6);
      }
      else
      {
        sub_8071B6C(**i, a4);
      }
    }
    if ( v7 )
    {
      dword_8202A40 -= 3;
      sub_8070DF8(12 * dword_8202A40 + 136325308, (char **)a3);
      *(_DWORD *)(a3 + 8) = a2;
      v5 = 1;
    }
    else
    {
      sub_806DAD8(126, -2, 0);
      sub_8076D92(a2, 1);
      sub_806FA26(a1);
      v5 = 0;
    }
  }
  else
  {
    sub_8077FFE(a2, "expression list must have 1 or 3 parameters");
    v5 = 0;
  }
  return v5;
}
// 8202A40: using guessed type int dword_8202A40;

//----- (0807112A) --------------------------------------------------------
void __cdecl sub_807112A(int a1, int a2, int a3)
{
  _DWORD ***v3; // [esp+14h] [ebp-4h]

  v3 = (_DWORD ***)sub_806F9EA(a1);
  if ( v3 )
    sub_8071E6A(**v3, (int)(*v3)[1], a3);
  else
    sub_8077FFE(a2, "not an object");
}

//----- (08071180) --------------------------------------------------------
signed int __cdecl sub_8071180(_DWORD *a1, _DWORD *a2)
{
  signed int v3; // [esp+14h] [ebp-4h]

  switch ( *a1 )
  {
    case 7:
      sub_806E07A(a1[1], a1[2], a2);
      v3 = 1;
      break;
    case 8:
      sub_806E250(a1[1], a1[2], a2);
      v3 = 1;
      break;
    case 9:
      sub_806E07A(-a1[1], a1[2], a2);
      v3 = 1;
      break;
    case 0xA:
      sub_806E250(a1[1] ^ 0x80000000, a1[2], a2);
      v3 = 1;
      break;
    case 0xB:
      sub_806ECA0(a1[1], a1[2], a2);
      v3 = 1;
      break;
    case 0xC:
      sub_806ED18(a1[1], a1[2], a2);
      v3 = 1;
      break;
    case 0x1F:
      sub_806E028(a1[1], (int)a2);
      v3 = 1;
      break;
    case 0x2E:
      v3 = (unsigned __int8)sub_8070EE4((int *)a1[1], a1[2], (int)a2);
      break;
    case 0x48:
      sub_806E07A(0, a1[1], a2);
      v3 = 1;
      break;
    case 0x49:
      sub_806E07A(1, a1[1], a2);
      v3 = 1;
      break;
    default:
      v3 = 0;
      break;
  }
  return v3;
}

//----- (08071370) --------------------------------------------------------
int __cdecl sub_8071370(_DWORD *a1, _DWORD *a2, int a3)
{
  int v4; // [esp+14h] [ebp-4h]

  switch ( *a1 )
  {
    case 0x11:
      sub_806F83E((signed int *)a1[1], a3);
      v4 = 0;
      break;
    case 0x12:
      sub_806FE34((_DWORD *)a1[1], a1[2]);
      v4 = 0;
      break;
    case 0x13:
      sub_8070CB2(a1[1], 0, a3);
      v4 = 0;
      break;
    case 0x20:
      sub_806F024(a1[1]);
      v4 = 0;
      break;
    case 0x22:
      sub_806F05C(a1[1]);
      v4 = 0;
      break;
    case 0x23:
      sub_806F094(a1[1]);
      v4 = 0;
      break;
    case 0x24:
      sub_806F0CC(a1[1]);
      v4 = 0;
      break;
    case 0x2E:
      v4 = (unsigned __int8)sub_8070FC0((int *)a1[1], a1[2], (int)a2, a3);
      break;
    case 0x34:
      sub_806EFDA(a1[1], a1[2], a3);
      v4 = 0;
      break;
    case 0x42:
      sub_806F3EA(a1[1]);
      v4 = 0;
      break;
    case 0x43:
      sub_806F422(a1[1], a1[2]);
      v4 = 0;
      break;
    case 0x4A:
      sub_806E2B4(a1[1]);
      v4 = 0;
      break;
    default:
      v4 = (unsigned __int8)sub_8071180(a1, a2);
      break;
  }
  return v4;
}

//----- (08071552) --------------------------------------------------------
void __cdecl sub_8071552(int a1, int a2)
{
  int v2[6]; // [esp+10h] [ebp-18h]

  if ( !((unsigned __int8)sub_8071370((_DWORD *)a1, v2, a2) ^ 1) )
    sub_806EE00(v2);
}

//----- (08071586) --------------------------------------------------------
unsigned int __cdecl sub_8071586(int a1, int a2, int a3, int a4, int a5)
{
  _WORD *v5; // ST14_4
  unsigned int v6; // ST10_4
  unsigned int result; // eax

  sub_8071B6C((_DWORD *)a1, a5);
  sub_806DAD8(97, -1, 0);
  sub_8076D92(a3, 0);
  sub_806DF60(0);
  v5 = (_WORD *)dword_8202860;
  v6 = sub_8079C94(0);
  sub_8071B6C((_DWORD *)a2, a5);
  sub_806EF32(a4);
  result = sub_8079C94(0) - v6;
  *v5 = result;
  return result;
}
// 8202860: using guessed type int dword_8202860;

//----- (0807162A) --------------------------------------------------------
unsigned int __cdecl sub_807162A(int a1, int a2, int a3, int a4, int a5)
{
  _WORD *v5; // ST14_4
  unsigned int v6; // ST10_4
  unsigned int result; // eax

  sub_8071B6C((_DWORD *)a1, a5);
  sub_806DAD8(96, -1, 0);
  sub_8076D92(a3, 0);
  sub_806DF60(0);
  v5 = (_WORD *)dword_8202860;
  v6 = sub_8079C94(0);
  sub_8071B6C((_DWORD *)a2, a5);
  sub_806EF32(a4);
  result = sub_8079C94(0) - v6;
  *v5 = result;
  return result;
}
// 8202860: using guessed type int dword_8202860;

//----- (080716CE) --------------------------------------------------------
signed int __cdecl sub_80716CE(int a1, int a2, int a3, int a4, _DWORD *a5)
{
  int v5; // edx
  signed int v7; // [esp+1Ch] [ebp-2Ch]
  int v8[4]; // [esp+20h] [ebp-28h]
  int v9; // [esp+30h] [ebp-18h]
  int v10; // [esp+34h] [ebp-14h]

  if ( (unsigned __int8)sub_807194E((_DWORD *)a1, &v9) ^ 1 )
    return 0;
  if ( (unsigned __int8)sub_807194E((_DWORD *)a2, v8) ^ 1 )
    return 0;
  sub_807578C(&v9);
  sub_807578C(v8);
  sub_807DDD2(a3, &v9, v8);
  if ( *(_DWORD *)dword_8394010 )
  {
    sub_8077FFE(a4, "%s", *(_DWORD *)dword_8394010);
    v7 = 0;
  }
  else
  {
    v5 = v10;
    *a5 = v9;
    a5[1] = v5;
    a5[2] = a4;
    v7 = 1;
  }
  return v7;
}

//----- (0807179C) --------------------------------------------------------
signed int __cdecl sub_807179C(int a1, int a2, int a3, int a4, _DWORD *a5, int a6)
{
  int v6; // edx
  signed int v8; // [esp+1Ch] [ebp-2Ch]
  int v9[4]; // [esp+20h] [ebp-28h]
  int v10; // [esp+30h] [ebp-18h]
  int v11; // [esp+34h] [ebp-14h]

  if ( (unsigned __int8)sub_80719D8((_DWORD *)a1, &v10, a6) ^ 1 )
  {
    sub_8071B6C((_DWORD *)a2, a6);
LABEL_7:
    sub_806DAD8((char)a3, -1, 0);
    sub_8076D92(a4, 0);
    return 0;
  }
  sub_806EEC6(&v10);
  if ( (unsigned __int8)sub_80719D8((_DWORD *)a2, v9, a6) ^ 1 )
    goto LABEL_7;
  sub_806EF26();
  sub_807DDD2(a3, &v10, v9);
  if ( *(_DWORD *)dword_8394010 )
  {
    sub_8077FFE(a4, "%s", *(_DWORD *)dword_8394010);
    v8 = 0;
  }
  else
  {
    v6 = v11;
    *a5 = v10;
    a5[1] = v6;
    a5[2] = a4;
    v8 = 1;
  }
  return v8;
}

//----- (080718AE) --------------------------------------------------------
void __cdecl sub_80718AE(signed int *a1, _DWORD *a2, char a3, int a4, int a5)
{
  byte_820287C = 1;
  sub_806F83E(a1, a5);
  byte_820287C = 0;
  sub_8071B6C(a2, a5);
  sub_806DAD8(a3, -1, 0);
  sub_8076D92(a4, 0);
  sub_8071BA0(a1, a5);
  sub_806E2EE(a4);
}
// 820287C: using guessed type char byte_820287C;

//----- (08071934) --------------------------------------------------------
_DWORD *__cdecl sub_8071934(int a1, _DWORD *a2)
{
  return sub_8071CB0(a1, a2);
}

//----- (0807194E) --------------------------------------------------------
int __cdecl sub_807194E(_DWORD *a1, _DWORD *a2)
{
  if ( *a1 == 6 )
    return (unsigned __int8)sub_8071180((_DWORD *)a1[1], a2);
  if ( *a1 == 49 )
    return (unsigned __int8)sub_80716CE(a1[1], a1[2], a1[3], a1[4], a2);
  return 0;
}

//----- (080719D8) --------------------------------------------------------
int __cdecl sub_80719D8(_DWORD *a1, _DWORD *a2, int a3)
{
  int v4; // [esp+24h] [ebp-4h]

  switch ( *a1 )
  {
    case 6:
      v4 = (unsigned __int8)sub_8071370((_DWORD *)a1[1], a2, a3);
      break;
    case 0x2F:
      sub_8071586(a1[1], a1[2], a1[3], a1[4], a3);
      v4 = 0;
      break;
    case 0x30:
      sub_807162A(a1[1], a1[2], a1[3], a1[4], a3);
      v4 = 0;
      break;
    case 0x31:
      v4 = (unsigned __int8)sub_807179C(a1[1], a1[2], a1[3], a1[4], a2, a3);
      break;
    case 0x32:
      sub_8071B6C((_DWORD *)a1[1], a3);
      sub_806EF6A(a1[2]);
      v4 = 0;
      break;
    case 0x33:
      sub_8071B6C((_DWORD *)a1[1], a3);
      sub_806EFA2(a1[2]);
      v4 = 0;
      break;
    default:
      v4 = 0;
      break;
  }
  return v4;
}

//----- (08071B6C) --------------------------------------------------------
void __cdecl sub_8071B6C(_DWORD *a1, int a2)
{
  int v2[6]; // [esp+10h] [ebp-18h]

  if ( !((unsigned __int8)sub_80719D8(a1, v2, a2) ^ 1) )
    sub_806EE00(v2);
}

//----- (08071BA0) --------------------------------------------------------
void __cdecl sub_8071BA0(signed int *a1, int a2)
{
  signed int v2; // [esp+20h] [ebp-8h]

  v2 = *a1;
  if ( *a1 == 15 )
  {
    sub_806F4E8((_DWORD *)a1[1], a1[2], a1[3], a2);
  }
  else if ( v2 > 15 )
  {
    if ( v2 == 53 || v2 == 79 )
    {
      if ( byte_8202A64 )
        sub_8077FFE(a1[2], "$ and self field can only be used in the script debugger");
      else
        sub_8077FFE(a1[2], "not an lvalue");
    }
  }
  else if ( v2 == 4 )
  {
    sub_806F230(a1[1], a1[2], a2);
  }
  else if ( v2 == 13 )
  {
    sub_806F798((_DWORD *)a1[1], (_DWORD *)a1[2], a1[3], a1[4], a2);
  }
}
// 8202A64: using guessed type char byte_8202A64;

//----- (08071CB0) --------------------------------------------------------
_DWORD *__cdecl sub_8071CB0(int a1, _DWORD *a2)
{
  _DWORD *result; // eax

  result = *(_DWORD **)a1;
  if ( *(_DWORD *)a1 == 4 )
    return sub_806F2B2(*(_DWORD **)(a1 + 4), *(_DWORD *)(a1 + 8), a2);
  if ( *(_DWORD *)a1 == 13 )
    result = sub_806F7DE(*(int **)(a1 + 4), (int)a2);
  return result;
}

//----- (08071D0A) --------------------------------------------------------
void __cdecl sub_8071D0A(_DWORD *a1, int a2, int a3)
{
  if ( *a1 == 17 )
  {
    sub_8071BA0((signed int *)a1[1], a3);
  }
  else if ( *a1 == 35 )
  {
    sub_806F2D4(a1[1]);
  }
  else
  {
    sub_8077FFE(a2, "not an lvalue");
  }
}

//----- (08071D66) --------------------------------------------------------
_DWORD *__cdecl sub_8071D66(int *a1, int a2)
{
  _DWORD *result; // eax

  result = (_DWORD *)*a1;
  if ( *a1 == 17 )
    result = sub_8071CB0(a1[1], (_DWORD *)a2);
  return result;
}

//----- (08071D92) --------------------------------------------------------
void __cdecl sub_8071D92(_DWORD *a1, int a2, int a3)
{
  switch ( *a1 )
  {
    case 0x11:
      sub_806F83E((signed int *)a1[1], a3);
      sub_806F722(a1[2]);
      break;
    case 0x13:
      sub_8070D46(a1[1], a3);
      break;
    case 0x20:
      sub_806F104(a1[1]);
      break;
    case 0x22:
      sub_806F13C(a1[1]);
      break;
    case 0x24:
      sub_806F174(a1[1]);
      break;
    case 0x2E:
      sub_807112A(a1[1], a2, a3);
      break;
    default:
      sub_8077FFE(a2, "not an object");
      break;
  }
}

//----- (08071E6A) --------------------------------------------------------
void __cdecl sub_8071E6A(_DWORD *a1, int a2, int a3)
{
  if ( *a1 == 6 )
    sub_8071D92((_DWORD *)a1[1], a1[2], a3);
  else
    sub_8077FFE(a2, "not an object");
}

//----- (08071EB6) --------------------------------------------------------
int sub_8071EB6()
{
  int result; // eax
  int i; // [esp+10h] [ebp-8h]
  unsigned int v2; // [esp+14h] [ebp-4h]

  v2 = sub_8079C94(0);
  result = dword_8202890;
  for ( i = dword_8202890; i; i = *(_DWORD *)(i + 8) )
  {
    **(_DWORD **)i = v2 - *(_DWORD *)(i + 4);
    result = *(_DWORD *)(i + 8);
  }
  return result;
}
// 8202890: using guessed type int dword_8202890;

//----- (08071EFA) --------------------------------------------------------
int sub_8071EFA()
{
  int result; // eax
  int i; // [esp+10h] [ebp-8h]
  unsigned int v2; // [esp+14h] [ebp-4h]

  v2 = sub_8079C94(0);
  result = dword_8202898;
  for ( i = dword_8202898; i; i = *(_DWORD *)(i + 8) )
  {
    **(_DWORD **)i = v2 - *(_DWORD *)(i + 4);
    result = *(_DWORD *)(i + 8);
  }
  return result;
}
// 8202898: using guessed type int dword_8202898;

//----- (08071F3E) --------------------------------------------------------
_BOOL4 __cdecl sub_8071F3E(_DWORD *a1)
{
  return *a1 == 31;
}

//----- (08071F50) --------------------------------------------------------
signed int __cdecl sub_8071F50(int a1)
{
  signed int v2; // [esp+4h] [ebp-4h]

  v2 = 0;
  if ( *(_DWORD *)a1 == 6 && (unsigned __int8)sub_8071F3E(*(_DWORD **)(a1 + 4)) )
    v2 = 1;
  return v2;
}

//----- (08071F86) --------------------------------------------------------
signed int __cdecl sub_8071F86(int a1, int a2, int a3)
{
  signed int v4; // [esp+1Ch] [ebp-Ch]

  v4 = *(_DWORD *)a1;
  if ( *(_DWORD *)a1 == 15 )
  {
    sub_806F530(*(_DWORD **)(a1 + 4), *(_DWORD *)(a1 + 8), *(_DWORD *)(a1 + 12), a2, a3);
    return 1;
  }
  if ( v4 > 15 )
  {
    if ( v4 == 53 || v4 == 79 )
    {
      if ( byte_8202A64 )
        sub_8077FFE(*(_DWORD *)(a1 + 8), "$ and self field can only be used in the script debugger");
      else
        sub_8077FFE(*(_DWORD *)(a1 + 8), "not an lvalue");
    }
    return 1;
  }
  if ( v4 != 4 )
  {
    if ( v4 == 13 )
      sub_806F7F8(*(_DWORD **)(a1 + 4), *(_DWORD **)(a1 + 8), *(_DWORD *)(a1 + 12), *(_DWORD *)(a1 + 16), a3);
    return 1;
  }
  return 0;
}
// 8202A64: using guessed type char byte_8202A64;

//----- (08072088) --------------------------------------------------------
void __cdecl sub_8072088(signed int *a1, _DWORD *a2, int a3, int a4, int a5)
{
  if ( !(unsigned __int8)sub_8071F50((int)a2) || !(unsigned __int8)sub_8071F86((int)a1, a4, a5) )
  {
    sub_8071B6C(a2, a5);
    sub_8071BA0(a1, a5);
    sub_806E2EE(a3);
  }
}

//----- (080720EE) --------------------------------------------------------
_DWORD *__cdecl sub_80720EE(int a1, int a2, _DWORD *a3)
{
  return sub_8071CB0(a1, a3);
}

//----- (08072108) --------------------------------------------------------
unsigned int __cdecl sub_8072108(int a1, int a2)
{
  return sub_8070CB2(a1, 1u, a2);
}

//----- (0807212A) --------------------------------------------------------
void __cdecl sub_807212A(_DWORD *a1, int a2, _DWORD *a3)
{
  if ( !*a3 )
    *a3 = 3;
  sub_8071B6C(a1, (int)a3);
  sub_806DEEA();
  sub_8076D92(a2, 0);
}

//----- (0807216E) --------------------------------------------------------
void __cdecl sub_807216E(int a1, _DWORD *a2)
{
  if ( !*a2 )
    *a2 = 3;
  sub_806DEC6();
  sub_8076D92(a1, 1);
}

//----- (080721A0) --------------------------------------------------------
void __cdecl sub_80721A0(_DWORD *a1, int a2, int a3, int a4)
{
  sub_8071B6C(a1, a4);
  sub_806DAD8(76, -1, 0);
  sub_8076D92(a3, 0);
  sub_8076D92(a3, 0);
  sub_8076D92(a2, 0);
}

//----- (08072210) --------------------------------------------------------
void __cdecl sub_8072210(int a1)
{
  sub_806DAD8(77, 0, 0);
  sub_8076D92(a1, 1);
  sub_8076D92(a1, 0);
}

//----- (0807225A) --------------------------------------------------------
unsigned int __cdecl sub_807225A(_DWORD *a1, int a2, int a3, unsigned __int8 a4, int a5, int a6, _DWORD **a7)
{
  _WORD *v7; // ST20_4
  unsigned int v8; // ST1C_4
  unsigned int result; // eax

  sub_8071B6C(a1, a6);
  sub_806DAD8(94, -1, 0);
  sub_8076D92(a3, 0);
  sub_806DF60(0);
  v7 = (_WORD *)dword_8202860;
  v8 = sub_8079C94(0);
  sub_806EA5A(a6, *a7);
  sub_80742D2(a2, a4, a5, *a7);
  sub_806E59A(a4, a5, *a7);
  result = sub_8079C94(0) - v8;
  *v7 = result;
  return result;
}
// 8202860: using guessed type int dword_8202860;

//----- (0807233A) --------------------------------------------------------
void __cdecl sub_807233A(int a1, _DWORD *a2, size_t *a3)
{
  sub_806E69A(a2, a3);
  sub_8074842((size_t *)a1, (signed int *)*a3);
  sub_806E94E((int)a3, 1, a2);
}

//----- (08072382) --------------------------------------------------------
int __cdecl sub_8072382(_DWORD *a1, int a2, int a3, int a4, int a5, unsigned __int8 a6, int a7, int a8, int *a9, _DWORD **a10)
{
  __int16 v10; // ax
  _DWORD *v11; // ebx
  signed int v13; // [esp+1Ch] [ebp-2Ch]
  int v14[2]; // [esp+20h] [ebp-28h]
  int v15; // [esp+28h] [ebp-20h]
  unsigned int v16; // [esp+2Ch] [ebp-1Ch]
  unsigned int v17; // [esp+30h] [ebp-18h]
  _DWORD *v18; // [esp+34h] [ebp-14h]
  _WORD *v19; // [esp+38h] [ebp-10h]
  unsigned __int8 v20; // [esp+3Fh] [ebp-9h]

  v20 = a6;
  v13 = 0;
  sub_8071B6C(a1, a8);
  sub_806DAD8(94, -1, 0);
  sub_8076D92(a4, 0);
  sub_806DF60(0);
  v19 = (_WORD *)dword_8202860;
  v17 = sub_8079C94(0);
  sub_806EA5A(a8, (_DWORD *)*a9);
  sub_80742D2(a2, a6, a7, (_DWORD *)*a9);
  sub_806E53A((_DWORD *)*a9, *a9);
  if ( !*(_DWORD *)*a9 )
  {
    v14[0] = *a9;
    v13 = 1;
  }
  v15 = dword_839403C;
  if ( v20 )
  {
    sub_806DEC6();
    sub_806DF0E(0);
    sub_8076D92(a7, 1);
    v18 = 0;
    v16 = 0;
  }
  else
  {
    sub_806DAD8(98, 0, 0);
    sub_8076D92(a5, 1);
    sub_806DF0E(0);
    v18 = (_DWORD *)dword_8202860;
    v16 = sub_8079C94(0);
  }
  dword_839403C = v15 + 1;
  v10 = sub_8079C94(0);
  *v19 = v10 - v17;
  sub_806EA5A(a8, *a10);
  sub_80742D2(a3, v20, a7, *a10);
  sub_806E59A(v20, a7, *a10);
  if ( !**a10 )
    v14[v13++] = (int)*a10;
  if ( !v20 )
  {
    v11 = v18;
    *v11 = sub_8079C94(0) - v16;
  }
  return sub_806E714((int)v14, v13, a8);
}
// 8202860: using guessed type int dword_8202860;
// 839403C: using guessed type int dword_839403C;
// 8072382: using guessed type int var_28[2];

//----- (080725C2) --------------------------------------------------------
void __cdecl sub_80725C2(int a1, int a2, signed int *a3, size_t *a4, size_t *a5)
{
  signed int v5; // [esp+18h] [ebp-10h]
  signed int v6; // [esp+1Ch] [ebp-Ch]
  int v7[2]; // [esp+20h] [ebp-8h]

  v6 = 0;
  v5 = 3;
  sub_806E69A(a3, a4);
  sub_8074842((size_t *)a1, (signed int *)*a4);
  if ( *(_DWORD *)*a4 <= 3 )
  {
    v5 = *(_DWORD *)*a4;
    if ( !v5 )
    {
      v7[0] = *a4;
      v6 = 1;
    }
  }
  sub_806E69A(a3, a5);
  sub_8074842((size_t *)a2, (signed int *)*a5);
  if ( *(_DWORD *)*a5 <= v5 )
  {
    v5 = *(_DWORD *)*a5;
    if ( !v5 )
      v7[v6++] = *a5;
  }
  if ( !*a3 )
    *a3 = v5;
  sub_806E846((int)v7, v6, a3);
  sub_806E94E((int)v7, v6, a3);
}
// 80725C2: using guessed type int var_8[2];

//----- (080726C0) --------------------------------------------------------
_DWORD *__cdecl sub_80726C0(_DWORD *a1)
{
  _DWORD *result; // eax

  result = a1;
  if ( !*a1 )
  {
    if ( dword_820289C )
    {
      sub_806E5EC(*(_DWORD *)dword_82028A0);
      *(_DWORD *)(dword_820289C + 4 * *(_DWORD *)dword_82028A0) = a1;
      result = (_DWORD *)dword_82028A0;
      ++*result;
    }
  }
  return result;
}
// 820289C: using guessed type int dword_820289C;
// 82028A0: using guessed type int dword_82028A0;

//----- (0807270E) --------------------------------------------------------
_DWORD *__cdecl sub_807270E(_DWORD *a1)
{
  _DWORD *result; // eax

  result = a1;
  if ( !*a1 )
  {
    if ( dword_82028A8 )
    {
      sub_806E5EC(*(_DWORD *)dword_82028AC);
      *(_DWORD *)(dword_82028A8 + 4 * *(_DWORD *)dword_82028AC) = a1;
      result = (_DWORD *)dword_82028AC;
      ++*result;
    }
  }
  return result;
}
// 82028A8: using guessed type int dword_82028A8;
// 82028AC: using guessed type int dword_82028AC;

//----- (0807275C) --------------------------------------------------------
int __cdecl sub_807275C(_DWORD *a1, _DWORD *a2, int a3, int a4, int a5, int *a6)
{
  int result; // eax
  int v7; // [esp+14h] [ebp-54h]
  int v8; // [esp+18h] [ebp-50h]
  int v9; // [esp+1Ch] [ebp-4Ch]
  int v10; // [esp+20h] [ebp-48h]
  int v11; // [esp+24h] [ebp-44h]
  int v12; // [esp+28h] [ebp-40h]
  int v13; // [esp+2Ch] [ebp-3Ch]
  int v14; // [esp+30h] [ebp-38h]
  int v15; // [esp+34h] [ebp-34h]
  char v16; // [esp+43h] [ebp-25h]
  int v17; // [esp+44h] [ebp-24h]
  char v18; // [esp+4Ah] [ebp-1Eh]
  char v19; // [esp+4Bh] [ebp-1Dh]
  int v20; // [esp+4Ch] [ebp-1Ch]
  char v21; // [esp+52h] [ebp-16h]
  char v22; // [esp+53h] [ebp-15h]
  unsigned int v23; // [esp+54h] [ebp-14h]
  _WORD *v24; // [esp+58h] [ebp-10h]
  unsigned int v25; // [esp+5Ch] [ebp-Ch]

  v22 = byte_820288C;
  v21 = byte_820288D;
  v20 = dword_8202890;
  byte_820288C = 0;
  byte_820288D = 0;
  v19 = byte_8202894;
  v18 = byte_8202895;
  v17 = dword_8202898;
  byte_8202894 = 0;
  byte_8202895 = 0;
  sub_806EA5A(a5, (_DWORD *)*a6);
  sub_806E4CA(*a6);
  *(_DWORD *)(a5 + 4) = *(_DWORD *)(*a6 + 4);
  v25 = sub_8079C94(0);
  v16 = 0;
  if ( (unsigned __int8)sub_80719D8(a1, &v14, a5) )
  {
    if ( v15 != 6 && v15 != 5 )
    {
      sub_806EE00(&v14);
    }
    else
    {
      sub_807CC38((float *)&v14);
      if ( !v14 )
        sub_8077FFE(a3, "conditional expression cannot be always false");
      v16 = 1;
    }
  }
  v13 = dword_820289C;
  v12 = dword_82028A0;
  v7 = dword_82028A4;
  v9 = dword_82028A8;
  v8 = dword_82028AC;
  v10 = 0;
  dword_82028A8 = 0;
  dword_82028A4 = *a6;
  if ( v16 )
  {
    v24 = 0;
    v23 = 0;
    v11 = sub_80A9CF0(4096);
    dword_82028A0 = (int)&v10;
  }
  else
  {
    sub_806DAD8(94, -1, 0);
    sub_8076D92(a3, 0);
    sub_806DF60(0);
    v24 = (_WORD *)dword_8202860;
    v23 = sub_8079C94(0);
    v11 = 0;
  }
  dword_820289C = v11;
  byte_820288C = 1;
  byte_820288D = dword_8202A68 != 0;
  dword_8202890 = 0;
  byte_8202894 = 1;
  byte_8202895 = dword_8202A68 != 0;
  dword_8202898 = 0;
  sub_80742D2((int)a2, 0, 0, (_DWORD *)*a6);
  if ( *(_DWORD *)*a6 != 3 )
    *(_DWORD *)*a6 = 0;
  byte_820288C = 0;
  byte_820288D = 0;
  byte_8202894 = 0;
  byte_8202895 = 0;
  sub_8071EFA();
  sub_806DAD8(99, 0, 0);
  sub_8076D92(a4, 0);
  if ( *a2 == 44 )
    sub_8076D92(a2[3], 1);
  sub_806DF60(0);
  *(_WORD *)dword_8202860 = sub_8079C94(0) - v25;
  if ( v24 )
    *v24 = sub_8079C94(0) - v23;
  sub_8071EB6();
  byte_820288C = v22;
  byte_820288D = v21;
  dword_8202890 = v20;
  byte_8202894 = v19;
  byte_8202895 = v18;
  dword_8202898 = v17;
  if ( v16 )
    sub_806E714(v11, v10, a5);
  dword_820289C = v13;
  dword_82028A0 = v12;
  dword_82028A4 = v7;
  dword_82028A8 = v9;
  result = v8;
  dword_82028AC = v8;
  return result;
}
// 8202860: using guessed type int dword_8202860;
// 820288C: using guessed type char byte_820288C;
// 820288D: using guessed type char byte_820288D;
// 8202890: using guessed type int dword_8202890;
// 8202894: using guessed type char byte_8202894;
// 8202895: using guessed type char byte_8202895;
// 8202898: using guessed type int dword_8202898;
// 820289C: using guessed type int dword_820289C;
// 82028A0: using guessed type int dword_82028A0;
// 82028A4: using guessed type int dword_82028A4;
// 82028A8: using guessed type int dword_82028A8;
// 82028AC: using guessed type int dword_82028AC;
// 8202A68: using guessed type int dword_8202A68;

//----- (08072AE6) --------------------------------------------------------
int __cdecl sub_8072AE6(_DWORD *a1, int a2, int *a3, size_t *a4)
{
  int result; // eax
  int i; // [esp+1Ch] [ebp-4Ch]
  int v6; // [esp+20h] [ebp-48h]
  int v7; // [esp+24h] [ebp-44h]
  int v8; // [esp+28h] [ebp-40h]
  size_t v9; // [esp+2Ch] [ebp-3Ch]
  int v10; // [esp+30h] [ebp-38h]
  int v11; // [esp+34h] [ebp-34h]
  int v12; // [esp+38h] [ebp-30h]
  int v13; // [esp+3Ch] [ebp-2Ch]
  int v14; // [esp+40h] [ebp-28h]
  int v15; // [esp+44h] [ebp-24h]
  char v16; // [esp+5Bh] [ebp-Dh]
  int v17; // [esp+5Ch] [ebp-Ch]

  v16 = 0;
  if ( (unsigned __int8)sub_807194E(a1, &v14) )
  {
    if ( v15 == 6 || v15 == 5 )
    {
      sub_807CC38((float *)&v14);
      if ( v14 )
        v16 = 1;
    }
    sub_80757AC(&v14);
  }
  v13 = dword_820289C;
  v12 = dword_82028A0;
  v7 = dword_82028A8;
  v6 = dword_82028AC;
  v10 = 0;
  v8 = 0;
  v9 = sub_80A9CF0(4096);
  dword_82028A8 = v9;
  dword_82028AC = (int)&v8;
  v17 = *a3;
  if ( v16 )
  {
    v11 = sub_80A9CF0(4096);
    dword_82028A0 = (int)&v10;
  }
  else
  {
    v11 = 0;
  }
  dword_820289C = v11;
  sub_806E69A(a3, a4);
  sub_8074842((size_t *)a2, (signed int *)*a4);
  sub_807270E((_DWORD *)*a4);
  for ( i = 0; i < v8; ++i )
    sub_806E846(v9 + 4 * i, 1, a3);
  if ( v16 )
    sub_806E846(v11, v10, a3);
  sub_806E94E((int)a4, 1, a3);
  dword_820289C = v13;
  dword_82028A0 = v12;
  dword_82028A8 = v7;
  result = v6;
  dword_82028AC = v6;
  return result;
}
// 820289C: using guessed type int dword_820289C;
// 82028A0: using guessed type int dword_82028A0;
// 82028A8: using guessed type int dword_82028A8;
// 82028AC: using guessed type int dword_82028AC;

//----- (08072C7E) --------------------------------------------------------
int __cdecl sub_8072C7E(int a1, int a2, int a3, _DWORD *a4, int a5, int a6, int a7, int *a8, int *a9)
{
  int result; // eax
  int v10; // [esp+1Ch] [ebp-5Ch]
  int v11; // [esp+20h] [ebp-58h]
  int v12; // [esp+24h] [ebp-54h]
  int v13; // [esp+28h] [ebp-50h]
  int v14; // [esp+2Ch] [ebp-4Ch]
  int v15; // [esp+30h] [ebp-48h]
  int v16; // [esp+34h] [ebp-44h]
  int v17; // [esp+38h] [ebp-40h]
  int v18; // [esp+3Ch] [ebp-3Ch]
  int v19; // [esp+40h] [ebp-38h]
  int v20; // [esp+44h] [ebp-34h]
  char v21; // [esp+53h] [ebp-25h]
  int v22; // [esp+54h] [ebp-24h]
  char v23; // [esp+5Ah] [ebp-1Eh]
  char v24; // [esp+5Bh] [ebp-1Dh]
  int v25; // [esp+5Ch] [ebp-1Ch]
  char v26; // [esp+62h] [ebp-16h]
  char v27; // [esp+63h] [ebp-15h]
  unsigned int v28; // [esp+64h] [ebp-14h]
  _WORD *v29; // [esp+68h] [ebp-10h]
  unsigned int v30; // [esp+6Ch] [ebp-Ch]

  v27 = byte_820288C;
  v26 = byte_820288D;
  v25 = dword_8202890;
  byte_820288C = 0;
  byte_820288D = 0;
  v24 = byte_8202894;
  v23 = byte_8202895;
  v22 = dword_8202898;
  byte_8202894 = 0;
  byte_8202895 = 0;
  sub_80742D2(a1, 0, 0, (_DWORD *)a7);
  sub_806EA5A(a7, (_DWORD *)*a8);
  sub_806E4CA(*a8);
  *(_DWORD *)(a7 + 4) = *(_DWORD *)(*a8 + 4);
  sub_806EA5A(a7, (_DWORD *)*a9);
  v30 = sub_8079C94(0);
  if ( *(_DWORD *)a2 == 65 )
  {
    v21 = 0;
    if ( (unsigned __int8)sub_80719D8(*(_DWORD **)(a2 + 4), &v19, a7) )
    {
      if ( v20 != 6 && v20 != 5 )
      {
        sub_806EE00(&v19);
      }
      else
      {
        sub_807CC38((float *)&v19);
        if ( !v19 )
          sub_8077FFE(a5, "conditional expression cannot be always false");
        v21 = 1;
      }
    }
  }
  else
  {
    v21 = 1;
  }
  v18 = dword_820289C;
  v17 = dword_82028A0;
  v10 = dword_82028A4;
  v12 = dword_82028A8;
  v11 = dword_82028AC;
  v15 = 0;
  v13 = 0;
  v14 = sub_80A9CF0(4096);
  dword_82028A8 = v14;
  dword_82028AC = (int)&v13;
  dword_82028A4 = *a8;
  if ( v21 )
  {
    v29 = 0;
    v28 = 0;
    v16 = sub_80A9CF0(4096);
    dword_82028A0 = (int)&v15;
  }
  else
  {
    sub_806DAD8(94, -1, 0);
    sub_8076D92(a5, 0);
    sub_806DF60(0);
    v29 = (_WORD *)dword_8202860;
    v28 = sub_8079C94(0);
    v16 = 0;
  }
  dword_820289C = v16;
  byte_820288C = 1;
  byte_820288D = dword_8202A68 != 0;
  dword_8202890 = 0;
  byte_8202894 = 1;
  byte_8202895 = dword_8202A68 != 0;
  dword_8202898 = 0;
  sub_80742D2((int)a4, 0, 0, (_DWORD *)*a8);
  sub_807270E((_DWORD *)*a8);
  byte_820288C = 0;
  byte_820288D = 0;
  byte_8202894 = 0;
  byte_8202895 = 0;
  sub_8071EFA();
  sub_806E714(v14, v13, *a9);
  sub_80742D2(a3, 0, 0, (_DWORD *)*a9);
  sub_806DAD8(99, 0, 0);
  sub_8076D92(a6, 0);
  if ( *a4 == 44 )
    sub_8076D92(a4[3], 1);
  sub_806DF60(0);
  *(_WORD *)dword_8202860 = sub_8079C94(0) - v30;
  if ( v29 )
    *v29 = sub_8079C94(0) - v28;
  sub_8071EB6();
  byte_820288C = v27;
  byte_820288D = v26;
  dword_8202890 = v25;
  byte_8202894 = v24;
  byte_8202895 = v23;
  dword_8202898 = v22;
  if ( v21 )
    sub_806E714(v16, v15, a7);
  dword_820289C = v18;
  dword_82028A0 = v17;
  dword_82028A4 = v10;
  dword_82028A8 = v12;
  result = v11;
  dword_82028AC = v11;
  return result;
}
// 8202860: using guessed type int dword_8202860;
// 820288C: using guessed type char byte_820288C;
// 820288D: using guessed type char byte_820288D;
// 8202890: using guessed type int dword_8202890;
// 8202894: using guessed type char byte_8202894;
// 8202895: using guessed type char byte_8202895;
// 8202898: using guessed type int dword_8202898;
// 820289C: using guessed type int dword_820289C;
// 82028A0: using guessed type int dword_82028A0;
// 82028A4: using guessed type int dword_82028A4;
// 82028A8: using guessed type int dword_82028A8;
// 82028AC: using guessed type int dword_82028AC;
// 8202A68: using guessed type int dword_8202A68;

//----- (080730A4) --------------------------------------------------------
int __cdecl sub_80730A4(int a1, int a2, int a3, int a4, int *a5, size_t *a6, size_t *a7)
{
  int result; // eax
  int i; // [esp+1Ch] [ebp-4Ch]
  int v9; // [esp+20h] [ebp-48h]
  int v10; // [esp+24h] [ebp-44h]
  int v11; // [esp+28h] [ebp-40h]
  size_t v12; // [esp+2Ch] [ebp-3Ch]
  int v13; // [esp+30h] [ebp-38h]
  int v14; // [esp+34h] [ebp-34h]
  int v15; // [esp+38h] [ebp-30h]
  int v16; // [esp+3Ch] [ebp-2Ch]
  int v17; // [esp+40h] [ebp-28h]
  int v18; // [esp+44h] [ebp-24h]
  char v19; // [esp+5Bh] [ebp-Dh]
  int v20; // [esp+5Ch] [ebp-Ch]

  sub_8074842((size_t *)a1, a5);
  if ( *(_DWORD *)a2 == 65 )
  {
    v19 = 0;
    if ( (unsigned __int8)sub_807194E(*(_DWORD **)(a2 + 4), &v17) )
    {
      if ( v18 == 6 || v18 == 5 )
      {
        sub_807CC38((float *)&v17);
        if ( v17 )
          v19 = 1;
      }
      sub_80757AC(&v17);
    }
  }
  else
  {
    v19 = 1;
  }
  v16 = dword_820289C;
  v15 = dword_82028A0;
  v10 = dword_82028A8;
  v9 = dword_82028AC;
  v13 = 0;
  v11 = 0;
  v12 = sub_80A9CF0(4096);
  dword_82028A8 = v12;
  dword_82028AC = (int)&v11;
  v20 = *a5;
  if ( v19 )
  {
    v14 = sub_80A9CF0(4096);
    dword_82028A0 = (int)&v13;
  }
  else
  {
    v14 = 0;
  }
  dword_820289C = v14;
  sub_806E69A(a5, a6);
  sub_806E69A(a5, a7);
  sub_8074842((size_t *)a4, (signed int *)*a6);
  sub_807270E((_DWORD *)*a6);
  for ( i = 0; i < v11; ++i )
    sub_806E846(v12 + 4 * i, 1, a5);
  sub_8074842((size_t *)a3, (signed int *)*a7);
  sub_806E846((int)a7, 1, a5);
  sub_806E94E((int)a7, 1, a5);
  if ( v19 )
    sub_806E846(v14, v13, a5);
  sub_806E94E((int)a6, 1, a5);
  dword_820289C = v16;
  dword_82028A0 = v15;
  dword_82028A8 = v10;
  result = v9;
  dword_82028AC = v9;
  return result;
}
// 820289C: using guessed type int dword_820289C;
// 82028A0: using guessed type int dword_82028A0;
// 82028A8: using guessed type int dword_82028A8;
// 82028AC: using guessed type int dword_82028AC;

//----- (080732BA) --------------------------------------------------------
void __cdecl sub_80732BA(signed int *a1, int a2, int a3)
{
  byte_82028B0 = 1;
  sub_8071BA0(a1, a3);
  byte_82028B0 = 0;
  sub_806DAD8(100, 1, 0);
  sub_8076D92(a2, 0);
  sub_806E2EE(a2);
}
// 82028B0: using guessed type char byte_82028B0;

//----- (0807331C) --------------------------------------------------------
_DWORD *__cdecl sub_807331C(int a1, _DWORD *a2)
{
  return sub_8071CB0(a1, a2);
}

//----- (08073336) --------------------------------------------------------
void __cdecl sub_8073336(signed int *a1, int a2, int a3)
{
  byte_82028B0 = 1;
  sub_8071BA0(a1, a3);
  byte_82028B0 = 0;
  sub_806DAD8(101, 1, 0);
  sub_8076D92(a2, 0);
  sub_806E2EE(a2);
}
// 82028B0: using guessed type char byte_82028B0;

//----- (08073398) --------------------------------------------------------
int __cdecl sub_8073398(int a1, int a2)
{
  int result; // eax

  while ( 1 )
  {
    result = *(_DWORD *)(a1 + 4);
    a1 = *(_DWORD *)(a1 + 4);
    if ( !a1 )
      break;
    sub_806EB94(**(_DWORD **)a1, *(_DWORD *)(*(_DWORD *)a1 + 4), a2);
  }
  return result;
}

//----- (080733DA) --------------------------------------------------------
int __cdecl sub_80733DA(int a1, _DWORD *a2)
{
  int result; // eax

  while ( 1 )
  {
    result = *(_DWORD *)(a1 + 4);
    a1 = *(_DWORD *)(a1 + 4);
    if ( !a1 )
      break;
    sub_806EC16(**(_DWORD ***)a1, *(_DWORD *)(*(_DWORD *)a1 + 4), a2);
  }
  return result;
}

//----- (0807341C) --------------------------------------------------------
int __cdecl sub_807341C(int a1, int a2)
{
  int result; // eax

  while ( 1 )
  {
    result = *(_DWORD *)(a1 + 4);
    a1 = *(_DWORD *)(a1 + 4);
    if ( !a1 )
      break;
    sub_806EC38(**(_DWORD **)a1, *(_DWORD *)(*(_DWORD *)a1 + 4), a2);
  }
  return result;
}

//----- (0807345E) --------------------------------------------------------
int __cdecl sub_807345E(int a1, int a2, int a3, int a4, int a5)
{
  _DWORD ***v5; // ST14_4

  v5 = *(_DWORD ****)(*(_DWORD *)a2 + 4);
  sub_8071B6C(**v5, a5);
  sub_8071552(a1, a5);
  sub_806DAD8(120, -2, 0);
  sub_8076D92(a4, 0);
  sub_8076D92(a4, 0);
  sub_8076D92(a3, 0);
  sub_8076D92((int)(*v5)[1], 0);
  sub_807341C((int)v5, a5);
  return sub_806DAD8(52, 0, 0);
}

//----- (08073538) --------------------------------------------------------
int __cdecl sub_8073538(int a1, _DWORD *a2)
{
  return sub_80733DA(*(_DWORD *)(*(_DWORD *)a1 + 4), a2);
}

//----- (08073560) --------------------------------------------------------
int __cdecl sub_8073560(int a1, int a2, int a3, int a4, int a5)
{
  int i; // [esp+10h] [ebp-8h]
  int v7; // [esp+14h] [ebp-4h]
  int v8; // [esp+14h] [ebp-4h]

  v7 = *(_DWORD *)(*(_DWORD *)a2 + 4);
  for ( i = 0; ; ++i )
  {
    v7 = *(_DWORD *)(v7 + 4);
    if ( !v7 )
      break;
    sub_8071B6C(**(_DWORD ***)v7, a5);
  }
  v8 = *(_DWORD *)(*(_DWORD *)a2 + 4);
  sub_8071B6C(**(_DWORD ***)v8, a5);
  sub_8071552(a1, a5);
  sub_806DAD8(119, -2 - i, 0);
  sub_8076D92(a4, 0);
  sub_8076D92(a4, 0);
  sub_8076D92(a3, 0);
  sub_8076D92(*(_DWORD *)(*(_DWORD *)v8 + 4), 0);
  while ( 1 )
  {
    v8 = *(_DWORD *)(v8 + 4);
    if ( !v8 )
      break;
    sub_8076D92(*(_DWORD *)(*(_DWORD *)v8 + 4), 0);
  }
  sub_806DF8E(i);
  return sub_806DAD8(52, 0, 0);
}

//----- (080736AC) --------------------------------------------------------
void __cdecl sub_80736AC(int a1, int *a2, int a3, int a4, int a5)
{
  int v5; // [esp+Ch] [ebp-Ch]
  int i; // [esp+10h] [ebp-8h]
  int v7; // [esp+14h] [ebp-4h]

  sub_806DAD8(123, 1, 0);
  sub_8076D92(a3, 1);
  v5 = 0;
  v7 = 0;
  for ( i = *a2; i; i = *(_DWORD *)(i + 4) )
  {
    v7 = i;
    sub_8071B6C(**(_DWORD ***)i, a5);
    ++v5;
  }
  sub_8071552(a1, a5);
  sub_806DAD8(121, -v5 - 2, 0);
  sub_8076D92(a4, 0);
  sub_8076D92(*(_DWORD *)(*(_DWORD *)v7 + 4), 0);
  sub_8076D92(a3, 0);
}

//----- (080737A2) --------------------------------------------------------
void __cdecl sub_80737A2(int a1, _DWORD *a2, int a3, int a4, int a5)
{
  sub_8071B6C(a2, a5);
  sub_8071552(a1, a5);
  sub_806DAD8(122, -2, 0);
  sub_8076D92(a4, 0);
  sub_8076D92(a3, 0);
}

//----- (08073810) --------------------------------------------------------
int __cdecl compar(const void *a1, const void *a2)
{
  signed int v3; // [esp+0h] [ebp-4h]

  if ( *(_DWORD *)a1 <= *(_DWORD *)a2 )
    v3 = *(_DWORD *)a1 < *(_DWORD *)a2;
  else
    v3 = -1;
  return v3;
}

//----- (0807384C) --------------------------------------------------------
signed int __cdecl sub_807384C(int a1)
{
  if ( !a1 )
    return 1;
  if ( byte_839400B )
    return 0;
  while ( a1 )
  {
    if ( **(_DWORD **)a1 != 45 )
      return 0;
    a1 = *(_DWORD *)(a1 + 4);
  }
  return 1;
}
// 839400B: using guessed type char byte_839400B;

//----- (080738A8) --------------------------------------------------------
void __cdecl sub_80738A8(_DWORD *a1, int a2)
{
  char *v2; // eax
  int v3; // ST14_4
  int v4; // ST14_4

  if ( *a1 == 7 )
  {
    if ( (unsigned __int8)sub_807BAB4(a1[1]) )
    {
      v3 = sub_807BADA(a1[1]);
      sub_8074020(v3, a2);
    }
    else
    {
      v2 = va("case index %d out of range", a1[1]);
      sub_8077FFE(a2, v2);
    }
  }
  else if ( *a1 == 11 )
  {
    v4 = a1[1];
    sub_806DA94(a1[1], 1u);
    sub_8074020(v4, a2);
  }
  else
  {
    sub_8077FFE(a2, "case expression must be an int or string");
  }
}

//----- (08073964) --------------------------------------------------------
void __cdecl sub_8073964(int a1)
{
  sub_8074020(0, a1);
}

//----- (08073980) --------------------------------------------------------
char *__cdecl sub_8073980(int a1, char a2, int a3, int a4)
{
  char *result; // eax
  unsigned __int8 v5; // [esp+10h] [ebp-28h]
  char *v6; // [esp+14h] [ebp-24h]
  int v7; // [esp+18h] [ebp-20h]
  int v8; // [esp+1Ch] [ebp-1Ch]
  int v9; // [esp+20h] [ebp-18h]
  int v10; // [esp+24h] [ebp-14h]
  char v11; // [esp+2Bh] [ebp-Dh]
  int *v12; // [esp+2Ch] [ebp-Ch]
  int *i; // [esp+30h] [ebp-8h]
  char v14; // [esp+37h] [ebp-1h]

  v14 = a2;
  v8 = dword_820289C;
  v7 = dword_82028A0;
  v6 = (char *)dword_82028A4;
  v9 = 0;
  v10 = sub_80A9CF0(4096);
  dword_820289C = v10;
  dword_82028A0 = (int)&v9;
  dword_82028A4 = 0;
  v11 = 0;
  for ( i = *(int **)(*(_DWORD *)a1 + 4); i; i = v12 )
  {
    v12 = (int *)i[1];
    if ( *(_DWORD *)*i != 61 && *(_DWORD *)*i != 62 )
    {
      if ( !dword_82028A4 )
        return sub_8077FFE(a3, "missing case statement");
      v5 = 0;
      if ( v14 && (unsigned __int8)sub_807384C((int)v12) )
        v5 = 1;
      sub_80742D2(*i, v5, a3, (_DWORD *)dword_82028A4);
      if ( dword_82028A4 && *(_DWORD *)dword_82028A4 )
      {
        dword_82028A4 = 0;
        byte_820288C = 0;
      }
    }
    else
    {
      if ( dword_82028A4 )
      {
        byte_820288C = 0;
        sub_806E53A((_DWORD *)dword_82028A4, dword_82028A4);
      }
      if ( *(_DWORD *)*i == 61 )
      {
        dword_82028A4 = *(_DWORD *)(*i + 12);
        sub_80738A8(*(_DWORD **)(*i + 4), *(_DWORD *)(*i + 8));
      }
      else
      {
        dword_82028A4 = *(_DWORD *)(*i + 8);
        v11 = 1;
        sub_8073964(*(_DWORD *)(*i + 4));
      }
      sub_806EA5A(a4, (_DWORD *)dword_82028A4);
      byte_820288C = 1;
    }
  }
  if ( dword_82028A4 )
  {
    byte_820288C = 0;
    sub_806E53A((_DWORD *)dword_82028A4, dword_82028A4);
  }
  if ( v11 )
  {
    if ( dword_82028A4 )
      sub_80726C0((_DWORD *)dword_82028A4);
    sub_806E714(v10, v9, a4);
  }
  dword_820289C = v8;
  dword_82028A0 = v7;
  result = v6;
  dword_82028A4 = (int)v6;
  return result;
}
// 820288C: using guessed type char byte_820288C;
// 820289C: using guessed type int dword_820289C;
// 82028A0: using guessed type int dword_82028A0;
// 82028A4: using guessed type int dword_82028A4;

//----- (08073BC8) --------------------------------------------------------
int __cdecl sub_8073BC8(int a1, signed int *a2)
{
  int result; // eax
  signed int v3; // [esp+10h] [ebp-28h]
  int v4; // [esp+14h] [ebp-24h]
  signed int v5; // [esp+18h] [ebp-20h]
  char v6; // [esp+1Fh] [ebp-19h]
  signed int *v7; // [esp+20h] [ebp-18h]
  int v8; // [esp+24h] [ebp-14h]
  int v9; // [esp+28h] [ebp-10h]
  int v10; // [esp+2Ch] [ebp-Ch]
  int v11; // [esp+30h] [ebp-8h]
  int i; // [esp+34h] [ebp-4h]

  v5 = 3;
  v9 = dword_820289C;
  v8 = dword_82028A0;
  v10 = 0;
  v11 = sub_80A9CF0(4096);
  dword_820289C = v11;
  dword_82028A0 = (int)&v10;
  v3 = 0;
  v7 = 0;
  v6 = 0;
  v4 = sub_80A9CF0(4096);
  for ( i = *(_DWORD *)(*(_DWORD *)a1 + 4); i; i = *(_DWORD *)(i + 4) )
  {
    if ( **(_DWORD **)i != 61 && **(_DWORD **)i != 62 )
    {
      if ( v7 )
      {
        sub_8074842(*(size_t **)i, v7);
        if ( *v7 )
        {
          if ( *v7 == 2 )
          {
            *v7 = 0;
            v5 = 0;
            sub_806E5EC(v3);
            *(_DWORD *)(v4 + 4 * v3++) = v7;
          }
          else if ( *v7 <= v5 )
          {
            v5 = *v7;
          }
          v7 = 0;
        }
      }
    }
    else
    {
      v7 = 0;
      sub_806E69A(a2, (size_t *)&v7);
      if ( **(_DWORD **)i == 61 )
      {
        *(_DWORD *)(*(_DWORD *)i + 12) = v7;
      }
      else
      {
        *(_DWORD *)(*(_DWORD *)i + 8) = v7;
        v6 = 1;
      }
    }
  }
  if ( v6 )
  {
    if ( v7 )
    {
      sub_80726C0(v7);
      sub_806E5EC(v3);
      *(_DWORD *)(v4 + 4 * v3++) = v7;
    }
    if ( !*a2 )
      *a2 = v5;
    sub_806E846(v11, v10, a2);
    sub_806E94E(v4, v3, a2);
  }
  dword_820289C = v9;
  result = v8;
  dword_82028A0 = v8;
  return result;
}
// 820289C: using guessed type int dword_820289C;
// 82028A0: using guessed type int dword_82028A0;

//----- (08073DBC) --------------------------------------------------------
char *__cdecl sub_8073DBC(_DWORD *a1, int a2, int a3, char a4, int a5, int a6)
{
  _DWORD *v6; // ST20_4
  unsigned int v7; // ST14_4
  char *result; // eax
  signed int nmemb; // [esp+10h] [ebp-28h]
  _DWORD *base; // [esp+18h] [ebp-20h]
  _WORD *v11; // [esp+1Ch] [ebp-1Ch]
  int v12; // [esp+24h] [ebp-14h]
  char v13; // [esp+2Ah] [ebp-Eh]
  char v14; // [esp+2Bh] [ebp-Dh]
  int *v15; // [esp+2Ch] [ebp-Ch]
  _DWORD *i; // [esp+2Ch] [ebp-Ch]
  int v17; // [esp+30h] [ebp-8h]
  char v18; // [esp+36h] [ebp-2h]

  v18 = byte_8202886;
  v17 = dword_8202888;
  byte_8202886 = 0;
  v14 = byte_820288C;
  v13 = byte_820288D;
  v12 = dword_8202890;
  byte_820288C = 0;
  byte_820288D = 0;
  sub_8071B6C(a1, a6);
  sub_806DAD8(124, -1, 0);
  sub_806DF0E(0);
  v6 = (_DWORD *)dword_8202860;
  v7 = sub_8079C94(0);
  byte_8202886 = dword_8202A68 != 0;
  dword_8202888 = 0;
  byte_820288D = dword_8202A68 != 0;
  dword_8202890 = 0;
  sub_8073980(a2, a4, a5, a6);
  byte_8202886 = 0;
  byte_820288D = 0;
  sub_806DAD8(125, 0, 0);
  sub_8076D92(a3, 0);
  sub_806DF32(0);
  v11 = (_WORD *)dword_8202860;
  *v6 = dword_8202860 - v7;
  base = (_DWORD *)sub_8079CDC(0);
  nmemb = 0;
  v15 = (int *)dword_8202888;
  while ( v15 )
  {
    sub_806DF0E(*v15);
    sub_806E004(v15[1]);
    v15 = (int *)v15[3];
    ++nmemb;
  }
  *v11 = nmemb;
  qsort(base, nmemb, 8u, compar);
  while ( nmemb > 1 )
  {
    if ( *base == base[2] )
    {
      for ( i = (_DWORD *)dword_8202888; i; i = (_DWORD *)i[3] )
      {
        if ( *i == *base )
          return sub_8077FFE(i[2], "duplicate case expression");
      }
    }
    --nmemb;
    base += 2;
  }
  sub_8071EB6();
  byte_8202886 = v18;
  dword_8202888 = v17;
  byte_820288C = v14;
  byte_820288D = v13;
  result = (char *)v12;
  dword_8202890 = v12;
  return result;
}
// 8202860: using guessed type int dword_8202860;
// 8202886: using guessed type char byte_8202886;
// 8202888: using guessed type int dword_8202888;
// 820288C: using guessed type char byte_820288C;
// 820288D: using guessed type char byte_820288D;
// 8202890: using guessed type int dword_8202890;
// 8202A68: using guessed type int dword_8202A68;

//----- (08074020) --------------------------------------------------------
void __cdecl sub_8074020(int a1, int a2)
{
  _DWORD *v2; // ST10_4

  if ( dword_8202A68 != 2 )
  {
    v2 = (_DWORD *)sub_80A9CF0(16);
    *v2 = a1;
    v2[1] = sub_8079C94(0);
    v2[2] = a2;
    v2[3] = dword_8202888;
    dword_8202888 = (int)v2;
  }
}
// 8202888: using guessed type int dword_8202888;
// 8202A68: using guessed type int dword_8202A68;

//----- (0807407E) --------------------------------------------------------
char *__cdecl sub_807407E(int a1, _DWORD *a2)
{
  char *result; // eax
  _DWORD *v3; // eax
  int v4; // ST10_4

  if ( !byte_820288C || *a2 )
    return sub_8077FFE(a1, "illegal break statement");
  sub_80726C0(a2);
  sub_806E53A(a2, dword_82028A4);
  *a2 = 2;
  sub_806DAD8(98, 0, 0);
  sub_8076D92(a1, 1);
  sub_806DF0E(0);
  v3 = (_DWORD *)sub_80A9CF0(12);
  v4 = (int)v3;
  *v3 = dword_8202860;
  v3[1] = sub_8079C94(0);
  *(_DWORD *)(v4 + 8) = dword_8202890;
  result = (char *)v4;
  dword_8202890 = v4;
  return result;
}
// 8202860: using guessed type int dword_8202860;
// 820288C: using guessed type char byte_820288C;
// 8202890: using guessed type int dword_8202890;
// 82028A4: using guessed type int dword_82028A4;

//----- (08074158) --------------------------------------------------------
char *__cdecl sub_8074158(int a1, _DWORD *a2)
{
  char *result; // eax
  _DWORD *v3; // eax
  int v4; // ST10_4

  if ( !byte_8202894 || *a2 )
    return sub_8077FFE(a1, "illegal continue statement");
  sub_807270E(a2);
  sub_806E53A(a2, (int)a2);
  *a2 = 1;
  sub_806DAD8(98, 0, 0);
  sub_8076D92(a1, 1);
  sub_806DF0E(0);
  v3 = (_DWORD *)sub_80A9CF0(12);
  v4 = (int)v3;
  *v3 = dword_8202860;
  v3[1] = sub_8079C94(0);
  *(_DWORD *)(v4 + 8) = dword_8202898;
  result = (char *)v4;
  dword_8202898 = v4;
  return result;
}
// 8202860: using guessed type int dword_8202860;
// 8202894: using guessed type char byte_8202894;
// 8202898: using guessed type int dword_8202898;

//----- (08074230) --------------------------------------------------------
void sub_8074230()
{
  ;
}

//----- (08074236) --------------------------------------------------------
int __cdecl sub_8074236(int a1, int a2, unsigned __int8 a3)
{
  if ( !byte_839400B )
    return sub_806D9EC(a1);
  sub_806D9EC(a1);
  sub_806DAD8(a3, 0, 0);
  return sub_806DF8E(0);
}
// 839400B: using guessed type char byte_839400B;

//----- (0807428E) --------------------------------------------------------
int __cdecl sub_807428E(int a1, int a2)
{
  return sub_8074236(a1, a2, 0x85u);
}

//----- (080742B0) --------------------------------------------------------
int __cdecl sub_80742B0(int a1, int a2)
{
  return sub_8074236(a1, a2, 0x86u);
}

//----- (080742D2) --------------------------------------------------------
void __cdecl sub_80742D2(int a1, unsigned __int8 a2, int a3, _DWORD *a4)
{
  int v4; // ST00_4

  switch ( *(_DWORD *)a1 )
  {
    case 0:
    case 1:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
    case 9:
    case 0xA:
    case 0xB:
    case 0xC:
    case 0xD:
    case 0xE:
    case 0xF:
    case 0x10:
    case 0x11:
    case 0x12:
    case 0x13:
    case 0x14:
    case 0x15:
    case 0x16:
    case 0x17:
    case 0x18:
    case 0x1A:
    case 0x1E:
    case 0x1F:
    case 0x20:
    case 0x21:
    case 0x22:
    case 0x23:
    case 0x24:
    case 0x2E:
    case 0x2F:
    case 0x30:
    case 0x31:
    case 0x32:
    case 0x33:
    case 0x34:
    case 0x35:
    case 0x36:
    case 0x41:
    case 0x42:
    case 0x43:
    case 0x44:
    case 0x45:
    case 0x46:
    case 0x47:
    case 0x48:
    case 0x49:
    case 0x4A:
      return;
    case 2:
      sub_8072088(*(signed int **)(a1 + 4), *(_DWORD **)(a1 + 8), *(_DWORD *)(a1 + 12), *(_DWORD *)(a1 + 16), (int)a4);
      break;
    case 0x19:
      sub_8072108(*(_DWORD *)(a1 + 4), (int)a4);
      break;
    case 0x1B:
      sub_807212A(*(_DWORD **)(a1 + 4), *(_DWORD *)(a1 + 8), a4);
      break;
    case 0x1C:
      sub_807216E(*(_DWORD *)(a1 + 4), a4);
      break;
    case 0x1D:
      sub_80721A0(*(_DWORD **)(a1 + 4), *(_DWORD *)(a1 + 8), *(_DWORD *)(a1 + 12), (int)a4);
      break;
    case 0x25:
      sub_807225A(
        *(_DWORD **)(a1 + 4),
        *(_DWORD *)(a1 + 8),
        *(_DWORD *)(a1 + 12),
        a2,
        a3,
        (int)a4,
        (_DWORD **)(a1 + 16));
      break;
    case 0x26:
      sub_8072382(
        *(_DWORD **)(a1 + 4),
        *(_DWORD *)(a1 + 8),
        *(_DWORD *)(a1 + 12),
        *(_DWORD *)(a1 + 16),
        *(_DWORD *)(a1 + 20),
        a2,
        a3,
        (int)a4,
        (int *)(a1 + 24),
        (_DWORD **)(a1 + 28));
      break;
    case 0x27:
      sub_807275C(
        *(_DWORD **)(a1 + 4),
        *(_DWORD **)(a1 + 8),
        *(_DWORD *)(a1 + 12),
        *(_DWORD *)(a1 + 16),
        (int)a4,
        (int *)(a1 + 20));
      break;
    case 0x28:
      sub_8072C7E(
        *(_DWORD *)(a1 + 4),
        *(_DWORD *)(a1 + 8),
        *(_DWORD *)(a1 + 12),
        *(_DWORD **)(a1 + 16),
        *(_DWORD *)(a1 + 20),
        *(_DWORD *)(a1 + 24),
        (int)a4,
        (int *)(a1 + 28),
        (int *)(a1 + 32));
      break;
    case 0x29:
      sub_80732BA(*(signed int **)(a1 + 4), *(_DWORD *)(a1 + 8), (int)a4);
      break;
    case 0x2A:
      sub_8073336(*(signed int **)(a1 + 4), *(_DWORD *)(a1 + 8), (int)a4);
      break;
    case 0x2B:
      sub_80718AE(*(signed int **)(a1 + 4), *(_DWORD **)(a1 + 8), *(_DWORD *)(a1 + 12), *(_DWORD *)(a1 + 16), (int)a4);
      break;
    case 0x2C:
      sub_8074A7A(*(_DWORD *)(a1 + 4), a2, a3, a4);
      break;
    case 0x2D:
      sub_8074B7C(*(_DWORD *)(a1 + 4), *(_DWORD *)(a1 + 8), (int)a4, (int *)(a1 + 12));
      break;
    case 0x37:
      sub_807345E(*(_DWORD *)(a1 + 4), *(_DWORD *)(a1 + 8), *(_DWORD *)(a1 + 12), *(_DWORD *)(a1 + 16), (int)a4);
      break;
    case 0x38:
      sub_8073560(*(_DWORD *)(a1 + 4), *(_DWORD *)(a1 + 8), *(_DWORD *)(a1 + 12), *(_DWORD *)(a1 + 16), (int)a4);
      break;
    case 0x39:
      sub_8072210(*(_DWORD *)(a1 + 4));
      break;
    case 0x3A:
      sub_80736AC(*(_DWORD *)(a1 + 4), *(int **)(a1 + 8), *(_DWORD *)(a1 + 12), *(_DWORD *)(a1 + 16), (int)a4);
      break;
    case 0x3B:
      sub_80737A2(*(_DWORD *)(a1 + 4), *(_DWORD **)(a1 + 8), *(_DWORD *)(a1 + 12), *(_DWORD *)(a1 + 16), (int)a4);
      break;
    case 0x3C:
      sub_8073DBC(*(_DWORD **)(a1 + 4), *(_DWORD *)(a1 + 8), *(_DWORD *)(a1 + 12), a2, a3, (int)a4);
      break;
    case 0x3D:
      sub_8077FFE(*(_DWORD *)(a1 + 8), "illegal case statement");
      break;
    case 0x3E:
      sub_8077FFE(*(_DWORD *)(a1 + 4), "illegal default statement");
      break;
    case 0x3F:
      sub_807407E(*(_DWORD *)(a1 + 4), a4);
      break;
    case 0x40:
      sub_8074158(*(_DWORD *)(a1 + 4), a4);
      break;
    case 0x4B:
      v4 = *(_DWORD *)(a1 + 4);
      sub_8074230();
      break;
    case 0x4C:
      sub_807428E(*(_DWORD *)(a1 + 4), *(_DWORD *)(a1 + 8));
      break;
    case 0x4D:
      sub_80742B0(*(_DWORD *)(a1 + 4), *(_DWORD *)(a1 + 8));
      break;
  }
}

//----- (08074842) --------------------------------------------------------
void __cdecl sub_8074842(size_t *a1, signed int *a2)
{
  switch ( *a1 )
  {
    case 0u:
    case 1u:
    case 3u:
    case 4u:
    case 5u:
    case 6u:
    case 7u:
    case 8u:
    case 9u:
    case 0xAu:
    case 0xBu:
    case 0xCu:
    case 0xDu:
    case 0xEu:
    case 0xFu:
    case 0x10u:
    case 0x11u:
    case 0x12u:
    case 0x13u:
    case 0x14u:
    case 0x15u:
    case 0x16u:
    case 0x17u:
    case 0x18u:
    case 0x19u:
    case 0x1Au:
    case 0x1Du:
    case 0x1Eu:
    case 0x1Fu:
    case 0x20u:
    case 0x21u:
    case 0x22u:
    case 0x23u:
    case 0x24u:
    case 0x2Eu:
    case 0x2Fu:
    case 0x30u:
    case 0x31u:
    case 0x32u:
    case 0x33u:
    case 0x34u:
    case 0x35u:
    case 0x36u:
    case 0x38u:
    case 0x39u:
    case 0x3Au:
    case 0x3Bu:
    case 0x3Du:
    case 0x3Eu:
      return;
    case 2u:
      sub_80720EE(a1[1], a1[2], a2);
      break;
    case 0x1Bu:
    case 0x1Cu:
      if ( !*a2 )
        *a2 = 3;
      break;
    case 0x25u:
      sub_807233A(a1[2], a2, a1 + 4);
      break;
    case 0x26u:
      sub_80725C2(a1[2], a1[3], a2, a1 + 6, a1 + 7);
      break;
    case 0x27u:
      sub_8072AE6((_DWORD *)a1[1], a1[2], a2, a1 + 5);
      break;
    case 0x28u:
      sub_80730A4(a1[1], a1[2], a1[3], a1[4], a2, a1 + 7, a1 + 8);
      break;
    case 0x29u:
    case 0x2Au:
      sub_807331C(a1[1], a2);
      break;
    case 0x2Bu:
      sub_8071934(a1[1], a2);
      break;
    case 0x2Cu:
      sub_8074AF6(a1[1], a2);
      break;
    case 0x2Du:
      sub_8074B34(a1[1], a2, a1 + 3);
      break;
    case 0x37u:
      sub_8073538(a1[2], a2);
      break;
    case 0x3Cu:
      sub_8073BC8(a1[2], a2);
      break;
    case 0x3Fu:
      sub_80726C0(a2);
      if ( !*a2 )
        *a2 = 2;
      break;
    case 0x40u:
      sub_807270E(a2);
      if ( !*a2 )
        *a2 = 1;
      break;
  }
}

//----- (08074A7A) --------------------------------------------------------
int __cdecl sub_8074A7A(int a1, char a2, int a3, _DWORD *a4)
{
  int result; // eax
  unsigned __int8 v5; // [esp+18h] [ebp-10h]
  int v6; // [esp+1Ch] [ebp-Ch]
  int *i; // [esp+20h] [ebp-8h]

  result = *(_DWORD *)(*(_DWORD *)a1 + 4);
  for ( i = *(int **)(*(_DWORD *)a1 + 4); i; i = (int *)v6 )
  {
    v6 = i[1];
    v5 = 0;
    if ( a2 )
    {
      if ( (unsigned __int8)sub_807384C(v6) )
        v5 = 1;
    }
    sub_80742D2(*i, v5, a3, a4);
    result = v6;
  }
  return result;
}

//----- (08074AF6) --------------------------------------------------------
int __cdecl sub_8074AF6(int a1, signed int *a2)
{
  int result; // eax
  int i; // [esp+14h] [ebp-4h]

  result = *(_DWORD *)(*(_DWORD *)a1 + 4);
  for ( i = *(_DWORD *)(*(_DWORD *)a1 + 4); i; i = *(_DWORD *)(i + 4) )
  {
    sub_8074842(*(size_t **)i, a2);
    result = *(_DWORD *)(i + 4);
  }
  return result;
}

//----- (08074B34) --------------------------------------------------------
void __cdecl sub_8074B34(int a1, _DWORD *a2, size_t *a3)
{
  sub_806E69A(a2, a3);
  sub_8074AF6(a1, (signed int *)*a3);
  sub_806E94E((int)a3, 1, a2);
}

//----- (08074B7C) --------------------------------------------------------
char *__cdecl sub_8074B7C(int a1, int a2, int a3, int *a4)
{
  char *result; // eax
  int v5; // ST10_4
  char *v6; // [esp+14h] [ebp-4h]

  if ( dword_8202A68 )
    return sub_8077FFE(a2, "cannot recurse /#");
  v6 = (char *)dword_839403C;
  sub_806EA5A(a3, (_DWORD *)*a4);
  if ( byte_839400B )
  {
    dword_8202A68 = 1;
    sub_8074A7A(a1, 0, 0, (_DWORD *)*a4);
    sub_806E53A((_DWORD *)*a4, *a4);
  }
  else
  {
    v5 = sub_8079C94(0);
    dword_8202A68 = 2;
    sub_8074A7A(a1, 0, 0, (_DWORD *)*a4);
    sub_8079CF0(v5);
  }
  dword_8202A68 = 0;
  result = v6;
  dword_839403C = (int)v6;
  return result;
}
// 8202A68: using guessed type int dword_8202A68;
// 839400B: using guessed type char byte_839400B;
// 839403C: using guessed type int dword_839403C;

//----- (08074C6A) --------------------------------------------------------
void __cdecl sub_8074C6A(int *a1, int a2, int a3)
{
  sub_8073398(*a1, a3);
  sub_806DAD8(53, 0, 0);
  sub_8076D92(a2, 0);
}

//----- (08074CB6) --------------------------------------------------------
int __cdecl sub_8074CB6(int *a1, _DWORD *a2)
{
  return sub_80733DA(*a1, a2);
}

//----- (08074CD2) --------------------------------------------------------
char *__cdecl sub_8074CD2(char **a1)
{
  char *result; // eax
  int v2; // eax
  signed int v3; // [esp+1Ch] [ebp-Ch]
  int v4; // [esp+24h] [ebp-4h]

  result = *a1;
  v3 = (signed int)*a1;
  if ( *a1 == (char *)69 )
  {
    if ( byte_820287D )
    {
      result = sub_8077FFE((int)a1[1], "cannot recurse /#");
    }
    else
    {
      byte_820287D = 1;
      result = a1[1];
      dword_8202880 = (int)a1[1];
    }
  }
  else if ( v3 > 69 )
  {
    if ( v3 == 70 )
    {
      if ( byte_820287D )
        byte_820287D = 0;
      else
        result = sub_8077FFE((int)a1[1], "#/ has no matching /#");
    }
  }
  else if ( v3 == 68 && (!byte_820287D || byte_839400B) )
  {
    v2 = sub_807C0A8(dword_8202868, (unsigned int)a1[1]);
    v4 = sub_807CA86(v2);
    if ( byte_820287D )
      result = (char *)sub_8070B86(v4, (int)a1[1], (int)a1[4], 12);
    else
      result = (char *)sub_8070B86(v4, (int)a1[1], (int)a1[4], 7);
  }
  return result;
}
// 8202868: using guessed type int dword_8202868;
// 820287D: using guessed type char byte_820287D;
// 839400B: using guessed type char byte_839400B;

//----- (08074DEE) --------------------------------------------------------
char *__cdecl sub_8074DEE(int a1, int a2, int a3, int a4, _DWORD *a5)
{
  char *result; // eax

  dword_820286C = a1;
  sub_8077016(a3);
  dword_8202870 = 0;
  dword_8202874 = 0;
  dword_8202878 = 0;
  sub_806DA94(*(_DWORD *)(a2 + 4), 2u);
  sub_8074C6A(*(int **)(a2 + 8), a3, (int)a5);
  sub_8074A7A(*(_DWORD *)(a2 + 12), 1, a4, a5);
  sub_806DEC6();
  sub_8076D92(a4, 1);
  sub_8076D92(-2, 0);
  result = (char *)(dword_8202874 + 32 * dword_8202878);
  if ( (signed int)result > 2047 )
    result = sub_8077FFE(a3, "function exceeds operand stack size");
  return result;
}
// 820286C: using guessed type int dword_820286C;
// 8202870: using guessed type int dword_8202870;
// 8202874: using guessed type int dword_8202874;
// 8202878: using guessed type int dword_8202878;

//----- (08074ED8) --------------------------------------------------------
int __cdecl sub_8074ED8(int *a1, int a2, signed int **a3)
{
  byte_82028B0 = 0;
  *a3 = (signed int *)sub_80A9CF0(280);
  **a3 = 0;
  (*a3)[1] = 0;
  (*a3)[3] = 0;
  (*a3)[2] = 0;
  memset(*a3 + 4, 0, 8u);
  sub_8074CB6(a1, *a3);
  return sub_8074AF6(a2, *a3);
}
// 82028B0: using guessed type char byte_82028B0;

//----- (08074F74) --------------------------------------------------------
void __cdecl sub_8074F74(int a1)
{
  byte_8202886 = 0;
  dword_8202888 = 0;
  byte_820288C = 0;
  byte_820288D = 0;
  dword_8202890 = 0;
  byte_8202894 = 0;
  byte_8202895 = 0;
  dword_8202898 = 0;
  dword_820289C = 0;
  dword_82028A8 = 0;
  if ( *(_BYTE *)(a1 + 136325252) )
  {
    *(_BYTE *)(a1 + 136325252) = 0;
    sub_806DEC6();
    sub_8076D92(0, 0);
    sub_8076D92(-2, 0);
  }
}
// 8202886: using guessed type char byte_8202886;
// 8202888: using guessed type int dword_8202888;
// 820288C: using guessed type char byte_820288C;
// 820288D: using guessed type char byte_820288D;
// 8202890: using guessed type int dword_8202890;
// 8202894: using guessed type char byte_8202894;
// 8202895: using guessed type char byte_8202895;
// 8202898: using guessed type int dword_8202898;
// 820289C: using guessed type int dword_820289C;
// 82028A8: using guessed type int dword_82028A8;

//----- (0807501A) --------------------------------------------------------
char *__cdecl sub_807501A(int *a1, _DWORD **a2)
{
  int v2; // eax
  int v3; // ST14_4
  int v4; // ST04_4

  sub_8074F74(0);
  v2 = sub_807BB34(dword_8202868, a1[1]);
  v3 = sub_807CB1E(v2);
  v4 = a1[4];
  sub_8070C7A(v3);
  return sub_8074DEE(v3, (int)a1, a1[4], a1[5], *a2);
}
// 8202868: using guessed type int dword_8202868;

//----- (0807509C) --------------------------------------------------------
char *__cdecl sub_807509C(int *a1, _DWORD **a2)
{
  int v2; // ST1C_4
  int v3; // ST24_4
  char *result; // eax
  int v5; // eax
  int v6; // ST20_4
  int v7; // ST04_4

  if ( byte_839400B )
  {
    dword_8202A68 = 1;
    sub_8074F74(1);
    v5 = sub_807BB34(dword_8202868, a1[1]);
    v6 = sub_807CB1E(v5);
    v7 = a1[4];
    sub_8070C7A(v6);
    result = sub_8074DEE(v6, (int)a1, a1[4], a1[5], *a2);
  }
  else
  {
    v2 = sub_8079C94(0);
    v3 = dword_839403C;
    dword_8202A68 = 2;
    sub_8074F74(1);
    sub_8074DEE(0, (int)a1, a1[4], a1[5], *a2);
    sub_8079CF0(v2);
    result = (char *)v3;
    dword_839403C = v3;
  }
  dword_8202A68 = 0;
  return result;
}
// 8202868: using guessed type int dword_8202868;
// 8202A68: using guessed type int dword_8202A68;
// 839400B: using guessed type char byte_839400B;
// 839403C: using guessed type int dword_839403C;

//----- (080751B4) --------------------------------------------------------
char *__cdecl sub_80751B4(int a1)
{
  char *result; // eax
  char *v2; // eax
  signed int v3; // [esp+14h] [ebp-4h]

  result = *(char **)a1;
  v3 = *(_DWORD *)a1;
  if ( *(_DWORD *)a1 == 69 )
  {
    byte_820287D = 1;
  }
  else if ( v3 > 69 )
  {
    if ( v3 == 70 )
    {
      byte_820287D = 0;
    }
    else if ( v3 == 71 )
    {
      if ( byte_820287D )
      {
        result = sub_8077FFE(*(_DWORD *)(a1 + 8), "cannot put #using_animtree inside /# ... #/ comment");
      }
      else
      {
        v2 = (char *)sub_8078896(*(_DWORD *)(a1 + 4));
        sub_806D55A(v2, *(_DWORD *)(a1 + 12));
        result = (char *)sub_806D9EC(*(_DWORD *)(a1 + 4));
      }
    }
  }
  else if ( v3 == 68 )
  {
    sub_8074ED8(*(int **)(a1 + 8), *(_DWORD *)(a1 + 12), (signed int **)(a1 + 24));
    if ( byte_820287D )
      result = sub_807509C((int *)a1, (_DWORD **)(a1 + 24));
    else
      result = sub_807501A((int *)a1, (_DWORD **)(a1 + 24));
  }
  return result;
}
// 820287D: using guessed type char byte_820287D;

//----- (080752BA) --------------------------------------------------------
int __cdecl sub_80752BA(int a1)
{
  int result; // eax
  int i; // [esp+14h] [ebp-4h]
  int *j; // [esp+14h] [ebp-4h]

  byte_820287D = 0;
  for ( i = *(_DWORD *)(*(_DWORD *)a1 + 4); i; i = *(_DWORD *)(i + 4) )
    sub_8074CD2(*(char ***)i);
  if ( byte_820287D )
    sub_8077FFE(dword_8202880, "/# has no matching #/");
  byte_8202884 = 1;
  byte_8202885 = 1;
  result = *(_DWORD *)(*(_DWORD *)a1 + 4);
  for ( j = *(int **)(*(_DWORD *)a1 + 4); j; j = (int *)j[1] )
  {
    sub_80751B4(*j);
    result = j[1];
  }
  return result;
}
// 820287D: using guessed type char byte_820287D;
// 8202884: using guessed type char byte_8202884;
// 8202885: using guessed type char byte_8202885;

//----- (08075354) --------------------------------------------------------
int __cdecl sub_8075354(int a1)
{
  char *v1; // eax
  int v2; // ST14_4

  v1 = (char *)sub_8078896(*(_DWORD *)(a1 + 4));
  v2 = sub_8079C2A(v1);
  sub_806D9EC(*(_DWORD *)(a1 + 4));
  return sub_806FA70(v2, *(_DWORD *)(a1 + 8), 1);
}

//----- (080753A6) --------------------------------------------------------
int __cdecl sub_80753A6(int a1)
{
  int result; // eax
  int *i; // [esp+4h] [ebp-4h]

  result = *(_DWORD *)(*(_DWORD *)a1 + 4);
  for ( i = *(int **)(*(_DWORD *)a1 + 4); i; i = (int *)i[1] )
  {
    sub_8075354(*i);
    result = i[1];
  }
  return result;
}

//----- (080753DE) --------------------------------------------------------
char *__cdecl sub_80753DE(int *a1, int a2, int a3)
{
  char *v3; // eax
  int v4; // eax
  unsigned __int16 v6; // ax
  int v7; // eax
  __int16 *v8; // ebx
  void *v9; // [esp+1Ch] [ebp-5Ch]
  int v10; // [esp+20h] [ebp-58h]
  int v11; // [esp+24h] [ebp-54h]
  int v12; // [esp+28h] [ebp-50h]
  int v13; // [esp+2Ch] [ebp-4Ch]
  int v14; // [esp+30h] [ebp-48h]
  int v15; // [esp+34h] [ebp-44h]
  int v16; // [esp+38h] [ebp-40h]
  unsigned __int16 v17; // [esp+3Eh] [ebp-3Ah]
  char v18; // [esp+40h] [ebp-38h]
  int v19; // [esp+44h] [ebp-34h]
  int v20; // [esp+48h] [ebp-30h]
  int k; // [esp+4Ch] [ebp-2Ch]
  int v22; // [esp+50h] [ebp-28h]
  unsigned __int16 *v23; // [esp+54h] [ebp-24h]
  char *v24; // [esp+58h] [ebp-20h]
  unsigned __int16 v25; // [esp+5Eh] [ebp-1Ah]
  int v26; // [esp+60h] [ebp-18h]
  int j; // [esp+64h] [ebp-14h]
  int i; // [esp+68h] [ebp-10h]
  void *ptr; // [esp+6Ch] [ebp-Ch]

  dword_8202868 = a2;
  byte_820287C = 0;
  dword_8202854 = 0;
  dword_8202A68 = 0;
  if ( dword_8202A44 )
    v9 = Z_MallocInternal(12 * dword_8202A44);
  else
    v9 = 0;
  ptr = v9;
  dword_82028B4 = (int)v9;
  if ( v9 )
  {
    *((_DWORD *)ptr + 2) = dword_82028B8;
    dword_82028B8 = (int)ptr;
  }
  sub_80753A6(*a1);
  sub_80752BA(a1[1]);
  dword_8202A70 = sub_8079C94(0) - dword_8394048;
  sub_80A9DB4();
  v26 = dword_8202A44;
  for ( i = 0; i < v26; ++i )
  {
    v24 = (char *)ptr + 12 * i;
    v25 = *((_WORD *)ptr + 6 * i);
    v3 = (char *)sub_8078896(v25);
    v22 = sub_8075C54(v3);
    if ( !v22 )
    {
      v4 = sub_8078896(v25);
      return sub_8077FFE(*((_DWORD *)v24 + 1), "Could not find script '%s'", v4);
    }
    sub_80796A2(v25);
    if ( v24[2] )
    {
      for ( j = i + 1; j < v26; ++j )
      {
        v23 = (unsigned __int16 *)((char *)ptr + 12 * j);
        if ( !*((_BYTE *)ptr + 12 * j + 2) )
          break;
        if ( *v23 == v25 )
          return sub_8077FFE(*((_DWORD *)v23 + 1), "Duplicate #include");
      }
      v24[2] = 0;
      for ( k = sub_807C9CE(v22); k; k = sub_807C9CE(k) )
      {
        if ( sub_807DF7C(k) == 1 )
        {
          v20 = sub_807CB1E(k);
          v16 = sub_807BB34(v20, 1);
          if ( v16 )
          {
            sub_807C66A(&v10, v16);
            v14 = v10;
            v15 = v11;
            if ( v11 != 13 )
            {
              v6 = sub_807CA72(k);
              v17 = v6;
              v7 = sub_807C0A8(a2, v6);
              v13 = sub_807CA86(v7);
              v12 = sub_8070B86(v13, v17, *((_DWORD *)v24 + 1), 13);
              v8 = sub_807C4FC(v12);
              *(_DWORD *)v8 = *(_DWORD *)sub_807C4FC(v16);
              sub_807098C(v13, &v14, 0);
            }
          }
        }
      }
    }
  }
  if ( ptr )
  {
    dword_82028B8 = *((_DWORD *)ptr + 2);
    Z_FreeInternal(ptr);
  }
  sub_8070AA8(a2);
  v19 = 6;
  return (char *)sub_807C45C(a3, (int *)&v18);
}
// 8202854: using guessed type int dword_8202854;
// 8202868: using guessed type int dword_8202868;
// 820287C: using guessed type char byte_820287C;
// 82028B4: using guessed type int dword_82028B4;
// 82028B8: using guessed type int dword_82028B8;
// 8202A44: using guessed type int dword_8202A44;
// 8202A68: using guessed type int dword_8202A68;
// 8202A70: using guessed type int dword_8202A70;
// 8394048: using guessed type int dword_8394048;

//----- (08075710) --------------------------------------------------------
int __cdecl sub_8075710(int a1)
{
  sub_80742D2(a1, 0, 0, 0);
  return sub_806DAD8(128, 0, 0);
}

//----- (08075758) --------------------------------------------------------
void sub_8075758()
{
  void *ptr; // ST04_4

  while ( dword_82028B8 )
  {
    ptr = (void *)dword_82028B8;
    dword_82028B8 = *(_DWORD *)(dword_82028B8 + 8);
    Z_FreeInternal(ptr);
  }
}
// 82028B8: using guessed type int dword_82028B8;

//----- (0807578C) --------------------------------------------------------
int __cdecl sub_807578C(int *a1)
{
  return sub_807BA14(a1[1], *a1);
}

//----- (080757AC) --------------------------------------------------------
int __cdecl sub_80757AC(_DWORD *a1)
{
  return sub_807BA64(a1[1], *a1);
}

//----- (080757CC) --------------------------------------------------------
_BOOL4 __cdecl sub_80757CC(int a1)
{
  return a1 - dword_8394048 < (unsigned int)dword_8202A70;
}
// 8202A70: using guessed type int dword_8202A70;
// 8394048: using guessed type int dword_8394048;

//----- (08075828) --------------------------------------------------------
signed int __cdecl sub_8075828(_BYTE *a1)
{
  while ( *a1 )
  {
    if ( !(*(_WORD *)(_ctype_b + 2 * (char)*a1) & 8) && *a1 != 95 )
      return 0;
    ++a1;
  }
  return 1;
}
// 8185A64: using guessed type int _ctype_b;

//----- (08075874) --------------------------------------------------------
int __cdecl sub_8075874(int a1, char *s)
{
  int v4; // [esp+10h] [ebp-38h]
  int v5; // [esp+14h] [ebp-34h]
  int v6; // [esp+18h] [ebp-30h]
  int v7; // [esp+1Ch] [ebp-2Ch]
  int v8; // [esp+20h] [ebp-28h]
  int v9; // [esp+24h] [ebp-24h]
  int v10; // [esp+2Ch] [ebp-1Ch]
  int v11; // [esp+30h] [ebp-18h]
  int v12; // [esp+34h] [ebp-14h]
  int v13; // [esp+38h] [ebp-10h]
  int v14; // [esp+3Ch] [ebp-Ch]
  int v15; // [esp+40h] [ebp-8h]
  int v16; // [esp+44h] [ebp-4h]

  v11 = sub_8079C2A((char *)a1);
  v16 = sub_807BB34(dword_8202A4C, v11);
  sub_80796A2(v11);
  if ( !v16 )
    return 0;
  v14 = sub_807CB1E(v16);
  v13 = sub_8078CEA(s);
  if ( !v13 )
    return 0;
  v15 = sub_807BB34(v14, v13);
  if ( !v15 )
    return 0;
  if ( sub_807DF7C(v15) != 1 )
    return 0;
  v7 = sub_807CB1E(v15);
  v6 = sub_807BB34(v7, 1);
  sub_807C66A(&v4, v6);
  v8 = v4;
  v9 = v5;
  v10 = v4;
  if ( !sub_80757CC(v4) )
    return 0;
  v12 = v10 - dword_8394048;
  return v10 - dword_8394048;
}
// 8202A4C: using guessed type int dword_8202A4C;
// 8394048: using guessed type int dword_8394048;

//----- (080759A6) --------------------------------------------------------
void *sub_80759A6()
{
  void *result; // eax

  dword_8394004 = sub_80A9B52();
  result = Hunk_AllocInternal(0x20000u);
  dword_8202A58 = (int)result;
  word_8394008 = 0;
  return result;
}
// 8202A58: using guessed type int dword_8202A58;
// 8394004: using guessed type int dword_8394004;
// 8394008: using guessed type __int16 word_8394008;

//----- (080759D2) --------------------------------------------------------
unsigned int *sub_80759D2()
{
  dword_8202A58 = 0;
  return sub_80A9B5C(dword_8394004);
}
// 8202A58: using guessed type int dword_8202A58;
// 8394004: using guessed type int dword_8394004;

//----- (080759F2) --------------------------------------------------------
int __cdecl sub_80759F2(int a1)
{
  sub_80794D8(a1, 2u);
  if ( *(_WORD *)(dword_8202A58 + 2 * a1) )
    return *(unsigned __int16 *)(dword_8202A58 + 2 * a1);
  *(_WORD *)(dword_8202A58 + 2 * a1) = ++word_8394008;
  return (unsigned __int16)word_8394008;
}
// 8202A58: using guessed type int dword_8202A58;
// 8394008: using guessed type __int16 word_8394008;

//----- (08075A60) --------------------------------------------------------
int __cdecl sub_8075A60(void *s2)
{
  int v1; // edx
  int v2; // eax

  v1 = 2 * sub_8078CC6(s2);
  if ( *(_WORD *)(dword_8202A58 + v1) )
    return *(unsigned __int16 *)(dword_8202A58 + v1);
  v2 = sub_8079290((char *)s2, 0);
  return sub_80759F2(v2);
}
// 8202A58: using guessed type int dword_8202A58;

//----- (08075ABA) --------------------------------------------------------
void sub_8075ABA()
{
  byte_8202A64 = 1;
  sub_8076B9C();
  dword_8202A48 = sub_807B658();
  dword_8202A4C = sub_807B658();
  dword_8202A50 = sub_807B658();
  dword_8202A54 = sub_807B658();
  dword_8394048 = (int)sub_80A9DC4(0);
  dword_8202A70 = 0;
  dword_839404C = 0;
  sub_80759A6();
  dword_8394000 = 0;
  dword_8202A40 = 0;
  sub_807F810();
  dword_8202A74 = 0;
  sub_8075B72(1);
  sub_8079C84();
}
// 8202A40: using guessed type int dword_8202A40;
// 8202A48: using guessed type int dword_8202A48;
// 8202A4C: using guessed type int dword_8202A4C;
// 8202A50: using guessed type int dword_8202A50;
// 8202A54: using guessed type int dword_8202A54;
// 8202A64: using guessed type char byte_8202A64;
// 8202A70: using guessed type int dword_8202A70;
// 8202A74: using guessed type int dword_8202A74;
// 8394000: using guessed type int dword_8394000;
// 8394048: using guessed type int dword_8394048;
// 839404C: using guessed type int dword_839404C;

//----- (08075B54) --------------------------------------------------------
int sub_8075B54()
{
  int result; // eax

  byte_8202A64 = 1;
  sub_8076B9C();
  result = sub_807B658();
  dword_8202A48 = result;
  return result;
}
// 8202A48: using guessed type int dword_8202A48;
// 8202A64: using guessed type char byte_8202A64;

//----- (08075B72) --------------------------------------------------------
int __cdecl sub_8075B72(int a1)
{
  int result; // eax

  byte_8202858 = 1;
  dword_820284C[a1] = 0;
  dword_820244C[128 * a1] = 0;
  result = sub_807B658();
  dword_8202440 = result;
  dword_8202444 = 0;
  dword_8202A68 = 0;
  return result;
}
// 8202440: using guessed type int dword_8202440;
// 820284C: using guessed type int dword_820284C[];
// 8202858: using guessed type char byte_8202858;
// 8202A68: using guessed type int dword_8202A68;

//----- (08075BBE) --------------------------------------------------------
int __cdecl sub_8075BBE(int a1, int a2)
{
  char v2; // al
  int i; // [esp+0h] [ebp-8h]
  char v5; // [esp+7h] [ebp-1h]

  v5 = 42;
  for ( i = 0; i < a2; ++i )
  {
    v2 = *(_BYTE *)dword_8202A5C++;
    v5 = v2;
    if ( !v2 || v2 == 10 )
      break;
    *(_BYTE *)(i + a1) = v2;
  }
  if ( v5 == 10 )
  {
    *(_BYTE *)(a1 + i++) = 10;
  }
  else if ( !v5 )
  {
    if ( dword_8202A60 )
    {
      dword_8202A5C = dword_8202A60;
      dword_8202A60 = 0;
    }
    else
    {
      --dword_8202A5C;
    }
  }
  return i;
}
// 8202A5C: using guessed type int dword_8202A5C;
// 8202A60: using guessed type int dword_8202A60;

//----- (08075C54) --------------------------------------------------------
int __cdecl sub_8075C54(char *a1)
{
  int v1; // eax
  int v2; // ebx
  int v3; // eax
  int v4; // ST2C_4
  int v5; // eax
  int v6; // ST20_4
  int v8; // [esp+14h] [ebp-74h]
  int v9; // [esp+18h] [ebp-70h]
  int v10; // [esp+1Ch] [ebp-6Ch]
  int v11; // [esp+24h] [ebp-64h]
  int v12; // [esp+28h] [ebp-60h]
  char s; // [esp+30h] [ebp-58h]
  int v14; // [esp+74h] [ebp-14h]
  int *v15; // [esp+78h] [ebp-10h]
  size_t v16; // [esp+7Ch] [ebp-Ch]

  v14 = sub_8079C2A(a1);
  if ( sub_807BB34(dword_8202A48, v14) )
  {
    sub_80796A2(v14);
    v10 = sub_807BB34(dword_8202A4C, v14);
    if ( v10 )
      v8 = sub_807CB1E(v10);
    else
      v8 = 0;
    v9 = v8;
  }
  else
  {
    v11 = sub_807C0CC(dword_8202A48, v14);
    sub_80796A2(v14);
    v1 = sub_8078896(v14);
    Com_sprintf(&s, 0x40u, "%s.gsc", v1);
    v12 = *(_DWORD *)dword_8283EE0;
    v2 = sub_8079C94(0);
    v3 = sub_8078896(v14);
    v16 = sub_807799E(v3, &s, v2, 1);
    if ( v16 )
    {
      dword_8202448 = 0;
      dword_8202A44 = 0;
      v4 = *(_DWORD *)dword_8283EDC;
      *(_DWORD *)dword_8283EDC = &s;
      dword_8202A5C = (int)"+";
      dword_8202A60 = v16;
      sub_808724F(&v15, 0);
      v5 = sub_807C0A8(dword_8202A4C, v14);
      v6 = sub_807CA86(v5);
      sub_80753DE(v15, v6, v11);
      *(_DWORD *)dword_8283EDC = v4;
      *(_DWORD *)dword_8283EE0 = v12;
      v9 = v6;
    }
    else
    {
      v9 = 0;
    }
  }
  return v9;
}
// 8202448: using guessed type int dword_8202448;
// 8202A44: using guessed type int dword_8202A44;
// 8202A48: using guessed type int dword_8202A48;
// 8202A4C: using guessed type int dword_8202A4C;
// 8202A5C: using guessed type int dword_8202A5C;
// 8202A60: using guessed type int dword_8202A60;

//----- (08075E10) --------------------------------------------------------
int sub_8075E10()
{
  return sub_80A9ECE();
}

//----- (08075E1E) --------------------------------------------------------
int sub_8075E1E()
{
  int result; // eax

  sub_80759D2();
  sub_8079910(2u);
  byte_8202A64 = 0;
  sub_807AF82(dword_8202A48);
  sub_807B7DC(dword_8202A48);
  dword_8202A48 = 0;
  sub_807AF82(dword_8202A4C);
  sub_807B7DC(dword_8202A4C);
  dword_8202A4C = 0;
  sub_807AF82(dword_8202A50);
  sub_807B7DC(dword_8202A50);
  dword_8202A50 = 0;
  sub_807AF82(dword_8202A54);
  result = sub_807B7DC(dword_8202A54);
  dword_8202A54 = 0;
  return result;
}
// 8202A48: using guessed type int dword_8202A48;
// 8202A4C: using guessed type int dword_8202A4C;
// 8202A50: using guessed type int dword_8202A50;
// 8202A54: using guessed type int dword_8202A54;
// 8202A64: using guessed type char byte_8202A64;

//----- (08075ECE) --------------------------------------------------------
int __cdecl sub_8075ECE(int a1, int a2)
{
  int result; // eax
  int i; // [esp+14h] [ebp-4h]

  for ( i = 1; ; ++i )
  {
    result = i;
    if ( i > dword_820284C[a2] )
      break;
    sub_806D668(i, a1, a2);
  }
  return result;
}
// 820284C: using guessed type int dword_820284C[];

//----- (08075F0E) --------------------------------------------------------
void *sub_8075F0E()
{
  void *result; // eax

  sub_807AF82(dword_8202440);
  sub_807B7DC(dword_8202440);
  dword_8202440 = 0;
  if ( dword_8202444 )
    sub_807B7DC(dword_8202444);
  sub_8079910(2u);
  result = sub_80A9DC4(0);
  dword_839404C = (int)result;
  byte_8202858 = 0;
  return result;
}
// 8202440: using guessed type int dword_8202440;
// 8202858: using guessed type char byte_8202858;
// 839404C: using guessed type int dword_839404C;

//----- (08075F74) --------------------------------------------------------
void sub_8075F74()
{
  if ( byte_8202A64 )
  {
    byte_8202A64 = 0;
    sub_8075E1E();
  }
  if ( byte_8202858 )
  {
    byte_8202858 = 0;
    sub_8075F0E();
  }
  sub_8079910(1u);
  sub_8076C84();
  dword_8394048 = 0;
  dword_8202A70 = 0;
  dword_839404C = 0;
  dword_839403C = 0;
}
// 8202858: using guessed type char byte_8202858;
// 8202A64: using guessed type char byte_8202A64;
// 8202A70: using guessed type int dword_8202A70;
// 839403C: using guessed type int dword_839403C;
// 8394048: using guessed type int dword_8394048;
// 839404C: using guessed type int dword_839404C;

//----- (08075FE8) --------------------------------------------------------
int __cdecl sub_8075FE8(int a1)
{
  int v1; // ebx

  if ( !a1 )
    return 0;
  v1 = sub_8075FE8(LOWORD(dword_8203B00[2 * a1]));
  return sub_8075FE8(HIWORD(dword_8203B00[2 * a1])) + v1 + 1;
}
// 8203B00: using guessed type int dword_8203B00[];

//----- (08076040) --------------------------------------------------------
void sub_8076040()
{
  int v0; // ST20_4
  int v1; // [esp+18h] [ebp-10h]
  char v2[4]; // [esp+24h] [ebp-4h]

  Com_Printf("********************************\n");
  v1 = *(_DWORD *)dword_8283E28;
  for ( *(_DWORD *)v2 = 0; *(_DWORD *)v2 <= 16; ++*(_DWORD *)v2 )
  {
    v0 = sub_8075FE8((unsigned __int16)word_8283E00[*(_DWORD *)v2]);
    v1 += v0 << v2[0];
    Com_Printf("%d subtree has %d * %d = %d free buckets\n", *(_DWORD *)v2, v0, 1 << v2[0], v0 << v2[0]);
  }
  Com_Printf("********************************\n");
  Com_Printf("********************************\n");
  Com_Printf("total memory alloc buckets: %d (%d instances)\n", *(_DWORD *)dword_8283E28, dword_8283E24);
  Com_Printf("total memory free buckets: %d\n", 0xFFFF - *(_DWORD *)dword_8283E28);
  Com_Printf("********************************\n");
}
// 8283E24: using guessed type int dword_8283E24;

//----- (08076134) --------------------------------------------------------
int *sub_8076134()
{
  int *result; // eax
  int j; // [esp+0h] [ebp-Ch]
  int l; // [esp+0h] [ebp-Ch]
  char v3; // [esp+4h] [ebp-8h]
  char k; // [esp+4h] [ebp-8h]
  char v5; // [esp+4h] [ebp-8h]
  int i; // [esp+8h] [ebp-4h]

  for ( i = 0; i <= 255; ++i )
  {
    v3 = 0;
    for ( j = i; j; j >>= 1 )
    {
      if ( j & 1 )
        ++v3;
    }
    *(_BYTE *)(i + 136854528) = v3;
    for ( k = 8; i & ((1 << k) - 1); --k )
      ;
    *(_BYTE *)(i + 136854272) = k;
    v5 = 0;
    for ( l = i; l; l >>= 1 )
      ++v5;
    *(_BYTE *)(i + 136854784) = v5;
    result = &i;
  }
  return result;
}

//----- (080761F6) --------------------------------------------------------
int __cdecl sub_80761F6(int a1)
{
  char v2; // [esp+8h] [ebp-8h]
  int v3; // [esp+18h] [ebp+8h]

  v3 = 0x10000 - a1;
  v2 = byte_8283B00[(unsigned __int8)v3];
  if ( !(_BYTE)v3 )
    v2 += byte_8283B00[BYTE1(v3)];
  return v3
       - ((unsigned __int8)byte_8283B00[BYTE1(v3) + 256]
        + (unsigned __int8)byte_8283B00[(unsigned __int8)v3 + 256])
       + (1 << v2);
}

//----- (0807626A) --------------------------------------------------------
int __cdecl sub_807626A(int a1, int a2)
{
  int v2; // edx
  int result; // eax
  signed int v4; // [esp+14h] [ebp-14h]
  int v5; // [esp+18h] [ebp-10h]
  int v6; // [esp+1Ch] [ebp-Ch]
  int *v7; // [esp+20h] [ebp-8h]
  int v8; // [esp+24h] [ebp-4h]

  v7 = (int *)(2 * a2 + 136855040);
  v8 = (unsigned __int16)word_8283E00[a2];
  if ( word_8283E00[a2] )
  {
    v6 = sub_80761F6(a1);
    v5 = 0;
    v4 = 0x10000;
    while ( sub_80761F6(v8) >= v6 )
    {
      v4 >>= 1;
      if ( a1 >= v5 )
      {
        v7 = (int *)(8 * v8 + 136329986);
        v5 += v4;
      }
      else
      {
        v7 = &dword_8203B00[2 * v8];
        v5 -= v4;
      }
      v8 = *(unsigned __int16 *)v7;
      if ( !*(_WORD *)v7 )
        goto LABEL_13;
    }
    while ( 1 )
    {
      *(_WORD *)v7 = a1;
      v2 = dword_8203B04[2 * v8];
      result = dword_8203B00[2 * v8];
      dword_8203B00[2 * a1] = result;
      dword_8203B04[2 * a1] = v2;
      if ( !v8 )
        break;
      v4 >>= 1;
      if ( v8 >= v5 )
      {
        v7 = (int *)(8 * a1 + 136329986);
        v5 += v4;
      }
      else
      {
        v7 = &dword_8203B00[2 * a1];
        v5 -= v4;
      }
      a1 = v8;
      v8 = *(unsigned __int16 *)v7;
    }
  }
  else
  {
LABEL_13:
    *(_WORD *)v7 = a1;
    LOWORD(dword_8203B00[2 * a1]) = 0;
    result = a1;
    HIWORD(dword_8203B00[2 * a1]) = 0;
  }
  return result;
}
// 8203B00: using guessed type int dword_8203B00[];

//----- (080763CA) --------------------------------------------------------
signed int __cdecl sub_80763CA(int a1, int a2)
{
  int v2; // ST2C_4
  int v3; // ST10_4
  int v4; // ST14_4
  int v7; // [esp+18h] [ebp-20h]
  int v8; // [esp+1Ch] [ebp-1Ch]
  signed int v9; // [esp+20h] [ebp-18h]
  int v10; // [esp+24h] [ebp-14h]
  int *v11; // [esp+30h] [ebp-8h]
  int i; // [esp+34h] [ebp-4h]
  int v13; // [esp+40h] [ebp+8h]

  v10 = 0;
  v9 = 0x10000;
  v11 = (int *)(2 * a2 + 136855040);
  for ( i = (unsigned __int16)word_8283E00[a2]; ; i = *(unsigned __int16 *)v11 )
  {
    if ( !i )
      return 0;
    if ( a1 == i )
      break;
    if ( a1 == v10 )
      return 0;
    v9 >>= 1;
    if ( a1 >= v10 )
    {
      v11 = (int *)(8 * i + 136329986);
      v10 += v9;
    }
    else
    {
      v11 = &dword_8203B00[2 * i];
      v10 -= v9;
    }
  }
  v7 = dword_8203B00[2 * a1];
  v8 = dword_8203B04[2 * a1];
  while ( (_WORD)v7 )
  {
    if ( HIWORD(v7) )
    {
      v2 = sub_80761F6((unsigned __int16)v7);
      if ( v2 >= sub_80761F6(HIWORD(v7)) )
      {
        v13 = (unsigned __int16)v7;
        *(_WORD *)v11 = v7;
        v11 = &dword_8203B00[2 * (unsigned __int16)v7];
      }
      else
      {
        v13 = HIWORD(v7);
        *(_WORD *)v11 = HIWORD(v7);
        v11 = (int *)(8 * HIWORD(v7) + 136329986);
      }
    }
    else
    {
      v13 = (unsigned __int16)v7;
      *(_WORD *)v11 = v7;
      v11 = &dword_8203B00[2 * (unsigned __int16)v7];
    }
LABEL_14:
    v3 = v7;
    v4 = v8;
    v7 = dword_8203B00[2 * v13];
    v8 = dword_8203B04[2 * v13];
    dword_8203B00[2 * v13] = v3;
    dword_8203B04[2 * v13] = v4;
  }
  v13 = HIWORD(v7);
  *(_WORD *)v11 = HIWORD(v7);
  if ( HIWORD(v7) )
  {
    v11 = (int *)(8 * HIWORD(v7) + 136329986);
    goto LABEL_14;
  }
  return 1;
}
// 8203B00: using guessed type int dword_8203B00[];

//----- (080765A0) --------------------------------------------------------
int __cdecl sub_80765A0(int a1)
{
  int v1; // ST24_4
  int result; // eax
  int v3; // ST1C_4
  int v4; // ST08_4
  int v5; // ST0C_4
  int v6; // [esp+10h] [ebp-18h]
  int v7; // [esp+14h] [ebp-14h]
  int *v8; // [esp+20h] [ebp-8h]
  int v9; // [esp+24h] [ebp-4h]

  v8 = (int *)(2 * a1 + 136855040);
  v1 = (unsigned __int16)word_8283E00[a1];
  v6 = dword_8203B00[2 * v1];
  v7 = dword_8203B04[2 * v1];
  while ( (_WORD)v6 )
  {
    if ( HIWORD(v6) )
    {
      v3 = sub_80761F6((unsigned __int16)v6);
      if ( v3 >= sub_80761F6(HIWORD(v6)) )
      {
        v9 = (unsigned __int16)v6;
        *(_WORD *)v8 = v6;
        v8 = &dword_8203B00[2 * (unsigned __int16)v6];
      }
      else
      {
        v9 = HIWORD(v6);
        *(_WORD *)v8 = HIWORD(v6);
        v8 = (int *)(8 * HIWORD(v6) + 136329986);
      }
    }
    else
    {
      v9 = (unsigned __int16)v6;
      *(_WORD *)v8 = v6;
      v8 = &dword_8203B00[2 * (unsigned __int16)v6];
    }
LABEL_10:
    v4 = v6;
    v5 = v7;
    v6 = dword_8203B00[2 * v9];
    v7 = dword_8203B04[2 * v9];
    dword_8203B00[2 * v9] = v4;
    dword_8203B04[2 * v9] = v5;
  }
  v9 = HIWORD(v6);
  result = HIWORD(v6);
  *(_WORD *)v8 = HIWORD(v6);
  if ( HIWORD(v6) )
  {
    v8 = (int *)(8 * HIWORD(v6) + 136329986);
    goto LABEL_10;
  }
  return result;
}
// 8203B00: using guessed type int dword_8203B00[];

//----- (080766E6) --------------------------------------------------------
int *sub_80766E6()
{
  int *result; // eax
  int i; // [esp+14h] [ebp-4h]

  dword_8283E80 = (int)dword_8203B00;
  result = sub_8076134();
  for ( i = 0; i <= 16; ++i )
  {
    word_8283E00[i] = 0;
    result = &i;
  }
  dword_8203B00[0] = 0;
  for ( i = 0; i <= 15; ++i )
  {
    sub_807626A(1 << i, i);
    result = &i;
  }
  dword_8283E24 = 0;
  *(_DWORD *)dword_8283E28 = 0;
  return result;
}
// 8203B00: using guessed type int dword_8203B00[];
// 8283E24: using guessed type int dword_8283E24;
// 8283E80: using guessed type int dword_8283E80;

//----- (08076776) --------------------------------------------------------
void __cdecl sub_8076776(int a1, int a2)
{
  sub_8076040();
  Com_Printf("%s: failed memory allocation of %d bytes for script usage\n", a1, a2);
  sub_8084DF0((int)"failed memory allocation for script usage");
}

//----- (080767AA) --------------------------------------------------------
int __cdecl sub_80767AA(int a1)
{
  int v2; // [esp+8h] [ebp-10h]
  int v3; // [esp+10h] [ebp-8h]
  int v4; // [esp+14h] [ebp-4h]

  if ( a1 > 0xFFFF )
  {
    sub_8076776((int)"MT_GetSize: max allocation exceeded", a1);
    v3 = 0;
  }
  else
  {
    v4 = (a1 + 7) / 8 - 1;
    if ( v4 > 255 )
      v2 = (unsigned __int8)byte_8283D00[v4 >> 8] + 8;
    else
      v2 = (unsigned __int8)byte_8283D00[(a1 + 7) / 8 - 1];
    v3 = v2;
  }
  return v3;
}

//----- (0807682A) --------------------------------------------------------
int __cdecl sub_807682A(int a1)
{
  int i; // [esp+Ch] [ebp-Ch]
  int v4; // [esp+10h] [ebp-8h]
  int v5; // [esp+14h] [ebp-4h]

  v4 = sub_80767AA(a1);
  for ( i = v4; ; ++i )
  {
    if ( i > 16 )
    {
      sub_8076776((int)"MT_AllocIndex", a1);
      return 0;
    }
    v5 = (unsigned __int16)word_8283E00[i];
    if ( word_8283E00[i] )
      break;
  }
  sub_80765A0(i);
  while ( i != v4 )
  {
    --i;
    sub_807626A(v5 + (1 << i), i);
  }
  ++dword_8283E24;
  *(_DWORD *)dword_8283E28 += 1 << v4;
  return (unsigned __int16)v5;
}
// 8283E24: using guessed type int dword_8283E24;

//----- (080768E2) --------------------------------------------------------
int __cdecl sub_80768E2(int a1, int a2)
{
  int v3; // [esp+10h] [ebp-8h]
  signed int v4; // [esp+14h] [ebp-4h]

  v3 = sub_80767AA(a2);
  --dword_8283E24;
  *(_DWORD *)dword_8283E28 -= 1 << v3;
  while ( 1 )
  {
    v4 = 1 << v3;
    if ( v3 == 16 || !(unsigned __int8)sub_80763CA(a1 ^ v4, v3) )
      break;
    a1 &= ~v4;
    ++v3;
  }
  return sub_807626A(a1, v3);
}
// 8283E24: using guessed type int dword_8283E24;

//----- (08076960) --------------------------------------------------------
int __cdecl sub_8076960(int a1)
{
  int i; // [esp+Ch] [ebp-Ch]
  int v3; // [esp+Ch] [ebp-Ch]
  int v4; // [esp+10h] [ebp-8h]
  int v5; // [esp+10h] [ebp-8h]
  signed int v6; // [esp+14h] [ebp-4h]

  v4 = 0;
  for ( i = a1; ; i &= ~(1 << v4++) )
  {
    if ( (unsigned __int8)sub_80763CA(i, v4) )
      return sub_807626A(i, v4);
    if ( v4 == 16 )
      break;
  }
  v5 = 0;
  v3 = a1;
  while ( 1 )
  {
    v6 = 1 << v5;
    if ( v5 == 16 || !(unsigned __int8)sub_80763CA(v3 ^ v6, v5) )
      break;
    v3 &= ~v6;
    ++v5;
  }
  return sub_807626A(v3, v5);
}

//----- (08076A2A) --------------------------------------------------------
int __cdecl sub_8076A2A(int a1)
{
  return 8 * (unsigned __int16)sub_807682A(a1) + 136329984;
}

//----- (08076A50) --------------------------------------------------------
int __cdecl sub_8076A50(int a1, int a2)
{
  return sub_80768E2((a1 - (signed int)dword_8203B00) >> 3, a2);
}
// 8203B00: using guessed type int dword_8203B00[];

//----- (08076A72) --------------------------------------------------------
void *sub_8076A72()
{
  dword_8283E24 = 0;
  *(_DWORD *)dword_8283E28 = 0;
  return sub_80A9362(0x2000u);
}
// 8283E24: using guessed type int dword_8283E24;

//----- (08076A9A) --------------------------------------------------------
signed int __cdecl sub_8076A9A(int a1, unsigned int a2, int a3)
{
  int v3; // eax
  signed int result; // eax
  int v5; // [esp+4h] [ebp-14h]
  int v6; // [esp+8h] [ebp-10h]

  v3 = sub_80767AA(a3);
  v6 = v3;
  ++dword_8283E24;
  v5 = 1 << v3;
  result = 1 << v3;
  *(_DWORD *)dword_8283E28 += result;
  while ( v5 )
  {
    *(_BYTE *)((a2 >> 3) + a1) |= 1 << (a2 & 7);
    ++a2;
    result = (signed int)&v5;
    --v5;
  }
  return result;
}
// 8283E24: using guessed type int dword_8283E24;

//----- (08076B14) --------------------------------------------------------
void __cdecl sub_8076B14(void *ptr)
{
  int i; // [esp+4h] [ebp-4h]

  for ( i = 1; i <= 0xFFFF; ++i )
  {
    if ( !(((signed int)*((unsigned __int8 *)ptr + (i >> 3)) >> (i & 7)) & 1) )
      sub_8076960(i);
  }
  sub_80A9268(ptr);
}

//----- (08076B6C) --------------------------------------------------------
_BOOL4 __cdecl sub_8076B6C(int a1, int a2)
{
  int v2; // ST04_4

  v2 = sub_80767AA(a1);
  return v2 >= sub_80767AA(a2);
}

//----- (08076B9C) --------------------------------------------------------
void sub_8076B9C()
{
  if ( byte_839400A )
  {
    dword_8283ECC = -1;
    dword_8283EA4 = 0x10000;
    dword_8283EA8 = 0;
    dword_8283EA0 = Z_MallocInternal(0x140000u);
    memset(dword_8283EA0, 0, 20 * dword_8283EA4);
    dword_8283EB0 = 0x10000;
    dword_8283EB4 = 0;
    dword_8283EAC = Z_MallocInternal(0x80000u);
    dword_8283EBC = 0;
    dword_8283EC0 = 0;
    dword_8283EB8 = 16;
    dword_8283ED8 = 0;
    dword_8283ED4 = Z_MallocInternal(0x180u);
  }
}
// 8283EA4: using guessed type int dword_8283EA4;
// 8283EA8: using guessed type int dword_8283EA8;
// 8283EB0: using guessed type int dword_8283EB0;
// 8283EB4: using guessed type int dword_8283EB4;
// 8283EB8: using guessed type int dword_8283EB8;
// 8283EBC: using guessed type int dword_8283EBC;
// 8283EC0: using guessed type int dword_8283EC0;
// 8283ECC: using guessed type int dword_8283ECC;
// 8283ED8: using guessed type int dword_8283ED8;
// 839400A: using guessed type char byte_839400A;

//----- (08076C84) --------------------------------------------------------
void sub_8076C84()
{
  unsigned int i; // [esp+4h] [ebp-4h]
  int j; // [esp+4h] [ebp-4h]

  if ( dword_8283EA0 )
  {
    Z_FreeInternal(dword_8283EA0);
    dword_8283EA0 = 0;
  }
  if ( dword_8283EAC )
  {
    Z_FreeInternal(dword_8283EAC);
    dword_8283EAC = 0;
  }
  if ( dword_8283ED4 )
  {
    for ( i = 0; i < dword_8283ED8; ++i )
      Z_FreeInternal(*((void **)dword_8283ED4 + 6 * i + 1));
    Z_FreeInternal(dword_8283ED4);
    dword_8283ED4 = 0;
  }
  if ( dword_8283EC4 )
  {
    for ( j = 0; j < dword_8283EC8; ++j )
    {
      if ( *((_DWORD *)dword_8283EC4 + 2 * j) )
        Z_FreeInternal(*((void **)dword_8283EC4 + 2 * j));
    }
    Z_FreeInternal(dword_8283EC4);
    dword_8283EC4 = 0;
  }
}
// 8283EC8: using guessed type int dword_8283EC8;
// 8283ED8: using guessed type int dword_8283ED8;

//----- (08076D92) --------------------------------------------------------
void __cdecl sub_8076D92(int a1, int a2)
{
  void *dest; // ST24_4
  void *v3; // ST20_4
  int v4; // [esp+14h] [ebp-14h]
  char *v5; // [esp+18h] [ebp-10h]
  _DWORD *v6; // [esp+1Ch] [ebp-Ch]

  if ( byte_839400A && dword_8202A68 != 2 )
  {
    if ( !byte_8202A65 )
      a2 &= 0xFFFFFFFE;
    if ( dword_8283EA8 >= (unsigned int)dword_8283EA4 )
    {
      dword_8283EA4 *= 2;
      dest = Z_MallocInternal(20 * dword_8283EA4);
      memcpy(dest, dword_8283EA0, 20 * dword_8283EA8);
      Z_FreeInternal(dword_8283EA0);
      dword_8283EA0 = dest;
    }
    if ( dword_8283EB4 >= (unsigned int)dword_8283EB0 )
    {
      dword_8283EB0 *= 2;
      v3 = Z_MallocInternal(8 * dword_8283EB0);
      memcpy(v3, dword_8283EAC, 8 * dword_8283EB4);
      Z_FreeInternal(dword_8283EAC);
      dword_8283EAC = v3;
    }
    if ( dword_8283EBC == dword_8202A6C )
    {
      v6 = (char *)dword_8283EA0 + 20 * --dword_8283EA8;
    }
    else
    {
      dword_8283EC0 = 0;
      dword_8283EBC = dword_8202A6C;
      v6 = (char *)dword_8283EA0 + 20 * dword_8283EA8;
      *((_DWORD *)dword_8283EA0 + 5 * dword_8283EA8 + 1) = dword_8283EB4;
      *v6 = dword_8283EBC;
    }
    v4 = v6[1] + dword_8283EC0;
    v5 = (char *)dword_8283EAC + 8 * v4;
    *((_DWORD *)dword_8283EAC + 2 * v4) = a1;
    if ( a1 == -1 )
    {
      dword_8283ECC = v4;
    }
    else if ( a1 == -2 )
    {
      dword_8283ED0 = v4;
    }
    else if ( dword_8283ECC >= 0 )
    {
      if ( a2 & 1 )
      {
        *((_DWORD *)dword_8283EAC + 2 * dword_8283ECC) = a1;
        dword_8283ECC = -1;
      }
    }
    *((_DWORD *)v5 + 1) |= a2;
    v6[2] = ++dword_8283EC0;
    ++dword_8283EA8;
    ++dword_8283EB4;
  }
}
// 8202A65: using guessed type char byte_8202A65;
// 8202A68: using guessed type int dword_8202A68;
// 8202A6C: using guessed type int dword_8202A6C;
// 8283EA4: using guessed type int dword_8283EA4;
// 8283EA8: using guessed type int dword_8283EA8;
// 8283EB0: using guessed type int dword_8283EB0;
// 8283EB4: using guessed type int dword_8283EB4;
// 8283EBC: using guessed type int dword_8283EBC;
// 8283EC0: using guessed type int dword_8283EC0;
// 8283ECC: using guessed type int dword_8283ECC;
// 8283ED0: using guessed type int dword_8283ED0;
// 839400A: using guessed type char byte_839400A;

//----- (08076FAE) --------------------------------------------------------
int sub_8076FAE()
{
  int result; // eax

  if ( byte_839400A && dword_8202A68 != 2 )
  {
    --dword_8283EB4;
    --dword_8283EA8;
    if ( !--dword_8283EC0 )
      dword_8283EBC = 0;
    result = dword_8283EC0;
    *((_DWORD *)dword_8283EA0 + 5 * dword_8283EA8 + 2) = dword_8283EC0;
  }
  return result;
}
// 8202A68: using guessed type int dword_8202A68;
// 8283EA8: using guessed type int dword_8283EA8;
// 8283EB4: using guessed type int dword_8283EB4;
// 8283EBC: using guessed type int dword_8283EBC;
// 8283EC0: using guessed type int dword_8283EC0;
// 839400A: using guessed type char byte_839400A;

//----- (08077016) --------------------------------------------------------
char *__cdecl sub_8077016(int a1)
{
  char *v1; // ST00_4
  char *result; // eax

  if ( byte_839400A )
  {
    if ( dword_8202A68 != 2 )
    {
      v1 = (char *)dword_8283EAC + 8 * dword_8283ED0;
      *((_DWORD *)dword_8283EAC + 2 * dword_8283ED0) = a1;
      result = v1;
      *((_DWORD *)v1 + 1) = 4;
      dword_8283ED0 = -1;
    }
  }
  return result;
}
// 8202A68: using guessed type int dword_8202A68;
// 8283ED0: using guessed type int dword_8283ED0;
// 839400A: using guessed type char byte_839400A;

//----- (080773B6) --------------------------------------------------------
char *__cdecl sub_80773B6(unsigned int a1)
{
  int v3; // [esp+4h] [ebp-Ch]
  int v4; // [esp+8h] [ebp-8h]
  int v5; // [esp+Ch] [ebp-4h]

  v5 = 0;
  v4 = dword_8283EA8 - 1;
  while ( v5 <= v4 )
  {
    v3 = (v4 + v5) / 2;
    if ( a1 < *((_DWORD *)dword_8283EA0 + 5 * v3) )
    {
      v4 = v3 - 1;
    }
    else
    {
      v5 = v3 + 1;
      if ( v3 + 1 == dword_8283EA8 || a1 < *((_DWORD *)dword_8283EA0 + 5 * v5) )
        return (char *)dword_8283EA0 + 20 * v3;
    }
  }
  return 0;
}
// 8283EA8: using guessed type int dword_8283EA8;

//----- (08077474) --------------------------------------------------------
char *__cdecl sub_8077474(unsigned int a1)
{
  int v3; // [esp+4h] [ebp-Ch]
  int v4; // [esp+8h] [ebp-8h]
  int v5; // [esp+Ch] [ebp-4h]

  v5 = 0;
  v4 = dword_8283EA8 - 1;
  while ( v5 <= v4 )
  {
    v3 = (v4 + v5) / 2;
    if ( a1 < *((_DWORD *)dword_8283EA0 + 5 * v3) )
    {
      v4 = v3 - 1;
    }
    else
    {
      if ( a1 == *((_DWORD *)dword_8283EA0 + 5 * v3) )
        return (char *)dword_8283EA0 + 20 * v3;
      v5 = v3 + 1;
    }
  }
  return 0;
}
// 8283EA8: using guessed type int dword_8283EA8;

//----- (0807752A) --------------------------------------------------------
int __cdecl sub_807752A(unsigned int a1, int a2)
{
  return *((_DWORD *)dword_8283EAC + 2 * (*((_DWORD *)sub_80773B6(a1) + 1) + a2));
}

//----- (08077554) --------------------------------------------------------
int __cdecl sub_8077554(_BYTE *a1, int a2, _DWORD *a3, _DWORD *a4)
{
  int v5; // [esp+0h] [ebp-4h]

  *a3 = a1;
  v5 = 0;
  while ( a2 )
  {
    if ( !*a1 )
    {
      *a3 = a1 + 1;
      ++v5;
    }
    ++a1;
    --a2;
  }
  *a4 = &a1[-*a3];
  return v5;
}

//----- (080775A6) --------------------------------------------------------
int __cdecl sub_80775A6(int a1, int a2)
{
  char v3; // [esp+10h] [ebp-8h]
  char v4; // [esp+14h] [ebp-4h]

  return sub_8077554(*((_BYTE **)dword_8283ED4 + 6 * a1 + 2), a2, &v3, &v4);
}

//----- (080775E4) --------------------------------------------------------
signed int __cdecl sub_80775E4(unsigned int a1, int a2, int *a3)
{
  unsigned int i; // [esp+Ch] [ebp-Ch]
  char *v6; // [esp+10h] [ebp-8h]

  v6 = sub_8077474(a1);
  if ( v6 )
  {
    for ( i = 0; i < *((_DWORD *)v6 + 2); ++i )
    {
      if ( (*((_DWORD *)dword_8283EAC + 2 * (*((_DWORD *)v6 + 1) + i) + 1) & a2) == a2 )
      {
        a3[2] = *((_DWORD *)dword_8283EAC + 2 * (*((_DWORD *)v6 + 1) + i));
        *a3 = sub_8077D5A(a1);
        a3[1] = sub_80775A6(*a3, a3[2]);
        return 1;
      }
    }
  }
  return 0;
}

//----- (080776B8) --------------------------------------------------------
char *sub_80776B8()
{
  void *dest; // ST14_4

  if ( dword_8283ED8 >= (unsigned int)dword_8283EB8 )
  {
    dword_8283EB8 *= 2;
    dest = Z_MallocInternal(24 * dword_8283EB8);
    Com_Memcpy(dest, dword_8283ED4, 24 * dword_8283ED8);
    Z_FreeInternal(dword_8283ED4);
    dword_8283ED4 = dest;
  }
  return (char *)dword_8283ED4 + 24 * dword_8283ED8++;
}
// 8283EB8: using guessed type int dword_8283EB8;
// 8283ED8: using guessed type int dword_8283ED8;

//----- (08077750) --------------------------------------------------------
int __cdecl sub_8077750(char *s, int a2, int a3, int a4, int a5, int a6)
{
  int result; // eax
  char v7; // ST1B_1
  char *v8; // eax
  char *v9; // edx
  int v10; // [esp+Ch] [ebp-2Ch]
  char *v11; // [esp+14h] [ebp-24h]
  char v12; // [esp+1Bh] [ebp-1Dh]
  int i; // [esp+1Ch] [ebp-1Ch]
  int j; // [esp+1Ch] [ebp-1Ch]
  _BYTE *v15; // [esp+24h] [ebp-14h]
  size_t v16; // [esp+2Ch] [ebp-Ch]
  char *dest; // [esp+30h] [ebp-8h]

  result = a5;
  if ( dword_8283ED4 )
  {
    v16 = strlen(s) + 1;
    dest = (char *)Z_MallocInternal(v16 + a4 + 2);
    strcpy(dest, s);
    if ( a3 )
      v10 = (int)&dest[v16];
    else
      v10 = 0;
    v11 = (char *)a3;
    v15 = (_BYTE *)v10;
    if ( (_BYTE)a5 )
    {
      for ( i = 0; i <= a4; ++i )
      {
        v12 = *v11++;
        if ( v12 != 10 && (v12 != 13 || *v11 == 10) )
          *v15 = v12;
        else
          *v15 = 0;
        ++v15;
      }
    }
    else
    {
      for ( j = 0; j <= a4; ++j )
      {
        v7 = *v11++;
        *v15++ = v7;
      }
    }
    v8 = sub_80776B8();
    *(_DWORD *)v8 = a2;
    *((_DWORD *)v8 + 1) = dest;
    *((_DWORD *)v8 + 2) = v10;
    *((_DWORD *)v8 + 3) = a4;
    *((_DWORD *)v8 + 4) = -1;
    v9 = v8;
    result = (unsigned __int8)a6;
    v9[20] = a6;
    if ( v10 )
    {
      result = v10;
      *(_DWORD *)dword_8283EE0 = v10;
    }
  }
  else
  {
    *(_DWORD *)dword_8283EE0 = 0;
  }
  return result;
}

//----- (080778BC) --------------------------------------------------------
int __cdecl sub_80778BC(int a1, char *s, int a3, int a4)
{
  int v5; // [esp+24h] [ebp-14h]
  int v6; // [esp+28h] [ebp-10h]
  int v7; // [esp+2Ch] [ebp-Ch]
  int v8; // [esp+30h] [ebp-8h]
  unsigned __int8 v9; // [esp+37h] [ebp-1h]

  v9 = a4;
  v7 = FS_FOpenFileByMode(s, (int)&v6, 0);
  if ( v7 >= 0 )
  {
    v8 = sub_80A9CF0(v7 + 1);
    FS_Read(v8, v7, v6);
    *(_BYTE *)(v8 + v7) = 0;
    FS_FCloseFile(v6);
    sub_8077750(s, a3, v8, v7, 1, v9);
    v5 = v8;
  }
  else
  {
    sub_8077750(s, a3, 0, -1, 1, v9);
    v5 = 0;
  }
  return v5;
}

//----- (0807799E) --------------------------------------------------------
size_t __cdecl sub_807799E(int a1, char *s, int a3, int a4)
{
  char v4; // ST3B_1
  char v6; // [esp+1Fh] [ebp-29h]
  char **v8; // [esp+28h] [ebp-20h]
  char *v9; // [esp+2Ch] [ebp-1Ch]
  int v10; // [esp+30h] [ebp-18h]
  size_t v11; // [esp+34h] [ebp-14h]
  int i; // [esp+3Ch] [ebp-Ch]
  char *v13; // [esp+40h] [ebp-8h]

  if ( !(_BYTE)a4 || !dword_8283EC4 )
    return sub_80778BC(a1, s, a3, (unsigned __int8)a4);
  v8 = (char **)((char *)dword_8283EC4 + 8 * --dword_8283EC8);
  v10 = *((_DWORD *)dword_8283EC4 + 2 * dword_8283EC8 + 1);
  if ( v10 >= 0 )
  {
    v11 = sub_80A9CF0(v10 + 1);
    v9 = *v8;
    v13 = (char *)v11;
    for ( i = 0; i < v10; ++i )
    {
      v4 = *v9++;
      v6 = v4;
      if ( !v4 )
        v6 = 10;
      *v13++ = v6;
    }
    *v13 = 0;
    if ( *v8 )
      Z_FreeInternal(*((void **)dword_8283EC4 + 2 * dword_8283EC8));
    sub_8077750(s, a3, v11, v10, 1, (unsigned __int8)a4);
  }
  else
  {
    v11 = 0;
    sub_8077750(s, a3, 0, v10, 1, (unsigned __int8)a4);
  }
  return v11;
}
// 8283EC8: using guessed type int dword_8283EC8;

//----- (08077AE8) --------------------------------------------------------
int __cdecl sub_8077AE8(_BYTE *a1, int a2, _DWORD *a3, int a4)
{
  char v5; // [esp+1Fh] [ebp-19h]
  char *s; // [esp+24h] [ebp-14h]
  int v7; // [esp+28h] [ebp-10h]
  char v8; // [esp+2Fh] [ebp-9h]
  int i; // [esp+30h] [ebp-8h]
  int v10; // [esp+34h] [ebp-4h]

  v7 = sub_8077554(a1, a2, &s, a3);
  v10 = strlen(s);
  if ( v10 > 1023 )
    v10 = 1023;
  for ( i = 0; i <= v10; ++i )
  {
    v8 = s[i];
    if ( v8 == 9 )
      v5 = 32;
    else
      v5 = v8;
    *(_BYTE *)(i + a4) = v5;
  }
  if ( *(_BYTE *)(a4 + v10 - 1) == 13 )
    *(_BYTE *)(a4 + v10 - 1) = 0;
  return v7;
}

//----- (08077B96) --------------------------------------------------------
void __cdecl sub_8077B96(int a1, int a2, _BYTE *a3, int a4)
{
  char *v4; // eax
  char *v5; // eax
  int v6; // [esp+Ch] [ebp-41Ch]
  int i; // [esp+14h] [ebp-414h]
  int v8; // [esp+18h] [ebp-410h]
  int v9; // [esp+1Ch] [ebp-40Ch]
  char v10; // [esp+20h] [ebp-408h]

  v9 = sub_8077AE8(a3, a4, &v8, (int)&v10);
  v6 = v9 + 1;
  if ( dword_8283EC4 )
    v4 = va("(file '%s'%s, line %d)\n", a2, " (savegame)", v6);
  else
    v4 = va("(file '%s'%s, line %d)\n", a2, &unk_813F86C, v6);
  Com_PrintMessage(a1, v4);
  v5 = va("%s\n", &v10);
  Com_PrintMessage(a1, v5);
  for ( i = 0; i < v8; ++i )
    Com_PrintMessage(a1, " ");
  Com_PrintMessage(a1, "*\n");
}

//----- (08077C92) --------------------------------------------------------
int __cdecl sub_8077C92(int a1, int a2, char *s, size_t maxlen)
{
  int v5; // [esp+18h] [ebp-420h]
  char v6; // [esp+28h] [ebp-410h]
  int v7; // [esp+2Ch] [ebp-40Ch]
  char v8; // [esp+30h] [ebp-408h]

  v7 = sub_8077AE8(*((_BYTE **)dword_8283ED4 + 6 * a1 + 2), a2, &v6, (int)&v8);
  v5 = v7 + 1;
  if ( dword_8283EC4 )
    Com_sprintf(s, maxlen, "%s // %s%s, line %d", &v8, *((_DWORD *)dword_8283ED4 + 6 * a1 + 1), " (savegame)", v5);
  else
    Com_sprintf(s, maxlen, "%s // %s%s, line %d", &v8, *((_DWORD *)dword_8283ED4 + 6 * a1 + 1), &unk_813F86C, v5);
  return v7;
}

//----- (08077D5A) --------------------------------------------------------
int __cdecl sub_8077D5A(unsigned int a1)
{
  int i; // [esp+0h] [ebp-4h]

  for ( i = dword_8283ED8 - 1;
        i > 0 && (!*((_DWORD *)dword_8283ED4 + 6 * i) || *((_DWORD *)dword_8283ED4 + 6 * i) > a1);
        --i )
  {
    ;
  }
  return i;
}
// 8283ED8: using guessed type int dword_8283ED8;

//----- (08077DBA) --------------------------------------------------------
void __cdecl sub_8077DBA(int a1, char *a2, int a3)
{
  char *v3; // eax
  int v4; // ST14_4
  int v5; // eax
  char *v6; // eax

  if ( !a2 )
  {
    Com_PrintMessage(a1, "<frozen thread>\n");
    return;
  }
  if ( a2 == (char *)&unk_83D4100 )
  {
    Com_PrintMessage(a1, "<removed thread>\n");
  }
  else
  {
    if ( byte_839400A )
    {
      if ( dword_8394048 && sub_80757CC((int)a2) )
      {
        v4 = sub_8077D5A((unsigned int)(a2 - 1));
        v5 = sub_807752A((unsigned int)(a2 - 1), a3);
        sub_8077B96(a1, *((_DWORD *)dword_8283ED4 + 6 * v4 + 1), *((_BYTE **)dword_8283ED4 + 6 * v4 + 2), v5);
        return;
      }
    }
    else if ( sub_80757CC((int)(a2 - 1)) )
    {
      v3 = va("@ %d\n", &a2[-dword_8394048]);
      Com_PrintMessage(a1, v3);
      return;
    }
    v6 = va("%s\n\n", a2);
    Com_PrintMessage(a1, v6);
  }
}
// 839400A: using guessed type char byte_839400A;
// 8394048: using guessed type int dword_8394048;

//----- (08077EF6) --------------------------------------------------------
int __cdecl sub_8077EF6(int a1, int a2, char *s, size_t maxlen)
{
  int v5; // [esp+10h] [ebp-18h]
  int v6; // [esp+18h] [ebp-10h]

  if ( !byte_839400A )
    return Com_sprintf(s, maxlen, "@ %d", a1 - dword_8394048);
  sub_80775E4(a1, 4, &v5);
  return sub_8077C92(v5, v6, s, maxlen);
}
// 839400A: using guessed type char byte_839400A;
// 8394048: using guessed type int dword_8394048;

//----- (08077FFE) --------------------------------------------------------
char *sub_8077FFE(int a1, char *format, ...)
{
  char *result; // eax
  char s; // [esp+10h] [ebp-418h]
  __gnuc_va_list __varargs; // [esp+41Ch] [ebp-Ch]
  va_list va; // [esp+438h] [ebp+10h]

  va_start(va, format);
  va_copy(__varargs, va);
  result = (char *)vsprintf(&s, format, va);
  if ( !byte_839400C )
  {
    Com_Printf("\n");
    Com_Printf("******* script compile error *******\n");
    if ( byte_839400A )
    {
      Com_Printf("%s: ", &s);
      sub_8077B96(0, *(int *)dword_8283EDC, *(_BYTE **)dword_8283EE0, a1);
    }
    else
    {
      Com_Printf("%s\n", &s);
    }
    Com_Printf("************************************\n");
    Com_Error(5, &byte_813F960);
  }
  if ( !*(_DWORD *)dword_8394010 )
  {
    result = va("%s", &s);
    *(_DWORD *)dword_8394010 = result;
  }
  return result;
}
// 839400A: using guessed type char byte_839400A;
// 839400C: using guessed type char byte_839400C;

//----- (080780F6) --------------------------------------------------------
void __noreturn sub_80780F6(int a1, char *format, ...)
{
  char s; // [esp+10h] [ebp-418h]
  __gnuc_va_list __varargs; // [esp+41Ch] [ebp-Ch]
  va_list va; // [esp+438h] [ebp+10h]

  va_start(va, format);
  Com_Printf("\n");
  Com_Printf("******* script compile error *******\n");
  va_copy(__varargs, va);
  vsprintf(&s, format, va);
  Com_Printf("%s: ", &s);
  sub_8077DBA(0, (char *)a1, 0);
  Com_Printf("************************************\n");
  Com_Error(5, &byte_813F960);
}

//----- (0807818C) --------------------------------------------------------
void __cdecl sub_807818C(int a1, char *a2, int a3, int a4)
{
  char *v4; // eax
  int i; // [esp+14h] [ebp-4h]

  v4 = va("\n******* script runtime error *******\n%s: ", a4);
  Com_PrintMessage(a1, v4);
  sub_8077DBA(a1, a2, a3);
  if ( dword_83D7608 )
  {
    for ( i = dword_83D7608 - 1; i > 0; --i )
    {
      Com_PrintMessage(a1, "called from:\n");
      sub_8077DBA(a1, (char *)dword_83D7620[6 * i], dword_83D7624[6 * i] == 0);
    }
    Com_PrintMessage(a1, "started from:\n");
    sub_8077DBA(a1, (char *)dword_83D7620[0], 1);
  }
  Com_PrintMessage(a1, "************************************\n");
}
// 83D7608: using guessed type int dword_83D7608;
// 83D7620: using guessed type int dword_83D7620[];
// 83D7624: using guessed type int dword_83D7624[];

//----- (08078282) --------------------------------------------------------
void __cdecl sub_8078282(char *a1, int a2, int a3, void *a4)
{
  const char *v4; // [esp+18h] [ebp-10h]
  void *v5; // [esp+1Ch] [ebp-Ch]
  char v6; // [esp+27h] [ebp-1h]

  if ( byte_839400A || byte_83D7616 )
  {
    if ( byte_83D7614 )
    {
      Com_Printf("%s\n", a3);
      if ( byte_83D7616 )
        goto LABEL_13;
    }
    else
    {
      v6 = 0;
      if ( byte_83D7615 || byte_83D7616 )
        v6 = 1;
      if ( v6 )
        sub_807818C(0, a1, a2, a3);
      else
        sub_807818C(4, a1, a2, a3);
      if ( v6 )
      {
LABEL_13:
        v5 = a4;
        if ( !a4 )
          v5 = &unk_813F86C;
        if ( a4 )
          v4 = "\n";
        else
          v4 = (const char *)&unk_813F86C;
        if ( byte_83D7616 )
          Com_Error(5, &byte_813FA00, a3, v4, v5);
        Com_Error(4, &byte_813FA00, a3, v4, v5);
      }
    }
  }
}
// 839400A: using guessed type char byte_839400A;
// 83D7614: using guessed type char byte_83D7614;
// 83D7615: using guessed type char byte_83D7615;
// 83D7616: using guessed type char byte_83D7616;

//----- (08078390) --------------------------------------------------------
_DWORD *__userpurge sub_8078390@<eax>(_DWORD *a1, int a2)
{
  *a1 = a2;
  return a1;
}

//----- (080783A2) --------------------------------------------------------
_DWORD *__userpurge sub_80783A2@<eax>(_DWORD *a1, int a2)
{
  *a1 = a2;
  return a1;
}

//----- (080783B4) --------------------------------------------------------
size_t *__userpurge sub_80783B4@<eax>(size_t *a1, int a2)
{
  *a1 = sub_80A9CF0(4);
  *(_DWORD *)*a1 = a2;
  return a1;
}

//----- (080783DE) --------------------------------------------------------
int __userpurge sub_80783DE@<eax>(int a1, int a2, int a3)
{
  *(_DWORD *)a1 = sub_80A9CF0(8);
  **(_DWORD **)a1 = a2;
  *(_DWORD *)(*(_DWORD *)a1 + 4) = a3;
  return a1;
}

//----- (08078412) --------------------------------------------------------
int __userpurge sub_8078412@<eax>(int a1, int a2, int a3, int a4)
{
  *(_DWORD *)a1 = sub_80A9CF0(12);
  **(_DWORD **)a1 = a2;
  *(_DWORD *)(*(_DWORD *)a1 + 4) = a3;
  *(_DWORD *)(*(_DWORD *)a1 + 8) = a4;
  return a1;
}

//----- (08078450) --------------------------------------------------------
int __userpurge sub_8078450@<eax>(int a1, int a2, int a3)
{
  *(_DWORD *)a1 = sub_80A9CF0(8);
  **(_DWORD **)a1 = a2;
  *(_DWORD *)(*(_DWORD *)a1 + 4) = a3;
  return a1;
}

//----- (08078484) --------------------------------------------------------
int __userpurge sub_8078484@<eax>(int a1, int a2, int a3, int a4, int a5)
{
  *(_DWORD *)a1 = sub_80A9CF0(16);
  **(_DWORD **)a1 = a2;
  *(_DWORD *)(*(_DWORD *)a1 + 4) = a3;
  *(_DWORD *)(*(_DWORD *)a1 + 8) = a4;
  *(_DWORD *)(*(_DWORD *)a1 + 12) = a5;
  return a1;
}

//----- (080784CC) --------------------------------------------------------
int __userpurge sub_80784CC@<eax>(int a1, int a2, int a3, int a4)
{
  *(_DWORD *)a1 = sub_80A9CF0(12);
  **(_DWORD **)a1 = a2;
  *(_DWORD *)(*(_DWORD *)a1 + 4) = a3;
  *(_DWORD *)(*(_DWORD *)a1 + 8) = a4;
  return a1;
}

//----- (0807850A) --------------------------------------------------------
int __userpurge sub_807850A@<eax>(int a1, int a2, int a3, int a4, int a5, int a6)
{
  *(_DWORD *)a1 = sub_80A9CF0(20);
  **(_DWORD **)a1 = a2;
  *(_DWORD *)(*(_DWORD *)a1 + 4) = a3;
  *(_DWORD *)(*(_DWORD *)a1 + 8) = a4;
  *(_DWORD *)(*(_DWORD *)a1 + 12) = a5;
  *(_DWORD *)(*(_DWORD *)a1 + 16) = a6;
  return a1;
}

//----- (0807855C) --------------------------------------------------------
int __userpurge sub_807855C@<eax>(int a1, int a2, int a3, int a4, int a5)
{
  *(_DWORD *)a1 = sub_80A9CF0(16);
  **(_DWORD **)a1 = a2;
  *(_DWORD *)(*(_DWORD *)a1 + 4) = a3;
  *(_DWORD *)(*(_DWORD *)a1 + 8) = a4;
  *(_DWORD *)(*(_DWORD *)a1 + 12) = a5;
  return a1;
}

//----- (080785A4) --------------------------------------------------------
int __userpurge sub_80785A4@<eax>(int a1, int a2, int a3, int a4, int a5, int a6, int a7)
{
  *(_DWORD *)a1 = sub_80A9CF0(24);
  **(_DWORD **)a1 = a2;
  *(_DWORD *)(*(_DWORD *)a1 + 4) = a3;
  *(_DWORD *)(*(_DWORD *)a1 + 8) = a4;
  *(_DWORD *)(*(_DWORD *)a1 + 12) = a5;
  *(_DWORD *)(*(_DWORD *)a1 + 16) = a6;
  *(_DWORD *)(*(_DWORD *)a1 + 20) = a7;
  return a1;
}

//----- (08078600) --------------------------------------------------------
int __userpurge sub_8078600@<eax>(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8)
{
  *(_DWORD *)a1 = sub_80A9CF0(28);
  **(_DWORD **)a1 = a2;
  *(_DWORD *)(*(_DWORD *)a1 + 4) = a3;
  *(_DWORD *)(*(_DWORD *)a1 + 8) = a4;
  *(_DWORD *)(*(_DWORD *)a1 + 12) = a5;
  *(_DWORD *)(*(_DWORD *)a1 + 16) = a6;
  *(_DWORD *)(*(_DWORD *)a1 + 20) = a7;
  *(_DWORD *)(*(_DWORD *)a1 + 24) = a8;
  return a1;
}

//----- (08078666) --------------------------------------------------------
int __userpurge sub_8078666@<eax>(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, int a9)
{
  *(_DWORD *)a1 = sub_80A9CF0(32);
  **(_DWORD **)a1 = a2;
  *(_DWORD *)(*(_DWORD *)a1 + 4) = a3;
  *(_DWORD *)(*(_DWORD *)a1 + 8) = a4;
  *(_DWORD *)(*(_DWORD *)a1 + 12) = a5;
  *(_DWORD *)(*(_DWORD *)a1 + 16) = a6;
  *(_DWORD *)(*(_DWORD *)a1 + 20) = a7;
  *(_DWORD *)(*(_DWORD *)a1 + 24) = a8;
  *(_DWORD *)(*(_DWORD *)a1 + 28) = a9;
  return a1;
}

//----- (080786D6) --------------------------------------------------------
int __userpurge sub_80786D6@<eax>(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, int a9, int a10)
{
  *(_DWORD *)a1 = sub_80A9CF0(36);
  **(_DWORD **)a1 = a2;
  *(_DWORD *)(*(_DWORD *)a1 + 4) = a3;
  *(_DWORD *)(*(_DWORD *)a1 + 8) = a4;
  *(_DWORD *)(*(_DWORD *)a1 + 12) = a5;
  *(_DWORD *)(*(_DWORD *)a1 + 16) = a6;
  *(_DWORD *)(*(_DWORD *)a1 + 20) = a7;
  *(_DWORD *)(*(_DWORD *)a1 + 24) = a8;
  *(_DWORD *)(*(_DWORD *)a1 + 28) = a9;
  *(_DWORD *)(*(_DWORD *)a1 + 32) = a10;
  return a1;
}

//----- (08078750) --------------------------------------------------------
int __userpurge sub_8078750@<eax>(int a1, int a2)
{
  _DWORD *v2; // eax
  _DWORD *v3; // ST10_4

  v2 = (_DWORD *)sub_80A9CF0(8);
  v3 = v2;
  *v2 = a2;
  v2[1] = 0;
  *(_DWORD *)a1 = sub_80A9CF0(8);
  **(_DWORD **)a1 = v3;
  *(_DWORD *)(*(_DWORD *)a1 + 4) = v3;
  return a1;
}

//----- (080787A6) --------------------------------------------------------
_DWORD *__userpurge sub_80787A6@<eax>(_DWORD *a1, int a2, _DWORD *a3)
{
  _DWORD *v3; // eax

  v3 = (_DWORD *)sub_80A9CF0(8);
  *v3 = a2;
  v3[1] = *a3;
  *a3 = v3;
  *a1 = a3;
  return a1;
}

//----- (080787EC) --------------------------------------------------------
_DWORD *__userpurge sub_80787EC@<eax>(_DWORD *a1, int a2, int a3)
{
  _DWORD *v3; // eax

  v3 = (_DWORD *)sub_80A9CF0(8);
  *v3 = a3;
  v3[1] = 0;
  *(_DWORD *)(*(_DWORD *)(a2 + 4) + 4) = v3;
  *(_DWORD *)(a2 + 4) = v3;
  *a1 = a2;
  return a1;
}

//----- (08078878) --------------------------------------------------------
int __cdecl sub_8078878(int a1)
{
  return dword_8283E80 + 8 * a1;
}
// 8283E80: using guessed type int dword_8283E80;

//----- (0807888A) --------------------------------------------------------
int __cdecl sub_807888A(int a1)
{
  return a1 - 4;
}

//----- (08078896) --------------------------------------------------------
int __cdecl sub_8078896(int a1)
{
  int v2; // [esp+4h] [ebp-4h]

  if ( a1 )
    v2 = sub_8078878(a1) + 4;
  else
    v2 = 0;
  return v2;
}

//----- (080788C2) --------------------------------------------------------
int __cdecl sub_80788C2(_BYTE *a1)
{
  int i; // [esp+4h] [ebp-4h]

  for ( i = (unsigned __int8)(*a1 - 1); a1[i + 4]; i += 256 )
    ;
  return i;
}

//----- (080788FC) --------------------------------------------------------
int __cdecl sub_80788FC(int a1)
{
  _BYTE *v1; // ST04_4

  v1 = (_BYTE *)sub_8078878(a1);
  return sub_80788C2(v1);
}

//----- (0807891E) --------------------------------------------------------
int __cdecl sub_807891E(int a1)
{
  return (a1 - dword_8283E80) / 8;
}
// 8283E80: using guessed type int dword_8283E80;

//----- (08078946) --------------------------------------------------------
int __cdecl sub_8078946(int a1)
{
  int v1; // eax

  v1 = sub_807888A(a1);
  return sub_807891E(v1);
}

//----- (08078962) --------------------------------------------------------
unsigned int __cdecl sub_8078962(char *a1, unsigned int a2)
{
  char *v4; // [esp+10h] [ebp-Ch]
  unsigned int v5; // [esp+14h] [ebp-8h]

  if ( a2 > 0xFF )
    return (a2 >> 2)
         - 0x3FFF
         * ((unsigned int)((262161 * (unsigned __int64)(a2 >> 2) >> 32)
                         + ((unsigned int)((a2 >> 2) - (262161 * (unsigned __int64)(a2 >> 2) >> 32)) >> 1)) >> 13)
         + 1;
  v5 = 0;
  v4 = a1;
  while ( a2 )
  {
    v5 = *v4++ + 31 * v5;
    --a2;
  }
  return v5 % 0x3FFF + 1;
}

//----- (08078A24) --------------------------------------------------------
unsigned int sub_8078A24()
{
  unsigned int result; // eax
  unsigned int v1; // [esp+Ch] [ebp-Ch]
  unsigned int i; // [esp+14h] [ebp-4h]

  sub_80766E6();
  word_8283F00[0] = 0;
  v1 = 0;
  for ( i = 1; i <= 0x3FFF; ++i )
  {
    word_8283F00[2 * i] = 0;
    word_8283F00[2 * v1] |= i;
    word_8283F00[2 * i + 1] = v1;
    v1 = i;
  }
  result = v1;
  word_8283F02[0] = v1;
  byte_8293F00 = 1;
  return result;
}
// 8283F00: using guessed type __int16 word_8283F00[];
// 8293F00: using guessed type char byte_8293F00;

//----- (08078AB2) --------------------------------------------------------
void sub_8078AB2()
{
  if ( byte_8293F00 )
    sub_8079A58();
  else
    sub_8078A24();
}
// 8293F00: using guessed type char byte_8293F00;

//----- (08078AD0) --------------------------------------------------------
void sub_8078AD0()
{
  if ( byte_8293F00 )
    byte_8293F00 = 0;
}
// 8293F00: using guessed type char byte_8293F00;

//----- (08078AE8) --------------------------------------------------------
int __cdecl sub_8078AE8(void *s2, size_t n)
{
  int v2; // ST18_4
  int v5; // [esp+20h] [ebp-18h]
  unsigned int v6; // [esp+24h] [ebp-14h]
  unsigned __int8 *v7; // [esp+28h] [ebp-10h]
  unsigned __int8 *v8; // [esp+28h] [ebp-10h]
  __int16 *i; // [esp+2Ch] [ebp-Ch]
  unsigned int v10; // [esp+30h] [ebp-8h]
  __int16 *v11; // [esp+34h] [ebp-4h]

  v6 = sub_8078962((char *)s2, n);
  v11 = &word_8283F00[2 * v6];
  if ( (*v11 & 0xC000) != 0x8000 )
    return 0;
  v7 = (unsigned __int8 *)sub_8078878((unsigned __int16)v11[1]);
  if ( *v7 != (unsigned __int8)n || memcmp(v7 + 4, s2, n) )
  {
    v10 = v6;
    v5 = *v11 & 0x3FFF;
    for ( i = &word_8283F00[2 * v5]; i != v11; i = &word_8283F00[2 * v5] )
    {
      v8 = (unsigned __int8 *)sub_8078878((unsigned __int16)i[1]);
      if ( *v8 == (unsigned __int8)n && !memcmp(v8 + 4, s2, n) )
      {
        word_8283F00[2 * v10] = word_8283F00[2 * v10] & 0xC000 | *i & 0x3FFF;
        *i = *i & 0xC000 | *v11 & 0x3FFF;
        *v11 = *v11 & 0xC000 | v5;
        v2 = (unsigned __int16)i[1];
        i[1] = v11[1];
        v11[1] = v2;
        return v2;
      }
      v10 = v5;
      v5 = *i & 0x3FFF;
    }
    return 0;
  }
  return (unsigned __int16)v11[1];
}
// 8283F00: using guessed type __int16 word_8283F00[];

//----- (08078CC6) --------------------------------------------------------
int __cdecl sub_8078CC6(void *s2)
{
  size_t v1; // eax

  v1 = I_strlen((char *)s2);
  return sub_8078AE8(s2, v1 + 1);
}

//----- (08078CEA) --------------------------------------------------------
int __cdecl sub_8078CEA(char *s)
{
  signed int n; // [esp+18h] [ebp-2010h]
  signed int i; // [esp+1Ch] [ebp-200Ch]
  char s2[8200]; // [esp+20h] [ebp-2008h]

  n = I_strlen(s) + 1;
  if ( n > 0x2000 )
    return 0;
  for ( i = 0; i < n; ++i )
    s2[i] = tolower(s[i]);
  return sub_8078AE8(s2, n);
}
// 8078CEA: using guessed type char s2[8200];

//----- (08078D94) --------------------------------------------------------
int __cdecl sub_8078D94(int a1, unsigned __int8 a2)
{
  int result; // eax

  result = (unsigned __int8)(a2 & *(_BYTE *)(a1 + 1));
  if ( !(a2 & *(_BYTE *)(a1 + 1)) )
  {
    *(_BYTE *)(a1 + 1) |= a2;
    result = *(unsigned __int16 *)(a1 + 2) + 1;
    *(_WORD *)(a1 + 2) = result;
  }
  return result;
}

//----- (08078DEC) --------------------------------------------------------
int __cdecl sub_8078DEC(void *s2, int a2, size_t n)
{
  int v3; // ST10_4
  __int16 *v4; // ST24_4
  int v5; // ST2C_4
  int v6; // ecx
  __int16 *v7; // ST24_4
  int v8; // ST20_4
  int v11; // [esp+10h] [ebp-28h]
  int v12; // [esp+18h] [ebp-20h]
  int v13; // [esp+18h] [ebp-20h]
  int v14; // [esp+18h] [ebp-20h]
  unsigned int v15; // [esp+1Ch] [ebp-1Ch]
  unsigned __int8 *v16; // [esp+20h] [ebp-18h]
  unsigned __int8 *v17; // [esp+20h] [ebp-18h]
  __int16 *j; // [esp+24h] [ebp-14h]
  unsigned __int16 v19; // [esp+2Ch] [ebp-Ch]
  unsigned int v20; // [esp+30h] [ebp-8h]
  int i; // [esp+30h] [ebp-8h]
  __int16 *v22; // [esp+34h] [ebp-4h]

  v15 = sub_8078962((char *)s2, n);
  v22 = &word_8283F00[2 * v15];
  if ( (*v22 & 0xC000) != 0x8000 )
  {
    if ( *v22 & 0xC000 )
    {
      v19 = *v22 & 0x3FFF;
      for ( i = v19; (word_8283F00[2 * i] & 0x3FFF) != v15; i = word_8283F00[2 * i] & 0x3FFF )
        ;
      v14 = (unsigned __int16)word_8283F00[0];
      if ( !word_8283F00[0] )
      {
        sub_8079DEE();
        sub_807A298();
        Com_Error(1, &byte_813FA40);
      }
      v11 = (unsigned __int16)sub_807682A(n + 4);
      v7 = &word_8283F00[2 * v14];
      word_8283F00[0] = *v7 & 0x3FFF;
      word_8283F02[2 * (unsigned __int16)word_8283F00[0]] = 0;
      word_8283F00[2 * i] = word_8283F00[2 * i] & 0xC000 | v14;
      *v7 = v19 | 0x4000;
      v7[1] = v22[1];
    }
    else
    {
      v11 = (unsigned __int16)sub_807682A(n + 4);
      v5 = *v22 & 0x3FFF;
      v6 = (unsigned __int16)v22[1];
      word_8283F00[2 * v6] = word_8283F00[2 * v6] & 0xC000 | v5;
      word_8283F02[2 * v5] = v6;
    }
    *v22 = v15 | 0x8000;
LABEL_25:
    v22[1] = v11;
    v8 = sub_8078878(v11);
    memcpy((void *)(v8 + 4), s2, n);
    *(_BYTE *)(v8 + 1) = a2;
    *(_WORD *)(v8 + 2) = 1;
    *(_BYTE *)v8 = n;
    return v11;
  }
  v16 = (unsigned __int8 *)sub_8078878((unsigned __int16)v22[1]);
  if ( *v16 != (unsigned __int8)n || memcmp(v16 + 4, s2, n) )
  {
    v20 = v15;
    v12 = *v22 & 0x3FFF;
    for ( j = &word_8283F00[2 * v12]; j != v22; j = &word_8283F00[2 * v12] )
    {
      v17 = (unsigned __int8 *)sub_8078878((unsigned __int16)j[1]);
      if ( *v17 == (unsigned __int8)n && !memcmp(v17 + 4, s2, n) )
      {
        word_8283F00[2 * v20] = word_8283F00[2 * v20] & 0xC000 | *j & 0x3FFF;
        *j = *j & 0xC000 | *v22 & 0x3FFF;
        *v22 = *v22 & 0xC000 | v12;
        v3 = (unsigned __int16)j[1];
        j[1] = v22[1];
        v22[1] = v3;
        sub_8078D94((int)v17, a2);
        return v3;
      }
      v20 = v12;
      v12 = *j & 0x3FFF;
    }
    v13 = (unsigned __int16)word_8283F00[0];
    if ( !word_8283F00[0] )
    {
      sub_8079DEE();
      sub_807A298();
      Com_Error(1, &byte_813FA40);
    }
    v11 = (unsigned __int16)sub_807682A(n + 4);
    v4 = &word_8283F00[2 * v13];
    word_8283F00[0] = *v4 & 0x3FFF;
    word_8283F02[2 * (unsigned __int16)word_8283F00[0]] = 0;
    *v4 = *v22 & 0x3FFF | 0x4000;
    *v22 = *v22 & 0xC000 | v13 & 0x3FFF;
    v4[1] = v22[1];
    goto LABEL_25;
  }
  sub_8078D94((int)v16, a2);
  return (unsigned __int16)v22[1];
}
// 8283F00: using guessed type __int16 word_8283F00[];

//----- (08079290) --------------------------------------------------------
int __cdecl sub_8079290(char *s, int a2)
{
  size_t v2; // eax

  v2 = I_strlen(s);
  return sub_8078DEC(s, a2, v2 + 1);
}

//----- (080792C4) --------------------------------------------------------
int __cdecl sub_80792C4(char *s, int a2)
{
  return sub_8079290(s, a2);
}

//----- (080792E6) --------------------------------------------------------
int __cdecl sub_80792E6(int a1, int a2, size_t n)
{
  size_t i; // [esp+1Ch] [ebp-200Ch]
  char s2[8200]; // [esp+20h] [ebp-2008h]

  if ( n > 0x2000 )
    Com_Error(1, "max string length exceeded: \"%s\"", a1);
  for ( i = 0; i < n; ++i )
    s2[i] = tolower(*(char *)(a1 + i));
  return sub_8078DEC(s2, a2, n);
}
// 80792E6: using guessed type char s2[8200];

//----- (0807939E) --------------------------------------------------------
int __cdecl sub_807939E(char *s, int a2)
{
  size_t v2; // eax

  v2 = I_strlen(s);
  return sub_80792E6((int)s, a2, v2 + 1);
}

//----- (080793D2) --------------------------------------------------------
int __cdecl sub_80793D2(char *s, int a2)
{
  return sub_807939E(s, a2);
}

//----- (080793F4) --------------------------------------------------------
int __cdecl sub_80793F4(int a1, int a2)
{
  int v2; // ST24_4
  unsigned int n; // [esp+20h] [ebp-2018h]
  int v6; // [esp+28h] [ebp-2010h]
  unsigned int i; // [esp+2Ch] [ebp-200Ch]
  char s2[8200]; // [esp+30h] [ebp-2008h]

  n = sub_80788FC(a1) + 1;
  if ( n > 0x2000 )
    return a1;
  v6 = sub_8078896(a1);
  for ( i = 0; i < n; ++i )
    s2[i] = tolower(*(char *)(v6 + i));
  v2 = sub_8078DEC(s2, a2, n);
  sub_80796A2(a1);
  return v2;
}
// 80793F4: using guessed type char s2[8200];

//----- (080794D8) --------------------------------------------------------
int __cdecl sub_80794D8(int a1, unsigned __int8 a2)
{
  int result; // eax
  int v3; // [esp+4h] [ebp-4h]

  v3 = sub_8078878(a1);
  if ( a2 & *(_BYTE *)(v3 + 1) )
  {
    result = *(unsigned __int16 *)(v3 + 2) - 1;
    *(_WORD *)(v3 + 2) = result;
  }
  else
  {
    result = a2;
    LOBYTE(result) = *(_BYTE *)(v3 + 1) | a2;
    *(_BYTE *)(v3 + 1) = result;
  }
  return result;
}

//----- (0807951E) --------------------------------------------------------
int __cdecl sub_807951E(int a1)
{
  int v1; // eax
  int v2; // edx
  int result; // eax

  v1 = sub_8078878(a1);
  v2 = v1;
  result = *(unsigned __int16 *)(v1 + 2) + 1;
  *(_WORD *)(v2 + 2) = result;
  return result;
}

//----- (08079544) --------------------------------------------------------
int __cdecl sub_8079544(int a1, int a2, unsigned int a3)
{
  int v3; // ST14_4
  int result; // eax
  unsigned int v5; // [esp+10h] [ebp-18h]
  int v6; // [esp+18h] [ebp-10h]
  unsigned int v7; // [esp+1Ch] [ebp-Ch]
  __int16 *v8; // [esp+20h] [ebp-8h]
  __int16 *v9; // [esp+24h] [ebp-4h]

  v7 = sub_8078962((char *)(a2 + 4), a3);
  v9 = &word_8283F00[2 * v7];
  sub_80768E2(a1, a3 + 4);
  v6 = *v9 & 0x3FFF;
  v8 = &word_8283F00[2 * v6];
  if ( (unsigned __int16)v9[1] == a1 )
  {
    if ( v8 == v9 )
    {
      v8 = &word_8283F00[2 * v7];
      v6 = v7;
    }
    else
    {
      *v9 = *v8 & 0x3FFF | 0x8000;
      v9[1] = v8[1];
      dword_8293F04 = (int)&word_8283F00[2 * v7];
    }
  }
  else
  {
    v5 = v7;
    while ( (unsigned __int16)v8[1] != a1 )
    {
      v5 = v6;
      v6 = *v8 & 0x3FFF;
      v8 = &word_8283F00[2 * v6];
    }
    word_8283F00[2 * v5] = word_8283F00[2 * v5] & 0xC000 | *v8 & 0x3FFF;
  }
  v3 = (unsigned __int16)word_8283F00[0];
  *v8 = word_8283F00[0];
  v8[1] = 0;
  word_8283F02[2 * v3] = v6;
  result = v6;
  word_8283F00[0] = v6;
  return result;
}
// 8283F00: using guessed type __int16 word_8283F00[];
// 8293F04: using guessed type int dword_8293F04;

//----- (080796A2) --------------------------------------------------------
int __cdecl sub_80796A2(int a1)
{
  _BYTE *v1; // eax
  int v2; // eax

  v1 = (_BYTE *)sub_8078878(a1);
  v2 = sub_80788C2(v1);
  return sub_8079746(a1, v2 + 1);
}

//----- (080796DA) --------------------------------------------------------
int __cdecl sub_80796DA(int a1)
{
  int result; // eax
  int v2; // eax
  int v3; // [esp+14h] [ebp-4h]

  v3 = sub_8078878(a1);
  if ( *(_BYTE *)(v3 + 1) & 4 )
  {
    *(_WORD *)(v3 + 2) = 1;
    result = v3;
    *(_BYTE *)(v3 + 1) = 4;
  }
  else
  {
    *(_WORD *)(v3 + 2) = 0;
    *(_BYTE *)(v3 + 1) = 0;
    v2 = sub_80788C2((_BYTE *)v3);
    result = sub_8079544(a1, v3, v2 + 1);
  }
  return result;
}

//----- (08079746) --------------------------------------------------------
int __cdecl sub_8079746(int a1, unsigned int a2)
{
  int result; // eax

  result = sub_8078878(a1);
  if ( !--*(_WORD *)(result + 2) )
    result = sub_8079544(a1, result, a2);
  return result;
}

//----- (08079790) --------------------------------------------------------
int __cdecl sub_8079790(_WORD *a1, int a2)
{
  int result; // eax

  if ( a2 )
    sub_807951E(a2);
  if ( *a1 )
    sub_80796A2((unsigned __int16)*a1);
  result = a2;
  *a1 = a2;
  return result;
}

//----- (080797CA) --------------------------------------------------------
int __cdecl sub_80797CA(int a1, char *s)
{
  int result; // eax

  if ( *(_WORD *)a1 )
    sub_80796A2(*(unsigned __int16 *)a1);
  result = sub_80792C4(s, 0);
  *(_WORD *)a1 = result;
  return result;
}

//----- (08079808) --------------------------------------------------------
int __cdecl sub_8079808(char *s)
{
  return sub_80792C4(s, 1);
}

//----- (08079824) --------------------------------------------------------
int __cdecl sub_8079824(float a1)
{
  char s; // [esp+10h] [ebp-88h]

  sprintf(&s, "%g", a1);
  return sub_8079290(&s, 0);
}

//----- (0807986A) --------------------------------------------------------
int __cdecl sub_807986A(int a1)
{
  char s; // [esp+10h] [ebp-88h]

  sprintf(&s, "%i", a1);
  return sub_8079290(&s, 0);
}

//----- (080798B0) --------------------------------------------------------
int __cdecl sub_80798B0(float *a1)
{
  char s; // [esp+20h] [ebp-88h]

  sprintf(&s, "(%g, %g, %g)", *a1, a1[1], a1[2]);
  return sub_8079290(&s, 0);
}

//----- (08079910) --------------------------------------------------------
void __cdecl sub_8079910(unsigned __int8 a1)
{
  int v1; // [esp+Ch] [ebp-Ch]
  __int16 *v2; // [esp+10h] [ebp-8h]
  unsigned int i; // [esp+14h] [ebp-4h]

  for ( i = 1; i <= 0x3FFF; ++i )
  {
    do
    {
      v2 = &word_8283F00[2 * i];
      if ( !(*v2 & 0xC000) )
        break;
      v1 = sub_8078878((unsigned __int16)v2[1]);
      if ( !(a1 & *(_BYTE *)(v1 + 1)) )
        break;
      *(_BYTE *)(v1 + 1) &= ~a1;
      dword_8293F04 = 0;
      sub_80796A2((unsigned __int16)v2[1]);
    }
    while ( dword_8293F04 );
  }
}
// 8283F00: using guessed type __int16 word_8283F00[];
// 8293F04: using guessed type int dword_8293F04;

//----- (080799B6) --------------------------------------------------------
void sub_80799B6()
{
  sub_8079910(1u);
}

//----- (08079A58) --------------------------------------------------------
void sub_8079A58()
{
  char *v0; // eax
  size_t v1; // eax
  void *ptr; // [esp+1Ch] [ebp-Ch]
  __int16 *v3; // [esp+20h] [ebp-8h]
  unsigned int i; // [esp+24h] [ebp-4h]
  unsigned int j; // [esp+24h] [ebp-4h]

  for ( i = 1; i <= 0x3FFF; ++i )
  {
    do
    {
      if ( !(word_8283F00[2 * i] & 0xC000) )
        break;
      dword_8293F04 = 0;
      sub_80796DA((unsigned __int16)word_8283F00[2 * i + 1]);
    }
    while ( dword_8293F04 );
  }
  ptr = sub_8076A72();
  for ( j = 1; j <= 0x3FFF; ++j )
  {
    v3 = &word_8283F00[2 * j];
    if ( *v3 & 0xC000 && *(_BYTE *)(sub_8078878((unsigned __int16)v3[1]) + 1) & 4 )
    {
      v0 = (char *)sub_8078896((unsigned __int16)v3[1]);
      v1 = I_strlen(v0);
      sub_8076A9A((int)ptr, (unsigned __int16)v3[1], v1 + 5);
    }
  }
  sub_8076B14(ptr);
}
// 8283F00: using guessed type __int16 word_8283F00[];
// 8293F04: using guessed type int dword_8293F04;

//----- (08079B84) --------------------------------------------------------
_BYTE *__cdecl sub_8079B84(_BYTE *a1, char *a2, int a3)
{
  _BYTE *result; // eax
  unsigned int c; // [esp+10h] [ebp-8h]

  do
  {
    do
    {
      do
        c = *a2++;
      while ( c == 92 );
    }
    while ( c == 47 );
    while ( c > 0x1F )
    {
      *a1++ = tolower(c);
      if ( !--a3 )
        Com_Error(1, &byte_813FAC0, a2, 0);
      if ( c == 47 )
        break;
      c = *a2++;
      if ( c == 92 )
        c = 47;
    }
  }
  while ( c );
  result = a1;
  *a1 = 0;
  return result;
}

//----- (08079C2A) --------------------------------------------------------
int __cdecl sub_8079C2A(char *a1)
{
  char s; // [esp+10h] [ebp-408h]

  sub_8079B84(&s, a1, 1024);
  return sub_8079290(&s, 0);
}

//----- (08079C70) --------------------------------------------------------
size_t __cdecl I_strlen(char *s)
{
  return strlen(s);
}

//----- (08079C84) --------------------------------------------------------
void sub_8079C84()
{
  dword_8293F84 = 0;
}
// 8293F84: using guessed type int dword_8293F84;

//----- (08079C94) --------------------------------------------------------
unsigned int __cdecl sub_8079C94(int a1)
{
  int v1; // ST10_4
  unsigned int v2; // ST14_4

  v1 = dword_8293F84 + a1;
  v2 = dword_8293F84 + sub_80AA00A(dword_8293F84 + a1);
  dword_8293F84 = v1;
  return v2;
}
// 8293F84: using guessed type int dword_8293F84;

//----- (08079CC8) --------------------------------------------------------
unsigned int __cdecl sub_8079CC8(int a1)
{
  return sub_8079C94(a1);
}

//----- (08079CDC) --------------------------------------------------------
unsigned int __cdecl sub_8079CDC(int a1)
{
  return sub_8079C94(a1);
}

//----- (08079CF0) --------------------------------------------------------
unsigned int __cdecl sub_8079CF0(int a1)
{
  dword_8293F84 -= sub_8079C94(0) - a1;
  return sub_80AA00A(dword_8293F84);
}
// 8293F84: using guessed type int dword_8293F84;

//----- (08079D48) --------------------------------------------------------
_BOOL4 __cdecl sub_8079D48(int a1)
{
  return sub_807DF7C(a1) > 14;
}

//----- (08079D6E) --------------------------------------------------------
int __cdecl sub_8079D6E(const void *a1, const void *a2)
{
  int v4; // [esp+4h] [ebp-Ch]
  int v5; // [esp+8h] [ebp-8h]
  int i; // [esp+Ch] [ebp-4h]

  for ( i = 0; ; ++i )
  {
    if ( i >= *((_DWORD *)a1 + 32) || i >= *((_DWORD *)a2 + 32) )
      return *((_DWORD *)a1 + 32) - *((_DWORD *)a2 + 32);
    v5 = *((_DWORD *)a1 + i);
    v4 = *((_DWORD *)a2 + i);
    if ( v5 != v4 )
      break;
  }
  return v5 - v4;
}

//----- (08079DEE) --------------------------------------------------------
void sub_8079DEE()
{
  char v0; // ST1F_1
  _DWORD *v1; // ST20_4
  float *v2; // ebx
  long double v3; // fst7
  int v4; // [esp+14h] [ebp-E4h]
  int v5; // [esp+18h] [ebp-E0h]
  _BYTE *v6; // [esp+20h] [ebp-D8h]
  int v7; // [esp+24h] [ebp-D4h]
  int v8; // [esp+28h] [ebp-D0h]
  int v9; // [esp+2Ch] [ebp-CCh]
  int v10[32]; // [esp+30h] [ebp-C8h]
  int v11; // [esp+B0h] [ebp-48h]
  float v12; // [esp+B4h] [ebp-44h]
  float v13; // [esp+B8h] [ebp-40h]
  int l; // [esp+C8h] [ebp-30h]
  unsigned int k; // [esp+CCh] [ebp-2Ch]
  char v16[4]; // [esp+D0h] [ebp-28h]
  int j; // [esp+D4h] [ebp-24h]
  int v18; // [esp+D8h] [ebp-20h]
  void *v19; // [esp+DCh] [ebp-1Ch]
  size_t nmemb; // [esp+E0h] [ebp-18h]
  void *base; // [esp+E4h] [ebp-14h]
  __int16 *v22; // [esp+E8h] [ebp-10h]
  unsigned int i; // [esp+ECh] [ebp-Ch]

  base = sub_80A92C0(0x8BFEE8u);
  if ( base )
  {
    nmemb = 0;
    for ( i = 1; i <= 0xFFFD; ++i )
    {
      v22 = &word_8294000[8 * i];
      if ( *((_DWORD *)v22 + 2) & 0x60 && (*((_DWORD *)v22 + 2) & 0x1F) == 10 )
      {
        v19 = (char *)base + 140 * nmemb++;
        v11 = 0;
        v9 = *((_DWORD *)v22 + 1);
        v8 = *(unsigned __int16 *)(v9 + 4);
        v7 = *(_DWORD *)v9;
        v6 = (_BYTE *)(v9 + 11);
        while ( v8 )
        {
          --v8;
          v0 = *v6;
          v1 = v6 + 1;
          v5 = *v1;
          v6 = v1 + 1;
          if ( v0 == 7 )
            v10[v11++] = v5;
        }
        v10[v11++] = v7;
        v2 = (float *)v19;
        v2[33] = sub_807F072(v9, (float *)v19 + 34);
        *((_DWORD *)v19 + 32) = v11--;
        for ( j = 0; j < *((_DWORD *)v19 + 32); ++j )
          *((_DWORD *)v19 + j) = v10[v11 - j];
      }
    }
    qsort(base, nmemb, 0x8Cu, sub_8079D6E);
    Com_Printf("********************************\n");
    v18 = 0;
    while ( v18 < (signed int)nmemb )
    {
      v19 = (char *)base + 140 * v18;
      *(_DWORD *)v16 = 0;
      v12 = 0.0;
      v13 = 0.0;
      do
      {
        ++*(_DWORD *)v16;
        v12 = v12 + *((float *)base + 35 * v18 + 33);
        v13 = v13 + *((float *)base + 35 * v18++ + 34);
      }
      while ( v18 < (signed int)nmemb && !sub_8079D6E(v19, (char *)base + 140 * v18) );
      LOWORD(v4) = HIWORD(v4) | 0xC00;
      Com_Printf(
        "count: %d, var usage: %d, endon usage: %d\n",
        *(_DWORD *)v16,
        (signed int)v12,
        (signed int)v13,
        (signed int)v12,
        v4);
      sub_8077DBA(0, *(char **)v19, 0);
      for ( j = 1; j < *((_DWORD *)v19 + 32); ++j )
      {
        Com_Printf("called from:\n");
        sub_8077DBA(0, *((char **)v19 + j), 0);
      }
    }
    Z_FreeInternal(base);
    Com_Printf("********************************\n");
    for ( k = 0; k <= 3; ++k )
    {
      if ( word_815AB82[6 * k] )
      {
        v12 = 0.0;
        *(_DWORD *)v16 = 0;
        for ( l = sub_807C9CE((unsigned __int16)word_815AB82[6 * k]); l; l = sub_807C9CE(l) )
        {
          ++*(_DWORD *)v16;
          if ( (dword_8294008[4 * l] & 0x1F) == 1 )
          {
            v3 = sub_807F006(dword_8294004[4 * l]);
            v12 = v3 + v12;
          }
        }
        LOWORD(v4) = HIWORD(v4) | 0xC00;
        Com_Printf(
          "ent type '%s'... count: %d, var usage: %d\n",
          (&off_815AB88)[3 * k],
          *(_DWORD *)v16,
          (signed int)v12,
          (signed int)v12,
          v4);
      }
    }
    Com_Printf("********************************\n");
  }
  else
  {
    Com_Printf("Cannot dump script threads: out of memory\n");
  }
}
// 815AB82: using guessed type __int16 word_815AB82[];
// 815AB88: using guessed type char *off_815AB88;
// 8294000: using guessed type __int16 word_8294000[];
// 8294004: using guessed type int dword_8294004[];
// 8294008: using guessed type int dword_8294008[];
// 8079DEE: using guessed type int var_C8[32];

//----- (0807A298) --------------------------------------------------------
void sub_807A298()
{
  ;
}

//----- (0807A29E) --------------------------------------------------------
int sub_807A29E()
{
  __int16 *v0; // ST08_4
  int result; // eax
  unsigned __int16 v2; // [esp+6h] [ebp-Ah]
  unsigned int i; // [esp+Ch] [ebp-4h]

  v2 = 0;
  for ( i = 1; i <= 0xFFFD; ++i )
  {
    v0 = &word_8294000[8 * i];
    *((_DWORD *)v0 + 2) = 0;
    *v0 = i;
    v0[6] = i;
    LOWORD(dword_8294004[4 * v2]) = i;
    v0[1] = v2;
    v2 = i;
  }
  *(_DWORD *)&word_8294000[4] = 0;
  *(_DWORD *)&word_8294000[4] = *(_DWORD *)&word_8294000[4];
  word_8294000[0] = 0;
  word_8294000[6] = 0;
  LOWORD(dword_8294004[4 * v2]) = 0;
  result = v2;
  word_8294000[1] = v2;
  return result;
}
// 8294000: using guessed type __int16 word_8294000[];
// 8294004: using guessed type int dword_8294004[];

//----- (0807A368) --------------------------------------------------------
int *sub_807A368()
{
  int *result; // eax
  int i; // [esp+4h] [ebp-4h]

  result = (int *)sub_807A29E();
  for ( i = 0; i <= 3; ++i )
  {
    word_815AB82[6 * i] = 0;
    word_815AB80[6 * i] = 0;
    result = &i;
  }
  return result;
}
// 815AB80: using guessed type __int16 word_815AB80[];
// 815AB82: using guessed type __int16 word_815AB82[];

//----- (0807A3B6) --------------------------------------------------------
int sub_807A3B6()
{
  int result; // eax

  if ( dword_8394028 )
  {
    result = sub_807B778(dword_8394028);
    dword_8394028 = 0;
  }
  return result;
}
// 8394028: using guessed type int dword_8394028;

//----- (0807A3E8) --------------------------------------------------------
unsigned int __cdecl sub_807A3E8(int a1)
{
  return ((unsigned int)dword_8294008[4 * a1] >> 8) - 0x10000;
}
// 8294008: using guessed type int dword_8294008[];

//----- (0807A402) --------------------------------------------------------
int __cdecl sub_807A402(int a1, int a2)
{
  __int16 *v4; // [esp+4h] [ebp-14h]
  int v5; // [esp+8h] [ebp-10h]
  __int16 *i; // [esp+Ch] [ebp-Ch]
  __int16 *v7; // [esp+14h] [ebp-4h]

  v7 = &word_8294000[8 * (unsigned __int16)word_8294000[8 * a2]];
  if ( (*((_DWORD *)v7 + 2) & 0x60) != 64 )
    return 0;
  if ( *((_DWORD *)v7 + 2) >> 8 != a1 )
  {
    v5 = (unsigned __int16)v7[6];
    for ( i = &word_8294000[8 * v5]; i != &word_8294000[8 * a2]; i = &word_8294000[8 * v5] )
    {
      v4 = &word_8294000[8 * (unsigned __int16)*i];
      if ( *((_DWORD *)v4 + 2) >> 8 == a1 )
        return v5;
      v5 = (unsigned __int16)v4[6];
    }
    return 0;
  }
  return a2;
}
// 8294000: using guessed type __int16 word_8294000[];

//----- (0807A4D2) --------------------------------------------------------
int __cdecl sub_807A4D2(int a1, int a2)
{
  return sub_807A402(a2, (unsigned __int16)((a1 + a2) % 0xFFFDu + 1));
}

//----- (0807A514) --------------------------------------------------------
int __cdecl sub_807A514(int a1, unsigned int a2, int a3)
{
  int v4; // [esp+10h] [ebp-38h]
  int v5; // [esp+14h] [ebp-34h]
  int v6; // [esp+1Ch] [ebp-2Ch]
  int v7; // [esp+20h] [ebp-28h]
  int v8; // [esp+24h] [ebp-24h]
  __int16 *v9; // [esp+28h] [ebp-20h]
  __int16 *v10; // [esp+2Ch] [ebp-1Ch]
  int v11; // [esp+30h] [ebp-18h]
  __int16 *v12; // [esp+34h] [ebp-14h]
  unsigned __int16 i; // [esp+38h] [ebp-10h]
  unsigned __int16 v14; // [esp+3Ah] [ebp-Eh]
  int v15; // [esp+3Ch] [ebp-Ch]
  __int16 *v16; // [esp+40h] [ebp-8h]
  __int16 *v17; // [esp+44h] [ebp-4h]

  v16 = &word_8294000[8 * a3];
  v17 = &word_8294000[8 * (unsigned __int16)*v16];
  v6 = *((_DWORD *)v17 + 2) & 0x60;
  if ( v6 )
  {
    if ( v6 == 64 )
    {
      if ( *((_DWORD *)v16 + 2) & 0x60 )
      {
        a3 = LOWORD(dword_8294004[0]);
        if ( !LOWORD(dword_8294004[0]) )
          sub_8084DF0((int)"exceeded maximum number of script variables");
        v16 = &word_8294000[8 * a3];
        v10 = &word_8294000[8 * (unsigned __int16)*v16];
        v14 = v10[2];
        LOWORD(dword_8294004[0]) = v14;
        word_8294002[8 * v14] = 0;
        *((_DWORD *)v10 + 2) = 32;
        v10[6] = v17[6];
        v17[6] = a3;
      }
      else
      {
        LOWORD(v11) = v16[6];
        v12 = &word_8294000[8 * (unsigned __int16)v11];
        v10 = v16;
        LOWORD(v15) = v12[1];
        v14 = v16[2];
        LOWORD(dword_8294004[4 * (unsigned __int16)word_8294000[8 * (unsigned __int16)v15]]) = v14;
        word_8294002[8 * v14] = v15;
        *v12 = *v16;
        *v16 = a3;
        v12[1] = v16[1];
        word_829400E[8 * (unsigned __int16)word_8294000[8 * (unsigned __int16)v12[1]]] = v11;
        word_8294002[8 * (unsigned __int16)v17[7]] = v11;
        *((_DWORD *)v17 + 2) &= 0xFFFFFF9F;
        *((_DWORD *)v17 + 2) |= 0x20u;
        *((_DWORD *)v10 + 2) = 64;
      }
    }
    else
    {
      if ( *((_DWORD *)v16 + 2) & 0x60 )
      {
        LOWORD(v11) = dword_8294004[0];
        if ( !LOWORD(dword_8294004[0]) )
          sub_8084DF0((int)"exceeded maximum number of script variables");
        v12 = &word_8294000[8 * (unsigned __int16)v11];
        v10 = &word_8294000[8 * (unsigned __int16)*v12];
        v14 = v10[2];
        LOWORD(dword_8294004[0]) = v14;
        word_8294002[8 * v14] = 0;
      }
      else
      {
        LOWORD(v11) = v16[6];
        v12 = &word_8294000[8 * (unsigned __int16)v11];
        v10 = v16;
        LOWORD(v15) = v12[1];
        v14 = v16[2];
        LOWORD(dword_8294004[4 * (unsigned __int16)word_8294000[8 * (unsigned __int16)v15]]) = v14;
        word_8294002[8 * v14] = v15;
      }
      HIWORD(v15) = v17[7];
      word_829400E[8 * (unsigned __int16)word_8294000[8 * (unsigned __int16)v16[1]]] = v11;
      word_8294002[8 * HIWORD(v15)] = v11;
      if ( v6 == 32 )
      {
        HIWORD(v15) = v17[6];
        for ( i = word_8294000[8 * HIWORD(v15)];
              (unsigned __int16)word_829400C[8 * i] != a3;
              i = word_8294000[8 * (unsigned __int16)word_829400C[8 * i]] )
        {
          ;
        }
        word_829400C[8 * i] = v11;
      }
      else
      {
        v17[6] = v11;
      }
      v12[1] = v16[1];
      HIWORD(v11) = *v12;
      *v12 = *v16;
      *v16 = HIWORD(v11);
      *((_DWORD *)v10 + 2) = 64;
      v10[6] = a3;
    }
  }
  else
  {
    LOWORD(v11) = v16[6];
    v14 = v17[2];
    if ( (_WORD)v11 == *v16 || *((_DWORD *)v16 + 2) & 0x60 )
    {
      v10 = v17;
    }
    else
    {
      word_8294000[8 * (unsigned __int16)v11] = *v16;
      *v16 = a3;
      v17[6] = v11;
      v17[2] = v16[2];
      v10 = v16;
    }
    LOWORD(v15) = v16[1];
    LOWORD(dword_8294004[4 * (unsigned __int16)word_8294000[8 * (unsigned __int16)v15]]) = v14;
    word_8294002[8 * v14] = v15;
    *((_DWORD *)v10 + 2) = 64;
    v10[6] = a3;
  }
  *((_DWORD *)v10 + 2) = *((unsigned __int8 *)v10 + 8);
  *((_DWORD *)v10 + 2) |= a2 << 8;
  v9 = &word_8294000[8 * a1];
  if ( (*((_DWORD *)v9 + 2) & 0x1F) == 22 )
  {
    ++v9[3];
    sub_807BF2C(&v4, a2);
    v7 = v4;
    v8 = v5;
    sub_807578C(&v7);
  }
  return a3;
}
// 8294000: using guessed type __int16 word_8294000[];
// 8294002: using guessed type __int16 word_8294002[];
// 8294004: using guessed type int dword_8294004[];
// 829400C: using guessed type __int16 word_829400C[];

//----- (0807AA14) --------------------------------------------------------
int __cdecl sub_807AA14(int a1, unsigned int a2, int a3)
{
  int result; // eax
  __int16 *v4; // ST14_4
  unsigned __int16 v5; // ST1E_2

  result = sub_807A514(a1, a2, a3);
  v4 = &word_8294000[8 * a1];
  v5 = v4[7];
  word_8294000[8 * (unsigned __int16)word_8294000[8 * result] + 7] = v5;
  word_8294000[8 * v5 + 1] = result;
  word_8294000[8 * result + 1] = v4[6];
  v4[7] = result;
  return result;
}
// 8294000: using guessed type __int16 word_8294000[];

//----- (0807AAC0) --------------------------------------------------------
int __cdecl sub_807AAC0(int a1, unsigned int a2, int a3)
{
  int result; // eax
  __int16 *v4; // ST10_4
  unsigned __int16 v5; // ST1E_2
  __int16 *v6; // ST18_4

  result = sub_807A514(a1, a2, a3);
  v4 = &word_8294000[8 * (unsigned __int16)word_8294002[8 * (unsigned __int16)word_8294000[8 * a1 + 7]]];
  v5 = v4[1];
  v6 = &word_8294000[8 * (unsigned __int16)word_8294000[8 * v5]];
  word_8294000[8 * (unsigned __int16)word_8294000[8 * result] + 7] = word_8294000[8 * a1 + 6];
  v4[1] = result;
  word_8294000[8 * result + 1] = v5;
  v6[7] = result;
  return result;
}
// 8294000: using guessed type __int16 word_8294000[];
// 8294002: using guessed type __int16 word_8294002[];

//----- (0807AB96) --------------------------------------------------------
int __cdecl sub_807AB96(int a1, unsigned int a2)
{
  return sub_807AA14(a1, a2, (a1 + a2) % 0xFFFD + 1);
}

//----- (0807ABDE) --------------------------------------------------------
int __cdecl sub_807ABDE(int a1, unsigned int a2)
{
  return sub_807AAC0(a1, a2, (a1 + a2) % 0xFFFD + 1);
}

//----- (0807AC26) --------------------------------------------------------
int __cdecl sub_807AC26(int a1, unsigned int a2)
{
  int v3; // [esp+Ch] [ebp-Ch]

  v3 = sub_807A402(a2, (a1 + a2) % 0xFFFD + 1);
  if ( !v3 )
    v3 = sub_807AA14(a1, a2, (a1 + a2) % 0xFFFD + 1);
  return v3;
}

//----- (0807AC94) --------------------------------------------------------
int __cdecl sub_807AC94(__int16 *a1, int a2)
{
  int result; // eax
  int v3; // [esp+8h] [ebp-40h]
  int v4; // [esp+Ch] [ebp-3Ch]
  int v5; // [esp+10h] [ebp-38h]
  int v6; // [esp+14h] [ebp-34h]
  unsigned int v7; // [esp+18h] [ebp-30h]
  int v8; // [esp+1Ch] [ebp-2Ch]
  int v9; // [esp+20h] [ebp-28h]
  int v10; // [esp+24h] [ebp-24h]
  int v11; // [esp+28h] [ebp-20h]
  int v12; // [esp+2Ch] [ebp-1Ch]
  __int16 *v13; // [esp+30h] [ebp-18h]
  __int16 *v14; // [esp+34h] [ebp-14h]
  int v15; // [esp+38h] [ebp-10h]
  __int16 *v16; // [esp+3Ch] [ebp-Ch]
  __int16 *v17; // [esp+40h] [ebp-8h]
  int v18; // [esp+44h] [ebp-4h]

  v15 = ((char *)a1 - (char *)word_8294000) >> 4;
  v14 = &word_8294000[8 * (unsigned __int16)*a1];
  if ( (*(_DWORD *)(a2 + 8) & 0x1F) == 22 )
  {
    --*(_WORD *)(a2 + 6);
    v7 = *((_DWORD *)v14 + 2) >> 8;
    sub_807BF2C(&v3, v7);
    v5 = v3;
    v6 = v4;
    sub_80757AC(&v5);
  }
  if ( (*((_DWORD *)v14 + 2) & 0x60) == 64 )
  {
    v18 = (unsigned __int16)v14[6];
    v17 = &word_8294000[8 * v18];
    v13 = &word_8294000[8 * (unsigned __int16)*v17];
    if ( v17 != a1 )
    {
      *((_DWORD *)v13 + 2) &= 0xFFFFFF9F;
      *((_DWORD *)v13 + 2) |= 0x40u;
      v11 = (unsigned __int16)a1[1];
      v10 = (unsigned __int16)v14[7];
      v9 = (unsigned __int16)v17[1];
      v8 = (unsigned __int16)v13[7];
      word_8294002[8 * v8] = v15;
      word_829400E[8 * (unsigned __int16)word_8294000[8 * v9]] = v15;
      word_8294002[8 * v10] = v18;
      word_829400E[8 * (unsigned __int16)word_8294000[8 * v11]] = v18;
      v12 = *(_DWORD *)a1;
      *(_DWORD *)a1 = *(_DWORD *)v17;
      *(_DWORD *)v17 = v12;
      v15 = v18;
    }
  }
  else
  {
    v17 = a1;
    v13 = v14;
    do
    {
      v16 = v17;
      v18 = (unsigned __int16)v13[6];
      v17 = &word_8294000[8 * v18];
      v13 = &word_8294000[8 * (unsigned __int16)*v17];
    }
    while ( v17 != a1 );
    word_829400C[8 * (unsigned __int16)*v16] = v14[6];
  }
  *((_DWORD *)v14 + 2) &= 0xFFFFFF9F;
  *((_DWORD *)v14 + 2) |= 0x60u;
  result = v15;
  v14[6] = v15;
  return result;
}
// 8294000: using guessed type __int16 word_8294000[];
// 8294002: using guessed type __int16 word_8294002[];
// 829400C: using guessed type __int16 word_829400C[];

//----- (0807AEBA) --------------------------------------------------------
int __cdecl sub_807AEBA(int a1)
{
  int result; // eax
  int v2; // ST08_4
  int i; // [esp+Ch] [ebp-Ch]
  int v4; // [esp+Ch] [ebp-Ch]
  __int16 *v5; // [esp+10h] [ebp-8h]
  __int16 *v6; // [esp+14h] [ebp-4h]

  v5 = &word_8294000[8 * a1];
  v6 = &word_8294000[8 * (unsigned __int16)v5[7]];
  for ( i = (unsigned __int16)*v6; i != a1; i = (unsigned __int16)*v6 )
  {
    sub_807AC94(v6, (int)v5);
    v6 = &word_8294000[8 * (unsigned __int16)word_829400E[8 * i]];
  }
  v4 = (unsigned __int16)word_8294000[8 * (unsigned __int16)v5[7]];
  while ( 1 )
  {
    result = v4;
    if ( v4 == a1 )
      break;
    v2 = v4;
    v4 = (unsigned __int16)word_8294000[8 * (unsigned __int16)word_829400E[8 * v4]];
    sub_807B778(v2);
  }
  return result;
}
// 8294000: using guessed type __int16 word_8294000[];

//----- (0807AF82) --------------------------------------------------------
int __cdecl sub_807AF82(int a1)
{
  sub_807B7BA(a1);
  sub_807AEBA(a1);
  return sub_807B8D4(a1);
}

//----- (0807AFAC) --------------------------------------------------------
int __cdecl sub_807AFAC(int a1, int a2)
{
  __int16 *v2; // ST00_4
  int result; // eax

  v2 = &word_8294000[8 * a1];
  *((_DWORD *)v2 + 2) &= 0xFFFFFFE0;
  *((_DWORD *)v2 + 2) = *((unsigned __int8 *)v2 + 8);
  *((_DWORD *)v2 + 2) |= 0x10u;
  result = *((_DWORD *)v2 + 2) | (a2 << 8);
  *((_DWORD *)v2 + 2) = result;
  return result;
}
// 8294000: using guessed type __int16 word_8294000[];

//----- (0807B004) --------------------------------------------------------
int __cdecl sub_807B004(int a1)
{
  if ( (unsigned __int16)word_8294000[8 * (unsigned __int16)word_8294000[8 * a1 + 7]] != a1 )
    sub_807AEBA(a1);
  return sub_807B7DC((unsigned __int16)word_8294000[8 * a1 + 3]);
}
// 8294000: using guessed type __int16 word_8294000[];

//----- (0807B04E) --------------------------------------------------------
int __cdecl sub_807B04E(int a1)
{
  sub_807B004(a1);
  HIWORD(dword_8294004[4 * a1]) = dword_8394024;
  return sub_807B7BA(dword_8394024);
}
// 8294004: using guessed type int dword_8294004[];
// 8394024: using guessed type int dword_8394024;

//----- (0807B084) --------------------------------------------------------
int __cdecl sub_807B084(int a1)
{
  __int16 *v1; // ST10_4
  unsigned __int16 v2; // ST16_2
  int result; // eax

  v1 = &word_8294000[8 * a1];
  v2 = sub_807B110(a1);
  sub_80796A2(v2);
  *((_DWORD *)v1 + 2) &= 0xFFFFFFE0;
  result = *((_DWORD *)v1 + 2) | 0xF;
  *((_DWORD *)v1 + 2) = result;
  return result;
}
// 8294000: using guessed type __int16 word_8294000[];

//----- (0807B110) --------------------------------------------------------
int __cdecl sub_807B110(int a1)
{
  return (unsigned __int16)((unsigned int)dword_8294008[4 * a1] >> 8);
}
// 8294008: using guessed type int dword_8294008[];

//----- (0807B128) --------------------------------------------------------
int __cdecl sub_807B128(int a1, int a2)
{
  __int16 *v2; // ST00_4
  int result; // eax

  v2 = &word_8294000[8 * a1];
  *((_DWORD *)v2 + 2) &= 0xFFFFFFE0;
  *((_DWORD *)v2 + 2) = *((unsigned __int8 *)v2 + 8);
  *((_DWORD *)v2 + 2) |= 0x11u;
  result = dword_8294008[4 * a1] | (a2 << 8);
  dword_8294008[4 * a1] = result;
  return result;
}
// 8294000: using guessed type __int16 word_8294000[];
// 8294008: using guessed type int dword_8294008[];

//----- (0807B190) --------------------------------------------------------
int __cdecl sub_807B190(int a1)
{
  __int16 *v1; // edx
  int result; // eax

  *(_DWORD *)&word_8294000[8 * a1 + 4] &= 0xFFFFFFE0;
  v1 = &word_8294000[8 * a1];
  result = *((_DWORD *)v1 + 2) | 0xF;
  *((_DWORD *)v1 + 2) = result;
  return result;
}
// 8294000: using guessed type __int16 word_8294000[];

//----- (0807B1C8) --------------------------------------------------------
unsigned int __cdecl sub_807B1C8(int a1)
{
  return (unsigned int)dword_8294008[4 * a1] >> 8;
}
// 8294008: using guessed type int dword_8294008[];

//----- (0807B1DC) --------------------------------------------------------
unsigned int __cdecl sub_807B1DC(int a1)
{
  return (unsigned int)dword_8294008[4 * a1] >> 8;
}
// 8294008: using guessed type int dword_8294008[];

//----- (0807B1F0) --------------------------------------------------------
unsigned int __cdecl sub_807B1F0(int a1)
{
  unsigned int v2; // [esp+0h] [ebp-4h]

  if ( (dword_8294008[4 * a1] & 0x1F) == 18 )
    v2 = (unsigned int)dword_8294008[4 * a1] >> 8;
  else
    v2 = 0;
  return v2;
}
// 8294008: using guessed type int dword_8294008[];

//----- (0807B22A) --------------------------------------------------------
unsigned int __cdecl sub_807B22A(unsigned int a1)
{
  while ( (dword_8294008[4 * a1] & 0x1F) == 18 )
    a1 = (unsigned int)dword_8294008[4 * a1] >> 8;
  return a1;
}
// 8294008: using guessed type int dword_8294008[];

//----- (0807B25E) --------------------------------------------------------
int __cdecl sub_807B25E(int a1)
{
  int v1; // ST10_4
  int v2; // eax
  __int16 *v3; // eax
  int result; // eax
  int v5; // [esp+14h] [ebp-14h]
  int i; // [esp+18h] [ebp-10h]
  int v7; // [esp+1Ch] [ebp-Ch]
  __int16 *v8; // [esp+24h] [ebp-4h]

  v8 = &word_8294000[8 * a1];
  sub_807B004(a1);
  v7 = sub_807BB58(dword_8394020, a1);
  if ( v7 )
  {
    for ( i = sub_807CB1E(v7); ; sub_807C228(i, v1) )
    {
      v5 = sub_807C9CE(i);
      if ( !v5 )
        break;
      v1 = (unsigned __int16)((unsigned int)dword_8294008[4 * v5] >> 8);
      v2 = sub_807BB58(i, v1);
      v3 = sub_807C4FC(v2);
      sub_80823CE(*(_DWORD *)v3, v1);
      sub_807B360(v1);
    }
    sub_807C228(dword_8394020, a1);
  }
  *((_DWORD *)v8 + 2) &= 0xFFFFFFE0;
  result = *((_DWORD *)v8 + 2) | 0x17;
  *((_DWORD *)v8 + 2) = result;
  return result;
}
// 8294000: using guessed type __int16 word_8294000[];
// 8294008: using guessed type int dword_8294008[];
// 8394020: using guessed type int dword_8394020;

//----- (0807B360) --------------------------------------------------------
int __cdecl sub_807B360(int a1)
{
  __int16 *v1; // ST04_4
  int result; // eax

  v1 = &word_8294000[8 * a1];
  sub_807B7DC((unsigned __int16)v1[3]);
  *((_DWORD *)v1 + 2) &= 0xFFFFFFE0;
  result = *((_DWORD *)v1 + 2) | 0x17;
  *((_DWORD *)v1 + 2) = result;
  return result;
}
// 8294000: using guessed type __int16 word_8294000[];

//----- (0807B3A8) --------------------------------------------------------
int sub_807B3A8()
{
  unsigned __int16 v0; // ST08_2
  unsigned __int16 v2; // [esp+Ah] [ebp-Eh]
  __int16 *v3; // [esp+Ch] [ebp-Ch]
  __int16 *v4; // [esp+10h] [ebp-8h]
  unsigned __int16 v5; // [esp+16h] [ebp-2h]

  v5 = dword_8294004[0];
  if ( !LOWORD(dword_8294004[0]) )
    sub_8084DF0((int)"exceeded maximum number of script variables");
  v4 = &word_8294000[8 * v5];
  v3 = &word_8294000[8 * (unsigned __int16)*v4];
  v2 = v3[2];
  if ( v4 != v3 && !(*((_DWORD *)v4 + 2) & 0x60) )
  {
    v0 = v4[6];
    word_8294000[8 * v0] = *v4;
    *v4 = v5;
    v3[6] = v0;
    v3[2] = v4[2];
    v3 = &word_8294000[8 * v5];
  }
  LOWORD(dword_8294004[0]) = v2;
  word_8294002[8 * v2] = 0;
  v3[6] = v5;
  v3[7] = v5;
  v4[1] = v5;
  return (unsigned __int16)*v4;
}
// 8294000: using guessed type __int16 word_8294000[];
// 8294002: using guessed type __int16 word_8294002[];
// 8294004: using guessed type int dword_8294004[];

//----- (0807B4A0) --------------------------------------------------------
int __cdecl sub_807B4A0(int a1)
{
  __int16 *v1; // ST08_4
  unsigned __int16 v2; // ST02_2
  unsigned __int16 v3; // ST06_2
  unsigned __int16 v4; // ST04_2
  int result; // eax

  v1 = &word_8294000[8 * a1];
  v2 = v1[6];
  v3 = word_8294000[8 * v2 + 1];
  v4 = v1[7];
  word_8294002[8 * v4] = v3;
  word_829400E[8 * (unsigned __int16)word_8294000[8 * v3]] = v4;
  *((_DWORD *)v1 + 2) = 0;
  v1[2] = dword_8294004[0];
  word_8294000[8 * v2 + 1] = 0;
  word_8294002[8 * LOWORD(dword_8294004[0])] = v2;
  result = v2;
  LOWORD(dword_8294004[0]) = v2;
  return result;
}
// 8294000: using guessed type __int16 word_8294000[];
// 8294002: using guessed type __int16 word_8294002[];
// 8294004: using guessed type int dword_8294004[];

//----- (0807B562) --------------------------------------------------------
int sub_807B562()
{
  int v0; // edx
  int result; // eax

  LOWORD(result) = sub_807B3A8();
  v0 = 8 * (unsigned __int16)result;
  *(_DWORD *)&word_8294000[v0 + 4] = 96;
  *(_DWORD *)&word_8294000[v0 + 4] = *(_DWORD *)&word_8294000[v0 + 4];
  return (unsigned __int16)result;
}
// 8294000: using guessed type __int16 word_8294000[];

//----- (0807B5A0) --------------------------------------------------------
int sub_807B5A0()
{
  __int16 *v0; // edx
  int result; // eax

  LOWORD(result) = sub_807B3A8();
  *(_DWORD *)&word_8294000[8 * (unsigned __int16)result + 4] = 96;
  v0 = &word_8294000[8 * (unsigned __int16)result];
  *((_DWORD *)v0 + 2) |= 0x13u;
  v0[2] = 0;
  return (unsigned __int16)result;
}
// 8294000: using guessed type __int16 word_8294000[];

//----- (0807B5EA) --------------------------------------------------------
int __cdecl sub_807B5EA(int a1, __int16 a2)
{
  __int16 *v2; // ST0C_4
  int result; // eax

  LOWORD(result) = sub_807B3A8();
  v2 = &word_8294000[8 * (unsigned __int16)result];
  *((_DWORD *)v2 + 2) = 96;
  *((_DWORD *)v2 + 2) |= 0x15u;
  *((_DWORD *)v2 + 2) |= a1 << 8;
  v2[2] = 0;
  v2[3] = a2;
  return (unsigned __int16)result;
}
// 8294000: using guessed type __int16 word_8294000[];

//----- (0807B658) --------------------------------------------------------
int sub_807B658()
{
  __int16 *v0; // edx
  int result; // eax

  LOWORD(result) = sub_807B3A8();
  *(_DWORD *)&word_8294000[8 * (unsigned __int16)result + 4] = 96;
  v0 = &word_8294000[8 * (unsigned __int16)result];
  *((_DWORD *)v0 + 2) |= 0x16u;
  v0[2] = 0;
  v0[3] = 0;
  return (unsigned __int16)result;
}
// 8294000: using guessed type __int16 word_8294000[];

//----- (0807B6AC) --------------------------------------------------------
int __cdecl sub_807B6AC(__int16 a1)
{
  __int16 *v1; // ST00_4
  int result; // eax

  LOWORD(result) = sub_807B3A8();
  v1 = &word_8294000[8 * (unsigned __int16)result];
  *((_DWORD *)v1 + 2) = 96;
  *((_DWORD *)v1 + 2) |= 0xFu;
  v1[2] = 0;
  v1[3] = a1;
  return (unsigned __int16)result;
}
// 8294000: using guessed type __int16 word_8294000[];

//----- (0807B700) --------------------------------------------------------
int __cdecl sub_807B700(__int16 a1, int a2)
{
  __int16 *v2; // ST00_4
  int result; // eax

  LOWORD(result) = sub_807B3A8();
  v2 = &word_8294000[8 * (unsigned __int16)result];
  *((_DWORD *)v2 + 2) = 96;
  *((_DWORD *)v2 + 2) |= 0x12u;
  *((_DWORD *)v2 + 2) |= a2 << 8;
  v2[2] = 0;
  v2[3] = a1;
  return (unsigned __int16)result;
}
// 8294000: using guessed type __int16 word_8294000[];

//----- (0807B766) --------------------------------------------------------
int __cdecl sub_807B766(int a1)
{
  return HIWORD(dword_8294004[4 * a1]);
}
// 8294004: using guessed type int dword_8294004[];

//----- (0807B778) --------------------------------------------------------
int __cdecl sub_807B778(int a1)
{
  sub_807BA64(*(_DWORD *)&word_8294000[8 * a1 + 4] & 0x1F, *(_DWORD *)&word_8294000[8 * a1 + 2]);
  return sub_807B4A0(a1);
}
// 8294000: using guessed type __int16 word_8294000[];

//----- (0807B7BA) --------------------------------------------------------
int __cdecl sub_807B7BA(int a1)
{
  int result; // eax

  result = LOWORD(dword_8294004[4 * a1]) + 1;
  LOWORD(dword_8294004[4 * a1]) = result;
  return result;
}
// 8294004: using guessed type int dword_8294004[];

//----- (0807B7DC) --------------------------------------------------------
int __cdecl sub_807B7DC(int a1)
{
  int result; // eax
  __int16 *v2; // [esp+14h] [ebp-4h]

  v2 = &word_8294000[8 * a1];
  if ( v2[2] )
  {
    --v2[2];
    result = (int)&word_8294000[8 * a1];
    if ( !v2[2] )
    {
      result = *((_DWORD *)v2 + 2) & 0x1F;
      if ( result == 21 )
      {
        result = (unsigned __int16)word_8294000[8 * (unsigned __int16)v2[7]];
        if ( result == a1 )
        {
          *((_DWORD *)v2 + 2) &= 0xFFFFFFE0;
          *((_DWORD *)v2 + 2) |= 0x14u;
          result = sub_807C26C((unsigned __int16)word_815AB82[6 * (*((_DWORD *)v2 + 2) >> 8)], (unsigned __int16)v2[3]);
        }
      }
    }
  }
  else
  {
    if ( (unsigned __int16)word_8294000[8 * (unsigned __int16)v2[7]] != a1 )
      sub_807AF82(a1);
    result = sub_807B4A0(a1);
  }
  return result;
}
// 815AB82: using guessed type __int16 word_815AB82[];
// 8294000: using guessed type __int16 word_8294000[];

//----- (0807B8D4) --------------------------------------------------------
int __cdecl sub_807B8D4(int a1)
{
  int result; // eax
  __int16 *v2; // [esp+4h] [ebp-4h]

  v2 = &word_8294000[8 * a1];
  if ( !v2[2] )
    return sub_807B4A0(a1);
  result = (unsigned __int16)v2[2] - 1;
  v2[2] = result;
  return result;
}
// 8294000: using guessed type __int16 word_8294000[];

//----- (0807B936) --------------------------------------------------------
int sub_807B936()
{
  int result; // eax

  result = sub_8076A2A(16) + 4;
  *(_DWORD *)(result - 4) = 0;
  return result;
}

//----- (0807B968) --------------------------------------------------------
_DWORD *__cdecl sub_807B968(_DWORD *a1)
{
  _DWORD *result; // eax

  result = (_DWORD *)sub_807B936();
  *result = *a1;
  result[1] = a1[1];
  result[2] = a1[2];
  return result;
}

//----- (0807B9A6) --------------------------------------------------------
int __cdecl sub_807B9A6(int a1)
{
  int result; // eax

  result = a1 - 1;
  if ( !*(_BYTE *)(a1 - 1) )
  {
    result = *(unsigned __int16 *)(a1 - 4) + 1;
    *(_WORD *)(a1 - 4) = result;
  }
  return result;
}

//----- (0807B9CA) --------------------------------------------------------
int __cdecl sub_807B9CA(int a1)
{
  int result; // eax

  result = a1 - 1;
  if ( !*(_BYTE *)(a1 - 1) )
  {
    if ( *(_WORD *)(a1 - 4) )
    {
      result = *(unsigned __int16 *)(a1 - 4) - 1;
      *(_WORD *)(a1 - 4) = result;
    }
    else
    {
      result = sub_8076A50(a1 - 4, 16);
    }
  }
  return result;
}

//----- (0807BA14) --------------------------------------------------------
int __cdecl sub_807BA14(signed int a1, int a2)
{
  int result; // eax

  result = a1;
  if ( a1 > 3 )
  {
    if ( a1 == 4 )
      result = sub_807B9A6(a2);
  }
  else if ( a1 >= 2 )
  {
    result = sub_807951E(a2);
  }
  else if ( a1 == 1 )
  {
    result = sub_807B7BA(a2);
  }
  return result;
}

//----- (0807BA64) --------------------------------------------------------
int __cdecl sub_807BA64(signed int a1, int a2)
{
  int result; // eax

  result = a1;
  if ( a1 > 3 )
  {
    if ( a1 == 4 )
      result = sub_807B9CA(a2);
  }
  else if ( a1 >= 2 )
  {
    result = sub_80796A2(a2);
  }
  else if ( a1 == 1 )
  {
    result = sub_807B7DC(a2);
  }
  return result;
}

//----- (0807BAB4) --------------------------------------------------------
_BOOL4 __cdecl sub_807BAB4(int a1)
{
  return (unsigned int)(a1 + 8257538) <= 0xFE0001;
}

//----- (0807BADA) --------------------------------------------------------
int __cdecl sub_807BADA(int a1)
{
  return (a1 + 0x800000) & 0xFFFFFF;
}

//----- (0807BAEC) --------------------------------------------------------
int __cdecl sub_807BAEC(int a1, int a2)
{
  return sub_807A4D2(a1, (a2 + 0x800000) & 0xFFFFFF);
}

//----- (0807BB10) --------------------------------------------------------
int __cdecl sub_807BB10(int a1, int a2)
{
  return (unsigned __int16)word_8294000[8 * sub_807BAEC(a1, a2)];
}
// 8294000: using guessed type __int16 word_8294000[];

//----- (0807BB34) --------------------------------------------------------
int __cdecl sub_807BB34(int a1, int a2)
{
  return (unsigned __int16)word_8294000[8 * sub_807A4D2(a1, a2)];
}
// 8294000: using guessed type __int16 word_8294000[];

//----- (0807BB58) --------------------------------------------------------
int __cdecl sub_807BB58(int a1, int a2)
{
  return (unsigned __int16)word_8294000[8 * sub_807A4D2(a1, a2 + 0x10000)];
}
// 8294000: using guessed type __int16 word_8294000[];

//----- (0807BB82) --------------------------------------------------------
int __cdecl sub_807BB82(int a1, int a2)
{
  return sub_807AC26(a1, (a2 + 0x800000) & 0xFFFFFF);
}

//----- (0807BBA6) --------------------------------------------------------
int __cdecl sub_807BBA6(int a1, int a2)
{
  return sub_807AB96(a1, (a2 + 0x800000) & 0xFFFFFF);
}

//----- (0807BBCA) --------------------------------------------------------
int __cdecl sub_807BBCA(int a1, int a2)
{
  char *v2; // eax
  signed int v4; // [esp+8h] [ebp-10h]
  int v5; // [esp+Ch] [ebp-Ch]
  int v6; // [esp+14h] [ebp-4h]

  v5 = *(_DWORD *)&word_8294000[8 * a1 + 4] & 0x1F;
  if ( v5 <= 19 )
    return sub_807C0A8(a1, a2);
  if ( v5 == 21 )
  {
    v6 = sub_807BB34(a1, a2);
    if ( v6 )
    {
      v4 = v6;
    }
    else
    {
      dword_8394040 = a1;
      dword_8394044 = a2;
      v4 = 65534;
    }
  }
  else
  {
    v2 = va("cannot set field of %s", *(_DWORD *)&off_815ABC0[4 * v5]);
    sub_8084DB4((int)v2);
    v4 = 0;
  }
  return v4;
}
// 8294000: using guessed type __int16 word_8294000[];
// 8394040: using guessed type int dword_8394040;
// 8394044: using guessed type int dword_8394044;

//----- (0807BC7C) --------------------------------------------------------
int *__userpurge sub_807BC7C@<eax>(int *a1, int a2, int a3)
{
  int v4; // [esp+18h] [ebp-10h]
  int v5; // [esp+24h] [ebp-4h]

  v5 = sub_807BB34(a2, a3);
  if ( v5 )
  {
    sub_807C66A(a1, v5);
  }
  else if ( (*(_DWORD *)&word_8294000[8 * a2 + 4] & 0x1F) == 21 )
  {
    sub_807C72C(a1, a2, a3);
  }
  else
  {
    *a1 = v4;
    a1[1] = 0;
  }
  return a1;
}
// 8294000: using guessed type __int16 word_8294000[];

//----- (0807BF2C) --------------------------------------------------------
_DWORD *__userpurge sub_807BF2C@<eax>(_DWORD *a1, unsigned int a2)
{
  if ( a2 > 0xFFFF )
  {
    if ( a2 > 0x1FFFD )
    {
      a1[1] = 6;
      *a1 = a2 - 0x800000;
    }
    else
    {
      a1[1] = 1;
      *a1 = a2 - 0x10000;
    }
  }
  else
  {
    a1[1] = 2;
    *a1 = (unsigned __int16)a2;
  }
  return a1;
}

//----- (0807BF8E) --------------------------------------------------------
int __cdecl sub_807BF8E(int a1, int a2, int a3)
{
  int result; // eax
  int v4; // [esp+18h] [ebp-10h]
  __int16 *v5; // [esp+1Ch] [ebp-Ch]
  int v6; // [esp+38h] [ebp+10h]

  if ( sub_807A4D2(a1, a2) )
    return sub_807C16E(a1, a2);
  v5 = &word_8294000[8 * a1];
  result = *((_DWORD *)v5 + 2) & 0x1F;
  if ( result == 21 )
  {
    v4 = *((_DWORD *)v5 + 2) >> 8;
    result = sub_807BB10((unsigned __int16)word_815AB80[6 * v4], a2);
    if ( result )
    {
      v6 = a3 + 8;
      *(_DWORD *)(v6 + 4) = 0;
      result = sub_8084E4E(v4, (unsigned __int16)v5[3], dword_8294004[4 * result], v6);
    }
  }
  return result;
}
// 815AB80: using guessed type __int16 word_815AB80[];
// 8294000: using guessed type __int16 word_8294000[];
// 8294004: using guessed type int dword_8294004[];

//----- (0807C060) --------------------------------------------------------
int __cdecl sub_807C060(int a1, int a2)
{
  return (unsigned __int16)word_8294000[8 * sub_807BB82(a1, a2)];
}
// 8294000: using guessed type __int16 word_8294000[];

//----- (0807C084) --------------------------------------------------------
int __cdecl sub_807C084(int a1, int a2)
{
  return (unsigned __int16)word_8294000[8 * sub_807BBA6(a1, a2)];
}
// 8294000: using guessed type __int16 word_8294000[];

//----- (0807C0A8) --------------------------------------------------------
int __cdecl sub_807C0A8(int a1, unsigned int a2)
{
  return (unsigned __int16)word_8294000[8 * sub_807AC26(a1, a2)];
}
// 8294000: using guessed type __int16 word_8294000[];

//----- (0807C0CC) --------------------------------------------------------
int __cdecl sub_807C0CC(int a1, unsigned int a2)
{
  return (unsigned __int16)word_8294000[8 * sub_807AB96(a1, a2)];
}
// 8294000: using guessed type __int16 word_8294000[];

//----- (0807C0F0) --------------------------------------------------------
int __cdecl sub_807C0F0(int a1, int a2)
{
  return (unsigned __int16)word_8294000[8 * sub_807AC26(a1, a2 + 0x10000)];
}
// 8294000: using guessed type __int16 word_8294000[];

//----- (0807C11A) --------------------------------------------------------
int __cdecl sub_807C11A(int a1, int a2)
{
  return (unsigned __int16)word_8294000[8 * sub_807AB96(a1, a2 + 0x10000)];
}
// 8294000: using guessed type __int16 word_8294000[];

//----- (0807C144) --------------------------------------------------------
int __cdecl sub_807C144(int a1, int a2)
{
  return (unsigned __int16)word_8294000[8 * sub_807ABDE(a1, a2 + 0x10000)];
}
// 8294000: using guessed type __int16 word_8294000[];

//----- (0807C16E) --------------------------------------------------------
int __cdecl sub_807C16E(int a1, int a2)
{
  int v2; // eax
  int v3; // ST0C_4

  v2 = sub_807A4D2(a1, a2);
  v3 = (unsigned __int16)word_8294000[8 * v2];
  sub_807AC94(&word_8294000[8 * v2], 16 * a1 + 136921088);
  return sub_807B778(v3);
}
// 8294000: using guessed type __int16 word_8294000[];

//----- (0807C1CC) --------------------------------------------------------
int __cdecl sub_807C1CC(int a1)
{
  __int16 *v1; // ST14_4
  unsigned __int16 v2; // ST10_2

  v1 = &word_8294000[8 * (unsigned __int16)word_829400E[8 * a1]];
  v2 = *v1;
  sub_807AC94(v1, 16 * a1 + 136921088);
  return sub_807B778(v2);
}
// 8294000: using guessed type __int16 word_8294000[];

//----- (0807C228) --------------------------------------------------------
int __cdecl sub_807C228(int a1, int a2)
{
  return sub_807C16E(a1, a2 + 0x10000);
}

//----- (0807C248) --------------------------------------------------------
int __cdecl sub_807C248(int a1, int a2)
{
  return sub_807C290(a1, (a2 + 0x800000) & 0xFFFFFF);
}

//----- (0807C26C) --------------------------------------------------------
int __cdecl sub_807C26C(int a1, int a2)
{
  return sub_807C16E(a1, (a2 + 0x800000) & 0xFFFFFF);
}

//----- (0807C290) --------------------------------------------------------
int __cdecl sub_807C290(int a1, int a2)
{
  int result; // eax
  int v3; // ST10_4

  result = sub_807A4D2(a1, a2);
  if ( result )
  {
    v3 = (unsigned __int16)word_8294000[8 * result];
    sub_807AC94(&word_8294000[8 * result], 16 * a1 + 136921088);
    result = sub_807B778(v3);
  }
  return result;
}
// 8294000: using guessed type __int16 word_8294000[];

//----- (0807C2F6) --------------------------------------------------------
int __cdecl sub_807C2F6(int a1, int a2)
{
  int result; // eax
  int i; // [esp+8h] [ebp-20h]
  __int16 *v4; // [esp+10h] [ebp-18h]
  __int16 *v5; // [esp+14h] [ebp-14h]
  int v6; // [esp+18h] [ebp-10h]

  for ( i = (unsigned __int16)word_8294000[8 * (unsigned __int16)word_829400E[8 * a1]];
        ;
        i = (unsigned __int16)word_8294000[8 * (unsigned __int16)word_829400E[8 * i]] )
  {
    result = i;
    if ( i == a1 )
      break;
    v5 = &word_8294000[8 * i];
    v6 = *((_DWORD *)v5 + 2) & 0x1F;
    v4 = &word_8294000[8 * (unsigned __int16)word_8294000[8 * sub_807AC26(a2, *((_DWORD *)v5 + 2) >> 8)]];
    *((_DWORD *)v4 + 2) |= v6;
    if ( v6 == 1 )
    {
      if ( (dword_8294008[4 * *((_DWORD *)v5 + 1)] & 0x1F) == 22 )
      {
        *((_DWORD *)v4 + 1) = sub_807B658();
        sub_807C2F6(*((_DWORD *)v5 + 1), *((_DWORD *)v4 + 1));
      }
      else
      {
        *((_DWORD *)v4 + 1) = *((_DWORD *)v5 + 1);
        sub_807B7BA(*((_DWORD *)v5 + 1));
      }
    }
    else
    {
      *((_DWORD *)v4 + 1) = *((_DWORD *)v5 + 1);
      sub_807BA14(v6, *((_DWORD *)v5 + 1));
    }
  }
  return result;
}
// 8294000: using guessed type __int16 word_8294000[];
// 8294008: using guessed type int dword_8294008[];

//----- (0807C45C) --------------------------------------------------------
int __cdecl sub_807C45C(int a1, int *a2)
{
  __int16 *v2; // ST14_4
  int result; // eax

  v2 = &word_8294000[8 * a1];
  sub_807BA64(*((_DWORD *)v2 + 2) & 0x1F, *((_DWORD *)v2 + 1));
  *((_DWORD *)v2 + 2) &= 0xFFFFFFE0;
  *((_DWORD *)v2 + 2) |= a2[1];
  result = *a2;
  *((_DWORD *)v2 + 1) = *a2;
  return result;
}
// 8294000: using guessed type __int16 word_8294000[];

//----- (0807C4C2) --------------------------------------------------------
int __cdecl sub_807C4C2(int a1, int *a2)
{
  int result; // eax

  *(_DWORD *)&word_8294000[8 * a1 + 4] |= a2[1];
  result = *a2;
  *(_DWORD *)&word_8294000[8 * a1 + 2] = *a2;
  return result;
}
// 8294000: using guessed type __int16 word_8294000[];

//----- (0807C4FC) --------------------------------------------------------
__int16 *__cdecl sub_807C4FC(int a1)
{
  return &word_8294000[8 * a1 + 2];
}
// 8294000: using guessed type __int16 word_8294000[];

//----- (0807C51C) --------------------------------------------------------
signed int __cdecl sub_807C51C(int a1, unsigned int a2, signed int *a3)
{
  signed int result; // eax
  int v4; // eax
  __int16 *v5; // edx
  int v6; // [esp+1Ch] [ebp-Ch]

  v6 = sub_807BB10((unsigned __int16)word_815AB80[6 * (*(_DWORD *)&word_8294000[8 * a1 + 4] >> 8)], a2);
  if ( !v6
    || (result = sub_8084E4E(
                   *(_DWORD *)&word_8294000[8 * a1 + 4] >> 8,
                   (unsigned __int16)word_8294000[8 * a1 + 3],
                   dword_8294004[4 * v6],
                   (int)a3),
        !(_BYTE)result) )
  {
    v4 = sub_807C0CC(a1, a2);
    *(_DWORD *)&word_8294000[8 * v4 + 4] |= a3[1];
    v5 = &word_8294000[8 * v4 + 2];
    result = *a3;
    *(_DWORD *)v5 = *a3;
  }
  return result;
}
// 815AB80: using guessed type __int16 word_815AB80[];
// 8294000: using guessed type __int16 word_8294000[];
// 8294004: using guessed type int dword_8294004[];

//----- (0807C5E2) --------------------------------------------------------
unsigned int __cdecl sub_807C5E2(int a1)
{
  __int16 *v1; // edx
  unsigned int result; // eax

  sub_807BA64(*(_DWORD *)&word_8294000[8 * a1 + 4] & 0x1F, *(_DWORD *)&word_8294000[8 * a1 + 2]);
  v1 = &word_8294000[8 * a1];
  result = *((_DWORD *)v1 + 2) & 0xFFFFFFE0;
  *((_DWORD *)v1 + 2) = result;
  return result;
}
// 8294000: using guessed type __int16 word_8294000[];

//----- (0807C628) --------------------------------------------------------
signed int __cdecl sub_807C628(int a1, signed int *a2)
{
  signed int result; // eax

  if ( a1 == 65534 )
    result = sub_807C51C(dword_8394040, dword_8394044, a2);
  else
    result = sub_807C45C(a1, a2);
  return result;
}
// 8394040: using guessed type int dword_8394040;
// 8394044: using guessed type int dword_8394044;

//----- (0807C66A) --------------------------------------------------------
int *__userpurge sub_807C66A@<eax>(int *a1, int a2)
{
  a1[1] = *(_DWORD *)&word_8294000[8 * a2 + 4] & 0x1F;
  *a1 = *(_DWORD *)&word_8294000[8 * a2 + 2];
  sub_807578C(a1);
  return a1;
}
// 8294000: using guessed type __int16 word_8294000[];

//----- (0807C6AE) --------------------------------------------------------
int __cdecl sub_807C6AE(int a1)
{
  char *v1; // eax
  int v4; // [esp+10h] [ebp-8h]
  __int16 *v5; // [esp+14h] [ebp-4h]

  v5 = &word_8294000[8 * a1];
  v4 = *((_DWORD *)v5 + 2) & 0x1F;
  if ( v4 == 1 )
  {
    v4 = dword_8294008[4 * *((_DWORD *)v5 + 1)] & 0x1F;
    if ( v4 <= 21 )
      return *((_DWORD *)v5 + 1);
  }
  v1 = va("%s is not a field object", *(_DWORD *)&off_815ABC0[4 * v4]);
  sub_8084DB4((int)v1);
  return 0;
}
// 8294000: using guessed type __int16 word_8294000[];
// 8294008: using guessed type int dword_8294008[];

//----- (0807C72C) --------------------------------------------------------
int *__userpurge sub_807C72C@<eax>(int *a1, int a2, int a3)
{
  int v3; // edx
  int v5; // [esp+10h] [ebp-18h]
  int v6; // [esp+14h] [ebp-14h]
  int v7; // [esp+18h] [ebp-10h]
  int v8; // [esp+1Ch] [ebp-Ch]
  __int16 *v9; // [esp+20h] [ebp-8h]
  __int16 *v10; // [esp+24h] [ebp-4h]

  v9 = &word_8294000[8 * a2];
  v8 = sub_807BB10((unsigned __int16)word_815AB80[6 * (*((_DWORD *)v9 + 2) >> 8)], a3);
  if ( v8 )
  {
    sub_8084ECA(&v5, (char *)(*((_DWORD *)v9 + 2) >> 8), (unsigned __int16)v9[3], dword_8294004[4 * v8]);
    v3 = v6;
    *a1 = v5;
    a1[1] = v3;
    if ( a1[1] == 1 )
    {
      v10 = &word_8294000[8 * *a1];
      if ( (*((_DWORD *)v10 + 2) & 0x1F) == 22 )
      {
        if ( v10[2] )
        {
          v7 = *a1;
          sub_807B7DC(v7);
          *a1 = sub_807B658();
          sub_807C2F6(v7, *a1);
        }
      }
    }
  }
  else
  {
    a1[1] = 0;
  }
  return a1;
}
// 815AB80: using guessed type __int16 word_815AB80[];
// 8294000: using guessed type __int16 word_8294000[];
// 8294004: using guessed type int dword_8294004[];

//----- (0807C83C) --------------------------------------------------------
int *__userpurge sub_807C83C@<eax>(int *a1, int a2)
{
  int v3; // [esp+10h] [ebp-18h]
  int v4; // [esp+14h] [ebp-14h]
  int v5; // [esp+18h] [ebp-10h]
  int v6; // [esp+1Ch] [ebp-Ch]
  int v7; // [esp+20h] [ebp-8h]
  int v8; // [esp+24h] [ebp-4h]

  if ( a2 == 65534 )
  {
    sub_807C72C(&v5, dword_8394040, dword_8394044);
    v3 = v5;
    v4 = v6;
  }
  else
  {
    sub_807C66A(&v7, a2);
    v3 = v7;
    v4 = v8;
  }
  *a1 = v3;
  a1[1] = v4;
  return a1;
}
// 8394040: using guessed type int dword_8394040;
// 8394044: using guessed type int dword_8394044;

//----- (0807C8B2) --------------------------------------------------------
void __cdecl sub_807C8B2(int *a1)
{
  int v1; // ST18_4
  const char *v2; // eax
  char *v3; // ST14_4
  signed int v4; // [esp+Ch] [ebp-1Ch]
  int v5; // [esp+1Ch] [ebp-Ch]
  __int16 *v6; // [esp+20h] [ebp-8h]

  if ( a1[1] == 1 )
  {
    v5 = *a1;
    v6 = &word_8294000[8 * *a1];
    a1[1] = 6;
    if ( (*((_DWORD *)v6 + 2) & 0x1F) == 22 )
      v4 = (unsigned __int16)v6[3];
    else
      v4 = 1;
    *a1 = v4;
    sub_807B7DC(v5);
  }
  else if ( a1[1] == 2 )
  {
    a1[1] = 6;
    v1 = *a1;
    v2 = (const char *)sub_8078896(*a1);
    *a1 = strlen(v2);
    sub_80796A2(v1);
  }
  else
  {
    v3 = va("size cannot be applied to %s", *(_DWORD *)&off_815ABC0[4 * a1[1]]);
    sub_80757AC(a1);
    a1[1] = 0;
    sub_8084DB4((int)v3);
  }
}
// 8294000: using guessed type __int16 word_8294000[];

//----- (0807C9AC) --------------------------------------------------------
int __cdecl sub_807C9AC(int a1)
{
  return (unsigned __int16)word_8294000[8 * a1 + 3];
}
// 8294000: using guessed type __int16 word_8294000[];

//----- (0807C9CE) --------------------------------------------------------
int __cdecl sub_807C9CE(int a1)
{
  int v2; // [esp+0h] [ebp-8h]

  if ( (dword_8294008[4 * (unsigned __int16)word_8294000[8 * (unsigned __int16)word_829400E[8 * a1]]] & 0x1Fu) > 0xE )
    v2 = 0;
  else
    v2 = (unsigned __int16)word_8294000[8 * (unsigned __int16)word_829400E[8 * a1]];
  return v2;
}
// 8294000: using guessed type __int16 word_8294000[];
// 8294008: using guessed type int dword_8294008[];

//----- (0807CA16) --------------------------------------------------------
int __cdecl sub_807CA16(int a1)
{
  int v2; // [esp+0h] [ebp-8h]

  if ( (dword_8294008[4
                    * (unsigned __int16)word_8294000[8
                                                   * (unsigned __int16)word_8294002[8
                                                                                  * (unsigned __int16)word_8294002[8 * (unsigned __int16)word_829400E[8 * a1]]]]] & 0x1Fu) > 0xE )
    v2 = 0;
  else
    v2 = (unsigned __int16)word_8294000[8
                                      * (unsigned __int16)word_8294002[8
                                                                     * (unsigned __int16)word_8294002[8 * (unsigned __int16)word_829400E[8 * a1]]]];
  return v2;
}
// 8294000: using guessed type __int16 word_8294000[];
// 8294002: using guessed type __int16 word_8294002[];
// 8294008: using guessed type int dword_8294008[];

//----- (0807CA72) --------------------------------------------------------
unsigned int __cdecl sub_807CA72(int a1)
{
  return (unsigned int)dword_8294008[4 * a1] >> 8;
}
// 8294008: using guessed type int dword_8294008[];

//----- (0807CA86) --------------------------------------------------------
int __cdecl sub_807CA86(int a1)
{
  __int16 *v2; // [esp+0h] [ebp-8h]

  v2 = &word_8294000[8 * a1];
  if ( !(*((_DWORD *)v2 + 2) & 0x1F) )
  {
    *((_DWORD *)v2 + 2) |= 1u;
    *((_DWORD *)v2 + 1) = sub_807B5A0();
  }
  return *((_DWORD *)v2 + 1);
}
// 8294000: using guessed type __int16 word_8294000[];

//----- (0807CAD2) --------------------------------------------------------
int __cdecl sub_807CAD2(int a1)
{
  __int16 *v2; // [esp+0h] [ebp-8h]

  v2 = &word_8294000[8 * a1];
  if ( !(*((_DWORD *)v2 + 2) & 0x1F) )
  {
    *((_DWORD *)v2 + 2) |= 1u;
    *((_DWORD *)v2 + 1) = sub_807B658();
  }
  return *((_DWORD *)v2 + 1);
}
// 8294000: using guessed type __int16 word_8294000[];

//----- (0807CB1E) --------------------------------------------------------
int __cdecl sub_807CB1E(int a1)
{
  return *(_DWORD *)&word_8294000[8 * a1 + 2];
}
// 8294000: using guessed type __int16 word_8294000[];

//----- (0807CB3E) --------------------------------------------------------
_BOOL4 __cdecl sub_807CB3E(int a1)
{
  return (*(_DWORD *)&word_8294000[8 * a1 + 4] & 0x1Fu) <= 0x15;
}
// 8294000: using guessed type __int16 word_8294000[];

//----- (0807CBAA) --------------------------------------------------------
_BOOL4 __cdecl sub_807CBAA(int a1)
{
  _BOOL4 result; // eax

  sub_807CC38((float *)a1);
  result = a1;
  if ( *(_DWORD *)(a1 + 4) == 6 )
  {
    result = *(_DWORD *)a1 == 0;
    *(_DWORD *)a1 = result;
  }
  return result;
}

//----- (0807CBD8) --------------------------------------------------------
void __cdecl sub_807CBD8(int *a1)
{
  int v1; // ST14_4
  char *v2; // eax

  if ( a1[1] == 6 )
  {
    *a1 = ~*a1;
  }
  else
  {
    v1 = a1[1];
    sub_80757AC(a1);
    a1[1] = 0;
    v2 = va("~ cannot be applied to \"%s\"", *(_DWORD *)&off_815ABC0[4 * v1]);
    sub_8084DB4((int)v2);
  }
}

//----- (0807CC38) --------------------------------------------------------
void __cdecl sub_807CC38(float *a1)
{
  int v1; // ST14_4
  char *v2; // eax

  if ( *((_DWORD *)a1 + 1) == 6 )
  {
    *(_DWORD *)a1 = *(_DWORD *)a1 != 0;
  }
  else if ( *((_DWORD *)a1 + 1) == 5 )
  {
    *((_DWORD *)a1 + 1) = 6;
    *(_DWORD *)a1 = 0.0 != *a1;
  }
  else
  {
    v1 = *((_DWORD *)a1 + 1);
    sub_80757AC(a1);
    a1[1] = 0.0;
    v2 = va("cannot cast %s to bool", *(_DWORD *)&off_815ABC0[4 * v1]);
    sub_8084DB4((int)v2);
  }
}

//----- (0807CCCE) --------------------------------------------------------
signed int __cdecl sub_807CCCE(int *a1)
{
  int v1; // ST10_4
  signed int v3; // [esp+Ch] [ebp-Ch]

  switch ( a1[1] )
  {
    case 2:
      return 1;
    case 6:
      a1[1] = 2;
      *a1 = sub_807986A(*a1);
      v3 = 1;
      break;
    case 5:
      a1[1] = 2;
      *a1 = sub_8079824(*(float *)a1);
      v3 = 1;
      break;
    case 4:
      a1[1] = 2;
      v1 = *a1;
      *a1 = sub_80798B0((float *)*a1);
      sub_807B9CA(v1);
      v3 = 1;
      break;
    default:
      *(_DWORD *)dword_8394010 = va("cannot cast %s to string", *(_DWORD *)&off_815ABC0[4 * a1[1]]);
      sub_80757AC(a1);
      a1[1] = 0;
      v3 = 0;
      break;
  }
  return v3;
}

//----- (0807CDD0) --------------------------------------------------------
signed int __cdecl sub_807CDD0(int *a1)
{
  signed int result; // eax
  int v2; // ST24_4
  int v3; // eax
  int v4; // ST1C_4
  char *s; // [esp+20h] [ebp-8h]

  switch ( a1[1] )
  {
    case 0:
    case 7:
    case 8:
    case 9:
    case 10:
      s = *(char **)&off_815ABC0[4 * a1[1]];
      goto LABEL_7;
    case 1:
      s = *(char **)&off_815ABC0[4 * sub_807DF7C(*a1)];
      goto LABEL_7;
    case 2:
    case 4:
    case 5:
    case 6:
      result = sub_807CCCE(a1);
      break;
    case 3:
      result = (signed int)a1;
      a1[1] = 2;
      break;
    case 11:
      v2 = *a1;
      v3 = sub_806D074((unsigned int)*a1 >> 16);
      s = sub_80BE94C(v3, (unsigned __int16)v2);
LABEL_7:
      v4 = sub_8079290(s, 0);
      sub_80757AC(a1);
      a1[1] = 2;
      result = v4;
      *a1 = v4;
      break;
  }
  return result;
}

//----- (0807CEE4) --------------------------------------------------------
int __cdecl sub_807CEE4(int a1)
{
  int result; // eax
  signed int i; // [esp+4h] [ebp-4h]

  for ( i = 2; i >= 0; --i )
    sub_80757AC((_DWORD *)(a1 + 8 * i));
  result = a1;
  *(_DWORD *)(a1 + 4) = 0;
  return result;
}

//----- (0807CF1E) --------------------------------------------------------
void __cdecl sub_807CF1E(_DWORD *a1)
{
  char *v1; // eax
  int v2; // [esp+18h] [ebp-20h]
  signed int i; // [esp+1Ch] [ebp-1Ch]
  int v4[6]; // [esp+20h] [ebp-18h]

  for ( i = 2; i >= 0; --i )
  {
    v2 = a1[2 * i + 1];
    if ( v2 == 5 )
    {
      v4[2 - i] = a1[2 * i];
    }
    else
    {
      if ( v2 != 6 )
      {
        dword_8394014 = i + 1;
        sub_807CEE4((int)a1);
        v1 = va("type %s is not a float", *(_DWORD *)&off_815ABC0[4 * v2]);
        sub_8084DB4((int)v1);
        return;
      }
      *(float *)&v4[2 - i] = (long double)(signed int)a1[2 * i];
    }
  }
  a1[1] = 4;
  *a1 = sub_807B968(v4);
}
// 8394014: using guessed type int dword_8394014;
// 807CF1E: using guessed type int var_18[6];

//----- (0807CFFA) --------------------------------------------------------
int __cdecl sub_807CFFA(int a1, int *a2)
{
  char *v2; // eax
  int v4; // [esp+14h] [ebp-14h]
  int v5; // [esp+18h] [ebp-10h]
  int v6; // [esp+1Ch] [ebp-Ch]
  int v7; // [esp+24h] [ebp-4h]

  v7 = a2[1];
  if ( v7 != 1 || (v7 = dword_8294008[4 * *a2] & 0x1F, v7 > 21) )
  {
    sub_80757AC(a2);
    v2 = va("%s is not a field object", *(_DWORD *)&off_815ABC0[4 * v7]);
    sub_8084DB4((int)v2);
    v4 = 0;
  }
  else
  {
    v6 = 1;
    v5 = *a2;
    sub_807C45C(a1, &v5);
    v4 = v5;
  }
  return v4;
}
// 8294008: using guessed type int dword_8294008[];

//----- (0807D08C) --------------------------------------------------------
void __cdecl sub_807D08C(int *a1, int *a2)
{
  int v2; // ST20_4
  int v3; // ST1C_4
  int v4; // ebx
  int v5; // eax
  char *v6; // [esp+18h] [ebp-10h]

  if ( *(_DWORD *)dword_8394010 )
  {
    v6 = 0;
  }
  else
  {
    v2 = a1[1];
    v3 = a2[1];
    sub_807CDD0(a1);
    sub_807CDD0(a2);
    v4 = sub_8078896(*a2);
    v5 = sub_8078896(*a1);
    v6 = va(
           "pair '%s' and '%s' has unmatching types '%s' and '%s'",
           v5,
           v4,
           *(_DWORD *)&off_815ABC0[4 * v2],
           *(_DWORD *)&off_815ABC0[4 * v3]);
  }
  sub_80757AC(a1);
  a1[1] = 0;
  sub_80757AC(a2);
  a2[1] = 0;
  sub_8084DB4((int)v6);
}

//----- (0807D15A) --------------------------------------------------------
void __cdecl sub_807D15A(int *a1, int *a2)
{
  int v2; // [esp+10h] [ebp-8h]
  int v3; // [esp+14h] [ebp-4h]

  v3 = a1[1];
  v2 = a2[1];
  if ( v3 != v2 )
  {
    if ( v3 != 5 || v2 != 6 )
    {
      if ( v3 != 6 || v2 != 5 )
      {
        sub_807D08C(a1, a2);
      }
      else
      {
        a1[1] = 5;
        *(float *)a1 = (long double)*a1;
      }
    }
    else
    {
      a2[1] = 5;
      *(float *)a2 = (long double)*a2;
    }
  }
}

//----- (0807D1D4) --------------------------------------------------------
void __cdecl sub_807D1D4(int *a1, int a2)
{
  float v2; // ST18_4
  int v3; // ST18_4
  signed int v4; // [esp+1Ch] [ebp-Ch]
  signed int v5; // [esp+20h] [ebp-8h]

  v5 = a1[1];
  v4 = *(_DWORD *)(a2 + 4);
  if ( v5 != v4 )
  {
    if ( v5 < v4 )
    {
      if ( v5 == 2 )
      {
        if ( v4 == 5 )
        {
          *(_DWORD *)(a2 + 4) = 2;
          *(_DWORD *)a2 = sub_8079824(*(float *)a2);
          return;
        }
        if ( v4 > 5 )
        {
          if ( v4 == 6 )
          {
            *(_DWORD *)(a2 + 4) = 2;
            *(_DWORD *)a2 = sub_807986A(*(_DWORD *)a2);
            return;
          }
        }
        else if ( v4 == 4 )
        {
          *(_DWORD *)(a2 + 4) = 2;
          v2 = *(float *)a2;
          *(_DWORD *)a2 = sub_80798B0(*(float **)a2);
          sub_807B9CA(SLODWORD(v2));
          return;
        }
      }
      else if ( v5 != 5 )
      {
LABEL_31:
        sub_807D08C(a1, (int *)a2);
        return;
      }
      if ( v4 == 6 )
      {
        *(_DWORD *)(a2 + 4) = 5;
        *(float *)a2 = (long double)*(signed int *)a2;
        return;
      }
      goto LABEL_31;
    }
    if ( v4 == 2 )
    {
      if ( v5 == 5 )
      {
        a1[1] = 2;
        *a1 = sub_8079824(*(float *)a1);
        return;
      }
      if ( v5 > 5 )
      {
        if ( v5 == 6 )
        {
          a1[1] = 2;
          *a1 = sub_807986A(*a1);
          return;
        }
      }
      else if ( v5 == 4 )
      {
        a1[1] = 2;
        v3 = *a1;
        *a1 = sub_80798B0((float *)*a1);
        sub_807B9CA(v3);
        return;
      }
    }
    else if ( v4 != 5 )
    {
      goto LABEL_31;
    }
    if ( v5 == 6 )
    {
      a1[1] = 5;
      *(float *)a1 = (long double)*a1;
      return;
    }
    goto LABEL_31;
  }
}

//----- (0807D3B6) --------------------------------------------------------
void __cdecl sub_807D3B6(int *a1, int *a2)
{
  if ( a1[1] != 6 || a2[1] != 6 )
    sub_807D08C(a1, a2);
  else
    *a1 |= *a2;
}

//----- (0807D3F4) --------------------------------------------------------
void __cdecl sub_807D3F4(int *a1, int *a2)
{
  if ( a1[1] != 6 || a2[1] != 6 )
    sub_807D08C(a1, a2);
  else
    *a1 ^= *a2;
}

//----- (0807D432) --------------------------------------------------------
void __cdecl sub_807D432(int *a1, int *a2)
{
  if ( a1[1] != 6 || a2[1] != 6 )
    sub_807D08C(a1, a2);
  else
    *a1 &= *a2;
}

//----- (0807D470) --------------------------------------------------------
void __cdecl sub_807D470(int *a1, int *a2)
{
  float v2; // ST00_4
  _BOOL4 v3; // ST10_4
  _BOOL4 v4; // ST10_4
  signed int v5; // [esp+Ch] [ebp-Ch]

  sub_807D15A(a1, a2);
  switch ( a1[1] )
  {
    case 0:
      a1[1] = 6;
      *a1 = 1;
      break;
    case 1:
      if ( ((dword_8294008[4 * *a1] & 0x1F) == 22 || (dword_8294008[4 * *a2] & 0x1F) == 22) && !byte_839400C )
        goto LABEL_17;
      a1[1] = 6;
      v4 = *a1 == *a2;
      sub_807B7DC(*a1);
      sub_807B7DC(*a2);
      *a1 = v4;
      break;
    case 2:
    case 3:
      a1[1] = 6;
      v3 = *a1 == *a2;
      sub_80796A2(*a1);
      sub_80796A2(*a2);
      *a1 = v3;
      break;
    case 4:
      a1[1] = 6;
      v5 = 0;
      if ( *(float *)*a1 == *(float *)*a2
        && *(float *)(*a1 + 4) == *(float *)(*a2 + 4)
        && *(float *)(*a1 + 8) == *(float *)(*a2 + 8) )
      {
        v5 = 1;
      }
      sub_807B9CA(*a1);
      sub_807B9CA(*a2);
      *a1 = v5;
      break;
    case 5:
      a1[1] = 6;
      v2 = *(float *)a1 - *(float *)a2;
      *a1 = 0.000001 > sub_807F7F4(v2);
      break;
    case 6:
      *a1 = *a1 == *a2;
      break;
    case 7:
    case 8:
    case 10:
LABEL_17:
      sub_807D08C(a1, a2);
      break;
    case 9:
      a1[1] = 6;
      *a1 = *a1 == *a2;
      break;
    case 11:
      a1[1] = 6;
      *a1 = *a1 == *a2;
      break;
  }
}
// 8294008: using guessed type int dword_8294008[];
// 839400C: using guessed type char byte_839400C;

//----- (0807D6D6) --------------------------------------------------------
_BOOL4 __cdecl sub_807D6D6(int *a1, int *a2)
{
  _BOOL4 result; // eax

  sub_807D470(a1, a2);
  result = *a1 == 0;
  *a1 = result;
  return result;
}

//----- (0807D702) --------------------------------------------------------
void __cdecl sub_807D702(int *a1, int *a2)
{
  int v2; // [esp+14h] [ebp-4h]

  sub_807D15A(a1, a2);
  v2 = a1[1];
  if ( v2 == 5 )
  {
    a1[1] = 6;
    *a1 = *(float *)a2 > (long double)*(float *)a1;
  }
  else if ( v2 == 6 )
  {
    *a1 = *a1 < *a2;
  }
  else
  {
    sub_807D08C(a1, a2);
  }
}

//----- (0807D784) --------------------------------------------------------
_BOOL4 __cdecl sub_807D784(int *a1, int *a2)
{
  _BOOL4 result; // eax

  sub_807D702(a1, a2);
  result = *a1 == 0;
  *a1 = result;
  return result;
}

//----- (0807D7B0) --------------------------------------------------------
void __cdecl sub_807D7B0(int *a1, int *a2)
{
  int v2; // [esp+14h] [ebp-4h]

  sub_807D15A(a1, a2);
  v2 = a1[1];
  if ( v2 == 5 )
  {
    a1[1] = 6;
    *a1 = *(float *)a1 > (long double)*(float *)a2;
  }
  else if ( v2 == 6 )
  {
    *a1 = *a1 > *a2;
  }
  else
  {
    sub_807D08C(a1, a2);
  }
}

//----- (0807D832) --------------------------------------------------------
_BOOL4 __cdecl sub_807D832(int *a1, int *a2)
{
  _BOOL4 result; // eax

  sub_807D7B0(a1, a2);
  result = *a1 == 0;
  *a1 = result;
  return result;
}

//----- (0807D85E) --------------------------------------------------------
void __cdecl sub_807D85E(int *a1, int *a2)
{
  if ( a1[1] != 6 || a2[1] != 6 )
    sub_807D08C(a1, a2);
  else
    *a1 <<= *(_BYTE *)a2;
}

//----- (0807D8A4) --------------------------------------------------------
void __cdecl sub_807D8A4(int *a1, int *a2)
{
  if ( a1[1] != 6 || a2[1] != 6 )
    sub_807D08C(a1, a2);
  else
    *a1 >>= *(_BYTE *)a2;
}

//----- (0807D8EA) --------------------------------------------------------
void __cdecl sub_807D8EA(int *a1, int *a2)
{
  char *v2; // eax
  signed int v3; // [esp+1Ch] [ebp-202Ch]
  char *v4; // [esp+20h] [ebp-2028h]
  char *src; // [esp+24h] [ebp-2024h]
  int v6; // [esp+28h] [ebp-2020h]
  int n; // [esp+2Ch] [ebp-201Ch]
  char dest[8200]; // [esp+30h] [ebp-2018h]
  float *v9; // [esp+2038h] [ebp-10h]
  int v10; // [esp+203Ch] [ebp-Ch]

  sub_807D1D4(a1, (int)a2);
  v3 = a1[1];
  if ( v3 == 4 )
  {
    v9 = (float *)sub_807B936();
    *v9 = *(float *)*a1 + *(float *)*a2;
    v9[1] = *(float *)(*a1 + 4) + *(float *)(*a2 + 4);
    v9[2] = *(float *)(*a1 + 8) + *(float *)(*a2 + 8);
    sub_807B9CA(*a1);
    sub_807B9CA(*a2);
    *a1 = (int)v9;
    return;
  }
  if ( v3 > 4 )
  {
    if ( v3 == 5 )
    {
      *(float *)a1 = *(float *)a1 + *(float *)a2;
      return;
    }
    if ( v3 == 6 )
    {
      *a1 += *a2;
      return;
    }
    goto LABEL_13;
  }
  if ( v3 != 2 )
  {
LABEL_13:
    sub_807D08C(a1, a2);
    return;
  }
  src = (char *)sub_8078896(*a1);
  v4 = (char *)sub_8078896(*a2);
  v6 = sub_80788FC(*a1);
  n = v6 + sub_80788FC(*a2) + 1;
  if ( v6 <= 0x2000 )
  {
    strcpy(dest, src);
    strcpy(&dest[v6], v4);
    v10 = sub_8078DEC(dest, 0, n);
    sub_80796A2(*a1);
    sub_80796A2(*a2);
    *a1 = v10;
  }
  else
  {
    sub_80796A2(*a1);
    sub_80796A2(*a2);
    a1[1] = 0;
    a2[1] = 0;
    v2 = va("cannot concat \"%s\" and \"%s\" - max string length exceeded", src, v4);
    sub_8084DB4((int)v2);
  }
}
// 807D8EA: using guessed type char dest[8200];

//----- (0807DB42) --------------------------------------------------------
void __cdecl sub_807DB42(int *a1, int *a2)
{
  float *v2; // ST10_4
  signed int v3; // [esp+Ch] [ebp-Ch]

  sub_807D15A(a1, a2);
  v3 = a1[1];
  if ( v3 == 5 )
  {
    *(float *)a1 = *(float *)a1 - *(float *)a2;
    return;
  }
  if ( v3 > 5 )
  {
    if ( v3 == 6 )
    {
      *a1 -= *a2;
      return;
    }
  }
  else if ( v3 == 4 )
  {
    v2 = (float *)sub_807B936();
    *v2 = *(float *)*a1 - *(float *)*a2;
    v2[1] = *(float *)(*a1 + 4) - *(float *)(*a2 + 4);
    v2[2] = *(float *)(*a1 + 8) - *(float *)(*a2 + 8);
    sub_807B9CA(*a1);
    sub_807B9CA(*a2);
    *a1 = (int)v2;
    return;
  }
  sub_807D08C(a1, a2);
}

//----- (0807DC40) --------------------------------------------------------
void __cdecl sub_807DC40(int *a1, int *a2)
{
  int v2; // [esp+14h] [ebp-4h]

  sub_807D15A(a1, a2);
  v2 = a1[1];
  if ( v2 == 5 )
  {
    *(float *)a1 = *(float *)a1 * *(float *)a2;
  }
  else if ( v2 == 6 )
  {
    *a1 *= *a2;
  }
  else
  {
    sub_807D08C(a1, a2);
  }
}

//----- (0807DCA6) --------------------------------------------------------
void __cdecl sub_807DCA6(int *a1, int *a2)
{
  int v2; // [esp+14h] [ebp-4h]

  sub_807D15A(a1, a2);
  v2 = a1[1];
  if ( v2 == 5 )
  {
    if ( *(float *)a2 == 0.0 )
    {
      *a1 = 0;
      sub_8084DB4((int)"divide by 0");
    }
    else
    {
      *(float *)a1 = *(float *)a1 / *(float *)a2;
    }
  }
  else if ( v2 == 6 )
  {
    a1[1] = 5;
    if ( *a2 )
    {
      *(float *)a1 = (long double)*a1 / (long double)*a2;
    }
    else
    {
      *a1 = 0;
      sub_8084DB4((int)"divide by 0");
    }
  }
  else
  {
    sub_807D08C(a1, a2);
  }
}

//----- (0807DD64) --------------------------------------------------------
void __cdecl sub_807DD64(int *a1, int *a2)
{
  if ( a1[1] != 6 || a2[1] != 6 )
  {
    sub_807D08C(a1, a2);
  }
  else if ( *a2 )
  {
    *a1 %= *a2;
  }
  else
  {
    *a1 = 0;
    sub_8084DB4((int)"divide by 0");
  }
}

//----- (0807DDD2) --------------------------------------------------------
void __cdecl sub_807DDD2(int a1, int *a2, int *a3)
{
  switch ( a1 )
  {
    case 102:
      sub_807D3B6(a2, a3);
      break;
    case 103:
      sub_807D3F4(a2, a3);
      break;
    case 104:
      sub_807D432(a2, a3);
      break;
    case 105:
      sub_807D470(a2, a3);
      break;
    case 106:
      sub_807D6D6(a2, a3);
      break;
    case 107:
      sub_807D702(a2, a3);
      break;
    case 108:
      sub_807D7B0(a2, a3);
      break;
    case 109:
      sub_807D832(a2, a3);
      break;
    case 110:
      sub_807D784(a2, a3);
      break;
    case 111:
      sub_807D85E(a2, a3);
      break;
    case 112:
      sub_807D8A4(a2, a3);
      break;
    case 113:
      sub_807D8EA(a2, a3);
      break;
    case 114:
      sub_807DB42(a2, a3);
      break;
    case 115:
      sub_807DC40(a2, a3);
      break;
    case 116:
      sub_807DCA6(a2, a3);
      break;
    case 117:
      sub_807DD64(a2, a3);
      break;
    default:
      return;
  }
}

//----- (0807DF52) --------------------------------------------------------
_BOOL4 __cdecl sub_807DF52(int a1)
{
  return (dword_8294008[4 * a1] & 0x60) == 0;
}
// 8294008: using guessed type int dword_8294008[];

//----- (0807DF7C) --------------------------------------------------------
int __cdecl sub_807DF7C(int a1)
{
  return dword_8294008[4 * a1] & 0x1F;
}
// 8294008: using guessed type int dword_8294008[];

//----- (0807DF90) --------------------------------------------------------
void __cdecl sub_807DF90(int a1, int a2)
{
  int v2; // ST0C_4
  __int16 *v3; // ST08_4
  int v4; // [esp+10h] [ebp-8h]
  int v5; // [esp+14h] [ebp-4h]

  if ( byte_8394038 )
  {
    v5 = (unsigned __int16)word_815AB82[6 * a2];
    v4 = sub_807BB10(v5, a1);
    if ( v4 )
    {
      v2 = sub_807CB1E(v4);
      v3 = &word_8294000[8 * v2];
      *((_DWORD *)v3 + 2) &= 0xFFFFFFE0;
      *((_DWORD *)v3 + 2) |= 0x14u;
      sub_807B7BA(v2);
      v3[3] = dword_8394030;
      dword_8394030 = v2;
      sub_807C26C(v5, a1);
    }
  }
}
// 815AB82: using guessed type __int16 word_815AB82[];
// 8294000: using guessed type __int16 word_8294000[];
// 8394030: using guessed type int dword_8394030;
// 8394038: using guessed type char byte_8394038;

//----- (0807E04A) --------------------------------------------------------
int sub_807E04A()
{
  __int16 *v0; // ST14_4
  int result; // eax
  int v2; // [esp+10h] [ebp-8h]

  while ( dword_8394030 )
  {
    v2 = dword_8394030;
    v0 = &word_8294000[8 * dword_8394030];
    dword_8394030 = (unsigned __int16)v0[3];
    v0[3] = 0;
    sub_80834DC(v2);
    if ( (unsigned __int16)word_8294000[8 * (unsigned __int16)v0[7]] != v2 )
      sub_807AEBA(v2);
    result = sub_807B7DC(v2);
  }
  return result;
}
// 8294000: using guessed type __int16 word_8294000[];
// 8394030: using guessed type int dword_8394030;

//----- (0807E0C6) --------------------------------------------------------
unsigned int *sub_807E0C6()
{
  unsigned int *result; // eax
  __int16 *v1; // [esp+10h] [ebp-8h]
  unsigned int i; // [esp+14h] [ebp-4h]

  for ( i = 1; i <= 0xFFFD; ++i )
  {
    v1 = &word_8294000[8 * i];
    if ( *((_DWORD *)v1 + 2) & 0x60 && ((*((_DWORD *)v1 + 2) & 0x1F) == 19 || (*((_DWORD *)v1 + 2) & 0x1F) == 20) )
    {
      sub_80834DC(i);
      sub_807AF82(i);
    }
    result = &i;
  }
  return result;
}
// 8294000: using guessed type __int16 word_8294000[];

//----- (0807E13C) --------------------------------------------------------
int __cdecl sub_807E13C(int a1)
{
  int result; // eax

  word_815AB82[6 * a1] = sub_807B658();
  result = sub_807B658();
  word_815AB80[6 * a1] = result;
  return result;
}
// 815AB80: using guessed type __int16 word_815AB80[];
// 815AB82: using guessed type __int16 word_815AB82[];

//----- (0807E182) --------------------------------------------------------
int __cdecl sub_807E182(int a1)
{
  int result; // eax

  if ( byte_8394038 )
  {
    sub_807B7DC((unsigned __int16)word_815AB82[6 * a1]);
    word_815AB82[6 * a1] = 0;
    sub_807B7DC((unsigned __int16)word_815AB80[6 * a1]);
    result = 12 * a1;
    word_815AB80[6 * a1] = 0;
  }
  return result;
}
// 815AB80: using guessed type __int16 word_815AB80[];
// 815AB82: using guessed type __int16 word_815AB82[];
// 8394038: using guessed type char byte_8394038;

//----- (0807E1F6) --------------------------------------------------------
int __cdecl sub_807E1F6(int a1, void *s2, __int16 a3)
{
  int v3; // ST18_4
  int v4; // eax
  int v5; // eax
  __int16 *v6; // ST20_4
  int v7; // ST1C_4
  int v8; // ST24_4
  __int16 *v9; // ST20_4
  int result; // eax

  v3 = (unsigned __int16)word_815AB80[6 * a1];
  v4 = sub_8075A60(s2);
  v5 = sub_807C084(v3, v4);
  v6 = &word_8294000[8 * v5];
  *((_DWORD *)v6 + 2) &= 0xFFFFFFE0;
  *((_DWORD *)v6 + 2) |= 6u;
  *((_DWORD *)v6 + 1) = (unsigned __int16)a3;
  v7 = sub_8079290((char *)s2, 0);
  v8 = sub_807C0CC(v3, v7);
  sub_80796A2(v7);
  v9 = &word_8294000[8 * v8];
  *((_DWORD *)v9 + 2) &= 0xFFFFFFE0;
  *((_DWORD *)v9 + 2) |= 6u;
  result = (unsigned __int16)a3;
  *((_DWORD *)v9 + 1) = (unsigned __int16)a3;
  return result;
}
// 815AB80: using guessed type __int16 word_815AB80[];
// 8294000: using guessed type __int16 word_8294000[];

//----- (0807E2EA) --------------------------------------------------------
int __cdecl sub_807E2EA(int a1, int a2)
{
  int v2; // ST10_4
  int v3; // eax
  int v5; // [esp+Ch] [ebp-Ch]
  int v6; // [esp+14h] [ebp-4h]

  v2 = (unsigned __int16)word_815AB80[6 * a1];
  v3 = sub_8078946(a2);
  v6 = sub_807BB34(v2, v3);
  if ( v6 )
    v5 = dword_8294004[4 * v6];
  else
    v5 = -1;
  return v5;
}
// 815AB80: using guessed type __int16 word_815AB80[];
// 8294004: using guessed type int dword_8294004[];

//----- (0807E346) --------------------------------------------------------
int __cdecl sub_807E346(int a1, int a2)
{
  int v3; // [esp+8h] [ebp-10h]
  int v4; // [esp+10h] [ebp-8h]

  v4 = sub_807BB10((unsigned __int16)word_815AB82[6 * a2], a1);
  if ( v4 )
    v3 = *(_DWORD *)&word_8294000[8 * v4 + 2];
  else
    v3 = 0;
  return v3;
}
// 815AB82: using guessed type __int16 word_815AB82[];
// 8294000: using guessed type __int16 word_8294000[];

//----- (0807E3A6) --------------------------------------------------------
int __cdecl sub_807E3A6(int a1, int a2)
{
  int v2; // ST1C_4
  __int16 *v5; // [esp+18h] [ebp-10h]

  v5 = &word_8294000[8 * sub_807C060((unsigned __int16)word_815AB82[6 * a2], a1)];
  if ( *((_DWORD *)v5 + 2) & 0x1F )
    return *((_DWORD *)v5 + 1);
  v2 = sub_807B5EA(a2, a1);
  *((_DWORD *)v5 + 2) |= 1u;
  *((_DWORD *)v5 + 1) = v2;
  return v2;
}
// 815AB82: using guessed type __int16 word_815AB82[];
// 8294000: using guessed type __int16 word_8294000[];

//----- (0807E43A) --------------------------------------------------------
int __cdecl sub_807E43A(int a1, int *a2)
{
  char *v2; // eax
  int v3; // ST14_4
  char *v4; // eax
  int v6; // [esp+10h] [ebp-8h]

  if ( a2[1] == 6 )
  {
    if ( (unsigned __int8)sub_807BAB4(*a2) )
    {
      v6 = sub_807C060(a1, *a2);
    }
    else
    {
      v2 = va("array index %d out of range", *a2);
      sub_8084DB4((int)v2);
      v6 = 0;
    }
  }
  else if ( a2[1] == 2 )
  {
    v3 = sub_807C0A8(a1, *a2);
    sub_80796A2(*a2);
    v6 = v3;
  }
  else
  {
    v4 = va("%s is not an array index", *(_DWORD *)&off_815ABC0[4 * a2[1]]);
    sub_8084DB4((int)v4);
    v6 = 0;
  }
  return v6;
}

//----- (0807E502) --------------------------------------------------------
int __cdecl sub_807E502(int a1, int *a2)
{
  char *v2; // eax
  int v3; // ST14_4
  char *v4; // eax
  int v6; // [esp+10h] [ebp-8h]

  if ( a2[1] == 6 )
  {
    if ( (unsigned __int8)sub_807BAB4(*a2) )
    {
      v6 = sub_807BB10(a1, *a2);
    }
    else
    {
      v2 = va("array index %d out of range", *a2);
      sub_8084DB4((int)v2);
      sub_807B7BA(a1);
      v6 = 0;
    }
  }
  else if ( a2[1] == 2 )
  {
    v3 = sub_807BB34(a1, *a2);
    sub_80796A2(*a2);
    v6 = v3;
  }
  else
  {
    v4 = va("%s is not an array index", *(_DWORD *)&off_815ABC0[4 * a2[1]]);
    sub_8084DB4((int)v4);
    sub_807B7BA(a1);
    v6 = 0;
  }
  return v6;
}

//----- (0807E5E0) --------------------------------------------------------
void __cdecl sub_807E5E0(int *a1, int *a2)
{
  char *v2; // eax
  char *v3; // eax
  char *v4; // eax
  char *v5; // eax
  char *v6; // eax
  int v7; // eax
  int v8; // edx
  char *v9; // eax
  signed int v10; // [esp+14h] [ebp-24h]
  int v11; // [esp+18h] [ebp-20h]
  int v12; // [esp+1Ch] [ebp-1Ch]
  char s2; // [esp+26h] [ebp-12h]
  char v14; // [esp+27h] [ebp-11h]
  char *s; // [esp+28h] [ebp-10h]
  __int16 *v16; // [esp+2Ch] [ebp-Ch]

  v10 = a1[1];
  if ( v10 == 2 )
  {
    if ( a2[1] == 6 )
    {
      if ( *a2 < 0 || (s = (char *)sub_8078896(*a1), *a2 >= strlen(s)) )
      {
        v2 = va("string index %d out of range", *a2);
        sub_8084DB4((int)v2);
      }
      else
      {
        a2[1] = 2;
        s2 = s[*a2];
        v14 = 0;
        *a2 = sub_8078DEC(&s2, 0, 2u);
        sub_80796A2(*a1);
      }
    }
    else
    {
      v3 = va("%s is not a string index", *(_DWORD *)&off_815ABC0[4 * a2[1]]);
      sub_8084DB4((int)v3);
    }
  }
  else if ( v10 > 2 )
  {
    if ( v10 != 4 )
      goto LABEL_21;
    if ( a2[1] == 6 )
    {
      if ( (unsigned int)*a2 > 2 )
      {
        v4 = va("vector index %d out of range", *a2);
        sub_8084DB4((int)v4);
      }
      else
      {
        a2[1] = 5;
        *a2 = *(_DWORD *)(*a1 + 4 * *a2);
        sub_807B9CA(*a1);
      }
    }
    else
    {
      v5 = va("%s is not a vector index", *(_DWORD *)&off_815ABC0[4 * a2[1]]);
      sub_8084DB4((int)v5);
    }
  }
  else
  {
    if ( v10 != 1 )
    {
LABEL_21:
      dword_8394014 = 1;
      v9 = va("%s is not an array, string, or vector", *(_DWORD *)&off_815ABC0[4 * a1[1]]);
      sub_8084DB4((int)v9);
      return;
    }
    v16 = &word_8294000[8 * *a1];
    if ( (*((_DWORD *)v16 + 2) & 0x1F) == 22 )
    {
      v7 = sub_807E502(*a1, a2);
      sub_807C66A(&v11, v7);
      v8 = v12;
      *a2 = v11;
      a2[1] = v8;
      sub_807B7DC(*a1);
    }
    else
    {
      dword_8394014 = 1;
      v6 = va("%s is not an array", *(_DWORD *)&off_815ABC0[4 * (*((_DWORD *)v16 + 2) & 0x1F)]);
      sub_8084DB4((int)v6);
    }
  }
}
// 8294000: using guessed type __int16 word_8294000[];
// 8394014: using guessed type int dword_8394014;

//----- (0807E856) --------------------------------------------------------
int __cdecl sub_807E856(int a1)
{
  __int16 *v1; // ebx
  char *v2; // eax
  char *v3; // eax
  int v5; // [esp+14h] [ebp-34h]
  int v6; // [esp+18h] [ebp-30h]
  int v7; // [esp+1Ch] [ebp-2Ch]
  int v8; // [esp+24h] [ebp-24h]
  int v9; // [esp+28h] [ebp-20h]
  int v10; // [esp+2Ch] [ebp-1Ch]
  int v11; // [esp+30h] [ebp-18h]
  __int16 *v12; // [esp+34h] [ebp-14h]
  __int16 *v13; // [esp+38h] [ebp-10h]
  __int16 *v14; // [esp+3Ch] [ebp-Ch]

  if ( a1 != 65534 )
  {
    v14 = &word_8294000[8 * a1];
    v10 = *((_DWORD *)v14 + 2) & 0x1F;
    if ( v10 )
    {
      v9 = *((_DWORD *)v14 + 1);
      goto LABEL_12;
    }
LABEL_10:
    *((_DWORD *)v14 + 2) |= 1u;
    v1 = v14;
    *((_DWORD *)v1 + 1) = sub_807B658();
    return *((_DWORD *)v14 + 1);
  }
  v12 = &word_8294000[8 * dword_8394040];
  v8 = sub_807BB10((unsigned __int16)word_815AB80[6 * (*((_DWORD *)v12 + 2) >> 8)], dword_8394044);
  if ( !v8
    || (sub_8084ECA(&v6, (char *)(*((_DWORD *)v12 + 2) >> 8), (unsigned __int16)v12[3], dword_8294004[4 * v8]),
        v9 = v6,
        (v10 = v7) == 0) )
  {
    v14 = &word_8294000[8 * sub_807C0CC(dword_8394040, dword_8394044)];
    goto LABEL_10;
  }
  if ( v10 == 1 && !LOWORD(dword_8294004[4 * v9]) )
  {
    sub_80757AC(&v9);
    dword_8394014 = 1;
    sub_8084DB4((int)"read-only array cannot be changed");
    return 0;
  }
  sub_80757AC(&v9);
  v14 = 0;
LABEL_12:
  if ( v10 == 1 )
  {
    v13 = &word_8294000[8 * v9];
    if ( (*((_DWORD *)v13 + 2) & 0x1F) == 22 )
    {
      if ( v13[2] )
      {
        v11 = v9;
        sub_807B7DC(v9);
        v9 = sub_807B658();
        sub_807C2F6(v11, v9);
        *((_DWORD *)v14 + 1) = v9;
      }
      v5 = v9;
    }
    else
    {
      dword_8394014 = 1;
      v3 = va("%s is not an array", *(_DWORD *)&off_815ABC0[4 * (*((_DWORD *)v13 + 2) & 0x1F)]);
      sub_8084DB4((int)v3);
      v5 = 0;
    }
  }
  else
  {
    dword_8394014 = 1;
    if ( v10 == 2 )
    {
      sub_8084DB4((int)"string characters cannot be individually changed");
      v5 = 0;
    }
    else
    {
      if ( v10 == 4 )
      {
        sub_8084DB4((int)"vector components cannot be individually changed");
      }
      else
      {
        v2 = va("%s is not an array", *(_DWORD *)&off_815ABC0[4 * v10]);
        sub_8084DB4((int)v2);
      }
      v5 = 0;
    }
  }
  return v5;
}
// 815AB80: using guessed type __int16 word_815AB80[];
// 8294000: using guessed type __int16 word_8294000[];
// 8294004: using guessed type int dword_8294004[];
// 8394014: using guessed type int dword_8394014;
// 8394040: using guessed type int dword_8394040;
// 8394044: using guessed type int dword_8394044;

//----- (0807EB00) --------------------------------------------------------
void __cdecl sub_807EB00(int a1, int *a2)
{
  char *v2; // eax
  char *v3; // eax
  char *v4; // eax
  char *v5; // eax
  int v6; // [esp+10h] [ebp-28h]
  int v7; // [esp+14h] [ebp-24h]
  int v8; // [esp+1Ch] [ebp-1Ch]
  int v9; // [esp+20h] [ebp-18h]
  int v10; // [esp+24h] [ebp-14h]
  int v11; // [esp+28h] [ebp-10h]
  __int16 *v12; // [esp+2Ch] [ebp-Ch]
  __int16 *v13; // [esp+30h] [ebp-8h]
  __int16 *v14; // [esp+34h] [ebp-4h]

  if ( a1 == 65534 )
  {
    v12 = &word_8294000[8 * dword_8394040];
    v8 = sub_807BB10((unsigned __int16)word_815AB80[6 * (*((_DWORD *)v12 + 2) >> 8)], dword_8394044);
    if ( !v8
      || (sub_8084ECA(&v6, (char *)(*((_DWORD *)v12 + 2) >> 8), (unsigned __int16)v12[3], dword_8294004[4 * v8]),
          v9 = v6,
          (v10 = v7) == 0) )
    {
      v10 = 0;
LABEL_11:
      dword_8394014 = 1;
      v2 = va("%s is not an array", *(_DWORD *)&off_815ABC0[4 * v10]);
      sub_8084DB4((int)v2);
      return;
    }
    if ( v10 == 1 && !LOWORD(dword_8294004[4 * v9]) )
    {
      sub_80757AC(&v9);
      dword_8394014 = 1;
      sub_8084DB4((int)"read-only array cannot be changed");
      return;
    }
    sub_80757AC(&v9);
    v14 = 0;
  }
  else
  {
    v14 = &word_8294000[8 * a1];
    v10 = *((_DWORD *)v14 + 2) & 0x1F;
    v9 = *((_DWORD *)v14 + 1);
  }
  if ( v10 != 1 )
    goto LABEL_11;
  v13 = &word_8294000[8 * v9];
  if ( (*((_DWORD *)v13 + 2) & 0x1F) == 22 )
  {
    if ( v13[2] )
    {
      v11 = v9;
      sub_807B7DC(v9);
      v9 = sub_807B658();
      sub_807C2F6(v11, v9);
      *((_DWORD *)v14 + 1) = v9;
    }
    if ( a2[1] == 6 )
    {
      if ( (unsigned __int8)sub_807BAB4(*a2) )
      {
        sub_807C248(v9, *a2);
      }
      else
      {
        v4 = va("array index %d out of range", *a2);
        sub_8084DB4((int)v4);
      }
    }
    else if ( a2[1] == 2 )
    {
      sub_80796A2(*a2);
      sub_807C290(v9, *a2);
    }
    else
    {
      v5 = va("%s is not an array index", *(_DWORD *)&off_815ABC0[4 * a2[1]]);
      sub_8084DB4((int)v5);
    }
  }
  else
  {
    dword_8394014 = 1;
    v3 = va("%s is not an array", *(_DWORD *)&off_815ABC0[4 * (*((_DWORD *)v13 + 2) & 0x1F)]);
    sub_8084DB4((int)v3);
  }
}
// 815AB80: using guessed type __int16 word_815AB80[];
// 8294000: using guessed type __int16 word_8294000[];
// 8294004: using guessed type int dword_8294004[];
// 8394014: using guessed type int dword_8394014;
// 8394040: using guessed type int dword_8394040;
// 8394044: using guessed type int dword_8394044;

//----- (0807ED9A) --------------------------------------------------------
int __cdecl sub_807ED9A(int a1)
{
  int v2; // [esp+10h] [ebp-8h]
  int v3; // [esp+14h] [ebp-4h]

  v3 = 1;
  v2 = sub_807B658();
  return sub_807C45C(a1, &v2);
}

//----- (0807EDC4) --------------------------------------------------------
_WORD *__userpurge sub_807EDC4@<eax>(_WORD *a1, int a2)
{
  *a1 = word_8294000[8 * a2 + 3];
  a1[1] = *(_DWORD *)&word_8294000[8 * a2 + 4] >> 8;
  return a1;
}
// 8294000: using guessed type __int16 word_8294000[];

//----- (0807EDFC) --------------------------------------------------------
int __cdecl sub_807EDFC(int a1, int a2)
{
  int result; // eax
  int v3; // eax
  int v4; // ST10_4
  int *v5; // edx
  __int16 *v6; // [esp+18h] [ebp-10h]
  unsigned int v7; // [esp+1Ch] [ebp-Ch]
  int i; // [esp+20h] [ebp-8h]

  result = sub_807C9CE(a1);
  for ( i = result; i; i = result )
  {
    v6 = &word_8294000[8 * i];
    v7 = *((_DWORD *)v6 + 2) >> 8;
    if ( v7 != 131070 )
    {
      v3 = sub_807C0A8(a2, v7);
      v4 = *((_DWORD *)v6 + 2) & 0x1F;
      *(_DWORD *)&word_8294000[8 * v3 + 4] |= v4;
      v5 = (int *)&word_8294000[8 * v3 + 2];
      *v5 = *((_DWORD *)v6 + 1);
      sub_807BA14(v4, *v5);
    }
    result = sub_807C9CE(i);
  }
  return result;
}
// 8294000: using guessed type __int16 word_8294000[];

//----- (0807EECE) --------------------------------------------------------
int __cdecl sub_807EECE(int a1, int a2, int a3)
{
  int result; // eax
  int v4; // eax
  int v5; // [esp+14h] [ebp-4h]

  result = sub_807E346(a1, a3);
  v5 = result;
  if ( result )
  {
    result = sub_807C9CE(result);
    if ( result )
    {
      v4 = sub_807E3A6(a2, a3);
      result = sub_807EDFC(v5, v4);
    }
  }
  return result;
}

//----- (0807EF24) --------------------------------------------------------
long double __cdecl sub_807EF24(int a1, int a2)
{
  float v3; // [esp+10h] [ebp-8h]

  if ( a1 != 1 || (*(_DWORD *)&word_8294000[8 * a2 + 4] & 0x1F) != 22 )
    v3 = 0.0;
  else
    v3 = sub_807F006(a2) / ((long double)(unsigned __int16)word_8294000[8 * a2 + 2] + 1.0);
  return v3;
}
// 8294000: using guessed type __int16 word_8294000[];

//----- (0807EF84) --------------------------------------------------------
long double __cdecl sub_807EF84(int a1)
{
  return sub_807EF24(*(_DWORD *)(a1 + 8) & 0x1F, *(_DWORD *)(a1 + 4)) + 1.0;
}

//----- (0807EFAE) --------------------------------------------------------
long double __cdecl sub_807EFAE(int a1)
{
  int v1; // eax
  float v3; // [esp+Ch] [ebp-Ch]
  int v4; // [esp+10h] [ebp-8h]

  v4 = sub_807BB58(dword_8394020, a1);
  if ( v4 )
  {
    v1 = sub_807CB1E(v4);
    v3 = sub_807F006(v1);
  }
  else
  {
    v3 = 0.0;
  }
  return v3;
}
// 8394020: using guessed type int dword_8394020;

//----- (0807F006) --------------------------------------------------------
long double __cdecl sub_807F006(int a1)
{
  float v2; // [esp+Ch] [ebp-Ch]
  int i; // [esp+10h] [ebp-8h]

  v2 = 1.0;
  for ( i = sub_807C9CE(a1); i; i = sub_807C9CE(i) )
    v2 = sub_807EF84(16 * i + 136921088) + v2;
  return v2;
}

//----- (0807F072) --------------------------------------------------------
long double __cdecl sub_807F072(int a1, float *a2)
{
  int *v2; // ST28_4
  int v4; // [esp+18h] [ebp-20h]
  float v5; // [esp+1Ch] [ebp-1Ch]
  int v6; // [esp+24h] [ebp-14h]
  _BYTE *v7; // [esp+28h] [ebp-10h]
  int v8; // [esp+2Ch] [ebp-Ch]

  v6 = *(unsigned __int16 *)(a1 + 4);
  v7 = (_BYTE *)(5 * v6 + a1 + 11);
  v5 = sub_807F006(*(unsigned __int16 *)(a1 + 8));
  *a2 = sub_807EFAE(*(unsigned __int16 *)(a1 + 8));
  v4 = *(unsigned __int16 *)(a1 + 8);
  while ( v6 )
  {
    v2 = (int *)(v7 - 4);
    v8 = *v2;
    v7 = (char *)v2 - 1;
    --v6;
    if ( *v7 == 7 )
    {
      v4 = sub_807B1DC(v4);
      v5 = sub_807F006(v4) + v5;
      *a2 = sub_807EFAE(v4) + *a2;
    }
    else
    {
      v5 = sub_807EF24((unsigned __int8)*v7, v8) + v5;
    }
  }
  return v5;
}

//----- (0807F168) --------------------------------------------------------
int __cdecl sub_807F168(char *s1, int a2)
{
  char *v2; // ST14_4
  int v3; // ST10_4
  size_t v6; // [esp+Ch] [ebp-Ch]
  char *s; // [esp+14h] [ebp-4h]

  for ( s = (char *)dword_8394000; *s; s += v6 + 3 )
  {
    v6 = strlen(s) + 1;
    if ( !strcasecmp(s1, s) )
    {
      v2 = &s[v6];
      v3 = *(unsigned __int16 *)v2;
      *(_DWORD *)a2 = v2[2];
      return v3;
    }
  }
  return 0;
}
// 8394000: using guessed type int dword_8394000;

//----- (0807F1EE) --------------------------------------------------------
int __cdecl sub_807F1EE(char *src)
{
  char *v1; // eax
  char *v2; // eax
  char *v3; // eax
  size_t v4; // eax
  char *v5; // ebx
  char v7[4]; // [esp+18h] [ebp-30h]
  int v8; // [esp+1Ch] [ebp-2Ch]
  int i; // [esp+20h] [ebp-28h]
  int v10; // [esp+24h] [ebp-24h]
  int v11; // [esp+28h] [ebp-20h]
  int v12; // [esp+2Ch] [ebp-1Ch]
  char *dest; // [esp+30h] [ebp-18h]
  char *s1; // [esp+34h] [ebp-14h]
  int v15; // [esp+38h] [ebp-10h]
  int v16; // [esp+3Ch] [ebp-Ch]
  int v17; // [esp+40h] [ebp-8h]

  v17 = FS_FOpenFileByMode(src, (int)v7, 0);
  if ( v17 < 0 )
  {
    v1 = va(&byte_81400D1, src);
    Com_Error(1, v1);
  }
  v16 = sub_80A9CF0(v17 + 1);
  FS_Read(v16, v17, *(int *)v7);
  *(_BYTE *)(v16 + v17) = 0;
  FS_FCloseFile(*(int *)v7);
  v15 = v16;
  sub_80B396A("Scr_AddFields");
  while ( 1 )
  {
    s1 = Com_Parse((char **)&v15);
    if ( !v15 )
      break;
    if ( !strcmp(s1, "float") )
    {
      v12 = 5;
    }
    else if ( !strcmp(s1, "int") )
    {
      v12 = 6;
    }
    else if ( !strcmp(s1, "string") )
    {
      v12 = 2;
    }
    else
    {
      if ( strcmp(s1, "vector") )
      {
        v2 = va(&byte_81400F1, s1, src);
        Com_Error(1, v2);
      }
      v12 = 4;
    }
    s1 = Com_Parse((char **)&v15);
    if ( !v15 )
    {
      v3 = va(&byte_814010C, src);
      Com_Error(1, v3);
    }
    v4 = strlen(s1);
    v17 = v4 + 1;
    for ( i = v4; i >= 0; --i )
    {
      v5 = &s1[i];
      *v5 = tolower(s1[i]);
    }
    v11 = sub_8075A60(s1);
    if ( sub_807F168(s1, (int)&v8) )
      Com_Error(1, &byte_8140128, s1, src);
    v10 = v17 + 3;
    dest = (char *)sub_8079C94(v17 + 3);
    strcpy(dest, s1);
    dest += v17;
    *(_WORD *)dest = v11;
    dest += 2;
    *dest++ = v12;
    *dest = 0;
  }
  sub_80B3A3C();
  return sub_80A9DB4();
}

//----- (0807F47A) --------------------------------------------------------
int __cdecl sub_807F47A(int a1, char *a2)
{
  signed int v3; // [esp+10h] [ebp-78h]
  char s; // [esp+30h] [ebp-58h]
  int i; // [esp+74h] [ebp-14h]
  void *ptr; // [esp+78h] [ebp-10h]
  int v7; // [esp+7Ch] [ebp-Ch]

  v3 = 10;
  ptr = sub_809F7B2(a1, a2, 0, (int)&v7);
  sub_8079C84();
  dword_8394000 = (int)sub_80A9DC4(0);
  *(_BYTE *)dword_8394000 = 0;
  for ( i = 0; i < v7; ++i )
  {
    sprintf(&s, "%s/%s", a1, *((_DWORD *)ptr + i), v3);
    sub_807F1EE(&s);
  }
  if ( ptr )
    FS_FreeFileList(ptr);
  *(_BYTE *)sub_8079C94(1) = 0;
  return sub_80A9ECE();
}
// 8394000: using guessed type int dword_8394000;

//----- (0807F554) --------------------------------------------------------
int __cdecl sub_807F554(int a1)
{
  return sub_807B7DC(a1);
}

//----- (0807F568) --------------------------------------------------------
signed int __cdecl sub_807F568(int a1)
{
  int v3; // [esp+1Ch] [ebp-Ch]
  int v4; // [esp+20h] [ebp-8h]

  if ( (*(_DWORD *)&word_8294000[8 * a1 + 4] & 0x1F) != 22 )
    return 0;
LABEL_3:
  v4 = sub_807C9CE(a1);
  while ( v4 )
  {
    v3 = *(_DWORD *)&word_8294000[8 * v4 + 4] >> 8;
    switch ( *(_DWORD *)&word_8294000[8 * v4 + 4] & 0x1F )
    {
      case 1:
        if ( sub_807F568(*(_DWORD *)&word_8294000[8 * v4 + 2]) )
          goto LABEL_9;
        sub_807C16E(a1, v3);
        goto LABEL_3;
      case 7:
      case 8:
      case 9:
      case 0xA:
      case 0xB:
        sub_807C16E(a1, v3);
        goto LABEL_3;
      default:
LABEL_9:
        v4 = sub_807C9CE(v4);
        break;
    }
  }
  return 1;
}
// 8294000: using guessed type __int16 word_8294000[];

//----- (0807F64C) --------------------------------------------------------
void sub_807F64C()
{
  if ( !dword_8394028 )
  {
    dword_8394028 = sub_807B562();
    sub_807ED9A(dword_8394028);
  }
}
// 8394028: using guessed type int dword_8394028;

//----- (0807F676) --------------------------------------------------------
int __cdecl sub_807F676(int a1)
{
  int result; // eax

  if ( !a1 )
    return sub_807F568(*(_DWORD *)&word_8294000[8 * dword_8394028 + 2]);
  result = sub_807B778(dword_8394028);
  dword_8394028 = 0;
  return result;
}
// 8294000: using guessed type __int16 word_8294000[];
// 8394028: using guessed type int dword_8394028;

//----- (0807F6F2) --------------------------------------------------------
signed int __cdecl sub_807F6F2(char a1)
{
  signed int i; // [esp+4h] [ebp-8h]

  for ( i = 0; i <= 3; ++i )
  {
    if ( byte_815AB84[12 * i] == a1 )
      return i;
  }
  return -1;
}

//----- (0807F740) --------------------------------------------------------
int sub_807F740()
{
  return sub_807B658();
}

//----- (0807F74E) --------------------------------------------------------
int __cdecl sub_807F74E(int a1, char *s)
{
  int v2; // ST14_4
  signed int v4; // [esp+10h] [ebp-18h]
  int v5; // [esp+18h] [ebp-10h]
  int v6; // [esp+1Ch] [ebp-Ch]
  int v7; // [esp+24h] [ebp-4h]

  v7 = sub_80793D2(s, 0);
  if ( sub_807BB34(a1, v7) )
  {
    sub_80796A2(v7);
    v4 = 0;
  }
  else
  {
    v2 = sub_807C0A8(a1, v7);
    sub_80796A2(v7);
    v6 = 6;
    v5 = 0;
    sub_807C45C(v2, &v5);
    v4 = 1;
  }
  return v4;
}

//----- (0807F7E0) --------------------------------------------------------
int __cdecl sub_807F7E0(int a1)
{
  return sub_807B7DC(a1);
}

//----- (0807F7F4) --------------------------------------------------------
long double __cdecl sub_807F7F4(float a1)
{
  return (float)fabs(a1);
}

//----- (0807F810) --------------------------------------------------------
void sub_807F810()
{
  *(_DWORD *)dword_8394010 = 0;
  dword_83D5590 = 0;
  dword_8394014 = 0;
}
// 8394014: using guessed type int dword_8394014;
// 83D5590: using guessed type int dword_83D5590;

//----- (0807F834) --------------------------------------------------------
int sub_807F834()
{
  int result; // eax

  dword_83D7604 = (int)&unk_83DB918;
  dword_83D7610 = (int)&unk_83D7920;
  dword_83D7608 = 0;
  dword_83D760C = (int)dword_83D7620;
  dword_83D7600 = (int)&dword_83D5598;
  byte_839400C = 0;
  byte_83D7614 = 0;
  sub_807F810();
  byte_83D7616 = 0;
  dword_83D761C = 0;
  dword_83D7618 = 0;
  result = sub_807B562();
  dword_8394034 = result;
  dword_839401C = 0;
  dword_8394020 = 0;
  dword_8394024 = 0;
  dword_8394028 = 0;
  dword_839402C = 0;
  dword_8394030 = 0;
  dword_83D7924 = 7;
  dword_83D5594 = 0;
  return result;
}
// 839400C: using guessed type char byte_839400C;
// 839401C: using guessed type int dword_839401C;
// 8394020: using guessed type int dword_8394020;
// 8394024: using guessed type int dword_8394024;
// 8394028: using guessed type int dword_8394028;
// 839402C: using guessed type int dword_839402C;
// 8394030: using guessed type int dword_8394030;
// 8394034: using guessed type int dword_8394034;
// 83D5594: using guessed type int dword_83D5594;
// 83D5598: using guessed type int dword_83D5598;
// 83D7600: using guessed type int dword_83D7600;
// 83D7604: using guessed type int dword_83D7604;
// 83D7608: using guessed type int dword_83D7608;
// 83D760C: using guessed type int dword_83D760C;
// 83D7610: using guessed type int dword_83D7610;
// 83D7614: using guessed type char byte_83D7614;
// 83D7616: using guessed type char byte_83D7616;
// 83D7618: using guessed type int dword_83D7618;
// 83D761C: using guessed type int dword_83D761C;
// 83D7620: using guessed type int dword_83D7620[];
// 83D7924: using guessed type int dword_83D7924;

//----- (0807F8F6) --------------------------------------------------------
int sub_807F8F6()
{
  int result; // eax

  if ( dword_8394034 )
  {
    result = sub_807B778(dword_8394034);
    dword_8394034 = 0;
  }
  return result;
}
// 8394034: using guessed type int dword_8394034;

//----- (0807F91E) --------------------------------------------------------
int Scr_Init()
{
  int result; // eax

  if ( !byte_8394038 )
  {
    sub_8078AB2();
    sub_807A368();
    result = sub_807F834();
    byte_8202A64 = 0;
    byte_8202858 = 0;
    dword_8202A4C = 0;
    dword_8202A48 = 0;
    dword_8202440 = 0;
    dword_8202A54 = 0;
    dword_8202A50 = 0;
    byte_8394038 = 1;
  }
  return result;
}
// 8202440: using guessed type int dword_8202440;
// 8202858: using guessed type char byte_8202858;
// 8202A48: using guessed type int dword_8202A48;
// 8202A4C: using guessed type int dword_8202A4C;
// 8202A50: using guessed type int dword_8202A50;
// 8202A54: using guessed type int dword_8202A54;
// 8202A64: using guessed type char byte_8202A64;
// 8394038: using guessed type char byte_8394038;

//----- (0807F988) --------------------------------------------------------
bool __cdecl sub_807F988(int a1, int a2, int a3)
{
  bool result; // al

  byte_839400A = a1 != 0;
  byte_839400B = a2 != 0;
  result = a3 != 0;
  byte_83D7615 = a3 != 0;
  return result;
}
// 839400A: using guessed type char byte_839400A;
// 839400B: using guessed type char byte_839400B;
// 83D7615: using guessed type char byte_83D7615;

//----- (0807F9B2) --------------------------------------------------------
void Scr_Shutdown()
{
  if ( byte_8394038 )
  {
    byte_8394038 = 0;
    sub_807F8F6();
    sub_807A3B6();
    sub_8078AD0();
  }
}
// 8394038: using guessed type char byte_8394038;

//----- (0807F9DC) --------------------------------------------------------
void Scr_Abort()
{
  dword_839401C = 0;
  byte_8394038 = 0;
}
// 839401C: using guessed type int dword_839401C;
// 8394038: using guessed type char byte_8394038;

//----- (0807F9F2) --------------------------------------------------------
int __cdecl sub_807F9F2(int a1)
{
  int result; // eax

  result = a1;
  dword_83D5594 = a1;
  return result;
}
// 83D5594: using guessed type int dword_83D5594;

//----- (0807FA00) --------------------------------------------------------
void sub_807FA00()
{
  if ( !byte_839400C && !byte_8202A64 )
  {
    if ( byte_839400A && dword_83D5594 )
      byte_83D7616 = 1;
    if ( dword_83D7608 || byte_83D7614 )
      longjmp((struct __jmp_buf_tag *)(156 * dword_83D553C + 138232096), -1);
LABEL_11:
    Com_Error(1, &byte_8140180, *(_DWORD *)dword_8394010);
  }
  if ( byte_83D7616 )
    goto LABEL_11;
}
// 8202A64: using guessed type char byte_8202A64;
// 839400A: using guessed type char byte_839400A;
// 839400C: using guessed type char byte_839400C;
// 83D553C: using guessed type int dword_83D553C;
// 83D5594: using guessed type int dword_83D5594;
// 83D7608: using guessed type int dword_83D7608;
// 83D7614: using guessed type char byte_83D7614;
// 83D7616: using guessed type char byte_83D7616;

//----- (0807FA9C) --------------------------------------------------------
int sub_807FA9C()
{
  int result; // eax

  while ( dword_83D761C )
  {
    result = sub_80757AC((_DWORD *)dword_83D7610);
    dword_83D7610 -= 8;
    --dword_83D761C;
  }
  return result;
}
// 83D7610: using guessed type int dword_83D7610;
// 83D761C: using guessed type int dword_83D761C;

//----- (0807FACC) --------------------------------------------------------
int sub_807FACC()
{
  sub_807C5E2(dword_8394034);
  return sub_807CA86(dword_8394034);
}
// 8394034: using guessed type int dword_8394034;

//----- (0807FAEE) --------------------------------------------------------
int sub_807FAEE()
{
  sub_807C5E2(dword_8394034);
  return dword_8394034;
}
// 8394034: using guessed type int dword_8394034;

//----- (0807FB08) --------------------------------------------------------
int __cdecl sub_807FB08(unsigned __int8 *a1, int a2, int a3, _DWORD *a4, int a5)
{
  int v5; // edx
  _DWORD *v6; // ecx
  int v7; // edx
  _DWORD *v8; // ecx
  int v9; // edx
  _DWORD *v10; // ebx
  _DWORD *v11; // ebx
  int *v12; // ebx
  float *v13; // ebx
  _DWORD *v14; // ebx
  _DWORD *v15; // ebx
  int *v16; // ebx
  int *v17; // ebx
  _DWORD *v18; // ebx
  int v19; // edx
  int *v20; // ebx
  int *v21; // ebx
  unsigned __int16 v22; // ax
  _DWORD *v23; // ebx
  int v24; // edx
  _DWORD *v25; // esi
  int v26; // eax
  int v27; // edx
  _DWORD *v28; // esi
  int v29; // eax
  int v30; // edx
  _DWORD *v31; // esi
  int v32; // eax
  int v33; // edx
  _DWORD *v34; // esi
  int v35; // eax
  int v36; // edx
  _DWORD *v37; // esi
  int v38; // eax
  int v39; // edx
  _DWORD *v40; // esi
  int v41; // eax
  int v42; // edx
  _DWORD *v43; // esi
  int v44; // eax
  int v45; // edx
  int v46; // eax
  int *v47; // ebx
  _DWORD *v48; // ebx
  unsigned __int16 v49; // ax
  int v50; // eax
  int v51; // edx
  _DWORD *v52; // esi
  unsigned __int16 v53; // ax
  int v54; // edx
  unsigned __int16 v55; // ax
  unsigned __int16 v56; // ax
  unsigned __int16 v57; // ax
  int v58; // eax
  int v59; // eax
  int v60; // eax
  unsigned __int16 v61; // ax
  int v62; // eax
  unsigned __int16 v63; // ax
  int v64; // eax
  int v65; // eax
  char *v66; // eax
  char *v67; // eax
  float v68; // ST00_4
  char *v69; // eax
  int v70; // eax
  int v71; // eax
  char *v72; // eax
  char *v73; // eax
  int v74; // eax
  int v75; // eax
  char *v76; // eax
  int v77; // eax
  int v78; // eax
  char *v79; // eax
  int v80; // eax
  _DWORD *v81; // ebx
  int v82; // edx
  char *v83; // eax
  _DWORD *v84; // ebx
  int v85; // edx
  char *v86; // eax
  int v87; // eax
  int v88; // eax
  int v89; // eax
  int v90; // eax
  int v91; // eax
  int v92; // eax
  int v93; // eax
  int v94; // eax
  int v95; // eax
  int v96; // eax
  int v97; // eax
  int v98; // eax
  int v99; // eax
  int v100; // eax
  char *v101; // eax
  char *v102; // eax
  int *v103; // ebx
  _DWORD *v104; // ebx
  _DWORD *v105; // ebx
  unsigned __int16 v106; // ax
  int v107; // eax
  int v108; // edx
  unsigned __int16 v109; // ax
  char *v110; // eax
  int v112; // [esp+20h] [ebp-108h]
  int v114; // [esp+28h] [ebp-100h]
  int v115; // [esp+2Ch] [ebp-FCh]
  int v116; // [esp+30h] [ebp-F8h]
  int v117; // [esp+34h] [ebp-F4h]
  int v118; // [esp+38h] [ebp-F0h]
  int v119; // [esp+3Ch] [ebp-ECh]
  int v120; // [esp+44h] [ebp-E4h]
  int v121; // [esp+48h] [ebp-E0h]
  int v122; // [esp+4Ch] [ebp-DCh]
  int v123; // [esp+50h] [ebp-D8h]
  int v124; // [esp+54h] [ebp-D4h]
  int v125; // [esp+58h] [ebp-D0h]
  int v126; // [esp+5Ch] [ebp-CCh]
  int v127; // [esp+60h] [ebp-C8h]
  int v128; // [esp+64h] [ebp-C4h]
  int v129; // [esp+68h] [ebp-C0h]
  int v130; // [esp+6Ch] [ebp-BCh]
  int v131; // [esp+70h] [ebp-B8h]
  int v132; // [esp+74h] [ebp-B4h]
  int v133; // [esp+78h] [ebp-B0h]
  int v134; // [esp+7Ch] [ebp-ACh]
  int v135; // [esp+80h] [ebp-A8h]
  int v136; // [esp+84h] [ebp-A4h]
  int v137; // [esp+88h] [ebp-A0h]
  int v138; // [esp+8Ch] [ebp-9Ch]
  int v139; // [esp+90h] [ebp-98h]
  int v140; // [esp+94h] [ebp-94h]
  int v141; // [esp+98h] [ebp-90h]
  int v142; // [esp+9Ch] [ebp-8Ch]
  int v143; // [esp+A0h] [ebp-88h]
  int v144; // [esp+A4h] [ebp-84h]
  int v145; // [esp+A8h] [ebp-80h]
  int v146; // [esp+ACh] [ebp-7Ch]
  int v147; // [esp+B4h] [ebp-74h]
  unsigned __int8 *v148; // [esp+B8h] [ebp-70h]
  int v149; // [esp+BCh] [ebp-6Ch]
  int v150; // [esp+C0h] [ebp-68h]
  int v151; // [esp+C4h] [ebp-64h]
  int v152; // [esp+C8h] [ebp-60h]
  unsigned __int8 v153; // [esp+CFh] [ebp-59h]
  int v154; // [esp+D0h] [ebp-58h]
  int v155; // [esp+D4h] [ebp-54h]
  int v156; // [esp+D8h] [ebp-50h]
  int v157; // [esp+DCh] [ebp-4Ch]
  unsigned int v158; // [esp+E0h] [ebp-48h]
  int v159; // [esp+E4h] [ebp-44h]
  int v160; // [esp+E8h] [ebp-40h]
  int v161; // [esp+ECh] [ebp-3Ch]
  unsigned __int8 *v162; // [esp+F0h] [ebp-38h]
  unsigned int v163; // [esp+F4h] [ebp-34h]
  int v164; // [esp+F8h] [ebp-30h]
  int v165; // [esp+FCh] [ebp-2Ch]
  int v166; // [esp+100h] [ebp-28h]
  int v167; // [esp+104h] [ebp-24h]
  int i; // [esp+108h] [ebp-20h]
  int v169; // [esp+10Ch] [ebp-1Ch]
  int v170; // [esp+110h] [ebp-18h]
  int v171; // [esp+114h] [ebp-14h]

  v159 = 0;
  if ( __sigsetjmp((struct __jmp_buf_tag *)(156 * ++dword_83D553C + 138232096), 0) )
    goto LABEL_275;
  while ( 2 )
  {
    v160 = *a1++;
    switch ( v160 )
    {
      case 0:
        v158 = sub_807B1F0(a2);
        sub_807B25E(a2);
        dword_83D7600 -= 4 * a3;
        while ( a4[1] != 7 )
        {
          sub_80757AC(a4);
          a4 -= 2;
        }
        --dword_83D7608;
        dword_83D760C -= 24;
        if ( !v158 )
          goto LABEL_258;
        a4[1] = 0;
        goto LABEL_10;
      case 1:
        v158 = sub_807B1F0(a2);
        sub_807B25E(a2);
        dword_83D7600 -= 4 * a3;
        v5 = a4[1];
        v166 = *a4;
        v167 = v5;
        for ( a4 -= 2; a4[1] != 7; a4 -= 2 )
          sub_80757AC(a4);
        --dword_83D7608;
        dword_83D760C -= 24;
        if ( !v158 )
        {
          v6 = a4 + 2;
          v7 = v167;
          *v6 = v166;
          v6[1] = v7;
          goto LABEL_259;
        }
        v8 = a4;
        v9 = v167;
        *a4 = v166;
        v8[1] = v9;
LABEL_10:
        sub_807B7DC(a2);
        a1 = *(unsigned __int8 **)dword_83D760C;
        a3 = *(_DWORD *)(dword_83D760C + 8);
        a2 = v158;
        continue;
      case 2:
        a4 += 2;
        a4[1] = 0;
        continue;
      case 3:
        a4 += 2;
        a4[1] = 6;
        *a4 = 0;
        continue;
      case 4:
        a4 += 2;
        a4[1] = 6;
        *a4 = *a1++;
        continue;
      case 5:
        a4 += 2;
        a4[1] = 6;
        *a4 = -*a1++;
        continue;
      case 6:
        a4 += 2;
        a4[1] = 6;
        v10 = a4;
        *v10 = (unsigned __int16)sub_80851E6((__int16 **)&a1);
        continue;
      case 7:
        a4 += 2;
        a4[1] = 6;
        v11 = a4;
        *v11 = -(unsigned __int16)sub_80851E6((__int16 **)&a1);
        continue;
      case 8:
        a4 += 2;
        a4[1] = 6;
        v12 = a4;
        *v12 = sub_8085180((int **)&a1);
        continue;
      case 9:
        a4 += 2;
        a4[1] = 5;
        v13 = (float *)a4;
        *v13 = sub_8085210((float **)&a1);
        continue;
      case 10:
        a4 += 2;
        a4[1] = 2;
        v14 = a4;
        *v14 = (unsigned __int16)sub_80851E6((__int16 **)&a1);
        sub_807951E(*a4);
        continue;
      case 11:
        a4 += 2;
        a4[1] = 3;
        v15 = a4;
        *v15 = (unsigned __int16)sub_80851E6((__int16 **)&a1);
        sub_807951E(*a4);
        continue;
      case 12:
        a4 += 2;
        a4[1] = 4;
        v16 = a4;
        *v16 = sub_80851A2((int *)&a1);
        continue;
      case 13:
        v170 = dword_8394024;
        continue;
      case 14:
        v170 = dword_839402C;
        continue;
      case 15:
        a4 += 2;
        a4[1] = 1;
        v17 = a4;
        *v17 = sub_807B766(a2);
        sub_807B7BA(*a4);
        continue;
      case 16:
        a4 += 2;
        a4[1] = 1;
        *a4 = dword_8394024;
        sub_807B7BA(dword_8394024);
        continue;
      case 17:
        a4 += 2;
        v18 = a4;
        sub_807C66A(&v141, dword_8394028);
        v19 = v142;
        *v18 = v141;
        v18[1] = v19;
        continue;
      case 18:
        a4 += 2;
        a4[1] = 1;
        *a4 = dword_839402C;
        sub_807B7BA(dword_839402C);
        continue;
      case 19:
        a4 += 2;
        a4[1] = 11;
        v20 = a4;
        *v20 = sub_8085180((int **)&a1);
        continue;
      case 20:
        v171 = dword_8394028;
        continue;
      case 21:
        a4 += 2;
        a4[1] = 9;
        v21 = a4;
        *v21 = sub_8085238((int **)&a1);
        continue;
      case 22:
        dword_83D7600 += 4;
        ++a3;
        v22 = sub_80851E6((__int16 **)&a1);
        *(_DWORD *)dword_83D7600 = sub_807C0CC(a2, v22);
        continue;
      case 23:
        v153 = *a1++;
        dword_83D7600 -= 4 * v153;
        a3 -= v153;
        while ( v153 )
        {
          sub_807C1CC(a2);
          --v153;
        }
        continue;
      case 24:
        a4 += 2;
        v23 = a4;
        sub_807C66A(&v139, *(_DWORD *)dword_83D7600);
        v24 = v140;
        *v23 = v139;
        v23[1] = v24;
        continue;
      case 25:
        a4 += 2;
        v25 = a4;
        v26 = sub_8085154(1);
        sub_807C66A(&v137, v26);
        v27 = v138;
        *v25 = v137;
        v25[1] = v27;
        continue;
      case 26:
        a4 += 2;
        v28 = a4;
        v29 = sub_8085154(2);
        sub_807C66A(&v135, v29);
        v30 = v136;
        *v28 = v135;
        v28[1] = v30;
        continue;
      case 27:
        a4 += 2;
        v31 = a4;
        v32 = sub_8085154(3);
        sub_807C66A(&v133, v32);
        v33 = v134;
        *v31 = v133;
        v31[1] = v33;
        continue;
      case 28:
        a4 += 2;
        v34 = a4;
        v35 = sub_8085154(4);
        sub_807C66A(&v131, v35);
        v36 = v132;
        *v34 = v131;
        v34[1] = v36;
        continue;
      case 29:
        a4 += 2;
        v37 = a4;
        v38 = sub_8085154(5);
        sub_807C66A(&v129, v38);
        v39 = v130;
        *v37 = v129;
        v37[1] = v39;
        continue;
      case 30:
        a4 += 2;
        v40 = a4;
        v41 = sub_808516A(a1);
        sub_807C66A(&v127, v41);
        v42 = v128;
        *v40 = v127;
        v40[1] = v42;
        ++a1;
        continue;
      case 31:
        a4 += 2;
        v43 = a4;
        v44 = sub_808516A(a1);
        sub_807C66A(&v125, v44);
        v45 = v126;
        *v43 = v125;
        v43[1] = v45;
        ++a1;
        goto LABEL_49;
      case 32:
LABEL_49:
        sub_807E5E0(a4, a4 - 2);
        goto LABEL_3;
      case 33:
        v171 = *(_DWORD *)dword_83D7600;
        goto LABEL_52;
      case 34:
        v171 = sub_808516A(a1++);
        goto LABEL_52;
      case 35:
LABEL_52:
        v46 = sub_807E856(v171);
        v171 = sub_807E43A(v46, a4);
        goto LABEL_3;
      case 36:
        sub_807EB00(v171, a4);
        goto LABEL_3;
      case 37:
        a4 += 2;
        a4[1] = 1;
        v47 = a4;
        *v47 = sub_807B658();
        continue;
      case 38:
        v170 = sub_807B766(a2);
        if ( (unsigned __int8)sub_807CB3E(v170) )
          continue;
        goto LABEL_273;
      case 39:
        v170 = dword_8394024;
        goto LABEL_58;
      case 40:
        v170 = dword_839402C;
LABEL_58:
        a4 += 2;
        v48 = a4;
        v49 = sub_80851E6((__int16 **)&a1);
        v50 = sub_807BB34(v170, v49);
        sub_807C66A(&v123, v50);
        v51 = v124;
        *v48 = v123;
        v48[1] = v51;
        continue;
      case 41:
        v170 = sub_807B766(a2);
        if ( (unsigned __int8)sub_807CB3E(v170) )
          goto LABEL_62;
        a4 += 2;
        sub_80851E6((__int16 **)&a1);
LABEL_273:
        v156 = sub_807DF7C(v170);
        goto LABEL_274;
      case 42:
LABEL_62:
        a4 += 2;
        v52 = a4;
        v53 = sub_80851E6((__int16 **)&a1);
        sub_807BC7C(&v121, v170, v53);
        v54 = v122;
        *v52 = v121;
        v52[1] = v54;
        continue;
      case 43:
        v170 = dword_8394024;
        goto LABEL_66;
      case 44:
        v170 = dword_839402C;
        goto LABEL_66;
      case 45:
        v170 = sub_807B766(a2);
        goto LABEL_66;
      case 46:
LABEL_66:
        v55 = sub_80851E6((__int16 **)&a1);
        v171 = sub_807BBCA(v170, v55);
        continue;
      case 47:
        v56 = sub_80851E6((__int16 **)&a1);
        sub_807BF8E(v170, v56, (int)a4);
        continue;
      case 48:
        dword_83D7600 += 4;
        ++a3;
        v57 = sub_80851E6((__int16 **)&a1);
        *(_DWORD *)dword_83D7600 = sub_807C0CC(a2, v57);
        goto LABEL_69;
      case 49:
LABEL_69:
        if ( a4[1] == 8 )
          continue;
        sub_807C45C(*(_DWORD *)dword_83D7600, a4);
        goto LABEL_3;
      case 50:
        if ( a4[1] != 8 )
        {
          v58 = sub_808516A(a1);
          sub_807C45C(v58, a4);
          ++a1;
          goto LABEL_3;
        }
        ++a1;
        continue;
      case 51:
        if ( a4[1] != 7 )
        {
          v59 = sub_808516A(a1);
          sub_807C45C(v59, a4);
          ++a1;
          goto LABEL_3;
        }
        v60 = sub_808516A(a1);
        sub_807C5E2(v60);
        ++a1;
        continue;
      case 52:
        while ( a4[1] != 7 )
        {
          sub_80757AC(a4);
          a4 -= 2;
        }
        continue;
      case 53:
        if ( a4[1] == 8 )
        {
          a4[1] = 7;
        }
        else
        {
          sub_8084DB4((int)"function called with too many parameters");
LABEL_82:
          v171 = *(_DWORD *)dword_83D7600;
        }
        continue;
      case 54:
        goto LABEL_82;
      case 55:
        v171 = sub_808516A(a1++);
        continue;
      case 56:
        v61 = sub_80851E6((__int16 **)&a1);
        v62 = sub_807C0A8(dword_8394024, v61);
        sub_807C45C(v62, a4);
        goto LABEL_3;
      case 57:
        goto LABEL_86;
      case 58:
        v63 = sub_80851E6((__int16 **)&a1);
        v64 = sub_807C0A8(dword_839402C, v63);
        sub_807C45C(v64, a4);
        goto LABEL_3;
      case 59:
        v147 = (unsigned __int16)sub_80851E6((__int16 **)&a1);
        v170 = sub_807B766(a2);
        v171 = sub_807BBCA(v170, v147);
        goto LABEL_86;
      case 60:
        sub_807C45C(*(_DWORD *)dword_83D7600, a4);
        goto LABEL_3;
      case 61:
        v65 = sub_808516A(a1);
        sub_807C45C(v65, a4);
        ++a1;
        goto LABEL_3;
      case 62:
        goto LABEL_96;
      case 63:
        dword_83D761C = 1;
        goto LABEL_96;
      case 64:
        dword_83D761C = 2;
        goto LABEL_96;
      case 65:
        dword_83D761C = 3;
        goto LABEL_96;
      case 66:
        dword_83D761C = 4;
        goto LABEL_96;
      case 67:
        dword_83D761C = 5;
        goto LABEL_96;
      case 68:
        dword_83D761C = *a1++;
LABEL_96:
        dword_83D7610 = (int)a4;
        v143 = (unsigned __int16)sub_80851E6((__int16 **)&a1);
        *(_DWORD *)dword_83D760C = a1;
        ((void (*)(void))dword_8202A78[v143])();
        goto LABEL_97;
      case 69:
        goto LABEL_109;
      case 70:
        dword_83D761C = 1;
        goto LABEL_109;
      case 71:
        dword_83D761C = 2;
        goto LABEL_109;
      case 72:
        dword_83D761C = 3;
        goto LABEL_109;
      case 73:
        dword_83D761C = 4;
        goto LABEL_109;
      case 74:
        dword_83D761C = 5;
        goto LABEL_109;
      case 75:
        dword_83D761C = *a1++;
LABEL_109:
        dword_83D7610 = (int)(a4 - 2);
        v143 = (unsigned __int16)sub_80851E6((__int16 **)&a1);
        if ( a4[1] != 1 )
          goto LABEL_113;
        v170 = *a4;
        if ( sub_807DF7C(v170) == 21 )
        {
          sub_807EDC4(&v120, v170);
          v165 = v120;
          sub_807B7DC(v170);
          *(_DWORD *)dword_83D760C = a1;
          ((void (__cdecl *)(int))dword_8202A78[v143])(v165);
LABEL_97:
          a4 = (_DWORD *)dword_83D7610;
          a1 = *(unsigned __int8 **)dword_83D760C;
          if ( dword_83D761C )
          {
            i = dword_83D761C;
            dword_83D761C = 0;
            dword_83D7610 -= 8 * i;
            do
            {
              sub_80757AC(a4);
              a4 -= 2;
              --i;
            }
            while ( i );
          }
          if ( dword_83D7618 )
          {
            dword_83D7618 = 0;
          }
          else
          {
            a4 += 2;
            a4[1] = 0;
          }
          continue;
        }
        v156 = sub_807DF7C(v170);
        sub_807B7DC(v170);
        dword_8394014 = -1;
        v66 = va("%s is not an entity", *(_DWORD *)&off_815ABC0[4 * v156]);
        sub_8084DB4((int)v66);
LABEL_113:
        v156 = a4[1];
        sub_80757AC(a4);
        dword_8394014 = -1;
        v67 = va("%s is not an entity", *(_DWORD *)&off_815ABC0[4 * v156]);
        sub_8084DB4((int)v67);
LABEL_114:
        if ( a4[1] == 5 )
        {
          if ( *(float *)a4 < 0.0 )
            goto LABEL_128;
          v68 = *(float *)a4 * 20.0;
          v164 = sub_80850EE(v68);
          if ( !v164 && *(float *)a4 != 0.0 )
            v164 = 1;
        }
        else if ( a4[1] == 6 )
        {
          v164 = 20 * *a4;
        }
        else
        {
          dword_8394014 = 2;
          v69 = va("type %s is not a float", *(_DWORD *)&off_815ABC0[4 * a4[1]]);
          sub_8084DB4((int)v69);
        }
        if ( (unsigned int)v164 > 0xFFFFFE )
        {
          dword_8394014 = 2;
          if ( v164 >= 0 )
            sub_8084DB4((int)"wait is too long");
LABEL_128:
          sub_8084DB4((int)"negative wait is not allowed");
LABEL_129:
          v146 = 10;
          v145 = sub_808244A(((signed int)a4 - a5) >> 3, (int)a1, a4, a3, &a2);
          v71 = sub_807C0A8(dword_839401C, dword_8394018);
          v157 = sub_807CAD2(v71);
          v144 = sub_807C144(v157, a2);
          sub_807C4C2(v144, &v145);
          sub_807B128(a2, dword_8394018);
          goto LABEL_258;
        }
        if ( v164 )
          sub_8084FE0();
        v164 = (dword_8394018 + v164) & 0xFFFFFF;
        a4 -= 2;
        v146 = 10;
        v145 = sub_808244A(((signed int)a4 - a5) >> 3, (int)a1, a4, a3, &a2);
        v70 = sub_807C0A8(dword_839401C, v164);
        v157 = sub_807CAD2(v70);
        v144 = sub_807C11A(v157, a2);
        sub_807C4C2(v144, &v145);
        sub_807B128(a2, v164);
LABEL_258:
        *(_DWORD *)(a5 + 12) = 0;
LABEL_259:
        if ( v159 )
        {
          --v159;
          sub_807B7DC(a2);
          a1 = *(unsigned __int8 **)dword_83D760C;
          a2 = *(_DWORD *)(dword_83D760C + 4);
          a3 = *(_DWORD *)(dword_83D760C + 8);
          a4 = *(_DWORD **)(dword_83D760C + 12);
          a5 = *(_DWORD *)(dword_83D760C + 16);
          a4[1] = *(_DWORD *)(dword_83D760C + 20);
          a4 += 2;
          continue;
        }
        --dword_83D553C;
        return a2;
      case 76:
        goto LABEL_114;
      case 77:
        goto LABEL_129;
      case 78:
        a4 += 2;
        a4[1] = 8;
        continue;
      case 79:
        a4 += 2;
        a4[1] = 8;
        goto LABEL_132;
      case 80:
LABEL_132:
        if ( dword_83D7608 <= 30 )
        {
          v169 = sub_807B766(a2);
          sub_807B7BA(v169);
          a2 = sub_807B700(v169, a2);
          *(_DWORD *)dword_83D760C = a1;
          a1 = (unsigned __int8 *)sub_8085238((int **)dword_83D760C);
          goto LABEL_257;
        }
        sub_8084DB4((int)"script stack overflow (too many embedded function calls)");
LABEL_135:
        if ( a4[1] != 9 )
          goto LABEL_139;
        if ( dword_83D7608 <= 30 )
        {
          v169 = sub_807B766(a2);
          sub_807B7BA(v169);
          a2 = sub_807B700(v169, a2);
          *(_DWORD *)dword_83D760C = a1;
          a1 = (unsigned __int8 *)*a4;
          a4 -= 2;
          goto LABEL_257;
        }
        dword_8394014 = 1;
        sub_8084DB4((int)"script stack overflow (too many embedded function calls)");
LABEL_139:
        v72 = va("%s is not a function pointer", *(_DWORD *)&off_815ABC0[4 * a4[1]]);
        sub_8084DB4((int)v72);
LABEL_140:
        if ( a4[1] != 1 )
          goto LABEL_267;
        if ( dword_83D7608 <= 30 )
        {
          a2 = sub_807B700(*a4, a2);
          a4 -= 2;
          *(_DWORD *)dword_83D760C = a1;
          a1 = (unsigned __int8 *)sub_8085238((int **)dword_83D760C);
          goto LABEL_257;
        }
        sub_8084DB4((int)"script stack overflow (too many embedded function calls)");
LABEL_267:
        v156 = a4[1];
        goto LABEL_271;
      case 81:
        goto LABEL_135;
      case 82:
        goto LABEL_140;
      case 83:
        if ( a4[1] == 9 )
        {
          v162 = (unsigned __int8 *)*a4;
          a4 -= 2;
          if ( a4[1] != 1 )
            goto LABEL_269;
          if ( dword_83D7608 <= 30 )
          {
            a2 = sub_807B700(*a4, a2);
            a4 -= 2;
            *(_DWORD *)dword_83D760C = a1;
            a1 = v162;
            goto LABEL_257;
          }
          dword_8394014 = 1;
          sub_8084DB4((int)"script stack overflow (too many embedded function calls)");
        }
        else
        {
          sub_80757AC(a4);
          a4 -= 2;
          v73 = va("%s is not a function pointer", *(_DWORD *)&off_815ABC0[4 * a4[3]]);
          sub_8084DB4((int)v73);
LABEL_150:
          if ( dword_83D7608 <= 30 )
          {
            v169 = sub_807B766(a2);
            sub_807B7BA(v169);
            a2 = sub_807B6AC(v169);
            *(_DWORD *)dword_83D760C = a1;
            *(_DWORD *)(dword_83D760C + 16) = a5;
            a1 = (unsigned __int8 *)sub_8085238((int **)dword_83D760C);
            v74 = sub_8085180((int **)dword_83D760C);
            a5 = (int)&a4[-2 * v74];
            goto LABEL_256;
          }
          dword_8394014 = 1;
          sub_8084DB4((int)"script stack overflow (too many embedded function calls)");
LABEL_153:
          if ( a4[1] == 9 )
          {
            if ( dword_83D7608 <= 30 )
            {
              v162 = (unsigned __int8 *)*a4;
              a4 -= 2;
              v169 = sub_807B766(a2);
              sub_807B7BA(v169);
              a2 = sub_807B6AC(v169);
              *(_DWORD *)dword_83D760C = a1;
              *(_DWORD *)(dword_83D760C + 16) = a5;
              a1 = v162;
              v75 = sub_8085180((int **)dword_83D760C);
              a5 = (int)&a4[-2 * v75];
              goto LABEL_256;
            }
            dword_8394014 = 1;
            sub_8084DB4((int)"script stack overflow (too many embedded function calls)");
          }
          v76 = va("%s is not a function pointer", *(_DWORD *)&off_815ABC0[4 * a4[1]]);
          sub_8084DB4((int)v76);
LABEL_158:
          if ( a4[1] == 1 )
          {
            if ( dword_83D7608 <= 30 )
            {
              a2 = sub_807B6AC(*a4);
              a4 -= 2;
              *(_DWORD *)dword_83D760C = a1;
              *(_DWORD *)(dword_83D760C + 16) = a5;
              a1 = (unsigned __int8 *)sub_8085238((int **)dword_83D760C);
              v77 = sub_8085180((int **)dword_83D760C);
              a5 = (int)&a4[-2 * v77];
              goto LABEL_256;
            }
            dword_8394014 = 1;
            sub_8084DB4((int)"script stack overflow (too many embedded function calls)");
          }
        }
        goto LABEL_269;
      case 84:
        goto LABEL_150;
      case 85:
        goto LABEL_153;
      case 86:
        goto LABEL_158;
      case 87:
        if ( a4[1] != 9 )
        {
          sub_80757AC(a4);
          a4 -= 2;
          v79 = va("%s is not a function pointer", *(_DWORD *)&off_815ABC0[4 * a4[3]]);
          sub_8084DB4((int)v79);
LABEL_168:
          sub_80757AC(a4);
          goto LABEL_3;
        }
        v162 = (unsigned __int8 *)*a4;
        a4 -= 2;
        if ( a4[1] != 1 )
          goto LABEL_269;
        if ( dword_83D7608 > 30 )
        {
          dword_8394014 = 1;
          sub_8084DB4((int)"script stack overflow (too many embedded function calls)");
LABEL_269:
          v156 = a4[1];
          goto LABEL_272;
        }
        a2 = sub_807B6AC(*a4);
        a4 -= 2;
        *(_DWORD *)dword_83D760C = a1;
        *(_DWORD *)(dword_83D760C + 16) = a5;
        a1 = v162;
        v78 = sub_8085180((int **)dword_83D760C);
        a5 = (int)&a4[-2 * v78];
LABEL_256:
        *(_DWORD *)(dword_83D760C + 12) = a5;
        *(_DWORD *)(dword_83D760C + 20) = *(_DWORD *)(a5 + 4);
        *(_DWORD *)(a5 + 4) = 8;
        ++v159;
LABEL_257:
        *(_DWORD *)(dword_83D760C + 8) = a3;
        a3 = 0;
        ++dword_83D7608;
        dword_83D760C += 24;
        *(_DWORD *)(dword_83D760C + 4) = a2;
        continue;
      case 88:
        goto LABEL_168;
      case 89:
        v170 = sub_807CFFA(dword_8394034, a4);
        goto LABEL_3;
      case 90:
        v80 = sub_808516A(a1);
        v170 = sub_807C6AE(v80);
        ++a1;
        continue;
      case 91:
        sub_807CC38((float *)a4);
        continue;
      case 92:
        sub_807CBAA((int)a4);
        continue;
      case 93:
        sub_807CBD8(a4);
        continue;
      case 94:
        sub_807CC38((float *)a4);
        v152 = (unsigned __int16)sub_80851E6((__int16 **)&a1);
        if ( !*a4 )
          a1 += v152;
        goto LABEL_3;
      case 95:
        sub_807CC38((float *)a4);
        v152 = (unsigned __int16)sub_80851E6((__int16 **)&a1);
        if ( *a4 )
          a1 += v152;
        goto LABEL_3;
      case 96:
        sub_807CC38((float *)a4);
        v152 = (unsigned __int16)sub_80851E6((__int16 **)&a1);
        if ( *a4 )
          goto LABEL_3;
        a1 += v152;
        continue;
      case 97:
        sub_807CC38((float *)a4);
        v152 = (unsigned __int16)sub_80851E6((__int16 **)&a1);
        if ( !*a4 )
          goto LABEL_3;
        a1 += v152;
        continue;
      case 98:
        v152 = sub_8085180((int **)&a1);
        a1 += v152;
        continue;
      case 99:
        if ( (unsigned int)(Sys_MilliSeconds() - dword_83D5598) > 0x1387 )
        {
          if ( !dword_83D5594 )
          {
            if ( !byte_83D7615 )
            {
              Com_Printf("script runtime error: potential infinite loop in script - killing thread.\n");
              sub_8077DBA(0, (char *)a1, 0);
              sub_8084FE0();
              while ( 1 )
              {
                v158 = sub_807B1F0(a2);
                sub_807B25E(a2);
                dword_83D7600 -= 4 * a3;
                while ( a4[1] != 7 )
                {
                  sub_80757AC(a4);
                  a4 -= 2;
                }
                --dword_83D7608;
                dword_83D760C -= 24;
                if ( !v158 )
                  break;
                sub_807B7DC(a2);
                a1 = *(unsigned __int8 **)dword_83D760C;
                a3 = *(_DWORD *)(dword_83D760C + 8);
                a2 = v158;
                a4 -= 2;
              }
              goto LABEL_258;
            }
            sub_8084DF0((int)"potential infinite loop in script");
LABEL_190:
            a4 += 2;
            v81 = a4;
            sub_807C83C(&v118, v171);
            v82 = v119;
            *v81 = v118;
            v81[1] = v82;
            if ( a4[1] == 6 )
            {
              ++*a4;
              ++a1;
            }
            else
            {
              v83 = va("++ must be applied to an int (applied to %s)", *(_DWORD *)&off_815ABC0[4 * a4[1]]);
              sub_8084DB4((int)v83);
LABEL_193:
              a4 += 2;
              v84 = a4;
              sub_807C83C(&v116, v171);
              v85 = v117;
              *v84 = v116;
              v84[1] = v85;
              if ( a4[1] != 6 )
              {
                v86 = va("-- must be applied to an int (applied to %s)", *(_DWORD *)&off_815ABC0[4 * a4[1]]);
                sub_8084DB4((int)v86);
LABEL_196:
                sub_807D3B6(a4 - 2, a4);
                goto LABEL_3;
              }
              --*a4;
              ++a1;
            }
LABEL_86:
            sub_807C628(v171, a4);
LABEL_3:
            a4 -= 2;
            continue;
          }
          Com_Printf("script runtime warning: potential infinite loop in script.\n");
          sub_8077DBA(0, (char *)a1, 0);
          v152 = (unsigned __int16)sub_80851E6((__int16 **)&a1);
          a1 -= v152;
          sub_8084FE0();
        }
        else
        {
          v152 = (unsigned __int16)sub_80851E6((__int16 **)&a1);
          a1 -= v152;
        }
        continue;
      case 100:
        goto LABEL_190;
      case 101:
        goto LABEL_193;
      case 102:
        goto LABEL_196;
      case 103:
        sub_807D3F4(a4 - 2, a4);
        goto LABEL_3;
      case 104:
        sub_807D432(a4 - 2, a4);
        goto LABEL_3;
      case 105:
        sub_807D470(a4 - 2, a4);
        goto LABEL_3;
      case 106:
        sub_807D6D6(a4 - 2, a4);
        goto LABEL_3;
      case 107:
        sub_807D702(a4 - 2, a4);
        goto LABEL_3;
      case 108:
        sub_807D7B0(a4 - 2, a4);
        goto LABEL_3;
      case 109:
        sub_807D832(a4 - 2, a4);
        goto LABEL_3;
      case 110:
        sub_807D784(a4 - 2, a4);
        goto LABEL_3;
      case 111:
        sub_807D85E(a4 - 2, a4);
        goto LABEL_3;
      case 112:
        sub_807D8A4(a4 - 2, a4);
        goto LABEL_3;
      case 113:
        sub_807D8EA(a4 - 2, a4);
        goto LABEL_3;
      case 114:
        sub_807DB42(a4 - 2, a4);
        goto LABEL_3;
      case 115:
        sub_807DC40(a4 - 2, a4);
        goto LABEL_3;
      case 116:
        sub_807DCA6(a4 - 2, a4);
        goto LABEL_3;
      case 117:
        sub_807DD64(a4 - 2, a4);
        goto LABEL_3;
      case 118:
        sub_807C8B2(a4);
        continue;
      case 119:
      case 120:
        if ( a4[1] != 1 )
          goto LABEL_269;
        if ( !(unsigned __int8)sub_807CB3E(*a4) )
          goto LABEL_270;
        v166 = *a4;
        a4 -= 2;
        if ( a4[1] == 2 )
        {
          v163 = *a4;
          a4 -= 2;
          v146 = 10;
          v145 = sub_808244A(((signed int)a4 - a5) >> 3, (int)a1, a4, a3, &a2);
          v87 = sub_807C0A8(v166, 0x1FFFEu);
          v88 = sub_807CAD2(v87);
          v89 = sub_807C0A8(v88, v163);
          v157 = sub_807CAD2(v89);
          v144 = sub_807C11A(v157, a2);
          sub_807C4C2(v144, &v145);
          v167 = 1;
          v90 = sub_807B766(a2);
          v91 = sub_807C0F0(dword_8394020, v90);
          v92 = sub_807CAD2(v91);
          v93 = sub_807C11A(v92, a2);
          sub_807C4C2(v93, &v166);
          sub_807AFAC(a2, v163);
          goto LABEL_258;
        }
        a4 += 2;
        dword_8394014 = 3;
        sub_8084DB4((int)"first parameter of waittill must evaluate to a string");
LABEL_270:
        v156 = sub_807DF7C(*a4);
LABEL_272:
        dword_8394014 = 2;
LABEL_274:
        v110 = va("%s is not an object", *(_DWORD *)&off_815ABC0[4 * v156]);
        sub_8084DB4((int)v110);
LABEL_275:
        switch ( v160 )
        {
          case 33:
          case 34:
          case 35:
          case 36:
          case 132:
            if ( dword_8394014 < 0 )
              dword_8394014 = 1;
            break;
          case 41:
          case 42:
          case 47:
          case 57:
          case 59:
          case 100:
          case 101:
            dword_8394014 = 0;
            break;
          case 62:
          case 63:
          case 64:
          case 65:
          case 66:
          case 67:
          case 68:
            if ( dword_8394014 > 0 )
              dword_8394014 = dword_83D761C - dword_8394014 + 1;
            break;
          case 69:
          case 70:
          case 71:
          case 72:
          case 73:
          case 74:
          case 75:
            if ( dword_8394014 <= 0 )
            {
              if ( dword_8394014 < 0 )
                dword_8394014 = 1;
            }
            else
            {
              dword_8394014 = dword_83D761C - dword_8394014 + 2;
            }
            break;
          default:
            break;
        }
        sub_8078282((char *)a1, dword_8394014, *(int *)dword_8394010, (void *)dword_83D5590);
        sub_807F810();
        switch ( v160 )
        {
          case 31:
          case 32:
            sub_80757AC(a4);
            a4 -= 2;
            sub_80757AC(a4);
            a4[1] = 0;
            continue;
          case 33:
          case 34:
          case 35:
          case 132:
            v171 = sub_807FAEE();
            goto LABEL_301;
          case 36:
          case 76:
            goto LABEL_301;
          case 38:
            goto LABEL_290;
          case 41:
          case 42:
            a4[1] = 0;
            continue;
          case 45:
          case 46:
            v171 = sub_807FAEE();
            continue;
          case 47:
            if ( dword_83D761C )
              dword_83D761C = 0;
            continue;
          case 53:
            while ( a4[1] != 8 )
            {
              sub_80757AC(a4);
              a4 -= 2;
            }
            a4[1] = 7;
            continue;
          case 57:
            if ( dword_83D761C )
            {
              sub_80757AC(a4);
              dword_83D761C = 0;
            }
            goto LABEL_302;
          case 59:
            sub_80757AC(a4);
            dword_83D761C = 0;
            goto LABEL_302;
          case 62:
          case 63:
          case 64:
          case 65:
          case 66:
          case 67:
          case 68:
          case 69:
          case 70:
          case 71:
          case 72:
          case 73:
          case 74:
          case 75:
            sub_807FA9C();
            a4 = (_DWORD *)(dword_83D7610 + 8);
            *(_DWORD *)(dword_83D7610 + 12) = 0;
            continue;
          case 79:
          case 80:
          case 82:
            sub_8085238((int **)&a1);
            goto LABEL_308;
          case 81:
          case 83:
LABEL_308:
            while ( a4[1] != 8 )
            {
              sub_80757AC(a4);
              a4 -= 2;
            }
            a4[1] = 0;
            continue;
          case 84:
          case 86:
            sub_8085238((int **)&a1);
            goto LABEL_312;
          case 85:
          case 87:
LABEL_312:
            for ( i = sub_8085180((int **)&a1); i; --i )
            {
              sub_80757AC(a4);
              a4 -= 2;
            }
            a4 += 2;
            a4[1] = 0;
            continue;
          case 89:
            v170 = sub_807FACC();
            goto LABEL_302;
          case 90:
            ++a1;
LABEL_290:
            v170 = sub_807FACC();
            continue;
          case 94:
          case 95:
          case 96:
          case 97:
            sub_80851E6((__int16 **)&a1);
            goto LABEL_302;
          case 99:
            v152 = (unsigned __int16)sub_80851E6((__int16 **)&a1);
            a1 -= v152;
            continue;
          case 102:
          case 103:
          case 104:
          case 105:
          case 106:
          case 107:
          case 108:
          case 109:
          case 110:
          case 111:
          case 112:
          case 113:
          case 114:
          case 115:
          case 116:
          case 117:
            goto LABEL_302;
          case 119:
            ++a1;
            goto LABEL_300;
          case 120:
          case 122:
LABEL_300:
            sub_80757AC(a4);
            a4 -= 2;
            goto LABEL_301;
          case 121:
            while ( a4[1] != 8 )
            {
              sub_80757AC(a4);
              a4 -= 2;
            }
            goto LABEL_301;
          case 124:
            while ( v155 )
            {
              v149 = sub_80851FC((int **)&a1);
              v148 = (unsigned __int8 *)sub_8085238((int **)&a1);
              --v155;
            }
            if ( !v149 )
              a1 = v148;
LABEL_301:
            sub_80757AC(a4);
LABEL_302:
            a4 -= 2;
            break;
          default:
            continue;
        }
        continue;
      case 121:
        if ( a4[1] != 1 )
          goto LABEL_269;
        v157 = *a4;
        if ( !(unsigned __int8)sub_807CB3E(v157) )
          goto LABEL_270;
        a4 -= 2;
        if ( a4[1] != 2 )
        {
          a4 += 2;
          dword_8394014 = 1;
          sub_8084DB4((int)"first parameter of notify must evaluate to a string");
          goto LABEL_270;
        }
        v163 = *a4;
        a4 -= 2;
        *(_DWORD *)dword_83D760C = a1;
        sub_8082F56(v157, v163, a4);
        a1 = *(unsigned __int8 **)dword_83D760C;
        sub_807B7DC(v157);
        sub_80796A2(v163);
        while ( a4[1] != 8 )
        {
          sub_80757AC(a4);
          a4 -= 2;
        }
        goto LABEL_3;
      case 122:
        if ( a4[1] != 1 )
          goto LABEL_267;
        if ( !(unsigned __int8)sub_807CB3E(*a4) )
          goto LABEL_268;
        if ( *(a4 - 1) == 2 )
        {
          v163 = *(a4 - 2);
          sub_807B7BA(a2);
          v161 = sub_807B6AC(a2);
          v94 = sub_807C0A8(*a4, 0x1FFFEu);
          v95 = sub_807CAD2(v94);
          v96 = sub_807C0A8(v95, v163);
          v97 = sub_807CAD2(v96);
          sub_807C0F0(v97, v161);
          sub_807B7DC(v161);
          v167 = 1;
          v166 = *a4;
          v98 = sub_807C0F0(dword_8394020, a2);
          v99 = sub_807CAD2(v98);
          v100 = sub_807C11A(v99, v161);
          sub_807C4C2(v100, &v166);
          sub_807AFAC(v161, v163);
          a4 -= 4;
          continue;
        }
        sub_8084DB4((int)"first parameter of endon must evaluate to a string");
LABEL_268:
        v156 = sub_807DF7C(*a4);
LABEL_271:
        dword_8394014 = 1;
        goto LABEL_274;
      case 123:
        a4 += 2;
        a4[1] = 8;
        continue;
      case 124:
        v152 = sub_8085180((int **)&a1);
        a1 += v152;
        v155 = (unsigned __int16)sub_80851E6((__int16 **)&a1);
        v112 = a4[1];
        if ( v112 == 2 )
          goto LABEL_236;
        if ( v112 == 6 )
        {
          if ( (unsigned __int8)sub_807BAB4(*a4) )
          {
            v154 = sub_807BADA(*a4);
          }
          else
          {
            v101 = va("switch index %d out of range", *a4);
            sub_8084DB4((int)v101);
LABEL_236:
            v154 = *a4;
            sub_80796A2(*a4);
          }
        }
        else
        {
          v102 = va("cannot switch on %s", *(_DWORD *)&off_815ABC0[4 * a4[1]]);
          sub_8084DB4((int)v102);
        }
        if ( !v155 )
          goto LABEL_3;
        do
        {
          v149 = sub_80851FC((int **)&a1);
          v148 = (unsigned __int8 *)sub_8085238((int **)&a1);
          if ( v149 == v154 )
          {
            a1 = v148;
            goto LABEL_3;
          }
          --v155;
        }
        while ( v155 );
        if ( !v149 )
          a1 = v148;
        goto LABEL_3;
      case 125:
        v155 = (unsigned __int16)sub_80851E6((__int16 **)&a1);
        sub_80851C2((int *)&a1, 2 * v155);
        continue;
      case 126:
        a4 -= 4;
        sub_807CF1E(a4);
        continue;
      case 127:
        continue;
      case 128:
        --dword_83D553C;
        return 0;
      case 129:
        a4 += 2;
        v151 = sub_8085180((int **)&a1);
        v150 = sub_8085180((int **)&a1);
        v103 = a4;
        *v103 = sub_807E346(v150, v151);
        if ( !*a4 )
        {
          a4[1] = 0;
          sub_8084DB4((int)"unknown object");
        }
        goto LABEL_249;
      case 130:
        a4 += 2;
        v104 = a4;
        *v104 = (unsigned __int16)sub_80851E6((__int16 **)&a1);
LABEL_249:
        a4[1] = 1;
        sub_807B7BA(*a4);
        continue;
      case 131:
        a4 += 2;
        v105 = a4;
        v106 = sub_80851E6((__int16 **)&a1);
        v107 = sub_807BB34(a2, v106);
        sub_807C66A(&v114, v107);
        v108 = v115;
        *v105 = v114;
        v105[1] = v108;
        continue;
      case 132:
        v109 = sub_80851E6((__int16 **)&a1);
        v171 = sub_807BB34(a2, v109);
        if ( v171 )
          continue;
        sub_8084DB4((int)"cannot create a new local variable in the debugger");
        goto LABEL_254;
      case 133:
LABEL_254:
        ++a1;
        continue;
      case 134:
        ++a1;
        continue;
    }
  }
}
// 8394014: using guessed type int dword_8394014;
// 8394018: using guessed type int dword_8394018;
// 839401C: using guessed type int dword_839401C;
// 8394020: using guessed type int dword_8394020;
// 8394024: using guessed type int dword_8394024;
// 8394028: using guessed type int dword_8394028;
// 839402C: using guessed type int dword_839402C;
// 8394034: using guessed type int dword_8394034;
// 83D553C: using guessed type int dword_83D553C;
// 83D5590: using guessed type int dword_83D5590;
// 83D5594: using guessed type int dword_83D5594;
// 83D5598: using guessed type int dword_83D5598;
// 83D7600: using guessed type int dword_83D7600;
// 83D7608: using guessed type int dword_83D7608;
// 83D760C: using guessed type int dword_83D760C;
// 83D7610: using guessed type int dword_83D7610;
// 83D7615: using guessed type char byte_83D7615;
// 83D7618: using guessed type int dword_83D7618;
// 83D761C: using guessed type int dword_83D761C;

//----- (08081F8C) --------------------------------------------------------
void *__cdecl sub_8081F8C(_DWORD *a1)
{
  void *v3; // [esp+4h] [ebp-4h]

  if ( dword_83D7608 <= 1 )
    return 0;
  v3 = *(void **)(dword_83D760C - 24);
  if ( v3 == &unk_83D4100 )
    return 0;
  *a1 = *(_DWORD *)(dword_83D760C - 24 + 4);
  return v3;
}
// 83D7608: using guessed type int dword_83D7608;
// 83D760C: using guessed type int dword_83D760C;

//----- (08081FD6) --------------------------------------------------------
char *__cdecl sub_8081FD6(int *a1, char *a2, int a3, int a4, _DWORD *a5)
{
  int v5; // edx
  int v6; // edx
  int v7; // ST24_4
  unsigned __int16 v8; // ax
  int v9; // ST24_4
  int v10; // ST2C_4
  int v12; // [esp+10h] [ebp-28h]
  int v13; // [esp+18h] [ebp-20h]
  int v14; // [esp+1Ch] [ebp-1Ch]
  int v15; // [esp+20h] [ebp-18h]
  int v16; // [esp+24h] [ebp-14h]
  int v17; // [esp+24h] [ebp-14h]
  int v18; // [esp+28h] [ebp-10h]
  int v19; // [esp+2Ch] [ebp-Ch]
  int v20; // [esp+30h] [ebp-8h]
  int v21; // [esp+34h] [ebp-4h]

  *a5 = *(_DWORD *)(dword_83D760C + 4);
  while ( 2 )
  {
    ++a2;
    if ( a4 == 2 )
    {
      switch ( a3 )
      {
        case 79:
        case 80:
        case 84:
          goto LABEL_5;
        case 81:
        case 85:
          goto LABEL_8;
        case 82:
        case 86:
          if ( a1[1] != 1 )
            break;
LABEL_5:
          if ( dword_83D7608 > 31 )
            break;
          *a5 = 0;
          return (char *)sub_8085238((int **)&a2);
        case 83:
        case 87:
          if ( *(a1 - 1) != 1 )
            break;
LABEL_8:
          if ( a1[1] != 9 || dword_83D7608 > 31 )
            break;
          *a5 = 0;
          return (char *)*a1;
        default:
          break;
      }
    }
    switch ( a3 )
    {
      case 0:
      case 1:
        return (char *)sub_8081F8C(a5);
      case 2:
      case 3:
      case 13:
      case 14:
      case 15:
      case 16:
      case 17:
      case 18:
      case 20:
      case 24:
      case 25:
      case 26:
      case 27:
      case 28:
      case 29:
      case 32:
      case 33:
      case 35:
      case 36:
      case 37:
      case 38:
      case 49:
      case 52:
      case 53:
      case 54:
      case 57:
      case 60:
      case 76:
      case 77:
      case 78:
      case 81:
      case 83:
      case 88:
      case 89:
      case 91:
      case 92:
      case 93:
      case 100:
      case 101:
      case 102:
      case 103:
      case 104:
      case 105:
      case 106:
      case 107:
      case 108:
      case 109:
      case 110:
      case 111:
      case 112:
      case 113:
      case 114:
      case 115:
      case 116:
      case 117:
      case 118:
      case 120:
      case 121:
      case 122:
      case 123:
      case 126:
      case 127:
      case 128:
        goto LABEL_45;
      case 4:
      case 5:
      case 23:
      case 30:
      case 31:
      case 34:
      case 50:
      case 51:
      case 55:
      case 61:
      case 90:
      case 119:
      case 133:
      case 134:
        ++a2;
        goto LABEL_45;
      case 6:
      case 7:
      case 62:
      case 63:
      case 64:
      case 65:
      case 66:
      case 67:
      case 69:
      case 70:
      case 71:
      case 72:
      case 73:
      case 74:
        sub_80851E6((__int16 **)&a2);
        goto LABEL_45;
      case 8:
      case 9:
      case 19:
      case 21:
      case 79:
      case 80:
      case 82:
      case 85:
      case 87:
        sub_8085180((int **)&a2);
        goto LABEL_45;
      case 10:
      case 11:
      case 22:
      case 39:
      case 40:
      case 41:
      case 42:
      case 43:
      case 44:
      case 45:
      case 46:
      case 47:
      case 48:
      case 56:
      case 58:
      case 59:
      case 130:
      case 131:
      case 132:
        sub_80851E6((__int16 **)&a2);
        goto LABEL_45;
      case 12:
        sub_80851A2((int *)&a2);
        goto LABEL_45;
      case 68:
      case 75:
        ++a2;
        sub_80851E6((__int16 **)&a2);
        goto LABEL_45;
      case 84:
      case 86:
      case 129:
        sub_8085180((int **)&a2);
        sub_8085180((int **)&a2);
        goto LABEL_45;
      case 94:
      case 96:
        v5 = a1[1];
        v20 = *a1;
        v21 = v5;
        sub_807578C(&v20);
        sub_807CC38((float *)&v20);
        v16 = (unsigned __int16)sub_80851E6((__int16 **)&a2);
        if ( *(_DWORD *)dword_8394010 )
          goto LABEL_45;
        if ( v20 )
          v13 = (int)a2;
        else
          v13 = (int)&a2[v16];
        return (char *)v13;
      case 95:
      case 97:
        v6 = a1[1];
        v20 = *a1;
        v21 = v6;
        sub_807578C(&v20);
        sub_807CC38((float *)&v20);
        v17 = (unsigned __int16)sub_80851E6((__int16 **)&a2);
        if ( *(_DWORD *)dword_8394010 )
        {
LABEL_45:
          sub_807F810();
          a3 = *a2;
          if ( a3 != 57 )
            return a2;
          continue;
        }
        if ( v20 )
          v13 = (int)&a2[v17];
        else
          v13 = (int)a2;
        return (char *)v13;
      case 98:
        v7 = sub_8085180((int **)&a2);
        return &a2[v7];
      case 99:
        v8 = sub_80851E6((__int16 **)&a2);
        return &a2[-v8];
      case 124:
        v9 = sub_8085180((int **)&a2);
        a2 += v9;
        v19 = (unsigned __int16)sub_80851E6((__int16 **)&a2);
        v12 = a1[1];
        if ( v12 == 2 )
        {
          v18 = *a1;
        }
        else
        {
          if ( v12 != 6 )
          {
            a2 += 8 * v19;
            return a2;
          }
          if ( !(unsigned __int8)sub_807BAB4(*a1) )
          {
            a2 += 8 * v19;
            return a2;
          }
          v18 = sub_807BADA(*a1);
        }
        if ( !v19 )
          return a2;
        do
        {
          v15 = sub_80851FC((int **)&a2);
          v14 = sub_8085238((int **)&a2);
          if ( v15 == v18 )
          {
            a2 = (char *)v14;
            return (char *)v14;
          }
          --v19;
        }
        while ( v19 );
        if ( !v15 )
          a2 = (char *)v14;
        return a2;
      case 125:
        v10 = (unsigned __int16)sub_80851E6((__int16 **)&a2);
        sub_80851C2((int *)&a2, 2 * v10);
        return a2;
    }
  }
}
// 83D7608: using guessed type int dword_83D7608;
// 83D760C: using guessed type int dword_83D760C;

//----- (08082366) --------------------------------------------------------
int __cdecl sub_8082366(int a1, int a2, int a3, int a4, int a5)
{
  int result; // eax

  sub_807B084(a2);
  sub_807C228(a4, a2);
  result = sub_807C9AC(a4);
  if ( !result )
  {
    sub_807C16E(a3, a5);
    result = sub_807C9AC(a3);
    if ( !result )
      result = sub_807C16E(a1, 131070);
  }
  return result;
}

//----- (080823CE) --------------------------------------------------------
int __cdecl sub_80823CE(int a1, int a2)
{
  int v2; // eax
  int v3; // ST20_4
  unsigned __int16 v4; // ax
  int v5; // ST24_4
  int v6; // eax
  int v7; // ST1C_4

  v2 = sub_807BB34(a1, 131070);
  v3 = sub_807CB1E(v2);
  v4 = sub_807B110(a2);
  v5 = v4;
  v6 = sub_807BB34(v3, v4);
  v7 = sub_807CB1E(v6);
  return sub_8082366(a1, a2, v3, v7, v5);
}

//----- (0808244A) --------------------------------------------------------
int __cdecl sub_808244A(int a1, int a2, _DWORD *a3, int a4, int *a5)
{
  int v6; // [esp+8h] [ebp-10h]
  _BYTE *v7; // [esp+10h] [ebp-8h]
  _DWORD *v8; // [esp+10h] [ebp-8h]
  int v9; // [esp+14h] [ebp-4h]

  v9 = sub_8076A2A(5 * a1 + 11);
  v6 = *a5;
  *(_WORD *)(v9 + 8) = *a5;
  *(_WORD *)(v9 + 4) = a1;
  *(_WORD *)(v9 + 6) = 5 * a1 + 11;
  *(_DWORD *)v9 = a2;
  *(_BYTE *)(v9 + 10) = dword_8394018;
  dword_83D7600 -= 4 * a4;
  v7 = (_BYTE *)(5 * a1 + v9 + 11);
  while ( a1 )
  {
    v8 = v7 - 4;
    if ( a3[1] == 7 )
    {
      --dword_83D7608;
      dword_83D760C -= 24;
      *v8 = *(_DWORD *)dword_83D760C;
      dword_83D7600 -= 4 * *(_DWORD *)(dword_83D760C + 8);
      v6 = sub_807B1DC(v6);
    }
    else
    {
      *v8 = *a3;
    }
    v7 = (char *)v8 - 1;
    *v7 = *((_BYTE *)a3 + 4);
    a3 -= 2;
    --a1;
  }
  --dword_83D7608;
  dword_83D760C -= 24;
  sub_807B7BA(v6);
  *a5 = v6;
  return v9;
}
// 8394018: using guessed type int dword_8394018;
// 83D7600: using guessed type int dword_83D7600;
// 83D7608: using guessed type int dword_83D7608;
// 83D760C: using guessed type int dword_83D760C;

//----- (08082572) --------------------------------------------------------
int __cdecl sub_8082572(int a1)
{
  int v2; // [esp+10h] [ebp-8h]
  int i; // [esp+14h] [ebp-4h]

  v2 = 0;
  for ( i = sub_807CA16(a1); i; i = sub_807CA16(i) )
  {
    dword_83D7600 += 4;
    *(_DWORD *)dword_83D7600 = i;
    ++v2;
  }
  return v2;
}
// 83D7600: using guessed type int dword_83D7600;

//----- (080825C2) --------------------------------------------------------
int __cdecl sub_80825C2(int a1, _DWORD *a2, int a3)
{
  int v4; // [esp+10h] [ebp-18h]
  int v5; // [esp+14h] [ebp-14h]
  _DWORD *v6; // [esp+18h] [ebp-10h]
  int v7; // [esp+1Ch] [ebp-Ch]
  unsigned __int8 *v8; // [esp+20h] [ebp-8h]
  _DWORD *v9; // [esp+20h] [ebp-8h]

  *(_DWORD *)dword_83D760C = *(_DWORD *)a3;
  ++dword_83D7608;
  dword_83D760C += 24;
  v7 = *(unsigned __int16 *)(a3 + 4);
  v8 = (unsigned __int8 *)(a3 + 11);
  v6 = (_DWORD *)a2[4];
  while ( v7 )
  {
    v6 += 2;
    --v7;
    v6[1] = *v8;
    v9 = v8 + 1;
    if ( v6[1] == 7 )
    {
      *(_DWORD *)dword_83D760C = *v9;
      ++dword_83D7608;
      dword_83D760C += 24;
    }
    else
    {
      *v6 = *v9;
    }
    v8 = (unsigned __int8 *)(v9 + 1);
  }
  *a2 = *(_DWORD *)a3;
  a2[3] = v6;
  v5 = *(unsigned __int16 *)(a3 + 8);
  a2[1] = v5;
  sub_807B190(a1);
  v4 = dword_83D7608;
  while ( 1 )
  {
    dword_83D7624[6 * v4--] = v5;
    if ( !v4 )
      break;
    v5 = sub_807B1DC(v5);
  }
  while ( ++v4 != dword_83D7608 )
    dword_83D7628[6 * v4] = sub_8082572(dword_83D7624[6 * v4]);
  a2[2] = sub_8082572(a2[1]);
  if ( *(unsigned __int8 *)(a3 + 10) != (unsigned __int8)dword_8394018 )
    sub_8084FE0();
  return sub_8076A50(a3, *(unsigned __int16 *)(a3 + 6));
}
// 8394018: using guessed type int dword_8394018;
// 83D7608: using guessed type int dword_83D7608;
// 83D760C: using guessed type int dword_83D760C;
// 83D7624: using guessed type int dword_83D7624[];

//----- (08082754) --------------------------------------------------------
int __cdecl sub_8082754(int a1, int a2, int a3)
{
  int v3; // eax
  int v4; // eax
  int v6; // [esp+10h] [ebp-28h]
  int v7; // [esp+14h] [ebp-24h]
  int v8; // [esp+1Ch] [ebp-1Ch]
  unsigned __int8 v9; // [esp+23h] [ebp-15h]
  int v10; // [esp+24h] [ebp-14h]
  int *v11; // [esp+28h] [ebp-10h]
  int v12; // [esp+2Ch] [ebp-Ch]
  unsigned int v13; // [esp+30h] [ebp-8h]
  int v14; // [esp+34h] [ebp-4h]

  v10 = *(unsigned __int16 *)(a3 + 4);
  v14 = *(unsigned __int16 *)(a3 + 8);
  v11 = (int *)(5 * v10 + a3 + 11);
  while ( v10 )
  {
    --v11;
    v12 = *v11;
    v11 = (int *)((char *)v11 - 1);
    v9 = *(_BYTE *)v11;
    --v10;
    if ( v9 == 7 )
    {
      v13 = sub_807B1DC(v14);
      sub_807B25E(v14);
      sub_807B7DC(v14);
      if ( v14 == a1 )
      {
        ++v10;
        *(_BYTE *)v11 = 0;
        sub_807B128(a2, dword_8394018);
        *(_DWORD *)a3 = v12;
        *(_WORD *)(a3 + 8) = v13;
        *(_WORD *)(a3 + 4) = v10;
        v7 = 10;
        v6 = a3;
        v3 = sub_807C0A8(dword_839401C, dword_8394018);
        v4 = sub_807CAD2(v3);
        v8 = sub_807C11A(v4, a2);
        return sub_807C4C2(v8, &v6);
      }
      v14 = v13;
    }
    else
    {
      sub_807BA64(v9, v12);
    }
  }
  sub_807B25E(v14);
  sub_807B7DC(v14);
  return sub_8076A50(a3, *(unsigned __int16 *)(a3 + 6));
}
// 8394018: using guessed type int dword_8394018;
// 839401C: using guessed type int dword_839401C;

//----- (080828BE) --------------------------------------------------------
int __cdecl sub_80828BE(int a1, int a2, char a3)
{
  int result; // eax
  int v4; // eax
  int v5; // [esp+10h] [ebp-28h]
  int v6; // [esp+14h] [ebp-24h]
  unsigned __int8 v7; // [esp+1Fh] [ebp-19h]
  int v8; // [esp+20h] [ebp-18h]
  int *v9; // [esp+24h] [ebp-14h]
  int v10; // [esp+28h] [ebp-10h]
  unsigned int v11; // [esp+2Ch] [ebp-Ch]
  int v12; // [esp+30h] [ebp-8h]
  char v13; // [esp+37h] [ebp-1h]

  v13 = a3;
  v8 = *(unsigned __int16 *)(a2 + 4);
  v12 = *(unsigned __int16 *)(a2 + 8);
  v9 = (int *)(5 * v8 + a2 + 11);
  while ( v8 )
  {
    --v9;
    v10 = *v9;
    v9 = (int *)((char *)v9 - 1);
    v7 = *(_BYTE *)v9;
    --v8;
    if ( v7 == 7 )
    {
      if ( sub_807BB58(dword_8394020, v12) )
      {
        ++v8;
        *(_WORD *)(a2 + 8) = v12;
        *(_WORD *)(a2 + 4) = v8;
        result = sub_807B04E(v12);
        if ( !v13 )
        {
          sub_807AFAC(a1, 0);
          *(_DWORD *)a2 = 0;
          v6 = 10;
          v5 = a2;
          v4 = sub_807C0CC(a1, 0x1FFFFu);
          result = sub_807C4C2(v4, &v5);
        }
        return result;
      }
      v11 = sub_807B1DC(v12);
      sub_807B25E(v12);
      sub_807B7DC(v12);
      v12 = v11;
    }
    else
    {
      sub_807BA64(v7, v10);
    }
  }
  if ( v13 )
    sub_807C16E(a1, 0x1FFFF);
  sub_807B25E(a1);
  sub_807B7DC(a1);
  return sub_8076A50(a2, *(unsigned __int16 *)(a2 + 6));
}
// 8394020: using guessed type int dword_8394020;

//----- (08082A4A) --------------------------------------------------------
int __cdecl sub_8082A4A(int a1)
{
  int result; // eax
  int v2; // [esp+Ch] [ebp-Ch]
  int v3; // [esp+10h] [ebp-8h]
  int v4; // [esp+14h] [ebp-4h]

  v4 = dword_83D7608;
  v3 = dword_83D7608;
  while ( 1 )
  {
    v2 = dword_83D7624[6 * v4];
    if ( v2 == a1 )
      break;
    --v4;
    if ( !sub_807B1F0(v2) )
      v3 = v4;
  }
  while ( 1 )
  {
    result = v3;
    if ( v3 < v4 )
      break;
    dword_83D7620[6 * v3--] = (int)&unk_83D4100;
  }
  return result;
}
// 83D7608: using guessed type int dword_83D7608;
// 83D7620: using guessed type int dword_83D7620[];
// 83D7624: using guessed type int dword_83D7624[];

//----- (08082AC0) --------------------------------------------------------
int __cdecl sub_8082AC0(int a1, int a2)
{
  int v2; // eax
  int v3; // ST24_4
  int v4; // ST1C_4
  int v6; // [esp+18h] [ebp-10h]
  int v7; // [esp+20h] [ebp-8h]

  v7 = sub_807B1C8(a2);
  sub_807B190(a2);
  v2 = sub_807BB34(dword_839401C, v7);
  v3 = sub_807CB1E(v2);
  v4 = sub_807BB58(v3, a2);
  v6 = *(_DWORD *)sub_807C4FC(v4);
  sub_807C228(v3, a2);
  if ( !sub_807C9AC(v3) && v7 != dword_8394018 )
    sub_807C16E(dword_839401C, v7);
  return sub_8082754(a1, a2, v6);
}
// 8394018: using guessed type int dword_8394018;
// 839401C: using guessed type int dword_839401C;

//----- (08082B7E) --------------------------------------------------------
int __cdecl sub_8082B7E(int a1)
{
  int v1; // eax
  int v2; // eax
  int v3; // eax
  int v4; // ST10_4
  int v5; // eax
  __int16 *v6; // eax
  int result; // eax
  int v8; // [esp+14h] [ebp-4h]

  v1 = sub_807B766(a1);
  v8 = v1;
  v2 = sub_807BB58(dword_8394020, v1);
  v3 = sub_807CB1E(v2);
  v4 = v3;
  v5 = sub_807BB58(v3, a1);
  v6 = sub_807C4FC(v5);
  sub_80823CE(*(_DWORD *)v6, a1);
  sub_807C228(v4, a1);
  result = sub_807C9AC(v4);
  if ( !result )
    result = sub_807C228(dword_8394020, v8);
  return result;
}
// 8394020: using guessed type int dword_8394020;

//----- (08082C1A) --------------------------------------------------------
int __cdecl sub_8082C1A(int a1, int a2)
{
  unsigned __int16 v2; // ax
  int v3; // eax
  int v4; // eax
  int v5; // eax
  int v6; // ST30_4
  int v7; // eax
  int *v8; // eax
  int v9; // ST28_4
  int v10; // eax
  int v11; // eax
  int v12; // ST20_4
  int v13; // eax
  int v14; // ST24_4
  int v15; // ST1C_4
  int v16; // ST1C_4
  int v18; // [esp+18h] [ebp-20h]
  int v19; // [esp+2Ch] [ebp-Ch]
  int v20; // [esp+34h] [ebp-4h]

  v2 = sub_807B110(a2);
  v19 = v2;
  if ( v2 )
  {
    v3 = sub_807B766(a2);
    v20 = v3;
    v4 = sub_807BB58(dword_8394020, v3);
    v5 = sub_807CB1E(v4);
    v6 = v5;
    v7 = sub_807BB58(v5, a2);
    v8 = (int *)sub_807C4FC(v7);
    v9 = *v8;
    v10 = sub_807BB34(*v8, 131070);
    v11 = sub_807CB1E(v10);
    v12 = v11;
    v13 = sub_807BB34(v11, v19);
    v14 = sub_807CB1E(v13);
    v15 = sub_807BB58(v14, a2);
    v18 = *(_DWORD *)sub_807C4FC(v15);
    sub_8082366(v9, a2, v12, v14, v19);
    sub_807C228(v6, a2);
    if ( !sub_807C9AC(v6) )
      sub_807C228(dword_8394020, v20);
  }
  else
  {
    v16 = sub_807BB34(a2, 0x1FFFF);
    v18 = *(_DWORD *)sub_807C4FC(v16);
    sub_807C16E(a2, 0x1FFFF);
  }
  return sub_8082754(a1, a2, v18);
}
// 8394020: using guessed type int dword_8394020;

//----- (08082D9A) --------------------------------------------------------
int __cdecl sub_8082D9A(int a1, int a2)
{
  unsigned __int16 v2; // ax
  int v3; // eax
  int v4; // eax
  int v5; // eax
  int v6; // eax
  __int16 *v7; // eax
  int v8; // eax
  int v9; // eax
  int v10; // eax
  int v11; // ST14_4
  int v14; // [esp+1Ch] [ebp-Ch]

  v2 = sub_807B110(a2);
  v14 = v2;
  if ( !v2 )
    return sub_807BB34(a2, 0x1FFFF);
  v3 = sub_807B766(a2);
  v4 = sub_807BB58(dword_8394020, v3);
  v5 = sub_807CB1E(v4);
  v6 = sub_807BB58(v5, a2);
  v7 = sub_807C4FC(v6);
  v8 = sub_807BB34(*(_DWORD *)v7, 131070);
  v9 = sub_807CB1E(v8);
  v10 = sub_807BB34(v9, v14);
  v11 = sub_807CB1E(v10);
  return sub_807BB58(v11, a2);
}
// 8394020: using guessed type int dword_8394020;

//----- (08082E74) --------------------------------------------------------
_BOOL4 __cdecl sub_8082E74(unsigned int a1)
{
  int v1; // ST14_4

  if ( sub_807DF7C(a1) != 16 )
    return 0;
  if ( sub_807B22A(a1) != a1 )
    return 0;
  v1 = sub_8082D9A(a1, a1);
  return sub_807DF7C(v1) == 0;
}

//----- (08082EE2) --------------------------------------------------------
signed int __cdecl sub_8082EE2(unsigned int a1)
{
  int v1; // eax
  signed int result; // eax
  int v3; // [esp+14h] [ebp-4h]

  v1 = sub_807B22A(a1);
  v3 = v1;
  result = sub_807DF7C(v1);
  if ( result == 16 )
    return sub_8082C1A(a1, v3);
  if ( result > 16 )
  {
    if ( result == 17 )
      result = sub_8082AC0(a1, v3);
  }
  else if ( result == 15 )
  {
    result = sub_8082A4A(a1);
  }
  return result;
}

//----- (08082F56) --------------------------------------------------------
int __cdecl sub_8082F56(int a1, int a2, int *a3)
{
  int result; // eax
  int v4; // eax
  int v5; // eax
  int v6; // eax
  int v7; // eax
  int v8; // edx
  int v9; // eax
  int v10; // eax
  int v11; // ST1C_4
  char **v12; // [esp+20h] [ebp-58h]
  int v13; // [esp+24h] [ebp-54h]
  int v14; // [esp+28h] [ebp-50h]
  int v15; // [esp+2Ch] [ebp-4Ch]
  int v16; // [esp+30h] [ebp-48h]
  int v17; // [esp+34h] [ebp-44h]
  bool v18; // [esp+3Bh] [ebp-3Dh]
  int v19; // [esp+3Ch] [ebp-3Ch]
  int v20; // [esp+40h] [ebp-38h]
  unsigned int v21; // [esp+44h] [ebp-34h]
  int v22; // [esp+48h] [ebp-30h]
  size_t n; // [esp+4Ch] [ebp-2Ch]
  int v24; // [esp+50h] [ebp-28h]
  int v25; // [esp+54h] [ebp-24h]
  unsigned __int8 *v26; // [esp+58h] [ebp-20h]
  char **v27; // [esp+5Ch] [ebp-1Ch]
  char **v28; // [esp+60h] [ebp-18h]
  __int16 *v29; // [esp+64h] [ebp-14h]
  int *i; // [esp+68h] [ebp-10h]
  int v31; // [esp+6Ch] [ebp-Ch]
  int v32; // [esp+70h] [ebp-8h]
  int v33; // [esp+74h] [ebp-4h]

  result = sub_807BB34(a1, 131070);
  v32 = result;
  if ( result )
  {
    v4 = sub_807CB1E(v32);
    v32 = v4;
    result = sub_807BB34(v4, a2);
    v33 = result;
    if ( result )
    {
      v33 = sub_807CB1E(v33);
      sub_807B7BA(v33);
      byte_839400C = 1;
      v19 = v33;
LABEL_4:
      while ( 1 )
      {
        v19 = sub_807CA16(v19);
        if ( !v19 )
          break;
        v5 = sub_807A3E8(v19);
        v31 = v5;
        v6 = sub_807B766(v5);
        v21 = v6;
        v7 = sub_807BB58(dword_8394020, v6);
        v20 = sub_807CB1E(v7);
        if ( sub_807DF7C(v19) )
        {
          v29 = sub_807C4FC(v19);
          v28 = *(char ***)v29;
          if ( *(*v28 - 1) == 119 )
          {
            v25 = **v28;
            v26 = (unsigned __int8 *)v28 + 5 * (*((unsigned __int16 *)v28 + 2) - v25) + 11;
            for ( i = a3; v25; i -= 2 )
            {
              if ( i[1] == 8 )
                goto LABEL_4;
              --v25;
              v15 = *v26;
              if ( v15 == 8 )
                break;
              v14 = *(_DWORD *)++v26;
              v26 += 4;
              sub_807578C(&v14);
              v8 = i[1];
              v16 = *i;
              v17 = v8;
              sub_807578C(&v16);
              sub_807D470(&v14, &v16);
              if ( *(_DWORD *)dword_8394010 )
              {
                sub_8078282(*v28, **v28 - v25 + 3, *(int *)dword_8394010, (void *)dword_83D5590);
                sub_807F810();
                goto LABEL_4;
              }
              if ( !v14 )
                goto LABEL_4;
            }
            ++*v28;
            v18 = 1;
          }
          else
          {
            v18 = a3[1] == 8;
          }
          v13 = 10;
          v12 = v28;
          v9 = sub_807C0A8(dword_839401C, dword_8394018);
          v10 = sub_807CAD2(v9);
          v11 = sub_807C11A(v10, v31);
          sub_807C4C2(v11, (int *)&v12);
          v29 = sub_807C4FC(v11);
          sub_8082366(a1, v31, v32, v33, a2);
          sub_807C228(v20, v31);
          if ( !sub_807C9AC(v20) )
            sub_807C228(dword_8394020, v21);
          sub_807B128(v31, dword_8394018);
          if ( v18 )
          {
            v19 = v33;
          }
          else
          {
            v25 = *((unsigned __int16 *)v28 + 2);
            v24 = v25;
            i = a3;
            do
            {
              ++v24;
              i -= 2;
            }
            while ( i[1] != 8 );
            n = 5 * v25;
            v22 = 5 * v24 + 11;
            if ( !sub_8076B6C(*((unsigned __int16 *)v28 + 3), v22) )
            {
              v27 = (char **)sub_8076A2A(v22);
              *((_WORD *)v27 + 3) = v22;
              *v27 = *v28;
              *((_WORD *)v27 + 4) = *((_WORD *)v28 + 4);
              memcpy((char *)v27 + 11, (char *)v28 + 11, n);
              sub_8076A50((int)v28, *((unsigned __int16 *)v28 + 3));
              v28 = v27;
              *(_DWORD *)v29 = v27;
            }
            *((_WORD *)v28 + 2) = v24;
            v26 = (unsigned __int8 *)v28 + n + 11;
            v24 -= v25;
            do
            {
              i += 2;
              sub_807578C(i);
              *v26++ = *((_BYTE *)i + 4);
              *(_DWORD *)v26 = *i;
              v26 += 4;
              --v24;
            }
            while ( v24 );
            v19 = v33;
          }
        }
        else
        {
          sub_8082366(a1, v31, v32, v33, a2);
          sub_807B360(v31);
          sub_807C228(v20, v31);
          if ( !sub_807C9AC(v20) )
            sub_807C228(dword_8394020, v21);
          sub_8082EE2(v21);
          v19 = v33;
        }
      }
      result = sub_807B7DC(v33);
      byte_839400C = 0;
    }
  }
  return result;
}
// 839400C: using guessed type char byte_839400C;
// 8394018: using guessed type int dword_8394018;
// 839401C: using guessed type int dword_839401C;
// 8394020: using guessed type int dword_8394020;
// 83D5590: using guessed type int dword_83D5590;

//----- (08083426) --------------------------------------------------------
int __cdecl sub_8083426(int a1, int a2, int a3, int a4)
{
  int v4; // ST0C_4
  int result; // eax
  int v6; // [esp+10h] [ebp-8h]
  int v7; // [esp+14h] [ebp-4h]
  int v8; // [esp+2Ch] [ebp+14h]

  sub_807FA9C();
  v6 = dword_83D7610 - 8 * a4;
  v8 = dword_83D7618 - a4;
  v7 = sub_807E346(a1, a2);
  if ( v7 )
  {
    v4 = *(_DWORD *)(v6 + 4);
    *(_DWORD *)(v6 + 4) = 8;
    dword_83D7618 = 0;
    sub_8082F56(v7, a3, (int *)dword_83D7610);
    *(_DWORD *)(v6 + 4) = v4;
  }
  while ( dword_83D7610 != v6 )
  {
    sub_80757AC((_DWORD *)dword_83D7610);
    dword_83D7610 -= 8;
  }
  result = v8;
  dword_83D7618 = v8;
  return result;
}
// 83D7610: using guessed type int dword_83D7610;
// 83D7618: using guessed type int dword_83D7618;

//----- (080834DC) --------------------------------------------------------
int __cdecl sub_80834DC(int a1)
{
  int result; // eax
  int v2; // eax
  int v3; // eax
  int v4; // ST14_4
  int v5; // ST10_4
  __int16 *v6; // eax
  int v7; // [esp+Ch] [ebp-1Ch]
  int v8; // [esp+18h] [ebp-10h]
  int v9; // [esp+24h] [ebp-4h]
  int v10; // [esp+24h] [ebp-4h]

  while ( 1 )
  {
    result = sub_807BB34(a1, 131070);
    if ( !result )
      break;
    v2 = sub_807CB1E(result);
    result = sub_807C9CE(v2);
    if ( !result )
      break;
    v3 = sub_807CB1E(result);
    result = sub_807C9CE(v3);
    v9 = result;
    if ( !result )
      break;
    v8 = sub_807A3E8(result);
    if ( sub_807DF7C(v9) == 10 )
    {
      v4 = *(_DWORD *)sub_807C4FC(v9);
      sub_8082B7E(v8);
      sub_80828BE(v8, v4, 0);
    }
    else
    {
      sub_807B7BA(v8);
      sub_8082B7E(v8);
      v5 = sub_807B766(v8);
      v7 = sub_807B22A(v5);
      v10 = sub_807BB34(v7, 0x1FFFF);
      if ( v10 )
      {
        v6 = sub_807C4FC(v10);
        sub_80828BE(v7, *(_DWORD *)v6, 1);
      }
      sub_807B360(v8);
      sub_807B8D4(v8);
    }
  }
  return result;
}

//----- (08083640) --------------------------------------------------------
int __cdecl sub_8083640(int a1)
{
  int v1; // ST10_4
  int v2; // ST0C_4
  int v4; // [esp+14h] [ebp-4h]

  sub_807B7BA(a1);
  while ( 1 )
  {
    v4 = sub_807C9CE(a1);
    if ( !v4 )
      break;
    v1 = sub_807A3E8(v4);
    v2 = *(_DWORD *)sub_807C4FC(v4);
    sub_807C228(a1, v1);
    sub_807B190(v1);
    sub_8082754(v1, v1, v2);
  }
  return sub_807B7DC(a1);
}

//----- (080836CA) --------------------------------------------------------
unsigned int __cdecl sub_80836CA(int a1)
{
  int v1; // ST28_4
  int v2; // ST24_4
  int v3; // eax
  unsigned int result; // eax
  int v5; // [esp+2Ch] [ebp-2Ch]
  unsigned __int8 *v6; // [esp+30h] [ebp-28h]
  int v7; // [esp+34h] [ebp-24h]
  int v8; // [esp+38h] [ebp-20h]
  _DWORD *v9; // [esp+3Ch] [ebp-1Ch]
  _DWORD *i; // [esp+40h] [ebp-18h]

  sub_8084FE0();
  sub_807B7BA(a1);
  for ( i = &unk_83D7920; ; sub_80757AC(i + 2) )
  {
    v5 = sub_807C9CE(a1);
    if ( !v5 )
      break;
    v1 = sub_807A3E8(v5);
    v2 = *(_DWORD *)sub_807C4FC(v5);
    sub_807C228(a1, v1);
    sub_80825C2(v1, &v6, v2);
    v3 = sub_807FB08(v6, v7, v8, v9, (int)i);
    sub_807B7DC(v3);
  }
  sub_807B7DC(a1);
  result = sub_807C5E2(dword_8394034);
  dword_83D7610 = (int)&unk_83D7920;
  return result;
}
// 8394034: using guessed type int dword_8394034;
// 83D7610: using guessed type int dword_83D7610;

//----- (080837B0) --------------------------------------------------------
int sub_80837B0()
{
  int result; // eax

  sub_807FA9C();
  result = dword_83D7610;
  if ( dword_83D7610 == dword_83D7604 )
    Com_Error(1, &byte_8140CE0);
  dword_83D7610 += 8;
  ++dword_83D7618;
  return result;
}
// 83D7604: using guessed type int dword_83D7604;
// 83D7610: using guessed type int dword_83D7610;
// 83D7618: using guessed type int dword_83D7618;

//----- (080837EC) --------------------------------------------------------
int __cdecl sub_80837EC(int a1, char *a2, int a3)
{
  int v3; // ST2C_4
  int v5; // [esp+28h] [ebp-30h]
  int v6; // [esp+34h] [ebp-24h]
  int v7; // [esp+40h] [ebp-18h]
  int v8; // [esp+68h] [ebp+10h]

  sub_807FA9C();
  v7 = dword_83D7610 - 8 * a3;
  v8 = dword_83D7618 - a3;
  if ( dword_83D7608 > 29 )
  {
    sub_807B25E(a1);
    dword_83D7618 = v8 + 1;
    while ( v8 )
    {
      sub_80757AC((_DWORD *)dword_83D7610);
      dword_83D7610 -= 8;
      --v8;
    }
    dword_83D7610 += 8;
    *(_DWORD *)(dword_83D7610 + 4) = 0;
    sub_8078282(a2, 0, (int)"script stack overflow (too many embedded function calls)", 0);
    v5 = a1;
  }
  else
  {
    if ( dword_83D7608 )
    {
      ++dword_83D7608;
      dword_83D760C += 24;
      *(_DWORD *)(dword_83D760C + 4) = 0;
    }
    *(_DWORD *)dword_83D760C = a2;
    ++dword_83D7608;
    dword_83D760C += 24;
    *(_DWORD *)(dword_83D760C + 4) = a1;
    v3 = *(_DWORD *)(v7 + 4);
    *(_DWORD *)(v7 + 4) = 8;
    dword_83D7618 = 0;
    v6 = sub_807FB08((unsigned __int8 *)a2, a1, 0, (_DWORD *)dword_83D7610, v7);
    *(_DWORD *)(v7 + 4) = v3;
    dword_83D7610 = v7 + 8;
    dword_83D7618 = v8 + 1;
    sub_807C5E2(dword_8394034);
    if ( dword_83D7608 )
    {
      --dword_83D7608;
      dword_83D760C -= 24;
    }
    v5 = v6;
  }
  return v5;
}
// 8394034: using guessed type int dword_8394034;
// 83D7608: using guessed type int dword_83D7608;
// 83D760C: using guessed type int dword_83D760C;
// 83D7610: using guessed type int dword_83D7610;
// 83D7618: using guessed type int dword_83D7618;

//----- (0808398E) --------------------------------------------------------
int __cdecl sub_808398E(int a1, int a2)
{
  int v2; // eax
  unsigned __int16 v3; // ST14_2
  char *v5; // [esp+10h] [ebp-8h]

  v5 = (char *)(dword_8394048 + a1);
  if ( !dword_83D7608 )
    sub_8084FE0();
  sub_80757CC((int)v5);
  sub_807B7BA(dword_8394024);
  v2 = sub_807B6AC(dword_8394024);
  v3 = sub_80837EC(v2, v5, a2);
  sub_80757AC((_DWORD *)dword_83D7610);
  *(_DWORD *)(dword_83D7610 + 4) = 0;
  dword_83D7610 -= 8;
  --dword_83D7618;
  return v3;
}
// 8394024: using guessed type int dword_8394024;
// 8394048: using guessed type int dword_8394048;
// 83D7608: using guessed type int dword_83D7608;
// 83D7610: using guessed type int dword_83D7610;
// 83D7618: using guessed type int dword_83D7618;

//----- (08083A1A) --------------------------------------------------------
int __cdecl sub_8083A1A(int a1, int a2, int a3, int a4)
{
  int v4; // ST10_4
  int v5; // eax
  unsigned __int16 v6; // ST14_2
  char *v8; // [esp+Ch] [ebp-Ch]

  v8 = (char *)(dword_8394048 + a3);
  if ( !dword_83D7608 )
    sub_8084FE0();
  v4 = sub_807E3A6(a1, a2);
  sub_807B7BA(v4);
  v5 = sub_807B6AC(v4);
  v6 = sub_80837EC(v5, v8, a4);
  sub_80757AC((_DWORD *)dword_83D7610);
  *(_DWORD *)(dword_83D7610 + 4) = 0;
  dword_83D7610 -= 8;
  --dword_83D7618;
  return v6;
}
// 8394048: using guessed type int dword_8394048;
// 83D7608: using guessed type int dword_83D7608;
// 83D7610: using guessed type int dword_83D7610;
// 83D7618: using guessed type int dword_83D7618;

//----- (08083AAC) --------------------------------------------------------
int __cdecl sub_8083AAC(int a1, int a2)
{
  int v2; // eax
  int v3; // eax
  int result; // eax
  char *v5; // [esp+14h] [ebp-4h]

  v5 = (char *)(dword_8394048 + a1);
  if ( !dword_83D7608 )
    sub_8084FE0();
  sub_807B7BA(dword_8394024);
  v2 = sub_807B6AC(dword_8394024);
  v3 = sub_80837EC(v2, v5, a2);
  result = sub_807B7DC(v3);
  ++dword_83D761C;
  --dword_83D7618;
  return result;
}
// 8394024: using guessed type int dword_8394024;
// 8394048: using guessed type int dword_8394048;
// 83D7608: using guessed type int dword_83D7608;
// 83D7618: using guessed type int dword_83D7618;
// 83D761C: using guessed type int dword_83D761C;

//----- (08083B14) --------------------------------------------------------
int __cdecl sub_8083B14(int a1, int a2, int a3, int a4)
{
  int v4; // ST10_4
  int v5; // eax
  int v6; // eax
  int result; // eax
  char *v8; // [esp+14h] [ebp-4h]

  v8 = (char *)(dword_8394048 + a3);
  if ( !dword_83D7608 )
    sub_8084FE0();
  v4 = sub_807E3A6(a1, a2);
  sub_807B7BA(v4);
  v5 = sub_807B6AC(v4);
  v6 = sub_80837EC(v5, v8, a4);
  result = sub_807B7DC(v6);
  ++dword_83D761C;
  --dword_83D7618;
  return result;
}
// 8394048: using guessed type int dword_8394048;
// 83D7608: using guessed type int dword_83D7608;
// 83D7618: using guessed type int dword_83D7618;
// 83D761C: using guessed type int dword_83D761C;

//----- (08083B8E) --------------------------------------------------------
int __cdecl sub_8083B8E(unsigned __int16 a1)
{
  return sub_807B7DC(a1);
}

//----- (08083BAA) --------------------------------------------------------
int __cdecl sub_8083BAA(char *a1, int a2)
{
  int result; // eax
  int v3; // [esp+24h] [ebp+Ch]

  sub_8084FE0();
  byte_83D7614 = 1;
  if ( a2 )
  {
    result = sub_80837EC(a2, a1, 0);
  }
  else
  {
    sub_807B7BA(dword_8394024);
    v3 = sub_807B6AC(dword_8394024);
    sub_80837EC(v3, a1, 0);
    sub_807B25E(v3);
    result = sub_807B7DC(v3);
  }
  byte_83D7614 = 0;
  if ( dword_83D7608 )
  {
    --dword_83D7608;
    dword_83D760C -= 24;
  }
  dword_83D7610 -= 8;
  dword_83D7618 = 0;
  return result;
}
// 8394024: using guessed type int dword_8394024;
// 83D7608: using guessed type int dword_83D7608;
// 83D760C: using guessed type int dword_83D760C;
// 83D7610: using guessed type int dword_83D7610;
// 83D7614: using guessed type char byte_83D7614;
// 83D7618: using guessed type int dword_83D7618;

//----- (08083C5C) --------------------------------------------------------
void sub_8083C5C()
{
  int v0; // eax
  int v1; // [esp+14h] [ebp-4h]

  if ( dword_839401C )
  {
    v1 = sub_807BB34(dword_839401C, dword_8394018);
    if ( v1 )
    {
      v0 = sub_807CB1E(v1);
      sub_80836CA(v0);
      sub_807C290(dword_839401C, dword_8394018);
    }
  }
}
// 8394018: using guessed type int dword_8394018;
// 839401C: using guessed type int dword_839401C;

//----- (08083CBA) --------------------------------------------------------
int __cdecl sub_8083CBA(int a1, int a2, int a3, char a4, int a5)
{
  int v5; // ST08_4
  int j; // [esp+Ch] [ebp-Ch]
  int i; // [esp+10h] [ebp-8h]

  v5 = sub_807CB1E(a2);
  for ( i = sub_807C9CE(v5); i; i = sub_807C9CE(i) )
  {
    if ( sub_807DF7C(i) == 10 )
    {
      for ( j = *(unsigned __int16 *)(*(_DWORD *)sub_807C4FC(i) + 8); j; j = sub_807B1F0(j) )
      {
        if ( !a4 || a1 == sub_807B766(j) )
        {
          if ( a5 )
            *(_DWORD *)(a5 + 4 * a3) = j;
          ++a3;
          break;
        }
      }
    }
  }
  return a3;
}

//----- (08083D82) --------------------------------------------------------
signed int __cdecl sub_8083D82(int a1, int *a2, int a3)
{
  int v3; // eax
  signed int v5; // [esp+1Ch] [ebp-Ch]
  int v6; // [esp+20h] [ebp-8h]
  int j; // [esp+20h] [ebp-8h]
  int i; // [esp+24h] [ebp-4h]

  v5 = 0;
  if ( a3 && a1 == sub_807B766(a3) )
  {
    if ( a2 )
      *a2 = a3;
    v5 = 1;
  }
  for ( i = sub_807C9CE(dword_839401C); i; i = sub_807C9CE(i) )
    v5 = sub_8083CBA(a1, i, v5, 1, (int)a2);
  v6 = sub_807BB34(a1, 131070);
  if ( v6 )
  {
    v3 = sub_807CB1E(v6);
    for ( j = sub_807C9CE(v3); j; j = sub_807C9CE(j) )
      v5 = sub_8083CBA(a1, j, v5, 0, (int)a2);
  }
  return v5;
}
// 839401C: using guessed type int dword_839401C;

//----- (08083E96) --------------------------------------------------------
int sub_8083E96()
{
  int result; // eax

  dword_839401C = sub_807B5A0();
  dword_8394020 = sub_807B658();
  dword_8394024 = sub_807B5A0();
  result = sub_807B5A0();
  dword_839402C = result;
  dword_8394018 = 0;
  dword_83D553C = -1;
  return result;
}
// 8394018: using guessed type int dword_8394018;
// 839401C: using guessed type int dword_839401C;
// 8394020: using guessed type int dword_8394020;
// 8394024: using guessed type int dword_8394024;
// 839402C: using guessed type int dword_839402C;
// 83D553C: using guessed type int dword_83D553C;

//----- (08083EDA) --------------------------------------------------------
unsigned int *__cdecl sub_8083EDA(int a1, int a2)
{
  unsigned int *result; // eax
  int v3; // eax
  int v4; // eax
  int v5; // ST10_4
  int v6; // ST0C_4
  int i; // [esp+10h] [ebp-8h]
  int v8; // [esp+10h] [ebp-8h]

  sub_8075758();
  result = (unsigned int *)sub_807E04A();
  if ( dword_839401C )
  {
    sub_807F676(a2);
    for ( i = sub_807C9CE(dword_839401C); i; i = sub_807C9CE(i) )
    {
      v3 = sub_807CB1E(i);
      sub_8083640(v3);
    }
    while ( 1 )
    {
      v8 = sub_807C9CE(dword_8394020);
      if ( !v8 )
        break;
      v4 = sub_807CB1E(v8);
      v5 = sub_807C9CE(v4);
      v6 = *(_DWORD *)sub_807C4FC(v5);
      sub_807B7BA(v6);
      sub_80834DC(v6);
      sub_807B7DC(v6);
    }
    sub_807AF82(dword_8394024);
    sub_807B8D4(dword_8394024);
    dword_8394024 = 0;
    sub_807AF82(dword_839402C);
    sub_807B8D4(dword_839402C);
    dword_839402C = 0;
    sub_807AF82(dword_839401C);
    sub_807B8D4(dword_839401C);
    dword_839401C = 0;
    sub_807B8D4(dword_8394020);
    dword_8394020 = 0;
    result = sub_807E0C6();
  }
  return result;
}
// 839401C: using guessed type int dword_839401C;
// 8394020: using guessed type int dword_8394020;
// 8394024: using guessed type int dword_8394024;
// 839402C: using guessed type int dword_839402C;

//----- (08084030) --------------------------------------------------------
_BOOL4 sub_8084030()
{
  return dword_839401C != 0;
}
// 839401C: using guessed type int dword_839401C;

//----- (0808404C) --------------------------------------------------------
int __cdecl sub_808404C(unsigned int a1)
{
  char *v1; // eax
  char *v2; // eax
  _DWORD *v5; // [esp+14h] [ebp-4h]

  if ( a1 >= dword_83D761C )
    goto LABEL_5;
  v5 = (_DWORD *)(dword_83D7610 - 8 * a1);
  if ( *(_DWORD *)(dword_83D7610 - 8 * a1 + 4) != 6 )
  {
    dword_8394014 = a1 + 1;
    v1 = va("type %s is not an int", *(_DWORD *)&off_815ABC0[4 * v5[1]]);
    sub_8084DB4((int)v1);
LABEL_5:
    v2 = va("parameter %d does not exist", a1 + 1);
    sub_8084DB4((int)v2);
    return 0;
  }
  return *v5;
}
// 8394014: using guessed type int dword_8394014;
// 83D7610: using guessed type int dword_83D7610;
// 83D761C: using guessed type int dword_83D761C;

//----- (080840DA) --------------------------------------------------------
unsigned __int16 *__userpurge sub_80840DA@<eax>(unsigned __int16 *a1, unsigned int a2, int a3)
{
  int v3; // ebx
  int v4; // eax
  int v5; // ebx
  int v6; // eax
  int v7; // esi
  int v8; // eax
  char *v9; // eax
  char *v10; // eax
  _DWORD *v12; // [esp+1Ch] [ebp-Ch]

  if ( a2 >= dword_83D761C )
    goto LABEL_8;
  v12 = (_DWORD *)(dword_83D7610 - 8 * a2);
  if ( *(_DWORD *)(dword_83D7610 - 8 * a2 + 4) != 11 )
  {
    *(_DWORD *)dword_8394010 = va("type %s is not an anim", *(_DWORD *)&off_815ABC0[4 * v12[1]]);
    goto LABEL_7;
  }
  *(_DWORD *)a1 = *v12;
  if ( a3 )
  {
    v3 = sub_806D074(a1[1]);
    if ( v3 != sub_80BA87C(a3) )
    {
      v4 = sub_80BA87C(a3);
      v5 = sub_80BEA0E(v4);
      v6 = sub_806D074(a1[1]);
      v7 = sub_80BEA0E(v6);
      v8 = sub_806D074(a1[1]);
      v9 = sub_80BE94C(v8, *a1);
      *(_DWORD *)dword_8394010 = va(
                                   "anim '%s' in animtree '%s' does not belong to the entity's animtree '%s'",
                                   v9,
                                   v7,
                                   v5);
LABEL_7:
      sub_80757AC(v12);
      v12[1] = 0;
      dword_8394014 = a2 + 1;
      sub_807FA00();
LABEL_8:
      v10 = va("parameter %d does not exist", a2 + 1);
      sub_8084DB4((int)v10);
      *a1 = 0;
      a1[1] = 0;
      return a1;
    }
  }
  return a1;
}
// 8394014: using guessed type int dword_8394014;
// 83D7610: using guessed type int dword_83D7610;
// 83D761C: using guessed type int dword_83D761C;

//----- (0808423E) --------------------------------------------------------
_DWORD *__userpurge sub_808423E@<eax>(_DWORD *a1, unsigned int a2)
{
  char *v2; // eax
  int *v4; // [esp+10h] [ebp-8h]
  int v5; // [esp+14h] [ebp-4h]

  if ( a2 >= dword_83D761C )
    goto LABEL_9;
  v4 = (int *)(dword_83D7610 - 8 * a2);
  if ( *(_DWORD *)(dword_83D7610 - 8 * a2 + 4) != 6 )
  {
    *(_DWORD *)dword_8394010 = va("type %s is not an animtree", *(_DWORD *)&off_815ABC0[4 * v4[1]]);
    goto LABEL_8;
  }
  v5 = *v4;
  if ( *v4 > (unsigned int)dword_8202850 || !dword_820264C[v5] )
  {
    *(_DWORD *)dword_8394010 = "bad anim tree";
LABEL_8:
    sub_80757AC(v4);
    v4[1] = 0;
    dword_8394014 = a2 + 1;
    sub_807FA00();
LABEL_9:
    v2 = va("parameter %d does not exist", a2 + 1);
    sub_8084DB4((int)v2);
    *a1 = dword_820264C[0];
    return a1;
  }
  *a1 = dword_820264C[v5];
  return a1;
}
// 8202850: using guessed type int dword_8202850;
// 8394014: using guessed type int dword_8394014;
// 83D7610: using guessed type int dword_83D7610;
// 83D761C: using guessed type int dword_83D761C;

//----- (08084320) --------------------------------------------------------
long double __cdecl sub_8084320(unsigned int a1)
{
  char *v1; // eax
  char *v2; // eax
  signed int *v5; // [esp+14h] [ebp-4h]

  if ( a1 >= dword_83D761C )
    goto LABEL_7;
  v5 = (signed int *)(dword_83D7610 - 8 * a1);
  if ( *(_DWORD *)(dword_83D7610 - 8 * a1 + 4) != 5 )
  {
    if ( v5[1] == 6 )
      return (float)*v5;
    dword_8394014 = a1 + 1;
    v1 = va("type %s is not a float", *(_DWORD *)&off_815ABC0[4 * v5[1]]);
    sub_8084DB4((int)v1);
LABEL_7:
    v2 = va("parameter %d does not exist", a1 + 1);
    sub_8084DB4((int)v2);
    return (float)0.0;
  }
  return *(float *)v5;
}
// 8394014: using guessed type int dword_8394014;
// 83D7610: using guessed type int dword_83D7610;
// 83D761C: using guessed type int dword_83D761C;

//----- (080843C0) --------------------------------------------------------
int __cdecl sub_80843C0(unsigned int a1)
{
  char *v1; // eax
  int v4; // [esp+14h] [ebp-4h]

  if ( a1 >= dword_83D761C )
    goto LABEL_5;
  v4 = dword_83D7610 - 8 * a1;
  if ( !(unsigned __int8)sub_807CCCE((int *)(dword_83D7610 - 8 * a1)) )
  {
    dword_8394014 = a1 + 1;
    sub_807FA00();
LABEL_5:
    v1 = va("parameter %d does not exist", a1 + 1);
    sub_8084DB4((int)v1);
    return 0;
  }
  return *(_DWORD *)v4;
}
// 8394014: using guessed type int dword_8394014;
// 83D7610: using guessed type int dword_83D7610;
// 83D761C: using guessed type int dword_83D761C;

//----- (08084434) --------------------------------------------------------
int __cdecl sub_8084434(unsigned int a1)
{
  char *v1; // eax
  int v4; // [esp+20h] [ebp-2018h]
  int *v5; // [esp+24h] [ebp-2014h]
  int v6; // [esp+28h] [ebp-2010h]
  int i; // [esp+2Ch] [ebp-200Ch]
  char s[8200]; // [esp+30h] [ebp-2008h]

  if ( a1 >= dword_83D761C )
    goto LABEL_8;
  v5 = (int *)(dword_83D7610 - 8 * a1);
  if ( !(unsigned __int8)sub_807CCCE((int *)(dword_83D7610 - 8 * a1)) )
  {
    dword_8394014 = a1 + 1;
    sub_807FA00();
LABEL_8:
    v1 = va("parameter %d does not exist", a1 + 1);
    sub_8084DB4((int)v1);
    return 0;
  }
  v4 = *v5;
  v6 = sub_8078896(*v5);
  for ( i = 0; ; ++i )
  {
    s[i] = tolower(*(char *)(v6 + i));
    if ( !*(_BYTE *)(v6 + i) )
      break;
  }
  *v5 = sub_80792C4(s, 0);
  sub_80796A2(v4);
  return *v5;
}
// 8394014: using guessed type int dword_8394014;
// 83D7610: using guessed type int dword_83D7610;
// 83D761C: using guessed type int dword_83D761C;
// 8084434: using guessed type char s[8200];

//----- (0808456A) --------------------------------------------------------
int __cdecl sub_808456A(unsigned int a1)
{
  int v1; // eax

  v1 = sub_80843C0(a1);
  return sub_8078896(v1);
}

//----- (08084586) --------------------------------------------------------
int __cdecl sub_8084586(unsigned int a1)
{
  int v2; // [esp+4h] [ebp-4h]

  if ( a1 >= dword_83D761C || *(_DWORD *)(dword_83D7610 - 8 * a1 + 4) )
    v2 = sub_80843C0(a1);
  else
    v2 = 0;
  return v2;
}
// 83D7610: using guessed type int dword_83D7610;
// 83D761C: using guessed type int dword_83D761C;

//----- (080845C8) --------------------------------------------------------
int __cdecl sub_80845C8(unsigned int a1)
{
  int v1; // eax

  v1 = sub_80843C0(a1);
  return sub_8078896(v1);
}

//----- (080845E4) --------------------------------------------------------
int __cdecl sub_80845E4(unsigned int a1)
{
  int *v1; // ST14_4
  char *v2; // eax
  int v4; // [esp+10h] [ebp-8h]

  if ( a1 >= dword_83D761C )
  {
    v2 = va("parameter %d does not exist", a1 + 1);
    sub_8084DB4((int)v2);
    v4 = 0;
  }
  else
  {
    v1 = (int *)(dword_83D7610 - 8 * a1);
    sub_807CDD0((int *)(dword_83D7610 - 8 * a1));
    v4 = sub_8078896(*v1);
  }
  return v4;
}
// 83D7610: using guessed type int dword_83D7610;
// 83D761C: using guessed type int dword_83D761C;

//----- (0808464E) --------------------------------------------------------
int __cdecl sub_808464E(unsigned int a1)
{
  char *v1; // eax
  char *v2; // eax
  _DWORD *v5; // [esp+14h] [ebp-4h]

  if ( a1 >= dword_83D761C )
    goto LABEL_5;
  v5 = (_DWORD *)(dword_83D7610 - 8 * a1);
  if ( *(_DWORD *)(dword_83D7610 - 8 * a1 + 4) != 3 )
  {
    dword_8394014 = a1 + 1;
    v1 = va("type %s is not a localized string", *(_DWORD *)&off_815ABC0[4 * v5[1]]);
    sub_8084DB4((int)v1);
LABEL_5:
    v2 = va("parameter %d does not exist", a1 + 1);
    sub_8084DB4((int)v2);
    return 0;
  }
  return *v5;
}
// 8394014: using guessed type int dword_8394014;
// 83D7610: using guessed type int dword_83D7610;
// 83D761C: using guessed type int dword_83D761C;

//----- (080846DC) --------------------------------------------------------
int __cdecl sub_80846DC(unsigned int a1)
{
  int v1; // eax

  v1 = sub_808464E(a1);
  return sub_8078896(v1);
}

//----- (080846F8) --------------------------------------------------------
void __cdecl sub_80846F8(unsigned int a1, _DWORD *a2)
{
  char *v2; // eax
  char *v3; // eax
  int v4; // [esp+14h] [ebp-4h]

  if ( a1 < dword_83D761C )
  {
    v4 = dword_83D7610 - 8 * a1;
    if ( *(_DWORD *)(dword_83D7610 - 8 * a1 + 4) == 4 )
    {
      sub_8085124(*(_DWORD **)v4, a2);
      return;
    }
    dword_8394014 = a1 + 1;
    v2 = va("type %s is not a vector", *(_DWORD *)&off_815ABC0[4 * *(_DWORD *)(v4 + 4)]);
    sub_8084DB4((int)v2);
  }
  v3 = va("parameter %d does not exist", a1 + 1);
  sub_8084DB4((int)v3);
}
// 8394014: using guessed type int dword_8394014;
// 83D7610: using guessed type int dword_83D7610;
// 83D761C: using guessed type int dword_83D761C;

//----- (08084788) --------------------------------------------------------
int __cdecl sub_8084788(unsigned int a1)
{
  char *v1; // eax
  char *v2; // eax
  _DWORD *v5; // [esp+14h] [ebp-4h]

  if ( a1 >= dword_83D761C )
    goto LABEL_5;
  v5 = (_DWORD *)(dword_83D7610 - 8 * a1);
  if ( *(_DWORD *)(dword_83D7610 - 8 * a1 + 4) != 9 )
  {
    dword_8394014 = a1 + 1;
    v1 = va("type %s is not a function", *(_DWORD *)&off_815ABC0[4 * v5[1]]);
    sub_8084DB4((int)v1);
LABEL_5:
    v2 = va("parameter %d does not exist", a1 + 1);
    sub_8084DB4((int)v2);
    return 0;
  }
  return *v5 - dword_8394048;
}
// 8394014: using guessed type int dword_8394014;
// 8394048: using guessed type int dword_8394048;
// 83D7610: using guessed type int dword_83D7610;
// 83D761C: using guessed type int dword_83D761C;

//----- (0808481E) --------------------------------------------------------
_WORD *__userpurge sub_808481E@<eax>(_WORD *a1, unsigned int a2)
{
  int v2; // eax
  char *v3; // eax
  char *v4; // eax
  char *v5; // eax
  int *v7; // [esp+Ch] [ebp-Ch]
  int v8; // [esp+14h] [ebp-4h]

  if ( a2 >= dword_83D761C )
    goto LABEL_7;
  v7 = (int *)(dword_83D7610 - 8 * a2);
  if ( *(_DWORD *)(dword_83D7610 - 8 * a2 + 4) != 1 )
  {
LABEL_6:
    dword_8394014 = a2 + 1;
    v4 = va("type %s is not an entity", *(_DWORD *)&off_815ABC0[4 * v7[1]]);
    sub_8084DB4((int)v4);
LABEL_7:
    v5 = va("parameter %d does not exist", a2 + 1);
    sub_8084DB4((int)v5);
    *(_DWORD *)a1 = 0;
    return a1;
  }
  v8 = *v7;
  if ( sub_807DF7C(*v7) != 21 )
  {
    dword_8394014 = a2 + 1;
    v2 = sub_807DF7C(v8);
    v3 = va("type %s is not an entity", *(_DWORD *)&off_815ABC0[4 * v2]);
    sub_8084DB4((int)v3);
    goto LABEL_6;
  }
  sub_807EDC4(a1, v8);
  return a1;
}
// 8394014: using guessed type int dword_8394014;
// 83D7610: using guessed type int dword_83D7610;
// 83D761C: using guessed type int dword_83D761C;

//----- (0808491A) --------------------------------------------------------
int __cdecl sub_808491A(unsigned int a1)
{
  char *v1; // eax
  char *v2; // eax
  _DWORD *v5; // [esp+14h] [ebp-4h]

  if ( a1 >= dword_83D761C )
    goto LABEL_5;
  v5 = (_DWORD *)(dword_83D7610 - 8 * a1);
  if ( *(_DWORD *)(dword_83D7610 - 8 * a1 + 4) != 1 )
  {
    dword_8394014 = a1 + 1;
    v1 = va("type %s is not an object", *(_DWORD *)&off_815ABC0[4 * v5[1]]);
    sub_8084DB4((int)v1);
LABEL_5:
    v2 = va("parameter %d does not exist", a1 + 1);
    sub_8084DB4((int)v2);
    return 0;
  }
  return *v5;
}
// 8394014: using guessed type int dword_8394014;
// 83D7610: using guessed type int dword_83D7610;
// 83D761C: using guessed type int dword_83D761C;

//----- (080849A8) --------------------------------------------------------
int __cdecl sub_80849A8(unsigned int a1)
{
  char *v1; // eax

  if ( a1 < dword_83D761C )
    return *(_DWORD *)(dword_83D7610 - 8 * a1 + 4);
  v1 = va("parameter %d does not exist", a1 + 1);
  sub_8084DB4((int)v1);
  return 0;
}
// 83D7610: using guessed type int dword_83D7610;
// 83D761C: using guessed type int dword_83D761C;

//----- (080849F8) --------------------------------------------------------
int __cdecl sub_80849F8(unsigned int a1)
{
  char *v1; // eax

  if ( a1 < dword_83D761C )
    return *(_DWORD *)&off_815ABC0[4 * *(_DWORD *)(dword_83D7610 - 8 * a1 + 4)];
  v1 = va("parameter %d does not exist", a1 + 1);
  sub_8084DB4((int)v1);
  return 0;
}
// 83D7610: using guessed type int dword_83D7610;
// 83D761C: using guessed type int dword_83D761C;

//----- (08084A50) --------------------------------------------------------
int __cdecl sub_8084A50(unsigned int a1)
{
  char *v1; // eax
  char *v2; // eax

  if ( a1 >= dword_83D761C )
    goto LABEL_5;
  if ( *(_DWORD *)(dword_83D7610 - 8 * a1 + 4) != 1 )
  {
    v1 = va("type %s is not a pointer", *(_DWORD *)&off_815ABC0[4 * *(_DWORD *)(dword_83D7610 - 8 * a1 + 4)]);
    sub_8084DB4((int)v1);
LABEL_5:
    v2 = va("parameter %d does not exist", a1 + 1);
    sub_8084DB4((int)v2);
    return 0;
  }
  return sub_807DF7C(*(_DWORD *)(dword_83D7610 - 8 * a1));
}
// 83D7610: using guessed type int dword_83D7610;
// 83D761C: using guessed type int dword_83D761C;

//----- (08084AEE) --------------------------------------------------------
int sub_8084AEE()
{
  return dword_83D761C;
}
// 83D761C: using guessed type int dword_83D761C;

//----- (08084AF8) --------------------------------------------------------
int __cdecl Scr_AddBool(int a1)
{
  int result; // eax

  sub_80837B0();
  *(_DWORD *)(dword_83D7610 + 4) = 6;
  result = a1;
  *(_DWORD *)dword_83D7610 = a1;
  return result;
}
// 83D7610: using guessed type int dword_83D7610;

//----- (08084B1C) --------------------------------------------------------
int __cdecl Scr_AddInt(int a1)
{
  int result; // eax

  sub_80837B0();
  *(_DWORD *)(dword_83D7610 + 4) = 6;
  result = a1;
  *(_DWORD *)dword_83D7610 = a1;
  return result;
}
// 83D7610: using guessed type int dword_83D7610;

//----- (08084B40) --------------------------------------------------------
int __cdecl Scr_AddFloat(int a1)
{
  int result; // eax

  sub_80837B0();
  *(_DWORD *)(dword_83D7610 + 4) = 5;
  result = a1;
  *(_DWORD *)dword_83D7610 = a1;
  return result;
}
// 83D7610: using guessed type int dword_83D7610;

//----- (08084B64) --------------------------------------------------------
int __cdecl sub_8084B64(int a1)
{
  int result; // eax

  sub_80837B0();
  *(_DWORD *)(dword_83D7610 + 4) = 11;
  result = a1;
  *(_DWORD *)dword_83D7610 = a1;
  return result;
}
// 83D7610: using guessed type int dword_83D7610;

//----- (08084B88) --------------------------------------------------------
int Scr_AddUndefined()
{
  int result; // eax

  sub_80837B0();
  result = dword_83D7610;
  *(_DWORD *)(dword_83D7610 + 4) = 0;
  return result;
}
// 83D7610: using guessed type int dword_83D7610;

//----- (08084BA2) --------------------------------------------------------
int __cdecl sub_8084BA2(int a1)
{
  sub_80837B0();
  *(_DWORD *)(dword_83D7610 + 4) = 1;
  *(_DWORD *)dword_83D7610 = a1;
  return sub_807B7BA(a1);
}
// 83D7610: using guessed type int dword_83D7610;

//----- (08084BD2) --------------------------------------------------------
int __cdecl sub_8084BD2(int a1, int a2)
{
  int v2; // eax

  v2 = sub_807E3A6(a1, a2);
  return sub_8084BA2(v2);
}

//----- (08084BF4) --------------------------------------------------------
int sub_8084BF4()
{
  int v0; // ST04_4

  v0 = sub_807B5A0();
  sub_8084BA2(v0);
  return sub_807B7DC(v0);
}

//----- (08084C1A) --------------------------------------------------------
int __cdecl Scr_AddString(char *s)
{
  _DWORD *v1; // ebx
  int result; // eax

  sub_80837B0();
  *(_DWORD *)(dword_83D7610 + 4) = 2;
  v1 = (_DWORD *)dword_83D7610;
  result = sub_80792C4(s, 0);
  *v1 = result;
  return result;
}
// 83D7610: using guessed type int dword_83D7610;

//----- (08084C54) --------------------------------------------------------
int __cdecl sub_8084C54(char *s)
{
  _DWORD *v1; // ebx
  int result; // eax

  sub_80837B0();
  *(_DWORD *)(dword_83D7610 + 4) = 3;
  v1 = (_DWORD *)dword_83D7610;
  result = sub_80792C4(s, 0);
  *v1 = result;
  return result;
}
// 83D7610: using guessed type int dword_83D7610;

//----- (08084C8E) --------------------------------------------------------
int __cdecl sub_8084C8E(int a1)
{
  sub_80837B0();
  *(_DWORD *)(dword_83D7610 + 4) = 2;
  *(_DWORD *)dword_83D7610 = a1;
  return sub_807951E(a1);
}
// 83D7610: using guessed type int dword_83D7610;

//----- (08084CBE) --------------------------------------------------------
_DWORD *__cdecl Scr_AddVector(_DWORD *a1)
{
  _DWORD *v1; // ebx
  _DWORD *result; // eax

  sub_80837B0();
  *(_DWORD *)(dword_83D7610 + 4) = 4;
  v1 = (_DWORD *)dword_83D7610;
  result = sub_807B968(a1);
  *v1 = result;
  return result;
}
// 83D7610: using guessed type int dword_83D7610;

//----- (08084CF0) --------------------------------------------------------
int sub_8084CF0()
{
  int *v0; // ebx
  int result; // eax

  sub_80837B0();
  *(_DWORD *)(dword_83D7610 + 4) = 1;
  v0 = (int *)dword_83D7610;
  result = sub_807B658();
  *v0 = result;
  return result;
}
// 83D7610: using guessed type int dword_83D7610;

//----- (08084D1C) --------------------------------------------------------
int sub_8084D1C()
{
  int v0; // eax
  int v1; // ST14_4

  dword_83D7610 -= 8;
  --dword_83D7618;
  v0 = sub_807C9AC(*(_DWORD *)dword_83D7610);
  v1 = sub_807C084(*(_DWORD *)dword_83D7610, v0);
  return sub_807C4C2(v1, (int *)(dword_83D7610 + 8));
}
// 83D7610: using guessed type int dword_83D7610;
// 83D7618: using guessed type int dword_83D7618;

//----- (08084D6E) --------------------------------------------------------
int __cdecl sub_8084D6E(unsigned int a1)
{
  int v1; // ST14_4

  dword_83D7610 -= 8;
  --dword_83D7618;
  v1 = sub_807C0CC(*(_DWORD *)dword_83D7610, a1);
  return sub_807C4C2(v1, (int *)(dword_83D7610 + 8));
}
// 83D7610: using guessed type int dword_83D7610;
// 83D7618: using guessed type int dword_83D7618;

//----- (08084DB4) --------------------------------------------------------
void __cdecl sub_8084DB4(int a1)
{
  if ( !*(_DWORD *)dword_8394010 )
    *(_DWORD *)dword_8394010 = a1;
  sub_807FA00();
}

//----- (08084DD2) --------------------------------------------------------
void __cdecl sub_8084DD2(int a1, int a2)
{
  *(_DWORD *)dword_8394010 = a1;
  dword_83D5590 = a2;
  sub_807FA00();
}
// 83D5590: using guessed type int dword_83D5590;

//----- (08084DF0) --------------------------------------------------------
void __cdecl sub_8084DF0(int a1)
{
  sub_8079DEE();
  sub_807A298();
  byte_83D7616 = 1;
  sub_8084DB4(a1);
}
// 83D7616: using guessed type char byte_83D7616;

//----- (08084E14) --------------------------------------------------------
void __cdecl sub_8084E14(int a1, int a2)
{
  dword_8394014 = a1 + 1;
  sub_8084DB4(a2);
}
// 8394014: using guessed type int dword_8394014;

//----- (08084E30) --------------------------------------------------------
void __cdecl sub_8084E30(int a1)
{
  dword_8394014 = -1;
  sub_8084DB4(a1);
}
// 8394014: using guessed type int dword_8394014;

//----- (08084E4E) --------------------------------------------------------
signed int __cdecl sub_8084E4E(int a1, int a2, int a3, int a4)
{
  signed int v5; // [esp+14h] [ebp-4h]

  dword_83D761C = 1;
  dword_83D7610 = a4;
  if ( sub_81189D2(a1, a2, a3) )
  {
    if ( dword_83D761C )
    {
      sub_80757AC((_DWORD *)dword_83D7610);
      dword_83D7610 -= 8;
      dword_83D761C = 0;
    }
    v5 = 1;
  }
  else
  {
    dword_83D761C = 0;
    v5 = 0;
  }
  return v5;
}
// 83D7610: using guessed type int dword_83D7610;
// 83D761C: using guessed type int dword_83D761C;

//----- (08084ECA) --------------------------------------------------------
_DWORD *__userpurge sub_8084ECA@<eax>(_DWORD *a1, char *a2, int a3, int a4)
{
  int v4; // edx

  dword_83D7610 = (int)(&dword_83D5580 - 2);
  dword_83D5584 = 0;
  sub_8118BCC(a2, a3, a4);
  dword_83D7618 = 0;
  v4 = dword_83D5584;
  *a1 = dword_83D5580;
  a1[1] = v4;
  return a1;
}
// 83D5580: using guessed type int dword_83D5580;
// 83D5584: using guessed type int dword_83D5584;
// 83D7610: using guessed type int dword_83D7610;
// 83D7618: using guessed type int dword_83D7618;

//----- (08084F28) --------------------------------------------------------
signed int __cdecl sub_8084F28(int a1, int a2)
{
  int v2; // ST14_4
  signed int result; // eax

  v2 = sub_807BBCA(a1, a2);
  dword_83D7618 = 0;
  result = sub_807C628(v2, (signed int *)dword_83D7610);
  dword_83D7610 -= 8;
  return result;
}
// 83D7610: using guessed type int dword_83D7610;
// 83D7618: using guessed type int dword_83D7618;

//----- (08084F6A) --------------------------------------------------------
signed int __cdecl sub_8084F6A(int a1, int a2, int a3)
{
  int v3; // ST14_4

  v3 = sub_807E3A6(a1, a2);
  return sub_8084F28(v3, a3);
}

//----- (08084F9A) --------------------------------------------------------
int sub_8084F9A()
{
  int result; // eax

  sub_8084FD2();
  result = sub_807E04A();
  ++dword_8394018;
  dword_8394018 &= 0xFFFFFFu;
  return result;
}
// 8394018: using guessed type int dword_8394018;

//----- (08084FD2) --------------------------------------------------------
void sub_8084FD2()
{
  sub_8083C5C();
}

//----- (08084FE0) --------------------------------------------------------
int sub_8084FE0()
{
  int result; // eax

  result = Sys_MilliSeconds();
  dword_83D5598 = result;
  return result;
}
// 83D5598: using guessed type int dword_83D5598;

//----- (080850EE) --------------------------------------------------------
int __cdecl sub_80850EE(float a1)
{
  return (signed int)floor(a1 + 0.5);
}

//----- (08085124) --------------------------------------------------------
int __cdecl sub_8085124(_DWORD *a1, _DWORD *a2)
{
  int result; // eax

  *a2 = *a1;
  a2[1] = a1[1];
  result = a1[2];
  a2[2] = result;
  return result;
}

//----- (08085154) --------------------------------------------------------
int __cdecl sub_8085154(int a1)
{
  return *(_DWORD *)(dword_83D7600 - 4 * a1);
}
// 83D7600: using guessed type int dword_83D7600;

//----- (0808516A) --------------------------------------------------------
int __cdecl sub_808516A(unsigned __int8 *a1)
{
  return sub_8085154(*a1);
}

//----- (08085180) --------------------------------------------------------
int __cdecl sub_8085180(int **a1)
{
  int v1; // ST00_4

  v1 = **a1;
  ++*a1;
  return v1;
}

//----- (080851A2) --------------------------------------------------------
int __cdecl sub_80851A2(int *a1)
{
  int v1; // ST00_4

  v1 = *a1;
  *a1 += 12;
  return v1;
}

//----- (080851C2) --------------------------------------------------------
int __cdecl sub_80851C2(int *a1, int a2)
{
  int v2; // ST00_4

  v2 = *a1;
  *a1 += 4 * a2;
  return v2;
}

//----- (080851E6) --------------------------------------------------------
int __cdecl sub_80851E6(__int16 **a1)
{
  return (unsigned __int16)sub_808524C(a1);
}

//----- (080851FC) --------------------------------------------------------
int __cdecl sub_80851FC(int **a1)
{
  return sub_8085180(a1);
}

//----- (08085210) --------------------------------------------------------
long double __cdecl sub_8085210(float **a1)
{
  float v1; // ST04_4

  v1 = **a1;
  ++*a1;
  return v1;
}

//----- (08085238) --------------------------------------------------------
int __cdecl sub_8085238(int **a1)
{
  return sub_8085180(a1);
}

//----- (0808524C) --------------------------------------------------------
int __cdecl sub_808524C(__int16 **a1)
{
  __int16 v1; // ST02_2

  v1 = **a1;
  ++*a1;
  return v1;
}

//----- (08085274) --------------------------------------------------------
int __cdecl sub_8085274(int a1)
{
  return sub_80793F4(a1, (unsigned __int8)byte_83DB9C0);
}
// 83DB9C0: using guessed type char byte_83DB9C0;

//----- (080852B8) --------------------------------------------------------
int __cdecl sub_80852B8(void *s2, int a2)
{
  int result; // eax

  result = sub_8078DEC(s2, 0, a2 + 1);
  dword_89BEB2C = result;
  return result;
}
// 89BEB2C: using guessed type int dword_89BEB2C;

//----- (080852E8) --------------------------------------------------------
signed int __cdecl sub_80852E8(char *a1, int a2)
{
  char *v2; // eax
  signed int v4; // [esp+18h] [ebp-2020h]
  char s; // [esp+20h] [ebp-2018h]
  char *v7; // [esp+202Ch] [ebp-Ch]
  char *v8; // [esp+2040h] [ebp+8h]
  int v9; // [esp+2044h] [ebp+Ch]

  if ( a2 <= 0x1FFF )
  {
    v7 = &s;
    while ( 1 )
    {
      while ( 1 )
      {
        if ( !a2 )
        {
LABEL_19:
          *v7 = 0;
          dword_89BEB2C = sub_8079290(&s, (unsigned __int8)byte_83DB9C0);
          return 1;
        }
        if ( *a1 == 92 )
          break;
        --a2;
        v2 = a1++;
        *v7++ = *v2;
      }
      v9 = a2 - 1;
      if ( !v9 )
        goto LABEL_19;
      v8 = a1 + 1;
      v4 = *v8;
      if ( v4 == 114 )
      {
        *v7++ = 13;
        goto LABEL_18;
      }
      if ( v4 > 114 )
      {
        if ( v4 == 116 )
        {
          *v7++ = 9;
          goto LABEL_18;
        }
      }
      else if ( v4 == 110 )
      {
        *v7++ = 10;
        goto LABEL_18;
      }
      *v7++ = *v8;
LABEL_18:
      a2 = v9 - 1;
      a1 = v8 + 1;
    }
  }
  sub_8077FFE(dword_83DB9BC, "max string length exceeded: \"%s\"", a1);
  return 0;
}
// 83DB9C0: using guessed type char byte_83DB9C0;
// 89BEB2C: using guessed type int dword_89BEB2C;

//----- (08085425) --------------------------------------------------------
int __cdecl sub_8085425(char *s)
{
  return sscanf(s, "%d", &dword_89BEB2C);
}
// 89BEB2C: using guessed type int dword_89BEB2C;

//----- (08085448) --------------------------------------------------------
int __cdecl sub_8085448(char *s)
{
  return sscanf(s, "%f", &dword_89BEB2C);
}
// 89BEB2C: using guessed type int dword_89BEB2C;

//----- (0808546B) --------------------------------------------------------
signed int sub_808546B()
{
  signed int result; // eax
  signed int v1; // [esp+1Ch] [ebp-2Ch]
  signed int v2; // [esp+20h] [ebp-28h]
  signed int v3; // [esp+24h] [ebp-24h]
  unsigned __int8 v4; // [esp+2Bh] [ebp-1Dh]
  int v5; // [esp+2Ch] [ebp-1Ch]
  char *v6; // [esp+30h] [ebp-18h]
  char *v7; // [esp+34h] [ebp-14h]
  signed int v8; // [esp+38h] [ebp-10h]
  int v10; // [esp+40h] [ebp-8h]
  int v11; // [esp+44h] [ebp-4h]

  if ( dword_815D548 )
  {
    dword_815D548 = 0;
    if ( !dword_83DB9A8 )
      dword_83DB9A8 = 1;
    if ( !stream )
      stream = (FILE *)stdin;
    if ( !dword_83DB9B0 )
      dword_83DB9B0 = stdout;
    if ( !dword_83DB9A0 )
      dword_83DB9A0 = (int)sub_8086E67(stream, 0x4000);
    sub_8086E2A();
  }
LABEL_11:
  v7 = (char *)dword_83DB9A4;
  *(_BYTE *)dword_83DB9A4 = byte_83DB9C8;
  v6 = v7;
  v8 = dword_83DB9A8;
  do
  {
LABEL_12:
    v4 = byte_81412A0[4 * (unsigned __int8)*v7];
    if ( word_81410A0[v8] )
    {
      dword_83DB9D4 = v8;
      dword_83DB9D8 = (int)v7;
    }
    while ( word_8141FC0[v4 + word_81417A0[v8]] != v8 )
    {
      v8 = word_81419C0[v8];
      if ( v8 > 255 )
        v4 = byte_81416A0[4 * v4];
    }
    v8 = word_8141BE0[v4 + word_81417A0[v8]];
    ++v7;
  }
  while ( word_81417A0[v8] != 431 );
  while ( 1 )
  {
    v5 = word_81410A0[v8];
    if ( !word_81410A0[v8] )
    {
      v7 = (char *)dword_83DB9D8;
      v5 = word_81410A0[dword_83DB9D4];
    }
    ptr = v6;
    size = v7 - v6;
    byte_83DB9C8 = *v7;
    *v7 = 0;
    dword_83DB9A4 = (int)v7;
LABEL_21:
    switch ( v5 )
    {
      case 0:
        *v7 = byte_83DB9C8;
        v7 = (char *)dword_83DB9D8;
        v8 = dword_83DB9D4;
        continue;
      case 1:
        dword_89BEB30 = dword_83DB9B8;
        dword_83DB9BC = dword_83DB9B8;
        dword_83DB9B8 += size;
        goto LABEL_11;
      case 2:
        dword_89BEB30 = dword_83DB9B8;
        dword_83DB9BC = dword_83DB9B8;
        dword_83DB9B8 += size;
        dword_83DB9A8 = 3;
        goto LABEL_11;
      case 3:
        dword_89BEB30 = dword_83DB9B8;
        dword_83DB9BC = dword_83DB9B8;
        dword_83DB9B8 += size;
        goto LABEL_11;
      case 4:
        dword_89BEB30 = dword_83DB9B8;
        dword_83DB9BC = dword_83DB9B8;
        dword_83DB9B8 += size;
        goto LABEL_11;
      case 5:
        dword_89BEB30 = dword_83DB9B8;
        dword_83DB9BC = dword_83DB9B8;
        dword_83DB9B8 += size;
        goto LABEL_11;
      case 6:
        dword_89BEB30 = dword_83DB9B8;
        dword_83DB9BC = dword_83DB9B8;
        dword_83DB9B8 += size;
        dword_83DB9A8 = 5;
        goto LABEL_11;
      case 7:
        dword_89BEB30 = dword_83DB9B8;
        dword_83DB9BC = dword_83DB9B8;
        dword_83DB9B8 += size;
        if ( sub_80852E8(ptr + 1, size - 2) )
          v3 = 259;
        else
          v3 = 257;
        return v3;
      case 8:
        dword_89BEB30 = dword_83DB9B8;
        dword_83DB9BC = dword_83DB9B8;
        dword_83DB9B8 += size;
        if ( sub_80852E8(ptr + 2, size - 3) )
          v2 = 260;
        else
          v2 = 257;
        return v2;
      case 9:
        dword_89BEB30 = dword_83DB9B8;
        dword_83DB9BC = dword_83DB9B8;
        dword_83DB9B8 += size;
        return 261;
      case 10:
        dword_89BEB30 = dword_83DB9B8;
        dword_83DB9BC = dword_83DB9B8;
        dword_83DB9B8 += size;
        return 262;
      case 11:
        dword_89BEB30 = dword_83DB9B8;
        dword_83DB9BC = dword_83DB9B8;
        dword_83DB9B8 += size;
        return 263;
      case 12:
        dword_89BEB30 = dword_83DB9B8;
        dword_83DB9BC = dword_83DB9B8;
        dword_83DB9B8 += size;
        return 264;
      case 13:
        dword_89BEB30 = dword_83DB9B8;
        dword_83DB9BC = dword_83DB9B8;
        dword_83DB9B8 += size;
        return 265;
      case 14:
        dword_89BEB30 = dword_83DB9B8;
        dword_83DB9BC = dword_83DB9B8;
        dword_83DB9B8 += size;
        return 266;
      case 15:
        dword_89BEB30 = dword_83DB9B8;
        dword_83DB9BC = dword_83DB9B8;
        dword_83DB9B8 += size;
        return 267;
      case 16:
        dword_89BEB30 = dword_83DB9B8;
        dword_83DB9BC = dword_83DB9B8;
        dword_83DB9B8 += size;
        return 268;
      case 17:
        dword_89BEB30 = dword_83DB9B8;
        dword_83DB9BC = dword_83DB9B8;
        dword_83DB9B8 += size;
        return 269;
      case 18:
        dword_89BEB30 = dword_83DB9B8;
        dword_83DB9BC = dword_83DB9B8;
        dword_83DB9B8 += size;
        return 270;
      case 19:
        dword_89BEB30 = dword_83DB9B8;
        dword_83DB9BC = dword_83DB9B8;
        dword_83DB9B8 += size;
        return 271;
      case 20:
        dword_89BEB30 = dword_83DB9B8;
        dword_83DB9BC = dword_83DB9B8;
        dword_83DB9B8 += size;
        return 272;
      case 21:
        dword_89BEB30 = dword_83DB9B8;
        dword_83DB9BC = dword_83DB9B8;
        dword_83DB9B8 += size;
        return 273;
      case 22:
        dword_89BEB30 = dword_83DB9B8;
        dword_83DB9BC = dword_83DB9B8;
        dword_83DB9B8 += size;
        return 274;
      case 23:
        dword_89BEB30 = dword_83DB9B8;
        dword_83DB9BC = dword_83DB9B8;
        dword_83DB9B8 += size;
        return 275;
      case 24:
        dword_89BEB30 = dword_83DB9B8;
        dword_83DB9BC = dword_83DB9B8;
        dword_83DB9B8 += size;
        return 276;
      case 25:
        dword_89BEB30 = dword_83DB9B8;
        dword_83DB9BC = dword_83DB9B8;
        dword_83DB9B8 += size;
        return 277;
      case 26:
        dword_89BEB30 = dword_83DB9B8;
        dword_83DB9BC = dword_83DB9B8;
        dword_83DB9B8 += size;
        return 278;
      case 27:
        dword_89BEB30 = dword_83DB9B8;
        dword_83DB9BC = dword_83DB9B8;
        dword_83DB9B8 += size;
        return 279;
      case 28:
        dword_89BEB30 = dword_83DB9B8;
        dword_83DB9BC = dword_83DB9B8;
        dword_83DB9B8 += size;
        return 280;
      case 29:
        dword_89BEB30 = dword_83DB9B8;
        dword_83DB9BC = dword_83DB9B8;
        dword_83DB9B8 += size;
        return 281;
      case 30:
        dword_89BEB30 = dword_83DB9B8;
        dword_83DB9BC = dword_83DB9B8;
        dword_83DB9B8 += size;
        return 282;
      case 31:
        dword_89BEB30 = dword_83DB9B8;
        dword_83DB9BC = dword_83DB9B8;
        dword_83DB9B8 += size;
        return 283;
      case 32:
        dword_89BEB30 = dword_83DB9B8;
        dword_83DB9BC = dword_83DB9B8;
        dword_83DB9B8 += size;
        return 284;
      case 33:
        dword_89BEB30 = dword_83DB9B8;
        dword_83DB9BC = dword_83DB9B8;
        dword_83DB9B8 += size;
        return 285;
      case 34:
        dword_89BEB30 = dword_83DB9B8;
        dword_83DB9BC = dword_83DB9B8;
        dword_83DB9B8 += size;
        return 286;
      case 35:
        dword_89BEB30 = dword_83DB9B8;
        dword_83DB9BC = dword_83DB9B8;
        dword_83DB9B8 += size;
        sub_8085425(ptr);
        return 287;
      case 36:
        dword_89BEB30 = dword_83DB9B8;
        dword_83DB9BC = dword_83DB9B8;
        dword_83DB9B8 += size;
        sub_8085448(ptr);
        return 288;
      case 37:
        dword_89BEB30 = dword_83DB9B8;
        dword_83DB9BC = dword_83DB9B8;
        dword_83DB9B8 += size;
        return 290;
      case 38:
        dword_89BEB30 = dword_83DB9B8;
        dword_83DB9BC = dword_83DB9B8;
        dword_83DB9B8 += size;
        return 289;
      case 39:
        dword_89BEB30 = dword_83DB9B8;
        dword_83DB9BC = dword_83DB9B8;
        dword_83DB9B8 += size;
        return 294;
      case 40:
        dword_89BEB30 = dword_83DB9B8;
        dword_83DB9BC = dword_83DB9B8;
        dword_83DB9B8 += size;
        return 291;
      case 41:
        dword_89BEB30 = dword_83DB9B8;
        dword_83DB9BC = dword_83DB9B8;
        dword_83DB9B8 += size;
        return 293;
      case 42:
        dword_89BEB30 = dword_83DB9B8;
        dword_83DB9BC = dword_83DB9B8;
        dword_83DB9B8 += size;
        return 292;
      case 43:
        dword_89BEB30 = dword_83DB9B8;
        dword_83DB9BC = dword_83DB9B8;
        dword_83DB9B8 += size;
        return 295;
      case 44:
        dword_89BEB30 = dword_83DB9B8;
        dword_83DB9BC = dword_83DB9B8;
        dword_83DB9B8 += size;
        return 296;
      case 45:
        dword_89BEB30 = dword_83DB9B8;
        dword_83DB9BC = dword_83DB9B8;
        dword_83DB9B8 += size;
        return 297;
      case 46:
        dword_89BEB30 = dword_83DB9B8;
        dword_83DB9BC = dword_83DB9B8;
        dword_83DB9B8 += size;
        return 298;
      case 47:
        dword_89BEB30 = dword_83DB9B8;
        dword_83DB9BC = dword_83DB9B8;
        dword_83DB9B8 += size;
        return 299;
      case 48:
        dword_89BEB30 = dword_83DB9B8;
        dword_83DB9BC = dword_83DB9B8;
        dword_83DB9B8 += size;
        return 300;
      case 49:
        dword_89BEB30 = dword_83DB9B8;
        dword_83DB9BC = dword_83DB9B8;
        dword_83DB9B8 += size;
        return 301;
      case 50:
        dword_89BEB30 = dword_83DB9B8;
        dword_83DB9BC = dword_83DB9B8;
        dword_83DB9B8 += size;
        return 302;
      case 51:
        dword_89BEB30 = dword_83DB9B8;
        dword_83DB9BC = dword_83DB9B8;
        dword_83DB9B8 += size;
        return 303;
      case 52:
        dword_89BEB30 = dword_83DB9B8;
        dword_83DB9BC = dword_83DB9B8;
        dword_83DB9B8 += size;
        return 304;
      case 53:
        dword_89BEB30 = dword_83DB9B8;
        dword_83DB9BC = dword_83DB9B8;
        dword_83DB9B8 += size;
        return 305;
      case 54:
        dword_89BEB30 = dword_83DB9B8;
        dword_83DB9BC = dword_83DB9B8;
        dword_83DB9B8 += size;
        return 306;
      case 55:
        dword_89BEB30 = dword_83DB9B8;
        dword_83DB9BC = dword_83DB9B8;
        dword_83DB9B8 += size;
        return 307;
      case 56:
        dword_89BEB30 = dword_83DB9B8;
        dword_83DB9BC = dword_83DB9B8;
        dword_83DB9B8 += size;
        return 308;
      case 57:
        dword_89BEB30 = dword_83DB9B8;
        dword_83DB9BC = dword_83DB9B8;
        dword_83DB9B8 += size;
        return 309;
      case 58:
        dword_89BEB30 = dword_83DB9B8;
        dword_83DB9BC = dword_83DB9B8;
        dword_83DB9B8 += size;
        return 310;
      case 59:
        dword_89BEB30 = dword_83DB9B8;
        dword_83DB9BC = dword_83DB9B8;
        dword_83DB9B8 += size;
        return 311;
      case 60:
        dword_89BEB30 = dword_83DB9B8;
        dword_83DB9BC = dword_83DB9B8;
        dword_83DB9B8 += size;
        return 312;
      case 61:
        dword_89BEB30 = dword_83DB9B8;
        dword_83DB9BC = dword_83DB9B8;
        dword_83DB9B8 += size;
        return 313;
      case 62:
        dword_89BEB30 = dword_83DB9B8;
        dword_83DB9BC = dword_83DB9B8;
        dword_83DB9B8 += size;
        return 314;
      case 63:
        dword_89BEB30 = dword_83DB9B8;
        dword_83DB9BC = dword_83DB9B8;
        dword_83DB9B8 += size;
        return 315;
      case 64:
        dword_89BEB30 = dword_83DB9B8;
        dword_83DB9BC = dword_83DB9B8;
        dword_83DB9B8 += size;
        return 316;
      case 65:
        dword_89BEB30 = dword_83DB9B8;
        dword_83DB9BC = dword_83DB9B8;
        dword_83DB9B8 += size;
        return 317;
      case 66:
        dword_89BEB30 = dword_83DB9B8;
        dword_83DB9BC = dword_83DB9B8;
        dword_83DB9B8 += size;
        return 318;
      case 67:
        dword_89BEB30 = dword_83DB9B8;
        dword_83DB9BC = dword_83DB9B8;
        dword_83DB9B8 += size;
        return 319;
      case 68:
        dword_89BEB30 = dword_83DB9B8;
        dword_83DB9BC = dword_83DB9B8;
        dword_83DB9B8 += size;
        return 320;
      case 69:
        dword_89BEB30 = dword_83DB9B8;
        dword_83DB9BC = dword_83DB9B8;
        dword_83DB9B8 += size;
        return 321;
      case 70:
        dword_89BEB30 = dword_83DB9B8;
        dword_83DB9BC = dword_83DB9B8;
        dword_83DB9B8 += size;
        return 322;
      case 71:
        dword_89BEB30 = dword_83DB9B8;
        dword_83DB9BC = dword_83DB9B8;
        dword_83DB9B8 += size;
        return 323;
      case 72:
        dword_89BEB30 = dword_83DB9B8;
        dword_83DB9BC = dword_83DB9B8;
        dword_83DB9B8 += size;
        return 325;
      case 73:
        dword_89BEB30 = dword_83DB9B8;
        dword_83DB9BC = dword_83DB9B8;
        dword_83DB9B8 += size;
        return 326;
      case 74:
        dword_89BEB30 = dword_83DB9B8;
        dword_83DB9BC = dword_83DB9B8;
        dword_83DB9B8 += size;
        return 327;
      case 75:
        dword_89BEB30 = dword_83DB9B8;
        dword_83DB9BC = dword_83DB9B8;
        dword_83DB9B8 += size;
        return 328;
      case 76:
        dword_89BEB30 = dword_83DB9B8;
        dword_83DB9BC = dword_83DB9B8;
        dword_83DB9B8 += size;
        return 329;
      case 77:
        dword_89BEB30 = dword_83DB9B8;
        dword_83DB9BC = dword_83DB9B8;
        dword_83DB9B8 += size;
        return 330;
      case 78:
        dword_89BEB30 = dword_83DB9B8;
        dword_83DB9BC = dword_83DB9B8;
        dword_83DB9B8 += size;
        return 331;
      case 79:
        dword_89BEB30 = dword_83DB9B8;
        dword_83DB9BC = dword_83DB9B8;
        dword_83DB9B8 += size;
        return 332;
      case 80:
        dword_89BEB30 = dword_83DB9B8;
        dword_83DB9BC = dword_83DB9B8;
        dword_83DB9B8 += size;
        return 333;
      case 81:
        dword_89BEB30 = dword_83DB9B8;
        dword_83DB9BC = dword_83DB9B8;
        dword_83DB9B8 += size;
        return 334;
      case 82:
        dword_89BEB30 = dword_83DB9B8;
        dword_83DB9BC = dword_83DB9B8;
        dword_83DB9B8 += size;
        return 335;
      case 83:
        dword_89BEB30 = dword_83DB9B8;
        dword_83DB9BC = dword_83DB9B8;
        dword_83DB9B8 += size;
        return 336;
      case 84:
        dword_89BEB30 = dword_83DB9B8;
        dword_83DB9BC = dword_83DB9B8;
        dword_83DB9B8 += size;
        return 337;
      case 85:
        dword_89BEB30 = dword_83DB9B8;
        dword_83DB9BC = dword_83DB9B8;
        dword_83DB9B8 += size;
        return 338;
      case 86:
        dword_89BEB30 = dword_83DB9B8;
        dword_83DB9BC = dword_83DB9B8;
        dword_83DB9B8 += size;
        return 339;
      case 87:
        dword_89BEB30 = dword_83DB9B8;
        dword_83DB9BC = dword_83DB9B8;
        dword_83DB9B8 += size;
        return 340;
      case 88:
        dword_89BEB30 = dword_83DB9B8;
        dword_83DB9BC = dword_83DB9B8;
        dword_83DB9B8 += size;
        return 341;
      case 89:
        dword_89BEB30 = dword_83DB9B8;
        dword_83DB9BC = dword_83DB9B8;
        dword_83DB9B8 += size;
        return 342;
      case 90:
        dword_89BEB30 = dword_83DB9B8;
        dword_83DB9BC = dword_83DB9B8;
        dword_83DB9B8 += size;
        sub_80852B8(ptr, size);
        return 258;
      case 91:
        dword_89BEB30 = dword_83DB9B8;
        dword_83DB9BC = dword_83DB9B8;
        dword_83DB9B8 += size;
        sub_80852B8(ptr, size);
        return 324;
      case 92:
        dword_89BEB30 = dword_83DB9B8;
        dword_83DB9BC = dword_83DB9B8;
        dword_83DB9B8 += size;
        sub_8077FFE(dword_83DB9BC, "bad token '%s'", ptr);
        return 257;
      case 93:
        dword_89BEB30 = dword_83DB9B8;
        dword_83DB9BC = dword_83DB9B8;
        dword_83DB9B8 += size;
        fwrite(ptr, size, 1u, dword_83DB9B0);
        goto LABEL_11;
      case 94:
        v11 = v7 - ptr - 1;
        *v7 = byte_83DB9C8;
        if ( !*(_DWORD *)(dword_83DB9A0 + 36) )
        {
          dword_83DB9CC = *(_DWORD *)(dword_83DB9A0 + 16);
          *(_DWORD *)dword_83DB9A0 = stream;
          *(_DWORD *)(dword_83DB9A0 + 36) = 1;
        }
        if ( dword_83DB9A4 <= (unsigned int)(dword_83DB9CC + *(_DWORD *)(dword_83DB9A0 + 4)) )
        {
          dword_83DB9A4 = (int)&ptr[v11];
          v8 = sub_8086AF2();
          v10 = sub_8086BCA(v8);
          v6 = ptr;
          if ( v10 )
          {
            v7 = (char *)++dword_83DB9A4;
            v8 = v10;
            goto LABEL_12;
          }
          v7 = (char *)dword_83DB9A4;
          continue;
        }
        v1 = sub_8086881();
        if ( v1 == 1 )
        {
          dword_83DB9D0 = 0;
          if ( sub_80872FC() )
          {
            dword_83DB9A4 = (int)ptr;
            v5 = (dword_83DB9A8 - 1) / 2 + 95;
            goto LABEL_21;
          }
          if ( !dword_83DB9D0 )
            sub_8086D87(stream);
          goto LABEL_11;
        }
        if ( v1 <= 1 )
        {
          if ( v1 )
            goto LABEL_11;
          dword_83DB9A4 = (int)&ptr[v11];
          v8 = sub_8086AF2();
          v7 = (char *)dword_83DB9A4;
          v6 = ptr;
          goto LABEL_12;
        }
        if ( v1 != 2 )
          goto LABEL_11;
        dword_83DB9A4 = dword_83DB9CC + *(_DWORD *)(dword_83DB9A0 + 4);
        v8 = sub_8086AF2();
        v7 = (char *)dword_83DB9A4;
        v6 = ptr;
        break;
      case 95:
      case 96:
      case 97:
        return 0;
      default:
        sub_8087193((int)"fatal flex scanner internal error--no action found");
        return result;
    }
  }
}
// 815D548: using guessed type int dword_815D548;
// 8185A68: using guessed type int stdin;
// 83DB9A4: using guessed type int dword_83DB9A4;
// 83DB9A8: using guessed type int dword_83DB9A8;
// 83DB9B8: using guessed type int dword_83DB9B8;
// 83DB9C8: using guessed type char byte_83DB9C8;
// 83DB9CC: using guessed type int dword_83DB9CC;
// 83DB9D0: using guessed type int dword_83DB9D0;
// 83DB9D4: using guessed type int dword_83DB9D4;
// 83DB9D8: using guessed type int dword_83DB9D8;
// 89BEB30: using guessed type int dword_89BEB30;

//----- (08086881) --------------------------------------------------------
signed int sub_8086881()
{
  char v0; // dl
  int v1; // eax
  int i; // [esp+Ch] [ebp-2Ch]
  int v4; // [esp+10h] [ebp-28h]
  char *v5; // [esp+14h] [ebp-24h]
  _BYTE *v6; // [esp+18h] [ebp-20h]
  signed int v7; // [esp+1Ch] [ebp-1Ch]
  int v8; // [esp+24h] [ebp-14h]
  int v9; // [esp+28h] [ebp-10h]
  int j; // [esp+2Ch] [ebp-Ch]
  signed int v11; // [esp+30h] [ebp-8h]

  v6 = *(_BYTE **)(dword_83DB9A0 + 4);
  v5 = ptr;
  if ( dword_83DB9A4 > (unsigned int)(*(_DWORD *)(dword_83DB9A0 + 4) + dword_83DB9CC + 1) )
    sub_8087193((int)"fatal flex scanner internal error--end of buffer missed");
  if ( *(_DWORD *)(dword_83DB9A0 + 32) )
  {
    v4 = dword_83DB9A4 - (_DWORD)ptr - 1;
    for ( i = 0; i < v4; ++i )
    {
      v0 = *v5++;
      *v6++ = v0;
    }
    if ( *(_DWORD *)(dword_83DB9A0 + 36) == 2 )
    {
      dword_83DB9CC = 0;
      *(_DWORD *)(dword_83DB9A0 + 16) = 0;
    }
    else
    {
      for ( j = *(_DWORD *)(dword_83DB9A0 + 12) - v4 - 1; j <= 0; j = *(_DWORD *)(dword_83DB9A0 + 12) - v4 - 1 )
      {
        v9 = dword_83DB9A0;
        v8 = dword_83DB9A4 - *(_DWORD *)(dword_83DB9A0 + 4);
        if ( *(_DWORD *)(dword_83DB9A0 + 20) )
        {
          if ( 2 * *(_DWORD *)(dword_83DB9A0 + 12) > 0 )
            v1 = 2 * *(_DWORD *)(dword_83DB9A0 + 12);
          else
            v1 = *(_DWORD *)(dword_83DB9A0 + 12) + (*(_DWORD *)(dword_83DB9A0 + 12) >> 3);
          *(_DWORD *)(dword_83DB9A0 + 12) = v1;
          *(_DWORD *)(v9 + 4) = sub_80871D4(*(void **)(v9 + 4), *(_DWORD *)(v9 + 12) + 2);
        }
        else
        {
          *(_DWORD *)(dword_83DB9A0 + 4) = 0;
        }
        if ( !*(_DWORD *)(v9 + 4) )
          sub_8087193((int)"fatal error - scanner input buffer overflow");
        dword_83DB9A4 = *(_DWORD *)(v9 + 4) + v8;
      }
      if ( j > 0x2000 )
        j = 0x2000;
      dword_83DB9CC = sub_8075BBE(*(_DWORD *)(dword_83DB9A0 + 4) + v4, j);
      *(_DWORD *)(dword_83DB9A0 + 16) = dword_83DB9CC;
    }
    if ( dword_83DB9CC )
    {
      v11 = 0;
    }
    else if ( v4 )
    {
      v11 = 2;
      *(_DWORD *)(dword_83DB9A0 + 36) = 2;
    }
    else
    {
      v11 = 1;
      sub_8086D87(stream);
    }
    dword_83DB9CC += v4;
    *(_BYTE *)(*(_DWORD *)(dword_83DB9A0 + 4) + dword_83DB9CC) = 0;
    *(_BYTE *)(*(_DWORD *)(dword_83DB9A0 + 4) + dword_83DB9CC + 1) = 0;
    ptr = *(char **)(dword_83DB9A0 + 4);
    v7 = v11;
  }
  else if ( dword_83DB9A4 - (_DWORD)ptr == 1 )
  {
    v7 = 1;
  }
  else
  {
    v7 = 2;
  }
  return v7;
}
// 83DB9A4: using guessed type int dword_83DB9A4;
// 83DB9CC: using guessed type int dword_83DB9CC;

//----- (08086AF2) --------------------------------------------------------
signed int sub_8086AF2()
{
  unsigned __int8 v1; // [esp+3h] [ebp-9h]
  char *i; // [esp+4h] [ebp-8h]
  signed int v3; // [esp+8h] [ebp-4h]

  v3 = dword_83DB9A8;
  for ( i = ptr; (unsigned int)i < dword_83DB9A4; ++i )
  {
    if ( *i )
      v1 = byte_81412A0[4 * (unsigned __int8)*i];
    else
      v1 = 1;
    if ( word_81410A0[v3] )
    {
      dword_83DB9D4 = v3;
      dword_83DB9D8 = (int)i;
    }
    while ( word_8141FC0[v1 + word_81417A0[v3]] != v3 )
    {
      v3 = word_81419C0[v3];
      if ( v3 > 255 )
        v1 = byte_81416A0[4 * v1];
    }
    v3 = word_8141BE0[v1 + word_81417A0[v3]];
  }
  return v3;
}
// 83DB9A4: using guessed type int dword_83DB9A4;
// 83DB9A8: using guessed type int dword_83DB9A8;
// 83DB9D4: using guessed type int dword_83DB9D4;
// 83DB9D8: using guessed type int dword_83DB9D8;

//----- (08086BCA) --------------------------------------------------------
int __cdecl sub_8086BCA(signed int a1)
{
  int v2; // [esp+0h] [ebp-Ch]
  unsigned __int8 v3; // [esp+7h] [ebp-5h]
  int v4; // [esp+14h] [ebp+8h]

  v3 = 1;
  if ( word_81410A0[a1] )
  {
    dword_83DB9D4 = a1;
    dword_83DB9D8 = dword_83DB9A4;
  }
  while ( word_8141FC0[v3 + word_81417A0[a1]] != a1 )
  {
    a1 = word_81419C0[a1];
    if ( a1 > 255 )
      v3 = byte_81416A0[4 * v3];
  }
  v4 = word_8141BE0[v3 + word_81417A0[a1]];
  if ( v4 == 255 )
    v2 = 0;
  else
    v2 = v4;
  return v2;
}
// 83DB9A4: using guessed type int dword_83DB9A4;
// 83DB9D4: using guessed type int dword_83DB9D4;
// 83DB9D8: using guessed type int dword_83DB9D8;

//----- (08086C86) --------------------------------------------------------
int sub_8086C86()
{
  int v0; // ST14_4
  signed int v2; // [esp+8h] [ebp-10h]
  int v4; // [esp+10h] [ebp-8h]

  *(_BYTE *)dword_83DB9A4 = byte_83DB9C8;
  if ( *(_BYTE *)dword_83DB9A4 )
    goto LABEL_16;
  if ( dword_83DB9A4 < (unsigned int)(dword_83DB9CC + *(_DWORD *)(dword_83DB9A0 + 4)) )
  {
    *(_BYTE *)dword_83DB9A4 = 0;
    goto LABEL_16;
  }
  v4 = dword_83DB9A4++ - (_DWORD)ptr;
  v2 = sub_8086881();
  if ( v2 != 1 )
  {
    if ( v2 <= 1 )
    {
      if ( !v2 )
        dword_83DB9A4 = (int)&ptr[v4];
      goto LABEL_16;
    }
    if ( v2 != 2 )
    {
LABEL_16:
      v0 = *(unsigned __int8 *)dword_83DB9A4;
      *(_BYTE *)dword_83DB9A4++ = 0;
      byte_83DB9C8 = *(_BYTE *)dword_83DB9A4;
      return v0;
    }
    sub_8086D87(stream);
  }
  if ( sub_80872FC() )
    return -1;
  if ( !dword_83DB9D0 )
    sub_8086D87(stream);
  return sub_8086C86();
}
// 83DB9A4: using guessed type int dword_83DB9A4;
// 83DB9C8: using guessed type char byte_83DB9C8;
// 83DB9CC: using guessed type int dword_83DB9CC;
// 83DB9D0: using guessed type int dword_83DB9D0;

//----- (08086D87) --------------------------------------------------------
int __cdecl sub_8086D87(FILE *stream)
{
  if ( !dword_83DB9A0 )
    dword_83DB9A0 = (int)sub_8086E67(::stream, 0x4000);
  sub_8086F30(dword_83DB9A0, stream);
  return sub_8086E2A();
}

//----- (08086DCB) --------------------------------------------------------
int __cdecl sub_8086DCB(int a1)
{
  int result; // eax

  result = dword_83DB9A0;
  if ( dword_83DB9A0 != a1 )
  {
    if ( dword_83DB9A0 )
    {
      *(_BYTE *)dword_83DB9A4 = byte_83DB9C8;
      *(_DWORD *)(dword_83DB9A0 + 8) = dword_83DB9A4;
      *(_DWORD *)(dword_83DB9A0 + 16) = dword_83DB9CC;
    }
    dword_83DB9A0 = a1;
    result = sub_8086E2A();
    dword_83DB9D0 = 1;
  }
  return result;
}
// 83DB9A4: using guessed type int dword_83DB9A4;
// 83DB9C8: using guessed type char byte_83DB9C8;
// 83DB9CC: using guessed type int dword_83DB9CC;
// 83DB9D0: using guessed type int dword_83DB9D0;

//----- (08086E2A) --------------------------------------------------------
int sub_8086E2A()
{
  char *v0; // eax
  int result; // eax

  dword_83DB9CC = *(_DWORD *)(dword_83DB9A0 + 16);
  v0 = *(char **)(dword_83DB9A0 + 8);
  dword_83DB9A4 = (int)v0;
  ptr = v0;
  stream = *(FILE **)dword_83DB9A0;
  result = (unsigned __int8)*v0;
  byte_83DB9C8 = result;
  return result;
}
// 83DB9A4: using guessed type int dword_83DB9A4;
// 83DB9C8: using guessed type char byte_83DB9C8;
// 83DB9CC: using guessed type int dword_83DB9CC;

//----- (08086E67) --------------------------------------------------------
_DWORD *__cdecl sub_8086E67(FILE *stream, int a2)
{
  _DWORD *v3; // [esp+10h] [ebp-8h]

  v3 = sub_80871C1(0x28u);
  if ( !v3 )
    sub_8087193((int)"out of dynamic memory in yy_create_buffer()");
  v3[3] = a2;
  v3[1] = sub_80871C1(v3[3] + 2);
  if ( !v3[1] )
    sub_8087193((int)"out of dynamic memory in yy_create_buffer()");
  v3[5] = 1;
  sub_8086F30((int)v3, stream);
  return v3;
}

//----- (08086F30) --------------------------------------------------------
int __cdecl sub_8086F30(int a1, FILE *stream)
{
  int v2; // eax
  int result; // eax
  signed int v4; // [esp+10h] [ebp-8h]

  sub_8086F8F(a1);
  *(_DWORD *)a1 = stream;
  *(_DWORD *)(a1 + 32) = 1;
  v4 = 0;
  if ( stream )
  {
    v2 = fileno(stream);
    if ( isatty(v2) > 0 )
      v4 = 1;
  }
  result = v4;
  *(_DWORD *)(a1 + 24) = v4;
  return result;
}

//----- (08086F8F) --------------------------------------------------------
int __cdecl sub_8086F8F(int a1)
{
  int result; // eax

  if ( a1 )
  {
    *(_DWORD *)(a1 + 16) = 0;
    **(_BYTE **)(a1 + 4) = 0;
    *(_BYTE *)(*(_DWORD *)(a1 + 4) + 1) = 0;
    *(_DWORD *)(a1 + 8) = *(_DWORD *)(a1 + 4);
    *(_DWORD *)(a1 + 28) = 1;
    *(_DWORD *)(a1 + 36) = 0;
    result = a1;
    if ( a1 == dword_83DB9A0 )
      result = sub_8086E2A();
  }
  return result;
}

//----- (08086FEC) --------------------------------------------------------
_DWORD *__cdecl sub_8086FEC(int a1, unsigned int a2)
{
  _DWORD *v4; // [esp+14h] [ebp-4h]

  if ( a2 <= 1 || *(_BYTE *)(a1 + a2 - 2) || *(_BYTE *)(a1 + a2 - 1) )
    return 0;
  v4 = sub_80871C1(0x28u);
  if ( !v4 )
    sub_8087193((int)"out of dynamic memory in yy_scan_buffer()");
  v4[3] = a2 - 2;
  v4[1] = a1;
  v4[2] = a1;
  v4[5] = 0;
  *v4 = 0;
  v4[4] = v4[3];
  v4[6] = 0;
  v4[7] = 1;
  v4[8] = 0;
  v4[9] = 0;
  sub_8086DCB((int)v4);
  return v4;
}

//----- (080870EE) --------------------------------------------------------
_DWORD *__cdecl sub_80870EE(int a1, int a2)
{
  int i; // [esp+8h] [ebp-10h]
  _BYTE *v4; // [esp+10h] [ebp-8h]
  _DWORD *v5; // [esp+14h] [ebp-4h]

  v4 = sub_80871C1(a2 + 2);
  if ( !v4 )
    sub_8087193((int)"out of dynamic memory in yy_scan_bytes()");
  for ( i = 0; i < a2; ++i )
    v4[i] = *(_BYTE *)(a1 + i);
  v4[a2 + 1] = 0;
  v4[a2] = 0;
  v5 = sub_8086FEC((int)v4, a2 + 2);
  if ( !v5 )
    sub_8087193((int)"bad buffer in yy_scan_bytes()");
  v5[5] = 1;
  return v5;
}

//----- (08087193) --------------------------------------------------------
void __cdecl __noreturn sub_8087193(int a1)
{
  fprintf(stderr, "%s\n", a1);
  exit(2);
}

//----- (080871C1) --------------------------------------------------------
void *__cdecl sub_80871C1(size_t size)
{
  return malloc(size);
}

//----- (080871D4) --------------------------------------------------------
void *__cdecl sub_80871D4(void *ptr, size_t size)
{
  return realloc(ptr, size);
}

//----- (080871EE) --------------------------------------------------------
void __cdecl sub_80871EE(void *ptr)
{
  free(ptr);
}

//----- (08087201) --------------------------------------------------------
int sub_8087201()
{
  if ( dword_89BFAE0 )
  {
    if ( dword_89BFAE0 != 257 )
      sub_8077FFE(dword_83DB9BC, "bad syntax");
  }
  else
  {
    sub_8077FFE(dword_83DB9BC, "unexpected end of file found");
  }
  return 0;
}
// 89BFAE0: using guessed type int dword_89BFAE0;

//----- (0808724F) --------------------------------------------------------
int __cdecl sub_808724F(_DWORD *a1, char a2)
{
  int result; // eax
  char s; // [esp+10h] [ebp-48h]
  void *v4; // [esp+14h] [ebp-44h]
  int v5; // [esp+1Ch] [ebp-3Ch]
  int v6; // [esp+24h] [ebp-34h]
  char v7; // [esp+4Fh] [ebp-9h]

  v7 = a2;
  memset(&s, 0, 0x28u);
  dword_83DB9B8 = -1;
  dword_83DB9BC = 0;
  byte_83DB9C0 = v7;
  dword_83DB9C4 = 0;
  dword_815D548 = 1;
  v5 = 0x4000;
  v4 = &unk_83DB9E0;
  v6 = 0;
  sub_8086F30((int)&s, 0);
  dword_83DB9A0 = (int)&s;
  dword_83DB9A8 = 3;
  sub_8087306();
  result = dword_83DB9B4;
  *a1 = dword_83DB9B4;
  return result;
}
// 815D548: using guessed type int dword_815D548;
// 83DB9A8: using guessed type int dword_83DB9A8;
// 83DB9B4: using guessed type int dword_83DB9B4;
// 83DB9B8: using guessed type int dword_83DB9B8;
// 83DB9C0: using guessed type char byte_83DB9C0;
// 83DB9C4: using guessed type int dword_83DB9C4;

//----- (080872FC) --------------------------------------------------------
signed int sub_80872FC()
{
  return 1;
}

//----- (08087306) --------------------------------------------------------
signed int sub_8087306()
{
  int v0; // ecx
  int v1; // edx
  int v2; // ecx
  int v3; // edx
  int *v4; // edx
  int v5; // eax
  int v6; // edx
  int *v7; // ebx
  int *v8; // ebx
  int *v9; // ebx
  int *v10; // ebx
  int *v11; // ebx
  int *v12; // ebx
  int *v13; // ebx
  int *v14; // ebx
  int *v15; // ebx
  int *v16; // ebx
  int *v17; // ebx
  int *v18; // ebx
  int *v19; // ebx
  int *v20; // ebx
  int v21; // ecx
  int v22; // edx
  int v23; // ecx
  int v24; // edx
  signed int v26; // [esp+2Ch] [ebp-2CCh]
  int v27; // [esp+2Ch] [ebp-2CCh]
  int v28; // [esp+30h] [ebp-2C8h]
  int v29; // [esp+30h] [ebp-2C8h]
  int v30; // [esp+30h] [ebp-2C8h]
  int v31; // [esp+30h] [ebp-2C8h]
  int v32; // [esp+30h] [ebp-2C8h]
  int v33; // [esp+34h] [ebp-2C4h]
  int v34; // [esp+34h] [ebp-2C4h]
  int v36; // [esp+3Ch] [ebp-2BCh]
  int v37; // [esp+40h] [ebp-2B8h]
  int v38; // [esp+44h] [ebp-2B4h]
  int v39; // [esp+48h] [ebp-2B0h]
  int v40; // [esp+4Ch] [ebp-2ACh]
  int v41; // [esp+50h] [ebp-2A8h]
  int v42; // [esp+54h] [ebp-2A4h]
  int v43; // [esp+58h] [ebp-2A0h]
  int v44; // [esp+5Ch] [ebp-29Ch]
  int v45; // [esp+60h] [ebp-298h]
  int v46; // [esp+64h] [ebp-294h]
  _DWORD *v47; // [esp+68h] [ebp-290h]
  int v48; // [esp+6Ch] [ebp-28Ch]
  int v49; // [esp+70h] [ebp-288h]
  int v50; // [esp+74h] [ebp-284h]
  int v51; // [esp+78h] [ebp-280h]
  int v52; // [esp+7Ch] [ebp-27Ch]
  int v53; // [esp+80h] [ebp-278h]
  int v54; // [esp+84h] [ebp-274h]
  int v55; // [esp+88h] [ebp-270h]
  int v56; // [esp+8Ch] [ebp-26Ch]
  int v57; // [esp+90h] [ebp-268h]
  int v58; // [esp+94h] [ebp-264h]
  int v59; // [esp+98h] [ebp-260h]
  int v60; // [esp+9Ch] [ebp-25Ch]
  int v61; // [esp+A0h] [ebp-258h]
  int v62; // [esp+A4h] [ebp-254h]
  int v63; // [esp+A8h] [ebp-250h]
  int v64; // [esp+ACh] [ebp-24Ch]
  int v65; // [esp+B0h] [ebp-248h]
  int v66; // [esp+B4h] [ebp-244h]
  int v67; // [esp+B8h] [ebp-240h]
  int v68; // [esp+BCh] [ebp-23Ch]
  int v69; // [esp+C0h] [ebp-238h]
  int v70; // [esp+C4h] [ebp-234h]
  _DWORD *v71; // [esp+C8h] [ebp-230h]
  int v72; // [esp+CCh] [ebp-22Ch]
  int v73; // [esp+D0h] [ebp-228h]
  int v74; // [esp+D4h] [ebp-224h]
  int v75; // [esp+D8h] [ebp-220h]
  int v76; // [esp+DCh] [ebp-21Ch]
  int v77; // [esp+E0h] [ebp-218h]
  int v78; // [esp+E4h] [ebp-214h]
  int v79; // [esp+E8h] [ebp-210h]
  int v80; // [esp+ECh] [ebp-20Ch]
  int v81; // [esp+F0h] [ebp-208h]
  int v82; // [esp+F4h] [ebp-204h]
  int v83; // [esp+F8h] [ebp-200h]
  int v84; // [esp+FCh] [ebp-1FCh]
  int v85; // [esp+100h] [ebp-1F8h]
  int v86; // [esp+104h] [ebp-1F4h]
  int v87; // [esp+108h] [ebp-1F0h]
  int v88; // [esp+10Ch] [ebp-1ECh]
  int v89; // [esp+110h] [ebp-1E8h]
  int v90; // [esp+114h] [ebp-1E4h]
  int v91; // [esp+118h] [ebp-1E0h]
  int v92; // [esp+11Ch] [ebp-1DCh]
  int v93; // [esp+120h] [ebp-1D8h]
  int v94; // [esp+124h] [ebp-1D4h]
  int v95; // [esp+128h] [ebp-1D0h]
  int v96; // [esp+12Ch] [ebp-1CCh]
  int v97; // [esp+130h] [ebp-1C8h]
  int v98; // [esp+134h] [ebp-1C4h]
  int v99; // [esp+138h] [ebp-1C0h]
  int v100; // [esp+13Ch] [ebp-1BCh]
  int v101; // [esp+140h] [ebp-1B8h]
  int v102; // [esp+144h] [ebp-1B4h]
  int v103; // [esp+148h] [ebp-1B0h]
  int v104; // [esp+14Ch] [ebp-1ACh]
  int v105; // [esp+150h] [ebp-1A8h]
  int v106; // [esp+154h] [ebp-1A4h]
  int v107; // [esp+158h] [ebp-1A0h]
  int v108; // [esp+15Ch] [ebp-19Ch]
  int v109; // [esp+160h] [ebp-198h]
  int v110; // [esp+164h] [ebp-194h]
  int v111; // [esp+168h] [ebp-190h]
  int v112; // [esp+16Ch] [ebp-18Ch]
  int v113; // [esp+170h] [ebp-188h]
  int v114; // [esp+174h] [ebp-184h]
  int v115; // [esp+178h] [ebp-180h]
  int v116; // [esp+17Ch] [ebp-17Ch]
  int v117; // [esp+180h] [ebp-178h]
  int v118; // [esp+184h] [ebp-174h]
  int v119; // [esp+188h] [ebp-170h]
  int v120; // [esp+18Ch] [ebp-16Ch]
  int v121; // [esp+190h] [ebp-168h]
  int v122; // [esp+194h] [ebp-164h]
  int v123; // [esp+198h] [ebp-160h]
  int v124; // [esp+19Ch] [ebp-15Ch]
  int v125; // [esp+1A0h] [ebp-158h]
  int v126; // [esp+1A4h] [ebp-154h]
  int v127; // [esp+1A8h] [ebp-150h]
  int v128; // [esp+1ACh] [ebp-14Ch]
  int v129; // [esp+1B0h] [ebp-148h]
  int v130; // [esp+1B4h] [ebp-144h]
  int v131; // [esp+1B8h] [ebp-140h]
  int v132; // [esp+1BCh] [ebp-13Ch]
  int v133; // [esp+1C0h] [ebp-138h]
  int v134; // [esp+1C4h] [ebp-134h]
  int v135; // [esp+1C8h] [ebp-130h]
  int v136; // [esp+1CCh] [ebp-12Ch]
  int v137; // [esp+1D0h] [ebp-128h]
  int v138; // [esp+1D4h] [ebp-124h]
  int v139; // [esp+1D8h] [ebp-120h]
  int v140; // [esp+1DCh] [ebp-11Ch]
  int v141; // [esp+1E0h] [ebp-118h]
  int v142; // [esp+1E4h] [ebp-114h]
  int v143; // [esp+1E8h] [ebp-110h]
  int v144; // [esp+1ECh] [ebp-10Ch]
  int v145; // [esp+1F0h] [ebp-108h]
  int v146; // [esp+1F4h] [ebp-104h]
  int v147; // [esp+1F8h] [ebp-100h]
  int v148; // [esp+1FCh] [ebp-FCh]
  int v149; // [esp+200h] [ebp-F8h]
  int v150; // [esp+204h] [ebp-F4h]
  int v151; // [esp+208h] [ebp-F0h]
  int v152; // [esp+20Ch] [ebp-ECh]
  int v153; // [esp+210h] [ebp-E8h]
  int v154; // [esp+214h] [ebp-E4h]
  int v155; // [esp+218h] [ebp-E0h]
  int v156; // [esp+21Ch] [ebp-DCh]
  int v157; // [esp+220h] [ebp-D8h]
  int v158; // [esp+224h] [ebp-D4h]
  int v159; // [esp+228h] [ebp-D0h]
  int v160; // [esp+22Ch] [ebp-CCh]
  int v161; // [esp+230h] [ebp-C8h]
  int v162; // [esp+234h] [ebp-C4h]
  int v163; // [esp+238h] [ebp-C0h]
  int v164; // [esp+23Ch] [ebp-BCh]
  int v165; // [esp+240h] [ebp-B8h]
  int v166; // [esp+244h] [ebp-B4h]
  int v167; // [esp+248h] [ebp-B0h]
  int v168; // [esp+24Ch] [ebp-ACh]
  int v169; // [esp+250h] [ebp-A8h]
  int v170; // [esp+254h] [ebp-A4h]
  int v171; // [esp+258h] [ebp-A0h]
  int v172; // [esp+25Ch] [ebp-9Ch]
  int v173; // [esp+260h] [ebp-98h]
  int v174; // [esp+264h] [ebp-94h]
  int v175; // [esp+268h] [ebp-90h]
  int v176; // [esp+26Ch] [ebp-8Ch]
  int v177; // [esp+270h] [ebp-88h]
  int v178; // [esp+274h] [ebp-84h]
  int v179; // [esp+278h] [ebp-80h]
  int v180; // [esp+27Ch] [ebp-7Ch]
  int v181; // [esp+280h] [ebp-78h]
  int v182; // [esp+284h] [ebp-74h]
  int v183; // [esp+288h] [ebp-70h]
  int v184; // [esp+28Ch] [ebp-6Ch]
  int v185; // [esp+290h] [ebp-68h]
  int v186; // [esp+294h] [ebp-64h]
  int v187; // [esp+298h] [ebp-60h]
  int v188; // [esp+29Ch] [ebp-5Ch]
  int v189; // [esp+2A0h] [ebp-58h]
  int v190; // [esp+2A4h] [ebp-54h]
  int v191; // [esp+2A8h] [ebp-50h]
  int v192; // [esp+2ACh] [ebp-4Ch]
  int v193; // [esp+2B0h] [ebp-48h]
  int v194; // [esp+2B4h] [ebp-44h]
  int v195; // [esp+2B8h] [ebp-40h]
  int v196; // [esp+2BCh] [ebp-3Ch]
  int v197; // [esp+2C0h] [ebp-38h]
  int v198; // [esp+2C4h] [ebp-34h]
  int v199; // [esp+2C8h] [ebp-30h]
  int v200; // [esp+2CCh] [ebp-2Ch]
  int v201; // [esp+2D0h] [ebp-28h]
  int v202; // [esp+2D4h] [ebp-24h]
  int v203; // [esp+2D8h] [ebp-20h]
  int v204; // [esp+2DCh] [ebp-1Ch]
  int v205; // [esp+2E0h] [ebp-18h]
  int v206; // [esp+2E4h] [ebp-14h]
  int v207; // [esp+2E8h] [ebp-10h]
  int v208; // [esp+2ECh] [ebp-Ch]

  dword_89BE730 = 0;
  dword_89BE720 = 0;
  dword_89BFAE0 = -1;
  dword_89BE72C = (int)&unk_89BE740;
  dword_89BE728 = (int)&unk_89BEB40;
  v26 = 0;
  unk_89BE740 = 0;
  while ( 1 )
  {
    while ( 1 )
    {
      while ( 1 )
      {
        while ( 1 )
        {
          v28 = word_815AEA0[v26];
          if ( !word_815AEA0[v26] )
            break;
LABEL_32:
          v33 = word_815AD80[v28];
          v4 = (int *)(dword_89BE728 + 8 * (1 - v33));
          v5 = *v4;
          v6 = v4[1];
          dword_89BE734 = v5;
          dword_89BE738 = v6;
          switch ( v28 )
          {
            case 1:
              sub_8078450((int)&dword_83DB9B4, *(_DWORD *)(dword_89BE728 - 8), *(_DWORD *)dword_89BE728);
              break;
            case 2:
              sub_80783DE((int)&dword_83DB9B4, 65, *(_DWORD *)dword_89BE728);
              break;
            case 3:
              sub_80783DE((int)&dword_83DB9B4, 82, *(_DWORD *)dword_89BE728);
              break;
            case 4:
              sub_80783DE((int)&dword_83DB9B4, 82, *(_DWORD *)dword_89BE728);
              break;
            case 5:
              sub_80783A2(&v208, *(_DWORD *)(dword_89BE728 + 4));
              sub_8078412((int)&dword_89BE734, 6, *(_DWORD *)dword_89BE728, v208);
              break;
            case 6:
              sub_80783A2(&v207, *(_DWORD *)(dword_89BE728 - 8 + 4));
              sub_80783A2(&v206, *(_DWORD *)(dword_89BE728 + 4));
              sub_80783A2(&v205, *(_DWORD *)(dword_89BE728 - 16 + 4));
              sub_80785A4(
                (int)&dword_89BE734,
                47,
                *(_DWORD *)(dword_89BE728 - 16),
                *(_DWORD *)dword_89BE728,
                v205,
                v206,
                v207);
              dword_89BE738 = *(_DWORD *)(dword_89BE728 - 8 + 4);
              break;
            case 7:
              sub_80783A2(&v204, *(_DWORD *)(dword_89BE728 - 8 + 4));
              sub_80783A2(&v203, *(_DWORD *)(dword_89BE728 + 4));
              sub_80783A2(&v202, *(_DWORD *)(dword_89BE728 - 16 + 4));
              sub_80785A4(
                (int)&dword_89BE734,
                48,
                *(_DWORD *)(dword_89BE728 - 16),
                *(_DWORD *)dword_89BE728,
                v202,
                v203,
                v204);
              dword_89BE738 = *(_DWORD *)(dword_89BE728 - 8 + 4);
              break;
            case 8:
              sub_80783A2(&v201, *(_DWORD *)(dword_89BE728 - 8 + 4));
              sub_8078390(&v200, 102);
              sub_807850A(
                (int)&dword_89BE734,
                49,
                *(_DWORD *)(dword_89BE728 - 16),
                *(_DWORD *)dword_89BE728,
                v200,
                v201);
              dword_89BE738 = *(_DWORD *)(dword_89BE728 - 8 + 4);
              break;
            case 9:
              sub_80783A2(&v199, *(_DWORD *)(dword_89BE728 - 8 + 4));
              sub_8078390(&v198, 103);
              sub_807850A(
                (int)&dword_89BE734,
                49,
                *(_DWORD *)(dword_89BE728 - 16),
                *(_DWORD *)dword_89BE728,
                v198,
                v199);
              dword_89BE738 = *(_DWORD *)(dword_89BE728 - 8 + 4);
              break;
            case 10:
              sub_80783A2(&v197, *(_DWORD *)(dword_89BE728 - 8 + 4));
              sub_8078390(&v196, 104);
              sub_807850A(
                (int)&dword_89BE734,
                49,
                *(_DWORD *)(dword_89BE728 - 16),
                *(_DWORD *)dword_89BE728,
                v196,
                v197);
              dword_89BE738 = *(_DWORD *)(dword_89BE728 - 8 + 4);
              break;
            case 11:
              sub_80783A2(&v195, *(_DWORD *)(dword_89BE728 - 8 + 4));
              sub_8078390(&v194, 105);
              sub_807850A(
                (int)&dword_89BE734,
                49,
                *(_DWORD *)(dword_89BE728 - 16),
                *(_DWORD *)dword_89BE728,
                v194,
                v195);
              dword_89BE738 = *(_DWORD *)(dword_89BE728 - 8 + 4);
              break;
            case 12:
              sub_80783A2(&v193, *(_DWORD *)(dword_89BE728 - 8 + 4));
              sub_8078390(&v192, 106);
              sub_807850A(
                (int)&dword_89BE734,
                49,
                *(_DWORD *)(dword_89BE728 - 16),
                *(_DWORD *)dword_89BE728,
                v192,
                v193);
              dword_89BE738 = *(_DWORD *)(dword_89BE728 - 8 + 4);
              break;
            case 13:
              sub_80783A2(&v191, *(_DWORD *)(dword_89BE728 - 8 + 4));
              sub_8078390(&v190, 107);
              sub_807850A(
                (int)&dword_89BE734,
                49,
                *(_DWORD *)(dword_89BE728 - 16),
                *(_DWORD *)dword_89BE728,
                v190,
                v191);
              dword_89BE738 = *(_DWORD *)(dword_89BE728 - 8 + 4);
              break;
            case 14:
              sub_80783A2(&v189, *(_DWORD *)(dword_89BE728 - 8 + 4));
              sub_8078390(&v188, 108);
              sub_807850A(
                (int)&dword_89BE734,
                49,
                *(_DWORD *)(dword_89BE728 - 16),
                *(_DWORD *)dword_89BE728,
                v188,
                v189);
              dword_89BE738 = *(_DWORD *)(dword_89BE728 - 8 + 4);
              break;
            case 15:
              sub_80783A2(&v187, *(_DWORD *)(dword_89BE728 - 8 + 4));
              sub_8078390(&v186, 109);
              sub_807850A(
                (int)&dword_89BE734,
                49,
                *(_DWORD *)(dword_89BE728 - 16),
                *(_DWORD *)dword_89BE728,
                v186,
                v187);
              dword_89BE738 = *(_DWORD *)(dword_89BE728 - 8 + 4);
              break;
            case 16:
              sub_80783A2(&v185, *(_DWORD *)(dword_89BE728 - 8 + 4));
              sub_8078390(&v184, 110);
              sub_807850A(
                (int)&dword_89BE734,
                49,
                *(_DWORD *)(dword_89BE728 - 16),
                *(_DWORD *)dword_89BE728,
                v184,
                v185);
              dword_89BE738 = *(_DWORD *)(dword_89BE728 - 8 + 4);
              break;
            case 17:
              sub_80783A2(&v183, *(_DWORD *)(dword_89BE728 - 8 + 4));
              sub_8078390(&v182, 111);
              sub_807850A(
                (int)&dword_89BE734,
                49,
                *(_DWORD *)(dword_89BE728 - 16),
                *(_DWORD *)dword_89BE728,
                v182,
                v183);
              dword_89BE738 = *(_DWORD *)(dword_89BE728 - 8 + 4);
              break;
            case 18:
              sub_80783A2(&v181, *(_DWORD *)(dword_89BE728 - 8 + 4));
              sub_8078390(&v180, 112);
              sub_807850A(
                (int)&dword_89BE734,
                49,
                *(_DWORD *)(dword_89BE728 - 16),
                *(_DWORD *)dword_89BE728,
                v180,
                v181);
              dword_89BE738 = *(_DWORD *)(dword_89BE728 - 8 + 4);
              break;
            case 19:
              sub_80783A2(&v179, *(_DWORD *)(dword_89BE728 - 8 + 4));
              sub_8078390(&v178, 113);
              sub_807850A(
                (int)&dword_89BE734,
                49,
                *(_DWORD *)(dword_89BE728 - 16),
                *(_DWORD *)dword_89BE728,
                v178,
                v179);
              dword_89BE738 = *(_DWORD *)(dword_89BE728 - 8 + 4);
              break;
            case 20:
              sub_80783A2(&v177, *(_DWORD *)(dword_89BE728 - 8 + 4));
              sub_8078390(&v176, 114);
              sub_807850A(
                (int)&dword_89BE734,
                49,
                *(_DWORD *)(dword_89BE728 - 16),
                *(_DWORD *)dword_89BE728,
                v176,
                v177);
              dword_89BE738 = *(_DWORD *)(dword_89BE728 - 8 + 4);
              break;
            case 21:
              sub_80783A2(&v175, *(_DWORD *)(dword_89BE728 - 8 + 4));
              sub_8078390(&v174, 115);
              sub_807850A(
                (int)&dword_89BE734,
                49,
                *(_DWORD *)(dword_89BE728 - 16),
                *(_DWORD *)dword_89BE728,
                v174,
                v175);
              dword_89BE738 = *(_DWORD *)(dword_89BE728 - 8 + 4);
              break;
            case 22:
              sub_80783A2(&v173, *(_DWORD *)(dword_89BE728 - 8 + 4));
              sub_8078390(&v172, 116);
              sub_807850A(
                (int)&dword_89BE734,
                49,
                *(_DWORD *)(dword_89BE728 - 16),
                *(_DWORD *)dword_89BE728,
                v172,
                v173);
              dword_89BE738 = *(_DWORD *)(dword_89BE728 - 8 + 4);
              break;
            case 23:
              sub_80783A2(&v171, *(_DWORD *)(dword_89BE728 - 8 + 4));
              sub_8078390(&v170, 117);
              sub_807850A(
                (int)&dword_89BE734,
                49,
                *(_DWORD *)(dword_89BE728 - 16),
                *(_DWORD *)dword_89BE728,
                v170,
                v171);
              dword_89BE738 = *(_DWORD *)(dword_89BE728 - 8 + 4);
              break;
            case 24:
              sub_80783A2(&v169, *(_DWORD *)(dword_89BE728 + 4));
              sub_8078412((int)&dword_89BE734, 50, *(_DWORD *)dword_89BE728, v169);
              break;
            case 25:
              sub_80783A2(&v168, *(_DWORD *)(dword_89BE728 + 4));
              sub_8078412((int)&dword_89BE734, 51, *(_DWORD *)dword_89BE728, v168);
              break;
            case 26:
              sub_80783DE((int)&dword_89BE734, 65, *(_DWORD *)dword_89BE728);
              break;
            case 27:
              sub_80783B4((size_t *)&dword_89BE734, 0);
              break;
            case 28:
              v7 = (int *)dword_89BE728;
              *v7 = sub_8085274(*(_DWORD *)dword_89BE728);
              dword_89BE734 = *(_DWORD *)dword_89BE728;
              break;
            case 29:
              v8 = (int *)dword_89BE728;
              *v8 = sub_8085274(*(_DWORD *)dword_89BE728);
              dword_89BE734 = *(_DWORD *)dword_89BE728;
              break;
            case 30:
              v9 = (int *)dword_89BE728;
              *v9 = sub_8085274(*(_DWORD *)dword_89BE728);
              sub_80783A2(&v167, *(_DWORD *)(dword_89BE728 - 16 + 4));
              sub_8078484((int)&dword_89BE734, 21, *(_DWORD *)(dword_89BE728 - 16), *(_DWORD *)dword_89BE728, v167);
              ++dword_8202A44;
              break;
            case 31:
              v10 = (int *)dword_89BE728;
              *v10 = sub_8085274(*(_DWORD *)dword_89BE728);
              sub_80783A2(&v166, *(_DWORD *)(dword_89BE728 + 4));
              sub_8078412((int)&dword_89BE734, 20, *(_DWORD *)dword_89BE728, v166);
              break;
            case 32:
              v11 = (int *)dword_89BE728;
              *v11 = sub_8085274(*(_DWORD *)dword_89BE728);
              sub_80783A2(&v165, *(_DWORD *)(dword_89BE728 - 16 + 4));
              sub_8078484((int)&dword_89BE734, 21, *(_DWORD *)(dword_89BE728 - 16), *(_DWORD *)dword_89BE728, v165);
              dword_89BE738 = *(_DWORD *)(dword_89BE728 - 8 + 4);
              ++dword_8202A44;
              break;
            case 33:
              v12 = (int *)dword_89BE728;
              *v12 = sub_8085274(*(_DWORD *)dword_89BE728);
              sub_80783A2(&v164, *(_DWORD *)(dword_89BE728 - 8 + 4));
              sub_8078412((int)&dword_89BE734, 20, *(_DWORD *)dword_89BE728, v164);
              break;
            case 34:
              sub_80783A2(&v163, *(_DWORD *)(dword_89BE728 + 4));
              sub_8078412((int)&dword_89BE734, 18, *(_DWORD *)dword_89BE728, v163);
              break;
            case 35:
              sub_80783A2(&v162, *(_DWORD *)(dword_89BE728 - 16 + 4));
              sub_8078412((int)&dword_89BE734, 22, *(_DWORD *)(dword_89BE728 - 16), v162);
              break;
            case 36:
              sub_80783A2(&v161, *(_DWORD *)(dword_89BE728 + 4));
              sub_8078412((int)&dword_89BE734, 26, *(_DWORD *)dword_89BE728, v161);
              break;
            case 37:
              sub_80783A2(&v160, *(_DWORD *)(dword_89BE728 + 4));
              sub_80783A2(&v159, *(_DWORD *)(dword_89BE728 - 8 + 4));
              sub_8078484((int)&dword_89BE734, 30, *(_DWORD *)dword_89BE728, v159, v160);
              dword_89BE738 = *(_DWORD *)(dword_89BE728 + 4);
              break;
            case 38:
              sub_80783A2(&v158, *(_DWORD *)(dword_89BE728 - 16 + 4));
              sub_8078484(
                (int)&dword_89BE734,
                23,
                *(_DWORD *)(dword_89BE728 - 24),
                *(_DWORD *)(dword_89BE728 - 8),
                v158);
              dword_89BE738 = *(_DWORD *)(dword_89BE728 - 16 + 4);
              break;
            case 39:
              sub_80783A2(&v157, *(_DWORD *)(dword_89BE728 - 16 + 4));
              sub_80783A2(&v156, *(_DWORD *)(dword_89BE728 - 32 + 4));
              sub_80785A4(
                (int)&dword_89BE734,
                24,
                *(_DWORD *)(dword_89BE728 - 32),
                *(_DWORD *)(dword_89BE728 - 24),
                *(_DWORD *)(dword_89BE728 - 8),
                v156,
                v157);
              dword_89BE738 = *(_DWORD *)(dword_89BE728 - 16 + 4);
              break;
            case 40:
              sub_80783A2(&v155, *(_DWORD *)(dword_89BE728 - 16 + 4));
              sub_8078412((int)&dword_89BE734, 46, *(_DWORD *)(dword_89BE728 - 8), v155);
              break;
            case 41:
              sub_80783A2(&v154, *(_DWORD *)(dword_89BE728 + 4));
              sub_8078412((int)&dword_89BE734, 7, *(_DWORD *)dword_89BE728, v154);
              break;
            case 42:
              sub_80783A2(&v153, *(_DWORD *)(dword_89BE728 + 4));
              sub_8078412((int)&dword_89BE734, 8, *(_DWORD *)dword_89BE728, v153);
              break;
            case 43:
              sub_80783A2(&v152, *(_DWORD *)(dword_89BE728 - 8 + 4));
              sub_8078412((int)&dword_89BE734, 9, *(_DWORD *)dword_89BE728, v152);
              break;
            case 44:
              sub_80783A2(&v151, *(_DWORD *)(dword_89BE728 - 8 + 4));
              sub_8078412((int)&dword_89BE734, 10, *(_DWORD *)dword_89BE728, v151);
              break;
            case 45:
              sub_80783A2(&v150, *(_DWORD *)(dword_89BE728 + 4));
              sub_8078412((int)&dword_89BE734, 11, *(_DWORD *)dword_89BE728, v150);
              break;
            case 46:
              sub_80783A2(&v149, *(_DWORD *)(dword_89BE728 + 4));
              sub_8078412((int)&dword_89BE734, 12, *(_DWORD *)dword_89BE728, v149);
              break;
            case 47:
              sub_80783DE((int)&dword_89BE734, 19, *(_DWORD *)dword_89BE728);
              break;
            case 48:
              sub_80783A2(&v148, *(_DWORD *)(dword_89BE728 + 4));
              sub_8078412((int)&dword_89BE734, 17, *(_DWORD *)dword_89BE728, v148);
              break;
            case 49:
              sub_80783A2(&v147, *(_DWORD *)(dword_89BE728 + 4));
              sub_80783DE((int)&dword_89BE734, 31, v147);
              break;
            case 50:
              sub_80783A2(&v146, *(_DWORD *)(dword_89BE728 + 4));
              sub_80783DE((int)&dword_89BE734, 32, v146);
              break;
            case 51:
              sub_80783A2(&v145, *(_DWORD *)(dword_89BE728 + 4));
              sub_80783DE((int)&dword_89BE734, 34, v145);
              break;
            case 52:
              sub_80783A2(&v144, *(_DWORD *)(dword_89BE728 + 4));
              sub_80783DE((int)&dword_89BE734, 35, v144);
              break;
            case 53:
              sub_80783A2(&v143, *(_DWORD *)(dword_89BE728 + 4));
              sub_80783DE((int)&dword_89BE734, 36, v143);
              break;
            case 54:
              sub_80783A2(&v142, *(_DWORD *)(dword_89BE728 - 8 + 4));
              sub_8078412((int)&dword_89BE734, 52, *(_DWORD *)(dword_89BE728 - 8), v142);
              dword_89BE738 = *(_DWORD *)(dword_89BE728 + 4);
              break;
            case 55:
              sub_80783A2(&v141, *(_DWORD *)(dword_89BE728 + 4));
              sub_8078412((int)&dword_89BE734, 18, *(_DWORD *)dword_89BE728, v141);
              break;
            case 56:
              sub_80783A2(&v140, *(_DWORD *)(dword_89BE728 - 8 + 4));
              sub_80783DE((int)&dword_89BE734, 66, v140);
              break;
            case 57:
              v13 = (int *)dword_89BE728;
              *v13 = sub_8085274(*(_DWORD *)dword_89BE728);
              sub_80783A2(&v139, *(_DWORD *)(dword_89BE728 + 4));
              sub_8078412((int)&dword_89BE734, 67, *(_DWORD *)dword_89BE728, v139);
              break;
            case 58:
              sub_80783A2(&v138, *(_DWORD *)(dword_89BE728 + 4));
              sub_80783DE((int)&dword_89BE734, 72, v138);
              break;
            case 59:
              sub_80783A2(&v137, *(_DWORD *)(dword_89BE728 + 4));
              sub_80783DE((int)&dword_89BE734, 73, v137);
              break;
            case 60:
              sub_80783A2(&v136, *(_DWORD *)(dword_89BE728 + 4));
              sub_80783DE((int)&dword_89BE734, 74, v136);
              break;
            case 61:
              v14 = (int *)dword_89BE728;
              *v14 = sub_8085274(*(_DWORD *)dword_89BE728);
              sub_80783A2(&v135, *(_DWORD *)(dword_89BE728 - 16 + 4));
              sub_8078484((int)&dword_89BE734, 15, *(_DWORD *)(dword_89BE728 - 16), *(_DWORD *)dword_89BE728, v135);
              dword_89BE738 = *(_DWORD *)(dword_89BE728 + 4);
              break;
            case 62:
              sub_80783A2(&v134, *(_DWORD *)(dword_89BE728 - 8 + 4));
              sub_80783A2(&v133, *(_DWORD *)(dword_89BE728 - 24 + 4));
              sub_807850A(
                (int)&dword_89BE734,
                13,
                *(_DWORD *)(dword_89BE728 - 24),
                *(_DWORD *)(dword_89BE728 - 8),
                v133,
                v134);
              dword_89BE738 = *(_DWORD *)(dword_89BE728 - 16 + 4);
              break;
            case 63:
              v15 = (int *)dword_89BE728;
              *v15 = sub_8085274(*(_DWORD *)dword_89BE728);
              sub_80783A2(&v132, *(_DWORD *)(dword_89BE728 + 4));
              sub_8078412((int)&dword_89BE734, 4, *(_DWORD *)dword_89BE728, v132);
              break;
            case 64:
              v16 = (int *)dword_89BE728;
              *v16 = sub_8085274(*(_DWORD *)dword_89BE728);
              sub_80783A2(&v131, *(_DWORD *)(dword_89BE728 - 8 + 4));
              sub_8078412((int)&dword_89BE734, 79, *(_DWORD *)dword_89BE728, v131);
              break;
            case 65:
              sub_80783A2(&v130, *(_DWORD *)(dword_89BE728 - 16 + 4));
              sub_8078412((int)&dword_89BE734, 53, *(_DWORD *)(dword_89BE728 - 16), v130);
              dword_89BE738 = *(_DWORD *)(dword_89BE728 + 4);
              break;
            case 66:
              sub_80783A2(&v129, *(_DWORD *)(dword_89BE728 + 4));
              sub_80783A2(&v128, *(_DWORD *)(dword_89BE728 - 8 + 4));
              sub_807850A((int)&dword_89BE734, 2, *(_DWORD *)(dword_89BE728 - 16), *(_DWORD *)dword_89BE728, v128, v129);
              break;
            case 67:
              sub_80783A2(&v127, *(_DWORD *)(dword_89BE728 - 8 + 4));
              sub_8078412((int)&dword_89BE734, 27, *(_DWORD *)dword_89BE728, v127);
              break;
            case 68:
              sub_80783A2(&v126, *(_DWORD *)(dword_89BE728 + 4));
              sub_80783DE((int)&dword_89BE734, 28, v126);
              break;
            case 69:
              sub_80783A2(&v125, *(_DWORD *)(dword_89BE728 - 8 + 4));
              sub_80783A2(&v124, *(_DWORD *)(dword_89BE728 + 4));
              sub_8078484((int)&dword_89BE734, 29, *(_DWORD *)dword_89BE728, v124, v125);
              break;
            case 70:
              sub_80783A2(&v123, *(_DWORD *)(dword_89BE728 - 8 + 4));
              sub_8078412((int)&dword_89BE734, 41, *(_DWORD *)(dword_89BE728 - 8), v123);
              break;
            case 71:
              sub_80783A2(&v122, *(_DWORD *)(dword_89BE728 - 8 + 4));
              sub_8078412((int)&dword_89BE734, 42, *(_DWORD *)(dword_89BE728 - 8), v122);
              break;
            case 72:
              sub_80783A2(&v121, *(_DWORD *)(dword_89BE728 - 8 + 4));
              sub_8078390(&v120, 102);
              sub_807850A(
                (int)&dword_89BE734,
                43,
                *(_DWORD *)(dword_89BE728 - 16),
                *(_DWORD *)dword_89BE728,
                v120,
                v121);
              break;
            case 73:
              sub_80783A2(&v119, *(_DWORD *)(dword_89BE728 - 8 + 4));
              sub_8078390(&v118, 103);
              sub_807850A(
                (int)&dword_89BE734,
                43,
                *(_DWORD *)(dword_89BE728 - 16),
                *(_DWORD *)dword_89BE728,
                v118,
                v119);
              break;
            case 74:
              sub_80783A2(&v117, *(_DWORD *)(dword_89BE728 - 8 + 4));
              sub_8078390(&v116, 104);
              sub_807850A(
                (int)&dword_89BE734,
                43,
                *(_DWORD *)(dword_89BE728 - 16),
                *(_DWORD *)dword_89BE728,
                v116,
                v117);
              break;
            case 75:
              sub_80783A2(&v115, *(_DWORD *)(dword_89BE728 - 8 + 4));
              sub_8078390(&v114, 111);
              sub_807850A(
                (int)&dword_89BE734,
                43,
                *(_DWORD *)(dword_89BE728 - 16),
                *(_DWORD *)dword_89BE728,
                v114,
                v115);
              break;
            case 76:
              sub_80783A2(&v113, *(_DWORD *)(dword_89BE728 - 8 + 4));
              sub_8078390(&v112, 112);
              sub_807850A(
                (int)&dword_89BE734,
                43,
                *(_DWORD *)(dword_89BE728 - 16),
                *(_DWORD *)dword_89BE728,
                v112,
                v113);
              break;
            case 77:
              sub_80783A2(&v111, *(_DWORD *)(dword_89BE728 - 8 + 4));
              sub_8078390(&v110, 113);
              sub_807850A(
                (int)&dword_89BE734,
                43,
                *(_DWORD *)(dword_89BE728 - 16),
                *(_DWORD *)dword_89BE728,
                v110,
                v111);
              break;
            case 78:
              sub_80783A2(&v109, *(_DWORD *)(dword_89BE728 - 8 + 4));
              sub_8078390(&v108, 114);
              sub_807850A(
                (int)&dword_89BE734,
                43,
                *(_DWORD *)(dword_89BE728 - 16),
                *(_DWORD *)dword_89BE728,
                v108,
                v109);
              break;
            case 79:
              sub_80783A2(&v107, *(_DWORD *)(dword_89BE728 - 8 + 4));
              sub_8078390(&v106, 115);
              sub_807850A(
                (int)&dword_89BE734,
                43,
                *(_DWORD *)(dword_89BE728 - 16),
                *(_DWORD *)dword_89BE728,
                v106,
                v107);
              break;
            case 80:
              sub_80783A2(&v105, *(_DWORD *)(dword_89BE728 - 8 + 4));
              sub_8078390(&v104, 116);
              sub_807850A(
                (int)&dword_89BE734,
                43,
                *(_DWORD *)(dword_89BE728 - 16),
                *(_DWORD *)dword_89BE728,
                v104,
                v105);
              break;
            case 81:
              sub_80783A2(&v103, *(_DWORD *)(dword_89BE728 - 8 + 4));
              sub_8078390(&v102, 117);
              sub_807850A(
                (int)&dword_89BE734,
                43,
                *(_DWORD *)(dword_89BE728 - 16),
                *(_DWORD *)dword_89BE728,
                v102,
                v103);
              break;
            case 82:
              sub_80783A2(&v101, *(_DWORD *)(dword_89BE728 - 24 + 4));
              sub_80783A2(&v100, *(_DWORD *)(dword_89BE728 - 32 + 4));
              sub_807850A(
                (int)&dword_89BE734,
                55,
                *(_DWORD *)(dword_89BE728 - 32),
                *(_DWORD *)(dword_89BE728 - 8),
                v100,
                v101);
              break;
            case 83:
              sub_80783A2(&v99, *(_DWORD *)(dword_89BE728 - 24 + 4));
              sub_80783A2(&v98, *(_DWORD *)(dword_89BE728 - 32 + 4));
              sub_807850A(
                (int)&dword_89BE734,
                56,
                *(_DWORD *)(dword_89BE728 - 32),
                *(_DWORD *)(dword_89BE728 - 8),
                v98,
                v99);
              break;
            case 84:
              sub_80783A2(&v97, *(_DWORD *)(dword_89BE728 + 4));
              sub_80783DE((int)&dword_89BE734, 57, v97);
              break;
            case 85:
              sub_80783A2(&v96, *(_DWORD *)(dword_89BE728 - 24 + 4));
              sub_80783A2(&v95, *(_DWORD *)(dword_89BE728 - 32 + 4));
              sub_807850A(
                (int)&dword_89BE734,
                58,
                *(_DWORD *)(dword_89BE728 - 32),
                *(_DWORD *)(dword_89BE728 - 8),
                v95,
                v96);
              break;
            case 86:
              sub_80783A2(&v94, *(_DWORD *)(dword_89BE728 - 8 + 4));
              sub_80783A2(&v93, *(_DWORD *)(dword_89BE728 - 32 + 4));
              sub_807850A(
                (int)&dword_89BE734,
                59,
                *(_DWORD *)(dword_89BE728 - 32),
                *(_DWORD *)(dword_89BE728 - 8),
                v93,
                v94);
              break;
            case 87:
              sub_80783A2(&v92, *(_DWORD *)(dword_89BE728 + 4));
              sub_80783DE((int)&dword_89BE734, 63, v92);
              break;
            case 88:
              sub_80783A2(&v91, *(_DWORD *)(dword_89BE728 + 4));
              sub_80783DE((int)&dword_89BE734, 64, v91);
              break;
            case 89:
              sub_80783A2(&v90, *(_DWORD *)(dword_89BE728 + 4));
              sub_80783DE((int)&dword_89BE734, 75, v90);
              break;
            case 90:
              sub_80783A2(&v89, *(_DWORD *)(dword_89BE728 - 24 + 4));
              sub_8078412((int)&dword_89BE734, 76, *(_DWORD *)(dword_89BE728 - 8), v89);
              break;
            case 91:
              sub_80783A2(&v88, *(_DWORD *)(dword_89BE728 - 24 + 4));
              sub_8078412((int)&dword_89BE734, 77, *(_DWORD *)(dword_89BE728 - 8), v88);
              break;
            case 92:
              sub_80783DE((int)&dword_89BE734, 25, *(_DWORD *)dword_89BE728);
              break;
            case 94:
              sub_80783B4((size_t *)&dword_89BE734, 0);
              break;
            case 97:
              sub_80783A2(&v87, *(_DWORD *)(dword_89BE728 + 4));
              sub_80783A2(&v86, *(_DWORD *)(dword_89BE728 - 16 + 4));
              sub_8078484((int)&dword_89BE734, 44, *(_DWORD *)(dword_89BE728 - 8), v86, v87);
              break;
            case 98:
              sub_80783A2(&v85, *(_DWORD *)(dword_89BE728 - 16 + 4));
              sub_807850A(
                (int)&dword_89BE734,
                37,
                *(_DWORD *)(dword_89BE728 - 16),
                *(_DWORD *)dword_89BE728,
                v85,
                dword_83DB9C4);
              break;
            case 99:
              sub_80783A2(&v84, *(_DWORD *)(dword_89BE728 - 8 + 4));
              sub_80783A2(&v83, *(_DWORD *)(dword_89BE728 - 32 + 4));
              sub_8078666(
                (int)&dword_89BE734,
                38,
                *(_DWORD *)(dword_89BE728 - 32),
                *(_DWORD *)(dword_89BE728 - 16),
                *(_DWORD *)dword_89BE728,
                v83,
                v84,
                dword_83DB9C4,
                dword_83DB9C4);
              break;
            case 100:
              sub_80783A2(&v82, *(_DWORD *)(dword_89BE728 - 32 + 4));
              sub_80783A2(&v81, *(_DWORD *)(dword_89BE728 - 16 + 4));
              sub_80785A4(
                (int)&dword_89BE734,
                39,
                *(_DWORD *)(dword_89BE728 - 16),
                *(_DWORD *)dword_89BE728,
                v81,
                v82,
                dword_83DB9C4);
              break;
            case 101:
              sub_80783A2(&v80, *(_DWORD *)(dword_89BE728 - 56 + 4));
              sub_80783A2(&v79, *(_DWORD *)(dword_89BE728 - 32 + 4));
              sub_80786D6(
                (int)&dword_89BE734,
                40,
                *(_DWORD *)(dword_89BE728 - 40),
                *(_DWORD *)(dword_89BE728 - 32),
                *(_DWORD *)(dword_89BE728 - 16),
                *(_DWORD *)dword_89BE728,
                v79,
                v80,
                dword_83DB9C4,
                dword_83DB9C4);
              break;
            case 102:
              sub_80783A2(&v78, *(_DWORD *)(dword_89BE728 - 32 + 4));
              sub_8078484((int)&dword_89BE734, 60, *(_DWORD *)(dword_89BE728 - 32), *(_DWORD *)(dword_89BE728 - 8), v78);
              break;
            case 103:
              sub_80783A2(&v77, *(_DWORD *)(dword_89BE728 - 16 + 4));
              sub_8078484((int)&dword_89BE734, 45, *(_DWORD *)(dword_89BE728 - 8), v77, dword_83DB9C4);
              break;
            case 104:
              sub_80783B4((size_t *)&dword_89BE734, 0);
              break;
            case 105:
              sub_80783A2(&v76, *(_DWORD *)(dword_89BE728 - 16 + 4));
              sub_8078484((int)&dword_89BE734, 61, *(_DWORD *)(dword_89BE728 - 8), v76, dword_83DB9C4);
              break;
            case 106:
              sub_80783A2(&v75, *(_DWORD *)(dword_89BE728 - 8 + 4));
              sub_8078412((int)&dword_89BE734, 62, v75, dword_83DB9C4);
              break;
            case 108:
              sub_80787EC(&dword_89BE734, *(_DWORD *)(dword_89BE728 - 8), *(_DWORD *)dword_89BE728);
              break;
            case 109:
              sub_80783B4((size_t *)&v74, 0);
              sub_8078750((int)&dword_89BE734, v74);
              break;
            case 110:
              sub_80783A2(&v72, *(_DWORD *)(dword_89BE728 + 4));
              sub_8078450((int)&v73, *(_DWORD *)dword_89BE728, v72);
              sub_80787A6(&dword_89BE734, v73, *(_DWORD **)(dword_89BE728 - 16));
              break;
            case 111:
              sub_80783B4((size_t *)&v71, 0);
              sub_80783A2(&v69, *(_DWORD *)(dword_89BE728 + 4));
              sub_8078450((int)&v70, *(_DWORD *)dword_89BE728, v69);
              sub_80787A6(&dword_89BE734, v70, v71);
              break;
            case 112:
              sub_80783B4((size_t *)&dword_89BE734, 0);
              break;
            case 113:
              v17 = (int *)dword_89BE728;
              *v17 = sub_8085274(*(_DWORD *)dword_89BE728);
              sub_80783A2(&v67, *(_DWORD *)(dword_89BE728 + 4));
              sub_8078450((int)&v68, *(_DWORD *)dword_89BE728, v67);
              sub_80787EC(&dword_89BE734, *(_DWORD *)(dword_89BE728 - 16), v68);
              break;
            case 114:
              v18 = (int *)dword_89BE728;
              *v18 = sub_8085274(*(_DWORD *)dword_89BE728);
              sub_80783A2(&v65, *(_DWORD *)(dword_89BE728 + 4));
              sub_8078450((int)&v66, *(_DWORD *)dword_89BE728, v65);
              sub_80783B4((size_t *)&v63, 0);
              sub_8078750((int)&v64, v63);
              sub_80787EC(&dword_89BE734, v64, v66);
              break;
            case 115:
              sub_80783B4((size_t *)&v62, 0);
              sub_8078750((int)&dword_89BE734, v62);
              break;
            case 116:
              v19 = (int *)dword_89BE728;
              *v19 = sub_8085274(*(_DWORD *)dword_89BE728);
              sub_80783A2(&v60, *(_DWORD *)(dword_89BE728 + 4));
              sub_8078450((int)&v61, *(_DWORD *)dword_89BE728, v60);
              sub_80787EC(&dword_89BE734, *(_DWORD *)(dword_89BE728 - 16), v61);
              break;
            case 117:
              sub_80783A2(&v58, *(_DWORD *)(dword_89BE728 + 4));
              sub_8078450((int)&v59, *(_DWORD *)dword_89BE728, v58);
              sub_80783B4((size_t *)&v56, 0);
              sub_8078750((int)&v57, v56);
              sub_80787EC(&dword_89BE734, v57, v59);
              break;
            case 118:
              sub_80783A2(&v54, *(_DWORD *)(dword_89BE728 + 4));
              sub_8078450((int)&v55, *(_DWORD *)dword_89BE728, v54);
              sub_80787EC(&dword_89BE734, *(_DWORD *)(dword_89BE728 - 16), v55);
              break;
            case 119:
              sub_80783A2(&v52, *(_DWORD *)(dword_89BE728 + 4));
              sub_8078450((int)&v53, *(_DWORD *)dword_89BE728, v52);
              sub_80783B4((size_t *)&v50, 0);
              sub_8078750((int)&v51, v50);
              sub_80787EC(&dword_89BE734, v51, v53);
              break;
            case 120:
              sub_80783A2(&v48, *(_DWORD *)(dword_89BE728 + 4));
              sub_8078450((int)&v49, *(_DWORD *)dword_89BE728, v48);
              sub_80787A6(&dword_89BE734, v49, *(_DWORD **)(dword_89BE728 - 16));
              break;
            case 121:
              sub_80783B4((size_t *)&v47, 0);
              sub_80783A2(&v45, *(_DWORD *)(dword_89BE728 + 4));
              sub_8078450((int)&v46, *(_DWORD *)dword_89BE728, v45);
              sub_80787A6(&dword_89BE734, v46, v47);
              break;
            case 122:
              v20 = (int *)(dword_89BE728 - 48);
              *v20 = sub_8085274(*(_DWORD *)(dword_89BE728 - 48));
              sub_80783A2(&v44, *(_DWORD *)(dword_89BE728 + 4));
              sub_80783A2(&v43, *(_DWORD *)(dword_89BE728 - 48 + 4));
              sub_8078600(
                (int)&dword_89BE734,
                68,
                *(_DWORD *)(dword_89BE728 - 48),
                *(_DWORD *)(dword_89BE728 - 32),
                *(_DWORD *)(dword_89BE728 - 8),
                v43,
                v44,
                dword_83DB9C4);
              break;
            case 123:
              sub_80783A2(&v42, *(_DWORD *)(dword_89BE728 - 16 + 4));
              sub_80783A2(&v41, *(_DWORD *)(dword_89BE728 - 32 + 4));
              sub_8078484((int)&dword_89BE734, 71, *(_DWORD *)(dword_89BE728 - 16), v41, v42);
              break;
            case 124:
              sub_80783A2(&v40, *(_DWORD *)(dword_89BE728 + 4));
              sub_80783DE((int)&dword_89BE734, 69, v40);
              break;
            case 125:
              sub_80783A2(&v39, *(_DWORD *)(dword_89BE728 + 4));
              sub_80783DE((int)&dword_89BE734, 70, v39);
              break;
            case 126:
              sub_80787EC(&dword_89BE734, *(_DWORD *)(dword_89BE728 - 8), *(_DWORD *)dword_89BE728);
              break;
            case 127:
              sub_80783B4((size_t *)&v38, 0);
              sub_8078750((int)&dword_89BE734, v38);
              break;
            case 128:
              sub_80783A2(&v37, *(_DWORD *)(dword_89BE728 - 8 + 4));
              sub_8078412((int)&dword_89BE734, 85, *(_DWORD *)dword_89BE728, v37);
              ++dword_8202A44;
              break;
            case 129:
              sub_80787EC(&dword_89BE734, *(_DWORD *)(dword_89BE728 - 16), *(_DWORD *)(dword_89BE728 - 8));
              break;
            case 130:
              sub_80783B4((size_t *)&v36, 0);
              sub_8078750((int)&dword_89BE734, v36);
              break;
            default:
              break;
          }
          dword_89BE72C -= 2 * v33;
          v27 = *(signed __int16 *)dword_89BE72C;
          dword_89BE728 -= 8 * v33;
          v34 = word_815AC60[v28];
          if ( v27 || word_815AC60[v28] )
          {
            if ( word_815B4E0[v34]
              && (v32 = v27 + word_815B4E0[v34], v32 >= 0)
              && v32 <= 2050
              && word_815C540[v32] == v27 )
            {
              v26 = word_815B520[v32];
            }
            else
            {
              v26 = word_815B0A0[v34];
            }
            if ( dword_89BE72C >= (unsigned int)&unk_89BEB26 )
              goto LABEL_174;
            dword_89BE72C += 2;
            *(_WORD *)dword_89BE72C = v26;
            dword_89BE728 += 8;
            v23 = dword_89BE728;
            v24 = dword_89BE738;
            *(_DWORD *)dword_89BE728 = dword_89BE734;
            *(_DWORD *)(v23 + 4) = v24;
          }
          else
          {
            v26 = 3;
            dword_89BE72C += 2;
            *(_WORD *)dword_89BE72C = 3;
            dword_89BE728 += 8;
            v21 = dword_89BE728;
            v22 = dword_89BE738;
            *(_DWORD *)dword_89BE728 = dword_89BE734;
            *(_DWORD *)(v21 + 4) = v22;
            if ( dword_89BFAE0 < 0 )
            {
              dword_89BFAE0 = sub_808546B();
              if ( dword_89BFAE0 < 0 )
                dword_89BFAE0 = 0;
            }
            if ( !dword_89BFAE0 )
              return 0;
          }
        }
        if ( dword_89BFAE0 < 0 )
        {
          dword_89BFAE0 = sub_808546B();
          if ( dword_89BFAE0 < 0 )
            dword_89BFAE0 = 0;
        }
        if ( !word_815B0E0[v26] )
          break;
        v29 = dword_89BFAE0 + word_815B0E0[v26];
        if ( v29 < 0 || v29 > 2050 || word_815C540[v29] != dword_89BFAE0 )
          break;
        if ( dword_89BE72C >= (unsigned int)&unk_89BEB26 )
          goto LABEL_174;
        dword_89BE72C += 2;
        v26 = word_815B520[v29];
        *(_WORD *)dword_89BE72C = v26;
        dword_89BE728 += 8;
        v0 = dword_89BE728;
        v1 = dword_89BEB30;
        *(_DWORD *)dword_89BE728 = dword_89BEB2C;
        *(_DWORD *)(v0 + 4) = v1;
        dword_89BFAE0 = -1;
        if ( dword_89BE720 > 0 )
          --dword_89BE720;
      }
      if ( word_815B2E0[v26] )
      {
        v30 = dword_89BFAE0 + word_815B2E0[v26];
        if ( v30 >= 0 && v30 <= 2050 && word_815C540[v30] == dword_89BFAE0 )
        {
          v28 = word_815B520[v30];
          goto LABEL_32;
        }
      }
      if ( !dword_89BE720 )
      {
        sub_8087201();
        ++dword_89BE730;
      }
      if ( dword_89BE720 <= 2 )
        break;
      if ( !dword_89BFAE0 )
        return 1;
      dword_89BFAE0 = -1;
    }
    dword_89BE720 = 3;
    while ( 1 )
    {
      if ( word_815B0E0[*(signed __int16 *)dword_89BE72C] )
      {
        v31 = word_815B0E0[*(signed __int16 *)dword_89BE72C] + 256;
        if ( v31 >= 0 && v31 <= 2050 && word_815C540[v31] == 256 )
          break;
      }
      if ( dword_89BE72C <= (unsigned int)&unk_89BE740 )
        return 1;
      dword_89BE72C -= 2;
      dword_89BE728 -= 8;
    }
    if ( dword_89BE72C >= (unsigned int)&unk_89BEB26 )
      break;
    dword_89BE72C += 2;
    v26 = word_815B520[v31];
    *(_WORD *)dword_89BE72C = v26;
    dword_89BE728 += 8;
    v2 = dword_89BE728;
    v3 = dword_89BEB30;
    *(_DWORD *)dword_89BE728 = dword_89BEB2C;
    *(_DWORD *)(v2 + 4) = v3;
  }
LABEL_174:
  sub_8087201();
  return 1;
}
// 815B0E0: using guessed type __int16 word_815B0E0[];
// 815B2E0: using guessed type __int16 word_815B2E0[];
// 815C540: using guessed type __int16 word_815C540[];
// 8202A44: using guessed type int dword_8202A44;
// 83DB9B4: using guessed type int dword_83DB9B4;
// 83DB9C4: using guessed type int dword_83DB9C4;
// 89BE720: using guessed type int dword_89BE720;
// 89BE728: using guessed type int dword_89BE728;
// 89BE72C: using guessed type int dword_89BE72C;
// 89BE730: using guessed type int dword_89BE730;
// 89BE734: using guessed type int dword_89BE734;
// 89BE738: using guessed type int dword_89BE738;
// 89BEB2C: using guessed type int dword_89BEB2C;
// 89BEB30: using guessed type int dword_89BEB30;
// 89BFAE0: using guessed type int dword_89BFAE0;

//----- (0808AA30) --------------------------------------------------------
char *sub_808AA30()
{
  int v1; // [esp+1Ch] [ebp-5Ch]
  char dest; // [esp+20h] [ebp-58h]
  char v3[4]; // [esp+64h] [ebp-14h]
  int v4; // [esp+68h] [ebp-10h]
  char *v5; // [esp+6Ch] [ebp-Ch]

  if ( !*(_BYTE *)(com_sv_running + 8) )
    return 0;
  if ( sub_805FFE6() > 1 )
  {
    *(_DWORD *)v3 = sub_806001C(1u);
    v4 = 0;
    v5 = (char *)dword_841FB0C;
    while ( v4 < *(_DWORD *)(dword_848B1CC + 8) )
    {
      if ( *(_DWORD *)v5 )
      {
        if ( !I_stricmp(v5 + 134216, *(char **)v3) )
          return v5;
        I_strncpyz(&dest, v5 + 134216, 64);
        sub_80B587C(&dest);
        if ( !I_stricmp(&dest, *(char **)v3) )
          return v5;
      }
      ++v4;
      v5 += 495380;
    }
    Com_Printf("Player %s is not on the server\n", *(_DWORD *)v3);
    v1 = 0;
  }
  else
  {
    Com_Printf("No player specified.\n");
    v1 = 0;
  }
  return (char *)v1;
}
// 819EF14: using guessed type int com_sv_running;
// 848B1CC: using guessed type int dword_848B1CC;

//----- (0808AB48) --------------------------------------------------------
char *sub_808AB48()
{
  char *v1; // [esp+14h] [ebp-14h]
  const char *nptr; // [esp+18h] [ebp-10h]
  int v3; // [esp+1Ch] [ebp-Ch]
  int i; // [esp+20h] [ebp-8h]

  if ( !*(_BYTE *)(com_sv_running + 8) )
    return 0;
  if ( sub_805FFE6() > 1 )
  {
    nptr = sub_806001C(1u);
    for ( i = 0; nptr[i]; ++i )
    {
      if ( nptr[i] <= 47 || nptr[i] > 57 )
      {
        Com_Printf("Bad slot number: %s\n", nptr);
        return 0;
      }
    }
    v3 = atoi(nptr);
    if ( v3 >= 0 && v3 < *(_DWORD *)(dword_848B1CC + 8) )
    {
      if ( *((_DWORD *)dword_841FB0C + 123845 * v3) )
      {
        v1 = (char *)dword_841FB0C + 495380 * v3;
      }
      else
      {
        Com_Printf("Client %i is not active\n", v3);
        v1 = 0;
      }
    }
    else
    {
      Com_Printf("Bad client slot: %i\n", v3);
      v1 = 0;
    }
  }
  else
  {
    Com_Printf("No player specified.\n");
    v1 = 0;
  }
  return v1;
}
// 819EF14: using guessed type int com_sv_running;
// 848B1CC: using guessed type int dword_848B1CC;

//----- (0808AC6A) --------------------------------------------------------
void *__cdecl sub_808AC6A(char *s)
{
  return sub_8065BE0(s);
}

//----- (0808AC7E) --------------------------------------------------------
void __usercall sub_808AC7E(long double a1@<st0>)
{
  char *v1; // eax
  bool v2; // ST1F_1
  char dest; // [esp+20h] [ebp-58h]
  char v4[4]; // [esp+60h] [ebp-18h]
  char *src; // [esp+64h] [ebp-14h]
  char *v6; // [esp+68h] [ebp-10h]
  char *s; // [esp+6Ch] [ebp-Ch]

  s = sub_806001C(1u);
  if ( *s )
  {
    src = (char *)sub_808AC6A(s);
    I_strncpyz(&dest, src, 64);
    sub_80B573C(&dest);
    v1 = sub_80A139C();
    *(_DWORD *)v4 = va("maps/mp/%s.%s", &dest, v1);
    if ( FS_ReadFile(*(_BYTE **)v4, 0) == -1 )
    {
      Com_Printf("Can't find map %s\n", *(_DWORD *)v4);
    }
    else
    {
      v6 = sub_806001C(0);
      v2 = I_stricmp(v6, "devmap") == 0;
      FS_ConvertPath(&dest);
      sub_8091C02(a1, &dest);
      Dvar_SetBool(dword_848B208, v2);
    }
  }
}
// 848B208: using guessed type int dword_848B208;

//----- (0808AD76) --------------------------------------------------------
void __usercall sub_808AD76(long double a1@<st0>, int a2)
{
  char *v2; // eax
  char *v3; // eax
  int v4; // [esp+1Ch] [ebp-5Ch]
  char dest; // [esp+20h] [ebp-58h]
  char *v6; // [esp+64h] [ebp-14h]
  int v7; // [esp+68h] [ebp-10h]
  int v8[3]; // [esp+6Ch] [ebp-Ch]

  if ( *(_BYTE *)(com_sv_running + 8) )
  {
    sub_8090BE6(a1);
    I_strncpyz(byte_848B174, *(char **)(dword_848B1F4 + 8), 64);
    v4 = sub_810695E();
    if ( !*(_BYTE *)(dword_848B1CC + 7) && !strcasecmp(byte_848B174, *(const char **)(dword_848B1F4 + 8)) && a2 )
    {
      if ( sv.start_frameTime != dword_842BC88 )
      {
        sub_8091B5A();
        sub_8091A70();
        dword_841FB08 ^= 4u;
        dword_841FA88 = (((_BYTE)dword_841FA88 + 1) & 0xF) + (unsigned __int8)(dword_841FA88 & 0xF0);
        Dvar_SetInt(dword_848B1E4, (char *)dword_841FA88);
        dword_842BC88 = sv.start_frameTime;
        dword_842BC80 = 1;
        dword_842BC84 = 1;
        sub_8090D6A(a1, v4);
        for ( v8[0] = 0; v8[0] <= 2; ++v8[0] )
        {
          dword_841FB04 += 100;
          sub_8094780(a1);
        }
        for ( v8[0] = 0; v8[0] < *(_DWORD *)(dword_848B1CC + 8); ++v8[0] )
        {
          v7 = (int)dword_841FB0C + 495380 * v8[0];
          if ( *((_DWORD *)dword_841FB0C + 123845 * v8[0]) > 1 )
          {
            if ( v4 )
              v3 = va("%c", 110);
            else
              v3 = va("%c", 66);
            sub_8092D5C(v7, 1, v3);
            v6 = (char *)sub_80F6722(a1, v8[0], *(_WORD *)(v7 + 484856));
            if ( v6 )
            {
              sub_808DC8C(a1, (char *)v7, v6);
              Com_Printf("SV_MapRestart_f: dropped client %i - denied!\n", v8[0]);
            }
            else if ( *(_DWORD *)v7 == 4 )
            {
              sub_808E1F0((_DWORD *)v7, (_DWORD *)(v7 + 133156));
            }
          }
        }
        dword_842BC80 = 2;
        dword_842BC84 = 0;
      }
    }
    else
    {
      sub_8106968(0);
      v2 = (char *)sub_80B0D96("mapname");
      I_strncpyz(&dest, v2, 64);
      FS_ConvertPath(&dest);
      sub_8091C02(a1, &dest);
    }
  }
  else
  {
    Com_Printf("Server is not running.\n");
  }
}
// 819EF14: using guessed type int com_sv_running;
// 819EF40: using guessed type int sv.start_frameTime;
// 841FA88: using guessed type int dword_841FA88;
// 841FB08: using guessed type int dword_841FB08;
// 842BC80: using guessed type int dword_842BC80;
// 842BC84: using guessed type int dword_842BC84;
// 842BC88: using guessed type int dword_842BC88;
// 848B1CC: using guessed type int dword_848B1CC;
// 848B1E4: using guessed type int dword_848B1E4;

//----- (0808AFE0) --------------------------------------------------------
void __usercall sub_808AFE0(long double a1@<st0>)
{
  sub_808AD76(a1, 0);
}

//----- (0808AFF4) --------------------------------------------------------
void __usercall sub_808AFF4(long double a1@<st0>)
{
  sub_808AD76(a1, 1);
}

//----- (0808B008) --------------------------------------------------------
char *sub_808B008()
{
  char *v1; // [esp+Ch] [ebp-Ch]
  char *v2; // [esp+10h] [ebp-8h]
  char *src; // [esp+14h] [ebp-4h]

  src = *(char **)(dword_848B220 + 8);
  v2 = Com_Parse(&src);
  if ( src )
  {
    Dvar_SetString(dword_848B220, src);
    v1 = v2;
  }
  else
  {
    Dvar_SetString(dword_848B220, &byte_8142A4E);
    v1 = 0;
  }
  return v1;
}

//----- (0808B06A) --------------------------------------------------------
void __usercall sub_808B06A(long double a1@<st0>)
{
  char *v1; // eax
  const char *s1; // [esp+14h] [ebp-4h]
  char *s1a; // [esp+14h] [ebp-4h]
  char *s1b; // [esp+14h] [ebp-4h]

  Com_Printf("map_rotate...\n\n");
  Com_Printf("\"sv_mapRotation\" is:\"%s\"\n\n", *(_DWORD *)(dword_848B21C + 8));
  Com_Printf("\"sv_mapRotationCurrent\" is:\"%s\"\n\n", *(_DWORD *)(dword_848B220 + 8));
  if ( !**(_BYTE **)(dword_848B220 + 8) )
    Dvar_SetString(dword_848B220, *(char **)(dword_848B21C + 8));
  s1 = sub_808B008();
  if ( !s1 )
  {
    Dvar_SetString(dword_848B220, *(char **)(dword_848B21C + 8));
    s1 = sub_808B008();
  }
  while ( 1 )
  {
    if ( !s1 )
    {
      Com_Printf("No map specified in sv_mapRotation - forcing map_restart.\n");
      sub_808AFF4(a1);
      return;
    }
    if ( strcasecmp(s1, "gametype") )
      break;
    s1a = sub_808B008();
    if ( !s1a )
    {
      Com_Printf("No gametype specified after 'gametype' keyword in sv_mapRotation - forcing map_restart.\n");
      sub_808AFF4(a1);
      return;
    }
    Com_Printf("Setting g_gametype: %s.\n", s1a);
    if ( *(_BYTE *)(com_sv_running + 8) )
    {
      if ( strcasecmp(*(const char **)(dword_848B1F4 + 8), s1a) )
        sub_8106968(0);
    }
    Dvar_SetString(dword_848B1F4, s1a);
LABEL_19:
    s1 = sub_808B008();
  }
  if ( strcasecmp(s1, "map") )
  {
    Com_Printf("Unknown keyword '%s' in sv_mapRotation.\n", s1);
    goto LABEL_19;
  }
  s1b = sub_808B008();
  if ( s1b )
  {
    Com_Printf("Setting map: %s.\n", s1b);
    v1 = va("map %s\n", s1b);
    Cbuf_ExecuteText(a1, 0, v1);
  }
  else
  {
    Com_Printf("No map specified after 'map' keyword in sv_mapRotation - forcing map_restart.\n");
    sub_808AFF4(a1);
  }
}
// 819EF14: using guessed type int com_sv_running;
// 848B21C: using guessed type int dword_848B21C;

//----- (0808B24C) --------------------------------------------------------
int __usercall sub_808B24C@<eax>(long double a1@<st0>, int a2, char *dest, int a4)
{
  int v4; // ST14_4
  int v6; // [esp+10h] [ebp-8h]

  if ( *(_DWORD *)(a2 + 452036) == 2 )
  {
    sub_809301C(0, 0, "%c \"EXE_CANNOTKICKHOSTPLAYER\"", 101);
    v6 = 0;
  }
  else
  {
    if ( dest )
    {
      I_strncpyz(dest, (char *)(a2 + 134216), a4);
      sub_80B587C(dest);
    }
    v4 = *(_DWORD *)(a2 + 484852);
    sub_808DC8C(a1, (char *)a2, "EXE_PLAYERKICKED");
    *(_DWORD *)(a2 + 134416) = dword_841FB04;
    v6 = v4;
  }
  return v6;
}

//----- (0808B2F2) --------------------------------------------------------
int __usercall sub_808B2F2@<eax>(long double a1@<st0>, char *dest, int a3)
{
  char *v3; // ST24_4
  char *v4; // eax
  int v6; // [esp+18h] [ebp-10h]
  int v7; // [esp+1Ch] [ebp-Ch]
  char *v8; // [esp+20h] [ebp-8h]
  _DWORD *v9; // [esp+20h] [ebp-8h]

  if ( *(_BYTE *)(com_sv_running + 8) )
  {
    if ( sub_805FFE6() == 2 )
    {
      v8 = sub_808AA30();
      if ( v8 )
      {
        v6 = sub_808B24C(a1, (int)v8, dest, a3);
      }
      else
      {
        v4 = sub_806001C(1u);
        if ( !I_stricmp(v4, "all") )
        {
          v7 = 0;
          v9 = dword_841FB0C;
          while ( v7 < *(_DWORD *)(dword_848B1CC + 8) )
          {
            if ( *v9 )
              sub_808B24C(a1, (int)v9, 0, 0);
            ++v7;
            v9 += 123845;
          }
        }
        v6 = 0;
      }
    }
    else
    {
      v3 = sub_806001C(0);
      Com_Printf("Usage: %s <player name>\n%s all = kick everyone\n", v3, v3);
      v6 = 0;
    }
  }
  else
  {
    Com_Printf("Server is not running.\n");
    v6 = 0;
  }
  return v6;
}
// 819EF14: using guessed type int com_sv_running;
// 848B1CC: using guessed type int dword_848B1CC;

//----- (0808B406) --------------------------------------------------------
int __usercall sub_808B406@<eax>(long double a1@<st0>, char *dest, int a3)
{
  char *v3; // eax
  int v5; // [esp+10h] [ebp-8h]
  char *v6; // [esp+14h] [ebp-4h]

  if ( *(_BYTE *)(com_sv_running + 8) )
  {
    if ( sub_805FFE6() == 2 )
    {
      v6 = sub_808AB48();
      if ( v6 )
        v5 = sub_808B24C(a1, (int)v6, dest, a3);
      else
        v5 = 0;
    }
    else
    {
      v3 = sub_806001C(0);
      Com_Printf("Usage: %s <client number>\n", v3);
      v5 = 0;
    }
  }
  else
  {
    Com_Printf("Server is not running.\n");
    v5 = 0;
  }
  return v5;
}
// 819EF14: using guessed type int com_sv_running;

//----- (0808B494) --------------------------------------------------------
int __usercall sub_808B494@<eax>(long double a1@<st0>)
{
  int result; // eax
  char dest; // [esp+10h] [ebp-58h]
  int v3; // [esp+5Ch] [ebp-Ch]

  result = sub_808B2F2(a1, &dest, 64);
  v3 = result;
  if ( result )
  {
    Com_Printf("%s (guid %i) was kicked for cheating\n", &dest, v3);
    result = sub_808C4CE(v3);
  }
  return result;
}

//----- (0808B4DE) --------------------------------------------------------
void __usercall sub_808B4DE(long double a1@<st0>)
{
  char *v1; // [esp+4h] [ebp-4h]

  if ( *(_BYTE *)(com_sv_running + 8) )
  {
    if ( sub_805FFE6() == 2 )
    {
      v1 = sub_808AA30();
      if ( v1 )
        sub_808C4FA(a1, (int)v1);
    }
    else
    {
      Com_Printf("Usage: banUser <player name>\n");
    }
  }
  else
  {
    Com_Printf("Server is not running.\n");
  }
}
// 819EF14: using guessed type int com_sv_running;

//----- (0808B532) --------------------------------------------------------
void __usercall sub_808B532(long double a1@<st0>)
{
  char *v1; // [esp+4h] [ebp-4h]

  if ( *(_BYTE *)(com_sv_running + 8) )
  {
    if ( sub_805FFE6() == 2 )
    {
      v1 = sub_808AB48();
      if ( v1 )
        sub_808C4FA(a1, (int)v1);
    }
    else
    {
      Com_Printf("Usage: banClient <client number>\n");
    }
  }
  else
  {
    Com_Printf("Server is not running.\n");
  }
}
// 819EF14: using guessed type int com_sv_running;

//----- (0808B586) --------------------------------------------------------
void sub_808B586()
{
  char *v0; // eax

  if ( sub_805FFE6() == 2 )
  {
    v0 = sub_806001C(1u);
    sub_808C626(v0);
  }
  else
  {
    Com_Printf("Usage: unban <client name>\n");
  }
}

//----- (0808B5BA) --------------------------------------------------------
int __usercall sub_808B5BA@<eax>(long double a1@<st0>)
{
  return sub_808B2F2(a1, 0, 0);
}

//----- (0808B5D6) --------------------------------------------------------
int __usercall sub_808B5D6@<eax>(long double a1@<st0>)
{
  return sub_808B406(a1, 0, 0);
}

//----- (0808B5F2) --------------------------------------------------------
int __usercall sub_808B5F2@<eax>(long double a1@<st0>)
{
  int result; // eax
  char dest; // [esp+10h] [ebp-58h]
  int v3; // [esp+5Ch] [ebp-Ch]

  result = sub_808B406(a1, &dest, 64);
  v3 = result;
  if ( result )
  {
    Com_Printf("%s (guid %i) was kicked for cheating\n", &dest, v3);
    result = sub_808C4CE(v3);
  }
  return result;
}

//----- (0808B63C) --------------------------------------------------------
void sub_808B63C()
{
  int v0; // eax
  const char *s; // ST20_4
  signed int v2; // [esp+18h] [ebp-20h]
  char *v3; // [esp+28h] [ebp-10h]
  int v4; // [esp+2Ch] [ebp-Ch]
  signed int v5; // [esp+2Ch] [ebp-Ch]
  int i; // [esp+30h] [ebp-8h]
  signed int j; // [esp+30h] [ebp-8h]
  int v8; // [esp+34h] [ebp-4h]

  if ( *(_BYTE *)(com_sv_running + 8) )
  {
    Com_Printf("map: %s\n", *(_DWORD *)(dword_848B1E0 + 8));
    Com_Printf("num score ping guid   name            lastmsg address               qport rate\n");
    Com_Printf("--- ----- ---- ------ --------------- ------- --------------------- ----- -----\n");
    v8 = 0;
    v3 = (char *)dword_841FB0C;
    while ( v8 < *(_DWORD *)(dword_848B1CC + 8) )
    {
      if ( *(_DWORD *)v3 )
      {
        Com_Printf("%3i ", v8);
        sub_808FE02(v8);
        v0 = sub_810698A(-1653759219 * ((v3 - (_BYTE *)dword_841FB0C) >> 2));
        Com_Printf("%5i ", v0);
        if ( *(_DWORD *)v3 == 2 )
        {
          Com_Printf("CNCT ");
        }
        else if ( *(_DWORD *)v3 == 1 )
        {
          Com_Printf("ZMBI ");
        }
        else
        {
          v2 = *((_DWORD *)v3 + 113001);
          if ( v2 > 9999 )
            v2 = 9999;
          Com_Printf("%4i ", v2);
        }
        Com_Printf("%6i ", *((_DWORD *)v3 + 121213));
        Com_Printf("%s^7", v3 + 134216);
        v4 = 16 - sub_80B5814(v3 + 134216);
        for ( i = 0; i < v4; ++i )
          Com_Printf(" ");
        Com_Printf("%7i ", dword_841FB04 - *((_DWORD *)v3 + 33604));
        s = sub_806AD14(
              *((_DWORD *)v3 + 113009),
              *((_DWORD *)v3 + 113010),
              *((_DWORD *)v3 + 113011),
              *((_DWORD *)v3 + 113012),
              *((_DWORD *)v3 + 113013));
        Com_Printf("%s", s);
        v5 = 22 - strlen(s);
        for ( j = 0; j < v5; ++j )
          Com_Printf(" ");
        Com_Printf("%5i", *((_DWORD *)v3 + 113014));
        Com_Printf(" %5i", *((_DWORD *)v3 + 113002));
        Com_Printf("\n");
      }
      ++v8;
      v3 += 495380;
    }
    Com_Printf("\n");
  }
  else
  {
    Com_Printf("Server is not running.\n");
  }
}
// 819EF14: using guessed type int com_sv_running;
// 841FB08: using guessed type int dword_841FB08;
// 848B1CC: using guessed type int dword_848B1CC;
// 848B1E0: using guessed type int dword_848B1E0;

//----- (0808B8DC) --------------------------------------------------------
void sub_808B8DC()
{
  size_t v0; // eax
  char dest; // [esp+20h] [ebp-418h]
  char *s; // [esp+42Ch] [ebp-Ch]

  if ( *(_BYTE *)(com_sv_running + 8) )
  {
    if ( sub_805FFE6() > 1 )
    {
      strcpy(&dest, "console: ");
      s = sub_80600A0(1);
      if ( *s == 34 )
      {
        v0 = strlen(++s);
        s[v0 - 1] = 0;
      }
      sub_80B57C0(&dest, 1024, s);
      sub_809301C(0, 0, aC_2, 104, &dest);
    }
  }
  else
  {
    Com_Printf("Server is not running.\n");
  }
}
// 819EF14: using guessed type int com_sv_running;

//----- (0808B9A2) --------------------------------------------------------
void sub_808B9A2()
{
  char *v0; // eax
  size_t v1; // eax
  int v2; // [esp+28h] [ebp-420h]
  char *v3; // [esp+2Ch] [ebp-41Ch]
  char dest; // [esp+30h] [ebp-418h]
  char *s; // [esp+43Ch] [ebp-Ch]

  if ( *(_BYTE *)(com_sv_running + 8) )
  {
    if ( sub_805FFE6() > 2 )
    {
      v0 = sub_806001C(1u);
      v2 = atoi(v0);
      if ( v2 >= 0 && v2 < *(_DWORD *)(dword_848B1CC + 8) )
      {
        v3 = (char *)dword_841FB0C + 495380 * v2;
        if ( *((_DWORD *)dword_841FB0C + 123845 * v2) == 4 )
        {
          strcpy(&dest, "console: ");
          s = sub_80600A0(2);
          if ( *s == 34 )
          {
            v1 = strlen(++s);
            s[v1 - 1] = 0;
          }
          sub_80B57C0(&dest, 1024, s);
          sub_809301C((int)v3, 0, aC_2, 104, &dest);
        }
      }
    }
  }
  else
  {
    Com_Printf("Server is not running.\n");
  }
}
// 819EF14: using guessed type int com_sv_running;
// 848B1CC: using guessed type int dword_848B1CC;

//----- (0808BACE) --------------------------------------------------------
void sub_808BACE()
{
  dword_841FB54 = 2147483648;
}
// 841FB54: using guessed type int dword_841FB54;

//----- (0808BADE) --------------------------------------------------------
void sub_808BADE()
{
  char *v0; // eax

  Com_Printf("Server info settings:\n");
  v0 = sub_8063D30(0x404u);
  sub_80611E6(v0);
}

//----- (0808BB06) --------------------------------------------------------
void sub_808BB06()
{
  char *v0; // eax

  Com_Printf("System info settings:\n");
  v0 = sub_8063D30(8u);
  sub_80611E6(v0);
}

//----- (0808BB2E) --------------------------------------------------------
void sub_808BB2E()
{
  char *v0; // [esp+4h] [ebp-4h]

  if ( *(_BYTE *)(com_sv_running + 8) )
  {
    if ( sub_805FFE6() == 2 )
    {
      v0 = sub_808AA30();
      if ( v0 )
      {
        Com_Printf("userinfo\n");
        Com_Printf("--------\n");
        sub_80611E6(v0 + 12);
      }
    }
    else
    {
      Com_Printf("Usage: info <userid>\n");
    }
  }
  else
  {
    Com_Printf("Server is not running.\n");
  }
}
// 819EF14: using guessed type int com_sv_running;

//----- (0808BB9E) --------------------------------------------------------
void *__usercall sub_808BB9E@<eax>(long double a1@<st0>)
{
  return sub_8060BFA(a1, (int)"EXE_SERVERKILLED");
}

//----- (0808BBB2) --------------------------------------------------------
void sub_808BBB2()
{
  sub_8094FFC();
}

//----- (0808BBC0) --------------------------------------------------------
void sub_808BBC0()
{
  sub_8079DEE();
}

//----- (0808BBCE) --------------------------------------------------------
void sub_808BBCE()
{
  sub_8076040();
}

//----- (0808BBDC) --------------------------------------------------------
void sub_808BBDC()
{
  if ( !dword_83DF9E8 )
  {
    dword_83DF9E8 = 1;
    Cmd_AddCommand("heartbeat", (int)sub_808BACE);
    Cmd_AddCommand("onlykick", (int)sub_808B5BA);
    Cmd_AddCommand("banUser", (int)sub_808B4DE);
    Cmd_AddCommand("banClient", (int)sub_808B532);
    Cmd_AddCommand("kick", (int)sub_808B494);
    Cmd_AddCommand("tempBanUser", (int)sub_808B494);
    Cmd_AddCommand("tempBanClient", (int)sub_808B5F2);
    Cmd_AddCommand("unbanUser", (int)sub_808B586);
    Cmd_AddCommand("clientkick", (int)sub_808B5D6);
    Cmd_AddCommand("status", (int)sub_808B63C);
    Cmd_AddCommand("serverinfo", (int)sub_808BADE);
    Cmd_AddCommand("systeminfo", (int)sub_808BB06);
    Cmd_AddCommand("dumpuser", (int)sub_808BB2E);
    Cmd_AddCommand("map_restart", (int)sub_808AFE0);
    Cmd_AddCommand("fast_restart", (int)sub_808AFF4);
    Cmd_AddCommand("map", (int)sub_808AC7E);
    sub_8060598("map", (int)"maps/mp", (int)"d3dbsp");
    Cmd_AddCommand("map_rotate", (int)sub_808B06A);
    Cmd_AddCommand("gameCompleteStatus", (int)sub_808BBB2);
    Cmd_AddCommand("devmap", (int)sub_808AC7E);
    sub_8060598("devmap", (int)"maps/mp", (int)"d3dbsp");
    Cmd_AddCommand("killserver", (int)sub_808BB9E);
    if ( *(_DWORD *)(com_dedicated + 8) )
      sub_808BE02();
    Cmd_AddCommand("scriptUsage", (int)sub_808BBC0);
    Cmd_AddCommand("stringUsage", (int)sub_808BBCE);
  }
}
// 83DF9E8: using guessed type int dword_83DF9E8;
// 8494204: using guessed type int com_dedicated;

//----- (0808BDFC) --------------------------------------------------------
void sub_808BDFC()
{
  ;
}

//----- (0808BE02) --------------------------------------------------------
void sub_808BE02()
{
  Cmd_AddCommand("say", (int)sub_808B8DC);
  Cmd_AddCommand("tell", (int)sub_808B9A2);
}

//----- (0808BE32) --------------------------------------------------------
void sub_808BE32()
{
  Cmd_RemoveCommand("say");
  Cmd_RemoveCommand("tell");
}

//----- (0808BE54) --------------------------------------------------------
void __usercall sub_808BE54(long double a1@<st0>, int a2, int a3, int a4, int a5, int a6)
{
  int v6; // ST18_4
  int v7; // ebx
  char *v8; // eax
  __int16 v9; // ax
  __int16 v10; // ax
  int *v11; // eax
  int v12; // ST34_4
  int v13; // ST38_4
  int v14; // ST3C_4
  int v15; // ST40_4
  char *v16; // eax
  int v17; // [esp+8h] [ebp-60h]
  int v18; // [esp+Ch] [ebp-5Ch]
  int v19; // [esp+10h] [ebp-58h]
  int v20; // [esp+1Ch] [ebp-4Ch]
  int v21; // [esp+20h] [ebp-48h]
  int v22; // [esp+24h] [ebp-44h]
  int *v23; // [esp+50h] [ebp-18h]
  signed int v24; // [esp+54h] [ebp-14h]
  signed int v25; // [esp+58h] [ebp-10h]
  signed int v26; // [esp+5Ch] [ebp-Ch]

  v25 = 0;
  v24 = 0x7FFFFFFF;
  v23 = dword_841FB5C;
  v26 = 0;
  while ( v26 <= 1023 )
  {
    if ( !v23[10] )
    {
      v6 = v23[1];
      v20 = v23[2];
      v21 = v23[3];
      v22 = v23[4];
      if ( sub_806C08C(a2, a3, a4, a5, a6, *v23) )
        break;
    }
    if ( v23[6] < v24 )
    {
      v24 = v23[6];
      v25 = v26;
    }
    ++v26;
    v23 += 12;
  }
  if ( v26 == 1024 )
  {
    v23 = (int *)(48 * v25 + 138541916);
    v7 = rand() << 16;
    dword_841FB70[12 * v25] = dword_841FB04 ^ v7 ^ rand();
    *v23 = a2;
    v23[1] = a3;
    v23[2] = a4;
    v23[3] = a5;
    v23[4] = a6;
    v23[8] = dword_841FB04;
    v23[9] = 0;
    v23[6] = dword_841FB04;
    v23[10] = 0;
    v26 = v25;
  }
  if ( !*(_BYTE *)(dword_81F7114 + 8) )
  {
    v17 = a4;
    v18 = a5;
    v19 = a6;
    if ( Sys_IsLANAddress(a2, a3) )
    {
      v23[7] = dword_841FB04;
      v8 = va("challengeResponse %i", v23[5], a4, a5, a6);
      sub_806C40C(1, a2, a3, a4, a5, a6, v8);
      return;
    }
  }
  if ( !(_BYTE)dword_842BB74 && dword_842BB70 != 1 )
  {
    Com_Printf("Resolving %s\n", "cod2master.activision.com", v17, v18, v19);
    if ( !sub_806C750("cod2master.activision.com", &dword_842BB70) )
    {
      Com_Printf("Couldn't resolve address\n");
      return;
    }
    v9 = sub_80B4F9A(20700);
    dword_842BB78 = v9;
    v10 = sub_80B4F9A(v9);
    Com_Printf(
      "%s resolved to %i.%i.%i.%i:%i\n",
      "cod2master.activision.com",
      (unsigned __int8)dword_842BB74,
      BYTE1(dword_842BB74),
      BYTE2(dword_842BB74),
      HIBYTE(dword_842BB74),
      v10,
      v20,
      v21,
      v22);
  }
  if ( dword_841FB04 - v23[8] <= 5000
    || (v11 = sub_8094E38(),
        v12 = v11[1],
        v13 = v11[2],
        v14 = v11[3],
        v15 = v11[4],
        sub_806C08C(a2, a3, a4, a5, a6, *v11)) )
  {
    sub_808C21C(a1, a2, a3, a4, a5, a6, dword_841FB70[12 * v26]);
  }
  else
  {
    Com_DPrintf("authorize server timed out\n");
    v23[7] = dword_841FB04;
    v16 = va("challengeResponse %i", v23[5]);
    sub_806C40C(1, *v23, v23[1], v23[2], v23[3], v23[4], v16);
  }
}
// 81F7114: using guessed type int dword_81F7114;
// 841FB5C: using guessed type int dword_841FB5C[];
// 841FB70: using guessed type int dword_841FB70[];

//----- (0808C21C) --------------------------------------------------------
void __usercall sub_808C21C(long double a1@<st0>, int a2, int a3, int a4, int a5, int a6, int a7)
{
  char *v7; // eax
  unsigned __int8 v8; // al
  char *v9; // eax
  char dest; // [esp+20h] [ebp-418h]
  unsigned __int8 v11; // [esp+42Bh] [ebp-Dh]
  char *v12; // [esp+42Ch] [ebp-Ch]

  if ( dword_842BB70 != 1 )
  {
    dest = 0;
    v12 = Dvar_RegisterString(a1, "fs_game", (int)&byte_814309B, 4124);
    if ( v12 )
    {
      if ( **((_BYTE **)v12 + 2) )
        strcpy(&dest, *((const char **)v12 + 2));
    }
    v7 = sub_806AD14(a2, a3, a4, a5, a6);
    Com_DPrintf("sending getIpAuthorize for %s\n", v7);
    v8 = Dvar_GetBool("sv_allowAnonymous");
    v11 = v8;
    v9 = va(
           "getIpAuthorize %i %i.%i.%i.%i %s %i",
           a7,
           (unsigned __int8)a3,
           BYTE1(a3),
           BYTE2(a3),
           HIBYTE(a3),
           &dest,
           v8,
           *(_DWORD *)&dest);
    sub_806C40C(1, dword_842BB70, dword_842BB74, *(int *)&dword_842BB78, dword_842BB7C, dword_842BB80, v9);
  }
}

//----- (0808C34C) --------------------------------------------------------
signed int __cdecl sub_808C34C(int a1)
{
  unsigned int i; // [esp+4h] [ebp-4h]

  if ( !a1 )
    return 0;
  for ( i = 0; i <= 0xF; ++i )
  {
    if ( dword_842BB88[2 * i] == a1
      && (long double)(dword_841FB04 - dword_842BB8C[2 * i]) <= *(float *)(dword_848B224 + 8) * 1000.0 )
    {
      return 1;
    }
  }
  return 0;
}
// 842BB88: using guessed type int dword_842BB88[];
// 848B224: using guessed type int dword_848B224;

//----- (0808C3D0) --------------------------------------------------------
signed int __cdecl sub_808C3D0(int a1)
{
  signed int v3; // [esp+14h] [ebp-14h]
  char *nptr; // [esp+1Ch] [ebp-Ch]
  void *v5; // [esp+20h] [ebp-8h]
  void *v6; // [esp+24h] [ebp-4h]

  if ( !a1 )
    return 0;
  if ( FS_ReadFile("ban.txt", &v6) < 0 )
    return 0;
  v5 = v6;
  v3 = 0;
  while ( 1 )
  {
    nptr = Com_Parse((char **)&v5);
    if ( !*nptr )
      break;
    if ( atoi(nptr) == a1 )
    {
      v3 = 1;
      break;
    }
    sub_80B49B8(&v5);
  }
  FS_FreeFile(v6);
  return v3;
}

//----- (0808C46E) --------------------------------------------------------
unsigned int sub_808C46E()
{
  unsigned int v2; // [esp+4h] [ebp-8h]
  unsigned int i; // [esp+8h] [ebp-4h]

  v2 = 0;
  for ( i = 0; i <= 0xF; ++i )
  {
    if ( !dword_842BB88[2 * i] )
      return i;
    if ( dword_842BB8C[2 * i] < dword_842BB8C[2 * v2] )
      v2 = i;
  }
  return v2;
}
// 842BB88: using guessed type int dword_842BB88[];

//----- (0808C4CE) --------------------------------------------------------
int __cdecl sub_808C4CE(int a1)
{
  unsigned int v1; // eax
  unsigned int v2; // edx
  int result; // eax

  v1 = sub_808C46E();
  dword_842BB88[2 * v1] = a1;
  v2 = v1;
  result = dword_841FB04;
  dword_842BB8C[2 * v2] = dword_841FB04;
  return result;
}
// 842BB88: using guessed type int dword_842BB88[];

//----- (0808C4FA) --------------------------------------------------------
void __usercall sub_808C4FA(long double a1@<st0>, int a2)
{
  char dest; // [esp+10h] [ebp-58h]
  int v3; // [esp+5Ch] [ebp-Ch]

  if ( *(_DWORD *)(a2 + 452036) == 2 )
  {
    sub_809301C(0, 0, "%c \"EXE_CANNOTKICKHOSTPLAYER\"", 101);
  }
  else if ( *(_DWORD *)(a2 + 484852) )
  {
    if ( sub_808C3D0(*(_DWORD *)(a2 + 484852)) )
    {
      Com_Printf("This GUID (%i) is already banned\n", *(_DWORD *)(a2 + 484852));
    }
    else if ( FS_FOpenFileByMode("ban.txt", (int)&v3, 2) >= 0 )
    {
      I_strncpyz(&dest, (char *)(a2 + 134216), 64);
      sub_80B587C(&dest);
      FS_Printf(v3, "%i %s\r\n", *(_DWORD *)(a2 + 484852), &dest);
      FS_FCloseFile(v3);
      sub_808DC8C(a1, (char *)a2, "EXE_PLAYERKICKED");
      *(_DWORD *)(a2 + 134416) = dword_841FB04;
    }
  }
  else
  {
    Com_Printf("Can't ban user, GUID is 0\n");
  }
}

//----- (0808C626) --------------------------------------------------------
void __cdecl sub_808C626(char *a1)
{
  signed int v1; // [esp+1Ch] [ebp-6Ch]
  int v2; // [esp+20h] [ebp-68h]
  int v3; // [esp+28h] [ebp-60h]
  void *dest; // [esp+30h] [ebp-58h]
  void *src; // [esp+34h] [ebp-54h]
  int v6; // [esp+38h] [ebp-50h]
  int v7; // [esp+3Ch] [ebp-4Ch]
  char s; // [esp+40h] [ebp-48h]

  v6 = FS_ReadFile("ban.txt", &v7);
  if ( v6 >= 0 )
  {
    I_strncpyz(&s, a1, 64);
    sub_80B587C(&s);
    v3 = strlen(&s);
    v2 = 0;
    src = (void *)v7;
    while ( 1 )
    {
      dest = src;
      if ( !*Com_Parse((char **)&src) )
        break;
      while ( *(_BYTE *)src && *(_BYTE *)src <= 32 )
        src = (char *)src + 1;
      v1 = 0;
      if ( !sub_808FD2A(src, &s, v3) && (*((_BYTE *)src + v3) == 13 || *((_BYTE *)src + v3) == 10) )
        v1 = 1;
      sub_80B49B8(&src);
      if ( v1 )
      {
        ++v2;
        memmove(dest, src, v6 - ((unsigned int)src - v7) + 1);
        v6 -= (_BYTE *)src - (_BYTE *)dest;
        src = dest;
      }
    }
    sub_809E99E("ban.txt", v7, v6);
    FS_FreeFile((void *)v7);
    if ( v2 )
      Com_Printf("unbanned %i user(s) named %s\n", v2, &s);
    else
      Com_Printf("no banned user has name %s\n", &s);
  }
}

//----- (0808C7CA) --------------------------------------------------------
void __cdecl sub_808C7CA(char a1, int a2, int a3, int a4, int a5)
{
  char *v5; // eax
  char *v6; // eax
  int v7; // ebx
  char *v8; // eax
  char *v9; // eax
  char s; // [esp+30h] [ebp-418h]
  char *v11; // [esp+430h] [ebp-18h]
  char *v12; // [esp+434h] [ebp-14h]
  int i; // [esp+438h] [ebp-10h]
  int v14; // [esp+43Ch] [ebp-Ch]

  if ( sub_806BF64(a1, a2, a3, a4, a5, dword_842BB70) )
  {
    v5 = sub_806001C(1u);
    v14 = atoi(v5);
    for ( i = 0; i <= 1023 && dword_841FB70[12 * i] != v14; ++i )
      ;
    if ( i == 1024 )
    {
      Com_Printf("SV_AuthorizeIpPacket: challenge not found\n");
    }
    else
    {
      dword_841FB78[12 * i] = dword_841FB04;
      v12 = sub_806001C(2u);
      v11 = sub_806001C(3u);
      if ( I_stricmp(v12, "demo") )
      {
        if ( I_stricmp(v12, "accept") )
        {
          if ( I_stricmp(v12, "deny") )
          {
            if ( v11 && *v11 )
            {
              sprintf(&s, "error\n%s", v11);
              sub_806C40C(
                1,
                dword_841FB5C[12 * i],
                dword_841FB60[12 * i],
                dword_841FB64[12 * i],
                dword_841FB68[12 * i],
                dword_841FB6C[12 * i],
                &s);
            }
            else
            {
              sub_806C40C(
                1,
                dword_841FB5C[12 * i],
                dword_841FB60[12 * i],
                dword_841FB64[12 * i],
                dword_841FB68[12 * i],
                dword_841FB6C[12 * i],
                "error\nEXE_ERR_BAD_CDKEY");
            }
            memset((void *)(48 * i + 138541916), 0, 0x30u);
          }
          else
          {
            if ( v11 && *v11 )
            {
              if ( I_stricmp(v11, "CLIENT_UNKNOWN_TO_AUTH") )
              {
                if ( I_stricmp(v11, "BAD_CDKEY") )
                {
                  if ( I_stricmp(v11, "INVALID_CDKEY") )
                  {
                    if ( I_stricmp(v11, "BANNED_CDKEY") )
                      sub_806C40C(
                        1,
                        dword_841FB5C[12 * i],
                        dword_841FB60[12 * i],
                        dword_841FB64[12 * i],
                        dword_841FB68[12 * i],
                        dword_841FB6C[12 * i],
                        "error\nEXE_ERR_BAD_CDKEY");
                    else
                      sub_806C40C(
                        1,
                        dword_841FB5C[12 * i],
                        dword_841FB60[12 * i],
                        dword_841FB64[12 * i],
                        dword_841FB68[12 * i],
                        dword_841FB6C[12 * i],
                        "error\nEXE_ERR_BAD_CDKEY");
                  }
                  else
                  {
                    sub_806C40C(
                      1,
                      dword_841FB5C[12 * i],
                      dword_841FB60[12 * i],
                      dword_841FB64[12 * i],
                      dword_841FB68[12 * i],
                      dword_841FB6C[12 * i],
                      "error\nEXE_ERR_CDKEY_IN_USE");
                  }
                }
                else
                {
                  sub_806C40C(
                    1,
                    dword_841FB5C[12 * i],
                    dword_841FB60[12 * i],
                    dword_841FB64[12 * i],
                    dword_841FB68[12 * i],
                    dword_841FB6C[12 * i],
                    "needcdkey");
                }
              }
              else
              {
                sub_806C40C(
                  1,
                  dword_841FB5C[12 * i],
                  dword_841FB60[12 * i],
                  dword_841FB64[12 * i],
                  dword_841FB68[12 * i],
                  dword_841FB6C[12 * i],
                  "needcdkey");
              }
            }
            else
            {
              sub_806C40C(
                1,
                dword_841FB5C[12 * i],
                dword_841FB60[12 * i],
                dword_841FB64[12 * i],
                dword_841FB68[12 * i],
                dword_841FB6C[12 * i],
                "error\nEXE_ERR_CDKEY_IN_USE");
            }
            memset((void *)(48 * i + 138541916), 0, 0x30u);
          }
        }
        else
        {
          v7 = 12 * i;
          v8 = sub_806001C(4u);
          dword_841FB88[v7] = atoi(v8);
          if ( sub_808C3D0(dword_841FB88[12 * i]) )
          {
            Com_Printf("rejected connection from permanently banned GUID %i\n", dword_841FB88[12 * i]);
            sub_806C40C(
              1,
              dword_841FB5C[12 * i],
              dword_841FB60[12 * i],
              dword_841FB64[12 * i],
              dword_841FB68[12 * i],
              dword_841FB6C[12 * i],
              aError_1);
            memset((void *)(48 * i + 138541916), 0, 0x30u);
          }
          else if ( sub_808C34C(dword_841FB88[12 * i]) )
          {
            Com_Printf("rejected connection from temporarily banned GUID %i\n", dword_841FB88[12 * i]);
            sub_806C40C(
              1,
              dword_841FB5C[12 * i],
              dword_841FB60[12 * i],
              dword_841FB64[12 * i],
              dword_841FB68[12 * i],
              dword_841FB6C[12 * i],
              aError_2);
            memset((void *)(48 * i + 138541916), 0, 0x30u);
          }
          else if ( !dword_841FB84[12 * i] )
          {
            v9 = va("challengeResponse %i", dword_841FB70[12 * i]);
            sub_806C40C(
              1,
              dword_841FB5C[12 * i],
              dword_841FB60[12 * i],
              dword_841FB64[12 * i],
              dword_841FB68[12 * i],
              dword_841FB6C[12 * i],
              v9);
          }
        }
      }
      else if ( (unsigned __int8)Dvar_GetBool("fs_restrict") )
      {
        v6 = va("challengeResponse %i", dword_841FB70[12 * i]);
        sub_806C40C(
          1,
          dword_841FB5C[12 * i],
          dword_841FB60[12 * i],
          dword_841FB64[12 * i],
          dword_841FB68[12 * i],
          dword_841FB6C[12 * i],
          v6);
      }
      else
      {
        sub_806C40C(
          1,
          dword_841FB5C[12 * i],
          dword_841FB60[12 * i],
          dword_841FB64[12 * i],
          dword_841FB68[12 * i],
          dword_841FB6C[12 * i],
          "error\nEXE_ERR_NOT_A_DEMO_SERVER");
        memset((void *)(48 * i + 138541916), 0, 0x30u);
      }
    }
  }
  else
  {
    Com_Printf("SV_AuthorizeIpPacket: not from authorize server\n");
  }
}
// 841FB5C: using guessed type int dword_841FB5C[];
// 841FB60: using guessed type int dword_841FB60[];
// 841FB64: using guessed type int dword_841FB64[];
// 841FB68: using guessed type int dword_841FB68[];
// 841FB6C: using guessed type int dword_841FB6C[];
// 841FB70: using guessed type int dword_841FB70[];
// 841FB78: using guessed type int dword_841FB78[];
// 841FB84: using guessed type int dword_841FB84[];

//----- (0808D026) --------------------------------------------------------
int __usercall sub_808D026@<eax>(long double a1@<st0>, int a2)
{
  sub_808E2BE(a2);
  if ( (unsigned __int8)sub_809215C() )
    sub_80F6D74(a1, -1653759219 * ((a2 - (signed int)dword_841FB0C) >> 2));
  sub_8091246(-1653759219 * ((a2 - (signed int)dword_841FB0C) >> 2), &byte_814309B);
  return sub_8094586(a2);
}

//----- (0808D08E) --------------------------------------------------------
void __usercall sub_808D08E(long double a1@<st0>)
{
  _DWORD *v1; // [esp+10h] [ebp-8h]
  int v2; // [esp+14h] [ebp-4h]

  v2 = 0;
  v1 = dword_841FB0C;
  while ( v2 < *(_DWORD *)(dword_848B1CC + 8) )
  {
    if ( *v1 > 1 )
      sub_808D026(a1, (int)v1);
    ++v2;
    v1 += 123845;
  }
  sub_80A9268(dword_841FB0C);
}
// 848B1CC: using guessed type int dword_848B1CC;

//----- (0808D0E6) --------------------------------------------------------
void __usercall sub_808D0E6(long double a1@<st0>, int a2, int a3, int a4, int a5, int a6)
{
  char *v6; // eax
  char *v7; // eax
  char *v8; // eax
  char *v9; // eax
  char *v10; // eax
  int v11; // ST18_4
  int v12; // ST1C_4
  int v13; // ST20_4
  int v14; // ST24_4
  char *v15; // eax
  int v16; // ST18_4
  int v17; // ST1C_4
  int v18; // ST20_4
  int v19; // ST24_4
  char *v20; // eax
  int v21; // ST18_4
  int v22; // ST1C_4
  int v23; // ST20_4
  int v24; // ST24_4
  char *v25; // eax
  const char *s1; // ST48_4
  char *v27; // eax
  char v28; // [esp+36h] [ebp-442h]
  char v29; // [esp+37h] [ebp-441h]
  int v30; // [esp+38h] [ebp-440h]
  int v31; // [esp+3Ch] [ebp-43Ch]
  const char *v32; // [esp+40h] [ebp-438h]
  int v33; // [esp+44h] [ebp-434h]
  int v34; // [esp+4Ch] [ebp-42Ch]
  int v35; // [esp+50h] [ebp-428h]
  int v36; // [esp+54h] [ebp-424h]
  int v37; // [esp+58h] [ebp-420h]
  _DWORD *s; // [esp+60h] [ebp-418h]
  _DWORD *v39; // [esp+64h] [ebp-414h]
  _DWORD *v40; // [esp+64h] [ebp-414h]
  char *v41; // [esp+64h] [ebp-414h]
  int v42; // [esp+68h] [ebp-410h]
  int v43; // [esp+6Ch] [ebp-40Ch]
  signed int i; // [esp+6Ch] [ebp-40Ch]
  int j; // [esp+6Ch] [ebp-40Ch]
  int v46; // [esp+6Ch] [ebp-40Ch]
  char dest; // [esp+70h] [ebp-408h]

  Com_DPrintf("SV_DirectConnect()\n");
  v6 = sub_806001C(1u);
  I_strncpyz(&dest, v6, 1024);
  v7 = sub_80B5B30(&dest, (int)"protocol");
  v36 = atoi(v7);
  if ( v36 != 115 )
  {
    v8 = va(aErrorExeServer_0, "1.0");
    sub_806C40C(1, a2, a3, a4, a5, a6, v8);
    Com_DPrintf("    rejected connect from protocol version %i (should be %i)\n", v36, 115);
    return;
  }
  v9 = sub_80B5B30(&dest, (int)"challenge");
  v34 = atoi(v9);
  v10 = sub_80B5B30(&dest, (int)"qport");
  v35 = atoi(v10);
  v43 = 0;
  v39 = dword_841FB0C;
  while ( v43 < *(_DWORD *)(dword_848B1CC + 8) )
  {
    v29 = 0;
    v11 = v39[113010];
    v12 = v39[113011];
    v13 = v39[113012];
    v14 = v39[113013];
    if ( sub_806BF64(a2, a3, a4, a5, a6, v39[113009]) && (v39[113014] == v35 || (_WORD)a4 == *((_WORD *)v39 + 226022)) )
      v29 = 1;
    if ( v29 )
    {
      if ( dword_841FB04 - v39[33605] < 1000 * *(_DWORD *)(dword_848B1D8 + 8) )
      {
        v15 = sub_806AD14(a2, a3, a4, a5, a6);
        Com_DPrintf("%s:reconnect rejected : too soon\n", v15);
        return;
      }
      break;
    }
    ++v43;
    v39 += 123845;
  }
  v42 = 0;
  if ( sub_806C0BA(a2) )
    goto LABEL_67;
  for ( i = 0; i <= 1023; ++i )
  {
    v16 = dword_841FB60[12 * i];
    v17 = dword_841FB64[12 * i];
    v18 = dword_841FB68[12 * i];
    v19 = dword_841FB6C[12 * i];
    if ( sub_806C08C(a2, a3, a4, a5, a6, dword_841FB5C[12 * i]) && v34 == dword_841FB70[12 * i] )
    {
      v42 = dword_841FB88[12 * i];
      break;
    }
  }
  if ( i == 1024 )
  {
    sub_806C40C(1, a2, a3, a4, a5, a6, "error\nEXE_BAD_CHALLENGE");
    return;
  }
  if ( dword_841FB80[12 * i] )
  {
    v30 = dword_841FB80[12 * i];
  }
  else
  {
    v30 = dword_841FB04 - dword_841FB78[12 * i];
    dword_841FB80[12 * i] = v30;
  }
  v20 = sub_806AD14(a2, a3, a4, a5, a6);
  Com_Printf("Client %i connecting with %i challenge ping from %s\n", i, v30, v20);
  dword_841FB84[12 * i] = 1;
  if ( Sys_IsLANAddress(a2, a3) )
    goto LABEL_67;
  if ( *(_DWORD *)(dword_848B1EC + 8) && v30 < *(_DWORD *)(dword_848B1EC + 8) )
  {
    sub_806C40C(1, a2, a3, a4, a5, a6, "error\nEXE_ERR_HIGH_PING_ONLY");
    Com_DPrintf("Client %i rejected on a too low ping\n", i);
    return;
  }
  if ( !*(_DWORD *)(dword_848B1F0 + 8) || v30 <= *(_DWORD *)(dword_848B1F0 + 8) )
  {
LABEL_67:
    j = 0;
    v40 = dword_841FB0C;
    while ( j < *(_DWORD *)(dword_848B1CC + 8) )
    {
      if ( *v40 )
      {
        v28 = 0;
        v21 = v40[113010];
        v22 = v40[113011];
        v23 = v40[113012];
        v24 = v40[113013];
        if ( sub_806BF64(a2, a3, a4, a5, a6, v40[113009])
          && (v40[113014] == v35 || (_WORD)a4 == *((_WORD *)v40 + 226022)) )
        {
          v28 = 1;
        }
        if ( v28 )
        {
          v25 = sub_806AD14(a2, a3, a4, a5, a6);
          Com_Printf("%s:reconnect\n", v25);
          if ( *v40 > 1 )
            sub_808D026(a1, (int)v40);
          s = v40;
          memset(v40, 0, 0x78F14u);
          goto LABEL_55;
        }
      }
      ++j;
      v40 += 123845;
    }
    s1 = sub_80B5B30(&dest, (int)"password");
    if ( !strcmp(s1, *(const char **)(dword_848B1C4 + 8)) )
      v33 = 0;
    else
      v33 = *(_DWORD *)(dword_848B1D0 + 8);
    s = 0;
    for ( j = v33; j < *(_DWORD *)(dword_848B1CC + 8); ++j )
    {
      v40 = (char *)dword_841FB0C + 495380 * j;
      if ( !*((_DWORD *)dword_841FB0C + 123845 * j) )
      {
        s = (char *)dword_841FB0C + 495380 * j;
        break;
      }
    }
    if ( !s )
    {
      sub_806C40C(1, a2, a3, a4, a5, a6, "error\nEXE_SERVERISFULL");
      Com_DPrintf("Rejected a connection.\n");
      return;
    }
    v40[33284] = 0;
    v40[33283] = 0;
    memset(s, 0, 0x78F14u);
LABEL_55:
    v37 = -1653759219 * (((char *)s - (_BYTE *)dword_841FB0C) >> 2);
    s[33553] = sub_808FDE4(-1653759219 * (((char *)s - (_BYTE *)dword_841FB0C) >> 2));
    *((_WORD *)s + 242428) = sub_807B658();
    s[33288] = v34;
    s[121213] = v42;
    sub_806B510(1, s + 113005, a2, a3, a4, a5, a6, v35);
    s[123827] = 0;
    *((_BYTE *)s + 495376) = 1;
    I_strncpyz((char *)s + 12, &dest, 1024);
    v32 = sub_80F6722(a1, v37, *((_WORD *)s + 242428));
    if ( v32 )
    {
      v27 = va("error\n%s", v32);
      sub_806C40C(1, a2, a3, a4, a5, a6, v27);
      Com_DPrintf("Game rejected a connection: %s.\n", v32);
      sub_8094586((int)s);
    }
    else
    {
      Com_Printf("Going from CS_FREE to CS_CONNECTED for %s (num %i guid %i)\n", s + 33554, v37, s[121213]);
      *s = 2;
      s[33606] = dword_841FB04;
      s[33604] = dword_841FB04;
      s[33605] = dword_841FB04;
      sub_808EEFE((int)s);
      dword_841FB80[12 * j] = 0;
      sub_806C40C(1, a2, a3, a4, a5, a6, "connectResponse");
      s[33287] = -1;
      v31 = 0;
      v46 = 0;
      v41 = (char *)dword_841FB0C;
      while ( v46 < *(_DWORD *)(dword_848B1CC + 8) )
      {
        if ( *((_DWORD *)dword_841FB0C + 123845 * v46) > 1 )
          ++v31;
        ++v46;
        v41 += 495380;
      }
      if ( v31 == 1 || v31 == *(_DWORD *)(dword_848B1CC + 8) )
        sub_808BACE();
    }
  }
  else
  {
    sub_806C40C(1, a2, a3, a4, a5, a6, "error\nEXE_ERR_LOW_PING_ONLY");
    Com_DPrintf("Client %i rejected on a too high ping: %i\n", i, v30);
  }
}
// 841FB08: using guessed type int dword_841FB08;
// 841FB5C: using guessed type int dword_841FB5C[];
// 841FB60: using guessed type int dword_841FB60[];
// 841FB64: using guessed type int dword_841FB64[];
// 841FB68: using guessed type int dword_841FB68[];
// 841FB6C: using guessed type int dword_841FB6C[];
// 841FB70: using guessed type int dword_841FB70[];
// 841FB78: using guessed type int dword_841FB78[];
// 841FB80: using guessed type int dword_841FB80[];
// 841FB84: using guessed type int dword_841FB84[];
// 848B1C4: using guessed type int dword_848B1C4;
// 848B1CC: using guessed type int dword_848B1CC;
// 848B1D0: using guessed type int dword_848B1D0;
// 848B1D8: using guessed type int dword_848B1D8;
// 848B1EC: using guessed type int dword_848B1EC;
// 848B1F0: using guessed type int dword_848B1F0;

//----- (0808DC2C) --------------------------------------------------------
int sub_808DC2C()
{
  int result; // eax
  _WORD *i; // [esp+Ch] [ebp-Ch]
  int v2; // [esp+10h] [ebp-8h]

  v2 = 0;
  for ( i = dword_841FB0C; ; i += 247690 )
  {
    result = v2;
    if ( v2 >= *(_DWORD *)(dword_848B1CC + 8) )
      break;
    if ( *(_DWORD *)i > 1 )
    {
      sub_8094586((int)i);
      i[242428] = sub_807B658();
    }
    ++v2;
  }
  return result;
}
// 848B1CC: using guessed type int dword_848B1CC;

//----- (0808DC8C) --------------------------------------------------------
void __usercall sub_808DC8C(long double a1@<st0>, char *a2, char *a3)
{
  int v3; // [esp+18h] [ebp-20h]
  int v4; // [esp+1Ch] [ebp-1Ch]
  int v5; // [esp+20h] [ebp-18h]
  int v6; // [esp+24h] [ebp-14h]
  int *v7; // [esp+30h] [ebp-8h]
  signed int v8; // [esp+34h] [ebp-4h]
  int i; // [esp+34h] [ebp-4h]

  if ( *(_DWORD *)a2 != 1 )
  {
    *((_DWORD *)a2 + 2) = 0;
    sub_808D026(a1, (int)a2);
    Com_DPrintf("Going to CS_ZOMBIE for %s\n", a2 + 134216);
    *(_DWORD *)a2 = 1;
    if ( !*((_DWORD *)a2 + 33553) )
    {
      v7 = dword_841FB5C;
      v8 = 0;
      while ( v8 <= 1023 )
      {
        v3 = v7[1];
        v4 = v7[2];
        v5 = v7[3];
        v6 = v7[4];
        if ( sub_806C08C(
               *((_DWORD *)a2 + 113009),
               *((_DWORD *)a2 + 113010),
               *((_DWORD *)a2 + 113011),
               *((_DWORD *)a2 + 113012),
               *((_DWORD *)a2 + 113013),
               *v7) )
        {
          v7[10] = 0;
          break;
        }
        ++v8;
        v7 += 12;
      }
    }
    if ( I_stricmp(a3, "EXE_DISCONNECTED") )
      sub_809301C(0, 0, aC_3, 101, a2 + 134216, a3, v3, v4, v5, v6);
    Com_Printf("%i:%s %s\n", -1653759219 * ((a2 - (_BYTE *)dword_841FB0C) >> 2), a2 + 134216, a3);
    sub_809301C(0, 1, "%c %d", 74, -1653759219 * ((a2 - (_BYTE *)dword_841FB0C) >> 2));
    sub_809301C((int)a2, 1, "%c \"%s\"", 119, a3);
    for ( i = 0; i < *(_DWORD *)(dword_848B1CC + 8) && *((_DWORD *)dword_841FB0C + 123845 * i) <= 1; ++i )
      ;
    if ( i == *(_DWORD *)(dword_848B1CC + 8) )
      sub_808BACE();
  }
}
// 841FB08: using guessed type int dword_841FB08;
// 841FB5C: using guessed type int dword_841FB5C[];
// 848B1CC: using guessed type int dword_848B1CC;

//----- (0808DEA6) --------------------------------------------------------
_DWORD *__cdecl sub_808DEA6(_DWORD *a1, _DWORD *a2)
{
  _DWORD *result; // eax

  result = a1;
  if ( *a1 != 1 )
  {
    result = a1;
    if ( !a1[2] )
    {
      result = a2;
      a1[2] = a2;
    }
  }
  return result;
}

//----- (0808DECA) --------------------------------------------------------
int __usercall sub_808DECA@<eax>(long double a1@<st0>, char *a2)
{
  char *v3; // [esp+1Ch] [ebp-13Ch]
  char v4; // [esp+20h] [ebp-138h]
  int v5; // [esp+30h] [ebp-128h]
  char v6[4]; // [esp+3Ch] [ebp-11Ch]
  char s; // [esp+50h] [ebp-108h]
  int *v8; // [esp+148h] [ebp-10h]
  int i; // [esp+14Ch] [ebp-Ch]

  sub_80AA1F6((int *)&v4, 0x4000);
  v3 = sub_80AA240((int *)&v4);
  while ( *(_DWORD *)a2 && *((_DWORD *)a2 + 117113) )
    sub_809558C((int)(a2 + 452020));
  Com_DPrintf("SV_SendClientGameState() for %s\n", a2 + 134216);
  Com_DPrintf("Going from CS_CONNECTED to CS_PRIMED for %s\n", a2 + 134216);
  *(_DWORD *)a2 = 3;
  *((_DWORD *)a2 + 113004) = 0;
  *((_DWORD *)a2 + 33287) = *((_DWORD *)a2 + 113005);
  sub_8067718(&v5, (int)v3, 0x4000);
  sub_8067C2A(&v5, *((_DWORD *)a2 + 33296));
  sub_80966D6(a2, &v5);
  sub_8067B4C(&v5, 1);
  sub_8067C2A(&v5, *((_DWORD *)a2 + 33283));
  for ( i = 0; i <= 2047; ++i )
  {
    if ( *dword_842C098[i] )
    {
      sub_8067B4C(&v5, 2);
      sub_8067BDA(&v5, i);
      sub_8067D96((int)&v5, dword_842C098[i]);
    }
  }
  memset(&s, 0, 0xF0u);
  for ( i = 0; i <= 1023; ++i )
  {
    v8 = (int *)(372 * i + 138600604);
    if ( *((_DWORD *)&unk_842E09C + 93 * i) )
    {
      sub_8067B4C(&v5, 3);
      sub_806938C(&v5, (int *)&s, v8, 1);
    }
  }
  sub_8067B4C(&v5, 7);
  sub_8067C2A(&v5, -1653759219 * ((a2 - (_BYTE *)dword_841FB0C) >> 2));
  sub_8067C2A(&v5, dword_842BC8C);
  sub_8067B4C(&v5, 7);
  Com_DPrintf(
    "Sending %i bytes in gamestate to client: %i\n",
    *(_DWORD *)v6,
    -1653759219 * ((a2 - (_BYTE *)dword_841FB0C) >> 2));
  sub_80989C6(a1, (int)&v5, (int)a2);
  return sub_80AA22A((int *)&v4);
}
// 841FB08: using guessed type int dword_841FB08;
// 842BC8C: using guessed type int dword_842BC8C;

//----- (0808E1F0) --------------------------------------------------------
int __cdecl sub_808E1F0(_DWORD *a1, _DWORD *a2)
{
  int v2; // ST14_4
  int *v3; // eax
  _DWORD *v4; // ecx

  Com_DPrintf("Going from CS_PRIMED to CS_ACTIVE for %s\n", a1 + 33554);
  *a1 = 4;
  v2 = -1653759219 * (((char *)a1 - (_BYTE *)dword_841FB0C) >> 2);
  v3 = (int *)sub_808FDE4(-1653759219 * (((char *)a1 - (_BYTE *)dword_841FB0C) >> 2));
  *v3 = v2;
  a1[33553] = v3;
  a1[33602] = -1;
  a1[33606] = dword_841FB04;
  v4 = a1 + 33289;
  *v4 = *a2;
  v4[1] = a2[1];
  v4[2] = a2[2];
  v4[3] = a2[3];
  v4[4] = a2[4];
  v4[5] = a2[5];
  v4[6] = a2[6];
  return sub_80F6954(-1653759219 * (((char *)a1 - (_BYTE *)dword_841FB0C) >> 2));
}
// 841FB08: using guessed type int dword_841FB08;

//----- (0808E2BE) --------------------------------------------------------
int *__cdecl sub_808E2BE(int a1)
{
  int *result; // eax
  int i; // [esp+4h] [ebp-4h]

  if ( *(_DWORD *)(a1 + 134312) )
    FS_FCloseFile(*(_DWORD *)(a1 + 134312));
  *(_DWORD *)(a1 + 134312) = 0;
  result = (int *)(a1 + 134248);
  *(_BYTE *)(a1 + 134248) = 0;
  for ( i = 0; i <= 7; ++i )
  {
    if ( *(_DWORD *)(a1 + 4 * i + 134336) )
    {
      Z_FreeInternal(*(void **)(a1 + 4 * i + 134336));
      *(_DWORD *)(a1 + 4 * i + 134336) = 0;
    }
    result = &i;
  }
  return result;
}

//----- (0808E348) --------------------------------------------------------
int *__cdecl sub_808E348(int a1)
{
  if ( *(_BYTE *)(a1 + 134248) )
    Com_DPrintf(
      "clientDownload: %d : file \"%s\" aborted\n",
      -1653759219 * ((a1 - (signed int)dword_841FB0C) >> 2),
      a1 + 134248);
  return sub_808E2BE(a1);
}
// 841FB08: using guessed type int dword_841FB08;

//----- (0808E398) --------------------------------------------------------
int __usercall sub_808E398@<eax>(long double a1@<st0>, char *a2)
{
  Com_DPrintf("clientDownload: %s Done\n", a2 + 134216);
  return sub_808DECA(a1, a2);
}

//----- (0808E3C4) --------------------------------------------------------
int __cdecl sub_808E3C4(int a1)
{
  char *v1; // eax
  int result; // eax

  v1 = sub_806001C(1u);
  result = atoi(v1);
  if ( result == *(_DWORD *)(a1 + 134324) )
  {
    result = a1;
    *(_DWORD *)(a1 + 134332) = *(_DWORD *)(a1 + 134324);
  }
  return result;
}

//----- (0808E404) --------------------------------------------------------
void __usercall sub_808E404(long double a1@<st0>, int a2)
{
  char *v2; // eax
  int v3; // [esp+24h] [ebp-4h]

  v2 = sub_806001C(1u);
  v3 = atoi(v2);
  if ( v3 == *(_DWORD *)(a2 + 134324) )
  {
    Com_DPrintf(
      "clientDownload: %d : client acknowledge of block %d\n",
      -1653759219 * ((a2 - (signed int)dword_841FB0C) >> 2),
      v3);
    if ( *(_DWORD *)(a2 + 4 * (*(_DWORD *)(a2 + 134324) % 8) + 134368) )
    {
      *(_DWORD *)(a2 + 134404) = dword_841FB04;
      ++*(_DWORD *)(a2 + 134324);
    }
    else
    {
      Com_Printf(
        "clientDownload: %d : file \"%s\" completed\n",
        -1653759219 * ((a2 - (signed int)dword_841FB0C) >> 2),
        a2 + 134248);
      sub_808E2BE(a2);
    }
  }
  else
  {
    sub_808DC8C(a1, (char *)a2, "broken download");
  }
}
// 841FB08: using guessed type int dword_841FB08;

//----- (0808E508) --------------------------------------------------------
char *__cdecl sub_808E508(int a1)
{
  char *v1; // eax

  sub_808E2BE(a1);
  v1 = sub_806001C(1u);
  return I_strncpyz((char *)(a1 + 134248), v1, 64);
}

//----- (0808E544) --------------------------------------------------------
int *__cdecl sub_808E544(int a1, _DWORD *a2)
{
  int *result; // eax
  char s; // [esp+30h] [ebp-418h]
  int v4; // [esp+430h] [ebp-18h]
  int v5; // [esp+434h] [ebp-14h]
  int v6; // [esp+438h] [ebp-10h]
  int v7; // [esp+43Ch] [ebp-Ch]

  result = (int *)(a1 + 134248);
  if ( *(_BYTE *)(a1 + 134248) )
  {
    if ( *(_DWORD *)(a1 + 134312) )
    {
LABEL_15:
      while ( *(_DWORD *)(a1 + 134328) - *(_DWORD *)(a1 + 134324) <= 7
           && *(_DWORD *)(a1 + 134316) != *(_DWORD *)(a1 + 134320) )
      {
        v7 = *(_DWORD *)(a1 + 134328) % 8;
        if ( !*(_DWORD *)(a1 + 4 * v7 + 134336) )
          *(_DWORD *)(a1 + 4 * v7 + 134336) = Z_MallocInternal(0x800u);
        *(_DWORD *)(a1 + 4 * v7 + 134368) = FS_Read(
                                              *(_DWORD *)(a1 + 4 * v7 + 134336),
                                              0x800u,
                                              *(_DWORD *)(a1 + 134312));
        if ( *(_DWORD *)(a1 + 4 * v7 + 134368) < 0 )
        {
          *(_DWORD *)(a1 + 134320) = *(_DWORD *)(a1 + 134316);
          break;
        }
        *(_DWORD *)(a1 + 134320) += *(_DWORD *)(a1 + 4 * v7 + 134368);
        ++*(_DWORD *)(a1 + 134328);
      }
      if ( *(_DWORD *)(a1 + 134320) == *(_DWORD *)(a1 + 134316)
        && !*(_DWORD *)(a1 + 134400)
        && *(_DWORD *)(a1 + 134328) - *(_DWORD *)(a1 + 134324) <= 7 )
      {
        *(_DWORD *)(a1 + 4 * ((*(_DWORD *)(a1 + 134328))++ % 8) + 134368) = 0;
        *(_DWORD *)(a1 + 134400) = 1;
      }
      v6 = *(_DWORD *)(a1 + 452008);
      if ( *(_DWORD *)(dword_848B1E8 + 8) )
      {
        if ( *(_DWORD *)(dword_848B1E8 + 8) <= 999 )
          Dvar_SetInt(dword_848B1E8, (char *)0x3E8);
        if ( *(_DWORD *)(dword_848B1E8 + 8) < v6 )
          v6 = *(_DWORD *)(dword_848B1E8 + 8);
      }
      if ( v6 )
        v5 = (*(_DWORD *)(a1 + 452012) * v6 / 1000 + 2048) / 2048;
      else
        v5 = 1;
      if ( v5 < 0 )
        v5 = 1;
      while ( 1 )
      {
        result = &v5;
        if ( --v5 == -1 )
          break;
        result = *(int **)(a1 + 134324);
        if ( result == *(int **)(a1 + 134328) )
          break;
        if ( *(_DWORD *)(a1 + 134332) == *(_DWORD *)(a1 + 134328) )
        {
          result = (int *)(dword_841FB04 - *(_DWORD *)(a1 + 134404));
          if ( (signed int)result <= 1000 )
            return result;
          *(_DWORD *)(a1 + 134332) = *(_DWORD *)(a1 + 134324);
        }
        v7 = *(_DWORD *)(a1 + 134332) % 8;
        sub_8067B4C(a2, 5);
        sub_8067BDA(a2, *(_DWORD *)(a1 + 134332));
        if ( !*(_DWORD *)(a1 + 134332) )
          sub_8067C2A(a2, *(_DWORD *)(a1 + 134316));
        sub_8067BDA(a2, *(_DWORD *)(a1 + 4 * v7 + 134368));
        if ( *(_DWORD *)(a1 + 4 * v7 + 134368) )
          sub_8067B84((int)a2, *(void **)(a1 + 4 * v7 + 134336), *(_DWORD *)(a1 + 4 * v7 + 134368));
        Com_DPrintf(
          "clientDownload: %d : writing block %d\n",
          -1653759219 * ((a1 - (signed int)dword_841FB0C) >> 2),
          *(_DWORD *)(a1 + 134332));
        ++*(_DWORD *)(a1 + 134332);
        *(_DWORD *)(a1 + 134404) = dword_841FB04;
      }
    }
    else
    {
      Com_Printf(
        "clientDownload: %d : begining \"%s\"\n",
        -1653759219 * ((a1 - (signed int)dword_841FB0C) >> 2),
        a1 + 134248);
      v4 = sub_8064ECC((char *)(a1 + 134248), (int)"main");
      if ( *(_BYTE *)(dword_848B1C8 + 8) )
      {
        if ( !v4 )
        {
          *(_DWORD *)(a1 + 134316) = FS_SV_FOpenFileRead((char *)(a1 + 134248), a1 + 134312);
          if ( *(_DWORD *)(a1 + 134316) > 0 )
          {
            *(_DWORD *)(a1 + 134332) = 0;
            *(_DWORD *)(a1 + 134324) = 0;
            *(_DWORD *)(a1 + 134328) = 0;
            *(_DWORD *)(a1 + 134320) = 0;
            *(_DWORD *)(a1 + 134400) = 0;
            goto LABEL_15;
          }
        }
      }
      if ( v4 )
      {
        Com_Printf(
          "clientDownload: %d : \"%s\" cannot download iwd files\n",
          -1653759219 * ((a1 - (signed int)dword_841FB0C) >> 2),
          a1 + 134248);
        Com_sprintf(&s, 0x400u, aExeCantautodlg, a1 + 134248);
      }
      else if ( *(_BYTE *)(dword_848B1C8 + 8) )
      {
        Com_Printf(
          "clientDownload: %d : \"%s\" file not found on server\n",
          -1653759219 * ((a1 - (signed int)dword_841FB0C) >> 2),
          a1 + 134248);
        Com_sprintf(&s, 0x400u, aExeAutodlFilen, a1 + 134248);
      }
      else
      {
        Com_Printf(
          "clientDownload: %d : \"%s\" download disabled",
          -1653759219 * ((a1 - (signed int)dword_841FB0C) >> 2),
          a1 + 134248);
        if ( *(_BYTE *)(dword_848B200 + 8) )
          Com_sprintf(&s, 0x400u, aExeAutodlServe, a1 + 134248);
        else
          Com_sprintf(&s, 0x400u, aExeAutodlServe_0, a1 + 134248);
      }
      sub_8067B4C(a2, 5);
      sub_8067BDA(a2, 0);
      sub_8067C2A(a2, -1);
      sub_8067CE4((int)a2, &s);
      result = (int *)(a1 + 134248);
      *(_BYTE *)(a1 + 134248) = 0;
    }
  }
  return result;
}
// 848B1C8: using guessed type int dword_848B1C8;
// 848B1E8: using guessed type int dword_848B1E8;
// 848B200: using guessed type int dword_848B200;

//----- (0808EC4A) --------------------------------------------------------
void __usercall sub_808EC4A(long double a1@<st0>, char *a2)
{
  sub_808DC8C(a1, a2, "EXE_DISCONNECTED");
}

//----- (0808EC66) --------------------------------------------------------
int __cdecl sub_808EC66(int a1)
{
  unsigned int v1; // ST00_4
  int v2; // ebx
  unsigned int v3; // ST00_4
  char *v4; // eax
  char *v5; // ST1C_4
  int v6; // ebx
  char *v7; // eax
  int result; // eax
  signed int v9; // [esp+14h] [ebp-2034h]
  int v10[1024]; // [esp+20h] [ebp-2028h]
  int v11[1025]; // [esp+1020h] [ebp-1028h]
  int v12; // [esp+2024h] [ebp-24h]
  int j; // [esp+2028h] [ebp-20h]
  int i; // [esp+202Ch] [ebp-1Ch]
  int v15; // [esp+2030h] [ebp-18h]
  int v16; // [esp+2034h] [ebp-14h]
  int v17; // [esp+2038h] [ebp-10h]
  int v18; // [esp+203Ch] [ebp-Ch]

  v9 = 1;
  v17 = 0;
  v18 = 0;
  v16 = sub_805FFE6();
  v12 = 1;
  if ( v16 > 1 )
  {
    v1 = v12++;
    if ( *sub_806001C(v1) == 64 )
    {
      i = 0;
      while ( v12 < v16 )
      {
        v2 = i;
        v3 = v12++;
        v4 = sub_806001C(v3);
        v11[v2] = atoi(v4);
        ++i;
      }
      v16 = i - 1;
      for ( i = 0; i < v16; ++i )
      {
        for ( j = 0; j < v16; ++j )
        {
          if ( i != j && v11[i] == v11[j] )
          {
            v9 = 0;
            break;
          }
        }
        if ( !v9 )
          break;
      }
      if ( v9 )
      {
        v5 = sub_806554C();
        sub_8060448(v5);
        v15 = sub_805FFE6();
        if ( v15 > 1024 )
          v15 = 1024;
        for ( i = 0; i < v15; ++i )
        {
          v6 = i;
          v7 = sub_806001C(i);
          v10[v6] = atoi(v7);
        }
        for ( i = 0; i < v16; ++i )
        {
          for ( j = 0; j < v15 && v11[i] != v10[j]; ++j )
            ;
          if ( j >= v15 )
          {
            v9 = 0;
            break;
          }
        }
        if ( v9 )
        {
          v18 = dword_842BC8C;
          for ( i = 0; i < v16; ++i )
            v18 ^= v11[i];
          v18 ^= v16;
          if ( v18 != v11[v16] )
            v9 = 0;
        }
      }
    }
    else
    {
      v9 = 0;
    }
  }
  else
  {
    v9 = 0;
  }
  if ( v9 )
  {
    result = a1;
    *(_DWORD *)(a1 + 452016) = 1;
  }
  else
  {
    result = a1;
    *(_DWORD *)(a1 + 452016) = 2;
  }
  return result;
}
// 842BC8C: using guessed type int dword_842BC8C;
// 808EC66: using guessed type int var_1028[1025];
// 808EC66: using guessed type int var_2028[1024];

//----- (0808EEEC) --------------------------------------------------------
int __cdecl sub_808EEEC(int a1)
{
  int result; // eax

  result = a1;
  *(_DWORD *)(a1 + 452016) = 0;
  return result;
}

//----- (0808EEFE) --------------------------------------------------------
int __cdecl sub_808EEFE(int a1)
{
  char *v1; // eax
  int v2; // ST08_4
  int v3; // ST0C_4
  int v4; // ST10_4
  const char *v5; // ST20_4
  int result; // eax
  char v7; // [esp+1Bh] [ebp-Dh]
  int v8; // [esp+1Ch] [ebp-Ch]
  const char *nptr; // [esp+20h] [ebp-8h]
  const char *nptra; // [esp+20h] [ebp-8h]

  v1 = sub_80B5B30((char *)(a1 + 12), (int)"name");
  I_strncpyz((char *)(a1 + 134216), v1, 32);
  v7 = 0;
  v2 = *(_DWORD *)(a1 + 452044);
  v3 = *(_DWORD *)(a1 + 452048);
  v4 = *(_DWORD *)(a1 + 452052);
  if ( Sys_IsLANAddress(*(_DWORD *)(a1 + 452036), *(_DWORD *)(a1 + 452040)) && *(_DWORD *)(com_dedicated + 8) != 2 )
    v7 = 1;
  if ( v7 )
  {
    *(_DWORD *)(a1 + 452008) = 99999;
  }
  else
  {
    nptr = sub_80B5B30((char *)(a1 + 12), (int)"rate");
    if ( *nptr )
    {
      *(_DWORD *)(a1 + 452008) = atoi(nptr);
      if ( *(_DWORD *)(a1 + 452008) > 999 )
      {
        if ( *(_DWORD *)(a1 + 452008) > 90000 )
          *(_DWORD *)(a1 + 452008) = 90000;
      }
      else
      {
        *(_DWORD *)(a1 + 452008) = 1000;
      }
    }
    else
    {
      *(_DWORD *)(a1 + 452008) = 5000;
    }
  }
  nptra = sub_80B5B30((char *)(a1 + 12), (int)"snaps");
  if ( *nptra )
  {
    v8 = atoi(nptra);
    if ( v8 > 0 )
    {
      if ( v8 > 30 )
        v8 = 30;
    }
    else
    {
      v8 = 1;
    }
    *(_DWORD *)(a1 + 452012) = 1000 / v8;
  }
  else
  {
    *(_DWORD *)(a1 + 452012) = 50;
  }
  v5 = sub_80B5B30((char *)(a1 + 12), (int)"cl_voice");
  *(_BYTE *)(a1 + 495376) = atoi(v5) > 0;
  result = a1;
  if ( *(_DWORD *)(a1 + 452008) <= 4999 )
  {
    result = a1;
    *(_BYTE *)(a1 + 495376) = 0;
  }
  return result;
}
// 8494204: using guessed type int com_dedicated;

//----- (0808F0E6) --------------------------------------------------------
int __cdecl sub_808F0E6(int a1)
{
  char *v1; // eax

  v1 = sub_806001C(1u);
  I_strncpyz((char *)(a1 + 12), v1, 1024);
  sub_808EEFE(a1);
  return sub_80F6506(-1653759219 * ((a1 - (signed int)dword_841FB0C) >> 2));
}
// 841FB08: using guessed type int dword_841FB08;

//----- (0808F13C) --------------------------------------------------------
void __cdecl sub_808F13C(int a1)
{
  char *v1; // eax
  int v2; // [esp+14h] [ebp-4h]

  v1 = sub_806001C(1u);
  v2 = atoi(v1);
  if ( v2 >= 0 && v2 <= 64 )
    *(_BYTE *)(v2 + a1 + 495312) = 1;
  else
    Com_Printf("Invalid mute client %i\n", v2);
}

//----- (0808F18C) --------------------------------------------------------
void __cdecl sub_808F18C(int a1)
{
  char *v1; // eax
  int v2; // [esp+14h] [ebp-4h]

  v1 = sub_806001C(1u);
  v2 = atoi(v1);
  if ( v2 >= 0 && v2 <= 64 )
    *(_BYTE *)(v2 + a1 + 495312) = 0;
  else
    Com_Printf("Invalid unmute client %i\n", v2);
}

//----- (0808F1DC) --------------------------------------------------------
void __cdecl sub_808F1DC(float *a1, float *a2)
{
  sub_81317D0(a1, a2);
}

//----- (0808F1F6) --------------------------------------------------------
void __usercall sub_808F1F6(long double a1@<st0>, int a2, _BYTE *a3, int a4)
{
  char *v4; // eax
  char **i; // [esp+14h] [ebp-4h]

  sub_8060448(a3);
  for ( i = &off_815D560; *i; i += 2 )
  {
    v4 = sub_806001C(0);
    if ( !strcmp(v4, *i) )
    {
      ((void (__cdecl *)(int))i[1])(a2);
      break;
    }
  }
  if ( a4 && !*i )
  {
    if ( (unsigned __int8)sub_809215C() )
      sub_80FE998(a1, -1653759219 * ((a2 - (signed int)dword_841FB0C) >> 2));
  }
}
// 815D560: using guessed type char *off_815D560;
// 841FB08: using guessed type int dword_841FB08;

//----- (0808F288) --------------------------------------------------------
signed int __usercall sub_808F288@<eax>(long double a1@<st0>, int a2, _DWORD *a3)
{
  char *v3; // eax
  signed int v5; // [esp+14h] [ebp-14h]
  signed int v6; // [esp+18h] [ebp-10h]
  int v7; // [esp+1Ch] [ebp-Ch]
  char *v8; // [esp+20h] [ebp-8h]
  signed int v9; // [esp+24h] [ebp-4h]

  v7 = 1;
  v6 = 1;
  v9 = sub_8067F90(a3);
  v8 = (char *)sub_8068062(a3);
  if ( *(_DWORD *)(a2 + 133184) >= v9 )
    return 1;
  if ( *(_BYTE *)(dword_848B210 + 8) )
    Com_Printf("clientCommand: %i : %s\n", v9, v8);
  if ( v9 <= *(_DWORD *)(a2 + 133184) + 1 )
  {
    if ( !I_strncmp("team ", v8, 5) || !I_strncmp("score ", v8, 6) || !I_strncmp("mr ", v8, 3) )
      v6 = 0;
    if ( !*((_DWORD *)off_815A498 + 1)
      && *(_DWORD *)a2 > 3
      && *(_BYTE *)(dword_848B204 + 8)
      && dword_841FB04 < *(_DWORD *)(a2 + 134412)
      && v6 )
    {
      v7 = 0;
      v3 = sub_806001C(0);
      Com_DPrintf("client text ignored for %s: %s\n", a2 + 134216, v3);
    }
    if ( v6 )
      *(_DWORD *)(a2 + 134412) = dword_841FB04 + 800;
    sub_808F1F6(a1, a2, v8, v7);
    *(_DWORD *)(a2 + 133184) = v9;
    Com_sprintf((char *)(a2 + 133188), 0x400u, "%s", v8);
    v5 = 1;
  }
  else
  {
    Com_Printf("Client %s lost %i clientCommands\n", a2 + 134216, v9 - *(_DWORD *)(a2 + 133184) + 1);
    sub_808DC8C(a1, (char *)a2, "EXE_LOSTRELIABLECOMMANDS");
    v5 = 0;
  }
  return v5;
}
// 815A498: using guessed type void *off_815A498;
// 848B204: using guessed type int dword_848B204;
// 848B210: using guessed type int dword_848B210;

//----- (0808F488) --------------------------------------------------------
int __usercall sub_808F488@<eax>(long double a1@<st0>, _DWORD *a2, int *a3)
{
  int *v3; // ecx
  int result; // eax

  v3 = a2 + 33289;
  *v3 = *a3;
  v3[1] = a3[1];
  v3[2] = a3[2];
  v3[3] = a3[3];
  v3[4] = a3[4];
  v3[5] = a3[5];
  v3[6] = a3[6];
  result = (int)a2;
  if ( *a2 == 4 )
  {
    sub_80F2EC0(-1653759219 * (((char *)a2 - (_BYTE *)dword_841FB0C) >> 2), *a3);
    result = sub_80F3EA4(a1, -1653759219 * (((char *)a2 - (_BYTE *)dword_841FB0C) >> 2));
  }
  return result;
}
// 841FB08: using guessed type int dword_841FB08;

//----- (0808F510) --------------------------------------------------------
void __usercall sub_808F510(long double a1@<st0>, char *a2, _DWORD *a3, int a4)
{
  int v4; // [esp+14h] [ebp-3C4h]
  char *v5; // [esp+18h] [ebp-3C0h]
  char *v6; // [esp+1Ch] [ebp-3BCh]
  char v7[896]; // [esp+20h] [ebp-3B8h]
  char s; // [esp+3A0h] [ebp-38h]
  int v9; // [esp+3C4h] [ebp-14h]
  int v10; // [esp+3C8h] [ebp-10h]
  int i; // [esp+3CCh] [ebp-Ch]
  char v12[8]; // [esp+3D0h] [ebp-8h]

  if ( a4 )
    *((_DWORD *)a2 + 33602) = *((_DWORD *)a2 + 33286);
  else
    *((_DWORD *)a2 + 33602) = -1;
  if ( *((_DWORD *)a2 + 33283) - *((_DWORD *)a2 + 33284) <= 127 )
  {
    v9 = sub_8067EE8(a3);
    if ( v9 > 0 )
    {
      if ( v9 <= 32 )
      {
        v10 = dword_842BC8C;
        v10 = *((_DWORD *)a2 + 33286) ^ dword_842BC8C;
        v10 ^= sub_80AA70C((int)&a2[1032 * (*((_DWORD *)a2 + 33284) & 0x7F) + 1036], 32);
        v4 = sub_808FE02(-1653759219 * ((a2 - (_BYTE *)dword_841FB0C) >> 2));
        sub_80684E6(v4, &s);
        v5 = &s;
        for ( i = 0; i < v9; ++i )
        {
          v6 = &v7[28 * i];
          sub_8068ADE(a3, v10, (int)v5, (int)v6);
          if ( !(unsigned __int8)sub_80E97F0(v4, (unsigned __int8)v6[8]) )
            v6[8] = *(_BYTE *)(v4 + 212);
          if ( !(unsigned __int8)sub_80E97F0(v4, (unsigned __int8)v6[9]) )
            v6[9] = *(_BYTE *)(v4 + 208);
          v5 = v6;
        }
        *(_DWORD *)&a2[9924 * (*((_DWORD *)a2 + 33286) & 0x1F) + 144352] = dword_841FB04;
        if ( *(_DWORD *)a2 == 3 )
          sub_808E1F0(a2, v7);
        if ( !*(_BYTE *)(dword_848B200 + 8) || *((_DWORD *)a2 + 113004) )
        {
          if ( *(_DWORD *)a2 == 4 )
          {
            for ( i = 0; i < v9; ++i )
            {
              if ( *(_DWORD *)&v12[28 * i - 944] <= *(_DWORD *)&v12[28 * v9 - 972]
                && *(_DWORD *)&v12[28 * i - 944] > *((_DWORD *)a2 + 33289) )
              {
                sub_808F488(a1, a2, (int *)&v7[28 * i]);
              }
            }
          }
          else
          {
            *((_DWORD *)a2 + 33602) = -1;
          }
        }
        else
        {
          sub_808DC8C(a1, a2, "EXE_CANNOTVALIDATEPURECLIENT");
        }
      }
      else
      {
        Com_Printf("cmdCount > MAX_PACKET_USERCMDS\n");
      }
    }
    else
    {
      Com_Printf("cmdCount < 1\n");
    }
  }
}
// 841FB08: using guessed type int dword_841FB08;
// 842BC8C: using guessed type int dword_842BC8C;
// 848B200: using guessed type int dword_848B200;
// 808F510: using guessed type char var_3B8[896];
// 808F510: using guessed type char var_8[8];

//----- (0808F82A) --------------------------------------------------------
void __usercall sub_808F82A(long double a1@<st0>, int a2, _DWORD *a3)
{
  int v3; // ST08_4
  int v4; // ST0C_4
  int v5; // ST10_4
  int v6; // [esp+20h] [ebp-4038h]
  char s; // [esp+4020h] [ebp-38h]
  int v8; // [esp+402Ch] [ebp-2Ch]
  char v9[4]; // [esp+404Ch] [ebp-Ch]

  sub_8067718(&s, (int)&v6, 0x4000);
  v8 = sub_8067AE2(a3[1] + a3[4], &v6, a3[3] - a3[4]);
  if ( *(_DWORD *)(a2 + 484864) == dword_841FA88 || *(_BYTE *)(a2 + 134248) )
  {
    while ( 1 )
    {
      *(_DWORD *)v9 = sub_8067960(&s, 3);
      if ( *(_DWORD *)v9 == 3 || *(_DWORD *)v9 != 2 )
        break;
      if ( !sub_808F288(a1, a2, &s) || *(_DWORD *)a2 == 1 )
        return;
    }
    if ( *(_BYTE *)(dword_848B200 + 8) && *(_DWORD *)(a2 + 452016) == 2 )
    {
      *(_DWORD *)(a2 + 134424) = -1;
      sub_808DC8C(a1, (char *)a2, "EXE_UNPURECLIENTDETECTED");
      *(_DWORD *)a2 = 4;
      sub_8098C0E(a1, a2);
      *(_DWORD *)a2 = 1;
    }
    if ( *(_DWORD *)v9 )
    {
      if ( *(_DWORD *)v9 == 1 )
      {
        sub_808F510(a1, (char *)a2, &s, 0);
      }
      else if ( *(_DWORD *)v9 != 3 )
      {
        Com_Printf(
          "WARNING: bad command byte %i for client %i\n",
          *(_DWORD *)v9,
          -1653759219 * ((a2 - (signed int)dword_841FB0C) >> 2));
      }
    }
    else
    {
      sub_808F510(a1, (char *)a2, &s, 1);
    }
  }
  else if ( (*(_DWORD *)(a2 + 484864) & 0xF0) == (dword_841FA88 & 0xF0) )
  {
    if ( *(_DWORD *)a2 == 3 )
      sub_808E1F0((_DWORD *)a2, (_DWORD *)(a2 + 133156));
  }
  else if ( *(_DWORD *)(a2 + 133144) > *(_DWORD *)(a2 + 133148) )
  {
    Com_DPrintf("%s : dropped gamestate, resending\n", a2 + 134216);
    sub_808DECA(a1, (char *)a2);
    if ( *(_BYTE *)(dword_81F7114 + 8)
      || (v3 = *(_DWORD *)(a2 + 452044),
          v4 = *(_DWORD *)(a2 + 452048),
          v5 = *(_DWORD *)(a2 + 452052),
          !Sys_IsLANAddress(*(_DWORD *)(a2 + 452036), *(_DWORD *)(a2 + 452040))) )
    {
      sub_808C21C(
        a1,
        *(_DWORD *)(a2 + 452036),
        *(_DWORD *)(a2 + 452040),
        *(_DWORD *)(a2 + 452044),
        *(_DWORD *)(a2 + 452048),
        *(_DWORD *)(a2 + 452052),
        *(_DWORD *)(a2 + 133152));
    }
  }
}
// 81F7114: using guessed type int dword_81F7114;
// 841FA88: using guessed type int dword_841FA88;
// 841FB08: using guessed type int dword_841FB08;
// 848B200: using guessed type int dword_848B200;

//----- (0808FAC6) --------------------------------------------------------
int __usercall sub_808FAC6@<eax>(long double a1@<st0>)
{
  int v1; // ST18_4
  int v2; // ST1C_4
  int v3; // ST20_4
  int v4; // ST24_4
  char v7; // [esp+40h] [ebp-458h]
  char *i; // [esp+68h] [ebp-430h]
  int v9; // [esp+6Ch] [ebp-42Ch]
  int v10; // [esp+70h] [ebp-428h]
  int v11; // [esp+74h] [ebp-424h]
  int v12; // [esp+78h] [ebp-420h]
  int v13; // [esp+7Ch] [ebp-41Ch]
  int v14; // [esp+80h] [ebp-418h]
  char s; // [esp+90h] [ebp-408h]

  v9 = 0;
  for ( i = (char *)dword_841FB0C; v9 < *(_DWORD *)(dword_848B1CC + 8) && *(_DWORD *)i; i += 495380 )
    ++v9;
  if ( v9 == *(_DWORD *)(dword_848B1CC + 8) )
    return 0;
  sprintf(
    &s,
    "connect \"\\cg_predictItems\\1\\cl_anonymous\\0\\color\\4\\head\\default\\model\\multi\\snaps\\20\\rate\\5000\\name\\"
    "bot%d\\protocol\\%d\"",
    dword_83DF9EC,
    115);
  sub_8060448(&s);
  memset(&v10, 0, 0x14u);
  v10 = 0;
  LOWORD(v12) = dword_83DF9EC++;
  sub_808D0E6(a1, 0, v11, v12, v13, v14);
  v9 = 0;
  for ( i = (char *)dword_841FB0C; v9 < *(_DWORD *)(dword_848B1CC + 8); i += 495380 )
  {
    if ( *(_DWORD *)i )
    {
      v1 = *((_DWORD *)i + 113010);
      v2 = *((_DWORD *)i + 113011);
      v3 = *((_DWORD *)i + 113012);
      v4 = *((_DWORD *)i + 113013);
      if ( sub_806BF64(v10, v11, v12, v13, v14, *((_DWORD *)i + 113009)) )
        break;
    }
    ++v9;
  }
  if ( v9 == *(_DWORD *)(dword_848B1CC + 8) )
    return 0;
  *((_DWORD *)i + 121215) = 1;
  sub_808DECA(a1, i);
  memset(&v7, 0, 0x1Cu);
  sub_808E1F0(i, &v7);
  return sub_808FDE4(v9);
}
// 83DF9EC: using guessed type int dword_83DF9EC;
// 848B1CC: using guessed type int dword_848B1CC;

//----- (0808FD2A) --------------------------------------------------------
signed int __cdecl sub_808FD2A(_BYTE *a1, _BYTE *a2, int a3)
{
  signed int v4; // [esp+Ch] [ebp-Ch]
  char v6; // [esp+16h] [ebp-2h]
  char v7; // [esp+17h] [ebp-1h]

  while ( a3 && *a1 )
  {
    v7 = tolower((char)*a1);
    v6 = tolower((char)*a2);
    --a3;
    ++a1;
    ++a2;
    if ( v7 < v6 )
      return -1;
    if ( v7 > v6 )
      return 1;
  }
  if ( a3 && *a1 != *a2 )
    v4 = -1;
  else
    v4 = 0;
  return v4;
}

//----- (0808FDE4) --------------------------------------------------------
int __cdecl sub_808FDE4(int a1)
{
  return dword_848B09C + a1 * dword_848B0A0;
}
// 848B09C: using guessed type int dword_848B09C;
// 848B0A0: using guessed type int dword_848B0A0;

//----- (0808FE02) --------------------------------------------------------
int __cdecl sub_808FE02(int a1)
{
  return dword_848B0A8 + a1 * dword_848B0AC;
}
// 848B0A8: using guessed type int dword_848B0A8;
// 848B0AC: using guessed type int dword_848B0AC;

//----- (0808FE20) --------------------------------------------------------
int __cdecl sub_808FE20(_DWORD *a1)
{
  if ( !a1 || *a1 < 0 || *a1 > 1023 )
    Com_Error(1, &byte_8143DA0);
  return 372 * *a1 + 138600600;
}

//----- (0808FE68) --------------------------------------------------------
int __cdecl sub_808FE68(int a1)
{
  return sub_808FDE4(1062196213 * ((a1 + -(signed int)&dword_842BC80 - 9240) >> 2));
}
// 842BC80: using guessed type int dword_842BC80;

//----- (0808FE96) --------------------------------------------------------
int __cdecl sub_808FE96(int a1, int a2, int a3)
{
  int result; // eax

  if ( a1 == -1 )
    return sub_809301C(0, a2, "%s", a3);
  if ( a1 >= 0 )
  {
    result = a1;
    if ( a1 < *(_DWORD *)(dword_848B1CC + 8) )
      result = sub_809301C((int)dword_841FB0C + 495380 * a1, a2, "%s", a3);
  }
  return result;
}
// 848B1CC: using guessed type int dword_848B1CC;

//----- (0808FF0A) --------------------------------------------------------
void __usercall sub_808FF0A(long double a1@<st0>, int a2, char *a3)
{
  if ( a2 >= 0 && a2 < *(_DWORD *)(dword_848B1CC + 8) )
    sub_808DC8C(a1, (char *)dword_841FB0C + 495380 * a2, a3);
}
// 848B1CC: using guessed type int dword_848B1CC;

//----- (0808FF44) --------------------------------------------------------
int __cdecl sub_808FF44(int a1)
{
  char v2; // [esp+10h] [ebp-28h]
  char v3; // [esp+20h] [ebp-18h]

  sub_8052518(*(_DWORD *)(a1 + 140), &v3, &v2);
  sub_8090E3A(&v3, (_DWORD *)(a1 + 260));
  sub_8090E3A(&v2, (_DWORD *)(a1 + 272));
  *(_BYTE *)(a1 + 241) = 1;
  *(_DWORD *)(a1 + 284) = -1;
  return sub_809A45E(a1);
}

//----- (0808FFBC) --------------------------------------------------------
signed int __cdecl sub_808FFBC(float *a1, int a2)
{
  int v2; // ST3C_4
  _BOOL4 v4; // [esp+20h] [ebp-28h]
  float v5; // [esp+24h] [ebp-24h]
  char *v6; // [esp+28h] [ebp-20h]
  int i; // [esp+30h] [ebp-18h]
  int v8; // [esp+34h] [ebp-14h]
  int v9; // [esp+38h] [ebp-10h]
  int v10; // [esp+40h] [ebp-8h]
  int v11; // [esp+44h] [ebp-4h]

  v11 = sub_808FDE4(a2);
  if ( !*(_BYTE *)(v11 + 240) )
    return 0;
  if ( *(_DWORD *)(v11 + 256) )
    return 1;
  if ( *(_BYTE *)(v11 + 242) & 1 )
    return 0;
  if ( *(_BYTE *)(v11 + 242) & 0x18 )
    return 1;
  v10 = sub_808FE20((_DWORD *)v11);
  v9 = sub_8058A2C(a1);
  if ( !*(_DWORD *)(v10 + 280) )
    return 0;
  v2 = sub_80524F4(v9);
  v6 = sub_8058F82(v2);
  v8 = 0;
  for ( i = 0; i < *(_DWORD *)(v10 + 280); ++i )
  {
    v8 = *(_DWORD *)(v10 + 4 * i + 284);
    if ( ((signed int)(unsigned __int8)v6[v8 >> 3] >> (*(_BYTE *)(v10 + 4 * i + 284) & 7)) & 1 )
      break;
  }
  if ( i != *(_DWORD *)(v10 + 280) )
    goto LABEL_29;
  if ( !*(_DWORD *)(v10 + 348) )
    return 0;
  while ( v8 <= *(_DWORD *)(v10 + 348) && !(((signed int)(unsigned __int8)v6[v8 >> 3] >> (v8 & 7)) & 1) )
    ++v8;
  if ( v8 == *(_DWORD *)(v10 + 348) )
    return 0;
LABEL_29:
  v5 = sub_8106976();
  if ( v5 == 3.4028235e38 )
    v4 = 1;
  else
    v4 = sub_80A831C(v11 + 288, v11 + 300, (int)a1, v5) == 0;
  return v4;
}

//----- (080901C2) --------------------------------------------------------
unsigned int __cdecl sub_80901C2(float *a1, float *a2, int a3)
{
  unsigned int v4; // [esp+3Ch] [ebp-5Ch]
  char s; // [esp+40h] [ebp-58h]
  unsigned __int8 v6; // [esp+63h] [ebp-35h]
  float v7; // [esp+78h] [ebp-20h]
  float v8; // [esp+7Ch] [ebp-1Ch]
  int v9; // [esp+80h] [ebp-18h]
  int v10; // [esp+8Ch] [ebp-Ch]

  if ( *(_BYTE *)(a3 + 242) & 0x60 )
  {
    if ( *(_BYTE *)(a3 + 242) & 0x20 )
    {
      if ( *(float *)(a3 + 320) < (long double)a2[2] )
      {
        if ( a1[2] < *(float *)(a3 + 320) + *(float *)(a3 + 280) )
        {
          sub_8090DE8(a1, a2, (float *)&v9);
          sub_8090E14((int)&v9, 0.5, (int)&v9);
          v8 = *a2 - *(float *)&v9 + *(float *)(a3 + 272);
          v7 = v8 * v8;
          v4 = v7 > sub_80A1EA8((float *)(a3 + 312), (float *)&v9);
        }
        else
        {
          v4 = 0;
        }
      }
      else
      {
        v4 = 0;
      }
    }
    else
    {
      sub_8090DE8(a1, a2, (float *)&v9);
      sub_8090E14((int)&v9, 0.5, (int)&v9);
      v8 = *a2 - *(float *)&v9 + *(float *)(a3 + 272) - 64.0;
      v7 = v8 * v8;
      v4 = sub_80A1EA8((float *)(a3 + 312), (float *)&v9) >= v7;
    }
  }
  else
  {
    v10 = sub_809A368(a3);
    sub_805B972(&s, (int)&unk_8145E68, (int)&unk_8145E68, (int)a1, (int)a2, v10, -1, a3 + 312, a3 + 324);
    v4 = v6;
  }
  return v4;
}

//----- (080903BC) --------------------------------------------------------
char *__cdecl sub_80903BC(char *dest, int a2)
{
  char *v2; // eax

  if ( a2 <= 0 )
    Com_Error(1, &byte_8143DE0, a2);
  v2 = sub_8063D30(0x404u);
  return I_strncpyz(dest, v2, a2);
}

//----- (08090408) --------------------------------------------------------
void *__cdecl sub_8090408(size_t a1)
{
  if ( dword_842BC80 != 1 )
    Com_Error(1, &byte_8143E20);
  return Hunk_AllocInternal(a1);
}
// 842BC80: using guessed type int dword_842BC80;

//----- (08090438) --------------------------------------------------------
void *__cdecl sub_8090438(size_t n, int a2)
{
  if ( dword_842BC80 != 1 )
    Com_Error(1, &byte_8143E80);
  return Hunk_AllocAlignInternal(n, a2);
}
// 842BC80: using guessed type int dword_842BC80;

//----- (08090470) --------------------------------------------------------
_DWORD *__cdecl sub_8090470(size_t size)
{
  return Hunk_AllocateTempMemory(size);
}

//----- (08090484) --------------------------------------------------------
void __cdecl sub_8090484(void *ptr)
{
  sub_80AA0C8(ptr);
}

//----- (08090498) --------------------------------------------------------
int __cdecl sub_8090498(int a1, int a2, int a3, int a4, int a5)
{
  int result; // eax

  dword_848B09C = a1;
  dword_848B0A0 = a3;
  dword_848B0A4 = a2;
  dword_848B0A8 = a4;
  result = a5;
  dword_848B0AC = a5;
  return result;
}
// 848B09C: using guessed type int dword_848B09C;
// 848B0A0: using guessed type int dword_848B0A0;
// 848B0A4: using guessed type int dword_848B0A4;
// 848B0A8: using guessed type int dword_848B0A8;
// 848B0AC: using guessed type int dword_848B0AC;

//----- (080904C6) --------------------------------------------------------
int __cdecl sub_80904C6(int a1, _DWORD *a2)
{
  _DWORD *v2; // edx
  int result; // eax

  v2 = (char *)dword_841FB0C + 495380 * a1 + 133156;
  *a2 = *v2;
  a2[1] = v2[1];
  a2[2] = v2[2];
  a2[3] = v2[3];
  a2[4] = v2[4];
  a2[5] = v2[5];
  result = v2[6];
  a2[6] = result;
  return result;
}

//----- (0809050C) --------------------------------------------------------
void *__cdecl sub_809050C(size_t a1)
{
  return Hunk_AllocInternal(a1);
}

//----- (08090520) --------------------------------------------------------
void *__cdecl sub_8090520(size_t a1)
{
  return Hunk_AllocInternal(a1);
}

//----- (08090534) --------------------------------------------------------
int __cdecl sub_8090534(char *s1)
{
  if ( !(unsigned __int8)sub_80C3820(s1) )
    Com_Error(1, &byte_8143EDA, s1);
  return sub_80C3264(s1 + 7, (int)sub_809050C, (int)sub_8090520);
}

//----- (08090584) --------------------------------------------------------
void __cdecl sub_8090584(int *a1)
{
  int v1; // [esp+4h] [ebp-4h]

  if ( *(_DWORD *)(com_developer + 8) )
  {
    v1 = sub_806289C(*a1);
    if ( v1 )
      sub_80B6F74(v1);
    else
      Com_Printf("no model.\n");
  }
}
// 819EEFC: using guessed type int com_developer;

//----- (080905C8) --------------------------------------------------------
unsigned int sub_80905C8()
{
  unsigned int result; // eax

  if ( !++dword_848B0B0 )
    ++dword_848B0B0;
  result = (unsigned int)&unk_83DFA8F & 0xFFFFFFF0;
  dword_841FA80 = (unsigned int)&unk_83DFA8F & 0xFFFFFFF0;
  dword_848B0B4 = 0;
  return result;
}
// 841FA80: using guessed type int dword_841FA80;
// 848B0B0: using guessed type int dword_848B0B0;
// 848B0B4: using guessed type int dword_848B0B4;

//----- (080905FA) --------------------------------------------------------
int __cdecl sub_80905FA(int a1)
{
  int v2; // [esp+14h] [ebp-4h]
  unsigned int v3; // [esp+20h] [ebp+8h]

  v3 = (a1 + 15) & 0xFFFFFFF0;
  while ( 1 )
  {
    v2 = dword_841FA80 + dword_848B0B4;
    dword_848B0B4 += v3;
    if ( (unsigned int)dword_848B0B4 <= 0x3FFF0 )
      break;
    if ( dword_841FA84 != dword_848B0B0 )
    {
      dword_841FA84 = dword_848B0B0;
      Com_Printf("^3WARNING: SV_SKEL_MEMORY_SIZE exceeded\n");
    }
    sub_80905C8();
  }
  return v2;
}
// 841FA80: using guessed type int dword_841FA80;
// 841FA84: using guessed type int dword_841FA84;
// 848B0B0: using guessed type int dword_848B0B0;
// 848B0B4: using guessed type int dword_848B0B4;

//----- (08090666) --------------------------------------------------------
int __cdecl sub_8090666(int *a1, int a2)
{
  int v2; // ST20_4
  int v3; // ST1C_4
  int v6; // [esp+24h] [ebp-4h]

  v6 = sub_806289C(*a1);
  if ( sub_80B83A2(v6, dword_848B0B0) )
    return sub_80B7796(v6, a2);
  v2 = sub_80B8380(v6);
  v3 = sub_80905FA(v2);
  sub_80B8424(v6, v3, (int *)dword_848B0B0);
  return 0;
}
// 848B0B0: using guessed type int dword_848B0B0;

//----- (080906EE) --------------------------------------------------------
signed int __cdecl sub_80906EE(int *a1, int a2)
{
  int v2; // ST20_4
  int v3; // ST1C_4
  int v6; // [esp+24h] [ebp-4h]

  v6 = sub_806289C(*a1);
  if ( sub_80B83A2(v6, dword_848B0B0) )
    return sub_80B77C2(v6, a2);
  v2 = sub_80B8380(v6);
  v3 = sub_80905FA(v2);
  sub_80B8424(v6, v3, (int *)dword_848B0B0);
  return 0;
}
// 848B0B0: using guessed type int dword_848B0B0;

//----- (08090776) --------------------------------------------------------
int __cdecl sub_8090776(int *a1, float a2, int a3)
{
  int v4; // [esp+10h] [ebp-8h]
  int v5; // [esp+14h] [ebp-4h]

  v5 = sub_806289C(*a1);
  if ( v5 )
    v4 = sub_80BEB76(v5, a2, a3);
  else
    v4 = 0;
  return v4;
}

//----- (080907BC) --------------------------------------------------------
int __cdecl sub_80907BC(int *a1, float a2)
{
  int result; // eax

  result = sub_806289C(*a1);
  if ( result )
    result = sub_80BEA94(result, a2);
  return result;
}

//----- (080907EE) --------------------------------------------------------
int __cdecl sub_80907EE(int *a1, int a2, int a3)
{
  int v3; // ST14_4

  v3 = sub_806289C(*a1);
  return sub_80B73C0(v3, a2, a3);
}

//----- (08090820) --------------------------------------------------------
int *__cdecl sub_8090820(int *a1, int a2)
{
  int v2; // ST14_4

  v2 = sub_806289C(*a1);
  return sub_80BEC88(v2, a2);
}

//----- (0809084A) --------------------------------------------------------
int *__cdecl sub_809084A(int *a1, int a2)
{
  int v2; // ST14_4

  v2 = sub_806289C(*a1);
  return sub_80B7822(v2, a2);
}

//----- (08090874) --------------------------------------------------------
int __cdecl sub_8090874(int *a1)
{
  int v1; // ST04_4

  v1 = sub_806289C(*a1);
  return sub_80B8C0C(v1);
}

//----- (08090898) --------------------------------------------------------
int __cdecl sub_8090898(int *a1, int a2)
{
  int v3; // [esp+10h] [ebp-8h]
  int v4; // [esp+14h] [ebp-4h]

  v4 = sub_806289C(*a1);
  if ( v4 )
    v3 = sub_80B8AF6(v4, a2);
  else
    v3 = -1;
  return v3;
}

//----- (080908D8) --------------------------------------------------------
int __cdecl sub_80908D8(int *a1)
{
  int v1; // ST04_4

  v1 = sub_806289C(*a1);
  return sub_80B84D2(v1);
}

//----- (080908FC) --------------------------------------------------------
void __cdecl sub_80908FC(int *a1)
{
  int **v1; // [esp+4h] [ebp-4h]

  v1 = (int **)sub_806289C(*a1);
  if ( v1 )
    sub_80BEEE4(v1);
}

//----- (08090928) --------------------------------------------------------
int __cdecl sub_8090928(int *a1)
{
  int v1; // ST04_4

  v1 = sub_806289C(*a1);
  return sub_80B84D2(v1);
}

//----- (0809094C) --------------------------------------------------------
signed int __cdecl sub_809094C(int *a1, int a2, int a3)
{
  int v3; // ST14_4

  v3 = sub_806289C(*a1);
  return sub_80B858C(v3, a2, a3);
}

//----- (0809097E) --------------------------------------------------------
signed int __cdecl sub_809097E(int *a1, int a2, int a3)
{
  int v3; // ST14_4

  v3 = sub_806289C(*a1);
  return sub_80B8616(v3, a2, a3);
}

//----- (080909B0) --------------------------------------------------------
int __cdecl sub_80909B0(int *a1)
{
  int v2; // [esp+10h] [ebp-8h]
  int v3; // [esp+14h] [ebp-4h]

  v3 = sub_806289C(*a1);
  if ( v3 )
    v2 = sub_80B8BB6(v3);
  else
    v2 = 0;
  return v2;
}

//----- (080909E8) --------------------------------------------------------
void sub_80909E8()
{
  ;
}

//----- (080909EE) --------------------------------------------------------
_BOOL4 __cdecl sub_80909EE(char *s)
{
  void *v1; // ST14_4
  char *v2; // eax
  char *v3; // eax

  v1 = sub_808AC6A(s);
  v2 = sub_80A139C();
  v3 = va("maps/mp/%s.%s", v1, v2);
  return FS_ReadFile(v3, 0) >= 0;
}

//----- (08090A48) --------------------------------------------------------
void *sub_8090A48()
{
  void *result; // eax

  result = sub_80524EA();
  dword_848B098 = (int)result;
  return result;
}
// 848B098: using guessed type int dword_848B098;

//----- (08090A5A) --------------------------------------------------------
_BOOL4 __cdecl sub_8090A5A(int *a1)
{
  return sub_806289C(*a1) != 0;
}

//----- (08090A82) --------------------------------------------------------
int sub_8090A82()
{
  return sub_8062676(1);
}

//----- (08090A96) --------------------------------------------------------
void sub_8090A96()
{
  sub_8062684(1);
}

//----- (08090AAA) --------------------------------------------------------
int __cdecl sub_8090AAA(char *dest, int a2)
{
  signed int v3; // [esp+10h] [ebp-8h]
  char *src; // [esp+14h] [ebp-4h]

  src = Com_Parse((char **)&dword_848B098);
  I_strncpyz(dest, src, a2);
  v3 = 0;
  if ( dword_848B098 || *src )
    v3 = 1;
  return v3;
}
// 848B098: using guessed type int dword_848B098;

//----- (08090AFE) --------------------------------------------------------
int __cdecl sub_8090AFE(int a1)
{
  int v2; // [esp+0h] [ebp-4h]

  if ( a1 >= 0 && a1 < *(_DWORD *)(dword_848B1CC + 8) )
    v2 = *((_DWORD *)dword_841FB0C + 123845 * a1 + 121213);
  else
    v2 = 0;
  return v2;
}
// 848B1CC: using guessed type int dword_848B1CC;

//----- (08090B42) --------------------------------------------------------
int __cdecl sub_8090B42(int a1)
{
  return *((_DWORD *)dword_841FB0C + 123845 * a1 + 113001);
}

//----- (08090B5E) --------------------------------------------------------
signed int __cdecl sub_8090B5E(int a1)
{
  int v1; // ST04_4
  int v2; // ST08_4
  int v3; // ST0C_4
  int v4; // ST10_4

  v1 = *((_DWORD *)dword_841FB0C + 123845 * a1 + 113010);
  v2 = *((_DWORD *)dword_841FB0C + 123845 * a1 + 113011);
  v3 = *((_DWORD *)dword_841FB0C + 123845 * a1 + 113012);
  v4 = *((_DWORD *)dword_841FB0C + 123845 * a1 + 113013);
  return sub_806C0BA(*((_DWORD *)dword_841FB0C + 123845 * a1 + 113009));
}

//----- (08090BA2) --------------------------------------------------------
void __usercall SV_ShutdownGameProgs(long double a1@<st0>)
{
  dword_842BC80 = 0;
  sub_80AAEDC(2);
  if ( dword_83DFA00 )
  {
    sub_8107058(a1, 1);
    sub_8090A96();
    dword_83DFA00 = 0;
  }
}
// 83DFA00: using guessed type int dword_83DFA00;
// 842BC80: using guessed type int dword_842BC80;

//----- (08090BE6) --------------------------------------------------------
void __usercall sub_8090BE6(long double a1@<st0>)
{
  char *v1; // ebx
  char dest; // [esp+10h] [ebp-58h]
  char *i; // [esp+5Ch] [ebp-Ch]

  Dvar_RegisterString(a1, "g_gametype", (int)"dm", 4132);
  if ( *(_BYTE *)(com_sv_running + 8) && sub_810695E() )
    I_strncpyz(&dest, byte_848B174, 64);
  else
    I_strncpyz(&dest, *(char **)(dword_848B1F4 + 8), 64);
  for ( i = &dest; *i; ++i )
  {
    v1 = i;
    *v1 = tolower(*i);
  }
  if ( !sub_8115E3C(&dest) )
  {
    Com_Printf("g_gametype %s is not a valid gametype, defaulting to dm\n", &dest);
    strcpy(&dest, "dm");
  }
  Dvar_SetString(dword_848B1F4, &dest);
}
// 819EF14: using guessed type int com_sv_running;

//----- (08090CD2) --------------------------------------------------------
void __usercall sub_8090CD2(long double a1@<st0>, int a2, int a3)
{
  int v3; // eax
  int i; // [esp+14h] [ebp-4h]

  sub_8131328();
  dword_848B098 = (int)sub_80524EA();
  sub_80D1D86();
  v3 = sub_80D37B0();
  sub_8106C06(a1, dword_841FB04, v3, a2, a3);
  sub_80D1D86();
  for ( i = 0; i < *(_DWORD *)(dword_848B1CC + 8); ++i )
    *((_DWORD *)dword_841FB0C + 123845 * i + 33553) = 0;
  if ( *(_DWORD *)(com_dedicated + 8) )
    Com_DvarDump(4);
}
// 848B098: using guessed type int dword_848B098;
// 848B1CC: using guessed type int dword_848B1CC;
// 8494204: using guessed type int com_dedicated;

//----- (08090D6A) --------------------------------------------------------
void __usercall sub_8090D6A(long double a1@<st0>, int a2)
{
  sub_8107058(a1, 0);
  com_fixedConsolePosition = 0;
  sub_8090CD2(a1, 1, a2);
}
// 819EF54: using guessed type int com_fixedConsolePosition;

//----- (08090D9C) --------------------------------------------------------
void __usercall sub_8090D9C(long double a1@<st0>, int a2)
{
  dword_83DFA00 = 1;
  sub_8090CD2(a1, 0, a2);
}
// 83DFA00: using guessed type int dword_83DFA00;

//----- (08090DC2) --------------------------------------------------------
signed int __usercall CL_ForwardCommandToServer@<eax>(long double a1@<st0>)
{
  signed int v2; // [esp+4h] [ebp-4h]

  if ( dword_842BC80 == 2 )
    v2 = sub_8119AD4(a1);
  else
    v2 = 0;
  return v2;
}
// 842BC80: using guessed type int dword_842BC80;

//----- (08090DE8) --------------------------------------------------------
int __cdecl sub_8090DE8(float *a1, float *a2, float *a3)
{
  int result; // eax

  *a3 = *a1 + *a2;
  result = (int)(a1 + 1);
  a3[1] = a1[1] + a2[1];
  return result;
}

//----- (08090E14) --------------------------------------------------------
int __cdecl sub_8090E14(int a1, float a2, int a3)
{
  int result; // eax

  *(float *)a3 = a2 * *(float *)a1;
  result = a1 + 4;
  *(float *)(a3 + 4) = a2 * *(float *)(a1 + 4);
  return result;
}

//----- (08090E3A) --------------------------------------------------------
int __cdecl sub_8090E3A(_DWORD *a1, _DWORD *a2)
{
  int result; // eax

  *a2 = *a1;
  a2[1] = a1[1];
  result = a1[2];
  a2[2] = result;
  return result;
}

//----- (08090E6C) --------------------------------------------------------
int __cdecl sub_8090E6C(int a1, char *s1)
{
  int result; // eax
  char s; // [esp+20h] [ebp-428h]
  char v4; // [esp+423h] [ebp-25h]
  int j; // [esp+424h] [ebp-24h]
  int v6; // [esp+428h] [ebp-20h]
  int i; // [esp+42Ch] [ebp-1Ch]
  int v8; // [esp+430h] [ebp-18h]
  size_t v9; // [esp+434h] [ebp-14h]
  int v10; // [esp+438h] [ebp-10h]
  int v11; // [esp+43Ch] [ebp-Ch]

  if ( a1 < 0 || a1 > 2047 )
    Com_Error(1, &byte_8143FA0, a1);
  if ( !s1 )
    s1 = &byte_8143FC3;
  result = a1;
  if ( dword_842C098[a1] )
  {
    result = strcmp(s1, dword_842C098[a1]);
    if ( result )
    {
      sub_80A93E4(4 * a1 + 138592408, s1);
      result = sub_809215C();
      if ( (_BYTE)result || dword_842BC84 )
      {
        v11 = strlen(s1);
        sprintf(&s, "%i", a1);
        v9 = strlen(&s) + 4;
        v8 = 1024 - v9;
        v10 = 0;
        for ( i = (int)dword_841FB0C; ; i += 495380 )
        {
          result = v10;
          if ( v10 >= *(_DWORD *)(dword_848B1CC + 8) )
            break;
          if ( *(_DWORD *)i > 2 )
          {
            if ( v11 <= v8 )
            {
              sub_809301C(i, 1, "%c %i %s", 100, a1, s1);
            }
            else
            {
              v6 = 0;
              for ( j = v11; j > 0; j -= v8 )
              {
                if ( v6 )
                {
                  if ( j > v8 )
                    v4 = 121;
                  else
                    v4 = 122;
                }
                else
                {
                  v4 = 120;
                }
                I_strncpyz(&s, &s1[v6], v8 + 1);
                sub_809301C(i, 1, "%c %i %s", v4, a1, &s);
                v6 += v8;
              }
            }
          }
          ++v10;
        }
      }
    }
  }
  return result;
}
// 842BC84: using guessed type int dword_842BC84;
// 848B1CC: using guessed type int dword_848B1CC;

//----- (0809107E) --------------------------------------------------------
char *__cdecl sub_809107E(int a1, char *dest, int a3)
{
  char *result; // eax

  if ( a3 <= 0 )
    Com_Error(1, &byte_8143FE0, a3);
  if ( a1 < 0 || a1 > 2047 )
    Com_Error(1, &byte_8144020, a1);
  if ( dword_842C098[a1] )
    return I_strncpyz(dest, dword_842C098[a1], a3);
  result = dest;
  *dest = 0;
  return result;
}

//----- (08091108) --------------------------------------------------------
char *__cdecl sub_8091108(int a1)
{
  char *v2; // [esp+0h] [ebp-4h]

  v2 = dword_842C098[a1];
  if ( !dword_842C098[a1] )
    v2 = &byte_8143FC3;
  return v2;
}

//----- (08091134) --------------------------------------------------------
char *__cdecl sub_8091134(int a1, int a2, char *s1)
{
  char *s2; // [esp+10h] [ebp-8h]
  int i; // [esp+14h] [ebp-4h]

  for ( i = 0; i < a2; ++i )
  {
    s2 = dword_842C098[a1 + i];
    if ( !*s2 )
      return &byte_8143FC3;
    if ( !strcasecmp(s1, s2) )
      return dword_842C098[i + a1 + a2];
  }
  return &byte_8143FC3;
}

//----- (080911AA) --------------------------------------------------------
int __cdecl sub_80911AA(int a1, int a2, char *s1, char *a4)
{
  char *s2; // [esp+10h] [ebp-8h]
  int i; // [esp+14h] [ebp-4h]

  for ( i = 0; i < a2; ++i )
  {
    s2 = dword_842C098[a1 + i];
    if ( !*s2 )
    {
      sub_8090E6C(a1 + i, s1);
      break;
    }
    if ( !strcasecmp(s1, s2) )
      break;
  }
  if ( i == a2 )
    Com_Error(1, &byte_8144060);
  return sub_8090E6C(i + a1 + a2, a4);
}

//----- (08091246) --------------------------------------------------------
char *__cdecl sub_8091246(int a1, char *src)
{
  char *v2; // eax

  if ( a1 < 0 || a1 >= *(_DWORD *)(dword_848B1CC + 8) )
    Com_Error(1, &byte_81440A0, a1);
  if ( !src )
    src = &byte_8143FC3;
  I_strncpyz((char *)dword_841FB0C + 495380 * a1 + 12, src, 1024);
  v2 = sub_80B5B30(src, (int)"name");
  return I_strncpyz((char *)dword_841FB0C + 495380 * a1 + 134216, v2, 32);
}
// 848B1CC: using guessed type int dword_848B1CC;

//----- (080912F0) --------------------------------------------------------
char *__cdecl sub_80912F0(int a1, char *dest, int a3)
{
  if ( a3 <= 0 )
    Com_Error(1, &byte_81440E0, a3);
  if ( a1 < 0 || a1 >= *(_DWORD *)(dword_848B1CC + 8) )
    Com_Error(1, &byte_8144120, a1);
  return I_strncpyz(dest, (char *)dword_841FB0C + 495380 * a1 + 12, a3);
}
// 848B1CC: using guessed type int dword_848B1CC;

//----- (08091372) --------------------------------------------------------
int sub_8091372()
{
  int result; // eax
  int i; // [esp+8h] [ebp-10h]
  int *v2; // [esp+Ch] [ebp-Ch]

  for ( i = 1; ; ++i )
  {
    result = i;
    if ( i >= dword_848B0A4 )
      break;
    v2 = (int *)sub_808FDE4(i);
    if ( *((_BYTE *)v2 + 240) )
    {
      *v2 = i;
      qmemcpy((char *)&unk_842E09C + 372 * i, v2, 0xF0u);
      dword_842E18C[93 * i] = *((unsigned __int8 *)v2 + 242);
      dword_842E190[93 * i] = v2[61];
      dword_842E194[93 * i] = v2[62];
      sub_80929F8(v2 + 72, (_DWORD *)(372 * i + 138600856));
      sub_80929F8(v2 + 75, (_DWORD *)(372 * i + 138600868));
    }
  }
  return result;
}
// 842E18C: using guessed type int dword_842E18C[];
// 842E190: using guessed type int dword_842E190[];
// 848B0A4: using guessed type int dword_848B0A4;

//----- (0809147E) --------------------------------------------------------
void __usercall sub_809147E(long double a1@<st0>, char *a2)
{
  dword_848B1CC = (int)Dvar_RegisterInt(a1, "sv_maxclients", 20, 1, 64, 4133);
  Dvar_ClearModified(dword_848B1CC);
  if ( *(_DWORD *)(dword_848B1CC + 8) < (signed int)a2 )
    Dvar_SetInt(dword_848B1CC, a2);
}
// 848B1CC: using guessed type int dword_848B1CC;

//----- (080914E6) --------------------------------------------------------
void __usercall sub_80914E6(long double a1@<st0>)
{
  int v1; // eax

  if ( dword_841FB00 )
    Com_Error(0, &byte_814414D);
  sub_809147E(a1, (char *)1);
  dword_841FB0C = sub_80A9362(495380 * *(_DWORD *)(dword_848B1CC + 8));
  if ( !dword_841FB0C )
    Com_Error(0, &byte_8144180);
  if ( *(_DWORD *)(com_dedicated + 8) )
  {
    dword_841FB10 = *(_DWORD *)(dword_848B1CC + 8) << 11;
    v1 = 32 * *(_DWORD *)(dword_848B1CC + 8) * *(_DWORD *)(dword_848B1CC + 8);
  }
  else
  {
    dword_841FB10 = *(_DWORD *)(dword_848B1CC + 8) << 8;
    v1 = 4 * *(_DWORD *)(dword_848B1CC + 8) * *(_DWORD *)(dword_848B1CC + 8);
  }
  dword_841FB14 = v1;
  dword_841FB00 = 1;
  Dvar_SetBool(com_sv_running, 1);
}
// 819EF14: using guessed type int com_sv_running;
// 841FB00: using guessed type int dword_841FB00;
// 841FB10: using guessed type int dword_841FB10;
// 841FB14: using guessed type int dword_841FB14;
// 848B1CC: using guessed type int dword_848B1CC;
// 8494204: using guessed type int com_dedicated;

//----- (080915D0) --------------------------------------------------------
int __usercall sub_80915D0@<eax>(long double a1@<st0>)
{
  int v1; // ST38_4
  int result; // eax
  unsigned int v3; // [esp+14h] [ebp-34h]
  _DWORD *v4; // [esp+18h] [ebp-30h]
  _DWORD *v5; // [esp+1Ch] [ebp-2Ch]
  unsigned int v6; // [esp+20h] [ebp-28h]
  _DWORD *v7; // [esp+24h] [ebp-24h]
  _DWORD *v8; // [esp+28h] [ebp-20h]
  int v9; // [esp+2Ch] [ebp-1Ch]
  char *v10; // [esp+2Ch] [ebp-1Ch]
  _DWORD *ptr; // [esp+30h] [ebp-18h]
  int i; // [esp+34h] [ebp-14h]
  signed int j; // [esp+34h] [ebp-14h]
  signed int k; // [esp+34h] [ebp-14h]

  v9 = 0;
  for ( i = 0; i < *(_DWORD *)(dword_848B1CC + 8); ++i )
  {
    if ( *((_DWORD *)dword_841FB0C + 123845 * i) > 1 && i > v9 )
      v9 = i;
  }
  v10 = (char *)(v9 + 1);
  v1 = *(_DWORD *)(dword_848B1CC + 8);
  sub_809147E(a1, v10);
  result = *(_DWORD *)(dword_848B1CC + 8);
  if ( result != v1 )
  {
    ptr = Hunk_AllocateTempMemory(495380 * (_DWORD)v10);
    for ( j = 0; j < (signed int)v10; ++j )
    {
      if ( *((_DWORD *)dword_841FB0C + 123845 * j) <= 1 )
      {
        sub_80AA83E(&ptr[123845 * j], 0, 0x78F14u);
      }
      else
      {
        v8 = &ptr[123845 * j];
        v7 = (char *)dword_841FB0C + 495380 * j;
        v6 = 495380;
        if ( ((_BYTE)ptr + 20 * (_BYTE)j) & 4 )
        {
          *v8 = *v7;
          ++v8;
          ++v7;
          v6 = 495376;
        }
        qmemcpy(v8, v7, 4 * (v6 >> 2));
      }
    }
    sub_80A9268(dword_841FB0C);
    dword_841FB0C = sub_80A9362(495380 * *(_DWORD *)(dword_848B1CC + 8));
    if ( !dword_841FB0C )
      Com_Error(0, &byte_8144180);
    sub_80AA83E(dword_841FB0C, 0, 495380 * *(_DWORD *)(dword_848B1CC + 8));
    for ( k = 0; k < (signed int)v10; ++k )
    {
      if ( ptr[123845 * k] > 1 )
      {
        v5 = (char *)dword_841FB0C + 495380 * k;
        v4 = &ptr[123845 * k];
        v3 = 495380;
        if ( ((_BYTE)dword_841FB0C + 20 * (_BYTE)k) & 4 )
        {
          *v5 = *v4;
          ++v5;
          ++v4;
          v3 = 495376;
        }
        qmemcpy(v5, v4, 4 * (v3 >> 2));
      }
    }
    sub_80AA0C8(ptr);
    if ( *(_DWORD *)(com_dedicated + 8) )
    {
      dword_841FB10 = *(_DWORD *)(dword_848B1CC + 8) << 11;
      result = 32 * *(_DWORD *)(dword_848B1CC + 8) * *(_DWORD *)(dword_848B1CC + 8);
    }
    else
    {
      dword_841FB10 = *(_DWORD *)(dword_848B1CC + 8) << 8;
      result = 4 * *(_DWORD *)(dword_848B1CC + 8) * *(_DWORD *)(dword_848B1CC + 8);
    }
    dword_841FB14 = result;
  }
  return result;
}
// 841FB10: using guessed type int dword_841FB10;
// 841FB14: using guessed type int dword_841FB14;
// 848B1CC: using guessed type int dword_848B1CC;
// 8494204: using guessed type int com_dedicated;

//----- (0809188A) --------------------------------------------------------
void __cdecl sub_809188A(char *a1)
{
  char *v1; // eax
  signed int v2; // [esp+10h] [ebp-18h]
  char *nptr; // [esp+14h] [ebp-14h]
  const char *nptra; // [esp+14h] [ebp-14h]
  void *v5; // [esp+18h] [ebp-10h]
  void *s; // [esp+1Ch] [ebp-Ch]
  char *src; // [esp+20h] [ebp-8h]
  int v8; // [esp+24h] [ebp-4h]

  src = "hunkusage.dat";
  v2 = FS_FOpenFileByMode("hunkusage.dat", (int)&v8, 0);
  if ( v2 >= 0 )
  {
    s = Z_MallocInternal(v2 + 1);
    memset(s, 0, v2 + 1);
    FS_Read((int)s, v2, v8);
    FS_FCloseFile(v8);
    v5 = s;
    while ( 1 )
    {
      nptr = Com_Parse((char **)&v5);
      if ( !nptr || !*nptr )
        break;
      if ( !I_stricmp(nptr, a1) )
      {
        nptra = Com_Parse((char **)&v5);
        if ( nptra )
        {
          if ( *nptra )
          {
            v1 = (char *)atoi(nptra);
            Dvar_SetInt(dword_819EF30, v1);
            Z_FreeInternal(s);
            return;
          }
        }
      }
    }
    Z_FreeInternal(s);
  }
}
// 819EF30: using guessed type int dword_819EF30;

//----- (08091998) --------------------------------------------------------
void *sub_8091998()
{
  signed int i; // [esp+14h] [ebp-4h]

  for ( i = 0; i <= 2047; ++i )
  {
    if ( dword_842C098[i] )
      Z_FreeInternal(dword_842C098[i]);
  }
  return sub_80AA83E(&dword_842BC80, 0, 0x5F534u);
}
// 842BC80: using guessed type int dword_842BC80;

//----- (080919F4) --------------------------------------------------------
void *__cdecl sub_80919F4(int a1)
{
  void *result; // eax

  result = (void *)a1;
  dword_841FB28 = a1;
  if ( a1 )
  {
    if ( !dword_841FB30 )
    {
      dword_841FB48 = Z_MallocInternal(0x450000u);
      dword_841FB4C = Z_MallocInternal(0x2708000u);
      dword_841FB30 = Z_MallocInternal(0x2580u);
      dword_841FB34 = Z_MallocInternal(0x2000000u);
      result = Z_MallocInternal(0x3800u);
      dword_841FB50 = result;
    }
  }
  return result;
}
// 841FB28: using guessed type int dword_841FB28;

//----- (08091A70) --------------------------------------------------------
void sub_8091A70()
{
  dword_841FB28 = 0;
  dword_841FB2C = 0;
  dword_841FB38 = 0;
  dword_841FB3C = 0;
  dword_841FB40 = 0;
  dword_841FB44 = 0;
}
// 841FB28: using guessed type int dword_841FB28;
// 841FB2C: using guessed type int dword_841FB2C;
// 841FB38: using guessed type int dword_841FB38;
// 841FB3C: using guessed type int dword_841FB3C;
// 841FB40: using guessed type int dword_841FB40;
// 841FB44: using guessed type int dword_841FB44;

//----- (08091AB2) --------------------------------------------------------
void sub_8091AB2()
{
  if ( dword_841FB48 )
  {
    Z_FreeInternal(dword_841FB48);
    dword_841FB48 = 0;
  }
  if ( dword_841FB4C )
  {
    Z_FreeInternal(dword_841FB4C);
    dword_841FB4C = 0;
  }
  if ( dword_841FB30 )
  {
    Z_FreeInternal(dword_841FB30);
    dword_841FB30 = 0;
  }
  if ( dword_841FB34 )
  {
    Z_FreeInternal(dword_841FB34);
    dword_841FB34 = 0;
  }
  if ( dword_841FB50 )
  {
    Z_FreeInternal(dword_841FB50);
    dword_841FB50 = 0;
  }
}

//----- (08091B5A) --------------------------------------------------------
int sub_8091B5A()
{
  return sub_80B2C06();
}

//----- (08091B68) --------------------------------------------------------
int sub_8091B68()
{
  char *v0; // eax
  char *v1; // eax
  int result; // eax
  char dest; // [esp+10h] [ebp-2008h]

  v0 = sub_8063D92(8u);
  I_strncpyz(&dest, v0, 0x2000);
  dvar_modifiedFlags &= 0xFFFFFFF7;
  sub_8090E6C(1, &dest);
  v1 = sub_8063D30(0x404u);
  sub_8090E6C(0, v1);
  dvar_modifiedFlags &= 0xFFFFFBFB;
  result = sub_8063CD4(142, 96, 0x100u);
  dvar_modifiedFlags &= 0xFFFFFEFF;
  return result;
}
// 85178A8: using guessed type int dvar_modifiedFlags;

//----- (08091C02) --------------------------------------------------------
void __usercall sub_8091C02(long double a1@<st0>, char *a2)
{
  int v2; // eax
  int v3; // ebx
  int v4; // ebx
  char *v5; // eax
  int v6; // ebx
  char *v7; // eax
  char *v8; // eax
  char *src; // ST2C_4
  char *v10; // ST2C_4
  char *v11; // eax
  char *v12; // ST2C_4
  char *v13; // [esp+28h] [ebp-60h]
  char s; // [esp+30h] [ebp-58h]
  int v15; // [esp+70h] [ebp-18h]
  _DWORD *v16; // [esp+74h] [ebp-14h]
  int v17; // [esp+78h] [ebp-10h]
  int i; // [esp+7Ch] [ebp-Ch]

  sub_8115AE2();
  sub_8090BE6(a1);
  if ( *(_BYTE *)(com_sv_running + 8) )
  {
    v15 = sub_810695E();
    i = 0;
    v16 = dword_841FB0C;
    while ( i < *(_DWORD *)(dword_848B1CC + 8) )
    {
      if ( *v16 > 2 )
      {
        Com_sprintf(&s, 0x40u, "loadingnewmap\n%s\n%s", a2, *(_DWORD *)(dword_848B1F4 + 8));
        sub_806C40C(1, v16[113009], v16[113010], v16[113011], v16[113012], v16[113013], &s);
      }
      ++i;
      v16 += 123845;
    }
    sub_80D3654(250);
  }
  else
  {
    v15 = 0;
  }
  sub_80B294E(a1, "mapname", a2);
  SV_ShutdownGameProgs(a1);
  Com_Printf("------ Server Initialization ------\n");
  Com_Printf("Server: %s\n", a2);
  sub_8091998();
  if ( *(_DWORD *)(com_dedicated + 8) )
    sub_812F498();
  FS_Shutdown();
  FS_ClearIwdReferences();
  Com_Restart(a1);
  if ( *(_BYTE *)(com_sv_running + 8) )
    sub_80915D0(a1);
  else
    sub_80914E6(a1);
  I_strncpyz(byte_848B174, *(char **)(dword_848B1F4 + 8), 64);
  v2 = sub_80D37B0();
  srand(v2);
  v3 = rand() << 16;
  v4 = rand() ^ v3;
  dword_842BC8C = v4 ^ Sys_MilliSeconds();
  FS_Restart(a1, dword_842BC8C);
  v5 = sub_80A139C();
  Com_sprintf(&s, 0x40u, "maps/mp/%s.%s", a2, v5);
  sub_809188A(&s);
  for ( i = 0; i <= 2047; ++i )
  {
    v6 = i;
    dword_842C098[v6] = sub_80A93B0(&byte_8143FC3);
  }
  sub_8091B5A();
  dword_841FB20 = (int)Hunk_AllocInternal(240 * dword_841FB10);
  dword_841FB18 = 0;
  dword_841FB24 = (int)Hunk_AllocInternal(92 * dword_841FB14);
  dword_841FB1C = 0;
  sub_8091A70();
  dword_841FB08 ^= 4u;
  Dvar_SetString(nextmap, "map_restart");
  Dvar_SetInt(cl_paused, 0);
  v7 = sub_80A139C();
  Com_sprintf(&s, 0x40u, "maps/mp/%s.%s", a2, v7);
  Com_LoadBsp((int)&s);
  sub_8051F9E(&s, (int)&v17);
  sub_8051E5C();
  sub_805DA8E();
  dword_841FA88 = (unsigned __int8)(dword_841FA88 + 16);
  if ( !(dword_841FA88 & 0xF0) )
    dword_841FA88 += 16;
  Dvar_SetInt(dword_848B1E4, (char *)dword_841FA88);
  dword_842BC88 = sv.start_frameTime;
  dword_842BC80 = 1;
  v8 = sub_80A139C();
  Com_sprintf(&s, 0x40u, "maps/mp/%s.%s", a2, v8);
  sub_80AAD12(&s, (int)"all_mp", 2);
  sub_8090D9C(a1, v15);
  if ( *(_DWORD *)(com_dedicated + 8) )
  {
    sub_812F47E(0);
    sub_8129F2C();
  }
  for ( i = 0; i <= 2; ++i )
  {
    dword_841FB04 += 100;
    sub_8094780(a1);
  }
  sub_8091372();
  for ( i = 0; i < *(_DWORD *)(dword_848B1CC + 8); ++i )
  {
    if ( *((_DWORD *)dword_841FB0C + 123845 * i) > 1 )
    {
      v13 = (char *)sub_80F6722(a1, i, *((_WORD *)dword_841FB0C + 247690 * i + 242428));
      if ( v13 )
        sub_808DC8C(a1, (char *)dword_841FB0C + 495380 * i, v13);
      else
        *((_DWORD *)dword_841FB0C + 123845 * i) = 2;
    }
  }
  if ( *(_BYTE *)(dword_848B200 + 8) )
  {
    src = sub_8065448();
    Dvar_SetString(dword_848B234, src);
    if ( !*src )
      Com_Printf("WARNING: sv_pure set but no IWD files loaded\n");
    v10 = sub_80654C0();
    Dvar_SetString(dword_848B238, v10);
  }
  else
  {
    Dvar_SetString(dword_848B234, &byte_8143FC3);
    Dvar_SetString(dword_848B238, &byte_8143FC3);
  }
  v11 = sub_80655C4();
  Dvar_SetString(dword_848B23C, v11);
  v12 = sub_8065670();
  Dvar_SetString(dword_848B240, v12);
  sub_8091B68();
  dword_842BC80 = 2;
  sub_808BACE();
  Com_Printf("-----------------------------------\n");
}
// 819EF14: using guessed type int com_sv_running;
// 819EF28: using guessed type int cl_paused;
// 819EF40: using guessed type int sv.start_frameTime;
// 841FA88: using guessed type int dword_841FA88;
// 841FB08: using guessed type int dword_841FB08;
// 841FB10: using guessed type int dword_841FB10;
// 841FB14: using guessed type int dword_841FB14;
// 841FB18: using guessed type int dword_841FB18;
// 841FB1C: using guessed type int dword_841FB1C;
// 841FB20: using guessed type int dword_841FB20;
// 841FB24: using guessed type int dword_841FB24;
// 842BC80: using guessed type int dword_842BC80;
// 842BC88: using guessed type int dword_842BC88;
// 842BC8C: using guessed type int dword_842BC8C;
// 848B1CC: using guessed type int dword_848B1CC;
// 848B1E4: using guessed type int dword_848B1E4;
// 848B200: using guessed type int dword_848B200;
// 8494204: using guessed type int com_dedicated;

//----- (0809215C) --------------------------------------------------------
_BOOL4 sub_809215C()
{
  return dword_842BC80 == 2;
}
// 842BC80: using guessed type int dword_842BC80;

//----- (0809216E) --------------------------------------------------------
char *__usercall SV_Init@<eax>(long double a1@<st0>)
{
  char *result; // eax

  sub_808BBDC();
  dword_848B1F4 = (int)Dvar_RegisterString(a1, "g_gametype", (int)"dm", 4132);
  Dvar_RegisterString(a1, "sv_keywords", (int)&byte_8143FC3, 4100);
  Dvar_RegisterInt(a1, "protocol", 115, 115, 115, 4164);
  dword_848B1E0 = (int)Dvar_RegisterString(a1, "mapname", (int)&byte_8143FC3, 4164);
  dword_848B1D0 = (int)Dvar_RegisterInt(a1, "sv_privateClients", 0, 0, 64, 4100);
  dword_848B1CC = (int)Dvar_RegisterInt(a1, "sv_maxclients", 20, 1, 64, 4133);
  dword_848B1D4 = (int)Dvar_RegisterString(a1, "sv_hostname", (int)"CoD2Host", 4101);
  dword_848B1E8 = (int)Dvar_RegisterInt(a1, "sv_maxRate", 0, 0, 25000, 4101);
  dword_848B1EC = (int)Dvar_RegisterInt(a1, "sv_minPing", 0, 0, 999, 4101);
  dword_848B1F0 = (int)Dvar_RegisterInt(a1, "sv_maxPing", 0, 0, 999, 4101);
  dword_848B204 = (int)Dvar_RegisterBool(a1, "sv_floodProtect", 1, 4101);
  dword_848B20C = (int)Dvar_RegisterBool(a1, "sv_allowAnonymous", 0, 4100);
  dword_848B210 = (int)Dvar_RegisterBool(a1, "sv_showCommands", 0, 4096);
  dword_848B228 = (int)Dvar_RegisterBool(a1, "sv_disableClientConsole", 0, 4104);
  dword_848B22C = (int)Dvar_RegisterBool(a1, "sv_voice", 0, 4109);
  dword_848B230 = (int)Dvar_RegisterInt(a1, "sv_voiceQuality", 1, 0, 9, 4104);
  dword_848B208 = (int)Dvar_RegisterBool(a1, "sv_cheats", 0, 4120);
  dword_848B1E4 = (int)Dvar_RegisterInt(a1, "sv_serverid", 0, 2147483648, 0x7FFFFFFF, 4168);
  dword_848B200 = (int)Dvar_RegisterBool(a1, "sv_pure", 1, 4108);
  dword_848B234 = (int)Dvar_RegisterString(a1, "sv_iwds", (int)&byte_8143FC3, 4168);
  dword_848B238 = (int)Dvar_RegisterString(a1, "sv_iwdNames", (int)&byte_8143FC3, 4168);
  dword_848B23C = (int)Dvar_RegisterString(a1, "sv_referencedIwds", (int)&byte_8143FC3, 4168);
  dword_848B240 = (int)Dvar_RegisterString(a1, "sv_referencedIwdNames", (int)&byte_8143FC3, 4168);
  dword_848B1C0 = (int)Dvar_RegisterString(a1, "rcon_password", (int)&byte_8143FC3, 4096);
  dword_848B1C4 = (int)Dvar_RegisterString(a1, "sv_privatePassword", (int)&byte_8143FC3, 4096);
  dword_848B1B4 = (int)Dvar_RegisterInt(a1, "sv_fps", 20, 10, 1000, 4096);
  dword_848B1B8 = (int)Dvar_RegisterInt(a1, "sv_timeout", 240, 0, 1800, 4096);
  dword_848B1BC = (int)Dvar_RegisterInt(a1, "sv_zombietime", 2, 0, 1800, 4096);
  dword_848B1C8 = (int)Dvar_RegisterBool(a1, "sv_allowDownload", 1, 4097);
  dword_848B1D8 = (int)Dvar_RegisterInt(a1, "sv_reconnectlimit", 3, 0, 1800, 4097);
  dword_848B1DC = (int)Dvar_RegisterInt(a1, "sv_padPackets", 0, 0, 0x7FFFFFFF, 4096);
  *((_BYTE *)off_815A498 + 221) = 0;
  dword_848B244 = (int)Dvar_RegisterString(a1, "sv_allowedClan1", (int)&byte_8143FC3, 4096);
  dword_848B248 = (int)Dvar_RegisterString(a1, "sv_allowedClan2", (int)&byte_8143FC3, 4096);
  dword_848B214 = (int)Dvar_RegisterBool(a1, "sv_packet_info", 0, 4096);
  dword_848B218 = (int)Dvar_RegisterBool(a1, "sv_showAverageBPS", 0, 4096);
  dword_848B224 = (int)Dvar_RegisterFloat(a1, "sv_kickBanTime", 1133903872, 0, 1163984896, 4096);
  dword_848B21C = (int)Dvar_RegisterString(a1, "sv_mapRotation", (int)&byte_8143FC3, 4096);
  dword_848B220 = (int)Dvar_RegisterString(a1, "sv_mapRotationCurrent", (int)&byte_8143FC3, 4096);
  dword_848B1F8 = (int)Dvar_RegisterBool(a1, "sv_debugRate", 0, 4096);
  dword_848B1FC = (int)Dvar_RegisterBool(a1, "sv_debugReliableCmds", 0, 4096);
  nextmap = (int)Dvar_RegisterString(a1, "nextmap", (int)&byte_8143FC3, 4096);
  result = Dvar_RegisterInt(a1, "com_expectedHunkUsage", 0, 0, 0x7FFFFFFF, 4160);
  dword_819EF30 = (int)result;
  return result;
}
// 815A498: using guessed type void *off_815A498;
// 819EF30: using guessed type int dword_819EF30;
// 848B1B4: using guessed type int dword_848B1B4;
// 848B1B8: using guessed type int dword_848B1B8;
// 848B1BC: using guessed type int dword_848B1BC;
// 848B1C0: using guessed type int dword_848B1C0;
// 848B1C4: using guessed type int dword_848B1C4;
// 848B1C8: using guessed type int dword_848B1C8;
// 848B1CC: using guessed type int dword_848B1CC;
// 848B1D0: using guessed type int dword_848B1D0;
// 848B1D4: using guessed type int dword_848B1D4;
// 848B1D8: using guessed type int dword_848B1D8;
// 848B1DC: using guessed type int dword_848B1DC;
// 848B1E0: using guessed type int dword_848B1E0;
// 848B1E4: using guessed type int dword_848B1E4;
// 848B1E8: using guessed type int dword_848B1E8;
// 848B1EC: using guessed type int dword_848B1EC;
// 848B1F0: using guessed type int dword_848B1F0;
// 848B1F8: using guessed type int dword_848B1F8;
// 848B1FC: using guessed type int dword_848B1FC;
// 848B200: using guessed type int dword_848B200;
// 848B204: using guessed type int dword_848B204;
// 848B208: using guessed type int dword_848B208;
// 848B20C: using guessed type int dword_848B20C;
// 848B210: using guessed type int dword_848B210;
// 848B214: using guessed type int dword_848B214;
// 848B218: using guessed type int dword_848B218;
// 848B21C: using guessed type int dword_848B21C;
// 848B224: using guessed type int dword_848B224;
// 848B228: using guessed type int dword_848B228;
// 848B22C: using guessed type int dword_848B22C;
// 848B230: using guessed type int dword_848B230;
// 848B244: using guessed type int dword_848B244;
// 848B248: using guessed type int dword_848B248;

//----- (080927DA) --------------------------------------------------------
int *__usercall sub_80927DA@<eax>(long double a1@<st0>, int a2)
{
  int *result; // eax
  _DWORD *v3; // [esp+1Ch] [ebp-Ch]
  int i; // [esp+20h] [ebp-8h]
  int v5; // [esp+24h] [ebp-4h]

  for ( i = 0; i <= 1; ++i )
  {
    v5 = 0;
    v3 = dword_841FB0C;
    while ( v5 < *(_DWORD *)(dword_848B1CC + 8) )
    {
      if ( *v3 > 1 )
      {
        if ( v3[113009] != 2 )
        {
          sub_809301C((int)v3, 0, "%c \"%s\"", 101, a2);
          sub_809301C((int)v3, 1, "%c \"%s\"", 119, a2);
        }
        v3[33606] = -1;
        sub_8098C0E(a1, (int)v3);
      }
      ++v5;
      v3 += 123845;
    }
    result = &i;
  }
  return result;
}
// 848B1CC: using guessed type int dword_848B1CC;

//----- (080928B4) --------------------------------------------------------
int __usercall sub_80928B4@<eax>(long double a1@<st0>)
{
  int result; // eax
  char *i; // [esp+10h] [ebp-8h]
  int v3; // [esp+14h] [ebp-4h]

  v3 = 0;
  for ( i = (char *)dword_841FB0C; ; i += 495380 )
  {
    result = v3;
    if ( v3 >= *(_DWORD *)(dword_848B1CC + 8) )
      break;
    if ( *(_DWORD *)i > 1 )
      sub_808DC8C(a1, i, "EXE_DISCONNECTED");
    ++v3;
  }
  return result;
}
// 848B1CC: using guessed type int dword_848B1CC;

//----- (08092906) --------------------------------------------------------
void __usercall SV_Shutdown(long double a1@<st0>, int a2)
{
  bool v2; // [esp+17h] [ebp-1h]

  if ( com_sv_running && *(_BYTE *)(com_sv_running + 8) )
  {
    Com_Printf("----- Server Shutdown -----\n");
    v2 = dword_842BC80 == 1;
    if ( dword_841FB0C )
      sub_80927DA(a1, a2);
    sub_808BDFC();
    sub_809505E();
    SV_ShutdownGameProgs(a1);
    sub_80928B4(a1);
    sub_8091998();
    if ( dword_841FB0C )
      sub_808D08E(a1);
    sub_8091AB2();
    memset(&dword_841FB00, 0, 0xC108u);
    if ( *(_DWORD *)(com_dedicated + 8) )
      sub_812F498();
    Dvar_SetBool(com_sv_running, 0);
    Com_Printf("---------------------------\n");
    if ( v2 )
    {
      sub_8062C40();
      sub_80B6F64();
      sub_80BA246();
      Scr_Abort();
      dword_855A4E0 = 0;
    }
  }
}
// 819EF14: using guessed type int com_sv_running;
// 841FB00: using guessed type int dword_841FB00;
// 842BC80: using guessed type int dword_842BC80;
// 8494204: using guessed type int com_dedicated;

//----- (080929F8) --------------------------------------------------------
int __cdecl sub_80929F8(_DWORD *a1, _DWORD *a2)
{
  int result; // eax

  *a2 = *a1;
  a2[1] = a1[1];
  result = a1[2];
  a2[2] = result;
  return result;
}

//----- (08092A28) --------------------------------------------------------
_BYTE *__cdecl sub_8092A28(_BYTE *a1)
{
  int v1; // ST00_4
  unsigned int v3; // [esp+0h] [ebp-4h]

  v3 = 0;
  while ( *a1 && v3 <= 0x3FC )
  {
    if ( *a1 == 10 )
    {
      *(_BYTE *)(v3 + 138981984) = 92;
      v1 = v3 + 1;
      *(_BYTE *)(v1 + 138981984) = 110;
      v3 = v1 + 1;
      goto LABEL_10;
    }
    if ( *a1 != 20 && *a1 != 21 )
    {
      byte_848B260[v3++] = *a1;
LABEL_10:
      ++a1;
    }
    else
    {
      ++a1;
    }
  }
  *(_BYTE *)(v3 + 138981984) = 0;
  return byte_848B260;
}

//----- (08092AB6) --------------------------------------------------------
signed int __cdecl sub_8092AB6(_BYTE *a1, _BYTE *a2)
{
  signed int v3; // [esp+0h] [ebp-8h]

  while ( *a1 && *a2 && *a1 != 32 && *a2 != 32 )
  {
    if ( *a1 != *a2 )
      return 0;
    ++a1;
    ++a2;
  }
  v3 = 0;
  if ( (!*a1 || *a1 == 32) && (!*a2 || *a2 == 32) )
    v3 = 1;
  return v3;
}

//----- (08092B3C) --------------------------------------------------------
signed int __cdecl sub_8092B3C(int a1, char *a2)
{
  int v3; // [esp+18h] [ebp-10h]
  int v4; // [esp+1Ch] [ebp-Ch]
  int i; // [esp+20h] [ebp-8h]

  for ( i = *(_DWORD *)(a1 + 133140) + 1; ; ++i )
  {
    if ( i > *(_DWORD *)(a1 + 133132) )
      return -1;
    v4 = i & 0x7F;
    if ( *(_DWORD *)(a1 + 1032 * v4 + 2064) )
    {
      if ( *a2 == *(char *)(a1 + 1032 * v4 + 1036) && (unsigned __int8)(*a2 - 120) > 2u )
        break;
    }
LABEL_12:
    ;
  }
  if ( !strcmp(a2 + 1, (const char *)(a1 + 1032 * v4 + 1037)) )
    return i;
  switch ( *a2 )
  {
    case 67:
    case 68:
    case 97:
    case 98:
    case 111:
    case 112:
    case 113:
    case 114:
    case 116:
      v3 = i;
      break;
    case 100:
    case 118:
      if ( !sub_8092AB6(a2 + 2, (_BYTE *)(a1 + 1032 * v4 + 1038)) )
        goto LABEL_12;
      v3 = i;
      break;
    default:
      goto LABEL_12;
  }
  return v3;
}

//----- (08092C6C) --------------------------------------------------------
int __cdecl sub_8092C6C(int a1)
{
  int result; // eax
  unsigned int v2; // [esp+0h] [ebp-24h]
  _DWORD *v3; // [esp+4h] [ebp-20h]
  _DWORD *v4; // [esp+8h] [ebp-1Ch]
  int v5; // [esp+Ch] [ebp-18h]
  int v6; // [esp+10h] [ebp-14h]
  int v7; // [esp+14h] [ebp-10h]
  int i; // [esp+18h] [ebp-Ch]

  v7 = *(_DWORD *)(a1 + 133140) + 1;
  for ( i = *(_DWORD *)(a1 + 133140) + 1; i <= *(_DWORD *)(a1 + 133132); ++i )
  {
    v6 = i & 0x7F;
    if ( *(_DWORD *)(a1 + 1032 * v6 + 2064) )
    {
      v5 = v7 & 0x7F;
      if ( v5 != v6 )
      {
        v4 = (_DWORD *)(a1 + 1032 * v5 + 1036);
        v3 = (_DWORD *)(a1 + 1032 * v6 + 1036);
        v2 = 1032;
        if ( ((_BYTE)a1 + 8 * (_BYTE)v5 + 12) & 4 )
        {
          *v4 = *v3;
          v4 = (_DWORD *)(a1 + 1032 * v5 + 1040);
          v3 = (_DWORD *)(a1 + 1032 * v6 + 1040);
          v2 = 1028;
        }
        qmemcpy(v4, v3, 4 * (v2 >> 2));
      }
      ++v7;
    }
  }
  result = v7 - 1;
  *(_DWORD *)(a1 + 133132) = v7 - 1;
  return result;
}

//----- (08092D5C) --------------------------------------------------------
int __cdecl sub_8092D5C(int a1, int a2, char *s)
{
  int result; // eax
  int v4; // ST3C_4
  unsigned int v5; // [esp+24h] [ebp-24h]
  _DWORD *v6; // [esp+28h] [ebp-20h]
  _DWORD *v7; // [esp+2Ch] [ebp-1Ch]
  int v8; // [esp+30h] [ebp-18h]
  signed int v9; // [esp+34h] [ebp-14h]
  int i; // [esp+38h] [ebp-10h]

  result = a1;
  if ( !*(_DWORD *)(a1 + 484860) )
  {
    if ( *(_DWORD *)(a1 + 133132) - *(_DWORD *)(a1 + 133136) <= 63 && *(_DWORD *)a1 == 4
      || (result = sub_8092C6C(a1), a2) )
    {
      v9 = sub_8092B3C(a1, s);
      if ( v9 < 0 )
      {
        ++*(_DWORD *)(a1 + 133132);
      }
      else
      {
        v8 = v9 + 1;
        while ( v8 <= *(_DWORD *)(a1 + 133132) )
        {
          v7 = (_DWORD *)(a1 + 1032 * (v9 & 0x7F) + 1036);
          v6 = (_DWORD *)(a1 + 1032 * (v8 & 0x7F) + 1036);
          v5 = 1032;
          if ( ((_BYTE)a1 + 8 * (v9 & 0x7F) + 12) & 4 )
          {
            *v7 = *v6;
            v7 = (_DWORD *)(a1 + 1032 * (v9 & 0x7F) + 1040);
            v6 = (_DWORD *)(a1 + 1032 * (v8 & 0x7F) + 1040);
            v5 = 1028;
          }
          qmemcpy(v7, v6, 4 * (v5 >> 2));
          ++v8;
          LOBYTE(v9) = v9 + 1;
        }
      }
      if ( *(_DWORD *)(a1 + 133132) - *(_DWORD *)(a1 + 133136) == 129 )
      {
        Com_Printf("===== pending server commands =====\n");
        for ( i = *(_DWORD *)(a1 + 133136) + 1; i <= *(_DWORD *)(a1 + 133132); ++i )
          Com_Printf(
            "cmd %5d: %8d: %s\n",
            i,
            *(_DWORD *)(a1 + 1032 * (i & 0x7F) + 2060),
            a1 + 1032 * (i & 0x7F) + 1036);
        Com_Printf("cmd %5d: %8d: %s\n", i, dword_841FB04, s);
        sub_806C40C(
          1,
          *(_DWORD *)(a1 + 452036),
          *(_DWORD *)(a1 + 452040),
          *(_DWORD *)(a1 + 452044),
          *(_DWORD *)(a1 + 452048),
          *(_DWORD *)(a1 + 452052),
          "disconnect");
        sub_808DEA6((_DWORD *)a1, "EXE_SERVERCOMMANDOVERFLOW");
        a2 = 1;
        s = va("%c \"EXE_SERVERCOMMANDOVERFLOW\"", 119);
      }
      v4 = *(_DWORD *)(a1 + 133132) & 0x7F;
      sub_8068424(s, a1 + 1032 * v4 + 1036, 1024);
      *(_DWORD *)(a1 + 1032 * v4 + 2060) = dword_841FB04;
      result = a2;
      *(_DWORD *)(a1 + 1032 * v4 + 2064) = a2;
    }
  }
  return result;
}

//----- (0809301C) --------------------------------------------------------
int sub_809301C(int a1, int a2, char *format, ...)
{
  int result; // eax
  _BYTE *v4; // eax
  int v5; // [esp+14h] [ebp-34h]
  _DWORD *v6; // [esp+18h] [ebp-30h]
  char *s; // [esp+1Ch] [ebp-2Ch]
  char v8; // [esp+20h] [ebp-28h]
  __gnuc_va_list __varargs; // [esp+3Ch] [ebp-Ch]
  va_list va; // [esp+5Ch] [ebp+14h]

  va_start(va, format);
  sub_80AA1F6((int *)&v8, 0x4000);
  s = sub_80AA240((int *)&v8);
  va_copy(__varargs, va);
  vsprintf(s, format, va);
  if ( a1 )
  {
    sub_8092D5C(a1, a2, s);
    result = sub_80AA22A((int *)&v8);
  }
  else
  {
    if ( *(_DWORD *)(com_dedicated + 8) && !strncmp(s, "print", 5u) )
    {
      v4 = sub_8092A28(s);
      Com_Printf("broadcast: %s\n", v4);
    }
    v5 = 0;
    v6 = dword_841FB0C;
    while ( v5 < *(_DWORD *)(dword_848B1CC + 8) )
    {
      if ( *v6 > 2 )
        sub_8092D5C((int)v6, a2, s);
      ++v5;
      v6 += 123845;
    }
    result = sub_80AA22A((int *)&v8);
  }
  return result;
}
// 848B1CC: using guessed type int dword_848B1CC;
// 8494204: using guessed type int com_dedicated;

//----- (0809315A) --------------------------------------------------------
int __cdecl sub_809315A(char a1, int a2, int a3, int a4, int a5, _DWORD *a6)
{
  int result; // eax
  int v7; // ST18_4
  int v8; // ST1C_4
  int v9; // ST20_4
  int v10; // ST24_4
  signed int v11; // [esp+2Ch] [ebp-Ch]
  int v12; // [esp+30h] [ebp-8h]
  _DWORD *i; // [esp+34h] [ebp-4h]

  v11 = sub_8067F32(a6);
  v12 = 0;
  for ( i = dword_841FB0C; ; i += 123845 )
  {
    result = v12;
    if ( v12 >= *(_DWORD *)(dword_848B1CC + 8) )
      break;
    if ( *i )
    {
      v7 = i[113010];
      v8 = i[113011];
      v9 = i[113012];
      v10 = i[113013];
      if ( sub_806BF64(a1, a2, a3, a4, a5, i[113009]) && i[113014] == v11 )
      {
        if ( *((_WORD *)i + 226022) != (_WORD)a3 )
        {
          Com_Printf("SV_ReadPackets: fixing up a translated port\n");
          *((_WORD *)i + 226022) = a3;
        }
        if ( *i != 1 )
        {
          i[33604] = dword_841FB04;
          if ( *i > 3 )
            sub_809A112((int)i, a6);
          else
            sub_809A1EA((int)i, a6);
        }
      }
    }
    ++v12;
  }
  return result;
}
// 848B1CC: using guessed type int dword_848B1CC;

//----- (08093288) --------------------------------------------------------
int __cdecl sub_8093288(int a1, int a2, int a3, int a4, int a5)
{
  char *v5; // eax
  char *v6; // eax
  char *v7; // eax
  int v8; // ST2C_4
  char *v9; // eax
  char *v10; // eax
  char v12; // [esp+30h] [ebp-4858h]
  char v13[4]; // [esp+43Ch] [ebp-444Ch]
  _BYTE *v14; // [esp+440h] [ebp-4448h]
  _BYTE *v15; // [esp+444h] [ebp-4444h]
  int v16; // [esp+448h] [ebp-4440h]
  _BYTE *v17; // [esp+44Ch] [ebp-443Ch]
  char v18; // [esp+450h] [ebp-4438h]
  char dest; // [esp+2450h] [ebp-2438h]
  size_t v20; // [esp+4458h] [ebp-430h]
  int v21; // [esp+445Ch] [ebp-42Ch]
  int v22; // [esp+4460h] [ebp-428h]
  char *v23; // [esp+4464h] [ebp-424h]
  int i; // [esp+4468h] [ebp-420h]
  char *v25; // [esp+446Ch] [ebp-41Ch]
  char v26; // [esp+4470h] [ebp-418h]
  char s; // [esp+4480h] [ebp-408h]

  sub_80AA1F6((int *)&v26, 0x4000);
  v25 = sub_80AA240((int *)&v26);
  *(_DWORD *)v13 = 0;
  v5 = sub_8063D30(0x404u);
  strcpy(&dest, v5);
  v6 = sub_806001C(1u);
  sub_80B5FF6(&dest, "challenge", (int)v6);
  if ( (unsigned __int8)Dvar_GetBool("fs_restrict") )
  {
    v7 = sub_80B5B30(&dest, (int)"sv_keywords");
    Com_sprintf(&v12, 0x400u, "demo %s", v7);
    sub_80B5FF6(&dest, "sv_keywords", (int)&v12);
  }
  *v25 = 0;
  v21 = 0;
  for ( i = 0; i < *(_DWORD *)(dword_848B1CC + 8); ++i )
  {
    v23 = (char *)dword_841FB0C + 495380 * i;
    if ( *((_DWORD *)dword_841FB0C + 123845 * i) > 1 )
    {
      v22 = sub_808FE02(i);
      if ( dword_83DFA00 )
      {
        v8 = sub_810698A(-1653759219 * ((v23 - (_BYTE *)dword_841FB0C) >> 2));
        Com_sprintf(&s, 0x400u, "%i %i \"%s\"\n", v8, *((_DWORD *)v23 + 113001), v23 + 134216);
      }
      else
      {
        Com_sprintf(&s, 0x400u, "%i %i \"%s\"\n", 0, *((_DWORD *)v23 + 113001), v23 + 134216);
      }
      v20 = strlen(&s);
      if ( v21 + v20 > 0x3FFF )
        break;
      strcpy(&v25[v21], &s);
      v21 += v20;
    }
  }
  v17 = sub_80B0D96("g_password");
  if ( v17 && *v17 )
    sub_80B5FF6(&dest, "pswrd", (int)"1");
  else
    sub_80B5FF6(&dest, "pswrd", (int)"0");
  v15 = sub_80B0D96("fs_game");
  if ( !*(_BYTE *)(dword_848B200 + 8) || v15 && *v15 )
  {
    *(_DWORD *)v13 = 1;
  }
  else
  {
    v14 = sub_80B0D96("sv_referencedIwdNames");
    if ( *v14 )
    {
      sub_8060448(v14);
      v16 = sub_805FFE6();
      for ( i = 0; i < v16; ++i )
      {
        v9 = sub_806001C(i);
        if ( !sub_8064ECC(v9, (int)"main") )
        {
          *(_DWORD *)v13 = 1;
          break;
        }
      }
    }
  }
  v10 = va("%i", *(_DWORD *)v13);
  sub_80B5FF6(&dest, "mod", (int)v10);
  Com_sprintf(&v18, 0x2000u, "statusResponse\n%s\n%s", &dest, v25);
  sub_806C40C(1, a1, a2, a3, a4, a5, &v18);
  return sub_80AA22A((int *)&v26);
}
// 83DFA00: using guessed type int dword_83DFA00;
// 841FB08: using guessed type int dword_841FB08;
// 848B1CC: using guessed type int dword_848B1CC;
// 848B200: using guessed type int dword_848B200;

//----- (080936D4) --------------------------------------------------------
int __cdecl sub_80936D4(int a1, int a2, int a3, int a4, int a5)
{
  char *v5; // eax
  char *v6; // eax
  char *v7; // eax
  int v8; // eax
  char *v9; // eax
  char v11; // [esp+30h] [ebp-C38h]
  char dest; // [esp+430h] [ebp-838h]
  size_t v13; // [esp+838h] [ebp-430h]
  int v14; // [esp+83Ch] [ebp-42Ch]
  int v15; // [esp+840h] [ebp-428h]
  char *v16; // [esp+844h] [ebp-424h]
  int i; // [esp+848h] [ebp-420h]
  char *v18; // [esp+84Ch] [ebp-41Ch]
  char v19; // [esp+850h] [ebp-418h]
  char s; // [esp+860h] [ebp-408h]

  sub_80AA1F6((int *)&v19, 0x4000);
  v18 = sub_80AA240((int *)&v19);
  v5 = sub_8063D30(0x404u);
  strcpy(&dest, v5);
  v6 = sub_806001C(1u);
  sub_80B5FF6(&dest, "challenge", (int)v6);
  if ( (unsigned __int8)Dvar_GetBool("fs_restrict") )
  {
    v7 = sub_80B5B30(&dest, (int)"sv_keywords");
    Com_sprintf(&v11, 0x400u, "demo %s", v7);
    sub_80B5FF6(&dest, "sv_keywords", (int)&v11);
  }
  *v18 = 0;
  v14 = 0;
  for ( i = 0; i < *(_DWORD *)(dword_848B1CC + 8); ++i )
  {
    v16 = (char *)dword_841FB0C + 495380 * i;
    if ( *((_DWORD *)dword_841FB0C + 123845 * i) > 1 )
    {
      v15 = sub_808FE02(i);
      v8 = sub_810698A(-1653759219 * ((v16 - (_BYTE *)dword_841FB0C) >> 2));
      Com_sprintf(&s, 0x400u, "%i %i \"%s\"\n", v8, *((_DWORD *)v16 + 113001), v16 + 134216);
      v13 = strlen(&s);
      if ( v14 + v13 > 0x3FFF )
        break;
      strcpy(&v18[v14], &s);
      v14 += v13;
    }
  }
  v9 = va("gameCompleteStatus\n%s\n%s", &dest, v18);
  sub_806C40C(1, a1, a2, a3, a4, a5, v9);
  return sub_80AA22A((int *)&v19);
}
// 841FB08: using guessed type int dword_841FB08;
// 848B1CC: using guessed type int dword_848B1CC;

//----- (08093980) --------------------------------------------------------
_BOOL4 __cdecl sub_8093980(int a1, int a2, int a3, int a4, int a5)
{
  char *v5; // eax
  char *v6; // eax
  char *v7; // eax
  char *v8; // eax
  char *v9; // eax
  char *v10; // eax
  char *v11; // eax
  char *v12; // eax
  char *v13; // eax
  char *v14; // eax
  char *v15; // eax
  char *v16; // eax
  char *v17; // eax
  char *v18; // eax
  _BYTE *v20; // [esp+2Ch] [ebp-83Ch]
  char dest; // [esp+30h] [ebp-838h]
  char src; // [esp+430h] [ebp-438h]
  char v23[4]; // [esp+83Ch] [ebp-2Ch]
  char v24[4]; // [esp+840h] [ebp-28h]
  char v25[4]; // [esp+844h] [ebp-24h]
  _BYTE *v26; // [esp+848h] [ebp-20h]
  int v27; // [esp+84Ch] [ebp-1Ch]
  int v28; // [esp+850h] [ebp-18h]
  int v29; // [esp+854h] [ebp-14h]
  char v30[4]; // [esp+858h] [ebp-10h]
  int i; // [esp+85Ch] [ebp-Ch]

  v29 = 0;
  for ( i = 0; i < *(_DWORD *)(dword_848B1D0 + 8); ++i )
  {
    if ( *((_DWORD *)dword_841FB0C + 123845 * i) > 1 )
      ++v29;
  }
  *(_DWORD *)v30 = v29;
  for ( i = *(_DWORD *)(dword_848B1D0 + 8); i < *(_DWORD *)(dword_848B1CC + 8); ++i )
  {
    if ( *((_DWORD *)dword_841FB0C + 123845 * i) > 1 )
      ++*(_DWORD *)v30;
  }
  src = 0;
  v5 = sub_806001C(1u);
  sub_80B5FF6(&src, "challenge", (int)v5);
  v6 = va("%i", 115);
  sub_80B5FF6(&src, "protocol", (int)v6);
  sub_80B5FF6(&src, "hostname", *(_DWORD *)(dword_848B1D4 + 8));
  sub_80B5FF6(&src, "mapname", *(_DWORD *)(dword_848B1E0 + 8));
  if ( *(_DWORD *)v30 )
  {
    v7 = va("%i", *(_DWORD *)v30);
    sub_80B5FF6(&src, "clients", (int)v7);
  }
  *(_DWORD *)v23 = *(_DWORD *)(dword_848B1CC + 8) - (*(_DWORD *)(dword_848B1D0 + 8) - v29);
  if ( *(_DWORD *)v23 > 0 )
  {
    v8 = va("%i", *(_DWORD *)v23);
    sub_80B5FF6(&src, "sv_maxclients", (int)v8);
  }
  sub_80B5FF6(&src, "gametype", *(_DWORD *)(dword_848B1F4 + 8));
  if ( *(_BYTE *)(dword_848B200 + 8) || fs_numServerIwds )
    sub_80B5FF6(&src, "pure", (int)"1");
  if ( *(_DWORD *)(dword_848B1EC + 8) )
  {
    v9 = va("%i", *(_DWORD *)(dword_848B1EC + 8));
    sub_80B5FF6(&src, "minPing", (int)v9);
  }
  if ( *(_DWORD *)(dword_848B1F0 + 8) )
  {
    v10 = va("%i", *(_DWORD *)(dword_848B1F0 + 8));
    sub_80B5FF6(&src, "maxPing", (int)v10);
  }
  v27 = (int)sub_80B0D96("fs_game");
  if ( *(_BYTE *)v27 )
    sub_80B5FF6(&src, "game", v27);
  if ( *(_BYTE *)(dword_848B20C + 8) )
  {
    v11 = va("%i", *(unsigned __int8 *)(dword_848B20C + 8));
    sub_80B5FF6(&src, "sv_allowAnonymous", (int)v11);
  }
  if ( *(_BYTE *)(dword_848B228 + 8) )
  {
    v12 = va("%i", *(unsigned __int8 *)(dword_848B228 + 8));
    sub_80B5FF6(&src, "con_disabled", (int)v12);
  }
  v26 = sub_80B0D96("g_password");
  if ( v26 && *v26 )
    sub_80B5FF6(&src, "pswrd", (int)"1");
  *(_DWORD *)v25 = Dvar_GetInt("scr_friendlyfire");
  if ( *(_DWORD *)v25 )
  {
    v13 = va("%i", *(_DWORD *)v25);
    sub_80B5FF6(&src, "ff", (int)v13);
  }
  *(_DWORD *)v24 = Dvar_GetInt("scr_killcam");
  if ( *(_DWORD *)v24 )
  {
    v14 = va("%i", *(_DWORD *)v24);
    sub_80B5FF6(&src, "kc", (int)v14);
  }
  v15 = va("%i", 1);
  sub_80B5FF6(&src, "hw", (int)v15);
  if ( !*(_BYTE *)(dword_848B200 + 8) || v27 && *(_BYTE *)v27 )
  {
    v16 = va("%i", 1);
  }
  else
  {
    v20 = sub_80B0D96("sv_referencedIwdNames");
    if ( *v20 )
    {
      sub_8060448(v20);
      v28 = sub_805FFE6();
      for ( i = 0; i < v28; ++i )
      {
        v17 = sub_806001C(i);
        if ( !sub_8064ECC(v17, (int)"main") )
        {
          v16 = va("%i", 1);
          goto LABEL_46;
        }
      }
    }
    v16 = va("%i", 0);
  }
LABEL_46:
  sub_80B5FF6(&src, "mod", (int)v16);
  v18 = va("%i", *(unsigned __int8 *)(dword_848B22C + 8));
  sub_80B5FF6(&src, "voice", (int)v18);
  I_strncpyz(&dest, "infoResponse\n", 1024);
  sub_80B57C0(&dest, 1024, &src);
  return sub_806C40C(1, a1, a2, a3, a4, a5, &dest);
}
// 848B1CC: using guessed type int dword_848B1CC;
// 848B1D0: using guessed type int dword_848B1D0;
// 848B1D4: using guessed type int dword_848B1D4;
// 848B1E0: using guessed type int dword_848B1E0;
// 848B1EC: using guessed type int dword_848B1EC;
// 848B1F0: using guessed type int dword_848B1F0;
// 848B200: using guessed type int dword_848B200;
// 848B20C: using guessed type int dword_848B20C;
// 848B228: using guessed type int dword_848B228;
// 848B22C: using guessed type int dword_848B22C;
// 848FF00: using guessed type int fs_numServerIwds;

//----- (08093F1E) --------------------------------------------------------
void __usercall sub_8093F1E(long double a1@<st0>, int a2, int a3, int a4, int a5, int a6, _DWORD *a7)
{
  _BYTE *v7; // ST24_4
  char *v8; // eax
  char *v9; // [esp+20h] [ebp-8h]

  sub_806775C(a7);
  sub_8067F90(a7);
  sub_80955EA(a7[3]);
  v7 = sub_8068146(a7);
  sub_8060448(v7);
  v9 = sub_806001C(0);
  if ( *(_BYTE *)(dword_848B214 + 8) )
  {
    v8 = sub_806AD14(a2, a3, a4, a5, a6);
    Com_Printf("SV packet %s : %s\n", v8, v9);
  }
  if ( I_stricmp(v9, "v") )
  {
    if ( I_stricmp(v9, "getstatus") )
    {
      if ( I_stricmp(v9, "getinfo") )
      {
        if ( I_stricmp(v9, "getchallenge") )
        {
          if ( I_stricmp(v9, "connect") )
          {
            if ( I_stricmp(v9, "ipAuthorize") )
            {
              if ( I_stricmp(v9, "rcon") )
                I_stricmp(v9, "disconnect");
              else
                sub_80951B4(a1, a2, a3, a4, a5, a6);
            }
            else
            {
              sub_808C7CA(a2, a3, a4, a5, a6);
            }
          }
          else
          {
            sub_808D0E6(a1, a2, a3, a4, a5, a6);
          }
        }
        else
        {
          sub_808BE54(a1, a2, a3, a4, a5, a6);
        }
      }
      else
      {
        sub_8093980(a2, a3, a4, a5, a6);
      }
    }
    else
    {
      sub_8093288(a2, a3, a4, a5, a6);
    }
  }
  else
  {
    sub_809315A(a2, a3, a4, a5, a6, a7);
  }
}
// 848B214: using guessed type int dword_848B214;

//----- (080941AE) --------------------------------------------------------
void __usercall sub_80941AE(long double a1@<st0>, int a2, int a3, int a4, int a5, int a6, _DWORD *a7)
{
  int v7; // ST18_4
  int v8; // ST1C_4
  int v9; // ST20_4
  int v10; // ST24_4
  int v11; // [esp+28h] [ebp-10h]
  _DWORD *i; // [esp+2Ch] [ebp-Ch]
  int v13; // [esp+30h] [ebp-8h]

  if ( a7[3] <= 3 || *(_DWORD *)a7[1] != -1 )
  {
    sub_80905C8();
    sub_806775C(a7);
    sub_8067F90(a7);
    v11 = (unsigned __int16)sub_8067F32(a7);
    v13 = 0;
    for ( i = dword_841FB0C; ; i += 123845 )
    {
      if ( v13 >= *(_DWORD *)(dword_848B1CC + 8) )
      {
        sub_806C40C(1, a2, a3, a4, a5, a6, "disconnect");
        return;
      }
      if ( *i )
      {
        v7 = i[113010];
        v8 = i[113011];
        v9 = i[113012];
        v10 = i[113013];
        if ( sub_806BF64(a2, a3, a4, a5, a6, i[113009]) && i[113014] == v11 )
          break;
      }
      ++v13;
    }
    if ( *((_WORD *)i + 226022) != (_WORD)a4 )
    {
      Com_Printf("SV_ReadPackets: fixing up a translated port\n");
      *((_WORD *)i + 226022) = a4;
    }
    if ( sub_806B9CA((int)(i + 113005), a7) )
    {
      i[121216] = sub_8067EE8(a7);
      i[33286] = sub_8067F90(a7);
      if ( i[33286] >= 0 )
      {
        i[33284] = sub_8067F90(a7);
        if ( i[33283] - i[33284] <= 127 )
        {
          sub_80954DE((int)i, (_BYTE *)(a7[1] + a7[4]), a7[3] - a7[4]);
          if ( *i != 1 )
          {
            i[33604] = dword_841FB04;
            sub_808F82A(a1, (int)i, a7);
            dword_855A4E0 = 0;
          }
        }
        else
        {
          i[33284] = i[33283];
        }
      }
    }
  }
  else
  {
    sub_8093F1E(a1, a2, a3, a4, a5, a6, a7);
  }
}
// 848B1CC: using guessed type int dword_848B1CC;

//----- (0809443E) --------------------------------------------------------
int sub_809443E()
{
  int result; // eax
  int v1; // [esp+8h] [ebp-18h]
  int v2; // [esp+Ch] [ebp-14h]
  char *v3; // [esp+10h] [ebp-10h]
  signed int j; // [esp+14h] [ebp-Ch]
  int i; // [esp+18h] [ebp-8h]

  for ( i = 0; ; ++i )
  {
    result = i;
    if ( i >= *(_DWORD *)(dword_848B1CC + 8) )
      break;
    v3 = (char *)dword_841FB0C + 495380 * i;
    if ( *((_DWORD *)dword_841FB0C + 123845 * i) == 4 )
    {
      if ( *((_DWORD *)v3 + 33553) )
      {
        v2 = 0;
        v1 = 0;
        for ( j = 0; j <= 31; ++j )
        {
          if ( *(_DWORD *)&v3[9924 * j + 144352] > 0 )
          {
            ++v1;
            v2 += *(_DWORD *)&v3[9924 * j + 144352] - *(_DWORD *)&v3[9924 * j + 144348];
          }
        }
        if ( v1 )
        {
          *((_DWORD *)v3 + 113001) = v2 / v1;
          if ( *((_DWORD *)v3 + 113001) > 999 )
            *((_DWORD *)v3 + 113001) = 999;
        }
        else
        {
          *((_DWORD *)v3 + 113001) = 999;
        }
      }
      else
      {
        *((_DWORD *)v3 + 113001) = 999;
      }
    }
    else
    {
      *((_DWORD *)v3 + 113001) = 999;
    }
  }
  return result;
}
// 848B1CC: using guessed type int dword_848B1CC;

//----- (08094586) --------------------------------------------------------
int __cdecl sub_8094586(int a1)
{
  int result; // eax

  sub_807F554(*(unsigned __int16 *)(a1 + 484856));
  result = a1;
  *(_WORD *)(a1 + 484856) = 0;
  return result;
}

//----- (080945AC) --------------------------------------------------------
int __usercall sub_80945AC@<eax>(long double a1@<st0>)
{
  int result; // eax
  int v2; // [esp+8h] [ebp-10h]
  int v3; // [esp+Ch] [ebp-Ch]
  char *i; // [esp+10h] [ebp-8h]
  int v5; // [esp+14h] [ebp-4h]

  v3 = dword_841FB04 - 1000 * *(_DWORD *)(dword_848B1B8 + 8);
  v2 = dword_841FB04 - 1000 * *(_DWORD *)(dword_848B1BC + 8);
  v5 = 0;
  for ( i = (char *)dword_841FB0C; ; i += 495380 )
  {
    result = v5;
    if ( v5 >= *(_DWORD *)(dword_848B1CC + 8) )
      break;
    if ( *((_DWORD *)i + 33604) > dword_841FB04 )
      *((_DWORD *)i + 33604) = dword_841FB04;
    if ( !*((_DWORD *)i + 121215) )
    {
      if ( *(_DWORD *)i != 1 || *((_DWORD *)i + 33604) >= v2 )
      {
        if ( *(_DWORD *)i <= 1 || *((_DWORD *)i + 33604) >= v3 )
        {
          *((_DWORD *)i + 33608) = 0;
        }
        else if ( ++*((_DWORD *)i + 33608) > 5 )
        {
          sub_808DC8C(a1, i, "EXE_TIMEDOUT");
          *(_DWORD *)i = 0;
        }
      }
      else
      {
        Com_DPrintf("Going from CS_ZOMBIE to CS_FREE for %s\n", i + 134216);
        *(_DWORD *)i = 0;
      }
    }
    ++v5;
  }
  return result;
}
// 848B1B8: using guessed type int dword_848B1B8;
// 848B1BC: using guessed type int dword_848B1BC;
// 848B1CC: using guessed type int dword_848B1CC;

//----- (080946DA) --------------------------------------------------------
signed int sub_80946DA()
{
  signed int v1; // [esp+8h] [ebp-10h]
  int v2; // [esp+Ch] [ebp-Ch]
  _DWORD *v3; // [esp+10h] [ebp-8h]
  signed int v4; // [esp+14h] [ebp-4h]

  if ( !*(_DWORD *)(cl_paused + 8) )
    return 0;
  v4 = 0;
  v2 = 0;
  v3 = dword_841FB0C;
  while ( v2 < *(_DWORD *)(dword_848B1CC + 8) )
  {
    if ( *v3 > 1 )
      ++v4;
    ++v2;
    v3 += 123845;
  }
  if ( v4 <= 1 )
  {
    Dvar_SetInt(sv_paused, (char *)1);
    v1 = 1;
  }
  else
  {
    Dvar_SetInt(sv_paused, 0);
    v1 = 0;
  }
  return v1;
}
// 819EF28: using guessed type int cl_paused;
// 819EF34: using guessed type int sv_paused;
// 848B1CC: using guessed type int dword_848B1CC;

//----- (08094780) --------------------------------------------------------
void __usercall sub_8094780(long double a1@<st0>)
{
  sub_80905C8();
  sub_8107CA2(a1, dword_841FB04);
}

//----- (0809479A) --------------------------------------------------------
int __usercall sub_809479A@<eax>(long double a1@<st0>, char *a2)
{
  int result; // eax
  char s; // [esp+20h] [ebp-28h]
  int v4; // [esp+24h] [ebp-24h]
  char v5; // [esp+28h] [ebp-20h]
  int v6; // [esp+2Ch] [ebp-1Ch]
  int v7; // [esp+30h] [ebp-18h]
  int v8; // [esp+34h] [ebp-14h]
  char v9; // [esp+38h] [ebp-10h]
  char v10; // [esp+39h] [ebp-Fh]

  result = (int)a2;
  if ( *((_DWORD *)a2 + 33553) )
  {
    memset(&s, 0, 0x1Cu);
    v5 = *(_BYTE *)(sub_808FE02(-1653759219 * ((a2 - (_BYTE *)dword_841FB0C) >> 2)) + 212);
    if ( !sub_81069A6(-1653759219 * ((a2 - (_BYTE *)dword_841FB0C) >> 2)) )
    {
      if ( sub_80A1410() < 0.5 )
        v4 |= 1u;
      if ( sub_80A1410() < 0.5 )
        v4 |= 0x28u;
      if ( sub_80A1410() >= 0.33000001 )
      {
        if ( sub_80A1410() < 0.5 )
          v9 = -127;
      }
      else
      {
        v9 = 127;
      }
      if ( sub_80A1410() >= 0.33000001 )
      {
        if ( sub_80A1410() < 0.5 )
          v10 = -127;
      }
      else
      {
        v10 = 127;
      }
      if ( sub_80A1410() < 0.33000001 )
        v6 = (signed int)(sub_80A142E() * 360.0);
      if ( sub_80A1410() < 0.33000001 )
        v7 = (signed int)(sub_80A142E() * 360.0);
      a1 = sub_80A1410();
      if ( a1 < 0.33000001 )
      {
        a1 = sub_80A142E() * 360.0;
        v8 = (signed int)a1;
      }
    }
    *((_DWORD *)a2 + 33602) = *((_DWORD *)a2 + 113005) - 1;
    result = sub_808F488(a1, a2, (int *)&s);
  }
  return result;
}
// 841FB08: using guessed type int dword_841FB08;

//----- (08094980) --------------------------------------------------------
int __usercall sub_8094980@<eax>(long double a1@<st0>)
{
  int result; // eax
  char *i; // [esp+10h] [ebp-8h]
  int v3; // [esp+14h] [ebp-4h]

  sub_80905C8();
  v3 = 0;
  for ( i = (char *)dword_841FB0C; ; i += 495380 )
  {
    result = v3;
    if ( v3 >= *(_DWORD *)(dword_848B1CC + 8) )
      break;
    if ( *(_DWORD *)i )
    {
      if ( !*((_DWORD *)i + 113009) )
        sub_809479A(a1, i);
    }
    ++v3;
  }
  return result;
}
// 848B1CC: using guessed type int dword_848B1CC;

//----- (080949DE) --------------------------------------------------------
void __usercall sub_80949DE(long double a1@<st0>, int a2)
{
  char *v2; // eax
  char *v3; // eax
  char *v4; // eax
  char *v5; // eax
  char *v6; // eax
  char *v7; // eax
  char *v8; // eax
  char *v9; // eax
  char *v10; // eax
  char *v11; // eax
  char dest; // [esp+20h] [ebp-58h]
  int v13; // [esp+6Ch] [ebp-Ch]

  if ( *((_BYTE *)off_815A498 + 221) )
  {
    if ( off_815A498 == (void *)-222 )
      sub_8060BFA(a1, (int)"EXE_SERVERKILLED");
    else
      sub_8060BFA(a1, (int)off_815A498 + 222);
    *((_BYTE *)off_815A498 + 221) = 0;
  }
  else if ( *(_BYTE *)(com_sv_running + 8) )
  {
    if ( !sub_80946DA() )
    {
      v13 = 1000 / *(_DWORD *)(dword_848B1B4 + 8);
      dword_842BC90 += a2;
      if ( dword_842BC90 >= v13 )
      {
        if ( dword_841FB04 <= 1879048192 )
        {
          if ( dword_841FB18 < 2147483646 - dword_841FB10 )
          {
            if ( dword_841FB3C <= 2147467261 )
            {
              if ( dword_841FB40 <= 2147479549 )
              {
                if ( dword_841FB2C <= 2147482445 )
                {
                  if ( dword_841FB38 <= 2113929213 )
                  {
                    if ( dword_841FB44 <= 2147483133 )
                    {
                      if ( dword_841FB1C < 2147483646 - dword_841FB14 )
                      {
                        if ( dvar_modifiedFlags & 0x404 )
                        {
                          v10 = sub_8063D30(0x404u);
                          sub_8090E6C(0, v10);
                          dvar_modifiedFlags &= 0xFFFFFBFB;
                        }
                        if ( dvar_modifiedFlags & 8 )
                        {
                          v11 = sub_8063D92(8u);
                          sub_8090E6C(1, v11);
                          dvar_modifiedFlags &= 0xFFFFFFF7;
                        }
                        if ( dvar_modifiedFlags & 0x100 )
                        {
                          sub_8063CD4(142, 96, 0x100u);
                          dvar_modifiedFlags &= 0xFFFFFEFF;
                        }
                        sub_8094980(a1);
                        sub_809443E();
                        while ( 1 )
                        {
                          dword_842BC90 -= v13;
                          dword_841FB04 += v13;
                          sub_8094780(a1);
                          sub_807F9F2(0);
                          if ( dword_842BC90 < v13 )
                            break;
                          sub_8098E3A();
                        }
                        sub_80945AC(a1);
                        sub_8099AF2(a1);
                        sub_8098E3A();
                        sub_8094F02((int)"COD-2");
                      }
                      else
                      {
                        I_strncpyz(&dest, *(char **)(dword_848B1E0 + 8), 64);
                        sub_8060BFA(a1, (int)&unk_8144AC0);
                        v9 = va("map %s\n", &dest);
                        Cbuf_AddText(v9);
                      }
                    }
                    else
                    {
                      I_strncpyz(&dest, *(char **)(dword_848B1E0 + 8), 64);
                      sub_8060BFA(a1, (int)&unk_8144A80);
                      v8 = va("map %s\n", &dest);
                      Cbuf_AddText(v8);
                    }
                  }
                  else
                  {
                    I_strncpyz(&dest, *(char **)(dword_848B1E0 + 8), 64);
                    sub_8060BFA(a1, (int)&unk_8144A40);
                    v7 = va("map %s\n", &dest);
                    Cbuf_AddText(v7);
                  }
                }
                else
                {
                  I_strncpyz(&dest, *(char **)(dword_848B1E0 + 8), 64);
                  sub_8060BFA(a1, (int)&unk_8144A00);
                  v6 = va("map %s\n", &dest);
                  Cbuf_AddText(v6);
                }
              }
              else
              {
                I_strncpyz(&dest, *(char **)(dword_848B1E0 + 8), 64);
                sub_8060BFA(a1, (int)&unk_81449C0);
                v5 = va("map %s\n", &dest);
                Cbuf_AddText(v5);
              }
            }
            else
            {
              I_strncpyz(&dest, *(char **)(dword_848B1E0 + 8), 64);
              sub_8060BFA(a1, (int)&unk_8144980);
              v4 = va("map %s\n", &dest);
              Cbuf_AddText(v4);
            }
          }
          else
          {
            I_strncpyz(&dest, *(char **)(dword_848B1E0 + 8), 64);
            sub_8060BFA(a1, (int)&unk_8144940);
            v3 = va("map %s\n", &dest);
            Cbuf_AddText(v3);
          }
        }
        else
        {
          I_strncpyz(&dest, *(char **)(dword_848B1E0 + 8), 64);
          sub_8060BFA(a1, (int)"EXE_SERVERRESTARTTIMEWRAP");
          v2 = va("map %s\n", &dest);
          Cbuf_AddText(v2);
        }
      }
    }
  }
}
// 815A498: using guessed type void *off_815A498;
// 819EF14: using guessed type int com_sv_running;
// 841FB10: using guessed type int dword_841FB10;
// 841FB14: using guessed type int dword_841FB14;
// 841FB18: using guessed type int dword_841FB18;
// 841FB1C: using guessed type int dword_841FB1C;
// 841FB2C: using guessed type int dword_841FB2C;
// 841FB38: using guessed type int dword_841FB38;
// 841FB3C: using guessed type int dword_841FB3C;
// 841FB40: using guessed type int dword_841FB40;
// 841FB44: using guessed type int dword_841FB44;
// 842BC90: using guessed type int dword_842BC90;
// 848B1B4: using guessed type int dword_848B1B4;
// 848B1E0: using guessed type int dword_848B1E0;
// 85178A8: using guessed type int dvar_modifiedFlags;

//----- (08094E38) --------------------------------------------------------
int *sub_8094E38()
{
  __int16 v0; // ax

  if ( !dword_848B660 )
  {
    Com_Printf("Resolving %s\n", "cod2master.activision.com");
    if ( sub_806C750("cod2master.activision.com", &dword_848B660) )
    {
      if ( !strstr(":", "cod2master.activision.com") )
        word_848B668 = sub_80B4F9A(20710);
      v0 = sub_80B4F9A(word_848B668);
      Com_Printf(
        "cod2master.activision.com resolved to %i.%i.%i.%i:%i\n",
        (unsigned __int8)byte_848B664,
        (unsigned __int8)byte_848B665,
        (unsigned __int8)byte_848B666,
        (unsigned __int8)byte_848B667,
        v0);
    }
    else
    {
      Com_Printf("Couldn't resolve address: cod2master.activision.com\n");
    }
  }
  return &dword_848B660;
}
// 848B660: using guessed type int dword_848B660;
// 848B664: using guessed type char byte_848B664;
// 848B665: using guessed type char byte_848B665;
// 848B666: using guessed type char byte_848B666;
// 848B667: using guessed type char byte_848B667;
// 848B668: using guessed type __int16 word_848B668;

//----- (08094F02) --------------------------------------------------------
void __cdecl sub_8094F02(int a1)
{
  char *v1; // eax
  int *v2; // [esp+24h] [ebp-4h]
  int *v3; // [esp+24h] [ebp-4h]

  if ( com_dedicated && *(_DWORD *)(com_dedicated + 8) == 2 )
  {
    if ( dword_841FB04 >= dword_841FB54 )
    {
      dword_841FB54 = dword_841FB04 + 180000;
      v2 = sub_8094E38();
      if ( *v2 != 1 )
      {
        Com_Printf("Sending heartbeat to cod2master.activision.com\n");
        v1 = va("heartbeat %s\n", a1);
        sub_806C40C(1, *v2, v2[1], v2[2], v2[3], v2[4], v1);
      }
    }
    if ( dword_841FB04 >= dword_841FB58 )
    {
      dword_841FB58 = dword_841FB04 + 600000;
      v3 = sub_8094E38();
      if ( *v3 != 1 )
        sub_8093288(*v3, v3[1], v3[2], v3[3], v3[4]);
    }
  }
}
// 841FB54: using guessed type int dword_841FB54;
// 841FB58: using guessed type int dword_841FB58;
// 8494204: using guessed type int com_dedicated;

//----- (08094FFC) --------------------------------------------------------
void sub_8094FFC()
{
  int *v0; // [esp+14h] [ebp-4h]

  if ( com_dedicated && *(_DWORD *)(com_dedicated + 8) == 2 )
  {
    v0 = sub_8094E38();
    if ( *v0 != 1 )
    {
      Com_Printf("Sending gameCompleteStatus to cod2master.activision.com\n");
      sub_80936D4(*v0, v0[1], v0[2], v0[3], v0[4]);
    }
  }
}
// 8494204: using guessed type int com_dedicated;

//----- (0809505E) --------------------------------------------------------
void sub_809505E()
{
  dword_841FB54 = 2147483648;
  sub_8094F02((int)"flatline");
}
// 841FB54: using guessed type int dword_841FB54;

//----- (0809507C) --------------------------------------------------------
_BOOL4 __cdecl sub_809507C(char *s)
{
  char v2; // [esp+30h] [ebp-538h]
  char v3; // [esp+55Bh] [ebp-Dh]
  int v4; // [esp+55Ch] [ebp-Ch]

  v4 = strlen(s);
  while ( v4 > 1294 )
  {
    v3 = s[1294];
    s[1294] = 0;
    Com_sprintf(&v2, 0x514u, "print\n%s", s);
    sub_806C40C(1, dword_842BB5C, dword_842BB60, *(int *)&dword_842BB64, dword_842BB68, dword_842BB6C, &v2);
    v4 -= 1294;
    s += 1294;
    *s = v3;
  }
  Com_sprintf(&v2, 0x514u, "print\n%s", s);
  return sub_806C40C(1, dword_842BB5C, dword_842BB60, *(int *)&dword_842BB64, dword_842BB68, dword_842BB6C, &v2);
}

//----- (080951B4) --------------------------------------------------------
int __usercall sub_80951B4@<eax>(long double a1@<st0>, int a2, int a3, int a4, int a5, int a6)
{
  int result; // eax
  char *v7; // ebx
  char *v8; // eax
  char *v9; // ebx
  char *v10; // eax
  char *v11; // eax
  char v12; // [esp+20h] [ebp-4418h]
  char *s1; // [esp+4014h] [ebp-424h]
  int v14; // [esp+4018h] [ebp-420h]
  int v15; // [esp+401Ch] [ebp-41Ch]
  char v16[1028]; // [esp+4020h] [ebp-418h]
  int v17; // [esp+4424h] [ebp-14h]
  int i; // [esp+4428h] [ebp-10h]
  int v19; // [esp+442Ch] [ebp-Ch]

  v17 = Com_Milliseconds();
  if ( !dword_848B674 || (result = v17 - dword_848B674, v17 - dword_848B674 > 499) )
  {
    dword_848B674 = v17;
    s1 = sub_806001C(1u);
    if ( **(_BYTE **)(dword_848B1C0 + 8) && !strcmp(s1, *(const char **)(dword_848B1C0 + 8)) )
    {
      v19 = 1;
      v9 = sub_806001C(2u);
      v10 = sub_806AD14(a2, a3, a4, a5, a6);
      Com_Printf("Rcon from %s:\n%s\n", v10, v9);
    }
    else
    {
      v19 = 0;
      v7 = sub_806001C(2u);
      v8 = sub_806AD14(a2, a3, a4, a5, a6);
      Com_Printf("Bad rcon from %s:\n%s\n", v8, v7);
    }
    dword_842BB5C = a2;
    dword_842BB60 = a3;
    *(_DWORD *)&dword_842BB64 = a4;
    dword_842BB68 = a5;
    dword_842BB6C = a6;
    sub_806092A(&v12, 16368, (int)sub_809507C);
    if ( **(_BYTE **)(dword_848B1C0 + 8) )
    {
      if ( v19 )
      {
        v15 = 0;
        v14 = 1024;
        for ( i = 2; i < sub_805FFE6(); ++i )
        {
          v11 = sub_806001C(i);
          v15 = sub_80626A8(v11, (int)v16, v15, v14, 1);
          v15 = sub_80626A8(" ", (int)v16, v15, v14, 0);
        }
        if ( v15 < v14 )
        {
          v16[v15] = 0;
          sub_8060754(a1, v16);
        }
      }
      else if ( *s1 )
      {
        Com_Printf("Invalid password.\n");
      }
      else
      {
        Com_Printf("You must log in with 'rcon login <password>' before using 'rcon'.\n");
      }
    }
    else
    {
      Com_Printf("The server must set 'rcon_password' for clients to use 'rcon'.\n");
    }
    result = sub_8060964();
  }
  return result;
}
// 848B1C0: using guessed type int dword_848B1C0;
// 848B674: using guessed type int dword_848B674;
// 80951B4: using guessed type char var_418[1028];

//----- (0809544E) --------------------------------------------------------
void sub_809544E()
{
  ;
}

//----- (08095454) --------------------------------------------------------
int __cdecl sub_8095454(int a1, _BYTE *a2, int a3)
{
  int result; // eax
  int v4; // [esp+0h] [ebp-10h]
  _BYTE v5[5]; // [esp+7h] [ebp-9h]
  int v6; // [esp+Ch] [ebp-4h]

  v4 = a1 + 133188;
  v5[4] = 0;
  *(_DWORD *)v5 = (unsigned __int8)(*(_BYTE *)(a1 + 133152) ^ *(_BYTE *)(a1 + 452020));
  v6 = 0;
  while ( 1 )
  {
    result = v6;
    if ( v6 >= a3 )
      break;
    if ( !*(_BYTE *)(v4 + *(_DWORD *)&v5[1]) )
      *(_DWORD *)&v5[1] = 0;
    v5[0] ^= *(unsigned __int8 *)(v4 + (*(_DWORD *)&v5[1])++) << (v6 & 1);
    *a2 ^= v5[0];
    ++v6;
    ++a2;
  }
  return result;
}

//----- (080954DE) --------------------------------------------------------
int __cdecl sub_80954DE(int a1, _BYTE *a2, int a3)
{
  int result; // eax
  int v4; // [esp+0h] [ebp-10h]
  _BYTE v5[5]; // [esp+7h] [ebp-9h]
  int v6; // [esp+Ch] [ebp-4h]

  v4 = a1 + 1032 * (*(_DWORD *)(a1 + 133136) & 0x7F) + 1036;
  v5[4] = 0;
  *(_DWORD *)v5 = (unsigned __int8)(*(_BYTE *)(a1 + 133144) ^ *(_BYTE *)(a1 + 484864) ^ *(_BYTE *)(a1 + 133152));
  v6 = 0;
  while ( 1 )
  {
    result = v6;
    if ( v6 >= a3 )
      break;
    if ( !*(_BYTE *)(v4 + *(_DWORD *)&v5[1]) )
      *(_DWORD *)&v5[1] = 0;
    v5[0] ^= *(unsigned __int8 *)(v4 + (*(_DWORD *)&v5[1])++) << (v6 & 1);
    *a2 ^= v5[0];
    ++v6;
    ++a2;
  }
  return result;
}

//----- (0809558C) --------------------------------------------------------
int __cdecl sub_809558C(int a1)
{
  return (unsigned __int8)sub_806B58C(a1);
}

//----- (080955A2) --------------------------------------------------------
int __cdecl sub_80955A2(int a1, void *src, size_t n)
{
  sub_8095454(a1, (_BYTE *)src + 4, n - 4);
  return (unsigned __int8)sub_806B7AC(a1 + 452020, n, src);
}

//----- (080955EA) --------------------------------------------------------
int __cdecl sub_80955EA(int a1)
{
  int result; // eax

  result = dword_81F710C;
  if ( *(_DWORD *)(dword_81F710C + 8) )
  {
    sub_806AE1A((void **)&dword_842BB84);
    result = sub_806AF0A(dword_842BB84, a1, 0);
  }
  return result;
}
// 81F710C: using guessed type int dword_81F710C;
// 842BB84: using guessed type int dword_842BB84;

//----- (08095626) --------------------------------------------------------
int __cdecl sub_8095626(size_t n, void *src, int a3, int a4, int a5, int a6, int a7)
{
  if ( *(_DWORD *)src != -1 )
    Com_Printf("SV_Netchan_SendOOBPacket used to send non-OOB packet.\n");
  sub_806AE1A((void **)&dword_842BB84);
  sub_806C32C(1, n, src, a3, a4, a5, a6, a7);
  return sub_80955EA(n);
}
// 842BB84: using guessed type int dword_842BB84;

//----- (08095696) --------------------------------------------------------
int sub_8095696()
{
  int result; // eax
  _DWORD **i; // [esp+10h] [ebp-8h]
  int v2; // [esp+14h] [ebp-4h]

  if ( dword_841FB0C )
  {
    if ( dword_842BB84 )
    {
      sub_806B09A((_DWORD *)dword_842BB84);
      sub_806B09A((_DWORD *)(dword_842BB84 + 752));
    }
    v2 = 0;
    for ( i = (_DWORD **)dword_841FB0C; ; i += 123845 )
    {
      result = v2;
      if ( v2 >= *(_DWORD *)(dword_848B1CC + 8) )
        break;
      if ( *i )
      {
        if ( i[121212] )
        {
          sub_806B09A(i[121212]);
          sub_806B09A(i[121212] + 188);
        }
      }
      ++v2;
    }
  }
  return result;
}
// 842BB84: using guessed type int dword_842BB84;
// 848B1CC: using guessed type int dword_848B1CC;

//----- (08095742) --------------------------------------------------------
int __cdecl sub_8095742(int a1)
{
  float v1; // ST04_4
  long double v2; // fst7
  float v3; // ST00_4
  float v4; // ST04_4
  long double v5; // fst7
  float v6; // ST00_4
  float v7; // ST04_4
  long double v8; // fst7
  float v9; // ST00_4
  double v10; // ST68_8
  float v11; // ST04_4
  long double v12; // fst7
  float v13; // ST00_4
  int result; // eax
  float v15; // ST04_4
  long double v16; // fst7
  float v17; // ST00_4
  double v18; // ST60_8
  float v19; // ST04_4
  long double v20; // fst7
  float v21; // ST00_4
  int v22; // [esp+2Ch] [ebp-4BCh]
  double v23; // [esp+30h] [ebp-4B8h]
  int v24; // [esp+74h] [ebp-474h]
  double v25; // [esp+78h] [ebp-470h]
  char s; // [esp+80h] [ebp-468h]
  char dest; // [esp+480h] [ebp-68h]
  char v28; // [esp+490h] [ebp-58h]
  char *i; // [esp+4A8h] [ebp-40h]
  _DWORD *v30; // [esp+4ACh] [ebp-3Ch]
  int v31; // [esp+4B0h] [ebp-38h]
  int v32; // [esp+4B4h] [ebp-34h]
  int v33; // [esp+4B8h] [ebp-30h]
  int v34; // [esp+4BCh] [ebp-2Ch]
  int v35; // [esp+4C0h] [ebp-28h]
  int v36; // [esp+4C4h] [ebp-24h]
  int v37; // [esp+4C8h] [ebp-20h]
  int v38; // [esp+4CCh] [ebp-1Ch]
  int v39; // [esp+4D0h] [ebp-18h]
  int v40; // [esp+4D4h] [ebp-14h]
  char v41[4]; // [esp+4D8h] [ebp-10h]
  char v42[4]; // [esp+4DCh] [ebp-Ch]

  *(_DWORD *)v41 = 0;
  v40 = 0;
  v39 = 0;
  v38 = 0;
  v37 = 0;
  v36 = 0;
  v35 = 0;
  v34 = 9999;
  v33 = 0;
  v32 = 9999;
  if ( dword_841FB0C )
  {
    sub_8095696();
    if ( a1 )
      Com_Printf("\n\n");
    Com_sprintf(&s, 0x400u, "====================");
    if ( a1 )
      Com_Printf("%s\n", &s);
    Com_sprintf(&s, 0x400u, "Server Network Profile:");
    if ( a1 )
      Com_Printf("%s\n\n", &s);
    Com_sprintf(
      &s,
      0x400u,
      "                    | Sent To                | Recieved From          | Total Source Traffic   |");
    if ( a1 )
      Com_Printf("%s\n", &s);
    Com_sprintf(
      &s,
      0x400u,
      "              Source|   bps|  max|  min|frag%%|   bps|  max|  min|frag%%|   bps|  max|  min|frag%%|");
    if ( a1 )
      Com_Printf("%s\n", &s);
    if ( dword_842BB84 )
    {
      v30 = (_DWORD *)dword_842BB84;
      *(_DWORD *)v41 += *(_DWORD *)(dword_842BB84 + 724);
      v39 += *(_DWORD *)(dword_842BB84 + 732);
      v38 += *(_DWORD *)(dword_842BB84 + 736);
      v40 += *(_DWORD *)(dword_842BB84 + 1476);
      v37 += *(_DWORD *)(dword_842BB84 + 1484);
      v36 += *(_DWORD *)(dword_842BB84 + 1488);
      if ( *(_DWORD *)(dword_842BB84 + 744) > v35 )
        v35 = v30[186];
      if ( v30[187] < v34 )
        v34 = v30[187];
      if ( v30[374] > v33 )
        v33 = v30[374];
      if ( v30[375] < v32 )
        v32 = v30[375];
    }
    *(_DWORD *)v42 = 0;
    i = (char *)dword_841FB0C;
    while ( *(_DWORD *)v42 < *(_DWORD *)(dword_848B1CC + 8) )
    {
      if ( *(_DWORD *)i && *((_DWORD *)i + 121212) )
      {
        v30 = (_DWORD *)*((_DWORD *)i + 121212);
        *(_DWORD *)v41 += v30[181];
        v39 += v30[183];
        v38 += v30[184];
        v40 += v30[369];
        v37 += v30[371];
        v36 += v30[372];
        if ( v30[186] > v35 )
          v35 = v30[186];
        if ( v30[187] < v34 )
          v34 = v30[187];
        if ( v30[374] > v33 )
          v33 = v30[374];
        if ( v30[375] < v32 )
          v32 = v30[375];
      }
      ++*(_DWORD *)v42;
      i += 495380;
    }
    if ( v39 + v37 <= 0 || v38 + v36 <= 0 )
      v31 = 0;
    else
      v31 = 100 * (v36 + v38) / (v37 + v39);
    v1 = (long double)v32;
    v2 = (long double)v34;
    v3 = v2;
    sub_80960DE(v3, v1);
    v25 = v2;
    v4 = (long double)v33;
    v5 = (long double)v35;
    v6 = v5;
    sub_80960BA(v6, v4);
    v23 = v5;
    v22 = *(_DWORD *)v41 + v40;
    if ( v37 )
      v24 = 100 * v36 / v37;
    else
      v24 = 0;
    if ( v39 )
      Com_sprintf(
        &s,
        0x400u,
        "              Totals:%6i|%5i|%5i| %3i%%|%6i|%5i|%5i| %3i%%|%6i|%5i|%5i| %3i%%|",
        *(_DWORD *)v41,
        v35,
        v34,
        100 * v38 / v39,
        v40,
        v33,
        v32,
        v24,
        v22,
        v23,
        v25,
        v31);
    else
      Com_sprintf(
        &s,
        0x400u,
        "              Totals:%6i|%5i|%5i| %3i%%|%6i|%5i|%5i| %3i%%|%6i|%5i|%5i| %3i%%|",
        *(_DWORD *)v41,
        v35,
        v34,
        0,
        v40,
        v33,
        v32,
        v24,
        v22,
        v23,
        v25,
        v31);
    if ( a1 )
      Com_Printf("%s\n", &s);
    if ( dword_842BB84 )
    {
      v30 = (_DWORD *)dword_842BB84;
      if ( *(_DWORD *)(dword_842BB84 + 732) + *(_DWORD *)(dword_842BB84 + 1484) <= 0 || v30[184] + v30[372] <= 0 )
        v31 = 0;
      else
        v31 = 100 * (v30[372] + v30[184]) / (v30[371] + v30[183]);
      v7 = (long double)(signed int)v30[375];
      v8 = (long double)(signed int)v30[187];
      v9 = v8;
      sub_80960DE(v9, v7);
      v10 = v8;
      v11 = (long double)(signed int)v30[374];
      v12 = (long double)(signed int)v30[186];
      v13 = v12;
      sub_80960BA(v13, v11);
      Com_sprintf(
        &s,
        0x400u,
        "  OutOfBand Messages: %5i|%5i|%5i| %3i%%| %5i|%5i|%5i| %3i%%| %5i|%5i|%5i| %3i%%|",
        v30[181],
        v30[186],
        v30[187],
        v30[185],
        v30[369],
        v30[374],
        v30[375],
        v30[373],
        v30[181] + v30[369],
        (double)v12,
        v10,
        v31);
      if ( a1 )
        Com_Printf("%s\n", &s);
    }
    else
    {
      Com_sprintf(
        &s,
        0x400u,
        "  OutOfBand Messages:     0|    0|    0|   - |     0|    0|    0|   - |     0|    0|    0|   - |");
      if ( a1 )
        Com_Printf("%s\n", &s);
    }
    *(_DWORD *)v42 = 0;
    for ( i = (char *)dword_841FB0C; ; i += 495380 )
    {
      result = *(_DWORD *)v42;
      if ( *(_DWORD *)v42 >= *(_DWORD *)(dword_848B1CC + 8) )
        break;
      if ( *(_DWORD *)i )
      {
        strncpy(&dest, i + 134216, 0x11u);
        v28 = 0;
        v30 = (_DWORD *)*((_DWORD *)i + 121212);
        if ( v30 )
        {
          if ( v30[183] + v30[371] <= 0 || v30[184] + v30[372] <= 0 )
            v31 = 0;
          else
            v31 = 100 * (v30[372] + v30[184]) / (v30[371] + v30[183]);
          v15 = (long double)(signed int)v30[375];
          v16 = (long double)(signed int)v30[187];
          v17 = v16;
          sub_80960DE(v17, v15);
          v18 = v16;
          v19 = (long double)(signed int)v30[374];
          v20 = (long double)(signed int)v30[186];
          v21 = v20;
          sub_80960BA(v21, v19);
          Com_sprintf(
            &s,
            0x400u,
            "#%2i-%16s: %5i|%5i|%5i| %3i%%| %5i|%5i|%5i| %3i%%| %5i|%5i|%5i| %3i%%|",
            *(_DWORD *)v42,
            &dest,
            v30[181],
            v30[186],
            v30[187],
            v30[185],
            v30[369],
            v30[374],
            v30[375],
            v30[373],
            v30[181] + v30[369],
            (double)v20,
            v18,
            v31);
          if ( a1 )
            Com_Printf("%s\n", &s);
        }
        else
        {
          Com_sprintf(
            &s,
            0x400u,
            "#%2i-%16s:     0|    0|    0|   0%%|     0|    0|    0|   0%%|     0|    0|    0|   0%%|",
            *(_DWORD *)v42,
            &dest);
          if ( a1 )
            Com_Printf("%s\n", &s);
        }
      }
      ++*(_DWORD *)v42;
    }
  }
  return result;
}
// 842BB84: using guessed type int dword_842BB84;
// 848B1CC: using guessed type int dword_848B1CC;

//----- (080960BA) --------------------------------------------------------
void __cdecl sub_80960BA(float a1, float a2)
{
  float v2; // ST00_4

  v2 = a1 - a2;
  sub_8096102(v2, a1, a2);
}

//----- (080960DE) --------------------------------------------------------
void __cdecl sub_80960DE(float a1, float a2)
{
  float v2; // ST00_4

  v2 = a2 - a1;
  sub_8096102(v2, a1, a2);
}

//----- (08096102) --------------------------------------------------------
long double __cdecl sub_8096102(float a1, float a2, float a3)
{
  float v4; // [esp+0h] [ebp-4h]

  if ( a1 < 0.0 )
    v4 = a3;
  else
    v4 = a2;
  return v4;
}

//----- (0809612C) --------------------------------------------------------
int *__cdecl sub_809612C(int a1, int a2, int a3, int a4, int a5, int *a6)
{
  signed int v7; // [esp+10h] [ebp-18h]
  signed int v8; // [esp+14h] [ebp-14h]
  int v9; // [esp+18h] [ebp-10h]
  int v10; // [esp+1Ch] [ebp-Ch]
  int *v11; // [esp+20h] [ebp-8h]
  int *v12; // [esp+24h] [ebp-4h]

  v11 = 0;
  v12 = 0;
  v9 = 0;
  v10 = 0;
  while ( v9 < a4 || v10 < a2 )
  {
    if ( v9 < a4 )
    {
      v11 = (int *)(dword_841FB20 + 240 * ((a5 + v9) % dword_841FB10));
      v7 = *v11;
    }
    else
    {
      v7 = 9999;
    }
    if ( v10 < a2 )
    {
      v12 = (int *)(dword_841FB20 + 240 * ((a3 + v10) % dword_841FB10));
      v8 = *v12;
    }
    else
    {
      v8 = 9999;
    }
    if ( v7 == v8 )
    {
      sub_806938C(a6, v12, v11, 0);
      ++v10;
      ++v9;
    }
    else if ( v7 >= v8 )
    {
      if ( v7 > v8 )
      {
        sub_806938C(a6, v12, 0, 1);
        ++v10;
      }
    }
    else
    {
      sub_806938C(a6, (int *)(372 * v7 + 138600604), v11, 1);
      ++v9;
    }
  }
  return sub_80677A2(a6, 1023, 10);
}
// 841FB10: using guessed type int dword_841FB10;
// 841FB20: using guessed type int dword_841FB20;

//----- (080962A0) --------------------------------------------------------
_DWORD *__cdecl sub_80962A0(int a1, int a2, int a3, int a4, int a5, int *a6)
{
  signed int v7; // [esp+10h] [ebp-18h]
  signed int v8; // [esp+14h] [ebp-14h]
  int v9; // [esp+18h] [ebp-10h]
  int v10; // [esp+1Ch] [ebp-Ch]
  int *v11; // [esp+20h] [ebp-8h]
  int *v12; // [esp+24h] [ebp-4h]

  v11 = 0;
  v12 = 0;
  v9 = 0;
  v10 = 0;
  while ( v9 < a4 || v10 < a2 )
  {
    if ( v9 < a4 )
    {
      v11 = (int *)(dword_841FB24 + 92 * ((a5 + v9) % dword_841FB14));
      v7 = *v11;
    }
    else
    {
      v7 = 9999;
    }
    if ( v10 < a2 )
    {
      v12 = (int *)(dword_841FB24 + 92 * ((a3 + v10) % dword_841FB14));
      v8 = *v12;
    }
    else
    {
      v8 = 9999;
    }
    if ( v7 == v8 )
    {
      sub_8069428(a6, v12, v11, 0);
      ++v10;
      ++v9;
    }
    else if ( v7 >= v8 )
    {
      if ( v7 > v8 )
      {
        sub_8069428(a6, v12, 0, 1);
        ++v10;
      }
    }
    else
    {
      sub_8069428(a6, 0, v11, 1);
      ++v9;
    }
  }
  return sub_8067868(a6);
}
// 841FB14: using guessed type int dword_841FB14;
// 841FB24: using guessed type int dword_841FB24;

//----- (080963EC) --------------------------------------------------------
int __cdecl sub_80963EC(char *a1, int *a2)
{
  int result; // eax
  int v3; // [esp+24h] [ebp-24h]
  int v4; // [esp+28h] [ebp-20h]
  char v5; // [esp+34h] [ebp-14h]
  int i; // [esp+38h] [ebp-10h]
  int v7; // [esp+3Ch] [ebp-Ch]
  int v8; // [esp+40h] [ebp-8h]
  char *v9; // [esp+44h] [ebp-4h]

  v9 = &a1[9924 * (*((_DWORD *)a1 + 113005) & 0x1F) + 134436];
  if ( *((_DWORD *)a1 + 33602) > 0 && *(_DWORD *)a1 == 4 )
  {
    if ( *((_DWORD *)a1 + 113005) - *((_DWORD *)a1 + 33602) <= 28 )
    {
      v8 = (int)&a1[9924 * (*((_DWORD *)a1 + 33602) & 0x1F) + 134436];
      v7 = *((_DWORD *)a1 + 113005) - *((_DWORD *)a1 + 33602);
      if ( *(_DWORD *)&a1[9924 * (*((_DWORD *)a1 + 33602) & 0x1F) + 144340] < dword_841FB18 - dword_841FB10 )
      {
        Com_DPrintf("%s: Delta request from out of date entities.\n", a1 + 134216);
        v8 = 0;
        LOBYTE(v7) = 0;
      }
    }
    else
    {
      Com_DPrintf("%s: Delta request from out of date packet.\n", a1 + 134216);
      v8 = 0;
      LOBYTE(v7) = 0;
    }
  }
  else
  {
    v8 = 0;
    LOBYTE(v7) = 0;
  }
  sub_8067B4C(a2, 6);
  sub_8067C2A(a2, dword_841FB04);
  sub_8067B4C(a2, v7);
  v5 = dword_841FB08;
  if ( *((_DWORD *)a1 + 33607) )
    v5 = dword_841FB08 | 1;
  if ( *(_DWORD *)a1 == 4 )
  {
    *((_DWORD *)a1 + 1) = 1;
  }
  else if ( *(_DWORD *)a1 != 1 )
  {
    *((_DWORD *)a1 + 1) = 0;
  }
  if ( !*((_DWORD *)a1 + 1) )
    v5 |= 2u;
  sub_8067B4C(a2, v5);
  if ( v8 )
  {
    sub_8069D40(a2, (char *)v8, v9);
    v4 = *(_DWORD *)(v8 + 9900);
    v3 = *(_DWORD *)(v8 + 9908);
    sub_809612C(
      -1653759219 * ((a1 - (_BYTE *)dword_841FB0C) >> 2),
      *(_DWORD *)(v8 + 9896),
      *(_DWORD *)(v8 + 9904),
      *((_DWORD *)v9 + 2474),
      *((_DWORD *)v9 + 2476),
      a2);
  }
  else
  {
    sub_8069D40(a2, 0, v9);
    v4 = 0;
    v3 = 0;
    sub_809612C(
      -1653759219 * ((a1 - (_BYTE *)dword_841FB0C) >> 2),
      0,
      0,
      *((_DWORD *)v9 + 2474),
      *((_DWORD *)v9 + 2476),
      a2);
  }
  sub_80962A0(
    -1653759219 * ((a1 - (_BYTE *)dword_841FB0C) >> 2),
    v4,
    v3,
    *((_DWORD *)v9 + 2475),
    *((_DWORD *)v9 + 2477),
    a2);
  for ( i = 0; ; ++i )
  {
    result = i;
    if ( i >= *(_DWORD *)(dword_848B1DC + 8) )
      break;
    sub_8067B4C(a2, 0);
  }
  return result;
}
// 841FB08: using guessed type int dword_841FB08;
// 841FB10: using guessed type int dword_841FB10;
// 841FB18: using guessed type int dword_841FB18;
// 848B1DC: using guessed type int dword_848B1DC;

//----- (080966D6) --------------------------------------------------------
_DWORD *__cdecl sub_80966D6(_DWORD *a1, _DWORD *a2)
{
  _DWORD *result; // eax
  int i; // [esp+14h] [ebp-4h]

  if ( a1[33284] + 1 < a1[33283] && *(_BYTE *)(dword_848B1FC + 8) )
    Com_Printf("Client %s has the following un-ack'd reliable commands:\n", a1 + 33554);
  for ( i = a1[33284] + 1; i <= a1[33283]; ++i )
  {
    sub_8067B4C(a2, 4);
    sub_8067C2A(a2, i);
    sub_8067CE4((int)a2, (char *)&a1[258 * (i & 0x7F) + 259]);
    if ( *(_BYTE *)(dword_848B1FC + 8) )
      Com_Printf("%i: %s\n", i - a1[33284] - 1, &a1[258 * (i & 0x7F) + 259]);
  }
  result = a1;
  a1[33285] = a1[33283];
  return result;
}
// 848B1FC: using guessed type int dword_848B1FC;

//----- (080967E4) --------------------------------------------------------
int __cdecl sub_80967E4(_DWORD *a1, _DWORD *a2, signed int a3)
{
  int result; // eax
  int i; // [esp+14h] [ebp-4h]
  int v5; // [esp+14h] [ebp-4h]

  for ( i = a1[33284] + 1;
        i <= a1[33283] && (signed int)(a2[3] + strlen((const char *)&a1[258 * (i & 0x7F) + 259]) + 6) < a3;
        ++i )
  {
    sub_8067B4C(a2, 4);
    sub_8067C2A(a2, i);
    sub_8067CE4((int)a2, (char *)&a1[258 * (i & 0x7F) + 259]);
  }
  v5 = i - 1;
  result = v5;
  if ( v5 > a1[33285] )
  {
    result = v5;
    a1[33285] = v5;
  }
  return result;
}

//----- (080968B8) --------------------------------------------------------
void __cdecl sub_80968B8(int a1)
{
  int i; // [esp+14h] [ebp-4h]

  Com_Printf(
    "-- Unacknowledged Server Commands for client %i:%s --\n",
    -1653759219 * ((a1 - (signed int)dword_841FB0C) >> 2),
    a1 + 134216);
  for ( i = *(_DWORD *)(a1 + 133136) + 1; i <= *(_DWORD *)(a1 + 133132); ++i )
    Com_Printf("cmd %5d: %8d: %s\n", i, *(_DWORD *)(a1 + 1032 * (i & 0x7F) + 2060), a1 + 1032 * (i & 0x7F) + 1036);
  Com_Printf("----------");
}
// 841FB08: using guessed type int dword_841FB08;

//----- (08096970) --------------------------------------------------------
_DWORD *__cdecl sub_8096970(int a1, _DWORD *a2)
{
  _DWORD *result; // eax

  result = a2;
  if ( *a2 != 1024 )
  {
    a2[*a2 + 1] = a1;
    result = a2;
    ++*result;
  }
  return result;
}

//----- (08096996) --------------------------------------------------------
_DWORD *__cdecl sub_8096996(int a1, _DWORD *a2)
{
  _DWORD *result; // eax

  result = a2;
  if ( *a2 != 1024 )
  {
    a2[*a2 + 1] = a1;
    result = a2;
    ++*result;
  }
  return result;
}

//----- (080969BC) --------------------------------------------------------
int __cdecl sub_80969BC(float *a1, int a2, _DWORD *a3)
{
  int v3; // eax
  int result; // eax
  float v5; // [esp+10h] [ebp-28h]
  char *v6; // [esp+1Ch] [ebp-1Ch]
  int v7; // [esp+24h] [ebp-14h]
  int v8; // [esp+28h] [ebp-10h]
  int v9; // [esp+2Ch] [ebp-Ch]
  int j; // [esp+30h] [ebp-8h]
  int i; // [esp+34h] [ebp-4h]

  v3 = sub_8058A2C(a1);
  result = sub_80524F4(v3);
  if ( result >= 0 )
  {
    v6 = sub_8058F82(result);
    v5 = sub_8106976();
    if ( v5 == 3.4028235e38 )
      v5 = 0.0;
    for ( i = 0; ; ++i )
    {
      result = i;
      if ( i >= dword_848B0A4 )
        return result;
      v9 = sub_808FDE4(i);
      if ( *(_BYTE *)(v9 + 240) && i != a2 )
      {
        if ( *(_DWORD *)(v9 + 256) )
        {
          if ( *(_DWORD *)(v9 + 256) < 0 || *(_DWORD *)(v9 + 256) - dword_841FB04 >= 0 )
          {
            sub_8096970(i, a3);
            continue;
          }
          *(_DWORD *)(v9 + 256) = 0;
        }
        else if ( *(_BYTE *)(v9 + 242) & 1 || (*(_DWORD *)(v9 + 4 * (a2 >> 5) + 244) >> (a2 & 0x1F)) & 1 )
        {
          continue;
        }
        if ( *(_BYTE *)(v9 + 242) & 0x18 )
        {
          sub_8096970(i, a3);
        }
        else
        {
          v8 = sub_808FE20((_DWORD *)v9);
          if ( *(_DWORD *)(v8 + 280) )
          {
            v7 = 0;
            for ( j = 0; j < *(_DWORD *)(v8 + 280); ++j )
            {
              v7 = *(_DWORD *)(v8 + 4 * j + 284);
              if ( ((signed int)(unsigned __int8)v6[v7 >> 3] >> (*(_BYTE *)(v8 + 4 * j + 284) & 7)) & 1 )
                break;
            }
            if ( j != *(_DWORD *)(v8 + 280) )
              goto LABEL_35;
            if ( *(_DWORD *)(v8 + 348) )
            {
              while ( v7 <= *(_DWORD *)(v8 + 348) && !(((signed int)(unsigned __int8)v6[v7 >> 3] >> (v7 & 7)) & 1) )
                ++v7;
              if ( v7 != *(_DWORD *)(v8 + 348) )
              {
LABEL_35:
                if ( v5 == 0.0 || !sub_80A831C(v9 + 288, v9 + 300, (int)a1, v5) )
                  sub_8096970(i, a3);
              }
            }
          }
        }
      }
    }
  }
  return result;
}
// 848B0A4: using guessed type int dword_848B0A4;

//----- (08096C56) --------------------------------------------------------
int __cdecl sub_8096C56(int a1, int a2, float *a3, int a4, _DWORD *a5)
{
  int v5; // eax
  int result; // eax
  float v7; // [esp+30h] [ebp-238h]
  int v8; // [esp+38h] [ebp-230h]
  char v9; // [esp+3Ch] [ebp-22Ch]
  int v10[130]; // [esp+40h] [ebp-228h]
  int v11; // [esp+248h] [ebp-20h]
  char *v12; // [esp+24Ch] [ebp-1Ch]
  int v13; // [esp+250h] [ebp-18h]
  _DWORD *v14; // [esp+254h] [ebp-14h]
  int j; // [esp+258h] [ebp-10h]
  int i; // [esp+25Ch] [ebp-Ch]

  v5 = sub_8058A2C(a3);
  result = sub_80524F4(v5);
  v13 = result;
  if ( result >= 0 )
  {
    v12 = sub_8058F82(v13);
    v7 = sub_8106976();
    if ( v7 == 3.4028235e38 )
      v7 = 0.0;
    for ( i = 0; ; ++i )
    {
      result = i;
      if ( i >= a1 )
        break;
      v14 = (char *)dword_841FB48 + 276 * ((i + a2) % 0x4000);
      if ( !((v14[(a4 >> 5) + 61] >> (a4 & 0x1F)) & 1) && *v14 != a4 )
      {
        if ( v14[60] & 0x18 )
        {
          sub_8096996(i, a5);
        }
        else
        {
          v11 = sub_8058B66(v14 + 63, v14 + 66, (int)v10, 128, &v9);
          if ( v11 )
          {
            for ( j = 0; j < v11; ++j )
            {
              v8 = sub_80524F4(v10[j]);
              if ( v8 != -1 )
              {
                if ( ((signed int)(unsigned __int8)v12[v8 >> 3] >> (v8 & 7)) & 1 )
                  break;
              }
            }
            if ( j != v11 && (v7 == 0.0 || !sub_80A831C((int)(v14 + 63), (int)(v14 + 66), (int)a3, v7)) )
              sub_8096996(i, a5);
          }
        }
      }
    }
  }
  return result;
}
// 8096C56: using guessed type int var_228[130];

//----- (08096E9E) --------------------------------------------------------
_DWORD *__cdecl sub_8096E9E(int a1)
{
  _DWORD *v1; // ebx
  _DWORD *v2; // ST6C_4
  signed int *v3; // ST50_4
  signed int *v4; // ST3C_4
  _DWORD *v5; // ST28_4
  signed int *v6; // ST1C_4
  _DWORD *v7; // ebx
  char *v10; // [esp+8Ch] [ebp-7Ch]
  char v11; // [esp+90h] [ebp-78h]
  char s; // [esp+A0h] [ebp-68h]
  void *dest; // [esp+A4h] [ebp-64h]
  size_t n; // [esp+ACh] [ebp-5Ch]
  int v15; // [esp+B0h] [ebp-58h]
  int v16; // [esp+C8h] [ebp-40h]
  int v17; // [esp+CCh] [ebp-3Ch]
  int v18; // [esp+D0h] [ebp-38h]
  int v19; // [esp+D4h] [ebp-34h]
  size_t v20; // [esp+D8h] [ebp-30h]
  int v21; // [esp+DCh] [ebp-2Ch]
  char *v22; // [esp+E0h] [ebp-28h]
  int v23; // [esp+E4h] [ebp-24h]
  int i; // [esp+E8h] [ebp-20h]
  char *v25; // [esp+ECh] [ebp-1Ch]
  char *v26; // [esp+F0h] [ebp-18h]
  void *v27; // [esp+F4h] [ebp-14h]
  int v28; // [esp+F8h] [ebp-10h]
  _DWORD *v29; // [esp+FCh] [ebp-Ch]

  sub_80AA1F6((int *)&v11, 0x20000);
  v10 = sub_80AA240((int *)&v11);
  v22 = (char *)dword_841FB30 + 8 * (a1 % 1200);
  if ( *((_DWORD *)dword_841FB30 + 2 * (a1 % 1200)) >= dword_841FB38 - 0x2000000 )
  {
    v19 = dword_841FB44 - 512;
    if ( dword_841FB44 - 512 < 0 )
      v19 = 0;
    for ( i = dword_841FB44 - 1; i >= v19; --i )
    {
      v29 = (char *)dword_841FB50 + 28 * (i % 512);
      if ( *((_DWORD *)dword_841FB50 + 7 * (i % 512)) == a1 )
      {
        if ( v29[3] >= dword_841FB3C - 0x4000 && v29[5] >= dword_841FB40 - 4096 )
        {
          v1 = v29;
          sub_80AA22A((int *)&v11);
          return v1;
        }
        break;
      }
    }
    sub_8067718(&s, (int)v10, 0x20000);
    n = *((_DWORD *)v22 + 1);
    v21 = *(_DWORD *)v22 % 0x2000000;
    v20 = 0x2000000 - v21;
    if ( (signed int)n > 0x2000000 - v21 )
    {
      memcpy(dest, (char *)dword_841FB34 + v21, v20);
      memcpy((char *)dest + v20, dword_841FB34, n - v20);
    }
    else
    {
      memcpy(dest, (char *)dword_841FB34 + v21, n);
    }
    if ( sub_8067A0E(&s) )
    {
      v29 = (char *)dword_841FB50 + 28 * (dword_841FB44 % 512);
      *v29 = a1;
      v29[2] = 0;
      v29[3] = dword_841FB3C;
      v29[4] = 0;
      v29[5] = dword_841FB40;
      v29[6] = 0;
      v5 = v29;
      v5[1] = sub_8067F90(&s);
      while ( sub_8067A0E(&s) )
      {
        v23 = sub_8067960(&s, 6);
        if ( v15 > (signed int)n )
          Com_Error(1, &byte_8145200);
        v26 = (char *)dword_841FB4C + 9992 * (dword_841FB40 % 4096);
        sub_8069A54((int)&s, 0, (char *)dword_841FB4C + 9992 * (dword_841FB40 % 4096) + 4, v23);
        v6 = (signed int *)v26;
        *v6 = sub_8067A0E(&s);
        if ( *(_DWORD *)v26 )
          sub_806A608(&s, 0, v26 + 96);
        if ( ++dword_841FB40 > 2147483645 )
          Com_Error(0, &byte_8145240);
        ++v29[4];
      }
      while ( 1 )
      {
        v23 = sub_8067960(&s, 10);
        if ( v23 == 1023 )
          break;
        if ( v15 > (signed int)n )
          Com_Error(1, &byte_8145200);
        v27 = (char *)dword_841FB48 + 276 * (dword_841FB3C % 0x4000);
        sub_8069A0E(
          (int)&s,
          (void *)(372 * v23 + 138600604),
          (char *)dword_841FB48 + 276 * (dword_841FB3C % 0x4000),
          v23);
        if ( ++dword_841FB3C > 2147483645 )
          Com_Error(0, &byte_8145280);
        ++v29[2];
      }
      if ( ++dword_841FB44 > 2147483645 )
        Com_Error(0, &byte_81452C0);
    }
    else
    {
      v18 = sub_8067F90(&s);
      if ( v18 < dword_841FB2C - 1200 )
      {
        sub_80AA22A((int *)&v11);
        return 0;
      }
      v22 = (char *)dword_841FB30 + 8 * (v18 % 1200);
      if ( *((_DWORD *)dword_841FB30 + 2 * (v18 % 1200)) < dword_841FB38 - 0x2000000 )
      {
        sub_80AA22A((int *)&v11);
        return 0;
      }
      v28 = sub_8096E9E(v18);
      if ( !v28 )
      {
        sub_80AA22A((int *)&v11);
        return 0;
      }
      v29 = (char *)dword_841FB50 + 28 * (dword_841FB44 % 512);
      *v29 = a1;
      v29[2] = 0;
      v29[3] = dword_841FB3C;
      v29[4] = 0;
      v29[5] = dword_841FB40;
      v29[6] = 1;
      v2 = v29;
      v2[1] = sub_8067F90(&s);
      v17 = 0;
      v25 = 0;
      if ( *(_DWORD *)(v28 + 16) > 0 )
      {
        v25 = (char *)dword_841FB4C + 9992 * ((v17 + *(_DWORD *)(v28 + 20)) % 4096);
        v16 = *((_DWORD *)v25 + 1);
      }
      else
      {
        v16 = 99999;
      }
      while ( sub_8067A0E(&s) )
      {
        v23 = sub_8067960(&s, 6);
        if ( v15 > (signed int)n )
          Com_Error(1, &byte_8145200);
        while ( v16 < v23 )
        {
          if ( ++v17 < *(_DWORD *)(v28 + 16) )
          {
            v25 = (char *)dword_841FB4C + 9992 * ((v17 + *(_DWORD *)(v28 + 20)) % 4096);
            v16 = *((_DWORD *)v25 + 1);
          }
          else
          {
            v16 = 99999;
          }
        }
        if ( v16 == v23 )
        {
          v26 = (char *)dword_841FB4C + 9992 * (dword_841FB40 % 4096);
          sub_8069A54((int)&s, v25 + 4, (char *)dword_841FB4C + 9992 * (dword_841FB40 % 4096) + 4, v23);
          v3 = (signed int *)v26;
          *v3 = sub_8067A0E(&s);
          if ( *(_DWORD *)v26 )
            sub_806A608(&s, v25 + 96, v26 + 96);
          if ( ++dword_841FB40 > 2147483645 )
            Com_Error(0, &byte_8145240);
          ++v29[4];
          if ( ++v17 < *(_DWORD *)(v28 + 16) )
          {
            v25 = (char *)dword_841FB4C + 9992 * ((v17 + *(_DWORD *)(v28 + 20)) % 4096);
            v16 = *((_DWORD *)v25 + 1);
          }
          else
          {
            v16 = 99999;
          }
        }
        else
        {
          v26 = (char *)dword_841FB4C + 9992 * (dword_841FB40 % 4096);
          sub_8069A54((int)&s, 0, (char *)dword_841FB4C + 9992 * (dword_841FB40 % 4096) + 4, v23);
          v4 = (signed int *)v26;
          *v4 = sub_8067A0E(&s);
          if ( *(_DWORD *)v26 )
            sub_806A608(&s, 0, v26 + 96);
          if ( ++dword_841FB40 > 2147483645 )
            Com_Error(0, &byte_8145240);
          ++v29[4];
        }
      }
      while ( 1 )
      {
        v23 = sub_8067960(&s, 10);
        if ( v23 == 1023 )
          break;
        if ( v15 > (signed int)n )
          Com_Error(1, &byte_8145200);
        v27 = (char *)dword_841FB48 + 276 * (dword_841FB3C % 0x4000);
        sub_8069A0E(
          (int)&s,
          (void *)(372 * v23 + 138600604),
          (char *)dword_841FB48 + 276 * (dword_841FB3C % 0x4000),
          v23);
        if ( ++dword_841FB3C > 2147483645 )
          Com_Error(0, &byte_8145280);
        ++v29[2];
      }
      if ( ++dword_841FB44 > 2147483645 )
        Com_Error(0, &byte_81452C0);
    }
    v7 = v29;
    sub_80AA22A((int *)&v11);
    return v7;
  }
  sub_80AA22A((int *)&v11);
  return 0;
}
// 841FB2C: using guessed type int dword_841FB2C;
// 841FB38: using guessed type int dword_841FB38;
// 841FB3C: using guessed type int dword_841FB3C;
// 841FB40: using guessed type int dword_841FB40;
// 841FB44: using guessed type int dword_841FB44;

//----- (08097A28) --------------------------------------------------------
_DWORD *__cdecl sub_8097A28(int *a1)
{
  int v1; // edx
  _DWORD *v4; // [esp+18h] [ebp-10h]
  int v5; // [esp+1Ch] [ebp-Ch]

  if ( !dword_841FB28 )
    return 0;
  if ( *a1 <= 0 )
    return 0;
  v1 = *(_DWORD *)(dword_848B1B4 + 8) * *a1 / 1000;
  v5 = dword_841FB2C - v1;
  if ( dword_841FB2C - v1 < dword_841FB2C - 1200 )
  {
    v5 = dword_841FB2C - 1200;
    *a1 = 1000 * (dword_841FB2C - (dword_841FB2C - 1200)) / *(_DWORD *)(dword_848B1B4 + 8);
  }
  if ( v5 < 0 )
  {
    v5 = 0;
    *a1 = 1000 * dword_841FB2C / *(_DWORD *)(dword_848B1B4 + 8);
  }
  while ( v5 < dword_841FB2C )
  {
    v4 = sub_8096E9E(v5);
    if ( v4 )
      return v4;
    ++v5;
  }
  *a1 = 0;
  return 0;
}
// 841FB28: using guessed type int dword_841FB28;
// 841FB2C: using guessed type int dword_841FB2C;
// 848B1B4: using guessed type int dword_848B1B4;

//----- (08097B54) --------------------------------------------------------
signed int __cdecl sub_8097B54(int a1, _DWORD *a2, void *a3)
{
  if ( *((_DWORD *)dword_841FB0C + 123845 * a1) != 4 )
    return 0;
  if ( !sub_80F4696(a1, a2) )
    return 0;
  qmemcpy(a3, (const void *)sub_81069E2(a1), 0x5Cu);
  return 1;
}

//----- (08097BD0) --------------------------------------------------------
signed int __cdecl sub_8097BD0(int a1, int a2, int a3)
{
  long double v3; // fst7
  int v6; // [esp+30h] [ebp-2768h]
  int v7; // [esp+34h] [ebp-2764h]
  int v8; // [esp+38h] [ebp-2760h]
  int i; // [esp+3Ch] [ebp-275Ch]
  char v10; // [esp+40h] [ebp-2758h]
  char v11; // [esp+A0h] [ebp-26F8h]
  int v12; // [esp+B4h] [ebp-26E4h]
  char v13; // [esp+275Eh] [ebp-3Ah]
  char v14; // [esp+275Fh] [ebp-39h]
  float v15[4]; // [esp+2760h] [ebp-38h]
  int dest[4]; // [esp+2770h] [ebp-28h]
  int v17; // [esp+2780h] [ebp-18h]
  int v18; // [esp+2784h] [ebp-14h]
  float v19; // [esp+2788h] [ebp-10h]
  int j; // [esp+278Ch] [ebp-Ch]

  v8 = 1000 / *(_DWORD *)(dword_848B1B4 + 8);
  v7 = v8 * (dword_841FB04 / v8);
  v18 = v8 * (dword_815D6E0 + (v8 * (dword_841FB04 / v8) - a2) / v8);
  v17 = v8 * (dword_815D6E4 + (v7 - a2) / v8);
  v14 = 0;
  v13 = 0;
  v6 = v8 * (dword_815D6E0 + (v8 * (dword_841FB04 / v8) - a2) / v8);
  for ( i = 0; i <= 9; ++i )
  {
    if ( sub_8097EDA(a1, &v6, &v11, &v10) )
    {
      v14 = 1;
      v18 = v6;
      memcpy(dest, &v12, 0xCu);
      break;
    }
    v6 += v8;
  }
  v6 = v17;
  for ( i = 0; i <= 9; ++i )
  {
    if ( sub_8097EDA(a1, &v6, &v11, &v10) )
    {
      v13 = 1;
      v17 = v6;
      memcpy(v15, &v12, 0xCu);
      break;
    }
    v6 -= v8;
  }
  if ( v14 && v13 )
  {
    v19 = (long double)(a2 % v8) / (long double)(v18 - v17);
  }
  else if ( v14 )
  {
    v19 = 0.0;
    sub_8099D8A(v15);
  }
  else
  {
    if ( !v13 )
      return 0;
    v19 = 1.0;
    sub_8099D8A(dest);
  }
  for ( j = 0; j <= 2; ++j )
  {
    v3 = sub_8099D74(*(float *)&dest[j], v15[j], v19);
    *(float *)(a3 + 4 * j) = v3;
  }
  return 1;
}
// 815D6E0: using guessed type int dword_815D6E0;
// 815D6E4: using guessed type int dword_815D6E4;
// 841FB00: using guessed type int dword_841FB00;
// 848B1B4: using guessed type int dword_848B1B4;
// 8097BD0: using guessed type int dest[4];
// 8097BD0: using guessed type float var_38[4];

//----- (08097EDA) --------------------------------------------------------
signed int __cdecl sub_8097EDA(int a1, int *a2, _DWORD *a3, void *a4)
{
  unsigned int v5; // [esp+14h] [ebp-34h]
  _DWORD *v6; // [esp+18h] [ebp-30h]
  void *v7; // [esp+1Ch] [ebp-2Ch]
  signed int v8; // [esp+28h] [ebp-20h]
  signed int v9; // [esp+2Ch] [ebp-1Ch]
  _DWORD *v10; // [esp+30h] [ebp-18h]
  int v11; // [esp+34h] [ebp-14h]
  int i; // [esp+38h] [ebp-10h]
  unsigned int j; // [esp+38h] [ebp-10h]
  _DWORD *v14; // [esp+3Ch] [ebp-Ch]

  v14 = sub_8097A28(a2);
  if ( v14 )
  {
    v11 = dword_841FB04 - v14[1];
    for ( i = 0; ; ++i )
    {
      if ( i >= v14[4] )
        return 0;
      v10 = (char *)dword_841FB4C + 9992 * ((i + v14[5]) % 4096);
      if ( v10[1] == a1 )
        break;
    }
    if ( !*v10 )
      return 0;
    v7 = a3;
    v6 = v10 + 24;
    v5 = 9896;
    if ( (unsigned __int8)a3 & 4 )
    {
      *a3 = *v6;
      v7 = a3 + 1;
      v6 = v10 + 25;
      v5 = 9892;
    }
    qmemcpy(v7, v6, 4 * (v5 >> 2));
    qmemcpy(a4, v10 + 1, 0x5Cu);
    if ( *a3 )
      *a3 += v11;
    if ( a3[4] )
      a3[4] += v11;
    if ( a3[17] )
      a3[17] += v11;
    if ( a3[28] )
      a3[28] += v11;
    if ( a3[63] )
      a3[63] += v11;
    if ( a3[375] )
      a3[375] += v11;
    for ( j = 0; j <= 0x1E; ++j )
    {
      if ( a3[32 * j + 1508] )
        a3[32 * j + 1508] += v11;
      if ( a3[32 * j + 1492] )
      {
        a3[32 * j + 1492] += v11;
        if ( a3[32 * j + 1492] > dword_841FB04 )
          a3[32 * j + 1492] = dword_841FB04;
      }
      if ( a3[32 * j + 1500] )
        a3[32 * j + 1500] += v11;
      if ( a3[32 * j + 1506] )
        a3[32 * j + 1506] += v11;
    }
    a3[489] += v11;
    v9 = 1;
  }
  else
  {
    if ( *a2 > 0 )
      v8 = 0;
    else
      v8 = sub_8097B54(a1, a3, a4);
    v9 = v8;
  }
  return v9;
}

//----- (0809822C) --------------------------------------------------------
int __cdecl sub_809822C(char *a1)
{
  int result; // eax
  unsigned int v2; // [esp+30h] [ebp-1088h]
  _DWORD *v3; // [esp+34h] [ebp-1084h]
  int v4; // [esp+38h] [ebp-1080h]
  int v5; // [esp+3Ch] [ebp-107Ch]
  int v6; // [esp+40h] [ebp-1078h]
  char *v7; // [esp+44h] [ebp-1074h]
  int v8; // [esp+48h] [ebp-1070h]
  char *v9; // [esp+4Ch] [ebp-106Ch]
  _DWORD *v10; // [esp+50h] [ebp-1068h]
  float *v11; // [esp+54h] [ebp-1064h]
  int v12; // [esp+58h] [ebp-1060h]
  int v13; // [esp+5Ch] [ebp-105Ch]
  _DWORD *v14; // [esp+60h] [ebp-1058h]
  _DWORD *v15; // [esp+64h] [ebp-1054h]
  const void *v16; // [esp+68h] [ebp-1050h]
  int i; // [esp+6Ch] [ebp-104Ch]
  char v18[4]; // [esp+70h] [ebp-1048h]
  int v19[1030]; // [esp+74h] [ebp-1044h]
  char *v20; // [esp+108Ch] [ebp-2Ch]
  float v21[2]; // [esp+1090h] [ebp-28h]
  float v22; // [esp+1098h] [ebp-20h]
  _DWORD *j; // [esp+10C0h] [ebp+8h]

  v20 = &a1[9924 * (*((_DWORD *)a1 + 113005) & 0x1F) + 134436];
  *((_DWORD *)v20 + 2474) = 0;
  *((_DWORD *)v20 + 2475) = 0;
  result = *((_DWORD *)a1 + 33553);
  v13 = *((_DWORD *)a1 + 33553);
  if ( v13 )
  {
    result = (int)a1;
    if ( *(_DWORD *)a1 != 1 )
    {
      *((_DWORD *)v20 + 2476) = dword_841FB18;
      result = dword_841FB1C;
      *((_DWORD *)v20 + 2477) = dword_841FB1C;
      if ( dword_842BC80 == 2 )
      {
        *(_DWORD *)v18 = 0;
        v12 = -1653759219 * ((a1 - (_BYTE *)dword_841FB0C) >> 2);
        v6 = sub_81069A6(-1653759219 * ((a1 - (_BYTE *)dword_841FB0C) >> 2));
        v10 = sub_8097A28(&v6);
        sub_81069C2(v12, v6);
        if ( v10 )
          v5 = dword_841FB04 - v10[1];
        else
          v5 = 0;
        v8 = v5;
        v11 = (float *)v20;
        v4 = (int)v20;
        v3 = (_DWORD *)sub_808FE02(v12);
        v2 = 9896;
        if ( v4 & 4 )
        {
          *(_DWORD *)v4 = *v3;
          v4 += 4;
          ++v3;
          v2 = 9892;
        }
        qmemcpy((void *)v4, v3, 4 * (v2 >> 2));
        v12 = *((_DWORD *)v11 + 51);
        if ( v12 < 0 || v12 > 1023 )
          Com_Error(1, &byte_8145300);
        sub_8099DB4((_DWORD *)v11 + 5, v21);
        v22 = v22 + v11[62];
        sub_80B66C0((int)v21, *((_DWORD *)v11 + 59), v11[19], 16.0, 20.0);
        if ( v10 )
        {
          sub_8096C56(v10[2], v10[3], v21, v12, v18);
          for ( i = 0; i < *(_DWORD *)v18; ++i )
          {
            v9 = (char *)dword_841FB48 + 276 * ((v19[i] + v10[3]) % 0x4000);
            v15 = (_DWORD *)(dword_841FB20 + 240 * (dword_841FB18 % dword_841FB10));
            qmemcpy((void *)(dword_841FB20 + 240 * (dword_841FB18 % dword_841FB10)), v9, 0xF0u);
            if ( v15[4] )
              v15[4] += v8;
            if ( v15[13] )
              v15[13] += v8;
            if ( v15[21] )
              v15[21] += v8;
            if ( v15[22] )
              v15[22] += v8;
            if ( ++dword_841FB18 > 2147483645 )
              Com_Error(0, &byte_8145340);
            ++*((_DWORD *)v20 + 2474);
          }
          for ( i = 0; ; ++i )
          {
            result = i;
            if ( i >= v10[4] )
              break;
            v7 = (char *)dword_841FB4C + 9992 * ((i + v10[5]) % 4096);
            v14 = (_DWORD *)(dword_841FB24 + 92 * (dword_841FB1C % dword_841FB14));
            qmemcpy((void *)(dword_841FB24 + 92 * (dword_841FB1C++ % dword_841FB14)), v7 + 4, 0x5Cu);
            if ( dword_841FB1C > 2147483645 )
              Com_Error(0, &byte_8145380);
            ++*((_DWORD *)v20 + 2475);
          }
        }
        else
        {
          sub_80969BC(v21, v12, v18);
          for ( i = 0; i < *(_DWORD *)v18; ++i )
          {
            v16 = (const void *)sub_808FDE4(v19[i]);
            v15 = (_DWORD *)(dword_841FB20 + 240 * (dword_841FB18 % dword_841FB10));
            qmemcpy((void *)(dword_841FB20 + 240 * (dword_841FB18++ % dword_841FB10)), v16, 0xF0u);
            if ( dword_841FB18 > 2147483645 )
              Com_Error(0, &byte_8145340);
            ++*((_DWORD *)v20 + 2474);
          }
          i = 0;
          for ( j = dword_841FB0C; ; j += 123845 )
          {
            result = i;
            if ( i >= *(_DWORD *)(dword_848B1CC + 8) )
              break;
            if ( *j > 1 )
            {
              v14 = (_DWORD *)(dword_841FB24 + 92 * (dword_841FB1C % dword_841FB14));
              qmemcpy(v14, (const void *)sub_81069E2(i), 0x5Cu);
              if ( *v14 == i )
              {
                if ( ++dword_841FB1C > 2147483645 )
                  Com_Error(0, &byte_8145380);
                ++*((_DWORD *)v20 + 2475);
              }
            }
            ++i;
          }
        }
      }
    }
  }
  return result;
}
// 841FB08: using guessed type int dword_841FB08;
// 841FB10: using guessed type int dword_841FB10;
// 841FB14: using guessed type int dword_841FB14;
// 841FB18: using guessed type int dword_841FB18;
// 841FB1C: using guessed type int dword_841FB1C;
// 841FB20: using guessed type int dword_841FB20;
// 841FB24: using guessed type int dword_841FB24;
// 842BC80: using guessed type int dword_842BC80;
// 848B1CC: using guessed type int dword_848B1CC;
// 809822C: using guessed type int var_1044[1030];

//----- (080988F4) --------------------------------------------------------
int __cdecl sub_80988F4(int a1, signed int a2)
{
  int v3; // [esp+20h] [ebp-8h]
  int v4; // [esp+24h] [ebp-4h]

  if ( a2 > 1500 )
    a2 = 1500;
  v4 = *(_DWORD *)(a1 + 452008);
  if ( *(_DWORD *)(dword_848B1E8 + 8) )
  {
    if ( *(_DWORD *)(dword_848B1E8 + 8) <= 999 )
      Dvar_SetInt(dword_848B1E8, (char *)0x3E8);
    if ( *(_DWORD *)(dword_848B1E8 + 8) < v4 )
      v4 = *(_DWORD *)(dword_848B1E8 + 8);
  }
  v3 = (1000 * a2 + 48000) / v4;
  if ( *(_BYTE *)(dword_848B1F8 + 8) )
    Com_Printf(
      "It would take %ims to send %i bytes to client %s (rate %i)\n",
      v3,
      a2,
      a1 + 134216,
      *(_DWORD *)(a1 + 452008));
  return v3;
}
// 848B1E8: using guessed type int dword_848B1E8;
// 848B1F8: using guessed type int dword_848B1F8;

//----- (080989C6) --------------------------------------------------------
int __usercall sub_80989C6@<eax>(long double a1@<st0>, int a2, int a3)
{
  int v3; // ST08_4
  int v4; // ST0C_4
  int v5; // ST10_4
  int result; // eax
  char *dest; // [esp+2Ch] [ebp-2Ch]
  char v8; // [esp+30h] [ebp-28h]
  size_t n; // [esp+48h] [ebp-10h]
  int v10; // [esp+4Ch] [ebp-Ch]

  sub_80AA1F6((int *)&v8, 0x4000);
  dest = sub_80AA240((int *)&v8);
  memcpy(dest, *(const void **)(a2 + 4), 4u);
  n = sub_8067A8E((unsigned __int8 *)(*(_DWORD *)(a2 + 4) + 4), (int)(dest + 4), *(_DWORD *)(a2 + 12) - 4) + 4;
  if ( *(_DWORD *)(a3 + 8) )
    sub_808DC8C(a1, (char *)a3, *(char **)(a3 + 8));
  *(_DWORD *)(a3 + 9924 * (*(_DWORD *)(a3 + 452020) & 0x1F) + 144356) = n;
  *(_DWORD *)(a3 + 9924 * (*(_DWORD *)(a3 + 452020) & 0x1F) + 144348) = dword_841FB04;
  *(_DWORD *)(a3 + 9924 * (*(_DWORD *)(a3 + 452020) & 0x1F) + 144352) = -1;
  sub_80955A2(a3, dest, n);
  if ( *(_DWORD *)(a3 + 452036) == 2
    || (v3 = *(_DWORD *)(a3 + 452044),
        v4 = *(_DWORD *)(a3 + 452048),
        v5 = *(_DWORD *)(a3 + 452052),
        Sys_IsLANAddress(*(_DWORD *)(a3 + 452036), *(_DWORD *)(a3 + 452040))) )
  {
    *(_DWORD *)(a3 + 134424) = dword_841FB04 - 1;
    result = sub_80AA22A((int *)&v8);
  }
  else
  {
    v10 = sub_80988F4(a3, n);
    if ( v10 >= *(_DWORD *)(a3 + 452012) )
    {
      *(_DWORD *)(a3 + 134428) = 1;
    }
    else
    {
      v10 = *(_DWORD *)(a3 + 452012);
      *(_DWORD *)(a3 + 134428) = 0;
    }
    *(_DWORD *)(a3 + 134424) = dword_841FB04 + v10;
    if ( *(_DWORD *)a3 != 4 && !*(_BYTE *)(a3 + 134248) && *(_DWORD *)(a3 + 134424) < dword_841FB04 + 1000 )
      *(_DWORD *)(a3 + 134424) = dword_841FB04 + 1000;
    dword_848B10C += n;
    result = sub_80AA22A((int *)&v8);
  }
  return result;
}
// 848B10C: using guessed type int dword_848B10C;

//----- (08098C0E) --------------------------------------------------------
int __usercall sub_8098C0E@<eax>(long double a1@<st0>, int a2)
{
  char *v3; // [esp+2Ch] [ebp-3Ch]
  char v4; // [esp+30h] [ebp-38h]
  int s; // [esp+40h] [ebp-28h]

  sub_80AA1F6((int *)&v4, 0x20000);
  v3 = sub_80AA240((int *)&v4);
  if ( *(_DWORD *)a2 == 4 || *(_DWORD *)a2 == 1 )
    sub_809822C((char *)a2);
  sub_8067718(&s, (int)v3, 0x20000);
  sub_8067C2A(&s, *(_DWORD *)(a2 + 133184));
  if ( *(_DWORD *)a2 == 4 || *(_DWORD *)a2 == 1 )
  {
    sub_80966D6((_DWORD *)a2, &s);
    sub_80963EC((char *)a2, &s);
  }
  if ( *(_DWORD *)a2 != 1 )
    sub_808E544(a2, &s);
  sub_8067B4C(&s, 7);
  if ( s )
  {
    Com_Printf("WARNING: msg overflowed for %s, trying to recover\n", a2 + 134216);
    if ( *(_DWORD *)a2 == 4 || *(_DWORD *)a2 == 1 )
    {
      sub_80968B8(a2);
      sub_8067718(&s, (int)v3, 0x20000);
      sub_8067C2A(&s, *(_DWORD *)(a2 + 133184));
      sub_80967E4((_DWORD *)a2, &s, 0x20000);
      sub_8067B4C(&s, 7);
    }
    if ( s )
    {
      Com_Printf("WARNING: client disconnected for msg overflow: %s\n", a2 + 134216);
      sub_806C40C(
        1,
        *(_DWORD *)(a2 + 452036),
        *(_DWORD *)(a2 + 452040),
        *(_DWORD *)(a2 + 452044),
        *(_DWORD *)(a2 + 452048),
        *(_DWORD *)(a2 + 452052),
        "disconnect");
      sub_808DC8C(a1, (char *)a2, "EXE_SERVERMESSAGEOVERFLOW");
    }
  }
  sub_80989C6(a1, (int)&s, a2);
  return sub_80AA22A((int *)&v4);
}

//----- (08098E3A) --------------------------------------------------------
int sub_8098E3A()
{
  int result; // eax
  int *v1; // eax
  int *v2; // eax
  signed int *v3; // ST24_4
  char *v4; // [esp+4Ch] [ebp-287Ch]
  char v5; // [esp+50h] [ebp-2878h]
  int s; // [esp+60h] [ebp-2868h]
  void *src; // [esp+64h] [ebp-2864h]
  size_t n; // [esp+6Ch] [ebp-285Ch]
  int v9; // [esp+88h] [ebp-2840h]
  int v10; // [esp+8Ch] [ebp-283Ch]
  int v11; // [esp+90h] [ebp-2838h]
  int v12; // [esp+94h] [ebp-2834h]
  int v13; // [esp+98h] [ebp-2830h]
  char v14[4]; // [esp+9Ch] [ebp-282Ch]
  char *v15; // [esp+A0h] [ebp-2828h]
  int v16; // [esp+A4h] [ebp-2824h]
  int v17; // [esp+A8h] [ebp-2820h]
  int *v18; // [esp+ACh] [ebp-281Ch]
  char v19; // [esp+B0h] [ebp-2818h]
  size_t v20; // [esp+2768h] [ebp-160h]
  int v21; // [esp+276Ch] [ebp-15Ch]
  char *v22; // [esp+2770h] [ebp-158h]
  _DWORD *v23; // [esp+2774h] [ebp-154h]
  int i; // [esp+2778h] [ebp-150h]
  int v25; // [esp+277Ch] [ebp-14Ch]
  char v26; // [esp+2780h] [ebp-148h]
  int v27; // [esp+2870h] [ebp-58h]
  int v28; // [esp+2874h] [ebp-54h]
  int v29; // [esp+2878h] [ebp-50h]
  int v30; // [esp+287Ch] [ebp-4Ch]
  int v31; // [esp+2888h] [ebp-40h]
  _DWORD *v32; // [esp+28A8h] [ebp-20h]
  int j; // [esp+28ACh] [ebp-1Ch]

  sub_80AA1F6((int *)&v5, 0x20000);
  v4 = sub_80AA240((int *)&v5);
  if ( dword_842BC80 != 2 )
    return sub_80AA22A((int *)&v5);
  if ( !dword_841FB28 )
    return sub_80AA22A((int *)&v5);
  sub_8067718(&s, (int)v4, 0x20000);
  v17 = dword_841FB44 - 512;
  if ( dword_841FB44 - 512 < 0 )
    v17 = 0;
  v16 = dword_841FB2C - *(_DWORD *)(dword_848B1B4 + 8);
  for ( i = dword_841FB44 - 1; i >= v17; --i )
  {
    v18 = (int *)((char *)dword_841FB50 + 28 * (i % 512));
    if ( *((_DWORD *)dword_841FB50 + 7 * (i % 512)) >= v16 && !v18[6] )
    {
      if ( v18[3] >= dword_841FB3C - 0x4000 && v18[5] >= dword_841FB40 - 4096 )
      {
        sub_8067868(&s);
        sub_8067C2A(&s, *v18);
        sub_8067C2A(&s, dword_841FB04);
        v13 = *(_DWORD *)(dword_848B1CC + 8);
        v12 = v18[4];
        v15 = 0;
        v11 = 0;
        v10 = 0;
        while ( v11 < v13 || v10 < v12 )
        {
          if ( v11 >= v13 || *((_DWORD *)dword_841FB0C + 123845 * v11) > 1 )
          {
            if ( v10 < v12 )
            {
              v15 = (char *)dword_841FB4C + 9992 * ((v10 + v18[5]) % 4096);
              v9 = *((_DWORD *)v15 + 1);
            }
            else
            {
              v9 = 9999;
            }
            if ( v11 == v9 )
            {
              v1 = (int *)sub_81069E2(v11);
              sub_8069428(&s, (int *)v15 + 1, v1, 1);
              if ( sub_80F4696(v11, &v19) )
              {
                sub_80678C6(&s);
                sub_8069D40(&s, v15 + 96, &v19);
              }
              else
              {
                sub_8067868(&s);
              }
              ++v10;
              ++v11;
            }
            else if ( v11 >= v9 )
            {
              if ( v11 > v9 )
                ++v10;
            }
            else
            {
              v2 = (int *)sub_81069E2(v11);
              sub_8069428(&s, 0, v2, 1);
              if ( sub_80F4696(v11, &v19) )
              {
                sub_80678C6(&s);
                sub_8069D40(&s, 0, &v19);
              }
              else
              {
                sub_8067868(&s);
              }
              ++v11;
            }
          }
          else
          {
            ++v11;
          }
        }
        sub_8067868(&s);
        for ( j = 0; j < dword_848B0A4; ++j )
        {
          v32 = (_DWORD *)sub_808FDE4(j);
          if ( *((_BYTE *)v32 + 240) )
          {
            if ( v32[64]
              || !(*((_BYTE *)v32 + 242) & 1)
              && ((v25 = sub_808FE20(v32), *((_BYTE *)v32 + 242) & 0x18) || *(_DWORD *)(v25 + 280)) )
            {
              qmemcpy(&v26, v32, 0xF0u);
              v27 = *((unsigned __int8 *)v32 + 242);
              if ( v32[64] )
                v27 |= 8u;
              v28 = v32[61];
              v29 = v32[62];
              sub_8099DB4(v32 + 72, &v30);
              sub_8099DB4(v32 + 75, &v31);
              sub_80693DA(&s, (int *)(372 * *v32 + 138600604), (int *)&v26, 1);
            }
          }
        }
        goto LABEL_71;
      }
      break;
    }
  }
  sub_80678C6(&s);
  sub_8067C2A(&s, dword_841FB04);
  v18 = (int *)((char *)dword_841FB50 + 28 * (dword_841FB44 % 512));
  *v18 = dword_841FB2C;
  v18[2] = 0;
  v18[3] = dword_841FB3C;
  v18[4] = 0;
  v18[5] = dword_841FB40;
  v18[6] = 0;
  v18[1] = dword_841FB04;
  i = 0;
  v23 = dword_841FB0C;
  while ( i < *(_DWORD *)(dword_848B1CC + 8) )
  {
    if ( *v23 > 1 )
    {
      v15 = (char *)dword_841FB4C + 9992 * (dword_841FB40 % 4096);
      qmemcpy((char *)dword_841FB4C + 9992 * (dword_841FB40 % 4096) + 4, (const void *)sub_81069E2(i), 0x5Cu);
      sub_8069428(&s, 0, (int *)v15 + 1, 1);
      v3 = (signed int *)v15;
      *v3 = sub_80F4696(i, (_DWORD *)v15 + 24);
      if ( *(_DWORD *)v15 )
      {
        sub_80678C6(&s);
        sub_8069D40(&s, 0, (_DWORD *)v15 + 24);
      }
      else
      {
        sub_8067868(&s);
      }
      if ( ++dword_841FB40 > 2147483645 )
        Com_Error(0, &byte_8145240);
      ++v18[4];
    }
    ++i;
    v23 += 123845;
  }
  sub_8067868(&s);
  for ( j = 0; j < dword_848B0A4; ++j )
  {
    v32 = (_DWORD *)sub_808FDE4(j);
    if ( *((_BYTE *)v32 + 240) )
    {
      if ( v32[64]
        || !(*((_BYTE *)v32 + 242) & 1)
        && ((v25 = sub_808FE20(v32), *((_BYTE *)v32 + 242) & 0x18) || *(_DWORD *)(v25 + 280)) )
      {
        *(_DWORD *)v14 = (char *)dword_841FB48 + 276 * (dword_841FB3C % 0x4000);
        qmemcpy((char *)dword_841FB48 + 276 * (dword_841FB3C % 0x4000), v32, 0xF0u);
        *(_DWORD *)(*(_DWORD *)v14 + 240) = *((unsigned __int8 *)v32 + 242);
        if ( v32[64] )
          *(_DWORD *)(*(_DWORD *)v14 + 240) |= 8u;
        *(_DWORD *)(*(_DWORD *)v14 + 244) = v32[61];
        *(_DWORD *)(*(_DWORD *)v14 + 248) = v32[62];
        sub_8099DB4(v32 + 72, (_DWORD *)(*(_DWORD *)v14 + 252));
        sub_8099DB4(v32 + 75, (_DWORD *)(*(_DWORD *)v14 + 264));
        sub_80693DA(&s, (int *)(372 * *v32 + 138600604), *(int **)v14, 1);
        if ( ++dword_841FB3C > 2147483645 )
          Com_Error(0, &byte_8145280);
        ++v18[2];
      }
    }
  }
  if ( ++dword_841FB44 > 2147483645 )
    Com_Error(0, &byte_81452C0);
LABEL_71:
  sub_80677A2(&s, 1023, 10);
  if ( s )
  {
    Com_DPrintf("SV_ArchiveSnapshot: ignoring snapshot because it overflowed.\n");
    result = sub_80AA22A((int *)&v5);
  }
  else
  {
    v22 = (char *)dword_841FB30 + 8 * (dword_841FB2C % 1200);
    *((_DWORD *)dword_841FB30 + 2 * (dword_841FB2C % 1200)) = dword_841FB38;
    *((_DWORD *)v22 + 1) = n;
    v21 = dword_841FB38 % 0x2000000;
    dword_841FB38 += n;
    if ( dword_841FB38 > 2147483645 )
      Com_Error(0, &byte_81454E0);
    v20 = 0x2000000 - v21;
    if ( (signed int)n > 0x2000000 - v21 )
    {
      memcpy((char *)dword_841FB34 + v21, src, v20);
      memcpy(dword_841FB34, (char *)src + v20, n - v20);
    }
    else
    {
      memcpy((char *)dword_841FB34 + v21, src, n);
    }
    if ( ++dword_841FB2C > 2147483645 )
      Com_Error(0, &byte_8145520);
    result = sub_80AA22A((int *)&v5);
  }
  return result;
}
// 841FB28: using guessed type int dword_841FB28;
// 841FB2C: using guessed type int dword_841FB2C;
// 841FB38: using guessed type int dword_841FB38;
// 841FB3C: using guessed type int dword_841FB3C;
// 841FB40: using guessed type int dword_841FB40;
// 841FB44: using guessed type int dword_841FB44;
// 842BC80: using guessed type int dword_842BC80;
// 848B0A4: using guessed type int dword_848B0A4;
// 848B1B4: using guessed type int dword_848B1B4;
// 848B1CC: using guessed type int dword_848B1CC;

//----- (08099AF2) --------------------------------------------------------
void __usercall sub_8099AF2(long double a1@<st0>)
{
  float v1; // ST44_4
  float v2; // ST40_4
  float v3; // ST3C_4
  float v4; // [esp+40h] [ebp-18h]
  float v5; // [esp+40h] [ebp-18h]
  float v6; // [esp+44h] [ebp-14h]
  float v7; // [esp+44h] [ebp-14h]
  signed int v8; // [esp+48h] [ebp-10h]
  _DWORD *v9; // [esp+4Ch] [ebp-Ch]
  int v10; // [esp+50h] [ebp-8h]
  signed int i; // [esp+50h] [ebp-8h]

  v8 = 0;
  dword_848B10C = 0;
  dword_848B164 = 0;
  v10 = 0;
  v9 = dword_841FB0C;
  while ( v10 < *(_DWORD *)(dword_848B1CC + 8) )
  {
    if ( *v9 && dword_841FB04 >= v9[33606] )
    {
      ++v8;
      if ( v9[117113] )
      {
        v9[33606] = dword_841FB04 + sub_80988F4((int)v9, v9[117115] - v9[117114]);
        sub_809558C((int)(v9 + 113005));
      }
      else
      {
        sub_8098C0E(a1, (int)v9);
        sub_8099EC6(v9);
      }
    }
    ++v10;
    v9 += 123845;
  }
  if ( *(_BYTE *)(dword_848B218 + 8) && v8 > 0 )
  {
    v6 = 0.0;
    v4 = 0.0;
    for ( i = 0; i <= 18; ++i )
    {
      dword_848B0B8[i] = dword_848B0BC[i];
      v6 = (long double)dword_848B0B8[i] + v6;
      dword_848B114[i] = dword_848B118[i];
      v4 = (long double)dword_848B114[i] + v4;
    }
    dword_848B104 = dword_848B10C;
    v7 = (long double)dword_848B10C + v6;
    dword_848B160 = dword_848B164;
    v5 = (long double)dword_848B164 + v4;
    if ( dword_848B10C >= dword_848B110 )
      dword_848B110 = dword_848B10C;
    if ( dword_848B164 >= dword_848B168 )
      dword_848B168 = dword_848B164;
    if ( ++dword_848B108 > 19 )
    {
      dword_848B108 = 0;
      v1 = v7 / 20.0;
      v2 = v5 / 20.0;
      v3 = (1.0 - v1 / v2) * 100.0;
      flt_848B16C = flt_848B16C + v3;
      Com_DPrintf(
        "bpspc(%2.0f) bps(%2.0f) pk(%i) ubps(%2.0f) upk(%i) cr(%2.2f) acr(%2.2f)\n",
        (double)(v1 / (long double)v8),
        v1,
        dword_848B110,
        v2,
        dword_848B168,
        v3,
        (double)(flt_848B16C / (long double)++dword_848B170));
    }
  }
}
// 848B0B8: using guessed type int dword_848B0B8[];
// 848B104: using guessed type int dword_848B104;
// 848B108: using guessed type int dword_848B108;
// 848B10C: using guessed type int dword_848B10C;
// 848B110: using guessed type int dword_848B110;
// 848B114: using guessed type int dword_848B114[];
// 848B160: using guessed type int dword_848B160;
// 848B164: using guessed type int dword_848B164;
// 848B168: using guessed type int dword_848B168;
// 848B16C: using guessed type float flt_848B16C;
// 848B170: using guessed type int dword_848B170;
// 848B1CC: using guessed type int dword_848B1CC;
// 848B218: using guessed type int dword_848B218;

//----- (08099D74) --------------------------------------------------------
long double __cdecl sub_8099D74(float a1, float a2, float a3)
{
  return (1.0 - a3) * a1 + a2 * a3;
}

//----- (08099D8A) --------------------------------------------------------
int __cdecl sub_8099D8A(_DWORD *a1)
{
  int result; // eax

  *a1 = 0;
  a1[1] = 0;
  result = 0;
  a1[2] = 0;
  return result;
}

//----- (08099DB4) --------------------------------------------------------
int __cdecl sub_8099DB4(_DWORD *a1, _DWORD *a2)
{
  int result; // eax

  *a2 = *a1;
  a2[1] = a1[1];
  result = a1[2];
  a2[2] = result;
  return result;
}

//----- (08099DE4) --------------------------------------------------------
int __cdecl sub_8099DE4(int a1, _DWORD *a2)
{
  int result; // eax
  int i; // [esp+14h] [ebp-4h]

  sub_8067B4C(a2, *(_DWORD *)(a1 + 495308));
  for ( i = 0; ; ++i )
  {
    result = i;
    if ( i >= *(_DWORD *)(a1 + 495308) )
      break;
    sub_8067B4C(a2, *(_BYTE *)(a1 + 261 * i + 484868));
    sub_8067B4C(a2, *(_DWORD *)(a1 + 261 * i + 485125));
    sub_8067B84((int)a2, (void *)(a1 + 261 * i + 484869), *(_DWORD *)(a1 + 261 * i + 485125));
  }
  return result;
}

//----- (08099EC6) --------------------------------------------------------
int __cdecl sub_8099EC6(_DWORD *a1)
{
  char *v2; // [esp+2Ch] [ebp-3Ch]
  char v3; // [esp+30h] [ebp-38h]
  int s; // [esp+40h] [ebp-28h]
  void *src; // [esp+44h] [ebp-24h]
  size_t n; // [esp+4Ch] [ebp-1Ch]

  sub_80AA1F6((int *)&v3, 0x20000);
  v2 = sub_80AA240((int *)&v3);
  if ( *a1 != 4 || !a1[123827] )
    return sub_80AA22A((int *)&v3);
  sub_8067718(&s, (int)v2, 0x20000);
  sub_8067CE4((int)&s, "v");
  sub_8099DE4((int)a1, &s);
  if ( s )
  {
    Com_Printf("WARNING: voice msg overflowed for %s\n", a1 + 33554);
  }
  else
  {
    sub_806C69C(1, a1[113009], a1[113010], a1[113011], a1[113012], a1[113013], src, n);
    a1[123827] = 0;
  }
  return sub_80AA22A((int *)&v3);
}

//----- (0809A000) --------------------------------------------------------
int __cdecl sub_809A000(int a1)
{
  return *((unsigned __int8 *)dword_841FB0C + 495380 * a1 + 495376);
}

//----- (0809A01E) --------------------------------------------------------
int __cdecl sub_809A01E(int a1, int a2)
{
  return *((unsigned __int8 *)dword_841FB0C + 495380 * a1 + a2 + 495312);
}

//----- (0809A040) --------------------------------------------------------
char *__cdecl sub_809A040(char a1, int a2, int a3)
{
  char *result; // eax
  char *v4; // [esp+10h] [ebp-8h]

  v4 = (char *)dword_841FB0C + 495380 * a2;
  result = (char *)dword_841FB0C + 495380 * a2;
  if ( *((_DWORD *)result + 123827) <= 39 )
  {
    *(_DWORD *)&v4[261 * *((_DWORD *)v4 + 123827) + 485125] = *(_DWORD *)(a3 + 257);
    memcpy(&v4[261 * *((_DWORD *)v4 + 123827) + 484869], (const void *)(a3 + 1), *(_DWORD *)(a3 + 257));
    v4[261 * *((_DWORD *)v4 + 123827) + 484868] = a1;
    result = v4;
    ++*((_DWORD *)result + 123827);
  }
  return result;
}

//----- (0809A112) --------------------------------------------------------
void __cdecl sub_809A112(int a1, _DWORD *a2)
{
  signed int i; // [esp+14h] [ebp-124h]
  signed int v3; // [esp+18h] [ebp-120h]
  char v4; // [esp+20h] [ebp-118h]
  _BYTE v5[3]; // [esp+21h] [ebp-117h]
  size_t n; // [esp+121h] [ebp-17h]

  if ( *(_BYTE *)(dword_848B22C + 8) )
  {
    v3 = sub_8067EE8(a2);
    for ( i = 0; i < v3; ++i )
    {
      n = sub_8067EE8(a2);
      if ( (signed int)n <= 0 || (signed int)n > 256 )
      {
        Com_Printf("Received invalid voice packet of size %i from %s\n", n, a1 + 134216);
        return;
      }
      sub_80681EC((int)a2, v5, n);
      sub_80F721C(*(int **)(a1 + 134212), (int)&v4);
    }
  }
}
// 848B22C: using guessed type int dword_848B22C;

//----- (0809A1EA) --------------------------------------------------------
void __cdecl sub_809A1EA(int a1, _DWORD *a2)
{
  int v2; // [esp+1Ch] [ebp-12Ch]
  int j; // [esp+20h] [ebp-128h]
  signed int i; // [esp+24h] [ebp-124h]
  signed int v5; // [esp+28h] [ebp-120h]
  char v6; // [esp+30h] [ebp-118h]
  _BYTE v7[3]; // [esp+31h] [ebp-117h]
  size_t n; // [esp+131h] [ebp-17h]

  if ( *(_BYTE *)(dword_848B22C + 8) )
  {
    v2 = -1653759219 * ((a1 - (signed int)dword_841FB0C) >> 2);
    v5 = sub_8067EE8(a2);
    for ( i = 0; i < v5; ++i )
    {
      n = sub_8067F32(a2);
      if ( (signed int)n <= 0 || (signed int)n > 256 )
      {
        Com_Printf("Received invalid voice packet of size %i from %s\n", n, a1 + 134216);
        return;
      }
      sub_80681EC((int)a2, v7, n);
      for ( j = 0; j <= 63; ++j )
      {
        if ( j != v2 && *((_DWORD *)dword_841FB0C + 123845 * j) > 1 && !(unsigned __int8)sub_809A01E(j, v2) )
        {
          if ( (unsigned __int8)sub_809A000(j) )
            sub_809A040(v2, j, (int)&v6);
        }
      }
    }
  }
}
// 841FB08: using guessed type int dword_841FB08;
// 848B22C: using guessed type int dword_848B22C;

//----- (0809A368) --------------------------------------------------------
signed int __cdecl sub_809A368(int a1)
{
  signed int v2; // [esp+14h] [ebp-4h]

  if ( *(_BYTE *)(a1 + 241) )
    v2 = *(_DWORD *)(a1 + 140);
  else
    v2 = sub_80590DE((_DWORD *)(a1 + 260), (_DWORD *)(a1 + 272), *(_DWORD *)(a1 + 284));
  return v2;
}

//----- (0809A3BA) --------------------------------------------------------
int __cdecl sub_809A3BA(int a1)
{
  unsigned __int16 *v1; // ST04_4

  v1 = (unsigned __int16 *)sub_808FE20((_DWORD *)a1);
  *(_BYTE *)(a1 + 240) = 0;
  return sub_805DAA0(v1);
}

//----- (0809A3E6) --------------------------------------------------------
void __cdecl sub_809A3E6(int a1)
{
  float v1; // ST0C_4
  signed int v2; // [esp+10h] [ebp-8h]
  int i; // [esp+14h] [ebp-4h]

  for ( i = 0; i <= 2; ++i )
  {
    v2 = sub_809C294(*(float *)(a1 + 4 * i));
    v1 = (long double)v2 - *(float *)(a1 + 4 * i);
    if ( v1 * v1 < 0.0000010000001 )
      *(float *)(a1 + 4 * i) = (long double)v2;
  }
}

//----- (0809A45E) --------------------------------------------------------
int __cdecl sub_809A45E(int a1)
{
  int v2; // edx
  signed int i; // [esp+24h] [ebp-264h]
  signed int j; // [esp+24h] [ebp-264h]
  float v5; // [esp+28h] [ebp-260h]
  float v6; // [esp+28h] [ebp-260h]
  int v7; // [esp+2Ch] [ebp-25Ch]
  float v8[4]; // [esp+30h] [ebp-258h]
  float v9[6]; // [esp+40h] [ebp-248h]
  int v10; // [esp+58h] [ebp-230h]
  int v11; // [esp+5Ch] [ebp-22Ch]
  float *v12; // [esp+60h] [ebp-228h]
  float *v13; // [esp+64h] [ebp-224h]
  int v14; // [esp+68h] [ebp-220h]
  int v15; // [esp+6Ch] [ebp-21Ch]
  int v16; // [esp+70h] [ebp-218h]
  int k; // [esp+74h] [ebp-214h]
  int v18; // [esp+78h] [ebp-210h]
  int v19; // [esp+7Ch] [ebp-20Ch]
  int v20[130]; // [esp+80h] [ebp-208h]

  v11 = sub_808FE20((_DWORD *)a1);
  if ( *(_BYTE *)(a1 + 241) )
  {
    *(_DWORD *)(a1 + 156) = 0xFFFFFF;
  }
  else if ( *(_DWORD *)(a1 + 284) & 0x2000001 )
  {
    k = (signed int)*(float *)(a1 + 272);
    if ( k <= 0 )
      k = 1;
    if ( k > 255 )
      k = 255;
    v16 = (signed int)(1.0 - *(float *)(a1 + 268));
    if ( v16 <= 0 )
      v16 = 1;
    if ( v16 > 255 )
      v16 = 255;
    v15 = (signed int)(*(float *)(a1 + 280) + 32.0);
    if ( v15 <= 0 )
      v15 = 1;
    if ( v15 > 255 )
      v15 = 255;
    *(_DWORD *)(a1 + 156) = k | (v15 << 16) | (v16 << 8);
  }
  else
  {
    *(_DWORD *)(a1 + 156) = 0;
  }
  v12 = (float *)(a1 + 324);
  v13 = (float *)(a1 + 312);
  sub_809A3E6(a1 + 324);
  if ( *(_BYTE *)(a1 + 241) && (*v12 != 0.0 || v12[1] != 0.0 || v12[2] != 0.0) )
  {
    if ( *v12 != 0.0 || v12[2] != 0.0 )
    {
      v5 = sub_80A626E(a1 + 260, a1 + 272);
      for ( i = 0; i <= 2; ++i )
      {
        *(float *)(a1 + 4 * i + 288) = v13[i] - v5;
        *(float *)(a1 + 4 * i + 300) = v13[i] + v5;
      }
    }
    else
    {
      v6 = sub_80A62FC(a1 + 260, a1 + 272);
      for ( j = 0; j <= 1; ++j )
      {
        *(float *)(a1 + 4 * j + 288) = v13[j] - v6;
        *(float *)(a1 + 4 * j + 300) = v13[j] + v6;
      }
      *(float *)(a1 + 296) = v13[2] + *(float *)(a1 + 268);
      *(float *)(a1 + 308) = v13[2] + *(float *)(a1 + 280);
    }
  }
  else
  {
    sub_809C326(v13, (float *)(a1 + 260), (float *)(a1 + 288));
    sub_809C326(v13, (float *)(a1 + 272), (float *)(a1 + 300));
  }
  *(float *)(a1 + 288) = *(float *)(a1 + 288) - 1.0;
  *(float *)(a1 + 292) = *(float *)(a1 + 292) - 1.0;
  *(float *)(a1 + 296) = *(float *)(a1 + 296) - 1.0;
  *(float *)(a1 + 300) = *(float *)(a1 + 300) + 1.0;
  *(float *)(a1 + 304) = *(float *)(a1 + 304) + 1.0;
  *(float *)(a1 + 308) = *(float *)(a1 + 308) + 1.0;
  *(_DWORD *)(v11 + 280) = 0;
  *(_DWORD *)(v11 + 348) = 0;
  if ( !(*(_BYTE *)(a1 + 242) & 0x19) )
  {
    v18 = sub_8058B66((_DWORD *)(a1 + 288), (_DWORD *)(a1 + 300), (int)v20, 128, &v14);
    if ( !v18 )
      return sub_805DAA0((unsigned __int16 *)v11);
    for ( k = 0; k < v18; ++k )
    {
      v19 = sub_80524F4(v20[k]);
      if ( v19 != -1 )
      {
        v2 = v11;
        *(_DWORD *)(v11 + 4 * *(_DWORD *)(v11 + 280) + 284) = v19;
        ++*(_DWORD *)(v2 + 280);
        if ( *(_DWORD *)(v11 + 280) == 16 )
          break;
      }
    }
    if ( k != v18 )
      *(_DWORD *)(v11 + 348) = sub_80524F4(v14);
  }
  *(_BYTE *)(a1 + 240) = 1;
  if ( !*(_DWORD *)(a1 + 284) )
    return sub_805DAA0((unsigned __int16 *)v11);
  v7 = sub_809A368(a1);
  v10 = sub_806289C(*(_DWORD *)a1);
  if ( !v10 || !(*(_BYTE *)(a1 + 242) & 6) )
    return sub_805E18C(v11, (_DWORD *)(a1 + 288), (_DWORD *)(a1 + 300), v7);
  if ( *(_BYTE *)(a1 + 242) & 2 )
  {
    sub_809C2CA(v13, (float *)&unk_815D6E8, v9);
    sub_809C2CA(v13, (float *)&unk_815D6F4, v8);
  }
  else
  {
    sub_80B84A0(v10, v9, v8);
    sub_809C2CA(v13, v9, v9);
    sub_809C2CA(v13, v8, v8);
  }
  return sub_805E18C(v11, v9, v8, v7);
}
// 80A626E: using guessed type double __cdecl sub_80A626E(_DWORD, _DWORD);
// 80A62FC: using guessed type double __cdecl sub_80A62FC(_DWORD, _DWORD);
// 809A45E: using guessed type int var_208[130];

//----- (0809AB88) --------------------------------------------------------
void __cdecl sub_809AB88(int a1, int a2, int a3)
{
  char v3; // [esp+30h] [ebp-48h]
  char v4; // [esp+40h] [ebp-38h]
  float v5; // [esp+5Ch] [ebp-1Ch]
  int v6; // [esp+60h] [ebp-18h]
  float *v7; // [esp+64h] [ebp-14h]
  int v8; // [esp+68h] [ebp-10h]
  int v9; // [esp+6Ch] [ebp-Ch]

  v6 = 1062196213 * ((a2 + -(signed int)&dword_842BC80 - 9240) >> 2);
  v9 = sub_808FDE4(1062196213 * ((a2 + -(signed int)&dword_842BC80 - 9240) >> 2));
  if ( *(_DWORD *)(a1 + 80) & *(_DWORD *)(v9 + 284)
    && (*(_DWORD *)(a1 + 72) == 1023
     || v6 != *(_DWORD *)(a1 + 72)
     && *(_DWORD *)(v9 + 336) != *(_DWORD *)(a1 + 72)
     && *(_DWORD *)(v9 + 336) != *(_DWORD *)(a1 + 76)) )
  {
    sub_809C326((float *)(v9 + 288), (float *)a1, (float *)&v4);
    sub_809C326((float *)(v9 + 300), (float *)(a1 + 12), (float *)&v3);
    if ( !sub_805D6DC(a1 + 36, (int)&v4, (int)&v3, *(float *)a3) )
    {
      v8 = sub_809A368(v9);
      v7 = (float *)(v9 + 324);
      if ( !*(_BYTE *)(v9 + 241) )
        v7 = (float *)&unk_8145E68;
      v5 = *(float *)a3;
      sub_805B6F2((float *)a3, a1 + 36, a1 + 48, a1, a1 + 12, v8, *(_DWORD *)(a1 + 80), (float *)(v9 + 312), v7);
      if ( *(float *)a3 < (long double)v5 )
        *(_WORD *)(a3 + 28) = *(_WORD *)v9;
    }
  }
}
// 842BC80: using guessed type int dword_842BC80;

//----- (0809AD2C) --------------------------------------------------------
void __cdecl sub_809AD2C(int a1, int a2, int a3)
{
  char v3; // [esp+30h] [ebp-C8h]
  int v4; // [esp+54h] [ebp-A4h]
  float v5; // [esp+6Ch] [ebp-8Ch]
  char v6; // [esp+70h] [ebp-88h]
  char v7; // [esp+80h] [ebp-78h]
  float v8; // [esp+90h] [ebp-68h]
  int v9; // [esp+94h] [ebp-64h]
  int v10; // [esp+98h] [ebp-60h]
  int v11; // [esp+A4h] [ebp-54h]
  float v12[4]; // [esp+B0h] [ebp-48h]
  float v13[7]; // [esp+C0h] [ebp-38h]
  int v14; // [esp+DCh] [ebp-1Ch]
  int v15; // [esp+E0h] [ebp-18h]
  float *v16; // [esp+E4h] [ebp-14h]
  int v17; // [esp+E8h] [ebp-10h]
  int v18; // [esp+ECh] [ebp-Ch]

  v15 = 1062196213 * ((a2 + -(signed int)&dword_842BC80 - 9240) >> 2);
  v18 = sub_808FDE4(1062196213 * ((a2 + -(signed int)&dword_842BC80 - 9240) >> 2));
  if ( !(*(_DWORD *)(a1 + 44) & *(_DWORD *)(v18 + 284))
    || *(_DWORD *)(a1 + 36) != 1023
    && (v15 == *(_DWORD *)(a1 + 36)
     || *(_DWORD *)(v18 + 336) == *(_DWORD *)(a1 + 36)
     || *(_DWORD *)(v18 + 336) == *(_DWORD *)(a1 + 40)) )
  {
    return;
  }
  if ( *(_DWORD *)(a1 + 48) )
  {
    v14 = sub_806289C(*(_DWORD *)v18);
    if ( v14 )
    {
      if ( *(_BYTE *)(v18 + 242) & 6 )
      {
        if ( *(_BYTE *)(v18 + 242) & 4 )
        {
          if ( !sub_80B96F8(v14, *(_DWORD *)(a1 + 44)) )
            return;
          sub_809C2F6((_DWORD *)(v18 + 312), &v4);
          sub_80B84A0(v14, v13, v12);
          sub_809C326((float *)&v4, v13, v13);
          sub_809C326((float *)&v4, v12, v12);
LABEL_14:
          if ( !sub_805D6DC(a1, (int)v13, (int)v12, *(float *)a3) )
          {
            sub_811BF30(v18);
            sub_80A7146((float *)(v18 + 324), (int)&v3);
            sub_80A5194((float *)a1, (float *)&v3, (float *)&v7);
            sub_80A5194((float *)(a1 + 12), (float *)&v3, (float *)&v6);
            v8 = *(float *)a3;
            if ( *(_BYTE *)(v18 + 242) & 4 )
              sub_80B955A(v14, (float *)&v7, (float *)&v6, *(_DWORD *)(a1 + 44), (int)&v8);
            else
              sub_80B8CA6(v14, (float *)&v7, (float *)&v6, *(_DWORD *)(a1 + 52), (int)&v8);
            if ( v8 < (long double)*(float *)a3 )
            {
              *(float *)a3 = v8;
              *(_DWORD *)(a3 + 16) = v9;
              *(_DWORD *)(a3 + 30) = v11;
              sub_80A4E52((float *)&v10, (float *)&v3, (float *)(a3 + 4));
LABEL_26:
              *(_WORD *)(a3 + 28) = *(_WORD *)v18;
              *(_DWORD *)(a3 + 20) = *(_DWORD *)(v18 + 284);
              *(_DWORD *)(a3 + 24) = 0;
              return;
            }
          }
          return;
        }
        if ( *(_DWORD *)(a1 + 52) )
        {
          sub_809C2F6((_DWORD *)(v18 + 312), &v4);
          sub_809C326((float *)&v4, (float *)&unk_815D6E8, v13);
          sub_809C326((float *)&v4, (float *)&unk_815D6F4, v12);
          goto LABEL_14;
        }
      }
    }
  }
  if ( *(_DWORD *)(a1 + 44) & *(_DWORD *)(a2 + 352) && !sub_805D6DC(a1, v18 + 288, v18 + 300, *(float *)a3) )
  {
    v17 = sub_809A368(v18);
    v16 = (float *)(v18 + 324);
    if ( !*(_BYTE *)(v18 + 241) )
      v16 = (float *)&unk_8145E68;
    v5 = *(float *)a3;
    sub_805B6F2(
      (float *)a3,
      a1,
      a1 + 12,
      (int)&unk_8145E68,
      (int)&unk_8145E68,
      v17,
      *(_DWORD *)(a1 + 44),
      (float *)(v18 + 312),
      v16);
    if ( *(float *)a3 < (long double)v5 )
    {
      *(_DWORD *)(a3 + 16) = 0;
      *(_WORD *)(a3 + 30) = 0;
      *(_WORD *)(a3 + 32) = 0;
      goto LABEL_26;
    }
  }
}
// 842BC80: using guessed type int dword_842BC80;

//----- (0809B1A0) --------------------------------------------------------
signed int __cdecl sub_809B1A0(_DWORD *a1, int a2)
{
  signed int v3; // [esp+30h] [ebp-18h]
  int v4; // [esp+38h] [ebp-10h]
  float *v5; // [esp+3Ch] [ebp-Ch]
  int v6; // [esp+40h] [ebp-8h]
  int v7; // [esp+44h] [ebp-4h]

  v4 = 1062196213 * ((a2 + -(signed int)&dword_842BC80 - 9240) >> 2);
  v7 = sub_808FDE4(1062196213 * ((a2 + -(signed int)&dword_842BC80 - 9240) >> 2));
  if ( !(a1[17] & *(_DWORD *)(v7 + 284)) )
    return 0;
  if ( a1[15] != 1023 )
  {
    if ( v4 == a1[15] )
      return 0;
    if ( *(_DWORD *)(v7 + 336) == a1[15] )
      return 0;
  }
  if ( a1[16] != 1023 )
  {
    if ( v4 == a1[16] )
      return 0;
    if ( *(_DWORD *)(v7 + 336) == a1[16] )
      return 0;
  }
  v6 = sub_809A368(v7);
  v5 = (float *)(v7 + 324);
  if ( !*(_BYTE *)(v7 + 241) )
    v5 = (float *)&unk_8145E68;
  if ( sub_805D124(0, (int)(a1 + 9), (int)(a1 + 12), (int)a1, (int)(a1 + 3), v6, a1[17], (float *)(v7 + 312), v5) )
    v3 = -1;
  else
    v3 = 0;
  return v3;
}
// 842BC80: using guessed type int dword_842BC80;

//----- (0809B30E) --------------------------------------------------------
signed int __cdecl sub_809B30E(_DWORD *a1, int a2)
{
  char v4; // [esp+40h] [ebp-F8h]
  int v5; // [esp+64h] [ebp-D4h]
  char v6; // [esp+70h] [ebp-C8h]
  char v7; // [esp+80h] [ebp-B8h]
  float v8; // [esp+90h] [ebp-A8h]
  float v9[4]; // [esp+B0h] [ebp-88h]
  float v10[7]; // [esp+C0h] [ebp-78h]
  int v11; // [esp+DCh] [ebp-5Ch]
  float v12[15]; // [esp+E0h] [ebp-58h]
  float v13[15]; // [esp+ECh] [ebp-4Ch]
  int v14; // [esp+120h] [ebp-18h]
  float *v15; // [esp+124h] [ebp-14h]
  int v16; // [esp+128h] [ebp-10h]
  int v17; // [esp+12Ch] [ebp-Ch]

  v14 = 1062196213 * ((a2 + -(signed int)&dword_842BC80 - 9240) >> 2);
  v17 = sub_808FDE4(1062196213 * ((a2 + -(signed int)&dword_842BC80 - 9240) >> 2));
  if ( a1[8] & *(_DWORD *)(v17 + 284) )
  {
    if ( a1[6] != 1023 )
    {
      if ( v14 == a1[6] )
        return 0;
      if ( *(_DWORD *)(v17 + 336) == a1[6] )
        return 0;
    }
    if ( a1[7] != 1023 )
    {
      if ( v14 == a1[7] )
        return 0;
      if ( *(_DWORD *)(v17 + 336) == a1[7] )
        return 0;
    }
    if ( a1[9] && (v11 = sub_806289C(*(_DWORD *)v17)) != 0 && *(_BYTE *)(v17 + 242) & 4 )
    {
      if ( !sub_80B96F8(v11, a1[8]) )
        return 0;
      sub_809C2F6((_DWORD *)(v17 + 312), &v5);
      sub_80B84A0(v11, v10, v9);
      sub_809C326((float *)&v5, v10, v10);
      sub_809C326((float *)&v5, v9, v9);
      sub_809C2F6(a1, v12);
      sub_809C2F6(a1 + 3, v13);
      sub_805D668((int)v12);
      if ( sub_805D6DC((int)v12, (int)v10, (int)v9, 1.0) )
        return 0;
      sub_811BF30(v17);
      sub_80A7146((float *)(v17 + 324), (int)&v4);
      sub_80A5194(v12, (float *)&v4, (float *)&v7);
      sub_80A5194(v13, (float *)&v4, (float *)&v6);
      v8 = 1.0;
      sub_80B955A(v11, (float *)&v7, (float *)&v6, a1[8], (int)&v8);
      if ( v8 < 1.0 )
        return -1;
    }
    else
    {
      v16 = sub_809A368(v17);
      v15 = (float *)(v17 + 324);
      if ( !*(_BYTE *)(v17 + 241) )
        v15 = (float *)&unk_8145E68;
      if ( sub_805D124(
             0,
             (int)a1,
             (int)(a1 + 3),
             (int)&unk_8145E68,
             (int)&unk_8145E68,
             v16,
             a1[8],
             (float *)(v17 + 312),
             v15) )
      {
        return -1;
      }
    }
    return 0;
  }
  return 0;
}
// 842BC80: using guessed type int dword_842BC80;

//----- (0809B6A8) --------------------------------------------------------
void __cdecl sub_809B6A8(void *s, int a2, int a3, int a4, int a5, int a6, int a7, int a8, int a9, int a10)
{
  signed __int16 v10; // [esp+2Ah] [ebp-BEh]
  int v11; // [esp+30h] [ebp-B8h]
  int v12; // [esp+3Ch] [ebp-ACh]
  float v13; // [esp+48h] [ebp-A0h]
  float v14; // [esp+4Ch] [ebp-9Ch]
  float v15; // [esp+50h] [ebp-98h]
  int v16; // [esp+54h] [ebp-94h]
  int v17; // [esp+60h] [ebp-88h]
  int v18; // [esp+78h] [ebp-70h]
  int v19; // [esp+7Ch] [ebp-6Ch]
  int v20; // [esp+80h] [ebp-68h]
  char v21; // [esp+90h] [ebp-58h]
  int v22; // [esp+9Ch] [ebp-4Ch]
  int v23; // [esp+B4h] [ebp-34h]
  int v24; // [esp+B8h] [ebp-30h]
  int v25; // [esp+BCh] [ebp-2Ch]
  int v26; // [esp+C0h] [ebp-28h]
  int v27; // [esp+C4h] [ebp-24h]
  int v28; // [esp+D0h] [ebp-18h]

  sub_805B690(s, a2, a5, a3, a4, 0, a7);
  if ( *(float *)s == 1.0 )
    v10 = 1023;
  else
    v10 = 1022;
  *((_WORD *)s + 14) = v10;
  if ( *(float *)s != 0.0 )
  {
    if ( !a10 || (sub_805EA28((float *)s, (_DWORD *)a2, (_DWORD *)a5, a7), *(float *)s != 0.0) )
    {
      if ( *(float *)a4
         - *(float *)a3
         + *(float *)(a4 + 4)
         - *(float *)(a3 + 4)
         + *(float *)(a4 + 8)
         - *(float *)(a3 + 8) == 0.0 )
      {
        v25 = a7;
        sub_809C2F6((_DWORD *)a2, &v21);
        sub_809C2F6((_DWORD *)a5, &v22);
        sub_805D668((int)&v21);
        v23 = a6;
        v26 = a8;
        v27 = a9;
        if ( a6 == 1023 )
        {
          v24 = -1;
        }
        else
        {
          v24 = *(_DWORD *)(sub_808FDE4(a6) + 336);
          if ( v24 == 1023 )
            v24 = -1;
        }
        sub_805F61E(&v21, (float *)s);
      }
      else
      {
        v20 = a7;
        v18 = a6;
        if ( a6 == 1023 )
        {
          v19 = -1;
        }
        else
        {
          v19 = *(_DWORD *)(sub_808FDE4(a6) + 336);
          if ( v19 == 1023 )
            v19 = -1;
        }
        sub_809C36A((float *)a4, (float *)a3, &v13);
        sub_809C3AE((int)&v13, 0.5, (int)&v13);
        sub_809C2F6(&v13, &v12);
        sub_809C3AE((int)&v13, -1.0, (int)&v11);
        v13 = v13 + 1.0;
        v14 = v14 + 1.0;
        v15 = v15 + 1.0;
        sub_809C326((float *)a4, (float *)a3, (float *)&v28);
        sub_809C3AE((int)&v28, 0.5, (int)&v28);
        sub_809C326((float *)a2, (float *)&v28, (float *)&v16);
        sub_809C326((float *)a5, (float *)&v28, (float *)&v17);
        sub_805D668((int)&v16);
        sub_805F0A4((int)&v11, (float *)s);
      }
    }
  }
}

//----- (0809B9E2) --------------------------------------------------------
signed int __cdecl sub_809B9E2(float *a1, float *a2, float *a3, float *a4, int a5, int a6, int a7, int a8, int a9)
{
  int v11; // [esp+30h] [ebp-98h]
  int v12; // [esp+3Ch] [ebp-8Ch]
  float v13; // [esp+48h] [ebp-80h]
  float v14; // [esp+4Ch] [ebp-7Ch]
  float v15; // [esp+50h] [ebp-78h]
  int v16; // [esp+54h] [ebp-74h]
  int v17; // [esp+60h] [ebp-68h]
  int v18; // [esp+6Ch] [ebp-5Ch]
  int v19; // [esp+70h] [ebp-58h]
  int v20; // [esp+74h] [ebp-54h]
  char v21; // [esp+80h] [ebp-48h]
  int v22; // [esp+8Ch] [ebp-3Ch]
  int v23; // [esp+98h] [ebp-30h]
  int v24; // [esp+9Ch] [ebp-2Ch]
  int v25; // [esp+A0h] [ebp-28h]
  int v26; // [esp+A4h] [ebp-24h]
  int v27; // [esp+B0h] [ebp-18h]

  if ( sub_805CCFA(0, (int)a1, (int)a4, (int)a2, (int)a3, 0, a7) )
    return 0;
  if ( !a9 || sub_805ED1E(a1, a4, a7) )
  {
    if ( *a3 - *a2 + a3[1] - a2[1] + a3[2] - a2[2] == 0.0 )
    {
      v25 = a7;
      sub_809C2F6(a1, &v21);
      sub_809C2F6(a4, &v22);
      v23 = a5;
      v24 = a6;
      v26 = a8;
      if ( sub_805F8C6((int)&v21) )
        return 0;
    }
    else
    {
      v20 = a7;
      v18 = a5;
      v19 = a6;
      sub_809C36A(a3, a2, &v13);
      sub_809C3AE((int)&v13, 0.5, (int)&v13);
      sub_809C2F6(&v13, &v12);
      sub_809C3AE((int)&v13, -1.0, (int)&v11);
      v13 = v13 + 1.0;
      v14 = v14 + 1.0;
      v15 = v15 + 1.0;
      sub_809C326(a3, a2, (float *)&v27);
      sub_809C3AE((int)&v27, 0.5, (int)&v27);
      sub_809C326(a1, (float *)&v27, (float *)&v16);
      sub_809C326(a4, (float *)&v27, (float *)&v17);
      if ( sub_805F3F6((int)&v11) )
        return 0;
    }
    return 1;
  }
  return 0;
}

//----- (0809BC5C) --------------------------------------------------------
int *__cdecl sub_809BC5C(int *a1, float *a2, float *a3, float *a4, float *a5, int a6, int a7, int a8)
{
  int *result; // eax
  signed int v9; // edx
  int v10; // [esp+20h] [ebp-98h]
  int v11; // [esp+2Ch] [ebp-8Ch]
  float v12; // [esp+38h] [ebp-80h]
  float v13; // [esp+3Ch] [ebp-7Ch]
  float v14; // [esp+40h] [ebp-78h]
  int v15; // [esp+44h] [ebp-74h]
  int v16; // [esp+50h] [ebp-68h]
  int v17; // [esp+5Ch] [ebp-5Ch]
  int v18; // [esp+60h] [ebp-58h]
  int v19; // [esp+64h] [ebp-54h]
  char v20; // [esp+70h] [ebp-48h]
  int v21; // [esp+7Ch] [ebp-3Ch]
  int v22; // [esp+88h] [ebp-30h]
  int v23; // [esp+8Ch] [ebp-2Ch]
  int v24; // [esp+90h] [ebp-28h]
  int v25; // [esp+94h] [ebp-24h]
  int v26; // [esp+A0h] [ebp-18h]

  *a1 = sub_805CCFA(*a1, (int)a2, (int)a5, (int)a3, (int)a4, 0, a8);
  result = a1;
  if ( !*a1 )
  {
    if ( *a4 - *a3 + a4[1] - a3[1] + a4[2] - a3[2] == 0.0 )
    {
      v24 = a8;
      sub_809C2F6(a2, &v20);
      sub_809C2F6(a5, &v21);
      v22 = a6;
      v23 = a7;
      v25 = 0;
      v9 = sub_805F8C6((int)&v20);
    }
    else
    {
      v19 = a8;
      v17 = a6;
      v18 = a7;
      sub_809C36A(a4, a3, &v12);
      sub_809C3AE((int)&v12, 0.5, (int)&v12);
      sub_809C2F6(&v12, &v11);
      sub_809C3AE((int)&v12, -1.0, (int)&v10);
      v12 = v12 + 1.0;
      v13 = v13 + 1.0;
      v14 = v14 + 1.0;
      sub_809C326(a4, a3, (float *)&v26);
      sub_809C3AE((int)&v26, 0.5, (int)&v26);
      sub_809C326(a2, (float *)&v26, (float *)&v15);
      sub_809C326(a5, (float *)&v26, (float *)&v16);
      v9 = sub_805F3F6((int)&v10);
    }
    result = a1;
    *a1 = v9;
  }
  return result;
}

//----- (0809BE82) --------------------------------------------------------
signed int __cdecl sub_809BE82(int a1, int a2, int a3, int a4, int a5, int a6)
{
  signed int v7; // [esp+38h] [ebp-50h]
  float v8; // [esp+40h] [ebp-48h]
  float v9; // [esp+44h] [ebp-44h]
  float v10; // [esp+48h] [ebp-40h]
  float v11; // [esp+50h] [ebp-38h]
  float v12; // [esp+54h] [ebp-34h]
  float v13; // [esp+58h] [ebp-30h]
  float *v14; // [esp+6Ch] [ebp-1Ch]
  float *v15; // [esp+70h] [ebp-18h]
  int v16; // [esp+74h] [ebp-14h]
  int v17; // [esp+78h] [ebp-10h]
  int i; // [esp+7Ch] [ebp-Ch]

  v17 = sub_808FDE4(a5);
  if ( !(a6 & *(_DWORD *)(v17 + 284)) )
    return 0;
  for ( i = 0; i <= 2; ++i )
  {
    if ( *(float *)(a4 + 4 * i) <= (long double)*(float *)(a1 + 4 * i) )
    {
      *(&v11 + i) = *(float *)(a4 + 4 * i) + *(float *)(a2 + 4 * i) - 1.0;
      *(&v8 + i) = *(float *)(a1 + 4 * i) + *(float *)(a3 + 4 * i) + 1.0;
    }
    else
    {
      *(&v11 + i) = *(float *)(a1 + 4 * i) + *(float *)(a2 + 4 * i) - 1.0;
      *(&v8 + i) = *(float *)(a4 + 4 * i) + *(float *)(a3 + 4 * i) + 1.0;
    }
  }
  if ( *(float *)(v17 + 288) > (long double)v8
    || *(float *)(v17 + 292) > (long double)v9
    || *(float *)(v17 + 296) > (long double)v10
    || v11 > (long double)*(float *)(v17 + 300)
    || v12 > (long double)*(float *)(v17 + 304)
    || v13 > (long double)*(float *)(v17 + 308) )
  {
    return 0;
  }
  v16 = sub_809A368(v17);
  v15 = (float *)(v17 + 312);
  v14 = (float *)(v17 + 324);
  if ( !*(_BYTE *)(v17 + 241) )
    v14 = (float *)&unk_8145E68;
  if ( sub_805D124(0, a1, a4, a2, a3, v16, a6, v15, v14) )
    v7 = -1;
  else
    v7 = 0;
  return v7;
}

//----- (0809C0CE) --------------------------------------------------------
void __cdecl sub_809C0CE(void *s, int a2, int a3, int a4, int a5, int a6)
{
  char v6; // [esp+10h] [ebp-58h]
  int v7; // [esp+1Ch] [ebp-4Ch]
  int v8; // [esp+34h] [ebp-34h]
  int v9; // [esp+38h] [ebp-30h]
  int v10; // [esp+3Ch] [ebp-2Ch]
  int v11; // [esp+40h] [ebp-28h]
  int v12; // [esp+44h] [ebp-24h]
  int v13; // [esp+58h] [ebp-10h]
  _DWORD *v14; // [esp+5Ch] [ebp-Ch]

  v14 = (_DWORD *)sub_808FDE4(a4);
  v13 = sub_808FE20(v14);
  memset(s, 0, 0x24u);
  *(_DWORD *)s = 1065353216;
  *((_WORD *)s + 14) = 1023;
  sub_809C2F6((_DWORD *)a2, &v6);
  sub_809C2F6((_DWORD *)a3, &v7);
  sub_805D668((int)&v6);
  v8 = -1;
  v9 = -1;
  v10 = a5;
  v11 = 1;
  v12 = a6;
  sub_809AD2C((int)&v6, v13, (int)s);
}

//----- (0809C18C) --------------------------------------------------------
int __cdecl sub_809C18C(float *a1, int a2, int a3)
{
  int v3; // ST3C_4
  int v4; // ST2C_4
  int v6; // [esp+30h] [ebp-1018h]
  int v7; // [esp+34h] [ebp-1014h]
  int i; // [esp+38h] [ebp-1010h]
  int v9[1026]; // [esp+40h] [ebp-1008h]

  v6 = sub_8058D88(a1, 0);
  v7 = sub_805E782((int)a1, (int)a1, (int)v9, 1024, a3);
  for ( i = 0; i < v7; ++i )
  {
    if ( v9[i] != a2 )
    {
      v3 = sub_808FDE4(v9[i]);
      v4 = sub_809A368(v3);
      v6 |= sub_8058E94(a1, v4, (float *)(v3 + 312), (float *)(v3 + 324));
    }
  }
  return v6 & a3;
}
// 809C18C: using guessed type int var_1008[1026];

//----- (0809C294) --------------------------------------------------------
int __cdecl sub_809C294(float a1)
{
  return (signed int)floor(a1 + 0.5);
}

//----- (0809C2CA) --------------------------------------------------------
int __cdecl sub_809C2CA(float *a1, float *a2, float *a3)
{
  int result; // eax

  *a3 = *a1 + *a2;
  result = (int)(a1 + 1);
  a3[1] = a1[1] + a2[1];
  return result;
}

//----- (0809C2F6) --------------------------------------------------------
int __cdecl sub_809C2F6(_DWORD *a1, _DWORD *a2)
{
  int result; // eax

  *a2 = *a1;
  a2[1] = a1[1];
  result = a1[2];
  a2[2] = result;
  return result;
}

//----- (0809C326) --------------------------------------------------------
int __cdecl sub_809C326(float *a1, float *a2, float *a3)
{
  int result; // eax

  *a3 = *a1 + *a2;
  a3[1] = a1[1] + a2[1];
  result = (int)(a1 + 2);
  a3[2] = a1[2] + a2[2];
  return result;
}

//----- (0809C36A) --------------------------------------------------------
int __cdecl sub_809C36A(float *a1, float *a2, float *a3)
{
  int result; // eax

  *a3 = *a1 - *a2;
  a3[1] = a1[1] - a2[1];
  result = (int)(a1 + 2);
  a3[2] = a1[2] - a2[2];
  return result;
}

//----- (0809C3AE) --------------------------------------------------------
int __cdecl sub_809C3AE(int a1, float a2, int a3)
{
  int result; // eax

  *(float *)a3 = a2 * *(float *)a1;
  *(float *)(a3 + 4) = a2 * *(float *)(a1 + 4);
  result = a1 + 8;
  *(float *)(a3 + 8) = a2 * *(float *)(a1 + 8);
  return result;
}

//----- (0809C3E8) --------------------------------------------------------
int RefreshQuitOnErrorCondition()
{
  int result; // eax
  unsigned __int8 v1; // [esp+7h] [ebp-1h]

  result = Dvar_IsSystemActive();
  if ( (_BYTE)result )
  {
    v1 = 0;
    if ( (unsigned __int8)Dvar_GetBool("QuitOnError") || Dvar_GetInt("r_vc_compile") == 2 )
      v1 = 1;
    result = v1;
    byte_848B67C = v1;
  }
  return result;
}
// 848B67C: using guessed type char byte_848B67C;

//----- (0809C42E) --------------------------------------------------------
int QuitOnError()
{
  RefreshQuitOnErrorCondition();
  return (unsigned __int8)byte_848B67C;
}
// 848B67C: using guessed type char byte_848B67C;

//----- (0809C444) --------------------------------------------------------
_BOOL4 FS_Initialized()
{
  return fs_searchpaths != 0;
}

//----- (0809C456) --------------------------------------------------------
void FS_CheckFileSystemStarted()
{
  ;
}

//----- (0809C45C) --------------------------------------------------------
signed int __cdecl FS_IwdIsPure(int a1)
{
  int i; // [esp+4h] [ebp-4h]

  if ( !fs_numServerIwds )
    return 1;
  for ( i = 0; i < fs_numServerIwds; ++i )
  {
    if ( *(_DWORD *)(a1 + 772) == dword_848FF20[i] )
      return 1;
  }
  return 0;
}
// 848FF00: using guessed type int fs_numServerIwds;

//----- (0809C4BA) --------------------------------------------------------
int FS_LoadStack()
{
  return fs_loadStack;
}
// 848B6A4: using guessed type int fs_loadStack;

//----- (0809C4C4) --------------------------------------------------------
_BOOL4 __cdecl FS_UseSearchPath(int a1)
{
  return !*(_DWORD *)(a1 + 12) || !*(_BYTE *)(fs_ignoreLocalized + 8);
}
// 848B7E4: using guessed type int fs_ignoreLocalized;

//----- (0809C4F4) --------------------------------------------------------
signed int __cdecl FS_LanguageHasAssets(int a1)
{
  _DWORD *i; // [esp+4h] [ebp-4h]

  for ( i = fs_searchpaths; i; i = (_DWORD *)*i )
  {
    if ( i[3] && i[4] == a1 )
      return 1;
  }
  return 0;
}

//----- (0809C53E) --------------------------------------------------------
int __cdecl FS_HashFileName(int a1, int a2)
{
  int v3; // [esp+Ch] [ebp-Ch]
  int v4; // [esp+10h] [ebp-8h]
  int i; // [esp+14h] [ebp-4h]

  v4 = 0;
  for ( i = 0; *(_BYTE *)(a1 + i); ++i )
  {
    v3 = tolower(*(char *)(a1 + i));
    if ( v3 == 46 )
      break;
    if ( v3 == 92 )
      v3 = 47;
    if ( v3 == 47 )
      v3 = 47;
    v4 += v3 * (i + 119);
  }
  return (a2 - 1) & (v4 ^ (v4 >> 10) ^ (v4 >> 20));
}

//----- (0809C5D2) --------------------------------------------------------
int __cdecl FS_HandleForFile(int a1)
{
  signed int v2; // [esp+1Ch] [ebp-Ch]
  signed int v3; // [esp+20h] [ebp-8h]
  char v4[4]; // [esp+24h] [ebp-4h]

  if ( a1 )
  {
    v3 = 51;
    v2 = 13;
  }
  else
  {
    v3 = 1;
    v2 = 50;
  }
  for ( *(_DWORD *)v4 = 0; ; ++*(_DWORD *)v4 )
  {
    if ( *(_DWORD *)v4 >= v2 )
    {
      for ( *(_DWORD *)v4 = 1; *(_DWORD *)v4 <= 63; ++*(_DWORD *)v4 )
        Com_Printf("FILE %2i: '%s'\n", *(_DWORD *)v4, 284 * *(_DWORD *)v4 + 138983452);
      Com_Error(1, &byte_8145690);
    }
    if ( !dword_848B800[71 * (v3 + *(_DWORD *)v4)] )
      break;
  }
  return v3 + *(_DWORD *)v4;
}
// 848B800: using guessed type int dword_848B800[];

//----- (0809C690) --------------------------------------------------------
int __cdecl FS_FileForHandle(int a1)
{
  return dword_848B800[71 * a1];
}
// 848B800: using guessed type int dword_848B800[];

//----- (0809C6A4) --------------------------------------------------------
int __cdecl FS_filelength(int a1)
{
  FILE *stream; // ST1C_4
  int off; // ST24_4
  int v3; // ST20_4

  FS_CheckFileSystemStarted();
  if ( dword_848B814[71 * a1] )
    return *(_DWORD *)(dword_848B800[71 * a1] + 68);
  stream = (FILE *)FS_FileForHandle(a1);
  off = ftell(stream);
  FS_FileSeek(stream, 0, 2);
  v3 = ftell(stream);
  FS_FileSeek(stream, off, 0);
  return v3;
}
// 848B800: using guessed type int dword_848B800[];
// 848B814: using guessed type int dword_848B814[];

//----- (0809C748) --------------------------------------------------------
_BYTE *__cdecl sub_809C748(_BYTE *a1)
{
  _BYTE *result; // eax
  char v2; // [esp+3h] [ebp-9h]
  _BYTE *v3; // [esp+4h] [ebp-8h]
  _BYTE *v4; // [esp+8h] [ebp-4h]

  v2 = 0;
  v4 = a1;
  v3 = a1;
  while ( *v4 )
  {
    if ( *v4 != 47 && *v4 != 92 )
    {
      v2 = 0;
      *v3++ = *v4;
    }
    else if ( !v2 )
    {
      v2 = 1;
      *v3++ = 47;
    }
    ++v4;
  }
  result = v3;
  *v3 = 0;
  return result;
}

//----- (0809C7B4) --------------------------------------------------------
void *__cdecl FS_BuildOSPath_Internal(void *src, char *s, char *a3, void *dest, int a5)
{
  void *result; // eax
  size_t v6; // [esp+Ch] [ebp-Ch]
  size_t v7; // [esp+10h] [ebp-8h]
  size_t n; // [esp+14h] [ebp-4h]

  if ( !s || !*s )
    s = byte_848B6C0;
  n = I_strlen((char *)src);
  v7 = I_strlen(s);
  v6 = I_strlen(a3);
  if ( (signed int)(v6 + n + v7 + 2) <= 255 )
  {
    memcpy(dest, src, n);
    *((_BYTE *)dest + n) = 47;
    memcpy((char *)dest + n + 1, s, v7);
    *((_BYTE *)dest + n + v7 + 1) = 47;
    memcpy((char *)dest + n + v7 + 2, a3, v6 + 1);
    result = sub_809C748(dest);
  }
  else
  {
    if ( !a5 )
      Com_Error(0, &byte_81456C0);
    result = dest;
    *(_BYTE *)dest = 0;
  }
  return result;
}

//----- (0809C8AE) --------------------------------------------------------
void *__cdecl FS_BuildOSPath(void *src, char *s, char *a3, void *dest)
{
  return FS_BuildOSPath_Internal(src, s, a3, dest, 0);
}

//----- (0809C8DE) --------------------------------------------------------
int __cdecl FS_CreatePath(char *haystack)
{
  signed int v2; // [esp+10h] [ebp-8h]
  char *i; // [esp+14h] [ebp-4h]

  if ( strstr(haystack, "..") || strstr(haystack, "::") )
  {
    Com_Printf("WARNING: refusing to create relative path \"%s\"\n", haystack);
    v2 = 1;
  }
  else
  {
    for ( i = haystack + 1; *i; ++i )
    {
      if ( *i == 47 )
      {
        *i = 0;
        sub_80D3874(haystack);
        *i = 47;
      }
    }
    v2 = 0;
  }
  return v2;
}

//----- (0809C974) --------------------------------------------------------
void __cdecl FS_CopyFile(char *filename, char *haystack)
{
  void *ptr; // [esp+1Ch] [ebp-Ch]
  int size; // [esp+20h] [ebp-8h]
  FILE *stream; // [esp+24h] [ebp-4h]
  FILE *streama; // [esp+24h] [ebp-4h]

  stream = FS_FileOpen(filename, "rb");
  if ( stream )
  {
    FS_FileSeek(stream, 0, 2);
    size = ftell(stream);
    FS_FileSeek(stream, 0, 0);
    ptr = malloc(size);
    if ( FS_FileRead(ptr, 1u, size, stream) != size )
      Com_Error(0, &byte_8145733);
    FS_FileClose(stream);
    if ( FS_CreatePath(haystack) )
    {
      free(ptr);
    }
    else
    {
      streama = FS_FileOpen(haystack, "wb");
      if ( streama )
      {
        if ( FS_FileWrite(ptr, 1u, size, streama) != size )
          Com_Error(0, &byte_8145760);
        FS_FileClose(streama);
        free(ptr);
      }
      else
      {
        free(ptr);
      }
    }
  }
}

//----- (0809CACA) --------------------------------------------------------
int __cdecl sub_809CACA(char *filename)
{
  return remove(filename);
}

//----- (0809CADE) --------------------------------------------------------
int __cdecl sub_809CADE(char *a1)
{
  char filename; // [esp+20h] [ebp-118h]
  FILE *stream; // [esp+12Ch] [ebp-Ch]

  FS_BuildOSPath(*(void **)(fs_homepath + 8), byte_848B6C0, a1, &filename);
  stream = FS_FileOpen(&filename, "rb");
  if ( !stream )
    return 0;
  FS_FileClose(stream);
  return 1;
}
// 848B7C4: using guessed type int fs_homepath;

//----- (0809CB58) --------------------------------------------------------
int __cdecl sub_809CB58(char *a1, char *a2)
{
  int result; // eax
  char newa; // [esp+10h] [ebp-208h]
  char old; // [esp+110h] [ebp-108h]

  FS_CheckFileSystemStarted();
  FS_BuildOSPath(*(void **)(fs_homepath + 8), byte_848B6C0, a1, &old);
  FS_BuildOSPath(*(void **)(fs_homepath + 8), byte_848B6C0, a2, &newa);
  if ( *(_DWORD *)(fs_debug + 8) )
    Com_Printf("FS_Rename: %s --> %s\n", &old, &newa);
  result = rename(&old, &newa);
  if ( result )
  {
    sub_809CACA(&newa);
    result = rename(&old, &newa);
    if ( result )
    {
      FS_CopyFile(&old, &newa);
      result = sub_809CACA(&old);
    }
  }
  return result;
}
// 848B7C0: using guessed type int fs_debug;
// 848B7C4: using guessed type int fs_homepath;

//----- (0809CC52) --------------------------------------------------------
void *__cdecl FS_FCloseFile(int a1)
{
  void *result; // eax
  FILE *stream; // ST14_4

  FS_CheckFileSystemStarted();
  if ( dword_848B818[71 * a1] )
    sub_80D2168();
  if ( dword_848B814[71 * a1] )
  {
    sub_80D0F1A(dword_848B800[71 * a1]);
    if ( dword_848B804[71 * a1] )
      sub_80CFC62(dword_848B800[71 * a1]);
    result = sub_80AA83E((void *)(284 * a1 + 138983424), 0, 0x11Cu);
  }
  else
  {
    if ( a1 )
    {
      stream = (FILE *)FS_FileForHandle(a1);
      FS_FileClose(stream);
    }
    result = sub_80AA83E((void *)(284 * a1 + 138983424), 0, 0x11Cu);
  }
  return result;
}
// 848B800: using guessed type int dword_848B800[];
// 848B804: using guessed type int dword_848B804[];
// 848B814: using guessed type int dword_848B814[];

//----- (0809CD3C) --------------------------------------------------------
int __cdecl FS_GetHandleAndOpenFile(char *src, char *filename, char *modes, int a4)
{
  int v4; // ST14_4
  FILE *v7; // [esp+10h] [ebp-8h]

  v7 = FS_FileOpen(filename, modes);
  if ( !v7 )
    return 0;
  v4 = FS_HandleForFile(a4);
  dword_848B814[71 * v4] = 0;
  dword_848B800[71 * v4] = (int)v7;
  I_strncpyz((char *)(284 * v4 + 138983452), src, 256);
  dword_848B808[71 * v4] = 0;
  return v4;
}
// 848B800: using guessed type int dword_848B800[];
// 848B808: using guessed type int dword_848B808[];
// 848B814: using guessed type int dword_848B814[];

//----- (0809CDDE) --------------------------------------------------------
int __cdecl FS_FOpenFileWrite(char *src)
{
  int v2; // [esp+1Ch] [ebp-10Ch]
  char dest; // [esp+20h] [ebp-108h]

  FS_CheckFileSystemStarted();
  FS_BuildOSPath(*(void **)(fs_homepath + 8), byte_848B6C0, src, &dest);
  if ( *(_DWORD *)(fs_debug + 8) )
    Com_Printf("FS_FOpenFileWrite: %s\n", &dest);
  if ( FS_CreatePath(&dest) )
    v2 = 0;
  else
    v2 = FS_GetHandleAndOpenFile(src, &dest, "wb", 0);
  return v2;
}
// 848B7C0: using guessed type int fs_debug;
// 848B7C4: using guessed type int fs_homepath;

//----- (0809CE88) --------------------------------------------------------
int __cdecl FS_FOpenTextFileWrite(char *src)
{
  int v3; // [esp+18h] [ebp-110h]
  char filename; // [esp+20h] [ebp-108h]

  FS_CheckFileSystemStarted();
  v3 = FS_HandleForFile(0);
  dword_848B814[71 * v3] = 0;
  FS_BuildOSPath(*(void **)(fs_homepath + 8), byte_848B6C0, src, &filename);
  if ( *(_DWORD *)(fs_debug + 8) )
    Com_Printf("FS_FOpenFileWrite: %s\n", &filename);
  if ( FS_CreatePath(&filename) )
    return 0;
  dword_848B800[71 * v3] = (int)FS_FileOpen(&filename, "wt");
  I_strncpyz((char *)(284 * v3 + 138983452), src, 256);
  dword_848B808[71 * v3] = 0;
  if ( !dword_848B800[71 * v3] )
    v3 = 0;
  return v3;
}
// 848B7C0: using guessed type int fs_debug;
// 848B7C4: using guessed type int fs_homepath;
// 848B800: using guessed type int dword_848B800[];
// 848B808: using guessed type int dword_848B808[];
// 848B814: using guessed type int dword_848B814[];

//----- (0809CFDA) --------------------------------------------------------
int __cdecl FS_FOpenFileAppend(char *src)
{
  int v3; // [esp+18h] [ebp-110h]
  char filename; // [esp+20h] [ebp-108h]

  FS_CheckFileSystemStarted();
  v3 = FS_HandleForFile(0);
  dword_848B814[71 * v3] = 0;
  I_strncpyz((char *)(284 * v3 + 138983452), src, 256);
  FS_BuildOSPath(*(void **)(fs_homepath + 8), byte_848B6C0, src, &filename);
  if ( *(_DWORD *)(fs_debug + 8) )
    Com_Printf("FS_FOpenFileAppend: %s\n", &filename);
  if ( FS_CreatePath(&filename) )
    return 0;
  dword_848B800[71 * v3] = (int)FS_FileOpen(&filename, "at");
  dword_848B808[71 * v3] = 0;
  if ( !dword_848B800[71 * v3] )
    v3 = 0;
  return v3;
}
// 848B7C0: using guessed type int fs_debug;
// 848B7C4: using guessed type int fs_homepath;
// 848B800: using guessed type int dword_848B800[];
// 848B808: using guessed type int dword_848B808[];
// 848B814: using guessed type int dword_848B814[];

//----- (0809D12A) --------------------------------------------------------
signed int __cdecl FS_FilenameCompare(char *a1, char *a2)
{
  signed int v4; // [esp+10h] [ebp-8h]
  signed int v5; // [esp+14h] [ebp-4h]

  do
  {
    v5 = *a1++;
    v4 = *a2++;
    if ( (unsigned __int8)sub_80B53C8(v5) )
      v5 -= 32;
    if ( (unsigned __int8)sub_80B53C8(v4) )
      v4 -= 32;
    if ( v5 == 92 || v5 == 58 )
      v5 = 47;
    if ( v4 == 92 || v4 == 58 )
      v4 = 47;
    if ( v5 != v4 )
      return -1;
  }
  while ( v5 );
  return 0;
}

//----- (0809D1C6) --------------------------------------------------------
int __cdecl sub_809D1C6(char *filename, char *a2)
{
  int v2; // ST24_4
  int v3; // ST24_4
  signed int v5; // [esp+10h] [ebp-28h]
  _BYTE *v6; // [esp+14h] [ebp-24h]
  _BYTE *v7; // [esp+18h] [ebp-20h]
  void *v8; // [esp+1Ch] [ebp-1Ch]
  void *ptr; // [esp+20h] [ebp-18h]
  int off; // [esp+24h] [ebp-14h]
  int size; // [esp+28h] [ebp-10h]
  int n; // [esp+2Ch] [ebp-Ch]
  FILE *v13; // [esp+30h] [ebp-8h]
  FILE *stream; // [esp+34h] [ebp-4h]

  stream = FS_FileOpen(filename, "rb");
  if ( !stream )
    Com_Error(0, &byte_81457E0, filename);
  v13 = FS_FileOpen(a2, "rb");
  if ( v13 )
  {
    v2 = ftell(stream);
    FS_FileSeek(stream, 0, 2);
    n = ftell(stream);
    FS_FileSeek(stream, v2, 0);
    v3 = ftell(v13);
    FS_FileSeek(v13, 0, 2);
    size = ftell(v13);
    FS_FileSeek(v13, v3, 0);
    if ( n == size )
    {
      ptr = Z_MallocInternal(n);
      if ( FS_FileRead(ptr, 1u, n, stream) != n )
        Com_Error(0, &byte_8145820);
      FS_FileClose(stream);
      v8 = Z_MallocInternal(size);
      if ( FS_FileRead(v8, 1u, size, v13) != size )
        Com_Error(0, &byte_8145820);
      FS_FileClose(v13);
      v7 = ptr;
      v6 = v8;
      off = 0;
      while ( off < n )
      {
        if ( *v7 != *v6 )
        {
          free(ptr);
          free(v8);
          return 0;
        }
        ++off;
        ++v7;
        ++v6;
      }
      free(ptr);
      free(v8);
      v5 = 1;
    }
    else
    {
      FS_FileClose(stream);
      FS_FileClose(v13);
      v5 = 0;
    }
  }
  else
  {
    FS_FileClose(stream);
    v5 = 0;
  }
  return v5;
}

//----- (0809D424) --------------------------------------------------------
char *__cdecl sub_809D424(char *haystack, int a2, char a3)
{
  int i; // [esp+1Ch] [ebp-10Ch]
  char needle[264]; // [esp+20h] [ebp-108h]

  for ( i = 0; *(_BYTE *)(a2 + i); ++i )
    needle[i] = *(_BYTE *)(i + a2) + a3;
  needle[i] = 0;
  return strstr(haystack, needle);
}
// 809D424: using guessed type char needle[264];

//----- (0809D498) --------------------------------------------------------
_BOOL4 __cdecl sub_809D498(char *s1)
{
  if ( *s1 == 46 )
    ++s1;
  if ( !strcasecmp(s1, "cfg") )
    return 1;
  if ( I_stricmp(s1, "menu") )
    return I_stricmp(s1, ".dm_NETWORK_PROTOCOL_VERSION") == 0;
  return 1;
}

//----- (0809D516) --------------------------------------------------------
_BOOL4 __cdecl sub_809D516(_BYTE *a1)
{
  _BOOL4 v2; // [esp+0h] [ebp-4h]

  if ( *a1 != 46 || a1[1] != 46 )
    v2 = *a1 == 58 && a1[1] == 58;
  else
    v2 = 1;
  return v2;
}

//----- (0809D55C) --------------------------------------------------------
signed int __cdecl FS_IsBackupSubStr(char a1)
{
  signed int v2; // [esp+0h] [ebp-Ch]

  if ( a1 == 47 )
    return 1;
  v2 = 0;
  if ( a1 == 47 || a1 == 92 )
    v2 = 1;
  return v2;
}

//----- (0809D59E) --------------------------------------------------------
signed int __cdecl FS_SanitizeFilename(int a1, int a2)
{
  int v4; // [esp+10h] [ebp-8h]
  int i; // [esp+14h] [ebp-4h]

  for ( i = 0; (unsigned __int8)FS_IsBackupSubStr(*(_BYTE *)(a1 + i)); ++i )
    ;
  v4 = 0;
  while ( *(_BYTE *)(a1 + i) )
  {
    if ( (unsigned __int8)sub_809D516((_BYTE *)(a1 + i)) )
      return 0;
    if ( *(_BYTE *)(a1 + i) != 46 || *(_BYTE *)(a1 + i + 1) && !(unsigned __int8)FS_IsBackupSubStr(*(_BYTE *)(a1 + i + 1)) )
    {
      if ( (unsigned __int8)FS_IsBackupSubStr(*(_BYTE *)(a1 + i)) )
      {
        *(_BYTE *)(a2 + v4) = 47;
        while ( (unsigned __int8)FS_IsBackupSubStr(*(_BYTE *)(a1 + i + 1)) )
          ++i;
      }
      else
      {
        *(_BYTE *)(v4 + a2) = *(_BYTE *)(a1 + i);
      }
      ++v4;
    }
    ++i;
  }
  *(_BYTE *)(a2 + v4) = 0;
  return 1;
}

//----- (0809D6A2) --------------------------------------------------------
int __cdecl sub_809D6A2(char *a1)
{
  size_t v1; // eax
  size_t v4; // [esp+18h] [ebp-30h]
  int i; // [esp+1Ch] [ebp-2Ch]
  char *s; // [esp+20h] [ebp-28h]
  const char *v7; // [esp+24h] [ebp-24h]
  const char *v8; // [esp+28h] [ebp-20h]
  const char *v9; // [esp+2Ch] [ebp-1Ch]
  const char *v10; // [esp+30h] [ebp-18h]
  const char *v11; // [esp+34h] [ebp-14h]
  const char *v12; // [esp+38h] [ebp-10h]
  char *v13; // [esp+3Ch] [ebp-Ch]

  s = ".hlsl";
  v7 = ".txt";
  v8 = ".cfg";
  v9 = ".levelshots";
  v10 = ".menu";
  v11 = ".arena";
  v12 = ".str";
  v13 = &byte_8145895;
  v4 = I_strlen(a1);
  for ( i = 0; *(&s)[i]; ++i )
  {
    v1 = strlen((&s)[i]);
    if ( !I_stricmp(&a1[v4 - v1], (&s)[i]) )
      return 1;
  }
  return 0;
}

//----- (0809D756) --------------------------------------------------------
int __cdecl FS_FOpenFileRead_Internal(int a1, int *a2, int a3, int a4)
{
  int v4; // ebx
  int v5; // ebx
  char *v6; // eax
  signed int v8; // [esp+8h] [ebp-370h]
  signed int v9; // [esp+2Ch] [ebp-34Ch]
  char haystack; // [esp+30h] [ebp-348h]
  char v11; // [esp+13Fh] [ebp-239h]
  char v12[4]; // [esp+140h] [ebp-238h]
  char *s1; // [esp+144h] [ebp-234h]
  FILE *stream; // [esp+148h] [ebp-230h]
  void *dest; // [esp+14Ch] [ebp-22Ch]
  int v16; // [esp+150h] [ebp-228h]
  void *v17; // [esp+154h] [ebp-224h]
  int v18; // [esp+158h] [ebp-220h]
  char *v19; // [esp+15Ch] [ebp-21Ch]
  char filename; // [esp+160h] [ebp-218h]
  char src; // [esp+260h] [ebp-118h]
  void *i; // [esp+36Ch] [ebp-Ch]

  v11 = 0;
  v16 = 0;
  FS_CheckFileSystemStarted();
  v8 = 256;
  if ( !(unsigned __int8)FS_SanitizeFilename(a1, (int)&src) )
  {
    if ( a2 )
      *a2 = 0;
    return -1;
  }
  if ( !a2 )
  {
    for ( i = fs_searchpaths; ; i = *(void **)i )
    {
      if ( !i )
        return -1;
      if ( FS_UseSearchPath((int)i) )
      {
        if ( *((_DWORD *)i + 1) )
          v16 = FS_HashFileName((int)&src, *(_DWORD *)(*((_DWORD *)i + 1) + 788));
        if ( *((_DWORD *)i + 1) && *(_DWORD *)(*(_DWORD *)(*((_DWORD *)i + 1) + 792) + 4 * v16) )
        {
          v19 = (char *)*((_DWORD *)i + 1);
          v18 = *(_DWORD *)(*((_DWORD *)v19 + 198) + 4 * v16);
          while ( FS_FilenameCompare(*(char **)(v18 + 4), &src) )
          {
            v18 = *(_DWORD *)(v18 + 8);
            if ( !v18 )
              goto LABEL_21;
          }
          return 1;
        }
        if ( *((_DWORD *)i + 2) )
        {
          v17 = (void *)*((_DWORD *)i + 2);
          FS_BuildOSPath_Internal(v17, (char *)v17 + 256, &src, &filename, a4);
          stream = FS_FileOpen(&filename, "rb");
          if ( stream )
          {
            FS_FileClose(stream);
            return 1;
          }
        }
      }
LABEL_21:
      ;
    }
  }
  *a2 = FS_HandleForFile(a4);
  dword_848B804[71 * *a2] = a3;
  *(_DWORD *)v12 = 0;
  for ( i = fs_searchpaths; ; i = *(void **)i )
  {
    if ( !i )
    {
      if ( *(_DWORD *)(fs_debug + 8) && !a4 )
        Com_Printf("Can't find %s\n", a1, v8);
      *a2 = 0;
      if ( *(_DWORD *)v12 )
      {
        v6 = va(aExeUnpureclien_0, *(_DWORD *)v12, v8);
        Com_Error(1, v6);
      }
      if ( v11 )
        v9 = -2;
      else
        v9 = -1;
      return v9;
    }
    if ( FS_UseSearchPath((int)i) )
      break;
LABEL_71:
    ;
  }
  v19 = (char *)*((_DWORD *)i + 1);
  if ( v19 )
    v16 = FS_HashFileName((int)&src, *((_DWORD *)v19 + 197));
  if ( !v19 || !*(_DWORD *)(*((_DWORD *)v19 + 198) + 4 * v16) )
  {
    if ( *((_DWORD *)i + 2) )
    {
      s1 = sub_80B4E42(&src);
      if ( !*(_BYTE *)(fs_restrict + 8) && !fs_numServerIwds || *((_DWORD *)i + 3) || sub_809D498(s1) )
      {
        v17 = (void *)*((_DWORD *)i + 2);
        FS_BuildOSPath_Internal(v17, (char *)v17 + 256, &src, &filename, a4);
        v5 = 71 * *a2;
        dword_848B800[v5] = (int)FS_FileOpen(&filename, "rb");
        if ( dword_848B800[71 * *a2] )
        {
          if ( !*((_DWORD *)i + 3) && !sub_809D498(s1) )
            *(_DWORD *)dword_848B7F0 = rand() + 1;
          I_strncpyz((char *)(284 * *a2 + 138983452), &src, 256);
          dword_848B814[71 * *a2] = 0;
          if ( *(_DWORD *)(fs_debug + 8) && !a4 )
            Com_Printf("FS_FOpenFileRead: %s (found in '%s/%s')\n", &src, v17, (char *)v17 + 256);
          if ( *(_BYTE *)(fs_copyfiles + 8) && !I_stricmp((char *)v17, *(char **)(fs_cdpath + 8)) )
          {
            FS_BuildOSPath_Internal(*(void **)(fs_basepath + 8), (char *)v17 + 256, &src, &haystack, a4);
            FS_CopyFile(&filename, &haystack);
          }
          return FS_filelength(*a2);
        }
      }
      else if ( !v11 )
      {
        v17 = (void *)*((_DWORD *)i + 2);
        FS_BuildOSPath_Internal(v17, (char *)v17 + 256, &src, &filename, a4);
        stream = FS_FileOpen(&filename, "rb");
        if ( stream )
        {
          v11 = 1;
          FS_FileClose(stream);
        }
      }
    }
    goto LABEL_71;
  }
  v18 = *(_DWORD *)(*((_DWORD *)v19 + 198) + 4 * v16);
  while ( FS_FilenameCompare(*(char **)(v18 + 4), &src) )
  {
    v18 = *(_DWORD *)(v18 + 8);
    if ( !v18 )
      goto LABEL_71;
  }
  if ( !*((_DWORD *)i + 3) && !FS_IwdIsPure((int)v19) )
  {
    *(_DWORD *)v12 = v19;
    goto LABEL_71;
  }
  if ( !v19[784] && !(unsigned __int8)sub_809D6A2(&src) )
    v19[784] = 1;
  if ( a3 )
  {
    v4 = 71 * *a2;
    dword_848B800[v4] = (int)sub_80CF90C(v19, *((void **)v19 + 192));
    if ( !dword_848B800[71 * *a2] )
    {
      if ( !a4 )
        Com_Error(0, &byte_8145896, v19);
      FS_FCloseFile(*a2);
      *a2 = 0;
      return -1;
    }
  }
  else
  {
    dword_848B800[71 * *a2] = *((_DWORD *)v19 + 192);
  }
  I_strncpyz((char *)(284 * *a2 + 138983452), &src, 256);
  dword_848B814[71 * *a2] = (int)v19;
  dest = (void *)dword_848B800[71 * *a2];
  stream = *(FILE **)dest;
  unzSetCurrentFileInfoPosition(*((_DWORD *)v19 + 192), *(_DWORD *)v18);
  if ( dest != *((void **)v19 + 192) )
    Com_Memcpy(dest, *((void **)v19 + 192), 0x80u);
  *(_DWORD *)dest = stream;
  unzOpenCurrentFile((_DWORD *)dword_848B800[71 * *a2]);
  dword_848B810[71 * *a2] = *(_DWORD *)v18;
  if ( *(_DWORD *)(fs_debug + 8) && !a4 )
    Com_Printf("FS_FOpenFileRead: %s (found in '%s')\n", &src, v19);
  return *((_DWORD *)dest + 17);
}
// 848B7C0: using guessed type int fs_debug;
// 848B7D4: using guessed type int fs_cdpath;
// 848B7D8: using guessed type int fs_copyfiles;
// 848B7E0: using guessed type int fs_restrict;
// 848B800: using guessed type int dword_848B800[];
// 848B804: using guessed type int dword_848B804[];
// 848B810: using guessed type int dword_848B810[];
// 848B814: using guessed type int dword_848B814[];
// 848FF00: using guessed type int fs_numServerIwds;

//----- (0809E034) --------------------------------------------------------
int __cdecl FS_FOpenFileReadStream(int a1, int *a2, int a3)
{
  return FS_FOpenFileRead_Internal(a1, a2, a3, 1);
}

//----- (0809E064) --------------------------------------------------------
int __cdecl FS_FOpenFileRead(int a1, int *a2, int a3)
{
  dword_848B6A0 = 1;
  return FS_FOpenFileRead_Internal(a1, a2, a3, 0);
}
// 848B6A0: using guessed type int dword_848B6A0;

//----- (0809E09E) --------------------------------------------------------
signed int __cdecl FS_TouchFile(int a1)
{
  int v3; // [esp+14h] [ebp-4h]

  FS_FOpenFileRead(a1, &v3, 0);
  if ( !v3 )
    return 0;
  FS_FCloseFile(v3);
  return 1;
}

//----- (0809E0E4) --------------------------------------------------------
char *__cdecl sub_809E0E4(char *a1)
{
  FILE *stream; // [esp+18h] [ebp-120h]
  char *src; // [esp+1Ch] [ebp-11Ch]
  char filename; // [esp+20h] [ebp-118h]
  void *i; // [esp+12Ch] [ebp-Ch]

  for ( i = fs_searchpaths; i; i = *(void **)i )
  {
    if ( FS_UseSearchPath((int)i) )
    {
      if ( *((_DWORD *)i + 2) )
      {
        src = (char *)*((_DWORD *)i + 2);
        FS_BuildOSPath(*((void **)i + 2), src + 256, a1, &filename);
        stream = FS_FileOpen(&filename, "rb");
        if ( stream )
        {
          FS_FileClose(stream);
          return va("%s/%s", src + 256, a1);
        }
      }
    }
  }
  return 0;
}

//----- (0809E1DA) --------------------------------------------------------
_BOOL4 __cdecl sub_809E1DA(char *a1)
{
  char filename; // [esp+20h] [ebp-108h]

  FS_CheckFileSystemStarted();
  if ( !*a1 )
    return 0;
  FS_BuildOSPath(*(void **)(fs_homepath + 8), byte_848B6C0, a1, &filename);
  return remove(&filename) != -1;
}
// 848B7C4: using guessed type int fs_homepath;

//----- (0809E256) --------------------------------------------------------
_BOOL4 __cdecl sub_809E256(char *a1, int a2)
{
  __mode_t v3; // [esp+18h] [ebp-180h]
  struct stat stat_buf; // [esp+20h] [ebp-178h]
  char file; // [esp+90h] [ebp-108h]

  FS_CheckFileSystemStarted();
  FS_BuildOSPath(*(void **)(fs_homepath + 8), byte_848B6C0, a1, &file);
  if ( sub_80A13EE(&file, &stat_buf) == -1 )
    return 0;
  if ( a2 )
    v3 = stat_buf.st_mode & 0xFFFFFEFF;
  else
    v3 = stat_buf.st_mode | 0x100;
  stat_buf.st_mode = v3;
  return chmod(&file, v3) != -1;
}
// 848B7C4: using guessed type int fs_homepath;

//----- (0809E328) --------------------------------------------------------
signed int __cdecl FS_Read(int a1, unsigned int a2, int a3)
{
  FILE *stream; // [esp+20h] [ebp-18h]
  signed int v6; // [esp+24h] [ebp-14h]
  char *ptr; // [esp+28h] [ebp-10h]
  size_t v8; // [esp+2Ch] [ebp-Ch]
  size_t v9; // [esp+30h] [ebp-8h]

  FS_CheckFileSystemStarted();
  if ( !a3 )
    return 0;
  if ( dword_848B814[71 * a3] )
    return sub_80D0AA8(dword_848B800[71 * a3], a1, a2);
  stream = (FILE *)FS_FileForHandle(a3);
  ptr = (char *)a1;
  v9 = a2;
  v6 = 0;
  while ( 1 )
  {
    if ( !v9 )
      return a2;
    v8 = FS_FileRead(ptr, 1u, v9, stream);
    if ( !v8 )
    {
      if ( v6 )
        return a2 - v9;
      v6 = 1;
    }
    if ( v8 == -1 )
      break;
    v9 -= v8;
    ptr += v8;
  }
  if ( a3 <= 50 || a3 > 63 )
    Com_Error(0, &byte_814595B);
  return -1;
}
// 848B800: using guessed type int dword_848B800[];
// 848B814: using guessed type int dword_848B814[];

//----- (0809E454) --------------------------------------------------------
size_t __cdecl sub_809E454(char *a1, size_t a2, int a3)
{
  FILE *stream; // [esp+20h] [ebp-18h]
  signed int v6; // [esp+24h] [ebp-14h]
  char *ptr; // [esp+28h] [ebp-10h]
  size_t v8; // [esp+2Ch] [ebp-Ch]
  size_t v9; // [esp+30h] [ebp-8h]

  FS_CheckFileSystemStarted();
  if ( !a3 )
    return 0;
  stream = (FILE *)FS_FileForHandle(a3);
  ptr = a1;
  v9 = a2;
  v6 = 0;
  while ( v9 )
  {
    v8 = FS_FileWrite(ptr, 1u, v9, stream);
    if ( !v8 )
    {
      if ( v6 )
        return 0;
      v6 = 1;
    }
    if ( v8 == -1 )
      return 0;
    v9 -= v8;
    ptr += v8;
  }
  if ( dword_848B808[71 * a3] )
    fflush(stream);
  return a2;
}
// 848B808: using guessed type int dword_848B808[];

//----- (0809E52A) --------------------------------------------------------
size_t FS_Printf(int a1, char *format, ...)
{
  size_t v2; // eax
  char s; // [esp+10h] [ebp-1018h]
  __gnuc_va_list __varargs; // [esp+101Ch] [ebp-Ch]
  va_list va; // [esp+1038h] [ebp+10h]

  va_start(va, format);
  va_copy(__varargs, va);
  vsprintf(&s, format, va);
  v2 = I_strlen(&s);
  return sub_809E454(&s, v2, a1);
}

//----- (0809E580) --------------------------------------------------------
int __cdecl sub_809E580(int a1, int off, int a3)
{
  signed int v3; // eax
  int v4; // eax
  signed int v6; // [esp+10h] [ebp-18h]
  FILE *stream; // [esp+14h] [ebp-14h]
  unsigned int v8; // [esp+18h] [ebp-10h]
  signed int v9; // [esp+1Ch] [ebp-Ch]

  FS_CheckFileSystemStarted();
  if ( dword_848B818[71 * a1] )
  {
    dword_848B818[71 * a1] = 0;
    sub_80D2194(a1, off, a3);
    dword_848B818[71 * a1] = 1;
  }
  if ( !dword_848B814[71 * a1] )
  {
    stream = (FILE *)FS_FileForHandle(a1);
    if ( a3 == 1 )
      return FS_FileSeek(stream, off, 2);
    if ( a3 > 1 )
    {
      if ( a3 != 2 )
        return 0;
      v4 = FS_FileSeek(stream, off, 0);
    }
    else
    {
      if ( a3 )
        return 0;
      v4 = FS_FileSeek(stream, off, 1);
    }
    return v4;
  }
  if ( off || a3 != 2 )
  {
    if ( off || a3 )
    {
      v9 = sub_80D0D98(dword_848B800[71 * a1]);
      if ( a3 )
      {
        if ( a3 == 1 )
        {
          if ( off + FS_filelength(a1) >= v9 )
          {
            v8 = off + FS_filelength(a1) - v9;
          }
          else
          {
            unzSetCurrentFileInfoPosition(dword_848B800[71 * a1], dword_848B810[71 * a1]);
            unzOpenCurrentFile((_DWORD *)dword_848B800[71 * a1]);
            v8 = off + FS_filelength(a1);
          }
          v3 = sub_80D0AA8(dword_848B800[71 * a1], 0, v8);
        }
        else
        {
          if ( a3 != 2 )
            return -1;
          if ( off >= v9 )
          {
            v3 = sub_80D0AA8(dword_848B800[71 * a1], 0, off - v9);
          }
          else
          {
            unzSetCurrentFileInfoPosition(dword_848B800[71 * a1], dword_848B810[71 * a1]);
            unzOpenCurrentFile((_DWORD *)dword_848B800[71 * a1]);
            v3 = sub_80D0AA8(dword_848B800[71 * a1], 0, off);
          }
        }
      }
      else if ( off >= 0 )
      {
        v3 = sub_80D0AA8(dword_848B800[71 * a1], 0, off);
      }
      else
      {
        unzSetCurrentFileInfoPosition(dword_848B800[71 * a1], dword_848B810[71 * a1]);
        unzOpenCurrentFile((_DWORD *)dword_848B800[71 * a1]);
        v3 = sub_80D0AA8(dword_848B800[71 * a1], 0, v9 + off);
      }
      if ( v3 )
        v6 = 0;
      else
        v6 = -1;
    }
    else
    {
      v6 = 0;
    }
  }
  else
  {
    unzSetCurrentFileInfoPosition(dword_848B800[71 * a1], dword_848B810[71 * a1]);
    v6 = unzOpenCurrentFile((_DWORD *)dword_848B800[71 * a1]);
  }
  return v6;
}
// 848B800: using guessed type int dword_848B800[];
// 848B810: using guessed type int dword_848B810[];
// 848B814: using guessed type int dword_848B814[];

//----- (0809E892) --------------------------------------------------------
signed int __cdecl FS_ReadFile(_BYTE *a1, _DWORD *a2)
{
  _DWORD *v2; // ST20_4
  signed int v4; // [esp+18h] [ebp-10h]
  int v5; // [esp+1Ch] [ebp-Ch]
  int v6; // [esp+24h] [ebp-4h]

  FS_CheckFileSystemStarted();
  if ( !a1 || !*a1 )
    Com_Error(0, &byte_8145973);
  v5 = FS_FOpenFileRead((int)a1, &v6, 0);
  if ( v6 )
  {
    if ( a2 )
    {
      ++fs_loadStack;
      v2 = Hunk_AllocateTempMemory(v5 + 1);
      *a2 = v2;
      FS_Read((int)v2, v5, v6);
      *((_BYTE *)v2 + v5) = 0;
    }
    FS_FCloseFile(v6);
    v4 = v5;
  }
  else
  {
    if ( a2 )
      *a2 = 0;
    v4 = -1;
  }
  return v4;
}
// 848B6A4: using guessed type int fs_loadStack;

//----- (0809E970) --------------------------------------------------------
void Com_ResetParseSessions()
{
  fs_loadStack = 0;
}
// 848B6A4: using guessed type int fs_loadStack;

//----- (0809E980) --------------------------------------------------------
void __cdecl FS_FreeFile(void *ptr)
{
  FS_CheckFileSystemStarted();
  --fs_loadStack;
  sub_80AA0C8(ptr);
}
// 848B6A4: using guessed type int fs_loadStack;

//----- (0809E99E) --------------------------------------------------------
int __cdecl sub_809E99E(char *src, int a2, int a3)
{
  size_t v3; // ST10_4
  signed int v5; // [esp+Ch] [ebp-Ch]
  int v6; // [esp+14h] [ebp-4h]

  FS_CheckFileSystemStarted();
  v6 = FS_FOpenFileWrite(src);
  if ( v6 )
  {
    v3 = sub_809E454((char *)a2, a3, v6);
    FS_FCloseFile(v6);
    if ( v3 == a3 )
    {
      v5 = 1;
    }
    else
    {
      sub_809E1DA(src);
      v5 = 0;
    }
  }
  else
  {
    Com_Printf("Failed to open %s\n", src);
    v5 = 0;
  }
  return v5;
}

//----- (0809EA28) --------------------------------------------------------
int __cdecl sub_809EA28(int a1, char *filename)
{
  FILE *stream; // [esp+24h] [ebp-114h]
  void **i; // [esp+2Ch] [ebp-10Ch]
  char v6; // [esp+30h] [ebp-108h]

  if ( !(unsigned __int8)FS_SanitizeFilename(a1, (int)&v6) )
    return -1;
  for ( i = (void **)fs_searchpaths; i; i = (void **)*i )
  {
    if ( FS_UseSearchPath((int)i) && !i[1] )
    {
      FS_BuildOSPath_Internal(i[2], (char *)i[2] + 256, &v6, filename, 0);
      stream = FS_FileOpen(filename, "rb");
      if ( stream )
      {
        FS_FileClose(stream);
        return 0;
      }
    }
  }
  return -1;
}

//----- (0809EB4A) --------------------------------------------------------
int sub_809EB4A()
{
  return 0;
}

//----- (0809EB54) --------------------------------------------------------
char *__cdecl FS_LoadZipFile(char *filename, char *a2)
{
  size_t v2; // eax
  char *v3; // ebx
  int v4; // ST34_4
  char *v5; // ebx
  char *v6; // ebx
  int v7; // eax
  char *v8; // ebx
  char *v9; // ebx
  int v12; // [esp+28h] [ebp-190h]
  _DWORD *ptr; // [esp+2Ch] [ebp-18Ch]
  int v14; // [esp+30h] [ebp-188h]
  int v15; // [esp+38h] [ebp-180h]
  unsigned int i; // [esp+3Ch] [ebp-17Ch]
  unsigned int j; // [esp+3Ch] [ebp-17Ch]
  int k; // [esp+3Ch] [ebp-17Ch]
  unsigned int l; // [esp+3Ch] [ebp-17Ch]
  int v20; // [esp+40h] [ebp-178h]
  int v21; // [esp+54h] [ebp-164h]
  int v22; // [esp+5Ch] [ebp-15Ch]
  char src; // [esp+90h] [ebp-128h]
  unsigned int v24; // [esp+198h] [ebp-20h]
  int v25; // [esp+1A0h] [ebp-18h]
  int v26; // [esp+1A4h] [ebp-14h]
  char *dest; // [esp+1A8h] [ebp-10h]
  _DWORD *v28; // [esp+1ACh] [ebp-Ch]

  v14 = 0;
  v26 = (int)unzOpen(filename);
  v25 = unzGetGlobalInfo(v26, &v24);
  if ( v25 )
    return 0;
  *(_DWORD *)fs_packFiles += v24;
  v15 = 0;
  unzGoToFirstFile((_DWORD *)v26);
  for ( i = 0; i < v24; ++i )
  {
    v25 = unzGetCurrentFileInfo(v26, (int)&v20, &src, 256, 0, 0, 0, 0);
    if ( v25 )
      break;
    v15 += I_strlen(&src) + 1;
    unzGoToNextFile((_DWORD *)v26);
  }
  v28 = Z_MallocInternal(v15 + 12 * v24);
  v12 = (int)&v28[3 * v24];
  ptr = Z_MallocInternal(4 * v24);
  for ( j = 1; (signed int)j <= 1024 && j <= v24; j *= 2 )
    ;
  dest = (char *)Z_MallocInternal(4 * j + 800);
  *((_DWORD *)dest + 197) = j;
  *((_DWORD *)dest + 198) = dest + 800;
  for ( k = 0; k < *((_DWORD *)dest + 197); ++k )
    *(_DWORD *)(*((_DWORD *)dest + 198) + 4 * k) = 0;
  I_strncpyz(dest, filename, 256);
  I_strncpyz(dest + 256, a2, 256);
  if ( strlen(dest + 256) > 4 )
  {
    v2 = strlen(dest + 256);
    if ( !I_stricmp(&dest[v2 + 252], ".iwd") )
    {
      v3 = dest;
      v3[strlen(dest + 256) + 252] = 0;
    }
  }
  *((_DWORD *)dest + 192) = v26;
  *((_DWORD *)dest + 195) = v24;
  unzGoToFirstFile((_DWORD *)v26);
  for ( l = 0; l < v24; ++l )
  {
    v25 = unzGetCurrentFileInfo(v26, (int)&v20, &src, 256, 0, 0, 0, 0);
    if ( v25 )
      break;
    if ( v22 )
      ptr[v14++] = LittleLong(v21);
    sub_80B573C(&src);
    v4 = FS_HashFileName((int)&src, *((_DWORD *)dest + 197));
    v28[3 * l + 1] = v12;
    strcpy((char *)v28[3 * l + 1], &src);
    v12 += strlen(&src) + 1;
    sub_80D0417(v26, &v28[3 * l]);
    v28[3 * l + 2] = *(_DWORD *)(*((_DWORD *)dest + 198) + 4 * v4);
    *(_DWORD *)(*((_DWORD *)dest + 198) + 4 * v4) = &v28[3 * l];
    unzGoToNextFile((_DWORD *)v26);
  }
  v5 = dest;
  *((_DWORD *)v5 + 193) = sub_8067642(ptr, 4 * v14);
  v6 = dest;
  v7 = LittleLong(fs_checksumFeed);
  *((_DWORD *)v6 + 194) = sub_806769E(ptr, 4 * v14, v7);
  v8 = dest;
  *((_DWORD *)v8 + 193) = LittleLong(*((_DWORD *)dest + 193));
  v9 = dest;
  *((_DWORD *)v9 + 194) = LittleLong(*((_DWORD *)dest + 194));
  Z_FreeInternal(ptr);
  *((_DWORD *)dest + 199) = v28;
  return dest;
}
// 848B7F4: using guessed type int fs_checksumFeed;

//----- (0809F09C) --------------------------------------------------------
int __cdecl sub_809F09C(char *src, char *dest, int a3)
{
  int v4; // [esp+Ch] [ebp-Ch]
  int i; // [esp+10h] [ebp-8h]
  int v6; // [esp+14h] [ebp-4h]

  v4 = 0;
  *dest = 0;
  v6 = 0;
  for ( i = 0; src[i]; ++i )
  {
    if ( src[i] == 47 || src[i] == 92 )
    {
      v6 = i;
      ++v4;
    }
  }
  strcpy(dest, src);
  dest[v6] = 0;
  if ( v6 + 1 == i )
    --v4;
  *(_DWORD *)a3 = v4;
  return v6;
}

//----- (0809F12A) --------------------------------------------------------
int __cdecl sub_809F12A(char *src, int a2, int a3)
{
  int i; // [esp+14h] [ebp-4h]

  if ( a3 == 4095 )
    return 4095;
  for ( i = 0; i < a3; ++i )
  {
    if ( !I_stricmp(src, *(char **)(a2 + 4 * i)) )
      return a3;
  }
  *(_DWORD *)(a2 + 4 * a3) = sub_80A93B0(src);
  return a3 + 1;
}

//----- (0809F1B2) --------------------------------------------------------
_DWORD *__cdecl FS_ListFilteredFiles(int a1, int a2, char *a3, int a4, int a5, int a6)
{
  size_t v6; // eax
  char name; // [esp+30h] [ebp-4398h]
  char v10; // [esp+12Fh] [ebp-4299h]
  char dest; // [esp+130h] [ebp-4298h]
  int v12; // [esp+170h] [ebp-4258h]
  void *ptr; // [esp+174h] [ebp-4254h]
  char *s; // [esp+178h] [ebp-4250h]
  bool v15; // [esp+17Fh] [ebp-4249h]
  char src; // [esp+180h] [ebp-4248h]
  char v17; // [esp+280h] [ebp-4148h]
  int v18; // [esp+38Ch] [ebp-403Ch]
  int v19; // [esp+390h] [ebp-4038h]
  int v20; // [esp+394h] [ebp-4034h]
  int v21; // [esp+398h] [ebp-4030h]
  int v22; // [esp+39Ch] [ebp-402Ch]
  int v23; // [esp+3A0h] [ebp-4028h]
  int v24; // [esp+3A4h] [ebp-4024h]
  int j; // [esp+3A8h] [ebp-4020h]
  int i; // [esp+3ACh] [ebp-401Ch]
  int v27[4098]; // [esp+3B0h] [ebp-4018h]
  _DWORD *v28; // [esp+43B8h] [ebp-10h]
  int v29; // [esp+43BCh] [ebp-Ch]

  FS_CheckFileSystemStarted();
  if ( !a2 )
  {
    *(_DWORD *)a6 = 0;
    return 0;
  }
  if ( !a3 )
    a3 = &byte_8145895;
  if ( !(unsigned __int8)FS_SanitizeFilename(a2, (int)&src) )
  {
    *(_DWORD *)a6 = 0;
    return 0;
  }
  v15 = I_stricmp(a3, "/") == 0;
  v24 = I_strlen(&src);
  if ( v24 && (*(&v15 + v24) == 92 || *(&v15 + v24) == 47) )
    --v24;
  v23 = I_strlen(a3);
  v29 = 0;
  sub_809F09C(&src, &v17, (int)&v21);
  if ( src )
    ++v21;
  for ( i = a1; i; i = *(_DWORD *)i )
  {
    if ( FS_UseSearchPath(i) )
    {
      if ( *(_DWORD *)(i + 4) )
      {
        if ( *(_DWORD *)(i + 12) || FS_IwdIsPure(*(_DWORD *)(i + 4)) )
        {
          v19 = *(_DWORD *)(i + 4);
          v18 = *(_DWORD *)(v19 + 796);
          for ( j = 0; ; ++j )
          {
            if ( j >= *(_DWORD *)(v19 + 780) )
              break;
            s = *(char **)(v18 + 12 * j + 4);
            if ( a4 )
            {
              if ( (unsigned __int8)sub_80AA618(a4, (int)s, 0) )
                v29 = sub_809F12A(s, (int)v27, v29);
            }
            else
            {
              ptr = (void *)sub_809F09C(s, &v17, (int)&v12);
              if ( v12 == v21 && v24 <= (signed int)ptr && (v24 <= 0 || s[v24] == 47) && !sub_80B550A(s, &src, v24) )
              {
                if ( v15 )
                {
                  v6 = strlen(s);
                  if ( s[v6 - 1] != 47 )
                    continue;
                }
                else if ( v23 )
                {
                  v22 = I_strlen(s);
                  if ( v22 <= v23 || s[v22 - v23 - 1] != 46 || I_stricmp(&s[v22 - v23], a3) )
                    continue;
                }
                v20 = v24;
                if ( v24 )
                  ++v20;
                if ( v15 )
                {
                  strcpy(&dest, &s[v20]);
                  *(&v10 + strlen(&dest)) = 0;
                  v29 = sub_809F12A(&dest, (int)v27, v29);
                }
                else
                {
                  v29 = sub_809F12A(&s[v20], (int)v27, v29);
                }
              }
            }
          }
        }
      }
      else if ( *(_DWORD *)(i + 8) && (!*(_BYTE *)(fs_restrict + 8) && !fs_numServerIwds || a5) )
      {
        FS_BuildOSPath(*(void **)(i + 8), (char *)(*(_DWORD *)(i + 8) + 256), &src, &name);
        ptr = Sys_ListFiles(&name, a3, a4, (int)&v12, v15);
        for ( j = 0; j < v12; ++j )
        {
          s = (char *)*((_DWORD *)ptr + j);
          v29 = sub_809F12A(s, (int)v27, v29);
        }
        Sys_FreeFileList(ptr);
      }
    }
  }
  *(_DWORD *)a6 = v29;
  if ( !v29 )
    return 0;
  v28 = Z_MallocInternal(4 * v29 + 4);
  for ( j = 0; j < v29; ++j )
    v28[j] = v27[j];
  v28[j] = 0;
  return v28;
}
// 848B7E0: using guessed type int fs_restrict;
// 848FF00: using guessed type int fs_numServerIwds;
// 809F1B2: using guessed type int var_4018[4098];

//----- (0809F7B2) --------------------------------------------------------
_DWORD *__cdecl sub_809F7B2(int a1, char *a2, int a3, int a4)
{
  return FS_ListFilteredFiles((int)fs_searchpaths, a1, a2, 0, a3, a4);
}

//----- (0809F7F2) --------------------------------------------------------
_DWORD *__cdecl sub_809F7F2(int a1, char *a2, int a3, int a4, int a5)
{
  return sub_809F98A(a1, a2, 0, a3, a4, a5);
}

//----- (0809F830) --------------------------------------------------------
_BOOL4 __cdecl sub_809F830(char *a1, int a2)
{
  if ( a2 == 63 )
    return 1;
  if ( a2 & 1 && !I_strncmp(a1, "main", 4) )
    return 1;
  if ( a2 & 2 && !I_strncmp(a1, "dev", 3) )
    return 1;
  if ( a2 & 4 && !I_strncmp(a1, "temp", 4) )
    return 1;
  if ( a2 & 8 && !I_strncmp(a1, "raw", 3) )
    return 1;
  if ( !(a2 & 0x10) || I_strncmp(a1, "raw_shared", 10) )
    return a2 & 0x20 && !I_strncmp(a1, "devraw", 6);
  return 1;
}

//----- (0809F98A) --------------------------------------------------------
_DWORD *__cdecl sub_809F98A(int a1, char *a2, int a3, int a4, int a5, int a6)
{
  bool v6; // al
  void **v7; // ST24_4
  void **v9; // [esp+24h] [ebp-14h]
  void **ptr; // [esp+28h] [ebp-10h]
  _DWORD *i; // [esp+2Ch] [ebp-Ch]
  _DWORD *v12; // [esp+30h] [ebp-8h]

  ptr = 0;
  v9 = 0;
  for ( i = fs_searchpaths; i; i = (_DWORD *)*i )
  {
    if ( i[2] )
    {
      v6 = sub_809F830((char *)(i[2] + 256), a6);
    }
    else if ( i[1] )
    {
      v6 = sub_809F830((char *)(i[1] + 512), a6);
    }
    else
    {
      v6 = sub_809F830(0, a6);
    }
    if ( v6 )
    {
      if ( ptr )
      {
        *v9 = Z_MallocInternal(0x14u);
        v9 = (void **)*v9;
      }
      else
      {
        ptr = (void **)Z_MallocInternal(0x14u);
        v9 = ptr;
      }
      *v9 = 0;
      v9[2] = (void *)i[2];
      v9[4] = (void *)i[4];
      v9[3] = (void *)i[3];
      v9[1] = (void *)i[1];
    }
  }
  v12 = FS_ListFilteredFiles((int)ptr, a1, a2, a3, a4, a5);
  while ( ptr )
  {
    v7 = (void **)*ptr;
    Z_FreeInternal(ptr);
    ptr = v7;
  }
  return v12;
}

//----- (0809FAE4) --------------------------------------------------------
void __cdecl FS_FreeFileList(void *ptr)
{
  int i; // [esp+4h] [ebp-4h]

  FS_CheckFileSystemStarted();
  if ( ptr )
  {
    for ( i = 0; *((_DWORD *)ptr + i); ++i )
      Z_FreeInternal(*((void **)ptr + i));
    Z_FreeInternal(ptr);
  }
}

//----- (0809FB40) --------------------------------------------------------
int __cdecl FS_GetFileList(int a1, char *a2, int a3, char *dest, int a5)
{
  _DWORD *ptr; // [esp+24h] [ebp-14h]
  size_t v8; // [esp+28h] [ebp-10h]
  int v9; // [esp+2Ch] [ebp-Ch]
  int i; // [esp+30h] [ebp-8h]
  int v11; // [esp+34h] [ebp-4h]

  *dest = 0;
  v11 = 0;
  v9 = 0;
  if ( !I_stricmp((char *)a1, "$modlist") )
    return FS_GetModList(dest, a5);
  ptr = sub_809F7B2(a1, a2, a3, (int)&v11);
  for ( i = 0; i < v11; ++i )
  {
    v8 = I_strlen((char *)ptr[i]) + 1;
    if ( (signed int)(v9 + v8 + 1) >= a5 )
    {
      v11 = i;
      break;
    }
    strcpy(dest, (const char *)ptr[i]);
    dest += v8;
    v9 += v8;
  }
  FS_FreeFileList(ptr);
  return v11;
}

//----- (0809FC4E) --------------------------------------------------------
_BYTE *__cdecl FS_ConvertPath(_BYTE *a1)
{
  _BYTE *result; // eax

  while ( 1 )
  {
    result = a1;
    if ( !*a1 )
      break;
    if ( *a1 == 92 || *a1 == 58 )
      *a1 = 47;
    ++a1;
  }
  return result;
}

//----- (0809FC7C) --------------------------------------------------------
signed int __cdecl FS_PathCmp(char *a1, char *a2)
{
  signed int v4; // [esp+10h] [ebp-8h]
  signed int v5; // [esp+14h] [ebp-4h]

  do
  {
    v5 = *a1++;
    v4 = *a2++;
    if ( (unsigned __int8)sub_80B53C8(v5) )
      v5 -= 32;
    if ( (unsigned __int8)sub_80B53C8(v4) )
      v4 -= 32;
    if ( v5 == 92 || v5 == 58 )
      v5 = 47;
    if ( v4 == 92 || v4 == 58 )
      v4 = 47;
    if ( v5 < v4 )
      return -1;
    if ( v5 > v4 )
      return 1;
  }
  while ( v5 );
  return 0;
}

//----- (0809FD2A) --------------------------------------------------------
void __cdecl FS_SortFileList(void *dest, int a2)
{
  _DWORD *ptr; // [esp+10h] [ebp-18h]
  int v3; // [esp+14h] [ebp-14h]
  int k; // [esp+18h] [ebp-10h]
  int j; // [esp+1Ch] [ebp-Ch]
  int i; // [esp+20h] [ebp-8h]

  ptr = Z_MallocInternal(4 * a2 + 4);
  *ptr = 0;
  v3 = 0;
  for ( i = 0; i < a2; ++i )
  {
    for ( j = 0; j < v3 && FS_PathCmp(*((char **)dest + i), (char *)ptr[j]) >= 0; ++j )
      ;
    for ( k = v3; k > j; --k )
      ptr[k] = ptr[k - 1];
    ptr[j] = *((_DWORD *)dest + i);
    ++v3;
  }
  Com_Memcpy(dest, ptr, 4 * a2);
  Z_FreeInternal(ptr);
}

//----- (0809FE44) --------------------------------------------------------
void __cdecl FS_DisplayPath(int a1)
{
  char v1[4]; // [esp+10h] [ebp-8h]
  int *i; // [esp+14h] [ebp-4h]

  if ( *(_BYTE *)(fs_ignoreLocalized + 8) )
    Com_Printf("    localized assets are being ignored\n");
  Com_Printf("Current search path:\n");
  for ( i = (int *)fs_searchpaths; i; i = (int *)*i )
  {
    if ( !a1 || FS_UseSearchPath((int)i) )
    {
      if ( i[1] )
      {
        Com_Printf("%s (%i files)\n", i[1], *(_DWORD *)(i[1] + 780));
        if ( fs_numServerIwds )
        {
          if ( FS_IwdIsPure(i[1]) )
            Com_Printf("    on the pure list\n");
          else
            Com_Printf("    not on the pure list\n");
        }
      }
      else
      {
        Com_Printf("%s/%s\n", i[2], i[2] + 256);
      }
    }
  }
  Com_Printf("\nFile Handles:\n");
  for ( *(_DWORD *)v1 = 1; *(_DWORD *)v1 <= 63; ++*(_DWORD *)v1 )
  {
    if ( dword_848B800[71 * *(_DWORD *)v1] )
      Com_Printf("handle %i: %s\n", *(_DWORD *)v1, 284 * *(_DWORD *)v1 + 138983452);
  }
}
// 848B7E4: using guessed type int fs_ignoreLocalized;
// 848B800: using guessed type int dword_848B800[];
// 848FF00: using guessed type int fs_numServerIwds;

//----- (0809FF8E) --------------------------------------------------------
void FS_FullPath_f()
{
  FS_DisplayPath(0);
}

//----- (0809FFA2) --------------------------------------------------------
void FS_Path_f()
{
  FS_DisplayPath(0);
}

//----- (0809FFB6) --------------------------------------------------------
int __cdecl IwdFileLanguage(char *s)
{
  signed int v2; // [esp+14h] [ebp-4h]

  dword_84941C0 ^= 1u;
  if ( strlen(s) > 9 )
  {
    v2 = 10;
    memset((void *)((dword_84941C0 << 6) + 139018560), 0, 0x40u);
    while ( v2 <= 63 && s[v2] && *(_WORD *)(_ctype_b + 2 * s[v2]) & 0x400 )
    {
      *((_BYTE *)&unk_8494136 + 64 * dword_84941C0 + v2) = s[v2];
      ++v2;
    }
  }
  else
  {
    byte_8494140[64 * dword_84941C0] = 0;
  }
  return (dword_84941C0 << 6) + 139018560;
}
// 8185A64: using guessed type int _ctype_b;
// 84941C0: using guessed type int dword_84941C0;

//----- (080A0076) --------------------------------------------------------
int __cdecl iwdsort(const void *a1, const void *a2)
{
  char *v2; // ST1C_4
  char *v5; // [esp+18h] [ebp-10h]
  char *v6; // [esp+20h] [ebp-8h]
  char *s; // [esp+24h] [ebp-4h]

  s = *(char **)a1;
  v6 = *(char **)a2;
  if ( I_strncmp(*(char **)a1, "          ", 10) || I_strncmp(v6, "          ", 10) )
    return FS_PathCmp(s, v6);
  v2 = (char *)IwdFileLanguage(s);
  v5 = (char *)IwdFileLanguage(v6);
  if ( I_stricmp(v2, "english") )
  {
    if ( !I_stricmp(v5, "english") )
      return 1;
    return FS_PathCmp(s, v6);
  }
  if ( !I_stricmp(v5, "english") )
    return FS_PathCmp(s, v6);
  return -1;
}

//----- (080A015C) --------------------------------------------------------
void **__cdecl FS_AddSearchPath(void **a1)
{
  void **result; // eax
  void **v2; // [esp+0h] [ebp-4h]

  v2 = &fs_searchpaths;
  if ( a1[3] )
  {
    while ( *v2 && !*((_DWORD *)*v2 + 3) )
      v2 = (void **)*v2;
  }
  *a1 = *v2;
  result = a1;
  *v2 = a1;
  return result;
}

//----- (080A01A4) --------------------------------------------------------
void __cdecl FS_AddIwdFilesForGameDirectory(void *a1, char *src)
{
  void **v2; // ST24_4
  char *v3; // [esp+20h] [ebp-1128h]
  char *v4; // [esp+28h] [ebp-1120h]
  _DWORD *ptr; // [esp+2Ch] [ebp-111Ch]
  void *dest[1024]; // [esp+30h] [ebp-1118h]
  void *_102F[1024]; // [esp+102Fh] [ebp-119h]
  char s; // [esp+1030h] [ebp-118h]
  void *v9; // [esp+1130h] [ebp-18h]
  size_t nmemb; // [esp+1134h] [ebp-14h]
  void *v11; // [esp+1138h] [ebp-10h]
  int i; // [esp+113Ch] [ebp-Ch]

  FS_BuildOSPath(a1, src, &byte_8145895, &s);
  *((_BYTE *)_102F + strlen(&s)) = 0;
  ptr = Sys_ListFiles(&s, "iwd", 0, (int)&nmemb, 0);
  if ( (signed int)nmemb > 1024 )
  {
    Com_Printf("WARNING: Exceeded max number of iwd files in %s/%s (%1/%1)\n", a1, src, nmemb, 1024);
    nmemb = 1024;
  }
  for ( i = 0; i < (signed int)nmemb; ++i )
  {
    dest[i] = (void *)ptr[i];
    if ( !I_strncmp((char *)dest[i], "localized_", 10) )
      memcpy(dest[i], "          ", 0xAu);
  }
  qsort(dest, nmemb, 4u, iwdsort);
  for ( i = 0; i < (signed int)nmemb; ++i )
  {
    if ( I_strncmp((char *)dest[i], "          ", 10) )
    {
      v9 = 0;
      v11 = 0;
LABEL_16:
      FS_BuildOSPath(a1, src, (char *)dest[i], &s);
      v3 = FS_LoadZipFile(&s, (char *)dest[i]);
      if ( v3 )
      {
        strcpy(v3 + 512, src);
        v2 = (void **)Z_MallocInternal(0x14u);
        v2[1] = v3;
        v2[3] = v9;
        v2[4] = v11;
        FS_AddSearchPath(v2);
      }
      continue;
    }
    memcpy(dest[i], "localized_", 0xAu);
    v9 = (void *)1;
    v4 = (char *)IwdFileLanguage((char *)dest[i]);
    if ( !*v4 )
    {
      Com_Printf(
        "WARNING: Localized assets iwd file %s/%s/%s has invalid name (no language specified). Proper naming convention i"
        "s: localized_[language]_iwd#.iwd\n",
        a1,
        src,
        dest[i]);
      continue;
    }
    if ( !I_stricmp(v4, "english") )
    {
      v11 = 0;
      goto LABEL_16;
    }
  }
  Sys_FreeFileList(ptr);
}

//----- (080A04B4) --------------------------------------------------------
void __cdecl FS_AddGameDirectoryInternal(char *a1, char *src, int a3, int a4)
{
  char **v4; // ebx
  const char *v5; // [esp+2Ch] [ebp-15Ch]
  char s; // [esp+30h] [ebp-158h]
  char **v7; // [esp+134h] [ebp-54h]
  void *i; // [esp+138h] [ebp-50h]
  const char *v9; // [esp+13Ch] [ebp-4Ch]
  char dest; // [esp+140h] [ebp-48h]

  if ( a3 )
  {
    v9 = "english";
    Com_sprintf(&dest, 0x40u, "%s/%s", src, "english");
  }
  else
  {
    I_strncpyz(&dest, src, 64);
  }
  for ( i = fs_searchpaths; i; i = *(void **)i )
  {
    if ( *((_DWORD *)i + 2)
      && !I_stricmp(*((char **)i + 2), a1)
      && !I_stricmp((char *)(*((_DWORD *)i + 2) + 256), &dest) )
    {
      if ( *((_DWORD *)i + 3) != a3 )
      {
        if ( *((_DWORD *)i + 3) )
          v5 = "localized";
        else
          v5 = "non-localized";
        Com_Printf(
          "WARNING: game folder %s/%s added as both localized & non-localized. Using folder as %s\n",
          a1,
          &dest,
          v5);
      }
      if ( *((_DWORD *)i + 3) )
      {
        if ( *((_DWORD *)i + 4) != a4 )
          Com_Printf("WARNING: game golder %s/%s re-added as localized folder with different language\n", a1, &dest);
      }
      return;
    }
  }
  if ( a3 )
  {
    FS_BuildOSPath(a1, &dest, &byte_8145895, &s);
    *((_BYTE *)&v5 + strlen(&s) + 3) = 0;
    if ( !sub_80D416A(&s) )
      return;
  }
  else
  {
    I_strncpyz(byte_848B6C0, &dest, 256);
  }
  v7 = (char **)Z_MallocInternal(0x14u);
  v4 = v7;
  v4[2] = (char *)Z_MallocInternal(0x200u);
  I_strncpyz(v7[2], a1, 256);
  I_strncpyz(v7[2] + 256, &dest, 256);
  v7[3] = (char *)a3;
  v7[4] = (char *)a4;
  FS_AddSearchPath((void **)v7);
  FS_AddIwdFilesForGameDirectory(a1, &dest);
}

//----- (080A0710) --------------------------------------------------------
void __cdecl FS_AddGameDirectory(char *a1, char *src)
{
  FS_AddGameDirectoryInternal(a1, src, 1, 0);
  FS_AddGameDirectoryInternal(a1, src, 0, 0);
}

//----- (080A075C) --------------------------------------------------------
void *__cdecl FS_ShutdownSearchPaths(void *ptr)
{
  void *result; // eax
  void *v2; // [esp+4h] [ebp-4h]

  while ( ptr )
  {
    v2 = *(void **)ptr;
    if ( *((_DWORD *)ptr + 1) )
    {
      sub_80CFC62(*(_DWORD *)(*((_DWORD *)ptr + 1) + 768));
      Z_FreeInternal(*(void **)(*((_DWORD *)ptr + 1) + 796));
      Z_FreeInternal(*((void **)ptr + 1));
    }
    if ( *((_DWORD *)ptr + 2) )
      Z_FreeInternal(*((void **)ptr + 2));
    Z_FreeInternal(ptr);
    result = v2;
    ptr = v2;
  }
  return result;
}

//----- (080A07DE) --------------------------------------------------------
int FS_ShutdownServerIwdNames()
{
  int result; // eax
  int i; // [esp+4h] [ebp-4h]

  for ( i = 0; ; ++i )
  {
    result = i;
    if ( i >= fs_numServerIwds )
      break;
    if ( dword_8490F20[i] )
      Z_FreeInternal(dword_8490F20[i]);
    dword_8490F20[i] = 0;
  }
  fs_numServerIwds = 0;
  return result;
}
// 848FF00: using guessed type int fs_numServerIwds;

//----- (080A0838) --------------------------------------------------------
int FS_ShutdownServerReferencedIwds()
{
  int result; // eax
  int i; // [esp+4h] [ebp-4h]

  for ( i = 0; ; ++i )
  {
    result = i;
    if ( i >= dword_8491F20 )
      break;
    if ( dword_8492F40[i] )
      Z_FreeInternal(dword_8492F40[i]);
    dword_8492F40[i] = 0;
  }
  dword_8491F20 = 0;
  return result;
}
// 8491F20: using guessed type int dword_8491F20;

//----- (080A0892) --------------------------------------------------------
void FS_Shutdown()
{
  int i; // [esp+4h] [ebp-4h]

  for ( i = 1; i <= 63; ++i )
  {
    if ( dword_848B80C[71 * i] )
      FS_FCloseFile(i);
  }
  FS_ShutdownSearchPaths(fs_searchpaths);
  fs_searchpaths = 0;
  Cmd_RemoveCommand("path");
  Cmd_RemoveCommand("fullpath");
  Cmd_RemoveCommand("dir");
  Cmd_RemoveCommand("fdir");
  Cmd_RemoveCommand("touchFile");
}
// 848B80C: using guessed type int dword_848B80C[];

//----- (080A0920) --------------------------------------------------------
signed int __usercall FS_RegisterDvars@<eax>(long double a1@<st0>)
{
  char *v1; // eax
  char *v2; // eax
  char *v5; // [esp+24h] [ebp-4h]

  if ( fs_debug )
    return 0;
  fs_debug = (int)Dvar_RegisterInt(a1, "fs_debug", 0, 0, 2, 4096);
  fs_copyfiles = (int)Dvar_RegisterBool(a1, "fs_copyfiles", 0, 4112);
  v1 = Sys_DefaultCDPath();
  fs_cdpath = (int)Dvar_RegisterString(a1, "fs_cdpath", (int)v1, 4112);
  v2 = Sys_DefaultInstallPath();
  fs_basepath = (int)Dvar_RegisterString(a1, "fs_basepath", (int)v2, 4112);
  fs_basegame = (int)Dvar_RegisterString(a1, "fs_basegame", (int)&byte_8145895, 4112);
  fs_useOldAssets = (int)Dvar_RegisterBool(a1, "fs_useOldAssets", 0, 4096);
  v5 = Sys_DefaultHomePath();
  if ( !v5 || !*v5 )
    v5 = *(char **)(fs_basepath + 8);
  fs_homepath = (int)Dvar_RegisterString(a1, "fs_homepath", (int)v5, 4112);
  fs_gameDirVar = (int)Dvar_RegisterString(a1, "fs_game", (int)&byte_8145895, 4124);
  fs_restrict = (int)Dvar_RegisterBool(a1, "fs_restrict", 0, 4112);
  fs_ignoreLocalized = (int)Dvar_RegisterBool(a1, "fs_ignoreLocalized", 0, 4256);
  return 1;
}
// 848B7C0: using guessed type int fs_debug;
// 848B7C4: using guessed type int fs_homepath;
// 848B7CC: using guessed type int fs_basegame;
// 848B7D0: using guessed type int fs_useOldAssets;
// 848B7D4: using guessed type int fs_cdpath;
// 848B7D8: using guessed type int fs_copyfiles;
// 848B7E0: using guessed type int fs_restrict;
// 848B7E4: using guessed type int fs_ignoreLocalized;

//----- (080A0AC4) --------------------------------------------------------
void __usercall FS_Startup(long double a1@<st0>, char *src)
{
  Com_Printf("----- FS_Startup -----\n");
  *(_DWORD *)fs_packFiles = 0;
  FS_RegisterDvars(a1);
  if ( *(_BYTE *)(fs_useOldAssets + 8) )
  {
    if ( **(_BYTE **)(fs_basepath + 8) )
      FS_AddGameDirectory(*(char **)(fs_basepath + 8), "tempcod");
    if ( **(_BYTE **)(fs_homepath + 8) )
      FS_AddGameDirectory(*(char **)(fs_homepath + 8), "tempcod");
  }
  if ( **(_BYTE **)(fs_basepath + 8) )
  {
    FS_AddGameDirectory(*(char **)(fs_basepath + 8), "devraw_shared");
    FS_AddGameDirectory(*(char **)(fs_basepath + 8), "devraw");
    FS_AddGameDirectory(*(char **)(fs_basepath + 8), "raw_shared");
    FS_AddGameDirectory(*(char **)(fs_basepath + 8), "raw");
  }
  if ( **(_BYTE **)(fs_homepath + 8) )
  {
    FS_AddGameDirectory(*(char **)(fs_homepath + 8), "devraw_shared");
    FS_AddGameDirectory(*(char **)(fs_homepath + 8), "devraw");
    FS_AddGameDirectory(*(char **)(fs_homepath + 8), "raw_shared");
    FS_AddGameDirectory(*(char **)(fs_homepath + 8), "raw");
  }
  if ( **(_BYTE **)(fs_cdpath + 8) )
  {
    FS_AddGameDirectory(*(char **)(fs_cdpath + 8), "devraw_shared");
    FS_AddGameDirectory(*(char **)(fs_cdpath + 8), "devraw");
    FS_AddGameDirectory(*(char **)(fs_cdpath + 8), "raw_shared");
    FS_AddGameDirectory(*(char **)(fs_cdpath + 8), "raw");
    FS_AddGameDirectory(*(char **)(fs_cdpath + 8), src);
  }
  if ( **(_BYTE **)(fs_basepath + 8) )
    FS_AddGameDirectory(*(char **)(fs_basepath + 8), src);
  if ( **(_BYTE **)(fs_basepath + 8) && I_stricmp(*(char **)(fs_homepath + 8), *(char **)(fs_basepath + 8)) )
    FS_AddGameDirectory(*(char **)(fs_homepath + 8), src);
  if ( **(_BYTE **)(fs_basegame + 8) && !I_stricmp(src, "main") && I_stricmp(*(char **)(fs_basegame + 8), src) )
  {
    if ( **(_BYTE **)(fs_cdpath + 8) )
      FS_AddGameDirectory(*(char **)(fs_cdpath + 8), *(char **)(fs_basegame + 8));
    if ( **(_BYTE **)(fs_basepath + 8) )
      FS_AddGameDirectory(*(char **)(fs_basepath + 8), *(char **)(fs_basegame + 8));
    if ( **(_BYTE **)(fs_homepath + 8) && I_stricmp(*(char **)(fs_homepath + 8), *(char **)(fs_basepath + 8)) )
      FS_AddGameDirectory(*(char **)(fs_homepath + 8), *(char **)(fs_basegame + 8));
  }
  if ( **(_BYTE **)(fs_gameDirVar + 8) && !I_stricmp(src, "main") && I_stricmp(*(char **)(fs_gameDirVar + 8), src) )
  {
    if ( **(_BYTE **)(fs_cdpath + 8) )
      FS_AddGameDirectory(*(char **)(fs_cdpath + 8), *(char **)(fs_gameDirVar + 8));
    if ( **(_BYTE **)(fs_basepath + 8) )
      FS_AddGameDirectory(*(char **)(fs_basepath + 8), *(char **)(fs_gameDirVar + 8));
    if ( **(_BYTE **)(fs_homepath + 8) && I_stricmp(*(char **)(fs_homepath + 8), *(char **)(fs_basepath + 8)) )
      FS_AddGameDirectory(*(char **)(fs_homepath + 8), *(char **)(fs_gameDirVar + 8));
  }
  FS_AddCommands();
  FS_Path_f();
  Dvar_ClearModified(fs_gameDirVar);
  Com_Printf("----------------------\n");
  Com_Printf("%d files in iwd files\n", *(_DWORD *)fs_packFiles);
}
// 848B7C4: using guessed type int fs_homepath;
// 848B7CC: using guessed type int fs_basegame;
// 848B7D0: using guessed type int fs_useOldAssets;
// 848B7D4: using guessed type int fs_cdpath;

//----- (080A0F06) --------------------------------------------------------
_DWORD *FS_ClearIwdReferences()
{
  _DWORD *result; // eax
  _DWORD *i; // [esp+0h] [ebp-4h]

  result = fs_searchpaths;
  for ( i = fs_searchpaths; i; i = (_DWORD *)*i )
  {
    if ( i[1] )
      *(_BYTE *)(i[1] + 784) = 0;
    result = (_DWORD *)*i;
  }
  return result;
}

//----- (080A0F3E) --------------------------------------------------------
char *__usercall FS_InitFilesystem@<eax>(long double a1@<st0>)
{
  Com_StartupVariable(a1, "fs_cdpath");
  Com_StartupVariable(a1, "fs_basepath");
  Com_StartupVariable(a1, "fs_homepath");
  Com_StartupVariable(a1, "fs_game");
  Com_StartupVariable(a1, "fs_copyfiles");
  Com_StartupVariable(a1, "fs_restrict");
  Com_StartupVariable(a1, "loc_language");
  SEH_InitLanguage(a1);
  FS_Startup(a1, "main");
  FS_SetRestrictions(a1);
  if ( FS_ReadFile("default_mp.cfg", 0) <= 0 )
    Com_Error(0, "Couldn't load %s.  Make sure Call of Duty is run from the correct folder.", "default_mp.cfg");
  I_strncpyz(&lastValidBase, *(char **)(fs_basepath + 8), 256);
  return I_strncpyz(&lastValidGame, *(char **)(fs_gameDirVar + 8), 256);
}

//----- (080A1024) --------------------------------------------------------
char *__usercall FS_Restart@<eax>(long double a1@<st0>, int a2)
{
  char *v2; // eax

  FS_Shutdown();
  fs_checksumFeed = a2;
  FS_ClearIwdReferences();
  FS_Startup(a1, "main");
  FS_SetRestrictions(a1);
  if ( FS_ReadFile("default_mp.cfg", 0) <= 0 )
  {
    if ( lastValidBase )
    {
      FS_PureServerSetLoadedIwds(&byte_8145895, &byte_8145895);
      Dvar_SetString(fs_basepath, &lastValidBase);
      Dvar_SetString(fs_gameDirVar, &lastValidGame);
      lastValidBase = 0;
      lastValidGame = 0;
      Dvar_SetBool(fs_restrict, 0);
      FS_Restart(a2);
      Com_Error(1, "Invalid game folder\n");
    }
    Com_Error(0, "Couldn't load %s.  Make sure Call of Duty is run from the correct folder.", "default_mp.cfg");
  }
  if ( I_stricmp(*(char **)(fs_gameDirVar + 8), &lastValidGame) && !Com_SafeMode() )
  {
    v2 = va("exec %s\n", "config_mp_server.cfg");
    Cbuf_AddText(v2);
  }
  I_strncpyz(&lastValidBase, *(char **)(fs_basepath + 8), 256);
  return I_strncpyz(&lastValidGame, *(char **)(fs_gameDirVar + 8), 256);
}
// 848B7E0: using guessed type int fs_restrict;
// 848B7F4: using guessed type int fs_checksumFeed;

//----- (080A119C) --------------------------------------------------------
signed int __usercall sub_80A119C@<eax>(long double a1@<st0>, int a2)
{
  signed int v3; // [esp+4h] [ebp-4h]

  if ( *(_BYTE *)(com_sv_running + 8) )
    return 0;
  if ( *(_BYTE *)(fs_gameDirVar + 7) )
  {
    FS_Restart(a1, a2);
    v3 = 1;
  }
  else if ( a2 == fs_checksumFeed )
  {
    v3 = 0;
  }
  else
  {
    FS_Restart(a1, a2);
    v3 = 1;
  }
  return v3;
}
// 819EF14: using guessed type int com_sv_running;
// 848B7F4: using guessed type int fs_checksumFeed;

//----- (080A1200) --------------------------------------------------------
int __cdecl FS_FOpenFileByMode(char *src, int a2, int a3)
{
  int v5; // [esp+20h] [ebp-8h]
  int v6; // [esp+24h] [ebp-4h]

  v5 = 0;
  if ( a3 == 1 )
  {
    *(_DWORD *)a2 = FS_FOpenFileWrite(src);
    v6 = 0;
    if ( !*(_DWORD *)a2 )
      v6 = -1;
  }
  else if ( a3 > 1 )
  {
    if ( a3 != 2 )
    {
      if ( a3 != 3 )
LABEL_14:
        Com_Error(0, &byte_8145E1D);
      v5 = 1;
    }
    *(_DWORD *)a2 = FS_FOpenFileAppend(src);
    v6 = 0;
    if ( !*(_DWORD *)a2 )
      v6 = -1;
  }
  else
  {
    if ( a3 )
      goto LABEL_14;
    v6 = FS_FOpenFileRead((int)src, (int *)a2, 1);
  }
  if ( !a2 )
    return v6;
  if ( *(_DWORD *)a2 )
  {
    dword_848B80C[71 * *(_DWORD *)a2] = v6;
    dword_848B818[71 * *(_DWORD *)a2] = 0;
  }
  dword_848B808[71 * *(_DWORD *)a2] = v5;
  return v6;
}
// 848B808: using guessed type int dword_848B808[];
// 848B80C: using guessed type int dword_848B80C[];

//----- (080A1330) --------------------------------------------------------
int __cdecl sub_80A1330(int a1)
{
  FILE *v1; // eax

  if ( dword_848B814[71 * a1] )
    return sub_80D0D98(dword_848B800[71 * a1]);
  v1 = (FILE *)FS_FileForHandle(a1);
  return ftell(v1);
}
// 848B800: using guessed type int dword_848B800[];
// 848B814: using guessed type int dword_848B814[];

//----- (080A1380) --------------------------------------------------------
int __cdecl sub_80A1380(int a1)
{
  FILE *v1; // eax

  v1 = (FILE *)FS_FileForHandle(a1);
  return fflush(v1);
}

//----- (080A139C) --------------------------------------------------------
char *sub_80A139C()
{
  char *v1; // [esp+10h] [ebp-8h]
  _BYTE *v2; // [esp+14h] [ebp-4h]

  v2 = sub_80B0D96("gfx_driver");
  if ( *v2 )
    v1 = va("%sbsp", v2);
  else
    v1 = va("d3dbsp");
  return v1;
}

//----- (080A13E6) --------------------------------------------------------
int __cdecl LittleLong(int a1)
{
  return a1;
}

//----- (080A13EE) --------------------------------------------------------
int __cdecl sub_80A13EE(char *filename, struct stat *stat_buf)
{
  return __xstat(3, filename, stat_buf);
}

//----- (080A1410) --------------------------------------------------------
long double sub_80A1410()
{
  return (long double)rand() / 2147483600.0;
}

//----- (080A142E) --------------------------------------------------------
long double sub_80A142E()
{
  long double v0; // fst7

  v0 = sub_80A1410();
  return v0 + v0 - 1.0;
}

//----- (080A1442) --------------------------------------------------------
float *__cdecl sub_80A1442(float *a1, float *a2)
{
  float v2; // ST08_4
  float v3; // ST0C_4
  float *result; // eax
  float v5; // [esp+Ch] [ebp-Ch]
  float v6; // [esp+10h] [ebp-8h]
  float v7; // [esp+14h] [ebp-4h]

  do
  {
    v7 = sub_80A142E();
    v6 = sub_80A142E();
    v5 = v7 * v7 + v6 * v6;
  }
  while ( v5 > 1.0 );
  v2 = log(v5) * -2.0 / v5;
  v3 = sub_80A8B5A(v2);
  *a1 = v7 * v3;
  result = a2;
  *a2 = v6 * v3;
  return result;
}

//----- (080A14BA) --------------------------------------------------------
int __cdecl sub_80A14BA(int a1, float a2, int a3)
{
  int result; // eax
  int v4; // [esp+14h] [ebp-14h]
  int v5; // [esp+18h] [ebp-10h]
  float v6; // [esp+1Ch] [ebp-Ch]
  float v7; // [esp+20h] [ebp-8h]
  float v8; // [esp+24h] [ebp-4h]

  v8 = *(float *)&a1;
  v7 = sub_80A8B5A(*(float *)&a1);
  v6 = a2 * 6.283185307179586;
  sub_80A8C1C(v6, (int)&v5, (int)&v4);
  *(float *)a3 = v7 * *(float *)&v4;
  result = a3 + 4;
  *(float *)(a3 + 4) = v7 * *(float *)&v5;
  return result;
}

//----- (080A1516) --------------------------------------------------------
int __cdecl sub_80A1516(float a1, float a2, int a3)
{
  float v3; // ST00_4
  int result; // eax
  int v5; // [esp+14h] [ebp-14h]
  int v6; // [esp+18h] [ebp-10h]
  float v7; // [esp+1Ch] [ebp-Ch]
  float v8; // [esp+20h] [ebp-8h]
  float v9; // [esp+24h] [ebp-4h]

  v9 = a1 + a1 - 1.0;
  v3 = 1.0 - v9 * v9;
  v8 = sub_80A8B5A(v3);
  v7 = a2 * 6.283185307179586;
  sub_80A8C1C(v7, (int)&v6, (int)&v5);
  *(float *)a3 = v8 * *(float *)&v5;
  *(float *)(a3 + 4) = v8 * *(float *)&v6;
  result = LODWORD(v9);
  *(float *)(a3 + 8) = v9;
  return result;
}

//----- (080A158C) --------------------------------------------------------
int __cdecl sub_80A158C(int a1, float a2, int a3)
{
  float v3; // ST00_4
  int result; // eax
  int v5; // [esp+14h] [ebp-14h]
  int v6; // [esp+18h] [ebp-10h]
  float v7; // [esp+1Ch] [ebp-Ch]
  float v8; // [esp+20h] [ebp-8h]
  int v9; // [esp+24h] [ebp-4h]

  v9 = a1;
  v3 = 1.0 - *(float *)&a1 * *(float *)&a1;
  v8 = sub_80A8B5A(v3);
  v7 = a2 * 6.283185307179586;
  sub_80A8C1C(v7, (int)&v6, (int)&v5);
  *(float *)a3 = v8 * *(float *)&v5;
  *(float *)(a3 + 4) = v8 * *(float *)&v6;
  result = v9;
  *(_DWORD *)(a3 + 8) = v9;
  return result;
}

//----- (080A15FA) --------------------------------------------------------
signed int __cdecl sub_80A15FA(signed int a1, float *a2, int a3)
{
  signed int result; // eax
  float v4; // ST10_4
  float v5; // ST0C_4
  float v6; // [esp+4h] [ebp-24h]
  float v7; // [esp+8h] [ebp-20h]
  float v8; // [esp+14h] [ebp-14h]
  float v9; // [esp+18h] [ebp-10h]
  signed int i; // [esp+24h] [ebp-4h]

  v9 = 1.0 / (long double)a1;
  v8 = v9 * 0.5;
  v7 = 0.0;
  v6 = 1.0;
  for ( i = 0; ; ++i )
  {
    result = i;
    if ( i >= a1 )
      break;
    v4 = sub_80A8B5A(v8);
    *a2 = v4 * v6;
    a2[1] = v4 * v7;
    v8 = v8 + v9;
    v5 = v7;
    v7 = v7 * -0.73736888 + v6 * -0.67549032;
    v6 = v6 * -0.73736888 - v5 * -0.67549032;
    a2 = (float *)((char *)a2 + a3);
  }
  return result;
}

//----- (080A16B2) --------------------------------------------------------
signed int __cdecl sub_80A16B2(signed int a1, float *a2, int a3)
{
  signed int result; // eax
  float v4; // ST00_4
  float v5; // ST1C_4
  float v6; // ST18_4
  float v7; // [esp+10h] [ebp-28h]
  float v8; // [esp+14h] [ebp-24h]
  float v9; // [esp+24h] [ebp-14h]
  float v10; // [esp+28h] [ebp-10h]
  signed int i; // [esp+34h] [ebp-4h]

  v10 = 1.0 / (long double)a1;
  v9 = v10 * 0.5;
  v8 = 0.0;
  v7 = 1.0;
  for ( i = 0; ; ++i )
  {
    result = i;
    if ( i >= a1 )
      break;
    v4 = 1.0 - v9 * v9;
    v5 = sub_80A8B5A(v4);
    *a2 = v5 * v7;
    a2[1] = v5 * v8;
    a2[2] = v9;
    v9 = v9 + v10;
    v6 = v8;
    v8 = v8 * -0.73736888 + v7 * -0.67549032;
    v7 = v7 * -0.73736888 - v6 * -0.67549032;
    a2 = (float *)((char *)a2 + a3);
  }
  return result;
}

//----- (080A1788) --------------------------------------------------------
signed int __cdecl sub_80A1788(signed int a1, float *a2, int a3)
{
  signed int result; // eax
  float v4; // ST20_4
  float v5; // ST00_4
  float v6; // ST1C_4
  float v7; // ST18_4
  float v8; // [esp+10h] [ebp-28h]
  float v9; // [esp+14h] [ebp-24h]
  float v10; // [esp+24h] [ebp-14h]
  float v11; // [esp+28h] [ebp-10h]
  signed int i; // [esp+34h] [ebp-4h]

  v11 = 1.0 / (long double)a1;
  v10 = v11 * 0.5;
  v9 = 0.0;
  v8 = 1.0;
  for ( i = 0; ; ++i )
  {
    result = i;
    if ( i >= a1 )
      break;
    v4 = v10 + v10 - 1.0;
    v5 = 1.0 - v4 * v4;
    v6 = sub_80A8B5A(v5);
    *a2 = v6 * v8;
    a2[1] = v6 * v9;
    a2[2] = v4;
    v10 = v10 + v11;
    v7 = v9;
    v9 = v9 * -0.73736888 + v8 * -0.67549032;
    v8 = v8 * -0.73736888 - v7 * -0.67549032;
    a2 = (float *)((char *)a2 + a3);
  }
  return result;
}

//----- (080A1866) --------------------------------------------------------
long double __cdecl sub_80A1866(float a1, float a2, float a3, float a4)
{
  float v4; // ST08_4
  float v6; // [esp+Ch] [ebp-Ch]
  float v7; // [esp+10h] [ebp-8h]
  float v8; // [esp+14h] [ebp-4h]

  v8 = a1 - a2;
  if ( v8 <= 0.0 )
    v7 = -a3 * a4;
  else
    v7 = a3 * a4;
  if ( sub_80A8B40(v8) <= 0.001 )
  {
    v6 = a1;
  }
  else
  {
    v4 = sub_80A8B40(v8);
    if ( sub_80A8B40(v7) <= v4 )
      v6 = a2 + v7;
    else
      v6 = a1;
  }
  return v6;
}

//----- (080A1902) --------------------------------------------------------
void __cdecl sub_80A1902(float a1, float a2, float a3, float a4)
{
  float v4; // ST14_4

  while ( a1 - a2 > 180.0 )
    a1 = a1 - 360.0;
  while ( a1 - a2 < -180.0 )
    a1 = a1 + 360.0;
  v4 = sub_80A1866(a1, a2, a3, a4);
  sub_80A6112(v4);
}

//----- (080A1986) --------------------------------------------------------
long double __cdecl sub_80A1986(float a1, float a2, float a3, float a4)
{
  float v4; // ST08_4
  float v6; // [esp+Ch] [ebp-Ch]
  float v7; // [esp+10h] [ebp-8h]
  float v8; // [esp+14h] [ebp-4h]

  v8 = a1 - a2;
  v7 = a3 * v8 * a4;
  if ( sub_80A8B40(v8) <= 0.001 )
  {
    v6 = a1;
  }
  else
  {
    v4 = sub_80A8B40(v8);
    if ( sub_80A8B40(v7) <= v4 )
      v6 = a2 + v7;
    else
      v6 = a1;
  }
  return v6;
}

//----- (080A1A02) --------------------------------------------------------
void __cdecl sub_80A1A02(float a1, float a2, float a3, float a4)
{
  float v4; // ST14_4

  while ( a1 - a2 > 180.0 )
    a1 = a1 - 360.0;
  while ( a1 - a2 < -180.0 )
    a1 = a1 + 360.0;
  v4 = sub_80A1986(a1, a2, a3, a4);
  sub_80A6112(v4);
}

//----- (080A1B68) --------------------------------------------------------
long double __cdecl sub_80A1B68(float a1)
{
  float v2; // [esp+Ch] [ebp-Ch]
  float v3; // [esp+14h] [ebp-4h]

  v3 = acos(a1);
  if ( v3 <= 3.141592653589793 )
  {
    if ( v3 >= -3.141592653589793 )
      v2 = v3;
    else
      v2 = 3.1415927;
  }
  else
  {
    v2 = 3.1415927;
  }
  return v2;
}

//----- (080A1C2A) --------------------------------------------------------
int __cdecl sub_80A1C2A(float *a1)
{
  float v3; // [esp+Ch] [ebp-Ch]
  float v4; // [esp+10h] [ebp-8h]
  unsigned __int8 v5; // [esp+16h] [ebp-2h]
  unsigned __int8 i; // [esp+17h] [ebp-1h]

  if ( !a1 )
    return 0;
  v3 = 0.0;
  v5 = 0;
  for ( i = 0; i <= 0xA1u; ++i )
  {
    v4 = sub_80A8EFC(a1, (float *)(12 * i + 135649024));
    if ( v4 > (long double)v3 )
    {
      v3 = v4;
      v5 = i;
    }
  }
  return v5;
}

//----- (080A1D86) --------------------------------------------------------
void __cdecl sub_80A1D86(float *a1, float *a2)
{
  char v2; // [esp+10h] [ebp-18h]

  sub_80A8DE8(a2, a1, (float *)&v2);
  sub_80A8F9A((float *)&v2);
}

//----- (080A1DB2) --------------------------------------------------------
long double __cdecl sub_80A1DB2(float *a1, float *a2)
{
  float v3; // [esp+10h] [ebp-18h]
  float v4; // [esp+14h] [ebp-14h]
  float v5; // [esp+18h] [ebp-10h]

  sub_80A8DE8(a2, a1, &v3);
  return v3 * v3 + v4 * v4 + v5 * v5;
}

//----- (080A1E7C) --------------------------------------------------------
void __cdecl sub_80A1E7C(float *a1, float *a2)
{
  char v2; // [esp+10h] [ebp-8h]

  sub_80A8CAC(a2, a1, (float *)&v2);
  sub_80A8CFA((float *)&v2);
}

//----- (080A1EA8) --------------------------------------------------------
long double __cdecl sub_80A1EA8(float *a1, float *a2)
{
  float v3; // [esp+10h] [ebp-8h]
  float v4; // [esp+14h] [ebp-4h]

  sub_80A8CAC(a2, a1, &v3);
  return v3 * v3 + v4 * v4;
}

//----- (080A1ED8) --------------------------------------------------------
int __cdecl sub_80A1ED8(float *a1, float *a2, float *a3)
{
  int result; // eax

  *a3 = a1[1] * a2[2] - a1[2] * a2[1];
  a3[1] = a1[2] * *a2 - *a1 * a2[2];
  result = (int)(a1 + 1);
  a3[2] = *a1 * a2[1] - a1[1] * *a2;
  return result;
}

//----- (080A1FA2) --------------------------------------------------------
_DWORD *__cdecl sub_80A1FA2(float *a1, _DWORD *a2, _DWORD *a3)
{
  _DWORD *result; // eax
  float v4; // [esp+10h] [ebp-18h]
  float v5; // [esp+14h] [ebp-14h]
  float v6; // [esp+18h] [ebp-10h]

  sub_80A8E64(a1, a1, &v4);
  if ( v6 < (long double)v4 || v6 < (long double)v5 )
  {
    if ( v5 < (long double)v4 || v5 < (long double)v6 )
    {
      if ( *a1 <= 0.0 )
      {
        *a2 = 2;
        result = a3;
        *a3 = 1;
      }
      else
      {
        *a2 = 1;
        result = a3;
        *a3 = 2;
      }
    }
    else if ( a1[1] <= 0.0 )
    {
      *a2 = 0;
      result = a3;
      *a3 = 2;
    }
    else
    {
      *a2 = 2;
      result = a3;
      *a3 = 0;
    }
  }
  else if ( a1[2] <= 0.0 )
  {
    *a2 = 1;
    result = a3;
    *a3 = 0;
  }
  else
  {
    *a2 = 0;
    result = a3;
    *a3 = 1;
  }
  return result;
}

//----- (080A20C0) --------------------------------------------------------
long double __cdecl sub_80A20C0(float *a1)
{
  float v1; // ST14_4
  float v2; // ST10_4
  float v4; // [esp+14h] [ebp-4h]

  v1 = *a1 * *a1 + a1[1] * a1[1] + a1[2] * a1[2];
  v4 = sub_80A8B5A(v1);
  if ( v4 != 0.0 )
  {
    v2 = 1.0 / v4;
    *a1 = *a1 * v2;
    a1[1] = a1[1] * v2;
    a1[2] = a1[2] * v2;
  }
  return v4;
}

//----- (080A215E) --------------------------------------------------------
long double __cdecl sub_80A215E(float *a1)
{
  float v1; // ST14_4
  float v2; // ST10_4
  float v4; // [esp+14h] [ebp-4h]

  v1 = *a1 * *a1 + a1[1] * a1[1];
  v4 = sub_80A8B5A(v1);
  if ( v4 != 0.0 )
  {
    v2 = 1.0 / v4;
    *a1 = *a1 * v2;
    a1[1] = a1[1] * v2;
  }
  return v4;
}

//----- (080A21D6) --------------------------------------------------------
long double __cdecl sub_80A21D6(float *a1)
{
  float v1; // ST14_4
  float v2; // ST10_4
  float v4; // [esp+14h] [ebp-4h]

  v1 = *a1 * *a1 + a1[1] * a1[1] + a1[2] * a1[2] + a1[3] * a1[3];
  v4 = sub_80A8B5A(v1);
  if ( v4 != 0.0 )
  {
    v2 = 1.0 / v4;
    *a1 = *a1 * v2;
    a1[1] = a1[1] * v2;
    a1[2] = a1[2] * v2;
    a1[3] = a1[3] * v2;
  }
  return v4;
}

//----- (080A2298) --------------------------------------------------------
long double __cdecl sub_80A2298(float *a1, int a2)
{
  float v2; // ST14_4
  float v3; // ST10_4
  float v5; // [esp+14h] [ebp-4h]

  v2 = *a1 * *a1 + a1[1] * a1[1] + a1[2] * a1[2];
  v5 = sub_80A8B5A(v2);
  if ( v5 == 0.0 )
  {
    sub_80A8D26((_DWORD *)a2);
  }
  else
  {
    v3 = 1.0 / v5;
    *(float *)a2 = *a1 * v3;
    *(float *)(a2 + 4) = a1[1] * v3;
    *(float *)(a2 + 8) = a1[2] * v3;
  }
  return v5;
}

//----- (080A2342) --------------------------------------------------------
long double __cdecl sub_80A2342(float *a1, int a2)
{
  float v2; // ST14_4
  float v3; // ST10_4
  float v5; // [esp+14h] [ebp-4h]

  v2 = *a1 * *a1 + a1[1] * a1[1];
  v5 = sub_80A8B5A(v2);
  if ( v5 == 0.0 )
  {
    sub_80A8C78((_DWORD *)a2);
  }
  else
  {
    v3 = 1.0 / v5;
    *(float *)a2 = *a1 * v3;
    *(float *)(a2 + 4) = a1[1] * v3;
  }
  return v5;
}

//----- (080A2672) --------------------------------------------------------
int *__cdecl sub_80A2672(int a1, int a2, int a3, float a4)
{
  float v4; // ST1C_4
  int *result; // eax
  int v6; // [esp+20h] [ebp-138h]
  int v7; // [esp+24h] [ebp-134h]
  int v8; // [esp+28h] [ebp-130h]
  int v9; // [esp+30h] [ebp-128h]
  int v10; // [esp+34h] [ebp-124h]
  int v11; // [esp+38h] [ebp-120h]
  int v12; // [esp+40h] [ebp-118h]
  int v13; // [esp+44h] [ebp-114h]
  int v14; // [esp+48h] [ebp-110h]
  int i; // [esp+5Ch] [ebp-FCh]
  char v16; // [esp+60h] [ebp-F8h]
  char v17; // [esp+90h] [ebp-C8h]
  int s; // [esp+C0h] [ebp-98h]
  int v19; // [esp+C4h] [ebp-94h]
  unsigned int v20; // [esp+CCh] [ebp-8Ch]
  int v21; // [esp+D0h] [ebp-88h]
  int v22; // [esp+E0h] [ebp-78h]
  char dest; // [esp+F0h] [ebp-68h]
  int v24; // [esp+F4h] [ebp-64h]
  int v25; // [esp+F8h] [ebp-60h]
  int v26; // [esp+FCh] [ebp-5Ch]
  int v27; // [esp+104h] [ebp-54h]
  int v28; // [esp+108h] [ebp-50h]
  int v29; // [esp+10Ch] [ebp-4Ch]
  int src; // [esp+120h] [ebp-38h]
  int v31; // [esp+124h] [ebp-34h]
  int v32; // [esp+128h] [ebp-30h]
  int v33; // [esp+12Ch] [ebp-2Ch]
  int v34; // [esp+130h] [ebp-28h]
  int v35; // [esp+134h] [ebp-24h]
  int v36; // [esp+138h] [ebp-20h]
  int v37; // [esp+13Ch] [ebp-1Ch]
  int v38; // [esp+140h] [ebp-18h]
  char v39[8]; // [esp+150h] [ebp-8h]

  v6 = *(_DWORD *)a2;
  v7 = *(_DWORD *)(a2 + 4);
  v8 = *(_DWORD *)(a2 + 8);
  sub_80A30BA((float *)a2, (float *)&v12);
  sub_80A1ED8((float *)&v12, (float *)&v6, (float *)&v9);
  src = v12;
  v33 = v13;
  v36 = v14;
  v31 = v9;
  v34 = v10;
  v37 = v11;
  v32 = v6;
  v35 = v7;
  v38 = v8;
  memcpy(&dest, &src, 0x24u);
  v24 = v33;
  v25 = v36;
  v26 = v31;
  v27 = v37;
  v28 = v32;
  v29 = v35;
  memset(&s, 0, 0x24u);
  v22 = 1065353216;
  v21 = 1065353216;
  s = 1065353216;
  v4 = a4 * 0.0174532925199433;
  sub_80A8C1C(v4, (int)&v19, (int)&s);
  v20 = v19 ^ 0x80000000;
  v21 = s;
  sub_80A358E((float *)&src, (float *)&s, (float *)&v17);
  result = (int *)sub_80A358E((float *)&v17, (float *)&dest, (float *)&v16);
  for ( i = 0; i <= 2; ++i )
  {
    *(float *)(a1 + 4 * i) = *(float *)&v39[12 * i - 240] * *(float *)a3
                           + *(float *)&v39[12 * i - 236] * *(float *)(a3 + 4)
                           + *(float *)&v39[12 * i - 232] * *(float *)(a3 + 8);
    result = &i;
  }
  return result;
}
// 80A2672: using guessed type char var_8[8];

//----- (080A28D8) --------------------------------------------------------
int __cdecl sub_80A28D8(int a1, float a2)
{
  int v3; // [esp+10h] [ebp-18h]

  sub_80A30BA((float *)a1, (float *)(a1 + 12));
  if ( a2 != 0.0 )
  {
    sub_80A8D74((_DWORD *)(a1 + 12), &v3);
    sub_80A2672(a1 + 12, a1, (int)&v3, a2);
  }
  return sub_80A1ED8((float *)a1, (float *)(a1 + 12), (float *)(a1 + 24));
}

//----- (080A295E) --------------------------------------------------------
int __cdecl sub_80A295E(int a1, int a2, float *a3)
{
  float v3; // ST14_4

  *(_DWORD *)(a2 + 4) = *(_DWORD *)a1 ^ 0x80000000;
  *(_DWORD *)(a2 + 8) = *(_DWORD *)(a1 + 4);
  *(_DWORD *)a2 = *(_DWORD *)(a1 + 8);
  v3 = sub_80A8EFC((float *)a2, (float *)a1);
  sub_80A8EA8(a2, COERCE_FLOAT(LODWORD(v3) ^ 0x80000000), a1, a2);
  sub_80A20C0((float *)a2);
  return sub_80A1ED8((float *)a2, (float *)a1, a3);
}

//----- (080A29F6) --------------------------------------------------------
long double __cdecl sub_80A29F6(float *a1)
{
  float v2; // [esp+24h] [ebp-4h]

  if ( a1[1] != 0.0 || *a1 != 0.0 )
  {
    v2 = atan2(a1[1], *a1) * 180.0 / 3.141592653589793;
    if ( v2 < 0.0 )
      v2 = v2 + 360.0;
  }
  else
  {
    v2 = 0.0;
  }
  return v2;
}

//----- (080A2A84) --------------------------------------------------------
long double __cdecl sub_80A2A84(float *a1)
{
  float v2; // [esp+24h] [ebp-4h]

  if ( a1[1] != 0.0 || *a1 != 0.0 )
    v2 = atan2(a1[1], *a1) * 180.0 / 3.141592653589793;
  else
    v2 = 0.0;
  return v2;
}

//----- (080A2AF6) --------------------------------------------------------
long double __cdecl sub_80A2AF6(float *a1)
{
  float v1; // ST00_4
  float v2; // ST24_4
  float v4; // [esp+20h] [ebp-8h]

  if ( a1[1] != 0.0 || *a1 != 0.0 )
  {
    v1 = *a1 * *a1 + a1[1] * a1[1];
    v2 = sub_80A8B5A(v1);
    v4 = atan2(a1[2], v2) * -180.0 / 3.141592653589793;
    if ( v4 < 0.0 )
      v4 = v4 + 360.0;
  }
  else if ( a1[2] <= 0.0 )
  {
    v4 = 90.0;
  }
  else
  {
    v4 = 270.0;
  }
  return v4;
}

//----- (080A2BC8) --------------------------------------------------------
long double __cdecl sub_80A2BC8(float *a1)
{
  float v1; // ST00_4
  float v2; // ST24_4
  float v4; // [esp+20h] [ebp-8h]

  if ( a1[1] != 0.0 || *a1 != 0.0 )
  {
    v1 = *a1 * *a1 + a1[1] * a1[1];
    v2 = sub_80A8B5A(v1);
    v4 = atan2(a1[2], v2) * -180.0 / 3.141592653589793;
  }
  else if ( a1[2] <= 0.0 )
  {
    v4 = 90.0;
  }
  else
  {
    v4 = -90.0;
  }
  return v4;
}

//----- (080A2C7E) --------------------------------------------------------
int __cdecl sub_80A2C7E(float *a1, int a2)
{
  float v2; // ST00_4
  float v3; // ST24_4
  int result; // eax
  float v5; // [esp+1Ch] [ebp-Ch]
  float v6; // [esp+20h] [ebp-8h]

  if ( a1[1] != 0.0 || *a1 != 0.0 )
  {
    v6 = atan2(a1[1], *a1) * 180.0 / 3.141592653589793;
    if ( v6 < 0.0 )
      v6 = v6 + 360.0;
    v2 = *a1 * *a1 + a1[1] * a1[1];
    v3 = sub_80A8B5A(v2);
    v5 = atan2(a1[2], v3) * -180.0 / 3.141592653589793;
    if ( v5 < 0.0 )
      v5 = v5 + 360.0;
  }
  else
  {
    v6 = 0.0;
    if ( a1[2] <= 0.0 )
      v5 = 90.0;
    else
      v5 = 270.0;
  }
  *(float *)a2 = v5;
  *(float *)(a2 + 4) = v6;
  result = 0;
  *(_DWORD *)(a2 + 8) = 0;
  return result;
}

//----- (080A2DBE) --------------------------------------------------------
int __cdecl sub_80A2DBE(float *a1, int a2)
{
  float v2; // ST00_4
  float v3; // ST24_4
  int result; // eax
  float v5; // [esp+1Ch] [ebp-Ch]
  float v6; // [esp+20h] [ebp-8h]

  if ( a1[1] != 0.0 || *a1 != 0.0 )
  {
    v6 = atan2(a1[1], *a1) * 180.0 / 3.141592653589793;
    v2 = *a1 * *a1 + a1[1] * a1[1];
    v3 = sub_80A8B5A(v2);
    v5 = atan2(a1[2], v3) * -180.0 / 3.141592653589793;
  }
  else
  {
    v6 = 0.0;
    if ( a1[2] <= 0.0 )
      v5 = 90.0;
    else
      v5 = -90.0;
  }
  *(float *)a2 = v5;
  *(float *)(a2 + 4) = v6;
  result = 0;
  *(_DWORD *)(a2 + 8) = 0;
  return result;
}

//----- (080A2EC2) --------------------------------------------------------
void __cdecl sub_80A2EC2(float *a1, int a2, float *a3, float *a4)
{
  int v4; // [esp+1Ch] [ebp-1Ch]
  int v5; // [esp+20h] [ebp-18h]
  int v6; // [esp+24h] [ebp-14h]
  int v7; // [esp+28h] [ebp-10h]
  int v8; // [esp+2Ch] [ebp-Ch]
  int v9; // [esp+30h] [ebp-8h]
  float v10; // [esp+34h] [ebp-4h]

  v10 = a1[1] * 0.0174532925199433;
  sub_80A8C1C(v10, (int)&v7, (int)&v4);
  v10 = *a1 * 0.0174532925199433;
  sub_80A8C1C(v10, (int)&v8, (int)&v5);
  if ( a2 )
  {
    *(float *)a2 = *(float *)&v5 * *(float *)&v4;
    *(float *)(a2 + 4) = *(float *)&v5 * *(float *)&v7;
    *(_DWORD *)(a2 + 8) = v8 ^ 0x80000000;
  }
  if ( a3 || a4 )
  {
    v10 = a1[2] * 0.0174532925199433;
    sub_80A8C1C(v10, (int)&v9, (int)&v6);
    if ( a3 )
    {
      *a3 = -*(float *)&v9 * *(float *)&v8 * *(float *)&v4 + *(float *)&v6 * *(float *)&v7;
      a3[1] = -*(float *)&v9 * *(float *)&v8 * *(float *)&v7 + -*(float *)&v6 * *(float *)&v4;
      a3[2] = -*(float *)&v9 * *(float *)&v5;
    }
    if ( a4 )
    {
      *a4 = *(float *)&v6 * *(float *)&v8 * *(float *)&v4 + *(float *)&v9 * *(float *)&v7;
      a4[1] = *(float *)&v6 * *(float *)&v8 * *(float *)&v7 + -*(float *)&v9 * *(float *)&v4;
      a4[2] = *(float *)&v6 * *(float *)&v5;
    }
  }
}

//----- (080A303A) --------------------------------------------------------
void __cdecl sub_80A303A(float a1, int a2, int a3)
{
  int v3; // [esp+1Ch] [ebp-Ch]
  int v4; // [esp+20h] [ebp-8h]
  float v5; // [esp+24h] [ebp-4h]

  v5 = a1 * 0.0174532925199433;
  sub_80A8C1C(v5, (int)&v4, (int)&v3);
  if ( a2 )
  {
    *(_DWORD *)a2 = v3;
    *(_DWORD *)(a2 + 4) = v4;
    *(_DWORD *)(a2 + 8) = 0;
  }
  if ( a3 )
  {
    *(_DWORD *)a3 = v4;
    *(_DWORD *)(a3 + 4) = v3 ^ 0x80000000;
    *(_DWORD *)(a3 + 8) = 0;
  }
}

//----- (080A30BA) --------------------------------------------------------
void __cdecl sub_80A30BA(float *a1, float *a2)
{
  float v2; // [esp+20h] [ebp-28h]
  float v3; // [esp+24h] [ebp-24h]
  float v4; // [esp+28h] [ebp-20h]
  int v5; // [esp+3Ch] [ebp-Ch]

  v2 = *a1 * *a1;
  v3 = a1[1] * a1[1];
  v4 = a1[2] * a1[2];
  v5 = v2 > (long double)v3;
  if ( *(&v2 + v5) > (long double)v4 )
    v5 = 2;
  sub_80A8E2C((int)a1, COERCE_FLOAT(LODWORD(a1[v5]) ^ 0x80000000), (int)a2);
  a2[v5] = a2[v5] + 1.0;
  sub_80A20C0(a2);
}

//----- (080A318C) --------------------------------------------------------
void __cdecl sub_80A318C(float *a1, float *a2, float *a3, float *a4)
{
  char v4; // [esp+10h] [ebp-28h]
  char v5; // [esp+20h] [ebp-18h]

  sub_80A8DE8(a1, a2, (float *)&v5);
  sub_80A20C0((float *)&v5);
  sub_80A8DE8(a1, a3, (float *)&v4);
  sub_80A20C0((float *)&v4);
  sub_80A1ED8((float *)&v5, (float *)&v4, a4);
  sub_80A20C0(a4);
}

//----- (080A3416) --------------------------------------------------------
int __cdecl sub_80A3416(void *s)
{
  int result; // eax

  memset(s, 0, 0x24u);
  *(_DWORD *)s = 1065353216;
  *((_DWORD *)s + 4) = 1065353216;
  result = 1065353216;
  *((_DWORD *)s + 8) = 1065353216;
  return result;
}

//----- (080A345E) --------------------------------------------------------
void *__cdecl sub_80A345E(void *dest)
{
  return memcpy(dest, &unk_8145FA0, 0x40u);
}

//----- (080A358E) --------------------------------------------------------
int __cdecl sub_80A358E(float *a1, float *a2, float *a3)
{
  int result; // eax

  *a3 = *a1 * *a2 + a1[1] * a2[3] + a1[2] * a2[6];
  a3[1] = *a1 * a2[1] + a1[1] * a2[4] + a1[2] * a2[7];
  a3[2] = *a1 * a2[2] + a1[1] * a2[5] + a1[2] * a2[8];
  a3[3] = a1[3] * *a2 + a1[4] * a2[3] + a1[5] * a2[6];
  a3[4] = a1[3] * a2[1] + a1[4] * a2[4] + a1[5] * a2[7];
  a3[5] = a1[3] * a2[2] + a1[4] * a2[5] + a1[5] * a2[8];
  a3[6] = a1[6] * *a2 + a1[7] * a2[3] + a1[8] * a2[6];
  a3[7] = a1[6] * a2[1] + a1[7] * a2[4] + a1[8] * a2[7];
  result = (int)(a1 + 8);
  a3[8] = a1[6] * a2[2] + a1[7] * a2[5] + a1[8] * a2[8];
  return result;
}

//----- (080A3C8E) --------------------------------------------------------
int __cdecl sub_80A3C8E(float *a1, float *a2, float *a3)
{
  int result; // eax

  *a3 = *a1 * *a2 + a1[1] * a2[3] + a1[2] * a2[6];
  a3[3] = a1[3] * *a2 + a1[4] * a2[3] + a1[5] * a2[6];
  a3[6] = a1[6] * *a2 + a1[7] * a2[3] + a1[8] * a2[6];
  a3[1] = *a1 * a2[1] + a1[1] * a2[4] + a1[2] * a2[7];
  a3[4] = a1[3] * a2[1] + a1[4] * a2[4] + a1[5] * a2[7];
  a3[7] = a1[6] * a2[1] + a1[7] * a2[4] + a1[8] * a2[7];
  a3[2] = *a1 * a2[2] + a1[1] * a2[5] + a1[2] * a2[8];
  a3[5] = a1[3] * a2[2] + a1[4] * a2[5] + a1[5] * a2[8];
  a3[8] = a1[6] * a2[2] + a1[7] * a2[5] + a1[8] * a2[8];
  a3[9] = a1[9] * *a2 + a1[10] * a2[3] + a1[11] * a2[6] + a2[9];
  a3[10] = a1[9] * a2[1] + a1[10] * a2[4] + a1[11] * a2[7] + a2[10];
  result = (int)(a2 + 11);
  a3[11] = a1[9] * a2[2] + a1[10] * a2[5] + a1[11] * a2[8] + a2[11];
  return result;
}

//----- (080A442E) --------------------------------------------------------
int __cdecl sub_80A442E(_DWORD *a1, _DWORD *a2)
{
  int result; // eax

  *a2 = *a1;
  a2[1] = a1[3];
  a2[2] = a1[6];
  a2[3] = a1[1];
  a2[4] = a1[4];
  a2[5] = a1[7];
  a2[6] = a1[2];
  a2[7] = a1[5];
  result = a1[8];
  a2[8] = result;
  return result;
}

//----- (080A45BE) --------------------------------------------------------
int __cdecl sub_80A45BE(float *a1, float *a2)
{
  float v2; // ST00_4
  float v3; // ST00_4
  int result; // eax

  v2 = (a1[8] * a1[4] - a1[7] * a1[5]) * *a1
     - (a1[8] * a1[1] - a1[7] * a1[2]) * a1[3]
     + (a1[5] * a1[1] - a1[4] * a1[2]) * a1[6];
  v3 = 1.0 / v2;
  *a2 = (a1[8] * a1[4] - a1[7] * a1[5]) * v3;
  a2[1] = -(a1[8] * a1[1] - a1[7] * a1[2]) * v3;
  a2[2] = (a1[5] * a1[1] - a1[4] * a1[2]) * v3;
  a2[3] = -(a1[8] * a1[3] - a1[6] * a1[5]) * v3;
  a2[4] = (a1[8] * *a1 - a1[6] * a1[2]) * v3;
  a2[5] = -(a1[5] * *a1 - a1[3] * a1[2]) * v3;
  a2[6] = (a1[7] * a1[3] - a1[6] * a1[4]) * v3;
  a2[7] = -(a1[7] * *a1 - a1[6] * a1[1]) * v3;
  result = (int)(a1 + 3);
  a2[8] = (a1[4] * *a1 - a1[3] * a1[1]) * v3;
  return result;
}

//----- (080A47DE) --------------------------------------------------------
int __cdecl sub_80A47DE(int a1, int a2)
{
  char v3; // [esp+10h] [ebp-18h]

  sub_80A442E((_DWORD *)a1, (_DWORD *)a2);
  sub_80A8DE8((float *)&unk_8145E68, (float *)(a1 + 36), (float *)&v3);
  return sub_80A4E52((float *)&v3, (float *)a2, (float *)(a2 + 36));
}

//----- (080A4E52) --------------------------------------------------------
int __cdecl sub_80A4E52(float *a1, float *a2, float *a3)
{
  int result; // eax

  *a3 = *a1 * *a2 + a1[1] * a2[3] + a1[2] * a2[6];
  a3[1] = *a1 * a2[1] + a1[1] * a2[4] + a1[2] * a2[7];
  result = (int)(a1 + 2);
  a3[2] = *a1 * a2[2] + a1[1] * a2[5] + a1[2] * a2[8];
  return result;
}

//----- (080A5028) --------------------------------------------------------
int __cdecl sub_80A5028(float *a1, float *a2, float *a3)
{
  int result; // eax

  *a3 = *a1 * *a2 + a1[1] * a2[1] + a1[2] * a2[2];
  a3[1] = *a1 * a2[3] + a1[1] * a2[4] + a1[2] * a2[5];
  result = (int)(a1 + 2);
  a3[2] = *a1 * a2[6] + a1[1] * a2[7] + a1[2] * a2[8];
  return result;
}

//----- (080A50D2) --------------------------------------------------------
int __cdecl sub_80A50D2(float *a1, float *a2, float *a3)
{
  int result; // eax

  *a3 = *a1 * *a2 + a1[1] * a2[3] + a1[2] * a2[6] + a2[9];
  a3[1] = *a1 * a2[1] + a1[1] * a2[4] + a1[2] * a2[7] + a2[10];
  result = (int)(a2 + 11);
  a3[2] = *a1 * a2[2] + a1[1] * a2[5] + a1[2] * a2[8] + a2[11];
  return result;
}

//----- (080A5194) --------------------------------------------------------
int __cdecl sub_80A5194(float *a1, float *a2, float *a3)
{
  int result; // eax
  float v4; // [esp+10h] [ebp-18h]
  float v5; // [esp+14h] [ebp-14h]
  float v6; // [esp+18h] [ebp-10h]

  sub_80A8DE8(a1, a2 + 9, &v4);
  *a3 = *a2 * v4 + a2[1] * v5 + a2[2] * v6;
  a3[1] = a2[3] * v4 + a2[4] * v5 + a2[5] * v6;
  result = (int)(a2 + 8);
  a3[2] = a2[6] * v4 + a2[7] * v5 + a2[8] * v6;
  return result;
}

//----- (080A530C) --------------------------------------------------------
int __cdecl sub_80A530C(int a1, float a2)
{
  float v2; // ST00_4
  float v3; // ST1C_4
  int result; // eax
  int v5; // [esp+20h] [ebp-8h]
  int v6; // [esp+24h] [ebp-4h]

  v2 = a2 * 0.0174532925199433;
  sub_80A8C1C(v2, (int)&v5, (int)&v6);
  v3 = *(float *)a1 * *(float *)&v6 - *(float *)(a1 + 4) * *(float *)&v5;
  *(float *)(a1 + 4) = *(float *)(a1 + 4) * *(float *)&v6 + *(float *)a1 * *(float *)&v5;
  result = LODWORD(v3);
  *(float *)a1 = v3;
  return result;
}

//----- (080A5372) --------------------------------------------------------
int __cdecl sub_80A5372(float *a1, float *a2, float *a3)
{
  int result; // eax

  *a3 = *a1 * a2[3] + a1[3] * *a2 + a1[2] * a2[1] - a1[1] * a2[2];
  a3[1] = a1[1] * a2[3] - a1[2] * *a2 + a1[3] * a2[1] + *a1 * a2[2];
  a3[2] = a1[2] * a2[3] + a1[1] * *a2 - *a1 * a2[1] + a1[3] * a2[2];
  result = (int)(a1 + 2);
  a3[3] = a1[3] * a2[3] - *a1 * *a2 - a1[1] * a2[1] - a1[2] * a2[2];
  return result;
}

//----- (080A5494) --------------------------------------------------------
unsigned int __cdecl sub_80A5494(_DWORD *a1, unsigned int *a2)
{
  unsigned int result; // eax

  *a2 = *a1 ^ 0x80000000;
  a2[1] = a1[1] ^ 0x80000000;
  a2[2] = a1[2] ^ 0x80000000;
  result = a1[3];
  a2[3] = result;
  return result;
}

//----- (080A54E2) --------------------------------------------------------
int __cdecl sub_80A54E2(float *a1, float *a2)
{
  float v2; // ST34_4
  float v3; // ST24_4
  float v4; // ST18_4
  float v5; // ST10_4
  float v6; // ST0C_4
  float v7; // ST08_4
  float v8; // ST34_4
  float v9; // ST24_4
  float v10; // ST18_4
  float v11; // ST04_4
  float v12; // ST30_4
  float v13; // ST2C_4
  float v14; // ST28_4
  float v15; // ST00_4
  float v16; // ST20_4
  float v17; // ST1C_4
  float v18; // ST14_4
  int result; // eax

  v2 = *a1 * *a1;
  v3 = a1[1] * a1[1];
  v4 = a1[2] * a1[2];
  v5 = a1[3] * a1[3];
  v6 = v2 + v3 + v4 + v5;
  v7 = 2.0 / v6;
  v8 = v2 * v7;
  v9 = v3 * v7;
  v10 = v4 * v7;
  v11 = v7 * *a1;
  v12 = v11 * a1[1];
  v13 = v11 * a1[2];
  v14 = v11 * a1[3];
  v15 = v7 * a1[1];
  v16 = v15 * a1[2];
  v17 = v15 * a1[3];
  v18 = v7 * a1[2] * a1[3];
  *a2 = 1.0 - (v9 + v10);
  a2[1] = v12 + v18;
  a2[2] = v13 - v17;
  a2[3] = v12 - v18;
  a2[4] = 1.0 - (v8 + v10);
  a2[5] = v16 + v14;
  a2[6] = v13 + v17;
  a2[7] = v16 - v14;
  result = (int)(a2 + 8);
  a2[8] = 1.0 - (v8 + v9);
  return result;
}

//----- (080A5662) --------------------------------------------------------
long double __cdecl sub_80A5662(float *a1)
{
  float v1; // ST04_4
  float v2; // ST10_4
  float v3; // ST0C_4
  float v4; // ST08_4
  float v6; // [esp+0h] [ebp-14h]
  float v7; // [esp+4h] [ebp-10h]
  float v8; // [esp+8h] [ebp-Ch]
  float v9; // [esp+Ch] [ebp-8h]
  float v10; // [esp+10h] [ebp-4h]

  v10 = *a1 * *a1;
  v9 = a1[1] * a1[1];
  v8 = a1[2] * a1[2];
  v7 = v10 + v9 + v8 + a1[3] * a1[3];
  if ( v7 == 0.0 )
  {
    v6 = 0.0;
  }
  else
  {
    v1 = 1.0 / v7;
    v2 = v10 * v1;
    v3 = v9 * v1;
    v4 = v8 * v1;
    v6 = v2 + v3 + v4;
  }
  return v6;
}

//----- (080A5706) --------------------------------------------------------
long double __cdecl sub_80A5706(float a1)
{
  long double v1; // fst7

  v1 = sin(a1 * 0.0174532925199433);
  return (float)((double)v1 * (double)v1);
}

//----- (080A5774) --------------------------------------------------------
long double __cdecl sub_80A5774(float *a1)
{
  float v1; // ST24_4
  float v2; // ST20_4
  float v3; // ST20_4

  v1 = *a1 * *a1;
  v2 = a1[1] * a1[1] + v1;
  v3 = 2.0 / v2;
  return (float)(atan2(*a1 * a1[1] * v3, 1.0 - v1 * v3) * 57.29577951308232);
}

//----- (080A57E8) --------------------------------------------------------
void __cdecl sub_80A57E8(float a1, int a2)
{
  float v2; // [esp+20h] [ebp+8h]

  v2 = a1 * 0.008726646259971648;
  *(_DWORD *)a2 = 0;
  *(_DWORD *)(a2 + 8) = 0;
  sub_80A8C1C(v2, a2 + 4, a2 + 12);
}

//----- (080A5834) --------------------------------------------------------
void __cdecl sub_80A5834(float a1, int a2)
{
  float v2; // [esp+20h] [ebp+8h]

  v2 = a1 * 0.008726646259971648;
  *(_DWORD *)a2 = 0;
  *(_DWORD *)(a2 + 4) = 0;
  sub_80A8C1C(v2, a2 + 8, a2 + 12);
}

//----- (080A5880) --------------------------------------------------------
void __cdecl sub_80A5880(float a1, int a2)
{
  float v2; // [esp+20h] [ebp+8h]

  v2 = a1 * 0.008726646259971648;
  *(_DWORD *)(a2 + 4) = 0;
  *(_DWORD *)(a2 + 8) = 0;
  sub_80A8C1C(v2, a2, a2 + 12);
}

//----- (080A58CC) --------------------------------------------------------
int __cdecl sub_80A58CC(float a1, int a2, int a3)
{
  float v4; // [esp+14h] [ebp-4h]
  float v5; // [esp+20h] [ebp+8h]

  v5 = a1 * 0.008726646259971648;
  sub_80A8C1C(v5, (int)&v4, a3 + 12);
  return sub_80A8E2C(a2, v4, a3);
}

//----- (080A5918) --------------------------------------------------------
int __cdecl sub_80A5918(int a1, float a2)
{
  float v2; // ST00_4
  int result; // eax
  int v4; // [esp+10h] [ebp-8h]
  int v5; // [esp+14h] [ebp-4h]

  v2 = a2 * 0.0174532925199433;
  sub_80A8C1C(v2, (int)&v4, (int)&v5);
  *(_DWORD *)a1 = 1065353216;
  *(_DWORD *)(a1 + 4) = 0;
  *(_DWORD *)(a1 + 8) = 0;
  *(_DWORD *)(a1 + 12) = 0;
  *(_DWORD *)(a1 + 16) = v5;
  *(_DWORD *)(a1 + 20) = v4 ^ 0x80000000;
  *(_DWORD *)(a1 + 24) = 0;
  *(_DWORD *)(a1 + 28) = v4;
  result = v5;
  *(_DWORD *)(a1 + 32) = v5;
  return result;
}

//----- (080A59B0) --------------------------------------------------------
int __cdecl sub_80A59B0(int a1, float a2)
{
  float v2; // ST00_4
  int result; // eax
  int v4; // [esp+10h] [ebp-8h]
  int v5; // [esp+14h] [ebp-4h]

  v2 = a2 * 0.0174532925199433;
  sub_80A8C1C(v2, (int)&v4, (int)&v5);
  *(_DWORD *)a1 = v5;
  *(_DWORD *)(a1 + 4) = 0;
  *(_DWORD *)(a1 + 8) = v4;
  *(_DWORD *)(a1 + 12) = 0;
  *(_DWORD *)(a1 + 16) = 1065353216;
  *(_DWORD *)(a1 + 20) = 0;
  *(_DWORD *)(a1 + 24) = v4 ^ 0x80000000;
  *(_DWORD *)(a1 + 28) = 0;
  result = v5;
  *(_DWORD *)(a1 + 32) = v5;
  return result;
}

//----- (080A5A48) --------------------------------------------------------
int __cdecl sub_80A5A48(int a1, float a2)
{
  float v2; // ST00_4
  int result; // eax
  int v4; // [esp+10h] [ebp-8h]
  int v5; // [esp+14h] [ebp-4h]

  v2 = a2 * 0.0174532925199433;
  sub_80A8C1C(v2, (int)&v4, (int)&v5);
  *(_DWORD *)a1 = v5;
  *(_DWORD *)(a1 + 4) = v4 ^ 0x80000000;
  *(_DWORD *)(a1 + 8) = 0;
  *(_DWORD *)(a1 + 12) = v4;
  *(_DWORD *)(a1 + 16) = v5;
  *(_DWORD *)(a1 + 20) = 0;
  *(_DWORD *)(a1 + 24) = 0;
  *(_DWORD *)(a1 + 28) = 0;
  result = 1065353216;
  *(_DWORD *)(a1 + 32) = 1065353216;
  return result;
}

//----- (080A5AE0) --------------------------------------------------------
int __cdecl sub_80A5AE0(void *s, float a2, float a3, int a4)
{
  int result; // eax

  memset(s, 0, 0x40u);
  *(float *)s = tan((90.0 - a2 * 0.5) * 0.0174532925199433) * 0.99950027;
  *((float *)s + 5) = tan((90.0 - a3 * 0.5) * 0.0174532925199433) * 0.99950027;
  *((_DWORD *)s + 10) = 1065344832;
  *((_DWORD *)s + 11) = 1065353216;
  result = a4;
  *((float *)s + 14) = -*(float *)&a4 * 0.99950027;
  return result;
}

//----- (080A5B9C) --------------------------------------------------------
int __cdecl sub_80A5B9C(void *s, float a2, float a3, float a4)
{
  int result; // eax

  memset(s, 0, 0x40u);
  *(float *)s = 2.0 / a2;
  *((float *)s + 5) = 2.0 / a3;
  *((float *)s + 10) = 0.5 / a4;
  *((_DWORD *)s + 14) = 1056964608;
  result = 1065353216;
  *((_DWORD *)s + 15) = 1065353216;
  return result;
}

//----- (080A5F4C) --------------------------------------------------------
long double __cdecl sub_80A5F4C(float a1)
{
  return (long double)(unsigned __int16)(signed int)(a1 * 182.04445) * 0.0054931641;
}

//----- (080A6000) --------------------------------------------------------
long double __cdecl sub_80A6000(float a1, float a2)
{
  float i; // [esp+4h] [ebp-4h]

  for ( i = a1 - a2; i > 180.0; i = i - 360.0 )
    ;
  while ( i < -180.0 )
    i = i + 360.0;
  return i;
}

//----- (080A6062) --------------------------------------------------------
int __cdecl sub_80A6062(float *a1, float *a2, float *a3)
{
  long double v3; // fst7
  int result; // eax

  *a3 = sub_80A6000(*a1, *a2);
  a3[1] = sub_80A6000(a1[1], a2[1]);
  v3 = sub_80A6000(a1[2], a2[2]);
  result = (int)(a3 + 2);
  a3[2] = v3;
  return result;
}

//----- (080A60CE) --------------------------------------------------------
long double __cdecl sub_80A60CE(float a1)
{
  return (long double)(unsigned __int16)(signed int)(a1 * 182.04445) * 0.0054931641;
}

//----- (080A6112) --------------------------------------------------------
long double __cdecl sub_80A6112(float a1)
{
  float v2; // [esp+14h] [ebp-4h]

  v2 = sub_80A60CE(a1);
  if ( v2 > 180.0 )
    v2 = v2 - 360.0;
  return v2;
}

//----- (080A6154) --------------------------------------------------------
long double __cdecl sub_80A6154(float a1)
{
  float v2; // [esp+0h] [ebp-4h]

  if ( a1 >= 0.0 )
  {
    if ( a1 < 360.0 )
    {
      v2 = a1;
    }
    else
    {
      do
        a1 = a1 - 360.0;
      while ( a1 >= 360.0 );
      v2 = a1;
    }
  }
  else
  {
    do
      a1 = a1 + 360.0;
    while ( a1 < 0.0 );
    v2 = a1;
  }
  return v2;
}

//----- (080A61D2) --------------------------------------------------------
long double __cdecl sub_80A61D2(float a1)
{
  float v2; // [esp+0h] [ebp-4h]

  if ( a1 > -180.0 )
  {
    if ( a1 <= 180.0 )
    {
      v2 = a1;
    }
    else
    {
      do
        a1 = a1 - 360.0;
      while ( a1 > 180.0 );
      v2 = a1;
    }
  }
  else
  {
    do
      a1 = a1 + 360.0;
    while ( a1 <= -180.0 );
    v2 = a1;
  }
  return v2;
}

//----- (080A6258) --------------------------------------------------------
void __cdecl sub_80A6258(float a1, float a2)
{
  float v2; // ST00_4

  v2 = a1 - a2;
  sub_80A6112(v2);
}

//----- (080A626E) --------------------------------------------------------
void __cdecl sub_80A626E(int a1, int a2)
{
  float v2; // [esp+10h] [ebp-38h]
  float v3; // [esp+18h] [ebp-30h]
  float v4; // [esp+1Ch] [ebp-2Ch]
  float v5[7]; // [esp+20h] [ebp-28h]
  int i; // [esp+3Ch] [ebp-Ch]

  for ( i = 0; i <= 2; ++i )
  {
    v4 = sub_80A8B40(*(float *)(a1 + 4 * i));
    v3 = sub_80A8B40(*(float *)(a2 + 4 * i));
    if ( v4 <= (long double)v3 )
      v2 = v3;
    else
      v2 = v4;
    v5[i] = v2;
  }
  sub_80A8F9A(v5);
}
// 80A626E: using guessed type float var_28[7];

//----- (080A62FC) --------------------------------------------------------
void __cdecl sub_80A62FC(int a1, int a2)
{
  float v2; // [esp+8h] [ebp-20h]
  float v3; // [esp+10h] [ebp-18h]
  float v4; // [esp+14h] [ebp-14h]
  float v5[3]; // [esp+18h] [ebp-10h]
  int i; // [esp+24h] [ebp-4h]

  for ( i = 0; i <= 1; ++i )
  {
    v4 = sub_80A8B40(*(float *)(a1 + 4 * i));
    v3 = sub_80A8B40(*(float *)(a2 + 4 * i));
    if ( v4 <= (long double)v3 )
      v2 = v3;
    else
      v2 = v4;
    v5[i] = v2;
  }
  sub_80A8CFA(v5);
}
// 80A62FC: using guessed type float var_10[3];

//----- (080A6450) --------------------------------------------------------
void __usercall sub_80A6450(long double a1@<st0>, float *a2, float *a3)
{
  float v3; // ST18_4
  float v4; // [esp+1Ch] [ebp-1Ch]
  float v5; // [esp+20h] [ebp-18h]
  float v6; // [esp+24h] [ebp-14h]
  float v7; // [esp+28h] [ebp-10h]

  sub_80A8DE8(a3, a2, &v5);
  sub_80A8B7A(v5, v6);
  v4 = a1;
  if ( v4 > (long double)v7 )
  {
    v3 = (v4 - v7) * 0.5;
    a2[2] = a2[2] - v3;
    a3[2] = a3[2] + v3;
  }
}

//----- (080A64CE) --------------------------------------------------------
void __cdecl sub_80A64CE(float *a1, float *a2)
{
  float v2; // ST1C_4
  float v3; // ST1C_4
  float v4; // [esp+20h] [ebp-18h]
  float v5; // [esp+24h] [ebp-14h]
  float v6; // [esp+28h] [ebp-10h]

  sub_80A8DE8(a2, a1, &v4);
  if ( v4 > (long double)v6 )
  {
    v2 = (v4 - v6) * 0.5;
    *a1 = *a1 + v2;
    *a2 = *a2 - v2;
  }
  if ( v5 > (long double)v6 )
  {
    v3 = (v5 - v6) * 0.5;
    a1[1] = a1[1] + v3;
    a2[1] = a2[1] - v3;
  }
}

//----- (080A660A) --------------------------------------------------------
void __cdecl sub_80A660A(float *a1, float *a2, float *a3)
{
  if ( *a2 > (long double)*a1 )
    *a2 = *a1;
  if ( *a1 > (long double)*a3 )
    *a3 = *a1;
  if ( a2[1] > (long double)a1[1] )
    a2[1] = a1[1];
  if ( a1[1] > (long double)a3[1] )
    a3[1] = a1[1];
  if ( a2[2] > (long double)a1[2] )
    a2[2] = a1[2];
  if ( a1[2] > (long double)a3[2] )
    a3[2] = a1[2];
}

//----- (080A6B48) --------------------------------------------------------
void __cdecl sub_80A6B48(float *a1, float *a2, float *a3, float *a4)
{
  if ( *a3 > (long double)*a1 )
    *a3 = *a1;
  if ( *a2 > (long double)*a4 )
    *a4 = *a2;
  if ( a3[1] > (long double)a1[1] )
    a3[1] = a1[1];
  if ( a2[1] > (long double)a4[1] )
    a4[1] = a2[1];
  if ( a3[2] > (long double)a1[2] )
    a3[2] = a1[2];
  if ( a2[2] > (long double)a4[2] )
    a4[2] = a2[2];
}

//----- (080A6CC8) --------------------------------------------------------
void __cdecl sub_80A6CC8(int a1, int a2, int a3, int a4)
{
  signed int v4; // [esp+4h] [ebp-24h]
  signed int v5; // [esp+8h] [ebp-20h]
  signed int v6; // [esp+10h] [ebp-18h]
  int i; // [esp+18h] [ebp-10h]

  for ( i = 0; i <= 2; ++i )
  {
    *(_DWORD *)(a4 + 4 * i) = *(_DWORD *)(a2 + 4 * i);
    *(_DWORD *)(a4 + 4 * i + 12) = *(_DWORD *)(a2 + 4 * i);
    if ( sub_80A8BDC(a3 + 4 * i) >= 0 )
      v6 = 0;
    else
      v6 = 12;
    *(float *)(a4 + 4 * i) = *(float *)(v6 + a1) * *(float *)(a3 + 4 * i) + *(float *)(a4 + 4 * i);
    *(float *)(a4 + 4 * i + 12) = *(float *)(a1 - v6 + 12) * *(float *)(a3 + 4 * i) + *(float *)(a4 + 4 * i + 12);
    if ( sub_80A8BDC(a3 + 4 * i + 12) >= 0 )
      v5 = 0;
    else
      v5 = 12;
    *(float *)(a4 + 4 * i) = *(float *)(a1 + v5 + 4) * *(float *)(a3 + 4 * i + 12) + *(float *)(a4 + 4 * i);
    *(float *)(a4 + 4 * i + 12) = *(float *)(a1 - v5 + 16) * *(float *)(a3 + 4 * i + 12) + *(float *)(a4 + 4 * i + 12);
    if ( sub_80A8BDC(a3 + 4 * i + 24) >= 0 )
      v4 = 0;
    else
      v4 = 12;
    *(float *)(a4 + 4 * i) = *(float *)(a1 + v4 + 8) * *(float *)(a3 + 4 * i + 24) + *(float *)(a4 + 4 * i);
    *(float *)(a4 + 4 * i + 12) = *(float *)(a1 - v4 + 20) * *(float *)(a3 + 4 * i + 24) + *(float *)(a4 + 4 * i + 12);
  }
}

//----- (080A6FE6) --------------------------------------------------------
int __cdecl sub_80A6FE6(_DWORD *a1, _DWORD *a2)
{
  sub_80A8D74(a1, a2);
  sub_80A8D74(a1 + 3, a2 + 3);
  return sub_80A8D74(a1 + 6, a2 + 6);
}

//----- (080A70C0) --------------------------------------------------------
int __cdecl sub_80A70C0(int a1, float a2, float a3, float a4, int a5)
{
  int result; // eax

  *(float *)a5 = a2 * *(float *)a1 + a3 * *(float *)(a1 + 12) + a4 * *(float *)(a1 + 24);
  *(float *)(a5 + 4) = a2 * *(float *)(a1 + 4) + a3 * *(float *)(a1 + 16) + a4 * *(float *)(a1 + 28);
  result = a1 + 32;
  *(float *)(a5 + 8) = a2 * *(float *)(a1 + 8) + a3 * *(float *)(a1 + 20) + a4 * *(float *)(a1 + 32);
  return result;
}

//----- (080A7146) --------------------------------------------------------
int __cdecl sub_80A7146(float *a1, int a2)
{
  char v3; // [esp+10h] [ebp-18h]

  sub_80A2EC2(a1, a2, (float *)&v3, (float *)(a2 + 24));
  return sub_80A8DE8((float *)&unk_8145E68, (float *)&v3, (float *)(a2 + 12));
}

//----- (080A718E) --------------------------------------------------------
int __cdecl sub_80A718E(float a1, int a2)
{
  int v3; // [esp+10h] [ebp-18h]

  sub_80A303A(a1, a2, (int)&v3);
  *(_DWORD *)(a2 + 24) = 0;
  *(_DWORD *)(a2 + 28) = 0;
  *(_DWORD *)(a2 + 32) = 1065353216;
  return sub_80A8DE8((float *)&unk_8145E68, (float *)&v3, (float *)(a2 + 12));
}

//----- (080A71F4) --------------------------------------------------------
int __cdecl sub_80A71F4(int a1, int a2)
{
  float v2; // ST30_4
  int result; // eax
  float v4; // [esp+20h] [ebp-38h]
  float v5; // [esp+2Ch] [ebp-2Ch]
  int v6; // [esp+34h] [ebp-24h]
  int v7; // [esp+38h] [ebp-20h]
  float v8; // [esp+3Ch] [ebp-1Ch]
  float v9; // [esp+40h] [ebp-18h]
  float v10; // [esp+44h] [ebp-14h]
  float v11; // [esp+48h] [ebp-10h]

  sub_80A2C7E((float *)a1, a2);
  sub_80A8D74((_DWORD *)(a1 + 12), &v9);
  v8 = -*(float *)(a2 + 4) * 0.0174532925199433;
  sub_80A8C1C(v8, (int)&v7, (int)&v6);
  v2 = *(float *)&v6 * v9 - *(float *)&v7 * v10;
  v10 = *(float *)&v7 * v9 + *(float *)&v6 * v10;
  v8 = -*(float *)a2 * 0.0174532925199433;
  sub_80A8C1C(v8, (int)&v7, (int)&v6);
  v9 = *(float *)&v7 * v11 + *(float *)&v6 * v2;
  v11 = *(float *)&v6 * v11 - *(float *)&v7 * v2;
  v5 = sub_80A2BC8(&v9);
  if ( v10 >= 0.0 )
  {
    result = a2 + 8;
    *(_DWORD *)(a2 + 8) = LODWORD(v5) ^ 0x80000000;
  }
  else
  {
    if ( v5 >= 0.0 )
      v4 = v5 + -180.0;
    else
      v4 = v5 + 180.0;
    result = a2 + 8;
    *(float *)(a2 + 8) = v4;
  }
  return result;
}

//----- (080A7338) --------------------------------------------------------
int __cdecl sub_80A7338(int a1, int a2)
{
  float v2; // ST30_4
  int result; // eax
  float v4; // [esp+20h] [ebp-38h]
  float v5; // [esp+2Ch] [ebp-2Ch]
  int v6; // [esp+34h] [ebp-24h]
  int v7; // [esp+38h] [ebp-20h]
  float v8; // [esp+3Ch] [ebp-1Ch]
  float v9; // [esp+40h] [ebp-18h]
  float v10; // [esp+44h] [ebp-14h]
  float v11; // [esp+48h] [ebp-10h]

  sub_80A2DBE((float *)a1, a2);
  sub_80A8D74((_DWORD *)(a1 + 12), &v9);
  v8 = -*(float *)(a2 + 4) * 0.0174532925199433;
  sub_80A8C1C(v8, (int)&v7, (int)&v6);
  v2 = *(float *)&v6 * v9 - *(float *)&v7 * v10;
  v10 = *(float *)&v7 * v9 + *(float *)&v6 * v10;
  v8 = -*(float *)a2 * 0.0174532925199433;
  sub_80A8C1C(v8, (int)&v7, (int)&v6);
  v9 = *(float *)&v7 * v11 + *(float *)&v6 * v2;
  v11 = *(float *)&v6 * v11 - *(float *)&v7 * v2;
  v5 = sub_80A2BC8(&v9);
  if ( v10 >= 0.0 )
  {
    result = a2 + 8;
    *(_DWORD *)(a2 + 8) = LODWORD(v5) ^ 0x80000000;
  }
  else
  {
    if ( v5 >= 0.0 )
      v4 = v5 + -180.0;
    else
      v4 = v5 + 180.0;
    result = a2 + 8;
    *(float *)(a2 + 8) = v4;
  }
  return result;
}

//----- (080A7CE6) --------------------------------------------------------
signed int __cdecl sub_80A7CE6(float *a1, float *a2, float *a3, float *a4)
{
  char v6; // [esp+20h] [ebp-28h]
  char v7; // [esp+30h] [ebp-18h]

  sub_80A8DE8(a3, a2, (float *)&v7);
  sub_80A8DE8(a4, a2, (float *)&v6);
  sub_80A1ED8((float *)&v6, (float *)&v7, a1);
  if ( sub_80A20C0(a1) == 0.0 )
    return 0;
  a1[3] = sub_80A8EFC(a2, a1);
  return 1;
}

//----- (080A7D80) --------------------------------------------------------
int __cdecl sub_80A7D80(float *a1, float *a2, int a3)
{
  float v3; // ST10_4

  v3 = sub_80A8EFC(a2, a1);
  return sub_80A8EA8((int)a1, COERCE_FLOAT(LODWORD(v3) ^ 0x80000000), (int)a2, a3);
}

//----- (080A7E1A) --------------------------------------------------------
signed int __cdecl sub_80A7E1A(float *a1, float *a2, int a3)
{
  signed int v4; // [esp+4h] [ebp-10h]
  signed int v5; // [esp+8h] [ebp-Ch]
  float v6; // [esp+Ch] [ebp-8h]
  float v7; // [esp+10h] [ebp-4h]

  if ( *(_BYTE *)(a3 + 16) > 2u )
  {
    switch ( *(unsigned __int8 *)(a3 + 17) )
    {
      case 0u:
        v7 = *(float *)a3 * *a2 + *(float *)(a3 + 4) * a2[1] + *(float *)(a3 + 8) * a2[2];
        v6 = *(float *)a3 * *a1 + *(float *)(a3 + 4) * a1[1] + *(float *)(a3 + 8) * a1[2];
        break;
      case 1u:
        v7 = *(float *)a3 * *a1 + *(float *)(a3 + 4) * a2[1] + *(float *)(a3 + 8) * a2[2];
        v6 = *(float *)a3 * *a2 + *(float *)(a3 + 4) * a1[1] + *(float *)(a3 + 8) * a1[2];
        break;
      case 2u:
        v7 = *(float *)a3 * *a2 + *(float *)(a3 + 4) * a1[1] + *(float *)(a3 + 8) * a2[2];
        v6 = *(float *)a3 * *a1 + *(float *)(a3 + 4) * a2[1] + *(float *)(a3 + 8) * a1[2];
        break;
      case 3u:
        v7 = *(float *)a3 * *a1 + *(float *)(a3 + 4) * a1[1] + *(float *)(a3 + 8) * a2[2];
        v6 = *(float *)a3 * *a2 + *(float *)(a3 + 4) * a2[1] + *(float *)(a3 + 8) * a1[2];
        break;
      case 4u:
        v7 = *(float *)a3 * *a2 + *(float *)(a3 + 4) * a2[1] + *(float *)(a3 + 8) * a1[2];
        v6 = *(float *)a3 * *a1 + *(float *)(a3 + 4) * a1[1] + *(float *)(a3 + 8) * a2[2];
        break;
      case 5u:
        v7 = *(float *)a3 * *a1 + *(float *)(a3 + 4) * a2[1] + *(float *)(a3 + 8) * a1[2];
        v6 = *(float *)a3 * *a2 + *(float *)(a3 + 4) * a1[1] + *(float *)(a3 + 8) * a2[2];
        break;
      case 6u:
        v7 = *(float *)a3 * *a2 + *(float *)(a3 + 4) * a1[1] + *(float *)(a3 + 8) * a1[2];
        v6 = *(float *)a3 * *a1 + *(float *)(a3 + 4) * a2[1] + *(float *)(a3 + 8) * a2[2];
        break;
      case 7u:
        v7 = *(float *)a3 * *a1 + *(float *)(a3 + 4) * a1[1] + *(float *)(a3 + 8) * a1[2];
        v6 = *(float *)a3 * *a2 + *(float *)(a3 + 4) * a2[1] + *(float *)(a3 + 8) * a2[2];
        break;
      default:
        v6 = 0.0;
        v7 = 0.0;
        break;
    }
    v5 = 0;
    if ( v7 >= (long double)*(float *)(a3 + 12) )
      v5 = 1;
    if ( *(float *)(a3 + 12) > (long double)v6 )
      v5 |= 2u;
    v4 = v5;
  }
  else if ( a1[*(unsigned __int8 *)(a3 + 16)] < (long double)*(float *)(a3 + 12) )
  {
    if ( *(float *)(a3 + 12) < (long double)a2[*(unsigned __int8 *)(a3 + 16)] )
      v4 = 3;
    else
      v4 = 2;
  }
  else
  {
    v4 = 1;
  }
  return v4;
}

//----- (080A81F8) --------------------------------------------------------
int __cdecl sub_80A81F8(int a1, float a2, int a3, float a4, float a5, float a6, float a7)
{
  float v7; // ST1C_4
  float v8; // ST18_4
  float v9; // ST14_4
  float v12; // [esp+14h] [ebp-24h]
  char v13; // [esp+20h] [ebp-18h]

  sub_80A8DE8((float *)a1, (float *)a3, (float *)&v13);
  v7 = sub_80A215E((float *)&v13);
  v8 = v7 - a2;
  if ( v8 * v8 > a4 * a4 )
    return 0;
  if ( *(float *)(a3 + 8) - a7 <= (long double)*(float *)(a1 + 8) && *(float *)(a1 + 8) <= *(float *)(a3 + 8) + a7 )
  {
    v9 = sub_80A29F6((float *)&v13);
    v12 = sub_80A60CE(v9);
    if ( a6 <= (long double)a5 )
    {
      if ( a6 > (long double)v12 || v12 > (long double)a5 )
        return 1;
    }
    else if ( a6 > (long double)v12 && v12 > (long double)a5 )
    {
      return 1;
    }
    return 0;
  }
  return 0;
}

//----- (080A831C) --------------------------------------------------------
_BOOL4 __cdecl sub_80A831C(int a1, int a2, int a3, float a4)
{
  float v5; // [esp+10h] [ebp-48h]
  float v6; // [esp+14h] [ebp-44h]
  float v7; // [esp+18h] [ebp-40h]
  float v8; // [esp+1Ch] [ebp-3Ch]
  float v9[4]; // [esp+20h] [ebp-38h]
  float v10[7]; // [esp+30h] [ebp-28h]
  int i; // [esp+4Ch] [ebp-Ch]

  sub_80A8DE8((float *)a1, (float *)a3, v10);
  sub_80A8DE8((float *)a2, (float *)a3, v9);
  v8 = 0.0;
  for ( i = 0; i <= 2; ++i )
  {
    if ( v10[i] * v9[i] > 0.0 )
    {
      v7 = v10[i] * v10[i];
      v6 = v9[i] * v9[i];
      if ( v7 <= (long double)v6 )
        v5 = v8 + v7;
      else
        v5 = v8 + v6;
      v8 = v5;
    }
  }
  return v8 > (long double)a4;
}
// 80A831C: using guessed type float var_28[7];
// 80A831C: using guessed type float var_38[4];

//----- (080A84C6) --------------------------------------------------------
int __cdecl sub_80A84C6(_DWORD *a1, int a2, _DWORD *a3)
{
  int v4[2]; // [esp+20h] [ebp-68h]
  int v5[2]; // [esp+28h] [ebp-60h]
  double v6; // [esp+30h] [ebp-58h]
  int i; // [esp+3Ch] [ebp-4Ch]
  int v8; // [esp+40h] [ebp-48h]
  int v9; // [esp+44h] [ebp-44h]
  int v10; // [esp+48h] [ebp-40h]
  int v11; // [esp+4Ch] [ebp-3Ch]
  int v12; // [esp+50h] [ebp-38h]
  int v13; // [esp+54h] [ebp-34h]
  float v14[4]; // [esp+60h] [ebp-28h]
  float v15[6]; // [esp+70h] [ebp-18h]

  sub_80A8D74(a1, v14);
  sub_80A8D74(v14, v15);
  v8 = 1;
  v9 = 2;
  v10 = 2;
  v11 = 0;
  v12 = 0;
  v13 = 1;
  for ( i = 0; i <= 2; ++i )
  {
    if ( *(float *)(a2 + 4 * i) != 0.0 )
    {
      v6 = *(float *)(a2 + 4 * i) * 3.141592653589793 / 180.0;
      sub_80A8C4A(v6, (int)v4, (int)v5);
      v15[*(&v8 + 2 * i)] = v14[*(&v8 + 2 * i)] * *(double *)v5 - v14[*(&v9 + 2 * i)] * *(double *)v4;
      v15[*(&v9 + 2 * i)] = v14[*(&v8 + 2 * i)] * *(double *)v4 + v14[*(&v9 + 2 * i)] * *(double *)v5;
    }
    sub_80A8D74(v15, v14);
  }
  return sub_80A8D74(v15, a3);
}
// 80A84C6: using guessed type float var_28[4];
// 80A84C6: using guessed type float var_18[6];

//----- (080A8610) --------------------------------------------------------
int __cdecl sub_80A8610(float *a1, int a2, float *a3, float *a4)
{
  float v5[4]; // [esp+10h] [ebp-28h]
  float v6[6]; // [esp+20h] [ebp-18h]

  sub_80A8DE8(a1, a3, v6);
  sub_80A84C6(v6, a2, v5);
  return sub_80A8DA4(v5, a3, a4);
}

//----- (080A8664) --------------------------------------------------------
int __cdecl sub_80A8664(int a1, float a2, float a3)
{
  int result; // eax
  int v4; // [esp+18h] [ebp-10h]
  int v5; // [esp+1Ch] [ebp-Ch]
  int v6; // [esp+20h] [ebp-8h]
  int v7; // [esp+24h] [ebp-4h]

  sub_80A8C1C(a3, (int)&v7, (int)&v6);
  sub_80A8C1C(a3, (int)&v5, (int)&v4);
  *(float *)a1 = a2 * *(float *)&v6 * *(float *)&v4;
  *(float *)(a1 + 4) = a2 * *(float *)&v7 * *(float *)&v4;
  result = a1 + 8;
  *(float *)(a1 + 8) = a2 * *(float *)&v5;
  return result;
}

//----- (080A86CC) --------------------------------------------------------
void __cdecl sub_80A86CC(float a1, int a2)
{
  char v2; // [esp+10h] [ebp-28h]
  int v3; // [esp+20h] [ebp-18h]

  sub_80A303A(a1, (int)&v3, 0);
  sub_80A7D80((float *)&v3, (float *)a2, (int)&v2);
  sub_80A2AF6((float *)&v2);
}

//----- (080A8712) --------------------------------------------------------
int __cdecl sub_80A8712(int a1)
{
  int result; // eax

  result = a1;
  dword_815DE98 = a1;
  return result;
}
// 815DE98: using guessed type int dword_815DE98;

//----- (080A8720) --------------------------------------------------------
long double __cdecl sub_80A8720(float a1, float a2)
{
  float v2; // ST0C_4

  dword_815DE98 = 214013 * dword_815DE98 + 2531011;
  v2 = (long double)((unsigned int)dword_815DE98 >> 17);
  return (float)((a2 - a1) * v2 / 32768.0 + a1);
}
// 815DE98: using guessed type int dword_815DE98;

//----- (080A8776) --------------------------------------------------------
int __cdecl sub_80A8776(int a1, int a2)
{
  dword_815DE98 = 214013 * dword_815DE98 + 2531011;
  return a1 + ((signed int)(((unsigned int)dword_815DE98 >> 17) * (a2 - a1)) >> 15);
}
// 815DE98: using guessed type int dword_815DE98;

//----- (080A87D8) --------------------------------------------------------
int __cdecl sub_80A87D8(float *a1, int a2)
{
  float v2; // ST1C_4
  float x; // [esp+20h] [ebp-58h]
  float v5; // [esp+24h] [ebp-54h]
  signed int v6; // [esp+28h] [ebp-50h]
  signed int i; // [esp+2Ch] [ebp-4Ch]
  float v8; // [esp+30h] [ebp-48h]
  float v9; // [esp+34h] [ebp-44h]
  float v10; // [esp+38h] [ebp-40h]
  float v11; // [esp+3Ch] [ebp-3Ch]
  float v12; // [esp+40h] [ebp-38h]
  float v13; // [esp+44h] [ebp-34h]
  float v14; // [esp+48h] [ebp-30h]
  float v15; // [esp+4Ch] [ebp-2Ch]
  float v16; // [esp+50h] [ebp-28h]
  float v17; // [esp+54h] [ebp-24h]
  float v18; // [esp+58h] [ebp-20h]
  float v19; // [esp+5Ch] [ebp-1Ch]
  float v20; // [esp+60h] [ebp-18h]
  float v21; // [esp+64h] [ebp-14h]
  float v22; // [esp+68h] [ebp-10h]
  float v23; // [esp+6Ch] [ebp-Ch]

  v8 = a1[5] - a1[7];
  v9 = a1[6] - a1[2];
  v10 = a1[1] - a1[3];
  v11 = *a1 + a1[4] + a1[8] + 1.0;
  v12 = *a1 - a1[4] - a1[8] + 1.0;
  v13 = a1[3] + a1[1];
  v14 = a1[6] + a1[2];
  v15 = v8;
  v16 = v13;
  v17 = a1[4] - *a1 - a1[8] + 1.0;
  v18 = a1[7] + a1[5];
  v19 = v9;
  v20 = v14;
  v21 = v18;
  v22 = a1[8] - a1[4] - *a1 + 1.0;
  v23 = v10;
  v6 = -1;
  x = 0.0;
  for ( i = 0; i <= 3; ++i )
  {
    v5 = sub_80A9024(&v8 + 4 * i);
    if ( x < (long double)v5 )
    {
      x = v5;
      v6 = i;
    }
  }
  v2 = 1.0 / sqrtf(x);
  return sub_80A8FD8((int)(&v8 + 4 * v6), v2, a2);
}

//----- (080A8972) --------------------------------------------------------
void __cdecl sub_80A8972(float a1, int a2, int a3)
{
  float v3; // ST00_4

  if ( a1 < 0.0 )
    a1 = a1 + 360.0;
  if ( a1 == 0.0 )
  {
    *(_DWORD *)a3 = 1065353216;
    *(_DWORD *)a2 = 0;
  }
  else if ( a1 == 90.0 )
  {
    *(_DWORD *)a3 = 0;
    *(_DWORD *)a2 = 1065353216;
  }
  else if ( a1 == 180.0 )
  {
    *(_DWORD *)a3 = -1082130432;
    *(_DWORD *)a2 = 0;
  }
  else if ( a1 == 270.0 )
  {
    *(_DWORD *)a3 = 0;
    *(_DWORD *)a2 = -1082130432;
  }
  else
  {
    v3 = a1 * 0.0174532925199433;
    sub_80A8C1C(v3, a2, a3);
  }
}

//----- (080A8A66) --------------------------------------------------------
long double __cdecl sub_80A8A66(int a1, int a2, char a3)
{
  signed int v4; // [esp+8h] [ebp-Ch]
  int v5; // [esp+Ch] [ebp-8h]
  int v6; // [esp+10h] [ebp-4h]

  v4 = 1 << a3;
  v6 = a1;
  v5 = a1 & ((1 << a3) - 1);
  if ( (a1 & ((1 << a3) - 1)) > a2 )
  {
    if ( v4 - v5 <= a2 )
      v6 = v4 - v5 + a1;
  }
  else
  {
    v6 = a1 - v5;
  }
  return *(float *)&v6;
}

//----- (080A8B40) --------------------------------------------------------
long double __cdecl sub_80A8B40(float a1)
{
  return (float)fabs(a1);
}

//----- (080A8B5A) --------------------------------------------------------
long double __cdecl sub_80A8B5A(float a1)
{
  return (float)sqrt(a1);
}

//----- (080A8B7A) --------------------------------------------------------
void __cdecl sub_80A8B7A(float a1, float a2)
{
  float v2; // ST00_4

  v2 = a1 - a2;
  sub_80A906A(v2, a1, a2);
}

//----- (080A8B9E) --------------------------------------------------------
long double __cdecl sub_80A8B9E(float a1, float a2, float a3)
{
  float v3; // ST00_4
  float v4; // ST08_4
  float v5; // ST00_4

  v3 = a1 - a3;
  v4 = sub_80A906A(v3, a3, a1);
  v5 = a2 - a1;
  return sub_80A906A(v5, a2, v4);
}

//----- (080A8BDC) --------------------------------------------------------
int __cdecl sub_80A8BDC(int a1)
{
  return *(_DWORD *)a1;
}

//----- (080A8BE6) --------------------------------------------------------
int __cdecl sub_80A8BE6(float a1)
{
  return (signed int)floor(a1 + 0.5);
}

//----- (080A8C1C) --------------------------------------------------------
void __cdecl sub_80A8C1C(float a1, int a2, int a3)
{
  *(float *)a2 = sin(a1);
  *(float *)a3 = cos(a1);
}

//----- (080A8C4A) --------------------------------------------------------
int __cdecl sub_80A8C4A(double a1, int a2, int a3)
{
  long double v3; // fst7
  int result; // eax

  *(double *)a2 = sin(a1);
  v3 = cos(a1);
  result = a3;
  *(double *)a3 = v3;
  return result;
}

//----- (080A8C78) --------------------------------------------------------
int __cdecl sub_80A8C78(_DWORD *a1)
{
  int result; // eax

  *a1 = 0;
  result = 0;
  a1[1] = 0;
  return result;
}

//----- (080A8C94) --------------------------------------------------------
int __cdecl sub_80A8C94(_DWORD *a1, int a2, int a3)
{
  int result; // eax

  *a1 = a2;
  result = a3;
  a1[1] = a3;
  return result;
}

//----- (080A8CAC) --------------------------------------------------------
int __cdecl sub_80A8CAC(float *a1, float *a2, float *a3)
{
  int result; // eax

  *a3 = *a1 - *a2;
  result = (int)(a1 + 1);
  a3[1] = a1[1] - a2[1];
  return result;
}

//----- (080A8CD8) --------------------------------------------------------
long double __cdecl sub_80A8CD8(float *a1, float *a2)
{
  return *a1 * *a2 + a1[1] * a2[1];
}

//----- (080A8CFA) --------------------------------------------------------
void __cdecl sub_80A8CFA(float *a1)
{
  float v1; // ST00_4

  v1 = *a1 * *a1 + a1[1] * a1[1];
  sub_80A8B5A(v1);
}

//----- (080A8D26) --------------------------------------------------------
int __cdecl sub_80A8D26(_DWORD *a1)
{
  int result; // eax

  *a1 = 0;
  a1[1] = 0;
  result = 0;
  a1[2] = 0;
  return result;
}

//----- (080A8D50) --------------------------------------------------------
int __cdecl sub_80A8D50(_DWORD *a1, int a2, int a3, int a4)
{
  int result; // eax

  *a1 = a2;
  a1[1] = a3;
  result = a4;
  a1[2] = a4;
  return result;
}

//----- (080A8D74) --------------------------------------------------------
int __cdecl sub_80A8D74(_DWORD *a1, _DWORD *a2)
{
  int result; // eax

  *a2 = *a1;
  a2[1] = a1[1];
  result = a1[2];
  a2[2] = result;
  return result;
}

//----- (080A8DA4) --------------------------------------------------------
int __cdecl sub_80A8DA4(float *a1, float *a2, float *a3)
{
  int result; // eax

  *a3 = *a1 + *a2;
  a3[1] = a1[1] + a2[1];
  result = (int)(a1 + 2);
  a3[2] = a1[2] + a2[2];
  return result;
}

//----- (080A8DE8) --------------------------------------------------------
int __cdecl sub_80A8DE8(float *a1, float *a2, float *a3)
{
  int result; // eax

  *a3 = *a1 - *a2;
  a3[1] = a1[1] - a2[1];
  result = (int)(a1 + 2);
  a3[2] = a1[2] - a2[2];
  return result;
}

//----- (080A8E2C) --------------------------------------------------------
int __cdecl sub_80A8E2C(int a1, float a2, int a3)
{
  int result; // eax

  *(float *)a3 = a2 * *(float *)a1;
  *(float *)(a3 + 4) = a2 * *(float *)(a1 + 4);
  result = a1 + 8;
  *(float *)(a3 + 8) = a2 * *(float *)(a1 + 8);
  return result;
}

//----- (080A8E64) --------------------------------------------------------
int __cdecl sub_80A8E64(float *a1, float *a2, float *a3)
{
  int result; // eax

  *a3 = *a1 * *a2;
  a3[1] = a1[1] * a2[1];
  result = (int)(a1 + 2);
  a3[2] = a1[2] * a2[2];
  return result;
}

//----- (080A8EA8) --------------------------------------------------------
int __cdecl sub_80A8EA8(int a1, float a2, int a3, int a4)
{
  int result; // eax

  *(float *)a4 = a2 * *(float *)a3 + *(float *)a1;
  *(float *)(a4 + 4) = a2 * *(float *)(a3 + 4) + *(float *)(a1 + 4);
  result = a3 + 8;
  *(float *)(a4 + 8) = a2 * *(float *)(a3 + 8) + *(float *)(a1 + 8);
  return result;
}

//----- (080A8EFC) --------------------------------------------------------
long double __cdecl sub_80A8EFC(float *a1, float *a2)
{
  return *a1 * *a2 + a1[1] * a2[1] + a1[2] * a2[2];
}

//----- (080A8F30) --------------------------------------------------------
signed int __cdecl sub_80A8F30(float *a1, float *a2)
{
  signed int v3; // [esp+0h] [ebp-4h]

  v3 = 0;
  if ( *a1 == *a2 && a1[1] == a2[1] && a1[2] == a2[2] )
    v3 = 1;
  return v3;
}

//----- (080A8F9A) --------------------------------------------------------
void __cdecl sub_80A8F9A(float *a1)
{
  float v1; // ST00_4

  v1 = *a1 * *a1 + a1[1] * a1[1] + a1[2] * a1[2];
  sub_80A8B5A(v1);
}

//----- (080A8FD8) --------------------------------------------------------
int __cdecl sub_80A8FD8(int a1, float a2, int a3)
{
  int result; // eax

  *(float *)a3 = a2 * *(float *)a1;
  *(float *)(a3 + 4) = a2 * *(float *)(a1 + 4);
  *(float *)(a3 + 8) = a2 * *(float *)(a1 + 8);
  result = a1 + 12;
  *(float *)(a3 + 12) = a2 * *(float *)(a1 + 12);
  return result;
}

//----- (080A9024) --------------------------------------------------------
long double __cdecl sub_80A9024(float *a1)
{
  return *a1 * *a1 + a1[1] * a1[1] + a1[2] * a1[2] + a1[3] * a1[3];
}

//----- (080A906A) --------------------------------------------------------
long double __cdecl sub_80A906A(float a1, float a2, float a3)
{
  float v4; // [esp+0h] [ebp-4h]

  if ( a1 < 0.0 )
    v4 = a3;
  else
    v4 = a2;
  return v4;
}

//----- (080A9094) --------------------------------------------------------
float *__cdecl sub_80A9094(float *a1, float *a2, float *a3)
{
  float *result; // eax
  float v4; // [esp+10h] [ebp-38h]
  float v5; // [esp+14h] [ebp-34h]
  float v6; // [esp+18h] [ebp-30h]
  float v7; // [esp+1Ch] [ebp-2Ch]
  float v8; // [esp+20h] [ebp-28h]
  float v9; // [esp+24h] [ebp-24h]
  float v10; // [esp+28h] [ebp-20h]
  float v11; // [esp+2Ch] [ebp-1Ch]
  float v12; // [esp+30h] [ebp-18h]

  sub_80A913C(a2, &v4);
  *a3 = *a1 * v4 + a1[1] * v7 + a1[2] * v10 + a2[4];
  a3[1] = *a1 * v5 + a1[1] * v8 + a1[2] * v11 + a2[5];
  result = a2;
  a3[2] = *a1 * v6 + a1[1] * v9 + a1[2] * v12 + a2[6];
  return result;
}

//----- (080A913C) --------------------------------------------------------
int __cdecl sub_80A913C(float *a1, float *a2)
{
  int result; // eax
  int v3; // [esp+10h] [ebp-48h]
  float v4; // [esp+14h] [ebp-44h]
  float v5; // [esp+18h] [ebp-40h]
  float v6; // [esp+2Ch] [ebp-2Ch]
  float v7; // [esp+30h] [ebp-28h]
  float v8; // [esp+34h] [ebp-24h]
  float v9; // [esp+38h] [ebp-20h]
  float v10; // [esp+3Ch] [ebp-1Ch]
  float v11; // [esp+40h] [ebp-18h]
  float v12; // [esp+44h] [ebp-14h]
  float v13; // [esp+48h] [ebp-10h]
  float v14; // [esp+4Ch] [ebp-Ch]

  sub_80A8E2C((int)a1, a1[7], (int)&v3);
  v14 = *(float *)&v3 * *a1;
  v13 = *(float *)&v3 * a1[1];
  v12 = *(float *)&v3 * a1[2];
  v11 = *(float *)&v3 * a1[3];
  v10 = v4 * a1[1];
  v9 = v4 * a1[2];
  v8 = v4 * a1[3];
  v7 = v5 * a1[2];
  v6 = v5 * a1[3];
  *a2 = 1.0 - (v10 + v7);
  a2[1] = v13 + v6;
  a2[2] = v12 - v8;
  a2[3] = v13 - v6;
  a2[4] = 1.0 - (v14 + v7);
  a2[5] = v9 + v11;
  a2[6] = v12 + v8;
  a2[7] = v9 - v11;
  result = (int)(a2 + 8);
  a2[8] = 1.0 - (v14 + v10);
  return result;
}

//----- (080A9254) --------------------------------------------------------
void __cdecl Z_FreeInternal(void *ptr)
{
  free(ptr);
}

//----- (080A9268) --------------------------------------------------------
void __cdecl sub_80A9268(void *ptr)
{
  free(ptr);
}

//----- (080A9290) --------------------------------------------------------
void __noreturn sub_80A9290()
{
  sub_80D1DA6((int)"universal/com_memory.cpp", 228);
}

//----- (080A92AC) --------------------------------------------------------
void *__cdecl sub_80A92AC(size_t size)
{
  return malloc(size);
}

//----- (080A92C0) --------------------------------------------------------
void *__cdecl sub_80A92C0(size_t size)
{
  void *s; // [esp+14h] [ebp-4h]

  s = sub_80A92AC(size);
  if ( s )
    sub_80AA83E(s, 0, size);
  return s;
}

//----- (080A92FA) --------------------------------------------------------
void *__cdecl Z_MallocInternal(size_t size)
{
  void *v2; // [esp+4h] [ebp-4h]

  v2 = sub_80A92C0(size);
  if ( !v2 )
    sub_80A9290();
  return v2;
}

//----- (080A9324) --------------------------------------------------------
void *__cdecl sub_80A9324(size_t size)
{
  void *v2; // [esp+4h] [ebp-4h]

  v2 = sub_80A92AC(size);
  if ( !v2 )
    sub_80A9290();
  return v2;
}

//----- (080A934E) --------------------------------------------------------
void *__cdecl sub_80A934E(size_t size)
{
  return malloc(size);
}

//----- (080A9362) --------------------------------------------------------
void *__cdecl sub_80A9362(size_t size)
{
  void *v2; // [esp+14h] [ebp-4h]

  v2 = sub_80A934E(size);
  if ( !v2 )
    sub_80D1DA6((int)"universal/com_memory.cpp", 536);
  return v2;
}

//----- (080A93B0) --------------------------------------------------------
char *__cdecl sub_80A93B0(char *src)
{
  size_t v1; // eax
  char *dest; // ST14_4

  v1 = I_strlen(src);
  dest = (char *)Z_MallocInternal(v1 + 1);
  strcpy(dest, src);
  return dest;
}

//----- (080A93E4) --------------------------------------------------------
char *__cdecl sub_80A93E4(int a1, char *src)
{
  size_t v3; // [esp+10h] [ebp-8h]
  char *s; // [esp+14h] [ebp-4h]

  v3 = I_strlen(src);
  s = *(char **)a1;
  if ( *(_DWORD *)a1 && strlen(s) < v3 )
  {
    Z_FreeInternal(s);
    s = 0;
  }
  if ( !s )
  {
    s = (char *)Z_MallocInternal(v3 + 1);
    *(_DWORD *)a1 = s;
  }
  return strcpy(s, src);
}

//----- (080A945A) --------------------------------------------------------
void sub_80A945A()
{
  Com_Printf("%8i bytes total hunk\n", s_hunkTotal);
  Com_Printf("\n");
  Com_Printf("%8i low permanent\n", *(_DWORD *)hunk_low.permanent);
  if ( *(_DWORD *)hunk_low.temp != *(_DWORD *)hunk_low.permanent )
    Com_Printf("%8i low temp\n", *(_DWORD *)hunk_low.temp);
  Com_Printf("\n");
  Com_Printf("%8i high permanent\n", *(_DWORD *)hunk_high.permanent);
  if ( *(_DWORD *)hunk_high.temp != *(_DWORD *)hunk_high.permanent )
    Com_Printf("%8i high temp\n", *(_DWORD *)hunk_high.temp);
  Com_Printf("\n");
  Com_Printf("%8i total hunk in use\n", *(_DWORD *)hunk_low.permanent + *(_DWORD *)hunk_high.permanent);
  Com_Printf("\n");
}

//----- (080A9530) --------------------------------------------------------
void sub_80A9530()
{
  int v0; // ST20_4
  int v1; // [esp+14h] [ebp-14h]
  int i; // [esp+1Ch] [ebp-Ch]
  signed int j; // [esp+1Ch] [ebp-Ch]
  int v4; // [esp+24h] [ebp-4h]

  v4 = Sys_MilliSeconds();
  v1 = 0;
  for ( i = 0; i < *(_DWORD *)hunk_low.permanent >> 2; i += 64 )
    v1 += *(_DWORD *)(dword_8515294 + 4 * i);
  for ( j = (signed int)(s_hunkTotal - *(_DWORD *)hunk_high.permanent) >> 2; j < *(_DWORD *)hunk_high.permanent >> 2; j += 64 )
    v1 += *(_DWORD *)(dword_8515294 + 4 * j);
  v0 = Sys_MilliSeconds();
  Com_Printf("Com_TouchMemory: %i msec. Using sum: %d\n", v0 - v4, v1);
}
// 8515294: using guessed type int dword_8515294;

//----- (080A95F0) --------------------------------------------------------
void __usercall Com_InitHunkMemory(long double a1@<st0>)
{
  char *v1; // [esp+14h] [ebp-4h]

  if ( FS_LoadStack() )
    Com_Error(0, &byte_8146220);
  v1 = Dvar_RegisterInt(a1, "com_hunkMegs", 160, 1, 512, 4129);
  if ( *((_DWORD *)v1 + 2) > 79 )
  {
    s_hunkTotal = *((_DWORD *)v1 + 2) << 20;
  }
  else
  {
    Com_Printf("Minimum com_hunkMegs for a dedicated server is %i, allocating %i megs.\n", 80, 80);
    s_hunkTotal = 83886080;
  }
  dword_8515294 = (int)malloc(s_hunkTotal);
  if ( !dword_8515294 )
    sub_80D1DA6((int)"universal/com_memory.cpp", 864);
  dword_8515298 = (void *)dword_8515294;
  Hunk_Clear();
  Cmd_AddCommand("meminfo", (int)sub_80A945A);
}
// 8515294: using guessed type int dword_8515294;

//----- (080A96D6) --------------------------------------------------------
void *sub_80A96D6()
{
  free(dword_8515298);
  dword_8515294 = 0;
  dword_8515298 = 0;
  s_hunkTotal = 0;
  memset(hunk_low.permanent, 0, 8u);
  return memset(hunk_high.permanent, 0, 8u);
}
// 8515294: using guessed type int dword_8515294;

//----- (080A9742) --------------------------------------------------------
int __cdecl sub_80A9742(int a1, char *s2, int a3)
{
  int i; // [esp+14h] [ebp-4h]

  for ( i = dword_8494220[a3]; i; i = *(_DWORD *)(i + 4) )
  {
    if ( *(unsigned __int8 *)(i + 8) == a1 && !strcasecmp((const char *)(i + 9), s2) )
      return *(_DWORD *)i;
  }
  return 0;
}

//----- (080A97A6) --------------------------------------------------------
int __cdecl sub_80A97A6(int a1, char *s2)
{
  int v2; // ST14_4

  v2 = FS_HashFileName((int)s2, 1024);
  return sub_80A9742(a1, s2, v2);
}

//----- (080A97DE) --------------------------------------------------------
_BOOL4 __cdecl sub_80A97DE(size_t a1)
{
  _BOOL4 v2; // [esp+0h] [ebp-4h]

  if ( a1 >= dword_8515294 )
    v2 = a1 < dword_8515294 + s_hunkTotal;
  else
    v2 = 0;
  return v2;
}
// 8515294: using guessed type int dword_8515294;

//----- (080A981E) --------------------------------------------------------
int __cdecl sub_80A981E(char a1, char *src, int a3, int a4)
{
  int v4; // ST14_4
  size_t v5; // eax
  int v6; // eax
  int v7; // ST10_4

  v4 = FS_HashFileName((int)src, 1024);
  v5 = I_strlen(src);
  v6 = ((int (__cdecl *)(size_t))a4)(v5 + 10);
  v7 = v6;
  *(_DWORD *)v6 = a3;
  *(_BYTE *)(v6 + 8) = a1;
  strcpy((char *)(v6 + 9), src);
  *(_DWORD *)(v7 + 4) = dword_8494220[v4];
  dword_8494220[v4] = v7;
  return v7 + 9;
}

//----- (080A98A0) --------------------------------------------------------
int __cdecl sub_80A98A0(char a1, int a2, int (__cdecl *a3)(signed int))
{
  int result; // eax

  result = a3(9);
  *(_DWORD *)result = a2;
  *(_BYTE *)(result + 8) = a1;
  *(_DWORD *)(result + 4) = dword_8495220;
  dword_8495220 = result;
  return result;
}
// 8495220: using guessed type int dword_8495220;

//----- (080A98DC) --------------------------------------------------------
int __cdecl sub_80A98DC(int a1, char *s2, int a3)
{
  int result; // eax
  int i; // [esp+10h] [ebp-8h]

  result = dword_8494220[FS_HashFileName((int)s2, 1024)];
  for ( i = result; i; i = *(_DWORD *)(i + 4) )
  {
    if ( *(unsigned __int8 *)(i + 8) == a1 && !strcasecmp((const char *)(i + 9), s2) )
    {
      result = a3;
      *(_DWORD *)i = a3;
      return result;
    }
    result = *(_DWORD *)(i + 4);
  }
  return result;
}

//----- (080A994C) --------------------------------------------------------
unsigned int *__cdecl Hunk_ClearDataFor(unsigned int *a1, unsigned int a2, unsigned int a3)
{
  unsigned int *result; // eax
  signed int v4; // [esp+Ch] [ebp-Ch]
  signed __int16 *v5; // [esp+10h] [ebp-8h]
  unsigned int v6; // [esp+14h] [ebp-4h]

  while ( 1 )
  {
    result = a1;
    if ( !*a1 )
      break;
    v6 = *a1;
    if ( *a1 >= a2 && v6 < a3 )
    {
      *a1 = *(_DWORD *)(v6 + 4);
      v5 = *(signed __int16 **)v6;
      v4 = *(unsigned __int8 *)(v6 + 8);
      if ( v4 == 4 )
      {
        sub_80C2DB2((int)v5);
      }
      else if ( v4 > 4 )
      {
        if ( v4 == 5 )
        {
          sub_80BA256((int)v5);
        }
        else if ( v4 == 6 )
        {
          sub_80BA704((int)v5);
        }
      }
      else if ( v4 == 3 )
      {
        sub_80C2D62(v5);
      }
    }
    else
    {
      a1 = (unsigned int *)(v6 + 4);
    }
  }
  return result;
}

//----- (080A9A04) --------------------------------------------------------
unsigned int *Hunk_ClearData()
{
  unsigned int i; // [esp+1Ch] [ebp-Ch]
  unsigned int v2; // [esp+20h] [ebp-8h]
  unsigned int v3; // [esp+24h] [ebp-4h]

  v3 = dword_8515294 + *(_DWORD *)hunk_low.permanent;
  v2 = dword_8515294 + s_hunkTotal - *(_DWORD *)hunk_high.permanent;
  for ( i = 0; i <= 0x3FF; ++i )
    Hunk_ClearDataFor((unsigned int *)&dword_8494220[i], v3, v2);
  return Hunk_ClearDataFor((unsigned int *)&dword_8495220, v3, v2);
}
// 8495220: using guessed type int dword_8495220;
// 8515294: using guessed type int dword_8515294;

//----- (080A9A8E) --------------------------------------------------------
int __cdecl sub_80A9A8E(int a1, int a2, void (__cdecl *a3)(_DWORD, int), int a4)
{
  int result; // eax

  while ( a1 )
  {
    if ( *(unsigned __int8 *)(a1 + 8) == a2 && *(_BYTE *)(a1 + 8) == 4 )
      a3(*(_DWORD *)a1, a4);
    result = *(_DWORD *)(a1 + 4);
    a1 = *(_DWORD *)(a1 + 4);
  }
  return result;
}

//----- (080A9AEC) --------------------------------------------------------
unsigned int *__cdecl sub_80A9AEC(unsigned int *a1, void (__cdecl *a2)(_DWORD, int), int a3, char a4)
{
  unsigned int *result; // eax
  unsigned int i; // [esp+20h] [ebp-8h]
  char v6; // [esp+27h] [ebp-1h]

  v6 = a4;
  result = a1;
  if ( a1 == (unsigned int *)1 )
  {
    for ( i = 0; i <= 0x3FF; ++i )
    {
      sub_80A9A8E(dword_8494220[i], 4, a2, a3);
      result = &i;
    }
  }
  return result;
}

//----- (080A9B52) --------------------------------------------------------
int sub_80A9B52()
{
  return *(_DWORD *)hunk_high.permanent;
}

//----- (080A9B5C) --------------------------------------------------------
unsigned int *__cdecl sub_80A9B5C(int a1)
{
  *(_DWORD *)hunk_high.temp = a1;
  *(_DWORD *)hunk_high.permanent = a1;
  return Hunk_ClearData();
}

//----- (080A9B80) --------------------------------------------------------
unsigned int *__cdecl sub_80A9B80(int a1)
{
  *(_DWORD *)hunk_low.temp = a1;
  *(_DWORD *)hunk_low.permanent = a1;
  return Hunk_ClearData();
}

//----- (080A9B9A) --------------------------------------------------------
unsigned int *Hunk_Clear()
{
  *(_DWORD *)hunk_low.permanent = 0;
  *(_DWORD *)hunk_low.temp = 0;
  *(_DWORD *)hunk_high.permanent = 0;
  *(_DWORD *)hunk_high.temp = 0;
  return Hunk_ClearData();
}

//----- (080A9BE0) --------------------------------------------------------
void *__cdecl Hunk_AllocInternal(size_t n)
{
  return Hunk_AllocAlignInternal(n, 32);
}

//----- (080A9BFC) --------------------------------------------------------
void *__cdecl Hunk_AllocAlignInternal(size_t n, int a2)
{
  void *s; // [esp+24h] [ebp-4h]

  *(_DWORD *)hunk_high.permanent += n;
  *(_DWORD *)hunk_high.permanent = (a2 - 1 + *(_DWORD *)hunk_high.permanent) & ~(a2 - 1);
  s = (void *)(dword_8515294 + s_hunkTotal - *(_DWORD *)hunk_high.permanent);
  *(_DWORD *)hunk_high.temp = *(_DWORD *)hunk_high.permanent;
  if ( *(_DWORD *)hunk_low.temp + *(_DWORD *)hunk_high.permanent > (signed int)s_hunkTotal )
    Com_Error(
      1,
      &byte_81462E0,
      n,
      (signed int)s_hunkTotal / 0x100000,
      *(_DWORD *)hunk_low.temp / 0x100000,
      *(_DWORD *)hunk_high.temp / 0x100000);
  memset(s, 0, n);
  return s;
}
// 8515294: using guessed type int dword_8515294;

//----- (080A9CF0) --------------------------------------------------------
size_t __cdecl sub_80A9CF0(int a1)
{
  *(_DWORD *)hunk_high.temp += a1;
  *(_DWORD *)hunk_high.temp = (*(_DWORD *)hunk_high.temp + 15) & 0xFFFFFFF0;
  if ( *(_DWORD *)hunk_low.temp + *(_DWORD *)hunk_high.temp > (signed int)s_hunkTotal )
    Com_Error(
      1,
      &byte_8146340,
      a1,
      (signed int)s_hunkTotal / 0x100000,
      *(_DWORD *)hunk_low.temp / 0x100000,
      *(_DWORD *)hunk_high.temp / 0x100000);
  return dword_8515294 + s_hunkTotal - *(_DWORD *)hunk_high.temp;
}
// 8515294: using guessed type int dword_8515294;

//----- (080A9DB4) --------------------------------------------------------
int sub_80A9DB4()
{
  int result; // eax

  result = *(_DWORD *)hunk_high.permanent;
  *(_DWORD *)hunk_high.temp = *(_DWORD *)hunk_high.permanent;
  return result;
}

//----- (080A9DC4) --------------------------------------------------------
void *__cdecl sub_80A9DC4(size_t n)
{
  return sub_80A9DE0(n, 32);
}

//----- (080A9DE0) --------------------------------------------------------
void *__cdecl sub_80A9DE0(size_t n, int a2)
{
  void *s; // [esp+24h] [ebp-4h]

  *(_DWORD *)hunk_low.permanent = (a2 - 1 + *(_DWORD *)hunk_low.permanent) & ~(a2 - 1);
  s = (void *)(dword_8515294 + *(_DWORD *)hunk_low.permanent);
  *(_DWORD *)hunk_low.permanent += n;
  *(_DWORD *)hunk_low.temp = *(_DWORD *)hunk_low.permanent;
  if ( *(_DWORD *)hunk_low.permanent + *(_DWORD *)hunk_high.temp > (signed int)s_hunkTotal )
    Com_Error(
      1,
      &byte_81463A0,
      n,
      (signed int)s_hunkTotal / 0x100000,
      *(_DWORD *)hunk_low.temp / 0x100000,
      *(_DWORD *)hunk_high.temp / 0x100000);
  memset(s, 0, n);
  return s;
}
// 8515294: using guessed type int dword_8515294;

//----- (080A9ECE) --------------------------------------------------------
int sub_80A9ECE()
{
  int result; // eax

  result = *(_DWORD *)hunk_low.temp;
  *(_DWORD *)hunk_low.permanent = *(_DWORD *)hunk_low.temp;
  return result;
}

//----- (080A9EDE) --------------------------------------------------------
_DWORD *__cdecl Hunk_AllocateTempMemory(size_t size)
{
  int v3; // [esp+2Ch] [ebp-Ch]
  _DWORD *v4; // [esp+34h] [ebp-4h]
  size_t sizea; // [esp+40h] [ebp+8h]

  if ( !dword_8515294 )
    return Z_MallocInternal(size);
  sizea = size + 16;
  v3 = *(_DWORD *)hunk_low.temp;
  *(_DWORD *)hunk_low.temp = (*(_DWORD *)hunk_low.temp + 15) & 0xFFFFFFF0;
  v4 = (_DWORD *)(dword_8515294 + *(_DWORD *)hunk_low.temp);
  *(_DWORD *)hunk_low.temp += sizea;
  if ( *(_DWORD *)hunk_low.temp + *(_DWORD *)hunk_high.temp > (signed int)s_hunkTotal )
    Com_Error(
      1,
      &byte_8146400,
      sizea,
      (signed int)s_hunkTotal / 0x100000,
      *(_DWORD *)hunk_low.temp / 0x100000,
      *(_DWORD *)hunk_high.temp / 0x100000,
      *(_DWORD *)hunk_low.temp + *(_DWORD *)hunk_high.temp - s_hunkTotal);
  *v4 = -1991018350;
  v4[1] = *(_DWORD *)hunk_low.temp - v3;
  return v4 + 4;
}
// 8515294: using guessed type int dword_8515294;

//----- (080AA00A) --------------------------------------------------------
unsigned int __cdecl sub_80AA00A(int a1)
{
  *(_DWORD *)hunk_low.temp = (*(_DWORD *)hunk_low.permanent + 31) & 0xFFFFFFE0;
  *(_DWORD *)hunk_low.temp += a1;
  if ( *(_DWORD *)hunk_low.temp + *(_DWORD *)hunk_high.temp > (signed int)s_hunkTotal )
    Com_Error(
      1,
      &byte_8146480,
      a1,
      (signed int)s_hunkTotal / 0x100000,
      *(_DWORD *)hunk_low.temp / 0x100000,
      *(_DWORD *)hunk_high.temp / 0x100000);
  return dword_8515294 + ((*(_DWORD *)hunk_low.permanent + 31) & 0xFFFFFFE0);
}
// 8515294: using guessed type int dword_8515294;

//----- (080AA0C8) --------------------------------------------------------
void __cdecl sub_80AA0C8(void *ptr)
{
  _DWORD *v1; // [esp+14h] [ebp-4h]

  if ( dword_8515294 )
  {
    v1 = (char *)ptr - 16;
    if ( *((_DWORD *)ptr - 4) != -1991018350 )
      Com_Error(0, &byte_81464E0);
    *v1 = -1991018349;
    *(_DWORD *)hunk_low.temp -= v1[1];
  }
  else
  {
    Z_FreeInternal(ptr);
  }
}
// 8515294: using guessed type int dword_8515294;

//----- (080AA124) --------------------------------------------------------
int sub_80AA124()
{
  int result; // eax

  if ( dword_8515294 )
  {
    result = *(_DWORD *)hunk_low.permanent;
    *(_DWORD *)hunk_low.temp = *(_DWORD *)hunk_low.permanent;
  }
  return result;
}
// 8515294: using guessed type int dword_8515294;

//----- (080AA13C) --------------------------------------------------------
int sub_80AA13C()
{
  int v0; // ST00_4

  v0 = *(_DWORD *)hunk_low.permanent;
  *(_DWORD *)hunk_low.permanent = *(_DWORD *)hunk_low.temp;
  return v0;
}

//----- (080AA15A) --------------------------------------------------------
int __cdecl sub_80AA15A(int a1)
{
  int result; // eax

  result = a1;
  *(_DWORD *)hunk_low.permanent = a1;
  return result;
}

//----- (080AA194) --------------------------------------------------------
int __cdecl sub_80AA194(int a1)
{
  int v1; // ST00_4

  v1 = g_largeLocalPos;
  g_largeLocalPos += (a1 + 3) & 0xFFFFFFFC;
  return v1;
}
// 8495224: using guessed type int g_largeLocalPos;

//----- (080AA1BC) --------------------------------------------------------
int __cdecl sub_80AA1BC(int a1)
{
  int result; // eax

  result = a1;
  g_largeLocalPos = a1;
  return result;
}
// 8495224: using guessed type int g_largeLocalPos;

//----- (080AA1CA) --------------------------------------------------------
char *__cdecl sub_80AA1CA(int a1)
{
  return (char *)&unk_8495280 + a1;
}

//----- (080AA1F6) --------------------------------------------------------
int __cdecl sub_80AA1F6(int *a1, int a2)
{
  int result; // eax

  result = sub_80AA194(a2);
  *a1 = result;
  return result;
}

//----- (080AA22A) --------------------------------------------------------
int __cdecl sub_80AA22A(int *a1)
{
  return sub_80AA1BC(*a1);
}

//----- (080AA240) --------------------------------------------------------
char *__cdecl sub_80AA240(int *a1)
{
  return sub_80AA1CA(*a1);
}

//----- (080AA256) --------------------------------------------------------
void LargeLocalReset()
{
  g_largeLocalPos = 0;
}
// 8495224: using guessed type int g_largeLocalPos;

//----- (080AA268) --------------------------------------------------------
char *__cdecl sub_80AA268(char *s, char *a2, int a3)
{
  size_t v3; // ebx
  signed int v6; // [esp+Ch] [ebp-Ch]
  signed int v7; // [esp+10h] [ebp-8h]

  v3 = I_strlen(s);
  v7 = v3 - I_strlen(a2);
  v6 = 0;
  while ( v6 <= v7 )
  {
    if ( !((int (__cdecl *)(char *, char *))a3)(s, a2) )
      return s;
    ++v6;
    ++s;
  }
  return 0;
}

//----- (080AA2D8) --------------------------------------------------------
int __cdecl Com_Filter(int a1, char *a2, int a3)
{
  char *v3; // eax
  int v4; // ebx
  int v5; // ebx
  int v6; // ebx
  int v7; // ebx
  signed int v10; // [esp+24h] [ebp-414h]
  int v11; // [esp+28h] [ebp-410h]
  char s[1032]; // [esp+30h] [ebp-408h]
  char *v13; // [esp+440h] [ebp+8h]

  while ( *(_BYTE *)a1 )
  {
    if ( *(_BYTE *)a1 == 42 )
    {
      ++a1;
      v11 = 0;
      while ( *(_BYTE *)a1 && *(_BYTE *)a1 != 42 && *(_BYTE *)a1 != 63 )
        s[v11++] = *(_BYTE *)a1++;
      s[v11] = 0;
      if ( s[0] )
      {
        if ( a3 )
          v3 = sub_80AA268(a2, s, (int)sub_80B5642);
        else
          v3 = sub_80AA268(a2, s, (int)I_stricmp);
        if ( !v3 )
          return 0;
        a2 = &v3[strlen(s)];
      }
    }
    else if ( *(_BYTE *)a1 == 63 )
    {
      ++a1;
      ++a2;
    }
    else if ( *(_BYTE *)a1 != 91 || *(_BYTE *)(a1 + 1) != 91 )
    {
      if ( *(_BYTE *)a1 == 91 )
      {
        v13 = (char *)(a1 + 1);
        v10 = 0;
        while ( *v13 && !v10 && (*v13 != 93 || v13[1] == 93) )
        {
          if ( v13[1] == 45 && v13[2] && (v13[2] != 93 || v13[3] == 93) )
          {
            if ( a3 )
            {
              if ( *a2 >= *v13 && *a2 <= v13[2] )
                v10 = 1;
            }
            else
            {
              v4 = toupper(*a2);
              if ( v4 >= toupper(*v13) )
              {
                v5 = toupper(*a2);
                if ( v5 <= toupper(v13[2]) )
                  v10 = 1;
              }
            }
            v13 += 3;
          }
          else
          {
            if ( a3 )
            {
              if ( *v13 == *a2 )
                v10 = 1;
            }
            else
            {
              v6 = toupper(*v13);
              if ( v6 == toupper(*a2) )
                v10 = 1;
            }
            ++v13;
          }
        }
        if ( !v10 )
          return 0;
        while ( *v13 && (*v13 != 93 || v13[1] == 93) )
          ++v13;
        a1 = (int)(v13 + 1);
        ++a2;
      }
      else
      {
        if ( a3 )
        {
          if ( *(_BYTE *)a1 != *a2 )
            return 0;
        }
        else
        {
          v7 = toupper(*(char *)a1);
          if ( v7 != toupper(*a2) )
            return 0;
        }
        ++a1;
        ++a2;
      }
    }
    else
    {
      ++a1;
    }
  }
  return 1;
}
// 80AA2D8: using guessed type char s[1032];

//----- (080AA618) --------------------------------------------------------
int __cdecl sub_80AA618(int a1, int a2, int a3)
{
  char v4[64]; // [esp+10h] [ebp-98h]
  _BYTE v5[76]; // [esp+50h] [ebp-58h]
  int i; // [esp+9Ch] [ebp-Ch]

  for ( i = 0; i <= 62 && *(_BYTE *)(a1 + i); ++i )
  {
    if ( *(_BYTE *)(a1 + i) != 92 && *(_BYTE *)(a1 + i) != 58 )
      v5[i] = *(_BYTE *)(a1 + i);
    else
      v5[i] = 47;
  }
  v5[i] = 0;
  for ( i = 0; i <= 62 && *(_BYTE *)(a2 + i); ++i )
  {
    if ( *(_BYTE *)(a2 + i) != 92 && *(_BYTE *)(a2 + i) != 58 )
      v4[i] = *(_BYTE *)(a2 + i);
    else
      v4[i] = 47;
  }
  v4[i] = 0;
  return (unsigned __int8)Com_Filter((int)v5, v4, a3);
}
// 80AA618: using guessed type char var_98[64];

//----- (080AA70C) --------------------------------------------------------
int __cdecl sub_80AA70C(int a1, int a2)
{
  int i; // [esp+0h] [ebp-8h]
  int v4; // [esp+4h] [ebp-4h]

  v4 = 0;
  for ( i = 0; i < a2 && *(_BYTE *)(i + a1); ++i )
    v4 += *(char *)(i + a1) * (i + 119);
  return (v4 >> 20) ^ (v4 >> 10) ^ v4;
}

//----- (080AA81C) --------------------------------------------------------
void *__cdecl Com_Memcpy(void *dest, void *src, size_t n)
{
  return memcpy(dest, src, n);
}

//----- (080AA83E) --------------------------------------------------------
void *__cdecl sub_80AA83E(void *s, int c, size_t n)
{
  return memset(s, c, n);
}

//----- (080AA860) --------------------------------------------------------
int __cdecl sub_80AA860(_BYTE *a1)
{
  int v2; // [esp+10h] [ebp-8h]

  v2 = 0;
  while ( *a1 )
    v2 = tolower((char)*a1++) + 31337 * v2;
  return v2 & 0x3FF;
}

//----- (080AA8AA) --------------------------------------------------------
int __cdecl sub_80AA8AA(char *a1)
{
  int i; // [esp+10h] [ebp-8h]

  if ( !a1 )
    return 0;
  for ( i = dword_85152C8[sub_80AA860(a1)]; i; i = *(_DWORD *)(i + 12) )
  {
    if ( !I_stricmp(a1, *(char **)i) )
      return i;
  }
  return 0;
}

//----- (080AA91A) --------------------------------------------------------
int __cdecl sub_80AA91A(char **a1)
{
  int i; // [esp+Ch] [ebp-Ch]
  char **v4; // [esp+10h] [ebp-8h]
  int v5; // [esp+14h] [ebp-4h]

  v5 = sub_80AA8AA(*a1);
  v4 = *(char ***)(v5 + 4);
  for ( i = 0; i < *(_DWORD *)(v5 + 8); ++i )
  {
    if ( v4 == a1 )
      return i;
    v4 += 17;
  }
  return 0;
}

//----- (080AA976) --------------------------------------------------------
int __cdecl sub_80AA976(char *a1, int a2)
{
  int i; // [esp+1Ch] [ebp-Ch]
  int v5; // [esp+20h] [ebp-8h]
  int v6; // [esp+24h] [ebp-4h]

  v6 = sub_80AA8AA(a1);
  v5 = *(_DWORD *)(v6 + 4);
  for ( i = 0; i < *(_DWORD *)(v6 + 8); ++i )
  {
    if ( i == a2 )
      return v5;
    v5 += 68;
  }
  if ( !*(_DWORD *)(v6 + 8) )
    Com_Error(1, "SND_GetAliasWithOffset: could not find sound alias '%s' with offset %d", a1, a2);
  return *(_DWORD *)(v6 + 4);
}

//----- (080AAA06) --------------------------------------------------------
signed int __cdecl sub_80AAA06(char *a1, int a2)
{
  int i; // [esp+10h] [ebp-8h]
  int v5; // [esp+14h] [ebp-4h]

  v5 = sub_80AA860(a1);
  for ( i = dword_85152C8[v5]; i; i = *(_DWORD *)(i + 12) )
  {
    if ( !I_stricmp(a1, *(char **)i) )
      return 0;
  }
  *(_DWORD *)(a2 + 12) = dword_85152C8[v5];
  dword_85152C8[v5] = a2;
  return 1;
}

//----- (080AAA84) --------------------------------------------------------
char *__cdecl sub_80AAA84(int a1, char *s)
{
  char *v2; // ST1C_4
  char *result; // eax
  char **v4; // eax
  char **v5; // ST20_4
  size_t v6; // eax
  char *dest; // ST18_4
  int i; // [esp+20h] [ebp-8h]
  int v9; // [esp+24h] [ebp-4h]

  v9 = sub_80AA860(s);
  for ( i = dword_85152C8[v9]; i; i = *(_DWORD *)(i + 12) )
  {
    if ( !I_stricmp(s, *(char **)i) )
    {
      v2 = *(char **)i;
      *(_DWORD *)i = *(_DWORD *)a1;
      *(_DWORD *)(i + 4) = *(_DWORD *)(a1 + 4);
      *(_DWORD *)(i + 8) = *(_DWORD *)(a1 + 8);
      *(_DWORD *)(i + 12) = *(_DWORD *)(a1 + 12);
      result = v2;
      *(_DWORD *)i = v2;
      return result;
    }
  }
  v4 = (char **)sub_80AB130(0x10u);
  v5 = v4;
  *v4 = *(char **)a1;
  v4[1] = *(char **)(a1 + 4);
  v4[2] = *(char **)(a1 + 8);
  v4[3] = *(char **)(a1 + 12);
  v6 = strlen(s);
  dest = (char *)sub_80AB130(v6 + 1);
  strcpy(dest, s);
  *v5 = dest;
  v5[3] = (char *)dword_85152C8[v9];
  result = (char *)v5;
  dword_85152C8[v9] = (int)v5;
  return result;
}

//----- (080AABBA) --------------------------------------------------------
void sub_80AABBA()
{
  char *dest; // ST18_4
  size_t v1; // eax
  int i; // [esp+1Ch] [ebp-Ch]
  char v3[4]; // [esp+20h] [ebp-8h]
  void *ptr; // [esp+24h] [ebp-4h]

  memset(&unk_8516354, 0, 0x480u);
  sub_80AD920(&unk_8516354);
  ptr = sub_809F7B2((int)"soundaliases", "vfcurve", 0, (int)v3);
  if ( *(_DWORD *)v3 > 15 )
    Com_Error(1, &byte_8146580, *(_DWORD *)v3, 15, 10);
  for ( i = 0; i < *(_DWORD *)v3; ++i )
  {
    dest = (char *)((i << 6) + 139552788);
    v1 = strlen(*((const char **)ptr + i));
    I_strncpyz(dest, *((char **)ptr + i), v1 - 7);
    if ( !(unsigned __int8)sub_80AD6F6((int)dest, (float *)(72 * i + 139551644)) )
      Com_Error(0, &byte_81465E0, *((_DWORD *)ptr + i));
  }
  FS_FreeFileList(ptr);
  byte_8516350 = 1;
}
// 8516350: using guessed type char byte_8516350;

//----- (080AAD12) --------------------------------------------------------
void __cdecl sub_80AAD12(char *src, int s2, int a3)
{
  int v3; // [esp+2Ch] [ebp-5Ch]
  char dest; // [esp+30h] [ebp-58h]
  int i; // [esp+74h] [ebp-14h]
  int v6; // [esp+78h] [ebp-10h]
  void *ptr; // [esp+7Ch] [ebp-Ch]

  if ( sub_80AB144(src, "maps/mp/", 8) )
  {
    if ( sub_80AB144(src, "maps/", 5) )
      strcpy(&dest, src);
    else
      sub_80B4E98(src + 5, &dest);
  }
  else
  {
    sub_80B4E98(src + 8, &dest);
  }
  strlwr(&dest);
  if ( a3 == 1 && *(_BYTE *)(com_sv_running + 8) )
  {
    dword_85162D8 = dword_85162E8;
    dword_85162DC = dword_85162EC;
    dword_85162E0 = dword_85162F0;
    dword_85162E4 = dword_85162F4;
    dword_8516300 = dword_8516308;
    dword_8516304 = dword_851630C;
  }
  else
  {
    ptr = sub_809F7B2((int)"soundaliases", "csv", 0, (int)&v6);
    if ( !v6 )
    {
      Com_Printf("WARNING: can't find any sound alias files (soundaliases/*.csv)\n");
      return;
    }
    v3 = sub_80AA13C();
    sub_80AC22C();
    for ( i = 0; i < v6; ++i )
      sub_80AC582(&dest, (char *)s2, *((char **)ptr + i));
    sub_80ACE9A(16 * a3 + 139551432, (_DWORD *)(8 * a3 + 139551480));
    sub_80AA124();
    sub_80AA15A(v3);
    FS_FreeFileList(ptr);
  }
  *(_BYTE *)(a3 + 139547328) = 1;
}
// 819EF14: using guessed type int com_sv_running;
// 85162D8: using guessed type int dword_85162D8;
// 85162DC: using guessed type int dword_85162DC;
// 85162E0: using guessed type int dword_85162E0;
// 85162E4: using guessed type int dword_85162E4;
// 85162E8: using guessed type int dword_85162E8;
// 85162EC: using guessed type int dword_85162EC;
// 85162F0: using guessed type int dword_85162F0;
// 85162F4: using guessed type int dword_85162F4;
// 8516300: using guessed type int dword_8516300;
// 8516304: using guessed type int dword_8516304;
// 8516308: using guessed type int dword_8516308;
// 851630C: using guessed type int dword_851630C;

//----- (080AAEDC) --------------------------------------------------------
int __cdecl sub_80AAEDC(int a1)
{
  int result; // eax

  result = a1 + 139547328;
  if ( *(_BYTE *)(a1 + 139547328) )
  {
    if ( dword_85162CC[4 * a1] )
    {
      dword_85162CC[4 * a1] = 0;
      dword_85162D0[4 * a1] = 0;
      memset(dword_85152C8, 0, 0x1000u);
    }
    result = a1 + 139547328;
    *(_BYTE *)(a1 + 139547328) = 0;
  }
  return result;
}
// 85162CC: using guessed type int dword_85162CC[];
// 85162D0: using guessed type int dword_85162D0[];

//----- (080AAF4A) --------------------------------------------------------
int __cdecl sub_80AAF4A(char *a1)
{
  int v2; // [esp+10h] [ebp-8h]
  int *v3; // [esp+14h] [ebp-4h]

  v3 = (int *)sub_80AA8AA(a1);
  if ( v3 )
    v2 = *v3;
  else
    v2 = 0;
  return v2;
}

//----- (080AAF92) --------------------------------------------------------
int __cdecl sub_80AAF92(int a1)
{
  int v3; // [esp+10h] [ebp-18h]
  int i; // [esp+10h] [ebp-18h]
  int v5; // [esp+14h] [ebp-14h]
  float v6; // [esp+18h] [ebp-10h]
  float v7; // [esp+18h] [ebp-10h]
  int v8; // [esp+1Ch] [ebp-Ch]
  int v9; // [esp+20h] [ebp-8h]
  int v10; // [esp+20h] [ebp-8h]
  int v11; // [esp+24h] [ebp-4h]

  if ( !a1 )
    return 0;
  v11 = *(_DWORD *)(a1 + 4);
  v8 = v11;
  v6 = *(float *)(v11 + 52);
  v5 = *(_DWORD *)(v11 + 16);
  v9 = *(_DWORD *)(a1 + 4);
  v3 = 0;
  while ( ++v3 != *(_DWORD *)(a1 + 8) )
  {
    v9 += 68;
    v6 = v6 + *(float *)(v9 + 52);
    if ( *(float *)(v9 + 52) * -2147483600.0 > (long double)sub_80AB1DC() * v6 )
      v8 = v9;
    if ( v5 < *(_DWORD *)(v9 + 16) )
      v5 = *(_DWORD *)(v9 + 16);
  }
  if ( *(_DWORD *)(a1 + 8) > 2 && v5 == *(_DWORD *)(v8 + 16) )
  {
    v7 = 0.0;
    v10 = v11;
    for ( i = 0; i < *(_DWORD *)(a1 + 8); ++i )
    {
      if ( v5 != *(_DWORD *)(v10 + 16) )
      {
        v7 = v7 + *(float *)(v10 + 52);
        if ( *(float *)(v10 + 52) * -2147483600.0 > (long double)sub_80AB1DC() * v7 )
          v8 = v10;
      }
      v10 += 68;
    }
  }
  *(_DWORD *)(v8 + 16) = v5 + 1;
  return v8;
}

//----- (080AB0E2) --------------------------------------------------------
int __cdecl sub_80AB0E2(char *a1)
{
  int v1; // ST04_4

  v1 = sub_80AA8AA(a1);
  return sub_80AAF92(v1);
}

//----- (080AB104) --------------------------------------------------------
int sub_80AB104()
{
  return 0;
}

//----- (080AB112) --------------------------------------------------------
void *sub_80AB112()
{
  return &unk_8516354;
}

//----- (080AB11C) --------------------------------------------------------
_DWORD *__cdecl sub_80AB11C(size_t size)
{
  return Hunk_AllocateTempMemory(size);
}

//----- (080AB130) --------------------------------------------------------
void *__cdecl sub_80AB130(size_t a1)
{
  return Hunk_AllocInternal(a1);
}

//----- (080AB144) --------------------------------------------------------
signed int __cdecl sub_80AB144(_BYTE *a1, _BYTE *a2, int a3)
{
  signed int v4; // [esp+Ch] [ebp-Ch]
  char v6; // [esp+16h] [ebp-2h]
  char v7; // [esp+17h] [ebp-1h]

  while ( a3 && *a1 )
  {
    v7 = tolower((char)*a1);
    v6 = tolower((char)*a2);
    --a3;
    ++a1;
    ++a2;
    if ( v7 < v6 )
      return -1;
    if ( v7 > v6 )
      return 1;
  }
  if ( a3 && *a1 != *a2 )
    v4 = -1;
  else
    v4 = 0;
  return v4;
}

//----- (080AB1DC) --------------------------------------------------------
int sub_80AB1DC()
{
  dword_85152C4 = 214013 * dword_85152C4 + 2531011;
  return (dword_85152C4 >> 16) & 0x7FFF;
}
// 85152C4: using guessed type int dword_85152C4;

//----- (080AB204) --------------------------------------------------------
long double __cdecl sub_80AB204(char *s1, int a2)
{
  signed int i; // [esp+14h] [ebp-4h]

  for ( i = 0; ; ++i )
  {
    if ( i > 31 )
      Com_Error(1, &byte_81467C0, a2, s1);
    if ( !strcasecmp(s1, (const char *)(68 * i + 139553768)) )
      break;
  }
  return dword_8516C28[17 * i];
}

//----- (080AB28A) --------------------------------------------------------
char *__cdecl sub_80AB28A(char *dest, char *src, char *s1)
{
  char *result; // eax

  strcpy(dest, src);
  dest[64] = 0;
  dest[128] = 0;
  *((_DWORD *)dest + 49) = 0;
  dest[200] = 0;
  *((_DWORD *)dest + 48) = 0;
  *((_DWORD *)dest + 67) = 1065353216;
  *((_DWORD *)dest + 68) = 1065353216;
  *((_DWORD *)dest + 69) = 1065353216;
  *((_DWORD *)dest + 70) = 1065353216;
  *((_DWORD *)dest + 71) = 1065353216;
  *((_DWORD *)dest + 72) = 1123024896;
  *((_DWORD *)dest + 73) = 0;
  *((_DWORD *)dest + 74) = 0;
  *((_DWORD *)dest + 75) = 1;
  dest[324] = 0;
  *((_DWORD *)dest + 78) = 1065353216;
  *((_DWORD *)dest + 79) = 0;
  dest[329] = 0;
  dest[330] = strcmp(s1, "menu") != 0;
  dest[325] = 0;
  dest[326] = 0;
  dest[327] = 0;
  dest[328] = 0;
  *((_DWORD *)dest + 77) = 1065353216;
  *((_DWORD *)dest + 80) = 0;
  *((_DWORD *)dest + 76) = sub_80AB112();
  result = dest;
  *((_DWORD *)dest + 84) = 0;
  return result;
}

//----- (080AB40A) --------------------------------------------------------
signed int __cdecl sub_80AB40A(_BYTE *a1)
{
  _BYTE *i; // [esp+Ch] [ebp+8h]

  if ( *a1 <= 31 || !(*(_WORD *)(_ctype_b + 2 * (char)*a1) & 8) && *a1 != 95 )
    return 0;
  for ( i = a1 + 1; *i; ++i )
  {
    if ( *i <= 31 || !(*(_WORD *)(_ctype_b + 2 * (char)*i) & 8) && *i != 95 )
      return 0;
  }
  return 1;
}
// 8185A64: using guessed type int _ctype_b;

//----- (080AB496) --------------------------------------------------------
int __cdecl sub_80AB496(char *a1, int a2, int a3)
{
  int result; // eax
  int v4; // edx
  int v5; // edx
  int v6; // edx
  char v7[16392]; // [esp+10h] [ebp-4018h]
  int v8; // [esp+4018h] [ebp-10h]
  int i; // [esp+401Ch] [ebp-Ch]

  for ( i = 0; i <= 10; ++i )
  {
    if ( !I_stricmp(a1, off_815DF00[i]) )
    {
      result = i;
      *(_DWORD *)(a3 + 296) = i;
      return result;
    }
  }
  v8 = 0;
  for ( i = 0; i <= 10; ++i )
  {
    v4 = sprintf(&v7[v8], "%s", off_815DF00[i]);
    v8 += v4;
    if ( i > 8 )
    {
      if ( i == 9 )
      {
        v6 = sprintf(&v7[v8], " or ");
        v8 += v6;
      }
    }
    else
    {
      v5 = sprintf(&v7[v8], ", ");
      v8 += v5;
    }
  }
  Com_Printf("^1ERROR: Sound alias file %s: Unknown sound channel '%s'; should be %s\n", a2, a1, v7);
  result = a3;
  *(_BYTE *)(a3 + 329) = 1;
  return result;
}
// 815DF00: using guessed type char *off_815DF00[13];
// 80AB496: using guessed type char var_4018[16392];

//----- (080AB5B2) --------------------------------------------------------
int __cdecl sub_80AB5B2(char *a1, int a2, int a3)
{
  int result; // eax

  if ( I_stricmp(a1, "streamed") )
  {
    if ( I_stricmp(a1, "primed") )
    {
      if ( I_stricmp(a1, "loaded") )
      {
        Com_Printf(
          "^1ERROR: Sound alias file %s: Unknown sound type '%s'; should be primed, streamed or loaded\n",
          a2,
          a1);
        result = a3;
        *(_BYTE *)(a3 + 329) = 1;
      }
      else
      {
        result = a3;
        *(_DWORD *)(a3 + 300) = 1;
      }
    }
    else
    {
      result = a3;
      *(_DWORD *)(a3 + 300) = 2;
    }
  }
  else
  {
    result = a3;
    *(_DWORD *)(a3 + 300) = 2;
  }
  return result;
}

//----- (080AB650) --------------------------------------------------------
int __cdecl sub_80AB650(char *a1, int a2, int a3)
{
  int result; // eax

  if ( I_stricmp(a1, "looping") )
  {
    if ( I_stricmp(a1, "nonlooping") )
    {
      Com_Printf(
        "^1ERROR: Sound alias file %s: Unknown sound looping type '%s'; should be looping or nonlooping\n",
        a2,
        a1);
      result = a3;
      *(_BYTE *)(a3 + 329) = 1;
    }
    else
    {
      result = a3;
      *(_BYTE *)(a3 + 324) = 0;
    }
  }
  else
  {
    result = a3;
    *(_BYTE *)(a3 + 324) = 1;
  }
  return result;
}

//----- (080AB6C2) --------------------------------------------------------
int __cdecl sub_80AB6C2(char *s, char *s2, char *src, int a4)
{
  unsigned __int8 v5; // [esp+13h] [ebp-4025h]
  int v6; // [esp+14h] [ebp-4024h]
  size_t v7; // [esp+1Ch] [ebp-401Ch]
  char dest; // [esp+20h] [ebp-4018h]
  char v9; // [esp+401Fh] [ebp-19h]
  char *haystack; // [esp+4028h] [ebp-10h]
  char *v11; // [esp+402Ch] [ebp-Ch]

  v7 = strlen(s);
  v9 = 0;
  strncpy(&dest, src, 0x4000u);
  if ( v9 )
  {
    Com_Printf("^1ERROR: Sound alias file %s: loadspec is > %i characters\n", a4, 0x3FFF);
    v6 = 0;
  }
  else
  {
    strlwr(&dest);
    haystack = &dest;
    v5 = 0;
    if ( dest != 33 || !strcmp(s, "menu") )
      v5 = 1;
    while ( 1 )
    {
      v11 = strstr(haystack, s);
      if ( !v11 )
        break;
      if ( (v11 == &dest || *(v11 - 1) <= 33) && v11[v7] <= 32 )
        return v5;
      haystack = v11 + 1;
    }
    if ( !strcmp(s, "menu") || strcmp(haystack, s2) )
      v6 = (unsigned __int8)(v5 ^ 1);
    else
      v6 = v5;
  }
  return v6;
}

//----- (080AB830) --------------------------------------------------------
void __cdecl sub_80AB830(char *s1, int a2, int a3)
{
  if ( !strcasecmp(s1, "master") )
  {
    *(_BYTE *)(a3 + 325) = 1;
    *(_BYTE *)(a3 + 326) = 0;
  }
  else
  {
    *(_BYTE *)(a3 + 325) = 0;
    *(_BYTE *)(a3 + 326) = 1;
    *(float *)(a3 + 308) = atof(s1);
    if ( *(float *)(a3 + 308) < 0.0 || *(float *)(a3 + 308) > 1.0 )
    {
      Com_Printf(
        "^1ERROR: Sound alias file %s: SlavePercentage'%f' is not within the range of '%f'-'%f'.\n",
        a2,
        *(float *)(a3 + 308),
        (double)0.0,
        (double)1.0);
      *(_BYTE *)(a3 + 329) = 1;
    }
  }
}

//----- (080AB8F4) --------------------------------------------------------
char *__cdecl sub_80AB8F4(char *haystack, int a2)
{
  char *result; // eax

  if ( strstr(haystack, "fulldrylevel") )
    *(_BYTE *)(a2 + 327) = 1;
  result = strstr(haystack, "nowetlevel");
  if ( result )
  {
    result = (char *)a2;
    *(_BYTE *)(a2 + 328) = 1;
  }
  return result;
}

//----- (080AB93E) --------------------------------------------------------
void __cdecl sub_80AB93E(char *a1, char *s2, int a3, char *s, int a5, int a6, int a7)
{
  float v7; // ST28_4
  size_t i; // [esp+30h] [ebp-8h]

  if ( a5 )
  {
    if ( *(_BYTE *)(a6 + a5) )
    {
      Com_Printf("^1ERROR: Sound alias file %s: Duplicate entries for the '%s' column\n", a3, dword_815DEA0[a5]);
      *(_BYTE *)(a7 + 329) = 1;
    }
    else
    {
      *(_BYTE *)(a6 + a5) = 1;
      switch ( a5 )
      {
        case 0:
        case 21:
          return;
        case 1:
          if ( strlen(s) <= 0x3E )
          {
            if ( sub_80AB40A(s) )
            {
              strcpy((char *)(a7 + 64), s);
            }
            else
            {
              Com_Printf("^1ERROR: Sound alias file %s: Alias name '%s' is invalid\n", a3, s);
              *(_BYTE *)(a7 + 329) = 1;
            }
          }
          else
          {
            Com_Printf("^1ERROR: Sound alias file %s: Alias name '%s' is longer than %i characters\n", a3, s, 63);
            *(_BYTE *)(a7 + 329) = 1;
          }
          break;
        case 2:
          *(_DWORD *)(a7 + 196) = atoi(s);
          break;
        case 3:
          if ( strlen(s) <= 0x3E )
          {
            strcpy((char *)(a7 + 200), s);
          }
          else
          {
            Com_Printf("^1ERROR: Sound alias file %s: Sound file '%s' is longer than %i characters\n", a3, s, 63);
            *(_BYTE *)(a7 + 329) = 1;
          }
          break;
        case 4:
          for ( i = 0; s[i]; ++i )
          {
            if ( s[i] < 0 )
            {
              Com_Printf(
                "^1ERROR: Sound alias file %s: Subtitle '%s' has invalid character '%c' ascii %i\n",
                a3,
                s,
                s[i],
                (unsigned __int8)s[i]);
              *(_BYTE *)(a7 + 329) = 1;
              return;
            }
          }
          *(_DWORD *)(a7 + 192) = Hunk_AllocateTempMemory(i + 1);
          memcpy(*(void **)(a7 + 192), s, i);
          *(_BYTE *)(*(_DWORD *)(a7 + 192) + i) = 0;
          break;
        case 5:
          *(float *)(a7 + 268) = atof(s);
          if ( *(float *)(a7 + 268) >= 0.0 && *(float *)(a7 + 268) <= 1.0 )
          {
            if ( !*(_BYTE *)(a6 + 6) )
              *(_DWORD *)(a7 + 272) = *(_DWORD *)(a7 + 268);
          }
          else
          {
            Com_Printf(
              "^1ERROR: Sound alias file %s: MinVolume '%f' is not within the range of '%f'-'%f'.\n",
              a3,
              *(float *)(a7 + 268),
              (double)0.0,
              (double)1.0);
            *(_BYTE *)(a7 + 329) = 1;
          }
          break;
        case 6:
          *(float *)(a7 + 272) = atof(s);
          if ( *(float *)(a7 + 272) < 0.0 || *(float *)(a7 + 272) > 1.0 )
          {
            Com_Printf(
              "^1ERROR: Sound alias file %s: MaxVolume '%f' is not within the range of '%f'-'%f'.\n",
              a3,
              *(float *)(a7 + 272),
              (double)0.0,
              (double)1.0);
            *(_BYTE *)(a7 + 329) = 1;
          }
          break;
        case 7:
          *(float *)(a7 + 276) = sub_80AB204(s, a3);
          break;
        case 8:
          *(float *)(a7 + 280) = atof(s);
          if ( !*(_BYTE *)(a6 + 9) )
            *(_DWORD *)(a7 + 284) = *(_DWORD *)(a7 + 280);
          break;
        case 9:
          *(float *)(a7 + 284) = atof(s);
          break;
        case 10:
          *(float *)(a7 + 288) = atof(s);
          break;
        case 11:
          *(float *)(a7 + 292) = atof(s);
          break;
        case 12:
          sub_80AB496(s, a3, a7);
          break;
        case 13:
          sub_80AB5B2(s, a3, a7);
          break;
        case 14:
          sub_80AB650(s, a3, a7);
          break;
        case 15:
          *(float *)(a7 + 312) = atof(s);
          break;
        case 16:
          *(_BYTE *)(a7 + 330) = sub_80AB6C2(a1, s2, s, a3);
          break;
        case 17:
          sub_80AB830(s, a3, a7);
          break;
        case 18:
          if ( strlen(s) <= 0x3E )
          {
            if ( sub_80AB40A(s) )
            {
              strcpy((char *)(a7 + 128), s);
            }
            else
            {
              Com_Printf("^1ERROR: Sound alias file %s: Secondary Alias name '%s' is invalid\n", a3, s);
              *(_BYTE *)(a7 + 329) = 1;
            }
          }
          else
          {
            Com_Printf(
              "^1ERROR: Sound alias file %s: Secondary Alias name '%s' is longer than %i characters\n",
              a3,
              s,
              63);
            *(_BYTE *)(a7 + 329) = 1;
          }
          break;
        case 19:
          *(_DWORD *)(a7 + 304) = sub_80AB104();
          break;
        case 20:
          *(_DWORD *)(a7 + 320) = atoi(s);
          break;
        case 22:
          sub_80AB8F4(s, a7);
          break;
        case 23:
          v7 = atof(s);
          *(float *)(a7 + 316) = sub_80AEE5E(v7, 0.0, 1.0);
          break;
      }
    }
  }
}
// 815DEA0: using guessed type int dword_815DEA0[];

//----- (080ABEF8) --------------------------------------------------------
signed int __cdecl sub_80ABEF8(int a1)
{
  int v1; // ST24_4
  int v2; // ST24_4
  signed int v4; // [esp+1Ch] [ebp-Ch]
  float v5; // [esp+20h] [ebp-8h]
  float v6; // [esp+20h] [ebp-8h]

  if ( *(float *)(a1 + 280) > (long double)*(float *)(a1 + 284) )
  {
    v1 = *(_DWORD *)(a1 + 284);
    *(_DWORD *)(a1 + 284) = *(_DWORD *)(a1 + 280);
    *(_DWORD *)(a1 + 280) = v1;
  }
  if ( *(float *)(a1 + 280) > 0.0 )
  {
    if ( *(float *)(a1 + 268) > (long double)*(float *)(a1 + 272) )
    {
      v2 = *(_DWORD *)(a1 + 272);
      *(_DWORD *)(a1 + 272) = *(_DWORD *)(a1 + 268);
      *(_DWORD *)(a1 + 268) = v2;
    }
    if ( *(float *)(a1 + 268) >= 0.0 )
    {
      if ( *(float *)(a1 + 292) == 0.0 )
        *(float *)(a1 + 292) = *(float *)(a1 + 288) * 5.0;
      if ( *(float *)(a1 + 288) <= (long double)*(float *)(a1 + 292) )
      {
        if ( *(float *)(a1 + 288) > 0.0 )
        {
          if ( *(float *)(a1 + 276) != 1.0 )
          {
            v5 = *(float *)(a1 + 268) * *(float *)(a1 + 276);
            if ( v5 >= 0.0 )
            {
              if ( v5 > 1.0 )
                v5 = 1.0;
            }
            else
            {
              v5 = 0.0;
            }
            *(float *)(a1 + 268) = v5;
            v6 = *(float *)(a1 + 272) * *(float *)(a1 + 276);
            if ( v6 >= 0.0 )
            {
              if ( v6 > 1.0 )
                v6 = 1.0;
            }
            else
            {
              v6 = 0.0;
            }
            *(float *)(a1 + 272) = v6;
          }
          v4 = 1;
        }
        else
        {
          Com_Printf("^1ERROR: sound alias '%s' has dist_min %g <= 0\n", a1 + 64, *(float *)(a1 + 288));
          v4 = 0;
        }
      }
      else
      {
        Com_Printf(
          "^1ERROR: sound alias '%s' has dist_min %g <= dist_max %g\n",
          a1 + 64,
          *(float *)(a1 + 288),
          *(float *)(a1 + 292));
        v4 = 0;
      }
    }
    else
    {
      Com_Printf("^1ERROR: sound alias '%s' has vol_min %g < 0\n", a1 + 64, *(float *)(a1 + 268));
      v4 = 0;
    }
  }
  else
  {
    Com_Printf("^1ERROR: sound alias '%s' has pitch_min %g <= 0\n", a1 + 64, *(float *)(a1 + 280));
    v4 = 0;
  }
  return v4;
}

//----- (080AC1A8) --------------------------------------------------------
int __cdecl sub_80AC1A8(_DWORD *a1)
{
  int result; // eax
  unsigned int v2; // [esp+10h] [ebp-18h]
  const void *v3; // [esp+14h] [ebp-14h]
  void *v4; // [esp+18h] [ebp-10h]
  int v5; // [esp+1Ch] [ebp-Ch]

  v5 = (int)sub_80AB11C(0x154u);
  v4 = (void *)v5;
  v3 = a1;
  v2 = 340;
  if ( v5 & 4 )
  {
    *(_DWORD *)v5 = *a1;
    v4 = (void *)(v5 + 4);
    v3 = a1 + 1;
    v2 = 336;
  }
  qmemcpy(v4, v3, 4 * (v2 >> 2));
  *(_DWORD *)(v5 + 336) = dword_8516BE0;
  result = v5;
  dword_8516BE0 = v5;
  ++dword_8516BE4;
  return result;
}
// 8516BE0: using guessed type int dword_8516BE0;
// 8516BE4: using guessed type int dword_8516BE4;

//----- (080AC22C) --------------------------------------------------------
void sub_80AC22C()
{
  dword_8516BE0 = 0;
  dword_8516BE4 = 0;
}
// 8516BE0: using guessed type int dword_8516BE0;
// 8516BE4: using guessed type int dword_8516BE4;

//----- (080AC246) --------------------------------------------------------
_DWORD *__cdecl sub_80AC246(int a1)
{
  signed int i; // [esp+2Ch] [ebp-206Ch]
  unsigned int n; // [esp+30h] [ebp-2068h]
  char *src; // [esp+38h] [ebp-2060h]
  char *srca; // [esp+38h] [ebp-2060h]
  char *v6; // [esp+3Ch] [ebp-205Ch]
  char s1[8200]; // [esp+40h] [ebp-2058h]
  int v8; // [esp+2048h] [ebp-50h]
  int v9; // [esp+204Ch] [ebp-4Ch]
  char dest; // [esp+2050h] [ebp-48h]

  n = strlen("VOLUMEMODGROUPS");
  strcpy(&dest, "soundaliases/volumemodgroups.def");
  v9 = FS_FOpenFileRead((int)&dest, &v8, 1);
  if ( v9 < 0 )
    Com_Error(1, "ERROR: Could not find '%s'\n", &dest);
  if ( !v9 )
  {
    FS_FCloseFile(v8);
    Com_Error(1, "ERROR: '%s' is empty\n", &dest);
  }
  FS_Read((int)s1, n, v8);
  s1[n] = 0;
  if ( strncmp(s1, "VOLUMEMODGROUPS", n) )
  {
    FS_FCloseFile(v8);
    Com_Error(1, "ERROR: \"%s\" does not appear to be a volumemodgroups file\n", &dest);
  }
  if ( (signed int)(v9 - n) > 0x1FFF )
  {
    FS_FCloseFile(v8);
    Com_Error(1, "ERROR: \"%s\" Is too long of a volumemodgroups file to parse\n", &dest);
  }
  memset(s1, 0, 0x2000u);
  FS_Read((int)s1, v9 - n, v8);
  s1[v9 - n] = 0;
  FS_FCloseFile(v8);
  sub_80B396A(&dest);
  v6 = s1;
  for ( i = 0; ; ++i )
  {
    src = Com_Parse(&v6);
    if ( !*src || *src == 125 )
      break;
    if ( i > 31 )
    {
      sub_80B3A3C();
      Com_Error(
        1,
        "ERROR: volumemodgroups parse failure on file \"%s\": groups parsed (%d) is greater than or equal to maxGroups(%d)\n",
        &dest,
        i,
        32);
    }
    strcpy((char *)(a1 + 68 * i), src);
    srca = Com_Parse(&v6);
    if ( !*srca || *srca == 125 )
    {
      sub_80B3A3C();
      Com_Error(
        1,
        "ERROR: volumemodgroups parse failure on file \"%s\": groupname '%s' missing a matching value\n",
        &dest,
        a1 + 68 * i);
    }
    *(float *)(a1 + 68 * i + 64) = atof(srca);
  }
  return sub_80B3A3C();
}
// 80AC246: using guessed type char s1[8200];

//----- (080AC576) --------------------------------------------------------
void sub_80AC576()
{
  byte_8517468 = 0;
}
// 8517468: using guessed type char byte_8517468;

//----- (080AC582) --------------------------------------------------------
_DWORD *__cdecl sub_80AC582(char *s1, char *s2, char *src)
{
  _DWORD *result; // eax
  signed int v4; // [esp+28h] [ebp-5F0h]
  signed int v5; // [esp+2Ch] [ebp-5ECh]
  char s; // [esp+30h] [ebp-5E8h]
  char v7; // [esp+31h] [ebp-5E7h]
  char v8; // [esp+33h] [ebp-5E5h]
  char v9; // [esp+50h] [ebp-5C8h]
  char dest; // [esp+90h] [ebp-588h]
  char v11; // [esp+1D9h] [ebp-43Fh]
  char v12; // [esp+1DAh] [ebp-43Eh]
  int v13[259]; // [esp+1F0h] [ebp-428h]
  int v14; // [esp+5FCh] [ebp-1Ch]
  int i; // [esp+600h] [ebp-18h]
  char *v16; // [esp+604h] [ebp-14h]
  _BYTE *v17; // [esp+608h] [ebp-10h]
  _BYTE *v18; // [esp+60Ch] [ebp-Ch]

  Com_sprintf(&v9, 0x40u, "soundaliases/%s", src);
  result = (_DWORD *)FS_ReadFile(&v9, &v18);
  if ( (signed int)result >= 0 )
  {
    if ( !byte_8517468 )
    {
      if ( !byte_8517469 )
      {
        Cmd_AddCommand("snd_refreshVolumeModGroups", (int)sub_80AC576);
        byte_8517469 = 1;
      }
      sub_80AC246((int)&unk_8516BE8);
      byte_8517468 = 1;
    }
    sub_80B396A(&v9);
    sub_80B3B00(1);
    v17 = v18;
    v14 = 0;
    while ( 1 )
    {
      v16 = Com_Parse(&v17);
      if ( !v17 )
        break;
      if ( *v16 && *v16 != 35 )
      {
        if ( v14 )
        {
          memset(&s, 0, 0x18u);
          sub_80AB28A(&dest, src, s1);
          i = 0;
          while ( 1 )
          {
            if ( *v16 )
              sub_80AB93E(s1, s2, (int)src, v16, v13[i], (int)&s, (int)&dest);
            if ( ++i == v14 )
              break;
            v16 = sub_80B4848(&v17);
          }
          if ( !v7 || !v8 )
          {
            Com_Printf("^1ERROR: Sound alias file %s: alias entry missing name and/or file\n", src);
            return sub_80B3A3C();
          }
          if ( v12 && !v11 && (unsigned __int8)sub_80ABEF8((int)&dest) )
            sub_80AC1A8(&dest);
        }
        else
        {
          v5 = 0;
          v4 = 0;
          while ( 2 )
          {
            v13[v14] = 0;
            for ( i = 1; i <= 23; ++i )
            {
              if ( !I_stricmp((char *)dword_815DEA0[i], v16) )
              {
                v13[v14] = i;
                if ( i == 1 )
                {
                  v5 = 1;
                }
                else if ( i == 3 )
                {
                  v4 = 1;
                }
                break;
              }
            }
            if ( ++v14 != 256 && v17 && *v17 != 10 )
            {
              v16 = sub_80B4848(&v17);
              continue;
            }
            break;
          }
          if ( !v5 || !v4 )
          {
            Com_Printf("^1ERROR: Sound alias file %s: missing 'name' and/or 'file' columns\n", src);
            return sub_80B3A3C();
          }
        }
        sub_80B49B8(&v17);
      }
      else
      {
        sub_80B49B8(&v17);
      }
    }
    result = sub_80B3A3C();
  }
  return result;
}
// 815DEA0: using guessed type int dword_815DEA0[];
// 8517468: using guessed type char byte_8517468;
// 8517469: using guessed type char byte_8517469;
// 80AC582: using guessed type int var_428[259];

//----- (080AC880) --------------------------------------------------------
signed int __cdecl sub_80AC880(int a1, int a2)
{
  return I_stricmp((char *)(a1 + 64), (char *)(a2 + 64));
}

//----- (080AC8A0) --------------------------------------------------------
int __cdecl sub_80AC8A0(int a1, int *a2, int (__cdecl *a3)(char *, int), unsigned __int8 a4)
{
  int v4; // edx
  int v5; // eax
  int v7; // [esp+18h] [ebp-20h]
  int v8; // [esp+1Ch] [ebp-1Ch]
  int v9; // [esp+1Ch] [ebp-1Ch]
  signed int v10; // [esp+1Ch] [ebp-1Ch]
  int v11; // [esp+20h] [ebp-18h]
  int v12; // [esp+24h] [ebp-14h]
  int *v13; // [esp+28h] [ebp-10h]
  int v14; // [esp+2Ch] [ebp-Ch]
  char *v15; // [esp+30h] [ebp-8h]
  unsigned __int8 v16; // [esp+37h] [ebp-1h]

  v16 = a4;
  if ( *a2 == 1 )
  {
    *(_DWORD *)(a1 + 336) = 0;
    v7 = a1;
  }
  else
  {
    v12 = *a2 / 2;
    v11 = *a2 - v12;
    v8 = 0;
    v14 = a1;
    while ( v8 < v12 )
    {
      ++v8;
      v14 = *(_DWORD *)(v14 + 336);
    }
    v15 = (char *)sub_80AC8A0(a1, &v12, a3, v16);
    v14 = sub_80AC8A0(v14, &v11, a3, v16);
    *a2 = 0;
    a1 = 0;
    v13 = &a1;
    while ( v12 && v11 )
    {
      v9 = a3(v15, v14);
      if ( !v16 || v9 || (v4 = *(_DWORD *)(v14 + 196), v9 = *((_DWORD *)v15 + 49) - v4, *((_DWORD *)v15 + 49) != v4) )
      {
        if ( v9 > 0 )
        {
          *v13 = v14;
          v14 = *(_DWORD *)(v14 + 336);
          --v11;
        }
        else
        {
          *v13 = (int)v15;
          v15 = (char *)*((_DWORD *)v15 + 84);
          --v12;
        }
        ++*a2;
        v13 = (int *)(*v13 + 336);
      }
      else
      {
        v10 = I_stricmp(v15, (char *)v14);
        if ( v10 )
        {
          if ( v10 >= 0 )
          {
            v14 = *(_DWORD *)(v14 + 336);
            --v11;
          }
          else
          {
            v15 = (char *)*((_DWORD *)v15 + 84);
            --v12;
          }
        }
        else
        {
          Com_Printf("^1ERROR: sound alias file %s: duplicate alias '%s'\n", v15, v15 + 64);
          v15 = (char *)*((_DWORD *)v15 + 84);
          --v12;
          v14 = *(_DWORD *)(v14 + 336);
          --v11;
        }
      }
    }
    if ( v12 )
    {
      *v13 = (int)v15;
      v5 = *a2 + v12;
    }
    else
    {
      *v13 = v14;
      v5 = *a2 + v11;
    }
    *a2 = v5;
    v7 = a1;
  }
  return v7;
}

//----- (080ACAF4) --------------------------------------------------------
signed int __cdecl sub_80ACAF4(int a1, int a2)
{
  int v2; // edx
  signed int v4; // [esp+Ch] [ebp-Ch]
  signed int v5; // [esp+14h] [ebp-4h]

  v5 = I_stricmp((char *)(a1 + 200), (char *)(a2 + 200));
  if ( v5 )
    return v5;
  v2 = *(_DWORD *)(a2 + 300);
  if ( *(_DWORD *)(a1 + 300) == v2 )
    v4 = sub_80AC880(a1, a2);
  else
    v4 = *(_DWORD *)(a1 + 300) - v2;
  return v4;
}

//----- (080ACB66) --------------------------------------------------------
void __cdecl sub_80ACB66(int a1, int a2)
{
  signed int v2; // [esp+1Ch] [ebp-1Ch]
  signed int v3; // [esp+20h] [ebp-18h]
  const char *v4; // [esp+34h] [ebp-4h]

  v3 = *(_DWORD *)(a1 + 300);
  if ( v3 == 2 )
  {
    v4 = "streamed";
  }
  else if ( v3 > 2 && v3 == 3 )
  {
    v4 = "primed";
  }
  else
  {
    v4 = "loaded";
  }
  v2 = *(_DWORD *)(a2 + 300);
  if ( v2 == 2 )
  {
    Com_Printf(
      "WARNING: sound file '%s' used as %s in alias '%s' and %s in alias '%s'\n",
      a1 + 200,
      v4,
      a1 + 64,
      "streamed",
      a2 + 64);
  }
  else if ( v2 > 2 && v2 == 3 )
  {
    Com_Printf(
      "WARNING: sound file '%s' used as %s in alias '%s' and %s in alias '%s'\n",
      a1 + 200,
      v4,
      a1 + 64,
      "primed",
      a2 + 64);
  }
  else
  {
    Com_Printf(
      "WARNING: sound file '%s' used as %s in alias '%s' and %s in alias '%s'\n",
      a1 + 200,
      v4,
      a1 + 64,
      "loaded",
      a2 + 64);
  }
}

//----- (080ACC2E) --------------------------------------------------------
int __cdecl sub_80ACC2E(_DWORD *a1, int a2, int a3)
{
  int result; // eax

  *a1 = a2;
  a1[1] = 0;
  result = a3;
  a1[3] = a3;
  return result;
}

//----- (080ACC4E) --------------------------------------------------------
int __cdecl sub_80ACC4E(int a1, int a2, int a3, int a4, int a5)
{
  size_t v5; // eax
  unsigned int v6; // edx
  unsigned int v7; // edx
  unsigned int v8; // edx
  unsigned int v9; // edx
  unsigned int v10; // edx
  int result; // eax

  *(_DWORD *)a2 = a3;
  if ( *(_BYTE *)(a1 + 128) )
  {
    v5 = strlen((const char *)(a1 + 128));
    *(_DWORD *)(a2 + 8) = sub_80AB130(v5 + 1);
    strcpy(*(char **)(a2 + 8), (const char *)(a1 + 128));
  }
  else
  {
    *(_DWORD *)(a2 + 8) = 0;
  }
  *(_DWORD *)(a2 + 12) = a4;
  *(_DWORD *)(a2 + 4) = a5;
  *(_DWORD *)(a2 + 16) = 0;
  *(_DWORD *)(a2 + 20) = *(_DWORD *)(a1 + 268);
  *(_DWORD *)(a2 + 24) = *(_DWORD *)(a1 + 272);
  *(_DWORD *)(a2 + 28) = *(_DWORD *)(a1 + 280);
  *(_DWORD *)(a2 + 32) = *(_DWORD *)(a1 + 284);
  *(_DWORD *)(a2 + 36) = *(_DWORD *)(a1 + 288);
  *(_DWORD *)(a2 + 40) = *(_DWORD *)(a1 + 292);
  *(_DWORD *)(a2 + 44) = *(_DWORD *)(a2 + 44) & 0xFFFFF87F | (*(_DWORD *)(a1 + 296) << 7);
  *(_DWORD *)(a2 + 44) = *(_DWORD *)(a2 + 44) & 0xFFFFFF9F | 32 * *(_DWORD *)(a1 + 300);
  *(_DWORD *)(a2 + 64) = *(_DWORD *)(a1 + 304);
  if ( *(_BYTE *)(a1 + 324) )
    v6 = *(_DWORD *)(a2 + 44) | 1;
  else
    v6 = *(_DWORD *)(a2 + 44) & 0xFFFFFFFE;
  *(_DWORD *)(a2 + 44) = v6;
  if ( *(_BYTE *)(a1 + 325) )
    v7 = *(_DWORD *)(a2 + 44) | 2;
  else
    v7 = *(_DWORD *)(a2 + 44) & 0xFFFFFFFD;
  *(_DWORD *)(a2 + 44) = v7;
  if ( *(_BYTE *)(a1 + 326) )
    v8 = *(_DWORD *)(a2 + 44) | 4;
  else
    v8 = *(_DWORD *)(a2 + 44) & 0xFFFFFFFB;
  *(_DWORD *)(a2 + 44) = v8;
  if ( *(_BYTE *)(a1 + 327) )
    v9 = *(_DWORD *)(a2 + 44) | 8;
  else
    v9 = *(_DWORD *)(a2 + 44) & 0xFFFFFFF7;
  *(_DWORD *)(a2 + 44) = v9;
  if ( *(_BYTE *)(a1 + 328) )
    v10 = *(_DWORD *)(a2 + 44) | 0x10;
  else
    v10 = *(_DWORD *)(a2 + 44) & 0xFFFFFFEF;
  *(_DWORD *)(a2 + 44) = v10;
  *(_DWORD *)(a2 + 48) = *(_DWORD *)(a1 + 308);
  *(_DWORD *)(a2 + 52) = *(_DWORD *)(a1 + 312);
  *(_DWORD *)(a2 + 56) = *(_DWORD *)(a1 + 316);
  result = *(_DWORD *)(a1 + 320);
  *(_DWORD *)(a2 + 60) = result;
  return result;
}

//----- (080ACE9A) --------------------------------------------------------
int __cdecl sub_80ACE9A(int a1, _DWORD *a2)
{
  int result; // eax
  char *v3; // ST4C_4
  char v4; // [esp+16h] [ebp-42h]
  char v5; // [esp+17h] [ebp-41h]
  int v6; // [esp+18h] [ebp-40h]
  void *v7; // [esp+1Ch] [ebp-3Ch]
  int v8; // [esp+20h] [ebp-38h]
  char v9; // [esp+27h] [ebp-31h]
  _DWORD *v10; // [esp+28h] [ebp-30h]
  int v11; // [esp+2Ch] [ebp-2Ch]
  size_t v12; // [esp+30h] [ebp-28h]
  size_t v13; // [esp+34h] [ebp-24h]
  size_t v14; // [esp+34h] [ebp-24h]
  char *v15; // [esp+38h] [ebp-20h]
  int v16; // [esp+40h] [ebp-18h]
  int i; // [esp+44h] [ebp-14h]
  int j; // [esp+44h] [ebp-14h]
  int k; // [esp+44h] [ebp-14h]
  char *s; // [esp+48h] [ebp-10h]
  char *dest; // [esp+50h] [ebp-8h]
  char *desta; // [esp+50h] [ebp-8h]
  char *destb; // [esp+50h] [ebp-8h]

  *a2 = 0;
  result = a1;
  *(_DWORD *)(a1 + 8) = 0;
  if ( dword_8516BE4 )
  {
    result = sub_80AC8A0(dword_8516BE0, &dword_8516BE4, (int (__cdecl *)(char *, int))sub_80AC880, 1u);
    dword_8516BE0 = result;
    if ( result )
    {
      result = sub_80AC8A0(dword_8516BE0, &dword_8516BE4, (int (__cdecl *)(char *, int))sub_80ACAF4, 0);
      dword_8516BE0 = result;
      if ( result )
      {
        v12 = 0;
        v11 = 0;
        v16 = 0;
        dest = 0;
        v6 = 0;
        for ( i = dword_8516BE0; i; i = *(_DWORD *)(i + 336) )
        {
          v13 = strlen((const char *)(i + 200)) + 1;
          v5 = 0;
          if ( v16 && *(_DWORD *)(i + 300) == *(_DWORD *)(v16 + 300) )
            v5 = 1;
          v4 = 0;
          if ( dest && !I_stricmp(dest, (char *)(i + 200)) )
            v4 = 1;
          v9 = 0;
          if ( v4 && v5 )
            v9 = 1;
          if ( dest && v9 )
          {
            v11 += v13;
            *(_DWORD *)(i + 332) = v16;
          }
          else
          {
            if ( v4 )
            {
              if ( !v5 )
                sub_80ACB66(i, v16);
            }
            v16 = i;
            dest = (char *)(i + 200);
            *(_DWORD *)(i + 332) = 0;
            v12 += v13;
            ++v6;
          }
        }
        result = sub_80AC8A0(dword_8516BE0, &dword_8516BE4, (int (__cdecl *)(char *, int))sub_80AC880, 1u);
        dword_8516BE0 = result;
        if ( result )
        {
          desta = 0;
          for ( j = dword_8516BE0; j; j = *(_DWORD *)(j + 336) )
          {
            v14 = strlen((const char *)(j + 64)) + 1;
            if ( desta && !I_stricmp(desta, (char *)(j + 64)) )
            {
              v11 += v14;
            }
            else
            {
              v12 += v14;
              desta = (char *)(j + 64);
            }
            if ( *(_DWORD *)(j + 192) )
              v12 += strlen(*(const char **)(j + 192)) + 1;
          }
          *(_DWORD *)(a1 + 4) = sub_80AB130(68 * dword_8516BE4);
          a2[1] = sub_80AB130(16 * v6);
          v15 = (char *)sub_80AB130(v12);
          destb = 0;
          v7 = 0;
          result = dword_8516BE0;
          for ( k = dword_8516BE0; ; k = *(_DWORD *)(k + 336) )
          {
            if ( !k )
              return result;
            if ( !destb || I_stricmp(destb, (char *)(k + 64)) )
            {
              destb = v15;
              strcpy(v15, (const char *)(k + 64));
              v15 += strlen(v15) + 1;
            }
            if ( *(_DWORD *)(k + 192) )
            {
              s = v15;
              strcpy(v15, *(const char **)(k + 192));
              v15 += strlen(v15) + 1;
            }
            else
            {
              s = 0;
            }
            v8 = *(_DWORD *)(a1 + 4) + 68 * *(_DWORD *)(a1 + 8);
            if ( !v7 || I_stricmp(**((char ***)v7 + 1), destb) )
            {
              v7 = sub_80AB130(0x10u);
              if ( !(unsigned __int8)sub_80AAA06(destb, (int)v7) )
              {
                v7 = 0;
                Com_Printf("^1ERROR: alias '%s' already added - ignoring\n", destb, 13);
                goto LABEL_50;
              }
              *(_DWORD *)v7 = destb;
              *((_DWORD *)v7 + 1) = v8;
            }
            if ( *(_DWORD *)(k + 332) )
            {
              v10 = *(_DWORD **)(*(_DWORD *)(k + 332) + 264);
            }
            else
            {
              v3 = v15;
              strcpy(v15, (const char *)(k + 200));
              v15 += strlen(v15) + 1;
              v10 = (_DWORD *)(a2[1] + 16 * *a2);
              sub_80ACC2E(v10, (int)v3, *(_DWORD *)(k + 300));
              ++*a2;
            }
            *(_DWORD *)(k + 264) = v10;
            sub_80ACC4E(k, v8, (int)destb, (int)v10, (int)s);
            ++*(_DWORD *)(a1 + 8);
            ++*((_DWORD *)v7 + 2);
LABEL_50:
            result = *(_DWORD *)(k + 336);
          }
        }
      }
    }
  }
  return result;
}
// 8516BE0: using guessed type int dword_8516BE0;
// 8516BE4: using guessed type int dword_8516BE4;

//----- (080AD3E6) --------------------------------------------------------
signed int __cdecl sub_80AD3E6(char a1, char *src, float *a3)
{
  const char *v3; // ST1C_4
  float *v4; // ebx
  float *v5; // esi
  float *v6; // esi
  signed int v8; // [esp+10h] [ebp-18h]
  signed int i; // [esp+18h] [ebp-10h]
  int v10; // [esp+18h] [ebp-10h]
  char *nptr; // [esp+1Ch] [ebp-Ch]
  char *nptra; // [esp+1Ch] [ebp-Ch]

  sub_80B396A(src);
  v3 = Com_Parse((char **)&a1);
  v4 = a3;
  *((_DWORD *)v4 + 1) = atoi(v3);
  if ( *((_DWORD *)a3 + 1) > 1 )
  {
    if ( *((_DWORD *)a3 + 1) <= 8 )
    {
      for ( i = 0; ; ++i )
      {
        nptr = Com_Parse((char **)&a1);
        if ( !*nptr || *nptr == 125 )
          break;
        if ( i > 7 )
        {
          sub_80B3A3C();
          Com_Printf(
            "^1ERROR: sndcurve parse failure on file \"%s\": knots parsed (%d) is greater than or equal to maxKnots (%d)\n",
            src,
            i,
            8);
          return 0;
        }
        v5 = a3;
        v5[2 * i + 2] = atof(nptr);
        if ( a3[2 * i + 2] < 0.0 || a3[2 * i + 2] > 1.0 )
        {
          sub_80B3A3C();
          Com_Printf(
            "^1ERROR: sndcurve parse failure on file \"%s\": knot x-coord '%f' is not in the range 0-1.\n",
            src,
            a3[2 * i + 2]);
          return 0;
        }
        nptra = Com_Parse((char **)&a1);
        if ( !*nptra || *nptra == 125 )
          break;
        v6 = a3;
        v6[2 * i + 3] = atof(nptra);
        if ( a3[2 * i + 3] < 0.0 || a3[2 * i + 3] > 1.0 )
        {
          sub_80B3A3C();
          Com_Printf(
            "^1ERROR: sndcurve parse failure on file \"%s\": knot x-coord '%f' is not in the range 0-1.\n",
            src,
            a3[2 * i + 3]);
          return 0;
        }
      }
      sub_80B3A3C();
      if ( i == *((_DWORD *)a3 + 1) )
      {
        v10 = i - 1;
        if ( a3[2] != 0.0 || a3[3] != 1.0 || a3[2 * v10 + 2] != 1.0 || a3[2 * v10 + 3] != 0.0 )
        {
          a3[2] = 0.0;
          a3[3] = 1.0;
          a3[2 * v10 + 2] = 1.0;
          a3[2 * v10 + 3] = 0.0;
          Com_Printf(
            "^3WARNING^7: sndcurve parse on file \"%s\": the first point must be '0.0000 1.0000' and the last point must "
            "be '1.0000 0.0000'.\n"
            "adjusting sndcurve endpoints.\n",
            src);
        }
        v8 = 1;
      }
      else
      {
        Com_Printf(
          "^1ERROR: sndcurve parse failure on file \"%s\": knot count (%d) does not match knots parsed (%d).\n",
          src,
          *((_DWORD *)a3 + 1),
          i);
        v8 = 0;
      }
    }
    else
    {
      sub_80B3A3C();
      Com_Printf(
        "^1ERROR: sndcurve parse failure on file \"%s\": knot count (%d) is greater than maxKnots (%d)\n",
        src,
        *((_DWORD *)a3 + 1),
        8);
      v8 = 0;
    }
  }
  else
  {
    sub_80B3A3C();
    Com_Printf(
      "^1ERROR: sndcurve parse failure on file \"%s\": knot count (%d) is less than 2\n",
      src,
      *((_DWORD *)a3 + 1));
    v8 = 0;
  }
  return v8;
}

//----- (080AD6F6) --------------------------------------------------------
signed int __cdecl sub_80AD6F6(int a1, float *a2)
{
  signed int v3; // [esp+14h] [ebp-2064h]
  unsigned int n; // [esp+18h] [ebp-2060h]
  char s1[8200]; // [esp+20h] [ebp-2058h]
  int v6; // [esp+2028h] [ebp-50h]
  int v7; // [esp+202Ch] [ebp-4Ch]
  char v8; // [esp+2030h] [ebp-48h]

  n = strlen("SNDCURVE");
  Com_sprintf(&v8, 0x40u, "soundaliases/%s.vfcurve", a1);
  v7 = FS_FOpenFileRead((int)&v8, &v6, 1);
  if ( v7 >= 0 )
  {
    if ( v7 )
    {
      FS_Read((int)s1, n, v6);
      s1[n] = 0;
      if ( !strncmp(s1, "SNDCURVE", n) )
      {
        if ( (signed int)(v7 - n) <= 0x1FFF )
        {
          memset(s1, 0, 0x2000u);
          FS_Read((int)s1, v7 - n, v6);
          s1[v7 - n] = 0;
          FS_FCloseFile(v6);
          if ( (unsigned __int8)sub_80AD3E6((unsigned int)s1, &v8, a2) )
          {
            *(_DWORD *)a2 = a1;
            v3 = 1;
          }
          else
          {
            v3 = 0;
          }
        }
        else
        {
          FS_FCloseFile(v6);
          Com_Printf("^1ERROR: \"%s\" Is too long of a sndcurve file to parse\n", &v8);
          v3 = 0;
        }
      }
      else
      {
        FS_FCloseFile(v6);
        Com_Printf("^1ERROR: \"%s\" does not appear to be a sndcurve file\n", &v8);
        v3 = 0;
      }
    }
    else
    {
      FS_FCloseFile(v6);
      Com_Printf("^1ERROR: sndcurve file '%s' is empty\n", &v8);
      v3 = 0;
    }
  }
  else
  {
    Com_Printf("^1ERROR: Could not load sndcurve file '%s'\n", &v8);
    v3 = 0;
  }
  return v3;
}
// 80AD6F6: using guessed type char s1[8200];

//----- (080AD920) --------------------------------------------------------
_DWORD *__cdecl sub_80AD920(_DWORD *a1)
{
  _DWORD *result; // eax

  *a1 = &byte_8147777;
  a1[2] = 0;
  a1[3] = 1065353216;
  a1[4] = 1065353216;
  a1[5] = 0;
  result = a1;
  a1[1] = 2;
  return result;
}

//----- (080AD964) --------------------------------------------------------
signed int __cdecl sub_80AD964(char *a1)
{
  char *v1; // ST1C_4
  signed int v3; // [esp+14h] [ebp-14h]
  signed int v4; // [esp+18h] [ebp-10h]
  const char *s1; // [esp+1Ch] [ebp-Ch]
  void *i; // [esp+20h] [ebp-8h]
  void *v7; // [esp+24h] [ebp-4h]

  v4 = 0;
  if ( I_strncmp(a1, "SUBTITLE_", 9) )
    return 0;
  if ( FS_ReadFile("soundaliases/subtitle.st", &v7) >= 0 )
  {
    sub_80B396A("soundaliases/subtitle.st");
    for ( i = v7; ; sub_80B49B8(&i) )
    {
      s1 = Com_Parse((char **)&i);
      if ( !i )
        break;
      if ( !strcmp(s1, "REFERENCE") )
      {
        v1 = sub_80B4848((char **)&i);
        if ( !I_stricmp(a1 + 9, v1) )
        {
          v4 = 1;
          break;
        }
      }
    }
    sub_80B3A3C();
    FS_FreeFile(v7);
    v3 = v4;
  }
  else
  {
    Com_Printf("WARNING: Could not read local copy of StringEd file %s\n", "soundaliases/subtitle.st");
    v3 = 0;
  }
  return v3;
}

//----- (080ADA6A) --------------------------------------------------------
char *__cdecl sub_80ADA6A(char *a1)
{
  const char *v1; // ST1C_4
  char *v2; // ST1C_4
  int v4; // [esp+18h] [ebp-10h]
  const char *s1; // [esp+1Ch] [ebp-Ch]
  const char *s1a; // [esp+1Ch] [ebp-Ch]
  void *i; // [esp+20h] [ebp-8h]
  void *v8; // [esp+24h] [ebp-4h]

  if ( FS_ReadFile("soundaliases/subtitle.st", &v8) >= 0 )
  {
    sub_80B396A("soundaliases/subtitle.st");
    for ( i = v8; ; sub_80B49B8(&i) )
    {
      s1 = Com_Parse((char **)&i);
      if ( !i )
        break;
      if ( !strcmp(s1, "REFERENCE") )
      {
        v1 = sub_80B4848((char **)&i);
        strcpy(byte_8517480, v1);
        sub_80B49B8(&i);
        do
        {
          s1a = Com_Parse((char **)&i);
          if ( !i )
            Com_Error(1, &byte_8147800, "soundaliases/subtitle.st");
        }
        while ( strcmp(s1a, "LANG_ENGLISH") );
        v2 = sub_80B4848((char **)&i);
        if ( !I_stricmp(a1, v2) )
        {
          sub_80B3A3C();
          FS_FreeFile(v8);
          return byte_8517480;
        }
      }
    }
    sub_80B3A3C();
    FS_FreeFile(v8);
    v4 = 0;
  }
  else
  {
    Com_Printf("WARNING: Could not read local copy of StringEd file %s\n", "soundaliases/subtitle.st");
    v4 = 0;
  }
  return (char *)v4;
}

//----- (080ADBCA) --------------------------------------------------------
size_t __cdecl sub_80ADBCA(char *a1, char *a2, int a3)
{
  size_t v3; // eax
  size_t v4; // eax
  size_t v5; // eax
  size_t v6; // eax
  size_t v7; // eax

  v3 = strlen("REFERENCE           ");
  sub_809E454("REFERENCE           ", v3, a3);
  v4 = strlen(a1);
  sub_809E454(a1, v4, a3);
  v5 = strlen("\r\nLANG_ENGLISH        \"");
  sub_809E454("\r\nLANG_ENGLISH        \"", v5, a3);
  v6 = strlen(a2);
  sub_809E454(a2, v6, a3);
  v7 = strlen("\"\r\n\r\n");
  return sub_809E454("\"\r\n\r\n", v7, a3);
}

//----- (080ADC96) --------------------------------------------------------
void __cdecl sub_80ADC96(int a1, char *a2)
{
  const char *v2; // ST28_4
  size_t v3; // eax
  signed int v4; // [esp+1Ch] [ebp-22Ch]
  int v5; // [esp+20h] [ebp-228h]
  char *v6; // [esp+24h] [ebp-224h]
  const char *s1; // [esp+28h] [ebp-220h]
  const char *s1a; // [esp+28h] [ebp-220h]
  char *s2; // [esp+2Ch] [ebp-21Ch]
  char dest; // [esp+30h] [ebp-218h]
  char filename; // [esp+130h] [ebp-118h]
  char *v12; // [esp+234h] [ebp-14h]
  char *v13; // [esp+238h] [ebp-10h]
  size_t v14; // [esp+23Ch] [ebp-Ch]

  v4 = 0;
  s2 = (char *)(a1 + 9);
  v5 = FS_FOpenFileWrite("soundaliases/temp.st");
  if ( v5 )
  {
    if ( FS_ReadFile("soundaliases/subtitle.st", &v13) >= 0 )
    {
      sub_80B396A("soundaliases/subtitle.st");
      v12 = v13;
      v6 = v13;
      while ( 1 )
      {
        s1 = Com_Parse(&v12);
        if ( !v12 )
          break;
        if ( !strcmp(s1, "ENDMARKER") )
        {
          if ( v6 < v12 )
          {
            v14 = v12 - v6 - 11;
            sub_809E454(v6, v14, v5);
          }
          break;
        }
        if ( !strcmp(s1, "REFERENCE") )
        {
          v2 = sub_80B4848(&v12);
          if ( !strcmp(v2, s2) )
          {
            if ( v6 < v12 )
            {
              v14 = v12 - v6;
              sub_809E454(v6, v12 - v6, v5);
            }
            sub_80ADBCA(s2, a2, v5);
            v4 = 1;
            do
            {
              v6 = v12;
              s1a = Com_Parse(&v12);
              if ( !v12 )
              {
                v6 = 0;
                goto LABEL_20;
              }
            }
            while ( strcmp(s1a, "REFERENCE") && strcmp(s1a, "ENDMARKER") );
            sub_80B3D92();
          }
        }
LABEL_20:
        sub_80B49B8(&v12);
      }
      if ( !v4 )
        sub_80ADBCA(s2, a2, v5);
      sub_80B3A3C();
      FS_FreeFile(v13);
      v3 = strlen("\r\nENDMARKER\r\n\r\n\r\n");
      sub_809E454("\r\nENDMARKER\r\n\r\n\r\n", v3, v5);
      FS_FCloseFile(v5);
      FS_BuildOSPath(*(void **)(fs_basepath + 8), byte_848B6C0, "soundaliases/temp.st", &filename);
      FS_BuildOSPath(*(void **)(fs_basepath + 8), byte_848B6C0, "soundaliases/subtitle.st", &dest);
      FS_CopyFile(&filename, &dest);
      sub_809CACA(&filename);
    }
    else
    {
      Com_Printf("WARNING: Could not read local copy of StringEd file %s\n", "soundaliases/subtitle.st");
      FS_FCloseFile(v5);
    }
  }
  else
  {
    Com_Printf("WARNING: Could not open output file %s for writing\n", "soundaliases/temp.st");
  }
}

//----- (080ADFEA) --------------------------------------------------------
void __cdecl sub_80ADFEA(char *a1, char *s2)
{
  signed int v2; // [esp+24h] [ebp-6DD4h]
  signed int v3; // [esp+28h] [ebp-6DD0h]
  char v4; // [esp+30h] [ebp-6DC8h]
  char dest; // [esp+130h] [ebp-6CC8h]
  int v6[257]; // [esp+290h] [ebp-6B68h]
  FILE *stream; // [esp+694h] [ebp-6764h]
  int v8; // [esp+698h] [ebp-6760h]
  int v9; // [esp+69Ch] [ebp-675Ch]
  char s; // [esp+6A0h] [ebp-6758h]
  char v11; // [esp+6A1h] [ebp-6757h]
  char v12; // [esp+6A2h] [ebp-6756h]
  char v13; // [esp+6A3h] [ebp-6755h]
  char v14; // [esp+6A4h] [ebp-6754h]
  char *v15; // [esp+6C4h] [ebp-6734h]
  char *v16; // [esp+6C8h] [ebp-6730h]
  char *src; // [esp+6CCh] [ebp-672Ch]
  char haystack; // [esp+6D0h] [ebp-6728h]
  char v19; // [esp+7D0h] [ebp-6628h]
  char v20; // [esp+8D0h] [ebp-6528h]
  char v21[4096]; // [esp+CD0h] [ebp-6128h]
  char v22[4096]; // [esp+10D0h] [ebp-5D28h]
  char v23[4096]; // [esp+14D0h] [ebp-5928h]
  char v24[20480]; // [esp+1CD0h] [ebp-5128h]
  char filename; // [esp+6CD0h] [ebp-128h]
  char *v26; // [esp+6DD8h] [ebp-20h]
  char *v27; // [esp+6DDCh] [ebp-1Ch]
  char v28[4]; // [esp+6DE0h] [ebp-18h]
  int v29; // [esp+6DE4h] [ebp-14h]
  int v30; // [esp+6DE8h] [ebp-10h]
  int i; // [esp+6DECh] [ebp-Ch]

  Com_sprintf(&v4, 0x100u, "soundaliases/%s", a1);
  FS_BuildOSPath(*(void **)(fs_basepath + 8), byte_848B6C0, &v4, &filename);
  Com_Printf("Processing sound alias file %s..\n", &filename);
  stream = FS_FileOpen(&filename, "r+");
  if ( stream )
  {
    FS_FileClose(stream);
    if ( FS_ReadFile(&v4, &v27) >= 0 )
    {
      v8 = FS_FOpenFileWrite("soundaliases/temp.csv");
      if ( v8 )
      {
        sub_80B396A(&v4);
        sub_80B3B00(1);
        v26 = v27;
        v30 = 0;
        *(_DWORD *)v28 = 0;
        while ( v26 )
        {
          if ( *v26 == 13 )
          {
            while ( *v26 == 13 )
              ++v26;
          }
          if ( *v26 == 10 )
          {
            ++v26;
            sub_809E454("\r\n", 2u, v8);
          }
          v16 = v26;
          src = Com_Parse(&v26);
          if ( !v26 )
            break;
          if ( !I_stricmp(src, "#Chateau") )
            i = 0;
          if ( *src && *src != 35 )
          {
            if ( v30 )
            {
              memset(&s, 0, 0x18u);
              sub_80AB28A(&dest, a1, "menu");
              i = 0;
              while ( 1 )
              {
                strcpy(&v21[1024 * v6[i]], src);
                if ( *src )
                  sub_80AB93E("menu", s2, (int)a1, src, v6[i], (int)&s, (int)&dest);
                if ( ++i == v30 )
                  break;
                src = sub_80B4848(&v26);
              }
              if ( !v11 || !v13 )
                Com_Error(1, &byte_8147A00, a1);
              v9 = 0;
              if ( v14 )
              {
                v29 = strlen(v24);
                for ( i = 0; i < v29 && (v24[i] > 64 && v24[i] <= 90 || v24[i] > 47 && v24[i] <= 57 || v24[i] == 95); ++i )
                  ;
                if ( i < v29 || I_strncmp(v24, "SUBTITLE_", 9) || !sub_80AD964(v24) )
                  v9 = 1;
              }
              if ( v9 )
              {
                for ( i = 0; i < v30; ++i )
                {
                  if ( v6[i] && *(&s + v6[i]) )
                  {
                    if ( v6[i] == 4 )
                    {
                      src = sub_80ADA6A(v24);
                      if ( src )
                      {
                        Com_sprintf(&v20, 0x400u, "%s%s", "SUBTITLE_", src);
                        src = sub_80B577E(&v20);
                      }
                      else
                      {
                        if ( v12 )
                          Com_sprintf(&v20, 0x400u, "%s%s_%s", "SUBTITLE_", v22, v23);
                        else
                          Com_sprintf(&v20, 0x400u, "%s%s", "SUBTITLE_", v22);
                        src = sub_80B577E(&v20);
                        sub_80ADC96((int)&v20, v24);
                        ++*(_DWORD *)v28;
                      }
                      v29 = strlen(src);
                      sub_809E454(src, v29, v8);
                    }
                    else
                    {
                      if ( i == v30 - 1 )
                      {
                        if ( strchr(&v21[1024 * v6[i]], 44)
                          || strchr(&v21[1024 * v6[i]], 32)
                          || strchr(&v21[1024 * v6[i]], 10)
                          || strchr(&v21[1024 * v6[i]], 13) )
                        {
                          src = va("\"%s\"", &v21[1024 * v6[i]]);
                        }
                        else
                        {
                          src = va("%s", &v21[1024 * v6[i]]);
                        }
                      }
                      else if ( strchr(&v21[1024 * v6[i]], 44)
                             || strchr(&v21[1024 * v6[i]], 32)
                             || strchr(&v21[1024 * v6[i]], 10)
                             || strchr(&v21[1024 * v6[i]], 13) )
                      {
                        src = va("\"%s\",", &v21[1024 * v6[i]]);
                      }
                      else
                      {
                        src = va("%s,", &v21[1024 * v6[i]]);
                      }
                      v29 = strlen(src);
                      sub_809E454(src, v29, v8);
                    }
                  }
                  else if ( i != v30 - 1 )
                  {
                    sub_809E454(",", 1u, v8);
                  }
                }
                sub_809E454("\r\n", 2u, v8);
                sub_80B49B8(&v26);
              }
              else
              {
                sub_80B49B8(&v26);
                v15 = v26;
                sub_809E454(v16, v26 - v16, v8);
              }
            }
            else
            {
              v3 = 0;
              v2 = 0;
              while ( 2 )
              {
                v6[v30] = 0;
                for ( i = 1; i <= 23; ++i )
                {
                  if ( !I_stricmp((char *)dword_815DEA0[i], src) )
                  {
                    v6[v30] = i;
                    if ( i == 1 )
                    {
                      v3 = 1;
                    }
                    else if ( i == 3 )
                    {
                      v2 = 1;
                    }
                    break;
                  }
                }
                if ( ++v30 != 256 && v26 && *v26 != 10 )
                {
                  src = sub_80B4848(&v26);
                  continue;
                }
                break;
              }
              if ( !v3 || !v2 )
                Com_Error(1, &byte_81479C0, a1);
              sub_80B49B8(&v26);
              if ( *v16 == 10 )
                sub_809E454("\r", 1u, v8);
              v15 = v26;
              sub_809E454(v16, v26 - v16, v8);
            }
          }
          else
          {
            sub_80B49B8(&v26);
            if ( *v16 == 10 )
              sub_809E454("\r", 1u, v8);
            v15 = v26;
            sub_809E454(v16, v26 - v16, v8);
          }
        }
        sub_80B3A3C();
        FS_FCloseFile(v8);
        FS_BuildOSPath(*(void **)(fs_basepath + 8), byte_848B6C0, "soundaliases/temp.csv", &v19);
        FS_BuildOSPath(*(void **)(fs_basepath + 8), byte_848B6C0, &v4, &haystack);
        if ( *(_DWORD *)v28 )
          FS_CopyFile(&v19, &haystack);
        sub_809CACA(&v19);
        Com_Printf("Localized %i sound alias subtitles\n", *(_DWORD *)v28);
      }
      else
      {
        Com_Printf("WARNING: Could not open output file %s for writing\n", "soundaliases/temp.csv");
      }
    }
    else
    {
      Com_Printf("WARNING: Could not read sound alias file %s\n", &v4);
    }
  }
  else
  {
    Com_Printf("WARNING: Can not write to sound alias file %s\n", &filename);
  }
}
// 815DEA0: using guessed type int dword_815DEA0[];
// 80ADFEA: using guessed type int var_6B68[257];
// 80ADFEA: using guessed type char var_6128[4096];
// 80ADFEA: using guessed type char var_5128[20480];

//----- (080AEB14) --------------------------------------------------------
void __cdecl sub_80AEB14(char *filename, char *a2)
{
  void *ptr; // [esp+1Ch] [ebp-Ch]
  int size; // [esp+20h] [ebp-8h]
  FILE *stream; // [esp+24h] [ebp-4h]
  FILE *streama; // [esp+24h] [ebp-4h]

  stream = FS_FileOpen(filename, "rb");
  if ( stream )
  {
    FS_FileSeek(stream, 0, 2);
    size = ftell(stream);
    FS_FileSeek(stream, 0, 0);
    ptr = malloc(size);
    if ( FS_FileRead(ptr, 1u, size, stream) != size )
      Com_Error(0, &byte_8147AA0);
    FS_FileClose(stream);
    streama = FS_FileOpen(a2, "wb");
    if ( streama )
    {
      if ( FS_FileWrite(ptr, 1u, size, streama) != size )
        Com_Error(0, &byte_8147AE0);
      FS_FileClose(streama);
      free(ptr);
    }
    else
    {
      free(ptr);
    }
  }
}

//----- (080AEC4E) --------------------------------------------------------
void sub_80AEC4E()
{
  int v0; // [esp+28h] [ebp-220h]
  FILE *stream; // [esp+2Ch] [ebp-21Ch]
  char filename; // [esp+30h] [ebp-218h]
  char v3; // [esp+12Fh] [ebp-119h]
  char s; // [esp+130h] [ebp-118h]
  void *ptr; // [esp+234h] [ebp-14h]
  int v6; // [esp+238h] [ebp-10h]
  int i; // [esp+23Ch] [ebp-Ch]

  FS_BuildOSPath(*(void **)(fs_homepath + 8), "../source_data/string_resources/subtitle.st", &byte_8147777, &s);
  *(&v3 + strlen(&s)) = 0;
  stream = FS_FileOpen(&s, "r+");
  if ( stream )
  {
    FS_FileClose(stream);
    FS_BuildOSPath(*(void **)(fs_basepath + 8), byte_848B6C0, "soundaliases/subtitle.st", &filename);
    FS_CopyFile(&s, &filename);
    if ( sub_809CADE("soundaliases/subtitle.st") )
    {
      Com_Printf("Localizing sound alias subtitle text...\n");
      Com_Printf("Writing to StringEd file %s\n", &s);
      ptr = sub_809F7B2((int)"soundaliases", "csv", 0, (int)&v6);
      if ( v6 )
      {
        v0 = sub_80AA13C();
        for ( i = 0; i < v6; ++i )
        {
          sub_80ADFEA(*((char **)ptr + i), "all_mp");
          sub_80AA124();
        }
        sub_80AA15A(v0);
        FS_FreeFileList(ptr);
        sub_80AEB14(&filename, &s);
        sub_809CACA(&filename);
        Com_Printf("done\n");
      }
      else
      {
        Com_Printf("WARNING: can't find any sound alias files (soundaliases/*.csv)\n");
      }
    }
    else
    {
      Com_Printf("WARNING: Could not make local copy of StringEd file %s\n", "soundaliases/subtitle.st");
    }
  }
  else
  {
    Com_Printf("WARNING: Can not write to StringEd file %s\n", &s);
  }
}
// 848B7C4: using guessed type int fs_homepath;

//----- (080AEE5E) --------------------------------------------------------
long double __cdecl sub_80AEE5E(float a1, float a2, float a3)
{
  float v3; // ST00_4
  float v4; // ST08_4
  float v5; // ST00_4

  v3 = a1 - a3;
  v4 = sub_80AEE9C(v3, a3, a1);
  v5 = a2 - a1;
  return sub_80AEE9C(v5, a2, v4);
}

//----- (080AEE9C) --------------------------------------------------------
long double __cdecl sub_80AEE9C(float a1, float a2, float a3)
{
  float v4; // [esp+0h] [ebp-4h]

  if ( a1 < 0.0 )
    v4 = a3;
  else
    v4 = a2;
  return v4;
}

//----- (080AEEC8) --------------------------------------------------------
int __cdecl Dvar_SetInAutoExec(unsigned __int8 a1)
{
  int result; // eax

  result = a1;
  isLoadingAutoExecGlobalFlag = a1;
  return result;
}
// 8523115: using guessed type char isLoadingAutoExecGlobalFlag;

//----- (080AEEE0) --------------------------------------------------------
int Dvar_IsSystemActive()
{
  return (unsigned __int8)isDvarSystemActive;
}
// 8523114: using guessed type char isDvarSystemActive;

//----- (080AEEEC) --------------------------------------------------------
int __cdecl sub_80AEEEC(int a1)
{
  int v2; // [esp+10h] [ebp-8h]
  int i; // [esp+14h] [ebp-4h]

  if ( !a1 )
    Com_Error(1, &byte_8147CC0);
  v2 = 0;
  for ( i = 0; *(_BYTE *)(a1 + i); ++i )
    v2 += tolower(*(char *)(a1 + i)) * (i + 119);
  return (unsigned __int8)v2;
}

//----- (080AEF62) --------------------------------------------------------
signed int __cdecl sub_80AEF62(int a1)
{
  char v3; // [esp+7h] [ebp-5h]
  int i; // [esp+8h] [ebp-4h]

  if ( !a1 )
    return 0;
  for ( i = 0; *(_BYTE *)(a1 + i); ++i )
  {
    v3 = *(_BYTE *)(a1 + i);
    if ( !(*(_WORD *)(_ctype_b + 2 * v3) & 8) && v3 != 95 )
      return 0;
  }
  return 1;
}
// 8185A64: using guessed type int _ctype_b;

//----- (080AEFD0) --------------------------------------------------------
char *__cdecl sub_80AEFD0(int a1)
{
  char *v1; // ST00_4

  if ( (unsigned int)(dword_8523110 + a1) > 0xC )
    dword_8523110 = 0;
  v1 = (char *)&unk_85230E0 + 4 * dword_8523110;
  dword_8523110 += a1;
  return v1;
}
// 8523110: using guessed type int dword_8523110;

//----- (080AF012) --------------------------------------------------------
int __cdecl sub_80AF012(int a1)
{
  int result; // eax

  *(_DWORD *)(a1 + 8) = Z_MallocInternal(12 * *(unsigned __int8 *)(a1 + 6));
  *(_DWORD *)(a1 + 12) = *(_DWORD *)(a1 + 8) + 4 * *(unsigned __int8 *)(a1 + 6);
  result = *(_DWORD *)(a1 + 12) + 4 * *(unsigned __int8 *)(a1 + 6);
  *(_DWORD *)(a1 + 16) = result;
  return result;
}

//----- (080AF06A) --------------------------------------------------------
void __cdecl sub_80AF06A(int a1)
{
  Z_FreeInternal(*(void **)(a1 + 8));
}

//----- (080AF080) --------------------------------------------------------
char *__cdecl sub_80AF080(char *src)
{
  return sub_80A93B0(src);
}

//----- (080AF094) --------------------------------------------------------
void __cdecl sub_80AF094(void *ptr)
{
  Z_FreeInternal(ptr);
}

//----- (080AF0A8) --------------------------------------------------------
char *__cdecl sub_80AF0A8(char *s)
{
  size_t v3; // [esp+14h] [ebp-4h]

  if ( *s )
  {
    v3 = I_strlen(s);
    if ( s[1] )
    {
      if ( *s == 111 )
      {
        if ( v3 == 3 && s[1] == 102 && s[2] == 102 && !s[3] )
          return off_815DF2C[0];
        if ( v3 == 2 && s[1] == 110 && !s[2] )
          return off_815DF30;
      }
    }
    else if ( *s > 47 && *s <= 57 )
    {
      return (char *)&a0123456789[*s - 48];
    }
    return sub_80A93B0(s);
  }
  return (char *)&unk_8147CE0;
}
// 81482EC: using guessed type __int16 a0123456789[10];
// 815DF2C: using guessed type char *off_815DF2C[2];
// 815DF30: using guessed type char *off_815DF30;

//----- (080AF180) --------------------------------------------------------
void __cdecl sub_80AF180(void *ptr)
{
  if ( *(_BYTE *)ptr
    && (*((_BYTE *)ptr + 1) || *(_BYTE *)ptr <= 47 || *(_BYTE *)ptr > 57)
    && ptr != off_815DF2C[0]
    && ptr != off_815DF30 )
  {
    Z_FreeInternal(ptr);
  }
}
// 815DF2C: using guessed type char *off_815DF2C[2];
// 815DF30: using guessed type char *off_815DF30;

//----- (080AF1CE) --------------------------------------------------------
int __cdecl sub_80AF1CE(int a1)
{
  int result; // eax

  if ( *(_DWORD *)(a1 + 8) != *(_DWORD *)(a1 + 12) && *(_DWORD *)(a1 + 8) != *(_DWORD *)(a1 + 16) )
    sub_80AF180(*(void **)(a1 + 8));
  result = a1;
  *(_DWORD *)(a1 + 8) = 0;
  return result;
}

//----- (080AF20A) --------------------------------------------------------
int __cdecl sub_80AF20A(int a1)
{
  int result; // eax

  if ( *(_DWORD *)(a1 + 12) != *(_DWORD *)(a1 + 8) && *(_DWORD *)(a1 + 12) != *(_DWORD *)(a1 + 16) )
    sub_80AF180(*(void **)(a1 + 12));
  result = a1;
  *(_DWORD *)(a1 + 12) = 0;
  return result;
}

//----- (080AF246) --------------------------------------------------------
int __cdecl sub_80AF246(int a1)
{
  int result; // eax

  if ( *(_DWORD *)(a1 + 16) != *(_DWORD *)(a1 + 8) && *(_DWORD *)(a1 + 16) != *(_DWORD *)(a1 + 12) )
    sub_80AF180(*(void **)(a1 + 16));
  result = a1;
  *(_DWORD *)(a1 + 16) = 0;
  return result;
}

//----- (080AF282) --------------------------------------------------------
char *__cdecl sub_80AF282(int a1, char *s1)
{
  char *result; // eax

  if ( *(_DWORD *)(a1 + 12) && (s1 == *(char **)(a1 + 12) || !strcmp(s1, *(const char **)(a1 + 12))) )
  {
    result = (char *)a1;
    *(_DWORD *)(a1 + 8) = *(_DWORD *)(a1 + 12);
  }
  else if ( *(_DWORD *)(a1 + 16) && (s1 == *(char **)(a1 + 16) || !strcmp(s1, *(const char **)(a1 + 16))) )
  {
    result = (char *)a1;
    *(_DWORD *)(a1 + 8) = *(_DWORD *)(a1 + 16);
  }
  else
  {
    result = sub_80AF0A8(s1);
    *(_DWORD *)(a1 + 8) = result;
  }
  return result;
}

//----- (080AF316) --------------------------------------------------------
char *__cdecl sub_80AF316(int a1, char *s1)
{
  char *result; // eax

  if ( *(_DWORD *)(a1 + 8) && (s1 == *(char **)(a1 + 8) || !strcmp(s1, *(const char **)(a1 + 8))) )
  {
    result = (char *)a1;
    *(_DWORD *)(a1 + 12) = *(_DWORD *)(a1 + 8);
  }
  else if ( *(_DWORD *)(a1 + 16) && (s1 == *(char **)(a1 + 16) || !strcmp(s1, *(const char **)(a1 + 16))) )
  {
    result = (char *)a1;
    *(_DWORD *)(a1 + 12) = *(_DWORD *)(a1 + 16);
  }
  else
  {
    result = sub_80AF0A8(s1);
    *(_DWORD *)(a1 + 12) = result;
  }
  return result;
}

//----- (080AF3AA) --------------------------------------------------------
char *__cdecl sub_80AF3AA(int a1, char *s1)
{
  char *result; // eax

  if ( *(_DWORD *)(a1 + 8) && (s1 == *(char **)(a1 + 8) || !strcmp(s1, *(const char **)(a1 + 8))) )
  {
    result = (char *)a1;
    *(_DWORD *)(a1 + 16) = *(_DWORD *)(a1 + 8);
  }
  else if ( *(_DWORD *)(a1 + 12) && (s1 == *(char **)(a1 + 12) || !strcmp(s1, *(const char **)(a1 + 12))) )
  {
    result = (char *)a1;
    *(_DWORD *)(a1 + 16) = *(_DWORD *)(a1 + 12);
  }
  else
  {
    result = sub_80AF0A8(s1);
    *(_DWORD *)(a1 + 16) = result;
  }
  return result;
}

//----- (080AF43E) --------------------------------------------------------
void *__cdecl sub_80AF43E(_DWORD *a1)
{
  void *v2; // [esp+0h] [ebp-4h]

  if ( a1[5] )
    v2 = *(void **)(a1[6] + 4 * a1[2]);
  else
    v2 = &unk_8147CE0;
  return v2;
}

//----- (080AF474) --------------------------------------------------------
void *__cdecl sub_80AF474(int a1, char *nptr)
{
  signed int i; // [esp+Ch] [ebp-Ch]
  signed int v5; // [esp+10h] [ebp-8h]

  if ( !*(_DWORD *)(a1 + 20) )
    return &unk_8147CE0;
  v5 = I_strlen(nptr);
  for ( i = 0; i < v5; ++i )
  {
    if ( !(*(_WORD *)(_ctype_b + 2 * nptr[i]) & 0x800) )
      return &unk_8147CE0;
  }
  return *(void **)(*(_DWORD *)(a1 + 24) + 4 * atoi(nptr));
}
// 8185A64: using guessed type int _ctype_b;

//----- (080AF502) --------------------------------------------------------
char *__cdecl sub_80AF502(int a1, float *a2)
{
  char *v3; // [esp+30h] [ebp-8h]
  char *v4; // [esp+34h] [ebp-4h]

  switch ( *(unsigned __int8 *)(a1 + 6) )
  {
    case 0u:
      if ( (_BYTE)a2 )
        v3 = (char *)&unk_8147CE1;
      else
        v3 = (char *)&unk_8147CE3;
      v4 = v3;
      break;
    case 1u:
      v4 = va("%g", *(float *)&a2);
      break;
    case 2u:
      v4 = va("%g %g", *a2, a2[1]);
      break;
    case 3u:
      v4 = va("%g %g %g", *a2, a2[1], a2[2]);
      break;
    case 4u:
      v4 = va("%g %g %g %g", *a2, a2[1], a2[2], a2[3]);
      break;
    case 5u:
      v4 = va("%i", a2);
      break;
    case 6u:
      if ( *(_DWORD *)(a1 + 20) )
        v4 = *(char **)(*(_DWORD *)(a1 + 24) + 4 * (_DWORD)a2);
      else
        v4 = (char *)&unk_8147CE0;
      break;
    case 7u:
      v4 = va("%s", a2);
      break;
    case 8u:
      v4 = va(
             "%g %g %g %g",
             (double)((long double)(unsigned __int8)a2 * 0.0039215689),
             (double)((long double)BYTE1(a2) * 0.0039215689),
             (double)((long double)BYTE2(a2) * 0.0039215689),
             (double)((long double)HIBYTE(a2) * 0.0039215689));
      break;
    default:
      v4 = (char *)&unk_8147CE0;
      break;
  }
  return v4;
}

//----- (080AF6DE) --------------------------------------------------------
_BOOL4 __cdecl sub_80AF6DE(char *nptr)
{
  return atoi(nptr) != 0;
}

//----- (080AF704) --------------------------------------------------------
int __cdecl sub_80AF704(char *nptr)
{
  return atoi(nptr);
}

//----- (080AF718) --------------------------------------------------------
long double __cdecl sub_80AF718(char *nptr)
{
  return (float)atof(nptr);
}

//----- (080AF738) --------------------------------------------------------
char *__cdecl sub_80AF738(char *s)
{
  char *v1; // ST14_4

  v1 = sub_80AEFD0(2);
  sub_80B317C(v1);
  sscanf(s, "%g %g", v1, v1 + 4);
  return v1;
}

//----- (080AF782) --------------------------------------------------------
char *__cdecl sub_80AF782(char *s)
{
  char *v1; // ST14_4

  v1 = sub_80AEFD0(3);
  sub_80B321E(v1);
  sscanf(s, "%g %g %g", v1, v1 + 4, v1 + 8);
  return v1;
}

//----- (080AF7D6) --------------------------------------------------------
char *__cdecl sub_80AF7D6(char *s)
{
  char *v1; // ST24_4

  v1 = sub_80AEFD0(4);
  sub_80B3306(v1);
  sscanf(s, "%g %g %g %g", v1, v1 + 4, v1 + 8, v1 + 12);
  return v1;
}

//----- (080AF834) --------------------------------------------------------
int __cdecl sub_80AF834(int a1, char *s1)
{
  int v4; // [esp+1Ch] [ebp-Ch]
  char *j; // [esp+20h] [ebp-8h]
  int i; // [esp+24h] [ebp-4h]
  int v7; // [esp+24h] [ebp-4h]
  int k; // [esp+24h] [ebp-4h]

  for ( i = 0; i < *(_DWORD *)a1; ++i )
  {
    if ( !strcasecmp(s1, *(const char **)(*(_DWORD *)(a1 + 4) + 4 * i)) )
      return i;
  }
  v7 = 0;
  for ( j = s1; *j; ++j )
  {
    if ( *j <= 47 || *j > 57 )
      return -1337;
    v7 = *j + 10 * v7 - 48;
  }
  if ( v7 >= 0 && v7 < *(_DWORD *)a1 )
    return v7;
  v4 = I_strlen(s1);
  for ( k = 0; k < *(_DWORD *)a1; ++k )
  {
    if ( !sub_80B3458(s1, *(_BYTE **)(*(_DWORD *)(a1 + 4) + 4 * k), v4) )
      return k;
  }
  return -1337;
}

//----- (080AF95E) --------------------------------------------------------
int __usercall sub_80AF95E@<eax>(long double a1@<st0>, char *s, int a3)
{
  float v3; // ST04_4
  long double v4; // fst7
  float v5; // ST00_4
  float v6; // ST04_4
  long double v7; // fst7
  float v8; // ST00_4
  float v9; // ST04_4
  long double v10; // fst7
  float v11; // ST00_4
  float v12; // ST04_4
  float v13; // ST00_4
  int result; // eax
  float v15; // [esp+20h] [ebp-18h]
  float v16; // [esp+24h] [ebp-14h]
  float v17; // [esp+28h] [ebp-10h]
  float v18; // [esp+2Ch] [ebp-Ch]

  sub_80B3306(&v15);
  sscanf(s, "%g %g %g %g", &v15, &v16, &v17, &v18);
  sub_80B3122(1.0, v15);
  v3 = a1;
  sub_80B30FE(0.0, v3);
  v4 = a1 * 255.0;
  v5 = v4;
  *(_BYTE *)a3 = sub_80B3146(v5);
  sub_80B3122(1.0, v16);
  v6 = v4;
  sub_80B30FE(0.0, v6);
  v7 = v4 * 255.0;
  v8 = v7;
  *(_BYTE *)(a3 + 1) = sub_80B3146(v8);
  sub_80B3122(1.0, v17);
  v9 = v7;
  sub_80B30FE(0.0, v9);
  v10 = v7 * 255.0;
  v11 = v10;
  *(_BYTE *)(a3 + 2) = sub_80B3146(v11);
  sub_80B3122(1.0, v18);
  v12 = v10;
  sub_80B30FE(0.0, v12);
  v13 = v10 * 255.0;
  result = sub_80B3146(v13);
  *(_BYTE *)(a3 + 3) = result;
  return result;
}

//----- (080AFA9E) --------------------------------------------------------
float *__userpurge sub_80AFA9E@<eax>(long double a1@<st0>, float *a2, char a3, int a4, int a5, char *nptr)
{
  int v7; // [esp+18h] [ebp-10h]
  int v8; // [esp+1Ch] [ebp-Ch]
  char v9; // [esp+27h] [ebp-1h]

  v7 = a4;
  v8 = a5;
  v9 = a3;
  switch ( a3 )
  {
    case 0:
      *(_BYTE *)a2 = sub_80AF6DE(nptr);
      break;
    case 1:
      *a2 = sub_80AF718(nptr);
      break;
    case 2:
      *(_DWORD *)a2 = sub_80AF738(nptr);
      break;
    case 3:
      *(_DWORD *)a2 = sub_80AF782(nptr);
      break;
    case 4:
      *(_DWORD *)a2 = sub_80AF7D6(nptr);
      break;
    case 5:
      *(_DWORD *)a2 = sub_80AF704(nptr);
      break;
    case 6:
      *(_DWORD *)a2 = sub_80AF834((int)&v7, nptr);
      break;
    case 7:
      *(_DWORD *)a2 = nptr;
      break;
    case 8:
      sub_80AF95E(a1, nptr, (int)a2);
      break;
    default:
      *a2 = 0.0;
      break;
  }
  return a2;
}

//----- (080AFB8C) --------------------------------------------------------
char *__cdecl Dvar_DisplayableValue(int a1)
{
  return sub_80AF502(a1, *(float **)(a1 + 8));
}

//----- (080AFBB2) --------------------------------------------------------
char *__cdecl Dvar_DisplayableResetValue(int a1)
{
  return sub_80AF502(a1, *(float **)(a1 + 16));
}

//----- (080AFBD8) --------------------------------------------------------
char *__cdecl Dvar_DisplayableLatchedValue(int a1)
{
  return sub_80AF502(a1, *(float **)(a1 + 12));
}

//----- (080AFBFE) --------------------------------------------------------
int __cdecl sub_80AFBFE(int a1, int a2, float a3, float a4)
{
  int result; // eax
  int i; // [esp+0h] [ebp-4h]

  for ( i = 0; ; ++i )
  {
    result = i;
    if ( i >= a2 )
      break;
    if ( a3 <= (long double)*(float *)(a1 + 4 * i) )
    {
      if ( *(float *)(a1 + 4 * i) > (long double)a4 )
        *(float *)(a1 + 4 * i) = a4;
    }
    else
    {
      *(float *)(a1 + 4 * i) = a3;
    }
  }
  return result;
}

//----- (080AFC80) --------------------------------------------------------
int __cdecl sub_80AFC80(int a1, int a2, float a3, float a4)
{
  int i; // [esp+4h] [ebp-4h]

  for ( i = 0; i < a2; ++i )
  {
    if ( a3 > (long double)*(float *)(a1 + 4 * i) )
      return 0;
    if ( *(float *)(a1 + 4 * i) > (long double)a4 )
      return 0;
  }
  return 1;
}

//----- (080AFCF6) --------------------------------------------------------
float *__userpurge sub_80AFCF6@<eax>(float *a1, char a2, float a3, float a4, float a5, float a6)
{
  switch ( a2 )
  {
    case 1:
      if ( a5 <= (long double)a3 )
      {
        if ( a3 > (long double)a6 )
          a3 = a6;
      }
      else
      {
        a3 = a5;
      }
      break;
    case 2:
      sub_80AFBFE(SLODWORD(a3), 2, a5, a6);
      break;
    case 3:
      sub_80AFBFE(SLODWORD(a3), 3, a5, a6);
      break;
    case 4:
      sub_80AFBFE(SLODWORD(a3), 4, a5, a6);
      break;
    case 5:
      if ( SLODWORD(a3) >= SLODWORD(a5) )
      {
        if ( SLODWORD(a3) > SLODWORD(a6) )
          a3 = a6;
      }
      else
      {
        a3 = a5;
      }
      break;
    case 6:
      if ( a3 < 0.0 || SLODWORD(a3) >= SLODWORD(a5) )
        a3 = a4;
      break;
    default:
      break;
  }
  *a1 = a3;
  return a1;
}

//----- (080AFE1A) --------------------------------------------------------
signed int __cdecl sub_80AFE1A(char a1, int a2, float a3, float a4)
{
  signed int v5; // [esp+20h] [ebp-18h]
  signed int v6; // [esp+24h] [ebp-14h]

  switch ( a1 )
  {
    case 0:
      v6 = 1;
      break;
    case 1:
      if ( a3 <= (long double)*(float *)&a2 )
        v6 = *(float *)&a2 <= (long double)a4;
      else
        v6 = 0;
      break;
    case 2:
      v6 = (unsigned __int8)sub_80AFC80(a2, 2, a3, a4);
      break;
    case 3:
      v6 = (unsigned __int8)sub_80AFC80(a2, 3, a3, a4);
      break;
    case 4:
      v6 = (unsigned __int8)sub_80AFC80(a2, 4, a3, a4);
      break;
    case 5:
      if ( a2 >= SLODWORD(a3) )
        v6 = a2 <= SLODWORD(a4);
      else
        v6 = 0;
      break;
    case 6:
      v5 = 0;
      if ( a2 >= 0 && a2 < SLODWORD(a3) || *(float *)&a2 == 0.0 )
        v5 = 1;
      v6 = v5;
      break;
    case 7:
      v6 = 1;
      break;
    case 8:
      v6 = 1;
      break;
    default:
      v6 = 0;
      break;
  }
  return v6;
}

//----- (080AFF9A) --------------------------------------------------------
int __cdecl sub_80AFF9A(int a1, int a2, int a3, char *s, size_t maxlen)
{
  int result; // eax

  if ( *(float *)&a2 == -3.4028235e38 )
  {
    if ( *(float *)&a3 == 3.4028235e38 )
      result = snprintf(s, maxlen, "Domain is any %iD vector", a1);
    else
      result = snprintf(s, maxlen, "Domain is any %iD vector with components %g or smaller", a1, (_QWORD)a3);
  }
  else if ( *(float *)&a3 == 3.4028235e38 )
  {
    result = snprintf(s, maxlen, "Domain is any %iD vector with components %g or bigger", a1, (_QWORD)a2);
  }
  else
  {
    result = snprintf(s, maxlen, "Domain is any %iD vector with components from %g to %g", a1, (_QWORD)a2, (_QWORD)a3);
  }
  return result;
}

//----- (080B009A) --------------------------------------------------------
char *__cdecl sub_80B009A(int a1, int a2, int a3, char *s, size_t maxlen, int a6)
{
  int i; // [esp+2Ch] [ebp-1Ch]
  int v8; // [esp+30h] [ebp-18h]
  int v9; // [esp+30h] [ebp-18h]
  char *v10; // [esp+34h] [ebp-14h]

  v10 = &s[maxlen];
  if ( a6 )
    *(_DWORD *)a6 = 0;
  switch ( (unsigned __int8)a1 )
  {
    case 0u:
      snprintf(s, maxlen, "Domain is 0 or 1");
      break;
    case 1u:
      if ( *(float *)&a2 == -3.4028235e38 )
      {
        if ( *(float *)&a3 == 3.4028235e38 )
          snprintf(s, maxlen, "Domain is any number");
        else
          snprintf(s, maxlen, "Domain is any number %g or smaller", (_QWORD)a3);
      }
      else if ( *(float *)&a3 == 3.4028235e38 )
      {
        snprintf(s, maxlen, "Domain is any number %g or bigger", (_QWORD)a2);
      }
      else
      {
        snprintf(s, maxlen, "Domain is any number from %g to %g", (_QWORD)a2, (_QWORD)a3);
      }
      break;
    case 2u:
      sub_80AFF9A(2, a2, a3, s, maxlen);
      break;
    case 3u:
      sub_80AFF9A(3, a2, a3, s, maxlen);
      break;
    case 4u:
      sub_80AFF9A(4, a2, a3, s, maxlen);
      break;
    case 5u:
      if ( a2 == 0x80000000 )
      {
        if ( *(float *)&a3 == 6.8056469e38/*NaN*/ )
          snprintf(s, maxlen, "Domain is any integer");
        else
          snprintf(s, maxlen, "Domain is any integer %i or smaller", a3);
      }
      else if ( *(float *)&a3 == 6.8056469e38/*NaN*/ )
      {
        snprintf(s, maxlen, "Domain is any integer %i or bigger", a2);
      }
      else
      {
        snprintf(s, maxlen, "Domain is any integer from %i to %i", a2, a3);
      }
      break;
    case 6u:
      v8 = snprintf(s, v10 - s, "Domain is one of the following:");
      if ( v8 >= 0 )
      {
        s += v8;
        for ( i = 0; i < a2; ++i )
        {
          v9 = snprintf(s, v10 - s, "\n  %2i: %s", i, *(_DWORD *)(a3 + 4 * i));
          if ( v9 < 0 )
            break;
          if ( a6 )
            ++*(_DWORD *)a6;
          s += v9;
        }
      }
      break;
    case 7u:
      snprintf(s, maxlen, "Domain is any text");
      break;
    case 8u:
      snprintf(s, maxlen, "Domain is any 4-component color, in RGBA format");
      break;
    default:
      *s = 0;
      break;
  }
  *(v10 - 1) = 0;
  return s;
}

//----- (080B0410) --------------------------------------------------------
char *__cdecl sub_80B0410(int a1, int a2, int a3, char *s, size_t maxlen)
{
  return sub_80B009A((unsigned __int8)a1, a2, a3, s, maxlen, 0);
}

//----- (080B045A) --------------------------------------------------------
char *__cdecl sub_80B045A(int a1, int a2, int a3, char *s, size_t maxlen, int a6)
{
  return sub_80B009A((unsigned __int8)a1, a2, a3, s, maxlen, a6);
}

//----- (080B04A4) --------------------------------------------------------
void __cdecl sub_80B04A4(unsigned __int8 a1, int a2, int a3)
{
  char *v3; // eax
  char s; // [esp+20h] [ebp-418h]
  int v5; // [esp+420h] [ebp-18h]
  int v6; // [esp+424h] [ebp-14h]
  unsigned __int8 v7; // [esp+42Fh] [ebp-9h]

  v5 = a2;
  v6 = a3;
  v7 = a1;
  v3 = sub_80B0410(a1, a2, a3, &s, 0x400u);
  Com_Printf("  %s\n", v3);
}

//----- (080B04FE) --------------------------------------------------------
int __cdecl sub_80B04FE(int a1, char *s1, char *s2)
{
  int v4; // [esp+10h] [ebp-8h]

  switch ( (unsigned __int8)a1 )
  {
    case 0u:
      v4 = (_BYTE)s1 == (_BYTE)s2;
      break;
    case 1u:
      v4 = *(float *)&s2 == *(float *)&s1;
      break;
    case 2u:
      v4 = (unsigned __int8)sub_80B31D0((float *)s1, (float *)s2);
      break;
    case 3u:
      v4 = (unsigned __int8)sub_80B329C((float *)s1, (float *)s2);
      break;
    case 4u:
      v4 = (unsigned __int8)sub_80B33AA((float *)s1, (float *)s2);
      break;
    case 5u:
      v4 = s1 == s2;
      break;
    case 6u:
      v4 = s1 == s2;
      break;
    case 7u:
      v4 = strcmp(s1, s2) == 0;
      break;
    case 8u:
      v4 = (unsigned __int8)sub_80B3442(&s1, &s2);
      break;
    default:
      v4 = 0;
      break;
  }
  return v4;
}

//----- (080B0620) --------------------------------------------------------
char *__cdecl sub_80B0620(int a1, char *s1)
{
  char *result; // eax
  signed int v3; // [esp+14h] [ebp-4h]

  v3 = *(unsigned __int8 *)(a1 + 6);
  if ( v3 == 3 )
    return (char *)sub_80B326C(s1, *(_DWORD **)(a1 + 12));
  if ( v3 > 3 )
  {
    if ( v3 == 4 )
      return (char *)sub_80B336A(s1, *(_DWORD **)(a1 + 12));
    if ( v3 == 7 )
    {
      sub_80AF20A(a1);
      return sub_80AF316(a1, s1);
    }
  }
  else if ( v3 == 2 )
  {
    return (char *)sub_80B31B0(s1, *(_DWORD **)(a1 + 12));
  }
  result = s1;
  *(_DWORD *)(a1 + 12) = s1;
  return result;
}

//----- (080B06C4) --------------------------------------------------------
int __cdecl Dvar_HasLatchedValue(int a1)
{
  return (unsigned __int8)(sub_80B04FE(*(unsigned __int8 *)(a1 + 6), *(char **)(a1 + 8), *(char **)(a1 + 12)) ^ 1);
}

//----- (080B06F8) --------------------------------------------------------
int __cdecl sub_80B06F8(int a1)
{
  return (unsigned __int8)sub_80B04FE(*(unsigned __int8 *)(a1 + 6), *(char **)(a1 + 8), *(char **)(a1 + 16));
}

//----- (080B072A) --------------------------------------------------------
void __cdecl sub_80B072A(int a1, char *s1, int a3)
{
  char *v3; // eax
  char *v4; // eax
  char *v5; // eax
  signed int v6; // [esp+14h] [ebp-4h]

  v3 = sub_80AF502(a1, (float *)s1);
  v4 = va("      dvar set %s %s\n", *(_DWORD *)a1, v3);
  Com_PrintMessage(4, v4);
  if ( (unsigned __int8)sub_80AFE1A(*(_BYTE *)(a1 + 6), (int)s1, *(float *)(a1 + 20), *(float *)(a1 + 24)) ^ 1 )
  {
    v5 = sub_80AF502(a1, (float *)s1);
    Com_Printf("'%s' is not a valid value for dvar '%s'\n", v5, *(_DWORD *)a1);
    sub_80B04A4(*(_BYTE *)(a1 + 6), *(_DWORD *)(a1 + 20), *(_DWORD *)(a1 + 24));
    if ( *(_BYTE *)(a1 + 6) == 6 )
      sub_80B072A(a1, *(char **)(a1 + 16), a3);
    return;
  }
  if ( a3 != 1 && a3 != 2 )
    goto LABEL_33;
  if ( *(_WORD *)(a1 + 4) & 0x40 )
  {
    Com_Printf("%s is read only.\n", *(_DWORD *)a1);
    return;
  }
  if ( *(_WORD *)(a1 + 4) & 0x10 )
  {
    Com_Printf("%s is write protected.\n", *(_DWORD *)a1);
    return;
  }
  if ( a3 == 1 && *(_BYTE *)(a1 + 4) < 0 && !*(_BYTE *)(dword_85178A4 + 8) )
  {
    Com_Printf("%s is cheat protected.\n", *(_DWORD *)a1);
    return;
  }
  if ( !(*(_WORD *)(a1 + 4) & 0x20) )
  {
LABEL_33:
    if ( (unsigned __int8)sub_80B04FE(*(unsigned __int8 *)(a1 + 6), *(char **)(a1 + 8), s1) )
    {
      sub_80B0620(a1, *(char **)(a1 + 8));
      return;
    }
    dvar_modifiedFlags |= *(unsigned __int16 *)(a1 + 4);
    v6 = *(unsigned __int8 *)(a1 + 6);
    if ( v6 == 3 )
    {
      sub_80B326C(s1, *(_DWORD **)(a1 + 8));
      sub_80B326C(s1, *(_DWORD **)(a1 + 12));
    }
    else if ( v6 > 3 )
    {
      if ( v6 == 4 )
      {
        sub_80B336A(s1, *(_DWORD **)(a1 + 8));
        sub_80B336A(s1, *(_DWORD **)(a1 + 12));
      }
      else
      {
        if ( v6 != 7 )
        {
LABEL_29:
          *(_DWORD *)(a1 + 8) = s1;
          *(_DWORD *)(a1 + 12) = s1;
          goto LABEL_30;
        }
        sub_80AF1CE(a1);
        sub_80AF282(a1, s1);
        sub_80AF20A(a1);
        *(_DWORD *)(a1 + 12) = *(_DWORD *)(a1 + 8);
      }
    }
    else
    {
      if ( v6 != 2 )
        goto LABEL_29;
      sub_80B31B0(s1, *(_DWORD **)(a1 + 8));
      sub_80B31B0(s1, *(_DWORD **)(a1 + 12));
    }
LABEL_30:
    *(_BYTE *)(a1 + 7) = 1;
    return;
  }
  sub_80B0620(a1, s1);
  if ( (unsigned __int8)sub_80B04FE(*(unsigned __int8 *)(a1 + 6), *(char **)(a1 + 12), *(char **)(a1 + 8)) ^ 1 )
    Com_Printf("%s will be changed upon restarting.\n", *(_DWORD *)a1);
}
// 85178A4: using guessed type int dword_85178A4;
// 85178A8: using guessed type int dvar_modifiedFlags;

//----- (080B0A84) --------------------------------------------------------
int __cdecl Dvar_FindMalleableVar(char *a1)
{
  int i; // [esp+14h] [ebp-4h]

  for ( i = dword_8522CE0[sub_80AEEEC((int)a1)]; i; i = *(_DWORD *)(i + 32) )
  {
    if ( !I_stricmp(a1, *(char **)i) )
      return i;
  }
  return 0;
}

//----- (080B0AE4) --------------------------------------------------------
int __cdecl Dvar_FindVar(char *a1)
{
  return Dvar_FindMalleableVar(a1);
}

//----- (080B0AF8) --------------------------------------------------------
int __cdecl Dvar_ClearModified(int a1)
{
  int result; // eax

  result = a1;
  *(_BYTE *)(a1 + 7) = 0;
  return result;
}

//----- (080B0BB6) --------------------------------------------------------
int __cdecl Dvar_GetBool(char *a1)
{
  int v3; // [esp+14h] [ebp-4h]

  v3 = Dvar_FindVar(a1);
  if ( !v3 )
    return 0;
  if ( *(_BYTE *)(v3 + 6) )
    return (unsigned __int8)sub_80AF6DE(*(char **)(v3 + 8));
  return *(unsigned __int8 *)(v3 + 8);
}

//----- (080B0C08) --------------------------------------------------------
int __cdecl Dvar_GetInt(char *a1)
{
  int v3; // [esp+14h] [ebp-4h]

  v3 = Dvar_FindVar(a1);
  if ( !v3 )
    return 0;
  if ( *(_BYTE *)(v3 + 6) != 5 && *(_BYTE *)(v3 + 6) != 6 )
    return sub_80AF704(*(char **)(v3 + 8));
  return *(_DWORD *)(v3 + 8);
}

//----- (080B0C60) --------------------------------------------------------
long double __cdecl sub_80B0C60(char *a1)
{
  float v2; // [esp+10h] [ebp-8h]
  int v3; // [esp+14h] [ebp-4h]

  v3 = Dvar_FindVar(a1);
  if ( v3 )
  {
    if ( *(_BYTE *)(v3 + 6) == 1 )
      v2 = *(float *)(v3 + 8);
    else
      v2 = sub_80AF718((char *)*(_DWORD *)(v3 + 8));
  }
  else
  {
    v2 = 0.0;
  }
  return v2;
}

//----- (080B0CAC) --------------------------------------------------------
char *__cdecl sub_80B0CAC(char *a1)
{
  int v3; // [esp+14h] [ebp-4h]

  v3 = Dvar_FindVar(a1);
  if ( !v3 )
    return (char *)&unk_8145E60;
  if ( *(_BYTE *)(v3 + 6) == 2 )
    return *(char **)(v3 + 8);
  return sub_80AF738(*(char **)(v3 + 8));
}

//----- (080B0CFA) --------------------------------------------------------
char *__cdecl sub_80B0CFA(char *a1)
{
  int v3; // [esp+14h] [ebp-4h]

  v3 = Dvar_FindVar(a1);
  if ( !v3 )
    return (char *)&unk_8145E68;
  if ( *(_BYTE *)(v3 + 6) == 3 )
    return *(char **)(v3 + 8);
  return sub_80AF782(*(char **)(v3 + 8));
}

//----- (080B0D48) --------------------------------------------------------
char *__cdecl sub_80B0D48(char *a1)
{
  int v3; // [esp+14h] [ebp-4h]

  v3 = Dvar_FindVar(a1);
  if ( !v3 )
    return (char *)&unk_8145E74;
  if ( *(_BYTE *)(v3 + 6) == 4 )
    return *(char **)(v3 + 8);
  return sub_80AF7D6(*(char **)(v3 + 8));
}

//----- (080B0D96) --------------------------------------------------------
void *__cdecl sub_80B0D96(char *a1)
{
  int v3; // [esp+14h] [ebp-4h]

  v3 = Dvar_FindVar(a1);
  if ( !v3 )
    return &unk_8147CE0;
  if ( *(_BYTE *)(v3 + 6) == 6 )
    return sub_80AF43E((_DWORD *)v3);
  return *(void **)(v3 + 8);
}

//----- (080B0DE0) --------------------------------------------------------
char *__cdecl sub_80B0DE0(char *a1)
{
  char *v2; // [esp+Ch] [ebp-Ch]
  int v3; // [esp+14h] [ebp-4h]

  v3 = Dvar_FindVar(a1);
  if ( v3 )
    v2 = sub_80AF502(v3, *(float **)(v3 + 8));
  else
    v2 = (char *)&unk_8147CE0;
  return v2;
}

//----- (080B0E28) --------------------------------------------------------
int __usercall sub_80B0E28@<eax>(long double a1@<st0>, int a2, float *a3)
{
  int result; // eax
  int v4; // [esp+14h] [ebp-4h]

  if ( *(_BYTE *)(a2 + 6) == 8 )
    sub_80B3432((_DWORD *)(a2 + 8), &v4);
  else
    sub_80AF95E(a1, *(char **)(a2 + 8), (int)&v4);
  *a3 = (long double)(unsigned __int8)v4 * 0.0039215689;
  a3[1] = (long double)BYTE1(v4) * 0.0039215689;
  a3[2] = (long double)BYTE2(v4) * 0.0039215689;
  result = HIBYTE(v4);
  a3[3] = (long double)HIBYTE(v4) * 0.0039215689;
  return result;
}

//----- (080B0ED2) --------------------------------------------------------
int __usercall sub_80B0ED2@<eax>(long double a1@<st0>, char *a2, float *a3)
{
  int result; // eax
  int v4; // [esp+14h] [ebp-4h]

  v4 = Dvar_FindVar(a2);
  if ( v4 )
    result = sub_80B0E28(a1, v4, a3);
  else
    result = sub_80B336A(&unk_8148660, a3);
  return result;
}

//----- (080B0F16) --------------------------------------------------------
void *sub_80B0F16()
{
  int i; // [esp+14h] [ebp-4h]

  for ( i = sortedDvars; i; i = *(_DWORD *)(i + 28) )
  {
    if ( *(_BYTE *)(i + 6) == 7 )
    {
      sub_80AF1CE(i);
      sub_80AF246(i);
      sub_80AF20A(i);
    }
    else if ( *(_BYTE *)(i + 6) == 2 || *(_BYTE *)(i + 6) == 3 || *(_BYTE *)(i + 6) == 4 )
    {
      sub_80AF06A(i);
    }
    if ( *(_WORD *)(i + 4) & 0x4000 )
      sub_80AF094(*(void **)i);
  }
  *(_DWORD *)dword_8522CC0 = 0;
  sortedDvars = 0;
  dword_85178A4 = 0;
  dvar_modifiedFlags = 0;
  isDvarSystemActive = 0;
  return memset(dword_8522CE0, 0, 0x400u);
}
// 85178A0: using guessed type int sortedDvars;
// 85178A4: using guessed type int dword_85178A4;
// 85178A8: using guessed type int dvar_modifiedFlags;
// 8523114: using guessed type char isDvarSystemActive;

//----- (080B0FF8) --------------------------------------------------------
void __cdecl sub_80B0FF8(int a1)
{
  char *v1; // eax
  char *v2; // eax
  void *ptr; // [esp+10h] [ebp-8h]

  if ( !(*(_WORD *)(a1 + 4) & 0x4000) )
  {
    *(_WORD *)(a1 + 4) |= 0x4000u;
    *(_DWORD *)a1 = sub_80AF080(*(char **)a1);
  }
  if ( *(_BYTE *)(a1 + 6) != 7 )
  {
    if ( *(_BYTE *)(a1 + 6) != 2 && *(_BYTE *)(a1 + 6) != 3 && *(_BYTE *)(a1 + 6) != 4 )
      ptr = 0;
    else
      ptr = *(void **)(a1 + 8);
    v1 = Dvar_DisplayableLatchedValue(a1);
    *(_DWORD *)(a1 + 8) = sub_80AF0A8(v1);
    *(_DWORD *)(a1 + 12) = *(_DWORD *)(a1 + 8);
    v2 = Dvar_DisplayableResetValue(a1);
    sub_80AF3AA(a1, v2);
    *(_BYTE *)(a1 + 6) = 7;
    if ( ptr )
      Z_FreeInternal(ptr);
  }
}

//----- (080B10CE) --------------------------------------------------------
void __cdecl sub_80B10CE(int a1, __int16 a2)
{
  if ( !(*(_WORD *)(a1 + 4) & 0x4000) )
  {
    *(_WORD *)(a1 + 4) &= ~a2;
    if ( !(*(_WORD *)(a1 + 4) & 0x7000) )
      sub_80B0FF8(a1);
  }
}

//----- (080B1120) --------------------------------------------------------
int __cdecl sub_80B1120(__int16 a1)
{
  int result; // eax
  int i; // [esp+14h] [ebp-4h]

  result = sortedDvars;
  for ( i = sortedDvars; i; i = *(_DWORD *)(i + 28) )
  {
    if ( (unsigned __int16)a1 & *(_WORD *)(i + 4) )
      sub_80B10CE(i, a1);
    result = *(_DWORD *)(i + 28);
  }
  return result;
}
// 85178A0: using guessed type int sortedDvars;

//----- (080B1164) --------------------------------------------------------
char *__cdecl sub_80B1164(int a1, char *s1)
{
  char *result; // eax
  signed int v3; // [esp+14h] [ebp-4h]

  v3 = *(unsigned __int8 *)(a1 + 6);
  if ( v3 == 3 )
    return (char *)sub_80B326C(s1, *(_DWORD **)(a1 + 16));
  if ( v3 > 3 )
  {
    if ( v3 == 4 )
      return (char *)sub_80B336A(s1, *(_DWORD **)(a1 + 16));
    if ( v3 == 7 )
    {
      sub_80AF246(a1);
      return sub_80AF3AA(a1, s1);
    }
  }
  else if ( v3 == 2 )
  {
    return (char *)sub_80B31B0(s1, *(_DWORD **)(a1 + 16));
  }
  result = s1;
  *(_DWORD *)(a1 + 16) = s1;
  return result;
}

//----- (080B1208) --------------------------------------------------------
char *__cdecl sub_80B1208(int a1, char *s1)
{
  return sub_80B1164(a1, s1);
}

//----- (080B1222) --------------------------------------------------------
char *__cdecl sub_80B1222(int a1, char *s1)
{
  char *result; // eax
  signed int v3; // [esp+14h] [ebp-4h]

  v3 = *(unsigned __int8 *)(a1 + 6);
  if ( v3 == 3 )
  {
    sub_80B326C(s1, *(_DWORD **)(a1 + 8));
    return (char *)sub_80B326C(s1, *(_DWORD **)(a1 + 12));
  }
  if ( v3 <= 3 )
  {
    if ( v3 == 2 )
    {
      sub_80B31B0(s1, *(_DWORD **)(a1 + 8));
      return (char *)sub_80B31B0(s1, *(_DWORD **)(a1 + 12));
    }
LABEL_13:
    *(_DWORD *)(a1 + 8) = s1;
    result = s1;
    *(_DWORD *)(a1 + 12) = s1;
    return result;
  }
  if ( v3 == 4 )
  {
    sub_80B336A(s1, *(_DWORD **)(a1 + 8));
    return (char *)sub_80B336A(s1, *(_DWORD **)(a1 + 12));
  }
  if ( v3 != 7 )
    goto LABEL_13;
  if ( s1 != *(char **)(a1 + 8) )
  {
    sub_80AF1CE(a1);
    sub_80AF282(a1, s1);
  }
  result = s1;
  *(_DWORD *)(a1 + 12) = s1;
  return result;
}

//----- (080B1334) --------------------------------------------------------
int __usercall sub_80B1334@<eax>(long double a1@<st0>, int a2, int a3, int a4, int a5, char *s1, int a7, int a8)
{
  _DWORD *v8; // ecx
  int v9; // edx
  int result; // eax
  char *v11; // [esp+24h] [ebp-24h]
  char *v12; // [esp+28h] [ebp-20h]
  char *v13; // [esp+2Ch] [ebp-1Ch]
  int v14; // [esp+30h] [ebp-18h]
  int v15; // [esp+34h] [ebp-14h]
  unsigned __int16 v16; // [esp+3Ch] [ebp-Ch]
  char v17; // [esp+3Fh] [ebp-9h]

  v14 = a7;
  v15 = a8;
  v17 = a4;
  v16 = a5;
  *(_BYTE *)(a2 + 6) = a4;
  v8 = (_DWORD *)(a2 + 20);
  v9 = v15;
  *v8 = v14;
  v8[1] = v9;
  if ( v16 & 0x40 || (v16 & 0x80u) != 0 && dword_85178A4 && !*(_BYTE *)(dword_85178A4 + 8) )
  {
    v13 = s1;
  }
  else
  {
    sub_80AFA9E(a1, (float *)&v12, *(_BYTE *)(a2 + 6), *(_DWORD *)(a2 + 20), *(_DWORD *)(a2 + 24), *(char **)(a2 + 8));
    v13 = v12;
    sub_80AFCF6((float *)&v11, v17, *(float *)&v12, *(float *)&s1, *(float *)&v14, *(float *)&v15);
    v13 = v11;
  }
  if ( *(_BYTE *)(a2 + 6) != 7 )
    sub_80AF1CE(a2);
  sub_80AF20A(a2);
  sub_80AF246(a2);
  if ( *(_BYTE *)(a2 + 6) == 2 || *(_BYTE *)(a2 + 6) == 3 || *(_BYTE *)(a2 + 6) == 4 )
    sub_80AF012(a2);
  sub_80B1164(a2, s1);
  sub_80B1222(a2, v13);
  result = v16;
  dvar_modifiedFlags |= v16;
  return result;
}
// 85178A4: using guessed type int dword_85178A4;
// 85178A8: using guessed type int dvar_modifiedFlags;

//----- (080B1498) --------------------------------------------------------
_DWORD *__userpurge sub_80B1498@<eax>(_DWORD *a1, int a2, int a3)
{
  *a1 = a3;
  return a1;
}

//----- (080B14CC) --------------------------------------------------------
int __usercall sub_80B14CC@<eax>(long double a1@<st0>, int a2, int a3, unsigned __int8 a4, unsigned __int16 a5, int a6, int a7, int a8)
{
  int result; // eax
  char *v9; // [esp+28h] [ebp-20h]
  char *s1; // [esp+2Ch] [ebp-1Ch]
  int v11; // [esp+30h] [ebp-18h]
  int v12; // [esp+34h] [ebp-14h]
  unsigned __int16 v13; // [esp+3Ch] [ebp-Ch]
  unsigned __int8 v14; // [esp+3Fh] [ebp-9h]

  v11 = a7;
  v12 = a8;
  v14 = a4;
  v13 = a5;
  result = *(_WORD *)(a2 + 4) & 0x4000;
  if ( *(_WORD *)(a2 + 4) & 0x4000 )
  {
    result = v13 & 0x4000;
    if ( !(v13 & 0x4000) )
    {
      sub_80B1498(&v9, a2, a6);
      s1 = v9;
      sub_80B0FF8(a2);
      sub_80AF094(*(void **)a2);
      *(_DWORD *)a2 = a3;
      *(_WORD *)(a2 + 4) &= 0xBFFFu;
      result = sub_80B1334(a1, a2, a3, v14, v13, s1, v11, v12);
    }
  }
  return result;
}

//----- (080B15C0) --------------------------------------------------------
int __cdecl sub_80B15C0(int a1, int a2, int a3, __int16 a4, int a5, int a6, int a7)
{
  int result; // eax
  int *v8; // ecx

  result = a4 & 0x4000;
  if ( !(a4 & 0x4000) )
  {
    result = a4 & 0x1000;
    if ( a4 & 0x1000 )
    {
      result = *(_WORD *)(a1 + 4) & 0x1000;
      if ( !(*(_WORD *)(a1 + 4) & 0x1000) )
      {
        *(_DWORD *)a1 = a2;
        result = a1;
        if ( *(_BYTE *)(a1 + 6) == 6 )
        {
          v8 = (int *)(a1 + 20);
          result = a6;
          *v8 = a6;
          v8[1] = a7;
        }
      }
    }
  }
  return result;
}

//----- (080B1634) --------------------------------------------------------
void __cdecl sub_80B1634(int a1)
{
  sub_80B072A(a1, *(char **)(a1 + 12), 0);
}

//----- (080B165C) --------------------------------------------------------
char *__cdecl sub_80B165C(int a1)
{
  char *result; // eax

  result = (char *)Dvar_HasLatchedValue(a1);
  if ( (_BYTE)result )
    result = sub_80B0620(a1, *(char **)(a1 + 8));
  return result;
}

//----- (080B168C) --------------------------------------------------------
void __usercall Dvar_Reregister(long double a1@<st0>, int a2, int a3, int a4, int a5, char *s1, int a7, int a8)
{
  if ( (*(_WORD *)(a2 + 4) ^ (unsigned __int16)a5) & 0x7000 )
  {
    sub_80B14CC(a1, a2, a3, a4, a5, (int)s1, a7, a8);
    sub_80B15C0(a2, a3, (unsigned __int8)a4, a5, (int)s1, a7, a8);
  }
  if ( *(_WORD *)(a2 + 4) & 0x4000 && *(_BYTE *)(a2 + 6) != (_BYTE)a4 )
    sub_80B1334(a1, a2, a3, (unsigned __int8)a4, (unsigned __int16)a5, s1, a7, a8);
  *(_WORD *)(a2 + 4) |= a5;
  if ( *(_BYTE *)(a2 + 4) < 0 && dword_85178A4 && !*(_BYTE *)(dword_85178A4 + 8) )
  {
    sub_80B072A(a2, *(char **)(a2 + 16), 0);
    sub_80B0620(a2, *(char **)(a2 + 16));
  }
  if ( *(_WORD *)(a2 + 4) & 0x20 )
    sub_80B1634(a2);
}
// 85178A4: using guessed type int dword_85178A4;

//----- (080B180C) --------------------------------------------------------
char *__cdecl Dvar_RegisterNew(char *src, int a2, int a3, char *s, int a5, int a6)
{
  int *v6; // eax
  int v7; // eax
  const char ***i; // [esp+18h] [ebp-20h]
  char *v10; // [esp+1Ch] [ebp-1Ch]

  if ( *(_DWORD *)dword_8522CC0 > 1279 )
    Com_Error(0, "Can't create dvar '%s': %i dvars already exist", src, 1280);
  v10 = (char *)&unk_85178C0 + 36 * (*(_DWORD *)dword_8522CC0)++;
  v10[6] = a2;
  if ( a3 & 0x4000 )
    *(_DWORD *)v10 = sub_80AF080(src);
  else
    *(_DWORD *)v10 = src;
  if ( (unsigned __int8)a2 == 3 )
  {
    sub_80AF012((int)v10);
    sub_80B326C(s, *((_DWORD **)v10 + 2));
    sub_80B326C(s, *((_DWORD **)v10 + 3));
    sub_80B326C(s, *((_DWORD **)v10 + 4));
  }
  else if ( (signed int)(unsigned __int8)a2 > 3 )
  {
    if ( (unsigned __int8)a2 == 4 )
    {
      sub_80AF012((int)v10);
      sub_80B336A(s, *((_DWORD **)v10 + 2));
      sub_80B336A(s, *((_DWORD **)v10 + 3));
      sub_80B336A(s, *((_DWORD **)v10 + 4));
    }
    else
    {
      if ( (unsigned __int8)a2 != 7 )
      {
LABEL_16:
        *((_DWORD *)v10 + 2) = s;
        *((_DWORD *)v10 + 3) = s;
        *((_DWORD *)v10 + 4) = s;
        goto LABEL_17;
      }
      *((_DWORD *)v10 + 2) = sub_80AF0A8(s);
      *((_DWORD *)v10 + 3) = *((_DWORD *)v10 + 2);
      *((_DWORD *)v10 + 4) = *((_DWORD *)v10 + 2);
    }
  }
  else
  {
    if ( (unsigned __int8)a2 != 2 )
      goto LABEL_16;
    sub_80AF012((int)v10);
    sub_80B31B0(s, *((_DWORD **)v10 + 2));
    sub_80B31B0(s, *((_DWORD **)v10 + 3));
    sub_80B31B0(s, *((_DWORD **)v10 + 4));
  }
LABEL_17:
  v6 = (int *)(v10 + 20);
  *v6 = a5;
  v6[1] = a6;
  v10[7] = 0;
  for ( i = (const char ***)&sortedDvars; *i && strcasecmp(*(const char **)v10, **i) >= 0; i = (const char ***)(*i + 7) )
    ;
  *((_DWORD *)v10 + 7) = *i;
  *i = (const char **)v10;
  *((_WORD *)v10 + 2) = a3;
  v7 = sub_80AEEEC((int)src);
  *((_DWORD *)v10 + 8) = dword_8522CE0[v7];
  dword_8522CE0[v7] = (int)v10;
  return v10;
}
// 85178A0: using guessed type int sortedDvars;

//----- (080B1AC2) --------------------------------------------------------
char *__usercall Dvar_RegisterVariant@<eax>(long double a1@<st0>, char *src, int a3, int a4, char *s1, int a6, int a7)
{
  int v9; // [esp+2Ch] [ebp-1Ch]

  v9 = Dvar_FindMalleableVar(src);
  if ( !v9 )
    return Dvar_RegisterNew(src, (unsigned __int8)a3, (unsigned __int16)a4, s1, a6, a7);
  Dvar_Reregister(a1, v9, (int)src, (unsigned __int8)a3, (unsigned __int16)a4, s1, a6, a7);
  return (char *)v9;
}

//----- (080B1B72) --------------------------------------------------------
char *__usercall Dvar_RegisterBool@<eax>(long double a1@<st0>, char *src, int a3, int a4)
{
  int s; // [esp+18h] [ebp-10h]
  int v6; // [esp+1Ch] [ebp-Ch]
  char *s1; // [esp+20h] [ebp-8h]
  unsigned __int16 v8; // [esp+24h] [ebp-4h]
  char v9; // [esp+27h] [ebp-1h]

  v9 = a3;
  v8 = a4;
  LOBYTE(s1) = a3;
  memset(&s, 0, 8u);
  return Dvar_RegisterVariant(a1, src, 0, v8, s1, s, v6);
}

//----- (080B1BDA) --------------------------------------------------------
char *__usercall Dvar_RegisterInt@<eax>(long double a1@<st0>, char *src, int a3, int a4, int a5, int a6)
{
  return Dvar_RegisterVariant(a1, src, 5, (unsigned __int16)a6, (char *)a3, a4, a5);
}

//----- (080B1C2C) --------------------------------------------------------
char *__usercall Dvar_RegisterFloat@<eax>(long double a1@<st0>, char *src, int a3, int a4, int a5, int a6)
{
  return Dvar_RegisterVariant(a1, src, 1, (unsigned __int16)a6, (char *)a3, a4, a5);
}

//----- (080B1C7E) --------------------------------------------------------
char *__usercall sub_80B1C7E@<eax>(long double a1@<st0>, char *src, int a3, int a4, int a5, int a6, int a7)
{
  char v8; // [esp+20h] [ebp-18h]
  int v9; // [esp+28h] [ebp-10h]
  int v10; // [esp+2Ch] [ebp-Ch]
  char *s1; // [esp+30h] [ebp-8h]
  unsigned __int16 v12; // [esp+36h] [ebp-2h]

  v12 = a7;
  sub_80B3198(&v8, a3, a4);
  s1 = &v8;
  v9 = a5;
  v10 = a6;
  return Dvar_RegisterVariant(a1, src, 2, v12, &v8, a5, a6);
}

//----- (080B1CE8) --------------------------------------------------------
char *__usercall sub_80B1CE8@<eax>(long double a1@<st0>, char *src, int a3, int a4, int a5, int a6, int a7, int a8)
{
  char v9; // [esp+20h] [ebp-28h]
  int v10; // [esp+30h] [ebp-18h]
  int v11; // [esp+34h] [ebp-14h]
  char *s1; // [esp+38h] [ebp-10h]
  unsigned __int16 v13; // [esp+3Eh] [ebp-Ah]

  v13 = a8;
  sub_80B3248(&v9, a3, a4, a5);
  s1 = &v9;
  v10 = a6;
  v11 = a7;
  return Dvar_RegisterVariant(a1, src, 3, v13, &v9, a6, a7);
}

//----- (080B1D5A) --------------------------------------------------------
char *__usercall sub_80B1D5A@<eax>(long double a1@<st0>, char *src, int a3, int a4, int a5, int a6, int a7, int a8, int a9)
{
  char v10; // [esp+20h] [ebp-28h]
  int v11; // [esp+30h] [ebp-18h]
  int v12; // [esp+34h] [ebp-14h]
  char *s1; // [esp+38h] [ebp-10h]
  unsigned __int16 v14; // [esp+3Eh] [ebp-Ah]

  v14 = a9;
  sub_80B333C(&v10, a3, a4, a5, a6);
  s1 = &v10;
  v11 = a7;
  v12 = a8;
  return Dvar_RegisterVariant(a1, src, 4, v14, &v10, a7, a8);
}

//----- (080B1DD2) --------------------------------------------------------
char *__usercall Dvar_RegisterString@<eax>(long double a1@<st0>, char *src, int a3, int a4)
{
  int s; // [esp+18h] [ebp-10h]
  int v6; // [esp+1Ch] [ebp-Ch]
  char *s1; // [esp+20h] [ebp-8h]
  unsigned __int16 v8; // [esp+26h] [ebp-2h]

  v8 = a4;
  s1 = (char *)a3;
  memset(&s, 0, 8u);
  return Dvar_RegisterVariant(a1, src, 7, v8, s1, s, v6);
}

//----- (080B1E32) --------------------------------------------------------
char *__usercall sub_80B1E32@<eax>(long double a1@<st0>, char *src, int a3, int a4, int a5)
{
  int i; // [esp+18h] [ebp-10h]

  for ( i = 0; *(_DWORD *)(a3 + 4 * i); ++i )
    ;
  return Dvar_RegisterVariant(a1, src, 6, (unsigned __int16)a5, (char *)a4, i, a3);
}

//----- (080B1EA0) --------------------------------------------------------
char *__usercall sub_80B1EA0@<eax>(long double a1@<st0>, char *src, float a3, float a4, float a5, float a6, int a7)
{
  float v7; // ST04_4
  long double v8; // fst7
  float v9; // ST00_4
  float v10; // ST04_4
  long double v11; // fst7
  float v12; // ST00_4
  float v13; // ST04_4
  long double v14; // fst7
  float v15; // ST00_4
  float v16; // ST04_4
  long double v17; // fst7
  float v18; // ST00_4
  int s; // [esp+18h] [ebp-10h]
  int v21; // [esp+1Ch] [ebp-Ch]
  char *s1; // [esp+20h] [ebp-8h]
  unsigned __int16 v23; // [esp+26h] [ebp-2h]

  v23 = a7;
  sub_80B3122(1.0, a3);
  v7 = a1;
  sub_80B30FE(0.0, v7);
  v8 = a1 * 255.0;
  v9 = v8;
  LOBYTE(s1) = sub_80B3146(v9);
  sub_80B3122(1.0, a4);
  v10 = v8;
  sub_80B30FE(0.0, v10);
  v11 = v8 * 255.0;
  v12 = v11;
  BYTE1(s1) = sub_80B3146(v12);
  sub_80B3122(1.0, a5);
  v13 = v11;
  sub_80B30FE(0.0, v13);
  v14 = v11 * 255.0;
  v15 = v14;
  BYTE2(s1) = sub_80B3146(v15);
  sub_80B3122(1.0, a6);
  v16 = v14;
  sub_80B30FE(0.0, v16);
  v17 = v14 * 255.0;
  v18 = v17;
  HIBYTE(s1) = sub_80B3146(v18);
  memset(&s, 0, 8u);
  return Dvar_RegisterVariant(v17, src, 8, v23, s1, s, v21);
}

//----- (080B1FDA) --------------------------------------------------------
void __cdecl sub_80B1FDA(int a1, char a2, int a3)
{
  char *v3; // [esp+Ch] [ebp-Ch]
  char *s1; // [esp+10h] [ebp-8h]

  if ( *(_BYTE *)(a1 + 6) )
  {
    if ( a2 )
      v3 = (char *)&unk_8147CE1;
    else
      v3 = (char *)&unk_8147CE3;
    sub_80B072A(a1, v3, a3);
  }
  else
  {
    LOBYTE(s1) = a2;
    sub_80B072A(a1, s1, a3);
  }
}

//----- (080B2030) --------------------------------------------------------
void __cdecl sub_80B2030(int a1, char *a2, int a3)
{
  char s; // [esp+10h] [ebp-38h]
  char *s1; // [esp+3Ch] [ebp-Ch]

  if ( *(_BYTE *)(a1 + 6) != 5 && *(_BYTE *)(a1 + 6) != 6 )
  {
    Com_sprintf(&s, 0x20u, "%i", a2);
    s1 = &s;
  }
  else
  {
    s1 = a2;
  }
  sub_80B072A(a1, s1, a3);
}

//----- (080B2096) --------------------------------------------------------
void __cdecl sub_80B2096(int a1, char *a2, int a3)
{
  char s; // [esp+20h] [ebp-38h]
  char *s1; // [esp+4Ch] [ebp-Ch]

  if ( *(_BYTE *)(a1 + 6) == 1 )
  {
    s1 = a2;
  }
  else
  {
    Com_sprintf(&s, 0x20u, "%g", *(float *)&a2);
    s1 = &s;
  }
  sub_80B072A(a1, s1, a3);
}

//----- (080B20F0) --------------------------------------------------------
void __cdecl sub_80B20F0(int a1, int a2, int a3, int a4)
{
  char s; // [esp+20h] [ebp-58h]
  char v5; // [esp+60h] [ebp-18h]
  char *s1; // [esp+6Ch] [ebp-Ch]

  if ( *(_BYTE *)(a1 + 6) == 4 )
  {
    sub_80B3198(&v5, a2, a3);
    s1 = &v5;
  }
  else
  {
    Com_sprintf(&s, 0x40u, "%g %g", (_QWORD)a2, (_QWORD)a3);
    s1 = &s;
  }
  sub_80B072A(a1, s1, a4);
}

//----- (080B216A) --------------------------------------------------------
void __cdecl sub_80B216A(int a1, int a2, int a3, int a4, int a5)
{
  char s; // [esp+30h] [ebp-88h]
  char v6; // [esp+90h] [ebp-28h]
  char *s1; // [esp+ACh] [ebp-Ch]

  if ( *(_BYTE *)(a1 + 6) == 3 )
  {
    sub_80B3248(&v6, a2, a3, a4);
    s1 = &v6;
  }
  else
  {
    Com_sprintf(&s, 0x60u, "%g %g %g", (_QWORD)a2, (_QWORD)a3, (_QWORD)a4);
    s1 = &s;
  }
  sub_80B072A(a1, s1, a5);
}

//----- (080B21FC) --------------------------------------------------------
void __cdecl sub_80B21FC(int a1, int a2, int a3, int a4, int a5, int a6)
{
  char s; // [esp+30h] [ebp-A8h]
  char v7; // [esp+B0h] [ebp-28h]
  char *s1; // [esp+CCh] [ebp-Ch]

  if ( *(_BYTE *)(a1 + 6) == 4 )
  {
    sub_80B333C(&v7, a2, a3, a4, a5);
    s1 = &v7;
  }
  else
  {
    Com_sprintf(&s, 0x80u, "%g %g %g %g", (_QWORD)a2, (_QWORD)a3, (_QWORD)a4, (_QWORD)a5);
    s1 = &s;
  }
  sub_80B072A(a1, s1, a6);
}

//----- (080B229C) --------------------------------------------------------
void __cdecl sub_80B229C(int a1, char *src, int a3)
{
  char dest; // [esp+10h] [ebp-418h]
  char *s1; // [esp+41Ch] [ebp-Ch]

  if ( *(_BYTE *)(a1 + 6) == 7 )
  {
    I_strncpyz(&dest, src, 1024);
    s1 = &dest;
  }
  else
  {
    s1 = (char *)sub_80AF834(a1 + 20, src);
  }
  sub_80B072A(a1, s1, a3);
}

//----- (080B230A) --------------------------------------------------------
void __usercall sub_80B230A(long double a1@<st0>, int a2, float a3, float a4, float a5, float a6, int a7)
{
  float v7; // ST04_4
  long double v8; // fst7
  float v9; // ST00_4
  float v10; // ST04_4
  long double v11; // fst7
  float v12; // ST00_4
  float v13; // ST04_4
  long double v14; // fst7
  float v15; // ST00_4
  float v16; // ST04_4
  float v17; // ST00_4
  char s; // [esp+30h] [ebp-98h]
  char *s1; // [esp+BCh] [ebp-Ch]

  if ( *(_BYTE *)(a2 + 6) == 8 )
  {
    sub_80B3122(1.0, a3);
    v7 = a1;
    sub_80B30FE(0.0, v7);
    v8 = a1 * 255.0;
    v9 = v8;
    LOBYTE(s1) = sub_80B3146(v9);
    sub_80B3122(1.0, a4);
    v10 = v8;
    sub_80B30FE(0.0, v10);
    v11 = v8 * 255.0;
    v12 = v11;
    BYTE1(s1) = sub_80B3146(v12);
    sub_80B3122(1.0, a5);
    v13 = v11;
    sub_80B30FE(0.0, v13);
    v14 = v11 * 255.0;
    v15 = v14;
    BYTE2(s1) = sub_80B3146(v15);
    sub_80B3122(1.0, a6);
    v16 = v14;
    sub_80B30FE(0.0, v16);
    v17 = v14 * 255.0;
    HIBYTE(s1) = sub_80B3146(v17);
  }
  else
  {
    Com_sprintf(&s, 0x80u, "%g %g %g %g", a3, a4, a5, a6);
    s1 = &s;
  }
  sub_80B072A(a2, s1, a7);
}

//----- (080B2460) --------------------------------------------------------
void __cdecl Dvar_SetBool(int a1, char a2)
{
  sub_80B1FDA(a1, a2, 0);
}

//----- (080B248A) --------------------------------------------------------
void __cdecl Dvar_SetInt(int a1, char *a2)
{
  sub_80B2030(a1, a2, 0);
}

//----- (080B24AC) --------------------------------------------------------
void __cdecl sub_80B24AC(int a1, char *a2)
{
  sub_80B2096(a1, a2, 0);
}

//----- (080B24CE) --------------------------------------------------------
void __cdecl sub_80B24CE(int a1, int a2, int a3)
{
  sub_80B20F0(a1, a2, a3, 0);
}

//----- (080B24F8) --------------------------------------------------------
void __cdecl sub_80B24F8(int a1, int a2, int a3, int a4)
{
  sub_80B216A(a1, a2, a3, a4, 0);
}

//----- (080B2528) --------------------------------------------------------
void __cdecl sub_80B2528(int a1, int a2, int a3, int a4, int a5)
{
  sub_80B21FC(a1, a2, a3, a4, a5, 0);
}

//----- (080B2560) --------------------------------------------------------
void __cdecl Dvar_SetString(int a1, char *src)
{
  sub_80B229C(a1, src, 0);
}

//----- (080B2582) --------------------------------------------------------
void __usercall sub_80B2582(long double a1@<st0>, int a2, float a3, float a4, float a5, float a6)
{
  sub_80B230A(a1, a2, a3, a4, a5, a6, 0);
}

//----- (080B25BA) --------------------------------------------------------
void __usercall sub_80B25BA(long double a1@<st0>, int a2, char *src, int a4)
{
  char *v4; // [esp+2Ch] [ebp-41Ch]
  char dest; // [esp+30h] [ebp-418h]
  char *s1; // [esp+43Ch] [ebp-Ch]

  I_strncpyz(&dest, src, 1024);
  sub_80AFA9E(a1, (float *)&v4, *(_BYTE *)(a2 + 6), *(_DWORD *)(a2 + 20), *(_DWORD *)(a2 + 24), &dest);
  s1 = v4;
  if ( *(_BYTE *)(a2 + 6) == 6 && s1 == (char *)-1337 )
  {
    Com_Printf("'%s' is not a valid value for dvar '%s'\n", &dest, *(_DWORD *)a2);
    sub_80B04A4(*(_BYTE *)(a2 + 6), *(_DWORD *)(a2 + 20), *(_DWORD *)(a2 + 24));
    s1 = *(char **)(a2 + 16);
  }
  sub_80B072A(a2, s1, a4);
}

//----- (080B269C) --------------------------------------------------------
void __usercall sub_80B269C(long double a1@<st0>, int a2, char *src)
{
  sub_80B25BA(a1, a2, src, 0);
}

//----- (080B26BE) --------------------------------------------------------
void __usercall sub_80B26BE(long double a1@<st0>, char *src, int a3)
{
  int v3; // [esp+10h] [ebp-8h]

  v3 = Dvar_FindVar(src);
  if ( v3 )
  {
    Dvar_SetBool(v3, a3);
  }
  else if ( (_BYTE)a3 )
  {
    Dvar_RegisterString(a1, src, (int)&unk_8147CE1, 0x4000);
  }
  else
  {
    Dvar_RegisterString(a1, src, (int)&unk_8147CE3, 0x4000);
  }
}

//----- (080B2726) --------------------------------------------------------
void __usercall Dvar_SetIntByName(long double a1@<st0>, char *src, int a3)
{
  char s; // [esp+10h] [ebp-38h]
  int v4; // [esp+3Ch] [ebp-Ch]

  v4 = Dvar_FindVar(src);
  if ( v4 )
  {
    Dvar_SetInt(v4, (char *)a3);
  }
  else
  {
    Com_sprintf(&s, 0x20u, "%i", a3);
    Dvar_RegisterString(a1, src, (int)&s, 0x4000);
  }
}

//----- (080B2792) --------------------------------------------------------
void __cdecl sub_80B2792(char *src, int a2)
{
  char *v2; // eax
  int v3; // [esp+14h] [ebp-4h]

  v3 = Dvar_FindVar(src);
  if ( v3 )
  {
    sub_80B24AC(v3, (char *)a2);
  }
  else
  {
    v2 = va("%g", (_QWORD)a2);
    Dvar_RegisterString(*(float *)&a2, src, (int)v2, 0x4000);
  }
}

//----- (080B27EC) --------------------------------------------------------
void __cdecl sub_80B27EC(char *src, int a2, int a3)
{
  char *v3; // eax
  int v4; // [esp+14h] [ebp-4h]

  v4 = Dvar_FindVar(src);
  if ( v4 )
  {
    sub_80B24CE(v4, a2, a3);
  }
  else
  {
    v3 = va("%g %g", (_QWORD)a2, (_QWORD)a3);
    Dvar_RegisterString(*(float *)&a2, src, (int)v3, 0x4000);
  }
}

//----- (080B2854) --------------------------------------------------------
void __cdecl sub_80B2854(char *src, int a2, int a3, int a4)
{
  char *v4; // eax
  int v5; // [esp+24h] [ebp-4h]

  v5 = Dvar_FindVar(src);
  if ( v5 )
  {
    sub_80B24F8(v5, a2, a3, a4);
  }
  else
  {
    v4 = va("%g %g %g", (_QWORD)a2, (_QWORD)a3, (_QWORD)a4);
    Dvar_RegisterString(*(float *)&a2, src, (int)v4, 0x4000);
  }
}

//----- (080B28CA) --------------------------------------------------------
void __cdecl sub_80B28CA(char *src, int a2, int a3, int a4, int a5)
{
  char *v5; // eax
  int v6; // [esp+24h] [ebp-4h]

  v6 = Dvar_FindVar(src);
  if ( v6 )
  {
    sub_80B2528(v6, a2, a3, a4, a5);
  }
  else
  {
    v5 = va("%g %g %g %g", (_QWORD)a2, (_QWORD)a3, (_QWORD)a4, (_QWORD)a5);
    Dvar_RegisterString(*(float *)&a2, src, (int)v5, 0x4000);
  }
}

//----- (080B294E) --------------------------------------------------------
void __usercall sub_80B294E(long double a1@<st0>, char *src, char *a3)
{
  int v3; // [esp+14h] [ebp-4h]

  v3 = Dvar_FindVar(src);
  if ( v3 )
    Dvar_SetString(v3, a3);
  else
    Dvar_RegisterString(a1, src, (int)a3, 0x4000);
}

//----- (080B2998) --------------------------------------------------------
void __usercall sub_80B2998(long double a1@<st0>, char *src, int a3, int a4, int a5, int a6)
{
  float v6; // ST14_4
  float v7; // ST10_4
  float v8; // ST0C_4
  long double v9; // fst7
  float v10; // ST08_4
  char *v11; // eax
  int v12; // [esp+1Ch] [ebp-Ch]

  v12 = Dvar_FindVar(src);
  if ( v12 )
  {
    v6 = (long double)(unsigned __int8)a6;
    v7 = (long double)(unsigned __int8)a5;
    v8 = (long double)(unsigned __int8)a4;
    v9 = (long double)(unsigned __int8)a3;
    v10 = v9;
    sub_80B2582(v9, v12, v10, v8, v7, v6);
  }
  else
  {
    v11 = va("%g %g %g %g", (unsigned __int8)a3, (unsigned __int8)a4, (unsigned __int8)a5, (unsigned __int8)a6);
    Dvar_RegisterString(a1, src, (int)v11, 0x4000);
  }
}

//----- (080B2A6A) --------------------------------------------------------
char *__usercall sub_80B2A6A@<eax>(long double a1@<st0>, char *src, char *a3, int a4)
{
  int v5; // [esp+14h] [ebp-4h]

  v5 = Dvar_FindVar(src);
  if ( !v5 )
    return Dvar_RegisterString(a1, src, (int)a3, 0x4000);
  sub_80B25BA(a1, v5, a3, a4);
  return (char *)v5;
}

//----- (080B2AC2) --------------------------------------------------------
char *__usercall sub_80B2AC2@<eax>(long double a1@<st0>, char *src, char *a3)
{
  return sub_80B2A6A(a1, src, a3, 0);
}

//----- (080B2AE4) --------------------------------------------------------
char *__usercall Dvar_SetCommand@<eax>(long double a1@<st0>, char *src, char *a3)
{
  char *result; // eax
  char *v4; // [esp+14h] [ebp-4h]

  result = sub_80B2A6A(a1, src, a3, 1);
  v4 = result;
  if ( result )
  {
    if ( isLoadingAutoExecGlobalFlag )
    {
      sub_80B2B42((int)result, 0x8000);
      result = sub_80B1164((int)v4, *((char **)v4 + 2));
    }
  }
  return result;
}
// 8523115: using guessed type char isLoadingAutoExecGlobalFlag;

//----- (080B2B42) --------------------------------------------------------
int __cdecl sub_80B2B42(int a1, int a2)
{
  int v2; // edx
  int result; // eax

  v2 = *(unsigned __int16 *)(a1 + 4);
  result = v2 | a2;
  *(_WORD *)(a1 + 4) = v2 | a2;
  return result;
}

//----- (080B2B5A) --------------------------------------------------------
void __cdecl sub_80B2B5A(int a1, int a2)
{
  sub_80B072A(a1, *(char **)(a1 + 16), a2);
}

//----- (080B2B80) --------------------------------------------------------
int sub_80B2B80()
{
  int result; // eax
  int i; // [esp+14h] [ebp-4h]

  result = sortedDvars;
  for ( i = sortedDvars; i; i = *(_DWORD *)(i + 28) )
  {
    if ( *(_BYTE *)(i + 4) < 0 )
      sub_80B072A(i, *(char **)(i + 16), 0);
    result = *(_DWORD *)(i + 28);
  }
  return result;
}
// 85178A0: using guessed type int sortedDvars;

//----- (080B2BD0) --------------------------------------------------------
void __usercall Dvar_Init(long double a1@<st0>)
{
  isDvarSystemActive = 1;
  dword_85178A4 = (int)Dvar_RegisterBool(a1, "sv_cheats", 0, 4120);
  sub_8063DF4();
}
// 85178A4: using guessed type int dword_85178A4;
// 8523114: using guessed type char isDvarSystemActive;

//----- (080B2C06) --------------------------------------------------------
int sub_80B2C06()
{
  int result; // eax
  _DWORD *i; // [esp+0h] [ebp-4h]

  for ( i = &unk_85178C0; i; i = (_DWORD *)i[7] )
  {
    *((_WORD *)i + 2) &= 0xFBFFu;
    result = i[7];
  }
  return result;
}

//----- (080B2C3C) --------------------------------------------------------
signed int sub_80B2C3C()
{
  int i; // [esp+14h] [ebp-4h]

  for ( i = sortedDvars; i; i = *(_DWORD *)(i + 28) )
  {
    if ( (unsigned __int8)Dvar_HasLatchedValue(i) )
      return 1;
  }
  return 0;
}
// 85178A0: using guessed type int sortedDvars;

//----- (080B2C82) --------------------------------------------------------
size_t __cdecl sub_80B2C82(int a1, unsigned __int16 a2)
{
  size_t v3; // [esp+8h] [ebp-10h]
  size_t v4; // [esp+8h] [ebp-10h]
  unsigned int i; // [esp+Ch] [ebp-Ch]
  char *src; // [esp+10h] [ebp-8h]
  int j; // [esp+14h] [ebp-4h]

  v3 = 0;
  for ( i = 0; i <= 0xFF; ++i )
  {
    for ( j = dword_8522CE0[i]; j; j = *(_DWORD *)(j + 32) )
    {
      if ( a2 & *(_WORD *)(j + 4) )
      {
        if ( a1 )
          strcpy((char *)(a1 + v3), *(const char **)j);
        v4 = v3 + I_strlen(*(char **)j) + 1;
        src = Dvar_DisplayableValue(j);
        if ( a1 )
          strcpy((char *)(a1 + v4), src);
        v3 = v4 + I_strlen(src) + 1;
      }
    }
  }
  return v3;
}

//----- (080B2D56) --------------------------------------------------------
int __usercall sub_80B2D56@<eax>(long double a1@<st0>, int a2, int a3)
{
  int result; // eax
  size_t v4; // eax
  size_t v5; // eax
  char *v6; // [esp+20h] [ebp-18h]
  int v7; // [esp+24h] [ebp-14h]
  char *s1; // [esp+28h] [ebp-10h]
  char *v9; // [esp+2Ch] [ebp-Ch]
  char *s; // [esp+30h] [ebp-8h]
  int v11; // [esp+34h] [ebp-4h]

  v11 = 0;
  while ( 1 )
  {
    result = v11;
    if ( v11 >= a3 )
      break;
    s = (char *)(a2 + v11);
    v4 = I_strlen((char *)(a2 + v11));
    v11 += v4 + 1;
    v9 = (char *)(a2 + v11);
    v5 = I_strlen((char *)(a2 + v11));
    v11 += v5 + 1;
    v7 = Dvar_FindMalleableVar(s);
    if ( v7 )
    {
      sub_80AFA9E(a1, (float *)&v6, *(_BYTE *)(v7 + 6), *(_DWORD *)(v7 + 20), *(_DWORD *)(v7 + 24), v9);
      s1 = v6;
      sub_80B072A(v7, v6, 0);
    }
    else
    {
      Dvar_RegisterString(a1, s, (int)v9, 0x4000);
    }
  }
  return result;
}

//----- (080B2E34) --------------------------------------------------------
int __cdecl sub_80B2E34(unsigned __int16 a1, int a2)
{
  int result; // eax
  int i; // [esp+14h] [ebp-4h]

  result = sortedDvars;
  for ( i = sortedDvars; i; i = *(_DWORD *)(i + 28) )
  {
    if ( a1 & *(_WORD *)(i + 4) )
      sub_80B2B5A(i, a2);
    result = *(_DWORD *)(i + 28);
  }
  return result;
}
// 85178A0: using guessed type int sortedDvars;

//----- (080B2E78) --------------------------------------------------------
int __cdecl sub_80B2E78(int a1, int a2, char *s, size_t maxlen)
{
  _DWORD *v4; // ST1C_4
  char *v5; // ST18_4
  int v8; // [esp+20h] [ebp-8h]
  int i; // [esp+24h] [ebp-4h]

  for ( i = 0; i < a2; ++i )
  {
    v4 = (_DWORD *)Dvar_FindVar(*(char **)(a1 + 4 * i));
    v5 = Dvar_DisplayableValue((int)v4);
    v8 = snprintf(s, maxlen, "%s \"%s\"\n", *v4, v5);
    if ( v8 < 0 )
      return 0;
    s += v8;
    maxlen -= v8;
  }
  return 1;
}

//----- (080B2F1A) --------------------------------------------------------
int __usercall sub_80B2F1A@<eax>(long double a1@<st0>, int a2, size_t n, char *a4, char src)
{
  char s[16384]; // [esp+20h] [ebp-4018h]
  int v8; // [esp+4020h] [ebp-18h]
  int v9; // [esp+4024h] [ebp-14h]
  char *s1; // [esp+4028h] [ebp-10h]
  int i; // [esp+402Ch] [ebp-Ch]

  memset(s, 0, n);
  v8 = 0;
  for ( i = 0; i < (signed int)n; ++i )
  {
    v9 = Dvar_FindVar(*(char **)(a2 + 4 * i));
    sub_80B2B5A(v9, 0);
  }
  sub_80B396A((char *)src);
  while ( 1 )
  {
    s1 = Com_Parse(&a4);
    if ( !*s1 )
      break;
    for ( i = 0; ; ++i )
    {
      if ( i >= (signed int)n )
      {
        Com_Printf("^3WARNING: unknown dvar '%s' in file '%s'\n", s1, src);
        goto LABEL_13;
      }
      if ( !strcasecmp(s1, *(const char **)(a2 + 4 * i)) )
        break;
    }
    v9 = Dvar_FindVar(*(char **)(a2 + 4 * i));
    s1 = sub_80B4848(&a4);
    sub_80B269C(a1, v9, s1);
    if ( !s[i] )
    {
      s[i] = 1;
      ++v8;
    }
LABEL_13:
    sub_80B49B8(&a4);
  }
  sub_80B3A3C();
  if ( v8 == n )
    return 1;
  Com_Printf("^1ERROR: the following dvars were not specified in file '%s'\n", src);
  for ( i = 0; i < (signed int)n; ++i )
  {
    if ( !s[i] )
      Com_Printf("^1  %s\n", *(_DWORD *)(a2 + 4 * i));
  }
  return 0;
}
// 80B2F1A: using guessed type char s[16384];

//----- (080B30FE) --------------------------------------------------------
void __cdecl sub_80B30FE(float a1, float a2)
{
  float v2; // ST00_4

  v2 = a1 - a2;
  sub_80B34F0(v2, a1, a2);
}

//----- (080B3122) --------------------------------------------------------
void __cdecl sub_80B3122(float a1, float a2)
{
  float v2; // ST00_4

  v2 = a2 - a1;
  sub_80B34F0(v2, a1, a2);
}

//----- (080B3146) --------------------------------------------------------
int __cdecl sub_80B3146(float a1)
{
  return (signed int)floor(a1 + 0.5);
}

//----- (080B317C) --------------------------------------------------------
int __cdecl sub_80B317C(_DWORD *a1)
{
  int result; // eax

  *a1 = 0;
  result = 0;
  a1[1] = 0;
  return result;
}

//----- (080B3198) --------------------------------------------------------
int __cdecl sub_80B3198(_DWORD *a1, int a2, int a3)
{
  int result; // eax

  *a1 = a2;
  result = a3;
  a1[1] = a3;
  return result;
}

//----- (080B31B0) --------------------------------------------------------
int __cdecl sub_80B31B0(_DWORD *a1, _DWORD *a2)
{
  int result; // eax

  *a2 = *a1;
  result = a1[1];
  a2[1] = result;
  return result;
}

//----- (080B31D0) --------------------------------------------------------
signed int __cdecl sub_80B31D0(float *a1, float *a2)
{
  signed int v3; // [esp+0h] [ebp-4h]

  v3 = 0;
  if ( *a1 == *a2 && a1[1] == a2[1] )
    v3 = 1;
  return v3;
}

//----- (080B321E) --------------------------------------------------------
int __cdecl sub_80B321E(_DWORD *a1)
{
  int result; // eax

  *a1 = 0;
  a1[1] = 0;
  result = 0;
  a1[2] = 0;
  return result;
}

//----- (080B3248) --------------------------------------------------------
int __cdecl sub_80B3248(_DWORD *a1, int a2, int a3, int a4)
{
  int result; // eax

  *a1 = a2;
  a1[1] = a3;
  result = a4;
  a1[2] = a4;
  return result;
}

//----- (080B326C) --------------------------------------------------------
int __cdecl sub_80B326C(_DWORD *a1, _DWORD *a2)
{
  int result; // eax

  *a2 = *a1;
  a2[1] = a1[1];
  result = a1[2];
  a2[2] = result;
  return result;
}

//----- (080B329C) --------------------------------------------------------
signed int __cdecl sub_80B329C(float *a1, float *a2)
{
  signed int v3; // [esp+0h] [ebp-4h]

  v3 = 0;
  if ( *a1 == *a2 && a1[1] == a2[1] && a1[2] == a2[2] )
    v3 = 1;
  return v3;
}

//----- (080B3306) --------------------------------------------------------
int __cdecl sub_80B3306(_DWORD *a1)
{
  int result; // eax

  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  result = 0;
  a1[3] = 0;
  return result;
}

//----- (080B333C) --------------------------------------------------------
int __cdecl sub_80B333C(_DWORD *a1, int a2, int a3, int a4, int a5)
{
  int result; // eax

  *a1 = a2;
  a1[1] = a3;
  a1[2] = a4;
  result = a5;
  a1[3] = a5;
  return result;
}

//----- (080B336A) --------------------------------------------------------
int __cdecl sub_80B336A(_DWORD *a1, _DWORD *a2)
{
  int result; // eax

  *a2 = *a1;
  a2[1] = a1[1];
  a2[2] = a1[2];
  result = a1[3];
  a2[3] = result;
  return result;
}

//----- (080B33AA) --------------------------------------------------------
signed int __cdecl sub_80B33AA(float *a1, float *a2)
{
  signed int v3; // [esp+0h] [ebp-4h]

  v3 = 0;
  if ( *a1 == *a2 && a1[1] == a2[1] && a1[2] == a2[2] && a1[3] == a2[3] )
    v3 = 1;
  return v3;
}

//----- (080B3432) --------------------------------------------------------
_DWORD *__cdecl sub_80B3432(_DWORD *a1, _DWORD *a2)
{
  _DWORD *result; // eax

  result = a2;
  *a2 = *a1;
  return result;
}

//----- (080B3442) --------------------------------------------------------
_BOOL4 __cdecl sub_80B3442(_DWORD *a1, _DWORD *a2)
{
  return *a1 == *a2;
}

//----- (080B3458) --------------------------------------------------------
signed int __cdecl sub_80B3458(_BYTE *a1, _BYTE *a2, int a3)
{
  signed int v4; // [esp+Ch] [ebp-Ch]
  char v6; // [esp+16h] [ebp-2h]
  char v7; // [esp+17h] [ebp-1h]

  while ( a3 && *a1 )
  {
    v7 = tolower((char)*a1);
    v6 = tolower((char)*a2);
    --a3;
    ++a1;
    ++a2;
    if ( v7 < v6 )
      return -1;
    if ( v7 > v6 )
      return 1;
  }
  if ( a3 && *a1 != *a2 )
    v4 = -1;
  else
    v4 = 0;
  return v4;
}

//----- (080B34F0) --------------------------------------------------------
long double __cdecl sub_80B34F0(float a1, float a2, float a3)
{
  float v4; // [esp+0h] [ebp-4h]

  if ( a1 < 0.0 )
    v4 = a3;
  else
    v4 = a2;
  return v4;
}

//----- (080B351C) --------------------------------------------------------
int __cdecl sub_80B351C(int a1, size_t n, void *src)
{
  return sub_80B3636(a1, n, src);
}

//----- (080B353E) --------------------------------------------------------
int __cdecl sub_80B353E(int a1, int a2, int a3, char a4)
{
  int result; // eax

  *(_DWORD *)a1 = a3;
  *(_DWORD *)(a1 + 4) = a2;
  *(_DWORD *)(a1 + 8) = 0;
  *(_BYTE *)(a1 + 12) = a4;
  result = a1;
  *(_BYTE *)(a1 + 13) = 0;
  return result;
}

//----- (080B35E6) --------------------------------------------------------
void *__cdecl sub_80B35E6(void *s)
{
  return memset(s, 0, 4u);
}

//----- (080B3636) --------------------------------------------------------
int __cdecl sub_80B3636(int a1, size_t n, void *src)
{
  int result; // eax

  if ( n )
  {
    result = a1;
    if ( !*(_BYTE *)(a1 + 13) )
    {
      if ( (signed int)(*(_DWORD *)(a1 + 8) + n) <= *(_DWORD *)(a1 + 4) )
      {
        memcpy((void *)(*(_DWORD *)a1 + *(_DWORD *)(a1 + 8)), src, n);
        result = *(_DWORD *)(a1 + 8) + n;
        *(_DWORD *)(a1 + 8) = result;
      }
      else
      {
        if ( *(_BYTE *)(a1 + 12) )
          Com_Error(
            1,
            "Couldn't write %i bytes to %i-byte buffer (only %i bytes free)\n",
            n,
            *(_DWORD *)(a1 + 4),
            *(_DWORD *)(a1 + 4) - *(_DWORD *)(a1 + 8));
        result = a1;
        *(_BYTE *)(a1 + 13) = 1;
      }
    }
  }
  return result;
}

//----- (080B36E4) --------------------------------------------------------
int __cdecl sub_80B36E4(int a1, char *s)
{
  size_t v2; // eax

  v2 = strlen(s);
  return sub_80B3636(a1, v2 + 1, s);
}

//----- (080B3710) --------------------------------------------------------
int __cdecl sub_80B3710(int a1, int a2)
{
  int result; // eax

  if ( a2 )
  {
    result = a1;
    if ( !*(_BYTE *)(a1 + 13) )
    {
      if ( *(_DWORD *)(a1 + 8) + a2 <= *(_DWORD *)(a1 + 4) )
      {
        result = *(_DWORD *)(a1 + 8) + a2;
        *(_DWORD *)(a1 + 8) = result;
      }
      else
      {
        if ( *(_BYTE *)(a1 + 12) )
          Com_Error(
            1,
            "Couldn't skip %i bytes from %i-byte buffer (only %i bytes left)\n",
            a2,
            *(_DWORD *)(a1 + 4),
            *(_DWORD *)(a1 + 4) - *(_DWORD *)(a1 + 8));
        result = a1;
        *(_BYTE *)(a1 + 13) = 1;
      }
    }
  }
  return result;
}

//----- (080B3796) --------------------------------------------------------
int __cdecl sub_80B3796(int a1, size_t n, void *dest)
{
  int result; // eax

  if ( n )
  {
    result = a1;
    if ( !*(_BYTE *)(a1 + 13) )
    {
      if ( (signed int)(*(_DWORD *)(a1 + 8) + n) <= *(_DWORD *)(a1 + 4) )
      {
        memcpy(dest, (const void *)(*(_DWORD *)a1 + *(_DWORD *)(a1 + 8)), n);
        result = *(_DWORD *)(a1 + 8) + n;
        *(_DWORD *)(a1 + 8) = result;
      }
      else
      {
        if ( *(_BYTE *)(a1 + 12) )
          Com_Error(
            1,
            "Couldn't read %i bytes from %i-byte buffer (only %i bytes left)\n",
            n,
            *(_DWORD *)(a1 + 4),
            *(_DWORD *)(a1 + 4) - *(_DWORD *)(a1 + 8));
        result = a1;
        *(_BYTE *)(a1 + 13) = 1;
      }
    }
  }
  return result;
}

//----- (080B3844) --------------------------------------------------------
void *__cdecl sub_80B3844(int a1)
{
  int v3; // [esp+14h] [ebp-4h]

  if ( *(_BYTE *)(a1 + 13) )
    return &unk_81483E1;
  v3 = *(_DWORD *)(a1 + 8);
  do
  {
    if ( !*(_BYTE *)(*(_DWORD *)a1 + *(_DWORD *)(a1 + 8)) )
    {
      ++*(_DWORD *)(a1 + 8);
      return (void *)(*(_DWORD *)a1 + v3);
    }
    ++*(_DWORD *)(a1 + 8);
  }
  while ( *(_DWORD *)(a1 + 8) != *(_DWORD *)(a1 + 4) );
  if ( *(_BYTE *)(a1 + 12) )
    Com_Error(1, "End of memory file while reading string (%i bytes read)\n", *(_DWORD *)(a1 + 8) - v3);
  *(_BYTE *)(a1 + 13) = 1;
  return &unk_81483E1;
}

//----- (080B38E8) --------------------------------------------------------
void *sub_80B38E8()
{
  return &unk_815DF80;
}

//----- (080B38F2) --------------------------------------------------------
int __cdecl sub_80B38F2(int a1)
{
  int result; // eax

  *(_DWORD *)(a1 + 1024) = 1;
  *(_BYTE *)(a1 + 1028) = 0;
  *(_BYTE *)(a1 + 1029) = 1;
  *(_BYTE *)(a1 + 1030) = 0;
  *(_BYTE *)(a1 + 1031) = 0;
  *(_BYTE *)(a1 + 1032) = 0;
  *(_DWORD *)(a1 + 1036) = &unk_814846A;
  *(_DWORD *)(a1 + 1040) = &unk_814846A;
  *(_DWORD *)(a1 + 1044) = 0;
  result = a1;
  *(_DWORD *)(a1 + 1048) = 0;
  return result;
}

//----- (080B396A) --------------------------------------------------------
char *__cdecl sub_80B396A(char *src)
{
  int v1; // ST0C_4
  _DWORD *v3; // [esp+10h] [ebp-8h]
  int i; // [esp+14h] [ebp-4h]

  v3 = sub_80B38E8();
  if ( v3[4464] == 15 )
  {
    Com_Printf("Already parsing:\n");
    for ( i = 0; i < v3[4464]; ++i )
      Com_Printf("%i. %s\n", i, &v3[279 * i + 263]);
    Com_Error(0, &byte_81484A0, src);
  }
  v1 = (int)&v3[279 * ++v3[4464]];
  sub_80B38F2(v1);
  return I_strncpyz((char *)(v1 + 1052), src, 64);
}

//----- (080B3A3C) --------------------------------------------------------
_DWORD *sub_80B3A3C()
{
  _DWORD *result; // eax
  _DWORD *v1; // [esp+14h] [ebp-4h]

  v1 = sub_80B38E8();
  if ( !v1[4464] )
    Com_Error(0, &byte_81484E0);
  result = v1;
  --result[4464];
  return result;
}

//----- (080B3A76) --------------------------------------------------------
_DWORD *CM_Cleanup()
{
  _DWORD *result; // eax

  result = sub_80B38E8();
  result[4464] = 0;
  return result;
}

//----- (080B3B00) --------------------------------------------------------
bool __cdecl sub_80B3B00(int a1)
{
  _DWORD *v1; // eax
  int v2; // edx
  bool result; // al

  v1 = sub_80B38E8();
  v2 = (int)&v1[279 * v1[4464]];
  result = a1 != 0;
  *(_BYTE *)(v2 + 1031) = a1 != 0;
  return result;
}

//----- (080B3B6C) --------------------------------------------------------
int sub_80B3B6C()
{
  _DWORD *v0; // eax

  v0 = sub_80B38E8();
  return v0[279 * v0[4464] + 256];
}

//----- (080B3BFE) --------------------------------------------------------
void __noreturn sub_80B3BFE(char *format, ...)
{
  _DWORD *v1; // ST2C_4
  int v2; // [esp+28h] [ebp-1020h]
  char s; // [esp+30h] [ebp-1018h]
  __gnuc_va_list __varargs; // [esp+103Ch] [ebp-Ch]
  va_list va; // [esp+1054h] [ebp+Ch]

  va_start(va, format);
  v1 = sub_80B38E8();
  v2 = (int)&v1[279 * v1[4464]];
  va_copy(__varargs, va);
  vsprintf(&s, format, va);
  if ( v1[4464] )
    Com_Error(1, &byte_8148508, *(_DWORD *)(v2 + 1036), v2 + 1052, *(_DWORD *)(v2 + 1024), &s);
  Com_Error(1, &byte_8148520, &s);
}

//----- (080B3CD0) --------------------------------------------------------
void Com_ScriptWarning(char *format, ...)
{
  _DWORD *v1; // ST2C_4
  int v2; // [esp+28h] [ebp-1020h]
  char s; // [esp+30h] [ebp-1018h]
  __gnuc_va_list __varargs; // [esp+103Ch] [ebp-Ch]
  va_list va; // [esp+1054h] [ebp+Ch]

  va_start(va, format);
  v1 = sub_80B38E8();
  v2 = (int)&v1[279 * v1[4464]];
  va_copy(__varargs, va);
  vsprintf(&s, format, va);
  if ( v1[4464] )
    Com_Printf("%sFile %s, line %i: %s", *(_DWORD *)(v2 + 1040), v2 + 1052, *(_DWORD *)(v2 + 1024), &s);
  else
    Com_Printf("%s", &s);
}

//----- (080B3D92) --------------------------------------------------------
int sub_80B3D92()
{
  int result; // eax
  int v1; // [esp+10h] [ebp-8h]
  _DWORD *v2; // [esp+14h] [ebp-4h]

  v2 = sub_80B38E8();
  v1 = (int)&v2[279 * v2[4464]];
  if ( *(_BYTE *)(v1 + 1028) )
    sub_80B3BFE("UngetToken called twice");
  *(_BYTE *)(v1 + 1028) = 1;
  result = v2[4466];
  v2[4465] = result;
  return result;
}

//----- (080B3DEC) --------------------------------------------------------
int __cdecl sub_80B3DEC(_DWORD *a1, _DWORD *a2)
{
  _DWORD *v2; // eax
  _DWORD *v3; // ST04_4
  int v4; // eax
  int result; // eax

  v2 = sub_80B38E8();
  v3 = v2;
  v4 = 279 * v2[4464];
  *a2 = v3[v4 + 256];
  a2[1] = *a1;
  a2[2] = LOBYTE(v3[v4 + 257]);
  a2[3] = v3[v4 + 261];
  result = v3[v4 + 262];
  a2[4] = result;
  return result;
}

//----- (080B3E58) --------------------------------------------------------
int __cdecl sub_80B3E58(_DWORD *a1, _DWORD *a2)
{
  _DWORD *v2; // eax
  int v3; // ST00_4
  int result; // eax

  v2 = sub_80B38E8();
  v3 = (int)&v2[279 * v2[4464]];
  *(_DWORD *)(v3 + 1024) = *a2;
  *a1 = a2[1];
  *(_BYTE *)(v3 + 1028) = a2[2] != 0;
  *(_DWORD *)(v3 + 1044) = a2[3];
  result = a2[4];
  *(_DWORD *)(v3 + 1048) = result;
  return result;
}

//----- (080B3EC8) --------------------------------------------------------
_BYTE *__cdecl sub_80B3EC8(_BYTE *a1, _DWORD *a2)
{
  _DWORD *v2; // eax
  int v5; // [esp+Ch] [ebp-Ch]
  signed int v6; // [esp+14h] [ebp-4h]

  v2 = sub_80B38E8();
  v5 = (int)&v2[279 * v2[4464]];
  while ( 1 )
  {
    v6 = (char)*a1;
    if ( v6 > 32 )
      break;
    if ( !*a1 )
      return 0;
    if ( v6 == 10 )
    {
      ++*(_DWORD *)(v5 + 1024);
      *a2 = 1;
    }
    ++a1;
  }
  return a1;
}

//----- (080B3F36) --------------------------------------------------------
int __cdecl sub_80B3F36(_BYTE *a1)
{
  int v2; // [esp+4h] [ebp-10h]
  char v3; // [esp+Bh] [ebp-9h]
  _BYTE *v4; // [esp+Ch] [ebp-8h]
  char *v5; // [esp+10h] [ebp-4h]

  v2 = 0;
  v4 = a1;
  v5 = a1;
  if ( a1 )
  {
    while ( 1 )
    {
      v3 = *v5;
      if ( !*v5 )
        break;
      if ( v3 != 13 && v3 != 10 )
      {
        if ( v3 != 47 || v5[1] != 47 )
        {
          if ( v3 != 47 || v5[1] != 42 )
          {
            *v4++ = v3;
            ++v2;
            ++v5;
          }
          else
          {
            while ( *v5 && (*v5 != 42 || v5[1] != 47) )
            {
              if ( *v5 == 10 )
              {
                *v4++ = 10;
                ++v2;
              }
              ++v5;
            }
            if ( *v5 )
              v5 += 2;
          }
        }
        else
        {
          while ( *v5 && *v5 != 10 )
            ++v5;
        }
      }
      else
      {
        *v4++ = v3;
        ++v2;
        ++v5;
      }
    }
  }
  *v4 = 0;
  return v2;
}

//----- (080B4072) --------------------------------------------------------
int sub_80B4072()
{
  return *((_DWORD *)sub_80B38E8() + 4465);
}

//----- (080B408C) --------------------------------------------------------
_BYTE *__cdecl sub_80B408C(_BYTE **a1, int a2)
{
  _BYTE *v4; // [esp+8h] [ebp-10h]
  _DWORD *v5; // [esp+Ch] [ebp-Ch]
  _BYTE *v6; // [esp+10h] [ebp-8h]
  _BYTE *i; // [esp+10h] [ebp-8h]
  unsigned int v8; // [esp+14h] [ebp-4h]

  v5 = sub_80B38E8();
  v4 = &v5[279 * v5[4464]];
  v6 = *a1;
  v8 = 0;
  *v4 = 0;
  if ( a2 )
  {
    while ( *v6 == 13 || *v6 == 10 )
      ++v6;
  }
  else if ( *v6 == 13 || *v6 == 10 )
  {
    return v4;
  }
  v5[4466] = v5[4465];
  v5[4465] = v6;
  while ( *v6 && *v6 != 44 && *v6 != 10 )
  {
    if ( *v6 == 13 )
    {
      ++v6;
    }
    else if ( *v6 == 34 )
    {
      for ( i = v6 + 1; ; i += 2 )
      {
        while ( *i != 34 )
        {
          if ( v8 <= 0x3FE )
            v4[v8++] = *i;
          ++i;
        }
        if ( i[1] != 34 )
          break;
        if ( v8 <= 0x3FE )
          v4[v8++] = 34;
      }
      v6 = i + 1;
    }
    else
    {
      if ( v8 <= 0x3FE )
        v4[v8++] = *v6;
      ++v6;
    }
  }
  if ( *v6 )
  {
    if ( *v6 != 10 )
      ++v6;
    *a1 = v6;
  }
  else
  {
    *a1 = 0;
  }
  v4[v8] = 0;
  return v4;
}

//----- (080B4220) --------------------------------------------------------
char *__cdecl sub_80B4220(char **a1, int a2)
{
  char *v2; // edx
  char *v3; // edx
  char *v5; // [esp+10h] [ebp-28h]
  signed int j; // [esp+14h] [ebp-24h]
  signed int n; // [esp+18h] [ebp-20h]
  char *dest; // [esp+1Ch] [ebp-1Ch]
  _DWORD *v9; // [esp+20h] [ebp-18h]
  char **i; // [esp+24h] [ebp-14h]
  char *v11; // [esp+28h] [ebp-10h]
  char *v12; // [esp+28h] [ebp-10h]
  int v13; // [esp+2Ch] [ebp-Ch]
  int v14; // [esp+30h] [ebp-8h]
  char v15; // [esp+37h] [ebp-1h]

  v15 = 0;
  v13 = 0;
  v9 = sub_80B38E8();
  dest = (char *)&v9[279 * v9[4464]];
  v11 = *a1;
  v14 = 0;
  *dest = 0;
  if ( !v11 )
  {
    *a1 = 0;
    return dest;
  }
  *((_DWORD *)dest + 261) = *((_DWORD *)dest + 256);
  *((_DWORD *)dest + 262) = *a1;
  if ( dest[1031] )
    return sub_80B408C(a1, a2);
  while ( 1 )
  {
    while ( 1 )
    {
      v11 = sub_80B3EC8(v11, &v13);
      if ( !v11 )
      {
        *a1 = 0;
        return dest;
      }
      if ( v13 && !a2 )
        return dest;
      v15 = *v11;
      if ( v15 != 47 || v11[1] != 47 )
        break;
      while ( *v11 && *v11 != 10 )
        ++v11;
    }
    if ( v15 != 47 || v11[1] != 42 )
      break;
    while ( *v11 && (*v11 != 42 || v11[1] != 47) )
    {
      if ( *v11 == 10 )
        ++*((_DWORD *)dest + 256);
      ++v11;
    }
    if ( *v11 )
      v11 += 2;
  }
  v9[4466] = v9[4465];
  v9[4465] = v11;
  if ( v15 == 34 )
  {
    if ( dest[1030] )
      dest[v14++] = 34;
    v12 = v11 + 1;
    while ( 1 )
    {
      v2 = v12++;
      v15 = *v2;
      if ( v15 != 92 || *v12 != 34 && *v12 != 92 )
      {
        if ( v15 == 34 || !v15 )
        {
          if ( dest[1030] )
            dest[v14++] = 34;
          dest[v14] = 0;
          *a1 = v12;
          return dest;
        }
        if ( *v12 == 10 )
          ++*((_DWORD *)dest + 256);
      }
      else
      {
        v3 = v12++;
        v15 = *v3;
      }
      if ( v14 <= 1022 )
        dest[v14++] = v15;
    }
  }
  if ( dest[1029] )
  {
    do
    {
      if ( v14 <= 1022 )
        dest[v14++] = v15;
      v15 = *++v11;
    }
    while ( v15 > 32 );
    if ( v14 == 1024 )
      v14 = 0;
    dest[v14] = 0;
    *a1 = v11;
    v5 = dest;
  }
  else if ( v15 > 47 && v15 <= 57
         || dest[1032] && v15 == 45 && v11[1] > 47 && v11[1] <= 57
         || v15 == 46 && v11[1] > 47 && v11[1] <= 57 )
  {
    do
    {
      if ( v14 <= 1022 )
        dest[v14++] = v15;
      v15 = *++v11;
    }
    while ( v15 > 47 && v15 <= 57 || v15 == 46 );
    if ( v15 == 101 || v15 == 69 )
    {
      if ( v14 <= 1022 )
        dest[v14++] = v15;
      v15 = *++v11;
      if ( v15 == 45 || v15 == 43 )
      {
        if ( v14 <= 1022 )
          dest[v14++] = v15;
        v15 = *++v11;
      }
      do
      {
        if ( v14 <= 1022 )
          dest[v14++] = v15;
        v15 = *++v11;
      }
      while ( v15 > 47 && v15 <= 57 );
    }
    if ( v14 == 1024 )
      v14 = 0;
    dest[v14] = 0;
    *a1 = v11;
    v5 = dest;
  }
  else if ( (v15 <= 96 || v15 > 122) && (v15 <= 64 || v15 > 90) && v15 != 95 && v15 != 47 && v15 != 92 )
  {
    for ( i = off_815DF40; ; ++i )
    {
      if ( !*i )
      {
        *dest = *v11;
        dest[1] = 0;
        *a1 = v11 + 1;
        return dest;
      }
      n = I_strlen(*i);
      for ( j = 0; j < n && v11[j] == (*i)[j]; ++j )
        ;
      if ( j == n )
        break;
    }
    memcpy(dest, *i, n);
    dest[n] = 0;
    *a1 = &v11[n];
    v5 = dest;
  }
  else
  {
    do
    {
      if ( v14 <= 1022 )
        dest[v14++] = v15;
      v15 = *++v11;
    }
    while ( v15 > 96 && v15 <= 122 || v15 > 64 && v15 <= 90 || v15 == 95 || v15 > 47 && v15 <= 57 );
    if ( v14 == 1024 )
      v14 = 0;
    dest[v14] = 0;
    *a1 = v11;
    v5 = dest;
  }
  return v5;
}
// 815DF40: using guessed type char *off_815DF40[14];

//----- (080B47DA) --------------------------------------------------------
char *__cdecl Com_Parse(char **a1)
{
  _DWORD *v1; // ST14_4
  int v3; // [esp+10h] [ebp-8h]

  v1 = sub_80B38E8();
  v3 = (int)&v1[279 * v1[4464]];
  if ( *(_BYTE *)(v3 + 1028) )
  {
    *(_BYTE *)(v3 + 1028) = 0;
    *a1 = *(char **)(v3 + 1048);
    *(_DWORD *)(v3 + 1024) = *(_DWORD *)(v3 + 1044);
  }
  return sub_80B4220(a1, 1);
}

//----- (080B4848) --------------------------------------------------------
char *__cdecl sub_80B4848(char **a1)
{
  _DWORD *v1; // ST14_4
  int v4; // [esp+10h] [ebp-8h]

  v1 = sub_80B38E8();
  v4 = (int)&v1[279 * v1[4464]];
  if ( !*(_BYTE *)(v4 + 1028) )
    return sub_80B4220(a1, 0);
  *(_BYTE *)(v4 + 1028) = 0;
  if ( *(_BYTE *)(v4 + 1029) )
  {
    *a1 = *(char **)(v4 + 1048);
    *(_DWORD *)(v4 + 1024) = *(_DWORD *)(v4 + 1044);
    return sub_80B4220(a1, 0);
  }
  return (char *)v4;
}

//----- (080B48D0) --------------------------------------------------------
int __cdecl sub_80B48D0(int a1, char *s2, int a3)
{
  const char *s1; // [esp+14h] [ebp-4h]

  s1 = Com_Parse((char **)a1);
  if ( !strcmp(s1, s2) )
    return 1;
  if ( !a3 )
    sub_80B3BFE("MatchToken: %s != %s\n", s1, s2);
  Com_ScriptWarning("MatchToken: %s != %s\n", s1, s2);
  return 0;
}

//----- (080B494C) --------------------------------------------------------
signed int __cdecl sub_80B494C(char **a1, int a2)
{
  signed int v3; // [esp+Ch] [ebp-Ch]
  int v4; // [esp+10h] [ebp-8h]
  char *v5; // [esp+14h] [ebp-4h]

  v3 = 0;
  v4 = 0;
  do
  {
    v5 = Com_Parse(a1);
    if ( !v5[1] )
    {
      if ( *v5 == 123 )
      {
        if ( v4 == a2 )
          v3 = 1;
        else
          ++v4;
      }
      else if ( *v5 == 125 )
      {
        --v4;
      }
    }
  }
  while ( v4 && *a1 );
  return v3;
}

//----- (080B49B8) --------------------------------------------------------
_BYTE *__cdecl sub_80B49B8(_DWORD *a1)
{
  _DWORD *v1; // eax
  _BYTE *result; // eax
  int v3; // [esp+8h] [ebp-10h]
  int v4; // [esp+10h] [ebp-8h]
  _BYTE *v5; // [esp+14h] [ebp-4h]

  v1 = sub_80B38E8();
  v3 = (int)&v1[279 * v1[4464]];
  result = (_BYTE *)*a1;
  v5 = (_BYTE *)*a1;
  if ( *a1 )
  {
    while ( 1 )
    {
      v4 = (char)*v5;
      if ( !*v5 )
        break;
      ++v5;
      if ( v4 == 10 )
      {
        ++*(_DWORD *)(v3 + 1024);
        break;
      }
    }
    result = v5;
    *a1 = v5;
  }
  return result;
}

//----- (080B4A1C) --------------------------------------------------------
int __cdecl sub_80B4A1C(char **a1)
{
  char v2; // [esp+10h] [ebp-38h]
  int i; // [esp+38h] [ebp-10h]
  char *v4; // [esp+3Ch] [ebp-Ch]

  sub_80B3DEC(a1, &v2);
  for ( i = 0; ; ++i )
  {
    v4 = sub_80B4848(a1);
    if ( !*v4 )
      break;
  }
  sub_80B3E58(a1, &v2);
  return i;
}

//----- (080B4A72) --------------------------------------------------------
char *__cdecl sub_80B4A72(char **a1)
{
  char *s; // [esp+Ch] [ebp-Ch]
  char *src; // [esp+14h] [ebp-4h]

  s = (char *)sub_80B38E8() + 17868;
  *s = 0;
  while ( 1 )
  {
    src = sub_80B4848(a1);
    if ( !*src )
      break;
    if ( *s )
      sub_80B57C0(s, 1024, L" ()");
    sub_80B57C0(s, 1024, src);
  }
  return s;
}

//----- (080B4AEE) --------------------------------------------------------
long double __cdecl sub_80B4AEE(char **a1)
{
  const char *nptr; // ST14_4

  nptr = Com_Parse(a1);
  return (float)atof(nptr);
}

//----- (080B4B1C) --------------------------------------------------------
long double __cdecl sub_80B4B1C(char **a1)
{
  const char *nptr; // ST14_4

  nptr = sub_80B4848(a1);
  return (float)atof(nptr);
}

//----- (080B4B4A) --------------------------------------------------------
int __cdecl sub_80B4B4A(char **a1)
{
  const char *nptr; // ST04_4

  nptr = Com_Parse(a1);
  return atoi(nptr);
}

//----- (080B4B6C) --------------------------------------------------------
int __cdecl sub_80B4B6C(char **a1)
{
  const char *nptr; // ST04_4

  nptr = sub_80B4848(a1);
  return atoi(nptr);
}

//----- (080B4B8E) --------------------------------------------------------
int __cdecl sub_80B4B8E(char **a1, int a2, int a3)
{
  const char *nptr; // ST1C_4
  int i; // [esp+18h] [ebp-10h]

  sub_80B48D0((int)a1, L"()", 0);
  for ( i = 0; i < a2; ++i )
  {
    nptr = Com_Parse(a1);
    *(float *)(a3 + 4 * i) = atof(nptr);
  }
  return sub_80B48D0((int)a1, L")", 0);
}

//----- (080B4C14) --------------------------------------------------------
int __cdecl sub_80B4C14(char **a1, int a2, int a3, int a4)
{
  int i; // [esp+14h] [ebp-4h]

  sub_80B48D0((int)a1, L"()", 0);
  for ( i = 0; i < a2; ++i )
    sub_80B4B8E(a1, a3, a4 + 4 * a3 * i);
  return sub_80B48D0((int)a1, L")", 0);
}

//----- (080B4C8E) --------------------------------------------------------
int __cdecl sub_80B4C8E(char **a1, int a2, int a3, int a4, int a5)
{
  int i; // [esp+14h] [ebp-4h]

  sub_80B48D0((int)a1, L"()", 0);
  for ( i = 0; i < a2; ++i )
    sub_80B4C14(a1, a3, a4, a5 + 4 * a3 * a4 * i);
  return sub_80B48D0((int)a1, L")", 0);
}

//----- (080B4D14) --------------------------------------------------------
signed int __cdecl sub_80B4D14(char a1)
{
  signed int v2; // [esp+0h] [ebp-8h]

  if ( (unsigned __int8)(a1 - 48) > 9u )
    v2 = 7;
  else
    v2 = (unsigned __int8)(a1 - 48);
  return v2;
}

//----- (080B4D44) --------------------------------------------------------
int __cdecl sub_80B4D44(_BYTE *a1)
{
  int v2; // [esp+0h] [ebp-4h]

  v2 = (int)a1;
  while ( *a1 )
  {
    if ( *a1 == 47 )
      v2 = (int)(a1 + 1);
    ++a1;
  }
  return v2;
}

//----- (080B4D74) --------------------------------------------------------
void *__cdecl sub_80B4D74(void *src, char *s, char *a3, void *dest, int a5)
{
  size_t v6; // [esp+1Ch] [ebp-Ch]
  size_t v7; // [esp+20h] [ebp-8h]
  size_t n; // [esp+24h] [ebp-4h]
  char *desta; // [esp+3Ch] [ebp+14h]

  n = I_strlen((char *)src);
  v7 = I_strlen(s);
  v6 = I_strlen(a3);
  if ( (signed int)(v6 + n + v7) >= a5 )
    Com_Error(1, "filepath '%s%s%s' is longer than %i characters", src, s, a3, a5 - 1);
  memcpy(dest, src, n);
  desta = (char *)dest + n;
  memcpy(desta, s, v7);
  return memcpy(&desta[v7], a3, v6 + 1);
}

//----- (080B4E42) --------------------------------------------------------
_BYTE *__cdecl sub_80B4E42(_BYTE *a1)
{
  _BYTE *v2; // [esp+0h] [ebp-4h]

  v2 = 0;
  while ( *a1 )
  {
    if ( *a1 == 46 )
    {
      v2 = a1;
    }
    else if ( *a1 == 47 || *a1 == 92 )
    {
      v2 = 0;
    }
    ++a1;
  }
  if ( !v2 )
    v2 = a1;
  return v2;
}

//----- (080B4E98) --------------------------------------------------------
_BYTE *__cdecl sub_80B4E98(_BYTE *a1, _BYTE *a2)
{
  _BYTE *v2; // eax
  _BYTE *result; // eax
  _BYTE *v4; // [esp+4h] [ebp-4h]

  v4 = sub_80B4E42(a1);
  while ( a1 != v4 )
  {
    v2 = a1++;
    *a2++ = *v2;
  }
  result = a2;
  *a2 = 0;
  return result;
}

//----- (080B4ED6) --------------------------------------------------------
char *__cdecl sub_80B4ED6(void *src, void *dest)
{
  int v2; // eax
  size_t n; // ST10_4
  char *result; // eax

  v2 = sub_80B4D44(src);
  n = v2 - (_DWORD)src;
  memcpy(dest, src, v2 - (_DWORD)src);
  result = (char *)dest + n;
  *((_BYTE *)dest + n) = 0;
  return result;
}

//----- (080B4F1A) --------------------------------------------------------
char *__cdecl Com_DefaultExtension(char *s, size_t maxlen, int a3)
{
  char *result; // eax
  char *i; // [esp+2Ch] [ebp-4Ch]
  char dest; // [esp+30h] [ebp-48h]

  for ( i = &s[strlen(s) - 1]; *i != 47 && i != s; --i )
  {
    result = i;
    if ( *i == 46 )
      return result;
  }
  I_strncpyz(&dest, s, 64);
  return (char *)Com_sprintf(s, maxlen, "%s%s", &dest, a3);
}

//----- (080B4F9A) --------------------------------------------------------
int __cdecl sub_80B4F9A(__int16 a1)
{
  return (signed __int16)dword_8527A40(a1);
}
// 8527A40: using guessed type int (__cdecl *dword_8527A40)(_DWORD);

//----- (080B4FB8) --------------------------------------------------------
int __cdecl sub_80B4FB8(int a1)
{
  return dword_8527A48(a1);
}
// 8527A48: using guessed type int (__cdecl *dword_8527A48)(_DWORD);

//----- (080B4FCE) --------------------------------------------------------
int __cdecl sub_80B4FCE(int a1, int a2)
{
  return dword_8527A50(a1, a2);
}
// 8527A50: using guessed type int (__cdecl *dword_8527A50)(_DWORD, _DWORD);

//----- (080B4FF6) --------------------------------------------------------
int __cdecl sub_80B4FF6(__int16 a1)
{
  return (signed __int16)dword_8527A44(a1);
}
// 8527A44: using guessed type int (__cdecl *dword_8527A44)(_DWORD);

//----- (080B5014) --------------------------------------------------------
int __cdecl sub_80B5014(int a1)
{
  return dword_8527A4C(a1);
}
// 8527A4C: using guessed type int (__cdecl *dword_8527A4C)(_DWORD);

//----- (080B502A) --------------------------------------------------------
int __cdecl sub_80B502A(int a1)
{
  return dword_8527A54(a1);
}
// 8527A54: using guessed type int (__cdecl *dword_8527A54)(_DWORD);

//----- (080B5040) --------------------------------------------------------
int __cdecl sub_80B5040(int a1)
{
  return dword_8527A58(a1);
}
// 8527A58: using guessed type int (__cdecl *dword_8527A58)(_DWORD);

//----- (080B5056) --------------------------------------------------------
int __cdecl sub_80B5056(__int16 a1)
{
  return (signed __int16)(((unsigned __int8)a1 << 8) + HIBYTE(a1));
}

//----- (080B508E) --------------------------------------------------------
int __cdecl sub_80B508E(__int16 a1)
{
  return a1;
}

//----- (080B50A2) --------------------------------------------------------
int __cdecl sub_80B50A2(int a1)
{
  return HIBYTE(a1) + (BYTE2(a1) << 8) + (BYTE1(a1) << 16) + ((unsigned __int8)a1 << 24);
}

//----- (080B50FE) --------------------------------------------------------
int __cdecl sub_80B50FE(int a1)
{
  return a1;
}

//----- (080B5106) --------------------------------------------------------
unsigned __int64 __cdecl sub_80B5106(__int64 a1)
{
  __int64 v1; // rcx
  __int64 v2; // rax
  __int64 v3; // rcx
  __int64 v4; // rcx

  LODWORD(v1) = 0;
  HIDWORD(v1) = (unsigned __int8)a1 << 24;
  LODWORD(v2) = 0;
  HIDWORD(v2) = BYTE1(a1) << 16;
  v3 = v2 + v1;
  LODWORD(v2) = 0;
  HIDWORD(v2) = BYTE2(a1) << 8;
  v4 = v2 + v3;
  HIDWORD(v2) = BYTE3(a1);
  LODWORD(v2) = 0;
  return HIBYTE(a1)
       + ((unsigned __int64)BYTE6(a1) << 8)
       + ((unsigned __int64)BYTE5(a1) << 16)
       + ((unsigned __int64)BYTE4(a1) << 24)
       + v2
       + v4;
}

//----- (080B5242) --------------------------------------------------------
__int64 __cdecl sub_80B5242(__int64 a1)
{
  return a1;
}

//----- (080B525C) --------------------------------------------------------
long double __cdecl sub_80B525C(int a1)
{
  float v1; // ST04_4

  LOBYTE(v1) = HIBYTE(a1);
  BYTE1(v1) = BYTE2(a1);
  BYTE2(v1) = BYTE1(a1);
  HIBYTE(v1) = a1;
  return v1;
}

//----- (080B5290) --------------------------------------------------------
void __cdecl sub_80B5290(float a1)
{
  sub_80B6D62(a1);
}

//----- (080B52A4) --------------------------------------------------------
int __cdecl sub_80B52A4(int a1)
{
  int v1; // ST00_4

  LOBYTE(v1) = HIBYTE(a1);
  BYTE1(v1) = BYTE2(a1);
  BYTE2(v1) = BYTE1(a1);
  HIBYTE(v1) = a1;
  return v1;
}

//----- (080B52D2) --------------------------------------------------------
int __cdecl sub_80B52D2(char a1)
{
  return sub_80B6D58((int)&a1);
}

//----- (080B52E6) --------------------------------------------------------
void sub_80B52E6()
{
  dword_8527A40 = (int (__cdecl *)(_DWORD))sub_80B5056;
  dword_8527A44 = (int (__cdecl *)(_DWORD))sub_80B508E;
  dword_8527A48 = sub_80B50A2;
  dword_8527A4C = sub_80B50FE;
  dword_8527A50 = (int (__cdecl *)(_DWORD, _DWORD))sub_80B5242;
  dword_8527A54 = (int (__cdecl *)(_DWORD))sub_80B5290;
  dword_8527A58 = (int (__cdecl *)(_DWORD))sub_80B52D2;
}
// 8527A40: using guessed type int (__cdecl *dword_8527A40)(_DWORD);
// 8527A44: using guessed type int (__cdecl *dword_8527A44)(_DWORD);
// 8527A48: using guessed type int (__cdecl *dword_8527A48)(_DWORD);
// 8527A4C: using guessed type int (__cdecl *dword_8527A4C)(_DWORD);
// 8527A50: using guessed type int (__cdecl *dword_8527A50)(_DWORD, _DWORD);
// 8527A54: using guessed type int (__cdecl *dword_8527A54)(_DWORD);
// 8527A58: using guessed type int (__cdecl *dword_8527A58)(_DWORD);

//----- (080B5332) --------------------------------------------------------
void sub_80B5332()
{
  dword_8527A40 = (int (__cdecl *)(_DWORD))sub_80B508E;
  dword_8527A44 = (int (__cdecl *)(_DWORD))sub_80B5056;
  dword_8527A48 = sub_80B50FE;
  dword_8527A4C = sub_80B50A2;
  dword_8527A50 = (int (__cdecl *)(_DWORD, _DWORD))sub_80B5106;
  dword_8527A54 = (int (__cdecl *)(_DWORD))sub_80B525C;
  dword_8527A58 = sub_80B52A4;
}
// 8527A40: using guessed type int (__cdecl *dword_8527A40)(_DWORD);
// 8527A44: using guessed type int (__cdecl *dword_8527A44)(_DWORD);
// 8527A48: using guessed type int (__cdecl *dword_8527A48)(_DWORD);
// 8527A4C: using guessed type int (__cdecl *dword_8527A4C)(_DWORD);
// 8527A50: using guessed type int (__cdecl *dword_8527A50)(_DWORD, _DWORD);
// 8527A54: using guessed type int (__cdecl *dword_8527A54)(_DWORD);
// 8527A58: using guessed type int (__cdecl *dword_8527A58)(_DWORD);

//----- (080B537E) --------------------------------------------------------
void Swap_Init()
{
  sub_80B52E6();
}

//----- (080B53C8) --------------------------------------------------------
signed int __cdecl sub_80B53C8(signed int a1)
{
  signed int v2; // [esp+0h] [ebp-4h]

  v2 = 0;
  if ( a1 > 96 && a1 <= 122 )
    v2 = 1;
  return v2;
}

//----- (080B53EE) --------------------------------------------------------
signed int __cdecl sub_80B53EE(signed int a1)
{
  signed int v2; // [esp+0h] [ebp-4h]

  v2 = 0;
  if ( a1 > 64 && a1 <= 90 )
    v2 = 1;
  return v2;
}

//----- (080B5414) --------------------------------------------------------
signed int __cdecl sub_80B5414(signed int a1)
{
  signed int v2; // [esp+0h] [ebp-4h]

  v2 = 0;
  if ( a1 > 96 && a1 <= 122 || a1 > 64 && a1 <= 90 )
    v2 = 1;
  return v2;
}

//----- (080B5448) --------------------------------------------------------
signed int __cdecl sub_80B5448(signed int a1)
{
  signed int v2; // [esp+0h] [ebp-4h]

  v2 = 0;
  if ( a1 > 47 && a1 <= 57 )
    v2 = 1;
  return v2;
}

//----- (080B546E) --------------------------------------------------------
signed int __cdecl sub_80B546E(signed int a1)
{
  signed int v2; // [esp+4h] [ebp-4h]

  v2 = 0;
  if ( (unsigned __int8)sub_80B5414(a1) || (unsigned __int8)sub_80B5448(a1) )
    v2 = 1;
  return v2;
}

//----- (080B54DE) --------------------------------------------------------
char *__cdecl I_strncpyz(char *dest, char *src, int a3)
{
  char *result; // eax

  strncpy(dest, src, a3 - 1);
  result = &dest[a3 - 1];
  *result = 0;
  return result;
}

//----- (080B550A) --------------------------------------------------------
signed int __cdecl sub_80B550A(char *a1, char *a2, int a3)
{
  signed int v4; // [esp+8h] [ebp-10h]
  signed int v6; // [esp+10h] [ebp-8h]
  signed int v7; // [esp+14h] [ebp-4h]

  while ( 1 )
  {
    v7 = *a1++;
    v6 = *a2++;
    if ( --a3 == -1 )
      return 0;
    if ( v7 != v6 )
    {
      if ( (unsigned __int8)sub_80B53C8(v7) )
        v7 -= 32;
      if ( (unsigned __int8)sub_80B53C8(v6) )
        v6 -= 32;
      if ( v7 != v6 )
        break;
    }
    if ( !v7 )
      return 0;
  }
  if ( v7 >= v6 )
    v4 = 1;
  else
    v4 = -1;
  return v4;
}

//----- (080B55B0) --------------------------------------------------------
signed int __cdecl I_strncmp(char *a1, char *a2, int a3)
{
  signed int v4; // [esp+0h] [ebp-10h]
  int v6; // [esp+8h] [ebp-8h]
  int v7; // [esp+Ch] [ebp-4h]

  while ( 1 )
  {
    v7 = *a1++;
    v6 = *a2++;
    if ( --a3 == -1 )
      return 0;
    if ( v7 != v6 )
      break;
    if ( !v7 )
      return 0;
  }
  if ( v7 >= v6 )
    v4 = 1;
  else
    v4 = -1;
  return v4;
}

//----- (080B5620) --------------------------------------------------------
signed int __cdecl I_stricmp(char *a1, char *a2)
{
  return sub_80B550A(a1, a2, 0x7FFFFFFF);
}

//----- (080B5642) --------------------------------------------------------
signed int __cdecl sub_80B5642(char *a1, char *a2)
{
  return I_strncmp(a1, a2, 0x7FFFFFFF);
}

//----- (080B5664) --------------------------------------------------------
signed int __cdecl sub_80B5664(char *a1, char *a2)
{
  int v2; // ebx
  int v3; // eax
  signed int v5; // [esp+14h] [ebp-14h]
  char v7; // [esp+22h] [ebp-6h]
  char v8; // [esp+23h] [ebp-5h]

  while ( 1 )
  {
    v8 = *a1++;
    if ( v8 == 42 )
    {
      if ( !*a1 )
        return 0;
      if ( *a2 && !sub_80B5664(a1 - 1, a2 + 1) )
        return 0;
      goto LABEL_14;
    }
    v7 = *a2++;
    if ( v8 != v7 && v8 != 63 )
    {
      v2 = tolower(v8);
      v3 = tolower(v7);
      if ( v2 != v3 )
        break;
    }
LABEL_14:
    if ( !v8 )
      return 0;
  }
  if ( v2 - v3 >= 0 )
    v5 = 1;
  else
    v5 = -1;
  return v5;
}

//----- (080B573C) --------------------------------------------------------
_BYTE *__cdecl sub_80B573C(_BYTE *a1)
{
  _BYTE *i; // [esp+4h] [ebp-4h]

  for ( i = a1; *i; ++i )
  {
    if ( (unsigned __int8)sub_80B53EE((char)*i) )
      *i += 32;
  }
  return a1;
}

//----- (080B577E) --------------------------------------------------------
_BYTE *__cdecl sub_80B577E(_BYTE *a1)
{
  _BYTE *i; // [esp+4h] [ebp-4h]

  for ( i = a1; *i; ++i )
  {
    if ( (unsigned __int8)sub_80B53C8((char)*i) )
      *i -= 32;
  }
  return a1;
}

//----- (080B57C0) --------------------------------------------------------
char *__cdecl sub_80B57C0(char *s, int a2, char *src)
{
  int v4; // [esp+14h] [ebp-4h]

  v4 = I_strlen(s);
  if ( v4 >= a2 )
    Com_Error(0, &byte_8148700);
  return I_strncpyz(&s[v4], src, a2 - v4);
}

//----- (080B5814) --------------------------------------------------------
int __cdecl sub_80B5814(_BYTE *a1)
{
  int v2; // [esp+0h] [ebp-8h]
  _BYTE *v3; // [esp+4h] [ebp-4h]

  v3 = a1;
  v2 = 0;
  while ( *v3 )
  {
    if ( v3 && *v3 == 94 && v3[1] && v3[1] != 94 && v3[1] > 47 && v3[1] <= 57 )
    {
      v3 += 2;
    }
    else
    {
      ++v2;
      ++v3;
    }
  }
  return v2;
}

//----- (080B587C) --------------------------------------------------------
char *__cdecl sub_80B587C(char *a1)
{
  char v2; // [esp+3h] [ebp-9h]
  char *v3; // [esp+4h] [ebp-8h]
  char *v4; // [esp+8h] [ebp-4h]

  v3 = a1;
  v4 = a1;
  while ( 1 )
  {
    v2 = *v3;
    if ( !*v3 )
      break;
    if ( v3 && *v3 == 94 && v3[1] && v3[1] != 94 && v3[1] > 47 && v3[1] <= 57 )
    {
      ++v3;
    }
    else if ( v2 > 31 && v2 != 127 )
    {
      *v4++ = v2;
    }
    ++v3;
  }
  *v4 = 0;
  return a1;
}

//----- (080B5904) --------------------------------------------------------
signed int __cdecl sub_80B5904(char a1)
{
  signed int v2; // [esp+0h] [ebp-Ch]

  if ( a1 == -110 )
    v2 = 39;
  else
    v2 = a1;
  return v2;
}

//----- (080B5932) --------------------------------------------------------
int Com_sprintf(char *s, size_t maxlen, char *format, ...)
{
  int result; // eax
  va_list va; // [esp+2Ch] [ebp+14h]

  va_start(va, format);
  result = vsnprintf(s, maxlen, format, va);
  s[maxlen - 1] = 0;
  return result;
}

//----- (080B5970) --------------------------------------------------------
_BOOL4 __cdecl sub_80B5970(unsigned int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, int a9, int a10, int a11, int a12, int a13, int a14, int a15, int a16, int a17, int a18, int a19, int a20, int a21, int a22, int a23, int a24, int a25, int a26, int a27, int a28, int a29, int a30, int a31, int a32, int a33, int a34, int a35, int a36, int a37, int a38, int a39, int a40, int a41, int a42, int a43, int a44, int a45, int a46, int a47, int a48, int a49, int a50, int a51, int a52, int a53, int a54, int a55, int a56, int a57, int a58, int a59, int a60, int a61, int a62, int a63)
{
  unsigned int v67; // [esp+10h] [ebp-8h]
  char v68; // [esp+14h] [ebp-4h]

  if ( a1 >= (unsigned int)&v68 && a1 < (unsigned int)&a65 )
    return 0;
  v67 = Sys_GetValue(1);
  return a1 < v67 || a1 >= v67 + 3072;
}
// 80B5970: too many input arguments, some ignored

//----- (080B59CE) --------------------------------------------------------
char *va(char *format, ...)
{
  int v1; // ST18_4
  int v2; // edx
  int v4; // [esp+1Ch] [ebp-Ch]
  char *s; // [esp+20h] [ebp-8h]
  va_list va; // [esp+34h] [ebp+Ch]

  va_start(va, format);
  v1 = Sys_GetValue(1);
  s = (char *)(v1 + (*(_DWORD *)(v1 + 2048) << 10));
  v2 = *(_DWORD *)(v1 + 2048) + 1;
  *(_DWORD *)(v1 + 2048) = v2 / 2;
  *(_DWORD *)(v1 + 2048) = v2 - 2 * *(_DWORD *)(v1 + 2048);
  v4 = vsnprintf(s, 0x400u, format, va);
  s[1023] = 0;
  if ( v4 < 0 || v4 > 1023 )
    Com_Error(1, &byte_8148720);
  return s;
}

//----- (080B5A86) --------------------------------------------------------
int __cdecl sub_80B5A86(int a1)
{
  Sys_SetValue(1, 2052 * a1 + 139604320);
  Sys_SetValue(2, 156 * a1 + 139606400);
  return Sys_SetValue(3, 24 * a1 + 139606556);
}

//----- (080B5B30) --------------------------------------------------------
char *__cdecl sub_80B5B30(char *s, int a2)
{
  char *v2; // eax
  char *v3; // eax
  char *v6; // [esp+18h] [ebp-2010h]
  char *v7; // [esp+18h] [ebp-2010h]
  char *v8; // [esp+1Ch] [ebp-200Ch]
  char v9; // [esp+20h] [ebp-2008h]
  char *sa; // [esp+2030h] [ebp+8h]

  if ( !s || !a2 )
    return (char *)&unk_814874D;
  if ( strlen(s) > 0x1FFF )
    Com_Error(1, &byte_8148760);
  dword_8527A5C ^= 1u;
  if ( *s == 92 )
    ++s;
  while ( 1 )
  {
    v6 = &v9;
    while ( *s != 92 )
    {
      if ( !*s )
        return (char *)&unk_814874D;
      v2 = s++;
      *v6++ = *v2;
    }
    *v6 = 0;
    sa = s + 1;
    v8 = (char *)&unk_8523A40 + 0x2000 * dword_8527A5C;
    v7 = (char *)&unk_8523A40 + 0x2000 * dword_8527A5C;
    while ( *sa != 92 && *sa )
    {
      v3 = sa++;
      *v7++ = *v3;
    }
    *v7 = 0;
    if ( !I_stricmp((char *)a2, &v9) )
      return v8;
    if ( !*sa )
      break;
    s = sa + 1;
  }
  return (char *)&unk_814874D;
}
// 8527A5C: using guessed type int dword_8527A5C;

//----- (080B5D40) --------------------------------------------------------
char *__cdecl sub_80B5D40(char *s, char *s1)
{
  char *result; // eax
  char *v3; // eax
  char *v4; // eax
  char *v5; // [esp+1Ch] [ebp-81Ch]
  char *v6; // [esp+1Ch] [ebp-81Ch]
  char v7; // [esp+20h] [ebp-818h]
  char s2; // [esp+420h] [ebp-418h]
  char *dest; // [esp+82Ch] [ebp-Ch]

  if ( strlen(s) > 0x3FF )
    Com_Error(1, &byte_81487A0);
  result = strchr(s1, 92);
  if ( !result )
  {
    while ( 1 )
    {
      dest = s;
      if ( *s == 92 )
        ++s;
      v5 = &s2;
      while ( *s != 92 )
      {
        result = s;
        if ( !*s )
          return result;
        v3 = s++;
        *v5++ = *v3;
      }
      *v5 = 0;
      ++s;
      v6 = &v7;
      while ( *s != 92 && *s )
      {
        result = s;
        if ( !*s )
          return result;
        v4 = s++;
        *v6++ = *v4;
      }
      *v6 = 0;
      if ( !strcmp(s1, &s2) )
        break;
      result = s;
      if ( !*s )
        return result;
    }
    result = strcpy(dest, s);
  }
  return result;
}

//----- (080B5E72) --------------------------------------------------------
char *__cdecl sub_80B5E72(char *s, char *s1)
{
  char *result; // eax
  char *v3; // eax
  char *v4; // eax
  char *v5; // [esp+1Ch] [ebp-401Ch]
  char *v6; // [esp+1Ch] [ebp-401Ch]
  char v7; // [esp+20h] [ebp-4018h]
  char s2; // [esp+2020h] [ebp-2018h]
  char *dest; // [esp+402Ch] [ebp-Ch]

  if ( strlen(s) > 0x1FFF )
    Com_Error(1, &byte_81487E0);
  result = strchr(s1, 92);
  if ( !result )
  {
    while ( 1 )
    {
      dest = s;
      if ( *s == 92 )
        ++s;
      v5 = &s2;
      while ( *s != 92 )
      {
        result = s;
        if ( !*s )
          return result;
        v3 = s++;
        *v5++ = *v3;
      }
      *v5 = 0;
      ++s;
      v6 = &v7;
      while ( *s != 92 && *s )
      {
        result = s;
        if ( !*s )
          return result;
        v4 = s++;
        *v6++ = *v4;
      }
      *v6 = 0;
      if ( !strcmp(s1, &s2) )
        break;
      result = s;
      if ( !*s )
        return result;
    }
    result = strcpy(dest, s);
  }
  return result;
}

//----- (080B5FA4) --------------------------------------------------------
_BOOL4 __cdecl sub_80B5FA4(char *s)
{
  _BOOL4 v2; // [esp+14h] [ebp-4h]

  if ( strchr(s, 34) )
    v2 = 0;
  else
    v2 = strchr(s, 59) == 0;
  return v2;
}

//----- (080B5FF6) --------------------------------------------------------
void __cdecl sub_80B5FF6(char *s, char *s1, int a3)
{
  size_t v3; // ebx
  char v4; // [esp+23h] [ebp-815h]
  int v5; // [esp+28h] [ebp-810h]
  signed int i; // [esp+2Ch] [ebp-80Ch]
  char v7[1024]; // [esp+30h] [ebp-808h]
  char src; // [esp+430h] [ebp-408h]

  if ( strlen(s) <= 0x3FF )
  {
    v5 = 0;
    for ( i = 0; i <= 1022; ++i )
    {
      v4 = *(_BYTE *)(a3 + i);
      if ( !v4 )
        break;
      if ( v4 != 92 && v4 != 59 && v4 != 34 )
        v7[v5++] = v4;
    }
    v7[v5] = 0;
    if ( strchr(s1, 92) )
    {
      Com_Printf(&byte_8148860, s1, a3);
    }
    else if ( strchr(s1, 59) )
    {
      Com_Printf(&byte_81488A0, s1, a3);
    }
    else if ( strchr(s1, 34) )
    {
      Com_Printf(&byte_81488E0, s1, a3);
    }
    else
    {
      sub_80B5D40(s, s1);
      if ( v7[0] )
      {
        if ( Com_sprintf(&src, 0x400u, "\\%s\\%s", s1, v7) > 0 )
        {
          v3 = strlen(&src);
          if ( strlen(s) + v3 <= 0x400 )
            strcat(s, &src);
          else
            Com_Printf(&byte_8148980, s1, a3, s);
        }
        else
        {
          Com_Printf(&byte_8148920);
        }
      }
    }
  }
  else
  {
    Com_Printf(&byte_8148820);
  }
}
// 80B5FF6: using guessed type char var_808[1024];

//----- (080B622A) --------------------------------------------------------
void __cdecl sub_80B622A(char *s, char *s1, int a3)
{
  size_t v3; // ebx
  char v4; // [esp+23h] [ebp-4015h]
  int v5; // [esp+28h] [ebp-4010h]
  signed int i; // [esp+2Ch] [ebp-400Ch]
  char v7[8192]; // [esp+30h] [ebp-4008h]
  char src; // [esp+2030h] [ebp-2008h]

  if ( strlen(s) <= 0x1FFF )
  {
    v5 = 0;
    for ( i = 0; i <= 8190; ++i )
    {
      v4 = *(_BYTE *)(a3 + i);
      if ( !v4 )
        break;
      if ( v4 != 92 && v4 != 59 && v4 != 34 )
        v7[v5++] = v4;
    }
    v7[v5] = 0;
    if ( strchr(s1, 92) )
    {
      Com_Printf(&byte_8148860, s1, a3);
    }
    else if ( strchr(s1, 59) )
    {
      Com_Printf(&byte_81488A0, s1, a3);
    }
    else if ( strchr(s1, 34) )
    {
      Com_Printf(&byte_81488E0, s1, a3);
    }
    else
    {
      sub_80B5E72(s, s1);
      if ( v7[0] )
      {
        if ( Com_sprintf(&src, 0x2000u, "\\%s\\%s", s1, v7) > 0 )
        {
          v3 = strlen(&src);
          if ( strlen(s) + v3 <= 0x400 )
            strcat(s, &src);
          else
            Com_Printf(&byte_8148980, s1, a3, s);
        }
        else
        {
          Com_Printf(&byte_8148920);
        }
      }
    }
  }
  else
  {
    Com_Printf(&byte_8148820);
  }
}
// 80B622A: using guessed type char var_4008[8192];

//----- (080B645E) --------------------------------------------------------
_BOOL4 __cdecl sub_80B645E(int a1, int a2, int a3, char *s, int a5, int a6, int a7)
{
  _DWORD *v7; // ebx
  float *v8; // ebx
  _DWORD *v9; // ebx
  float v10; // ST24_4
  int *v13; // [esp+28h] [ebp-10h]
  char *nptr; // [esp+2Ch] [ebp-Ch]
  int v15; // [esp+30h] [ebp-8h]

  v15 = 0;
  v13 = (int *)a2;
  while ( v15 < a3 )
  {
    nptr = sub_80B5B30(s, *v13);
    if ( *nptr )
    {
      if ( v13[2] > 7 )
      {
        if ( a5 <= 0 || v13[2] >= a5 )
          Com_Error(1, &byte_81489C4, v13[2]);
        if ( !((int (__cdecl *)(int, char *, int))a6)(a1, nptr, v13[2]) )
          return 0;
      }
      else
      {
        switch ( v13[2] )
        {
          case 0:
            ((void (__cdecl *)(int, char *))a7)(a1 + v13[1], nptr);
            break;
          case 1:
            I_strncpyz((char *)(a1 + v13[1]), nptr, 1024);
            break;
          case 2:
            I_strncpyz((char *)(a1 + v13[1]), nptr, 64);
            break;
          case 3:
            I_strncpyz((char *)(a1 + v13[1]), nptr, 256);
            break;
          case 4:
            *(_DWORD *)(a1 + v13[1]) = atoi(nptr);
            break;
          case 5:
            v7 = (_DWORD *)(v13[1] + a1);
            *v7 = atoi(nptr) != 0;
            break;
          case 6:
            v8 = (float *)(v13[1] + a1);
            *v8 = atof(nptr);
            break;
          case 7:
            v9 = (_DWORD *)(v13[1] + a1);
            v10 = atof(nptr);
            *v9 = (signed int)(v10 * 1000.0);
            break;
        }
      }
    }
    ++v15;
    v13 += 3;
  }
  return v15 == a3;
}

//----- (080B6688) --------------------------------------------------------
long double __cdecl sub_80B6688(float a1)
{
  return (2.0 - sub_80B6D1E(a1)) * a1;
}

//----- (080B66A6) --------------------------------------------------------
long double __cdecl sub_80B66A6(float a1)
{
  float v1; // ST00_4

  v1 = 1.0 - a1;
  return 1.0 - sub_80B6D38(v1);
}

//----- (080B66C0) --------------------------------------------------------
void __cdecl sub_80B66C0(int a1, int a2, float a3, float a4, float a5)
{
  int v5; // ST0C_4
  float v6[4]; // [esp+10h] [ebp-38h]
  int v7; // [esp+20h] [ebp-28h]
  float v8; // [esp+3Ch] [ebp-Ch]

  if ( a3 != 0.0 )
  {
    v8 = sub_80B6688(a3);
    *(float *)&v5 = v8 * a4;
    sub_80B6D74(v6, 0, a2, v5);
    sub_80A2EC2(v6, 0, (float *)&v7, 0);
    v8 = v8 * a5;
    sub_80B6D98(a1, v8, (int)&v7, a1);
  }
}

//----- (080B6758) --------------------------------------------------------
int __cdecl sub_80B6758(float *a1, float *a2, float *a3)
{
  int result; // eax

  *a3 = *a2 * a1[3] + *a1 + a2[1] * a1[6] + a2[2] * a1[9];
  a3[1] = *a2 * a1[4] + a1[1] + a2[1] * a1[7] + a2[2] * a1[10];
  result = (int)(a2 + 2);
  a3[2] = *a2 * a1[5] + a1[2] + a2[1] * a1[8] + a2[2] * a1[11];
  return result;
}

//----- (080B6806) --------------------------------------------------------
int __cdecl sub_80B6806(float *a1, float *a2, float *a3)
{
  int result; // eax

  *a3 = *a2 * a1[3] + a2[1] * a1[6] + a2[2] * a1[9];
  a3[1] = *a2 * a1[4] + a2[1] * a1[7] + a2[2] * a1[10];
  result = (int)(a2 + 2);
  a3[2] = *a2 * a1[5] + a2[1] * a1[8] + a2[2] * a1[11];
  return result;
}

//----- (080B68EE) --------------------------------------------------------
float *__cdecl sub_80B68EE(float *a1, float *a2, float *a3)
{
  float v3; // ST00_4
  float v4; // ST04_4
  float v5; // ST08_4
  float *result; // eax

  v3 = *a2 - *a1;
  v4 = a2[1] - a1[1];
  v5 = a2[2] - a1[2];
  *a3 = v3 * a1[3] + v4 * a1[4] + v5 * a1[5];
  a3[1] = v3 * a1[6] + v4 * a1[7] + v5 * a1[8];
  result = a1;
  a3[2] = v3 * a1[9] + v4 * a1[10] + v5 * a1[11];
  return result;
}

//----- (080B6998) --------------------------------------------------------
int __cdecl sub_80B6998(float *a1, float *a2, float *a3)
{
  int result; // eax

  *a3 = *a2 * a1[3] + a2[1] * a1[4] + a2[2] * a1[5];
  a3[1] = *a2 * a1[6] + a2[1] * a1[7] + a2[2] * a1[8];
  result = (int)(a2 + 2);
  a3[2] = *a2 * a1[9] + a2[1] * a1[10] + a2[2] * a1[11];
  return result;
}

//----- (080B6D1E) --------------------------------------------------------
long double __cdecl sub_80B6D1E(float a1)
{
  return (float)fabs(a1);
}

//----- (080B6D38) --------------------------------------------------------
long double __cdecl sub_80B6D38(float a1)
{
  return (float)sqrt(a1);
}

//----- (080B6D58) --------------------------------------------------------
int __cdecl sub_80B6D58(int a1)
{
  return *(_DWORD *)a1;
}

//----- (080B6D62) --------------------------------------------------------
long double __cdecl sub_80B6D62(float a1)
{
  return a1;
}

//----- (080B6D74) --------------------------------------------------------
int __cdecl sub_80B6D74(_DWORD *a1, int a2, int a3, int a4)
{
  int result; // eax

  *a1 = a2;
  a1[1] = a3;
  result = a4;
  a1[2] = a4;
  return result;
}

//----- (080B6D98) --------------------------------------------------------
int __cdecl sub_80B6D98(int a1, float a2, int a3, int a4)
{
  int result; // eax

  *(float *)a4 = a2 * *(float *)a3 + *(float *)a1;
  *(float *)(a4 + 4) = a2 * *(float *)(a3 + 4) + *(float *)(a1 + 4);
  result = a3 + 8;
  *(float *)(a4 + 8) = a2 * *(float *)(a3 + 8) + *(float *)(a1 + 8);
  return result;
}

//----- (080B6DEC) --------------------------------------------------------
long double __cdecl sub_80B6DEC(float *a1, float *a2)
{
  return *a1 * *a2 + a1[1] * a2[1] + a1[2] * a2[2];
}

//----- (080B6E20) --------------------------------------------------------
int __cdecl sub_80B6E20(char *s1)
{
  signed int i; // [esp+14h] [ebp-4h]

  if ( !strcasecmp(s1, "default") )
    return 0;
  for ( i = 0; i <= 21; ++i )
  {
    if ( !strcasecmp(s1, (&off_8162960)[5 * i]) )
      return (unsigned __int8)((dword_8162968[5 * i] & 0x1F00000) >> 20);
  }
  return -1;
}
// 8162960: using guessed type char *off_8162960;

//----- (080B6EB2) --------------------------------------------------------
const char *__cdecl sub_80B6EB2(signed int a1)
{
  const char *v2; // [esp+0h] [ebp-4h]

  if ( a1 <= 0 || a1 > 22 )
    v2 = "default";
  else
    v2 = (const char *)dword_816294C[5 * a1];
  return v2;
}
// 816294C: using guessed type int dword_816294C[];

//----- (080B6EE8) --------------------------------------------------------
int DObjInit()
{
  int result; // eax
  char s; // [esp+10h] [ebp-28h]

  memset(&s, 0, 0x14u);
  result = sub_8078DEC(&s, 0, 0x11u);
  dword_8527A68 = result;
  return result;
}
// 8527A68: using guessed type int dword_8527A68;

//----- (080B6F34) --------------------------------------------------------
int DObjShutdown()
{
  int result; // eax

  if ( dword_8527A68 )
  {
    result = sub_8079746(dword_8527A68, 0x11u);
    dword_8527A68 = 0;
  }
  return result;
}
// 8527A68: using guessed type int dword_8527A68;

//----- (080B6F64) --------------------------------------------------------
void sub_80B6F64()
{
  dword_8527A68 = 0;
}
// 8527A68: using guessed type int dword_8527A68;

//----- (080B6F74) --------------------------------------------------------
void __cdecl sub_80B6F74(int a1)
{
  signed __int16 **v1; // ST18_4
  int v2; // eax
  int v3; // ebx
  int v4; // eax
  unsigned __int8 *k; // [esp+1Ch] [ebp-1Ch]
  int v6; // [esp+20h] [ebp-18h]
  int v7; // [esp+24h] [ebp-14h]
  int v8; // [esp+28h] [ebp-10h]
  int i; // [esp+2Ch] [ebp-Ch]
  int j; // [esp+30h] [ebp-8h]

  if ( a1 )
  {
    Com_Printf("\nModels:\n");
    v7 = *(unsigned __int8 *)(a1 + 24);
    v6 = 0;
    for ( i = 0; i < v7; ++i )
    {
      v1 = *(signed __int16 ***)(a1 + 4 * i + 28);
      Com_Printf("%d: '%s'\n", v6, v1[34]);
      v6 += **v1;
    }
    Com_Printf("\nBones:\n");
    v8 = *(unsigned __int8 *)(a1 + 25);
    for ( j = 0; j < v8; ++j )
    {
      v2 = sub_80B8B16(a1, j);
      Com_Printf("Bone %d: '%s'\n", j, v2);
    }
    if ( *(_WORD *)(a1 + 16) )
    {
      Com_Printf("\nPart duplicates:\n");
      for ( k = (unsigned __int8 *)(sub_8078896(*(unsigned __int16 *)(a1 + 16)) + 16); *k; k += 2 )
      {
        v3 = sub_80B8B16(a1, k[1] - 1);
        v4 = sub_80B8B16(a1, *k - 1);
        Com_Printf("%d ('%s') -> %d ('%s')\n", *k - 1, v4, k[1] - 1, v3);
      }
    }
    else
    {
      Com_Printf("\nNo part duplicates.\n");
    }
    Com_Printf("\n");
  }
  else
  {
    Com_Printf("No Dobj\n");
  }
}

//----- (080B712C) --------------------------------------------------------
int __cdecl sub_80B712C(int a1, int a2)
{
  int v4; // [esp+14h] [ebp-14h]
  signed __int16 **v5; // [esp+18h] [ebp-10h]
  int v6; // [esp+1Ch] [ebp-Ch]
  int i; // [esp+20h] [ebp-8h]
  int v8; // [esp+24h] [ebp-4h]

  v8 = *(unsigned __int8 *)(a1 + 24);
  v6 = 0;
  for ( i = 0; i < v8; ++i )
  {
    v5 = *(signed __int16 ***)(a1 + 4 * i + 28);
    v4 = sub_80C3324(*(signed __int16 ***)(a1 + 4 * i + 28), a2);
    if ( v4 >= 0 )
      return v6 + v4;
    v6 += **v5;
  }
  return -1;
}

//----- (080B71A8) --------------------------------------------------------
int __cdecl sub_80B71A8(int a1)
{
  int v1; // eax
  int result; // eax
  int s[279]; // [esp+10h] [ebp-498h]
  int v4[279]; // [esp+20h] [ebp-488h]
  signed __int16 *v5; // [esp+46Ch] [ebp-3Ch]
  int v6; // [esp+470h] [ebp-38h]
  char v7; // [esp+477h] [ebp-31h]
  int v8; // [esp+478h] [ebp-30h]
  int *v9; // [esp+47Ch] [ebp-2Ch]
  unsigned __int16 *v10; // [esp+480h] [ebp-28h]
  unsigned __int16 **v11; // [esp+484h] [ebp-24h]
  int v12; // [esp+488h] [ebp-20h]
  int i; // [esp+48Ch] [ebp-1Ch]
  int v14; // [esp+490h] [ebp-18h]
  signed __int16 **v15; // [esp+494h] [ebp-14h]
  int v16; // [esp+498h] [ebp-10h]
  int v17; // [esp+49Ch] [ebp-Ch]

  v9 = v4;
  memset(s, 0, 0x10u);
  v8 = 0;
  v16 = ***(signed __int16 ***)(a1 + 28);
  v17 = 1;
  while ( v17 < *(unsigned __int8 *)(a1 + 24) )
  {
    v15 = *(signed __int16 ***)(a1 + 4 * v17 + 28);
    if ( *(_BYTE *)(v17 + a1 + 60) == -1 )
    {
      v5 = *v15;
      v11 = (unsigned __int16 **)*((_DWORD *)v5 + 1);
      v10 = *v11;
      v12 = *v5;
      v7 = 0;
      v14 = -1;
      for ( i = 0; i < v12; ++i )
      {
        v14 = sub_80B712C(a1, v10[i]);
        if ( v14 != v16 + i )
        {
          if ( !i )
            v7 = 1;
          v6 = v16 + i;
          *((_BYTE *)v9 + v8) = v16 + i + 1;
          s[v6 >> 5] |= 1 << (v6 & 0x1F);
          *((_BYTE *)v9 + ++v8) = v14 + 1;
          ++v8;
        }
      }
      if ( !v7 )
      {
        v1 = sub_8078896(*v10);
        Com_Printf(
          "WARNING: Attempting to meld model, but root part '%s' of model '%s' not found in model '%s' or any of its descendants\n",
          v1,
          v15[34],
          *(_DWORD *)(*(_DWORD *)(a1 + 28) + 136));
      }
    }
    ++v17;
    v16 += **v15;
  }
  if ( v8 )
  {
    *((_BYTE *)v9 + v8++) = 0;
    result = sub_8078DEC(s, 0, v8 + 16);
    *(_WORD *)(a1 + 16) = result;
  }
  else
  {
    result = (unsigned __int16)dword_8527A68;
    *(_WORD *)(a1 + 16) = dword_8527A68;
  }
  return result;
}
// 8527A68: using guessed type int dword_8527A68;
// 80B71A8: using guessed type int s[279];

//----- (080B73C0) --------------------------------------------------------
int __cdecl sub_80B73C0(int a1, int a2, int a3)
{
  int result; // eax
  int v4; // [esp+1Ch] [ebp-5Ch]
  int v5[8]; // [esp+20h] [ebp-58h]
  int v6; // [esp+40h] [ebp-38h]
  unsigned __int8 *k; // [esp+44h] [ebp-34h]
  int v8; // [esp+48h] [ebp-30h]
  int j; // [esp+4Ch] [ebp-2Ch]
  unsigned __int8 *v10; // [esp+50h] [ebp-28h]
  signed __int16 *v11; // [esp+54h] [ebp-24h]
  int i; // [esp+58h] [ebp-20h]
  int v13; // [esp+5Ch] [ebp-1Ch]

  for ( i = 0; i <= 3; ++i )
    *(_DWORD *)(a3 + 4 * i) = 0;
  v13 = *(unsigned __int8 *)(a1 + 24);
  if ( !*(_WORD *)(a1 + 16) )
    sub_80B71A8(a1);
  v4 = sub_8078896(*(unsigned __int16 *)(a1 + 16));
  v10 = (unsigned __int8 *)(v4 + 16);
  k = (unsigned __int8 *)(v4 + 16);
  v5[0] = 0;
  for ( i = 0; ; v5[i] = v6 )
  {
    v11 = **(signed __int16 ***)(a1 + 4 * i + 28);
    v6 = v5[i] + *v11;
    if ( v6 > a2 )
    {
      for ( j = *((_DWORD *)v11 + 1) + 4; ; a2 -= *(unsigned __int8 *)(j + v6) )
      {
        v8 = a2 - v5[i];
        while ( 1 )
        {
          *(_DWORD *)(a3 + 4 * (a2 >> 5)) |= 1 << (a2 & 0x1F);
          if ( !(((unsigned __int8)(*(_DWORD *)(v4 + 4 * (a2 >> 5)) >> (a2 & 0x1F)) ^ 1) & 1) )
          {
            for ( k = v10; a2 != *k - 1; k += 2 )
              ;
            a2 = k[1] - 1;
            goto LABEL_21;
          }
          v6 = v8 - v11[1];
          if ( v6 >= 0 )
            break;
          result = *(unsigned __int8 *)(i + a1 + 60);
          a2 = *(unsigned __int8 *)(i + a1 + 60);
          if ( a2 == 255 )
            return result;
          do
LABEL_21:
            v8 = a2 - v5[--i];
          while ( v8 < 0 );
          v11 = **(signed __int16 ***)(a1 + 4 * i + 28);
          j = *((_DWORD *)v11 + 1) + 4;
        }
      }
    }
    result = ++i;
    if ( i == v13 )
      break;
  }
  return result;
}
// 80B73C0: using guessed type int var_58[8];

//----- (080B75A8) --------------------------------------------------------
int *__cdecl sub_80B75A8(int a1, int a2)
{
  int *result; // eax
  int v3; // [esp+18h] [ebp-60h]
  int v4; // [esp+1Ch] [ebp-5Ch]
  int v5[8]; // [esp+20h] [ebp-58h]
  int v6; // [esp+40h] [ebp-38h]
  unsigned __int8 *k; // [esp+44h] [ebp-34h]
  int v8; // [esp+48h] [ebp-30h]
  int j; // [esp+4Ch] [ebp-2Ch]
  unsigned __int8 *v10; // [esp+50h] [ebp-28h]
  signed __int16 *v11; // [esp+54h] [ebp-24h]
  int i; // [esp+58h] [ebp-20h]
  int v13; // [esp+5Ch] [ebp-1Ch]

  v3 = *(unsigned __int8 *)(a1 + 25) - 1;
  v13 = *(unsigned __int8 *)(a1 + 24);
  if ( !*(_WORD *)(a1 + 16) )
    sub_80B71A8(a1);
  v4 = sub_8078896(*(unsigned __int16 *)(a1 + 16));
  v10 = (unsigned __int8 *)(v4 + 16);
  k = (unsigned __int8 *)(v4 + 16);
  v5[0] = 0;
  for ( i = 0; ; v5[i] = v6 )
  {
    v11 = **(signed __int16 ***)(a1 + 4 * i + 28);
    v6 = v5[i] + *v11;
    if ( v6 > v3 )
      break;
    ++i;
  }
  for ( j = *((_DWORD *)v11 + 1) + 4; ; j = *((_DWORD *)v11 + 1) + 4 )
  {
    while ( 1 )
    {
      v8 = v3 - v5[i];
      if ( v8 < 0 )
        break;
      if ( ((unsigned __int8)(*(_DWORD *)(a2 + 4 * (v3 >> 5)) >> (v3 & 0x1F)) ^ 1) & 1 )
      {
        --v3;
      }
      else
      {
        if ( !(((unsigned __int8)(*(_DWORD *)(v4 + 4 * (v3 >> 5)) >> (v3 & 0x1F)) ^ 1) & 1) )
        {
          for ( k = v10; v3 != *k - 1; k += 2 )
            ;
          v6 = k[1] - 1;
          goto LABEL_21;
        }
        v6 = v8 - v11[1];
        if ( v6 >= 0 )
        {
          v6 = v3 - *(unsigned __int8 *)(j + v6);
          goto LABEL_21;
        }
        v6 = *(unsigned __int8 *)(i + a1 + 60);
        if ( v6 == 255 )
        {
          --v3;
        }
        else
        {
LABEL_21:
          *(_DWORD *)(a2 + 4 * (v6 >> 5)) |= 1 << (v6 & 0x1F);
          --v3;
        }
      }
    }
    result = &i;
    if ( --i < 0 )
      break;
    v11 = **(signed __int16 ***)(a1 + 4 * i + 28);
  }
  return result;
}
// 80B75A8: using guessed type int var_58[8];

//----- (080B7796) --------------------------------------------------------
int __cdecl sub_80B7796(int a1, int a2)
{
  return (*(_DWORD *)(*(_DWORD *)(a1 + 4) + 4 * (a2 >> 5) + 32) >> (a2 & 0x1F)) & 1;
}

//----- (080B77C2) --------------------------------------------------------
signed int __cdecl sub_80B77C2(int a1, int a2)
{
  signed int i; // [esp+8h] [ebp-8h]

  for ( i = 0; i <= 3; ++i )
  {
    if ( *(_DWORD *)(a2 + 4 * i) & ~*(_DWORD *)(*(_DWORD *)(a1 + 4) + 4 * i + 32) )
      return 0;
  }
  return 1;
}

//----- (080B7822) --------------------------------------------------------
int *__cdecl sub_80B7822(int a1, int a2)
{
  int *result; // eax
  float *v3; // ecx
  float *v4; // edx
  float *v5; // ecx
  float *v6; // edx
  int v7; // [esp+1Ch] [ebp-9Ch]
  char v8; // [esp+23h] [ebp-95h]
  int v9; // [esp+24h] [ebp-94h]
  float *v10; // [esp+30h] [ebp-88h]
  unsigned __int8 *v11; // [esp+34h] [ebp-84h]
  int v12; // [esp+3Ch] [ebp-7Ch]
  signed int v13; // [esp+40h] [ebp-78h]
  signed int v14; // [esp+40h] [ebp-78h]
  signed int v15; // [esp+40h] [ebp-78h]
  int v16; // [esp+44h] [ebp-74h]
  int v17; // [esp+48h] [ebp-70h]
  int v18; // [esp+4Ch] [ebp-6Ch]
  int v19[4]; // [esp+50h] [ebp-68h]
  int v20[4]; // [esp+60h] [ebp-58h]
  int v21[4]; // [esp+70h] [ebp-48h]
  float *v22; // [esp+80h] [ebp-38h]
  int v23; // [esp+84h] [ebp-34h]
  unsigned __int8 v24; // [esp+8Bh] [ebp-2Dh]
  unsigned __int8 *v25; // [esp+8Ch] [ebp-2Ch]
  signed __int16 *v26; // [esp+90h] [ebp-28h]
  int j; // [esp+94h] [ebp-24h]
  int i; // [esp+98h] [ebp-20h]
  float *v29; // [esp+9Ch] [ebp-1Ch]

  result = *(int **)(a1 + 4);
  v9 = *(_DWORD *)(a1 + 4);
  v8 = 1;
  for ( i = 0; i <= 3; ++i )
  {
    v20[i] = *(_DWORD *)(v9 + 4 * i + 32) | ~*(_DWORD *)(a2 + 4 * i);
    if ( v20[i] != -1 )
      v8 = 0;
    result = &i;
  }
  if ( !v8 )
  {
    if ( !*(_WORD *)(a1 + 16) )
      sub_80B71A8(a1);
    v7 = sub_8078896(*(unsigned __int16 *)(a1 + 16));
    for ( i = 0; i <= 3; ++i )
    {
      *(_DWORD *)(v9 + 4 * i + 32) |= *(_DWORD *)(a2 + 4 * i);
      v21[i] = *(_DWORD *)(v9 + 4 * i + 16) & ~v20[i];
      v19[i] = *(_DWORD *)(v7 + 4 * i) | v21[i] | v20[i];
    }
    for ( i = 0; i <= 3; ++i )
      v21[i] |= ~v19[i];
    v12 = *(unsigned __int8 *)(a1 + 24);
    v23 = v9 + 48;
    v29 = (float *)(v9 + 48);
    v17 = 0;
    v11 = (unsigned __int8 *)(v7 + 16);
    for ( j = 0; ; ++j )
    {
      result = (int *)j;
      if ( j >= v12 )
        break;
      v26 = **(signed __int16 ***)(a1 + 4 * j + 28);
      v24 = *(_BYTE *)(j + a1 + 60);
      if ( v24 == -1 )
      {
        i = v26[1];
        while ( i )
        {
          v13 = 1 << (v17 & 0x1F);
          if ( v21[v17 >> 5] & v13 )
          {
            sub_80B9D76((signed int)v29);
          }
          else if ( v17 == *v11 - 1 )
          {
            v11 += 2;
            if ( !(v20[v17 >> 5] & v13) )
            {
              v3 = v29;
              v4 = (float *)(v23 + 32 * (*(v11 - 1) - 1));
              *v29 = *v4;
              v3[1] = v4[1];
              v3[2] = v4[2];
              v3[3] = v4[3];
              v3[4] = v4[4];
              v3[5] = v4[5];
              v3[6] = v4[6];
              v3[7] = v4[7];
            }
          }
          --i;
          v29 += 8;
          ++v17;
        }
      }
      else
      {
        v10 = (float *)(v23 + 32 * v24);
        i = v26[1];
        while ( i )
        {
          v14 = 1 << (v17 & 0x1F);
          if ( v21[v17 >> 5] & v14 )
          {
            if ( v14 & v19[v17 >> 5] )
              sub_80B9FB2(v10, v29);
            else
              sub_80B9E7A(v29, v10);
            sub_80B9D76((signed int)v29);
            sub_80B9DC6(v29 + 4, v10);
          }
          --i;
          v29 += 8;
          ++v17;
        }
      }
      v18 = *((_DWORD *)v26 + 2);
      v22 = (float *)*((_DWORD *)v26 + 3);
      v25 = (unsigned __int8 *)(*((_DWORD *)v26 + 1) + 4);
      i = *v26 - v26[1];
      while ( i )
      {
        v16 = v17 >> 5;
        v15 = 1 << (v17 & 0x1F);
        if ( v21[v17 >> 5] & v15 )
        {
          if ( v15 & v19[v16] )
            sub_80B9FB2(&v29[-8 * *v25], v29);
          else
            sub_80B9E7A(v29, &v29[-8 * *v25]);
          sub_80B9D76((signed int)v29);
          sub_80B9B5C(v29 + 4, v22, v29 + 4);
          sub_80B9DC6(v29 + 4, &v29[-8 * *v25]);
        }
        else if ( v17 == *v11 - 1 )
        {
          v11 += 2;
          if ( !(v20[v16] & v15) )
          {
            v5 = v29;
            v6 = (float *)(v23 + 32 * (*(v11 - 1) - 1));
            *v29 = *v6;
            v5[1] = v6[1];
            v5[2] = v6[2];
            v5[3] = v6[3];
            v5[4] = v6[4];
            v5[5] = v6[5];
            v5[6] = v6[6];
            v5[7] = v6[7];
          }
        }
        --i;
        v29 += 8;
        v18 += 8;
        v22 += 3;
        ++v25;
        ++v17;
      }
    }
  }
  return result;
}
// 80B7822: using guessed type int var_58[4];
// 80B7822: using guessed type int var_48[4];
// 80B7822: using guessed type int var_68[4];

//----- (080B7D70) --------------------------------------------------------
_DWORD *__cdecl sub_80B7D70(_DWORD *a1, int a2)
{
  _DWORD *result; // eax
  unsigned __int8 v3; // [esp+1Bh] [ebp-Dh]
  unsigned __int8 *v4; // [esp+1Ch] [ebp-Ch]
  size_t n; // [esp+20h] [ebp-8h]

  *a1 = a2;
  if ( a2 )
  {
    n = *(_DWORD *)(*(_DWORD *)a2 + 4);
    a1[3] = a2 + 2 * n + 8;
    v4 = (unsigned __int8 *)(a1[3] + 2 * n);
    v3 = *v4 + 1;
    if ( *v4 == -1 )
    {
      v3 = 1;
      memset(v4 + 1, 0, n);
    }
    result = (_DWORD *)v3;
    *v4 = v3;
  }
  else
  {
    result = a1;
    a1[3] = 0;
  }
  return result;
}

//----- (080B7DFC) --------------------------------------------------------
int __cdecl sub_80B7DFC(int a1)
{
  float v2[4]; // [esp+10h] [ebp-58h]
  float v3[4]; // [esp+20h] [ebp-48h]
  float v4[4]; // [esp+30h] [ebp-38h]
  float v5[6]; // [esp+40h] [ebp-28h]
  int i; // [esp+58h] [ebp-10h]
  int v7; // [esp+5Ch] [ebp-Ch]

  v7 = *(unsigned __int8 *)(a1 + 24);
  sub_80B9B08(v3, 0, 0, 0);
  sub_80B9B08(v2, 0, 0, 0);
  for ( i = 0; i < v7; ++i )
  {
    if ( *(_DWORD *)(a1 + 4 * i + 28) )
    {
      sub_80C337C(*(_DWORD *)(a1 + 4 * i + 28), v5, v4);
      sub_80B9B5C(v3, v5, v3);
      sub_80B9B5C(v2, v4, v2);
    }
  }
  sub_80B9B2C(v3, (_DWORD *)(a1 + 76));
  return sub_80B9B2C(v2, (_DWORD *)(a1 + 88));
}

//----- (080B7EFC) --------------------------------------------------------
int __cdecl sub_80B7EFC(signed __int16 ***a1, unsigned int a2, int a3, int a4, __int16 a5)
{
  int v5; // ST24_4
  int v6; // ST2C_4
  signed __int16 ***v8; // [esp+1Ch] [ebp-3Ch]
  int v9; // [esp+20h] [ebp-38h]
  int v10; // [esp+30h] [ebp-28h]
  int v11; // [esp+34h] [ebp-24h]
  signed __int16 **s2; // [esp+38h] [ebp-20h]
  signed __int16 **v13; // [esp+3Ch] [ebp-1Ch]
  int v14; // [esp+44h] [ebp-14h]
  int i; // [esp+48h] [ebp-10h]
  unsigned int v16; // [esp+4Ch] [ebp-Ch]

  *(_DWORD *)(a4 + 4) = 0;
  *(_DWORD *)(a4 + 8) = 0;
  *(_WORD *)(a4 + 16) = 0;
  *(_BYTE *)(a4 + 26) = 0;
  sub_80B7D70((_DWORD *)a4, a3);
  if ( a3 )
    *(_WORD *)(a3 + 4) = a5;
  v9 = 0;
  v14 = 0;
  v8 = a1;
  v16 = 0;
  while ( v16 < a2 )
  {
    v13 = *v8;
    *(_DWORD *)(a4 + 4 * v9 + 28) = *v8;
    *(_BYTE *)(v9 + a4 + 60) = -1;
    *(_BYTE *)(v9 + a4 + 68) = v14;
    if ( v8[2] )
      *(_BYTE *)(a4 + 26) |= 1 << v16;
    if ( v16 )
    {
      v5 = **((_DWORD **)*v13 + 1);
      v6 = **v13;
      s2 = v8[1];
      if ( s2 )
      {
        if ( *(_BYTE *)s2 )
        {
          v11 = sub_8078CC6(s2);
          if ( v11 )
          {
            for ( i = 0; i < v9; ++i )
            {
              v10 = sub_80C3324(*(signed __int16 ***)(a4 + 4 * i + 28), v11);
              if ( v10 >= 0 )
              {
                *(_BYTE *)(v9 + a4 + 60) = *(_BYTE *)(i + a4 + 68) + v10;
                goto LABEL_17;
              }
            }
          }
          Com_Printf(
            "WARNING: Part '%s' not found in model '%s' or any of its descendants\n",
            s2,
            *(_DWORD *)(*(_DWORD *)(a4 + 28) + 136));
        }
      }
    }
LABEL_17:
    if ( v13 )
    {
      if ( v14 + **v13 > 127 )
        Com_Error(1, &byte_8148D20, *(_DWORD *)(*(_DWORD *)(a4 + 28) + 136), 127);
      v14 += **v13;
    }
    ++v9;
    ++v16;
    v8 += 3;
  }
  *(_BYTE *)(a4 + 24) = v9;
  *(_BYTE *)(a4 + 25) = v14;
  return sub_80B7DFC(a4);
}

//----- (080B812E) --------------------------------------------------------
_DWORD *__cdecl sub_80B812E(const void *a1, int a2, int a3)
{
  qmemcpy((void *)a3, a1, 0x64u);
  *(_DWORD *)(a3 + 4) = 0;
  if ( *(_WORD *)(a3 + 16) && *(unsigned __int16 *)(a3 + 16) != dword_8527A68 )
    sub_807951E(*(unsigned __int16 *)(a3 + 16));
  return sub_80B7D70((_DWORD *)a3, a2);
}
// 8527A68: using guessed type int dword_8527A68;

//----- (080B819E) --------------------------------------------------------
int __cdecl sub_80B819E(int a1)
{
  int result; // eax
  int v2; // eax
  size_t v3; // eax

  if ( *(_DWORD *)a1 )
  {
    *(_DWORD *)(a1 + 12) = 0;
    *(_DWORD *)a1 = 0;
  }
  result = a1;
  if ( *(_WORD *)(a1 + 16) )
  {
    if ( *(unsigned __int16 *)(a1 + 16) != dword_8527A68 )
    {
      v2 = sub_8078896(*(unsigned __int16 *)(a1 + 16));
      v3 = I_strlen((char *)(v2 + 16));
      sub_8079746(*(unsigned __int16 *)(a1 + 16), v3 + 17);
    }
    result = a1;
    *(_WORD *)(a1 + 16) = 0;
  }
  return result;
}
// 8527A68: using guessed type int dword_8527A68;

//----- (080B821A) --------------------------------------------------------
int __cdecl sub_80B821A(unsigned __int8 *a1, _DWORD *a2, _WORD *a3, _DWORD *a4, _WORD *a5)
{
  int result; // eax
  int v6; // ST24_4
  int v7; // ST20_4
  __int16 v8; // [esp+1Ah] [ebp-1Eh]
  int j; // [esp+28h] [ebp-10h]
  int v10; // [esp+2Ch] [ebp-Ch]
  _DWORD *i; // [esp+30h] [ebp-8h]

  *a3 = a1[24];
  *a4 = *(_DWORD *)a1;
  if ( *(_DWORD *)a1 )
    v8 = *(_WORD *)(*(_DWORD *)a1 + 4);
  else
    v8 = 0;
  *a5 = v8;
  v10 = 0;
  for ( i = a2; ; i += 3 )
  {
    result = a1[24];
    if ( v10 >= result )
      break;
    *i = *(_DWORD *)&a1[4 * v10 + 28];
    i[1] = 0;
    i[2] = (((signed int)a1[26] >> v10) & 1) != 0;
    if ( a1[v10 + 60] != -1 )
    {
      for ( j = v10 - 1; j >= 0; --j )
      {
        if ( a1[v10 + 60] >= a1[j + 68] )
        {
          v6 = a1[v10 + 60] - a1[j + 68];
          v7 = sub_80C3314(*(_DWORD *)&a1[4 * j + 28]);
          i[1] = sub_8078896(*(unsigned __int16 *)(v7 + 2 * v6));
          break;
        }
      }
    }
    ++v10;
  }
  return result;
}

//----- (080B8380) --------------------------------------------------------
int __cdecl sub_80B8380(int a1)
{
  return 32 * *(unsigned __int8 *)(a1 + 25) + 48;
}

//----- (080B83A2) --------------------------------------------------------
_BOOL4 __cdecl sub_80B83A2(int a1, int a2)
{
  if ( *(_DWORD *)(a1 + 8) == a2 )
    return *(_DWORD *)(a1 + 4) != 0;
  *(_DWORD *)(a1 + 4) = 0;
  return 0;
}

//----- (080B840A) --------------------------------------------------------
int __cdecl sub_80B840A(int a1)
{
  int result; // eax

  *(_DWORD *)(a1 + 8) = 0;
  result = a1;
  *(_DWORD *)(a1 + 4) = 0;
  return result;
}

//----- (080B8424) --------------------------------------------------------
int *__cdecl sub_80B8424(int a1, int a2, int *a3)
{
  int *result; // eax
  int i; // [esp+4h] [ebp-4h]

  *(_DWORD *)(a1 + 4) = a2;
  result = a3;
  *(_DWORD *)(a1 + 8) = a3;
  for ( i = 0; i <= 3; ++i )
  {
    *(_DWORD *)(a2 + 4 * i) = 0;
    *(_DWORD *)(a2 + 4 * i + 16) = 0;
    *(_DWORD *)(a2 + 4 * i + 32) = 0;
    result = &i;
  }
  return result;
}

//----- (080B8490) --------------------------------------------------------
int __cdecl sub_80B8490(int a1, int a2)
{
  return *(_DWORD *)(a1 + 4 * a2 + 28);
}

//----- (080B84A0) --------------------------------------------------------
int __cdecl sub_80B84A0(int a1, _DWORD *a2, _DWORD *a3)
{
  sub_80B9B2C((_DWORD *)(a1 + 76), a2);
  return sub_80B9B2C((_DWORD *)(a1 + 88), a3);
}

//----- (080B84D2) --------------------------------------------------------
int __cdecl sub_80B84D2(int a1)
{
  int v2; // [esp+0h] [ebp-4h]

  if ( *(_DWORD *)(a1 + 4) )
    v2 = *(_DWORD *)(a1 + 4) + 48;
  else
    v2 = 0;
  return v2;
}

//----- (080B858C) --------------------------------------------------------
signed int __cdecl sub_80B858C(int a1, int a2, int a3)
{
  int v5; // [esp+4h] [ebp-14h]
  signed int v6; // [esp+8h] [ebp-10h]
  int v7; // [esp+Ch] [ebp-Ch]

  v7 = a3 >> 5;
  v6 = 1 << (a3 & 0x1F);
  if ( !(*(_DWORD *)(a2 + 4 * (a3 >> 5)) & (1 << (a3 & 0x1F))) )
    return 0;
  v5 = *(_DWORD *)(a1 + 4);
  if ( *(_DWORD *)(v5 + 4 * v7 + 32) & v6 )
    return 0;
  *(_DWORD *)(v5 + 4 * v7) |= v6;
  return 1;
}

//----- (080B8616) --------------------------------------------------------
signed int __cdecl sub_80B8616(int a1, int a2, int a3)
{
  int v5; // [esp+4h] [ebp-14h]
  signed int v6; // [esp+8h] [ebp-10h]
  int v7; // [esp+Ch] [ebp-Ch]

  v7 = a3 >> 5;
  v6 = 1 << (a3 & 0x1F);
  if ( !(*(_DWORD *)(a2 + 4 * (a3 >> 5)) & (1 << (a3 & 0x1F))) )
    return 0;
  v5 = *(_DWORD *)(a1 + 4);
  if ( *(_DWORD *)(v5 + 4 * v7 + 32) & v6 )
    return 0;
  *(_DWORD *)(v5 + 4 * v7 + 16) |= v6;
  *(_DWORD *)(v5 + 4 * v7) |= v6;
  return 1;
}

//----- (080B8768) --------------------------------------------------------
const char *__cdecl sub_80B8768(int a1, int a2, int a3, int a4)
{
  const char *v5; // [esp+10h] [ebp-8h]
  unsigned __int16 v6; // [esp+16h] [ebp-2h]

  v6 = *(_WORD *)(*(_DWORD *)(*(_DWORD *)(a1 + 4 * a2 + 28) + 20 * a4 + 16) + 2 * a3);
  if ( v6 )
    v5 = (const char *)sub_8078896(v6);
  else
    v5 = "DEFAULT";
  return v5;
}

//----- (080B87BE) --------------------------------------------------------
int __cdecl sub_80B87BE(int a1, int a2, void *s, int a4)
{
  int v4; // ebx
  int v5; // eax
  char v7; // [esp+20h] [ebp-58h]
  signed __int16 **v8; // [esp+24h] [ebp-54h]
  char v9; // [esp+28h] [ebp-50h]
  int j; // [esp+2Ch] [ebp-4Ch]
  int v11; // [esp+30h] [ebp-48h]
  int v12; // [esp+34h] [ebp-44h]
  int v13; // [esp+38h] [ebp-40h]
  int v14; // [esp+3Ch] [ebp-3Ch]
  int v15; // [esp+40h] [ebp-38h]
  signed __int16 **v16; // [esp+44h] [ebp-34h]
  int v17; // [esp+48h] [ebp-30h]
  _DWORD *v18; // [esp+4Ch] [ebp-2Ch]
  int k; // [esp+50h] [ebp-28h]
  int v20; // [esp+54h] [ebp-24h]
  signed __int16 *v21; // [esp+58h] [ebp-20h]
  int v22; // [esp+5Ch] [ebp-1Ch]
  int i; // [esp+60h] [ebp-18h]
  int v24; // [esp+64h] [ebp-14h]
  int v25; // [esp+68h] [ebp-10h]

  memset(s, 0, 0x10u);
  v25 = *(unsigned __int8 *)(a1 + 24);
  v11 = 0;
  for ( i = 0; i < v25; ++i )
  {
    if ( *(_BYTE *)(a4 + i) >= 0 )
    {
      v16 = *(signed __int16 ***)(a1 + 4 * i + 28);
      v8 = &v16[5 * *(char *)(a4 + i) + 1];
      v21 = v8[4];
      if ( v21 )
      {
        v17 = (**v16 - 1) >> 5;
        v22 = *((signed __int16 *)v8 + 4);
        if ( v11 + v22 > 64 )
        {
          Com_Printf("ERROR: models with more than %i total surfaces\n", 64);
          for ( j = 0; j < v25; ++j )
          {
            v16 = (signed __int16 **)sub_80B8490(a1, j);
            v4 = sub_80C5482((int)v16, &v9, *(char *)(a4 + j), &v7);
            v5 = sub_80C5414((int)v16);
            Com_Printf("  model '%s' lod %i has %i surfaces\n", v5, *(char *)(a4 + j), v4);
          }
          Com_Error(1, "Max surfs exceeded - see console for details");
        }
        v24 = 0;
        while ( v24 < v22 )
        {
          *(_WORD *)(a2 + 4 * v11 + 2) = v24;
          *(_WORD *)(a2 + 4 * v11) = i;
          ++v24;
          ++v11;
        }
        v20 = *(unsigned __int8 *)(i + a1 + 68);
        v18 = v21 + 2;
        v12 = v20 >> 5;
        v14 = v20 & 0x1F;
        if ( v20 & 0x1F )
        {
          v13 = 32 - v14;
          *((_DWORD *)s + v12) |= *v18 << v14;
          v15 = v12 + 1;
          for ( k = 0; k < v17; ++k )
            *((_DWORD *)s + v15++) |= (v18[k] >> v13) | (v18[k + 1] << v14);
          *((_DWORD *)s + v15) |= v18[k] >> v13;
        }
        else
        {
          v15 = v12;
          for ( k = 0; k <= v17; ++k )
            *((_DWORD *)s + v15++) |= v18[k];
        }
      }
    }
  }
  return v11;
}

//----- (080B8AF6) --------------------------------------------------------
int __cdecl sub_80B8AF6(int a1, int a2)
{
  return sub_80B712C(a1, a2);
}

//----- (080B8B16) --------------------------------------------------------
int __cdecl sub_80B8B16(int a1, int a2)
{
  signed __int16 *v4; // [esp+14h] [ebp-24h]
  int v5; // [esp+24h] [ebp-14h]
  int v6; // [esp+2Ch] [ebp-Ch]
  int i; // [esp+30h] [ebp-8h]
  int v8; // [esp+34h] [ebp-4h]

  v8 = *(unsigned __int8 *)(a1 + 24);
  v6 = 0;
  for ( i = 0; i < v8; ++i )
  {
    v4 = **(signed __int16 ***)(a1 + 4 * i + 28);
    v5 = *v4;
    if ( a2 - v6 < v5 )
      return sub_8078896(*(unsigned __int16 *)(**((_DWORD **)v4 + 1) + 2 * (a2 - v6)));
    v6 += v5;
  }
  return 0;
}

//----- (080B8BB6) --------------------------------------------------------
int __cdecl sub_80B8BB6(int a1)
{
  return *(_DWORD *)a1;
}

//----- (080B8BC0) --------------------------------------------------------
signed int __cdecl sub_80B8BC0(int a1)
{
  int i; // [esp+14h] [ebp-4h]

  for ( i = *(unsigned __int8 *)(a1 + 24) - 1; i >= 0; --i )
  {
    if ( sub_80C2D44(*(_DWORD *)(a1 + 4 * i + 28)) )
      return 1;
  }
  return 0;
}

//----- (080B8C0C) --------------------------------------------------------
int __cdecl sub_80B8C0C(int a1)
{
  return *(unsigned __int8 *)(a1 + 25);
}

//----- (080B8C18) --------------------------------------------------------
int __cdecl sub_80B8C18(float *a1, float *a2, float *a3)
{
  int result; // eax
  float v4; // [esp+10h] [ebp-48h]
  float v5; // [esp+14h] [ebp-44h]
  float v6; // [esp+18h] [ebp-40h]
  float v7; // [esp+1Ch] [ebp-3Ch]
  float v8; // [esp+20h] [ebp-38h]
  float v9; // [esp+24h] [ebp-34h]
  float v10; // [esp+28h] [ebp-30h]
  float v11; // [esp+2Ch] [ebp-2Ch]
  float v12; // [esp+30h] [ebp-28h]
  float v13; // [esp+40h] [ebp-18h]
  float v14; // [esp+44h] [ebp-14h]
  float v15; // [esp+48h] [ebp-10h]

  sub_80B9BA0(a1, a2 + 4, &v13);
  sub_80A913C(a2, &v4);
  *a3 = v13 * v4 + v14 * v5 + v15 * v6;
  a3[1] = v13 * v7 + v14 * v8 + v15 * v9;
  result = (int)(a3 + 2);
  a3[2] = v13 * v10 + v14 * v11 + v15 * v12;
  return result;
}

//----- (080B8CA6) --------------------------------------------------------
void __cdecl sub_80B8CA6(int a1, float *a2, float *a3, int a4, int a5)
{
  long double v5; // fst7
  float v6; // ST00_4
  long double v7; // fst7
  unsigned __int16 v8; // [esp+2Eh] [ebp-25Ah]
  __int16 v9[130]; // [esp+30h] [ebp-258h]
  float v10; // [esp+134h] [ebp-154h]
  unsigned __int16 v11; // [esp+13Ah] [ebp-14Eh]
  int *v12; // [esp+13Ch] [ebp-14Ch]
  unsigned __int8 v13; // [esp+143h] [ebp-145h]
  int v14; // [esp+144h] [ebp-144h]
  signed __int16 *v15; // [esp+148h] [ebp-140h]
  unsigned __int8 *v16; // [esp+14Ch] [ebp-13Ch]
  int v17; // [esp+150h] [ebp-138h]
  unsigned int v18; // [esp+154h] [ebp-134h]
  unsigned int v19; // [esp+158h] [ebp-130h]
  int v20; // [esp+15Ch] [ebp-12Ch]
  int v21; // [esp+160h] [ebp-128h]
  int v22; // [esp+164h] [ebp-124h]
  int v23; // [esp+168h] [ebp-120h]
  int v24; // [esp+16Ch] [ebp-11Ch]
  float v25; // [esp+170h] [ebp-118h]
  int v26; // [esp+174h] [ebp-114h]
  float v27; // [esp+178h] [ebp-110h]
  char v28; // [esp+17Eh] [ebp-10Ah]
  char v29; // [esp+17Fh] [ebp-109h]
  signed __int16 *i; // [esp+180h] [ebp-108h]
  int j; // [esp+184h] [ebp-104h]
  float v32; // [esp+188h] [ebp-100h]
  float v33; // [esp+18Ch] [ebp-FCh]
  float v34; // [esp+190h] [ebp-F8h]
  int v35; // [esp+194h] [ebp-F4h]
  int v36; // [esp+198h] [ebp-F0h]
  float v37; // [esp+19Ch] [ebp-ECh]
  float v38[4]; // [esp+1A0h] [ebp-E8h]
  float v39[7]; // [esp+1B0h] [ebp-D8h]
  float v40; // [esp+1CCh] [ebp-BCh]
  int v41; // [esp+1D0h] [ebp-B8h]
  float v42; // [esp+1ECh] [ebp-9Ch]
  char v43; // [esp+1F0h] [ebp-98h]
  int v44; // [esp+200h] [ebp-88h]
  char v45; // [esp+210h] [ebp-78h]
  char v46[52]; // [esp+220h] [ebp-68h]
  float *v47; // [esp+254h] [ebp-34h]
  float *v48; // [esp+258h] [ebp-30h]
  int v49; // [esp+25Ch] [ebp-2Ch]
  float v50; // [esp+260h] [ebp-28h]
  signed __int16 *v51; // [esp+264h] [ebp-24h]
  signed __int16 **v52; // [esp+268h] [ebp-20h]
  float v53; // [esp+26Ch] [ebp-1Ch]
  int v54; // [esp+270h] [ebp-18h]
  float v55; // [esp+274h] [ebp-14h]
  float v56; // [esp+278h] [ebp-10h]

  *(_DWORD *)(a5 + 4) = 0;
  *(_WORD *)(a5 + 20) = 0;
  *(_WORD *)(a5 + 22) = 0;
  sub_80B9ADE((_DWORD *)(a5 + 8));
  sub_80B9BA0(a3, a2, (float *)&v54);
  v10 = sub_80B9CA4((float *)&v54);
  if ( v10 == 0.0 )
    return;
  v48 = (float *)sub_80B84D2(a1);
  if ( !v48 )
    return;
  v53 = 1.0 / v10;
  v19 = 2;
  v21 = *(_DWORD *)(a1 + 4);
  v16 = (unsigned __int8 *)(sub_8078896(*(unsigned __int16 *)(a1 + 16)) + 16);
  v22 = 0;
  v24 = -1;
  v23 = -1;
  v25 = 0.0;
  v47 = 0;
  v35 = *(_DWORD *)a5;
  v20 = 0;
LABEL_4:
  if ( v20 < *(unsigned __int8 *)(a1 + 24) )
  {
    v52 = *(signed __int16 ***)(a1 + 4 * v20 + 28);
    v51 = *v52;
    v12 = (int *)*((_DWORD *)v51 + 1);
    v17 = *v12;
    v49 = *v51;
    v14 = *(unsigned __int8 *)(a1 + 26) & (1 << v20);
    v26 = 0;
    while ( 1 )
    {
      if ( v26 >= v49 )
      {
        ++v20;
        goto LABEL_4;
      }
      v11 = *(unsigned __int8 *)(*((_DWORD *)v51 + 4) + v26);
      v18 = *(unsigned __int8 *)(v11 + a4);
      if ( v22 == *v16 - 1 )
      {
        v16 += 2;
        if ( v18 == 1 )
        {
          v11 = *(&v8 + *(v16 - 1));
          v18 = *(unsigned __int8 *)(v11 + a4);
        }
      }
      else if ( v18 == 1 )
      {
        if ( v26 >= v51[1] )
        {
          v11 = v9[v22 - *((unsigned __int8 *)v12 + v26 - v51[1] + 4)];
        }
        else
        {
          v13 = *(_BYTE *)(v20 + a1 + 60);
          if ( v13 == -1 )
            v8 = 0;
          else
            v8 = v9[v13];
          v11 = v8;
        }
        v18 = *(unsigned __int8 *)(v11 + a4);
      }
      v9[v22] = v11;
      if ( !v14 )
      {
        v15 = &v52[24][20 * v26];
        if ( *((float *)v15 + 9) != 0.0 && v19 <= v18 )
        {
          sub_80A9094((float *)v15 + 6, v48, (float *)&v45);
          sub_80B9BA0(a2, (float *)&v45, (float *)&v44);
          v5 = sub_80B9C70((float *)&v44, (float *)&v54);
          v42 = -v5 * v53;
          if ( v42 >= 1.0 )
          {
            sub_80B9BA0(a3, (float *)&v45, (float *)&v43);
            v50 = sub_80B9CA4((float *)&v43);
          }
          else if ( v42 <= 0.0 )
          {
            v50 = sub_80B9CA4((float *)&v44);
          }
          else
          {
            sub_80B9C1C((int)&v44, v42, (int)&v54, (int)&v41);
            v50 = sub_80B9CA4((float *)&v41);
          }
          v40 = *((float *)v15 + 9) - v50;
          if ( v40 > 0.0 )
          {
            if ( v19 != v18 || (v6 = v40 * v53, v7 = sqrtf(v6), v42 - v7 < *(float *)a5) )
            {
              sub_80B8C18(a2, v48, v39);
              sub_80B8C18(a3, v48, v38);
              v37 = 0.0;
              if ( v19 == v18 )
                v36 = *(int *)a5;
              else
                v36 = v35;
              v29 = 1;
              v28 = 1;
              v27 = -1.0;
              for ( i = v15; ; i += 6 )
              {
                for ( j = 0; j <= 2; ++j )
                {
                  v34 = (v39[j] - *(float *)&i[2 * j]) * v27;
                  v33 = (v38[j] - *(float *)&i[2 * j]) * v27;
                  if ( v34 <= 0.0 )
                  {
                    if ( v33 > 0.0 )
                    {
                      v28 = 0;
                      v32 = v34 - v33;
                      if ( v34 > *(float *)&v36 * v32 )
                      {
                        *(float *)&v36 = v34 / v32;
                        if ( v37 >= (long double)*(float *)&v36 )
                          goto LABEL_58;
                      }
                    }
                  }
                  else
                  {
                    if ( v33 > 0.0 )
                      goto LABEL_58;
                    v29 = 0;
                    v32 = v34 - v33;
                    if ( v34 > v37 * v32 )
                    {
                      v37 = v34 / v32;
                      if ( v37 >= (long double)*(float *)&v36 )
                        goto LABEL_58;
                      v25 = v27;
                      v24 = j;
                    }
                  }
                }
                if ( v27 == 1.0 )
                  break;
                v27 = 1.0;
              }
              if ( v29 )
              {
                if ( v28 && sub_80B9ABC((float *)&v54, a2) <= 0.0 )
                {
                  *(_DWORD *)a5 = 0;
                  *(_WORD *)(a5 + 20) = *(_WORD *)(v17 + 2 * v26);
                  *(_WORD *)(a5 + 22) = v11;
                  if ( *(float *)&v54 != 0.0 || v55 != 0.0 )
                  {
                    sub_80B9A9C(a2, (_DWORD *)(a5 + 8));
                    sub_80A215E((float *)(a5 + 8));
                  }
                  else
                  {
                    sub_80B9A48(v56);
                    *(_DWORD *)(a5 + 16) = COERCE_UNSIGNED_INT(0.0) ^ 0x80000000;
                  }
                  return;
                }
              }
              else
              {
                if ( v19 == v18 )
                {
                  if ( v37 >= (long double)*(float *)a5 )
                    goto LABEL_58;
                }
                else
                {
                  v19 = v18;
                }
                *(float *)a5 = v37;
                *(_WORD *)(a5 + 20) = *(_WORD *)(v17 + 2 * v26);
                *(_WORD *)(a5 + 22) = v11;
                v23 = v24;
                v47 = v48;
              }
            }
          }
        }
      }
LABEL_58:
      ++v26;
      v48 += 8;
      ++v22;
    }
  }
  if ( v47 )
  {
    sub_80A913C(v47, (float *)v46);
    sub_80B9BE4((int)&v46[12 * v23], v25, a5 + 8);
  }
}
// 80B8CA6: using guessed type __int16 var_258[130];
// 80B8CA6: using guessed type float var_D8[7];
// 80B8CA6: using guessed type float var_E8[4];
// 80B8CA6: using guessed type char var_68[52];

//----- (080B955A) --------------------------------------------------------
int __cdecl sub_80B955A(int a1, float *a2, float *a3, int a4, int a5)
{
  signed __int16 **v5; // ST3C_4
  signed int v7; // [esp+28h] [ebp-50h]
  int v8; // [esp+2Ch] [ebp-4Ch]
  signed int i; // [esp+30h] [ebp-48h]
  int v10; // [esp+34h] [ebp-44h]
  signed __int16 *v11; // [esp+38h] [ebp-40h]
  int v12; // [esp+40h] [ebp-38h]
  int v13; // [esp+44h] [ebp-34h]
  int v14; // [esp+50h] [ebp-28h]

  *(_WORD *)(a5 + 20) = 0;
  *(_WORD *)(a5 + 22) = 0;
  v12 = *(_DWORD *)a5;
  v14 = 0;
  sub_80B9ADE(&v13);
  v10 = sub_80B84D2(a1);
  if ( v10 )
  {
    for ( i = 0; i < *(unsigned __int8 *)(a1 + 24); ++i )
    {
      v5 = *(signed __int16 ***)(a1 + 4 * i + 28);
      v11 = *v5;
      v8 = **((_DWORD **)*v5 + 1);
      v7 = sub_80C33FE(*(_DWORD *)(a1 + 4 * i + 28), (int)&v12, v10, a2, a3, a4);
      if ( v7 >= 0 )
        *(_WORD *)(a5 + 20) = *(_WORD *)(v8 + 2 * v7);
      v10 += 32 * *v11;
    }
  }
  *(_DWORD *)a5 = v12;
  *(_DWORD *)(a5 + 4) = v14;
  return sub_80B9B2C(&v13, (_DWORD *)(a5 + 8));
}

//----- (080B9676) --------------------------------------------------------
int __cdecl sub_80B9676(int a1, int a2, float a3)
{
  return sub_80C5556(*(_DWORD *)(a1 + 4 * a2 + 28), a3);
}

//----- (080B9698) --------------------------------------------------------
long double __cdecl sub_80B9698(int a1)
{
  float v2; // [esp+Ch] [ebp-Ch]
  float v3; // [esp+10h] [ebp-8h]
  signed int i; // [esp+14h] [ebp-4h]

  v2 = 0.0;
  for ( i = 0; i < *(unsigned __int8 *)(a1 + 24); ++i )
  {
    v3 = sub_80C5506(*(_DWORD *)(a1 + 4 * i + 28));
    if ( v3 > (long double)v2 )
      v2 = v3;
  }
  return v2;
}

//----- (080B96F8) --------------------------------------------------------
signed int __cdecl sub_80B96F8(int a1, int a2)
{
  signed int i; // [esp+14h] [ebp-4h]

  for ( i = 0; i < *(unsigned __int8 *)(a1 + 24); ++i )
  {
    if ( a2 & sub_80C33CA(*(_DWORD *)(a1 + 4 * i + 28)) )
      return 1;
  }
  return 0;
}

//----- (080B9748) --------------------------------------------------------
int __cdecl sub_80B9748(int a1, _DWORD *a2, float *a3, int a4)
{
  int result; // eax
  float v5; // ST00_4
  float v6; // ST00_4
  float v7; // ST00_4
  float v8; // ST40_4
  float v9; // ST44_4
  float v10; // ST48_4
  float v11; // ST4C_4
  int v12; // [esp+50h] [ebp-28h]
  float v13; // [esp+54h] [ebp-24h]
  int v14; // [esp+58h] [ebp-20h]
  float v15; // [esp+5Ch] [ebp-1Ch]
  int v16; // [esp+60h] [ebp-18h]
  float v17; // [esp+64h] [ebp-14h]
  int v18; // [esp+6Ch] [ebp-Ch]

  result = sub_80B84D2(a1);
  v18 = result;
  if ( result )
  {
    v18 += 32 * a4;
    if ( a3 )
    {
      v5 = a3[1] * 0.008726646259971648;
      sub_80B9A6E(v5, (int)&v16, (int)&v17);
      v6 = *a3 * 0.008726646259971648;
      sub_80B9A6E(v6, (int)&v12, (int)&v13);
      v7 = a3[2] * 0.008726646259971648;
      sub_80B9A6E(v7, (int)&v14, (int)&v15);
      v8 = -*(float *)&v12 * *(float *)&v16;
      v9 = *(float *)&v12 * v17;
      v10 = v13 * *(float *)&v16;
      v11 = v13 * v17;
      *(float *)v18 = *(float *)&v14 * v11 + v15 * v8;
      *(float *)(v18 + 4) = v15 * v9 + *(float *)&v14 * v10;
      *(float *)(v18 + 8) = -*(float *)&v14 * v9 + v15 * v10;
      *(float *)(v18 + 12) = v15 * v11 - *(float *)&v14 * v8;
    }
    else
    {
      sub_80B9CD8((_DWORD *)v18, 0, 0, 0, 1065353216);
    }
    *(_DWORD *)(v18 + 28) = 0;
    result = sub_80B9B2C(a2, (_DWORD *)(v18 + 16));
  }
  return result;
}

//----- (080B98CC) --------------------------------------------------------
signed int __cdecl sub_80B98CC(int a1, int a2, int a3, float *a4)
{
  int v6; // [esp+14h] [ebp-4h]

  v6 = sub_80B8AF6(a1, a3);
  if ( v6 < 0 )
    return 0;
  if ( !sub_80B8616(a1, a2, v6) )
    return 0;
  sub_80B9748(a1, &unk_8145E68, a4, v6);
  return 1;
}

//----- (080B994A) --------------------------------------------------------
signed int __cdecl sub_80B994A(int a1, int a2, int a3, _DWORD *a4, float *a5)
{
  int v7; // [esp+14h] [ebp-4h]

  v7 = sub_80B8AF6(a1, a3);
  if ( v7 < 0 )
    return 0;
  if ( !sub_80B858C(a1, a2, v7) )
    return 0;
  sub_80B9748(a1, a4, a5, v7);
  return 1;
}

//----- (080B99C6) --------------------------------------------------------
signed int __cdecl sub_80B99C6(int a1, int a2, int a3, _DWORD *a4, float *a5)
{
  if ( !sub_80B858C(a1, a2, a3) )
    return 0;
  sub_80B9748(a1, a4, a5, a3);
  return 1;
}

//----- (080B9A48) --------------------------------------------------------
void __cdecl sub_80B9A48(float a1)
{
  sub_80B9D06(a1, 1.0, -1.0);
}

//----- (080B9A6E) --------------------------------------------------------
void __cdecl sub_80B9A6E(float a1, int a2, int a3)
{
  *(float *)a2 = sin(a1);
  *(float *)a3 = cos(a1);
}

//----- (080B9A9C) --------------------------------------------------------
int __cdecl sub_80B9A9C(_DWORD *a1, _DWORD *a2)
{
  int result; // eax

  *a2 = *a1;
  result = a1[1];
  a2[1] = result;
  return result;
}

//----- (080B9ABC) --------------------------------------------------------
long double __cdecl sub_80B9ABC(float *a1, float *a2)
{
  return *a1 * *a2 + a1[1] * a2[1];
}

//----- (080B9ADE) --------------------------------------------------------
int __cdecl sub_80B9ADE(_DWORD *a1)
{
  int result; // eax

  *a1 = 0;
  a1[1] = 0;
  result = 0;
  a1[2] = 0;
  return result;
}

//----- (080B9B08) --------------------------------------------------------
int __cdecl sub_80B9B08(_DWORD *a1, int a2, int a3, int a4)
{
  int result; // eax

  *a1 = a2;
  a1[1] = a3;
  result = a4;
  a1[2] = a4;
  return result;
}

//----- (080B9B2C) --------------------------------------------------------
int __cdecl sub_80B9B2C(_DWORD *a1, _DWORD *a2)
{
  int result; // eax

  *a2 = *a1;
  a2[1] = a1[1];
  result = a1[2];
  a2[2] = result;
  return result;
}

//----- (080B9B5C) --------------------------------------------------------
int __cdecl sub_80B9B5C(float *a1, float *a2, float *a3)
{
  int result; // eax

  *a3 = *a1 + *a2;
  a3[1] = a1[1] + a2[1];
  result = (int)(a1 + 2);
  a3[2] = a1[2] + a2[2];
  return result;
}

//----- (080B9BA0) --------------------------------------------------------
int __cdecl sub_80B9BA0(float *a1, float *a2, float *a3)
{
  int result; // eax

  *a3 = *a1 - *a2;
  a3[1] = a1[1] - a2[1];
  result = (int)(a1 + 2);
  a3[2] = a1[2] - a2[2];
  return result;
}

//----- (080B9BE4) --------------------------------------------------------
int __cdecl sub_80B9BE4(int a1, float a2, int a3)
{
  int result; // eax

  *(float *)a3 = a2 * *(float *)a1;
  *(float *)(a3 + 4) = a2 * *(float *)(a1 + 4);
  result = a1 + 8;
  *(float *)(a3 + 8) = a2 * *(float *)(a1 + 8);
  return result;
}

//----- (080B9C1C) --------------------------------------------------------
int __cdecl sub_80B9C1C(int a1, float a2, int a3, int a4)
{
  int result; // eax

  *(float *)a4 = a2 * *(float *)a3 + *(float *)a1;
  *(float *)(a4 + 4) = a2 * *(float *)(a3 + 4) + *(float *)(a1 + 4);
  result = a3 + 8;
  *(float *)(a4 + 8) = a2 * *(float *)(a3 + 8) + *(float *)(a1 + 8);
  return result;
}

//----- (080B9C70) --------------------------------------------------------
long double __cdecl sub_80B9C70(float *a1, float *a2)
{
  return *a1 * *a2 + a1[1] * a2[1] + a1[2] * a2[2];
}

//----- (080B9CA4) --------------------------------------------------------
long double __cdecl sub_80B9CA4(float *a1)
{
  return *a1 * *a1 + a1[1] * a1[1] + a1[2] * a1[2];
}

//----- (080B9CD8) --------------------------------------------------------
int __cdecl sub_80B9CD8(_DWORD *a1, int a2, int a3, int a4, int a5)
{
  int result; // eax

  *a1 = a2;
  a1[1] = a3;
  a1[2] = a4;
  result = a5;
  a1[3] = a5;
  return result;
}

//----- (080B9D06) --------------------------------------------------------
long double __cdecl sub_80B9D06(float a1, float a2, float a3)
{
  float v4; // [esp+0h] [ebp-4h]

  if ( a1 < 0.0 )
    v4 = a3;
  else
    v4 = a2;
  return v4;
}

//----- (080B9D30) --------------------------------------------------------
long double __cdecl sub_80B9D30(float *a1)
{
  return *a1 * *a1 + a1[1] * a1[1] + a1[2] * a1[2] + a1[3] * a1[3];
}

//----- (080B9D76) --------------------------------------------------------
signed int __cdecl sub_80B9D76(signed int a1)
{
  signed int result; // eax
  float v2; // [esp+4h] [ebp-4h]

  v2 = sub_80B9D30((float *)a1);
  if ( v2 == 0.0 )
  {
    *(_DWORD *)(a1 + 12) = 1065353216;
    result = 0x40000000;
    *(_DWORD *)(a1 + 28) = 0x40000000;
  }
  else
  {
    result = a1;
    *(float *)(a1 + 28) = 2.0 / v2;
  }
  return result;
}

//----- (080B9DC6) --------------------------------------------------------
float __usercall sub_80B9DC6@<eax>(float *a1, float *a2)
{
  float result; // eax
  float v3; // [esp+10h] [ebp-48h]
  float v4; // [esp+14h] [ebp-44h]
  float v5; // [esp+18h] [ebp-40h]
  float v6; // [esp+1Ch] [ebp-3Ch]
  float v7; // [esp+20h] [ebp-38h]
  float v8; // [esp+24h] [ebp-34h]
  float v9; // [esp+28h] [ebp-30h]
  float v10; // [esp+2Ch] [ebp-2Ch]
  float v11; // [esp+30h] [ebp-28h]
  float v12; // [esp+48h] [ebp-10h]
  float v13; // [esp+4Ch] [ebp-Ch]

  sub_80A913C(a2, &v3);
  v12 = *a1 * v3 + a1[1] * v6 + a1[2] * v9 + a2[4];
  v13 = *a1 * v4 + a1[1] * v7 + a1[2] * v10 + a2[5];
  a1[2] = *a1 * v5 + a1[1] * v8 + a1[2] * v11 + a2[6];
  *a1 = v12;
  result = v13;
  a1[1] = v13;
  return result;
}

//----- (080B9E7A) --------------------------------------------------------
float __usercall sub_80B9E7A@<eax>(float *a1, float *a2)
{
  float v2; // ST00_4
  float v3; // ST04_4
  float v4; // ST08_4
  float result; // eax

  v2 = *a1 * a2[3] + a1[3] * *a2 + a1[2] * a2[1] - a1[1] * a2[2];
  v3 = a1[1] * a2[3] - a1[2] * *a2 + a1[3] * a2[1] + *a1 * a2[2];
  v4 = a1[2] * a2[3] + a1[1] * *a2 - *a1 * a2[1] + a1[3] * a2[2];
  a1[3] = a1[3] * a2[3] - *a1 * *a2 - a1[1] * a2[1] - a1[2] * a2[2];
  *a1 = v2;
  a1[1] = v3;
  result = v4;
  a1[2] = v4;
  return result;
}

//----- (080B9FB2) --------------------------------------------------------
float __usercall sub_80B9FB2@<eax>(float *a1, float *a2)
{
  float v2; // ST00_4
  float v3; // ST04_4
  float v4; // ST08_4
  float result; // eax

  v2 = *a1 * a2[3] + a1[3] * *a2 + a1[2] * a2[1] - a1[1] * a2[2];
  v3 = a1[1] * a2[3] - a1[2] * *a2 + a1[3] * a2[1] + *a1 * a2[2];
  v4 = a1[2] * a2[3] + a1[1] * *a2 - *a1 * a2[1] + a1[3] * a2[2];
  a2[3] = a1[3] * a2[3] - *a1 * *a2 - a1[1] * a2[1] - a1[2] * a2[2];
  *a2 = v2;
  a2[1] = v3;
  result = v4;
  a2[2] = v4;
  return result;
}

//----- (080BA0EC) --------------------------------------------------------
bool XAnimInit()
{
  bool result; // al
  signed int i; // [esp+24h] [ebp-4h]

  for ( i = 0; i <= 4095; ++i )
  {
    word_8527A88[20 * i] = (i + 4095) % 4096;
    word_8527A8A[20 * i] = (i + 1) % 4096;
  }
  dword_8527A8C[0] = 0;
  dword_8527A90[0] = 0;
  word_8527A94 = 0;
  word_8527A96[0] = 0;
  dword_854FA80 = sub_8079290("end", 0);
  result = *(_DWORD *)(com_developer + 8) != 0;
  byte_85500A4 = *(_DWORD *)(com_developer + 8) != 0;
  return result;
}
// 819EEFC: using guessed type int com_developer;
// 8527A88: using guessed type __int16 word_8527A88[];
// 8527A8A: using guessed type __int16 word_8527A8A[];
// 8527A8C: using guessed type int dword_8527A8C[];
// 8527A90: using guessed type int dword_8527A90[];
// 8527A94: using guessed type __int16 word_8527A94;
// 8527A96: using guessed type __int16 word_8527A96[];
// 85500A4: using guessed type char byte_85500A4;

//----- (080BA21E) --------------------------------------------------------
int XAnimShutdown()
{
  int result; // eax

  if ( dword_854FA80 )
  {
    result = sub_80796A2(dword_854FA80);
    dword_854FA80 = 0;
  }
  return result;
}

//----- (080BA246) --------------------------------------------------------
void sub_80BA246()
{
  dword_854FA80 = 0;
}

//----- (080BA256) --------------------------------------------------------
int __cdecl sub_80BA256(int a1)
{
  int result; // eax
  __int16 v2; // [esp+6h] [ebp-12h]
  unsigned __int16 *j; // [esp+8h] [ebp-10h]
  int v4; // [esp+Ch] [ebp-Ch]
  int i; // [esp+10h] [ebp-8h]
  int v6; // [esp+14h] [ebp-4h]

  v6 = *(_DWORD *)(a1 + 16);
  v4 = *(signed __int16 *)(a1 + 14);
  for ( i = 0; i < v4; ++i )
    sub_80796A2(*(unsigned __int16 *)(v6 + 2 * i));
  v2 = 0;
  for ( j = *(unsigned __int16 **)(a1 + 28); ; j += 4 )
  {
    result = v2;
    if ( v2 >= (signed int)*(unsigned __int8 *)(a1 + 12) )
      break;
    sub_80796A2(*j);
    ++v2;
  }
  return result;
}

//----- (080BA2DE) --------------------------------------------------------
int __cdecl sub_80BA2DE(char *s2)
{
  return sub_80A97A6(5, s2);
}

//----- (080BA2FA) --------------------------------------------------------
int __cdecl sub_80BA2FA(const void *a1, int (__cdecl *a2)(signed int))
{
  int v3; // [esp+8h] [ebp-20h]
  __int16 v4; // [esp+Eh] [ebp-1Ah]
  unsigned __int16 *v5; // [esp+10h] [ebp-18h]
  int v6; // [esp+14h] [ebp-14h]
  int i; // [esp+18h] [ebp-10h]
  int v8; // [esp+1Ch] [ebp-Ch]

  v3 = a2(44);
  qmemcpy((void *)v3, a1, 0x2Cu);
  v8 = *(_DWORD *)(v3 + 16);
  v6 = *(signed __int16 *)(v3 + 14);
  for ( i = 0; i < v6; ++i )
    sub_807951E(*(unsigned __int16 *)(v8 + 2 * i));
  v4 = 0;
  v5 = *(unsigned __int16 **)(v3 + 28);
  while ( v4 < (signed int)*(unsigned __int8 *)(v3 + 12) )
  {
    sub_807951E(*v5);
    ++v4;
    v5 += 4;
  }
  return v3;
}

//----- (080BA3AE) --------------------------------------------------------
unsigned __int16 *__cdecl sub_80BA3AE(char *src, int a2)
{
  unsigned __int16 *v4; // [esp+1Ch] [ebp-Ch]
  int v5; // [esp+20h] [ebp-8h]
  unsigned __int16 *v6; // [esp+20h] [ebp-8h]

  v5 = sub_80BA2DE(src);
  if ( v5 )
    return (unsigned __int16 *)v5;
  v6 = sub_80C19AE((int)src, (int (__cdecl *)(int))a2);
  if ( !v6 )
  {
    Com_Printf("^3WARNING: Couldn't find xanim '%s', using default xanim '%s' instead\n", src, "void");
    v4 = (unsigned __int16 *)sub_80BA2DE("void");
    if ( !v4 )
    {
      v4 = sub_80C19AE((int)"void", (int (__cdecl *)(int))a2);
      if ( !v4 )
        Com_Error(1, &byte_8148E87, "void");
      sub_80A981E(5, "void", (int)v4, a2);
    }
    v6 = (unsigned __int16 *)sub_80BA2FA(v4, (int (__cdecl *)(signed int))a2);
    *((_BYTE *)v6 + 40) = 1;
  }
  *((_DWORD *)v6 + 9) = sub_80A981E(5, src, (int)v6, a2);
  return v6;
}

//----- (080BA4D8) --------------------------------------------------------
char *__cdecl sub_80BA4D8(int a1, int a2, char *s)
{
  char *result; // eax
  size_t v4; // eax
  char *dest; // ST0C_4
  int v6; // [esp+14h] [ebp-4h]

  v6 = sub_80BA2DE(s);
  if ( !v6 )
    Com_Error(1, &byte_8148EA0, s);
  *(_WORD *)(a1 + 8 * a2 + 12) = 0;
  *(_DWORD *)(a1 + 8 * a2 + 16) = v6;
  result = (char *)a1;
  if ( *(_DWORD *)(a1 + 8) )
  {
    v4 = strlen(s);
    dest = (char *)Z_MallocInternal(v4 + 1);
    strcpy(dest, s);
    result = dest;
    *(_DWORD *)(*(_DWORD *)(a1 + 8) + 4 * a2) = dest;
  }
  return result;
}

//----- (080BA57A) --------------------------------------------------------
char *__cdecl sub_80BA57A(int a1, int a2, char *s, int a4, int a5, int a6)
{
  _WORD *v6; // ST10_4
  char *result; // eax
  size_t v8; // eax
  char *dest; // ST0C_4
  unsigned int i; // [esp+14h] [ebp-4h]

  v6 = (_WORD *)(a1 + 8 * a2 + 12);
  *v6 = a5;
  v6[2] = a6;
  v6[3] = a4;
  for ( i = 0; i < a5; ++i )
    *(_WORD *)(a1 + 8 * (i + *(unsigned __int16 *)(a1 + 8 * a2 + 18)) + 14) = a2;
  result = (char *)a1;
  if ( *(_DWORD *)(a1 + 8) )
  {
    v8 = strlen(s);
    dest = (char *)Z_MallocInternal(v8 + 1);
    strcpy(dest, s);
    result = dest;
    *(_DWORD *)(*(_DWORD *)(a1 + 8) + 4 * a2) = dest;
  }
  return result;
}

//----- (080BA626) --------------------------------------------------------
char **__cdecl sub_80BA626(char *s, int a2, int a3)
{
  size_t v3; // eax
  char *dest; // ST1C_4
  char **v6; // [esp+20h] [ebp-8h]

  v6 = (char **)((int (__cdecl *)(int))a3)(8 * a2 + 12);
  v6[1] = (char *)a2;
  if ( byte_85500A4 )
  {
    v3 = strlen(s);
    dest = (char *)Z_MallocInternal(v3 + 1);
    strcpy(dest, s);
    *v6 = dest;
    v6[2] = (char *)Z_MallocInternal(4 * a2);
  }
  if ( sub_80A97DE((size_t)v6) )
    sub_80A98A0(6, (int)v6, (int (__cdecl *)(signed int))a3);
  return v6;
}
// 85500A4: using guessed type char byte_85500A4;

//----- (080BA6D0) --------------------------------------------------------
int __cdecl sub_80BA6D0(int a1, int (__cdecl *a2)(int, int))
{
  int v2; // ST14_4

  v2 = 8 * *(_DWORD *)(a1 + 4) + 12;
  sub_80BA704(a1);
  return a2(a1, v2);
}

//----- (080BA704) --------------------------------------------------------
int __cdecl sub_80BA704(int a1)
{
  int result; // eax
  unsigned int i; // [esp+4h] [ebp-4h]

  if ( *(_DWORD *)a1 )
  {
    Z_FreeInternal(*(void **)a1);
    *(_DWORD *)a1 = 0;
  }
  result = a1;
  if ( *(_DWORD *)(a1 + 8) )
  {
    for ( i = 0; i < *(_DWORD *)(a1 + 4); ++i )
    {
      if ( *(_DWORD *)(*(_DWORD *)(a1 + 8) + 4 * i) )
      {
        Z_FreeInternal(*(void **)(*(_DWORD *)(a1 + 8) + 4 * i));
        *(_DWORD *)(*(_DWORD *)(a1 + 8) + 4 * i) = 0;
      }
    }
    Z_FreeInternal(*(void **)(a1 + 8));
    result = a1;
    *(_DWORD *)(a1 + 8) = 0;
  }
  return result;
}

//----- (080BA7BC) --------------------------------------------------------
int __cdecl sub_80BA7BC(int a1)
{
  return 5 * a1 + 9;
}

//----- (080BA7E4) --------------------------------------------------------
_DWORD *__cdecl sub_80BA7E4(int a1, int (__cdecl *a2)(int))
{
  int n; // ST10_4
  _DWORD *s; // ST14_4

  n = sub_80BA7BC(*(_DWORD *)(a1 + 4));
  s = (_DWORD *)a2(n);
  memset(s, 0, n);
  *s = a1;
  return s;
}

//----- (080BA836) --------------------------------------------------------
int __cdecl sub_80BA836(_DWORD *a1, int (__cdecl *a2)(_DWORD *, int))
{
  int result; // eax
  int v3; // ST14_4
  int v4; // [esp+10h] [ebp-8h]

  v4 = *(_DWORD *)(*a1 + 4);
  result = sub_80BFA1E(a1);
  if ( a2 )
  {
    v3 = sub_80BA7BC(v4);
    result = a2(a1, v3);
  }
  return result;
}

//----- (080BA87C) --------------------------------------------------------
int __cdecl sub_80BA87C(int a1)
{
  return *(_DWORD *)a1;
}

//----- (080BA886) --------------------------------------------------------
int __cdecl sub_80BA886(int a1, int a2, int a3)
{
  int v3; // ST40_4
  signed __int16 *v4; // ST18_4
  signed int i; // [esp+24h] [ebp-C4h]
  int k; // [esp+24h] [ebp-C4h]
  int v8; // [esp+30h] [ebp-B8h]
  int v9; // [esp+34h] [ebp-B4h]
  int v10; // [esp+38h] [ebp-B0h]
  int v11; // [esp+3Ch] [ebp-ACh]
  int v12; // [esp+44h] [ebp-A4h]
  int v13; // [esp+48h] [ebp-A0h]
  int j; // [esp+4Ch] [ebp-9Ch]
  int l; // [esp+4Ch] [ebp-9Ch]
  int s2[4]; // [esp+50h] [ebp-98h]
  char v17[136]; // [esp+60h] [ebp-88h]

  v3 = *(_DWORD *)(a1 + 4);
  v9 = *(_DWORD *)(v3 + 16);
  v11 = *(signed __int16 *)(v3 + 14);
  for ( i = 0; i <= 3; ++i )
    s2[i] = 0;
  for ( j = v11 - 1; j >= 0; --j )
    v17[j] = 127;
  v13 = 0;
  for ( k = 0; k < a3; ++k )
  {
    v4 = **(signed __int16 ***)(a2 + 4 * k);
    v8 = **((_DWORD **)v4 + 1);
    v10 = *v4;
    v12 = 0;
    while ( v12 < v10 )
    {
      for ( l = v11 - 1; l >= 0; --l )
      {
        if ( *(unsigned __int16 *)(v8 + 2 * v12) == *(unsigned __int16 *)(v9 + 2 * l) )
        {
          if ( v17[l] == 127 )
          {
            v17[l] = v13;
            s2[v13 >> 5] |= 1 << (v13 & 0x1F);
          }
          break;
        }
      }
      ++v12;
      ++v13;
    }
  }
  return sub_8078DEC(s2, 0, v11 + 16);
}
// 80BA886: using guessed type int s2[4];
// 80BA886: using guessed type char var_88[136];

//----- (080BAACE) --------------------------------------------------------
__int16 __cdecl sub_80BAACE(float a1, signed int a2, int a3)
{
  __int16 result; // ax
  __int16 v4; // [esp+2h] [ebp-2h]

  *(float *)a3 = a1;
  *(_DWORD *)(a3 + 4) = a2;
  *(float *)(a3 + 8) = (long double)a2 * a1;
  result = v4 | 0xC00;
  *(_DWORD *)(a3 + 12) = (signed int)*(float *)(a3 + 8);
  return result;
}

//----- (080BAB16) --------------------------------------------------------
int __cdecl sub_80BAB16(int a1, float a2, int a3)
{
  int v4; // [esp+10h] [ebp-8h]

  if ( *(_WORD *)a1 )
    v4 = 4 * *(unsigned __int16 *)a1 + *(_DWORD *)(a1 + 4);
  else
    v4 = a1 + 4;
  return sub_80C150E(a3, a2, v4, a3);
}

//----- (080BAB6C) --------------------------------------------------------
int __cdecl sub_80BAB6C(int a1, float a2, int a3)
{
  int result; // eax

  if ( *(_WORD *)a1 )
    result = sub_80C1544(a3, a2, *(_DWORD *)(a1 + 4) + 8 * *(unsigned __int16 *)a1, a3);
  else
    result = sub_80C1544(a3, a2, a1 + 4, a3);
  return result;
}

//----- (080BABCE) --------------------------------------------------------
int __cdecl sub_80BABCE(int a1, float a2, int a3)
{
  int result; // eax

  if ( *(_WORD *)a1 )
    result = sub_80C11C4(a3, a2, *(_DWORD *)(a1 + 4) + 12 * *(unsigned __int16 *)a1, a3);
  else
    result = sub_80C11C4(a3, a2, a1 + 4, a3);
  return result;
}

//----- (080BAC36) --------------------------------------------------------
int __cdecl sub_80BAC36(int a1, int a2, float a3, int a4, int a5)
{
  int result; // eax
  int v6; // [esp+Ch] [ebp-1Ch]
  int v7; // [esp+10h] [ebp-18h]
  int v8; // [esp+14h] [ebp-14h]
  float v9; // [esp+18h] [ebp-10h]
  int *v10; // [esp+1Ch] [ebp-Ch]
  int i; // [esp+20h] [ebp-8h]
  int v12; // [esp+24h] [ebp-4h]

  v9 = a3 * 0.000030518509;
  v6 = *(_DWORD *)(a1 + 20);
  v7 = *(signed __int16 *)(a1 + 14);
  for ( i = 0; ; ++i )
  {
    result = i;
    if ( i >= v7 )
      break;
    v8 = *(unsigned __int8 *)(a2 + i);
    if ( !((*(_DWORD *)(a5 + 4 * (v8 >> 5)) >> (v8 & 0x1F)) & 1) )
    {
      v12 = a4 + 32 * v8;
      v10 = (int *)(*(_DWORD *)(a1 + 24) + 8 * i);
      if ( (*(char *)((i >> 3) + v6) >> (i & 7)) & 1 )
      {
        if ( v10[1] )
          sub_80BAB16(v10[1], v9, v12 + 8);
        else
          *(float *)(v12 + 12) = *(float *)(v12 + 12) + a3;
      }
      else
      {
        sub_80BAB6C(v10[1], v9, v12);
      }
      if ( *v10 )
        sub_80BABCE(*v10, a3, v12 + 16);
      *(float *)(v12 + 28) = *(float *)(v12 + 28) + a3;
    }
  }
  return result;
}

//----- (080BAD76) --------------------------------------------------------
int __cdecl sub_80BAD76(int a1, _DWORD *a2, int a3)
{
  int result; // eax
  int v4; // [esp+4h] [ebp-4h]

  v4 = 0;
  while ( 1 )
  {
    result = *(unsigned __int8 *)(a1 + 25);
    if ( v4 >= result )
      break;
    if ( !((*(_DWORD *)(a3 + 4 * (v4 >> 5) + 16400) >> (v4 & 0x1F)) & 1) )
    {
      sub_80C1218(a2);
      a2[7] = 0;
      sub_80C1040(a2 + 4);
    }
    ++v4;
    a2 += 8;
  }
  return result;
}

//----- (080BADE6) --------------------------------------------------------
int __cdecl sub_80BADE6(unsigned __int16 *a1, float *a2)
{
  signed __int16 *v3; // [esp+10h] [ebp-8h]

  if ( *a1 )
    v3 = (signed __int16 *)(4 * *a1 + *((_DWORD *)a1 + 1));
  else
    v3 = (signed __int16 *)(a1 + 2);
  return sub_80C16B4(v3, a2);
}

//----- (080BAE2E) --------------------------------------------------------
int __cdecl sub_80BAE2E(int a1, int a2)
{
  int result; // eax

  if ( *(_DWORD *)(a1 + 4) )
    return sub_80BADE6(*(unsigned __int16 **)(a1 + 4), (float *)a2);
  *(_DWORD *)a2 = 0;
  result = 1191181824;
  *(_DWORD *)(a2 + 4) = 1191181824;
  return result;
}

//----- (080BAE6E) --------------------------------------------------------
int __cdecl sub_80BAE6E(unsigned __int16 *a1, _DWORD *a2)
{
  int result; // eax

  if ( *a1 )
    result = sub_80C106A((_DWORD *)(*((_DWORD *)a1 + 1) + 12 * *a1), a2);
  else
    result = sub_80C106A((_DWORD *)a1 + 1, a2);
  return result;
}

//----- (080BAEBA) --------------------------------------------------------
int __cdecl sub_80BAEBA(unsigned __int16 **a1, _DWORD *a2)
{
  int result; // eax

  if ( *a1 )
    result = sub_80BAE6E(*a1, a2);
  else
    result = sub_80C1040(a2);
  return result;
}

//----- (080BAEEC) --------------------------------------------------------
int __cdecl sub_80BAEEC(int a1, int a2, signed int a3, int *a4, float *a5)
{
  int result; // eax
  int v6; // [esp+4h] [ebp-10h]
  int v7; // [esp+4h] [ebp-10h]
  signed int v8; // [esp+8h] [ebp-Ch]
  int v9; // [esp+Ch] [ebp-8h]
  int v10; // [esp+10h] [ebp-4h]
  int v11; // [esp+10h] [ebp-4h]

  v9 = (signed int)((long double)a3 * *(float *)a1);
  v8 = *(_DWORD *)(a1 + 12);
  if ( v8 >= *(unsigned __int8 *)(a2 + v9) )
  {
    if ( v8 >= *(unsigned __int8 *)(a2 + v9 + 1) )
    {
      v11 = v9 + 1;
      v7 = a3;
      do
      {
        while ( 1 )
        {
          v9 = (v7 + v11) / 2;
          if ( v8 < *(unsigned __int8 *)(a2 + v9) )
            break;
          if ( v8 < *(unsigned __int8 *)(a2 + v9 + 1) )
            goto LABEL_15;
          v11 = v9 + 1;
        }
        v7 = (v7 + v11++) / 2;
      }
      while ( v8 >= *(unsigned __int8 *)(a2 + v11) );
      v9 = v11 - 1;
    }
  }
  else
  {
    v10 = 0;
    v6 = (signed int)((long double)a3 * *(float *)a1);
    while ( 1 )
    {
      while ( 1 )
      {
        v9 = (v6 + v10) / 2;
        if ( v8 >= *(unsigned __int8 *)(a2 + v9) )
          break;
        v6 = (v6 + v10) / 2;
      }
      if ( v8 < *(unsigned __int8 *)(a2 + v9 + 1) )
        break;
      v10 = v9 + 1;
      if ( v8 >= *(unsigned __int8 *)(a2 + --v6) )
      {
        v9 = v6;
        break;
      }
    }
  }
LABEL_15:
  *a5 = (*(float *)(a1 + 8) - (long double)*(unsigned __int8 *)(a2 + v9))
      / (long double)(*(unsigned __int8 *)(a2 + v9 + 1) - *(unsigned __int8 *)(a2 + v9));
  result = v9;
  *a4 = v9;
  return result;
}

//----- (080BB060) --------------------------------------------------------
int __cdecl sub_80BB060(int a1, int a2, signed int a3, int *a4, float *a5)
{
  int result; // eax

  if ( a3 < *(_DWORD *)(a1 + 4) )
    return sub_80BAEEC(a1, a2, a3, a4, a5);
  *a5 = *(float *)(a1 + 8) - (long double)*(signed int *)(a1 + 12);
  result = *(_DWORD *)(a1 + 12);
  *a4 = result;
  return result;
}

//----- (080BB0BA) --------------------------------------------------------
int __cdecl sub_80BB0BA(signed __int16 *a1, float a2, signed int a3, float *a4)
{
  float v5; // [esp+28h] [ebp-20h]
  int v6; // [esp+2Ch] [ebp-1Ch]
  char v7; // [esp+30h] [ebp-18h]

  if ( !*a1 )
    return sub_80C16B4(a1 + 2, a4);
  sub_80BAACE(a2, a3, (int)&v7);
  sub_80BB060((int)&v7, (int)(a1 + 4), (unsigned __int16)*a1, &v6, &v5);
  return sub_80C1350(*((_DWORD *)a1 + 1) + 4 * v6, *((_DWORD *)a1 + 1) + 4 * v6 + 4, v5, (int)a4);
}

//----- (080BB15E) --------------------------------------------------------
int __cdecl sub_80BB15E(int a1, float a2, signed int a3, int a4)
{
  int result; // eax

  if ( *(_DWORD *)(a1 + 4) )
    return sub_80BB0BA(*(signed __int16 **)(a1 + 4), a2, a3, (float *)a4);
  *(_DWORD *)a4 = 0;
  result = 1191181824;
  *(_DWORD *)(a4 + 4) = 1191181824;
  return result;
}

//----- (080BB1AC) --------------------------------------------------------
int __cdecl sub_80BB1AC(unsigned __int16 *a1, float a2, signed int a3, _DWORD *a4)
{
  float v5; // [esp+28h] [ebp-20h]
  int v6; // [esp+2Ch] [ebp-1Ch]
  char v7; // [esp+30h] [ebp-18h]

  if ( !*a1 )
    return sub_80C106A((_DWORD *)a1 + 1, a4);
  sub_80BAACE(a2, a3, (int)&v7);
  sub_80BB060((int)&v7, (int)(a1 + 4), *a1, &v6, &v5);
  return sub_80C1122(*((_DWORD *)a1 + 1) + 12 * v6, *((_DWORD *)a1 + 1) + 12 * v6 + 12, v5, (int)a4);
}

//----- (080BB25E) --------------------------------------------------------
int __cdecl sub_80BB25E(unsigned __int16 **a1, float a2, signed int a3, _DWORD *a4)
{
  int result; // eax

  if ( *a1 )
    result = sub_80BB1AC(*a1, a2, a3, a4);
  else
    result = sub_80C1040(a4);
  return result;
}

//----- (080BB29E) --------------------------------------------------------
int __cdecl sub_80BB29E(int a1, int a2, signed int a3, int *a4, float *a5)
{
  int result; // eax
  int v6; // [esp+4h] [ebp-14h]
  int v7; // [esp+4h] [ebp-14h]
  signed int v8; // [esp+8h] [ebp-10h]
  int v9; // [esp+Ch] [ebp-Ch]
  int v10; // [esp+10h] [ebp-8h]
  int v11; // [esp+10h] [ebp-8h]

  v9 = (signed int)((long double)a3 * *(float *)a1);
  v8 = *(_DWORD *)(a1 + 12);
  if ( v8 >= *(unsigned __int16 *)(a2 + 2 * v9) )
  {
    if ( v8 >= *(unsigned __int16 *)(a2 + 2 * v9 + 2) )
    {
      v11 = v9 + 1;
      v7 = a3;
      do
      {
        while ( 1 )
        {
          v9 = (v7 + v11) / 2;
          if ( v8 < *(unsigned __int16 *)(a2 + 2 * v9) )
            break;
          if ( v8 < *(unsigned __int16 *)(a2 + 2 * v9 + 2) )
            goto LABEL_15;
          v11 = v9 + 1;
        }
        v7 = (v7 + v11++) / 2;
      }
      while ( v8 >= *(unsigned __int16 *)(a2 + 2 * v11) );
      v9 = v11 - 1;
    }
  }
  else
  {
    v10 = 0;
    v6 = (signed int)((long double)a3 * *(float *)a1);
    while ( 1 )
    {
      while ( 1 )
      {
        v9 = (v6 + v10) / 2;
        if ( v8 >= *(unsigned __int16 *)(a2 + 2 * v9) )
          break;
        v6 = (v6 + v10) / 2;
      }
      if ( v8 < *(unsigned __int16 *)(a2 + 2 * v9 + 2) )
        break;
      v10 = v9 + 1;
      if ( v8 >= *(unsigned __int16 *)(a2 + 2 * --v6) )
      {
        v9 = v6;
        break;
      }
    }
  }
LABEL_15:
  *a5 = (*(float *)(a1 + 8) - (long double)*(unsigned __int16 *)(a2 + 2 * v9))
      / (long double)(*(unsigned __int16 *)(a2 + 2 * v9 + 2) - *(unsigned __int16 *)(a2 + 2 * v9));
  result = v9;
  *a4 = v9;
  return result;
}

//----- (080BB444) --------------------------------------------------------
int __cdecl sub_80BB444(int a1, int a2, signed int a3, int *a4, float *a5)
{
  int result; // eax

  if ( a3 < *(_DWORD *)(a1 + 4) )
    return sub_80BB29E(a1, a2, a3, a4, a5);
  *a5 = *(float *)(a1 + 8) - (long double)*(signed int *)(a1 + 12);
  result = *(_DWORD *)(a1 + 12);
  *a4 = result;
  return result;
}

//----- (080BB49E) --------------------------------------------------------
int __cdecl sub_80BB49E(signed __int16 *a1, float a2, signed int a3, float *a4)
{
  float v5; // [esp+28h] [ebp-20h]
  int v6; // [esp+2Ch] [ebp-1Ch]
  char v7; // [esp+30h] [ebp-18h]

  if ( !*a1 )
    return sub_80C16B4(a1 + 2, a4);
  sub_80BAACE(a2, a3, (int)&v7);
  sub_80BB444((int)&v7, (int)(a1 + 4), (unsigned __int16)*a1, &v6, &v5);
  return sub_80C1350(*((_DWORD *)a1 + 1) + 4 * v6, *((_DWORD *)a1 + 1) + 4 * v6 + 4, v5, (int)a4);
}

//----- (080BB542) --------------------------------------------------------
int __cdecl sub_80BB542(int a1, float a2, signed int a3, int a4)
{
  int result; // eax

  if ( *(_DWORD *)(a1 + 4) )
    return sub_80BB49E(*(signed __int16 **)(a1 + 4), a2, a3, (float *)a4);
  *(_DWORD *)a4 = 0;
  result = 1191181824;
  *(_DWORD *)(a4 + 4) = 1191181824;
  return result;
}

//----- (080BB590) --------------------------------------------------------
int __cdecl sub_80BB590(unsigned __int16 *a1, float a2, signed int a3, _DWORD *a4)
{
  float v5; // [esp+28h] [ebp-20h]
  int v6; // [esp+2Ch] [ebp-1Ch]
  char v7; // [esp+30h] [ebp-18h]

  if ( !*a1 )
    return sub_80C106A((_DWORD *)a1 + 1, a4);
  sub_80BAACE(a2, a3, (int)&v7);
  sub_80BB444((int)&v7, (int)(a1 + 4), *a1, &v6, &v5);
  return sub_80C1122(*((_DWORD *)a1 + 1) + 12 * v6, *((_DWORD *)a1 + 1) + 12 * v6 + 12, v5, (int)a4);
}

//----- (080BB642) --------------------------------------------------------
int __cdecl sub_80BB642(unsigned __int16 **a1, float a2, signed int a3, _DWORD *a4)
{
  int result; // eax

  if ( *a1 )
    result = sub_80BB590(*a1, a2, a3, a4);
  else
    result = sub_80C1040(a4);
  return result;
}

//----- (080BB682) --------------------------------------------------------
int __cdecl sub_80BB682(int a1, float a2, int a3, int a4)
{
  int result; // eax
  char v5; // [esp+1Bh] [ebp-Dh]
  unsigned __int16 **v6; // [esp+1Ch] [ebp-Ch]
  signed int v7; // [esp+24h] [ebp-4h]

  v6 = *(unsigned __int16 ***)(a1 + 32);
  v7 = *(unsigned __int16 *)a1;
  v5 = 0;
  if ( a2 == 1.0 || !*(_WORD *)a1 )
    v5 = 1;
  if ( v5 )
  {
    sub_80BAE2E((int)v6, a3);
    result = sub_80BAEBA(v6, (_DWORD *)a4);
  }
  else if ( v7 > 255 )
  {
    sub_80BB542((int)v6, a2, v7, a3);
    result = sub_80BB642(v6, a2, v7, (_DWORD *)a4);
  }
  else
  {
    sub_80BB15E((int)v6, a2, v7, a3);
    result = sub_80BB25E(v6, a2, v7, (_DWORD *)a4);
  }
  return result;
}

//----- (080BB77C) --------------------------------------------------------
void __cdecl sub_80BB77C(float *a1, float *a2)
{
  float v2; // ST04_4
  float v3; // ST0C_4
  float v4; // ST08_4
  float v5; // ST00_4
  float v6; // [esp+4h] [ebp-Ch]
  float v7; // [esp+Ch] [ebp-4h]

  v7 = *a1 * *a1;
  v6 = a1[1] * a1[1] + v7;
  if ( v6 != 0.0 )
  {
    v2 = 2.0 / v6;
    v3 = v7 * v2;
    v4 = *a1 * a1[1] * v2;
    v5 = (1.0 - v3) * *a2 + v4 * a2[1];
    a2[1] = a2[1] - (v4 * *a2 + v3 * a2[1]);
    *a2 = v5;
  }
}

//----- (080BB82A) --------------------------------------------------------
int __cdecl sub_80BB82A(int a1, float a2, float a3, float a4, int a5, int a6)
{
  float v6; // ST1C_4
  unsigned __int16 *v8; // [esp+14h] [ebp-54h]
  int v9; // [esp+20h] [ebp-48h]
  int v10; // [esp+30h] [ebp-38h]
  int v11; // [esp+40h] [ebp-28h]
  int v12; // [esp+50h] [ebp-18h]
  float v13; // [esp+54h] [ebp-14h]
  float v14; // [esp+58h] [ebp-10h]
  float v15; // [esp+5Ch] [ebp-Ch]

  sub_80BB682(a1, a3, (int)&v12, (int)&v11);
  sub_80BB682(a1, a4, (int)&v14, (int)&v10);
  if ( *(_BYTE *)(a1 + 2) )
  {
    if ( a3 > (long double)a4 )
    {
      v8 = **(unsigned __int16 ***)(a1 + 32);
      if ( v8 )
      {
        if ( *v8 )
        {
          sub_80C109A((float *)&v10, (float *)(*((_DWORD *)v8 + 1) + 12 * *v8), (float *)&v10);
          sub_80C10DE((float *)&v10, *((float **)v8 + 1), (float *)&v10);
        }
      }
    }
  }
  v6 = a2 * 9.3137942e-10;
  *(float *)a5 = (v14 * v13 - v15 * *(float *)&v12) * v6 + *(float *)a5;
  *(float *)(a5 + 4) = (v14 * *(float *)&v12 + v15 * v13) * v6 + *(float *)(a5 + 4);
  sub_80C10DE((float *)&v10, (float *)&v11, (float *)&v9);
  sub_80BB77C((float *)&v12 + 2 * a6, (float *)&v9);
  *(float *)(a5 + 8) = *(float *)(a5 + 8) + a2;
  return sub_80C11C4(a5 + 12, a2, (int)&v9, a5 + 12);
}

//----- (080BB9A8) --------------------------------------------------------
int __cdecl sub_80BB9A8(int a1, float a2, float a3, int a4)
{
  float v4; // ST04_4
  int v6; // [esp+10h] [ebp-28h]
  int v7; // [esp+28h] [ebp-10h]

  sub_80BB682(a1, a3, (int)&v7, (int)&v6);
  v4 = a2 * 0.000030518509;
  sub_80C0FE8(a4, v4, (int)&v7, a4);
  *(float *)(a4 + 8) = *(float *)(a4 + 8) + a2;
  return sub_80C11C4(a4 + 12, a2, (int)&v6, a4 + 12);
}

//----- (080BBA2E) --------------------------------------------------------
int __cdecl sub_80BBA2E(int a1)
{
  int result; // eax

  if ( *(_WORD *)(a1 + 4) )
  {
    sub_80796A2(*(unsigned __int16 *)(a1 + 4));
    *(_WORD *)(a1 + 4) = 0;
  }
  result = a1;
  *(_WORD *)(a1 + 2) = -1;
  return result;
}

//----- (080BBA62) --------------------------------------------------------
int __cdecl sub_80BBA62(int a1, int a2)
{
  char *v2; // ST04_4
  int result; // eax

  v2 = (char *)&unk_8527A80 + 40 * a2;
  sub_80BBA2E((int)v2);
  *((_WORD *)v2 + 4) = 0;
  *((_WORD *)v2 + 5) = word_8527A8A[0];
  word_8527A88[20 * (unsigned __int16)word_8527A8A[0]] = a2;
  result = a2;
  word_8527A8A[0] = a2;
  return result;
}
// 8527A88: using guessed type __int16 word_8527A88[];
// 8527A8A: using guessed type __int16 word_8527A8A[];

//----- (080BBAD0) --------------------------------------------------------
long double __cdecl sub_80BBAD0(_DWORD *a1, int a2)
{
  float v3; // [esp+8h] [ebp-30h]
  float v4; // [esp+Ch] [ebp-2Ch]
  float v5; // [esp+10h] [ebp-28h]
  unsigned __int16 *v6; // [esp+18h] [ebp-20h]
  float v7; // [esp+1Ch] [ebp-1Ch]
  float v8; // [esp+20h] [ebp-18h]
  float v9; // [esp+24h] [ebp-14h]
  float *v10; // [esp+28h] [ebp-10h]
  unsigned __int16 v11; // [esp+2Eh] [ebp-Ah]
  int i; // [esp+30h] [ebp-8h]
  int v13; // [esp+34h] [ebp-4h]

  v6 = (unsigned __int16 *)(*a1 + 8 * a2 + 12);
  v13 = *v6;
  if ( *v6 )
  {
    v8 = 0.0;
    v7 = 0.0;
    for ( i = 0; i < v13; ++i )
    {
      v11 = *((_WORD *)a1 + i + v6[3] + 4);
      if ( v11 )
      {
        v10 = (float *)((char *)&unk_8527A80 + 40 * v11);
        v9 = v10[8];
        if ( v9 != 0.0 )
        {
          v5 = sub_80BBAD0(a1, i + (unsigned int)v6[3]);
          if ( v5 != 0.0 )
          {
            v8 = v8 + v9;
            v7 = v5 * v9 * v10[9] + v7;
          }
        }
      }
    }
    if ( v8 == 0.0 )
      v3 = 0.0;
    else
      v3 = v7 / v8;
    v4 = v3;
  }
  else
  {
    v4 = *(float *)(*(_DWORD *)(*a1 + 8 * a2 + 16) + 8);
  }
  return v4;
}

//----- (080BBC06) --------------------------------------------------------
int __cdecl sub_80BBC06(int a1, float a2)
{
  signed int v3; // [esp+0h] [ebp-18h]
  int v4; // [esp+4h] [ebp-14h]
  float v5; // [esp+8h] [ebp-10h]
  float v6; // [esp+Ch] [ebp-Ch]
  int v7; // [esp+10h] [ebp-8h]
  int v8; // [esp+14h] [ebp-4h]

  v8 = *(_DWORD *)(a1 + 4);
  v4 = 0;
  v5 = 2.0;
  v7 = *(_DWORD *)(v8 + 28);
  v3 = 0;
  while ( v3 < *(unsigned __int8 *)(v8 + 12) )
  {
    v6 = *(float *)(v7 + 4);
    if ( a2 <= (long double)v6 && v5 > (long double)v6 )
    {
      v5 = *(float *)(v7 + 4);
      v4 = v7;
    }
    ++v3;
    v7 += 8;
  }
  return (unsigned __int16)((v4 - *(_DWORD *)(v8 + 28)) >> 3);
}

//----- (080BBC94) --------------------------------------------------------
long double __cdecl sub_80BBC94(int a1, int a2, float a3, float a4)
{
  float v5; // [esp+0h] [ebp-4h]

  if ( *(float *)(a2 + 4) == 1.0 )
  {
    v5 = 1.0;
  }
  else if ( *(float *)(a2 + 4) <= (long double)*(float *)a2 )
  {
    if ( *(float *)a2 <= (long double)a3 && *(float *)a2 != 1.0 || a3 < (long double)*(float *)(a2 + 4) )
      v5 = 1.0;
    else
      v5 = ((long double)(*(signed __int16 *)(a2 + 10) - (signed int)*(signed __int16 *)(a1 + 10))
          + a3
          - *(float *)(a1 + 4))
         / a4;
  }
  else if ( *(float *)a2 <= (long double)a3 )
  {
    if ( a3 < (long double)*(float *)(a2 + 4) )
      v5 = 1.0;
    else
      v5 = ((long double)(*(signed __int16 *)(a2 + 10) - (signed int)*(signed __int16 *)(a1 + 10))
          + a3
          - *(float *)(a1 + 4))
         / a4;
  }
  else
  {
    v5 = ((long double)(*(signed __int16 *)(a2 + 10) - (signed int)*(signed __int16 *)(a1 + 10) + 1)
        + a3
        - *(float *)(a1 + 4))
       / a4;
  }
  return v5;
}

//----- (080BBDC8) --------------------------------------------------------
long double __cdecl sub_80BBDC8(int a1, int a2, int a3, int a4, int a5, float a6)
{
  float v7; // [esp+10h] [ebp-8h]
  int v8; // [esp+14h] [ebp-4h]

  if ( *(_WORD *)(a1 + 4) && *(_WORD *)(a2 + 4) )
  {
    if ( *(_WORD *)a3 )
    {
      if ( !*(_WORD *)a2 )
        return (float)sub_80BBC94(a4, a5, 1.0, a6);
      a3 = *(_DWORD *)a1 + 8 * *(unsigned __int16 *)a2 + 12;
    }
    v8 = *(_DWORD *)(a3 + 4);
    if ( *(_WORD *)(a2 + 2) >= 0 || (sub_80C0164((_DWORD *)a1, (float *)a2, (_WORD *)a3), *(_WORD *)(a2 + 2) >= 0) )
      v7 = sub_80BBC94(a4, a5, *(float *)(*(_DWORD *)(v8 + 28) + 8 * *(signed __int16 *)(a2 + 2) + 4), a6);
    else
      v7 = sub_80BBC94(a4, a5, 1.0, a6);
  }
  else
  {
    v7 = 1.0;
  }
  return v7;
}

//----- (080BBED6) --------------------------------------------------------
int __cdecl sub_80BBED6(int a1, int a2, float a3, int a4)
{
  _DWORD *v4; // ecx
  int v5; // ST10_4
  int result; // eax
  int i; // [esp+Ch] [ebp-Ch]
  char *v8; // [esp+10h] [ebp-8h]

  for ( i = dword_85500A0 - 1; i >= 0; --i )
  {
    v8 = (char *)&unk_854FAA0 + 12 * i;
    if ( a3 >= (long double)*((float *)v8 + 2) )
      break;
    v4 = v8 + 12;
    *v4 = *(_DWORD *)v8;
    v4[1] = *((_DWORD *)v8 + 1);
    v4[2] = *((_DWORD *)v8 + 2);
  }
  v5 = 12 * i + 139786924;
  dword_854FAAC[3 * i] = sub_8078896(a2);
  *(float *)(v5 + 8) = a3;
  result = a4;
  *(_DWORD *)(v5 + 4) = a4;
  ++dword_85500A0;
  return result;
}
// 85500A0: using guessed type int dword_85500A0;

//----- (080BBF7C) --------------------------------------------------------
void __cdecl sub_80BBF7C(int a1, int a2, float a3)
{
  float v3; // ST08_4
  float v4; // ST08_4
  float v5; // ST08_4
  float v6; // ST08_4
  float v7; // ST08_4
  float v8; // ST08_4
  float v9; // ST08_4
  unsigned __int16 v10; // [esp+16h] [ebp-12h]
  float *v11; // [esp+18h] [ebp-10h]
  unsigned __int16 v12; // [esp+1Eh] [ebp-Ah]
  float *v13; // [esp+20h] [ebp-8h]
  float *i; // [esp+20h] [ebp-8h]
  int v15; // [esp+24h] [ebp-4h]

  v11 = (float *)(a1 + 12);
  v10 = *(_WORD *)(a1 + 6);
  if ( v10 )
  {
    if ( *(float *)(a1 + 16) == 1.0 )
    {
      v3 = sub_80BBC94((int)v11, (int)v11, 1.0, a3);
      sub_80BBED6(a2, dword_854FA80, v3, v10);
    }
    else if ( *(_WORD *)a2 )
    {
      if ( *(float *)(a1 + 16) > (long double)*(float *)(a1 + 12) || *v11 == 1.0 )
      {
        v4 = sub_80BBC94((int)v11, (int)v11, 1.0, a3);
        sub_80BBED6(a2, dword_854FA80, v4, v10);
      }
    }
    else
    {
      v15 = *(_DWORD *)(a2 + 4);
      v12 = sub_80BBC06(a2, *(float *)(a1 + 16));
      v13 = (float *)(*(_DWORD *)(v15 + 28) + 8 * v12);
      if ( *(float *)(a1 + 16) <= (long double)*(float *)(a1 + 12) )
      {
        if ( *v11 == 1.0 )
        {
          if ( *(float *)(a1 + 16) <= (long double)v13[1] )
          {
            do
            {
              v8 = sub_80BBC94((int)v11, (int)v11, v13[1], a3);
              sub_80BBED6(a2, *(unsigned __int16 *)v13, v8, v10);
              v13 += 2;
              ++v12;
            }
            while ( v12 < (unsigned int)*(unsigned __int8 *)(v15 + 12) );
          }
        }
        else if ( v13[1] < (long double)*v11 && *(float *)(a1 + 16) <= (long double)v13[1] )
        {
          do
          {
            v9 = sub_80BBC94((int)v11, (int)v11, v13[1], a3);
            sub_80BBED6(a2, *(unsigned __int16 *)v13, v9, v10);
            v13 += 2;
            ++v12;
          }
          while ( v12 < (unsigned int)*(unsigned __int8 *)(v15 + 12) && *v11 > (long double)v13[1] );
        }
      }
      else if ( *v11 <= (long double)v13[1] )
      {
        if ( *(float *)(a1 + 16) <= (long double)v13[1] )
        {
          do
          {
            v6 = sub_80BBC94((int)v11, (int)v11, v13[1], a3);
            sub_80BBED6(a2, *(unsigned __int16 *)v13, v6, v10);
            v13 += 2;
            ++v12;
          }
          while ( v12 < (unsigned int)*(unsigned __int8 *)(v15 + 12) );
          for ( i = *(float **)(v15 + 28); *v11 > (long double)i[1]; i += 4 )
          {
            v7 = sub_80BBC94((int)v11, (int)v11, i[1], a3);
            sub_80BBED6(a2, *(unsigned __int16 *)i, v7, v10);
          }
        }
      }
      else
      {
        do
        {
          v5 = sub_80BBC94((int)v11, (int)v11, v13[1], a3);
          sub_80BBED6(a2, *(unsigned __int16 *)v13, v5, v10);
          v13 += 2;
          ++v12;
        }
        while ( v12 < (unsigned int)*(unsigned __int8 *)(v15 + 12) && *v11 > (long double)v13[1] );
      }
    }
  }
}

//----- (080BC382) --------------------------------------------------------
void __cdecl sub_80BC382(int a1, int a2, int a3, int a4, float a5)
{
  unsigned __int16 *v5; // [esp+1Ch] [ebp-1Ch]
  _DWORD *v6; // [esp+20h] [ebp-18h]
  char *v7; // [esp+24h] [ebp-14h]
  unsigned __int16 v8; // [esp+2Ah] [ebp-Eh]
  int v9; // [esp+2Ch] [ebp-Ch]
  int i; // [esp+30h] [ebp-8h]
  unsigned __int8 v11; // [esp+37h] [ebp-1h]

  v11 = a3;
  v8 = *(_WORD *)(a1 + 2 * a2 + 8);
  if ( v8 )
  {
    v7 = (char *)&unk_8527A80 + 40 * v8;
    v6 = v7 + 12;
    if ( *((float *)v7 + 8) != 0.0 )
    {
      if ( *((float *)v7 + 7) == 0.0 )
        v11 = 0;
      v5 = (unsigned __int16 *)(*(_DWORD *)a1 + 8 * a2 + 12);
      if ( *((float *)v7 + 4) != *(float *)(a4 + 4) || *((_WORD *)v7 + 11) != *(_WORD *)(a4 + 10) )
      {
        *v6 = *(_DWORD *)(a4 + 4);
        *((_WORD *)v7 + 10) = *(_WORD *)(a4 + 10);
        *((_DWORD *)v7 + 4) = *(_DWORD *)(a4 + 4);
        *((_WORD *)v7 + 11) = *(_WORD *)(a4 + 10);
        *((_WORD *)v7 + 1) = -1;
      }
      if ( v11 )
        sub_80BD2FC(a1, (int)v7, (int)v5, *(float *)a4);
      *v6 = *(_DWORD *)a4;
      *((_WORD *)v7 + 10) = *(_WORD *)(a4 + 8);
      *((_WORD *)v7 + 1) = -1;
      if ( v11 )
        sub_80BBF7C((int)v7, (int)v5, a5);
      v9 = *v5;
      for ( i = 0; i < v9; ++i )
        sub_80BC382(a1, i + v5[3], v11, a4, a5);
    }
  }
}

//----- (080BC52E) --------------------------------------------------------
void __cdecl sub_80BC52E(int a1, int a2, float a3, int a4)
{
  __int16 v4; // [esp+22h] [ebp-26h]
  __int16 v5; // [esp+22h] [ebp-26h]
  float v6; // [esp+24h] [ebp-24h]
  float v7; // [esp+24h] [ebp-24h]
  int v8; // [esp+28h] [ebp-20h]
  unsigned __int16 *v9; // [esp+2Ch] [ebp-1Ch]
  float *v10; // [esp+30h] [ebp-18h]
  float *v11; // [esp+34h] [ebp-14h]
  unsigned __int16 v12; // [esp+3Ah] [ebp-Eh]
  int v13; // [esp+3Ch] [ebp-Ch]
  int i; // [esp+40h] [ebp-8h]
  int j; // [esp+40h] [ebp-8h]
  unsigned __int8 v16; // [esp+47h] [ebp-1h]
  float v17; // [esp+58h] [ebp+10h]
  float v18; // [esp+58h] [ebp+10h]
  float v19; // [esp+58h] [ebp+10h]

  v16 = a4;
  v12 = *(_WORD *)(a1 + 2 * a2 + 8);
  if ( v12 )
  {
    v11 = (float *)((char *)&unk_8527A80 + 40 * v12);
    v10 = v11 + 3;
    if ( v11[8] != 0.0 )
    {
      if ( v11[7] == 0.0 )
        v16 = 0;
      v9 = (unsigned __int16 *)(*(_DWORD *)a1 + 8 * a2 + 12);
      v13 = *v9;
      if ( *v9 )
      {
        if ( *(_WORD *)(*(_DWORD *)a1 + 8 * a2 + 16) & 3 )
        {
          v18 = sub_80BBAD0((_DWORD *)a1, a2) * v11[9] * a3;
          if ( v18 != 0.0 )
          {
            v7 = v11[4] + v18;
            v5 = *((_WORD *)v11 + 11);
            if ( v7 >= 1.0 )
            {
              if ( v9[2] & 2 )
              {
                v7 = 1.0;
              }
              else
              {
                do
                {
                  v7 = v7 - 1.0;
                  ++v5;
                }
                while ( v7 >= 1.0 );
              }
            }
            if ( *v10 - v7 <= (long double)(v5 - (signed int)*((signed __int16 *)v11 + 10)) )
            {
              if ( v16 )
                sub_80BD2FC(a1, (int)v11, (int)v9, v7);
              *v10 = v7;
              *((_WORD *)v11 + 10) = v5;
              *((_WORD *)v11 + 1) = -1;
              if ( v16 )
                sub_80BBF7C((int)v11, (int)v9, v18);
              for ( i = 0; i < v13; ++i )
                sub_80BC382(a1, i + v9[3], v16, (int)v10, v18);
            }
          }
        }
        else
        {
          v19 = a3 * v11[9];
          if ( v19 != 0.0 )
          {
            for ( j = 0; j < v13; ++j )
              sub_80BC52E(a1, j + v9[3], v19, v16);
          }
        }
      }
      else
      {
        v8 = *(_DWORD *)(*(_DWORD *)a1 + 8 * a2 + 16);
        v17 = v11[9] * *(float *)(v8 + 8) * a3;
        if ( v17 != 0.0 )
        {
          v6 = v11[4] + v17;
          v4 = *((_WORD *)v11 + 10);
          if ( v6 >= 1.0 )
          {
            if ( *(_BYTE *)(v8 + 2) )
            {
              do
              {
                v6 = v6 - 1.0;
                ++v4;
              }
              while ( v6 >= 1.0 );
            }
            else
            {
              v6 = 1.0;
            }
          }
          if ( *v10 - v6 <= (long double)(v4 - (signed int)*((signed __int16 *)v11 + 10)) )
          {
            if ( v16 )
              sub_80BD2FC(a1, (int)v11, (int)v9, v6);
            *v10 = v6;
            *((_WORD *)v11 + 10) = v4;
            *((_WORD *)v11 + 1) = -1;
            if ( v16 )
              sub_80BBF7C((int)v11, (int)v9, v17);
          }
        }
      }
    }
  }
}

//----- (080BC8C8) --------------------------------------------------------
_WORD *__cdecl sub_80BC8C8(_WORD *a1)
{
  _WORD *result; // eax

  memset(a1 + 6, 0, 0x1Cu);
  a1[2] = 0;
  a1[1] = -1;
  *a1 = 0;
  result = a1;
  a1[3] = 0;
  return result;
}

//----- (080BC912) --------------------------------------------------------
int __cdecl sub_80BC912(int a1, int a2)
{
  int result; // eax
  int v3; // ST10_4
  int v4; // [esp+18h] [ebp-10h]
  char *v5; // [esp+1Ch] [ebp-Ch]
  int v6; // [esp+20h] [ebp-8h]
  int i; // [esp+24h] [ebp-4h]

  v4 = *(_DWORD *)(*(_DWORD *)a1 + 4);
  for ( i = 0; ; ++i )
  {
    result = i;
    if ( i >= v4 )
      break;
    v6 = *(unsigned __int16 *)(a1 + 2 * i + 8);
    if ( *(_WORD *)(a1 + 2 * i + 8) )
    {
      if ( *(_WORD *)(a2 + 2 * i + 8) )
      {
        v5 = (char *)&unk_8527A80 + 40 * *(unsigned __int16 *)(a2 + 2 * i + 8);
      }
      else
      {
        v5 = (char *)sub_80BF2AE(a2, i);
        sub_80BC8C8(v5);
      }
      v3 = (int)(v5 + 12);
      *((_DWORD *)v5 + 3) = dword_8527A90[10 * v6];
      *(_WORD *)(v3 + 8) = word_8527A96[20 * v6];
      *(_DWORD *)(v3 + 16) = dword_8527A9C[10 * v6];
      *(_DWORD *)(v3 + 24) = dword_8527AA4[10 * v6];
      *(_DWORD *)(v3 + 12) = *((_DWORD *)&unk_8527A98 + 10 * v6);
    }
    else if ( *(_WORD *)(a2 + 2 * i + 8) )
    {
      sub_80BBA62(a2, *(unsigned __int16 *)(a2 + 2 * i + 8));
      *(_WORD *)(a2 + 2 * i + 8) = 0;
    }
  }
  return result;
}
// 8527A90: using guessed type int dword_8527A90[];
// 8527A96: using guessed type __int16 word_8527A96[];
// 8527A9C: using guessed type int dword_8527A9C[];

//----- (080BCA42) --------------------------------------------------------
signed int __cdecl sub_80BCA42(int a1)
{
  if ( *(float *)(a1 + 12) == 0.0 && !*(_WORD *)(a1 + 20) )
    return 0;
  *(_DWORD *)(a1 + 12) = 0;
  *(_WORD *)(a1 + 20) = 0;
  *(_DWORD *)(a1 + 16) = 0;
  *(_WORD *)(a1 + 22) = 0;
  *(_WORD *)(a1 + 2) = -1;
  return 1;
}

//----- (080BCAB4) --------------------------------------------------------
int __cdecl sub_80BCAB4(_DWORD *a1, int a2)
{
  int result; // eax
  unsigned __int16 *v3; // [esp+8h] [ebp-10h]
  unsigned __int16 v4; // [esp+Eh] [ebp-Ah]
  int v5; // [esp+10h] [ebp-8h]
  int i; // [esp+14h] [ebp-4h]

  result = *((unsigned __int16 *)a1 + a2 + 4);
  v4 = *((_WORD *)a1 + a2 + 4);
  if ( v4 )
  {
    sub_80BCA42(40 * v4 + 139623040);
    v3 = (unsigned __int16 *)(*a1 + 8 * a2 + 12);
    v5 = *v3;
    for ( i = 0; ; ++i )
    {
      result = i;
      if ( i >= v5 )
        break;
      sub_80BCAB4(a1, i + v3[3]);
    }
  }
  return result;
}

//----- (080BCB3A) --------------------------------------------------------
int __cdecl sub_80BCB3A(int a1, int a2, int a3, float a4, int a5, int a6, int a7)
{
  int result; // eax
  char v8; // [esp+1Eh] [ebp-2Ah]
  char v9; // [esp+1Fh] [ebp-29h]
  int v10; // [esp+26h] [ebp-22h]
  int v11; // [esp+2Ch] [ebp-1Ch]
  int v12; // [esp+30h] [ebp-18h]
  int v13; // [esp+34h] [ebp-14h]
  int v14; // [esp+38h] [ebp-10h]
  int i; // [esp+3Ch] [ebp-Ch]
  int v16; // [esp+42h] [ebp-6h]

  BYTE1(v16) = a5;
  result = *(unsigned __int16 *)(a1 + 2 * a2 + 8);
  v13 = *(unsigned __int16 *)(a1 + 2 * a2 + 8);
  if ( v13 )
  {
    v12 = (int)&unk_8527A80 + 40 * v13;
    v11 = v12 + 12;
    v9 = 0;
    if ( BYTE1(v16) && *(float *)(v11 + 20) != 0.0 )
      v9 = 1;
    BYTE1(v10) = v9;
    if ( BYTE1(v16) && a4 < (long double)*(float *)(v11 + 12) )
    {
      *(float *)(v11 + 20) = (*(float *)(v11 + 16) - *(float *)(v11 + 20)) * a4 / *(float *)(v11 + 12)
                           + *(float *)(v11 + 20);
      if ( *(float *)(v11 + 20) < 0.0000010000001 )
        *(float *)(v11 + 20) = *(float *)(v11 + 16) * 0.001;
      *(float *)(v11 + 12) = *(float *)(v11 + 12) - a4;
    }
    else
    {
      *(_DWORD *)(v11 + 20) = *(_DWORD *)(v11 + 16);
      *(_DWORD *)(v11 + 12) = 0;
    }
    v8 = 0;
    if ( BYTE1(v10) || *(float *)(v11 + 16) != 0.0 )
      v8 = 1;
    LOBYTE(v16) = v8;
    *(int *)((char *)&v10 + 2) = *(_DWORD *)a1 + 8 * a2 + 12;
    v14 = **(unsigned __int16 **)((char *)&v10 + 2);
    if ( v14 )
    {
      LOBYTE(v10) = 0;
      if ( *(_WORD *)(*(int *)((char *)&v10 + 2) + 4) & 4 )
        a3 = v11;
      for ( i = 0; i < v14; ++i )
        sub_80BCB3A(
          a1,
          i + *(unsigned __int16 *)(*(int *)((char *)&v10 + 2) + 6),
          a3,
          a4,
          BYTE1(v10),
          (int)&v16,
          (int)&v10);
    }
    else
    {
      LOBYTE(v10) = 0.0 != *(float *)(*(_DWORD *)(*(int *)((char *)&v10 + 2) + 4) + 8);
    }
    if ( (_BYTE)v16 )
    {
      if ( (_WORD)v10 )
      {
        *(_BYTE *)a7 = 1;
      }
      else if ( v14 && *(_WORD *)(*(int *)((char *)&v10 + 2) + 4) & 4 )
      {
        if ( (unsigned __int8)sub_80BCA42(v12) )
        {
          for ( i = 0; i < v14; ++i )
            sub_80BCAB4((_DWORD *)a1, i + *(unsigned __int16 *)(*(int *)((char *)&v10 + 2) + 6));
        }
      }
      else if ( *(float *)v11 != *(float *)a3 || *(_WORD *)(v11 + 8) != *(_WORD *)(a3 + 8) )
      {
        *(_DWORD *)v11 = *(_DWORD *)a3;
        *(_WORD *)(v11 + 8) = *(_WORD *)(a3 + 8);
        *(_WORD *)(v12 + 2) = -1;
      }
      *(_DWORD *)(v11 + 4) = *(_DWORD *)v11;
      *(_WORD *)(v11 + 10) = *(_WORD *)(v11 + 8);
      result = a6;
      *(_BYTE *)a6 = 1;
    }
    else
    {
      sub_80BBA62(a1, v13);
      result = a2;
      *(_WORD *)(a1 + 2 * a2 + 8) = 0;
    }
  }
  return result;
}

//----- (080BCE1C) --------------------------------------------------------
int __cdecl sub_80BCE1C(int a1, int a2, int a3)
{
  sub_8084C8E(a3);
  return sub_8083426(*(unsigned __int16 *)(a1 + 4) - 1, 0, a2, 1);
}

//----- (080BCE56) --------------------------------------------------------
long double __cdecl sub_80BCE56(int a1, int a2, int a3, int a4, int a5, float a6)
{
  unsigned __int16 v7; // [esp+26h] [ebp-12h]
  int v8; // [esp+28h] [ebp-10h]
  signed int i; // [esp+30h] [ebp-8h]
  float v10; // [esp+34h] [ebp-4h]
  float *v11; // [esp+44h] [ebp+Ch]

  v10 = sub_80BBDC8(a1, a2, a3, a4, a5, a6);
  for ( i = 0; i < *(unsigned __int16 *)a3; ++i )
  {
    v8 = i + *(unsigned __int16 *)(a3 + 6);
    v7 = *(_WORD *)(a1 + 2 * v8 + 8);
    if ( v7 )
    {
      v11 = (float *)((char *)&unk_8527A80 + 40 * v7);
      if ( v11[8] != 0.0 && v11[7] != 0.0 )
      {
        sub_80BCE56(a1, (int)v11, *(_DWORD *)a1 + 8 * v8 + 12, a4, a5, a6);
        if ( v10 > (long double)(float)0.0 )
          v10 = 0.0;
      }
    }
  }
  return v10;
}

//----- (080BCF74) --------------------------------------------------------
long double __cdecl sub_80BCF74(int a1, int a2, float a3)
{
  long double v3; // fst7
  float v5; // [esp+2Ch] [ebp-5Ch]
  int v6; // [esp+30h] [ebp-58h]
  int v7; // [esp+34h] [ebp-54h]
  __int16 v8; // [esp+38h] [ebp-50h]
  __int16 v9; // [esp+3Ah] [ebp-4Eh]
  float v10; // [esp+54h] [ebp-34h]
  float v11; // [esp+58h] [ebp-30h]
  __int16 v12; // [esp+5Eh] [ebp-2Ah]
  int v13; // [esp+60h] [ebp-28h]
  int v14; // [esp+64h] [ebp-24h]
  int v15; // [esp+68h] [ebp-20h]
  int v16; // [esp+6Ch] [ebp-1Ch]
  int v17; // [esp+70h] [ebp-18h]
  unsigned __int16 v18; // [esp+76h] [ebp-12h]
  int v19; // [esp+78h] [ebp-10h]
  int i; // [esp+7Ch] [ebp-Ch]
  float v21; // [esp+98h] [ebp+10h]
  float v22; // [esp+98h] [ebp+10h]
  float v23; // [esp+98h] [ebp+10h]

  v18 = *(_WORD *)(a1 + 2 * a2 + 8);
  if ( v18 )
  {
    v17 = (int)&unk_8527A80 + 40 * v18;
    v16 = v17 + 12;
    if ( *(float *)(v17 + 32) != 0.0 && *(float *)(v16 + 16) != 0.0 )
    {
      v15 = *(_DWORD *)a1 + 8 * a2 + 12;
      v19 = *(unsigned __int16 *)v15;
      if ( v19 )
      {
        if ( *(_WORD *)(v15 + 4) & 3 )
        {
          v22 = sub_80BBAD0((_DWORD *)a1, a2) * *(float *)(v16 + 24) * a3;
          if ( v22 == 0.0 )
          {
            v5 = 1.0;
          }
          else
          {
            *(float *)&v13 = *(float *)(v16 + 4) + v22;
            v12 = *(_WORD *)(v16 + 10);
            if ( *(_WORD *)(v15 + 4) & 2 )
            {
              if ( *(float *)&v13 >= 1.0 )
                *(float *)&v13 = 1.0;
            }
            else
            {
              while ( *(float *)&v13 >= 1.0 )
              {
                *(float *)&v13 = *(float *)&v13 - 1.0;
                ++v12;
              }
            }
            if ( *(float *)v16 - *(float *)&v13 <= (long double)(v12 - (signed int)*(signed __int16 *)(v16 + 8)) )
            {
              v7 = *(_DWORD *)v16;
              v9 = *(_WORD *)(v16 + 8);
              v6 = v13;
              v8 = v12;
              v5 = sub_80BCE56(a1, v17, v15, v16, (int)&v6, v22);
            }
            else
            {
              v5 = 1.0;
            }
          }
        }
        else
        {
          v23 = a3 * *(float *)(v16 + 24);
          v3 = 0.0;
          if ( v23 == 0.0 )
          {
            v5 = 1.0;
          }
          else
          {
            v10 = 1.0;
            for ( i = 0; i < v19; ++i )
            {
              sub_80BCF74(a1, i + *(unsigned __int16 *)(v15 + 6), v23);
              v11 = v3;
              v3 = v11;
              if ( v10 > (long double)v11 )
                v10 = v11;
            }
            v5 = v10;
          }
        }
      }
      else
      {
        v14 = *(_DWORD *)(v15 + 4);
        v21 = *(float *)(v16 + 24) * *(float *)(v14 + 8) * a3;
        if ( v21 == 0.0 )
        {
          v5 = 1.0;
        }
        else
        {
          *(float *)&v13 = *(float *)(v16 + 4) + v21;
          v12 = *(_WORD *)(v16 + 10);
          if ( *(_BYTE *)(v14 + 2) )
          {
            while ( *(float *)&v13 >= 1.0 )
            {
              *(float *)&v13 = *(float *)&v13 - 1.0;
              ++v12;
            }
          }
          else if ( *(float *)&v13 >= 1.0 )
          {
            *(float *)&v13 = 1.0;
          }
          if ( *(float *)v16 - *(float *)&v13 <= (long double)(v12 - (signed int)*(signed __int16 *)(v16 + 8)) )
          {
            v7 = *(_DWORD *)v16;
            v9 = *(_WORD *)(v16 + 8);
            v6 = v13;
            v8 = v12;
            v5 = sub_80BBDC8(a1, v17, v15, v16, (int)&v6, v21);
          }
          else
          {
            v5 = 1.0;
          }
        }
      }
    }
    else
    {
      v5 = 1.0;
    }
  }
  else
  {
    v5 = 1.0;
  }
  return v5;
}

//----- (080BD2FC) --------------------------------------------------------
void __cdecl sub_80BD2FC(int a1, int a2, int a3, float a4)
{
  signed int v4; // [esp+1Ch] [ebp-Ch]
  float *v5; // [esp+20h] [ebp-8h]
  float *i; // [esp+20h] [ebp-8h]
  int v7; // [esp+24h] [ebp-4h]

  if ( *(_WORD *)(a1 + 4) && *(_WORD *)(a2 + 4) )
  {
    if ( *(float *)(a2 + 12) == 1.0 )
    {
      sub_8084C8E(dword_854FA80);
      sub_8083426(*(unsigned __int16 *)(a1 + 4) - 1, 0, *(unsigned __int16 *)(a2 + 4), 1);
    }
    else if ( *(_WORD *)(a2 + 2) >= 0 || (sub_80C0164((_DWORD *)a1, (float *)a2, (_WORD *)a3), *(_WORD *)(a2 + 2) >= 0) )
    {
      if ( *(_WORD *)a3 )
        a3 = *(_DWORD *)a1 + 8 * *(unsigned __int16 *)a2 + 12;
      v7 = *(_DWORD *)(a3 + 4);
      v4 = *(signed __int16 *)(a2 + 2);
      v5 = (float *)(*(_DWORD *)(v7 + 28) + 8 * v4);
      if ( *(float *)(a2 + 12) <= (long double)a4 )
      {
        if ( a4 == 1.0 )
        {
          if ( *(float *)(a2 + 12) <= (long double)v5[1] )
          {
            do
            {
              sub_80BCE1C(a1, *(unsigned __int16 *)(a2 + 4), *(unsigned __int16 *)v5);
              v5 += 2;
              ++v4;
            }
            while ( v4 < *(unsigned __int8 *)(v7 + 12) );
          }
        }
        else if ( v5[1] < (long double)a4 && *(float *)(a2 + 12) <= (long double)v5[1] )
        {
          do
          {
            sub_80BCE1C(a1, *(unsigned __int16 *)(a2 + 4), *(unsigned __int16 *)v5);
            v5 += 2;
            ++v4;
          }
          while ( v4 < *(unsigned __int8 *)(v7 + 12) && a4 > (long double)v5[1] );
        }
      }
      else if ( a4 <= (long double)v5[1] )
      {
        if ( *(float *)(a2 + 12) <= (long double)v5[1] )
        {
          do
          {
            sub_80BCE1C(a1, *(unsigned __int16 *)(a2 + 4), *(unsigned __int16 *)v5);
            v5 += 2;
            ++v4;
          }
          while ( v4 < *(unsigned __int8 *)(v7 + 12) );
          for ( i = *(float **)(v7 + 28); a4 > (long double)i[1]; i += 2 )
            sub_80BCE1C(a1, *(unsigned __int16 *)(a2 + 4), *(unsigned __int16 *)i);
        }
      }
      else
      {
        do
        {
          sub_80BCE1C(a1, *(unsigned __int16 *)(a2 + 4), *(unsigned __int16 *)v5);
          v5 += 2;
          ++v4;
        }
        while ( v4 < *(unsigned __int8 *)(v7 + 12) && a4 > (long double)v5[1] );
      }
    }
    else if ( *(float *)(a2 + 12) > (long double)a4 || a4 == 1.0 )
    {
      sub_8084C8E(dword_854FA80);
      sub_8083426(*(unsigned __int16 *)(a1 + 4) - 1, 0, *(unsigned __int16 *)(a2 + 4), 1);
    }
  }
}

//----- (080BD62C) --------------------------------------------------------
void __cdecl sub_80BD62C(int a1, int a2, float a3, int a4, int a5, int a6, int a7, int a8)
{
  int v8; // ebx
  int v9; // ebx
  float v10; // ST4C_4
  float v11; // ST04_4
  float v12; // ST04_4
  float v13; // ST04_4
  float v14; // ST04_4
  int v15; // [esp+30h] [ebp-48h]
  _WORD *v16; // [esp+34h] [ebp-44h]
  int v17; // [esp+38h] [ebp-40h]
  int v18; // [esp+3Ch] [ebp-3Ch]
  _BYTE *v19; // [esp+40h] [ebp-38h]
  unsigned __int16 *v20; // [esp+44h] [ebp-34h]
  unsigned __int16 v21; // [esp+4Ah] [ebp-2Eh]
  unsigned __int16 v22; // [esp+4Ah] [ebp-2Eh]
  unsigned __int16 v23; // [esp+4Ah] [ebp-2Eh]
  float v24; // [esp+4Ch] [ebp-2Ch]
  float v25; // [esp+4Ch] [ebp-2Ch]
  float *v26; // [esp+50h] [ebp-28h]
  int v27; // [esp+54h] [ebp-24h]
  int j; // [esp+58h] [ebp-20h]
  int k; // [esp+58h] [ebp-20h]
  signed int l; // [esp+5Ch] [ebp-1Ch]
  int i; // [esp+5Ch] [ebp-1Ch]
  signed int v32; // [esp+5Ch] [ebp-1Ch]
  signed int v33; // [esp+5Ch] [ebp-1Ch]
  signed int v34; // [esp+5Ch] [ebp-1Ch]
  float v35; // [esp+60h] [ebp-18h]
  float v36; // [esp+64h] [ebp-14h]
  float v37; // [esp+64h] [ebp-14h]

  v18 = *(_DWORD *)a1;
  v20 = (unsigned __int16 *)(**(_DWORD **)a1 + 8 * a2 + 12);
  v27 = *v20;
  if ( *v20 )
  {
    for ( i = 0; ; ++i )
    {
      if ( i >= v27 )
      {
        if ( (_BYTE)a5 )
          sub_80BAD76(a1, (_DWORD *)a4, a7);
        return;
      }
      v21 = *(_WORD *)(v18 + 2 * (i + *(unsigned __int16 *)(**(_DWORD **)a1 + 8 * a2 + 18)) + 8);
      if ( v21 )
      {
        v35 = *(float *)&dword_8527AA0[10 * v21];
        if ( v35 != 0.0 )
          break;
      }
    }
    for ( j = i + 1; ; ++j )
    {
      if ( j >= v27 )
      {
        sub_80BD62C(
          a1,
          i + *(unsigned __int16 *)(**(_DWORD **)a1 + 8 * a2 + 18),
          a3,
          a4,
          (unsigned __int8)a5,
          (unsigned __int8)a6,
          a7,
          a8);
        return;
      }
      v22 = *(_WORD *)(v18 + 2 * (j + *(unsigned __int16 *)(**(_DWORD **)a1 + 8 * a2 + 18)) + 8);
      if ( v22 )
      {
        v36 = *(float *)&dword_8527AA0[10 * v22];
        if ( v36 != 0.0 )
          break;
      }
    }
    if ( (_BYTE)a5 )
    {
      v26 = (float *)a4;
      sub_80BD62C(a1, i + *(unsigned __int16 *)(**(_DWORD **)a1 + 8 * a2 + 18), v35, a4, 1, 1, a7, a8);
    }
    else
    {
      v26 = (float *)(a7 + 32 * a8);
      a8 += *(unsigned __int8 *)(a1 + 25);
      if ( a8 > 512 )
      {
        Com_Printf("MAX_CALC_ANIM_BUFFER exceeded\n");
        return;
      }
      sub_80BD62C(a1, i + v20[3], v35, (int)v26, 1, 1, a7, a8);
    }
    sub_80BD62C(a1, j + v20[3], v36, (int)v26, 0, 1, a7, a8);
    for ( k = j + 1; k < v27; ++k )
    {
      v23 = *(_WORD *)(v18 + 2 * (k + v20[3]) + 8);
      if ( v23 )
      {
        v37 = *(float *)&dword_8527AA0[10 * v23];
        if ( v37 != 0.0 )
          sub_80BD62C(a1, k + v20[3], v37, (int)v26, 0, 1, a7, a8);
      }
    }
    if ( (_BYTE)a6 )
    {
      if ( (_BYTE)a5 )
      {
        v33 = 0;
        while ( v33 < *(unsigned __int8 *)(a1 + 25) )
        {
          if ( !((*(_DWORD *)(a7 + 4 * (v33 >> 5) + 16400) >> (v33 & 0x1F)) & 1) )
          {
            v24 = sub_80C130A((float *)a4);
            if ( v24 != 0.0 )
            {
              v11 = sub_80C0F22(v24) * a3;
              sub_80C124E(a4, v11, a4);
            }
            if ( *(float *)(a4 + 28) != 0.0 )
            {
              v12 = a3 / *(float *)(a4 + 28);
              sub_80C118C(a4 + 16, v12, a4 + 16);
              *(float *)(a4 + 28) = a3;
            }
          }
          ++v33;
          a4 += 32;
        }
      }
      else
      {
        v34 = 0;
        while ( v34 < *(unsigned __int8 *)(a1 + 25) )
        {
          if ( !((*(_DWORD *)(a7 + 4 * (v34 >> 5) + 16400) >> (v34 & 0x1F)) & 1) )
          {
            v25 = sub_80C130A(v26);
            if ( v25 != 0.0 )
            {
              v13 = sub_80C0F22(v25) * a3;
              sub_80C129A(a4, v13, (int)v26, a4);
            }
            if ( v26[7] != 0.0 )
            {
              v14 = a3 / v26[7];
              sub_80C11C4(a4 + 16, v14, (int)(v26 + 4), a4 + 16);
              *(float *)(a4 + 28) = *(float *)(a4 + 28) + a3;
            }
          }
          ++v34;
          a4 += 32;
          v26 += 8;
        }
      }
    }
    else
    {
      v32 = 0;
      while ( v32 < *(unsigned __int8 *)(a1 + 25) )
      {
        if ( !((*(_DWORD *)(a7 + 4 * (v32 >> 5) + 16400) >> (v32 & 0x1F)) & 1) && *(float *)(a4 + 28) != 0.0 )
        {
          v10 = 1.0 / *(float *)(a4 + 28);
          sub_80C124E(a4, v10, a4);
          sub_80C118C(a4 + 16, v10, a4 + 16);
        }
        ++v32;
        a4 += 32;
      }
    }
  }
  else
  {
    if ( (_BYTE)a5 )
      sub_80BAD76(a1, (_DWORD *)a4, a7);
    v19 = (_BYTE *)(*(_DWORD *)(a1 + 12) + 2 * *(_DWORD *)(*(_DWORD *)v18 + 4));
    if ( *(_WORD *)(*(_DWORD *)(a1 + 12) + 2 * a2) )
    {
      if ( v19[a2 + 1] != *v19 )
      {
        v19[a2 + 1] = *v19;
        sub_8079746(
          *(unsigned __int16 *)(*(_DWORD *)(a1 + 12) + 2 * a2),
          *(signed __int16 *)(*((_DWORD *)v20 + 1) + 14) + 16);
        v9 = *(_DWORD *)(a1 + 12);
        *(_WORD *)(v9 + 2 * a2) = sub_80BA886((int)v20, a1 + 28, *(unsigned __int8 *)(a1 + 24));
      }
    }
    else
    {
      v19[a2 + 1] = *v19;
      v8 = *(_DWORD *)(a1 + 12);
      *(_WORD *)(v8 + 2 * a2) = sub_80BA886((int)v20, a1 + 28, *(unsigned __int8 *)(a1 + 24));
    }
    v17 = sub_8078896(*(unsigned __int16 *)(*(_DWORD *)(a1 + 12) + 2 * a2));
    for ( l = 0; l <= 3; ++l )
      *(_DWORD *)(a7 + 4 * l + 0x4000) |= *(_DWORD *)(v17 + 4 * l) & ~*(_DWORD *)(a7 + 4 * l + 16400);
    v16 = (_WORD *)*((_DWORD *)v20 + 1);
    v15 = dword_8527A8C[10 * *(unsigned __int16 *)(v18 + 2 * a2 + 8)];
    if ( *(float *)&v15 != 1.0 && *v16 )
    {
      if ( *v16 > 0xFFu )
        sub_80C0D92((int)v16, v17 + 16, v15, a3, a4, a7 + 16400);
      else
        sub_80C0A1E((int)v16, v17 + 16, v15, a3, a4, a7 + 16400);
    }
    else
    {
      sub_80BAC36((int)v16, v17 + 16, a3, a4, a7 + 16400);
    }
  }
}
// 8527A8C: using guessed type int dword_8527A8C[];
// 8527AA0: using guessed type int dword_8527AA0[];

//----- (080BDE00) --------------------------------------------------------
void __cdecl sub_80BDE00(int *a1, int a2, int a3)
{
  int v3; // eax
  int v4; // eax
  int v5; // eax
  float v6; // [esp+38h] [ebp-30h]
  const char *v7; // [esp+3Ch] [ebp-2Ch]
  char *v8; // [esp+40h] [ebp-28h]
  float v9; // [esp+48h] [ebp-20h]
  int v10; // [esp+4Ch] [ebp-1Ch]
  float *v11; // [esp+54h] [ebp-14h]
  unsigned __int16 *v12; // [esp+58h] [ebp-10h]
  unsigned __int16 v13; // [esp+5Eh] [ebp-Ah]
  int v14; // [esp+60h] [ebp-8h]
  int i; // [esp+64h] [ebp-4h]
  int j; // [esp+64h] [ebp-4h]

  v13 = *((_WORD *)a1 + a2 + 4);
  if ( v13 )
  {
    v12 = (unsigned __int16 *)(*a1 + 8 * a2 + 12);
    v14 = *v12;
    v11 = (float *)((char *)&unk_8527A80 + 40 * v13);
    for ( i = 0; i < a3; ++i )
      Com_Printf(" ");
    v8 = sub_80BE94C(*a1, a2);
    if ( v11[7] <= (long double)v11[8] )
    {
      if ( v11[8] <= (long double)v11[7] )
        v7 = (const char *)&unk_8148F07;
      else
        v7 = "^1";
    }
    else
    {
      v7 = "^4";
    }
    if ( v14 )
    {
      if ( *((_WORD *)v11 + 2) )
      {
        if ( (unsigned __int8)sub_80C0088(*a1, a2) )
        {
          v4 = sub_8078896(*((unsigned __int16 *)v11 + 2));
          Com_Printf(
            "%s%s: (weight) %.2f -> %.2f, (time) %.2f -> %.2f, '%s'\n",
            v7,
            v8,
            v11[8],
            v11[7],
            v11[4],
            v11[3],
            v4);
        }
        else
        {
          v5 = sub_8078896(*((unsigned __int16 *)v11 + 2));
          Com_Printf("%s%s: (weight) %.2f -> %.2f, '%s'\n", v7, v8, v11[8], v11[7], v5);
        }
      }
      else if ( (unsigned __int8)sub_80C0088(*a1, a2) )
      {
        Com_Printf("%s%s: (weight) %.2f -> %.2f, (time) %.2f -> %.2f\n", v7, v8, v11[8], v11[7], v11[4], v11[3]);
      }
      else
      {
        Com_Printf("%s%s: (weight) %.2f -> %.2f\n", v7, v8, v11[8], v11[7]);
      }
      for ( j = 0; j < v14; ++j )
        sub_80BDE00(a1, j + v12[3], a3 + 1);
    }
    else
    {
      v10 = *((_DWORD *)v12 + 1);
      v9 = v11[3] - v11[4];
      if ( v9 < 0.0 )
        v9 = v9 + 1.0;
      if ( *(float *)(v10 + 8) == 0.0 )
        v6 = 0.0;
      else
        v6 = v9 / *(float *)(v10 + 8);
      if ( *((_WORD *)v11 + 2) )
      {
        v3 = sub_8078896(*((unsigned __int16 *)v11 + 2));
        Com_Printf(
          "%s%s: (weight) %.2f -> %.2f, (time) %.2f -> %.2f, (realtimedelta) %.2f, '%s'\n",
          v7,
          v8,
          v11[8],
          v11[7],
          v11[4],
          v11[3],
          v6,
          v3);
      }
      else
      {
        Com_Printf(
          "%s%s: (weight) %.2f -> %.2f, (time) %.2f -> %.2f, (realtimedelta) %.2f\n",
          v7,
          v8,
          v11[8],
          v11[7],
          v11[4],
          v11[3],
          v6);
      }
    }
  }
}

//----- (080BE1F4) --------------------------------------------------------
void __cdecl sub_80BE1F4(int a1, int a2, float a3, int a4, int a5, int a6)
{
  float v6; // ST04_4
  float v7; // ST04_4
  float v8; // ST04_4
  float v9; // ST04_4
  float v10; // ST04_4
  float v11; // [esp+2Ch] [ebp-6Ch]
  char *v12; // [esp+30h] [ebp-68h]
  float v13; // [esp+34h] [ebp-64h]
  float v14; // [esp+38h] [ebp-60h]
  int v15; // [esp+44h] [ebp-54h]
  unsigned __int16 *v16; // [esp+48h] [ebp-50h]
  unsigned __int16 v17; // [esp+4Eh] [ebp-4Ah]
  unsigned __int16 v18; // [esp+4Eh] [ebp-4Ah]
  unsigned __int16 v19; // [esp+4Eh] [ebp-4Ah]
  unsigned __int16 v20; // [esp+4Eh] [ebp-4Ah]
  char v21; // [esp+50h] [ebp-48h]
  float v22; // [esp+70h] [ebp-28h]
  int v23; // [esp+74h] [ebp-24h]
  int v24; // [esp+78h] [ebp-20h]
  int j; // [esp+7Ch] [ebp-1Ch]
  int i; // [esp+80h] [ebp-18h]
  float v27; // [esp+84h] [ebp-14h]
  float v28; // [esp+88h] [ebp-10h]
  unsigned __int8 v29; // [esp+8Eh] [ebp-Ah]
  unsigned __int8 v30; // [esp+8Fh] [ebp-9h]

  v30 = a4;
  v29 = a5;
  v16 = (unsigned __int16 *)(*(_DWORD *)a1 + 8 * a2 + 12);
  v24 = *v16;
  if ( v24 )
  {
    for ( i = 0; ; ++i )
    {
      if ( i >= v24 )
      {
        if ( v30 )
        {
          sub_80C0F86((_DWORD *)a6);
          *(_DWORD *)(a6 + 8) = 0;
          sub_80C1040((_DWORD *)(a6 + 12));
        }
        return;
      }
      v18 = *(_WORD *)(a1 + 2 * (i + v16[3]) + 8);
      if ( v18 )
      {
        v14 = *(_BYTE *)(a1 + 7) ? *(float *)&dword_8527A9C[10 * v18] : *(float *)&dword_8527AA0[10 * v18];
        v27 = v14;
        if ( v14 != 0.0 )
          break;
      }
    }
    for ( j = i + 1; ; ++j )
    {
      if ( j >= v24 )
      {
        sub_80BE1F4(a1, i + v16[3], a3, v30, v29, a6);
        return;
      }
      v19 = *(_WORD *)(a1 + 2 * (j + v16[3]) + 8);
      if ( v19 )
      {
        v13 = *(_BYTE *)(a1 + 7) ? *(float *)&dword_8527A9C[10 * v19] : *(float *)&dword_8527AA0[10 * v19];
        v28 = v13;
        if ( v13 != 0.0 )
          break;
      }
    }
    if ( v30 )
      v12 = (char *)a6;
    else
      v12 = &v21;
    v23 = (int)v12;
    sub_80BE1F4(a1, i + v16[3], v27, 1, 1, (int)v12);
    sub_80BE1F4(a1, j++ + v16[3], v28, 0, 1, v23);
    while ( j < v24 )
    {
      v20 = *(_WORD *)(a1 + 2 * (j + v16[3]) + 8);
      if ( v20 )
      {
        v11 = *(_BYTE *)(a1 + 7) ? *(float *)&dword_8527A9C[10 * v20] : *(float *)&dword_8527AA0[10 * v20];
        v28 = v11;
        if ( v11 != 0.0 )
          sub_80BE1F4(a1, j + v16[3], v28, 0, 1, v23);
      }
      ++j;
    }
    if ( v29 )
    {
      if ( v30 )
      {
        v22 = sub_80C101E((float *)a6);
        if ( v22 != 0.0 )
        {
          v7 = sub_80C0F22(v22) * a3;
          sub_80C0FC2(a6, v7, a6);
        }
        if ( *(float *)(a6 + 8) != 0.0 )
        {
          v8 = a3 / *(float *)(a6 + 8);
          sub_80C118C(a6 + 12, v8, a6 + 12);
          *(float *)(a6 + 8) = a3;
        }
      }
      else
      {
        v22 = sub_80C101E((float *)v23);
        if ( v22 != 0.0 )
        {
          v9 = sub_80C0F22(v22) * a3;
          sub_80C0FE8(a6, v9, v23, a6);
        }
        if ( *(float *)(v23 + 8) != 0.0 )
        {
          v10 = a3 / *(float *)(v23 + 8);
          sub_80C11C4(a6 + 12, v10, v23 + 12, a6 + 12);
          *(float *)(a6 + 8) = *(float *)(a6 + 8) + a3;
        }
      }
    }
    else if ( *(float *)(a6 + 8) != 0.0 )
    {
      v6 = 1.0 / *(float *)(a6 + 8);
      sub_80C118C(a6 + 12, v6, a6 + 12);
    }
  }
  else
  {
    if ( v30 )
    {
      sub_80C0F86((_DWORD *)a6);
      *(_DWORD *)(a6 + 8) = 0;
      sub_80C1040((_DWORD *)(a6 + 12));
    }
    v15 = *((_DWORD *)v16 + 1);
    if ( *(_BYTE *)(v15 + 3) )
    {
      v17 = *(_WORD *)(a1 + 2 * a2 + 8);
      if ( v17 )
      {
        if ( *(_BYTE *)(a1 + 6) )
          sub_80BB9A8(v15, a3, *((float *)&unk_8527A80 + 10 * v17 + 3), a6);
        else
          sub_80BB82A(v15, a3, *((float *)&unk_8527A80 + 10 * v17 + 4), *((float *)&unk_8527A80 + 10 * v17 + 3), a6, 1);
      }
    }
  }
}
// 8527A9C: using guessed type int dword_8527A9C[];
// 8527AA0: using guessed type int dword_8527AA0[];

//----- (080BE760) --------------------------------------------------------
long double __cdecl sub_80BE760(int a1, int a2)
{
  return (long double)**(unsigned __int16 **)(a1 + 8 * a2 + 16) / *(float *)(*(_DWORD *)(a1 + 8 * a2 + 16) + 4);
}

//----- (080BE794) --------------------------------------------------------
signed int __cdecl sub_80BE794(int a1, int a2)
{
  return (signed int)(sub_80BE760(a1, a2) * 1000.0);
}

//----- (080BE7D2) --------------------------------------------------------
long double __cdecl sub_80BE7D2(int a1, int a2)
{
  float v3; // [esp+0h] [ebp-8h]
  unsigned __int16 v4; // [esp+6h] [ebp-2h]

  v4 = *(_WORD *)(a1 + 2 * a2 + 8);
  if ( v4 )
    v3 = *(float *)&dword_8527A8C[10 * v4];
  else
    v3 = 0.0;
  return v3;
}
// 8527A8C: using guessed type int dword_8527A8C[];

//----- (080BE816) --------------------------------------------------------
long double __cdecl sub_80BE816(int a1, int a2)
{
  float v3; // [esp+0h] [ebp-8h]
  unsigned __int16 v4; // [esp+6h] [ebp-2h]

  v4 = *(_WORD *)(a1 + 2 * a2 + 8);
  if ( v4 )
    v3 = *(float *)&dword_8527AA0[10 * v4];
  else
    v3 = 0.0;
  return v3;
}
// 8527AA0: using guessed type int dword_8527AA0[];

//----- (080BE8E4) --------------------------------------------------------
int __cdecl sub_80BE8E4(int a1, int a2)
{
  return *(unsigned __int16 *)(a1 + 8 * a2 + 12);
}

//----- (080BE8F4) --------------------------------------------------------
int __cdecl sub_80BE8F4(int a1, int a2, int a3)
{
  return a3 + *(unsigned __int16 *)(a1 + 8 * a2 + 18);
}

//----- (080BE908) --------------------------------------------------------
void *__cdecl sub_80BE908(int a1, int a2)
{
  void *v3; // [esp+0h] [ebp-8h]

  if ( *(_WORD *)(a1 + 8 * a2 + 12) )
    v3 = &unk_8148F07;
  else
    v3 = *(void **)(*(_DWORD *)(a1 + 8 * a2 + 16) + 36);
  return v3;
}

//----- (080BE940) --------------------------------------------------------
int __cdecl sub_80BE940(int a1)
{
  return *(unsigned __int8 *)(a1 + 40);
}

//----- (080BE94C) --------------------------------------------------------
char *__cdecl sub_80BE94C(int a1, int a2)
{
  char *v3; // [esp+Ch] [ebp-1Ch]
  char v4; // [esp+13h] [ebp-15h]
  char *v5; // [esp+14h] [ebp-14h]
  char *v6; // [esp+18h] [ebp-10h]
  char *v7; // [esp+20h] [ebp-8h]
  _WORD *v8; // [esp+24h] [ebp-4h]

  v8 = (_WORD *)(a1 + 8 * a2 + 12);
  if ( *(_DWORD *)(a1 + 8) )
  {
    v7 = *(char **)(*(_DWORD *)(a1 + 8) + 4 * a2);
    v4 = 0;
    if ( !*v8 && (unsigned __int8)sub_80BE940(*(_DWORD *)(a1 + 8 * a2 + 16)) )
      v4 = 1;
    if ( v4 )
      v3 = va("^3%s (missing)", v7);
    else
      v3 = v7;
    v6 = v3;
  }
  else
  {
    if ( *v8 )
      v5 = va("%i", a2);
    else
      v5 = *(char **)(*(_DWORD *)(a1 + 8 * a2 + 16) + 36);
    v6 = v5;
  }
  return v6;
}

//----- (080BEA0E) --------------------------------------------------------
int __cdecl sub_80BEA0E(int a1)
{
  return *(_DWORD *)a1;
}

//----- (080BEA18) --------------------------------------------------------
int __cdecl sub_80BEA18(int a1)
{
  return *(_DWORD *)(a1 + 4);
}

//----- (080BEA24) --------------------------------------------------------
int __cdecl sub_80BEA24(int a1, int a2, float a3)
{
  int result; // eax
  int v4; // [esp+20h] [ebp-38h]
  __int16 v5; // [esp+28h] [ebp-30h]
  int v6; // [esp+4Eh] [ebp-Ah]

  result = a1;
  if ( *(_DWORD *)a1 )
  {
    v4 = 0;
    v5 = 0;
    sub_80BCB3A(*(_DWORD *)a2, 0, (int)&v4, a3, 1, (int)&v6 + 1, (int)&v6);
    result = sub_80BC912(*(_DWORD *)a1, *(_DWORD *)a2);
  }
  return result;
}

//----- (080BEA94) --------------------------------------------------------
int __cdecl sub_80BEA94(int a1, float a2)
{
  int result; // eax
  int v3; // [esp+20h] [ebp-38h]
  __int16 v4; // [esp+28h] [ebp-30h]
  int v5; // [esp+4Eh] [ebp-Ah]

  result = a1;
  if ( *(_DWORD *)a1 )
  {
    v3 = 0;
    v4 = 0;
    result = sub_80BCB3A(*(_DWORD *)a1, 0, (int)&v3, a2, 1, (int)&v5 + 1, (int)&v5);
  }
  return result;
}

//----- (080BEAEE) --------------------------------------------------------
void __cdecl sub_80BEAEE(int a1, float a2)
{
  int v2; // [esp+20h] [ebp-38h]
  __int16 v3; // [esp+28h] [ebp-30h]
  int v4; // [esp+4Eh] [ebp-Ah]

  dword_85500A0 = 0;
  if ( *(_DWORD *)a1 )
  {
    v2 = 0;
    v3 = 0;
    sub_80BCB3A(*(_DWORD *)a1, 0, (int)&v2, a2, 1, (int)&v4 + 1, (int)&v4);
    sub_80BC52E(*(_DWORD *)a1, 0, a2, 1);
  }
}
// 85500A0: using guessed type int dword_85500A0;

//----- (080BEB76) --------------------------------------------------------
int __cdecl sub_80BEB76(int a1, float a2, int a3)
{
  signed int v4; // [esp+1Ch] [ebp-Ch]
  float v5; // [esp+20h] [ebp-8h]
  float v6; // [esp+24h] [ebp-4h]

  if ( !*(_DWORD *)a1 )
    return 0;
  if ( a3 )
  {
    v6 = sub_80BCF74(*(_DWORD *)a1, 0, a2);
    if ( v6 == 1.0 || (v5 = a2 * v6 + 0.001, a2 < (long double)v5) )
    {
      sub_80BC52E(*(_DWORD *)a1, 0, a2, 1);
      v4 = 0;
    }
    else
    {
      sub_80BC52E(*(_DWORD *)a1, 0, v5, 1);
      v4 = 1;
    }
  }
  else
  {
    sub_80BC52E(*(_DWORD *)a1, 0, a2, 0);
    v4 = 0;
  }
  return v4;
}

//----- (080BEC88) --------------------------------------------------------
int *__cdecl sub_80BEC88(int a1, int a2)
{
  int *result; // eax
  int v3; // [esp+20h] [ebp-4068h]
  int v4[4]; // [esp+4020h] [ebp-68h]
  int v5[3]; // [esp+4030h] [ebp-58h]
  int v6; // [esp+403Ch] [ebp-4Ch]
  char v7; // [esp+404Fh] [ebp-39h]
  int v8; // [esp+4050h] [ebp-38h]
  int v9; // [esp+4054h] [ebp-34h]
  int v10; // [esp+4058h] [ebp-30h]
  signed __int16 *v11; // [esp+405Ch] [ebp-2Ch]
  int j; // [esp+4060h] [ebp-28h]
  int v13; // [esp+4064h] [ebp-24h]
  int v14; // [esp+4068h] [ebp-20h]
  int i; // [esp+406Ch] [ebp-1Ch]

  result = *(int **)(a1 + 4);
  v14 = *(_DWORD *)(a1 + 4);
  v7 = 1;
  for ( i = 0; i <= 3; ++i )
  {
    v4[i] = *(_DWORD *)(v14 + 4 * i) | ~*(_DWORD *)(a2 + 4 * i);
    if ( v4[i] != -1 )
      v7 = 0;
    result = &i;
  }
  if ( !v7 )
  {
    for ( i = 0; i <= 3; ++i )
    {
      *(_DWORD *)(v14 + 4 * i) |= *(_DWORD *)(a2 + 4 * i);
      v5[i] = v4[i];
    }
    v13 = v14 + 48;
    if ( *(_DWORD *)a1 )
    {
      v6 |= 0x80000000;
      sub_80BD62C(a1, 0, 1.0, v13, 1, 0, (int)&v3, 0);
    }
    v9 = 0;
    for ( j = 0; ; ++j )
    {
      result = (int *)*(unsigned __int8 *)(a1 + 24);
      if ( j >= (signed int)result )
        break;
      v11 = **(signed __int16 ***)(a1 + 4 * j + 28);
      i = v11[1];
      while ( i )
      {
        if ( !((v4[v9 >> 5] >> (v9 & 0x1F)) & 1) )
        {
          *(_DWORD *)v13 = 0;
          *(_DWORD *)(v13 + 4) = 0;
          *(_DWORD *)(v13 + 8) = 0;
          *(_DWORD *)(v13 + 12) = 1065353216;
          sub_80C1040((_DWORD *)(v13 + 16));
        }
        --i;
        v13 += 32;
        ++v9;
      }
      v10 = *((_DWORD *)v11 + 2);
      v8 = *((_DWORD *)v11 + 1);
      i = *v11 - v11[1];
      while ( i )
      {
        if ( !((v4[v9 >> 5] >> (v9 & 0x1F)) & 1) )
        {
          sub_80C15B4(v10, 0.000030518509, v13);
          sub_80C1040((_DWORD *)(v13 + 16));
        }
        --i;
        v13 += 32;
        ++v9;
        v10 += 8;
      }
    }
  }
  return result;
}
// 80BEC88: using guessed type int var_68[4];
// 80BEC88: using guessed type int var_58[3];

//----- (080BEEE4) --------------------------------------------------------
void __cdecl sub_80BEEE4(int **a1)
{
  if ( *a1 )
  {
    sub_80BDE00(*a1, 0, 0);
    Com_Printf("\n");
  }
  else
  {
    Com_Printf("NO TREE\n");
  }
}

//----- (080BEF2C) --------------------------------------------------------
int __cdecl sub_80BEF2C(int a1, int a2, _DWORD *a3, _DWORD *a4, char a5)
{
  int v6; // [esp+20h] [ebp-38h]
  float v7; // [esp+24h] [ebp-34h]
  int v8; // [esp+2Ch] [ebp-2Ch]
  char v9; // [esp+4Fh] [ebp-9h]

  v9 = a5;
  *(_BYTE *)(a1 + 6) = 0;
  *(_BYTE *)(a1 + 7) = v9;
  sub_80BE1F4(a1, a2, 1.0, 1, 0, (int)&v6);
  if ( *(float *)&v6 == 0.0 || v7 == 0.0 )
  {
    *a3 = 0;
    a3[1] = 1065353216;
  }
  else
  {
    sub_80C0FA2(&v6, a3);
  }
  return sub_80C106A(&v8, a4);
}

//----- (080BEFE2) --------------------------------------------------------
int __cdecl sub_80BEFE2(int a1, int a2, _DWORD *a3, _DWORD *a4)
{
  int v5; // [esp+20h] [ebp-28h]
  float v6; // [esp+24h] [ebp-24h]
  int v7; // [esp+2Ch] [ebp-1Ch]

  *(_BYTE *)(a1 + 6) = 1;
  *(_BYTE *)(a1 + 7) = 1;
  sub_80BE1F4(a1, a2, 1.0, 1, 0, (int)&v5);
  if ( *(float *)&v5 != 0.0 || v6 != 0.0 )
  {
    sub_80C0FA2(&v5, a3);
  }
  else
  {
    *a3 = 0;
    a3[1] = 1065353216;
  }
  return sub_80C106A(&v7, a4);
}

//----- (080BF08C) --------------------------------------------------------
int __cdecl sub_80BF08C(int a1, int a2, int a3, int a4, float a5, float a6)
{
  int result; // eax
  int v7; // [esp+24h] [ebp-34h]
  int v8; // [esp+30h] [ebp-28h]
  float v9; // [esp+34h] [ebp-24h]
  int v10; // [esp+38h] [ebp-20h]
  int v11; // [esp+3Ch] [ebp-1Ch]

  if ( *(_WORD *)(a1 + 8 * a2 + 12) || (v7 = *(_DWORD *)(a1 + 8 * a2 + 16), !*(_BYTE *)(v7 + 3)) )
  {
    *(_DWORD *)a3 = 0;
    *(_DWORD *)(a3 + 4) = 1065353216;
    result = sub_80C1040((_DWORD *)a4);
  }
  else
  {
    sub_80C0F86(&v8);
    v10 = 0;
    sub_80C1040(&v11);
    sub_80BB82A(v7, 1.0, a5, a6, (int)&v8, 0);
    if ( *(float *)&v8 != 0.0 || v9 != 0.0 )
    {
      sub_80C0FA2(&v8, (_DWORD *)a3);
    }
    else
    {
      *(_DWORD *)a3 = 0;
      *(_DWORD *)(a3 + 4) = 1065353216;
    }
    result = sub_80C106A(&v11, (_DWORD *)a4);
  }
  return result;
}

//----- (080BF1A4) --------------------------------------------------------
int __cdecl sub_80BF1A4(int a1, int a2, int a3, int a4, float a5)
{
  int result; // eax
  int v6; // [esp+14h] [ebp-34h]
  int v7; // [esp+20h] [ebp-28h]
  float v8; // [esp+24h] [ebp-24h]
  int v9; // [esp+28h] [ebp-20h]
  int v10; // [esp+2Ch] [ebp-1Ch]

  if ( *(_WORD *)(a1 + 8 * a2 + 12) || (v6 = *(_DWORD *)(a1 + 8 * a2 + 16), !*(_BYTE *)(v6 + 3)) )
  {
    *(_DWORD *)a3 = 0;
    *(_DWORD *)(a3 + 4) = 1065353216;
    result = sub_80C1040((_DWORD *)a4);
  }
  else
  {
    sub_80C0F86(&v7);
    v9 = 0;
    sub_80C1040(&v10);
    sub_80BB9A8(v6, 1.0, a5, (int)&v7);
    if ( *(float *)&v7 != 0.0 || v8 != 0.0 )
    {
      sub_80C0FA2(&v7, (_DWORD *)a3);
    }
    else
    {
      *(_DWORD *)a3 = 0;
      *(_DWORD *)(a3 + 4) = 1065353216;
    }
    result = sub_80C106A(&v10, (_DWORD *)a4);
  }
  return result;
}

//----- (080BF2AE) --------------------------------------------------------
int __cdecl sub_80BF2AE(int a1, int a2)
{
  unsigned __int16 v3; // [esp+16h] [ebp-2h]

  v3 = word_8527A8A[0];
  if ( !word_8527A8A[0] )
    Com_Error(1, &byte_81490E0);
  word_8527A8A[0] = word_8527A8A[20 * (unsigned __int16)word_8527A8A[0]];
  word_8527A88[20 * (unsigned __int16)word_8527A8A[0]] = 0;
  *(_WORD *)(a1 + 2 * a2 + 8) = v3;
  return 40 * v3 + 139623040;
}
// 8527A88: using guessed type __int16 word_8527A88[];
// 8527A8A: using guessed type __int16 word_8527A8A[];

//----- (080BF346) --------------------------------------------------------
int __cdecl sub_80BF346(int a1, int a2, float a3)
{
  int result; // eax
  float *v4; // [esp+10h] [ebp-8h]
  unsigned __int16 v5; // [esp+16h] [ebp-2h]

  result = *(unsigned __int16 *)(a1 + 2 * a2 + 8);
  v5 = *(_WORD *)(a1 + 2 * a2 + 8);
  if ( v5 )
  {
    v4 = (float *)((char *)&unk_8527A80 + 40 * v5);
    if ( v4[7] == 0.0 )
    {
      if ( v4[6] > (long double)a3 )
        v4[6] = a3;
    }
    else
    {
      v4[6] = a3;
    }
    v4[7] = 0.0;
    if ( a3 == 0.0 )
      v4[8] = 0.0;
    result = sub_80BBA2E((int)v4);
  }
  return result;
}

//----- (080BF3FE) --------------------------------------------------------
int __cdecl sub_80BF3FE(_DWORD *a1, int a2, float a3)
{
  int result; // eax
  unsigned __int16 *v4; // [esp+Ch] [ebp-Ch]
  int i; // [esp+10h] [ebp-8h]
  int v6; // [esp+14h] [ebp-4h]

  result = a2;
  if ( *((_WORD *)a1 + a2 + 4) )
  {
    sub_80BF346((int)a1, a2, a3);
    v4 = (unsigned __int16 *)(*a1 + 8 * a2 + 12);
    v6 = *v4;
    for ( i = 0; ; ++i )
    {
      result = i;
      if ( i >= v6 )
        break;
      sub_80BF3FE(a1, i + v4[3], LODWORD(a3));
    }
  }
  return result;
}

//----- (080BF482) --------------------------------------------------------
int __cdecl sub_80BF482(_DWORD *a1, int a2, float a3)
{
  int result; // eax
  unsigned __int16 *v4; // [esp+Ch] [ebp-Ch]
  int i; // [esp+10h] [ebp-8h]
  int v6; // [esp+14h] [ebp-4h]

  v4 = (unsigned __int16 *)(*a1 + 8 * a2 + 12);
  v6 = *v4;
  for ( i = 0; ; ++i )
  {
    result = i;
    if ( i >= v6 )
      break;
    sub_80BF3FE(a1, i + v4[3], a3);
  }
  return result;
}

//----- (080BF4DC) --------------------------------------------------------
int __cdecl sub_80BF4DC(int a1, int a2, float a3, float a4)
{
  int v4; // ST3C_4
  float v5; // ST00_4
  float v6; // ST30_4
  int result; // eax
  float v8; // [esp+18h] [ebp-30h]
  float v9; // [esp+1Ch] [ebp-2Ch]
  unsigned __int16 v10; // [esp+22h] [ebp-26h]
  float v11; // [esp+28h] [ebp-20h]
  unsigned __int16 *v12; // [esp+38h] [ebp-10h]
  int v13; // [esp+40h] [ebp-8h]
  int i; // [esp+44h] [ebp-4h]
  int j; // [esp+44h] [ebp-4h]

  if ( a2 )
  {
    v4 = *(_DWORD *)a1 + 8 * a2 + 12;
    v12 = (unsigned __int16 *)(*(_DWORD *)a1 + 8 * *(unsigned __int16 *)(*(_DWORD *)a1 + 8 * a2 + 14) + 12);
    v11 = 0.0;
    v13 = *v12;
    for ( i = 0; i < v13; ++i )
    {
      v10 = *(_WORD *)(a1 + 2 * (i + v12[3]) + 8);
      if ( v10 )
        v9 = *(float *)&dword_8527AA0[10 * v10];
      else
        v9 = 0.0;
      if ( i + v12[3] == a2 )
      {
        v5 = a3 - v9;
        v8 = sub_80C0F08(v5);
      }
      else
      {
        v8 = v9;
      }
      if ( v8 > (long double)v11 )
        v11 = v8;
    }
    for ( j = 0; ; ++j )
    {
      result = j;
      if ( j >= v13 )
        break;
      if ( j + v12[3] != a2 )
      {
        v6 = v11 * a4;
        sub_80BF346(a1, j + v12[3], v6);
      }
    }
  }
  return result;
}
// 8527AA0: using guessed type int dword_8527AA0[];

//----- (080BF62C) --------------------------------------------------------
void __cdecl sub_80BF62C(int a1, int a2, float a3, float a4, int a5, int a6, int a7)
{
  if ( a3 < 0.001 )
    a3 = 0.0;
  sub_80BF4DC(a1, a2, a3, a4);
  sub_80C04C6(a1, a2, a3, SLODWORD(a4), a5, a6, 0, a7);
}

//----- (080BF6AC) --------------------------------------------------------
int __cdecl sub_80BF6AC(int a1, int a2, int a3, float a4, float a5, int a6, int a7, int a8)
{
  int v10; // [esp+24h] [ebp-4h]

  if ( a4 < 0.001 )
    a4 = 0.0;
  sub_80BF4DC(a1, a2, a4, a5);
  v10 = sub_80BFB06(a1, a2, a4, SLODWORD(a5), a6, 0, a7, 0);
  sub_80C02D8((_DWORD *)a1, a2, SLODWORD(a5));
  if ( a8 )
    sub_80C01C8((_DWORD *)a1, a2);
  while ( 1 )
  {
    if ( !a2 )
      return 1;
    a2 = *(unsigned __int16 *)(*(_DWORD *)a1 + 8 * a2 + 14);
    if ( a2 == a3 )
      break;
    sub_80BF4DC(a1, a2, 1.0, a5);
    sub_80BFB06(a1, a2, 1.0, SLODWORD(a5), 1065353216, 0, 0, 0);
    if ( a8 )
      sub_80C01C8((_DWORD *)a1, a2);
  }
  return v10;
}

//----- (080BF81E) --------------------------------------------------------
int __cdecl sub_80BF81E(int a1, int a2, float a3, float a4, int a5, int a6, int a7)
{
  if ( a3 < 0.001 )
    a3 = 0.0;
  sub_80BF4DC(a1, a2, a3, a4);
  return sub_80C0354(a1, a2, a3, SLODWORD(a4), a5, a6, 0, a7);
}

//----- (080BF89E) --------------------------------------------------------
int __cdecl sub_80BF89E(_DWORD *a1, int a2, float a3)
{
  int result; // eax
  unsigned __int16 *v4; // [esp+Ch] [ebp-Ch]
  int v5; // [esp+10h] [ebp-8h]
  int i; // [esp+14h] [ebp-4h]

  v4 = (unsigned __int16 *)(*a1 + 8 * a2 + 12);
  v5 = *v4;
  for ( i = 0; ; ++i )
  {
    result = i;
    if ( i >= v5 )
      break;
    sub_80BF346((int)a1, i + v4[3], a3);
  }
  return result;
}

//----- (080BF8F8) --------------------------------------------------------
int __cdecl sub_80BF8F8(_DWORD *a1, int a2)
{
  int result; // eax
  unsigned __int16 *v3; // [esp+8h] [ebp-10h]
  int v4; // [esp+Ch] [ebp-Ch]
  int i; // [esp+10h] [ebp-8h]
  int v6; // [esp+14h] [ebp-4h]

  result = *((unsigned __int16 *)a1 + a2 + 4);
  v4 = *((unsigned __int16 *)a1 + a2 + 4);
  if ( *((_WORD *)a1 + a2 + 4) )
  {
    v3 = (unsigned __int16 *)(*a1 + 8 * a2 + 12);
    v6 = *v3;
    for ( i = 0; i < v6; ++i )
      sub_80BF8F8(a1, i + v3[3]);
    sub_80BBA62((int)a1, v4);
    result = a2;
    *((_WORD *)a1 + a2 + 4) = 0;
  }
  return result;
}

//----- (080BF980) --------------------------------------------------------
int __cdecl sub_80BF980(int a1)
{
  int result; // eax
  int i; // [esp+18h] [ebp-10h]
  int v3; // [esp+1Ch] [ebp-Ch]
  int v4; // [esp+20h] [ebp-8h]

  v4 = *(_DWORD *)(*(_DWORD *)a1 + 4);
  v3 = a1 + 2 * v4 + 8;
  for ( i = 0; ; ++i )
  {
    result = i;
    if ( i >= v4 )
      break;
    if ( *(_WORD *)(v3 + 2 * i) )
    {
      sub_8079746(
        *(unsigned __int16 *)(v3 + 2 * i),
        *(signed __int16 *)(*(_DWORD *)(*(_DWORD *)a1 + 8 * i + 16) + 14) + 16);
      *(_WORD *)(v3 + 2 * i) = 0;
    }
  }
  return result;
}

//----- (080BFA1E) --------------------------------------------------------
int __cdecl sub_80BFA1E(_DWORD *a1)
{
  sub_80BF8F8(a1, 0);
  return sub_80BF980((int)a1);
}

//----- (080BFA44) --------------------------------------------------------
int __cdecl sub_80BFA44(_DWORD *a1, int a2)
{
  unsigned __int16 *v4; // [esp+Ch] [ebp-18h]
  signed int i; // [esp+10h] [ebp-14h]
  int v6; // [esp+14h] [ebp-10h]
  int v7; // [esp+18h] [ebp-Ch]
  float v8; // [esp+1Ch] [ebp-8h]
  float v9; // [esp+20h] [ebp-4h]

  v4 = (unsigned __int16 *)(*a1 + 8 * a2 + 12);
  if ( !*v4 )
    return a2;
  v9 = 0.0;
  v6 = 0;
  for ( i = 0; i < *v4; ++i )
  {
    v8 = *(float *)&dword_8527A9C[10 * *((unsigned __int16 *)a1 + i + v4[3] + 4)];
    if ( v9 < (long double)v8 )
    {
      v7 = sub_80BFA44(a1, i + v4[3]);
      if ( v7 )
      {
        v9 = v8;
        v6 = v7;
      }
    }
  }
  return v6;
}
// 8527A9C: using guessed type int dword_8527A9C[];

//----- (080BFB06) --------------------------------------------------------
int __cdecl sub_80BFB06(int a1, int a2, float a3, int a4, int a5, int a6, int a7, int a8)
{
  float *v10; // [esp+18h] [ebp-10h]

  if ( *(_WORD *)(a1 + 2 * a2 + 8) )
  {
    v10 = (float *)((char *)&unk_8527A80 + 40 * *(unsigned __int16 *)(a1 + 2 * a2 + 8));
    sub_80BBA2E((int)v10);
LABEL_7:
    if ( !a2 )
    {
      a3 = 1.0;
      *(float *)&a4 = 0.0;
      a5 = 1065353216;
    }
    if ( *(float *)&a4 == 0.0 )
    {
      v10[8] = a3;
    }
    else if ( v10[8] == 0.0 )
    {
      v10[8] = a3 * 0.001;
    }
    if ( a3 == 0.0 )
    {
      if ( v10[7] == 0.0 )
      {
        if ( v10[6] > (long double)*(float *)&a4 )
          v10[6] = *(float *)&a4;
      }
      else
      {
        v10[6] = *(float *)&a4;
      }
    }
    else if ( a3 < (long double)v10[8] )
    {
      v10[6] = (v10[8] - a3) * *(float *)&a4 / v10[8];
    }
    else
    {
      v10[6] = (a3 - v10[8]) * *(float *)&a4 / a3;
    }
    v10[7] = a3;
    *((_DWORD *)v10 + 9) = a5;
    *((_WORD *)v10 + 2) = a7;
    if ( a7 )
      sub_807951E(a7);
    if ( a7 && *(_WORD *)(*(_DWORD *)a1 + 8 * a2 + 12) && *(_WORD *)(*(_DWORD *)a1 + 8 * a2 + 16) & 3 )
    {
      *(_WORD *)v10 = sub_80BFA44((_DWORD *)a1, a2);
      if ( !*(_WORD *)v10 )
        return 2;
    }
    else
    {
      *(_WORD *)v10 = 0;
    }
    *((_WORD *)v10 + 3) = a8;
    return 0;
  }
  if ( a3 != 0.0 || (_BYTE)a6 )
  {
    v10 = (float *)sub_80BF2AE(a1, a2);
    sub_80BC8C8(v10);
    goto LABEL_7;
  }
  return 0;
}

//----- (080BFD38) --------------------------------------------------------
int __cdecl sub_80BFD38(int a1, int a2, int a3)
{
  int result; // eax

  result = a3;
  dword_8527AA4[10 * *(unsigned __int16 *)(a1 + 2 * a2 + 8)] = a3;
  return result;
}

//----- (080BFD6A) --------------------------------------------------------
void *__cdecl sub_80BFD6A(size_t n)
{
  return Hunk_AllocAlignInternal(n, 4);
}

//----- (080BFD86) --------------------------------------------------------
int __cdecl sub_80BFD86(_DWORD *a1, int a2, unsigned __int8 a3)
{
  int result; // eax
  char *v4; // eax
  char *v5; // eax
  char *v6; // eax
  __int16 v7; // [esp+16h] [ebp-22h]
  __int16 v8; // [esp+18h] [ebp-20h]
  int v9; // [esp+20h] [ebp-18h]
  int i; // [esp+24h] [ebp-14h]
  int v11; // [esp+28h] [ebp-10h]
  unsigned __int16 *v12; // [esp+2Ch] [ebp-Ch]

  v12 = (unsigned __int16 *)&a1[2 * a2 + 3];
  v11 = *v12;
  if ( *v12 )
  {
    if ( a1[2 * a2 + 4] & 3 )
    {
      v9 = 0;
      do
      {
        ++v9;
        v12 = (unsigned __int16 *)&a1[2 * v12[3] + 3];
      }
      while ( *v12 );
      v6 = sub_80BE94C((int)a1, a2);
      Com_Error(1, &byte_8149220, *a1, v9, v6);
    }
    v8 = a1[2 * a2 + 4];
    if ( a3 )
      v7 = v8 | 1;
    else
      v7 = v8 | 2;
    LOWORD(a1[2 * a2 + 4]) = v7;
    for ( i = 0; ; ++i )
    {
      result = i;
      if ( i >= v11 )
        break;
      sub_80BFD86(a1, i + HIWORD(a1[2 * a2 + 4]), a3);
    }
  }
  else
  {
    result = *(unsigned __int8 *)(a1[2 * a2 + 4] + 2);
    if ( (_BYTE)result != a3 )
    {
      if ( !(unsigned __int8)sub_80BE940(a1[2 * a2 + 4]) )
      {
        if ( a3 )
        {
          v4 = sub_80BE94C((int)a1, a2);
          Com_Error(1, &byte_81491A0, v4, *a1);
        }
        v5 = sub_80BE94C((int)a1, a2);
        Com_Error(1, &byte_81491E0, v5, *a1);
      }
      sub_80BA3AE("void_loop", (int)sub_80BFD6A);
      a1[2 * a2 + 4] = sub_80BA2DE("void_loop");
      result = (int)&a1[2 * a2 + 3];
      if ( !a1[2 * a2 + 4] )
        Com_Error(1, &byte_8149140, "void_loop");
    }
  }
  return result;
}

//----- (080BFF8E) --------------------------------------------------------
int __cdecl sub_80BFF8E(_DWORD *a1, int a2)
{
  int result; // eax
  int v3; // [esp+18h] [ebp-10h]
  int i; // [esp+1Ch] [ebp-Ch]
  int j; // [esp+1Ch] [ebp-Ch]
  int v6; // [esp+20h] [ebp-8h]

  result = LOWORD(a1[2 * a2 + 3]);
  v6 = LOWORD(a1[2 * a2 + 3]);
  if ( LOWORD(a1[2 * a2 + 3]) )
  {
    v3 = a1[2 * a2 + 4] & 3;
    if ( v3 )
    {
      if ( v3 == 3 )
        Com_Error(1, &byte_8149280);
      LOWORD(a1[2 * a2 + 4]) |= 4u;
      for ( i = 0; ; ++i )
      {
        result = i;
        if ( i >= v6 )
          break;
        sub_80BFD86(a1, i + HIWORD(a1[2 * a2 + 4]), v3 == 1);
      }
    }
    else
    {
      for ( j = 0; ; ++j )
      {
        result = j;
        if ( j >= v6 )
          break;
        sub_80BFF8E(a1, j + HIWORD(a1[2 * a2 + 4]));
      }
    }
  }
  return result;
}

//----- (080C006C) --------------------------------------------------------
int __cdecl sub_80C006C(_DWORD *a1)
{
  return sub_80BFF8E(a1, 0);
}

//----- (080C0088) --------------------------------------------------------
signed int __cdecl sub_80C0088(int a1, int a2)
{
  signed int v3; // [esp+0h] [ebp-8h]

  v3 = 0;
  if ( !*(_WORD *)(a1 + 8 * a2 + 12) || *(_WORD *)(a1 + 8 * a2 + 16) & 3 )
    v3 = 1;
  return v3;
}

//----- (080C00CA) --------------------------------------------------------
_BOOL4 __cdecl sub_80C00CA(int a1, int a2)
{
  return *(_WORD *)(a1 + 8 * a2 + 12) == 0;
}

//----- (080C00E2) --------------------------------------------------------
char *__cdecl sub_80C00E2(_DWORD *a1, int a2, int a3)
{
  char *result; // eax
  int v4; // ST00_4
  char *v5; // eax
  int v6; // ST04_4
  unsigned __int16 v7; // [esp+Eh] [ebp-2h]

  result = (char *)*((unsigned __int16 *)a1 + a2 + 4);
  v7 = *((_WORD *)a1 + a2 + 4);
  if ( v7 )
  {
    v4 = *a1 + 8 * a2 + 12;
    v5 = (char *)&unk_8527A80 + 40 * v7;
    v6 = (int)(v5 + 12);
    *((_DWORD *)v5 + 3) = a3;
    *(_WORD *)(v6 + 8) = 0;
    *(_DWORD *)(v6 + 4) = a3;
    *(_WORD *)(v6 + 10) = 0;
    result = (char *)&unk_8527A80 + 40 * v7;
    *((_WORD *)result + 1) = -1;
  }
  return result;
}

//----- (080C0164) --------------------------------------------------------
void __cdecl sub_80C0164(_DWORD *a1, float *a2, _WORD *a3)
{
  if ( a2[3] != 1.0 )
  {
    if ( *a3 )
    {
      if ( !*(_WORD *)a2 )
        return;
      a3 = (_WORD *)(*a1 + 8 * *(unsigned __int16 *)a2 + 12);
    }
    *((_WORD *)a2 + 1) = sub_80BBC06((int)a3, a2[3]);
  }
}

//----- (080C01C8) --------------------------------------------------------
signed int __cdecl sub_80C01C8(_DWORD *a1, int a2)
{
  signed int result; // eax
  _WORD *v3; // ST1C_4
  signed int j; // [esp+14h] [ebp-14h]
  signed int v5; // [esp+18h] [ebp-10h]
  unsigned __int16 *v6; // [esp+1Ch] [ebp-Ch]
  int i; // [esp+20h] [ebp-8h]

  for ( i = a2; i; i = *(unsigned __int16 *)(*a1 + 8 * i + 14) )
  {
    v6 = (unsigned __int16 *)(*a1 + 8 * i + 12);
    if ( *v6 && *(_WORD *)(*a1 + 8 * i + 16) & 4 )
    {
      result = sub_80BCA42((int)&unk_8527A80 + 40 * *((unsigned __int16 *)a1 + i + 4));
      if ( (_BYTE)result )
      {
        v5 = *v6;
        for ( j = 0; ; ++j )
        {
          result = j;
          if ( j >= v5 )
            break;
          sub_80BCAB4(a1, j + v6[3]);
        }
      }
      return result;
    }
  }
  v3 = (_WORD *)(*a1 + 8 * a2 + 12);
  result = (unsigned __int16)*v3;
  if ( !*v3 )
    result = sub_80BCA42(40 * *((unsigned __int16 *)a1 + a2 + 4) + 139623040);
  return result;
}

//----- (080C02D8) --------------------------------------------------------
int __cdecl sub_80C02D8(_DWORD *a1, int a2, int a3)
{
  int result; // eax
  int i; // [esp+24h] [ebp-4h]

  result = a2;
  for ( i = a2; i; result = sub_80BFB06((int)a1, i, 0.0, a3, 1065353216, 1, 0, 0) )
  {
    i = *(unsigned __int16 *)(*a1 + 8 * i + 14);
    result = i;
    if ( *((_WORD *)a1 + i + 4) )
      break;
  }
  return result;
}

//----- (080C0354) --------------------------------------------------------
int __cdecl sub_80C0354(int a1, int a2, float a3, int a4, int a5, int a6, int a7, int a8)
{
  int v9; // [esp+24h] [ebp-4h]

  if ( a3 < 0.001 )
    a3 = 0.0;
  v9 = sub_80BFB06(a1, a2, a3, a4, a5, 0, a6, a7);
  sub_80C02D8((_DWORD *)a1, a2, a4);
  if ( a8 )
    sub_80C01C8((_DWORD *)a1, a2);
  return v9;
}

//----- (080C03EA) --------------------------------------------------------
int __cdecl sub_80C03EA(int a1, int a2, int a3)
{
  return sub_80BFD38(a1, a2, a3);
}

//----- (080C040C) --------------------------------------------------------
int __cdecl sub_80C040C(int a1, int a2)
{
  int v3; // [esp+0h] [ebp-8h]

  if ( *(_WORD *)(a1 + 8 * a2 + 12) )
    v3 = *(_WORD *)(a1 + 8 * a2 + 16) & 1;
  else
    v3 = *(unsigned __int8 *)(*(_DWORD *)(a1 + 8 * a2 + 16) + 2);
  return v3;
}

//----- (080C044E) --------------------------------------------------------
signed int __cdecl sub_80C044E(int a1, int a2, int a3)
{
  signed int v5; // [esp+4h] [ebp-10h]
  unsigned __int16 *v6; // [esp+8h] [ebp-Ch]
  int v7; // [esp+Ch] [ebp-8h]

  v7 = *(_DWORD *)(a1 + 8 * a2 + 16);
  v6 = *(unsigned __int16 **)(v7 + 28);
  if ( !v6 )
    return 0;
  v5 = 0;
  while ( v5 < *(unsigned __int8 *)(v7 + 12) )
  {
    if ( *v6 == a3 )
      return 1;
    ++v5;
    v6 += 4;
  }
  return 0;
}

//----- (080C04C6) --------------------------------------------------------
void __cdecl sub_80C04C6(int a1, int a2, float a3, int a4, int a5, int a6, int a7, int a8)
{
  int v8; // [esp+20h] [ebp-8h]

  if ( a3 < 0.001 )
    a3 = 0.0;
  sub_80BFB06(a1, a2, a3, a4, a5, 0, a6, a7);
  v8 = a2;
  while ( v8 )
  {
    v8 = *(unsigned __int16 *)(*(_DWORD *)a1 + 8 * v8 + 14);
    if ( !*(_WORD *)(a1 + 2 * v8 + 8) || *(float *)&dword_8527A9C[10 * *(unsigned __int16 *)(a1 + 2 * v8 + 8)] == 0.0 )
      sub_80BFB06(a1, v8, 1.0, a4, 1065353216, 0, 0, 0);
  }
  if ( a8 )
    sub_80C01C8((_DWORD *)a1, a2);
}
// 8527A9C: using guessed type int dword_8527A9C[];

//----- (080C05DA) --------------------------------------------------------
int __cdecl sub_80C05DA(_DWORD *a1, _DWORD *a2)
{
  int result; // eax

  *a2 = *a1;
  a2[1] = a1[1];
  a2[2] = a1[2];
  a2[3] = a1[3];
  a2[4] = a1[4];
  a2[5] = a1[5];
  a2[6] = a1[6];
  a2[7] = a1[7];
  a2[8] = a1[8];
  a2[9] = a1[9];
  result = (int)a2;
  if ( *((_WORD *)a2 + 2) )
    result = sub_807951E(*((unsigned __int16 *)a2 + 2));
  return result;
}

//----- (080C063C) --------------------------------------------------------
int __cdecl sub_80C063C(int a1, int a2)
{
  int result; // eax
  int v3; // [esp+8h] [ebp-10h]
  _DWORD *v4; // [esp+Ch] [ebp-Ch]
  int v5; // [esp+10h] [ebp-8h]
  int i; // [esp+14h] [ebp-4h]

  v3 = *(_DWORD *)(*(_DWORD *)a1 + 4);
  for ( i = 0; ; ++i )
  {
    result = i;
    if ( i >= v3 )
      break;
    v5 = *(unsigned __int16 *)(a1 + 2 * i + 8);
    if ( *(_WORD *)(a1 + 2 * i + 8) )
    {
      if ( *(_WORD *)(a2 + 2 * i + 8) )
      {
        v4 = (_DWORD *)((char *)&unk_8527A80 + 40 * *(unsigned __int16 *)(a2 + 2 * i + 8));
        sub_80BBA2E((int)v4);
      }
      else
      {
        v4 = (_DWORD *)sub_80BF2AE(a2, i);
      }
      sub_80C05DA((_DWORD *)(40 * v5 + 139623040), v4);
    }
    else if ( *(_WORD *)(a2 + 2 * i + 8) )
    {
      sub_80BBA62(a2, *(unsigned __int16 *)(a2 + 2 * i + 8));
      *(_WORD *)(a2 + 2 * i + 8) = 0;
    }
  }
  return result;
}

//----- (080C072E) --------------------------------------------------------
int __cdecl sub_80C072E(_DWORD *a1, int a2)
{
  int result; // eax

  *(_DWORD *)a2 = *a1;
  *(_DWORD *)(a2 + 4) = a1[1];
  *(_DWORD *)(a2 + 8) = a1[2];
  *(_DWORD *)(a2 + 12) = a1[3];
  *(_DWORD *)(a2 + 16) = a1[4];
  *(_DWORD *)(a2 + 20) = a1[5];
  *(_DWORD *)(a2 + 24) = a1[6];
  *(_DWORD *)(a2 + 28) = a1[7];
  *(_DWORD *)(a2 + 32) = a1[8];
  *(_DWORD *)(a2 + 36) = a1[9];
  *(_WORD *)a2 = 0;
  *(_WORD *)(a2 + 2) = -1;
  result = a2;
  *(_WORD *)(a2 + 4) = 0;
  return result;
}

//----- (080C078E) --------------------------------------------------------
int __cdecl sub_80C078E(int a1, int a2)
{
  int result; // eax
  int v3; // ST0C_4
  int v4; // [esp+8h] [ebp-10h]
  unsigned __int16 v5; // [esp+12h] [ebp-6h]
  int i; // [esp+14h] [ebp-4h]

  v4 = *(_DWORD *)(*(_DWORD *)a1 + 4);
  for ( i = 0; ; ++i )
  {
    result = i;
    if ( i >= v4 )
      break;
    v5 = *(_WORD *)(a1 + 2 * i + 8);
    if ( v5 )
    {
      v3 = sub_80BF2AE(a2, i);
      sub_80C072E((_DWORD *)(40 * v5 + 139623040), v3);
    }
  }
  return result;
}

//----- (080C0820) --------------------------------------------------------
void __cdecl sub_80C0820(int a1, int a2, float a3, int a4)
{
  float v4; // [esp+20h] [ebp-8h]
  int v5; // [esp+24h] [ebp-4h]

  if ( *(_WORD *)a2 )
  {
    sub_80BB060(a1, a2 + 8, *(unsigned __int16 *)a2, &v5, &v4);
    sub_80C13AA(a4, a3, *(_DWORD *)(a2 + 4) + 4 * v5, *(_DWORD *)(a2 + 4) + 4 * v5 + 4, v4, a4);
  }
  else
  {
    sub_80C150E(a4, a3, a2 + 4, a4);
  }
}

//----- (080C08C6) --------------------------------------------------------
void __cdecl sub_80C08C6(int a1, int a2, float a3, int a4)
{
  float v4; // [esp+20h] [ebp-8h]
  int v5; // [esp+24h] [ebp-4h]

  if ( *(_WORD *)a2 )
  {
    sub_80BB060(a1, a2 + 8, *(unsigned __int16 *)a2, &v5, &v4);
    sub_80C1422(a4, a3, *(_DWORD *)(a2 + 4) + 8 * v5, *(_DWORD *)(a2 + 4) + 8 * v5 + 8, v4, a4);
  }
  else
  {
    sub_80C1544(a4, a3, a2 + 4, a4);
  }
}

//----- (080C096C) --------------------------------------------------------
void __cdecl sub_80C096C(int a1, int a2, float a3, int a4)
{
  float v4; // [esp+20h] [ebp-8h]
  int v5; // [esp+24h] [ebp-4h]

  if ( *(_WORD *)a2 )
  {
    sub_80BB060(a1, a2 + 8, *(unsigned __int16 *)a2, &v5, &v4);
    sub_80C1608(a4, a3, *(_DWORD *)(a2 + 4) + 12 * v5, *(_DWORD *)(a2 + 4) + 12 * v5 + 12, v4, a4);
  }
  else
  {
    sub_80C11C4(a4, a3, a2 + 4, a4);
  }
}

//----- (080C0A1E) --------------------------------------------------------
int __cdecl sub_80C0A1E(int a1, int a2, int a3, float a4, int a5, int a6)
{
  int result; // eax
  int v7; // [esp+10h] [ebp-38h]
  int v8; // [esp+20h] [ebp-28h]
  int v9; // [esp+24h] [ebp-24h]
  int v10; // [esp+28h] [ebp-20h]
  int v11; // [esp+2Ch] [ebp-1Ch]
  float v12; // [esp+30h] [ebp-18h]
  int *v13; // [esp+34h] [ebp-14h]
  int i; // [esp+38h] [ebp-10h]
  int v15; // [esp+3Ch] [ebp-Ch]

  v9 = *(unsigned __int16 *)a1;
  sub_80BAACE(*(float *)&a3, v9, (int)&v7);
  v12 = a4 * 0.000030518509;
  v8 = *(_DWORD *)(a1 + 20);
  v10 = *(signed __int16 *)(a1 + 14);
  for ( i = 0; ; ++i )
  {
    result = i;
    if ( i >= v10 )
      break;
    v11 = *(unsigned __int8 *)(a2 + i);
    if ( !((*(_DWORD *)(a6 + 4 * (v11 >> 5)) >> (v11 & 0x1F)) & 1) )
    {
      v15 = a5 + 32 * v11;
      v13 = (int *)(*(_DWORD *)(a1 + 24) + 8 * i);
      if ( (*(char *)((i >> 3) + v8) >> (i & 7)) & 1 )
      {
        if ( v13[1] )
          sub_80C0820((int)&v7, v13[1], v12, v15 + 8);
        else
          *(float *)(v15 + 12) = *(float *)(v15 + 12) + a4;
      }
      else
      {
        sub_80C08C6((int)&v7, v13[1], v12, v15);
      }
      if ( *v13 )
        sub_80C096C((int)&v7, *v13, a4, v15 + 16);
      *(float *)(v15 + 28) = *(float *)(v15 + 28) + a4;
    }
  }
  return result;
}

//----- (080C0B94) --------------------------------------------------------
void __cdecl sub_80C0B94(int a1, int a2, float a3, int a4)
{
  float v4; // [esp+20h] [ebp-8h]
  int v5; // [esp+24h] [ebp-4h]

  if ( *(_WORD *)a2 )
  {
    sub_80BB444(a1, a2 + 8, *(unsigned __int16 *)a2, &v5, &v4);
    sub_80C13AA(a4, a3, *(_DWORD *)(a2 + 4) + 4 * v5, *(_DWORD *)(a2 + 4) + 4 * v5 + 4, v4, a4);
  }
  else
  {
    sub_80C150E(a4, a3, a2 + 4, a4);
  }
}

//----- (080C0C3A) --------------------------------------------------------
void __cdecl sub_80C0C3A(int a1, int a2, float a3, int a4)
{
  float v4; // [esp+20h] [ebp-8h]
  int v5; // [esp+24h] [ebp-4h]

  if ( *(_WORD *)a2 )
  {
    sub_80BB444(a1, a2 + 8, *(unsigned __int16 *)a2, &v5, &v4);
    sub_80C1422(a4, a3, *(_DWORD *)(a2 + 4) + 8 * v5, *(_DWORD *)(a2 + 4) + 8 * v5 + 8, v4, a4);
  }
  else
  {
    sub_80C1544(a4, a3, a2 + 4, a4);
  }
}

//----- (080C0CE0) --------------------------------------------------------
void __cdecl sub_80C0CE0(int a1, int a2, float a3, int a4)
{
  float v4; // [esp+20h] [ebp-8h]
  int v5; // [esp+24h] [ebp-4h]

  if ( *(_WORD *)a2 )
  {
    sub_80BB444(a1, a2 + 8, *(unsigned __int16 *)a2, &v5, &v4);
    sub_80C1608(a4, a3, *(_DWORD *)(a2 + 4) + 12 * v5, *(_DWORD *)(a2 + 4) + 12 * v5 + 12, v4, a4);
  }
  else
  {
    sub_80C11C4(a4, a3, a2 + 4, a4);
  }
}

//----- (080C0D92) --------------------------------------------------------
int __cdecl sub_80C0D92(int a1, int a2, int a3, float a4, int a5, int a6)
{
  int result; // eax
  int v7; // [esp+10h] [ebp-38h]
  int v8; // [esp+20h] [ebp-28h]
  int v9; // [esp+24h] [ebp-24h]
  int v10; // [esp+28h] [ebp-20h]
  int v11; // [esp+2Ch] [ebp-1Ch]
  float v12; // [esp+30h] [ebp-18h]
  int *v13; // [esp+34h] [ebp-14h]
  int i; // [esp+38h] [ebp-10h]
  int v15; // [esp+3Ch] [ebp-Ch]

  v9 = *(unsigned __int16 *)a1;
  sub_80BAACE(*(float *)&a3, v9, (int)&v7);
  v12 = a4 * 0.000030518509;
  v8 = *(_DWORD *)(a1 + 20);
  v10 = *(signed __int16 *)(a1 + 14);
  for ( i = 0; ; ++i )
  {
    result = i;
    if ( i >= v10 )
      break;
    v11 = *(unsigned __int8 *)(a2 + i);
    if ( !((*(_DWORD *)(a6 + 4 * (v11 >> 5)) >> (v11 & 0x1F)) & 1) )
    {
      v15 = a5 + 32 * v11;
      v13 = (int *)(*(_DWORD *)(a1 + 24) + 8 * i);
      if ( (*(char *)((i >> 3) + v8) >> (i & 7)) & 1 )
      {
        if ( v13[1] )
          sub_80C0B94((int)&v7, v13[1], v12, v15 + 8);
        else
          *(float *)(v15 + 12) = *(float *)(v15 + 12) + a4;
      }
      else
      {
        sub_80C0C3A((int)&v7, v13[1], v12, v15);
      }
      if ( *v13 )
        sub_80C0CE0((int)&v7, *v13, a4, v15 + 16);
      *(float *)(v15 + 28) = *(float *)(v15 + 28) + a4;
    }
  }
  return result;
}

//----- (080C0F08) --------------------------------------------------------
long double __cdecl sub_80C0F08(float a1)
{
  return (float)fabs(a1);
}

//----- (080C0F22) --------------------------------------------------------
long double __cdecl sub_80C0F22(float a1)
{
  float v1; // ST0C_4

  v1 = a1 * 0.5;
  return (float)((1.5
                - v1 * COERCE_FLOAT(1597463007 - (SLODWORD(a1) >> 1)) * COERCE_FLOAT(1597463007 - (SLODWORD(a1) >> 1)))
               * COERCE_FLOAT(1597463007 - (SLODWORD(a1) >> 1)));
}

//----- (080C0F86) --------------------------------------------------------
int __cdecl sub_80C0F86(_DWORD *a1)
{
  int result; // eax

  *a1 = 0;
  result = 0;
  a1[1] = 0;
  return result;
}

//----- (080C0FA2) --------------------------------------------------------
int __cdecl sub_80C0FA2(_DWORD *a1, _DWORD *a2)
{
  int result; // eax

  *a2 = *a1;
  result = a1[1];
  a2[1] = result;
  return result;
}

//----- (080C0FC2) --------------------------------------------------------
int __cdecl sub_80C0FC2(int a1, float a2, int a3)
{
  int result; // eax

  *(float *)a3 = a2 * *(float *)a1;
  result = a1 + 4;
  *(float *)(a3 + 4) = a2 * *(float *)(a1 + 4);
  return result;
}

//----- (080C0FE8) --------------------------------------------------------
int __cdecl sub_80C0FE8(int a1, float a2, int a3, int a4)
{
  int result; // eax

  *(float *)a4 = a2 * *(float *)a3 + *(float *)a1;
  result = a3 + 4;
  *(float *)(a4 + 4) = a2 * *(float *)(a3 + 4) + *(float *)(a1 + 4);
  return result;
}

//----- (080C101E) --------------------------------------------------------
long double __cdecl sub_80C101E(float *a1)
{
  return *a1 * *a1 + a1[1] * a1[1];
}

//----- (080C1040) --------------------------------------------------------
int __cdecl sub_80C1040(_DWORD *a1)
{
  int result; // eax

  *a1 = 0;
  a1[1] = 0;
  result = 0;
  a1[2] = 0;
  return result;
}

//----- (080C106A) --------------------------------------------------------
int __cdecl sub_80C106A(_DWORD *a1, _DWORD *a2)
{
  int result; // eax

  *a2 = *a1;
  a2[1] = a1[1];
  result = a1[2];
  a2[2] = result;
  return result;
}

//----- (080C109A) --------------------------------------------------------
int __cdecl sub_80C109A(float *a1, float *a2, float *a3)
{
  int result; // eax

  *a3 = *a1 + *a2;
  a3[1] = a1[1] + a2[1];
  result = (int)(a1 + 2);
  a3[2] = a1[2] + a2[2];
  return result;
}

//----- (080C10DE) --------------------------------------------------------
int __cdecl sub_80C10DE(float *a1, float *a2, float *a3)
{
  int result; // eax

  *a3 = *a1 - *a2;
  a3[1] = a1[1] - a2[1];
  result = (int)(a1 + 2);
  a3[2] = a1[2] - a2[2];
  return result;
}

//----- (080C1122) --------------------------------------------------------
int __cdecl sub_80C1122(int a1, int a2, float a3, int a4)
{
  int result; // eax

  *(float *)a4 = (*(float *)a2 - *(float *)a1) * a3 + *(float *)a1;
  *(float *)(a4 + 4) = (*(float *)(a2 + 4) - *(float *)(a1 + 4)) * a3 + *(float *)(a1 + 4);
  result = a2 + 8;
  *(float *)(a4 + 8) = (*(float *)(a2 + 8) - *(float *)(a1 + 8)) * a3 + *(float *)(a1 + 8);
  return result;
}

//----- (080C118C) --------------------------------------------------------
int __cdecl sub_80C118C(int a1, float a2, int a3)
{
  int result; // eax

  *(float *)a3 = a2 * *(float *)a1;
  *(float *)(a3 + 4) = a2 * *(float *)(a1 + 4);
  result = a1 + 8;
  *(float *)(a3 + 8) = a2 * *(float *)(a1 + 8);
  return result;
}

//----- (080C11C4) --------------------------------------------------------
int __cdecl sub_80C11C4(int a1, float a2, int a3, int a4)
{
  int result; // eax

  *(float *)a4 = a2 * *(float *)a3 + *(float *)a1;
  *(float *)(a4 + 4) = a2 * *(float *)(a3 + 4) + *(float *)(a1 + 4);
  result = a3 + 8;
  *(float *)(a4 + 8) = a2 * *(float *)(a3 + 8) + *(float *)(a1 + 8);
  return result;
}

//----- (080C1218) --------------------------------------------------------
int __cdecl sub_80C1218(_DWORD *a1)
{
  int result; // eax

  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  result = 0;
  a1[3] = 0;
  return result;
}

//----- (080C124E) --------------------------------------------------------
int __cdecl sub_80C124E(int a1, float a2, int a3)
{
  int result; // eax

  *(float *)a3 = a2 * *(float *)a1;
  *(float *)(a3 + 4) = a2 * *(float *)(a1 + 4);
  *(float *)(a3 + 8) = a2 * *(float *)(a1 + 8);
  result = a1 + 12;
  *(float *)(a3 + 12) = a2 * *(float *)(a1 + 12);
  return result;
}

//----- (080C129A) --------------------------------------------------------
int __cdecl sub_80C129A(int a1, float a2, int a3, int a4)
{
  int result; // eax

  *(float *)a4 = a2 * *(float *)a3 + *(float *)a1;
  *(float *)(a4 + 4) = a2 * *(float *)(a3 + 4) + *(float *)(a1 + 4);
  *(float *)(a4 + 8) = a2 * *(float *)(a3 + 8) + *(float *)(a1 + 8);
  result = a3 + 12;
  *(float *)(a4 + 12) = a2 * *(float *)(a3 + 12) + *(float *)(a1 + 12);
  return result;
}

//----- (080C130A) --------------------------------------------------------
long double __cdecl sub_80C130A(float *a1)
{
  return *a1 * *a1 + a1[1] * a1[1] + a1[2] * a1[2] + a1[3] * a1[3];
}

//----- (080C1350) --------------------------------------------------------
int __cdecl sub_80C1350(int a1, int a2, float a3, int a4)
{
  long double v4; // fst7
  int result; // eax

  *(float *)a4 = sub_80C16D4(*(signed __int16 *)a1, *(signed __int16 *)a2, a3);
  v4 = sub_80C16D4(*(signed __int16 *)(a1 + 2), *(signed __int16 *)(a2 + 2), a3);
  result = a4 + 4;
  *(float *)(a4 + 4) = v4;
  return result;
}

//----- (080C13AA) --------------------------------------------------------
void __cdecl sub_80C13AA(int a1, float a2, int a3, int a4, float a5, int a6)
{
  *(float *)a6 = sub_80C16D4(*(signed __int16 *)a3, *(signed __int16 *)a4, a5) * a2 + *(float *)a1;
  *(float *)(a6 + 4) = sub_80C16D4(*(signed __int16 *)(a3 + 2), *(signed __int16 *)(a4 + 2), a5) * a2
                     + *(float *)(a1 + 4);
}

//----- (080C1422) --------------------------------------------------------
void __cdecl sub_80C1422(int a1, float a2, int a3, int a4, float a5, int a6)
{
  *(float *)a6 = sub_80C16D4(*(signed __int16 *)a3, *(signed __int16 *)a4, a5) * a2 + *(float *)a1;
  *(float *)(a6 + 4) = sub_80C16D4(*(signed __int16 *)(a3 + 2), *(signed __int16 *)(a4 + 2), a5) * a2
                     + *(float *)(a1 + 4);
  *(float *)(a6 + 8) = sub_80C16D4(*(signed __int16 *)(a3 + 4), *(signed __int16 *)(a4 + 4), a5) * a2
                     + *(float *)(a1 + 8);
  *(float *)(a6 + 12) = sub_80C16D4(*(signed __int16 *)(a3 + 6), *(signed __int16 *)(a4 + 6), a5) * a2
                      + *(float *)(a1 + 12);
}

//----- (080C150E) --------------------------------------------------------
int __cdecl sub_80C150E(int a1, float a2, int a3, int a4)
{
  int result; // eax

  *(float *)a4 = (long double)*(signed __int16 *)a3 * a2 + *(float *)a1;
  result = a3 + 2;
  *(float *)(a4 + 4) = (long double)*(signed __int16 *)(a3 + 2) * a2 + *(float *)(a1 + 4);
  return result;
}

//----- (080C1544) --------------------------------------------------------
int __cdecl sub_80C1544(int a1, float a2, int a3, int a4)
{
  int result; // eax

  *(float *)a4 = (long double)*(signed __int16 *)a3 * a2 + *(float *)a1;
  *(float *)(a4 + 4) = (long double)*(signed __int16 *)(a3 + 2) * a2 + *(float *)(a1 + 4);
  *(float *)(a4 + 8) = (long double)*(signed __int16 *)(a3 + 4) * a2 + *(float *)(a1 + 8);
  result = a3 + 6;
  *(float *)(a4 + 12) = (long double)*(signed __int16 *)(a3 + 6) * a2 + *(float *)(a1 + 12);
  return result;
}

//----- (080C15B4) --------------------------------------------------------
int __cdecl sub_80C15B4(int a1, float a2, int a3)
{
  int result; // eax

  *(float *)a3 = (long double)*(signed __int16 *)a1 * a2;
  *(float *)(a3 + 4) = (long double)*(signed __int16 *)(a1 + 2) * a2;
  *(float *)(a3 + 8) = (long double)*(signed __int16 *)(a1 + 4) * a2;
  result = a1 + 6;
  *(float *)(a3 + 12) = (long double)*(signed __int16 *)(a1 + 6) * a2;
  return result;
}

//----- (080C1608) --------------------------------------------------------
void __cdecl sub_80C1608(int a1, float a2, int a3, int a4, float a5, int a6)
{
  *(float *)a6 = sub_80C1706(*(float *)a3, *(float *)a4, a5) * a2 + *(float *)a1;
  *(float *)(a6 + 4) = sub_80C1706(*(float *)(a3 + 4), *(float *)(a4 + 4), a5) * a2 + *(float *)(a1 + 4);
  *(float *)(a6 + 8) = sub_80C1706(*(float *)(a3 + 8), *(float *)(a4 + 8), a5) * a2 + *(float *)(a1 + 8);
}

//----- (080C16B4) --------------------------------------------------------
int __cdecl sub_80C16B4(signed __int16 *a1, float *a2)
{
  int result; // eax

  *a2 = (long double)*a1;
  result = (int)(a1 + 1);
  a2[1] = (long double)a1[1];
  return result;
}

//----- (080C16D4) --------------------------------------------------------
long double __cdecl sub_80C16D4(int a1, int a2, float a3)
{
  return (long double)(signed __int16)a1 + (long double)((signed __int16)a2 - (signed int)(signed __int16)a1) * a3;
}

//----- (080C1706) --------------------------------------------------------
long double __cdecl sub_80C1706(float a1, float a2, float a3)
{
  return (a2 - a1) * a3 + a1;
}

//----- (080C1718) --------------------------------------------------------
signed int __cdecl sub_80C1718(const void **a1, signed __int16 *a2)
{
  float v2; // ST00_4
  long double v3; // fst7
  signed int result; // eax
  signed int v5; // [esp+10h] [ebp-28h]
  int v6; // [esp+1Ch] [ebp-1Ch]

  *a2 = sub_80C2C9E(a1);
  a2[1] = sub_80C2C9E(a1);
  a2[2] = sub_80C2C9E(a1);
  v6 = 1073676289 - (a2[2] * a2[2] + a2[1] * a2[1] + *a2 * *a2);
  if ( v6 <= 0 )
  {
    v5 = 0;
  }
  else
  {
    v2 = (long double)v6;
    v3 = sub_80C2C4E(v2);
    v5 = (signed int)floor(v3 + 0.5);
  }
  result = v5;
  a2[3] = v5;
  return result;
}

//----- (080C17FA) --------------------------------------------------------
signed int __cdecl sub_80C17FA(const void **a1, signed __int16 *a2)
{
  float v2; // ST00_4
  long double v3; // fst7
  signed int result; // eax
  signed int v5; // [esp+10h] [ebp-18h]
  int v6; // [esp+1Ch] [ebp-Ch]

  *a2 = sub_80C2C9E(a1);
  v6 = 1073676289 - *a2 * *a2;
  if ( v6 <= 0 )
  {
    v5 = 0;
  }
  else
  {
    v2 = (long double)v6;
    v3 = sub_80C2C4E(v2);
    v5 = (signed int)floor(v3 + 0.5);
  }
  result = v5;
  a2[1] = v5;
  return result;
}

//----- (080C1886) --------------------------------------------------------
signed int __cdecl sub_80C1886(int a1, char **a2, unsigned __int16 *a3, int (__cdecl *a4)(int))
{
  float v4; // ST1C_4
  signed int result; // eax
  float v6; // [esp+18h] [ebp-20h]
  int v7; // [esp+20h] [ebp-18h]
  signed int v8; // [esp+24h] [ebp-14h]
  int v9; // [esp+28h] [ebp-10h]
  int v10; // [esp+2Ch] [ebp-Ch]

  v10 = (unsigned __int8)*(*a2)++;
  *((_BYTE *)a3 + 12) = v10 + 1;
  v7 = a4(8 * *((unsigned __int8 *)a3 + 12));
  *((_DWORD *)a3 + 7) = v7;
  v9 = 0;
  while ( v9 < v10 )
  {
    *(_WORD *)v7 = sub_8079290(*a2, 0);
    *a2 += strlen(*a2) + 1;
    v8 = (unsigned __int16)sub_80C2CD4((const void **)a2);
    if ( *a3 )
    {
      v4 = (long double)v8;
      v6 = v4 / (long double)*a3;
    }
    else
    {
      v6 = 0.0;
    }
    *(float *)(v7 + 4) = v6;
    ++v9;
    v7 += 8;
  }
  *(_WORD *)v7 = sub_8079290("end", 0);
  result = 1065353216;
  *(_DWORD *)(v7 + 4) = 1065353216;
  return result;
}

//----- (080C19AE) --------------------------------------------------------
unsigned __int16 *__cdecl sub_80C19AE(int a1, int (__cdecl *a2)(int))
{
  _WORD **v2; // ebx
  _WORD **v3; // ebx
  _WORD **v4; // ebx
  _WORD **v5; // ebx
  _WORD *v6; // ebx
  _DWORD *v7; // ebx
  _DWORD *v8; // ebx
  _DWORD *v9; // ebx
  _DWORD *v10; // ebx
  _WORD *v11; // ebx
  long double v12; // fst7
  long double v13; // fst7
  long double v14; // fst7
  unsigned __int16 *v15; // ebx
  int v16; // ebx
  int v17; // esi
  _DWORD *v18; // ebx
  _DWORD *v19; // ebx
  _DWORD *v20; // ebx
  _DWORD *v21; // ebx
  _DWORD *v22; // ebx
  int v23; // ebx
  int v24; // ebx
  signed __int16 *v25; // ST34_4
  _DWORD *v26; // ebx
  _DWORD *v27; // ebx
  _DWORD *v28; // ebx
  _DWORD *v29; // ebx
  int v30; // ebx
  long double v31; // fst7
  long double v32; // fst7
  long double v33; // fst7
  float v35; // [esp+10h] [ebp-D8h]
  unsigned __int16 v36; // [esp+1Ah] [ebp-CEh]
  int v37; // [esp+1Ch] [ebp-CCh]
  unsigned __int16 *v38; // [esp+20h] [ebp-C8h]
  char v39; // [esp+26h] [ebp-C2h]
  char v40; // [esp+27h] [ebp-C1h]
  char *dest; // [esp+28h] [ebp-C0h]
  signed __int16 *v42; // [esp+34h] [ebp-B4h]
  signed __int16 *v43; // [esp+34h] [ebp-B4h]
  signed __int16 *v44; // [esp+34h] [ebp-B4h]
  signed int i; // [esp+38h] [ebp-B0h]
  signed int j; // [esp+38h] [ebp-B0h]
  signed int k; // [esp+38h] [ebp-B0h]
  signed int m; // [esp+38h] [ebp-B0h]
  signed int ii; // [esp+38h] [ebp-B0h]
  signed int jj; // [esp+38h] [ebp-B0h]
  signed int kk; // [esp+38h] [ebp-B0h]
  signed int ll; // [esp+38h] [ebp-B0h]
  size_t n; // [esp+3Ch] [ebp-ACh]
  size_t na; // [esp+3Ch] [ebp-ACh]
  size_t nb; // [esp+3Ch] [ebp-ACh]
  float v56; // [esp+40h] [ebp-A8h]
  float v57; // [esp+44h] [ebp-A4h]
  float v58; // [esp+48h] [ebp-A0h]
  int v59; // [esp+50h] [ebp-98h]
  int v60; // [esp+54h] [ebp-94h]
  bool v61; // [esp+5Fh] [ebp-89h]
  int v62; // [esp+60h] [ebp-88h]
  char v63; // [esp+65h] [ebp-83h]
  char v64; // [esp+66h] [ebp-82h]
  unsigned __int8 v65; // [esp+67h] [ebp-81h]
  __int16 v66; // [esp+68h] [ebp-80h]
  __int16 v67; // [esp+6Ah] [ebp-7Eh]
  size_t v68; // [esp+6Ch] [ebp-7Ch]
  char s; // [esp+70h] [ebp-78h]
  int l; // [esp+B4h] [ebp-34h]
  unsigned __int8 *v71; // [esp+B8h] [ebp-30h]
  void *src; // [esp+BCh] [ebp-2Ch]
  void *v73; // [esp+C0h] [ebp-28h]
  _WORD **v74; // [esp+C4h] [ebp-24h]
  _DWORD *v75; // [esp+C8h] [ebp-20h]
  unsigned __int16 v76; // [esp+CEh] [ebp-1Ah]
  int v77; // [esp+D0h] [ebp-18h]
  unsigned __int16 *v78; // [esp+D4h] [ebp-14h]
  int v79; // [esp+D8h] [ebp-10h]
  int v80; // [esp+DCh] [ebp-Ch]

  if ( Com_sprintf(&s, 0x40u, "xanim/%s", a1) >= 0 )
  {
    v80 = FS_ReadFile(&s, &v73);
    if ( v80 >= 0 )
    {
      if ( v80 )
      {
        src = v73;
        v66 = sub_80C2C9E((const void **)&src);
        if ( v66 == 14 )
        {
          LOWORD(v77) = sub_80C2C9E((const void **)&src);
          HIWORD(v77) = sub_80C2C9E((const void **)&src);
          if ( HIWORD(v77) )
            v37 = a2(2 * SHIWORD(v77));
          else
            v37 = 0;
          v79 = v37;
          v65 = *(_BYTE *)src;
          src = (char *)src + 1;
          v64 = v65 & 1;
          v63 = (v65 >> 1) & 1;
          v67 = sub_80C2C9E((const void **)&src);
          v78 = (unsigned __int16 *)a2(44);
          v78[7] = HIWORD(v77);
          *((_DWORD *)v78 + 4) = v79;
          *((float *)v78 + 1) = (long double)v67;
          *((_BYTE *)v78 + 2) = v64;
          *((_BYTE *)v78 + 3) = v63;
          if ( v64 )
            v36 = v77 + 1;
          else
            v36 = v77;
          v76 = v36;
          v61 = v36 <= 0x100u;
          *v78 = v36 - 1;
          if ( *v78 )
            v35 = *((float *)v78 + 1) / (long double)*v78;
          else
            v35 = 0.0;
          *((float *)v78 + 2) = v35;
          if ( v63 )
          {
            v74 = (_WORD **)a2(8);
            *((_DWORD *)v78 + 8) = v74;
            HIWORD(v62) = sub_80C2CD4((const void **)&src);
            if ( HIWORD(v62) )
            {
              if ( HIWORD(v62) == 1 )
              {
                sub_80C17FA((const void **)&src, (signed __int16 *)&v59);
                v2 = v74;
                v2[1] = (_WORD *)a2(8);
                *v74[1] = 0;
                *((_DWORD *)v74[1] + 1) = v59;
              }
              else
              {
                if ( HIWORD(v62) >= v76 )
                {
                  v5 = v74;
                  v5[1] = (_WORD *)a2(8);
                }
                else if ( v61 )
                {
                  v3 = v74;
                  v3[1] = (_WORD *)a2(HIWORD(v62) + 8);
                  memcpy(v74[1] + 4, src, HIWORD(v62));
                  src = (char *)src + HIWORD(v62);
                }
                else
                {
                  v4 = v74;
                  v4[1] = (_WORD *)a2(2 * HIWORD(v62) + 8);
                  memcpy(v74[1] + 4, src, 2 * HIWORD(v62));
                  src = (char *)src + 2 * HIWORD(v62);
                }
                *v74[1] = HIWORD(v62) - 1;
                v6 = v74[1];
                *((_DWORD *)v6 + 1) = a2(4 * HIWORD(v62));
                for ( i = 0; i < HIWORD(v62); ++i )
                {
                  sub_80C17FA((const void **)&src, (signed __int16 *)&v59);
                  *(_DWORD *)(*((_DWORD *)v74[1] + 1) + 4 * i) = v59;
                }
                for ( j = 1; j < HIWORD(v62); ++j )
                {
                  v42 = (signed __int16 *)(*((_DWORD *)v74[1] + 1) + 4 * j);
                  if ( v42[1] * *(v42 - 1) + *(v42 - 2) * *v42 < 0 )
                  {
                    *v42 = -*v42;
                    v42[1] = -v42[1];
                  }
                }
              }
            }
            else
            {
              v74[1] = 0;
            }
            LOWORD(v62) = sub_80C2CD4((const void **)&src);
            if ( (_WORD)v62 )
            {
              if ( (_WORD)v62 == 1 )
              {
                v56 = sub_80C2D0A((const void **)&src);
                v57 = sub_80C2D0A((const void **)&src);
                v58 = sub_80C2D0A((const void **)&src);
                v7 = v74;
                *v7 = a2(16);
                **v74 = 0;
                sub_80C2C6E(&v56, (_DWORD *)*v74 + 1);
              }
              else
              {
                if ( (unsigned __int16)v62 >= v76 )
                {
                  v10 = v74;
                  *v10 = a2(8);
                }
                else
                {
                  if ( v61 )
                  {
                    v8 = v74;
                    *v8 = a2((unsigned __int16)v62 + 8);
                    n = (unsigned __int16)v62;
                    memcpy(*v74 + 4, src, (unsigned __int16)v62);
                  }
                  else
                  {
                    v9 = v74;
                    *v9 = a2(2 * (unsigned __int16)v62 + 8);
                    n = 2 * (unsigned __int16)v62;
                    memcpy(*v74 + 4, src, 2 * (unsigned __int16)v62);
                  }
                  src = (char *)src + n;
                }
                **v74 = v62 - 1;
                v11 = *v74;
                *((_DWORD *)v11 + 1) = a2(12 * (unsigned __int16)v62);
                for ( k = 0; k < (unsigned __int16)v62; ++k )
                {
                  v12 = sub_80C2D0A((const void **)&src);
                  *(float *)(*((_DWORD *)*v74 + 1) + 12 * k) = v12;
                  v13 = sub_80C2D0A((const void **)&src);
                  *(float *)(*((_DWORD *)*v74 + 1) + 12 * k + 4) = v13;
                  v14 = sub_80C2D0A((const void **)&src);
                  *(float *)(*((_DWORD *)*v74 + 1) + 12 * k + 8) = v14;
                }
              }
            }
            else
            {
              *v74 = 0;
            }
          }
          if ( HIWORD(v77) )
          {
            v68 = ((SHIWORD(v77) - 1) >> 3) + 1;
            v71 = (unsigned __int8 *)src;
            src = (char *)src + v68;
            dest = (char *)a2(v68);
            memcpy(dest, src, v68);
            src = (char *)src + v68;
            *((_DWORD *)v78 + 5) = dest;
            v15 = v78;
            *((_DWORD *)v15 + 6) = a2(8 * SHIWORD(v77));
          }
          else
          {
            v71 = 0;
            dest = 0;
          }
          for ( l = 0; l < SHIWORD(v77); ++l )
          {
            v68 = strlen((const char *)src) + 1;
            v16 = 2 * l;
            v17 = v79;
            *(_WORD *)(v17 + v16) = sub_8078DEC(src, 0, v68);
            src = (char *)src + v68;
          }
          for ( l = 0; l < SHIWORD(v77); ++l )
          {
            v40 = ((signed int)v71[l >> 3] >> (l & 7)) & 1;
            v39 = (dest[l >> 3] >> (l & 7)) & 1;
            v75 = (_DWORD *)(*((_DWORD *)v78 + 6) + 8 * l);
            HIWORD(v62) = sub_80C2CD4((const void **)&src);
            if ( HIWORD(v62) )
            {
              if ( HIWORD(v62) == 1 )
              {
                if ( v39 )
                {
                  sub_80C17FA((const void **)&src, (signed __int16 *)&v59);
                  if ( v40 )
                  {
                    LOWORD(v59) = -(signed __int16)v59;
                    HIWORD(v59) = -HIWORD(v59);
                  }
                  v18 = v75;
                  v18[1] = a2(8);
                  *(_DWORD *)(v75[1] + 4) = v59;
                }
                else
                {
                  sub_80C1718((const void **)&src, (signed __int16 *)&v59);
                  if ( v40 )
                  {
                    LOWORD(v59) = -(signed __int16)v59;
                    HIWORD(v59) = -HIWORD(v59);
                    LOWORD(v60) = -(signed __int16)v60;
                    HIWORD(v60) = -HIWORD(v60);
                  }
                  v19 = v75;
                  v19[1] = a2(12);
                  *(_DWORD *)(v75[1] + 4) = v59;
                  *(_DWORD *)(v75[1] + 8) = v60;
                }
                *(_WORD *)v75[1] = 0;
              }
              else
              {
                if ( HIWORD(v62) >= v76 )
                {
                  v22 = v75;
                  v22[1] = a2(8);
                }
                else
                {
                  if ( v61 )
                  {
                    v20 = v75;
                    v20[1] = a2(HIWORD(v62) + 8);
                    na = HIWORD(v62);
                    memcpy((void *)(v75[1] + 8), src, HIWORD(v62));
                  }
                  else
                  {
                    v21 = v75;
                    v21[1] = a2(2 * HIWORD(v62) + 8);
                    na = 2 * HIWORD(v62);
                    memcpy((void *)(v75[1] + 8), src, 2 * HIWORD(v62));
                  }
                  src = (char *)src + na;
                }
                if ( v39 )
                {
                  v23 = v75[1];
                  *(_DWORD *)(v23 + 4) = a2(4 * HIWORD(v62));
                  sub_80C17FA((const void **)&src, (signed __int16 *)&v59);
                  if ( v40 )
                  {
                    LOWORD(v59) = -(signed __int16)v59;
                    HIWORD(v59) = -HIWORD(v59);
                  }
                  **(_DWORD **)(v75[1] + 4) = v59;
                  for ( m = 1; m < HIWORD(v62); ++m )
                  {
                    sub_80C17FA((const void **)&src, (signed __int16 *)&v59);
                    *(_DWORD *)(*(_DWORD *)(v75[1] + 4) + 4 * m) = v59;
                  }
                  for ( ii = 1; ii < HIWORD(v62); ++ii )
                  {
                    v43 = (signed __int16 *)(*(_DWORD *)(v75[1] + 4) + 4 * ii);
                    if ( v43[1] * *(v43 - 1) + *(v43 - 2) * *v43 < 0 )
                    {
                      *v43 = -*v43;
                      v43[1] = -v43[1];
                    }
                  }
                }
                else
                {
                  v24 = v75[1];
                  *(_DWORD *)(v24 + 4) = a2(8 * HIWORD(v62));
                  sub_80C1718((const void **)&src, (signed __int16 *)&v59);
                  if ( v40 )
                  {
                    LOWORD(v59) = -(signed __int16)v59;
                    HIWORD(v59) = -HIWORD(v59);
                    LOWORD(v60) = -(signed __int16)v60;
                    HIWORD(v60) = -HIWORD(v60);
                  }
                  **(_DWORD **)(v75[1] + 4) = v59;
                  *(_DWORD *)(*(_DWORD *)(v75[1] + 4) + 4) = v60;
                  for ( jj = 1; jj < HIWORD(v62); ++jj )
                  {
                    sub_80C1718((const void **)&src, (signed __int16 *)&v59);
                    *(_DWORD *)(*(_DWORD *)(v75[1] + 4) + 8 * jj) = v59;
                    *(_DWORD *)(*(_DWORD *)(v75[1] + 4) + 8 * jj + 4) = v60;
                  }
                  for ( kk = 1; kk < HIWORD(v62); ++kk )
                  {
                    v44 = (signed __int16 *)(*(_DWORD *)(v75[1] + 4) + 8 * kk);
                    v25 = v44 - 4;
                    if ( v44[1] * v25[1] + *v25 * *v44 + v44[3] * v25[3] + v25[2] * v44[2] < 0 )
                    {
                      *v44 = -*v44;
                      v44[1] = -v44[1];
                      v44[2] = -v44[2];
                      v44[3] = -v44[3];
                    }
                  }
                }
                *(_WORD *)v75[1] = HIWORD(v62) - 1;
              }
            }
            else
            {
              v75[1] = 0;
            }
            LOWORD(v62) = sub_80C2CD4((const void **)&src);
            if ( (_WORD)v62 )
            {
              if ( (_WORD)v62 == 1 )
              {
                v56 = sub_80C2D0A((const void **)&src);
                v57 = sub_80C2D0A((const void **)&src);
                v58 = sub_80C2D0A((const void **)&src);
                v26 = v75;
                *v26 = a2(16);
                *(_WORD *)*v75 = 0;
                sub_80C2C6E(&v56, (_DWORD *)(*v75 + 4));
              }
              else
              {
                if ( (unsigned __int16)v62 >= v76 )
                {
                  v29 = v75;
                  *v29 = a2(8);
                }
                else
                {
                  if ( v61 )
                  {
                    v27 = v75;
                    *v27 = a2((unsigned __int16)v62 + 8);
                    nb = (unsigned __int16)v62;
                    memcpy((void *)(*v75 + 8), src, (unsigned __int16)v62);
                  }
                  else
                  {
                    v28 = v75;
                    *v28 = a2(2 * (unsigned __int16)v62 + 8);
                    nb = 2 * (unsigned __int16)v62;
                    memcpy((void *)(*v75 + 8), src, 2 * (unsigned __int16)v62);
                  }
                  src = (char *)src + nb;
                }
                *(_WORD *)*v75 = v62 - 1;
                v30 = *v75;
                *(_DWORD *)(v30 + 4) = a2(12 * (unsigned __int16)v62);
                for ( ll = 0; ll < (unsigned __int16)v62; ++ll )
                {
                  v31 = sub_80C2D0A((const void **)&src);
                  *(float *)(*(_DWORD *)(*v75 + 4) + 12 * ll) = v31;
                  v32 = sub_80C2D0A((const void **)&src);
                  *(float *)(*(_DWORD *)(*v75 + 4) + 12 * ll + 4) = v32;
                  v33 = sub_80C2D0A((const void **)&src);
                  *(float *)(*(_DWORD *)(*v75 + 4) + 12 * ll + 8) = v33;
                }
              }
            }
            else
            {
              *v75 = 0;
            }
          }
          sub_80C1886(a1, (char **)&src, v78, a2);
          FS_FreeFile(v73);
          v38 = v78;
        }
        else
        {
          FS_FreeFile(v73);
          Com_Printf("^1ERROR: xanim '%s' out of date (version %d, expecting %d)\n", a1, v66, 14);
          v38 = 0;
        }
      }
      else
      {
        Com_Printf("^1ERROR: xanim '%s' has 0 length\n", a1);
        FS_FreeFile(v73);
        v38 = 0;
      }
    }
    else
    {
      Com_Printf("^1ERROR: xanim '%s' not found\n", a1);
      v38 = 0;
    }
  }
  else
  {
    Com_Printf("^1ERROR: filename '%s' too long\n", &s);
    v38 = 0;
  }
  return v38;
}

//----- (080C2C4E) --------------------------------------------------------
long double __cdecl sub_80C2C4E(float a1)
{
  return (float)sqrt(a1);
}

//----- (080C2C6E) --------------------------------------------------------
int __cdecl sub_80C2C6E(_DWORD *a1, _DWORD *a2)
{
  int result; // eax

  *a2 = *a1;
  a2[1] = a1[1];
  result = a1[2];
  a2[2] = result;
  return result;
}

//----- (080C2C9E) --------------------------------------------------------
int __cdecl sub_80C2C9E(const void **a1)
{
  __int16 dest; // [esp+16h] [ebp-2h]

  memcpy(&dest, *a1, 2u);
  *a1 = (char *)*a1 + 2;
  return dest;
}

//----- (080C2CD4) --------------------------------------------------------
int __cdecl sub_80C2CD4(const void **a1)
{
  unsigned __int16 dest; // [esp+16h] [ebp-2h]

  memcpy(&dest, *a1, 2u);
  *a1 = (char *)*a1 + 2;
  return dest;
}

//----- (080C2D0A) --------------------------------------------------------
long double __cdecl sub_80C2D0A(const void **a1)
{
  float dest; // [esp+14h] [ebp-4h]

  memcpy(&dest, *a1, 4u);
  *a1 = (char *)*a1 + 4;
  return dest;
}

//----- (080C2D44) --------------------------------------------------------
int __cdecl sub_80C2D44(int a1)
{
  return *(unsigned __int8 *)(a1 + 141);
}

//----- (080C2D62) --------------------------------------------------------
int __cdecl sub_80C2D62(signed __int16 *a1)
{
  int result; // eax
  int v2; // [esp+8h] [ebp-10h]
  int i; // [esp+Ch] [ebp-Ch]
  int v4; // [esp+10h] [ebp-8h]

  v4 = **((_DWORD **)a1 + 1);
  v2 = *a1;
  for ( i = 0; ; ++i )
  {
    result = i;
    if ( i >= v2 )
      break;
    sub_80796A2(*(unsigned __int16 *)(v4 + 2 * i));
  }
  return result;
}

//----- (080C2DB2) --------------------------------------------------------
int *__cdecl sub_80C2DB2(int a1)
{
  int *result; // eax
  signed int j; // [esp+10h] [ebp-8h]
  int i; // [esp+14h] [ebp-4h]

  result = (int *)sub_80C2D44(a1);
  if ( !result )
  {
    for ( i = 0; i <= 3; ++i )
    {
      if ( *(_DWORD *)(a1 + 20 * i + 16) )
      {
        for ( j = 0; j < *(signed __int16 *)(a1 + 20 * i + 12); ++j )
          sub_80796A2(*(unsigned __int16 *)(*(_DWORD *)(a1 + 20 * i + 16) + 2 * j));
        *(_DWORD *)(a1 + 20 * i + 16) = 0;
      }
      result = &i;
    }
  }
  return result;
}

//----- (080C2E74) --------------------------------------------------------
void *sub_80C2E74()
{
  unk_85500C4 = &unk_85500C0;
  *((_DWORD *)&unk_85500CC + 1) = &unk_85500C4;
  *((_DWORD *)&unk_85500CC + 2) = 0;
  *((_DWORD *)&unk_85500CC + 3) = 0;
  unk_85500CC = 1;
  *((_WORD *)&unk_85500CC + 1) = 1;
  *((_DWORD *)&unk_85500CC + 4) = &byte_855016C;
  byte_855016C = 0;
  unk_85500C0 = 0;
  return &unk_85500CC;
}
// 855016C: using guessed type char byte_855016C;

//----- (080C2EF2) --------------------------------------------------------
void *sub_80C2EF2()
{
  unk_8550130 = 0;
  return &unk_8550130;
}

//----- (080C2F0E) --------------------------------------------------------
_DWORD *__cdecl sub_80C2F0E(int a1)
{
  _DWORD *v1; // ST04_4
  _DWORD *result; // eax
  signed int i; // [esp+10h] [ebp-8h]

  *(_BYTE *)(a1 + 141) = 1;
  *(_DWORD *)a1 = sub_80C2E74();
  for ( i = 0; i <= 3; ++i )
  {
    *(_DWORD *)(a1 + 20 * i + 20) = 0;
    *(_DWORD *)(a1 + 20 * i + 8) = &unk_81493E0;
    *(_DWORD *)(a1 + 20 * i + 4) = 0;
    *(_WORD *)(a1 + 20 * i + 12) = 1;
    *(_DWORD *)(a1 + 20 * i + 16) = &word_855016E;
    word_855016E = 0;
  }
  *(_DWORD *)(a1 + 20) = sub_80C2EF2();
  *(_WORD *)(a1 + 124) = 1;
  *(_WORD *)(a1 + 126) = 0;
  *(_DWORD *)(a1 + 136) = "DEFAULT";
  dword_8550144[0] = -1048576000;
  dword_8550144[1] = -1048576000;
  dword_8550144[2] = -1048576000;
  v1 = &dword_8550144[3];
  *v1 = 1098907648;
  v1[1] = 1098907648;
  v1[2] = 1098907648;
  result = dword_8550144;
  *(_DWORD *)(a1 + 96) = dword_8550144;
  return result;
}
// 855016E: using guessed type __int16 word_855016E;

//----- (080C306A) --------------------------------------------------------
int __cdecl sub_80C306A(int (__cdecl *a1)(signed int))
{
  int v1; // ST04_4

  v1 = a1(144);
  sub_80C2F0E(v1);
  return v1;
}

//----- (080C3090) --------------------------------------------------------
int __cdecl sub_80C3090(char *s2)
{
  return sub_80A97A6(3, s2);
}

//----- (080C30AC) --------------------------------------------------------
int __cdecl sub_80C30AC(char *src, int a2, int a3)
{
  return sub_80A981E(3, src, a2, a3);
}

//----- (080C30D6) --------------------------------------------------------
int __cdecl sub_80C30D6(char *s2)
{
  return sub_80A97A6(2, s2);
}

//----- (080C30F2) --------------------------------------------------------
int __cdecl sub_80C30F2(char *src, int a2, int a3)
{
  return sub_80A981E(2, src, a2, a3);
}

//----- (080C311C) --------------------------------------------------------
int __cdecl sub_80C311C(char *s2)
{
  return sub_80A97A6(4, s2);
}

//----- (080C3138) --------------------------------------------------------
int __cdecl sub_80C3138(char *src, int a2)
{
  int v2; // ST14_4

  v2 = sub_80C306A((int (__cdecl *)(signed int))a2);
  sub_80A981E(4, src, v2, a2);
  return v2;
}

//----- (080C3172) --------------------------------------------------------
int *__cdecl sub_80C3172(_DWORD *a1, const void *a2)
{
  int *v2; // ST14_4
  int *result; // eax
  signed int j; // [esp+18h] [ebp-10h]
  int i; // [esp+1Ch] [ebp-Ch]

  if ( sub_80C2D44((int)a2) )
    Com_Error(1, "Could not load replacement model.");
  v2 = (int *)a1[34];
  sub_80C2DB2((int)a1);
  qmemcpy(a1, a2, 0x90u);
  result = v2;
  a1[34] = v2;
  for ( i = 0; i <= 3; ++i )
  {
    if ( a1[5 * i + 4] )
    {
      for ( j = 0; j < SLOWORD(a1[5 * i + 3]); ++j )
        sub_807951E(*(unsigned __int16 *)(a1[5 * i + 4] + 2 * j));
    }
    result = &i;
  }
  return result;
}

//----- (080C3264) --------------------------------------------------------
int __cdecl sub_80C3264(char *s2, int a2, int a3)
{
  int v4; // [esp+1Ch] [ebp-Ch]
  int v5; // [esp+20h] [ebp-8h]
  int v6; // [esp+20h] [ebp-8h]

  v5 = sub_80A97A6(4, s2);
  if ( v5 )
    return v5;
  v6 = sub_80C4FAA((int)s2, (int (__cdecl *)(int))a2, (int (__cdecl *)(int))a3);
  if ( v6 )
  {
    *(_DWORD *)(v6 + 136) = sub_80A981E(4, s2, v6, a2);
    v4 = v6;
  }
  else
  {
    Com_Printf("^1ERROR: Cannot find xmodel '%s'.\n", s2);
    v4 = sub_80C3138(s2, a2);
  }
  return v4;
}

//----- (080C3314) --------------------------------------------------------
int __cdecl sub_80C3314(int a1)
{
  return **(_DWORD **)(*(_DWORD *)a1 + 4);
}

//----- (080C3324) --------------------------------------------------------
int __cdecl sub_80C3324(signed __int16 **a1, int a2)
{
  int i; // [esp+10h] [ebp-4h]

  for ( i = **a1 - 1; i >= 0 && a2 != *(unsigned __int16 *)(**((_DWORD **)*a1 + 1) + 2 * i); --i )
    ;
  return i;
}

//----- (080C337C) --------------------------------------------------------
int __cdecl sub_80C337C(int a1, _DWORD *a2, _DWORD *a3)
{
  sub_80C38AC((_DWORD *)(a1 + 100), a2);
  return sub_80C38AC((_DWORD *)(a1 + 112), a3);
}

//----- (080C33CA) --------------------------------------------------------
int __cdecl sub_80C33CA(int a1)
{
  return *(_DWORD *)(a1 + 92);
}

//----- (080C33FE) --------------------------------------------------------
signed int __cdecl sub_80C33FE(int a1, int a2, int a3, float *a4, float *a5, int a6)
{
  long double v6; // fst7
  long double v7; // fst7
  long double v8; // fst7
  long double v9; // fst7
  long double v10; // fst7
  char v13; // [esp+20h] [ebp-F8h]
  float v14[4]; // [esp+50h] [ebp-C8h]
  int j; // [esp+60h] [ebp-B8h]
  int i; // [esp+64h] [ebp-B4h]
  float v17; // [esp+68h] [ebp-B0h]
  float v18; // [esp+6Ch] [ebp-ACh]
  float v19; // [esp+70h] [ebp-A8h]
  float v20; // [esp+74h] [ebp-A4h]
  float v21; // [esp+78h] [ebp-A0h]
  float v22; // [esp+7Ch] [ebp-9Ch]
  int v23; // [esp+80h] [ebp-98h]
  int v24; // [esp+90h] [ebp-88h]
  float *v25; // [esp+A4h] [ebp-74h]
  _DWORD *v26; // [esp+A8h] [ebp-70h]
  int v27; // [esp+ACh] [ebp-6Ch]
  int v28; // [esp+B0h] [ebp-68h]
  int v29; // [esp+BCh] [ebp-5Ch]
  char v30; // [esp+E0h] [ebp-38h]
  char v31; // [esp+F0h] [ebp-28h]
  float *v32; // [esp+104h] [ebp-14h]
  int v33; // [esp+108h] [ebp-10h]
  int v34; // [esp+10Ch] [ebp-Ch]

  v27 = -1;
  v33 = sub_80C54CE((signed __int16 **)a1);
  for ( i = 0; i < *(_DWORD *)(a1 + 88); ++i )
  {
    v26 = (_DWORD *)(*(_DWORD *)(a1 + 84) + 44 * i);
    if ( v26[9] & a6 )
    {
      v34 = v26[8];
      v32 = (float *)(a3 + 32 * v34);
      sub_80C38DC(a4, (float *)(a3 + 32 * v34 + 16), (float *)&v31);
      sub_80C38DC(a5, v32 + 4, (float *)&v30);
      sub_80A913C(v32, (float *)&v13);
      sub_80C3AB4((float *)&v31, (float *)&v13, (float *)&v28);
      sub_80C3AB4((float *)&v30, (float *)&v13, (float *)&v29);
      sub_805D668((int)&v28);
      if ( !sub_805D6DC((int)&v28, (int)(v26 + 2), (int)(v26 + 5), *(float *)a2) )
      {
        sub_80C38DC((float *)&v29, (float *)&v28, (float *)&v24);
        for ( j = 0; j < v26[1]; ++j )
        {
          v25 = (float *)(*v26 + 48 * j);
          v6 = sub_80C3974((float *)&v29, v25);
          v22 = v6 - v25[3];
          if ( v22 < 0.0 )
          {
            v7 = sub_80C3974((float *)&v28, v25);
            v21 = v7 - v25[3];
            if ( v21 > 0.0 )
            {
              v8 = (v21 - 0.125) / (v21 - v22);
              v20 = v8;
              sub_80C3888(v20, 0.0);
              v20 = v8;
              if ( v20 < (long double)*(float *)a2 )
              {
                v19 = v21 / (v21 - v22);
                sub_80C3920((int)&v28, v19, (int)&v24, (int)&v23);
                v9 = sub_80C3974((float *)&v23, v25 + 4);
                v18 = v9 - v25[7];
                if ( v18 >= -0.001 && v18 <= 1.001 )
                {
                  v10 = sub_80C3974((float *)&v23, v25 + 8);
                  v17 = v10 - v25[11];
                  if ( v17 >= -0.001 && v18 + v17 <= 1.001 )
                  {
                    v27 = v34;
                    *(_BYTE *)(a2 + 35) = 0;
                    *(_BYTE *)(a2 + 34) = 0;
                    *(float *)a2 = v20;
                    *(_DWORD *)(a2 + 16) = v26[10];
                    *(_DWORD *)(a2 + 20) = v26[9];
                    sub_80C38AC(v25, (_DWORD *)(a2 + 4));
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  if ( v27 < 0 )
    return -1;
  v32 = (float *)(a3 + 32 * v27);
  sub_80A913C((float *)(a3 + 32 * v27), (float *)&v13);
  sub_80C3A0A((float *)(a2 + 4), (float *)&v13, v14);
  sub_80C38AC(v14, (_DWORD *)(a2 + 4));
  return v27;
}

//----- (080C3820) --------------------------------------------------------
int __cdecl sub_80C3820(char *s1)
{
  signed int v2; // [esp+14h] [ebp-4h]

  v2 = 0;
  if ( !strncasecmp(s1, "xmodel", 6u) && (s1[6] == 47 || s1[6] == 47) )
    v2 = 1;
  return v2;
}

//----- (080C3888) --------------------------------------------------------
void __cdecl sub_80C3888(float a1, float a2)
{
  float v2; // ST00_4

  v2 = a1 - a2;
  sub_80C39A8(v2, a1, a2);
}

//----- (080C38AC) --------------------------------------------------------
int __cdecl sub_80C38AC(_DWORD *a1, _DWORD *a2)
{
  int result; // eax

  *a2 = *a1;
  a2[1] = a1[1];
  result = a1[2];
  a2[2] = result;
  return result;
}

//----- (080C38DC) --------------------------------------------------------
int __cdecl sub_80C38DC(float *a1, float *a2, float *a3)
{
  int result; // eax

  *a3 = *a1 - *a2;
  a3[1] = a1[1] - a2[1];
  result = (int)(a1 + 2);
  a3[2] = a1[2] - a2[2];
  return result;
}

//----- (080C3920) --------------------------------------------------------
int __cdecl sub_80C3920(int a1, float a2, int a3, int a4)
{
  int result; // eax

  *(float *)a4 = a2 * *(float *)a3 + *(float *)a1;
  *(float *)(a4 + 4) = a2 * *(float *)(a3 + 4) + *(float *)(a1 + 4);
  result = a3 + 8;
  *(float *)(a4 + 8) = a2 * *(float *)(a3 + 8) + *(float *)(a1 + 8);
  return result;
}

//----- (080C3974) --------------------------------------------------------
long double __cdecl sub_80C3974(float *a1, float *a2)
{
  return *a1 * *a2 + a1[1] * a2[1] + a1[2] * a2[2];
}

//----- (080C39A8) --------------------------------------------------------
long double __cdecl sub_80C39A8(float a1, float a2, float a3)
{
  float v4; // [esp+0h] [ebp-4h]

  if ( a1 < 0.0 )
    v4 = a3;
  else
    v4 = a2;
  return v4;
}

//----- (080C3A0A) --------------------------------------------------------
int __cdecl sub_80C3A0A(float *a1, float *a2, float *a3)
{
  int result; // eax

  *a3 = *a1 * *a2 + a1[1] * a2[3] + a1[2] * a2[6];
  a3[1] = *a1 * a2[1] + a1[1] * a2[4] + a1[2] * a2[7];
  result = (int)(a1 + 2);
  a3[2] = *a1 * a2[2] + a1[1] * a2[5] + a1[2] * a2[8];
  return result;
}

//----- (080C3AB4) --------------------------------------------------------
int __cdecl sub_80C3AB4(float *a1, float *a2, float *a3)
{
  int result; // eax

  *a3 = *a1 * *a2 + a1[1] * a2[1] + a1[2] * a2[2];
  a3[1] = *a1 * a2[3] + a1[1] * a2[4] + a1[2] * a2[5];
  result = (int)(a1 + 2);
  a3[2] = *a1 * a2[6] + a1[1] * a2[7] + a1[2] * a2[8];
  return result;
}

//----- (080C3B60) --------------------------------------------------------
signed int __cdecl sub_80C3B60(const void **a1, signed __int16 *a2)
{
  float v2; // ST00_4
  long double v3; // fst7
  signed int result; // eax
  signed int v5; // [esp+10h] [ebp-28h]
  int v6; // [esp+1Ch] [ebp-1Ch]

  *a2 = sub_80C2C9E(a1);
  a2[1] = sub_80C2C9E(a1);
  a2[2] = sub_80C2C9E(a1);
  v6 = 1073676289 - (a2[2] * a2[2] + a2[1] * a2[1] + *a2 * *a2);
  if ( v6 <= 0 )
  {
    v5 = 0;
  }
  else
  {
    v2 = (long double)v6;
    v3 = sub_80C51F0(v2);
    v5 = (signed int)floor(v3 + 0.5);
  }
  result = v5;
  a2[3] = v5;
  return result;
}

//----- (080C3C42) --------------------------------------------------------
void *__cdecl sub_80C3C42(signed __int16 *a1)
{
  float v2; // [esp+10h] [ebp-38h]
  float v3; // [esp+14h] [ebp-34h]
  float v4; // [esp+18h] [ebp-30h]
  float v5; // [esp+1Ch] [ebp-2Ch]
  unsigned __int8 *v6; // [esp+24h] [ebp-24h]
  float *v7; // [esp+28h] [ebp-20h]
  int v8; // [esp+2Ch] [ebp-1Ch]
  int v9; // [esp+30h] [ebp-18h]
  float *v10; // [esp+34h] [ebp-14h]
  signed __int16 *v11; // [esp+38h] [ebp-10h]
  int v12; // [esp+3Ch] [ebp-Ch]

  v9 = *((_DWORD *)a1 + 1);
  v6 = (unsigned __int8 *)(v9 + 4);
  v8 = *a1;
  v11 = (signed __int16 *)*((_DWORD *)a1 + 2);
  v10 = (float *)*((_DWORD *)a1 + 3);
  v7 = (float *)(a1 + 34);
  v12 = a1[1];
  while ( v12 )
  {
    sub_80C5210(v7);
    v7[3] = 1.0;
    sub_80C5210((_DWORD *)v7 + 4);
    v7[7] = 2.0;
    --v12;
    v7 += 8;
  }
  v12 = v8 - a1[1];
  while ( v12 )
  {
    v2 = (long double)*v11 * 0.000030518509;
    v3 = (long double)v11[1] * 0.000030518509;
    v4 = (long double)v11[2] * 0.000030518509;
    v5 = (long double)v11[3] * 0.000030518509;
    sub_80A5372(&v2, &v7[-8 * *v6], v7);
    sub_80B9D76((signed int)v7);
    sub_80A9094(v10, &v7[-8 * *v6], v7 + 4);
    --v12;
    v11 += 4;
    v10 += 3;
    v7 += 8;
    ++v6;
  }
  memset(a1 + 10, 255, 0x10u);
  return memset(a1 + 26, 255, 0x10u);
}

//----- (080C3DE8) --------------------------------------------------------
int __cdecl sub_80C3DE8(int a1, int a2, int (__cdecl *a3)(int))
{
  int v3; // ST18_4
  int *v4; // ST44_4
  int v5; // ST18_4
  int v6; // ebx
  int v7; // ebx
  int v8; // ebx
  char v9; // ST24_1
  size_t n; // ST28_4
  int v12; // [esp+10h] [ebp-98h]
  signed int v13; // [esp+14h] [ebp-94h]
  signed __int16 *v14; // [esp+1Ch] [ebp-8Ch]
  __int16 v15; // [esp+22h] [ebp-86h]
  float *v16; // [esp+2Ch] [ebp-7Ch]
  signed int v17; // [esp+30h] [ebp-78h]
  signed int i; // [esp+30h] [ebp-78h]
  __int16 v19; // [esp+36h] [ebp-72h]
  __int16 v20; // [esp+38h] [ebp-70h]
  __int16 v21; // [esp+3Ah] [ebp-6Eh]
  _BYTE *v22; // [esp+3Ch] [ebp-6Ch]
  int v23; // [esp+40h] [ebp-68h]
  void *src; // [esp+48h] [ebp-60h]
  void *v25; // [esp+4Ch] [ebp-5Ch]
  char s; // [esp+50h] [ebp-58h]
  int v27; // [esp+9Ch] [ebp-Ch]

  if ( Com_sprintf(&s, 0x40u, "xmodelparts/%s", a2) >= 0 )
  {
    v13 = FS_ReadFile(&s, &v25);
    if ( v13 >= 0 )
    {
      if ( v13 )
      {
        src = v25;
        v15 = sub_80C2C9E((const void **)&src);
        if ( v15 == 20 )
        {
          v19 = sub_80C2C9E((const void **)&src);
          v20 = sub_80C2C9E((const void **)&src);
          v21 = v20 + v19;
          v3 = 2 * (signed __int16)(v20 + v19);
          v23 = a3(v3);
          *(_DWORD *)(a1 + 132) += v3;
          if ( (signed __int16)(v20 + v19) <= 127 )
          {
            v4 = (int *)a3(v19 + 7);
            *(_DWORD *)(a1 + 132) += v19 + 7;
            *v4 = v23;
            v22 = v4 + 1;
            v5 = 32 * v21 + 68;
            v27 = a3(v5);
            *(_DWORD *)(a1 + 132) += v5;
            *(_DWORD *)(v27 + 4) = v4;
            if ( v19 )
            {
              v6 = v27;
              *(_DWORD *)(v6 + 8) = a3(8 * v19);
              *(_DWORD *)(a1 + 132) += 8 * v19;
              v7 = v27;
              *(_DWORD *)(v7 + 12) = a3(16 * v19);
              *(_DWORD *)(a1 + 132) += 16 * v19;
            }
            else
            {
              *(_DWORD *)(v27 + 8) = 0;
              *(_DWORD *)(v27 + 12) = 0;
            }
            v8 = v27;
            *(_DWORD *)(v8 + 16) = a3(v21);
            *(_DWORD *)(a1 + 132) += v21;
            *(_WORD *)v27 = v21;
            *(_WORD *)(v27 + 2) = v20;
            v14 = *(signed __int16 **)(v27 + 8);
            v16 = *(float **)(v27 + 12);
            v17 = v20;
            while ( v17 < v21 )
            {
              v9 = *(_BYTE *)src;
              src = (char *)src + 1;
              *v22 = v17 - v9;
              *v16 = sub_80C2D0A((const void **)&src);
              v16[1] = sub_80C2D0A((const void **)&src);
              v16[2] = sub_80C2D0A((const void **)&src);
              sub_80C3B60((const void **)&src, v14);
              ++v17;
              v14 += 4;
              v16 += 3;
              ++v22;
            }
            for ( i = 0; i < v21; ++i )
            {
              n = I_strlen((char *)src) + 1;
              *(_WORD *)(v23 + 2 * i) = sub_8078DEC(src, 0, n);
              src = (char *)src + n;
            }
            memcpy(*(void **)(v27 + 16), src, v21);
            src = (char *)src + v21;
            FS_FreeFile(v25);
            sub_80C3C42((signed __int16 *)v27);
            v12 = v27;
          }
          else
          {
            FS_FreeFile(v25);
            Com_Printf("^1ERROR: xmodel '%s' has more than %d bones\n", a2, 127);
            v12 = 0;
          }
        }
        else
        {
          FS_FreeFile(v25);
          Com_Printf("^1ERROR: xmodelparts '%s' out of date (version %d, expecting %d).\n", a2, v15, 20);
          v12 = 0;
        }
      }
      else
      {
        Com_Printf("^1ERROR: xmodelparts '%s' has 0 length\n", a2);
        FS_FreeFile(v25);
        v12 = 0;
      }
    }
    else
    {
      Com_Printf("^1ERROR: xmodelparts '%s' not found\n", a2);
      v12 = 0;
    }
  }
  else
  {
    Com_Printf("^1ERROR: filename '%s' too long\n", &s);
    v12 = 0;
  }
  return v12;
}

//----- (080C4280) --------------------------------------------------------
signed int __cdecl sub_80C4280(int a1, const void **a2, int a3)
{
  signed int v4; // [esp+14h] [ebp-14h]
  __int16 v5; // [esp+1Ah] [ebp-Eh]
  signed int i; // [esp+1Ch] [ebp-Ch]

  v5 = sub_80C2C9E(a2);
  if ( v5 == 20 )
  {
    *(_BYTE *)(a3 + 4140) = *(_BYTE *)*a2;
    *a2 = (char *)*a2 + 1;
    *(float *)(a3 + 4112) = sub_80C2D0A(a2);
    *(float *)(a3 + 4116) = sub_80C2D0A(a2);
    *(float *)(a3 + 4120) = sub_80C2D0A(a2);
    *(float *)(a3 + 4124) = sub_80C2D0A(a2);
    *(float *)(a3 + 4128) = sub_80C2D0A(a2);
    *(float *)(a3 + 4132) = sub_80C2D0A(a2);
    for ( i = 0; i <= 3; ++i )
    {
      *(float *)(a3 + 1028 * i + 1024) = sub_80C2D0A(a2);
      strcpy((char *)(a3 + 1028 * i), (const char *)*a2);
      *a2 = (char *)*a2 + strlen((const char *)*a2) + 1;
    }
    *(_DWORD *)(a3 + 4136) = sub_80C53E0(a2);
    v4 = 1;
  }
  else
  {
    Com_Printf("^1ERROR: xmodel '%s' out of date (version %d, expecting %d).\n", a1, v5, 20);
    v4 = 0;
  }
  return v4;
}

//----- (080C43F4) --------------------------------------------------------
_DWORD *__cdecl sub_80C43F4(const void **a1, _DWORD *a2, int (__cdecl *a3)(int))
{
  _DWORD *result; // eax
  int v4; // ebx
  float *v5; // ST0C_4
  float *v6; // ebx
  int j; // [esp+4h] [ebp-14h]
  signed int i; // [esp+8h] [ebp-10h]
  int v9; // [esp+10h] [ebp-8h]

  a2[22] = sub_80C53E0(a1);
  result = a2;
  if ( a2[22] )
  {
    a2[21] = a3(44 * a2[22]);
    for ( i = 0; ; ++i )
    {
      result = (_DWORD *)i;
      if ( i >= a2[22] )
        break;
      v9 = a2[21] + 44 * i;
      v4 = a2[21] + 44 * i;
      *(_DWORD *)(v4 + 4) = sub_80C53E0(a1);
      *(_DWORD *)v9 = a3(48 * *(_DWORD *)(v9 + 4));
      for ( j = 0; j < *(_DWORD *)(v9 + 4); ++j )
      {
        v5 = (float *)(*(_DWORD *)v9 + 48 * j);
        v6 = (float *)(*(_DWORD *)v9 + 48 * j);
        *v6 = sub_80C2D0A(a1);
        v5[1] = sub_80C2D0A(a1);
        v5[2] = sub_80C2D0A(a1);
        v5[3] = sub_80C2D0A(a1);
        v5[4] = sub_80C2D0A(a1);
        v5[5] = sub_80C2D0A(a1);
        v5[6] = sub_80C2D0A(a1);
        v5[7] = sub_80C2D0A(a1);
        v5[8] = sub_80C2D0A(a1);
        v5[9] = sub_80C2D0A(a1);
        v5[10] = sub_80C2D0A(a1);
        v5[11] = sub_80C2D0A(a1);
      }
      *(float *)(v9 + 8) = sub_80C2D0A(a1) - 0.001;
      *(float *)(v9 + 12) = sub_80C2D0A(a1) - 0.001;
      *(float *)(v9 + 16) = sub_80C2D0A(a1) - 0.001;
      *(float *)(v9 + 20) = sub_80C2D0A(a1) + 0.001;
      *(float *)(v9 + 24) = sub_80C2D0A(a1) + 0.001;
      *(float *)(v9 + 28) = sub_80C2D0A(a1) + 0.001;
      *(_DWORD *)(v9 + 32) = sub_80C53E0(a1);
      *(_DWORD *)(v9 + 36) = sub_80C53E0(a1) & 0xDFFFFFFB;
      *(_DWORD *)(v9 + 40) = sub_80C53E0(a1);
      a2[23] |= *(_DWORD *)(v9 + 36);
    }
  }
  return result;
}

//----- (080C468A) --------------------------------------------------------
int __cdecl sub_80C468A(int a1, char *s2, int a3)
{
  int v4; // [esp+10h] [ebp-8h]
  int v5; // [esp+14h] [ebp-4h]
  int v6; // [esp+14h] [ebp-4h]

  v5 = sub_80C3090(s2);
  if ( v5 )
    return v5;
  v6 = sub_80C3DE8(a1, (int)s2, (int (__cdecl *)(int))a3);
  if ( v6 )
  {
    sub_80C30AC(s2, v6, a3);
    v4 = v6;
  }
  else
  {
    Com_Printf("^1ERROR: Cannot find xmodelparts '%s'.\n", s2);
    v4 = 0;
  }
  return v4;
}

//----- (080C470E) --------------------------------------------------------
int __cdecl sub_80C470E(int a1, int (__cdecl *a2)(int), int (__cdecl *a3)(int))
{
  int v3; // ebx
  int v4; // ST18_4
  int v5; // esi
  int v6; // ebx
  int v7; // ST18_4
  _DWORD *v8; // ebx
  size_t v9; // eax
  int v10; // ebx
  int v11; // esi
  _DWORD *v12; // ebx
  long double v13; // fst7
  long double v14; // fst7
  long double v15; // fst7
  long double v16; // fst7
  long double v17; // fst7
  long double v18; // fst7
  int v19; // esi
  int v21; // [esp+10h] [ebp-10F8h]
  signed int v22; // [esp+14h] [ebp-10F4h]
  int v23; // [esp+1Ch] [ebp-10ECh]
  char v24; // [esp+20h] [ebp-10E8h]
  float *v25; // [esp+38h] [ebp-10D0h]
  float *v26; // [esp+3Ch] [ebp-10CCh]
  float *v27; // [esp+40h] [ebp-10C8h]
  int v28; // [esp+44h] [ebp-10C4h]
  char *s; // [esp+48h] [ebp-10C0h]
  char *v30; // [esp+4Ch] [ebp-10BCh]
  char v31; // [esp+50h] [ebp-10B8h]
  int j; // [esp+9Ch] [ebp-106Ch]
  int i; // [esp+A0h] [ebp-1068h]
  int v34; // [esp+A4h] [ebp-1064h]
  char *dest; // [esp+A8h] [ebp-1060h]
  char *v36; // [esp+ACh] [ebp-105Ch]
  int v37[7]; // [esp+B0h] [ebp-1058h]
  int v38; // [esp+CCh] [ebp-103Ch]
  char v39[4136]; // [esp+D0h] [ebp-1038h]
  char _10E0[4136]; // [esp+10E0h] [ebp-28h]
  char _10EC[4136]; // [esp+10ECh] [ebp-1Ch]
  int v42; // [esp+10F8h] [ebp-10h]
  char v43; // [esp+10FCh] [ebp-Ch]
  char v44[8]; // [esp+1100h] [ebp-8h]

  if ( Com_sprintf(&v31, 0x40u, "xmodel/%s", a1) >= 0 )
  {
    v22 = FS_ReadFile(&v31, &v30);
    if ( v22 >= 0 )
    {
      if ( v22 )
      {
        v36 = v30;
        if ( (unsigned __int8)sub_80C4280(a1, (const void **)&v36, (int)v39) )
        {
          v34 = 0;
          for ( i = 0; i <= 3; ++i )
          {
            v3 = i;
            v37[v3] = I_strlen(&v39[1028 * i]) + 1;
            v34 += v37[i];
          }
          v4 = v34 + 144;
          v38 = a2(v34 + 144);
          *(_DWORD *)(v38 + 132) = v4;
          sub_80C43F4((const void **)&v36, (_DWORD *)v38, a3);
          dest = (char *)(v38 + 144);
          *(_WORD *)(v38 + 124) = 0;
          for ( i = 0; i <= 3; ++i )
          {
            strcpy(dest, &v39[1028 * i]);
            *(_DWORD *)(v38 + 20 * i + 8) = dest;
            if ( *dest )
            {
              ++*(_WORD *)(v38 + 124);
              v5 = v38;
              v6 = 20 * i;
              *(_WORD *)(v5 + v6 + 12) = sub_80C2C9E((const void **)&v36);
              v7 = 2 * *(signed __int16 *)(v38 + 20 * i + 12);
              v8 = (_DWORD *)(v38 + 20 * i + 16);
              *v8 = a2(2 * *(signed __int16 *)(v38 + 20 * i + 12));
              *(_DWORD *)(v38 + 132) += v7;
              for ( j = 0; j < *(signed __int16 *)(v38 + 20 * i + 12); ++j )
              {
                s = v36;
                v9 = strlen(v36);
                v36 += v9 + 1;
                v10 = 2 * j;
                v11 = *(_DWORD *)(v38 + 20 * i + 16);
                *(_WORD *)(v11 + v10) = sub_8079290(s, 0);
              }
            }
            else
            {
              *(_DWORD *)(v38 + 20 * i + 16) = 0;
            }
            *(_DWORD *)(v38 + 20 * i + 4) = *(_DWORD *)&v44[1028 * i - 3120];
            dest += v37[i];
          }
          v12 = (_DWORD *)v38;
          *v12 = sub_80C468A(v38, *(char **)(v38 + 8), (int)a2);
          if ( *(_DWORD *)v38 )
          {
            v28 = **(signed __int16 **)v38;
            v23 = a2(40 * v28);
            *(_DWORD *)(v38 + 132) += 40 * v28;
            for ( i = 0; i < v28; ++i )
            {
              v27 = (float *)(v23 + 40 * i);
              v13 = sub_80C2D0A((const void **)&v36);
              *v27 = v13;
              v14 = sub_80C2D0A((const void **)&v36);
              v27[1] = v14;
              v15 = sub_80C2D0A((const void **)&v36);
              v27[2] = v15;
              v26 = (float *)(v23 + 40 * i + 12);
              v16 = sub_80C2D0A((const void **)&v36);
              *v26 = v16;
              v17 = sub_80C2D0A((const void **)&v36);
              v26[1] = v17;
              v18 = sub_80C2D0A((const void **)&v36);
              v26[2] = v18;
              v25 = (float *)(v23 + 40 * i + 24);
              sub_80C52D2(v27, v26, v25);
              sub_80C528E(v26, v25, (float *)&v24);
              v19 = 40 * i;
              *(float *)(v23 + v19 + 36) = sub_80C532E((float *)&v24);
            }
            *(_DWORD *)(v38 + 96) = v23;
            FS_FreeFile(v30);
            sub_80C525E(_10E0, (_DWORD *)(v38 + 100));
            sub_80C525E(_10EC, (_DWORD *)(v38 + 112));
            *(_WORD *)(v38 + 126) = v42;
            *(_BYTE *)(v38 + 140) = v43;
            v21 = v38;
          }
          else
          {
            FS_FreeFile(v30);
            sub_80C2DB2(v38);
            v21 = 0;
          }
        }
        else
        {
          FS_FreeFile(v30);
          v21 = 0;
        }
      }
      else
      {
        Com_Printf("^1ERROR: xmodel '%s' has 0 length\n", a1);
        FS_FreeFile(v30);
        v21 = 0;
      }
    }
    else
    {
      Com_Printf("^1ERROR: xmodel '%s' not found\n", a1);
      v21 = 0;
    }
  }
  else
  {
    Com_Printf("^1ERROR: filename '%s' too long\n", &v31);
    v21 = 0;
  }
  return v21;
}
// 80C470E: using guessed type char var_1038[4136];
// 80C470E: using guessed type int var_1058[7];
// 80C470E: using guessed type char var_8[8];

//----- (080C4E50) --------------------------------------------------------
int sub_80C4E50()
{
  return 0;
}

//----- (080C4E5A) --------------------------------------------------------
int sub_80C4E5A()
{
  return 0;
}

//----- (080C4E74) --------------------------------------------------------
int __cdecl sub_80C4E74(int a1, char *s2, int a3, int a4, int a5)
{
  int v6; // [esp+1Ch] [ebp-Ch]
  int v7; // [esp+20h] [ebp-8h]
  int v8; // [esp+20h] [ebp-8h]

  v7 = sub_80C30D6(s2);
  if ( v7 )
    return v7;
  v8 = sub_80C4E5A();
  if ( v8 )
  {
    sub_80C30F2(s2, v8, a3);
    v6 = v8;
  }
  else
  {
    Com_Printf("^1ERROR: Cannot find 'xmodelsurfs '%s'.\n", s2, a3, (signed __int16)a4, a5);
    v6 = 0;
  }
  return v6;
}

//----- (080C4F0E) --------------------------------------------------------
signed int __cdecl sub_80C4F0E(int a1, int a2)
{
  signed int i; // [esp+20h] [ebp-8h]

  for ( i = 0; i <= 3 && **(_BYTE **)(a1 + 20 * i + 8); ++i )
  {
    *(_DWORD *)(a1 + 20 * i + 20) = sub_80C4E74(
                                      a1,
                                      *(char **)(a1 + 20 * i + 8),
                                      a2,
                                      *(signed __int16 *)(a1 + 20 * i + 12),
                                      *(_DWORD *)(a1 + 136));
    if ( !*(_DWORD *)(a1 + 20 * i + 20) )
      return 0;
  }
  return 1;
}

//----- (080C4FAA) --------------------------------------------------------
int __cdecl sub_80C4FAA(int a1, int (__cdecl *a2)(int), int (__cdecl *a3)(int))
{
  int v5; // [esp+14h] [ebp-4h]

  v5 = sub_80C470E(a1, a2, a3);
  if ( !v5 )
    return 0;
  if ( !(unsigned __int8)sub_80C4E50() || (unsigned __int8)sub_80C4F0E(v5, (int)a2) )
    return v5;
  sub_80C2DB2(v5);
  return 0;
}

//----- (080C501A) --------------------------------------------------------
signed int __cdecl sub_80C501A(int a1, float *a2, _DWORD *a3, _DWORD *a4)
{
  float v5; // [esp+10h] [ebp-48h]
  float v6; // [esp+14h] [ebp-44h]
  float v7; // [esp+18h] [ebp-40h]
  float v9[4]; // [esp+20h] [ebp-38h]
  float v10; // [esp+30h] [ebp-28h]
  float v11; // [esp+34h] [ebp-24h]
  float v12; // [esp+38h] [ebp-20h]
  int j; // [esp+40h] [ebp-18h]
  int k; // [esp+44h] [ebp-14h]
  int i; // [esp+48h] [ebp-10h]
  float *v16; // [esp+4Ch] [ebp-Ch]

  if ( !*(_DWORD *)(a1 + 88) )
    return 0;
  sub_80C523A(a3, 2139095039, 2139095039, 2139095039);
  sub_80C523A(a4, -8388609, -8388609, -8388609);
  for ( i = 0; i < *(_DWORD *)(a1 + 88); ++i )
  {
    v16 = (float *)(*(_DWORD *)(a1 + 84) + 44 * i);
    for ( j = 0; j <= 7; ++j )
    {
      if ( j & 1 )
        v7 = v16[2];
      else
        v7 = v16[5];
      v10 = v7;
      if ( j & 2 )
        v6 = v16[3];
      else
        v6 = v16[6];
      v11 = v6;
      if ( j & 4 )
        v5 = v16[4];
      else
        v5 = v16[7];
      v12 = v5;
      sub_80A4E52(&v10, a2, v9);
      for ( k = 0; k <= 2; ++k )
      {
        if ( *(float *)&a3[k] > (long double)v9[k] )
          a3[k] = LODWORD(v9[k]);
        if ( v9[k] > (long double)*(float *)&a4[k] )
          a4[k] = LODWORD(v9[k]);
      }
    }
  }
  return 1;
}
// 80C501A: using guessed type float var_38[4];

//----- (080C51F0) --------------------------------------------------------
long double __cdecl sub_80C51F0(float a1)
{
  return (float)sqrt(a1);
}

//----- (080C5210) --------------------------------------------------------
int __cdecl sub_80C5210(_DWORD *a1)
{
  int result; // eax

  *a1 = 0;
  a1[1] = 0;
  result = 0;
  a1[2] = 0;
  return result;
}

//----- (080C523A) --------------------------------------------------------
int __cdecl sub_80C523A(_DWORD *a1, int a2, int a3, int a4)
{
  int result; // eax

  *a1 = a2;
  a1[1] = a3;
  result = a4;
  a1[2] = a4;
  return result;
}

//----- (080C525E) --------------------------------------------------------
int __cdecl sub_80C525E(_DWORD *a1, _DWORD *a2)
{
  int result; // eax

  *a2 = *a1;
  a2[1] = a1[1];
  result = a1[2];
  a2[2] = result;
  return result;
}

//----- (080C528E) --------------------------------------------------------
int __cdecl sub_80C528E(float *a1, float *a2, float *a3)
{
  int result; // eax

  *a3 = *a1 - *a2;
  a3[1] = a1[1] - a2[1];
  result = (int)(a1 + 2);
  a3[2] = a1[2] - a2[2];
  return result;
}

//----- (080C52D2) --------------------------------------------------------
int __cdecl sub_80C52D2(float *a1, float *a2, float *a3)
{
  int result; // eax

  *a3 = (*a1 + *a2) * 0.5;
  a3[1] = (a1[1] + a2[1]) * 0.5;
  result = (int)(a1 + 2);
  a3[2] = (a1[2] + a2[2]) * 0.5;
  return result;
}

//----- (080C532E) --------------------------------------------------------
long double __cdecl sub_80C532E(float *a1)
{
  return *a1 * *a1 + a1[1] * a1[1] + a1[2] * a1[2];
}

//----- (080C53E0) --------------------------------------------------------
int __cdecl sub_80C53E0(const void **a1)
{
  int dest; // [esp+14h] [ebp-4h]

  memcpy(&dest, *a1, 4u);
  *a1 = (char *)*a1 + 4;
  return dest;
}

//----- (080C5414) --------------------------------------------------------
int __cdecl sub_80C5414(int a1)
{
  return *(_DWORD *)(a1 + 136);
}

//----- (080C5432) --------------------------------------------------------
const char *__cdecl sub_80C5432(int a1, int a2, int a3)
{
  const char *v4; // [esp+10h] [ebp-8h]
  unsigned __int16 v5; // [esp+16h] [ebp-2h]

  v5 = *(_WORD *)(*(_DWORD *)(a1 + 20 * a3 + 16) + 2 * a2);
  if ( v5 )
    v4 = (const char *)sub_8078896(v5);
  else
    v4 = "DEFAULT";
  return v4;
}

//----- (080C5482) --------------------------------------------------------
int __cdecl sub_80C5482(int a1, _DWORD *a2, int a3, _DWORD *a4)
{
  *a2 = **(_DWORD **)(a1 + 20 * a3 + 20);
  *a4 = *(_DWORD *)(a1 + 20 * a3 + 20) + 4;
  return *(signed __int16 *)(a1 + 20 * a3 + 12);
}

//----- (080C54C2) --------------------------------------------------------
int __cdecl sub_80C54C2(int a1)
{
  return *(signed __int16 *)(a1 + 124);
}

//----- (080C54CE) --------------------------------------------------------
int __cdecl sub_80C54CE(signed __int16 **a1)
{
  return **a1;
}

//----- (080C54DC) --------------------------------------------------------
int __cdecl sub_80C54DC(_DWORD *a1)
{
  return *a1 + 68;
}

//----- (080C5506) --------------------------------------------------------
long double __cdecl sub_80C5506(int a1)
{
  float v2; // [esp+10h] [ebp-8h]
  int v3; // [esp+14h] [ebp-4h]

  v3 = sub_80C54C2(a1) - 1;
  if ( byte_8550180[8 * v3] )
    v2 = flt_8550184[2 * v3];
  else
    v2 = *(float *)(a1 + 20 * v3 + 4);
  return v2;
}

//----- (080C5556) --------------------------------------------------------
int __cdecl sub_80C5556(int a1, float a2)
{
  float v3; // [esp+10h] [ebp-18h]
  int i; // [esp+1Ch] [ebp-Ch]
  int v6; // [esp+20h] [ebp-8h]

  v6 = sub_80C54C2(a1);
  for ( i = 0; i < v6; ++i )
  {
    if ( byte_8550180[8 * i] )
      v3 = flt_8550184[2 * i];
    else
      v3 = *(float *)(a1 + 4 + 20 * i);
    if ( v3 == 0.0 || v3 > (long double)a2 )
      return i;
  }
  return -1;
}

//----- (080C5628) --------------------------------------------------------
int __cdecl sub_80C5628(unsigned int a1, unsigned __int8 *a2, unsigned int a3)
{
  int v3; // ST10_4
  int v4; // ST0C_4
  int v5; // ST10_4
  int v6; // ST0C_4
  int v7; // ST10_4
  int v8; // ST0C_4
  int v9; // ST10_4
  int v10; // ST0C_4
  int v11; // ST10_4
  int v12; // ST0C_4
  int v13; // ST10_4
  int v14; // ST0C_4
  int v15; // ST10_4
  int v16; // ST0C_4
  int v17; // ST10_4
  int v18; // ST0C_4
  int v19; // ST10_4
  int v20; // ST0C_4
  int v21; // ST10_4
  int v22; // ST0C_4
  int v23; // ST10_4
  int v24; // ST0C_4
  int v25; // ST10_4
  int v26; // ST0C_4
  int v27; // ST10_4
  int v28; // ST0C_4
  int v29; // ST10_4
  int v30; // ST0C_4
  int v31; // ST10_4
  int v32; // ST0C_4
  signed int v34; // [esp+0h] [ebp-14h]
  signed int v36; // [esp+8h] [ebp-Ch]
  unsigned int v37; // [esp+Ch] [ebp-8h]
  unsigned int v38; // [esp+10h] [ebp-4h]

  v38 = (unsigned __int16)a1;
  v37 = a1 >> 16;
  if ( !a2 )
    return 1;
  while ( a3 )
  {
    v34 = a3;
    if ( a3 > 0x15B0 )
      v34 = 5552;
    v36 = v34;
    a3 -= v34;
    while ( v36 > 15 )
    {
      v3 = *a2 + v38;
      v4 = v3 + v37;
      v5 = a2[1] + v3;
      v6 = v5 + v4;
      v7 = a2[2] + v5;
      v8 = v7 + v6;
      v9 = a2[3] + v7;
      v10 = v9 + v8;
      v11 = a2[4] + v9;
      v12 = v11 + v10;
      v13 = a2[5] + v11;
      v14 = v13 + v12;
      v15 = a2[6] + v13;
      v16 = v15 + v14;
      v17 = a2[7] + v15;
      v18 = v17 + v16;
      v19 = a2[8] + v17;
      v20 = v19 + v18;
      v21 = a2[9] + v19;
      v22 = v21 + v20;
      v23 = a2[10] + v21;
      v24 = v23 + v22;
      v25 = a2[11] + v23;
      v26 = v25 + v24;
      v27 = a2[12] + v25;
      v28 = v27 + v26;
      v29 = a2[13] + v27;
      v30 = v29 + v28;
      v31 = a2[14] + v29;
      v32 = v31 + v30;
      v38 = a2[15] + v31;
      v37 = v38 + v32;
      a2 += 16;
      v36 -= 16;
    }
    for ( ; v36; --v36 )
    {
      v38 += *a2++;
      v37 += v38;
    }
    v38 %= 0xFFF1u;
    v37 %= 0xFFF1u;
  }
  return v38 | (v37 << 16);
}

//----- (080C5874) --------------------------------------------------------
signed int __cdecl sub_80C5874(int a1, int *a2, int a3, int a4, signed int a5)
{
  signed int v6; // [esp+14h] [ebp-54h]
  signed int v7; // [esp+18h] [ebp-50h]
  signed int v8; // [esp+1Ch] [ebp-4Ch]
  signed int v9; // [esp+1Ch] [ebp-4Ch]
  int v10; // [esp+20h] [ebp-48h]
  int v11; // [esp+24h] [ebp-44h]
  int v12; // [esp+2Ch] [ebp-3Ch]
  int v13; // [esp+30h] [ebp-38h]
  int v14; // [esp+34h] [ebp-34h]
  int v15; // [esp+40h] [ebp-28h]
  int v16; // [esp+44h] [ebp-24h]
  int v17; // [esp+48h] [ebp-20h]

  v10 = a3;
  v11 = a4;
  v12 = a1;
  v13 = *a2;
  if ( v13 != *a2 )
    return -5;
  v15 = 0;
  v16 = 0;
  v17 = 0;
  v8 = sub_80C5988(&v10, a5, "1.1.4", 56);
  if ( v8 )
    return v8;
  v9 = sub_80C620B((int)&v10, 4);
  if ( v9 == 1 )
  {
    *a2 = v14;
    v7 = sub_80C65F4((int)&v10);
  }
  else
  {
    sub_80C65F4((int)&v10);
    v6 = v9;
    if ( !v9 )
      v6 = -5;
    v7 = v6;
  }
  return v7;
}

//----- (080C5988) --------------------------------------------------------
signed int __cdecl sub_80C5988(_DWORD *a1, signed int a2, _BYTE *a3, int a4)
{
  return sub_80C59D0(a1, a2, 8, 15, 8, 0, a3, a4);
}

//----- (080C59D0) --------------------------------------------------------
signed int __cdecl sub_80C59D0(_DWORD *a1, signed int a2, int a3, int a4, signed int a5, signed int a6, _BYTE *a7, int a8)
{
  signed int v9; // [esp+14h] [ebp-14h]
  int v10; // [esp+18h] [ebp-10h]
  signed int v11; // [esp+1Ch] [ebp-Ch]
  int v12; // [esp+20h] [ebp-8h]

  v11 = 0;
  if ( !a7 || *a7 != *off_8162D84 || a8 != 56 )
    return -6;
  if ( !a1 )
    return -2;
  a1[6] = 0;
  if ( !a1[8] )
  {
    a1[8] = sub_80D1096;
    a1[10] = 0;
  }
  if ( !a1[9] )
    a1[9] = sub_80D10AD;
  if ( a2 == -1 )
    a2 = 6;
  if ( a4 < 0 )
  {
    v11 = 1;
    a4 = -a4;
  }
  if ( a5 <= 0 || a5 > 9 || a3 != 8 || a4 <= 8 || a4 > 15 || a2 < 0 || a2 > 9 || a6 < 0 || a6 > 2 )
    return -2;
  v12 = ((int (__cdecl *)(_DWORD, signed int, signed int))a1[8])(a1[10], 1, 5816);
  if ( !v12 )
    return -4;
  a1[7] = v12;
  *(_DWORD *)v12 = a1;
  *(_DWORD *)(v12 + 24) = v11;
  *(_DWORD *)(v12 + 40) = a4;
  *(_DWORD *)(v12 + 36) = 1 << *(_BYTE *)(v12 + 40);
  *(_DWORD *)(v12 + 44) = *(_DWORD *)(v12 + 36) - 1;
  *(_DWORD *)(v12 + 72) = a5 + 7;
  *(_DWORD *)(v12 + 68) = 1 << *(_BYTE *)(v12 + 72);
  *(_DWORD *)(v12 + 76) = *(_DWORD *)(v12 + 68) - 1;
  *(_DWORD *)(v12 + 80) = (*(_DWORD *)(v12 + 72) + 2) / 3u;
  *(_DWORD *)(v12 + 48) = ((int (__cdecl *)(_DWORD, _DWORD, signed int))a1[8])(a1[10], *(_DWORD *)(v12 + 36), 2);
  *(_DWORD *)(v12 + 56) = ((int (__cdecl *)(_DWORD, _DWORD, signed int))a1[8])(a1[10], *(_DWORD *)(v12 + 36), 2);
  *(_DWORD *)(v12 + 60) = ((int (__cdecl *)(_DWORD, _DWORD, signed int))a1[8])(a1[10], *(_DWORD *)(v12 + 68), 2);
  *(_DWORD *)(v12 + 5780) = 1 << (a5 + 6);
  v10 = ((int (__cdecl *)(_DWORD, _DWORD, signed int))a1[8])(a1[10], *(_DWORD *)(v12 + 5780), 4);
  *(_DWORD *)(v12 + 8) = v10;
  *(_DWORD *)(v12 + 12) = 4 * *(_DWORD *)(v12 + 5780);
  if ( *(_DWORD *)(v12 + 48) && *(_DWORD *)(v12 + 56) && *(_DWORD *)(v12 + 60) && *(_DWORD *)(v12 + 8) )
  {
    *(_DWORD *)(v12 + 5788) = v10 + 2 * (*(_DWORD *)(v12 + 5780) >> 1);
    *(_DWORD *)(v12 + 5776) = *(_DWORD *)(v12 + 8) + 3 * *(_DWORD *)(v12 + 5780);
    *(_DWORD *)(v12 + 124) = a2;
    *(_DWORD *)(v12 + 128) = a6;
    *(_BYTE *)(v12 + 29) = 8;
    v9 = sub_80C5ECE(a1);
  }
  else
  {
    a1[6] = off_8163F58[0];
    sub_80C65F4((int)a1);
    v9 = -4;
  }
  return v9;
}
// 8162D84: using guessed type char *off_8162D84;
// 8163F58: using guessed type char *off_8163F58[3];

//----- (080C5ECE) --------------------------------------------------------
signed int __cdecl sub_80C5ECE(_DWORD *a1)
{
  signed int v2; // [esp+8h] [ebp-10h]
  _DWORD *v4; // [esp+14h] [ebp-4h]

  if ( !a1 || !a1[7] || !a1[8] || !a1[9] )
    return -2;
  a1[5] = 0;
  a1[2] = 0;
  a1[6] = 0;
  a1[11] = 2;
  v4 = (_DWORD *)a1[7];
  v4[5] = 0;
  v4[4] = v4[2];
  if ( v4[6] < 0 )
    v4[6] = 0;
  if ( v4[6] )
    v2 = 113;
  else
    v2 = 42;
  v4[1] = v2;
  a1[12] = 1;
  v4[8] = 0;
  sub_80CC47D((int)v4);
  sub_80C6AC0((int)v4);
  return 0;
}

//----- (080C6104) --------------------------------------------------------
int __cdecl sub_80C6104(int a1, __int16 a2)
{
  int result; // eax

  *(_BYTE *)(*(_DWORD *)(a1 + 8) + (*(_DWORD *)(a1 + 20))++) = HIBYTE(a2);
  result = (unsigned __int8)a2;
  *(_BYTE *)(*(_DWORD *)(a1 + 8) + (*(_DWORD *)(a1 + 20))++) = a2;
  return result;
}

//----- (080C613D) --------------------------------------------------------
size_t __cdecl sub_80C613D(int a1)
{
  size_t result; // eax
  size_t n; // [esp+14h] [ebp-4h]

  n = *(_DWORD *)(*(_DWORD *)(a1 + 28) + 20);
  result = n;
  if ( n > *(_DWORD *)(a1 + 16) )
  {
    result = *(_DWORD *)(a1 + 16);
    n = *(_DWORD *)(a1 + 16);
  }
  if ( n )
  {
    memcpy(*(void **)(a1 + 12), *(const void **)(*(_DWORD *)(a1 + 28) + 16), n);
    *(_DWORD *)(a1 + 12) += n;
    *(_DWORD *)(*(_DWORD *)(a1 + 28) + 16) += n;
    *(_DWORD *)(a1 + 20) += n;
    *(_DWORD *)(a1 + 16) -= n;
    *(_DWORD *)(*(_DWORD *)(a1 + 28) + 20) -= n;
    result = *(_DWORD *)(a1 + 28);
    if ( !*(_DWORD *)(result + 20) )
    {
      result = *(_DWORD *)(*(_DWORD *)(a1 + 28) + 8);
      *(_DWORD *)(*(_DWORD *)(a1 + 28) + 16) = result;
    }
  }
  return result;
}

//----- (080C620B) --------------------------------------------------------
signed int __cdecl sub_80C620B(int a1, int a2)
{
  unsigned int v4; // [esp+14h] [ebp-14h]
  int v5; // [esp+14h] [ebp-14h]
  int v6; // [esp+18h] [ebp-10h]
  int v7; // [esp+1Ch] [ebp-Ch]
  int v8; // [esp+20h] [ebp-8h]

  if ( !a1 || !*(_DWORD *)(a1 + 28) || a2 > 4 || a2 < 0 )
    return -2;
  v7 = *(_DWORD *)(a1 + 28);
  if ( !*(_DWORD *)(a1 + 12) || !*(_DWORD *)a1 && *(_DWORD *)(a1 + 4) || *(_DWORD *)(v7 + 4) == 666 && a2 != 4 )
  {
    *(char **)(a1 + 24) = off_8163F50[0];
    return -2;
  }
  if ( !*(_DWORD *)(a1 + 16) )
  {
    *(char **)(a1 + 24) = off_8163F5C[0];
    return -5;
  }
  *(_DWORD *)v7 = a1;
  v8 = *(_DWORD *)(v7 + 32);
  *(_DWORD *)(v7 + 32) = a2;
  if ( *(_DWORD *)(v7 + 4) == 42 )
  {
    v4 = (*(_DWORD *)(v7 + 124) - 1) >> 1;
    if ( v4 > 3 )
      v4 = 3;
    v6 = (v4 << 6) | ((16 * (*(_DWORD *)(v7 + 40) - 8) + 8) << 8);
    if ( *(_DWORD *)(v7 + 100) )
      v6 |= 0x20u;
    *(_DWORD *)(v7 + 4) = 113;
    sub_80C6104(
      v7,
      31
    * ((unsigned int)(((unsigned int)v6 * (unsigned __int64)(unsigned int)&unk_8421085 >> 32)
                    + ((unsigned int)(v6 - ((unsigned int)v6 * (unsigned __int64)(unsigned int)&unk_8421085 >> 32)) >> 1)) >> 4)
    + 31);
    if ( *(_DWORD *)(v7 + 100) )
    {
      sub_80C6104(v7, *(_DWORD *)(a1 + 48) >> 16);
      sub_80C6104(v7, *(_WORD *)(a1 + 48));
    }
    *(_DWORD *)(a1 + 48) = 1;
  }
  if ( *(_DWORD *)(v7 + 20) )
  {
    sub_80C613D(a1);
    if ( !*(_DWORD *)(a1 + 16) )
    {
      *(_DWORD *)(v7 + 32) = -1;
      return 0;
    }
  }
  else if ( !*(_DWORD *)(a1 + 4) && a2 <= v8 && a2 != 4 )
  {
    *(char **)(a1 + 24) = off_8163F5C[0];
    return -5;
  }
  if ( *(_DWORD *)(v7 + 4) == 666 && *(_DWORD *)(a1 + 4) )
  {
    *(char **)(a1 + 24) = off_8163F5C[0];
    return -5;
  }
  if ( !*(_DWORD *)(a1 + 4) && !*(_DWORD *)(v7 + 108) && (!a2 || *(_DWORD *)(v7 + 4) == 666) )
    goto LABEL_51;
  v5 = off_81497A8[3 * *(_DWORD *)(v7 + 124)](v7, a2);
  if ( v5 == 2 || v5 == 3 )
    *(_DWORD *)(v7 + 4) = 666;
  if ( v5 && v5 != 2 )
  {
    if ( v5 == 1 )
    {
      if ( a2 == 1 )
      {
        sub_80CE10F(v7);
      }
      else
      {
        sub_80CDFE1(v7, 0, 0, 0);
        if ( a2 == 3 )
        {
          *(_WORD *)(*(_DWORD *)(v7 + 60) + 2 * *(_DWORD *)(v7 + 68) - 2) = 0;
          memset(*(void **)(v7 + 60), 0, 2 * *(_DWORD *)(v7 + 68) - 2);
        }
      }
      sub_80C613D(a1);
      if ( !*(_DWORD *)(a1 + 16) )
      {
        *(_DWORD *)(v7 + 32) = -1;
        return 0;
      }
    }
LABEL_51:
    if ( a2 != 4 )
      return 0;
    if ( *(_DWORD *)(v7 + 24) )
      return 1;
    sub_80C6104(v7, *(_DWORD *)(a1 + 48) >> 16);
    sub_80C6104(v7, *(_WORD *)(a1 + 48));
    sub_80C613D(a1);
    *(_DWORD *)(v7 + 24) = -1;
    return *(_DWORD *)(v7 + 20) == 0;
  }
  if ( !*(_DWORD *)(a1 + 16) )
    *(_DWORD *)(v7 + 32) = -1;
  return 0;
}
// 8163F50: using guessed type char *off_8163F50[5];
// 8163F5C: using guessed type char *off_8163F5C[2];

//----- (080C65F4) --------------------------------------------------------
signed int __cdecl sub_80C65F4(int a1)
{
  signed int v2; // [esp+Ch] [ebp-Ch]
  int v4; // [esp+14h] [ebp-4h]

  if ( !a1 || !*(_DWORD *)(a1 + 28) )
    return -2;
  v4 = *(_DWORD *)(*(_DWORD *)(a1 + 28) + 4);
  if ( v4 != 42 && v4 != 113 && v4 != 666 )
    return -2;
  if ( *(_DWORD *)(*(_DWORD *)(a1 + 28) + 8) )
    (*(void (__cdecl **)(_DWORD, _DWORD))(a1 + 36))(*(_DWORD *)(a1 + 40), *(_DWORD *)(*(_DWORD *)(a1 + 28) + 8));
  if ( *(_DWORD *)(*(_DWORD *)(a1 + 28) + 60) )
    (*(void (__cdecl **)(_DWORD, _DWORD))(a1 + 36))(*(_DWORD *)(a1 + 40), *(_DWORD *)(*(_DWORD *)(a1 + 28) + 60));
  if ( *(_DWORD *)(*(_DWORD *)(a1 + 28) + 56) )
    (*(void (__cdecl **)(_DWORD, _DWORD))(a1 + 36))(*(_DWORD *)(a1 + 40), *(_DWORD *)(*(_DWORD *)(a1 + 28) + 56));
  if ( *(_DWORD *)(*(_DWORD *)(a1 + 28) + 48) )
    (*(void (__cdecl **)(_DWORD, _DWORD))(a1 + 36))(*(_DWORD *)(a1 + 40), *(_DWORD *)(*(_DWORD *)(a1 + 28) + 48));
  (*(void (__cdecl **)(_DWORD, _DWORD))(a1 + 36))(*(_DWORD *)(a1 + 40), *(_DWORD *)(a1 + 28));
  *(_DWORD *)(a1 + 28) = 0;
  if ( v4 == 113 )
    v2 = -3;
  else
    v2 = 0;
  return v2;
}

//----- (080C6A0C) --------------------------------------------------------
unsigned int __cdecl sub_80C6A0C(int a1, void *dest, int a3)
{
  unsigned int n; // [esp+10h] [ebp-8h]

  n = *(_DWORD *)(a1 + 4);
  if ( n > a3 )
    n = a3;
  if ( !n )
    return 0;
  *(_DWORD *)(a1 + 4) -= n;
  if ( !*(_DWORD *)(*(_DWORD *)(a1 + 28) + 24) )
    *(_DWORD *)(a1 + 48) = sub_80C5628(*(_DWORD *)(a1 + 48), *(unsigned __int8 **)a1, n);
  memcpy(dest, *(const void **)a1, n);
  *(_DWORD *)a1 += n;
  *(_DWORD *)(a1 + 8) += n;
  return n;
}

//----- (080C6AC0) --------------------------------------------------------
int __cdecl sub_80C6AC0(int a1)
{
  int result; // eax

  *(_DWORD *)(a1 + 52) = 2 * *(_DWORD *)(a1 + 36);
  *(_WORD *)(*(_DWORD *)(a1 + 60) + 2 * *(_DWORD *)(a1 + 68) - 2) = 0;
  memset(*(void **)(a1 + 60), 0, 2 * *(_DWORD *)(a1 + 68) - 2);
  *(_DWORD *)(a1 + 120) = (unsigned __int16)word_81497A2[6 * *(_DWORD *)(a1 + 124)];
  *(_DWORD *)(a1 + 132) = (unsigned __int16)word_81497A0[6 * *(_DWORD *)(a1 + 124)];
  *(_DWORD *)(a1 + 136) = (unsigned __int16)word_81497A4[6 * *(_DWORD *)(a1 + 124)];
  *(_DWORD *)(a1 + 116) = (unsigned __int16)word_81497A6[6 * *(_DWORD *)(a1 + 124)];
  *(_DWORD *)(a1 + 100) = 0;
  *(_DWORD *)(a1 + 84) = 0;
  *(_DWORD *)(a1 + 108) = 0;
  *(_DWORD *)(a1 + 112) = 2;
  *(_DWORD *)(a1 + 88) = 2;
  *(_DWORD *)(a1 + 96) = 0;
  result = a1;
  *(_DWORD *)(a1 + 64) = 0;
  return result;
}
// 81497A0: using guessed type __int16 word_81497A0[];
// 81497A2: using guessed type __int16 word_81497A2[];
// 81497A4: using guessed type __int16 word_81497A4[];
// 81497A6: using guessed type __int16 word_81497A6[];

//----- (080C6BCD) --------------------------------------------------------
int __cdecl sub_80C6BCD(_DWORD *a1, unsigned int a2)
{
  char v3; // [esp+2h] [ebp-32h]
  char v4; // [esp+3h] [ebp-31h]
  unsigned int v5; // [esp+4h] [ebp-30h]
  unsigned int v6; // [esp+8h] [ebp-2Ch]
  int v7; // [esp+Ch] [ebp-28h]
  _BYTE *v8; // [esp+10h] [ebp-24h]
  _BYTE *v9; // [esp+10h] [ebp-24h]
  _BYTE *v10; // [esp+10h] [ebp-24h]
  _BYTE *v11; // [esp+10h] [ebp-24h]
  _BYTE *v12; // [esp+10h] [ebp-24h]
  _BYTE *v13; // [esp+10h] [ebp-24h]
  _BYTE *v14; // [esp+10h] [ebp-24h]
  _BYTE *v15; // [esp+10h] [ebp-24h]
  _BYTE *v16; // [esp+10h] [ebp-24h]
  _BYTE *v17; // [esp+10h] [ebp-24h]
  _BYTE *v18; // [esp+14h] [ebp-20h]
  _BYTE *v19; // [esp+14h] [ebp-20h]
  int v20; // [esp+18h] [ebp-1Ch]
  int v21; // [esp+1Ch] [ebp-18h]
  int v22; // [esp+20h] [ebp-14h]
  int v23; // [esp+28h] [ebp-Ch]
  int v24; // [esp+2Ch] [ebp-8h]
  unsigned int v25; // [esp+30h] [ebp-4h]

  v25 = a1[29];
  v18 = (_BYTE *)(a1[25] + a1[12]);
  v24 = a1[28];
  v23 = a1[34];
  if ( a1[25] <= (unsigned int)(a1[9] - 262) )
    v6 = 0;
  else
    v6 = a1[25] - a1[9] + 262;
  v22 = a1[14];
  v21 = a1[11];
  v5 = a1[25] + a1[12] + 258;
  v4 = v18[v24 - 1];
  v3 = v18[v24];
  if ( a1[28] >= a1[33] )
    v25 >>= 2;
  if ( (unsigned int)v23 > a1[27] )
    v23 = a1[27];
  do
  {
    v8 = (_BYTE *)(a2 + a1[12]);
    if ( v8[v24] == v3 && v8[v24 - 1] == v4 && *v8 == *v18 )
    {
      v9 = v8 + 1;
      if ( *v9 == v18[1] )
      {
        v19 = v18 + 2;
        v10 = v9 + 1;
        do
        {
          ++v19;
          v11 = v10 + 1;
          if ( *v19 != *v11 )
            break;
          ++v19;
          v12 = v11 + 1;
          if ( *v19 != *v12 )
            break;
          ++v19;
          v13 = v12 + 1;
          if ( *v19 != *v13 )
            break;
          ++v19;
          v14 = v13 + 1;
          if ( *v19 != *v14 )
            break;
          ++v19;
          v15 = v14 + 1;
          if ( *v19 != *v15 )
            break;
          ++v19;
          v16 = v15 + 1;
          if ( *v19 != *v16 )
            break;
          ++v19;
          v17 = v16 + 1;
          if ( *v19 != *v17 )
            break;
          ++v19;
          v10 = v17 + 1;
          if ( *v19 != *v10 )
            break;
        }
        while ( (unsigned int)v19 < v5 );
        v7 = 258 - (v5 - (_DWORD)v19);
        v18 = (_BYTE *)(v5 - 258);
        if ( v7 > v24 )
        {
          a1[26] = a2;
          v24 = v7;
          if ( v7 >= v23 )
            break;
          v4 = v18[v7 - 1];
          v3 = v18[v7];
        }
      }
    }
    a2 = *(unsigned __int16 *)(v22 + 2 * (a2 & v21));
    if ( a2 <= v6 )
      break;
    --v25;
  }
  while ( v25 );
  if ( (unsigned int)v24 > a1[27] )
    v20 = a1[27];
  else
    v20 = v24;
  return v20;
}

//----- (080C6E57) --------------------------------------------------------
int __cdecl sub_80C6E57(int a1)
{
  int result; // eax
  __int16 v2; // [esp+10h] [ebp-48h]
  __int16 v3; // [esp+20h] [ebp-38h]
  _WORD *v4; // [esp+3Ch] [ebp-1Ch]
  _WORD *v5; // [esp+3Ch] [ebp-1Ch]
  unsigned int v6; // [esp+40h] [ebp-18h]
  unsigned int v7; // [esp+40h] [ebp-18h]
  int v8; // [esp+44h] [ebp-14h]
  size_t v9; // [esp+44h] [ebp-14h]
  size_t n; // [esp+48h] [ebp-10h]
  int v11; // [esp+4Ch] [ebp-Ch]

  n = *(_DWORD *)(a1 + 36);
  do
  {
    v11 = *(_DWORD *)(a1 + 52) - *(_DWORD *)(a1 + 108) - *(_DWORD *)(a1 + 100);
    if ( *(_DWORD *)(a1 + 52) - *(_DWORD *)(a1 + 108) != *(_DWORD *)(a1 + 100)
      || *(_DWORD *)(a1 + 100)
      || *(_DWORD *)(a1 + 108) )
    {
      if ( v11 == -1 )
      {
        v11 = -2;
      }
      else if ( *(_DWORD *)(a1 + 100) >= n + *(_DWORD *)(a1 + 36) - 262 )
      {
        memcpy(*(void **)(a1 + 48), (const void *)(*(_DWORD *)(a1 + 48) + n), n);
        *(_DWORD *)(a1 + 104) -= n;
        *(_DWORD *)(a1 + 100) -= n;
        *(_DWORD *)(a1 + 84) -= n;
        v8 = *(_DWORD *)(a1 + 68);
        v4 = (_WORD *)(2 * v8 + *(_DWORD *)(a1 + 60));
        do
        {
          --v4;
          v6 = (unsigned __int16)*v4;
          if ( v6 < n )
            v3 = 0;
          else
            v3 = v6 - n;
          *v4 = v3;
          --v8;
        }
        while ( v8 );
        v9 = n;
        v5 = (_WORD *)(2 * n + *(_DWORD *)(a1 + 56));
        do
        {
          --v5;
          v7 = (unsigned __int16)*v5;
          if ( v7 < n )
            v2 = 0;
          else
            v2 = v7 - n;
          *v5 = v2;
          --v9;
        }
        while ( v9 );
        v11 += n;
      }
    }
    else
    {
      v11 = n;
    }
    result = *(_DWORD *)a1;
    if ( !*(_DWORD *)(*(_DWORD *)a1 + 4) )
      break;
    *(_DWORD *)(a1 + 108) += sub_80C6A0C(
                               *(_DWORD *)a1,
                               (void *)(*(_DWORD *)(a1 + 108) + *(_DWORD *)(a1 + 100) + *(_DWORD *)(a1 + 48)),
                               v11);
    if ( *(_DWORD *)(a1 + 108) > 2u )
    {
      *(_DWORD *)(a1 + 64) = *(unsigned __int8 *)(*(_DWORD *)(a1 + 48) + *(_DWORD *)(a1 + 100));
      *(_DWORD *)(a1 + 64) = *(_DWORD *)(a1 + 76) & (*(unsigned __int8 *)(*(_DWORD *)(a1 + 48)
                                                                        + *(_DWORD *)(a1 + 100)
                                                                        + 1) ^ (*(_DWORD *)(a1 + 64) << *(_BYTE *)(a1 + 80)));
    }
    result = a1;
    if ( *(_DWORD *)(a1 + 108) > 0x105u )
      break;
    result = *(_DWORD *)a1;
  }
  while ( *(_DWORD *)(*(_DWORD *)a1 + 4) );
  return result;
}

//----- (080C70A8) --------------------------------------------------------
signed int __cdecl sub_80C70A8(int *a1, int a2)
{
  int v3; // [esp+8h] [ebp-30h]
  int v4; // [esp+8h] [ebp-30h]
  int v5; // [esp+8h] [ebp-30h]
  int v6; // [esp+Ch] [ebp-2Ch]
  signed int v7; // [esp+18h] [ebp-20h]
  signed int v8; // [esp+1Ch] [ebp-1Ch]
  signed int v9; // [esp+2Ch] [ebp-Ch]
  unsigned int v10; // [esp+30h] [ebp-8h]
  int v11; // [esp+34h] [ebp-4h]

  v11 = 0xFFFF;
  if ( (unsigned int)(a1[3] - 5) < 0xFFFF )
    v11 = a1[3] - 5;
  while ( 1 )
  {
    if ( (unsigned int)a1[27] <= 1 )
    {
      sub_80C6E57((int)a1);
      if ( !a1[27] && !a2 )
        return 0;
      if ( !a1[27] )
        break;
    }
    a1[25] += a1[27];
    a1[27] = 0;
    v10 = a1[21] + v11;
    if ( !a1[25] || a1[25] >= v10 )
    {
      a1[27] = a1[25] - v10;
      a1[25] = v10;
      v3 = a1[25] - a1[21];
      if ( a1[21] < 0 )
        sub_80CE57D((int)a1, 0, v3, 0);
      else
        sub_80CE57D((int)a1, (_BYTE *)(a1[12] + a1[21]), v3, 0);
      a1[21] = a1[25];
      sub_80C613D(*a1);
      if ( !*(_DWORD *)(*a1 + 16) )
        return 0;
    }
    if ( a1[25] - a1[21] >= (unsigned int)(a1[9] - 262) )
    {
      v4 = a1[25] - a1[21];
      if ( a1[21] < 0 )
        sub_80CE57D((int)a1, 0, v4, 0);
      else
        sub_80CE57D((int)a1, (_BYTE *)(a1[12] + a1[21]), v4, 0);
      a1[21] = a1[25];
      sub_80C613D(*a1);
      if ( !*(_DWORD *)(*a1 + 16) )
        return 0;
    }
  }
  v6 = a2 == 4;
  v5 = a1[25] - a1[21];
  if ( a1[21] < 0 )
    sub_80CE57D((int)a1, 0, v5, v6);
  else
    sub_80CE57D((int)a1, (_BYTE *)(a1[12] + a1[21]), v5, v6);
  a1[21] = a1[25];
  sub_80C613D(*a1);
  if ( *(_DWORD *)(*a1 + 16) )
  {
    if ( a2 == 4 )
      v7 = 3;
    else
      v7 = 1;
    v9 = v7;
  }
  else
  {
    if ( a2 == 4 )
      v8 = 2;
    else
      v8 = 0;
    v9 = v8;
  }
  return v9;
}

//----- (080C8044) --------------------------------------------------------
int __cdecl sub_80C8044(int a1, int a2, _DWORD *a3)
{
  int v3; // eax
  int result; // eax

  if ( a3 )
    *a3 = *(_DWORD *)(a1 + 60);
  if ( *(_DWORD *)a1 == 4 || *(_DWORD *)a1 == 5 )
    (*(void (__cdecl **)(_DWORD, _DWORD))(a2 + 36))(*(_DWORD *)(a2 + 40), *(_DWORD *)(a1 + 12));
  if ( *(_DWORD *)a1 == 6 )
    sub_80CA538(*(_DWORD *)(a1 + 4), a2);
  *(_DWORD *)a1 = 0;
  *(_DWORD *)(a1 + 28) = 0;
  *(_DWORD *)(a1 + 32) = 0;
  v3 = *(_DWORD *)(a1 + 40);
  *(_DWORD *)(a1 + 52) = v3;
  *(_DWORD *)(a1 + 48) = v3;
  result = a1;
  if ( *(_DWORD *)(a1 + 56) )
  {
    *(_DWORD *)(a1 + 60) = (*(int (__cdecl **)(_DWORD, _DWORD, _DWORD))(a1 + 56))(0, 0, 0);
    result = *(_DWORD *)(a1 + 60);
    *(_DWORD *)(a2 + 48) = result;
  }
  return result;
}

//----- (080C8114) --------------------------------------------------------
_DWORD *__cdecl sub_80C8114(int a1, int a2, int a3)
{
  _DWORD *v4; // [esp+Ch] [ebp-Ch]
  _DWORD *v5; // [esp+10h] [ebp-8h]

  v5 = (_DWORD *)(*(int (__cdecl **)(_DWORD, signed int, signed int))(a1 + 32))(*(_DWORD *)(a1 + 40), 1, 64);
  if ( !v5 )
    return 0;
  v5[9] = (*(int (__cdecl **)(_DWORD, signed int, signed int))(a1 + 32))(*(_DWORD *)(a1 + 40), 8, 1440);
  if ( v5[9] )
  {
    v5[10] = (*(int (__cdecl **)(_DWORD, signed int, int))(a1 + 32))(*(_DWORD *)(a1 + 40), 1, a3);
    if ( v5[10] )
    {
      v5[11] = v5[10] + a3;
      v5[14] = a2;
      *v5 = 0;
      sub_80C8044((int)v5, a1, 0);
      v4 = v5;
    }
    else
    {
      (*(void (__cdecl **)(_DWORD, _DWORD))(a1 + 36))(*(_DWORD *)(a1 + 40), v5[9]);
      (*(void (__cdecl **)(_DWORD, _DWORD *))(a1 + 36))(*(_DWORD *)(a1 + 40), v5);
      v4 = 0;
    }
  }
  else
  {
    (*(void (__cdecl **)(_DWORD, _DWORD *))(a1 + 36))(*(_DWORD *)(a1 + 40), v5);
    v4 = 0;
  }
  return v4;
}

//----- (080C8256) --------------------------------------------------------
int __cdecl sub_80C8256(int a1, int a2, int a3)
{
  int v4; // [esp+28h] [ebp-80h]
  int v5; // [esp+2Ch] [ebp-7Ch]
  unsigned int v6; // [esp+30h] [ebp-78h]
  signed int v7; // [esp+34h] [ebp-74h]
  int v8; // [esp+38h] [ebp-70h]
  signed int v9; // [esp+3Ch] [ebp-6Ch]
  int v10; // [esp+44h] [ebp-64h]
  int v11; // [esp+48h] [ebp-60h]
  int v12; // [esp+4Ch] [ebp-5Ch]
  signed int v13; // [esp+50h] [ebp-58h]
  size_t v14; // [esp+58h] [ebp-50h]
  int v15; // [esp+5Ch] [ebp-4Ch]
  int v16; // [esp+60h] [ebp-48h]
  int v17; // [esp+64h] [ebp-44h]
  unsigned int v18; // [esp+68h] [ebp-40h]
  int v19; // [esp+6Ch] [ebp-3Ch]
  int v20; // [esp+70h] [ebp-38h]
  int v21; // [esp+74h] [ebp-34h]
  int v22; // [esp+78h] [ebp-30h]
  int v23; // [esp+7Ch] [ebp-2Ch]
  int v24; // [esp+80h] [ebp-28h]
  int v25; // [esp+84h] [ebp-24h]
  size_t v26; // [esp+88h] [ebp-20h]
  void *dest; // [esp+8Ch] [ebp-1Ch]
  size_t v28; // [esp+90h] [ebp-18h]
  void *src; // [esp+94h] [ebp-14h]
  size_t v30; // [esp+98h] [ebp-10h]
  unsigned int v31; // [esp+9Ch] [ebp-Ch]
  size_t n; // [esp+A0h] [ebp-8h]
  int v33; // [esp+B8h] [ebp+10h]
  int v34; // [esp+B8h] [ebp+10h]
  int v35; // [esp+B8h] [ebp+10h]
  int v36; // [esp+B8h] [ebp+10h]
  int v37; // [esp+B8h] [ebp+10h]

  src = *(void **)a2;
  v28 = *(_DWORD *)(a2 + 4);
  v31 = *(_DWORD *)(a1 + 32);
  v30 = *(_DWORD *)(a1 + 28);
  dest = *(void **)(a1 + 52);
  if ( (unsigned int)dest >= *(_DWORD *)(a1 + 48) )
    v15 = *(_DWORD *)(a1 + 44) - (_DWORD)dest;
  else
    v15 = *(_DWORD *)(a1 + 48) - (_DWORD)dest - 1;
  v26 = v15;
  while ( 2 )
  {
    switch ( *(_DWORD *)a1 )
    {
      case 0:
        while ( v30 <= 2 )
        {
          if ( !v28 )
          {
            *(_DWORD *)(a1 + 32) = v31;
            *(_DWORD *)(a1 + 28) = v30;
            *(_DWORD *)(a2 + 4) = v28;
            *(_DWORD *)(a2 + 8) += (char *)src - *(_DWORD *)a2;
            *(_DWORD *)a2 = src;
            *(_DWORD *)(a1 + 52) = dest;
            return sub_80CC278(a1, (_DWORD *)a2, a3);
          }
          a3 = 0;
          --v28;
          v31 |= *(unsigned __int8 *)src << v30;
          src = (char *)src + 1;
          v30 += 8;
        }
        n = v31 & 7;
        *(_DWORD *)(a1 + 24) = v31 & 1;
        v14 = n >> 1;
        if ( n >> 1 == 1 )
        {
          sub_80CC247(&v25, &v24, &v23, &v22);
          *(_DWORD *)(a1 + 4) = sub_80C9764(v25, v24, v23, v22, a2);
          if ( *(_DWORD *)(a1 + 4) )
          {
            v31 >>= 3;
            v30 -= 3;
            *(_DWORD *)a1 = 6;
            continue;
          }
          *(_DWORD *)(a1 + 32) = v31;
          *(_DWORD *)(a1 + 28) = v30;
          *(_DWORD *)(a2 + 4) = v28;
          *(_DWORD *)(a2 + 8) += (char *)src - *(_DWORD *)a2;
          *(_DWORD *)a2 = src;
          *(_DWORD *)(a1 + 52) = dest;
          v16 = sub_80CC278(a1, (_DWORD *)a2, -4);
        }
        else
        {
          if ( v14 < 1 )
          {
            v31 >>= 3;
            v30 -= 3;
            n = v30 & 7;
            v31 >>= n;
            v30 -= n;
            *(_DWORD *)a1 = 1;
            continue;
          }
          if ( v14 == 2 )
          {
            v31 >>= 3;
            v30 -= 3;
            *(_DWORD *)a1 = 3;
            continue;
          }
          if ( v14 != 3 )
            continue;
          v31 >>= 3;
          v30 -= 3;
          *(_DWORD *)a1 = 9;
          *(_DWORD *)(a2 + 24) = "invalid block type";
          *(_DWORD *)(a1 + 32) = v31;
          *(_DWORD *)(a1 + 28) = v30;
          *(_DWORD *)(a2 + 4) = v28;
          *(_DWORD *)(a2 + 8) += (char *)src - *(_DWORD *)a2;
          *(_DWORD *)a2 = src;
          *(_DWORD *)(a1 + 52) = dest;
          v16 = sub_80CC278(a1, (_DWORD *)a2, -3);
        }
        break;
      case 1:
        while ( v30 <= 0x1F )
        {
          if ( !v28 )
          {
            *(_DWORD *)(a1 + 32) = v31;
            *(_DWORD *)(a1 + 28) = v30;
            *(_DWORD *)(a2 + 4) = v28;
            *(_DWORD *)(a2 + 8) += (char *)src - *(_DWORD *)a2;
            *(_DWORD *)a2 = src;
            *(_DWORD *)(a1 + 52) = dest;
            return sub_80CC278(a1, (_DWORD *)a2, a3);
          }
          a3 = 0;
          --v28;
          v31 |= *(unsigned __int8 *)src << v30;
          src = (char *)src + 1;
          v30 += 8;
        }
        if ( ~v31 >> 16 == (unsigned __int16)v31 )
        {
          *(_DWORD *)(a1 + 4) = (unsigned __int16)v31;
          v30 = 0;
          v31 = 0;
          if ( *(_DWORD *)(a1 + 4) )
          {
            v13 = 2;
          }
          else if ( *(_DWORD *)(a1 + 24) )
          {
            v13 = 7;
          }
          else
          {
            v13 = 0;
          }
          *(_DWORD *)a1 = v13;
          continue;
        }
        *(_DWORD *)a1 = 9;
        *(_DWORD *)(a2 + 24) = "invalid stored block lengths";
        *(_DWORD *)(a1 + 32) = v31;
        *(_DWORD *)(a1 + 28) = v30;
        *(_DWORD *)(a2 + 4) = v28;
        *(_DWORD *)(a2 + 8) += (char *)src - *(_DWORD *)a2;
        *(_DWORD *)a2 = src;
        *(_DWORD *)(a1 + 52) = dest;
        v16 = sub_80CC278(a1, (_DWORD *)a2, -3);
        break;
      case 2:
        if ( v28 )
        {
          if ( v26 )
            goto LABEL_141;
          if ( dest == *(void **)(a1 + 44) && *(_DWORD *)(a1 + 48) != *(_DWORD *)(a1 + 40) )
          {
            dest = *(void **)(a1 + 40);
            if ( (unsigned int)dest >= *(_DWORD *)(a1 + 48) )
              v12 = *(_DWORD *)(a1 + 44) - (_DWORD)dest;
            else
              v12 = *(_DWORD *)(a1 + 48) - (_DWORD)dest - 1;
            v26 = v12;
          }
          if ( v26 )
            goto LABEL_141;
          *(_DWORD *)(a1 + 52) = dest;
          v33 = sub_80CC278(a1, (_DWORD *)a2, a3);
          dest = *(void **)(a1 + 52);
          if ( (unsigned int)dest >= *(_DWORD *)(a1 + 48) )
            v11 = *(_DWORD *)(a1 + 44) - (_DWORD)dest;
          else
            v11 = *(_DWORD *)(a1 + 48) - (_DWORD)dest - 1;
          v26 = v11;
          if ( dest == *(void **)(a1 + 44) && *(_DWORD *)(a1 + 48) != *(_DWORD *)(a1 + 40) )
          {
            dest = *(void **)(a1 + 40);
            if ( (unsigned int)dest >= *(_DWORD *)(a1 + 48) )
              v10 = *(_DWORD *)(a1 + 44) - (_DWORD)dest;
            else
              v10 = *(_DWORD *)(a1 + 48) - (_DWORD)dest - 1;
            v26 = v10;
          }
          if ( v26 )
          {
LABEL_141:
            a3 = 0;
            n = *(_DWORD *)(a1 + 4);
            if ( n > v28 )
              n = v28;
            if ( n > v26 )
              n = v26;
            memcpy(dest, src, n);
            src = (char *)src + n;
            v28 -= n;
            dest = (char *)dest + n;
            v26 -= n;
            *(_DWORD *)(a1 + 4) -= n;
            if ( !*(_DWORD *)(a1 + 4) )
            {
              if ( *(_DWORD *)(a1 + 24) )
                v9 = 7;
              else
                v9 = 0;
              *(_DWORD *)a1 = v9;
            }
            continue;
          }
          *(_DWORD *)(a1 + 32) = v31;
          *(_DWORD *)(a1 + 28) = v30;
          *(_DWORD *)(a2 + 4) = v28;
          *(_DWORD *)(a2 + 8) += (char *)src - *(_DWORD *)a2;
          *(_DWORD *)a2 = src;
          *(_DWORD *)(a1 + 52) = dest;
          v16 = sub_80CC278(a1, (_DWORD *)a2, v33);
        }
        else
        {
          *(_DWORD *)(a1 + 32) = v31;
          *(_DWORD *)(a1 + 28) = v30;
          *(_DWORD *)(a2 + 4) = v28;
          *(_DWORD *)(a2 + 8) += (char *)src - *(_DWORD *)a2;
          *(_DWORD *)a2 = src;
          *(_DWORD *)(a1 + 52) = dest;
          v16 = sub_80CC278(a1, (_DWORD *)a2, a3);
        }
        break;
      case 3:
        while ( v30 <= 0xD )
        {
          if ( !v28 )
          {
            *(_DWORD *)(a1 + 32) = v31;
            *(_DWORD *)(a1 + 28) = v30;
            *(_DWORD *)(a2 + 4) = v28;
            *(_DWORD *)(a2 + 8) += (char *)src - *(_DWORD *)a2;
            *(_DWORD *)a2 = src;
            *(_DWORD *)(a1 + 52) = dest;
            return sub_80CC278(a1, (_DWORD *)a2, a3);
          }
          a3 = 0;
          --v28;
          v31 |= *(unsigned __int8 *)src << v30;
          src = (char *)src + 1;
          v30 += 8;
        }
        n = v31 & 0x3FFF;
        *(_DWORD *)(a1 + 4) = n;
        if ( (n & 0x1F) <= 0x1D && ((n >> 5) & 0x1F) <= 0x1D )
        {
          n = ((n >> 5) & 0x1F) + (n & 0x1F) + 258;
          *(_DWORD *)(a1 + 12) = (*(int (__cdecl **)(_DWORD, size_t, signed int))(a2 + 32))(*(_DWORD *)(a2 + 40), n, 4);
          if ( *(_DWORD *)(a1 + 12) )
          {
            v31 >>= 14;
            v30 -= 14;
            *(_DWORD *)(a1 + 8) = 0;
            *(_DWORD *)a1 = 4;
            goto LABEL_73;
          }
          *(_DWORD *)(a1 + 32) = v31;
          *(_DWORD *)(a1 + 28) = v30;
          *(_DWORD *)(a2 + 4) = v28;
          *(_DWORD *)(a2 + 8) += (char *)src - *(_DWORD *)a2;
          *(_DWORD *)a2 = src;
          *(_DWORD *)(a1 + 52) = dest;
          v16 = sub_80CC278(a1, (_DWORD *)a2, -4);
        }
        else
        {
          *(_DWORD *)a1 = 9;
          *(_DWORD *)(a2 + 24) = "too many length or distance symbols";
          *(_DWORD *)(a1 + 32) = v31;
          *(_DWORD *)(a1 + 28) = v30;
          *(_DWORD *)(a2 + 4) = v28;
          *(_DWORD *)(a2 + 8) += (char *)src - *(_DWORD *)a2;
          *(_DWORD *)a2 = src;
          *(_DWORD *)(a1 + 52) = dest;
          v16 = sub_80CC278(a1, (_DWORD *)a2, -3);
        }
        break;
      case 4:
LABEL_73:
        while ( *(_DWORD *)(a1 + 8) < (unsigned int)((*(_DWORD *)(a1 + 4) >> 10) + 4) )
        {
          while ( v30 <= 2 )
          {
            if ( !v28 )
            {
              *(_DWORD *)(a1 + 32) = v31;
              *(_DWORD *)(a1 + 28) = v30;
              *(_DWORD *)(a2 + 4) = v28;
              *(_DWORD *)(a2 + 8) += (char *)src - *(_DWORD *)a2;
              *(_DWORD *)a2 = src;
              *(_DWORD *)(a1 + 52) = dest;
              return sub_80CC278(a1, (_DWORD *)a2, a3);
            }
            a3 = 0;
            --v28;
            v31 |= *(unsigned __int8 *)src << v30;
            src = (char *)src + 1;
            v30 += 8;
          }
          *(_DWORD *)(*(_DWORD *)(a1 + 12) + 4 * dword_8149820[(*(_DWORD *)(a1 + 8))++]) = v31 & 7;
          v31 >>= 3;
          v30 -= 3;
        }
        while ( *(_DWORD *)(a1 + 8) <= 0x12u )
          *(_DWORD *)(*(_DWORD *)(a1 + 12) + 4 * dword_8149820[(*(_DWORD *)(a1 + 8))++]) = 0;
        *(_DWORD *)(a1 + 16) = 7;
        n = sub_80CBF7B(*(int **)(a1 + 12), (unsigned int *)(a1 + 16), (_DWORD *)(a1 + 20), *(_DWORD *)(a1 + 36), a2);
        if ( !n )
        {
          *(_DWORD *)(a1 + 8) = 0;
          *(_DWORD *)a1 = 5;
          goto LABEL_86;
        }
        v34 = n;
        if ( n == -3 )
        {
          (*(void (__cdecl **)(_DWORD, _DWORD))(a2 + 36))(*(_DWORD *)(a2 + 40), *(_DWORD *)(a1 + 12));
          *(_DWORD *)a1 = 9;
        }
        *(_DWORD *)(a1 + 32) = v31;
        *(_DWORD *)(a1 + 28) = v30;
        *(_DWORD *)(a2 + 4) = v28;
        *(_DWORD *)(a2 + 8) += (char *)src - *(_DWORD *)a2;
        *(_DWORD *)a2 = src;
        *(_DWORD *)(a1 + 52) = dest;
        v16 = sub_80CC278(a1, (_DWORD *)a2, v34);
        break;
      case 5:
LABEL_86:
        while ( 1 )
        {
          n = *(_DWORD *)(a1 + 4);
          if ( *(_DWORD *)(a1 + 8) >= ((n >> 5) & 0x1F) + (n & 0x1F) + 258 )
            break;
          n = *(_DWORD *)(a1 + 16);
          while ( v30 < n )
          {
            if ( !v28 )
            {
              *(_DWORD *)(a1 + 32) = v31;
              *(_DWORD *)(a1 + 28) = v30;
              *(_DWORD *)(a2 + 4) = v28;
              *(_DWORD *)(a2 + 8) += (char *)src - *(_DWORD *)a2;
              *(_DWORD *)a2 = src;
              *(_DWORD *)(a1 + 52) = dest;
              return sub_80CC278(a1, (_DWORD *)a2, a3);
            }
            a3 = 0;
            --v28;
            v31 |= *(unsigned __int8 *)src << v30;
            src = (char *)src + 1;
            v30 += 8;
          }
          v21 = *(_DWORD *)(a1 + 20) + 8 * (v31 & dword_8163EC0[n]);
          n = *(unsigned __int8 *)(v21 + 1);
          v18 = *(_DWORD *)(v21 + 4);
          if ( v18 > 0xF )
          {
            if ( v18 == 18 )
              v8 = 7;
            else
              v8 = v18 - 14;
            v20 = v8;
            if ( v18 == 18 )
              v7 = 11;
            else
              v7 = 3;
            v19 = v7;
            while ( v30 < n + v20 )
            {
              if ( !v28 )
              {
                *(_DWORD *)(a1 + 32) = v31;
                *(_DWORD *)(a1 + 28) = v30;
                *(_DWORD *)(a2 + 4) = v28;
                *(_DWORD *)(a2 + 8) += (char *)src - *(_DWORD *)a2;
                *(_DWORD *)a2 = src;
                *(_DWORD *)(a1 + 52) = dest;
                return sub_80CC278(a1, (_DWORD *)a2, a3);
              }
              a3 = 0;
              --v28;
              v31 |= *(unsigned __int8 *)src << v30;
              src = (char *)src + 1;
              v30 += 8;
            }
            v31 >>= n;
            v30 -= n;
            v19 += dword_8163EC0[v20] & v31;
            v31 >>= v20;
            v30 -= v20;
            v20 = *(_DWORD *)(a1 + 8);
            n = *(_DWORD *)(a1 + 4);
            if ( v19 + v20 > ((n >> 5) & 0x1F) + (n & 0x1F) + 258 || v18 == 16 && !v20 )
            {
              (*(void (__cdecl **)(_DWORD, _DWORD))(a2 + 36))(*(_DWORD *)(a2 + 40), *(_DWORD *)(a1 + 12));
              *(_DWORD *)a1 = 9;
              *(_DWORD *)(a2 + 24) = "invalid bit length repeat";
              *(_DWORD *)(a1 + 32) = v31;
              *(_DWORD *)(a1 + 28) = v30;
              *(_DWORD *)(a2 + 4) = v28;
              *(_DWORD *)(a2 + 8) += (char *)src - *(_DWORD *)a2;
              *(_DWORD *)a2 = src;
              *(_DWORD *)(a1 + 52) = dest;
              return sub_80CC278(a1, (_DWORD *)a2, -3);
            }
            if ( v18 == 16 )
              v6 = *(_DWORD *)(*(_DWORD *)(a1 + 12) + 4 * v20 - 4);
            else
              v6 = 0;
            v18 = v6;
            do
            {
              *(_DWORD *)(*(_DWORD *)(a1 + 12) + 4 * v20++) = v18;
              --v19;
            }
            while ( v19 );
            *(_DWORD *)(a1 + 8) = v20;
          }
          else
          {
            v31 >>= n;
            v30 -= n;
            *(_DWORD *)(*(_DWORD *)(a1 + 12) + 4 * (*(_DWORD *)(a1 + 8))++) = v18;
          }
        }
        *(_DWORD *)(a1 + 20) = 0;
        v18 = 9;
        v19 = 6;
        n = *(_DWORD *)(a1 + 4);
        n = sub_80CC064(
              (n & 0x1F) + 257,
              ((n >> 5) & 0x1F) + 1,
              *(int **)(a1 + 12),
              &v18,
              (unsigned int *)&v19,
              &v20,
              &v21,
              *(_DWORD *)(a1 + 36),
              a2);
        if ( n )
        {
          if ( n == -3 )
          {
            (*(void (__cdecl **)(_DWORD, _DWORD))(a2 + 36))(*(_DWORD *)(a2 + 40), *(_DWORD *)(a1 + 12));
            *(_DWORD *)a1 = 9;
          }
          v35 = n;
          *(_DWORD *)(a1 + 32) = v31;
          *(_DWORD *)(a1 + 28) = v30;
          *(_DWORD *)(a2 + 4) = v28;
          *(_DWORD *)(a2 + 8) += (char *)src - *(_DWORD *)a2;
          *(_DWORD *)a2 = src;
          *(_DWORD *)(a1 + 52) = dest;
          v16 = sub_80CC278(a1, (_DWORD *)a2, v35);
        }
        else
        {
          (*(void (__cdecl **)(_DWORD, _DWORD))(a2 + 36))(*(_DWORD *)(a2 + 40), *(_DWORD *)(a1 + 12));
          v17 = sub_80C9764(v18, v19, v20, v21, a2);
          if ( v17 )
          {
            *(_DWORD *)(a1 + 4) = v17;
            *(_DWORD *)a1 = 6;
            goto LABEL_122;
          }
          *(_DWORD *)(a1 + 32) = v31;
          *(_DWORD *)(a1 + 28) = v30;
          *(_DWORD *)(a2 + 4) = v28;
          *(_DWORD *)(a2 + 8) += (char *)src - *(_DWORD *)a2;
          *(_DWORD *)a2 = src;
          *(_DWORD *)(a1 + 52) = dest;
          v16 = sub_80CC278(a1, (_DWORD *)a2, -4);
        }
        break;
      case 6:
LABEL_122:
        *(_DWORD *)(a1 + 32) = v31;
        *(_DWORD *)(a1 + 28) = v30;
        *(_DWORD *)(a2 + 4) = v28;
        *(_DWORD *)(a2 + 8) += (char *)src - *(_DWORD *)a2;
        *(_DWORD *)a2 = src;
        *(_DWORD *)(a1 + 52) = dest;
        v36 = sub_80C97C9((_DWORD *)a1, (int *)a2, a3);
        if ( v36 == 1 )
        {
          a3 = 0;
          sub_80CA538(*(_DWORD *)(a1 + 4), a2);
          src = *(void **)a2;
          v28 = *(_DWORD *)(a2 + 4);
          v31 = *(_DWORD *)(a1 + 32);
          v30 = *(_DWORD *)(a1 + 28);
          dest = *(void **)(a1 + 52);
          if ( (unsigned int)dest >= *(_DWORD *)(a1 + 48) )
            v5 = *(_DWORD *)(a1 + 44) - (_DWORD)dest;
          else
            v5 = *(_DWORD *)(a1 + 48) - (_DWORD)dest - 1;
          v26 = v5;
          if ( !*(_DWORD *)(a1 + 24) )
          {
            *(_DWORD *)a1 = 0;
            continue;
          }
          *(_DWORD *)a1 = 7;
          goto LABEL_130;
        }
        v16 = sub_80CC278(a1, (_DWORD *)a2, v36);
        break;
      case 7:
LABEL_130:
        *(_DWORD *)(a1 + 52) = dest;
        v37 = sub_80CC278(a1, (_DWORD *)a2, a3);
        dest = *(void **)(a1 + 52);
        if ( (unsigned int)dest >= *(_DWORD *)(a1 + 48) )
          v4 = *(_DWORD *)(a1 + 44) - (_DWORD)dest;
        else
          v4 = *(_DWORD *)(a1 + 48) - (_DWORD)dest - 1;
        v26 = v4;
        if ( *(_DWORD *)(a1 + 48) == *(_DWORD *)(a1 + 52) )
        {
          *(_DWORD *)a1 = 8;
          goto LABEL_136;
        }
        *(_DWORD *)(a1 + 32) = v31;
        *(_DWORD *)(a1 + 28) = v30;
        *(_DWORD *)(a2 + 4) = v28;
        *(_DWORD *)(a2 + 8) += (char *)src - *(_DWORD *)a2;
        *(_DWORD *)a2 = src;
        *(_DWORD *)(a1 + 52) = dest;
        v16 = sub_80CC278(a1, (_DWORD *)a2, v37);
        break;
      case 8:
LABEL_136:
        *(_DWORD *)(a1 + 32) = v31;
        *(_DWORD *)(a1 + 28) = v30;
        *(_DWORD *)(a2 + 4) = v28;
        *(_DWORD *)(a2 + 8) += (char *)src - *(_DWORD *)a2;
        *(_DWORD *)a2 = src;
        *(_DWORD *)(a1 + 52) = dest;
        v16 = sub_80CC278(a1, (_DWORD *)a2, 1);
        break;
      case 9:
        *(_DWORD *)(a1 + 32) = v31;
        *(_DWORD *)(a1 + 28) = v30;
        *(_DWORD *)(a2 + 4) = v28;
        *(_DWORD *)(a2 + 8) += (char *)src - *(_DWORD *)a2;
        *(_DWORD *)a2 = src;
        *(_DWORD *)(a1 + 52) = dest;
        v16 = sub_80CC278(a1, (_DWORD *)a2, -3);
        break;
    }
    return v16;
  }
}

//----- (080C969D) --------------------------------------------------------
int __cdecl sub_80C969D(int a1, int a2)
{
  sub_80C8044(a1, a2, 0);
  (*(void (__cdecl **)(_DWORD, _DWORD))(a2 + 36))(*(_DWORD *)(a2 + 40), *(_DWORD *)(a1 + 40));
  (*(void (__cdecl **)(_DWORD, _DWORD))(a2 + 36))(*(_DWORD *)(a2 + 40), *(_DWORD *)(a1 + 36));
  (*(void (__cdecl **)(_DWORD, int))(a2 + 36))(*(_DWORD *)(a2 + 40), a1);
  return 0;
}

//----- (080C9712) --------------------------------------------------------
int __cdecl sub_80C9712(int a1, void *src, size_t n)
{
  int result; // eax

  memcpy(*(void **)(a1 + 40), src, n);
  *(_DWORD *)(a1 + 52) = *(_DWORD *)(a1 + 40) + n;
  result = *(_DWORD *)(a1 + 52);
  *(_DWORD *)(a1 + 48) = result;
  return result;
}

//----- (080C9753) --------------------------------------------------------
_BOOL4 __cdecl sub_80C9753(_DWORD *a1)
{
  return *a1 == 1;
}

//----- (080C9764) --------------------------------------------------------
int __cdecl sub_80C9764(char a1, char a2, int a3, int a4, int a5)
{
  int v6; // [esp+14h] [ebp-4h]

  v6 = (*(int (__cdecl **)(_DWORD, signed int, signed int))(a5 + 32))(*(_DWORD *)(a5 + 40), 1, 28);
  if ( v6 )
  {
    *(_DWORD *)v6 = 0;
    *(_BYTE *)(v6 + 16) = a1;
    *(_BYTE *)(v6 + 17) = a2;
    *(_DWORD *)(v6 + 20) = a3;
    *(_DWORD *)(v6 + 24) = a4;
  }
  return v6;
}

//----- (080C97C9) --------------------------------------------------------
int __cdecl sub_80C97C9(_DWORD *a1, int *a2, int a3)
{
  _BYTE *v3; // edx
  int v4; // ST28_4
  int v5; // ST28_4
  int v7; // [esp+2Ch] [ebp-5Ch]
  int v8; // [esp+30h] [ebp-58h]
  int v9; // [esp+34h] [ebp-54h]
  int v10; // [esp+38h] [ebp-50h]
  int v11; // [esp+3Ch] [ebp-4Ch]
  int v12; // [esp+40h] [ebp-48h]
  signed int v13; // [esp+44h] [ebp-44h]
  int v14; // [esp+4Ch] [ebp-3Ch]
  int v15; // [esp+50h] [ebp-38h]
  int v16; // [esp+54h] [ebp-34h]
  int v17; // [esp+58h] [ebp-30h]
  unsigned int i; // [esp+5Ch] [ebp-2Ch]
  unsigned int v19; // [esp+60h] [ebp-28h]
  _BYTE *v20; // [esp+64h] [ebp-24h]
  unsigned int v21; // [esp+68h] [ebp-20h]
  unsigned __int8 *v22; // [esp+6Ch] [ebp-1Ch]
  unsigned int v23; // [esp+70h] [ebp-18h]
  unsigned int v24; // [esp+74h] [ebp-14h]
  int v25; // [esp+78h] [ebp-10h]
  int v26; // [esp+78h] [ebp-10h]
  unsigned __int8 *v27; // [esp+7Ch] [ebp-Ch]
  unsigned __int8 *v28; // [esp+7Ch] [ebp-Ch]
  unsigned int v29; // [esp+80h] [ebp-8h]
  unsigned int v30; // [esp+80h] [ebp-8h]
  unsigned int v31; // [esp+80h] [ebp-8h]
  unsigned int v32; // [esp+80h] [ebp-8h]
  int v33; // [esp+98h] [ebp+10h]
  int v34; // [esp+98h] [ebp+10h]
  int v35; // [esp+98h] [ebp+10h]

  v17 = a1[1];
  v22 = (unsigned __int8 *)*a2;
  v21 = a2[1];
  v24 = a1[8];
  v23 = a1[7];
  v20 = (_BYTE *)a1[13];
  if ( (unsigned int)v20 >= a1[12] )
    v15 = a1[11] - (_DWORD)v20;
  else
    v15 = a1[12] - (_DWORD)v20 - 1;
  v19 = v15;
  while ( 2 )
  {
    switch ( *(_DWORD *)v17 )
    {
      case 0:
        if ( v19 <= 0x101 || v21 <= 9 )
          goto LABEL_113;
        a1[8] = v24;
        a1[7] = v23;
        a2[1] = v21;
        a2[2] += (int)&v22[-*a2];
        *a2 = (int)v22;
        a1[13] = v20;
        a3 = sub_80CA558(
               *(unsigned __int8 *)(v17 + 16),
               *(unsigned __int8 *)(v17 + 17),
               *(_DWORD *)(v17 + 20),
               *(_DWORD *)(v17 + 24),
               a1,
               a2);
        v22 = (unsigned __int8 *)*a2;
        v21 = a2[1];
        v24 = a1[8];
        v23 = a1[7];
        v20 = (_BYTE *)a1[13];
        v14 = (unsigned int)v20 >= a1[12] ? a1[11] - (_DWORD)v20 : a1[12] - (_DWORD)v20 - 1;
        v19 = v14;
        if ( !a3 )
        {
LABEL_113:
          *(_DWORD *)(v17 + 12) = *(unsigned __int8 *)(v17 + 16);
          *(_DWORD *)(v17 + 8) = *(_DWORD *)(v17 + 20);
          *(_DWORD *)v17 = 1;
          goto LABEL_17;
        }
        if ( a3 == 1 )
          v13 = 7;
        else
          v13 = 9;
        *(_DWORD *)v17 = v13;
        continue;
      case 1:
LABEL_17:
        v29 = *(_DWORD *)(v17 + 12);
        while ( 2 )
        {
          if ( v23 < v29 )
          {
            if ( v21 )
            {
              a3 = 0;
              --v21;
              v24 |= *v22++ << v23;
              v23 += 8;
              continue;
            }
            a1[8] = v24;
            a1[7] = v23;
            a2[1] = 0;
            a2[2] += (int)&v22[-*a2];
            *a2 = (int)v22;
            a1[13] = v20;
            return sub_80CC278((int)a1, a2, a3);
          }
          break;
        }
        v27 = (unsigned __int8 *)(*(_DWORD *)(v17 + 8) + 8 * (v24 & dword_8163EC0[v29]));
        v24 >>= v27[1];
        v23 -= v27[1];
        v25 = *v27;
        if ( *v27 )
        {
          if ( v25 & 0x10 )
          {
            *(_DWORD *)(v17 + 8) = v25 & 0xF;
            *(_DWORD *)(v17 + 4) = *((_DWORD *)v27 + 1);
            *(_DWORD *)v17 = 2;
          }
          else if ( v25 & 0x40 )
          {
            if ( !(v25 & 0x20) )
            {
              *(_DWORD *)v17 = 9;
              a2[6] = (int)"invalid literal/length code";
              a1[8] = v24;
              a1[7] = v23;
              a2[1] = v21;
              a2[2] += (int)&v22[-*a2];
              *a2 = (int)v22;
              a1[13] = v20;
              return sub_80CC278((int)a1, a2, -3);
            }
            *(_DWORD *)v17 = 7;
          }
          else
          {
            *(_DWORD *)(v17 + 12) = v25;
            *(_DWORD *)(v17 + 8) = &v27[8 * *((_DWORD *)v27 + 1)];
          }
        }
        else
        {
          *(_DWORD *)(v17 + 8) = *((_DWORD *)v27 + 1);
          *(_DWORD *)v17 = 6;
        }
        continue;
      case 2:
        v30 = *(_DWORD *)(v17 + 8);
        while ( 2 )
        {
          if ( v23 < v30 )
          {
            if ( v21 )
            {
              a3 = 0;
              --v21;
              v24 |= *v22++ << v23;
              v23 += 8;
              continue;
            }
            a1[8] = v24;
            a1[7] = v23;
            a2[1] = 0;
            a2[2] += (int)&v22[-*a2];
            *a2 = (int)v22;
            a1[13] = v20;
            return sub_80CC278((int)a1, a2, a3);
          }
          break;
        }
        *(_DWORD *)(v17 + 4) += v24 & dword_8163EC0[v30];
        v24 >>= v30;
        v23 -= v30;
        *(_DWORD *)(v17 + 12) = *(unsigned __int8 *)(v17 + 17);
        *(_DWORD *)(v17 + 8) = *(_DWORD *)(v17 + 24);
        *(_DWORD *)v17 = 3;
LABEL_37:
        v31 = *(_DWORD *)(v17 + 12);
        while ( v23 < v31 )
        {
          if ( !v21 )
          {
            a1[8] = v24;
            a1[7] = v23;
            a2[1] = 0;
            a2[2] += (int)&v22[-*a2];
            *a2 = (int)v22;
            a1[13] = v20;
            return sub_80CC278((int)a1, a2, a3);
          }
          a3 = 0;
          --v21;
          v24 |= *v22++ << v23;
          v23 += 8;
        }
        v28 = (unsigned __int8 *)(*(_DWORD *)(v17 + 8) + 8 * (v24 & dword_8163EC0[v31]));
        v24 >>= v28[1];
        v23 -= v28[1];
        v26 = *v28;
        if ( v26 & 0x10 )
        {
          *(_DWORD *)(v17 + 8) = v26 & 0xF;
          *(_DWORD *)(v17 + 12) = *((_DWORD *)v28 + 1);
          *(_DWORD *)v17 = 4;
        }
        else
        {
          if ( v26 & 0x40 )
          {
            *(_DWORD *)v17 = 9;
            a2[6] = (int)"invalid distance code";
            a1[8] = v24;
            a1[7] = v23;
            a2[1] = v21;
            a2[2] += (int)&v22[-*a2];
            *a2 = (int)v22;
            a1[13] = v20;
            return sub_80CC278((int)a1, a2, -3);
          }
          *(_DWORD *)(v17 + 12) = v26;
          *(_DWORD *)(v17 + 8) = &v28[8 * *((_DWORD *)v28 + 1)];
        }
        continue;
      case 3:
        goto LABEL_37;
      case 4:
        v32 = *(_DWORD *)(v17 + 8);
LABEL_48:
        if ( v23 >= v32 )
        {
          *(_DWORD *)(v17 + 12) += v24 & dword_8163EC0[v32];
          v24 >>= v32;
          v23 -= v32;
          *(_DWORD *)v17 = 5;
LABEL_53:
          for ( i = (unsigned int)&v20[-*(_DWORD *)(v17 + 12)]; i < a1[10]; i += a1[11] - a1[10] )
            ;
          while ( *(_DWORD *)(v17 + 4) )
          {
            if ( !v19 )
            {
              if ( v20 == (_BYTE *)a1[11] && a1[12] != a1[10] )
              {
                v20 = (_BYTE *)a1[10];
                if ( (unsigned int)v20 >= a1[12] )
                  v12 = a1[11] - (_DWORD)v20;
                else
                  v12 = a1[12] - (_DWORD)v20 - 1;
                v19 = v12;
              }
              if ( !v19 )
              {
                a1[13] = v20;
                v33 = sub_80CC278((int)a1, a2, a3);
                v20 = (_BYTE *)a1[13];
                if ( (unsigned int)v20 >= a1[12] )
                  v11 = a1[11] - (_DWORD)v20;
                else
                  v11 = a1[12] - (_DWORD)v20 - 1;
                v19 = v11;
                if ( v20 == (_BYTE *)a1[11] && a1[12] != a1[10] )
                {
                  v20 = (_BYTE *)a1[10];
                  if ( (unsigned int)v20 >= a1[12] )
                    v10 = a1[11] - (_DWORD)v20;
                  else
                    v10 = a1[12] - (_DWORD)v20 - 1;
                  v19 = v10;
                }
                if ( !v19 )
                {
                  a1[8] = v24;
                  a1[7] = v23;
                  a2[1] = v21;
                  a2[2] += (int)&v22[-*a2];
                  *a2 = (int)v22;
                  a1[13] = v20;
                  return sub_80CC278((int)a1, a2, v33);
                }
              }
            }
            a3 = 0;
            v3 = (_BYTE *)i++;
            *v20++ = *v3;
            --v19;
            if ( i == a1[11] )
              i = a1[10];
            --*(_DWORD *)(v17 + 4);
          }
          *(_DWORD *)v17 = 0;
          continue;
        }
        if ( v21 )
        {
          a3 = 0;
          --v21;
          v24 |= *v22++ << v23;
          v23 += 8;
          goto LABEL_48;
        }
        a1[8] = v24;
        a1[7] = v23;
        a2[1] = 0;
        a2[2] += (int)&v22[-*a2];
        *a2 = (int)v22;
        a1[13] = v20;
        return sub_80CC278((int)a1, a2, a3);
      case 5:
        goto LABEL_53;
      case 6:
        if ( !v19 )
        {
          if ( v20 == (_BYTE *)a1[11] && a1[12] != a1[10] )
          {
            v20 = (_BYTE *)a1[10];
            if ( (unsigned int)v20 >= a1[12] )
              v9 = a1[11] - (_DWORD)v20;
            else
              v9 = a1[12] - (_DWORD)v20 - 1;
            v19 = v9;
          }
          if ( !v19 )
          {
            a1[13] = v20;
            v34 = sub_80CC278((int)a1, a2, a3);
            v20 = (_BYTE *)a1[13];
            if ( (unsigned int)v20 >= a1[12] )
              v8 = a1[11] - (_DWORD)v20;
            else
              v8 = a1[12] - (_DWORD)v20 - 1;
            v19 = v8;
            if ( v20 == (_BYTE *)a1[11] && a1[12] != a1[10] )
            {
              v20 = (_BYTE *)a1[10];
              if ( (unsigned int)v20 >= a1[12] )
                v7 = a1[11] - (_DWORD)v20;
              else
                v7 = a1[12] - (_DWORD)v20 - 1;
              v19 = v7;
            }
            if ( !v19 )
            {
              a1[8] = v24;
              a1[7] = v23;
              a2[1] = v21;
              a2[2] += (int)&v22[-*a2];
              *a2 = (int)v22;
              a1[13] = v20;
              return sub_80CC278((int)a1, a2, v34);
            }
          }
        }
        a3 = 0;
        *v20++ = *(_BYTE *)(v17 + 8);
        --v19;
        *(_DWORD *)v17 = 0;
        continue;
      case 7:
        if ( v23 > 7 )
        {
          v23 -= 8;
          ++v21;
          --v22;
        }
        a1[13] = v20;
        v35 = sub_80CC278((int)a1, a2, a3);
        v20 = (_BYTE *)a1[13];
        if ( (unsigned int)v20 >= a1[12] )
          v5 = a1[11] - (_DWORD)v20;
        else
          v4 = a1[12] - (_DWORD)v20 - 1;
        if ( a1[12] == a1[13] )
        {
          *(_DWORD *)v17 = 8;
LABEL_108:
          a1[8] = v24;
          a1[7] = v23;
          a2[1] = v21;
          a2[2] += (int)&v22[-*a2];
          *a2 = (int)v22;
          a1[13] = v20;
          v16 = sub_80CC278((int)a1, a2, 1);
        }
        else
        {
          a1[8] = v24;
          a1[7] = v23;
          a2[1] = v21;
          a2[2] += (int)&v22[-*a2];
          *a2 = (int)v22;
          a1[13] = v20;
          v16 = sub_80CC278((int)a1, a2, v35);
        }
        return v16;
      case 8:
        goto LABEL_108;
      case 9:
        a1[8] = v24;
        a1[7] = v23;
        a2[1] = v21;
        a2[2] += (int)&v22[-*a2];
        *a2 = (int)v22;
        a1[13] = v20;
        return sub_80CC278((int)a1, a2, -3);
    }
  }
}

//----- (080CA538) --------------------------------------------------------
int __cdecl sub_80CA538(int a1, int a2)
{
  return (*(int (__cdecl **)(_DWORD, int))(a2 + 36))(*(_DWORD *)(a2 + 40), a1);
}

//----- (080CA558) --------------------------------------------------------
signed int __cdecl sub_80CA558(int a1, int a2, int a3, int a4, _DWORD *a5, int *a6)
{
  int v6; // ST54_4
  int v7; // ST2C_4
  _BYTE *v8; // edx
  _BYTE *v9; // edx
  _BYTE *v10; // ST40_4
  _BYTE *v11; // edx
  _BYTE *v12; // edx
  _BYTE *v13; // ST40_4
  _BYTE *v14; // edx
  _BYTE *v15; // edx
  int v16; // ST48_4
  int v17; // ST48_4
  int v18; // ST48_4
  int v19; // ST48_4
  unsigned int v21; // [esp+0h] [ebp-60h]
  unsigned int v22; // [esp+8h] [ebp-58h]
  unsigned int v23; // [esp+10h] [ebp-50h]
  unsigned int v24; // [esp+18h] [ebp-48h]
  int v25; // [esp+20h] [ebp-40h]
  signed int v26; // [esp+24h] [ebp-3Ch]
  _BYTE *v27; // [esp+28h] [ebp-38h]
  _BYTE *v28; // [esp+28h] [ebp-38h]
  int v29; // [esp+28h] [ebp-38h]
  int v30; // [esp+28h] [ebp-38h]
  unsigned int v31; // [esp+30h] [ebp-30h]
  int v32; // [esp+30h] [ebp-30h]
  int v33; // [esp+30h] [ebp-30h]
  int v34; // [esp+30h] [ebp-30h]
  int v35; // [esp+34h] [ebp-2Ch]
  int v36; // [esp+38h] [ebp-28h]
  unsigned int v37; // [esp+3Ch] [ebp-24h]
  _BYTE *v38; // [esp+40h] [ebp-20h]
  unsigned int v39; // [esp+44h] [ebp-1Ch]
  unsigned __int8 *v40; // [esp+48h] [ebp-18h]
  unsigned int v41; // [esp+4Ch] [ebp-14h]
  unsigned int i; // [esp+4Ch] [ebp-14h]
  unsigned int v43; // [esp+50h] [ebp-10h]
  unsigned int v44; // [esp+50h] [ebp-10h]
  int v45; // [esp+54h] [ebp-Ch]
  int j; // [esp+54h] [ebp-Ch]
  unsigned int v47; // [esp+54h] [ebp-Ch]
  unsigned int v48; // [esp+54h] [ebp-Ch]
  unsigned __int8 *v49; // [esp+58h] [ebp-8h]
  unsigned __int8 *v50; // [esp+58h] [ebp-8h]

  v40 = (unsigned __int8 *)*a6;
  v39 = a6[1];
  v43 = a5[8];
  v41 = a5[7];
  v38 = (_BYTE *)a5[13];
  if ( (unsigned int)v38 >= a5[12] )
    v25 = a5[11] - (_DWORD)v38;
  else
    v25 = a5[12] - (_DWORD)v38 - 1;
  v37 = v25;
  v36 = dword_8163EC0[a1];
  v35 = dword_8163EC0[a2];
  while ( 1 )
  {
    while ( v41 <= 0x13 )
    {
      --v39;
      v43 |= *v40++ << v41;
      v41 += 8;
    }
    v49 = (unsigned __int8 *)(a3 + 8 * (v43 & v36));
    v45 = *(unsigned __int8 *)(a3 + 8 * (v43 & v36));
    if ( *(_BYTE *)(a3 + 8 * (v43 & v36)) )
      break;
    v43 >>= v49[1];
    v41 -= v49[1];
    *v38++ = v49[4];
    --v37;
LABEL_47:
    if ( v37 <= 0x101 || v39 <= 9 )
    {
      v21 = a6[1] - v39;
      if ( v21 > v41 >> 3 )
        v21 = v41 >> 3;
      v19 = (int)&v40[-v21];
      a5[8] = v43;
      a5[7] = v41 - 8 * v21;
      a6[1] = v21 + v39;
      a6[2] += v19 - *a6;
      *a6 = v19;
      a5[13] = v38;
      return 0;
    }
  }
  while ( 1 )
  {
    v43 >>= v49[1];
    v41 -= v49[1];
    if ( v45 & 0x10 )
      break;
    if ( v45 & 0x40 )
    {
      if ( v45 & 0x20 )
      {
        v23 = a6[1] - v39;
        if ( v23 > v41 >> 3 )
          v23 = v41 >> 3;
        v17 = (int)&v40[-v23];
        a5[8] = v43;
        a5[7] = v41 - 8 * v23;
        a6[1] = v23 + v39;
        a6[2] += v17 - *a6;
        *a6 = v17;
        a5[13] = v38;
        v26 = 1;
      }
      else
      {
        a6[6] = (int)"invalid literal/length code";
        v22 = a6[1] - v39;
        if ( v22 > v41 >> 3 )
          v22 = v41 >> 3;
        v18 = (int)&v40[-v22];
        a5[8] = v43;
        a5[7] = v41 - 8 * v22;
        a6[1] = v22 + v39;
        a6[2] += v18 - *a6;
        *a6 = v18;
        a5[13] = v38;
        v26 = -3;
      }
      return v26;
    }
    v49 += 8 * (v43 & dword_8163EC0[v45]) + 8 * *((_DWORD *)v49 + 1);
    v45 = *v49;
    if ( !*v49 )
    {
      v43 >>= v49[1];
      v41 -= v49[1];
      *v38++ = v49[4];
      --v37;
      goto LABEL_47;
    }
  }
  v6 = v45 & 0xF;
  v31 = *((_DWORD *)v49 + 1) + (v43 & dword_8163EC0[v6]);
  v44 = v43 >> v6;
  for ( i = v41 - v6; i <= 0xE; i += 8 )
  {
    --v39;
    v44 |= *v40++ << i;
  }
  v50 = (unsigned __int8 *)(a4 + 8 * (v44 & v35));
  for ( j = *v50; ; j = *v50 )
  {
    v44 >>= v50[1];
    i -= v50[1];
    if ( j & 0x10 )
    {
      v47 = j & 0xF;
      while ( i < v47 )
      {
        --v39;
        v44 |= *v40++ << i;
        i += 8;
      }
      v7 = *((_DWORD *)v50 + 1) + (v44 & dword_8163EC0[v47]);
      v43 = v44 >> v47;
      v41 = i - v47;
      v37 -= v31;
      v27 = &v38[-v7];
      if ( (unsigned int)&v38[-v7] >= a5[10] )
      {
        *v38 = *v27;
        v13 = v38 + 1;
        v14 = v27 + 1;
        v30 = (int)(v27 + 2);
        *v13 = *v14;
        v38 = v13 + 1;
        v34 = v31 - 2;
        do
        {
          v15 = (_BYTE *)v30++;
          *v38++ = *v15;
          --v34;
        }
        while ( v34 );
      }
      else
      {
        do
          v27 += a5[11] - a5[10];
        while ( (unsigned int)v27 < a5[10] );
        v48 = a5[11] - (_DWORD)v27;
        if ( v31 <= v48 )
        {
          *v38 = *v27;
          v10 = v38 + 1;
          v11 = v27 + 1;
          v29 = (int)(v27 + 2);
          *v10 = *v11;
          v38 = v10 + 1;
          v33 = v31 - 2;
          do
          {
            v12 = (_BYTE *)v29++;
            *v38++ = *v12;
            --v33;
          }
          while ( v33 );
        }
        else
        {
          v32 = v31 - v48;
          do
          {
            v8 = v27++;
            *v38++ = *v8;
            --v48;
          }
          while ( v48 );
          v28 = (_BYTE *)a5[10];
          do
          {
            v9 = v28++;
            *v38++ = *v9;
            --v32;
          }
          while ( v32 );
        }
      }
      goto LABEL_47;
    }
    if ( j & 0x40 )
      break;
    v50 += 8 * (v44 & dword_8163EC0[j]) + 8 * *((_DWORD *)v50 + 1);
  }
  a6[6] = (int)"invalid distance code";
  v24 = a6[1] - v39;
  if ( v24 > i >> 3 )
    v24 = i >> 3;
  v16 = (int)&v40[-v24];
  a5[8] = v44;
  a5[7] = i - 8 * v24;
  a6[1] = v24 + v39;
  a6[2] += v16 - *a6;
  *a6 = v16;
  a5[13] = v38;
  return -3;
}

//----- (080CAC68) --------------------------------------------------------
signed int __cdecl sub_80CAC68(_DWORD *a1)
{
  signed int v2; // [esp+Ch] [ebp-Ch]

  if ( !a1 || !a1[7] )
    return -2;
  a1[5] = 0;
  a1[2] = 0;
  a1[6] = 0;
  if ( *(_DWORD *)(a1[7] + 12) )
    v2 = 7;
  else
    v2 = 0;
  *(_DWORD *)a1[7] = v2;
  sub_80C8044(*(_DWORD *)(a1[7] + 20), (int)a1, 0);
  return 0;
}

//----- (080CACFD) --------------------------------------------------------
signed int __cdecl sub_80CACFD(_DWORD *a1)
{
  if ( !a1 || !a1[7] || !a1[9] )
    return -2;
  if ( *(_DWORD *)(a1[7] + 20) )
    sub_80C969D(*(_DWORD *)(a1[7] + 20), (int)a1);
  ((void (__cdecl *)(_DWORD, _DWORD))a1[9])(a1[10], a1[7]);
  a1[7] = 0;
  return 0;
}

//----- (080CAD79) --------------------------------------------------------
signed int __cdecl sub_80CAD79(_DWORD *a1, int a2, _BYTE *a3, int a4)
{
  _DWORD *v4; // eax
  int v6; // [esp+8h] [ebp-20h]
  int v7; // [esp+1Ch] [ebp-Ch]
  signed int v8; // [esp+20h] [ebp-8h]

  if ( !a3 || *a3 != 49 || a4 != 56 )
    return -6;
  if ( !a1 )
    return -2;
  a1[6] = 0;
  if ( !a1[8] )
  {
    a1[8] = sub_80D1096;
    a1[10] = 0;
  }
  if ( !a1[9] )
    a1[9] = sub_80D10AD;
  a1[7] = ((int (__cdecl *)(_DWORD, signed int, signed int))a1[8])(a1[10], 1, 24);
  if ( !a1[7] )
    return -4;
  *(_DWORD *)(a1[7] + 20) = 0;
  *(_DWORD *)(a1[7] + 12) = 0;
  if ( a2 < 0 )
  {
    a2 = -a2;
    *(_DWORD *)(a1[7] + 12) = 1;
  }
  if ( a2 > 7 && a2 <= 15 )
  {
    *(_DWORD *)(a1[7] + 16) = a2;
    v7 = a1[7];
    v6 = 1 << a2;
    if ( *(_DWORD *)(a1[7] + 12) )
      v4 = sub_80C8114((int)a1, 0, v6);
    else
      v4 = sub_80C8114((int)a1, (int)sub_80C5628, v6);
    *(_DWORD *)(v7 + 20) = v4;
    if ( *(_DWORD *)(v7 + 20) )
    {
      sub_80CAC68(a1);
      v8 = 0;
    }
    else
    {
      sub_80CACFD(a1);
      v8 = -4;
    }
  }
  else
  {
    sub_80CACFD(a1);
    v8 = -2;
  }
  return v8;
}

//----- (080CAF10) --------------------------------------------------------
signed int __cdecl sub_80CAF10(_DWORD *a1, _BYTE *a2, int a3)
{
  return sub_80CAD79(a1, 15, a2, a3);
}

//----- (080CAF39) --------------------------------------------------------
signed int __cdecl sub_80CAF39(unsigned __int8 **a1, int a2)
{
  unsigned __int8 *v2; // ecx
  int v3; // eax
  int v4; // ebx
  unsigned __int8 *v5; // ecx
  unsigned __int8 *v6; // ebx
  unsigned __int8 *v7; // ecx
  unsigned __int8 *v8; // ebx
  unsigned __int8 *v9; // ecx
  unsigned __int8 *v10; // ebx
  unsigned __int8 *v11; // ecx
  unsigned __int8 *v12; // ecx
  unsigned __int8 *v13; // ebx
  unsigned __int8 *v14; // ecx
  unsigned __int8 *v15; // ebx
  unsigned __int8 *v16; // ecx
  unsigned __int8 *v17; // ebx
  unsigned __int8 *v18; // ecx
  signed int v20; // [esp+14h] [ebp-14h]
  signed int v21; // [esp+18h] [ebp-10h]
  int v22; // [esp+1Ch] [ebp-Ch]
  signed int v23; // [esp+20h] [ebp-8h]

  if ( !a1 || !a1[7] || !*a1 )
    return -2;
  if ( a2 == 4 )
    v20 = -5;
  else
    v20 = 0;
  v23 = -5;
  while ( 2 )
  {
    switch ( *(_DWORD *)a1[7] )
    {
      case 0:
        if ( a1[1] )
        {
          v23 = v20;
          v2 = a1[7];
          --a1[1];
          ++a1[2];
          *((_DWORD *)v2 + 1) = **a1;
          v3 = *((_DWORD *)v2 + 1) & 0xF;
          ++*a1;
          if ( v3 != 8 )
          {
            *(_DWORD *)a1[7] = 13;
            a1[6] = "unknown compression method";
            *((_DWORD *)a1[7] + 1) = 5;
            continue;
          }
          if ( (unsigned int)((*((_DWORD *)a1[7] + 1) >> 4) + 8) > *((_DWORD *)a1[7] + 4) )
          {
            *(_DWORD *)a1[7] = 13;
            a1[6] = "invalid window size";
            *((_DWORD *)a1[7] + 1) = 5;
            continue;
          }
          *(_DWORD *)a1[7] = 1;
          goto LABEL_17;
        }
        v21 = v23;
        break;
      case 1:
LABEL_17:
        if ( a1[1] )
        {
          v23 = v20;
          --a1[1];
          ++a1[2];
          v22 = *(*a1)++;
          v4 = v22 + (*((_DWORD *)a1[7] + 1) << 8);
          if ( v4 != 31
                   * ((unsigned int)(((unsigned int)v4 * (unsigned __int64)(unsigned int)&unk_8421085 >> 32)
                                   + ((unsigned int)(v22
                                                   + (*((_DWORD *)a1[7] + 1) << 8)
                                                   - ((unsigned int)v4 * (unsigned __int64)(unsigned int)&unk_8421085 >> 32)) >> 1)) >> 4) )
          {
            *(_DWORD *)a1[7] = 13;
            a1[6] = "incorrect header check";
            *((_DWORD *)a1[7] + 1) = 5;
            continue;
          }
          if ( !(v22 & 0x20) )
          {
            *(_DWORD *)a1[7] = 7;
            continue;
          }
          *(_DWORD *)a1[7] = 2;
          goto LABEL_24;
        }
        v21 = v23;
        break;
      case 2:
LABEL_24:
        if ( a1[1] )
        {
          v23 = v20;
          v5 = a1[7];
          --a1[1];
          ++a1[2];
          *((_DWORD *)v5 + 2) = *(*a1)++ << 24;
          *(_DWORD *)a1[7] = 3;
          goto LABEL_27;
        }
        v21 = v23;
        break;
      case 3:
LABEL_27:
        if ( a1[1] )
        {
          v23 = v20;
          v6 = a1[7];
          v7 = a1[7];
          --a1[1];
          ++a1[2];
          *((_DWORD *)v6 + 2) = *((_DWORD *)v7 + 2) + (*(*a1)++ << 16);
          *(_DWORD *)a1[7] = 4;
          goto LABEL_30;
        }
        v21 = v23;
        break;
      case 4:
LABEL_30:
        if ( a1[1] )
        {
          v23 = v20;
          v8 = a1[7];
          v9 = a1[7];
          --a1[1];
          ++a1[2];
          *((_DWORD *)v8 + 2) = *((_DWORD *)v9 + 2) + (*(*a1)++ << 8);
          *(_DWORD *)a1[7] = 5;
          goto LABEL_33;
        }
        v21 = v23;
        break;
      case 5:
LABEL_33:
        if ( a1[1] )
        {
          v10 = a1[7];
          v11 = a1[7];
          --a1[1];
          ++a1[2];
          *((_DWORD *)v10 + 2) = *((_DWORD *)v11 + 2) + *(*a1)++;
          a1[12] = (unsigned __int8 *)*((_DWORD *)a1[7] + 2);
          *(_DWORD *)a1[7] = 6;
          v21 = 2;
        }
        else
        {
          v21 = v23;
        }
        break;
      case 6:
        *(_DWORD *)a1[7] = 13;
        a1[6] = "need dictionary";
        *((_DWORD *)a1[7] + 1) = 0;
        v21 = -2;
        break;
      case 7:
        v23 = sub_80C8256(*((_DWORD *)a1[7] + 5), (int)a1, v23);
        if ( v23 == -3 )
        {
          *(_DWORD *)a1[7] = 13;
          *((_DWORD *)a1[7] + 1) = 0;
          continue;
        }
        if ( !v23 )
          v23 = v20;
        if ( v23 == 1 )
        {
          v23 = v20;
          sub_80C8044(*((_DWORD *)a1[7] + 5), (int)a1, (_DWORD *)a1[7] + 1);
          if ( *((_DWORD *)a1[7] + 3) )
          {
            *(_DWORD *)a1[7] = 12;
            continue;
          }
          *(_DWORD *)a1[7] = 8;
          goto LABEL_46;
        }
        v21 = v23;
        break;
      case 8:
LABEL_46:
        if ( a1[1] )
        {
          v23 = v20;
          v12 = a1[7];
          --a1[1];
          ++a1[2];
          *((_DWORD *)v12 + 2) = *(*a1)++ << 24;
          *(_DWORD *)a1[7] = 9;
          goto LABEL_49;
        }
        v21 = v23;
        break;
      case 9:
LABEL_49:
        if ( a1[1] )
        {
          v23 = v20;
          v13 = a1[7];
          v14 = a1[7];
          --a1[1];
          ++a1[2];
          *((_DWORD *)v13 + 2) = *((_DWORD *)v14 + 2) + (*(*a1)++ << 16);
          *(_DWORD *)a1[7] = 10;
          goto LABEL_52;
        }
        v21 = v23;
        break;
      case 0xA:
LABEL_52:
        if ( a1[1] )
        {
          v23 = v20;
          v15 = a1[7];
          v16 = a1[7];
          --a1[1];
          ++a1[2];
          *((_DWORD *)v15 + 2) = *((_DWORD *)v16 + 2) + (*(*a1)++ << 8);
          *(_DWORD *)a1[7] = 11;
          goto LABEL_55;
        }
        v21 = v23;
        break;
      case 0xB:
LABEL_55:
        if ( a1[1] )
        {
          v23 = v20;
          v17 = a1[7];
          v18 = a1[7];
          --a1[1];
          ++a1[2];
          *((_DWORD *)v17 + 2) = *((_DWORD *)v18 + 2) + *(*a1)++;
          if ( *((_DWORD *)a1[7] + 1) != *((_DWORD *)a1[7] + 2) )
          {
            *(_DWORD *)a1[7] = 13;
            a1[6] = "incorrect data check";
            *((_DWORD *)a1[7] + 1) = 5;
            continue;
          }
          *(_DWORD *)a1[7] = 12;
          goto LABEL_60;
        }
        v21 = v23;
        break;
      case 0xC:
LABEL_60:
        v21 = 1;
        break;
      case 0xD:
        v21 = -3;
        break;
    }
    return v21;
  }
}

//----- (080CB75C) --------------------------------------------------------
signed int __cdecl sub_80CB75C(int *a1, unsigned int a2, unsigned int a3, int a4, int a5, _DWORD *a6, unsigned int *a7, int a8, _DWORD *a9, int *a10)
{
  int v10; // eax
  int v11; // eax
  int v12; // ebx
  int v13; // ecx
  int v14; // edx
  int v15; // eax
  int v16; // edx
  int v17; // ebx
  int v18; // ecx
  int v19; // edx
  signed int v21; // [esp+0h] [ebp-128h]
  char v22; // [esp+7h] [ebp-121h]
  unsigned int v23; // [esp+8h] [ebp-120h]
  int v24; // [esp+Ch] [ebp-11Ch]
  int *v25; // [esp+10h] [ebp-118h]
  int *v26; // [esp+10h] [ebp-118h]
  int *v27; // [esp+10h] [ebp-118h]
  int *v28; // [esp+10h] [ebp-118h]
  int v29; // [esp+14h] [ebp-114h]
  unsigned int i; // [esp+18h] [ebp-110h]
  int v31; // [esp+18h] [ebp-110h]
  unsigned int v32; // [esp+18h] [ebp-110h]
  unsigned int l; // [esp+18h] [ebp-110h]
  unsigned int m; // [esp+18h] [ebp-110h]
  unsigned int v35; // [esp+1Ch] [ebp-10Ch]
  unsigned int j; // [esp+1Ch] [ebp-10Ch]
  unsigned int v37; // [esp+1Ch] [ebp-10Ch]
  unsigned int v38; // [esp+1Ch] [ebp-10Ch]
  signed int v39; // [esp+20h] [ebp-108h]
  unsigned int v40; // [esp+24h] [ebp-104h]
  int v41; // [esp+28h] [ebp-100h]
  int *k; // [esp+2Ch] [ebp-FCh]
  int v43; // [esp+30h] [ebp-F8h]
  int v44; // [esp+34h] [ebp-F4h]
  int v45; // [esp+38h] [ebp-F0h]
  int v46; // [esp+6Ch] [ebp-BCh]
  int v47[16]; // [esp+70h] [ebp-B8h]
  int v48; // [esp+B0h] [ebp-78h]
  unsigned int v49; // [esp+B4h] [ebp-74h]
  int v50; // [esp+B8h] [ebp-70h]
  int n; // [esp+BCh] [ebp-6Ch]
  unsigned int v52; // [esp+C0h] [ebp-68h]
  int v53; // [esp+C4h] [ebp-64h]
  int v54; // [esp+C8h] [ebp-60h]
  unsigned int v55; // [esp+CCh] [ebp-5Ch]
  int v56; // [esp+D0h] [ebp-58h]
  int v57; // [esp+D4h] [ebp-54h]
  int v58; // [esp+D8h] [ebp-50h]
  int v59; // [esp+DCh] [ebp-4Ch]
  int v60; // [esp+E0h] [ebp-48h]
  int v61; // [esp+E4h] [ebp-44h]
  int v62; // [esp+E8h] [ebp-40h]
  int v63; // [esp+ECh] [ebp-3Ch]
  int v64; // [esp+F0h] [ebp-38h]
  int v65; // [esp+F4h] [ebp-34h]
  int v66; // [esp+F8h] [ebp-30h]
  int v67; // [esp+FCh] [ebp-2Ch]
  int v68; // [esp+100h] [ebp-28h]
  int v69; // [esp+104h] [ebp-24h]
  int v70; // [esp+108h] [ebp-20h]
  int v71; // [esp+10Ch] [ebp-1Ch]
  int v72; // [esp+11Ch] [ebp-Ch]
  int v73; // [esp+134h] [ebp+Ch]

  v56 = 0;
  v57 = 0;
  v58 = 0;
  v59 = 0;
  v60 = 0;
  v61 = 0;
  v62 = 0;
  v63 = 0;
  v64 = 0;
  v65 = 0;
  v66 = 0;
  v67 = 0;
  v68 = 0;
  v69 = 0;
  v70 = 0;
  v71 = 0;
  v25 = a1;
  v35 = a2;
  do
  {
    v10 = *v25;
    ++v25;
    ++*(&v56 + v10);
    --v35;
  }
  while ( v35 );
  if ( v56 == a2 )
  {
    *a6 = 0;
    *a7 = 0;
    v39 = 0;
  }
  else
  {
    v52 = *a7;
    for ( i = 1; i <= 0xF && !*(&v56 + i); ++i )
      ;
    v29 = i;
    if ( v52 < i )
      v52 = i;
    for ( j = 15; j && !*(&v56 + j); --j )
      ;
    v54 = j;
    if ( v52 > j )
      v52 = j;
    *a7 = v52;
    v41 = 1 << i;
    while ( i < j )
    {
      v41 -= *(&v56 + i);
      if ( v41 < 0 )
        return -3;
      ++i;
      v41 *= 2;
    }
    v41 -= *(&v56 + j);
    if ( v41 >= 0 )
    {
      *(&v56 + j) += v41;
      v31 = 0;
      v44 = 0;
      v26 = &v57;
      for ( k = &v45; --j; ++k )
      {
        v31 += *v26;
        ++v26;
        *k = v31;
      }
      v27 = a1;
      v37 = 0;
      do
      {
        v11 = *v27;
        ++v27;
        if ( v11 )
          a10[(*(&v43 + v11))++] = v37;
        ++v37;
      }
      while ( v37 < a2 );
      v73 = *(&v43 + v54);
      v38 = 0;
      v43 = 0;
      v28 = a10;
      v53 = -1;
      v24 = -v52;
      v47[0] = 0;
      v50 = 0;
      v40 = 0;
      while ( v29 <= v54 )
      {
        v72 = *(&v56 + v29);
        while ( --v72 != -1 )
        {
          while ( v29 > (signed int)(v52 + v24) )
          {
            ++v53;
            v24 += v52;
            v23 = v54 - v24;
            if ( v54 - v24 > v52 )
              v23 = v52;
            v32 = v29 - v24;
            v55 = 1 << (v29 - v24);
            if ( 1 << (v29 - v24) > (unsigned int)(v72 + 1) )
            {
              v55 = v55 - v72 - 1;
              k = &v56 + v29;
              if ( v32 < v23 )
              {
                while ( ++v32 < v23 )
                {
                  v55 *= 2;
                  ++k;
                  if ( v55 <= *k )
                    break;
                  v55 -= *k;
                }
              }
            }
            v40 = 1 << v32;
            if ( (unsigned int)(*a9 + (1 << v32)) > 0x5A0 )
              return -3;
            v50 = a8 + 8 * *a9;
            v47[v53] = v50;
            *a9 += v40;
            if ( v53 )
            {
              *(&v43 + v53) = v38;
              BYTE1(v48) = v52;
              LOBYTE(v48) = v32;
              v49 = ((v50 - *(&v46 + v53)) >> 3) - (v38 >> (v24 - v52));
              v12 = 8 * (v38 >> (v24 - v52));
              v13 = *(&v46 + v53);
              v14 = v49;
              *(_DWORD *)(v13 + v12) = v48;
              *(_DWORD *)(v13 + v12 + 4) = v14;
            }
            else
            {
              *a6 = v50;
            }
          }
          BYTE1(v48) = v29 - v24;
          if ( v28 < &a10[v73] )
          {
            if ( *v28 >= a3 )
            {
              LOBYTE(v48) = *(_BYTE *)(a5 + 4 * (*v28 - a3)) + 80;
              v16 = 4 * (*v28 - a3);
              ++v28;
              v49 = *(_DWORD *)(a4 + v16);
            }
            else
            {
              if ( (unsigned int)*v28 <= 0xFF )
                v22 = 0;
              else
                v22 = 96;
              LOBYTE(v48) = v22;
              v15 = *v28;
              ++v28;
              v49 = v15;
            }
          }
          else
          {
            LOBYTE(v48) = -64;
          }
          v55 = 1 << (v29 - v24);
          for ( l = v38 >> v24; l < v40; l += v55 )
          {
            v17 = 8 * l;
            v18 = v50;
            v19 = v49;
            *(_DWORD *)(v50 + v17) = v48;
            *(_DWORD *)(v18 + v17 + 4) = v19;
          }
          for ( m = 1 << (v29 - 1); m & v38; m >>= 1 )
            v38 ^= m;
          v38 ^= m;
          for ( n = (1 << v24) - 1; (n & v38) != *(&v43 + v53); n = (1 << v24) - 1 )
          {
            --v53;
            v24 -= v52;
          }
        }
        ++v29;
      }
      if ( v41 && v54 != 1 )
        v21 = -5;
      else
        v21 = 0;
      v39 = v21;
    }
    else
    {
      v39 = -3;
    }
  }
  return v39;
}
// 80CB75C: using guessed type int var_B8[16];

//----- (080CBF7B) --------------------------------------------------------
signed int __cdecl sub_80CBF7B(int *a1, unsigned int *a2, _DWORD *a3, int a4, int a5)
{
  int *v7; // [esp+2Ch] [ebp-Ch]
  int v8; // [esp+30h] [ebp-8h]
  int v9; // [esp+34h] [ebp-4h]

  v8 = 0;
  v7 = (int *)(*(int (__cdecl **)(_DWORD, signed int, signed int))(a5 + 32))(*(_DWORD *)(a5 + 40), 19, 4);
  if ( !v7 )
    return -4;
  v9 = sub_80CB75C(a1, 0x13u, 0x13u, 0, 0, a3, a2, a4, &v8, v7);
  if ( v9 == -3 )
  {
    *(_DWORD *)(a5 + 24) = "oversubscribed dynamic bit lengths tree";
  }
  else if ( v9 == -5 || !*a2 )
  {
    *(_DWORD *)(a5 + 24) = "incomplete dynamic bit lengths tree";
    v9 = -3;
  }
  (*(void (__cdecl **)(_DWORD, int *))(a5 + 36))(*(_DWORD *)(a5 + 40), v7);
  return v9;
}

//----- (080CC064) --------------------------------------------------------
signed int __cdecl sub_80CC064(unsigned int a1, unsigned int a2, int *a3, unsigned int *a4, unsigned int *a5, _DWORD *a6, _DWORD *a7, int a8, int a9)
{
  int v10; // [esp+28h] [ebp-10h]
  int *v11; // [esp+2Ch] [ebp-Ch]
  int v12; // [esp+30h] [ebp-8h]
  int v13; // [esp+34h] [ebp-4h]

  v12 = 0;
  v11 = (int *)(*(int (__cdecl **)(_DWORD, signed int, signed int))(a9 + 32))(*(_DWORD *)(a9 + 40), 288, 4);
  if ( !v11 )
    return -4;
  v13 = sub_80CB75C(a3, a1, 0x101u, (int)&unk_8149A80, (int)&unk_8149B00, a6, a4, a8, &v12, v11);
  if ( !v13 && *a4 )
  {
    v13 = sub_80CB75C(&a3[a1], a2, 0, (int)&unk_8149B80, (int)&unk_8149C00, a7, a5, a8, &v12, v11);
    if ( !v13 && (*a5 || a1 <= 0x101) )
    {
      (*(void (__cdecl **)(_DWORD, int *))(a9 + 36))(*(_DWORD *)(a9 + 40), v11);
      v10 = 0;
    }
    else
    {
      if ( v13 == -3 )
      {
        *(_DWORD *)(a9 + 24) = "oversubscribed distance tree";
      }
      else if ( v13 == -5 )
      {
        *(_DWORD *)(a9 + 24) = "incomplete distance tree";
        v13 = -3;
      }
      else if ( v13 != -4 )
      {
        *(_DWORD *)(a9 + 24) = "empty distance tree with lengths";
        v13 = -3;
      }
      (*(void (__cdecl **)(_DWORD, int *))(a9 + 36))(*(_DWORD *)(a9 + 40), v11);
      v10 = v13;
    }
  }
  else
  {
    if ( v13 == -3 )
    {
      *(_DWORD *)(a9 + 24) = "oversubscribed literal/length tree";
    }
    else if ( v13 != -4 )
    {
      *(_DWORD *)(a9 + 24) = "incomplete literal/length tree";
      v13 = -3;
    }
    (*(void (__cdecl **)(_DWORD, int *))(a9 + 36))(*(_DWORD *)(a9 + 40), v11);
    v10 = v13;
  }
  return v10;
}

//----- (080CC247) --------------------------------------------------------
int __cdecl sub_80CC247(_DWORD *a1, _DWORD *a2, _DWORD *a3, _DWORD *a4)
{
  *a1 = dword_8162DA0;
  *a2 = dword_8162DA4;
  *a3 = &unk_8162DC0;
  *a4 = &unk_8163DC0;
  return 0;
}
// 8162DA0: using guessed type int dword_8162DA0;
// 8162DA4: using guessed type int dword_8162DA4;

//----- (080CC278) --------------------------------------------------------
int __cdecl sub_80CC278(int a1, _DWORD *a2, int a3)
{
  int v3; // eax
  char *src; // [esp+14h] [ebp-14h]
  char *srca; // [esp+14h] [ebp-14h]
  char *srcb; // [esp+14h] [ebp-14h]
  char *dest; // [esp+18h] [ebp-10h]
  int n; // [esp+1Ch] [ebp-Ch]
  unsigned int na; // [esp+1Ch] [ebp-Ch]

  dest = (char *)a2[3];
  src = *(char **)(a1 + 48);
  if ( (unsigned int)src > *(_DWORD *)(a1 + 52) )
    v3 = *(_DWORD *)(a1 + 44);
  else
    v3 = *(_DWORD *)(a1 + 52);
  n = v3 - (_DWORD)src;
  if ( (unsigned int)(v3 - (_DWORD)src) > a2[4] )
    n = a2[4];
  if ( n && a3 == -5 )
    a3 = 0;
  a2[4] -= n;
  a2[5] += n;
  if ( *(_DWORD *)(a1 + 56) )
  {
    *(_DWORD *)(a1 + 60) = (*(int (__cdecl **)(_DWORD, char *, int))(a1 + 56))(*(_DWORD *)(a1 + 60), src, n);
    a2[12] = *(_DWORD *)(a1 + 60);
  }
  if ( dest )
  {
    memcpy(dest, src, n);
    dest += n;
  }
  srca = &src[n];
  if ( srca == *(char **)(a1 + 44) )
  {
    srcb = *(char **)(a1 + 40);
    if ( *(_DWORD *)(a1 + 52) == *(_DWORD *)(a1 + 44) )
      *(_DWORD *)(a1 + 52) = *(_DWORD *)(a1 + 40);
    na = *(_DWORD *)(a1 + 52) - (_DWORD)srcb;
    if ( na > a2[4] )
      na = a2[4];
    if ( na && a3 == -5 )
      a3 = 0;
    a2[4] -= na;
    a2[5] += na;
    if ( *(_DWORD *)(a1 + 56) )
    {
      *(_DWORD *)(a1 + 60) = (*(int (__cdecl **)(_DWORD, char *, unsigned int))(a1 + 56))(
                               *(_DWORD *)(a1 + 60),
                               srcb,
                               na);
      a2[12] = *(_DWORD *)(a1 + 60);
    }
    if ( dest )
    {
      memcpy(dest, srcb, na);
      dest += na;
    }
    srca = &srcb[na];
  }
  a2[3] = dest;
  *(_DWORD *)(a1 + 48) = srca;
  return a3;
}

//----- (080CC478) --------------------------------------------------------
void sub_80CC478()
{
  ;
}

//----- (080CC47D) --------------------------------------------------------
int __cdecl sub_80CC47D(int a1)
{
  sub_80CC478();
  *(_DWORD *)(a1 + 2832) = a1 + 140;
  *(_DWORD *)(a1 + 2840) = &off_8163F04;
  *(_DWORD *)(a1 + 2844) = a1 + 2432;
  *(_DWORD *)(a1 + 2852) = &off_8163F18;
  *(_DWORD *)(a1 + 2856) = a1 + 2676;
  *(_DWORD *)(a1 + 2864) = &unk_8163F2C;
  *(_WORD *)(a1 + 5808) = 0;
  *(_DWORD *)(a1 + 5812) = 0;
  *(_DWORD *)(a1 + 5804) = 8;
  return sub_80CC515(a1);
}
// 8163F04: using guessed type void *off_8163F04;
// 8163F18: using guessed type void *off_8163F18;

//----- (080CC515) --------------------------------------------------------
int __cdecl sub_80CC515(int a1)
{
  int result; // eax
  signed int i; // [esp+0h] [ebp-4h]
  signed int j; // [esp+0h] [ebp-4h]
  signed int k; // [esp+0h] [ebp-4h]

  for ( i = 0; i <= 285; ++i )
    *(_WORD *)(a1 + 4 * i + 140) = 0;
  for ( j = 0; j <= 29; ++j )
    *(_WORD *)(a1 + 4 * j + 2432) = 0;
  for ( k = 0; k <= 18; ++k )
    *(_WORD *)(a1 + 4 * k + 2676) = 0;
  *(_WORD *)(a1 + 1164) = 1;
  *(_DWORD *)(a1 + 5796) = 0;
  *(_DWORD *)(a1 + 5792) = 0;
  result = a1;
  *(_DWORD *)(a1 + 5800) = 0;
  *(_DWORD *)(a1 + 5784) = 0;
  return result;
}

//----- (080CC5D2) --------------------------------------------------------
int __cdecl sub_80CC5D2(int a1, int a2, int a3)
{
  int result; // eax
  int i; // [esp+0h] [ebp-10h]
  int v5; // [esp+4h] [ebp-Ch]

  v5 = *(_DWORD *)(a1 + 4 * a3 + 2900);
  for ( i = 2 * a3; i <= *(_DWORD *)(a1 + 5192); i *= 2 )
  {
    if ( i < *(_DWORD *)(a1 + 5192)
      && (*(_WORD *)(a2 + 4 * *(_DWORD *)(a1 + 4 * i + 2904)) < *(_WORD *)(a2 + 4 * *(_DWORD *)(a1 + 4 * i + 2900))
       || *(_WORD *)(a2 + 4 * *(_DWORD *)(a1 + 4 * i + 2904)) == *(_WORD *)(a2 + 4 * *(_DWORD *)(a1 + 4 * i + 2900))
       && *(_BYTE *)(*(_DWORD *)(a1 + 4 * i + 2904) + a1 + 5200) <= *(_BYTE *)(*(_DWORD *)(a1 + 4 * i + 2900) + a1 + 5200)) )
    {
      ++i;
    }
    if ( *(_WORD *)(a2 + 4 * v5) < *(_WORD *)(a2 + 4 * *(_DWORD *)(a1 + 4 * i + 2900))
      || *(_WORD *)(a2 + 4 * v5) == *(_WORD *)(a2 + 4 * *(_DWORD *)(a1 + 4 * i + 2900))
      && *(_BYTE *)(v5 + a1 + 5200) <= *(_BYTE *)(*(_DWORD *)(a1 + 4 * i + 2900) + a1 + 5200) )
    {
      break;
    }
    *(_DWORD *)(a1 + 4 * a3 + 2900) = *(_DWORD *)(a1 + 4 * i + 2900);
    a3 = i;
  }
  result = v5;
  *(_DWORD *)(a1 + 4 * a3 + 2900) = v5;
  return result;
}

//----- (080CC794) --------------------------------------------------------
int *__cdecl sub_80CC794(_DWORD *a1, int a2)
{
  int *result; // eax
  int v3; // [esp+0h] [ebp-3Ch]
  unsigned __int16 v4; // [esp+6h] [ebp-36h]
  int v5; // [esp+8h] [ebp-34h]
  int *i; // [esp+Ch] [ebp-30h]
  int v7; // [esp+10h] [ebp-2Ch]
  int v8; // [esp+14h] [ebp-28h]
  int j; // [esp+18h] [ebp-24h]
  int *v10; // [esp+1Ch] [ebp-20h]
  int v11; // [esp+20h] [ebp-1Ch]
  int v12; // [esp+24h] [ebp-18h]
  int v13; // [esp+28h] [ebp-14h]
  int v14; // [esp+2Ch] [ebp-10h]
  int v15; // [esp+30h] [ebp-Ch]

  v15 = *(_DWORD *)a2;
  v14 = *(_DWORD *)(a2 + 4);
  v13 = **(_DWORD **)(a2 + 8);
  v12 = *(_DWORD *)(*(_DWORD *)(a2 + 8) + 4);
  v11 = *(_DWORD *)(*(_DWORD *)(a2 + 8) + 8);
  v10 = *(int **)(*(_DWORD *)(a2 + 8) + 16);
  v3 = 0;
  for ( i = 0; (signed int)i <= 15; i = (int *)((char *)i + 1) )
    *((_WORD *)a1 + (_DWORD)i + 1434) = 0;
  *(_WORD *)(v15 + 4 * a1[a1[1299] + 725] + 2) = 0;
  result = (int *)(a1[1299] + 1);
  for ( j = a1[1299] + 1; j <= 572; ++j )
  {
    v8 = a1[j + 725];
    i = (int *)(*(unsigned __int16 *)(v15 + 4 * *(unsigned __int16 *)(v15 + 4 * v8 + 2) + 2) + 1);
    if ( (signed int)i > (signed int)v10 )
    {
      i = v10;
      ++v3;
    }
    *(_WORD *)(v15 + 4 * v8 + 2) = (_WORD)i;
    if ( v8 <= v14 )
    {
      ++*((_WORD *)a1 + (_DWORD)i + 1434);
      v5 = 0;
      if ( v8 >= v11 )
        v5 = *(_DWORD *)(v12 + 4 * (v8 - v11));
      v4 = *(_WORD *)(v15 + 4 * v8);
      a1[1448] += v4 * ((_DWORD)i + v5);
      if ( v13 )
        a1[1449] += v4 * (v5 + *(unsigned __int16 *)(v13 + 4 * v8 + 2));
    }
    result = &j;
  }
  if ( v3 )
  {
    do
    {
      for ( i = (int *)((char *)v10 - 1); !*((_WORD *)a1 + (_DWORD)i + 1434); i = (int *)((char *)i - 1) )
        ;
      --*((_WORD *)a1 + (_DWORD)i + 1434);
      *((_WORD *)a1 + (_DWORD)i + 1435) += 2;
      --*((_WORD *)a1 + (_DWORD)v10 + 1434);
      v3 -= 2;
    }
    while ( v3 > 0 );
    result = v10;
    for ( i = v10; i; i = (int *)((char *)i - 1) )
    {
      v8 = *((unsigned __int16 *)a1 + (_DWORD)i + 1434);
      while ( v8 )
      {
        v7 = a1[--j + 725];
        if ( v7 <= v14 )
        {
          if ( (int *)*(unsigned __int16 *)(v15 + 4 * v7 + 2) != i )
          {
            a1[1448] += ((_DWORD)i - *(unsigned __int16 *)(v15 + 4 * v7 + 2)) * *(unsigned __int16 *)(v15 + 4 * v7);
            *(_WORD *)(v15 + 4 * v7 + 2) = (_WORD)i;
          }
          --v8;
        }
      }
      result = (int *)&i;
    }
  }
  return result;
}

//----- (080CCAD0) --------------------------------------------------------
int __cdecl sub_80CCAD0(int a1, int a2, int a3)
{
  int result; // eax
  unsigned __int16 v4; // cx
  int v5; // [esp+10h] [ebp-38h]
  int j; // [esp+14h] [ebp-34h]
  signed int i; // [esp+18h] [ebp-30h]
  __int16 v8; // [esp+1Eh] [ebp-2Ah]
  __int16 v9[20]; // [esp+20h] [ebp-28h]

  v8 = 0;
  for ( i = 1; i <= 15; ++i )
  {
    v8 = 2 * (*(_WORD *)(a3 + 2 * i - 2) + v8);
    v9[i] = v8;
  }
  for ( j = 0; ; ++j )
  {
    result = j;
    if ( j > a2 )
      break;
    v5 = *(unsigned __int16 *)(a1 + 4 * j + 2);
    if ( *(_WORD *)(a1 + 4 * j + 2) )
    {
      v4 = v9[v5];
      v9[v5] = v4 + 1;
      *(_WORD *)(a1 + 4 * j) = sub_80CF2D0(v4, v5);
    }
  }
  return result;
}
// 80CCAD0: using guessed type __int16 var_28[20];

//----- (080CCB86) --------------------------------------------------------
int __cdecl sub_80CCB86(_DWORD *a1, int a2)
{
  int v2; // edx
  char v3; // al
  int v4; // edx
  int v6; // [esp+14h] [ebp-34h]
  int v7; // [esp+20h] [ebp-28h]
  int v8; // [esp+24h] [ebp-24h]
  int v9; // [esp+28h] [ebp-20h]
  int i; // [esp+2Ch] [ebp-1Ch]
  int j; // [esp+2Ch] [ebp-1Ch]
  int v12; // [esp+2Ch] [ebp-1Ch]
  int v13; // [esp+30h] [ebp-18h]
  int v14; // [esp+34h] [ebp-14h]
  int v15; // [esp+38h] [ebp-10h]

  v15 = *(_DWORD *)a2;
  v14 = **(_DWORD **)(a2 + 8);
  v13 = *(_DWORD *)(*(_DWORD *)(a2 + 8) + 12);
  v8 = -1;
  a1[1298] = 0;
  a1[1299] = 573;
  for ( i = 0; i < v13; ++i )
  {
    if ( *(_WORD *)(v15 + 4 * i) )
    {
      ++a1[1298];
      v8 = i;
      a1[a1[1298] + 725] = i;
      *((_BYTE *)a1 + i + 5200) = 0;
    }
    else
    {
      *(_WORD *)(v15 + 4 * i + 2) = 0;
    }
  }
  while ( a1[1298] <= 1 )
  {
    ++a1[1298];
    if ( v8 > 1 )
      v6 = 0;
    else
      v6 = ++v8;
    a1[a1[1298] + 725] = v6;
    *(_WORD *)(v15 + 4 * v6) = 1;
    *((_BYTE *)a1 + v6 + 5200) = 0;
    --a1[1448];
    if ( v14 )
      a1[1449] -= *(unsigned __int16 *)(v14 + 4 * v6 + 2);
  }
  *(_DWORD *)(a2 + 4) = v8;
  for ( j = a1[1298] / 2; j > 0; --j )
    sub_80CC5D2((int)a1, v15, j);
  v7 = v13;
  do
  {
    v12 = a1[726];
    v2 = a1[1298]--;
    a1[726] = a1[v2 + 725];
    sub_80CC5D2((int)a1, v15, 1);
    v9 = a1[726];
    a1[--a1[1299] + 725] = v12;
    a1[--a1[1299] + 725] = v9;
    *(_WORD *)(v15 + 4 * v7) = *(_WORD *)(v15 + 4 * v9) + *(_WORD *)(v15 + 4 * v12);
    if ( *((_BYTE *)a1 + v12 + 5200) < *((_BYTE *)a1 + v9 + 5200) )
      v3 = *((_BYTE *)a1 + v9 + 5200);
    else
      v3 = *((_BYTE *)a1 + v12 + 5200);
    *((_BYTE *)a1 + v7 + 5200) = v3 + 1;
    *(_WORD *)(v15 + 4 * v9 + 2) = v7;
    *(_WORD *)(v15 + 4 * v12 + 2) = *(_WORD *)(v15 + 4 * v9 + 2);
    v4 = v7++;
    a1[726] = v4;
    sub_80CC5D2((int)a1, v15, 1);
  }
  while ( a1[1298] > 1 );
  a1[--a1[1299] + 725] = a1[726];
  sub_80CC794(a1, a2);
  return sub_80CCAD0(v15, v8, (int)(a1 + 717));
}

//----- (080CCF25) --------------------------------------------------------
int __cdecl sub_80CCF25(_WORD *a1, int a2, int a3)
{
  int result; // eax
  signed int v4; // [esp+0h] [ebp-20h]
  signed int v5; // [esp+4h] [ebp-1Ch]
  signed int v6; // [esp+8h] [ebp-18h]
  signed int v7; // [esp+Ch] [ebp-14h]
  signed int v8; // [esp+10h] [ebp-10h]
  signed int v9; // [esp+14h] [ebp-Ch]
  int i; // [esp+18h] [ebp-8h]

  v9 = -1;
  v7 = *(unsigned __int16 *)(a2 + 2);
  v6 = 0;
  v5 = 7;
  v4 = 4;
  if ( !*(_WORD *)(a2 + 2) )
  {
    v5 = 138;
    v4 = 3;
  }
  *(_WORD *)(a2 + 4 * a3 + 6) = -1;
  for ( i = 0; ; ++i )
  {
    result = i;
    if ( i > a3 )
      break;
    v8 = v7;
    v7 = *(unsigned __int16 *)(a2 + 4 * i + 6);
    if ( ++v6 >= v5 || v8 != v7 )
    {
      if ( v6 >= v4 )
      {
        if ( v8 )
        {
          if ( v8 != v9 )
            ++a1[2 * v8 + 1338];
          ++a1[1370];
        }
        else if ( v6 > 10 )
        {
          ++a1[1374];
        }
        else
        {
          ++a1[1372];
        }
      }
      else
      {
        a1[2 * v8 + 1338] += v6;
      }
      v6 = 0;
      v9 = v8;
      if ( v7 )
      {
        if ( v8 == v7 )
        {
          v5 = 6;
          v4 = 3;
        }
        else
        {
          v5 = 7;
          v4 = 4;
        }
      }
      else
      {
        v5 = 138;
        v4 = 3;
      }
    }
  }
  return result;
}

//----- (080CD0B8) --------------------------------------------------------
int __cdecl sub_80CD0B8(int a1, int a2, int a3)
{
  int result; // eax
  int v4; // ST00_4
  int v5; // eax
  int v6; // ST04_4
  int v7; // eax
  int v8; // ST04_4
  int v9; // eax
  int v10; // eax
  int v11; // ST04_4
  int v12; // eax
  int v13; // eax
  int v14; // ST04_4
  int v15; // eax
  int v16; // eax
  int v17; // [esp+0h] [ebp-2Ch]
  int v18; // [esp+0h] [ebp-2Ch]
  int v19; // [esp+0h] [ebp-2Ch]
  int v20; // [esp+0h] [ebp-2Ch]
  int v21; // [esp+4h] [ebp-28h]
  signed int v22; // [esp+8h] [ebp-24h]
  signed int v23; // [esp+Ch] [ebp-20h]
  signed int v24; // [esp+10h] [ebp-1Ch]
  signed int v25; // [esp+14h] [ebp-18h]
  signed int v26; // [esp+18h] [ebp-14h]
  signed int v27; // [esp+1Ch] [ebp-10h]
  int i; // [esp+20h] [ebp-Ch]

  v27 = -1;
  v25 = *(unsigned __int16 *)(a2 + 2);
  v24 = 0;
  v23 = 7;
  v22 = 4;
  if ( !*(_WORD *)(a2 + 2) )
  {
    v23 = 138;
    v22 = 3;
  }
  for ( i = 0; ; ++i )
  {
    result = i;
    if ( i > a3 )
      break;
    v26 = v25;
    v25 = *(unsigned __int16 *)(a2 + 4 * i + 6);
    if ( ++v24 >= v23 || v26 != v25 )
    {
      if ( v24 >= v22 )
      {
        if ( v26 )
        {
          if ( v26 != v27 )
          {
            v17 = *(unsigned __int16 *)(a1 + 4 * v26 + 2678);
            if ( *(_DWORD *)(a1 + 5812) <= 16 - v17 )
            {
              *(_WORD *)(a1 + 5808) |= *(unsigned __int16 *)(a1 + 4 * v26 + 2676) << *(_BYTE *)(a1 + 5812);
              v7 = *(_DWORD *)(a1 + 5812) + v17;
            }
            else
            {
              v6 = *(unsigned __int16 *)(a1 + 4 * v26 + 2676);
              *(_WORD *)(a1 + 5808) |= v6 << *(_BYTE *)(a1 + 5812);
              *(_BYTE *)(*(_DWORD *)(a1 + 8) + (*(_DWORD *)(a1 + 20))++) = *(_BYTE *)(a1 + 5808);
              *(_BYTE *)(*(_DWORD *)(a1 + 8) + (*(_DWORD *)(a1 + 20))++) = *(_WORD *)(a1 + 5808) >> 8;
              *(_WORD *)(a1 + 5808) = (signed int)(unsigned __int16)v6 >> (16 - *(_BYTE *)(a1 + 5812));
              v7 = *(_DWORD *)(a1 + 5812) + v17 - 16;
            }
            *(_DWORD *)(a1 + 5812) = v7;
            --v24;
          }
          v18 = *(unsigned __int16 *)(a1 + 2742);
          if ( *(_DWORD *)(a1 + 5812) <= 16 - v18 )
          {
            *(_WORD *)(a1 + 5808) |= *(unsigned __int16 *)(a1 + 2740) << *(_BYTE *)(a1 + 5812);
            v9 = *(_DWORD *)(a1 + 5812) + v18;
          }
          else
          {
            v8 = *(unsigned __int16 *)(a1 + 2740);
            *(_WORD *)(a1 + 5808) |= v8 << *(_BYTE *)(a1 + 5812);
            *(_BYTE *)(*(_DWORD *)(a1 + 8) + (*(_DWORD *)(a1 + 20))++) = *(_BYTE *)(a1 + 5808);
            *(_BYTE *)(*(_DWORD *)(a1 + 8) + (*(_DWORD *)(a1 + 20))++) = *(_WORD *)(a1 + 5808) >> 8;
            *(_WORD *)(a1 + 5808) = (signed int)(unsigned __int16)v8 >> (16 - *(_BYTE *)(a1 + 5812));
            v9 = *(_DWORD *)(a1 + 5812) + v18 - 16;
          }
          *(_DWORD *)(a1 + 5812) = v9;
          if ( *(_DWORD *)(a1 + 5812) <= 14 )
          {
            *(_WORD *)(a1 + 5808) |= (v24 - 3) << *(_BYTE *)(a1 + 5812);
            v10 = *(_DWORD *)(a1 + 5812) + 2;
          }
          else
          {
            *(_WORD *)(a1 + 5808) |= (v24 - 3) << *(_BYTE *)(a1 + 5812);
            *(_BYTE *)(*(_DWORD *)(a1 + 8) + (*(_DWORD *)(a1 + 20))++) = *(_BYTE *)(a1 + 5808);
            *(_BYTE *)(*(_DWORD *)(a1 + 8) + (*(_DWORD *)(a1 + 20))++) = *(_WORD *)(a1 + 5808) >> 8;
            *(_WORD *)(a1 + 5808) = (signed int)(unsigned __int16)(v24 - 3) >> (16 - *(_BYTE *)(a1 + 5812));
            v10 = *(_DWORD *)(a1 + 5812) - 14;
          }
          *(_DWORD *)(a1 + 5812) = v10;
        }
        else if ( v24 > 10 )
        {
          v20 = *(unsigned __int16 *)(a1 + 2750);
          if ( *(_DWORD *)(a1 + 5812) <= 16 - v20 )
          {
            *(_WORD *)(a1 + 5808) |= *(unsigned __int16 *)(a1 + 2748) << *(_BYTE *)(a1 + 5812);
            v15 = *(_DWORD *)(a1 + 5812) + v20;
          }
          else
          {
            v14 = *(unsigned __int16 *)(a1 + 2748);
            *(_WORD *)(a1 + 5808) |= v14 << *(_BYTE *)(a1 + 5812);
            *(_BYTE *)(*(_DWORD *)(a1 + 8) + (*(_DWORD *)(a1 + 20))++) = *(_BYTE *)(a1 + 5808);
            *(_BYTE *)(*(_DWORD *)(a1 + 8) + (*(_DWORD *)(a1 + 20))++) = *(_WORD *)(a1 + 5808) >> 8;
            *(_WORD *)(a1 + 5808) = (signed int)(unsigned __int16)v14 >> (16 - *(_BYTE *)(a1 + 5812));
            v15 = *(_DWORD *)(a1 + 5812) + v20 - 16;
          }
          *(_DWORD *)(a1 + 5812) = v15;
          if ( *(_DWORD *)(a1 + 5812) <= 9 )
          {
            *(_WORD *)(a1 + 5808) |= (v24 - 11) << *(_BYTE *)(a1 + 5812);
            v16 = *(_DWORD *)(a1 + 5812) + 7;
          }
          else
          {
            *(_WORD *)(a1 + 5808) |= (v24 - 11) << *(_BYTE *)(a1 + 5812);
            *(_BYTE *)(*(_DWORD *)(a1 + 8) + (*(_DWORD *)(a1 + 20))++) = *(_BYTE *)(a1 + 5808);
            *(_BYTE *)(*(_DWORD *)(a1 + 8) + (*(_DWORD *)(a1 + 20))++) = *(_WORD *)(a1 + 5808) >> 8;
            *(_WORD *)(a1 + 5808) = (signed int)(unsigned __int16)(v24 - 11) >> (16 - *(_BYTE *)(a1 + 5812));
            v16 = *(_DWORD *)(a1 + 5812) - 9;
          }
          *(_DWORD *)(a1 + 5812) = v16;
        }
        else
        {
          v19 = *(unsigned __int16 *)(a1 + 2746);
          if ( *(_DWORD *)(a1 + 5812) <= 16 - v19 )
          {
            *(_WORD *)(a1 + 5808) |= *(unsigned __int16 *)(a1 + 2744) << *(_BYTE *)(a1 + 5812);
            v12 = *(_DWORD *)(a1 + 5812) + v19;
          }
          else
          {
            v11 = *(unsigned __int16 *)(a1 + 2744);
            *(_WORD *)(a1 + 5808) |= v11 << *(_BYTE *)(a1 + 5812);
            *(_BYTE *)(*(_DWORD *)(a1 + 8) + (*(_DWORD *)(a1 + 20))++) = *(_BYTE *)(a1 + 5808);
            *(_BYTE *)(*(_DWORD *)(a1 + 8) + (*(_DWORD *)(a1 + 20))++) = *(_WORD *)(a1 + 5808) >> 8;
            *(_WORD *)(a1 + 5808) = (signed int)(unsigned __int16)v11 >> (16 - *(_BYTE *)(a1 + 5812));
            v12 = *(_DWORD *)(a1 + 5812) + v19 - 16;
          }
          *(_DWORD *)(a1 + 5812) = v12;
          if ( *(_DWORD *)(a1 + 5812) <= 13 )
          {
            *(_WORD *)(a1 + 5808) |= (v24 - 3) << *(_BYTE *)(a1 + 5812);
            v13 = *(_DWORD *)(a1 + 5812) + 3;
          }
          else
          {
            *(_WORD *)(a1 + 5808) |= (v24 - 3) << *(_BYTE *)(a1 + 5812);
            *(_BYTE *)(*(_DWORD *)(a1 + 8) + (*(_DWORD *)(a1 + 20))++) = *(_BYTE *)(a1 + 5808);
            *(_BYTE *)(*(_DWORD *)(a1 + 8) + (*(_DWORD *)(a1 + 20))++) = *(_WORD *)(a1 + 5808) >> 8;
            *(_WORD *)(a1 + 5808) = (signed int)(unsigned __int16)(v24 - 3) >> (16 - *(_BYTE *)(a1 + 5812));
            v13 = *(_DWORD *)(a1 + 5812) - 13;
          }
          *(_DWORD *)(a1 + 5812) = v13;
        }
      }
      else
      {
        do
        {
          v21 = *(unsigned __int16 *)(a1 + 4 * v26 + 2678);
          if ( *(_DWORD *)(a1 + 5812) <= 16 - v21 )
          {
            *(_WORD *)(a1 + 5808) |= *(unsigned __int16 *)(a1 + 4 * v26 + 2676) << *(_BYTE *)(a1 + 5812);
            v5 = *(_DWORD *)(a1 + 5812) + v21;
          }
          else
          {
            v4 = *(unsigned __int16 *)(a1 + 4 * v26 + 2676);
            *(_WORD *)(a1 + 5808) |= v4 << *(_BYTE *)(a1 + 5812);
            *(_BYTE *)(*(_DWORD *)(a1 + 8) + (*(_DWORD *)(a1 + 20))++) = *(_BYTE *)(a1 + 5808);
            *(_BYTE *)(*(_DWORD *)(a1 + 8) + (*(_DWORD *)(a1 + 20))++) = *(_WORD *)(a1 + 5808) >> 8;
            *(_WORD *)(a1 + 5808) = (signed int)(unsigned __int16)v4 >> (16 - *(_BYTE *)(a1 + 5812));
            v5 = *(_DWORD *)(a1 + 5812) + v21 - 16;
          }
          *(_DWORD *)(a1 + 5812) = v5;
          --v24;
        }
        while ( v24 );
      }
      v24 = 0;
      v27 = v26;
      if ( v25 )
      {
        if ( v26 == v25 )
        {
          v23 = 6;
          v22 = 3;
        }
        else
        {
          v23 = 7;
          v22 = 4;
        }
      }
      else
      {
        v23 = 138;
        v22 = 3;
      }
    }
  }
  return result;
}

//----- (080CDA7E) --------------------------------------------------------
signed int __cdecl sub_80CDA7E(int a1)
{
  signed int i; // [esp+10h] [ebp-8h]

  sub_80CCF25((_WORD *)a1, a1 + 140, *(_DWORD *)(a1 + 2836));
  sub_80CCF25((_WORD *)a1, a1 + 2432, *(_DWORD *)(a1 + 2848));
  sub_80CCB86((_DWORD *)a1, a1 + 2856);
  for ( i = 18; i > 2 && !*(_WORD *)(a1 + 4 * *(unsigned __int8 *)(i + 135569196) + 2678); --i )
    ;
  *(_DWORD *)(a1 + 5792) += 3 * i + 17;
  return i;
}

//----- (080CDB3D) --------------------------------------------------------
int __cdecl sub_80CDB3D(int a1, int a2, int a3, int a4)
{
  int v4; // eax
  int v5; // eax
  int v6; // eax
  int v7; // ST18_4
  int v8; // eax
  int i; // [esp+1Ch] [ebp-Ch]

  if ( *(_DWORD *)(a1 + 5812) <= 11 )
  {
    *(_WORD *)(a1 + 5808) |= (a2 - 257) << *(_BYTE *)(a1 + 5812);
    v4 = *(_DWORD *)(a1 + 5812) + 5;
  }
  else
  {
    *(_WORD *)(a1 + 5808) |= (a2 - 257) << *(_BYTE *)(a1 + 5812);
    *(_BYTE *)(*(_DWORD *)(a1 + 8) + (*(_DWORD *)(a1 + 20))++) = *(_BYTE *)(a1 + 5808);
    *(_BYTE *)(*(_DWORD *)(a1 + 8) + (*(_DWORD *)(a1 + 20))++) = *(_WORD *)(a1 + 5808) >> 8;
    *(_WORD *)(a1 + 5808) = (signed int)(unsigned __int16)(a2 - 257) >> (16 - *(_BYTE *)(a1 + 5812));
    v4 = *(_DWORD *)(a1 + 5812) - 11;
  }
  *(_DWORD *)(a1 + 5812) = v4;
  if ( *(_DWORD *)(a1 + 5812) <= 11 )
  {
    *(_WORD *)(a1 + 5808) |= (a3 - 1) << *(_BYTE *)(a1 + 5812);
    v5 = *(_DWORD *)(a1 + 5812) + 5;
  }
  else
  {
    *(_WORD *)(a1 + 5808) |= (a3 - 1) << *(_BYTE *)(a1 + 5812);
    *(_BYTE *)(*(_DWORD *)(a1 + 8) + (*(_DWORD *)(a1 + 20))++) = *(_BYTE *)(a1 + 5808);
    *(_BYTE *)(*(_DWORD *)(a1 + 8) + (*(_DWORD *)(a1 + 20))++) = *(_WORD *)(a1 + 5808) >> 8;
    *(_WORD *)(a1 + 5808) = (signed int)(unsigned __int16)(a3 - 1) >> (16 - *(_BYTE *)(a1 + 5812));
    v5 = *(_DWORD *)(a1 + 5812) - 11;
  }
  *(_DWORD *)(a1 + 5812) = v5;
  if ( *(_DWORD *)(a1 + 5812) <= 12 )
  {
    *(_WORD *)(a1 + 5808) |= (a4 - 4) << *(_BYTE *)(a1 + 5812);
    v6 = *(_DWORD *)(a1 + 5812) + 4;
  }
  else
  {
    *(_WORD *)(a1 + 5808) |= (a4 - 4) << *(_BYTE *)(a1 + 5812);
    *(_BYTE *)(*(_DWORD *)(a1 + 8) + (*(_DWORD *)(a1 + 20))++) = *(_BYTE *)(a1 + 5808);
    *(_BYTE *)(*(_DWORD *)(a1 + 8) + (*(_DWORD *)(a1 + 20))++) = *(_WORD *)(a1 + 5808) >> 8;
    *(_WORD *)(a1 + 5808) = (signed int)(unsigned __int16)(a4 - 4) >> (16 - *(_BYTE *)(a1 + 5812));
    v6 = *(_DWORD *)(a1 + 5812) - 12;
  }
  *(_DWORD *)(a1 + 5812) = v6;
  for ( i = 0; i < a4; ++i )
  {
    if ( *(_DWORD *)(a1 + 5812) <= 13 )
    {
      *(_WORD *)(a1 + 5808) |= *(unsigned __int16 *)(a1 + 4 * *(unsigned __int8 *)(i + 135569196) + 2678) << *(_BYTE *)(a1 + 5812);
      v8 = *(_DWORD *)(a1 + 5812) + 3;
    }
    else
    {
      v7 = *(unsigned __int16 *)(a1 + 4 * *(unsigned __int8 *)(i + 135569196) + 2678);
      *(_WORD *)(a1 + 5808) |= v7 << *(_BYTE *)(a1 + 5812);
      *(_BYTE *)(*(_DWORD *)(a1 + 8) + (*(_DWORD *)(a1 + 20))++) = *(_BYTE *)(a1 + 5808);
      *(_BYTE *)(*(_DWORD *)(a1 + 8) + (*(_DWORD *)(a1 + 20))++) = *(_WORD *)(a1 + 5808) >> 8;
      *(_WORD *)(a1 + 5808) = (signed int)(unsigned __int16)v7 >> (16 - *(_BYTE *)(a1 + 5812));
      v8 = *(_DWORD *)(a1 + 5812) - 13;
    }
    *(_DWORD *)(a1 + 5812) = v8;
  }
  sub_80CD0B8(a1, a1 + 140, a2 - 1);
  return sub_80CD0B8(a1, a1 + 2432, a3 - 1);
}

//----- (080CDFE1) --------------------------------------------------------
int *__cdecl sub_80CDFE1(int a1, _BYTE *a2, int a3, int a4)
{
  int v4; // eax

  if ( *(_DWORD *)(a1 + 5812) <= 13 )
  {
    *(_WORD *)(a1 + 5808) |= a4 << *(_BYTE *)(a1 + 5812);
    v4 = *(_DWORD *)(a1 + 5812) + 3;
  }
  else
  {
    *(_WORD *)(a1 + 5808) |= a4 << *(_BYTE *)(a1 + 5812);
    *(_BYTE *)(*(_DWORD *)(a1 + 8) + (*(_DWORD *)(a1 + 20))++) = *(_BYTE *)(a1 + 5808);
    *(_BYTE *)(*(_DWORD *)(a1 + 8) + (*(_DWORD *)(a1 + 20))++) = *(_WORD *)(a1 + 5808) >> 8;
    *(_WORD *)(a1 + 5808) = (signed int)(unsigned __int16)a4 >> (16 - *(_BYTE *)(a1 + 5812));
    v4 = *(_DWORD *)(a1 + 5812) - 13;
  }
  *(_DWORD *)(a1 + 5812) = v4;
  return sub_80CF458((_DWORD *)a1, a2, a3, 1);
}

//----- (080CE10F) --------------------------------------------------------
int __cdecl sub_80CE10F(int a1)
{
  int v1; // eax
  char v2; // cl
  int v3; // eax
  char v4; // cl
  int v5; // eax
  char v6; // cl
  int v7; // eax
  char v8; // cl
  int result; // eax

  if ( *(_DWORD *)(a1 + 5812) <= 13 )
  {
    *(_WORD *)(a1 + 5808) |= 2 << *(_BYTE *)(a1 + 5812);
    v1 = *(_DWORD *)(a1 + 5812) + 3;
  }
  else
  {
    *(_WORD *)(a1 + 5808) |= 2 << *(_BYTE *)(a1 + 5812);
    *(_BYTE *)(*(_DWORD *)(a1 + 8) + (*(_DWORD *)(a1 + 20))++) = *(_BYTE *)(a1 + 5808);
    *(_BYTE *)(*(_DWORD *)(a1 + 8) + (*(_DWORD *)(a1 + 20))++) = *(_WORD *)(a1 + 5808) >> 8;
    *(_WORD *)(a1 + 5808) = 2 >> (16 - *(_BYTE *)(a1 + 5812));
    v1 = *(_DWORD *)(a1 + 5812) - 13;
  }
  *(_DWORD *)(a1 + 5812) = v1;
  if ( *(_DWORD *)(a1 + 5812) <= 9 )
  {
    v4 = *(_BYTE *)(a1 + 5812);
    *(_WORD *)(a1 + 5808) = *(_WORD *)(a1 + 5808);
    v3 = *(_DWORD *)(a1 + 5812) + 7;
  }
  else
  {
    v2 = *(_BYTE *)(a1 + 5812);
    *(_WORD *)(a1 + 5808) = *(_WORD *)(a1 + 5808);
    *(_BYTE *)(*(_DWORD *)(a1 + 8) + (*(_DWORD *)(a1 + 20))++) = *(_BYTE *)(a1 + 5808);
    *(_BYTE *)(*(_DWORD *)(a1 + 8) + (*(_DWORD *)(a1 + 20))++) = *(_WORD *)(a1 + 5808) >> 8;
    *(_BYTE *)(a1 + 5812);
    *(_WORD *)(a1 + 5808) = 0;
    v3 = *(_DWORD *)(a1 + 5812) - 9;
  }
  *(_DWORD *)(a1 + 5812) = v3;
  sub_80CF2FE(a1);
  if ( *(_DWORD *)(a1 + 5804) - *(_DWORD *)(a1 + 5812) + 11 <= 8 )
  {
    if ( *(_DWORD *)(a1 + 5812) <= 13 )
    {
      *(_WORD *)(a1 + 5808) |= 2 << *(_BYTE *)(a1 + 5812);
      v5 = *(_DWORD *)(a1 + 5812) + 3;
    }
    else
    {
      *(_WORD *)(a1 + 5808) |= 2 << *(_BYTE *)(a1 + 5812);
      *(_BYTE *)(*(_DWORD *)(a1 + 8) + (*(_DWORD *)(a1 + 20))++) = *(_BYTE *)(a1 + 5808);
      *(_BYTE *)(*(_DWORD *)(a1 + 8) + (*(_DWORD *)(a1 + 20))++) = *(_WORD *)(a1 + 5808) >> 8;
      *(_WORD *)(a1 + 5808) = 2 >> (16 - *(_BYTE *)(a1 + 5812));
      v5 = *(_DWORD *)(a1 + 5812) - 13;
    }
    *(_DWORD *)(a1 + 5812) = v5;
    if ( *(_DWORD *)(a1 + 5812) <= 9 )
    {
      v8 = *(_BYTE *)(a1 + 5812);
      *(_WORD *)(a1 + 5808) = *(_WORD *)(a1 + 5808);
      v7 = *(_DWORD *)(a1 + 5812) + 7;
    }
    else
    {
      v6 = *(_BYTE *)(a1 + 5812);
      *(_WORD *)(a1 + 5808) = *(_WORD *)(a1 + 5808);
      *(_BYTE *)(*(_DWORD *)(a1 + 8) + (*(_DWORD *)(a1 + 20))++) = *(_BYTE *)(a1 + 5808);
      *(_BYTE *)(*(_DWORD *)(a1 + 8) + (*(_DWORD *)(a1 + 20))++) = *(_WORD *)(a1 + 5808) >> 8;
      *(_BYTE *)(a1 + 5812);
      *(_WORD *)(a1 + 5808) = 0;
      v7 = *(_DWORD *)(a1 + 5812) - 9;
    }
    *(_DWORD *)(a1 + 5812) = v7;
    sub_80CF2FE(a1);
  }
  result = a1;
  *(_DWORD *)(a1 + 5804) = 7;
  return result;
}

//----- (080CE57D) --------------------------------------------------------
int __cdecl sub_80CE57D(int a1, _BYTE *a2, int a3, int a4)
{
  int v4; // eax
  int v5; // eax
  int result; // eax
  signed int v7; // [esp+24h] [ebp-14h]
  unsigned int v8; // [esp+28h] [ebp-10h]
  unsigned int v9; // [esp+2Ch] [ebp-Ch]

  v7 = 0;
  if ( *(_DWORD *)(a1 + 124) <= 0 )
  {
    v8 = a3 + 5;
    v9 = a3 + 5;
  }
  else
  {
    if ( *(_BYTE *)(a1 + 28) == 2 )
      sub_80CF236(a1);
    sub_80CCB86((_DWORD *)a1, a1 + 2832);
    sub_80CCB86((_DWORD *)a1, a1 + 2844);
    v7 = sub_80CDA7E(a1);
    v9 = (unsigned int)(*(_DWORD *)(a1 + 5792) + 10) >> 3;
    v8 = (unsigned int)(*(_DWORD *)(a1 + 5796) + 10) >> 3;
    if ( v8 <= v9 )
      v9 = (unsigned int)(*(_DWORD *)(a1 + 5796) + 10) >> 3;
  }
  if ( a3 + 4 <= v9 && a2 )
  {
    sub_80CDFE1(a1, a2, a3, a4);
  }
  else if ( v8 == v9 )
  {
    if ( *(_DWORD *)(a1 + 5812) <= 13 )
    {
      *(_WORD *)(a1 + 5808) |= (a4 + 2) << *(_BYTE *)(a1 + 5812);
      v4 = *(_DWORD *)(a1 + 5812) + 3;
    }
    else
    {
      *(_WORD *)(a1 + 5808) |= (a4 + 2) << *(_BYTE *)(a1 + 5812);
      *(_BYTE *)(*(_DWORD *)(a1 + 8) + (*(_DWORD *)(a1 + 20))++) = *(_BYTE *)(a1 + 5808);
      *(_BYTE *)(*(_DWORD *)(a1 + 8) + (*(_DWORD *)(a1 + 20))++) = *(_WORD *)(a1 + 5808) >> 8;
      *(_WORD *)(a1 + 5808) = (signed int)(unsigned __int16)(a4 + 2) >> (16 - *(_BYTE *)(a1 + 5812));
      v4 = *(_DWORD *)(a1 + 5812) - 13;
    }
    *(_DWORD *)(a1 + 5812) = v4;
    sub_80CEA8B(a1, (int)&unk_8149F40, (int)&unk_814A3C0);
  }
  else
  {
    if ( *(_DWORD *)(a1 + 5812) <= 13 )
    {
      *(_WORD *)(a1 + 5808) |= (a4 + 4) << *(_BYTE *)(a1 + 5812);
      v5 = *(_DWORD *)(a1 + 5812) + 3;
    }
    else
    {
      *(_WORD *)(a1 + 5808) |= (a4 + 4) << *(_BYTE *)(a1 + 5812);
      *(_BYTE *)(*(_DWORD *)(a1 + 8) + (*(_DWORD *)(a1 + 20))++) = *(_BYTE *)(a1 + 5808);
      *(_BYTE *)(*(_DWORD *)(a1 + 8) + (*(_DWORD *)(a1 + 20))++) = *(_WORD *)(a1 + 5808) >> 8;
      *(_WORD *)(a1 + 5808) = (signed int)(unsigned __int16)(a4 + 4) >> (16 - *(_BYTE *)(a1 + 5812));
      v5 = *(_DWORD *)(a1 + 5812) - 13;
    }
    *(_DWORD *)(a1 + 5812) = v5;
    sub_80CDB3D(a1, *(_DWORD *)(a1 + 2836) + 1, *(_DWORD *)(a1 + 2848) + 1, v7 + 1);
    sub_80CEA8B(a1, a1 + 140, a1 + 2432);
  }
  result = sub_80CC515(a1);
  if ( a4 )
    result = sub_80CF3C1(a1);
  return result;
}

//----- (080CEA8B) --------------------------------------------------------
int __cdecl sub_80CEA8B(int a1, int a2, int a3)
{
  int v3; // ST04_4
  int v4; // eax
  int v5; // ST08_4
  int v6; // eax
  int v7; // eax
  int v8; // ST08_4
  int v9; // eax
  int v10; // eax
  int v11; // ST08_4
  int v12; // eax
  int result; // eax
  int v14; // [esp+0h] [ebp-28h]
  int v15; // [esp+4h] [ebp-24h]
  int v16; // [esp+4h] [ebp-24h]
  int v17; // [esp+4h] [ebp-24h]
  int v18; // [esp+8h] [ebp-20h]
  int v19; // [esp+Ch] [ebp-1Ch]
  int v20; // [esp+Ch] [ebp-1Ch]
  int v21; // [esp+10h] [ebp-18h]
  unsigned int v22; // [esp+14h] [ebp-14h]
  int v23; // [esp+18h] [ebp-10h]
  int v24; // [esp+18h] [ebp-10h]
  int v25; // [esp+1Ch] [ebp-Ch]
  unsigned int v26; // [esp+1Ch] [ebp-Ch]
  int v27; // [esp+1Ch] [ebp-Ch]

  v22 = 0;
  if ( *(_DWORD *)(a1 + 5784) )
  {
    do
    {
      v25 = *(unsigned __int16 *)(*(_DWORD *)(a1 + 5788) + 2 * v22);
      v23 = *(unsigned __int8 *)(*(_DWORD *)(a1 + 5776) + v22++);
      if ( v25 )
      {
        v21 = *(unsigned __int8 *)(v23 + 135571008);
        v15 = *(unsigned __int16 *)(a2 + 4 * v21 + 1030);
        if ( *(_DWORD *)(a1 + 5812) <= 16 - v15 )
        {
          *(_WORD *)(a1 + 5808) |= *(unsigned __int16 *)(a2 + 4 * v21 + 1028) << *(_BYTE *)(a1 + 5812);
          v6 = *(_DWORD *)(a1 + 5812) + v15;
        }
        else
        {
          v5 = *(unsigned __int16 *)(a2 + 4 * v21 + 1028);
          *(_WORD *)(a1 + 5808) |= v5 << *(_BYTE *)(a1 + 5812);
          *(_BYTE *)(*(_DWORD *)(a1 + 8) + (*(_DWORD *)(a1 + 20))++) = *(_BYTE *)(a1 + 5808);
          *(_BYTE *)(*(_DWORD *)(a1 + 8) + (*(_DWORD *)(a1 + 20))++) = *(_WORD *)(a1 + 5808) >> 8;
          *(_WORD *)(a1 + 5808) = (signed int)(unsigned __int16)v5 >> (16 - *(_BYTE *)(a1 + 5812));
          v6 = *(_DWORD *)(a1 + 5812) + v15 - 16;
        }
        *(_DWORD *)(a1 + 5812) = v6;
        v19 = dword_8149DE0[v21];
        if ( v19 )
        {
          v24 = v23 - dword_814A740[v21];
          if ( *(_DWORD *)(a1 + 5812) <= 16 - v19 )
          {
            *(_WORD *)(a1 + 5808) |= v24 << *(_BYTE *)(a1 + 5812);
            v7 = *(_DWORD *)(a1 + 5812) + v19;
          }
          else
          {
            *(_WORD *)(a1 + 5808) |= v24 << *(_BYTE *)(a1 + 5812);
            *(_BYTE *)(*(_DWORD *)(a1 + 8) + (*(_DWORD *)(a1 + 20))++) = *(_BYTE *)(a1 + 5808);
            *(_BYTE *)(*(_DWORD *)(a1 + 8) + (*(_DWORD *)(a1 + 20))++) = *(_WORD *)(a1 + 5808) >> 8;
            *(_WORD *)(a1 + 5808) = (signed int)(unsigned __int16)v24 >> (16 - *(_BYTE *)(a1 + 5812));
            v7 = *(_DWORD *)(a1 + 5812) + v19 - 16;
          }
          *(_DWORD *)(a1 + 5812) = v7;
        }
        v26 = v25 - 1;
        if ( v26 > 0xFF )
          v14 = (unsigned __int8)byte_814A540[v26 >> 7];
        else
          v14 = *(unsigned __int8 *)(v26 + 135570496);
        v16 = *(unsigned __int16 *)(a3 + 4 * v14 + 2);
        if ( *(_DWORD *)(a1 + 5812) <= 16 - v16 )
        {
          *(_WORD *)(a1 + 5808) |= *(unsigned __int16 *)(a3 + 4 * v14) << *(_BYTE *)(a1 + 5812);
          v9 = *(_DWORD *)(a1 + 5812) + v16;
        }
        else
        {
          v8 = *(unsigned __int16 *)(a3 + 4 * v14);
          *(_WORD *)(a1 + 5808) |= v8 << *(_BYTE *)(a1 + 5812);
          *(_BYTE *)(*(_DWORD *)(a1 + 8) + (*(_DWORD *)(a1 + 20))++) = *(_BYTE *)(a1 + 5808);
          *(_BYTE *)(*(_DWORD *)(a1 + 8) + (*(_DWORD *)(a1 + 20))++) = *(_WORD *)(a1 + 5808) >> 8;
          *(_WORD *)(a1 + 5808) = (signed int)(unsigned __int16)v8 >> (16 - *(_BYTE *)(a1 + 5812));
          v9 = *(_DWORD *)(a1 + 5812) + v16 - 16;
        }
        *(_DWORD *)(a1 + 5812) = v9;
        v20 = dword_8149E60[v14];
        if ( v20 )
        {
          v27 = v26 - dword_814A7C0[v14];
          if ( *(_DWORD *)(a1 + 5812) <= 16 - v20 )
          {
            *(_WORD *)(a1 + 5808) |= v27 << *(_BYTE *)(a1 + 5812);
            v10 = *(_DWORD *)(a1 + 5812) + v20;
          }
          else
          {
            *(_WORD *)(a1 + 5808) |= v27 << *(_BYTE *)(a1 + 5812);
            *(_BYTE *)(*(_DWORD *)(a1 + 8) + (*(_DWORD *)(a1 + 20))++) = *(_BYTE *)(a1 + 5808);
            *(_BYTE *)(*(_DWORD *)(a1 + 8) + (*(_DWORD *)(a1 + 20))++) = *(_WORD *)(a1 + 5808) >> 8;
            *(_WORD *)(a1 + 5808) = (signed int)(unsigned __int16)v27 >> (16 - *(_BYTE *)(a1 + 5812));
            v10 = *(_DWORD *)(a1 + 5812) + v20 - 16;
          }
          *(_DWORD *)(a1 + 5812) = v10;
        }
      }
      else
      {
        v18 = *(unsigned __int16 *)(a2 + 4 * v23 + 2);
        if ( *(_DWORD *)(a1 + 5812) <= 16 - v18 )
        {
          *(_WORD *)(a1 + 5808) |= *(unsigned __int16 *)(a2 + 4 * v23) << *(_BYTE *)(a1 + 5812);
          v4 = *(_DWORD *)(a1 + 5812) + v18;
        }
        else
        {
          v3 = *(unsigned __int16 *)(a2 + 4 * v23);
          *(_WORD *)(a1 + 5808) |= v3 << *(_BYTE *)(a1 + 5812);
          *(_BYTE *)(*(_DWORD *)(a1 + 8) + (*(_DWORD *)(a1 + 20))++) = *(_BYTE *)(a1 + 5808);
          *(_BYTE *)(*(_DWORD *)(a1 + 8) + (*(_DWORD *)(a1 + 20))++) = *(_WORD *)(a1 + 5808) >> 8;
          *(_WORD *)(a1 + 5808) = (signed int)(unsigned __int16)v3 >> (16 - *(_BYTE *)(a1 + 5812));
          v4 = *(_DWORD *)(a1 + 5812) + v18 - 16;
        }
        *(_DWORD *)(a1 + 5812) = v4;
      }
    }
    while ( v22 < *(_DWORD *)(a1 + 5784) );
  }
  v17 = *(unsigned __int16 *)(a2 + 1026);
  if ( *(_DWORD *)(a1 + 5812) <= 16 - v17 )
  {
    *(_WORD *)(a1 + 5808) |= *(unsigned __int16 *)(a2 + 1024) << *(_BYTE *)(a1 + 5812);
    v12 = *(_DWORD *)(a1 + 5812) + v17;
  }
  else
  {
    v11 = *(unsigned __int16 *)(a2 + 1024);
    *(_WORD *)(a1 + 5808) |= v11 << *(_BYTE *)(a1 + 5812);
    *(_BYTE *)(*(_DWORD *)(a1 + 8) + (*(_DWORD *)(a1 + 20))++) = *(_BYTE *)(a1 + 5808);
    *(_BYTE *)(*(_DWORD *)(a1 + 8) + (*(_DWORD *)(a1 + 20))++) = *(_WORD *)(a1 + 5808) >> 8;
    *(_WORD *)(a1 + 5808) = (signed int)(unsigned __int16)v11 >> (16 - *(_BYTE *)(a1 + 5812));
    v12 = *(_DWORD *)(a1 + 5812) + v17 - 16;
  }
  *(_DWORD *)(a1 + 5812) = v12;
  result = a1;
  *(_DWORD *)(a1 + 5804) = *(unsigned __int16 *)(a2 + 1026);
  return result;
}
// 8149DE0: using guessed type int dword_8149DE0[];
// 8149E60: using guessed type int dword_8149E60[];

//----- (080CF236) --------------------------------------------------------
bool __cdecl sub_80CF236(int a1)
{
  bool result; // al
  unsigned int v2; // [esp+0h] [ebp-Ch]
  unsigned int v3; // [esp+4h] [ebp-8h]
  signed int v4; // [esp+8h] [ebp-4h]

  v4 = 0;
  v3 = 0;
  v2 = 0;
  while ( v4 <= 6 )
    v2 += *(unsigned __int16 *)(a1 + 4 * v4++ + 140);
  while ( v4 <= 127 )
    v3 += *(unsigned __int16 *)(a1 + 4 * v4++ + 140);
  while ( v4 <= 255 )
    v2 += *(unsigned __int16 *)(a1 + 4 * v4++ + 140);
  result = v2 <= v3 >> 2;
  *(_BYTE *)(a1 + 28) = result;
  return result;
}

//----- (080CF2D0) --------------------------------------------------------
unsigned int __cdecl sub_80CF2D0(unsigned int a1, int a2)
{
  int v2; // ST00_4
  unsigned int v4; // [esp+0h] [ebp-4h]

  v4 = 0;
  do
  {
    v2 = a1 & 1 | v4;
    a1 >>= 1;
    v4 = 2 * v2;
    --a2;
  }
  while ( a2 > 0 );
  return v4 >> 1;
}

//----- (080CF2FE) --------------------------------------------------------
int __cdecl sub_80CF2FE(int a1)
{
  int result; // eax

  if ( *(_DWORD *)(a1 + 5812) == 16 )
  {
    *(_BYTE *)(*(_DWORD *)(a1 + 8) + (*(_DWORD *)(a1 + 20))++) = *(_BYTE *)(a1 + 5808);
    *(_BYTE *)(*(_DWORD *)(a1 + 8) + (*(_DWORD *)(a1 + 20))++) = *(_WORD *)(a1 + 5808) >> 8;
    *(_WORD *)(a1 + 5808) = 0;
    result = a1;
    *(_DWORD *)(a1 + 5812) = 0;
  }
  else
  {
    result = a1;
    if ( *(_DWORD *)(a1 + 5812) > 7 )
    {
      *(_BYTE *)(*(_DWORD *)(a1 + 8) + (*(_DWORD *)(a1 + 20))++) = *(_BYTE *)(a1 + 5808);
      *(_WORD *)(a1 + 5808) >>= 8;
      result = *(_DWORD *)(a1 + 5812) - 8;
      *(_DWORD *)(a1 + 5812) = result;
    }
  }
  return result;
}

//----- (080CF3C1) --------------------------------------------------------
int __cdecl sub_80CF3C1(int a1)
{
  int result; // eax

  if ( *(_DWORD *)(a1 + 5812) <= 8 )
  {
    if ( *(_DWORD *)(a1 + 5812) > 0 )
      *(_BYTE *)(*(_DWORD *)(a1 + 8) + (*(_DWORD *)(a1 + 20))++) = *(_BYTE *)(a1 + 5808);
  }
  else
  {
    *(_BYTE *)(*(_DWORD *)(a1 + 8) + (*(_DWORD *)(a1 + 20))++) = *(_BYTE *)(a1 + 5808);
    *(_BYTE *)(*(_DWORD *)(a1 + 8) + (*(_DWORD *)(a1 + 20))++) = *(_WORD *)(a1 + 5808) >> 8;
  }
  *(_WORD *)(a1 + 5808) = 0;
  result = a1;
  *(_DWORD *)(a1 + 5812) = 0;
  return result;
}

//----- (080CF458) --------------------------------------------------------
int *__cdecl sub_80CF458(_DWORD *a1, _BYTE *a2, int a3, int a4)
{
  int *result; // eax
  _BYTE *v5; // ecx

  sub_80CF3C1((int)a1);
  a1[1451] = 8;
  if ( a4 )
  {
    *(_BYTE *)(a1[2] + a1[5]++) = a3;
    *(_BYTE *)(a1[2] + a1[5]++) = BYTE1(a3);
    *(_BYTE *)(a1[2] + a1[5]++) = ~(_BYTE)a3;
    *(_BYTE *)(a1[2] + a1[5]++) = (unsigned __int16)~(_WORD)a3 >> 8;
  }
  while ( 1 )
  {
    result = &a3;
    if ( --a3 == -1 )
      break;
    v5 = a2++;
    *(_BYTE *)(a1[2] + a1[5]++) = *v5;
  }
  return result;
}

//----- (080CF610) --------------------------------------------------------
int __cdecl sub_80CF610(FILE *stream, int a2)
{
  __int16 ptr; // [esp+16h] [ebp-2h]

  FS_FileRead(&ptr, 2u, 1u, stream);
  *(_DWORD *)a2 = ptr;
  return 0;
}

//----- (080CF648) --------------------------------------------------------
int __cdecl sub_80CF648(FILE *stream, int a2)
{
  int ptr; // [esp+14h] [ebp-4h]

  FS_FileRead(&ptr, 4u, 1u, stream);
  *(_DWORD *)a2 = ptr;
  return 0;
}

//----- (080CF67F) --------------------------------------------------------
signed int __cdecl sub_80CF67F(char *a1, char *a2)
{
  char *v2; // eax
  char *v3; // edx
  signed int v5; // [esp+0h] [ebp-Ch]
  char v7; // [esp+Ah] [ebp-2h]
  char v8; // [esp+Bh] [ebp-1h]

  while ( 1 )
  {
    v2 = a1++;
    v8 = *v2;
    v3 = a2++;
    v7 = *v3;
    if ( *v2 > 96 && v8 <= 122 )
      v8 -= 32;
    if ( v7 > 96 && v7 <= 122 )
      v7 -= 32;
    if ( !v8 )
      break;
    if ( !v7 )
      return 1;
    if ( v8 < v7 )
      return -1;
    if ( v8 > v7 )
      return 1;
  }
  if ( v7 )
    v5 = -1;
  else
    v5 = 0;
  return v5;
}

//----- (080CF724) --------------------------------------------------------
int __cdecl sub_80CF724(char *s1, char *s2, int a3)
{
  int v4; // [esp+14h] [ebp-4h]

  if ( !a3 )
    a3 = 1;
  if ( a3 == 1 )
    v4 = strcmp(s1, s2);
  else
    v4 = sub_80CF67F(s1, s2);
  return v4;
}

//----- (080CF76E) --------------------------------------------------------
int __cdecl sub_80CF76E(FILE *stream)
{
  int v1; // edx
  size_t v3; // [esp+10h] [ebp-28h]
  int v5; // [esp+18h] [ebp-20h]
  int off; // [esp+1Ch] [ebp-1Ch]
  int v7; // [esp+24h] [ebp-14h]
  unsigned int v8; // [esp+28h] [ebp-10h]
  unsigned int v9; // [esp+2Ch] [ebp-Ch]
  unsigned int v10; // [esp+30h] [ebp-8h]
  void *ptr; // [esp+34h] [ebp-4h]

  v8 = 0xFFFF;
  v7 = 0;
  if ( FS_FileSeek(stream, 0, 2) )
    return 0;
  v10 = ftell(stream);
  if ( v10 < 0xFFFF )
    v8 = v10;
  ptr = malloc(0x404u);
  if ( !ptr )
    return 0;
  v9 = 4;
  do
  {
    if ( v9 >= v8 )
      break;
    if ( v9 + 1024 <= v8 )
      v9 += 1024;
    else
      v9 = v8;
    off = v10 - v9;
    v3 = v9;
    if ( v9 > 0x404 )
      v3 = 1028;
    if ( FS_FileSeek(stream, off, 0) || FS_FileRead(ptr, v3, 1u, stream) != 1 )
      break;
    v5 = v3 - 3;
    while ( 1 )
    {
      v1 = v5--;
      if ( v1 <= 0 )
        break;
      if ( *((_BYTE *)ptr + v5) == 80
        && *((_BYTE *)ptr + v5 + 1) == 75
        && *((_BYTE *)ptr + v5 + 2) == 5
        && *((_BYTE *)ptr + v5 + 3) == 6 )
      {
        v7 = off + v5;
        break;
      }
    }
  }
  while ( !v7 );
  free(ptr);
  return v7;
}

//----- (080CF90C) --------------------------------------------------------
_DWORD *__cdecl sub_80CF90C(char *filename, void *src)
{
  _DWORD *dest; // ST14_4
  FILE *v5; // [esp+10h] [ebp-8h]

  v5 = FS_FileOpen(filename, "rb");
  if ( !v5 )
    return 0;
  dest = malloc(0x80u);
  Com_Memcpy(dest, src, 0x80u);
  *dest = v5;
  dest[31] = 0;
  return dest;
}

//----- (080CF97D) --------------------------------------------------------
void *__cdecl unzOpen(char *filename)
{
  void *v2; // [esp+1Ch] [ebp-ACh]
  signed int v3; // [esp+20h] [ebp-A8h]
  int v4; // [esp+24h] [ebp-A4h]
  int v5; // [esp+28h] [ebp-A0h]
  int v6; // [esp+2Ch] [ebp-9Ch]
  FILE *stream; // [esp+30h] [ebp-98h]
  int v8; // [esp+34h] [ebp-94h]
  int off; // [esp+38h] [ebp-90h]
  FILE **v10; // [esp+3Ch] [ebp-8Ch]
  FILE *v11; // [esp+40h] [ebp-88h]
  int v12; // [esp+44h] [ebp-84h]
  int v13; // [esp+48h] [ebp-80h]
  int v14; // [esp+4Ch] [ebp-7Ch]
  int v15; // [esp+5Ch] [ebp-6Ch]
  int v16; // [esp+60h] [ebp-68h]
  int v17; // [esp+64h] [ebp-64h]
  int v18; // [esp+BCh] [ebp-Ch]

  v3 = 0;
  stream = FS_FileOpen(filename, "rb");
  if ( !stream )
    return 0;
  off = sub_80CF76E(stream);
  if ( !off )
    v3 = -1;
  if ( FS_FileSeek(stream, off, 0) )
    v3 = -1;
  if ( sub_80CF648(stream, (int)&v8) )
    v3 = -1;
  if ( sub_80CF610(stream, (int)&v6) )
    v3 = -1;
  if ( sub_80CF610(stream, (int)&v5) )
    v3 = -1;
  if ( sub_80CF610(stream, (int)&v12) )
    v3 = -1;
  if ( sub_80CF610(stream, (int)&v4) )
    v3 = -1;
  if ( v4 != v12 || v5 || v6 )
    v3 = -103;
  if ( sub_80CF648(stream, (int)&v16) )
    v3 = -1;
  if ( sub_80CF648(stream, (int)&v17) )
    v3 = -1;
  if ( sub_80CF610(stream, (int)&v13) )
    v3 = -1;
  if ( off < (unsigned int)(v17 + v16) && !v3 )
    v3 = -103;
  if ( v3 )
  {
    FS_FileClose(stream);
    v2 = 0;
  }
  else
  {
    v11 = stream;
    v14 = off - (v16 + v17);
    v15 = off;
    v18 = 0;
    v10 = (FILE **)malloc(0x80u);
    qmemcpy(v10, &v11, 0x80u);
    unzGoToFirstFile(v10);
    v2 = v10;
  }
  return v2;
}

//----- (080CFC62) --------------------------------------------------------
signed int __cdecl sub_80CFC62(int a1)
{
  if ( !a1 )
    return -102;
  if ( *(_DWORD *)(a1 + 124) )
    sub_80D0F1A(a1);
  FS_FileClose(*(FILE **)a1);
  free((void *)a1);
  return 0;
}

//----- (080CFCB5) --------------------------------------------------------
signed int __cdecl unzGetGlobalInfo(int a1, _DWORD *a2)
{
  int v2; // edx

  if ( !a1 )
    return -102;
  v2 = *(_DWORD *)(a1 + 8);
  *a2 = *(_DWORD *)(a1 + 4);
  a2[1] = v2;
  return 0;
}

//----- (080CFCED) --------------------------------------------------------
int __cdecl sub_80CFCED(int a1, int *a2)
{
  int result; // eax

  a2[3] = BYTE2(a1) & 0x1F;
  a2[4] = ((HIWORD(a1) & 0x1E0u) >> 5) - 1;
  a2[5] = ((HIWORD(a1) & 0xFE00u) >> 9) + 1980;
  a2[2] = (a1 & 0xF800u) >> 11;
  a2[1] = (a1 & 0x7E0u) >> 5;
  result = 2 * (a1 & 0x1F);
  *a2 = result;
  return result;
}

//----- (080CFD61) --------------------------------------------------------
int __cdecl sub_80CFD61(int a1, int a2, int a3, void *ptr, int a5, void *a6, int a7, void *a8, int a9)
{
  int size; // [esp+1Ch] [ebp-7Ch]
  int sizea; // [esp+1Ch] [ebp-7Ch]
  int sizeb; // [esp+1Ch] [ebp-7Ch]
  int off; // [esp+20h] [ebp-78h]
  int offa; // [esp+20h] [ebp-78h]
  int v16; // [esp+24h] [ebp-74h]
  int v17; // [esp+28h] [ebp-70h]
  int v18; // [esp+2Ch] [ebp-6Ch]
  int v19; // [esp+30h] [ebp-68h]
  int v20; // [esp+34h] [ebp-64h]
  int v21; // [esp+38h] [ebp-60h]
  int v22; // [esp+3Ch] [ebp-5Ch]
  int v23; // [esp+40h] [ebp-58h]
  int v24; // [esp+44h] [ebp-54h]
  int v25; // [esp+48h] [ebp-50h]
  int v26; // [esp+4Ch] [ebp-4Ch]
  unsigned int v27; // [esp+50h] [ebp-48h]
  unsigned int v28; // [esp+54h] [ebp-44h]
  unsigned int v29; // [esp+58h] [ebp-40h]
  int v30; // [esp+5Ch] [ebp-3Ch]
  int v31; // [esp+60h] [ebp-38h]
  int v32; // [esp+64h] [ebp-34h]
  int v33; // [esp+68h] [ebp-30h]
  FILE **v34; // [esp+8Ch] [ebp-Ch]

  v17 = 0;
  if ( !a1 )
    return -102;
  v34 = (FILE **)a1;
  if ( FS_FileSeek(*(FILE **)a1, *(_DWORD *)(a1 + 20) + *(_DWORD *)(a1 + 12), 0) )
    v17 = -1;
  if ( !v17 )
  {
    if ( sub_80CF648(*v34, (int)&v16) )
    {
      v17 = -1;
    }
    else if ( v16 != 33639248 )
    {
      v17 = -103;
    }
  }
  if ( sub_80CF610(*v34, (int)&v19) )
    v17 = -1;
  if ( sub_80CF610(*v34, (int)&v20) )
    v17 = -1;
  if ( sub_80CF610(*v34, (int)&v21) )
    v17 = -1;
  if ( sub_80CF610(*v34, (int)&v22) )
    v17 = -1;
  if ( sub_80CF648(*v34, (int)&v23) )
    v17 = -1;
  sub_80CFCED(v23, &v33);
  if ( sub_80CF648(*v34, (int)&v24) )
    v17 = -1;
  if ( sub_80CF648(*v34, (int)&v25) )
    v17 = -1;
  if ( sub_80CF648(*v34, (int)&v26) )
    v17 = -1;
  if ( sub_80CF610(*v34, (int)&v27) )
    v17 = -1;
  if ( sub_80CF610(*v34, (int)&v28) )
    v17 = -1;
  if ( sub_80CF610(*v34, (int)&v29) )
    v17 = -1;
  if ( sub_80CF610(*v34, (int)&v30) )
    v17 = -1;
  if ( sub_80CF610(*v34, (int)&v31) )
    v17 = -1;
  if ( sub_80CF648(*v34, (int)&v32) )
    v17 = -1;
  if ( sub_80CF648(*v34, (int)&v18) )
    v17 = -1;
  off = v27;
  if ( !v17 && ptr )
  {
    if ( v27 >= a5 )
    {
      size = a5;
    }
    else
    {
      *((_BYTE *)ptr + v27) = 0;
      size = v27;
    }
    if ( v27 && a5 && FS_FileRead(ptr, size, 1u, *v34) != 1 )
      v17 = -1;
    off -= size;
  }
  if ( v17 || !a6 )
  {
    offa = v28 + off;
  }
  else
  {
    if ( v28 >= a7 )
      sizea = a7;
    else
      sizea = v28;
    if ( off )
    {
      if ( FS_FileSeek(*v34, off, 1) )
        v17 = -1;
      else
        off = 0;
    }
    if ( v28 && a7 && FS_FileRead(a6, sizea, 1u, *v34) != 1 )
      v17 = -1;
    offa = v28 - sizea + off;
  }
  if ( !v17 && a8 )
  {
    if ( v29 >= a9 )
    {
      sizeb = a9;
    }
    else
    {
      *((_BYTE *)a8 + v29) = 0;
      sizeb = v29;
    }
    if ( offa && FS_FileSeek(*v34, offa, 1) )
      v17 = -1;
    if ( v29 && a9 && FS_FileRead(a8, sizeb, 1u, *v34) != 1 )
      v17 = -1;
  }
  if ( !v17 && a2 )
    qmemcpy((void *)a2, &v19, 0x50u);
  if ( !v17 && a3 )
    *(_DWORD *)a3 = v18;
  return v17;
}

//----- (080D0235) --------------------------------------------------------
int __cdecl unzGetCurrentFileInfo(int a1, int a2, void *ptr, int a4, void *a5, int a6, void *a7, int a8)
{
  return sub_80CFD61(a1, a2, 0, ptr, a4, a5, a6, a7, a8);
}

//----- (080D0281) --------------------------------------------------------
signed int __cdecl unzGoToFirstFile(_DWORD *a1)
{
  int v1; // ST34_4

  if ( !a1 )
    return -102;
  a1[5] = a1[9];
  a1[4] = 0;
  v1 = sub_80CFD61((int)a1, (int)(a1 + 10), (int)(a1 + 30), 0, 0, 0, 0, 0, 0);
  a1[6] = v1 == 0;
  return v1;
}

//----- (080D0329) --------------------------------------------------------
signed int __cdecl unzGoToNextFile(_DWORD *a1)
{
  int v1; // ST28_4

  if ( !a1 )
    return -102;
  if ( !a1[6] )
    return -100;
  if ( a1[4] + 1 == a1[1] )
    return -100;
  a1[5] += a1[20] + a1[19] + a1[18] + 46;
  ++a1[4];
  v1 = sub_80CFD61((int)a1, (int)(a1 + 10), (int)(a1 + 30), 0, 0, 0, 0, 0, 0);
  a1[6] = v1 == 0;
  return v1;
}

//----- (080D0417) --------------------------------------------------------
signed int __cdecl sub_80D0417(int a1, _DWORD *a2)
{
  if ( !a1 )
    return -102;
  *a2 = *(_DWORD *)(a1 + 20);
  return 0;
}

//----- (080D0449) --------------------------------------------------------
signed int __cdecl unzSetCurrentFileInfoPosition(int a1, int a2)
{
  if ( !a1 )
    return -102;
  *(_DWORD *)(a1 + 20) = a2;
  *(_DWORD *)(a1 + 24) = sub_80CFD61(a1, a1 + 40, a1 + 120, 0, 0, 0, 0, 0, 0) == 0;
  return 0;
}

//----- (080D060A) --------------------------------------------------------
signed int __cdecl sub_80D060A(int a1, _DWORD *a2, _DWORD *a3, int *a4)
{
  signed int v6; // [esp+10h] [ebp-18h]
  int v7; // [esp+14h] [ebp-14h]
  int v8; // [esp+18h] [ebp-10h]
  int v9; // [esp+1Ch] [ebp-Ch]
  int v10; // [esp+20h] [ebp-8h]
  int v11; // [esp+24h] [ebp-4h]

  v6 = 0;
  *a2 = 0;
  *a3 = 0;
  *a4 = 0;
  if ( FS_FileSeek(*(FILE **)a1, *(_DWORD *)(a1 + 120) + *(_DWORD *)(a1 + 12), 0) )
    return -1;
  if ( sub_80CF648(*(FILE **)a1, (int)&v11) )
  {
    v6 = -1;
  }
  else if ( v11 != 67324752 )
  {
    v6 = -103;
  }
  if ( sub_80CF610(*(FILE **)a1, (int)&v10) )
    v6 = -1;
  if ( sub_80CF610(*(FILE **)a1, (int)&v9) )
    v6 = -1;
  if ( sub_80CF610(*(FILE **)a1, (int)&v10) )
  {
    v6 = -1;
  }
  else if ( !v6 && v10 != *(_DWORD *)(a1 + 52) )
  {
    v6 = -103;
  }
  if ( !v6 && *(_DWORD *)(a1 + 52) && *(_DWORD *)(a1 + 52) != 8 )
    v6 = -103;
  if ( sub_80CF648(*(FILE **)a1, (int)&v10) )
    v6 = -1;
  if ( sub_80CF648(*(FILE **)a1, (int)&v10) )
  {
    v6 = -1;
  }
  else if ( !v6 && v10 != *(_DWORD *)(a1 + 60) && !(v9 & 8) )
  {
    v6 = -103;
  }
  if ( sub_80CF648(*(FILE **)a1, (int)&v10) )
  {
    v6 = -1;
  }
  else if ( !v6 && v10 != *(_DWORD *)(a1 + 64) && !(v9 & 8) )
  {
    v6 = -103;
  }
  if ( sub_80CF648(*(FILE **)a1, (int)&v10) )
  {
    v6 = -1;
  }
  else if ( !v6 && v10 != *(_DWORD *)(a1 + 68) && !(v9 & 8) )
  {
    v6 = -103;
  }
  if ( sub_80CF610(*(FILE **)a1, (int)&v8) )
  {
    v6 = -1;
  }
  else if ( !v6 && v8 != *(_DWORD *)(a1 + 72) )
  {
    v6 = -103;
  }
  *a2 += v8;
  if ( sub_80CF610(*(FILE **)a1, (int)&v7) )
    v6 = -1;
  *a3 = *(_DWORD *)(a1 + 120) + v8 + 30;
  *a4 = v7;
  *a2 += v7;
  return v6;
}

//----- (080D08B2) --------------------------------------------------------
signed int __cdecl unzOpenCurrentFile(_DWORD *a1)
{
  _DWORD *v1; // ebx
  signed int v3; // [esp+14h] [ebp-24h]
  int v4; // [esp+18h] [ebp-20h]
  int v5; // [esp+1Ch] [ebp-1Ch]
  void *ptr; // [esp+20h] [ebp-18h]
  _DWORD *v7; // [esp+24h] [ebp-14h]
  int v8; // [esp+28h] [ebp-10h]
  _BOOL4 v9; // [esp+2Ch] [ebp-Ch]
  int v10; // [esp+30h] [ebp-8h]

  v10 = 0;
  if ( !a1 )
    return -102;
  v7 = a1;
  if ( !a1[6] )
    return -102;
  if ( v7[31] )
    sub_80D0F1A((int)a1);
  if ( sub_80D060A((int)v7, &v8, &v5, &v4) )
    return -103;
  ptr = malloc(0x64u);
  if ( !ptr )
    return -104;
  v1 = ptr;
  *v1 = malloc(0x4000u);
  *((_DWORD *)ptr + 17) = v5;
  *((_DWORD *)ptr + 18) = v4;
  *((_DWORD *)ptr + 19) = 0;
  if ( *(_DWORD *)ptr )
  {
    *((_DWORD *)ptr + 16) = 0;
    if ( v7[13] && v7[13] != 8 )
      v10 = -103;
    v9 = v7[13] == 0;
    *((_DWORD *)ptr + 23) = v7[13];
    *((_DWORD *)ptr + 22) = *v7;
    *((_DWORD *)ptr + 24) = v7[3];
    *((_DWORD *)ptr + 6) = 0;
    if ( !v9 )
    {
      *((_DWORD *)ptr + 9) = 0;
      *((_DWORD *)ptr + 10) = 0;
      *((_DWORD *)ptr + 11) = 0;
      v10 = sub_80CAD79((_DWORD *)ptr + 1, -15, "1.1.4", 56);
      if ( !v10 )
        *((_DWORD *)ptr + 16) = 1;
    }
    *((_DWORD *)ptr + 20) = v7[16];
    *((_DWORD *)ptr + 21) = v7[17];
    *((_DWORD *)ptr + 15) = v7[30] + v8 + 30;
    *((_DWORD *)ptr + 2) = 0;
    v7[31] = ptr;
    v3 = 0;
  }
  else
  {
    free(ptr);
    v3 = -104;
  }
  return v3;
}

//----- (080D0AA8) --------------------------------------------------------
signed int __cdecl sub_80D0AA8(int a1, int a2, unsigned int a3)
{
  size_t v3; // ST34_4
  int v4; // ST28_4
  int v5; // ST2C_4
  signed int v7; // [esp+1Ch] [ebp-2Ch]
  size_t i; // [esp+30h] [ebp-18h]
  size_t size; // [esp+34h] [ebp-14h]
  size_t sizea; // [esp+34h] [ebp-14h]
  int v11; // [esp+38h] [ebp-10h]
  signed int v12; // [esp+40h] [ebp-8h]
  signed int v13; // [esp+44h] [ebp-4h]

  v13 = 0;
  v12 = 0;
  if ( !a1 )
    return -102;
  v11 = *(_DWORD *)(a1 + 124);
  if ( !v11 )
    return -102;
  if ( !*(_DWORD *)v11 )
    return -100;
  if ( !a3 )
    return 0;
  *(_DWORD *)(v11 + 16) = a2;
  *(_DWORD *)(v11 + 20) = a3;
  if ( a3 > *(_DWORD *)(v11 + 84) )
    *(_DWORD *)(v11 + 20) = *(_DWORD *)(v11 + 84);
  while ( *(_DWORD *)(v11 + 20) )
  {
    if ( !*(_DWORD *)(v11 + 8) && *(_DWORD *)(v11 + 80) )
    {
      size = 0x4000;
      if ( *(_DWORD *)(v11 + 80) < 0x4000u )
        size = *(_DWORD *)(v11 + 80);
      if ( !size )
        return 0;
      if ( FS_FileSeek(*(FILE **)(v11 + 88), *(_DWORD *)(v11 + 60) + *(_DWORD *)(v11 + 96), 0) )
        return -1;
      if ( FS_FileRead(*(void **)v11, size, 1u, *(FILE **)(v11 + 88)) != 1 )
        return -1;
      *(_DWORD *)(v11 + 60) += size;
      *(_DWORD *)(v11 + 80) -= size;
      *(_DWORD *)(v11 + 4) = *(_DWORD *)v11;
      *(_DWORD *)(v11 + 8) = size;
    }
    if ( *(_DWORD *)(v11 + 92) )
    {
      v3 = *(_DWORD *)(v11 + 24);
      v4 = *(_DWORD *)(v11 + 16);
      v13 = sub_80CAF39((unsigned __int8 **)(v11 + 4), 2);
      v5 = *(_DWORD *)(v11 + 24);
      *(_DWORD *)(v11 + 84) -= v5 - v3;
      v12 += v5 - v3;
      if ( v13 == 1 )
        return v12;
      if ( v13 )
        break;
    }
    else
    {
      if ( *(_DWORD *)(v11 + 20) >= *(_DWORD *)(v11 + 8) )
        sizea = *(_DWORD *)(v11 + 8);
      else
        sizea = *(_DWORD *)(v11 + 20);
      for ( i = 0; i < sizea; ++i )
        *(_BYTE *)(i + *(_DWORD *)(v11 + 16)) = *(_BYTE *)(*(_DWORD *)(v11 + 4) + i);
      *(_DWORD *)(v11 + 84) -= sizea;
      *(_DWORD *)(v11 + 8) -= sizea;
      *(_DWORD *)(v11 + 20) -= sizea;
      *(_DWORD *)(v11 + 16) += sizea;
      *(_DWORD *)(v11 + 4) += sizea;
      *(_DWORD *)(v11 + 24) += sizea;
      v12 += sizea;
    }
  }
  if ( v13 )
    v7 = v13;
  else
    v7 = v12;
  return v7;
}

//----- (080D0D98) --------------------------------------------------------
signed int __cdecl sub_80D0D98(int a1)
{
  signed int v2; // [esp+0h] [ebp-Ch]
  int v3; // [esp+4h] [ebp-8h]

  if ( !a1 )
    return -102;
  v3 = *(_DWORD *)(a1 + 124);
  if ( v3 )
    v2 = *(_DWORD *)(v3 + 24);
  else
    v2 = -102;
  return v2;
}

//----- (080D0F1A) --------------------------------------------------------
signed int __cdecl sub_80D0F1A(int a1)
{
  void **ptr; // [esp+Ch] [ebp-Ch]

  if ( !a1 )
    return -102;
  ptr = *(void ***)(a1 + 124);
  if ( !ptr )
    return -102;
  free(*ptr);
  *ptr = 0;
  if ( ptr[16] )
    sub_80CACFD(ptr + 1);
  ptr[16] = 0;
  free(ptr);
  *(_DWORD *)(a1 + 124) = 0;
  return 0;
}

//----- (080D1096) --------------------------------------------------------
void *__cdecl sub_80D1096(int a1, int a2, int a3)
{
  return Z_MallocInternal(a3 * a2);
}

//----- (080D10AD) --------------------------------------------------------
void __cdecl sub_80D10AD(int a1, void *ptr)
{
  Z_FreeInternal(ptr);
}

//----- (080D1178) --------------------------------------------------------
void sub_80D1178()
{
  ;
}

//----- (080D117E) --------------------------------------------------------
ssize_t tty_FlushIn()
{
  ssize_t result; // eax
  char buf; // [esp+17h] [ebp-1h]

  do
    result = read(0, &buf, 1u);
  while ( result != -1 );
  return result;
}

//----- (080D11A8) --------------------------------------------------------
ssize_t sub_80D11A8()
{
  char buf; // [esp+17h] [ebp-1h]

  buf = 8;
  write(1, &buf, 1u);
  buf = 32;
  write(1, &buf, 1u);
  buf = 8;
  return write(1, &buf, 1u);
}

//----- (080D120E) --------------------------------------------------------
int sub_80D120E()
{
  int result; // eax
  int i; // [esp+4h] [ebp-4h]

  if ( dword_85501D0 )
  {
    ++dword_85501D0;
  }
  else
  {
    if ( dword_8550220 > 0 )
    {
      for ( i = 0; ; ++i )
      {
        result = i;
        if ( i >= dword_8550220 )
          break;
        sub_80D11A8();
      }
    }
    ++dword_85501D0;
  }
  return result;
}
// 85501D0: using guessed type int dword_85501D0;
// 8550220: using guessed type int dword_8550220;

//----- (080D1256) --------------------------------------------------------
int sub_80D1256()
{
  int result; // eax
  int i; // [esp+14h] [ebp-4h]

  if ( !--dword_85501D0 && dword_8550220 )
  {
    for ( i = 0; ; ++i )
    {
      result = i;
      if ( i >= dword_8550220 )
        break;
      write(1, (const void *)(i + 139788856), 1u);
    }
  }
  return result;
}
// 85501D0: using guessed type int dword_85501D0;
// 8550220: using guessed type int dword_8550220;

//----- (080D12B2) --------------------------------------------------------
int Sys_ConsoleInputShutdown()
{
  int result; // eax

  if ( dword_85501CC )
  {
    Com_Printf("Shutdown tty console\n");
    result = tcsetattr(0, 1, &termios_p);
  }
  return result;
}
// 85501CC: using guessed type int dword_85501CC;

//----- (080D12EC) --------------------------------------------------------
unsigned int __cdecl sub_80D12EC(_DWORD *a1)
{
  unsigned int result; // eax
  unsigned int v2; // [esp+0h] [ebp-24h]
  const void *v3; // [esp+4h] [ebp-20h]
  char *v4; // [esp+8h] [ebp-1Ch]
  unsigned int v5; // [esp+Ch] [ebp-18h]
  const void *v6; // [esp+10h] [ebp-14h]
  void *v7; // [esp+14h] [ebp-10h]
  signed int i; // [esp+18h] [ebp-Ch]

  for ( i = 31; i > 0; --i )
  {
    v7 = (void *)(280 * i + 139789120);
    v6 = (const void *)(280 * i + 139788840);
    v5 = 280;
    if ( (24 * (_BYTE)i + 64) & 4 )
    {
      dword_8550340[70 * i] = *((_DWORD *)&unk_8550228 + 70 * i);
      v7 = (void *)(280 * i + 139789124);
      v6 = (const void *)(280 * i + 139788844);
      v5 = 276;
    }
    qmemcpy(v7, v6, 4 * (v5 >> 2));
  }
  v4 = (char *)dword_8550340;
  v3 = a1;
  v2 = 280;
  result = (unsigned int)dword_8550340 & 4;
  if ( (unsigned int)dword_8550340 & 4 )
  {
    result = *a1;
    dword_8550340[0] = *a1;
    v4 = (char *)&dword_8550340[1];
    v3 = a1 + 1;
    v2 = 276;
  }
  qmemcpy(v4, v3, 4 * (v2 >> 2));
  if ( dword_8552640 <= 31 )
    ++dword_8552640;
  dword_8163F84 = -1;
  return result;
}
// 8163F84: using guessed type int dword_8163F84;
// 8552640: using guessed type int dword_8552640;

//----- (080D13C8) --------------------------------------------------------
int sub_80D13C8()
{
  int v1; // [esp+0h] [ebp-8h]

  if ( dword_8163F84 + 1 < dword_8552640 )
    v1 = 280 * ++dword_8163F84 + 139789120;
  else
    v1 = 0;
  return v1;
}
// 8163F84: using guessed type int dword_8163F84;
// 8552640: using guessed type int dword_8552640;

//----- (080D140A) --------------------------------------------------------
int sub_80D140A()
{
  int v1; // [esp+0h] [ebp-4h]

  if ( dword_8163F84 >= 0 )
    --dword_8163F84;
  if ( dword_8163F84 == -1 )
    v1 = 0;
  else
    v1 = 280 * dword_8163F84 + 139789120;
  return v1;
}
// 8163F84: using guessed type int dword_8163F84;

//----- (080D144A) --------------------------------------------------------
void __cdecl __noreturn Sys_Exit(int status)
{
  Sys_ConsoleInputShutdown();
  if ( byte_8163FA0 )
  {
    sleep(1u);
    sub_80D266A(&byte_8163FA0);
    sleep(1u);
  }
  exit(status);
}

//----- (080D148E) --------------------------------------------------------
void __noreturn Sys_Quit()
{
  int v0; // eax

  sub_80B0F16();
  sub_80605C0();
  sub_80A96D6();
  v0 = fcntl(0, 3, 0);
  fcntl(0, 4, v0 & 0xFFFFF7FF);
  Sys_Exit(0);
}

//----- (080D14EA) --------------------------------------------------------
char *__usercall Sys_Init@<eax>(long double a1@<st0>)
{
  const char *v1; // eax
  char *result; // eax

  Cmd_AddCommand("in_restart", (int)sub_80D1178);
  dword_8552644 = (int)Dvar_RegisterString(a1, "arch", (int)"linux i386", 4160);
  v1 = sub_80D40F0();
  result = Dvar_RegisterString(a1, "username", (int)v1, 4160);
  dword_8552648 = (int)result;
  return result;
}
// 8552644: using guessed type int dword_8552644;
// 8552648: using guessed type int dword_8552648;

//----- (080D1550) --------------------------------------------------------
void __noreturn Sys_Error(char *format, ...)
{
  int v1; // eax
  char s; // [esp+10h] [ebp-418h]
  __gnuc_va_list __varargs; // [esp+41Ch] [ebp-Ch]
  va_list va; // [esp+434h] [ebp+Ch]

  va_start(va, format);
  v1 = fcntl(0, 3, 0);
  fcntl(0, 4, v1 & 0xFFFFF7FF);
  if ( dword_85501CC )
    sub_80D120E();
  va_copy(__varargs, va);
  vsprintf(&s, format, va);
  fprintf(stderr, "Sys_Error: %s\n", &s);
  Sys_Exit(1);
}
// 85501CC: using guessed type int dword_85501CC;

//----- (080D15F0) --------------------------------------------------------
int Sys_Warn(char *format, ...)
{
  int result; // eax
  char s; // [esp+10h] [ebp-418h]
  __gnuc_va_list __varargs; // [esp+41Ch] [ebp-Ch]
  va_list va; // [esp+434h] [ebp+Ch]

  va_start(va, format);
  va_copy(__varargs, va);
  vsprintf(&s, format, va);
  if ( dword_85501CC )
    sub_80D120E();
  result = fprintf(stderr, "Warning: %s", &s);
  if ( dword_85501CC )
    result = sub_80D1256();
  return result;
}
// 85501CC: using guessed type int dword_85501CC;

//----- (080D1658) --------------------------------------------------------
__time_t __cdecl sub_80D1658(char *filename)
{
  __time_t v2; // [esp+1Ch] [ebp-6Ch]
  struct stat stat_buf; // [esp+20h] [ebp-68h]

  if ( sub_80A13EE(filename, &stat_buf) == -1 )
    v2 = -1;
  else
    v2 = stat_buf.st_mtim.tv_sec;
  return v2;
}

//----- (080D168C) --------------------------------------------------------
void handler()
{
  signal(8, handler);
}

//----- (080D16A8) --------------------------------------------------------
void __usercall Sys_ConsoleInputInit(long double a1@<st0>)
{
  char s; // [esp+10h] [ebp-48h]
  int v2; // [esp+1Ch] [ebp-3Ch]
  unsigned __int8 v3; // [esp+23h] [ebp-35h]
  unsigned __int8 v4; // [esp+25h] [ebp-33h]
  char v5; // [esp+26h] [ebp-32h]
  char v6; // [esp+27h] [ebp-31h]

  memset(&s, 0, 0x3Cu);
  signal(21, (__sighandler_t)1);
  signal(22, (__sighandler_t)1);
  dword_85501C8 = (int)Dvar_RegisterBool(a1, "ttycon", 1, 4112);
  Dvar_SetBool(dword_85501C8, 0);
  if ( (unsigned __int8)Dvar_GetBool("ttycon") )
  {
    if ( isatty(0) == 1 )
    {
      Com_Printf("Started tty console (use +set ttycon 0 to disable)\n");
      sub_8062590(&dword_8550220);
      tcgetattr(0, &termios_p);
      dword_85501D4 = v3;
      dword_85501D8 = v4;
      qmemcpy(&s, &termios_p, 0x3Cu);
      v2 &= 0xFFFFFFF5;
      *(_DWORD *)&s &= 0xFFFFFFCF;
      v6 = 1;
      v5 = 0;
      tcsetattr(0, 1, (const struct termios *)&s);
      dword_85501CC = 1;
    }
    else
    {
      Com_Printf("stdin is not a tty, tty console mode failed\n");
      Dvar_SetBool(dword_85501C8, 0);
      dword_85501CC = 0;
    }
  }
  else
  {
    dword_85501CC = 0;
  }
}
// 85501C8: using guessed type int dword_85501C8;
// 85501CC: using guessed type int dword_85501CC;
// 85501D4: using guessed type int dword_85501D4;
// 85501D8: using guessed type int dword_85501D8;
// 8550220: using guessed type int dword_8550220;

//----- (080D181A) --------------------------------------------------------
char *Sys_ConsoleInput()
{
  unsigned int v1; // [esp+24h] [ebp-D4h]
  int *v2; // [esp+28h] [ebp-D0h]
  int *v3; // [esp+2Ch] [ebp-CCh]
  unsigned int v4; // [esp+30h] [ebp-C8h]
  int *v5; // [esp+34h] [ebp-C4h]
  int *v6; // [esp+38h] [ebp-C0h]
  char *v7; // [esp+3Ch] [ebp-BCh]
  struct timeval timeout; // [esp+48h] [ebp-B0h]
  fd_set readfds; // [esp+50h] [ebp-A8h]
  ssize_t v10; // [esp+DCh] [ebp-1Ch]
  int *v11; // [esp+E0h] [ebp-18h]
  char buf; // [esp+E7h] [ebp-11h]
  ssize_t v13; // [esp+E8h] [ebp-10h]
  int i; // [esp+ECh] [ebp-Ch]

  buf = 0;
  if ( !(unsigned __int8)Dvar_GetBool("ttycon") )
  {
    if ( !dword_8163F80 )
      return 0;
    memset(&readfds, 0, sizeof(readfds));
    readfds.__fds_bits[0] |= 1u;
    timeout.tv_sec = 0;
    timeout.tv_usec = 0;
    if ( select(1, &readfds, 0, 0, &timeout) == -1 || !_bittest(readfds.__fds_bits, 0) )
      return 0;
    v10 = read(0, ::buf, 0x100u);
    if ( v10 )
    {
      if ( v10 > 0 )
      {
        *(_BYTE *)(v10 + 139798111) = 0;
        v7 = ::buf;
      }
      else
      {
        v7 = 0;
      }
    }
    else
    {
      dword_8163F80 = 0;
      v7 = 0;
    }
    return v7;
  }
  v13 = read(0, &buf, 1u);
  if ( v13 == -1 )
    return 0;
  if ( buf == dword_85501D4 || buf == 127 || buf == 8 )
  {
    if ( dword_8550220 > 0 )
    {
      *(_BYTE *)(--dword_8550220 + 139788856) = 0;
      sub_80D11A8();
    }
    return 0;
  }
  if ( !buf || buf > 31 )
  {
    *(_BYTE *)(dword_8550220++ + 139788856) = buf;
    write(1, &buf, 1u);
    return 0;
  }
  if ( buf == 10 )
  {
    sub_80D12EC(&dword_8550220);
    strcpy(::buf, &byte_8550238);
    sub_8062590(&dword_8550220);
    buf = 10;
    write(1, &buf, 1u);
    return ::buf;
  }
  if ( buf == 9 )
  {
    sub_80D120E();
    sub_8060924();
    dword_8550220 = strlen(&byte_8550238);
    if ( dword_8550220 > 0 && byte_8550238 == 92 )
    {
      for ( i = 0; i <= dword_8550220; ++i )
        *(_BYTE *)(i + 139788856) = *(_BYTE *)(i + 139788857);
      --dword_8550220;
    }
    sub_80D1256();
    return 0;
  }
  v13 = read(0, &buf, 1u);
  if ( v13 == -1 || buf != 91 && buf != 79 || (v13 = read(0, &buf, 1u), v13 == -1) )
  {
LABEL_45:
    Com_DPrintf("droping ISCTL sequence: %d, tty_erase: %d\n", buf, dword_85501D4);
    tty_FlushIn();
    return 0;
  }
  if ( buf == 66 )
  {
    v11 = (int *)sub_80D140A();
    sub_80D120E();
    if ( v11 )
    {
      v3 = &dword_8550220;
      v2 = v11;
      v1 = 280;
      if ( (unsigned int)&dword_8550220 & 4 )
      {
        dword_8550220 = *v11;
        v3 = &dword_8550220 + 1;
        v2 = v11 + 1;
        v1 = 276;
      }
      qmemcpy(v3, v2, 4 * (v1 >> 2));
    }
    else
    {
      sub_8062590(&dword_8550220);
    }
    sub_80D1256();
    tty_FlushIn();
    return 0;
  }
  if ( buf > 66 )
  {
    if ( buf == 67 )
      return 0;
    if ( buf == 68 )
      return 0;
    goto LABEL_45;
  }
  if ( buf != 65 )
    goto LABEL_45;
  v11 = (int *)sub_80D13C8();
  if ( v11 )
  {
    sub_80D120E();
    v6 = &dword_8550220;
    v5 = v11;
    v4 = 280;
    if ( (unsigned int)&dword_8550220 & 4 )
    {
      dword_8550220 = *v11;
      v6 = &dword_8550220 + 1;
      v5 = v11 + 1;
      v4 = 276;
    }
    qmemcpy(v6, v5, 4 * (v4 >> 2));
    sub_80D1256();
  }
  tty_FlushIn();
  return 0;
}
// 8163F80: using guessed type int dword_8163F80;
// 85501D4: using guessed type int dword_85501D4;
// 8550220: using guessed type int dword_8550220;

//----- (080D1D3E) --------------------------------------------------------
void __cdecl Sys_UnloadGame(void *handle)
{
  char *v1; // [esp+14h] [ebp-4h]

  if ( handle )
  {
    dlclose(handle);
    v1 = dlerror();
    if ( v1 )
      Com_Printf("Sys_UnloadGame failed on dlclose: \"%s\"!\n", v1);
  }
  else
  {
    Com_Printf("Sys_UnloadDll(NULL)\n");
  }
}

//----- (080D1D86) --------------------------------------------------------
void sub_80D1D86()
{
  ;
}

//----- (080D1DA6) --------------------------------------------------------
void __cdecl __noreturn sub_80D1DA6(int a1, int a2)
{
  fprintf(stderr, "OUT OF MEMORY! ABORTING!!! (%s:%d)\n", a1, a2);
  exit(-1);
}

//----- (080D1DDC) --------------------------------------------------------
void __noreturn sub_80D1DDC()
{
  Com_Error(0, "Unable to load shared library\n");
}

//----- (080D1DF8) --------------------------------------------------------
void *__cdecl Sys_LoadDll(int a1, char *dest, int a3, int a4)
{
  char *v4; // eax
  char *v5; // eax
  char file; // [esp+20h] [ebp-228h]
  char *v8; // [esp+120h] [ebp-128h]
  void *v9; // [esp+124h] [ebp-124h]
  void *v10; // [esp+128h] [ebp-120h]
  void *src; // [esp+12Ch] [ebp-11Ch]
  char s; // [esp+130h] [ebp-118h]
  void (__cdecl *v13)(int); // [esp+238h] [ebp-10h]
  void *handle; // [esp+23Ch] [ebp-Ch]

  *dest = 0;
  snprintf(&s, 0x100u, "%s.mp.i386.so", a1);
  src = sub_80D3F0E();
  v10 = sub_80B0D96("fs_homepath");
  v9 = sub_80B0D96("fs_basepath");
  v8 = (char *)sub_80B0D96("fs_game");
  FS_BuildOSPath(src, v8, &s, &file);
  Com_Printf("Sys_LoadDll(%s)... ", &file);
  handle = dlopen(&file, 2);
  if ( handle )
  {
    Com_Printf("ok\n");
  }
  else
  {
    Com_Printf("failed\n");
    FS_BuildOSPath(v10, v8, &s, &file);
    Com_Printf("Sys_LoadDll(%s)... ", &file);
    handle = dlopen(&file, 2);
    if ( handle )
    {
      Com_Printf("ok\n");
    }
    else
    {
      Com_Printf("failed\n");
      FS_BuildOSPath(v9, v8, &s, &file);
      Com_Printf("Sys_LoadDll(%s)... ", &file);
      handle = dlopen(&file, 2);
      if ( handle )
      {
        Com_Printf("ok\n");
      }
      else
      {
        v4 = dlerror();
        Com_Printf("\nSys_LoadDll(%s) failed:\n\"%s\"\n", &file, v4);
      }
      if ( !handle )
        Com_Error(0, "Sys_LoadDll(%s) failed dlopen() completely!\n", a1);
    }
  }
  I_strncpyz(dest, &file, 64);
  v13 = (void (__cdecl *)(int))dlsym(handle, "dllEntry");
  *(_DWORD *)a3 = dlsym(handle, "vmMain");
  if ( !*(_DWORD *)a3 || !v13 )
  {
    v5 = dlerror();
    Com_Error(0, "Sys_LoadDll(%s) failed dlsym(vmMain):\n\"%s\" !\n", a1, v5);
  }
  Com_Printf("Sys_LoadDll(%s) found **vmMain** at  %p  \n", a1, *(_DWORD *)a3);
  v13(a4);
  Com_Printf("Sys_LoadDll(%s) succeeded!\n", a1);
  return handle;
}

//----- (080D2168) --------------------------------------------------------
void sub_80D2168()
{
  ;
}

//----- (080D216E) --------------------------------------------------------
signed int __cdecl sub_80D216E(int a1, int a2, int a3, int a4)
{
  return FS_Read(a1, a3 * a2, a4);
}

//----- (080D2194) --------------------------------------------------------
int __cdecl sub_80D2194(int a1, int off, int a3)
{
  return sub_809E580(a1, off, a3);
}

//----- (080D21B6) --------------------------------------------------------
int __cdecl Sys_QueEvent(int a1, int a2, int a3, int a4, int a5, int a6)
{
  int result; // eax
  int *v7; // [esp+4h] [ebp-4h]

  v7 = &dword_8552760[6 * (unsigned __int8)dword_8553F60];
  if ( dword_8553F60 - dword_8553F64 > 255 )
  {
    Com_Printf("Sys_QueEvent: overflow\n");
    if ( v7[5] )
      Z_FreeInternal((void *)v7[5]);
    ++dword_8553F64;
  }
  ++dword_8553F60;
  if ( !a1 )
    a1 = Sys_MilliSeconds();
  *v7 = a1;
  v7[1] = a2;
  v7[2] = a3;
  v7[3] = a4;
  v7[4] = a5;
  result = a6;
  v7[5] = a6;
  return result;
}
// 8552760: using guessed type int dword_8552760[];
// 8553F60: using guessed type int dword_8553F60;
// 8553F64: using guessed type int dword_8553F64;

//----- (080D2262) --------------------------------------------------------
_DWORD *__stdcall sub_80D2262(_DWORD *a1)
{
  int v1; // edx
  size_t size; // ST28_4
  char *dest; // ST2C_4
  char *v4; // ST2C_4
  _DWORD *v5; // ST28_4
  int v6; // edx
  int v8; // [esp+30h] [ebp-78h]
  int v9; // [esp+34h] [ebp-74h]
  int v10; // [esp+38h] [ebp-70h]
  int v11; // [esp+3Ch] [ebp-6Ch]
  int v12; // [esp+40h] [ebp-68h]
  char v13; // [esp+50h] [ebp-58h]
  void *src; // [esp+54h] [ebp-54h]
  size_t n; // [esp+5Ch] [ebp-4Ch]
  char *s; // [esp+7Ch] [ebp-2Ch]
  int v17; // [esp+80h] [ebp-28h]
  int v18; // [esp+84h] [ebp-24h]
  int v19; // [esp+88h] [ebp-20h]
  int v20; // [esp+8Ch] [ebp-1Ch]
  int v21; // [esp+90h] [ebp-18h]
  int v22; // [esp+94h] [ebp-14h]

  if ( dword_8553F60 <= dword_8553F64 )
  {
    s = Sys_ConsoleInput();
    if ( s )
    {
      size = strlen(s) + 1;
      dest = (char *)Z_MallocInternal(size);
      strcpy(dest, s);
      Sys_QueEvent(0, 4, 0, 0, size, (int)dest);
    }
    sub_8067718(&v13, (int)&unk_8553F80, 0x4000);
    if ( Sys_GetPacket(&v8, (int)&v13) )
    {
      v4 = (char *)(n + 20);
      v5 = Z_MallocInternal(n + 20);
      *v5 = v8;
      v5[1] = v9;
      v5[2] = v10;
      v5[3] = v11;
      v5[4] = v12;
      memcpy(v5 + 5, src, n);
      Sys_QueEvent(0, 5, 0, 0, (int)v4, (int)v5);
    }
    if ( dword_8553F60 <= dword_8553F64 )
    {
      memset(&v17, 0, 0x18u);
      v17 = Sys_MilliSeconds();
      *a1 = v17;
      a1[1] = v18;
      a1[2] = v19;
      a1[3] = v20;
      a1[4] = v21;
      a1[5] = v22;
    }
    else
    {
      v6 = 6 * (unsigned __int8)(++dword_8553F64 - 1);
      *a1 = dword_8552760[v6];
      a1[1] = dword_8552764[v6];
      a1[2] = dword_8552768[v6];
      a1[3] = dword_855276C[v6];
      a1[4] = dword_8552770[v6];
      a1[5] = dword_8552774[v6];
    }
  }
  else
  {
    v1 = 6 * (unsigned __int8)(++dword_8553F64 - 1);
    *a1 = dword_8552760[v1];
    a1[1] = dword_8552764[v1];
    a1[2] = dword_8552768[v1];
    a1[3] = dword_855276C[v1];
    a1[4] = dword_8552770[v1];
    a1[5] = dword_8552774[v1];
  }
  return a1;
}
// 8552760: using guessed type int dword_8552760[];
// 8552764: using guessed type int dword_8552764[];
// 8552768: using guessed type int dword_8552768[];
// 855276C: using guessed type int dword_855276C[];
// 8552770: using guessed type int dword_8552770[];
// 8552774: using guessed type int dword_8552774[];
// 8553F60: using guessed type int dword_8553F60;
// 8553F64: using guessed type int dword_8553F64;

//----- (080D24F4) --------------------------------------------------------
int __cdecl sub_80D24F4(char *s)
{
  int result; // eax

  if ( dword_85501CC )
    sub_80D120E();
  result = fputs(s, stderr);
  if ( dword_85501CC )
    result = sub_80D1256();
  return result;
}
// 85501CC: using guessed type int dword_85501CC;

//----- (080D252C) --------------------------------------------------------
void Sys_ConfigureFPU()
{
  ;
}

//----- (080D253E) --------------------------------------------------------
int __cdecl Sys_PrintBinVersion(int a1)
{
  fprintf(stdout, "\n\n%s\n", "==============================================================");
  fprintf(stdout, "Linux Quake3 Dedicated Server [%s %s]\n", "Oct 25 2005", "18:23:51");
  fprintf(stdout, " local install: %s\n", a1);
  return fprintf(stdout, "%s\n\n", "==============================================================");
}

//----- (080D25D2) --------------------------------------------------------
void __cdecl sub_80D25D2(char *file, int a2)
{
  int *v2; // eax
  int *v3; // eax
  __mode_t mode; // [esp+1Ch] [ebp-6Ch]
  struct stat stat_buf; // [esp+20h] [ebp-68h]

  if ( sub_80A13EE(file, &stat_buf) )
  {
    v2 = __errno_location();
    Com_Printf("stat('%s')  failed: errno %d\n", file, *v2);
  }
  else
  {
    mode = stat_buf.st_mode | a2;
    if ( chmod(file, stat_buf.st_mode | a2) )
    {
      v3 = __errno_location();
      Com_Printf("chmod('%s', %d) failed: errno %d\n", file, mode, *v3);
    }
    Com_DPrintf("chmod +%d '%s'\n", file);
  }
}

//----- (080D266A) --------------------------------------------------------
__pid_t __cdecl sub_80D266A(char *s)
{
  __pid_t result; // eax

  result = fork();
  if ( result != -1 && !result )
  {
    if ( strchr(s, 32) )
      system(s);
    else
      execl(s, s, 0);
    _exit(0);
  }
  return result;
}

//----- (080D26D2) --------------------------------------------------------
void __usercall Sys_StartProcess(long double a1@<st0>, char *src, int a3)
{
  if ( a3 )
  {
    Com_DPrintf("Sys_StartProcess %s (delaying to final exit)\n", src);
    I_strncpyz(&byte_8163FA0, src, 1024);
    Cbuf_ExecuteText(a1, 2, "quit\n");
  }
  else
  {
    Com_DPrintf("Sys_StartProcess %s\n", src);
    sub_80D266A(src);
  }
}

//----- (080D2742) --------------------------------------------------------
void __usercall Sys_OpenURL(long double a1@<st0>, int a2, int a3)
{
  char s; // [esp+20h] [ebp-538h]
  char name; // [esp+420h] [ebp-138h]
  char dest; // [esp+520h] [ebp-38h]
  char v6[4]; // [esp+544h] [ebp-14h]
  char v7[4]; // [esp+548h] [ebp-10h]
  char v8[4]; // [esp+54Ch] [ebp-Ch]

  Com_Printf("Sys_OpenURL %s\n", a2);
  I_strncpyz(&dest, "openurl.sh", 20);
  *(_DWORD *)v6 = sub_80D3F0E();
  Com_sprintf(&name, 0x100u, "%s/%s", *(_DWORD *)v6, &dest);
  if ( access(&name, 1) != -1
    || (Com_DPrintf("%s not found\n", &name),
        *(_DWORD *)v7 = sub_80B0D96("fs_homepath"),
        Com_sprintf(&name, 0x100u, "%s/%s", *(_DWORD *)v7, &dest),
        access(&name, 1) != -1)
    || (Com_DPrintf("%s not found\n", &name),
        *(_DWORD *)v8 = sub_80B0D96("fs_basepath"),
        Com_sprintf(&name, 0x100u, "%s/%s", *(_DWORD *)v8, &dest),
        access(&name, 1) != -1) )
  {
    Com_DPrintf("URL script: %s\n", &name);
    Com_sprintf(&s, 0x400u, "%s '%s' &", &name, a2);
    Sys_StartProcess(a1, &s, a3);
  }
  else
  {
    Com_DPrintf("%s not found\n", &name);
    Com_Printf("Can't find script '%s' to open requested URL (use +set developer 1 for more verbosity)\n", &dest);
  }
}

//----- (080D2930) --------------------------------------------------------
void __cdecl Sys_ParseArgs(int a1, int a2)
{
  if ( a1 == 2 && (!strcmp(*(const char **)(a2 + 4), "--version") || !strcmp(*(const char **)(a2 + 4), "-v")) )
  {
    Sys_PrintBinVersion(*(_DWORD *)a2);
    Sys_Exit(0);
  }
}

//----- (080D2990) --------------------------------------------------------
void __usercall __noreturn main(long double a1@<st0>, int a2, char **a3)
{
  void *v3; // esp
  __uid_t v4; // eax
  int v5; // eax
  char *dest; // [esp+Ch] [ebp-Ch]
  int i; // [esp+10h] [ebp-8h]
  int j; // [esp+10h] [ebp-8h]
  signed int v9; // [esp+14h] [ebp-4h]

  v3 = alloca(0);
  saved_euid = geteuid();
  v4 = getuid();
  seteuid(v4);
  sub_806283E();
  Sys_InitMainThread();
  Dvar_Init(a1);
  Sys_ParseArgs(a2, (int)a3);
  Sys_SetDefaultCDPath(&byte_814AE9F);
  v9 = 1;
  for ( i = 1; i < a2; ++i )
    v9 += strlen(a3[i]) + 1;
  dest = (char *)operator new[](v9);
  *dest = 0;
  for ( j = 1; j < a2; ++j )
  {
    if ( j > 1 )
      strcat(dest, " ");
    strcat(dest, a3[j]);
  }
  memset(dword_8552760, 0, 0x1800u);
  memset(&unk_8553F80, 0, 0x4000u);
  Sys_MilliSeconds();
  Com_Init(a1, dest);
  Sys_ConsoleInputInit(a1);
  v5 = fcntl(0, 3, 0);
  fcntl(0, 4, v5 | 0x800);
  while ( 1 )
  {
    Sys_ConfigureFPU();
    usleep(0x1388u);
    Com_Frame(a1);
  }
}
// 85501C4: using guessed type int saved_euid;
// 8552760: using guessed type int dword_8552760[];

//----- (080D2B24) --------------------------------------------------------
void __noreturn Sys_LoadRenderer()
{
  Com_Error(0, "Sys_LoadRenderer is unimplemented\n");
}

//----- (080D2B46) --------------------------------------------------------
void __noreturn Sys_UnloadRenderer()
{
  Com_Error(0, "Sys_UnloadRenderer is unimplemented\n");
}

//----- (080D2B64) --------------------------------------------------------
int __cdecl sub_80D2B64(int a1, void *s)
{
  int result; // eax

  memset(s, 0, 0x10u);
  if ( *(_DWORD *)a1 == 3 )
  {
    *(_WORD *)s = 2;
    *((_WORD *)s + 1) = *(_WORD *)(a1 + 8);
    result = (int)s + 4;
    *((_DWORD *)s + 1) = -1;
  }
  else
  {
    result = a1;
    if ( *(_DWORD *)a1 == 4 )
    {
      *(_WORD *)s = 2;
      *((_DWORD *)s + 1) = *(_DWORD *)(a1 + 4);
      result = *(unsigned __int16 *)(a1 + 8);
      *((_WORD *)s + 1) = result;
    }
  }
  return result;
}

//----- (080D2BE2) --------------------------------------------------------
int __cdecl sub_80D2BE2(int a1, int a2)
{
  int result; // eax

  *(_DWORD *)(a2 + 4) = *(_DWORD *)(a1 + 4);
  *(_WORD *)(a2 + 8) = *(_WORD *)(a1 + 2);
  result = a2;
  *(_DWORD *)a2 = 4;
  return result;
}

//----- (080D2C0E) --------------------------------------------------------
char *__cdecl sub_80D2C0E(int a1, int a2)
{
  Com_sprintf(byte_855A040, 0x40u, "%i.%i.%i.%i", (unsigned __int8)a2, BYTE1(a2), BYTE2(a2), HIBYTE(a2));
  return byte_855A040;
}

//----- (080D2C58) --------------------------------------------------------
int __cdecl sub_80D2C58(char *cp, void *s)
{
  struct hostent *v4; // [esp+10h] [ebp-8h]

  memset(s, 0, 0x10u);
  *(_WORD *)s = 2;
  *((_WORD *)s + 1) = 0;
  if ( *cp > 47 && *cp <= 57 )
  {
    *((_DWORD *)s + 1) = inet_addr(cp);
    return 1;
  }
  v4 = gethostbyname(cp);
  if ( v4 )
  {
    *((_DWORD *)s + 1) = **(_DWORD **)v4->h_addr_list;
    return 1;
  }
  return 0;
}

//----- (080D2CF0) --------------------------------------------------------
int __cdecl sub_80D2CF0(char *cp, int a2)
{
  char s; // [esp+20h] [ebp-18h]

  if ( !sub_80D2C58(cp, &s) )
    return 0;
  sub_80D2BE2((int)&s, a2);
  return 1;
}

//----- (080D2D34) --------------------------------------------------------
signed int __cdecl Sys_GetPacket(int *a1, int a2)
{
  char *v2; // ebx
  char *v3; // eax
  char *v4; // eax
  int v7; // [esp+30h] [ebp-38h]
  signed int i; // [esp+34h] [ebp-34h]
  int fd; // [esp+38h] [ebp-30h]
  socklen_t addr_len; // [esp+3Ch] [ebp-2Ch]
  struct sockaddr addr; // [esp+40h] [ebp-28h]
  ssize_t v12; // [esp+5Ch] [ebp-Ch]

  for ( i = 0; i <= 1; ++i )
  {
    if ( i )
      fd = dword_8557F9C;
    else
      fd = ::fd;
    if ( fd )
    {
      addr_len = 16;
      v12 = recvfrom(fd, *(void **)(a2 + 4), *(_DWORD *)(a2 + 8), 0, &addr, &addr_len);
      sub_80D2BE2((int)&addr, (int)a1);
      *(_DWORD *)(a2 + 16) = 0;
      if ( v12 == -1 )
      {
        v7 = *__errno_location();
        if ( v7 != 11 && v7 != 111 )
        {
          v2 = sub_806AD14(*a1, a1[1], a1[2], a1[3], a1[4]);
          v3 = sub_80D3636();
          Com_Printf("NET_GetPacket: %s from %s\n", v3, v2);
        }
      }
      else
      {
        if ( v12 != *(_DWORD *)(a2 + 8) )
        {
          *(_DWORD *)(a2 + 12) = v12;
          return 1;
        }
        v4 = sub_806AD14(*a1, a1[1], a1[2], a1[3], a1[4]);
        Com_Printf("Oversize packet from %s\n", v4);
      }
    }
  }
  return 0;
}
// 8557F9C: using guessed type int dword_8557F9C;

//----- (080D2EA8) --------------------------------------------------------
int __cdecl Sys_SendPacket(size_t n, void *buf, int a3, int a4, int a5, int a6, int a7)
{
  char *v7; // ebx
  char *v8; // eax
  int fd; // [esp+2Ch] [ebp-2Ch]
  struct sockaddr addr; // [esp+30h] [ebp-28h]
  ssize_t v13; // [esp+4Ch] [ebp-Ch]

  switch ( a3 )
  {
    case 3:
      fd = ::fd;
      break;
    case 4:
      fd = ::fd;
      break;
    case 5:
      fd = dword_8557F9C;
      break;
    default:
      if ( a3 != 6 )
        Com_Error(0, "NET_SendPacket: bad address type");
      fd = dword_8557F9C;
      break;
  }
  if ( !fd )
    return 0;
  sub_80D2B64((int)&a3, &addr);
  v13 = sendto(fd, buf, n, 0, &addr, 0x10u);
  if ( v13 != -1 )
    return 1;
  v7 = sub_806AD14(a3, a4, a5, a6, a7);
  v8 = sub_80D3636();
  Com_Printf("NET_SendPacket ERROR: %s to %s\n", v8, v7);
  return 0;
}
// 8557F9C: using guessed type int dword_8557F9C;

//----- (080D2FC8) --------------------------------------------------------
signed int __cdecl Sys_IsLANAddress(int a1, int a2)
{
  int i; // [esp+4h] [ebp-4h]

  if ( a1 == 2 )
    return 1;
  if ( a1 == 5 )
    return 1;
  if ( a1 != 4 )
    return 0;
  if ( (_BYTE)a2 == 10 )
    return 1;
  if ( (_BYTE)a2 == 127 )
    return 1;
  if ( (_BYTE)a2 == -87 && BYTE1(a2) == -2 )
    return 1;
  if ( (_BYTE)a2 == -84 && (BYTE1(a2) & 0xF0) == 16 )
    return 1;
  if ( (_BYTE)a2 == -64 && BYTE1(a2) == -88 )
    return 1;
  for ( i = 0; i < dword_8557FA0; ++i )
  {
    if ( (_BYTE)a2 == byte_8557FC0[4 * i] && BYTE1(a2) == byte_8557FC1[4 * i] && BYTE2(a2) == byte_8557FC2[4 * i] )
      return 1;
  }
  return 0;
}
// 8557FA0: using guessed type int dword_8557FA0;

//----- (080D30D2) --------------------------------------------------------
int sub_80D30D2()
{
  int result; // eax
  int i; // [esp+14h] [ebp-4h]

  for ( i = 0; ; ++i )
  {
    result = i;
    if ( i >= dword_8557FA0 )
      break;
    Com_Printf(
      "IP: %i.%i.%i.%i\n",
      (unsigned __int8)byte_8557FC0[4 * i],
      (unsigned __int8)byte_8557FC1[4 * i],
      (unsigned __int8)byte_8557FC2[4 * i],
      (unsigned __int8)byte_8557FC3[4 * i]);
  }
  return result;
}
// 8557FA0: using guessed type int dword_8557FA0;

//----- (080D313E) --------------------------------------------------------
struct hostent *sub_80D313E()
{
  struct hostent *result; // eax
  char *v1; // edx
  signed int v2; // eax
  int v3; // [esp+20h] [ebp-118h]
  char *v4; // [esp+28h] [ebp-110h]
  struct hostent *v5; // [esp+2Ch] [ebp-10Ch]
  char name; // [esp+30h] [ebp-108h]

  result = (struct hostent *)gethostname(&name, 0x100u);
  if ( result != (struct hostent *)-1 )
  {
    result = gethostbyname(&name);
    v5 = result;
    if ( result )
    {
      Com_Printf("Hostname: %s\n", result->h_name);
      v3 = 0;
      while ( 1 )
      {
        v1 = v5->h_aliases[v3++];
        if ( !v1 )
          break;
        Com_Printf("Alias: %s\n", v1);
      }
      result = v5;
      if ( v5->h_addrtype == 2 )
      {
        dword_8557FA0 = 0;
        while ( 1 )
        {
          result = (struct hostent *)v5->h_addr_list[dword_8557FA0++];
          v4 = (char *)result;
          if ( !result || dword_8557FA0 > 15 )
            break;
          v2 = ntohl((uint32_t)result->h_name);
          byte_8557FC0[4 * dword_8557FA0] = *v4;
          byte_8557FC1[4 * dword_8557FA0] = v4[1];
          byte_8557FC2[4 * dword_8557FA0] = v4[2];
          byte_8557FC3[4 * dword_8557FA0] = v4[3];
          Com_Printf("IP: %i.%i.%i.%i\n", (v2 >> 24) & 0xFF, (v2 >> 16) & 0xFF, (v2 >> 8) & 0xFF, (unsigned __int8)v2);
        }
      }
    }
  }
  return result;
}
// 8557FA0: using guessed type int dword_8557FA0;

//----- (080D330E) --------------------------------------------------------
struct hostent *__usercall sub_80D330E@<eax>(long double a1@<st0>)
{
  int i; // [esp+14h] [ebp-14h]
  int v3; // [esp+18h] [ebp-10h]
  char *cp; // [esp+1Ch] [ebp-Ch]
  char *v5; // [esp+20h] [ebp-8h]
  char *v6; // [esp+24h] [ebp-4h]

  v6 = Dvar_RegisterString(a1, "net_ip", (int)"localhost", 4112);
  v5 = Dvar_RegisterInt(a1, "net_port", 28960, 0, 999999, 4112);
  v3 = Dvar_GetInt("net_port");
  cp = (char *)sub_80B0D96("net_ip");
  for ( i = 0; ; ++i )
  {
    if ( i > 9 )
      Com_Error(0, "Couldn't allocate IP port");
    fd = sub_80D3438(cp, v3 + i);
    if ( fd )
      break;
  }
  Dvar_SetInt((int)v5, (char *)(v3 + i));
  return sub_80D313E();
}

//----- (080D33EC) --------------------------------------------------------
struct hostent *__usercall NET_Init@<eax>(long double a1@<st0>)
{
  struct hostent *result; // eax

  dword_8557F80 = (int)Dvar_RegisterBool(a1, "net_noudp", 0, 4112);
  result = (struct hostent *)Dvar_GetBool("net_noudp");
  if ( !(_BYTE)result && !fd )
    result = sub_80D330E(a1);
  return result;
}
// 8557F80: using guessed type int dword_8557F80;

//----- (080D3438) --------------------------------------------------------
int __cdecl sub_80D3438(char *cp, int a2)
{
  char *v2; // eax
  char *v3; // eax
  char *v4; // eax
  char *v5; // eax
  int v7; // [esp+24h] [ebp-34h]
  int optval; // [esp+28h] [ebp-30h]
  int v9; // [esp+2Ch] [ebp-2Ch]
  struct sockaddr addr; // [esp+30h] [ebp-28h]
  int fd; // [esp+4Ch] [ebp-Ch]

  v9 = 1;
  optval = 1;
  if ( cp )
    Com_Printf("Opening IP socket: %s:%i\n", cp, a2);
  else
    Com_Printf("Opening IP socket: localhost:%i\n", a2);
  fd = socket(2, 2, 17);
  if ( fd == -1 )
  {
    v2 = sub_80D3636();
    Com_Printf("ERROR: UDP_OpenSocket: socket: %s", v2);
    v7 = 0;
  }
  else if ( ioctl(fd, 0x5421u, &v9) == -1 )
  {
    v3 = sub_80D3636();
    Com_Printf("ERROR: UDP_OpenSocket: ioctl FIONBIO:%s\n", v3);
    v7 = 0;
  }
  else if ( setsockopt(fd, 1, 6, &optval, 4u) == -1 )
  {
    v4 = sub_80D3636();
    Com_Printf("ERROR: UDP_OpenSocket: setsockopt SO_BROADCAST:%s\n", v4);
    v7 = 0;
  }
  else
  {
    if ( cp && *cp && I_stricmp(cp, "localhost") )
      sub_80D2C58(cp, &addr);
    else
      *(_DWORD *)&addr.sa_data[2] = 0;
    if ( a2 == -1 )
      *(_WORD *)addr.sa_data = 0;
    else
      *(_WORD *)addr.sa_data = htons(a2);
    addr.sa_family = 2;
    if ( bind(fd, &addr, 0x10u) == -1 )
    {
      v5 = sub_80D3636();
      Com_Printf("ERROR: UDP_OpenSocket: bind: %s\n", v5);
      close(fd);
      v7 = 0;
    }
    else
    {
      v7 = fd;
    }
  }
  return v7;
}

//----- (080D360E) --------------------------------------------------------
int sub_80D360E()
{
  int result; // eax

  if ( fd )
  {
    result = close(fd);
    fd = 0;
  }
  return result;
}

//----- (080D3636) --------------------------------------------------------
char *sub_80D3636()
{
  int *v0; // eax

  v0 = __errno_location();
  return strerror(*v0);
}

//----- (080D3654) --------------------------------------------------------
int __cdecl sub_80D3654(int a1)
{
  fd_set readfds; // [esp+30h] [ebp-98h]
  struct timeval timeout; // [esp+B8h] [ebp-10h]

  memset(&readfds, 0, sizeof(readfds));
  if ( dword_8163F80 )
    readfds.__fds_bits[0] |= 1u;
  _bittestandset(&readfds.__fds_bits[(unsigned int)fd >> 5], fd & 0x1F);
  timeout.tv_sec = a1 / 1000;
  timeout.tv_usec = 1000 * (a1 % 1000);
  return select(fd + 1, &readfds, 0, 0, &timeout);
}
// 8163F80: using guessed type int dword_8163F80;

//----- (080D3728) --------------------------------------------------------
int Sys_MilliSeconds()
{
  int v0; // ebx
  int v2; // [esp+Ch] [ebp-1Ch]
  struct timezone tz; // [esp+10h] [ebp-18h]
  struct timeval tv; // [esp+18h] [ebp-10h]

  gettimeofday(&tv, &tz);
  if ( dword_855A384 )
  {
    v0 = 1000 * (tv.tv_sec - dword_855A384);
    dword_855A380 = tv.tv_usec / 1000 + v0;
    v2 = tv.tv_usec / 1000 + v0;
  }
  else
  {
    dword_855A384 = tv.tv_sec;
    v2 = tv.tv_usec / 1000;
  }
  return v2;
}
// 855A380: using guessed type int dword_855A380;
// 855A384: using guessed type int dword_855A384;

//----- (080D37B0) --------------------------------------------------------
int sub_80D37B0()
{
  struct timezone tz; // [esp+10h] [ebp-18h]
  struct timeval tv; // [esp+18h] [ebp-10h]

  gettimeofday(&tv, &tz);
  dword_855A380 = tv.tv_usec / 1000 + 1000 * tv.tv_sec;
  return tv.tv_usec / 1000 + 1000 * tv.tv_sec;
}
// 855A380: using guessed type int dword_855A380;

//----- (080D3824) --------------------------------------------------------
void __cdecl sub_80D3824(float *a1)
{
  *a1 = rint(*a1);
  a1[1] = rint(a1[1]);
  a1[2] = rint(a1[2]);
}

//----- (080D3874) --------------------------------------------------------
int __cdecl sub_80D3874(char *path)
{
  return mkdir(path, 0x1FFu);
}

//----- (080D3890) --------------------------------------------------------
DIR *__cdecl sub_80D3890(int a1, _BYTE *a2, int a3, int a4, DIR *a5)
{
  DIR *result; // eax
  struct stat stat_buf; // [esp+20h] [ebp-378h]
  struct dirent *v7; // [esp+88h] [ebp-310h]
  DIR *dirp; // [esp+8Ch] [ebp-30Ch]
  char filename; // [esp+90h] [ebp-308h]
  char s; // [esp+190h] [ebp-208h]
  char name; // [esp+290h] [ebp-108h]

  result = a5;
  if ( *(_DWORD *)a5 <= 4094 )
  {
    if ( *a2 )
      Com_sprintf(&name, 0x100u, "%s/%s", a1, a2);
    else
      Com_sprintf(&name, 0x100u, "%s", a1);
    result = opendir(&name);
    dirp = result;
    if ( result )
    {
      while ( 1 )
      {
        v7 = readdir(dirp);
        if ( !v7 )
          break;
        Com_sprintf(&filename, 0x100u, "%s/%s", &name, v7->d_name);
        if ( sub_80A13EE(&filename, &stat_buf) != -1 )
        {
          if ( stat_buf.st_mode & 0x4000 && I_stricmp(v7->d_name, ".") && I_stricmp(v7->d_name, "..") )
          {
            if ( *a2 )
              Com_sprintf(&s, 0x100u, "%s/%s", a2, v7->d_name);
            else
              Com_sprintf(&s, 0x100u, "%s", v7->d_name);
            sub_80D3890(a1, (unsigned int)&s, a3, a4, a5);
          }
          if ( *(_DWORD *)a5 > 4094 )
            break;
          Com_sprintf(&filename, 0x100u, "%s/%s", a2, v7->d_name);
          if ( (unsigned __int8)sub_80AA618(a3, (int)&filename, 0) )
            *(_DWORD *)(a4 + 4 * (*(_DWORD *)a5)++) = sub_80A93B0(&filename);
        }
      }
      result = (DIR *)closedir(dirp);
    }
  }
  return result;
}

//----- (080D3B28) --------------------------------------------------------
void *__cdecl Sys_ListFiles(char *name, char *s, int a3, int a4, int a5)
{
  size_t v5; // ebx
  size_t v6; // eax
  int v7; // ebx
  size_t v8; // eax
  int v9; // ebx
  void *v11; // [esp+28h] [ebp-41A0h]
  struct stat stat_buf; // [esp+30h] [ebp-4198h]
  int i; // [esp+9Ch] [ebp-412Ch]
  int v14[4098]; // [esp+A0h] [ebp-4128h]
  _DWORD *v15; // [esp+40A8h] [ebp-120h]
  int v16; // [esp+40ACh] [ebp-11Ch]
  char filename; // [esp+40B0h] [ebp-118h]
  int v18; // [esp+41B4h] [ebp-14h]
  DIR *dirp; // [esp+41B8h] [ebp-10h]
  struct dirent *v20; // [esp+41BCh] [ebp-Ch]

  v18 = a5;
  if ( a3 )
  {
    v16 = 0;
    sub_80D3890((int)name, &unk_814B1CE, a3, (int)v14, (DIR *)&v16);
    v14[v16] = 0;
    *(_DWORD *)a4 = v16;
    if ( v16 )
    {
      v15 = Z_MallocInternal(4 * v16 + 4);
      for ( i = 0; i < v16; ++i )
        v15[i] = v14[i];
      v15[i] = 0;
      v11 = v15;
    }
    else
    {
      v11 = 0;
    }
  }
  else
  {
    if ( !s )
      s = (char *)&unk_814B1CE;
    if ( *s == 47 && !s[1] )
    {
      s = (char *)&unk_814B1CE;
      v18 = 1;
    }
    strlen(s);
    v16 = 0;
    dirp = opendir(name);
    if ( dirp )
    {
      while ( 1 )
      {
        v20 = readdir(dirp);
        if ( !v20 )
          break;
        Com_sprintf(&filename, 0x100u, "%s/%s", name, v20->d_name);
        if ( sub_80A13EE(&filename, &stat_buf) != -1
          && (!v18 || stat_buf.st_mode & 0x4000)
          && (v18 || !(stat_buf.st_mode & 0x4000)) )
        {
          if ( !*s
            || (v5 = strlen(v20->d_name), v5 >= strlen(s))
            && (v6 = strlen(v20->d_name), v7 = (int)v20 + v6, v8 = strlen(s), !I_stricmp((char *)(v7 - v8 + 11), s)) )
          {
            if ( v16 == 4095 )
              break;
            v9 = v16;
            v14[v9] = (int)sub_80A93B0(v20->d_name);
            ++v16;
          }
        }
      }
      v14[v16] = 0;
      closedir(dirp);
      *(_DWORD *)a4 = v16;
      if ( v16 )
      {
        v15 = Z_MallocInternal(4 * v16 + 4);
        for ( i = 0; i < v16; ++i )
          v15[i] = v14[i];
        v15[i] = 0;
        v11 = v15;
      }
      else
      {
        v11 = 0;
      }
    }
    else
    {
      *(_DWORD *)a4 = 0;
      v11 = 0;
    }
  }
  return v11;
}
// 80D3B28: using guessed type int var_4128[4098];

//----- (080D3EB8) --------------------------------------------------------
void __cdecl Sys_FreeFileList(void *ptr)
{
  int i; // [esp+4h] [ebp-4h]

  if ( ptr )
  {
    for ( i = 0; *((_DWORD *)ptr + i); ++i )
      Z_FreeInternal(*((void **)ptr + i));
    Z_FreeInternal(ptr);
  }
}

//----- (080D3F0E) --------------------------------------------------------
char *sub_80D3F0E()
{
  getcwd(byte_855A3A0, 0xFFu);
  byte_855A49F = 0;
  return byte_855A3A0;
}
// 855A49F: using guessed type char byte_855A49F;

//----- (080D3F36) --------------------------------------------------------
char *__cdecl Sys_SetDefaultCDPath(char *src)
{
  return I_strncpyz(byte_855A080, src, 256);
}

//----- (080D3F5A) --------------------------------------------------------
char *Sys_DefaultCDPath()
{
  return byte_855A080;
}

//----- (080D3F64) --------------------------------------------------------
char *sub_80D3F64()
{
  char *v1; // [esp+4h] [ebp-4h]

  if ( byte_855A180 )
    v1 = &byte_855A180;
  else
    v1 = sub_80D3F0E();
  return v1;
}

//----- (080D3F8A) --------------------------------------------------------
char *__cdecl sub_80D3F8A(char *src)
{
  return I_strncpyz(&byte_855A180, src, 256);
}

//----- (080D3FAE) --------------------------------------------------------
char *Sys_DefaultInstallPath()
{
  char *v1; // [esp+4h] [ebp-4h]

  if ( byte_855A180 )
    v1 = &byte_855A180;
  else
    v1 = sub_80D3F0E();
  return v1;
}

//----- (080D3FD4) --------------------------------------------------------
char *__cdecl sub_80D3FD4(char *src)
{
  return I_strncpyz(&path, src, 256);
}

//----- (080D3FF8) --------------------------------------------------------
char *Sys_DefaultHomePath()
{
  int *v0; // ebx
  int *v1; // eax
  char *v2; // eax
  char *src; // [esp+20h] [ebp-8h]

  if ( path )
    return &path;
  src = getenv("HOME");
  if ( !src )
    return (char *)&unk_814B1CE;
  I_strncpyz(&path, src, 256);
  sub_80B57C0(&path, 256, "/.callofduty2");
  if ( mkdir(&path, 0x1FFu) && *__errno_location() != 17 )
  {
    v0 = __errno_location();
    v1 = __errno_location();
    v2 = strerror(*v1);
    Sys_Error("Unable to create directory \"%s\", error is %s(%d)\n", &path, v2, *v0);
  }
  return &path;
}

//----- (080D40EA) --------------------------------------------------------
void sub_80D40EA()
{
  ;
}

//----- (080D40F0) --------------------------------------------------------
const char *sub_80D40F0()
{
  __uid_t v0; // eax
  const char *v2; // [esp+10h] [ebp-8h]
  struct passwd *v3; // [esp+14h] [ebp-4h]

  v0 = getuid();
  v3 = getpwuid(v0);
  if ( v3 )
    v2 = v3->pw_name;
  else
    v2 = "player";
  return v2;
}

//----- (080D4122) --------------------------------------------------------
_BYTE *__cdecl strlwr(_BYTE *a1)
{
  if ( !a1 )
    return 0;
  while ( *a1 )
  {
    *a1 = tolower((char)*a1);
    ++a1;
  }
  return a1;
}

//----- (080D416A) --------------------------------------------------------
int __cdecl sub_80D416A(char *s)
{
  size_t v1; // eax
  struct dirent *v3; // [esp+8h] [ebp-10h]
  DIR *dirp; // [esp+Ch] [ebp-Ch]
  int i; // [esp+10h] [ebp-8h]
  signed int v6; // [esp+10h] [ebp-8h]
  char *dest; // [esp+14h] [ebp-4h]

  v1 = strlen(s);
  dest = (char *)operator new[](v1 + 1);
  strcpy(dest, s);
  for ( i = 0; dest[i]; ++i )
  {
    if ( dest[i] == 92 )
      dest[i] = 47;
  }
  v6 = 0;
  dirp = opendir(dest);
  if ( dirp )
  {
    while ( 1 )
    {
      v3 = readdir(dirp);
      if ( !v3 )
        break;
      if ( strcmp(v3->d_name, ".") && strcmp(v3->d_name, "..") )
      {
        v6 = 1;
        break;
      }
    }
    closedir(dirp);
  }
  if ( dest )
    operator delete[](dest);
  return v6;
}

//----- (080D425A) --------------------------------------------------------
int __cdecl sub_80D425A(char *s)
{
  size_t v1; // eax
  size_t v2; // ebx
  struct stat stat_buf; // [esp+20h] [ebp-88h]
  char *name; // [esp+88h] [ebp-20h]
  size_t maxlen; // [esp+8Ch] [ebp-1Ch]
  struct dirent *v7; // [esp+90h] [ebp-18h]
  DIR *dirp; // [esp+94h] [ebp-14h]
  int i; // [esp+98h] [ebp-10h]
  char *dest; // [esp+9Ch] [ebp-Ch]

  v1 = strlen(s);
  dest = (char *)operator new[](v1 + 1);
  strcpy(dest, s);
  for ( i = 0; dest[i]; ++i )
  {
    if ( dest[i] == 92 )
      dest[i] = 47;
  }
  i = 1;
  dirp = opendir(dest);
  if ( dirp )
  {
    while ( 1 )
    {
      v7 = readdir(dirp);
      if ( !v7 )
        break;
      if ( strcmp(v7->d_name, ".") && strcmp(v7->d_name, "..") )
      {
        v2 = strlen(dest);
        maxlen = strlen(v7->d_name) + v2 + 2;
        name = (char *)operator new[](maxlen);
        snprintf(name, maxlen, "%s/%s", dest, v7->d_name);
        if ( sub_80A13EE(name, &stat_buf) == -1 )
        {
          i = 0;
        }
        else if ( (stat_buf.st_mode & 0xF000) == 0x4000 )
        {
          i = sub_80D425A(name);
        }
        else
        {
          i = unlink(name) != -1;
        }
        if ( name )
          operator delete[](name);
        if ( !i )
          break;
      }
    }
    closedir(dirp);
  }
  if ( i == 1 )
    i = rmdir(dest) != -1;
  if ( dest )
    operator delete[](dest);
  return 1;
}

//----- (080D4444) --------------------------------------------------------
int Sys_InitMainThread()
{
  dword_855A4B4 = pthread_self();
  return sub_80B5A86(0);
}
// 855A4B4: using guessed type int dword_855A4B4;

//----- (080D446C) --------------------------------------------------------
_BOOL4 Sys_IsMainThread()
{
  return pthread_self() == dword_855A4B4;
}
// 855A4B4: using guessed type int dword_855A4B4;

//----- (080D4492) --------------------------------------------------------
int __cdecl Sys_SetValue(int a1, int a2)
{
  int result; // eax

  result = a2;
  dword_855A4A0[a1] = a2;
  return result;
}

//----- (080D44A4) --------------------------------------------------------
int __cdecl Sys_GetValue(int a1)
{
  return dword_855A4A0[a1];
}

//----- (080D4560) --------------------------------------------------------
char *__usercall sub_80D4560@<eax>(long double a1@<st0>)
{
  char *result; // eax

  result = Dvar_RegisterBool(a1, "snd_errorOnMissing", 0, 4097);
  dword_855A4B8 = (int)result;
  return result;
}
// 855A4B8: using guessed type int dword_855A4B8;

//----- (080D4590) --------------------------------------------------------
void SND_ShutdownChannels()
{
  ;
}

//----- (080D45C4) --------------------------------------------------------
int __cdecl sub_80D45C4(int a1)
{
  int v2; // [esp+10h] [ebp-8h]
  int i; // [esp+14h] [ebp-4h]

  v2 = 0;
  for ( i = 0; *(_BYTE *)(a1 + i); ++i )
    v2 += (i + 119) * (char)tolower(*(char *)(a1 + i));
  if ( v2 == -1 )
    v2 = 0;
  return v2;
}

//----- (080D4624) --------------------------------------------------------
void __noreturn sub_80D4624(char *format, ...)
{
  int v1; // eax
  char s; // [esp+20h] [ebp-418h]
  __gnuc_va_list __varargs; // [esp+42Ch] [ebp-Ch]
  va_list va; // [esp+444h] [ebp+Ch]

  va_start(va, format);
  va_copy(__varargs, va);
  vsprintf(&s, format, va);
  if ( *(_DWORD *)off_81643C0 )
  {
    v1 = sub_80B3B6C();
    Com_Error(1, &byte_814B63B, &s, *(_DWORD *)off_81643C0, v1 + 1);
  }
  Com_Error(1, &byte_814B64E, &s);
}

//----- (080D46AC) --------------------------------------------------------
int __cdecl sub_80D46AC(char *src)
{
  int v1; // ST24_4
  int v3; // [esp+18h] [ebp-10h]
  int i; // [esp+1Ch] [ebp-Ch]
  int v5; // [esp+1Ch] [ebp-Ch]
  int v6; // [esp+20h] [ebp-8h]
  int v7; // [esp+20h] [ebp-8h]
  int v8; // [esp+24h] [ebp-4h]
  int v9; // [esp+24h] [ebp-4h]

  if ( dword_855D568 )
  {
    v7 = sub_80D45C4((int)src);
    v5 = 0;
    v9 = dword_855D568;
    while ( v5 < *(_DWORD *)dword_855D56C )
    {
      if ( v7 == *(_DWORD *)(v9 + 4) && !I_stricmp(src, (char *)(v9 + 8)) )
        return v5;
      ++v5;
      v9 += 72;
    }
    v1 = dword_855D568 + 72 * *(_DWORD *)dword_855D56C;
    sub_806D982("multiplayer", src, (_DWORD *)v1, *((_DWORD *)dword_855A4E0 + 184058));
    strcpy((char *)(v1 + 8), src);
    *(_DWORD *)(v1 + 4) = v7;
    v3 = ++*(_DWORD *)dword_855D56C - 1;
  }
  else
  {
    v6 = sub_80D45C4((int)src);
    v8 = 0;
    for ( i = dword_855A4E4; ; i += 96 )
    {
      if ( v8 >= *(_DWORD *)(dword_855A4E4 + 49152) )
        sub_80D4624("BG_AnimationIndexForString: unknown player animation '%s'", src);
      if ( v6 == *(_DWORD *)(i + 76) && !I_stricmp(src, (char *)i) )
        break;
      ++v8;
    }
    v3 = v8;
  }
  return v3;
}
// 855A4E4: using guessed type int dword_855A4E4;
// 855D568: using guessed type int dword_855D568;
// 855D56C: using guessed type int dword_855D56C;

//----- (080D4832) --------------------------------------------------------
int __cdecl sub_80D4832(char *a1)
{
  int i; // [esp+1Ch] [ebp-Ch]
  int v3; // [esp+20h] [ebp-8h]
  int v4; // [esp+24h] [ebp-4h]

  v3 = sub_80D45C4((int)a1);
  v4 = 0;
  for ( i = dword_855A4E4; ; i += 96 )
  {
    if ( v4 >= *(_DWORD *)(dword_855A4E4 + 49152) )
      Com_Error(1, &byte_814B6C0, a1);
    if ( v3 == *(_DWORD *)(i + 76) && !I_stricmp(a1, (char *)i) )
      break;
    ++v4;
  }
  return i;
}
// 855A4E4: using guessed type int dword_855A4E4;

//----- (080D48C6) --------------------------------------------------------
signed int __cdecl sub_80D48C6(char *a1, int *a2, int a3)
{
  int *v5; // [esp+18h] [ebp-10h]
  int v6; // [esp+1Ch] [ebp-Ch]
  int v7; // [esp+20h] [ebp-8h]

  v6 = sub_80D45C4((int)a1);
  v7 = 0;
  v5 = a2;
  while ( *v5 )
  {
    if ( v5[1] == -1 )
      v5[1] = sub_80D45C4(*v5);
    if ( v6 == v5[1] && !I_stricmp(a1, (char *)*v5) )
      return v7;
    v5 += 2;
    ++v7;
  }
  if ( !a3 )
    sub_80D4624("BG_IndexForString: unknown token '%s'", a1);
  return -1;
}

//----- (080D4970) --------------------------------------------------------
char *__cdecl sub_80D4970(char *s, int a2, int a3, int a4)
{
  char *dest; // ST0C_4

  if ( *(_DWORD *)a4 + strlen(s) + 1 >= a3 )
    sub_80D4624("BG_CopyStringIntoBuffer: out of buffer space");
  dest = (char *)(a2 + *(_DWORD *)a4);
  strcpy((char *)(a2 + *(_DWORD *)a4), s);
  *(_DWORD *)a4 += strlen(s) + 1;
  return dest;
}

//----- (080D49D8) --------------------------------------------------------
int __cdecl sub_80D49D8(int a1, int a2)
{
  int result; // eax

  dword_8575C40[2 * a1] = a2;
  result = sub_80D45C4(a2);
  dword_8575C44[2 * a1] = result;
  return result;
}
// 8575C40: using guessed type int dword_8575C40[];

//----- (080D4A08) --------------------------------------------------------
int sub_80D4A08()
{
  memset(dword_8575C40, 0, 0x400u);
  return sub_80F04AE();
}
// 8575C40: using guessed type int dword_8575C40[];

//----- (080D4A32) --------------------------------------------------------
unsigned __int16 *__cdecl sub_80D4A32(unsigned int a1)
{
  unsigned __int16 *v3; // [esp+20h] [ebp-8h]
  int v4; // [esp+24h] [ebp-4h]

  if ( a1 >= *(_DWORD *)(dword_855A4E4 + 49152) )
    Com_Error(1, &byte_814B780, a1, *(_DWORD *)(dword_855A4E4 + 49152));
  v4 = 0;
  v3 = (unsigned __int16 *)dword_855D568;
  while ( v4 < *(_DWORD *)dword_855D56C )
  {
    if ( a1 == *v3 )
      return v3;
    ++v4;
    v3 += 36;
  }
  return 0;
}
// 855A4E4: using guessed type int dword_855A4E4;
// 855D568: using guessed type int dword_855D568;
// 855D56C: using guessed type int dword_855D56C;

//----- (080D4ABE) --------------------------------------------------------
void *__cdecl sub_80D4ABE(int a1)
{
  void *result; // eax
  int k; // [esp+0h] [ebp-14h]
  int i; // [esp+4h] [ebp-10h]
  signed int j; // [esp+4h] [ebp-10h]
  int v5; // [esp+Ch] [ebp-8h]
  signed int *v6; // [esp+10h] [ebp-4h]

  for ( i = 0; i < *(_DWORD *)(a1 + 49152); ++i )
    *(_DWORD *)(a1 + 96 * i + 92) = 0;
  result = dword_855A4E0;
  if ( !*((_DWORD *)dword_855A4E0 + 184058) )
  {
    v6 = (signed int *)(a1 + 231820);
    for ( j = 0; ; ++j )
    {
      result = (void *)j;
      if ( j >= *v6 )
        break;
      v5 = v6[j + 1];
      for ( k = 0; k < *(_DWORD *)(v5 + 112); ++k )
      {
        if ( *(_WORD *)(v5 + 16 * k + 116) )
          *(_DWORD *)(a1 + 96 * *(signed __int16 *)(v5 + 16 * k + 120) + 92) = 1;
        if ( *(_WORD *)(v5 + 16 * k + 118) )
          *(_DWORD *)(a1 + 96 * *(signed __int16 *)(v5 + 16 * k + 122) + 92) = 1;
      }
    }
  }
  return result;
}

//----- (080D4BC2) --------------------------------------------------------
void *sub_80D4BC2()
{
  char *v0; // eax
  char *v1; // eax
  char *v2; // ebx
  char *v3; // ebx
  float v5; // [esp+28h] [ebp-40h]
  unsigned __int16 *v6; // [esp+2Ch] [ebp-3Ch]
  int v7; // [esp+30h] [ebp-38h]
  int v8; // [esp+40h] [ebp-28h]
  int v9; // [esp+4Ch] [ebp-1Ch]
  char *dest; // [esp+50h] [ebp-18h]
  int v11; // [esp+54h] [ebp-14h]
  int v12; // [esp+58h] [ebp-10h]
  int v13; // [esp+5Ch] [ebp-Ch]

  v11 = dword_855A4E4;
  v9 = *(_DWORD *)(dword_855A4E4 + 736180);
  v12 = sub_80BEA18(v9);
  *(_DWORD *)(dword_855A4E4 + 49152) = v12;
  dest = (char *)v11;
  *(_DWORD *)(v11 + 80) |= 0x101u;
  I_strncpyz(dest, "root", 64);
  *((_DWORD *)dest + 19) = 0;
  dest += 96;
  v13 = 1;
  while ( v13 < v12 )
  {
    v6 = sub_80D4A32(v13);
    if ( v6 )
    {
      if ( (unsigned __int8)sub_80C00CA(v9, v13) )
      {
        v1 = (char *)sub_80BE908(v9, v13);
        I_strncpyz(dest, v1, 64);
        v2 = dest;
        *((_DWORD *)v2 + 19) = sub_80D45C4((int)dest);
        if ( !*((_DWORD *)dest + 16) )
          *((_DWORD *)dest + 16) = -1;
        v5 = sub_80BE760(v9, v13);
        if ( v5 == 0.0 )
        {
          *((_DWORD *)dest + 18) = 500;
          *((_DWORD *)dest + 17) = 0;
        }
        else
        {
          *((_DWORD *)dest + 18) = (signed int)(v5 * 1000.0);
          sub_80BF08C(v9, v13, (int)&v8, (int)&v7, 0.0, 1.0);
          v3 = dest;
          *((float *)v3 + 17) = sub_80D9E26(&v7) / v5;
          if ( *((_DWORD *)dest + 18) <= 499 )
            *((_DWORD *)dest + 18) = 500;
        }
        if ( (unsigned __int8)sub_80C040C(v9, v13) )
          *((_DWORD *)dest + 20) |= 0x80u;
      }
      else
      {
        *((_DWORD *)dest + 20) |= 1u;
        if ( v6 )
        {
          I_strncpyz(dest, (char *)v6 + 8, 64);
          *((_DWORD *)dest + 19) = *((_DWORD *)v6 + 1);
        }
        else
        {
          v0 = (char *)sub_80BE908(v9, v13);
          I_strncpyz(dest, v0, 64);
          *((_DWORD *)dest + 19) = 0;
        }
        if ( !*((_DWORD *)dest + 16) )
          *((_DWORD *)dest + 16) = -1;
        *((_DWORD *)dest + 18) = 0;
        *((_DWORD *)dest + 17) = 0;
      }
    }
    else
    {
      *((_DWORD *)dest + 20) |= 0x100u;
      I_strncpyz(dest, "unused", 64);
      *((_DWORD *)dest + 19) = 0;
    }
    ++v13;
    dest += 96;
  }
  sub_80D5B94(dword_855A4E4, 0, 0);
  return sub_80D4ABE(dword_855A4E4);
}
// 80D9E26: using guessed type double __cdecl sub_80D9E26(_DWORD);
// 855A4E4: using guessed type int dword_855A4E4;

//----- (080D4ED4) --------------------------------------------------------
void *__cdecl sub_80D4ED4(int a1, int a2, int a3, void *s)
{
  void *result; // eax
  int v5; // eax
  char *src; // [esp+18h] [ebp-60h]
  signed int v7; // [esp+1Ch] [ebp-5Ch]
  char v8; // [esp+20h] [ebp-58h]
  int v9; // [esp+60h] [ebp-18h]
  int v10; // [esp+64h] [ebp-14h]
  int v11; // [esp+68h] [ebp-10h]
  int v12; // [esp+6Ch] [ebp-Ch]

  v12 = 0;
  v7 = 0;
  v8 = 0;
  memset(s, 0, 4u);
  result = memset(&v9, 0, 8u);
  while ( !v12 )
  {
    src = sub_80B4848((char **)a1);
    if ( !src || !*src )
    {
      result = (void *)sub_80B3D92();
      v12 = 1;
      if ( !v8 )
        break;
    }
    if ( !I_stricmp(src, (char *)&unk_814B7C0) )
      v12 = 1;
    if ( I_stricmp(src, "none") )
    {
      if ( I_stricmp(src, "none,") )
      {
        if ( !I_stricmp(src, "NOT") )
          src = "MINUS";
        if ( !v12 && I_stricmp(src, "AND") && I_stricmp(src, "MINUS") )
        {
          if ( src[strlen(src) - 1] == 44 )
          {
            v12 = 1;
            src[strlen(src) - 1] = 0;
          }
          if ( v8 )
            sub_80B57C0(&v8, 64, " ");
          sub_80B57C0(&v8, 64, src);
        }
        if ( !I_stricmp(src, "AND") || (result = (void *)I_stricmp(src, "MINUS")) == 0 || v12 )
        {
          if ( v8 )
          {
            if ( I_stricmp(&v8, "all") )
            {
              v11 = sub_80D48C6(&v8, (int *)((a3 << 7) + 139840608), 1);
              if ( v11 < 0 )
              {
                v11 = sub_80D48C6(&v8, (int *)a2, 0);
                sub_80D9EAA((int)&v9, v11);
              }
              else
              {
                v9 = dword_855D0E0[2 * (v11 + 16 * a3)];
                v10 = dword_855D0E4[2 * (v11 + 16 * a3)];
              }
            }
            else
            {
              v9 = -1;
              v10 = -1;
            }
            if ( v7 )
            {
              *(_DWORD *)s &= ~v9;
              v5 = *((_DWORD *)s + 1) & ~v10;
            }
            else
            {
              *(_DWORD *)s |= v9;
              v5 = *((_DWORD *)s + 1) | v10;
            }
            *((_DWORD *)s + 1) = v5;
            v8 = 0;
            result = (void *)I_stricmp(src, "MINUS");
            if ( !result )
              v7 = 1;
          }
          else
          {
            if ( v12 )
              sub_80D4624("BG_ParseConditionBits: unexpected end of condition");
            result = (void *)I_stricmp(src, "MINUS");
            if ( result )
              sub_80D4624("BG_ParseConditionBits: unexpected '%s'", src);
            v7 = 1;
          }
        }
      }
      else
      {
        result = (void *)sub_80D9EAA((int)s, 0);
        v12 = 1;
      }
    }
    else
    {
      result = (void *)sub_80D9EAA((int)s, 0);
    }
  }
  return result;
}
// 855D0E0: using guessed type int dword_855D0E0[];

//----- (080D5250) --------------------------------------------------------
signed int __cdecl sub_80D5250(char **a1, _DWORD *a2)
{
  int v3; // [esp+1Ch] [ebp-1Ch]
  char *v4; // [esp+24h] [ebp-14h]
  char *v5; // [esp+24h] [ebp-14h]
  int s; // [esp+28h] [ebp-10h]
  int v7; // [esp+2Ch] [ebp-Ch]
  int v8; // [esp+34h] [ebp-4h]

  memset(&s, 0, 8u);
  while ( 1 )
  {
    v4 = sub_80B4848(a1);
    if ( !v4 || !*v4 )
      break;
    if ( !I_stricmp(v4, "default") )
      return 1;
    v8 = sub_80D48C6(v4, (int *)&off_8164760, 0);
    v3 = dword_81647C0[2 * v8];
    if ( v3 )
    {
      if ( v3 == 1 )
      {
        if ( off_81647C4[2 * v8] )
        {
          v5 = sub_80B4848(a1);
          if ( !v5 || !*v5 )
            sub_80D4624("BG_ParseConditions: expected condition value, found end of line");
          if ( v5[strlen(v5) - 1] == 44 )
            v5[strlen(v5) - 1] = 0;
          s = sub_80D48C6(v5, (int *)off_81647C4[2 * v8], 0);
        }
        else
        {
          s = 1;
        }
      }
    }
    else
    {
      sub_80D4ED4((int)a1, off_81647C4[2 * v8], v8, &s);
    }
    a2[3 * *a2 + 1] = v8;
    a2[3 * *a2 + 2] = s;
    a2[3 * (*a2)++ + 3] = v7;
  }
  if ( !*a2 )
    sub_80D4624("BG_ParseConditions: no conditions found");
  return 1;
}
// 8164760: using guessed type char *off_8164760;
// 81647C0: using guessed type int dword_81647C0[];

//----- (080D5424) --------------------------------------------------------
size_t __cdecl sub_80D5424(char **a1, _DWORD *a2, int a3)
{
  size_t result; // eax
  int v4; // esi
  int v5; // ebx
  signed int v6; // edx
  signed int v7; // eax
  int *v8; // ebx
  int v9; // edx
  char *v10; // [esp+18h] [ebp-20h]
  signed int v11; // [esp+1Ch] [ebp-1Ch]
  int i; // [esp+20h] [ebp-18h]
  int v13; // [esp+24h] [ebp-14h]
  _DWORD *v14; // [esp+28h] [ebp-10h]
  char *s; // [esp+2Ch] [ebp-Ch]
  char *sa; // [esp+2Ch] [ebp-Ch]
  char *sb; // [esp+2Ch] [ebp-Ch]
  char *sc; // [esp+2Ch] [ebp-Ch]
  char *sd; // [esp+2Ch] [ebp-Ch]
  char *se; // [esp+2Ch] [ebp-Ch]

  v14 = 0;
  v13 = 0;
  while ( 1 )
  {
    v10 = v13 > 0 ? sub_80B4848(a1) : Com_Parse(a1);
    result = (size_t)v10;
    if ( !v10 )
      return result;
    result = (size_t)v10;
    if ( !*v10 )
      return result;
    if ( !I_stricmp(v10, "}") )
    {
      result = (size_t)&(*a1)[-strlen(v10)];
      *a1 = (char *)result;
      return result;
    }
    if ( !v13 )
    {
      if ( a2[28] > 7 )
        sub_80D4624("BG_ParseCommands: exceeded maximum number of animations (%i)", 8);
      v14 = &a2[4 * a2[28]++ + 29];
      memset(v14, 0, 4u);
    }
    *((_WORD *)v14 + v13) = sub_80D48C6(v10, (int *)&off_8164620, 1);
    if ( *((_WORD *)v14 + v13) <= 0 )
    {
      *a1 -= strlen(v10);
      goto LABEL_68;
    }
    s = sub_80B4848(a1);
    if ( !s || !*s )
      sub_80D4624("BG_ParseCommands: expected animation");
    *((_WORD *)v14 + v13 + 2) = sub_80D46AC(s);
    *((_WORD *)v14 + v13 + 4) = *(_WORD *)(a3 + 96 * *((signed __int16 *)v14 + v13 + 2) + 72);
    if ( !dword_855D568 )
    {
      if ( dword_855D560 && *((_WORD *)v14 + v13) != 2 )
      {
        v4 = a3 + 96 * *((signed __int16 *)v14 + v13 + 2) + 80;
        v5 = a3 + 96 * *((signed __int16 *)v14 + v13 + 2) + 80;
        v6 = (unsigned __int64)(1LL << dword_855D560) >> 32;
        v7 = 1 << dword_855D560;
        if ( dword_855D560 & 0x20 )
        {
          v6 = 1 << dword_855D560;
          v7 = 0;
        }
        *(_DWORD *)(a3 + 96 * *((signed __int16 *)v14 + v13 + 2) + 84) |= v7;
        *(_DWORD *)(v4 + 8) = v6 | *(_DWORD *)(v5 + 8);
        if ( (dword_855D560 == 18 || dword_855D560 == 19)
          && *(float *)(a3 + 96 * *((signed __int16 *)v14 + v13 + 2) + 68) != 0.0 )
        {
          *(_DWORD *)(a3 + 96 * *((signed __int16 *)v14 + v13 + 2) + 80) |= 2u;
        }
        for ( i = 0; i < *a2; ++i )
        {
          if ( a2[3 * i + 1] == 8 )
          {
            if ( a2[3 * i + 2] == 1 )
            {
              *(_DWORD *)(a3 + 96 * *((signed __int16 *)v14 + v13 + 2) + 80) |= 0x10u;
            }
            else if ( a2[3 * i + 2] == 2 )
            {
              *(_DWORD *)(a3 + 96 * *((signed __int16 *)v14 + v13 + 2) + 80) |= 0x20u;
            }
            break;
          }
        }
      }
      switch ( dword_855D564 )
      {
        case 2:
          *(_DWORD *)(a3 + 96 * *((signed __int16 *)v14 + v13 + 2) + 80) |= 8u;
          *(_DWORD *)(a3 + 96 * *((signed __int16 *)v14 + v13 + 2) + 64) = 30;
          break;
        case 1:
          *(_DWORD *)(a3 + 96 * *((signed __int16 *)v14 + v13 + 2) + 68) = 0;
          *(_DWORD *)(a3 + 96 * *((signed __int16 *)v14 + v13 + 2) + 80) |= 0x40u;
          break;
        case 10:
          *(_DWORD *)(a3 + 96 * *((signed __int16 *)v14 + v13 + 2) + 68) = 0;
          break;
        default:
          if ( dword_855D560 > 20 && dword_855D560 <= 30 )
            *(_DWORD *)(a3 + 96 * *((signed __int16 *)v14 + v13 + 2) + 68) = 0;
          break;
      }
    }
    do
    {
      v11 = 0;
      sa = sub_80B4848(a1);
      if ( sa && *sa )
      {
        if ( I_stricmp(sa, "duration") )
        {
          if ( I_stricmp(sa, "turretanim") )
          {
            if ( I_stricmp(sa, "blendtime") )
            {
              sub_80B3D92();
            }
            else
            {
              v11 = 1;
              sc = sub_80B4848(a1);
              if ( !sc || !*sc )
                sub_80D4624("BG_ParseCommands: expected blendtime value");
              if ( !dword_855D568 )
              {
                v8 = (int *)(a3 + 96 * *((signed __int16 *)v14 + v13 + 2) + 64);
                *v8 = atoi(sc);
              }
            }
          }
          else
          {
            v11 = 1;
            if ( !dword_855D568 )
              *(_DWORD *)(a3 + 96 * *((signed __int16 *)v14 + v13 + 2) + 80) |= 4u;
            if ( *((_WORD *)v14 + v13) != 3 )
              sub_80D4624("BG_ParseCommands: Turret animations can only be played on the 'both' body part");
          }
        }
        else
        {
          v11 = 1;
          sb = sub_80B4848(a1);
          if ( !sb || !*sb )
            sub_80D4624("BG_ParseCommands: expected duration value");
          *((_WORD *)v14 + v13 + 4) = atoi(sb);
        }
      }
      else
      {
        sub_80B3D92();
      }
    }
    while ( v11 );
    if ( *((_WORD *)v14 + v13) != 3 )
    {
      v9 = v13++;
      if ( v9 <= 0 )
        continue;
    }
LABEL_68:
    while ( 1 )
    {
      sd = sub_80B4848(a1);
      if ( !sd || !*sd )
        break;
      if ( I_stricmp(sd, "sound") )
        sub_80D4624("BG_ParseCommands: unknown parameter '%s'", sd);
      se = sub_80B4848(a1);
      if ( !se || !*se )
        sub_80D4624("BG_ParseCommands: expected sound");
      if ( strstr(se, ".wav") )
        sub_80D4624("BG_ParseCommands: wav files not supported, only sound scripts");
      v14[3] = (*(int (__cdecl **)(char *))(dword_855A4E4 + 736192))(se);
    }
    v13 = 0;
  }
}
// 8164620: using guessed type char *off_8164620;
// 855A4E4: using guessed type int dword_855A4E4;
// 855D560: using guessed type int dword_855D560;
// 855D564: using guessed type int dword_855D564;
// 855D568: using guessed type int dword_855D568;

//----- (080D5B94) --------------------------------------------------------
_DWORD *__cdecl sub_80D5B94(int a1, int a2, int a3)
{
  int v3; // ebx
  int v4; // ebx
  int v5; // ebx
  int v6; // ebx
  size_t v7; // eax
  int v8; // eax
  int v9; // ebx
  size_t v10; // eax
  int v11; // eax
  int v12; // ebx
  int v13; // ebx
  size_t v14; // eax
  int v15; // eax
  int v16; // ebx
  size_t v17; // eax
  int v18; // eax
  unsigned int v20; // [esp+14h] [ebp-164h]
  int v21; // [esp+18h] [ebp-160h]
  int v22; // [esp+1Ch] [ebp-15Ch]
  int i; // [esp+20h] [ebp-158h]
  int v24; // [esp+24h] [ebp-154h]
  int v25; // [esp+28h] [ebp-150h]
  int v26; // [esp+2Ch] [ebp-14Ch]
  int v27; // [esp+30h] [ebp-148h]
  int v28; // [esp+34h] [ebp-144h]
  int v29; // [esp+38h] [ebp-140h]
  _DWORD *v30; // [esp+4Ch] [ebp-12Ch]
  char v31; // [esp+50h] [ebp-128h]
  void *s; // [esp+150h] [ebp-28h]
  int v33; // [esp+154h] [ebp-24h]
  char *v34; // [esp+158h] [ebp-20h]
  int v35; // [esp+15Ch] [ebp-1Ch]

  v30 = 0;
  if ( !dword_8575C20 )
  {
    v20 = FS_FOpenFileByMode(*(char **)off_81643C0, (int)&v21, 0);
    if ( (v20 & 0x80000000) != 0 )
      Com_Error(1, &byte_814BB40, *(_DWORD *)off_81643C0);
    if ( v20 > 0x1869E )
      Com_Error(1, &byte_814BB40, *(_DWORD *)off_81643C0);
    FS_Read((int)&unk_855D580, v20, v21);
    *(_BYTE *)(v20 + 139842944) = 0;
    FS_FCloseFile(v21);
    dword_8575C20 = 1;
  }
  dword_855A4E4 = a1;
  dword_855D568 = a2;
  dword_855D56C = a3;
  v33 = 0;
  sub_80D4A08();
  memset(dword_855CC60, 0, 0x480u);
  memset(&unk_855A540, 0, 0x2710u);
  memset(dword_855A500, 0, 0x24u);
  dword_855CC50 = 0;
  for ( i = 0; i <= 2; ++i )
    *(&v27 + i) = -1;
  v26 = 0;
  s = 0;
  v35 = (int)&unk_855D580;
  sub_80B396A("BG_AnimParseAnimScript");
  while ( 1 )
  {
    v34 = Com_Parse((char **)&v35);
    if ( !v34 || !*v34 )
      break;
    v24 = sub_80D48C6(v34, (int *)&off_8164820, 1);
    if ( v24 < 0 )
    {
      switch ( v33 )
      {
        case 0:
          if ( !I_stricmp(v34, "set") )
          {
            v34 = sub_80B4848((char **)&v35);
            if ( !v34 || !*v34 )
              sub_80D4624("BG_AnimParseAnimScript: expected condition type string");
            v22 = sub_80D48C6(v34, (int *)&off_8164760, 0);
            if ( dword_81647C0[2 * v22] )
              sub_80D4624("BG_AnimParseAnimScript: can not make a define of type '%s'", v34);
            v34 = sub_80B4848((char **)&v35);
            if ( !v34 || !*v34 )
              sub_80D4624("BG_AnimParseAnimScript: expected condition define string");
            v3 = dword_855A500[v22] + 16 * v22;
            dword_855CC60[2 * v3] = (int)sub_80D4970(v34, (int)&unk_855A540, 10000, (int)&dword_855CC50);
            v4 = dword_855A500[v22] + 16 * v22;
            dword_855CC64[2 * v4] = sub_80D45C4(dword_855CC60[2 * v4]);
            v34 = sub_80B4848((char **)&v35);
            if ( !v34 )
              sub_80D4624("BG_AnimParseAnimScript: expected '=', found end of line");
            if ( I_stricmp(v34, "=") )
              sub_80D4624("BG_AnimParseAnimScript: expected '=', found '%s'", v34);
            sub_80D4ED4((int)&v35, off_81647C4[2 * v22], v22, (void *)(8 * (dword_855A500[v22] + 16 * v22) + 139841760));
            ++dword_855A500[v22];
          }
          break;
        case 1:
        case 2:
          if ( I_stricmp(v34, "{") )
          {
            if ( I_stricmp(v34, "}") )
            {
              if ( v26 || v27 >= 0 )
              {
                if ( v26 != 1 || v28 >= 0 )
                {
                  if ( v26 != 2 || v29 >= 0 )
                  {
                    if ( v26 != 3 )
                      sub_80D4624("BG_AnimParseAnimScript: unexpected '%s'", v34);
                    v10 = strlen(v34);
                    v35 -= v10;
                    v11 = strlen(v34);
                    if ( I_strncmp((char *)v35, v34, v11) )
                      sub_80D4624("BG_AnimParseAnimScript: internal error");
                    sub_80D5424((char **)&v35, v30, a1);
                  }
                  else
                  {
                    v7 = strlen(v34);
                    v35 -= v7;
                    v8 = strlen(v34);
                    if ( I_strncmp((char *)v35, v34, v8) )
                      sub_80D4624("BG_AnimParseAnimScript: internal error");
                    memset(&v31, 0, 0xF4u);
                    v9 = v26;
                    *(&v27 + v9) = sub_80D5250((char **)&v35, &v31);
                    if ( *(_DWORD *)s > 127 )
                      sub_80D4624("BG_AnimParseAnimScript: exceeded maximum items per script (%i)", 128);
                    if ( *(_DWORD *)(a1 + 736176) > 2047 )
                      sub_80D4624("BG_AnimParseAnimScript: exceeded maximum global items (%i)", 2048);
                    *((_DWORD *)s + *(_DWORD *)s + 1) = a1 + 244 * (*(_DWORD *)(a1 + 736176))++ + 236464;
                    v30 = (_DWORD *)*((_DWORD *)s + (*(_DWORD *)s)++ + 1);
                    qmemcpy(v30, &v31, 0xF4u);
                  }
                }
                else
                {
                  v6 = v26;
                  *(&v27 + v6) = sub_80D48C6(v34, (int *)&off_8164420, 0);
                  if ( v33 == 1 )
                  {
                    s = (void *)(516 * v28 + a1 + 21156 * v27 + 49156);
                    dword_855D560 = v28;
                  }
                  else if ( v33 == 2 )
                  {
                    s = (void *)(516 * v28 + a1 + 21156 * v27 + 133780);
                  }
                  memset(s, 0, 0x204u);
                }
              }
              else
              {
                if ( I_stricmp(v34, "state") )
                  sub_80D4624("BG_AnimParseAnimScript: expected 'state'");
                v34 = sub_80B4848((char **)&v35);
                if ( !v34 )
                  sub_80D4624("BG_AnimParseAnimScript: expected state type");
                v5 = v26;
                *(&v27 + v5) = sub_80D48C6(v34, (int *)&off_81643E0, 0);
                v34 = Com_Parse((char **)&v35);
                if ( !v34 || I_stricmp(v34, "{") )
                  sub_80D4624("BG_AnimParseAnimScript: expected '{'");
                ++v26;
              }
            }
            else
            {
              if ( --v26 < 0 )
                sub_80D4624("BG_AnimParseAnimScript: unexpected '%s'", v34);
              if ( v26 == 1 )
                s = 0;
              *(&v27 + v26) = -1;
            }
          }
          else
          {
            if ( v26 > 2 )
              sub_80D4624("BG_AnimParseAnimScript: unexpected '%s'", v34);
            if ( *(&v27 + v26) < 0 )
              sub_80D4624("BG_AnimParseAnimScript: unexpected '%s'", v34);
            ++v26;
          }
          break;
        case 3:
        case 4:
          if ( I_stricmp(v34, "{") )
          {
            if ( I_stricmp(v34, "}") )
            {
              if ( v26 || v27 >= 0 )
              {
                if ( v26 != 1 || v28 >= 0 )
                {
                  if ( v26 != 2 )
                    sub_80D4624("BG_AnimParseAnimScript: unexpected '%s'", v34);
                  v17 = strlen(v34);
                  v35 -= v17;
                  v18 = strlen(v34);
                  if ( I_strncmp((char *)v35, v34, v18) )
                    sub_80D4624("BG_AnimParseAnimScript: internal error");
                  sub_80D5424((char **)&v35, v30, a1);
                }
                else
                {
                  v14 = strlen(v34);
                  v35 -= v14;
                  v15 = strlen(v34);
                  if ( I_strncmp((char *)v35, v34, v15) )
                    sub_80D4624("BG_AnimParseAnimScript: internal error");
                  memset(&v31, 0, 0xF4u);
                  v16 = v26;
                  *(&v27 + v16) = sub_80D5250((char **)&v35, &v31);
                  if ( *(_DWORD *)s > 127 )
                    sub_80D4624("BG_AnimParseAnimScript: exceeded maximum items per script (%i)", 128);
                  if ( *(_DWORD *)(a1 + 736176) > 2047 )
                    sub_80D4624("BG_AnimParseAnimScript: exceeded maximum global items (%i)", 2048);
                  *((_DWORD *)s + *(_DWORD *)s + 1) = a1 + 244 * (*(_DWORD *)(a1 + 736176))++ + 236464;
                  v30 = (_DWORD *)*((_DWORD *)s + (*(_DWORD *)s)++ + 1);
                  qmemcpy(v30, &v31, 0xF4u);
                }
              }
              else
              {
                if ( v33 == 3 )
                {
                  if ( I_stricmp(v34, "statechange") )
                    sub_80D4624("BG_AnimParseAnimScript: expected 'statechange', got '%s'", v34);
                  v34 = sub_80B4848((char **)&v35);
                  if ( !v34 )
                    sub_80D4624("BG_AnimParseAnimScript: expected <state type>");
                  v25 = sub_80D48C6(v34, (int *)&off_81643E0, 0);
                  v34 = sub_80B4848((char **)&v35);
                  if ( !v34 )
                    sub_80D4624("BG_AnimParseAnimScript: expected <state type>");
                  v12 = v26;
                  *(&v27 + v12) = sub_80D48C6(v34, (int *)&off_81643E0, 0);
                  s = (void *)(516 * *(&v27 + v26) + a1 + 2064 * v25 + 218404);
                  v34 = Com_Parse((char **)&v35);
                  if ( !v34 || I_stricmp(v34, "{") )
                    sub_80D4624("BG_AnimParseAnimScript: expected '{'");
                  ++v26;
                }
                else
                {
                  v13 = v26;
                  *(&v27 + v13) = sub_80D48C6(v34, (int *)&off_8164580, 0);
                  s = (void *)(a1 + 516 * v27 + 226660);
                  dword_855D564 = *(&v27 + v26);
                }
                memset(s, 0, 0x204u);
              }
            }
            else
            {
              if ( --v26 < 0 )
                sub_80D4624("BG_AnimParseAnimScript: unexpected '%s'", v34);
              if ( !v26 )
                s = 0;
              *(&v27 + v26) = -1;
            }
          }
          else
          {
            if ( v26 > 2 )
              sub_80D4624("BG_AnimParseAnimScript: unexpected '%s'", v34);
            if ( *(&v27 + v26) < 0 )
              sub_80D4624("BG_AnimParseAnimScript: unexpected '%s'", v34);
            ++v26;
          }
          break;
      }
    }
    else
    {
      if ( v26 )
        sub_80D4624("BG_AnimParseAnimScript: unexpected '%s'", v34);
      v33 = v24;
      dword_855D560 = 0;
      dword_855D564 = -1;
    }
  }
  if ( v26 )
    sub_80D4624("BG_AnimParseAnimScript: unexpected end of file: %s");
  *(_DWORD *)off_81643C0 = 0;
  return sub_80B3A3C();
}
// 81643E0: using guessed type char *off_81643E0;
// 8164420: using guessed type char *off_8164420;
// 8164580: using guessed type char *off_8164580;
// 8164760: using guessed type char *off_8164760;
// 81647C0: using guessed type int dword_81647C0[];
// 8164820: using guessed type char *off_8164820;
// 855A4E4: using guessed type int dword_855A4E4;
// 855A500: using guessed type int dword_855A500[];
// 855CC50: using guessed type int dword_855CC50;
// 855CC60: using guessed type int dword_855CC60[];
// 855D560: using guessed type int dword_855D560;
// 855D564: using guessed type int dword_855D564;
// 855D568: using guessed type int dword_855D568;
// 855D56C: using guessed type int dword_855D56C;
// 8575C20: using guessed type int dword_8575C20;

//----- (080D688A) --------------------------------------------------------
signed int __cdecl sub_80D688A(int a1, _DWORD *a2)
{
  int v3; // [esp+0h] [ebp-10h]
  _DWORD *v5; // [esp+8h] [ebp-8h]
  int v6; // [esp+Ch] [ebp-4h]

  v6 = 0;
  v5 = a2 + 1;
  while ( v6 < *a2 )
  {
    v3 = dword_81647C0[2 * *v5];
    if ( v3 )
    {
      if ( v3 == 1 && *(_DWORD *)(a1 + 8 * *v5 + 1116) != v5[1] )
        return 0;
    }
    else if ( !(*(_DWORD *)(a1 + 8 * *v5 + 1116) & v5[1]) && !(*(_DWORD *)(a1 + 8 * *v5 + 1120) & v5[2]) )
    {
      return 0;
    }
    ++v6;
    v5 += 3;
  }
  return 1;
}
// 81647C0: using guessed type int dword_81647C0[];

//----- (080D6944) --------------------------------------------------------
_DWORD *__cdecl sub_80D6944(int a1, _DWORD *a2)
{
  int v4; // [esp+10h] [ebp-8h]
  _DWORD **v5; // [esp+14h] [ebp-4h]

  v4 = 0;
  v5 = (_DWORD **)(a2 + 1);
  while ( v4 < *a2 )
  {
    if ( sub_80D688A((int)dword_855A4E0 + 1208 * a1 + 736252, *v5) )
      return *v5;
    ++v4;
    ++v5;
  }
  return 0;
}

//----- (080D69B2) --------------------------------------------------------
signed int __cdecl sub_80D69B2(_DWORD *a1, int a2, signed int a3, int a4, int a5, int a6, int a7)
{
  signed int v8; // [esp+4h] [ebp-Ch]
  signed int v9; // [esp+8h] [ebp-8h]
  int v10; // [esp+Ch] [ebp-4h]

  v9 = 0;
  if ( a4 )
    v10 = a4;
  else
    v10 = *(_DWORD *)(dword_855A4E4 + 96 * a2 + 72) + 50;
  if ( a3 == 2 )
  {
LABEL_20:
    if ( a1[32] <= 49 || a7 )
    {
      if ( a6 && (a1[33] & 0xFFFFFDFF) == a2 )
      {
        if ( a5 && *(_BYTE *)(dword_855A4E4 + 96 * a2 + 80) & 0x80 )
          a1[32] = v10;
      }
      else
      {
        a1[33] = a2 | a1[33] & 0x200 ^ 0x200;
        if ( a5 )
          a1[32] = v10;
        a1[35] = v10;
      }
    }
    goto LABEL_30;
  }
  if ( a3 > 2 )
  {
    if ( a3 != 3 )
      goto LABEL_30;
  }
  else if ( a3 != 1 )
  {
    goto LABEL_30;
  }
  if ( a1[30] <= 49 || a7 )
  {
    if ( a6 && (a1[31] & 0xFFFFFDFF) == a2 )
    {
      if ( a5 && *(_BYTE *)(dword_855A4E4 + 96 * a2 + 80) & 0x80 )
        a1[30] = v10;
    }
    else
    {
      v9 = 1;
      a1[34] = v10;
      a1[31] = a2 | a1[31] & 0x200 ^ 0x200;
      if ( a5 )
        a1[30] = v10;
    }
  }
  if ( a3 == 3 )
  {
    a2 = 0;
    goto LABEL_20;
  }
LABEL_30:
  if ( v9 )
    v8 = v10;
  else
    v8 = -1;
  return v8;
}
// 855A4E4: using guessed type int dword_855A4E4;

//----- (080D6B7C) --------------------------------------------------------
int __cdecl sub_80D6B7C(int a1, char *src, int a3, int a4, int a5, int a6)
{
  int v6; // eax

  v6 = sub_80D46AC(src);
  return sub_80D69B2((_DWORD *)a1, v6, a3, 0, a4, a5, a6);
}

//----- (080D6BC4) --------------------------------------------------------
signed int __cdecl sub_80D6BC4(_DWORD *a1, signed __int16 *a2, int a3, int a4, int a5)
{
  signed int v6; // [esp+1Ch] [ebp-Ch]
  _BOOL4 v7; // [esp+20h] [ebp-8h]
  int v8; // [esp+24h] [ebp-4h]

  v8 = -1;
  v7 = 0;
  if ( *a2 )
  {
    v8 = a2[4] + 50;
    if ( *a2 != 1 && *a2 != 3 )
      sub_80D69B2(a1, a2[2], *a2, v8, a3, a4, a5);
    else
      v7 = sub_80D69B2(a1, a2[2], *a2, v8, a3, a4, a5) >= 0;
  }
  if ( a2[1] )
  {
    v8 = a2[4] + 50;
    if ( *a2 != 1 && *a2 != 3 )
      sub_80D69B2(a1, a2[3], a2[1], v8, a3, a4, a5);
    else
      v7 = sub_80D69B2(a1, a2[3], a2[1], v8, a3, a4, a5) >= 0;
  }
  if ( *((_DWORD *)a2 + 3) )
    (*(void (__cdecl **)(_DWORD, _DWORD))(dword_855A4E4 + 736196))(a1[51], *((_DWORD *)a2 + 3));
  if ( v7 )
    v6 = v8;
  else
    v6 = -1;
  return v6;
}
// 855A4E4: using guessed type int dword_855A4E4;

//----- (080D6D82) --------------------------------------------------------
signed int __cdecl sub_80D6D82(_DWORD *a1, int a2, int a3, int a4)
{
  _DWORD *v6; // [esp+30h] [ebp-8h]
  _DWORD *v7; // [esp+34h] [ebp-4h]

  v6 = 0;
  if ( a1[1] > 5 )
    return -1;
  while ( !v6 && a2 >= 0 )
  {
    v7 = (_DWORD *)(516 * a3 + dword_855A4E4 + 21156 * a2 + 49156);
    if ( *v7 )
    {
      v6 = sub_80D6944(a1[51], v7);
      if ( !v6 )
        --a2;
    }
    else
    {
      --a2;
    }
  }
  if ( !v6 )
    return -1;
  if ( !v6[28] )
    return -1;
  sub_80D70E2(a1[51], 3, a3, 1);
  return sub_80D6BC4(a1, (signed __int16 *)&v6[4 * (a1[51] % v6[28]) + 29], 0, a4, 0) != -1;
}
// 855A4E4: using guessed type int dword_855A4E4;

//----- (080D6EDC) --------------------------------------------------------
signed int __cdecl sub_80D6EDC(_DWORD *a1, int a2, int a3)
{
  int v3; // eax
  _DWORD *v6; // [esp+20h] [ebp-8h]
  _DWORD *v7; // [esp+24h] [ebp-4h]

  if ( a1[1] > 5 )
    return -1;
  v7 = (_DWORD *)(516 * a2 + dword_855A4E4 + 2064 * a3 + 218404);
  if ( !*v7 )
    return -1;
  v6 = sub_80D6944(a1[51], v7);
  if ( !v6 )
    return -1;
  if ( !v6[28] )
    return -1;
  v3 = rand();
  return sub_80D6BC4(a1, (signed __int16 *)&v6[4 * (v3 % v6[28]) + 29], 1, 0, 0);
}
// 855A4E4: using guessed type int dword_855A4E4;

//----- (080D6FCA) --------------------------------------------------------
signed int __cdecl sub_80D6FCA(_DWORD *a1, int a2, int a3, int a4)
{
  int v4; // eax
  _DWORD *v7; // [esp+20h] [ebp-8h]

  if ( a2 != 1 && a1[1] > 5 )
    return -1;
  if ( !*(_DWORD *)(dword_855A4E4 + 516 * a2 + 226660) )
    return -1;
  v7 = sub_80D6944(a1[51], (_DWORD *)(dword_855A4E4 + 516 * a2 + 226660));
  if ( !v7 )
    return -1;
  if ( !v7[28] )
    return -1;
  v4 = rand();
  return sub_80D6BC4(a1, (signed __int16 *)&v7[4 * (v4 % v7[28]) + 29], 1, a3, a4);
}
// 855A4E4: using guessed type int dword_855A4E4;

//----- (080D70AA) --------------------------------------------------------
int __cdecl sub_80D70AA(int a1, unsigned int a2)
{
  if ( a2 >= *(_DWORD *)(dword_855A4E4 + 49152) )
    sub_80D4624("BG_GetAnimString: anim index is out of range");
  return dword_855A4E4 + 96 * a2;
}
// 855A4E4: using guessed type int dword_855A4E4;

//----- (080D70E2) --------------------------------------------------------
int __cdecl sub_80D70E2(int a1, int a2, int a3, int a4)
{
  int result; // eax

  if ( !a4 || dword_81647C0[2 * a2] )
  {
    result = a3;
    *((_DWORD *)dword_855A4E0 + 2 * (a2 + 151 * a1) + 184342) = a3;
  }
  else
  {
    *((_DWORD *)dword_855A4E0 + 2 * (a2 + 151 * a1) + 184342) = 0;
    *((_DWORD *)dword_855A4E0 + 2 * (a2 + 151 * a1) + 184343) = 0;
    result = sub_80D9EAA((int)dword_855A4E0 + 8 * (a2 + 151 * a1) + 737368, a3);
  }
  return result;
}
// 81647C0: using guessed type int dword_81647C0[];

//----- (080D7180) --------------------------------------------------------
unsigned int __cdecl sub_80D7180(int a1, int a2, int a3)
{
  unsigned int i; // [esp+10h] [ebp-8h]

  if ( !a3 || dword_81647C0[2 * a2] )
    return *(_DWORD *)(a1 + 8 * a2 + 1116);
  for ( i = 0; i <= 0x3F; ++i )
  {
    if ( (unsigned __int8)sub_80D9E84(a1 + 8 * a2 + 1116, i) )
      return i;
  }
  return 0;
}
// 81647C0: using guessed type int dword_81647C0[];

//----- (080D72B8) --------------------------------------------------------
int __cdecl sub_80D72B8(int a1, unsigned int a2)
{
  if ( a2 >= *(_DWORD *)(dword_855A4E4 + 49152) )
    Com_Error(1, &byte_814BFE0);
  return dword_855A4E4 + 96 * a2;
}
// 855A4E4: using guessed type int dword_855A4E4;

//----- (080D72F8) --------------------------------------------------------
int __cdecl sub_80D72F8(float **a1)
{
  int v1; // eax
  int v2; // ST10_4
  int result; // eax
  float *v4; // [esp+14h] [ebp-4h]

  v4 = *a1;
  v1 = sub_80E95EE(*a1);
  v2 = sub_80E9270(v1);
  sub_80D70E2(*((_DWORD *)v4 + 51), 0, *(_DWORD *)(v2 + 116), 1);
  sub_80D70E2(*((_DWORD *)v4 + 51), 1, *(_DWORD *)(v2 + 124), 1);
  if ( (_DWORD)v4[40] & 0x40000 )
    sub_80D70E2(*((_DWORD *)v4 + 51), 7, 1, 1);
  else
    sub_80D70E2(*((_DWORD *)v4 + 51), 7, 0, 1);
  if ( (_DWORD)v4[40] & 0x300 )
    sub_80D70E2(*((_DWORD *)v4 + 51), 2, 1, 1);
  else
    sub_80D70E2(*((_DWORD *)v4 + 51), 2, 0, 1);
  sub_80D70E2(*((_DWORD *)v4 + 51), 4, v4[58] > 0.0, 1);
  if ( (_BYTE)a1[2] & 1 )
    result = sub_80D70E2(*((_DWORD *)v4 + 51), 6, 1, 1);
  else
    result = sub_80D70E2(*((_DWORD *)v4 + 51), 6, 0, 1);
  return result;
}

//----- (080D74DE) --------------------------------------------------------
_BOOL4 __cdecl sub_80D74DE(int a1, int a2)
{
  int v2; // ST14_4

  v2 = sub_80D72B8(*(_DWORD *)(a1 + 8), a2 & 0xFFFFFDFF);
  return (*(_DWORD *)(v2 + 88) & 0x180 | *(_DWORD *)(v2 + 84) & 0xC4) != 0;
}

//----- (080D7534) --------------------------------------------------------
_BOOL4 __cdecl sub_80D7534(int a1, int a2)
{
  int v2; // eax
  int v3; // et1

  v2 = sub_80D72B8(*(_DWORD *)(a1 + 8), a2 & 0xFFFFFDFF);
  v3 = *(_DWORD *)(v2 + 88);
  return (*(_DWORD *)(v2 + 84) & 0x308) != 0;
}

//----- (080D7588) --------------------------------------------------------
_BOOL4 __cdecl sub_80D7588(int a1, int a2)
{
  int v2; // eax
  int v3; // et1

  v2 = sub_80D72B8(*(_DWORD *)(a1 + 8), a2 & 0xFFFFFDFF);
  v3 = *(_DWORD *)(v2 + 88);
  return (*(_DWORD *)(v2 + 84) & 0x7FF00000) != 0;
}

//----- (080D75DC) --------------------------------------------------------
void __cdecl sub_80D75DC(signed int *a1, signed int *a2, int a3, int a4)
{
  _BOOL4 v4; // ebx
  _BOOL4 v5; // ebx
  float v6; // ST0C_4
  int v7; // ST10_4
  int v8; // ST10_4
  int v9; // ST10_4
  int v10; // ST10_4
  int v11; // ST10_4
  int v12; // ST10_4
  signed int v13; // [esp+28h] [ebp-50h]
  _BOOL4 v14; // [esp+34h] [ebp-44h]
  _BOOL4 v15; // [esp+38h] [ebp-40h]
  int v16; // [esp+40h] [ebp-38h]
  int v17; // [esp+48h] [ebp-30h]
  int v18; // [esp+4Ch] [ebp-2Ch]
  int v19; // [esp+50h] [ebp-28h]
  _BOOL4 v20; // [esp+54h] [ebp-24h]
  float v21; // [esp+58h] [ebp-20h]
  int v22; // [esp+5Ch] [ebp-1Ch]
  int v23; // [esp+60h] [ebp-18h]
  int v24; // [esp+64h] [ebp-14h]
  int v25; // [esp+68h] [ebp-10h]
  int v26; // [esp+6Ch] [ebp-Ch]
  char v27[4]; // [esp+70h] [ebp-8h]
  unsigned int v28; // [esp+88h] [ebp+10h]

  v25 = -1;
  v22 = 0;
  v21 = 0.0;
  v24 = a2[6];
  v26 = a2[5];
  v23 = a2[4];
  v20 = a2 == a1 + 224;
  if ( !a2[5] )
    v22 = 1;
  a2[4] = a3;
  v28 = a3 & 0xFFFFFDFF;
  if ( v28 >= *((_DWORD *)dword_855A4E0 + 12288) )
    Com_Error(1, &byte_814C020, *((_DWORD *)dword_855A4E0 + 12288), v28);
  v19 = a1[297];
  v18 = *((_DWORD *)dword_855A4E0 + 184045);
  if ( v28 )
  {
    *(_DWORD *)v27 = (char *)dword_855A4E0 + 96 * v28;
    a2[5] = (signed int)dword_855A4E0 + 96 * v28;
    a2[6] = *(_DWORD *)(*(_DWORD *)v27 + 64);
    v4 = sub_80D74DE((int)a1, v28);
    v15 = v4 == sub_80D74DE((int)a1, v23);
    v5 = sub_80D7534((int)a1, v28);
    v14 = v5 == sub_80D7534((int)a1, v23);
    if ( v20 && (!v15 || !v14) )
      a1[299] = *((_DWORD *)dword_855A4E0 + 184055) + 400;
  }
  else
  {
    *(_DWORD *)v27 = 0;
    a2[5] = 0;
    a2[6] = 200;
  }
  if ( v22 && v20 )
  {
    a2[6] = 0;
  }
  else
  {
    if ( !*(_DWORD *)v27 || a2[6] <= 0 )
    {
      if ( *(_DWORD *)v27 && *(float *)(*(_DWORD *)v27 + 68) != 0.0 )
      {
        v25 = 120;
      }
      else if ( v26 && *(float *)(v26 + 68) != 0.0 )
      {
        v25 = 250;
      }
      else
      {
        v25 = 170;
      }
    }
    if ( a1[299] - *((_DWORD *)dword_855A4E0 + 184055) > v25 )
      v25 = a1[299] - *((_DWORD *)dword_855A4E0 + 184055);
    if ( a2[6] < v25 )
      a2[6] = v25;
  }
  if ( *(_DWORD *)v27 && *(float *)(*(_DWORD *)v27 + 68) != 0.0 && (unsigned __int8)sub_80C040C(v18, v28) )
  {
    v16 = v23 & 0xFFFFFDFF;
    if ( v26 && *(float *)(v26 + 68) != 0.0 && (unsigned __int8)sub_80C040C(v18, v16) )
    {
      v21 = sub_80BE7D2(v19, v16);
    }
    else
    {
      if ( (unsigned __int8)sub_80C00CA(v18, v16) )
        v17 = sub_80BE794(v18, v16) + 200;
      else
        v17 = 1000;
      v21 = (long double)(*((_DWORD *)dword_855A4E0 + 184055) % v17) / (long double)v17
          + (long double)a1[2] * 0.36000001;
      v21 = v21 - (long double)(signed int)v21;
    }
  }
  if ( v26 )
  {
    v6 = (long double)a2[6] * 0.001;
    sub_80BF346(v19, v23 & 0xFFFFFDFF, v6);
  }
  if ( v28 )
  {
    if ( !v20 )
    {
      a1[253] = 0;
      a1[254] = 1;
    }
    if ( *(_DWORD *)(*(_DWORD *)v27 + 80) & 0x40 )
    {
      if ( (unsigned __int8)sub_80C040C(v18, v28) )
        Com_Error(1, "death animation '%s' is looping", *(_DWORD *)v27);
      if ( a4 )
      {
        *(float *)&v7 = (long double)a2[6] * 0.001;
        sub_80C04C6(v19, v28, 1.0, v7, 1065353216, 0, 0, 0);
      }
      else
      {
        sub_80BF6AC(v19, v28, *((unsigned __int16 *)dword_855A4E0 + 368102), 1.0, 0.0, 1065353216, 0, 0);
        sub_80C00E2((_DWORD *)v19, v28, 1065353216);
      }
    }
    else
    {
      v13 = 0;
      if ( *(float *)(*(_DWORD *)v27 + 68) != 0.0 && sub_80BE816(v19, v28) == 0.0 )
        v13 = 1;
      *(float *)&v8 = (long double)a2[6] * 0.001;
      sub_80C04C6(v19, v28, 1.0, v8, 1065353216, 0, *(_DWORD *)(*(_DWORD *)v27 + 92), v20 == 0);
      if ( v13 )
        sub_80C00E2((_DWORD *)v19, v28, SLODWORD(v21));
    }
    if ( !v20 )
    {
      *(float *)&v9 = (long double)a2[6] * 0.001;
      sub_80C04C6(
        v19,
        *((unsigned __int16 *)dword_855A4E0 + 368092),
        1.0,
        v9,
        1065353216,
        0,
        *(_DWORD *)(*(_DWORD *)v27 + 92),
        0);
      *(float *)&v10 = (long double)a2[6] * 0.001;
      sub_80C04C6(
        v19,
        *((unsigned __int16 *)dword_855A4E0 + 368093),
        0.0099999998,
        v10,
        1065353216,
        0,
        *(_DWORD *)(*(_DWORD *)v27 + 92),
        0);
    }
  }
  else if ( !v20 )
  {
    *(float *)&v11 = (long double)a2[6] * 0.001;
    sub_80C04C6(v19, *((unsigned __int16 *)dword_855A4E0 + 368092), 0.0, v11, 1065353216, 0, 0, 0);
    *(float *)&v12 = (long double)a2[6] * 0.001;
    sub_80C04C6(v19, *((unsigned __int16 *)dword_855A4E0 + 368093), 1.0, v12, 1065353216, 0, 0, 0);
  }
}

//----- (080D7D06) --------------------------------------------------------
unsigned int __cdecl sub_80D7D06(signed int *a1, unsigned int a2, int a3, int a4)
{
  int v4; // ST34_4
  int v5; // ST24_4
  unsigned int result; // eax
  float v7; // ST04_4
  float v8; // ST20_4
  signed int v9; // [esp+14h] [ebp-24h]
  float v10; // [esp+18h] [ebp-20h]
  float v11; // [esp+1Ch] [ebp-1Ch]
  int v12; // [esp+24h] [ebp-14h]
  int v13; // [esp+34h] [ebp-4h]

  v9 = 0;
  if ( *(_DWORD *)(a2 + 20) && *(_DWORD *)(*(_DWORD *)(a2 + 20) + 80) & 2 )
    v9 = 1;
  v4 = *(_DWORD *)(a2 + 20);
  v12 = a1[297];
  v5 = *((_DWORD *)dword_855A4E0 + 184045);
  if ( a3 != *(_DWORD *)(a2 + 16) || !*(_DWORD *)(a2 + 20) && a3 & 0xFFFFFDFF )
    sub_80D75DC(a1, (signed int *)a2, a3, (*(_DWORD *)(a4 + 8) >> 19) & 1);
  result = a3 & 0xFFFFFDFF;
  if ( a3 & 0xFFFFFDFF )
  {
    v13 = *(_DWORD *)(a2 + 20);
    if ( *(float *)(v13 + 68) != 0.0 && *(_DWORD *)(a2 + 44) )
    {
      if ( *((_DWORD *)dword_855A4E0 + 184056) != *(_DWORD *)(a2 + 44) )
      {
        if ( v9 )
        {
          v7 = *(float *)(a2 + 36) - *(float *)(a4 + 32);
          v11 = sub_80D9C30(v7);
        }
        else
        {
          v11 = sub_80A1D86(a2 + 28, a4 + 24);
        }
        v8 = v11 / ((long double)(*((_DWORD *)dword_855A4E0 + 184056) - *(_DWORD *)(a2 + 44)) * 0.001);
        *(float *)(a2 + 40) = v8 / *(float *)(v13 + 68);
        *(_DWORD *)(a2 + 44) = *((_DWORD *)dword_855A4E0 + 184056);
        sub_80D9D2A((_DWORD *)(a4 + 24), (_DWORD *)(a2 + 28));
        if ( *(float *)(a2 + 40) >= 0.1 )
        {
          if ( *(float *)(a2 + 40) > 2.0 )
          {
            if ( *(_DWORD *)(v13 + 80) & 2 )
            {
              if ( *(float *)(a2 + 40) > 4.0 )
                *(_DWORD *)(a2 + 40) = 1082130432;
            }
            else if ( *(float *)(v13 + 68) <= 150.0 )
            {
              if ( *(float *)(v13 + 68) >= 20.0 )
              {
                v10 = 3.0 - (*(float *)(v13 + 68) - 20.0) / 130.0;
                if ( *(float *)(a2 + 40) > (long double)v10 )
                  *(float *)(a2 + 40) = v10;
              }
              else if ( *(float *)(a2 + 40) > 3.0 )
              {
                *(_DWORD *)(a2 + 40) = 1077936128;
              }
            }
            else
            {
              *(_DWORD *)(a2 + 40) = 0x40000000;
            }
          }
        }
        else if ( *(float *)(a2 + 40) < 0.0099999998 && v9 )
        {
          *(_DWORD *)(a2 + 40) = 0;
        }
        else
        {
          *(_DWORD *)(a2 + 40) = 1036831949;
        }
      }
    }
    else
    {
      *(_DWORD *)(a2 + 40) = 1065353216;
      *(_DWORD *)(a2 + 44) = *((_DWORD *)dword_855A4E0 + 184056);
      sub_80D9D2A((_DWORD *)(a4 + 24), (_DWORD *)(a2 + 28));
    }
    result = a2;
    if ( *(_DWORD *)(a2 + 16) )
      result = sub_80C03EA(v12, *(_DWORD *)(a2 + 16) & 0xFFFFFDFF, *(_DWORD *)(a2 + 40));
  }
  return result;
}
// 80A1D86: using guessed type double __cdecl sub_80A1D86(_DWORD, _DWORD);

//----- (080D8052) --------------------------------------------------------
void __cdecl sub_80D8052(int a1, _DWORD *a2)
{
  int v2; // ST14_4

  v2 = *((_DWORD *)dword_855A4E0 + 184045);
  if ( a2[4] )
  {
    if ( sub_80BE816(a1, a2[4] & 0xFFFFFDFF) == 0.0 )
    {
      a2[4] = 0;
      a2[5] = 0;
      a2[6] = 150;
    }
  }
}

//----- (080D80B8) --------------------------------------------------------
void __cdecl sub_80D80B8(float a1, float a2, float a3, float a4, int a5, int a6)
{
  float v6; // ST0C_4
  float v7; // ST00_4
  float v8; // ST00_4
  float v9; // ST00_4
  float v10; // ST00_4
  float v11; // [esp+Ch] [ebp-Ch]
  float v12; // [esp+10h] [ebp-8h]
  float v13; // [esp+10h] [ebp-8h]
  float v14; // [esp+14h] [ebp-4h]
  float v15; // [esp+14h] [ebp-4h]
  float v16; // [esp+14h] [ebp-4h]

  if ( !*(_DWORD *)a6 )
  {
    v14 = sub_80A6000(*(float *)a5, a1);
    if ( v14 > (long double)a2 || -a2 > (long double)v14 )
      *(_DWORD *)a6 = 1;
  }
  if ( *(_DWORD *)a6 )
  {
    v15 = sub_80A6000(a1, *(float *)a5);
    v6 = sub_80D9C30(v15);
    v11 = v6 * 0.050000001;
    if ( v11 < 0.5 )
      v11 = 0.5;
    if ( v15 < 0.0 )
    {
      if ( v15 < 0.0 )
      {
        v13 = (long double)*((signed int *)dword_855A4E0 + 184057) * v11 * -a4;
        if ( v15 < (long double)v13 )
        {
          *(_DWORD *)a6 = 1;
        }
        else
        {
          v13 = v15;
          *(_DWORD *)a6 = 0;
        }
        v8 = *(float *)a5 + v13;
        *(float *)a5 = sub_80A5F4C(v8);
      }
    }
    else
    {
      v12 = (long double)*((signed int *)dword_855A4E0 + 184057) * v11 * a4;
      if ( v12 < (long double)v15 )
      {
        *(_DWORD *)a6 = 1;
      }
      else
      {
        v12 = v15;
        *(_DWORD *)a6 = 0;
      }
      v7 = *(float *)a5 + v12;
      *(float *)a5 = sub_80A5F4C(v7);
    }
    v16 = sub_80A6000(a1, *(float *)a5);
    if ( v16 <= (long double)a3 )
    {
      if ( -a3 > (long double)v16 )
      {
        v10 = a1 + a3;
        *(float *)a5 = sub_80A5F4C(v10);
      }
    }
    else
    {
      v9 = a1 - a3;
      *(float *)a5 = sub_80A5F4C(v9);
    }
  }
}

//----- (080D82A4) --------------------------------------------------------
void __cdecl sub_80D82A4(int a1, int a2)
{
  float v2; // [esp+20h] [ebp-48h]
  float v3; // [esp+24h] [ebp-44h]
  int v4; // [esp+30h] [ebp-38h]
  float v5; // [esp+34h] [ebp-34h]
  char v6; // [esp+40h] [ebp-28h]
  float v7; // [esp+44h] [ebp-24h]
  float v8; // [esp+50h] [ebp-18h]
  float v9; // [esp+54h] [ebp-14h]
  float v10; // [esp+58h] [ebp-10h]
  float v11; // [esp+5Ch] [ebp-Ch]

  v9 = sub_80B6688(*(float *)(a2 + 996));
  v8 = *(float *)(a2 + 992);
  sub_80D9D2A((_DWORD *)(a2 + 1000), &v2);
  v3 = sub_80A5F4C(v3);
  sub_80D9CDC(&v6);
  sub_80D9CDC(&v4);
  if ( *(_DWORD *)(a1 + 8) & 0x300 )
  {
    *(_DWORD *)(a2 + 948) = 1;
    *(_DWORD *)(a2 + 956) = 1;
    *(_DWORD *)(a2 + 900) = 1;
  }
  else if ( sub_80D7180(a2, 3, 0) & 0xC0000 )
  {
    *(_DWORD *)(a2 + 948) = 1;
    *(_DWORD *)(a2 + 956) = 1;
    *(_DWORD *)(a2 + 900) = 1;
  }
  else if ( *(_DWORD *)(a1 + 8) & 0x4000 )
  {
    *(_DWORD *)(a2 + 948) = 1;
    *(_DWORD *)(a2 + 956) = 1;
    *(_DWORD *)(a2 + 900) = 1;
  }
  else if ( sub_80D7180(a2, 3, 0) & 6 )
  {
    if ( sub_80D7180(a2, 6, 1) )
    {
      *(_DWORD *)(a2 + 948) = 1;
      *(_DWORD *)(a2 + 956) = 1;
    }
  }
  else
  {
    *(_DWORD *)(a2 + 948) = 1;
    *(_DWORD *)(a2 + 956) = 1;
    *(_DWORD *)(a2 + 900) = 1;
  }
  v7 = v3 + v8;
  if ( *(_DWORD *)(a1 + 8) & 0x20000 )
  {
    v7 = v3;
    v5 = v3;
    v10 = 90.0;
  }
  else if ( sub_80D7180(a2, 3, 0) & 0xC0000 )
  {
    v5 = v7;
    v10 = 0.0;
  }
  else if ( *(_DWORD *)(a1 + 8) & 0x4000 )
  {
    v5 = v3;
    v7 = v3;
    v4 = 1119092736;
    v10 = 90.0;
  }
  else if ( *(_DWORD *)(a1 + 8) & 8 )
  {
    v5 = v3;
    v10 = 90.0;
  }
  else if ( *(_DWORD *)(a1 + 8) & 0x40 )
  {
    v5 = v3;
    v10 = 45.0;
  }
  else
  {
    if ( *(_DWORD *)(a1 + 8) & 0x40000 )
      v5 = v3;
    else
      v5 = v8 * 0.30000001 + v3;
    v10 = 90.0;
  }
  sub_80D80B8(v5, 0.0, v10, *(float *)(dword_85760B4 + 8), a2 + 944, a2 + 948);
  v10 = 150.0;
  if ( *(_DWORD *)(a1 + 8) & 0x20000 )
  {
    sub_80D80B8(v7, 0.0, v10, *(float *)(dword_85760B4 + 8), a2 + 896, a2 + 900);
  }
  else if ( *(_DWORD *)(a1 + 8) & 8 )
  {
    *(_DWORD *)(a2 + 900) = 0;
    *(float *)(a2 + 896) = v3 + v8;
  }
  else if ( *((_DWORD *)dword_855A4E0 + 24 * (*(_DWORD *)(a1 + 204) & 0xFFFFFDFF) + 20) & 0x30 )
  {
    *(_DWORD *)(a2 + 900) = 0;
    v7 = v3;
    sub_80D80B8(v3, 0.0, v10, *(float *)(dword_85760B4 + 8), a2 + 896, a2 + 900);
  }
  else if ( *(_DWORD *)(a2 + 900) )
  {
    sub_80D80B8(v7, 0.0, v10, *(float *)(dword_85760B4 + 8), a2 + 896, a2 + 900);
  }
  else
  {
    sub_80D80B8(v7, 40.0, v10, *(float *)(dword_85760B4 + 8), a2 + 896, a2 + 900);
  }
  if ( *(_DWORD *)(a1 + 8) & 0x300 )
  {
    *(float *)(a2 + 944) = v3;
    *(float *)(a2 + 896) = v3;
  }
  else if ( sub_80D7180(a2, 3, 0) & 0xC0000 )
  {
    *(float *)(a2 + 944) = v3 + v8;
    *(float *)(a2 + 896) = v3 + v8;
  }
  if ( *(_DWORD *)(a1 + 8) & 0x20000 )
  {
    v11 = 0.0;
  }
  else if ( *(_DWORD *)(a1 + 8) & 0x300 )
  {
    v11 = 0.0;
  }
  else if ( sub_80D7180(a2, 3, 0) & 0xC0000 )
  {
    v11 = 0.0;
  }
  else if ( *(_DWORD *)(a1 + 8) == 0x4000 )
  {
    v11 = 0.0;
  }
  else if ( v2 <= 180.0 )
  {
    v11 = v2 * 0.60000002;
  }
  else
  {
    v11 = (v2 + -360.0) * 0.60000002;
  }
  sub_80D80B8(v11, 0.0, 45.0, 0.15000001, a2 + 952, a2 + 956);
}
// 85760B4: using guessed type int dword_85760B4;

//----- (080D8882) --------------------------------------------------------
int __cdecl sub_80D8882(_DWORD *a1, int a2)
{
  int v2; // ST18_4
  unsigned int v4; // [esp+1Ch] [ebp-Ch]

  v2 = sub_80E9270(a1[50]);
  sub_80D70E2(a1[36], 0, *(_DWORD *)(v2 + 116), 1);
  sub_80D70E2(a1[36], 1, *(_DWORD *)(v2 + 124), 1);
  if ( a1[2] & 0x40000 )
    sub_80D70E2(a1[36], 7, 1, 1);
  else
    sub_80D70E2(a1[36], 7, 0, 1);
  if ( a1[2] & 0x300 )
    sub_80D70E2(a1[36], 2, 1, 1);
  else
    sub_80D70E2(a1[36], 2, 0, 1);
  sub_80D70E2(a1[36], 4, *(float *)(a2 + 1000) > 0.0, 1);
  if ( a1[2] & 4 )
    sub_80D70E2(a1[36], 5, 1, 1);
  else
    sub_80D70E2(a1[36], 5, 0, 1);
  if ( a1[2] & 0x40 )
    sub_80D70E2(a1[36], 6, 1, 1);
  else
    sub_80D70E2(a1[36], 6, 0, 1);
  v4 = a1[51] & 0xFFFFFDFF;
  if ( *(_QWORD *)((char *)dword_855A4E0 + 96 * v4 + 84)
    && sub_80D7180(a2, 3, 0) != *(_QWORD *)((char *)dword_855A4E0 + 96 * v4 + 84) )
  {
    sub_80D70E2(a1[36], 3, *((_DWORD *)dword_855A4E0 + 24 * v4 + 21), 0);
  }
  if ( *((_DWORD *)dword_855A4E0 + 24 * v4 + 20) & 0x10 )
    return sub_80D70E2(a1[36], 8, 1, 1);
  if ( *((_DWORD *)dword_855A4E0 + 24 * v4 + 20) & 0x20 )
    return sub_80D70E2(a1[36], 8, 2, 1);
  return sub_80D70E2(a1[36], 8, 0, 1);
}

//----- (080D8C3E) --------------------------------------------------------
void *__cdecl sub_80D8C3E(int a1, int a2, int a3, int a4, void *s)
{
  float v6; // ST00_4
  long double v7; // fst7
  long double v8; // fst7
  signed int i; // [esp+30h] [ebp-B8h]
  int v10; // [esp+34h] [ebp-B4h]
  int v11; // [esp+38h] [ebp-B0h]
  int v12; // [esp+3Ch] [ebp-ACh]
  float v13; // [esp+40h] [ebp-A8h]
  float v14; // [esp+44h] [ebp-A4h]
  float v15; // [esp+48h] [ebp-A0h]
  float v16; // [esp+50h] [ebp-98h]
  float v17; // [esp+54h] [ebp-94h]
  float v18; // [esp+58h] [ebp-90h]
  float v19; // [esp+6Ch] [ebp-7Ch]
  float v20; // [esp+70h] [ebp-78h]
  float v21; // [esp+74h] [ebp-74h]
  float v22; // [esp+80h] [ebp-68h]
  float v23; // [esp+84h] [ebp-64h]
  float v24; // [esp+88h] [ebp-60h]
  float v25; // [esp+90h] [ebp-58h]
  float v26; // [esp+94h] [ebp-54h]
  float v27; // [esp+98h] [ebp-50h]
  float v28; // [esp+9Ch] [ebp-4Ch]
  float v29; // [esp+A0h] [ebp-48h]
  float v30; // [esp+A4h] [ebp-44h]
  float v31; // [esp+A8h] [ebp-40h]
  float v32; // [esp+ACh] [ebp-3Ch]
  float v33; // [esp+B0h] [ebp-38h]
  float v34; // [esp+B4h] [ebp-34h]
  float v35; // [esp+B8h] [ebp-30h]
  int v36; // [esp+BCh] [ebp-2Ch]
  float v37; // [esp+C0h] [ebp-28h]
  float v38; // [esp+C4h] [ebp-24h]
  float v39; // [esp+C8h] [ebp-20h]
  float v40; // [esp+CCh] [ebp-1Ch]

  if ( *(_DWORD *)(a2 + 8) & 0x300 )
    return memset(s, 0, 0x60u);
  v12 = *(_DWORD *)(a2 + 144);
  sub_80D9CDC(&v22);
  sub_80D9CDC(&v16);
  sub_80D9D2A((_DWORD *)(a4 + 1000), &v13);
  v23 = *(float *)(a4 + 896);
  v17 = *(float *)(a4 + 944);
  if ( !(sub_80D7180(a4, 3, 0) & 0xC0000) )
  {
    v16 = *(float *)(a4 + 952);
    if ( *(_DWORD *)(a2 + 8) & 8 )
    {
      v16 = sub_80A6112(v16);
      if ( v16 <= 0.0 )
        v16 = v16 * 0.25;
      else
        v16 = v16 * 0.5;
    }
  }
  sub_80A6062(&v13, &v16, &v13);
  sub_80A6062(&v16, &v22, &v16);
  sub_80D9D06(&v20, 0, 0, *(_DWORD *)(a2 + 228));
  v19 = sub_80B6688(*(float *)(a4 + 996));
  v18 = v19 * 50.0 * 0.92500001;
  v15 = v19 * 50.0 * 0.92500001;
  if ( v19 != 0.0 )
  {
    if ( *(_DWORD *)(a2 + 8) & 4 )
    {
      if ( v19 <= 0.0 )
        v21 = -v19 * 12.5 + v21;
      else
        v21 = -v19 * 2.5 + v21;
    }
    else if ( v19 <= 0.0 )
    {
      v21 = -v19 * 5.0 + v21;
    }
    else
    {
      v21 = -v19 * 2.5 + v21;
    }
  }
  if ( !(*(_DWORD *)(a2 + 8) & 0x20000) )
    v23 = sub_80A6000(v23, *(float *)(a4 + 1004));
  if ( *(_DWORD *)(a2 + 8) & 8 )
  {
    if ( v19 != 0.0 )
      v15 = v15 * 0.5;
    v22 = v22 + *(float *)(a2 + 232);
    v6 = v17 * 0.0174532925199433;
    sub_80D9CAE(v6, (int)&v11, (int)&v10);
    v20 = (1.0 - *(float *)&v10) * -24.0 + v20;
    v21 = *(float *)&v11 * -12.0 + v21;
    if ( v19 * *(float *)&v11 > 0.0 )
      v21 = -v19 * (1.0 - *(float *)&v10) * 16.0 + v21;
    v25 = 0.0;
    v26 = v18 * -1.2;
    v27 = v18 * 0.30000001;
    if ( *(float *)(a2 + 232) != 0.0 || *(float *)(a2 + 236) != 0.0 )
    {
      v7 = sub_80A6000(*(float *)(a2 + 232), *(float *)(a2 + 236));
      v25 = v7 + v25;
    }
    v28 = 0.0;
    v29 = v17 * 0.1 - v18 * 0.2;
    v30 = v18 * 0.2;
    v31 = v16;
    v32 = v17 * 0.80000001 + v18;
    v33 = v18 * -0.2;
  }
  else
  {
    if ( v19 != 0.0 )
    {
      if ( *(_DWORD *)(a2 + 8) & 4 )
      {
        if ( v19 <= 0.0 )
        {
          v18 = v18 * 1.25;
          v15 = v15 * 1.25;
        }
      }
      else
      {
        v18 = v18 * 1.25;
        v15 = v15 * 1.25;
      }
    }
    v24 = v19 * 50.0 * 0.075000003 + v24;
    v25 = v16 * 0.2;
    v26 = v17 * 0.40000001;
    v27 = v18 * 0.5;
    if ( *(float *)(a2 + 232) != 0.0 || *(float *)(a2 + 236) != 0.0 )
    {
      v8 = sub_80A6000(*(float *)(a2 + 232), *(float *)(a2 + 236));
      v25 = v8 + v25;
    }
    v28 = v16 * 0.30000001;
    v29 = v17 * 0.40000001;
    v30 = v18 * 0.5;
    v31 = v16 * 0.5;
    v32 = v17 * 0.2;
    v33 = v18 * -0.60000002;
  }
  v34 = v13 * 0.30000001;
  v35 = v14 * 0.30000001;
  v36 = 0;
  v37 = v13 * 0.69999999;
  v38 = v14 * 0.69999999;
  v39 = v15 * -0.30000001;
  sub_80D9CDC(&v40);
  if ( *(float *)(a2 + 236) != 0.0 || *(float *)(a2 + 232) != 0.0 )
    v40 = sub_80A6000(*(float *)(a2 + 236), *(float *)(a2 + 232));
  for ( i = 0; i <= 5; ++i )
    sub_80D9D2A((_DWORD *)&v25 + 3 * i, (_DWORD *)s + 3 * i);
  sub_80D9D2A(&v22, (_DWORD *)s + 18);
  return (void *)sub_80D9D2A(&v20, (_DWORD *)s + 21);
}

//----- (080D93D8) --------------------------------------------------------
int *__cdecl sub_80D93D8(int a1, float a2, int a3)
{
  int *result; // eax
  int i; // [esp+4h] [ebp-Ch]
  float v5; // [esp+8h] [ebp-8h]

  for ( i = 0; i <= 2; ++i )
  {
    v5 = *(float *)(a1 + 4 * i) - *(float *)(a3 + 4 * i);
    if ( v5 <= (long double)a2 )
    {
      if ( -a2 <= (long double)v5 )
        *(_DWORD *)(a3 + 4 * i) = *(_DWORD *)(a1 + 4 * i);
      else
        *(float *)(a3 + 4 * i) = *(float *)(a3 + 4 * i) - a2;
    }
    else
    {
      *(float *)(a3 + 4 * i) = *(float *)(a3 + 4 * i) + a2;
    }
    result = &i;
  }
  return result;
}

//----- (080D94B8) --------------------------------------------------------
void __cdecl sub_80D94B8(int a1, float a2, int a3)
{
  float v3; // [esp+1Ch] [ebp-1Ch]
  float v4; // [esp+1Ch] [ebp-1Ch]
  int v5; // [esp+20h] [ebp-18h]

  sub_80D9D5A((float *)a1, (float *)a3, (float *)&v5);
  v3 = sub_80D9DF2((float *)&v5);
  if ( v3 != 0.0 )
  {
    v4 = sub_80D9C4A(v3) * a2;
    if ( v4 >= 1.0 )
      sub_80D9D2A((_DWORD *)a1, (_DWORD *)a3);
    else
      sub_80D9D9E(a3, v4, (int)&v5, a3);
  }
}

//----- (080D954C) --------------------------------------------------------
signed int __cdecl sub_80D954C(int a1, int a2, int a3, int a4, signed int a5)
{
  float v5; // ST04_4
  char s[104]; // [esp+20h] [ebp-78h]
  char _68[104]; // [esp+68h] [ebp-30h]
  char _74[104]; // [esp+74h] [ebp-24h]
  float v10; // [esp+88h] [ebp-10h]
  int i; // [esp+8Ch] [ebp-Ch]

  sub_80D8C3E(a1, a2, a3, a4, s);
  v10 = (long double)a5 * 0.36000001;
  for ( i = 0; i <= 5; ++i )
  {
    sub_80D93D8((int)&s[12 * i], v10, a4 + 12 * i + 1020);
    sub_80B98CC(a1, a3, **((unsigned __int16 **)&off_8164808 + i), (float *)(a4 + 12 * i + 1020));
  }
  sub_80D93D8((int)_68, v10, a4 + 1092);
  v5 = (long double)a5 * 0.1;
  sub_80D94B8((int)_74, v5, a4 + 1104);
  return sub_80B994A(a1, a3, (unsigned __int16)word_87A2342, (_DWORD *)(a4 + 1104), (float *)(a4 + 1092));
}
// 87A2342: using guessed type __int16 word_87A2342;
// 80D954C: using guessed type char s[104];

//----- (080D9698) --------------------------------------------------------
unsigned int __cdecl sub_80D9698(int a1, _DWORD *a2, signed int *a3)
{
  int v3; // ST14_4

  sub_80D82A4((int)a2, (int)a3);
  sub_80D8882(a2, (int)a3);
  v3 = a3[297];
  sub_80D8052(a3[297], a3 + 224);
  sub_80D8052(v3, a3 + 236);
  if ( a3[253] && !(a3[240] & 0xFFFFFDFF) )
  {
    a3[253] = 0;
    a3[254] = 1;
  }
  sub_80D7D06(a3, (unsigned int)(a3 + 224), a2[51], (int)a2);
  return sub_80D7D06(a3, (unsigned int)(a3 + 236), a2[52], (int)a2);
}

//----- (080D978C) --------------------------------------------------------
int __cdecl sub_80D978C(int a1, _DWORD *a2, int a3, int a4)
{
  int result; // eax
  signed int v5; // [esp+2Ch] [ebp-7Ch]
  int v6; // [esp+30h] [ebp-78h]
  int v7; // [esp+34h] [ebp-74h]
  int v8[23]; // [esp+38h] [ebp-70h]
  _DWORD *v9; // [esp+94h] [ebp-14h]
  int i; // [esp+98h] [ebp-10h]
  int v11; // [esp+9Ch] [ebp-Ch]
  char v12[8]; // [esp+A0h] [ebp-8h]

  v11 = a2[50];
  if ( a2[2] & 0x300 )
    v11 = 0;
  v9 = *(_DWORD **)(a3 + 1188);
  if ( !*(_DWORD *)a3 || !*(_BYTE *)(a3 + 64) )
  {
    sub_80BFA1E(v9);
    return (*((int (__cdecl **)(_DWORD))dword_855A4E0 + 184061))(*a2);
  }
  if ( a1 != 0 )
  {
    if ( *(_DWORD *)(a3 + 1192) == v11 )
    {
      result = a3;
      if ( !*(_DWORD *)(a3 + 1016) )
        return result;
    }
    (*((void (__cdecl **)(_DWORD))dword_855A4E0 + 184061))(*a2);
  }
  v6 = (*((int (__cdecl **)(int))dword_855A4E0 + 184059))(a3 + 64);
  v7 = 0;
  v8[0] = 0;
  v5 = 1;
  for ( i = 0; i <= 5; ++i )
  {
    if ( *(_BYTE *)(a3 + (i << 6) + 128) )
    {
      *(_DWORD *)&v12[12 * v5 - 112] = (*((int (__cdecl **)(int))dword_855A4E0 + 184059))(a3 + (i << 6) + 128);
      *(_DWORD *)&v12[12 * v5 - 108] = a3 + (i << 6) + 512;
      v8[3 * v5++] = (a4 >> i) & 1;
    }
  }
  *(_DWORD *)(a3 + 1192) = v11;
  (*((void (__cdecl **)(int *, _DWORD, _DWORD *, _DWORD, int))dword_855A4E0 + 184060))(
    &v6,
    (unsigned __int16)v5,
    v9,
    *a2,
    a3);
  result = a3;
  *(_DWORD *)(a3 + 1016) = 0;
  return result;
}
// 80D978C: using guessed type char var_8[8];
// 80D978C: using guessed type int anonymous_1[23];

//----- (080D99BE) --------------------------------------------------------
int sub_80D99BE()
{
  sub_806D982("multiplayer", "root", (_DWORD *)dword_855A4E0 + 184051, *((_DWORD *)dword_855A4E0 + 184058));
  sub_806D982("multiplayer", "torso", (_DWORD *)dword_855A4E0 + 184052, *((_DWORD *)dword_855A4E0 + 184058));
  sub_806D982("multiplayer", "legs", (_DWORD *)dword_855A4E0 + 184053, *((_DWORD *)dword_855A4E0 + 184058));
  return sub_806D982("multiplayer", "turning", (_DWORD *)dword_855A4E0 + 184054, *((_DWORD *)dword_855A4E0 + 184058));
}

//----- (080D9A8A) --------------------------------------------------------
_DWORD *__userpurge sub_80D9A8A@<eax>(_DWORD *a1, char *a2, int a3)
{
  int v4; // [esp+14h] [ebp-4h]

  sub_806D8CE(&v4, a2);
  *a1 = v4;
  if ( !*a1 && a3 )
    Com_Error(1, &byte_814C140, a2);
  return a1;
}

//----- (080D9ADE) --------------------------------------------------------
int sub_80D9ADE()
{
  _DWORD *v0; // ebx
  int result; // eax
  int v2; // [esp+10h] [ebp-8h]

  v0 = (char *)dword_855A4E0 + 736200;
  sub_80D9A8A(&v2, "multiplayer", 1);
  *v0 = v2;
  *((_DWORD *)dword_855A4E0 + 184045) = *((_DWORD *)dword_855A4E0 + 184050);
  *((_WORD *)dword_855A4E0 + 368092) = *((_WORD *)dword_855A4E0 + 368104);
  *((_WORD *)dword_855A4E0 + 368093) = *((_WORD *)dword_855A4E0 + 368106);
  result = *((unsigned __int16 *)dword_855A4E0 + 368108);
  *((_WORD *)dword_855A4E0 + 368094) = result;
  return result;
}

//----- (080D9B7E) --------------------------------------------------------
int sub_80D9B7E()
{
  char *v0; // ST1C_4
  char v2; // [esp+20h] [ebp-28h]
  int v3; // [esp+3Ch] [ebp-Ch]

  sub_80AA1F6((int *)&v2, 36864);
  v0 = sub_80AA240((int *)&v2);
  v3 = 0;
  sub_80D99BE();
  sub_80D5B94((int)dword_855A4E0, (int)v0, (int)&v3);
  sub_8075ECE(*((_DWORD *)dword_855A4E0 + 184062), *((_DWORD *)dword_855A4E0 + 184058));
  sub_80D9ADE();
  sub_8075F0E();
  sub_80D4BC2();
  return sub_80AA22A((int *)&v2);
}

//----- (080D9C30) --------------------------------------------------------
long double __cdecl sub_80D9C30(float a1)
{
  return (float)fabs(a1);
}

//----- (080D9C4A) --------------------------------------------------------
long double __cdecl sub_80D9C4A(float a1)
{
  float v1; // ST0C_4

  v1 = a1 * 0.5;
  return (float)((1.5
                - v1 * COERCE_FLOAT(1597463007 - (SLODWORD(a1) >> 1)) * COERCE_FLOAT(1597463007 - (SLODWORD(a1) >> 1)))
               * COERCE_FLOAT(1597463007 - (SLODWORD(a1) >> 1)));
}

//----- (080D9CAE) --------------------------------------------------------
void __cdecl sub_80D9CAE(float a1, int a2, int a3)
{
  *(float *)a2 = sin(a1);
  *(float *)a3 = cos(a1);
}

//----- (080D9CDC) --------------------------------------------------------
int __cdecl sub_80D9CDC(_DWORD *a1)
{
  int result; // eax

  *a1 = 0;
  a1[1] = 0;
  result = 0;
  a1[2] = 0;
  return result;
}

//----- (080D9D06) --------------------------------------------------------
int __cdecl sub_80D9D06(_DWORD *a1, int a2, int a3, int a4)
{
  int result; // eax

  *a1 = a2;
  a1[1] = a3;
  result = a4;
  a1[2] = a4;
  return result;
}

//----- (080D9D2A) --------------------------------------------------------
int __cdecl sub_80D9D2A(_DWORD *a1, _DWORD *a2)
{
  int result; // eax

  *a2 = *a1;
  a2[1] = a1[1];
  result = a1[2];
  a2[2] = result;
  return result;
}

//----- (080D9D5A) --------------------------------------------------------
int __cdecl sub_80D9D5A(float *a1, float *a2, float *a3)
{
  int result; // eax

  *a3 = *a1 - *a2;
  a3[1] = a1[1] - a2[1];
  result = (int)(a1 + 2);
  a3[2] = a1[2] - a2[2];
  return result;
}

//----- (080D9D9E) --------------------------------------------------------
int __cdecl sub_80D9D9E(int a1, float a2, int a3, int a4)
{
  int result; // eax

  *(float *)a4 = a2 * *(float *)a3 + *(float *)a1;
  *(float *)(a4 + 4) = a2 * *(float *)(a3 + 4) + *(float *)(a1 + 4);
  result = a3 + 8;
  *(float *)(a4 + 8) = a2 * *(float *)(a3 + 8) + *(float *)(a1 + 8);
  return result;
}

//----- (080D9DF2) --------------------------------------------------------
long double __cdecl sub_80D9DF2(float *a1)
{
  return *a1 * *a1 + a1[1] * a1[1] + a1[2] * a1[2];
}

//----- (080D9E26) --------------------------------------------------------
void __cdecl sub_80D9E26(float *a1)
{
  float v1; // ST00_4

  v1 = *a1 * *a1 + a1[1] * a1[1] + a1[2] * a1[2];
  sub_80D9E64(v1);
}

//----- (080D9E64) --------------------------------------------------------
long double __cdecl sub_80D9E64(float a1)
{
  return (float)sqrt(a1);
}

//----- (080D9E84) --------------------------------------------------------
int __cdecl sub_80D9E84(int a1, int a2)
{
  return (*(_DWORD *)(a1 + 4 * (a2 >> 5)) >> (a2 & 0x1F)) & 1;
}

//----- (080D9EAA) --------------------------------------------------------
int __cdecl sub_80D9EAA(int a1, int a2)
{
  int result; // eax

  result = *(_DWORD *)(a1 + 4 * (a2 >> 5)) | (1 << (a2 & 0x1F));
  *(_DWORD *)(a1 + 4 * (a2 >> 5)) = result;
  return result;
}

//----- (080D9EE8) --------------------------------------------------------
char *__usercall sub_80D9EE8@<eax>(long double a1@<st0>)
{
  char *result; // eax

  dword_8576040 = (int)Dvar_RegisterFloat(a1, "jump_height", 1109131264, 0, 1124073472, 4480);
  dword_8576044 = (int)Dvar_RegisterFloat(a1, "jump_stepSize", 1099956224, 0, 1115684864, 4480);
  dword_8576048 = (int)Dvar_RegisterBool(a1, "jump_slowdownEnable", 1, 4480);
  dword_857604C = (int)Dvar_RegisterFloat(a1, "jump_ladderPushVel", 1124073472, 0, 1149239296, 4480);
  result = Dvar_RegisterFloat(a1, "jump_spreadAdd", 1115684864, 0, 1140850688, 4480);
  dword_8576050 = (int)result;
  return result;
}
// 8576040: using guessed type int dword_8576040;
// 8576044: using guessed type int dword_8576044;
// 8576048: using guessed type int dword_8576048;
// 857604C: using guessed type int dword_857604C;
// 8576050: using guessed type int dword_8576050;

//----- (080D9FF4) --------------------------------------------------------
int __cdecl sub_80D9FF4(int a1)
{
  int result; // eax

  *(_DWORD *)(a1 + 12) &= 0xFFF7FFFF;
  result = 0;
  *(_DWORD *)(a1 + 116) = 0;
  return result;
}

//----- (080DA016) --------------------------------------------------------
signed int __cdecl sub_80DA016(int a1, int a2, float *a3)
{
  if ( *(float *)(a1 + 116) + *(float *)(dword_8576040 + 8) <= (long double)*(float *)(a2 + 8) )
    return 0;
  *a3 = *(float *)(dword_8576044 + 8);
  if ( *(float *)(a2 + 8) + *a3 > *(float *)(a1 + 116) + *(float *)(dword_8576040 + 8) )
    *a3 = *(float *)(a1 + 116) + *(float *)(dword_8576040 + 8) - *(float *)(a2 + 8);
  return 1;
}
// 8576040: using guessed type int dword_8576040;
// 8576044: using guessed type int dword_8576044;

//----- (080DA0A4) --------------------------------------------------------
_BOOL4 __cdecl sub_80DA0A4(int a1)
{
  return *(float *)(a1 + 28) >= *(float *)(a1 + 116) + *(float *)(dword_8576040 + 8);
}
// 8576040: using guessed type int dword_8576040;

//----- (080DA0CA) --------------------------------------------------------
int __cdecl sub_80DA0CA(int a1)
{
  int result; // eax

  result = a1;
  if ( !*(_DWORD *)(a1 + 16) )
  {
    *(_DWORD *)(a1 + 12) |= 0x80000u;
    result = a1;
    *(_DWORD *)(a1 + 16) = 1800;
  }
  return result;
}

//----- (080DA0F4) --------------------------------------------------------
int __cdecl sub_80DA0F4(int a1)
{
  signed int v2; // [esp+14h] [ebp-4h]

  v2 = 1065353216;
  if ( *(_DWORD *)(a1 + 16) <= 1800 )
  {
    if ( !*(_DWORD *)(a1 + 16) )
    {
      if ( *(float *)(a1 + 116) + 18.0 <= *(float *)(a1 + 28) )
      {
        *(_DWORD *)(a1 + 16) = 1200;
        v2 = 1056964608;
      }
      else
      {
        *(_DWORD *)(a1 + 16) = 1800;
        v2 = 1059481190;
      }
    }
  }
  else
  {
    sub_80D9FF4(a1);
    v2 = 1059481190;
  }
  if ( !*(_BYTE *)(dword_8576048 + 8) )
    v2 = 1065353216;
  return sub_80DA7A6(a1 + 32, *(float *)&v2, a1 + 32);
}
// 8576048: using guessed type int dword_8576048;

//----- (080DA1A6) --------------------------------------------------------
long double __cdecl sub_80DA1A6(int a1)
{
  float v2; // [esp+0h] [ebp-4h]

  if ( *(_BYTE *)(dword_8576048 + 8) )
  {
    if ( *(_DWORD *)(a1 + 16) <= 1699 )
      v2 = (long double)*(signed int *)(a1 + 16) * 1.5 * 0.00058823527 + 1.0;
    else
      v2 = 2.5;
  }
  else
  {
    v2 = 1.0;
  }
  return v2;
}
// 8576048: using guessed type int dword_8576048;

//----- (080DA1F8) --------------------------------------------------------
long double __cdecl sub_80DA1F8(int a1)
{
  float v2; // [esp+14h] [ebp-4h]

  if ( *(_DWORD *)(a1 + 16) > 1800 )
  {
    sub_80D9FF4(a1);
    v2 = 1.0;
  }
  else
  {
    v2 = sub_80DA1A6(a1);
  }
  return v2;
}

//----- (080DA238) --------------------------------------------------------
void __cdecl sub_80DA238(int a1, int a2)
{
  float v2; // ST00_4
  float v3; // [esp+10h] [ebp-8h]
  float v4; // [esp+14h] [ebp-4h]

  if ( *(float *)(a1 + 28) - *(float *)(a2 + 8) > 0.0 )
  {
    v4 = *(float *)(a1 + 116) + *(float *)(dword_8576040 + 8) - *(float *)(a1 + 28);
    if ( v4 >= 0.1 )
    {
      v2 = (v4 + v4) * (long double)*(signed int *)(a1 + 72);
      v3 = sub_80DA70C(v2);
      if ( *(float *)(a1 + 40) > (long double)v3 )
        *(float *)(a1 + 40) = v3;
    }
    else
    {
      *(_DWORD *)(a1 + 40) = 0;
    }
  }
}
// 8576040: using guessed type int dword_8576040;

//----- (080DA2CA) --------------------------------------------------------
long double __cdecl sub_80DA2CA(int a1)
{
  float v2; // [esp+0h] [ebp-4h]

  if ( *(_BYTE *)(dword_8576048 + 8) )
  {
    if ( *(_DWORD *)(a1 + 16) <= 1699 )
      v2 = (long double)*(signed int *)(a1 + 16) * 1.5 * 0.00058823527 + 1.0;
    else
      v2 = 2.5;
  }
  else
  {
    v2 = 1.0;
  }
  return v2;
}
// 8576048: using guessed type int dword_8576048;

//----- (080DA31C) --------------------------------------------------------
void __cdecl sub_80DA31C(int a1, int a2, float a3)
{
  float v3; // ST0C_4
  int v4; // [esp+8h] [ebp-10h]
  float v5; // [esp+10h] [ebp-8h]

  v4 = *(_DWORD *)a1;
  v5 = (a3 + a3) * (long double)*(signed int *)(*(_DWORD *)a1 + 72);
  if ( *(_DWORD *)(*(_DWORD *)a1 + 12) & 0x80000 && *(_DWORD *)(v4 + 16) <= 1800 )
  {
    v3 = sub_80DA2CA(v4);
    v5 = v5 / v3;
  }
  *(_DWORD *)(a2 + 48) = 0;
  *(_DWORD *)(a2 + 52) = 0;
  *(_DWORD *)(a2 + 44) = 0;
  *(_DWORD *)(v4 + 96) = 1023;
  *(_DWORD *)(v4 + 112) = *(_DWORD *)(a1 + 4);
  *(_DWORD *)(v4 + 116) = *(_DWORD *)(v4 + 28);
  *(_DWORD *)(v4 + 12) |= 0x80000u;
  *(_DWORD *)(v4 + 16) = 0;
  *(float *)(v4 + 40) = sub_80DA70C(v5);
  *(float *)(v4 + 1492) = *(float *)(v4 + 1492) + *(float *)(dword_8576050 + 8);
  if ( *(float *)(v4 + 1492) > 255.0 )
    *(_DWORD *)(v4 + 1492) = 1132396544;
}
// 8576050: using guessed type int dword_8576050;

//----- (080DA424) --------------------------------------------------------
unsigned int __cdecl sub_80DA424(int a1, int *a2)
{
  float v2; // ST1C_4
  float v3; // ST1C_4
  float v4; // ST04_4
  unsigned int result; // eax
  int v6; // [esp+20h] [ebp-28h]
  int v7; // [esp+30h] [ebp-18h]

  *(float *)(a1 + 40) = *(float *)(a1 + 40) * 0.75;
  sub_80DA752(&v6, *a2, a2[1], 0);
  sub_80A20C0((float *)&v6);
  v2 = sub_80DA832((float *)(a1 + 100), (float *)a2);
  if ( v2 >= 0.0 )
  {
    sub_80DA776(&v6, &v7);
  }
  else
  {
    v3 = sub_80DA832((float *)&v6, (float *)(a1 + 100));
    v4 = v3 * -2.0;
    sub_80DA7DE((int)&v6, v4, a1 + 100, (int)&v7);
    sub_80A20C0((float *)&v7);
  }
  sub_80DA72C((int)&v7, *(float *)(dword_857604C + 8), a1 + 32);
  result = *(_DWORD *)(a1 + 12) & 0xFFFFFFDF;
  *(_DWORD *)(a1 + 12) = result;
  return result;
}
// 857604C: using guessed type int dword_857604C;

//----- (080DA52E) --------------------------------------------------------
int __cdecl sub_80DA52E(int a1, int a2)
{
  int result; // eax

  if ( *(_DWORD *)(a1 + 12) & 0x20 )
    return sub_80DED2E(a1, 91);
  result = sub_80DFAFC(a2);
  if ( result )
    result = sub_80DED2E(a1, result + 70);
  return result;
}

//----- (080DA584) --------------------------------------------------------
signed int __cdecl sub_80DA584(int a1, int *a2)
{
  signed int v3; // [esp+10h] [ebp-8h]
  _DWORD *v4; // [esp+14h] [ebp-4h]

  v4 = *(_DWORD **)a1;
  if ( *(_DWORD *)(a1 + 4) - *(_DWORD *)(*(_DWORD *)a1 + 112) <= 499 )
    return 0;
  if ( v4[3] & 0x1000 )
    return 0;
  if ( v4[3] & 4 )
    return 0;
  if ( v4[1] > 5 )
    return 0;
  if ( sub_80DEE0E((int)v4) )
    return 0;
  if ( !(*(_DWORD *)(a1 + 8) & 0x400) )
    return 0;
  if ( *(_DWORD *)(a1 + 36) & 0x400 )
  {
    *(_DWORD *)(a1 + 8) &= 0xFFFFFBFF;
    v3 = 0;
  }
  else
  {
    sub_80DA31C(a1, (int)a2, *(float *)(dword_8576040 + 8));
    sub_80DA52E((int)v4, (int)a2);
    if ( v4[3] & 0x20 )
      sub_80DA424((int)v4, a2);
    if ( *(_BYTE *)(a1 + 28) < 0 )
      sub_80D6FCA(v4, 4, 0, 1);
    else
      sub_80D6FCA(v4, 3, 0, 1);
    v3 = 1;
  }
  return v3;
}
// 8576040: using guessed type int dword_8576040;

//----- (080DA70C) --------------------------------------------------------
long double __cdecl sub_80DA70C(float a1)
{
  return (float)sqrt(a1);
}

//----- (080DA72C) --------------------------------------------------------
int __cdecl sub_80DA72C(int a1, float a2, int a3)
{
  int result; // eax

  *(float *)a3 = a2 * *(float *)a1;
  result = a1 + 4;
  *(float *)(a3 + 4) = a2 * *(float *)(a1 + 4);
  return result;
}

//----- (080DA752) --------------------------------------------------------
int __cdecl sub_80DA752(_DWORD *a1, int a2, int a3, int a4)
{
  int result; // eax

  *a1 = a2;
  a1[1] = a3;
  result = a4;
  a1[2] = a4;
  return result;
}

//----- (080DA776) --------------------------------------------------------
int __cdecl sub_80DA776(_DWORD *a1, _DWORD *a2)
{
  int result; // eax

  *a2 = *a1;
  a2[1] = a1[1];
  result = a1[2];
  a2[2] = result;
  return result;
}

//----- (080DA7A6) --------------------------------------------------------
int __cdecl sub_80DA7A6(int a1, float a2, int a3)
{
  int result; // eax

  *(float *)a3 = a2 * *(float *)a1;
  *(float *)(a3 + 4) = a2 * *(float *)(a1 + 4);
  result = a1 + 8;
  *(float *)(a3 + 8) = a2 * *(float *)(a1 + 8);
  return result;
}

//----- (080DA7DE) --------------------------------------------------------
int __cdecl sub_80DA7DE(int a1, float a2, int a3, int a4)
{
  int result; // eax

  *(float *)a4 = a2 * *(float *)a3 + *(float *)a1;
  *(float *)(a4 + 4) = a2 * *(float *)(a3 + 4) + *(float *)(a1 + 4);
  result = a3 + 8;
  *(float *)(a4 + 8) = a2 * *(float *)(a3 + 8) + *(float *)(a1 + 8);
  return result;
}

//----- (080DA832) --------------------------------------------------------
long double __cdecl sub_80DA832(float *a1, float *a2)
{
  return *a1 * *a2 + a1[1] * a2[1] + a1[2] * a2[2];
}

//----- (080DA868) --------------------------------------------------------
char *__usercall sub_80DA868@<eax>(long double a1@<st0>)
{
  char *result; // eax

  dword_8576054 = (int)Dvar_RegisterBool(a1, "mantle_enable", 1, 4480);
  dword_8576058 = (int)Dvar_RegisterBool(a1, "mantle_debug", 0, 4480);
  dword_857605C = (int)Dvar_RegisterFloat(a1, "mantle_check_range", 1101004800, 0, 1124073472, 4480);
  dword_8576060 = (int)Dvar_RegisterFloat(a1, "mantle_check_radius", 1036831949, 0, 1097859072, 4480);
  dword_8576064 = (int)Dvar_RegisterFloat(a1, "mantle_check_angle", 1114636288, 0, 1127481344, 4480);
  result = Dvar_RegisterFloat(a1, "mantle_view_yawcap", 1114636288, 0, 1127481344, 4480);
  dword_8576068 = (int)result;
  return result;
}
// 8576054: using guessed type int dword_8576054;
// 8576058: using guessed type int dword_8576058;
// 857605C: using guessed type int dword_857605C;
// 8576060: using guessed type int dword_8576060;
// 8576064: using guessed type int dword_8576064;
// 8576068: using guessed type int dword_8576068;

//----- (080DA9B8) --------------------------------------------------------
void *__cdecl sub_80DA9B8(size_t n)
{
  return Hunk_AllocAlignInternal(n, 4);
}

//----- (080DA9D4) --------------------------------------------------------
void __cdecl sub_80DA9D4(int a1)
{
  if ( *(_BYTE *)(dword_8576058 + 8) )
    Com_Printf("%s\n", a1);
}
// 8576058: using guessed type int dword_8576058;

//----- (080DA9FC) --------------------------------------------------------
signed int __cdecl sub_80DA9FC(int a1)
{
  return sub_80BE794(dword_857606C, dword_8164860[3 * *(_DWORD *)(a1 + 8)]);
}
// 8164860: using guessed type int dword_8164860[];

//----- (080DAA36) --------------------------------------------------------
signed int __cdecl sub_80DAA36(int a1)
{
  signed int v2; // [esp+Ch] [ebp-Ch]

  if ( (*(_BYTE *)(a1 + 12) ^ 1) & 1 )
    v2 = 0;
  else
    v2 = sub_80BE794(dword_857606C, dword_8164864[3 * *(_DWORD *)(a1 + 8)]);
  return v2;
}
// 8164864: using guessed type int dword_8164864[];

//----- (080DAA8E) --------------------------------------------------------
int __cdecl sub_80DAA8E(int a1)
{
  signed int v1; // ST14_4
  int v3; // [esp+Ch] [ebp-Ch]

  v1 = sub_80DA9FC(a1);
  sub_80DAA36(a1);
  if ( *(_DWORD *)(a1 + 4) > v1 )
    v3 = dword_8164864[3 * *(_DWORD *)(a1 + 8)];
  else
    v3 = dword_8164860[3 * *(_DWORD *)(a1 + 8)];
  return v3;
}
// 8164860: using guessed type int dword_8164860[];
// 8164864: using guessed type int dword_8164864[];

//----- (080DAAF2) --------------------------------------------------------
int __cdecl sub_80DAAF2(int a1, signed int a2, float *a3)
{
  float v3; // ST2C_4
  float v4; // ST2C_4
  signed int v6; // [esp+30h] [ebp-28h]
  signed int v7; // [esp+34h] [ebp-24h]
  int v8; // [esp+38h] [ebp-20h]
  int v9; // [esp+40h] [ebp-18h]

  v7 = sub_80DA9FC(a1);
  v6 = sub_80DAA36(a1);
  if ( a2 > v7 )
  {
    v4 = (long double)(a2 - v7) / (long double)v6;
    sub_80BF1A4(dword_857606C, dword_8164860[3 * *(_DWORD *)(a1 + 8)], (int)&v8, (int)&v9, 1.0);
    sub_80BF1A4(dword_857606C, dword_8164864[3 * *(_DWORD *)(a1 + 8)], (int)&v8, (int)a3, v4);
    sub_80DBFC2(a3, (float *)&v9, a3);
  }
  else
  {
    v3 = (long double)a2 / (long double)v7;
    sub_80BF1A4(dword_857606C, dword_8164860[3 * *(_DWORD *)(a1 + 8)], (int)&v8, (int)a3, v3);
  }
  return sub_80A530C((int)a3, *(float *)a1);
}
// 8164860: using guessed type int dword_8164860[];
// 8164864: using guessed type int dword_8164864[];

//----- (080DAC38) --------------------------------------------------------
int __cdecl sub_80DAC38(float a1, float a2)
{
  float v2; // ST00_4
  float v3; // ST00_4
  signed int v5; // [esp+4h] [ebp-14h]
  signed int i; // [esp+8h] [ebp-10h]
  float v7; // [esp+Ch] [ebp-Ch]
  float v8; // [esp+10h] [ebp-8h]
  float v9; // [esp+14h] [ebp-4h]

  v9 = a2 - a1;
  v5 = 0;
  v2 = flt_8164868[0] - v9;
  v7 = sub_80DBF16(v2);
  for ( i = 1; i <= 6; ++i )
  {
    v3 = flt_8164868[3 * i] - v9;
    v8 = sub_80DBF16(v3);
    if ( v7 > (long double)v8 )
    {
      v5 = i;
      v7 = v8;
    }
  }
  return v5;
}

//----- (080DACB8) --------------------------------------------------------
int __cdecl sub_80DACB8(int **a1, int a2)
{
  int result; // eax
  int *v3; // [esp+2Ch] [ebp-7Ch]
  char v4; // [esp+30h] [ebp-78h]
  int v5; // [esp+38h] [ebp-70h]
  char v6; // [esp+40h] [ebp-68h]
  char v7; // [esp+50h] [ebp-58h]
  float v8; // [esp+58h] [ebp-50h]
  int v9; // [esp+60h] [ebp-48h]
  float v10; // [esp+68h] [ebp-40h]
  float v11; // [esp+70h] [ebp-38h]
  char v12; // [esp+93h] [ebp-15h]

  v3 = *a1;
  if ( (*(_BYTE *)(a2 + 48) ^ 1) & 1 )
    return sub_80DBF54((_DWORD *)(a2 + 24), (_DWORD *)(a2 + 36));
  sub_80DBF54(v3 + 347, &v6);
  sub_80DBF54(v3 + 350, &v4);
  v5 = 1112014848;
  sub_80DBF54((_DWORD *)(a2 + 24), &v9);
  sub_80DC082((int)&v9, 31.0, a2, (int)&v9);
  sub_80DBF54(&v9, &v7);
  v8 = v8 - 18.0;
  sub_80DEBE4((int)a1, &v11, (int)&v9, (int)&v6, (int)&v4, (int)&v7, v3[51], (int)a1[15]);
  if ( v12 || v11 < 1.0 )
  {
    *(_DWORD *)(a2 + 48) &= 0xFFFFFFFE;
    result = sub_80DBF54((_DWORD *)(a2 + 24), (_DWORD *)(a2 + 36));
  }
  else
  {
    sub_80DBF54(&v7, (_DWORD *)(a2 + 36));
    result = a2;
    *(float *)(a2 + 44) = (v8 - v10) * v11 + v10;
  }
  return result;
}

//----- (080DAE2E) --------------------------------------------------------
int __cdecl sub_80DAE2E(int a1, int a2, int a3)
{
  signed int v3; // ebx
  signed int v4; // ST1C_4
  int result; // eax
  char v6; // [esp+20h] [ebp-28h]
  _DWORD *v7; // [esp+3Ch] [ebp-Ch]

  v7 = (_DWORD *)(a2 + 1468);
  *(float *)(a2 + 1468) = sub_80A29F6((float *)a3);
  v7[1] = 0;
  v7[2] = sub_80DAC38(*(float *)(a3 + 20), *(float *)(a3 + 32));
  v7[3] = *(_DWORD *)(a3 + 48);
  v3 = sub_80DA9FC((int)v7);
  v4 = sub_80DAA36((int)v7) + v3;
  sub_80DAAF2((int)v7, v4, (float *)&v6);
  sub_80DC006((float *)(a3 + 36), (float *)&v6, (float *)(a2 + 20));
  *(_DWORD *)(a2 + 12) |= 4u;
  *(_DWORD *)(a2 + 160) |= 0x4000u;
  sub_80DBF54((_DWORD *)(a3 + 36), (_DWORD *)(a1 + 232));
  *(_DWORD *)(a1 + 244) = v4;
  result = a1;
  *(_BYTE *)(a1 + 229) = 1;
  return result;
}

//----- (080DAF36) --------------------------------------------------------
int __cdecl sub_80DAF36(int a1, int a2, int a3, float a4)
{
  char *v4; // eax
  int v5; // ST0C_4
  signed int v7; // [esp+28h] [ebp-90h]
  _DWORD *v8; // [esp+2Ch] [ebp-8Ch]
  char v9; // [esp+30h] [ebp-88h]
  int v10; // [esp+38h] [ebp-80h]
  char v11; // [esp+40h] [ebp-78h]
  int v12; // [esp+50h] [ebp-68h]
  float v13; // [esp+58h] [ebp-60h]
  int v14; // [esp+60h] [ebp-58h]
  float v15; // [esp+68h] [ebp-50h]
  float v16; // [esp+70h] [ebp-48h]
  float v17; // [esp+7Ch] [ebp-3Ch]
  char v18; // [esp+93h] [ebp-25h]
  int v19; // [esp+ACh] [ebp-Ch]

  v8 = *(_DWORD **)a1;
  v19 = *(int *)(*(_DWORD *)a1 + 1400);
  v4 = va("Checking for ledge at %f units", a4);
  sub_80DA9D4((int)v4);
  sub_80DBF30(&v11, v19 ^ 0x80000000, v19 ^ 0x80000000, 0);
  *(float *)&v5 = *(float *)&v19 + *(float *)&v19;
  sub_80DBF30(&v9, v19, v19, v5);
  sub_80DBF54((_DWORD *)(a3 + 12), &v14);
  v15 = v15 + a4;
  sub_80DC082((int)&v14, 16.0, a3, (int)&v12);
  sub_80DEBE4(a1, &v16, (int)&v14, (int)&v11, (int)&v9, (int)&v12, v8[51], *(_DWORD *)(a1 + 60));
  if ( v18 || v16 < 1.0 )
  {
    sub_80DA9D4((int)"Mantle Failed: Ledge is too far away");
    v7 = 0;
  }
  else
  {
    sub_80DBF54(&v12, &v14);
    v13 = *(float *)(a3 + 20) + 18.0;
    sub_80DEBE4(a1, &v16, (int)&v14, (int)&v11, (int)&v9, (int)&v12, v8[51], *(_DWORD *)(a1 + 60));
    if ( v18 || v16 == 1.0 )
    {
      sub_80DA9D4((int)"Mantle Failed: Can't find ledge");
      v7 = 0;
    }
    else if ( v17 >= 0.69999999 )
    {
      sub_80DBF54(&v12, (_DWORD *)(a3 + 24));
      *(float *)(a3 + 32) = (v13 - v15) * v16 + v15;
      v10 = 1112014848;
      sub_80DEBE4(a1, &v16, a3 + 24, (int)&v11, (int)&v9, a3 + 24, v8[51], *(_DWORD *)(a1 + 60));
      if ( v18 )
      {
        sub_80DA9D4((int)"Mantle Failed: Player can't fit crouched on ledge");
        v7 = 0;
      }
      else
      {
        v8[370] |= 8u;
        *(_DWORD *)(a3 + 48) |= 8u;
        sub_80DA9D4((int)"Mantle available!");
        if ( *(_DWORD *)(a1 + 8) & 0x400 )
        {
          sub_80DACB8((int **)a1, a3);
          if ( !(v8[40] & 4) )
          {
            sub_80DEBE4(a1, &v16, a3 + 24, (int)(v8 + 347), (int)(v8 + 350), a3 + 24, v8[51], *(_DWORD *)(a1 + 60));
            if ( v18 )
              *(_DWORD *)(a3 + 48) |= 2u;
            sub_80DEBE4(a1, &v16, a3 + 36, (int)(v8 + 347), (int)(v8 + 350), a3 + 36, v8[51], *(_DWORD *)(a1 + 60));
            if ( !v18 )
              *(_DWORD *)(a3 + 48) |= 4u;
          }
          sub_80DAE2E(a1, (int)v8, a3);
          v7 = 1;
        }
        else
        {
          v7 = 1;
        }
      }
    }
    else
    {
      sub_80DA9D4((int)"Mantle Failed: Ledge is too steep");
      v7 = 0;
    }
  }
  return v7;
}

//----- (080DB380) --------------------------------------------------------
void __cdecl sub_80DB380(int a1)
{
  float v1; // ST00_4
  float v2; // ST00_4
  float v3; // ST00_4
  float v4; // ST00_4
  int j; // [esp+28h] [ebp-30h]
  int i; // [esp+2Ch] [ebp-2Ch]
  int v7; // [esp+30h] [ebp-28h]
  int v8; // [esp+40h] [ebp-18h]
  float v9; // [esp+44h] [ebp-14h]
  float v10; // [esp+48h] [ebp-10h]

  if ( !dword_857606C )
  {
    dword_857606C = (int)sub_80BA626("PLAYER_MANTLE", 11, a1);
    sub_80BA57A(dword_857606C, 0, off_81648C0, 1, 10, 0);
    for ( i = 1; i <= 10; ++i )
    {
      sub_80BA3AE((&off_81648C0)[i], (int)sub_80DA9B8);
      sub_80BA4D8(dword_857606C, i, (&off_81648C0)[i]);
    }
    for ( j = 0; j <= 6; ++j )
    {
      i = dword_8164860[3 * j];
      sub_80BF1A4(dword_857606C, i, (int)&v7, (int)&v8, 1.0);
      v1 = *(float *)&v8 - 16.0;
      if ( sub_80DBF16(v1) > 1.0 )
        Com_Error(
          1,
          "Mantle anim [%s] has X translation %f, should be %f\n",
          (&off_81648C0)[i],
          (_QWORD)v8,
          (double)16.0);
      if ( sub_80DBF16(v9) > 1.0 )
        Com_Error(1, "Mantle anim [%s] has Y translation %f, should be %f\n", (&off_81648C0)[i], v9, (double)0.0);
      v2 = v10 - flt_8164868[3 * j];
      if ( sub_80DBF16(v2) > 1.0 )
        Com_Error(
          1,
          "Mantle anim [%s] has Z translation %f, should be %f\n",
          (&off_81648C0)[i],
          v10,
          flt_8164868[3 * j]);
      i = dword_8164864[3 * j];
      sub_80BF1A4(dword_857606C, i, (int)&v7, (int)&v8, 1.0);
      v3 = *(float *)&v8 - 31.0;
      if ( sub_80DBF16(v3) > 1.0 )
        Com_Error(
          1,
          "Mantle anim [%s] has X translation %f, should be %f\n",
          (&off_81648C0)[i],
          (_QWORD)v8,
          (double)31.0);
      if ( sub_80DBF16(v9) > 1.0 )
        Com_Error(1, "Mantle anim [%s] has Y translation %f, should be %f\n", (&off_81648C0)[i], v9, (double)0.0);
      v4 = v10 - -18.0;
      if ( sub_80DBF16(v4) > 1.0 )
        Com_Error(1, "Mantle anim [%s] has Z translation %f, should be %f\n", (&off_81648C0)[i], v10, (double)-18.0);
    }
  }
}
// 8164860: using guessed type int dword_8164860[];
// 8164864: using guessed type int dword_8164864[];

//----- (080DB6CA) --------------------------------------------------------
void sub_80DB6CA()
{
  dword_857606C = 0;
}

//----- (080DB6DA) --------------------------------------------------------
signed int __cdecl sub_80DB6DA(int a1, _DWORD *a2, float *a3, unsigned int *a4)
{
  int *v4; // ST2C_4
  float v5; // ST38_4
  float v6; // ST3C_4
  float v7; // ST30_4
  float v8; // ST34_4
  signed int v10; // [esp+28h] [ebp-80h]
  int v11; // [esp+40h] [ebp-68h]
  int v12; // [esp+48h] [ebp-60h]
  int v13; // [esp+50h] [ebp-58h]
  int v14; // [esp+60h] [ebp-48h]
  char v15; // [esp+70h] [ebp-38h]
  char v16; // [esp+80h] [ebp-28h]
  float v17; // [esp+9Ch] [ebp-Ch]

  v4 = *(int **)a1;
  v17 = *(float *)(*(_DWORD *)a1 + 1400);
  sub_80DBF30(&v16, *(_DWORD *)(dword_8576060 + 8) ^ 0x80000000, *(_DWORD *)(dword_8576060 + 8) ^ 0x80000000, v4[349]);
  sub_80DBF30(&v15, *(_DWORD *)(dword_8576060 + 8), *(_DWORD *)(dword_8576060 + 8), v4[352]);
  v5 = v17 - *(float *)(dword_8576060 + 8);
  v6 = *(float *)(dword_857605C + 8) + v5;
  sub_80DBF54(a2, &v11);
  v12 = 0;
  sub_80A20C0((float *)&v11);
  sub_80DC082((int)(v4 + 5), COERCE_FLOAT(LODWORD(v5) ^ 0x80000000), (int)&v11, (int)&v14);
  sub_80DC082((int)(v4 + 5), v6, (int)&v11, (int)&v13);
  sub_80DEBE4(a1, a3, (int)&v14, (int)&v16, (int)&v15, (int)&v13, v4[51], 0x1000000);
  if ( *((_BYTE *)a3 + 35) || *((_BYTE *)a3 + 34) )
  {
    sub_80DA9D4((int)"Mantle Failed: Mantle brush is too thick");
    v10 = 0;
  }
  else if ( *a3 == 1.0 )
  {
    sub_80DA9D4((int)"Mantle Failed: No mantle surface found");
    v10 = 0;
  }
  else if ( (_DWORD)a3[4] & 0x6000000 )
  {
    sub_80DBF84((_DWORD *)a3 + 1, a4);
    a4[2] = 0;
    v7 = sub_80A20C0((float *)a4);
    if ( v7 >= 0.000099999997 )
    {
      v8 = sub_80DC0D6((float *)&v11, (float *)a4);
      if ( acos(v8) * 57.29577951308232 <= *(float *)(dword_8576064 + 8) )
      {
        v10 = 1;
      }
      else
      {
        sub_80DA9D4((int)"Mantle Failed: Player is not facing mantle surface");
        v10 = 0;
      }
    }
    else
    {
      sub_80DA9D4((int)"Mantle Failed: Mantle surface has vertical normal");
      v10 = 0;
    }
  }
  else
  {
    sub_80DA9D4((int)"Mantle Failed: No mantle surface with MANTLE_ON or MANTLE_OVER found");
    v10 = 0;
  }
  return v10;
}
// 857605C: using guessed type int dword_857605C;
// 8576060: using guessed type int dword_8576060;
// 8576064: using guessed type int dword_8576064;

//----- (080DB964) --------------------------------------------------------
void __cdecl sub_80DB964(int *a1, _DWORD *a2)
{
  _DWORD *v2; // [esp+1Ch] [ebp-8Ch]
  unsigned int v3[4]; // [esp+20h] [ebp-88h]
  char v4; // [esp+30h] [ebp-78h]
  int v5; // [esp+40h] [ebp-68h]
  char s; // [esp+60h] [ebp-48h]
  int v7; // [esp+6Ch] [ebp-3Ch]
  int v8; // [esp+90h] [ebp-18h]

  sub_80DA9D4((int)"====== Mantle Debug ======");
  if ( *(_BYTE *)(dword_8576054 + 8) )
  {
    v2 = (_DWORD *)*a1;
    sub_80DBE96(*a1);
    if ( v2[1] <= 5 )
    {
      if ( v2[3] & 4 )
      {
        sub_80DA9D4((int)"Mantle Failed: Player already mantling");
      }
      else if ( v2[40] & 0xC )
      {
        sub_80DA9D4((int)"Mantle Failed: Player not standing");
      }
      else if ( v2[54] <= 16 || v2[54] > 22 )
      {
        if ( (unsigned __int8)sub_80DB6DA((int)a1, a2, (float *)&v4, v3) )
        {
          memset(&s, 0, 0x38u);
          sub_80DBF54(v3, &s);
          sub_80DBF54(v2 + 5, &v7);
          if ( v5 & 0x4000000 )
            v8 |= 1u;
          if ( !(unsigned __int8)sub_80DAF36((int)a1, (int)a2, (int)&s, 60.0)
            && !(unsigned __int8)sub_80DAF36((int)a1, (int)a2, (int)&s, 40.0) )
          {
            sub_80DAF36((int)a1, (int)a2, (int)&s, 20.0);
          }
        }
      }
      else
      {
        sub_80DA9D4((int)"Mantle Failed: Player using binoculars");
      }
    }
    else
    {
      sub_80DA9D4((int)"Mantle Failed: Player is dead");
    }
  }
  else
  {
    sub_80DA9D4((int)"Mantle Failed: Not enabled");
  }
}
// 8576054: using guessed type int dword_8576054;

//----- (080DBB3C) --------------------------------------------------------
int __cdecl sub_80DBB3C(int a1, int a2, int a3)
{
  int result; // eax
  signed int v4; // ebx
  int v5; // ST18_4
  int v6; // ST10_4
  float v7; // ST04_4
  int v8; // [esp+14h] [ebp-44h]
  signed int v9; // [esp+1Ch] [ebp-3Ch]
  char v10; // [esp+20h] [ebp-38h]
  int v11; // [esp+30h] [ebp-28h]
  int v12; // [esp+4Ch] [ebp-Ch]

  result = dword_8576054;
  if ( *(_BYTE *)(dword_8576054 + 8) )
  {
    v12 = a2 + 1468;
    *(_DWORD *)(a2 + 1480) &= 0xFFFFFFF7;
    if ( *(_DWORD *)(v12 + 12) & 2 )
      sub_80DD554(141, 0, a2);
    v4 = sub_80DA9FC(v12);
    v8 = sub_80DAA36(v12) + v4;
    v9 = *(_DWORD *)(v12 + 4);
    *(_DWORD *)(v12 + 4) += *(_DWORD *)(a3 + 40);
    if ( *(_DWORD *)(v12 + 4) > v8 )
      *(_DWORD *)(v12 + 4) = v8;
    v5 = *(_DWORD *)(v12 + 4) - v9;
    sub_80DAAF2(v12, v9, (float *)&v10);
    sub_80DAAF2(v12, *(_DWORD *)(v12 + 4), (float *)&v11);
    v6 = sub_80DAA8E(v12);
    sub_80D6D82((_DWORD *)a2, 3, v6 + 20, 1);
    sub_80DC006((float *)&v11, (float *)&v10, (float *)&v11);
    sub_80DBFC2((float *)&v11, (float *)(a2 + 20), (float *)(a2 + 20));
    v7 = 1.0 / ((long double)v5 * 0.001);
    sub_80DC04A((int)&v11, v7, a2 + 32);
    result = *(_DWORD *)(v12 + 4);
    if ( result == v8 )
    {
      *(_DWORD *)(a2 + 12) &= 0xFFFFFFFB;
      *(_BYTE *)(a1 + 229) = 0;
      if ( *(_BYTE *)(v12 + 12) & 1 )
        sub_80D6FCA((_DWORD *)a2, 3, 0, 1);
      result = *(_DWORD *)(v12 + 12) & 4;
      if ( result )
      {
        sub_80DD554(140, 0, a2);
        result = *(_DWORD *)(a2 + 160) & 0xFFFFBFFF;
        *(_DWORD *)(a2 + 160) = result;
      }
    }
  }
  return result;
}
// 8576054: using guessed type int dword_8576054;

//----- (080DBD56) --------------------------------------------------------
void __usercall sub_80DBD56(long double a1@<st0>, int a2)
{
  float v2; // ST00_4
  float v3; // [esp+10h] [ebp-18h]
  float v4; // [esp+20h] [ebp-8h]

  if ( *(_BYTE *)(dword_8576054 + 8) )
  {
    sub_80A6258(*(float *)(a2 + 1468), *(float *)(a2 + 236));
    v4 = a1;
    if ( v4 < -*(float *)(dword_8576068 + 8) || *(float *)(dword_8576068 + 8) < (long double)v4 )
    {
      while ( -*(float *)(dword_8576068 + 8) > (long double)v4 )
        v4 = v4 + *(float *)(dword_8576068 + 8);
      while ( v4 > (long double)*(float *)(dword_8576068 + 8) )
        v4 = v4 - *(float *)(dword_8576068 + 8);
      v3 = *(float *)(dword_8576068 + 8);
      if ( v4 > 0.0 )
        HIBYTE(v3) ^= 0x80u;
      *(_DWORD *)(a2 + 88) += (unsigned __int16)(signed int)(v4 * 182.04445);
      v2 = *(float *)(a2 + 1468) + v3;
      *(float *)(a2 + 236) = sub_80A6154(v2);
    }
  }
}
// 8576054: using guessed type int dword_8576054;
// 8576068: using guessed type int dword_8576068;

//----- (080DBE96) --------------------------------------------------------
int __cdecl sub_80DBE96(int a1)
{
  int result; // eax

  result = a1;
  *(_DWORD *)(a1 + 1480) &= 0xFFFFFFF7;
  return result;
}

//----- (080DBEB0) --------------------------------------------------------
_BOOL4 __cdecl sub_80DBEB0(int a1)
{
  if ( !*(_BYTE *)(dword_8576054 + 8) )
    return 0;
  if ( *(_DWORD *)(a1 + 12) & 4 )
    return dword_8164864[3 * *(_DWORD *)(a1 + 1476)] != 10;
  return 0;
}
// 8164864: using guessed type int dword_8164864[];
// 8576054: using guessed type int dword_8576054;

//----- (080DBF16) --------------------------------------------------------
long double __cdecl sub_80DBF16(float a1)
{
  return (float)fabs(a1);
}

//----- (080DBF30) --------------------------------------------------------
int __cdecl sub_80DBF30(_DWORD *a1, int a2, int a3, int a4)
{
  int result; // eax

  *a1 = a2;
  a1[1] = a3;
  result = a4;
  a1[2] = a4;
  return result;
}

//----- (080DBF54) --------------------------------------------------------
int __cdecl sub_80DBF54(_DWORD *a1, _DWORD *a2)
{
  int result; // eax

  *a2 = *a1;
  a2[1] = a1[1];
  result = a1[2];
  a2[2] = result;
  return result;
}

//----- (080DBF84) --------------------------------------------------------
unsigned int __cdecl sub_80DBF84(_DWORD *a1, unsigned int *a2)
{
  unsigned int result; // eax

  *a2 = *a1 ^ 0x80000000;
  a2[1] = a1[1] ^ 0x80000000;
  result = a1[2] ^ 0x80000000;
  a2[2] = result;
  return result;
}

//----- (080DBFC2) --------------------------------------------------------
int __cdecl sub_80DBFC2(float *a1, float *a2, float *a3)
{
  int result; // eax

  *a3 = *a1 + *a2;
  a3[1] = a1[1] + a2[1];
  result = (int)(a1 + 2);
  a3[2] = a1[2] + a2[2];
  return result;
}

//----- (080DC006) --------------------------------------------------------
int __cdecl sub_80DC006(float *a1, float *a2, float *a3)
{
  int result; // eax

  *a3 = *a1 - *a2;
  a3[1] = a1[1] - a2[1];
  result = (int)(a1 + 2);
  a3[2] = a1[2] - a2[2];
  return result;
}

//----- (080DC04A) --------------------------------------------------------
int __cdecl sub_80DC04A(int a1, float a2, int a3)
{
  int result; // eax

  *(float *)a3 = a2 * *(float *)a1;
  *(float *)(a3 + 4) = a2 * *(float *)(a1 + 4);
  result = a1 + 8;
  *(float *)(a3 + 8) = a2 * *(float *)(a1 + 8);
  return result;
}

//----- (080DC082) --------------------------------------------------------
int __cdecl sub_80DC082(int a1, float a2, int a3, int a4)
{
  int result; // eax

  *(float *)a4 = a2 * *(float *)a3 + *(float *)a1;
  *(float *)(a4 + 4) = a2 * *(float *)(a3 + 4) + *(float *)(a1 + 4);
  result = a3 + 8;
  *(float *)(a4 + 8) = a2 * *(float *)(a3 + 8) + *(float *)(a1 + 8);
  return result;
}

//----- (080DC0D6) --------------------------------------------------------
long double __cdecl sub_80DC0D6(float *a1, float *a2)
{
  return *a1 * *a2 + a1[1] * a2[1] + a1[2] * a2[2];
}

//----- (080DC10C) --------------------------------------------------------
char *__usercall sub_80DC10C@<eax>(long double a1@<st0>)
{
  dword_8576074 = (int)Dvar_RegisterFloat(a1, "player_view_pitch_up", 1118437376, 0, 1119092736, 4480);
  dword_8576078 = (int)Dvar_RegisterFloat(a1, "player_view_pitch_down", 1118437376, 0, 1119092736, 4480);
  dword_857607C = (int)Dvar_RegisterFloat(a1, "bg_ladder_yawcap", 1120403456, 0, 1135869952, 4480);
  dword_8576080 = (int)Dvar_RegisterFloat(a1, "bg_prone_yawcap", 1118437376, 0, 1135869952, 4480);
  dword_8576084 = (int)Dvar_RegisterFloat(a1, "bg_foliagesnd_minspeed", 1109393408, 0, 2139095039, 4480);
  dword_8576088 = (int)Dvar_RegisterFloat(a1, "bg_foliagesnd_maxspeed", 1127481344, 0, 2139095039, 4480);
  dword_857608C = (int)Dvar_RegisterInt(a1, "bg_foliagesnd_slowinterval", 1500, 0, 0x7FFFFFFF, 4480);
  dword_8576090 = (int)Dvar_RegisterInt(a1, "bg_foliagesnd_fastinterval", 500, 0, 0x7FFFFFFF, 4480);
  dword_8576094 = (int)Dvar_RegisterInt(a1, "bg_foliagesnd_resetinterval", 500, 0, 0x7FFFFFFF, 4480);
  dword_8576098 = (int)Dvar_RegisterFloat(a1, "bg_fallDamageMinHeight", 1132462080, 1065353216, 2139095039, 4488);
  dword_857609C = (int)Dvar_RegisterFloat(a1, "bg_fallDamageMaxHeight", 1139802112, 1065353216, 2139095039, 4488);
  dword_85760A0 = (int)Dvar_RegisterFloat(a1, "inertiaMax", 1112014848, 0, 1148846080, 4480);
  dword_85760A4 = (int)Dvar_RegisterBool(a1, "inertiaDebug", 0, 4480);
  dword_85760A8 = (int)Dvar_RegisterFloat(a1, "inertiaAngle", 0, -1082130432, 1065353216, 4480);
  dword_85760B0 = (int)Dvar_RegisterFloat(a1, "friction", 1085276160, 0, 1120403456, 4480);
  dword_85760AC = (int)Dvar_RegisterFloat(a1, "stopspeed", 1120403456, 0, 1148846080, 4480);
  dword_85760B4 = (int)Dvar_RegisterFloat(a1, "bg_swingSpeed", 1045220557, 0, 1065353216, 4224);
  dword_85760B8 = (int)Dvar_RegisterFloat(a1, "bg_bobAmplitudeStanding", 1004888130, 0, 1065353216, 4480);
  dword_85760BC = (int)Dvar_RegisterFloat(a1, "bg_bobAmplitudeDucked", 1005961871, 0, 1065353216, 4480);
  dword_85760C0 = (int)Dvar_RegisterFloat(a1, "bg_bobAmplitudeProne", 1022739087, 0, 1065353216, 4480);
  dword_85760C4 = (int)Dvar_RegisterFloat(a1, "bg_bobMax", 1090519040, 0, 1108344832, 4480);
  dword_85760C8 = (int)Dvar_RegisterFloat(a1, "bg_aimSpreadMoveSpeedThreshold", 1093664768, 0, 1133903872, 4480);
  dword_85760CC = (int)Dvar_RegisterFloat(a1, "player_breath_hold_time", 1083179008, 0, 1106247680, 4480);
  dword_85760D0 = (int)Dvar_RegisterFloat(a1, "player_breath_gasp_time", 1065353216, 0, 1106247680, 4480);
  dword_85760D4 = (int)Dvar_RegisterFloat(a1, "player_breath_fire_delay", 0, 0, 1106247680, 4480);
  dword_85760D8 = (int)Dvar_RegisterFloat(a1, "player_breath_gasp_scale", 1083179008, 0, 1112014848, 4480);
  dword_85760DC = (int)Dvar_RegisterFloat(a1, "player_breath_hold_lerp", 1082130432, 0, 1112014848, 4480);
  dword_85760E0 = (int)Dvar_RegisterFloat(a1, "player_breath_gasp_lerp", 1086324736, 0, 1112014848, 4480);
  dword_85760E4 = (int)Dvar_RegisterFloat(a1, "player_breath_snd_lerp", 0x40000000, 0, 1120403456, 4480);
  dword_85760E8 = (int)Dvar_RegisterFloat(a1, "player_breath_snd_delay", 1065353216, 0, 0x40000000, 4480);
  dword_85760EC = (int)Dvar_RegisterBool(a1, "player_toggleBinoculars", 1, 4352);
  dword_85760F0 = (int)Dvar_RegisterBool(a1, "player_scopeExitOnDamage", 0, 4480);
  dword_85760F4 = (int)Dvar_RegisterInt(a1, "player_adsExitDelay", 0, 0, 1000, 4480);
  dword_85760F8 = (int)Dvar_RegisterFloat(a1, "player_moveThreshhold", 1092616192, 841731191, 1101004800, 4544);
  dword_85760FC = (int)Dvar_RegisterFloat(a1, "player_footstepsThreshhold", 0, 0, 1195593728, 4544);
  dword_8576100 = (int)Dvar_RegisterFloat(a1, "player_strafeSpeedScale", 1061997773, 0, 1101004800, 4480);
  dword_8576104 = (int)Dvar_RegisterFloat(a1, "player_backSpeedScale", 1060320051, 0, 1101004800, 4480);
  dword_8576108 = (int)Dvar_RegisterFloat(a1, "player_spectateSpeedScale", 0x40000000, 0, 1101004800, 4480);
  dword_857610C = (int)Dvar_RegisterBool(a1, "player_turnAnims", 0, 4480);
  dword_8576110 = (int)Dvar_RegisterFloat(a1, "player_dmgtimer_timePerPoint", 1120403456, 0, 2139095039, 4480);
  dword_8576114 = (int)Dvar_RegisterFloat(a1, "player_dmgtimer_maxTime", 1144750080, 0, 2139095039, 4480);
  dword_8576118 = (int)Dvar_RegisterFloat(a1, "player_dmgtimer_minScale", 0, 0, 1065353216, 4480);
  dword_857611C = (int)Dvar_RegisterInt(a1, "player_dmgtimer_stumbleTime", 500, 0, 2000, 4480);
  dword_8576120 = (int)Dvar_RegisterInt(a1, "player_dmgtimer_flinchTime", 500, 0, 2000, 4480);
  sub_80D9EE8(a1);
  return sub_80DA868(a1);
}
// 8576074: using guessed type int dword_8576074;
// 8576078: using guessed type int dword_8576078;
// 857607C: using guessed type int dword_857607C;
// 8576080: using guessed type int dword_8576080;
// 8576084: using guessed type int dword_8576084;
// 8576088: using guessed type int dword_8576088;
// 857608C: using guessed type int dword_857608C;
// 8576090: using guessed type int dword_8576090;
// 8576094: using guessed type int dword_8576094;
// 8576098: using guessed type int dword_8576098;
// 857609C: using guessed type int dword_857609C;
// 85760A0: using guessed type int dword_85760A0;
// 85760A4: using guessed type int dword_85760A4;
// 85760A8: using guessed type int dword_85760A8;
// 85760AC: using guessed type int dword_85760AC;
// 85760B0: using guessed type int dword_85760B0;
// 85760B4: using guessed type int dword_85760B4;
// 85760B8: using guessed type int dword_85760B8;
// 85760BC: using guessed type int dword_85760BC;
// 85760C0: using guessed type int dword_85760C0;
// 85760C4: using guessed type int dword_85760C4;
// 85760C8: using guessed type int dword_85760C8;
// 85760CC: using guessed type int dword_85760CC;
// 85760D0: using guessed type int dword_85760D0;
// 85760D4: using guessed type int dword_85760D4;
// 85760D8: using guessed type int dword_85760D8;
// 85760DC: using guessed type int dword_85760DC;
// 85760E0: using guessed type int dword_85760E0;
// 85760E4: using guessed type int dword_85760E4;
// 85760E8: using guessed type int dword_85760E8;
// 85760EC: using guessed type int dword_85760EC;
// 85760F0: using guessed type int dword_85760F0;
// 85760F4: using guessed type int dword_85760F4;
// 85760F8: using guessed type int dword_85760F8;
// 85760FC: using guessed type int dword_85760FC;
// 8576100: using guessed type int dword_8576100;
// 8576104: using guessed type int dword_8576104;
// 8576108: using guessed type int dword_8576108;
// 857610C: using guessed type int dword_857610C;
// 8576110: using guessed type int dword_8576110;
// 8576114: using guessed type int dword_8576114;
// 8576118: using guessed type int dword_8576118;
// 857611C: using guessed type int dword_857611C;
// 8576120: using guessed type int dword_8576120;

//----- (080DCAE6) --------------------------------------------------------
int __cdecl sub_80DCAE6(int a1)
{
  return 44 * a1 + 135679008;
}

//----- (080DCB02) --------------------------------------------------------
char *__cdecl sub_80DCB02(char *s1)
{
  int v2; // [esp+Ch] [ebp-Ch]
  signed int i; // [esp+14h] [ebp-4h]
  int v4; // [esp+14h] [ebp-4h]

  for ( i = 129; i < 131; ++i )
  {
    if ( !I_stricmp(*((char **)&unk_8164C20 + 11 * i + 5), s1) || !I_stricmp(*((char **)&unk_8164C20 + 11 * i), s1) )
      return (char *)&unk_8164C20 + 44 * i;
  }
  v4 = sub_811E940(s1);
  if ( v4 )
    v2 = 44 * v4 + 135679008;
  else
    v2 = 0;
  return (char *)v2;
}

//----- (080DCBB6) --------------------------------------------------------
_BOOL4 __cdecl sub_80DCBB6(float *a1, int a2, int a3)
{
  float v5; // [esp+20h] [ebp-18h]
  float v6; // [esp+24h] [ebp-14h]
  float v7; // [esp+28h] [ebp-10h]

  sub_80DCEB0(a2 + 12, a3, (int)&v5);
  return a1[5] - v5 <= 36.0
      && a1[5] - v5 >= -36.0
      && a1[6] - v6 <= 36.0
      && a1[6] - v6 >= -36.0
      && a1[7] - v7 <= 18.0
      && a1[7] - v7 >= -88.0;
}

//----- (080DCC7A) --------------------------------------------------------
_BOOL4 __cdecl sub_80DCC7A(_DWORD *a1, _DWORD *a2, int a3)
{
  char *v3; // eax
  signed int v5; // [esp+Ch] [ebp-Ch]
  char *v7; // [esp+14h] [ebp-4h]

  if ( a1[35] <= 0 || a1[35] >= 131 )
  {
    v3 = va(&byte_814DB20, a1[35], a1[1]);
    Com_Error(1, v3);
  }
  v7 = (char *)&unk_8164C20 + 44 * a1[35];
  if ( a1[36] != a2[51] )
  {
    v5 = *((_DWORD *)v7 + 7);
    if ( v5 != 1 )
    {
      if ( v5 > 1 )
      {
        if ( v5 == 2 )
        {
          if ( (unsigned __int8)sub_80D9E84((int)(a2 + 337), *((_DWORD *)v7 + 8)) )
          {
            if ( sub_80E9DE0((int)a2, *((_DWORD *)v7 + 8)) <= 0 )
              return 0;
          }
          else if ( !sub_80EACAE(*((_DWORD *)v7 + 8)) || sub_80E9DE0((int)a2, *((_DWORD *)v7 + 8)) <= 0 )
          {
            return 0;
          }
          return 1;
        }
        if ( v5 == 3 )
          return a2[75] < a2[77];
      }
      else if ( !v5 )
      {
        Com_Error(1, &byte_814DB64);
      }
      return 0;
    }
    if ( (unsigned __int8)sub_80E9882(*((_DWORD *)v7 + 8))
      && !(unsigned __int8)sub_80D9E84((int)(a2 + 337), *((_DWORD *)v7 + 8)) )
    {
      if ( a3 || sub_80E9DE0((int)a2, *((_DWORD *)v7 + 8)) <= 0 )
        return 0;
    }
    else if ( sub_80E9DE0((int)a2, *((_DWORD *)v7 + 8)) <= 0 )
    {
      return 0;
    }
    return 1;
  }
  return 0;
}

//----- (080DCEB0) --------------------------------------------------------
int __cdecl sub_80DCEB0(int a1, int a2, int a3)
{
  int result; // eax
  float v4; // ST08_4
  float v5; // ST08_4
  int v6; // [esp+30h] [ebp-28h]
  float v7; // [esp+48h] [ebp-10h]
  float v8; // [esp+4Ch] [ebp-Ch]

  switch ( *(_DWORD *)a1 )
  {
    case 0:
    case 1:
    case 6:
      result = sub_80DE966((_DWORD *)(a1 + 12), (_DWORD *)a3);
      break;
    case 2:
      v8 = (long double)(a2 - *(_DWORD *)(a1 + 4)) * 0.001;
      result = sub_80DEA94(a1 + 12, v8, a1 + 24, a3);
      break;
    case 3:
      if ( a2 > *(_DWORD *)(a1 + 4) + *(_DWORD *)(a1 + 8) )
        a2 = *(_DWORD *)(a1 + 4) + *(_DWORD *)(a1 + 8);
      v8 = (long double)(a2 - *(_DWORD *)(a1 + 4)) * 0.001;
      if ( v8 < 0.0 )
        v8 = 0.0;
      result = sub_80DEA94(a1 + 12, v8, a1 + 24, a3);
      break;
    case 4:
      v8 = (long double)(a2 - *(_DWORD *)(a1 + 4)) / (long double)*(signed int *)(a1 + 8);
      v7 = sin(v8 * 3.141592653589793 + v8 * 3.141592653589793);
      result = sub_80DEA94(a1 + 12, v7, a1 + 24, a3);
      break;
    case 5:
      v8 = (long double)(a2 - *(_DWORD *)(a1 + 4)) * 0.001;
      sub_80DEA94(a1 + 12, v8, a1 + 24, a3);
      result = a3 + 8;
      *(float *)(a3 + 8) = *(float *)(a3 + 8) - v8 * 400.0 * v8;
      break;
    case 7:
      if ( a2 > *(_DWORD *)(a1 + 4) + *(_DWORD *)(a1 + 8) )
        a2 = *(_DWORD *)(a1 + 4) + *(_DWORD *)(a1 + 8);
      v8 = (long double)(a2 - *(_DWORD *)(a1 + 4)) * 0.001;
      v7 = sub_80DEB1C(a1 + 24) / ((long double)*(signed int *)(a1 + 8) * 0.001);
      sub_80A2298((float *)(a1 + 24), a3);
      v4 = v7 * 0.5 * v8 * v8;
      result = sub_80DEA94(a1 + 12, v4, a3, a3);
      break;
    case 8:
      if ( a2 > *(_DWORD *)(a1 + 4) + *(_DWORD *)(a1 + 8) )
        a2 = *(_DWORD *)(a1 + 4) + *(_DWORD *)(a1 + 8);
      v8 = (long double)(a2 - *(_DWORD *)(a1 + 4)) * 0.001;
      v7 = sub_80DEB1C(a1 + 24) / ((long double)*(signed int *)(a1 + 8) * 0.001);
      sub_80A2298((float *)(a1 + 24), a3);
      sub_80DEA94(a1 + 12, v8, a1 + 24, (int)&v6);
      v5 = -v7 * 0.5 * v8 * v8;
      result = sub_80DEA94((int)&v6, v5, a3, a3);
      break;
  }
  return result;
}
// 80DEB1C: using guessed type double __cdecl sub_80DEB1C(_DWORD);

//----- (080DD224) --------------------------------------------------------
int __cdecl sub_80DD224(_DWORD *a1, int a2, int a3)
{
  int result; // eax
  float v4; // ST28_4
  float v5; // ST24_4
  float v6; // ST24_4
  float v7; // ST28_4
  float v8; // ST28_4
  float v9; // ST24_4
  float v10; // ST08_4
  float v11; // ST28_4

  switch ( *a1 )
  {
    case 0:
    case 1:
      result = sub_80DE918((_DWORD *)a3);
      break;
    case 2:
      result = sub_80DE966(a1 + 6, (_DWORD *)a3);
      break;
    case 3:
      if ( a2 <= a1[1] + a1[2] )
        result = sub_80DE966(a1 + 6, (_DWORD *)a3);
      else
        result = sub_80DE918((_DWORD *)a3);
      break;
    case 4:
      v4 = (long double)(a2 - a1[1]) / (long double)(signed int)a1[2];
      v5 = cos(v4 * 3.141592653589793 + v4 * 3.141592653589793);
      v6 = v5 * 0.5;
      result = sub_80DEA5C((int)(a1 + 6), v6, a3);
      break;
    case 5:
      v7 = (long double)(a2 - a1[1]) * 0.001;
      sub_80DE966(a1 + 6, (_DWORD *)a3);
      result = a3 + 8;
      *(float *)(a3 + 8) = *(float *)(a3 + 8) - v7 * 800.0;
      break;
    case 6:
      Com_Error(1, &byte_814DC20, *a1);
      return result;
    case 7:
      if ( a2 <= a1[1] + a1[2] )
      {
        v8 = (long double)(a2 - a1[1]) * 0.001;
        v9 = v8 / (long double)(signed int)a1[2];
        v10 = v8 * v8;
        result = sub_80DEA5C((int)(a1 + 6), v10, a3);
      }
      else
      {
        result = sub_80DE918((_DWORD *)a3);
      }
      break;
    case 8:
      if ( a2 <= a1[1] + a1[2] )
      {
        v11 = (long double)(a2 - a1[1]) * 0.001;
        result = sub_80DEA5C((int)(a1 + 6), v11, a3);
      }
      else
      {
        result = sub_80DE918((_DWORD *)a3);
      }
      break;
  }
  return result;
}

//----- (080DD452) --------------------------------------------------------
int __cdecl sub_80DD452(_DWORD *a1, int a2, _DWORD *a3)
{
  float v4; // [esp+1Ch] [ebp-2Ch]
  int v5; // [esp+20h] [ebp-28h]
  int v6; // [esp+30h] [ebp-18h]

  v4 = 0.30000001;
  if ( sub_80DEB1C(a2) >= 1.0 )
    sub_80DE966((_DWORD *)a2, &v5);
  else
    sub_80DE942(&v5, 0, 0, 1065353216);
  sub_80DE996(a1, (unsigned int *)&v6);
  sub_80A20C0((float *)&v6);
  if ( *(float *)(a2 + 8) > 0.80000001 )
    v4 = 0.69999999;
  while ( v4 > sub_80DEAE8((float *)&v6, (float *)&v5) )
  {
    sub_80DEA94((int)&v6, 0.5, (int)&v5, (int)&v6);
    sub_80A20C0((float *)&v6);
  }
  return sub_80DE966(&v6, a3);
}
// 80DEB1C: using guessed type double __cdecl sub_80DEB1C(_DWORD);

//----- (080DD554) --------------------------------------------------------
int __cdecl sub_80DD554(int a1, unsigned __int8 a2, int a3)
{
  int result; // eax

  if ( a1 )
  {
    *(_DWORD *)(a3 + 4 * (*(_DWORD *)(a3 + 164) & 3) + 168) = (unsigned __int8)a1;
    *(_DWORD *)(a3 + 4 * (*(_DWORD *)(a3 + 164) & 3) + 184) = a2;
    result = a3;
    ++*(_DWORD *)(result + 164);
  }
  return result;
}

//----- (080DD59E) --------------------------------------------------------
int __cdecl sub_80DD59E(int a1, int a2, int a3, unsigned __int8 a4)
{
  unsigned int v4; // edx
  unsigned int v5; // edx
  int result; // eax
  unsigned __int8 v7; // [esp+1Fh] [ebp-19h]
  int j; // [esp+20h] [ebp-18h]
  float v9; // [esp+24h] [ebp-14h]
  void (__cdecl *v10)(_DWORD, _DWORD); // [esp+28h] [ebp-10h]
  int i; // [esp+2Ch] [ebp-Ch]

  if ( *(_DWORD *)(a1 + 12) & 0xC00000 )
    *(_DWORD *)(a2 + 4) = 1;
  else
    *(_DWORD *)(a2 + 4) = 5;
  *(_DWORD *)(a2 + 12) = 1;
  sub_80DE966((_DWORD *)(a1 + 20), (_DWORD *)(a2 + 24));
  if ( a3 )
  {
    *(float *)(a2 + 24) = (long double)(signed int)*(float *)(a2 + 24);
    *(float *)(a2 + 28) = (long double)(signed int)*(float *)(a2 + 28);
    *(float *)(a2 + 32) = (long double)(signed int)*(float *)(a2 + 32);
  }
  *(_DWORD *)(a2 + 48) = 1;
  sub_80DE966((_DWORD *)(a1 + 232), (_DWORD *)(a2 + 60));
  if ( a3 )
  {
    *(float *)(a2 + 60) = (long double)(signed int)*(float *)(a2 + 60);
    *(float *)(a2 + 64) = (long double)(signed int)*(float *)(a2 + 64);
    *(float *)(a2 + 68) = (long double)(signed int)*(float *)(a2 + 68);
  }
  *(float *)(a2 + 108) = (long double)*(signed int *)(a1 + 156);
  *(_DWORD *)(a2 + 204) = *(_DWORD *)(a1 + 124);
  *(_DWORD *)(a2 + 208) = *(_DWORD *)(a1 + 132);
  *(_DWORD *)(a2 + 144) = *(_DWORD *)(a1 + 204);
  *(_DWORD *)(a2 + 8) = *(_DWORD *)(a1 + 160);
  if ( *(_DWORD *)(a1 + 160) & 0x300 )
    *(_DWORD *)(a2 + 116) = *(_DWORD *)(a1 + 1428);
  if ( *(_DWORD *)(a1 + 4) <= 5 )
    v4 = *(_DWORD *)(a2 + 8) & 0xFFFDFFFF;
  else
    v4 = *(_DWORD *)(a2 + 8) | 0x20000;
  *(_DWORD *)(a2 + 8) = v4;
  if ( *(_DWORD *)(a1 + 12) & 0x40 )
    v5 = *(_DWORD *)(a2 + 8) | 0x40000;
  else
    v5 = *(_DWORD *)(a2 + 8) & 0xFFFBFFFF;
  *(_DWORD *)(a2 + 8) = v5;
  *(_DWORD *)(a2 + 212) = *(_DWORD *)(a1 + 76);
  if ( sub_80DEE0E(a1) == 1 )
  {
    if ( *(_DWORD *)(a1 + 252) )
    {
      v9 = (long double)(*(_DWORD *)a1 - *(_DWORD *)(a1 + 252))
         / (long double)sub_80E1522(a1, *(_DWORD *)(a1 + 256), *(_DWORD *)(a1 + 260));
      if ( v9 >= 0.0 )
      {
        if ( v9 > 1.0 )
          v9 = 1.0;
      }
      else
      {
        v9 = 0.0;
      }
      if ( !*(_DWORD *)(a1 + 260) )
        v9 = 1.0 - v9;
    }
    else
    {
      v9 = 1.0;
    }
    *(float *)(a2 + 228) = *(float *)(a1 + 1448) * v9;
    *(float *)(a2 + 232) = sub_80A6112(*(float *)(a1 + 1452)) * v9;
    *(float *)(a2 + 236) = sub_80A6112(*(float *)(a1 + 1456)) * v9;
  }
  else
  {
    *(_DWORD *)(a2 + 228) = 0;
    *(_DWORD *)(a2 + 232) = 0;
    *(_DWORD *)(a2 + 236) = 0;
  }
  if ( *(_DWORD *)(a1 + 1484) - *(_DWORD *)(a1 + 164) >= 0 )
  {
    *(_DWORD *)(a2 + 160) = 0;
  }
  else
  {
    if ( *(_DWORD *)(a1 + 164) - *(_DWORD *)(a1 + 1484) > 4 )
      *(_DWORD *)(a1 + 1484) = *(_DWORD *)(a1 + 164) - 4;
    *(_DWORD *)(a2 + 160) = *(unsigned __int8 *)(a1 + 4 * ((*(_DWORD *)(a1 + 1484))++ & 3) + 184);
  }
  for ( i = *(_DWORD *)(a1 + 200); i != *(_DWORD *)(a1 + 164); ++i )
  {
    v7 = *(_BYTE *)(a1 + 4 * (i & 3) + 168);
    v10 = (void (__cdecl *)(_DWORD, _DWORD))dword_8166528[3 * a4];
    if ( v10 )
      v10(*(_DWORD *)a2, v7);
    for ( j = 0; dword_814D70C[j] > 0 && dword_814D70C[j] != v7; ++j )
      ;
    if ( dword_814D70C[j] < 0 )
    {
      *(_DWORD *)(a2 + 4 * (*(_DWORD *)(a2 + 164) & 3) + 168) = v7;
      *(_DWORD *)(a2 + 4 * ((*(_DWORD *)(a2 + 164))++ & 3) + 184) = *(unsigned __int8 *)(a1 + 4 * (i & 3) + 184);
    }
  }
  *(_DWORD *)(a1 + 200) = *(_DWORD *)(a1 + 164);
  *(_DWORD *)(a2 + 200) = *(unsigned __int8 *)(a1 + 212);
  result = *(unsigned __int16 *)(a1 + 96);
  *(_DWORD *)(a2 + 124) = result;
  return result;
}
// 8166528: using guessed type int dword_8166528[];

//----- (080DDAD0) --------------------------------------------------------
int __cdecl sub_80DDAD0(int a1, int a2, int a3, int a4, float a5, int a6, int a7, int a8, int a9, int a10, int a11, int a12, int a13, float a14)
{
  int v14; // ST08_4
  float v15; // ST04_4
  float v16; // ST04_4
  float v17; // ST4C_4
  float v18; // ST48_4
  float v19; // ST00_4
  float v20; // ST00_4
  char v23; // [esp+2Bh] [ebp-11Dh]
  void (__cdecl *v24)(float *, int *, float *, float *, int *, int, int); // [esp+2Ch] [ebp-11Ch]
  float v25; // [esp+30h] [ebp-118h]
  signed int v26; // [esp+34h] [ebp-114h]
  float v27; // [esp+38h] [ebp-110h]
  float v28; // [esp+40h] [ebp-108h]
  float v29; // [esp+44h] [ebp-104h]
  float v30; // [esp+44h] [ebp-104h]
  int v31; // [esp+50h] [ebp-F8h]
  float v32; // [esp+58h] [ebp-F0h]
  int v33; // [esp+60h] [ebp-E8h]
  float v34; // [esp+68h] [ebp-E0h]
  float v35[4]; // [esp+70h] [ebp-D8h]
  char v36; // [esp+80h] [ebp-C8h]
  char v37; // [esp+90h] [ebp-B8h]
  int v38; // [esp+A0h] [ebp-A8h]
  float v39; // [esp+A4h] [ebp-A4h]
  int v40; // [esp+B0h] [ebp-98h]
  float v41; // [esp+B8h] [ebp-90h]
  float v42[4]; // [esp+C0h] [ebp-88h]
  float v43[4]; // [esp+D0h] [ebp-78h]
  int v44; // [esp+E0h] [ebp-68h]
  float v45; // [esp+E4h] [ebp-64h]
  float v46; // [esp+E8h] [ebp-60h]
  int v47; // [esp+F0h] [ebp-58h]
  float v48; // [esp+F8h] [ebp-50h]
  float v49; // [esp+100h] [ebp-48h]
  float v50; // [esp+10Ch] [ebp-3Ch]
  char v51; // [esp+122h] [ebp-26h]
  int v52; // [esp+138h] [ebp-10h]
  char v53; // [esp+13Fh] [ebp-9h]

  v53 = a12;
  v26 = 0;
  v23 = 1;
  v24 = (void (__cdecl *)(float *, int *, float *, float *, int *, int, int))*(&off_8166520 + 3 * (unsigned __int8)a12);
  sub_80DE942(v43, a3 ^ 0x80000000, a3 ^ 0x80000000, 0);
  sub_80DE9D4(v43, (float *)a2, v43);
  sub_80DE942(v42, a3, a3, a4);
  sub_80DE9D4(v42, (float *)a2, v42);
  if ( a13 )
    v52 = 8519697;
  else
    v52 = 8454161;
  if ( !a9 )
  {
    sub_80DE942(v43, a3 ^ 0x80000000, a3 ^ 0x80000000, 0);
    sub_80DE942(v42, a3, a3, a4);
    sub_80DE966((_DWORD *)a2, &v47);
    sub_80DE966((_DWORD *)a2, &v44);
    v46 = v46 + 10.0;
    v24(&v49, &v47, v43, v42, &v44, a1, v52);
    if ( v51 )
      return 0;
  }
  if ( a10 && a11 && *(float *)(a11 + 8) < 0.69999999 )
    return 0;
  sub_80DE942(v43, -1061158912, -1061158912, -1061158912);
  sub_80DE942(v42, 1086324736, 1086324736, 1086324736);
  *(float *)&v14 = a5 - 180.0;
  sub_80DE942(&v44, 0, v14, 0);
  sub_80A2EC2((float *)&v44, (int)&v38, (float *)&v37, (float *)&v36);
  v28 = *(float *)&a4 - 6.0;
  sub_80DE966((_DWORD *)a2, &v47);
  v48 = v48 + v28;
  v15 = a14 - 6.0;
  sub_80DEA94((int)&v47, v15, (int)&v38, (int)&v44);
  v24(&v49, &v47, v43, v42, &v44, a1, v52);
  if ( v49 >= 1.0 )
  {
    v27 = a14;
  }
  else
  {
    if ( !a10 )
      return 0;
    v26 = 1;
    v27 = (a14 - 6.0) * v49 + 6.0;
    if ( *(float *)&a3 + 2.0 > v27 )
      return 0;
    if ( v28 * 0.69999999 + 48.0 > v27 )
    {
      v26 = 0;
      v46 = v46 + 22.0;
      sub_80DEA18((float *)&v44, (float *)&v47, (float *)&v40);
      v29 = sub_80A2298((float *)&v40, (int)&v38);
      v24(&v49, &v47, v43, v42, &v44, a1, v52);
      if ( v49 >= 1.0 )
      {
        v27 = a14;
      }
      else
      {
        v26 = 1;
        v27 = v49 * v29 + 6.0;
        if ( v28 * 0.69999999 + 48.0 > v27 )
          return 0;
      }
    }
  }
  sub_80DEB7A((int)&v47, (int)&v44, v49, (int)&v31);
  sub_80DEA94(a2, 48.0, (int)&v38, (int)&v47);
  v48 = v48 + v28;
  sub_80DE966(&v47, &v44);
  v46 = v46 - (*(float *)&a3 * 2.5 + v28 - 6.0);
  v24(&v49, &v47, v43, v42, &v44, a1, v52);
  if ( v49 != 1.0 )
  {
    if ( v50 < 0.69999999 )
      return 0;
    v25 = (*(float *)&a3 * 2.5 + v28 - 6.0) * v49 + 6.0;
    sub_80DEB7A((int)&v47, (int)&v44, v49, (int)&v33);
    v34 = v34 - 6.0;
    if ( !v26 )
      goto LABEL_30;
    if ( v25 * -0.75 <= v27 - v25 )
    {
      sub_80DEA18((float *)&v31, (float *)&v33, (float *)&v40);
      sub_80DEA94((int)&v40, 6.0, (int)&v38, (int)&v40);
      v41 = v41 + 6.0;
      sub_80A20C0((float *)&v40);
      v16 = a14 - 6.0 - 48.0;
      sub_80DEA94((int)&v47, v16, (int)&v40, (int)&v44);
      *(float *)&v44 = ((a14 - 6.0) * *(float *)&v38 + *(float *)a2 + *(float *)&v44) * 0.5;
      v45 = ((a14 - 6.0) * v39 + *(float *)(a2 + 4) + v45) * 0.5;
      v24(&v49, &v47, v43, v42, &v44, a1, v52);
      if ( v49 >= 1.0
        || (sub_80DEB7A((int)&v47, (int)&v44, v49, (int)&v47),
            v48 = v48 + 18.0,
            v46 = v46 + 18.0,
            v24(&v49, &v47, v43, v42, &v44, a1, v52),
            v49 >= 1.0) )
      {
        sub_80DEB7A((int)&v47, (int)&v44, v49, (int)&v31);
LABEL_30:
        sub_80DE966(&v31, &v47);
        sub_80DE966(&v47, &v44);
        v46 = v46 - (v48 - v34 + v48 - v34 + *(float *)&a3);
        v24(&v49, &v47, v43, v42, &v44, a1, v52);
        if ( v49 != 1.0 )
        {
          if ( v50 < 0.69999999 )
            return 0;
          sub_80DEB7A((int)&v47, (int)&v44, v49, (int)&v31);
          v32 = v32 - 6.0;
          sub_80DE966((_DWORD *)a2, v35);
          sub_80DEA18((float *)&v33, v35, (float *)&v40);
          v17 = sub_80A2AF6((float *)&v40);
          sub_80DEA18((float *)&v31, (float *)&v33, (float *)&v40);
          v18 = sub_80A2AF6((float *)&v40);
          v30 = sub_80A6000(v18, v17);
          if ( v30 < -50.0 || v30 > 70.0 )
            v23 = 0;
          sub_80DE942(v43, 2147483648, 2147483648, 2147483648);
          sub_80DE942(v42, 0, 0, 0);
          sub_80DE966(v35, &v47);
          v48 = v48 + 5.0;
          sub_80DE966(&v33, &v44);
          v46 = v46 + 5.0;
          v24(&v49, &v47, v43, v42, &v44, a1, v52);
          if ( v49 < 1.0 )
            v23 = 0;
          sub_80DE966(&v44, &v47);
          sub_80DE966(&v31, &v44);
          v46 = v46 + 5.0;
          v24(&v49, &v47, v43, v42, &v44, a1, v52);
          if ( v49 < 1.0 )
            v23 = 0;
          if ( a6 )
            *(_DWORD *)a6 = 0;
          if ( a7 )
          {
            sub_80DEA18(v35, (float *)&v33, (float *)&v40);
            v19 = sub_80A2AF6((float *)&v40);
            *(float *)a7 = sub_80A6112(v19);
          }
          if ( a8 )
          {
            sub_80DEA18((float *)&v33, (float *)&v31, (float *)&v40);
            v20 = sub_80A2AF6((float *)&v40);
            *(float *)a8 = sub_80A6112(v20);
          }
          if ( v23 )
            return 1;
        }
        goto LABEL_48;
      }
    }
  }
LABEL_48:
  if ( a10 )
    return 0;
  if ( a6 )
    *(_DWORD *)a6 = 0;
  if ( a7 )
    *(_DWORD *)a7 = 0;
  if ( a8 )
    *(_DWORD *)a8 = 0;
  return 1;
}
// 8166520: using guessed type int (__cdecl *off_8166520)(void *s, int, int, int, int, int, int);

//----- (080DE734) --------------------------------------------------------
int __cdecl sub_80DE734(int a1, int a2, int a3, int a4, float a5, int a6, int a7, int a8, int a9, int a10, int a11, int a12, int a13, float a14)
{
  return sub_80DDAD0(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, (unsigned __int8)a12, a13, a14);
}

//----- (080DE918) --------------------------------------------------------
int __cdecl sub_80DE918(_DWORD *a1)
{
  int result; // eax

  *a1 = 0;
  a1[1] = 0;
  result = 0;
  a1[2] = 0;
  return result;
}

//----- (080DE942) --------------------------------------------------------
int __cdecl sub_80DE942(_DWORD *a1, int a2, int a3, int a4)
{
  int result; // eax

  *a1 = a2;
  a1[1] = a3;
  result = a4;
  a1[2] = a4;
  return result;
}

//----- (080DE966) --------------------------------------------------------
int __cdecl sub_80DE966(_DWORD *a1, _DWORD *a2)
{
  int result; // eax

  *a2 = *a1;
  a2[1] = a1[1];
  result = a1[2];
  a2[2] = result;
  return result;
}

//----- (080DE996) --------------------------------------------------------
unsigned int __cdecl sub_80DE996(_DWORD *a1, unsigned int *a2)
{
  unsigned int result; // eax

  *a2 = *a1 ^ 0x80000000;
  a2[1] = a1[1] ^ 0x80000000;
  result = a1[2] ^ 0x80000000;
  a2[2] = result;
  return result;
}

//----- (080DE9D4) --------------------------------------------------------
int __cdecl sub_80DE9D4(float *a1, float *a2, float *a3)
{
  int result; // eax

  *a3 = *a1 + *a2;
  a3[1] = a1[1] + a2[1];
  result = (int)(a1 + 2);
  a3[2] = a1[2] + a2[2];
  return result;
}

//----- (080DEA18) --------------------------------------------------------
int __cdecl sub_80DEA18(float *a1, float *a2, float *a3)
{
  int result; // eax

  *a3 = *a1 - *a2;
  a3[1] = a1[1] - a2[1];
  result = (int)(a1 + 2);
  a3[2] = a1[2] - a2[2];
  return result;
}

//----- (080DEA5C) --------------------------------------------------------
int __cdecl sub_80DEA5C(int a1, float a2, int a3)
{
  int result; // eax

  *(float *)a3 = a2 * *(float *)a1;
  *(float *)(a3 + 4) = a2 * *(float *)(a1 + 4);
  result = a1 + 8;
  *(float *)(a3 + 8) = a2 * *(float *)(a1 + 8);
  return result;
}

//----- (080DEA94) --------------------------------------------------------
int __cdecl sub_80DEA94(int a1, float a2, int a3, int a4)
{
  int result; // eax

  *(float *)a4 = a2 * *(float *)a3 + *(float *)a1;
  *(float *)(a4 + 4) = a2 * *(float *)(a3 + 4) + *(float *)(a1 + 4);
  result = a3 + 8;
  *(float *)(a4 + 8) = a2 * *(float *)(a3 + 8) + *(float *)(a1 + 8);
  return result;
}

//----- (080DEAE8) --------------------------------------------------------
long double __cdecl sub_80DEAE8(float *a1, float *a2)
{
  return *a1 * *a2 + a1[1] * a2[1] + a1[2] * a2[2];
}

//----- (080DEB1C) --------------------------------------------------------
void __cdecl sub_80DEB1C(float *a1)
{
  float v1; // ST00_4

  v1 = *a1 * *a1 + a1[1] * a1[1] + a1[2] * a1[2];
  sub_80DEB5A(v1);
}

//----- (080DEB5A) --------------------------------------------------------
long double __cdecl sub_80DEB5A(float a1)
{
  return (float)sqrt(a1);
}

//----- (080DEB7A) --------------------------------------------------------
int __cdecl sub_80DEB7A(int a1, int a2, float a3, int a4)
{
  int result; // eax

  *(float *)a4 = (*(float *)a2 - *(float *)a1) * a3 + *(float *)a1;
  *(float *)(a4 + 4) = (*(float *)(a2 + 4) - *(float *)(a1 + 4)) * a3 + *(float *)(a1 + 4);
  result = a2 + 8;
  *(float *)(a4 + 8) = (*(float *)(a2 + 8) - *(float *)(a1 + 8)) * a3 + *(float *)(a1 + 8);
  return result;
}

//----- (080DEBE4) --------------------------------------------------------
int __cdecl sub_80DEBE4(int a1, void *a2, int a3, int a4, int a5, int a6, int a7, int a8)
{
  return (*(&off_8166520 + 3 * *(unsigned __int8 *)(a1 + 228)))(a2, a3, a4, a5, a6, a7, a8);
}
// 8166520: using guessed type int (__cdecl *off_8166520)(void *s, int, int, int, int, int, int);

//----- (080DEC3C) --------------------------------------------------------
int __cdecl sub_80DEC3C(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8)
{
  int result; // eax

  (*(&off_8166520 + 3 * *(unsigned __int8 *)(a1 + 228)))((void *)a2, a3, a4, a5, a6, a7, a8);
  result = a2;
  if ( *(_BYTE *)(a2 + 35) )
  {
    result = *(_DWORD *)(a2 + 20) & 0x2000000;
    if ( result )
    {
      sub_80DED50(a1, *(unsigned __int16 *)(a2 + 28));
      *(_DWORD *)(a1 + 60) &= 0xFDFFFFFF;
      result = (*(&off_8166520 + 3 * *(unsigned __int8 *)(a1 + 228)))((void *)a2, a3, a4, a5, a6, a7, a8 & 0xFDFFFFFF);
    }
  }
  return result;
}
// 8166520: using guessed type int (__cdecl *off_8166520)(void *s, int, int, int, int, int, int);

//----- (080DED2E) --------------------------------------------------------
int __cdecl sub_80DED2E(int a1, int a2)
{
  return sub_80DD554(a2, 0, a1);
}

//----- (080DED50) --------------------------------------------------------
int __cdecl sub_80DED50(int a1, int a2)
{
  int result; // eax
  int i; // [esp+0h] [ebp-4h]

  if ( a2 != 1022 )
  {
    result = a1;
    if ( *(_DWORD *)(a1 + 64) != 32 )
    {
      for ( i = 0; i < *(_DWORD *)(a1 + 64); ++i )
      {
        result = *(_DWORD *)(a1 + 4 * i + 68);
        if ( result == a2 )
          return result;
      }
      *(_DWORD *)(a1 + 4 * *(_DWORD *)(a1 + 64) + 68) = a2;
      result = a1;
      ++*(_DWORD *)(result + 64);
    }
  }
  return result;
}

//----- (080DEDB0) --------------------------------------------------------
int __cdecl sub_80DEDB0(float *a1, float *a2, int a3)
{
  float v3; // ST14_4
  float v4; // ST14_4

  v3 = sub_80E724C(a1, a2);
  v4 = v3 - sub_80E6E42(v3) * 0.001;
  return sub_80E71F8((int)a1, COERCE_FLOAT(LODWORD(v4) ^ 0x80000000), (int)a2, a3);
}

//----- (080DEE0E) --------------------------------------------------------
signed int __cdecl sub_80DEE0E(int a1)
{
  signed int v2; // [esp+0h] [ebp-4h]

  if ( *(_DWORD *)(a1 + 244) == 40 )
    v2 = 2;
  else
    v2 = *(_DWORD *)(a1 + 244) == 11;
  return v2;
}

//----- (080DEE4A) --------------------------------------------------------
int __cdecl sub_80DEE4A(int a1, int a2)
{
  int result; // eax
  float v3; // ST24_4
  float v4; // [esp+18h] [ebp-30h]
  float v5; // [esp+1Ch] [ebp-2Ch]
  float v6; // [esp+20h] [ebp-28h]
  float v7; // [esp+24h] [ebp-24h]
  float v8; // [esp+28h] [ebp-20h]
  float *v9; // [esp+2Ch] [ebp-1Ch]
  char v10; // [esp+30h] [ebp-18h]
  int v11; // [esp+38h] [ebp-10h]

  v9 = (float *)(a1 + 32);
  sub_80E70CA((_DWORD *)(a1 + 32), &v10);
  if ( *(_DWORD *)(a2 + 44) )
    v11 = 0;
  v8 = sub_80E72B4(&v10);
  if ( v8 < 1.0 )
    return sub_80E707C(v9);
  v5 = 0.0;
  if ( *(_DWORD *)(a2 + 44) && !(*(_DWORD *)(a2 + 72) & 2) && !(*(_DWORD *)(a1 + 12) & 0x400) )
  {
    if ( *(float *)(dword_85760AC + 8) <= (long double)v8 )
      v4 = v8;
    else
      v4 = *(float *)(dword_85760AC + 8);
    v6 = v4;
    if ( *(_DWORD *)(a1 + 12) & 0x200 )
    {
      v6 = v4 * 0.30000001;
    }
    else if ( *(_DWORD *)(a1 + 12) & 0x80000 )
    {
      v6 = sub_80DA1F8(a1) * v4;
    }
    v5 = v6 * *(float *)(dword_85760B0 + 8) * *(float *)(a2 + 36) + 0.0;
  }
  if ( *(_DWORD *)(a1 + 4) == 4 )
    v5 = v8 * 5.0 * *(float *)(a2 + 36) + v5;
  v7 = v8 - v5;
  if ( v7 < 0.0 )
    v7 = 0.0;
  v3 = v7 / v8;
  *v9 = *v9 * v3;
  *(float *)(a1 + 36) = *(float *)(a1 + 36) * v3;
  result = a1 + 40;
  *(float *)(a1 + 40) = *(float *)(a1 + 40) * v3;
  return result;
}
// 80E72B4: using guessed type double __cdecl sub_80E72B4(_DWORD);
// 85760AC: using guessed type int dword_85760AC;
// 85760B0: using guessed type int dword_85760B0;

//----- (080DEFE8) --------------------------------------------------------
int __cdecl sub_80DEFE8(int a1, float a2, int a3)
{
  int v5; // [esp+40h] [ebp-18h]
  float v6; // [esp+44h] [ebp-14h]
  float v7; // [esp+48h] [ebp-10h]
  float v8; // [esp+4Ch] [ebp-Ch]
  float v9; // [esp+54h] [ebp-4h]

  sub_80E6FD6(a1 + 32, a2, a3, (int)&v5);
  sub_80E6F38((_DWORD *)(a1 + 44), &v7);
  sub_80A215E(&v7);
  sub_80A215E((float *)&v5);
  v9 = sub_80E700C(&v7, (float *)&v5);
  if ( v9 >= (long double)*(float *)(dword_85760A8 + 8) )
    return 0;
  if ( *(_BYTE *)(dword_85760A4 + 8) )
  {
    Com_Printf("angle is %f (oldVel is (%f,%f), vel is (%f, %f))\n", v9, v7, v8, (_QWORD)v5, v6);
    Com_Printf("clamping acceleration from %f to %f\n", a2, *(float *)(dword_85760A0 + 8));
  }
  return 1;
}
// 85760A0: using guessed type int dword_85760A0;
// 85760A4: using guessed type int dword_85760A4;
// 85760A8: using guessed type int dword_85760A8;

//----- (080DF0DA) --------------------------------------------------------
long double __cdecl sub_80DF0DA(int a1, float a2, int a3)
{
  float v4; // [esp+14h] [ebp-4h]

  if ( *(_DWORD *)(a1 + 4) == 2 )
  {
    v4 = a2;
  }
  else if ( *(float *)(dword_85760A0 + 8) < (long double)a2 )
  {
    if ( sub_80E702E((float *)(a1 + 44)) >= 0.0001 )
    {
      if ( (unsigned __int8)sub_80DEFE8(a1, a2, a3) )
        v4 = *(float *)(dword_85760A0 + 8);
      else
        v4 = a2;
    }
    else
    {
      v4 = a2;
    }
  }
  else
  {
    v4 = a2;
  }
  return v4;
}
// 85760A0: using guessed type int dword_85760A0;

//----- (080DF16A) --------------------------------------------------------
void __cdecl sub_80DF16A(int a1, int a2, int a3, float a4, float a5)
{
  float v5; // [esp+1Ch] [ebp-4Ch]
  int v6; // [esp+20h] [ebp-48h]
  int v7; // [esp+30h] [ebp-38h]
  float v8; // [esp+4Ch] [ebp-1Ch]
  float v9; // [esp+50h] [ebp-18h]
  float v10; // [esp+54h] [ebp-14h]
  float v11; // [esp+58h] [ebp-10h]
  float v12; // [esp+5Ch] [ebp-Ch]

  if ( *(_DWORD *)(a1 + 12) & 0x20 )
  {
    sub_80E71C0(a3, a4, (int)&v7);
    sub_80E717C((float *)&v7, (float *)(a1 + 32), (float *)&v6);
    v8 = sub_80A20C0((float *)&v6);
    v9 = a5 * *(float *)(a2 + 36) * a4;
    if ( v9 > (long double)v8 )
      v9 = v8;
    sub_80E71F8(a1 + 32, v9, (int)&v6, a1 + 32);
  }
  else
  {
    v10 = sub_80E724C((float *)(a1 + 32), (float *)a3);
    v12 = a4 - v10;
    if ( v12 > 0.0 )
    {
      if ( *(float *)(dword_85760AC + 8) <= (long double)a4 )
        v5 = a4;
      else
        v5 = *(float *)(dword_85760AC + 8);
      v8 = v5;
      v11 = a5 * *(float *)(a2 + 36) * v5;
      if ( v11 > (long double)v12 )
        v11 = v12;
      v9 = sub_80DF0DA(a1, v11, a3);
      sub_80E71F8(a1 + 32, v9, a3, a1 + 32);
    }
  }
}
// 85760AC: using guessed type int dword_85760AC;

//----- (080DF2DE) --------------------------------------------------------
long double __cdecl sub_80DF2DE(int a1, float a2, float a3, float a4)
{
  float v4; // ST00_4
  float v5; // ST10_4
  float v7; // [esp+4h] [ebp-14h]
  float v8; // [esp+Ch] [ebp-Ch]
  float v9; // [esp+14h] [ebp-4h]

  v9 = fabs(a2);
  if ( fabs(a3) > v9 )
    v9 = fabs(a3);
  if ( fabs(a4) > v9 )
    v9 = fabs(a4);
  if ( v9 == 0.0 )
  {
    v7 = 0.0;
  }
  else
  {
    v4 = a2 * a2 + a3 * a3 + a4 * a4;
    v5 = sub_80E6E5C(v4);
    v8 = (long double)*(signed int *)(a1 + 80) * v9 / (v5 * 127.0);
    if ( *(_DWORD *)(a1 + 12) & 0x100 || *(float *)(a1 + 76) != 0.0 )
      v8 = v8 * 0.40000001;
    if ( *(_DWORD *)(a1 + 4) == 2 )
      v8 = v8 * 3.0;
    if ( *(_DWORD *)(a1 + 4) == 3 )
      v8 = v8 * 6.0;
    if ( *(_DWORD *)(a1 + 4) == 4 )
      v8 = v8 * *(float *)(dword_8576108 + 8);
    v7 = v8;
  }
  return v7;
}
// 8576108: using guessed type int dword_8576108;

//----- (080DF3FA) --------------------------------------------------------
long double __cdecl sub_80DF3FA(int a1, int a2)
{
  float v2; // ST04_4
  int v4; // [esp+Ch] [ebp-1Ch]
  int v5; // [esp+10h] [ebp-18h]
  int v6; // [esp+14h] [ebp-14h]
  float v7; // [esp+18h] [ebp-10h]
  float v8; // [esp+1Ch] [ebp-Ch]
  float v9; // [esp+20h] [ebp-8h]
  signed int v10; // [esp+24h] [ebp-4h]

  v2 = (long double)(*(char *)(a2 + 25) * (signed int)*(char *)(a2 + 25)
                   + *(char *)(a2 + 24) * (signed int)*(char *)(a2 + 24));
  v9 = sub_80E6E5C(v2);
  v6 = *(char *)(a2 + 24);
  if ( v6 < 0 )
    v6 = -v6;
  v10 = v6;
  v5 = *(char *)(a2 + 25);
  if ( v5 < 0 )
    v5 = -v5;
  if ( v5 > v6 )
  {
    v4 = *(char *)(a2 + 25);
    if ( v4 < 0 )
      v4 = -v4;
    v10 = v4;
  }
  if ( v10 )
  {
    v8 = (long double)*(signed int *)(a1 + 80) * (long double)v10 / (v9 * 127.0);
    if ( *(_DWORD *)(a1 + 12) & 0x100 || *(float *)(a1 + 76) != 0.0 )
      v8 = v8 * 0.40000001;
    if ( *(_DWORD *)(a1 + 4) == 2 )
      v8 = v8 * 3.0;
    if ( *(_DWORD *)(a1 + 4) == 3 )
      v8 = v8 * 6.0;
    if ( *(_DWORD *)(a1 + 4) == 4 )
      v8 = v8 * *(float *)(dword_8576108 + 8);
    v7 = v8;
  }
  else
  {
    v7 = 0.0;
  }
  return v7;
}
// 8576108: using guessed type int dword_8576108;

//----- (080DF534) --------------------------------------------------------
long double __cdecl sub_80DF534(int *a1, int a2)
{
  float v2; // ST04_4
  float v3; // ST34_4
  float v4; // ST04_4
  long double v5; // fst7
  float v6; // ST30_4
  float v8; // [esp+0h] [ebp-38h]
  float v9; // [esp+14h] [ebp-24h]
  signed int v10; // [esp+18h] [ebp-20h]
  float v11; // [esp+1Ch] [ebp-1Ch]
  float v12; // [esp+1Ch] [ebp-1Ch]
  int v13; // [esp+20h] [ebp-18h]
  float v14; // [esp+24h] [ebp-14h]
  float v15; // [esp+28h] [ebp-10h]
  float v16; // [esp+34h] [ebp-4h]

  v13 = *a1;
  v2 = (long double)(*(char *)(a2 + 25) * (signed int)*(char *)(a2 + 25)
                   + *(char *)(a2 + 24) * (signed int)*(char *)(a2 + 24));
  v14 = sub_80E6E5C(v2);
  if ( *(_BYTE *)(a2 + 24) >= 0 )
    v8 = (long double)*(char *)(a2 + 24);
  else
    v8 = (long double)*(char *)(a2 + 24) * *(float *)(dword_8576104 + 8);
  v3 = sub_80E6E42(v8);
  v4 = (long double)*(char *)(a2 + 25) * *(float *)(dword_8576100 + 8);
  v5 = sub_80E6E42(v4);
  v6 = v5;
  sub_80E6E7C(v3, v6);
  v16 = v5;
  if ( v16 == 0.0 )
  {
    v9 = 0.0;
  }
  else
  {
    v15 = (long double)*(signed int *)(v13 + 80) * v16 / (v14 * 127.0);
    if ( *(_DWORD *)(v13 + 12) & 0x100 || *(float *)(v13 + 76) != 0.0 )
      v15 = v15 * 0.40000001;
    if ( *(_DWORD *)(v13 + 4) == 2 )
    {
      v15 = v15 * 3.0;
    }
    else if ( *(_DWORD *)(v13 + 4) == 3 )
    {
      v15 = v15 * 6.0;
    }
    else
    {
      v10 = sub_80DEE0E(v13);
      v11 = sub_80E168A(a1, 40, 11);
      if ( v11 == 0.0 )
      {
        v12 = sub_80E168A(a1, 11, 40);
        if ( v12 == 0.0 )
        {
          if ( v10 == 1 )
          {
            v15 = v15 * 0.15000001;
          }
          else if ( v10 == 2 )
          {
            v15 = v15 * 0.64999998;
          }
        }
        else
        {
          v15 = (v12 * 0.64999998 + (1.0 - v12) * 0.15000001) * v15;
        }
      }
      else
      {
        v15 = (v11 * 0.15000001 + (1.0 - v11) * 0.64999998) * v15;
      }
    }
    if ( *(_DWORD *)(v13 + 212) && *(float *)(sub_80E9270(*(_DWORD *)(v13 + 212)) + 612) > 0.0 )
      v15 = v15 * *(float *)(sub_80E9270(*(_DWORD *)(v13 + 212)) + 612);
    if ( *(_DWORD *)(a2 + 4) & 0x800 )
      v15 = v15 * 0.40000001;
    v9 = v15;
  }
  return v9;
}
// 8576100: using guessed type int dword_8576100;
// 8576104: using guessed type int dword_8576104;

//----- (080DF7FC) --------------------------------------------------------
long double __cdecl sub_80DF7FC(signed int a1)
{
  float v1; // ST08_4
  float v2; // ST14_4
  float v4; // [esp+4h] [ebp-14h]
  float v5; // [esp+10h] [ebp-8h]

  if ( a1 )
  {
    v5 = *(float *)(dword_8576114 + 8);
    if ( v5 == 0.0 )
    {
      v4 = 1.0;
    }
    else
    {
      v1 = -*(float *)(dword_8576118 + 8) / v5;
      v2 = (long double)a1 * v1 + 1.0;
      v4 = v2;
    }
  }
  else
  {
    v4 = 1.0;
  }
  return v4;
}
// 8576114: using guessed type int dword_8576114;
// 8576118: using guessed type int dword_8576118;

//----- (080DF868) --------------------------------------------------------
int __usercall sub_80DF868@<eax>(long double a1@<st0>, int a2, int a3)
{
  int result; // eax
  long double v4; // fst7
  long double v5; // fst7
  float v6; // ST00_4
  int v7; // [esp+10h] [ebp-58h]
  int v8; // [esp+14h] [ebp-54h]
  int v9; // [esp+18h] [ebp-50h]
  char v10; // [esp+20h] [ebp-48h]
  float v11; // [esp+24h] [ebp-44h]
  int v12; // [esp+38h] [ebp-30h]
  int v13; // [esp+3Ch] [ebp-2Ch]
  char v14; // [esp+40h] [ebp-28h]
  float v15; // [esp+5Ch] [ebp-Ch]

  v12 = *(_DWORD *)a2;
  if ( !(*(_BYTE *)(v12 + 12) & 1) || *(_DWORD *)(v12 + 160) & 0x300 )
  {
    if ( *(_DWORD *)(v12 + 12) & 0x20 )
    {
      v4 = sub_80A29F6((float *)(v12 + 100)) + 180.0;
      v15 = v4;
      sub_80A6258(v15, *(float *)(v12 + 236));
      v13 = (signed int)v4;
      v8 = (signed int)v4;
      if ( (signed int)v4 < 0 )
        v8 = -v8;
      if ( v8 > 90 )
      {
        if ( v13 <= 0 )
          v13 = -90;
        else
          v13 = 90;
      }
      result = (char)v13;
      *(_DWORD *)(v12 + 156) = (char)v13;
    }
    else
    {
      sub_80E717C((float *)(v12 + 20), (float *)(a3 + 96), (float *)&v14);
      if ( (*(_BYTE *)(a2 + 28) || *(_BYTE *)(a2 + 29))
        && *(_DWORD *)(v12 + 96) != 1023
        && (v15 = sub_80E72B4(&v14), v15 != 0.0)
        && v15 > *(float *)(a3 + 36) * 5.0 )
      {
        v5 = sub_80A2298((float *)&v14, (int)&v10);
        sub_80A2C7E((float *)&v10, (int)&v10);
        sub_80A6258(v11, *(float *)(v12 + 236));
        v13 = (signed int)v5;
        if ( *(_BYTE *)(a2 + 28) < 0 )
        {
          v6 = (long double)v13 + 180.0;
          v13 = (signed int)sub_80A6112(v6);
        }
        v7 = v13;
        if ( v13 < 0 )
          v7 = -v13;
        if ( v7 > 90 )
        {
          if ( v13 <= 0 )
            v13 = -90;
          else
            v13 = 90;
        }
        result = (char)v13;
        *(_DWORD *)(v12 + 156) = (char)v13;
      }
      else
      {
        result = v12;
        *(_DWORD *)(v12 + 156) = 0;
      }
    }
  }
  else
  {
    sub_80A6258(*(float *)(v12 + 1412), *(float *)(v12 + 236));
    v13 = (signed int)a1;
    v9 = (signed int)a1;
    if ( (signed int)a1 < 0 )
      v9 = -v9;
    if ( v9 > 90 )
    {
      if ( v13 <= 0 )
        v13 = -90;
      else
        v13 = 90;
    }
    result = (char)v13;
    *(_DWORD *)(v12 + 156) = (char)v13;
  }
  return result;
}
// 80E72B4: using guessed type double __cdecl sub_80E72B4(_DWORD);

//----- (080DFAFC) --------------------------------------------------------
int __cdecl sub_80DFAFC(int a1)
{
  int v2; // [esp+0h] [ebp-8h]

  if ( *(_DWORD *)(a1 + 72) & 0x2000 )
    v2 = 0;
  else
    v2 = (unsigned __int8)((*(_DWORD *)(a1 + 72) & 0x1F00000) >> 20);
  return v2;
}

//----- (080DFB3A) --------------------------------------------------------
void __cdecl sub_80DFB3A(int a1, int a2)
{
  int v2; // [esp+28h] [ebp-50h]
  float v3; // [esp+2Ch] [ebp-4Ch]
  float v4; // [esp+2Ch] [ebp-4Ch]
  int v5; // [esp+30h] [ebp-48h]
  float v6; // [esp+4Ch] [ebp-2Ch]
  int v7; // [esp+50h] [ebp-28h]
  int v8; // [esp+54h] [ebp-24h]
  float v9; // [esp+58h] [ebp-20h]
  int i; // [esp+6Ch] [ebp-Ch]

  v2 = *(_DWORD *)a1;
  sub_80DEE4A(*(_DWORD *)a1, a2);
  v3 = sub_80DF3FA(v2, a1 + 4);
  if ( v3 == 0.0 )
  {
    v7 = 0;
    v8 = 0;
    v9 = 0.0;
  }
  else
  {
    for ( i = 0; i <= 2; ++i )
      *((float *)&v7 + i) = v3 * *(float *)(a2 + 4 * i) * (long double)*(char *)(a1 + 28)
                          + v3 * *(float *)(a2 + 4 * i + 12) * (long double)*(char *)(a1 + 29);
  }
  if ( *(_DWORD *)(v2 + 80) )
  {
    v4 = sub_80DF2DE(v2, 0.0, 0.0, 127.0);
    if ( *(_DWORD *)(a1 + 8) & 0x40 )
      v9 = v9 - v4 * 127.0;
    if ( *(_BYTE *)(a1 + 8) < 0 )
      v9 = v4 * 127.0 + v9;
  }
  sub_80E70CA(&v7, &v5);
  v6 = sub_80A20C0((float *)&v5);
  sub_80DF16A(v2, a2, (int)&v5, v6, 8.0);
  sub_80E7CC0((int *)a1, a2, 0);
}

//----- (080DFCD4) --------------------------------------------------------
int __cdecl sub_80DFCD4(int a1, int a2)
{
  long double v2; // fst7
  int v4; // [esp+2Ch] [ebp-7Ch]
  int v5; // [esp+30h] [ebp-78h]
  int v6; // [esp+34h] [ebp-74h]
  int v7; // [esp+38h] [ebp-70h]
  int v8; // [esp+3Ch] [ebp-6Ch]
  int v9; // [esp+40h] [ebp-68h]
  int v10; // [esp+44h] [ebp-64h]
  int v11; // [esp+48h] [ebp-60h]
  float v12; // [esp+58h] [ebp-50h]
  float v13; // [esp+5Ch] [ebp-4Ch]
  int v14; // [esp+60h] [ebp-48h]
  float v15; // [esp+78h] [ebp-30h]
  float v16; // [esp+7Ch] [ebp-2Ch]
  float v17[2]; // [esp+80h] [ebp-28h]
  int v18; // [esp+88h] [ebp-20h]
  int i; // [esp+9Ch] [ebp-Ch]

  v4 = *(_DWORD *)a1;
  sub_80DEE4A(*(_DWORD *)a1, a2);
  v16 = (long double)*(char *)(a1 + 28);
  v15 = (long double)*(char *)(a1 + 29);
  v5 = *(_DWORD *)(a1 + 4);
  v6 = *(_DWORD *)(a1 + 8);
  v7 = *(_DWORD *)(a1 + 12);
  v8 = *(_DWORD *)(a1 + 16);
  v9 = *(_DWORD *)(a1 + 20);
  v10 = *(_DWORD *)(a1 + 24);
  v11 = *(_DWORD *)(a1 + 28);
  v12 = sub_80DF3FA(v4, (int)&v5);
  *(_DWORD *)(a2 + 8) = 0;
  *(_DWORD *)(a2 + 20) = 0;
  sub_80A20C0((float *)a2);
  sub_80A20C0((float *)(a2 + 12));
  for ( i = 0; i <= 1; ++i )
    v17[i] = *(float *)(a2 + 4 * i) * v16 + *(float *)(a2 + 4 * i + 12) * v15;
  v18 = 0;
  sub_80E70CA(v17, &v14);
  v13 = sub_80A20C0((float *)&v14);
  v2 = v13 * v12;
  v13 = v2;
  sub_80DF16A(v4, a2, (int)&v14, v13, 1.0);
  if ( *(_DWORD *)(a2 + 48) )
    sub_80DEDB0((float *)(v4 + 32), (float *)(a2 + 60), v4 + 32);
  sub_80E7CC0((int *)a1, a2, 1);
  return sub_80DF868(v2, a1, a2);
}
// 80DFCD4: using guessed type float var_28[2];

//----- (080DFE82) --------------------------------------------------------
int __cdecl sub_80DFE82(int *a1, int a2)
{
  long double v3; // fst7
  long double v4; // fst7
  int v5; // [esp+30h] [ebp-98h]
  signed int v6; // [esp+34h] [ebp-94h]
  float v7; // [esp+38h] [ebp-90h]
  float v8; // [esp+3Ch] [ebp-8Ch]
  int v9; // [esp+40h] [ebp-88h]
  int v10; // [esp+44h] [ebp-84h]
  int v11; // [esp+48h] [ebp-80h]
  int v12; // [esp+4Ch] [ebp-7Ch]
  int v13; // [esp+50h] [ebp-78h]
  int v14; // [esp+54h] [ebp-74h]
  int v15; // [esp+58h] [ebp-70h]
  float v16; // [esp+68h] [ebp-60h]
  float v17; // [esp+6Ch] [ebp-5Ch]
  int v18; // [esp+70h] [ebp-58h]
  float v19; // [esp+88h] [ebp-40h]
  float v20; // [esp+8Ch] [ebp-3Ch]
  float v21[4]; // [esp+90h] [ebp-38h]
  float v22[7]; // [esp+A0h] [ebp-28h]
  int i; // [esp+BCh] [ebp-Ch]

  v5 = *a1;
  if ( *(_DWORD *)(*a1 + 12) & 0x80000 )
    sub_80DA0F4(v5);
  if ( (unsigned __int8)sub_80DA584((int)a1, (int *)a2) )
    return sub_80DFCD4((int)a1, a2);
  sub_80DEE4A(v5, a2);
  v20 = (long double)*((char *)a1 + 28);
  v19 = (long double)*((char *)a1 + 29);
  v9 = a1[1];
  v10 = a1[2];
  v11 = a1[3];
  v12 = a1[4];
  v13 = a1[5];
  v14 = a1[6];
  v15 = a1[7];
  v16 = sub_80DF534(a1, (int)&v9);
  v3 = sub_80DF7FC(*(_DWORD *)(v5 + 144));
  v16 = v3 * v16;
  *(_DWORD *)(v5 + 144) -= (signed int)(*(float *)(a2 + 36) * 1000.0);
  if ( *(_DWORD *)(v5 + 144) <= 0 )
    *(_DWORD *)(v5 + 144) = 0;
  *(_DWORD *)(a2 + 8) = 0;
  *(_DWORD *)(a2 + 20) = 0;
  sub_80DEDB0((float *)a2, (float *)(a2 + 60), a2);
  sub_80DEDB0((float *)(a2 + 12), (float *)(a2 + 60), a2 + 12);
  sub_80A20C0((float *)a2);
  sub_80A20C0((float *)(a2 + 12));
  for ( i = 0; i <= 2; ++i )
    v22[i] = *(float *)(a2 + 4 * i) * v20 + *(float *)(a2 + 4 * i + 12) * v19;
  sub_80E70CA(v22, &v18);
  v17 = sub_80A20C0((float *)&v18);
  v17 = v17 * v16;
  v6 = sub_80DEE0E(v5);
  if ( *(_DWORD *)(a2 + 72) & 2 || *(_DWORD *)(v5 + 12) & 0x400 )
  {
    v8 = 1.0;
  }
  else if ( v6 == 1 )
  {
    v8 = 19.0;
  }
  else if ( v6 == 2 )
  {
    v8 = 12.0;
  }
  else
  {
    v8 = 9.0;
  }
  if ( *(_DWORD *)(v5 + 12) & 0x200 )
    v8 = v8 * 0.25;
  sub_80DF16A(v5, a2, (int)&v18, v17, v8);
  if ( *(_DWORD *)(a2 + 72) & 2 || *(_DWORD *)(v5 + 12) & 0x400 )
    *(float *)(v5 + 40) = *(float *)(v5 + 40) - (long double)*(signed int *)(v5 + 72) * *(float *)(a2 + 36);
  v7 = sub_80E72B4(v5 + 32);
  sub_80E70CA((_DWORD *)(v5 + 32), v21);
  sub_80DEDB0((float *)(v5 + 32), (float *)(a2 + 60), v5 + 32);
  if ( sub_80E724C((float *)(v5 + 32), v21) > 0.0 )
  {
    sub_80A20C0((float *)(v5 + 32));
    sub_80E71C0(v5 + 32, v7, v5 + 32);
  }
  v4 = 0.0;
  if ( *(float *)(v5 + 32) != 0.0 || (v4 = 0.0, *(float *)(v5 + 36) != 0.0) )
    sub_80E7CC0(a1, a2, 0);
  return sub_80DF868(v4, (int)a1, a2);
}
// 80E72B4: using guessed type double __cdecl sub_80E72B4(_DWORD);
// 80DFE82: using guessed type float var_28[7];

//----- (080E02FE) --------------------------------------------------------
int __cdecl sub_80E02FE(int a1, int a2)
{
  int result; // eax
  float v3; // ST14_4
  float v4; // [esp+14h] [ebp-4h]

  result = a2;
  if ( *(_DWORD *)(a2 + 44) )
  {
    v3 = sub_80E72B4(a1 + 32);
    v4 = v3 - 20.0;
    if ( v4 > 0.0 )
    {
      sub_80A20C0((float *)(a1 + 32));
      result = sub_80E71C0(a1 + 32, v4, a1 + 32);
    }
    else
    {
      result = sub_80E707C((_DWORD *)(a1 + 32));
    }
  }
  return result;
}
// 80E72B4: using guessed type double __cdecl sub_80E72B4(_DWORD);

//----- (080E037E) --------------------------------------------------------
int __cdecl sub_80E037E(int a1, int a2)
{
  float v2; // ST30_4
  float v3; // ST30_4
  float v5; // [esp+20h] [ebp-68h]
  int v6; // [esp+24h] [ebp-64h]
  float v7; // [esp+28h] [ebp-60h]
  int v8; // [esp+30h] [ebp-58h]
  float v9; // [esp+44h] [ebp-44h]
  float v10; // [esp+48h] [ebp-40h]
  float v11; // [esp+4Ch] [ebp-3Ch]
  float v12[6]; // [esp+50h] [ebp-38h]
  int i; // [esp+68h] [ebp-20h]
  float v14; // [esp+6Ch] [ebp-1Ch]
  float v15; // [esp+70h] [ebp-18h]
  float v16; // [esp+74h] [ebp-14h]
  float v17; // [esp+78h] [ebp-10h]
  float v18; // [esp+7Ch] [ebp-Ch]

  v6 = *(_DWORD *)a1;
  *(_DWORD *)(v6 + 244) = 60;
  v18 = sub_80E72B4(v6 + 32);
  if ( v18 >= 1.0 )
  {
    v17 = 0.0;
    v16 = *(float *)(dword_85760B0 + 8) * 1.5;
    if ( *(float *)(dword_85760AC + 8) <= (long double)v18 )
      v5 = v18;
    else
      v5 = *(float *)(dword_85760AC + 8);
    v15 = v5;
    v17 = v5 * v16 * *(float *)(a2 + 36) + v17;
    v14 = v18 - v17;
    if ( v14 < 0.0 )
      v14 = 0.0;
    v14 = v14 / v18;
    sub_80E71C0(v6 + 32, v14, v6 + 32);
  }
  else
  {
    sub_80E70CA(&unk_8145E68, (_DWORD *)(v6 + 32));
  }
  v11 = (long double)*(char *)(a1 + 28);
  v10 = (long double)*(char *)(a1 + 29);
  v9 = 0.0;
  if ( *(_BYTE *)(a1 + 8) < 0 )
    v9 = v9 + 127.0;
  if ( *(_DWORD *)(a1 + 8) & 0x40 )
    v9 = v9 - 127.0;
  v7 = sub_80DF2DE(v6, v11, v10, v9);
  for ( i = 0; i <= 2; ++i )
    v12[i] = *(float *)(a2 + 4 * i) * v11 + *(float *)(a2 + 4 * i + 12) * v10 + *(float *)(a2 + 4 * i + 24) * v9;
  sub_80E70CA(v12, &v8);
  v2 = sub_80A20C0((float *)&v8);
  v3 = v2 * v7;
  sub_80DF16A(v6, a2, (int)&v8, v3, 9.0);
  return sub_80E71F8(v6 + 20, *(float *)(a2 + 36), v6 + 32, v6 + 20);
}
// 80E72B4: using guessed type double __cdecl sub_80E72B4(_DWORD);
// 85760AC: using guessed type int dword_85760AC;
// 85760B0: using guessed type int dword_85760B0;
// 80E037E: using guessed type float var_38[6];

//----- (080E05C8) --------------------------------------------------------
int __cdecl sub_80E05C8(int a1, int a2)
{
  float v3; // [esp+2Ch] [ebp-8Ch]
  float v4[4]; // [esp+30h] [ebp-88h]
  int v5; // [esp+40h] [ebp-78h]
  int v6; // [esp+44h] [ebp-74h]
  int v7; // [esp+48h] [ebp-70h]
  int i; // [esp+50h] [ebp-68h]
  int v9; // [esp+54h] [ebp-64h]
  float v10; // [esp+58h] [ebp-60h]
  float v11; // [esp+5Ch] [ebp-5Ch]
  int v12; // [esp+60h] [ebp-58h]
  float v13; // [esp+74h] [ebp-44h]
  float v14; // [esp+78h] [ebp-40h]
  float v15; // [esp+7Ch] [ebp-3Ch]
  float v16[7]; // [esp+80h] [ebp-38h]
  float v17; // [esp+9Ch] [ebp-1Ch]
  float v18; // [esp+A0h] [ebp-18h]
  float v19; // [esp+A4h] [ebp-14h]
  float v20; // [esp+A8h] [ebp-10h]
  float v21; // [esp+ACh] [ebp-Ch]

  v9 = *(_DWORD *)a1;
  *(_DWORD *)(v9 + 244) = 60;
  v15 = (long double)*(char *)(a1 + 28);
  v14 = (long double)*(char *)(a1 + 29);
  v13 = 0.0;
  if ( *(_BYTE *)(a1 + 8) < 0 )
    v13 = v13 + 127.0;
  if ( *(_DWORD *)(a1 + 8) & 0x40 )
    v13 = v13 - 127.0;
  if ( v15 != 0.0 || v14 != 0.0 || v13 != 0.0 )
    v21 = sub_80E72B4(v9 + 32);
  else
    v21 = 0.0;
  if ( v21 >= 1.0 )
  {
    v20 = 0.0;
    v19 = *(float *)(dword_85760B0 + 8) * 1.5;
    if ( *(float *)(dword_85760AC + 8) <= (long double)v21 )
      v3 = v21;
    else
      v3 = *(float *)(dword_85760AC + 8);
    v18 = v3;
    v20 = v3 * v19 * *(float *)(a2 + 36) + v20;
    v17 = v21 - v20;
    if ( v17 < 0.0 )
      v17 = 0.0;
    v17 = v17 / v21;
    sub_80E71C0(v9 + 32, v17, v9 + 32);
  }
  else
  {
    sub_80E70CA(&unk_8145E68, (_DWORD *)(v9 + 32));
  }
  v10 = sub_80DF2DE(v9, v15, v14, v13);
  v6 = 0;
  v5 = 0;
  v7 = 1065353216;
  sub_80A1ED8((float *)&v5, (float *)(a2 + 12), v4);
  for ( i = 0; i <= 2; ++i )
    v16[i] = v4[i] * v15 + *(float *)(a2 + 4 * i + 12) * v14 + *((float *)&v5 + i) * v13;
  sub_80E70CA(v16, &v12);
  v11 = sub_80A20C0((float *)&v12);
  v11 = v11 * v10;
  sub_80DF16A(v9, a2, (int)&v12, v11, 9.0);
  return sub_80E71F8(v9 + 20, *(float *)(a2 + 36), v9 + 32, v9 + 20);
}
// 80E72B4: using guessed type double __cdecl sub_80E72B4(_DWORD);
// 85760AC: using guessed type int dword_85760AC;
// 85760B0: using guessed type int dword_85760B0;
// 80E05C8: using guessed type float var_88[4];
// 80E05C8: using guessed type float var_38[7];

//----- (080E088C) --------------------------------------------------------
int __cdecl sub_80E088C(int a1, int a2)
{
  int v4; // [esp+14h] [ebp-4h]

  v4 = sub_80DFAFC(a2);
  if ( !v4 )
    return 0;
  if ( *(_BYTE *)(a1 + 12) & 1 )
    return v4 + 47;
  if ( *(_DWORD *)(a1 + 12) & 0x100 || *(float *)(a1 + 76) != 0.0 )
    return v4 + 24;
  return v4 + 1;
}

//----- (080E0906) --------------------------------------------------------
int __cdecl sub_80E0906(int a1)
{
  int v2; // [esp+10h] [ebp-8h]
  int v3; // [esp+14h] [ebp-4h]

  v3 = sub_80DFAFC(a1);
  if ( v3 )
    v2 = v3 + 24;
  else
    v2 = 0;
  return v2;
}

//----- (080E0938) --------------------------------------------------------
int __cdecl sub_80E0938(int a1)
{
  int v2; // [esp+10h] [ebp-8h]
  int v3; // [esp+14h] [ebp-4h]

  v3 = sub_80DFAFC(a1);
  if ( v3 )
    v2 = v3 + 1;
  else
    v2 = 0;
  return v2;
}

//----- (080E0968) --------------------------------------------------------
int __cdecl sub_80E0968(int a1)
{
  return sub_80DFAFC(a1) + 93;
}

//----- (080E0984) --------------------------------------------------------
int __cdecl sub_80E0984(int a1)
{
  return sub_80DFAFC(a1) + 116;
}

//----- (080E09A0) --------------------------------------------------------
void __cdecl sub_80E09A0(int a1, int a2)
{
  float v2; // ST5C_4
  float v3; // ST50_4
  float v4; // ST1C_4
  int v5; // eax
  int v6; // eax
  int v7; // eax
  int v8; // eax
  float v9; // [esp+1Ch] [ebp-4Ch]
  int v10; // [esp+30h] [ebp-38h]
  int v11; // [esp+34h] [ebp-34h]
  signed int v12; // [esp+38h] [ebp-30h]
  float v13; // [esp+3Ch] [ebp-2Ch]
  float v14; // [esp+40h] [ebp-28h]
  float v15; // [esp+4Ch] [ebp-1Ch]
  float v16; // [esp+58h] [ebp-10h]
  float v17; // [esp+60h] [ebp-8h]

  v2 = *(float *)(a2 + 104) - *(float *)(a1 + 28);
  v16 = *(float *)(a2 + 116);
  v9 = (long double)*(signed int *)(a1 + 72);
  v15 = COERCE_FLOAT(LODWORD(v9) ^ 0x80000000) * 0.5;
  v14 = v16 * v16 - v15 * 4.0 * v2;
  if ( v14 >= 0.0 )
  {
    v3 = (-v16 - sqrt(v14)) / (v15 + v15);
    v4 = v3 * COERCE_FLOAT(LODWORD(v9) ^ 0x80000000) + v16;
    v17 = COERCE_FLOAT(LODWORD(v4) ^ 0x80000000)
        * COERCE_FLOAT(LODWORD(v4) ^ 0x80000000)
        / ((long double)*(signed int *)(a1 + 72) + (long double)*(signed int *)(a1 + 72));
    if ( *(float *)(dword_8576098 + 8) < (long double)*(float *)(dword_857609C + 8) )
    {
      if ( *(float *)(dword_8576098 + 8) >= (long double)v17 || *(_BYTE *)(a2 + 72) & 1 || *(_DWORD *)(a1 + 4) > 5 )
      {
        v11 = 0;
      }
      else if ( v17 < (long double)*(float *)(dword_857609C + 8) )
      {
        v11 = sub_80E6EC4(
                (signed int)((v17 - *(float *)(dword_8576098 + 8))
                           / (*(float *)(dword_857609C + 8) - *(float *)(dword_8576098 + 8))
                           * 100.0),
                0,
                100);
      }
      else
      {
        v11 = 100;
      }
    }
    else
    {
      Com_Printf("bg_fallDamageMaxHeight must be greater than bg_fallDamageMinHeight\n");
      v11 = 0;
    }
    if ( v17 > 12.0 )
    {
      v12 = (signed int)((v17 - 12.0) / 26.0 * 4.0 + 4.0);
      if ( v12 > 24 )
        LOBYTE(v12) = 24;
      sub_80D6FCA((_DWORD *)a1, 5, 0, 1);
    }
    else
    {
      LOBYTE(v12) = 0;
    }
    if ( v11 )
    {
      if ( v11 > 99 || *(_DWORD *)(a2 + 72) & 2 )
      {
        sub_80E71C0(a1 + 32, 0.67000002, a1 + 32);
      }
      else
      {
        v10 = 35 * v11 + 500;
        if ( v10 > 2000 )
          v10 = 2000;
        if ( v10 > 500 )
        {
          if ( v10 <= 1499 )
            v13 = 0.5 - ((long double)v10 - 500.0) / 1000.0 * 0.30000001;
          else
            v13 = 0.2;
        }
        else
        {
          v13 = 0.5;
        }
        *(_DWORD *)(a1 + 16) = v10;
        *(_DWORD *)(a1 + 12) |= 0x200u;
        sub_80E71C0(a1 + 32, v13, a1 + 32);
      }
      v5 = sub_80E0984(a2);
      sub_80DD554(v5, v11, a1);
    }
    else if ( v17 > 4.0 )
    {
      if ( v17 >= 8.0 )
      {
        if ( v17 >= 12.0 )
        {
          sub_80E71C0(a1 + 32, 0.67000002, a1 + 32);
          v8 = sub_80E0968(a2);
          sub_80DD554(v8, v12, a1);
        }
        else
        {
          v7 = sub_80E0938(a2);
          sub_80DED2E(a1, v7);
        }
      }
      else
      {
        v6 = sub_80E0906(a2);
        sub_80DED2E(a1, v6);
      }
    }
  }
}
// 8576098: using guessed type int dword_8576098;
// 857609C: using guessed type int dword_857609C;

//----- (080E0DA2) --------------------------------------------------------
signed int __cdecl sub_80E0DA2(int *a1, _DWORD *a2, int a3)
{
  _DWORD *v3; // ecx
  int v6; // [esp+2Ch] [ebp-2Ch]
  int v7; // [esp+30h] [ebp-28h]
  int v8; // [esp+34h] [ebp-24h]
  float v9; // [esp+38h] [ebp-20h]
  unsigned int i; // [esp+4Ch] [ebp-Ch]

  v6 = *a1;
  for ( i = 0; i <= 0x19; ++i )
  {
    sub_80E7138((float *)(v6 + 20), (float *)(12 * i + 135585920), (float *)&v7);
    sub_80DEC3C((int)a1, a3, (int)&v7, (int)(a1 + 49), (int)(a1 + 52), (int)&v7, *(_DWORD *)(v6 + 204), a1[15]);
    if ( !*(_BYTE *)(a3 + 35) )
    {
      sub_80E70CA(&v7, (_DWORD *)(v6 + 20));
      v7 = *(_DWORD *)(v6 + 20);
      v8 = *(_DWORD *)(v6 + 24);
      v9 = *(float *)(v6 + 28) - 1.0;
      sub_80DEC3C((int)a1, a3, v6 + 20, (int)(a1 + 49), (int)(a1 + 52), (int)&v7, *(_DWORD *)(v6 + 204), a1[15]);
      v3 = a2 + 14;
      *v3 = *(_DWORD *)a3;
      v3[1] = *(_DWORD *)(a3 + 4);
      v3[2] = *(_DWORD *)(a3 + 8);
      v3[3] = *(_DWORD *)(a3 + 12);
      v3[4] = *(_DWORD *)(a3 + 16);
      v3[5] = *(_DWORD *)(a3 + 20);
      v3[6] = *(_DWORD *)(a3 + 24);
      v3[7] = *(_DWORD *)(a3 + 28);
      v3[8] = *(_DWORD *)(a3 + 32);
      sub_80DEB7A(v6 + 20, (int)&v7, *(float *)a3, v6 + 20);
      return 1;
    }
  }
  *(_DWORD *)(v6 + 96) = 1023;
  a2[12] = 0;
  a2[13] = 0;
  a2[11] = 0;
  sub_80D9FF4(v6);
  return 0;
}

//----- (080E0F86) --------------------------------------------------------
_DWORD *__cdecl sub_80E0F86(int a1, _DWORD *a2)
{
  _DWORD *result; // eax
  _DWORD *v3; // [esp+2Ch] [ebp-4Ch]
  char v4; // [esp+30h] [ebp-48h]
  float v5; // [esp+38h] [ebp-40h]
  float v6; // [esp+40h] [ebp-38h]

  v3 = *(_DWORD **)a1;
  if ( *(_DWORD *)(*(_DWORD *)a1 + 96) == 1023 )
  {
    sub_80E70CA(v3 + 5, &v4);
    v5 = v5 - 1.0;
    (*(&off_8166520 + 3 * *(unsigned __int8 *)(a1 + 228)))(
      &v6,
      (int)(v3 + 5),
      a1 + 196,
      a1 + 208,
      (int)&v4,
      v3[51],
      *(_DWORD *)(a1 + 60));
    a2[13] = 1.0 != v6;
  }
  else
  {
    sub_80E70CA(v3 + 5, &v4);
    v5 = v5 - 64.0;
    (*(&off_8166520 + 3 * *(unsigned __int8 *)(a1 + 228)))(
      &v6,
      (int)(v3 + 5),
      a1 + 196,
      a1 + 208,
      (int)&v4,
      v3[51],
      *(_DWORD *)(a1 + 60));
    if ( v6 == 1.0 )
    {
      if ( *(_BYTE *)(a1 + 28) < 0 )
        sub_80D6FCA(v3, 4, 0, 1);
      else
        sub_80D6FCA(v3, 3, 0, 1);
      a2[13] = 0;
    }
    else
    {
      a2[13] = 0.015625 > v6;
    }
  }
  v3[24] = 1023;
  a2[12] = 0;
  result = a2;
  a2[11] = 0;
  return result;
}
// 8166520: using guessed type int (__cdecl *off_8166520)(void *s, int, int, int, int, int, int);

//----- (080E117E) --------------------------------------------------------
_DWORD *__cdecl sub_80E117E(int *a1, _DWORD *a2)
{
  long double v2; // fst7
  int v3; // edx
  _DWORD *result; // eax
  int v5; // edx
  int v6; // [esp+2Ch] [ebp-5Ch]
  float v7; // [esp+30h] [ebp-58h]
  int v8; // [esp+34h] [ebp-54h]
  int v9; // [esp+38h] [ebp-50h]
  float v10; // [esp+3Ch] [ebp-4Ch]
  int v11; // [esp+40h] [ebp-48h]
  int v12; // [esp+44h] [ebp-44h]
  int v13; // [esp+48h] [ebp-40h]
  int v14; // [esp+4Ch] [ebp-3Ch]
  int v15; // [esp+50h] [ebp-38h]
  int v16; // [esp+60h] [ebp-28h]
  int v17; // [esp+64h] [ebp-24h]
  float v18; // [esp+68h] [ebp-20h]
  int v19; // [esp+70h] [ebp-18h]
  int v20; // [esp+74h] [ebp-14h]
  float v21; // [esp+78h] [ebp-10h]

  v6 = *a1;
  v19 = *(_DWORD *)(*a1 + 20);
  v20 = *(_DWORD *)(v6 + 24);
  v16 = *(_DWORD *)(v6 + 20);
  v17 = *(_DWORD *)(v6 + 24);
  if ( *(_DWORD *)(v6 + 160) & 0x300 )
  {
    v21 = *(float *)(v6 + 28);
    v2 = *(float *)(v6 + 28) - 1.0;
  }
  else
  {
    v21 = *(float *)(v6 + 28) + 0.25;
    v2 = *(float *)(v6 + 28) - 0.25;
  }
  v18 = v2;
  sub_80DEC3C((int)a1, (int)&v7, (int)&v19, (int)(a1 + 49), (int)(a1 + 52), (int)&v16, *(_DWORD *)(v6 + 204), a1[15]);
  v3 = (int)(a2 + 14);
  *(float *)v3 = v7;
  *(_DWORD *)(v3 + 4) = v8;
  *(_DWORD *)(v3 + 8) = v9;
  *(float *)(v3 + 12) = v10;
  *(_DWORD *)(v3 + 16) = v11;
  *(_DWORD *)(v3 + 20) = v12;
  *(_DWORD *)(v3 + 24) = v13;
  *(_DWORD *)(v3 + 28) = v14;
  *(_DWORD *)(v3 + 32) = v15;
  if ( !BYTE2(v15) || (result = (_DWORD *)sub_80E0DA2(a1, a2, (int)&v7)) != 0 )
  {
    if ( HIBYTE(v15) )
    {
      v21 = *(float *)(v6 + 28) - 0.001;
      sub_80DEC3C(
        (int)a1,
        (int)&v7,
        (int)&v19,
        (int)(a1 + 49),
        (int)(a1 + 52),
        (int)&v16,
        *(_DWORD *)(v6 + 204),
        a1[15]);
      if ( HIBYTE(v15) )
      {
        *(_DWORD *)(v6 + 96) = 1023;
        a2[12] = 0;
        a2[13] = 0;
        result = a2;
        a2[11] = 0;
        return result;
      }
      v5 = (int)(a2 + 14);
      *(float *)v5 = v7;
      *(_DWORD *)(v5 + 4) = v8;
      *(_DWORD *)(v5 + 8) = v9;
      *(float *)(v5 + 12) = v10;
      *(_DWORD *)(v5 + 16) = v11;
      *(_DWORD *)(v5 + 20) = v12;
      *(_DWORD *)(v5 + 24) = v13;
      *(_DWORD *)(v5 + 28) = v14;
      *(_DWORD *)(v5 + 32) = v15;
    }
    if ( v7 == 1.0 )
    {
      result = sub_80E0F86((int)a1, a2);
    }
    else if ( *(_DWORD *)(v6 + 12) & 0x20
           || *(float *)(v6 + 40) <= 0.0
           || sub_80E724C((float *)(v6 + 32), (float *)&v8) <= 10.0 )
    {
      if ( v10 >= 0.69999999 )
      {
        a2[12] = 1;
        a2[13] = 1;
        a2[11] = 1;
        if ( *(_DWORD *)(v6 + 96) == 1023 )
          sub_80E09A0(v6, (int)a2);
        *(_DWORD *)(v6 + 96) = (unsigned __int16)v14;
        result = (_DWORD *)sub_80DED50((int)a1, (unsigned __int16)v14);
      }
      else
      {
        *(_DWORD *)(v6 + 96) = 1023;
        a2[12] = 1;
        a2[13] = 1;
        a2[11] = 0;
        result = (_DWORD *)sub_80D9FF4(v6);
      }
    }
    else
    {
      if ( *((_BYTE *)a1 + 28) < 0 )
        sub_80D6FCA((_DWORD *)v6, 4, 0, 0);
      else
        sub_80D6FCA((_DWORD *)v6, 3, 0, 0);
      a2[13] = 0;
      *(_DWORD *)(v6 + 96) = 1023;
      a2[12] = 0;
      result = a2;
      a2[11] = 0;
    }
  }
  return result;
}

//----- (080E1522) --------------------------------------------------------
signed int __cdecl sub_80E1522(int a1, int a2, int a3)
{
  if ( a2 == 11 )
    return 400;
  if ( a2 != 40 )
    return 200;
  if ( a3 )
    return 200;
  return 400;
}

//----- (080E1562) --------------------------------------------------------
long double __cdecl sub_80E1562(int a1, int a2, float *a3)
{
  float v3; // ST08_4
  float v5; // [esp+0h] [ebp-18h]
  int v6; // [esp+Ch] [ebp-Ch]
  signed int v7; // [esp+10h] [ebp-8h]

  if ( a1 )
  {
    v6 = a2 + 12;
    v7 = 1;
    do
    {
      if ( a1 == *(_DWORD *)v6 )
      {
        *a3 = (long double)*(signed int *)(v6 + 8);
        return *(float *)(v6 + 4);
      }
      if ( *(_DWORD *)v6 > a1 )
      {
        v3 = (long double)(a1 - *(_DWORD *)(a2 + 12 * v7 - 12))
           / (long double)(*(_DWORD *)v6 - *(_DWORD *)(a2 + 12 * v7 - 12));
        *a3 = (long double)*(signed int *)(a2 + 12 * v7 - 12 + 8)
            + (long double)(*(_DWORD *)(v6 + 8) - *(_DWORD *)(a2 + 12 * v7 - 12 + 8)) * v3;
        return (float)((*(float *)(v6 + 4) - *(float *)(a2 + 12 * v7 - 12 + 4)) * v3 + *(float *)(a2 + 12 * v7 - 12 + 4));
      }
      v6 = a2 + 12 * ++v7;
    }
    while ( *(_DWORD *)(a2 + 12 * v7) != -1 );
    *a3 = (long double)*(signed int *)(a2 + 8);
    v5 = *(float *)(a2 + 4);
  }
  else
  {
    *a3 = (long double)*(signed int *)(a2 + 8);
    v5 = *(float *)(a2 + 4);
  }
  return v5;
}

//----- (080E168A) --------------------------------------------------------
long double __cdecl sub_80E168A(_DWORD *a1, int a2, int a3)
{
  float v4; // [esp+18h] [ebp-10h]
  float v5; // [esp+1Ch] [ebp-Ch]
  _DWORD *v6; // [esp+24h] [ebp-4h]

  v6 = (_DWORD *)*a1;
  if ( *(_DWORD *)(*a1 + 252) )
  {
    if ( a2 != -1 && a3 != -1 && (a3 != v6[64] || a3 == 40 && (a2 != 11 || v6[65]) && (a2 != 60 || !v6[65])) )
    {
      v4 = 0.0;
    }
    else
    {
      v5 = (long double)(a1[1] - v6[63]) / (long double)sub_80E1522((int)v6, v6[64], v6[65]);
      if ( v5 >= 0.0 )
      {
        if ( v5 > 1.0 )
          v5 = 1.0;
      }
      else
      {
        v5 = 0.0;
      }
      v4 = v5;
    }
  }
  else
  {
    v4 = 0.0;
  }
  return v4;
}

//----- (080E178C) --------------------------------------------------------
void __cdecl sub_80E178C(int *a1, int a2)
{
  int v2; // ebx
  int v3; // ebx
  int v4; // ebx
  int v5; // ebx
  float v6; // ST00_4
  int v7; // [esp+30h] [ebp-48h]
  int v8; // [esp+34h] [ebp-44h]
  int v9; // [esp+38h] [ebp-40h]
  char v10; // [esp+40h] [ebp-38h]
  float v11; // [esp+5Ch] [ebp-1Ch]
  float v12; // [esp+60h] [ebp-18h]
  int v13; // [esp+64h] [ebp-14h]
  int v14; // [esp+68h] [ebp-10h]
  int v15; // [esp+6Ch] [ebp-Ch]

  v15 = *a1;
  if ( *(_DWORD *)(v15 + 244) && *(float *)(v15 + 248) != 0.0 )
  {
    if ( *(float *)(v15 + 248) != (long double)*(signed int *)(v15 + 244) || *(_DWORD *)(v15 + 252) )
    {
      v14 = 0;
      if ( *(_DWORD *)(v15 + 244) == 11 || *(_DWORD *)(v15 + 244) == 40 || *(_DWORD *)(v15 + 244) == 60 )
      {
        if ( *(_DWORD *)(v15 + 252) )
        {
          v13 = sub_80E1522(v15, *(_DWORD *)(v15 + 256), *(_DWORD *)(v15 + 260));
          v14 = 100 * (a1[1] - *(_DWORD *)(v15 + 252)) / v13;
          if ( v14 >= 0 )
          {
            if ( v14 > 100 )
              v14 = 100;
          }
          else
          {
            v14 = 0;
          }
          if ( v14 == 100 )
          {
            *(float *)(v15 + 248) = (long double)*(signed int *)(v15 + 256);
            *(_DWORD *)(v15 + 252) = 0;
            *(_DWORD *)(v15 + 264) = 0;
          }
          else
          {
            if ( *(_DWORD *)(v15 + 256) == 11 )
            {
              v2 = v15;
              *(float *)(v2 + 248) = sub_80E1562(v14, (int)&unk_81663E0, &v12);
            }
            else if ( *(_DWORD *)(v15 + 256) == 40 )
            {
              if ( *(_DWORD *)(v15 + 260) )
              {
                v3 = v15;
                *(float *)(v3 + 248) = sub_80E1562(v14, (int)&unk_81662E0, &v12);
              }
              else
              {
                v4 = v15;
                *(float *)(v4 + 248) = sub_80E1562(v14, (int)&unk_81664C0, &v12);
              }
            }
            else
            {
              v5 = v15;
              *(float *)(v5 + 248) = sub_80E1562(v14, (int)&unk_8166360, &v12);
            }
            v6 = *(float *)(v15 + 264) - v12;
            if ( sub_80E6E42(v6) > 0.050000001 )
            {
              sub_80E70CA((_DWORD *)(v15 + 32), &v10);
              v11 = v12 - *(float *)(v15 + 264);
              if ( *(_DWORD *)(v15 + 96) == 1023 )
                v11 = v11 * 0.5;
              v11 = v11 / *(float *)(a2 + 36);
              v7 = *(_DWORD *)a2;
              v8 = *(_DWORD *)(a2 + 4);
              v9 = 0;
              sub_80A20C0((float *)&v7);
              sub_80E71C0((int)&v7, v11, v15 + 32);
              sub_80E7CC0(a1, a2, 1);
              sub_80E70CA(&v10, (_DWORD *)(v15 + 32));
              *(float *)(v15 + 264) = v12;
            }
          }
        }
        if ( *(_DWORD *)(v15 + 252) )
        {
          if ( *(_DWORD *)(v15 + 244) != *(_DWORD *)(v15 + 256)
            && (*(_DWORD *)(v15 + 244) < *(_DWORD *)(v15 + 256) && !*(_DWORD *)(v15 + 260)
             || *(_DWORD *)(v15 + 244) > *(_DWORD *)(v15 + 256) && *(_DWORD *)(v15 + 260)) )
          {
            v14 = 100 - v14;
            *(_DWORD *)(v15 + 260) ^= 1u;
            if ( *(_DWORD *)(v15 + 260) )
            {
              if ( *(_DWORD *)(v15 + 256) == 60 )
              {
                *(_DWORD *)(v15 + 256) = 40;
              }
              else if ( *(_DWORD *)(v15 + 256) == 40 )
              {
                *(_DWORD *)(v15 + 256) = 11;
              }
            }
            else if ( *(_DWORD *)(v15 + 256) == 11 )
            {
              *(_DWORD *)(v15 + 256) = 40;
            }
            else if ( *(_DWORD *)(v15 + 256) == 40 )
            {
              *(_DWORD *)(v15 + 256) = 60;
            }
            if ( v14 == 100 )
            {
              *(float *)(v15 + 248) = (long double)*(signed int *)(v15 + 256);
              *(_DWORD *)(v15 + 252) = 0;
              *(_DWORD *)(v15 + 264) = 0;
            }
            else
            {
              v13 = sub_80E1522(v15, *(_DWORD *)(v15 + 256), *(_DWORD *)(v15 + 260));
              *(_DWORD *)(v15 + 252) = a1[1] - (signed int)((long double)v14 * 0.0099999998 * (long double)v13);
              if ( *(_DWORD *)(v15 + 256) == 11 )
              {
                sub_80E1562(v14, (int)&unk_81663E0, &v12);
              }
              else if ( *(_DWORD *)(v15 + 256) == 40 )
              {
                if ( *(_DWORD *)(v15 + 260) )
                  sub_80E1562(v14, (int)&unk_81662E0, &v12);
                else
                  sub_80E1562(v14, (int)&unk_81664C0, &v12);
              }
              else
              {
                sub_80E1562(v14, (int)&unk_8166360, &v12);
              }
              *(float *)(v15 + 264) = v12;
            }
          }
        }
        else if ( *(float *)(v15 + 248) != (long double)*(signed int *)(v15 + 244) )
        {
          *(_DWORD *)(v15 + 252) = a1[1];
          switch ( *(_DWORD *)(v15 + 244) )
          {
            case 0xB:
              *(_DWORD *)(v15 + 260) = 1;
              if ( *(float *)(v15 + 248) <= 40.0 )
                *(_DWORD *)(v15 + 256) = 11;
              else
                *(_DWORD *)(v15 + 256) = 40;
              break;
            case 0x28:
              *(_DWORD *)(v15 + 260) = *(float *)(v15 + 248) > (long double)*(signed int *)(v15 + 244);
              *(_DWORD *)(v15 + 256) = 40;
              break;
            case 0x3C:
              *(_DWORD *)(v15 + 260) = 0;
              if ( *(float *)(v15 + 248) >= 40.0 )
                *(_DWORD *)(v15 + 256) = 60;
              else
                *(_DWORD *)(v15 + 256) = 40;
              break;
          }
        }
      }
      else
      {
        *(_DWORD *)(v15 + 252) = 0;
        if ( (long double)*(signed int *)(v15 + 244) <= *(float *)(v15 + 248) )
        {
          *(float *)(v15 + 248) = *(float *)(v15 + 248) - *(float *)(a2 + 36) * 180.0;
          if ( (long double)*(signed int *)(v15 + 244) >= *(float *)(v15 + 248) )
            *(float *)(v15 + 248) = (long double)*(signed int *)(v15 + 244);
        }
        else
        {
          *(float *)(v15 + 248) = *(float *)(a2 + 36) * 180.0 + *(float *)(v15 + 248);
          if ( *(float *)(v15 + 248) >= (long double)*(signed int *)(v15 + 244) )
            *(float *)(v15 + 248) = (long double)*(signed int *)(v15 + 244);
        }
      }
    }
  }
  else if ( *(_DWORD *)(v15 + 4) == 4 )
  {
    *(_DWORD *)(v15 + 248) = 0;
  }
  else
  {
    *(float *)(v15 + 248) = (long double)*(signed int *)(v15 + 244);
  }
}

//----- (080E1F20) --------------------------------------------------------
void __cdecl sub_80E1F20(int a1, int a2)
{
  unsigned int v2; // eax
  long double v3; // fst7
  int v4; // ebx
  int v5; // [esp+50h] [ebp-88h]
  float v6; // [esp+58h] [ebp-80h]
  float v7; // [esp+6Ch] [ebp-6Ch]
  char v8; // [esp+70h] [ebp-68h]
  float v9; // [esp+78h] [ebp-60h]
  int v10; // [esp+88h] [ebp-50h]
  int v11; // [esp+8Ch] [ebp-4Ch]
  float v12; // [esp+90h] [ebp-48h]
  int v13; // [esp+94h] [ebp-44h]
  char v14; // [esp+B2h] [ebp-26h]
  char v15; // [esp+B3h] [ebp-25h]
  _BOOL4 v16; // [esp+C8h] [ebp-10h]
  _BOOL4 v17; // [esp+CCh] [ebp-Ch]

  v10 = *(_DWORD *)a1;
  *(_DWORD *)(a1 + 224) = 0;
  if ( *(_DWORD *)(v10 + 4) == 4 )
  {
    *(_DWORD *)(a1 + 196) = -1056964608;
    *(_DWORD *)(a1 + 200) = -1056964608;
    *(_DWORD *)(a1 + 204) = -1056964608;
    *(_DWORD *)(a1 + 208) = 1090519040;
    *(_DWORD *)(a1 + 212) = 1090519040;
    *(_DWORD *)(a1 + 216) = 1098907648;
    *(_DWORD *)(v10 + 12) &= 0xFFFFFFFC;
    if ( *(_DWORD *)(a1 + 8) & 0x100 )
    {
      *(_DWORD *)(a1 + 8) &= 0xFFFFFEFF;
      sub_80DD554(140, 0, v10);
    }
    *(_DWORD *)(v10 + 244) = 0;
    *(_DWORD *)(v10 + 248) = 0;
  }
  else
  {
    v17 = (*(_BYTE *)(v10 + 12) & 1) != 0;
    v16 = (*(_DWORD *)(v10 + 12) & 3) == 0;
    *(_DWORD *)(a1 + 196) = *(_DWORD *)(v10 + 1388);
    *(_DWORD *)(a1 + 200) = *(_DWORD *)(v10 + 1392);
    *(_DWORD *)(a1 + 208) = *(_DWORD *)(v10 + 1400);
    *(_DWORD *)(a1 + 212) = *(_DWORD *)(v10 + 1404);
    *(_DWORD *)(a1 + 204) = *(_DWORD *)(v10 + 1396);
    if ( *(_DWORD *)(v10 + 4) <= 5 )
    {
      if ( *(_DWORD *)(v10 + 160) & 0x300 )
      {
        if ( !(*(_DWORD *)(v10 + 160) & 0x100) || *(_DWORD *)(v10 + 160) & 0x200 )
        {
          if ( !(*(_DWORD *)(v10 + 160) & 0x200) || *(_DWORD *)(v10 + 160) & 0x100 )
          {
            *(_DWORD *)(v10 + 12) &= 0xFFFFFFFC;
          }
          else
          {
            *(_DWORD *)(v10 + 12) |= 2u;
            *(_DWORD *)(v10 + 12) &= 0xFFFFFFFE;
          }
        }
        else
        {
          *(_DWORD *)(v10 + 12) |= 1u;
          *(_DWORD *)(v10 + 12) &= 0xFFFFFFFD;
        }
      }
      else if ( *(_WORD *)(v10 + 12) >= 0 )
      {
        if ( *(_DWORD *)(v10 + 12) & 0x20 && *(_DWORD *)(a1 + 8) & 0x300 )
        {
          *(_DWORD *)(a1 + 8) &= 0xFFFFFCFF;
          sub_80DD554(140, 0, v10);
        }
        if ( *(_DWORD *)(a1 + 8) & 0x100 )
        {
          if ( *(_BYTE *)(v10 + 12) & 1
            || *(_DWORD *)(v10 + 96) != 1023
            && sub_80DE734(
                 *(_DWORD *)(v10 + 204),
                 v10 + 20,
                 *(_DWORD *)(a1 + 208),
                 1106247680,
                 *(float *)(v10 + 236),
                 v10 + 1448,
                 v10 + 1452,
                 v10 + 1456,
                 0,
                 *(_DWORD *)(v10 + 96) != 1023,
                 0,
                 *(unsigned __int8 *)(a1 + 228),
                 0,
                 66.0) )
          {
            *(_DWORD *)(v10 + 12) |= 1u;
            *(_DWORD *)(v10 + 12) &= 0xFFFFFFFD;
          }
          else if ( *(_DWORD *)(v10 + 96) != 1023 )
          {
            *(_DWORD *)(v10 + 12) |= 0x10000u;
            if ( !(*(_DWORD *)(a1 + 8) & 0x2000) )
            {
              if ( *(_DWORD *)(v10 + 12) & 2 )
                sub_80DD554(141, 0, v10);
              else
                sub_80DD554(140, 0, v10);
            }
          }
        }
        else if ( *(_DWORD *)(a1 + 8) & 0x200 )
        {
          if ( *(_BYTE *)(v10 + 12) & 1 )
          {
            *(_DWORD *)(a1 + 216) = 1112014848;
            (*(&off_8166520 + 3 * *(unsigned __int8 *)(a1 + 228)))(
              &v12,
              v10 + 20,
              a1 + 196,
              a1 + 208,
              v10 + 20,
              *(_DWORD *)(v10 + 204),
              *(_DWORD *)(a1 + 60) & 0xFDFFFFFF);
            if ( v14 )
            {
              if ( !(*(_DWORD *)(a1 + 8) & 0x2000) )
                sub_80DD554(142, 2u, v10);
            }
            else
            {
              sub_80D6FCA((_DWORD *)v10, 12, 0, 0);
              *(_DWORD *)(v10 + 12) &= 0xFFFFFFFE;
              *(_DWORD *)(v10 + 12) |= 2u;
            }
          }
          else
          {
            sub_80D6FCA((_DWORD *)v10, 13, 0, 0);
            *(_DWORD *)(v10 + 12) |= 2u;
          }
        }
        else if ( *(_BYTE *)(v10 + 12) & 1 )
        {
          *(_DWORD *)(a1 + 216) = *(_DWORD *)(v10 + 1408);
          (*(&off_8166520 + 3 * *(unsigned __int8 *)(a1 + 228)))(
            &v12,
            v10 + 20,
            a1 + 196,
            a1 + 208,
            v10 + 20,
            *(_DWORD *)(v10 + 204),
            *(_DWORD *)(a1 + 60) & 0xFDFFFFFF);
          if ( v14 )
          {
            *(_DWORD *)(a1 + 216) = 1112014848;
            (*(&off_8166520 + 3 * *(unsigned __int8 *)(a1 + 228)))(
              &v12,
              v10 + 20,
              a1 + 196,
              a1 + 208,
              v10 + 20,
              *(_DWORD *)(v10 + 204),
              *(_DWORD *)(a1 + 60) & 0xFDFFFFFF);
            if ( v14 )
            {
              if ( !(*(_DWORD *)(a1 + 8) & 0x2000) )
                sub_80DD554(142, 1u, v10);
            }
            else
            {
              *(_DWORD *)(v10 + 12) &= 0xFFFFFFFE;
              *(_DWORD *)(v10 + 12) |= 2u;
            }
          }
          else
          {
            sub_80D6FCA((_DWORD *)v10, 16, 0, 0);
            *(_DWORD *)(v10 + 12) &= 0xFFFFFFFC;
          }
        }
        else if ( *(_DWORD *)(v10 + 12) & 2 )
        {
          *(_DWORD *)(a1 + 216) = *(_DWORD *)(v10 + 1408);
          (*(&off_8166520 + 3 * *(unsigned __int8 *)(a1 + 228)))(
            &v12,
            v10 + 20,
            a1 + 196,
            a1 + 208,
            v10 + 20,
            *(_DWORD *)(v10 + 204),
            *(_DWORD *)(a1 + 60) & 0xFDFFFFFF);
          if ( v14 )
          {
            if ( !(*(_DWORD *)(a1 + 8) & 0x2000) )
              sub_80DD554(141, 1u, v10);
          }
          else
          {
            sub_80D6FCA((_DWORD *)v10, 14, 0, 0);
            *(_DWORD *)(v10 + 12) &= 0xFFFFFFFD;
          }
        }
      }
      if ( !*(_DWORD *)(v10 + 252) )
      {
        if ( *(_BYTE *)(v10 + 12) & 1 )
        {
          if ( *(_DWORD *)(v10 + 244) == 60 )
          {
            *(_DWORD *)(v10 + 244) = 40;
          }
          else if ( *(_DWORD *)(v10 + 244) != 11 )
          {
            *(_DWORD *)(v10 + 244) = 11;
            *(_DWORD *)(a1 + 224) = 1;
            sub_80D69B2((_DWORD *)v10, 0, 2, 0, 0, 1, 1);
            sub_80DA0CA(v10);
          }
        }
        else if ( *(_DWORD *)(v10 + 244) == 11 )
        {
          *(_DWORD *)(v10 + 244) = 40;
          *(_DWORD *)(a1 + 224) = 1;
          sub_80D69B2((_DWORD *)v10, 0, 2, 0, 0, 1, 1);
        }
        else if ( *(_DWORD *)(v10 + 12) & 2 )
        {
          *(_DWORD *)(v10 + 244) = 40;
        }
        else
        {
          *(_DWORD *)(v10 + 244) = 60;
        }
      }
      sub_80E178C((int *)a1, a2);
      v11 = sub_80DEE0E(v10);
      if ( v11 == 1 )
      {
        *(_DWORD *)(a1 + 216) = 1106247680;
        *(_DWORD *)(v10 + 160) |= 8u;
        *(_DWORD *)(v10 + 160) &= 0xFFFFFFFB;
        *(_DWORD *)(v10 + 12) |= 1u;
        *(_DWORD *)(v10 + 12) &= 0xFFFFFFFD;
      }
      else
      {
        if ( v11 == 2 )
        {
          *(_DWORD *)(a1 + 216) = 1112014848;
          *(_DWORD *)(v10 + 160) |= 4u;
          *(_DWORD *)(v10 + 160) &= 0xFFFFFFF7;
          *(_DWORD *)(v10 + 12) |= 2u;
          v2 = *(_DWORD *)(v10 + 12) & 0xFFFFFFFE;
        }
        else
        {
          *(_DWORD *)(a1 + 216) = *(_DWORD *)(v10 + 1408);
          *(_DWORD *)(v10 + 160) &= 0xFFFFFFF3;
          v2 = *(_DWORD *)(v10 + 12) & 0xFFFFFFFC;
        }
        *(_DWORD *)(v10 + 12) = v2;
      }
      if ( *(_BYTE *)(v10 + 12) & 1 && !v17 )
      {
        if ( *(_BYTE *)(a1 + 28) || *(_BYTE *)(a1 + 29) )
        {
          *(_DWORD *)(v10 + 12) &= 0xFFFFF7FF;
          sub_80EA53E(v10);
        }
        sub_80E70CA((_DWORD *)(v10 + 20), &v5);
        v6 = v6 + 10.0;
        (*(&off_8166520 + 3 * *(unsigned __int8 *)(a1 + 228)))(
          &v12,
          v10 + 20,
          a1 + 196,
          a1 + 208,
          (int)&v5,
          *(_DWORD *)(v10 + 204),
          *(_DWORD *)(a1 + 60) & 0xFDFFFFFF);
        sub_80DEB7A(v10 + 20, (int)&v5, v12, (int)&v5);
        (*(&off_8166520 + 3 * *(unsigned __int8 *)(a1 + 228)))(
          &v12,
          (int)&v5,
          a1 + 196,
          a1 + 208,
          v10 + 20,
          *(_DWORD *)(v10 + 204),
          *(_DWORD *)(a1 + 60) & 0xFDFFFFFF);
        sub_80DEB7A((int)&v5, v10 + 20, v12, v10 + 20);
        *(_DWORD *)(v10 + 1412) = *(_DWORD *)(v10 + 236);
        sub_80E70CA((_DWORD *)(v10 + 20), &v8);
        v3 = v9 - 0.25;
        v9 = v3;
        (*(&off_8166520 + 3 * *(unsigned __int8 *)(a1 + 228)))(
          &v12,
          v10 + 20,
          a1 + 196,
          a1 + 208,
          (int)&v8,
          *(_DWORD *)(v10 + 204),
          *(_DWORD *)(a1 + 60) & 0xFDFFFFFF);
        if ( v15 || (v3 = v12, v12 >= 1.0) )
        {
          *(_DWORD *)(v10 + 1416) = 0;
        }
        else
        {
          v4 = v10;
          sub_80A86CC(*(float *)(v10 + 1412), (int)&v13);
          *(float *)(v4 + 1416) = v3;
        }
        sub_80A6258(*(float *)(v10 + 1416), *(float *)(v10 + 232));
        v7 = v3;
        if ( v7 >= -45.0 )
        {
          if ( v7 <= 45.0 )
            *(_DWORD *)(v10 + 1420) = *(_DWORD *)(v10 + 1416);
          else
            *(float *)(v10 + 1420) = *(float *)(v10 + 232) + 45.0;
        }
        else
        {
          *(float *)(v10 + 1420) = *(float *)(v10 + 232) - 45.0;
        }
      }
    }
    else
    {
      *(_DWORD *)(a1 + 216) = *(_DWORD *)(v10 + 1408);
      *(_DWORD *)(v10 + 244) = 8;
      sub_80E178C((int *)a1, a2);
    }
  }
}
// 8166520: using guessed type int (__cdecl *off_8166520)(void *s, int, int, int, int, int, int);

//----- (080E2CDE) --------------------------------------------------------
char __cdecl sub_80E2CDE(int a1, int a2, char a3, char a4, int a5)
{
  char v5; // dl
  int v6; // eax
  int v7; // eax
  float v9; // [esp+20h] [ebp-78h]
  int v10; // [esp+30h] [ebp-68h]
  int v11; // [esp+50h] [ebp-48h]
  float v12; // [esp+60h] [ebp-38h]
  float v13; // [esp+64h] [ebp-34h]
  float v14; // [esp+68h] [ebp-30h]
  float v15; // [esp+70h] [ebp-28h]
  float v16; // [esp+74h] [ebp-24h]
  float v17; // [esp+78h] [ebp-20h]
  float v18; // [esp+80h] [ebp-18h]
  int v19; // [esp+84h] [ebp-14h]
  int v20; // [esp+88h] [ebp-10h]
  _DWORD *v21; // [esp+8Ch] [ebp-Ch]

  v21 = *(_DWORD **)a1;
  v5 = (a4 + 64) ^ (a3 + 64);
  LOBYTE(v6) = v5 & 0x80;
  if ( v5 < 0 )
  {
    LOBYTE(v6) = (_BYTE)v21;
    if ( v21[24] == 1023 )
    {
      if ( a5 )
      {
        v6 = v21[3] & 0x20;
        if ( v6 )
        {
          sub_80E70CA((_DWORD *)(a1 + 196), &v15);
          v15 = v15 + 6.0;
          v16 = v16 + 6.0;
          v17 = 8.0;
          sub_80E70CA((_DWORD *)(a1 + 208), &v12);
          v12 = v12 - 6.0;
          v13 = v13 - 6.0;
          if ( v17 > (long double)v14 )
            v14 = v17;
          v19 = *(_DWORD *)(a1 + 60) & 0xFDFEFFFF;
          v18 = -31.0;
          sub_80E71F8((int)(v21 + 5), -31.0, (int)(v21 + 25), (int)&v11);
          sub_80DEC3C(a1, (int)&v9, (int)(v21 + 5), (int)&v15, (int)&v12, (int)&v11, v21[51], v19);
          v20 = (unsigned __int8)((v10 & 0x1F00000) >> 20);
          if ( v9 == 1.0 || !v20 )
            v20 = 21;
          LOBYTE(v6) = sub_80DED2E((int)v21, v20 + 1);
        }
      }
    }
    else if ( a5 )
    {
      v7 = sub_80E088C((int)v21, a2);
      LOBYTE(v6) = sub_80DED2E((int)v21, v7);
    }
  }
  return v6;
}

//----- (080E2EA6) --------------------------------------------------------
_BOOL4 __cdecl sub_80E2EA6(int *a1)
{
  int v3; // [esp+Ch] [ebp-Ch]
  int v4; // [esp+10h] [ebp-8h]
  signed int v5; // [esp+14h] [ebp-4h]

  v3 = *a1;
  v4 = *(_DWORD *)(*a1 + 12) & 0x100;
  v5 = sub_80DEE0E(*a1);
  if ( v5 == 1 || v5 == 2 )
    return 0;
  if ( *(_BYTE *)(v3 + 12) >= 0 )
  {
    if ( !v4 )
      return *((float *)a1 + 55) >= (long double)*(float *)(dword_85760FC + 8);
    return 0;
  }
  if ( v4 )
    return 0;
  return *((float *)a1 + 55) >= (long double)*(float *)(dword_85760FC + 8);
}
// 85760FC: using guessed type int dword_85760FC;

//----- (080E2F4E) --------------------------------------------------------
int __cdecl sub_80E2F4E(float a1)
{
  if ( a1 < 0.0 )
    a1 = a1 + 360.0;
  if ( a1 >= 315.0 || a1 < 45.0 )
    return 31;
  if ( a1 >= 45.0 && a1 < 135.0 )
    return 33;
  if ( a1 < 135.0 || a1 >= 225.0 )
    return 34;
  return 32;
}

//----- (080E3008) --------------------------------------------------------
void __cdecl sub_80E3008(int a1, int a2)
{
  float v2; // ST00_4
  signed int v3; // ST5C_4
  int v4; // ST2C_4
  float v5; // ST00_4
  int v6; // ST34_4
  long double v7; // fst7
  long double v8; // fst7
  signed int v9; // [esp+14h] [ebp-54h]
  float v10; // [esp+20h] [ebp-48h]
  signed int v11; // [esp+28h] [ebp-40h]
  signed int v12; // [esp+28h] [ebp-40h]
  signed int v13; // [esp+2Ch] [ebp-3Ch]
  char *v14; // [esp+30h] [ebp-38h]
  int v15; // [esp+40h] [ebp-28h]
  int v16; // [esp+48h] [ebp-20h]
  float v17; // [esp+4Ch] [ebp-1Ch]
  float v18; // [esp+4Ch] [ebp-1Ch]
  float v19; // [esp+50h] [ebp-18h]
  signed int v20; // [esp+54h] [ebp-14h]
  int v21; // [esp+58h] [ebp-10h]
  signed int v22; // [esp+5Ch] [ebp-Ch]
  float v23; // [esp+60h] [ebp-8h]
  float v24; // [esp+60h] [ebp-8h]

  v16 = *(_DWORD *)a1;
  if ( *(_DWORD *)(*(_DWORD *)a1 + 4) <= 5 )
  {
    if ( *(_DWORD *)(v16 + 204) > 63 )
      v14 = 0;
    else
      v14 = (char *)dword_855A4E0 + 1208 * *(_DWORD *)(v16 + 204) + 736252;
    v15 = *(_DWORD *)(v16 + 148) - *(_DWORD *)(dword_857611C + 8);
    if ( v15 < 0 )
      v15 = 0;
    *(_DWORD *)(v16 + 148);
    *(_DWORD *)(dword_8576120 + 8);
    v2 = *(float *)(v16 + 32) * *(float *)(v16 + 32) + *(float *)(v16 + 36) * *(float *)(v16 + 36);
    *(float *)(a1 + 220) = sub_80E6E5C(v2);
    if ( *(_DWORD *)(v16 + 160) & 0x300 )
    {
      if ( *(_BYTE *)(v16 + 12) & 1 )
      {
        sub_80D6D82((_DWORD *)v16, 3, 3, 1);
      }
      else if ( *(_DWORD *)(v16 + 12) & 2 )
      {
        sub_80D6D82((_DWORD *)v16, 3, 2, 1);
      }
      else
      {
        sub_80D6D82((_DWORD *)v16, 3, 1, 1);
      }
    }
    else
    {
      v20 = sub_80DEE0E(v16);
      if ( *(_DWORD *)(v16 + 96) != 1023 || *(_DWORD *)(v16 + 4) == 1 )
        goto LABEL_155;
      if ( *(_DWORD *)(v16 + 12) & 0x20 )
      {
        if ( *(_DWORD *)(a1 + 4) - *(_DWORD *)(v16 + 112) <= 299 )
          return;
        v10 = *(float *)(v16 + 40);
        if ( *(_DWORD *)(v16 + 12) & 0x100 || *(float *)(v16 + 76) != 0.0 )
          v23 = v10 / (95.25 * 0.40000001) * 0.34999999;
        else
          v23 = v10 / 95.25 * 0.44999999;
        if ( v10 < 0.0 )
          sub_80D6D82((_DWORD *)v16, 3, 19, 1);
        else
          sub_80D6D82((_DWORD *)v16, 3, 18, 1);
        v3 = *(_DWORD *)(v16 + 8);
        *(_DWORD *)(v16 + 8) = (unsigned __int8)(signed int)((long double)v3
                                                           + (long double)*(signed int *)(a2 + 40) * v23);
        sub_80E2CDE(a1, a2, v3, *(_DWORD *)(v16 + 8), 1);
      }
      if ( v20 != (*(_DWORD *)(v16 + 12) & 3) )
      {
LABEL_155:
        v9 = 0;
        if ( *(_DWORD *)(v16 + 12) & 0x100 || *(float *)(v16 + 76) != 0.0 )
          v9 = 1;
        if ( *(float *)(dword_85760F8 + 8) <= (long double)*(float *)(a1 + 220) && *(_DWORD *)(v16 + 4) != 1 )
        {
          v19 = (long double)*(signed int *)(v16 + 80);
          if ( *(_BYTE *)(a1 + 28) )
          {
            if ( *(_BYTE *)(a1 + 29) )
            {
              v19 = ((*(float *)(dword_8576100 + 8) - 1.0) * 0.75 + 1.0 + 1.0) * 0.5 * v19;
              if ( *(_BYTE *)(a1 + 28) < 0 )
                v19 = (*(float *)(dword_8576104 + 8) + 1.0) * 0.5 * v19;
            }
            else if ( *(_BYTE *)(a1 + 28) < 0 )
            {
              v19 = v19 * *(float *)(dword_8576104 + 8);
            }
            sub_80D70E2(*(_DWORD *)(v16 + 204), 8, 0, 1);
          }
          else if ( *(_BYTE *)(a1 + 29) )
          {
            v19 = ((*(float *)(dword_8576100 + 8) - 1.0) * 0.75 + 1.0) * v19;
            if ( *(_BYTE *)(a1 + 29) <= 0 )
              sub_80D70E2(*(_DWORD *)(v16 + 204), 8, 1, 1);
            else
              sub_80D70E2(*(_DWORD *)(v16 + 204), 8, 2, 1);
          }
          if ( v9 )
            v19 = v19 * 0.40000001;
          v17 = sub_80E168A((_DWORD *)a1, 40, 11);
          if ( v17 == 0.0 )
          {
            v18 = sub_80E168A((_DWORD *)a1, 11, 40);
            if ( v18 == 0.0 )
            {
              if ( v20 == 1 )
              {
                v19 = v19 * 0.15000001;
              }
              else if ( v20 == 2 )
              {
                v19 = v19 * 0.64999998;
              }
            }
            else
            {
              v19 = (v18 * 0.64999998 + (1.0 - v18) * 0.15000001) * v19;
            }
          }
          else
          {
            v19 = (v17 * 0.15000001 + (1.0 - v17) * 0.64999998) * v19;
          }
          if ( v20 == 1 )
          {
            if ( v9 )
              v7 = *(float *)(a1 + 220) / v19 * 0.23999999;
            else
              v7 = *(float *)(a1 + 220) / v19 * 0.25;
            v24 = v7;
            if ( *(_BYTE *)(v16 + 12) >= 0 )
              v12 = sub_80D6D82((_DWORD *)v16, 3, 8, 1);
            else
              v12 = sub_80D6D82((_DWORD *)v16, 3, 9, 1);
          }
          else if ( v20 == 2 )
          {
            if ( v9 )
              v8 = *(float *)(a1 + 220) / v19 * 0.315;
            else
              v8 = *(float *)(a1 + 220) / v19 * 0.34;
            v24 = v8;
            if ( *(_BYTE *)(v16 + 12) >= 0 )
            {
              if ( v9 )
              {
                if ( *(_DWORD *)(v16 + 144) <= v15 )
                  v12 = sub_80D6D82((_DWORD *)v16, 3, 6, 1);
                else
                  v12 = sub_80D6D82((_DWORD *)v16, 3, 39, 1);
              }
              else if ( *(_DWORD *)(v16 + 144) <= v15 )
              {
                v12 = sub_80D6D82((_DWORD *)v16, 3, 12, 1);
              }
              else
              {
                v12 = sub_80D6D82((_DWORD *)v16, 3, 39, 1);
              }
            }
            else if ( v9 )
            {
              if ( *(_DWORD *)(v16 + 144) <= v15 )
                v12 = sub_80D6D82((_DWORD *)v16, 3, 7, 1);
              else
                v12 = sub_80D6D82((_DWORD *)v16, 3, 40, 1);
            }
            else if ( *(_DWORD *)(v16 + 144) <= v15 )
            {
              v12 = sub_80D6D82((_DWORD *)v16, 3, 13, 1);
            }
            else
            {
              v12 = sub_80D6D82((_DWORD *)v16, 3, 40, 1);
            }
          }
          else if ( *(_BYTE *)(v16 + 12) >= 0 )
          {
            if ( v9 )
            {
              v24 = *(float *)(a1 + 220) / v19 * 0.30500001;
              if ( *(_DWORD *)(v16 + 144) <= v15 )
                v12 = sub_80D6D82((_DWORD *)v16, 3, 4, 1);
              else
                v12 = sub_80D6D82((_DWORD *)v16, 3, 37, 1);
            }
            else
            {
              v24 = *(float *)(a1 + 220) / v19 * 0.33500001;
              if ( *(_DWORD *)(v16 + 144) <= v15 )
                v12 = sub_80D6D82((_DWORD *)v16, 3, 10, 1);
              else
                v12 = sub_80D6D82((_DWORD *)v16, 3, 35, 1);
            }
          }
          else if ( v9 )
          {
            v24 = *(float *)(a1 + 220) / v19 * 0.32499999;
            if ( *(_DWORD *)(v16 + 144) <= v15 )
              v12 = sub_80D6D82((_DWORD *)v16, 3, 5, 1);
            else
              v12 = sub_80D6D82((_DWORD *)v16, 3, 38, 1);
          }
          else
          {
            v24 = *(float *)(a1 + 220) / v19 * 0.36000001;
            if ( *(_DWORD *)(v16 + 144) <= v15 )
              v12 = sub_80D6D82((_DWORD *)v16, 3, 11, 1);
            else
              v12 = sub_80D6D82((_DWORD *)v16, 3, 36, 1);
          }
          v21 = sub_80E2EA6((int *)a1);
          v22 = *(_DWORD *)(v16 + 8);
          *(_DWORD *)(v16 + 8) = (unsigned __int8)(signed int)((long double)v22
                                                             + (long double)*(signed int *)(a2 + 40) * v24);
          if ( *(_BYTE *)(a1 + 28) || *(_BYTE *)(a1 + 29) )
          {
            if ( v12 < 0 )
              sub_80D6D82((_DWORD *)v16, 3, 1, 1);
            sub_80E2CDE(a1, a2, v22, *(_DWORD *)(v16 + 8), v21);
          }
          else if ( *(float *)(a1 + 220) <= 120.0 )
          {
            if ( *(_DWORD *)(v16 + 244) == 11 )
            {
              v12 = sub_80D6D82((_DWORD *)v16, 3, 3, 1);
            }
            else if ( *(_DWORD *)(v16 + 244) == 40 )
            {
              v12 = sub_80D6D82((_DWORD *)v16, 3, 2, 1);
            }
            if ( v12 < 0 )
            {
              if ( *(_DWORD *)(v16 + 144) <= v15 )
                sub_80D6D82((_DWORD *)v16, 3, 1, 1);
              else
                sub_80D6D82((_DWORD *)v16, 3, 31, 1);
            }
          }
        }
        else
        {
          if ( *(float *)(a1 + 220) < 1.0 )
            *(_DWORD *)(v16 + 8) = 0;
          v13 = 0;
          if ( v14 && *(_BYTE *)(dword_857610C + 8) )
          {
            if ( v14[1204] && *((_DWORD *)v14 + 300) )
              Com_DPrintf(
                "turn anim end time is %i, time is %i\n",
                *((_DWORD *)v14 + 300),
                *((_DWORD *)dword_855A4E0 + 184055));
            if ( *((_DWORD *)v14 + 225) )
            {
              if ( *((float *)v14 + 224) <= (long double)*((float *)v14 + 236) )
                v13 = 15;
              else
                v13 = 14;
              *((_DWORD *)v14 + 224) = *((_DWORD *)v14 + 236);
              v14[1204] = v13;
              if ( *((_DWORD *)v14 + 300) < *((_DWORD *)dword_855A4E0 + 184055) )
                *((_DWORD *)v14 + 300) = 0;
            }
            else
            {
              if ( *((_DWORD *)v14 + 300) > *((_DWORD *)dword_855A4E0 + 184055) )
              {
                v4 = v14[1204];
                *((_DWORD *)v14 + 224) = *((_DWORD *)v14 + 236);
                return;
              }
              if ( *((_DWORD *)v14 + 300) )
              {
                *((_DWORD *)v14 + 300) = 0;
                *((_DWORD *)v14 + 224) = *((_DWORD *)v14 + 236);
              }
            }
          }
          if ( *(_DWORD *)(v16 + 244) == 11 )
          {
            v11 = sub_80D6D82((_DWORD *)v16, 3, 3, 1);
          }
          else if ( *(_DWORD *)(v16 + 244) == 40 )
          {
            if ( v13 == 14 )
            {
              v11 = sub_80D6D82((_DWORD *)v16, 3, 16, 1);
              if ( v11 > 0 && !*((_DWORD *)v14 + 300) )
                *((_DWORD *)v14 + 300) = *((_DWORD *)dword_855A4E0 + 184055) + *(_DWORD *)(v16 + 136);
            }
            else if ( v13 == 15 )
            {
              v11 = sub_80D6D82((_DWORD *)v16, 3, 17, 1);
              if ( v11 > 0 && !*((_DWORD *)v14 + 300) )
                *((_DWORD *)v14 + 300) = *((_DWORD *)dword_855A4E0 + 184055) + *(_DWORD *)(v16 + 136);
            }
            else
            {
              v11 = sub_80D6D82((_DWORD *)v16, 3, 2, 1);
            }
          }
          else if ( v13 == 14 )
          {
            v11 = sub_80D6D82((_DWORD *)v16, 3, 14, 1);
            if ( v11 > 0 && !*((_DWORD *)v14 + 300) )
              *((_DWORD *)v14 + 300) = *((_DWORD *)dword_855A4E0 + 184055) + *(_DWORD *)(v16 + 136);
          }
          else if ( v13 == 15 )
          {
            v11 = sub_80D6D82((_DWORD *)v16, 3, 15, 1);
            if ( v11 > 0 && !*((_DWORD *)v14 + 300) )
              *((_DWORD *)v14 + 300) = *((_DWORD *)dword_855A4E0 + 184055) + *(_DWORD *)(v16 + 136);
          }
          else
          {
            if ( *(_DWORD *)(v16 + 144) > v15 )
            {
              v5 = (long double)*(signed int *)(v16 + 152);
              v6 = sub_80E2F4E(v5);
              sub_80D6D82((_DWORD *)v16, 3, v6, 1);
              return;
            }
            v11 = sub_80D6D82((_DWORD *)v16, 3, 1, 1);
          }
          if ( v11 < 0 )
          {
            if ( *(_DWORD *)(v16 + 244) == 40 )
            {
              sub_80D6D82((_DWORD *)v16, 3, 2, 1);
            }
            else if ( *(_DWORD *)(v16 + 144) <= v15 )
            {
              sub_80D6D82((_DWORD *)v16, 3, 1, 1);
            }
            else
            {
              sub_80D6D82((_DWORD *)v16, 3, 31, 1);
            }
          }
        }
      }
    }
  }
}
// 85760F8: using guessed type int dword_85760F8;
// 8576100: using guessed type int dword_8576100;
// 8576104: using guessed type int dword_8576104;
// 857610C: using guessed type int dword_857610C;
// 857611C: using guessed type int dword_857611C;
// 8576120: using guessed type int dword_8576120;

//----- (080E4060) --------------------------------------------------------
int __cdecl sub_80E4060(int a1)
{
  int result; // eax
  int v2; // [esp+2Ch] [ebp-6Ch]
  int v3; // [esp+30h] [ebp-68h]
  float v4; // [esp+38h] [ebp-60h]
  int v5; // [esp+40h] [ebp-58h]
  char v6; // [esp+50h] [ebp-48h]
  char v7; // [esp+73h] [ebp-25h]
  int v8; // [esp+88h] [ebp-10h]
  float v9; // [esp+8Ch] [ebp-Ch]

  v2 = *(_DWORD *)a1;
  if ( *(float *)(dword_8576084 + 8) <= (long double)*(float *)(a1 + 220) )
  {
    v9 = (*(float *)(a1 + 220) - *(float *)(dword_8576084 + 8))
       / (*(float *)(dword_8576088 + 8) - *(float *)(dword_8576084 + 8));
    if ( v9 > 1.0 )
      v9 = 1.0;
    v8 = (signed int)((long double)(*(_DWORD *)(dword_8576090 + 8) - *(_DWORD *)(dword_857608C + 8)) * v9
                    + (long double)*(signed int *)(dword_857608C + 8));
    result = a1;
    if ( v8 + *(_DWORD *)(v2 + 68) < *(_DWORD *)(a1 + 4) )
    {
      sub_80E71C0(a1 + 196, 0.75, (int)&v5);
      sub_80E71C0(a1 + 208, 0.75, (int)&v3);
      v4 = *(float *)(a1 + 216) * 0.89999998;
      result = sub_80DEC3C(a1, (int)&v6, v2 + 20, (int)&v5, (int)&v3, v2 + 20, *(_DWORD *)(v2 + 204), 2);
      if ( v7 )
      {
        sub_80DED2E(v2, 139);
        result = *(_DWORD *)(a1 + 4);
        *(_DWORD *)(v2 + 68) = result;
      }
    }
  }
  else
  {
    result = a1;
    if ( *(_DWORD *)(dword_8576094 + 8) + *(_DWORD *)(v2 + 68) < *(_DWORD *)(a1 + 4) )
    {
      result = *(_DWORD *)a1;
      *(_DWORD *)(v2 + 68) = 0;
    }
  }
  return result;
}
// 8576084: using guessed type int dword_8576084;
// 8576088: using guessed type int dword_8576088;
// 857608C: using guessed type int dword_857608C;
// 8576090: using guessed type int dword_8576090;
// 8576094: using guessed type int dword_8576094;

//----- (080E4212) --------------------------------------------------------
_DWORD *__cdecl sub_80E4212(_DWORD *a1, int a2)
{
  _DWORD *result; // eax

  if ( a1[4] )
  {
    if ( *(_DWORD *)(a2 + 40) < a1[4] )
    {
      a1[4] -= *(_DWORD *)(a2 + 40);
    }
    else
    {
      a1[3] &= 0xFFF7F9FF;
      a1[4] = 0;
    }
  }
  if ( a1[30] > 0 )
  {
    a1[30] -= *(_DWORD *)(a2 + 40);
    if ( a1[30] < 0 )
      a1[30] = 0;
  }
  result = a1;
  if ( a1[32] > 0 )
  {
    a1[32] -= *(_DWORD *)(a2 + 40);
    result = a1;
    if ( a1[32] < 0 )
    {
      result = a1;
      a1[32] = 0;
    }
  }
  return result;
}

//----- (080E42D0) --------------------------------------------------------
void __cdecl sub_80E42D0(int a1, float a2, int a3, int a4)
{
  float v4; // ST38_4
  float v5; // [esp+34h] [ebp-94h]
  float v6; // [esp+3Ch] [ebp-8Ch]
  float v7; // [esp+40h] [ebp-88h]
  float v8; // [esp+78h] [ebp-50h]
  int v9; // [esp+7Ch] [ebp-4Ch]
  char v10; // [esp+80h] [ebp-48h]
  char v11; // [esp+90h] [ebp-38h]
  int v12; // [esp+A0h] [ebp-28h]
  char v13; // [esp+B0h] [ebp-18h]
  float v14; // [esp+B8h] [ebp-10h]

  v9 = 0;
  v8 = 0.0;
  if ( *(_BYTE *)(a3 + 4) & 0xC0
    && *(_WORD *)(a1 + 12) >= 0
    && *(_DWORD *)(a1 + 4) <= 5
    && (*(_DWORD *)(a1 + 96) != 1023 || *(_DWORD *)(a1 + 4) == 1) )
  {
    if ( *(_DWORD *)(a3 + 4) & 0x40 )
      --v9;
    if ( *(_BYTE *)(a3 + 4) < 0 )
      ++v9;
  }
  if ( *(_DWORD *)(a1 + 160) & 0x300 )
    v9 = 0;
  if ( sub_80DEE0E(a1) == 1 )
    v6 = 0.25;
  else
    v6 = 0.5;
  v8 = *(float *)(a1 + 76);
  if ( v9 )
  {
    if ( v9 <= 0 )
    {
      if ( v8 > -v6 )
        v8 = v8 - a2 / 350.0 * v6;
      if ( -v6 > (long double)v8 )
        LODWORD(v8) = LODWORD(v6) ^ 0x80000000;
    }
    else
    {
      if ( v6 > (long double)v8 )
        v8 = a2 / 350.0 * v6 + v8;
      if ( v8 > (long double)v6 )
        v8 = v6;
    }
  }
  else if ( v8 <= 0.0 )
  {
    if ( v8 < 0.0 )
    {
      v8 = a2 / 280.0 * v6 + v8;
      if ( v8 > 0.0 )
        v8 = 0.0;
    }
  }
  else
  {
    v8 = v8 - a2 / 280.0 * v6;
    if ( v8 < 0.0 )
      v8 = 0.0;
  }
  *(float *)(a1 + 76) = v8;
  if ( *(float *)(a1 + 76) != 0.0 )
  {
    v4 = (long double)(signed int)sub_80E6F12(*(_DWORD *)(a1 + 76));
    sub_80E70CA((_DWORD *)(a1 + 20), &v13);
    v14 = v14 + *(float *)(a1 + 248);
    sub_80E70CA(&v13, &v12);
    sub_80B66C0((int)&v12, *(_DWORD *)(a1 + 236), v4, 16.0, 20.0);
    sub_80E70A6(&v11, -1056964608, -1056964608, -1056964608);
    sub_80E70A6(&v10, 1090519040, 1090519040, 1090519040);
    ((void (__cdecl *)(float *, char *, char *, char *, int *, _DWORD, signed int))a4)(
      &v7,
      &v13,
      &v11,
      &v10,
      &v12,
      *(_DWORD *)(a1 + 204),
      42008593);
    v5 = sub_80B66A6(v7);
    if ( sub_80E6E42(*(float *)(a1 + 76)) > v5 )
      *(float *)(a1 + 76) = (long double)(signed int)sub_80E6F12(*(_DWORD *)(a1 + 76)) * v5;
  }
}

//----- (080E4688) --------------------------------------------------------
int __usercall sub_80E4688@<eax>(long double a1@<st0>, int a2, float a3, int a4)
{
  float v4; // ST50_4
  float v5; // ST48_4
  float v6; // ST00_4
  float v7; // ST4C_4
  float v8; // ST44_4

  sub_80A6258(a3, *(float *)(a2 + 236));
  v4 = a1;
  v5 = sub_80E6E42(v4) / 240.0;
  v6 = a3 - (1.0 - v5) * v4;
  v7 = sub_80A6154(v6);
  v8 = v5 * 45.0 + (1.0 - v5) * 66.0;
  return sub_80DE734(
           *(_DWORD *)(a2 + 204),
           a2 + 20,
           *(_DWORD *)(a2 + 1400),
           1106247680,
           v7,
           a2 + 1448,
           a2 + 1452,
           a2 + 1456,
           1,
           *(_DWORD *)(a2 + 96) != 1023,
           0,
           (unsigned __int8)a4,
           0,
           v8);
}

//----- (080E4794) --------------------------------------------------------
void __cdecl sub_80E4794(int a1, float a2, int a3, int a4)
{
  long double v4; // fst7
  int v5; // edi
  long double v6; // fst7
  long double v7; // fst7
  int j; // eax
  long double v9; // fst7
  float v10; // ST00_4
  long double v11; // fst7
  int k; // eax
  long double v13; // fst7
  float v14; // ST00_4
  float v15; // ST00_4
  long double v16; // fst7
  float v17; // ST50_4
  float v18; // ST54_4
  float v19; // ST00_4
  float v20; // [esp+0h] [ebp-88h]
  float v21; // [esp+0h] [ebp-88h]
  float v22; // [esp+0h] [ebp-88h]
  float v23; // [esp+0h] [ebp-88h]
  signed int v24; // [esp+44h] [ebp-44h]
  int v25; // [esp+48h] [ebp-40h]
  float v26; // [esp+4Ch] [ebp-3Ch]
  float v27; // [esp+54h] [ebp-34h]
  signed int v28; // [esp+58h] [ebp-30h]
  float v29; // [esp+5Ch] [ebp-2Ch]
  float v30; // [esp+60h] [ebp-28h]
  _BOOL4 v31; // [esp+64h] [ebp-24h]
  _BOOL4 v32; // [esp+64h] [ebp-24h]
  int v33; // [esp+68h] [ebp-20h]
  int v34; // [esp+68h] [ebp-20h]
  float v35; // [esp+6Ch] [ebp-1Ch]
  float v36; // [esp+6Ch] [ebp-1Ch]
  float v37; // [esp+70h] [ebp-18h]
  float v38; // [esp+70h] [ebp-18h]
  float v39; // [esp+70h] [ebp-18h]
  float v40; // [esp+70h] [ebp-18h]
  float v41; // [esp+70h] [ebp-18h]
  float v42; // [esp+70h] [ebp-18h]
  float v43; // [esp+70h] [ebp-18h]
  float v44; // [esp+70h] [ebp-18h]
  float v45; // [esp+70h] [ebp-18h]
  float v46; // [esp+70h] [ebp-18h]
  int i; // [esp+74h] [ebp-14h]
  __int16 v48; // [esp+78h] [ebp-10h]
  unsigned __int8 v49; // [esp+7Bh] [ebp-Dh]

  v49 = a4;
  if ( *(_DWORD *)(a1 + 4) != 5 )
  {
    if ( *(_DWORD *)(a1 + 4) <= 5 )
    {
      v30 = *(float *)(a1 + 236);
      v25 = (unsigned __int16)(signed int)(*(float *)(dword_8576074 + 8) * 182.04445);
      v4 = *(float *)(dword_8576078 + 8) * 182.04445;
      v24 = (unsigned __int16)(signed int)v4;
      for ( i = 0; i <= 2; ++i )
      {
        v48 = *(_WORD *)(a1 + 4 * i + 84) + *(_WORD *)(a3 + 4 * i + 12);
        if ( !i )
        {
          if ( v48 <= v24 )
          {
            if ( v48 < -v25 )
            {
              *(_DWORD *)(a1 + 4 * i + 84) = -v25 - *(_DWORD *)(a3 + 4 * i + 12);
              v48 = -(signed __int16)v25;
            }
          }
          else
          {
            *(_DWORD *)(a1 + 4 * i + 84) = v24 - *(_DWORD *)(a3 + 4 * i + 12);
            v48 = v24;
          }
        }
        v4 = (long double)v48 * 0.0054931641;
        *(float *)(a1 + 4 * i + 232) = v4;
      }
      v29 = *(float *)(a1 + 236);
      if ( *(_DWORD *)(a1 + 160) & 0x300 )
      {
        for ( i = 0; i <= 1; ++i )
        {
          sub_80A6258(*(float *)(a1 + 4 * i + 268), *(float *)(a1 + 4 * i + 232));
          v37 = v4;
          if ( v37 <= (long double)*(float *)(a1 + 4 * i + 276) )
          {
            v4 = v37;
            if ( -*(float *)(a1 + 4 * i + 276) <= (long double)v37 )
              continue;
          }
          if ( v37 <= (long double)*(float *)(a1 + 4 * i + 276) )
            v38 = v37 + *(float *)(a1 + 4 * i + 276);
          else
            v38 = v37 - *(float *)(a1 + 4 * i + 276);
          *(_DWORD *)(a1 + 4 * i + 84) += (unsigned __int16)(signed int)(v38 * 182.04445);
          if ( v38 <= 0.0 )
          {
            v5 = i;
            v20 = *(float *)(a1 + 4 * i + 268) + *(float *)(a1 + 4 * i + 276);
          }
          else
          {
            v5 = i;
            v20 = *(float *)(a1 + 4 * i + 268) - *(float *)(a1 + 4 * i + 276);
          }
          v4 = sub_80A6154(v20);
          *(float *)(a1 + 4 * v5 + 232) = v4;
        }
      }
      else if ( *(_DWORD *)(a1 + 12) & 4 )
      {
        sub_80DBD56(v4, a1);
      }
      else
      {
        if ( *(_DWORD *)(a1 + 12) & 0x20 )
        {
          if ( *(_DWORD *)(a1 + 96) == 1023 )
          {
            v4 = 0.0;
            if ( *(float *)(dword_857607C + 8) != 0.0 )
            {
              v6 = sub_80A29F6((float *)(a1 + 100)) + 180.0;
              v26 = v6;
              sub_80A6258(v26, *(float *)(a1 + 236));
              v39 = v6;
              if ( v39 > (long double)*(float *)(dword_857607C + 8)
                || (v4 = v39, -*(float *)(dword_857607C + 8) > (long double)v39) )
              {
                if ( v39 <= (long double)*(float *)(dword_857607C + 8) )
                  v40 = v39 + *(float *)(dword_857607C + 8);
                else
                  v40 = v39 - *(float *)(dword_857607C + 8);
                *(_DWORD *)(a1 + 88) += (unsigned __int16)(signed int)(v40 * 182.04445);
                if ( v40 <= 0.0 )
                  v21 = v26 + *(float *)(dword_857607C + 8);
                else
                  v21 = v26 - *(float *)(dword_857607C + 8);
                v4 = sub_80A6154(v21);
                *(float *)(a1 + 236) = v4;
              }
            }
          }
        }
        if ( *(_BYTE *)(a1 + 12) & 1 && !(*(_DWORD *)(a1 + 160) & 0x300) )
        {
          v28 = 0;
          sub_80A6258(*(float *)(a1 + 1412), *(float *)(a1 + 236));
          v41 = v4;
          if ( v41 > *(float *)(dword_8576080 + 8) - 5.0
            || (v7 = v41, -(*(float *)(dword_8576080 + 8) - 5.0) > v41)
            || (*(_BYTE *)(a3 + 24) || *(_BYTE *)(a3 + 25)) && (v7 = 0.0, v41 != 0.0) )
          {
            v7 = sub_80E6E42(v41);
            if ( a2 * 55.0 * 0.001 <= v7 )
            {
              if ( v41 <= 0.0 )
                v7 = a2 * 55.0 * 0.001 + *(float *)(a1 + 1412);
              else
                v7 = *(float *)(a1 + 1412) - a2 * 55.0 * 0.001;
              v35 = v7;
            }
            else
            {
              v35 = *(float *)(a1 + 236);
            }
            v31 = 1;
            for ( j = sub_80E4688(v7, a1, v35, v49); !j; j = sub_80E4688(v7, a1, v35, v49) )
            {
              if ( !v31 )
                goto LABEL_68;
              sub_80A6258(*(float *)(a1 + 1412), v35);
              v42 = v7;
              v9 = sub_80E6E42(v42);
              v31 = v9 > 1.0;
              if ( v9 <= 1.0 )
              {
                v28 = 1;
              }
              else if ( v42 <= 0.0 )
              {
                v42 = -1.0;
              }
              else
              {
                v42 = 1.0;
              }
              v10 = v35 + v42;
              v7 = sub_80A6154(v10);
              v35 = v7;
            }
            v33 = sub_80DE734(
                    *(_DWORD *)(a1 + 204),
                    a1 + 20,
                    *(_DWORD *)(a1 + 1400),
                    1106247680,
                    *(float *)(a1 + 236),
                    0,
                    0,
                    0,
                    1,
                    *(_DWORD *)(a1 + 96) != 1023,
                    0,
                    v49,
                    0,
                    45.0);
            if ( v33 )
            {
              v33 = sub_80DE734(
                      *(_DWORD *)(a1 + 204),
                      a1 + 20,
                      *(_DWORD *)(a1 + 1400),
                      1106247680,
                      v35,
                      0,
                      0,
                      0,
                      1,
                      *(_DWORD *)(a1 + 96) != 1023,
                      0,
                      v49,
                      0,
                      45.0);
              if ( v33 )
                *(float *)(a1 + 1412) = v35;
            }
            if ( !v33 )
              v28 = 1;
          }
LABEL_68:
          sub_80A6258(*(float *)(a1 + 1412), *(float *)(a1 + 236));
          v43 = v7;
          v11 = 0.0;
          if ( v43 != 0.0 )
          {
            v36 = *(float *)(a1 + 1412);
            v32 = 1;
LABEL_70:
            for ( k = sub_80DE734(
                        *(_DWORD *)(a1 + 204),
                        a1 + 20,
                        *(_DWORD *)(a1 + 1400),
                        1106247680,
                        v36,
                        0,
                        0,
                        0,
                        1,
                        *(_DWORD *)(a1 + 96) != 1023,
                        0,
                        v49,
                        0,
                        45.0);
                  ;
                  k = sub_80DE734(
                        *(_DWORD *)(a1 + 204),
                        a1 + 20,
                        *(_DWORD *)(a1 + 1400),
                        1106247680,
                        v36,
                        0,
                        0,
                        0,
                        1,
                        *(_DWORD *)(a1 + 96) != 1023,
                        0,
                        v49,
                        0,
                        45.0) )
            {
              v34 = k;
              if ( k )
              {
                if ( sub_80E4688(v11, a1, v36, v49) )
                  break;
              }
              if ( !v32 )
                goto LABEL_81;
              v13 = sub_80E6E42(v43);
              v32 = v13 > 1.0;
              if ( v13 > 1.0 )
              {
                if ( v43 <= 0.0 )
                  v43 = -1.0;
                else
                  v43 = 1.0;
              }
              v28 = 1;
              *(_DWORD *)(a1 + 88) += (unsigned __int16)(signed int)(v43 * 182.04445);
              v14 = *(float *)(a1 + 236) + v43;
              v11 = sub_80A6154(v14);
              *(float *)(a1 + 236) = v11;
              sub_80A6258(*(float *)(a1 + 1412), *(float *)(a1 + 236));
              v43 = v11;
              if ( v34 )
                goto LABEL_70;
              v15 = v36 + v43;
              v11 = sub_80A6154(v15);
              v36 = v11;
            }
            *(float *)(a1 + 1412) = v36;
          }
LABEL_81:
          if ( v43 > (long double)*(float *)(dword_8576080 + 8)
            || (v16 = v43, -*(float *)(dword_8576080 + 8) > (long double)v43) )
          {
            if ( v43 <= (long double)*(float *)(dword_8576080 + 8) )
              v44 = v43 + *(float *)(dword_8576080 + 8);
            else
              v44 = v43 - *(float *)(dword_8576080 + 8);
            *(_DWORD *)(a1 + 88) += (unsigned __int16)(signed int)(v44 * 182.04445);
            if ( v44 <= 0.0 )
              v22 = *(float *)(a1 + 1412) + *(float *)(dword_8576080 + 8);
            else
              v22 = *(float *)(a1 + 1412) - *(float *)(dword_8576080 + 8);
            v16 = sub_80A6154(v22);
            *(float *)(a1 + 236) = v16;
          }
          if ( v28 )
          {
            *(_DWORD *)(a1 + 12) |= 0x10000u;
            sub_80A6258(v30, *(float *)(a1 + 236));
            v27 = v16;
            v16 = sub_80E6E42(v27);
            if ( v16 <= 1.0 )
            {
              sub_80A6258(v29, *(float *)(a1 + 236));
              v17 = v16;
              v16 = 0.0;
              if ( v27 * v17 > 0.0 )
              {
                v18 = v27 * 0.98000002;
                v19 = *(float *)(a1 + 236) + v18;
                *(float *)(a1 + 236) = sub_80A6154(v19);
                v16 = v18 * 182.04445;
                *(_DWORD *)(a1 + 88) += (unsigned __int16)(signed int)v16;
              }
            }
          }
          sub_80A6258(*(float *)(a1 + 1420), *(float *)(a1 + 232));
          v45 = v16;
          if ( v45 > 45.0 || v45 < -45.0 )
          {
            if ( v45 <= 45.0 )
              v46 = v45 + 45.0;
            else
              v46 = v45 - 45.0;
            *(_DWORD *)(a1 + 84) += (unsigned __int16)(signed int)(v46 * 182.04445);
            if ( v46 <= 0.0 )
              v23 = *(float *)(a1 + 1420) + 45.0;
            else
              v23 = *(float *)(a1 + 1420) - 45.0;
            *(float *)(a1 + 232) = sub_80A61D2(v23);
          }
        }
        if ( *(_DWORD *)(a1 + 4) != 3 && *(_DWORD *)(a1 + 4) != 2 && *(_DWORD *)(a1 + 4) != 4 )
          sub_80E42D0(a1, a2, a3, (int)*(&off_8166520 + 3 * v49));
      }
    }
    else
    {
      v48 = *(_WORD *)(a1 + 88) + *(_WORD *)(a3 + 16);
      if ( *(_DWORD *)(a1 + 304) == 999 )
        *(_DWORD *)(a1 + 304) = (signed int)((long double)v48 * 0.0054931641);
      sub_80E42D0(a1, a2, a3, (int)*(&off_8166520 + 3 * v49));
    }
  }
}
// 8166520: using guessed type int (__cdecl *off_8166520)(void *s, int, int, int, int, int, int);
// 8576074: using guessed type int dword_8576074;
// 8576078: using guessed type int dword_8576078;
// 857607C: using guessed type int dword_857607C;
// 8576080: using guessed type int dword_8576080;

//----- (080E54DC) --------------------------------------------------------
void __usercall sub_80E54DC(long double a1@<st0>, unsigned __int8 *a2, int a3)
{
  int v3; // eax
  float v4; // ST50_4
  long double v5; // fst7
  float v6; // ST50_4
  int v7; // [esp+2Ch] [ebp-2Ch]
  int v8; // [esp+44h] [ebp-14h]
  float v9; // [esp+48h] [ebp-10h]
  float v10; // [esp+48h] [ebp-10h]

  v8 = *(_DWORD *)a2;
  if ( !((*(_BYTE *)(*(_DWORD *)a2 + 12) ^ 1) & 1) )
  {
    if ( *(_DWORD *)(v8 + 96) == 1023 )
    {
      v7 = a2[228];
      if ( *(_DWORD *)(a3 + 48) )
        v3 = sub_80DE734(
               *(_DWORD *)(v8 + 204),
               v8 + 20,
               *(_DWORD *)(v8 + 1400),
               1106247680,
               *(float *)(v8 + 1412),
               v8 + 1448,
               v8 + 1452,
               v8 + 1456,
               1,
               *(_DWORD *)(v8 + 96) != 1023,
               a3 + 60,
               v7,
               0,
               66.0);
      else
        v3 = sub_80DE734(
               *(_DWORD *)(v8 + 204),
               v8 + 20,
               *(_DWORD *)(v8 + 1400),
               1106247680,
               *(float *)(v8 + 1412),
               v8 + 1448,
               v8 + 1452,
               v8 + 1456,
               1,
               *(_DWORD *)(v8 + 96) != 1023,
               0,
               v7,
               0,
               66.0);
      if ( !v3 )
      {
        sub_80DD554(141, 0, v8);
        *(_DWORD *)(v8 + 12) |= 0x10000u;
      }
    }
    else if ( *(_DWORD *)(a3 + 48) )
    {
      a1 = *(float *)(a3 + 68);
      if ( a1 < 0.69999999 )
        sub_80DD554(141, 0, v8);
    }
    if ( *(_DWORD *)(a3 + 48) )
    {
      sub_80A86CC(*(float *)(v8 + 1412), a3 + 60);
      v4 = a1;
      sub_80A6258(v4, *(float *)(v8 + 1416));
    }
    else
    {
      sub_80A6258(0.0, *(float *)(v8 + 1416));
    }
    v9 = a1;
    v5 = 0.0;
    if ( v9 != 0.0 )
    {
      if ( sub_80E6E42(v9) <= *(float *)(a3 + 36) * 70.0 )
        *(float *)(v8 + 1416) = *(float *)(v8 + 1416) + v9;
      else
        *(float *)(v8 + 1416) = (long double)(signed int)sub_80E6F12(LODWORD(v9)) * (*(float *)(a3 + 36) * 70.0)
                              + *(float *)(v8 + 1416);
      v5 = sub_80A61D2(*(float *)(v8 + 1416));
      *(float *)(v8 + 1416) = v5;
    }
    if ( *(_DWORD *)(a3 + 48) )
    {
      sub_80A86CC(*(float *)(v8 + 236), a3 + 60);
      v6 = v5;
      sub_80A6258(v6, *(float *)(v8 + 1420));
    }
    else
    {
      sub_80A6258(0.0, *(float *)(v8 + 1420));
    }
    v10 = v5;
    if ( v10 != 0.0 )
    {
      if ( sub_80E6E42(v10) <= *(float *)(a3 + 36) * 70.0 )
        *(float *)(v8 + 1420) = *(float *)(v8 + 1420) + v10;
      else
        *(float *)(v8 + 1420) = (long double)(signed int)sub_80E6F12(LODWORD(v10)) * (*(float *)(a3 + 36) * 70.0)
                              + *(float *)(v8 + 1420);
      *(float *)(v8 + 1420) = sub_80A61D2(*(float *)(v8 + 1420));
    }
  }
}

//----- (080E5820) --------------------------------------------------------
int __cdecl sub_80E5820(int a1)
{
  int result; // eax

  result = *(_DWORD *)(a1 + 12) & 1;
  if ( (_BYTE)result )
  {
    result = a1;
    *(_DWORD *)(a1 + 12) |= 0x800u;
  }
  return result;
}

//----- (080E5844) --------------------------------------------------------
int __cdecl sub_80E5844(_DWORD *a1)
{
  int result; // eax
  _DWORD *v2; // [esp+0h] [ebp-4h]

  v2 = (_DWORD *)*a1;
  v2[3] &= 0xFFFFFEFF;
  result = (int)v2;
  if ( v2[1] <= 5 )
  {
    result = a1[2] & 0x1000;
    if ( result )
    {
      result = v2[3] & 1;
      if ( !(_BYTE)result )
      {
        result = v2[3] & 0x40;
        if ( result )
        {
          result = (int)v2;
          if ( v2[54] != 5 )
          {
            result = (int)v2;
            if ( v2[54] != 7 )
            {
              result = (int)v2;
              if ( v2[54] != 9 )
              {
                result = (int)v2;
                if ( v2[54] != 8 )
                {
                  result = (int)v2;
                  if ( v2[54] != 6 )
                  {
                    result = (int)v2;
                    v2[3] |= 0x100u;
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  return result;
}

//----- (080E58EE) --------------------------------------------------------
int __cdecl sub_80E58EE(int a1)
{
  int result; // eax

  result = a1;
  *(_DWORD *)(a1 + 12) |= 0x20u;
  return result;
}

//----- (080E5902) --------------------------------------------------------
int __cdecl sub_80E5902(int a1)
{
  int result; // eax

  if ( *(_DWORD *)(a1 + 12) & 0x20 )
    *(_DWORD *)(a1 + 12) |= 0x40000u;
  result = a1;
  *(_DWORD *)(a1 + 12) &= 0xFFFFFFDF;
  return result;
}

//----- (080E5936) --------------------------------------------------------
int __cdecl sub_80E5936(int a1, int *a2)
{
  int result; // eax
  signed int v3; // [esp+20h] [ebp-88h]
  _DWORD *v4; // [esp+24h] [ebp-84h]
  signed int v5; // [esp+2Ch] [ebp-7Ch]
  float v6; // [esp+30h] [ebp-78h]
  int v7; // [esp+34h] [ebp-74h]
  int v8; // [esp+40h] [ebp-68h]
  float v9; // [esp+60h] [ebp-48h]
  float v10; // [esp+64h] [ebp-44h]
  float v11; // [esp+68h] [ebp-40h]
  float v12; // [esp+70h] [ebp-38h]
  float v13; // [esp+74h] [ebp-34h]
  float v14; // [esp+78h] [ebp-30h]
  int v15; // [esp+80h] [ebp-28h]
  int v16; // [esp+84h] [ebp-24h]
  int v17; // [esp+88h] [ebp-20h]
  int v18; // [esp+90h] [ebp-18h]

  v4 = *(_DWORD **)a1;
  if ( a2[11] )
    v4[3] &= 0xFFFBFFFF;
  if ( !v4[4] || (result = v4[3] & 0x600) == 0 )
  {
    if ( a2[11] )
      v5 = 1090519040;
    else
      v5 = 1106247680;
    v3 = 0;
    if ( v4[3] & 0x20 && v4[24] == 1023 )
      v3 = 1;
    if ( v3 )
    {
      sub_80E70FA(v4 + 25, (unsigned int *)&v15);
    }
    else
    {
      v15 = *a2;
      v16 = a2[1];
      v17 = 0;
      sub_80A20C0((float *)&v15);
    }
    if ( v4[1] > 5 )
    {
      v4[24] = 1023;
      a2[12] = 0;
      a2[13] = 0;
      a2[11] = 0;
      return sub_80E5902((int)v4);
    }
    if ( v4[3] & 0x40000 )
      return sub_80E5902((int)v4);
    if ( sub_80DEE0E((int)v4) == 1 )
      return sub_80E5902((int)v4);
    if ( *(_DWORD *)(a1 + 4) - v4[28] <= 299 )
      return sub_80E5902((int)v4);
    sub_80E70CA((_DWORD *)(a1 + 196), &v12);
    v12 = v12 + 6.0;
    v13 = v13 + 6.0;
    v14 = 8.0;
    sub_80E70CA((_DWORD *)(a1 + 208), &v9);
    v9 = v9 - 6.0;
    v10 = v10 - 6.0;
    if ( v14 > (long double)v11 )
      v11 = v14;
    sub_80E71F8((int)(v4 + 5), *(float *)&v5, (int)&v15, (int)&v18);
    sub_80DEC3C(a1, (int)&v6, (int)(v4 + 5), (int)&v12, (int)&v9, (int)&v18, v4[51], *(_DWORD *)(a1 + 60));
    if ( v6 < 1.0 && v8 & 8 && (!a2[11] || *(_BYTE *)(a1 + 28) > 0) )
    {
      if ( v4[3] & 0x20 )
        return sub_80E58EE((int)v4);
      sub_80E70CA(&v7, v4 + 25);
      sub_80E70FA(v4 + 25, (unsigned int *)&v15);
      sub_80E71F8((int)(v4 + 5), *(float *)&v5, (int)&v15, (int)&v18);
      sub_80DEC3C(a1, (int)&v6, (int)(v4 + 5), (int)&v12, (int)&v9, (int)&v18, v4[51], *(_DWORD *)(a1 + 60));
      if ( v6 < 1.0 && v8 & 8 )
        return sub_80E58EE((int)v4);
    }
    result = sub_80E5902((int)v4);
    if ( v3 )
      result = sub_80D6FCA(v4, 3, 0, 1);
  }
  return result;
}

//----- (080E5D4A) --------------------------------------------------------
int __cdecl sub_80E5D4A(int a1, int a2)
{
  int result; // eax
  float v3; // ST08_4
  float v4; // ST2C_4
  float v5; // ST40_4
  float v6; // ST40_4
  float v7; // ST28_4
  long double v8; // fst7
  int v9; // [esp+20h] [ebp-78h]
  int v10; // [esp+30h] [ebp-68h]
  signed int v11; // [esp+34h] [ebp-64h]
  float v12; // [esp+38h] [ebp-60h]
  float v13; // [esp+3Ch] [ebp-5Ch]
  int v14; // [esp+40h] [ebp-58h]
  float v15; // [esp+4Ch] [ebp-4Ch]
  char v16; // [esp+50h] [ebp-48h]
  int v17; // [esp+60h] [ebp-38h]
  float v18; // [esp+68h] [ebp-30h]
  int v19; // [esp+70h] [ebp-28h]
  float v20; // [esp+88h] [ebp-10h]
  float v21; // [esp+8Ch] [ebp-Ch]

  v10 = *(_DWORD *)a1;
  if ( (unsigned __int8)sub_80DA584(a1, (int *)a2) )
    return sub_80DFCD4(a1, a2);
  v15 = (*(float *)(a2 + 8) + 0.25) * 2.5;
  if ( v15 <= 1.0 )
  {
    if ( v15 < -1.0 )
      v15 = -1.0;
  }
  else
  {
    v15 = 1.0;
  }
  *(_DWORD *)(a2 + 8) = 0;
  sub_80A20C0((float *)a2);
  *(_DWORD *)(a2 + 20) = 0;
  sub_80A2298((float *)(a2 + 12), (int)&v16);
  sub_80A7D80((float *)&v16, (float *)(v10 + 100), a2 + 12);
  v20 = sub_80DF3FA(v10, a1 + 4);
  sub_80E707C(&v17);
  if ( *(_BYTE *)(a1 + 28) )
    v18 = v15 * 0.5 * v20 * (long double)*(char *)(a1 + 28);
  if ( *(_BYTE *)(a1 + 29) )
  {
    v3 = v20 * 0.2 * (long double)*(char *)(a1 + 29);
    sub_80E71F8((int)&v17, v3, a2 + 12, (int)&v17);
  }
  v21 = sub_80A2298((float *)&v17, (int)&v19);
  sub_80DF16A(v10, a2, (int)&v19, v21, 9.0);
  if ( !*(_BYTE *)(a1 + 28) )
  {
    if ( *(float *)(v10 + 40) <= 0.0 )
    {
      *(float *)(v10 + 40) = (long double)*(signed int *)(v10 + 72) * *(float *)(a2 + 36) + *(float *)(v10 + 40);
      if ( *(float *)(v10 + 40) > 0.0 )
        *(_DWORD *)(v10 + 40) = 0;
    }
    else
    {
      *(float *)(v10 + 40) = *(float *)(v10 + 40) - (long double)*(signed int *)(v10 + 72) * *(float *)(a2 + 36);
      if ( *(float *)(v10 + 40) < 0.0 )
        *(_DWORD *)(v10 + 40) = 0;
    }
  }
  if ( !*(_BYTE *)(a1 + 29) )
  {
    sub_80E6F38((_DWORD *)(a2 + 12), &v14);
    sub_80A215E((float *)&v14);
    v13 = sub_80E700C((float *)&v14, (float *)(v10 + 32));
    if ( v13 != 0.0 )
    {
      sub_80E6FD6(v10 + 32, COERCE_FLOAT(LODWORD(v13) ^ 0x80000000), (int)&v14, v10 + 32);
      v12 = v13 * *(float *)(a2 + 36) * 16.0;
      v4 = sub_80E6E42(v13);
      if ( v4 > sub_80E6E42(v12) )
      {
        if ( sub_80E6E42(v12) < 1.0 )
          v12 = (long double)(signed int)sub_80E6F12(LODWORD(v12));
        v5 = v13 - v12;
        sub_80E6FD6(v10 + 32, v5, (int)&v14, v10 + 32);
      }
    }
  }
  if ( !*(_DWORD *)(a2 + 44) )
  {
    v6 = sub_80E700C((float *)(v10 + 100), (float *)(v10 + 32));
    sub_80E6FD6(v10 + 32, COERCE_FLOAT(LODWORD(v6) ^ 0x80000000), v10 + 100, v10 + 32);
    v7 = sub_80E702E((float *)(v10 + 32));
    if ( sub_80E6F06(*(float *)(v10 + 40)) >= v7 )
      sub_80E6FD6(v10 + 32, -50.0, v10 + 100, v10 + 32);
  }
  sub_80E7CC0((int *)a1, a2, 0);
  v8 = sub_80A29F6((float *)(v10 + 100)) + 180.0;
  v20 = v8;
  sub_80A6258(v20, *(float *)(v10 + 236));
  v11 = (signed int)v8;
  v9 = (signed int)v8;
  if ( (signed int)v8 < 0 )
    v9 = -v9;
  if ( v9 > 75 )
  {
    if ( v11 <= 0 )
      LOBYTE(v11) = -75;
    else
      LOBYTE(v11) = 75;
  }
  result = (char)v11;
  *(_DWORD *)(v10 + 156) = (char)v11;
  return result;
}

//----- (080E6200) --------------------------------------------------------
void __cdecl sub_80E6200(int a1)
{
  float v1; // ST04_4
  float v2; // ST28_4
  float v3; // ST04_4
  float v4; // ST04_4
  float v5; // ST24_4
  float v6; // ST04_4
  unsigned int v7; // edx
  long double v8; // fst7
  float v9; // ST08_4
  long double v10; // fst7
  float v11; // ST30_4
  float v12; // ST2C_4
  long double v13; // fst7
  float v14; // ST08_4
  float v15; // ST08_4
  int v16; // [esp+30h] [ebp-B8h]
  int s[9]; // [esp+40h] [ebp-A8h]
  int v18[9]; // [esp+4Ch] [ebp-9Ch]
  int v19[9]; // [esp+58h] [ebp-90h]
  float v20; // [esp+64h] [ebp-84h]
  int v21; // [esp+68h] [ebp-80h]
  int v22; // [esp+6Ch] [ebp-7Ch]
  int v23; // [esp+70h] [ebp-78h]
  int v24; // [esp+74h] [ebp-74h]
  int v25; // [esp+A0h] [ebp-48h]
  int v26; // [esp+ACh] [ebp-3Ch]
  int v27; // [esp+CCh] [ebp-1Ch]
  int v28; // [esp+D0h] [ebp-18h]
  int v29; // [esp+DCh] [ebp-Ch]

  v27 = *(_DWORD *)a1;
  sub_80D72F8((float **)a1);
  if ( *(_WORD *)(v27 + 12) < 0 )
  {
    *(_DWORD *)(a1 + 8) &= 0x2300u;
    *(_BYTE *)(a1 + 28) = 0;
    *(_BYTE *)(a1 + 29) = 0;
    sub_80E70A6((_DWORD *)(v27 + 32), 0, 0, 0);
  }
  if ( *(_DWORD *)(a1 + 8) & 0x40000 )
  {
    *(_DWORD *)(a1 + 8) &= 0x43300u;
    *(_BYTE *)(a1 + 28) = 0;
    *(_BYTE *)(a1 + 29) = 0;
  }
  *(_DWORD *)(v27 + 12) &= 0xFFFEFFFF;
  if ( *(_DWORD *)(v27 + 4) > 5 )
    *(_DWORD *)(a1 + 60) &= 0xFDFFFFFF;
  if ( *(_BYTE *)(v27 + 12) & 1 )
  {
    if ( (*(_BYTE *)(a1 + 28) == *(_BYTE *)(a1 + 56)
       || (v1 = (long double)*(char *)(a1 + 28),
           v2 = sub_80E6E42(v1),
           v3 = (long double)*(char *)(a1 + 56),
           v2 <= sub_80E6E42(v3)))
      && (*(_BYTE *)(a1 + 29) == *(_BYTE *)(a1 + 57)
       || (v4 = (long double)*(char *)(a1 + 29),
           v5 = sub_80E6E42(v4),
           v6 = (long double)*(char *)(a1 + 57),
           v5 <= sub_80E6E42(v6))) )
    {
      if ( !(*(_DWORD *)(v27 + 12) & 0x40)
        && (!*(_DWORD *)(v27 + 216)
         || *(_DWORD *)(v27 + 216) == 1
         || *(_DWORD *)(v27 + 216) == 2
         || *(_DWORD *)(v27 + 216) == 5) )
      {
        *(_DWORD *)(v27 + 12) &= 0xFFFFF7FF;
      }
    }
    else if ( sub_80EABAA((_DWORD *)v27) )
    {
      *(_DWORD *)(v27 + 12) &= 0xFFFFF7FF;
      sub_80EA53E(v27);
    }
  }
  else
  {
    *(_DWORD *)(v27 + 12) &= 0xFFFFF7FF;
  }
  v29 = sub_80DEE0E(v27);
  if ( *(_DWORD *)(v27 + 12) & 0x40 && v29 == 1 )
  {
    *(_BYTE *)(a1 + 28) = 0;
    *(_BYTE *)(a1 + 29) = 0;
  }
  if ( *(_DWORD *)(a1 + 8) & 0x40000 )
    v7 = *(_DWORD *)(v27 + 160) | 0x200000;
  else
    v7 = *(_DWORD *)(v27 + 160) & 0xFFDFFFFF;
  *(_DWORD *)(v27 + 160) = v7;
  *(_DWORD *)(v27 + 160) &= 0xFFFFFFBF;
  if ( *(_DWORD *)(v27 + 4) != 5
    && !(*(_DWORD *)(v27 + 12) & 0x1000)
    && (!*(_DWORD *)(v27 + 216) || *(_DWORD *)(v27 + 216) == 3)
    && sub_80EAEC8(v27)
    && *(_BYTE *)(a1 + 8) & 1 )
  {
    *(_DWORD *)(v27 + 160) |= 0x40u;
  }
  if ( *(_DWORD *)(v27 + 4) <= 5 && !(*(_DWORD *)(a1 + 8) & 0x4001) )
    *(_DWORD *)(v27 + 12) &= 0xFFFFEFFF;
  memset(s, 0, 0x7Cu);
  v21 = *(_DWORD *)(a1 + 4) - *(_DWORD *)v27;
  if ( v21 > 0 )
  {
    if ( v21 > 200 )
      v21 = 200;
  }
  else
  {
    v21 = 1;
  }
  *(_DWORD *)v27 = *(_DWORD *)(a1 + 4);
  sub_80E70CA((_DWORD *)(v27 + 20), &v25);
  sub_80E70CA((_DWORD *)(v27 + 32), &v26);
  v20 = (long double)v21 * 0.001;
  sub_80EC2BA((_BYTE *)a1, (int)s);
  v8 = (long double)v21;
  v9 = v8;
  sub_80E4794(v27, v9, a1 + 4, *(unsigned __int8 *)(a1 + 228));
  sub_80A2EC2((float *)(v27 + 232), (int)s, (float *)v18, (float *)v19);
  if ( *(_BYTE *)(a1 + 28) >= 0 )
  {
    if ( *(_BYTE *)(a1 + 28) > 0 || !*(_BYTE *)(a1 + 28) && *(_BYTE *)(a1 + 29) )
      *(_DWORD *)(v27 + 12) &= 0xFFFFFF7F;
  }
  else
  {
    *(_DWORD *)(v27 + 12) |= 0x80u;
  }
  if ( *(_DWORD *)(v27 + 4) > 5 )
  {
    *(_BYTE *)(a1 + 28) = 0;
    *(_BYTE *)(a1 + 29) = 0;
  }
  if ( v29 == 1 && *(_DWORD *)(v27 + 12) & 0x800 )
  {
    *(_BYTE *)(a1 + 28) = 0;
    *(_BYTE *)(a1 + 29) = 0;
  }
  sub_80DBE96(v27);
  switch ( *(_DWORD *)(v27 + 4) )
  {
    case 0:
    case 6:
      if ( *(_DWORD *)(v27 + 160) & 0x300 )
      {
        sub_80E5902(v27);
        *(_DWORD *)(v27 + 96) = 1023;
        v23 = 0;
        v24 = 0;
        v22 = 0;
        sub_80E707C((_DWORD *)(v27 + 32));
        sub_80EA40E(a1, (int)s);
        sub_80E5844((_DWORD *)a1);
        sub_80E1F20(a1, (int)s);
        sub_80E4212((_DWORD *)v27, (int)s);
        sub_80E3008(a1, (int)s);
        sub_80EE212((_DWORD *)v27);
      }
      else
      {
        if ( !(*(_DWORD *)(v27 + 12) & 4) )
        {
          sub_80E1F20(a1, (int)s);
          sub_80E117E((int *)a1, s);
        }
        sub_80DB964((int *)a1, s);
        if ( *(_DWORD *)(v27 + 12) & 4 )
        {
          sub_80E5902(v27);
          *(_DWORD *)(v27 + 96) = 1023;
          v23 = 0;
          v22 = 0;
          sub_80EA40E(a1, (int)s);
          sub_80E5844((_DWORD *)a1);
          sub_80E1F20(a1, (int)s);
          sub_80DBB3C(a1, v27, (int)s);
          sub_80EDF3A(a1, (int)s);
        }
        else
        {
          sub_80EA40E(a1, (int)s);
          sub_80E5844((_DWORD *)a1);
          sub_80E54DC(v8, (unsigned __int8 *)a1, (int)s);
          if ( *(_DWORD *)(v27 + 4) == 6 )
            sub_80E02FE(v27, (int)s);
          sub_80E5936(a1, s);
          sub_80E4212((_DWORD *)v27, (int)s);
          if ( *(_DWORD *)(v27 + 12) & 0x20 )
          {
            sub_80E5D4A(a1, (int)s);
          }
          else if ( v22 )
          {
            sub_80DFE82((int *)a1, (int)s);
          }
          else
          {
            sub_80DFCD4(a1, (int)s);
          }
          sub_80E117E((int *)a1, s);
          sub_80E3008(a1, (int)s);
          sub_80EDF3A(a1, (int)s);
          sub_80E4060(a1);
          sub_80E717C((float *)(v27 + 20), (float *)&v25, (float *)&v16);
          v10 = sub_80E7280((float *)&v16);
          v11 = v10 / (v20 * v20);
          v12 = sub_80E7280((float *)(v27 + 32));
          v13 = v11;
          if ( v12 * 0.25 > v11 )
          {
            v13 = 1.0 / v20;
            v14 = v13;
            sub_80E71C0((int)&v16, v14, v27 + 32);
          }
          sub_80E6F84((float *)(v27 + 32), (float *)(v27 + 44), (float *)&v28);
          sub_80E6EA0(v20, 1.0);
          v15 = v13;
          sub_80E6FB0((int)&v28, v15, (int)&v28);
          sub_80E6F58((float *)(v27 + 44), (float *)&v28, (float *)(v27 + 44));
          sub_80D3824((float *)(v27 + 32));
        }
      }
      break;
    case 1:
    case 7:
      sub_80E5902(v27);
      *(_DWORD *)(v27 + 96) = 1023;
      v23 = 0;
      v24 = 0;
      v22 = 0;
      sub_80E707C((_DWORD *)(v27 + 32));
      sub_80EA40E(a1, (int)s);
      sub_80E5844((_DWORD *)a1);
      sub_80E1F20(a1, (int)s);
      sub_80E4212((_DWORD *)v27, (int)s);
      sub_80E3008(a1, (int)s);
      sub_80EDF3A(a1, (int)s);
      break;
    case 2:
      sub_80E5902(v27);
      sub_80EA40E(a1, (int)s);
      sub_80E5844((_DWORD *)a1);
      sub_80E037E(a1, (int)s);
      sub_80E4212((_DWORD *)v27, (int)s);
      sub_80EA568((float **)a1, (int)s);
      break;
    case 3:
      sub_80E5902(v27);
      sub_80EA40E(a1, (int)s);
      sub_80E5844((_DWORD *)a1);
      sub_80E05C8(a1, (int)s);
      sub_80E4212((_DWORD *)v27, (int)s);
      sub_80EA568((float **)a1, (int)s);
      break;
    case 4:
      sub_80E5902(v27);
      sub_80EA40E(a1, (int)s);
      sub_80E5844((_DWORD *)a1);
      sub_80E1F20(a1, (int)s);
      sub_80DFB3A(a1, (int)s);
      sub_80E4212((_DWORD *)v27, (int)s);
      sub_80EA568((float **)a1, (int)s);
      break;
    case 5:
      sub_80E5902(v27);
      sub_80EA40E(a1, (int)s);
      sub_80EA568((float **)a1, (int)s);
      break;
  }
}

//----- (080E6D30) --------------------------------------------------------
int __cdecl sub_80E6D30(_DWORD *a1)
{
  int result; // eax
  _DWORD *v2; // ecx
  int v3; // [esp+Ch] [ebp-Ch]
  int *v4; // [esp+10h] [ebp-8h]
  int v5; // [esp+14h] [ebp-4h]

  v4 = (int *)*a1;
  v5 = a1[1];
  result = v5;
  if ( v5 >= *(_DWORD *)*a1 )
  {
    if ( v5 > *v4 + 1000 )
      *v4 = v5 - 1000;
    a1[16] = 0;
    while ( 1 )
    {
      result = *v4;
      if ( *v4 == v5 )
        break;
      v3 = v5 - *v4;
      if ( v3 > 66 )
        v3 = 66;
      a1[1] = *v4 + v3;
      sub_80E6200((int)a1);
      v2 = a1 + 8;
      *v2 = a1[1];
      v2[1] = a1[2];
      v2[2] = a1[3];
      v2[3] = a1[4];
      v2[4] = a1[5];
      v2[5] = a1[6];
      v2[6] = a1[7];
    }
  }
  return result;
}

//----- (080E6DF4) --------------------------------------------------------
long double __cdecl sub_80E6DF4(int a1, int a2)
{
  float v3; // [esp+4h] [ebp-4h]

  if ( *(_DWORD *)(a1 + 12) & 0x20 )
  {
    if ( a2 - *(_DWORD *)(a1 + 112) > 499 )
      v3 = *(float *)(a1 + 40);
    else
      v3 = 0.0;
  }
  else
  {
    v3 = sub_80E7050(a1 + 32);
  }
  return v3;
}
// 80E7050: using guessed type double __cdecl sub_80E7050(_DWORD);

//----- (080E6E42) --------------------------------------------------------
long double __cdecl sub_80E6E42(float a1)
{
  return (float)fabs(a1);
}

//----- (080E6E5C) --------------------------------------------------------
long double __cdecl sub_80E6E5C(float a1)
{
  return (float)sqrt(a1);
}

//----- (080E6E7C) --------------------------------------------------------
void __cdecl sub_80E6E7C(float a1, float a2)
{
  float v2; // ST00_4

  v2 = a1 - a2;
  sub_80E72F2(v2, a1, a2);
}

//----- (080E6EA0) --------------------------------------------------------
void __cdecl sub_80E6EA0(float a1, float a2)
{
  float v2; // ST00_4

  v2 = a2 - a1;
  sub_80E72F2(v2, a1, a2);
}

//----- (080E6EC4) --------------------------------------------------------
int __cdecl sub_80E6EC4(int a1, int a2, int a3)
{
  int v3; // eax

  v3 = sub_80E731C(a1 - a3, a3, a1);
  return sub_80E731C(a2 - a1, a2, v3);
}

//----- (080E6F06) --------------------------------------------------------
long double __cdecl sub_80E6F06(float a1)
{
  return a1 * a1;
}

//----- (080E6F12) --------------------------------------------------------
unsigned int __cdecl sub_80E6F12(unsigned int a1)
{
  return -2 * sub_80E733C(a1) + 1;
}

//----- (080E6F38) --------------------------------------------------------
int __cdecl sub_80E6F38(_DWORD *a1, _DWORD *a2)
{
  int result; // eax

  *a2 = *a1;
  result = a1[1];
  a2[1] = result;
  return result;
}

//----- (080E6F58) --------------------------------------------------------
int __cdecl sub_80E6F58(float *a1, float *a2, float *a3)
{
  int result; // eax

  *a3 = *a1 + *a2;
  result = (int)(a1 + 1);
  a3[1] = a1[1] + a2[1];
  return result;
}

//----- (080E6F84) --------------------------------------------------------
int __cdecl sub_80E6F84(float *a1, float *a2, float *a3)
{
  int result; // eax

  *a3 = *a1 - *a2;
  result = (int)(a1 + 1);
  a3[1] = a1[1] - a2[1];
  return result;
}

//----- (080E6FB0) --------------------------------------------------------
int __cdecl sub_80E6FB0(int a1, float a2, int a3)
{
  int result; // eax

  *(float *)a3 = a2 * *(float *)a1;
  result = a1 + 4;
  *(float *)(a3 + 4) = a2 * *(float *)(a1 + 4);
  return result;
}

//----- (080E6FD6) --------------------------------------------------------
int __cdecl sub_80E6FD6(int a1, float a2, int a3, int a4)
{
  int result; // eax

  *(float *)a4 = a2 * *(float *)a3 + *(float *)a1;
  result = a3 + 4;
  *(float *)(a4 + 4) = a2 * *(float *)(a3 + 4) + *(float *)(a1 + 4);
  return result;
}

//----- (080E700C) --------------------------------------------------------
long double __cdecl sub_80E700C(float *a1, float *a2)
{
  return *a1 * *a2 + a1[1] * a2[1];
}

//----- (080E702E) --------------------------------------------------------
long double __cdecl sub_80E702E(float *a1)
{
  return *a1 * *a1 + a1[1] * a1[1];
}

//----- (080E7050) --------------------------------------------------------
void __cdecl sub_80E7050(float *a1)
{
  float v1; // ST00_4

  v1 = *a1 * *a1 + a1[1] * a1[1];
  sub_80E6E5C(v1);
}

//----- (080E707C) --------------------------------------------------------
int __cdecl sub_80E707C(_DWORD *a1)
{
  int result; // eax

  *a1 = 0;
  a1[1] = 0;
  result = 0;
  a1[2] = 0;
  return result;
}

//----- (080E70A6) --------------------------------------------------------
int __cdecl sub_80E70A6(_DWORD *a1, int a2, int a3, int a4)
{
  int result; // eax

  *a1 = a2;
  a1[1] = a3;
  result = a4;
  a1[2] = a4;
  return result;
}

//----- (080E70CA) --------------------------------------------------------
int __cdecl sub_80E70CA(_DWORD *a1, _DWORD *a2)
{
  int result; // eax

  *a2 = *a1;
  a2[1] = a1[1];
  result = a1[2];
  a2[2] = result;
  return result;
}

//----- (080E70FA) --------------------------------------------------------
unsigned int __cdecl sub_80E70FA(_DWORD *a1, unsigned int *a2)
{
  unsigned int result; // eax

  *a2 = *a1 ^ 0x80000000;
  a2[1] = a1[1] ^ 0x80000000;
  result = a1[2] ^ 0x80000000;
  a2[2] = result;
  return result;
}

//----- (080E7138) --------------------------------------------------------
int __cdecl sub_80E7138(float *a1, float *a2, float *a3)
{
  int result; // eax

  *a3 = *a1 + *a2;
  a3[1] = a1[1] + a2[1];
  result = (int)(a1 + 2);
  a3[2] = a1[2] + a2[2];
  return result;
}

//----- (080E717C) --------------------------------------------------------
int __cdecl sub_80E717C(float *a1, float *a2, float *a3)
{
  int result; // eax

  *a3 = *a1 - *a2;
  a3[1] = a1[1] - a2[1];
  result = (int)(a1 + 2);
  a3[2] = a1[2] - a2[2];
  return result;
}

//----- (080E71C0) --------------------------------------------------------
int __cdecl sub_80E71C0(int a1, float a2, int a3)
{
  int result; // eax

  *(float *)a3 = a2 * *(float *)a1;
  *(float *)(a3 + 4) = a2 * *(float *)(a1 + 4);
  result = a1 + 8;
  *(float *)(a3 + 8) = a2 * *(float *)(a1 + 8);
  return result;
}

//----- (080E71F8) --------------------------------------------------------
int __cdecl sub_80E71F8(int a1, float a2, int a3, int a4)
{
  int result; // eax

  *(float *)a4 = a2 * *(float *)a3 + *(float *)a1;
  *(float *)(a4 + 4) = a2 * *(float *)(a3 + 4) + *(float *)(a1 + 4);
  result = a3 + 8;
  *(float *)(a4 + 8) = a2 * *(float *)(a3 + 8) + *(float *)(a1 + 8);
  return result;
}

//----- (080E724C) --------------------------------------------------------
long double __cdecl sub_80E724C(float *a1, float *a2)
{
  return *a1 * *a2 + a1[1] * a2[1] + a1[2] * a2[2];
}

//----- (080E7280) --------------------------------------------------------
long double __cdecl sub_80E7280(float *a1)
{
  return *a1 * *a1 + a1[1] * a1[1] + a1[2] * a1[2];
}

//----- (080E72B4) --------------------------------------------------------
void __cdecl sub_80E72B4(float *a1)
{
  float v1; // ST00_4

  v1 = *a1 * *a1 + a1[1] * a1[1] + a1[2] * a1[2];
  sub_80E6E5C(v1);
}

//----- (080E72F2) --------------------------------------------------------
long double __cdecl sub_80E72F2(float a1, float a2, float a3)
{
  float v4; // [esp+0h] [ebp-4h]

  if ( a1 < 0.0 )
    v4 = a3;
  else
    v4 = a2;
  return v4;
}

//----- (080E731C) --------------------------------------------------------
int __cdecl sub_80E731C(int a1, int a2, int a3)
{
  int v4; // [esp+0h] [ebp-4h]

  if ( a1 < 0 )
    v4 = a3;
  else
    v4 = a2;
  return v4;
}

//----- (080E733C) --------------------------------------------------------
unsigned int __cdecl sub_80E733C(unsigned int a1)
{
  return a1 >> 31;
}

//----- (080E7348) --------------------------------------------------------
signed int __cdecl sub_80E7348(unsigned __int8 *a1, _DWORD *a2, _DWORD *a3)
{
  int v5; // [esp+40h] [ebp-8h]
  int v6; // [esp+44h] [ebp-4h]

  v6 = *(_DWORD *)a1;
  if ( !(*(_BYTE *)(*(_DWORD *)a1 + 12) & 1) )
    return 1;
  v5 = sub_80DE734(
         *(_DWORD *)(v6 + 204),
         v6 + 20,
         *(_DWORD *)(v6 + 1400),
         1106247680,
         *(float *)(v6 + 1412),
         v6 + 1448,
         v6 + 1452,
         v6 + 1456,
         1,
         1,
         0,
         a1[228],
         0,
         66.0);
  if ( !v5 )
  {
    sub_80E87AA(a2, (_DWORD *)(v6 + 20));
    sub_80E87AA(a3, (_DWORD *)(v6 + 32));
  }
  return v5;
}

//----- (080E7448) --------------------------------------------------------
long double __cdecl sub_80E7448(float *a1, int a2, int a3, _DWORD *a4)
{
  int v4; // ebx
  int j; // [esp+2Ch] [ebp-3Ch]
  float v7[11]; // [esp+30h] [ebp-38h]
  int i; // [esp+5Ch] [ebp-Ch]

  for ( i = 0; i < a2; ++i )
  {
    v4 = i;
    v7[v4] = sub_80E88AA(a1, (float *)(a3 + 12 * i));
    for ( j = i; j && v7[i] <= (long double)v7[a4[j - 1]]; --j )
      a4[j] = a4[j - 1];
    a4[j] = i;
  }
  return v7[*a4];
}
// 80E7448: using guessed type float var_38[11];

//----- (080E750E) --------------------------------------------------------
_BOOL4 __cdecl sub_80E750E(int *a1, int a2, int a3)
{
  int v5; // [esp+3Ch] [ebp-15Ch]
  int v6; // [esp+40h] [ebp-158h]
  float v7[2]; // [esp+50h] [ebp-148h]
  float v8; // [esp+58h] [ebp-140h]
  float v9; // [esp+68h] [ebp-130h]
  float v10; // [esp+6Ch] [ebp-12Ch]
  int v11; // [esp+70h] [ebp-128h]
  float v12; // [esp+80h] [ebp-118h]
  int v13; // [esp+84h] [ebp-114h]
  unsigned __int16 v14; // [esp+9Ch] [ebp-FCh]
  char v15; // [esp+A2h] [ebp-F6h]
  int l; // [esp+B4h] [ebp-E4h]
  int k; // [esp+B8h] [ebp-E0h]
  int j; // [esp+BCh] [ebp-DCh]
  int v19; // [esp+C0h] [ebp-D8h]
  char v20; // [esp+D0h] [ebp-C8h]
  float v21; // [esp+D8h] [ebp-C0h]
  int v22[8]; // [esp+E0h] [ebp-B8h]
  char v23[104]; // [esp+100h] [ebp-98h]
  int v24; // [esp+168h] [ebp-30h]
  float v25; // [esp+16Ch] [ebp-2Ch]
  int v26; // [esp+170h] [ebp-28h]
  int v27; // [esp+188h] [ebp-10h]
  int i; // [esp+18Ch] [ebp-Ch]

  v5 = *a1;
  v27 = 4;
  sub_80E87AA((_DWORD *)(v5 + 32), &v20);
  sub_80E87AA((_DWORD *)(v5 + 32), v7);
  if ( a3 )
  {
    v8 = v8 - (long double)*(signed int *)(v5 + 72) * *(float *)(a2 + 36);
    *(float *)(v5 + 40) = (*(float *)(v5 + 40) + v8) * 0.5;
    v21 = v8;
    if ( *(_DWORD *)(a2 + 48) )
      sub_80DEDB0((float *)(v5 + 32), (float *)(a2 + 60), v5 + 32);
  }
  v10 = *(float *)(a2 + 36);
  if ( *(_DWORD *)(a2 + 48) )
  {
    sub_80E87AA((_DWORD *)(a2 + 60), v23);
    v24 = 1;
  }
  else
  {
    v24 = 0;
  }
  sub_80A2298((float *)(v5 + 32), (int)&v23[12 * v24++]);
  for ( i = 0; i < v27; ++i )
  {
    sub_80E8856(v5 + 20, v10, v5 + 32, (int)&v11);
    sub_80DEC3C((int)a1, (int)&v12, v5 + 20, (int)(a1 + 49), (int)(a1 + 52), (int)&v11, *(_DWORD *)(v5 + 204), a1[15]);
    if ( v15 )
    {
      *(_DWORD *)(v5 + 40) = 0;
      return 1;
    }
    if ( v12 > 0.0 )
      sub_80DEB7A(v5 + 20, (int)&v11, v12, v5 + 20);
    if ( v12 == 1.0 )
      break;
    sub_80DED50((int)a1, v14);
    v10 = v10 - v10 * v12;
    if ( v24 > 7 )
    {
      sub_80E875C((_DWORD *)(v5 + 32));
      return 1;
    }
    for ( j = 0; j < v24; ++j )
    {
      if ( sub_80E88AA((float *)&v13, (float *)&v23[12 * j]) > 0.99900001 )
      {
        sub_80DEDB0((float *)(v5 + 32), (float *)&v13, v5 + 32);
        sub_80E87DA((float *)&v13, (float *)(v5 + 32), (float *)(v5 + 32));
        break;
      }
    }
    if ( j >= v24 )
    {
      sub_80E87AA(&v13, &v23[12 * v24++]);
      v9 = sub_80E7448((float *)(v5 + 32), v24, (int)v23, v22);
      if ( v9 < 0.1 )
      {
        if ( -v9 > (long double)*(float *)(a2 + 92) )
          *(_DWORD *)(a2 + 92) = LODWORD(v9) ^ 0x80000000;
        sub_80DEDB0((float *)(v5 + 32), (float *)&v23[12 * v22[0]], (int)&v19);
        sub_80DEDB0(v7, (float *)&v23[12 * v22[0]], (int)&v6);
        for ( k = 1; k < v24; ++k )
        {
          if ( sub_80E88AA((float *)&v19, (float *)&v23[12 * v22[k]]) < 0.1 )
          {
            sub_80DEDB0((float *)&v19, (float *)&v23[12 * v22[k]], (int)&v19);
            sub_80DEDB0((float *)&v6, (float *)&v23[12 * v22[k]], (int)&v6);
            if ( sub_80E88AA((float *)&v19, (float *)&v23[12 * v22[0]]) < 0.0 )
            {
              sub_80A1ED8((float *)&v23[12 * v22[0]], (float *)&v23[12 * v22[k]], (float *)&v26);
              sub_80A20C0((float *)&v26);
              v25 = sub_80E88AA((float *)&v26, (float *)(v5 + 32));
              sub_80E881E((int)&v26, v25, (int)&v19);
              v25 = sub_80E88AA((float *)&v26, v7);
              sub_80E881E((int)&v26, v25, (int)&v6);
              for ( l = 1; l < v24; ++l )
              {
                if ( l != k && sub_80E88AA((float *)&v19, (float *)&v23[12 * v22[l]]) < 0.1 )
                {
                  sub_80E875C((_DWORD *)(v5 + 32));
                  return 1;
                }
              }
            }
          }
        }
        sub_80E87AA(&v19, (_DWORD *)(v5 + 32));
        sub_80E87AA(&v6, v7);
      }
    }
  }
  if ( a3 )
    sub_80E87AA(v7, (_DWORD *)(v5 + 32));
  if ( *(_DWORD *)(v5 + 16) )
    sub_80E87AA(&v20, (_DWORD *)(v5 + 32));
  return i != 0;
}
// 80E750E: using guessed type char var_98[104];
// 80E750E: using guessed type int var_B8[8];

//----- (080E7CC0) --------------------------------------------------------
void __cdecl sub_80E7CC0(int *a1, int a2, int a3)
{
  int v3; // ST0C_4
  float v4; // ST34_4
  long double v5; // fst6
  float v6; // ST00_4
  float v7; // ST00_4
  int v8; // ST54_4
  float v9; // ST00_4
  float v10; // ST4C_4
  float v11; // ST48_4
  float v12; // ST40_4
  signed int v13; // ST44_4
  int v14; // [esp+2Ch] [ebp-10Ch]
  int v15; // [esp+30h] [ebp-108h]
  int v16; // [esp+54h] [ebp-E4h]
  int v17; // [esp+54h] [ebp-E4h]
  int v18; // [esp+54h] [ebp-E4h]
  int v19; // [esp+58h] [ebp-E0h]
  signed int v20; // [esp+5Ch] [ebp-DCh]
  int v21; // [esp+60h] [ebp-D8h]
  float v22; // [esp+68h] [ebp-D0h]
  int v23; // [esp+7Ch] [ebp-BCh]
  float v24; // [esp+80h] [ebp-B8h]
  _BOOL4 v25; // [esp+84h] [ebp-B4h]
  float v26; // [esp+88h] [ebp-B0h]
  _BOOL4 v27; // [esp+8Ch] [ebp-ACh]
  char v28; // [esp+90h] [ebp-A8h]
  char v29; // [esp+98h] [ebp-A0h]
  int v30; // [esp+A0h] [ebp-98h]
  float v31; // [esp+A8h] [ebp-90h]
  int v32; // [esp+B0h] [ebp-88h]
  int v33; // [esp+B4h] [ebp-84h]
  float v34; // [esp+B8h] [ebp-80h]
  float v35; // [esp+C0h] [ebp-78h]
  int v36; // [esp+C4h] [ebp-74h]
  float v37; // [esp+CCh] [ebp-6Ch]
  unsigned __int16 v38; // [esp+DCh] [ebp-5Ch]
  char v39; // [esp+F0h] [ebp-48h]
  float v40[2]; // [esp+100h] [ebp-38h]
  float v41; // [esp+108h] [ebp-30h]
  char v42; // [esp+110h] [ebp-28h]
  float v43[2]; // [esp+120h] [ebp-18h]
  float v44; // [esp+128h] [ebp-10h]

  v24 = 0.0;
  v19 = *a1;
  v20 = 0;
  if ( *(_DWORD *)(*a1 + 12) & 0x20 )
  {
    v23 = 0;
    sub_80D9FF4(v19);
  }
  else if ( *(_DWORD *)(a2 + 48) )
  {
    v23 = 1;
  }
  else
  {
    v23 = 0;
    if ( *(_DWORD *)(v19 + 12) & 0x80000 && *(_DWORD *)(v19 + 16) )
      sub_80D9FF4(v19);
  }
  sub_80E87AA((_DWORD *)(v19 + 20), v43);
  sub_80E87AA((_DWORD *)(v19 + 32), &v42);
  v25 = sub_80E750E(a1, a2, a3);
  if ( *(_BYTE *)(v19 + 12) & 1 )
    v26 = 10.0;
  else
    v26 = 18.0;
  if ( *(_DWORD *)(v19 + 96) != 1023 )
    goto LABEL_68;
  if ( *(_DWORD *)(v19 + 12) & 0x80000 && *(_DWORD *)(v19 + 16) )
    sub_80D9FF4(v19);
  if ( v25 && *(_DWORD *)(v19 + 12) & 0x80000 && (unsigned __int8)sub_80DA016(v19, (int)v43, &v26) )
  {
    if ( v26 < 1.0 )
      return;
    v20 = 1;
  }
  if ( v20 || *(_DWORD *)(v19 + 12) & 0x20 && *(float *)(v19 + 40) > 0.0 )
  {
LABEL_68:
    sub_80E87AA((_DWORD *)(v19 + 20), v40);
    sub_80E87AA((_DWORD *)(v19 + 32), &v39);
    sub_80E870E(v40, v43, (float *)&v29);
    if ( v25 )
    {
      sub_80E87AA(v43, &v32);
      v34 = v26 + 1.0 + v34;
      sub_80DEC3C(
        (int)a1,
        (int)&v35,
        (int)v43,
        (int)(a1 + 49),
        (int)(a1 + 52),
        (int)&v32,
        *(_DWORD *)(v19 + 204),
        a1[15]);
      v24 = (v26 + 1.0) * v35 - 1.0;
      if ( v24 >= 1.0 )
      {
        *(float *)&v3 = v44 + v24;
        sub_80E8786((_DWORD *)(v19 + 20), v32, v33, v3);
        sub_80E87AA(&v42, (_DWORD *)(v19 + 32));
        sub_80E750E(a1, a2, a3);
      }
      else
      {
        v24 = 0.0;
      }
    }
    if ( v23 || v24 != 0.0 )
    {
      sub_80E87AA((_DWORD *)(v19 + 20), &v30);
      v31 = v31 - v24;
      if ( v23 )
        v31 = v31 - 9.0;
      sub_80DEC3C(
        (int)a1,
        (int)&v35,
        v19 + 20,
        (int)(a1 + 49),
        (int)(a1 + 52),
        (int)&v30,
        *(_DWORD *)(v19 + 204),
        a1[15]);
      if ( v38 <= 0x3Fu )
      {
        sub_80E87AA(v40, (_DWORD *)(v19 + 20));
        sub_80E87AA(&v39, (_DWORD *)(v19 + 32));
        return;
      }
      if ( v35 >= 1.0 )
      {
        if ( v24 != 0.0 )
          *(float *)(v19 + 28) = *(float *)(v19 + 28) - v24;
      }
      else
      {
        if ( v37 < 0.30000001 )
        {
          sub_80E87AA(v40, (_DWORD *)(v19 + 20));
          sub_80E87AA(&v39, (_DWORD *)(v19 + 32));
          return;
        }
        sub_80DEB7A(v19 + 20, (int)&v30, v35, v19 + 20);
        sub_80DEDB0((float *)(v19 + 32), (float *)&v36, v19 + 32);
      }
    }
    sub_80E870E((float *)(v19 + 20), v43, (float *)&v28);
    v4 = sub_80E873A((float *)&v28, (float *)(v19 + 32));
    v5 = sub_80E873A((float *)&v29, (float *)(v19 + 32)) + 0.001;
    v27 = v5 >= v4;
    if ( v5 >= v4 || v20 && (unsigned __int8)sub_80DA0A4(v19) )
    {
      sub_80E87AA(v40, (_DWORD *)(v19 + 20));
      sub_80E87AA(&v39, (_DWORD *)(v19 + 32));
      v24 = 0.0;
      if ( v23 )
      {
        sub_80E87AA((_DWORD *)(v19 + 20), &v30);
        v31 = v31 - 9.0;
        sub_80DEC3C(
          (int)a1,
          (int)&v35,
          v19 + 20,
          (int)(a1 + 49),
          (int)(a1 + 52),
          (int)&v30,
          *(_DWORD *)(v19 + 204),
          a1[15]);
        if ( v35 < 1.0 )
        {
          sub_80DEB7A(v19 + 20, (int)&v30, v35, (int)&v21);
          v24 = v22 - *(float *)(v19 + 28);
          sub_80E87AA(&v21, (_DWORD *)(v19 + 20));
          sub_80DEDB0((float *)(v19 + 32), (float *)&v36, v19 + 32);
        }
      }
    }
    if ( v20 )
      sub_80DA238(v19, (int)v40);
    if ( v23 )
    {
      if ( *(_DWORD *)(v19 + 4) <= 5 )
      {
        if ( sub_80E7348((unsigned __int8 *)a1, v43, &v42) )
        {
          v6 = *(float *)(v19 + 28) - v41;
          if ( sub_80E86BE(v6) > 0.5 )
          {
            v7 = *(float *)(v19 + 28) - v41;
            v16 = sub_80E86D8(v7);
            if ( v16 )
            {
              if ( v16 >= -16 )
              {
                if ( v16 > 24 )
                  v16 = 24;
              }
              else
              {
                v16 = -16;
              }
              v8 = v16 + 128;
              sub_80DD554(143, v8, v19);
              v9 = *(float *)(v19 + 28) - v44;
              v10 = sub_80E86BE(v9);
              v11 = (1.0 - v10 / v26) * 0.80000001 + 0.19999999;
              sub_80E881E(v19 + 32, v11, v19 + 32);
              v17 = v8 - 128;
              v15 = v17;
              if ( v17 < 0 )
                v15 = -v17;
              if ( v15 > 3 && *(_DWORD *)(v19 + 96) != 1023 && sub_80E2EA6(a1) )
              {
                v14 = v17;
                if ( v17 < 0 )
                  v14 = -v17;
                v18 = v14 / 2;
                if ( v14 / 2 > 4 )
                  v18 = 4;
                v12 = (long double)v18 * 1.25 + 7.0;
                v13 = *(_DWORD *)(v19 + 8);
                *(_DWORD *)(v19 + 8) = (unsigned __int8)(signed int)((long double)v13 + v12);
                sub_80E2CDE((int)a1, a2, v13, *(_DWORD *)(v19 + 8), 1);
              }
            }
          }
        }
      }
    }
  }
}

//----- (080E86BE) --------------------------------------------------------
long double __cdecl sub_80E86BE(float a1)
{
  return (float)fabs(a1);
}

//----- (080E86D8) --------------------------------------------------------
int __cdecl sub_80E86D8(float a1)
{
  return (signed int)floor(a1 + 0.5);
}

//----- (080E870E) --------------------------------------------------------
int __cdecl sub_80E870E(float *a1, float *a2, float *a3)
{
  int result; // eax

  *a3 = *a1 - *a2;
  result = (int)(a1 + 1);
  a3[1] = a1[1] - a2[1];
  return result;
}

//----- (080E873A) --------------------------------------------------------
long double __cdecl sub_80E873A(float *a1, float *a2)
{
  return *a1 * *a2 + a1[1] * a2[1];
}

//----- (080E875C) --------------------------------------------------------
int __cdecl sub_80E875C(_DWORD *a1)
{
  int result; // eax

  *a1 = 0;
  a1[1] = 0;
  result = 0;
  a1[2] = 0;
  return result;
}

//----- (080E8786) --------------------------------------------------------
int __cdecl sub_80E8786(_DWORD *a1, int a2, int a3, int a4)
{
  int result; // eax

  *a1 = a2;
  a1[1] = a3;
  result = a4;
  a1[2] = a4;
  return result;
}

//----- (080E87AA) --------------------------------------------------------
int __cdecl sub_80E87AA(_DWORD *a1, _DWORD *a2)
{
  int result; // eax

  *a2 = *a1;
  a2[1] = a1[1];
  result = a1[2];
  a2[2] = result;
  return result;
}

//----- (080E87DA) --------------------------------------------------------
int __cdecl sub_80E87DA(float *a1, float *a2, float *a3)
{
  int result; // eax

  *a3 = *a1 + *a2;
  a3[1] = a1[1] + a2[1];
  result = (int)(a1 + 2);
  a3[2] = a1[2] + a2[2];
  return result;
}

//----- (080E881E) --------------------------------------------------------
int __cdecl sub_80E881E(int a1, float a2, int a3)
{
  int result; // eax

  *(float *)a3 = a2 * *(float *)a1;
  *(float *)(a3 + 4) = a2 * *(float *)(a1 + 4);
  result = a1 + 8;
  *(float *)(a3 + 8) = a2 * *(float *)(a1 + 8);
  return result;
}

//----- (080E8856) --------------------------------------------------------
int __cdecl sub_80E8856(int a1, float a2, int a3, int a4)
{
  int result; // eax

  *(float *)a4 = a2 * *(float *)a3 + *(float *)a1;
  *(float *)(a4 + 4) = a2 * *(float *)(a3 + 4) + *(float *)(a1 + 4);
  result = a3 + 8;
  *(float *)(a4 + 8) = a2 * *(float *)(a3 + 8) + *(float *)(a1 + 8);
  return result;
}

//----- (080E88AA) --------------------------------------------------------
long double __cdecl sub_80E88AA(float *a1, float *a2)
{
  return *a1 * *a2 + a1[1] * a2[1] + a1[2] * a2[2];
}

//----- (080E88E0) --------------------------------------------------------
void sub_80E88E0()
{
  dword_8576140 = 0;
}
// 8576140: using guessed type int dword_8576140;

//----- (080E88F0) --------------------------------------------------------
int __cdecl sub_80E88F0(int a1)
{
  _DWORD *v1; // eax
  _DWORD *v2; // ST10_4
  int result; // eax

  v1 = (_DWORD *)sub_80E9270(a1);
  v2 = (_DWORD *)((char *)&unk_8164C20 + 44 * a1);
  v2[1] = v1[38];
  v2[2] = v1[109];
  v2[3] = 0;
  v2[4] = v1[110];
  v2[5] = v1[1];
  v2[6] = v1[112];
  v2[7] = 1;
  v2[8] = a1;
  v2[9] = v1[114];
  result = v1[116];
  v2[10] = result;
  return result;
}

//----- (080E89A8) --------------------------------------------------------
int __cdecl sub_80E89A8(int a1)
{
  int result; // eax
  char dest; // [esp+10h] [ebp-68h]
  char *j; // [esp+5Ch] [ebp-1Ch]
  int v4; // [esp+60h] [ebp-18h]
  int v5; // [esp+64h] [ebp-14h]
  int v6; // [esp+68h] [ebp-10h]
  int i; // [esp+6Ch] [ebp-Ch]

  for ( i = 129; ; ++i )
  {
    result = i;
    if ( i >= 131 )
      break;
    v4 = (int)&unk_8164C20 + 44 * i;
    if ( *(_DWORD *)(v4 + 28) == 2 )
    {
      I_strncpyz(&dest, *(char **)(v4 + 20), 64);
      for ( j = &dest; *j; ++j )
      {
        if ( *j == 32 )
        {
          *j = 0;
          break;
        }
      }
      v6 = sub_80E94F0(&dest, a1);
      if ( v6 )
      {
        v5 = sub_80E9270(v6);
        *(_DWORD *)(v4 + 32) = v6;
        *(_DWORD *)(v4 + 36) = *(_DWORD *)(v5 + 456);
        result = *(_DWORD *)(v5 + 464);
        *(_DWORD *)(v4 + 40) = result;
        return result;
      }
      Com_Printf("^3WARNING^7: Could not find weapon for ammo item %s\n", *(_DWORD *)(v4 + 20));
      v6 = sub_80E94F0("defaultweapon_mp", a1);
      if ( !v6 )
        Com_Error(1, &byte_814E260);
      v5 = sub_80E9270(v6);
      *(_DWORD *)(v4 + 32) = 1;
      *(_DWORD *)(v4 + 36) = *(_DWORD *)(v5 + 456);
      *(_DWORD *)(v4 + 40) = *(_DWORD *)(v5 + 464);
    }
  }
  return result;
}

//----- (080E8B16) --------------------------------------------------------
int __cdecl sub_80E8B16(int a1)
{
  int result; // eax
  int v2; // [esp+28h] [ebp-10h]
  signed int j; // [esp+2Ch] [ebp-Ch]
  int i; // [esp+30h] [ebp-8h]
  int v5; // [esp+34h] [ebp-4h]

  v5 = sub_80E9270(a1);
  for ( i = 0; ; ++i )
  {
    if ( i >= dword_8576560 )
    {
      dword_8576360[i] = v5;
      result = i;
      *(_DWORD *)(v5 + 456) = i;
      ++dword_8576560;
      return result;
    }
    if ( !strcmp(*(const char **)(dword_8576360[i] + 452), *(const char **)(v5 + 452)) )
      break;
  }
  *(_DWORD *)(v5 + 456) = i;
  result = *(_DWORD *)(dword_8576360[i] + 468);
  if ( result != *(_DWORD *)(v5 + 468) && i )
  {
    for ( j = 1; ; ++j )
    {
      result = j;
      if ( j >= a1 )
        break;
      v2 = dword_8576160[j];
      if ( !I_stricmp(*(char **)(dword_8576360[i] + 452), *(char **)(v2 + 452))
        && *(_DWORD *)(v2 + 468) == *(_DWORD *)(dword_8576360[i] + 468) )
      {
        Com_Error(
          1,
          &byte_814E2C0,
          *(_DWORD *)(v5 + 452),
          *(_DWORD *)v5,
          *(_DWORD *)(v5 + 468),
          *(_DWORD *)v2,
          *(_DWORD *)(v2 + 468));
      }
    }
  }
  return result;
}
// 8576560: using guessed type int dword_8576560;

//----- (080E8C8C) --------------------------------------------------------
_BYTE *__cdecl sub_80E8C8C(int a1)
{
  int v1; // eax
  _BYTE *result; // eax
  int v3; // [esp+28h] [ebp-10h]
  signed int j; // [esp+2Ch] [ebp-Ch]
  _DWORD *v5; // [esp+30h] [ebp-8h]
  int i; // [esp+34h] [ebp-4h]

  v1 = sub_80E9270(a1);
  v5 = (_DWORD *)v1;
  *(_DWORD *)(v1 + 484) = -1;
  result = *(_BYTE **)(v1 + 480);
  if ( *result )
  {
    Com_DPrintf("%s: %s\n", *v5, v5[120]);
    for ( i = 0; ; ++i )
    {
      if ( i >= dword_8576780 )
      {
        dword_8576580[i] = (int)v5;
        result = (_BYTE *)i;
        v5[121] = i;
        ++dword_8576780;
        return result;
      }
      if ( !I_stricmp(*(char **)(dword_8576580[i] + 480), (char *)v5[120]) )
        break;
    }
    v5[121] = i;
    result = *(_BYTE **)(dword_8576580[i] + 488);
    if ( result != (_BYTE *)v5[122] && i )
    {
      for ( j = 1; ; ++j )
      {
        result = (_BYTE *)j;
        if ( j >= a1 )
          break;
        v3 = dword_8576160[j];
        if ( !I_stricmp(*(char **)(dword_8576580[i] + 480), *(char **)(v3 + 480))
          && *(_DWORD *)(v3 + 488) == *(_DWORD *)(dword_8576580[i] + 488) )
        {
          Com_Error(1, &byte_814E320, v5[120], *v5, v5[122], *(_DWORD *)v3, *(_DWORD *)(v3 + 488));
        }
      }
    }
  }
  return result;
}
// 8576780: using guessed type int dword_8576780;

//----- (080E8E44) --------------------------------------------------------
int __cdecl sub_80E8E44(int a1)
{
  int result; // eax
  int v2; // [esp+28h] [ebp-10h]
  signed int j; // [esp+2Ch] [ebp-Ch]
  int v4; // [esp+30h] [ebp-8h]
  int i; // [esp+34h] [ebp-4h]

  v4 = sub_80E9270(a1);
  for ( i = 0; ; ++i )
  {
    if ( i >= dword_85769A0 )
    {
      dword_85767A0[i] = v4;
      result = i;
      *(_DWORD *)(v4 + 464) = i;
      ++dword_85769A0;
      return result;
    }
    if ( !strcmp(*(const char **)(dword_85767A0[i] + 460), *(const char **)(v4 + 460)) )
      break;
  }
  *(_DWORD *)(v4 + 464) = i;
  result = *(_DWORD *)(dword_85767A0[i] + 472);
  if ( result != *(_DWORD *)(v4 + 472) && i )
  {
    for ( j = 1; ; ++j )
    {
      result = j;
      if ( j >= a1 )
        break;
      v2 = dword_8576160[j];
      if ( !I_stricmp(*(char **)(dword_85767A0[i] + 460), *(char **)(v2 + 460))
        && *(_DWORD *)(v2 + 472) == *(_DWORD *)(dword_85767A0[i] + 472) )
      {
        Com_Error(
          1,
          &byte_814E3A0,
          *(_DWORD *)(v4 + 452),
          *(_DWORD *)v4,
          *(_DWORD *)(v4 + 472),
          *(_DWORD *)v2,
          *(_DWORD *)(v2 + 472));
      }
    }
  }
  return result;
}
// 85769A0: using guessed type int dword_85769A0;

//----- (080E8FBA) --------------------------------------------------------
_BYTE *__cdecl sub_80E8FBA(int a1, int a2)
{
  int v2; // eax
  _BYTE *result; // eax
  _DWORD *v4; // [esp+1Ch] [ebp-Ch]
  _DWORD *v5; // [esp+20h] [ebp-8h]
  int v6; // [esp+24h] [ebp-4h]

  v2 = sub_80E9270(a1);
  v5 = (_DWORD *)v2;
  *(_DWORD *)(v2 + 876) = 0;
  result = *(_BYTE **)(v2 + 872);
  if ( *result )
  {
    v6 = sub_80E94F0((char *)v5[218], a2);
    if ( !v6 )
      Com_Error(1, &byte_814E400, v5[218], *v5);
    v5[219] = v6;
    v4 = (_DWORD *)dword_8576160[v6];
    if ( v5[32] != v4[32] )
      Com_Error(1, &byte_814E440, *v5, *v4);
    result = (_BYTE *)v5[34];
    if ( result != (_BYTE *)v4[34] )
      Com_Error(1, &byte_814E4A0, *v5, *v4);
  }
  return result;
}

//----- (080E90C8) --------------------------------------------------------
int sub_80E90C8()
{
  signed int i; // [esp+4h] [ebp-4h]

  dword_8576160[0] = (int)sub_80F0F9E();
  dword_8576360[0] = dword_8576160[0];
  dword_8576560 = 1;
  dword_8576580[0] = dword_8576160[0];
  dword_8576780 = 1;
  dword_85767A0[0] = dword_8576160[0];
  dword_85769A0 = 1;
  for ( i = 1; i <= 128; ++i )
    dword_8164C3C[11 * i] = 0;
  sub_80F04EA();
  return sub_80D4A08();
}
// 8576560: using guessed type int dword_8576560;
// 8576780: using guessed type int dword_8576780;
// 85769A0: using guessed type int dword_85769A0;

//----- (080E9154) --------------------------------------------------------
int __cdecl sub_80E9154(int a1)
{
  sub_80E8B16(a1);
  sub_80E8C8C(a1);
  sub_80E8E44(a1);
  return sub_80E88F0(a1);
}

//----- (080E9188) --------------------------------------------------------
int __cdecl sub_80E9188(int a1, void (__cdecl *a2)(int))
{
  int v3; // [esp+14h] [ebp-4h]

  v3 = ++dword_8576140;
  dword_8576160[dword_8576140] = a1;
  sub_80E9154(v3);
  sub_80E8FBA(v3, (int)a2);
  if ( a2 )
    a2(v3);
  return v3;
}
// 8576140: using guessed type int dword_8576140;

//----- (080E91DC) --------------------------------------------------------
int sub_80E91DC()
{
  int result; // eax
  int v1; // [esp+10h] [ebp-8h]
  int i; // [esp+14h] [ebp-4h]

  v1 = sub_80E9322();
  for ( i = 1; ; ++i )
  {
    result = i;
    if ( i > v1 )
      break;
    sub_80E9154(i);
  }
  return result;
}

//----- (080E9210) --------------------------------------------------------
int __cdecl sub_80E9210(int a1, int a2)
{
  int result; // eax

  result = a1;
  if ( *(_DWORD *)(a1 + 4) <= 5 )
  {
    result = a2 | *(_DWORD *)(a1 + 1488) & 0x200 ^ 0x200;
    *(_DWORD *)(a1 + 1488) = result;
  }
  return result;
}

//----- (080E9240) --------------------------------------------------------
unsigned int __cdecl sub_80E9240(int a1, int a2)
{
  unsigned int result; // eax

  result = *(_DWORD *)(a1 + 1488) & 0xFFFFFDFF;
  if ( result != a2 )
    result = sub_80E9210(a1, a2);
  return result;
}

//----- (080E9270) --------------------------------------------------------
int __cdecl sub_80E9270(int a1)
{
  return dword_8576160[a1];
}

//----- (080E9280) --------------------------------------------------------
int *__cdecl sub_80E9280(int a1)
{
  int *result; // eax
  int v2; // [esp+Ch] [ebp-Ch]
  int i; // [esp+10h] [ebp-8h]

  v2 = sub_80E958C("defaultweapon_mp");
  if ( !v2 )
    Com_Error(1, &byte_814E500);
  *(_DWORD *)(dword_8576160[a1] + 12) = *(_DWORD *)(dword_8576160[v2] + 12);
  result = *(int **)(dword_8576160[v2] + 16);
  *(_DWORD *)(dword_8576160[a1] + 16) = result;
  for ( i = 0; i <= 22; ++i )
  {
    *(_DWORD *)(dword_8576160[a1] + 4 * i + 20) = *(_DWORD *)(dword_8576160[v2] + 4 * i + 20);
    result = &i;
  }
  return result;
}

//----- (080E9322) --------------------------------------------------------
int sub_80E9322()
{
  return dword_8576140;
}
// 8576140: using guessed type int dword_8576140;

//----- (080E9336) --------------------------------------------------------
int __cdecl sub_80E9336(int a1)
{
  return *(_DWORD *)(dword_8576360[a1] + 468);
}

//----- (080E9356) --------------------------------------------------------
int __cdecl sub_80E9356(int a1)
{
  return *(_DWORD *)(dword_85767A0[a1] + 472);
}

//----- (080E936C) --------------------------------------------------------
int __cdecl sub_80E936C(int a1)
{
  return *(_DWORD *)(dword_8576580[a1] + 488);
}

//----- (080E93C4) --------------------------------------------------------
int __cdecl sub_80E93C4(char *a1)
{
  int i; // [esp+14h] [ebp-4h]

  for ( i = 0; i < dword_8576560; ++i )
  {
    if ( !I_stricmp(*(char **)(dword_8576360[i] + 452), a1) )
      return i;
  }
  Com_DPrintf("Couldn't find ammo type \"%s\"\n", a1);
  return 0;
}
// 8576560: using guessed type int dword_8576560;

//----- (080E9430) --------------------------------------------------------
int __cdecl sub_80E9430(char *a1)
{
  int i; // [esp+14h] [ebp-4h]

  for ( i = 0; i < dword_85769A0; ++i )
  {
    if ( !I_stricmp(*(char **)(dword_85767A0[i] + 460), a1) )
      return i;
  }
  Com_DPrintf("Couldn't find ammo clip \"%s\"\n", a1);
  return 0;
}
// 85769A0: using guessed type int dword_85769A0;

//----- (080E949C) --------------------------------------------------------
signed int __cdecl sub_80E949C(char *a1)
{
  signed int i; // [esp+14h] [ebp-4h]

  for ( i = 1; i <= dword_8576140; ++i )
  {
    if ( !I_stricmp(a1, *(char **)dword_8576160[i]) )
      return i;
  }
  return 0;
}
// 8576140: using guessed type int dword_8576140;

//----- (080E94F0) --------------------------------------------------------
int __cdecl sub_80E94F0(char *s1, int a2)
{
  int v4; // [esp+10h] [ebp-8h]
  signed int v5; // [esp+14h] [ebp-4h]

  if ( !*s1 || !strcasecmp(s1, "none") )
    return 0;
  v5 = sub_80E949C(s1);
  if ( v5 )
    return v5;
  v4 = sub_80F0110((int)"mp", s1);
  if ( v4 )
    return sub_80E9188(v4, (void (__cdecl *)(int))a2);
  Com_DPrintf("Couldn't find weapon \"%s\"\n", s1);
  return 0;
}

//----- (080E958C) --------------------------------------------------------
int __cdecl sub_80E958C(char *s1)
{
  return sub_80E94F0(s1, 0);
}

//----- (080E95A8) --------------------------------------------------------
int sub_80E95A8()
{
  signed int i; // [esp+4h] [ebp-4h]

  for ( i = 1; i <= dword_8576140; ++i )
  {
    if ( *(_DWORD *)(dword_8576160[i] + 120) == 3 )
      return (unsigned __int8)i;
  }
  return 0;
}
// 8576140: using guessed type int dword_8576140;

//----- (080E95EE) --------------------------------------------------------
int __cdecl sub_80E95EE(_DWORD *a1)
{
  if ( a1[3] & 0x20000 )
    return sub_80E95A8();
  if ( a1[3] & 0x10 )
    return a1[52];
  return a1[53];
}

//----- (080E963A) --------------------------------------------------------
int __cdecl sub_80E963A(int a1, int a2)
{
  int v4; // [esp+Ch] [ebp-Ch]
  int i; // [esp+10h] [ebp-8h]

  v4 = sub_80E9322();
  for ( i = 1; i <= v4; ++i )
  {
    if ( *(_DWORD *)(sub_80E9270(i) + 132) == a2 && (unsigned __int8)sub_80D9E84(a1 + 1348, i) && sub_80EACC8(a1, i) )
      return i;
  }
  return 0;
}

//----- (080E973E) --------------------------------------------------------
int __cdecl sub_80E973E(int a1)
{
  return *(_DWORD *)(sub_80E9270(a1) + 812);
}

//----- (080E9758) --------------------------------------------------------
signed int __cdecl sub_80E9758(int a1)
{
  signed int v2; // [esp+4h] [ebp-4h]

  v2 = 0;
  if ( a1 >= 0 && a1 <= sub_80E9322() )
    v2 = 1;
  return v2;
}

//----- (080E9782) --------------------------------------------------------
signed int __cdecl sub_80E9782(int a1)
{
  signed int v2; // [esp+10h] [ebp-8h]
  _DWORD *v3; // [esp+14h] [ebp-4h]

  v3 = (_DWORD *)(sub_80E9270(a1) + 128);
  v2 = 0;
  if ( *v3 == 1 || *v3 == 2 )
    v2 = 1;
  return v2;
}

//----- (080E97BE) --------------------------------------------------------
signed int __cdecl sub_80E97BE(int a1)
{
  signed int v2; // [esp+0h] [ebp-4h]

  v2 = 0;
  if ( !*(_BYTE *)(a1 + 1365) || !*(_BYTE *)(a1 + 1366) )
    v2 = 1;
  return v2;
}

//----- (080E97F0) --------------------------------------------------------
int __cdecl sub_80E97F0(int a1, int a2)
{
  int v3; // [esp+Ch] [ebp-Ch]
  unsigned __int8 v4; // [esp+17h] [ebp-1h]

  v4 = 1;
  if ( !(unsigned __int8)sub_80E9758(a2) )
    v4 = 0;
  if ( !(unsigned __int8)sub_80D9E84(a1 + 1348, a2) )
    v4 = 0;
  v3 = sub_80E9270(a2);
  if ( !*(_DWORD *)(v3 + 132) && *(char *)(a1 + 1365) != a2 && *(char *)(a1 + 1366) != a2 && *(_DWORD *)(v3 + 876) != a2 )
    v4 = 0;
  return v4;
}

//----- (080E9882) --------------------------------------------------------
_BOOL4 __cdecl sub_80E9882(int a1)
{
  _BOOL4 v2; // [esp+10h] [ebp-8h]
  int v3; // [esp+14h] [ebp-4h]

  v3 = sub_80E9270(a1);
  if ( *(_DWORD *)(v3 + 124) == 9 )
    v2 = 0;
  else
    v2 = *(_DWORD *)(v3 + 132) == 0;
  return v2;
}

//----- (080E98CA) --------------------------------------------------------
signed int __cdecl sub_80E98CA(int a1, int a2)
{
  int v4; // [esp+18h] [ebp-10h]
  _DWORD *v5; // [esp+1Ch] [ebp-Ch]
  signed int v6; // [esp+20h] [ebp-8h]
  int i; // [esp+24h] [ebp-4h]
  int j; // [esp+24h] [ebp-4h]

  if ( !(unsigned __int8)sub_80D9E84(a1 + 1348, a2) )
    return 0;
  v5 = (_DWORD *)sub_80E9270(a2);
  v6 = sub_80E9B54(a1, a2, 1);
  if ( v6 )
  {
    if ( v5[34] )
    {
      for ( i = 1; i <= dword_8576140; ++i )
      {
        v4 = sub_80E9270(a2);
        if ( *(_DWORD *)(v4 + 136)
          && *(_DWORD *)(v4 + 128) == v5[32]
          && (unsigned __int8)sub_80D9E84(a1 + 1348, i)
          && !sub_80E9B54(a1, i, 1) )
        {
          *(_BYTE *)(v6 + a1 + 1364) = i;
          break;
        }
      }
      if ( i > dword_8576140 )
        *(_BYTE *)(v6 + a1 + 1364) = 0;
    }
    else
    {
      *(_BYTE *)(v6 + a1 + 1364) = 0;
    }
  }
  sub_80F0400(a1 + 1348, a2);
  for ( j = v5[219]; j && (unsigned __int8)sub_80D9E84(a1 + 1348, j); j = *(_DWORD *)(sub_80E9270(j) + 876) )
    sub_80F0400(a1 + 1348, j);
  if ( a2 == *(_DWORD *)(a1 + 212) )
    *(_DWORD *)(a1 + 212) = 0;
  return 1;
}
// 8576140: using guessed type int dword_8576140;

//----- (080E9A9E) --------------------------------------------------------
signed int __cdecl sub_80E9A9E(int a1, int a2, int a3)
{
  if ( !(unsigned __int8)sub_80D9E84(a1 + 1348, a3) )
    return 0;
  if ( (unsigned int)(*(_DWORD *)(sub_80E9270(a3) + 128) - 1) > 1 )
    return 0;
  if ( a2 != 1 && a2 != 2 )
    return 0;
  if ( a3 != *(char *)(a2 + a1 + 1364) && a3 != *(_DWORD *)(a1 + 212) )
    *(_DWORD *)(a1 + 212) = 0;
  *(_BYTE *)(a2 + a1 + 1364) = a3;
  return 1;
}

//----- (080E9B54) --------------------------------------------------------
signed int __cdecl sub_80E9B54(int a1, int a2, int a3)
{
  int v5; // [esp+10h] [ebp-8h]
  int v6; // [esp+14h] [ebp-4h]

  if ( !(unsigned __int8)sub_80D9E84(a1 + 1348, a2) )
    return 0;
  v6 = a2;
  do
  {
    v5 = sub_80E9270(v6);
    if ( (unsigned int)(*(_DWORD *)(v5 + 128) - 1) > 1 )
      return 0;
    if ( *(char *)(a1 + 1365) == v6 )
      return 1;
    if ( *(char *)(a1 + 1366) == v6 )
      return 2;
    if ( a3 && *(_DWORD *)(v5 + 876) )
      v6 = *(_DWORD *)(v5 + 876);
  }
  while ( v6 != a2 );
  return 0;
}

//----- (080E9C10) --------------------------------------------------------
signed int __cdecl sub_80E9C10(int a1, int a2)
{
  if ( (unsigned int)(*(_DWORD *)(sub_80E9270(a2) + 128) - 1) > 1 )
    return 0;
  if ( *(_BYTE *)(a1 + 1365) )
  {
    if ( !*(_BYTE *)(a1 + 1366) )
      return 2;
    return 0;
  }
  return 1;
}

//----- (080E9C6A) --------------------------------------------------------
signed int __cdecl sub_80E9C6A(int a1, int a2, int a3)
{
  int v5; // [esp+14h] [ebp-4h]

  v5 = sub_80E9270(a2);
  if ( *(_DWORD *)(v5 + 136) )
  {
    if ( (unsigned int)(*(_DWORD *)(v5 + 128) - 1) <= 1 )
    {
      if ( a3 == 1 || a3 == 2 )
      {
        if ( !*(_BYTE *)(a3 + a1 + 1364) )
          return a3;
        if ( *(_DWORD *)(sub_80E9270(*(char *)(a3 + a1 + 1364)) + 136) )
          return a3;
      }
      if ( !*(_BYTE *)(a1 + 1365) )
        return 1;
      if ( *(_DWORD *)(sub_80E9270(*(char *)(a1 + 1365)) + 136) )
        return 1;
      if ( !*(_BYTE *)(a1 + 1366) )
        return 2;
      if ( *(_DWORD *)(sub_80E9270(*(char *)(a1 + 1366)) + 136) )
        return 2;
    }
    return 0;
  }
  return 0;
}

//----- (080E9DE0) --------------------------------------------------------
int __cdecl sub_80E9DE0(int a1, int a2)
{
  int v2; // eax
  int v3; // eax
  int v4; // eax
  int v5; // eax
  int v7[128]; // [esp+10h] [ebp-428h]
  int s[130]; // [esp+210h] [ebp-228h]
  int v9; // [esp+418h] [ebp-20h]
  int v10; // [esp+41Ch] [ebp-1Ch]
  int v11; // [esp+420h] [ebp-18h]
  int v12; // [esp+424h] [ebp-14h]
  int v13; // [esp+428h] [ebp-10h]
  int i; // [esp+42Ch] [ebp-Ch]

  memset(s, 0, 0x200u);
  memset(v7, 0, 0x200u);
  v13 = sub_80E9270(a2);
  v10 = sub_80EAC94(a2);
  v9 = sub_80EAC7A(a2);
  if ( *(_DWORD *)(v13 + 484) < 0 )
  {
    if ( sub_80EACAE(a2) )
    {
      v4 = sub_80E9356(v9);
      v11 = v4 - *(_DWORD *)(a1 + 4 * v9 + 836);
    }
    else
    {
      v5 = sub_80E9336(v10);
      v11 = v5 - *(_DWORD *)(a1 + 4 * v10 + 324);
    }
  }
  else
  {
    v11 = sub_80E936C(*(_DWORD *)(v13 + 484));
    for ( i = 1; i <= dword_8576140; ++i )
    {
      if ( (unsigned __int8)sub_80D9E84(a1 + 1348, i) )
      {
        v12 = sub_80E9270(i);
        if ( *(_DWORD *)(v12 + 484) == *(_DWORD *)(v13 + 484) )
        {
          if ( sub_80EACAE(i) )
          {
            if ( !v7[sub_80EAC7A(i)] )
            {
              v7[sub_80EAC7A(i)] = 1;
              v2 = sub_80EAC7A(i);
              v11 -= *(_DWORD *)(a1 + 4 * v2 + 836);
            }
          }
          else if ( !s[sub_80EAC94(i)] )
          {
            s[sub_80EAC94(i)] = 1;
            v3 = sub_80EAC94(i);
            v11 -= *(_DWORD *)(a1 + 4 * v3 + 324);
          }
        }
      }
    }
  }
  return v11;
}
// 8576140: using guessed type int dword_8576140;
// 80E9DE0: using guessed type int s[130];
// 80E9DE0: using guessed type int var_428[128];

//----- (080E9FD2) --------------------------------------------------------
int __cdecl sub_80E9FD2(int a1, int a2)
{
  int v2; // eax
  int v3; // eax
  int v5[128]; // [esp+10h] [ebp-428h]
  int s[130]; // [esp+210h] [ebp-228h]
  int v7; // [esp+418h] [ebp-20h]
  int v8; // [esp+41Ch] [ebp-1Ch]
  int v9; // [esp+420h] [ebp-18h]
  int v10; // [esp+424h] [ebp-14h]
  int v11; // [esp+428h] [ebp-10h]
  int i; // [esp+42Ch] [ebp-Ch]

  v9 = 0;
  v8 = sub_80EAC94(a2);
  v7 = sub_80EAC7A(a2);
  memset(s, 0, 0x200u);
  memset(v5, 0, 0x200u);
  v11 = sub_80E9270(a2);
  if ( *(_DWORD *)(v11 + 484) < 0 )
  {
    if ( sub_80EACAE(a2) )
      v9 = *(_DWORD *)(a1 + 4 * v7 + 836);
    else
      v9 = *(_DWORD *)(a1 + 4 * v8 + 324);
  }
  else
  {
    for ( i = 1; i <= dword_8576140; ++i )
    {
      if ( (unsigned __int8)sub_80D9E84(a1 + 1348, i) )
      {
        v10 = sub_80E9270(i);
        if ( *(_DWORD *)(v10 + 484) == *(_DWORD *)(v11 + 484) )
        {
          if ( sub_80EACAE(i) )
          {
            if ( !v5[sub_80EAC7A(i)] )
            {
              v5[sub_80EAC7A(i)] = 1;
              v2 = sub_80EAC7A(i);
              v9 += *(_DWORD *)(a1 + 4 * v2 + 836);
            }
          }
          else if ( !s[sub_80EAC94(i)] )
          {
            s[sub_80EAC94(i)] = 1;
            v3 = sub_80EAC94(i);
            v9 += *(_DWORD *)(a1 + 4 * v3 + 324);
          }
        }
      }
    }
  }
  return v9;
}
// 8576140: using guessed type int dword_8576140;
// 80E9FD2: using guessed type int s[130];
// 80E9FD2: using guessed type int var_428[128];

//----- (080EA198) --------------------------------------------------------
float *__cdecl sub_80EA198(int a1, int a2, float *a3, float *a4)
{
  float v4; // ST10_4
  float *result; // eax
  float v6; // ST10_4
  float *v7; // [esp+14h] [ebp-4h]

  v7 = (float *)sub_80E9270(a2);
  if ( *(float *)(a1 + 248) <= 40.0 )
  {
    v6 = (*(float *)(a1 + 248) - 11.0) / 29.0;
    *a3 = (v7[164] - v7[165]) * v6 + v7[165];
    result = v7;
    *a4 = (v7[167] - v7[168]) * v6 + v7[168];
  }
  else
  {
    v4 = (*(float *)(a1 + 248) - 40.0) / 20.0;
    *a3 = (v7[163] - v7[164]) * v4 + v7[164];
    result = v7;
    *a4 = (v7[166] - v7[167]) * v4 + v7[167];
  }
  return result;
}

//----- (080EA28E) --------------------------------------------------------
signed int __cdecl sub_80EA28E(int a1)
{
  signed int v2; // [esp+0h] [ebp-4h]

  v2 = 0;
  if ( a1 == 19 || a1 == 20 )
    v2 = 1;
  return v2;
}

//----- (080EA2B6) --------------------------------------------------------
_BOOL4 __cdecl sub_80EA2B6(_DWORD *a1, int a2)
{
  int v2; // ST10_4
  signed int v4; // [esp+8h] [ebp-10h]

  v4 = a1[1];
  if ( v4 == 1 )
  {
    if ( *(_DWORD *)(a2 + 52) )
      return 0;
  }
  else if ( v4 >= 1 && v4 <= 7 )
  {
    return 0;
  }
  v2 = sub_80E95EE(a1);
  if ( !*(_DWORD *)(sub_80E9270(v2) + 812) )
    return 0;
  if ( a1[54] > 11 && a1[54] <= 16 )
    return 0;
  if ( a1[54] == 10 || a1[54] == 11 )
    return 0;
  if ( a1[54] != 1 && a1[54] != 2 )
    return a1[54] <= 16 || a1[54] > 22 || (unsigned __int8)sub_80EA28E(a1[54]);
  return 0;
}

//----- (080EA3DA) --------------------------------------------------------
signed int __cdecl sub_80EA3DA(int a1)
{
  signed int v2; // [esp+0h] [ebp-4h]

  v2 = 0;
  if ( *(_DWORD *)(a1 + 216) == 19 || *(_DWORD *)(a1 + 216) == 20 )
    v2 = 1;
  return v2;
}

//----- (080EA40E) --------------------------------------------------------
int __cdecl sub_80EA40E(int a1, int a2)
{
  int result; // eax
  char v3; // [esp+1Fh] [ebp-9h]
  _DWORD *v4; // [esp+20h] [ebp-8h]
  bool v5; // [esp+27h] [ebp-1h]

  v4 = *(_DWORD **)a1;
  v4[3] &= 0xFFFFFFBF;
  v5 = sub_80EA2B6(v4, a2);
  v3 = 0;
  if ( *(_DWORD *)(a1 + 8) & 0x1000 || (unsigned __int8)sub_80EA3DA((int)v4) )
    v3 = 1;
  if ( v3 && v5 )
  {
    if ( v4[3] & 1 )
    {
      if ( !(*(_DWORD *)(a1 + 36) & 0x1000) || !*(_BYTE *)(a1 + 28) && !*(_BYTE *)(a1 + 29) )
      {
        v4[3] |= 0x40u;
        v4[3] |= 0x800u;
      }
    }
    else
    {
      v4[3] |= 0x40u;
    }
  }
  if ( v4[3] & 0x40 )
    result = sub_80D70E2(v4[51], 7, 1, 1);
  else
    result = sub_80D70E2(v4[51], 7, 0, 1);
  return result;
}

//----- (080EA53E) --------------------------------------------------------
unsigned int __cdecl sub_80EA53E(int a1)
{
  unsigned int result; // eax

  sub_80DED2E(a1, 149);
  result = *(_DWORD *)(a1 + 12) & 0xFFFFFFBF;
  *(_DWORD *)(a1 + 12) = result;
  return result;
}

//----- (080EA568) --------------------------------------------------------
void __cdecl sub_80EA568(float **a1, int a2)
{
  int v2; // ST1C_4
  long double v3; // fst7
  float *v4; // [esp+14h] [ebp-14h]
  char v5; // [esp+1Bh] [ebp-Dh]
  int v6; // [esp+20h] [ebp-8h]

  v4 = *a1;
  v2 = sub_80E95EE(*a1);
  v6 = sub_80E9270(v2);
  if ( *(_BYTE *)(dword_85760F0 + 8) && *((_DWORD *)v4 + 74) && *(_DWORD *)(v6 + 632) )
  {
    sub_80EA53E((int)v4);
    v4[55] = 0.0;
    v4[56] = 0.0;
  }
  else if ( *(_DWORD *)(v6 + 812) )
  {
    v5 = 0;
    if ( (*(_DWORD *)(v6 + 860) || *((_DWORD *)v4 + 54) != 5 || *((_DWORD *)v4 + 13) - *(_DWORD *)(v6 + 1316) <= 0)
      && (!*(_DWORD *)(v6 + 860)
       || *((_DWORD *)v4 + 54) != 5
       && *((_DWORD *)v4 + 54) != 6
       && *((_DWORD *)v4 + 54) != 7
       && *((_DWORD *)v4 + 54) != 8
       && (*((_DWORD *)v4 + 54) != 9 || *((_DWORD *)v4 + 13) - *(_DWORD *)(v6 + 1316) <= 0))
      && (*(_DWORD *)(v6 + 816) || *((_DWORD *)v4 + 54) != 4) )
    {
      if ( (_DWORD)v4[3] & 0x40 )
        v5 = 1;
    }
    else
    {
      v5 = 0;
    }
    if ( *(_DWORD *)(v6 + 840) && *((_DWORD *)v4 + 14) && *((_DWORD *)v4 + 54) == 3 )
      v5 = 1;
    if ( 1.0 != v4[55] || v5 || *(_DWORD *)(dword_85760F4 + 8) <= 0 )
    {
      v4[56] = 0.0;
    }
    else
    {
      if ( !*((_DWORD *)v4 + 56) )
        *((_DWORD *)v4 + 56) = (char *)a1[1] + *(_DWORD *)(dword_85760F4 + 8);
      if ( *((_DWORD *)v4 + 56) <= (signed int)a1[1] )
        v4[56] = 0.0;
      else
        v5 = 1;
    }
    if ( v5 && v4[55] != 1.0 || !v5 && v4[55] != 0.0 )
    {
      if ( v5 )
        v3 = (long double)*(signed int *)(a2 + 40) * *(float *)(v6 + 1416) + v4[55];
      else
        v3 = v4[55] - (long double)*(signed int *)(a2 + 40) * *(float *)(v6 + 1420);
      v4[55] = v3;
      v4[55] = sub_80F0220(v4[55], 0.0, 1.0);
    }
  }
  else
  {
    v4[55] = 0.0;
    v4[56] = 0.0;
  }
}
// 85760F0: using guessed type int dword_85760F0;
// 85760F4: using guessed type int dword_85760F4;

//----- (080EA838) --------------------------------------------------------
int __cdecl sub_80EA838(int a1)
{
  int result; // eax

  result = a1;
  *(_DWORD *)(a1 + 12) |= 0x4000u;
  return result;
}

//----- (080EA850) --------------------------------------------------------
int __cdecl sub_80EA850(int a1)
{
  int result; // eax

  result = a1;
  *(_DWORD *)(a1 + 12) &= 0xFFFFBFFF;
  return result;
}

//----- (080EA868) --------------------------------------------------------
void __cdecl sub_80EA868(int a1)
{
  int v1; // ST08_4
  int v2; // [esp+Ch] [ebp-Ch]
  signed int v3; // [esp+14h] [ebp-4h]

  v1 = sub_80E95EE((_DWORD *)a1);
  v2 = sub_80E9270(v1);
  if ( *(float *)(a1 + 220) == 1.0 && *(_DWORD *)(v2 + 632) && *(_DWORD *)(v2 + 124) != 9 )
  {
    v3 = (signed int)(*(float *)(dword_85760CC + 8) * 1000.0);
    if ( *(_DWORD *)(a1 + 1464) < v3 )
    {
      *(_DWORD *)(a1 + 1464) += (signed int)(*(float *)(dword_85760D4 + 8) * 1000.0);
      if ( *(_DWORD *)(a1 + 1464) > v3 )
        *(_DWORD *)(a1 + 1464) = v3;
    }
    sub_80EA850(a1);
  }
}
// 85760CC: using guessed type int dword_85760CC;
// 85760D4: using guessed type int dword_85760D4;

//----- (080EA950) --------------------------------------------------------
void __cdecl sub_80EA950(float **a1, int a2)
{
  int v2; // ST30_4
  int v3; // eax
  float v4; // ST28_4
  float v5; // ST2C_4
  float *v6; // [esp+18h] [ebp-20h]
  signed int v7; // [esp+1Ch] [ebp-1Ch]
  signed int v8; // [esp+20h] [ebp-18h]
  float v9; // [esp+24h] [ebp-14h]
  float v10; // [esp+28h] [ebp-10h]
  int v11; // [esp+30h] [ebp-8h]

  v6 = *a1;
  v2 = sub_80E95EE(*a1);
  v11 = sub_80E9270(v2);
  v8 = (signed int)(*(float *)(dword_85760CC + 8) * 1000.0);
  v7 = (signed int)(*(float *)(dword_85760D0 + 8) * 1000.0);
  if ( v8 > 0 )
  {
    if ( v6[55] == 1.0 && *(_DWORD *)(v11 + 632) && *(_DWORD *)(v11 + 124) != 9 )
    {
      if ( *((_WORD *)a1 + 4) < 0 )
      {
        if ( !*((_DWORD *)v6 + 366) )
          sub_80EA838((int)v6);
      }
      else
      {
        sub_80EA850((int)v6);
      }
    }
    else
    {
      sub_80EA850((int)v6);
    }
    if ( (_DWORD)v6[3] & 0x4000 )
      v3 = *((_DWORD *)v6 + 366) + *(_DWORD *)(a2 + 40);
    else
      v3 = *((_DWORD *)v6 + 366) - *(_DWORD *)(a2 + 40);
    *((_DWORD *)v6 + 366) = v3;
    if ( *((_DWORD *)v6 + 366) < 0 )
      v6[366] = 0.0;
    if ( (_DWORD)v6[3] & 0x4000 && *((_DWORD *)v6 + 366) > v8 )
    {
      *((_DWORD *)v6 + 366) = v8 + v7;
      sub_80EA850((int)v6);
    }
    if ( (_DWORD)v6[3] & 0x4000 )
    {
      v10 = 0.0;
      v9 = *(float *)(dword_85760DC + 8);
    }
    else
    {
      v4 = (long double)*((signed int *)v6 + 366) / (long double)(v8 + v7);
      v10 = (*(float *)(dword_85760D8 + 8) - 1.0) * v4 + 1.0;
      v9 = *(float *)(dword_85760E0 + 8);
    }
    v5 = (v10 - 1.0) * v6[55] + 1.0;
    v6[365] = sub_80A1986(v5, v6[365], v9, *(float *)(a2 + 36));
  }
  else
  {
    sub_80EA850((int)v6);
    v6[365] = 1.0;
    v6[366] = 0.0;
  }
}
// 85760CC: using guessed type int dword_85760CC;
// 85760D0: using guessed type int dword_85760D0;
// 85760D8: using guessed type int dword_85760D8;
// 85760DC: using guessed type int dword_85760DC;
// 85760E0: using guessed type int dword_85760E0;

//----- (080EABAA) --------------------------------------------------------
signed int __cdecl sub_80EABAA(_DWORD *a1)
{
  if ( !a1[54]
    || a1[54] == 1
    || a1[54] == 2
    || a1[54] == 5
    || a1[54] == 7
    || a1[54] == 9
    || a1[54] == 8
    || a1[54] == 6
    || a1[54] == 4 )
  {
    return 1;
  }
  if ( a1[54] == 3 || a1[54] == 11 || a1[54] > 11 && a1[54] <= 16 )
    return 0;
  sub_80ED212(a1);
  return 1;
}

//----- (080EAC7A) --------------------------------------------------------
int __cdecl sub_80EAC7A(int a1)
{
  return *(_DWORD *)(sub_80E9270(a1) + 464);
}

//----- (080EAC94) --------------------------------------------------------
int __cdecl sub_80EAC94(int a1)
{
  return *(_DWORD *)(sub_80E9270(a1) + 456);
}

//----- (080EACAE) --------------------------------------------------------
int __cdecl sub_80EACAE(int a1)
{
  return *(_DWORD *)(sub_80E9270(a1) + 832);
}

//----- (080EACC8) --------------------------------------------------------
int __cdecl sub_80EACC8(int a1, int a2)
{
  int v2; // ST0C_4

  v2 = sub_80EAC94(a2);
  return *(_DWORD *)(a1 + 4 * v2 + 324) + *(_DWORD *)(a1 + 4 * sub_80EAC7A(a2) + 836);
}

//----- (080EAD0C) --------------------------------------------------------
int __cdecl sub_80EAD0C(int a1)
{
  int result; // eax
  int v2; // ST0C_4
  int v3; // [esp+8h] [ebp-20h]
  int v4; // [esp+10h] [ebp-18h]
  int v5; // [esp+14h] [ebp-14h]
  int v6; // [esp+18h] [ebp-10h]
  int v7; // [esp+1Ch] [ebp-Ch]

  v7 = sub_80E9270(*(_DWORD *)(a1 + 212));
  if ( *(_DWORD *)(a1 + 216) != 7 && *(_DWORD *)(a1 + 216) != 8 || (result = v7, *(_DWORD *)(v7 + 868)) )
  {
    v6 = sub_80EAC94(*(_DWORD *)(a1 + 212));
    v5 = sub_80EAC7A(*(_DWORD *)(a1 + 212));
    v4 = *(_DWORD *)(a1 + 4 * v6 + 324);
    v2 = *(_DWORD *)(a1 + 4 * v5 + 836);
    v3 = sub_80E9356(v5) - v2;
    if ( v3 > v4 )
      v3 = v4;
    if ( *(_DWORD *)(a1 + 216) != 7 && *(_DWORD *)(a1 + 216) != 8 )
    {
      result = v7;
      if ( *(_DWORD *)(v7 + 864) )
      {
        result = sub_80E9356(v5);
        if ( *(_DWORD *)(v7 + 864) < result )
        {
          result = v3;
          if ( v3 > *(_DWORD *)(v7 + 864) )
          {
            result = *(_DWORD *)(v7 + 864);
            v3 = *(_DWORD *)(v7 + 864);
          }
        }
      }
    }
    else
    {
      result = sub_80E9356(v5);
      if ( *(_DWORD *)(v7 + 868) < result )
      {
        result = v3;
        if ( v3 > *(_DWORD *)(v7 + 868) )
        {
          result = *(_DWORD *)(v7 + 868);
          v3 = *(_DWORD *)(v7 + 868);
        }
      }
    }
    if ( v3 )
    {
      *(_DWORD *)(a1 + 4 * v6 + 324) -= v3;
      result = *(_DWORD *)(a1 + 4 * v5 + 836) + v3;
      *(_DWORD *)(a1 + 4 * v5 + 836) = result;
    }
  }
  return result;
}

//----- (080EAE8C) --------------------------------------------------------
int __cdecl sub_80EAE8C(int a1, int a2, int a3)
{
  int v3; // eax
  int v4; // ebx
  int result; // eax

  v3 = sub_80EAC7A(a2);
  v4 = v3;
  result = *(_DWORD *)(a1 + 4 * v3 + 836) - a3;
  *(_DWORD *)(a1 + 4 * v4 + 836) = result;
  return result;
}

//----- (080EAEC8) --------------------------------------------------------
int __cdecl sub_80EAEC8(int a1)
{
  return *(_DWORD *)(a1 + 4 * sub_80EAC7A(*(_DWORD *)(a1 + 212)) + 836);
}

//----- (080EAEF2) --------------------------------------------------------
_BOOL4 __cdecl sub_80EAEF2(int a1)
{
  return *(_DWORD *)(a1 + 4 * sub_80EAC7A(*(_DWORD *)(a1 + 212)) + 836) == 0;
}

//----- (080EAF30) --------------------------------------------------------
int __cdecl sub_80EAF30(int a1)
{
  int result; // eax

  sub_80E9240(a1, 0);
  result = a1;
  *(_DWORD *)(a1 + 216) = 0;
  return result;
}

//----- (080EAF58) --------------------------------------------------------
signed int __cdecl sub_80EAF58(int a1, int a2)
{
  _DWORD *v4; // [esp+14h] [ebp-4h]

  v4 = (_DWORD *)sub_80E9270(*(_DWORD *)(a1 + 212));
  if ( *(_DWORD *)(a1 + 216) > 16 && *(_DWORD *)(a1 + 216) <= 22 )
    return 0;
  if ( *(_DWORD *)(a1 + 216) <= 11 || *(_DWORD *)(a1 + 216) > 16 )
  {
    if ( v4[202] && (unsigned __int8)sub_80D9E84(a1 + 1372, *(_DWORD *)(a1 + 212)) )
    {
      if ( *(_DWORD *)(a1 + 216) == 4 )
      {
        if ( a2 )
        {
          sub_80F0400(a1 + 1372, *(_DWORD *)(a1 + 212));
          sub_80DED2E(a1, 162);
          if ( *(_DWORD *)(a1 + 52) )
            return 1;
        }
      }
      if ( !*(_DWORD *)(a1 + 52)
        || *(_DWORD *)(a1 + 216) != 3
        && *(_DWORD *)(a1 + 216) != 4
        && *(_DWORD *)(a1 + 216) != 10
        && *(_DWORD *)(a1 + 216) != 11
        && !*(_DWORD *)(a1 + 56) )
      {
        if ( *(_DWORD *)(a1 + 216) == 4 )
        {
          sub_80EAF30(a1);
        }
        else if ( !*(_DWORD *)(a1 + 216) )
        {
          if ( *(float *)(a1 + 220) <= 0.75 )
            sub_80E9210(a1, 4);
          else
            sub_80E9210(a1, 7);
          *(_DWORD *)(a1 + 216) = 4;
          *(_DWORD *)(a1 + 52) = v4[130];
          if ( v4[131] && v4[131] < v4[130] )
            *(_DWORD *)(a1 + 56) = v4[131];
          else
            *(_DWORD *)(a1 + 56) = 1;
          sub_80DED2E(a1, 161);
        }
      }
    }
    return 0;
  }
  return 0;
}

//----- (080EB180) --------------------------------------------------------
int __cdecl sub_80EB180(_DWORD *a1)
{
  int result; // eax
  signed int v2; // [esp+10h] [ebp-8h]
  _DWORD *v3; // [esp+14h] [ebp-4h]

  v3 = (_DWORD *)sub_80E9270(a1[53]);
  if ( a1[54] != 7 && a1[54] != 8 )
  {
    if ( a1[sub_80EAC7A(a1[53]) + 209] || v3[30] )
      v2 = v3[134];
    else
      v2 = v3[135];
    if ( v3[136] && v3[136] < v2 )
      v2 = v3[136];
  }
  else if ( v3[138] )
  {
    if ( v3[138] >= v3[137] )
      v2 = v3[137];
    else
      v2 = v3[138];
  }
  else
  {
    v2 = 0;
  }
  result = (int)v3;
  if ( v3[202] && (result = sub_80D9E84((int)(a1 + 343), a1[53]), (_BYTE)result) )
  {
    if ( !v2 )
      v2 = a1[13];
    if ( v3[131] < v2 )
      v2 = v3[131];
    if ( !v2 )
      v2 = 1;
    result = v2;
    a1[14] = v2;
  }
  else if ( v2 )
  {
    result = v2;
    a1[14] = v2;
  }
  return result;
}

//----- (080EB2E8) --------------------------------------------------------
int __cdecl sub_80EB2E8(_DWORD *a1)
{
  _DWORD *v2; // [esp+14h] [ebp-4h]

  v2 = (_DWORD *)sub_80E9270(a1[53]);
  if ( a1[sub_80EAC7A(a1[53]) + 209] || v2[30] )
  {
    sub_80E9210((int)a1, 11);
    a1[13] = v2[134];
    sub_80DED2E((int)a1, 150);
  }
  else
  {
    sub_80E9210((int)a1, 12);
    a1[13] = v2[135];
    sub_80DED2E((int)a1, 151);
  }
  if ( a1[54] == 8 )
    a1[54] = 6;
  else
    a1[54] = 5;
  return sub_80EB180(a1);
}

//----- (080EB3D0) --------------------------------------------------------
int __cdecl sub_80EB3D0(_DWORD *a1)
{
  int result; // eax
  int v2; // [esp+10h] [ebp-8h]

  v2 = sub_80E9270(a1[53]);
  if ( !a1[54] || a1[54] == 3 || (result = (int)a1, a1[54] == 4) )
  {
    result = (int)a1;
    if ( a1[53] )
    {
      result = sub_80E9322();
      if ( a1[53] <= result )
      {
        if ( !sub_80EACAE(a1[53]) )
          sub_80D6FCA(a1, 10, 0, 1);
        sub_80DED2E((int)a1, 149);
        if ( *(_DWORD *)(v2 + 860) && *(_DWORD *)(v2 + 548) )
        {
          sub_80E9210((int)a1, 13);
          a1[13] = *(_DWORD *)(v2 + 548);
          a1[54] = 7;
          sub_80DED2E((int)a1, 152);
          result = sub_80EB180(a1);
        }
        else
        {
          result = sub_80EB2E8(a1);
        }
      }
    }
  }
  return result;
}

//----- (080EB4FC) --------------------------------------------------------
int __cdecl sub_80EB4FC(_DWORD *a1, int a2)
{
  int result; // eax
  int v3; // edx
  signed int v4; // [esp+1Ch] [ebp-1Ch]
  int v5; // [esp+24h] [ebp-14h]
  _DWORD *v6; // [esp+28h] [ebp-10h]
  signed int v7; // [esp+2Ch] [ebp-Ch]

  if ( !a2 || (result = sub_80D9E84((int)(a1 + 337), a2), (_BYTE)result) )
  {
    result = (int)a1;
    if ( a1[54] != 2 )
    {
      a1[14] = 0;
      v5 = a1[53];
      if ( v5 && (unsigned __int8)sub_80D9E84((int)(a1 + 337), v5) && a1[15] <= 0 )
      {
        v6 = (_DWORD *)sub_80E9270(v5);
        v4 = 0;
        if ( a2 && a2 == v6[219] )
          v4 = 1;
        v7 = 1;
        if ( sub_80EACAE(v5) && !a1[sub_80EAC7A(v5) + 209] )
          v7 = 0;
        a1[15] = 0;
        if ( v4 )
        {
          sub_80DED2E((int)a1, 156);
          sub_80E9210((int)a1, 15);
        }
        else if ( v7 )
        {
          sub_80DED2E((int)a1, 155);
          sub_80E9210((int)a1, 9);
        }
        if ( !v4 && !(a1[3] & 4) )
          sub_80D6FCA(a1, 6, 0, 0);
        a1[54] = 2;
        sub_80E5820((int)a1);
        if ( v4 )
        {
          result = (int)a1;
          v3 = v6[142];
        }
        else
        {
          result = (int)a1;
          v3 = v6[140];
        }
        a1[13] = v3;
        if ( v4 )
        {
          result = sub_80E9B54((int)a1, v5, 1);
          if ( result )
            result = sub_80E9A9E((int)a1, result, a2);
        }
      }
      else
      {
        a1[13] = 0;
        a1[54] = 2;
        a1[15] = 0;
        result = sub_80E5820((int)a1);
      }
    }
  }
  return result;
}

//----- (080EB738) --------------------------------------------------------
int __cdecl sub_80EB738(unsigned __int8 *a1)
{
  char v1; // al
  int result; // eax
  int v3; // ST1C_4
  signed int v4; // [esp+18h] [ebp-20h]
  float *v5; // [esp+20h] [ebp-18h]
  int v6; // [esp+24h] [ebp-14h]
  int v7; // [esp+28h] [ebp-10h]

  v5 = *(float **)a1;
  sub_80E9270(*(_DWORD *)(*(_DWORD *)a1 + 212));
  if ( (unsigned __int8)sub_80DBEB0((int)v5) )
  {
    v6 = 0;
    v1 = sub_80D9E84((int)(v5 + 337), 0);
  }
  else if ( !((_DWORD)v5[3] & 0x20) && (unsigned __int8)sub_80D9E84((int)(v5 + 337), a1[12]) )
  {
    if ( !((_DWORD)v5[3] & 0x4000000) && (unsigned __int8)sub_80D9E84((int)(v5 + 337), a1[12]) )
    {
      v6 = a1[12];
      if ( v6 > sub_80E9322() )
        v6 = 0;
      v1 = sub_80D9E84((int)(v5 + 337), v6);
    }
    else
    {
      v6 = 0;
      v1 = sub_80D9E84((int)(v5 + 337), 0);
    }
  }
  else
  {
    v6 = 0;
    v1 = sub_80D9E84((int)(v5 + 337), 0);
  }
  if ( !v1 )
    v6 = 0;
  v7 = *((_DWORD *)v5 + 53);
  *((_DWORD *)v5 + 53) = (unsigned __int8)v6;
  sub_80E9270(*((_DWORD *)v5 + 53));
  if ( v7 == v6 )
  {
    v5[54] = 0.0;
    result = sub_80E9210((int)v5, 0);
  }
  else if ( v7 )
  {
    *((_DWORD *)v5 + 54) = 1;
    sub_80E5820((int)v5);
    v4 = 0;
    if ( v6 && v6 == *(_DWORD *)(sub_80E9270(v7) + 876) )
      v4 = 1;
    if ( v4 )
    {
      v5[13] = *(float *)(sub_80E9270(v6) + 572);
    }
    else
    {
      sub_80DED2E((int)v5, 154);
      v5[13] = *(float *)(sub_80E9270(v6) + 564);
    }
    v3 = sub_80E9270(v6);
    sub_80D70E2(*((_DWORD *)v5 + 51), 0, *(_DWORD *)(v3 + 116), 1);
    sub_80D70E2(*((_DWORD *)v5 + 51), 1, *(_DWORD *)(v3 + 124), 1);
    if ( v6 && v6 == *(_DWORD *)(sub_80E9270(v7) + 876) )
    {
      if ( v5[373] < 128.0 )
        v5[373] = 128.0;
      result = sub_80E9210((int)v5, 16);
    }
    else
    {
      sub_80D6FCA(v5, 7, 0, 0);
      v5[373] = 255.0;
      result = sub_80E9210((int)v5, 10);
    }
  }
  else
  {
    *((_DWORD *)v5 + 54) = 1;
    v5[13] = *(float *)(sub_80E9270(v6) + 564);
    v5[373] = 255.0;
    sub_80E9210((int)v5, 10);
    result = sub_80E5820((int)v5);
  }
  return result;
}

//----- (080EBA76) --------------------------------------------------------
int __cdecl sub_80EBA76(int a1)
{
  *(_DWORD *)(a1 + 216) = 0;
  return sub_80E9210(a1, 0);
}

//----- (080EBA9E) --------------------------------------------------------
signed int __cdecl sub_80EBA9E(int a1)
{
  int v3; // [esp+18h] [ebp-10h]
  int v4; // [esp+1Ch] [ebp-Ch]

  v4 = sub_80E9270(*(_DWORD *)(a1 + 212));
  v3 = sub_80EAC7A(*(_DWORD *)(a1 + 212));
  if ( !*(_DWORD *)(a1 + 4 * sub_80EAC94(*(_DWORD *)(a1 + 212)) + 324)
    || *(_DWORD *)(a1 + 4 * v3 + 836) >= sub_80E9356(v3) )
  {
    return 0;
  }
  if ( !*(_DWORD *)(v4 + 856) )
    return 1;
  if ( *(_DWORD *)(v4 + 864) && *(_DWORD *)(v4 + 864) < sub_80E9356(v3) )
  {
    if ( sub_80E9356(v3) - *(_DWORD *)(a1 + 4 * v3 + 836) >= *(_DWORD *)(v4 + 864) )
      return 1;
    return 0;
  }
  if ( *(_DWORD *)(a1 + 4 * v3 + 836) )
    return 0;
  return 1;
}

//----- (080EBBA8) --------------------------------------------------------
int __cdecl sub_80EBBA8(_DWORD *a1)
{
  int result; // eax
  signed int v2; // [esp+Ch] [ebp-Ch]
  int v3; // [esp+10h] [ebp-8h]
  int v4; // [esp+10h] [ebp-8h]
  _DWORD *v5; // [esp+14h] [ebp-4h]

  v5 = (_DWORD *)sub_80E9270(a1[53]);
  if ( !v5[202] || !(unsigned __int8)sub_80D9E84((int)(a1 + 343), a1[53]) )
    return sub_80EAD0C((int)a1);
  sub_80F0400((int)(a1 + 343), a1[53]);
  sub_80DED2E((int)a1, 162);
  if ( a1[54] != 7 && a1[54] != 8 || (result = (int)v5, v5[138]) )
  {
    if ( a1[13] )
    {
      if ( a1[54] != 7 && a1[54] != 8 )
      {
        if ( a1[sub_80EAC7A(a1[53]) + 209] || v5[30] )
          v3 = v5[134];
        else
          v3 = v5[135];
        if ( v5[136] && v5[136] < v3 )
          v3 = v5[136];
      }
      else if ( v5[138] >= v5[137] )
      {
        v3 = v5[137];
      }
      else
      {
        v3 = v5[138];
      }
      if ( v5[131] >= v3 )
        v2 = 1;
      else
        v2 = v5[131];
      v4 = v3 - v2;
      if ( v4 > 0 )
      {
        result = v4;
        a1[14] = v4;
      }
      else
      {
        result = sub_80EAD0C((int)a1);
      }
    }
    else
    {
      result = sub_80EAD0C((int)a1);
    }
  }
  return result;
}

//----- (080EBD80) --------------------------------------------------------
int __cdecl sub_80EBD80(_DWORD *a1, int a2)
{
  int result; // eax
  int v3; // [esp+10h] [ebp-8h]

  v3 = sub_80E9270(a1[53]);
  if ( a2 )
    sub_80EBBA8(a1);
  result = (int)a1;
  if ( !a1[13] )
  {
    if ( a1[54] == 8 && a1[sub_80EAC7A(a1[53]) + 209] || !sub_80EBA9E((int)a1) )
    {
      sub_80F0400((int)(a1 + 343), a1[53]);
      if ( *(_DWORD *)(v3 + 556) )
      {
        a1[54] = 9;
        sub_80E9210((int)a1, 14);
        a1[13] = *(_DWORD *)(v3 + 556);
        result = sub_80DED2E((int)a1, 153);
      }
      else
      {
        a1[54] = 0;
        result = sub_80E9210((int)a1, 0);
      }
    }
    else
    {
      result = sub_80EB2E8(a1);
    }
  }
  return result;
}

//----- (080EBE96) --------------------------------------------------------
int __cdecl sub_80EBE96(_DWORD *a1, int a2)
{
  int result; // eax
  int v3; // [esp+14h] [ebp-4h]

  v3 = sub_80E9270(a1[53]);
  if ( !a2 || (sub_80EBBA8(a1), result = (int)a1, !a1[13]) )
  {
    result = (int)a1;
    if ( !a1[13] )
    {
      sub_80F0400((int)(a1 + 343), a1[53]);
      if ( *(_DWORD *)(v3 + 860) )
      {
        if ( a1[54] != 6 && sub_80EBA9E((int)a1) )
        {
          result = sub_80EB2E8(a1);
        }
        else if ( *(_DWORD *)(v3 + 556) )
        {
          a1[54] = 9;
          sub_80E9210((int)a1, 14);
          a1[13] = *(_DWORD *)(v3 + 556);
          result = sub_80DED2E((int)a1, 153);
        }
        else
        {
          a1[54] = 0;
          result = sub_80E9210((int)a1, 0);
        }
      }
      else
      {
        a1[54] = 0;
        result = sub_80E9210((int)a1, 0);
      }
    }
  }
  return result;
}

//----- (080EBFC8) --------------------------------------------------------
int __cdecl sub_80EBFC8(int a1)
{
  *(_DWORD *)(a1 + 216) = 0;
  return sub_80E9210(a1, 0);
}

//----- (080EBFF0) --------------------------------------------------------
char __cdecl sub_80EBFF0(int a1)
{
  int v1; // eax
  _DWORD *v3; // [esp+20h] [ebp-18h]
  int v4; // [esp+24h] [ebp-14h]
  int v5; // [esp+28h] [ebp-10h]
  signed int v6; // [esp+2Ch] [ebp-Ch]
  signed int v7; // [esp+30h] [ebp-8h]
  int v8; // [esp+34h] [ebp-4h]

  v6 = 0;
  v3 = *(_DWORD **)a1;
  v8 = sub_80E9270(*(_DWORD *)(*(_DWORD *)a1 + 212));
  if ( v3[54] <= 16 || (LOBYTE(v1) = (_BYTE)v3, v3[54] > 22) )
  {
    if ( v3[54] <= 11 || (LOBYTE(v1) = (_BYTE)v3, v3[54] > 16) )
    {
      v7 = 0;
      if ( *(_DWORD *)(a1 + 8) & 0x10 )
        v7 = 1;
      if ( v3[3] & 8 )
      {
        v3[3] &= 0xFFFFFFF7;
        v7 = 1;
      }
      if ( *(_DWORD *)(v8 + 860)
        && (v3[54] == 7 || v3[54] == 5)
        && *(_BYTE *)(a1 + 8) & 1
        && (*(_BYTE *)(a1 + 36) ^ 1) & 1 )
      {
        if ( v3[54] == 7 )
        {
          v3[54] = 8;
        }
        else if ( v3[54] == 5 )
        {
          v3[54] = 6;
        }
      }
      v1 = v3[54];
      switch ( v1 )
      {
        case 0:
        case 3:
        case 4:
          v5 = sub_80EAC7A(v3[53]);
          v4 = sub_80EAC94(v3[53]);
          if ( v7 && sub_80EBA9E((int)v3) )
            v6 = 1;
          LOBYTE(v1) = v5;
          if ( !v3[v5 + 209] )
          {
            LOBYTE(v1) = v4;
            if ( v3[v4 + 81] )
            {
              LOBYTE(v1) = (_BYTE)v3;
              if ( v3[54] != 3 )
              {
                LOBYTE(v1) = (*((_BYTE *)v3 + 12) ^ 1) & 1;
                if ( (_BYTE)v1 || (LOBYTE(v1) = a1, !*(_BYTE *)(a1 + 28)) && (LOBYTE(v1) = a1, !*(_BYTE *)(a1 + 29)) )
                  v6 = 1;
              }
            }
          }
          if ( v6 )
            LOBYTE(v1) = sub_80EB3D0(v3);
          break;
        case 1:
        case 2:
        case 10:
        case 11:
          return v1;
        case 5:
        case 6:
        case 7:
        case 8:
        case 9:
          LOBYTE(v1) = a1;
          if ( *(_DWORD *)(a1 + 224) )
          {
            v1 = sub_80EACAE(v3[53]);
            if ( !v1 )
              LOBYTE(v1) = sub_80D6FCA(v3, 10, 0, 1);
          }
          break;
      }
    }
  }
  return v1;
}

//----- (080EC22A) --------------------------------------------------------
int __cdecl sub_80EC22A(int a1)
{
  int result; // eax

  result = sub_80EACAE(*(_DWORD *)(a1 + 212));
  if ( result )
  {
    result = sub_80EAC7A(*(_DWORD *)(a1 + 212));
    if ( !*(_DWORD *)(a1 + 4 * result + 836) )
    {
      result = sub_80EAC94(*(_DWORD *)(a1 + 212));
      if ( !*(_DWORD *)(a1 + 4 * result + 324) )
      {
        sub_80E98CA(a1, *(_DWORD *)(a1 + 212));
        result = sub_80DED2E(a1, 146);
      }
    }
  }
  return result;
}

//----- (080EC2BA) --------------------------------------------------------
void __cdecl sub_80EC2BA(_BYTE *a1, int a2)
{
  float v2; // ST04_4
  float v3; // ST00_4
  float v4; // ST00_4
  float v5; // ST10_4
  int v6; // [esp+1Ch] [ebp-1Ch]
  float v7; // [esp+20h] [ebp-18h]
  float v8; // [esp+24h] [ebp-14h]
  float v9; // [esp+28h] [ebp-10h]
  float v10; // [esp+2Ch] [ebp-Ch]
  signed int i; // [esp+30h] [ebp-8h]
  signed int j; // [esp+30h] [ebp-8h]
  float *v13; // [esp+34h] [ebp-4h]

  v6 = *(_DWORD *)a1;
  v13 = (float *)sub_80E9270(*(_DWORD *)(*(_DWORD *)a1 + 212));
  v7 = v13[169];
  if ( v7 == 0.0 )
  {
    v10 = 0.0;
    v9 = 1.0;
  }
  else
  {
    if ( *(_DWORD *)(v6 + 96) != 1023 || *(_DWORD *)(v6 + 4) == 1 )
    {
      if ( *(_DWORD *)(v6 + 160) & 8 )
      {
        v7 = v7 * v13[174];
      }
      else if ( *(_DWORD *)(v6 + 160) & 4 )
      {
        v7 = v7 * v13[173];
      }
    }
    else
    {
      v7 = v7 * 0.5;
    }
    v9 = v7 * *(float *)(a2 + 36);
    if ( *(float *)(v6 + 220) == 1.0 )
    {
      v10 = 0.0;
    }
    else
    {
      v8 = 0.0;
      if ( v13[171] != 0.0 )
      {
        for ( i = 0; i <= 1; ++i )
        {
          v2 = (long double)*(signed int *)&a1[4 * i + 44] * 0.0054931641;
          v3 = (long double)*(signed int *)&a1[4 * i + 16] * 0.0054931641;
          v4 = sub_80A6000(v3, v2);
          v8 = sub_80F0198(v4) * 0.0099999998 * v13[171] / *(float *)(a2 + 36) + v8;
        }
      }
      if ( v13[172] != 0.0 && (a1[28] || a1[29]) )
      {
        v5 = sub_80F026A((float *)(v6 + 32));
        if ( v5 > sub_80F025E(*(float *)(dword_85760C8 + 8)) )
          v8 = v8 + v13[172];
      }
      if ( *(_DWORD *)(v6 + 96) == 1023 && *(_DWORD *)(v6 + 4) != 1 )
      {
        for ( j = 0; j <= 1; ++j )
          v8 = v8 + 1.28;
      }
      v10 = v8 * *(float *)(a2 + 36);
    }
  }
  *(float *)(v6 + 1492) = (v10 - v9) * 255.0 + *(float *)(v6 + 1492);
  if ( *(float *)(v6 + 1492) >= 0.0 )
  {
    if ( *(float *)(v6 + 1492) > 255.0 )
      *(_DWORD *)(v6 + 1492) = 1132396544;
  }
  else
  {
    *(_DWORD *)(v6 + 1492) = 0;
  }
}
// 85760C8: using guessed type int dword_85760C8;

//----- (080EC560) --------------------------------------------------------
signed int __cdecl sub_80EC560(_BYTE *a1, int a2)
{
  _DWORD *v4; // [esp+Ch] [ebp-Ch]
  _DWORD *v5; // [esp+10h] [ebp-8h]

  v4 = *(_DWORD **)a1;
  v5 = (_DWORD *)sub_80E9270(*(_DWORD *)(*(_DWORD *)a1 + 212));
  if ( v4[16] > 0 )
  {
    v4[16] -= *(_DWORD *)(a2 + 40);
    v4[16] = sub_80F01FA(v4[16], 0);
  }
  if ( v4[13] )
  {
    v4[13] -= *(_DWORD *)(a2 + 40);
    if ( v4[13] <= 0 )
    {
      if ( (v4[54] <= 11 || v4[54] > 16)
        && v5[201]
        && a1[8] & 1
        && v4[53] == (unsigned __int8)a1[12]
        && sub_80EAEC8((int)v4) )
      {
        v4[13] = 1;
        if ( v4[54] == 5 || v4[54] == 7 || v4[54] == 9 || v4[54] == 8 || v4[54] == 6 )
          v4[13] = 0;
        if ( (v4[54] == 5 || v4[54] == 7 || v4[54] == 9 || v4[54] == 8 || v4[54] == 6)
          && v4[54] != 9
          && v5[215]
          && v5[137] )
        {
          v4[13] = 0;
        }
        else if ( v4[54] == 4 )
        {
          sub_80EAF30((int)v4);
        }
        else if ( v4[54] == 3 || v4[54] == 4 || v4[54] == 10 || v4[54] == 11 )
        {
          sub_80E9240((int)v4, 0);
          v4[54] = 0;
        }
      }
      else
      {
        v4[13] = 0;
      }
    }
  }
  if ( !v4[14] )
    return 0;
  v4[14] -= *(_DWORD *)(a2 + 40);
  if ( v4[14] > 0 )
    return 0;
  v4[14] = 0;
  return 1;
}

//----- (080EC7D2) --------------------------------------------------------
int __cdecl sub_80EC7D2(unsigned __int8 *a1)
{
  int result; // eax
  int v2; // [esp+14h] [ebp-4h]

  v2 = *(_DWORD *)a1;
  if ( *(_DWORD *)(*(_DWORD *)a1 + 216) <= 16 || (result = *(_DWORD *)a1, *(_DWORD *)(v2 + 216) > 22) )
  {
    if ( *(_DWORD *)(v2 + 216) <= 11 || (result = *(_DWORD *)a1, *(_DWORD *)(v2 + 216) > 16) )
    {
      if ( !*(_DWORD *)(v2 + 52)
        || *(_DWORD *)(v2 + 216) == 5
        || *(_DWORD *)(v2 + 216) == 7
        || *(_DWORD *)(v2 + 216) == 9
        || *(_DWORD *)(v2 + 216) == 8
        || *(_DWORD *)(v2 + 216) == 6
        || *(_DWORD *)(v2 + 216) == 4
        || (result = *(_DWORD *)a1, *(_DWORD *)(v2 + 216) != 3)
        && (result = *(_DWORD *)a1, *(_DWORD *)(v2 + 216) != 4)
        && (result = *(_DWORD *)a1, *(_DWORD *)(v2 + 216) != 10)
        && (result = *(_DWORD *)a1, *(_DWORD *)(v2 + 216) != 11)
        && (result = *(_DWORD *)a1, !*(_DWORD *)(v2 + 56)) )
      {
        if ( (unsigned __int8)sub_80DBEB0(v2) )
        {
          result = v2;
          if ( *(_DWORD *)(v2 + 212) )
            result = sub_80EB4FC((_DWORD *)v2, 0);
        }
        else if ( *(_DWORD *)(v2 + 12) & 0x20 )
        {
          result = v2;
          if ( *(_DWORD *)(v2 + 212) )
            result = sub_80EB4FC((_DWORD *)v2, 0);
        }
        else if ( *(_DWORD *)(v2 + 12) & 0x4000000 )
        {
          result = v2;
          if ( *(_DWORD *)(v2 + 212) )
            result = sub_80EB4FC((_DWORD *)v2, 0);
        }
        else if ( *(_DWORD *)(v2 + 212) == a1[12]
               || *(_WORD *)(v2 + 12) < 0 && *(_DWORD *)(v2 + 212)
               || a1[12] && !(unsigned __int8)sub_80E97F0(v2, a1[12]) )
        {
          result = v2;
          if ( *(_DWORD *)(v2 + 212) )
          {
            result = sub_80D9E84(v2 + 1348, *(_DWORD *)(v2 + 212));
            if ( !(_BYTE)result )
              result = sub_80EB4FC((_DWORD *)v2, 0);
          }
        }
        else
        {
          result = sub_80EB4FC((_DWORD *)v2, a1[12]);
        }
      }
    }
  }
  return result;
}

//----- (080ECA14) --------------------------------------------------------
signed int __cdecl sub_80ECA14(_BYTE *a1, int a2)
{
  int v4; // [esp+14h] [ebp-4h]

  if ( !((a1[8] ^ 1) & 1) || a2 )
    return 0;
  v4 = *(_DWORD *)a1;
  if ( *(_DWORD *)(*(_DWORD *)a1 + 216) == 3 )
    sub_80E9240(v4, 0);
  *(_DWORD *)(v4 + 216) = 0;
  return 1;
}

//----- (080ECA78) --------------------------------------------------------
int __cdecl sub_80ECA78(int a1, int a2)
{
  int v3; // [esp+20h] [ebp-8h]

  v3 = sub_80E9270(*(_DWORD *)(a1 + 212));
  if ( *(_DWORD *)(v3 + 120) == 1 )
  {
    if ( !a2 )
    {
      if ( sub_80EAEC8(a1) )
      {
        *(_DWORD *)(a1 + 60) = *(_DWORD *)(v3 + 584);
        sub_80E9210(a1, 19);
        sub_80DED2E(a1, 157);
      }
      *(_DWORD *)(a1 + 56) = *(_DWORD *)(v3 + 528);
      *(_DWORD *)(a1 + 52) = 0;
    }
  }
  else
  {
    *(_DWORD *)(a1 + 56) = *(_DWORD *)(v3 + 508);
    *(_DWORD *)(a1 + 52) = *(_DWORD *)(v3 + 516);
    if ( *(_DWORD *)(v3 + 840) )
      *(_DWORD *)(a1 + 56) = (signed int)((1.0 - *(float *)(a1 + 220)) * (1.0 / *(float *)(v3 + 1416)));
    sub_80D6FCA((_DWORD *)a1, 2, 0, 1);
    if ( *(_DWORD *)(v3 + 808) )
      sub_80D9EAA(a1 + 1372, *(_DWORD *)(a1 + 212));
    if ( *(_DWORD *)(a1 + 216) != 3 )
    {
      if ( *(float *)(a1 + 220) < 1.0 )
        *(_DWORD *)(a1 + 64) = *(_DWORD *)(v3 + 508) + *(_DWORD *)(v3 + 1216) * *(_DWORD *)(v3 + 516);
      else
        *(_DWORD *)(a1 + 64) = *(_DWORD *)(v3 + 508) + *(_DWORD *)(v3 + 1144) * *(_DWORD *)(v3 + 516);
    }
  }
  *(_DWORD *)(a1 + 216) = 3;
  return sub_80E5820(a1);
}

//----- (080ECC42) --------------------------------------------------------
signed int sub_80ECC42()
{
  return 1;
}

//----- (080ECC4C) --------------------------------------------------------
signed int __cdecl sub_80ECC4C(_DWORD *a1)
{
  int v1; // ST00_4
  signed int v4; // [esp+10h] [ebp-18h]
  _BOOL4 v5; // [esp+14h] [ebp-14h]
  int v6; // [esp+1Ch] [ebp-Ch]
  int v7; // [esp+20h] [ebp-8h]

  v4 = 1;
  v7 = sub_80E9270(a1[53]);
  v1 = a1[53];
  v6 = sub_80ECC42();
  if ( v6 <= sub_80EAEC8((int)a1) )
    return 1;
  v5 = v6 <= a1[sub_80EAC94(a1[53]) + 81];
  if ( *(_DWORD *)(v7 + 120) == 1 )
    v4 = 0;
  if ( v4 && !v5 )
    sub_80DED2E((int)a1, 146);
  if ( v5 )
  {
    sub_80EB3D0(a1);
  }
  else
  {
    sub_80F0400((int)(a1 + 343), a1[53]);
    sub_80E9240((int)a1, 0);
    a1[13] += 500;
  }
  return 0;
}

//----- (080ECD62) --------------------------------------------------------
int __cdecl sub_80ECD62(int a1)
{
  int result; // eax

  if ( *(float *)(a1 + 220) <= 0.75 )
  {
    if ( sub_80EAEF2(a1) )
      result = sub_80E9210(a1, 3);
    else
      result = sub_80E9210(a1, 2);
  }
  else if ( sub_80EAEF2(a1) )
  {
    result = sub_80E9210(a1, 6);
  }
  else
  {
    result = sub_80E9210(a1, 5);
  }
  return result;
}

//----- (080ECDD6) --------------------------------------------------------
void __cdecl sub_80ECDD6(int a1)
{
  int v1; // [esp+4h] [ebp-4h]

  v1 = sub_80E9270(*(_DWORD *)(a1 + 212));
  if ( *(float *)(a1 + 220) != 1.0 )
  {
    *(float *)(a1 + 1492) = *(float *)(v1 + 680) * 255.0 + *(float *)(a1 + 1492);
    if ( *(float *)(a1 + 1492) > 255.0 )
      *(_DWORD *)(a1 + 1492) = 1132396544;
  }
}

//----- (080ECE56) --------------------------------------------------------
signed int __cdecl sub_80ECE56(_DWORD *a1, int a2)
{
  signed int result; // eax
  int v3; // ST00_4
  int v4; // eax
  int v5; // [esp+14h] [ebp-4h]

  v5 = sub_80E9270(a1[53]);
  sub_80ECA78((int)a1, a2);
  result = sub_80ECC4C(a1);
  if ( result )
  {
    result = (signed int)a1;
    if ( !a1[14] )
    {
      if ( sub_80EAEC8((int)a1) != -1 && !(a1[40] & 0x300) )
      {
        v3 = a1[53];
        v4 = sub_80ECC42();
        sub_80EAE8C((int)a1, a1[53], v4);
      }
      if ( *(_DWORD *)(v5 + 120) == 1 )
        a1[13] = *(_DWORD *)(v5 + 516);
      sub_80ECD62((int)a1);
      if ( sub_80EAEF2((int)a1) )
        sub_80DED2E((int)a1, 160);
      else
        sub_80DED2E((int)a1, 158);
      sub_80EA868((int)a1);
      sub_80ECDD6((int)a1);
      result = sub_80EC22A((int)a1);
    }
  }
  return result;
}

//----- (080ECF70) --------------------------------------------------------
int __cdecl sub_80ECF70(_DWORD *a1)
{
  int v2; // [esp+10h] [ebp-8h]

  v2 = sub_80E9270(a1[53]);
  if ( a1[13] < *(_DWORD *)(v2 + 532) - *(_DWORD *)(v2 + 512) )
    a1[13] = *(_DWORD *)(v2 + 532) - *(_DWORD *)(v2 + 512);
  sub_80DED2E((int)a1, 164);
  a1[54] = 11;
  return sub_80E5820((int)a1);
}

//----- (080ECFF2) --------------------------------------------------------
int __cdecl sub_80ECFF2(int a1)
{
  int result; // eax

  sub_80E9240(a1, 0);
  result = a1;
  *(_DWORD *)(a1 + 216) = 0;
  return result;
}

//----- (080ED01A) --------------------------------------------------------
int __cdecl sub_80ED01A(int *a1, int a2)
{
  int result; // eax
  signed int v3; // [esp+1Ch] [ebp-Ch]
  int v4; // [esp+20h] [ebp-8h]
  _DWORD *v5; // [esp+24h] [ebp-4h]

  v4 = *a1;
  v5 = (_DWORD *)sub_80E9270(*(_DWORD *)(*a1 + 212));
  if ( *(_DWORD *)(v4 + 216) <= 16 || (result = v4, *(_DWORD *)(v4 + 216) > 22) )
  {
    if ( *(_DWORD *)(v4 + 216) <= 11 || (result = v4, *(_DWORD *)(v4 + 216) > 16) )
    {
      result = (int)v5;
      if ( v5[125] )
      {
        if ( !a2 )
        {
          if ( !*(_DWORD *)(v4 + 56)
            || *(_DWORD *)(v4 + 216) == 5
            || *(_DWORD *)(v4 + 216) == 7
            || *(_DWORD *)(v4 + 216) == 9
            || *(_DWORD *)(v4 + 216) == 8
            || (result = v4, *(_DWORD *)(v4 + 216) == 6) )
          {
            if ( a1[2] & 4 )
            {
              result = *(_DWORD *)(v4 + 12) & 0x2000;
              if ( !result )
              {
                *(_DWORD *)(v4 + 12) |= 0x2000u;
                if ( *(float *)(v4 + 220) <= 0.0 || (result = (int)v5, !v5[158]) )
                {
                  result = *(_DWORD *)(v4 + 216);
                  v3 = *(_DWORD *)(v4 + 216);
                  if ( v3 < 1 || v3 > 2 && (result = v3 - 10, (unsigned int)(v3 - 10) > 1) )
                  {
                    sub_80D6FCA((_DWORD *)v4, 17, 0, 1);
                    sub_80E9210(v4, 8);
                    sub_80DED2E(v4, 163);
                    if ( v5[128] )
                    {
                      *(_DWORD *)(v4 + 52) = v5[133];
                      *(_DWORD *)(v4 + 56) = v5[128];
                      *(_DWORD *)(v4 + 216) = 10;
                      result = sub_80E5820(v4);
                    }
                    else
                    {
                      result = sub_80ECF70((_DWORD *)v4);
                    }
                  }
                }
              }
            }
            else
            {
              result = v4;
              *(_DWORD *)(v4 + 12) &= 0xFFFFDFFF;
            }
          }
        }
      }
    }
  }
  return result;
}

//----- (080ED212) --------------------------------------------------------
int __cdecl sub_80ED212(_DWORD *a1)
{
  a1[3] &= 0xFFFFF7EF;
  if ( a1[54] > 16 && a1[54] <= 22 )
    sub_80ED8A6((int)a1);
  a1[13] = 0;
  a1[14] = 0;
  a1[54] = 0;
  return sub_80E9210((int)a1, 0);
}

//----- (080ED282) --------------------------------------------------------
int __cdecl sub_80ED282(_DWORD *a1)
{
  int v1; // eax

  v1 = sub_80E9270(a1[53]);
  a1[54] = 12;
  a1[13] = *(_DWORD *)(v1 + 576);
  a1[14] = 0;
  a1[3] &= 0xFFFFFFEF;
  sub_80EA53E((int)a1);
  return sub_80E9210((int)a1, 17);
}

//----- (080ED2F2) --------------------------------------------------------
int __cdecl sub_80ED2F2(_DWORD *a1)
{
  int v1; // eax

  v1 = sub_80E9270(a1[52]);
  a1[54] = 13;
  a1[13] = *(_DWORD *)(v1 + 528);
  a1[14] = 0;
  a1[3] |= 0x10u;
  sub_80DD554(165, a1[52], (int)a1);
  sub_80E9210((int)a1, 19);
  return sub_80E5820((int)a1);
}

//----- (080ED382) --------------------------------------------------------
int __cdecl sub_80ED382(_DWORD *a1)
{
  int v1; // eax
  int result; // eax

  v1 = sub_80E9270(a1[52]);
  a1[54] = 14;
  a1[13] = 0;
  a1[14] = 0;
  a1[3] |= 0x10u;
  result = *(_DWORD *)(v1 + 584);
  a1[15] = result;
  return result;
}

//----- (080ED3DE) --------------------------------------------------------
int __cdecl sub_80ED3DE(int *a1)
{
  int result; // eax
  int v2; // eax
  _DWORD *v3; // [esp+10h] [ebp-8h]

  v3 = (_DWORD *)*a1;
  if ( a1[9] & 0x30000 && a1[2] & 0x30000 )
  {
    result = *a1;
    v3[14] = 1;
  }
  else
  {
    v2 = sub_80E9270(v3[52]);
    v3[54] = 15;
    v3[13] = *(_DWORD *)(v2 + 516);
    v3[14] = 0;
    v3[3] |= 0x10u;
    sub_80DD554(166, v3[52], (int)v3);
    sub_80E9210((int)v3, 2);
    sub_80EAE8C((int)v3, v3[52], 1);
    sub_80D6FCA(v3, 2, 0, 1);
    result = sub_80EACC8((int)v3, v3[52]);
    if ( !result )
      result = sub_80DED2E((int)v3, 148);
  }
  return result;
}

//----- (080ED50A) --------------------------------------------------------
unsigned int __cdecl sub_80ED50A(_DWORD *a1)
{
  unsigned int result; // eax

  if ( a1[53] )
  {
    a1[13] = *(_DWORD *)(sub_80E9270(a1[53]) + 580);
    a1[14] = 0;
    sub_80E9210((int)a1, 18);
  }
  else
  {
    a1[13] = 0;
    a1[14] = 1;
  }
  a1[54] = 16;
  result = a1[3] & 0xFFFFF7EF;
  a1[3] = result;
  return result;
}

//----- (080ED592) --------------------------------------------------------
int __cdecl sub_80ED592(int a1)
{
  return sub_80DED2E(a1, 148);
}

//----- (080ED5AE) --------------------------------------------------------
int __cdecl sub_80ED5AE(int *a1)
{
  int result; // eax
  int v2; // eax
  _DWORD *v3; // eax
  int v4; // [esp+1Ch] [ebp-Ch]
  _DWORD *v5; // [esp+20h] [ebp-8h]

  v5 = (_DWORD *)*a1;
  result = *(_DWORD *)(*a1 + 160) & 0x300;
  if ( !result )
  {
    result = v5[3] & 0x4000000;
    if ( !result )
    {
      if ( v5[54] <= 16 || (result = *a1, v5[54] > 22) )
      {
        if ( v5[54] <= 11 || v5[54] > 16 || (result = *a1, v5[54] == 16) )
        {
          if ( (unsigned __int8)sub_80D9E84((int)(v5 + 337), *((unsigned __int8 *)a1 + 13)) )
            v5[52] = *((unsigned __int8 *)a1 + 13);
          if ( a1[2] & 0x10000 )
          {
            v2 = sub_80E963A((int)v5, 1);
          }
          else
          {
            result = a1[2] & 0x20000;
            if ( !result )
              return result;
            v2 = sub_80E963A((int)v5, 2);
          }
          v4 = v2;
          if ( v2 )
          {
            sub_80DD554(167, v2, (int)v5);
            v5[52] = v4;
            v3 = (_DWORD *)sub_80E9270(v5[52]);
            if ( v3[30] != 1 )
              Com_Error(1, "[%s] Only grenades are currently supported for off hand use\n", *v3);
            if ( !v3[33] )
              Com_Error(1, "[%s] No offhand class set\n", *v3);
            if ( v5[53] && v5[54] != 16 )
              result = sub_80ED282(v5);
            else
              result = sub_80ED2F2(v5);
          }
          else
          {
            result = sub_80ED592((int)v5);
          }
        }
      }
    }
  }
  return result;
}

//----- (080ED780) --------------------------------------------------------
signed int __cdecl sub_80ED780(_DWORD *a1, int a2)
{
  int v4; // [esp+1Ch] [ebp-Ch]
  int v5; // [esp+20h] [ebp-8h]

  if ( !(a1[3] & 0x10) )
    return 0;
  v4 = a1[52];
  v5 = sub_80E9270(a1[52]);
  if ( *(_DWORD *)(v5 + 120) != 1 )
    return 0;
  if ( a1[15] <= 0 )
    return 0;
  if ( *(_DWORD *)(v5 + 828) )
    a1[15] -= *(_DWORD *)(a2 + 40);
  if ( a1[15] > 0 )
    return 0;
  sub_80EAE8C((int)a1, v4, 1);
  sub_80DED2E((int)a1, 197);
  return 1;
}

//----- (080ED84E) --------------------------------------------------------
int __cdecl sub_80ED84E(int a1)
{
  *(_DWORD *)(a1 + 12) |= 0x20000u;
  return sub_80DED2E(a1, 168);
}

//----- (080ED87A) --------------------------------------------------------
int __cdecl sub_80ED87A(int a1)
{
  *(_DWORD *)(a1 + 12) &= 0xFFFDFFFF;
  return sub_80DED2E(a1, 169);
}

//----- (080ED8A6) --------------------------------------------------------
int __cdecl sub_80ED8A6(int a1)
{
  *(_DWORD *)(a1 + 220) = 0;
  sub_80EA53E(a1);
  return sub_80ED87A(a1);
}

//----- (080ED8D2) --------------------------------------------------------
_DWORD *__cdecl sub_80ED8D2(_DWORD *a1)
{
  int v1; // ST04_4
  _DWORD *result; // eax

  v1 = sub_80E9270(a1[53]);
  sub_80EA53E((int)a1);
  a1[13] = 0;
  a1[14] = *(_DWORD *)(v1 + 708) + *(_DWORD *)(dword_85760F4 + 8);
  result = a1;
  a1[54] = 17;
  return result;
}
// 85760F4: using guessed type int dword_85760F4;

//----- (080ED928) --------------------------------------------------------
int __cdecl sub_80ED928(_DWORD *a1)
{
  int v1; // eax

  v1 = sub_80E9270(a1[53]);
  a1[54] = 18;
  a1[13] = *(_DWORD *)(v1 + 576);
  a1[14] = 0;
  return sub_80E9210((int)a1, 17);
}

//----- (080ED97E) --------------------------------------------------------
int __cdecl sub_80ED97E(_DWORD *a1)
{
  int v1; // eax
  int v2; // eax

  v1 = sub_80E95A8();
  v2 = sub_80E9270(v1);
  a1[54] = 19;
  a1[13] = *(_DWORD *)(v2 + 704);
  a1[14] = 0;
  sub_80ED84E((int)a1);
  return sub_80E9210((int)a1, 0);
}

//----- (080ED9E0) --------------------------------------------------------
_DWORD *__cdecl sub_80ED9E0(_DWORD *a1)
{
  _DWORD *result; // eax

  a1[54] = 20;
  a1[13] = 0;
  result = a1;
  a1[14] = 0;
  return result;
}

//----- (080EDA06) --------------------------------------------------------
int __cdecl sub_80EDA06(_DWORD *a1)
{
  int v1; // eax
  int v2; // eax

  v1 = sub_80E95A8();
  v2 = sub_80E9270(v1);
  a1[54] = 21;
  a1[13] = *(_DWORD *)(v2 + 708) + *(_DWORD *)(dword_85760F4 + 8);
  a1[14] = 0;
  sub_80DED2E((int)a1, 172);
  return sub_80E9210((int)a1, 0);
}
// 85760F4: using guessed type int dword_85760F4;

//----- (080EDA78) --------------------------------------------------------
int __cdecl sub_80EDA78(int a1)
{
  int result; // eax
  _DWORD *v2; // [esp+10h] [ebp-8h]

  v2 = *(_DWORD **)a1;
  v2[54] = 22;
  sub_80ED87A((int)v2);
  if ( *(_BYTE *)(a1 + 12) )
  {
    v2[13] = *(_DWORD *)(sub_80E9270(v2[53]) + 580);
    v2[14] = 0;
    result = sub_80E9210((int)v2, 18);
  }
  else
  {
    v2[13] = 0;
    result = (int)v2;
    v2[14] = 1;
  }
  return result;
}

//----- (080EDB00) --------------------------------------------------------
_DWORD *__cdecl sub_80EDB00(int a1)
{
  _DWORD *result; // eax
  unsigned __int8 v2; // [esp+Ch] [ebp-1Ch]
  char v3; // [esp+Dh] [ebp-1Bh]
  unsigned __int8 v4; // [esp+Eh] [ebp-1Ah]
  char v5; // [esp+Fh] [ebp-19h]
  char v6; // [esp+10h] [ebp-18h]
  char v7; // [esp+11h] [ebp-17h]
  char v8; // [esp+12h] [ebp-16h]
  char v9; // [esp+13h] [ebp-15h]
  int v10; // [esp+14h] [ebp-14h]
  unsigned __int8 v11; // [esp+1Dh] [ebp-Bh]
  char v12; // [esp+1Eh] [ebp-Ah]
  char v13; // [esp+1Fh] [ebp-9h]

  v10 = *(_DWORD *)a1;
  if ( *(_DWORD *)(*(_DWORD *)a1 + 216) > 16 && *(_DWORD *)(v10 + 216) <= 22
    || (*(float *)(v10 + 220) <= 0.0 || (result = (_DWORD *)sub_80E9270(*(_DWORD *)(v10 + 212)), !result[158]))
    && (result = (_DWORD *)(*(_DWORD *)(a1 + 8) & 0x30015)) == 0 )
  {
    result = (_DWORD *)v10;
    if ( *(_DWORD *)(v10 + 216) != 5 )
    {
      result = (_DWORD *)v10;
      if ( *(_DWORD *)(v10 + 216) != 7 )
      {
        result = (_DWORD *)v10;
        if ( *(_DWORD *)(v10 + 216) != 9 )
        {
          result = (_DWORD *)v10;
          if ( *(_DWORD *)(v10 + 216) != 8 )
          {
            result = (_DWORD *)v10;
            if ( *(_DWORD *)(v10 + 216) != 6 )
            {
              result = (_DWORD *)v10;
              if ( *(_DWORD *)(v10 + 216) != 3 )
              {
                result = (_DWORD *)v10;
                if ( *(_DWORD *)(v10 + 216) != 4 )
                {
                  result = (_DWORD *)v10;
                  if ( *(_DWORD *)(v10 + 216) != 10 )
                  {
                    result = (_DWORD *)v10;
                    if ( *(_DWORD *)(v10 + 216) != 11 )
                    {
                      result = (_DWORD *)v10;
                      if ( *(_DWORD *)(v10 + 216) != 10 )
                      {
                        result = (_DWORD *)v10;
                        if ( *(_DWORD *)(v10 + 216) != 11 )
                        {
                          result = (_DWORD *)v10;
                          if ( *(_DWORD *)(v10 + 216) != 1 )
                          {
                            result = (_DWORD *)v10;
                            if ( *(_DWORD *)(v10 + 216) != 2 )
                            {
                              if ( *(_DWORD *)(v10 + 216) <= 11 || (result = (_DWORD *)v10, *(_DWORD *)(v10 + 216) > 16) )
                              {
                                v9 = 0;
                                if ( *(_DWORD *)(v10 + 296)
                                  || *(_BYTE *)(a1 + 40) != *(_BYTE *)(a1 + 12)
                                  || *(_BYTE *)(a1 + 41) != *(_BYTE *)(a1 + 13)
                                  || *(_DWORD *)(a1 + 8) & 0x30015 )
                                {
                                  v9 = 1;
                                }
                                if ( *(_DWORD *)(v10 + 216) > 16 && *(_DWORD *)(v10 + 216) <= 22 && v9 )
                                {
                                  sub_80ED212((_DWORD *)v10);
                                  result = (_DWORD *)(*(_DWORD *)(a1 + 8) & 1);
                                  if ( (_BYTE)result )
                                  {
                                    result = (_DWORD *)v10;
                                    *(_DWORD *)(v10 + 52) = 1;
                                  }
                                }
                                else
                                {
                                  result = (_DWORD *)(*(_DWORD *)(a1 + 8) & 1);
                                  if ( !(_BYTE)result )
                                  {
                                    if ( *(_DWORD *)(v10 + 216) == 20 )
                                    {
                                      v8 = 0;
                                      if ( !(*(_DWORD *)(a1 + 36) & 0x28) && *(_DWORD *)(a1 + 8) & 0x28 )
                                        v8 = 1;
                                      v7 = 0;
                                      if ( *(_DWORD *)(a1 + 36) & 0x28 && !(*(_DWORD *)(a1 + 8) & 0x28) )
                                        v7 = 1;
                                      if ( v8 )
                                      {
                                        sub_80DED2E(v10, 170);
                                      }
                                      else if ( v7 )
                                      {
                                        sub_80DED2E(v10, 171);
                                      }
                                    }
                                    if ( *(_BYTE *)(dword_85760EC + 8) )
                                    {
                                      v6 = 0;
                                      if ( !(*(_DWORD *)(a1 + 36) & 0x4000) && *(_DWORD *)(a1 + 8) & 0x4000 )
                                        v6 = 1;
                                      v5 = 0;
                                      if ( v6 && (*(_DWORD *)(v10 + 216) <= 16 || *(_DWORD *)(v10 + 216) > 22) )
                                        v5 = 1;
                                      v12 = v5;
                                      v4 = 0;
                                      if ( v6 && *(_DWORD *)(v10 + 216) > 17 && *(_DWORD *)(v10 + 216) <= 20 )
                                        v4 = 1;
                                      result = (_DWORD *)v4;
                                      v11 = v4;
                                    }
                                    else
                                    {
                                      v13 = (*(_DWORD *)(a1 + 8) >> 14) & 1;
                                      v3 = 0;
                                      if ( v13 && (*(_DWORD *)(v10 + 216) <= 16 || *(_DWORD *)(v10 + 216) > 22) )
                                        v3 = 1;
                                      v12 = v3;
                                      v2 = 0;
                                      if ( !v13 && *(_DWORD *)(v10 + 216) > 17 && *(_DWORD *)(v10 + 216) <= 20 )
                                        v2 = 1;
                                      result = (_DWORD *)v2;
                                      v11 = v2;
                                    }
                                    if ( v12 )
                                    {
                                      result = (_DWORD *)sub_80E95A8();
                                      if ( result )
                                      {
                                        if ( *(_BYTE *)(a1 + 12) )
                                        {
                                          if ( *(_DWORD *)(a1 + 8) & 0x1000 )
                                            result = sub_80ED8D2((_DWORD *)v10);
                                          else
                                            result = (_DWORD *)sub_80ED928((_DWORD *)v10);
                                        }
                                        else
                                        {
                                          result = (_DWORD *)sub_80ED97E((_DWORD *)v10);
                                        }
                                      }
                                    }
                                    else if ( v11 )
                                    {
                                      if ( *(_DWORD *)(v10 + 216) == 18 )
                                        result = (_DWORD *)sub_80EDA78(a1);
                                      else
                                        result = (_DWORD *)sub_80EDA06((_DWORD *)v10);
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  return result;
}
// 85760EC: using guessed type int dword_85760EC;

//----- (080EDF3A) --------------------------------------------------------
float *__cdecl sub_80EDF3A(int a1, int a2)
{
  float *result; // eax
  int v3; // [esp+10h] [ebp-8h]
  int v4; // [esp+14h] [ebp-4h]

  v3 = *(_DWORD *)a1;
  result = (float *)(*(_DWORD *)(*(_DWORD *)a1 + 12) & 0x1000);
  if ( !result )
  {
    if ( *(_DWORD *)(v3 + 4) <= 5 )
    {
      result = (float *)(*(_DWORD *)(v3 + 160) & 0x300);
      if ( !result )
      {
        sub_80EA568((float **)a1, a2);
        sub_80EA950((float **)a1, a2);
        result = (float *)sub_80ED780((_DWORD *)v3, a2);
        if ( !(_BYTE)result )
        {
          v4 = sub_80EC560((_BYTE *)a1, a2);
          sub_80EDB00(a1);
          sub_80ED5AE((int *)a1);
          sub_80EC7D2((unsigned __int8 *)a1);
          sub_80EBFF0(a1);
          sub_80ED01A((int *)a1, v4);
          result = (float *)sub_80EAF58(v3, v4);
          if ( !result )
          {
            if ( *(_BYTE *)(v3 + 12) & 1 && (*(_BYTE *)(a1 + 28) || *(_BYTE *)(a1 + 29))
              || *(_DWORD *)(v3 + 216) == 10
              || *(_DWORD *)(v3 + 216) == 11 )
            {
              *(_DWORD *)(v3 + 1492) = 1132396544;
            }
            if ( v4 || (result = (float *)v3, !*(_DWORD *)(v3 + 52)) && (result = (float *)v3, !*(_DWORD *)(v3 + 56)) )
            {
              result = *(float **)(v3 + 216);
              switch ( (unsigned int)result )
              {
                case 0u:
                case 3u:
                case 4u:
                  result = (float *)v3;
                  if ( *(_DWORD *)(v3 + 212) )
                  {
                    result = (float *)sub_80ECA14((_BYTE *)a1, v4);
                    if ( !result )
                      result = (float *)sub_80ECE56((_DWORD *)v3, v4);
                  }
                  break;
                case 1u:
                  result = (float *)sub_80EBA76(v3);
                  break;
                case 2u:
                  result = (float *)sub_80EB738((unsigned __int8 *)a1);
                  break;
                case 5u:
                case 6u:
                  result = (float *)sub_80EBE96((_DWORD *)v3, v4);
                  break;
                case 7u:
                case 8u:
                  result = (float *)sub_80EBD80((_DWORD *)v3, v4);
                  break;
                case 9u:
                  result = (float *)sub_80EBFC8(v3);
                  break;
                case 0xAu:
                  result = (float *)sub_80ECF70((_DWORD *)v3);
                  break;
                case 0xBu:
                  result = (float *)sub_80ECFF2(v3);
                  break;
                case 0xCu:
                  result = (float *)sub_80ED2F2((_DWORD *)v3);
                  break;
                case 0xDu:
                  result = (float *)sub_80ED382((_DWORD *)v3);
                  break;
                case 0xEu:
                  result = (float *)sub_80ED3DE((int *)a1);
                  break;
                case 0xFu:
                  result = (float *)sub_80ED50A((_DWORD *)v3);
                  break;
                case 0x10u:
                  result = (float *)sub_80ED212((_DWORD *)v3);
                  break;
                case 0x11u:
                  result = (float *)sub_80ED928((_DWORD *)v3);
                  break;
                case 0x12u:
                  result = (float *)sub_80ED97E((_DWORD *)v3);
                  break;
                case 0x13u:
                  result = (float *)sub_80ED9E0((_DWORD *)v3);
                  break;
                case 0x14u:
                  return result;
                case 0x15u:
                  result = (float *)sub_80EDA78(a1);
                  break;
                case 0x16u:
                  result = (float *)sub_80ED212((_DWORD *)v3);
                  break;
              }
            }
          }
        }
      }
    }
    else
    {
      result = *(float **)a1;
      *(_DWORD *)(v3 + 212) = 0;
    }
  }
  return result;
}

//----- (080EE212) --------------------------------------------------------
int __cdecl sub_80EE212(_DWORD *a1)
{
  return sub_80ED212(a1);
}

//----- (080EE226) --------------------------------------------------------
int __cdecl sub_80EE226(int a1, float *a2, int a3)
{
  int v3; // ST30_4
  float v4; // ST28_4
  float v5; // ST24_4
  float v6; // ST20_4
  float v7; // ST1C_4
  float v8; // ST3C_4
  float v9; // ST38_4
  float v10; // ST18_4
  float v11; // ST14_4
  float v12; // ST10_4
  float v13; // ST0C_4
  float v14; // ST3C_4
  float v15; // ST38_4
  int result; // eax
  float v17; // [esp+2Ch] [ebp-1Ch]
  float v18; // [esp+34h] [ebp-14h]
  float v19; // [esp+38h] [ebp-10h]
  float v20; // [esp+38h] [ebp-10h]
  float v21; // [esp+3Ch] [ebp-Ch]
  float v22; // [esp+3Ch] [ebp-Ch]
  float *v23; // [esp+40h] [ebp-8h]

  v3 = sub_80E95EE((_DWORD *)a1);
  v23 = (float *)sub_80E9270(v3);
  v18 = *(float *)(a1 + 220);
  v17 = 1.0;
  if ( *(_DWORD *)(a1 + 64) > 0 )
  {
    if ( v18 == 1.0 )
      v17 = v23[287] * 0.0099999998;
    else
      v17 = v23[305] * 0.0099999998;
  }
  if ( v18 == 1.0 )
  {
    v4 = v23[297] - v23[296];
    v21 = sub_80A1410() * v4 + v23[296];
    v5 = v23[299] - v23[298];
    v19 = sub_80A1410() * v5 + v23[298];
  }
  else
  {
    v6 = v23[315] - v23[314];
    v21 = sub_80A1410() * v6 + v23[314];
    v7 = v23[317] - v23[316];
    v19 = sub_80A1410() * v7 + v23[316];
  }
  v8 = v21 * v17;
  v9 = v19 * v17;
  *(_DWORD *)a3 = LODWORD(v8) ^ 0x80000000;
  *(float *)(a3 + 4) = v9;
  *(float *)(a3 + 8) = *(float *)(a3 + 4) * -0.5;
  if ( v18 <= 0.0 )
  {
    v12 = v23[307] - v23[306];
    v22 = sub_80A1410() * v12 + v23[306];
    v13 = v23[309] - v23[308];
    v20 = sub_80A1410() * v13 + v23[308];
  }
  else
  {
    v10 = v23[289] - v23[288];
    v22 = sub_80A1410() * v10 + v23[288];
    v11 = v23[291] - v23[290];
    v20 = sub_80A1410() * v11 + v23[290];
  }
  v14 = v22 * v17;
  v15 = v20 * v17;
  *a2 = *a2 + v14;
  result = (int)(a2 + 1);
  a2[1] = a2[1] + v15;
  return result;
}

//----- (080EE4AA) --------------------------------------------------------
long double __cdecl sub_80EE4AA(int a1)
{
  return (float)((long double)*(unsigned __int8 *)(a1 + 8) / 255.0 * 3.141592653589793
               + (long double)*(unsigned __int8 *)(a1 + 8) / 255.0 * 3.141592653589793
               + 6.283185307179586);
}

//----- (080EE506) --------------------------------------------------------
long double __cdecl sub_80EE506(int a1, float a2, float a3, float a4)
{
  long double v4; // fst7
  float v5; // ST0C_4
  float v6; // ST10_4
  float v7; // ST0C_4
  float v8; // ST0C_4
  float v11; // [esp+14h] [ebp-4h]

  if ( *(_DWORD *)(a1 + 244) == 11 )
  {
    v11 = a3 * *(float *)(dword_85760C0 + 8);
  }
  else
  {
    if ( *(_DWORD *)(a1 + 244) == 40 )
      v4 = a3 * *(float *)(dword_85760BC + 8);
    else
      v4 = a3 * *(float *)(dword_85760B8 + 8);
    v11 = v4;
  }
  if ( v11 > (long double)a4 )
    v11 = a4;
  v5 = sin(a2 + a2);
  v6 = sin(a2 * 4.0 + 1.570796326794897);
  v7 = v6 * 0.2 + v5;
  v8 = 0.75 * v7;
  return (float)(v8 * v11);
}
// 85760B8: using guessed type int dword_85760B8;
// 85760BC: using guessed type int dword_85760BC;
// 85760C0: using guessed type int dword_85760C0;

//----- (080EE5C6) --------------------------------------------------------
long double __cdecl sub_80EE5C6(int a1, float a2, float a3, float a4)
{
  long double v4; // fst7
  float v5; // ST10_4
  float v7; // [esp+14h] [ebp-4h]

  if ( *(_DWORD *)(a1 + 244) == 11 )
  {
    v7 = a3 * *(float *)(dword_85760C0 + 8);
  }
  else
  {
    if ( *(_DWORD *)(a1 + 244) == 40 )
      v4 = a3 * *(float *)(dword_85760BC + 8);
    else
      v4 = a3 * *(float *)(dword_85760B8 + 8);
    v7 = v4;
  }
  if ( v7 > (long double)a4 )
    v7 = a4;
  v5 = sin(a2);
  return v5 * v7;
}
// 85760B8: using guessed type int dword_85760B8;
// 85760BC: using guessed type int dword_85760BC;
// 85760C0: using guessed type int dword_85760C0;

//----- (080EE640) --------------------------------------------------------
void __cdecl sub_80EE640(_DWORD **a1, float *a2)
{
  int v2; // ST14_4
  long double v3; // fst7
  float v4; // ST04_4
  int v5; // [esp+18h] [ebp-30h]
  float *v6; // [esp+1Ch] [ebp-2Ch]
  int v7[4]; // [esp+20h] [ebp-28h]
  float v8; // [esp+30h] [ebp-18h]
  float v9; // [esp+34h] [ebp-14h]
  float v10; // [esp+38h] [ebp-10h]
  int i; // [esp+3Ch] [ebp-Ch]

  v6 = (float *)*a1;
  v2 = sub_80E95EE(*a1);
  v5 = sub_80E9270(v2);
  if ( (_DWORD)v6[40] & 8 )
  {
    v8 = *(float *)(v5 + 432);
  }
  else if ( (_DWORD)v6[40] & 4 )
  {
    v8 = *(float *)(v5 + 428);
  }
  else
  {
    v8 = *(float *)(v5 + 424);
  }
  if ( *((float *)a1 + 1) <= (long double)v8 || *((_DWORD *)v6 + 54) == 5 )
  {
    sub_80F028C(v7);
  }
  else
  {
    v3 = (*((float *)a1 + 1) - v8) / ((long double)*((signed int *)v6 + 20) - v8);
    v10 = v3;
    sub_80F01B2(0.0, v10);
    v4 = v3;
    sub_80F01D6(1.0, v4);
    v10 = v3;
    if ( (_DWORD)v6[40] & 8 )
    {
      sub_80F032A(v5 + 384, v10, (int)v7);
    }
    else if ( (_DWORD)v6[40] & 4 )
    {
      sub_80F032A(v5 + 348, v10, (int)v7);
    }
    else
    {
      sub_80F032A(v5 + 312, v10, (int)v7);
    }
  }
  if ( v6[55] != 0.0 )
  {
    v9 = 1.0 - v6[55];
    sub_80F032A((int)v7, v9, (int)v7);
  }
  for ( i = 0; i <= 2; ++i )
  {
    if ( *(float *)&a1[i + 3] != *(float *)&v7[i] )
    {
      if ( v6[62] == 11.0 )
        v9 = (*(float *)&v7[i] - *(float *)&a1[i + 3]) * *((float *)a1 + 2) * *(float *)(v5 + 420);
      else
        v9 = (*(float *)&v7[i] - *(float *)&a1[i + 3]) * *((float *)a1 + 2) * *(float *)(v5 + 416);
      if ( *(float *)&v7[i] <= (long double)*(float *)&a1[i + 3] )
      {
        if ( v9 > *((float *)a1 + 2) * -0.1 )
          v9 = *((float *)a1 + 2) * -0.1;
        *(float *)&a1[i + 3] = *(float *)&a1[i + 3] + v9;
        if ( *(float *)&v7[i] > (long double)*(float *)&a1[i + 3] )
          a1[i + 3] = (_DWORD *)v7[i];
      }
      else
      {
        if ( *((float *)a1 + 2) * 0.1 > v9 )
          v9 = *((float *)a1 + 2) * 0.1;
        *(float *)&a1[i + 3] = *(float *)&a1[i + 3] + v9;
        if ( *(float *)&a1[i + 3] > (long double)*(float *)&v7[i] )
          a1[i + 3] = (_DWORD *)v7[i];
      }
    }
  }
  if ( v6[55] == 0.0 )
  {
    sub_80F02E6(a2, (float *)a1 + 3, a2);
  }
  else if ( v6[55] < 0.5 )
  {
    v9 = 1.0 - (v6[55] + v6[55]);
    sub_80F0362((int)a2, v9, (int)(a1 + 3), (int)a2);
  }
}
// 80EE640: using guessed type int var_28[4];

//----- (080EEA0C) --------------------------------------------------------
void __cdecl sub_80EEA0C(float **a1, float *a2)
{
  int v2; // ST08_4
  int v3; // [esp+Ch] [ebp-Ch]
  float *v4; // [esp+10h] [ebp-8h]

  v4 = *a1;
  v2 = sub_80E95EE(*a1);
  v3 = sub_80E9270(v2);
  if ( sub_80E973E(v2) )
    *a2 = v4[55] * *(float *)(v3 + 1132) + *a2;
  sub_80EE640((_DWORD **)a1, a2);
}

//----- (080EEA7C) --------------------------------------------------------
float *__cdecl sub_80EEA7C(float **a1, float *a2)
{
  int v2; // ST18_4
  float v3; // ST2C_4
  float v4; // ST2C_4
  float v5; // ST2C_4
  float *result; // eax
  float v7; // [esp+14h] [ebp-24h]
  float *v8; // [esp+1Ch] [ebp-1Ch]
  float v9; // [esp+24h] [ebp-14h]
  float v10; // [esp+28h] [ebp-10h]
  float v11; // [esp+28h] [ebp-10h]
  int v12; // [esp+30h] [ebp-8h]

  v8 = *a1;
  v2 = sub_80E95EE(*a1);
  v12 = sub_80E9270(v2);
  if ( sub_80E973E(v2) )
  {
    v10 = (*(float *)(v12 + 712) - *(float *)(v12 + 716)) * v8[55] + *(float *)(v12 + 716);
    v7 = (*(float *)(v12 + 720) - *(float *)(v12 + 724)) * v8[55] + *(float *)(v12 + 724);
  }
  else if ( *(float *)(v12 + 716) == 0.0 )
  {
    v10 = 80.0;
    v7 = 1.0;
  }
  else
  {
    v10 = *(float *)(v12 + 716);
    v7 = *(float *)(v12 + 724);
  }
  if ( (_DWORD)v8[40] & 8 )
  {
    v9 = *(float *)(v12 + 732);
  }
  else if ( (_DWORD)v8[40] & 4 )
  {
    v9 = *(float *)(v12 + 728);
  }
  else
  {
    v9 = 1.0;
  }
  if ( (!*(_DWORD *)(v12 + 632) || v8[55] == 0.0) && v9 != *((float *)a1 + 6) )
  {
    if ( v9 <= (long double)*((float *)a1 + 6) )
    {
      *((float *)a1 + 6) = *((float *)a1 + 6) - *((float *)a1 + 2) * 0.5;
      if ( v9 > (long double)*((float *)a1 + 6) )
        *((float *)a1 + 6) = v9;
    }
    else
    {
      *((float *)a1 + 6) = *((float *)a1 + 2) * 0.5 + *((float *)a1 + 6);
      if ( *((float *)a1 + 6) > (long double)v9 )
        *((float *)a1 + 6) = v9;
    }
  }
  v11 = v10 * *((float *)a1 + 6);
  if ( *(_DWORD *)(v12 + 632) )
    v11 = (1.0 - v8[55]) * v11;
  *(_DWORD *)a1[20] += (signed int)(*((float *)a1 + 2) * 1000.0 * v7);
  v3 = sin((long double)*(signed int *)a1[20] * 0.00050000002);
  a2[2] = v11 * v3 * 0.0099999998 + a2[2];
  v4 = sin((long double)*(signed int *)a1[20] * 0.00069999998);
  a2[1] = v11 * v4 * 0.0099999998 + a2[1];
  v5 = sin((long double)*(signed int *)a1[20] * 0.001);
  result = a2;
  *a2 = v11 * v5 * 0.0099999998 + *a2;
  return result;
}

//----- (080EED76) --------------------------------------------------------
int __cdecl sub_80EED76(float **a1, float *a2)
{
  float *v2; // ST3C_4
  int v3; // ST34_4
  float v4; // ST40_4
  float v5; // ST20_4
  float v6; // ST20_4
  long double v7; // fst7
  float v8; // ST04_4
  float v9; // ST08_4
  int v11; // [esp+34h] [ebp-34h]
  int v12; // [esp+40h] [ebp-28h]
  float v13; // [esp+44h] [ebp-24h]
  float v14; // [esp+48h] [ebp-20h]
  float v15; // [esp+54h] [ebp-14h]
  float v16; // [esp+58h] [ebp-10h]
  float v17; // [esp+5Ch] [ebp-Ch]

  v2 = *a1;
  v3 = sub_80E95EE(*a1);
  v11 = sub_80E9270(v3);
  v4 = (long double)*((unsigned __int8 *)v2 + 8) / 255.0 * 3.141592653589793
     + (long double)*((unsigned __int8 *)v2 + 8) / 255.0 * 3.141592653589793
     + 6.283185307179586;
  v16 = v4 + 0.7853981633974483 + 6.283185307179586;
  v15 = *((float *)a1 + 1) * 0.16;
  v5 = sub_80EE506((int)v2, v16, v15, 10.0);
  v12 = LODWORD(v5) ^ 0x80000000;
  v6 = sub_80EE5C6((int)v2, v16, v15, 10.0);
  LODWORD(v13) = LODWORD(v6) ^ 0x80000000;
  v16 = v16 - 0.4712389167638204;
  v15 = v15 * 1.5;
  v7 = sub_80EE5C6((int)v2, v16, v15, 10.0);
  v8 = v7;
  sub_80F01D6(v8, 0.0);
  v14 = v7;
  v17 = v2[55];
  if ( v17 != 0.0 )
  {
    v15 = 1.0 - (1.0 - *(float *)(v11 + 644)) * v17;
    *(float *)&v12 = *(float *)&v12 * v15;
    v13 = v13 * v15;
    v14 = v14 * v15;
  }
  if ( *(_DWORD *)(v11 + 632) )
  {
    v9 = 1.0 - v17;
    sub_80F032A((int)&v12, v9, (int)&v12);
  }
  return sub_80F02E6(a2, (float *)&v12, a2);
}

//----- (080EEF38) --------------------------------------------------------
void __cdecl sub_80EEF38(float **a1, float *a2)
{
  int v2; // ST10_4
  float v3; // ST28_4
  float v4; // ST28_4
  float v5; // ST28_4
  float v6; // ST04_4
  float v7; // ST28_4
  float v8; // ST28_4
  int v9; // [esp+10h] [ebp-18h]
  float *v10; // [esp+14h] [ebp-14h]
  float v11; // [esp+18h] [ebp-10h]
  float v12; // [esp+1Ch] [ebp-Ch]
  float v13; // [esp+20h] [ebp-8h]
  float v14; // [esp+24h] [ebp-4h]
  float v15; // [esp+24h] [ebp-4h]

  if ( a1[8] )
  {
    v10 = *a1;
    v2 = sub_80E95EE(*a1);
    v9 = sub_80E9270(v2);
    v13 = v10[55] * 0.5 + 0.5;
    v12 = v13 * 100.0;
    v11 = v13 * 400.0;
    if ( v10[55] != 0.0 && *(_DWORD *)(v9 + 632) )
      v13 = (1.0 - v10[55] * 0.75) * v13;
    v14 = (long double)((char *)a1[7] - (char *)a1[8]);
    if ( v12 <= (long double)v14 )
    {
      v15 = 1.0 - (v14 - v12) / v11;
      if ( v15 > 0.0 )
      {
        v6 = 1.0 - v15;
        v7 = 1.0 - sub_80B6688(v6);
        v8 = v7 * v13;
        *a2 = v8 * *((float *)a1 + 9) * 0.5 + *a2;
        a2[1] = a2[1] - v8 * *((float *)a1 + 10);
        a2[2] = v8 * *((float *)a1 + 10) * 0.5 + a2[2];
      }
    }
    else
    {
      v3 = v14 / v12;
      v4 = sub_80B6688(v3);
      v5 = v4 * v13;
      *a2 = v5 * *((float *)a1 + 9) * 0.5 + *a2;
      a2[1] = a2[1] - v5 * *((float *)a1 + 10);
      a2[2] = v5 * *((float *)a1 + 10) * 0.5 + a2[2];
    }
  }
}

//----- (080EF12E) --------------------------------------------------------
int __cdecl sub_80EF12E(int a1, int a2, float a3, float a4, float a5, float a6, float a7, float a8)
{
  signed int v9; // [esp+14h] [ebp-4h]

  v9 = 0;
  if ( sub_80F0198(*(float *)a1) >= 0.25 || sub_80F0198(*(float *)a2) >= 1.0 )
  {
    *(float *)a1 = *(float *)a2 * a3 + *(float *)a1;
    if ( *(float *)a1 <= (long double)a4 )
    {
      if ( -a4 > (long double)*(float *)a1 )
      {
        *(_DWORD *)a1 = LODWORD(a4) ^ 0x80000000;
        if ( *(float *)a2 < 0.0 )
          *(_DWORD *)a2 = 0;
      }
    }
    else
    {
      *(float *)a1 = a4;
      if ( *(float *)a2 > 0.0 )
        *(_DWORD *)a2 = 0;
    }
    if ( *(float *)a1 <= 0.0 )
    {
      if ( *(float *)a1 < 0.0 )
        *(float *)a2 = a5 * a3 + *(float *)a2;
    }
    else
    {
      *(float *)a2 = *(float *)a2 - a5 * a3;
    }
    *(float *)a2 = *(float *)a2 - *(float *)a2 * a7 * a3;
    if ( *(float *)a2 <= 0.0 )
    {
      *(float *)a2 = a8 * a3 + *(float *)a2;
      if ( *(float *)a2 > 0.0 )
        *(_DWORD *)a2 = 0;
    }
    else
    {
      *(float *)a2 = *(float *)a2 - a8 * a3;
      if ( *(float *)a2 < 0.0 )
        *(_DWORD *)a2 = 0;
    }
    if ( *(float *)a2 <= (long double)a6 )
    {
      if ( -a6 > (long double)*(float *)a2 )
        *(_DWORD *)a2 = LODWORD(a6) ^ 0x80000000;
    }
    else
    {
      *(float *)a2 = a6;
    }
  }
  else
  {
    *(_DWORD *)a1 = 0;
    *(_DWORD *)a2 = 0;
    v9 = 1;
  }
  return v9;
}

//----- (080EF336) --------------------------------------------------------
int __cdecl sub_80EF336(_DWORD **a1, float *a2)
{
  int v2; // ST2C_4
  int result; // eax
  float v4; // ST38_4
  int v5; // eax
  float *v6; // [esp+30h] [ebp-28h]
  float *v7; // [esp+34h] [ebp-24h]
  float v8; // [esp+3Ch] [ebp-1Ch]
  float v9; // [esp+40h] [ebp-18h]
  float v10; // [esp+44h] [ebp-14h]
  float v11; // [esp+48h] [ebp-10h]
  int v12; // [esp+4Ch] [ebp-Ch]
  float v13; // [esp+50h] [ebp-8h]
  float v14; // [esp+54h] [ebp-4h]

  v7 = (float *)*a1;
  v2 = sub_80E95EE(*a1);
  v6 = (float *)sub_80E9270(v2);
  result = sub_80E973E(v2);
  if ( result )
  {
    v4 = v7[55];
    v11 = (v6[292] - v6[310]) * v4 + v6[310];
    v10 = (v6[293] - v6[311]) * v4 + v6[311];
    v9 = (v6[294] - v6[312]) * v4 + v6[312];
    v8 = (v6[295] - v6[313]) * v4 + v6[313];
    v14 = *((float *)a1 + 2);
    while ( v14 > 0.0 )
    {
      if ( v14 <= 0.005 )
      {
        v13 = v14;
        v14 = 0.0;
        v5 = sub_80EF12E((int)(a1 + 11), (int)(a1 + 14), v13, v6[184], v11, v10, v9, v8);
      }
      else
      {
        v13 = 0.0049999999;
        v14 = v14 - 0.005;
        v5 = sub_80EF12E((int)(a1 + 11), (int)(a1 + 14), 0.0049999999, v6[184], v11, v10, v9, v8);
      }
      v12 = v5;
      if ( sub_80EF12E((int)(a1 + 12), (int)(a1 + 15), v13, v6[185], v11, v10, v9, v8) )
      {
        if ( v12 )
          break;
      }
    }
    result = sub_80F02E6(a2, (float *)a1 + 11, a2);
  }
  return result;
}

//----- (080EF52C) --------------------------------------------------------
int __cdecl sub_80EF52C(int a1, int a2)
{
  float v2; // ST14_4
  long double v3; // fst7
  int result; // eax
  float *v5; // [esp+10h] [ebp-8h]

  v5 = *(float **)a1;
  sub_80F028C((_DWORD *)a2);
  if ( v5[19] != 0.0 )
  {
    v2 = sub_80B6688(v5[19]);
    *(float *)(a2 + 8) = *(float *)(a2 + 8) - (v2 + v2);
  }
  sub_80EEA0C((float **)a1, (float *)a2);
  sub_80EEA7C((float **)a1, (float *)a2);
  sub_80EED76((float **)a1, (float *)a2);
  sub_80EEF38((float **)a1, (float *)a2);
  sub_80EF336((_DWORD **)a1, (float *)a2);
  *(float *)a2 = sub_80A6000(*(float *)a2, *(float *)(a1 + 68));
  v3 = sub_80A6000(*(float *)(a2 + 4), *(float *)(a1 + 72));
  result = a2 + 4;
  *(float *)(a2 + 4) = v3;
  return result;
}

//----- (080EF61E) --------------------------------------------------------
void __cdecl sub_80EF61E(float **a1, float *a2)
{
  int v2; // ST08_4
  float v3; // ST18_4
  float v4; // ST18_4
  float v5; // ST18_4
  float v6; // ST04_4
  float v7; // ST18_4
  float v8; // ST18_4
  int v9; // [esp+8h] [ebp-10h]
  float *v10; // [esp+Ch] [ebp-Ch]
  float v11; // [esp+10h] [ebp-8h]
  float v12; // [esp+14h] [ebp-4h]
  float v13; // [esp+14h] [ebp-4h]

  if ( a1[1] )
  {
    v10 = *a1;
    v2 = sub_80E95EE(*a1);
    v9 = sub_80E9270(v2);
    v11 = 1.0 - v10[55] * 0.5;
    if ( v10[55] != 0.0 && *(_DWORD *)(v9 + 632) )
      v11 = (v10[55] * 0.5 + 1.0) * v11;
    v12 = (long double)((char *)a1[2] - (char *)a1[1]);
    if ( v12 >= 100.0 )
    {
      v13 = 1.0 - (v12 - 100.0) / 400.0;
      if ( v13 > 0.0 )
      {
        v6 = 1.0 - v13;
        v7 = 1.0 - sub_80B6688(v6);
        v8 = v7 * v11;
        *a2 = v8 * *((float *)a1 + 3) + *a2;
        a2[2] = v8 * *((float *)a1 + 4) + a2[2];
      }
    }
    else
    {
      v3 = v12 / 100.0;
      v4 = sub_80B6688(v3);
      v5 = v4 * v11;
      *a2 = v5 * *((float *)a1 + 3) + *a2;
      a2[2] = v5 * *((float *)a1 + 4) + a2[2];
    }
  }
}

//----- (080EF7AA) --------------------------------------------------------
int __cdecl sub_80EF7AA(float **a1, float *a2)
{
  int v2; // eax
  int result; // eax
  float v4; // ST28_4
  float v5; // ST28_4
  float v6; // ST28_4
  float v7; // ST2C_4
  float v8; // ST2C_4
  float v9; // [esp+14h] [ebp-24h]
  int v10; // [esp+18h] [ebp-20h]
  float *v11; // [esp+1Ch] [ebp-1Ch]
  float v12; // [esp+24h] [ebp-14h]
  float v13; // [esp+28h] [ebp-10h]
  int v14; // [esp+30h] [ebp-8h]

  v11 = *a1;
  v2 = sub_80E95EE(*a1);
  v10 = v2;
  result = sub_80E9270(v2);
  v14 = result;
  if ( *(_DWORD *)(result + 632) )
  {
    if ( sub_80E973E(v10) )
    {
      v13 = (*(float *)(v14 + 712) - *(float *)(v14 + 716)) * v11[55] + *(float *)(v14 + 716);
      v9 = (*(float *)(v14 + 720) - *(float *)(v14 + 724)) * v11[55] + *(float *)(v14 + 724);
    }
    else if ( *(float *)(v14 + 716) == 0.0 )
    {
      v13 = 80.0;
      v9 = 1.0;
    }
    else
    {
      v13 = *(float *)(v14 + 716);
      v9 = *(float *)(v14 + 724);
    }
    if ( (_DWORD)v11[40] & 8 )
    {
      v12 = *(float *)(v14 + 732);
    }
    else if ( (_DWORD)v11[40] & 4 )
    {
      v12 = *(float *)(v14 + 728);
    }
    else
    {
      v12 = 1.0;
    }
    if ( *(_DWORD *)(v14 + 632) && v11[55] != 0.0 && v12 != *((float *)a1 + 7) )
    {
      if ( v12 <= (long double)*((float *)a1 + 7) )
      {
        *((float *)a1 + 7) = *((float *)a1 + 7) - *((float *)a1 + 6) * 0.5;
        if ( v12 > (long double)*((float *)a1 + 7) )
          *((float *)a1 + 7) = v12;
      }
      else
      {
        *((float *)a1 + 7) = *((float *)a1 + 6) * 0.5 + *((float *)a1 + 7);
        if ( *((float *)a1 + 7) > (long double)v12 )
          *((float *)a1 + 7) = v12;
      }
    }
    v4 = v13 * *((float *)a1 + 7);
    v5 = v4 * v11[55];
    v6 = v5 * v11[365];
    *(_DWORD *)a1[8] += (signed int)(v11[365] * *((float *)a1 + 6) * 1000.0 * v9);
    v7 = sin((long double)*(signed int *)a1[8] * 0.00069999998);
    a2[1] = v6 * v7 * 0.0099999998 + a2[1];
    v8 = sin((long double)*(signed int *)a1[8] * 0.001);
    result = (int)a2;
    *a2 = v6 * v8 * 0.0099999998 + *a2;
  }
  return result;
}

//----- (080EFA86) --------------------------------------------------------
int __cdecl sub_80EFA86(float **a1, float *a2)
{
  int v2; // eax
  int result; // eax
  float v4; // ST40_4
  float v5; // ST20_4
  float v6; // ST20_4
  long double v7; // fst7
  float v8; // ST04_4
  int v9; // [esp+34h] [ebp-34h]
  float *v10; // [esp+38h] [ebp-30h]
  int v11; // [esp+40h] [ebp-28h]
  float v12; // [esp+44h] [ebp-24h]
  float v13; // [esp+48h] [ebp-20h]
  float v14; // [esp+54h] [ebp-14h]
  float v15; // [esp+58h] [ebp-10h]
  float v16; // [esp+5Ch] [ebp-Ch]

  v10 = *a1;
  v2 = sub_80E95EE(*a1);
  result = sub_80E9270(v2);
  v9 = result;
  if ( *(_DWORD *)(result + 632) )
  {
    v4 = (long double)*((unsigned __int8 *)v10 + 8) / 255.0 * 3.141592653589793
       + (long double)*((unsigned __int8 *)v10 + 8) / 255.0 * 3.141592653589793
       + 6.283185307179586;
    v15 = v4 + 0.7853981633974483 + 6.283185307179586;
    v14 = *((float *)a1 + 5) * 0.16;
    v5 = sub_80EE506((int)v10, v15, v14, 10.0);
    v11 = LODWORD(v5) ^ 0x80000000;
    v6 = sub_80EE5C6((int)v10, v15, v14, 10.0);
    LODWORD(v12) = LODWORD(v6) ^ 0x80000000;
    v15 = v15 - 0.4712389167638204;
    v14 = v14 * 1.5;
    v7 = sub_80EE5C6((int)v10, v15, v14, 10.0);
    v8 = v7;
    sub_80F01D6(v8, 0.0);
    v13 = v7;
    v16 = v10[55];
    if ( v16 != 0.0 )
    {
      v14 = 1.0 - (1.0 - *(float *)(v9 + 644)) * v16;
      *(float *)&v11 = *(float *)&v11 * v14;
      v12 = v12 * v14;
      v13 = v13 * v14;
    }
    sub_80F032A((int)&v11, v16, (int)&v11);
    result = sub_80F02E6(a2, (float *)&v11, a2);
  }
  return result;
}

//----- (080EFC4A) --------------------------------------------------------
void __cdecl sub_80EFC4A(_DWORD **a1, float *a2)
{
  int v2; // ST24_4
  float v3; // ST30_4
  float v4; // ST38_4
  float v5; // ST38_4
  float v6; // ST34_4
  float v7; // ST34_4
  int v8; // [esp+24h] [ebp-14h]
  float *v9; // [esp+28h] [ebp-10h]

  v9 = (float *)*a1;
  v2 = sub_80E95EE(*a1);
  v8 = sub_80E9270(v2);
  if ( !((_DWORD)v9[40] & 0x300) && v9[55] != 0.0 && *(float *)(v8 + 648) != 0.0 )
  {
    v3 = (long double)*((unsigned __int8 *)v9 + 8) / 255.0 * 3.141592653589793
       + (long double)*((unsigned __int8 *)v9 + 8) / 255.0 * 3.141592653589793
       + 6.283185307179586;
    v4 = sub_80EE506((int)v9, v3, *((float *)a1 + 5), 45.0);
    v5 = v9[55] * *(float *)(v8 + 648) * v4;
    *a2 = *a2 - v5;
    v6 = sub_80EE5C6((int)v9, v3, *((float *)a1 + 5), 45.0);
    v7 = v9[55] * *(float *)(v8 + 648) * v6;
    a2[1] = a2[1] - v7;
  }
}

//----- (080EFD94) --------------------------------------------------------
void __cdecl sub_80EFD94(float **a1, float *a2)
{
  sub_80F028C(a2);
  sub_80EF61E(a1, a2);
  sub_80EF7AA(a1, a2);
  sub_80EFA86(a1, a2);
  sub_80EFC4A((_DWORD **)a1, a2);
}

//----- (080EFDF0) --------------------------------------------------------
int __cdecl sub_80EFDF0(int a1, int a2, int a3, int a4, float a5, int a6)
{
  int result; // eax
  int v7; // ST1C_4
  float v8; // ST34_4
  float v9; // ST30_4
  float v10; // ST2C_4
  float v11; // ST28_4
  float v12; // ST04_4
  float v13; // ST44_4
  float v14; // ST48_4
  long double v15; // fst7
  float v16; // [esp+20h] [ebp-58h]
  float v17; // [esp+24h] [ebp-54h]
  float v18; // [esp+28h] [ebp-50h]
  float v19; // [esp+2Ch] [ebp-4Ch]
  float v20; // [esp+30h] [ebp-48h]
  float v21; // [esp+34h] [ebp-44h]
  float v22; // [esp+38h] [ebp-40h]
  float v23; // [esp+3Ch] [ebp-3Ch]
  float v24; // [esp+50h] [ebp-28h]
  float v25; // [esp+54h] [ebp-24h]
  int v26; // [esp+6Ch] [ebp-Ch]

  result = *(_DWORD *)(a1 + 220);
  v17 = *(float *)(a1 + 220);
  if ( a6 )
  {
    v7 = sub_80E95EE((_DWORD *)a1);
    v26 = sub_80E9270(v7);
    v16 = (long double)a6 * 0.001;
    if ( !sub_80E973E(v7) )
    {
      v23 = *(float *)(v26 + 744);
      v22 = *(float *)(v26 + 748);
      v21 = *(float *)(v26 + 752);
      v20 = *(float *)(v26 + 756);
      v19 = *(float *)(v26 + 760);
      v18 = *(float *)(v26 + 764);
      goto LABEL_7;
    }
    if ( v17 <= 0.0 || (result = v26, !*(_DWORD *)(v26 + 632)) )
    {
      v23 = (*(float *)(v26 + 772) - *(float *)(v26 + 744)) * v17 + *(float *)(v26 + 744);
      v22 = (*(float *)(v26 + 776) - *(float *)(v26 + 748)) * v17 + *(float *)(v26 + 748);
      v21 = (*(float *)(v26 + 780) - *(float *)(v26 + 752)) * v17 + *(float *)(v26 + 752);
      v20 = (*(float *)(v26 + 784) - *(float *)(v26 + 756)) * v17 + *(float *)(v26 + 756);
      v19 = (*(float *)(v26 + 788) - *(float *)(v26 + 760)) * v17 + *(float *)(v26 + 760);
      v18 = (*(float *)(v26 + 792) - *(float *)(v26 + 764)) * v17 + *(float *)(v26 + 764);
LABEL_7:
      v8 = v21 * a5;
      v9 = v20 * a5;
      v10 = v19 * a5;
      v11 = v18 * a5;
      sub_80A6062((float *)(a1 + 232), (float *)a2, &v24);
      v12 = 1.0 / (v16 * 60.0);
      sub_80F032A((int)&v24, v12, (int)&v24);
      v24 = sub_80F0220(v24, COERCE_FLOAT(LODWORD(v23) ^ 0x80000000), v23);
      v25 = sub_80F0220(v25, COERCE_FLOAT(LODWORD(v23) ^ 0x80000000), v23);
      v13 = v25 * v10;
      v14 = v24 * v11;
      *(float *)(a3 + 4) = sub_80A1986(v13, *(float *)(a3 + 4), v22, v16);
      *(float *)(a3 + 8) = sub_80A1986(v14, *(float *)(a3 + 8), v22, v16);
      v24 = v24 * v8;
      v15 = v25 * v9;
      v25 = v15;
      sub_80A1A02(v24, *(float *)a4, v22, v16);
      *(float *)a4 = v15;
      sub_80A1A02(v25, *(float *)(a4 + 4), v22, v16);
      *(float *)(a4 + 4) = v15;
      return sub_80F02B6((_DWORD *)(a1 + 232), (_DWORD *)a2);
    }
  }
  return result;
}

//----- (080F0110) --------------------------------------------------------
int __cdecl sub_80F0110(int a1, char *s)
{
  int v4; // [esp+14h] [ebp-4h]
  int v5; // [esp+14h] [ebp-4h]

  if ( !*s )
    return 0;
  v4 = sub_80F0C4E(a1, s);
  if ( v4 )
    return v4;
  v5 = sub_80F0C4E(a1, "defaultweapon_mp");
  if ( !v5 )
    Com_Error(1, &byte_814E800);
  sub_80F0B8E(v5, s);
  return v5;
}

//----- (080F0198) --------------------------------------------------------
long double __cdecl sub_80F0198(float a1)
{
  return (float)fabs(a1);
}

//----- (080F01B2) --------------------------------------------------------
void __cdecl sub_80F01B2(float a1, float a2)
{
  float v2; // ST00_4

  v2 = a1 - a2;
  sub_80F03B6(v2, a1, a2);
}

//----- (080F01D6) --------------------------------------------------------
void __cdecl sub_80F01D6(float a1, float a2)
{
  float v2; // ST00_4

  v2 = a2 - a1;
  sub_80F03B6(v2, a1, a2);
}

//----- (080F01FA) --------------------------------------------------------
int __cdecl sub_80F01FA(int a1, int a2)
{
  return sub_80F03E0(a1 - a2, a1, a2);
}

//----- (080F0220) --------------------------------------------------------
long double __cdecl sub_80F0220(float a1, float a2, float a3)
{
  float v3; // ST00_4
  float v4; // ST08_4
  float v5; // ST00_4

  v3 = a1 - a3;
  v4 = sub_80F03B6(v3, a3, a1);
  v5 = a2 - a1;
  return sub_80F03B6(v5, a2, v4);
}

//----- (080F025E) --------------------------------------------------------
long double __cdecl sub_80F025E(float a1)
{
  return a1 * a1;
}

//----- (080F026A) --------------------------------------------------------
long double __cdecl sub_80F026A(float *a1)
{
  return *a1 * *a1 + a1[1] * a1[1];
}

//----- (080F028C) --------------------------------------------------------
int __cdecl sub_80F028C(_DWORD *a1)
{
  int result; // eax

  *a1 = 0;
  a1[1] = 0;
  result = 0;
  a1[2] = 0;
  return result;
}

//----- (080F02B6) --------------------------------------------------------
int __cdecl sub_80F02B6(_DWORD *a1, _DWORD *a2)
{
  int result; // eax

  *a2 = *a1;
  a2[1] = a1[1];
  result = a1[2];
  a2[2] = result;
  return result;
}

//----- (080F02E6) --------------------------------------------------------
int __cdecl sub_80F02E6(float *a1, float *a2, float *a3)
{
  int result; // eax

  *a3 = *a1 + *a2;
  a3[1] = a1[1] + a2[1];
  result = (int)(a1 + 2);
  a3[2] = a1[2] + a2[2];
  return result;
}

//----- (080F032A) --------------------------------------------------------
int __cdecl sub_80F032A(int a1, float a2, int a3)
{
  int result; // eax

  *(float *)a3 = a2 * *(float *)a1;
  *(float *)(a3 + 4) = a2 * *(float *)(a1 + 4);
  result = a1 + 8;
  *(float *)(a3 + 8) = a2 * *(float *)(a1 + 8);
  return result;
}

//----- (080F0362) --------------------------------------------------------
int __cdecl sub_80F0362(int a1, float a2, int a3, int a4)
{
  int result; // eax

  *(float *)a4 = a2 * *(float *)a3 + *(float *)a1;
  *(float *)(a4 + 4) = a2 * *(float *)(a3 + 4) + *(float *)(a1 + 4);
  result = a3 + 8;
  *(float *)(a4 + 8) = a2 * *(float *)(a3 + 8) + *(float *)(a1 + 8);
  return result;
}

//----- (080F03B6) --------------------------------------------------------
long double __cdecl sub_80F03B6(float a1, float a2, float a3)
{
  float v4; // [esp+0h] [ebp-4h]

  if ( a1 < 0.0 )
    v4 = a3;
  else
    v4 = a2;
  return v4;
}

//----- (080F03E0) --------------------------------------------------------
int __cdecl sub_80F03E0(int a1, int a2, int a3)
{
  int v4; // [esp+0h] [ebp-4h]

  if ( a1 < 0 )
    v4 = a3;
  else
    v4 = a2;
  return v4;
}

//----- (080F0400) --------------------------------------------------------
int __cdecl sub_80F0400(int a1, int a2)
{
  int result; // eax

  result = *(_DWORD *)(a1 + 4 * (a2 >> 5)) & ~(1 << (a2 & 0x1F));
  *(_DWORD *)(a1 + 4 * (a2 >> 5)) = result;
  return result;
}

//----- (080F0450) --------------------------------------------------------
int __cdecl sub_80F0450(char *s1)
{
  signed int i; // [esp+14h] [ebp-4h]

  for ( i = 0; i <= 2; ++i )
  {
    if ( !strcasecmp(s1, (&off_8166550)[i]) )
      return i;
  }
  return 0;
}

//----- (080F049E) --------------------------------------------------------
char *__cdecl sub_80F049E(int a1)
{
  return (&off_8166550)[a1];
}

//----- (080F04AE) --------------------------------------------------------
int sub_80F04AE()
{
  int result; // eax
  int i; // [esp+14h] [ebp-4h]

  for ( i = 0; ; ++i )
  {
    result = i;
    if ( i >= dword_8576FC4 )
      break;
    sub_80D49D8(i, (int)dword_8576FE0[i]);
  }
  return result;
}

//----- (080F04EA) --------------------------------------------------------
_DWORD *sub_80F04EA()
{
  int v0; // ebx
  size_t v1; // eax
  unsigned int v3; // [esp+18h] [ebp-1020h]
  char v4[4]; // [esp+1Ch] [ebp-101Ch]
  char v5[4104]; // [esp+20h] [ebp-1018h]
  char *s; // [esp+1028h] [ebp-10h]
  char *v7; // [esp+102Ch] [ebp-Ch]

  dword_8576FC4 = 0;
  v3 = FS_FOpenFileByMode("mp/playeranimtypes.txt", (int)v4, 0);
  if ( (v3 & 0x80000000) != 0 )
    Com_Error(1, &byte_814FFCE, "mp/playeranimtypes.txt");
  if ( v3 > 0xFFF )
  {
    FS_FCloseFile(*(int *)v4);
    Com_Error(1, &byte_814FFE7, "mp/playeranimtypes.txt");
  }
  FS_Read((int)v5, v3, *(int *)v4);
  v5[v3] = 0;
  FS_FCloseFile(*(int *)v4);
  v7 = v5;
  sub_80B396A("BG_AnimParseAnimScript");
  while ( 1 )
  {
    s = Com_Parse(&v7);
    if ( !s || !*s )
      break;
    if ( (unsigned int)dword_8576FC4 > 0x3F )
      Com_Error(1, &byte_8150020);
    v0 = dword_8576FC4;
    v1 = strlen(s);
    dword_8576FE0[v0] = (char *)sub_80A9DC4(v1 + 1);
    strcpy(dword_8576FE0[dword_8576FC4], s);
    ++dword_8576FC4;
  }
  return sub_80B3A3C();
}
// 80F04EA: using guessed type char var_1018[4104];

//----- (080F065E) --------------------------------------------------------
int __cdecl sub_80F065E(char *s1, int a2, int a3)
{
  int i; // [esp+14h] [ebp-4h]

  for ( i = 0; i < a3; ++i )
  {
    if ( !strcasecmp(s1, *(const char **)(a2 + 4 * i)) )
      return i;
  }
  return -1;
}

//----- (080F06B4) --------------------------------------------------------
int __cdecl sub_80F06B4(int a1, char *s1, int a3)
{
  int result; // eax
  int v4; // [esp+20h] [ebp-8h]
  int v5; // [esp+20h] [ebp-8h]
  int v6; // [esp+20h] [ebp-8h]
  int v7; // [esp+20h] [ebp-8h]
  int v8; // [esp+20h] [ebp-8h]
  int v9; // [esp+20h] [ebp-8h]
  int v10; // [esp+20h] [ebp-8h]
  int v11; // [esp+20h] [ebp-8h]

  switch ( a3 )
  {
    case 8:
      v4 = sub_80F065E(s1, (int)off_8166540, 4);
      if ( v4 < 0 )
        Com_Error(1, &byte_8150060, s1, *(_DWORD *)a1);
      *(_DWORD *)(a1 + 120) = v4;
      break;
    case 9:
      v5 = sub_80F065E(s1, (int)off_8166580, 10);
      if ( v5 < 0 )
        Com_Error(1, &byte_81500A0, s1, *(_DWORD *)a1);
      *(_DWORD *)(a1 + 124) = v5;
      break;
    case 10:
      v6 = sub_80F065E(s1, (int)off_8166568, 5);
      if ( v6 < 0 )
        Com_Error(1, &byte_81500E0, s1, *(_DWORD *)a1);
      *(_DWORD *)(a1 + 632) = v6;
      break;
    case 11:
      v7 = sub_80F065E(s1, (int)&off_8166550, 3);
      if ( v7 < 0 )
        Com_Error(1, &byte_8150120, s1, *(_DWORD *)a1);
      *(_DWORD *)(a1 + 128) = v7;
      break;
    case 12:
      v8 = sub_80F065E(s1, (int)off_81665A8, 3);
      if ( v8 < 0 )
        Com_Error(1, &byte_8150160, s1, *(_DWORD *)a1);
      *(_DWORD *)(a1 + 140) = v8;
      break;
    case 13:
      v9 = sub_80F065E(s1, (int)off_816655C, 3);
      if ( v9 < 0 )
        Com_Error(1, &byte_81501A0, s1, *(_DWORD *)a1);
      *(_DWORD *)(a1 + 912) = v9;
      break;
    case 14:
      v10 = sub_80F065E(s1, (int)off_81665B4, 3);
      if ( v10 < 0 )
        Com_Error(1, &byte_81501E0, s1, *(_DWORD *)a1);
      *(_DWORD *)(a1 + 132) = v10;
      break;
    case 15:
      v11 = sub_80F065E(s1, (int)dword_8576FE0, dword_8576FC4);
      if ( v11 < 0 )
        Com_Error(1, &byte_8150220, s1, *(_DWORD *)a1);
      *(_DWORD *)(a1 + 116) = v11;
      break;
    default:
      Com_Error(1, &byte_8150246, a3, *(_DWORD *)a1);
      return result;
  }
  return 1;
}
// 8166540: using guessed type char *off_8166540[15];
// 816655C: using guessed type char *off_816655C[8];
// 8166568: using guessed type char *off_8166568[5];
// 8166580: using guessed type char *off_8166580[17];
// 81665A8: using guessed type char *off_81665A8[7];
// 81665B4: using guessed type char *off_81665B4[4];

//----- (080F09D6) --------------------------------------------------------
signed int __cdecl sub_80F09D6(signed int *a1)
{
  signed int result; // eax

  if ( a1[176] <= 0 )
    a1[354] = 995783694;
  else
    *((float *)a1 + 354) = 1.0 / (long double)a1[176];
  if ( a1[177] <= 0 )
  {
    result = 990057071;
    a1[355] = 990057071;
  }
  else
  {
    result = (signed int)a1;
    *((float *)a1 + 355) = 1.0 / (long double)a1[177];
  }
  return result;
}

//----- (080F0A52) --------------------------------------------------------
void __cdecl sub_80F0A52(int a1)
{
  if ( *(float *)(a1 + 1432) <= 0.0 )
    *(_DWORD *)(a1 + 1432) = 1232348144;
  if ( *(float *)(a1 + 1436) <= 0.0 )
    *(_DWORD *)(a1 + 1436) = 1232348146;
}

//----- (080F0AA6) --------------------------------------------------------
void __cdecl sub_80F0AA6(int a1)
{
  if ( (long double)*(signed int *)(a1 + 900) <= 0.0 )
    Com_Error(1, "Projectile speed for WeapType %s must be greater than 0.0", *(_DWORD *)(a1 + 4));
  if ( *(float *)(a1 + 1448) >= 45.0 || *(float *)(a1 + 1448) < 0.0 )
    Com_Error(1, "Destabilization angle for for WeapType %s must be between 0 and 45 degrees", *(_DWORD *)(a1 + 4));
  if ( *(float *)(a1 + 1440) <= 0.0 )
    Com_Error(1, "Destabilization base time for for WeapType %s must be positive", *(_DWORD *)(a1 + 4));
  if ( *(float *)(a1 + 1444) <= 0.0 )
    Com_Error(1, "Destabilization reduction ratio for for WeapType %s must be positive", *(_DWORD *)(a1 + 4));
}

//----- (080F0B8E) --------------------------------------------------------
char *__cdecl sub_80F0B8E(int a1, char *s)
{
  char *result; // eax
  size_t v3; // eax
  char *dest; // ST14_4

  if ( *s )
  {
    v3 = strlen(s);
    dest = (char *)sub_80A9DE0(v3 + 1, 1);
    strcpy(dest, s);
    result = dest;
    *(_DWORD *)a1 = dest;
  }
  else
  {
    result = (char *)a1;
    *(_DWORD *)a1 = &unk_81503AC;
  }
  return result;
}

//----- (080F0BE2) --------------------------------------------------------
char *__cdecl sub_80F0BE2(int a1, char *s)
{
  return sub_80F0B8E(a1, s);
}

//----- (080F0BFC) --------------------------------------------------------
char ***__cdecl sub_80F0BFC(char ***a1)
{
  char ***result; // eax
  char **v2; // [esp+0h] [ebp-8h]
  int v3; // [esp+4h] [ebp-4h]

  result = a1;
  *a1 = (char **)&unk_81503AC;
  v3 = 0;
  v2 = &off_81665C0;
  while ( v3 <= 365 )
  {
    if ( !v2[2] )
      *(_DWORD *)&v2[1][(_DWORD)a1] = &unk_81503AC;
    ++v3;
    result = &v2;
    v2 += 3;
  }
  return result;
}
// 81665C0: using guessed type char *off_81665C0;

//----- (080F0C4E) --------------------------------------------------------
int __cdecl sub_80F0C4E(int a1, char *a2)
{
  int v3; // [esp+2Ch] [ebp-206Ch]
  unsigned int n; // [esp+30h] [ebp-2068h]
  int v5; // [esp+38h] [ebp-2060h]
  int v6; // [esp+3Ch] [ebp-205Ch]
  char s1[8192]; // [esp+40h] [ebp-2058h]
  char src; // [esp+2040h] [ebp-58h]
  int v9; // [esp+208Ch] [ebp-Ch]

  n = strlen("WEAPONFILE");
  v6 = (int)sub_80A9DC4(0x604u);
  sub_80F0BFC((char ***)v6);
  Com_sprintf(&src, 0x40u, "weapons/%s/%s", a1, a2);
  v9 = FS_FOpenFileByMode(&src, (int)&v5, 0);
  if ( v9 >= 0 )
  {
    FS_Read((int)s1, n, v5);
    s1[n] = 0;
    if ( !strncmp(s1, "WEAPONFILE", n) )
    {
      if ( (signed int)(v9 - n) <= 0x1FFF )
      {
        memset(s1, 0, 0x2000u);
        FS_Read((int)s1, v9 - n, v5);
        s1[v9 - n] = 0;
        FS_FCloseFile(v5);
        if ( sub_80B5FA4(s1) )
        {
          sub_80F0B8E(v6, a2);
          if ( sub_80B645E(v6, (int)&off_81665C0, 366, s1, 16, (int)sub_80F06B4, (int)sub_80F0BE2) )
          {
            sub_80F09D6((signed int *)v6);
            sub_80F0A52(v6);
            if ( *(float *)(v6 + 608) > 15000.0 )
              Com_Error(1, "Enemy crosshair ranges should be less than %f ", (double)15000.0);
            if ( *(_DWORD *)(v6 + 120) == 2 )
              sub_80F0AA6(v6);
            if ( (unsigned __int8)sub_80F1F7E(v6) )
            {
              sub_80B573C(*(_BYTE **)(v6 + 452));
              sub_80B573C(*(_BYTE **)(v6 + 460));
              v3 = v6;
            }
            else
            {
              v3 = 0;
            }
          }
          else
          {
            v3 = 0;
          }
        }
        else
        {
          Com_Printf("^3WARNING: \"%s\" is not a valid weapon file\n", &src);
          v3 = 0;
        }
      }
      else
      {
        Com_Printf("^3WARNING: \"%s\" Is too long of a weapon file to parse\n", &src);
        FS_FCloseFile(v5);
        v3 = 0;
      }
    }
    else
    {
      Com_Printf("^3WARNING: \"%s\" does not appear to be a weapon file\n", &src);
      FS_FCloseFile(v5);
      v3 = 0;
    }
  }
  else
  {
    Com_Printf("^3WARNING: Could not load weapon file '%s'\n", &src);
    v3 = 0;
  }
  return v3;
}
// 81665C0: using guessed type char *off_81665C0;
// 80F0C4E: using guessed type char s1[8192];

//----- (080F0F9E) --------------------------------------------------------
char ***sub_80F0F9E()
{
  sub_80F0BFC(dword_85769C0);
  dword_85769C0[0] = (char **)"none";
  dword_85769C0[323] = (char **)"noweapon.accu";
  dword_85769C0[324] = (char **)"noweapon.accu";
  sub_80F1F7E((int)dword_85769C0);
  return dword_85769C0;
}

//----- (080F0FEC) --------------------------------------------------------
int __usercall sub_80F0FEC@<eax>(long double a1@<st0>, int a2, int a3, int a4, int a5, float a6, int a7)
{
  long double v7; // fst7
  long double v8; // fst7
  long double v9; // fst7
  long double v10; // fst7
  long double v11; // fst7
  int result; // eax
  float v13; // [esp+10h] [ebp-18h]
  float v14; // [esp+14h] [ebp-14h]
  float v15; // [esp+18h] [ebp-10h]

  sub_80DEB7A(a2, a5, a6, (int)&v13);
  sub_80F1750(*(float *)a2, v13);
  v7 = a1 + *(float *)a3;
  *(float *)a7 = v7;
  sub_80F1750(*(float *)(a2 + 4), v14);
  v8 = v7 + *(float *)(a3 + 4);
  *(float *)(a7 + 4) = v8;
  sub_80F1750(*(float *)(a2 + 8), v15);
  v9 = v8 + *(float *)(a3 + 8);
  *(float *)(a7 + 8) = v9;
  sub_80F172C(*(float *)a2, v13);
  v10 = v9 + *(float *)a4;
  *(float *)(a7 + 12) = v10;
  sub_80F172C(*(float *)(a2 + 4), v14);
  v11 = v10 + *(float *)(a4 + 4);
  *(float *)(a7 + 16) = v11;
  sub_80F172C(*(float *)(a2 + 8), v15);
  result = a4 + 8;
  *(float *)(a7 + 20) = v11 + *(float *)(a4 + 8);
  return result;
}

//----- (080F10F4) --------------------------------------------------------
int __usercall sub_80F10F4@<eax>(long double a1@<st0>, int a2, int a3, int a4, int a5, int a6, int a7, int a8, int a9)
{
  int result; // eax
  float v10; // ST3C_4
  float v11; // ST3C_4
  long double v12; // fst7
  float v13; // [esp+4Ch] [ebp-BCh]
  int v14; // [esp+50h] [ebp-B8h]
  float v15; // [esp+54h] [ebp-B4h]
  float v16; // [esp+58h] [ebp-B0h]
  float v17; // [esp+5Ch] [ebp-ACh]
  float v18; // [esp+60h] [ebp-A8h]
  float v19; // [esp+64h] [ebp-A4h]
  int v20; // [esp+78h] [ebp-90h]
  int v21; // [esp+7Ch] [ebp-8Ch]
  int v22; // [esp+80h] [ebp-88h]
  float v23; // [esp+90h] [ebp-78h]
  float v24; // [esp+94h] [ebp-74h]
  float v25; // [esp+98h] [ebp-70h]
  float v26; // [esp+A0h] [ebp-68h]
  float v27; // [esp+A4h] [ebp-64h]
  float v28; // [esp+A8h] [ebp-60h]
  int v29; // [esp+B8h] [ebp-50h]
  int v30; // [esp+BCh] [ebp-4Ch]
  float s; // [esp+C0h] [ebp-48h]
  int v32; // [esp+C4h] [ebp-44h]
  int v33; // [esp+C8h] [ebp-40h]
  int v34; // [esp+CCh] [ebp-3Ch]
  int v35; // [esp+D0h] [ebp-38h]
  int v36; // [esp+D4h] [ebp-34h]
  int v37; // [esp+D8h] [ebp-30h]
  int v38; // [esp+DCh] [ebp-2Ch]
  int v39; // [esp+E0h] [ebp-28h]
  int v40; // [esp+F0h] [ebp-18h]
  int v41; // [esp+F4h] [ebp-14h]
  int v42; // [esp+F8h] [ebp-10h]
  int i; // [esp+FCh] [ebp-Ch]

  sub_80F0FEC(a1, a2, a3, a4, a5, *(float *)a9, (int)&v14);
  for ( i = 0; ; ++i )
  {
    result = i;
    if ( i >= dword_85771F8 )
      break;
    v21 = dword_8577200[i];
    v30 = v21 + 240;
    if ( *(_DWORD *)(v21 + 240) == a6 )
      continue;
    if ( *(_DWORD *)(v30 + 156) == 0xFFFFFF )
    {
      v29 = *(_DWORD *)(v30 + 140);
      v20 = sub_805919A(v29);
      if ( !(v20 & a7) )
        continue;
      v13 = sub_80591BC(v29);
      if ( *(float *)(v21 + 492) - v13 >= (long double)v17
        || *(float *)(v21 + 496) - v13 >= (long double)v18
        || *(float *)&v14 >= *(float *)(v21 + 492) + v13
        || v15 >= *(float *)(v21 + 496) + v13
        || *(float *)(v21 + 500) - v13 >= (long double)v19
        || v16 >= *(float *)(v21 + 500) + v13 )
      {
        continue;
      }
      sub_80F179E((_DWORD *)(v21 + 504), &v22);
    }
    else
    {
      if ( *(_DWORD *)(v30 + 4) == 1 )
        v20 = 0x2000000;
      else
        v20 = 1;
      if ( !(v20 & a7) )
        continue;
      v42 = *(unsigned __int8 *)(v30 + 156);
      v41 = ((*(_DWORD *)(v30 + 156) >> 8) & 0xFF) - 1;
      v40 = ((*(_DWORD *)(v30 + 156) >> 16) & 0xFF) - 32;
      v10 = 1.0 - (long double)v42;
      v27 = v10;
      v26 = v10;
      v11 = (long double)v42 - 1.0;
      v24 = v11;
      v23 = v11;
      v28 = 1.0 - (long double)v41;
      v25 = (long double)v40 - 1.0;
      if ( *(float *)(v21 + 492) + v26 >= (long double)v17
        || *(float *)(v21 + 496) + v27 >= (long double)v18
        || *(float *)&v14 >= *(float *)(v21 + 492) + v23
        || v15 >= *(float *)(v21 + 496) + v24
        || *(float *)(v21 + 500) + v28 >= (long double)v19
        || v16 >= *(float *)(v21 + 500) + v25 )
      {
        continue;
      }
      v29 = sub_80590DE(&v26, &v23, v20);
      sub_80F1774(&v22);
    }
    sub_805B972(&s, a2, a5, a3, a4, v29, a7, v21 + 492, (int)&v22);
    v12 = s;
    if ( *(float *)a9 <= (long double)s )
    {
      if ( BYTE2(v39) )
      {
        LOWORD(v38) = *(_WORD *)v30;
        *(float *)a9 = s;
        *(_DWORD *)(a9 + 4) = v32;
        *(_DWORD *)(a9 + 8) = v33;
        *(_DWORD *)(a9 + 12) = v34;
        *(_DWORD *)(a9 + 16) = v35;
        *(_DWORD *)(a9 + 20) = v36;
        *(_DWORD *)(a9 + 24) = v37;
        *(_DWORD *)(a9 + 28) = v38;
        *(_DWORD *)(a9 + 32) = v39;
      }
      else if ( HIBYTE(v39) )
      {
        *(_BYTE *)(a9 + 35) = 1;
      }
    }
    else
    {
      LOWORD(v38) = *(_WORD *)v30;
      *(float *)a9 = s;
      *(_DWORD *)(a9 + 4) = v32;
      *(_DWORD *)(a9 + 8) = v33;
      *(_DWORD *)(a9 + 12) = v34;
      *(_DWORD *)(a9 + 16) = v35;
      *(_DWORD *)(a9 + 20) = v36;
      *(_DWORD *)(a9 + 24) = v37;
      *(_DWORD *)(a9 + 28) = v38;
      *(_DWORD *)(a9 + 32) = v39;
      sub_80F0FEC(v12, a2, a3, a4, a5, s, (int)&v14);
    }
    result = a9;
    if ( *(_BYTE *)(a9 + 34) )
      return result;
  }
  return result;
}
// 85771F8: using guessed type int dword_85771F8;

//----- (080F15AA) --------------------------------------------------------
void __cdecl sub_80F15AA(void *s, int a2, int a3, int a4, int a5, int a6, int a7)
{
  signed __int16 v7; // [esp+22h] [ebp-6h]

  sub_805B690(s, a2, a5, a3, a4, 0, a7);
  if ( *(float *)s == 1.0 )
    v7 = 1023;
  else
    v7 = 1022;
  *((_WORD *)s + 14) = v7;
  if ( *(float *)s != 0.0 )
    sub_80F10F4(0.0, a2, a3, a4, a5, a6, a7, 1, (int)s);
}

//----- (080F166C) --------------------------------------------------------
int __cdecl sub_80F166C(float *a1, int a2, int a3)
{
  int v4; // [esp+14h] [ebp-14h]
  int v5; // [esp+18h] [ebp-10h]
  int v6; // [esp+1Ch] [ebp-Ch]
  int i; // [esp+24h] [ebp-4h]

  v4 = sub_8058D88(a1, 0);
  for ( i = 0; i < dword_85771F8; ++i )
  {
    v6 = dword_8577200[i];
    if ( *(_DWORD *)(v6 + 240) != a2 && *(_DWORD *)(v6 + 396) == 0xFFFFFF )
    {
      v5 = *(_DWORD *)(v6 + 380);
      if ( v5 )
        v4 |= sub_8058E94(a1, v5, (float *)(v6 + 492), (float *)(v6 + 504));
    }
  }
  return v4 & a3;
}
// 85771F8: using guessed type int dword_85771F8;

//----- (080F172C) --------------------------------------------------------
void __cdecl sub_80F172C(float a1, float a2)
{
  float v2; // ST00_4

  v2 = a1 - a2;
  sub_80F17CE(v2, a1, a2);
}

//----- (080F1750) --------------------------------------------------------
void __cdecl sub_80F1750(float a1, float a2)
{
  float v2; // ST00_4

  v2 = a2 - a1;
  sub_80F17CE(v2, a1, a2);
}

//----- (080F1774) --------------------------------------------------------
int __cdecl sub_80F1774(_DWORD *a1)
{
  int result; // eax

  *a1 = 0;
  a1[1] = 0;
  result = 0;
  a1[2] = 0;
  return result;
}

//----- (080F179E) --------------------------------------------------------
int __cdecl sub_80F179E(_DWORD *a1, _DWORD *a2)
{
  int result; // eax

  *a2 = *a1;
  a2[1] = a1[1];
  result = a1[2];
  a2[2] = result;
  return result;
}

//----- (080F17CE) --------------------------------------------------------
long double __cdecl sub_80F17CE(float a1, float a2, float a3)
{
  float v4; // [esp+0h] [ebp-4h]

  if ( a1 < 0.0 )
    v4 = a3;
  else
    v4 = a2;
  return v4;
}

//----- (080F17F8) --------------------------------------------------------
void *__cdecl sub_80F17F8(char *s, int a2)
{
  void *dest; // ST10_4
  size_t v4; // [esp+14h] [ebp-4h]

  v4 = strlen(s);
  if ( (signed int)(*(_DWORD *)(a2 + 520) + v4 + 1) > 2048 )
    Com_Error(1, &byte_8150540);
  dest = (void *)(a2 + *(_DWORD *)(a2 + 520) + 524);
  memcpy(dest, s, v4 + 1);
  *(_DWORD *)(a2 + 520) += v4 + 1;
  return dest;
}

//----- (080F187E) --------------------------------------------------------
signed int __cdecl sub_80F187E(int a1)
{
  int v1; // ebx
  int v2; // ebx
  char dest; // [esp+20h] [ebp-808h]
  char s; // [esp+420h] [ebp-408h]

  *(_BYTE *)a1 = 0;
  *(_DWORD *)(a1 + 4) = 0;
  *(_DWORD *)(a1 + 520) = 0;
  if ( !sub_8090AAA(&dest, 1024) )
    return 0;
  if ( dest != 123 )
    Com_Error(1, &byte_8150580, &dest);
  while ( 1 )
  {
    if ( !sub_8090AAA(&s, 1024) )
      Com_Error(1, &byte_81505C0);
    if ( s == 125 )
      break;
    if ( !sub_8090AAA(&dest, 1024) )
      Com_Error(1, &byte_81505C0);
    if ( dest == 125 )
      Com_Error(1, &byte_8150600);
    if ( *(_DWORD *)(a1 + 4) == 64 )
      Com_Error(1, &byte_8150640);
    v1 = *(_DWORD *)(a1 + 4);
    *(_DWORD *)(a1 + 8 * v1 + 8) = sub_80F17F8(&s, a1);
    v2 = *(_DWORD *)(a1 + 4);
    *(_DWORD *)(a1 + 8 * v2 + 12) = sub_80F17F8(&dest, a1);
    ++*(_DWORD *)(a1 + 4);
  }
  *(_BYTE *)a1 = 1;
  return 1;
}

//----- (080F1A0A) --------------------------------------------------------
int __cdecl sub_80F1A0A(int a1, char *s1, int a3, int a4)
{
  int i; // [esp+14h] [ebp-4h]

  for ( i = 0; i < *(_DWORD *)(a1 + 4); ++i )
  {
    if ( !strcmp(s1, *(const char **)(a1 + 8 * i + 8)) )
    {
      *(_DWORD *)a4 = *(_DWORD *)(a1 + 8 * i + 12);
      return 1;
    }
  }
  *(_DWORD *)a4 = a3;
  return 0;
}

//----- (080F1A74) --------------------------------------------------------
int __cdecl sub_80F1A74(char *s)
{
  size_t v2; // [esp+14h] [ebp-4014h]
  int i; // [esp+18h] [ebp-4010h]
  char *v4; // [esp+1Ch] [ebp-400Ch]
  char v5; // [esp+20h] [ebp-4008h]

  v2 = strlen(s) + 1;
  if ( v2 > 0x4000 )
    Com_Error(1, &byte_8150662, v2, 0x4000);
  v4 = &v5;
  for ( i = 0; i < (signed int)v2; ++i )
  {
    if ( s[i] != 92 || i >= (signed int)(v2 - 1) )
    {
      *v4++ = s[i];
    }
    else
    {
      if ( s[++i] == 110 )
        *v4 = 10;
      else
        *v4 = 92;
      ++v4;
    }
  }
  return sub_80792C4(&v5, 0);
}

//----- (080F1B86) --------------------------------------------------------
char *__cdecl sub_80F1B86(float *a1)
{
  char *s; // ST24_4

  s = (char *)&unk_8577A40 + 32 * dword_8577A20;
  dword_8577A20 = ((_BYTE)dword_8577A20 + 1) & 7;
  Com_sprintf(s, 0x20u, "(%i %i %i)", (signed int)*a1, (signed int)a1[1], (signed int)a1[2]);
  return s;
}
// 8577A20: using guessed type int dword_8577A20;

//----- (080F1C24) --------------------------------------------------------
int __cdecl sub_80F1C24(char a1, char *src, int a3, int a4)
{
  char *v4; // eax
  int v5; // eax
  int v6; // ebx
  float *v7; // ebx
  int v10; // [esp+18h] [ebp-10h]
  char *nptr; // [esp+1Ch] [ebp-Ch]
  char *nptra; // [esp+1Ch] [ebp-Ch]

  sub_80B396A(src);
  v4 = Com_Parse((char **)&a1);
  v5 = atoi(v4);
  *(_DWORD *)a4 = v5;
  v10 = 0;
  while ( 1 )
  {
    nptr = Com_Parse((char **)&a1);
    if ( !*nptr )
      break;
    if ( *nptr == 125 )
      break;
    v6 = a3;
    *(float *)(v6 + 8 * v10) = atof(nptr);
    nptra = Com_Parse((char **)&a1);
    if ( !*nptra || *nptra == 125 )
      break;
    v7 = (float *)(a3 + 8 * v10 + 4);
    *v7 = atof(nptra);
    if ( ++v10 > 15 )
    {
      Com_Printf("^3WARNING: \"%s\" has too many graph knots\n", src);
      sub_80B3A3C();
      return 0;
    }
  }
  sub_80B3A3C();
  if ( v10 == *(_DWORD *)a4 )
    return 1;
  Com_Printf("^3WARNING: \"%s\" Error in parsing an ai weapon accuracy file\n", src);
  return 0;
}

//----- (080F1D3A) --------------------------------------------------------
signed int __cdecl sub_80F1D3A(int a1, int a2, _BYTE *a3, int a4, int *a5)
{
  signed int v6; // [esp+10h] [ebp-2068h]
  int v7; // [esp+14h] [ebp-2064h]
  size_t n; // [esp+18h] [ebp-2060h]
  char *s; // [esp+1Ch] [ebp-205Ch]
  char s1[8192]; // [esp+20h] [ebp-2058h]
  char src; // [esp+2020h] [ebp-58h]
  int v12; // [esp+2068h] [ebp-10h]
  int v13; // [esp+206Ch] [ebp-Ch]

  s = "WEAPONACCUFILE";
  n = strlen("WEAPONACCUFILE");
  if ( *(_DWORD *)(a1 + 120) && *(_DWORD *)(a1 + 120) != 2 )
    return 1;
  if ( !*a3 )
    return 1;
  sprintf(&src, "accuracy/%s/%s", a2, a3);
  v13 = FS_FOpenFileByMode(&src, (int)&v12, 0);
  if ( v13 >= 0 )
  {
    FS_Read((int)s1, n, v12);
    s1[n] = 0;
    if ( !strncmp(s1, s, n) )
    {
      if ( (signed int)(v13 - n) <= 0x1FFF )
      {
        memset(s1, 0, 0x2000u);
        FS_Read((int)s1, v13 - n, v12);
        s1[v13 - n] = 0;
        FS_FCloseFile(v12);
        v7 = 0;
        if ( (unsigned __int8)sub_80F1C24((unsigned int)s1, &src, a4, (int)&v7) )
        {
          *a5 = v7;
          v6 = 1;
        }
        else
        {
          v6 = 0;
        }
      }
      else
      {
        Com_Printf("^3WARNING: \"%s\" Is too long of an ai weapon accuracy file to parse\n", &src);
        FS_FCloseFile(v12);
        v6 = 0;
      }
    }
    else
    {
      Com_Printf("^3WARNING: \"%s\" does not appear to be an ai weapon accuracy file\n", &src);
      FS_FCloseFile(v12);
      v6 = 0;
    }
  }
  else
  {
    Com_Printf("^3WARNING: Could not load ai weapon accuracy file '%s'\n", &src);
    v6 = 0;
  }
  return v6;
}
// 80F1D3A: using guessed type char s1[8192];

//----- (080F1F7E) --------------------------------------------------------
signed int __cdecl sub_80F1F7E(int a1)
{
  int n; // ST28_4
  signed int i; // [esp+24h] [ebp-94h]
  int v5; // [esp+2Ch] [ebp-8Ch]
  char s; // [esp+30h] [ebp-88h]

  for ( i = 0; i <= 1; ++i )
  {
    memset(&s, 0, 0x80u);
    v5 = 0;
    if ( !(unsigned __int8)sub_80F1D3A(a1, (int)off_81676E8[i], *(_BYTE **)(a1 + 4 * i + 1292), (int)&s, &v5) )
      return 0;
    if ( v5 > 0 )
    {
      n = 8 * v5;
      *(_DWORD *)(a1 + 4 * i + 1300) = sub_80A9DE0(8 * v5, 4);
      memcpy(*(void **)(a1 + 4 * i + 1300), &s, n);
      *(_DWORD *)(a1 + 4 * i + 1308) = v5;
    }
  }
  return 1;
}
// 81676E8: using guessed type char *off_81676E8[2];

//----- (080F20C8) --------------------------------------------------------
int __cdecl sub_80F20C8(int a1)
{
  int result; // eax
  int v2; // ebx
  float v3; // ST28_4
  int v4; // ebx
  long double v5; // fst7
  char v6; // [esp+30h] [ebp-68h]
  int v7; // [esp+3Ch] [ebp-5Ch]
  float v8; // [esp+6Ch] [ebp-2Ch]
  float v9; // [esp+70h] [ebp-28h]
  float v10; // [esp+74h] [ebp-24h]
  int v11; // [esp+88h] [ebp-10h]
  int v12; // [esp+8Ch] [ebp-Ch]

  v12 = *(_DWORD *)(a1 + 344);
  result = v12;
  if ( *(_DWORD *)(v12 + 4) <= 5 )
  {
    *(_DWORD *)(v12 + 296) = 0;
    result = *(_DWORD *)(v12 + 10208);
    v11 = *(_DWORD *)(v12 + 10208);
    if ( v11 > 0 )
    {
      result = v12;
      if ( *(_DWORD *)(v12 + 10024) > 0 )
      {
        v11 = 100 * v11 / *(_DWORD *)(v12 + 10024);
        if ( v11 > 127 )
          v11 = 127;
        *(float *)(v12 + 1492) = (long double)v11 + *(float *)(v12 + 1492);
        if ( *(float *)(v12 + 1492) > 255.0 )
          *(_DWORD *)(v12 + 1492) = 1132396544;
        v8 = (long double)v11 * 0.2;
        if ( v8 >= 5.0 )
        {
          if ( v8 > 90.0 )
            v8 = 90.0;
        }
        else
        {
          v8 = 5.0;
        }
        if ( *(_DWORD *)(v12 + 10224) )
        {
          *(_DWORD *)(v12 + 10308) = 0;
          *(_DWORD *)(v12 + 10312) = LODWORD(v8) ^ 0x80000000;
          *(_DWORD *)(v12 + 292) = 255;
          *(_DWORD *)(v12 + 288) = 255;
          *(_DWORD *)(v12 + 10224) = 0;
        }
        else
        {
          sub_80A2C7E((float *)(v12 + 10212), (int)&v9);
          sub_80A7146((float *)(v12 + 232), (int)&v6);
          v2 = v12;
          LODWORD(v3) = LODWORD(v8) ^ 0x80000000;
          *(float *)(v2 + 10308) = sub_80F55E2((float *)(v12 + 10212), (float *)&v7) * v3;
          v4 = v12;
          v5 = sub_80F55E2((float *)(v12 + 10212), (float *)&v6);
          *(float *)(v4 + 10312) = v5 * v8;
          *(_DWORD *)(v12 + 292) = (signed int)(v9 / 360.0 * 256.0);
          *(_DWORD *)(v12 + 288) = (signed int)(v10 / 360.0 * 256.0);
        }
        ++*(_DWORD *)(v12 + 284);
        *(_DWORD *)(v12 + 10304) = dword_859B5EC - 20;
        *(_DWORD *)(v12 + 296) = v11;
        result = v12;
        *(_DWORD *)(v12 + 10208) = 0;
      }
    }
  }
  return result;
}

//----- (080F2350) --------------------------------------------------------
int __cdecl sub_80F2350(int a1)
{
  int result; // eax

  result = a1;
  *(_DWORD *)(a1 + 132) = 0;
  return result;
}

//----- (080F2362) --------------------------------------------------------
int __cdecl sub_80F2362(int a1, int a2)
{
  int result; // eax
  void (__cdecl *v3)(int *, int, signed int); // [esp+10h] [ebp-18h]
  void (__cdecl *v4)(int, int *, signed int); // [esp+14h] [ebp-14h]
  int *v5; // [esp+18h] [ebp-10h]
  int j; // [esp+1Ch] [ebp-Ch]
  int i; // [esp+20h] [ebp-8h]

  v4 = (void (__cdecl *)(int, int *, signed int))dword_816788C[10 * *(unsigned __int8 *)(a1 + 358)];
  for ( i = 0; ; ++i )
  {
    result = i;
    if ( i >= *(_DWORD *)(a2 + 64) )
      break;
    for ( j = 0; j < i && *(_DWORD *)(a2 + 4 * j + 68) != *(_DWORD *)(a2 + 4 * i + 68); ++j )
      ;
    if ( j == i )
    {
      v5 = (int *)((char *)&unk_8665480 + 560 * *(_DWORD *)(a2 + 4 * i + 68));
      if ( sub_8084030() )
      {
        Scr_AddEntity(v5);
        Scr_Notify((int *)a1, word_87A22F2, 1);
        Scr_AddEntity((int *)a1);
        Scr_Notify(v5, word_87A22F2, 1);
      }
      v3 = (void (__cdecl *)(int *, int, signed int))dword_816788C[10 * *((unsigned __int8 *)v5 + 358)];
      if ( v3 )
        v3(v5, a1, 1);
      if ( v4 )
        v4(a1, v5, 1);
    }
  }
  return result;
}
// 816788C: using guessed type int dword_816788C[];
// 87A22F2: using guessed type __int16 word_87A22F2;

//----- (080F24C6) --------------------------------------------------------
int __cdecl sub_80F24C6(int a1)
{
  int result; // eax
  void (__cdecl *v2)(int, int, signed int); // [esp+28h] [ebp-1050h]
  int v3; // [esp+2Ch] [ebp-104Ch]
  char v4; // [esp+30h] [ebp-1048h]
  char v5; // [esp+40h] [ebp-1038h]
  int v6; // [esp+5Ch] [ebp-101Ch]
  int v7[1026]; // [esp+60h] [ebp-1018h]
  int v8; // [esp+1068h] [ebp-10h]
  int i; // [esp+106Ch] [ebp-Ch]

  result = *(_DWORD *)(a1 + 344);
  if ( *(_DWORD *)(result + 4) <= 1 )
  {
    sub_80F559E((float *)(*(_DWORD *)(a1 + 344) + 20), (float *)&unk_81676F4, (float *)&v5);
    sub_80F555A((float *)(*(_DWORD *)(a1 + 344) + 20), (float *)&unk_81676F4, (float *)&v4);
    v8 = sub_805E782((int)&v5, (int)&v4, (int)v7, 1024, 1079771144);
    sub_80F555A((float *)(*(_DWORD *)(a1 + 344) + 20), (float *)(a1 + 260), (float *)&v5);
    sub_80F555A((float *)(*(_DWORD *)(a1 + 344) + 20), (float *)(a1 + 272), (float *)&v4);
    sub_80A64CE((float *)&v5, (float *)&v4);
    v3 = dword_816788C[10 * *(unsigned __int8 *)(a1 + 358)];
    for ( i = 0; ; ++i )
    {
      result = i;
      if ( i >= v8 )
        return result;
      v6 = (int)&unk_8665480 + 560 * v7[i];
      v2 = (void (__cdecl *)(int, int, signed int))dword_816788C[10 * *(unsigned __int8 *)(v6 + 358)];
      if ( v2 || v3 )
      {
        if ( *(_DWORD *)(v6 + 4) == 3 )
        {
          if ( !sub_80DCBB6(*(float **)(a1 + 344), v6, dword_859B5EC) )
            continue;
        }
        else if ( !sub_80901C2((float *)&v5, (float *)&v4, v6) )
        {
          continue;
        }
        if ( sub_8084030() )
        {
          Scr_AddEntity((int *)a1);
          Scr_Notify((int *)v6, word_87A22F2, 1);
          Scr_AddEntity((int *)v6);
          Scr_Notify((int *)a1, word_87A22F2, 1);
        }
        if ( v2 )
          v2(v6, a1, 1);
      }
    }
  }
  return result;
}
// 816788C: using guessed type int dword_816788C[];
// 87A22F2: using guessed type __int16 word_87A22F2;
// 80F24C6: using guessed type int var_1018[1026];

//----- (080F275E) --------------------------------------------------------
int __cdecl sub_80F275E(int a1, int *a2)
{
  int result; // eax
  _DWORD *v3; // [esp+1Ch] [ebp-10Ch]
  _DWORD *s; // [esp+20h] [ebp-108h]
  int v5; // [esp+24h] [ebp-104h]
  int v6; // [esp+28h] [ebp-100h]
  int v7; // [esp+2Ch] [ebp-FCh]
  int v8; // [esp+30h] [ebp-F8h]
  int v9; // [esp+34h] [ebp-F4h]
  int v10; // [esp+38h] [ebp-F0h]
  int v11; // [esp+3Ch] [ebp-ECh]
  int v12; // [esp+5Ch] [ebp-CCh]
  char v13; // [esp+104h] [ebp-24h]

  v3 = *(_DWORD **)(a1 + 344);
  v3[2544] = v3[2543];
  v3[2543] = v3[2483];
  v3[2546] |= v3[2543] & ~v3[2544];
  if ( v3[2475] < 0 && sub_80F467C((int)v3, 4) && v3[2538] >= 0 && (v3[2543] & 4) != (v3[2544] & 4) )
    sub_80FCAE6((char *)a1);
  if ( v3[2543] & 1 && (*((_BYTE *)v3 + 10176) ^ 1) & 1 )
  {
    sub_80FCD40(a1, 1);
  }
  else if ( v3[2543] & 0x1000 && !(v3[2544] & 0x1000) )
  {
    sub_80FCD40(a1, -1);
  }
  result = v3[3] & 0x400000;
  if ( !result )
  {
    v3[1] = 4;
    if ( sub_80F467C((int)v3, 4) )
      v3[20] = 400;
    else
      v3[20] = 0;
    memset(&s, 0, 0xF8u);
    s = v3;
    v5 = *a2;
    v6 = a2[1];
    v7 = a2[2];
    v8 = a2[3];
    v9 = a2[4];
    v10 = a2[5];
    v11 = a2[6];
    v12 = 8390673;
    v13 = 1;
    sub_80E6D30(&s);
    sub_80F552A(v3 + 5, (_DWORD *)(a1 + 312));
    result = sub_809A3BA(a1);
  }
  return result;
}

//----- (080F29CA) --------------------------------------------------------
signed int __usercall sub_80F29CA@<eax>(long double a1@<st0>, int a2)
{
  char *v2; // eax

  if ( !*(_DWORD *)(dword_8793DA8 + 8) )
  {
    *(_DWORD *)(a2 + 10240) = dword_859B5EC + 60000;
    *(_DWORD *)(a2 + 10244) = 0;
    return 1;
  }
  if ( *(_BYTE *)(a2 + 9952) || *(_BYTE *)(a2 + 9953) || *(_DWORD *)(a2 + 9932) & 0x401 )
  {
    *(_DWORD *)(a2 + 10240) = dword_859B5EC + 1000 * *(_DWORD *)(dword_8793DA8 + 8);
    *(_DWORD *)(a2 + 10244) = 0;
    return 1;
  }
  if ( *(_DWORD *)(a2 + 9984) )
    return 1;
  if ( dword_859B5EC <= *(_DWORD *)(a2 + 10240) )
  {
    if ( dword_859B5EC > *(_DWORD *)(a2 + 10240) - 10000 && !*(_DWORD *)(a2 + 10244) )
    {
      *(_DWORD *)(a2 + 10244) = 1;
      v2 = va("%c \"GAME_INACTIVEDROPWARNING\"", 99);
      sub_808FE96(1682649625 * ((a2 - dword_859B400) >> 2), 0, (int)v2);
    }
    return 1;
  }
  sub_808FF0A(a1, 1682649625 * ((a2 - dword_859B400) >> 2), "GAME_DROPPEDFORINACTIVITY");
  return 0;
}
// 859B400: using guessed type int dword_859B400;
// 8793DA8: using guessed type int dword_8793DA8;

//----- (080F2B22) --------------------------------------------------------
int __cdecl sub_80F2B22(int a1)
{
  _DWORD *v1; // ST00_4
  int result; // eax

  v1 = *(_DWORD **)(a1 + 344);
  v1[2544] = v1[2543];
  v1[2543] = v1[2483];
  result = v1[2546] | v1[2543] & ~v1[2544];
  v1[2546] = result;
  return result;
}

//----- (080F2B86) --------------------------------------------------------
int __cdecl sub_80F2B86(int *a1, int a2)
{
  int result; // eax
  int v3; // edx
  char v4; // [esp+40h] [ebp-38h]
  float v5; // [esp+5Ch] [ebp-1Ch]
  _DWORD *v6; // [esp+60h] [ebp-18h]
  int v7; // [esp+64h] [ebp-14h]
  int v8; // [esp+68h] [ebp-10h]
  int i; // [esp+6Ch] [ebp-Ch]

  v6 = (_DWORD *)a1[86];
  if ( a2 < v6[41] - 4 )
    a2 = v6[41] - 4;
  for ( i = a2; ; ++i )
  {
    result = i;
    if ( i >= v6[41] )
      break;
    v8 = v6[(i & 3) + 42];
    v7 = v6[(i & 3) + 46];
    if ( v8 <= 115 || v8 > 138 )
    {
      switch ( v8 )
      {
        case 158:
        case 159:
        case 160:
        case 175:
          if ( *(_BYTE *)(dword_8793E4C + 8) )
            sub_811E3E0((int)a1, v6[2599]);
          else
            sub_811E3E0((int)a1, dword_859B5EC);
          break;
        case 164:
          sub_811E5E0((int)a1);
          break;
        case 166:
          sub_811E586(a1);
          break;
        case 168:
          Scr_Notify(a1, word_87A2302, 0);
          break;
        case 169:
          Scr_Notify(a1, word_87A2304, 0);
          break;
        case 170:
          Scr_Notify(a1, word_87A2306, 0);
          break;
        case 171:
          Scr_Notify(a1, word_87A2308, 0);
          break;
        case 172:
          Scr_Notify(a1, word_87A230A, 0);
          break;
        case 197:
          if ( a1[86] && !(a1[93] & 3) )
          {
            v3 = a1[86];
            a1[101] = 0;
            *(_DWORD *)(v3 + 300) = 0;
            sub_80FF2CA((int)a1, a1, a1, 100000, 0xCu, 0, 0, 0, 0);
          }
          break;
        default:
          continue;
      }
    }
    else
    {
      result = (int)a1;
      if ( a1[1] != 1 )
        return result;
      if ( v7 <= 99 )
        v5 = (long double)v7 * 0.0099999998;
      else
        v5 = 1.1;
      if ( v5 != 0.0 )
      {
        v5 = (long double)(signed int)v6[77] * v5;
        sub_80F5506(&v4, 0, 0, 1065353216);
        sub_80FF7C8(a1, 0, 0, 0, 0, (signed int)v5, 0, 0xBu, 0, 0);
      }
    }
  }
  return result;
}
// 8793E4C: using guessed type int dword_8793E4C;
// 87A2302: using guessed type __int16 word_87A2302;
// 87A2304: using guessed type __int16 word_87A2304;
// 87A2306: using guessed type __int16 word_87A2306;
// 87A2308: using guessed type __int16 word_87A2308;
// 87A230A: using guessed type __int16 word_87A230A;

//----- (080F2EC0) --------------------------------------------------------
int __cdecl sub_80F2EC0(int a1, int a2)
{
  int result; // eax
  char *v3; // [esp+0h] [ebp-4h]

  v3 = (char *)&unk_8665480 + 560 * a1;
  if ( dword_859B5EC - a2 > 1000 )
    a2 = dword_859B5EC - 1000;
  if ( a2 >= *(_DWORD *)(*((_DWORD *)v3 + 86) + 10396) || (result = dword_859B5EC, dword_859B5EC <= a2) )
  {
    result = a2;
    *(_DWORD *)(*((_DWORD *)v3 + 86) + 10396) = a2;
  }
  return result;
}

//----- (080F2F2E) --------------------------------------------------------
int __cdecl sub_80F2F2E(int a1)
{
  int result; // eax

  if ( *(_DWORD *)(*(_DWORD *)(a1 + 344) + 10156) )
  {
    result = a1;
    *(_DWORD *)(a1 + 284) = 0;
  }
  else if ( *(_DWORD *)(*(_DWORD *)(a1 + 344) + 10160) )
  {
    result = a1;
    *(_DWORD *)(a1 + 284) = 0;
  }
  else if ( *(_DWORD *)(*(_DWORD *)(a1 + 344) + 9896) == 1 )
  {
    result = a1;
    *(_DWORD *)(a1 + 284) = 0;
  }
  else
  {
    result = a1;
    *(_DWORD *)(a1 + 284) = 0x2000000;
  }
  return result;
}

//----- (080F2FA4) --------------------------------------------------------
void __cdecl sub_80F2FA4(int a1, int a2, int a3, int a4)
{
  unsigned int v4; // edx
  unsigned int v5; // edx
  float v6; // [esp+14h] [ebp-14h]
  unsigned __int8 v7; // [esp+1Bh] [ebp-Dh]
  int j; // [esp+1Ch] [ebp-Ch]
  int i; // [esp+20h] [ebp-8h]

  *(_DWORD *)(a2 + 12) = 3;
  sub_80F552A((_DWORD *)(a1 + 20), (_DWORD *)(a2 + 24));
  sub_80F552A((_DWORD *)(a1 + 32), (_DWORD *)(a2 + 36));
  *(_DWORD *)(a2 + 16) = a3;
  *(_DWORD *)(a2 + 20) = 50;
  *(_DWORD *)(a2 + 48) = 1;
  sub_80F552A((_DWORD *)(a1 + 232), (_DWORD *)(a2 + 60));
  *(float *)(a2 + 108) = (long double)*(signed int *)(a1 + 156);
  *(_DWORD *)(a2 + 8) = *(_DWORD *)(a1 + 160);
  if ( *(_DWORD *)(a1 + 1484) - *(_DWORD *)(a1 + 164) >= 0 )
  {
    *(_DWORD *)(a2 + 160) = 0;
  }
  else
  {
    if ( *(_DWORD *)(a1 + 164) - *(_DWORD *)(a1 + 1484) > 4 )
      *(_DWORD *)(a1 + 1484) = *(_DWORD *)(a1 + 164) - 4;
    *(_DWORD *)(a2 + 160) = *(unsigned __int8 *)(a1 + 4 * ((*(_DWORD *)(a1 + 1484))++ & 3) + 184);
  }
  if ( *(_DWORD *)(a1 + 200) - *(_DWORD *)(a1 + 164) > 0 )
    *(_DWORD *)(a1 + 200) = *(_DWORD *)(a1 + 164);
  for ( i = *(_DWORD *)(a1 + 200); i != *(_DWORD *)(a1 + 164); ++i )
  {
    v7 = *(_BYTE *)(a1 + 4 * (i & 3) + 168);
    sub_80F53E0(*(_DWORD *)a2, v7);
    for ( j = 0; dword_814D70C[j] > 0 && dword_814D70C[j] != v7; ++j )
      ;
    if ( dword_814D70C[j] < 0 )
    {
      *(_DWORD *)(a2 + 4 * (*(_DWORD *)(a2 + 164) & 3) + 168) = v7;
      *(_DWORD *)(a2 + 4 * ((*(_DWORD *)(a2 + 164))++ & 3) + 184) = *(unsigned __int8 *)(a1 + 4 * (i & 3) + 184);
    }
  }
  *(_DWORD *)(a1 + 200) = *(_DWORD *)(a1 + 164);
  *(_DWORD *)(a2 + 200) = *(unsigned __int8 *)(a1 + 212);
  *(_DWORD *)(a2 + 124) = *(unsigned __int16 *)(a1 + 96);
  if ( *(_DWORD *)(a1 + 12) & 0xC00000 )
    *(_DWORD *)(a2 + 4) = 1;
  else
    *(_DWORD *)(a2 + 4) = 5;
  if ( a4 )
  {
    *(float *)(a2 + 24) = (long double)(signed int)*(float *)(a2 + 24);
    *(float *)(a2 + 28) = (long double)(signed int)*(float *)(a2 + 28);
    *(float *)(a2 + 32) = (long double)(signed int)*(float *)(a2 + 32);
    *(float *)(a2 + 60) = (long double)(signed int)*(float *)(a2 + 60);
    *(float *)(a2 + 64) = (long double)(signed int)*(float *)(a2 + 64);
    *(float *)(a2 + 68) = (long double)(signed int)*(float *)(a2 + 68);
  }
  *(_DWORD *)(a2 + 204) = *(_DWORD *)(a1 + 124);
  *(_DWORD *)(a2 + 208) = *(_DWORD *)(a1 + 132);
  *(_DWORD *)(a2 + 144) = *(_DWORD *)(a1 + 204);
  if ( *(_DWORD *)(a1 + 160) & 0x300 )
    *(_DWORD *)(a2 + 116) = *(_DWORD *)(a1 + 1428);
  if ( *(_DWORD *)(a1 + 4) <= 5 )
    v4 = *(_DWORD *)(a2 + 8) & 0xFFFDFFFF;
  else
    v4 = *(_DWORD *)(a2 + 8) | 0x20000;
  *(_DWORD *)(a2 + 8) = v4;
  if ( *(_DWORD *)(a1 + 12) & 0x40 )
    v5 = *(_DWORD *)(a2 + 8) | 0x40000;
  else
    v5 = *(_DWORD *)(a2 + 8) & 0xFFFBFFFF;
  *(_DWORD *)(a2 + 8) = v5;
  *(_DWORD *)(a2 + 212) = *(_DWORD *)(a1 + 76);
  if ( sub_80DEE0E(a1) == 1 )
  {
    v6 = (long double)(*(_DWORD *)a1 - *(_DWORD *)(a1 + 252))
       / (long double)sub_80E1522(a1, *(_DWORD *)(a1 + 256), *(_DWORD *)(a1 + 260));
    if ( v6 >= 0.0 )
    {
      if ( v6 > 1.0 )
        v6 = 1.0;
    }
    else
    {
      v6 = 0.0;
    }
    if ( !*(_DWORD *)(a1 + 260) )
      v6 = 1.0 - v6;
    *(float *)(a2 + 228) = *(float *)(a1 + 1448) * v6;
    *(float *)(a2 + 232) = sub_80A6112(*(float *)(a1 + 1452)) * v6;
    *(float *)(a2 + 236) = sub_80A6112(*(float *)(a1 + 1456)) * v6;
  }
  else
  {
    *(_DWORD *)(a2 + 228) = 0;
    *(_DWORD *)(a2 + 232) = 0;
    *(_DWORD *)(a2 + 236) = 0;
  }
}

//----- (080F34E0) --------------------------------------------------------
int __cdecl sub_80F34E0(_DWORD *a1, int a2, int a3)
{
  char *v3; // ST10_4
  int v4; // eax
  _DWORD *v5; // ST14_4
  int result; // eax

  v3 = (char *)&unk_8665480 + 560 * *(_DWORD *)(*(_DWORD *)a3 + 204);
  v4 = sub_811C546();
  v5 = (_DWORD *)v4;
  *(_DWORD *)(v4 + 396) = v3;
  *(_DWORD *)(v4 + 336) = *(_DWORD *)(*(_DWORD *)a3 + 204);
  *(_DWORD *)(v4 + 284) = 0x10000;
  *(_DWORD *)(v4 + 388) = 0x10000;
  *(_BYTE *)(v4 + 242) = 33;
  *(_DWORD *)(v4 + 4) = 5;
  *(_BYTE *)(v4 + 358) = 19;
  sub_80F552A((_DWORD *)v3 + 65, (_DWORD *)(v4 + 260));
  sub_80F552A((_DWORD *)v3 + 68, v5 + 68);
  sub_811CF36(v5, a1);
  sub_809A45E((int)v5);
  result = *(_DWORD *)(dword_8793DD8 + 8) + dword_859B5EC + a2;
  v5[100] = result;
  return result;
}
// 8793DD8: using guessed type int dword_8793DD8;

//----- (080F35DA) --------------------------------------------------------
int __usercall sub_80F35DA@<eax>(long double a1@<st0>, int *a2, int *a3)
{
  int result; // eax
  unsigned int v4; // edx
  char v5; // [esp+20h] [ebp-278h]
  char v6; // [esp+50h] [ebp-248h]
  char v7; // [esp+80h] [ebp-218h]
  int v8; // [esp+B0h] [ebp-1E8h]
  float v9; // [esp+B4h] [ebp-1E4h]
  float v10; // [esp+B8h] [ebp-1E0h]
  int v11; // [esp+BCh] [ebp-1DCh]
  char v12; // [esp+C0h] [ebp-1D8h]
  int v13; // [esp+D0h] [ebp-1C8h]
  int v14; // [esp+D4h] [ebp-1C4h]
  int v15; // [esp+E0h] [ebp-1B8h]
  float v16; // [esp+E4h] [ebp-1B4h]
  float v17; // [esp+E8h] [ebp-1B0h]
  int v18; // [esp+ECh] [ebp-1ACh]
  int v19; // [esp+F8h] [ebp-1A0h]
  int v20; // [esp+FCh] [ebp-19Ch]
  int v21; // [esp+100h] [ebp-198h]
  int v22; // [esp+104h] [ebp-194h]
  int v23; // [esp+108h] [ebp-190h]
  int v24; // [esp+10Ch] [ebp-18Ch]
  int v25; // [esp+118h] [ebp-180h]
  int v26; // [esp+124h] [ebp-174h]
  int v27; // [esp+130h] [ebp-168h]
  int v28; // [esp+140h] [ebp-158h]
  int v29; // [esp+144h] [ebp-154h]
  int v30; // [esp+148h] [ebp-150h]
  int v31; // [esp+14Ch] [ebp-14Ch]
  int v32; // [esp+150h] [ebp-148h]
  float v33; // [esp+154h] [ebp-144h]
  float v34; // [esp+158h] [ebp-140h]
  int v35; // [esp+15Ch] [ebp-13Ch]
  int v36; // [esp+160h] [ebp-138h]
  int v37; // [esp+178h] [ebp-120h]
  int v38; // [esp+17Ch] [ebp-11Ch]
  int s; // [esp+180h] [ebp-118h]
  int v40; // [esp+184h] [ebp-114h]
  int v41; // [esp+188h] [ebp-110h]
  int v42; // [esp+18Ch] [ebp-10Ch]
  int v43; // [esp+190h] [ebp-108h]
  int v44; // [esp+194h] [ebp-104h]
  int v45; // [esp+198h] [ebp-100h]
  int v46; // [esp+19Ch] [ebp-FCh]
  int v47; // [esp+1A0h] [ebp-F8h]
  int v48; // [esp+1A4h] [ebp-F4h]
  int v49; // [esp+1A8h] [ebp-F0h]
  int v50; // [esp+1ACh] [ebp-ECh]
  int v51; // [esp+1B0h] [ebp-E8h]
  int v52; // [esp+1B4h] [ebp-E4h]
  int v53; // [esp+1B8h] [ebp-E0h]
  int v54; // [esp+1BCh] [ebp-DCh]
  int v55; // [esp+244h] [ebp-54h]
  int v56; // [esp+250h] [ebp-48h]
  char v57; // [esp+264h] [ebp-34h]
  char v58; // [esp+265h] [ebp-33h]
  int v59; // [esp+268h] [ebp-30h]
  int v60; // [esp+274h] [ebp-24h]
  int v61; // [esp+28Ch] [ebp-Ch]

  v61 = a2[86];
  result = v61;
  if ( *(_DWORD *)(v61 + 9924) == 2 )
  {
    if ( *a3 > dword_859B5EC + 200 )
      *a3 = dword_859B5EC + 200;
    if ( *a3 < dword_859B5EC - 1000 )
      *a3 = dword_859B5EC - 1000;
    v37 = *a3 - *(_DWORD *)v61;
    if ( v37 > 0
      || (result = -1963413621 * (((char *)a2 - (char *)&unk_8665480) >> 4), *(_DWORD *)(v61 + 204) != result) )
    {
      if ( v37 > 200 )
        v37 = 200;
      if ( *(_DWORD *)(v61 + 10164) )
        v4 = *(_DWORD *)(v61 + 12) | 0x8000;
      else
        v4 = *(_DWORD *)(v61 + 12) & 0xFFFF7FFF;
      *(_DWORD *)(v61 + 12) = v4;
      if ( *(_DWORD *)(v61 + 9896) == 3 )
      {
        result = sub_80F2B22((int)a2);
      }
      else if ( *(_DWORD *)(v61 + 9896) == 2 )
      {
        result = sub_80F275E((int)a2, a3);
      }
      else
      {
        result = sub_80F29CA(a1, v61);
        if ( result )
        {
          v38 = *(_DWORD *)(v61 + 164);
          memset(&s, 0, 0xF8u);
          s = v61;
          v40 = *a3;
          v41 = a3[1];
          v42 = a3[2];
          v43 = a3[3];
          v44 = a3[4];
          v45 = a3[5];
          v46 = a3[6];
          v47 = *(_DWORD *)(v61 + 9956);
          v48 = *(_DWORD *)(v61 + 9960);
          v49 = *(_DWORD *)(v61 + 9964);
          v50 = *(_DWORD *)(v61 + 9968);
          v51 = *(_DWORD *)(v61 + 9972);
          v52 = *(_DWORD *)(v61 + 9976);
          v53 = *(_DWORD *)(v61 + 9980);
          if ( *(_DWORD *)(v61 + 4) <= 5 )
            v54 = 42008593;
          else
            v54 = 8454161;
          v57 = 1;
          sub_80F552A((_DWORD *)(v61 + 20), (_DWORD *)(v61 + 10188));
          *(_DWORD *)(v61 + 10176) = *(_DWORD *)(v61 + 10172);
          *(_DWORD *)(v61 + 10172) = *(_DWORD *)(v61 + 9932);
          *(_DWORD *)(v61 + 10180) = *(_DWORD *)(v61 + 10172) & ~*(_DWORD *)(v61 + 10176);
          *(_DWORD *)(v61 + 10184) |= *(_DWORD *)(v61 + 10180);
          v28 = v61;
          v29 = *(_DWORD *)(v61 + 10304);
          v30 = dword_859B5EC;
          v31 = *(_DWORD *)(v61 + 10312);
          v32 = *(_DWORD *)(v61 + 10308);
          v33 = sub_80E6DF4(v61, dword_859B5EC);
          v34 = (long double)v37 * 0.001;
          v35 = *(_DWORD *)(v61 + 10364);
          v36 = v61 + 10392;
          sub_80EFD94((float **)&v28, (float *)&v12);
          sub_80F555A((float *)(v61 + 232), (float *)&v12, (float *)&v13);
          v11 = sub_80E9270(*(_DWORD *)(v61 + 212));
          v8 = *(_DWORD *)(v61 + 1500) + *(_DWORD *)(v61 + 1504) - v30;
          if ( v8 <= 0 )
          {
            v9 = 1.0;
          }
          else
          {
            v10 = 1.0;
            if ( v8 <= 2999 )
              v10 = (long double)v8 / 3000.0;
            v10 = (3.0 - (v10 + v10)) * v10 * v10;
            v9 = (*(float *)(v11 + 768) - 1.0) * v10 + 1.0;
          }
          sub_80EFDF0(v61, v61 + 10316, v61 + 10328, v61 + 10340, 1.0, v37);
          v15 = v28;
          v16 = v33;
          v17 = (long double)v37 * 0.001;
          sub_80F552A((_DWORD *)(v61 + 10352), &v18);
          v19 = *(_DWORD *)(v61 + 10364);
          v20 = v30;
          v21 = *(_DWORD *)(v61 + 10304);
          v22 = *(_DWORD *)(v61 + 10312);
          v23 = *(_DWORD *)(v61 + 10308);
          sub_80F552A((_DWORD *)(v61 + 10368), &v24);
          sub_80F552A((_DWORD *)(v61 + 10380), &v25);
          sub_80F552A((_DWORD *)(v61 + 10340), &v26);
          v27 = v61 + 10392;
          sub_80EF52C((int)&v15, (int)&v12);
          if ( sub_80E973E(*(_DWORD *)(v15 + 212)) && *(float *)(v15 + 220) != 0.0 && !*(_DWORD *)(v11 + 632) )
          {
            sub_80A7146((float *)&v12, (int)&v7);
            sub_80A7146((float *)&v13, (int)&v6);
            sub_80A358E((float *)&v7, (float *)&v6, (float *)&v5);
            sub_80A71F4((int)&v5, (int)&v13);
          }
          sub_80F552A(&v18, (_DWORD *)(v61 + 10352));
          *(_DWORD *)(v61 + 10364) = v19;
          sub_80F552A(&v24, (_DWORD *)(v61 + 10368));
          sub_80F552A(&v25, (_DWORD *)(v61 + 10380));
          *(_DWORD *)(v61 + 10200) = v13;
          *(_DWORD *)(v61 + 10204) = v14;
          sub_80E6D30(&s);
          if ( v58 )
            sub_80F34E0(&v59, v60, (int)&s);
          if ( *(_DWORD *)(a2[86] + 12) & 2 )
            a2[56] = 1;
          else
            a2[56] = 0;
          if ( *(_DWORD *)(a2[86] + 164) != v38 )
          {
            a2[94] = dword_859B5EC;
            a2[85] = dword_859B5EC;
          }
          if ( *(_BYTE *)(dword_8793E0C + 8) )
            sub_80F2FA4(a2[86], (int)a2, *(_DWORD *)a2[86], 1);
          else
            sub_80DD59E(a2[86], (int)a2, 1, 1u);
          sub_80F552A(a2 + 6, a2 + 78);
          sub_80F552A(&v55, a2 + 65);
          sub_80F552A(&v56, a2 + 68);
          sub_80F2B86(a2, v38);
          sub_809A45E((int)a2);
          if ( !*(_DWORD *)(a2[86] + 10156) )
            sub_80F24C6((int)a2);
          sub_80F552A((_DWORD *)(a2[86] + 20), a2 + 78);
          sub_80F54DC(a2 + 81);
          a2[82] = *(_DWORD *)(a2[86] + 236);
          sub_80F2362((int)a2, (int)&s);
          if ( *(_DWORD *)(a2[86] + 164) != v38 )
            a2[94] = dword_859B5EC;
          result = sub_811EE84(a2);
        }
      }
    }
  }
  return result;
}
// 8793E0C: using guessed type int dword_8793E0C;

//----- (080F3EA4) --------------------------------------------------------
int __usercall sub_80F3EA4@<eax>(long double a1@<st0>, int a2)
{
  _DWORD *v2; // ecx
  _DWORD *v3; // edx
  int result; // eax
  int *v5; // [esp+14h] [ebp-4h]

  v5 = (int *)((char *)&unk_8665480 + 560 * a2);
  dword_855A4E0 = &unk_859EA40;
  v2 = (_DWORD *)(v5[86] + 9956);
  v3 = (_DWORD *)(v5[86] + 9928);
  *v2 = *v3;
  v2[1] = v3[1];
  v2[2] = v3[2];
  v2[3] = v3[3];
  v2[4] = v3[4];
  v2[5] = v3[5];
  v2[6] = v3[6];
  sub_80904C6(a2, (_DWORD *)(v5[86] + 9928));
  *(_DWORD *)(v5[86] + 10168) = dword_859B5EC;
  result = dword_8793DC0;
  if ( !*(_BYTE *)(dword_8793DC0 + 8) )
    result = sub_80F35DA(a1, v5, (int *)(v5[86] + 9928));
  dword_855A4E0 = 0;
  return result;
}
// 8793DC0: using guessed type int dword_8793DC0;

//----- (080F3F74) --------------------------------------------------------
int __usercall sub_80F3F74@<eax>(long double a1@<st0>, int *a2)
{
  int result; // eax
  signed int v3; // [esp+10h] [ebp-8h]

  if ( *(_BYTE *)(dword_8793DC0 + 8) )
  {
    *(_DWORD *)(a2[86] + 9928) = dword_859B5EC;
    sub_80F35DA(a1, a2, (int *)(a2[86] + 9928));
  }
  result = a2[86];
  if ( !*(_DWORD *)(result + 10156) )
  {
    if ( a2[130] )
    {
      if ( *(_DWORD *)(a2[86] + 9896) == 1 )
        v3 = 7;
      else
        v3 = 1;
      *(_DWORD *)(a2[86] + 4) = v3;
      sub_811BD52((int)a2, 2);
      sub_811CF36(a2, a2 + 78);
      sub_811CF96(a2, a2 + 81);
      a2[3] = 1;
      a2[12] = 1;
      sub_809A45E((int)a2);
      result = sub_80F552A(a2 + 78, (_DWORD *)(a2[86] + 20));
    }
    else if ( *(_DWORD *)(a2[86] + 4) == 1 || (result = a2[86], *(_DWORD *)(result + 4) == 7) )
    {
      result = a2[86];
      --*(_DWORD *)(result + 4);
    }
  }
  return result;
}
// 8793DC0: using guessed type int dword_8793DC0;

//----- (080F40C4) --------------------------------------------------------
int __cdecl sub_80F40C4(int a1)
{
  _DWORD *v1; // ST14_4
  char *v2; // eax
  char *v3; // eax

  v1 = *(_DWORD **)(a1 + 344);
  *(_BYTE *)(a1 + 242) &= 0xFDu;
  *(_BYTE *)(a1 + 242) |= 1u;
  *(_BYTE *)(a1 + 353) = 0;
  *(_DWORD *)(a1 + 284) = 0;
  v1[3] &= 0xFC7FFFFF;
  v1[1] = 5;
  v1[40] &= 0xFFDFFFFF;
  v1[40] &= 0xFFFFFFBF;
  v1[57] = 0;
  *(_DWORD *)(a1 + 4) = 5;
  v2 = va("%i", *(_DWORD *)dword_859B600);
  sub_8090E6C(5, v2);
  v3 = va("%i", *(_DWORD *)dword_859B604);
  return sub_8090E6C(6, v3);
}

//----- (080F41C2) --------------------------------------------------------
int __cdecl sub_80F41C2(int a1)
{
  int result; // eax
  unsigned int v2; // edx
  unsigned int v3; // [esp+1Ch] [ebp-273Ch]
  char *v4; // [esp+20h] [ebp-2738h]
  char *v5; // [esp+24h] [ebp-2734h]
  int v6; // [esp+28h] [ebp-2730h]
  int v7; // [esp+2Ch] [ebp-272Ch]
  char v8; // [esp+30h] [ebp-2728h]
  int v9; // [esp+34h] [ebp-2724h]
  char v10; // [esp+90h] [ebp-26C8h]
  int v11; // [esp+94h] [ebp-26C4h]
  int v12; // [esp+130h] [ebp-2628h]
  int v13; // [esp+2748h] [ebp-10h]
  unsigned int v14; // [esp+274Ch] [ebp-Ch]

  v7 = *(_DWORD *)(a1 + 344);
  *(_BYTE *)(a1 + 242) &= 0xFDu;
  *(_BYTE *)(a1 + 242) |= 1u;
  *(_BYTE *)(a1 + 353) = 0;
  *(_DWORD *)(a1 + 284) = 0;
  *(_DWORD *)(v7 + 12) &= 0xFF7FFFFF;
  *(_DWORD *)(a1 + 4) = 5;
  *(_DWORD *)(v7 + 228) = 0;
  *(_DWORD *)(v7 + 10200) = 0;
  *(_DWORD *)(v7 + 10204) = 0;
  if ( *(_DWORD *)(v7 + 9900) < 0 )
  {
LABEL_10:
    if ( *(_DWORD *)(v7 + 10152) < 0 && !sub_80F467C(v7, 4) )
      sub_80FCD40(a1, 1);
    v13 = *(_DWORD *)(v7 + 10152);
    if ( v13 < 0
      || (v6 = *(_DWORD *)(v7 + 9908) + *(_DWORD *)(v7 + 10148), !sub_8097EDA(v13, &v6, &v10, &v8))
      || !sub_80F467C(v7, v9) )
    {
      sub_80FCAE6((char *)a1);
      *(_DWORD *)(v7 + 12) &= 0xFDFFFFFF;
      if ( sub_80F467C(v7, 2) || sub_80F467C(v7, 1) || sub_80F467C(v7, 0) )
      {
        result = v7;
        *(_DWORD *)(v7 + 12) |= 0x1000000u;
      }
      else
      {
        result = v7;
        *(_DWORD *)(v7 + 12) &= 0xFEFFFFFF;
      }
      return result;
    }
  }
  else
  {
    v13 = *(_DWORD *)(v7 + 9900);
    *(_DWORD *)(v7 + 10152) = v13;
    while ( 1 )
    {
      if ( *(_DWORD *)(v7 + 9908) < 0 )
        *(_DWORD *)(v7 + 9908) = 0;
      v6 = *(_DWORD *)(v7 + 9908) - *(_DWORD *)(v7 + 10148);
      if ( sub_8097EDA(*(_DWORD *)(v7 + 9900), &v6, &v10, &v8) )
      {
        if ( sub_80F467C(v7, v9) )
          break;
      }
      if ( !*(_DWORD *)(v7 + 9908) )
      {
        *(_DWORD *)(v7 + 9900) = -1;
        *(_DWORD *)(v7 + 10152) = -1;
        goto LABEL_10;
      }
      *(_DWORD *)(v7 + 9908) -= 50;
    }
  }
  v14 = v12 & 0xFFEFFFFF | *(_DWORD *)(v7 + 160) & 0x100000;
  v5 = (char *)v7;
  v4 = &v10;
  v3 = 9896;
  if ( v7 & 4 )
  {
    *(_DWORD *)v7 = *(_DWORD *)&v10;
    v5 += 4;
    v4 = (char *)&v11;
    v3 = 9892;
  }
  qmemcpy(v5, v4, 4 * (v3 >> 2));
  sub_81023F2((_DWORD *)v7, *(_DWORD *)a1, 2u);
  *(_DWORD *)(v7 + 160) = v14;
  *(_DWORD *)(v7 + 12) &= 0xFF7FFFFF;
  *(_DWORD *)(v7 + 12) |= 0x400000u;
  if ( *(_DWORD *)(v7 + 9900) < 0 )
  {
    *(_DWORD *)(v7 + 12) |= 0x1000000u;
    if ( sub_80F467C(v7, 4) )
    {
      result = v7;
      v2 = *(_DWORD *)(v7 + 12) | 0x2000000;
    }
    else
    {
      result = v7;
      v2 = *(_DWORD *)(v7 + 12) & 0xFDFFFFFF;
    }
    *(_DWORD *)(v7 + 12) = v2;
  }
  else
  {
    result = v7;
    *(_DWORD *)(v7 + 12) &= 0xFCFFFFFF;
  }
  return result;
}

//----- (080F467C) --------------------------------------------------------
int __cdecl sub_80F467C(int a1, char a2)
{
  return ((unsigned __int8)(*(_DWORD *)(a1 + 10048) >> a2) ^ 1) & 1;
}

//----- (080F4696) --------------------------------------------------------
signed int __cdecl sub_80F4696(int a1, _DWORD *a2)
{
  unsigned int v3; // [esp+18h] [ebp-20h]
  const void *v4; // [esp+1Ch] [ebp-1Ch]
  void *v5; // [esp+20h] [ebp-18h]
  _DWORD *v7; // [esp+28h] [ebp-10h]

  v7 = (_DWORD *)*((_DWORD *)&unk_8665480 + 140 * a1 + 86);
  if ( !(v7[3] & 0x800000) )
    return 0;
  v5 = a2;
  v4 = (const void *)*((_DWORD *)&unk_8665480 + 140 * a1 + 86);
  v3 = 9896;
  if ( (unsigned __int8)a2 & 4 )
  {
    *a2 = *v7;
    v5 = a2 + 1;
    v4 = v7 + 1;
    v3 = 9892;
  }
  qmemcpy(v5, v4, 4 * (v3 >> 2));
  memset(a2 + 490, 0, 0xF80u);
  return 1;
}

//----- (080F474A) --------------------------------------------------------
signed int __cdecl sub_80F474A(int a1)
{
  long double v1; // fst7
  float v3; // [esp+18h] [ebp-30h]
  float v4; // [esp+1Ch] [ebp-2Ch]
  int v6; // [esp+28h] [ebp-20h]
  float v7; // [esp+2Ch] [ebp-1Ch]
  float *v8; // [esp+34h] [ebp-14h]
  float v9; // [esp+38h] [ebp-10h]
  float v10; // [esp+3Ch] [ebp-Ch]
  float v11; // [esp+40h] [ebp-8h]
  int v12; // [esp+44h] [ebp-4h]

  if ( !(*(_DWORD *)(*(_DWORD *)(a1 + 344) + 12) & 0x800000) )
    return 0;
  if ( *(_DWORD *)(*(_DWORD *)(a1 + 344) + 9896) )
    return 0;
  if ( *(_DWORD *)(a1 + 284) != 0x2000000 && *(_DWORD *)(a1 + 284) != 0x4000000 )
    return 0;
  v8 = (float *)&unk_8665480;
  v12 = 0;
  while ( 1 )
  {
    if ( v12 >= dword_859B5E4 )
      return 0;
    if ( *((_BYTE *)v8 + 252)
      && *(_DWORD *)(*((_DWORD *)v8 + 86) + 12) & 0x800000
      && !*(_DWORD *)(*((_DWORD *)v8 + 86) + 9896)
      && v8 != (float *)a1
      && *((_DWORD *)v8 + 86)
      && *((_DWORD *)v8 + 101) > 0
      && (*((_DWORD *)v8 + 71) == 0x2000000 || *((_DWORD *)v8 + 71) == 0x4000000)
      && v8[72] <= (long double)*(float *)(a1 + 300)
      && *(float *)(a1 + 288) <= (long double)v8[75]
      && v8[73] <= (long double)*(float *)(a1 + 304)
      && *(float *)(a1 + 292) <= (long double)v8[76]
      && v8[74] <= (long double)*(float *)(a1 + 308)
      && *(float *)(a1 + 296) <= (long double)v8[77] )
    {
      sub_80F543C(v8 + 78, (float *)(a1 + 312), (float *)&v6);
      v11 = *(float *)(a1 + 272) + v8[68];
      v1 = sub_80F548E((float *)&v6);
      if ( v1 <= v11 * v11 )
        break;
    }
    ++v12;
    v8 += 140;
  }
  sub_80F543C(v8 + 78, (float *)(a1 + 312), (float *)&v6);
  *(float *)&v6 = sub_80A142E() + *(float *)&v6;
  v7 = sub_80A142E() + v7;
  sub_80A215E((float *)&v6);
  if ( sub_80F54B0(*((_DWORD *)v8 + 86) + 32) <= 0.0 )
    v4 = 0.0;
  else
    v4 = (long double)*(signed int *)(dword_8793DC4 + 8);
  v9 = v4;
  if ( sub_80F54B0(*(_DWORD *)(a1 + 344) + 32) <= 0.0 )
    v3 = 0.0;
  else
    v3 = (long double)*(signed int *)(dword_8793DC4 + 8);
  v10 = v3;
  if ( v9 < 0.000099999997 && v10 < 0.000099999997 )
  {
    v9 = (long double)*(signed int *)(*((_DWORD *)v8 + 86) + 80);
    v10 = (long double)*(signed int *)(*(_DWORD *)(a1 + 344) + 80);
  }
  sub_80F5468((int)&v6, v9, *((_DWORD *)v8 + 86) + 32);
  *(_DWORD *)(*((_DWORD *)v8 + 86) + 16) = 300;
  *(_DWORD *)(*((_DWORD *)v8 + 86) + 12) |= 0x200u;
  sub_80F5468((int)&v6, COERCE_FLOAT(LODWORD(v10) ^ 0x80000000), *(_DWORD *)(a1 + 344) + 32);
  *(_DWORD *)(*(_DWORD *)(a1 + 344) + 16) = 300;
  *(_DWORD *)(*(_DWORD *)(a1 + 344) + 12) |= 0x200u;
  return 1;
}
// 80F54B0: using guessed type double __cdecl sub_80F54B0(_DWORD);
// 859B5E4: using guessed type int dword_859B5E4;
// 8793DC4: using guessed type int dword_8793DC4;

//----- (080F4B46) --------------------------------------------------------
signed int __cdecl sub_80F4B46(int *a1, int a2)
{
  int v2; // ST14_4
  int v3; // eax

  v2 = 1208 * a1[36] + 140846652;
  dword_855A4E0 = &unk_859EA40;
  v3 = sub_806289C(*a1);
  return sub_80D954C(v3, (int)a1, a2, v2, dword_859B5F4);
}
// 859B5F4: using guessed type int dword_859B5F4;

//----- (080F4BA4) --------------------------------------------------------
signed int __cdecl sub_80F4BA4(int a1)
{
  int v2; // [esp+14h] [ebp-24h]
  signed int v3; // [esp+18h] [ebp-20h]
  signed int i; // [esp+1Ch] [ebp-1Ch]
  char *src; // [esp+20h] [ebp-18h]
  char *s2; // [esp+24h] [ebp-14h]
  char *s2a; // [esp+24h] [ebp-14h]
  int v8; // [esp+2Ch] [ebp-Ch]

  v2 = *(_DWORD *)(a1 + 344);
  v8 = 1208 * *(_DWORD *)(a1 + 144) + 140846652;
  v3 = 0;
  s2 = sub_811B124(*(unsigned __int8 *)(a1 + 356));
  *(_DWORD *)(v2 + 10064) = *(unsigned __int8 *)(a1 + 356);
  if ( strcmp((const char *)(v8 + 64), s2) )
  {
    v3 = 1;
    I_strncpyz((char *)(v8 + 64), s2, 64);
  }
  for ( i = 0; i <= 5; ++i )
  {
    if ( *(_BYTE *)(i + a1 + 528) )
    {
      s2a = sub_811B124(*(unsigned __int8 *)(i + a1 + 528));
      *(_DWORD *)(v2 + 4 * i + 10068) = *(unsigned __int8 *)(i + a1 + 528);
      if ( strcmp((const char *)(v8 + (i << 6) + 128), s2a) )
      {
        v3 = 1;
        I_strncpyz((char *)(v8 + (i << 6) + 128), s2a, 64);
      }
      src = (char *)sub_8078896(*(unsigned __int16 *)(a1 + 2 * i + 536));
      *(_DWORD *)(v2 + 4 * i + 10092) = sub_811B13C(src);
      if ( strcmp((const char *)(v8 + (i << 6) + 512), src) )
      {
        v3 = 1;
        I_strncpyz((char *)(v8 + (i << 6) + 512), src, 64);
      }
    }
    else
    {
      *(_BYTE *)(v8 + (i << 6) + 128) = 0;
      *(_BYTE *)(v8 + (i << 6) + 512) = 0;
      *(_DWORD *)(v2 + 4 * i + 10068) = 0;
      *(_DWORD *)(v2 + 4 * i + 10092) = 0;
    }
  }
  return v3;
}

//----- (080F4DBE) --------------------------------------------------------
int __usercall sub_80F4DBE@<eax>(long double a1@<st0>, int a2)
{
  int result; // eax
  unsigned int v3; // edx
  unsigned int v4; // edx
  int v5; // ST2C_4
  char v6; // [esp+17h] [ebp-61h]
  signed int v7; // [esp+1Ch] [ebp-5Ch]
  char v8; // [esp+30h] [ebp-48h]
  char v9; // [esp+40h] [ebp-38h]
  int v10; // [esp+50h] [ebp-28h]
  int v11; // [esp+54h] [ebp-24h]
  int v12; // [esp+58h] [ebp-20h]
  signed int *v13; // [esp+5Ch] [ebp-1Ch]
  char v14; // [esp+60h] [ebp-18h]

  v10 = *(_DWORD *)(a2 + 344);
  *(_BYTE *)(a2 + 358) = 10;
  *(_DWORD *)(v10 + 1956) = 0;
  v11 = sub_80F4BA4(a2);
  if ( *(_DWORD *)(v10 + 9924) == 2 )
  {
    if ( *(_DWORD *)(v10 + 9896) == 3 )
    {
      sub_80F40C4(a2);
      result = *(_DWORD *)(a2 + 344);
      *(_DWORD *)(result + 10184) = 0;
    }
    else if ( *(_DWORD *)(v10 + 9896) == 2 )
    {
      sub_80F41C2(a2);
      result = *(_DWORD *)(a2 + 344);
      *(_DWORD *)(result + 10184) = 0;
    }
    else if ( *(_DWORD *)(v10 + 204) == *(_DWORD *)a2 )
    {
      *(_BYTE *)(a2 + 242) |= 2u;
      *(_BYTE *)(a2 + 242) &= 0xFEu;
      *(_BYTE *)(a2 + 353) = 1;
      *(_DWORD *)(v10 + 12) |= 0x800000u;
      *(_DWORD *)(v10 + 12) &= 0xFCFFFFFF;
      *(_DWORD *)(v10 + 228) = *(_DWORD *)(v10 + 10044);
      sub_80F2F2E(a2);
      *(_DWORD *)(v10 + 10268) = 0;
      if ( *(_DWORD *)(v10 + 10300) <= dword_859B5EC )
        *(_DWORD *)(v10 + 160) &= 0xFFBFFFFF;
      if ( *(_DWORD *)(v10 + 10156) )
      {
        *(_DWORD *)(v10 + 4) = 2;
      }
      else if ( *(_DWORD *)(v10 + 10160) )
      {
        *(_DWORD *)(v10 + 4) = 3;
      }
      else if ( *(_DWORD *)(v10 + 9896) == 1 )
      {
        if ( *(_DWORD *)(a2 + 520) )
          v7 = 7;
        else
          v7 = 6;
        *(_DWORD *)(v10 + 4) = v7;
        *(_BYTE *)(a2 + 242) |= 1u;
        *(_BYTE *)(a2 + 242) &= 0xFDu;
        *(_BYTE *)(a2 + 353) = 0;
      }
      else
      {
        *(_DWORD *)(v10 + 4) = *(_DWORD *)(a2 + 520) != 0;
      }
      *(_DWORD *)(v10 + 72) = (signed int)*(float *)(dword_8793D94 + 8);
      *(_DWORD *)(v10 + 80) = *(_DWORD *)(dword_8793D90 + 8);
      *(float *)(v10 + 10256) = *(float *)(v10 + 1492) / 255.0;
      sub_811FB7A((int *)a2);
      sub_811F736(a2);
      sub_80F20C8(a2);
      if ( dword_859B5EC - *(_DWORD *)(v10 + 10168) <= 1000 )
        v3 = *(_DWORD *)(a2 + 8) & 0xFFFFFF7F;
      else
        v3 = *(_DWORD *)(a2 + 8) | 0x80;
      *(_DWORD *)(a2 + 8) = v3;
      *(_DWORD *)(v10 + 300) = *(_DWORD *)(a2 + 404);
      sub_80F2350(a2);
      if ( *(_BYTE *)(dword_8793E0C + 8) )
        sub_80F2FA4(v10, a2, *(_DWORD *)v10, 1);
      else
        sub_80DD59E(v10, a2, 1, 1u);
      if ( *(_DWORD *)(a2 + 404) > 0 && sub_80F474A(a2) )
        *(_DWORD *)(a2 + 284) = 0x4000000;
      sub_80F61BE(a2, (float *)&v14);
      *(_DWORD *)(v10 + 1444) = sub_80F6ED0(a2, (float *)&v14, *(_DWORD *)(v10 + 10296));
      if ( *(_DWORD *)(v10 + 1444) )
      {
        *(_DWORD *)(v10 + 10296) = *(_DWORD *)(v10 + 1444) & 0x3F;
        if ( dword_8665488[140 * *(_DWORD *)(v10 + 10296)] & 0x400000 )
          v4 = *(_DWORD *)(v10 + 160) | 0x800000;
        else
          v4 = *(_DWORD *)(v10 + 160) & 0xFF7FFFFF;
        *(_DWORD *)(v10 + 160) = v4;
      }
      else
      {
        *(_DWORD *)(v10 + 10296) = 1023;
      }
      if ( *(_DWORD *)(a2 + 4) == 1 )
      {
        if ( *(_DWORD *)(a2 + 404) <= 0 )
          v6 = 11;
        else
          v6 = 9;
        *(_BYTE *)(a2 + 358) = v6;
        v12 = *(_DWORD *)(a2 + 144);
        v13 = (signed int *)(1208 * v12 + 140846652);
        *((_DWORD *)&unk_8652A1C + 302 * v12) = *(_DWORD *)(a2 + 108);
        v13[249] = *(_DWORD *)(a2 + 212);
        sub_80F552A((_DWORD *)(v10 + 232), v13 + 250);
        if ( v11 )
          sub_811BEEE((int *)a2);
        v5 = sub_806289C(*(_DWORD *)a2);
        sub_80D978C(v5, (_DWORD *)a2, (int)v13, *(unsigned __int8 *)(a2 + 357));
        sub_80D9698(v5, (_DWORD *)a2, v13);
        if ( *(_DWORD *)(v10 + 12) & 0x800000 && *(_DWORD *)(v10 + 160) & 0x300 )
          sub_8109672((_DWORD *)(dword_859B404 + 560 * *(_DWORD *)(v10 + 1428)));
        if ( *(_BYTE *)(dword_8793E34 + 8) )
        {
          if ( sub_8090A5A((int *)a2) )
          {
            sub_811BF30(a2);
            sub_80909E8();
          }
        }
        result = *(_DWORD *)(a2 + 344);
        *(_DWORD *)(result + 10184) = 0;
      }
      else
      {
        result = *(_DWORD *)(a2 + 344);
        *(_DWORD *)(result + 10184) = 0;
      }
    }
    else
    {
      sub_80F552A((_DWORD *)(v10 + 20), &v9);
      sub_80F5506(&v8, 0, *(_DWORD *)(v10 + 236), 0);
      sub_80F69B4(a1, a2, &v9, &v8);
      result = *(_DWORD *)(a2 + 344);
      *(_DWORD *)(result + 10184) = 0;
    }
  }
  else
  {
    result = *(_DWORD *)(a2 + 344);
    *(_DWORD *)(result + 10184) = 0;
  }
  return result;
}
// 859B404: using guessed type int dword_859B404;
// 8665488: using guessed type int dword_8665488[];
// 8793D90: using guessed type int dword_8793D90;
// 8793D94: using guessed type int dword_8793D94;
// 8793E0C: using guessed type int dword_8793E0C;
// 8793E34: using guessed type int dword_8793E34;

//----- (080F53E0) --------------------------------------------------------
int __cdecl sub_80F53E0(int a1, signed int a2)
{
  int result; // eax
  char v3; // [esp+20h] [ebp-18h]

  result = a2;
  if ( a2 >= 158 && (a2 <= 160 || a2 == 175) )
    result = sub_80EE226(dword_86655D8[140 * a1], (float *)(dword_86655D8[140 * a1] + 10380), (int)&v3);
  return result;
}
// 86655D8: using guessed type int dword_86655D8[];

//----- (080F543C) --------------------------------------------------------
int __cdecl sub_80F543C(float *a1, float *a2, float *a3)
{
  int result; // eax

  *a3 = *a1 - *a2;
  result = (int)(a1 + 1);
  a3[1] = a1[1] - a2[1];
  return result;
}

//----- (080F5468) --------------------------------------------------------
int __cdecl sub_80F5468(int a1, float a2, int a3)
{
  int result; // eax

  *(float *)a3 = a2 * *(float *)a1;
  result = a1 + 4;
  *(float *)(a3 + 4) = a2 * *(float *)(a1 + 4);
  return result;
}

//----- (080F548E) --------------------------------------------------------
long double __cdecl sub_80F548E(float *a1)
{
  return *a1 * *a1 + a1[1] * a1[1];
}

//----- (080F54B0) --------------------------------------------------------
void __cdecl sub_80F54B0(float *a1)
{
  float v1; // ST00_4

  v1 = *a1 * *a1 + a1[1] * a1[1];
  sub_80F5616(v1);
}

//----- (080F54DC) --------------------------------------------------------
int __cdecl sub_80F54DC(_DWORD *a1)
{
  int result; // eax

  *a1 = 0;
  a1[1] = 0;
  result = 0;
  a1[2] = 0;
  return result;
}

//----- (080F5506) --------------------------------------------------------
int __cdecl sub_80F5506(_DWORD *a1, int a2, int a3, int a4)
{
  int result; // eax

  *a1 = a2;
  a1[1] = a3;
  result = a4;
  a1[2] = a4;
  return result;
}

//----- (080F552A) --------------------------------------------------------
int __cdecl sub_80F552A(_DWORD *a1, _DWORD *a2)
{
  int result; // eax

  *a2 = *a1;
  a2[1] = a1[1];
  result = a1[2];
  a2[2] = result;
  return result;
}

//----- (080F555A) --------------------------------------------------------
int __cdecl sub_80F555A(float *a1, float *a2, float *a3)
{
  int result; // eax

  *a3 = *a1 + *a2;
  a3[1] = a1[1] + a2[1];
  result = (int)(a1 + 2);
  a3[2] = a1[2] + a2[2];
  return result;
}

//----- (080F559E) --------------------------------------------------------
int __cdecl sub_80F559E(float *a1, float *a2, float *a3)
{
  int result; // eax

  *a3 = *a1 - *a2;
  a3[1] = a1[1] - a2[1];
  result = (int)(a1 + 2);
  a3[2] = a1[2] - a2[2];
  return result;
}

//----- (080F55E2) --------------------------------------------------------
long double __cdecl sub_80F55E2(float *a1, float *a2)
{
  return *a1 * *a2 + a1[1] * a2[1] + a1[2] * a2[2];
}

//----- (080F5616) --------------------------------------------------------
long double __cdecl sub_80F5616(float a1)
{
  return (float)sqrt(a1);
}

//----- (080F5638) --------------------------------------------------------
void __cdecl sub_80F5638(int a1, _DWORD *a2)
{
  char *v2; // eax

  v2 = va("player field %s is read-only", *a2);
  sub_8084DB4((int)v2);
}

//----- (080F565E) --------------------------------------------------------
void __cdecl sub_80F565E(int a1)
{
  int v1; // eax
  char *v2; // eax
  unsigned __int16 v3; // [esp+16h] [ebp-2h]

  v3 = sub_80843C0(0);
  if ( v3 == word_87A22A4 )
  {
    *(_DWORD *)(a1 + 10060) = 1;
  }
  else if ( v3 == word_87A22A2 )
  {
    *(_DWORD *)(a1 + 10060) = 2;
  }
  else if ( v3 == word_87A22E8 )
  {
    *(_DWORD *)(a1 + 10060) = 3;
  }
  else if ( v3 == word_87A2314 )
  {
    *(_DWORD *)(a1 + 10060) = 0;
  }
  else
  {
    v1 = sub_8078896(v3);
    v2 = va("'%s' is an illegal sessionteam string. Must be allies, axis, none, or spectator.", v1);
    sub_8084DB4((int)v2);
  }
  sub_80F6506(1682649625 * ((a1 - dword_859B400) >> 2));
  sub_8107356();
}
// 859B400: using guessed type int dword_859B400;
// 87A22A2: using guessed type __int16 word_87A22A2;
// 87A22A4: using guessed type __int16 word_87A22A4;
// 87A22E8: using guessed type __int16 word_87A22E8;
// 87A2314: using guessed type __int16 word_87A2314;

//----- (080F572C) --------------------------------------------------------
int __cdecl sub_80F572C(int a1)
{
  int result; // eax
  signed int v2; // [esp+4h] [ebp-4h]

  result = *(_DWORD *)(a1 + 10060);
  v2 = *(_DWORD *)(a1 + 10060);
  if ( v2 == 1 )
    return sub_8084C8E((unsigned __int16)word_87A22A4);
  if ( v2 > 1 )
  {
    if ( v2 == 2 )
    {
      result = sub_8084C8E((unsigned __int16)word_87A22A2);
    }
    else if ( v2 == 3 )
    {
      result = sub_8084C8E((unsigned __int16)word_87A22E8);
    }
  }
  else if ( !v2 )
  {
    result = sub_8084C8E((unsigned __int16)word_87A2314);
  }
  return result;
}
// 87A22A2: using guessed type __int16 word_87A22A2;
// 87A22A4: using guessed type __int16 word_87A22A4;
// 87A22E8: using guessed type __int16 word_87A22E8;
// 87A2314: using guessed type __int16 word_87A2314;

//----- (080F57A4) --------------------------------------------------------
void __cdecl sub_80F57A4(int a1)
{
  int v1; // eax
  char *v2; // eax
  unsigned __int16 v3; // [esp+16h] [ebp-2h]

  v3 = sub_80843C0(0);
  if ( v3 == word_87A2312 )
  {
    *(_DWORD *)(a1 + 9896) = 0;
  }
  else if ( v3 == word_87A2316 )
  {
    *(_DWORD *)(a1 + 9896) = 1;
  }
  else if ( v3 == word_87A22E8 )
  {
    *(_DWORD *)(a1 + 9896) = 2;
  }
  else if ( v3 == word_87A230E )
  {
    *(_DWORD *)(a1 + 160) ^= 2u;
    *(_DWORD *)(a1 + 9896) = 3;
  }
  else
  {
    v1 = sub_8078896(v3);
    v2 = va("'%s' is an illegal sessionstate string. Must be playing, dead, spectator, or intermission.", v1);
    sub_8084DB4((int)v2);
  }
}
// 87A22E8: using guessed type __int16 word_87A22E8;
// 87A230E: using guessed type __int16 word_87A230E;
// 87A2312: using guessed type __int16 word_87A2312;
// 87A2316: using guessed type __int16 word_87A2316;

//----- (080F5868) --------------------------------------------------------
int __cdecl sub_80F5868(int a1)
{
  int result; // eax
  signed int v2; // [esp+4h] [ebp-4h]

  result = *(_DWORD *)(a1 + 9896);
  v2 = *(_DWORD *)(a1 + 9896);
  if ( v2 == 1 )
    return sub_8084C8E((unsigned __int16)word_87A2316);
  if ( v2 > 1 )
  {
    if ( v2 == 2 )
    {
      result = sub_8084C8E((unsigned __int16)word_87A22E8);
    }
    else if ( v2 == 3 )
    {
      result = sub_8084C8E((unsigned __int16)word_87A230E);
    }
  }
  else if ( !v2 )
  {
    result = sub_8084C8E((unsigned __int16)word_87A2312);
  }
  return result;
}
// 87A22E8: using guessed type __int16 word_87A22E8;
// 87A230E: using guessed type __int16 word_87A230E;
// 87A2312: using guessed type __int16 word_87A2312;
// 87A2316: using guessed type __int16 word_87A2316;

//----- (080F58E0) --------------------------------------------------------
int __cdecl sub_80F58E0(_DWORD *a1)
{
  int result; // eax

  a1[2506] = sub_808404C(0);
  if ( a1[2506] <= 0 )
    a1[2506] = 1;
  if ( a1[75] > a1[2506] )
    a1[75] = a1[2506];
  *((_DWORD *)&unk_8665480 + 421488044 * (((signed int)a1 - dword_859B400) >> 2) + 101) = a1[75];
  result = a1[2506];
  a1[77] = result;
  return result;
}
// 859B400: using guessed type int dword_859B400;

//----- (080F598C) --------------------------------------------------------
void __cdecl sub_80F598C(int a1)
{
  *(_DWORD *)(a1 + 9912) = sub_808404C(0);
  sub_8107356();
}

//----- (080F59B4) --------------------------------------------------------
int __cdecl sub_80F59B4(int a1)
{
  int result; // eax
  int v2; // [esp+4h] [ebp-4h]

  v2 = sub_808404C(0);
  if ( v2 < -1 || v2 > 63 )
    sub_8084DB4((int)"spectatorclient can only be set to -1, or a valid client number");
  result = v2;
  *(_DWORD *)(a1 + 9900) = v2;
  return result;
}

//----- (080F59F2) --------------------------------------------------------
int __cdecl sub_80F59F2(int a1)
{
  char *v1; // eax
  int result; // eax

  v1 = (char *)sub_808456A(0);
  result = sub_811114A(v1);
  *(_DWORD *)(a1 + 9904) = result;
  return result;
}

//----- (080F5A22) --------------------------------------------------------
int __cdecl sub_80F5A22(int a1)
{
  char s; // [esp+10h] [ebp-408h]

  if ( !*(_DWORD *)(a1 + 9904) )
    return Scr_AddString(byte_8150A80);
  sub_809107E(*(_DWORD *)(a1 + 9904) + 22, &s, 1024);
  return Scr_AddString(&s);
}

//----- (080F5A7C) --------------------------------------------------------
int __cdecl sub_80F5A7C(int a1)
{
  char *v1; // ST0C_4
  char *v2; // eax
  int result; // eax

  v1 = (char *)&unk_8665480 + 1685952176 * ((a1 - dword_859B400) >> 2);
  v2 = (char *)sub_808456A(0);
  result = sub_81112E8(v2);
  *((_DWORD *)v1 + 37) = result;
  return result;
}
// 859B400: using guessed type int dword_859B400;

//----- (080F5AD2) --------------------------------------------------------
int __cdecl sub_80F5AD2(int a1)
{
  int result; // eax
  char s; // [esp+10h] [ebp-418h]
  int v3; // [esp+41Ch] [ebp-Ch]

  v3 = (int)&unk_8665480 + 1685952176 * ((a1 - dword_859B400) >> 2);
  if ( !*(_DWORD *)(v3 + 148) )
    return Scr_AddString(byte_8150A80);
  result = v3;
  if ( *(_DWORD *)(v3 + 148) <= 15 )
  {
    sub_809107E(*(_DWORD *)(v3 + 148) + 30, &s, 1024);
    result = Scr_AddString(&s);
  }
  return result;
}
// 859B400: using guessed type int dword_859B400;

//----- (080F5B5E) --------------------------------------------------------
void __cdecl sub_80F5B5E(int a1)
{
  int v1; // eax
  char *v2; // eax
  char *v3; // [esp+10h] [ebp-8h]
  unsigned __int16 v4; // [esp+16h] [ebp-2h]

  v3 = (char *)&unk_8665480 + 1685952176 * ((a1 - dword_859B400) >> 2);
  v4 = sub_80843C0(0);
  if ( v4 == word_87A2314 )
  {
    *((_DWORD *)v3 + 38) = 0;
  }
  else if ( v4 == word_87A22A2 )
  {
    *((_DWORD *)v3 + 38) = 2;
  }
  else if ( v4 == word_87A22A4 )
  {
    *((_DWORD *)v3 + 38) = 1;
  }
  else if ( v4 == word_87A22E8 )
  {
    v1 = sub_8078896(v4);
    v2 = va("'%s' is an illegal head icon team string. Must be none, allies, axis, or spectator.", v1);
    sub_8084DB4((int)v2);
  }
  else
  {
    *((_DWORD *)v3 + 38) = 3;
  }
}
// 859B400: using guessed type int dword_859B400;
// 87A22A2: using guessed type __int16 word_87A22A2;
// 87A22A4: using guessed type __int16 word_87A22A4;
// 87A22E8: using guessed type __int16 word_87A22E8;
// 87A2314: using guessed type __int16 word_87A2314;

//----- (080F5C30) --------------------------------------------------------
int __cdecl sub_80F5C30(int a1)
{
  signed int v2; // [esp+10h] [ebp-8h]

  v2 = *((_DWORD *)&unk_8665480 + 421488044 * ((a1 - dword_859B400) >> 2) + 38);
  if ( v2 == 2 )
    return sub_8084C8E((unsigned __int16)word_87A22A2);
  if ( v2 > 2 )
  {
    if ( v2 == 3 )
      return sub_8084C8E((unsigned __int16)word_87A22E8);
  }
  else if ( v2 == 1 )
  {
    return sub_8084C8E((unsigned __int16)word_87A22A4);
  }
  return sub_8084C8E((unsigned __int16)word_87A2314);
}
// 859B400: using guessed type int dword_859B400;
// 87A22A2: using guessed type __int16 word_87A22A2;
// 87A22A4: using guessed type __int16 word_87A22A4;
// 87A22E8: using guessed type __int16 word_87A22E8;
// 87A2314: using guessed type __int16 word_87A2314;

//----- (080F5CC8) --------------------------------------------------------
__int16 __cdecl sub_80F5CC8(int a1)
{
  long double v1; // fst7
  __int16 result; // ax
  __int16 v3; // [esp+12h] [ebp-6h]

  v1 = sub_8084320(0);
  result = v3 | 0xC00;
  *(_DWORD *)(a1 + 9908) = (signed int)(v1 * 1000.0);
  return result;
}

//----- (080F5D08) --------------------------------------------------------
int __cdecl sub_80F5D08(int a1)
{
  int v1; // ST00_4

  *(float *)&v1 = (long double)*(signed int *)(a1 + 9908) * 0.001;
  return Scr_AddFloat(v1);
}

//----- (080F5D2A) --------------------------------------------------------
int __cdecl sub_80F5D2A(int a1)
{
  int result; // eax

  result = sub_808404C(0);
  *(_DWORD *)(a1 + 10148) = result;
  return result;
}

//----- (080F5D4C) --------------------------------------------------------
int __cdecl sub_80F5D4C(int a1)
{
  return Scr_AddInt(*(_DWORD *)(a1 + 9908));
}

//----- (080F5D66) --------------------------------------------------------
void **sub_80F5D66()
{
  void **result; // eax
  void **i; // [esp+14h] [ebp-4h]

  for ( i = (void **)&off_8150B80; ; i += 5 )
  {
    result = i;
    if ( !*i )
      break;
    sub_807E1F6(0, *i, -13107 * (((char *)i - (char *)&off_8150B80) >> 2) | 0xC000);
  }
  return result;
}
// 8150B80: using guessed type char *off_8150B80;

//----- (080F5DBC) --------------------------------------------------------
int __cdecl sub_80F5DBC(int a1, int a2)
{
  int result; // eax
  char **v3; // [esp+14h] [ebp-4h]

  v3 = &(&off_8150B80)[5 * a2];
  if ( v3[3] )
    result = ((int (__cdecl *)(int, char **))v3[3])(a1, v3);
  else
    result = sub_81188EE(a1, (int)v3[2], (int)v3[1]);
  return result;
}
// 8150B80: using guessed type char *off_8150B80;

//----- (080F5E1E) --------------------------------------------------------
int __cdecl sub_80F5E1E(int a1, int a2)
{
  int result; // eax
  char **v3; // [esp+14h] [ebp-4h]

  v3 = &(&off_8150B80)[5 * a2];
  if ( v3[4] )
    result = ((int (__cdecl *)(int, char **))v3[4])(a1, v3);
  else
    result = sub_8118AAC(a1, (int)v3[2], (int)v3[1]);
  return result;
}
// 8150B80: using guessed type char *off_8150B80;

//----- (080F5E80) --------------------------------------------------------
int __usercall sub_80F5E80@<eax>(long double a1@<st0>, int a2, _DWORD *a3)
{
  float v3; // ST1C_4
  long double v4; // fst7
  float v5; // ST1C_4
  float v7; // [esp+0h] [ebp-48h]
  float v8; // [esp+0h] [ebp-48h]
  float v9; // [esp+1Ch] [ebp-2Ch]
  float v10; // [esp+1Ch] [ebp-2Ch]
  float v11; // [esp+1Ch] [ebp-2Ch]
  float v12; // [esp+1Ch] [ebp-2Ch]
  float v13; // [esp+20h] [ebp-28h]
  float v14; // [esp+24h] [ebp-24h]
  int i; // [esp+3Ch] [ebp-Ch]

  sub_80F739A(a3, &v13);
  if ( *(_BYTE *)(*(_DWORD *)(a2 + 344) + 12) & 1 && !(*(_DWORD *)(*(_DWORD *)(a2 + 344) + 160) & 0x300) )
  {
    sub_80A6258(*(float *)(*(_DWORD *)(a2 + 344) + 1412), v14);
    v3 = a1;
    v9 = sub_80A6112(v3);
    if ( v9 > 45.0 || (v4 = v9, v9 < -45.0) )
    {
      if ( v9 <= 45.0 )
        v10 = v9 + 45.0;
      else
        v10 = v9 - 45.0;
      *(_DWORD *)(*(_DWORD *)(a2 + 344) + 88) += (unsigned __int16)(signed int)(v10 * 182.04445);
      if ( v10 <= 0.0 )
        v7 = *(float *)(*(_DWORD *)(a2 + 344) + 1412) + 45.0;
      else
        v7 = *(float *)(*(_DWORD *)(a2 + 344) + 1412) - 45.0;
      v4 = sub_80A60CE(v7);
      v14 = v4;
    }
    sub_80A6258(*(float *)(*(_DWORD *)(a2 + 344) + 1420), v13);
    v5 = v4;
    v11 = sub_80A6112(v5);
    if ( v11 > 45.0 || v11 < -15.0 )
    {
      if ( v11 <= 45.0 )
        v12 = v11 + 15.0;
      else
        v12 = v11 - 45.0;
      *(_DWORD *)(*(_DWORD *)(a2 + 344) + 84) += (unsigned __int16)(signed int)(v12 * 182.04445);
      if ( v12 <= 0.0 )
        v8 = *(float *)(*(_DWORD *)(a2 + 344) + 1420) + 15.0;
      else
        v8 = *(float *)(*(_DWORD *)(a2 + 344) + 1420) - 45.0;
      v13 = sub_80A6112(v8);
    }
  }
  for ( i = 0; i <= 2; ++i )
    *(_DWORD *)(*(_DWORD *)(a2 + 344) + 4 * i + 84) = (unsigned __int16)(signed int)(*(&v13 + i) * 182.04445)
                                                    - *(_DWORD *)(*(_DWORD *)(a2 + 344) + 4 * i + 9940);
  sub_80F739A(&v13, (_DWORD *)(a2 + 324));
  return sub_80F739A((_DWORD *)(a2 + 324), (_DWORD *)(*(_DWORD *)(a2 + 344) + 232));
}

//----- (080F61BE) --------------------------------------------------------
void __cdecl sub_80F61BE(int a1, float *a2)
{
  float v2; // ST24_4
  float v3; // ST20_4
  float v4; // ST2C_4
  float v5; // ST28_4
  int v6; // [esp+30h] [ebp-28h]
  int v7; // [esp+4Ch] [ebp-Ch]

  v7 = *(_DWORD *)(a1 + 344);
  if ( *(_DWORD *)(v7 + 160) & 0x300 )
  {
    if ( !sub_811C16A((int)&unk_8665480 + 560 * *(_DWORD *)(v7 + 1428), (unsigned __int16)word_87A233A, a2) )
      Com_Error(1, &byte_8150CC0);
  }
  else
  {
    sub_80F739A((_DWORD *)(v7 + 20), a2);
    a2[2] = a2[2] + *(float *)(v7 + 248);
    v2 = sub_80EE4AA(v7);
    v3 = sub_80E6DF4(v7, dword_859B5EC);
    v4 = sub_80EE506(v7, v2, v3, *(float *)(dword_85760C4 + 8));
    a2[2] = a2[2] + v4;
    v5 = sub_80EE5C6(v7, v2, v3, *(float *)(dword_85760C4 + 8));
    sub_80F63A0(a1, 0, (float *)&v6, 0);
    sub_80F73CA((int)a2, v5, (int)&v6, (int)a2);
    sub_80B66C0((int)a2, *(_DWORD *)(v7 + 236), *(float *)(v7 + 76), 16.0, 20.0);
    if ( *(float *)(v7 + 28) + 8.0 > a2[2] )
      a2[2] = *(float *)(v7 + 28) + 8.0;
  }
}
// 85760C4: using guessed type int dword_85760C4;
// 87A233A: using guessed type __int16 word_87A233A;

//----- (080F63A0) --------------------------------------------------------
void __cdecl sub_80F63A0(int a1, int a2, float *a3, float *a4)
{
  sub_80A2EC2((float *)(*(_DWORD *)(a1 + 344) + 232), a2, a3, a4);
}

//----- (080F63D4) --------------------------------------------------------
char *__cdecl sub_80F63D4(char *a1, char *a2, int a3)
{
  char *v3; // eax
  char *v4; // eax
  char *result; // eax
  int v6; // [esp+14h] [ebp-14h]
  char *dest; // [esp+18h] [ebp-10h]
  char v8; // [esp+1Fh] [ebp-9h]
  int v9; // [esp+20h] [ebp-8h]
  int v10; // [esp+24h] [ebp-4h]
  char *v11; // [esp+34h] [ebp+Ch]
  int v12; // [esp+38h] [ebp+10h]

  v12 = a3 - 1;
  v10 = 0;
  v9 = 0;
  dest = a2;
  *a2 = 0;
  v6 = 0;
  while ( 1 )
  {
    v3 = a1++;
    v8 = *v3;
    if ( !*v3 )
      break;
    if ( *dest || v8 != 32 )
    {
      if ( v8 == 94 )
      {
        if ( !*a1 )
          break;
        if ( (unsigned __int8)sub_80B4D14(*a1) )
        {
          if ( v10 > v12 - 2 )
            break;
          *a2 = 94;
          v11 = a2 + 1;
          v4 = a1++;
          *v11 = *v4;
          a2 = v11 + 1;
          v10 += 2;
        }
        else
        {
          ++a1;
        }
      }
      else if ( v8 == 32 )
      {
        if ( ++v6 <= 3 )
          goto LABEL_15;
      }
      else
      {
        v6 = 0;
LABEL_15:
        if ( v10 > v12 - 1 )
          break;
        *a2++ = v8;
        ++v9;
        ++v10;
      }
    }
  }
  *a2 = 0;
  result = dest;
  if ( !*dest || !v9 )
    result = I_strncpyz(dest, "UnnamedPlayer", v12);
  return result;
}

//----- (080F6506) --------------------------------------------------------
int __cdecl sub_80F6506(int a1)
{
  int v1; // ebx
  int result; // eax
  char dest; // [esp+20h] [ebp-828h]
  int v4; // [esp+42Ch] [ebp-41Ch]
  char v5; // [esp+430h] [ebp-418h]
  char *nptr; // [esp+838h] [ebp-10h]
  int v7; // [esp+83Ch] [ebp-Ch]

  v7 = (int)&unk_8665480 + 560 * a1;
  v4 = *(_DWORD *)(v7 + 344);
  sub_80912F0(a1, &dest, 1024);
  if ( !sub_80B5FA4(&dest) )
    strcpy(&dest, "\\name\\badinfo");
  v1 = v4;
  *(_DWORD *)(v1 + 9984) = sub_8090B5E(a1);
  nptr = sub_80B5B30(&dest, (int)"cg_predictItems");
  if ( atoi(nptr) )
    *(_DWORD *)(v4 + 9988) = 1;
  else
    *(_DWORD *)(v4 + 9988) = 0;
  if ( *(_DWORD *)(v4 + 9924) == 2 && dword_859B614 )
  {
    nptr = sub_80B5B30(&dest, (int)"name");
    sub_80F63D4(nptr, (char *)(v4 + 9992), 32);
  }
  else
  {
    I_strncpyz(&v5, (char *)(v4 + 10116), 1024);
    nptr = sub_80B5B30(&dest, (int)"name");
    sub_80F63D4(nptr, (char *)(v4 + 10116), 32);
    I_strncpyz((char *)(v4 + 9992), (char *)(v4 + 10116), 32);
  }
  *((_DWORD *)&unk_8652644 + 302 * a1) = a1;
  I_strncpyz((char *)(1208 * a1 + 140846664), (char *)(v4 + 10116), 32);
  result = *(_DWORD *)(v4 + 10060);
  *((_DWORD *)&unk_8652668 + 302 * a1) = result;
  return result;
}
// 859B614: using guessed type int dword_859B614;

//----- (080F6722) --------------------------------------------------------
const char *__usercall sub_80F6722@<eax>(long double a1@<st0>, int a2, __int16 a3)
{
  _DWORD *v3; // ST18_4
  int v4; // ST14_4
  const char *v6; // [esp+10h] [ebp-428h]
  char *v7; // [esp+1Ch] [ebp-41Ch]
  char dest; // [esp+20h] [ebp-418h]
  void *s; // [esp+424h] [ebp-14h]
  char *s2; // [esp+428h] [ebp-10h]
  __int16 v11; // [esp+42Eh] [ebp-Ah]

  v11 = a3;
  v7 = (char *)&unk_8665480 + 560 * a2;
  s = (void *)(dword_859B400 + 10404 * a2);
  memset((void *)(dword_859B400 + 10404 * a2), 0, 0x28A4u);
  v3 = (_DWORD *)(1208 * a2 + 140846652);
  v4 = dword_8652AE0[302 * a2];
  memset(v3, 0, 0x4B8u);
  v3[297] = v4;
  *v3 = 1;
  v3[1] = 1;
  *((_DWORD *)s + 2481) = 1;
  *((_WORD *)s + 4960) = v11;
  *((_DWORD *)s + 2515) = 3;
  *((_DWORD *)s + 2474) = 2;
  *((_DWORD *)s + 2538) = -1;
  *((_DWORD *)s + 2475) = -1;
  sub_811C3CC((int)v7);
  v7[358] = 0;
  *((_DWORD *)v7 + 86) = s;
  *((_DWORD *)s + 2572) = 1023;
  *((_DWORD *)s + 2514) = a2;
  *((_DWORD *)s + 51) = a2;
  sub_80F6506(a2);
  sub_80912F0(a2, &dest, 1024);
  if ( *((_DWORD *)s + 2496)
    || (s2 = sub_80B5B30(&dest, (int)"password"), !**(_BYTE **)(dword_8793D84 + 8))
    || !I_stricmp(*(char **)(dword_8793D84 + 8), "none")
    || !strcmp(*(const char **)(dword_8793D84 + 8), s2) )
  {
    sub_8115EC2((int *)v7);
    sub_8107356();
    v6 = 0;
  }
  else
  {
    sub_811C9C0(a1, v7);
    v6 = "GAME_INVALIDPASSWORD";
  }
  return v6;
}
// 859B400: using guessed type int dword_859B400;
// 8793D84: using guessed type int dword_8793D84;

//----- (080F6954) --------------------------------------------------------
int __cdecl sub_80F6954(int a1)
{
  int v1; // ST14_4

  v1 = dword_859B400 + 10404 * a1;
  *(_DWORD *)(dword_859B400 + 10404 * a1 + 9924) = 2;
  *(_DWORD *)(v1 + 4) = 4;
  sub_8107356();
  return Scr_Notify((int *)(560 * a1 + 140924032), word_87A230C, 0);
}
// 859B400: using guessed type int dword_859B400;
// 87A230C: using guessed type __int16 word_87A230C;

//----- (080F69B4) --------------------------------------------------------
int __usercall sub_80F69B4@<eax>(long double a1@<st0>, int a2, _DWORD *a3, _DWORD *a4)
{
  int v4; // ST1C_4
  char v6; // [esp+20h] [ebp-118h]
  int v7; // [esp+124h] [ebp-14h]
  void *s; // [esp+128h] [ebp-10h]
  int v9; // [esp+12Ch] [ebp-Ch]

  v9 = -1963413621 * ((a2 - (signed int)&unk_8665480) >> 4);
  s = *(void **)(a2 + 344);
  if ( *((_DWORD *)s + 3) & 0x800000 && *((_DWORD *)s + 40) & 0x300 )
    sub_810950C(dword_859B404 + 560 * *((_DWORD *)s + 357));
  sub_811B928(a1, (_DWORD *)a2);
  if ( *(_BYTE *)(a2 + 240) )
    sub_809A3BA(a2);
  *(_DWORD *)(a2 + 124) = 1023;
  sub_8079790((_WORD *)(a2 + 360), (unsigned __int16)word_87A22D2);
  *(_DWORD *)(a2 + 388) = 42008593;
  *(_BYTE *)(a2 + 242) |= 1u;
  *(_BYTE *)(a2 + 353) = 0;
  sub_80F2F2E(a2);
  *(_BYTE *)(a2 + 358) = 10;
  *(_DWORD *)(a2 + 372) = 4096;
  sub_80F739A(&unk_8167700, (_DWORD *)(a2 + 260));
  sub_80F739A(&unk_816770C, (_DWORD *)(a2 + 272));
  v7 = *((_DWORD *)s + 40) & 0x100002;
  qmemcpy(&v6, (char *)s + 9896, 0x100u);
  v4 = *((_DWORD *)s + 80);
  memset(s, 0, 0x28A4u);
  qmemcpy((char *)s + 9896, &v6, 0x100u);
  *((_DWORD *)s + 2538) = -1;
  *((_DWORD *)s + 2572) = 1023;
  *((_DWORD *)s + 80) = v4 + 1;
  *((_DWORD *)s + 77) = *((_DWORD *)s + 2506);
  *((_DWORD *)s + 40) = v7;
  *((_DWORD *)s + 2514) = v9;
  *((_DWORD *)s + 51) = v9;
  *((_DWORD *)s + 357) = 1023;
  sub_80904C6(1682649625 * ((_DWORD)((_DWORD)s - dword_859B400) >> 2), (_DWORD *)s + 2482);
  *((_DWORD *)s + 40) ^= 2u;
  sub_80F739A((_DWORD *)(a2 + 260), (_DWORD *)s + 347);
  sub_80F739A((_DWORD *)(a2 + 272), (_DWORD *)s + 350);
  *((_DWORD *)s + 61) = 60;
  *((_DWORD *)s + 62) = 1114636288;
  *((_DWORD *)s + 63) = 0;
  *((_DWORD *)s + 66) = 0;
  sub_811CF36((_DWORD *)a2, a3);
  sub_80F739A(a3, (_DWORD *)s + 5);
  *((_DWORD *)s + 3) |= 0x1000u;
  sub_80F5E80(a1, a2, a4);
  *((_DWORD *)s + 2560) = dword_859B5EC + 1000 * *(_DWORD *)(dword_8793DA8 + 8);
  *((_DWORD *)s + 2543) = *((_DWORD *)s + 2483);
  dword_859B420 = 1;
  *((_DWORD *)s + 2600) = dword_859B5EC;
  *((_DWORD *)s + 2482) = dword_859B5EC;
  *(_DWORD *)s = dword_859B5EC - 100;
  sub_80F4DBE(a1, a2);
  sub_80F35DA(a1, (int *)a2, (int *)s + 2482);
  dword_859B420 = 0;
  return sub_80DD59E((int)s, a2, 1, 1u);
}
// 859B400: using guessed type int dword_859B400;
// 859B404: using guessed type int dword_859B404;
// 859B420: using guessed type int dword_859B420;
// 8793DA8: using guessed type int dword_8793DA8;
// 87A22D2: using guessed type __int16 word_87A22D2;

//----- (080F6D74) --------------------------------------------------------
void __usercall sub_80F6D74(long double a1@<st0>, int a2)
{
  int v2; // [esp+Ch] [ebp-Ch]
  int i; // [esp+10h] [ebp-8h]
  int *s; // [esp+14h] [ebp-4h]

  v2 = dword_859B400 + 10404 * a2;
  s = (int *)((char *)&unk_8665480 + 560 * a2);
  if ( sub_8084030() )
  {
    Scr_AddString("disconnect");
    Scr_AddString("-1");
    Scr_Notify(s, word_87A2310, 2);
  }
  for ( i = 0; i < dword_859B5E4; ++i )
  {
    if ( *(_DWORD *)(dword_859B400 + 10404 * i + 9924)
      && *(_DWORD *)(dword_859B400 + 10404 * i + 9896) == 2
      && *(_DWORD *)(dword_859B400 + 10404 * i + 10152) == a2 )
    {
      sub_80FCAE6((char *)(560 * i + 140924032));
    }
  }
  sub_8100F84(s);
  if ( sub_8084030() )
    sub_8115EF6(s);
  sub_811C9C0(a1, s);
  *(_DWORD *)(v2 + 9924) = 0;
  memset((void *)(v2 + 10056), 0, 0x5Cu);
  sub_8107356();
}
// 859B400: using guessed type int dword_859B400;
// 859B5E4: using guessed type int dword_859B5E4;
// 87A2310: using guessed type __int16 word_87A2310;

//----- (080F6ED0) --------------------------------------------------------
int __cdecl sub_80F6ED0(int a1, float *a2, int a3)
{
  int v3; // edx
  signed int v4; // ST30_4
  int v7; // [esp+38h] [ebp-30h]
  char *v8; // [esp+3Ch] [ebp-2Ch]
  float v9; // [esp+40h] [ebp-28h]
  float v10; // [esp+44h] [ebp-24h]
  float v11; // [esp+48h] [ebp-20h]
  float v12; // [esp+4Ch] [ebp-1Ch]
  int v13; // [esp+50h] [ebp-18h]
  int v14; // [esp+54h] [ebp-14h]
  unsigned int v15; // [esp+58h] [ebp-10h]
  int v16; // [esp+5Ch] [ebp-Ch]
  int i; // [esp+60h] [ebp-8h]
  int v18; // [esp+64h] [ebp-4h]

  v7 = *(_DWORD *)(*(_DWORD *)(a1 + 344) + 10060);
  if ( !v7 || v7 == 3 )
    return 0;
  if ( a3 == 1023 )
    v18 = 0;
  else
    v18 = a3 + 1;
  for ( i = 0; ; ++i )
  {
    if ( i > 63 )
      return 0;
    v16 = (i + v18) % 64;
    v8 = (char *)&unk_8665480 + 560 * v16;
    if ( v8[252] )
    {
      if ( *((_DWORD *)v8 + 86)
        && !*(_DWORD *)(*((_DWORD *)v8 + 86) + 9896)
        && *(_DWORD *)(*((_DWORD *)v8 + 86) + 10060) == v7
        && (char *)a1 != v8
        && !sub_808FFBC(a2, *(_DWORD *)v8) )
      {
        break;
      }
    }
  }
  v15 = *(_DWORD *)v8;
  sub_80F736E((float *)v8 + 78, a2, &v11);
  v13 = (signed int)(v11 + 0.5);
  v14 = (signed int)(v12 + 0.5);
  v9 = 1.0;
  v10 = 1.0;
  if ( v13 <= 1024 )
  {
    if ( v13 < -1022 )
      v9 = -1022.0 / (long double)v13;
  }
  else
  {
    v9 = 1024.0 / (long double)v13;
  }
  if ( v14 <= 1024 )
  {
    if ( v14 < -1022 )
      v10 = -1022.0 / (long double)v14;
  }
  else
  {
    v10 = 1024.0 / (long double)v14;
  }
  if ( v9 < 1.0 || v10 < 1.0 )
  {
    if ( v10 <= (long double)v9 )
    {
      if ( v9 > (long double)v10 )
        v13 = (signed int)((long double)v13 * v10);
    }
    else
    {
      v14 = (signed int)((long double)v14 * v9);
    }
  }
  if ( v13 <= 1024 )
  {
    if ( v13 < -1022 )
      v13 = -1022;
  }
  else
  {
    v13 = 1024;
  }
  if ( v14 <= 1024 )
  {
    if ( v14 < -1022 )
      v14 = -1022;
  }
  else
  {
    v14 = 1024;
  }
  v15 = (v15 & 0xFFFF803F | ((((unsigned __int16)((v13 + 2) / 4) + 255) & 0x1FF) << 6)) & 0xFF007FFF | ((((unsigned __int16)((v14 + 2) / 4) + 255) & 0x1FF) << 15);
  v3 = v15 & 0xFFFFFF;
  v4 = (signed int)(*((float *)v8 + 82) * 0.71111113);
  v15 = v15 & 0xFFFFFF | ((unsigned __int8)v4 << 24);
  return v3 | ((unsigned __int8)v4 << 24);
}

//----- (080F721C) --------------------------------------------------------
int *__cdecl sub_80F721C(int *a1, int a2)
{
  int *result; // eax
  int *v3; // [esp+10h] [ebp-8h]
  int i; // [esp+14h] [ebp-4h]

  result = (int *)dword_859B5EC;
  *(_DWORD *)(a1[86] + 10248) = dword_859B5EC;
  for ( i = 0; i <= 63; ++i )
  {
    v3 = (int *)((char *)&unk_8665480 + 560 * i);
    if ( *((_BYTE *)v3 + 252)
      && v3[86]
      && (*(_BYTE *)(dword_8793DE0 + 8) || sub_8119C40((int)a1, (int)v3) || !*(_DWORD *)(a1[86] + 10060))
      && (*(_DWORD *)(v3[86] + 9896) == *(_DWORD *)(a1[86] + 9896)
       || (*(_DWORD *)(v3[86] + 9896) == 1 || *(_DWORD *)(a1[86] + 9896) == 1) && *(_BYTE *)(dword_8793DE4 + 8))
      && (a1 != v3 || *(_BYTE *)(dword_8793DDC + 8))
      && !(unsigned __int8)sub_809A01E(i, *a1) )
    {
      if ( (unsigned __int8)sub_809A000(i) )
        sub_809A040(*a1, i, a2);
    }
    result = &i;
  }
  return result;
}
// 8793DDC: using guessed type int dword_8793DDC;
// 8793DE0: using guessed type int dword_8793DE0;
// 8793DE4: using guessed type int dword_8793DE4;

//----- (080F736E) --------------------------------------------------------
int __cdecl sub_80F736E(float *a1, float *a2, float *a3)
{
  int result; // eax

  *a3 = *a1 - *a2;
  result = (int)(a1 + 1);
  a3[1] = a1[1] - a2[1];
  return result;
}

//----- (080F739A) --------------------------------------------------------
int __cdecl sub_80F739A(_DWORD *a1, _DWORD *a2)
{
  int result; // eax

  *a2 = *a1;
  a2[1] = a1[1];
  result = a1[2];
  a2[2] = result;
  return result;
}

//----- (080F73CA) --------------------------------------------------------
int __cdecl sub_80F73CA(int a1, float a2, int a3, int a4)
{
  int result; // eax

  *(float *)a4 = a2 * *(float *)a3 + *(float *)a1;
  *(float *)(a4 + 4) = a2 * *(float *)(a3 + 4) + *(float *)(a1 + 4);
  result = a3 + 8;
  *(float *)(a4 + 8) = a2 * *(float *)(a3 + 8) + *(float *)(a1 + 8);
  return result;
}

//----- (080F7420) --------------------------------------------------------
int __cdecl sub_80F7420(int a1)
{
  char *v1; // eax
  char *s1; // ST2C_4
  int v3; // ebx
  int v4; // eax
  char *v5; // eax
  char *v6; // eax
  int v7; // edx
  int result; // eax
  char *v9; // [esp+18h] [ebp-20h]
  int v10; // [esp+1Ch] [ebp-1Ch]
  int v11; // [esp+20h] [ebp-18h]
  int v12; // [esp+24h] [ebp-14h]
  int v13; // [esp+28h] [ebp-10h]
  _DWORD *v14; // [esp+30h] [ebp-8h]

  if ( HIWORD(a1) )
  {
    sub_8084E30((int)"not an entity");
    v9 = 0;
  }
  else
  {
    v9 = (char *)&unk_8665480 + 560 * (unsigned __int16)a1;
    if ( !*((_DWORD *)v9 + 86) )
    {
      v1 = va("entity %i is not a player", (unsigned __int16)a1);
      sub_8084E30((int)v1);
    }
  }
  s1 = (char *)sub_808456A(0);
  v13 = sub_811E940(s1);
  v10 = *((_DWORD *)v9 + 86);
  v11 = (unsigned __int8)sub_80D9E84(v10 + 1348, v13);
  v14 = (_DWORD *)sub_80E9270(v13);
  if ( (unsigned __int8)sub_80E9882(v13) && !sub_80E9C10(v10, v13) )
  {
    v3 = sub_80E9270(*(char *)(v10 + 1366));
    v4 = sub_80E9270(*(char *)(v10 + 1365));
    v5 = va(
           "Cannot give %s weapon %s without having an empty weapon slot - player currently has a %s and a %s\n",
           *((_DWORD *)v9 + 86) + 10116,
           v14[1],
           *(_DWORD *)(v4 + 4),
           *(_DWORD *)(v3 + 4));
    sub_8084E14(0, (int)v5);
  }
  if ( sub_811E696(v10, v13) )
  {
    v6 = va("%c \"%i\"", 73, 1);
    sub_808FE96(-1963413621 * ((v9 - (char *)&unk_8665480) >> 4), 0, (int)v6);
  }
  v7 = *(_DWORD *)(v10 + 4 * v14[114] + 324);
  result = v14[112] - v7;
  v12 = v14[112] - v7;
  if ( v12 > 0 )
    result = sub_8102704((int)v9, v13, v12, v11 == 0);
  return result;
}

//----- (080F761E) --------------------------------------------------------
signed int __cdecl sub_80F761E(int a1)
{
  char *v1; // eax
  char *v2; // eax
  int v3; // eax
  int v4; // ST0C_4
  int v5; // ebx
  int v6; // ebx
  char *v8; // [esp+8h] [ebp-10h]

  if ( HIWORD(a1) )
  {
    sub_8084E30((int)"not an entity");
    v8 = 0;
  }
  else
  {
    v8 = (char *)&unk_8665480 + 560 * (unsigned __int16)a1;
    if ( !*((_DWORD *)v8 + 86) )
    {
      v1 = va("entity %i is not a player", (unsigned __int16)a1);
      sub_8084E30((int)v1);
    }
  }
  v2 = (char *)sub_808456A(0);
  v3 = sub_811E940(v2);
  v4 = v3;
  v5 = *((_DWORD *)v8 + 86);
  *(_DWORD *)(v5 + 4 * sub_80EAC94(v3) + 324) = 0;
  v6 = *((_DWORD *)v8 + 86);
  *(_DWORD *)(v6 + 4 * sub_80EAC7A(v4) + 836) = 0;
  return sub_80E98CA(*((_DWORD *)v8 + 86), v4);
}

//----- (080F76F8) --------------------------------------------------------
int __cdecl sub_80F76F8(int a1)
{
  char *v1; // eax
  int result; // eax
  int v3; // ebx
  int v4; // ebx
  char *v5; // [esp+Ch] [ebp-Ch]
  int i; // [esp+10h] [ebp-8h]

  if ( HIWORD(a1) )
  {
    sub_8084E30((int)"not an entity");
    v5 = 0;
  }
  else
  {
    v5 = (char *)&unk_8665480 + 560 * (unsigned __int16)a1;
    if ( !*((_DWORD *)v5 + 86) )
    {
      v1 = va("entity %i is not a player", (unsigned __int16)a1);
      sub_8084E30((int)v1);
    }
  }
  *(_DWORD *)(*((_DWORD *)v5 + 86) + 212) = 0;
  for ( i = 1; ; ++i )
  {
    result = sub_80E9322();
    if ( i > result )
      break;
    v3 = *((_DWORD *)v5 + 86);
    *(_DWORD *)(v3 + 4 * sub_80EAC94(i) + 324) = 0;
    v4 = *((_DWORD *)v5 + 86);
    *(_DWORD *)(v4 + 4 * sub_80EAC7A(i) + 836) = 0;
    sub_80E98CA(*((_DWORD *)v5 + 86), i);
  }
  return result;
}

//----- (080F77E2) --------------------------------------------------------
_BOOL4 __cdecl sub_80F77E2(int a1)
{
  return *(_DWORD *)(*(_DWORD *)(a1 + 344) + 9896) == 0;
}

//----- (080F77FE) --------------------------------------------------------
int __cdecl sub_80F77FE(int a1)
{
  char *v1; // eax
  char **v3; // ST14_4
  char *v4; // [esp+8h] [ebp-10h]
  int v5; // [esp+Ch] [ebp-Ch]

  if ( HIWORD(a1) )
  {
    sub_8084E30((int)"not an entity");
    v4 = 0;
  }
  else
  {
    v4 = (char *)&unk_8665480 + 560 * (unsigned __int16)a1;
    if ( !*((_DWORD *)v4 + 86) )
    {
      v1 = va("entity %i is not a player", (unsigned __int16)a1);
      sub_8084E30((int)v1);
    }
  }
  if ( !sub_80F77E2((int)v4) )
    return Scr_AddString("none");
  v5 = *(_DWORD *)(*((_DWORD *)v4 + 86) + 212);
  if ( v5 <= 0 )
    return Scr_AddString("none");
  v3 = (char **)sub_80E9270(v5);
  return Scr_AddString(*v3);
}

//----- (080F78C4) --------------------------------------------------------
int __cdecl sub_80F78C4(int a1)
{
  char *v1; // eax
  char **v3; // ST14_4
  char *v4; // [esp+10h] [ebp-8h]

  if ( HIWORD(a1) )
  {
    sub_8084E30((int)"not an entity");
    v4 = 0;
  }
  else
  {
    v4 = (char *)&unk_8665480 + 560 * (unsigned __int16)a1;
    if ( !*((_DWORD *)v4 + 86) )
    {
      v1 = va("entity %i is not a player", (unsigned __int16)a1);
      sub_8084E30((int)v1);
    }
  }
  if ( !sub_80F77E2((int)v4) )
    return Scr_AddString("none");
  if ( *(_DWORD *)(*((_DWORD *)v4 + 86) + 208) <= 0 )
    return Scr_AddString("none");
  v3 = (char **)sub_80E9270(*(_DWORD *)(*((_DWORD *)v4 + 86) + 208));
  return Scr_AddString(*v3);
}

//----- (080F798A) --------------------------------------------------------
int __cdecl sub_80F798A(int a1)
{
  char *v1; // eax
  char *v2; // ST14_4
  int result; // eax
  char *v4; // [esp+Ch] [ebp-Ch]
  int v5; // [esp+10h] [ebp-8h]

  if ( HIWORD(a1) )
  {
    sub_8084E30((int)"not an entity");
    v4 = 0;
  }
  else
  {
    v4 = (char *)&unk_8665480 + 560 * (unsigned __int16)a1;
    if ( !*((_DWORD *)v4 + 86) )
    {
      v1 = va("entity %i is not a player", (unsigned __int16)a1);
      sub_8084E30((int)v1);
    }
  }
  v2 = (char *)sub_808456A(0);
  v5 = sub_80E949C(v2);
  if ( v5 && (unsigned __int8)sub_80D9E84(*((_DWORD *)v4 + 86) + 1348, v5) )
    result = Scr_AddBool(1);
  else
    result = Scr_AddBool(0);
  return result;
}

//----- (080F7A4A) --------------------------------------------------------
int __cdecl sub_80F7A4A(int a1)
{
  char *v1; // eax
  char *v2; // eax
  char *v4; // [esp+Ch] [ebp-Ch]
  int v5; // [esp+10h] [ebp-8h]
  char *s1; // [esp+14h] [ebp-4h]

  if ( HIWORD(a1) )
  {
    sub_8084E30((int)"not an entity");
    v4 = 0;
  }
  else
  {
    v4 = (char *)&unk_8665480 + 560 * (unsigned __int16)a1;
    if ( !*((_DWORD *)v4 + 86) )
    {
      v1 = va("entity %i is not a player", (unsigned __int16)a1);
      sub_8084E30((int)v1);
    }
  }
  s1 = (char *)sub_808456A(0);
  v5 = sub_811E940(s1);
  if ( !v5 )
  {
    v2 = va("unknown weapon '%s'", s1);
    sub_8084E14(0, (int)v2);
  }
  if ( !(unsigned __int8)sub_80D9E84(*((_DWORD *)v4 + 86) + 1348, v5) )
    return Scr_AddBool(0);
  sub_811E97A((unsigned __int16)a1, v5);
  return Scr_AddBool(1);
}

//----- (080F7B40) --------------------------------------------------------
int __cdecl sub_80F7B40(int a1)
{
  char *v1; // eax
  char *v2; // eax
  char *v4; // [esp+Ch] [ebp-Ch]
  int v5; // [esp+10h] [ebp-8h]
  char *s1; // [esp+14h] [ebp-4h]

  if ( HIWORD(a1) )
  {
    sub_8084E30((int)"not an entity");
    v4 = 0;
  }
  else
  {
    v4 = (char *)&unk_8665480 + 560 * (unsigned __int16)a1;
    if ( !*((_DWORD *)v4 + 86) )
    {
      v1 = va("entity %i is not a player", (unsigned __int16)a1);
      sub_8084E30((int)v1);
    }
  }
  s1 = (char *)sub_808456A(0);
  v5 = sub_811E940(s1);
  if ( !v5 )
  {
    v2 = va("unknown weapon '%s'", s1);
    sub_8084E14(0, (int)v2);
  }
  if ( !(unsigned __int8)sub_80D9E84(*((_DWORD *)v4 + 86) + 1348, v5) )
    return Scr_AddBool(0);
  sub_811E9B4((unsigned __int16)a1, v5);
  return Scr_AddBool(1);
}

//----- (080F7C36) --------------------------------------------------------
int __cdecl sub_80F7C36(int a1)
{
  char *v1; // eax
  char *v2; // eax
  int v3; // eax
  int result; // eax
  int v5; // eax
  char *v6; // [esp+14h] [ebp-14h]
  int v7; // [esp+1Ch] [ebp-Ch]

  if ( HIWORD(a1) )
  {
    sub_8084E30((int)"not an entity");
    v6 = 0;
  }
  else
  {
    v6 = (char *)&unk_8665480 + 560 * (unsigned __int16)a1;
    if ( !*((_DWORD *)v6 + 86) )
    {
      v1 = va("entity %i is not a player", (unsigned __int16)a1);
      sub_8084E30((int)v1);
    }
  }
  v2 = (char *)sub_808456A(0);
  v3 = sub_811E940(v2);
  v7 = v3;
  result = sub_80D9E84(*((_DWORD *)v6 + 86) + 1348, v3);
  if ( (_BYTE)result )
  {
    v5 = sub_80E9270(v7);
    result = *(_DWORD *)(v5 + 448) - *(_DWORD *)(*((_DWORD *)v6 + 86) + 4 * *(_DWORD *)(v5 + 456) + 324);
    if ( result > 0 )
      result = sub_8102704((int)v6, v7, result, 0);
  }
  return result;
}

//----- (080F7D32) --------------------------------------------------------
int __cdecl sub_80F7D32(int a1)
{
  char *v1; // eax
  char *v2; // eax
  int v3; // eax
  int result; // eax
  int v5; // eax
  char *v6; // [esp+14h] [ebp-14h]
  int v7; // [esp+1Ch] [ebp-Ch]

  if ( HIWORD(a1) )
  {
    sub_8084E30((int)"not an entity");
    v6 = 0;
  }
  else
  {
    v6 = (char *)&unk_8665480 + 560 * (unsigned __int16)a1;
    if ( !*((_DWORD *)v6 + 86) )
    {
      v1 = va("entity %i is not a player", (unsigned __int16)a1);
      sub_8084E30((int)v1);
    }
  }
  v2 = (char *)sub_808456A(0);
  v3 = sub_811E940(v2);
  v7 = v3;
  result = sub_80D9E84(*((_DWORD *)v6 + 86) + 1348, v3);
  if ( (_BYTE)result )
  {
    v5 = sub_80E9270(v7);
    result = sub_80E9336(*(_DWORD *)(v5 + 456)) - *(_DWORD *)(*((_DWORD *)v6 + 86) + 4 * *(_DWORD *)(v5 + 456) + 324);
    if ( result > 0 )
      result = sub_8102704((int)v6, v7, result, 0);
  }
  return result;
}

//----- (080F7E38) --------------------------------------------------------
int __cdecl sub_80F7E38(int a1)
{
  char *v1; // eax
  char *s1; // ST20_4
  int v4; // ST18_4
  char *v5; // [esp+14h] [ebp-14h]
  int v6; // [esp+1Ch] [ebp-Ch]
  int v7; // [esp+24h] [ebp-4h]

  if ( HIWORD(a1) )
  {
    sub_8084E30((int)"not an entity");
    v5 = 0;
  }
  else
  {
    v5 = (char *)&unk_8665480 + 560 * (unsigned __int16)a1;
    if ( !*((_DWORD *)v5 + 86) )
    {
      v1 = va("entity %i is not a player", (unsigned __int16)a1);
      sub_8084E30((int)v1);
    }
  }
  s1 = (char *)sub_808456A(0);
  v6 = sub_811E940(s1);
  if ( !(unsigned __int8)sub_80D9E84(*((_DWORD *)v5 + 86) + 1348, v6) )
    return Scr_AddFloat(1065353216);
  v7 = sub_80E9270(v6);
  if ( *(_DWORD *)(v7 + 448) <= 0 )
    return Scr_AddFloat(1065353216);
  if ( *(_DWORD *)(*((_DWORD *)v5 + 86) + 4 * *(_DWORD *)(v7 + 456) + 324) <= 0 )
    return Scr_AddFloat(0);
  *(float *)&v4 = (long double)*(signed int *)(*((_DWORD *)v5 + 86) + 4 * *(_DWORD *)(v7 + 456) + 324)
                / (long double)*(signed int *)(v7 + 448);
  return Scr_AddFloat(v4);
}

//----- (080F7F72) --------------------------------------------------------
int __cdecl sub_80F7F72(int a1)
{
  char *v1; // eax
  char *s1; // ST24_4
  float v4; // ST14_4
  int v5; // ST1C_4
  char *v6; // [esp+14h] [ebp-14h]
  int v7; // [esp+1Ch] [ebp-Ch]
  int v8; // [esp+24h] [ebp-4h]

  if ( HIWORD(a1) )
  {
    sub_8084E30((int)"not an entity");
    v6 = 0;
  }
  else
  {
    v6 = (char *)&unk_8665480 + 560 * (unsigned __int16)a1;
    if ( !*((_DWORD *)v6 + 86) )
    {
      v1 = va("entity %i is not a player", (unsigned __int16)a1);
      sub_8084E30((int)v1);
    }
  }
  s1 = (char *)sub_808456A(0);
  v7 = sub_811E940(s1);
  if ( !(unsigned __int8)sub_80D9E84(*((_DWORD *)v6 + 86) + 1348, v7) )
    return Scr_AddFloat(1065353216);
  v8 = sub_80E9270(v7);
  if ( sub_80E9336(*(_DWORD *)(v8 + 456)) <= 0 )
    return Scr_AddFloat(1065353216);
  if ( *(_DWORD *)(*((_DWORD *)v6 + 86) + 4 * *(_DWORD *)(v8 + 456) + 324) <= 0 )
    return Scr_AddFloat(0);
  v4 = (long double)*(signed int *)(*((_DWORD *)v6 + 86) + 4 * *(_DWORD *)(v8 + 456) + 324);
  *(float *)&v5 = v4 / (long double)sub_80E9336(*(_DWORD *)(v8 + 456));
  return Scr_AddFloat(v5);
}

//----- (080F80CC) --------------------------------------------------------
int __cdecl sub_80F80CC(int a1)
{
  char *v1; // eax
  char *v3; // [esp+1Ch] [ebp-1Ch]
  char v4; // [esp+20h] [ebp-18h]

  if ( HIWORD(a1) )
  {
    sub_8084E30((int)"not an entity");
    v3 = 0;
  }
  else
  {
    v3 = (char *)&unk_8665480 + 560 * (unsigned __int16)a1;
    if ( !*((_DWORD *)v3 + 86) )
    {
      v1 = va("entity %i is not a player", (unsigned __int16)a1);
      sub_8084E30((int)v1);
    }
  }
  sub_80846F8(0, &v4);
  sub_809A3BA((int)v3);
  sub_80FB6EE(&v4, (_DWORD *)(*((_DWORD *)v3 + 86) + 20));
  *(float *)(*((_DWORD *)v3 + 86) + 28) = *(float *)(*((_DWORD *)v3 + 86) + 28) + 1.0;
  *(_DWORD *)(*((_DWORD *)v3 + 86) + 160) ^= 2u;
  sub_80DD59E(*((_DWORD *)v3 + 86), (int)v3, 1, 1u);
  sub_80FB6EE((_DWORD *)(*((_DWORD *)v3 + 86) + 20), (_DWORD *)v3 + 78);
  return sub_809A45E((int)v3);
}

//----- (080F81F8) --------------------------------------------------------
int __usercall sub_80F81F8@<eax>(long double a1@<st0>, int a2)
{
  char *v2; // eax
  char *v4; // [esp+1Ch] [ebp-1Ch]
  char v5; // [esp+20h] [ebp-18h]

  if ( HIWORD(a2) )
  {
    sub_8084E30((int)"not an entity");
    v4 = 0;
  }
  else
  {
    v4 = (char *)&unk_8665480 + 560 * (unsigned __int16)a2;
    if ( !*((_DWORD *)v4 + 86) )
    {
      v2 = va("entity %i is not a player", (unsigned __int16)a2);
      sub_8084E30((int)v2);
    }
  }
  sub_80846F8(0, &v5);
  return sub_80F5E80(a1, (int)v4, &v5);
}

//----- (080F8280) --------------------------------------------------------
_DWORD *__cdecl sub_80F8280(int a1)
{
  char *v1; // eax
  char *v3; // [esp+14h] [ebp-4h]

  if ( HIWORD(a1) )
  {
    sub_8084E30((int)"not an entity");
    v3 = 0;
  }
  else
  {
    v3 = (char *)&unk_8665480 + 560 * (unsigned __int16)a1;
    if ( !*((_DWORD *)v3 + 86) )
    {
      v1 = va("entity %i is not a player", (unsigned __int16)a1);
      sub_8084E30((int)v1);
    }
  }
  return Scr_AddVector((_DWORD *)(*((_DWORD *)v3 + 86) + 232));
}

//----- (080F82F8) --------------------------------------------------------
int __cdecl sub_80F82F8(int a1)
{
  char *v1; // eax
  int result; // eax
  char *v3; // [esp+14h] [ebp-4h]

  if ( HIWORD(a1) )
  {
    sub_8084E30((int)"not an entity");
    v3 = 0;
  }
  else
  {
    v3 = (char *)&unk_8665480 + 560 * (unsigned __int16)a1;
    if ( !*((_DWORD *)v3 + 86) )
    {
      v1 = va("entity %i is not a player", (unsigned __int16)a1);
      sub_8084E30((int)v1);
    }
  }
  if ( (*(_DWORD *)(*((_DWORD *)v3 + 86) + 10184) | *(_DWORD *)(*((_DWORD *)v3 + 86) + 10172)) & 0x28 )
    result = Scr_AddInt(1);
  else
    result = Scr_AddInt(0);
  return result;
}

//----- (080F839A) --------------------------------------------------------
int __cdecl sub_80F839A(int a1)
{
  char *v1; // eax
  int result; // eax
  char *v3; // [esp+14h] [ebp-4h]

  if ( HIWORD(a1) )
  {
    sub_8084E30((int)"not an entity");
    v3 = 0;
  }
  else
  {
    v3 = (char *)&unk_8665480 + 560 * (unsigned __int16)a1;
    if ( !*((_DWORD *)v3 + 86) )
    {
      v1 = va("entity %i is not a player", (unsigned __int16)a1);
      sub_8084E30((int)v1);
    }
  }
  if ( (*(_BYTE *)(*((_DWORD *)v3 + 86) + 10184) | *(_BYTE *)(*((_DWORD *)v3 + 86) + 10172)) & 1 )
    result = Scr_AddInt(1);
  else
    result = Scr_AddInt(0);
  return result;
}

//----- (080F843C) --------------------------------------------------------
int __cdecl sub_80F843C(int a1)
{
  char *v1; // eax
  int result; // eax
  char *v3; // [esp+14h] [ebp-4h]

  if ( HIWORD(a1) )
  {
    sub_8084E30((int)"not an entity");
    v3 = 0;
  }
  else
  {
    v3 = (char *)&unk_8665480 + 560 * (unsigned __int16)a1;
    if ( !*((_DWORD *)v3 + 86) )
    {
      v1 = va("entity %i is not a player", (unsigned __int16)a1);
      sub_8084E30((int)v1);
    }
  }
  if ( (*(_DWORD *)(*((_DWORD *)v3 + 86) + 10184) | *(_DWORD *)(*((_DWORD *)v3 + 86) + 10172)) & 4 )
    result = Scr_AddInt(1);
  else
    result = Scr_AddInt(0);
  return result;
}

//----- (080F84DE) --------------------------------------------------------
int __cdecl sub_80F84DE(int a1)
{
  char *v1; // eax
  char *v3; // [esp+14h] [ebp-4h]

  if ( HIWORD(a1) )
  {
    sub_8084E30((int)"not an entity");
    v3 = 0;
  }
  else
  {
    v3 = (char *)&unk_8665480 + 560 * (unsigned __int16)a1;
    if ( !*((_DWORD *)v3 + 86) )
    {
      v1 = va("entity %i is not a player", (unsigned __int16)a1);
      sub_8084E30((int)v1);
    }
  }
  return Scr_AddFloat(*(_DWORD *)(*((_DWORD *)v3 + 86) + 220));
}

//----- (080F8558) --------------------------------------------------------
int __cdecl sub_80F8558(int a1)
{
  char *v1; // eax
  int result; // eax
  char *v3; // [esp+14h] [ebp-4h]

  if ( HIWORD(a1) )
  {
    sub_8084E30((int)"not an entity");
    v3 = 0;
  }
  else
  {
    v3 = (char *)&unk_8665480 + 560 * (unsigned __int16)a1;
    if ( !*((_DWORD *)v3 + 86) )
    {
      v1 = va("entity %i is not a player", (unsigned __int16)a1);
      sub_8084E30((int)v1);
    }
  }
  if ( *(_DWORD *)(*((_DWORD *)v3 + 86) + 96) == 1023 )
    result = Scr_AddInt(0);
  else
    result = Scr_AddInt(1);
  return result;
}

//----- (080F85E6) --------------------------------------------------------
int __cdecl sub_80F85E6(int a1)
{
  char *v1; // eax
  int result; // eax
  char *v3; // [esp+14h] [ebp-4h]

  if ( HIWORD(a1) )
  {
    sub_8084E30((int)"not an entity");
    v3 = 0;
  }
  else
  {
    v3 = (char *)&unk_8665480 + 560 * (unsigned __int16)a1;
    if ( !*((_DWORD *)v3 + 86) )
    {
      v1 = va("entity %i is not a player", (unsigned __int16)a1);
      sub_8084E30((int)v1);
    }
  }
  *(_DWORD *)(*((_DWORD *)v3 + 86) + 160) |= 0x400000u;
  result = dword_859B5EC + 3000;
  *(_DWORD *)(*((_DWORD *)v3 + 86) + 10300) = dword_859B5EC + 3000;
  return result;
}

//----- (080F8684) --------------------------------------------------------
int __cdecl sub_80F8684(int a1)
{
  char *v1; // eax
  int result; // eax
  char *v3; // [esp+Ch] [ebp-Ch]
  char *s2; // [esp+14h] [ebp-4h]

  if ( HIWORD(a1) )
  {
    sub_8084E30((int)"not an entity");
    v3 = 0;
  }
  else
  {
    v3 = (char *)&unk_8665480 + 560 * (unsigned __int16)a1;
    if ( !*((_DWORD *)v3 + 86) )
    {
      v1 = va("entity %i is not a player", (unsigned __int16)a1);
      sub_8084E30((int)v1);
    }
  }
  s2 = (char *)sub_808456A(0);
  if ( !s2 || !*s2 )
    sub_8084E14(0, (int)"usage: setviewmodel(<model name>)");
  result = sub_811B00C(s2);
  *(_DWORD *)(*((_DWORD *)v3 + 86) + 10044) = result;
  return result;
}

//----- (080F8738) --------------------------------------------------------
int __cdecl sub_80F8738(int a1)
{
  char *v1; // eax
  char *s; // ST14_4
  char *v4; // [esp+10h] [ebp-8h]

  if ( HIWORD(a1) )
  {
    sub_8084E30((int)"not an entity");
    v4 = 0;
  }
  else
  {
    v4 = (char *)&unk_8665480 + 560 * (unsigned __int16)a1;
    if ( !*((_DWORD *)v4 + 86) )
    {
      v1 = va("entity %i is not a player", (unsigned __int16)a1);
      sub_8084E30((int)v1);
    }
  }
  s = sub_811B124(*(_DWORD *)(*((_DWORD *)v4 + 86) + 10044));
  return Scr_AddString(s);
}

//----- (080F87C0) --------------------------------------------------------
int __cdecl sub_80F87C0(int a1)
{
  char *v1; // eax
  char *v3; // [esp+14h] [ebp-4h]

  if ( HIWORD(a1) )
  {
    sub_8084E30((int)"not an entity");
    v3 = 0;
  }
  else
  {
    v3 = (char *)&unk_8665480 + 560 * (unsigned __int16)a1;
    if ( !*((_DWORD *)v3 + 86) )
    {
      v1 = va("entity %i is not a player", (unsigned __int16)a1);
      sub_8084E30((int)v1);
    }
  }
  return sub_80FB982((int)v3);
}

//----- (080F882E) --------------------------------------------------------
int __cdecl sub_80F882E(int a1)
{
  char *v1; // eax
  char *v2; // eax
  int v3; // eax
  int result; // eax
  char *v5; // [esp+Ch] [ebp-Ch]
  int v6; // [esp+10h] [ebp-8h]

  if ( HIWORD(a1) )
  {
    sub_8084E30((int)"not an entity");
    v5 = 0;
  }
  else
  {
    v5 = (char *)&unk_8665480 + 560 * (unsigned __int16)a1;
    if ( !*((_DWORD *)v5 + 86) )
    {
      v1 = va("entity %i is not a player", (unsigned __int16)a1);
      sub_8084E30((int)v1);
    }
  }
  v2 = (char *)sub_808456A(0);
  v3 = sub_811E940(v2);
  v6 = v3;
  result = sub_80E97F0(*((_DWORD *)v5 + 86), v3);
  if ( (_BYTE)result )
  {
    *(_DWORD *)(*((_DWORD *)v5 + 86) + 212) = v6;
    result = *((_DWORD *)v5 + 86);
    *(_DWORD *)(result + 216) = 0;
  }
  return result;
}

//----- (080F88EE) --------------------------------------------------------
int __cdecl sub_80F88EE(int a1)
{
  char *v1; // eax
  int v2; // ST1C_4
  int *v3; // eax
  int result; // eax
  int *v5; // ST18_4
  char *v6; // [esp+10h] [ebp-18h]
  char *v7; // [esp+14h] [ebp-14h]
  int v8; // [esp+20h] [ebp-8h]
  char *s1; // [esp+24h] [ebp-4h]

  if ( HIWORD(a1) )
  {
    sub_8084E30((int)"not an entity");
    v6 = 0;
  }
  else
  {
    v6 = (char *)&unk_8665480 + 560 * (unsigned __int16)a1;
    if ( !*((_DWORD *)v6 + 86) )
    {
      v1 = va("entity %i is not a player", (unsigned __int16)a1);
      sub_8084E30((int)v1);
    }
  }
  s1 = (char *)sub_808456A(0);
  v8 = sub_811E940(s1);
  if ( v8 )
  {
    if ( (unsigned int)sub_8084AEE() <= 1 )
    {
      v3 = sub_810404E((int)v6, v8, (unsigned __int16)word_87A2346);
    }
    else
    {
      v2 = sub_8084434(1u);
      v3 = sub_810404E((int)v6, v8, v2);
    }
    result = sub_8115AC2(v3);
  }
  else
  {
    v7 = sub_80DCB02(s1);
    if ( v7 )
    {
      v5 = (int *)sub_8103F44((int)v6, (int)v7, 0.0, 0);
      result = sub_8115AC2(v5);
    }
    else
    {
      result = sub_8115AC2(0);
    }
  }
  return result;
}
// 87A2346: using guessed type __int16 word_87A2346;

//----- (080F8A04) --------------------------------------------------------
int __cdecl sub_80F8A04(int a1)
{
  char *v1; // eax
  int result; // eax
  char *v3; // eax
  char *v4; // eax
  __int16 v5; // ax
  float v6; // ST04_4
  int v7; // eax
  _DWORD *v8; // ST60_4
  _DWORD *v9; // eax
  float v10; // ST4C_4
  int v11; // ebx
  char *v12; // [esp+44h] [ebp-C4h]
  float v13; // [esp+48h] [ebp-C0h]
  float v14; // [esp+50h] [ebp-B8h]
  void (__cdecl *v15)(char *, int *, int, char *, int, int *, int); // [esp+58h] [ebp-B0h]
  void (__cdecl *v16)(char *, int *, int *, int, int, int, int *, int, int); // [esp+5Ch] [ebp-ACh]
  int v17; // [esp+64h] [ebp-A4h]
  int v18; // [esp+68h] [ebp-A0h]
  int v19; // [esp+70h] [ebp-98h]
  int v20; // [esp+80h] [ebp-88h]
  float v21; // [esp+90h] [ebp-78h]
  int v22; // [esp+94h] [ebp-74h]
  int v23; // [esp+98h] [ebp-70h]
  int v24; // [esp+9Ch] [ebp-6Ch]
  int v25; // [esp+A0h] [ebp-68h]
  int v26; // [esp+A4h] [ebp-64h]
  int v27; // [esp+A8h] [ebp-60h]
  char *v28; // [esp+ACh] [ebp-5Ch]
  char v29; // [esp+B0h] [ebp-58h]
  float *v30; // [esp+CCh] [ebp-3Ch]
  char v31; // [esp+D0h] [ebp-38h]
  int *v32; // [esp+E8h] [ebp-20h]
  int *v33; // [esp+ECh] [ebp-1Ch]

  v33 = &dword_86F1020;
  v32 = &dword_86F1020;
  v30 = 0;
  v28 = 0;
  if ( HIWORD(a1) )
  {
    sub_8084E30((int)"not an entity");
    v12 = 0;
  }
  else
  {
    v12 = (char *)&unk_8665480 + 560 * (unsigned __int16)a1;
    if ( !*((_DWORD *)v12 + 86) )
    {
      v1 = va("entity %i is not a player", (unsigned __int16)a1);
      sub_8084E30((int)v1);
    }
  }
  result = sub_808404C(2u);
  v27 = result;
  if ( result > 0 )
  {
    if ( sub_80849A8(0) && sub_8084A50(0) == 21 )
      v33 = (int *)sub_8118CDE(1u);
    if ( sub_80849A8(1u) && sub_8084A50(1u) == 21 )
      v32 = (int *)sub_8118CDE(1u);
    v26 = sub_808404C(3u);
    v3 = (char *)sub_808456A(4u);
    v25 = sub_80FF26A(v3);
    v4 = (char *)sub_808456A(5u);
    v24 = sub_811E940(v4);
    if ( sub_80849A8(6u) )
    {
      sub_80846F8(6u, &v29);
      v28 = &v29;
    }
    if ( sub_80849A8(7u) )
    {
      sub_80846F8(7u, &v31);
      v30 = (float *)&v31;
    }
    v5 = sub_80843C0(8u);
    v23 = sub_81003F6(v5);
    v17 = sub_808404C(9u);
    if ( v30 )
      sub_80A2298(v30, (int)&v20);
    else
      sub_80FB6C4(&v20);
    if ( *((_DWORD *)v12 + 93) & 8 || v26 & 4 )
    {
      v22 = 0;
    }
    else
    {
      v21 = 0.30000001;
      if ( *(_BYTE *)(*((_DWORD *)v12 + 86) + 12) & 1 )
      {
        v21 = 0.02;
      }
      else if ( *(_DWORD *)(*((_DWORD *)v12 + 86) + 12) & 2 )
      {
        v21 = 0.15000001;
      }
      v22 = (signed int)((long double)v27 * v21);
      if ( v22 > 60 )
        v22 = 60;
      if ( v22 )
      {
        if ( !(*(_DWORD *)(*((_DWORD *)v12 + 86) + 160) & 0x300) )
        {
          v6 = (long double)v22 * *(float *)(dword_8793D9C + 8) / 250.0;
          sub_80FB762((int)&v20, v6, (int)&v19);
          sub_80FB71E((float *)(*((_DWORD *)v12 + 86) + 32), (float *)&v19, (float *)(*((_DWORD *)v12 + 86) + 32));
          if ( !*(_DWORD *)(*((_DWORD *)v12 + 86) + 16) )
          {
            v18 = 2 * v22;
            if ( 2 * v22 <= 49 )
              v18 = 50;
            if ( v18 > 200 )
              v18 = 200;
            *(_DWORD *)(*((_DWORD *)v12 + 86) + 16) = v18;
            *(_DWORD *)(*((_DWORD *)v12 + 86) + 12) |= 0x400u;
          }
        }
      }
    }
    result = *((_DWORD *)v12 + 93) & 1;
    if ( !(_BYTE)result )
    {
      if ( v24 && !*(_DWORD *)(sub_80E9270(v24) + 120) )
      {
        if ( *(_DWORD *)(sub_80E9270(v24) + 796) )
          v7 = sub_811CB34(&v29, 183);
        else
          v7 = sub_811CB34(&v29, 182);
        v8 = (_DWORD *)v7;
        *(_DWORD *)(v7 + 160) = (unsigned __int8)sub_80A1C2A((float *)&v20);
        v8[54] = (unsigned __int8)sub_80A1C2A((float *)&v20);
        v8[34] = 7;
        v8[29] = *v32;
        v8[(*(_DWORD *)(*((_DWORD *)v12 + 86) + 204) >> 5) + 61] |= 1 << (*(_BYTE *)(*((_DWORD *)v12 + 86) + 204) & 0x1F);
        if ( *(_DWORD *)(sub_80E9270(v24) + 796) )
          v9 = (_DWORD *)sub_811CB34(&v29, 186);
        else
          v9 = (_DWORD *)sub_811CB34(&v29, 185);
        v9[34] = 7;
        v9[29] = *v32;
        v9[36] = *(_DWORD *)(*((_DWORD *)v12 + 86) + 204);
        v9[61] = -1;
        v9[62] = -1;
        v9[(*(_DWORD *)(*((_DWORD *)v12 + 86) + 204) >> 5) + 61] &= ~(1 << (*(_BYTE *)(*((_DWORD *)v12 + 86) + 204) & 0x1F));
      }
      *(_DWORD *)(*((_DWORD *)v12 + 86) + 10208) += v27;
      if ( v30 )
      {
        sub_80FB6EE(&v20, (_DWORD *)(*((_DWORD *)v12 + 86) + 10212));
        *(_DWORD *)(*((_DWORD *)v12 + 86) + 10224) = 0;
      }
      else
      {
        sub_80FB6EE((_DWORD *)v12 + 78, (_DWORD *)(*((_DWORD *)v12 + 86) + 10212));
        *(_DWORD *)(*((_DWORD *)v12 + 86) + 10224) = 1;
      }
      if ( *((_DWORD *)v12 + 93) & 2 && *((_DWORD *)v12 + 101) - v27 <= 0 )
        v27 = *((_DWORD *)v12 + 101) - 1;
      v14 = *(float *)(dword_8576114 + 8);
      v10 = (long double)v27 * *(float *)(dword_8576110 + 8);
      *(_DWORD *)(*((_DWORD *)v12 + 86) + 144) += (signed int)v10;
      if ( v30 )
      {
        v11 = *((_DWORD *)v12 + 86);
        *(_DWORD *)(v11 + 152) = (signed int)sub_80A29F6(v30);
      }
      else
      {
        *(_DWORD *)(*((_DWORD *)v12 + 86) + 152) = 0;
      }
      v13 = *(float *)(*((_DWORD *)v12 + 86) + 236);
      if ( v13 < 0.0 )
        v13 = v13 + 360.0;
      *(_DWORD *)(*((_DWORD *)v12 + 86) + 152) -= (signed int)v13;
      if ( (long double)*(signed int *)(*((_DWORD *)v12 + 86) + 144) > v14 )
        *(_DWORD *)(*((_DWORD *)v12 + 86) + 144) = (signed int)v14;
      *(_DWORD *)(*((_DWORD *)v12 + 86) + 148) = *(_DWORD *)(*((_DWORD *)v12 + 86) + 144);
      *((_DWORD *)v12 + 101) -= v27;
      Scr_AddEntity(v32);
      Scr_AddInt(v27);
      Scr_Notify((int *)v12, word_87A22A8, 2);
      if ( *((_DWORD *)v12 + 101) > 0 )
      {
        v15 = (void (__cdecl *)(char *, int *, int, char *, int, int *, int))dword_8167894[10
                                                                                         * (unsigned __int8)v12[358]];
        if ( v15 )
          v15(v12, v32, v27, v28, v25, &v20, v23);
      }
      else
      {
        if ( *((_DWORD *)v12 + 101) < -999 )
          *((_DWORD *)v12 + 101) = -999;
        v16 = (void (__cdecl *)(char *, int *, int *, int, int, int, int *, int, int))dword_8167898[10 * (unsigned __int8)v12[358]];
        if ( v16 )
          v16(v12, v33, v32, v27, v25, v24, &v20, v23, v17);
        result = (int)v12;
        if ( !v12[252] )
          return result;
      }
      result = *((_DWORD *)v12 + 101);
      *(_DWORD *)(*((_DWORD *)v12 + 86) + 300) = result;
      return result;
    }
  }
  return result;
}
// 8167894: using guessed type int dword_8167894[];
// 8167898: using guessed type int dword_8167898[];
// 8576110: using guessed type int dword_8576110;
// 8576114: using guessed type int dword_8576114;
// 86F1020: using guessed type int dword_86F1020;
// 8793D9C: using guessed type int dword_8793D9C;
// 87A22A8: using guessed type __int16 word_87A22A8;

//----- (080F9448) --------------------------------------------------------
int __cdecl sub_80F9448(int a1)
{
  char *v1; // eax
  int v2; // edx
  int *v4; // [esp+24h] [ebp-4h]

  if ( HIWORD(a1) )
  {
    sub_8084E30((int)"not an entity");
    v4 = 0;
  }
  else
  {
    v4 = (int *)((char *)&unk_8665480 + 560 * (unsigned __int16)a1);
    if ( !v4[86] )
    {
      v1 = va("entity %i is not a player", (unsigned __int16)a1);
      sub_8084E30((int)v1);
    }
  }
  v4[93] &= 0xFFFFFFFC;
  v2 = v4[86];
  v4[101] = 0;
  *(_DWORD *)(v2 + 300) = 0;
  return sub_80FF2CA((int)v4, v4, v4, 100000, 0xCu, 0, 0, 0, 0);
}

//----- (080F9528) --------------------------------------------------------
int __cdecl sub_80F9528(int a1)
{
  char *v1; // eax
  char *v2; // eax
  int v3; // eax
  char *v4; // eax
  char *v6; // [esp+10h] [ebp-8h]

  if ( HIWORD(a1) )
  {
    sub_8084E30((int)"not an entity");
    v6 = 0;
  }
  else
  {
    v6 = (char *)&unk_8665480 + 560 * (unsigned __int16)a1;
    if ( !*((_DWORD *)v6 + 86) )
    {
      v1 = va("entity %i is not a player", (unsigned __int16)a1);
      sub_8084E30((int)v1);
    }
  }
  if ( *(_DWORD *)(*((_DWORD *)v6 + 86) + 9924) != 2 )
    return Scr_AddInt(0);
  v2 = (char *)sub_808456A(0);
  v3 = sub_8110FC2(v2);
  v4 = va("%c %i", 116, v3);
  sub_808FE96((unsigned __int16)a1, 1, (int)v4);
  return Scr_AddInt(1);
}

//----- (080F9600) --------------------------------------------------------
int __cdecl sub_80F9600(int a1)
{
  char *v1; // eax
  char *v2; // eax
  int v3; // eax
  char *v4; // eax
  char *v6; // [esp+10h] [ebp-8h]

  if ( HIWORD(a1) )
  {
    sub_8084E30((int)"not an entity");
    v6 = 0;
  }
  else
  {
    v6 = (char *)&unk_8665480 + 560 * (unsigned __int16)a1;
    if ( !*((_DWORD *)v6 + 86) )
    {
      v1 = va("entity %i is not a player", (unsigned __int16)a1);
      sub_8084E30((int)v1);
    }
  }
  if ( *(_DWORD *)(*((_DWORD *)v6 + 86) + 9924) != 2 )
    return Scr_AddInt(0);
  v2 = (char *)sub_808456A(0);
  v3 = sub_8110FC2(v2);
  v4 = va("%c %i 1", 116, v3);
  sub_808FE96((unsigned __int16)a1, 1, (int)v4);
  return Scr_AddInt(1);
}

//----- (080F96D8) --------------------------------------------------------
int __cdecl sub_80F96D8(int a1)
{
  char *v1; // eax
  char *v2; // eax

  if ( HIWORD(a1) )
  {
    sub_8084E30((int)"not an entity");
  }
  else if ( !*((_DWORD *)&unk_8665480 + 140 * (unsigned __int16)a1 + 86) )
  {
    v1 = va("entity %i is not a player", (unsigned __int16)a1);
    sub_8084E30((int)v1);
  }
  v2 = va("%c", 117);
  return sub_808FE96((unsigned __int16)a1, 1, (int)v2);
}

//----- (080F9766) --------------------------------------------------------
int __cdecl sub_80F9766(int a1)
{
  char *v1; // eax
  char *v2; // eax

  if ( HIWORD(a1) )
  {
    sub_8084E30((int)"not an entity");
  }
  else if ( !*((_DWORD *)&unk_8665480 + 140 * (unsigned __int16)a1 + 86) )
  {
    v1 = va("entity %i is not a player", (unsigned __int16)a1);
    sub_8084E30((int)v1);
  }
  v2 = va("%c", 75);
  return sub_808FE96((unsigned __int16)a1, 1, (int)v2);
}

//----- (080F97F4) --------------------------------------------------------
int __cdecl sub_80F97F4(int a1)
{
  char *v1; // eax
  unsigned __int16 v3; // ax
  char *v4; // eax
  int v5; // eax
  char *v6; // eax
  char **v7; // ST18_4
  char *v8; // [esp+14h] [ebp-14h]
  int v9; // [esp+20h] [ebp-8h]
  unsigned __int16 v10; // [esp+26h] [ebp-2h]

  if ( HIWORD(a1) )
  {
    sub_8084E30((int)"not an entity");
    v8 = 0;
  }
  else
  {
    v8 = (char *)&unk_8665480 + 560 * (unsigned __int16)a1;
    if ( !*((_DWORD *)v8 + 86) )
    {
      v1 = va("entity %i is not a player", (unsigned __int16)a1);
      sub_8084E30((int)v1);
    }
  }
  if ( !sub_80F77E2((int)v8) )
    return sub_8084C8E((unsigned __int16)word_87A2314);
  v3 = sub_80843C0(0);
  v10 = v3;
  v4 = (char *)sub_8078896(v3);
  v9 = sub_80F0450(v4);
  if ( !v9 )
  {
    v5 = sub_8078896(v10);
    v6 = va("Unknown weaponslot name %s. Valid weaponslots are \"primary\" and \"primaryb\"", v5);
    sub_8084E14(0, (int)v6);
  }
  if ( !*(_BYTE *)(v9 + *((_DWORD *)v8 + 86) + 1364) )
    return sub_8084C8E((unsigned __int16)word_87A2314);
  v7 = (char **)sub_80E9270(*(char *)(v9 + *((_DWORD *)v8 + 86) + 1364));
  return Scr_AddString(*v7);
}
// 87A2314: using guessed type __int16 word_87A2314;

//----- (080F991C) --------------------------------------------------------
signed int __cdecl sub_80F991C(int a1)
{
  char *v1; // eax
  unsigned __int16 v2; // ax
  char *v3; // eax
  int v4; // eax
  char *v5; // eax
  char *v6; // eax
  char *v7; // ebx
  char *v8; // eax
  char *v9; // eax
  signed int result; // eax
  int v11; // edx
  char *v12; // [esp+1Ch] [ebp-2Ch]
  signed int v13; // [esp+20h] [ebp-28h]
  int v14; // [esp+24h] [ebp-24h]
  int *v15; // [esp+28h] [ebp-20h]
  char *s1; // [esp+2Ch] [ebp-1Ch]
  int v17; // [esp+30h] [ebp-18h]
  int v18; // [esp+34h] [ebp-14h]
  int v19; // [esp+3Ch] [ebp-Ch]
  unsigned __int16 v20; // [esp+42h] [ebp-6h]

  v13 = 0;
  if ( HIWORD(a1) )
  {
    sub_8084E30((int)"not an entity");
    v12 = 0;
  }
  else
  {
    v12 = (char *)&unk_8665480 + 560 * (unsigned __int16)a1;
    if ( !*((_DWORD *)v12 + 86) )
    {
      v1 = va("entity %i is not a player", (unsigned __int16)a1);
      sub_8084E30((int)v1);
    }
  }
  v2 = sub_80843C0(0);
  v20 = v2;
  v3 = (char *)sub_8078896(v2);
  v19 = sub_80F0450(v3);
  if ( !v19 )
  {
    v4 = sub_8078896(v20);
    v5 = va("Unknown weaponslot name %s. Valid weaponslots are \"primary\" and \"primaryb\"", v4);
    sub_8084E14(0, (int)v5);
  }
  s1 = (char *)sub_808456A(1u);
  if ( I_stricmp(s1, "none") )
  {
    v18 = sub_811E940(s1);
    if ( !v18 )
    {
      v6 = va("Unknown weapon %s.", s1);
      sub_8084E14(1, (int)v6);
    }
    v15 = (int *)sub_80E9270(v18);
    if ( v15[32] != v19 && (v15[32] != 1 && v15[32] != 2 || v19 != 1 && v19 != 2) )
    {
      v7 = sub_80F049E(v19);
      v8 = sub_80F049E(v15[32]);
      v9 = va("Weapon %s goes in the %s weaponslot, not the %s weaponslot.", s1, v8, v7);
      sub_8084E14(1, (int)v9);
    }
  }
  else
  {
    v18 = 0;
    v15 = 0;
  }
  result = *(char *)(v19 + *((_DWORD *)v12 + 86) + 1364);
  if ( *(_BYTE *)(v19 + *((_DWORD *)v12 + 86) + 1364) )
    result = sub_80E98CA(*((_DWORD *)v12 + 86), *(char *)(v19 + *((_DWORD *)v12 + 86) + 1364));
  if ( v18 )
  {
    if ( v19 == 2 && !*(_BYTE *)(*((_DWORD *)v12 + 86) + 1365) )
      v13 = 1;
    v14 = (unsigned __int8)sub_80D9E84(*((_DWORD *)v12 + 86) + 1348, v18);
    sub_811E696(*((_DWORD *)v12 + 86), v18);
    if ( v13 )
    {
      *(_BYTE *)(*((_DWORD *)v12 + 86) + 1366) = *(_BYTE *)(*((_DWORD *)v12 + 86) + 1365);
      *(_BYTE *)(*((_DWORD *)v12 + 86) + 1365) = 0;
    }
    v11 = *(_DWORD *)(*((_DWORD *)v12 + 86) + 4 * v15[114] + 324);
    result = v15[112] - v11;
    v17 = v15[112] - v11;
    if ( v17 > 0 )
      result = sub_8102704((int)v12, v18, v17, v14 == 0);
  }
  return result;
}

//----- (080F9C02) --------------------------------------------------------
int __cdecl sub_80F9C02(int a1)
{
  char *v1; // eax
  int result; // eax
  unsigned __int16 v3; // ax
  char *v4; // eax
  int v5; // eax
  char *v6; // eax
  int v7; // ST18_4
  int v8; // ST18_4
  char *v9; // [esp+14h] [ebp-14h]
  int v10; // [esp+1Ch] [ebp-Ch]
  int v11; // [esp+20h] [ebp-8h]
  unsigned __int16 v12; // [esp+26h] [ebp-2h]

  if ( HIWORD(a1) )
  {
    sub_8084E30((int)"not an entity");
    v9 = 0;
  }
  else
  {
    v9 = (char *)&unk_8665480 + 560 * (unsigned __int16)a1;
    if ( !*((_DWORD *)v9 + 86) )
    {
      v1 = va("entity %i is not a player", (unsigned __int16)a1);
      sub_8084E30((int)v1);
    }
  }
  if ( !sub_80F77E2((int)v9) )
    return Scr_AddInt(0);
  v3 = sub_80843C0(0);
  v12 = v3;
  v4 = (char *)sub_8078896(v3);
  v11 = sub_80F0450(v4);
  if ( !v11 )
  {
    v5 = sub_8078896(v12);
    v6 = va("Unknown weaponslot name %s. Valid weaponslots are \"primary\" and \"primaryb\"", v5);
    sub_8084E14(0, (int)v6);
  }
  v10 = *(char *)(v11 + *((_DWORD *)v9 + 86) + 1364);
  if ( !*(_BYTE *)(v11 + *((_DWORD *)v9 + 86) + 1364) )
    return Scr_AddInt(0);
  if ( sub_80EACAE(v10) )
  {
    v7 = sub_80EAC7A(v10);
    result = Scr_AddInt(*(_DWORD *)(*((_DWORD *)v9 + 86) + 4 * v7 + 836));
  }
  else
  {
    v8 = sub_80EAC94(v10);
    result = Scr_AddInt(*(_DWORD *)(*((_DWORD *)v9 + 86) + 4 * v8 + 324));
  }
  return result;
}

//----- (080F9D6C) --------------------------------------------------------
int __cdecl sub_80F9D6C(int a1)
{
  char *v1; // eax
  unsigned __int16 v2; // ax
  char *v3; // eax
  int v4; // eax
  char *v5; // eax
  int result; // eax
  char *v7; // [esp+10h] [ebp-18h]
  int v8; // [esp+14h] [ebp-14h]
  int v9; // [esp+14h] [ebp-14h]
  int v10; // [esp+18h] [ebp-10h]
  int v11; // [esp+1Ch] [ebp-Ch]
  int v12; // [esp+20h] [ebp-8h]
  unsigned __int16 v13; // [esp+26h] [ebp-2h]

  if ( HIWORD(a1) )
  {
    sub_8084E30((int)"not an entity");
    v7 = 0;
  }
  else
  {
    v7 = (char *)&unk_8665480 + 560 * (unsigned __int16)a1;
    if ( !*((_DWORD *)v7 + 86) )
    {
      v1 = va("entity %i is not a player", (unsigned __int16)a1);
      sub_8084E30((int)v1);
    }
  }
  v2 = sub_80843C0(0);
  v13 = v2;
  v3 = (char *)sub_8078896(v2);
  v12 = sub_80F0450(v3);
  if ( !v12 )
  {
    v4 = sub_8078896(v13);
    v5 = va("Unknown weaponslot name %s. Valid weaponslots are \"primary\" and \"primaryb\"", v4);
    sub_8084E14(0, (int)v5);
  }
  v10 = sub_808404C(1u);
  result = *(char *)(v12 + *((_DWORD *)v7 + 86) + 1364);
  v11 = *(char *)(v12 + *((_DWORD *)v7 + 86) + 1364);
  if ( *(_BYTE *)(v12 + *((_DWORD *)v7 + 86) + 1364) )
  {
    if ( sub_80EACAE(v11) )
    {
      result = sub_80EAC7A(v11);
      v8 = result;
      if ( result )
      {
        if ( v10 >= 0 )
        {
          if ( v10 > sub_80E9356(result) )
            v10 = sub_80E9356(v8);
        }
        else
        {
          v10 = 0;
        }
        result = v10;
        *(_DWORD *)(*((_DWORD *)v7 + 86) + 4 * v8 + 836) = v10;
      }
    }
    else
    {
      result = sub_80EAC94(v11);
      v9 = result;
      if ( result )
      {
        if ( v10 >= 0 )
        {
          if ( v10 > sub_80E9336(result) )
            v10 = sub_80E9336(v9);
        }
        else
        {
          v10 = 0;
        }
        result = v10;
        *(_DWORD *)(*((_DWORD *)v7 + 86) + 4 * v9 + 324) = v10;
      }
    }
  }
  return result;
}

//----- (080F9F20) --------------------------------------------------------
int __cdecl sub_80F9F20(int a1)
{
  char *v1; // eax
  int result; // eax
  unsigned __int16 v3; // ax
  char *v4; // eax
  int v5; // eax
  char *v6; // eax
  char *v7; // [esp+14h] [ebp-14h]
  int v8; // [esp+18h] [ebp-10h]
  int v9; // [esp+20h] [ebp-8h]
  unsigned __int16 v10; // [esp+26h] [ebp-2h]

  if ( HIWORD(a1) )
  {
    sub_8084E30((int)"not an entity");
    v7 = 0;
  }
  else
  {
    v7 = (char *)&unk_8665480 + 560 * (unsigned __int16)a1;
    if ( !*((_DWORD *)v7 + 86) )
    {
      v1 = va("entity %i is not a player", (unsigned __int16)a1);
      sub_8084E30((int)v1);
    }
  }
  if ( !sub_80F77E2((int)v7) )
    return Scr_AddInt(0);
  v3 = sub_80843C0(0);
  v10 = v3;
  v4 = (char *)sub_8078896(v3);
  v9 = sub_80F0450(v4);
  if ( !v9 )
  {
    v5 = sub_8078896(v10);
    v6 = va("Unknown weaponslot name %s. Valid weaponslots are \"primary\" and \"primaryb\"", v5);
    sub_8084E14(0, (int)v6);
  }
  if ( !*(_BYTE *)(v9 + *((_DWORD *)v7 + 86) + 1364) )
    return Scr_AddInt(0);
  v8 = sub_80EAC7A(*(char *)(v9 + *((_DWORD *)v7 + 86) + 1364));
  if ( v8 )
    result = Scr_AddInt(*(_DWORD *)(*((_DWORD *)v7 + 86) + 4 * v8 + 836));
  else
    result = Scr_AddInt(0);
  return result;
}

//----- (080FA064) --------------------------------------------------------
int __cdecl sub_80FA064(int a1)
{
  char *v1; // eax
  unsigned __int16 v2; // ax
  char *v3; // eax
  int v4; // eax
  char *v5; // eax
  int result; // eax
  char *v7; // [esp+10h] [ebp-18h]
  int v8; // [esp+14h] [ebp-14h]
  int v9; // [esp+18h] [ebp-10h]
  int v10; // [esp+20h] [ebp-8h]
  unsigned __int16 v11; // [esp+26h] [ebp-2h]

  if ( HIWORD(a1) )
  {
    sub_8084E30((int)"not an entity");
    v7 = 0;
  }
  else
  {
    v7 = (char *)&unk_8665480 + 560 * (unsigned __int16)a1;
    if ( !*((_DWORD *)v7 + 86) )
    {
      v1 = va("entity %i is not a player", (unsigned __int16)a1);
      sub_8084E30((int)v1);
    }
  }
  v2 = sub_80843C0(0);
  v11 = v2;
  v3 = (char *)sub_8078896(v2);
  v10 = sub_80F0450(v3);
  if ( !v10 )
  {
    v4 = sub_8078896(v11);
    v5 = va("Unknown weaponslot name %s. Valid weaponslots are \"primary\" and \"primaryb\"", v4);
    sub_8084E14(0, (int)v5);
  }
  v9 = sub_808404C(1u);
  if ( !*(_BYTE *)(v10 + *((_DWORD *)v7 + 86) + 1364) )
    return Scr_AddInt(0);
  result = sub_80EAC7A(*(char *)(v10 + *((_DWORD *)v7 + 86) + 1364));
  v8 = result;
  if ( result )
  {
    if ( v9 < 0 )
      v9 = 0;
    if ( v9 > sub_80E9356(result) )
      v9 = sub_80E9356(v8);
    result = v9;
    *(_DWORD *)(*((_DWORD *)v7 + 86) + 4 * v8 + 836) = v9;
  }
  return result;
}

//----- (080FA1B2) --------------------------------------------------------
int __cdecl sub_80FA1B2(int a1)
{
  char *v1; // eax
  char *s1; // ST24_4
  int result; // eax
  char *v4; // [esp+14h] [ebp-14h]
  int v5; // [esp+18h] [ebp-10h]
  int v6; // [esp+1Ch] [ebp-Ch]
  int v7; // [esp+20h] [ebp-8h]

  if ( HIWORD(a1) )
  {
    sub_8084E30((int)"not an entity");
    v4 = 0;
  }
  else
  {
    v4 = (char *)&unk_8665480 + 560 * (unsigned __int16)a1;
    if ( !*((_DWORD *)v4 + 86) )
    {
      v1 = va("entity %i is not a player", (unsigned __int16)a1);
      sub_8084E30((int)v1);
    }
  }
  s1 = (char *)sub_808456A(0);
  v6 = sub_808404C(1u);
  v7 = sub_811E940(s1);
  if ( !v7 )
    return Scr_AddInt(0);
  result = sub_80EAC7A(v7);
  v5 = result;
  if ( result )
  {
    if ( v6 < 0 )
      v6 = 0;
    if ( v6 > sub_80E9356(result) )
      v6 = sub_80E9356(v5);
    result = v6;
    *(_DWORD *)(*((_DWORD *)v4 + 86) + 4 * v5 + 836) = v6;
  }
  return result;
}

//----- (080FA2AC) --------------------------------------------------------
int __cdecl sub_80FA2AC(int a1)
{
  char *v1; // eax
  char *v2; // eax

  if ( HIWORD(a1) )
  {
    sub_8084E30((int)"not an entity");
  }
  else if ( !*((_DWORD *)&unk_8665480 + 140 * (unsigned __int16)a1 + 86) )
  {
    v1 = va("entity %i is not a player", (unsigned __int16)a1);
    sub_8084E30((int)v1);
  }
  v2 = va("%c", 102);
  return sub_810E5D8((unsigned __int16)a1, (int)v2);
}

//----- (080FA332) --------------------------------------------------------
int __cdecl sub_80FA332(int a1)
{
  char *v1; // eax
  char *v2; // eax

  if ( HIWORD(a1) )
  {
    sub_8084E30((int)"not an entity");
  }
  else if ( !*((_DWORD *)&unk_8665480 + 140 * (unsigned __int16)a1 + 86) )
  {
    v1 = va("entity %i is not a player", (unsigned __int16)a1);
    sub_8084E30((int)v1);
  }
  v2 = va("%c", 103);
  return sub_810E5D8((unsigned __int16)a1, (int)v2);
}

//----- (080FA3B8) --------------------------------------------------------
int __usercall sub_80FA3B8@<eax>(long double a1@<st0>, int a2)
{
  char *v2; // eax
  char *v4; // [esp+1Ch] [ebp-2Ch]
  char v5; // [esp+20h] [ebp-28h]
  char v6; // [esp+30h] [ebp-18h]

  if ( HIWORD(a2) )
  {
    sub_8084E30((int)"not an entity");
    v4 = 0;
  }
  else
  {
    v4 = (char *)&unk_8665480 + 560 * (unsigned __int16)a2;
    if ( !*((_DWORD *)v4 + 86) )
    {
      v2 = va("entity %i is not a player", (unsigned __int16)a2);
      sub_8084E30((int)v2);
    }
  }
  sub_80846F8(0, &v6);
  sub_80846F8(1u, &v5);
  return sub_80F69B4(a1, (int)v4, &v6, &v5);
}

//----- (080FA45A) --------------------------------------------------------
int __cdecl sub_80FA45A(int a1)
{
  char *v1; // eax
  int v2; // ebx
  int result; // eax
  char *v4; // [esp+10h] [ebp-8h]

  if ( HIWORD(a1) )
  {
    sub_8084E30((int)"not an entity");
    v4 = 0;
  }
  else
  {
    v4 = (char *)&unk_8665480 + 560 * (unsigned __int16)a1;
    if ( !*((_DWORD *)v4 + 86) )
    {
      v1 = va("entity %i is not a player", (unsigned __int16)a1);
      sub_8084E30((int)v1);
    }
  }
  v2 = *((_DWORD *)v4 + 86);
  result = sub_808404C(0);
  *(_DWORD *)(v2 + 10028) = result;
  return result;
}

//----- (080FA50A) --------------------------------------------------------
int __usercall sub_80FA50A@<eax>(long double a1@<st0>, int a2)
{
  char *v2; // eax
  int v3; // ST28_4
  int v4; // eax
  int v5; // ST20_4
  _DWORD *v7; // [esp+14h] [ebp-24h]
  signed int i; // [esp+18h] [ebp-20h]
  int v9; // [esp+1Ch] [ebp-1Ch]
  _DWORD *v10; // [esp+2Ch] [ebp-Ch]
  _DWORD *v11; // [esp+30h] [ebp-8h]
  int v12; // [esp+34h] [ebp-4h]

  if ( HIWORD(a2) )
  {
    sub_8084E30((int)"not an entity");
    v7 = 0;
  }
  else
  {
    v7 = (_DWORD *)((char *)&unk_8665480 + 560 * (unsigned __int16)a2);
    if ( !v7[86] )
    {
      v2 = va("entity %i is not a player", (unsigned __int16)a2);
      sub_8084E30((int)v2);
    }
  }
  v12 = sub_808404C(0);
  v10 = (_DWORD *)v7[86];
  v11 = sub_811C614(a1);
  v11[36] = v10[51];
  v11[2] = v10[40] & 0xFFFFFFFD | v11[2] & 2 | 0xA0000;
  sub_811CF36(v11, v10 + 5);
  sub_811CF96(v11, v7 + 81);
  v11[3] = 5;
  v11[4] = dword_859B5EC;
  sub_80FB6EE(v10 + 8, v11 + 9);
  v11[1] = 2;
  *((_BYTE *)v11 + 352) = 1;
  v3 = sub_806289C(v10[51]);
  v9 = sub_80B8BB6(v3);
  for ( i = 0; i <= 1; ++i )
  {
    a1 = *(float *)(dword_8793DD4 + 8);
    if ( *(float *)&v11[i + 9] > a1 )
      v11[i + 9] = *(_DWORD *)(dword_8793DD4 + 8);
  }
  v11[106] = dword_859B5EC;
  v4 = sub_811C87C(a1);
  v5 = 1224 * v4 + 142202936;
  dword_879D83C[306 * v4] = *v11;
  *(_DWORD *)(v5 + 8) = dword_859B5EC;
  *(_BYTE *)(v5 + 1220) = 1;
  memcpy((void *)(1224 * v4 + 142202948), (const void *)(1208 * v10[51] + 140846652), 0x4B8u);
  *(_DWORD *)(v5 + 1200) = *(_DWORD *)v5;
  sub_80C063C(v9, *(_DWORD *)v5);
  v11[31] = 1023;
  *((_BYTE *)v11 + 242) = 2;
  sub_80FB6EE(v7 + 65, v11 + 65);
  sub_80FB6EE(v7 + 68, v11 + 68);
  sub_80FB6EE(v7 + 72, v11 + 72);
  sub_80FB6EE(v7 + 75, v11 + 75);
  v11[51] = v10[31];
  v11[52] = v10[33];
  v11[97] = 65537;
  v11[71] = 67117056;
  sub_809A45E((int)v11);
  v11[100] = dword_859B5EC + v12;
  *((_BYTE *)v11 + 358) = 12;
  return sub_8115AC2(v11);
}
// 8793DD4: using guessed type int dword_8793DD4;

//----- (080FA820) --------------------------------------------------------
void __cdecl sub_80FA820(int a1)
{
  char *v1; // eax
  int v2; // eax
  char *v3; // eax
  char v4; // dl
  char *v5; // eax
  char v6; // [esp+30h] [ebp-828h]
  char v7; // [esp+430h] [ebp-428h]
  char *v8; // [esp+838h] [ebp-20h]
  char *s; // [esp+83Ch] [ebp-1Ch]
  char v10[4]; // [esp+840h] [ebp-18h]
  int v11; // [esp+844h] [ebp-14h]
  size_t v12; // [esp+848h] [ebp-10h]
  int v13; // [esp+84Ch] [ebp-Ch]

  if ( HIWORD(a1) )
  {
    sub_8084E30((int)"not an entity");
  }
  else if ( !*((_DWORD *)&unk_8665480 + 140 * (unsigned __int16)a1 + 86) )
  {
    v1 = va("entity %i is not a player", (unsigned __int16)a1);
    sub_8084E30((int)v1);
  }
  *(_DWORD *)v10 = sub_808456A(0);
  v11 = sub_80849A8(1u);
  if ( v11 == 3 )
  {
    v2 = sub_8084AEE();
    sub_810E290(1, v2 - 1, (int)"Client Dvar Value", (int)&v7, 1024);
    s = &v7;
  }
  else
  {
    s = (char *)sub_808456A(1u);
  }
  v12 = strlen(s);
  if ( (unsigned __int8)sub_80AEF62(*(int *)v10) )
  {
    v8 = &v6;
    memset(&v6, 0, 0x400u);
    v13 = 0;
    while ( v13 <= 0x1FFF && s[v13] )
    {
      v4 = sub_80B5904(s[v13]);
      *v8 = v4;
      if ( *v8 == 34 )
        *v8 = 39;
      ++v13;
      ++v8;
    }
    v5 = va("%c %s \"%s\"", 118, *(_DWORD *)v10, &v6);
    sub_808FE96((unsigned __int16)a1, 1, (int)v5);
  }
  else
  {
    v3 = va("Dvar %s has an invalid dvar name", *(_DWORD *)v10);
    sub_8084DB4((int)v3);
  }
}

//----- (080FA9EE) --------------------------------------------------------
int __cdecl sub_80FA9EE(int a1)
{
  char *v1; // eax
  int result; // eax
  char *v3; // [esp+10h] [ebp-8h]
  int v4; // [esp+14h] [ebp-4h]

  if ( HIWORD(a1) )
  {
    sub_8084E30((int)"not an entity");
    v3 = 0;
  }
  else
  {
    v3 = (char *)&unk_8665480 + 560 * (unsigned __int16)a1;
    if ( !*((_DWORD *)v3 + 86) )
    {
      v1 = va("entity %i is not a player", (unsigned __int16)a1);
      sub_8084E30((int)v1);
    }
  }
  v4 = dword_859B5EC - *(_DWORD *)(*((_DWORD *)v3 + 86) + 10248);
  if ( v4 < 0 || v4 >= *(_DWORD *)(dword_8793DE8 + 8) )
    result = Scr_AddInt(0);
  else
    result = Scr_AddInt(1);
  return result;
}
// 8793DE8: using guessed type int dword_8793DE8;

//----- (080FAA98) --------------------------------------------------------
int __cdecl sub_80FAA98(int a1)
{
  char *v1; // eax
  int v2; // ebx
  int result; // eax
  char *v4; // [esp+10h] [ebp-8h]

  if ( HIWORD(a1) )
  {
    sub_8084E30((int)"not an entity");
    v4 = 0;
  }
  else
  {
    v4 = (char *)&unk_8665480 + 560 * (unsigned __int16)a1;
    if ( !*((_DWORD *)v4 + 86) )
    {
      v1 = va("entity %i is not a player", (unsigned __int16)a1);
      sub_8084E30((int)v1);
    }
  }
  v2 = *((_DWORD *)v4 + 86);
  result = sub_808404C(0);
  *(_DWORD *)(v2 + 10164) = result;
  return result;
}

//----- (080FAB1A) --------------------------------------------------------
int __cdecl sub_80FAB1A(int a1)
{
  char *v1; // eax
  int result; // eax
  char *v3; // [esp+14h] [ebp-4h]

  if ( HIWORD(a1) )
  {
    sub_8084E30((int)"not an entity");
    v3 = 0;
  }
  else
  {
    v3 = (char *)&unk_8665480 + 560 * (unsigned __int16)a1;
    if ( !*((_DWORD *)v3 + 86) )
    {
      v1 = va("entity %i is not a player", (unsigned __int16)a1);
      sub_8084E30((int)v1);
    }
  }
  result = *(_DWORD *)(*((_DWORD *)v3 + 86) + 12) | 0x4000000;
  *(_DWORD *)(*((_DWORD *)v3 + 86) + 12) = result;
  return result;
}

//----- (080FAB9A) --------------------------------------------------------
unsigned int __cdecl sub_80FAB9A(int a1)
{
  char *v1; // eax
  unsigned int result; // eax
  char *v3; // [esp+14h] [ebp-4h]

  if ( HIWORD(a1) )
  {
    sub_8084E30((int)"not an entity");
    v3 = 0;
  }
  else
  {
    v3 = (char *)&unk_8665480 + 560 * (unsigned __int16)a1;
    if ( !*((_DWORD *)v3 + 86) )
    {
      v1 = va("entity %i is not a player", (unsigned __int16)a1);
      sub_8084E30((int)v1);
    }
  }
  result = *(_DWORD *)(*((_DWORD *)v3 + 86) + 12) & 0xFBFFFFFF;
  *(_DWORD *)(*((_DWORD *)v3 + 86) + 12) = result;
  return result;
}

//----- (080FAC1A) --------------------------------------------------------
void __cdecl sub_80FAC1A(int a1)
{
  char *v1; // eax
  char *v2; // eax
  unsigned int v3; // [esp+28h] [ebp-20h]
  float v4; // [esp+30h] [ebp-18h]
  float v5; // [esp+34h] [ebp-14h]
  float v6; // [esp+38h] [ebp-10h]
  int v7; // [esp+3Ch] [ebp-Ch]
  signed int v8; // [esp+40h] [ebp-8h]
  __int16 v9; // [esp+46h] [ebp-2h]

  if ( HIWORD(a1) )
  {
    sub_8084E30((int)"not an entity");
  }
  else if ( !*((_DWORD *)&unk_8665480 + 140 * (unsigned __int16)a1 + 86) )
  {
    v1 = va("entity %i is not a player", (unsigned __int16)a1);
    sub_8084E30((int)v1);
  }
  v4 = 0.0;
  v6 = 1.0;
  v5 = 0.5;
  v3 = sub_8084AEE();
  if ( v3 == 3 )
  {
LABEL_13:
    v6 = sub_8084320(2u);
    goto LABEL_14;
  }
  if ( v3 > 3 )
  {
    if ( v3 != 4 )
    {
      if ( v3 != 5 )
      {
LABEL_20:
        sub_8084DB4((int)"USAGE: player setReverb(\"priority\", \"roomtype\", drylevel = 1.0, wetlevel = 0.5, fadetime = "
                         "0);\n"
                         "Valid priorities are \"snd_enveffectsprio_level\" or \"snd_enveffectsprio_shellshock\", dry lev"
                         "el is a float from 0 (no source sound) to 1 (full source sound), wetlevel is a float from 0 (no"
                         " effect) to 1 (full effect), fadetime is in sec and modifies drylevel and wetlevel\n");
        return;
      }
      v4 = sub_8084320(4u);
    }
    v5 = sub_8084320(3u);
    goto LABEL_13;
  }
  if ( v3 != 2 )
    goto LABEL_20;
LABEL_14:
  v7 = sub_808456A(1u);
  v9 = sub_80843C0(0);
  v8 = 1;
  if ( v9 == word_87A2322 )
  {
    v8 = 1;
  }
  else if ( v9 == word_87A2324 )
  {
    v8 = 2;
  }
  else
  {
    sub_8084DB4((int)"priority must be 'snd_enveffectsprio_level' or 'snd_enveffectsprio_shellshock'\n");
  }
  v2 = va("%c %i \"%s\" %g %g %g", 114, v8, v7, v6, v5, v4);
  sub_808FE96((unsigned __int16)a1, 1, (int)v2);
}
// 87A2322: using guessed type __int16 word_87A2322;
// 87A2324: using guessed type __int16 word_87A2324;

//----- (080FADAC) --------------------------------------------------------
void __cdecl sub_80FADAC(int a1)
{
  char *v1; // eax
  char *v2; // eax
  int v3; // [esp+14h] [ebp-14h]
  float v4; // [esp+1Ch] [ebp-Ch]
  signed int v5; // [esp+20h] [ebp-8h]
  __int16 v6; // [esp+26h] [ebp-2h]

  if ( HIWORD(a1) )
  {
    sub_8084E30((int)"not an entity");
  }
  else if ( !*((_DWORD *)&unk_8665480 + 140 * (unsigned __int16)a1 + 86) )
  {
    v1 = va("entity %i is not a player", (unsigned __int16)a1);
    sub_8084E30((int)v1);
  }
  v4 = 0.0;
  v3 = sub_8084AEE();
  if ( v3 != 1 )
  {
    if ( v3 != 2 )
    {
      sub_8084DB4((int)"USAGE: player deactivateReverb(\"priority\", fadetime = 0);\n"
                       "Valid priorities are \"snd_enveffectsprio_level\" or \"snd_enveffectsprio_shellshock\", fadetime "
                       "is the time spent fading to the next lowest active reverb priority level in seconds\n");
      return;
    }
    v4 = sub_8084320(1u);
  }
  v6 = sub_80843C0(0);
  v5 = 1;
  if ( v6 == word_87A2322 )
  {
    v5 = 1;
  }
  else if ( v6 == word_87A2324 )
  {
    v5 = 2;
  }
  else
  {
    sub_8084DB4((int)"priority must be 'snd_enveffectsprio_level' or 'snd_enveffectsprio_shellshock'\n");
  }
  v2 = va("%c %i \"%s\" %g %g %g", 68, v5, v4);
  sub_808FE96((unsigned __int16)a1, 1, (int)v2);
}
// 87A2322: using guessed type __int16 word_87A2322;
// 87A2324: using guessed type __int16 word_87A2324;

//----- (080FAED6) --------------------------------------------------------
void __cdecl sub_80FAED6(int a1)
{
  char *v1; // eax
  char *v2; // eax
  char *v3; // eax
  int v4; // [esp+20h] [ebp-18h]
  float v5; // [esp+28h] [ebp-10h]
  int v6; // [esp+2Ch] [ebp-Ch]
  signed int v7; // [esp+30h] [ebp-8h]
  __int16 v8; // [esp+36h] [ebp-2h]

  if ( HIWORD(a1) )
  {
    sub_8084E30((int)"not an entity");
  }
  else if ( !*((_DWORD *)&unk_8665480 + 140 * (unsigned __int16)a1 + 86) )
  {
    v1 = va("entity %i is not a player", (unsigned __int16)a1);
    sub_8084E30((int)v1);
  }
  v5 = 0.0;
  v4 = sub_8084AEE();
  if ( v4 != 2 )
  {
    if ( v4 != 3 )
    {
      sub_8084DB4((int)"USAGE: player setchannelvolumes(\"priority\", \"shock name\", fadetime = 0);\n"
                       "Valid priorities are \"snd_channelvolprio_holdbreath\", \"snd_channelvolprio_pain\", or \"snd_cha"
                       "nnelvolprio_shellshock\", fadetime is in sec\n");
      return;
    }
    v5 = sub_8084320(2u);
  }
  v2 = (char *)sub_808456A(1u);
  v6 = sub_811AE70(v2, 1166, 16, 0, 0);
  v8 = sub_80843C0(0);
  v7 = 1;
  if ( v8 == word_87A2326 )
  {
    v7 = 1;
  }
  else if ( v8 == word_87A2328 )
  {
    v7 = 2;
  }
  else if ( v8 == word_87A232A )
  {
    v7 = 3;
  }
  else
  {
    sub_8084DB4((int)"priority must be 'snd_channelvolprio_holdbreath', 'snd_channelvolprio_pain', or 'snd_channelvolprio_shellshock'\n");
  }
  v3 = va("%c %i %i %g", 69, v7, v6, v5);
  sub_808FE96((unsigned __int16)a1, 1, (int)v3);
}
// 87A2326: using guessed type __int16 word_87A2326;
// 87A2328: using guessed type __int16 word_87A2328;
// 87A232A: using guessed type __int16 word_87A232A;

//----- (080FB054) --------------------------------------------------------
void __cdecl sub_80FB054(int a1)
{
  char *v1; // eax
  char *v2; // eax
  int v3; // [esp+14h] [ebp-14h]
  float v4; // [esp+1Ch] [ebp-Ch]
  signed int v5; // [esp+20h] [ebp-8h]
  __int16 v6; // [esp+26h] [ebp-2h]

  if ( HIWORD(a1) )
  {
    sub_8084E30((int)"not an entity");
  }
  else if ( !*((_DWORD *)&unk_8665480 + 140 * (unsigned __int16)a1 + 86) )
  {
    v1 = va("entity %i is not a player", (unsigned __int16)a1);
    sub_8084E30((int)v1);
  }
  v4 = 0.0;
  v3 = sub_8084AEE();
  if ( v3 != 1 )
  {
    if ( v3 != 2 )
    {
      sub_8084DB4((int)"USAGE: player deactivatechannelvolumes(\"priority\", fadetime = 0);\n"
                       "Valid priorities are \"snd_channelvolprio_holdbreath\", \"snd_channelvolprio_pain\", or \"snd_cha"
                       "nnelvolprio_shellshock\", fadetime is the time spent fading to the next lowest active reverb prio"
                       "rity level in seconds\n");
      return;
    }
    v4 = sub_8084320(1u);
  }
  v6 = sub_80843C0(0);
  v5 = 1;
  if ( v6 == word_87A2326 )
  {
    v5 = 1;
  }
  else if ( v6 == word_87A2328 )
  {
    v5 = 2;
  }
  else if ( v6 == word_87A232A )
  {
    v5 = 3;
  }
  else
  {
    sub_8084DB4((int)"priority must be 'snd_channelvolprio_holdbreath', 'snd_channelvolprio_pain', or 'snd_channelvolprio_shellshock'\n");
  }
  v2 = va("%c %i \"%s\" %g %g %g", 70, v5, v4);
  sub_808FE96((unsigned __int16)a1, 1, (int)v2);
}
// 87A2326: using guessed type __int16 word_87A2326;
// 87A2328: using guessed type __int16 word_87A2328;
// 87A232A: using guessed type __int16 word_87A232A;

//----- (080FB194) --------------------------------------------------------
int __cdecl sub_80FB194(int a1)
{
  char *v1; // eax
  int v2; // ebx
  int v3; // eax
  char *v5; // [esp+10h] [ebp-8h]

  if ( HIWORD(a1) )
  {
    sub_8084E30((int)"not an entity");
    v5 = 0;
  }
  else
  {
    v5 = (char *)&unk_8665480 + 560 * (unsigned __int16)a1;
    if ( !*((_DWORD *)v5 + 86) )
    {
      v1 = va("entity %i is not a player", (unsigned __int16)a1);
      sub_8084E30((int)v1);
    }
  }
  v2 = *((_DWORD *)v5 + 86);
  v3 = sub_8118CDE(0);
  return Scr_AddInt(*(_DWORD *)(v2 + 10284) == v3);
}

//----- (080FB224) --------------------------------------------------------
int __cdecl sub_80FB224(int a1)
{
  char *v1; // eax
  char *v2; // eax
  unsigned __int8 v3; // al
  char *v4; // eax

  if ( HIWORD(a1) )
  {
    sub_8084E30((int)"not an entity");
  }
  else if ( !*((_DWORD *)&unk_8665480 + 140 * (unsigned __int16)a1 + 86) )
  {
    v1 = va("entity %i is not a player", (unsigned __int16)a1);
    sub_8084E30((int)v1);
  }
  v2 = (char *)sub_808456A(0);
  v3 = sub_811B1D8(v2);
  v4 = va("%c %i", 115, v3);
  return sub_808FE96((unsigned __int16)a1, 0, (int)v4);
}

//----- (080FB2D4) --------------------------------------------------------
void __cdecl sub_80FB2D4(int a1)
{
  char *v1; // eax
  int v2; // eax
  char *v3; // [esp+2Ch] [ebp-40Ch]
  char src; // [esp+30h] [ebp-408h]
  _BYTE v5[3]; // [esp+31h] [ebp-407h]

  if ( HIWORD(a1) )
  {
    sub_8084E30((int)"not an entity");
    v3 = 0;
  }
  else
  {
    v3 = (char *)&unk_8665480 + 560 * (unsigned __int16)a1;
    if ( !*((_DWORD *)v3 + 86) )
    {
      v1 = va("entity %i is not a player", (unsigned __int16)a1);
      sub_8084E30((int)v1);
    }
  }
  v2 = sub_8084AEE();
  sub_810E290(0, v2 - 1, (int)"Client Chat Message", (int)v5, 1023);
  src = 20;
  sub_80FCFC8((int)v3, 0, 0, &src);
}

//----- (080FB3A4) --------------------------------------------------------
void __cdecl sub_80FB3A4(int a1)
{
  char *v1; // eax
  int v2; // eax
  char *v3; // [esp+2Ch] [ebp-40Ch]
  char src; // [esp+30h] [ebp-408h]
  _BYTE v5[3]; // [esp+31h] [ebp-407h]

  if ( HIWORD(a1) )
  {
    sub_8084E30((int)"not an entity");
    v3 = 0;
  }
  else
  {
    v3 = (char *)&unk_8665480 + 560 * (unsigned __int16)a1;
    if ( !*((_DWORD *)v3 + 86) )
    {
      v1 = va("entity %i is not a player", (unsigned __int16)a1);
      sub_8084E30((int)v1);
    }
  }
  v2 = sub_8084AEE();
  sub_810E290(0, v2 - 1, (int)"Client Chat Message", (int)v5, 1023);
  src = 20;
  sub_80FCFC8((int)v3, 0, 1, &src);
}

//----- (080FB474) --------------------------------------------------------
int __cdecl sub_80FB474(int a1)
{
  char *v1; // eax
  int v2; // ecx
  int result; // eax
  char *v4; // [esp+8h] [ebp-10h]
  signed int v5; // [esp+10h] [ebp-8h]
  __int16 v6; // [esp+16h] [ebp-2h]

  if ( HIWORD(a1) )
  {
    sub_8084E30((int)"not an entity");
    v4 = 0;
  }
  else
  {
    v4 = (char *)&unk_8665480 + 560 * (unsigned __int16)a1;
    if ( !*((_DWORD *)v4 + 86) )
    {
      v1 = va("entity %i is not a player", (unsigned __int16)a1);
      sub_8084E30((int)v1);
    }
  }
  v6 = sub_80843C0(0);
  v5 = 0;
  if ( v6 == word_87A22A4 )
  {
    v5 = 2;
  }
  else if ( v6 == word_87A22A2 )
  {
    v5 = 4;
  }
  else if ( v6 == word_87A2314 )
  {
    v5 = 1;
  }
  else if ( v6 == word_87A231C )
  {
    v5 = 16;
  }
  else
  {
    sub_8084E14(0, (int)"team must be \"axis\", \"allies\", \"none\", or \"freelook\"");
  }
  if ( sub_808404C(1u) )
  {
    v2 = *((_DWORD *)v4 + 86);
    result = *(_DWORD *)(*((_DWORD *)v4 + 86) + 10048) & ~v5;
  }
  else
  {
    v2 = *((_DWORD *)v4 + 86);
    result = *(_DWORD *)(*((_DWORD *)v4 + 86) + 10048) | v5;
  }
  *(_DWORD *)(v2 + 10048) = result;
  return result;
}
// 87A22A2: using guessed type __int16 word_87A22A2;
// 87A22A4: using guessed type __int16 word_87A22A4;
// 87A2314: using guessed type __int16 word_87A2314;
// 87A231C: using guessed type __int16 word_87A231C;

//----- (080FB5B4) --------------------------------------------------------
int __cdecl sub_80FB5B4(int a1)
{
  char *v1; // eax
  int v2; // eax

  if ( HIWORD(a1) )
  {
    sub_8084E30((int)"not an entity");
  }
  else if ( !*((_DWORD *)&unk_8665480 + 140 * (unsigned __int16)a1 + 86) )
  {
    v1 = va("entity %i is not a player", (unsigned __int16)a1);
    sub_8084E30((int)v1);
  }
  if ( sub_8084AEE() )
    sub_8084DB4((int)"USAGE: self getGuid()\n");
  v2 = sub_8090AFE((unsigned __int16)a1);
  return Scr_AddInt(v2);
}

//----- (080FB640) --------------------------------------------------------
int (__cdecl *__cdecl sub_80FB640(char **a1))(__int16)
{
  char *s1; // [esp+10h] [ebp-8h]
  unsigned int i; // [esp+14h] [ebp-4h]

  s1 = *a1;
  for ( i = 0; i <= 0x3A; ++i )
  {
    if ( !strcmp(s1, (&off_81518E0)[3 * i]) )
    {
      *a1 = (&off_81518E0)[3 * i];
      return off_81518E4[3 * i];
    }
  }
  return 0;
}
// 81518E0: using guessed type char *off_81518E0;

//----- (080FB6C4) --------------------------------------------------------
int __cdecl sub_80FB6C4(_DWORD *a1)
{
  int result; // eax

  *a1 = 0;
  a1[1] = 0;
  result = 0;
  a1[2] = 0;
  return result;
}

//----- (080FB6EE) --------------------------------------------------------
int __cdecl sub_80FB6EE(_DWORD *a1, _DWORD *a2)
{
  int result; // eax

  *a2 = *a1;
  a2[1] = a1[1];
  result = a1[2];
  a2[2] = result;
  return result;
}

//----- (080FB71E) --------------------------------------------------------
int __cdecl sub_80FB71E(float *a1, float *a2, float *a3)
{
  int result; // eax

  *a3 = *a1 + *a2;
  a3[1] = a1[1] + a2[1];
  result = (int)(a1 + 2);
  a3[2] = a1[2] + a2[2];
  return result;
}

//----- (080FB762) --------------------------------------------------------
int __cdecl sub_80FB762(int a1, float a2, int a3)
{
  int result; // eax

  *(float *)a3 = a2 * *(float *)a1;
  *(float *)(a3 + 4) = a2 * *(float *)(a1 + 4);
  result = a1 + 8;
  *(float *)(a3 + 8) = a2 * *(float *)(a1 + 8);
  return result;
}

//----- (080FB79C) --------------------------------------------------------
int __cdecl sub_80FB79C(int a1)
{
  int v1; // ST20_4
  char *v2; // eax
  int v4; // [esp+24h] [ebp-9A4h]
  signed int v5; // [esp+2Ch] [ebp-99Ch]
  _DWORD *v6; // [esp+30h] [ebp-998h]
  size_t v7; // [esp+34h] [ebp-994h]
  signed int i; // [esp+38h] [ebp-990h]
  int v9; // [esp+3Ch] [ebp-98Ch]
  char v10[1408]; // [esp+40h] [ebp-988h]
  char s; // [esp+5C0h] [ebp-408h]

  v10[0] = 0;
  v9 = 0;
  v5 = nmemb;
  if ( (signed int)nmemb > 64 )
    v5 = 64;
  for ( i = 0; i < v5; ++i )
  {
    v4 = *(_DWORD *)&dword_859B61C[4 * i];
    v6 = (_DWORD *)(dword_859B400 + 10404 * v4);
    if ( *(_DWORD *)(dword_859B400 + 10404 * v4 + 9924) == 1 )
    {
      Com_sprintf(&s, 0x400u, " %i %i %i %i %i", *(_DWORD *)&dword_859B61C[4 * i], v6[2478], -1, v6[2479], v6[2476]);
    }
    else
    {
      v1 = sub_8090B42(v4);
      Com_sprintf(&s, 0x400u, " %i %i %i %i %i", *(_DWORD *)&dword_859B61C[4 * i], v6[2478], v1, v6[2479], v6[2476]);
    }
    v7 = strlen(&s);
    if ( (signed int)(v9 + v7) > 1024 )
      break;
    strcpy(&v10[v9], &s);
    v9 += v7;
  }
  v2 = va("%c %i %i %i%s", 98, i, *(_DWORD *)dword_859B600, *(_DWORD *)dword_859B604, v10);
  return sub_808FE96(-1963413621 * ((a1 - (signed int)&unk_8665480) >> 4), 1, (int)v2);
}
// 859B400: using guessed type int dword_859B400;
// 80FB79C: using guessed type char var_988[1408];

//----- (080FB982) --------------------------------------------------------
int __cdecl sub_80FB982(int a1)
{
  return sub_80FB79C(a1);
}

//----- (080FB996) --------------------------------------------------------
signed int __cdecl sub_80FB996(int a1)
{
  char *v1; // eax
  char *v2; // eax
  signed int v4; // [esp+14h] [ebp-4h]

  if ( *(_BYTE *)(dword_8793D98 + 8) )
  {
    if ( *(_DWORD *)(a1 + 404) > 0 )
    {
      v4 = 1;
    }
    else
    {
      v2 = va("%c \"GAME_MUSTBEALIVECOMMAND\"", 101);
      sub_808FE96(-1963413621 * ((a1 - (signed int)&unk_8665480) >> 4), 0, (int)v2);
      v4 = 0;
    }
  }
  else
  {
    v1 = va("%c \"GAME_CHEATSNOTENABLED\"", 101);
    sub_808FE96(-1963413621 * ((a1 - (signed int)&unk_8665480) >> 4), 0, (int)v1);
    v4 = 0;
  }
  return v4;
}
// 8793D98: using guessed type int dword_8793D98;

//----- (080FBA44) --------------------------------------------------------
void *__cdecl sub_80FBA44(int a1)
{
  char s; // [esp+10h] [ebp-418h]
  int v3; // [esp+410h] [ebp-18h]
  size_t n; // [esp+414h] [ebp-14h]
  int v5; // [esp+418h] [ebp-10h]
  int i; // [esp+41Ch] [ebp-Ch]

  v3 = 0;
  v5 = sub_805FFE6();
  for ( i = a1; i < v5; ++i )
  {
    sub_8060074(i, &s, 1024);
    n = strlen(&s);
    if ( (signed int)(v3 + n) > 1022 )
      break;
    memcpy((char *)&unk_8577B60 + v3, &s, n);
    v3 += n;
    if ( i != v5 - 1 )
      *(_BYTE *)(v3++ + 139950944) = 32;
  }
  *(_BYTE *)(v3 + 139950944) = 0;
  return &unk_8577B60;
}

//----- (080FBB0A) --------------------------------------------------------
_BYTE *__cdecl sub_80FBB0A(_BYTE *a1, _BYTE *a2)
{
  _BYTE *v2; // ebx
  int v3; // ST00_4
  _BYTE *result; // eax

  while ( *a1 )
  {
    if ( *a1 == 27 )
    {
      a1 += 2;
    }
    else if ( *a1 > 31 )
    {
      v2 = a2;
      v3 = (char)*a1++;
      ++a2;
      *v2 = tolower(v3);
    }
    else
    {
      ++a1;
    }
  }
  result = a2;
  *a2 = 0;
  return result;
}

//----- (080FBB62) --------------------------------------------------------
int __cdecl sub_80FBB62(int a1, char *nptr)
{
  char *v2; // eax
  char *v3; // eax
  char *v4; // eax
  signed int v6; // [esp+1Ch] [ebp-81Ch]
  char s1; // [esp+20h] [ebp-818h]
  char s2; // [esp+420h] [ebp-418h]
  int v9; // [esp+828h] [ebp-10h]
  int v10; // [esp+82Ch] [ebp-Ch]

  if ( *nptr <= 47 || *nptr > 57 )
  {
    sub_80FBB0A(nptr, &s2);
    v9 = 0;
    v10 = dword_859B400;
    while ( v9 < dword_859B5E4 )
    {
      if ( *(_DWORD *)(v10 + 9924) == 2 )
      {
        sub_80FBB0A((_BYTE *)(v10 + 10116), &s1);
        if ( !strcmp(&s1, &s2) )
          return v9;
      }
      ++v9;
      v10 += 10404;
    }
    v4 = va(aCGameUsernoton, 101, nptr);
    sub_808FE96(-1963413621 * ((a1 - (signed int)&unk_8665480) >> 4), 0, (int)v4);
    v6 = -1;
  }
  else
  {
    v9 = atoi(nptr);
    if ( v9 >= 0 && v9 < dword_859B5E4 )
    {
      v10 = dword_859B400 + 10404 * v9;
      if ( *(_DWORD *)(dword_859B400 + 10404 * v9 + 9924) == 2 )
      {
        v6 = v9;
      }
      else
      {
        v3 = va(aCGameClientnot_0, 101, v9);
        sub_808FE96(-1963413621 * ((a1 - (signed int)&unk_8665480) >> 4), 0, (int)v3);
        v6 = -1;
      }
    }
    else
    {
      v2 = va(aCGameBadclient, 101, v9);
      sub_808FE96(-1963413621 * ((a1 - (signed int)&unk_8665480) >> 4), 0, (int)v2);
      v6 = -1;
    }
  }
  return v6;
}
// 859B400: using guessed type int dword_859B400;
// 859B5E4: using guessed type int dword_859B5E4;

//----- (080FBD50) --------------------------------------------------------
void __cdecl sub_80FBD50(char *s)
{
  char v1; // [esp+3Ch] [ebp-2Ch]
  char v2; // [esp+40h] [ebp-28h]
  int v3; // [esp+44h] [ebp-24h]
  int v4; // [esp+48h] [ebp-20h]
  float v5; // [esp+54h] [ebp-14h]
  float v6; // [esp+58h] [ebp-10h]
  float v7; // [esp+5Ch] [ebp-Ch]

  sub_8090E6C(12, s);
  dword_859D1D8 = 2139095039;
  dword_859D1DC = 2139095039;
  if ( sscanf(s, "%f %f %f %f %f %f %f", &v7, &v6, &v5, &v2, &v3, &v4, &v1) == 7 && v5 >= 1.0 )
  {
    *(float *)&dword_859D1D8 = v6 - v7 + v7;
    *(float *)&dword_859D1DC = *(float *)&dword_859D1D8 * *(float *)&dword_859D1D8;
  }
}
// 859D1D8: using guessed type int dword_859D1D8;
// 859D1DC: using guessed type int dword_859D1DC;

//----- (080FBE00) --------------------------------------------------------
void sub_80FBE00()
{
  char *v0; // eax

  v0 = (char *)sub_80FBA44(1);
  sub_80FBD50(v0);
}

//----- (080FBE1C) --------------------------------------------------------
char *__usercall sub_80FBE1C@<eax>(long double a1@<st0>, int *a2)
{
  char *result; // eax
  char *nptr; // ST30_4
  signed int v4; // [esp+18h] [ebp-20h]
  int v5; // [esp+1Ch] [ebp-1Ch]
  _DWORD *s; // [esp+20h] [ebp-18h]
  _BOOL4 v7; // [esp+24h] [ebp-14h]
  signed int i; // [esp+28h] [ebp-10h]
  int j; // [esp+28h] [ebp-10h]
  int k; // [esp+28h] [ebp-10h]
  int l; // [esp+28h] [ebp-10h]
  char **v12; // [esp+2Ch] [ebp-Ch]
  char *v13; // [esp+34h] [ebp-4h]

  result = (char *)sub_80FB996((int)a2);
  if ( result )
  {
    nptr = (char *)sub_80FBA44(2);
    v5 = atoi(nptr);
    result = (char *)sub_80FBA44(1);
    v13 = result;
    if ( result )
    {
      if ( *result )
      {
        if ( (v7 = I_stricmp(result, "all") == 0) == 0 && sub_80B550A(v13, "health", 6)
          || (!v5 ? (result = *(char **)(a2[86] + 308)) : (result = (char *)(a2[101] + v5)), a2[101] = (int)result, v7) )
        {
          if ( !v7 && I_stricmp(v13, "weapons") )
            goto LABEL_51;
          dword_859B41C = 1;
          v4 = *(char *)(a2[86] + 1366);
          sub_80E98CA(a2[86], *(char *)(a2[86] + 1365));
          sub_80E98CA(a2[86], *(char *)(a2[86] + 1366));
          for ( i = 1; i <= sub_80E9322(); ++i )
          {
            if ( (unsigned __int8)sub_80E9782(i) )
            {
              if ( i > v4 )
              {
                if ( (unsigned __int8)sub_80E97BE(a2[86]) )
                  sub_811E696(a2[86], i);
              }
            }
            else
            {
              sub_811E696(a2[86], i);
            }
          }
          for ( j = 1; ; ++j )
          {
            result = (char *)sub_80E97BE(a2[86]);
            if ( !(_BYTE)result )
              break;
            result = (char *)sub_80E9322();
            if ( j > (signed int)result )
              break;
            if ( (unsigned __int8)sub_80E9782(j) )
              sub_811E696(a2[86], j);
          }
          dword_859B41C = 0;
          if ( v7 )
          {
LABEL_51:
            if ( !v7 && sub_80B550A(v13, "ammo", 4) )
              goto LABEL_49;
            if ( v5 )
            {
              result = (char *)a2[86];
              if ( *((_DWORD *)result + 53) )
                result = (char *)sub_8102704((int)a2, *(_DWORD *)(a2[86] + 212), v5, 1);
            }
            else
            {
              for ( k = 1; ; sub_8102704((int)a2, k++, 998, 1) )
              {
                result = (char *)sub_80E9322();
                if ( k > (signed int)result )
                  break;
              }
            }
            if ( v7 )
            {
LABEL_49:
              result = (char *)sub_80B550A(v13, "allammo", 7);
              if ( result )
                goto LABEL_50;
              if ( !v5 )
                goto LABEL_50;
              for ( l = 1; ; sub_8102704((int)a2, l++, v5, 1) )
              {
                result = (char *)sub_80E9322();
                if ( l > (signed int)result )
                  break;
              }
              if ( v7 )
              {
LABEL_50:
                if ( !v7 )
                {
                  result = sub_80DCB02(v13);
                  v12 = (char **)result;
                  if ( result )
                  {
                    dword_859B41C = 1;
                    s = (_DWORD *)sub_811C546();
                    sub_80FEE3C(a2 + 78, s + 78);
                    sub_8103CB2(v12, (int)(s + 90));
                    sub_8104EB2(a1, (int)s, (int)v12);
                    *((_BYTE *)s + 354) = 1;
                    sub_810381C(a1, (unsigned __int16 *)s, a2, 1);
                    *((_BYTE *)s + 354) = 0;
                    result = (char *)s;
                    if ( *((_BYTE *)s + 252) )
                      result = (char *)sub_811C9C0(a1, s);
                    dword_859B41C = 0;
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  return result;
}

//----- (080FC25E) --------------------------------------------------------
char *__cdecl sub_80FC25E(int a1)
{
  char *result; // eax
  char *nptr; // ST24_4
  int v3; // ebx
  int v4; // ebx
  int v5; // ebx
  int v6; // eax
  int v7; // ebx
  int v8; // ST14_4
  int v9; // esi
  int v10; // edi
  int v11; // ebx
  int v12; // ebx
  int v13; // ebx
  int v14; // ebx
  int v15; // ebx
  int v16; // ebx
  int v17; // ebx
  int v18; // eax
  int v19; // ebx
  int v20; // ST10_4
  int v21; // esi
  int v22; // edi
  int v23; // ebx
  int v24; // ebx
  int v25; // ebx
  int v26; // ebx
  int v27; // [esp+18h] [ebp-20h]
  _BOOL4 v28; // [esp+1Ch] [ebp-1Ch]
  signed int i; // [esp+20h] [ebp-18h]
  int v30; // [esp+20h] [ebp-18h]
  signed int j; // [esp+20h] [ebp-18h]
  int k; // [esp+20h] [ebp-18h]
  char *v33; // [esp+28h] [ebp-10h]

  result = (char *)sub_80FB996(a1);
  if ( result )
  {
    nptr = (char *)sub_80FBA44(2);
    v27 = atoi(nptr);
    result = (char *)sub_80FBA44(1);
    v33 = result;
    if ( result )
    {
      if ( *result )
      {
        v28 = I_stricmp(result, "all") == 0;
        if ( !v28 )
        {
          if ( sub_80B550A(v33, "health", 6) )
            goto LABEL_40;
        }
        if ( v27 )
        {
          *(_DWORD *)(a1 + 404) -= v27;
          result = (char *)a1;
          if ( *(_DWORD *)(a1 + 404) <= 0 )
          {
            result = (char *)a1;
            *(_DWORD *)(a1 + 404) = 1;
          }
        }
        else
        {
          result = (char *)a1;
          *(_DWORD *)(a1 + 404) = 1;
        }
        if ( v28 )
        {
LABEL_40:
          if ( !v28 && I_stricmp(v33, "weapons") )
            goto LABEL_41;
          for ( i = 1; i <= sub_80E9322(); ++i )
          {
            sub_80E98CA(*(_DWORD *)(a1 + 344), i);
            v3 = *(_DWORD *)(a1 + 344);
            *(_DWORD *)(v3 + 4 * sub_80EAC94(i) + 324) = 0;
            v4 = *(_DWORD *)(a1 + 344);
            *(_DWORD *)(v4 + 4 * sub_80EAC7A(i) + 836) = 0;
          }
          result = *(char **)(a1 + 344);
          if ( *((_DWORD *)result + 53) )
          {
            *(_DWORD *)(*(_DWORD *)(a1 + 344) + 212) = 0;
            result = (char *)sub_811E97A(-1963413621 * ((a1 - (signed int)&unk_8665480) >> 4), 0);
          }
          if ( v28 )
          {
LABEL_41:
            if ( !v28 && sub_80B550A(v33, "ammo", 4) )
              goto LABEL_42;
            if ( v27 )
            {
              result = *(char **)(a1 + 344);
              if ( *((_DWORD *)result + 53) )
              {
                v30 = *(_DWORD *)(*(_DWORD *)(a1 + 344) + 212);
                v5 = *(_DWORD *)(a1 + 344);
                v6 = sub_80EAC94(v30);
                *(_DWORD *)(v5 + 4 * v6 + 324) = *(_DWORD *)(*(_DWORD *)(a1 + 344) + 4 * v6 + 324) - v27;
                v7 = *(_DWORD *)(a1 + 344);
                result = (char *)sub_80EAC94(v30);
                if ( *(_DWORD *)(v7 + 4 * (_DWORD)result + 324) < 0 )
                {
                  v8 = *(_DWORD *)(a1 + 344);
                  v9 = sub_80EAC7A(v30);
                  v10 = *(_DWORD *)(a1 + 344);
                  v11 = *(_DWORD *)(a1 + 344);
                  *(_DWORD *)(v8 + 4 * v9 + 836) = *(_DWORD *)(v10 + 4 * v9 + 836)
                                                 + *(_DWORD *)(v11 + 4 * sub_80EAC94(v30) + 324);
                  v12 = *(_DWORD *)(a1 + 344);
                  *(_DWORD *)(v12 + 4 * sub_80EAC94(v30) + 324) = 0;
                  v13 = *(_DWORD *)(a1 + 344);
                  result = (char *)sub_80EAC7A(v30);
                  if ( *(_DWORD *)(v13 + 4 * (_DWORD)result + 836) < 0 )
                  {
                    v14 = *(_DWORD *)(a1 + 344);
                    result = (char *)sub_80EAC7A(v30);
                    *(_DWORD *)(v14 + 4 * (_DWORD)result + 836) = 0;
                  }
                }
              }
            }
            else
            {
              for ( j = 1; ; *(_DWORD *)(v16 + 4 * sub_80EAC7A(j++) + 836) = 0 )
              {
                result = (char *)sub_80E9322();
                if ( j > (signed int)result )
                  break;
                v15 = *(_DWORD *)(a1 + 344);
                *(_DWORD *)(v15 + 4 * sub_80EAC94(j) + 324) = 0;
                v16 = *(_DWORD *)(a1 + 344);
              }
            }
            if ( v28 )
            {
LABEL_42:
              result = (char *)sub_80B550A(v33, "allammo", 7);
              if ( !result && v27 )
              {
                for ( k = 1; ; ++k )
                {
                  result = (char *)sub_80E9322();
                  if ( k > (signed int)result )
                    break;
                  v17 = *(_DWORD *)(a1 + 344);
                  v18 = sub_80EAC94(k);
                  *(_DWORD *)(v17 + 4 * v18 + 324) = *(_DWORD *)(*(_DWORD *)(a1 + 344) + 4 * v18 + 324) - v27;
                  v19 = *(_DWORD *)(a1 + 344);
                  if ( *(_DWORD *)(v19 + 4 * sub_80EAC94(k) + 324) < 0 )
                  {
                    v20 = *(_DWORD *)(a1 + 344);
                    v21 = sub_80EAC7A(k);
                    v22 = *(_DWORD *)(a1 + 344);
                    v23 = *(_DWORD *)(a1 + 344);
                    *(_DWORD *)(v20 + 4 * v21 + 836) = *(_DWORD *)(v22 + 4 * v21 + 836)
                                                     + *(_DWORD *)(v23 + 4 * sub_80EAC94(k) + 324);
                    v24 = *(_DWORD *)(a1 + 344);
                    *(_DWORD *)(v24 + 4 * sub_80EAC94(k) + 324) = 0;
                    v25 = *(_DWORD *)(a1 + 344);
                    if ( *(_DWORD *)(v25 + 4 * sub_80EAC7A(k) + 836) < 0 )
                    {
                      v26 = *(_DWORD *)(a1 + 344);
                      *(_DWORD *)(v26 + 4 * sub_80EAC7A(k) + 836) = 0;
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  return result;
}

//----- (080FC74E) --------------------------------------------------------
signed int __cdecl sub_80FC74E(int a1)
{
  signed int result; // eax
  char *v2; // eax
  const char *v3; // [esp+10h] [ebp-8h]

  result = sub_80FB996(a1);
  if ( result )
  {
    *(_DWORD *)(a1 + 372) ^= 1u;
    if ( *(_BYTE *)(a1 + 372) & 1 )
      v3 = "GAME_GODMODE_ON";
    else
      v3 = "GAME_GODMODE_OFF";
    v2 = va("%c \"%s\"", 101, v3);
    result = sub_808FE96(-1963413621 * ((a1 - (signed int)&unk_8665480) >> 4), 0, (int)v2);
  }
  return result;
}

//----- (080FC7E2) --------------------------------------------------------
signed int __cdecl sub_80FC7E2(int a1)
{
  signed int result; // eax
  char *v2; // eax
  const char *v3; // [esp+10h] [ebp-8h]

  result = sub_80FB996(a1);
  if ( result )
  {
    *(_DWORD *)(a1 + 372) ^= 2u;
    if ( *(_DWORD *)(a1 + 372) & 2 )
      v3 = "GAME_DEMI_GODMODE_ON";
    else
      v3 = "GAME_DEMI_GODMODE_OFF";
    v2 = va("%c \"%s\"", 101, v3);
    result = sub_808FE96(-1963413621 * ((a1 - (signed int)&unk_8665480) >> 4), 0, (int)v2);
  }
  return result;
}

//----- (080FC876) --------------------------------------------------------
signed int __cdecl sub_80FC876(int a1)
{
  signed int result; // eax
  char *v2; // eax

  result = sub_80FB996(a1);
  if ( result )
  {
    *(_DWORD *)(a1 + 372) ^= 4u;
    if ( *(_DWORD *)(a1 + 372) & 4 )
      v2 = va("%c \"%s\"", 101, "GAME_NOTARGETON");
    else
      v2 = va("%c \"%s\"", 101, "GAME_NOTARGETOFF");
    result = sub_808FE96(-1963413621 * ((a1 - (signed int)&unk_8665480) >> 4), 0, (int)v2);
  }
  return result;
}

//----- (080FC904) --------------------------------------------------------
signed int __cdecl sub_80FC904(int a1)
{
  signed int result; // eax
  char *v2; // eax
  const char *v3; // [esp+14h] [ebp-4h]

  result = sub_80FB996(a1);
  if ( result )
  {
    if ( *(_DWORD *)(*(_DWORD *)(a1 + 344) + 10156) )
      v3 = "GAME_NOCLIPOFF";
    else
      v3 = "GAME_NOCLIPON";
    *(_DWORD *)(*(_DWORD *)(a1 + 344) + 10156) = *(_DWORD *)(*(_DWORD *)(a1 + 344) + 10156) == 0;
    v2 = va("%c \"%s\"", 101, v3);
    result = sub_808FE96(-1963413621 * ((a1 - (signed int)&unk_8665480) >> 4), 0, (int)v2);
  }
  return result;
}

//----- (080FC9A8) --------------------------------------------------------
signed int __cdecl sub_80FC9A8(int a1)
{
  signed int result; // eax
  char *v2; // eax
  const char *v3; // [esp+14h] [ebp-4h]

  result = sub_80FB996(a1);
  if ( result )
  {
    if ( *(_DWORD *)(*(_DWORD *)(a1 + 344) + 10160) )
      v3 = "GAME_UFOOFF";
    else
      v3 = "GAME_UFOON";
    *(_DWORD *)(*(_DWORD *)(a1 + 344) + 10160) = *(_DWORD *)(*(_DWORD *)(a1 + 344) + 10160) == 0;
    v2 = va("%c \"%s\"", 101, v3);
    result = sub_808FE96(-1963413621 * ((a1 - (signed int)&unk_8665480) >> 4), 0, (int)v2);
  }
  return result;
}

//----- (080FCA4C) --------------------------------------------------------
int __cdecl sub_80FCA4C(int *a1)
{
  int result; // eax
  int v2; // edx

  result = a1[86];
  if ( !*(_DWORD *)(result + 9896) )
  {
    a1[93] &= 0xFFFFFFFC;
    v2 = a1[86];
    a1[101] = 0;
    *(_DWORD *)(v2 + 300) = 0;
    result = sub_80FF2CA((int)a1, a1, a1, 100000, 0xCu, 0, 0, 0, 0);
  }
  return result;
}

//----- (080FCAE6) --------------------------------------------------------
_DWORD *__cdecl sub_80FCAE6(char *a1)
{
  _DWORD *result; // eax
  long double v2; // fst7
  float s; // [esp+20h] [ebp-B8h]
  int v4; // [esp+50h] [ebp-88h]
  int v5; // [esp+60h] [ebp-78h]
  int v6; // [esp+70h] [ebp-68h]
  int v7; // [esp+80h] [ebp-58h]
  int v8; // [esp+90h] [ebp-48h]
  int v9; // [esp+A0h] [ebp-38h]
  float v10; // [esp+B0h] [ebp-28h]
  _DWORD *v11; // [esp+CCh] [ebp-Ch]

  v11 = (_DWORD *)*((_DWORD *)a1 + 86);
  v11[2475] = -1;
  v11[2538] = -1;
  result = (_DWORD *)(v11[3] & 0x400000);
  if ( result )
  {
    sub_80F61BE((int)a1, (float *)&v9);
    sub_80F63A0((int)a1, (int)&v8, 0, (float *)&v7);
    sub_80FEE3C(v11 + 58, &v10);
    v2 = v10 + 15.0;
    v10 = v2;
    sub_80FEE6C((int)&v9, -40.0, (int)&v8, (int)&v6);
    sub_80FEE6C((int)&v6, 10.0, (int)&v7, (int)&v6);
    sub_80FEE18(&v5, -1056964608, -1056964608, -1056964608);
    sub_80FEE18(&v4, 1090519040, 1090519040, 1090519040);
    sub_8108090(&s, (int)&v9, (int)&v5, (int)&v4, (int)&v6, 1023, 8454161);
    sub_80DEB7A((int)&v9, (int)&v6, s, (int)&v9);
    v11[51] = -1963413621 * ((a1 - (char *)&unk_8665480) >> 4);
    v11[40] &= 0xFFFFFCFF;
    v11[356] = 0;
    v11[357] = 1023;
    v11[3] &= 0xFFBFFFBF;
    v11[55] = 0;
    sub_811CF36(a1, &v9);
    sub_80FEE3C(&v9, v11 + 5);
    sub_80F5E80(v2, (int)a1, &v10);
    v11[374] = 0;
    v11[375] = 0;
    result = v11;
    v11[376] = 0;
  }
  return result;
}

//----- (080FCD40) --------------------------------------------------------
signed int __cdecl sub_80FCD40(int a1, int a2)
{
  char v4; // [esp+20h] [ebp-2728h]
  int v5; // [esp+24h] [ebp-2724h]
  char v6; // [esp+80h] [ebp-26C8h]
  int v7; // [esp+2738h] [ebp-10h]
  int v8; // [esp+273Ch] [ebp-Ch]

  if ( a2 != 1 && a2 != -1 )
    Com_Error(1, &byte_8151D60, a2);
  if ( *(_DWORD *)(*(_DWORD *)(a1 + 344) + 9896) != 2 )
    return 0;
  if ( *(_DWORD *)(*(_DWORD *)(a1 + 344) + 9900) >= 0 )
    return 0;
  v8 = *(_DWORD *)(*(_DWORD *)(a1 + 344) + 10152);
  if ( v8 < 0 )
    v8 = 0;
  v7 = v8;
  do
  {
    v8 += a2;
    if ( v8 >= dword_859B5E4 )
      v8 = 0;
    if ( v8 < 0 )
      v8 = dword_859B5E4 - 1;
    if ( sub_8097EDA(v8, (int *)(*(_DWORD *)(a1 + 344) + 9908), &v6, &v4) && sub_80F467C(*(_DWORD *)(a1 + 344), v5) )
    {
      *(_DWORD *)(*(_DWORD *)(a1 + 344) + 10152) = v8;
      *(_DWORD *)(*(_DWORD *)(a1 + 344) + 9896) = 2;
      return 1;
    }
  }
  while ( v8 != v7 );
  return 0;
}
// 859B5E4: using guessed type int dword_859B5E4;

//----- (080FCEA8) --------------------------------------------------------
_BOOL4 __cdecl sub_80FCEA8(int a1)
{
  return *(_DWORD *)(*(_DWORD *)(a1 + 344) + 9896) == 0;
}

//----- (080FCEC4) --------------------------------------------------------
void __cdecl sub_80FCEC4(int a1, int a2, int a3, int a4, int a5, int a6)
{
  char *v6; // eax

  if ( a2
    && *(_BYTE *)(a2 + 252)
    && *(_DWORD *)(a2 + 344)
    && *(_DWORD *)(*(_DWORD *)(a2 + 344) + 9924) == 2
    && (a3 != 1 || sub_8119C40(a1, a2))
    && (*(_BYTE *)(dword_8793DFC + 8) || sub_80FCEA8(a1) || !sub_80FCEA8(a2)) )
  {
    if ( a3 == 1 )
      v6 = va(aC_4, 105, a5, 94, a4, a6);
    else
      v6 = va(aC_4, 104, a5, 94, a4, a6);
    sub_808FE96(-1963413621 * ((a2 - (signed int)&unk_8665480) >> 4), 0, (int)v6);
  }
}
// 8793DFC: using guessed type int dword_8793DFC;

//----- (080FCFC8) --------------------------------------------------------
void __cdecl sub_80FCFC8(int a1, int a2, int a3, char *src)
{
  int v4; // eax
  int v5; // eax
  int v6; // [esp+24h] [ebp-1C4h]
  void *v7; // [esp+28h] [ebp-1C0h]
  const char *v8; // [esp+2Ch] [ebp-1BCh]
  char v9; // [esp+30h] [ebp-1B8h]
  char s; // [esp+D0h] [ebp-118h]
  char v11; // [esp+110h] [ebp-D8h]
  char dest; // [esp+190h] [ebp-58h]
  int v13; // [esp+1D4h] [ebp-14h]
  int v14; // [esp+1D8h] [ebp-10h]
  int i; // [esp+1DCh] [ebp-Ch]

  if ( a3 == 1 && *(_DWORD *)(*(_DWORD *)(a1 + 344) + 10060) != 1 && *(_DWORD *)(*(_DWORD *)(a1 + 344) + 10060) != 2 )
    a3 = 0;
  I_strncpyz(&dest, (char *)(*(_DWORD *)(a1 + 344) + 10116), 64);
  sub_80B587C(&dest);
  v6 = *(_DWORD *)(*(_DWORD *)(a1 + 344) + 10060);
  if ( v6 == 1 )
  {
    v7 = &unk_8151D91;
  }
  else if ( v6 == 2 )
  {
    v7 = &unk_8151D8E;
  }
  else
  {
    v7 = &unk_8151D94;
  }
  if ( *(_DWORD *)(*(_DWORD *)(a1 + 344) + 10060) == 3 )
  {
    Com_sprintf(&s, 0x40u, &byte_8151D95);
  }
  else if ( *(_DWORD *)(*(_DWORD *)(a1 + 344) + 9896) )
  {
    Com_sprintf(&s, 0x40u, &byte_8151DA9, v7);
  }
  else
  {
    Com_sprintf(&s, 0x40u, &byte_8151DBA, v7);
  }
  if ( a3 == 1 )
  {
    if ( *(_DWORD *)(*(_DWORD *)(a1 + 344) + 10060) == 1 )
      v8 = "GAME_AXIS";
    else
      v8 = "GAME_ALLIES";
    v5 = sub_8090AFE(*(_DWORD *)a1);
    sub_8107502("sayteam;%d;%d;%s;%s\n", v5, *(_DWORD *)a1, &dest, src);
    Com_sprintf(&v11, 0x80u, aS_33, &s, v8, &dest, "^7");
    v13 = 53;
  }
  else if ( a3 > 1 && a3 == 2 )
  {
    Com_sprintf(&v11, 0x80u, "%s[%s]%s: ", &s, &dest, "^7");
    v13 = 51;
  }
  else
  {
    v4 = sub_8090AFE(*(_DWORD *)a1);
    sub_8107502("say;%d;%d;%s;%s\n", v4, *(_DWORD *)a1, &dest, src);
    Com_sprintf(&v11, 0x80u, "%s%s%s: ", &s, &dest, "^7");
    v13 = 55;
  }
  I_strncpyz(&v9, src, 150);
  if ( a2 )
  {
    sub_80FCEC4(a1, a2, a3, v13, (int)&v11, (int)&v9);
  }
  else
  {
    if ( *(_DWORD *)(dword_8793D8C + 8) )
      Com_Printf("%s%s\n", &v11, &v9);
    for ( i = 0; i < dword_859B5E4; ++i )
    {
      v14 = (int)&unk_8665480 + 560 * i;
      sub_80FCEC4(a1, v14, a3, v13, (int)&v11, (int)&v9);
    }
  }
}
// 859B5E4: using guessed type int dword_859B5E4;
// 8793D8C: using guessed type int dword_8793D8C;

//----- (080FD38E) --------------------------------------------------------
void __cdecl sub_80FD38E(int a1, int a2, int a3)
{
  char *src; // [esp+14h] [ebp-4h]

  if ( sub_805FFE6() > 1 || a3 )
  {
    if ( a3 )
      src = (char *)sub_80FBA44(0);
    else
      src = (char *)sub_80FBA44(1);
    sub_80FCFC8(a1, 0, a2, src);
  }
}

//----- (080FD3F0) --------------------------------------------------------
void __cdecl sub_80FD3F0(int *a1)
{
  int v1; // ebx
  int v2; // eax
  char v3; // [esp+20h] [ebp-498h]
  char dest; // [esp+60h] [ebp-458h]
  char nptr; // [esp+A0h] [ebp-418h]
  char *src; // [esp+4A4h] [ebp-14h]
  int v7; // [esp+4A8h] [ebp-10h]
  int v8; // [esp+4ACh] [ebp-Ch]

  if ( sub_805FFE6() > 1 )
  {
    sub_8060074(1, &nptr, 1024);
    v8 = atoi(&nptr);
    if ( v8 >= 0 && v8 < dword_859B5E4 )
    {
      v7 = (int)&unk_8665480 + 560 * v8;
      if ( v7 )
      {
        if ( *(_BYTE *)(v7 + 252) )
        {
          if ( *(_DWORD *)(v7 + 344) )
          {
            src = (char *)sub_80FBA44(2);
            I_strncpyz(&dest, (char *)(a1[86] + 10116), 64);
            sub_80B587C(&dest);
            I_strncpyz(&v3, (char *)(*(_DWORD *)(v7 + 344) + 10116), 64);
            sub_80B587C(&v3);
            v1 = sub_8090AFE(*(_DWORD *)v7);
            v2 = sub_8090AFE(*a1);
            sub_8107502("tell;%d;%d;%s;%d;%d;%s;%s\n", v2, *a1, &dest, v1, *(_DWORD *)v7, &v3, src);
            sub_80FCFC8((int)a1, v7, 2, src);
            sub_80FCFC8((int)a1, (int)a1, 2, src);
          }
        }
      }
    }
  }
}
// 859B5E4: using guessed type int dword_859B5E4;

//----- (080FD5B6) --------------------------------------------------------
void __cdecl sub_80FD5B6(int a1)
{
  char nptr; // [esp+10h] [ebp-418h]
  int v2; // [esp+418h] [ebp-10h]
  int v3; // [esp+41Ch] [ebp-Ch]

  sub_8060074(1, &nptr, 1024);
  v3 = atoi(&nptr);
  sub_8060074(2, &nptr, 1024);
  v2 = atoi(&nptr);
  if ( v3 >= 0 && v3 <= 63 && v2 >= 0 && (unsigned int)v2 <= 6 )
  {
    sub_80FCFC8(a1, 560 * v3 + 140924032, 2, (&off_8167718)[v2]);
    sub_80FCFC8(a1, a1, 2, (&off_8167718)[v2]);
  }
}

//----- (080FD692) --------------------------------------------------------
int __cdecl sub_80FD692(int a1)
{
  char *v1; // eax
  char *v2; // eax

  v1 = sub_80F1B86((float *)(a1 + 312));
  v2 = va(aC_5, 101, v1);
  return sub_808FE96(-1963413621 * ((a1 - (signed int)&unk_8665480) >> 4), 0, (int)v2);
}

//----- (080FD6E8) --------------------------------------------------------
signed int __usercall sub_80FD6E8@<eax>(long double a1@<st0>, int a2)
{
  char *v2; // eax
  signed int result; // eax
  char *v4; // eax
  char *v5; // eax
  char *v6; // eax
  char *v7; // eax
  char *v8; // eax
  char *v9; // eax
  char *v10; // eax
  char *v11; // eax
  char *v12; // eax
  char *v13; // eax
  int v14; // eax
  int v15; // eax
  char *v16; // eax
  int v17; // eax
  char *v18; // eax
  char *v19; // eax
  char *v20; // eax
  char *v21; // eax
  char *v22; // eax
  char *v23; // eax
  int v24; // [esp+24h] [ebp-354h]
  int j; // [esp+28h] [ebp-350h]
  int i; // [esp+2Ch] [ebp-34Ch]
  char dest; // [esp+30h] [ebp-348h]
  char v28; // [esp+70h] [ebp-308h]
  char nptr; // [esp+170h] [ebp-208h]
  char s; // [esp+270h] [ebp-108h]

  if ( !*(_BYTE *)(dword_8793DF4 + 8) )
  {
    v2 = va("%c \"GAME_VOTINGNOTENABLED\"", 101);
    return sub_808FE96(-1963413621 * ((a2 - (signed int)&unk_8665480) >> 4), 0, (int)v2);
  }
  if ( *(_BYTE *)(dword_8793E50 + 8) )
  {
    if ( *(_DWORD *)dword_859BF1C )
    {
      v4 = va("%c \"GAME_VOTEALREADYINPROGRESS\"", 101);
      return sub_808FE96(-1963413621 * ((a2 - (signed int)&unk_8665480) >> 4), 0, (int)v4);
    }
    if ( *(_DWORD *)(*(_DWORD *)(a2 + 344) + 10036) > 2 )
    {
      v5 = va("%c \"GAME_MAXVOTESCALLED\"", 101);
      return sub_808FE96(-1963413621 * ((a2 - (signed int)&unk_8665480) >> 4), 0, (int)v5);
    }
    if ( *(_DWORD *)(*(_DWORD *)(a2 + 344) + 10060) == 3 )
    {
      v6 = va("%c \"GAME_NOSPECTATORCALLVOTE\"", 101);
      return sub_808FE96(-1963413621 * ((a2 - (signed int)&unk_8665480) >> 4), 0, (int)v6);
    }
  }
  sub_8060074(1, &s, 256);
  sub_8060074(2, &nptr, 256);
  sub_8060074(3, &v28, 256);
  if ( strchr(&s, 59) || strchr(&nptr, 59) || strchr(&v28, 59) )
  {
    v7 = va("%c \"GAME_INVALIDVOTESTRING\"", 101);
    return sub_808FE96(-1963413621 * ((a2 - (signed int)&unk_8665480) >> 4), 0, (int)v7);
  }
  if ( !*(_BYTE *)(dword_8793E50 + 8) )
    return sub_81160D4(a2, &s, &nptr, &v28);
  if ( I_stricmp(&s, "map_restart")
    && I_stricmp(&s, "map_rotate")
    && I_stricmp(&s, "typemap")
    && I_stricmp(&s, "map")
    && I_stricmp(&s, "g_gametype")
    && I_stricmp(&s, "kick")
    && I_stricmp(&s, "clientkick")
    && I_stricmp(&s, "tempBanUser")
    && I_stricmp(&s, "tempBanClient") )
  {
    v8 = va("%c \"GAME_INVALIDVOTESTRING\"", 101);
    sub_808FE96(-1963413621 * ((a2 - (signed int)&unk_8665480) >> 4), 0, (int)v8);
    v9 = va(aCGameVotecomma, 101);
    return sub_808FE96(-1963413621 * ((a2 - (signed int)&unk_8665480) >> 4), 0, (int)v9);
  }
  if ( dword_859BF20 )
  {
    dword_859BF20 = 0;
    v10 = va("%s\n", byte_859B71C);
    Cbuf_ExecuteText(a1, 2, v10);
  }
  if ( !I_stricmp(&s, "typemap") )
  {
    if ( !sub_8115E3C(&nptr) )
    {
      v11 = va("%c \"GAME_INVALIDGAMETYPE\"", 101);
      return sub_808FE96(-1963413621 * ((a2 - (signed int)&unk_8665480) >> 4), 0, (int)v11);
    }
    if ( !I_stricmp(&nptr, *(char **)(dword_8793D80 + 8)) )
      nptr = 0;
    sub_8060074(3, &v28, 256);
    if ( !sub_80909EE(&v28) )
    {
      v12 = va(aC_6, 101);
      return sub_808FE96(-1963413621 * ((a2 - (signed int)&unk_8665480) >> 4), 0, (int)v12);
    }
    j = (int)Dvar_RegisterString(a1, "mapname", (int)&unk_8151D94, 4164);
    if ( !I_stricmp(&v28, *(char **)(j + 8)) )
      v28 = 0;
    if ( !nptr && !v28 )
    {
      v13 = va("%c \"GAME_TYPEMAP_NOCHANGE\"", 101);
      return sub_808FE96(-1963413621 * ((a2 - (signed int)&unk_8665480) >> 4), 0, (int)v13);
    }
    if ( v28 )
    {
      if ( nptr )
        Com_sprintf(byte_859B71C, 0x400u, "g_gametype %s; map %s", &nptr, &v28);
      else
        Com_sprintf(byte_859B71C, 0x400u, "map %s", &v28);
      if ( nptr )
      {
        v14 = sub_8115DD2(&nptr);
        Com_sprintf(byte_859BB1C, 0x400u, aGameVoteGamety, v14, &v28);
      }
      else
      {
        Com_sprintf(byte_859BB1C, 0x400u, aGameVoteMap, &v28);
      }
    }
    else
    {
      Com_sprintf(byte_859B71C, 0x400u, "g_gametype %s; map_restart", &nptr);
      v15 = sub_8115DD2(&nptr);
      Com_sprintf(byte_859BB1C, 0x400u, aGameVoteGamety_0, v15);
    }
    goto LABEL_85;
  }
  if ( !I_stricmp(&s, "g_gametype") )
  {
    if ( !sub_8115E3C(&nptr) )
    {
      v16 = va("%c \"GAME_INVALIDGAMETYPE\"", 101);
      return sub_808FE96(-1963413621 * ((a2 - (signed int)&unk_8665480) >> 4), 0, (int)v16);
    }
    Com_sprintf(byte_859B71C, 0x400u, "%s %s; map_restart", &s, &nptr);
    v17 = sub_8115DD2(&nptr);
    Com_sprintf(byte_859BB1C, 0x400u, aGameVoteGamety_0, v17);
    goto LABEL_85;
  }
  if ( !I_stricmp(&s, "map_restart") )
  {
    Com_sprintf(byte_859B71C, 0x400u, "fast_restart");
    Com_sprintf(byte_859BB1C, 0x400u, "GAME_VOTE_MAPRESTART");
    goto LABEL_85;
  }
  if ( !I_stricmp(&s, "map_rotate") )
  {
    Com_sprintf(byte_859B71C, 0x400u, "%s", &s);
    Com_sprintf(byte_859BB1C, 0x400u, "GAME_VOTE_NEXTMAP");
LABEL_85:
    v20 = va(aCGameCalledavo, 101, *(_DWORD *)(a2 + 344) + 10116);
    sub_808FE96(-1, 0, (int)v20);
    *(_DWORD *)dword_859BF1C = dword_859B5EC + 30000;
    *(_DWORD *)dword_859BF24 = 1;
    *(_DWORD *)dword_859BF28 = 0;
    for ( i = 0; i < dword_859B5E4; ++i )
      *(_DWORD *)(dword_859B400 + 10404 * i + 160) &= 0xFFEFFFFF;
    *(_DWORD *)(*(_DWORD *)(a2 + 344) + 160) |= 0x100000u;
    v21 = va("%i", *(_DWORD *)dword_859BF1C);
    sub_8090E6C(15, v21);
    sub_8090E6C(16, byte_859BB1C);
    v22 = va("%i", *(_DWORD *)dword_859BF24);
    sub_8090E6C(17, v22);
    v23 = va("%i", *(_DWORD *)dword_859BF28);
    return sub_8090E6C(18, v23);
  }
  if ( !I_stricmp(&s, "map") )
  {
    if ( !sub_80909EE(&nptr) )
    {
      v18 = va(aC_6, 101);
      return sub_808FE96(-1963413621 * ((a2 - (signed int)&unk_8665480) >> 4), 0, (int)v18);
    }
    Com_sprintf(byte_859B71C, 0x400u, "%s %s", &s, &nptr);
    Com_sprintf(byte_859BB1C, 0x400u, aGameVoteMap, &nptr);
    goto LABEL_85;
  }
  if ( !I_stricmp(&s, "kick")
    || !I_stricmp(&s, "clientkick")
    || !I_stricmp(&s, "tempBanUser")
    || (result = I_stricmp(&s, "tempBanClient")) == 0 )
  {
    v24 = 64;
    if ( I_stricmp(&s, "kick") && I_stricmp(&s, "tempBanUser") )
    {
      v24 = atoi(&nptr);
      if ( (v24 || !I_stricmp(&nptr, "0"))
        && v24 >= 0
        && v24 <= 63
        && *(_DWORD *)(dword_859B400 + 10404 * v24 + 9924) == 2 )
      {
        I_strncpyz(&dest, (char *)(dword_859B400 + 10404 * v24 + 10116), 64);
        sub_80B587C(&dest);
      }
      else
      {
        v24 = 64;
      }
    }
    else
    {
      for ( j = 0; j <= 63; ++j )
      {
        if ( *(_DWORD *)(dword_859B400 + 10404 * j + 9924) == 2 )
        {
          I_strncpyz(&dest, (char *)(dword_859B400 + 10404 * j + 10116), 64);
          sub_80B587C(&dest);
          if ( !I_stricmp(&dest, &nptr) )
            v24 = j;
        }
      }
    }
    if ( v24 == 64 )
    {
      v19 = va("%c \"GAME_CLIENTNOTONSERVER\"", 101);
      return sub_808FE96(-1963413621 * ((a2 - (signed int)&unk_8665480) >> 4), 0, (int)v19);
    }
    if ( s != 116 && s != 84 )
      Com_sprintf(byte_859B71C, 0x400u, "%s \"%d\"", "clientkick", v24);
    else
      Com_sprintf(byte_859B71C, 0x400u, "%s \"%d\"", "tempBanClient", v24);
    Com_sprintf(byte_859BB1C, 0x400u, aGameVoteKick, v24, dword_859B400 + 10404 * v24 + 10116);
    goto LABEL_85;
  }
  return result;
}
// 859B400: using guessed type int dword_859B400;
// 859B5E4: using guessed type int dword_859B5E4;
// 859BF20: using guessed type int dword_859BF20;
// 8793D80: using guessed type int dword_8793D80;
// 8793DF4: using guessed type int dword_8793DF4;
// 8793E50: using guessed type int dword_8793E50;

//----- (080FE496) --------------------------------------------------------
int __cdecl sub_80FE496(int a1)
{
  char *v1; // eax
  int result; // eax
  char *v3; // eax
  char *v4; // eax
  char *v5; // eax
  char *v6; // eax
  char *v7; // eax
  char dest; // [esp+10h] [ebp-48h]
  char v9; // [esp+11h] [ebp-47h]

  if ( *(_BYTE *)(dword_8793E50 + 8) )
  {
    if ( !*(_DWORD *)dword_859BF1C )
    {
      v1 = va("%c \"GAME_NOVOTEINPROGRESS\"", 101);
      return sub_808FE96(-1963413621 * ((a1 - (signed int)&unk_8665480) >> 4), 0, (int)v1);
    }
    if ( *(_DWORD *)(*(_DWORD *)(a1 + 344) + 160) & 0x100000 )
    {
      v3 = va("%c \"GAME_VOTEALREADYCAST\"", 101);
      return sub_808FE96(-1963413621 * ((a1 - (signed int)&unk_8665480) >> 4), 0, (int)v3);
    }
    if ( *(_DWORD *)(*(_DWORD *)(a1 + 344) + 10060) == 3 )
    {
      v4 = va("%c \"GAME_NOSPECTATORVOTE\"", 101);
      return sub_808FE96(-1963413621 * ((a1 - (signed int)&unk_8665480) >> 4), 0, (int)v4);
    }
    v5 = va("%c \"GAME_VOTECAST\"", 101);
    sub_808FE96(-1963413621 * ((a1 - (signed int)&unk_8665480) >> 4), 0, (int)v5);
    *(_DWORD *)(*(_DWORD *)(a1 + 344) + 160) |= 0x100000u;
  }
  sub_8060074(1, &dest, 64);
  if ( dest != 121 && v9 != 89 && v9 != 49 )
  {
    if ( *(_BYTE *)(dword_8793E50 + 8) )
    {
      v7 = va("%i", ++*(_DWORD *)dword_859BF28);
      result = sub_8090E6C(18, v7);
    }
    else
    {
      result = sub_811611C(a1, "no");
    }
  }
  else if ( *(_BYTE *)(dword_8793E50 + 8) )
  {
    v6 = va("%i", ++*(_DWORD *)dword_859BF24);
    result = sub_8090E6C(17, v6);
  }
  else
  {
    result = sub_811611C(a1, "yes");
  }
  return result;
}
// 8793E50: using guessed type int dword_8793E50;

//----- (080FE6BE) --------------------------------------------------------
int __cdecl sub_80FE6BE(int a1)
{
  char *v1; // eax
  int result; // eax
  char *v3; // eax
  signed int i; // [esp+1Ch] [ebp-42Ch]
  char nptr; // [esp+20h] [ebp-428h]
  char v6; // [esp+420h] [ebp-28h]
  float v7; // [esp+424h] [ebp-24h]
  float v8[2]; // [esp+430h] [ebp-18h]
  float v9; // [esp+438h] [ebp-10h]

  if ( *(_BYTE *)(dword_8793D98 + 8) )
  {
    if ( sub_805FFE6() == 5 )
    {
      sub_80FEDEE(&v6);
      for ( i = 0; i <= 2; ++i )
      {
        sub_8060074(i + 1, &nptr, 1024);
        v8[i] = atof(&nptr);
      }
      sub_8060074(4, &nptr, 1024);
      v7 = atof(&nptr);
      v9 = v9 - *(float *)(*(_DWORD *)(a1 + 344) + 248);
      result = sub_8108270(a1, v8, &v6);
    }
    else
    {
      v3 = va(aCGameUsage, 101);
      result = sub_808FE96(-1963413621 * ((a1 - (signed int)&unk_8665480) >> 4), 0, (int)v3);
    }
  }
  else
  {
    v1 = va("%c \"GAME_CHEATSNOTENABLED\"", 101);
    result = sub_808FE96(-1963413621 * ((a1 - (signed int)&unk_8665480) >> 4), 0, (int)v1);
  }
  return result;
}
// 8793D98: using guessed type int dword_8793D98;
// 80FE6BE: using guessed type float var_18[2];

//----- (080FE822) --------------------------------------------------------
void sub_80FE822()
{
  if ( *(_BYTE *)(dword_8793D98 + 8) )
    Com_Printf("entity count = %i\n", *(_DWORD *)dword_859B40C);
}
// 8793D98: using guessed type int dword_8793D98;

//----- (080FE84C) --------------------------------------------------------
int __cdecl sub_80FE84C(int *a1)
{
  int v1; // ebx
  int result; // eax
  char dest; // [esp+10h] [ebp-C18h]
  char s; // [esp+410h] [ebp-818h]
  char nptr; // [esp+810h] [ebp-418h]
  int v6; // [esp+C1Ch] [ebp-Ch]

  v6 = -1;
  if ( sub_805FFE6() == 4 )
  {
    sub_8060074(1, &nptr, 1024);
    v1 = atoi(&nptr);
    result = Dvar_GetInt("sv_serverId");
    if ( v1 != result )
      return result;
    sub_8060074(2, &s, 1024);
    v6 = atoi(&s);
    if ( v6 >= 0 && v6 <= 31 )
      sub_809107E(v6 + 1246, &s, 1024);
    sub_8060074(3, &dest, 1024);
  }
  else
  {
    s = 0;
    strcpy(&dest, "bad");
  }
  Scr_AddString(&dest);
  Scr_AddString(&s);
  return Scr_Notify(a1, word_87A2310, 2);
}
// 87A2310: using guessed type __int16 word_87A2310;

//----- (080FE98A) --------------------------------------------------------
int sub_80FE98A()
{
  return sub_811C444();
}

//----- (080FE998) --------------------------------------------------------
void __usercall sub_80FE998(long double a1@<st0>, int a2)
{
  char *v2; // eax
  char dest; // [esp+10h] [ebp-418h]
  int *v4; // [esp+41Ch] [ebp-Ch]

  v4 = (int *)((char *)&unk_8665480 + 560 * a2);
  if ( v4[86] )
  {
    sub_8060074(0, &dest, 1024);
    if ( I_stricmp(&dest, "say") )
    {
      if ( I_stricmp(&dest, "say_team") )
      {
        if ( I_stricmp(&dest, "tell") )
        {
          if ( I_stricmp(&dest, "score") )
          {
            if ( *(_DWORD *)(v4[86] + 4) != 5 )
            {
              if ( I_stricmp(&dest, "mr") )
              {
                if ( I_stricmp(&dest, "give") )
                {
                  if ( I_stricmp(&dest, "take") )
                  {
                    if ( I_stricmp(&dest, "god") )
                    {
                      if ( I_stricmp(&dest, "demigod") )
                      {
                        if ( I_stricmp(&dest, "notarget") )
                        {
                          if ( I_stricmp(&dest, "noclip") )
                          {
                            if ( I_stricmp(&dest, "ufo") )
                            {
                              if ( I_stricmp(&dest, "kill") )
                              {
                                if ( I_stricmp(&dest, "follownext") )
                                {
                                  if ( I_stricmp(&dest, "followprev") )
                                  {
                                    if ( I_stricmp(&dest, "where") )
                                    {
                                      if ( I_stricmp(&dest, "callvote") )
                                      {
                                        if ( I_stricmp(&dest, "vote") )
                                        {
                                          if ( I_stricmp(&dest, "gc") )
                                          {
                                            if ( I_stricmp(&dest, "setviewpos") )
                                            {
                                              if ( I_stricmp(&dest, "entitycount") )
                                              {
                                                if ( I_stricmp(&dest, "printentities") )
                                                {
                                                  v2 = va(aCGameUnknowncl, 101, &dest);
                                                  sub_808FE96(a2, 0, (int)v2);
                                                }
                                                else
                                                {
                                                  sub_80FE98A();
                                                }
                                              }
                                              else
                                              {
                                                sub_80FE822();
                                              }
                                            }
                                            else
                                            {
                                              sub_80FE6BE((int)v4);
                                            }
                                          }
                                          else
                                          {
                                            sub_80FD5B6((int)v4);
                                          }
                                        }
                                        else
                                        {
                                          sub_80FE496((int)v4);
                                        }
                                      }
                                      else
                                      {
                                        sub_80FD6E8(a1, (int)v4);
                                      }
                                    }
                                    else
                                    {
                                      sub_80FD692((int)v4);
                                    }
                                  }
                                  else
                                  {
                                    sub_80FCD40((int)v4, -1);
                                  }
                                }
                                else
                                {
                                  sub_80FCD40((int)v4, 1);
                                }
                              }
                              else
                              {
                                sub_80FCA4C(v4);
                              }
                            }
                            else
                            {
                              sub_80FC9A8((int)v4);
                            }
                          }
                          else
                          {
                            sub_80FC904((int)v4);
                          }
                        }
                        else
                        {
                          sub_80FC876((int)v4);
                        }
                      }
                      else
                      {
                        sub_80FC7E2((int)v4);
                      }
                    }
                    else
                    {
                      sub_80FC74E((int)v4);
                    }
                  }
                  else
                  {
                    sub_80FC25E((int)v4);
                  }
                }
                else
                {
                  sub_80FBE1C(a1, v4);
                }
              }
              else
              {
                sub_80FE84C(v4);
              }
            }
          }
          else
          {
            sub_80FB982((int)v4);
          }
        }
        else
        {
          sub_80FD3F0(v4);
        }
      }
      else
      {
        sub_80FD38E((int)v4, 1, 0);
      }
    }
    else
    {
      sub_80FD38E((int)v4, 0, 0);
    }
  }
}

//----- (080FEDEE) --------------------------------------------------------
int __cdecl sub_80FEDEE(_DWORD *a1)
{
  int result; // eax

  *a1 = 0;
  a1[1] = 0;
  result = 0;
  a1[2] = 0;
  return result;
}

//----- (080FEE18) --------------------------------------------------------
int __cdecl sub_80FEE18(_DWORD *a1, int a2, int a3, int a4)
{
  int result; // eax

  *a1 = a2;
  a1[1] = a3;
  result = a4;
  a1[2] = a4;
  return result;
}

//----- (080FEE3C) --------------------------------------------------------
int __cdecl sub_80FEE3C(_DWORD *a1, _DWORD *a2)
{
  int result; // eax

  *a2 = *a1;
  a2[1] = a1[1];
  result = a1[2];
  a2[2] = result;
  return result;
}

//----- (080FEE6C) --------------------------------------------------------
int __cdecl sub_80FEE6C(int a1, float a2, int a3, int a4)
{
  int result; // eax

  *(float *)a4 = a2 * *(float *)a3 + *(float *)a1;
  *(float *)(a4 + 4) = a2 * *(float *)(a3 + 4) + *(float *)(a1 + 4);
  result = a3 + 8;
  *(float *)(a4 + 8) = a2 * *(float *)(a3 + 8) + *(float *)(a1 + 8);
  return result;
}

//----- (080FEEC0) --------------------------------------------------------
char *__cdecl sub_80FEEC0(char *dest, char *src)
{
  return strcpy(dest, src);
}

//----- (080FEEDA) --------------------------------------------------------
_BOOL4 sub_80FEEDA()
{
  int v0; // ebx
  _BOOL4 result; // eax
  int v2; // [esp+28h] [ebp-2110h]
  int v3; // [esp+2Ch] [ebp-210Ch]
  char s1[8192]; // [esp+30h] [ebp-2108h]
  int v5; // [esp+2030h] [ebp-108h]
  size_t n; // [esp+2120h] [ebp-18h]
  char *s; // [esp+2124h] [ebp-14h]
  char *src; // [esp+2128h] [ebp-10h]
  int i; // [esp+212Ch] [ebp-Ch]
  char v10[8]; // [esp+2130h] [ebp-8h]

  src = "info/mp_lochit_dmgtable";
  s = "LOCDMGTABLE";
  n = strlen("LOCDMGTABLE");
  for ( i = 0; i <= 18; ++i )
  {
    dword_8577F60[i] = 1.0;
    *(_DWORD *)&v10[12 * i - 256] = (&off_8167740)[i];
    *(_DWORD *)&v10[12 * i - 252] = 4 * i;
    *(_DWORD *)&v10[12 * i - 248] = 6;
    v0 = i;
    word_8577FC0[v0] = sub_8079808((&off_8167740)[i]);
  }
  dword_8577FA8 = 0;
  v3 = FS_FOpenFileByMode(src, (int)&v2, 0);
  if ( v3 <= 0 )
    Com_Error(1, &byte_8152520, src);
  FS_Read((int)s1, n, v2);
  s1[n] = 0;
  if ( strncmp(s1, s, n) )
    Com_Error(1, &byte_8152560, src);
  if ( (signed int)(v3 - n) > 0x1FFF )
    Com_Error(1, &byte_81525A0, src);
  FS_Read((int)s1, v3 - n, v2);
  s1[v3 - n] = 0;
  FS_FCloseFile(v2);
  if ( !sub_80B5FA4(s1) )
    Com_Error(1, &byte_81525E0, src);
  result = sub_80B645E((int)dword_8577F60, (int)&v5, 19, s1, 0, 0, (int)sub_80FEEC0);
  if ( !result )
    Com_Error(1, &byte_8152620, src);
  return result;
}
// 8577FA8: using guessed type int dword_8577FA8;
// 8577FC0: using guessed type __int16 word_8577FC0[];
// 80FEEDA: using guessed type char var_8[8];
// 80FEEDA: using guessed type char s1[8192];

//----- (080FF17A) --------------------------------------------------------
__int16 __cdecl sub_80FF17A(int a1, int a2, int a3)
{
  __int16 result; // ax
  int v4; // ebx
  float v5; // ST24_4
  __int16 v6; // [esp+1Eh] [ebp-2Ah]
  char v7; // [esp+30h] [ebp-18h]

  if ( a3 && a3 != a1 )
  {
    sub_81004B2((float *)(a3 + 312), (float *)(a1 + 312), (float *)&v7);
  }
  else
  {
    if ( !a2 || a2 == a1 )
    {
      result = v6 | 0xC00;
      *(_DWORD *)(*(_DWORD *)(a1 + 344) + 304) = (signed int)*(float *)(a1 + 328);
      return result;
    }
    sub_81004B2((float *)(a2 + 312), (float *)(a1 + 312), (float *)&v7);
  }
  v4 = *(_DWORD *)(a1 + 344);
  *(_DWORD *)(v4 + 304) = (signed int)sub_80A29F6((float *)&v7);
  v5 = sub_80A29F6((float *)&v7);
  return 0;
}

//----- (080FF26A) --------------------------------------------------------
signed int __cdecl sub_80FF26A(char *a1)
{
  signed int i; // [esp+14h] [ebp-4h]

  for ( i = 0; i <= 14; ++i )
  {
    if ( !I_stricmp(a1, (&off_81677C0)[i]) )
      return i;
  }
  Com_Printf("Unknown means of death string '%s'\n", a1);
  return 0;
}

//----- (080FF2CA) --------------------------------------------------------
int __cdecl sub_80FF2CA(int a1, int *a2, int *a3, int a4, unsigned int a5, int a6, _DWORD *a7, int a8, int a9)
{
  int result; // eax
  signed int v10; // [esp+34h] [ebp-44h]
  char *v11; // [esp+3Ch] [ebp-3Ch]
  int v12; // [esp+3Ch] [ebp-3Ch]
  char v13; // [esp+40h] [ebp-38h]
  float v14; // [esp+48h] [ebp-30h]
  int v15; // [esp+50h] [ebp-28h]
  float v16; // [esp+54h] [ebp-24h]
  float v17; // [esp+58h] [ebp-20h]
  int v18; // [esp+68h] [ebp-10h]
  int i; // [esp+6Ch] [ebp-Ch]

  result = sub_806289C(*(_DWORD *)(*(_DWORD *)(a1 + 344) + 204));
  if ( result )
  {
    if ( !*(_DWORD *)(*(_DWORD *)(a1 + 344) + 4) || (result = *(_DWORD *)(a1 + 344), *(_DWORD *)(result + 4) == 1) )
    {
      result = *(_DWORD *)(*(_DWORD *)(a1 + 344) + 12) & 0x400000;
      if ( !result )
      {
        dword_855A4E0 = &unk_859EA40;
        if ( a3[1] == 9 && a3[84] != 1023 )
          a3 = (int *)((char *)&unk_8665480 + 560 * a3[84]);
        Scr_AddEntity(a3);
        Scr_Notify((int *)a1, word_87A22AA, 1);
        if ( a6 )
        {
          if ( a3[86] )
          {
            if ( *(_DWORD *)(a3[86] + 160) & 0x300 )
            {
              v11 = (char *)&unk_8665480 + 560 * a3[29];
              if ( *((_DWORD *)v11 + 1) == 9 )
                a6 = *((_DWORD *)v11 + 50);
            }
          }
        }
        if ( *(_DWORD *)(*(_DWORD *)(a1 + 344) + 60) )
        {
          *(float *)&v15 = sub_80A142E();
          v16 = sub_80A142E();
          v17 = sub_80A1410();
          sub_81004F6((int)&v15, 160.0, (int)&v15);
          sub_810043E((_DWORD *)(a1 + 312), &v13);
          v14 = v14 + 40.0;
          sub_810C1F6(
            (_DWORD *)a1,
            &v13,
            (float *)&v15,
            *(_DWORD *)(*(_DWORD *)(a1 + 344) + 208),
            *(_DWORD *)(*(_DWORD *)(a1 + 344) + 60));
        }
        if ( *(_DWORD *)(*(_DWORD *)(a1 + 344) + 4) == 1 )
          v10 = 7;
        else
          v10 = 6;
        *(_DWORD *)(*(_DWORD *)(a1 + 344) + 4) = v10;
        v18 = sub_80D6FCA(*(_DWORD **)(a1 + 344), 1, 0, 1);
        sub_8116004((int *)a1, a2, a3, a4, a5, a6, a7, a8, a9, v18);
        for ( i = 0; i < dword_859B5E4; ++i )
        {
          v12 = dword_859B400 + 10404 * i;
          if ( *(_DWORD *)(dword_859B400 + 10404 * i + 9924) == 2
            && *(_DWORD *)(v12 + 9896) == 2
            && *(_DWORD *)(v12 + 10152) == *(_DWORD *)a1 )
          {
            sub_80FB982(560 * i + 140924032);
          }
        }
        *(_BYTE *)(a1 + 353) = 1;
        *(_DWORD *)(a1 + 284) = 0x4000000;
        *(_DWORD *)(a1 + 332) = 0;
        sub_80FF17A(a1, (int)a2, (int)a3);
        sub_810043E((_DWORD *)(a1 + 324), (_DWORD *)(*(_DWORD *)(a1 + 344) + 232));
        *(_DWORD *)(a1 + 132) = 0;
        sub_809A3BA(a1);
        *(_DWORD *)(a1 + 280) = 1106247680;
        sub_809A45E(a1);
        *(_DWORD *)(a1 + 404) = 0;
        result = a1;
        *(_BYTE *)(a1 + 358) = 11;
      }
    }
  }
  return result;
}
// 859B400: using guessed type int dword_859B400;
// 859B5E4: using guessed type int dword_859B5E4;
// 87A22AA: using guessed type __int16 word_87A22AA;

//----- (080FF652) --------------------------------------------------------
long double __cdecl sub_80FF652(int a1, int a2)
{
  float v3; // [esp+10h] [ebp-8h]
  int v4; // [esp+14h] [ebp-4h]

  if ( a2 )
  {
    v4 = sub_80E9270(a2);
    if ( v4 && !*(_DWORD *)(v4 + 120) )
      v3 = *(float *)(v4 + 4 * a1 + 1456);
    else
      v3 = dword_8577F60[a1];
  }
  else
  {
    v3 = dword_8577F60[a1];
  }
  return v3;
}

//----- (080FF6B0) --------------------------------------------------------
__int16 __cdecl sub_80FF6B0(int a1, int *a2, int *a3, _DWORD *a4, _DWORD *a5, signed int a6, int a7, unsigned int a8, int a9, int a10)
{
  _DWORD *v10; // eax
  float v11; // ST2C_4
  long double v12; // fst7
  __int16 v14; // [esp+32h] [ebp-6h]
  int v15; // [esp+34h] [ebp-4h]
  int v16; // [esp+54h] [ebp+1Ch]

  LOWORD(v10) = a1;
  if ( *(_BYTE *)(a1 + 353) )
  {
    v10 = *(_DWORD **)(a1 + 344);
    if ( !v10[2539] )
    {
      v10 = *(_DWORD **)(a1 + 344);
      if ( !v10[2540] )
      {
        v10 = *(_DWORD **)(a1 + 344);
        if ( v10[2481] == 2 )
        {
          if ( a2 )
          {
            v15 = a2[50];
          }
          else if ( a3 )
          {
            v15 = a3[50];
          }
          else
          {
            v15 = 0;
          }
          v11 = (long double)a6;
          v12 = sub_80FF652(a9, v15);
          LOWORD(v10) = v14 | 0xC00;
          v16 = (signed int)(v12 * v11);
          if ( v16 > 0 )
            LOWORD(v10) = sub_8115F2A((int *)a1, a2, a3, v16, a7, a8, v15, a5, a4, a9, a10);
        }
      }
    }
  }
  return (signed __int16)v10;
}

//----- (080FF7C8) --------------------------------------------------------
__int16 __cdecl sub_80FF7C8(int *a1, int *a2, int *a3, float *a4, _DWORD *a5, signed int a6, int a7, unsigned int a8, int a9, int a10)
{
  int v10; // eax
  int (__cdecl *v12)(int *, int *, signed int, _DWORD *, unsigned int, char *, int); // [esp+38h] [ebp-20h]
  int (__cdecl *v13)(int *, int *, int *, signed int, unsigned int, int, char *, int, int); // [esp+3Ch] [ebp-1Ch]
  char v14; // [esp+40h] [ebp-18h]

  if ( a1[86] )
  {
    LOWORD(v10) = sub_80FF6B0((int)a1, a2, a3, a4, a5, a6, a7, a8, a9, a10);
  }
  else
  {
    LOWORD(v10) = (_WORD)a1;
    if ( *((_BYTE *)a1 + 353) )
    {
      if ( !a2 )
        a2 = &dword_86F1020;
      if ( !a3 )
        a3 = &dword_86F1020;
      sub_80A2298(a4, (int)&v14);
      v10 = a1[93] & 1;
      if ( !(_BYTE)v10 )
      {
        if ( a6 <= 0 )
          a6 = 1;
        if ( a1[93] & 2 && a1[101] - a6 <= 0 )
          a6 = a1[101] - 1;
        if ( *(_BYTE *)(dword_8793DAC + 8) )
          Com_Printf("target:%i health:%i damage:%i\n", *a1, a1[101], a6);
        a1[101] -= a6;
        Scr_AddEntity(a3);
        Scr_AddInt(a6);
        Scr_Notify(a1, word_87A22A8, 2);
        if ( a1[101] > 0 )
        {
          v10 = dword_8167894[10 * *((unsigned __int8 *)a1 + 358)];
          v12 = (int (__cdecl *)(int *, int *, signed int, _DWORD *, unsigned int, char *, int))dword_8167894[10 * *((unsigned __int8 *)a1 + 358)];
          if ( v12 )
            LOWORD(v10) = v12(a1, a3, a6, a5, a8, &v14, a9);
        }
        else
        {
          if ( a1[101] < -999 )
            a1[101] = -999;
          Scr_AddEntity(a3);
          Scr_Notify(a1, word_87A22AA, 1);
          v10 = dword_8167898[10 * *((unsigned __int8 *)a1 + 358)];
          v13 = (int (__cdecl *)(int *, int *, int *, signed int, unsigned int, int, char *, int, int))dword_8167898[10 * *((unsigned __int8 *)a1 + 358)];
          if ( v13 )
            LOWORD(v10) = v13(a1, a2, a3, a6, a8, a2[50], &v14, a9, a10);
        }
      }
    }
  }
  return v10;
}
// 8167894: using guessed type int dword_8167894[];
// 8167898: using guessed type int dword_8167898[];
// 86F1020: using guessed type int dword_86F1020;
// 8793DAC: using guessed type int dword_8793DAC;
// 87A22A8: using guessed type __int16 word_87A22A8;
// 87A22AA: using guessed type __int16 word_87A22AA;

//----- (080FFA56) --------------------------------------------------------
long double __cdecl sub_80FFA56(int a1, float *a2)
{
  float v2; // ST1C_4
  float v4; // [esp+14h] [ebp-A4h]
  signed int v5; // [esp+18h] [ebp-A0h]
  char v6; // [esp+20h] [ebp-98h]
  float v7; // [esp+28h] [ebp-90h]
  int v8; // [esp+30h] [ebp-88h]
  int v9; // [esp+34h] [ebp-84h]
  int v10; // [esp+38h] [ebp-80h]
  int v11; // [esp+40h] [ebp-78h]
  int v12; // [esp+44h] [ebp-74h]
  int v13; // [esp+48h] [ebp-70h]
  int i; // [esp+5Ch] [ebp-5Ch]
  int v15[3]; // [esp+60h] [ebp-58h]
  float v16; // [esp+6Ch] [ebp-4Ch]
  float v17; // [esp+70h] [ebp-48h]
  float v18; // [esp+74h] [ebp-44h]
  float v19; // [esp+78h] [ebp-40h]
  float v20; // [esp+7Ch] [ebp-3Ch]
  float v21; // [esp+80h] [ebp-38h]
  float v22; // [esp+84h] [ebp-34h]
  float v23; // [esp+88h] [ebp-30h]
  float v24; // [esp+8Ch] [ebp-2Ch]
  float v25; // [esp+90h] [ebp-28h]
  float v26; // [esp+94h] [ebp-24h]
  float v27; // [esp+98h] [ebp-20h]
  int v28; // [esp+ACh] [ebp-Ch]

  v28 = 1097859072;
  if ( *(_DWORD *)(a1 + 344) )
  {
    sub_80F61BE(a1, (float *)&v6);
    v2 = (v7 - *(float *)(a1 + 320)) * 0.5;
    sub_81004B2(a2, (float *)(a1 + 312), (float *)&v11);
    v13 = 0;
    sub_80A20C0((float *)&v11);
    v8 = v12 ^ 0x80000000;
    v9 = v11;
    v10 = v13;
    sub_810046E((float *)&v6, (float *)(a1 + 312), (float *)v15);
    sub_81004F6((int)v15, 0.5, (int)v15);
    sub_810052E((int)v15, 15.0, (int)&v8, (int)&v16);
    v18 = v18 + v2;
    sub_810052E((int)v15, 15.0, (int)&v8, (int)&v19);
    v21 = v21 - v2;
    sub_810052E((int)v15, -15.0, (int)&v8, (int)&v22);
    v24 = v24 + v2;
    sub_810052E((int)v15, -15.0, (int)&v8, (int)&v25);
    v27 = v27 - v2;
    v5 = 0;
    for ( i = 0; i <= 4; ++i )
    {
      if ( sub_810818A(a2, (float *)&v15[3 * i], *(_DWORD *)a1, 8398993) )
        ++v5;
    }
    if ( v5 )
    {
      if ( v5 <= 3 )
        v4 = (long double)v5 / 3.0;
      else
        v4 = 1.0;
    }
    else
    {
      v4 = 0.0;
    }
  }
  else
  {
    sub_810046E((float *)(a1 + 288), (float *)(a1 + 300), (float *)v15);
    sub_81004F6((int)v15, 0.5, (int)v15);
    sub_810043E(v15, &v16);
    v16 = v16 + 15.0;
    v17 = v17 + 15.0;
    sub_810043E(v15, &v19);
    v19 = v19 + 15.0;
    v20 = v20 - 15.0;
    sub_810043E(v15, &v22);
    v22 = v22 - 15.0;
    v23 = v23 + 15.0;
    sub_810043E(v15, &v25);
    v25 = v25 - 15.0;
    v26 = v26 - 15.0;
    for ( i = 0; i <= 4; ++i )
    {
      if ( sub_810818A((float *)&v15[3 * i], a2, *(_DWORD *)a1, 8398993) )
        return (float)1.0;
    }
    v4 = 0.0;
  }
  return v4;
}
// 80FFA56: using guessed type int var_58[3];

//----- (080FFE10) --------------------------------------------------------
int __cdecl sub_80FFE10(int a1, int a2, int a3, float a4, float a5, float a6, int a7, int a8)
{
  int v10; // [esp+40h] [ebp-10C8h]
  float s; // [esp+50h] [ebp-10B8h]
  int v12; // [esp+80h] [ebp-1088h]
  float v13; // [esp+90h] [ebp-1078h]
  int v14; // [esp+94h] [ebp-1074h]
  int j; // [esp+98h] [ebp-1070h]
  int i; // [esp+9Ch] [ebp-106Ch]
  char v17; // [esp+A0h] [ebp-1068h]
  float v18; // [esp+A8h] [ebp-1060h]
  float v19[4]; // [esp+B0h] [ebp-1058h]
  float v20[4]; // [esp+C0h] [ebp-1048h]
  float v21[7]; // [esp+D0h] [ebp-1038h]
  int v22; // [esp+ECh] [ebp-101Ch]
  int v23[1024]; // [esp+F0h] [ebp-1018h]
  int v24; // [esp+10F0h] [ebp-18h]
  float v25; // [esp+10F4h] [ebp-14h]
  float v26; // [esp+10F8h] [ebp-10h]
  float v27; // [esp+10FCh] [ebp-Ch]

  v14 = 0;
  if ( !a3 )
    return 0;
  if ( a6 < 1.0 )
    a6 = 1.0;
  v13 = a6 * 1.4142135;
  for ( i = 0; i <= 2; ++i )
  {
    v21[i] = *(float *)(a1 + 4 * i) - v13;
    v20[i] = *(float *)(a1 + 4 * i) + v13;
  }
  v22 = sub_805E782((int)v21, (int)v20, (int)v23, 1024, -1);
  for ( j = 0; j < v22; ++j )
  {
    v24 = (int)&unk_8665480 + 560 * v23[j];
    if ( v24 != a7 && *(_BYTE *)(v24 + 353) )
    {
      if ( *(_BYTE *)(v24 + 241) )
      {
        for ( i = 0; i <= 2; ++i )
        {
          if ( *(float *)(v24 + 4 * i + 288) <= (long double)*(float *)(a1 + 4 * i) )
          {
            if ( *(float *)(a1 + 4 * i) <= (long double)*(float *)(v24 + 4 * i + 300) )
              v19[i] = 0.0;
            else
              v19[i] = *(float *)(a1 + 4 * i) - *(float *)(v24 + 4 * i + 300);
          }
          else
          {
            v19[i] = *(float *)(v24 + 4 * i + 288) - *(float *)(a1 + 4 * i);
          }
        }
      }
      else
      {
        sub_81004B2((float *)(v24 + 312), (float *)a1, v19);
      }
      v26 = sub_8100582(v19);
      if ( v26 < (long double)a6 && (!*(_DWORD *)(v24 + 344) || !dword_859E9F4) )
      {
        v27 = (a4 - a5) * (1.0 - v26 / a6) + a5;
        v25 = sub_80FFA56(v24, (float *)a1);
        if ( v25 <= 0.0 )
        {
          sub_810046E((float *)(v24 + 288), (float *)(v24 + 300), (float *)&v10);
          sub_81004F6((int)&v10, 0.5, (int)&v10);
          sub_810043E(&v10, &v12);
          sub_8108090(&s, a1, (int)&unk_8145E68, (int)&unk_8145E68, (int)&v12, 1023, 2065);
          if ( s < 1.0 )
          {
            sub_81004B2((float *)&v12, (float *)a1, (float *)&v12);
            v26 = sub_8100582(&v12);
            if ( a6 * 0.2 > v26 )
            {
              if ( sub_811E2C2(v24, a3) )
                v14 = 1;
              sub_81004B2((float *)(v24 + 312), (float *)a1, (float *)&v17);
              v18 = v18 + 24.0;
              sub_80FF7C8(
                (int *)v24,
                (int *)a2,
                (int *)a3,
                (float *)&v17,
                (_DWORD *)a1,
                (signed int)(v27 * 0.1),
                1,
                a8,
                0,
                0);
            }
          }
        }
        else
        {
          if ( sub_811E2C2(v24, a3) )
            v14 = 1;
          sub_81004B2((float *)(v24 + 312), (float *)a1, (float *)&v17);
          v18 = v18 + 24.0;
          sub_80FF7C8(
            (int *)v24,
            (int *)a2,
            (int *)a3,
            (float *)&v17,
            (_DWORD *)a1,
            (signed int)(v27 * v25),
            1,
            a8,
            0,
            0);
        }
      }
    }
  }
  return v14;
}
// 8100582: using guessed type double __cdecl sub_8100582(_DWORD);
// 859E9F4: using guessed type int dword_859E9F4;
// 80FFE10: using guessed type float var_1038[7];
// 80FFE10: using guessed type float var_1048[4];
// 80FFE10: using guessed type int var_1018[1024];
// 80FFE10: using guessed type float var_1058[4];

//----- (081003E6) --------------------------------------------------------
int __cdecl sub_81003E6(int a1)
{
  return (unsigned __int16)word_8577FC0[a1];
}
// 8577FC0: using guessed type __int16 word_8577FC0[];

//----- (081003F6) --------------------------------------------------------
signed int __cdecl sub_81003F6(__int16 a1)
{
  signed int i; // [esp+4h] [ebp-8h]

  for ( i = 0; i <= 18; ++i )
  {
    if ( word_8577FC0[i] == a1 )
      return i;
  }
  return 0;
}
// 8577FC0: using guessed type __int16 word_8577FC0[];

//----- (0810043E) --------------------------------------------------------
int __cdecl sub_810043E(_DWORD *a1, _DWORD *a2)
{
  int result; // eax

  *a2 = *a1;
  a2[1] = a1[1];
  result = a1[2];
  a2[2] = result;
  return result;
}

//----- (0810046E) --------------------------------------------------------
int __cdecl sub_810046E(float *a1, float *a2, float *a3)
{
  int result; // eax

  *a3 = *a1 + *a2;
  a3[1] = a1[1] + a2[1];
  result = (int)(a1 + 2);
  a3[2] = a1[2] + a2[2];
  return result;
}

//----- (081004B2) --------------------------------------------------------
int __cdecl sub_81004B2(float *a1, float *a2, float *a3)
{
  int result; // eax

  *a3 = *a1 - *a2;
  a3[1] = a1[1] - a2[1];
  result = (int)(a1 + 2);
  a3[2] = a1[2] - a2[2];
  return result;
}

//----- (081004F6) --------------------------------------------------------
int __cdecl sub_81004F6(int a1, float a2, int a3)
{
  int result; // eax

  *(float *)a3 = a2 * *(float *)a1;
  *(float *)(a3 + 4) = a2 * *(float *)(a1 + 4);
  result = a1 + 8;
  *(float *)(a3 + 8) = a2 * *(float *)(a1 + 8);
  return result;
}

//----- (0810052E) --------------------------------------------------------
int __cdecl sub_810052E(int a1, float a2, int a3, int a4)
{
  int result; // eax

  *(float *)a4 = a2 * *(float *)a3 + *(float *)a1;
  *(float *)(a4 + 4) = a2 * *(float *)(a3 + 4) + *(float *)(a1 + 4);
  result = a3 + 8;
  *(float *)(a4 + 8) = a2 * *(float *)(a3 + 8) + *(float *)(a1 + 8);
  return result;
}

//----- (08100582) --------------------------------------------------------
void __cdecl sub_8100582(float *a1)
{
  float v1; // ST00_4

  v1 = *a1 * *a1 + a1[1] * a1[1] + a1[2] * a1[2];
  sub_81005C0(v1);
}

//----- (081005C0) --------------------------------------------------------
long double __cdecl sub_81005C0(float a1)
{
  return (float)sqrt(a1);
}

//----- (081005E0) --------------------------------------------------------
void sub_81005E0()
{
  ;
}

//----- (081005E6) --------------------------------------------------------
void __cdecl sub_81005E6(int a1, int a2, int a3, float a4)
{
  float v4; // ST00_4
  float *v5; // ST04_4
  float *v6; // ST00_4
  float v7; // [esp+24h] [ebp-A4h]
  float v8; // [esp+30h] [ebp-98h]
  float v9; // [esp+34h] [ebp-94h]
  int v10; // [esp+48h] [ebp-80h]
  int v11; // [esp+4Ch] [ebp-7Ch]
  float v12[26]; // [esp+50h] [ebp-78h]
  int j; // [esp+B8h] [ebp-10h]
  int i; // [esp+BCh] [ebp-Ch]
  char v15[8]; // [esp+C0h] [ebp-8h]

  v4 = a4 * 0.0174532925199433;
  sub_8100C02(v4, (int)&v11, (int)&v10);
  for ( i = 0; i <= 7; ++i )
  {
    for ( j = 0; j <= 2; ++j )
    {
      if ( (i >> j) & 1 )
        v7 = *(float *)(a3 + 4 * j);
      else
        v7 = *(float *)(a2 + 4 * j);
      v12[3 * i + j] = v7;
    }
    v8 = *(float *)&v15[12 * i - 112] * *(float *)&v10 - *(float *)&v15[12 * i - 108] * *(float *)&v11;
    v9 = *(float *)&v15[12 * i - 112] * *(float *)&v11 + *(float *)&v15[12 * i - 108] * *(float *)&v10;
    sub_8100C30(&v8, &v12[3 * i]);
    sub_8100CA4(&v12[3 * i], (float *)a1, &v12[3 * i]);
  }
  for ( i = 0; (unsigned int)i <= 0xB; ++i )
  {
    v5 = &v12[3 * dword_81527A4[2 * i]];
    v6 = &v12[3 * dword_81527A0[2 * i]];
    sub_81005E0();
  }
}
// 81527A0: using guessed type int dword_81527A0[];
// 81005E6: using guessed type float var_78[26];
// 81005E6: using guessed type char var_8[8];

//----- (081007DE) --------------------------------------------------------
int *__cdecl sub_81007DE(int a1, float a2, int a3, int a4, int a5)
{
  float v6[2]; // [esp+20h] [ebp-28h]
  float v7; // [esp+28h] [ebp-20h]
  int v8; // [esp+30h] [ebp-18h]

  if ( a5 )
  {
    sub_8100C50(&v8, 0, 0, 1065353216);
  }
  else
  {
    sub_8100C74((_DWORD *)(dword_859B400 + 20), v6);
    v7 = v7 + *(float *)(dword_859B400 + 248);
    sub_8100CE8((float *)a1, v6, (float *)&v8);
  }
  return sub_8100884(a1, a2, (int)&v8);
}
// 859B400: using guessed type int dword_859B400;

//----- (08100884) --------------------------------------------------------
int *__cdecl sub_8100884(int a1, float a2, int a3)
{
  int *result; // eax
  float v4; // [esp+2Ch] [ebp-10Ch]
  float v5; // [esp+30h] [ebp-108h]
  float v6; // [esp+38h] [ebp-100h]
  unsigned int i; // [esp+3Ch] [ebp-FCh]
  int v8; // [esp+40h] [ebp-F8h]
  int v9; // [esp+50h] [ebp-E8h]
  char v10; // [esp+60h] [ebp-D8h]
  char v11[200]; // [esp+70h] [ebp-C8h]

  sub_80A2298((float *)a3, (int)&v10);
  sub_80A30BA((float *)&v10, (float *)&v9);
  result = (int *)sub_80A1ED8((float *)&v10, (float *)&v9, (float *)&v8);
  for ( i = 0; i <= 0xF; ++i )
  {
    v6 = (long double)(signed int)i * 0.3926990816987241;
    sub_8100C02(v6, (int)&v5, (int)&v4);
    v5 = v5 * a2;
    v4 = v4 * a2;
    sub_8100D2C(a1, v5, (int)&v8, (int)&v11[12 * i]);
    sub_8100D2C((int)&v11[12 * i], v4, (int)&v9, (int)&v11[12 * i]);
    result = (int *)&i;
  }
  for ( i = 0; i <= 0xF; ++i )
  {
    sub_81005E0();
    result = (int *)&i;
  }
  return result;
}
// 8100884: using guessed type char var_C8[200];

//----- (08100A5A) --------------------------------------------------------
void __cdecl sub_8100A5A(int a1, float a2, float a3, float a4)
{
  int v4; // [esp+28h] [ebp-E0h]
  int v5; // [esp+2Ch] [ebp-DCh]
  float v6; // [esp+34h] [ebp-D4h]
  float v7; // [esp+38h] [ebp-D0h]
  unsigned int i; // [esp+3Ch] [ebp-CCh]
  char v9[8]; // [esp+100h] [ebp-8h]

  v7 = (a4 - a3) / 15.0;
  if ( v7 < 0.0 )
  {
    a3 = a3 - 360.0;
    v7 = (a4 - a3) / 15.0;
  }
  for ( i = 0; i <= 0xF; ++i )
  {
    v6 = ((long double)(signed int)i * v7 + a3) * 0.0174532925199433;
    sub_8100C02(v6, (int)&v5, (int)&v4);
    *(float *)&v9[12 * i - 192] = *(float *)&v4 * a2 + *(float *)a1;
    *(float *)&v9[12 * i - 188] = *(float *)&v5 * a2 + *(float *)(a1 + 4);
    *(_DWORD *)&v9[12 * i - 184] = *(_DWORD *)(a1 + 8);
  }
  for ( i = 0; i <= 0xE; ++i )
    sub_81005E0();
}
// 8100A5A: using guessed type char var_8[8];

//----- (08100C02) --------------------------------------------------------
void __cdecl sub_8100C02(float a1, int a2, int a3)
{
  *(float *)a2 = sin(a1);
  *(float *)a3 = cos(a1);
}

//----- (08100C30) --------------------------------------------------------
int __cdecl sub_8100C30(_DWORD *a1, _DWORD *a2)
{
  int result; // eax

  *a2 = *a1;
  result = a1[1];
  a2[1] = result;
  return result;
}

//----- (08100C50) --------------------------------------------------------
int __cdecl sub_8100C50(_DWORD *a1, int a2, int a3, int a4)
{
  int result; // eax

  *a1 = a2;
  a1[1] = a3;
  result = a4;
  a1[2] = a4;
  return result;
}

//----- (08100C74) --------------------------------------------------------
int __cdecl sub_8100C74(_DWORD *a1, _DWORD *a2)
{
  int result; // eax

  *a2 = *a1;
  a2[1] = a1[1];
  result = a1[2];
  a2[2] = result;
  return result;
}

//----- (08100CA4) --------------------------------------------------------
int __cdecl sub_8100CA4(float *a1, float *a2, float *a3)
{
  int result; // eax

  *a3 = *a1 + *a2;
  a3[1] = a1[1] + a2[1];
  result = (int)(a1 + 2);
  a3[2] = a1[2] + a2[2];
  return result;
}

//----- (08100CE8) --------------------------------------------------------
int __cdecl sub_8100CE8(float *a1, float *a2, float *a3)
{
  int result; // eax

  *a3 = *a1 - *a2;
  a3[1] = a1[1] - a2[1];
  result = (int)(a1 + 2);
  a3[2] = a1[2] - a2[2];
  return result;
}

//----- (08100D2C) --------------------------------------------------------
int __cdecl sub_8100D2C(int a1, float a2, int a3, int a4)
{
  int result; // eax

  *(float *)a4 = a2 * *(float *)a3 + *(float *)a1;
  *(float *)(a4 + 4) = a2 * *(float *)(a3 + 4) + *(float *)(a1 + 4);
  result = a3 + 8;
  *(float *)(a4 + 8) = a2 * *(float *)(a3 + 8) + *(float *)(a1 + 8);
  return result;
}

//----- (08100D80) --------------------------------------------------------
_DWORD *__cdecl sub_8100D80(_DWORD *a1)
{
  _DWORD *result; // eax

  a1[13] = 0;
  a1[14] = 0;
  a1[15] = 0;
  a1[20] = 0;
  a1[21] = 0;
  a1[22] = 0;
  a1[23] = 0;
  a1[16] = 0;
  a1[17] = 0;
  a1[18] = 0;
  a1[19] = 0;
  a1[26] = 0;
  a1[27] = 0;
  a1[28] = 0;
  result = a1;
  a1[29] = 0;
  return result;
}

//----- (08100E1E) --------------------------------------------------------
_DWORD *__cdecl sub_8100E1E(_DWORD *a1)
{
  *a1 = 1;
  a1[1] = 0;
  a1[2] = 0;
  a1[3] = 0;
  a1[4] = 1065353216;
  a1[5] = 0;
  a1[6] = 0;
  a1[7] = 0;
  a1[8] = -1;
  a1[9] = 0;
  a1[10] = 0;
  a1[11] = 0;
  a1[12] = 0;
  a1[30] = 0;
  a1[31] = 0;
  a1[34] = 1;
  return sub_8100D80(a1);
}

//----- (08100EDA) --------------------------------------------------------
int __cdecl sub_8100EDA(int a1, int a2)
{
  unsigned int i; // [esp+14h] [ebp-4h]

  for ( i = 0; i <= 0x3FF; ++i )
  {
    if ( !dword_8578000[35 * i] )
    {
      sub_8100E1E((_DWORD *)(140 * i + 139952128));
      dword_8578080[35 * i] = a1;
      dword_8578084[35 * i] = a2;
      return 140 * i + 139952128;
    }
  }
  return 0;
}
// 8578000: using guessed type int dword_8578000[];
// 8578080: using guessed type int dword_8578080[];

//----- (08100F68) --------------------------------------------------------
_DWORD *__cdecl sub_8100F68(_DWORD *a1)
{
  _DWORD *result; // eax

  sub_8118D3A((int)a1);
  result = a1;
  *a1 = 0;
  return result;
}

//----- (08100F84) --------------------------------------------------------
int *__cdecl sub_8100F84(_DWORD *a1)
{
  int *result; // eax
  unsigned int i; // [esp+4h] [ebp-4h]

  for ( i = 0; i <= 0x3FF; ++i )
  {
    if ( dword_8578000[35 * i] )
    {
      if ( dword_8578080[35 * i] == *a1 )
        sub_8100F68((_DWORD *)(140 * i + 139952128));
    }
    result = (int *)&i;
  }
  return result;
}
// 8578000: using guessed type int dword_8578000[];
// 8578080: using guessed type int dword_8578080[];

//----- (08100FE6) --------------------------------------------------------
void *sub_8100FE6()
{
  unsigned int i; // [esp+14h] [ebp-4h]

  for ( i = 0; i <= 0x3FF; ++i )
  {
    if ( dword_8578000[35 * i] )
      sub_8100F68((_DWORD *)(140 * i + 139952128));
  }
  return memset(dword_8578000, 0, 0x23000u);
}
// 8578000: using guessed type int dword_8578000[];

//----- (0810104E) --------------------------------------------------------
void __cdecl sub_810104E(int a1, int a2, int a3, int a4)
{
  char *v4; // eax
  _DWORD *v5; // [esp+1Ch] [ebp-81Ch]
  char s; // [esp+20h] [ebp-818h]
  char v7; // [esp+81Fh] [ebp-19h]
  char *v8; // [esp+828h] [ebp-10h]
  int i; // [esp+82Ch] [ebp-Ch]

  v5 = (_DWORD *)(a1 + *(_DWORD *)(a2 + 4));
  v8 = (char *)sub_808456A(0);
  for ( i = 0; i < a4; ++i )
  {
    if ( !I_stricmp(v8, *(char **)(a3 + 4 * i)) )
    {
      *v5 &= ~(*(_DWORD *)(a2 + 12) << *(_BYTE *)(a2 + 16));
      *v5 |= i << *(_BYTE *)(a2 + 16);
      return;
    }
  }
  sprintf(&s, "\"%s\" is not a valid value for hudelem field \"%s\"\nShould be one of:", v8, *(_DWORD *)a2);
  for ( i = 0; i < a4; ++i )
  {
    v4 = va(" %s", *(_DWORD *)(a3 + 4 * i));
    strncat(&s, v4, 0x800u);
    v7 = 0;
  }
  sub_8084DB4((int)&s);
}

//----- (08101188) --------------------------------------------------------
int __cdecl sub_8101188(int a1, int a2, int a3)
{
  return Scr_AddString(*(char **)(a3
                              + 4
                              * (*(_DWORD *)(a2 + 12) & (*(_DWORD *)(a1 + *(_DWORD *)(a2 + 4)) >> *(_BYTE *)(a2 + 16)))));
}

//----- (081011D0) --------------------------------------------------------
int *__cdecl sub_81011D0(int a1, int a2)
{
  char *s2; // ST10_4
  int v3; // edx
  int *result; // eax

  s2 = (char *)sub_80846DC(0);
  v3 = sub_811AF6E(s2);
  result = (int *)((char *)off_8152E40[7 * a2 + 1] + a1);
  *result = v3;
  return result;
}

//----- (0810121A) --------------------------------------------------------
int __cdecl sub_810121A(int a1, int a2)
{
  int result; // eax

  result = sub_808404C(0);
  *(_DWORD *)((char *)off_8152E40[7 * a2 + 1] + a1) = result;
  return result;
}

//----- (0810125C) --------------------------------------------------------
int __usercall sub_810125C@<eax>(long double a1@<st0>, _BYTE *a2)
{
  float v2; // ST04_4
  long double v3; // fst7
  float v4; // ST00_4
  float v5; // ST04_4
  long double v6; // fst7
  float v7; // ST00_4
  float v8; // ST04_4
  float v9; // ST00_4
  int result; // eax
  float v11; // [esp+10h] [ebp-18h]
  float v12; // [esp+14h] [ebp-14h]
  float v13; // [esp+18h] [ebp-10h]

  sub_80846F8(0, &v11);
  sub_8102580(1.0, v11);
  v2 = a1;
  sub_810255C(0.0, v2);
  v3 = a1 * 255.0;
  v4 = v3;
  a2[32] = sub_81025A4(v4);
  sub_8102580(1.0, v12);
  v5 = v3;
  sub_810255C(0.0, v5);
  v6 = v3 * 255.0;
  v7 = v6;
  a2[33] = sub_81025A4(v7);
  sub_8102580(1.0, v13);
  v8 = v6;
  sub_810255C(0.0, v8);
  v9 = v6 * 255.0;
  result = sub_81025A4(v9);
  a2[34] = result;
  return result;
}

//----- (0810132E) --------------------------------------------------------
_DWORD *__cdecl sub_810132E(unsigned __int8 *a1)
{
  float v2; // [esp+10h] [ebp-18h]
  float v3; // [esp+14h] [ebp-14h]
  float v4; // [esp+18h] [ebp-10h]

  v2 = (long double)a1[32] * 0.0039215689;
  v3 = (long double)a1[33] * 0.0039215689;
  v4 = (long double)a1[34] * 0.0039215689;
  return Scr_AddVector(&v2);
}

//----- (08101390) --------------------------------------------------------
int __cdecl sub_8101390(int a1)
{
  long double v1; // fst7
  float v2; // ST10_4
  float v3; // ST04_4
  float v4; // ST00_4
  int result; // eax

  v1 = sub_8084320(0);
  v2 = v1;
  sub_8102580(1.0, v2);
  v3 = v1;
  sub_810255C(0.0, v3);
  v4 = v1 * 255.0;
  result = sub_81025A4(v4);
  *(_BYTE *)(a1 + 35) = result;
  return result;
}

//----- (081013E8) --------------------------------------------------------
int __cdecl sub_81013E8(int a1)
{
  int v1; // ST04_4

  *(float *)&v1 = (long double)*(unsigned __int8 *)(a1 + 35) * 0.0039215689;
  return Scr_AddFloat(v1);
}

//----- (08101410) --------------------------------------------------------
float __usercall sub_8101410@<eax>(int a1)
{
  char *v1; // eax
  float result; // eax
  float v3; // [esp+14h] [ebp-4h]

  v3 = sub_8084320(0);
  if ( v3 <= 0.0 )
  {
    v1 = va("font scale was %g; should be > 0", v3);
    sub_8084DB4((int)v1);
  }
  result = v3;
  *(float *)(a1 + 16) = v3;
  return result;
}

//----- (0810145A) --------------------------------------------------------
void __cdecl sub_810145A(int a1, int a2)
{
  sub_810104E(a1, 28 * a2 + 135605824, (int)off_8167800, 3);
}
// 8167800: using guessed type char *off_8167800[9];

//----- (08101494) --------------------------------------------------------
int __cdecl sub_8101494(int a1, int a2)
{
  return sub_8101188(a1, 28 * a2 + 135605824, (int)off_8167800);
}
// 8167800: using guessed type char *off_8167800[9];

//----- (081014CE) --------------------------------------------------------
void __cdecl sub_81014CE(int a1, int a2)
{
  sub_810104E(a1, 28 * a2 + 135605824, (int)off_816780C, 3);
}
// 816780C: using guessed type char *off_816780C[6];

//----- (08101508) --------------------------------------------------------
int __cdecl sub_8101508(int a1, int a2)
{
  return sub_8101188(a1, 28 * a2 + 135605824, (int)off_816780C);
}
// 816780C: using guessed type char *off_816780C[6];

//----- (08101542) --------------------------------------------------------
void __cdecl sub_8101542(int a1, int a2)
{
  sub_810104E(a1, 28 * a2 + 135605824, (int)off_8167818, 3);
}
// 8167818: using guessed type char *off_8167818[3];

//----- (0810157C) --------------------------------------------------------
int __cdecl sub_810157C(int a1, int a2)
{
  return sub_8101188(a1, 28 * a2 + 135605824, (int)off_8167818);
}
// 8167818: using guessed type char *off_8167818[3];

//----- (081015B6) --------------------------------------------------------
void __cdecl sub_81015B6(int a1, int a2)
{
  sub_810104E(a1, 28 * a2 + 135605824, (int)off_8167840, 8);
}
// 8167840: using guessed type char *off_8167840[16];

//----- (081015F0) --------------------------------------------------------
int __cdecl sub_81015F0(int a1, int a2)
{
  return sub_8101188(a1, 28 * a2 + 135605824, (int)off_8167840);
}
// 8167840: using guessed type char *off_8167840[16];

//----- (0810162A) --------------------------------------------------------
void __cdecl sub_810162A(int a1, int a2)
{
  sub_810104E(a1, 28 * a2 + 135605824, (int)off_8167860, 8);
}
// 8167860: using guessed type char *off_8167860[8];

//----- (08101664) --------------------------------------------------------
int __cdecl sub_8101664(int a1, int a2)
{
  return sub_8101188(a1, 28 * a2 + 135605824, (int)off_8167860);
}
// 8167860: using guessed type char *off_8167860[8];

//----- (0810169E) --------------------------------------------------------
int __cdecl sub_810169E(int a1, int a2)
{
  int result; // eax
  int *v3; // [esp+10h] [ebp-8h]
  __int16 **v4; // [esp+14h] [ebp-4h]

  v4 = &off_8152E40[7 * a2];
  v3 = &dword_8578000[35 * a1];
  if ( v4[6] )
    result = ((int (__cdecl *)(int *, int))v4[6])(v3, a2);
  else
    result = sub_8118AAC((int)v3, (int)v4[2], (int)v4[1]);
  return result;
}
// 8578000: using guessed type int dword_8578000[];

//----- (08101716) --------------------------------------------------------
int __cdecl sub_8101716(int a1, int a2)
{
  int result; // eax
  int *v3; // [esp+10h] [ebp-8h]
  __int16 **v4; // [esp+14h] [ebp-4h]

  v4 = &off_8152E40[7 * a2];
  v3 = &dword_8578000[35 * a1];
  if ( v4[5] )
    result = ((int (__cdecl *)(int *, int))v4[5])(v3, a2);
  else
    result = sub_81188EE((int)v3, (int)v4[2], (int)v4[1]);
  return result;
}
// 8578000: using guessed type int dword_8578000[];

//----- (0810178E) --------------------------------------------------------
__int16 **__cdecl sub_810178E(int a1)
{
  __int16 **result; // eax
  __int16 **i; // [esp+14h] [ebp-4h]

  for ( i = off_8152E40; ; i += 7 )
  {
    result = i;
    if ( !*i )
      break;
    if ( i[2] == (__int16 *)3 )
      sub_8079790((__int16 *)((char *)i[1] + a1), 0);
  }
  return result;
}

//----- (081017D2) --------------------------------------------------------
int sub_81017D2()
{
  int v1; // [esp+14h] [ebp-4h]

  v1 = sub_8100EDA(1023, 0);
  if ( !v1 )
    sub_8084DB4((int)"out of hudelems");
  return sub_8118D6E(v1);
}

//----- (0810180E) --------------------------------------------------------
int sub_810180E()
{
  int *v1; // [esp+10h] [ebp-8h]
  int v2; // [esp+14h] [ebp-4h]

  v1 = (int *)sub_8118CDE(0);
  if ( !v1[86] )
    sub_8084E14(0, (int)"not a client");
  v2 = sub_8100EDA(*v1, 0);
  if ( !v2 )
    sub_8084DB4((int)"out of hudelems");
  return sub_8118D6E(v2);
}

//----- (0810187A) --------------------------------------------------------
int sub_810187A()
{
  int v0; // eax
  int v1; // eax
  char *v2; // eax
  __int16 v4; // [esp+12h] [ebp-6h]
  int v5; // [esp+14h] [ebp-4h]

  v4 = sub_80843C0(0);
  if ( v4 == word_87A22A2 )
  {
    v0 = sub_8100EDA(1023, 2);
  }
  else if ( v4 == word_87A22A4 )
  {
    v0 = sub_8100EDA(1023, 1);
  }
  else if ( v4 == word_87A22E8 )
  {
    v0 = sub_8100EDA(1023, 3);
  }
  else
  {
    v1 = sub_808456A(0);
    v2 = va("team \"%s\" should be \"allies\", \"axis\", or \"spectator\"", v1);
    sub_8084E14(0, (int)v2);
    v0 = sub_8100EDA(1023, 0);
  }
  v5 = v0;
  if ( !v0 )
    sub_8084DB4((int)"out of hudelems");
  return sub_8118D6E(v5);
}
// 87A22A2: using guessed type __int16 word_87A22A2;
// 87A22A4: using guessed type __int16 word_87A22A4;
// 87A22E8: using guessed type __int16 word_87A22E8;

//----- (0810193A) --------------------------------------------------------
void **sub_810193A()
{
  void **result; // eax
  void **i; // [esp+14h] [ebp-4h]

  for ( i = (void **)off_8152E40; ; i += 7 )
  {
    result = i;
    if ( !*i )
      break;
    sub_807E1F6(1, *i, 28087 * (((char *)i - (char *)off_8152E40) >> 2));
  }
  return result;
}

//----- (08101988) --------------------------------------------------------
int __cdecl sub_8101988(int a1)
{
  if ( HIWORD(a1) == 1 )
    return 140 * (unsigned __int16)a1 + 139952128;
  sub_8084E30((int)"not a hud element");
  return 0;
}

//----- (081019C2) --------------------------------------------------------
int __cdecl sub_81019C2(int a1)
{
  _DWORD *v1; // ST0C_4
  char *s2; // ST10_4
  int result; // eax

  v1 = (_DWORD *)sub_8101988(a1);
  s2 = (char *)sub_80846DC(0);
  sub_8100D80(v1);
  *v1 = 1;
  result = sub_811AF6E(s2);
  v1[29] = result;
  return result;
}

//----- (08101A12) --------------------------------------------------------
void __cdecl sub_8101A12(int a1)
{
  int v1; // [esp+10h] [ebp-8h]
  signed int *v2; // [esp+14h] [ebp-4h]

  v1 = sub_8101988(a1);
  v2 = (signed int *)sub_8118CDE(0);
  if ( v2 )
  {
    if ( v2[86] )
    {
      sub_8100D80((_DWORD *)v1);
      *(_DWORD *)v1 = 3;
      *(float *)(v1 + 112) = (long double)*v2;
    }
    else
    {
      Com_Printf("Invalid entity passed to hudelem setplayernamestring(), entity is not a client\n");
    }
  }
  else
  {
    Com_Printf("Invalid entity passed to hudelem setplayernamestring()\n");
  }
}

//----- (08101A84) --------------------------------------------------------
void __cdecl sub_8101A84(int a1)
{
  _DWORD *v1; // [esp+10h] [ebp-8h]
  char *s1; // [esp+14h] [ebp-4h]

  v1 = (_DWORD *)sub_8101988(a1);
  s1 = (char *)sub_808456A(0);
  if ( s1 )
  {
    if ( sub_8115DD2(s1) )
    {
      sub_8090E6C(20, s1);
      sub_8100D80(v1);
      *v1 = 5;
      v1[28] = 1101004800;
    }
    else
    {
      Com_Printf("Invalid gametype '%s'\n", s1);
    }
  }
  else
  {
    Com_Printf("Invalid entity passed to hudelem setgametypestring()\n");
  }
}

//----- (08101B14) --------------------------------------------------------
void __cdecl sub_8101B14(int a1)
{
  _DWORD *v1; // [esp+10h] [ebp-8h]
  char *s; // [esp+14h] [ebp-4h]

  v1 = (_DWORD *)sub_8101988(a1);
  s = (char *)sub_808456A(0);
  if ( s )
  {
    if ( sub_80909EE(s) )
    {
      sub_8090E6C(19, s);
      sub_8100D80(v1);
      *v1 = 4;
    }
    else
    {
      Com_Printf("Invalid map name passed to hudelem setmapnamestring(), map not found\n");
    }
  }
  else
  {
    Com_Printf("Invalid mapname passed to hudelem setmapnamestring()\n");
  }
}

//----- (08101B92) --------------------------------------------------------
int __cdecl sub_8101B92(int a1)
{
  char *v1; // eax
  char *v2; // eax
  char *v3; // eax
  int result; // eax
  int v5; // [esp+14h] [ebp-14h]
  int v6; // [esp+18h] [ebp-10h]
  int v7; // [esp+1Ch] [ebp-Ch]
  int v8; // [esp+20h] [ebp-8h]
  _DWORD *v9; // [esp+24h] [ebp-4h]

  v9 = (_DWORD *)sub_8101988(a1);
  v8 = sub_8084AEE();
  if ( v8 != 1 && v8 != 3 )
    sub_8084DB4((int)"USAGE: <hudelem> setShader(\"shadername\"[, optional_width, optional_height]);");
  v1 = (char *)sub_808456A(0);
  v5 = sub_811AFBA(v1);
  if ( v8 == 1 )
  {
    v7 = 0;
    v6 = 0;
  }
  else
  {
    v7 = sub_808404C(1u);
    if ( v7 < 0 )
    {
      v2 = va("width %i < 0", v7);
      sub_8084E14(1, (int)v2);
    }
    v6 = sub_808404C(2u);
    if ( v6 < 0 )
    {
      v3 = va("height %i < 0", v6);
      sub_8084E14(2, (int)v3);
    }
  }
  sub_8100D80(v9);
  *v9 = 6;
  v9[15] = v5;
  v9[13] = v7;
  result = v6;
  v9[14] = v6;
  return result;
}

//----- (08101C94) --------------------------------------------------------
int __cdecl sub_8101C94(int a1, int a2, int a3)
{
  char *v3; // eax
  float v4; // ST00_4
  char *v5; // eax
  int result; // eax
  signed int v7; // [esp+10h] [ebp-8h]
  _DWORD *v8; // [esp+14h] [ebp-4h]

  v8 = (_DWORD *)sub_8101988(a1);
  if ( sub_8084AEE() != 1 )
  {
    v3 = va("USAGE: <hudelem> %s(time_in_seconds);\n", a3);
    sub_8084DB4((int)v3);
  }
  v4 = sub_8084320(0) * 1000.0;
  v7 = sub_81025DA(v4);
  if ( v7 <= 0 && a2 != 8 )
  {
    v5 = va("time %g should be > 0", (double)((long double)v7 * 0.001));
    sub_8084E14(0, (int)v5);
  }
  sub_8100D80(v8);
  *v8 = a2;
  result = dword_859B5EC + v7;
  v8[26] = dword_859B5EC + v7;
  return result;
}

//----- (08101D48) --------------------------------------------------------
int __cdecl sub_8101D48(int a1, int a2, int a3)
{
  char *v3; // eax
  float v4; // ST00_4
  char *v5; // eax
  float v6; // ST00_4
  char *v7; // eax
  char *v8; // eax
  char *v9; // eax
  char *v10; // eax
  int result; // eax
  int v12; // [esp+Ch] [ebp-1Ch]
  int v13; // [esp+10h] [ebp-18h]
  int v14; // [esp+14h] [ebp-14h]
  signed int v15; // [esp+18h] [ebp-10h]
  signed int v16; // [esp+1Ch] [ebp-Ch]
  int v17; // [esp+20h] [ebp-8h]
  _DWORD *v18; // [esp+24h] [ebp-4h]

  v18 = (_DWORD *)sub_8101988(a1);
  v17 = sub_8084AEE();
  if ( v17 != 3 && v17 != 5 )
  {
    v3 = va(
           "USAGE: <hudelem> %s(time_in_seconds, total_clock_time_in_seconds, shadername[, width, height]);\n",
           a3);
    sub_8084DB4((int)v3);
  }
  v4 = sub_8084320(0) * 1000.0;
  v16 = sub_81025DA(v4);
  if ( v16 <= 0 && a2 != 12 )
  {
    v5 = va("time %g should be > 0", (double)((long double)v16 * 0.001));
    sub_8084E14(0, (int)v5);
  }
  v6 = sub_8084320(1u) * 1000.0;
  v15 = sub_81025DA(v6);
  if ( v15 <= 0 )
  {
    v7 = va("duration %g should be > 0", (double)((long double)v15 * 0.001));
    sub_8084E14(1, (int)v7);
  }
  v8 = (char *)sub_808456A(2u);
  v14 = sub_811AFBA(v8);
  if ( v17 == 3 )
  {
    v13 = 0;
    v12 = 0;
  }
  else
  {
    v13 = sub_808404C(3u);
    if ( v13 < 0 )
    {
      v9 = va("width %i < 0", v13);
      sub_8084E14(3, (int)v9);
    }
    v12 = sub_808404C(4u);
    if ( v12 < 0 )
    {
      v10 = va("height %i < 0", v12);
      sub_8084E14(4, (int)v10);
    }
  }
  sub_8100D80(v18);
  *v18 = a2;
  v18[26] = dword_859B5EC + v16;
  v18[27] = v15;
  v18[15] = v14;
  v18[13] = v13;
  result = v12;
  v18[14] = v12;
  return result;
}

//----- (08101F16) --------------------------------------------------------
int __cdecl sub_8101F16(int a1)
{
  return sub_8101C94(a1, 7, (int)"setTimer");
}

//----- (08101F3A) --------------------------------------------------------
int __cdecl sub_8101F3A(int a1)
{
  return sub_8101C94(a1, 8, (int)"setTimerUp");
}

//----- (08101F5E) --------------------------------------------------------
int __cdecl sub_8101F5E(int a1)
{
  return sub_8101C94(a1, 9, (int)"setTenthsTimer");
}

//----- (08101F82) --------------------------------------------------------
int __cdecl sub_8101F82(int a1)
{
  return sub_8101C94(a1, 10, (int)"setTenthsTimerUp");
}

//----- (08101FA6) --------------------------------------------------------
int __cdecl sub_8101FA6(int a1)
{
  return sub_8101D48(a1, 11, (int)"setClock");
}

//----- (08101FCA) --------------------------------------------------------
int __cdecl sub_8101FCA(int a1)
{
  return sub_8101D48(a1, 12, (int)"setClockUp");
}

//----- (08101FEE) --------------------------------------------------------
float __usercall sub_8101FEE@<eax>(int a1)
{
  int v1; // ST10_4
  float v2; // ST14_4
  float result; // eax

  v1 = sub_8101988(a1);
  v2 = sub_8084320(0);
  sub_8100D80((_DWORD *)v1);
  *(_DWORD *)v1 = 2;
  result = v2;
  *(float *)(v1 + 112) = v2;
  return result;
}

//----- (08102030) --------------------------------------------------------
int __cdecl sub_8102030(int a1)
{
  int v1; // ST14_4
  int v2; // ST10_4
  int result; // eax

  v1 = sub_8101988(a1);
  v2 = sub_808404C(0);
  *(_DWORD *)v1 = 13;
  result = v1;
  *(float *)(v1 + 112) = (long double)v2;
  return result;
}

//----- (08102068) --------------------------------------------------------
int __cdecl sub_8102068(int a1)
{
  char *v1; // eax
  char *v2; // eax
  float v3; // ST00_4
  int result; // eax
  float v5; // [esp+Ch] [ebp-Ch]
  _DWORD *v6; // [esp+10h] [ebp-8h]

  v6 = (_DWORD *)sub_8101988(a1);
  v5 = sub_8084320(0);
  if ( v5 > 0.0 )
  {
    if ( v5 > 60.0 )
    {
      v2 = va("fade time %g > 60", v5);
      sub_8084E14(0, (int)v2);
    }
  }
  else
  {
    v1 = va("fade time %g <= 0", v5);
    sub_8084E14(0, (int)v1);
  }
  v6[10] = dword_859B5EC;
  v3 = v5 * 1000.0;
  v6[11] = sub_81025A4(v3);
  result = v6[8];
  v6[9] = result;
  return result;
}

//----- (0810212C) --------------------------------------------------------
int __cdecl sub_810212C(int a1)
{
  char *v1; // eax
  char *v2; // eax
  int v3; // ST18_4
  int v4; // ST14_4
  float v5; // ST00_4
  int result; // eax
  float v7; // [esp+1Ch] [ebp-Ch]
  _DWORD *v8; // [esp+20h] [ebp-8h]

  v8 = (_DWORD *)sub_8101988(a1);
  if ( sub_8084AEE() != 3 )
    sub_8084DB4((int)"hudelem scaleOverTime(time_in_seconds, new_width, new_height)");
  v7 = sub_8084320(0);
  if ( v7 > 0.0 )
  {
    if ( v7 > 60.0 )
    {
      v2 = va("scale time %g > 60", v7);
      sub_8084E14(0, (int)v2);
    }
  }
  else
  {
    v1 = va("scale time %g <= 0", v7);
    sub_8084E14(0, (int)v1);
  }
  v3 = sub_808404C(1u);
  v4 = sub_808404C(2u);
  v8[18] = dword_859B5EC;
  v5 = v7 * 1000.0;
  v8[19] = sub_81025A4(v5);
  v8[16] = v8[13];
  v8[17] = v8[14];
  v8[13] = v3;
  result = v4;
  v8[14] = v4;
  return result;
}

//----- (08102242) --------------------------------------------------------
int __cdecl sub_8102242(int a1)
{
  char *v1; // eax
  char *v2; // eax
  float v3; // ST00_4
  int result; // eax
  float v5; // [esp+Ch] [ebp-Ch]
  _DWORD *v6; // [esp+10h] [ebp-8h]

  v6 = (_DWORD *)sub_8101988(a1);
  v5 = sub_8084320(0);
  if ( v5 > 0.0 )
  {
    if ( v5 > 60.0 )
    {
      v2 = va("move time %g > 60", v5);
      sub_8084E14(0, (int)v2);
    }
  }
  else
  {
    v1 = va("move time %g <= 0", v5);
    sub_8084E14(0, (int)v1);
  }
  v6[24] = dword_859B5EC;
  v3 = v5 * 1000.0;
  v6[25] = sub_81025A4(v3);
  v6[20] = v6[1];
  v6[21] = v6[2];
  v6[22] = v6[6];
  result = v6[7];
  v6[23] = result;
  return result;
}

//----- (0810232A) --------------------------------------------------------
_DWORD *__cdecl sub_810232A(int a1)
{
  _DWORD *v1; // ST04_4

  v1 = (_DWORD *)sub_8101988(a1);
  return sub_8100E1E(v1);
}

//----- (0810234C) --------------------------------------------------------
_DWORD *__cdecl sub_810234C(int a1)
{
  _DWORD *v1; // ST04_4

  v1 = (_DWORD *)sub_8101988(a1);
  return sub_8100F68(v1);
}

//----- (0810236E) --------------------------------------------------------
int (__cdecl *__cdecl sub_810236E(char **a1))(int)
{
  char *s1; // [esp+10h] [ebp-8h]
  unsigned int i; // [esp+14h] [ebp-4h]

  s1 = *a1;
  for ( i = 0; i <= 0x11; ++i )
  {
    if ( !strcmp(s1, (&off_81530E0)[3 * i]) )
    {
      *a1 = (&off_81530E0)[3 * i];
      return off_81530E4[3 * i];
    }
  }
  return 0;
}
// 81530E0: using guessed type char *off_81530E0;

//----- (081023F2) --------------------------------------------------------
int **__cdecl sub_81023F2(_DWORD *a1, int a2, unsigned __int8 a3)
{
  int **result; // eax
  int *v4; // [esp+Ch] [ebp-1Ch]
  _DWORD *v5; // [esp+10h] [ebp-18h]
  int v6; // [esp+14h] [ebp-14h]
  int v7; // [esp+18h] [ebp-10h]
  unsigned int v8; // [esp+1Ch] [ebp-Ch]

  if ( a3 & 1 )
    memset(a1 + 1482, 0, 0xF80u);
  result = (int **)(a3 & 2);
  if ( a3 & 2 )
    result = (int **)memset(a1 + 490, 0, 0xF80u);
  v7 = 0;
  v6 = 0;
  v4 = dword_8578000;
  v8 = 0;
  while ( v8 <= 0x3FF )
  {
    if ( *v4 && (!v4[33] || v4[33] == a1[2515]) && (v4[32] == 1023 || v4[32] == a2) )
    {
      if ( v4[34] )
      {
        if ( !((a3 ^ 1) & 1) )
        {
          v5 = &a1[32 * v7++ + 1482];
          if ( v7 <= 31 )
            goto LABEL_18;
        }
      }
      else if ( a3 & 2 )
      {
        v5 = &a1[32 * v6++ + 490];
        if ( v6 <= 31 )
        {
LABEL_18:
          qmemcpy(v5, v4, 0x80u);
          goto LABEL_19;
        }
      }
    }
LABEL_19:
    ++v8;
    result = &v4;
    v4 += 35;
  }
  return result;
}
// 8578000: using guessed type int dword_8578000[];

//----- (0810255C) --------------------------------------------------------
void __cdecl sub_810255C(float a1, float a2)
{
  float v2; // ST00_4

  v2 = a1 - a2;
  sub_8102608(v2, a1, a2);
}

//----- (08102580) --------------------------------------------------------
void __cdecl sub_8102580(float a1, float a2)
{
  float v2; // ST00_4

  v2 = a2 - a1;
  sub_8102608(v2, a1, a2);
}

//----- (081025A4) --------------------------------------------------------
int __cdecl sub_81025A4(float a1)
{
  return (signed int)floor(a1 + 0.5);
}

//----- (081025DA) --------------------------------------------------------
int __cdecl sub_81025DA(float a1)
{
  return (signed int)ceil(a1);
}

//----- (08102608) --------------------------------------------------------
long double __cdecl sub_8102608(float a1, float a2, float a3)
{
  float v4; // [esp+0h] [ebp-4h]

  if ( a1 < 0.0 )
    v4 = a3;
  else
    v4 = a2;
  return v4;
}

//----- (08102634) --------------------------------------------------------
int __cdecl sub_8102634(int a1, int a2)
{
  int result; // eax
  int v3; // ST1C_4
  int v4; // eax
  int v5; // [esp+Ch] [ebp-1Ch]
  int v6; // [esp+10h] [ebp-18h]
  int v7; // [esp+14h] [ebp-14h]

  v6 = sub_80EAC94(a2);
  result = sub_80EAC7A(a2);
  v5 = result;
  if ( a2 > 0 )
  {
    result = sub_80E9322();
    if ( a2 <= result )
    {
      v3 = *(_DWORD *)(a1 + 4 * v5 + 836);
      v4 = sub_80E9356(v5);
      v7 = v4 - v3;
      result = v4 - v3;
      if ( result > *(_DWORD *)(a1 + 4 * v6 + 324) )
      {
        result = *(_DWORD *)(a1 + 4 * v6 + 324);
        v7 = *(_DWORD *)(a1 + 4 * v6 + 324);
      }
      if ( v7 )
      {
        *(_DWORD *)(a1 + 4 * v6 + 324) -= v7;
        result = *(_DWORD *)(a1 + 4 * v5 + 836) + v7;
        *(_DWORD *)(a1 + 4 * v5 + 836) = result;
      }
    }
  }
  return result;
}

//----- (08102704) --------------------------------------------------------
int __cdecl sub_8102704(int a1, int a2, int a3, int a4)
{
  int v4; // esi
  int v5; // esi
  int v6; // esi
  int v7; // esi
  int v10; // [esp+Ch] [ebp-1Ch]
  int v11; // [esp+10h] [ebp-18h]
  signed int v12; // [esp+14h] [ebp-14h]
  int v13; // [esp+18h] [ebp-10h]
  int v14; // [esp+1Ch] [ebp-Ch]
  int v15; // [esp+38h] [ebp+10h]

  v14 = sub_80EAC94(a2);
  v13 = sub_80EAC7A(a2);
  v12 = 0;
  v11 = *(_DWORD *)(*(_DWORD *)(a1 + 344) + 4 * v14 + 324);
  v10 = *(_DWORD *)(*(_DWORD *)(a1 + 344) + 4 * v13 + 836);
  *(_DWORD *)(*(_DWORD *)(a1 + 344) + 4 * v14 + 324) += a3;
  if ( sub_80EACAE(a2) )
  {
    sub_811E696(*(_DWORD *)(a1 + 344), a2);
    v12 = 1;
  }
  if ( a4 || v12 )
    sub_8102634(*(_DWORD *)(a1 + 344), a2);
  if ( v12 )
  {
    *(_DWORD *)(*(_DWORD *)(a1 + 344) + 4 * v14 + 324) = 0;
  }
  else
  {
    v4 = *(_DWORD *)(a1 + 344);
    if ( *(_DWORD *)(v4 + 4 * v14 + 324) > sub_80E9336(v14) )
    {
      v5 = *(_DWORD *)(a1 + 344);
      *(_DWORD *)(v5 + 4 * v14 + 324) = sub_80E9336(v14);
    }
  }
  v6 = *(_DWORD *)(a1 + 344);
  if ( *(_DWORD *)(v6 + 4 * v13 + 836) > sub_80E9356(v13) )
  {
    v7 = *(_DWORD *)(a1 + 344);
    *(_DWORD *)(v7 + 4 * v13 + 836) = sub_80E9356(v13);
  }
  if ( *(_DWORD *)(sub_80E9270(a2) + 484) < 0 )
    return *(_DWORD *)(*(_DWORD *)(a1 + 344) + 4 * v13 + 836)
         - v10
         + *(_DWORD *)(*(_DWORD *)(a1 + 344) + 4 * v14 + 324)
         - v11;
  v15 = sub_80E9DE0(*(_DWORD *)(a1 + 344), a2);
  if ( v15 >= 0 )
    return *(_DWORD *)(*(_DWORD *)(a1 + 344) + 4 * v13 + 836)
         - v10
         + *(_DWORD *)(*(_DWORD *)(a1 + 344) + 4 * v14 + 324)
         - v11;
  if ( !sub_80EACAE(a2) )
  {
    *(_DWORD *)(*(_DWORD *)(a1 + 344) + 4 * v14 + 324) += v15;
    if ( *(_DWORD *)(*(_DWORD *)(a1 + 344) + 4 * v14 + 324) < 0 )
      *(_DWORD *)(*(_DWORD *)(a1 + 344) + 4 * v14 + 324) = 0;
    return *(_DWORD *)(*(_DWORD *)(a1 + 344) + 4 * v13 + 836)
         - v10
         + *(_DWORD *)(*(_DWORD *)(a1 + 344) + 4 * v14 + 324)
         - v11;
  }
  *(_DWORD *)(*(_DWORD *)(a1 + 344) + 4 * v13 + 836) += v15;
  if ( *(_DWORD *)(*(_DWORD *)(a1 + 344) + 4 * v13 + 836) > 0 )
    return *(_DWORD *)(*(_DWORD *)(a1 + 344) + 4 * v13 + 836)
         - v10
         + *(_DWORD *)(*(_DWORD *)(a1 + 344) + 4 * v14 + 324)
         - v11;
  *(_DWORD *)(*(_DWORD *)(a1 + 344) + 4 * v13 + 836) = 0;
  sub_80E98CA(*(_DWORD *)(a1 + 344), a2);
  return 0;
}

//----- (081029D4) --------------------------------------------------------
signed int __cdecl sub_81029D4(int a1, int *a2)
{
  int v2; // eax
  int v3; // eax
  char *v4; // eax
  int v5; // eax
  char *v6; // eax
  char *v9; // [esp+1Ch] [ebp-Ch]

  v9 = (char *)&unk_8164C20 + 44 * *(unsigned __int16 *)(a1 + 428);
  if ( *(_DWORD *)(a1 + 416) )
    v2 = sub_8102704((int)a2, *((_DWORD *)v9 + 8), *(_DWORD *)(a1 + 416), 0);
  else
    v2 = sub_8102704((int)a2, *((_DWORD *)v9 + 8), *((_DWORD *)v9 + 6), 0);
  if ( !v2 )
    return 0;
  if ( sub_80EACAE(*((_DWORD *)v9 + 8)) )
  {
    v3 = sub_80E9270(*((_DWORD *)v9 + 8));
    v4 = va(aCGamePickupCli, 102, *(_DWORD *)(v3 + 4));
  }
  else
  {
    v5 = sub_80E9270(*((_DWORD *)v9 + 8));
    v4 = va(aCGamePickupAmm, 102, *(_DWORD *)(v5 + 4));
  }
  sub_808FE96(-1963413621 * (((char *)a2 - (char *)&unk_8665480) >> 4), 0, (int)v4);
  Scr_AddEntity(a2);
  Scr_Notify((int *)a1, word_87A22F4, 1);
  if ( *(_DWORD *)(sub_80E9270(*((_DWORD *)v9 + 8)) + 132) )
    v6 = va("%c \"%i\"", 73, 4);
  else
    v6 = va("%c \"%i\"", 73, 1);
  sub_808FE96(-1963413621 * (((char *)a2 - (char *)&unk_8665480) >> 4), 0, (int)v6);
  return 1;
}
// 87A22F4: using guessed type __int16 word_87A22F4;

//----- (08102BE2) --------------------------------------------------------
signed int __cdecl sub_8102BE2(int a1, int *a2, _DWORD *a3, int a4)
{
  float v4; // ST20_4
  int v5; // eax
  float v6; // ST04_4
  int v7; // eax
  int v8; // eax
  int v9; // eax
  int v10; // eax
  int v11; // eax
  unsigned __int8 v12; // al
  int v13; // eax
  int v14; // eax
  int v15; // ST2C_4
  char *v16; // eax
  char *v17; // eax
  int v18; // eax
  int v19; // eax
  int v20; // eax
  int v21; // eax
  int v22; // eax
  int v23; // ebx
  int v24; // eax
  char *v25; // eax
  int v27; // [esp+14h] [ebp-44h]
  int v29; // [esp+24h] [ebp-34h]
  int i; // [esp+2Ch] [ebp-2Ch]
  int v31; // [esp+30h] [ebp-28h]
  int v32; // [esp+34h] [ebp-24h]
  _DWORD *v33; // [esp+38h] [ebp-20h]
  int *v34; // [esp+3Ch] [ebp-1Ch]
  int v35; // [esp+40h] [ebp-18h]
  char v36[4]; // [esp+44h] [ebp-14h]
  int v37; // [esp+48h] [ebp-10h]
  int v38; // [esp+4Ch] [ebp-Ch]
  int v39; // [esp+50h] [ebp-8h]

  v37 = 0;
  v34 = 0;
  v32 = (int)&unk_8164C20 + 44 * *(unsigned __int16 *)(a1 + 428);
  *(_DWORD *)v36 = *(_DWORD *)(v32 + 32);
  v33 = (_DWORD *)sub_80E9270(*(int *)v36);
  if ( *(_DWORD *)(a1 + 416) >= 0 )
  {
    if ( !*(_DWORD *)(a1 + 416) )
    {
      i = v33[221];
      v31 = v33[220];
      if ( i < v31 )
      {
        i = v31;
        v31 = v33[221];
      }
      if ( i || v31 )
      {
        if ( i >= 0 )
        {
          if ( i == v31 )
            v27 = v31;
          else
            v27 = rand() % (i - v31) + v31;
          *(_DWORD *)(a1 + 416) = v27;
          if ( *(_DWORD *)(a1 + 416) <= 0 )
            *(_DWORD *)(a1 + 416) = 0;
        }
        else
        {
          *(_DWORD *)(a1 + 416) = 0;
        }
      }
      else
      {
        v4 = (sub_80A1410() + 1.0) * 0.5;
        v5 = sub_80EAC7A(*(int *)v36);
        v6 = (long double)(sub_80E9356(v5) - 1) * v4;
        *(_DWORD *)(a1 + 416) = sub_8105D5E(v6) + 1;
      }
    }
    v7 = sub_80EAC94(*(int *)v36);
    if ( *(_DWORD *)(a1 + 416) > sub_80E9336(v7) )
    {
      v8 = sub_80EAC94(*(int *)v36);
      *(_DWORD *)(a1 + 416) = sub_80E9336(v8);
    }
    v39 = *(_DWORD *)(a1 + 416);
  }
  else
  {
    v39 = 0;
  }
  if ( *(_DWORD *)(a1 + 424) >= 0 )
  {
    if ( !*(_DWORD *)(a1 + 424) )
    {
      if ( *(_DWORD *)(a1 + 416) >= 0 )
      {
        v9 = sub_80EAC7A(*(int *)v36);
        *(_DWORD *)(a1 + 424) = sub_80E9356(v9);
        if ( *(_DWORD *)(a1 + 424) > *(_DWORD *)(a1 + 416) )
          *(_DWORD *)(a1 + 424) = *(_DWORD *)(a1 + 416);
        *(_DWORD *)(a1 + 416) -= *(_DWORD *)(a1 + 424);
        v39 = *(_DWORD *)(a1 + 416);
      }
      else
      {
        *(_DWORD *)(a1 + 424) = 0;
      }
    }
    v10 = sub_80EAC7A(*(int *)v36);
    if ( *(_DWORD *)(a1 + 424) > sub_80E9356(v10) )
    {
      v11 = sub_80EAC7A(*(int *)v36);
      *(_DWORD *)(a1 + 424) = sub_80E9356(v11);
    }
    v38 = *(_DWORD *)(a1 + 424);
  }
  else
  {
    v38 = 0;
  }
  v12 = sub_80D9E84(a2[86] + 1348, *(int *)v36);
  v37 = v12;
  if ( !v12 )
  {
    if ( (unsigned __int8)sub_80E9882(*(int *)v36) )
    {
      if ( *(_DWORD *)(a2[86] + 212) )
      {
        if ( !(unsigned __int8)sub_80D9E84(a2[86] + 1348, *(_DWORD *)(a2[86] + 212)) )
          return 0;
        if ( !sub_80E9B54(a2[86], *(_DWORD *)(a2[86] + 212), 1) )
        {
          v13 = sub_80E9270(*(_DWORD *)(a2[86] + 212));
          if ( !sub_80E9C6A(a2[86], *(_DWORD *)(a2[86] + 212), *(_DWORD *)(v13 + 128))
            && !sub_80E9C10(a2[86], *(int *)v36) )
          {
            Com_Printf("WARNING: cannot swap out a debug weapon (can result from too many weapons given to the player)\n");
            return 0;
          }
        }
      }
      if ( !sub_80E9C10(a2[86], *(int *)v36) )
      {
        v14 = sub_80E9270(*(_DWORD *)(a2[86] + 212));
        if ( !sub_80E9C6A(a2[86], *(int *)v36, *(_DWORD *)(v14 + 128)) )
        {
          if ( v33[32] == *(_DWORD *)(sub_80E9270(*(_DWORD *)(a2[86] + 212)) + 128) )
          {
            v34 = sub_810404E((int)a2, *(_DWORD *)(a2[86] + 212), 0);
          }
          else
          {
            for ( i = 1; i <= 2; ++i )
            {
              v31 = *(char *)(i + a2[86] + 1364);
              v15 = sub_80EAC94(*(int *)v36);
              v29 = sub_80EAC7A(*(int *)v36);
              if ( !*(_DWORD *)(a2[86] + 4 * v15 + 324) && !*(_DWORD *)(a2[86] + 4 * v29 + 836) )
              {
                v34 = sub_810404E((int)a2, v31, 0);
                break;
              }
            }
            if ( i > 2 )
            {
              v16 = va("%c \"GAME_CANT_GET_PRIMARY_WEAP_MESSAGE\"", 102);
              sub_808FE96(-1963413621 * (((char *)a2 - (char *)&unk_8665480) >> 4), 0, (int)v16);
              return 0;
            }
          }
          if ( !v34 )
            return 0;
          v34[92] = *(_DWORD *)(a1 + 368);
          v34[31] = *(_DWORD *)(a1 + 124);
          sub_811CF36(v34, (_DWORD *)(a1 + 312));
          sub_811CF96(v34, (_DWORD *)(a1 + 324));
          sub_809A45E((int)v34);
        }
      }
      sub_811E696(a2[86], *(int *)v36);
      if ( !a4 )
        sub_811E97A(-1963413621 * (((char *)a2 - (char *)&unk_8665480) >> 4), *(int *)v36);
    }
    else
    {
      sub_811E696(a2[86], *(int *)v36);
    }
  }
  if ( v37 )
  {
    *a3 = 145;
    v39 += v38;
    v35 = sub_8102704((int)a2, *(int *)v36, v39, 0);
    if ( v35 )
    {
      if ( sub_80EACAE(*(int *)v36) )
        v17 = va(aCGamePickupCli, 102, v33[1]);
      else
        v17 = va(aCGamePickupAmm, 102, v33[1]);
      sub_808FE96(-1963413621 * (((char *)a2 - (char *)&unk_8665480) >> 4), 0, (int)v17);
    }
    if ( v35 != v39 )
    {
      *(_DWORD *)(a1 + 416) -= v35;
      if ( *(_DWORD *)(a1 + 416) <= 0 )
      {
        *(_DWORD *)(a1 + 424) += *(_DWORD *)(a1 + 416);
        *(_DWORD *)(a1 + 416) = -1;
        if ( *(_DWORD *)(a1 + 424) <= 0 )
          *(_DWORD *)(a1 + 424) = -1;
      }
      if ( (*(_DWORD *)(a1 + 416) > 0 || *(_DWORD *)(a1 + 424) > 0) && *(_BYTE *)(dword_8793DB4 + 8) )
        return 0;
    }
  }
  else
  {
    if ( v38 >= 0 )
    {
      v18 = sub_80EAC7A(*(int *)v36);
      v19 = sub_80E9356(v18);
      if ( v38 > v19 )
      {
        v20 = sub_80EAC7A(*(int *)v36);
        v21 = sub_80E9356(v20);
        v39 += v38 - v21;
        v22 = sub_80EAC7A(*(int *)v36);
        v38 = sub_80E9356(v22);
      }
      v23 = a2[86];
      v24 = sub_80EAC7A(*(int *)v36);
      *(_DWORD *)(v23 + 4 * v24 + 836) = v38;
    }
    sub_8102704((int)a2, *(int *)v36, v39, v38 == -1);
  }
  if ( v34 )
    Scr_AddEntity(v34);
  else
    Scr_AddUndefined();
  Scr_AddEntity(a2);
  Scr_Notify((int *)a1, word_87A22F4, 2);
  if ( v33[33] )
    v25 = va("%c \"%i\"", 73, 4);
  else
    v25 = va("%c \"%i\"", 73, 1);
  sub_808FE96(-1963413621 * (((char *)a2 - (char *)&unk_8665480) >> 4), 0, (int)v25);
  return 1;
}
// 8793DB4: using guessed type int dword_8793DB4;
// 87A22F4: using guessed type __int16 word_87A22F4;

//----- (08103530) --------------------------------------------------------
signed int __cdecl sub_8103530(int a1, int *a2)
{
  char *v2; // eax
  char *v3; // eax
  signed int v5; // [esp+1Ch] [ebp-1Ch]
  int v6; // [esp+1Ch] [ebp-1Ch]
  signed int v7; // [esp+20h] [ebp-18h]
  char *v8; // [esp+24h] [ebp-14h]
  int v9; // [esp+28h] [ebp-10h]
  signed int v10; // [esp+2Ch] [ebp-Ch]
  int v11; // [esp+30h] [ebp-8h]

  v8 = (char *)&unk_8164C20 + 44 * *(unsigned __int16 *)(a1 + 428);
  if ( *((_DWORD *)v8 + 6) == 5 || *((_DWORD *)v8 + 6) == 100 )
    v11 = 2 * *(_DWORD *)(a2[86] + 308);
  else
    v11 = *(_DWORD *)(a2[86] + 308);
  if ( *(_DWORD *)(a1 + 416) )
    v10 = *(_DWORD *)(a1 + 416);
  else
    v10 = *((_DWORD *)v8 + 6);
  v9 = a2[101];
  a2[101] += (signed int)((long double)v10 * (long double)*(signed int *)(a2[86] + 308) * 0.0099999998);
  if ( a2[101] <= v11 )
  {
    v7 = (signed int)((long double)(100 * a2[101]) / (long double)*(signed int *)(a2[86] + 308));
    if ( v7 > 0 )
    {
      if ( v7 > 100 )
        v7 = 100;
    }
    else
    {
      v7 = 1;
    }
    v5 = (signed int)((long double)(100 * v9) / (long double)*(signed int *)(a2[86] + 308));
    if ( v5 <= 0 )
      v5 = 1;
    v6 = v10 + v5;
    if ( v6 > 100 )
      v6 = 100;
    if ( v7 != v6 )
      a2[101] = *(_DWORD *)(a2[86] + 308) * v6 / 100;
  }
  else
  {
    a2[101] = v11;
  }
  *(_DWORD *)(a2[86] + 300) = a2[101];
  v2 = va(aCGamePickupHea, 102, v10);
  sub_808FE96(-1963413621 * (((char *)a2 - (char *)&unk_8665480) >> 4), 0, (int)v2);
  v3 = va("%c \"%i\"", 73, 0);
  sub_808FE96(-1963413621 * (((char *)a2 - (char *)&unk_8665480) >> 4), 0, (int)v3);
  Scr_AddEntity(a2);
  Scr_Notify((int *)a1, word_87A22F4, 1);
  return 1;
}
// 87A22F4: using guessed type __int16 word_87A22F4;

//----- (081037F0) --------------------------------------------------------
unsigned __int16 *__usercall sub_81037F0@<eax>(long double a1@<st0>, int a2, int *a3, int a4)
{
  *(_BYTE *)(a2 + 354) = 1;
  return sub_810381C(a1, (unsigned __int16 *)a2, a3, a4);
}

//----- (0810381C) --------------------------------------------------------
unsigned __int16 *__usercall sub_810381C@<eax>(long double a1@<st0>, unsigned __int16 *s, int *a3, int a4)
{
  unsigned __int16 *result; // eax
  int v5; // eax
  char *v6; // eax
  char *v7; // eax
  _DWORD *v8; // ebx
  int v9; // eax
  int v10; // eax
  signed int v11; // [esp+28h] [ebp-60h]
  _DWORD *v12; // [esp+2Ch] [ebp-5Ch]
  char dest; // [esp+30h] [ebp-58h]
  int v14; // [esp+78h] [ebp-10h]
  unsigned __int16 *v15; // [esp+7Ch] [ebp-Ch]

  v14 = 144;
  result = s;
  if ( *((_BYTE *)s + 354) )
  {
    *((_BYTE *)s + 354) = 0;
    result = (unsigned __int16 *)a3;
    if ( a3[86] )
    {
      result = (unsigned __int16 *)a3;
      if ( a3[101] > 0 && !dword_859B420 )
      {
        v12 = (_DWORD *)((char *)&unk_8164C20 + 44 * s[214]);
        result = (unsigned __int16 *)sub_80DCC7A(s, (_DWORD *)a3[86], a4);
        if ( result )
        {
          I_strncpyz(&dest, (char *)(a3[86] + 10116), 64);
          sub_80B587C(&dest);
          if ( v12[7] == 1 )
          {
            v8 = (_DWORD *)sub_80E9270(v12[8]);
            v9 = sub_8090AFE(*a3);
            sub_8107502("Weapon;%d;%d;%s;%s\n", v9, *a3, &dest, *v8);
          }
          else
          {
            v10 = sub_8090AFE(*a3);
            sub_8107502("Item;%d;%d;%s;%s\n", v10, *a3, &dest, *v12);
          }
          result = (unsigned __int16 *)v12[7];
          v11 = v12[7];
          if ( v11 == 2 )
          {
            result = (unsigned __int16 *)sub_81029D4((int)s, a3);
            v15 = result;
          }
          else if ( v11 > 2 )
          {
            if ( v11 != 3 )
              return result;
            result = (unsigned __int16 *)sub_8103530((int)s, a3);
            v15 = result;
          }
          else
          {
            if ( v11 != 1 )
              return result;
            result = (unsigned __int16 *)sub_8102BE2((int)s, a3, &v14, a4);
            v15 = result;
          }
          if ( v15 )
          {
            if ( *(_DWORD *)(a3[86] + 9988) )
              sub_811CD6C((int)a3, v14, *((_DWORD *)s + 35));
            else
              sub_811CDA2(a3, v14, *((_DWORD *)s + 35));
            result = (unsigned __int16 *)sub_811C9C0(a1, s);
          }
        }
        else if ( !a4 )
        {
          result = (unsigned __int16 *)*((_DWORD *)s + 36);
          if ( result != (unsigned __int16 *)*a3 )
          {
            result = (unsigned __int16 *)v12[7];
            if ( result == (unsigned __int16 *)1 )
            {
              if ( (unsigned __int8)sub_80D9E84(a3[86] + 1348, v12[8]) )
              {
                v5 = sub_80E9270(v12[8]);
                v6 = va(aCGamePickupCan, 102, *(_DWORD *)(v5 + 4));
                result = (unsigned __int16 *)sub_808FE96(
                                               -1963413621 * (((char *)a3 - (char *)&unk_8665480) >> 4),
                                               0,
                                               (int)v6);
              }
              else
              {
                result = (unsigned __int16 *)(*(_DWORD *)(sub_80E9270(v12[8]) + 128) - 1);
                if ( (unsigned int)result <= 1 )
                {
                  v7 = va("%c \"GAME_CANT_GET_PRIMARY_WEAP_MESSAGE\"", 102);
                  result = (unsigned __int16 *)sub_808FE96(
                                                 -1963413621 * (((char *)a3 - (char *)&unk_8665480) >> 4),
                                                 0,
                                                 (int)v7);
                }
              }
            }
          }
        }
      }
    }
  }
  return result;
}
// 859B420: using guessed type int dword_859B420;

//----- (08103B6A) --------------------------------------------------------
int __usercall sub_8103B6A@<eax>(long double a1@<st0>)
{
  int v3; // [esp+14h] [ebp-24h]
  float *s; // [esp+1Ch] [ebp-1Ch]
  float v5; // [esp+20h] [ebp-18h]
  float v6; // [esp+24h] [ebp-14h]
  float v7; // [esp+28h] [ebp-10h]
  int v8; // [esp+2Ch] [ebp-Ch]
  int j; // [esp+30h] [ebp-8h]
  int i; // [esp+34h] [ebp-4h]

  v8 = 0;
  v5 = -1.0;
  v3 = *(_DWORD *)(dword_8793DB8 + 8);
  for ( i = 0; i < v3; ++i )
  {
    s = (float *)dword_859D158[i];
    if ( !s )
      return i;
    v7 = 9.9999803e11;
    for ( j = 0; j < dword_859B5E4; ++j )
    {
      if ( *(_DWORD *)(dword_859B400 + 10404 * j + 9924) == 2 && !*(_DWORD *)(dword_859B400 + 10404 * j + 9896) )
      {
        v6 = sub_80A1DB2((float *)(560 * j + 140924344), s + 78);
        if ( v7 > (long double)v6 )
          v7 = v6;
      }
    }
    a1 = v5;
    if ( v7 > (long double)v5 )
    {
      v5 = v7;
      v8 = i;
    }
  }
  sub_811C9C0(a1, (void *)dword_859D158[v8]);
  dword_859D158[v8] = 0;
  return v8;
}
// 859B400: using guessed type int dword_859B400;
// 859B5E4: using guessed type int dword_859B5E4;
// 8793DB8: using guessed type int dword_8793DB8;

//----- (08103CB2) --------------------------------------------------------
int __cdecl sub_8103CB2(char **a1, int a2)
{
  char s; // [esp+10h] [ebp-118h]
  _DWORD *v4; // [esp+118h] [ebp-10h]
  int v5; // [esp+11Ch] [ebp-Ch]

  v5 = -1171354717 * (((char *)a1 - (char *)&unk_8164C20) >> 2);
  if ( v5 > sub_80E9322() )
    return sub_811D098(a2, *a1);
  v4 = (_DWORD *)sub_80E9270(v5);
  Com_sprintf(&s, 0x100u, "weapon_%s", *v4);
  return sub_811D098(a2, &s);
}

//----- (08103D3C) --------------------------------------------------------
int __usercall sub_8103D3C@<eax>(long double a1@<st0>, int a2, _DWORD *a3, _DWORD *a4, int a5)
{
  int v5; // ST14_4
  int v7; // [esp+10h] [ebp-8h]

  v5 = -1171354717 * ((a2 - (signed int)&unk_8164C20) >> 2);
  sub_8104C84(-1171354717 * ((a2 - (signed int)&unk_8164C20) >> 2), 1);
  v7 = sub_811C546();
  dword_859D158[sub_8103B6A(a1)] = v7;
  *(_DWORD *)(v7 + 4) = 3;
  *(_DWORD *)(v7 + 140) = v5;
  sub_8103CB2((char **)a2, v7 + 360);
  *(_WORD *)(v7 + 428) = v5;
  if ( *(_DWORD *)(a2 + 28) == 1 )
  {
    sub_8105DBE((_DWORD *)(v7 + 260), -1082130432, -1082130432, -1082130432);
    sub_8105DBE((_DWORD *)(v7 + 272), 1065353216, 1065353216, 1065353216);
  }
  else
  {
    sub_8105DBE((_DWORD *)(v7 + 260), -1082130432, -1082130432, 0);
    sub_8105DBE((_DWORD *)(v7 + 272), 1065353216, 1065353216, 0x40000000);
  }
  *(_DWORD *)(v7 + 284) = 1079771400;
  if ( *(_DWORD *)(a2 + 28) != 2 )
    *(_DWORD *)(v7 + 284) |= 0x200000u;
  *(_DWORD *)(v7 + 144) = a5;
  sub_811B3EA(v7, *(char **)(a2 + 8));
  sub_811B20E(a1, v7);
  *(_BYTE *)(v7 + 358) = 15;
  sub_811CF36((_DWORD *)v7, a3);
  *(_DWORD *)(v7 + 12) = 5;
  *(_DWORD *)(v7 + 16) = dword_859B5EC;
  sub_8105DE2(a4, (_DWORD *)(v7 + 36));
  *(_DWORD *)(v7 + 400) = dword_859B5EC + 1000;
  *(_DWORD *)(v7 + 372) = 16;
  sub_809A45E(v7);
  return v7;
}

//----- (08103F44) --------------------------------------------------------
int __cdecl sub_8103F44(int a1, int a2, float a3, int a4)
{
  int v4; // ebx
  long double v5; // fst7
  char v7; // [esp+10h] [ebp-38h]
  float v8; // [esp+18h] [ebp-30h]
  int v9; // [esp+20h] [ebp-28h]
  float v10; // [esp+24h] [ebp-24h]
  int v11; // [esp+28h] [ebp-20h]
  int v12; // [esp+30h] [ebp-18h]
  float v13; // [esp+38h] [ebp-10h]

  sub_8105DE2((_DWORD *)(a1 + 324), &v9);
  v10 = v10 + a3;
  v9 = 0;
  v11 = 0;
  if ( a4 )
  {
    sub_8105D94(&v12);
  }
  else
  {
    sub_80A2EC2((float *)&v9, (int)&v12, 0, 0);
    sub_8105EF6((int)&v12, *(float *)(dword_8793DC8 + 8), (int)&v12);
    v4 = dword_8793DCC;
    v13 = sub_80A142E() * *(float *)(dword_8793DD0 + 8) + *(float *)(v4 + 8) + v13;
  }
  sub_8105DE2((_DWORD *)(a1 + 312), &v7);
  v5 = (*(float *)(a1 + 280) - *(float *)(a1 + 268)) * 0.5 + v8;
  v8 = v5;
  return sub_8103D3C(v5, a2, &v7, &v12, *(_DWORD *)a1);
}
// 8793DC8: using guessed type int dword_8793DC8;
// 8793DCC: using guessed type int dword_8793DCC;
// 8793DD0: using guessed type int dword_8793DD0;

//----- (0810404E) --------------------------------------------------------
_DWORD *__cdecl sub_810404E(int a1, int a2, int a3)
{
  float v3; // ST4C_4
  float v4; // ST04_4
  float v5; // ST04_4
  int v6; // eax
  int v7; // ST40_4
  int v8; // ST3C_4
  int v9; // ST08_4
  int v11; // [esp+40h] [ebp-D8h]
  int v12; // [esp+44h] [ebp-D4h]
  _DWORD *v13; // [esp+4Ch] [ebp-CCh]
  float s; // [esp+50h] [ebp-C8h]
  int v15; // [esp+80h] [ebp-98h]
  char v16; // [esp+90h] [ebp-88h]
  float v17; // [esp+98h] [ebp-80h]
  char v18; // [esp+A0h] [ebp-78h]
  int v19; // [esp+C4h] [ebp-54h]
  char v20; // [esp+D0h] [ebp-48h]
  int v21; // [esp+ECh] [ebp-2Ch]
  int v22; // [esp+F0h] [ebp-28h]
  int v23; // [esp+F4h] [ebp-24h]
  int v24; // [esp+F8h] [ebp-20h]
  _DWORD *v25; // [esp+FCh] [ebp-1Ch]
  int v26; // [esp+100h] [ebp-18h]
  int v27; // [esp+104h] [ebp-14h]
  int v28; // [esp+108h] [ebp-10h]
  int v29; // [esp+10Ch] [ebp-Ch]

  v24 = (int)&unk_8164C20 + 44 * a2;
  if ( !*(_DWORD *)(a1 + 344) || (unsigned __int8)sub_80D9E84(*(_DWORD *)(a1 + 344) + 1348, a2) )
  {
    v27 = sub_80EAC94(a2);
    v26 = sub_80EAC7A(a2);
    if ( !*(_DWORD *)(sub_80E9270(a2) + 832) || *(_DWORD *)(*(_DWORD *)(a1 + 344) + 4 * v26 + 836) )
    {
      v25 = (_DWORD *)sub_8103F44(a1, v24, 0.0, 0);
      if ( *(_DWORD *)(a1 + 344) )
      {
        v29 = *(_DWORD *)(*(_DWORD *)(a1 + 344) + 4 * v27 + 324);
        *(_DWORD *)(*(_DWORD *)(a1 + 344) + 4 * v27 + 324) = 0;
        v28 = *(_DWORD *)(*(_DWORD *)(a1 + 344) + 4 * v26 + 836);
        *(_DWORD *)(*(_DWORD *)(a1 + 344) + 4 * v26 + 836) = 0;
        sub_80E98CA(*(_DWORD *)(a1 + 344), a2);
      }
      else
      {
        v22 = *(_DWORD *)(sub_80E9270(a2) + 884);
        v21 = *(_DWORD *)(sub_80E9270(a2) + 880);
        if ( v22 < v21 )
        {
          v22 = v21;
          v21 = *(_DWORD *)(sub_80E9270(a2) + 884);
        }
        if ( v22 || v21 )
        {
          if ( v22 >= 0 )
          {
            if ( v22 == v21 )
              v12 = v21;
            else
              v12 = rand() % (v22 - v21) + v21;
            v29 = v12;
            if ( v12 > 0 )
            {
              v23 = sub_80E9356(v26);
              if ( v23 )
                v11 = rand() % v23;
              else
                v11 = 0;
              v28 = v11;
              if ( v11 < v29 )
              {
                v29 -= v28;
              }
              else
              {
                v28 = v29;
                v29 = 0;
              }
            }
            else
            {
              v29 = 0;
              v28 = 0;
            }
          }
          else
          {
            v29 = 0;
            v28 = 0;
          }
        }
        else
        {
          v3 = (sub_80A1410() + 1.0) * 0.5;
          v4 = (long double)(sub_80E9356(v26) - 1) * v3;
          v29 = sub_8105D5E(v4) + 1;
          v5 = (sub_80A1410() * 0.5 + 0.25) * (long double)v29;
          v28 = sub_8105D5E(v5);
          v29 -= v28;
        }
      }
      v25[104] = v29;
      v25[106] = v28;
      if ( !v25[104] )
        v25[104] = -1;
      if ( !v25[106] )
        v25[106] = -1;
      if ( !v29 && !v28 )
        v25[71] &= 0xFFDFFFFF;
      if ( a3 )
      {
        if ( sub_811C0B2(a1, a3, (float *)&v18) )
        {
          sub_8105E9A((float *)(a1 + 260), (float *)(a1 + 272), (float *)&v15);
          sub_8105E12((float *)&v15, (float *)(a1 + 312), (float *)&v15);
          v6 = sub_8105FEA((int)v25);
          sub_8108090(&s, (int)&v15, (int)(v25 + 65), (int)(v25 + 68), (int)&v19, *(_DWORD *)a1, v6);
          sub_80DEB7A((int)&v15, (int)&v19, s, (int)(v25 + 6));
          sub_8105DE2(v25 + 6, v25 + 78);
          v25[4] = dword_859B5EC;
          sub_80A71F4((int)&v18, (int)&v16);
        }
        else
        {
          sub_8105DE2((_DWORD *)(a1 + 324), &v16);
        }
        v17 = v17 + 90.0;
        sub_811CF96(v25, (_DWORD *)(a1 + 324));
        *(float *)&v7 = sub_80A142E() * 60.0;
        *(float *)&v8 = sub_80A142E() * 40.0;
        *(float *)&v9 = sub_80A142E() * 50.0;
        sub_8105DBE(&v20, v9, v8, v7);
        v25[12] = 2;
        v25[13] = dword_859B5EC;
        sub_8105DE2(&v20, v25 + 18);
      }
      v13 = v25;
    }
    else
    {
      sub_80E98CA(*(_DWORD *)(a1 + 344), a2);
      v13 = 0;
    }
  }
  else
  {
    sub_80E98CA(*(_DWORD *)(a1 + 344), a2);
    v13 = 0;
  }
  return v13;
}

//----- (08104600) --------------------------------------------------------
int __cdecl sub_8104600(_DWORD *a1)
{
  long double v1; // fst7
  int v2; // ST0C_4
  int v3; // ST0C_4
  char *v4; // ebx
  int v5; // eax
  char v7; // [esp+20h] [ebp-E8h]
  int v8; // [esp+2Ch] [ebp-DCh]
  int v9; // [esp+38h] [ebp-D0h]
  char v10; // [esp+50h] [ebp-B8h]
  float v11; // [esp+58h] [ebp-B0h]
  int v12; // [esp+6Ch] [ebp-9Ch]
  int v13; // [esp+70h] [ebp-98h]
  int v14; // [esp+80h] [ebp-88h]
  float v15; // [esp+88h] [ebp-80h]
  int v16; // [esp+9Ch] [ebp-6Ch]
  int v17; // [esp+A0h] [ebp-68h]
  int v18; // [esp+B0h] [ebp-58h]
  int v19; // [esp+C0h] [ebp-48h]
  float s; // [esp+D0h] [ebp-38h]
  int v21; // [esp+D4h] [ebp-34h]
  unsigned __int16 v22; // [esp+ECh] [ebp-1Ch]
  char v23; // [esp+F3h] [ebp-15h]

  *((_BYTE *)a1 + 358) = 17;
  if ( a1[92] & 1 )
  {
    sub_811CF36(a1, a1 + 78);
  }
  else
  {
    v16 = (int)&unk_8164C20 + 44 * *((unsigned __int16 *)a1 + 214);
    if ( *(_DWORD *)(v16 + 28) == 1 )
    {
      sub_8105DBE(&v18, -1082130432, -1082130432, -1082130432);
      sub_8105DBE(&v17, 1065353216, 1065353216, 1065353216);
    }
    else
    {
      sub_8105DBE(&v18, -1082130432, -1082130432, 0);
      sub_8105DBE(&v17, 1065353216, 1065353216, 0x40000000);
    }
    v12 = sub_8105FEA((int)a1);
    sub_8105DE2(a1 + 78, &v14);
    v1 = *((float *)a1 + 80) - 4096.0;
    *(float *)&v2 = v1;
    sub_8105DBE(&v19, a1[78], a1[79], v2);
    sub_8108090(&s, (int)&v14, (int)&v18, (int)&v17, (int)&v19, *a1, v12);
    if ( v23 )
    {
      sub_8105DE2(a1 + 78, &v14);
      v15 = v15 - 15.0;
      v1 = *((float *)a1 + 80) - 4096.0;
      *(float *)&v3 = v1;
      sub_8105DBE(&v19, a1[78], a1[79], v3);
      sub_8108090(&s, (int)&v14, (int)&v18, (int)&v17, (int)&v19, *a1, v12);
    }
    if ( v23 )
    {
      v4 = sub_80F1B86((float *)a1 + 78);
      v5 = sub_8078896(*((unsigned __int16 *)a1 + 180));
      Com_Printf("FinishSpawningItem: %s startsolid at %s\n", v5, v4);
      return sub_811C9C0(v1, a1);
    }
    a1[31] = v22;
    sub_80DEB7A((int)&v14, (int)&v19, s, (int)&v13);
    sub_811CF36(a1, &v13);
    if ( s < 1.0 )
    {
      sub_8105DE2(&v21, &v9);
      sub_80A2EC2((float *)a1 + 81, (int)&v7, 0, 0);
      sub_80A1ED8((float *)&v9, (float *)&v7, (float *)&v8);
      sub_80A1ED8((float *)&v8, (float *)&v9, (float *)&v7);
      sub_80A71F4((int)&v7, (int)&v10);
      if ( dword_8164C3C[11 * a1[35]] == 1 )
        v11 = v11 + 90.0;
      sub_811CF96(a1, &v10);
    }
  }
  return sub_809A45E((int)a1);
}

//----- (08104A02) --------------------------------------------------------
void *sub_8104A02()
{
  void *result; // eax

  result = memset(dword_859B000, 0, 0x400u);
  dword_859B000[0] = 1;
  return result;
}
// 859B000: using guessed type int dword_859B000[];

//----- (08104A30) --------------------------------------------------------
int sub_8104A30()
{
  char **v1; // [esp+18h] [ebp-2010h]
  signed int i; // [esp+1Ch] [ebp-200Ch]
  char s1; // [esp+20h] [ebp-2008h]

  dword_859E9FC = 0;
  s1 = 0;
  v1 = 0;
  for ( i = 1; i <= sub_80E9322(); ++i )
  {
    if ( v1 )
      sub_80B57C0(&s1, 0x2000, " ");
    v1 = (char **)sub_80E9270(i);
    sub_80B57C0(&s1, 0x2000, *v1);
  }
  return sub_8090E6C(7, &s1);
}
// 859E9FC: using guessed type int dword_859E9FC;

//----- (08104AEC) --------------------------------------------------------
int sub_8104AEC()
{
  char v1; // [esp+13h] [ebp-135h]
  char *v2; // [esp+14h] [ebp-134h]
  char v3; // [esp+1Bh] [ebp-12Dh]
  char *v4; // [esp+1Ch] [ebp-12Ch]
  int v5; // [esp+20h] [ebp-128h]
  signed int v6; // [esp+24h] [ebp-124h]
  int v7; // [esp+28h] [ebp-120h]
  signed int i; // [esp+2Ch] [ebp-11Ch]
  char s1[272]; // [esp+30h] [ebp-118h]
  char v10[8]; // [esp+140h] [ebp-8h]

  dword_859EA00 = 0;
  v7 = 0;
  v6 = 0;
  v5 = 0;
  for ( i = 0; i < 131; ++i )
  {
    if ( dword_859B000[i] )
      v6 += 1 << v5;
    if ( ++v5 == 4 )
    {
      v4 = &v10[v7++ - 272];
      if ( v6 > 9 )
        v3 = v6 + 87;
      else
        v3 = v6 + 48;
      *v4 = v3;
      v6 = 0;
      v5 = 0;
    }
  }
  if ( v5 )
  {
    v2 = &v10[v7++ - 272];
    if ( v6 > 9 )
      v1 = v6 + 87;
    else
      v1 = v6 + 48;
    *v2 = v1;
  }
  s1[v7] = 0;
  return sub_8090E6C(8, s1);
}
// 859B000: using guessed type int dword_859B000[];
// 859EA00: using guessed type int dword_859EA00;
// 8104AEC: using guessed type char var_8[8];
// 8104AEC: using guessed type char s1[272];

//----- (08104C84) --------------------------------------------------------
int __cdecl sub_8104C84(int a1, int a2)
{
  int result; // eax
  char *v3; // eax
  const char *v4; // [esp+14h] [ebp-4h]

  result = a1;
  if ( !dword_859B000[a1] )
  {
    if ( !dword_859B41C )
    {
      v4 = (const char *)dword_8164C34[11 * a1];
      if ( !v4 || !*v4 )
        v4 = "<<unknown>>";
      v3 = va("game tried to register the item '%s' after initialization finished\n", v4);
      sub_8084DB4((int)v3);
    }
    dword_859B000[a1] = 1;
    if ( dword_8164C28[11 * a1] )
      sub_811B00C((char *)dword_8164C28[11 * a1]);
    result = 44 * a1;
    if ( dword_8164C2C[11 * a1] )
      result = sub_811B00C((char *)dword_8164C2C[11 * a1]);
    if ( a2 )
      dword_859EA00 = 1;
  }
  return result;
}
// 8164C28: using guessed type int dword_8164C28[];
// 8164C2C: using guessed type int dword_8164C2C[];
// 8164C34: using guessed type int dword_8164C34[];
// 859B000: using guessed type int dword_859B000[];
// 859EA00: using guessed type int dword_859EA00;

//----- (08104D86) --------------------------------------------------------
int __cdecl sub_8104D86(int a1)
{
  char **v2; // [esp+10h] [ebp-8h]
  int v3; // [esp+14h] [ebp-4h]

  dword_859B000[a1] = 1;
  dword_859EA00 = 1;
  dword_859E9FC = 1;
  v2 = (char **)sub_80E9270(a1);
  if ( *v2[347] && !sub_810FFAA((int)(v2 + 349), v2[347]) )
    Com_Error(1, &byte_8153420, 32);
  if ( *v2[348] && !sub_810FFAA((int)(v2 + 350), v2[348]) )
    Com_Error(1, &byte_8153420, 32);
  v3 = sub_811B00C(v2[109]);
  if ( v3 && sub_811B108(v3) )
    sub_811B422(v3, "xmodel/defaultweapon");
  return sub_811B00C(v2[227]);
}
// 859B000: using guessed type int dword_859B000[];
// 859E9FC: using guessed type int dword_859E9FC;
// 859EA00: using guessed type int dword_859EA00;

//----- (08104EA2) --------------------------------------------------------
int __cdecl sub_8104EA2(int a1)
{
  return dword_859B000[a1];
}
// 859B000: using guessed type int dword_859B000[];

//----- (08104EB2) --------------------------------------------------------
int __usercall sub_8104EB2@<eax>(long double a1@<st0>, int a2, int a3)
{
  int result; // eax

  sub_8104C84(-1171354717 * ((a3 - (signed int)&unk_8164C20) >> 2), 0);
  *(_WORD *)(a2 + 428) = -29789 * ((a3 - (signed int)&unk_8164C20) >> 2);
  sub_811B3EA(a2, *(char **)(a3 + 8));
  if ( *(_DWORD *)(a3 + 28) == 1 )
  {
    sub_8105DBE((_DWORD *)(a2 + 260), -1082130432, -1082130432, -1082130432);
    sub_8105DBE((_DWORD *)(a2 + 272), 1065353216, 1065353216, 1065353216);
  }
  else
  {
    sub_8105DBE((_DWORD *)(a2 + 260), -1082130432, -1082130432, 0);
    sub_8105DBE((_DWORD *)(a2 + 272), 1065353216, 1065353216, 0x40000000);
  }
  *(_DWORD *)(a2 + 284) = 1079771400;
  if ( *(_DWORD *)(a3 + 28) != 2 )
    *(_DWORD *)(a2 + 284) |= 0x200000u;
  *(_DWORD *)(a2 + 4) = 3;
  *(_DWORD *)(a2 + 140) = *(unsigned __int16 *)(a2 + 428);
  sub_811B20E(a1, a2);
  *(_DWORD *)(a2 + 144) = 1022;
  *(_DWORD *)(a2 + 372) |= 0x1000u;
  if ( byte_859C748 )
  {
    sub_811CF96((_DWORD *)a2, (_DWORD *)(a2 + 324));
    *(_DWORD *)(a2 + 400) = dword_859B5EC + 100;
    result = a2;
    *(_BYTE *)(a2 + 358) = 16;
  }
  else
  {
    *(_BYTE *)(a2 + 358) = 17;
    if ( (*(_BYTE *)(a2 + 368) ^ 1) & 1 )
    {
      *(_DWORD *)(a2 + 124) = 1023;
      if ( *(_DWORD *)(a3 + 28) == 1 )
        *(float *)(a2 + 332) = *(float *)(a2 + 332) + 90.0;
    }
    sub_811CF96((_DWORD *)a2, (_DWORD *)(a2 + 324));
    sub_811CF36((_DWORD *)a2, (_DWORD *)(a2 + 312));
    result = sub_809A45E(a2);
  }
  return result;
}
// 859C748: using guessed type char byte_859C748;

//----- (081050FE) --------------------------------------------------------
int __cdecl sub_81050FE(int a1, int a2, int a3, _DWORD *a4)
{
  int result; // eax
  char v5; // [esp+10h] [ebp-48h]
  char v6; // [esp+20h] [ebp-38h]
  int v7; // [esp+2Ch] [ebp-2Ch]
  int v8; // [esp+38h] [ebp-20h]

  sub_8105D94((_DWORD *)(a1 + 36));
  if ( *(_BYTE *)(a3 + 34) || *(float *)(a3 + 12) > 0.0 )
  {
    *(_BYTE *)(a2 + 1220) = 0;
    *(_DWORD *)(a1 + 12) = 1;
    sub_8105DE2(a4, (_DWORD *)(a1 + 24));
    *(_DWORD *)(a1 + 16) = 0;
    *(_DWORD *)(a1 + 20) = 0;
    sub_8105D94((_DWORD *)(a1 + 36));
    *(_DWORD *)(a1 + 124) = *(unsigned __int16 *)(a3 + 28);
    if ( *(_BYTE *)(a3 + 34) )
    {
      sub_811CF96((_DWORD *)a1, (_DWORD *)(a1 + 324));
    }
    else
    {
      sub_8105DE2((_DWORD *)(a3 + 4), &v8);
      sub_80A2EC2((float *)(a1 + 324), (int)&v6, 0, 0);
      sub_80A1ED8((float *)&v8, (float *)&v6, (float *)&v7);
      sub_80A1ED8((float *)&v7, (float *)&v8, (float *)&v6);
      sub_80A71F4((int)&v6, (int)&v5);
      sub_811CF96((_DWORD *)a1, &v5);
    }
    result = sub_809A45E(a1);
  }
  else
  {
    sub_8105E12((float *)(a1 + 312), (float *)(a3 + 4), (float *)(a1 + 312));
    sub_8105DE2((_DWORD *)(a1 + 312), (_DWORD *)(a1 + 24));
    result = dword_859B5EC;
    *(_DWORD *)(a1 + 16) = dword_859B5EC;
  }
  return result;
}

//----- (081052AA) --------------------------------------------------------
int __cdecl sub_81052AA(int a1, int a2)
{
  char v3; // [esp+10h] [ebp-48h]
  float v4; // [esp+18h] [ebp-40h]
  char v5; // [esp+20h] [ebp-38h]
  int v6; // [esp+2Ch] [ebp-2Ch]
  int v7; // [esp+38h] [ebp-20h]

  sub_8105DE2((_DWORD *)(a2 + 4), &v7);
  sub_80A2EC2((float *)(a1 + 324), (int)&v5, 0, 0);
  sub_80A1ED8((float *)&v7, (float *)&v5, (float *)&v6);
  sub_80A1ED8((float *)&v6, (float *)&v7, (float *)&v5);
  sub_80A71F4((int)&v5, (int)&v3);
  if ( dword_8164C3C[11 * *(_DWORD *)(a1 + 140)] == 1 )
    v4 = v4 + 90.0;
  return sub_811CF96((_DWORD *)a1, &v3);
}

//----- (08105382) --------------------------------------------------------
int __cdecl sub_8105382(int a1, int *a2, _DWORD *a3)
{
  char v4; // [esp+20h] [ebp-18h]

  return sub_80BEF2C(*a2, 0, &v4, a3, 1);
}

//----- (081053B6) --------------------------------------------------------
float *__cdecl sub_81053B6(float *a1)
{
  float *result; // eax
  int v2; // eax
  char v3; // [esp+2Eh] [ebp-CAh]
  int v4; // [esp+30h] [ebp-C8h]
  int v5; // [esp+40h] [ebp-B8h]
  int v6; // [esp+50h] [ebp-A8h]
  float v7; // [esp+60h] [ebp-98h]
  float v8; // [esp+64h] [ebp-94h]
  int v9; // [esp+78h] [ebp-80h]
  int v10; // [esp+7Ch] [ebp-7Ch]
  int v11; // [esp+80h] [ebp-78h]
  float v12; // [esp+88h] [ebp-70h]
  int v13; // [esp+90h] [ebp-68h]
  int v14; // [esp+A8h] [ebp-50h]
  int v15; // [esp+ACh] [ebp-4Ch]
  float s; // [esp+B0h] [ebp-48h]
  char v17; // [esp+D2h] [ebp-26h]
  char v18; // [esp+D3h] [ebp-25h]
  int v19; // [esp+E0h] [ebp-18h]
  float v20; // [esp+E8h] [ebp-10h]

  v10 = sub_811C830(a1);
  v9 = 1224 * v10 + 142202936;
  sub_8105382((int)a1, (int *)v9, &v7);
  v3 = 0;
  if ( !*(_BYTE *)(v9 + 1220) && sub_8105FB6(&v7) > 1.0 )
    v3 = 1;
  result = (float *)v9;
  if ( *(_BYTE *)(v9 + 1220) || v3 )
  {
    sub_80DCEB0((int)(a1 + 3), dword_859B5EC, (int)&v19);
    if ( v3 )
    {
      sub_80A2EC2(a1 + 81, (int)&v6, (float *)&v5, 0);
      sub_8105EF6((int)&v5, -1.0, (int)&v4);
      sub_80A20C0((float *)&v6);
      sub_80A20C0((float *)&v4);
      sub_8105F2E((int)&v19, v7, (int)&v6, (int)&v19);
      sub_8105F2E((int)&v19, v8, (int)&v4, (int)&v19);
    }
    v14 = *((_DWORD *)a1 + 97);
    sub_8108090(&s, (int)(a1 + 78), (int)(a1 + 65), (int)(a1 + 68), (int)&v19, *((_DWORD *)a1 + 84), v14);
    sub_80DEB7A((int)(a1 + 78), (int)&v19, s, (int)&v13);
    sub_8105DE2(&v13, (_DWORD *)a1 + 78);
    if ( v18 )
      s = 0.0;
    sub_809A45E((int)a1);
    sub_81079C8((int)a1);
    result = a1;
    if ( *((_BYTE *)a1 + 252) )
    {
      if ( s == 1.0 )
      {
        result = (float *)v9;
        if ( !*(_BYTE *)(v9 + 1220) )
        {
          if ( v3 )
          {
            *((_DWORD *)a1 + 3) = 1;
            sub_8105DE2(&v13, (_DWORD *)a1 + 6);
            a1[4] = 0.0;
            a1[5] = 0.0;
            sub_8105D94((_DWORD *)a1 + 9);
            v20 = v20 - 1.0;
            result = (float *)sub_81080E6(a1 + 78, a1 + 65, a1 + 68, (float *)&v19, *((_DWORD *)a1 + 84), v14);
            if ( result )
            {
              *(_BYTE *)(v9 + 1220) = 1;
              *((_DWORD *)a1 + 3) = 5;
              sub_8105DE2(&v13, (_DWORD *)a1 + 6);
              sub_8105D94((_DWORD *)a1 + 9);
              sub_8105F2E((int)(a1 + 9), v7, (int)&v6, (int)(a1 + 9));
              sub_8105F2E((int)(a1 + 9), v8, (int)&v4, (int)(a1 + 9));
              *((_DWORD *)a1 + 4) = dword_859B5EC;
              result = a1;
              a1[5] = 0.0;
            }
          }
        }
      }
      else
      {
        v2 = sub_809C18C(a1 + 78, -1, 2147483648);
        v15 = v2;
        if ( v2 )
        {
          result = (float *)sub_811C9C0(1.0, a1);
        }
        else
        {
          result = (float *)v9;
          if ( *(_BYTE *)(v9 + 1220) )
          {
            if ( v17 )
            {
              sub_8105DE2((_DWORD *)a1 + 78, &v11);
              v12 = v12 + 64.0;
              sub_8108090(
                &s,
                (int)&v11,
                (int)(a1 + 65),
                (int)(a1 + 68),
                (int)(a1 + 78),
                *((_DWORD *)a1 + 84),
                v14 & 0xFFFEFFFF);
              if ( !v17 )
              {
                sub_80DEB7A((int)&v11, (int)(a1 + 78), s, (int)&v13);
                sub_8105DE2(&v13, (_DWORD *)a1 + 78);
              }
            }
            result = (float *)sub_81050FE((int)a1, v9, (int)&s, &v13);
          }
        }
      }
    }
  }
  return result;
}

//----- (081058A0) --------------------------------------------------------
int __cdecl sub_81058A0(int *a1)
{
  int v1; // eax
  int result; // eax
  int v3; // [esp+1Ch] [ebp-Ch]

  v3 = 1224 * sub_811C830(a1) + 142202936;
  v1 = sub_806289C(*a1);
  sub_80D978C(v1, a1, v3 + 12, 0);
  result = sub_806289C(*a1);
  if ( result )
    result = sub_80D9698(result, a1, (signed int *)(v3 + 12));
  return result;
}

//----- (0810592C) --------------------------------------------------------
int __cdecl sub_810592C(float *a1)
{
  sub_81053B6(a1);
  sub_81058A0((int *)a1);
  return sub_81079C8((int)a1);
}

//----- (08105956) --------------------------------------------------------
void __cdecl sub_8105956(_DWORD *a1)
{
  long double v1; // fst7
  char v2; // [esp+20h] [ebp-88h]
  float v3; // [esp+3Ch] [ebp-6Ch]
  int v4; // [esp+40h] [ebp-68h]
  int v5; // [esp+58h] [ebp-50h]
  int v6; // [esp+5Ch] [ebp-4Ch]
  float s; // [esp+60h] [ebp-48h]
  int v8; // [esp+64h] [ebp-44h]
  float v9; // [esp+6Ch] [ebp-3Ch]
  unsigned __int16 v10; // [esp+7Ch] [ebp-2Ch]
  char v11; // [esp+83h] [ebp-25h]
  int v12; // [esp+90h] [ebp-18h]
  float v13; // [esp+98h] [ebp-10h]

  if ( (a1[31] == 1023 || *(_DWORD *)(dword_859B404 + 560 * a1[31] + 12))
    && a1[3] != 5
    && (*((_BYTE *)a1 + 368) ^ 1) & 1 )
  {
    a1[3] = 5;
    a1[4] = dword_859B5EC;
    sub_8105DE2(a1 + 78, a1 + 6);
    sub_8105D94(a1 + 9);
  }
  if ( a1[3] && a1[3] != 6 && !a1[130] )
  {
    sub_80DCEB0((int)(a1 + 3), dword_859B5EC + 50, (int)&v12);
    v5 = sub_8105FEA((int)a1);
    if ( sub_80A1DB2((float *)a1 + 78, (float *)&v12) < 0.1 )
      v13 = v13 - 1.0;
    sub_8108090(&s, (int)(a1 + 78), (int)(a1 + 65), (int)(a1 + 68), (int)&v12, a1[84], v5);
    if ( s >= 1.0 )
    {
      sub_8105DE2(&v12, a1 + 78);
    }
    else
    {
      sub_80DEB7A((int)(a1 + 78), (int)&v12, s, (int)&v4);
      if ( !v11 && s < 0.0099999998 && v9 < 0.5 )
      {
        sub_8105E56((float *)&v12, (float *)a1 + 78, (float *)&v2);
        v3 = 1.0 - sub_8105F82((float *)&v2, (float *)&v8);
        sub_8105F2E((int)&v12, v3, (int)&v8, (int)&v12);
        sub_8108090(&s, (int)&v4, (int)(a1 + 65), (int)(a1 + 68), (int)&v12, a1[84], v5);
        sub_80DEB7A((int)&v4, (int)&v12, s, (int)&v4);
      }
      a1[3] = 3;
      a1[4] = dword_859B5EC;
      a1[5] = 50;
      sub_8105DE2(a1 + 78, a1 + 6);
      sub_8105E56((float *)&v4, (float *)a1 + 78, (float *)a1 + 9);
      sub_8105EF6((int)(a1 + 9), 20.0, (int)(a1 + 9));
      sub_8105DE2(&v4, a1 + 78);
    }
    sub_809A45E((int)a1);
    sub_81079C8((int)a1);
    if ( *((_BYTE *)a1 + 252) && s < 0.0099999998 )
    {
      v1 = v9;
      if ( v9 > 0.0 )
      {
        v6 = sub_809C18C((float *)a1 + 78, -1, 2147483648);
        if ( v6 )
        {
          sub_811C9C0(v1, a1);
        }
        else
        {
          sub_81052AA((int)a1, (int)&s);
          sub_811CF36(a1, &v4);
          a1[31] = v10;
          sub_809A45E((int)a1);
        }
      }
      else
      {
        sub_811C9C0(v1, a1);
      }
    }
  }
  else
  {
    sub_81079C8((int)a1);
  }
}
// 859B404: using guessed type int dword_859B404;

//----- (08105D5E) --------------------------------------------------------
int __cdecl sub_8105D5E(float a1)
{
  return (signed int)floor(a1 + 0.5);
}

//----- (08105D94) --------------------------------------------------------
int __cdecl sub_8105D94(_DWORD *a1)
{
  int result; // eax

  *a1 = 0;
  a1[1] = 0;
  result = 0;
  a1[2] = 0;
  return result;
}

//----- (08105DBE) --------------------------------------------------------
int __cdecl sub_8105DBE(_DWORD *a1, int a2, int a3, int a4)
{
  int result; // eax

  *a1 = a2;
  a1[1] = a3;
  result = a4;
  a1[2] = a4;
  return result;
}

//----- (08105DE2) --------------------------------------------------------
int __cdecl sub_8105DE2(_DWORD *a1, _DWORD *a2)
{
  int result; // eax

  *a2 = *a1;
  a2[1] = a1[1];
  result = a1[2];
  a2[2] = result;
  return result;
}

//----- (08105E12) --------------------------------------------------------
int __cdecl sub_8105E12(float *a1, float *a2, float *a3)
{
  int result; // eax

  *a3 = *a1 + *a2;
  a3[1] = a1[1] + a2[1];
  result = (int)(a1 + 2);
  a3[2] = a1[2] + a2[2];
  return result;
}

//----- (08105E56) --------------------------------------------------------
int __cdecl sub_8105E56(float *a1, float *a2, float *a3)
{
  int result; // eax

  *a3 = *a1 - *a2;
  a3[1] = a1[1] - a2[1];
  result = (int)(a1 + 2);
  a3[2] = a1[2] - a2[2];
  return result;
}

//----- (08105E9A) --------------------------------------------------------
int __cdecl sub_8105E9A(float *a1, float *a2, float *a3)
{
  int result; // eax

  *a3 = (*a1 + *a2) * 0.5;
  a3[1] = (a1[1] + a2[1]) * 0.5;
  result = (int)(a1 + 2);
  a3[2] = (a1[2] + a2[2]) * 0.5;
  return result;
}

//----- (08105EF6) --------------------------------------------------------
int __cdecl sub_8105EF6(int a1, float a2, int a3)
{
  int result; // eax

  *(float *)a3 = a2 * *(float *)a1;
  *(float *)(a3 + 4) = a2 * *(float *)(a1 + 4);
  result = a1 + 8;
  *(float *)(a3 + 8) = a2 * *(float *)(a1 + 8);
  return result;
}

//----- (08105F2E) --------------------------------------------------------
int __cdecl sub_8105F2E(int a1, float a2, int a3, int a4)
{
  int result; // eax

  *(float *)a4 = a2 * *(float *)a3 + *(float *)a1;
  *(float *)(a4 + 4) = a2 * *(float *)(a3 + 4) + *(float *)(a1 + 4);
  result = a3 + 8;
  *(float *)(a4 + 8) = a2 * *(float *)(a3 + 8) + *(float *)(a1 + 8);
  return result;
}

//----- (08105F82) --------------------------------------------------------
long double __cdecl sub_8105F82(float *a1, float *a2)
{
  return *a1 * *a2 + a1[1] * a2[1] + a1[2] * a2[2];
}

//----- (08105FB6) --------------------------------------------------------
long double __cdecl sub_8105FB6(float *a1)
{
  return *a1 * *a1 + a1[1] * a1[1] + a1[2] * a1[2];
}

//----- (08105FEA) --------------------------------------------------------
signed int __cdecl sub_8105FEA(int a1)
{
  signed int v2; // [esp+0h] [ebp-4h]

  v2 = *(_DWORD *)(a1 + 388);
  if ( !*(_DWORD *)(a1 + 388) )
    v2 = 1169;
  return v2;
}

//----- (08106014) --------------------------------------------------------
char *__usercall sub_8106014@<eax>(long double a1@<st0>)
{
  dword_8793D98 = (int)Dvar_RegisterBool(a1, "sv_cheats", 0, 4096);
  Dvar_RegisterString(a1, "gamename", (int)"Call of Duty 2", 4164);
  Dvar_RegisterString(a1, "gamedate", (int)"Oct 24 2005", 4160);
  Dvar_RegisterString(a1, "sv_mapname", (int)&byte_81534F7, 4164);
  dword_8793D80 = (int)Dvar_RegisterString(a1, "g_gametype", (int)"dm", 4132);
  dword_8793D88 = (int)Dvar_RegisterInt(a1, "sv_maxclients", 20, 1, 64, 4133);
  dword_8793DC0 = (int)Dvar_RegisterBool(a1, "g_synchronousClients", 0, 4104);
  dword_8793DEC = (int)Dvar_RegisterString(a1, "g_log", (int)"games_mp.log", 4097);
  dword_8793DF0 = (int)Dvar_RegisterBool(a1, "g_logSync", 0, 4097);
  dword_8793D84 = (int)Dvar_RegisterString(a1, "g_password", (int)&byte_81534F7, 4096);
  dword_8793E04 = (int)Dvar_RegisterString(a1, "g_banIPs", (int)&byte_81534F7, 4097);
  dword_8793D8C = (int)Dvar_RegisterInt(a1, "dedicated", 0, 0, 2, 4128);
  if ( *(_DWORD *)(dword_8793D8C + 8) )
    Dvar_RegisterInt(a1, "dedicated", 0, 0, 2, 4160);
  dword_8793D90 = (int)Dvar_RegisterInt(a1, "g_speed", 190, 2147483648, 0x7FFFFFFF, 4096);
  dword_8793D94 = (int)Dvar_RegisterFloat(a1, "g_gravity", 1145569280, 1065353216, 2139095039, 4096);
  dword_8793D9C = (int)Dvar_RegisterFloat(a1, "g_knockback", 1148846080, -8388609, 2139095039, 4096);
  dword_8793DB4 = (int)Dvar_RegisterBool(a1, "g_weaponAmmoPools", 0, 4096);
  dword_8793DB8 = (int)Dvar_RegisterInt(a1, "g_maxDroppedWeapons", 16, 1, 32, 4096);
  dword_8793DA8 = (int)Dvar_RegisterInt(a1, "g_inactivity", 0, 0, 0x7FFFFFFF, 4096);
  dword_8793DAC = (int)Dvar_RegisterBool(a1, "g_debugDamage", 0, 4224);
  dword_8793DB0 = (int)Dvar_RegisterInt(a1, "g_debugBullets", 0, -3, 6, 4224);
  dword_8793DBC = (int)Dvar_RegisterString(a1, "g_motd", (int)&byte_81534F7, 4096);
  dword_8793DC4 = (int)Dvar_RegisterInt(a1, "g_playerCollisionEjectSpeed", 25, 0, 32000, 4097);
  dword_8793DC8 = (int)Dvar_RegisterFloat(a1, "g_dropForwardSpeed", 1092616192, 0, 1148846080, 4097);
  dword_8793DCC = (int)Dvar_RegisterFloat(a1, "g_dropUpSpeedBase", 1092616192, 0, 1148846080, 4097);
  dword_8793DD0 = (int)Dvar_RegisterFloat(a1, "g_dropUpSpeedRand", 1084227584, 0, 1148846080, 4097);
  dword_8793DD4 = (int)Dvar_RegisterFloat(a1, "g_clonePlayerMaxVelocity", 1117782016, 0, 2139095039, 4097);
  dword_8793DE0 = (int)Dvar_RegisterBool(a1, "voice_global", 0, 4097);
  dword_8793DDC = (int)Dvar_RegisterBool(a1, "voice_localEcho", 0, 4097);
  dword_8793DE4 = (int)Dvar_RegisterBool(a1, "voice_deadChat", 0, 4097);
  dword_8793DF4 = (int)Dvar_RegisterBool(a1, "g_allowVote", 1, 4096);
  dword_8793E00 = (int)Dvar_RegisterBool(a1, "g_listEntity", 0, 4096);
  dword_8793DFC = (int)Dvar_RegisterBool(a1, "g_deadChat", 0, 4097);
  dword_8793DE8 = (int)Dvar_RegisterInt(a1, "g_voiceChatTalkingDuration", 500, 0, 10000, 4097);
  dword_8793E10 = (int)Dvar_RegisterString(a1, "g_ScoresBanner_Allies", (int)"mpflag_american", 4352);
  dword_8793E14 = (int)Dvar_RegisterString(a1, "g_ScoresBanner_Axis", (int)"mpflag_german", 4352);
  dword_8793E18 = (int)Dvar_RegisterString(a1, "g_ScoresBanner_None", (int)"mpflag_none", 4352);
  dword_8793E1C = (int)Dvar_RegisterString(a1, "g_ScoresBanner_Spectators", (int)"mpflag_spectator", 4352);
  dword_8793E20 = (int)Dvar_RegisterString(a1, "g_TeamName_Allies", (int)"GAME_ALLIES", 4352);
  dword_8793E24 = (int)Dvar_RegisterString(a1, "g_TeamName_Axis", (int)"GAME_AXIS", 4352);
  dword_8793E28 = (int)sub_80B1EA0(a1, "g_TeamColor_Allies", 0.5, 0.5, 1.0, 1.0, 4352);
  dword_8793E2C = (int)sub_80B1EA0(a1, "g_TeamColor_Axis", 1.0, 0.5, 0.5, 1.0, 4352);
  dword_8793E0C = (int)Dvar_RegisterBool(a1, "g_smoothClients", 1, 4096);
  dword_8793E4C = (int)Dvar_RegisterBool(a1, "g_antilag", 1, 4101);
  dword_8793E50 = (int)Dvar_RegisterBool(a1, "g_oldVoting", 1, 4097);
  dword_8793E54 = (int)Dvar_RegisterFloat(a1, "g_voteAbstainWeight", 1056964608, 0, 1065353216, 4097);
  dword_8793E30 = (int)Dvar_RegisterBool(a1, "g_no_script_spam", 0, 4096);
  dword_8793E34 = (int)Dvar_RegisterBool(a1, "g_debugLocDamage", 0, 4224);
  dword_8793E38 = (int)Dvar_RegisterFloat(a1, "g_friendlyfireDist", 1132462080, 0, 1181376512, 4224);
  dword_8793E3C = (int)Dvar_RegisterFloat(a1, "g_friendlyNameDist", 1181376512, 0, 1181376512, 4224);
  dword_8793E40 = (int)Dvar_RegisterFloat(a1, "player_meleeRange", 1115684864, 0, 1148846080, 4224);
  dword_8793E44 = (int)Dvar_RegisterFloat(a1, "player_meleeWidth", 1092616192, 0, 1148846080, 4224);
  dword_8793E48 = (int)Dvar_RegisterFloat(a1, "player_meleeHeight", 1092616192, 0, 1148846080, 4224);
  dword_8793E58 = (int)Dvar_RegisterInt(a1, "g_dumpAnims", -1, -1, 1023, 4224);
  dword_8793DA0 = (int)Dvar_RegisterInt(a1, "g_useholdtime", 0, 0, 0x7FFFFFFF, 4096);
  dword_8793DA4 = (int)Dvar_RegisterInt(a1, "g_useholdspawndelay", 1, 0, 10, 4225);
  dword_8793DD8 = (int)Dvar_RegisterInt(a1, "g_mantleBlockTimeBuffer", 500, 0, 60000, 4224);
  return sub_80DC10C(a1);
}
// 8793D80: using guessed type int dword_8793D80;
// 8793D84: using guessed type int dword_8793D84;
// 8793D88: using guessed type int dword_8793D88;
// 8793D8C: using guessed type int dword_8793D8C;
// 8793D90: using guessed type int dword_8793D90;
// 8793D94: using guessed type int dword_8793D94;
// 8793D98: using guessed type int dword_8793D98;
// 8793D9C: using guessed type int dword_8793D9C;
// 8793DA0: using guessed type int dword_8793DA0;
// 8793DA4: using guessed type int dword_8793DA4;
// 8793DA8: using guessed type int dword_8793DA8;
// 8793DAC: using guessed type int dword_8793DAC;
// 8793DB0: using guessed type int dword_8793DB0;
// 8793DB4: using guessed type int dword_8793DB4;
// 8793DB8: using guessed type int dword_8793DB8;
// 8793DBC: using guessed type int dword_8793DBC;
// 8793DC0: using guessed type int dword_8793DC0;
// 8793DC4: using guessed type int dword_8793DC4;
// 8793DC8: using guessed type int dword_8793DC8;
// 8793DCC: using guessed type int dword_8793DCC;
// 8793DD0: using guessed type int dword_8793DD0;
// 8793DD4: using guessed type int dword_8793DD4;
// 8793DD8: using guessed type int dword_8793DD8;
// 8793DDC: using guessed type int dword_8793DDC;
// 8793DE0: using guessed type int dword_8793DE0;
// 8793DE4: using guessed type int dword_8793DE4;
// 8793DE8: using guessed type int dword_8793DE8;
// 8793DEC: using guessed type int dword_8793DEC;
// 8793DF0: using guessed type int dword_8793DF0;
// 8793DF4: using guessed type int dword_8793DF4;
// 8793DFC: using guessed type int dword_8793DFC;
// 8793E00: using guessed type int dword_8793E00;
// 8793E0C: using guessed type int dword_8793E0C;
// 8793E10: using guessed type int dword_8793E10;
// 8793E14: using guessed type int dword_8793E14;
// 8793E18: using guessed type int dword_8793E18;
// 8793E1C: using guessed type int dword_8793E1C;
// 8793E20: using guessed type int dword_8793E20;
// 8793E24: using guessed type int dword_8793E24;
// 8793E28: using guessed type int dword_8793E28;
// 8793E2C: using guessed type int dword_8793E2C;
// 8793E30: using guessed type int dword_8793E30;
// 8793E34: using guessed type int dword_8793E34;
// 8793E38: using guessed type int dword_8793E38;
// 8793E3C: using guessed type int dword_8793E3C;
// 8793E40: using guessed type int dword_8793E40;
// 8793E44: using guessed type int dword_8793E44;
// 8793E48: using guessed type int dword_8793E48;
// 8793E4C: using guessed type int dword_8793E4C;
// 8793E50: using guessed type int dword_8793E50;
// 8793E54: using guessed type int dword_8793E54;
// 8793E58: using guessed type int dword_8793E58;

//----- (0810695E) --------------------------------------------------------
int sub_810695E()
{
  return dword_859D154;
}
// 859D154: using guessed type int dword_859D154;

//----- (08106968) --------------------------------------------------------
int __cdecl sub_8106968(int a1)
{
  int result; // eax

  result = a1;
  dword_859D154 = a1;
  return result;
}
// 859D154: using guessed type int dword_859D154;

//----- (08106976) --------------------------------------------------------
long double sub_8106976()
{
  return *(float *)&dword_859D1DC;
}
// 859D1DC: using guessed type int dword_859D1DC;

//----- (0810698A) --------------------------------------------------------
int __cdecl sub_810698A(int a1)
{
  return *(_DWORD *)(dword_859B400 + 10404 * a1 + 9912);
}
// 859B400: using guessed type int dword_859B400;

//----- (081069A6) --------------------------------------------------------
int __cdecl sub_81069A6(int a1)
{
  return *(_DWORD *)(dword_859B400 + 10404 * a1 + 9908);
}
// 859B400: using guessed type int dword_859B400;

//----- (081069C2) --------------------------------------------------------
int __cdecl sub_81069C2(int a1, int a2)
{
  int result; // eax

  result = a2;
  *(_DWORD *)(dword_859B400 + 10404 * a1 + 9908) = a2;
  return result;
}
// 859B400: using guessed type int dword_859B400;

//----- (081069E2) --------------------------------------------------------
int __cdecl sub_81069E2(int a1)
{
  return dword_859B400 + 10404 * a1 + 10056;
}
// 859B400: using guessed type int dword_859B400;

//----- (081069FC) --------------------------------------------------------
int __usercall sub_81069FC@<eax>(long double a1@<st0>)
{
  int result; // eax
  _BYTE *s; // [esp+10h] [ebp-8h]
  int v3; // [esp+14h] [ebp-4h]

  s = &unk_8665480;
  v3 = 0;
  while ( 1 )
  {
    result = v3;
    if ( v3 >= *(_DWORD *)dword_859B40C )
      break;
    if ( s[252] )
      sub_811C9C0(a1, s);
    ++v3;
    s += 560;
  }
  if ( byte_86F111C )
    result = sub_811C9C0(a1, &dword_86F1020);
  *(_DWORD *)dword_859B40C = 0;
  dword_859B410 = 0;
  dword_859B414 = 0;
  return result;
}
// 859B410: using guessed type int dword_859B410;
// 859B414: using guessed type int dword_859B414;
// 86F1020: using guessed type int dword_86F1020;
// 86F111C: using guessed type char byte_86F111C;

//----- (08106A7C) --------------------------------------------------------
int __cdecl sub_8106A7C(signed __int16 ***a1, unsigned __int16 a2, int a3, int a4)
{
  return sub_8062A66(a1, a2, a3, a4);
}

//----- (08106AAC) --------------------------------------------------------
int *sub_8106AAC()
{
  int *result; // eax
  int v1; // ebx
  int v2; // ebx
  int v3; // [esp+Ch] [ebp-Ch]
  int i; // [esp+10h] [ebp-8h]

  result = (int *)dword_8652608;
  v3 = dword_8652608;
  for ( i = 0; i <= 63; ++i )
  {
    v1 = 302 * i;
    dword_8652AE0[v1] = (int)sub_80BA7E4(v3, (int (__cdecl *)(int))sub_8106BF2);
    result = &i;
  }
  for ( i = 0; i <= 7; ++i )
  {
    v2 = 306 * i;
    dword_879D838[v2] = (int)sub_80BA7E4(v3, (int (__cdecl *)(int))sub_8106BF2);
    result = &i;
  }
  return result;
}
// 8652608: using guessed type int dword_8652608;
// 879D838: using guessed type int dword_879D838[];

//----- (08106B36) --------------------------------------------------------
int *sub_8106B36()
{
  int *result; // eax
  int i; // [esp+14h] [ebp-4h]

  for ( i = 0; i <= 63; ++i )
  {
    if ( dword_8652AE0[302 * i] )
    {
      sub_80BA836((_DWORD *)dword_8652AE0[302 * i], 0);
      dword_8652AE0[302 * i] = 0;
    }
    result = &i;
  }
  for ( i = 0; i <= 7; ++i )
  {
    if ( dword_879D838[306 * i] )
    {
      sub_80BA836((_DWORD *)dword_879D838[306 * i], 0);
      dword_879D838[306 * i] = 0;
    }
    result = &i;
  }
  return result;
}
// 879D838: using guessed type int dword_879D838[];

//----- (08106BF2) --------------------------------------------------------
void *__cdecl sub_8106BF2(size_t a1)
{
  return sub_80A9DC4(a1);
}

//----- (08106C06) --------------------------------------------------------
int __usercall sub_8106C06@<eax>(long double a1@<st0>, int a2, unsigned int seed, int a4, int a5)
{
  char dest; // [esp+20h] [ebp-818h]
  char s1; // [esp+420h] [ebp-418h]
  int i; // [esp+828h] [ebp-10h]
  int j; // [esp+82Ch] [ebp-Ch]

  Com_Printf("------- Game Initialization -------\n");
  Com_Printf("gamename: %s\n", "Call of Duty 2");
  Com_Printf("gamedate: %s\n", "Oct 24 2005");
  Swap_Init();
  memset(&dword_859B400, 0, 0x3624u);
  dword_859B41C = 1;
  dword_859B5EC = a2;
  *(_DWORD *)dword_859B5F8 = a2;
  dword_859EA04 = -1;
  srand(seed);
  sub_80A8712(seed);
  sub_811E8E4();
  if ( !a4 || !a5 )
    sub_8106014(a1);
  sub_81196D0();
  dword_865262C = (int)sub_8090534;
  dword_8652630 = (int)sub_8106A7C;
  dword_8652634 = (int)sub_8062B4C;
  dword_8652638 = (int)sub_8106BF2;
  dword_8652628 = 1;
  if ( **(_BYTE **)(dword_8793DEC + 8) )
  {
    if ( *(_BYTE *)(dword_8793DF0 + 8) )
      FS_FOpenFileByMode(*(char **)(dword_8793DEC + 8), (int)&dword_859B418, 3);
    else
      FS_FOpenFileByMode(*(char **)(dword_8793DEC + 8), (int)&dword_859B418, 2);
    if ( dword_859B418 )
    {
      sub_80903BC(&dest, 1024);
      sub_8107502("------------------------------------------------------------\n");
      sub_8107502("InitGame: %s\n", &dest);
    }
    else
    {
      Com_Printf("WARNING: Couldn't open logfile: %s\n", *(_DWORD *)(dword_8793DEC + 8));
    }
  }
  else
  {
    Com_Printf("Not logging to disk.\n");
  }
  for ( i = 0; i <= 0; ++i )
  {
    dword_859EA08[i] = -1;
    *(&dword_859EA0C + i) = 0;
    memset((void *)(20 * i + 140110352), 0, 0x14u);
  }
  sub_80DB380((int)sub_8106BF2);
  dword_855A4E0 = &unk_859EA40;
  if ( !a4 )
  {
    memset(dword_855A4E0, 0, 0xB3BC8u);
    *((_DWORD *)dword_855A4E0 + 184048) = sub_80AA8AA;
    *((_DWORD *)dword_855A4E0 + 184049) = sub_811CEFE;
    sub_810DF86(a1);
    sub_80D9B7E();
    sub_8106AAC();
  }
  sub_8120068();
  sub_809107E(22, &s1, 1024);
  sub_80B5FF6(&s1, "winner", (int)"0");
  sub_8090E6C(22, &s1);
  memset(&unk_8665480, 0, 0x8C000u);
  dword_859B404 = (int)&unk_8665480;
  dword_859B5E4 = *(_DWORD *)(dword_8793D88 + 8);
  memset(&unk_86F1480, 0, 0xA2900u);
  dword_859B400 = (int)&unk_86F1480;
  for ( j = 0; j < dword_859B5E4; ++j )
    dword_86655D8[140 * j] = dword_859B400 + 10404 * j;
  *(_DWORD *)dword_859B40C = 72;
  dword_859B410 = 0;
  dword_859B414 = 0;
  sub_8090498(dword_859B404, 72, 560, dword_859B400, 10404);
  sub_80FEEDA();
  sub_81083B2();
  sub_81192E0(a1);
  sub_80FBD50("0");
  sub_811030E();
  sub_807E04A();
  Com_Printf("-----------------------------------\n");
  sub_8083E96();
  sub_807F9F2(1);
  sub_807F64C();
  sub_811932A();
  sub_8115E66();
  sub_810DD38();
  sub_8115E94();
  for ( j = 0; j <= 7; ++j )
    dword_879D83C[306 * j] = -1;
  dword_855A4E0 = 0;
  dword_859B41C = 0;
  sub_8104A30();
  return sub_8104AEC();
}
// 859B400: using guessed type int dword_859B400;
// 859B404: using guessed type int dword_859B404;
// 859B410: using guessed type int dword_859B410;
// 859B414: using guessed type int dword_859B414;
// 859B418: using guessed type int dword_859B418;
// 859B5E4: using guessed type int dword_859B5E4;
// 859EA04: using guessed type int dword_859EA04;
// 859EA08: using guessed type int dword_859EA08[];
// 8652628: using guessed type int dword_8652628;
// 865262C: using guessed type int dword_865262C;
// 8652630: using guessed type int dword_8652630;
// 8652634: using guessed type int dword_8652634;
// 8652638: using guessed type int dword_8652638;
// 86655D8: using guessed type int dword_86655D8[];
// 8793D88: using guessed type int dword_8793D88;
// 8793DEC: using guessed type int dword_8793DEC;
// 8793DF0: using guessed type int dword_8793DF0;

//----- (08107058) --------------------------------------------------------
unsigned int *__usercall sub_8107058@<eax>(long double a1@<st0>, int a2)
{
  unsigned int *result; // eax
  int i; // [esp+14h] [ebp-4h]

  Com_Printf("==== ShutdownGame ====\n");
  if ( dword_859B418 )
  {
    sub_8107502("ShutdownGame:\n");
    sub_8107502("------------------------------------------------------------\n");
    FS_FCloseFile(dword_859B418);
  }
  dword_855A4E0 = 0;
  sub_81069FC(a1);
  sub_8100FE6();
  if ( sub_8084030() && !dword_859D154 )
    sub_808DC2C();
  result = sub_8083EDA(1, dword_859D154 == 0);
  if ( a2 )
  {
    sub_80DB6CA();
    sub_810E010();
    sub_8075F74();
    sub_8106B36();
    result = sub_80A9B80(0);
  }
  for ( i = 0; i <= 0; ++i )
  {
    if ( *(&dword_859EA0C + i) )
      Z_FreeInternal(*(&dword_859EA0C + i));
    *(&dword_859EA0C + i) = 0;
    if ( dword_859EA08[i] >= 0 )
      FS_FCloseFile(dword_859EA08[i]);
    dword_859EA08[i] = -1;
    result = (unsigned int *)&i;
  }
  return result;
}
// 859B418: using guessed type int dword_859B418;
// 859D154: using guessed type int dword_859D154;
// 859EA08: using guessed type int dword_859EA08[];

//----- (08107186) --------------------------------------------------------
int sub_8107186()
{
  int result; // eax
  int i; // [esp+14h] [ebp-4h]

  if ( dword_859B610 )
  {
    for ( i = 0; ; ++i )
    {
      result = i;
      if ( i >= dword_859B5E4 )
        break;
      if ( *(_DWORD *)(dword_859B400 + 10404 * i + 9924) == 2 && *(_DWORD *)(dword_859B400 + 10404 * i + 4) == 5 )
        sub_80FB79C(560 * i + 140924032);
    }
    dword_859B610 = 0;
  }
  return result;
}
// 859B400: using guessed type int dword_859B400;
// 859B5E4: using guessed type int dword_859B5E4;
// 859B610: using guessed type int dword_859B610;

//----- (081071FE) --------------------------------------------------------
int __cdecl sub_81071FE(const void *a1, const void *a2)
{
  signed int v3; // [esp+0h] [ebp-Ch]
  _DWORD *v4; // [esp+4h] [ebp-8h]
  _DWORD *v5; // [esp+8h] [ebp-4h]

  v5 = (_DWORD *)(dword_859B400 + 10404 * *(_DWORD *)a1);
  v4 = (_DWORD *)(dword_859B400 + 10404 * *(_DWORD *)a2);
  if ( v5[2481] == 1 )
    return 1;
  if ( v4[2481] == 1 )
    return -1;
  if ( v5[2515] != 3 || v4[2515] != 3 )
  {
    if ( v5[2515] == 3 )
    {
      v3 = 1;
    }
    else if ( v4[2515] == 3 )
    {
      v3 = -1;
    }
    else if ( v5[2478] <= v4[2478] )
    {
      if ( v5[2478] >= v4[2478] )
      {
        if ( v5[2479] >= v4[2479] )
          v3 = v5[2479] > v4[2479];
        else
          v3 = -1;
      }
      else
      {
        v3 = 1;
      }
    }
    else
    {
      v3 = -1;
    }
  }
  else if ( v5 >= v4 )
  {
    v3 = v5 > v4;
  }
  else
  {
    v3 = -1;
  }
  return v3;
}
// 859B400: using guessed type int dword_859B400;

//----- (08107356) --------------------------------------------------------
void sub_8107356()
{
  int i; // [esp+14h] [ebp-4h]

  nmemb = 0;
  dword_859BF2C = 0;
  for ( i = 0; i < dword_859B5E4; ++i )
  {
    if ( *(_DWORD *)(dword_859B400 + 10404 * i + 9924) )
    {
      *(_DWORD *)&dword_859B61C[4 * nmemb++] = i;
      if ( *(_DWORD *)(dword_859B400 + 10404 * i + 10060) != 3 && *(_DWORD *)(dword_859B400 + 10404 * i + 9924) == 2 )
        ++dword_859BF2C;
    }
  }
  qsort(dword_859B61C, nmemb, 4u, sub_81071FE);
  dword_859B610 = 1;
}
// 859B400: using guessed type int dword_859B400;
// 859B5E4: using guessed type int dword_859B5E4;
// 859B610: using guessed type int dword_859B610;
// 859BF2C: using guessed type int dword_859BF2C;

//----- (08107428) --------------------------------------------------------
void __usercall sub_8107428(long double a1@<st0>)
{
  int i; // [esp+14h] [ebp-4h]
  int j; // [esp+14h] [ebp-4h]

  Cbuf_ExecuteText(a1, 2, "map_rotate\n");
  *(_DWORD *)dword_859B600 = 0;
  *(_DWORD *)dword_859B604 = 0;
  for ( i = 0; i < *(_DWORD *)(dword_8793D88 + 8); ++i )
  {
    if ( *(_DWORD *)(dword_859B400 + 10404 * i + 9924) == 2 )
      *(_DWORD *)(dword_859B400 + 10404 * i + 9912) = 0;
  }
  for ( j = 0; j < *(_DWORD *)(dword_8793D88 + 8); ++j )
  {
    if ( *(_DWORD *)(dword_859B400 + 10404 * j + 9924) == 2 )
      *(_DWORD *)(dword_859B400 + 10404 * j + 9924) = 1;
  }
  sub_8107502("ExitLevel: executed\n");
}
// 859B400: using guessed type int dword_859B400;
// 8793D88: using guessed type int dword_8793D88;

//----- (08107502) --------------------------------------------------------
void sub_8107502(char *format, ...)
{
  size_t v1; // eax
  char s; // [esp+30h] [ebp-818h]
  char v3; // [esp+430h] [ebp-418h]
  __gnuc_va_list __varargs; // [esp+83Ch] [ebp-Ch]
  va_list va; // [esp+854h] [ebp+Ch]

  va_start(va, format);
  if ( dword_859B418 )
  {
    va_copy(__varargs, va);
    vsprintf(&s, format, va);
    Com_sprintf(
      &v3,
      0x400u,
      "%3i:%i%i %s",
      dword_859B5EC / 1000 / 60,
      dword_859B5EC / 1000 % 60 / 10,
      dword_859B5EC / 1000 % 60 % 10,
      &s);
    v1 = strlen(&v3);
    sub_809E454(&v3, v1, dword_859B418);
  }
}
// 859B418: using guessed type int dword_859B418;

//----- (08107644) --------------------------------------------------------
void __usercall sub_8107644(long double a1@<st0>)
{
  char *v1; // eax
  signed int v2; // ST34_4
  double v3; // ST1C_8
  char *v4; // eax
  char *v5; // eax
  char *v6; // eax
  char *v7; // eax
  int v8; // [esp+28h] [ebp-10h]

  if ( dword_859BF20 && dword_859BF20 < dword_859B5EC )
  {
    dword_859BF20 = 0;
    v1 = va("%s\n", byte_859B71C);
    Cbuf_ExecuteText(a1, 2, v1);
  }
  if ( *(_DWORD *)dword_859BF1C )
  {
    if ( dword_859B5EC - *(_DWORD *)dword_859BF1C < 0 )
    {
      v8 = dword_859BF2C / 2 + 1;
      if ( *(_DWORD *)dword_859BF24 < v8 )
      {
        if ( *(_DWORD *)dword_859BF28 <= dword_859BF2C - v8 )
          return;
        v7 = va("%c \"GAME_VOTEFAILED\"", 101);
        sub_808FE96(-1, 0, (int)v7);
      }
      else
      {
        v6 = va("%c \"GAME_VOTEPASSED\"", 101);
        sub_808FE96(-1, 0, (int)v6);
        dword_859BF20 = dword_859B5EC + 3000;
      }
    }
    else
    {
      v2 = *(_DWORD *)dword_859BF24;
      v3 = (long double)*(signed int *)dword_859BF28;
      if ( v2 <= (signed int)(ceil(
                                (long double)(dword_859BF2C - (*(_DWORD *)dword_859BF24 + *(_DWORD *)dword_859BF28))
                              * *(float *)(dword_8793E54 + 8))
                            + v3) )
      {
        v5 = va("%c \"GAME_VOTEFAILED\"", 101);
        sub_808FE96(-1, 0, (int)v5);
      }
      else
      {
        v4 = va("%c \"GAME_VOTEPASSED\"", 101);
        sub_808FE96(-1, 0, (int)v4);
        dword_859BF20 = dword_859B5EC + 3000;
      }
    }
    *(_DWORD *)dword_859BF1C = 0;
    sub_8090E6C(15, &byte_81534F7);
  }
}
// 859BF20: using guessed type int dword_859BF20;
// 859BF2C: using guessed type int dword_859BF2C;
// 8793E54: using guessed type int dword_8793E54;

//----- (08107848) --------------------------------------------------------
int sub_8107848()
{
  int result; // eax
  _DWORD *v1; // ecx
  int v2; // [esp+0h] [ebp-18h]
  int v3; // [esp+4h] [ebp-14h]
  signed int j; // [esp+Ch] [ebp-Ch]
  int v5; // [esp+10h] [ebp-8h]
  int i; // [esp+14h] [ebp-4h]

  for ( i = 0; ; ++i )
  {
    result = i;
    if ( i >= dword_859B5E4 )
      break;
    v5 = dword_859B404 + 560 * i;
    if ( *(_BYTE *)(dword_859B404 + 560 * i + 252) )
    {
      v3 = *(_DWORD *)(v5 + 344);
      v2 = *(_DWORD *)(*(_DWORD *)(v5 + 344) + 10060);
      for ( j = 0; j <= 15; ++j )
      {
        if ( dword_859B424[7 * j] && (!dword_859B424[7 * j + 5] || dword_859B424[7 * j + 5] == v2) )
        {
          v1 = (_DWORD *)(v3 + 28 * j + 1508);
          *v1 = dword_859B424[7 * j];
          v1[1] = dword_859B424[7 * j + 1];
          v1[2] = dword_859B424[7 * j + 2];
          v1[3] = dword_859B424[7 * j + 3];
          v1[4] = dword_859B424[7 * j + 4];
          v1[5] = dword_859B424[7 * j + 5];
          v1[6] = dword_859B424[7 * j + 6];
        }
        else
        {
          *(_DWORD *)(v3 + 28 * j + 1508) = 0;
        }
      }
    }
  }
  return result;
}
// 859B404: using guessed type int dword_859B404;
// 859B5E4: using guessed type int dword_859B5E4;

//----- (08107962) --------------------------------------------------------
int sub_8107962()
{
  int result; // eax
  int i; // [esp+14h] [ebp-4h]

  for ( i = 0; ; ++i )
  {
    result = i;
    if ( i >= dword_859B5E4 )
      break;
    if ( *(_BYTE *)(dword_859B404 + 560 * i + 252) )
      sub_81023F2(*(_DWORD **)(dword_859B404 + 560 * i + 344), *(_DWORD *)(dword_859B404 + 560 * i), 3u);
  }
  return result;
}
// 859B404: using guessed type int dword_859B404;
// 859B5E4: using guessed type int dword_859B5E4;

//----- (081079C8) --------------------------------------------------------
int __cdecl sub_81079C8(int a1)
{
  int result; // eax
  int (__cdecl *v2)(int); // [esp+10h] [ebp-8h]
  int v3; // [esp+14h] [ebp-4h]

  result = *(_DWORD *)(a1 + 400);
  v3 = *(_DWORD *)(a1 + 400);
  if ( v3 > 0 )
  {
    result = *(_DWORD *)(a1 + 400);
    if ( v3 <= dword_859B5EC )
    {
      *(_DWORD *)(a1 + 400) = 0;
      v2 = (int (__cdecl *)(int))dword_8167880[10 * *(unsigned __int8 *)(a1 + 358)];
      if ( !v2 )
        Com_Error(1, &byte_8153A87);
      result = v2(a1);
    }
  }
  return result;
}
// 8167880: using guessed type int dword_8167880[];

//----- (08107A40) --------------------------------------------------------
void sub_8107A40()
{
  if ( *(_DWORD *)(dword_8793E58 + 8) >= 0 )
  {
    Com_Printf("server:\n");
    sub_80908FC((int *)(dword_859B404 + 560 * *(_DWORD *)(dword_8793E58 + 8)));
  }
}
// 859B404: using guessed type int dword_859B404;
// 8793E58: using guessed type int dword_8793E58;

//----- (08107A7C) --------------------------------------------------------
int __cdecl sub_8107A7C(int a1)
{
  int result; // eax

  while ( 1 )
  {
    result = a1;
    if ( !*(_BYTE *)(a1 + 252) )
      break;
    result = *(_DWORD *)(a1 + 372) & 0x2000;
    if ( result )
      break;
    result = sub_811BF04((int *)a1, 1);
    if ( !result )
      break;
    sub_8084FD2();
  }
  return result;
}

//----- (08107AC4) --------------------------------------------------------
void __usercall sub_8107AC4(long double a1@<st0>, _DWORD *s)
{
  unsigned int v2; // edx

  if ( s[98] != dword_859B5E8 )
  {
    s[98] = dword_859B5E8;
    if ( !s[86] )
    {
      if ( s[93] & 0x800 )
        v2 = s[2] | 0x20;
      else
        v2 = s[2] & 0xFFFFFFDF;
      s[2] = v2;
    }
    if ( s[2] == 0x10000 && dword_859B5EC > s[22] )
    {
      sub_811C9C0(a1, s);
      return;
    }
    if ( dword_859B5EC - s[94] > 300 )
    {
      if ( s[95] )
      {
        sub_811C9C0(a1, s);
        return;
      }
      if ( s[96] )
      {
        s[96] = 0;
        sub_809A3BA((int)s);
      }
    }
    if ( !s[95] )
    {
      switch ( s[1] )
      {
        case 4:
          sub_810BC36((unsigned __int8 *)s);
          break;
        case 3:
          if ( s[130] )
          {
            sub_811BE86(s);
            sub_81079C8((int)s);
          }
          else
          {
            sub_8105956(s);
          }
          break;
        case 2:
          sub_810592C((float *)s);
          break;
        default:
          if ( *((_BYTE *)s + 352) )
          {
            sub_8105956(s);
          }
          else if ( s[1] == 6 )
          {
            sub_810D966(s);
          }
          else if ( s[86] )
          {
            sub_80F3F74(a1, s);
          }
          else
          {
            if ( !s[1] && s[130] )
              sub_811BE86(s);
            sub_81079C8((int)s);
          }
          break;
      }
    }
  }
}
// 859B5E8: using guessed type int dword_859B5E8;

//----- (08107CA2) --------------------------------------------------------
void __usercall sub_8107CA2(long double a1@<st0>, int a2)
{
  float v2; // ST04_4
  int v3; // ecx
  int v4; // edx
  int v5; // eax
  char s[1028]; // [esp+10h] [ebp-428h]
  int v7; // [esp+414h] [ebp-24h]
  int v8; // [esp+418h] [ebp-20h]
  int v9; // [esp+41Fh] [ebp-19h]
  int *v10; // [esp+424h] [ebp-14h]
  int *v11; // [esp+428h] [ebp-10h]
  char v12[4]; // [esp+42Ch] [ebp-Ch]

  ++dword_859B5E8;
  dword_859B5F0 = dword_859B5EC;
  dword_859B5EC = a2;
  dword_859B5F4 = a2 - dword_859B5F0;
  dword_865261C = a2;
  dword_8652620 = a2;
  dword_8652624 = a2 - dword_859B5F0;
  dword_855A4E0 = &unk_859EA40;
  v11 = (int *)&unk_8665480;
  *(_DWORD *)v12 = 0;
  while ( *(_DWORD *)v12 < *(_DWORD *)dword_859B40C )
  {
    if ( *((_BYTE *)v11 + 252) )
    {
      a1 = (long double)dword_859B5F4 * 0.001;
      v2 = a1;
      sub_80907BC(v11, v2);
    }
    ++*(_DWORD *)v12;
    v11 += 140;
  }
  memset(s, 0, 0x400u);
  LOBYTE(v9) = 0;
  Com_Memcpy(dword_859DDE8, &unk_859D1E8, 12 * dword_859E9E8);
  dword_859E9EC = dword_859E9E8;
  dword_859E9E8 = 0;
  do
  {
    *(int *)((char *)&v9 + 1) = 0;
    v9 = (unsigned __int8)(v9 + 1);
    for ( *(_DWORD *)v12 = 0; *(_DWORD *)v12 < dword_859E9EC; ++*(_DWORD *)v12 )
    {
      v8 = 12 * *(_DWORD *)v12 + 140107240;
      v7 = LOWORD(dword_859DDE8[3 * *(_DWORD *)v12]);
      v11 = (int *)((char *)&unk_8665480 + 560 * v7);
      if ( v11[138] == dword_859DDEC[3 * *(_DWORD *)v12] )
      {
        v10 = (int *)((char *)&unk_8665480 + 560 * *(unsigned __int16 *)(v8 + 2));
        if ( v10[138] == *(_DWORD *)(v8 + 8) )
        {
          if ( s[v7] == (_BYTE)v9 )
          {
            *(int *)((char *)&v9 + 1) = 1;
            continue;
          }
          s[v7] = v9;
          Scr_AddEntity(v10);
          Scr_Notify(v11, word_87A22F4, 1);
        }
      }
      --dword_859E9EC;
      --*(_DWORD *)v12;
      v3 = v8;
      v4 = 3 * dword_859E9EC;
      *(_DWORD *)v8 = dword_859DDE8[3 * dword_859E9EC];
      *(_DWORD *)(v3 + 4) = dword_859DDEC[v4];
      *(_DWORD *)(v3 + 8) = dword_859DDF0[v4];
    }
    sub_8084FD2();
  }
  while ( *(int *)((char *)&v9 + 1) );
  v11 = (int *)&unk_8665480;
  *(_DWORD *)v12 = 0;
  while ( *(_DWORD *)v12 < *(_DWORD *)dword_859B40C )
  {
    sub_8107A7C((int)v11);
    ++*(_DWORD *)v12;
    v11 += 140;
  }
  sub_8084F9A();
  v11 = (int *)&unk_8665480;
  dword_859EA04 = 0;
  while ( dword_859EA04 < *(_DWORD *)dword_859B40C )
  {
    if ( *((_BYTE *)v11 + 252) )
    {
      if ( v11[130] )
        sub_8107AC4(a1, *(_DWORD **)v11[130]);
      sub_8107AC4(a1, v11);
    }
    ++dword_859EA04;
    v11 += 140;
  }
  dword_859EA04 = -1;
  sub_8107848();
  sub_8107962();
  v11 = (int *)&unk_8665480;
  *(_DWORD *)v12 = 0;
  while ( *(_DWORD *)v12 < dword_859B5E4 )
  {
    if ( *((_BYTE *)v11 + 252) )
      sub_80F4DBE(a1, (int)v11);
    ++*(_DWORD *)v12;
    v11 += 140;
  }
  sub_8119EF2();
  if ( *(_BYTE *)(dword_8793E50 + 8) )
    sub_8107644(a1);
  sub_8107186();
  if ( *(_BYTE *)(dword_8793E00 + 8) )
  {
    for ( *(_DWORD *)v12 = 0; *(_DWORD *)v12 <= 1023; ++*(_DWORD *)v12 )
    {
      v5 = sub_8078896((unsigned __int16)word_86655E8[280 * *(_DWORD *)v12]);
      Com_Printf("%4i: %s\n", *(_DWORD *)v12, v5);
    }
    Dvar_SetBool(dword_8793E00, 0);
  }
  if ( dword_859E9FC )
    sub_8104A30();
  if ( dword_859EA00 )
    sub_8104AEC();
  sub_8107A40();
  dword_855A4E0 = 0;
}
// 859B5E4: using guessed type int dword_859B5E4;
// 859B5E8: using guessed type int dword_859B5E8;
// 859B5F0: using guessed type int dword_859B5F0;
// 859B5F4: using guessed type int dword_859B5F4;
// 859DDE8: using guessed type int dword_859DDE8[];
// 859DDEC: using guessed type int dword_859DDEC[];
// 859DDF0: using guessed type int dword_859DDF0[];
// 859E9E8: using guessed type int dword_859E9E8;
// 859E9EC: using guessed type int dword_859E9EC;
// 859E9FC: using guessed type int dword_859E9FC;
// 859EA00: using guessed type int dword_859EA00;
// 859EA04: using guessed type int dword_859EA04;
// 865261C: using guessed type int dword_865261C;
// 8652620: using guessed type int dword_8652620;
// 8652624: using guessed type int dword_8652624;
// 86655E8: using guessed type __int16 word_86655E8[];
// 8793E00: using guessed type int dword_8793E00;
// 8793E50: using guessed type int dword_8793E50;
// 87A22F4: using guessed type __int16 word_87A22F4;
// 8107CA2: using guessed type char s[1028];

//----- (08108090) --------------------------------------------------------
void __cdecl sub_8108090(void *s, int a2, int a3, int a4, int a5, int a6, int a7)
{
  sub_809B6A8(s, a2, a3, a4, a5, a6, a7, 0, 0, 0);
}

//----- (081080E6) --------------------------------------------------------
signed int __cdecl sub_81080E6(float *a1, float *a2, float *a3, float *a4, int a5, int a6)
{
  return sub_809B9E2(a1, a2, a3, a4, a5, 1023, a6, 0, 0);
}

//----- (08108134) --------------------------------------------------------
void __cdecl sub_8108134(void *s, int a2, int a3, int a4, int a5, int a6)
{
  sub_809B6A8(s, a2, (int)&unk_8145E68, (int)&unk_8145E68, a3, a4, a5, 1, a6, 1);
}

//----- (0810818A) --------------------------------------------------------
signed int __cdecl sub_810818A(float *a1, float *a2, int a3, int a4)
{
  return sub_809B9E2(a1, (float *)&unk_8145E68, (float *)&unk_8145E68, a2, a3, 1023, a4, 1, 1);
}

//----- (081081DA) --------------------------------------------------------
int *__cdecl sub_81081DA(int *a1, float *a2, float *a3, int a4, int a5)
{
  return sub_809BC5C(a1, a2, (float *)&unk_8145E68, (float *)&unk_8145E68, a3, a4, 1023, a5);
}

//----- (08108222) --------------------------------------------------------
void sub_8108222()
{
  ;
}

//----- (08108228) --------------------------------------------------------
int __usercall sub_8108228@<eax>(long double a1@<st0>, void *s)
{
  return sub_811C9C0(a1, s);
}

//----- (0810823C) --------------------------------------------------------
int __cdecl sub_810823C(_DWORD *a1)
{
  return sub_811CF36(a1, a1 + 78);
}

//----- (0810825C) --------------------------------------------------------
int __usercall sub_810825C@<eax>(long double a1@<st0>, void *s)
{
  return sub_811C9C0(a1, s);
}

//----- (08108270) --------------------------------------------------------
int __cdecl sub_8108270(int a1, _DWORD *a2, _DWORD *a3)
{
  int v3; // ST14_4
  long double v4; // fst7
  int result; // eax

  v3 = *(unsigned __int8 *)(a1 + 240);
  sub_809A3BA(a1);
  sub_810A912(a2, (_DWORD *)(*(_DWORD *)(a1 + 344) + 20));
  v4 = *(float *)(*(_DWORD *)(a1 + 344) + 28) + 1.0;
  *(float *)(*(_DWORD *)(a1 + 344) + 28) = v4;
  *(_DWORD *)(*(_DWORD *)(a1 + 344) + 160) ^= 2u;
  sub_80F5E80(v4, a1, a3);
  sub_80DD59E(*(_DWORD *)(a1 + 344), a1, 1, 1u);
  result = sub_810A912((_DWORD *)(*(_DWORD *)(a1 + 344) + 20), (_DWORD *)(a1 + 312));
  if ( v3 )
    result = sub_809A45E(a1);
  return result;
}

//----- (08108354) --------------------------------------------------------
int __usercall sub_8108354@<eax>(long double a1@<st0>, void *s)
{
  return sub_811C9C0(a1, s);
}

//----- (08108368) --------------------------------------------------------
int __cdecl sub_8108368(int a1)
{
  if ( *(_BYTE *)(a1 + 240) )
    return sub_809A3BA(a1);
  *(_BYTE *)(a1 + 354) = 0;
  return sub_809A45E(a1);
}

//----- (0810839E) --------------------------------------------------------
int __usercall sub_810839E@<eax>(long double a1@<st0>, void *s)
{
  return sub_811C9C0(a1, s);
}

//----- (081083B2) --------------------------------------------------------
int *sub_81083B2()
{
  int *result; // eax
  int i; // [esp+0h] [ebp-4h]

  for ( i = 0; i <= 31; ++i )
  {
    dword_8793E60[17 * i] = 0;
    result = &i;
  }
  return result;
}

//----- (081083E8) --------------------------------------------------------
int __cdecl sub_81083E8(int a1, int a2, int a3)
{
  int v3; // eax
  float v4; // ST2C_4
  char v6; // [esp+30h] [ebp-58h]
  int v7; // [esp+40h] [ebp-48h]
  char v8; // [esp+50h] [ebp-38h]
  int v9; // [esp+74h] [ebp-14h]

  if ( !sub_811C0B2(a1, (unsigned __int16)word_87A232C, (float *)&v8) )
  {
    v3 = sub_8078896(*(unsigned __int16 *)(a1 + 360));
    Com_Error(1, &byte_8153AE0, "tag_flash", *(_DWORD *)a1, v3);
  }
  sub_80F61BE(a2, (float *)&v7);
  sub_80F63A0(a2, a3, (float *)(a3 + 12), (float *)(a3 + 24));
  sub_810A912((_DWORD *)a3, (_DWORD *)(a3 + 48));
  sub_810A986((float *)&v9, (float *)&v7, (float *)&v6);
  v4 = sub_80A20C0((float *)&v6);
  return sub_810A9CA((int)&v7, v4, a3, a3 + 36);
}
// 87A232C: using guessed type __int16 word_87A232C;

//----- (081084EA) --------------------------------------------------------
int __cdecl sub_81084EA(_DWORD *a1, int *a2)
{
  int *v3; // [esp+24h] [ebp-54h]
  int v4; // [esp+30h] [ebp-48h]
  int v5; // [esp+6Ch] [ebp-Ch]

  if ( a2 == (int *)&unk_86F1250 )
    v3 = &dword_86F1020;
  else
    v3 = a2;
  sub_81083E8((int)a1, (int)v3, (int)&v4);
  v5 = sub_80E9270(a1[50]);
  if ( *(_DWORD *)(v5 + 120) )
    sub_811E18A((int)a1, 0.0, (int)&v4);
  else
    sub_811DFF4((int)v3, *(float *)(a1[87] + 56), (int)&v4, (int)a1, dword_859B5EC);
  return sub_811CDA2(a1, 175, *v3);
}
// 86F1020: using guessed type int dword_86F1020;

//----- (081085B8) --------------------------------------------------------
void __cdecl sub_81085B8(int a1, int a2)
{
  char *v2; // eax
  char *v3; // eax
  float v4; // ST0C_4
  long double v5; // fst7
  float v6; // ST04_4
  float v7; // ST0C_4
  long double v8; // fst7
  float v9; // ST04_4
  int v10; // ST38_4
  float v11; // ST04_4
  int v12; // ST34_4
  long double v13; // fst7
  float v14; // ST04_4
  int v15; // ST30_4
  long double v16; // fst7
  float v17; // ST04_4
  float v18; // ST0C_4
  long double v19; // fst7
  float v20; // ST04_4
  float v21; // ST0C_4
  long double v22; // fst7
  float v23; // ST04_4
  int v24; // ST24_4
  long double v25; // fst7
  int v26; // [esp+24h] [ebp-1E4h]
  int v27; // [esp+28h] [ebp-1E0h]
  int v28; // [esp+38h] [ebp-1D0h]
  int v29; // [esp+40h] [ebp-1C8h]
  int v30; // [esp+48h] [ebp-1C0h]
  float s; // [esp+50h] [ebp-1B8h]
  int v32; // [esp+80h] [ebp-188h]
  float v33; // [esp+88h] [ebp-180h]
  int v34; // [esp+90h] [ebp-178h]
  float v35; // [esp+98h] [ebp-170h]
  char v36; // [esp+A0h] [ebp-168h]
  int v37; // [esp+B4h] [ebp-154h]
  int v38; // [esp+B8h] [ebp-150h]
  int v39; // [esp+BCh] [ebp-14Ch]
  int v40; // [esp+C0h] [ebp-148h]
  int v41; // [esp+C4h] [ebp-144h]
  int v42; // [esp+C8h] [ebp-140h]
  float *v43; // [esp+CCh] [ebp-13Ch]
  char v44; // [esp+D0h] [ebp-138h]
  char v45; // [esp+100h] [ebp-108h]
  int v46; // [esp+124h] [ebp-E4h]
  int v47; // [esp+130h] [ebp-D8h]
  int v48; // [esp+154h] [ebp-B4h]
  float v49; // [esp+15Ch] [ebp-ACh]
  float v50; // [esp+16Ch] [ebp-9Ch]
  char v51; // [esp+170h] [ebp-98h]
  int v52; // [esp+188h] [ebp-80h]
  int v53; // [esp+194h] [ebp-74h]
  int v54; // [esp+1A0h] [ebp-68h]
  float v55; // [esp+1A8h] [ebp-60h]
  float v56[3]; // [esp+1B0h] [ebp-58h]
  float v57; // [esp+1BCh] [ebp-4Ch]
  float v58; // [esp+1C0h] [ebp-48h]
  float v59; // [esp+1C4h] [ebp-44h]
  float v60; // [esp+1C8h] [ebp-40h]
  float v61; // [esp+1CCh] [ebp-3Ch]
  float v62; // [esp+1D0h] [ebp-38h]
  float v63; // [esp+1D4h] [ebp-34h]
  float v64; // [esp+1D8h] [ebp-30h]
  int v65; // [esp+1DCh] [ebp-2Ch]
  int v66; // [esp+1E0h] [ebp-28h]
  int v67; // [esp+1E4h] [ebp-24h]
  int v68; // [esp+1E8h] [ebp-20h]
  int v69; // [esp+1ECh] [ebp-1Ch]
  int v70; // [esp+1F0h] [ebp-18h]
  int v71; // [esp+1F4h] [ebp-14h]
  int v72; // [esp+1F8h] [ebp-10h]
  int v73; // [esp+1FCh] [ebp-Ch]

  v72 = *(_DWORD *)(a1 + 144);
  v67 = 1208 * v72 + 140846652;
  v66 = 1208 * v72 + 140847548;
  if ( *((_DWORD *)&unk_86529CC + 302 * v72) && *(_DWORD *)(v66 + 20) && *(_DWORD *)(*(_DWORD *)(v66 + 20) + 80) & 4 )
  {
    v43 = (float *)sub_811C056((int *)a2, (unsigned __int16)word_87A2338);
    if ( v43 )
    {
      v65 = sub_80E9270(*(_DWORD *)(a2 + 200));
      v42 = *(_DWORD *)(v67 + 1188);
      v41 = dword_86525F4;
      v40 = *(_DWORD *)(v66 + 16) & 0xFFFFFDFF;
      sub_80A913C(v43, (float *)&v44);
      v64 = sub_80A2A84((float *)&v44);
      sub_80A7146((float *)(a2 + 324), (int)&v51);
      sub_810A912((_DWORD *)(a2 + 312), &v53);
      sub_810A986((float *)(a1 + 312), (float *)&v53, (float *)&v36);
      v50 = sub_810AA1E((float *)&v36, (float *)&v52);
      v63 = v50 - v43[6];
      sub_80BF482((_DWORD *)v42, v40, 0.0);
      v71 = sub_80BE8E4(v41, v40);
      v62 = 0.0;
      v61 = 0.0;
      v69 = 0;
      v38 = 0;
      if ( !v71 )
      {
        v2 = sub_80BE94C(v41, v40);
        Com_Error(1, &byte_8153B80, v2);
      }
      v73 = 0;
      do
      {
        v37 = sub_80BE8F4(v41, v40, v73);
        sub_80C0354(v42, v37, 1.0, 1065353216, 1065353216, 0, 0, 0);
        v70 = sub_80BE8E4(v41, v37);
        if ( !v70 )
        {
          v3 = sub_80BE94C(v41, v37);
          Com_Error(1, &byte_8153B80, v3);
        }
        v59 = (long double)v70 * 0.5 - v64 / *(float *)(v65 + 1380);
        if ( v59 >= 0.0 )
        {
          if ( v59 >= (long double)(v70 - 1) )
            v59 = (long double)(v70 - 1);
        }
        else
        {
          v59 = 0.0;
        }
        v68 = (signed int)v59;
        v59 = v59 - (long double)v68;
        v39 = sub_80BE8F4(v41, v37, v68);
        v4 = 1.0 - v59;
        sub_80C0354(v42, v39, v4, 1065353216, 1065353216, 0, 0, 0);
        if ( v59 != 0.0 )
        {
          v38 = sub_80BE8F4(v41, v37, v68 + 1);
          sub_80C0354(v42, v38, v59, 1065353216, 1065353216, 0, 0, 0);
        }
        sub_80BEFE2(v42, v37, v56, &v54);
        if ( v55 >= (long double)v63 )
          break;
        v62 = v55;
        v69 = v68;
        v61 = v59;
        ++v73;
      }
      while ( v73 < v71 );
      sub_80BF482((_DWORD *)v42, v40, 0.0);
      v5 = sub_80BE816(v42, v39);
      v6 = v5 - (1.0 - v59);
      v58 = sub_810A840(v6) * (1000.0 / (long double)dword_859B5F4);
      if ( v58 <= 0.0 )
        *(float *)&v28 = 0.0;
      else
        *(float *)&v28 = 1.0 / v58;
      v7 = 1.0 - v59;
      sub_80C0354(v42, v39, v7, v28, 1065353216, 0, 0, 0);
      if ( v59 != 0.0 )
      {
        v8 = sub_80BE816(v42, v38);
        v9 = v8 - v59;
        v58 = sub_810A840(v9) * (1000.0 / (long double)dword_859B5F4);
        if ( v58 <= 0.0 )
        {
          sub_80C0354(v42, v38, v59, COERCE_INT(0.0), 1065353216, 0, 0, 0);
        }
        else
        {
          *(float *)&v10 = 1.0 / v58;
          sub_80C0354(v42, v38, v59, v10, 1065353216, 0, 0, 0);
        }
      }
      if ( v73 && v73 != v71 )
      {
        v57 = (v63 - v62) / (v55 - v62);
        v13 = sub_80BE816(v42, v37);
        v14 = v13 - v57;
        v58 = sub_810A840(v14) * (1000.0 / (long double)dword_859B5F4);
        if ( v58 <= 0.0 )
        {
          sub_80C0354(v42, v37, v57, COERCE_INT(0.0), 1065353216, 0, 0, 0);
        }
        else
        {
          *(float *)&v15 = 1.0 / v58;
          sub_80C0354(v42, v37, v57, v15, 1065353216, 0, 0, 0);
        }
        v37 = sub_80BE8F4(v41, v40, v73 - 1);
        v16 = sub_80BE816(v42, v37);
        v17 = v16 - (1.0 - v57);
        v58 = sub_810A840(v17) * (1000.0 / (long double)dword_859B5F4);
        if ( v58 <= 0.0 )
          *(float *)&v27 = 0.0;
        else
          *(float *)&v27 = 1.0 / v58;
        v18 = 1.0 - v57;
        sub_80C0354(v42, v37, v18, v27, 1065353216, 0, 0, 0);
        v39 = sub_80BE8F4(v41, v37, v69);
        v19 = sub_80BE816(v42, v39);
        v20 = v19 - (1.0 - v61);
        v58 = sub_810A840(v20) * (1000.0 / (long double)dword_859B5F4);
        if ( v58 <= 0.0 )
          *(float *)&v26 = 0.0;
        else
          *(float *)&v26 = 1.0 / v58;
        v21 = 1.0 - v61;
        sub_80C0354(v42, v39, v21, v26, 1065353216, 0, 0, 0);
        if ( v61 != 0.0 )
        {
          v38 = sub_80BE8F4(v41, v37, v69 + 1);
          v22 = sub_80BE816(v42, v38);
          v23 = v22 - v61;
          v58 = sub_810A840(v23) * (1000.0 / (long double)dword_859B5F4);
          if ( v58 <= 0.0 )
          {
            sub_80C0354(v42, v38, v61, COERCE_INT(0.0), 1065353216, 0, 0, 0);
          }
          else
          {
            *(float *)&v24 = 1.0 / v58;
            sub_80C0354(v42, v38, v61, v24, 1065353216, 0, 0, 0);
          }
        }
      }
      else
      {
        v11 = sub_80BE816(v42, v37) - 1.0;
        v58 = sub_810A840(v11) * (1000.0 / (long double)dword_859B5F4);
        if ( v58 <= 0.0 )
        {
          sub_80C0354(v42, v37, 1.0, COERCE_INT(0.0), 1065353216, 0, 0, 0);
        }
        else
        {
          *(float *)&v12 = 1.0 / v58;
          sub_80C0354(v42, v37, 1.0, v12, 1065353216, 0, 0, 0);
        }
      }
      sub_80BEFE2(v42, v40, v56, &v54);
      sub_80A530C((int)&v54, v64);
      sub_810A898((float *)&v54, v43 + 4, (float *)&v48);
      v49 = v50;
      v25 = sub_80A5774(v56);
      v60 = v25 + v64;
      sub_80A718E(v60, (int)&v47);
      sub_80A3C8E((float *)&v47, (float *)&v51, (float *)&v45);
      sub_810A912(&v46, (_DWORD *)(*(_DWORD *)(a1 + 344) + 20));
      sub_810A912((_DWORD *)(*(_DWORD *)(a1 + 344) + 20), &v34);
      sub_810A912((_DWORD *)(*(_DWORD *)(a1 + 344) + 20), &v32);
      v35 = v35 + *(float *)(*(_DWORD *)(a1 + 344) + 248);
      v33 = v33 - 60.0;
      sub_8108090(&s, (int)&v34, (int)&unk_8145E68, (int)&unk_8145E68, (int)&v32, *(_DWORD *)a1, 42008593);
      if ( s < 1.0 )
      {
        sub_80DEB7A((int)&v34, (int)&v32, s, (int)&v29);
        *(_DWORD *)(*(_DWORD *)(a1 + 344) + 28) = v30;
      }
      sub_80DD59E(*(_DWORD *)(a1 + 344), a1, 1, 1u);
      sub_810A912((_DWORD *)(*(_DWORD *)(a1 + 344) + 20), (_DWORD *)(a1 + 312));
      sub_80A71F4((int)&v45, a1 + 324);
      sub_809A45E(a1);
    }
    else
    {
      Com_Printf("WARNING: aborting player positioning on turret since 'tag_weapon' does not exist\n");
    }
  }
}
// 859B5F4: using guessed type int dword_859B5F4;
// 86525F4: using guessed type int dword_86525F4;
// 87A2338: using guessed type __int16 word_87A2338;

//----- (08109236) --------------------------------------------------------
int __cdecl sub_8109236(int a1, int a2)
{
  int v2; // ST0C_4
  int result; // eax
  int v4; // [esp+10h] [ebp-8h]

  v4 = *(_DWORD *)(a1 + 348);
  v2 = *(_DWORD *)(a2 + 344);
  *(_DWORD *)(v2 + 1424) = 1;
  *(_DWORD *)(v2 + 1428) = *(_DWORD *)a1;
  *(float *)(a1 + 104) = sub_80A6000(*(float *)(v2 + 232), *(float *)(a1 + 324));
  *(float *)(a1 + 104) = sub_810A85A(*(float *)(a1 + 104), *(float *)(v4 + 12), *(float *)(v4 + 20));
  *(float *)(a1 + 108) = sub_80A6000(*(float *)(v2 + 236), *(float *)(a1 + 328));
  *(float *)(a1 + 108) = sub_810A85A(*(float *)(a1 + 108), *(float *)(v4 + 16), *(float *)(v4 + 24));
  *(_DWORD *)(a1 + 112) = 0;
  result = *(_DWORD *)(v4 + 4) & 0x800;
  if ( result )
  {
    *(_DWORD *)(v4 + 4) &= 0xFFFFF7FF;
    result = *(_DWORD *)(a1 + 8) ^ 2;
    *(_DWORD *)(a1 + 8) = result;
  }
  return result;
}

//----- (08109348) --------------------------------------------------------
int *__cdecl sub_8109348(_DWORD *a1, int *a2)
{
  int v2; // ebx
  int *result; // eax

  v2 = a1[87];
  *(_DWORD *)(v2 + 40) = 3 * *(_DWORD *)(sub_80E9270(a1[50]) + 516);
  result = a2;
  if ( a2[86] )
  {
    sub_81084EA(a1, a2);
    result = (int *)a2[86];
    result[356] = 2;
  }
  return result;
}

//----- (081093B8) --------------------------------------------------------
int __cdecl sub_81093B8(_DWORD *a1, int *a2)
{
  int result; // eax
  int v3; // [esp+10h] [ebp-8h]
  int v4; // [esp+14h] [ebp-4h]

  v4 = a1[87];
  sub_8109236((int)a1, (int)a2);
  sub_81085B8((int)a2, (int)a1);
  v3 = sub_80E9270(a1[50]);
  *(_DWORD *)(a2[86] + 1424) = 1;
  a1[2] &= 0xFFFFFFBF;
  *(_DWORD *)(v4 + 8) -= 50;
  result = v4;
  if ( *(_DWORD *)(v4 + 8) <= 0 )
  {
    *(_DWORD *)(v4 + 8) = 0;
    result = *(_DWORD *)(a2[86] + 10172) & 1;
    if ( (_BYTE)result )
    {
      *(_DWORD *)(v4 + 8) = *(_DWORD *)(v3 + 516);
      sub_8109348(a1, a2);
      result = a1[2] | 0x40;
      a1[2] = result;
    }
  }
  return result;
}

//----- (0810948E) --------------------------------------------------------
int __cdecl sub_810948E(_DWORD *a1)
{
  int result; // eax
  int v2; // [esp+14h] [ebp-4h]

  v2 = a1[87];
  a1[33] = 0;
  result = v2;
  if ( *(_DWORD *)(v2 + 40) > 0 )
  {
    a1[33] = *(unsigned __int8 *)(v2 + 64);
    *(_DWORD *)(v2 + 40) -= 50;
    result = v2;
    if ( *(_DWORD *)(v2 + 40) <= 0 )
    {
      result = v2;
      if ( *(_BYTE *)(v2 + 66) )
      {
        a1[33] = 0;
        result = sub_811CE9E(a1, *(unsigned __int8 *)(v2 + 66));
      }
    }
  }
  return result;
}

//----- (0810950C) --------------------------------------------------------
unsigned int __cdecl sub_810950C(int a1)
{
  unsigned int result; // eax
  _DWORD *v2; // [esp+10h] [ebp-8h]
  char *v3; // [esp+14h] [ebp-4h]

  v2 = *(_DWORD **)(a1 + 348);
  v3 = (char *)&unk_8665480 + 560 * *(_DWORD *)(a1 + 336);
  v2[10] = 0;
  *(_DWORD *)(a1 + 132) = 0;
  if ( v2[9] != -1 )
  {
    if ( v2[9] == 2 )
    {
      sub_811CDA2(v3, 142, 0);
    }
    else if ( v2[9] == 1 )
    {
      sub_811CDA2(v3, 141, 0);
    }
    else
    {
      sub_811CDA2(v3, 140, 0);
    }
    v2[9] = -1;
  }
  sub_8108270((int)v3, v2 + 11, (_DWORD *)v3 + 81);
  *(_DWORD *)(*((_DWORD *)v3 + 86) + 160) &= 0xFFFFFCFF;
  *(_DWORD *)(*((_DWORD *)v3 + 86) + 1424) = 0;
  *(_DWORD *)(*((_DWORD *)v3 + 86) + 1428) = 1023;
  v3[354] = 0;
  *((_DWORD *)v3 + 29) = 0;
  *(_BYTE *)(a1 + 354) = 0;
  *(_DWORD *)(a1 + 336) = 1023;
  result = v2[1] & 0xFFFFF7FF;
  v2[1] = result;
  return result;
}

//----- (08109672) --------------------------------------------------------
int __cdecl sub_8109672(_DWORD *a1)
{
  char *v2; // [esp+14h] [ebp-4h]

  v2 = (char *)&unk_8665480 + 560 * a1[84];
  if ( v2[354] != 1 || *(_DWORD *)(*((_DWORD *)v2 + 86) + 9896) )
    return sub_810950C((int)a1);
  sub_81093B8(a1, (int *)v2);
  return sub_810948E(a1);
}

//----- (081096DE) --------------------------------------------------------
signed int __cdecl sub_81096DE(int a1, int a2, int a3)
{
  long double v3; // fst7
  float v5; // [esp+1Ch] [ebp-2Ch]
  float v6; // [esp+20h] [ebp-28h]
  signed int v7; // [esp+24h] [ebp-24h]
  int v8; // [esp+28h] [ebp-20h]
  float v9; // [esp+2Ch] [ebp-1Ch]
  float v10; // [esp+2Ch] [ebp-1Ch]
  float v11; // [esp+30h] [ebp-18h]
  int v12; // [esp+34h] [ebp-14h]
  int i; // [esp+3Ch] [ebp-Ch]

  v8 = *(_DWORD *)(a1 + 348);
  v7 = 1;
  v6 = *(float *)(a1 + 104);
  *(float *)(a1 + 104) = *(float *)(a1 + 104) + *(float *)(a1 + 112);
  if ( a3 )
  {
    v11 = *(float *)(sub_80E9270(*(_DWORD *)(a1 + 200)) + 1356);
    v12 = *(_DWORD *)(sub_80E9270(*(_DWORD *)(a1 + 200)) + 1360);
  }
  else
  {
    v11 = 200.0;
    v12 = 1128792064;
  }
  if ( *(_DWORD *)(v8 + 4) & 0x200 && *(_DWORD *)(v8 + 4) & 0x100 && v11 < 360.0 )
    v11 = 360.0;
  for ( i = 0; i <= 1; ++i )
  {
    *(&v11 + i) = *(&v11 + i) * 0.050000001;
    v9 = sub_80A6000(*(float *)(a2 + 4 * i), *(float *)(a1 + 4 * i + 104));
    if ( v9 <= (long double)*(&v11 + i) )
    {
      if ( -*(&v11 + i) > (long double)v9 )
      {
        v7 = 0;
        LODWORD(v9) = *((_DWORD *)&v11 + i) ^ 0x80000000;
      }
    }
    else
    {
      v7 = 0;
      v9 = *(&v11 + i);
    }
    *(float *)(a1 + 4 * i + 104) = *(float *)(a1 + 4 * i + 104) + v9;
  }
  v5 = *(float *)(a1 + 104);
  *(float *)(a1 + 112) = v5;
  if ( *(_DWORD *)(v8 + 4) & 0x200 )
  {
    if ( *(_DWORD *)(v8 + 4) & 0x400 )
    {
      if ( *(float *)(v8 + 60) > (long double)*(float *)(a1 + 104) )
      {
        v3 = sub_80A6000(*(float *)(v8 + 60), v6);
        goto LABEL_24;
      }
      *(_DWORD *)(v8 + 4) &= 0xFFFFFEFF;
    }
    else
    {
      if ( *(float *)(a1 + 104) > (long double)*(float *)(v8 + 60) )
      {
        v3 = sub_80A6000(*(float *)(v8 + 60), v6);
        goto LABEL_24;
      }
      *(_DWORD *)(v8 + 4) &= 0xFFFFFEFF;
    }
  }
  v3 = sub_80A6000(v5, v6);
LABEL_24:
  v10 = v3;
  if ( v10 <= (long double)v11 )
  {
    if ( -v11 > (long double)v10 )
    {
      v7 = 0;
      LODWORD(v10) = LODWORD(v11) ^ 0x80000000;
    }
  }
  else
  {
    v7 = 0;
    v10 = v11;
  }
  *(float *)(a1 + 104) = v6 + v10;
  *(float *)(a1 + 112) = *(float *)(a1 + 112) - *(float *)(a1 + 104);
  return v7;
}

//----- (08109984) --------------------------------------------------------
signed int __cdecl sub_8109984(int a1, int a2)
{
  float v3; // [esp+14h] [ebp-14h]
  float v4; // [esp+18h] [ebp-10h]
  int v5; // [esp+1Ch] [ebp-Ch]
  int v6; // [esp+24h] [ebp-4h]

  v6 = *(_DWORD *)(a1 + 348);
  if ( a2 )
    v3 = 0.0;
  else
    v3 = *(float *)(v6 + 28);
  v4 = v3;
  v5 = 0;
  return sub_81096DE(a1, (int)&v4, a2);
}

//----- (081099D6) --------------------------------------------------------
char *__cdecl sub_81099D6(_DWORD *a1)
{
  int v1; // ST10_4
  char *result; // eax

  v1 = a1[87];
  a1[100] = dword_859B5EC + 50;
  if ( a1[130] )
    sub_811BE86(a1);
  result = (char *)&unk_8665480 + 560 * a1[84];
  if ( !*((_DWORD *)result + 86) )
  {
    sub_810948E(a1);
    a1[2] &= 0xFFFFFFBF;
    result = (char *)sub_8109984((int)a1, 0);
  }
  return result;
}

//----- (08109A68) --------------------------------------------------------
int __cdecl sub_8109A68(int a1)
{
  int result; // eax
  int i; // [esp+2Ch] [ebp-FCh]
  float s; // [esp+30h] [ebp-F8h]
  int v4; // [esp+60h] [ebp-C8h]
  int v5; // [esp+70h] [ebp-B8h]
  char v6; // [esp+80h] [ebp-A8h]
  char v7; // [esp+90h] [ebp-98h]
  int v8; // [esp+A0h] [ebp-88h]
  int v9; // [esp+A4h] [ebp-84h]
  int v10; // [esp+A8h] [ebp-80h]
  char v11; // [esp+B0h] [ebp-78h]
  char v12; // [esp+E0h] [ebp-48h]
  int v13; // [esp+104h] [ebp-24h]
  int v14; // [esp+110h] [ebp-18h]
  int v15; // [esp+114h] [ebp-14h]
  int v16; // [esp+118h] [ebp-10h]
  int v17; // [esp+11Ch] [ebp-Ch]

  v17 = 30;
  v16 = *(_DWORD *)(a1 + 348);
  *(_BYTE *)(a1 + 358) = 14;
  *(_DWORD *)(a1 + 400) = dword_859B5EC + 50;
  result = sub_811C056((int *)a1, (unsigned __int16)word_87A233E);
  v15 = result;
  if ( result )
  {
    result = sub_811C056((int *)a1, (unsigned __int16)word_87A2344);
    v14 = result;
    if ( result )
    {
      sub_80A7146((float *)(a1 + 324), (int)&v12);
      sub_810A912((_DWORD *)(a1 + 312), &v13);
      sub_810A986((float *)(v14 + 16), (float *)(v15 + 16), (float *)&v7);
      result = sub_80A50D2((float *)(v15 + 16), (float *)&v12, (float *)&v5);
      for ( i = 0; i <= 30; ++i )
      {
        *(float *)&v8 = (long double)i * -3.0;
        v9 = 0;
        v10 = 0;
        sub_80A7146((float *)&v8, (int)&v11);
        sub_80A4E52((float *)&v7, (float *)&v11, (float *)&v6);
        sub_810A942((float *)(v15 + 16), (float *)&v6, (float *)&v6);
        sub_80A50D2((float *)&v6, (float *)&v12, (float *)&v4);
        sub_8108134(&s, (int)&v5, (int)&v4, *(_DWORD *)a1, 2065, (int)&unk_816778C);
        if ( s < 1.0 )
        {
          result = v8;
          *(float *)(v16 + 28) = *(float *)&v8;
          return result;
        }
        result = (int)&i;
      }
    }
  }
  return result;
}
// 87A233E: using guessed type __int16 word_87A233E;
// 87A2344: using guessed type __int16 word_87A2344;

//----- (08109C76) --------------------------------------------------------
signed int __cdecl sub_8109C76(int *a1, int a2)
{
  int v2; // ST1C_4
  int v4; // [esp+20h] [ebp-18h]
  int v5; // [esp+24h] [ebp-14h]
  int v6; // [esp+28h] [ebp-10h]

  v5 = a1[27];
  v4 = a1[26];
  v6 = 0;
  v2 = sub_806289C(*a1);
  sub_80B98CC(v2, a2, (unsigned __int16)word_87A233E, (float *)&v4);
  sub_80B98CC(v2, a2, (unsigned __int16)word_87A2340, (float *)&v4);
  v4 = a1[28];
  v5 = 0;
  return sub_80B98CC(v2, a2, (unsigned __int16)word_87A232C, (float *)&v4);
}
// 87A232C: using guessed type __int16 word_87A232C;
// 87A233E: using guessed type __int16 word_87A233E;
// 87A2340: using guessed type __int16 word_87A2340;

//----- (08109D26) --------------------------------------------------------
_BOOL4 __cdecl sub_8109D26(int a1, int a2)
{
  float v2; // ST2C_4
  float v3; // ST10_4
  float v4; // ST28_4
  float v5; // ST00_4
  float v6; // ST24_4
  float v7; // ST20_4
  float v8; // ST00_4
  float v9; // ST1C_4
  int v11; // [esp+30h] [ebp-38h]
  char v12; // [esp+40h] [ebp-28h]
  int v13; // [esp+48h] [ebp-20h]
  int v14; // [esp+5Ch] [ebp-Ch]

  v14 = *(_DWORD *)(a1 + 348);
  v2 = *(float *)(a1 + 328) + *(float *)(v14 + 16);
  v3 = sub_810A840(*(float *)(v14 + 16));
  v4 = (sub_810A840(*(float *)(v14 + 24)) + v3) * 0.5;
  v5 = v2 + v4;
  v6 = sub_80A6112(v5);
  sub_80A303A(v6, (int)&v11, 0);
  sub_80A20C0((float *)&v11);
  sub_810A986((float *)(a1 + 312), (float *)(a2 + 312), (float *)&v12);
  v13 = 0;
  sub_80A20C0((float *)&v12);
  v7 = sub_810AA1E((float *)&v11, (float *)&v12);
  v8 = sub_810A85A(v7, -1.0, 1.0);
  v9 = sub_80A1B68(v8) * 57.29577951308232;
  return v9 <= (long double)v4;
}

//----- (08109E54) --------------------------------------------------------
int __cdecl sub_8109E54(int a1)
{
  int v1; // ST10_4
  int result; // eax

  v1 = *(_DWORD *)(a1 + 348);
  if ( *((_DWORD *)&unk_8665480 + 140 * *(_DWORD *)(a1 + 336) + 86) )
    sub_810950C(a1);
  *(_BYTE *)(a1 + 354) = 0;
  **(_DWORD **)(a1 + 348) = 0;
  result = a1;
  *(_DWORD *)(a1 + 348) = 0;
  return result;
}

//----- (08109EC0) --------------------------------------------------------
_BOOL4 __cdecl sub_8109EC0(int a1, int a2)
{
  if ( *(_BYTE *)(a1 + 354) || !*(_DWORD *)(a1 + 348) )
    return 0;
  if ( !sub_8109D26(a1, a2) )
    return 0;
  if ( *(_DWORD *)(*(_DWORD *)(a2 + 344) + 60) )
    return 0;
  return *(_DWORD *)(*(_DWORD *)(a2 + 344) + 96) != 1023;
}

//----- (08109F46) --------------------------------------------------------
void __cdecl sub_8109F46(int a1, int a2)
{
  float v2; // ST00_4
  float v3; // ST00_4
  int v4; // [esp+Ch] [ebp-Ch]
  int v5; // [esp+10h] [ebp-8h]

  v5 = *(_DWORD *)(a1 + 348);
  v4 = *(_DWORD *)(a2 + 344);
  *(_BYTE *)(a2 + 354) = 1;
  *(_BYTE *)(a1 + 354) = 1;
  *(_DWORD *)(a1 + 336) = *(_DWORD *)a2;
  *(_DWORD *)(v4 + 1424) = 1;
  *(_DWORD *)(v4 + 1428) = *(_DWORD *)a1;
  *(_DWORD *)(v5 + 4) |= 0x800u;
  sub_810A912((_DWORD *)(a2 + 312), (_DWORD *)(v5 + 44));
  *(_DWORD *)(a2 + 116) = *(_DWORD *)a1;
  *(_DWORD *)(a1 + 116) = *(_DWORD *)a2;
  if ( *(_BYTE *)(v4 + 12) & 1 )
  {
    *(_DWORD *)(v5 + 36) = 2;
  }
  else if ( *(_DWORD *)(v4 + 12) & 2 )
  {
    *(_DWORD *)(v5 + 36) = 1;
  }
  else
  {
    *(_DWORD *)(v5 + 36) = 0;
  }
  if ( *(_DWORD *)(v5 + 32) == 2 )
  {
    *(_DWORD *)(v4 + 160) |= 0x100u;
    *(_DWORD *)(v4 + 160) &= 0xFFFFFDFF;
  }
  else if ( *(_DWORD *)(v5 + 32) == 1 )
  {
    *(_DWORD *)(v4 + 160) |= 0x200u;
    *(_DWORD *)(v4 + 160) &= 0xFFFFFEFF;
  }
  else
  {
    *(_DWORD *)(v4 + 160) |= 0x300u;
  }
  *(float *)(a1 + 104) = sub_80A6000(*(float *)(v4 + 232), *(float *)(a1 + 324));
  *(float *)(a1 + 104) = sub_810A85A(*(float *)(a1 + 104), *(float *)(v5 + 12), *(float *)(v5 + 20));
  *(float *)(a1 + 108) = sub_80A6000(*(float *)(v4 + 236), *(float *)(a1 + 328));
  *(float *)(a1 + 108) = sub_810A85A(*(float *)(a1 + 108), *(float *)(v5 + 16), *(float *)(v5 + 24));
  *(_DWORD *)(a1 + 112) = 0;
  *(float *)(v4 + 276) = sub_80A6000(*(float *)(v5 + 20), *(float *)(v5 + 12)) * 0.5;
  *(float *)(v4 + 268) = *(float *)(a1 + 324) + *(float *)(v5 + 20);
  v2 = *(float *)(v4 + 268) - *(float *)(v4 + 276);
  *(float *)(v4 + 268) = sub_80A6154(v2);
  *(float *)(v4 + 280) = sub_80A6000(*(float *)(v5 + 24), *(float *)(v5 + 16)) * 0.5;
  *(float *)(v4 + 272) = *(float *)(a1 + 328) + *(float *)(v5 + 24);
  v3 = *(float *)(v4 + 272) - *(float *)(v4 + 280);
  *(float *)(v4 + 272) = sub_80A6154(v3);
}

//----- (0810A21A) --------------------------------------------------------
int __cdecl sub_810A21A(int a1, char *s1)
{
  char *v2; // eax
  char *v3; // eax
  _BYTE *v4; // ebx
  _BYTE *v5; // ebx
  _BYTE *v6; // ebx
  _BYTE *v7; // ebx
  long double v8; // fst7
  int i; // [esp+18h] [ebp-10h]
  void *s; // [esp+1Ch] [ebp-Ch]
  int v12; // [esp+20h] [ebp-8h]

  s = 0;
  for ( i = 0; i <= 31; ++i )
  {
    s = &dword_8793E60[17 * i];
    if ( !*(_DWORD *)s )
      break;
  }
  if ( i == 32 )
    Com_Error(1, &byte_8153BE0, 32);
  memset(s, 0, 0x44u);
  *(_DWORD *)(a1 + 348) = s;
  *(_DWORD *)s = 1;
  *(_DWORD *)(a1 + 200) = sub_811E940(s1);
  if ( !*(_DWORD *)(a1 + 200) )
    Com_Error(1, &byte_8153C20, s1);
  v12 = sub_80E9270(*(_DWORD *)(a1 + 200));
  if ( *(_DWORD *)(v12 + 124) != 7 )
  {
    v2 = va(
           "G_SpawnTurret: weapon '%s' isn't a turret. This usually indicates that the weapon failed to load.",
           s1);
    sub_8084DB4((int)v2);
  }
  if ( !dword_859B41C && !sub_8104EA2(*(_DWORD *)(a1 + 200)) )
  {
    v3 = va("turret '%s' not precached", s1);
    sub_8084DB4((int)v3);
  }
  *((_DWORD *)s + 2) = 0;
  *((_DWORD *)s + 8) = *(_DWORD *)(v12 + 140);
  *((_DWORD *)s + 9) = -1;
  *((_DWORD *)s + 10) = 0;
  if ( *(_DWORD *)(v12 + 176) && **(_BYTE **)(v12 + 176) )
  {
    v4 = s;
    v4[64] = sub_811B1D8(*(char **)(v12 + 176));
  }
  else
  {
    *((_BYTE *)s + 64) = 0;
  }
  if ( *(_DWORD *)(v12 + 180) && **(_BYTE **)(v12 + 180) )
  {
    v5 = s;
    v5[65] = sub_811B1D8(*(char **)(v12 + 180));
  }
  else
  {
    *((_BYTE *)s + 65) = 0;
  }
  if ( *(_DWORD *)(v12 + 184) && **(_BYTE **)(v12 + 184) )
  {
    v6 = s;
    v6[66] = sub_811B1D8(*(char **)(v12 + 184));
  }
  else
  {
    *((_BYTE *)s + 66) = 0;
  }
  if ( *(_DWORD *)(v12 + 188) && **(_BYTE **)(v12 + 188) )
  {
    v7 = s;
    v7[67] = sub_811B1D8(*(char **)(v12 + 188));
  }
  else
  {
    *((_BYTE *)s + 67) = 0;
  }
  if ( !byte_859C748 || !sub_8117F76("rightarc", (int)&unk_8153CDC, (int)s + 16) )
    *((_DWORD *)s + 4) = *(_DWORD *)(v12 + 1324);
  *((_DWORD *)s + 4) ^= 0x80000000;
  if ( *((float *)s + 4) > 0.0 )
    *((_DWORD *)s + 4) = 0;
  if ( !byte_859C748 || !sub_8117F76("leftarc", (int)&unk_8153CDC, (int)s + 24) )
    *((_DWORD *)s + 6) = *(_DWORD *)(v12 + 1320);
  if ( *((float *)s + 6) < 0.0 )
    *((_DWORD *)s + 6) = 0;
  if ( !byte_859C748 || !sub_8117F76("toparc", (int)&unk_8153CDC, (int)s + 12) )
    *((_DWORD *)s + 3) = *(_DWORD *)(v12 + 1328);
  *((_DWORD *)s + 3) ^= 0x80000000;
  if ( *((float *)s + 3) > 0.0 )
    *((_DWORD *)s + 3) = 0;
  if ( !byte_859C748 || !sub_8117F76("bottomarc", (int)&unk_8153CDC, (int)s + 20) )
    *((_DWORD *)s + 5) = *(_DWORD *)(v12 + 1332);
  if ( *((float *)s + 5) < 0.0 )
    *((_DWORD *)s + 5) = 0;
  *((_DWORD *)s + 7) = -1028390912;
  if ( !*(_DWORD *)(a1 + 404) )
    *(_DWORD *)(a1 + 404) = 100;
  if ( !byte_859C748 || !sub_8117FB2("damage", (int)"0", a1 + 412) )
    *(_DWORD *)(a1 + 412) = *(_DWORD *)(v12 + 492);
  if ( *(_DWORD *)(a1 + 412) < 0 )
    *(_DWORD *)(a1 + 412) = 0;
  if ( !byte_859C748 || !sub_8117F76("playerSpread", (int)"1", (int)s + 56) )
    *((_DWORD *)s + 14) = *(_DWORD *)(v12 + 1344);
  v8 = *((float *)s + 14);
  if ( v8 < 0.0 )
    *((_DWORD *)s + 14) = 0;
  *((_DWORD *)s + 1) = 3;
  *(_DWORD *)(a1 + 388) = 1;
  *(_DWORD *)(a1 + 284) = 2097156;
  *(_BYTE *)(a1 + 242) = 0;
  *(_DWORD *)(a1 + 4) = 9;
  *(_DWORD *)(a1 + 372) |= 0x1000u;
  sub_811B20E(v8, a1);
  sub_810A8EE((_DWORD *)(a1 + 260), -1040187392, -1040187392, 0);
  sub_810A8EE((_DWORD *)(a1 + 272), 1107296256, 1107296256, 1113587712);
  sub_811CF36((_DWORD *)a1, (_DWORD *)(a1 + 312));
  sub_811CF96((_DWORD *)a1, (_DWORD *)(a1 + 324));
  sub_810A8C4((_DWORD *)(a1 + 104));
  *(_BYTE *)(a1 + 358) = 13;
  *(_DWORD *)(a1 + 400) = dword_859B5EC + 50;
  *(_DWORD *)(a1 + 48) = 3;
  *(_BYTE *)(a1 + 353) = 0;
  return sub_809A45E(a1);
}
// 859C748: using guessed type char byte_859C748;

//----- (0810A7F2) --------------------------------------------------------
int __cdecl sub_810A7F2(int a1)
{
  char v2[4]; // [esp+14h] [ebp-4h]

  if ( !sub_8117F4C("weaponinfo", (int)&unk_8153CDC, (int)v2) )
    Com_Error(1, &byte_8153D40);
  return sub_810A21A(a1, *(char **)v2);
}

//----- (0810A840) --------------------------------------------------------
long double __cdecl sub_810A840(float a1)
{
  return (float)fabs(a1);
}

//----- (0810A85A) --------------------------------------------------------
long double __cdecl sub_810A85A(float a1, float a2, float a3)
{
  float v3; // ST00_4
  float v4; // ST08_4
  float v5; // ST00_4

  v3 = a1 - a3;
  v4 = sub_810AA52(v3, a3, a1);
  v5 = a2 - a1;
  return sub_810AA52(v5, a2, v4);
}

//----- (0810A898) --------------------------------------------------------
int __cdecl sub_810A898(float *a1, float *a2, float *a3)
{
  int result; // eax

  *a3 = *a1 + *a2;
  result = (int)(a1 + 1);
  a3[1] = a1[1] + a2[1];
  return result;
}

//----- (0810A8C4) --------------------------------------------------------
int __cdecl sub_810A8C4(_DWORD *a1)
{
  int result; // eax

  *a1 = 0;
  a1[1] = 0;
  result = 0;
  a1[2] = 0;
  return result;
}

//----- (0810A8EE) --------------------------------------------------------
int __cdecl sub_810A8EE(_DWORD *a1, int a2, int a3, int a4)
{
  int result; // eax

  *a1 = a2;
  a1[1] = a3;
  result = a4;
  a1[2] = a4;
  return result;
}

//----- (0810A912) --------------------------------------------------------
int __cdecl sub_810A912(_DWORD *a1, _DWORD *a2)
{
  int result; // eax

  *a2 = *a1;
  a2[1] = a1[1];
  result = a1[2];
  a2[2] = result;
  return result;
}

//----- (0810A942) --------------------------------------------------------
int __cdecl sub_810A942(float *a1, float *a2, float *a3)
{
  int result; // eax

  *a3 = *a1 + *a2;
  a3[1] = a1[1] + a2[1];
  result = (int)(a1 + 2);
  a3[2] = a1[2] + a2[2];
  return result;
}

//----- (0810A986) --------------------------------------------------------
int __cdecl sub_810A986(float *a1, float *a2, float *a3)
{
  int result; // eax

  *a3 = *a1 - *a2;
  a3[1] = a1[1] - a2[1];
  result = (int)(a1 + 2);
  a3[2] = a1[2] - a2[2];
  return result;
}

//----- (0810A9CA) --------------------------------------------------------
int __cdecl sub_810A9CA(int a1, float a2, int a3, int a4)
{
  int result; // eax

  *(float *)a4 = a2 * *(float *)a3 + *(float *)a1;
  *(float *)(a4 + 4) = a2 * *(float *)(a3 + 4) + *(float *)(a1 + 4);
  result = a3 + 8;
  *(float *)(a4 + 8) = a2 * *(float *)(a3 + 8) + *(float *)(a1 + 8);
  return result;
}

//----- (0810AA1E) --------------------------------------------------------
long double __cdecl sub_810AA1E(float *a1, float *a2)
{
  return *a1 * *a2 + a1[1] * a2[1] + a1[2] * a2[2];
}

//----- (0810AA52) --------------------------------------------------------
long double __cdecl sub_810AA52(float a1, float a2, float a3)
{
  float v4; // [esp+0h] [ebp-4h]

  if ( a1 < 0.0 )
    v4 = a3;
  else
    v4 = a2;
  return v4;
}

//----- (0810AAB4) --------------------------------------------------------
void __cdecl sub_810AAB4(int a1, float *a2, int a3, int a4)
{
  float v4; // ST20_4
  float v5; // ST04_4
  long double v6; // fst7
  float v7; // ST04_4
  long double v8; // fst7
  float v9; // ST04_4
  char v10; // [esp+30h] [ebp-28h]
  float v11; // [esp+40h] [ebp-18h]
  float v12; // [esp+44h] [ebp-14h]
  float v13; // [esp+48h] [ebp-10h]
  int v14; // [esp+4Ch] [ebp-Ch]

  v14 = dword_859B5F0 + (signed int)((long double)(dword_859B5EC - dword_859B5F0) * *a2);
  sub_80DCEB0(a1 + 48, v14, a3);
  sub_810C716((_DWORD *)a3, &v10);
  if ( a2[3] <= 0.1 )
  {
    if ( !a4 )
    {
      v9 = (long double)((rand() & 0x7F) - 63) + *(float *)(a1 + 72);
      *(float *)(a1 + 72) = sub_80A60CE(v9);
    }
  }
  else
  {
    sub_80A86CC(*(float *)(a3 + 4), (int)(a2 + 1));
    v13 = 0.1;
    v12 = sub_80A6000(0.1, *(float *)a3);
    v11 = sub_810C6D2(v12);
    if ( !a4 )
    {
      sub_810C716((_DWORD *)a3, (_DWORD *)(a1 + 60));
      *(_DWORD *)(a1 + 52) = v14;
      if ( v11 >= 80.0 )
      {
        *(float *)(a1 + 72) = (sub_80A1410() * 0.30000001 + 0.85000002) * *(float *)(a1 + 72);
      }
      else
      {
        v4 = (sub_80A1410() * 0.30000001 + 0.85000002) * *(float *)(a1 + 72);
        *(_DWORD *)(a1 + 72) = LODWORD(v4) ^ 0x80000000;
      }
    }
    *(float *)a3 = sub_80A6112(*(float *)a3);
    if ( a4 || v11 < 45.0 )
    {
      if ( sub_810C6D2(*(float *)a3) <= 90.0 )
      {
        v6 = sub_80A60CE(v13);
      }
      else
      {
        v5 = v13 + 180.0;
        v6 = sub_80A60CE(v5);
      }
      *(float *)a3 = v6;
    }
    else
    {
      if ( v11 >= 80.0 )
      {
        v8 = sub_80A60CE(*(float *)a3);
      }
      else
      {
        v7 = v12 * 0.25 + *(float *)a3;
        v8 = sub_80A60CE(v7);
      }
      *(float *)a3 = v8;
    }
  }
}
// 859B5F0: using guessed type int dword_859B5F0;

//----- (0810AD10) --------------------------------------------------------
_BOOL4 __cdecl sub_810AD10(int a1, int a2)
{
  float v2; // ST08_4
  float v3; // ST40_4
  float v4; // ST3C_4
  float v5; // ST40_4
  _BOOL4 v7; // [esp+20h] [ebp-68h]
  int v8; // [esp+2Ch] [ebp-5Ch]
  int v9; // [esp+30h] [ebp-58h]
  float v10; // [esp+38h] [ebp-50h]
  float v11; // [esp+3Ch] [ebp-4Ch]
  char v12; // [esp+40h] [ebp-48h]
  int v13; // [esp+50h] [ebp-38h]
  float v14; // [esp+58h] [ebp-30h]
  int v15; // [esp+60h] [ebp-28h]
  int v16; // [esp+7Ch] [ebp-Ch]

  v16 = sub_80E9270(*(_DWORD *)(a1 + 200));
  v9 = sub_809C18C((float *)(a1 + 312), -1, 32);
  v8 = (unsigned __int8)((*(_DWORD *)(a2 + 16) & 0x1F00000) >> 20);
  sub_80DD224(
    (_DWORD *)(a1 + 12),
    dword_859B5F0 + (signed int)((long double)(dword_859B5EC - dword_859B5F0) * *(float *)a2),
    (int)&v15);
  v11 = sub_810C85A((float *)&v15, (float *)(a2 + 4));
  v2 = v11 * -2.0;
  sub_810C806((int)&v15, v2, a2 + 4, a1 + 36);
  if ( *(float *)(a2 + 12) > 0.7 )
    *(_DWORD *)(a1 + 124) = *(unsigned __int16 *)(a2 + 28);
  if ( !(*(_DWORD *)(a1 + 8) & 0x1000000) )
    goto LABEL_18;
  v10 = sub_810C88E(&v15);
  if ( v10 > 0.0 && v11 <= 0.0 )
  {
    v3 = v11 / -v10;
    v4 = (*(float *)(v16 + 4 * v8 + 1020) - *(float *)(v16 + 4 * v8 + 928)) * v3 + *(float *)(v16 + 4 * v8 + 928);
    sub_810C7CE(a1 + 36, v4, a1 + 36);
  }
  if ( *(float *)(a2 + 12) > 0.7 && sub_810C88E(a1 + 36) < 20.0 )
  {
    sub_811CF36((_DWORD *)a1, (_DWORD *)(a1 + 312));
    sub_810AAB4(a1, (float *)a2, (int)&v12, 1);
    sub_811CF96((_DWORD *)a1, &v12);
    v7 = 0;
  }
  else
  {
LABEL_18:
    sub_810C7CE(a2 + 4, 0.1, (int)&v13);
    if ( v14 > 0.0 )
      v14 = 0.0;
    sub_810C746((float *)(a1 + 312), (float *)&v13, (float *)(a1 + 312));
    sub_810C716((_DWORD *)(a1 + 312), (_DWORD *)(a1 + 24));
    *(_DWORD *)(a1 + 16) = dword_859B5EC;
    sub_810AAB4(a1, (float *)a2, (int)&v12, 0);
    sub_810C716(&v12, (_DWORD *)(a1 + 60));
    *(_DWORD *)(a1 + 52) = dword_859B5EC;
    if ( v9 )
    {
      v7 = 0;
    }
    else
    {
      sub_810C78A((float *)(a1 + 36), (float *)&v15, (float *)&v15);
      v5 = sub_810C88E(&v15);
      v7 = v5 > 100.0;
    }
  }
  return v7;
}
// 810C88E: using guessed type double __cdecl sub_810C88E(_DWORD);
// 859B5F0: using guessed type int dword_859B5F0;

//----- (0810B07A) --------------------------------------------------------
int __cdecl sub_810B07A(int a1, int a2, int a3, float *a4)
{
  int result; // eax
  int v5; // ST5C_4
  float v6; // ST14_4
  float v7; // ST10_4
  float v8; // ST0C_4
  _DWORD *v9; // [esp+4h] [ebp-84h]
  int v10; // [esp+8h] [ebp-80h]
  int v11; // [esp+Ch] [ebp-7Ch]
  _DWORD *v12; // [esp+10h] [ebp-78h]
  signed int v13; // [esp+14h] [ebp-74h]
  signed int v14; // [esp+40h] [ebp-48h]
  int v15; // [esp+50h] [ebp-38h]
  signed int *v16; // [esp+54h] [ebp-34h]
  char v17; // [esp+60h] [ebp-28h]
  int v18; // [esp+68h] [ebp-20h]
  int v19; // [esp+78h] [ebp-10h]
  int v20; // [esp+7Ch] [ebp-Ch]

  v19 = 0;
  v20 = (int)&unk_8665480 + 560 * *(unsigned __int16 *)(a2 + 28);
  *(_DWORD *)(a1 + 136) = (unsigned __int8)((*(_DWORD *)(a2 + 16) & 0x1F00000) >> 20);
  if ( !*(_BYTE *)(v20 + 353) && *(_DWORD *)(a1 + 8) & 0x1000000 )
  {
    result = sub_810AD10(a1, a2);
    if ( result )
    {
      result = a2;
      if ( !*(_BYTE *)(a2 + 35) )
        result = sub_811CDA2((_DWORD *)a1, 187, (unsigned __int8)((*(_DWORD *)(a2 + 16) & 0x1F00000) >> 20));
    }
    return result;
  }
  v16 = (signed int *)sub_80E9270(*(_DWORD *)(a1 + 200));
  v15 = dword_81678A0[10 * *(unsigned __int8 *)(a1 + 358)];
  if ( !*(_BYTE *)(v20 + 353) )
    goto LABEL_22;
  if ( *(_DWORD *)(a1 + 412) )
  {
    if ( sub_811E2C2(v20, 560 * *(_DWORD *)(a1 + 336) + 140924032) )
      v19 = 1;
    sub_80DD224((_DWORD *)(a1 + 12), dword_859B5EC, (int)&v17);
    if ( sub_810C88E(&v17) == 0.0 )
      v18 = 1065353216;
    v13 = *(_DWORD *)(a1 + 412);
    v12 = (_DWORD *)(a1 + 312);
    if ( *(_DWORD *)(a1 + 336) == 1023 )
      sub_80FF7C8((int *)v20, (int *)a1, 0, (float *)&v17, v12, v13, 0, v15, 0, 0);
    else
      sub_80FF7C8(
        (int *)v20,
        (int *)a1,
        (int *)(560 * *(_DWORD *)(a1 + 336) + 140924032),
        (float *)&v17,
        v12,
        v13,
        0,
        v15,
        0,
        0);
LABEL_22:
    if ( *(_DWORD *)(a1 + 412) )
    {
      v11 = *(_DWORD *)(a1 + 412);
      v9 = (_DWORD *)(a1 + 312);
      if ( *(_DWORD *)(a1 + 336) == 1023 )
        sub_811AA18(&dword_86F1020, v9, a4, v11, v15);
      else
        sub_811AA18((int *)(560 * *(_DWORD *)(a1 + 336) + 140924032), v9, a4, v11, v15);
    }
    v14 = 0;
    if ( v19 || *(_WORD *)(a2 + 30) )
      v14 = 1;
    v10 = (unsigned __int8)sub_80A1C2A((float *)(a2 + 4));
    if ( v14 )
      sub_811CDA2((_DWORD *)a1, 190, v10);
    else
      sub_811CDA2((_DWORD *)a1, 189, v10);
    *(_DWORD *)(a1 + 136) = (unsigned __int8)((*(_DWORD *)(a2 + 16) & 0x1F00000) >> 20);
    *(_DWORD *)(a1 + 380) = 1;
    v5 = *(_DWORD *)(a1 + 4);
    *(_DWORD *)(a1 + 4) = 0;
    *(_DWORD *)(a1 + 8) ^= 2u;
    *(_DWORD *)(a1 + 8) |= 0x20u;
    *(_DWORD *)(a1 + 372) |= 0x800u;
    sub_811D53A((int)a4, a1 + 24);
    sub_811CF36((_DWORD *)a1, a4);
    if ( v16[223] )
    {
      v6 = (long double)v16[222];
      v7 = (long double)v16[224];
      v8 = (long double)v16[223];
      sub_80FFE10(
        (int)a4,
        a1,
        *(_DWORD *)(a1 + 396),
        v8,
        v7,
        v6,
        v20,
        dword_81678A4[10 * *(unsigned __int8 *)(a1 + 358)]);
    }
    return sub_809A45E(a1);
  }
  if ( *(_DWORD *)(v20 + 344) && !*(_DWORD *)(a2 + 16) )
    *(_DWORD *)(a2 + 16) = 7340032;
  result = sub_810AD10(a1, a2);
  if ( result )
  {
    result = a2;
    if ( !*(_BYTE *)(a2 + 35) )
      result = sub_811CDA2((_DWORD *)a1, 187, (unsigned __int8)((*(_DWORD *)(a2 + 16) & 0x1F00000) >> 20));
  }
  return result;
}
// 810C88E: using guessed type double __cdecl sub_810C88E(_DWORD);
// 81678A0: using guessed type int dword_81678A0[];
// 86F1020: using guessed type int dword_86F1020;

//----- (0810B4D8) --------------------------------------------------------
int __cdecl sub_810B4D8(int a1)
{
  int result; // eax
  unsigned __int8 v2; // al
  unsigned __int8 v3; // al
  float v4; // ST18_4
  float v5; // ST14_4
  float v6; // ST10_4
  int v7; // [esp+2Ch] [ebp-7Ch]
  char s; // [esp+30h] [ebp-78h]
  int v9; // [esp+34h] [ebp-74h]
  int v10; // [esp+40h] [ebp-68h]
  void *v11; // [esp+64h] [ebp-44h]
  int v12; // [esp+68h] [ebp-40h]
  int v13; // [esp+6Ch] [ebp-3Ch]
  int v14; // [esp+70h] [ebp-38h]
  float v15; // [esp+78h] [ebp-30h]
  float v16; // [esp+80h] [ebp-28h]
  float v17; // [esp+84h] [ebp-24h]
  float v18; // [esp+88h] [ebp-20h]
  int v19; // [esp+90h] [ebp-18h]
  int v20; // [esp+94h] [ebp-14h]
  int v21; // [esp+98h] [ebp-10h]

  v7 = sub_80E9270(*(_DWORD *)(a1 + 200));
  if ( *(_DWORD *)(v7 + 132) != 2 || *(_DWORD *)(a1 + 124) != 1023 )
  {
    sub_80DCEB0(a1 + 12, dword_859B5EC, (int)&v16);
    v16 = (long double)(signed int)v16;
    v17 = (long double)(signed int)v17;
    v18 = (long double)(signed int)v18;
    sub_811CF36((_DWORD *)a1, &v16);
    v20 = 0;
    v19 = 0;
    v21 = 1065353216;
    v13 = *(_DWORD *)(a1 + 4);
    *(_DWORD *)(a1 + 4) = 0;
    *(_DWORD *)(a1 + 8) |= 0x20u;
    *(_DWORD *)(a1 + 372) |= 0x800u;
    *(_BYTE *)(a1 + 242) |= 8u;
    sub_810C716((_DWORD *)(a1 + 312), &v14);
    v15 = v15 - 16.0;
    sub_8108090(&s, a1 + 312, (int)&unk_8145E68, (int)&unk_8145E68, (int)&v14, *(_DWORD *)a1, 2065);
    if ( *(_DWORD *)(v7 + 912) == 2 )
    {
      v2 = sub_80A1C2A((float *)&v9);
      sub_811CDA2((_DWORD *)a1, 191, v2);
    }
    else
    {
      v3 = sub_80A1C2A((float *)&v9);
      sub_811CDA2((_DWORD *)a1, 188, v3);
    }
    v12 = sub_809C18C((float *)(a1 + 312), -1, 32);
    if ( v12 )
      *(_DWORD *)(a1 + 136) = 20;
    else
      *(_DWORD *)(a1 + 136) = (unsigned __int8)((v10 & 0x1F00000) >> 20);
    if ( *(_DWORD *)(v7 + 916) && **(_BYTE **)(v7 + 916) )
    {
      *(_DWORD *)(a1 + 8) |= 0x10000u;
      sub_812F34E();
      v11 = sub_8129F6A(*(_BYTE **)(v7 + 916));
      *(_DWORD *)(a1 + 84) = dword_859B5EC;
      *(_DWORD *)(a1 + 88) = dword_859B5EC + (signed int)(sub_812F544(v11) + 1.0);
    }
    else
    {
      *(_DWORD *)(a1 + 380) = 1;
    }
    if ( *(_DWORD *)(v7 + 892) )
    {
      v4 = (long double)*(signed int *)(v7 + 888);
      v5 = (long double)*(signed int *)(v7 + 896);
      v6 = (long double)*(signed int *)(v7 + 892);
      sub_80FFE10(
        a1 + 312,
        a1,
        *(_DWORD *)(a1 + 396),
        v6,
        v5,
        v4,
        a1,
        dword_81678A4[10 * *(unsigned __int8 *)(a1 + 358)]);
    }
    result = sub_809A45E(a1);
  }
  else
  {
    result = a1;
    *(_DWORD *)(a1 + 400) = 50;
  }
  return result;
}
// 812F544: using guessed type double __cdecl sub_812F544(_DWORD);

//----- (0810B894) --------------------------------------------------------
void __cdecl sub_810B894(void *s, int a2, int a3, int a4, int a5)
{
  char v5; // [esp+20h] [ebp-18h]

  sub_8108134(s, a2, a3, a4, a5, (int)&unk_816778C);
  if ( *((_BYTE *)s + 35) )
  {
    *(_DWORD *)s = 0;
    sub_810C78A((float *)a2, (float *)a3, (float *)&v5);
    sub_80A2298((float *)&v5, (int)s + 4);
  }
}

//----- (0810B90E) --------------------------------------------------------
int __cdecl sub_810B90E(void *s, int a2, int a3, int a4)
{
  int v4; // ST20_4
  int result; // eax

  v4 = *((_DWORD *)&unk_8665480 + 140 * a2 + 71);
  *((_DWORD *)&unk_8665480 + 140 * a2 + 71) = 0;
  sub_810B894(s, a3 + 312, a4, *(_DWORD *)(a3 + 336), *(_DWORD *)(a3 + 388));
  result = v4;
  *((_DWORD *)&unk_8665480 + 140 * a2 + 71) = v4;
  return result;
}

//----- (0810B988) --------------------------------------------------------
long double __cdecl sub_810B988(float a1)
{
  float v1; // ST14_4

  v1 = a1 * 0.0174532925199433;
  return (float)tan(v1);
}

//----- (0810B9B6) --------------------------------------------------------
int __cdecl sub_810B9B6(int a1)
{
  int result; // eax
  float v2; // ST04_4
  long double v3; // fst7
  int v4; // [esp+24h] [ebp-34h]
  float v5; // [esp+28h] [ebp-30h]
  signed int i; // [esp+2Ch] [ebp-2Ch]
  int v7[4]; // [esp+30h] [ebp-28h]
  int v8; // [esp+40h] [ebp-18h]

  result = *(_DWORD *)(a1 + 16) + (signed int)*(float *)(a1 + 424);
  if ( result < dword_859B5EC )
  {
    v4 = sub_80E9270(*(_DWORD *)(a1 + 200));
    sub_810C716((_DWORD *)(a1 + 36), &v8);
    sub_80A20C0((float *)&v8);
    v5 = sub_810B988(*(float *)(v4 + 1448));
    for ( i = 0; i <= 2; ++i )
      *(float *)&v7[i] = sub_80A8720(-1.0, 1.0);
    sub_810C7CE((int)v7, v5, (int)v7);
    sub_810C746((float *)&v8, (float *)v7, (float *)&v8);
    sub_80A20C0((float *)&v8);
    v2 = (long double)*(signed int *)(v4 + 900);
    sub_810C7CE((int)&v8, v2, a1 + 36);
    sub_810C716((_DWORD *)(a1 + 312), (_DWORD *)(a1 + 24));
    sub_80A2C7E((float *)&v8, a1 + 324);
    sub_811CF96((_DWORD *)a1, (_DWORD *)(a1 + 324));
    *(_DWORD *)(a1 + 16) = dword_859B5EC;
    if ( *(_DWORD *)(a1 + 372) & 0x10000 )
      v3 = *(float *)(a1 + 424) * *(float *)(v4 + 1444);
    else
      v3 = *(float *)(v4 + 1440) * 1000.0;
    *(float *)(a1 + 424) = v3;
    result = a1;
    *(_DWORD *)(a1 + 372) |= 0x10000u;
  }
  return result;
}
// 810B9B6: using guessed type int var_28[4];

//----- (0810BB8C) --------------------------------------------------------
int __cdecl sub_810BB8C(float *a1, int a2)
{
  _DWORD *v2; // ST1C_4
  int result; // eax
  char v4; // [esp+20h] [ebp-18h]
  float v5; // [esp+28h] [ebp-10h]

  sub_80A2298(a1 + 9, (int)&v4);
  if ( v5 < 0.0 )
    HIBYTE(v5) ^= 0x80u;
  v2 = (_DWORD *)sub_811CB34((_DWORD *)a1 + 78, 182);
  v2[40] = (unsigned __int8)sub_80A1C2A((float *)(a2 + 4));
  v2[54] = (unsigned __int8)sub_80A1C2A((float *)&v4);
  v2[34] = (unsigned __int8)((*(_DWORD *)(a2 + 16) & 0x1F00000) >> 20);
  result = *(_DWORD *)a1;
  v2[29] = *(_DWORD *)a1;
  return result;
}

//----- (0810BC36) --------------------------------------------------------
unsigned __int8 *__cdecl sub_810BC36(unsigned __int8 *a1)
{
  unsigned __int8 *result; // eax
  int v2; // [esp+2Ch] [ebp-BCh]
  int v3; // [esp+30h] [ebp-B8h]
  float v4; // [esp+38h] [ebp-B0h]
  int v5; // [esp+4Ch] [ebp-9Ch]
  char v6; // [esp+50h] [ebp-98h]
  float v7; // [esp+60h] [ebp-88h]
  int v8; // [esp+64h] [ebp-84h]
  int v9; // [esp+68h] [ebp-80h]
  float v10; // [esp+6Ch] [ebp-7Ch]
  int v11; // [esp+70h] [ebp-78h]
  int v12; // [esp+74h] [ebp-74h]
  int v13; // [esp+78h] [ebp-70h]
  int v14; // [esp+7Ch] [ebp-6Ch]
  int v15; // [esp+80h] [ebp-68h]
  float s; // [esp+90h] [ebp-58h]
  int v17; // [esp+94h] [ebp-54h]
  int v18; // [esp+98h] [ebp-50h]
  float v19; // [esp+9Ch] [ebp-4Ch]
  int v20; // [esp+A0h] [ebp-48h]
  int v21; // [esp+A4h] [ebp-44h]
  int v22; // [esp+A8h] [ebp-40h]
  int v23; // [esp+ACh] [ebp-3Ch]
  int v24; // [esp+B0h] [ebp-38h]
  char v25; // [esp+C0h] [ebp-28h]
  int v26; // [esp+D0h] [ebp-18h]
  float v27; // [esp+D8h] [ebp-10h]

  if ( !*((_DWORD *)a1 + 3) && *((_DWORD *)a1 + 31) != 1022 )
  {
    sub_810C716((_DWORD *)a1 + 78, &v26);
    v27 = v27 - 1.5;
    sub_810B894(&s, (int)(a1 + 312), (int)&v26, *((_DWORD *)a1 + 84), *((_DWORD *)a1 + 97));
    if ( s == 1.0 )
    {
      *((_DWORD *)a1 + 3) = 5;
      *((_DWORD *)a1 + 4) = dword_859B5EC;
      *((_DWORD *)a1 + 5) = 0;
      sub_810C716((_DWORD *)a1 + 78, (_DWORD *)a1 + 6);
      sub_810C6EC((_DWORD *)a1 + 9);
    }
  }
  sub_810C716((_DWORD *)a1 + 78, &v6);
  sub_80DCEB0((int)(a1 + 12), dword_859B5EC, (int)&v26);
  sub_810C78A((float *)&v26, (float *)a1 + 78, (float *)&v25);
  if ( sub_80A20C0((float *)&v25) < 0.001 )
    return (unsigned __int8 *)sub_81079C8((int)a1);
  if ( sub_810C6D2(*((float *)a1 + 11)) <= 30.0 || sub_809C18C((float *)a1 + 78, -1, 32) )
    sub_810B894(&s, (int)(a1 + 312), (int)&v26, *((_DWORD *)a1 + 84), *((_DWORD *)a1 + 97));
  else
    sub_810B894(&s, (int)(a1 + 312), (int)&v26, *((_DWORD *)a1 + 84), *((_DWORD *)a1 + 97) | 0x20);
  if ( (v20 & 0x1F00000) == 20971520 )
  {
    sub_810BB8C((float *)a1, (int)&s);
    sub_810B894(&s, (int)(a1 + 312), (int)&v26, *((_DWORD *)a1 + 84), *((_DWORD *)a1 + 97));
  }
  v5 = dword_81678A0[10 * a1[358]];
  if ( v5 == 3 && word_86655F4[280 * (unsigned __int16)v23] < 0 )
    sub_810B90E(&s, (unsigned __int16)v23, (int)a1, (int)&v26);
  sub_80DEB7A((int)(a1 + 312), (int)&v26, s, (int)&v3);
  sub_810C716(&v3, (_DWORD *)a1 + 78);
  if ( *((_DWORD *)a1 + 2) & 0x1000000 && (s == 1.0 || s < 1.0 && v19 > 0.69999999) )
  {
    sub_810C716((_DWORD *)a1 + 78, &v26);
    v27 = v27 - 1.5;
    sub_810B894(&v7, (int)(a1 + 312), (int)&v26, *((_DWORD *)a1 + 84), *((_DWORD *)a1 + 97));
    if ( v7 != 1.0 && (_WORD)v14 == 1022 )
    {
      s = v7;
      v17 = v8;
      v18 = v9;
      v19 = v10;
      v20 = v11;
      v21 = v12;
      v22 = v13;
      v23 = v14;
      v24 = v15;
      sub_80DEB7A((int)(a1 + 312), (int)&v26, v7, (int)&v3);
      *((float *)a1 + 8) = v4 + 1.5 - *((float *)a1 + 80) + *((float *)a1 + 8);
      sub_810C716(&v3, (_DWORD *)a1 + 78);
      *((float *)a1 + 80) = *((float *)a1 + 80) + 1.5;
    }
  }
  sub_809A45E((int)a1);
  v2 = sub_80E9270(*((_DWORD *)a1 + 50));
  if ( v5 == 3 )
    sub_811AC06((int *)a1, &v6, (float *)a1 + 78, *(_DWORD *)(v2 + 892), 3);
  if ( s == 1.0 )
  {
    if ( sub_810C88E(a1 + 36) != 0.0 )
    {
      *((_DWORD *)a1 + 31) = 1023;
      if ( *(_DWORD *)(v2 + 120) == 2 && !(*((_DWORD *)a1 + 93) & 0x20000) )
        sub_810B9B6((int)a1);
    }
    return (unsigned __int8 *)sub_81079C8((int)a1);
  }
  if ( v20 & 0x10 )
    return (unsigned __int8 *)sub_811C9C0(1.0, a1);
  sub_810B07A((int)a1, (int)&s, (int)&v25, (float *)&v3);
  result = a1;
  if ( *((_DWORD *)a1 + 1) == 4 )
    return (unsigned __int8 *)sub_81079C8((int)a1);
  return result;
}
// 810C88E: using guessed type double __cdecl sub_810C88E(_DWORD);
// 81678A0: using guessed type int dword_81678A0[];
// 86655F4: using guessed type __int16 word_86655F4[];

//----- (0810C1F6) --------------------------------------------------------
int __cdecl sub_810C1F6(_DWORD *a1, _DWORD *a2, float *a3, int a4, int a5)
{
  int v5; // ST20_4
  float v6; // ST04_4
  int v8; // [esp+20h] [ebp-8h]

  v8 = sub_811C546();
  if ( a1[86] && *(_DWORD *)(a1[86] + 60) )
  {
    *(_DWORD *)(v8 + 400) = dword_859B5EC + *(_DWORD *)(a1[86] + 60);
    *(_DWORD *)(a1[86] + 60) = 0;
  }
  else
  {
    *(_DWORD *)(v8 + 400) = dword_859B5EC + a5;
  }
  if ( a1[86] )
    *(_DWORD *)(a1[86] + 60) = 0;
  *(_BYTE *)(v8 + 358) = 7;
  *(_DWORD *)(v8 + 4) = 4;
  *(_BYTE *)(v8 + 242) = 8;
  *(_DWORD *)(v8 + 200) = a4;
  *(_DWORD *)(v8 + 336) = *a1;
  *(_DWORD *)(v8 + 396) = a1;
  v5 = sub_80E9270(a4);
  sub_8079790((_WORD *)(v8 + 360), (unsigned __int16)word_87A22BA);
  *(_DWORD *)(v8 + 412) = *(_DWORD *)(v5 + 492);
  *(_DWORD *)(v8 + 8) = 0x1000000;
  *(_DWORD *)(v8 + 388) = 41953425;
  *(_DWORD *)(v8 + 84) = dword_859B5EC + 50;
  *(_DWORD *)(v8 + 12) = 5;
  *(_DWORD *)(v8 + 16) = dword_859B5EC;
  sub_810C716(a2, (_DWORD *)(v8 + 24));
  sub_810C716(a3, (_DWORD *)(v8 + 36));
  *(float *)(v8 + 36) = (long double)(signed int)*(float *)(v8 + 36);
  *(float *)(v8 + 40) = (long double)(signed int)*(float *)(v8 + 40);
  *(float *)(v8 + 44) = (long double)(signed int)*(float *)(v8 + 44);
  *(_DWORD *)(v8 + 48) = 2;
  *(_DWORD *)(v8 + 52) = dword_859B5EC;
  sub_80A2C7E(a3, v8 + 60);
  v6 = *(float *)(v8 + 60) - 120.0;
  *(float *)(v8 + 60) = sub_80A60CE(v6);
  *(float *)(v8 + 72) = sub_80A8720(-45.0, 45.0) + 720.0;
  *(_DWORD *)(v8 + 76) = 0;
  *(float *)(v8 + 80) = sub_80A8720(-45.0, 45.0) + 360.0;
  sub_810C716(a2, (_DWORD *)(v8 + 312));
  sub_810C716((_DWORD *)(v8 + 60), (_DWORD *)(v8 + 324));
  return v8;
}
// 87A22BA: using guessed type __int16 word_87A22BA;

//----- (0810C4A0) --------------------------------------------------------
int __cdecl sub_810C4A0(_DWORD *a1, _DWORD *a2, float *a3)
{
  _DWORD *v3; // ST24_4
  int v4; // ST28_4
  float v5; // ST08_4

  sub_80A20C0(a3);
  v3 = (_DWORD *)sub_80E9270(a1[50]);
  v4 = sub_811C546();
  sub_8079790((_WORD *)(v4 + 360), (unsigned __int16)word_87A22DE);
  *(_DWORD *)(v4 + 400) = dword_859B5EC + 30000;
  *(_BYTE *)(v4 + 358) = 8;
  *(_DWORD *)(v4 + 4) = 4;
  *(_DWORD *)(v4 + 8) |= 0x400u;
  *(_BYTE *)(v4 + 242) = 8;
  *(_DWORD *)(v4 + 200) = a1[50];
  *(_DWORD *)(v4 + 336) = *a1;
  *(_DWORD *)(v4 + 396) = a1;
  *(_DWORD *)(v4 + 412) = v3[123];
  *(_DWORD *)(v4 + 388) = 41953425;
  *(_DWORD *)(v4 + 84) = dword_859B5EC + 50;
  *(_DWORD *)(v4 + 12) = 2;
  *(_DWORD *)(v4 + 16) = dword_859B5EC - 50;
  sub_810C716(a2, (_DWORD *)(v4 + 24));
  v5 = (long double)(signed int)v3[225];
  sub_810C7CE((int)a3, v5, v4 + 36);
  *(float *)(v4 + 36) = (long double)(signed int)*(float *)(v4 + 36);
  *(float *)(v4 + 40) = (long double)(signed int)*(float *)(v4 + 40);
  *(float *)(v4 + 44) = (long double)(signed int)*(float *)(v4 + 44);
  sub_810C716(a2, (_DWORD *)(v4 + 312));
  sub_80A2C7E(a3, v4 + 324);
  sub_811CF96((_DWORD *)v4, (_DWORD *)(v4 + 324));
  *(float *)(v4 + 424) = (long double)(signed int)v3[363] / (long double)(signed int)v3[225] * 1000.0;
  *(_DWORD *)(v4 + 372) |= a1[93] & 0x20000;
  return v4;
}
// 87A22DE: using guessed type __int16 word_87A22DE;

//----- (0810C6D2) --------------------------------------------------------
long double __cdecl sub_810C6D2(float a1)
{
  return (float)fabs(a1);
}

//----- (0810C6EC) --------------------------------------------------------
int __cdecl sub_810C6EC(_DWORD *a1)
{
  int result; // eax

  *a1 = 0;
  a1[1] = 0;
  result = 0;
  a1[2] = 0;
  return result;
}

//----- (0810C716) --------------------------------------------------------
int __cdecl sub_810C716(_DWORD *a1, _DWORD *a2)
{
  int result; // eax

  *a2 = *a1;
  a2[1] = a1[1];
  result = a1[2];
  a2[2] = result;
  return result;
}

//----- (0810C746) --------------------------------------------------------
int __cdecl sub_810C746(float *a1, float *a2, float *a3)
{
  int result; // eax

  *a3 = *a1 + *a2;
  a3[1] = a1[1] + a2[1];
  result = (int)(a1 + 2);
  a3[2] = a1[2] + a2[2];
  return result;
}

//----- (0810C78A) --------------------------------------------------------
int __cdecl sub_810C78A(float *a1, float *a2, float *a3)
{
  int result; // eax

  *a3 = *a1 - *a2;
  a3[1] = a1[1] - a2[1];
  result = (int)(a1 + 2);
  a3[2] = a1[2] - a2[2];
  return result;
}

//----- (0810C7CE) --------------------------------------------------------
int __cdecl sub_810C7CE(int a1, float a2, int a3)
{
  int result; // eax

  *(float *)a3 = a2 * *(float *)a1;
  *(float *)(a3 + 4) = a2 * *(float *)(a1 + 4);
  result = a1 + 8;
  *(float *)(a3 + 8) = a2 * *(float *)(a1 + 8);
  return result;
}

//----- (0810C806) --------------------------------------------------------
int __cdecl sub_810C806(int a1, float a2, int a3, int a4)
{
  int result; // eax

  *(float *)a4 = a2 * *(float *)a3 + *(float *)a1;
  *(float *)(a4 + 4) = a2 * *(float *)(a3 + 4) + *(float *)(a1 + 4);
  result = a3 + 8;
  *(float *)(a4 + 8) = a2 * *(float *)(a3 + 8) + *(float *)(a1 + 8);
  return result;
}

//----- (0810C85A) --------------------------------------------------------
long double __cdecl sub_810C85A(float *a1, float *a2)
{
  return *a1 * *a2 + a1[1] * a2[1] + a1[2] * a2[2];
}

//----- (0810C88E) --------------------------------------------------------
void __cdecl sub_810C88E(float *a1)
{
  float v1; // ST00_4

  v1 = *a1 * *a1 + a1[1] * a1[1] + a1[2] * a1[2];
  sub_810C8CC(v1);
}

//----- (0810C8CC) --------------------------------------------------------
long double __cdecl sub_810C8CC(float a1)
{
  return (float)sqrt(a1);
}

//----- (0810C8EC) --------------------------------------------------------
int __cdecl sub_810C8EC(int *a1, int a2)
{
  int v3; // [esp+28h] [ebp-40h]
  signed int v4; // [esp+2Ch] [ebp-3Ch]
  char s; // [esp+30h] [ebp-38h]
  unsigned __int16 v6; // [esp+4Ch] [ebp-1Ch]
  char v7; // [esp+52h] [ebp-16h]
  char v8; // [esp+53h] [ebp-15h]

  if ( a1[97] )
  {
    if ( a1[71] & 0x4000000 )
      return 0;
    v4 = a1[97];
  }
  else
  {
    v4 = 2065;
  }
  if ( a1[1] == 4 )
    sub_8108090(&s, a2, (int)(a1 + 65), (int)(a1 + 68), a2, a1[84], v4);
  else
    sub_8108090(&s, a2, (int)(a1 + 65), (int)(a1 + 68), a2, *a1, v4);
  if ( v8 || v7 )
    v3 = 560 * v6 + 140924032;
  else
    v3 = 0;
  return v3;
}

//----- (0810C9F0) --------------------------------------------------------
unsigned int __cdecl sub_810C9F0(float *a1, int a2)
{
  sub_80A2EC2(a1, a2, (float *)(a2 + 12), (float *)(a2 + 24));
  return sub_810DC22((_DWORD *)(a2 + 12));
}

//----- (0810CA2C) --------------------------------------------------------
int *__cdecl sub_810CA2C(int a1, int a2)
{
  int *result; // eax
  signed int j; // [esp+0h] [ebp-Ch]
  int i; // [esp+4h] [ebp-8h]

  for ( i = 0; i <= 2; ++i )
  {
    for ( j = 0; j <= 2; ++j )
      *(_DWORD *)(a2 + 4 * (j + 3 * i)) = *(_DWORD *)(a1 + 4 * (i + 3 * j));
    result = &i;
  }
  return result;
}

//----- (0810CA98) --------------------------------------------------------
int __cdecl sub_810CA98(int a1, float *a2)
{
  long double v2; // fst7
  int result; // eax
  float v4[6]; // [esp+10h] [ebp-18h]

  sub_810DBF2((_DWORD *)a1, v4);
  *(float *)a1 = sub_810DCE8(a2, v4);
  *(float *)(a1 + 4) = sub_810DCE8(a2 + 3, v4);
  v2 = sub_810DCE8(a2 + 6, v4);
  result = a1 + 8;
  *(float *)(a1 + 8) = v2;
  return result;
}

//----- (0810CB04) --------------------------------------------------------
signed int __cdecl sub_810CB04(int a1, int a2, float *a3, float *a4)
{
  signed int v5; // [esp+14h] [ebp-E4h]
  float v6[6]; // [esp+20h] [ebp-D8h]
  int i; // [esp+38h] [ebp-C0h]
  float v8; // [esp+3Ch] [ebp-BCh]
  int k; // [esp+40h] [ebp-B8h]
  float v10; // [esp+44h] [ebp-B4h]
  int j; // [esp+48h] [ebp-B0h]
  float v12; // [esp+4Ch] [ebp-ACh]
  char v13; // [esp+50h] [ebp-A8h]
  char v14; // [esp+80h] [ebp-78h]
  int v15; // [esp+BCh] [ebp-3Ch]
  float v16[4]; // [esp+C0h] [ebp-38h]
  float v17[4]; // [esp+D0h] [ebp-28h]
  float v18[6]; // [esp+E0h] [ebp-18h]

  sub_810DC60((float *)(a1 + 312), a3, v6);
  sub_810C9F0(a4, (int)&v13);
  sub_810CA2C((int)&v13, (int)&v14);
  sub_810DCA4(v6, (float *)(a2 + 312), v18);
  sub_810DBF2(v18, v17);
  sub_810CA98((int)v17, (float *)&v14);
  sub_810DCA4(v17, v18, v16);
  sub_810DC60(v6, v16, v6);
  v15 = sub_810C8EC((int *)a1, (int)v6);
  if ( v15 )
  {
    if ( *(float *)(a1 + 272) / 2.0 <= 4.0 )
      goto LABEL_39;
    sub_810DBF2(v6, v18);
    v8 = 0.0;
LABEL_9:
    if ( *(float *)(a1 + 272) / 2.0 <= v8 )
    {
LABEL_39:
      v15 = sub_810C8EC((int *)a1, a1 + 312);
      if ( v15 )
      {
        v5 = 0;
      }
      else
      {
        *(_DWORD *)(a1 + 124) = 1023;
        v5 = 1;
      }
    }
    else
    {
      for ( i = LODWORD(v8) ^ 0x80000000; ; *(float *)&i = v8 + v8 + *(float *)&i )
      {
        if ( v8 < (long double)*(float *)&i )
        {
LABEL_32:
          v8 = v8 + 4.0;
          goto LABEL_9;
        }
        v12 = 4.0;
LABEL_13:
        if ( *(float *)(a1 + 272) / 2.0 > v12 )
          break;
        if ( *(float *)&i == 0.0 )
          goto LABEL_32;
      }
      for ( j = LODWORD(v12) ^ 0x80000000; ; *(float *)&j = v12 + v12 + *(float *)&j )
      {
        if ( v12 < (long double)*(float *)&j )
        {
          v12 = v12 + 4.0;
          goto LABEL_13;
        }
        v10 = 4.0;
LABEL_17:
        if ( *(float *)(a1 + 272) / 2.0 > v10 )
          break;
      }
      for ( k = LODWORD(v10) ^ 0x80000000; ; *(float *)&k = v10 + v10 + *(float *)&k )
      {
        if ( v10 < (long double)*(float *)&k )
        {
          v10 = v10 + 4.0;
          goto LABEL_17;
        }
        sub_810DBCE(v16, j, k, i);
        sub_810DC60(v18, v16, v17);
        v15 = sub_810C8EC((int *)a1, (int)v17);
        if ( !v15 )
          break;
      }
      if ( *(_DWORD *)(a1 + 124) != *(_DWORD *)a2 )
        *(_DWORD *)(a1 + 124) = 1023;
      sub_810DBF2(v17, (_DWORD *)(a1 + 312));
      sub_810DBF2(v17, (_DWORD *)(a1 + 24));
      if ( *(_DWORD *)(a1 + 344) )
      {
        *(_DWORD *)(*(_DWORD *)(a1 + 344) + 88) += (unsigned __int16)(signed int)(a4[1] * 182.04445);
        sub_810DBF2(v17, (_DWORD *)(*(_DWORD *)(a1 + 344) + 20));
      }
      dword_879C700 += 32;
      v5 = 1;
    }
  }
  else
  {
    if ( *(_DWORD *)(a1 + 124) != *(_DWORD *)a2 )
      *(_DWORD *)(a1 + 124) = 1023;
    sub_810DBF2(v6, (_DWORD *)(a1 + 312));
    sub_810DBF2(v6, (_DWORD *)(a1 + 24));
    if ( *(_DWORD *)(a1 + 344) )
    {
      *(_DWORD *)(*(_DWORD *)(a1 + 344) + 88) += (unsigned __int16)(signed int)(a4[1] * 182.04445);
      sub_810DBF2(v6, (_DWORD *)(*(_DWORD *)(a1 + 344) + 20));
    }
    dword_879C700 += 32;
    v5 = 1;
  }
  return v5;
}
// 879C700: using guessed type int dword_879C700;

//----- (0810D058) --------------------------------------------------------
int __cdecl sub_810D058(int a1, float *a2, float *a3, _DWORD *a4)
{
  unsigned __int8 v5; // [esp+3Bh] [ebp-206Dh]
  float v6; // [esp+3Ch] [ebp-206Ch]
  float v7[4]; // [esp+40h] [ebp-2068h]
  float v8[6]; // [esp+50h] [ebp-2058h]
  int v9; // [esp+68h] [ebp-2040h]
  int v10; // [esp+6Ch] [ebp-203Ch]
  int v11[1024]; // [esp+70h] [ebp-2038h]
  int v12[1024]; // [esp+1070h] [ebp-1038h]
  float v13; // [esp+2070h] [ebp-38h]
  float v14; // [esp+2074h] [ebp-34h]
  float v15; // [esp+2078h] [ebp-30h]
  float v16; // [esp+2080h] [ebp-28h]
  float v17; // [esp+2084h] [ebp-24h]
  float v18; // [esp+2088h] [ebp-20h]
  int v19; // [esp+2094h] [ebp-14h]
  int j; // [esp+2098h] [ebp-10h]
  int i; // [esp+209Ch] [ebp-Ch]

  *a4 = 0;
  v5 = 1;
  if ( *(float *)(a1 + 324) != 0.0
    || *(float *)(a1 + 328) != 0.0
    || *(float *)(a1 + 332) != 0.0
    || *a3 != 0.0
    || a3[1] != 0.0
    || a3[2] != 0.0 )
  {
    v6 = sub_80A626E(a1 + 260, a1 + 272);
    for ( i = 0; i <= 2; ++i )
    {
      *(&v16 + i) = *(float *)(a1 + 4 * i + 312) - v6 + a2[i];
      *(&v13 + i) = *(float *)(a1 + 4 * i + 312) + v6 + a2[i];
      v8[i] = *(float *)(a1 + 4 * i + 312) - v6;
      v7[i] = *(float *)(a1 + 4 * i + 312) + v6;
    }
  }
  else
  {
    for ( i = 0; i <= 2; ++i )
    {
      *(&v16 + i) = *(float *)(a1 + 4 * i + 288) + a2[i];
      *(&v13 + i) = *(float *)(a1 + 4 * i + 300) + a2[i];
    }
    sub_810DBF2((_DWORD *)(a1 + 288), v8);
    sub_810DBF2((_DWORD *)(a1 + 300), v7);
  }
  for ( i = 0; i <= 2; ++i )
  {
    if ( a2[i] <= 0.0 )
      v8[i] = v8[i] + a2[i];
    else
      v7[i] = v7[i] + a2[i];
  }
  sub_809A3BA(a1);
  v10 = sub_805E782((int)v8, (int)v7, (int)v12, 1024, 33554816);
  sub_810DC60((float *)(a1 + 312), a2, (float *)(a1 + 312));
  sub_810DC60((float *)(a1 + 324), a3, (float *)(a1 + 324));
  sub_809A45E(a1);
  v9 = 0;
  for ( j = 0; j < v10; ++j )
  {
    v19 = (int)&unk_8665480 + 560 * v12[j];
    if ( (*(_DWORD *)(v19 + 4) == 4 || *(_DWORD *)(v19 + 4) == 3 || *(_DWORD *)(v19 + 4) == 1 || *(_BYTE *)(v19 + 352))
      && (*(_DWORD *)(v19 + 124) == *(_DWORD *)a1
       || *(float *)(v19 + 288) < (long double)v13
       && *(float *)(v19 + 292) < (long double)v14
       && *(float *)(v19 + 296) < (long double)v15
       && v16 < (long double)*(float *)(v19 + 300)
       && v17 < (long double)*(float *)(v19 + 304)
       && v18 < (long double)*(float *)(v19 + 308)
       && sub_810C8EC((int *)v19, v19 + 312) == a1) )
    {
      v11[v9++] = v12[j];
    }
  }
  for ( j = 0; j < v9; ++j )
  {
    v19 = (int)&unk_8665480 + 560 * v11[j];
    sub_809A3BA(v19);
  }
  for ( j = 0; j < v9; ++j )
  {
    v19 = (int)&unk_8665480 + 560 * v11[j];
    *(_DWORD *)dword_879C700 = v19;
    sub_810DBF2((_DWORD *)(v19 + 312), (_DWORD *)(dword_879C700 + 4));
    *(float *)(dword_879C700 + 28) = a3[1];
    if ( sub_810CB04(v19, a1, a2, a3) )
    {
      sub_809A45E(v19);
    }
    else if ( *(_DWORD *)(v19 + 4) == 3 )
    {
      sub_809A45E(v19);
    }
    else if ( *(_DWORD *)(a1 + 12) != 4 && *(_DWORD *)(a1 + 48) != 4 )
    {
      *a4 = v19;
      v5 = 0;
    }
    else
    {
      sub_80FF7C8((int *)v19, (int *)a1, (int *)a1, 0, 0, 99999, 0, 9u, 0, 0);
    }
  }
  for ( j = 0; j < v9; ++j )
  {
    v19 = (int)&unk_8665480 + 560 * v11[j];
    sub_809A45E(v19);
  }
  return v5;
}
// 80A626E: using guessed type double __cdecl sub_80A626E(_DWORD, _DWORD);
// 879C700: using guessed type int dword_879C700;
// 810D058: using guessed type float var_2058[6];
// 810D058: using guessed type float var_2068[4];
// 810D058: using guessed type int var_1038[1024];
// 810D058: using guessed type int var_2038[1024];

//----- (0810D672) --------------------------------------------------------
int __cdecl sub_810D672(int a1)
{
  int result; // eax
  void (__cdecl *v2)(int); // [esp+20h] [ebp-68h]
  int (__cdecl *v3)(int); // [esp+20h] [ebp-68h]
  int (__cdecl *v4)(int, int); // [esp+24h] [ebp-64h]
  unsigned int i; // [esp+28h] [ebp-60h]
  int v6; // [esp+2Ch] [ebp-5Ch]
  char v7; // [esp+30h] [ebp-58h]
  char v8; // [esp+40h] [ebp-48h]
  int v9; // [esp+5Ch] [ebp-2Ch]
  char v10; // [esp+60h] [ebp-28h]
  char v11; // [esp+70h] [ebp-18h]

  v9 = 0;
  dword_879C700 = (int)&unk_8794700;
  sub_80DCEB0(a1 + 12, dword_859B5EC, (int)&v8);
  sub_80DCEB0(a1 + 48, dword_859B5EC, (int)&v7);
  sub_810DCA4((float *)&v8, (float *)(a1 + 312), (float *)&v11);
  sub_810DCA4((float *)&v7, (float *)(a1 + 324), (float *)&v10);
  if ( (unsigned __int8)sub_810D058(a1, (float *)&v11, (float *)&v10, &v9) )
  {
    if ( *(_DWORD *)(a1 + 12) )
    {
      if ( dword_859B5EC >= *(_DWORD *)(a1 + 16) + *(_DWORD *)(a1 + 20) )
      {
        v2 = (void (__cdecl *)(int))dword_8167884[10 * *(unsigned __int8 *)(a1 + 358)];
        if ( v2 )
          v2(a1);
      }
    }
    result = a1;
    if ( *(_DWORD *)(a1 + 48) )
    {
      result = *(_DWORD *)(a1 + 52) + *(_DWORD *)(a1 + 56);
      if ( dword_859B5EC >= result )
      {
        result = dword_8167884[10 * *(unsigned __int8 *)(a1 + 358)];
        v3 = (int (__cdecl *)(int))dword_8167884[10 * *(unsigned __int8 *)(a1 + 358)];
        if ( v3 )
          result = v3(a1);
      }
    }
  }
  else
  {
    for ( i = dword_879C700 - 32; i >= (unsigned int)&unk_8794700; i -= 32 )
    {
      v6 = *(_DWORD *)i;
      sub_810DBF2((_DWORD *)(i + 4), (_DWORD *)(*(_DWORD *)i + 312));
      sub_810DBF2((_DWORD *)(i + 4), (_DWORD *)(v6 + 24));
      if ( *(_DWORD *)(v6 + 344) )
      {
        *(_DWORD *)(*(_DWORD *)(v6 + 344) + 88) -= (unsigned __int16)(signed int)(*(float *)(i + 28) * 182.04445);
        sub_810DBF2((_DWORD *)(i + 4), (_DWORD *)(*(_DWORD *)(v6 + 344) + 20));
      }
      sub_809A45E(v6);
    }
    *(_DWORD *)(a1 + 16) += dword_859B5EC - dword_859B5F0;
    *(_DWORD *)(a1 + 52) += dword_859B5EC - dword_859B5F0;
    sub_80DCEB0(a1 + 12, dword_859B5EC, a1 + 312);
    sub_80DCEB0(a1 + 48, dword_859B5EC, a1 + 324);
    sub_809A45E(a1);
    result = dword_8167888[10 * *(unsigned __int8 *)(a1 + 358)];
    v4 = (int (__cdecl *)(int, int))dword_8167888[10 * *(unsigned __int8 *)(a1 + 358)];
    if ( v4 )
      result = v4(a1, v9);
  }
  return result;
}
// 8167884: using guessed type int dword_8167884[];
// 8167888: using guessed type int dword_8167888[];
// 859B5F0: using guessed type int dword_859B5F0;
// 879C700: using guessed type int dword_879C700;

//----- (0810D966) --------------------------------------------------------
int __cdecl sub_810D966(_DWORD *a1)
{
  if ( a1[130] )
  {
    sub_811BE86(a1);
  }
  else if ( a1[3] || a1[12] )
  {
    sub_810D672((int)a1);
  }
  return sub_81079C8((int)a1);
}

//----- (0810D9B8) --------------------------------------------------------
unsigned int *__cdecl sub_810D9B8(int a1)
{
  unsigned int *result; // eax
  char s2; // [esp+10h] [ebp-418h]
  char *s1; // [esp+418h] [ebp-10h]
  unsigned int i; // [esp+41Ch] [ebp-Ch]

  sub_808FF44(a1);
  sub_809A45E(a1);
  *(_DWORD *)(a1 + 436) = 1023;
  *(_DWORD *)(a1 + 12) = 0;
  sub_810DBF2((_DWORD *)(a1 + 312), (_DWORD *)(a1 + 24));
  *(_DWORD *)(a1 + 284) = 0x200000;
  *(_BYTE *)(a1 + 242) = 1;
  *(_BYTE *)(a1 + 358) = 18;
  *(_DWORD *)(a1 + 220) = 2;
  if ( sub_8117F4C("cursorhint", (int)&unk_8153DE0, (int)&s1) )
  {
    if ( I_stricmp(s1, "HINT_INHERIT") )
    {
      for ( i = 1; i <= 5; ++i )
      {
        if ( !I_stricmp(s1, *(char **)&off_8167BA0[4 * i]) )
        {
          *(_DWORD *)(a1 + 220) = i;
          break;
        }
      }
    }
    else
    {
      *(_DWORD *)(a1 + 220) = -1;
    }
  }
  *(_DWORD *)(a1 + 216) = 255;
  result = (unsigned int *)sub_8117F4C("hintstring", (int)&unk_8153DE0, (int)&s1);
  if ( result )
  {
    for ( i = 0; (signed int)i <= 31; ++i )
    {
      sub_809107E(i + 1278, &s2, 1024);
      if ( !s2 )
      {
        sub_8090E6C(i + 1278, s1);
        result = (unsigned int *)(unsigned __int8)i;
        *(_DWORD *)(a1 + 216) = (unsigned __int8)i;
        break;
      }
      if ( !strcmp(s1, &s2) )
      {
        result = (unsigned int *)(unsigned __int8)i;
        *(_DWORD *)(a1 + 216) = (unsigned __int8)i;
        break;
      }
      result = &i;
    }
    if ( i == 32 )
      Com_Error(1, &byte_8153E60, 32);
  }
  return result;
}

//----- (0810DBA6) --------------------------------------------------------
unsigned int *__cdecl sub_810DBA6(int a1)
{
  return sub_810D9B8(a1);
}

//----- (0810DBBA) --------------------------------------------------------
unsigned int *__cdecl sub_810DBBA(int a1)
{
  return sub_810D9B8(a1);
}

//----- (0810DBCE) --------------------------------------------------------
int __cdecl sub_810DBCE(_DWORD *a1, int a2, int a3, int a4)
{
  int result; // eax

  *a1 = a2;
  a1[1] = a3;
  result = a4;
  a1[2] = a4;
  return result;
}

//----- (0810DBF2) --------------------------------------------------------
int __cdecl sub_810DBF2(_DWORD *a1, _DWORD *a2)
{
  int result; // eax

  *a2 = *a1;
  a2[1] = a1[1];
  result = a1[2];
  a2[2] = result;
  return result;
}

//----- (0810DC22) --------------------------------------------------------
unsigned int __cdecl sub_810DC22(_DWORD *a1)
{
  unsigned int result; // eax

  *a1 ^= 0x80000000;
  a1[1] ^= 0x80000000;
  result = a1[2] ^ 0x80000000;
  a1[2] = result;
  return result;
}

//----- (0810DC60) --------------------------------------------------------
int __cdecl sub_810DC60(float *a1, float *a2, float *a3)
{
  int result; // eax

  *a3 = *a1 + *a2;
  a3[1] = a1[1] + a2[1];
  result = (int)(a1 + 2);
  a3[2] = a1[2] + a2[2];
  return result;
}

//----- (0810DCA4) --------------------------------------------------------
int __cdecl sub_810DCA4(float *a1, float *a2, float *a3)
{
  int result; // eax

  *a3 = *a1 - *a2;
  a3[1] = a1[1] - a2[1];
  result = (int)(a1 + 2);
  a3[2] = a1[2] - a2[2];
  return result;
}

//----- (0810DCE8) --------------------------------------------------------
long double __cdecl sub_810DCE8(float *a1, float *a2)
{
  return *a1 * *a2 + a1[1] * a2[1] + a1[2] * a2[2];
}

//----- (0810DD1C) --------------------------------------------------------
int __cdecl sub_810DD1C(char *s)
{
  return sub_8079808(s);
}

//----- (0810DD38) --------------------------------------------------------
void sub_810DD38()
{
  unsigned __int16 v0; // ST16_2

  if ( dword_879C780 )
  {
    v0 = sub_808398E(dword_879C780, 0);
    sub_8083B8E(v0);
  }
}
// 879C780: using guessed type int dword_879C780;

//----- (0810DD70) --------------------------------------------------------
int __cdecl sub_810DD70(int a1, char *s, int a3)
{
  int v4; // [esp+14h] [ebp-4h]

  if ( !sub_8075C54((char *)a1) && a3 )
    Com_Error(1, &byte_8153EC0, a1);
  v4 = sub_8075874(a1, s);
  if ( !v4 && a3 )
    Com_Error(1, &byte_8153EE0, s, a1);
  return v4;
}

//----- (0810DDEE) --------------------------------------------------------
int sub_810DDEE()
{
  int result; // eax
  char s; // [esp+10h] [ebp-48h]

  Com_sprintf(&s, 0x40u, "maps/mp/gametypes/%s", *(_DWORD *)(dword_8793D80 + 8));
  dword_879C788 = sub_810DD70((int)&s, "main", 1);
  dword_879C78C = sub_810DD70((int)"maps/mp/gametypes/_callbacksetup", "CodeCallback_StartGameType", 1);
  dword_879C790 = sub_810DD70((int)"maps/mp/gametypes/_callbacksetup", "CodeCallback_PlayerConnect", 1);
  dword_879C794 = sub_810DD70((int)"maps/mp/gametypes/_callbacksetup", "CodeCallback_PlayerDisconnect", 1);
  dword_879C798 = sub_810DD70((int)"maps/mp/gametypes/_callbacksetup", "CodeCallback_PlayerDamage", 1);
  result = sub_810DD70((int)"maps/mp/gametypes/_callbacksetup", "CodeCallback_PlayerKilled", 1);
  dword_879C79C = result;
  return result;
}
// 8793D80: using guessed type int dword_8793D80;
// 879C788: using guessed type int dword_879C788;
// 879C78C: using guessed type int dword_879C78C;
// 879C790: using guessed type int dword_879C790;
// 879C794: using guessed type int dword_879C794;
// 879C798: using guessed type int dword_879C798;
// 879C79C: using guessed type int dword_879C79C;

//----- (0810DEE2) --------------------------------------------------------
int __usercall sub_810DEE2@<eax>(long double a1@<st0>)
{
  char *v1; // ST1C_4
  int result; // eax
  char s; // [esp+20h] [ebp-48h]

  v1 = Dvar_RegisterString(a1, "mapname", (int)&byte_8153FCE, 4164);
  Com_sprintf(&s, 0x40u, "maps/mp/%s", *((_DWORD *)v1 + 2));
  result = sub_810DD70((int)&s, "main", 0);
  dword_879C780 = result;
  return result;
}
// 879C780: using guessed type int dword_879C780;

//----- (0810DF4E) --------------------------------------------------------
int sub_810DF4E()
{
  int i; // [esp+4h] [ebp-4h]

  for ( i = 0; i <= 3; ++i )
    sub_807E13C(i);
  sub_81187B8();
  sub_810193A();
  return sub_8118806();
}

//----- (0810DF86) --------------------------------------------------------
int __usercall sub_810DF86@<eax>(long double a1@<st0>)
{
  sub_8075ABA();
  dword_879D82C = sub_810DD70((int)"codescripts/delete", "main", 1);
  dword_879D830 = sub_810DD70((int)"codescripts/struct", "initstructs", 1);
  dword_879D834 = sub_810DD70((int)"codescripts/struct", "createstruct", 1);
  sub_810DDEE();
  sub_810DEE2(a1);
  sub_8075E10();
  sub_810DF4E();
  return sub_8075E1E();
}
// 879D82C: using guessed type int dword_879D82C;
// 879D830: using guessed type int dword_879D830;
// 879D834: using guessed type int dword_879D834;

//----- (0810E010) --------------------------------------------------------
int *sub_810E010()
{
  int *result; // eax
  int i; // [esp+4h] [ebp-4h]

  for ( i = 0; i <= 3; ++i )
  {
    sub_807E182(i);
    result = &i;
  }
  return result;
}

//----- (0810E03A) --------------------------------------------------------
int __cdecl sub_810E03A(int a1)
{
  if ( !HIWORD(a1) )
    return 560 * (unsigned __int16)a1 + 140924032;
  sub_8084E30((int)"not an entity");
  return 0;
}

//----- (0810E074) --------------------------------------------------------
int __cdecl sub_810E074(int a1)
{
  int v1; // eax
  char *v2; // eax
  const char *v4; // [esp+30h] [ebp-8h]
  int v5; // [esp+34h] [ebp-4h]

  v5 = sub_810E03A(a1);
  if ( !*(_DWORD *)(v5 + 344) )
  {
    if ( *(_WORD *)(v5 + 364) )
      v4 = (const char *)sub_8078896(*(unsigned __int16 *)(v5 + 364));
    else
      v4 = "<undefined>";
    v1 = sub_8078896(*(unsigned __int16 *)(v5 + 360));
    v2 = va(
           "only valid on players; called on entity %i at %.0f %.0f %.0f classname %s targetname %s\n",
           (unsigned __int16)a1,
           *(float *)(v5 + 312),
           *(float *)(v5 + 316),
           *(float *)(v5 + 320),
           v1,
           v4);
    sub_8084DB4((int)v2);
  }
  return v5;
}

//----- (0810E128) --------------------------------------------------------
int sub_810E128()
{
  return Scr_AddString("0");
}

//----- (0810E13C) --------------------------------------------------------
int sub_810E13C()
{
  return Scr_AddString(&byte_8153FCE);
}

//----- (0810E150) --------------------------------------------------------
int sub_810E150()
{
  return Scr_AddString(&byte_8153FCE);
}

//----- (0810E164) --------------------------------------------------------
int sub_810E164()
{
  return Scr_AddString(&byte_8153FCE);
}

//----- (0810E178) --------------------------------------------------------
int sub_810E178()
{
  return Scr_AddString(&byte_8153FCE);
}

//----- (0810E18C) --------------------------------------------------------
int sub_810E18C()
{
  int result; // eax
  int v1; // eax
  signed int i; // [esp+10h] [ebp-8h]
  int v3; // [esp+14h] [ebp-4h]

  result = dword_8793E30;
  if ( !*(_BYTE *)(dword_8793E30 + 8) )
  {
    v3 = sub_8084AEE();
    for ( i = 0; ; ++i )
    {
      result = i;
      if ( i >= v3 )
        break;
      v1 = sub_80845E4(i);
      Com_Printf("%s", v1);
    }
  }
  return result;
}
// 8793E30: using guessed type int dword_8793E30;

//----- (0810E1DC) --------------------------------------------------------
void sub_810E1DC()
{
  if ( !*(_BYTE *)(dword_8793E30 + 8) )
  {
    sub_810E18C();
    Com_Printf("\n");
  }
}
// 8793E30: using guessed type int dword_8793E30;

//----- (0810E202) --------------------------------------------------------
void __cdecl __noreturn sub_810E202(int a1, char *format)
{
  Com_Error(6, format);
}

//----- (0810E21E) --------------------------------------------------------
void __cdecl sub_810E21E(int a1, int a2, signed int a3)
{
  char *v3; // eax
  signed int i; // [esp+14h] [ebp-4h]

  if ( a3 > 1 )
  {
    for ( i = 0; i < a3; ++i )
    {
      if ( !(*(_WORD *)(_ctype_b + 2 * *(char *)(a2 + i)) & 8) && *(_BYTE *)(a2 + i) != 95 )
      {
        v3 = va(
               "Illegal localized string reference: %s must contain only alpha-numeric characters and underscores",
               a2);
        sub_8084E14(a1, (int)v3);
      }
    }
  }
}
// 8185A64: using guessed type int _ctype_b;

//----- (0810E290) --------------------------------------------------------
int __cdecl sub_810E290(signed int a1, signed int a2, int a3, int a4, int a5)
{
  char *v5; // eax
  char *v6; // eax
  char *v7; // eax
  char *v8; // eax
  char *v9; // eax
  int result; // eax
  int v11; // [esp+18h] [ebp-20h]
  char v12; // [esp+1Fh] [ebp-19h]
  const char *s; // [esp+20h] [ebp-18h]
  int v14; // [esp+24h] [ebp-14h]
  signed int v15; // [esp+28h] [ebp-10h]
  int v16; // [esp+2Ch] [ebp-Ch]
  signed int i; // [esp+30h] [ebp-8h]
  signed int j; // [esp+34h] [ebp-4h]
  signed int k; // [esp+34h] [ebp-4h]

  v12 = 1;
  v16 = 0;
  for ( i = a1; i <= a2; ++i )
  {
    v14 = sub_80849A8(i);
    if ( v14 == 3 )
    {
      s = (const char *)sub_80846DC(i);
      v15 = strlen(s);
      sub_810E21E(i, (int)s, v15);
      if ( v16 + v15 + 1 >= a5 )
      {
        v5 = va("%s is too long. Max length is %i\n", a3, a5);
        sub_8084E14(i, (int)v5);
      }
      if ( v16 )
        *(_BYTE *)(a4 + v16++) = 20;
      v12 = 1;
    }
    else if ( v14 != 1 || sub_8084A50(i) != 21 )
    {
      s = (const char *)sub_808456A(i);
      v15 = strlen(s);
      for ( j = 0; j < v15; ++j )
      {
        if ( s[j] == 20 || s[j] == 21 || s[j] == 22 )
        {
          v7 = va("bad escape character (%i) present in string", s[j]);
          sub_8084E14(i, (int)v7);
        }
        if ( *(_WORD *)(_ctype_b + 2 * s[j]) & 0x400 )
        {
          if ( *(_BYTE *)(loc_warningsAsErrors + 8) )
          {
            v8 = va("non-localized %s strings are not allowed to have letters in them: \"%s\"", a3, s);
            sub_810E202(i, v8);
          }
          Com_Printf(
            "^3WARNING: Non-localized %s string is not allowed to have letters in it. Must be changed over to a localized"
            " string: \"%s\"\n",
            a3,
            s);
          break;
        }
      }
      if ( v16 + v15 + 1 >= a5 )
      {
        v9 = va("%s is too long. Max length is %i\n", a3, a5);
        sub_8084E14(i, (int)v9);
      }
      if ( v12 )
        *(_BYTE *)(a4 + v16++) = 21;
      v12 = 0;
    }
    else
    {
      v11 = sub_8118CDE(i);
      if ( !*(_DWORD *)(v11 + 344) )
        sub_8084E14(i, (int)"Entity is not a player");
      s = va("%s^7", *(_DWORD *)(v11 + 344) + 10116);
      v15 = strlen(s);
      if ( v16 + v15 + 1 >= a5 )
      {
        v6 = va("%s is too long. Max length is %i\n", a3, a5);
        sub_8084E14(i, (int)v6);
      }
      if ( v12 )
        *(_BYTE *)(a4 + v16++) = 21;
      v12 = 0;
    }
    for ( k = 0; k < v15; ++k )
    {
      if ( s[k] != 20 && s[k] != 21 && s[k] != 22 )
        *(_BYTE *)(v16 + a4) = s[k];
      else
        *(_BYTE *)(a4 + v16) = 46;
      ++v16;
    }
  }
  result = a4 + v16;
  *(_BYTE *)(a4 + v16) = 0;
  return result;
}
// 8185A64: using guessed type int _ctype_b;
// 8523150: using guessed type int loc_warningsAsErrors;

//----- (0810E5D8) --------------------------------------------------------
int __cdecl sub_810E5D8(int a1, int a2)
{
  int v2; // eax
  char *v3; // eax
  char v5; // [esp+20h] [ebp-408h]

  v2 = sub_8084AEE();
  sub_810E290(0, v2 - 1, (int)"Game Message", (int)&v5, 1024);
  v3 = va("%s \"%s\"", a2, &v5);
  return sub_808FE96(a1, 0, (int)v3);
}

//----- (0810E64A) --------------------------------------------------------
int sub_810E64A()
{
  char *v0; // eax

  v0 = va("%c", 102);
  return sub_810E5D8(-1, (int)v0);
}

//----- (0810E676) --------------------------------------------------------
int sub_810E676()
{
  char *v0; // eax

  v0 = va("%c", 103);
  return sub_810E5D8(-1, (int)v0);
}

//----- (0810E6A2) --------------------------------------------------------
void sub_810E6A2()
{
  float v0; // ST1C_4
  unsigned int v1; // [esp+18h] [ebp-50h]
  char v2; // [esp+20h] [ebp-48h]
  int v3; // [esp+30h] [ebp-38h]
  int v4; // [esp+34h] [ebp-34h]
  int v5; // [esp+38h] [ebp-30h]
  float v6; // [esp+3Ch] [ebp-2Ch]
  int v7; // [esp+4Ch] [ebp-1Ch]
  char v8; // [esp+50h] [ebp-18h]

  v3 = 1065353216;
  v4 = 1065353216;
  v5 = 1065353216;
  v6 = 1.0;
  v1 = sub_8084AEE();
  if ( v1 == 3 )
    goto LABEL_8;
  if ( v1 > 3 )
  {
    if ( v1 == 4 )
    {
LABEL_7:
      v6 = sub_8084320(3u);
LABEL_8:
      sub_80846F8(2u, &v2);
      sub_811620A(&v2, &v3);
      goto LABEL_9;
    }
LABEL_6:
    v0 = sub_8084320(4u);
    goto LABEL_7;
  }
  if ( v1 != 2 )
    goto LABEL_6;
LABEL_9:
  v7 = sub_808456A(1u);
  sub_80846F8(0, &v8);
  sub_8108222();
}

//----- (0810E780) --------------------------------------------------------
void sub_810E780()
{
  if ( !sub_808404C(0) )
    sub_8084DB4((int)"assert fail");
}

//----- (0810E7A6) --------------------------------------------------------
void sub_810E7A6()
{
  int v0; // eax
  char *v1; // eax

  if ( !sub_808404C(0) )
  {
    v0 = sub_808456A(1u);
    v1 = va("assert fail: %s", v0);
    sub_8084DB4((int)v1);
  }
}

//----- (0810E7E4) --------------------------------------------------------
void sub_810E7E4()
{
  int v0; // eax
  char *v1; // eax

  v0 = sub_808456A(0);
  v1 = va("assert fail: %s", v0);
  sub_8084DB4((int)v1);
}

//----- (0810E810) --------------------------------------------------------
int sub_810E810()
{
  int v1; // [esp+10h] [ebp-8h]
  int v2; // [esp+14h] [ebp-4h]
  int v3; // [esp+14h] [ebp-4h]

  v2 = sub_80849A8(0);
  if ( v2 != 1 )
    return Scr_AddInt(v2 != 0);
  v3 = sub_8084A50(0);
  v1 = 0;
  if ( v3 <= 22 && v3 != 20 )
    v1 = 1;
  return Scr_AddInt(v1);
}

//----- (0810E876) --------------------------------------------------------
int sub_810E876()
{
  int v0; // eax

  v0 = sub_80849A8(0);
  return Scr_AddInt(v0 == 2);
}

//----- (0810E89C) --------------------------------------------------------
int sub_810E89C()
{
  if ( sub_80849A8(0) != 1 )
    return Scr_AddInt(0);
  if ( sub_8084A50(0) != 21 )
    return Scr_AddInt(0);
  if ( *(_DWORD *)(sub_8118CDE(0) + 404) <= 0 )
    return Scr_AddInt(0);
  return Scr_AddInt(1);
}

//----- (0810E918) --------------------------------------------------------
int sub_810E918()
{
  char *v0; // ST14_4
  char *s; // ST10_4

  v0 = (char *)sub_808456A(0);
  s = sub_80B0DE0(v0);
  return Scr_AddString(s);
}

//----- (0810E948) --------------------------------------------------------
int sub_810E948()
{
  char *v0; // eax
  char *v1; // eax
  int v2; // eax

  v0 = (char *)sub_808456A(0);
  v1 = sub_80B0DE0(v0);
  v2 = atoi(v1);
  return Scr_AddInt(v2);
}

//----- (0810E980) --------------------------------------------------------
int sub_810E980()
{
  char *v0; // ST14_4
  const char *nptr; // ST10_4
  int v2; // ST0C_4

  v0 = (char *)sub_808456A(0);
  nptr = sub_80B0DE0(v0);
  *(float *)&v2 = atof(nptr);
  return Scr_AddFloat(v2);
}

//----- (0810E9BE) --------------------------------------------------------
void __usercall sub_810E9BE(long double a1@<st0>)
{
  int v1; // eax
  size_t v2; // eax
  char v3; // al
  char *v4; // eax
  int v5; // ST34_4
  signed int v6; // [esp+2Ch] [ebp-82Ch]
  char *s; // [esp+38h] [ebp-820h]
  char *src; // [esp+3Ch] [ebp-81Ch]
  char v9; // [esp+40h] [ebp-818h]
  char v10; // [esp+440h] [ebp-418h]
  char *v11; // [esp+840h] [ebp-18h]
  int v12; // [esp+844h] [ebp-14h]
  size_t v13; // [esp+848h] [ebp-10h]
  int v14; // [esp+84Ch] [ebp-Ch]

  src = (char *)sub_808456A(0);
  v12 = sub_80849A8(1u);
  if ( v12 == 3 )
  {
    v1 = sub_8084AEE();
    sub_810E290(1, v1 - 1, (int)"Dvar Value", (int)&v10, 1024);
    s = &v10;
    v2 = strlen(&v10);
  }
  else
  {
    s = (char *)sub_808456A(1u);
    v2 = strlen(s);
  }
  v13 = v2;
  v11 = &v9;
  memset(&v9, 0, 0x400u);
  v14 = 0;
  while ( v14 <= 0x1FFF && s[v14] )
  {
    v3 = sub_80B5904(s[v14]);
    *v11 = v3;
    if ( *v11 == 34 )
      *v11 = 39;
    ++v14;
    ++v11;
  }
  if ( (unsigned __int8)sub_80AEF62((int)src) )
  {
    v6 = 0;
    if ( (unsigned int)sub_8084AEE() > 2 && sub_808404C(2u) )
      v6 = 1;
    sub_80B2AC2(a1, src, s);
    if ( v6 )
    {
      v5 = Dvar_FindVar(src);
      sub_80B2B42(v5, 1024);
    }
  }
  else
  {
    v4 = va("Dvar %s has an invalid dvar name", src);
    sub_8084DB4((int)v4);
  }
}

//----- (0810EB8A) --------------------------------------------------------
int sub_810EB8A()
{
  return Scr_AddInt(dword_859B5EC);
}

//----- (0810EBA0) --------------------------------------------------------
unsigned int sub_810EBA0()
{
  unsigned int result; // eax
  unsigned int v1; // [esp+14h] [ebp-4h]

  result = sub_808404C(0);
  v1 = result;
  if ( result <= 0x3FF )
  {
    result = (unsigned int)&unk_8665480 + 560 * result;
    if ( *(_BYTE *)(result + 252) )
      result = Scr_AddEntity((int *)&unk_8665480 + 140 * v1);
  }
  return result;
}

//----- (0810EBF0) --------------------------------------------------------
int sub_810EBF0()
{
  char *v0; // eax
  int result; // eax
  int v2; // eax
  int v3; // [esp+10h] [ebp-8h]
  char *s1; // [esp+14h] [ebp-4h]

  s1 = (char *)sub_808456A(0);
  v3 = sub_811E940(s1);
  if ( v3 )
  {
    v2 = sub_80E9270(v3);
    result = Scr_AddString(*(char **)(v2 + 436));
  }
  else
  {
    if ( *s1 )
    {
      if ( I_stricmp(s1, "none") )
      {
        v0 = va("unknown weapon '%s' in getWeaponModel\n", s1);
        Com_Printf(v0);
      }
    }
    result = Scr_AddString(&byte_8153FCE);
  }
  return result;
}

//----- (0810EC7C) --------------------------------------------------------
int __cdecl sub_810EC7C(int a1)
{
  char *s1; // ST14_4
  int v3; // eax
  int v4; // [esp+Ch] [ebp-Ch]
  int v5; // [esp+10h] [ebp-8h]

  v4 = sub_810E074(a1);
  s1 = (char *)sub_808456A(0);
  v5 = sub_811E940(s1);
  if ( !v5 )
    return Scr_AddInt(0);
  v3 = sub_80EACC8(*(_DWORD *)(v4 + 344), v5);
  return Scr_AddInt(v3);
}

//----- (0810ECE4) --------------------------------------------------------
int sub_810ECE4()
{
  int v0; // ST00_4
  int v2; // [esp+Ch] [ebp-Ch]
  int v3; // [esp+10h] [ebp-8h]
  int v4; // [esp+14h] [ebp-4h]

  sub_80840DA((unsigned __int16 *)&v2, 0, 0);
  v4 = v2;
  v3 = sub_806D074(HIWORD(v2));
  if ( !(unsigned __int8)sub_80C00CA(v3, (unsigned __int16)v4) )
    sub_8084E14(0, (int)"non-primitive animation has no concept of length");
  *(float *)&v0 = sub_80BE760(v3, (unsigned __int16)v4);
  return Scr_AddFloat(v0);
}

//----- (0810ED66) --------------------------------------------------------
int sub_810ED66()
{
  int v0; // eax
  unsigned __int8 v1; // al
  int v3; // [esp+Ch] [ebp-Ch]
  unsigned __int16 v4; // [esp+12h] [ebp-6h]
  int v5; // [esp+14h] [ebp-4h]

  sub_80840DA((unsigned __int16 *)&v3, 0, 0);
  v5 = v3;
  v4 = sub_80843C0(1u);
  v0 = sub_806D074(HIWORD(v5));
  v1 = sub_80C044E(v0, (unsigned __int16)v5, v4);
  return Scr_AddBool(v1);
}

//----- (0810EDD4) --------------------------------------------------------
_DWORD *sub_810EDD4()
{
  int v0; // ST1C_4
  int v2; // [esp+20h] [ebp-18h]

  v0 = sub_8118CDE(0);
  sub_811623A((float *)(v0 + 288), (float *)(v0 + 300), (float *)&v2);
  sub_81162C2((int)&v2, 0.5, (int)&v2);
  return Scr_AddVector(&v2);
}

//----- (0810EE34) --------------------------------------------------------
void __usercall sub_810EE34(long double a1@<st0>)
{
  int v1; // eax
  char *v2; // eax
  int v3; // [esp+18h] [ebp-30h]
  int v4; // [esp+1Ch] [ebp-2Ch]
  char v5; // [esp+20h] [ebp-28h]
  unsigned __int16 v6; // [esp+3Eh] [ebp-Ah]

  v6 = sub_80843C0(0);
  sub_80846F8(1u, &v5);
  if ( (unsigned int)sub_8084AEE() <= 2 )
    v3 = 0;
  else
    v3 = sub_808404C(2u);
  v4 = sub_811C546();
  sub_8079790((_WORD *)(v4 + 360), v6);
  sub_811620A(&v5, (_DWORD *)(v4 + 312));
  *(_DWORD *)(v4 + 368) = v3;
  if ( sub_81186D2(a1, v4) )
  {
    Scr_AddEntity((int *)v4);
  }
  else
  {
    v1 = sub_8078896(v6);
    v2 = va("unable to spawn \"%s\" entity", v1);
    sub_8084DB4((int)v2);
  }
}

//----- (0810EF04) --------------------------------------------------------
int sub_810EF04()
{
  char *v0; // ST18_4
  int v1; // ST1C_4
  char v3; // [esp+20h] [ebp-28h]
  unsigned __int16 v4; // [esp+3Eh] [ebp-Ah]

  v4 = sub_80843C0(0);
  sub_80846F8(1u, &v3);
  v0 = (char *)sub_808456A(2u);
  v1 = sub_811C546();
  sub_8079790((_WORD *)(v1 + 360), v4);
  sub_811620A(&v3, (_DWORD *)(v1 + 312));
  sub_810A21A(v1, v0);
  return Scr_AddEntity((int *)v1);
}

//----- (0810EF92) --------------------------------------------------------
int sub_810EF92()
{
  char *s1; // ST04_4

  if ( !dword_859B41C )
    sub_8084DB4((int)"precacheTurret must be called before any wait statements in the level script\n");
  s1 = (char *)sub_808456A(0);
  return sub_811E940(s1);
}

//----- (0810EFCA) --------------------------------------------------------
void __usercall sub_810EFCA(long double a1@<st0>, int a2)
{
  int v2; // eax
  char *v3; // eax
  int v4; // [esp+10h] [ebp-18h]
  int v5; // [esp+14h] [ebp-14h]
  char *s2; // [esp+20h] [ebp-8h]
  int v7; // [esp+24h] [ebp-4h]

  v7 = sub_810E03A(a2);
  s2 = (char *)sub_808456A(0);
  if ( (unsigned int)sub_8084AEE() <= 1 )
    v5 = (unsigned __int16)word_87A22A0;
  else
    v5 = sub_8084434(1u);
  if ( (unsigned int)sub_8084AEE() <= 2 )
    v4 = 0;
  else
    v4 = sub_808404C(2u);
  if ( sub_811B528(a1, v7, s2, v5) )
  {
    v2 = sub_8078896(v5);
    v3 = va("model '%s' already attached to tag '%s'", s2, v2);
    sub_8084DB4((int)v3);
  }
  if ( !sub_811B470(a1, v7, s2, v5, v4) )
    sub_8084DB4((int)"maximum attached models exceeded");
}
// 87A22A0: using guessed type __int16 word_87A22A0;

//----- (0810F0BA) --------------------------------------------------------
void __usercall sub_810F0BA(long double a1@<st0>, int a2)
{
  int v2; // ebx
  char *v3; // eax
  int v4; // eax
  char *v5; // eax
  int v6; // [esp+10h] [ebp-18h]
  signed int i; // [esp+14h] [ebp-14h]
  char *s2; // [esp+1Ch] [ebp-Ch]
  int v9; // [esp+20h] [ebp-8h]

  v9 = sub_810E03A(a2);
  s2 = (char *)sub_808456A(0);
  if ( (unsigned int)sub_8084AEE() <= 1 )
    v6 = (unsigned __int16)word_87A22A0;
  else
    v6 = sub_8084434(1u);
  if ( !sub_811B528(a1, v9, s2, v6) )
  {
    Com_Printf("Current attachments:\n");
    for ( i = 0; i <= 6; ++i )
    {
      if ( *(_BYTE *)(i + v9 + 528) )
      {
        if ( *(_WORD *)(v9 + 2 * i + 536) )
        {
          v2 = sub_8078896(*(unsigned __int16 *)(v9 + 2 * i + 536));
          v3 = sub_811B124(*(unsigned __int8 *)(i + v9 + 528));
          Com_Printf("model: '%s', tag: '%s'\n", v3, v2);
        }
      }
    }
    v4 = sub_8078896(v6);
    v5 = va("failed to detach model '%s' from tag '%s'", s2, v4);
    sub_8084DB4((int)v5);
  }
}
// 87A22A0: using guessed type __int16 word_87A22A0;

//----- (0810F1E4) --------------------------------------------------------
_DWORD *__usercall sub_810F1E4@<eax>(long double a1@<st0>, int a2)
{
  int v2; // ST04_4

  v2 = sub_810E03A(a2);
  return sub_811B6C2(a1, v2);
}

//----- (0810F206) --------------------------------------------------------
int __cdecl sub_810F206(int a1)
{
  int v2; // [esp+10h] [ebp-8h]
  int i; // [esp+14h] [ebp-4h]

  v2 = sub_810E03A(a1);
  for ( i = 0; i <= 6 && *(_BYTE *)(i + v2 + 528); ++i )
    ;
  return Scr_AddInt(i);
}

//----- (0810F250) --------------------------------------------------------
int __cdecl sub_810F250(int a1)
{
  char *v1; // eax
  int v3; // [esp+10h] [ebp-8h]
  unsigned int v4; // [esp+14h] [ebp-4h]

  v3 = sub_810E03A(a1);
  v4 = sub_808404C(0);
  if ( v4 > 6 || !*(_BYTE *)(v4 + v3 + 528) )
    sub_8084E14(0, (int)"bad index");
  v1 = sub_811B124(*(unsigned __int8 *)(v4 + v3 + 528));
  return Scr_AddString(v1);
}

//----- (0810F2BE) --------------------------------------------------------
int __cdecl sub_810F2BE(int a1)
{
  int v2; // [esp+10h] [ebp-8h]
  unsigned int v3; // [esp+14h] [ebp-4h]

  v2 = sub_810E03A(a1);
  v3 = sub_808404C(0);
  if ( v3 > 6 || !*(_BYTE *)(v3 + v2 + 528) )
    sub_8084E14(0, (int)"bad index");
  return sub_8084C8E(*(unsigned __int16 *)(v2 + 2 * v3 + 536));
}

//----- (0810F324) --------------------------------------------------------
int __cdecl sub_810F324(int a1)
{
  int v2; // [esp+10h] [ebp-8h]
  unsigned int v3; // [esp+14h] [ebp-4h]

  v2 = sub_810E03A(a1);
  v3 = sub_808404C(0);
  if ( v3 > 6 || !*(_BYTE *)(v3 + v2 + 528) )
    sub_8084E14(0, (int)"bad index");
  return Scr_AddBool(((signed int)*(unsigned __int8 *)(v2 + 357) >> v3) & 1);
}

//----- (0810F392) --------------------------------------------------------
void __usercall sub_810F392(long double a1@<st0>, int a2)
{
  int v2; // eax
  char *v3; // eax
  char *v4; // eax
  char *v5; // eax
  char *v6; // ebx
  int v7; // eax
  char *v8; // eax
  float v9[4]; // [esp+20h] [ebp-38h]
  char v10; // [esp+30h] [ebp-28h]
  int v11; // [esp+40h] [ebp-18h]
  int v12; // [esp+44h] [ebp-14h]
  int v13; // [esp+48h] [ebp-10h]
  int v14; // [esp+4Ch] [ebp-Ch]

  v14 = sub_810E03A(a2);
  if ( sub_80849A8(0) != 1 || sub_8084A50(0) != 21 )
    sub_8084E14(0, (int)"not an entity");
  if ( !(*(_DWORD *)(v14 + 372) & 0x1000) )
  {
    v2 = sub_8078896(*(unsigned __int16 *)(v14 + 360));
    v3 = va("entity (classname: '%s') does not currently support linkTo", v2);
    sub_8084E30((int)v3);
  }
  v13 = sub_8118CDE(0);
  v11 = sub_8084AEE();
  v12 = 0;
  if ( v11 > 1 )
  {
    v12 = sub_8084434(1u);
    if ( !*(_BYTE *)sub_8078896(v12) )
      v12 = 0;
  }
  if ( v11 > 2 )
  {
    sub_80846F8(2u, &v10);
    sub_80846F8(3u, v9);
    if ( sub_811B8BA(a1, (int *)v14, (int *)v13, v12, &v10, v9) )
      return;
  }
  else if ( sub_811B86E(a1, (int *)v14, (int *)v13, v12) )
  {
    return;
  }
  if ( !sub_8090A5A((int *)v13) )
  {
    if ( !*(_BYTE *)(v13 + 356) )
      sub_8084DB4((int)"failed to link entity since parent has no model");
    v4 = sub_811B124(*(unsigned __int8 *)(v13 + 356));
    v5 = va("failed to link entity since parent model '%s' is invalid", v4);
    sub_8084DB4((int)v5);
  }
  if ( v12 )
  {
    if ( sub_8090898((int *)v13, v12) < 0 )
    {
      sub_8090584((int *)v13);
      v6 = sub_811B124(*(unsigned __int8 *)(v13 + 356));
      v7 = sub_8078896(v12);
      v8 = va("failed to link entity since tag '%s' does not exist in parent model '%s'", v7, v6);
      sub_8084DB4((int)v8);
    }
  }
  sub_8084DB4((int)"failed to link entity due to link cycle");
}

//----- (0810F5A8) --------------------------------------------------------
int __usercall sub_810F5A8@<eax>(long double a1@<st0>, int a2)
{
  _DWORD *v2; // ST04_4

  v2 = (_DWORD *)sub_810E03A(a2);
  return sub_811B928(a1, v2);
}

//----- (0810F5CA) --------------------------------------------------------
int __cdecl sub_810F5CA(int a1)
{
  int v1; // eax
  char *v2; // eax
  int result; // eax
  int v4; // [esp+14h] [ebp-4h]

  v4 = sub_810E03A(a1);
  if ( *(_DWORD *)(v4 + 372) & 0x1000 )
    sub_8084E30((int)"entity already has linkTo enabled");
  if ( *(_DWORD *)(v4 + 4) || *(_BYTE *)(v4 + 352) )
  {
    v1 = sub_8078896(*(unsigned __int16 *)(v4 + 360));
    v2 = va("entity (classname: '%s') does not currently support enableLinkTo", v1);
    sub_8084E30((int)v2);
  }
  result = v4;
  *(_DWORD *)(v4 + 372) |= 0x1000u;
  return result;
}

//----- (0810F658) --------------------------------------------------------
_DWORD *__cdecl sub_810F658(int a1)
{
  char v2; // [esp+10h] [ebp-28h]
  int v3; // [esp+2Ch] [ebp-Ch]

  v3 = sub_810E03A(a1);
  sub_811620A((_DWORD *)(v3 + 312), &v2);
  return Scr_AddVector(&v2);
}

//----- (0810F690) --------------------------------------------------------
_DWORD *__cdecl sub_810F690(int a1)
{
  char v2; // [esp+10h] [ebp-28h]
  float v3; // [esp+18h] [ebp-20h]
  int v4; // [esp+2Ch] [ebp-Ch]

  v4 = sub_810E03A(a1);
  sub_811620A((_DWORD *)(v4 + 312), &v2);
  v3 = v3 + 40.0;
  return Scr_AddVector(&v2);
}

//----- (0810F6D6) --------------------------------------------------------
int __cdecl sub_810F6D6(int a1)
{
  int result; // eax
  int (__cdecl *v2)(int, int *, int *); // [esp+Ch] [ebp-Ch]
  int *v3; // [esp+10h] [ebp-8h]
  int v4; // [esp+14h] [ebp-4h]

  v4 = sub_810E03A(a1);
  v3 = (int *)sub_8118CDE(0);
  Scr_AddEntity(v3);
  Scr_Notify((int *)v4, word_87A22F4, 1);
  result = dword_8167890[10 * *(unsigned __int8 *)(v4 + 358)];
  v2 = (int (__cdecl *)(int, int *, int *))dword_8167890[10 * *(unsigned __int8 *)(v4 + 358)];
  if ( v2 )
    result = v2(v4, v3, v3);
  return result;
}
// 8167890: using guessed type int dword_8167890[];
// 87A22F4: using guessed type __int16 word_87A22F4;

//----- (0810F760) --------------------------------------------------------
int __usercall sub_810F760@<eax>(long double a1@<st0>, int a2)
{
  int v2; // ST1C_4
  char v4; // [esp+20h] [ebp-38h]
  char v5; // [esp+30h] [ebp-28h]
  int v6; // [esp+44h] [ebp-14h]
  int v7; // [esp+48h] [ebp-10h]
  int v8; // [esp+4Ch] [ebp-Ch]

  v8 = sub_810E03A(a2);
  if ( *(_BYTE *)(v8 + 241) || *(_BYTE *)(v8 + 242) & 0x60 )
  {
    v6 = v8;
    v8 = sub_8118CDE(0);
    if ( *(_BYTE *)(v8 + 241) || *(_BYTE *)(v8 + 242) & 0x60 )
      sub_8084DB4((int)"istouching cannot be called on 2 brush/cylinder entities");
    v7 = v6;
  }
  else
  {
    v7 = sub_8118CDE(0);
  }
  sub_811623A((float *)(v8 + 312), (float *)(v8 + 260), (float *)&v5);
  sub_811623A((float *)(v8 + 312), (float *)(v8 + 272), (float *)&v4);
  sub_80A6450(a1, (float *)&v5, (float *)&v4);
  v2 = sub_80901C2((float *)&v5, (float *)&v4, v7);
  return Scr_AddInt(v2);
}

//----- (0810F872) --------------------------------------------------------
int sub_810F872()
{
  char *v0; // eax
  int v1; // eax

  v0 = (char *)sub_808456A(0);
  v1 = sub_80AA8AA(v0);
  return Scr_AddBool(v1 != 0);
}

//----- (0810F8A4) --------------------------------------------------------
int __cdecl sub_810F8A4(int a1)
{
  int v1; // ST14_4
  char *s2; // ST10_4
  unsigned __int8 v3; // ST0F_1
  int v4; // eax
  int v5; // edx
  int result; // eax

  v1 = sub_810E03A(a1);
  s2 = (char *)sub_808456A(0);
  v3 = sub_811B1D8(s2);
  v4 = sub_811CB34((_DWORD *)(v1 + 312), 179);
  *(_BYTE *)(v4 + 242) |= 8u;
  v5 = v4;
  result = v3;
  *(_DWORD *)(v5 + 160) = v3;
  return result;
}

//----- (0810F914) --------------------------------------------------------
int __cdecl sub_810F914(int a1)
{
  int v1; // ST14_4
  char *s2; // ST10_4
  unsigned __int8 v3; // ST0F_1
  int v4; // eax
  int v5; // edx
  int result; // eax

  v1 = sub_810E03A(a1);
  s2 = (char *)sub_808456A(0);
  v3 = sub_811B1D8(s2);
  v4 = sub_811CB34((_DWORD *)(v1 + 312), 180);
  *(_BYTE *)(v4 + 242) |= 8u;
  v5 = v4;
  result = v3;
  *(_DWORD *)(v5 + 160) = v3;
  return result;
}

//----- (0810F984) --------------------------------------------------------
int __cdecl sub_810F984(int a1)
{
  int v1; // ST14_4
  char *v2; // eax
  int result; // eax

  v1 = sub_810E03A(a1);
  v2 = (char *)sub_808456A(0);
  LOBYTE(result) = sub_811B1D8(v2);
  *(_DWORD *)(v1 + 256) = -1;
  result = (unsigned __int8)result;
  *(_DWORD *)(v1 + 132) = (unsigned __int8)result;
  return result;
}

//----- (0810F9D2) --------------------------------------------------------
int __cdecl sub_810F9D2(int a1)
{
  int result; // eax

  result = sub_810E03A(a1);
  *(_DWORD *)(result + 256) = dword_859B5EC + 300;
  *(_DWORD *)(result + 132) = 0;
  return result;
}

//----- (0810FA1A) --------------------------------------------------------
int __usercall sub_810FA1A@<eax>(long double a1@<st0>, int a2)
{
  int *s; // [esp+14h] [ebp-4h]

  s = (int *)sub_810E03A(a2);
  if ( s[86] )
    sub_8084DB4((int)"Cannot delete a client entity");
  if ( dword_859EA04 == *s )
    sub_8084DB4((int)"Cannot delete entity during its think");
  Scr_Notify(s, word_87A22AA, 0);
  return sub_811C9C0(a1, s);
}
// 859EA04: using guessed type int dword_859EA04;
// 87A22AA: using guessed type __int16 word_87A22AA;

//----- (0810FA8A) --------------------------------------------------------
int __usercall sub_810FA8A@<eax>(long double a1@<st0>, int a2)
{
  int v2; // ST14_4
  char *s2; // ST10_4

  v2 = sub_810E03A(a2);
  s2 = (char *)sub_808456A(0);
  sub_811B3EA(v2, s2);
  sub_811B20E(a1, v2);
  return sub_809A45E(v2);
}

//----- (0810FAD8) --------------------------------------------------------
int __cdecl sub_810FAD8(int a1)
{
  int v1; // ST00_4
  int result; // eax
  int v3; // ST00_4
  int v4; // [esp+4h] [ebp-4h]

  v4 = sub_810E03A(a1);
  if ( *(_DWORD *)(v4 + 344) )
  {
    if ( *(_DWORD *)(v4 + 404) )
    {
      *(float *)&v1 = (long double)*(signed int *)(v4 + 404)
                    / (long double)*(signed int *)(*(_DWORD *)(v4 + 344) + 10024);
      result = Scr_AddFloat(v1);
    }
    else
    {
      result = Scr_AddFloat(0);
    }
  }
  else
  {
    *(float *)&v3 = (long double)*(signed int *)(v4 + 404);
    result = Scr_AddFloat(v3);
  }
  return result;
}

//----- (0810FB4A) --------------------------------------------------------
void __cdecl sub_810FB4A(int a1)
{
  float v1; // ST00_4
  char *v2; // eax
  signed int v3; // [esp+1Ch] [ebp-Ch]
  float v4; // [esp+20h] [ebp-8h]
  char *v5; // [esp+24h] [ebp-4h]

  v5 = (char *)sub_810E03A(a1);
  v4 = sub_8084320(0);
  if ( v4 > 1.0 )
    v4 = 1.0;
  if ( *((_DWORD *)v5 + 86) )
  {
    v1 = (long double)*(signed int *)(*((_DWORD *)v5 + 86) + 10024) * v4;
    v3 = sub_8116158(v1);
    v2 = va("%c \"%i\"", 73, 0);
    sub_808FE96(-1963413621 * ((v5 - (char *)&unk_8665480) >> 4), 0, (int)v2);
  }
  else if ( *((_DWORD *)v5 + 102) )
  {
    v3 = (signed int)((long double)*((signed int *)v5 + 102) * v4);
  }
  else
  {
    v3 = (signed int)v4;
  }
  if ( v3 > 0 )
    *((_DWORD *)v5 + 101) = v3;
  else
    Com_Printf("ERROR: Cannot setnormalhealth to 0 or below.\n");
}

//----- (0810FC60) --------------------------------------------------------
_DWORD *__cdecl sub_810FC60(int a1)
{
  _DWORD *result; // eax

  result = (_DWORD *)sub_810E03A(a1);
  result[93] &= 0xFFFFF7FF;
  result[61] = 0;
  result[62] = 0;
  return result;
}

//----- (0810FCA8) --------------------------------------------------------
_DWORD *__cdecl sub_810FCA8(int a1)
{
  _DWORD *result; // eax

  result = (_DWORD *)sub_810E03A(a1);
  result[93] |= 0x800u;
  result[61] = -1;
  result[62] = -1;
  return result;
}

//----- (0810FCF0) --------------------------------------------------------
void __cdecl sub_810FCF0(int a1)
{
  _DWORD *v1; // [esp+4h] [ebp-14h]
  int v2; // [esp+8h] [ebp-10h]

  v2 = sub_810E03A(a1);
  v1 = (_DWORD *)sub_8118CDE(0);
  if ( *v1 <= 63 )
  {
    *(_DWORD *)(v2 + 372) &= 0xFFFFF7FF;
    *(_DWORD *)(v2 + 4 * (*v1 >> 5) + 244) &= ~(1 << (*(_BYTE *)v1 & 0x1F));
  }
  else
  {
    sub_8084DB4((int)"showToClient error: param must be a client entity\n");
  }
}

//----- (0810FD84) --------------------------------------------------------
int __cdecl sub_810FD84(int a1)
{
  int v1; // ST14_4
  int v2; // ST10_4

  v1 = sub_810E03A(a1);
  v2 = sub_808404C(0);
  Scr_AddInt(*(_DWORD *)(v1 + 284));
  *(_DWORD *)(v1 + 284) = v2;
  return sub_809A45E(v1);
}

//----- (0810FDD2) --------------------------------------------------------
int __cdecl sub_810FDD2(int a1)
{
  int result; // eax
  unsigned int v2; // edx
  int v3; // [esp+10h] [ebp-8h]
  int v4; // [esp+14h] [ebp-4h]

  v4 = sub_810E03A(a1);
  v3 = sub_808404C(0);
  if ( *(_DWORD *)(v4 + 4) != 1 )
    sub_8084DB4((int)"Type should be a player");
  if ( v3 )
  {
    result = v4;
    v2 = *(_DWORD *)(v4 + 372) | 0x20000;
  }
  else
  {
    result = v4;
    v2 = *(_DWORD *)(v4 + 372) & 0xFFFDFFFF;
  }
  *(_DWORD *)(v4 + 372) = v2;
  return result;
}

//----- (0810FE44) --------------------------------------------------------
void __cdecl sub_810FE44(int a1)
{
  char *v1; // eax
  char *v2; // [esp+Ch] [ebp-Ch]
  int v3; // [esp+10h] [ebp-8h]
  int i; // [esp+14h] [ebp-4h]

  v3 = sub_810E03A(a1);
  v2 = (char *)sub_808456A(0);
  if ( *(_WORD *)(v3 + 360) != word_87A22F6 && *(_WORD *)(v3 + 360) != word_87A22F8 || I_stricmp(v2, "HINT_INHERIT") )
  {
    for ( i = 1; i <= 132 && *(_DWORD *)&off_8167BA0[4 * i]; ++i )
    {
      if ( !I_stricmp(v2, *(char **)&off_8167BA0[4 * i]) )
      {
        *(_DWORD *)(v3 + 220) = i;
        return;
      }
    }
    Com_Printf("List of valid hint type strings\n");
    if ( *(_WORD *)(v3 + 360) == word_87A22F6 || *(_WORD *)(v3 + 360) == word_87A22F8 )
      Com_Printf("HINT_INHERIT (for trigger_use or trigger_use_touch entities only)\n");
    for ( i = 1; i <= 132 && *(_DWORD *)&off_8167BA0[4 * i]; ++i )
      Com_Printf("%s\n", *(_DWORD *)&off_8167BA0[4 * i]);
    v1 = va("%s is not a valid hint type. See above for list of valid hint types\n", v2);
    sub_8084DB4((int)v1);
  }
  else
  {
    *(_DWORD *)(v3 + 220) = -1;
  }
}
// 87A22F6: using guessed type __int16 word_87A22F6;
// 87A22F8: using guessed type __int16 word_87A22F8;

//----- (0810FFAA) --------------------------------------------------------
int __cdecl sub_810FFAA(int a1, char *s1)
{
  char s2; // [esp+20h] [ebp-418h]
  int i; // [esp+42Ch] [ebp-Ch]

  for ( i = 0; i <= 31; ++i )
  {
    sub_809107E(i + 1278, &s2, 1024);
    if ( !s2 )
    {
      sub_8090E6C(i + 1278, s1);
      *(_DWORD *)a1 = i;
      return 1;
    }
    if ( !strcmp(s1, &s2) )
    {
      *(_DWORD *)a1 = i;
      return 1;
    }
  }
  *(_DWORD *)a1 = -1;
  return 0;
}

//----- (0811006E) --------------------------------------------------------
int __cdecl sub_811006E(int a1)
{
  char *v1; // eax
  int result; // eax
  int v3; // eax
  char *v4; // eax
  char s1; // [esp+20h] [ebp-418h]
  int v6; // [esp+424h] [ebp-14h]
  int v7; // [esp+428h] [ebp-10h]
  int v8; // [esp+42Ch] [ebp-Ch]

  v6 = sub_810E03A(a1);
  if ( *(_WORD *)(v6 + 360) != word_87A22F6 && *(_WORD *)(v6 + 360) != word_87A22F8 )
    sub_8084DB4((int)"The setHintString command only works on trigger_use or trigger_use_touch entities.\n");
  v7 = sub_80849A8(0);
  if ( v7 != 2 || (v1 = (char *)sub_808456A(0), I_stricmp(v1, &byte_8153FCE)) )
  {
    v3 = sub_8084AEE();
    sub_810E290(0, v3 - 1, (int)"Hint String", (int)&s1, 1024);
    if ( !sub_810FFAA((int)&v8, &s1) )
    {
      v4 = va("Too many different hintstring values. Max allowed is %i different strings", 32);
      sub_8084DB4((int)v4);
    }
    result = (unsigned __int8)v8;
    *(_DWORD *)(v6 + 216) = (unsigned __int8)v8;
  }
  else
  {
    result = v6;
    *(_DWORD *)(v6 + 216) = 255;
  }
  return result;
}
// 87A22F6: using guessed type __int16 word_87A22F6;
// 87A22F8: using guessed type __int16 word_87A22F8;

//----- (08110172) --------------------------------------------------------
int __cdecl sub_8110172(int a1)
{
  int *v1; // ST04_4

  v1 = (int *)sub_810E03A(a1);
  return Scr_AddInt(*v1);
}

//----- (08110196) --------------------------------------------------------
int __cdecl sub_8110196(int a1)
{
  int result; // eax
  int v2; // [esp+4h] [ebp-4h]

  v2 = sub_810E03A(a1);
  if ( *(_WORD *)(v2 + 360) != word_87A22FA )
    sub_8084DB4((int)"Currently on supported on damage triggers");
  result = v2;
  *(_DWORD *)(v2 + 372) |= 0x4000u;
  return result;
}
// 87A22FA: using guessed type __int16 word_87A22FA;

//----- (081101E4) --------------------------------------------------------
int __cdecl sub_81101E4(int a1)
{
  int result; // eax
  int v2; // [esp+4h] [ebp-4h]

  v2 = sub_810E03A(a1);
  if ( *(_WORD *)(v2 + 360) != word_87A22FA )
    sub_8084DB4((int)"Currently on supported on damage triggers");
  result = v2;
  *(_DWORD *)(v2 + 372) &= 0xFFFFBFFF;
  return result;
}
// 87A22FA: using guessed type __int16 word_87A22FA;

//----- (08110232) --------------------------------------------------------
unsigned int __cdecl sub_8110232(int a1)
{
  int v1; // eax
  int v2; // edx
  unsigned int result; // eax

  v1 = sub_810E03A(a1);
  v2 = v1;
  result = *(_DWORD *)(v1 + 372) & 0xFFFF7FFF;
  *(_DWORD *)(v2 + 372) = result;
  return result;
}

//----- (08110260) --------------------------------------------------------
int __cdecl sub_8110260(int a1)
{
  int v1; // eax
  int v2; // edx
  int result; // eax

  v1 = sub_810E03A(a1);
  v2 = v1;
  result = *(_DWORD *)(v1 + 372) | 0x8000;
  *(_DWORD *)(v2 + 372) = result;
  return result;
}

//----- (0811028E) --------------------------------------------------------
int __cdecl sub_811028E(int a1)
{
  int result; // eax
  int v2; // [esp+4h] [ebp-4h]

  v2 = sub_810E03A(a1);
  if ( !*(_BYTE *)(v2 + 241) )
    sub_8084DB4((int)"Currently only supported on entities with brush models");
  result = v2;
  *(_DWORD *)(v2 + 8) |= 0x800u;
  return result;
}

//----- (081102CE) --------------------------------------------------------
int __cdecl sub_81102CE(int a1)
{
  int result; // eax
  int v2; // [esp+4h] [ebp-4h]

  v2 = sub_810E03A(a1);
  if ( !*(_BYTE *)(v2 + 241) )
    sub_8084DB4((int)"Currently only supported on entities with brush models");
  result = v2;
  *(_DWORD *)(v2 + 8) &= 0xFFFFF7FF;
  return result;
}

//----- (0811030E) --------------------------------------------------------
int *sub_811030E()
{
  int *result; // eax
  int i; // [esp+4h] [ebp-4h]

  for ( i = 0; i <= 15; ++i )
  {
    sub_8110408((_DWORD *)(28 * i + 140096548));
    result = &i;
  }
  return result;
}

//----- (08110346) --------------------------------------------------------
signed int __cdecl sub_8110346(_DWORD *a1, int a2)
{
  if ( a2 == (unsigned __int16)word_87A22B0 )
  {
    *a1 = 0;
    return 1;
  }
  if ( a2 == (unsigned __int16)word_87A22BE )
  {
    *a1 = 2;
    return 1;
  }
  if ( a2 == (unsigned __int16)word_87A22A6 )
  {
    *a1 = 4;
    return 1;
  }
  *a1 = 0;
  return 0;
}
// 87A22A6: using guessed type __int16 word_87A22A6;
// 87A22B0: using guessed type __int16 word_87A22B0;
// 87A22BE: using guessed type __int16 word_87A22BE;

//----- (081103B0) --------------------------------------------------------
int __cdecl sub_81103B0(int a1)
{
  int result; // eax
  char *v2; // [esp+0h] [ebp-4h]

  result = a1;
  if ( *(_DWORD *)(a1 + 16) != 1023 )
  {
    v2 = (char *)&unk_8665480 + 560 * *(_DWORD *)(a1 + 16);
    if ( v2[252] )
      v2[242] &= 0xEFu;
    result = a1;
    *(_DWORD *)(a1 + 16) = 1023;
  }
  return result;
}

//----- (08110408) --------------------------------------------------------
_DWORD *__cdecl sub_8110408(_DWORD *a1)
{
  _DWORD *result; // eax

  *a1 = 0;
  sub_81161BC(a1 + 1);
  a1[4] = 1023;
  a1[5] = 0;
  result = a1;
  a1[6] = 0;
  return result;
}

//----- (08110446) --------------------------------------------------------
int __cdecl sub_8110446(int a1, unsigned int a2)
{
  char *v2; // eax
  char *v3; // eax
  int result; // eax
  char *src; // [esp+1Ch] [ebp-Ch]
  signed int i; // [esp+20h] [ebp-8h]

  src = (char *)sub_808456A(a2);
  for ( i = 0; src[i]; ++i )
  {
    if ( src[i] <= 31 || src[i] == 127 )
    {
      v2 = va(
             "Illegal character '%c'(ascii %i) in objective icon name: %s\n",
             src[i],
             (unsigned __int8)src[i],
             src);
      sub_8084E14(3, (int)v2);
    }
  }
  if ( i > 63 )
  {
    v3 = va("Objective icon name is too long (> %i): %s\n", 63, src);
    sub_8084E14(3, (int)v3);
  }
  result = sub_811AFBA(src);
  *(_DWORD *)(a1 + 24) = result;
  return result;
}

//----- (08110514) --------------------------------------------------------
int sub_8110514()
{
  char *v0; // eax
  int v1; // eax
  char *v2; // eax
  int result; // eax
  int v4; // [esp+14h] [ebp-14h]
  unsigned __int16 v5; // [esp+1Ah] [ebp-Eh]
  int v6; // [esp+1Ch] [ebp-Ch]
  char v7[4]; // [esp+20h] [ebp-8h]
  int v8; // [esp+24h] [ebp-4h]

  v8 = sub_8084AEE();
  if ( v8 <= 1 )
    sub_8084DB4((int)"objective_add needs at least the first two parameters out of its parameter list of: index state [st"
                     "ring] [position]\n");
  *(_DWORD *)v7 = sub_808404C(0);
  if ( *(_DWORD *)v7 < 0 || *(_DWORD *)v7 > 15 )
  {
    v0 = va("index %i is an illegal objective index. Valid indexes are 0 to %i\n", *(_DWORD *)v7, 15);
    sub_8084E14(0, (int)v0);
  }
  v6 = 28 * *(_DWORD *)v7 + 140096548;
  sub_81103B0(v6);
  v5 = sub_80843C0(1u);
  if ( !sub_8110346(&v4, v5) )
  {
    v1 = sub_8078896(v5);
    v2 = va("Illegal objective state \"%s\". Valid states are \"empty\", \"invisible\", \"current\"\n", v1);
    sub_8084E14(1, (int)v2);
  }
  *(_DWORD *)v6 = v4;
  if ( v8 > 2 )
  {
    sub_80846F8(2u, (_DWORD *)(v6 + 4));
    *(float *)(v6 + 4) = (long double)(signed int)*(float *)(v6 + 4);
    *(float *)(v6 + 8) = (long double)(signed int)*(float *)(v6 + 8);
    *(float *)(v6 + 12) = (long double)(signed int)*(float *)(v6 + 12);
    *(_DWORD *)(v6 + 16) = 1023;
    if ( v8 > 3 )
      sub_8110446(v6, 3u);
  }
  result = v6;
  *(_DWORD *)(v6 + 20) = 0;
  return result;
}

//----- (081106B6) --------------------------------------------------------
_DWORD *sub_81106B6()
{
  char *v0; // eax
  int v2; // [esp+14h] [ebp-4h]

  v2 = sub_808404C(0);
  if ( v2 < 0 || v2 > 15 )
  {
    v0 = va("index %i is an illegal objective index. Valid indexes are 0 to %i\n", v2, 15);
    sub_8084E14(0, (int)v0);
  }
  sub_81103B0(28 * v2 + 140096548);
  return sub_8110408((_DWORD *)(28 * v2 + 140096548));
}

//----- (0811073A) --------------------------------------------------------
int sub_811073A()
{
  char *v0; // eax
  unsigned __int16 v1; // ST1A_2
  int v2; // eax
  char *v3; // eax
  int result; // eax
  int v5; // [esp+1Ch] [ebp-Ch]
  _DWORD *v6; // [esp+20h] [ebp-8h]
  char v7[4]; // [esp+24h] [ebp-4h]

  *(_DWORD *)v7 = sub_808404C(0);
  if ( *(_DWORD *)v7 < 0 || *(_DWORD *)v7 > 15 )
  {
    v0 = va("index %i is an illegal objective index. Valid indexes are 0 to %i\n", *(_DWORD *)v7, 15);
    sub_8084E14(0, (int)v0);
  }
  v6 = (_DWORD *)(28 * *(_DWORD *)v7 + 140096548);
  v1 = sub_80843C0(1u);
  if ( !sub_8110346(&v5, v1) )
  {
    v2 = sub_808456A(1u);
    v3 = va("Illegal objective state \"%s\". Valid states are \"empty\", \"invisible\", \"current\"\n", v2);
    sub_8084E14(1, (int)v3);
  }
  result = v5;
  *v6 = v5;
  if ( !v5 || v5 == 2 )
    result = sub_81103B0((int)v6);
  return result;
}

//----- (08110814) --------------------------------------------------------
int sub_8110814()
{
  char *v0; // eax
  int v2; // [esp+14h] [ebp-4h]

  v2 = sub_808404C(0);
  if ( v2 < 0 || v2 > 15 )
  {
    v0 = va("index %i is an illegal objective index. Valid indexes are 0 to %i\n", v2, 15);
    sub_8084E14(0, (int)v0);
  }
  return sub_8110446(28 * v2 + 140096548, 1u);
}

//----- (08110886) --------------------------------------------------------
signed int sub_8110886()
{
  char *v0; // eax
  float *v1; // ST24_4
  signed int result; // eax
  int v3; // [esp+24h] [ebp-4h]

  v3 = sub_808404C(0);
  if ( v3 < 0 || v3 > 15 )
  {
    v0 = va("index %i is an illegal objective index. Valid indexes are 0 to %i\n", v3, 15);
    sub_8084E14(0, (int)v0);
  }
  v1 = (float *)(28 * v3 + 140096548);
  sub_81103B0((int)v1);
  sub_80846F8(1u, (_DWORD *)(28 * v3 + 140096552));
  v1[1] = (long double)(signed int)v1[1];
  v1[2] = (long double)(signed int)v1[2];
  result = (signed int)*(float *)&dword_859B424[7 * v3 + 3];
  v1[3] = (long double)result;
  return result;
}

//----- (0811097C) --------------------------------------------------------
int sub_811097C()
{
  char *v0; // eax
  int v1; // eax
  _DWORD *v2; // ST0C_4
  int result; // eax
  int v4; // [esp+14h] [ebp-4h]

  v4 = sub_808404C(0);
  if ( v4 < 0 || v4 > 15 )
  {
    v0 = va("index %i is an illegal objective index. Valid indexes are 0 to %i\n", v4, 15);
    sub_8084E14(0, (int)v0);
  }
  sub_81103B0(28 * v4 + 140096548);
  v1 = sub_8118CDE(1u);
  v2 = (_DWORD *)v1;
  *(_BYTE *)(v1 + 242) |= 0x10u;
  result = *(_DWORD *)v1;
  dword_859B424[7 * v4 + 4] = *v2;
  return result;
}

//----- (08110A1C) --------------------------------------------------------
char *sub_8110A1C()
{
  char *result; // eax
  char *v1; // eax
  int s[16]; // [esp+10h] [ebp-58h]
  _DWORD *v3; // [esp+50h] [ebp-18h]
  char v4[4]; // [esp+54h] [ebp-14h]
  char *v5; // [esp+58h] [ebp-10h]
  char *i; // [esp+5Ch] [ebp-Ch]

  v5 = (char *)sub_8084AEE();
  memset(s, 0, 0x40u);
  for ( i = 0; ; ++i )
  {
    result = i;
    if ( (signed int)i >= (signed int)v5 )
      break;
    *(_DWORD *)v4 = sub_808404C((unsigned int)i);
    if ( *(_DWORD *)v4 < 0 || *(_DWORD *)v4 > 15 )
    {
      v1 = va("index %i is an illegal objective index. Valid indexes are 0 to %i\n", *(_DWORD *)v4, 15);
      sub_8084E14((int)i, (int)v1);
    }
    s[*(_DWORD *)v4] = 1;
  }
  for ( *(_DWORD *)v4 = 0; *(_DWORD *)v4 <= 15; ++*(_DWORD *)v4 )
  {
    v3 = (_DWORD *)(28 * *(_DWORD *)v4 + 140096548);
    if ( s[*(_DWORD *)v4] )
    {
      *v3 = 4;
    }
    else if ( *v3 == 4 )
    {
      *v3 = 1;
    }
    result = v4;
  }
  return result;
}
// 8110A1C: using guessed type int s[16];

//----- (08110B02) --------------------------------------------------------
void sub_8110B02()
{
  char *v0; // eax
  int v1; // eax
  char *v2; // eax
  unsigned __int16 v3; // [esp+Eh] [ebp-Ah]
  int v4; // [esp+14h] [ebp-4h]

  v4 = sub_808404C(0);
  if ( v4 < 0 || v4 > 15 )
  {
    v0 = va("index %i is an illegal objective index. Valid indexes are 0 to %i\n", v4, 15);
    sub_8084E14(0, (int)v0);
  }
  v3 = sub_80843C0(1u);
  if ( v3 == word_87A22A2 )
  {
    dword_859B424[7 * v4 + 5] = 2;
  }
  else if ( v3 == word_87A22A4 )
  {
    dword_859B424[7 * v4 + 5] = 1;
  }
  else if ( v3 == word_87A2314 )
  {
    dword_859B424[7 * v4 + 5] = 0;
  }
  else
  {
    v1 = sub_8078896(v3);
    v2 = va("Illegal team string '%s'. Must be allies, axis, or none.", v1);
    sub_8084E14(1, (int)v2);
  }
}
// 87A22A2: using guessed type __int16 word_87A22A2;
// 87A22A4: using guessed type __int16 word_87A22A4;
// 87A2314: using guessed type __int16 word_87A2314;

//----- (08110BEE) --------------------------------------------------------
void sub_8110BEE()
{
  char *s; // [esp+1Ch] [ebp-41Ch]
  char format; // [esp+20h] [ebp-418h]
  size_t v2; // [esp+420h] [ebp-18h]
  int v3; // [esp+424h] [ebp-14h]
  int v4; // [esp+428h] [ebp-10h]
  int i; // [esp+42Ch] [ebp-Ch]

  format = 0;
  v3 = 0;
  v4 = sub_8084AEE();
  for ( i = 0; i < v4; ++i )
  {
    s = (char *)sub_808456A(i);
    v2 = strlen(s);
    if ( (signed int)(v3 + v2) > 1023 )
      break;
    sub_80B57C0(&format, 1024, s);
    v3 += v2;
  }
  sub_8107502(&format);
}

//----- (08110C8C) --------------------------------------------------------
int sub_8110C8C()
{
  return Scr_AddInt(1022);
}

//----- (08110CA0) --------------------------------------------------------
int sub_8110CA0()
{
  char *s1; // ST20_4
  char *v1; // ST1C_4
  _DWORD *v2; // ST24_4
  int result; // eax
  int v4; // [esp+10h] [ebp-18h]
  signed int v5; // [esp+14h] [ebp-14h]
  int v6; // [esp+18h] [ebp-10h]

  s1 = (char *)sub_808456A(2u);
  v6 = sub_811E940(s1);
  v1 = (char *)sub_808456A(3u);
  v5 = sub_80FF26A(v1);
  v2 = (_DWORD *)sub_8118CDE(0);
  v4 = sub_811CB34(&unk_8145E68, 198);
  *(_DWORD *)(v4 + 116) = *v2;
  if ( sub_80849A8(1u) != 1 || sub_8084A50(1u) != 21 )
    *(_DWORD *)(v4 + 120) = 1022;
  else
    *(_DWORD *)(v4 + 120) = *(_DWORD *)sub_8118CDE(1u);
  *(_BYTE *)(v4 + 242) = 8;
  if ( v5 != 7 && v5 != 8 && v5 != 12 && v5 != 11 && v5 != 9 )
  {
    result = v6;
    *(_DWORD *)(v4 + 160) = v6;
  }
  else
  {
    result = v5 | 0x80;
    *(_DWORD *)(v4 + 160) = v5 | 0x80;
  }
  return result;
}

//----- (08110DA4) --------------------------------------------------------
int sub_8110DA4()
{
  float v1[4]; // [esp+20h] [ebp-1058h]
  char v2; // [esp+30h] [ebp-1048h]
  char v3; // [esp+40h] [ebp-1038h]
  int v4; // [esp+5Ch] [ebp-101Ch]
  int v5[1026]; // [esp+60h] [ebp-1018h]
  int v6; // [esp+1068h] [ebp-10h]
  int i; // [esp+106Ch] [ebp-Ch]

  sub_80846F8(0, v1);
  sub_811623A(v1, (float *)&unk_8167700, (float *)&v3);
  sub_811623A(v1, (float *)&unk_816770C, (float *)&v2);
  v6 = sub_805E782((int)&v3, (int)&v2, (int)v5, 1024, 0x2000000);
  for ( i = 0; i < v6; ++i )
  {
    v4 = (int)&unk_8665480 + 560 * v5[i];
    if ( *(_DWORD *)(v4 + 344) && *(_DWORD *)(*(_DWORD *)(v4 + 344) + 4) <= 5 )
      return Scr_AddInt(1);
  }
  return Scr_AddInt(0);
}
// 8110DA4: using guessed type int var_1018[1026];

//----- (08110EAC) --------------------------------------------------------
int sub_8110EAC()
{
  return Scr_AddInt(*(int *)dword_859B5F8);
}

//----- (08110EC2) --------------------------------------------------------
void sub_8110EC2()
{
  char *v0; // eax
  char dest; // [esp+10h] [ebp-418h]
  char *s1; // [esp+418h] [ebp-10h]
  int i; // [esp+41Ch] [ebp-Ch]

  s1 = (char *)sub_808456A(0);
  for ( i = 0; i <= 31; ++i )
  {
    sub_809107E(i + 1246, &dest, 1024);
    if ( !I_stricmp(&dest, s1) )
    {
      Com_DPrintf("Script tried to precache the menu '%s' more than once\n", s1);
      return;
    }
  }
  for ( i = 0; i <= 31; ++i )
  {
    sub_809107E(i + 1246, &dest, 1024);
    if ( !dest )
      break;
  }
  if ( i == 32 )
  {
    v0 = va("Too many menus precached. Max allowed menus is %i", 32);
    sub_8084DB4((int)v0);
  }
  sub_8090E6C(i + 1246, s1);
}

//----- (08110FC2) --------------------------------------------------------
int __cdecl sub_8110FC2(char *a1)
{
  char *v1; // eax
  char dest; // [esp+20h] [ebp-418h]
  int i; // [esp+42Ch] [ebp-Ch]

  for ( i = 0; i <= 31; ++i )
  {
    sub_809107E(i + 1246, &dest, 1024);
    if ( !I_stricmp(&dest, a1) )
      return i;
  }
  v1 = va("Menu '%s' was not precached\n", a1);
  sub_8084DB4((int)v1);
  return 0;
}

//----- (08111054) --------------------------------------------------------
void sub_8111054()
{
  char *v0; // eax
  char dest; // [esp+10h] [ebp-418h]
  char *s1; // [esp+418h] [ebp-10h]
  int i; // [esp+41Ch] [ebp-Ch]

  s1 = (char *)sub_808456A(0);
  for ( i = 0; i <= 7; ++i )
  {
    sub_809107E(i + 23, &dest, 1024);
    if ( !I_stricmp(&dest, s1) )
    {
      Com_DPrintf("Script tried to precache the player status icon '%s' more than once\n", s1);
      return;
    }
  }
  for ( i = 0; i <= 7; ++i )
  {
    sub_809107E(i + 23, &dest, 1024);
    if ( !dest )
      break;
  }
  if ( i == 8 )
  {
    v0 = va("Too many player status icons precached. Max allowed is %i", 8);
    sub_8084DB4((int)v0);
  }
  sub_8090E6C(i + 23, s1);
}

//----- (0811114A) --------------------------------------------------------
int __cdecl sub_811114A(char *a1)
{
  char *v1; // eax
  char dest; // [esp+20h] [ebp-418h]
  int i; // [esp+42Ch] [ebp-Ch]

  if ( !*a1 )
    return 0;
  for ( i = 0; i <= 7; ++i )
  {
    sub_809107E(i + 23, &dest, 1024);
    if ( !I_stricmp(&dest, a1) )
      return i + 1;
  }
  v1 = va("Status icon '%s' was not precached\n", a1);
  sub_8084DB4((int)v1);
  return 0;
}

//----- (081111F2) --------------------------------------------------------
void sub_81111F2()
{
  char *v0; // eax
  char dest; // [esp+10h] [ebp-418h]
  char *s1; // [esp+418h] [ebp-10h]
  int i; // [esp+41Ch] [ebp-Ch]

  s1 = (char *)sub_808456A(0);
  for ( i = 0; i <= 14; ++i )
  {
    sub_809107E(i + 31, &dest, 1024);
    if ( !I_stricmp(&dest, s1) )
    {
      Com_DPrintf("Script tried to precache the player head icon '%s' more than once\n", s1);
      return;
    }
  }
  for ( i = 0; i <= 14; ++i )
  {
    sub_809107E(i + 31, &dest, 1024);
    if ( !dest )
      break;
  }
  if ( i == 15 )
  {
    v0 = va("Too many player head icons precached. Max allowed is %i", 15);
    sub_8084DB4((int)v0);
  }
  sub_8090E6C(i + 31, s1);
}

//----- (081112E8) --------------------------------------------------------
int __cdecl sub_81112E8(char *a1)
{
  char *v1; // eax
  char dest; // [esp+20h] [ebp-418h]
  int i; // [esp+42Ch] [ebp-Ch]

  if ( !*a1 )
    return 0;
  for ( i = 0; i <= 14; ++i )
  {
    sub_809107E(i + 31, &dest, 1024);
    if ( !I_stricmp(&dest, a1) )
      return i + 1;
  }
  v1 = va("Head icon '%s' was not precached\n", a1);
  sub_8084DB4((int)v1);
  return 0;
}

//----- (08111390) --------------------------------------------------------
int sub_8111390()
{
  char *v0; // eax
  int result; // eax
  float v2[4]; // [esp+20h] [ebp-98h]
  int v3; // [esp+30h] [ebp-88h]
  int v4; // [esp+4Ch] [ebp-6Ch]
  float s; // [esp+50h] [ebp-68h]
  int v6; // [esp+54h] [ebp-64h]
  int v7; // [esp+60h] [ebp-58h]
  unsigned __int16 v8; // [esp+6Ch] [ebp-4Ch]
  int v9; // [esp+80h] [ebp-38h]
  int v10; // [esp+84h] [ebp-34h]
  int *v11; // [esp+88h] [ebp-30h]
  int v12; // [esp+8Ch] [ebp-2Ch]
  int v13; // [esp+90h] [ebp-28h]
  int v14; // [esp+A0h] [ebp-18h]

  v11 = 0;
  v10 = 1023;
  v9 = 41953329;
  sub_80846F8(0, &v14);
  sub_80846F8(1u, &v13);
  v12 = sub_808404C(2u);
  if ( !v12 )
    v9 &= 0xFDFFFFFF;
  if ( sub_80849A8(3u) == 1 && sub_8084A50(3u) == 21 )
  {
    v11 = (int *)sub_8118CDE(3u);
    v10 = *v11;
  }
  sub_8108134(&s, (int)&v14, (int)&v13, v10, v9, 0);
  sub_8084CF0();
  Scr_AddFloat(SLODWORD(s));
  sub_8084D6E((unsigned __int16)word_87A22B6);
  sub_80DEB7A((int)&v14, (int)&v13, s, (int)&v3);
  Scr_AddVector(&v3);
  sub_8084D6E((unsigned __int16)word_87A22D4);
  if ( v8 != 1023 && v8 != 1022 )
    Scr_AddEntity((int *)(560 * v8 + 140924032));
  else
    Scr_AddUndefined();
  sub_8084D6E((unsigned __int16)word_87A22B2);
  if ( s >= 1.0 )
  {
    sub_811627E((float *)&v13, (float *)&v14, v2);
    sub_80A20C0(v2);
    Scr_AddVector(v2);
    sub_8084D6E((unsigned __int16)word_87A22CC);
    sub_8084C8E((unsigned __int16)word_87A2314);
    result = sub_8084D6E((unsigned __int16)word_87A22EC);
  }
  else
  {
    Scr_AddVector(&v6);
    sub_8084D6E((unsigned __int16)word_87A22CC);
    v4 = (unsigned __int8)((v7 & 0x1F00000) >> 20);
    v0 = (char *)sub_80B6EB2(v4);
    Scr_AddString(v0);
    result = sub_8084D6E((unsigned __int16)word_87A22EC);
  }
  return result;
}
// 87A22B2: using guessed type __int16 word_87A22B2;
// 87A22B6: using guessed type __int16 word_87A22B6;
// 87A22CC: using guessed type __int16 word_87A22CC;
// 87A22D4: using guessed type __int16 word_87A22D4;
// 87A22EC: using guessed type __int16 word_87A22EC;
// 87A2314: using guessed type __int16 word_87A2314;

//----- (081115C2) --------------------------------------------------------
int sub_81115C2()
{
  int v0; // eax
  int v2; // [esp+10h] [ebp-38h]
  int v3; // [esp+14h] [ebp-34h]
  float v4[4]; // [esp+20h] [ebp-28h]
  float v5[6]; // [esp+30h] [ebp-18h]

  v3 = 1023;
  v2 = 41953329;
  sub_80846F8(0, v5);
  sub_80846F8(1u, v4);
  if ( !sub_808404C(2u) )
    v2 = 8398897;
  if ( sub_80849A8(3u) == 1 && sub_8084A50(3u) == 21 )
    v3 = *(_DWORD *)sub_8118CDE(3u);
  v0 = sub_810818A(v5, v4, v3, v2);
  return Scr_AddBool(v0);
}

//----- (08111684) --------------------------------------------------------
int sub_8111684()
{
  int v1; // [esp+2Ch] [ebp-3Ch]
  int v2; // [esp+30h] [ebp-38h]
  int v3; // [esp+34h] [ebp-34h]
  int *v4; // [esp+38h] [ebp-30h]
  int v5; // [esp+3Ch] [ebp-2Ch]
  float v6[4]; // [esp+40h] [ebp-28h]
  float v7[6]; // [esp+50h] [ebp-18h]

  v4 = 0;
  v3 = 1023;
  v2 = 41949187;
  sub_80846F8(0, v7);
  sub_80846F8(1u, v6);
  v5 = sub_808404C(2u);
  if ( !v5 )
    v2 &= 0xFDFFFFFF;
  if ( sub_80849A8(3u) == 1 && sub_8084A50(3u) == 21 )
  {
    v4 = (int *)sub_8118CDE(3u);
    v3 = *v4;
  }
  sub_81081DA(&v1, v7, v6, v3, v2);
  if ( !v1 && sub_808F1DC(v7, v6) < 0.2 )
    v1 = 1;
  return Scr_AddBool(v1 == 0);
}
// 808F1DC: using guessed type double __cdecl sub_808F1DC(_DWORD, _DWORD);

//----- (08111786) --------------------------------------------------------
_DWORD *sub_8111786()
{
  float s; // [esp+20h] [ebp-68h]
  int v2; // [esp+50h] [ebp-38h]
  int v3; // [esp+60h] [ebp-28h]
  int v4; // [esp+70h] [ebp-18h]

  sub_80846F8(0, &v4);
  sub_80846F8(1u, &v3);
  sub_8108090(&s, (int)&v4, (int)&unk_8145E68, (int)&unk_8145E68, (int)&v3, 1023, 8519697);
  sub_80DEB7A((int)&v4, (int)&v3, s, (int)&v2);
  return Scr_AddVector(&v2);
}

//----- (0811181C) --------------------------------------------------------
void sub_811181C()
{
  int v0; // eax
  int v1; // [esp+14h] [ebp-4h]

  v1 = sub_808404C(0);
  if ( v1 > 0 )
  {
    v0 = sub_80A8776(0, v1);
    Scr_AddInt(v0);
  }
  else
  {
    Com_Printf("RandomInt parm: %d  ", v1);
    sub_8084DB4((int)"RandomInt parm must be positive integer.\n");
  }
}

//----- (08111876) --------------------------------------------------------
int sub_8111876()
{
  float v0; // ST14_4
  int v1; // ST00_4

  v0 = sub_8084320(0);
  *(float *)&v1 = sub_80A8720(0.0, v0);
  return Scr_AddFloat(v1);
}

//----- (081118AA) --------------------------------------------------------
int sub_81118AA()
{
  int v0; // eax
  int v2; // [esp+10h] [ebp-8h]
  int v3; // [esp+14h] [ebp-4h]

  v3 = sub_808404C(0);
  v2 = sub_808404C(1u);
  if ( v2 <= v3 )
  {
    Com_Printf("RandomIntRange parms: %d %d ", v3, v2);
    sub_8084DB4((int)"RandomIntRange range must be positive integer.\n");
  }
  v0 = sub_80A8776(v3, v2);
  return Scr_AddInt(v0);
}

//----- (08111918) --------------------------------------------------------
int sub_8111918()
{
  int v0; // ST00_4
  float v2; // [esp+20h] [ebp-8h]
  float v3; // [esp+24h] [ebp-4h]

  v3 = sub_8084320(0);
  v2 = sub_8084320(1u);
  if ( v3 >= (long double)v2 )
  {
    Com_Printf("Scr_RandomFloatRange parms: %d %d ", v3, v2);
    sub_8084DB4((int)"Scr_RandomFloatRange range must be positive float.\n");
  }
  *(float *)&v0 = sub_80A8720(v3, v2);
  return Scr_AddFloat(v0);
}

//----- (0811198E) --------------------------------------------------------
int sub_811198E()
{
  long double v0; // fst7
  int v1; // ST14_4

  v0 = sub_8084320(0);
  *(float *)&v1 = sin(v0 * 0.0174532925199433);
  return Scr_AddFloat(v1);
}

//----- (081119C0) --------------------------------------------------------
int sub_81119C0()
{
  long double v0; // fst7
  int v1; // ST14_4

  v0 = sub_8084320(0);
  *(float *)&v1 = cos(v0 * 0.0174532925199433);
  return Scr_AddFloat(v1);
}

//----- (081119F2) --------------------------------------------------------
int sub_81119F2()
{
  float v0; // ST0C_4
  int v1; // ST00_4
  int v3; // [esp+10h] [ebp-8h]
  int v4; // [esp+14h] [ebp-4h]

  v0 = sub_8084320(0) * 0.0174532925199433;
  sub_811618E(v0, (int)&v4, (int)&v3);
  if ( *(float *)&v3 == 0.0 )
    sub_8084DB4((int)"divide by 0");
  *(float *)&v1 = *(float *)&v4 / *(float *)&v3;
  return Scr_AddFloat(v1);
}

//----- (08111A56) --------------------------------------------------------
int sub_8111A56()
{
  char *v0; // eax
  float v1; // ST10_4
  int v2; // ST10_4
  float v4; // [esp+14h] [ebp-4h]

  v4 = sub_8084320(0);
  if ( v4 < -1.0 || v4 > 1.0 )
  {
    v0 = va("%g out of range", v4);
    sub_8084DB4((int)v0);
  }
  v1 = asin(v4);
  *(float *)&v2 = v1 * 57.29577951308232;
  return Scr_AddFloat(v2);
}

//----- (08111AD0) --------------------------------------------------------
int sub_8111AD0()
{
  char *v0; // eax
  float v1; // ST10_4
  int v2; // ST10_4
  float v4; // [esp+14h] [ebp-4h]

  v4 = sub_8084320(0);
  if ( v4 < -1.0 || v4 > 1.0 )
  {
    v0 = va("%g out of range", v4);
    sub_8084DB4((int)v0);
  }
  v1 = acos(v4);
  *(float *)&v2 = v1 * 57.29577951308232;
  return Scr_AddFloat(v2);
}

//----- (08111B4A) --------------------------------------------------------
int sub_8111B4A()
{
  long double v0; // fst7
  float v1; // ST14_4
  int v2; // ST14_4

  v0 = sub_8084320(0);
  v1 = atan(v0);
  *(float *)&v2 = v1 * 57.29577951308232;
  return Scr_AddFloat(v2);
}

//----- (08111B82) --------------------------------------------------------
void sub_8111B82()
{
  int v0; // eax
  int v1; // ST10_4
  const char *v2; // eax
  int v3; // eax
  int v4; // eax
  char *v5; // eax
  int v6; // [esp+Ch] [ebp-Ch]

  v6 = sub_80849A8(0);
  if ( v6 == 5 )
  {
    v1 = (signed int)sub_8084320(0);
    Scr_AddInt(v1);
    return;
  }
  if ( v6 > 5 )
  {
    if ( v6 == 6 )
    {
      v0 = sub_808404C(0);
      Scr_AddInt(v0);
      return;
    }
  }
  else if ( v6 == 2 )
  {
    v2 = (const char *)sub_808456A(0);
    v3 = atoi(v2);
    Scr_AddInt(v3);
    return;
  }
  v4 = sub_80849F8(0);
  v5 = va("cannot cast %s to int", v4);
  sub_8084E14(0, (int)v5);
}

//----- (08111C46) --------------------------------------------------------
int sub_8111C46()
{
  int v0; // ST00_4
  char v2; // [esp+10h] [ebp-28h]
  char v3; // [esp+20h] [ebp-18h]

  sub_80846F8(0, &v3);
  sub_80846F8(1u, &v2);
  *(float *)&v0 = sub_80A1D86(&v3, &v2);
  return Scr_AddFloat(v0);
}
// 80A1D86: using guessed type double __cdecl sub_80A1D86(_DWORD, _DWORD);

//----- (08111C8E) --------------------------------------------------------
int sub_8111C8E()
{
  int v0; // ST00_4
  float v2[4]; // [esp+10h] [ebp-28h]
  float v3[6]; // [esp+20h] [ebp-18h]

  sub_80846F8(0, v3);
  sub_80846F8(1u, v2);
  *(float *)&v0 = sub_80A1DB2(v3, v2);
  return Scr_AddFloat(v0);
}

//----- (08111CD6) --------------------------------------------------------
int sub_8111CD6()
{
  int v0; // ST00_4
  char v2; // [esp+10h] [ebp-18h]

  sub_80846F8(0, &v2);
  *(float *)&v0 = sub_8116362(&v2);
  return Scr_AddFloat(v0);
}
// 8116362: using guessed type double __cdecl sub_8116362(_DWORD);

//----- (08111D04) --------------------------------------------------------
int sub_8111D04()
{
  int v0; // ST00_4
  float v2[6]; // [esp+10h] [ebp-18h]

  sub_80846F8(0, v2);
  *(float *)&v0 = sub_811632E(v2);
  return Scr_AddFloat(v0);
}

//----- (08111D32) --------------------------------------------------------
int sub_8111D32()
{
  float v0; // ST1C_4
  float v1; // ST18_4
  float v3[4]; // [esp+20h] [ebp-38h]
  float v4[4]; // [esp+30h] [ebp-28h]
  float v5[6]; // [esp+40h] [ebp-18h]

  sub_80846F8(0, v5);
  sub_80846F8(1u, v4);
  sub_80846F8(2u, v3);
  v0 = sub_80A1DB2(v4, v5);
  v1 = sub_80A1DB2(v3, v5);
  return Scr_AddInt(v1 > (long double)v0);
}

//----- (08111DB8) --------------------------------------------------------
int sub_8111DB8()
{
  int v0; // ST00_4
  float v2[4]; // [esp+10h] [ebp-28h]
  float v3[6]; // [esp+20h] [ebp-18h]

  sub_80846F8(0, v3);
  sub_80846F8(1u, v2);
  *(float *)&v0 = sub_81162FA(v3, v2);
  return Scr_AddFloat(v0);
}

//----- (08111E00) --------------------------------------------------------
_DWORD *sub_8111E00()
{
  float v1[4]; // [esp+10h] [ebp-28h]
  char v2; // [esp+20h] [ebp-18h]

  sub_80846F8(0, &v2);
  sub_811620A(&v2, v1);
  sub_80A20C0(v1);
  return Scr_AddVector(v1);
}

//----- (08111E46) --------------------------------------------------------
_DWORD *sub_8111E46()
{
  char v1; // [esp+10h] [ebp-28h]
  float v2[6]; // [esp+20h] [ebp-18h]

  sub_80846F8(0, v2);
  sub_80A2C7E(v2, (int)&v1);
  return Scr_AddVector(&v1);
}

//----- (08111E7E) --------------------------------------------------------
_DWORD *sub_8111E7E()
{
  float v1[4]; // [esp+10h] [ebp-28h]
  float v2[6]; // [esp+20h] [ebp-18h]

  sub_80846F8(0, v2);
  sub_80A2EC2(v2, 0, 0, v1);
  return Scr_AddVector(v1);
}

//----- (08111EC6) --------------------------------------------------------
_DWORD *sub_8111EC6()
{
  float v1[4]; // [esp+10h] [ebp-28h]
  float v2[6]; // [esp+20h] [ebp-18h]

  sub_80846F8(0, v2);
  sub_80A2EC2(v2, 0, v1, 0);
  return Scr_AddVector(v1);
}

//----- (08111F0E) --------------------------------------------------------
_DWORD *sub_8111F0E()
{
  char v1; // [esp+10h] [ebp-28h]
  float v2[6]; // [esp+20h] [ebp-18h]

  sub_80846F8(0, v2);
  sub_80A2EC2(v2, (int)&v1, 0, 0);
  return Scr_AddVector(&v1);
}

//----- (08111F56) --------------------------------------------------------
int sub_8111F56()
{
  const char *v0; // ebx
  const char *v1; // eax
  char *v2; // eax

  v0 = (const char *)sub_808456A(1u);
  v1 = (const char *)sub_808456A(0);
  v2 = strstr(v1, v0);
  return Scr_AddBool(v2 != 0);
}

//----- (08111F9A) --------------------------------------------------------
int sub_8111F9A()
{
  int v1; // [esp+14h] [ebp-424h]
  char v2; // [esp+1Bh] [ebp-41Dh]
  signed int i; // [esp+1Ch] [ebp-41Ch]
  int v4; // [esp+20h] [ebp-418h]
  int v5; // [esp+28h] [ebp-410h]
  int v6; // [esp+2Ch] [ebp-40Ch]
  char s[1032]; // [esp+30h] [ebp-408h]

  v6 = sub_808456A(0);
  v5 = sub_808404C(1u);
  if ( (unsigned int)sub_8084AEE() <= 2 )
    v1 = 0x7FFFFFFF;
  else
    v1 = sub_808404C(2u);
  v4 = v5;
  for ( i = 0; v4 < v1; ++i )
  {
    if ( i > 1023 )
      sub_8084DB4((int)"string too long");
    v2 = *(_BYTE *)(v6 + v4);
    if ( !v2 )
      break;
    s[i] = v2;
    ++v4;
  }
  s[i] = 0;
  return Scr_AddString(s);
}
// 8111F9A: using guessed type char s[1032];

//----- (081120A2) --------------------------------------------------------
void sub_81120A2()
{
  char v0; // al
  signed int v1; // [esp+18h] [ebp-410h]
  char *v2; // [esp+1Ch] [ebp-40Ch]
  char s[1032]; // [esp+20h] [ebp-408h]

  v2 = (char *)sub_808456A(0);
  v1 = 0;
  while ( v1 <= 1023 )
  {
    v0 = tolower(*v2);
    s[v1] = v0;
    if ( !v0 )
    {
      Scr_AddString(s);
      return;
    }
    ++v1;
    ++v2;
  }
  sub_8084DB4((int)"string too long");
}
// 81120A2: using guessed type char s[1032];

//----- (0811213C) --------------------------------------------------------
int sub_811213C()
{
  int result; // eax
  signed int j; // [esp+14h] [ebp-424h]
  char v2; // [esp+1Bh] [ebp-41Dh]
  signed int v3; // [esp+1Ch] [ebp-41Ch]
  int i; // [esp+20h] [ebp-418h]
  signed int v5; // [esp+24h] [ebp-414h]
  char *s; // [esp+28h] [ebp-410h]
  int v7; // [esp+2Ch] [ebp-40Ch]
  char v8[1032]; // [esp+30h] [ebp-408h]

  v7 = sub_808456A(0);
  s = (char *)sub_808456A(1u);
  v5 = strlen(s);
  v3 = 0;
  sub_8084CF0();
  for ( i = 0; ; ++i )
  {
    result = *(unsigned __int8 *)(v7 + i);
    v2 = *(_BYTE *)(v7 + i);
    if ( !v2 )
      break;
    for ( j = 0; j < v5; ++j )
    {
      if ( v2 == s[j] )
      {
        if ( v3 )
        {
          v8[v3] = 0;
          Scr_AddString(v8);
          sub_8084D1C();
          v3 = 0;
        }
        goto LABEL_11;
      }
    }
    v8[v3++] = v2;
    if ( v3 > 1023 )
      sub_8084DB4((int)"string too long");
LABEL_11:
    ;
  }
  if ( v3 )
  {
    v8[v3] = 0;
    Scr_AddString(v8);
    result = sub_8084D1C();
  }
  return result;
}
// 811213C: using guessed type char var_408[1032];

//----- (081122AC) --------------------------------------------------------
int sub_81122AC()
{
  int v0; // eax
  char *v1; // eax

  v0 = sub_808456A(0);
  v1 = va("%c %s", 111, v0);
  return sub_808FE96(-1, 1, (int)v1);
}

//----- (081122F0) --------------------------------------------------------
void sub_81122F0()
{
  float v0; // ST00_4
  char *v1; // eax
  char *v2; // eax
  char *v3; // eax
  int v4; // [esp+10h] [ebp-8h]
  int v5; // [esp+14h] [ebp-4h]

  v4 = sub_8084AEE();
  if ( v4 )
  {
    if ( v4 != 1 )
    {
      v1 = va("USAGE: musicStop([fadetime]);\n");
      sub_8084DB4((int)v1);
      return;
    }
    v0 = sub_8084320(0) * 1000.0;
    v5 = sub_8116158(v0);
  }
  else
  {
    v5 = 0;
  }
  if ( v5 < 0 )
  {
    v2 = va("musicStop: fade time must be >= 0\n");
    sub_8084DB4((int)v2);
  }
  v3 = va("%c %i", 112, v5);
  sub_808FE96(-1, 1, (int)v3);
}

//----- (0811239C) --------------------------------------------------------
int sub_811239C()
{
  char *v0; // eax
  signed int v2; // [esp+20h] [ebp-8h]
  float v3; // [esp+24h] [ebp-4h]

  v3 = sub_8084320(0);
  if ( (unsigned int)sub_8084AEE() <= 1 )
    v2 = 0;
  else
    v2 = (signed int)(sub_8084320(1u) * 1000.0);
  v0 = va("%c %f %i\n", 113, v3, v2);
  return sub_808FE96(-1, 1, (int)v0);
}

//----- (0811242C) --------------------------------------------------------
int sub_811242C()
{
  char *v0; // eax

  if ( !dword_859B41C )
    sub_8084DB4((int)"precacheModel must be called before any wait statements in the gametype or level script\n");
  v0 = (char *)sub_808456A(0);
  return sub_811B00C(v0);
}

//----- (0811245E) --------------------------------------------------------
int sub_811245E()
{
  char *v0; // eax

  if ( !dword_859B41C )
    sub_8084DB4((int)"precacheShellShock must be called before any wait statements in the gametype or level script\n");
  v0 = (char *)sub_808456A(0);
  return sub_811B1A4(v0);
}

//----- (08112490) --------------------------------------------------------
int sub_8112490()
{
  char *v0; // eax
  char *v2; // [esp+10h] [ebp-8h]
  char *v3; // [esp+14h] [ebp-4h]

  if ( !dword_859B41C )
    sub_8084DB4((int)"precacheItem must be called before any wait statements in the gametype or level script\n");
  v3 = (char *)sub_808456A(0);
  v2 = sub_80DCB02(v3);
  if ( !v2 )
  {
    v0 = va("unknown item '%s'", v3);
    sub_8084E14(0, (int)v0);
  }
  return sub_8104C84(-1171354717 * ((v2 - (char *)&unk_8164C20) >> 2), 1);
}

//----- (0811251A) --------------------------------------------------------
int sub_811251A()
{
  char *src; // [esp+14h] [ebp-4h]

  if ( !dword_859B41C )
    sub_8084DB4((int)"precacheShader must be called before any wait statements in the gametype or level script\n");
  src = (char *)sub_808456A(0);
  if ( !*src )
    sub_8084E14(0, (int)"Shader name string is empty");
  return sub_811AFBA(src);
}

//----- (0811256E) --------------------------------------------------------
char *sub_811256E()
{
  char *result; // eax

  if ( !dword_859B41C )
    sub_8084DB4((int)"precacheString must be called before any wait statements in the gametype or level script\n");
  result = (char *)sub_80846DC(0);
  if ( *result )
    result = (char *)sub_811AF6E(result);
  return result;
}

//----- (081125B4) --------------------------------------------------------
void sub_81125B4()
{
  float v0; // ST00_4
  char *v1; // eax
  char *v2; // eax
  char *v3; // eax
  char *v4; // eax
  int v5; // [esp+Ch] [ebp-Ch]
  _BYTE *v6; // [esp+10h] [ebp-8h]
  int v7; // [esp+14h] [ebp-4h]

  v7 = 0;
  v5 = sub_8084AEE();
  if ( v5 != 1 )
  {
    if ( v5 != 2 )
    {
      v1 = va("USAGE: ambientPlay(alias_name, <fadetime>);\n");
      sub_8084DB4((int)v1);
      return;
    }
    v0 = sub_8084320(1u) * 1000.0;
    v7 = sub_8116158(v0);
  }
  v6 = (_BYTE *)sub_808456A(0);
  if ( !*v6 )
  {
    v2 = va("ambientPlay: alias name cannot be the empty string... use stop or fade version\n");
    sub_8084DB4((int)v2);
  }
  if ( v7 < 0 )
  {
    v3 = va("ambientPlay: fade time must be >= 0\n");
    sub_8084DB4((int)v3);
  }
  v4 = va("n\\%s\\t\\%i", v6, dword_859B5EC + v7);
  sub_8090E6C(3, v4);
}

//----- (0811268C) --------------------------------------------------------
void sub_811268C()
{
  float v0; // ST00_4
  char *v1; // eax
  char *v2; // eax
  char *v3; // eax
  int v4; // [esp+10h] [ebp-8h]
  int v5; // [esp+14h] [ebp-4h]

  v4 = sub_8084AEE();
  if ( v4 )
  {
    if ( v4 != 1 )
    {
      v1 = va("USAGE: ambientStop(<fadetime>);\n");
      sub_8084DB4((int)v1);
      return;
    }
    v0 = sub_8084320(0) * 1000.0;
    v5 = sub_8116158(v0);
  }
  else
  {
    v5 = 0;
  }
  if ( v5 < 0 )
  {
    v2 = va("ambientStop: fade time must be >= 0\n");
    sub_8084DB4((int)v2);
  }
  v3 = va("t\\%i", dword_859B5EC + v5);
  sub_8090E6C(3, v3);
}

//----- (0811272E) --------------------------------------------------------
int sub_811272E()
{
  int result; // eax
  char s; // [esp+20h] [ebp-88h]
  int v2; // [esp+30h] [ebp-78h]
  int v3; // [esp+5Ch] [ebp-4Ch]
  int v4; // [esp+60h] [ebp-48h]
  float v5; // [esp+68h] [ebp-40h]
  int v6; // [esp+70h] [ebp-38h]
  float v7; // [esp+78h] [ebp-30h]
  float v8[4]; // [esp+80h] [ebp-28h]
  char v9; // [esp+90h] [ebp-18h]

  sub_80846F8(0, &v9);
  sub_811620A(&v9, &v6);
  v7 = v7 + 1.0;
  v3 = sub_811CB34(&v6, 188);
  sub_81161E6(v8, 0, 0, 1065353216);
  *(_DWORD *)(v3 + 160) = (unsigned __int8)sub_80A1C2A(v8);
  sub_811620A(&v6, &v4);
  v5 = v5 - 17.0;
  sub_8108090(&s, (int)&v6, (int)&unk_8145E68, (int)&unk_8145E68, (int)&v4, 1023, 2065);
  result = (unsigned __int8)((v2 & 0x1F00000) >> 20);
  *(_DWORD *)(v3 + 136) = result;
  return result;
}

//----- (08112836) --------------------------------------------------------
int sub_8112836()
{
  float v0; // ST2C_4
  float v1; // ST28_4
  float v2; // ST24_4
  int result; // eax
  int v4; // [esp+30h] [ebp-18h]

  sub_80846F8(0, &v4);
  v0 = sub_8084320(1u);
  v1 = sub_8084320(2u);
  v2 = sub_8084320(3u);
  dword_859E9F4 = dword_859E9F8;
  result = sub_80FFE10((int)&v4, 0, (int)&dword_86F1020, v1, v2, v0, 0, 14);
  dword_859E9F4 = 0;
  return result;
}
// 859E9F4: using guessed type int dword_859E9F4;
// 859E9F8: using guessed type int dword_859E9F8;
// 86F1020: using guessed type int dword_86F1020;

//----- (081128D2) --------------------------------------------------------
int sub_81128D2()
{
  int result; // eax

  result = sub_808404C(0);
  dword_859E9F8 = result;
  return result;
}
// 859E9F8: using guessed type int dword_859E9F8;

//----- (081128EC) --------------------------------------------------------
_DWORD *sub_81128EC()
{
  int v0; // eax
  int v2; // [esp+20h] [ebp-38h]
  int v3; // [esp+24h] [ebp-34h]
  float v4; // [esp+28h] [ebp-30h]
  float v5; // [esp+2Ch] [ebp-2Ch]
  int v6; // [esp+30h] [ebp-28h]
  int v7; // [esp+40h] [ebp-18h]
  int v8; // [esp+4Ch] [ebp-Ch]

  v5 = 0.0;
  v4 = 1.0;
  v2 = sub_8084AEE();
  if ( v2 != 1 )
  {
    if ( v2 != 2 )
    {
      v4 = sub_8084320(2u);
      if ( v4 < 0.0 || v4 > 1.0 )
        sub_8084E14(2, (int)"end time must be between 0 and 1");
    }
    v5 = sub_8084320(1u);
    if ( v5 < 0.0 || v5 > 1.0 )
      sub_8084E14(1, (int)"start time must be between 0 and 1");
  }
  sub_80840DA((unsigned __int16 *)&v3, 0, 0);
  v8 = v3;
  v0 = sub_806D074(HIWORD(v3));
  sub_80BF08C(v0, (unsigned __int16)v8, (int)&v7, (int)&v6, v5, v4);
  return Scr_AddVector(&v6);
}

//----- (08112A04) --------------------------------------------------------
int sub_8112A04()
{
  int v0; // eax
  int v1; // ST00_4
  int v3; // [esp+20h] [ebp-38h]
  int v4; // [esp+24h] [ebp-34h]
  float v5; // [esp+28h] [ebp-30h]
  float v6; // [esp+2Ch] [ebp-2Ch]
  int v7; // [esp+30h] [ebp-28h]
  int v8; // [esp+40h] [ebp-18h]
  int v9; // [esp+4Ch] [ebp-Ch]

  v6 = 0.0;
  v5 = 1.0;
  v3 = sub_8084AEE();
  if ( v3 != 1 )
  {
    if ( v3 != 2 )
    {
      v5 = sub_8084320(2u);
      if ( v5 < 0.0 || v5 > 1.0 )
        sub_8084E14(2, (int)"end time must be between 0 and 1");
    }
    v6 = sub_8084320(1u);
    if ( v6 < 0.0 || v6 > 1.0 )
      sub_8084E14(1, (int)"start time must be between 0 and 1");
  }
  sub_80840DA((unsigned __int16 *)&v4, 0, 0);
  v9 = v4;
  v0 = sub_806D074(HIWORD(v4));
  sub_80BF08C(v0, (unsigned __int16)v9, (int)&v8, (int)&v7, v6, v5);
  *(float *)&v1 = sub_80A5774((float *)&v8);
  return Scr_AddFloat(v1);
}

//----- (08112B24) --------------------------------------------------------
int sub_8112B24()
{
  int v0; // ST1C_4
  char nptr; // [esp+20h] [ebp-28h]

  sub_809107E(11, &nptr, 32);
  *(float *)&v0 = atof(&nptr);
  return Scr_AddFloat(v0);
}

//----- (08112B60) --------------------------------------------------------
int sub_8112B60()
{
  char *s2; // ST10_4
  int v2; // [esp+14h] [ebp-4h]

  s2 = (char *)sub_808456A(0);
  v2 = sub_811B170(s2);
  if ( !v2 && !dword_859B41C )
    sub_8084DB4((int)"loadFx must be called before any wait statements in the gametype or level script, or on an already loaded effect\n");
  return Scr_AddInt(v2);
}

//----- (08112BAC) --------------------------------------------------------
void __cdecl sub_8112BAC(int a1, int a2)
{
  char *v2; // eax
  char dest; // [esp+10h] [ebp-408h]

  if ( a2 )
    sub_809107E(a2 + 846, &dest, 1024);
  else
    strcpy(&dest, "not successfully loaded");
  v2 = va("%s (effect = %s)\n", a1, &dest);
  sub_8084DB4((int)v2);
}

//----- (08112C1C) --------------------------------------------------------
int sub_8112C1C()
{
  int result; // eax
  float v1; // ST04_4
  float v2; // ST04_4
  float v3; // ST04_4
  int v4; // [esp+10h] [ebp-58h]
  int v5; // [esp+1Ch] [ebp-4Ch]
  int v6; // [esp+28h] [ebp-40h]
  char v7; // [esp+40h] [ebp-28h]
  float v8; // [esp+50h] [ebp-18h]
  int v9; // [esp+54h] [ebp-14h]
  int v10; // [esp+58h] [ebp-10h]
  int v11; // [esp+5Ch] [ebp-Ch]

  v9 = sub_8084AEE();
  if ( v9 <= 1 || v9 > 4 )
    sub_8084DB4((int)"Incorrect number of parameters");
  v10 = sub_808404C(0);
  sub_80846F8(1u, &v7);
  v11 = sub_811CB34(&v7, 194);
  *(_DWORD *)(v11 + 160) = (unsigned __int8)v10;
  if ( v9 == 2 )
  {
    result = -1028390912;
    *(_DWORD *)(v11 + 60) = -1028390912;
  }
  else
  {
    sub_80846F8(2u, &v4);
    v8 = sub_8116362(&v4);
    if ( v8 == 0.0 )
      sub_8112BAC((int)"playFx called with (0 0 0) forward direction", v10);
    v1 = 1.0 / v8;
    sub_81162C2((int)&v4, v1, (int)&v4);
    if ( v9 == 3 )
    {
      result = sub_80A2C7E((float *)&v4, v11 + 60);
    }
    else
    {
      sub_80846F8(3u, &v6);
      v8 = sub_8116362(&v6);
      if ( v8 == 0.0 )
        sub_8112BAC((int)"playFx called with (0 0 0) up direction", v10);
      v2 = 1.0 / v8;
      sub_81162C2((int)&v6, v2, (int)&v6);
      sub_80A1ED8((float *)&v6, (float *)&v4, (float *)&v5);
      v8 = sub_8116362(&v5);
      if ( v8 >= 0.001 )
      {
        if ( v8 < 0.99900001 )
        {
          v3 = 1.0 / v8;
          sub_81162C2((int)&v5, v3, (int)&v5);
          sub_80A1ED8((float *)&v4, (float *)&v5, (float *)&v6);
        }
      }
      else
      {
        sub_8112BAC((int)"playFx called an up direction 0 or 180 degrees from forward", v10);
      }
      result = sub_80A71F4((int)&v4, v11 + 60);
    }
  }
  return result;
}
// 8116362: using guessed type double __cdecl sub_8116362(_DWORD);

//----- (08112E4E) --------------------------------------------------------
int sub_8112E4E()
{
  char *v0; // eax
  int v1; // eax
  const char *v2; // eax
  char *v3; // eax
  char *v4; // eax
  int v5; // eax
  char *v6; // eax
  int v7; // ST20_4
  int v9; // [esp+18h] [ebp-10h]
  int v10; // [esp+1Ch] [ebp-Ch]
  int v11; // [esp+24h] [ebp-4h]

  if ( sub_8084AEE() != 3 )
    sub_8084DB4((int)"USAGE: playFxOnTag <effect id from loadFx> <entity> <tag name>");
  v11 = sub_808404C(0);
  if ( v11 <= 0 || v11 > 63 )
  {
    v0 = va("effect id %i is invalid\n", v11);
    sub_8084E14(0, (int)v0);
  }
  v10 = sub_8118CDE(1u);
  if ( !*(_BYTE *)(v10 + 356) )
    sub_8084E14(1, (int)"cannot play fx on entity with no model");
  v1 = sub_8084434(2u);
  v9 = v1;
  v2 = (const char *)sub_8078896(v1);
  if ( strchr(v2, 34) )
    sub_8084E14(2, (int)"cannot use \" characters in tag names\n");
  if ( sub_8090898((int *)v10, v9) < 0 )
  {
    sub_8090584((int *)v10);
    v3 = sub_811B124(*(unsigned __int8 *)(v10 + 356));
    v4 = va("tag '%s' does not exist on entity with model '%s'", v9, v3);
    sub_8084E14(2, (int)v4);
  }
  v5 = sub_8078896(v9);
  v6 = va("%02d%s", v11, v5);
  v7 = sub_811AE70(v6, 910, 256, 1, 0);
  return sub_811CDA2((_DWORD *)v10, 195, v7);
}

//----- (08112FDE) --------------------------------------------------------
int sub_8112FDE()
{
  char *v0; // eax
  char *v1; // eax
  float v2; // ST00_4
  char *v3; // eax
  int v4; // eax
  int v5; // ebx
  unsigned int v7; // [esp+1Ch] [ebp-45Ch]
  char dest; // [esp+20h] [ebp-458h]
  char v9[4]; // [esp+428h] [ebp-50h]
  float v10; // [esp+42Ch] [ebp-4Ch]
  float v11[4]; // [esp+430h] [ebp-48h]
  float v12[4]; // [esp+440h] [ebp-38h]
  char v13; // [esp+450h] [ebp-28h]
  int v14; // [esp+468h] [ebp-10h]
  int v15; // [esp+46Ch] [ebp-Ch]

  if ( (unsigned int)sub_8084AEE() <= 2 || (unsigned int)sub_8084AEE() > 6 )
    sub_8084DB4((int)"USAGE: playLoopedFx <effect id from loadFx> <repeat delay> <vector position of effect> <optional cu"
                     "ll distance (0 = never cull)> <optional forward vector> <optional up vector>");
  sub_81161BC(v12);
  sub_81161BC(v11);
  v10 = 0.0;
  v14 = sub_808404C(0);
  v7 = sub_8084AEE();
  if ( v7 == 5 )
  {
LABEL_14:
    sub_80846F8(4u, v12);
    if ( sub_80A20C0(v12) == 0.0 )
    {
      if ( v14 )
        sub_809107E(v14 + 846, &dest, 1024);
      else
        strcpy(&dest, "not successfully loaded");
      v1 = va("playLoopedFx called with (0 0 0) forward direction (effect = %s)\n", &dest);
      sub_8084DB4((int)v1);
    }
    goto LABEL_19;
  }
  if ( v7 > 5 )
  {
    if ( v7 != 6 )
      goto LABEL_20;
    sub_80846F8(5u, v11);
    if ( sub_80A20C0(v11) == 0.0 )
    {
      if ( v14 )
        sub_809107E(v14 + 846, &dest, 1024);
      else
        strcpy(&dest, "not successfully loaded");
      v0 = va("playLoopedFx called with (0 0 0) up direction (effect = %s)\n", &dest);
      sub_8084DB4((int)v0);
    }
    goto LABEL_14;
  }
  if ( v7 == 4 )
LABEL_19:
    v10 = sub_8084320(3u);
LABEL_20:
  sub_80846F8(2u, &v13);
  v2 = sub_8084320(1u) * 1000.0;
  *(_DWORD *)v9 = sub_8116158(v2);
  if ( *(_DWORD *)v9 <= 0 )
  {
    v3 = va("playLoopedFx called with %f s repeat (should be >= 0.0005s)\n", *(_DWORD *)v9);
    sub_8084DB4((int)v3);
  }
  v4 = sub_811C546();
  v15 = v4;
  *(_DWORD *)(v4 + 4) = 8;
  *(_BYTE *)(v15 + 242) |= 8u;
  *(_DWORD *)(v15 + 216) = (unsigned __int8)v14;
  sub_811CF36((_DWORD *)v15, &v13);
  sub_811620A(v12, (_DWORD *)(v15 + 92));
  v5 = v15;
  *(_DWORD *)(v5 + 160) = (unsigned __int8)sub_80A1C2A(v11);
  *(float *)(v15 + 104) = v10;
  *(float *)(v15 + 108) = (long double)*(signed int *)v9;
  sub_809A45E(v15);
  return Scr_AddEntity((int *)v15);
}

//----- (08113294) --------------------------------------------------------
void __cdecl sub_8113294(int a1, float a2, float a3, float a4, float a5, float a6, float a7, float a8)
{
  char *v8; // eax
  char *v9; // eax
  char *v10; // eax
  char *v11; // eax
  char *v12; // eax

  if ( a2 < 0.0 )
  {
    v8 = va("%s: near distance must be >= 0", a1);
    sub_8084DB4((int)v8);
  }
  if ( a2 >= (long double)a3 )
  {
    v9 = va("%s: near distance must be less than far distance", a1);
    sub_8084DB4((int)v9);
  }
  if ( a5 < 0.0 || a5 > 1.0 || a6 < 0.0 || a6 > 1.0 || a7 < 0.0 || a7 > 1.0 )
  {
    v10 = va("%s: red/green/blue color components must be in the range [0, 1]", a1);
    sub_8084DB4((int)v10);
  }
  if ( a8 < 0.0 )
  {
    v11 = va("%s: transition time must be >= 0 seconds", a1);
    sub_8084DB4((int)v11);
  }
  v12 = va("%g %g %g %g %g %g %.0f", a2, a3, a4, a5, a6, a7, (double)(a8 * 1000.0));
  sub_80FBD50(v12);
}

//----- (081133D0) --------------------------------------------------------
void sub_81133D0()
{
  float v0; // ST34_4
  float v1; // ST30_4
  float v2; // ST2C_4
  float v3; // ST28_4
  float v4; // ST24_4
  float v5; // ST20_4

  if ( sub_8084AEE() != 6 )
    sub_8084DB4((int)"USAGE: setCullFog(near distance, far distance, red, green, blue, transition time);\n");
  v0 = sub_8084320(0);
  v1 = sub_8084320(1u);
  v2 = sub_8084320(2u);
  v3 = sub_8084320(3u);
  v4 = sub_8084320(4u);
  v5 = sub_8084320(5u);
  sub_8113294((int)"setCullFog", v0, v1, 1.0, v2, v3, v4, v5);
}

//----- (08113488) --------------------------------------------------------
void sub_8113488()
{
  float v0; // [esp+24h] [ebp-14h]
  float v1; // [esp+28h] [ebp-10h]
  float v2; // [esp+2Ch] [ebp-Ch]
  float v3; // [esp+30h] [ebp-8h]
  float v4; // [esp+34h] [ebp-4h]

  if ( sub_8084AEE() != 5 )
    sub_8084DB4((int)"USAGE: setExpFog(density, red, green, blue, transition time);\n"
                     "Density must be greater than 0 and less than 1, and typically less than .001.  For example, .0002 m"
                     "eans the fog gets .02%% more dense for every 1 unit of distance (about 1%% thicker every 50 units of distance)\n");
  v4 = sub_8084320(0);
  v3 = sub_8084320(1u);
  v2 = sub_8084320(2u);
  v1 = sub_8084320(3u);
  v0 = sub_8084320(4u);
  if ( v4 <= 0.0 || v4 >= 1.0 )
    sub_8084DB4((int)"setExpFog: distance must be greater than 0 and less than 1");
  sub_8113294((int)"setExpFog", 0.0, 1.0, v4, v3, v2, v1, v0);
}

//----- (0811355A) --------------------------------------------------------
int sub_811355A()
{
  int result; // eax

  if ( sub_80849A8(0) == 1 && sub_8084A50(0) == 21 && *(_DWORD *)(sub_8118CDE(0) + 344) )
    result = Scr_AddInt(1);
  else
    result = Scr_AddInt(0);
  return result;
}

//----- (081135BA) --------------------------------------------------------
int sub_81135BA()
{
  int result; // eax
  int v1; // [esp+4h] [ebp-4h]

  v1 = sub_808404C(0);
  if ( v1 >= 0 && v1 <= 63 )
    result = Scr_AddInt(1);
  else
    result = Scr_AddInt(0);
  return result;
}

//----- (081135FA) --------------------------------------------------------
signed int sub_81135FA()
{
  char *v0; // eax
  signed int result; // eax
  char s1; // [esp+20h] [ebp-418h]
  int v3; // [esp+428h] [ebp-10h]
  char v4[4]; // [esp+42Ch] [ebp-Ch]

  *(_DWORD *)v4 = *(_DWORD *)sub_8118CDE(0) + 1;
  sub_809107E(22, &s1, 1024);
  v3 = (int)va("%i", *(_DWORD *)v4);
  v0 = sub_80B5B30(&s1, (int)"winner");
  result = I_stricmp(v0, (char *)v3);
  if ( result )
  {
    sub_80B5FF6(&s1, "winner", v3);
    result = sub_8090E6C(22, &s1);
  }
  return result;
}

//----- (081136B8) --------------------------------------------------------
void sub_81136B8()
{
  int v0; // eax
  char *v1; // eax
  char *v2; // eax
  char s1; // [esp+10h] [ebp-418h]
  int v4; // [esp+414h] [ebp-14h]
  char v5[4]; // [esp+418h] [ebp-10h]
  unsigned __int16 v6; // [esp+41Eh] [ebp-Ah]

  v6 = sub_80843C0(0);
  if ( v6 == word_87A22A2 )
  {
    *(_DWORD *)v5 = -2;
  }
  else if ( v6 == word_87A22A4 )
  {
    *(_DWORD *)v5 = -1;
  }
  else
  {
    if ( v6 != word_87A2314 )
    {
      v0 = sub_8078896(v6);
      v1 = va("Illegal team string '%s'. Must be allies, axis, or none.", v0);
      sub_8084E14(0, (int)v1);
      return;
    }
    *(_DWORD *)v5 = 0;
  }
  sub_809107E(22, &s1, 1024);
  v4 = (int)va("%i", *(_DWORD *)v5);
  v2 = sub_80B5B30(&s1, (int)"winner");
  if ( I_stricmp(v2, (char *)v4) )
  {
    sub_80B5FF6(&s1, "winner", v4);
    sub_8090E6C(22, &s1);
  }
}
// 87A22A2: using guessed type __int16 word_87A22A2;
// 87A22A4: using guessed type __int16 word_87A22A4;
// 87A2314: using guessed type __int16 word_87A2314;

//----- (081137DA) --------------------------------------------------------
int sub_81137DA()
{
  int v0; // eax
  char *v1; // eax
  char v3; // [esp+20h] [ebp-408h]

  v0 = sub_8084AEE();
  sub_810E290(0, v0 - 1, (int)"Announcement", (int)&v3, 1024);
  v1 = va("%c \"%s\" 2", 99, &v3);
  return sub_808FE96(-1, 0, (int)v1);
}

//----- (0811384E) --------------------------------------------------------
int sub_811384E()
{
  int v0; // eax
  char *v1; // eax
  char v3; // [esp+20h] [ebp-418h]
  int *v4; // [esp+42Ch] [ebp-Ch]

  v4 = (int *)sub_8118CDE(0);
  v0 = sub_8084AEE();
  sub_810E290(1, v0 - 1, (int)"Announcement", (int)&v3, 1024);
  v1 = va("%c \"%s\" 2", 99, &v3);
  return sub_808FE96(*v4, 0, (int)v1);
}

//----- (081138D2) --------------------------------------------------------
int sub_81138D2()
{
  int v0; // eax
  char *v1; // eax
  int result; // eax
  unsigned __int16 v3; // [esp+16h] [ebp-2h]

  v3 = sub_80843C0(0);
  if ( v3 != word_87A22A2 && v3 != word_87A22A4 )
  {
    v0 = sub_8078896(v3);
    v1 = va("Illegal team string '%s'. Must be allies, or axis.", v0);
    sub_8084DB4((int)v1);
  }
  if ( v3 == word_87A22A2 )
    result = Scr_AddInt(*(int *)dword_859B604);
  else
    result = Scr_AddInt(*(int *)dword_859B600);
  return result;
}
// 87A22A2: using guessed type __int16 word_87A22A2;
// 87A22A4: using guessed type __int16 word_87A22A4;

//----- (08113952) --------------------------------------------------------
int sub_8113952()
{
  int v0; // eax
  char *v1; // eax
  char *v2; // eax
  int result; // eax
  int v4; // [esp+10h] [ebp-8h]
  unsigned __int16 v5; // [esp+16h] [ebp-2h]

  v5 = sub_80843C0(0);
  if ( v5 != word_87A22A2 && v5 != word_87A22A4 )
  {
    v0 = sub_8078896(v5);
    v1 = va("Illegal team string '%s'. Must be allies, or axis.", v0);
    sub_8084DB4((int)v1);
  }
  v4 = sub_808404C(1u);
  if ( v5 == word_87A22A2 )
  {
    *(_DWORD *)dword_859B604 = v4;
    v2 = va("%c %i", 72, v4);
  }
  else
  {
    *(_DWORD *)dword_859B600 = v4;
    v2 = va("%c %i", 71, v4);
  }
  result = sub_808FE96(-1, 0, (int)v2);
  dword_859B610 = 1;
  return result;
}
// 859B610: using guessed type int dword_859B610;
// 87A22A2: using guessed type __int16 word_87A22A2;
// 87A22A4: using guessed type __int16 word_87A22A4;

//----- (08113A4A) --------------------------------------------------------
void sub_8113A4A()
{
  __int16 v0; // [esp+6h] [ebp-2h]

  v0 = sub_80843C0(0);
  if ( v0 == word_87A2318 )
  {
    dword_859B614 = 0;
  }
  else if ( v0 == word_87A231A )
  {
    dword_859B614 = 1;
  }
  else
  {
    sub_8084DB4((int)"Unknown mode");
  }
}
// 859B614: using guessed type int dword_859B614;
// 87A2318: using guessed type __int16 word_87A2318;
// 87A231A: using guessed type __int16 word_87A231A;

//----- (08113AA0) --------------------------------------------------------
int sub_8113AA0()
{
  int result; // eax
  int v1; // [esp+1Ch] [ebp-3Ch]
  char dest; // [esp+20h] [ebp-38h]
  int i; // [esp+4Ch] [ebp-Ch]

  if ( !dword_859B614 )
    sub_8084DB4((int)"Only works in [manual_change] mode");
  v1 = 0;
  for ( i = dword_859B400; ; i += 10404 )
  {
    result = v1;
    if ( v1 >= dword_859B5E4 )
      break;
    if ( *(_DWORD *)(i + 9924) == 2 )
    {
      if ( strcmp((const char *)(i + 10116), (const char *)(i + 9992)) )
      {
        I_strncpyz(&dest, (char *)(i + 10116), 32);
        I_strncpyz((char *)(i + 10116), (char *)(i + 9992), 32);
        sub_80F6506(v1);
      }
    }
    ++v1;
  }
  return result;
}
// 859B400: using guessed type int dword_859B400;
// 859B5E4: using guessed type int dword_859B5E4;
// 859B614: using guessed type int dword_859B614;

//----- (08113B6E) --------------------------------------------------------
int sub_8113B6E()
{
  int v0; // eax
  char *v1; // eax
  char *v3; // [esp+14h] [ebp-14h]
  int i; // [esp+18h] [ebp-10h]
  signed int v5; // [esp+1Ch] [ebp-Ch]
  int v6; // [esp+20h] [ebp-8h]
  unsigned __int16 v7; // [esp+26h] [ebp-2h]

  v7 = sub_80843C0(0);
  if ( v7 != word_87A22A2 && v7 != word_87A22A4 )
  {
    v0 = sub_8078896(v7);
    v1 = va("Illegal team string '%s'. Must be allies, or axis.", v0);
    sub_8084DB4((int)v1);
  }
  if ( v7 == word_87A22A2 )
    v5 = 2;
  else
    v5 = 1;
  v6 = 0;
  for ( i = 0; i < *(_DWORD *)(dword_8793D88 + 8); ++i )
  {
    v3 = (char *)&unk_8665480 + 560 * i;
    if ( v3[252] && *(_DWORD *)(*((_DWORD *)v3 + 86) + 10060) == v5 && *((_DWORD *)v3 + 101) > 0 )
      ++v6;
  }
  return Scr_AddInt(v6);
}
// 8793D88: using guessed type int dword_8793D88;
// 87A22A2: using guessed type __int16 word_87A22A2;
// 87A22A4: using guessed type __int16 word_87A22A4;

//----- (08113C58) --------------------------------------------------------
int sub_8113C58()
{
  char *v0; // eax
  signed __int16 **v1; // eax
  int v2; // eax

  v0 = (char *)sub_808456A(0);
  v1 = (signed __int16 **)sub_8090534(v0);
  v2 = sub_80C54CE(v1);
  return Scr_AddInt(v2);
}

//----- (08113C8A) --------------------------------------------------------
int sub_8113C8A()
{
  char *v0; // eax
  char *v1; // eax
  unsigned __int16 v3; // [esp+Ah] [ebp-Eh]
  unsigned int v4; // [esp+Ch] [ebp-Ch]
  unsigned int v5; // [esp+10h] [ebp-8h]
  signed __int16 **v6; // [esp+14h] [ebp-4h]

  v0 = (char *)sub_808456A(0);
  v6 = (signed __int16 **)sub_8090534(v0);
  v5 = sub_808404C(1u);
  v4 = sub_80C54CE(v6);
  if ( v5 >= v4 )
  {
    v1 = va("index out of range (0 - %d)", v4 - 1);
    sub_8084E14(1, (int)v1);
  }
  v3 = *(_WORD *)(sub_80C3314((int)v6) + 2 * v5);
  if ( !v3 )
    sub_8084E14(0, (int)"bad model");
  return sub_8084C8E(v3);
}

//----- (08113D32) --------------------------------------------------------
float __usercall sub_8113D32@<eax>()
{
  float v0; // ST00_4
  int v1; // eax
  float result; // eax
  float v3; // [esp+1Ch] [ebp-2Ch]
  char v4; // [esp+20h] [ebp-28h]
  int v5; // [esp+34h] [ebp-14h]
  float v6; // [esp+38h] [ebp-10h]
  int v7; // [esp+3Ch] [ebp-Ch]

  v6 = sub_8084320(0);
  v0 = sub_8084320(1u) * 1000.0;
  v5 = sub_8116158(v0);
  sub_80846F8(2u, &v4);
  v3 = sub_8084320(3u);
  if ( v6 <= 0.0 )
    sub_8084E14(0, (int)"Scale must be greater than 0");
  if ( v5 <= 0 )
    sub_8084E14(1, (int)"duration must be greater than 0");
  if ( v3 <= 0.0 )
    sub_8084E14(3, (int)"Radius must be greater than 0");
  v1 = sub_811CB34(&v4, 196);
  v7 = v1;
  *(float *)(v1 + 104) = v6;
  *(_DWORD *)(v7 + 84) = v5;
  result = v3;
  *(float *)(v7 + 108) = v3;
  return result;
}

//----- (08113E1A) --------------------------------------------------------
void __cdecl sub_8113E1A(int a1)
{
  float v1; // ST00_4
  char *v2; // eax
  char *v3; // eax
  char s1; // [esp+10h] [ebp-418h]
  char *s2; // [esp+410h] [ebp-18h]
  int v6; // [esp+414h] [ebp-14h]
  int i; // [esp+418h] [ebp-10h]
  int v8; // [esp+41Ch] [ebp-Ch]

  v8 = sub_810E074(a1);
  if ( sub_8084AEE() != 2 )
    sub_8084DB4((int)"USAGE: <player> shellshock(<shellshockname>, <duration>)\n");
  s2 = (char *)sub_808456A(0);
  for ( i = 1; ; ++i )
  {
    if ( i > 15 )
    {
      v3 = va("shellshock '%s' was not precached\n", s2);
      sub_8084DB4((int)v3);
      return;
    }
    sub_809107E(i + 1166, &s1, 1024);
    if ( !strcasecmp(&s1, s2) )
      break;
  }
  v1 = sub_8084320(1u) * 1000.0;
  v6 = sub_8116158(v1);
  if ( v6 < 0 || v6 > 60000 )
  {
    v2 = va("duration %g should be >= 0 and <= 60", (double)((long double)v6 * 0.001));
    sub_8084E14(1, (int)v2);
  }
  *(_DWORD *)(*(_DWORD *)(v8 + 344) + 1496) = i;
  *(_DWORD *)(*(_DWORD *)(v8 + 344) + 1500) = dword_859B5EC;
  *(_DWORD *)(*(_DWORD *)(v8 + 344) + 1504) = v6;
  if ( *(_DWORD *)(v8 + 404) > 0 )
  {
    dword_855A4E0 = &unk_859EA40;
    sub_80D6FCA(*(_DWORD **)(v8 + 344), 18, 0, 1);
  }
}

//----- (08113FA2) --------------------------------------------------------
int __cdecl sub_8113FA2(int a1)
{
  int result; // eax
  int v2; // [esp+4h] [ebp-4h]

  v2 = sub_810E074(a1);
  if ( sub_8084AEE() )
    sub_8084DB4((int)"USAGE: <player> stopshellshock()\n");
  *(_DWORD *)(*(_DWORD *)(v2 + 344) + 1496) = 0;
  *(_DWORD *)(*(_DWORD *)(v2 + 344) + 1500) = 0;
  result = *(_DWORD *)(v2 + 344);
  *(_DWORD *)(result + 1504) = 0;
  return result;
}

//----- (08114006) --------------------------------------------------------
int __cdecl sub_8114006(int a1)
{
  int v1; // ebx
  long double v2; // fst7
  char *v3; // eax
  float v5[7]; // [esp+10h] [ebp-28h]
  int v6; // [esp+2Ch] [ebp-Ch]

  v6 = sub_810E074(a1);
  if ( sub_8084AEE() != 2 )
    sub_8084DB4((int)"USAGE: <player> viewkick <force 0-127> <source position>\n");
  v1 = *(_DWORD *)(v6 + 344);
  *(_DWORD *)(v1 + 10208) = (*(_DWORD *)(v6 + 408) * sub_808404C(0) + 50) / 100;
  if ( *(_DWORD *)(*(_DWORD *)(v6 + 344) + 10208) < 0 )
  {
    v2 = sub_8084320(0);
    v3 = va("viewkick: damage %g < 0\n", (double)v2);
    sub_8084DB4((int)v3);
  }
  sub_80846F8(1u, v5);
  return sub_811627E((float *)(*(_DWORD *)(v6 + 344) + 20), v5, (float *)(*(_DWORD *)(v6 + 344) + 10212));
}

//----- (081140EC) --------------------------------------------------------
_DWORD *__cdecl sub_81140EC(int a1)
{
  char v2; // [esp+10h] [ebp-68h]
  float v3[4]; // [esp+40h] [ebp-38h]
  float v4[7]; // [esp+50h] [ebp-28h]
  int v5; // [esp+6Ch] [ebp-Ch]

  v5 = sub_810E03A(a1);
  sub_80846F8(0, v4);
  sub_80A7146((float *)(v5 + 324), (int)&v2);
  sub_80A4E52(v4, (float *)&v2, v3);
  sub_811623A(v3, (float *)(v5 + 312), v3);
  return Scr_AddVector(v3);
}

//----- (0811416E) --------------------------------------------------------
void __cdecl sub_811416E(int a1)
{
  float v1; // ST08_4
  int v2; // [esp+Ch] [ebp-Ch]

  v2 = *(_DWORD *)(sub_810E03A(a1) + 348);
  if ( !v2 )
    sub_8084DB4((int)"entity is not a turret");
  v1 = sub_8084320(0);
  *(_DWORD *)(v2 + 16) = LODWORD(v1) ^ 0x80000000;
  if ( *(float *)(v2 + 16) > 0.0 )
    *(_DWORD *)(v2 + 16) = 0;
}

//----- (081141E2) --------------------------------------------------------
void __cdecl sub_81141E2(int a1)
{
  int v1; // [esp+Ch] [ebp-Ch]

  v1 = *(_DWORD *)(sub_810E03A(a1) + 348);
  if ( !v1 )
    sub_8084DB4((int)"entity is not a turret");
  *(float *)(v1 + 24) = sub_8084320(0);
  if ( *(float *)(v1 + 24) < 0.0 )
    *(_DWORD *)(v1 + 24) = 0;
}

//----- (0811424A) --------------------------------------------------------
void __cdecl sub_811424A(int a1)
{
  float v1; // ST08_4
  int v2; // [esp+Ch] [ebp-Ch]

  v2 = *(_DWORD *)(sub_810E03A(a1) + 348);
  if ( !v2 )
    sub_8084DB4((int)"entity is not a turret");
  v1 = sub_8084320(0);
  *(_DWORD *)(v2 + 12) = LODWORD(v1) ^ 0x80000000;
  if ( *(float *)(v2 + 12) > 0.0 )
    *(_DWORD *)(v2 + 12) = 0;
}

//----- (081142BE) --------------------------------------------------------
void __cdecl sub_81142BE(int a1)
{
  int v1; // [esp+Ch] [ebp-Ch]

  v1 = *(_DWORD *)(sub_810E03A(a1) + 348);
  if ( !v1 )
    sub_8084DB4((int)"entity is not a turret");
  *(float *)(v1 + 20) = sub_8084320(0);
  if ( *(float *)(v1 + 20) < 0.0 )
    *(_DWORD *)(v1 + 20) = 0;
}

//----- (08114326) --------------------------------------------------------
int __cdecl sub_8114326(int a1)
{
  int v2; // [esp+30h] [ebp-68h]
  float v3; // [esp+38h] [ebp-60h]
  int v4; // [esp+40h] [ebp-58h]
  float s; // [esp+50h] [ebp-48h]
  unsigned __int16 v6; // [esp+6Ch] [ebp-2Ch]
  char v7; // [esp+72h] [ebp-26h]
  int *v8; // [esp+8Ch] [ebp-Ch]

  v8 = (int *)sub_810E03A(a1);
  sub_811620A(v8 + 78, &v4);
  sub_811620A(v8 + 78, &v2);
  v3 = v3 + 128.0;
  sub_8108090(&s, (int)&v4, (int)&unk_8167700, (int)&unk_816770C, (int)&v2, *v8, 42008593);
  sub_80DEB7A((int)&v4, (int)&v2, s, (int)&v4);
  sub_811620A(&v4, &v2);
  v3 = v3 - 262144.0;
  sub_8108090(&s, (int)&v4, (int)&unk_8167700, (int)&unk_816770C, (int)&v2, *v8, 42008593);
  v8[31] = v6;
  sub_80DEB7A((int)&v4, (int)&v2, s, (int)&v4);
  sub_8108090(&s, (int)&v4, (int)&unk_8167700, (int)&unk_816770C, (int)&v4, *v8, 42008593);
  if ( v7 )
    Com_Printf(
      "WARNING: Spawn point entity %i is in solid at (%i, %i, %i)\n",
      *v8,
      (signed int)*((float *)v8 + 78),
      (signed int)*((float *)v8 + 79),
      (signed int)*((float *)v8 + 80));
  return sub_811CF36(v8, &v4);
}

//----- (0811451A) --------------------------------------------------------
int __cdecl sub_811451A(int a1)
{
  int v1; // ST14_4
  char *v2; // eax
  char *v3; // eax

  v1 = sub_810E03A(a1);
  v2 = va("%c %i", 72, *(_DWORD *)dword_859B604);
  sub_808FE96(-1963413621 * ((v1 - (signed int)&unk_8665480) >> 4), 0, (int)v2);
  v3 = va("%c %i", 71, *(_DWORD *)dword_859B600);
  return sub_808FE96(-1963413621 * ((v1 - (signed int)&unk_8665480) >> 4), 0, (int)v3);
}

//----- (081145B4) --------------------------------------------------------
void __usercall sub_81145B4(long double a1@<st0>)
{
  if ( dword_859E9F0 )
  {
    if ( dword_859E9F0 == 1 )
      sub_8084DB4((int)"map_restart already called");
    else
      sub_8084DB4((int)"exitlevel already called");
  }
  dword_859E9F0 = 1;
  dword_859D154 = 0;
  if ( sub_8084AEE() )
    dword_859D154 = sub_808404C(0);
  Cbuf_ExecuteText(a1, 2, "fast_restart\n");
}
// 859D154: using guessed type int dword_859D154;
// 859E9F0: using guessed type int dword_859E9F0;

//----- (0811462C) --------------------------------------------------------
void __usercall sub_811462C(long double a1@<st0>)
{
  char *v1; // eax
  char *s; // [esp+14h] [ebp-4h]

  if ( sub_8084AEE() )
  {
    s = (char *)sub_808456A(0);
    if ( sub_80909EE(s) )
    {
      if ( dword_859E9F0 )
      {
        if ( dword_859E9F0 == 2 )
          sub_8084DB4((int)"map already called");
        else
          sub_8084DB4((int)"exitlevel already called");
      }
      dword_859E9F0 = 2;
      dword_859D154 = 0;
      if ( (unsigned int)sub_8084AEE() > 1 )
        dword_859D154 = sub_808404C(1u);
      v1 = va("map %s\n", s);
      Cbuf_ExecuteText(a1, 2, v1);
    }
  }
}
// 859D154: using guessed type int dword_859D154;
// 859E9F0: using guessed type int dword_859E9F0;

//----- (081146E2) --------------------------------------------------------
void __usercall sub_81146E2(long double a1@<st0>)
{
  if ( dword_859E9F0 )
  {
    if ( dword_859E9F0 == 1 )
      sub_8084DB4((int)"map_restart already called");
    else
      sub_8084DB4((int)"exitlevel already called");
  }
  dword_859E9F0 = 3;
  dword_859D154 = 0;
  if ( sub_8084AEE() )
    dword_859D154 = sub_808404C(0);
  sub_809544E();
  sub_8107428(a1);
}
// 859D154: using guessed type int dword_859D154;
// 859E9F0: using guessed type int dword_859E9F0;

//----- (08114750) --------------------------------------------------------
int *__usercall sub_8114750@<eax>(long double a1@<st0>)
{
  int *result; // eax

  result = (int *)sub_808FAC6(a1);
  if ( result )
    result = (int *)Scr_AddEntity(result);
  return result;
}

//----- (08114772) --------------------------------------------------------
char *__usercall sub_8114772@<eax>(long double a1@<st0>)
{
  int v2; // eax
  size_t v3; // eax
  char v4; // al
  int v5; // [esp+24h] [ebp-824h]
  char *s; // [esp+28h] [ebp-820h]
  char *src; // [esp+2Ch] [ebp-81Ch]
  char v8; // [esp+30h] [ebp-818h]
  char v9; // [esp+430h] [ebp-418h]
  char *v10; // [esp+830h] [ebp-18h]
  int v11; // [esp+834h] [ebp-14h]
  size_t v12; // [esp+838h] [ebp-10h]
  unsigned int v13; // [esp+83Ch] [ebp-Ch]

  src = (char *)sub_808456A(0);
  v5 = Dvar_FindVar(src);
  if ( v5 )
    return (char *)sub_80B2B42(v5, 256);
  v11 = sub_80849A8(1u);
  if ( v11 == 3 )
  {
    v2 = sub_8084AEE();
    sub_810E290(1, v2 - 1, (int)"Dvar Value", (int)&v9, 1024);
    s = &v9;
    v3 = strlen(&v9);
  }
  else
  {
    s = (char *)sub_808456A(1u);
    v3 = strlen(s);
  }
  v12 = v3;
  v10 = &v8;
  v13 = 0;
  while ( v13 <= 0x3FE && s[v13] )
  {
    v4 = sub_80B5904(s[v13]);
    *v10 = v4;
    if ( *v10 == 34 )
      *v10 = 39;
    ++v13;
    ++v10;
  }
  *v10 = 0;
  return Dvar_RegisterString(a1, src, (int)s, 16640);
}

//----- (081148C4) --------------------------------------------------------
int sub_81148C4()
{
  int result; // eax
  int v1; // eax
  char *v2; // eax

  result = sub_8084AEE();
  if ( result )
  {
    v1 = sub_808456A(0);
    v2 = va("%c \"%s\"", 101, v1);
    result = sub_808FE96(-1, 0, (int)v2);
  }
  return result;
}

//----- (0811491A) --------------------------------------------------------
int sub_811491A()
{
  int result; // eax
  char *s; // ST04_4

  result = sub_8084AEE();
  if ( result )
  {
    s = (char *)sub_808456A(0);
    if ( sub_80909EE(s) )
      result = Scr_AddInt(1);
    else
      result = Scr_AddInt(0);
  }
  return result;
}

//----- (08114966) --------------------------------------------------------
int sub_8114966()
{
  int result; // eax
  char *v1; // ST04_4

  result = sub_8084AEE();
  if ( result )
  {
    v1 = (char *)sub_808456A(0);
    if ( sub_8115E3C(v1) )
      result = Scr_AddInt(1);
    else
      result = Scr_AddInt(0);
  }
  return result;
}

//----- (081149B2) --------------------------------------------------------
int sub_81149B2()
{
  int result; // eax
  char *s1; // ST14_4
  char *v2; // eax
  char *v3; // eax
  char *v4; // eax

  result = sub_8084AEE();
  if ( result )
  {
    s1 = (char *)sub_808456A(0);
    sub_8090E6C(16, s1);
    v2 = va("%i", *(_DWORD *)dword_859BF1C);
    sub_8090E6C(15, v2);
    v3 = va("%i", *(_DWORD *)dword_859BF24);
    sub_8090E6C(17, v3);
    v4 = va("%i", *(_DWORD *)dword_859BF28);
    result = sub_8090E6C(18, v4);
  }
  return result;
}

//----- (08114A5A) --------------------------------------------------------
int sub_8114A5A()
{
  int result; // eax
  int v1; // eax
  char *v2; // eax
  char *v3; // eax
  char *v4; // eax

  result = sub_8084AEE();
  if ( result )
  {
    v1 = sub_808404C(0);
    v2 = va("%i", v1);
    sub_8090E6C(15, v2);
    v3 = va("%i", *(_DWORD *)dword_859BF24);
    sub_8090E6C(17, v3);
    v4 = va("%i", *(_DWORD *)dword_859BF28);
    result = sub_8090E6C(18, v4);
  }
  return result;
}

//----- (08114AEA) --------------------------------------------------------
int sub_8114AEA()
{
  int result; // eax
  int v1; // eax
  char *v2; // eax
  char *v3; // eax

  result = sub_8084AEE();
  if ( result )
  {
    v1 = sub_808404C(0);
    v2 = va("%i", v1);
    sub_8090E6C(17, v2);
    v3 = va("%i", *(_DWORD *)dword_859BF28);
    result = sub_8090E6C(18, v3);
  }
  return result;
}

//----- (08114B54) --------------------------------------------------------
int sub_8114B54()
{
  int result; // eax
  int v1; // eax
  char *v2; // eax

  result = sub_8084AEE();
  if ( result )
  {
    v1 = sub_808404C(0);
    v2 = va("%i", v1);
    result = sub_8090E6C(18, v2);
  }
  return result;
}

//----- (08114B9A) --------------------------------------------------------
void __usercall sub_8114B9A(long double a1@<st0>)
{
  int v1; // eax
  char *v2; // eax

  if ( sub_8084AEE() )
  {
    v1 = sub_808404C(0);
    v2 = va("tempBanClient %i\n", v1);
    Cbuf_ExecuteText(a1, 2, v2);
  }
}

//----- (08114BE0) --------------------------------------------------------
void __usercall sub_8114BE0(long double a1@<st0>)
{
  int v1; // eax
  char *v2; // eax

  if ( sub_8084AEE() )
  {
    v1 = sub_808404C(0);
    v2 = va("banClient %i\n", v1);
    Cbuf_ExecuteText(a1, 2, v2);
  }
}

//----- (08114C26) --------------------------------------------------------
int sub_8114C26()
{
  int result; // eax
  int v1; // ST14_4
  int v2; // eax
  char *v3; // eax

  result = sub_8084AEE();
  if ( result )
  {
    v1 = sub_8118CDE(0);
    v2 = sub_808456A(1u);
    v3 = va("%c \"%s\"", 101, v2);
    result = sub_808FE96(-1963413621 * ((v1 - (signed int)&unk_8665480) >> 4), 0, (int)v3);
  }
  return result;
}

//----- (08114C98) --------------------------------------------------------
unsigned int sub_8114C98()
{
  unsigned int result; // eax
  char *v1; // eax
  int v2; // ebx
  char *v3; // eax
  char *v4; // eax
  signed int v5; // [esp+18h] [ebp-20h]
  int i; // [esp+1Ch] [ebp-1Ch]
  int v7; // [esp+20h] [ebp-18h]
  int v8; // [esp+24h] [ebp-14h]
  int v9; // [esp+28h] [ebp-10h]
  char *s1; // [esp+2Ch] [ebp-Ch]
  char *src; // [esp+30h] [ebp-8h]

  v9 = 0;
  result = sub_8084AEE();
  if ( result > 1 )
  {
    src = (char *)sub_808456A(0);
    s1 = (char *)sub_808456A(1u);
    for ( i = 0; i <= 0; ++i )
    {
      if ( dword_859EA08[i] < 0 )
      {
        v9 = 4 * i + 140110344;
        break;
      }
    }
    if ( v9 )
    {
      if ( !strcmp(s1, "read") )
      {
        v1 = va("%s/%s", "scriptdata", src);
        v5 = FS_FOpenFileByMode(v1, (int)&v8, 0);
        if ( v5 >= 0 )
        {
          v2 = i;
          *(&dword_859EA0C + v2) = Z_MallocInternal(v5 + 1);
          FS_Read((int)*(&dword_859EA0C + i), v5, v8);
          FS_FCloseFile(v8);
          *((_BYTE *)*(&dword_859EA0C + i) + v5) = 0;
          sub_80B396A(src);
          sub_80B3B00(1);
          dword_859EA10[5 * i] = 0;
          result = Scr_AddInt(i);
        }
        else
        {
          result = Scr_AddInt(-1);
        }
      }
      else if ( !strcmp(s1, "write") )
      {
        v3 = va("%s/%s", "scriptdata", src);
        v7 = FS_FOpenFileByMode(v3, v9, 1);
        if ( v7 >= 0 )
          result = Scr_AddInt(i);
        else
          result = Scr_AddInt(-1);
      }
      else if ( !strcmp(s1, "append") )
      {
        v4 = va("%s/%s", "scriptdata", src);
        v7 = FS_FOpenFileByMode(v4, v9, 2);
        if ( v7 >= 0 )
          result = Scr_AddInt(i);
        else
          result = Scr_AddInt(-1);
      }
      else
      {
        Com_Printf("Valid openfile modes are 'write', 'read', and 'append'\n");
        result = Scr_AddInt(-1);
      }
    }
    else
    {
      Com_Printf("OpenFile failed.  %i files already open\n", 1);
      result = Scr_AddInt(-1);
    }
  }
  return result;
}
// 859EA08: using guessed type int dword_859EA08[];
// 859EA10: using guessed type int dword_859EA10[];

//----- (08114F2C) --------------------------------------------------------
int sub_8114F2C()
{
  int result; // eax
  int v1; // [esp+14h] [ebp-4h]

  result = sub_8084AEE();
  if ( result )
  {
    v1 = sub_808404C(0);
    if ( v1 < 0 || v1 > 1 )
    {
      Com_Printf("CloseFile failed, invalid file number %i\n", v1);
      return Scr_AddInt(-1);
    }
    if ( dword_859EA08[v1] <= 0 )
    {
      if ( !*(&dword_859EA0C + v1) )
      {
        Com_Printf("CloseFile failed, file number %i was not open\n", v1);
        return Scr_AddInt(-1);
      }
      sub_80B3A3C();
      Z_FreeInternal(*(&dword_859EA0C + v1));
      *(&dword_859EA0C + v1) = 0;
    }
    else
    {
      FS_FCloseFile(dword_859EA08[v1]);
      dword_859EA08[v1] = -1;
    }
    result = Scr_AddInt(1);
  }
  return result;
}
// 859EA08: using guessed type int dword_859EA08[];

//----- (08115014) --------------------------------------------------------
int sub_8115014()
{
  int result; // eax
  const char *v1; // eax
  char *s; // ST0C_4
  size_t v3; // eax
  int v4; // eax
  unsigned int i; // [esp+10h] [ebp-8h]
  int v6; // [esp+14h] [ebp-4h]

  if ( (unsigned int)sub_8084AEE() > 1 )
  {
    v6 = sub_808404C(0);
    if ( v6 >= 0 && v6 <= 1 )
    {
      if ( dword_859EA08[v6] >= 0 )
      {
        for ( i = 1; i < sub_8084AEE(); ++i )
        {
          v1 = (const char *)sub_808456A(i);
          s = (char *)v1;
          v3 = strlen(v1);
          sub_809E454(s, v3, dword_859EA08[v6]);
          sub_809E454(",", 1u, dword_859EA08[v6]);
        }
        v4 = sub_8084AEE();
        result = Scr_AddInt(v4 - 1);
      }
      else
      {
        Com_Printf("FPrintln failed, file number %i was not open for writing\n", v6);
        result = Scr_AddInt(-1);
      }
    }
    else
    {
      Com_Printf("FPrintln failed, invalid file number %i\n", v6);
      result = Scr_AddInt(-1);
    }
  }
  else
  {
    Com_Printf("fprintln requires at least 2 parameters (file, output)\n");
    result = Scr_AddInt(-1);
  }
  return result;
}
// 859EA08: using guessed type int dword_859EA08[];

//----- (08115138) --------------------------------------------------------
int sub_8115138()
{
  int result; // eax
  int v1; // eax
  int v2; // eax
  int v3; // [esp+Ch] [ebp-Ch]
  _BOOL4 v4; // [esp+10h] [ebp-8h]
  char v5[4]; // [esp+14h] [ebp-4h]

  if ( sub_8084AEE() )
  {
    *(_DWORD *)v5 = sub_808404C(0);
    if ( *(_DWORD *)v5 >= 0 && *(_DWORD *)v5 <= 1 )
    {
      if ( *(&dword_859EA0C + *(_DWORD *)v5) )
      {
        v3 = (int)*(&dword_859EA0C + *(_DWORD *)v5);
        if ( dword_859EA10[5 * *(_DWORD *)v5] )
        {
          sub_80B3E58(&v3, (_DWORD *)(20 * *(_DWORD *)v5 + 140110352));
          sub_80B49B8(&v3);
          sub_80B3DEC(&v3, (_DWORD *)(20 * *(_DWORD *)v5 + 140110352));
          v4 = *Com_Parse((char **)&v3) == 0;
          sub_80B3E58(&v3, (_DWORD *)(20 * *(_DWORD *)v5 + 140110352));
          if ( v4 )
          {
            result = Scr_AddInt(-1);
          }
          else
          {
            v2 = sub_80B4A1C((char **)&v3);
            result = Scr_AddInt(v2);
          }
        }
        else
        {
          sub_80B3DEC(&v3, (_DWORD *)(20 * *(_DWORD *)v5 + 140110352));
          v1 = sub_80B4A1C((char **)&v3);
          result = Scr_AddInt(v1);
        }
      }
      else
      {
        Com_Printf("freadln failed, file number %i was not open for reading\n", *(_DWORD *)v5);
        result = Scr_AddInt(-1);
      }
    }
    else
    {
      Com_Printf("freadln failed, invalid file number %i\n", *(_DWORD *)v5);
      result = Scr_AddInt(-1);
    }
  }
  else
  {
    Com_Printf("freadln requires a parameter - the file to read from\n");
    result = Scr_AddInt(-1);
  }
  return result;
}
// 859EA10: using guessed type int dword_859EA10[];

//----- (081152F0) --------------------------------------------------------
int sub_81152F0()
{
  int result; // eax
  int v1; // [esp+14h] [ebp-14h]
  char *s; // [esp+18h] [ebp-10h]
  int i; // [esp+1Ch] [ebp-Ch]
  char v4[4]; // [esp+20h] [ebp-8h]
  char v5[4]; // [esp+24h] [ebp-4h]

  if ( (unsigned int)sub_8084AEE() > 1 )
  {
    *(_DWORD *)v5 = sub_808404C(0);
    *(_DWORD *)v4 = sub_808404C(1u);
    if ( *(_DWORD *)v5 >= 0 && *(_DWORD *)v5 <= 1 )
    {
      if ( *(_DWORD *)v4 >= 0 )
      {
        if ( *(&dword_859EA0C + *(_DWORD *)v5) )
        {
          s = 0;
          v1 = (int)*(&dword_859EA0C + *(_DWORD *)v5);
          sub_80B3E58(&v1, (_DWORD *)(20 * *(_DWORD *)v5 + 140110352));
          for ( i = 0; i <= *(_DWORD *)v4; ++i )
          {
            s = sub_80B4848((char **)&v1);
            if ( !*s )
            {
              Com_Printf(
                "freadline failed, there aren't %i arguments on this line, there are only %i arguments\n",
                *(_DWORD *)v4 + 1,
                i);
              return Scr_AddString(&byte_8153FCE);
            }
          }
          result = Scr_AddString(s);
        }
        else
        {
          Com_Printf("freadline failed, file number %i was not open for reading\n", *(_DWORD *)v5);
          result = Scr_AddString(&byte_8153FCE);
        }
      }
      else
      {
        Com_Printf("freadline failed, invalid argument number %i\n", *(_DWORD *)v4);
        result = Scr_AddString(&byte_8153FCE);
      }
    }
    else
    {
      Com_Printf("freadline failed, invalid file number %i\n", *(_DWORD *)v5);
      result = Scr_AddString(&byte_8153FCE);
    }
  }
  else
  {
    Com_Printf("freadline requires at least 2 parameters (file, string)\n");
    result = Scr_AddString(&byte_8153FCE);
  }
  return result;
}

//----- (08115462) --------------------------------------------------------
void *sub_8115462()
{
  int v0; // eax

  v0 = sub_808404C(0);
  return sub_80919F4(v0);
}

//----- (08115490) --------------------------------------------------------
int sub_8115490()
{
  return Scr_AddInt(0);
}

//----- (081154B6) --------------------------------------------------------
void __cdecl sub_81154B6(int a1)
{
  int v1; // ebx
  int v2; // eax
  char *v3; // eax
  int v4; // esi
  int v5; // ebx
  int v6; // eax
  char *v7; // eax
  __int16 v8; // [esp+1Ah] [ebp-Eh]
  int v9; // [esp+1Ch] [ebp-Ch]

  v9 = sub_810E03A(a1);
  if ( *(_WORD *)(v9 + 360) != word_87A22F6 && *(_WORD *)(v9 + 360) != word_87A22F8 )
  {
    v1 = sub_8078896((unsigned __int16)word_87A22F8);
    v2 = sub_8078896((unsigned __int16)word_87A22F6);
    v3 = va("setteamfortrigger: trigger entity must be of type %s or %s", v2, v1);
    sub_8084DB4((int)v3);
  }
  v8 = sub_80843C0(0);
  if ( v8 == word_87A22A2 )
  {
    *(_BYTE *)(v9 + 359) = 2;
  }
  else if ( v8 == word_87A22A4 )
  {
    *(_BYTE *)(v9 + 359) = 1;
  }
  else if ( v8 == word_87A2314 )
  {
    *(_BYTE *)(v9 + 359) = 0;
  }
  else
  {
    v4 = sub_8078896((unsigned __int16)word_87A2314);
    v5 = sub_8078896((unsigned __int16)word_87A22A4);
    v6 = sub_8078896((unsigned __int16)word_87A22A2);
    v7 = va("setteamfortrigger: invalid team used must be %s, %s or %s", v6, v5, v4);
    sub_8084DB4((int)v7);
  }
}
// 87A22A2: using guessed type __int16 word_87A22A2;
// 87A22A4: using guessed type __int16 word_87A22A4;
// 87A22F6: using guessed type __int16 word_87A22F6;
// 87A22F8: using guessed type __int16 word_87A22F8;
// 87A2314: using guessed type __int16 word_87A2314;

//----- (081155E4) --------------------------------------------------------
int __cdecl sub_81155E4(int a1)
{
  int v1; // ebx
  int v2; // eax
  char *v3; // eax
  int result; // eax
  int v5; // [esp+Ch] [ebp-Ch]
  int v6; // [esp+10h] [ebp-8h]

  v6 = sub_810E03A(a1);
  if ( !*(_DWORD *)(v6 + 344) )
    sub_8084DB4((int)"clientclaimtrigger: claimer must be a client.");
  v5 = sub_8118CDE(0);
  if ( *(_WORD *)(v5 + 360) != word_87A22F6 && *(_WORD *)(v5 + 360) != word_87A22F8 )
  {
    v1 = sub_8078896((unsigned __int16)word_87A22F8);
    v2 = sub_8078896((unsigned __int16)word_87A22F6);
    v3 = va("clientclaimtrigger: trigger entity must be of type %s or %s", v2, v1);
    sub_8084DB4((int)v3);
  }
  if ( *(_DWORD *)(v5 + 436) == 1023
    || (result = *(_DWORD *)(v5 + 436), result == *(_DWORD *)(*(_DWORD *)(v6 + 344) + 204)) )
  {
    result = *(_DWORD *)(*(_DWORD *)(v6 + 344) + 204);
    *(_DWORD *)(v5 + 436) = result;
  }
  return result;
}
// 87A22F6: using guessed type __int16 word_87A22F6;
// 87A22F8: using guessed type __int16 word_87A22F8;

//----- (081156CC) --------------------------------------------------------
int __cdecl sub_81156CC(int a1)
{
  int v1; // ebx
  int v2; // eax
  char *v3; // eax
  int result; // eax
  int v5; // [esp+Ch] [ebp-Ch]
  int v6; // [esp+10h] [ebp-8h]

  v6 = sub_810E03A(a1);
  if ( !*(_DWORD *)(v6 + 344) )
    sub_8084DB4((int)"clientreleasetrigger: releaser must be a client.");
  v5 = sub_8118CDE(0);
  if ( *(_WORD *)(v5 + 360) != word_87A22F6 && *(_WORD *)(v5 + 360) != word_87A22F8 )
  {
    v1 = sub_8078896((unsigned __int16)word_87A22F8);
    v2 = sub_8078896((unsigned __int16)word_87A22F6);
    v3 = va("clientreleasetrigger: trigger entity must be of type %s or %s", v2, v1);
    sub_8084DB4((int)v3);
  }
  result = *(_DWORD *)(v5 + 436);
  if ( result == *(_DWORD *)(*(_DWORD *)(v6 + 344) + 204) )
  {
    result = v5;
    *(_DWORD *)(v5 + 436) = 1023;
  }
  return result;
}
// 87A22F6: using guessed type __int16 word_87A22F6;
// 87A22F8: using guessed type __int16 word_87A22F8;

//----- (0811579A) --------------------------------------------------------
int __cdecl sub_811579A(int a1)
{
  int v1; // ebx
  int v2; // eax
  char *v3; // eax
  int result; // eax
  int v5; // [esp+10h] [ebp-8h]

  v5 = sub_810E03A(a1);
  if ( *(_WORD *)(v5 + 360) != word_87A22F6 && *(_WORD *)(v5 + 360) != word_87A22F8 )
  {
    v1 = sub_8078896((unsigned __int16)word_87A22F8);
    v2 = sub_8078896((unsigned __int16)word_87A22F6);
    v3 = va("releaseclaimedtrigger: trigger entity must be of type %s or %s", v2, v1);
    sub_8084DB4((int)v3);
  }
  result = v5;
  *(_DWORD *)(v5 + 436) = 1023;
  return result;
}
// 87A22F6: using guessed type __int16 word_87A22F6;
// 87A22F8: using guessed type __int16 word_87A22F8;

//----- (08115824) --------------------------------------------------------
int __cdecl sub_8115824(char **a1, _DWORD *a2)
{
  char *s1; // [esp+10h] [ebp-8h]
  unsigned int i; // [esp+14h] [ebp-4h]

  s1 = *a1;
  for ( i = 0; i <= 0x8F; ++i )
  {
    if ( !strcmp(s1, (&off_8167BC0)[3 * i]) )
    {
      *a1 = (&off_8167BC0)[3 * i];
      *a2 = dword_8167BC8[3 * i];
      return (int)*(&off_8167BC4 + 3 * i);
    }
  }
  return 0;
}
// 8167BC0: using guessed type char *off_8167BC0;
// 8167BC4: using guessed type int (*off_8167BC4)();
// 8167BC8: using guessed type int dword_8167BC8[];

//----- (081158C2) --------------------------------------------------------
int __cdecl sub_81158C2(char **a1, _DWORD *a2)
{
  char *s1; // [esp+10h] [ebp-8h]
  unsigned int i; // [esp+14h] [ebp-4h]

  s1 = *a1;
  for ( i = 0; i <= 0x3A; ++i )
  {
    if ( !strcmp(s1, (&off_8168280)[3 * i]) )
    {
      *a1 = (&off_8168280)[3 * i];
      *a2 = dword_8168288[3 * i];
      return (int)*(&off_8168284 + 3 * i);
    }
  }
  return 0;
}
// 8168280: using guessed type char *off_8168280;
// 8168284: using guessed type int (__cdecl *off_8168284)(int);
// 8168288: using guessed type int dword_8168288[];

//----- (0811595C) --------------------------------------------------------
int (__cdecl *__cdecl sub_811595C(char **a1, _DWORD *a2))(__int16)
{
  int (__cdecl *v3)(__int16); // [esp+10h] [ebp-8h]
  int v4; // [esp+10h] [ebp-8h]
  int (__cdecl *v5)(int); // [esp+10h] [ebp-8h]
  int (__cdecl *v6)(__int16); // [esp+14h] [ebp-4h]

  *a2 = 0;
  v6 = sub_80FB640(a1);
  v3 = sub_8117D6A(a1);
  if ( !v6 )
    v6 = v3;
  v4 = sub_81158C2(a1, a2);
  if ( !v6 )
    v6 = (int (__cdecl *)(__int16))v4;
  v5 = sub_810236E(a1);
  if ( !v6 )
    v6 = (int (__cdecl *)(__int16))v5;
  return v6;
}

//----- (081159D4) --------------------------------------------------------
int __cdecl sub_81159D4(int a1)
{
  int result; // eax
  char v2; // [esp+10h] [ebp-18h]

  sub_80846F8(0, &v2);
  sub_811CF36((_DWORD *)a1, &v2);
  result = a1;
  if ( *(_BYTE *)(a1 + 240) )
    result = sub_809A45E(a1);
  return result;
}

//----- (08115A18) --------------------------------------------------------
int __cdecl sub_8115A18(_DWORD *a1)
{
  char v2; // [esp+10h] [ebp-18h]

  sub_80846F8(0, &v2);
  return sub_811CF96(a1, &v2);
}

//----- (08115A46) --------------------------------------------------------
int __cdecl sub_8115A46(_DWORD *a1)
{
  int result; // eax
  int v2; // [esp+4h] [ebp-4h]

  v2 = sub_808404C(0);
  if ( a1[86] )
  {
    a1[101] = v2;
    result = v2;
    *(_DWORD *)(a1[86] + 300) = v2;
  }
  else
  {
    a1[102] = v2;
    result = v2;
    a1[101] = v2;
  }
  return result;
}

//----- (08115AA2) --------------------------------------------------------
_DWORD *__cdecl sub_8115AA2(_DWORD *a1)
{
  _DWORD *result; // eax

  if ( a1 )
    result = Scr_AddVector(a1);
  else
    result = (_DWORD *)Scr_AddUndefined();
  return result;
}

//----- (08115AC2) --------------------------------------------------------
int __cdecl sub_8115AC2(int *a1)
{
  int result; // eax

  if ( a1 )
    result = Scr_AddEntity(a1);
  else
    result = Scr_AddUndefined();
  return result;
}

//----- (08115AE2) --------------------------------------------------------
int sub_8115AE2()
{
  char *v0; // eax
  char *v1; // eax
  int result; // eax
  size_t v3; // [esp+28h] [ebp-1440h]
  int v4; // [esp+2Ch] [ebp-143Ch]
  char v5; // [esp+30h] [ebp-1438h]
  char s; // [esp+1030h] [ebp-438h]
  char *v7; // [esp+143Ch] [ebp-2Ch]
  char *dest; // [esp+1440h] [ebp-28h]
  char *v9; // [esp+1444h] [ebp-24h]
  char *v10; // [esp+1448h] [ebp-20h]
  int v11; // [esp+144Ch] [ebp-1Ch]
  int v12; // [esp+1450h] [ebp-18h]
  int v13; // [esp+1454h] [ebp-14h]
  int i; // [esp+1458h] [ebp-10h]
  char *src; // [esp+145Ch] [ebp-Ch]

  memset(&s, 0, 0x400u);
  v12 = 0;
  memset(&unk_879C7AC, 0, 0x1080u);
  v11 = FS_GetFileList((int)"maps/mp/gametypes", "gsc", 0, &v5, 4096);
  src = &v5;
  for ( i = 0; i < v11; ++i )
  {
    dest = (char *)(132 * v12 + 142198700);
    v3 = strlen(src);
    if ( *src == 95 )
    {
      src += v3 + 1;
    }
    else
    {
      if ( !I_stricmp(&src[v3 - 4], ".gsc") )
        src[v3 - 4] = 0;
      if ( v12 == 32 )
      {
        Com_Printf("Too many game type scripts found! Only loading the first %i\n", 31);
        break;
      }
      I_strncpyz(dest, src, 64);
      strlwr(dest);
      v7 = va("maps/mp/gametypes/%s.txt", src);
      v13 = FS_FOpenFileByMode(v7, (int)&v4, 0);
      if ( v13 > 0 && v13 <= 1023 )
      {
        FS_Read((int)&s, v13, v4);
        v10 = &s;
        v9 = Com_Parse(&v10);
        I_strncpyz(dest + 64, v9, 64);
        v9 = Com_Parse(&v10);
        *((_DWORD *)dest + 32) = v9 && !I_stricmp(v9, "team");
      }
      else
      {
        if ( v13 > 0 )
        {
          v1 = va("maps/mp/gametypes/%s.txt", src);
          Com_Printf("WARNING: GameType description file %s is too big to load.\n", v1);
        }
        else
        {
          v0 = va("maps/mp/gametypes/%s.txt", src);
          Com_Printf("WARNING: Could not load GameType description file %s for gametype %s\n", v0, src);
        }
        I_strncpyz(dest + 64, dest, 64);
        *((_DWORD *)dest + 32) = 0;
      }
      ++v12;
      if ( v13 > 0 )
        FS_FCloseFile(v4);
      src += v3 + 1;
    }
  }
  result = v12;
  dword_879C7A8 = v12;
  return result;
}
// 879C7A8: using guessed type int dword_879C7A8;

//----- (08115DD2) --------------------------------------------------------
int __cdecl sub_8115DD2(char *a1)
{
  int i; // [esp+14h] [ebp-4h]

  for ( i = 0; i < dword_879C7A8; ++i )
  {
    if ( !I_stricmp((char *)(132 * i + 142198700), a1) )
      return 132 * i + 142198764;
  }
  return 0;
}
// 879C7A8: using guessed type int dword_879C7A8;

//----- (08115E3C) --------------------------------------------------------
_BOOL4 __cdecl sub_8115E3C(char *a1)
{
  return sub_8115DD2(a1) != 0;
}

//----- (08115E66) --------------------------------------------------------
int sub_8115E66()
{
  unsigned __int16 v0; // ST16_2

  v0 = sub_808398E(dword_879C788, 0);
  return sub_8083B8E(v0);
}
// 879C788: using guessed type int dword_879C788;

//----- (08115E94) --------------------------------------------------------
int sub_8115E94()
{
  unsigned __int16 v0; // ST16_2

  v0 = sub_808398E(dword_879C78C, 0);
  return sub_8083B8E(v0);
}
// 879C78C: using guessed type int dword_879C78C;

//----- (08115EC2) --------------------------------------------------------
int __cdecl sub_8115EC2(int *a1)
{
  unsigned __int16 v1; // ST16_2

  v1 = sub_8118DF4(a1, dword_879C790, 0);
  return sub_8083B8E(v1);
}
// 879C790: using guessed type int dword_879C790;

//----- (08115EF6) --------------------------------------------------------
int __cdecl sub_8115EF6(int *a1)
{
  unsigned __int16 v1; // ST16_2

  v1 = sub_8118DF4(a1, dword_879C794, 0);
  return sub_8083B8E(v1);
}
// 879C794: using guessed type int dword_879C794;

//----- (08115F2A) --------------------------------------------------------
int __cdecl sub_8115F2A(int *a1, int *a2, int *a3, int a4, int a5, unsigned int a6, int a7, _DWORD *a8, _DWORD *a9, int a10, int a11)
{
  unsigned __int16 v11; // ax
  char **v12; // eax
  unsigned __int16 v13; // ST16_2

  Scr_AddInt(a11);
  v11 = sub_81003E6(a10);
  sub_8084C8E(v11);
  sub_8115AA2(a9);
  sub_8115AA2(a8);
  v12 = (char **)sub_80E9270(a7);
  Scr_AddString(*v12);
  if ( (a6 & 0x80000000) == 0 && a6 <= 0xE )
    Scr_AddString((&off_81677C0)[a6]);
  else
    Scr_AddString("badMOD");
  Scr_AddInt(a5);
  Scr_AddInt(a4);
  sub_8115AC2(a3);
  sub_8115AC2(a2);
  v13 = sub_8118DF4(a1, dword_879C798, 10);
  return sub_8083B8E(v13);
}
// 879C798: using guessed type int dword_879C798;

//----- (08116004) --------------------------------------------------------
int __cdecl sub_8116004(int *a1, int *a2, int *a3, int a4, unsigned int a5, int a6, _DWORD *a7, int a8, int a9, int a10)
{
  unsigned __int16 v10; // ax
  char **v11; // eax
  unsigned __int16 v12; // ST16_2

  Scr_AddInt(a10);
  Scr_AddInt(a9);
  v10 = sub_81003E6(a8);
  sub_8084C8E(v10);
  sub_8115AA2(a7);
  v11 = (char **)sub_80E9270(a6);
  Scr_AddString(*v11);
  if ( (a5 & 0x80000000) == 0 && a5 <= 0xE )
    Scr_AddString((&off_81677C0)[a5]);
  else
    Scr_AddString("badMOD");
  Scr_AddInt(a4);
  sub_8115AC2(a3);
  sub_8115AC2(a2);
  v12 = sub_8118DF4(a1, dword_879C79C, 9);
  return sub_8083B8E(v12);
}
// 879C79C: using guessed type int dword_879C79C;

//----- (081160D4) --------------------------------------------------------
int __cdecl sub_81160D4(int a1, char *a2, char *a3, char *s)
{
  Scr_AddString(s);
  Scr_AddString(a3);
  Scr_AddString(a2);
  return Scr_Notify((int *)a1, word_87A231E, 3);
}
// 87A231E: using guessed type __int16 word_87A231E;

//----- (0811611C) --------------------------------------------------------
int __cdecl sub_811611C(int a1, char *s)
{
  Scr_AddString(s);
  return Scr_Notify((int *)a1, word_87A2320, 1);
}
// 87A2320: using guessed type __int16 word_87A2320;

//----- (08116158) --------------------------------------------------------
int __cdecl sub_8116158(float a1)
{
  return (signed int)floor(a1 + 0.5);
}

//----- (0811618E) --------------------------------------------------------
void __cdecl sub_811618E(float a1, int a2, int a3)
{
  *(float *)a2 = sin(a1);
  *(float *)a3 = cos(a1);
}

//----- (081161BC) --------------------------------------------------------
int __cdecl sub_81161BC(_DWORD *a1)
{
  int result; // eax

  *a1 = 0;
  a1[1] = 0;
  result = 0;
  a1[2] = 0;
  return result;
}

//----- (081161E6) --------------------------------------------------------
int __cdecl sub_81161E6(_DWORD *a1, int a2, int a3, int a4)
{
  int result; // eax

  *a1 = a2;
  a1[1] = a3;
  result = a4;
  a1[2] = a4;
  return result;
}

//----- (0811620A) --------------------------------------------------------
int __cdecl sub_811620A(_DWORD *a1, _DWORD *a2)
{
  int result; // eax

  *a2 = *a1;
  a2[1] = a1[1];
  result = a1[2];
  a2[2] = result;
  return result;
}

//----- (0811623A) --------------------------------------------------------
int __cdecl sub_811623A(float *a1, float *a2, float *a3)
{
  int result; // eax

  *a3 = *a1 + *a2;
  a3[1] = a1[1] + a2[1];
  result = (int)(a1 + 2);
  a3[2] = a1[2] + a2[2];
  return result;
}

//----- (0811627E) --------------------------------------------------------
int __cdecl sub_811627E(float *a1, float *a2, float *a3)
{
  int result; // eax

  *a3 = *a1 - *a2;
  a3[1] = a1[1] - a2[1];
  result = (int)(a1 + 2);
  a3[2] = a1[2] - a2[2];
  return result;
}

//----- (081162C2) --------------------------------------------------------
int __cdecl sub_81162C2(int a1, float a2, int a3)
{
  int result; // eax

  *(float *)a3 = a2 * *(float *)a1;
  *(float *)(a3 + 4) = a2 * *(float *)(a1 + 4);
  result = a1 + 8;
  *(float *)(a3 + 8) = a2 * *(float *)(a1 + 8);
  return result;
}

//----- (081162FA) --------------------------------------------------------
long double __cdecl sub_81162FA(float *a1, float *a2)
{
  return *a1 * *a2 + a1[1] * a2[1] + a1[2] * a2[2];
}

//----- (0811632E) --------------------------------------------------------
long double __cdecl sub_811632E(float *a1)
{
  return *a1 * *a1 + a1[1] * a1[1] + a1[2] * a1[2];
}

//----- (08116362) --------------------------------------------------------
void __cdecl sub_8116362(float *a1)
{
  float v1; // ST00_4

  v1 = *a1 * *a1 + a1[1] * a1[1] + a1[2] * a1[2];
  sub_81163A0(v1);
}

//----- (081163A0) --------------------------------------------------------
long double __cdecl sub_81163A0(float a1)
{
  return (float)sqrt(a1);
}

//----- (081163C0) --------------------------------------------------------
int __cdecl sub_81163C0(int a1, int a2, float a3, float a4, float a5, int a6, int a7, int a8)
{
  signed int v10; // [esp+1Ch] [ebp-2Ch]
  int v11; // [esp+20h] [ebp-28h]
  float v12; // [esp+3Ch] [ebp-Ch]

  v10 = (signed int)(a4 * 1000.0);
  if ( *(_DWORD *)a1 == 7 && v10 > 0 )
  {
    *(_DWORD *)(a1 + 4) = dword_859B5EC;
    *(_DWORD *)(a1 + 8) = v10;
    sub_8117DEE((_DWORD *)a6, (_DWORD *)(a1 + 12));
    sub_8117E1E((float *)a7, (float *)a6, (float *)&v11);
    v12 = 1000.0 / (long double)v10;
    sub_8117E62((int)&v11, v12, a1 + 24);
    *(_DWORD *)a1 = 3;
    return 0;
  }
  if ( (*(_DWORD *)a1 == 7 && v10 <= 0 || *(_DWORD *)a1 == 3) && a5 > 0.0 )
  {
    *(_DWORD *)(a1 + 4) = dword_859B5EC;
    *(_DWORD *)(a1 + 8) = (signed int)(a5 * 1000.0);
    sub_8117DEE((_DWORD *)a7, (_DWORD *)(a1 + 12));
    sub_8117E1E((float *)a8, (float *)a7, (float *)&v11);
    sub_80A20C0((float *)&v11);
    sub_8117E62((int)&v11, a3, (int)&v11);
    sub_8117DEE(&v11, (_DWORD *)(a1 + 24));
    *(_DWORD *)a1 = 8;
    return 0;
  }
  if ( *(_DWORD *)a1 == 5 )
    sub_80DCEB0(a1, dword_859B5EC, a1 + 12);
  else
    sub_8117DEE((_DWORD *)a8, (_DWORD *)(a1 + 12));
  *(_DWORD *)(a1 + 4) = dword_859B5EC;
  *(_DWORD *)a1 = 0;
  return 1;
}

//----- (081165A0) --------------------------------------------------------
int __cdecl sub_81165A0(int a1)
{
  int v1; // ST20_4
  int result; // eax
  int v3; // ST20_4

  if ( *(_DWORD *)(a1 + 12) )
  {
    if ( *(_DWORD *)(a1 + 16) + *(_DWORD *)(a1 + 20) <= dword_859B5EC )
    {
      v1 = sub_81163C0(
             a1 + 12,
             a1 + 312,
             *(float *)(a1 + 432),
             *(float *)(a1 + 440),
             *(float *)(a1 + 424),
             a1 + 448,
             a1 + 460,
             a1 + 472);
      sub_80DCEB0(a1 + 12, dword_859B5EC, a1 + 312);
      sub_809A45E(a1);
      if ( v1 )
        Scr_Notify((int *)a1, word_87A22C8, 0);
    }
  }
  result = a1;
  if ( *(_DWORD *)(a1 + 48) )
  {
    result = *(_DWORD *)(a1 + 52) + *(_DWORD *)(a1 + 56);
    if ( result <= dword_859B5EC )
    {
      v3 = sub_81163C0(
             a1 + 48,
             a1 + 324,
             *(float *)(a1 + 436),
             *(float *)(a1 + 444),
             *(float *)(a1 + 428),
             a1 + 484,
             a1 + 496,
             a1 + 508);
      sub_80DCEB0(a1 + 48, dword_859B5EC, a1 + 324);
      result = sub_809A45E(a1);
      if ( v3 )
      {
        *(float *)(a1 + 324) = sub_80A6112(*(float *)(a1 + 324));
        *(float *)(a1 + 328) = sub_80A60CE(*(float *)(a1 + 328));
        *(float *)(a1 + 332) = sub_80A6112(*(float *)(a1 + 332));
        result = Scr_Notify((int *)a1, word_87A22E0, 0);
      }
    }
  }
  return result;
}
// 87A22C8: using guessed type __int16 word_87A22C8;
// 87A22E0: using guessed type __int16 word_87A22E0;

//----- (081167BA) --------------------------------------------------------
int __cdecl sub_81167BA(int a1, int a2, float a3, float a4, float a5, int a6, int a7, int a8, int a9, int a10, int a11, int a12)
{
  int result; // eax
  int v13; // [esp+20h] [ebp-38h]
  int v14; // [esp+30h] [ebp-28h]
  float v15; // [esp+48h] [ebp-10h]
  float v16; // [esp+4Ch] [ebp-Ch]

  sub_8117E1E((float *)a2, (float *)a6, (float *)&v14);
  if ( *(_DWORD *)a1 )
    sub_80DCEB0(a1, dword_859B5EC, a6);
  if ( a4 != 0.0 || a5 != 0.0 )
  {
    *(float *)a8 = a3 - a4 - a5;
    *(float *)a9 = a5;
    v16 = sub_8117EEE(&v14);
    *(float *)a7 = (v16 + v16) / (a3 + a3 - a4 - a5);
    sub_80A2298((float *)&v14, (int)&v13);
    sub_8117E62((int)&v13, *(float *)a7, (int)&v13);
    if ( a4 == 0.0 )
    {
      sub_8117DEE((_DWORD *)a6, (_DWORD *)a10);
      if ( *(float *)a8 == 0.0 )
      {
        *(_DWORD *)(a1 + 4) = dword_859B5EC;
        *(_DWORD *)(a1 + 8) = (signed int)(*(float *)a9 * 1000.0);
        sub_8117DEE((_DWORD *)a6, (_DWORD *)(a1 + 12));
        sub_8117DEE(&v13, (_DWORD *)(a1 + 24));
        *(_DWORD *)a1 = 8;
      }
      else
      {
        *(_DWORD *)(a1 + 4) = dword_859B5EC;
        *(_DWORD *)(a1 + 8) = (signed int)(*(float *)a8 * 1000.0);
        sub_8117DEE((_DWORD *)a6, (_DWORD *)(a1 + 12));
        sub_8117E62((int)&v13, *(float *)a8, (int)&v14);
        v15 = 1000.0 / (long double)*(signed int *)(a1 + 8);
        sub_8117E62((int)&v14, v15, a1 + 24);
        *(_DWORD *)a1 = 3;
      }
    }
    else
    {
      *(_DWORD *)(a1 + 4) = dword_859B5EC;
      *(_DWORD *)(a1 + 8) = (signed int)(a4 * 1000.0);
      sub_8117DEE((_DWORD *)a6, (_DWORD *)(a1 + 12));
      sub_8117DEE(&v13, (_DWORD *)(a1 + 24));
      *(_DWORD *)a1 = 7;
      sub_80DCEB0(a1, dword_859B5EC + *(_DWORD *)(a1 + 8), a10);
    }
    sub_8117E9A(a10, *(float *)a8, (int)&v13, a11);
    sub_8117DEE((_DWORD *)a2, (_DWORD *)a12);
    result = sub_80DCEB0(a1, dword_859B5EC, a6);
  }
  else
  {
    *(_DWORD *)(a1 + 4) = dword_859B5EC;
    *(_DWORD *)(a1 + 8) = (signed int)(a3 * 1000.0);
    *(float *)a8 = a3;
    *(_DWORD *)a9 = 0;
    sub_8117DEE((_DWORD *)a2, (_DWORD *)a12);
    sub_8117DEE((_DWORD *)a6, (_DWORD *)(a1 + 12));
    v15 = 1000.0 / (long double)*(signed int *)(a1 + 8);
    sub_8117E62((int)&v14, v15, a1 + 24);
    *(_DWORD *)a1 = 3;
    result = sub_80DCEB0(a1, dword_859B5EC, a6);
  }
  return result;
}
// 8117EEE: using guessed type double __cdecl sub_8117EEE(_DWORD);

//----- (08116B6E) --------------------------------------------------------
int __cdecl sub_8116B6E(int a1, int a2, float a3, float a4, float a5, int a6, int a7, int a8, int a9, int a10, int a11, int a12)
{
  int result; // eax
  int v13; // [esp+20h] [ebp-38h]
  int v14; // [esp+24h] [ebp-34h]
  int v15; // [esp+28h] [ebp-30h]
  int v16; // [esp+2Ch] [ebp-2Ch]
  int v17; // [esp+38h] [ebp-20h]

  if ( *(_DWORD *)a1 )
    sub_80DCEB0(a1, dword_859B5EC, a6);
  if ( a4 != 0.0 || a5 != 0.0 )
  {
    *(float *)a8 = a3 - a4 - a5;
    *(float *)a9 = a5;
    *(float *)a7 = sub_8117EEE(a2);
    if ( a4 == 0.0 )
    {
      sub_8117DEE((_DWORD *)a6, (_DWORD *)a10);
      if ( *(float *)a8 == 0.0 )
      {
        *(_DWORD *)(a1 + 4) = dword_859B5EC;
        *(_DWORD *)(a1 + 8) = (signed int)(*(float *)a9 * 1000.0);
        sub_8117DEE((_DWORD *)a6, (_DWORD *)(a1 + 12));
        sub_8117DEE((_DWORD *)a2, (_DWORD *)(a1 + 24));
        *(_DWORD *)a1 = 8;
      }
      else
      {
        *(_DWORD *)(a1 + 4) = dword_859B5EC;
        *(_DWORD *)(a1 + 8) = (signed int)(*(float *)a8 * 1000.0);
        sub_8117DEE((_DWORD *)a6, (_DWORD *)(a1 + 12));
        sub_8117DEE((_DWORD *)a2, (_DWORD *)(a1 + 24));
        *(_DWORD *)a1 = 3;
      }
    }
    else
    {
      *(_DWORD *)(a1 + 4) = dword_859B5EC;
      *(_DWORD *)(a1 + 8) = (signed int)(a4 * 1000.0);
      sub_8117DEE((_DWORD *)a6, (_DWORD *)(a1 + 12));
      sub_8117DEE((_DWORD *)a2, (_DWORD *)(a1 + 24));
      *(_DWORD *)a1 = 7;
      sub_80DCEB0(a1, dword_859B5EC + *(_DWORD *)(a1 + 8), a10);
    }
    sub_8117E9A(a10, *(float *)a8, a2, a11);
    if ( *(float *)a9 == 0.0 )
    {
      sub_8117DEE((_DWORD *)a11, (_DWORD *)a12);
    }
    else
    {
      v13 = 8;
      v14 = dword_859B5EC;
      v15 = (signed int)(*(float *)a9 * 1000.0);
      sub_8117DEE((_DWORD *)a11, &v16);
      sub_8117DEE((_DWORD *)a2, &v17);
      sub_80DCEB0((int)&v13, dword_859B5EC + v15, a12);
    }
    result = sub_80DCEB0(a1, dword_859B5EC, a6);
  }
  else
  {
    *(_DWORD *)(a1 + 4) = dword_859B5EC;
    *(_DWORD *)(a1 + 8) = (signed int)(a3 * 1000.0);
    *(float *)a8 = a3;
    *(_DWORD *)a9 = 0;
    sub_8117DEE((_DWORD *)a6, (_DWORD *)(a1 + 12));
    sub_8117DEE((_DWORD *)a2, (_DWORD *)(a1 + 24));
    *(_DWORD *)a1 = 3;
    sub_80DCEB0(a1, dword_859B5EC, a6);
    result = sub_80DCEB0(a1, dword_859B5EC + *(_DWORD *)(a1 + 8), a12);
  }
  return result;
}
// 8117EEE: using guessed type double __cdecl sub_8117EEE(_DWORD);

//----- (08116F18) --------------------------------------------------------
int __cdecl sub_8116F18(int a1, int a2, float a3, float a4, float a5)
{
  sub_81167BA(a1 + 12, a2, a3, a4, a5, a1 + 312, a1 + 432, a1 + 440, a1 + 424, a1 + 448, a1 + 460, a1 + 472);
  return sub_809A45E(a1);
}

//----- (08116FAA) --------------------------------------------------------
int __cdecl sub_8116FAA(int a1, int a2, float a3)
{
  *(_DWORD *)(a1 + 16) = dword_859B5EC;
  *(_DWORD *)(a1 + 20) = (signed int)(a3 * 1000.0);
  sub_8117DEE((_DWORD *)(a1 + 312), (_DWORD *)(a1 + 24));
  sub_8117DEE((_DWORD *)a2, (_DWORD *)(a1 + 36));
  *(_DWORD *)(a1 + 12) = 5;
  sub_80DCEB0(a1 + 12, dword_859B5EC, a1 + 312);
  return sub_809A45E(a1);
}

//----- (08117050) --------------------------------------------------------
int __cdecl sub_8117050(int a1, int a2, float a3, float a4, float a5)
{
  sub_81167BA(a1 + 48, a2, a3, a4, a5, a1 + 324, a1 + 436, a1 + 444, a1 + 428, a1 + 484, a1 + 496, a1 + 508);
  return sub_809A45E(a1);
}

//----- (081170E2) --------------------------------------------------------
int __cdecl sub_81170E2(int a1, int a2, float a3, float a4, float a5)
{
  sub_8116B6E(a1 + 48, a2, a3, a4, a5, a1 + 324, a1 + 436, a1 + 444, a1 + 428, a1 + 484, a1 + 496, a1 + 508);
  return sub_809A45E(a1);
}

//----- (08117174) --------------------------------------------------------
int __cdecl sub_8117174(int a1)
{
  int v1; // ST2C_4
  int result; // eax
  signed int v3; // [esp+18h] [ebp-40h]
  signed int v4; // [esp+1Ch] [ebp-3Ch]
  signed int v5; // [esp+20h] [ebp-38h]
  signed int v6; // [esp+24h] [ebp-34h]
  int v7; // [esp+28h] [ebp-30h]
  int v8; // [esp+30h] [ebp-28h]
  float v9; // [esp+34h] [ebp-24h]
  float v10; // [esp+38h] [ebp-20h]
  int v11; // [esp+4Ch] [ebp-Ch]

  if ( byte_859C748 )
  {
    v1 = sub_8117F76("light", (int)&unk_8157110, (int)&v11);
    v7 = sub_8117FEC("color", (int)"1 1 1", (int)&v8);
    if ( v1 || v7 )
    {
      v6 = (signed int)(*(float *)&v8 * 255.0);
      if ( v6 > 255 )
        v6 = 255;
      v5 = (signed int)(v9 * 255.0);
      if ( v5 > 255 )
        v5 = 255;
      v4 = (signed int)(v10 * 255.0);
      if ( v4 > 255 )
        v4 = 255;
      v3 = (signed int)(*(float *)&v11 / 4.0);
      if ( v3 > 255 )
        v3 = 255;
      *(_DWORD *)(a1 + 128) = (v4 << 16) | v6 | (v5 << 8) | (v3 << 24);
    }
  }
  *(_BYTE *)(a1 + 358) = 5;
  *(_BYTE *)(a1 + 242) = 0;
  *(_DWORD *)(a1 + 4) = 6;
  sub_8117DEE((_DWORD *)(a1 + 312), (_DWORD *)(a1 + 24));
  *(_DWORD *)(a1 + 12) = 0;
  sub_8117DEE((_DWORD *)(a1 + 324), (_DWORD *)(a1 + 60));
  *(_DWORD *)(a1 + 48) = 0;
  result = *(_DWORD *)(a1 + 372) | 0x1000;
  *(_DWORD *)(a1 + 372) = result;
  return result;
}
// 859C748: using guessed type char byte_859C748;

//----- (08117316) --------------------------------------------------------
int __cdecl sub_8117316(int a1)
{
  sub_808FF44(a1);
  sub_8117174(a1);
  *(_DWORD *)(a1 + 284) = 1;
  return sub_809A45E(a1);
}

//----- (0811734C) --------------------------------------------------------
int __usercall sub_811734C@<eax>(long double a1@<st0>, int a2)
{
  sub_811B20E(a1, a2);
  sub_8117174(a2);
  *(_BYTE *)(a2 + 242) |= 4u;
  *(_DWORD *)(a2 + 284) = 8320;
  return sub_809A45E(a2);
}

//----- (08117398) --------------------------------------------------------
int __cdecl sub_8117398(int a1)
{
  int result; // eax

  sub_8117174(a1);
  *(_DWORD *)(a1 + 284) = 0;
  sub_809A45E(a1);
  if ( *(_DWORD *)(a1 + 128) )
  {
    result = a1;
    *(_DWORD *)(a1 + 8) |= 0x20u;
  }
  else
  {
    result = a1;
    *(_BYTE *)(a1 + 242) |= 1u;
  }
  return result;
}

//----- (081173F6) --------------------------------------------------------
void __cdecl sub_81173F6(float *a1, float *a2, float *a3)
{
  int v3; // [esp+14h] [ebp-4h]

  *a1 = sub_8084320(1u);
  if ( *a1 <= 0.0 )
    sub_8084E14(1, (int)"total time must be positive");
  v3 = sub_8084AEE();
  if ( v3 <= 2 )
  {
    *a2 = 0.0;
    *a3 = 0.0;
  }
  else
  {
    *a2 = sub_8084320(2u);
    if ( *a2 < 0.0 )
      sub_8084E14(2, (int)"accel time must be nonnegative");
    if ( v3 <= 3 )
    {
      *a3 = 0.0;
    }
    else
    {
      *a3 = sub_8084320(3u);
      if ( *a3 < 0.0 )
        sub_8084E14(3, (int)"decel time must be nonnegative");
    }
  }
  if ( *a2 + *a3 > (long double)*a1 )
    sub_8084DB4((int)"accel time plus decel time is greater than total time");
}

//----- (081174FA) --------------------------------------------------------
int __cdecl sub_81174FA(int a1)
{
  char *v1; // eax
  char *v3; // [esp+2Ch] [ebp-2Ch]
  int v4; // [esp+30h] [ebp-28h]
  float v5; // [esp+44h] [ebp-14h]
  float v6; // [esp+48h] [ebp-10h]
  float v7; // [esp+4Ch] [ebp-Ch]

  if ( HIWORD(a1) )
  {
    sub_8084E30((int)"not an entity");
    v3 = 0;
  }
  else
  {
    v3 = (char *)&unk_8665480 + 560 * (unsigned __int16)a1;
    if ( *((_WORD *)v3 + 180) != word_87A22E2
      && *((_WORD *)v3 + 180) != word_87A22E4
      && *((_WORD *)v3 + 180) != word_87A22E6 )
    {
      v1 = va("entity %i is not a script_brushmodel, script_model, or script_origin", (unsigned __int16)a1);
      sub_8084E30((int)v1);
    }
  }
  sub_80846F8(0, &v4);
  sub_81173F6(&v7, &v6, &v5);
  return sub_8116F18((int)v3, (int)&v4, v7, v6, v5);
}
// 87A22E2: using guessed type __int16 word_87A22E2;
// 87A22E4: using guessed type __int16 word_87A22E4;
// 87A22E6: using guessed type __int16 word_87A22E6;

//----- (081175DC) --------------------------------------------------------
int __cdecl sub_81175DC(int a1)
{
  char *v1; // eax
  char *v3; // [esp+1Ch] [ebp-2Ch]
  int v4; // [esp+20h] [ebp-28h]
  float v5; // [esp+3Ch] [ebp-Ch]

  if ( HIWORD(a1) )
  {
    sub_8084E30((int)"not an entity");
    v3 = 0;
  }
  else
  {
    v3 = (char *)&unk_8665480 + 560 * (unsigned __int16)a1;
    if ( *((_WORD *)v3 + 180) != word_87A22E2
      && *((_WORD *)v3 + 180) != word_87A22E4
      && *((_WORD *)v3 + 180) != word_87A22E6 )
    {
      v1 = va("entity %i is not a script_brushmodel, script_model, or script_origin", (unsigned __int16)a1);
      sub_8084E30((int)v1);
    }
  }
  sub_80846F8(0, &v4);
  v5 = sub_8084320(1u);
  return sub_8116FAA((int)v3, (int)&v4, v5);
}
// 87A22E2: using guessed type __int16 word_87A22E2;
// 87A22E4: using guessed type __int16 word_87A22E4;
// 87A22E6: using guessed type __int16 word_87A22E6;

//----- (081176A6) --------------------------------------------------------
int __cdecl sub_81176A6(int a1, int a2)
{
  char *v2; // eax
  char *v4; // [esp+2Ch] [ebp-2Ch]
  int v5[4]; // [esp+30h] [ebp-28h]
  float v6; // [esp+40h] [ebp-18h]
  float v7; // [esp+44h] [ebp-14h]
  float v8; // [esp+48h] [ebp-10h]
  float v9; // [esp+4Ch] [ebp-Ch]

  if ( HIWORD(a1) )
  {
    sub_8084E30((int)"not an entity");
    v4 = 0;
  }
  else
  {
    v4 = (char *)&unk_8665480 + 560 * (unsigned __int16)a1;
    if ( *((_WORD *)v4 + 180) != word_87A22E2
      && *((_WORD *)v4 + 180) != word_87A22E4
      && *((_WORD *)v4 + 180) != word_87A22E6 )
    {
      v2 = va("entity %i is not a script_brushmodel, script_model, or script_origin", (unsigned __int16)a1);
      sub_8084E30((int)v2);
    }
  }
  v9 = sub_8084320(0);
  sub_81173F6(&v8, &v7, &v6);
  sub_8117DEE((_DWORD *)v4 + 78, v5);
  *(float *)&v5[a2] = *(float *)&v5[a2] + v9;
  return sub_8116F18((int)v4, (int)v5, v8, v7, v6);
}
// 87A22E2: using guessed type __int16 word_87A22E2;
// 87A22E4: using guessed type __int16 word_87A22E4;
// 87A22E6: using guessed type __int16 word_87A22E6;
// 81176A6: using guessed type int var_28[4];

//----- (081177AC) --------------------------------------------------------
int __cdecl sub_81177AC(int a1)
{
  return sub_81176A6(a1, 0);
}

//----- (081177C8) --------------------------------------------------------
int __cdecl sub_81177C8(int a1)
{
  return sub_81176A6(a1, 1);
}

//----- (081177E4) --------------------------------------------------------
int __cdecl sub_81177E4(int a1)
{
  return sub_81176A6(a1, 2);
}

//----- (08117800) --------------------------------------------------------
int __cdecl sub_8117800(int a1)
{
  char *v1; // eax
  int v2; // esi
  int v3; // ebx
  char *v5; // [esp+2Ch] [ebp-4Ch]
  int v6[4]; // [esp+30h] [ebp-48h]
  float v7[4]; // [esp+40h] [ebp-38h]
  float v8; // [esp+50h] [ebp-28h]
  float v9; // [esp+54h] [ebp-24h]
  float v10; // [esp+58h] [ebp-20h]
  int i; // [esp+5Ch] [ebp-1Ch]

  if ( HIWORD(a1) )
  {
    sub_8084E30((int)"not an entity");
    v5 = 0;
  }
  else
  {
    v5 = (char *)&unk_8665480 + 560 * (unsigned __int16)a1;
    if ( *((_WORD *)v5 + 180) != word_87A22E2
      && *((_WORD *)v5 + 180) != word_87A22E4
      && *((_WORD *)v5 + 180) != word_87A22E6 )
    {
      v1 = va("entity %i is not a script_brushmodel, script_model, or script_origin", (unsigned __int16)a1);
      sub_8084E30((int)v1);
    }
  }
  sub_80846F8(0, v7);
  sub_81173F6(&v10, &v9, &v8);
  for ( i = 0; i <= 2; ++i )
  {
    v2 = i;
    v3 = i;
    *(float *)&v6[v2] = sub_80A6000(v7[i], *(float *)&v5[4 * i + 324]) + *(float *)&v5[4 * v3 + 324];
  }
  return sub_8117050((int)v5, (int)v6, v10, v9, v8);
}
// 87A22E2: using guessed type __int16 word_87A22E2;
// 87A22E4: using guessed type __int16 word_87A22E4;
// 87A22E6: using guessed type __int16 word_87A22E6;
// 8117800: using guessed type float var_38[4];
// 8117800: using guessed type int var_48[4];

//----- (08117938) --------------------------------------------------------
int __cdecl sub_8117938(int a1, int a2)
{
  char *v2; // eax
  char *v4; // [esp+2Ch] [ebp-2Ch]
  int v5[4]; // [esp+30h] [ebp-28h]
  float v6; // [esp+40h] [ebp-18h]
  float v7; // [esp+44h] [ebp-14h]
  float v8; // [esp+48h] [ebp-10h]
  float v9; // [esp+4Ch] [ebp-Ch]

  if ( HIWORD(a1) )
  {
    sub_8084E30((int)"not an entity");
    v4 = 0;
  }
  else
  {
    v4 = (char *)&unk_8665480 + 560 * (unsigned __int16)a1;
    if ( *((_WORD *)v4 + 180) != word_87A22E2
      && *((_WORD *)v4 + 180) != word_87A22E4
      && *((_WORD *)v4 + 180) != word_87A22E6 )
    {
      v2 = va("entity %i is not a script_brushmodel, script_model, or script_origin", (unsigned __int16)a1);
      sub_8084E30((int)v2);
    }
  }
  v9 = sub_8084320(0);
  sub_81173F6(&v8, &v7, &v6);
  sub_8117DEE((_DWORD *)v4 + 81, v5);
  *(float *)&v5[a2] = *(float *)&v5[a2] + v9;
  return sub_8117050((int)v4, (int)v5, v8, v7, v6);
}
// 87A22E2: using guessed type __int16 word_87A22E2;
// 87A22E4: using guessed type __int16 word_87A22E4;
// 87A22E6: using guessed type __int16 word_87A22E6;
// 8117938: using guessed type int var_28[4];

//----- (08117A3E) --------------------------------------------------------
int __cdecl sub_8117A3E(int a1)
{
  return sub_8117938(a1, 0);
}

//----- (08117A5A) --------------------------------------------------------
int __cdecl sub_8117A5A(int a1)
{
  return sub_8117938(a1, 1);
}

//----- (08117A76) --------------------------------------------------------
int __cdecl sub_8117A76(int a1)
{
  return sub_8117938(a1, 2);
}

//----- (08117A92) --------------------------------------------------------
int __cdecl sub_8117A92(int a1)
{
  char *v1; // eax
  char *v3; // [esp+2Ch] [ebp-2Ch]
  int v4; // [esp+30h] [ebp-28h]
  float v5; // [esp+44h] [ebp-14h]
  float v6; // [esp+48h] [ebp-10h]
  float v7; // [esp+4Ch] [ebp-Ch]

  if ( HIWORD(a1) )
  {
    sub_8084E30((int)"not an entity");
    v3 = 0;
  }
  else
  {
    v3 = (char *)&unk_8665480 + 560 * (unsigned __int16)a1;
    if ( *((_WORD *)v3 + 180) != word_87A22E2
      && *((_WORD *)v3 + 180) != word_87A22E4
      && *((_WORD *)v3 + 180) != word_87A22E6 )
    {
      v1 = va("entity %i is not a script_brushmodel, script_model, or script_origin", (unsigned __int16)a1);
      sub_8084E30((int)v1);
    }
  }
  sub_80846F8(0, &v4);
  sub_81173F6(&v7, &v6, &v5);
  return sub_81170E2((int)v3, (int)&v4, v7, v6, v5);
}
// 87A22E2: using guessed type __int16 word_87A22E2;
// 87A22E4: using guessed type __int16 word_87A22E4;
// 87A22E6: using guessed type __int16 word_87A22E6;

//----- (08117B74) --------------------------------------------------------
void __cdecl sub_8117B74(int a1)
{
  char *v1; // eax
  char *v2; // [esp+14h] [ebp-4h]

  if ( HIWORD(a1) )
  {
    sub_8084E30((int)"not an entity");
    v2 = 0;
  }
  else
  {
    v2 = (char *)&unk_8665480 + 560 * (unsigned __int16)a1;
    if ( *((_WORD *)v2 + 180) != word_87A22E2
      && *((_WORD *)v2 + 180) != word_87A22E4
      && *((_WORD *)v2 + 180) != word_87A22E6 )
    {
      v1 = va("entity %i is not a script_brushmodel, script_model, or script_origin", (unsigned __int16)a1);
      sub_8084E30((int)v1);
    }
  }
  if ( *((_WORD *)v2 + 180) == word_87A22E6 )
  {
    Com_DPrintf("cannot use the solid/notsolid commands on a script_origin entity( number %i )\n", *(_DWORD *)v2);
  }
  else
  {
    if ( *((_WORD *)v2 + 180) == word_87A22E4 )
    {
      *((_DWORD *)v2 + 71) = 8320;
    }
    else
    {
      *((_DWORD *)v2 + 71) = 1;
      *((_DWORD *)v2 + 2) &= 0xFFFFFFFE;
    }
    sub_809A45E((int)v2);
  }
}
// 87A22E2: using guessed type __int16 word_87A22E2;
// 87A22E4: using guessed type __int16 word_87A22E4;
// 87A22E6: using guessed type __int16 word_87A22E6;

//----- (08117C76) --------------------------------------------------------
void __cdecl sub_8117C76(int a1)
{
  char *v1; // eax
  char *v2; // [esp+14h] [ebp-4h]

  if ( HIWORD(a1) )
  {
    sub_8084E30((int)"not an entity");
    v2 = 0;
  }
  else
  {
    v2 = (char *)&unk_8665480 + 560 * (unsigned __int16)a1;
    if ( *((_WORD *)v2 + 180) != word_87A22E2
      && *((_WORD *)v2 + 180) != word_87A22E4
      && *((_WORD *)v2 + 180) != word_87A22E6 )
    {
      v1 = va("entity %i is not a script_brushmodel, script_model, or script_origin", (unsigned __int16)a1);
      sub_8084E30((int)v1);
    }
  }
  if ( *((_WORD *)v2 + 180) == word_87A22E6 )
  {
    Com_DPrintf("cannot use the solid/notsolid commands on a script_origin entity( number %i )\n", *(_DWORD *)v2);
  }
  else
  {
    *((_DWORD *)v2 + 71) = 0;
    if ( *((_WORD *)v2 + 180) != word_87A22E4 )
      *((_DWORD *)v2 + 2) |= 1u;
    sub_809A45E((int)v2);
  }
}
// 87A22E2: using guessed type __int16 word_87A22E2;
// 87A22E4: using guessed type __int16 word_87A22E4;
// 87A22E6: using guessed type __int16 word_87A22E6;

//----- (08117D6A) --------------------------------------------------------
int (__cdecl *__cdecl sub_8117D6A(char **a1))(__int16)
{
  char *s1; // [esp+10h] [ebp-8h]
  unsigned int i; // [esp+14h] [ebp-4h]

  s1 = *a1;
  for ( i = 0; i <= 0xB; ++i )
  {
    if ( !strcmp(s1, (&off_8157300)[3 * i]) )
    {
      *a1 = (&off_8157300)[3 * i];
      return off_8157304[3 * i];
    }
  }
  return 0;
}
// 8157300: using guessed type char *off_8157300;

//----- (08117DEE) --------------------------------------------------------
int __cdecl sub_8117DEE(_DWORD *a1, _DWORD *a2)
{
  int result; // eax

  *a2 = *a1;
  a2[1] = a1[1];
  result = a1[2];
  a2[2] = result;
  return result;
}

//----- (08117E1E) --------------------------------------------------------
int __cdecl sub_8117E1E(float *a1, float *a2, float *a3)
{
  int result; // eax

  *a3 = *a1 - *a2;
  a3[1] = a1[1] - a2[1];
  result = (int)(a1 + 2);
  a3[2] = a1[2] - a2[2];
  return result;
}

//----- (08117E62) --------------------------------------------------------
int __cdecl sub_8117E62(int a1, float a2, int a3)
{
  int result; // eax

  *(float *)a3 = a2 * *(float *)a1;
  *(float *)(a3 + 4) = a2 * *(float *)(a1 + 4);
  result = a1 + 8;
  *(float *)(a3 + 8) = a2 * *(float *)(a1 + 8);
  return result;
}

//----- (08117E9A) --------------------------------------------------------
int __cdecl sub_8117E9A(int a1, float a2, int a3, int a4)
{
  int result; // eax

  *(float *)a4 = a2 * *(float *)a3 + *(float *)a1;
  *(float *)(a4 + 4) = a2 * *(float *)(a3 + 4) + *(float *)(a1 + 4);
  result = a3 + 8;
  *(float *)(a4 + 8) = a2 * *(float *)(a3 + 8) + *(float *)(a1 + 8);
  return result;
}

//----- (08117EEE) --------------------------------------------------------
void __cdecl sub_8117EEE(float *a1)
{
  float v1; // ST00_4

  v1 = *a1 * *a1 + a1[1] * a1[1] + a1[2] * a1[2];
  sub_8117F2C(v1);
}

//----- (08117F2C) --------------------------------------------------------
long double __cdecl sub_8117F2C(float a1)
{
  return (float)sqrt(a1);
}

//----- (08117F4C) --------------------------------------------------------
int __cdecl sub_8117F4C(char *s1, int a2, int a3)
{
  return sub_80F1A0A((int)&byte_859C748, s1, a2, a3);
}
// 859C748: using guessed type char byte_859C748;

//----- (08117F76) --------------------------------------------------------
int __cdecl sub_8117F76(char *s1, int a2, int a3)
{
  int v3; // ST1C_4
  char *nptr; // [esp+20h] [ebp-8h]

  v3 = sub_8117F4C(s1, a2, (int)&nptr);
  *(float *)a3 = atof(nptr);
  return v3;
}

//----- (08117FB2) --------------------------------------------------------
int __cdecl sub_8117FB2(char *s1, int a2, int a3)
{
  int v3; // ST10_4
  char *nptr; // [esp+14h] [ebp-4h]

  v3 = sub_8117F4C(s1, a2, (int)&nptr);
  *(_DWORD *)a3 = atoi(nptr);
  return v3;
}

//----- (08117FEC) --------------------------------------------------------
int __cdecl sub_8117FEC(char *s1, int a2, int a3)
{
  int v3; // ST20_4
  char *s; // [esp+24h] [ebp-4h]

  v3 = sub_8117F4C(s1, a2, (int)&s);
  sub_81193A8((_DWORD *)a3);
  sscanf(s, "%f %f %f", a3, a3 + 4, a3 + 8);
  return v3;
}

//----- (0811804C) --------------------------------------------------------
void sub_811804C()
{
  sub_8084DB4((int)"Tried to set a read only entity field");
}

//----- (08118060) --------------------------------------------------------
int __cdecl sub_8118060(char *s1, char *nptr)
{
  int v2; // ST2C_4
  int v3; // eax
  char v6; // [esp+30h] [ebp-28h]
  int v7; // [esp+34h] [ebp-24h]
  int v8; // [esp+38h] [ebp-20h]
  int v9; // [esp+48h] [ebp-10h]
  int v10; // [esp+4Ch] [ebp-Ch]

  v9 = sub_807F168(s1, (int)&v10);
  if ( !v9 )
    return 0;
  if ( v10 == 4 )
  {
    sub_81193A8(&v6);
    sscanf(nptr, "%f %f %f", &v6, &v7, &v8);
    Scr_AddVector(&v6);
  }
  else if ( v10 > 4 )
  {
    if ( v10 == 5 )
    {
      *(float *)&v2 = atof(nptr);
      Scr_AddFloat(v2);
    }
    else if ( v10 == 6 )
    {
      v3 = atoi(nptr);
      Scr_AddInt(v3);
    }
  }
  else if ( v10 == 2 )
  {
    Scr_AddString(nptr);
  }
  return v9;
}

//----- (08118148) --------------------------------------------------------
int __cdecl sub_8118148(char *s1, char *nptr, int a3)
{
  int result; // eax

  result = sub_8118060(s1, nptr);
  if ( result )
    result = sub_81190B6((int *)a3, result);
  return result;
}

//----- (08118180) --------------------------------------------------------
void __cdecl sub_8118180(char *s1, char *s, int a3)
{
  char *v3; // ebx
  float *v4; // ebx
  int v5; // [esp+30h] [ebp-28h]
  int v6; // [esp+34h] [ebp-24h]
  int v7; // [esp+38h] [ebp-20h]
  int v8; // [esp+48h] [ebp-10h]
  char **i; // [esp+4Ch] [ebp-Ch]

  for ( i = off_8157780; ; i += 4 )
  {
    if ( !*i )
    {
      sub_8118148(s1, s, a3);
      return;
    }
    if ( !I_stricmp(*i, s1) )
      break;
  }
  v8 = a3;
  switch ( (unsigned int)i[2] )
  {
    case 0u:
      *(_DWORD *)&i[1][v8] = atoi(s);
      break;
    case 1u:
      v4 = (float *)&i[1][v8];
      *v4 = atof(s);
      break;
    case 2u:
    case 5u:
    case 6u:
    case 7u:
      return;
    case 3u:
      sub_8079790(&i[1][v8], 0);
      v3 = &i[1][v8];
      *(_WORD *)v3 = sub_80F1A74(s);
      break;
    case 4u:
      sub_81193A8(&v5);
      sscanf(s, "%f %f %f", &v5, &v6, &v7);
      *(_DWORD *)&i[1][v8] = v5;
      *(_DWORD *)&i[1][v8 + 4] = v6;
      *(_DWORD *)&i[1][v8 + 8] = v7;
      break;
    case 8u:
      if ( *s == 42 )
        *(_DWORD *)(a3 + 140) = (unsigned __int16)atoi(s + 1);
      else
        sub_811B3EA(a3, s);
      break;
  }
}

//----- (08118320) --------------------------------------------------------
int __cdecl sub_8118320(_DWORD *a1)
{
  int i; // [esp+14h] [ebp-4h]

  for ( i = 0; i < dword_859C74C; ++i )
    sub_8118180((&dword_859C750)[2 * i], nptr[2 * i], (int)a1);
  sub_811CF36(a1, a1 + 78);
  return sub_811CF96(a1, a1 + 81);
}
// 859C74C: using guessed type int dword_859C74C;

//----- (08118398) --------------------------------------------------------
int sub_8118398()
{
  int result; // eax
  int v1; // [esp+Ch] [ebp-Ch]
  int v2; // [esp+10h] [ebp-8h]
  int i; // [esp+14h] [ebp-4h]

  sub_8083AAC(dword_879D834, 0);
  v1 = sub_808491A(0);
  for ( i = 0; ; ++i )
  {
    result = i;
    if ( i >= dword_859C74C )
      break;
    v2 = sub_8118060((&dword_859C750)[2 * i], nptr[2 * i]);
    if ( v2 )
      sub_8084F28(v1, v2);
  }
  return result;
}
// 859C74C: using guessed type int dword_859C74C;
// 879D834: using guessed type int dword_879D834;

//----- (0811841C) --------------------------------------------------------
char **__cdecl sub_811841C(int a1, int a2)
{
  char **result; // eax
  char **i; // [esp+14h] [ebp-4h]

  for ( i = off_8157780; ; i += 4 )
  {
    result = i;
    if ( !*i )
      break;
    switch ( (unsigned int)i[2] )
    {
      case 0u:
        *(_DWORD *)&i[1][a1] = *(_DWORD *)&i[1][a2];
        break;
      case 1u:
        *(_DWORD *)&i[1][a1] = *(_DWORD *)&i[1][a2];
        break;
      case 2u:
      case 5u:
      case 6u:
      case 7u:
        continue;
      case 3u:
        sub_8079790(&i[1][a1], *(unsigned __int16 *)&i[1][a2]);
        break;
      case 4u:
        sub_81193D2(&i[1][a2], &i[1][a1]);
        break;
      case 8u:
        i[1][a1] = i[1][a2];
        break;
    }
  }
  return result;
}

//----- (08118504) --------------------------------------------------------
int __cdecl sub_8118504(int *a1, int *a2)
{
  return sub_807EECE(*a2, *a1, 0);
}

//----- (0811852A) --------------------------------------------------------
int __cdecl sub_811852A(char *s1)
{
  int v2; // [esp+14h] [ebp-14h]
  signed int i; // [esp+18h] [ebp-10h]
  int v4; // [esp+20h] [ebp-8h]

  if ( !strncmp(s1, "weapon_", 7u) && (v4 = sub_811E940(s1 + 7)) != 0 )
  {
    sub_80E9270(v4);
    v2 = sub_80DCAE6(v4);
  }
  else
  {
    for ( i = 129; i < 131; ++i )
    {
      if ( !strcmp(*((const char **)&unk_8164C20 + 11 * i), s1) )
        return (int)&unk_8164C20 + 44 * i;
    }
    v2 = 0;
  }
  return v2;
}

//----- (081185EA) --------------------------------------------------------
void __usercall sub_81185EA(long double a1@<st0>)
{
  char *s2; // [esp+18h] [ebp-10h]
  _DWORD *v2; // [esp+1Ch] [ebp-Ch]
  int v3; // [esp+20h] [ebp-8h]
  char **i; // [esp+24h] [ebp-4h]

  sub_8117F4C("classname", (int)&byte_8157544, (int)&s2);
  if ( s2 )
  {
    v3 = sub_811852A(s2);
    if ( v3 )
    {
      v2 = (_DWORD *)sub_811C546();
      sub_8118320(v2);
      sub_8104EB2(a1, (int)v2, v3);
    }
    else
    {
      for ( i = &off_8168560; ; i += 2 )
      {
        if ( !*i )
        {
          v2 = (_DWORD *)sub_811C546();
          sub_8118320(v2);
          return;
        }
        if ( !strcmp(*i, s2) )
          break;
      }
      if ( i[1] != (char *)sub_811C9C0 )
      {
        v2 = (_DWORD *)sub_811C546();
        sub_8118320(v2);
        ((void (__cdecl *)(_DWORD *))i[1])(v2);
      }
    }
  }
  else
  {
    Com_Printf("G_CallSpawn: NULL classname\n");
  }
}
// 8168560: using guessed type char *off_8168560;

//----- (081186D2) --------------------------------------------------------
signed int __usercall sub_81186D2@<eax>(long double a1@<st0>, int a2)
{
  int v2; // eax
  signed int v4; // [esp+8h] [ebp-10h]
  char *s2; // [esp+Ch] [ebp-Ch]
  int v6; // [esp+10h] [ebp-8h]
  char **i; // [esp+14h] [ebp-4h]

  if ( *(_WORD *)(a2 + 360) )
  {
    s2 = (char *)sub_8078896(*(unsigned __int16 *)(a2 + 360));
    v6 = sub_811852A(s2);
    if ( v6 )
    {
      sub_8104EB2(a1, a2, v6);
      v4 = 1;
    }
    else
    {
      for ( i = &off_8168560; *i; i += 2 )
      {
        if ( !strcmp(*i, s2) )
        {
          ((void (__cdecl *)(int))i[1])(a2);
          return 1;
        }
      }
      v2 = sub_8078896(*(unsigned __int16 *)(a2 + 360));
      Com_Printf("%s doesn't have a spawn function\n", v2);
      v4 = 0;
    }
  }
  else
  {
    Com_Printf("G_CallSpawnEntity: NULL classname\n");
    v4 = 0;
  }
  return v4;
}
// 8168560: using guessed type char *off_8168560;

//----- (081187B8) --------------------------------------------------------
void **sub_81187B8()
{
  void **i; // [esp+14h] [ebp-4h]

  for ( i = (void **)off_8157780; *i; i += 4 )
    sub_807E1F6(0, *i, ((char *)i - (char *)off_8157780) >> 4);
  return sub_80F5D66();
}

//----- (08118806) --------------------------------------------------------
int sub_8118806()
{
  return sub_807F47A((int)"radiant", "txt");
}

//----- (08118822) --------------------------------------------------------
signed int __cdecl sub_8118822(int a1, int a2)
{
  signed int v3; // [esp+Ch] [ebp-Ch]
  char *v4; // [esp+10h] [ebp-8h]
  char **v5; // [esp+14h] [ebp-4h]

  v4 = (char *)&unk_8665480 + 560 * a1;
  if ( (a2 & 0xC000) == 49152 )
  {
    if ( *((_DWORD *)v4 + 86) )
    {
      sub_80F5DBC(*((_DWORD *)v4 + 86), a2 & 0xFFFF3FFF);
      v3 = 1;
    }
    else
    {
      v3 = 0;
    }
  }
  else
  {
    v5 = &off_8157780[4 * a2];
    if ( v5[3] )
      ((void (__cdecl *)(char *, int))v5[3])(v4, a2);
    else
      sub_81188EE((int)v4, (int)v5[2], (int)v5[1]);
    v3 = 1;
  }
  return v3;
}

//----- (081188EE) --------------------------------------------------------
int __cdecl sub_81188EE(int a1, int a2, int a3)
{
  int result; // eax
  int v4; // eax
  long double v5; // fst7
  int v6; // [esp+10h] [ebp-18h]
  int v7; // [esp+14h] [ebp-14h]
  int v8; // [esp+18h] [ebp-10h]

  result = a2;
  switch ( a2 )
  {
    case 0:
      result = sub_808404C(0);
      *(_DWORD *)(a1 + a3) = result;
      break;
    case 1:
      v5 = sub_8084320(0);
      result = a1 + a3;
      *(float *)(a1 + a3) = v5;
      break;
    case 2:
      return result;
    case 3:
      v4 = sub_8084586(0);
      result = sub_8079790((_WORD *)(a1 + a3), v4);
      break;
    case 4:
      sub_80846F8(0, &v6);
      *(_DWORD *)(a3 + a1) = v6;
      *(_DWORD *)(a1 + a3 + 4) = v7;
      result = v8;
      *(_DWORD *)(a1 + a3 + 8) = v8;
      break;
    case 5:
      result = sub_8118CDE(0);
      *(_DWORD *)(a1 + a3) = result;
      break;
    case 6:
      sub_80846F8(0, &v6);
      result = v7;
      *(_DWORD *)(a3 + a1) = v7;
      break;
  }
  return result;
}

//----- (081189D2) --------------------------------------------------------
signed int __cdecl sub_81189D2(int a1, int a2, int a3)
{
  if ( !a1 )
    return sub_8118822(a2, a3);
  if ( a1 == 1 )
    sub_8101716(a2, a3);
  return 1;
}

//----- (08118A22) --------------------------------------------------------
char *__cdecl sub_8118A22(int a1, int a2)
{
  char *result; // eax
  char *v3; // [esp+10h] [ebp-8h]

  v3 = (char *)&unk_8665480 + 560 * a1;
  if ( (a2 & 0xC000) != 49152 )
    return (char *)sub_8118AAC((int)v3, (int)off_8157780[4 * a2 + 2], (int)off_8157780[4 * a2 + 1]);
  result = (char *)&unk_8665480 + 560 * a1;
  if ( *((_DWORD *)v3 + 86) )
    result = (char *)sub_80F5E1E(*((_DWORD *)v3 + 86), a2 & 0xFFFF3FFF);
  return result;
}

//----- (08118AAC) --------------------------------------------------------
int __cdecl sub_8118AAC(int a1, int a2, int a3)
{
  int result; // eax
  char *v4; // eax
  unsigned __int16 v5; // [esp+1Eh] [ebp-2Ah]
  int v6; // [esp+20h] [ebp-28h]
  int v7; // [esp+24h] [ebp-24h]
  int v8; // [esp+28h] [ebp-20h]
  unsigned __int16 v9; // [esp+3Ah] [ebp-Eh]
  char *s; // [esp+3Ch] [ebp-Ch]

  switch ( a2 )
  {
    case 0:
      result = Scr_AddInt(*(_DWORD *)(a1 + a3));
      break;
    case 1:
      result = Scr_AddFloat(*(_DWORD *)(a1 + a3));
      break;
    case 2:
      s = (char *)(a1 + a3);
      result = Scr_AddString((char *)(a1 + a3));
      break;
    case 3:
      result = *(unsigned __int16 *)(a1 + a3);
      v9 = *(_WORD *)(a1 + a3);
      if ( v9 )
        result = sub_8084C8E(v9);
      break;
    case 4:
      result = (int)Scr_AddVector((_DWORD *)(a1 + a3));
      break;
    case 5:
      result = a1 + a3;
      if ( *(_DWORD *)(a1 + a3) )
        result = Scr_AddEntity(*(int **)(a1 + a3));
      break;
    case 6:
      v6 = 0;
      v7 = *(_DWORD *)(a1 + a3);
      v8 = 0;
      result = (int)Scr_AddVector(&v6);
      break;
    case 7:
      result = *(unsigned __int16 *)(a1 + a3);
      v5 = *(_WORD *)(a1 + a3);
      if ( v5 )
        result = sub_8084BA2(v5);
      break;
    case 8:
      v4 = sub_811B124(*(unsigned __int8 *)(a1 + a3));
      result = Scr_AddString(v4);
      break;
  }
  return result;
}

//----- (08118BCC) --------------------------------------------------------
char *__cdecl sub_8118BCC(char *a1, int a2, int a3)
{
  char *result; // eax

  result = a1;
  if ( !a1 )
    return sub_8118A22(a2, a3);
  if ( a1 == (char *)1 )
    result = (char *)sub_810169E(a2, a3);
  return result;
}

//----- (08118C0E) --------------------------------------------------------
int *__cdecl sub_8118C0E(int a1)
{
  int *result; // eax
  int j; // [esp+Ch] [ebp-Ch]
  int v3; // [esp+10h] [ebp-8h]
  char **i; // [esp+14h] [ebp-4h]

  for ( i = off_8157780; ; i += 4 )
  {
    result = (int *)i;
    if ( !*i )
      break;
    if ( i[2] == (char *)3 )
    {
      v3 = a1;
      sub_8079790(&i[1][a1], 0);
    }
  }
  for ( j = 0; j <= 6; ++j )
  {
    *(_BYTE *)(j + a1 + 528) = 0;
    sub_8079790((_WORD *)(a1 + 2 * j + 536), 0);
    result = &j;
  }
  return result;
}

//----- (08118C98) --------------------------------------------------------
void __cdecl sub_8118C98(int *a1)
{
  sub_8118C0E((int)a1);
  sub_807DF90(*a1, 0);
}

//----- (08118CC0) --------------------------------------------------------
int __cdecl Scr_AddEntity(int *a1)
{
  return sub_8084BD2(*a1, 0);
}

//----- (08118CDE) --------------------------------------------------------
int __cdecl sub_8118CDE(unsigned int a1)
{
  int v3; // [esp+10h] [ebp-8h]
  int v4; // [esp+14h] [ebp-4h]

  sub_808481E(&v3, a1);
  v4 = v3;
  if ( !HIWORD(v3) )
    return 560 * (unsigned __int16)v4 + 140924032;
  sub_8084E14(a1, (int)"not an entity");
  return 0;
}

//----- (08118D3A) --------------------------------------------------------
void __cdecl sub_8118D3A(int a1)
{
  sub_810178E(a1);
  sub_807DF90(-1963413621 * ((a1 - (signed int)dword_8578000) >> 2), 1);
}
// 8578000: using guessed type int dword_8578000[];

//----- (08118D6E) --------------------------------------------------------
int __cdecl sub_8118D6E(int a1)
{
  return sub_8084BD2(-1963413621 * ((a1 - (signed int)dword_8578000) >> 2), 1);
}
// 8578000: using guessed type int dword_8578000[];

//----- (08118D98) --------------------------------------------------------
int __cdecl sub_8118D98(unsigned int a1)
{
  int v3; // [esp+10h] [ebp-8h]
  int v4; // [esp+14h] [ebp-4h]

  sub_808481E(&v3, a1);
  v4 = v3;
  if ( HIWORD(v3) == 1 )
    return 140 * (unsigned __int16)v4 + 139952128;
  sub_8084E14(a1, (int)"not a hudelem");
  return 0;
}

//----- (08118DF4) --------------------------------------------------------
int __cdecl sub_8118DF4(int *a1, int a2, int a3)
{
  return (unsigned __int16)sub_8083A1A(*a1, 0, a2, a3);
}

//----- (08118E22) --------------------------------------------------------
int __cdecl sub_8118E22(int *a1, int a2, int a3)
{
  return sub_8083B14(*a1, 0, a2, a3);
}

//----- (08118E4E) --------------------------------------------------------
int __cdecl Scr_Notify(int *a1, unsigned __int16 a2, int a3)
{
  return sub_8083426(*a1, 0, a2, a3);
}

//----- (08118E82) --------------------------------------------------------
int sub_8118E82()
{
  int v0; // eax
  int result; // eax
  int v2; // [esp+8h] [ebp-20h]
  int *v3; // [esp+Ch] [ebp-1Ch]
  int v4; // [esp+10h] [ebp-18h]
  __int16 v5; // [esp+14h] [ebp-14h]
  __int16 v6; // [esp+16h] [ebp-12h]
  void *i; // [esp+20h] [ebp-8h]

  v5 = sub_80843C0(0);
  v0 = sub_808456A(1u);
  result = sub_807E2EA(0, v0);
  v4 = result;
  if ( result >= 0 )
  {
    result = (int)&off_8157780[4 * result];
    if ( *(_DWORD *)(result + 8) == 3 )
    {
      v3 = 0;
      v2 = 0;
      for ( i = &unk_8665480; ; i = (char *)i + 560 )
      {
        result = v2;
        if ( v2 >= *(_DWORD *)dword_859B40C )
          break;
        if ( *((_BYTE *)i + 252) )
        {
          v6 = *(_WORD *)&off_8157780[4 * v4 + 1][(_DWORD)i];
          if ( v6 )
          {
            if ( v6 == v5 )
            {
              if ( v3 )
                sub_8084DB4((int)"getent used with more than one entity");
              v3 = (int *)i;
            }
          }
        }
        ++v2;
      }
      if ( v3 )
        result = Scr_AddEntity(v3);
    }
  }
  return result;
}

//----- (08118F7E) --------------------------------------------------------
int sub_8118F7E()
{
  int result; // eax
  int v1; // eax
  int v2; // [esp+Ch] [ebp-1Ch]
  int v3; // [esp+Ch] [ebp-1Ch]
  int v4; // [esp+10h] [ebp-18h]
  __int16 v5; // [esp+14h] [ebp-14h]
  __int16 v6; // [esp+16h] [ebp-12h]
  int *j; // [esp+20h] [ebp-8h]
  void *i; // [esp+20h] [ebp-8h]

  if ( sub_8084AEE() )
  {
    v5 = sub_80843C0(0);
    v1 = sub_808456A(1u);
    result = sub_807E2EA(0, v1);
    v4 = result;
    if ( result >= 0 )
    {
      result = (int)&off_8157780[4 * result];
      if ( *(_DWORD *)(result + 8) == 3 )
      {
        sub_8084CF0();
        v3 = 0;
        for ( i = &unk_8665480; ; i = (char *)i + 560 )
        {
          result = v3;
          if ( v3 >= *(_DWORD *)dword_859B40C )
            break;
          if ( *((_BYTE *)i + 252) )
          {
            v6 = *(_WORD *)&off_8157780[4 * v4 + 1][(_DWORD)i];
            if ( v6 )
            {
              if ( v6 == v5 )
              {
                Scr_AddEntity((int *)i);
                sub_8084D1C();
              }
            }
          }
          ++v3;
        }
      }
    }
  }
  else
  {
    sub_8084CF0();
    v2 = 0;
    for ( j = (int *)&unk_8665480; ; j += 140 )
    {
      result = v2;
      if ( v2 >= *(_DWORD *)dword_859B40C )
        break;
      if ( *((_BYTE *)j + 252) )
      {
        Scr_AddEntity(j);
        sub_8084D1C();
      }
      ++v2;
    }
  }
  return result;
}

//----- (081190B6) --------------------------------------------------------
signed int __cdecl sub_81190B6(int *a1, int a2)
{
  return sub_8084F6A(*a1, 0, a2);
}

//----- (081190DA) --------------------------------------------------------
int sub_81190DA()
{
  char *v0; // eax
  char *v1; // eax
  float v2; // ST10_4
  int result; // eax
  char *nptr; // [esp+14h] [ebp-4h]

  sub_8117F4C("classname", (int)&byte_8157544, (int)&nptr);
  if ( I_stricmp(nptr, "worldspawn") )
    Com_Error(1, &byte_81576A0);
  sub_8090E6C(2, "cod");
  v0 = va("%i", *(_DWORD *)dword_859B5F8);
  sub_8090E6C(13, v0);
  sub_8117F4C("ambienttrack", (int)&byte_8157544, (int)&nptr);
  if ( *nptr )
  {
    v1 = va("n\\%s", nptr);
    sub_8090E6C(3, v1);
  }
  else
  {
    sub_8090E6C(3, &byte_8157544);
  }
  sub_8117F4C("message", (int)&byte_8157544, (int)&nptr);
  sub_8090E6C(4, nptr);
  sub_8090E6C(14, *(char **)(dword_8793DBC + 8));
  sub_8117F4C("gravity", (int)"800", (int)&nptr);
  v2 = atof(nptr);
  sub_80B24AC(dword_8793D94, (char *)LODWORD(v2));
  sub_8117F4C("northyaw", (int)&byte_8157544, (int)&nptr);
  if ( *nptr )
    sub_8090E6C(11, nptr);
  else
    sub_8090E6C(11, "0");
  sub_8117F4C("spawnflags", (int)"0", (int)&nptr);
  dword_86F1190 = atoi(nptr);
  dword_86F1020 = 1022;
  result = sub_8079790(&unk_86F1188, (unsigned __int16)word_87A2300);
  byte_86F111C = 1;
  return result;
}
// 86F1020: using guessed type int dword_86F1020;
// 86F111C: using guessed type char byte_86F111C;
// 86F1190: using guessed type int dword_86F1190;
// 8793D94: using guessed type int dword_8793D94;
// 8793DBC: using guessed type int dword_8793DBC;
// 87A2300: using guessed type __int16 word_87A2300;

//----- (081192E0) --------------------------------------------------------
signed int __usercall sub_81192E0@<eax>(long double a1@<st0>)
{
  signed int result; // eax

  if ( !sub_80F187E((int)&byte_859C748) )
    Com_Error(1, &byte_8157717);
  sub_81190DA();
  while ( 1 )
  {
    result = sub_80F187E((int)&byte_859C748);
    if ( !result )
      break;
    sub_81185EA(a1);
  }
  return result;
}
// 859C748: using guessed type char byte_859C748;

//----- (0811932A) --------------------------------------------------------
void *sub_811932A()
{
  char *s2; // [esp+10h] [ebp-8h]
  unsigned __int16 v2; // [esp+16h] [ebp-2h]

  v2 = sub_808398E(dword_879D830, 0);
  sub_8083B8E(v2);
  while ( sub_80F187E((int)&byte_859C748) )
  {
    sub_8117F4C("classname", (int)&byte_8157544, (int)&s2);
    if ( !strcmp("script_struct", s2) )
      sub_8118398();
  }
  return sub_8090A48();
}
// 859C748: using guessed type char byte_859C748;
// 879D830: using guessed type int dword_879D830;

//----- (081193A8) --------------------------------------------------------
int __cdecl sub_81193A8(_DWORD *a1)
{
  int result; // eax

  *a1 = 0;
  a1[1] = 0;
  result = 0;
  a1[2] = 0;
  return result;
}

//----- (081193D2) --------------------------------------------------------
int __cdecl sub_81193D2(_DWORD *a1, _DWORD *a2)
{
  int result; // eax

  *a2 = *a1;
  a2[1] = a1[1];
  result = a1[2];
  a2[2] = result;
  return result;
}

//----- (08119404) --------------------------------------------------------
signed int __cdecl sub_8119404(char *a1, _DWORD *a2)
{
  char *v2; // eax
  _BYTE *v3; // ebx
  int v6; // [esp+20h] [ebp-98h]
  int v7; // [esp+24h] [ebp-94h]
  int v8; // [esp+28h] [ebp-90h]
  int i; // [esp+2Ch] [ebp-8Ch]
  char nptr[128]; // [esp+30h] [ebp-88h]
  char v11[8]; // [esp+B0h] [ebp-8h]

  for ( i = 0; i <= 3; ++i )
  {
    *((_BYTE *)&v7 + i) = 0;
    *((_BYTE *)&v6 + i) = 0;
  }
  for ( i = 0; i <= 3; ++i )
  {
    if ( *a1 <= 47 || *a1 > 57 )
    {
      Com_Printf("Bad filter address: %s\n", a1);
      return 0;
    }
    v8 = 0;
    while ( *a1 > 47 && *a1 <= 57 )
    {
      v2 = a1++;
      v11[v8++ - 128] = *v2;
    }
    nptr[v8] = 0;
    v3 = (char *)&v7 + i;
    *v3 = atoi(nptr);
    if ( *((_BYTE *)&v7 + i) )
      *((_BYTE *)&v6 + i) = -1;
    if ( !*a1 )
      break;
    ++a1;
  }
  *a2 = v6;
  a2[1] = v7;
  return 1;
}
// 8119404: using guessed type char var_8[8];
// 8119404: using guessed type char nptr[128];

//----- (0811956E) --------------------------------------------------------
void sub_811956E()
{
  size_t v0; // esi
  size_t v1; // eax
  char s[1032]; // [esp+20h] [ebp-418h]
  int i; // [esp+428h] [ebp-10h]
  int v4; // [esp+42Ch] [ebp-Ch]

  s[0] = 0;
  for ( i = 0; i < dword_87A1E80; ++i )
  {
    if ( dword_879FE84[2 * i] != -1 )
    {
      v4 = dword_879FE84[2 * i];
      v0 = 1024 - strlen(s);
      v1 = strlen(s);
      Com_sprintf(&s[v1], v0, "%i.%i.%i.%i ", (unsigned __int8)v4, BYTE1(v4), BYTE2(v4), HIBYTE(v4));
    }
  }
  Dvar_SetString(dword_8793E04, s);
}
// 87A1E80: using guessed type int dword_87A1E80;
// 811956E: using guessed type char s[1032];

//----- (08119642) --------------------------------------------------------
void __cdecl sub_8119642(char *a1)
{
  int i; // [esp+14h] [ebp-4h]

  for ( i = 0; i < dword_87A1E80 && dword_879FE84[2 * i] != -1; ++i )
    ;
  if ( i == dword_87A1E80 )
  {
    if ( dword_87A1E80 == 1024 )
    {
      Com_Printf("IP filter list is full\n");
      return;
    }
    ++dword_87A1E80;
  }
  if ( !sub_8119404(a1, (_DWORD *)(8 * i + 142212736)) )
    dword_879FE84[2 * i] = -1;
  sub_811956E();
}
// 87A1E80: using guessed type int dword_87A1E80;

//----- (081196D0) --------------------------------------------------------
char *sub_81196D0()
{
  char *result; // eax
  char dest; // [esp+10h] [ebp-418h]
  char *i; // [esp+418h] [ebp-10h]
  char *s; // [esp+41Ch] [ebp-Ch]

  dword_87A1E80 = 0;
  I_strncpyz(&dest, *(char **)(dword_8793E04 + 8), 1024);
  s = &dest;
  for ( i = &dest; ; i = s )
  {
    result = i;
    if ( !*i )
      break;
    result = strchr(s, 32);
    s = result;
    if ( !result )
      break;
    while ( *s == 32 )
      *s++ = 0;
    if ( *i )
      sub_8119642(i);
  }
  return result;
}
// 87A1E80: using guessed type int dword_87A1E80;

//----- (08119772) --------------------------------------------------------
void sub_8119772()
{
  char dest; // [esp+10h] [ebp-408h]

  if ( sub_805FFE6() > 1 )
  {
    sub_8060074(1, &dest, 1024);
    sub_8119642(&dest);
  }
  else
  {
    Com_Printf("Usage:  addip <ip-mask>\n");
  }
}

//----- (081197C2) --------------------------------------------------------
void sub_81197C2()
{
  char dest; // [esp+10h] [ebp-418h]
  int i; // [esp+414h] [ebp-14h]
  char v2[4]; // [esp+418h] [ebp-10h]
  int v3; // [esp+41Ch] [ebp-Ch]

  if ( sub_805FFE6() > 1 )
  {
    sub_8060074(1, &dest, 1024);
    if ( sub_8119404(&dest, v2) )
    {
      for ( i = 0; i < dword_87A1E80; ++i )
      {
        if ( dword_879FE80[2 * i] == *(_DWORD *)v2 && dword_879FE84[2 * i] == v3 )
        {
          dword_879FE84[2 * i] = -1;
          Com_Printf("Removed.\n");
          sub_811956E();
          return;
        }
      }
      Com_Printf("Didn't find %s.\n", &dest);
    }
  }
  else
  {
    Com_Printf("Usage:  sv removeip <ip-mask>\n");
  }
}
// 879FE80: using guessed type int dword_879FE80[];
// 87A1E80: using guessed type int dword_87A1E80;

//----- (08119892) --------------------------------------------------------
signed int sub_8119892()
{
  signed int result; // eax
  int v1; // eax
  _DWORD *v2; // [esp+10h] [ebp-8h]
  signed int v3; // [esp+14h] [ebp-4h]

  v2 = &unk_86656B0;
  v3 = 1;
  while ( 1 )
  {
    result = v3;
    if ( v3 >= *(_DWORD *)dword_859B40C )
      break;
    if ( *((_BYTE *)v2 + 252) )
    {
      Com_Printf("%3i:", v3);
      switch ( v2[1] )
      {
        case 0:
          Com_Printf("ET_GENERAL          ");
          break;
        case 1:
          Com_Printf("ET_PLAYER           ");
          break;
        case 2:
          Com_Printf("%3i                 ", v2[1]);
          break;
        case 3:
          Com_Printf("ET_ITEM             ");
          break;
        case 4:
          Com_Printf("ET_MISSILE          ");
          break;
        case 5:
          Com_Printf("ET_INVISIBLE        ");
          break;
        case 6:
          Com_Printf("ET_SCRIPTMOVER      ");
          break;
      }
      if ( *((_WORD *)v2 + 180) )
      {
        v1 = sub_8078896(*((unsigned __int16 *)v2 + 180));
        Com_Printf("%s", v1);
      }
      Com_Printf("\n");
    }
    ++v3;
    v2 += 140;
  }
  return result;
}

//----- (081199B4) --------------------------------------------------------
int __cdecl sub_81199B4(char *nptr)
{
  int v2; // [esp+8h] [ebp-10h]
  int v3; // [esp+Ch] [ebp-Ch]
  int i; // [esp+10h] [ebp-8h]
  int v5; // [esp+14h] [ebp-4h]

  if ( *nptr <= 47 || *nptr > 57 )
  {
    for ( i = 0; i < dword_859B5E4; ++i )
    {
      v5 = dword_859B400 + 10404 * i;
      if ( *(_DWORD *)(dword_859B400 + 10404 * i + 9924) && !I_stricmp((char *)(v5 + 10116), nptr) )
        return v5;
    }
    Com_Printf("User %s is not on the server\n", nptr);
    v2 = 0;
  }
  else
  {
    v3 = atoi(nptr);
    if ( v3 >= 0 && v3 < dword_859B5E4 )
    {
      if ( *(_DWORD *)(dword_859B400 + 10404 * v3 + 9924) )
      {
        v2 = dword_859B400 + 10404 * v3;
      }
      else
      {
        Com_Printf("Client %i is not connected\n", v3);
        v2 = 0;
      }
    }
    else
    {
      Com_Printf("Bad client slot: %i\n", v3);
      v2 = 0;
    }
  }
  return v2;
}
// 859B400: using guessed type int dword_859B400;
// 859B5E4: using guessed type int dword_859B5E4;

//----- (08119AD4) --------------------------------------------------------
signed int __usercall sub_8119AD4@<eax>(long double a1@<st0>)
{
  void *v1; // eax
  char *v2; // eax
  signed int v4; // [esp+1Ch] [ebp-40Ch]
  char dest; // [esp+20h] [ebp-408h]

  sub_8060074(0, &dest, 1024);
  if ( I_stricmp(&dest, "entitylist") )
  {
    if ( I_stricmp(&dest, "addip") )
    {
      if ( I_stricmp(&dest, "removeip") )
      {
        if ( I_stricmp(&dest, "listip") )
        {
          if ( !*(_DWORD *)(dword_8793D8C + 8) || I_stricmp(&dest, "say") )
          {
            v4 = 0;
          }
          else
          {
            v1 = sub_80FBA44(1);
            v2 = va(aCGameServer, 101, v1);
            sub_808FE96(-1, 0, (int)v2);
            v4 = 1;
          }
        }
        else
        {
          Cbuf_ExecuteText(a1, 1, "g_banIPs\n");
          v4 = 1;
        }
      }
      else
      {
        sub_81197C2();
        v4 = 1;
      }
    }
    else
    {
      sub_8119772();
      v4 = 1;
    }
  }
  else
  {
    sub_8119892();
    v4 = 1;
  }
  return v4;
}
// 8793D8C: using guessed type int dword_8793D8C;

//----- (08119C40) --------------------------------------------------------
_BOOL4 __cdecl sub_8119C40(int a1, int a2)
{
  if ( !*(_DWORD *)(a1 + 344) || !*(_DWORD *)(a2 + 344) )
    return 0;
  if ( *(_DWORD *)(*(_DWORD *)(a1 + 344) + 10060) )
    return *(_DWORD *)(*(_DWORD *)(a1 + 344) + 10060) == *(_DWORD *)(*(_DWORD *)(a2 + 344) + 10060);
  return 0;
}

//----- (08119CB8) --------------------------------------------------------
int __cdecl sub_8119CB8(int a1)
{
  int result; // eax
  char s; // [esp+30h] [ebp-78h]
  unsigned __int16 v3; // [esp+4Ch] [ebp-5Ch]
  int v4; // [esp+60h] [ebp-48h]
  int v5; // [esp+70h] [ebp-38h]
  float v6; // [esp+78h] [ebp-30h]
  int v7; // [esp+80h] [ebp-28h]
  int v8; // [esp+98h] [ebp-10h]
  int v9; // [esp+9Ch] [ebp-Ch]

  if ( *(_DWORD *)(*(_DWORD *)(a1 + 344) + 9896) )
  {
    sub_80F61BE(a1, (float *)&v5);
    sub_80F63A0(a1, (int)&v7, 0, 0);
    if ( *(float *)(*(_DWORD *)(a1 + 344) + 248) < 8.0 )
      v6 = 8.0 - *(float *)(*(_DWORD *)(a1 + 344) + 248) + v6;
    sub_8119F76((int)&v5, 8192.0, (int)&v7, (int)&v4);
  }
  else
  {
    if ( !*(_DWORD *)(*(_DWORD *)(a1 + 344) + 10060) )
    {
      *(_DWORD *)(*(_DWORD *)(a1 + 344) + 312) = -1;
      result = *(_DWORD *)(a1 + 344);
      *(_DWORD *)(result + 316) = 0;
      return result;
    }
    sub_80F61BE(a1, (float *)&v5);
    sub_80F63A0(a1, (int)&v7, 0, 0);
    sub_8119F76((int)&v5, 8192.0, (int)&v7, (int)&v4);
  }
  sub_8108090(
    &s,
    (int)&v5,
    (int)&unk_8145E68,
    (int)&unk_8145E68,
    (int)&v4,
    *(_DWORD *)(*(_DWORD *)(a1 + 344) + 204),
    33554433);
  v9 = v3;
  if ( (signed int)v3 > 63
    || !dword_86655D8[140 * v9]
    || sub_80FCEA8(a1) && *(_DWORD *)(dword_86655D8[140 * v9] + 10060) != *(_DWORD *)(*(_DWORD *)(a1 + 344) + 10060) )
  {
    v9 = -1;
    v8 = 0;
  }
  else
  {
    v8 = dword_8665614[140 * v9];
  }
  *(_DWORD *)(*(_DWORD *)(a1 + 344) + 312) = v9;
  result = v8;
  *(_DWORD *)(*(_DWORD *)(a1 + 344) + 316) = v8;
  return result;
}
// 86655D8: using guessed type int dword_86655D8[];
// 8665614: using guessed type int dword_8665614[];

//----- (08119EF2) --------------------------------------------------------
int sub_8119EF2()
{
  int result; // eax
  char *v1; // [esp+10h] [ebp-8h]
  int i; // [esp+14h] [ebp-4h]

  result = dword_859B5EC - dword_859B60C;
  if ( dword_859B5EC - dword_859B60C > 0 )
  {
    dword_859B60C = dword_859B5EC;
    for ( i = 0; ; ++i )
    {
      result = i;
      if ( i >= *(_DWORD *)(dword_8793D88 + 8) )
        break;
      v1 = (char *)&unk_8665480 + 560 * i;
      if ( v1[252] )
      {
        if ( !(*(_DWORD *)(*((_DWORD *)v1 + 86) + 12) & 0x400000) )
          sub_8119CB8((int)v1);
      }
    }
  }
  return result;
}
// 859B60C: using guessed type int dword_859B60C;
// 8793D88: using guessed type int dword_8793D88;

//----- (08119F76) --------------------------------------------------------
int __cdecl sub_8119F76(int a1, float a2, int a3, int a4)
{
  int result; // eax

  *(float *)a4 = a2 * *(float *)a3 + *(float *)a1;
  *(float *)(a4 + 4) = a2 * *(float *)(a3 + 4) + *(float *)(a1 + 4);
  result = a3 + 8;
  *(float *)(a4 + 8) = a2 * *(float *)(a3 + 8) + *(float *)(a1 + 8);
  return result;
}

//----- (08119FCC) --------------------------------------------------------
int __cdecl sub_8119FCC(int *a1, int *a2)
{
  int result; // eax
  int v3; // ST14_4

  result = sub_8084030();
  if ( result )
  {
    if ( dword_859E9E8 == 256 )
    {
      Scr_AddEntity(a2);
      result = Scr_Notify(a1, word_87A22F4, 1);
    }
    else
    {
      v3 = 12 * dword_859E9E8++ + 140104168;
      *(_WORD *)v3 = *(_WORD *)a1;
      *(_WORD *)(v3 + 2) = *(_WORD *)a2;
      *(_DWORD *)(v3 + 4) = a1[138];
      result = a2[138];
      *(_DWORD *)(v3 + 8) = result;
    }
  }
  return result;
}
// 859E9E8: using guessed type int dword_859E9E8;
// 87A22F4: using guessed type __int16 word_87A22F4;

//----- (0811A074) --------------------------------------------------------
int __cdecl sub_811A074(int a1)
{
  int result; // eax

  sub_808FF44(a1);
  *(_DWORD *)(a1 + 284) = 1079771144;
  *(_BYTE *)(a1 + 242) = 1;
  result = *(_DWORD *)(a1 + 8) | 1;
  *(_DWORD *)(a1 + 8) = result;
  return result;
}

//----- (0811A0AE) --------------------------------------------------------
void __cdecl sub_811A0AE(int a1, int a2)
{
  int v2; // [esp+14h] [ebp-4h]

  if ( byte_859C748 && sub_8117F76("wait", (int)&unk_8157A40, (int)&v2) && *(float *)&v2 <= 0.0 )
    *(_DWORD *)(a1 + 368) |= a2;
}
// 859C748: using guessed type char byte_859C748;

//----- (0811A106) --------------------------------------------------------
int __cdecl sub_811A106(int a1)
{
  int result; // eax

  *(_DWORD *)(a1 + 284) = 0;
  if ( !(*(_DWORD *)(a1 + 368) & 8) )
    *(_DWORD *)(a1 + 284) |= 0x40000000u;
  if ( *(_BYTE *)(a1 + 368) & 1 )
    *(_DWORD *)(a1 + 284) |= 0x40000u;
  if ( *(_DWORD *)(a1 + 368) & 2 )
    *(_DWORD *)(a1 + 284) |= 0x80000u;
  result = *(_DWORD *)(a1 + 368) & 4;
  if ( result )
  {
    result = a1;
    *(_DWORD *)(a1 + 284) |= 0x100000u;
  }
  return result;
}

//----- (0811A1B8) --------------------------------------------------------
int __cdecl sub_811A1B8(int *a1)
{
  int result; // eax

  result = a1[92] & 0x10;
  if ( result )
    result = sub_811CB00(a1);
  return result;
}

//----- (0811A1DE) --------------------------------------------------------
int __cdecl sub_811A1DE(int *a1, int *a2)
{
  sub_8119FCC(a1, a2);
  return sub_811A1B8(a1);
}

//----- (0811A20A) --------------------------------------------------------
int __cdecl sub_811A20A(int a1)
{
  *(_BYTE *)(a1 + 358) = 1;
  sub_811A0AE(a1, 16);
  sub_811A074(a1);
  sub_811A106(a1);
  return sub_809A45E(a1);
}

//----- (0811A250) --------------------------------------------------------
int __cdecl sub_811A250(int a1)
{
  char *v1; // eax
  char *v2; // eax
  char v4[4]; // [esp+20h] [ebp-8h]
  char v5[4]; // [esp+24h] [ebp-4h]

  if ( byte_859C748 )
  {
    if ( !sub_8117F76("radius", (int)&unk_8157A40, (int)v5) )
    {
      v1 = va(
             "radius not specified for trigger_radius at (%g %g %g)",
             *(float *)(a1 + 312),
             *(float *)(a1 + 316),
             *(float *)(a1 + 320));
      Com_Error(1, v1);
    }
    if ( !sub_8117F76("height", (int)&unk_8157A40, (int)v4) )
    {
      v2 = va(
             "height not specified for trigger_radius at (%g %g %g)",
             *(float *)(a1 + 312),
             *(float *)(a1 + 316),
             *(float *)(a1 + 320));
      Com_Error(1, v2);
    }
  }
  else
  {
    if ( (unsigned int)sub_8084AEE() <= 4 )
      sub_8084DB4((int)"USAGE: spawn( \"trigger_radius\", <origin>, <spawnflags>, <radius>, <height> )");
    *(float *)v5 = sub_8084320(3u);
    *(float *)v4 = sub_8084320(4u);
  }
  *(_BYTE *)(a1 + 358) = 1;
  *(_DWORD *)(a1 + 260) = *(_DWORD *)v5 ^ 0x80000000;
  *(_DWORD *)(a1 + 264) = *(_DWORD *)v5 ^ 0x80000000;
  *(_DWORD *)(a1 + 268) = 0;
  *(float *)(a1 + 272) = *(float *)v5;
  *(float *)(a1 + 276) = *(float *)v5;
  *(float *)(a1 + 280) = *(float *)v4;
  *(_BYTE *)(a1 + 242) = 33;
  sub_811A0AE(a1, 16);
  sub_811A106(a1);
  return sub_809A45E(a1);
}
// 859C748: using guessed type char byte_859C748;

//----- (0811A3F0) --------------------------------------------------------
int __cdecl sub_811A3F0(int a1)
{
  char *v1; // eax
  char v3[4]; // [esp+24h] [ebp-4h]

  if ( !sub_8117F76("radius", (int)&unk_8157A40, (int)v3) )
  {
    v1 = va(
           "radius not specified for trigger_radius at (%g %g %g)",
           *(float *)(a1 + 312),
           *(float *)(a1 + 316),
           *(float *)(a1 + 320));
    Com_Error(1, v1);
  }
  *(_BYTE *)(a1 + 358) = 1;
  *(float *)v3 = *(float *)v3 + 64.0;
  *(_DWORD *)(a1 + 260) = *(_DWORD *)v3 ^ 0x80000000;
  *(_DWORD *)(a1 + 264) = *(_DWORD *)v3 ^ 0x80000000;
  *(_DWORD *)(a1 + 268) = -943501312;
  *(float *)(a1 + 272) = *(float *)v3;
  *(float *)(a1 + 276) = *(float *)v3;
  *(_DWORD *)(a1 + 280) = 1203982336;
  *(_BYTE *)(a1 + 242) = 65;
  sub_811A0AE(a1, 16);
  sub_811A106(a1);
  return sub_809A45E(a1);
}

//----- (0811A4FC) --------------------------------------------------------
int __cdecl sub_811A4FC(int a1, int a2)
{
  int result; // eax

  result = a2;
  if ( *(_BYTE *)(a2 + 353) )
  {
    result = *(_DWORD *)(a1 + 432);
    if ( result <= dword_859B5EC )
    {
      sub_8119FCC((int *)a1, (int *)a2);
      if ( *(_DWORD *)(a1 + 368) & 0x10 )
        *(_DWORD *)(a1 + 432) = dword_859B5EC + 1000;
      else
        *(_DWORD *)(a1 + 432) = dword_859B5EC + 50;
      if ( *(_DWORD *)(a1 + 368) & 8 )
        sub_80FF7C8((int *)a2, (int *)a1, (int *)a1, 0, 0, *(_DWORD *)(a1 + 412), 16, 0xDu, 0, 0);
      else
        sub_80FF7C8((int *)a2, (int *)a1, (int *)a1, 0, 0, *(_DWORD *)(a1 + 412), 0, 0xDu, 0, 0);
      result = *(_DWORD *)(a1 + 368) & 0x20;
      if ( result )
      {
        result = a1;
        *(_BYTE *)(a1 + 358) = 2;
      }
    }
  }
  return result;
}

//----- (0811A62A) --------------------------------------------------------
int __cdecl sub_811A62A(int a1)
{
  int result; // eax
  int v2; // [esp+14h] [ebp-4h]

  sub_811A074(a1);
  sub_8117F4C("sound", (int)"world_hurt_me", (int)&v2);
  if ( !*(_DWORD *)(a1 + 412) )
    *(_DWORD *)(a1 + 412) = 5;
  *(_DWORD *)(a1 + 284) = 1079771144;
  if ( (*(_BYTE *)(a1 + 368) ^ 1) & 1 )
  {
    result = a1;
    *(_BYTE *)(a1 + 358) = 3;
  }
  else
  {
    result = a1;
    *(_BYTE *)(a1 + 358) = 2;
  }
  return result;
}

//----- (0811A6A6) --------------------------------------------------------
int __cdecl sub_811A6A6(int a1)
{
  *(_BYTE *)(a1 + 358) = 1;
  *(_DWORD *)(a1 + 368) |= 0x10u;
  sub_811A074(a1);
  sub_811A106(a1);
  return sub_809A45E(a1);
}

//----- (0811A6EE) --------------------------------------------------------
_BOOL4 __cdecl sub_811A6EE(int a1, signed int a2)
{
  if ( *(_BYTE *)(a1 + 368) & 1 && a2 == 1 )
    return 0;
  if ( *(_DWORD *)(a1 + 368) & 2 && a2 == 2 )
    return 0;
  if ( *(_DWORD *)(a1 + 368) & 4 && (unsigned int)(a2 - 3) <= 3 )
    return 0;
  if ( *(_DWORD *)(a1 + 368) & 8 && a2 >= 3 && (a2 <= 6 || a2 == 14) )
    return 0;
  if ( *(_DWORD *)(a1 + 368) & 0x10 && (a2 == 4 || a2 == 6) )
    return 0;
  if ( *(_DWORD *)(a1 + 368) & 0x20 && a2 == 7 )
    return 0;
  return !(*(_DWORD *)(a1 + 368) & 0x100) || a2 && (a2 < 0 || (unsigned int)(a2 - 9) > 4);
}

//----- (0811A826) --------------------------------------------------------
int __cdecl sub_811A826(int *a1, int *a2, int a3, signed int a4)
{
  int result; // eax

  if ( a1[106] <= 0 || (result = a3, a3 >= a1[106]) )
  {
    result = sub_811A6EE((int)a1, a4);
    if ( result )
    {
      if ( !a1[107] || (result = (int)a1, 32000 - a1[101] >= a1[107]) )
      {
        if ( a4 != -1 )
          sub_8119FCC(a1, a2);
        a1[101] = 32000;
        result = a1[92] & 0x200;
        if ( result )
          result = sub_811CB00(a1);
      }
    }
  }
  return result;
}

//----- (0811A8D2) --------------------------------------------------------
int __cdecl sub_811A8D2(int *a1, int *a2)
{
  return sub_811A826(a1, a2, a1[107] + 1, -1);
}

//----- (0811A902) --------------------------------------------------------
int *__cdecl sub_811A902(int *a1, int *a2, int a3, int a4, signed int a5)
{
  int *result; // eax

  sub_811A826(a1, a2, a3, a5);
  result = a1;
  if ( !a1[107] )
  {
    result = a1;
    a1[101] = 32000;
  }
  return result;
}

//----- (0811A944) --------------------------------------------------------
int *__cdecl sub_811A944(int *a1, int a2, int *a3, int a4, signed int a5)
{
  int *result; // eax

  sub_811A826(a1, a3, a4, a5);
  result = a1;
  if ( !a1[107] )
  {
    result = a1;
    a1[101] = 32000;
  }
  return result;
}

//----- (0811A986) --------------------------------------------------------
int __cdecl sub_811A986(int a1)
{
  sub_8117FB2("accumulate", (int)"0", a1 + 428);
  sub_8117FB2("threshold", (int)"0", a1 + 424);
  *(_DWORD *)(a1 + 404) = 32000;
  *(_BYTE *)(a1 + 353) = 1;
  *(_BYTE *)(a1 + 358) = 4;
  sub_811A0AE(a1, 512);
  sub_811A074(a1);
  return sub_809A45E(a1);
}

//----- (0811AA18) --------------------------------------------------------
int __cdecl sub_811AA18(int *a1, _DWORD *a2, float *a3, int a4, signed int a5)
{
  int result; // eax
  float *v6; // [esp+2Ch] [ebp-105Ch]
  char v7; // [esp+30h] [ebp-1058h]
  char v8; // [esp+40h] [ebp-1048h]
  float v9[4]; // [esp+50h] [ebp-1038h]
  float v10[4]; // [esp+60h] [ebp-1028h]
  int v11[1026]; // [esp+70h] [ebp-1018h]
  int v12; // [esp+1078h] [ebp-10h]
  int i; // [esp+107Ch] [ebp-Ch]

  sub_811ADFA(a2, v10);
  sub_811ADFA(a2, v9);
  sub_80A660A(a3, v10, v9);
  v12 = sub_805E782((int)v10, (int)v9, (int)v11, 1024, 0x400000);
  for ( i = 0; ; ++i )
  {
    result = i;
    if ( i >= v12 )
      break;
    v6 = (float *)((char *)&unk_8665480 + 560 * v11[i]);
    if ( *((_WORD *)v6 + 180) == word_87A22FA )
    {
      sub_811AE2A(v6 + 78, v6 + 65, (float *)&v8);
      sub_811AE2A(v6 + 78, v6 + 68, (float *)&v7);
      if ( sub_809BE82((int)a2, (int)&unk_8145E68, (int)&unk_8145E68, (int)a3, *(_DWORD *)v6, -1) )
      {
        Scr_AddEntity(a1);
        Scr_AddInt(a4);
        Scr_Notify((int *)v6, word_87A22A8, 2);
        sub_811A826((int *)v6, a1, a4, a5);
        if ( !*((_DWORD *)v6 + 107) )
          *((_DWORD *)v6 + 101) = 32000;
      }
    }
  }
  return result;
}
// 87A22A8: using guessed type __int16 word_87A22A8;
// 87A22FA: using guessed type __int16 word_87A22FA;
// 811AA18: using guessed type int var_1018[1026];

//----- (0811AC06) --------------------------------------------------------
int __cdecl sub_811AC06(int *a1, _DWORD *a2, float *a3, int a4, signed int a5)
{
  int result; // eax
  int *v6; // [esp+2Ch] [ebp-103Ch]
  float v7[4]; // [esp+30h] [ebp-1038h]
  float v8[4]; // [esp+40h] [ebp-1028h]
  int v9[1026]; // [esp+50h] [ebp-1018h]
  int v10; // [esp+1058h] [ebp-10h]
  int i; // [esp+105Ch] [ebp-Ch]

  sub_811ADFA(a2, v8);
  sub_811ADFA(a2, v7);
  sub_80A660A(a3, v8, v7);
  v10 = sub_805E782((int)v8, (int)v7, (int)v9, 1024, 0x400000);
  for ( i = 0; ; ++i )
  {
    result = i;
    if ( i >= v10 )
      break;
    v6 = (int *)((char *)&unk_8665480 + 560 * v9[i]);
    if ( *((_WORD *)v6 + 180) == word_87A22FA
      && v6[93] & 0x4000
      && sub_809BE82((int)a2, (int)&unk_8145E68, (int)&unk_8145E68, (int)a3, *v6, -1) )
    {
      Scr_AddEntity(a1);
      Scr_AddInt(a4);
      Scr_Notify(v6, word_87A22A8, 2);
      sub_811A826(v6, a1, a4, a5);
      if ( !v6[107] )
        v6[101] = 32000;
    }
  }
  return result;
}
// 87A22A8: using guessed type __int16 word_87A22A8;
// 87A22FA: using guessed type __int16 word_87A22FA;
// 811AC06: using guessed type int var_1018[1026];

//----- (0811ADB6) --------------------------------------------------------
int __cdecl sub_811ADB6(int a1)
{
  sub_808FF44(a1);
  *(_DWORD *)(a1 + 284) = 0x20000000;
  *(_BYTE *)(a1 + 242) = 1;
  *(_DWORD *)(a1 + 8) |= 1u;
  return sub_809A45E(a1);
}

//----- (0811ADFA) --------------------------------------------------------
int __cdecl sub_811ADFA(_DWORD *a1, _DWORD *a2)
{
  int result; // eax

  *a2 = *a1;
  a2[1] = a1[1];
  result = a1[2];
  a2[2] = result;
  return result;
}

//----- (0811AE2A) --------------------------------------------------------
int __cdecl sub_811AE2A(float *a1, float *a2, float *a3)
{
  int result; // eax

  *a3 = *a1 + *a2;
  a3[1] = a1[1] + a2[1];
  result = (int)(a1 + 2);
  a3[2] = a1[2] + a2[2];
  return result;
}

//----- (0811AE70) --------------------------------------------------------
int __cdecl sub_811AE70(char *s2, int a2, int a3, int a4, int a5)
{
  char *v5; // eax
  char *v6; // eax
  int v8; // [esp+Ch] [ebp-Ch]
  char *s1; // [esp+10h] [ebp-8h]
  int i; // [esp+14h] [ebp-4h]

  if ( !s2 || !*s2 )
    return 0;
  for ( i = 1; i < a3; ++i )
  {
    s1 = sub_8091108(a2 + i);
    if ( !*s1 )
      break;
    if ( !strcasecmp(s1, s2) )
      return i;
  }
  if ( a4 )
  {
    if ( i == a3 )
    {
      v6 = va(&byte_8157B80, a2, s2);
      Com_Error(1, v6);
    }
    sub_8090E6C(a2 + i, s2);
    v8 = i;
  }
  else
  {
    if ( a5 )
    {
      v5 = va("%s \"%s\" not precached", a5, s2);
      sub_8084DB4((int)v5);
    }
    v8 = 0;
  }
  return v8;
}

//----- (0811AF6E) --------------------------------------------------------
int __cdecl sub_811AF6E(char *s2)
{
  int v2; // [esp+14h] [ebp-4h]

  if ( *s2 )
    v2 = sub_811AE70(s2, 1310, 256, dword_859B41C, (int)"localized string");
  else
    v2 = 0;
  return v2;
}

//----- (0811AFBA) --------------------------------------------------------
int __cdecl sub_811AFBA(char *src)
{
  char dest; // [esp+20h] [ebp-48h]

  strcpy(&dest, src);
  sub_80B573C(&dest);
  return sub_811AE70(&dest, 1566, 128, dword_859B41C, (int)"shader");
}

//----- (0811B00C) --------------------------------------------------------
int __cdecl sub_811B00C(char *s2)
{
  char *v1; // eax
  int v2; // ebx
  char *s1; // [esp+Ch] [ebp-Ch]
  int i; // [esp+10h] [ebp-8h]

  if ( !*s2 )
    return 0;
  for ( i = 1; i <= 255; ++i )
  {
    s1 = sub_8091108(i + 334);
    if ( !*s1 )
      break;
    if ( !strcasecmp(s1, s2) )
      return i;
  }
  if ( !dword_859B41C )
  {
    v1 = va("model '%s' not precached", s2);
    sub_8084DB4((int)v1);
  }
  if ( i == 256 )
    Com_Error(1, &byte_8157BDF);
  v2 = i;
  dword_87A1EA0[v2] = sub_8090534(s2);
  sub_8090E6C(i + 334, s2);
  return i;
}

//----- (0811B0F8) --------------------------------------------------------
int __cdecl sub_811B0F8(int a1)
{
  return dword_87A1EA0[a1];
}

//----- (0811B108) --------------------------------------------------------
int __cdecl sub_811B108(int a1)
{
  int v1; // eax

  v1 = sub_811B0F8(a1);
  return sub_80C2D44(v1);
}

//----- (0811B124) --------------------------------------------------------
char *__cdecl sub_811B124(int a1)
{
  return sub_8091108(a1 + 334);
}

//----- (0811B13C) --------------------------------------------------------
int __cdecl sub_811B13C(char *s2)
{
  return sub_811AE70(s2, 110, 32, 1, 0);
}

//----- (0811B170) --------------------------------------------------------
int __cdecl sub_811B170(char *s2)
{
  return sub_811AE70(s2, 846, 64, dword_859B41C, (int)"effect");
}

//----- (0811B1A4) --------------------------------------------------------
int __cdecl sub_811B1A4(char *s2)
{
  return sub_811AE70(s2, 1166, 16, 1, 0);
}

//----- (0811B1D8) --------------------------------------------------------
int __cdecl sub_811B1D8(char *s2)
{
  return (unsigned __int8)sub_811AE70(s2, 590, 256, 1, 0);
}

//----- (0811B20E) --------------------------------------------------------
_DWORD *__usercall sub_811B20E@<eax>(long double a1@<st0>, int a2)
{
  _DWORD *result; // eax
  signed int i; // [esp+18h] [ebp-80h]
  signed int v4; // [esp+1Ch] [ebp-7Ch]
  int v5; // [esp+20h] [ebp-78h]
  int v6; // [esp+24h] [ebp-74h]
  int v7[24]; // [esp+28h] [ebp-70h]
  int v8; // [esp+88h] [ebp-10h]
  int v9; // [esp+8Ch] [ebp-Ch]
  char v10[8]; // [esp+90h] [ebp-8h]

  result = (_DWORD *)a2;
  if ( !*(_DWORD *)(a2 + 344) )
  {
    sub_811BEEE((int *)a2);
    v9 = *(unsigned __int8 *)(a2 + 356);
    if ( v9 )
    {
      v8 = sub_811B0F8(v9);
      v5 = v8;
      v6 = 0;
      v7[0] = 0;
      v4 = 1;
      if ( !*(_DWORD *)(a2 + 4) || *(_DWORD *)(a2 + 4) == 6 || *(_DWORD *)(a2 + 4) == 9 )
        *(_DWORD *)(a2 + 140) = v9;
      for ( i = 0; i <= 6; ++i )
      {
        v9 = *(unsigned __int8 *)(i + a2 + 528);
        if ( v9 )
        {
          *(_DWORD *)&v10[12 * v4 - 112] = sub_811B0F8(v9);
          *(_DWORD *)&v10[12 * v4 - 108] = sub_8078896(*(unsigned __int16 *)(a2 + 2 * i + 536));
          v7[3 * v4++] = ((signed int)*(unsigned __int8 *)(a2 + 357) >> i) & 1;
        }
      }
      sub_8062A66((signed __int16 ***)&v5, v4, 0, *(_DWORD *)a2);
      result = sub_811BAF4(a1, a2, 1);
    }
    else
    {
      result = sub_811BAF4(a1, a2, 0);
    }
  }
  return result;
}
// 811B20E: using guessed type char var_8[8];
// 811B20E: using guessed type int anonymous_1[24];

//----- (0811B3EA) --------------------------------------------------------
int __cdecl sub_811B3EA(int a1, char *s2)
{
  int result; // eax

  if ( *s2 )
  {
    result = (unsigned __int8)sub_811B00C(s2);
    *(_BYTE *)(a1 + 356) = result;
  }
  else
  {
    result = a1;
    *(_BYTE *)(a1 + 356) = 0;
  }
  return result;
}

//----- (0811B422) --------------------------------------------------------
int __cdecl sub_811B422(int a1, char *s1)
{
  char *v2; // ST14_4
  int v3; // eax

  v2 = sub_811B124(a1);
  v3 = sub_8090534(s1);
  dword_87A1EA0[a1] = v3;
  return sub_80A98DC(4, v2 + 7, v3);
}

//----- (0811B470) --------------------------------------------------------
int __usercall sub_811B470@<eax>(long double a1@<st0>, int a2, char *s2, int a4, int a5)
{
  signed int i; // [esp+10h] [ebp-8h]

  for ( i = 0; ; ++i )
  {
    if ( i > 6 )
      return 0;
    if ( !*(_BYTE *)(i + a2 + 528) )
      break;
  }
  *(_BYTE *)(i + a2 + 528) = sub_811B00C(s2);
  sub_8079790((_WORD *)(a2 + 2 * i + 536), a4);
  if ( a5 )
    *(_BYTE *)(a2 + 357) |= 1 << i;
  sub_811B20E(a1, a2);
  return 1;
}

//----- (0811B528) --------------------------------------------------------
int __usercall sub_811B528@<eax>(long double a1@<st0>, int a2, char *s2, int a4)
{
  char *v4; // eax
  char v5; // al
  signed int i; // [esp+10h] [ebp-8h]

  for ( i = 0; ; ++i )
  {
    if ( i > 6 )
      return 0;
    if ( *(unsigned __int16 *)(a2 + 2 * i + 536) == a4 )
    {
      v4 = sub_811B124(*(unsigned __int8 *)(i + a2 + 528));
      if ( !strcasecmp(v4, s2) )
        break;
    }
  }
  *(_BYTE *)(i + a2 + 528) = 0;
  sub_8079790((_WORD *)(a2 + 2 * i + 536), 0);
  while ( i <= 5 )
  {
    *(_BYTE *)(i + a2 + 528) = *(_BYTE *)(i + a2 + 529);
    *(_WORD *)(a2 + 2 * i + 536) = *(_WORD *)(a2 + 2 * i + 538);
    if ( ((signed int)*(unsigned __int8 *)(a2 + 357) >> (i + 1)) & 1 )
      v5 = *(_BYTE *)(a2 + 357) | (1 << i);
    else
      v5 = *(_BYTE *)(a2 + 357) & ~(unsigned __int8)(1 << i);
    *(_BYTE *)(a2 + 357) = v5;
    ++i;
  }
  *(_BYTE *)(i + a2 + 528) = 0;
  *(_WORD *)(a2 + 2 * i + 536) = 0;
  *(_BYTE *)(a2 + 357) &= ~(unsigned __int8)(1 << i);
  sub_811B20E(a1, a2);
  return 1;
}

//----- (0811B6C2) --------------------------------------------------------
_DWORD *__usercall sub_811B6C2@<eax>(long double a1@<st0>, int a2)
{
  signed int i; // [esp+14h] [ebp-4h]

  for ( i = 0; i <= 6; ++i )
  {
    *(_BYTE *)(i + a2 + 528) = 0;
    sub_8079790((_WORD *)(a2 + 2 * i + 536), 0);
  }
  *(_BYTE *)(a2 + 357) = 0;
  return sub_811B20E(a1, a2);
}

//----- (0811B720) --------------------------------------------------------
signed int __usercall sub_811B720@<eax>(long double a1@<st0>, int *a2, int *a3, int a4)
{
  int v4; // ST24_4
  int v7; // [esp+1Ch] [ebp-Ch]
  int *i; // [esp+20h] [ebp-8h]

  sub_811B928(a1, a2);
  if ( a4 )
  {
    if ( !sub_8090A5A(a3) )
      return 0;
    v7 = sub_8090898(a3, a4);
    if ( v7 < 0 )
      return 0;
  }
  else
  {
    v7 = -1;
  }
  for ( i = a3; ; i = *(int **)i[130] )
  {
    if ( i == a2 )
      return 0;
    if ( !i[130] )
      break;
  }
  v4 = sub_8076A2A(112);
  *(_DWORD *)v4 = a3;
  *(_WORD *)(v4 + 8) = 0;
  sub_8079790((_WORD *)(v4 + 8), a4);
  *(_DWORD *)(v4 + 4) = a3[131];
  *(_DWORD *)(v4 + 12) = v7;
  memset((void *)(v4 + 16), 0, 0x30u);
  a3[131] = (int)a2;
  a2[130] = v4;
  memset((void *)(v4 + 64), 0, 0x30u);
  return 1;
}

//----- (0811B86E) --------------------------------------------------------
signed int __usercall sub_811B86E@<eax>(long double a1@<st0>, int *a2, int *a3, int a4)
{
  if ( !sub_811B720(a1, a2, a3, a4) )
    return 0;
  sub_811BC88((int)a2, 0);
  return 1;
}

//----- (0811B8BA) --------------------------------------------------------
signed int __usercall sub_811B8BA@<eax>(long double a1@<st0>, int *a2, int *a3, int a4, _DWORD *a5, float *a6)
{
  int v6; // ST14_4

  if ( !sub_811B720(a1, a2, a3, a4) )
    return 0;
  v6 = a2[130];
  sub_80A7146(a6, v6 + 16);
  sub_811D0FC(a5, (_DWORD *)(v6 + 52));
  return 1;
}

//----- (0811B928) --------------------------------------------------------
int __usercall sub_811B928@<eax>(long double a1@<st0>, _DWORD *a2)
{
  int result; // eax
  char v3; // [esp+10h] [ebp-28h]
  int v4; // [esp+18h] [ebp-20h]
  _DWORD *v5; // [esp+20h] [ebp-18h]
  _DWORD *i; // [esp+24h] [ebp-14h]
  int v7; // [esp+28h] [ebp-10h]
  int v8; // [esp+2Ch] [ebp-Ch]

  result = a2[130];
  v8 = a2[130];
  if ( v8 )
  {
    sub_811CF36(a2, a2 + 78);
    sub_811CF96(a2, a2 + 81);
    if ( a2[86] )
    {
      sub_811D0FC((_DWORD *)(a2[86] + 232), &v3);
      v4 = 0;
      sub_80F5E80(a1, (int)a2, &v3);
    }
    v7 = *(_DWORD *)v8;
    v5 = 0;
    for ( i = *(_DWORD **)(v7 + 524); i != a2; i = *(_DWORD **)(i[130] + 4) )
      v5 = i;
    if ( v5 )
      *(_DWORD *)(v5[130] + 4) = *(_DWORD *)(v8 + 4);
    else
      *(_DWORD *)(v7 + 524) = *(_DWORD *)(v8 + 4);
    a2[130] = 0;
    sub_8079790((_WORD *)(v8 + 8), 0);
    result = sub_8076A50(v8, 112);
  }
  return result;
}

//----- (0811BA8A) --------------------------------------------------------
int __usercall sub_811BA8A@<eax>(long double a1@<st0>, _DWORD *a2, int a3)
{
  int result; // eax
  int v4; // [esp+10h] [ebp-8h]

  v4 = a2[130];
  if ( *(_WORD *)(v4 + 8) )
  {
    if ( !a3
      || (*(_DWORD *)(v4 + 12) = sub_8090898(*(int **)v4, *(unsigned __int16 *)(v4 + 8)),
          result = v4,
          *(_DWORD *)(v4 + 12) < 0) )
    {
      result = sub_811B928(a1, a2);
    }
  }
  else
  {
    result = a2[130];
    *(_DWORD *)(v4 + 12) = -1;
  }
  return result;
}

//----- (0811BAF4) --------------------------------------------------------
_DWORD *__usercall sub_811BAF4@<eax>(long double a1@<st0>, int a2, int a3)
{
  _DWORD *result; // eax
  _DWORD *v4; // ST10_4
  _DWORD *i; // [esp+14h] [ebp-4h]

  result = *(_DWORD **)(a2 + 524);
  for ( i = *(_DWORD **)(a2 + 524); i; i = v4 )
  {
    v4 = *(_DWORD **)(i[130] + 4);
    sub_811BA8A(a1, i, a3);
    result = v4;
  }
  return result;
}

//----- (0811BB3A) --------------------------------------------------------
int __cdecl sub_811BB3A(int a1, int a2)
{
  int v2; // eax
  float *v3; // ST1C_4
  int result; // eax
  char v5; // [esp+20h] [ebp-78h]
  char v6; // [esp+50h] [ebp-48h]
  int v7; // [esp+74h] [ebp-24h]
  int v8; // [esp+88h] [ebp-10h]
  int *v9; // [esp+8Ch] [ebp-Ch]

  v9 = *(int **)(a1 + 520);
  v8 = *v9;
  if ( v9[3] < 0 )
  {
    sub_80A7146((float *)(v8 + 324), a2);
    result = sub_811D0FC((_DWORD *)(v8 + 312), (_DWORD *)(a2 + 36));
  }
  else
  {
    sub_80A7146((float *)(v8 + 324), (int)&v6);
    sub_811D0FC((_DWORD *)(v8 + 312), &v7);
    sub_811BFC4(v8, v9[3]);
    v2 = sub_80908D8((int *)v8);
    v3 = (float *)(32 * v9[3] + v2);
    sub_80A913C(v3, (float *)&v5);
    sub_80A358E((float *)&v5, (float *)&v6, (float *)a2);
    result = sub_80A50D2(v3 + 4, (float *)&v6, (float *)(a2 + 36));
  }
  return result;
}

//----- (0811BC46) --------------------------------------------------------
int __cdecl sub_811BC46(int a1, float *a2)
{
  int v2; // ST1C_4
  char v4; // [esp+20h] [ebp-38h]

  v2 = *(_DWORD *)(a1 + 520);
  sub_811BB3A(a1, (int)&v4);
  return sub_80A3C8E((float *)(v2 + 64), (float *)&v4, a2);
}

//----- (0811BC88) --------------------------------------------------------
int __cdecl sub_811BC88(int a1, int a2)
{
  int result; // eax
  float v3[12]; // [esp+10h] [ebp-A8h]
  char v4; // [esp+40h] [ebp-78h]
  char v5; // [esp+70h] [ebp-48h]
  int v6; // [esp+94h] [ebp-24h]
  int v7; // [esp+ACh] [ebp-Ch]

  sub_811BB3A(a1, (int)&v4);
  sub_80A7146((float *)(a1 + 324), (int)&v5);
  v7 = *(_DWORD *)(a1 + 520);
  if ( a2 )
  {
    sub_80A442E(&v4, v3);
    result = sub_80A358E((float *)&v5, v3, (float *)(v7 + 16));
  }
  else
  {
    sub_80A47DE((int)&v4, (int)v3);
    sub_811D0FC((_DWORD *)(a1 + 312), &v6);
    result = sub_80A3C8E((float *)&v5, v3, (float *)(v7 + 16));
  }
  return result;
}

//----- (0811BD52) --------------------------------------------------------
void __cdecl sub_811BD52(int a1, signed int a2)
{
  char v2; // [esp+20h] [ebp-78h]
  char v3; // [esp+50h] [ebp-48h]
  int v4; // [esp+74h] [ebp-24h]
  int v5; // [esp+8Ch] [ebp-Ch]

  sub_811BB3A(a1, (int)&v2);
  v5 = *(_DWORD *)(a1 + 520);
  if ( a2 == 1 )
  {
    sub_80A3C8E((float *)(v5 + 16), (float *)&v2, (float *)&v3);
    sub_811D0FC(&v4, (_DWORD *)(a1 + 312));
    *(float *)(a1 + 328) = sub_80A29F6((float *)&v3);
  }
  else if ( a2 > 1 )
  {
    if ( a2 == 2 )
    {
      sub_80A50D2((float *)(v5 + 52), (float *)&v2, (float *)&v4);
      sub_811D0FC(&v4, (_DWORD *)(a1 + 312));
    }
  }
  else if ( !a2 )
  {
    sub_80A3C8E((float *)(v5 + 16), (float *)&v2, (float *)&v3);
    sub_811D0FC(&v4, (_DWORD *)(a1 + 312));
    sub_80A71F4((int)&v3, a1 + 324);
  }
}

//----- (0811BE86) --------------------------------------------------------
int __cdecl sub_811BE86(_DWORD *a1)
{
  sub_811BD52((int)a1, 0);
  sub_811CF36(a1, a1 + 78);
  sub_811CF96(a1, a1 + 81);
  a1[3] = 1;
  a1[12] = 1;
  return sub_809A45E((int)a1);
}

//----- (0811BEEE) --------------------------------------------------------
int __cdecl sub_811BEEE(int *a1)
{
  return sub_8062B4C(*a1);
}

//----- (0811BF04) --------------------------------------------------------
int __cdecl sub_811BF04(int *a1, int a2)
{
  float v2; // ST04_4

  v2 = (long double)dword_859B5F4 * 0.001;
  return sub_8090776(a1, v2, a2);
}
// 859B5F4: using guessed type int dword_859B5F4;

//----- (0811BF30) --------------------------------------------------------
int *__cdecl sub_811BF30(int a1)
{
  int *result; // eax
  char s; // [esp+10h] [ebp-28h]
  void (__cdecl *v3)(int, char *); // [esp+2Ch] [ebp-Ch]

  memset(&s, 255, 0x10u);
  result = (int *)sub_80906EE((int *)a1, (int)&s);
  if ( !result )
  {
    sub_8090820((int *)a1, (int)&s);
    v3 = (void (__cdecl *)(int, char *))dword_816789C[10 * *(unsigned __int8 *)(a1 + 358)];
    if ( v3 )
      v3(a1, &s);
    result = sub_809084A((int *)a1, (int)&s);
  }
  return result;
}
// 816789C: using guessed type int dword_816789C[];

//----- (0811BFC4) --------------------------------------------------------
int *__cdecl sub_811BFC4(int a1, int a2)
{
  int *result; // eax
  char v3; // [esp+10h] [ebp-28h]
  void (__cdecl *v4)(int, char *); // [esp+2Ch] [ebp-Ch]

  result = (int *)sub_8090666((int *)a1, a2);
  if ( !result )
  {
    sub_80907EE((int *)a1, a2, (int)&v3);
    sub_8090820((int *)a1, (int)&v3);
    v4 = (void (__cdecl *)(int, char *))dword_816789C[10 * *(unsigned __int8 *)(a1 + 358)];
    if ( v4 )
      v4(a1, &v3);
    result = sub_809084A((int *)a1, (int)&v3);
  }
  return result;
}
// 816789C: using guessed type int dword_816789C[];

//----- (0811C056) --------------------------------------------------------
int __cdecl sub_811C056(int *a1, int a2)
{
  int v4; // [esp+10h] [ebp-8h]

  v4 = sub_8090898(a1, a2);
  if ( v4 < 0 )
    return 0;
  sub_811BFC4((int)a1, v4);
  return sub_80908D8(a1) + 32 * v4;
}

//----- (0811C0B2) --------------------------------------------------------
signed int __cdecl sub_811C0B2(int a1, int a2, float *a3)
{
  char v5; // [esp+20h] [ebp-78h]
  char v6; // [esp+50h] [ebp-48h]
  int v7; // [esp+74h] [ebp-24h]
  float *v8; // [esp+8Ch] [ebp-Ch]

  v8 = (float *)sub_811C056((int *)a1, a2);
  if ( !v8 )
    return 0;
  sub_80A7146((float *)(a1 + 324), (int)&v6);
  sub_811D0FC((_DWORD *)(a1 + 312), &v7);
  sub_80A913C(v8, (float *)&v5);
  sub_80A358E((float *)&v5, (float *)&v6, a3);
  sub_80A50D2(v8 + 4, (float *)&v6, a3 + 9);
  return 1;
}

//----- (0811C16A) --------------------------------------------------------
signed int __cdecl sub_811C16A(int a1, int a2, float *a3)
{
  char v5; // [esp+20h] [ebp-48h]
  int v6; // [esp+44h] [ebp-24h]
  int v7; // [esp+5Ch] [ebp-Ch]

  v7 = sub_811C056((int *)a1, a2);
  if ( !v7 )
    return 0;
  sub_80A7146((float *)(a1 + 324), (int)&v5);
  sub_811D0FC((_DWORD *)(a1 + 312), &v6);
  sub_80A50D2((float *)(v7 + 16), (float *)&v5, a3);
  return 1;
}

//----- (0811C1EE) --------------------------------------------------------
char *__cdecl sub_811C1EE(int a1, int a2, __int16 a3)
{
  __int16 v5; // [esp+4h] [ebp-4h]
  char *v6; // [esp+10h] [ebp+8h]

  if ( a1 )
    v6 = (char *)(a1 + 560);
  else
    v6 = (char *)&unk_8665480;
  while ( (unsigned int)v6 < 560 * *(_DWORD *)dword_859B40C + 140924032 )
  {
    if ( v6[252] )
    {
      v5 = *(_WORD *)&v6[a2];
      if ( v5 )
      {
        if ( v5 == a3 )
          return v6;
      }
    }
    v6 += 560;
  }
  return 0;
}

//----- (0811C272) --------------------------------------------------------
char *__cdecl sub_811C272(int a1, int a2, char *a3)
{
  char *v5; // [esp+14h] [ebp-4h]
  char *v6; // [esp+20h] [ebp+8h]

  if ( a1 )
    v6 = (char *)(a1 + 560);
  else
    v6 = (char *)&unk_8665480;
  while ( (unsigned int)v6 < 560 * *(_DWORD *)dword_859B40C + 140924032 )
  {
    if ( v6[252] )
    {
      v5 = *(char **)&v6[a2];
      if ( v5 )
      {
        if ( !I_stricmp(v5, a3) )
          return v6;
      }
    }
    v6 += 560;
  }
  return 0;
}

//----- (0811C2FA) --------------------------------------------------------
int __cdecl sub_811C2FA(unsigned __int16 a1)
{
  int v1; // eax
  int v4[33]; // [esp+30h] [ebp-98h]
  int v5; // [esp+B4h] [ebp-14h]
  char *v6; // [esp+B8h] [ebp-10h]
  unsigned __int16 v7; // [esp+BEh] [ebp-Ah]

  v7 = a1;
  v6 = 0;
  v5 = 0;
  if ( !a1 )
    return 0;
  do
  {
    v6 = sub_811C1EE((int)v6, 364, v7);
    if ( !v6 )
      break;
    v4[v5++] = (int)v6;
  }
  while ( v5 != 32 );
  if ( v5 )
    return v4[rand() % v5];
  v1 = sub_8078896(v7);
  Com_Printf("G_PickTarget: target %s not found\n", v1);
  return 0;
}
// 811C2FA: using guessed type int var_98[33];

//----- (0811C3CC) --------------------------------------------------------
int __cdecl sub_811C3CC(int a1)
{
  int result; // eax

  *(_DWORD *)(a1 + 556) = 0;
  *(_BYTE *)(a1 + 252) = 1;
  sub_8079790((_WORD *)(a1 + 360), (unsigned __int16)word_87A22CA);
  *(_DWORD *)a1 = -1963413621 * ((a1 - (signed int)&unk_8665480) >> 4);
  *(_DWORD *)(a1 + 336) = 1023;
  *(_DWORD *)(a1 + 376) = 0;
  result = a1;
  *(_DWORD *)(a1 + 380) = 0;
  return result;
}
// 87A22CA: using guessed type __int16 word_87A22CA;

//----- (0811C444) --------------------------------------------------------
int sub_811C444()
{
  int result; // eax
  void *v1; // [esp+30h] [ebp-8h]
  int i; // [esp+34h] [ebp-4h]

  for ( i = 0; ; ++i )
  {
    result = i;
    if ( i >= *(_DWORD *)dword_859B40C )
      break;
    if ( word_86655E8[280 * i] )
      v1 = (void *)sub_8078896((unsigned __int16)word_86655E8[280 * i]);
    else
      v1 = &unk_8157C43;
    Com_Printf(
      "%4i: '%s', origin: %f %f %f\n",
      i,
      v1,
      flt_86655B8[140 * i],
      flt_86655BC[140 * i],
      flt_86655C0[140 * i]);
  }
  return result;
}
// 86655B8: using guessed type float flt_86655B8[];
// 86655BC: using guessed type float flt_86655BC[];
// 86655C0: using guessed type float flt_86655C0[];
// 86655E8: using guessed type __int16 word_86655E8[];

//----- (0811C4F8) --------------------------------------------------------
_BOOL4 __cdecl sub_811C4F8(int a1)
{
  _BOOL4 v2; // [esp+0h] [ebp-4h]

  if ( a1 )
    v2 = dword_859B5EC - *(_DWORD *)(a1 + 376) > 499 || *(_DWORD *)dword_859B40C > 1021;
  else
    v2 = 0;
  return v2;
}

//----- (0811C546) --------------------------------------------------------
int sub_811C546()
{
  int v1; // [esp+14h] [ebp-4h]

  v1 = dword_859B410;
  if ( (unsigned __int8)sub_811C4F8(dword_859B410) )
  {
    dword_859B410 = *(_DWORD *)(dword_859B410 + 556);
    if ( !dword_859B410 )
      dword_859B414 = 0;
    *(_DWORD *)(v1 + 556) = 0;
  }
  else
  {
    if ( *(_DWORD *)dword_859B40C == 1022 )
    {
      sub_811C444();
      Com_Error(1, &byte_8157C61);
    }
    v1 = dword_859B404 + 560 * (*(_DWORD *)dword_859B40C)++;
    sub_8090498(dword_859B404, *(int *)dword_859B40C, 560, dword_859B400, 10404);
  }
  sub_811C3CC(v1);
  return v1;
}
// 859B400: using guessed type int dword_859B400;
// 859B404: using guessed type int dword_859B404;
// 859B410: using guessed type int dword_859B410;
// 859B414: using guessed type int dword_859B414;

//----- (0811C614) --------------------------------------------------------
_DWORD *__usercall sub_811C614@<eax>(long double a1@<st0>)
{
  int v2; // [esp+10h] [ebp-8h]
  _DWORD *s; // [esp+14h] [ebp-4h]

  s = (_DWORD *)(dword_859B404 + 560 * dword_859D1E4 + 35840);
  dword_859D1E4 = (dword_859D1E4 + 1) % 8;
  v2 = s[2] & 2 ^ 2;
  if ( *((_BYTE *)s + 252) )
    sub_811C9C0(a1, s);
  sub_811C3CC((int)s);
  s[2] = v2;
  return s;
}
// 859B404: using guessed type int dword_859B404;
// 859D1E4: using guessed type int dword_859D1E4;

//----- (0811C6AE) --------------------------------------------------------
int *__cdecl sub_811C6AE(int *a1)
{
  int *result; // eax
  _DWORD *v2; // [esp+0h] [ebp-10h]
  int v3; // [esp+4h] [ebp-Ch]
  int i; // [esp+8h] [ebp-8h]
  int v5; // [esp+Ch] [ebp-4h]

  v3 = *a1;
  for ( i = 0; ; ++i )
  {
    result = (int *)i;
    if ( i >= *(_DWORD *)dword_859B40C )
      break;
    v5 = (int)&unk_8665480 + 560 * i;
    if ( *(_BYTE *)(v5 + 252) )
    {
      if ( *(int **)(v5 + 396) == a1 )
        *(_DWORD *)(v5 + 396) = 0;
      if ( *(_DWORD *)(v5 + 336) == v3 )
      {
        *(_DWORD *)(v5 + 336) = 1023;
        if ( *(_DWORD *)(v5 + 4) == 9 )
          *(_BYTE *)(v5 + 354) = 0;
      }
      if ( *(_DWORD *)(v5 + 124) == v3 )
        *(_DWORD *)(v5 + 124) = 1023;
    }
  }
  for ( i = 0; i <= 63; ++i )
  {
    v5 = (int)&unk_8665480 + 560 * i;
    if ( *(_BYTE *)(v5 + 252) )
    {
      v2 = *(_DWORD **)(v5 + 344);
      if ( (int *)v2[2571] == a1 )
        v2[2571] = 0;
      if ( v2[2572] == v3 )
        v2[2572] = 1023;
      if ( v2[360] == v3 )
        v2[360] = 1023;
    }
    result = &i;
  }
  for ( i = 0; i <= 31; ++i )
  {
    if ( (int *)dword_859D158[i] == a1 )
      dword_859D158[i] = 0;
    result = &i;
  }
  return result;
}

//----- (0811C830) --------------------------------------------------------
signed int __cdecl sub_811C830(_DWORD *a1)
{
  signed int i; // [esp+4h] [ebp-8h]

  for ( i = 0; i <= 7; ++i )
  {
    if ( dword_879D83C[306 * i] == *a1 )
      return i;
  }
  return 0;
}

//----- (0811C87C) --------------------------------------------------------
int __usercall sub_811C87C@<eax>(long double a1@<st0>)
{
  int v3; // [esp+1Ch] [ebp-2Ch]
  float v4[4]; // [esp+20h] [ebp-28h]
  float v5; // [esp+30h] [ebp-18h]
  float v6; // [esp+34h] [ebp-14h]
  void *s; // [esp+38h] [ebp-10h]
  int i; // [esp+3Ch] [ebp-Ch]

  v5 = -1.0;
  v3 = 0;
  s = sub_811C1EE(0, 360, word_87A22D2);
  sub_811D0FC((_DWORD *)s + 6, v4);
  for ( i = 0; i <= 7; ++i )
  {
    if ( dword_879D83C[306 * i] == -1 )
      return i;
    s = (void *)(dword_859B404 + 560 * dword_879D83C[306 * i]);
    v6 = sub_80A1DB2((float *)s + 78, v4);
    a1 = v5;
    if ( v6 > (long double)v5 )
    {
      v5 = v6;
      v3 = i;
    }
  }
  s = (void *)(dword_859B404 + 560 * dword_879D83C[306 * v3]);
  sub_811C9C0(a1, s);
  dword_879D83C[306 * v3] = -1;
  return v3;
}
// 859B404: using guessed type int dword_859B404;
// 87A22D2: using guessed type __int16 word_87A22D2;

//----- (0811C996) --------------------------------------------------------
int __cdecl sub_811C996(_DWORD *a1)
{
  int result; // eax

  result = 306 * sub_811C830(a1);
  dword_879D83C[result] = -1;
  return result * 4;
}

//----- (0811C9C0) --------------------------------------------------------
int __usercall sub_811C9C0@<eax>(long double a1@<st0>, void *s)
{
  int result; // eax
  _DWORD *v3; // [esp+10h] [ebp-8h]
  int v4; // [esp+14h] [ebp-4h]

  sub_811B928(a1, s);
  while ( *((_DWORD *)s + 131) )
    sub_811B928(a1, *((_DWORD **)s + 131));
  sub_809A3BA((int)s);
  v3 = (_DWORD *)sub_80909B0((int *)s);
  if ( v3 )
    sub_80BFA1E(v3);
  sub_8062B4C(*(_DWORD *)s);
  sub_811C6AE((int *)s);
  if ( *((_DWORD *)s + 87) )
    sub_8109E54((int)s);
  if ( *((_DWORD *)s + 1) == 2 )
    sub_811C996(s);
  sub_8118C98((int *)s);
  v4 = *((_DWORD *)s + 138);
  memset(s, 0, 0x230u);
  *((_DWORD *)s + 94) = dword_859B5EC;
  if ( -1963413621 * ((_DWORD)((_DWORD)s - dword_859B404) >> 4) > 71 )
  {
    if ( dword_859B414 )
      *(_DWORD *)(dword_859B414 + 556) = s;
    else
      dword_859B410 = (int)s;
    dword_859B414 = (int)s;
    *((_DWORD *)s + 139) = 0;
  }
  result = v4 + 1;
  *((_DWORD *)s + 138) = v4 + 1;
  return result;
}
// 859B404: using guessed type int dword_859B404;
// 859B410: using guessed type int dword_859B410;
// 859B414: using guessed type int dword_859B414;

//----- (0811CB00) --------------------------------------------------------
int __cdecl sub_811CB00(int *a1)
{
  unsigned __int16 v1; // ST16_2

  v1 = sub_8118DF4(a1, dword_879D82C, 0);
  return sub_8083B8E(v1);
}
// 879D82C: using guessed type int dword_879D82C;

//----- (0811CB34) --------------------------------------------------------
int __cdecl sub_811CB34(_DWORD *a1, int a2)
{
  int v2; // eax
  float v4; // [esp+20h] [ebp-28h]
  float v5; // [esp+24h] [ebp-24h]
  float v6; // [esp+28h] [ebp-20h]
  int v7; // [esp+3Ch] [ebp-Ch]

  v2 = sub_811C546();
  v7 = v2;
  *(_DWORD *)(v2 + 4) = a2 + 10;
  sub_8079790((_WORD *)(v7 + 360), (unsigned __int16)word_87A22F0);
  *(_DWORD *)(v7 + 376) = dword_859B5EC;
  *(_DWORD *)(v7 + 340) = dword_859B5EC;
  *(_DWORD *)(v7 + 380) = 1;
  sub_811D0FC(a1, &v4);
  v4 = (long double)(signed int)v4;
  v5 = (long double)(signed int)v5;
  v6 = (long double)(signed int)v6;
  sub_811CF36((_DWORD *)v7, &v4);
  sub_809A45E(v7);
  return v7;
}
// 87A22F0: using guessed type __int16 word_87A22F0;

//----- (0811CC24) --------------------------------------------------------
int __cdecl sub_811CC24(int a1)
{
  int result; // eax
  char v2; // [esp+30h] [ebp-1048h]
  char v3; // [esp+40h] [ebp-1038h]
  int v4; // [esp+5Ch] [ebp-101Ch]
  int v5[1026]; // [esp+60h] [ebp-1018h]
  int v6; // [esp+1068h] [ebp-10h]
  int i; // [esp+106Ch] [ebp-Ch]

  sub_811D12C((float *)(*(_DWORD *)(a1 + 344) + 20), (float *)(a1 + 260), (float *)&v3);
  sub_811D12C((float *)(*(_DWORD *)(a1 + 344) + 20), (float *)(a1 + 272), (float *)&v2);
  v6 = sub_805E782((int)&v3, (int)&v2, (int)v5, 1024, 0x2000000);
  for ( i = 0; ; ++i )
  {
    result = i;
    if ( i >= v6 )
      break;
    v4 = (int)&unk_8665480 + 560 * v5[i];
    if ( *(_DWORD *)(v4 + 344) )
    {
      if ( *(_BYTE *)(v4 + 240) )
        sub_80FF7C8((int *)v4, (int *)a1, (int *)a1, 0, 0, 100000, 16, 0xAu, 0, 0);
    }
  }
  return result;
}
// 811CC24: using guessed type int var_1018[1026];

//----- (0811CD6C) --------------------------------------------------------
int __cdecl sub_811CD6C(int a1, int a2, unsigned __int8 a3)
{
  int result; // eax

  result = a1;
  if ( *(_DWORD *)(a1 + 344) )
    result = sub_80DD554(a2, a3, *(_DWORD *)(a1 + 344));
  return result;
}

//----- (0811CDA2) --------------------------------------------------------
int __cdecl sub_811CDA2(_DWORD *a1, int a2, int a3)
{
  int result; // eax

  if ( a1[86] )
  {
    *(_DWORD *)(a1[86] + 4 * (*(_DWORD *)(a1[86] + 164) & 3) + 168) = a2;
    *(_DWORD *)(a1[86] + 4 * ((*(_DWORD *)(a1[86] + 164))++ & 3) + 184) = a3;
  }
  else
  {
    a1[(a1[41] & 3) + 42] = a2;
    a1[(a1[41]++ & 3) + 46] = a3;
  }
  a1[94] = dword_859B5EC;
  result = dword_859B5EC;
  a1[85] = dword_859B5EC;
  return result;
}

//----- (0811CE66) --------------------------------------------------------
int __cdecl sub_811CE66(_DWORD *a1, int a2)
{
  int result; // eax
  int v3; // edx

  result = a2;
  if ( (_BYTE)a2 )
  {
    v3 = sub_811CB34(a1, 179);
    result = (unsigned __int8)a2;
    *(_DWORD *)(v3 + 160) = (unsigned __int8)a2;
  }
  return result;
}

//----- (0811CE9E) --------------------------------------------------------
int __cdecl sub_811CE9E(_DWORD *a1, int a2)
{
  int result; // eax

  result = a2;
  if ( (_BYTE)a2 )
    result = sub_811CDA2(a1, 179, (unsigned __int8)a2);
  return result;
}

//----- (0811CEFE) --------------------------------------------------------
int __cdecl sub_811CEFE(int a1, char **a2)
{
  unsigned __int8 v2; // al

  v2 = sub_811B1D8(*a2);
  sub_811CE9E((_DWORD *)(560 * a1 + 140924032), v2);
  return 0;
}

//----- (0811CF36) --------------------------------------------------------
int __cdecl sub_811CF36(_DWORD *a1, _DWORD *a2)
{
  sub_811D0FC(a2, a1 + 6);
  a1[3] = 0;
  a1[4] = 0;
  a1[5] = 0;
  sub_811D0D2(a1 + 9);
  return sub_811D0FC(a2, a1 + 78);
}

//----- (0811CF96) --------------------------------------------------------
int __cdecl sub_811CF96(_DWORD *a1, _DWORD *a2)
{
  sub_811D0FC(a2, a1 + 15);
  a1[12] = 0;
  a1[13] = 0;
  a1[14] = 0;
  sub_811D0D2(a1 + 18);
  return sub_811D0FC(a2, a1 + 81);
}

//----- (0811CFF6) --------------------------------------------------------
_BOOL4 __cdecl sub_811CFF6(int a1, int a2)
{
  char v3; // [esp+20h] [ebp-38h]
  float v4; // [esp+3Ch] [ebp-1Ch]
  char v5; // [esp+40h] [ebp-18h]

  sub_80A2EC2((float *)(a1 + 324), (int)&v3, 0, 0);
  sub_811D170((float *)(a2 + 312), (float *)(a1 + 312), (float *)&v5);
  sub_80A20C0((float *)&v5);
  v4 = sub_811D1B4((float *)&v5, (float *)&v3);
  return v4 > 0.0;
}

//----- (0811D098) --------------------------------------------------------
int __cdecl sub_811D098(int a1, char *s)
{
  int result; // eax

  sub_8079790((_WORD *)a1, 0);
  result = sub_80792C4(s, 0);
  *(_WORD *)a1 = result;
  return result;
}

//----- (0811D0D2) --------------------------------------------------------
int __cdecl sub_811D0D2(_DWORD *a1)
{
  int result; // eax

  *a1 = 0;
  a1[1] = 0;
  result = 0;
  a1[2] = 0;
  return result;
}

//----- (0811D0FC) --------------------------------------------------------
int __cdecl sub_811D0FC(_DWORD *a1, _DWORD *a2)
{
  int result; // eax

  *a2 = *a1;
  a2[1] = a1[1];
  result = a1[2];
  a2[2] = result;
  return result;
}

//----- (0811D12C) --------------------------------------------------------
int __cdecl sub_811D12C(float *a1, float *a2, float *a3)
{
  int result; // eax

  *a3 = *a1 + *a2;
  a3[1] = a1[1] + a2[1];
  result = (int)(a1 + 2);
  a3[2] = a1[2] + a2[2];
  return result;
}

//----- (0811D170) --------------------------------------------------------
int __cdecl sub_811D170(float *a1, float *a2, float *a3)
{
  int result; // eax

  *a3 = *a1 - *a2;
  a3[1] = a1[1] - a2[1];
  result = (int)(a1 + 2);
  a3[2] = a1[2] - a2[2];
  return result;
}

//----- (0811D1B4) --------------------------------------------------------
long double __cdecl sub_811D1B4(float *a1, float *a2)
{
  return *a1 * *a2 + a1[1] * a2[1] + a1[2] * a2[2];
}

//----- (0811D220) --------------------------------------------------------
int __cdecl sub_811D220(int a1, int a2, int a3, float a4, float a5, float a6, void *s, int a8)
{
  float v8; // ST04_4
  float v9; // ST04_4
  signed int v11; // [esp+20h] [ebp-28h]
  signed int i; // [esp+2Ch] [ebp-1Ch]
  int v14; // [esp+30h] [ebp-18h]

  if ( a5 > 0.0 || a6 > 0.0 )
    v11 = 5;
  else
    v11 = 1;
  for ( i = 0; i < v11; ++i )
  {
    sub_811EADE(a2 + 36, a4, a2, (int)&v14);
    v8 = a5 * flt_8157C80[2 * i];
    sub_811EADE((int)&v14, v8, a2 + 12, (int)&v14);
    v9 = a6 * flt_8157C84[2 * i];
    sub_811EADE((int)&v14, v9, a2 + 24, (int)&v14);
    sub_8108134(s, a2 + 36, (int)&v14, *(_DWORD *)a1, 41953329, (int)&unk_816778C);
    sub_80DEB7A(a2 + 36, (int)&v14, *(float *)s, a8);
    if ( !i )
      sub_811AA18((int *)a1, (_DWORD *)(a2 + 36), (float *)a8, a3, 7);
    if ( !(*((_DWORD *)s + 4) & 0x10) && *(float *)s != 1.0 )
      return 1;
  }
  return 0;
}
// 8157C80: using guessed type float flt_8157C80[];

//----- (0811D3B4) --------------------------------------------------------
__int16 __cdecl sub_811D3B4(int a1, int a2, float a3, float a4, float a5)
{
  int v5; // eax
  int v6; // ebx
  int v7; // eax
  int v9; // [esp+30h] [ebp-58h]
  int v10; // [esp+44h] [ebp-44h]
  int v11; // [esp+48h] [ebp-40h]
  int v12; // [esp+4Ch] [ebp-3Ch]
  char s; // [esp+50h] [ebp-38h]
  int v14; // [esp+54h] [ebp-34h]
  unsigned __int16 v15; // [esp+6Ch] [ebp-1Ch]
  unsigned __int16 v16; // [esp+70h] [ebp-18h]

  v10 = *(_DWORD *)(sub_80E9270(*(_DWORD *)(a1 + 200)) + 500);
  LOWORD(v5) = sub_811D220(a1, a2, v10, a3, a4, a5, &s, (int)&v9);
  if ( (_BYTE)v5 )
  {
    v12 = (int)&unk_8665480 + 560 * v15;
    if ( *(_DWORD *)(v12 + 344) )
      v11 = sub_811CB34(&v9, 173);
    else
      v11 = sub_811CB34(&v9, 174);
    *(_DWORD *)(v11 + 116) = v15;
    v6 = v11;
    *(_DWORD *)(v6 + 160) = (unsigned __int8)sub_80A1C2A((float *)&v14);
    v5 = *(_DWORD *)(a1 + 200);
    *(_DWORD *)(v11 + 200) = v5;
    if ( v15 != 1022 )
    {
      LOWORD(v5) = v12;
      if ( *(_BYTE *)(v12 + 353) )
      {
        v7 = rand();
        LOWORD(v5) = sub_80FF7C8((int *)v12, (int *)a1, (int *)a1, (float *)a2, &v9, v10 + v7 % 5, 0, 7u, v16, 0);
      }
    }
  }
  return v5;
}

//----- (0811D53A) --------------------------------------------------------
int *__cdecl sub_811D53A(int a1, int a2)
{
  int v2; // ebx
  int v3; // ebx
  int *result; // eax
  int i; // [esp+Ch] [ebp-Ch]

  for ( i = 0; i <= 2; ++i )
  {
    if ( *(float *)(a1 + 4 * i) < (long double)*(float *)(a2 + 4 * i) )
    {
      v3 = 4 * i;
      *(float *)(a1 + v3) = ceil(*(float *)(a1 + 4 * i));
    }
    else
    {
      v2 = 4 * i;
      *(float *)(a1 + v2) = floor(*(float *)(a1 + 4 * i));
    }
    result = &i;
  }
  return result;
}

//----- (0811D5E0) --------------------------------------------------------
float *__cdecl sub_811D5E0(float *a1, float *a2)
{
  float v2; // ST00_4
  float *result; // eax
  int v4; // [esp+18h] [ebp-10h]
  int v5; // [esp+1Ch] [ebp-Ch]
  float v6; // [esp+20h] [ebp-8h]
  float v7; // [esp+24h] [ebp-4h]

  v7 = sub_80A1410() * 360.0;
  v6 = sub_80A1410();
  v2 = v7 * 0.0174532925199433;
  sub_811EA04(v2, (int)&v5, (int)&v4);
  *a1 = v6 * *(float *)&v4;
  result = a2;
  *a2 = v6 * *(float *)&v5;
  return result;
}

//----- (0811D638) --------------------------------------------------------
int __cdecl sub_811D638(float a1, int a2, int a3, float a4)
{
  float v4; // ST18_4
  float v5; // ST1C_4
  float v7; // [esp+20h] [ebp-8h]
  float v8; // [esp+24h] [ebp-4h]

  v4 = tan(a1 * 0.0174532925199433);
  v5 = v4 * a4;
  sub_811D5E0(&v8, &v7);
  v8 = v8 * v5;
  v7 = v7 * v5;
  sub_811EADE(a3 + 36, a4, a3, a2);
  sub_811EADE(a2, v8, a3 + 12, a2);
  return sub_811EADE(a2, v7, a3 + 24, a2);
}

//----- (0811D6EC) --------------------------------------------------------
int __cdecl sub_811D6EC(int a1, float a2)
{
  float v2; // ST1C_4
  float v3; // ST04_4
  float v4; // ST00_4
  float v6; // [esp+20h] [ebp-8h]

  if ( *(float *)(*(_DWORD *)(a1 + 60) + 1432) > (long double)a2 )
    return *(_DWORD *)(*(_DWORD *)(a1 + 60) + 492);
  if ( *(float *)(*(_DWORD *)(a1 + 60) + 1436) <= (long double)a2 )
    return *(_DWORD *)(*(_DWORD *)(a1 + 60) + 1424);
  v6 = *(float *)(*(_DWORD *)(a1 + 60) + 1436) - *(float *)(*(_DWORD *)(a1 + 60) + 1432);
  if ( v6 == 0.0 )
    return *(_DWORD *)(*(_DWORD *)(a1 + 60) + 492);
  v2 = (a2 - *(float *)(*(_DWORD *)(a1 + 60) + 1432)) / v6;
  v3 = (long double)*(signed int *)(*(_DWORD *)(a1 + 60) + 1424);
  v4 = (long double)*(signed int *)(*(_DWORD *)(a1 + 60) + 492);
  return (signed int)sub_811E9EE(v4, v3, v2);
}

//----- (0811D7E6) --------------------------------------------------------
int __cdecl sub_811D7E6(int a1, void *s)
{
  int result; // eax
  char src; // [esp+20h] [ebp-28h]
  int v4; // [esp+38h] [ebp-10h]
  int i; // [esp+3Ch] [ebp-Ch]

  result = dword_8793E4C;
  if ( *(_BYTE *)(dword_8793E4C + 8) )
  {
    memset(s, 0, 0x340u);
    result = 1000 / *(_DWORD *)(dword_848B1B4 + 8);
    if ( dword_859B5EC - a1 > result )
    {
      for ( i = 0; ; ++i )
      {
        result = i;
        if ( i >= dword_859B5E4 )
          break;
        if ( *(_DWORD *)(dword_859B400 + 10404 * i + 9924) == 2 && !*(_DWORD *)(dword_859B400 + 10404 * i + 9896) )
        {
          if ( (unsigned __int8)sub_8097BD0(i, a1, (int)&src) )
          {
            v4 = a1;
            memcpy((char *)s + 12 * i, (const void *)(560 * i + 140924344), 0xCu);
            sub_809A3BA(560 * i + 140924032);
            memcpy((void *)(560 * i + 140924344), &src, 0xCu);
            sub_809A45E(560 * i + 140924032);
            *((_BYTE *)s + i + 768) = 1;
          }
        }
      }
    }
  }
  return result;
}
// 848B1B4: using guessed type int dword_848B1B4;
// 859B400: using guessed type int dword_859B400;
// 859B5E4: using guessed type int dword_859B5E4;
// 8793E4C: using guessed type int dword_8793E4C;

//----- (0811D95C) --------------------------------------------------------
int __cdecl sub_811D95C(int a1)
{
  int result; // eax
  int i; // [esp+14h] [ebp-4h]

  result = dword_8793E4C;
  if ( *(_BYTE *)(dword_8793E4C + 8) )
  {
    for ( i = 0; ; ++i )
    {
      result = i;
      if ( i >= dword_859B5E4 )
        break;
      if ( *(_BYTE *)(i + a1 + 768) )
      {
        sub_809A3BA(560 * i + 140924032);
        memcpy((void *)(560 * i + 140924344), (const void *)(a1 + 12 * i), 0xCu);
        sub_809A45E(560 * i + 140924032);
      }
    }
  }
  return result;
}
// 859B5E4: using guessed type int dword_859B5E4;
// 8793E4C: using guessed type int dword_8793E4C;

//----- (0811DA00) --------------------------------------------------------
void __cdecl sub_811DA00(int *a1, int *a2, float *a3, float *a4, float a5, signed int a6, int a7, _DWORD *a8, int a9)
{
  float v9; // ST70_4
  int v10; // eax
  int v11; // ebx
  float v12; // ST14_4
  float v13; // [esp+3Ch] [ebp-CCh]
  float v14; // [esp+4Ch] [ebp-BCh]
  signed int v15; // [esp+50h] [ebp-B8h]
  int v16; // [esp+70h] [ebp-98h]
  int v17; // [esp+8Ch] [ebp-7Ch]
  int v18; // [esp+90h] [ebp-78h]
  int v19; // [esp+A0h] [ebp-68h]
  int v20; // [esp+A4h] [ebp-64h]
  int v21; // [esp+A8h] [ebp-60h]
  float v22; // [esp+ACh] [ebp-5Ch]
  char v23; // [esp+B0h] [ebp-58h]
  int v24; // [esp+C8h] [ebp-40h]
  int v25; // [esp+CCh] [ebp-3Ch]
  float s; // [esp+D0h] [ebp-38h]
  int v27; // [esp+D4h] [ebp-34h]
  int v28; // [esp+E0h] [ebp-28h]
  int v29; // [esp+E4h] [ebp-24h]
  unsigned __int16 v30; // [esp+ECh] [ebp-1Ch]
  unsigned __int16 v31; // [esp+F0h] [ebp-18h]

  v20 = 0;
  if ( a6 <= 12 )
  {
    if ( *(_DWORD *)(*(_DWORD *)(a7 + 60) + 796) )
    {
      v19 = 2;
      v20 = 32;
    }
    else
    {
      v19 = 1;
    }
    if ( *(_DWORD *)(*(_DWORD *)(a7 + 60) + 800) )
      v20 |= 2u;
    if ( *(_DWORD *)(*(_DWORD *)(a7 + 60) + 796) )
      sub_8108134(&s, (int)a3, (int)a4, *a1, 41953329, (int)&unk_816779F);
    else
      sub_8108134(&s, (int)a3, (int)a4, *a1, 41953329, (int)&unk_816778C);
    sub_80DEB7A((int)a3, (int)a4, s, (int)&v18);
    sub_811AA18(a2, a3, (float *)&v18, *(_DWORD *)(*(_DWORD *)(a7 + 60) + 492), v19);
    v24 = (int)&unk_8665480 + 560 * v30;
    sub_811EA62(a4, a3, (float *)&v16);
    sub_80A20C0((float *)&v16);
    v9 = sub_811EB32((float *)&v16, (float *)&v27) * -2.0;
    sub_811EADE((int)&v16, v9, (int)&v27, (int)&v16);
    if ( !(v28 & 4) && !*(_DWORD *)(v24 + 344) && s < 1.0 )
    {
      if ( *(_DWORD *)(*(_DWORD *)(a7 + 60) + 124) == 3 )
      {
        v17 = 181;
      }
      else if ( *(_DWORD *)(*(_DWORD *)(a7 + 60) + 796) )
      {
        v17 = 183;
      }
      else
      {
        v17 = 182;
      }
      if ( *(_DWORD *)(*(_DWORD *)(a7 + 60) + 796) )
        v10 = sub_811CB34(&v18, 183);
      else
        v10 = sub_811CB34(&v18, 182);
      v25 = v10;
      *(_DWORD *)(v10 + 160) = (unsigned __int8)sub_80A1C2A((float *)&v27);
      v11 = v25;
      *(_DWORD *)(v11 + 216) = (unsigned __int8)sub_80A1C2A((float *)&v16);
      if ( *(_DWORD *)(v24 + 4) == 2 )
        v15 = 7;
      else
        v15 = (unsigned __int8)((v28 & 0x1F00000) >> 20);
      *(_DWORD *)(v25 + 136) = v15;
      *(_DWORD *)(v25 + 116) = *a8;
    }
    if ( v29 & 0x10 )
    {
      sub_811EA62(a4, a3, (float *)&v16);
      sub_80A20C0((float *)&v16);
      v13 = sub_811EB32((float *)&v27, (float *)&v16);
      if ( COERCE_FLOAT(LODWORD(v13) ^ 0x80000000) < 0.125 )
        v14 = 0.0;
      else
        v14 = 0.25 / COERCE_FLOAT(LODWORD(v13) ^ 0x80000000);
      sub_811EADE((int)&v18, v14, (int)&v16, (int)a3);
      sub_811DA00(a1, (char)a2, a3, a4, LODWORD(a5), a6 + 1, a7, a8, a9);
    }
    else if ( *(_BYTE *)(v24 + 353) )
    {
      if ( (int *)v24 != a2 )
      {
        sub_811EA62(a3, (float *)&v18, (float *)&v23);
        v22 = sub_811EB66(&v23);
        v21 = (signed int)((long double)sub_811D6EC(a7, v22) * a5);
        sub_80FF7C8((int *)v24, a2, a2, (float *)a7, &v18, v21, v20, v19, v31, dword_859B5EC - a9);
        if ( *(_DWORD *)(v24 + 344) )
        {
          if ( v20 & 0x20 && (Dvar_GetInt("scr_friendlyfire") || !sub_8119C40(v24, (int)a2)) )
          {
            v12 = a5 * 0.5;
            sub_811DA00(v24, (char)a2, &v18, a4, LODWORD(v12), a6 + 1, a7, a8, a9);
          }
        }
      }
    }
  }
  else
  {
    Com_DPrintf("Bullet_Fire_Extended: Too many resursions, bullet aborted\n");
  }
}
// 811EB66: using guessed type double __cdecl sub_811EB66(_DWORD);

//----- (0811DF44) --------------------------------------------------------
int __cdecl sub_811DF44(int a1, int a2, int a3, int a4, float a5)
{
  int result; // eax
  int i; // [esp+3Ch] [ebp-2Ch]
  float v7[4]; // [esp+40h] [ebp-28h]
  int v8; // [esp+50h] [ebp-18h]

  sub_811EA32((_DWORD *)(a3 + 36), v7);
  for ( i = 0; ; ++i )
  {
    result = i;
    if ( i >= *(_DWORD *)(*(_DWORD *)(a3 + 60) + 476) )
      break;
    sub_811D638(a5, (int)&v8, a3, *(float *)(*(_DWORD *)(a3 + 60) + 1436));
    sub_811DA00((int *)a1, (int *)a2, v7, (float *)&v8, 1.0, 0, a3, (_DWORD *)a1, a4);
  }
  return result;
}

//----- (0811DFF4) --------------------------------------------------------
int __cdecl sub_811DFF4(int a1, float a2, int a3, int a4, int a5)
{
  char s; // [esp+30h] [ebp-358h]
  int v7; // [esp+370h] [ebp-18h]

  sub_811D7E6(a5, &s);
  if ( *(_DWORD *)(*(_DWORD *)(a3 + 60) + 124) == 3 )
  {
    sub_811DF44(a4, a1, a3, a5, a2);
  }
  else
  {
    sub_811D638(a2, (int)&v7, a3, 8192.0);
    sub_811DA00((int *)a4, (int *)a1, (float *)(a3 + 36), (float *)&v7, 1.0, 0, a3, (_DWORD *)a4, a5);
  }
  return sub_811D95C((int)&s);
}

//----- (0811E0C2) --------------------------------------------------------
int __cdecl sub_811E0C2(_DWORD *a1, int a2, int a3)
{
  float v3; // ST04_4
  float v4; // ST2C_4
  int v6; // [esp+30h] [ebp-28h]
  float v7; // [esp+38h] [ebp-20h]
  int v8; // [esp+4Ch] [ebp-Ch]

  v3 = (long double)*(signed int *)(*(_DWORD *)(a3 + 60) + 900);
  sub_811EAA6(a3, v3, (int)&v6);
  v7 = (long double)*(signed int *)(*(_DWORD *)(a3 + 60) + 904) + v7;
  v8 = sub_810C1F6(a1, (_DWORD *)(a3 + 36), (float *)&v6, a2, *(_DWORD *)(*(_DWORD *)(a3 + 60) + 584));
  sub_80A20C0((float *)&v6);
  v4 = sub_811EB32((float *)(a1[86] + 32), (float *)&v6);
  sub_811EADE(v8 + 36, v4, (int)&v6, v8 + 36);
  return v8;
}

//----- (0811E18A) --------------------------------------------------------
int __cdecl sub_811E18A(int a1, float a2, int a3)
{
  float v3; // ST18_4
  int result; // eax
  char v5; // [esp+20h] [ebp-38h]
  int v6; // [esp+30h] [ebp-28h]
  float v7; // [esp+40h] [ebp-18h]
  float v8; // [esp+44h] [ebp-14h]
  float v9; // [esp+48h] [ebp-10h]
  int v10; // [esp+4Ch] [ebp-Ch]

  v10 = 1098907648;
  v3 = tan(a2 * 0.0174532925199433);
  v7 = v3 * 16.0;
  sub_811D5E0(&v9, &v8);
  v9 = v9 * v7;
  v8 = v8 * v7;
  sub_811EAA6(a3, 16.0, (int)&v6);
  sub_811EADE((int)&v6, v9, a3 + 12, (int)&v6);
  sub_811EADE((int)&v6, v8, a3 + 24, (int)&v6);
  sub_80A20C0((float *)&v6);
  sub_811EA32((_DWORD *)(a3 + 36), &v5);
  sub_810C4A0((_DWORD *)a1, &v5, (float *)&v6);
  result = a1;
  if ( *(_DWORD *)(a1 + 344) )
    result = sub_811EADE(*(_DWORD *)(a1 + 344) + 32, -64.0, a3, *(_DWORD *)(a1 + 344) + 32);
  return result;
}

//----- (0811E2C2) --------------------------------------------------------
_BOOL4 __cdecl sub_811E2C2(int a1, int a2)
{
  if ( !*(_BYTE *)(a1 + 353) )
    return 0;
  if ( a1 == a2 )
    return 0;
  if ( !*(_DWORD *)(a1 + 344) )
    return 0;
  if ( !*(_DWORD *)(a2 + 344) )
    return 0;
  if ( *(_DWORD *)(*(_DWORD *)(a1 + 344) + 4) <= 5 )
    return sub_8119C40(a1, a2) == 0;
  return 0;
}

//----- (0811E35C) --------------------------------------------------------
void __cdecl sub_811E35C(int a1, float *a2)
{
  int v2; // [esp+10h] [ebp-18h]
  int v3; // [esp+14h] [ebp-14h]

  sub_811EA32((_DWORD *)(*(_DWORD *)(a1 + 344) + 232), &v2);
  v2 = *(_DWORD *)(*(_DWORD *)(a1 + 344) + 10200);
  v3 = *(_DWORD *)(*(_DWORD *)(a1 + 344) + 10204);
  sub_80A2EC2((float *)&v2, (int)a2, a2 + 3, a2 + 6);
  sub_80F61BE(a1, a2 + 9);
}

//----- (0811E3E0) --------------------------------------------------------
int __cdecl sub_811E3E0(int a1, int a2)
{
  int result; // eax
  float v3; // [esp+20h] [ebp-58h]
  float v4; // [esp+24h] [ebp-54h]
  float v5; // [esp+28h] [ebp-50h]
  float v6; // [esp+2Ch] [ebp-4Ch]
  int v7; // [esp+30h] [ebp-48h]
  int v8; // [esp+6Ch] [ebp-Ch]

  if ( !(*(_DWORD *)(*(_DWORD *)(a1 + 344) + 160) & 0x300) || (result = a1, !*(_BYTE *)(a1 + 354)) )
  {
    v8 = sub_80E9270(*(_DWORD *)(a1 + 200));
    sub_811E35C(a1, (float *)&v7);
    v6 = *(float *)(*(_DWORD *)(a1 + 344) + 10256);
    sub_80EA198(*(_DWORD *)(a1 + 344), *(_DWORD *)(a1 + 200), &v4, &v3);
    if ( *(float *)(*(_DWORD *)(a1 + 344) + 220) == 1.0 )
      v5 = (v3 - *(float *)(v8 + 1212)) * v6 + *(float *)(v8 + 1212);
    else
      v5 = (v3 - v4) * v6 + v4;
    if ( *(_DWORD *)(v8 + 120) )
    {
      if ( *(_DWORD *)(v8 + 120) == 1 )
      {
        result = sub_811E0C2((_DWORD *)a1, *(_DWORD *)(a1 + 200), (int)&v7);
      }
      else
      {
        if ( *(_DWORD *)(v8 + 120) != 2 )
          Com_Error(1, &byte_8157D40, *(_DWORD *)(v8 + 120), *(_DWORD *)v8);
        result = sub_811E18A(a1, v5, (int)&v7);
      }
    }
    else
    {
      result = sub_811DFF4(a1, v5, (int)&v7, a1, a2);
    }
  }
  return result;
}

//----- (0811E56A) --------------------------------------------------------
int __cdecl sub_811E56A(int a1)
{
  return sub_811E3E0(a1, dword_859B5EC);
}

//----- (0811E586) --------------------------------------------------------
int __cdecl sub_811E586(_DWORD *a1)
{
  char v2; // [esp+10h] [ebp-48h]
  int v3; // [esp+4Ch] [ebp-Ch]

  v3 = sub_80E9270(*(_DWORD *)(a1[86] + 208));
  sub_811E35C((int)a1, (float *)&v2);
  return sub_811E0C2(a1, *(_DWORD *)(a1[86] + 208), (int)&v2);
}

//----- (0811E5E0) --------------------------------------------------------
__int16 __cdecl sub_811E5E0(int a1)
{
  __int16 result; // ax
  int v2; // [esp+20h] [ebp-48h]
  int v3; // [esp+2Ch] [ebp-3Ch]
  int v4; // [esp+38h] [ebp-30h]
  int v5; // [esp+44h] [ebp-24h]
  int v6; // [esp+5Ch] [ebp-Ch]

  if ( !(*(_DWORD *)(*(_DWORD *)(a1 + 344) + 160) & 0x300) || (result = a1, !*(_BYTE *)(a1 + 354)) )
  {
    v6 = sub_80E9270(*(_DWORD *)(a1 + 200));
    sub_80F61BE(a1, (float *)&v5);
    sub_80F63A0(a1, (int)&v2, (float *)&v3, (float *)&v4);
    result = sub_811D3B4(
               a1,
               (int)&v2,
               *(float *)(dword_8793E40 + 8),
               *(float *)(dword_8793E44 + 8),
               *(float *)(dword_8793E48 + 8));
  }
  return result;
}
// 8793E40: using guessed type int dword_8793E40;
// 8793E44: using guessed type int dword_8793E44;
// 8793E48: using guessed type int dword_8793E48;

//----- (0811E696) --------------------------------------------------------
signed int __cdecl sub_811E696(int a1, int a2)
{
  int v2; // ST20_4
  signed int v4; // [esp+10h] [ebp-18h]
  int v5; // [esp+18h] [ebp-10h]
  int i; // [esp+1Ch] [ebp-Ch]
  _DWORD *v7; // [esp+24h] [ebp-4h]

  if ( (unsigned __int8)sub_80D9E84(a1 + 1348, a2) )
    return 0;
  v7 = (_DWORD *)sub_80E9270(a2);
  if ( v7[31] == 7 )
    return 0;
  if ( v7[31] == 8 )
    return 0;
  sub_80D9EAA(a1 + 1348, a2);
  sub_80F0400(a1 + 1372, a2);
  if ( v7[31] == 9 )
    return 1;
  if ( v7[33] )
  {
    if ( *(_DWORD *)(a1 + 208) )
    {
      if ( sub_80EACC8(a1, *(_DWORD *)(a1 + 208)) <= 0 )
      {
        v2 = sub_80E9270(*(_DWORD *)(a1 + 208));
        v5 = sub_80E963A(a1, *(_DWORD *)(v2 + 132));
        if ( v5 )
          *(_DWORD *)(a1 + 208) = v5;
        else
          *(_DWORD *)(a1 + 208) = a2;
        sub_811E9B4(*(_DWORD *)(a1 + 204), *(_DWORD *)(a1 + 208));
      }
    }
    else
    {
      *(_DWORD *)(a1 + 208) = a2;
      sub_811E9B4(*(_DWORD *)(a1 + 204), *(_DWORD *)(a1 + 208));
    }
    v4 = 1;
  }
  else
  {
    if ( (unsigned int)(v7[32] - 1) <= 1 )
    {
      if ( *(_BYTE *)(a1 + 1365) )
      {
        if ( !*(_BYTE *)(a1 + 1366) )
          *(_BYTE *)(a1 + 1366) = a2;
      }
      else
      {
        *(_BYTE *)(a1 + 1365) = a2;
      }
    }
    for ( i = v7[219]; i && !(unsigned __int8)sub_80D9E84(a1 + 1348, i); i = *(_DWORD *)(sub_80E9270(i) + 876) )
    {
      sub_80D9EAA(a1 + 1348, i);
      sub_80F0400(a1 + 1372, a2);
    }
    v4 = 1;
  }
  return v4;
}

//----- (0811E8E4) --------------------------------------------------------
void sub_811E8E4()
{
  Com_DPrintf("----------------------\n");
  Com_DPrintf("Game: G_SetupWeaponDef\n");
  if ( !dword_8576140 )
  {
    sub_8090A82();
    sub_8104A02();
    sub_80E90C8();
    sub_80E89A8((int)sub_8104D86);
    sub_811E940("defaultweapon_mp");
  }
  Com_DPrintf("----------------------\n");
}
// 8576140: using guessed type int dword_8576140;

//----- (0811E940) --------------------------------------------------------
int __cdecl sub_811E940(char *s1)
{
  signed int v2; // [esp+14h] [ebp-4h]

  if ( dword_859B41C )
    v2 = sub_80E94F0(s1, (int)sub_8104D86);
  else
    v2 = sub_80E949C(s1);
  return v2;
}

//----- (0811E97A) --------------------------------------------------------
int __cdecl sub_811E97A(int a1, int a2)
{
  char *v2; // eax

  v2 = va("%c %i", 97, a2);
  return sub_808FE96(a1, 1, (int)v2);
}

//----- (0811E9B4) --------------------------------------------------------
int __cdecl sub_811E9B4(int a1, int a2)
{
  char *v2; // eax

  v2 = va("%c %i", 67, a2);
  return sub_808FE96(a1, 1, (int)v2);
}

//----- (0811E9EE) --------------------------------------------------------
long double __cdecl sub_811E9EE(float a1, float a2, float a3)
{
  return (1.0 - a3) * a1 + a2 * a3;
}

//----- (0811EA04) --------------------------------------------------------
void __cdecl sub_811EA04(float a1, int a2, int a3)
{
  *(float *)a2 = sin(a1);
  *(float *)a3 = cos(a1);
}

//----- (0811EA32) --------------------------------------------------------
int __cdecl sub_811EA32(_DWORD *a1, _DWORD *a2)
{
  int result; // eax

  *a2 = *a1;
  a2[1] = a1[1];
  result = a1[2];
  a2[2] = result;
  return result;
}

//----- (0811EA62) --------------------------------------------------------
int __cdecl sub_811EA62(float *a1, float *a2, float *a3)
{
  int result; // eax

  *a3 = *a1 - *a2;
  a3[1] = a1[1] - a2[1];
  result = (int)(a1 + 2);
  a3[2] = a1[2] - a2[2];
  return result;
}

//----- (0811EAA6) --------------------------------------------------------
int __cdecl sub_811EAA6(int a1, float a2, int a3)
{
  int result; // eax

  *(float *)a3 = a2 * *(float *)a1;
  *(float *)(a3 + 4) = a2 * *(float *)(a1 + 4);
  result = a1 + 8;
  *(float *)(a3 + 8) = a2 * *(float *)(a1 + 8);
  return result;
}

//----- (0811EADE) --------------------------------------------------------
int __cdecl sub_811EADE(int a1, float a2, int a3, int a4)
{
  int result; // eax

  *(float *)a4 = a2 * *(float *)a3 + *(float *)a1;
  *(float *)(a4 + 4) = a2 * *(float *)(a3 + 4) + *(float *)(a1 + 4);
  result = a3 + 8;
  *(float *)(a4 + 8) = a2 * *(float *)(a3 + 8) + *(float *)(a1 + 8);
  return result;
}

//----- (0811EB32) --------------------------------------------------------
long double __cdecl sub_811EB32(float *a1, float *a2)
{
  return *a1 * *a2 + a1[1] * a2[1] + a1[2] * a2[2];
}

//----- (0811EB66) --------------------------------------------------------
void __cdecl sub_811EB66(float *a1)
{
  float v1; // ST00_4

  v1 = *a1 * *a1 + a1[1] * a1[1] + a1[2] * a1[2];
  sub_811EBA4(v1);
}

//----- (0811EBA4) --------------------------------------------------------
long double __cdecl sub_811EBA4(float a1)
{
  return (float)sqrt(a1);
}

//----- (0811EBC4) --------------------------------------------------------
int __cdecl sub_811EBC4(int *a1, int a2)
{
  int result; // eax
  void (__cdecl *v3)(int, int *, _DWORD); // [esp+10h] [ebp-8h]
  void (__cdecl *v4)(int, int *, int *); // [esp+14h] [ebp-4h]

  v4 = (void (__cdecl *)(int, int *, int *))dword_8167890[10 * *(unsigned __int8 *)(a2 + 358)];
  v3 = (void (__cdecl *)(int, int *, _DWORD))dword_816788C[10 * *(unsigned __int8 *)(a2 + 358)];
  if ( *(_DWORD *)(a2 + 4) == 3 )
  {
    Scr_AddEntity(a1);
    Scr_Notify((int *)a2, word_87A22F2, 1);
    *(_BYTE *)(a2 + 354) = 1;
    if ( v3 )
      v3(a2, a1, 0);
  }
  else if ( *(_DWORD *)(a2 + 4) != 9 || sub_8109EC0(a2, (int)a1) )
  {
    Scr_AddEntity(a1);
    Scr_Notify((int *)a2, word_87A22F4, 1);
    if ( v4 )
      v4(a2, a1, a1);
  }
  result = a1[86];
  *(_DWORD *)(result + 10288) = 1023;
  return result;
}
// 816788C: using guessed type int dword_816788C[];
// 8167890: using guessed type int dword_8167890[];
// 87A22F2: using guessed type __int16 word_87A22F2;
// 87A22F4: using guessed type __int16 word_87A22F4;

//----- (0811ECE4) --------------------------------------------------------
signed int __cdecl sub_811ECE4(int a1)
{
  signed int v2; // [esp+4h] [ebp-4h]

  if ( !sub_8084030() )
    return 0;
  *(_DWORD *)(*(_DWORD *)(a1 + 344) + 10288) = 1023;
  if ( *(_BYTE *)(a1 + 354) )
  {
    if ( *(_DWORD *)(*(_DWORD *)(a1 + 344) + 160) & 0x300 )
      *(_BYTE *)(a1 + 354) = 2;
    else
      *(_BYTE *)(a1 + 354) = 0;
    v2 = 1;
  }
  else if ( *(_DWORD *)(*(_DWORD *)(a1 + 344) + 12) & 4 )
  {
    v2 = 1;
  }
  else if ( *(_DWORD *)(*(_DWORD *)(a1 + 344) + 1440) == 1023 )
  {
    v2 = 0;
  }
  else
  {
    *(_DWORD *)(*(_DWORD *)(a1 + 344) + 10288) = *(_DWORD *)(*(_DWORD *)(a1 + 344) + 1440);
    *(_DWORD *)(*(_DWORD *)(a1 + 344) + 10292) = dword_859B5EC;
    v2 = 1;
  }
  return v2;
}

//----- (0811EDD4) --------------------------------------------------------
int __cdecl sub_811EDD4(int *a1)
{
  int result; // eax

  result = sub_8084030();
  if ( result )
  {
    result = a1[86];
    if ( *(_DWORD *)(result + 10288) != 1023 )
    {
      result = dword_8793DA4;
      if ( dword_859B5EC - *(_DWORD *)(a1[86] + 10400) >= *(_DWORD *)(dword_8793DA4 + 8) )
      {
        result = dword_8793DA0;
        if ( dword_859B5EC - *(_DWORD *)(a1[86] + 10292) >= *(_DWORD *)(dword_8793DA0 + 8) )
          result = sub_811EBC4(a1, (int)&unk_8665480 + 560 * *(_DWORD *)(a1[86] + 10288));
      }
    }
  }
  return result;
}
// 8793DA0: using guessed type int dword_8793DA0;
// 8793DA4: using guessed type int dword_8793DA4;

//----- (0811EE84) --------------------------------------------------------
int __cdecl sub_811EE84(int *a1)
{
  int result; // eax
  char v2; // [esp+7h] [ebp-1h]

  *(_DWORD *)(a1[86] + 12) &= 0xFFFFFFF7;
  if ( *(_DWORD *)(a1[86] + 216) <= 16 || (result = a1[86], *(_DWORD *)(result + 216) > 22) )
  {
    v2 = 0;
    if ( *(_DWORD *)(a1[86] + 10288) == 1023
      || !(*(_DWORD *)(a1[86] + 10176) & 0x20)
      || *(_DWORD *)(a1[86] + 10172) & 0x20 )
    {
      if ( *(_DWORD *)(a1[86] + 10180) & 0x28 )
        v2 = sub_811ECE4((int)a1);
      if ( *(_DWORD *)(a1[86] + 10288) != 1023 || v2 )
      {
        result = *(_DWORD *)(a1[86] + 10172) & 0x28;
        if ( result )
          result = sub_811EDD4(a1);
      }
      else
      {
        result = *(_DWORD *)(a1[86] + 10180) & 0x20;
        if ( result )
        {
          result = *(_DWORD *)(a1[86] + 12) | 8;
          *(_DWORD *)(a1[86] + 12) = result;
        }
      }
    }
    else
    {
      result = *(_DWORD *)(a1[86] + 12) | 8;
      *(_DWORD *)(a1[86] + 12) = result;
    }
  }
  return result;
}

//----- (0811EFC8) --------------------------------------------------------
int __cdecl sub_811EFC8(const void *a1, const void *a2)
{
  return (signed int)(*((float *)a1 + 1) - *((float *)a2 + 1));
}

//----- (0811F004) --------------------------------------------------------
size_t __cdecl sub_811F004(int a1, void *base)
{
  float v2; // ST24_4
  int v4; // [esp+28h] [ebp-10C0h]
  float v5; // [esp+30h] [ebp-10B8h]
  float v6; // [esp+34h] [ebp-10B4h]
  float v7; // [esp+38h] [ebp-10B0h]
  float v8; // [esp+40h] [ebp-10A8h]
  float v9; // [esp+44h] [ebp-10A4h]
  float v10; // [esp+48h] [ebp-10A0h]
  int v11; // [esp+50h] [ebp-1098h]
  int i; // [esp+54h] [ebp-1094h]
  size_t nmemb; // [esp+58h] [ebp-1090h]
  int v14; // [esp+5Ch] [ebp-108Ch]
  int v15[1026]; // [esp+60h] [ebp-1088h]
  float v16; // [esp+1068h] [ebp-80h]
  float v17; // [esp+106Ch] [ebp-7Ch]
  char v18; // [esp+1070h] [ebp-78h]
  int v19; // [esp+1080h] [ebp-68h]
  char v20; // [esp+1090h] [ebp-58h]
  char v21; // [esp+10A0h] [ebp-48h]
  char v22; // [esp+10B0h] [ebp-38h]
  char v23; // [esp+10C0h] [ebp-28h]
  int v24; // [esp+10D8h] [ebp-10h]
  int v25; // [esp+10DCh] [ebp-Ch]
  int v26; // [esp+10F0h] [ebp+8h]

  v4 = 0;
  v25 = *(_DWORD *)(a1 + 344);
  sub_80F61BE(a1, (float *)&v20);
  sub_80F63A0(a1, (int)&v23, 0, 0);
  sub_811FEEA((float *)(v25 + 20), (float *)(v25 + 1388), &v8);
  sub_811FEEA((float *)(v25 + 20), (float *)(v25 + 1400), &v5);
  sub_811FF2E((float *)&v20, (float *)&unk_8157DAC, (float *)&v22);
  sub_811FEEA((float *)&v20, (float *)&unk_8157DAC, (float *)&v21);
  v14 = sub_805E782((int)&v22, (int)&v21, (int)v15, 1024, 0x200000);
  nmemb = 0;
  for ( i = 0; i < v14; ++i )
  {
    v24 = (int)&unk_8665480 + 560 * v15[i];
    if ( a1 != v24 && (*(_DWORD *)(v24 + 4) == 3 || *(_DWORD *)(v24 + 284) & 0x200000) )
    {
      if ( *(_WORD *)(v24 + 360) == word_87A22F8 )
      {
        if ( *(float *)(v24 + 288) <= (long double)v5
          && v8 <= (long double)*(float *)(v24 + 300)
          && *(float *)(v24 + 292) <= (long double)v6
          && v9 <= (long double)*(float *)(v24 + 304)
          && *(float *)(v24 + 296) <= (long double)v7
          && v10 <= (long double)*(float *)(v24 + 308) )
        {
          if ( sub_80901C2(&v8, &v5, v24) )
          {
            *((_DWORD *)base + 2 * nmemb + 1) = -1015021568;
            *((_DWORD *)base + 2 * nmemb++) = v24;
          }
        }
      }
      else
      {
        sub_811FEEA((float *)(v24 + 288), (float *)(v24 + 300), (float *)&v19);
        sub_811FF72((int)&v19, 0.5, (int)&v19);
        sub_811FF2E((float *)&v19, (float *)&v20, (float *)&v18);
        v17 = sub_80A20C0((float *)&v18);
        if ( v17 <= 128.0 )
        {
          v2 = sub_811FFFE((float *)&v18, (float *)&v23);
          v16 = 1.0 - (v2 + 1.0) * 0.5;
          *((float *)base + 2 * nmemb + 1) = v16 * 256.0;
          if ( *(_WORD *)(v24 + 360) == word_87A22F6 )
            *((float *)base + 2 * nmemb + 1) = *((float *)base + 2 * nmemb + 1) - 256.0;
          if ( *(_DWORD *)(v24 + 4) == 3 && !sub_80DCC7A((_DWORD *)v24, *(_DWORD **)(a1 + 344), 0) )
          {
            *((float *)base + 2 * nmemb + 1) = *((float *)base + 2 * nmemb + 1) + 10000.0;
            ++v4;
          }
          *((_DWORD *)base + 2 * nmemb) = v24;
          *((float *)base + 2 * nmemb + 1) = *((float *)base + 2 * nmemb + 1) + v17;
          ++nmemb;
        }
      }
    }
  }
  qsort(base, nmemb, 8u, sub_811EFC8);
  nmemb -= v4;
  v11 = 0;
  for ( i = 0; i < (signed int)nmemb; ++i )
  {
    v26 = *((_DWORD *)base + 2 * i);
    if ( *(_WORD *)(v26 + 360) != word_87A22F8 )
    {
      sub_811FEEA((float *)(v26 + 288), (float *)(v26 + 300), (float *)&v19);
      sub_811FF72((int)&v19, 0.5, (int)&v19);
      if ( *(_DWORD *)(v26 + 4) == 9 )
        sub_811C16A(v26, (unsigned __int16)word_87A233E, (float *)&v19);
      if ( !sub_81080E6(
              (float *)&v20,
              (float *)&unk_8145E68,
              (float *)&unk_8145E68,
              (float *)&v19,
              *(_DWORD *)(v25 + 204),
              17) )
      {
        *((float *)base + 2 * i + 1) = *((float *)base + 2 * i + 1) + 10000.0;
        ++v11;
      }
    }
  }
  qsort(base, nmemb, 8u, sub_811EFC8);
  return nmemb - v11;
}
// 87A22F6: using guessed type __int16 word_87A22F6;
// 87A22F8: using guessed type __int16 word_87A22F8;
// 87A233E: using guessed type __int16 word_87A233E;
// 811F004: using guessed type int var_1088[1026];

//----- (0811F61A) --------------------------------------------------------
int __cdecl sub_811F61A(int a1, int a2)
{
  int v3; // [esp+10h] [ebp-8h]
  char *v4; // [esp+14h] [ebp-4h]

  v4 = (char *)&unk_8164C20 + 44 * *(unsigned __int16 *)(a2 + 428);
  v3 = 0;
  if ( *((_DWORD *)v4 + 7) == 1
    && *(_DWORD *)(sub_80E9270(*((_DWORD *)v4 + 8)) + 120) != 1
    && !(unsigned __int8)sub_80D9E84(a1 + 1348, *((_DWORD *)v4 + 8)) )
  {
    v3 = *((_DWORD *)v4 + 8) + 4;
  }
  return v3;
}

//----- (0811F6A6) --------------------------------------------------------
_BYTE *__cdecl sub_811F6A6(int a1)
{
  _BYTE *result; // eax
  _DWORD *v2; // [esp+Ch] [ebp-Ch]
  int v3; // [esp+10h] [ebp-8h]

  v2 = *(_DWORD **)(a1 + 344);
  v3 = dword_859B404 + 560 * v2[357];
  result = *(_BYTE **)(sub_80E9270(*(_DWORD *)(v3 + 200)) + 1392);
  if ( *result )
  {
    v2[360] = 1023;
    v2[358] = *(_DWORD *)(v3 + 200) + 4;
    result = *(_BYTE **)(sub_80E9270(*(_DWORD *)(v3 + 200)) + 1400);
    v2[359] = result;
  }
  return result;
}
// 859B404: using guessed type int dword_859B404;

//----- (0811F736) --------------------------------------------------------
_BYTE *__cdecl sub_811F736(int a1)
{
  _BYTE *result; // eax
  signed int v2; // [esp+10h] [ebp-2028h]
  signed int i; // [esp+14h] [ebp-2024h]
  _BYTE *v4; // [esp+18h] [ebp-2020h]
  signed int v5; // [esp+1Ch] [ebp-201Ch]
  int v6; // [esp+20h] [ebp-2018h]
  int v7; // [esp+24h] [ebp-2014h]
  int v8; // [esp+28h] [ebp-2010h]
  _DWORD *v9; // [esp+2Ch] [ebp-200Ch]
  int base[2050]; // [esp+30h] [ebp-2008h]

  v9 = *(_DWORD **)(a1 + 344);
  v9[358] = 0;
  v9[359] = -1;
  v9[360] = 1023;
  result = (_BYTE *)a1;
  if ( *(_DWORD *)(a1 + 404) > 0 )
  {
    if ( *(_DWORD *)(*(_DWORD *)(a1 + 344) + 216) <= 16
      || (result = *(_BYTE **)(a1 + 344), *((_DWORD *)result + 54) > 22) )
    {
      if ( *(_BYTE *)(a1 + 354) )
      {
        result = (_BYTE *)(v9[40] & 0x300);
        if ( result )
          result = sub_811F6A6(a1);
      }
      else
      {
        result = (_BYTE *)(*(_DWORD *)(*(_DWORD *)(a1 + 344) + 12) & 4);
        if ( !result )
        {
          result = (_BYTE *)sub_811F004(a1, base);
          v4 = result;
          if ( result )
          {
            v7 = 0;
            v5 = -1;
            for ( i = 0; ; ++i )
            {
              result = (_BYTE *)i;
              if ( i >= (signed int)v4 )
                return result;
              v8 = base[2 * i];
              v2 = *(_DWORD *)(v8 + 4);
              if ( v2 == 3 )
              {
                v6 = sub_811F61A(*(_DWORD *)(a1 + 344), v8);
                if ( v6 )
                {
                  v7 = v6;
LABEL_31:
                  v9[360] = *(_DWORD *)v8;
                  v9[358] = v7;
                  v9[359] = v5;
                  result = v9;
                  if ( !v9[358] )
                  {
                    result = v9;
                    v9[360] = 1023;
                  }
                  return result;
                }
              }
              else if ( v2 > 3 )
              {
                if ( v2 == 9 && sub_8109EC0(v8, a1) )
                {
                  v7 = *(_DWORD *)(v8 + 200) + 4;
                  if ( **(_BYTE **)(sub_80E9270(*(_DWORD *)(v8 + 200)) + 1388) )
                    v5 = *(_DWORD *)(sub_80E9270(*(_DWORD *)(v8 + 200)) + 1396);
                  goto LABEL_31;
                }
              }
              else if ( !v2 )
              {
                if ( *(_WORD *)(v8 + 360) != word_87A22F6 && *(_WORD *)(v8 + 360) != word_87A22F8 )
                  goto LABEL_31;
                if ( (!*(_BYTE *)(v8 + 359)
                   || *(unsigned __int8 *)(v8 + 359) == *(_DWORD *)(*(_DWORD *)(a1 + 344) + 10060))
                  && (*(_DWORD *)(v8 + 436) == 1023 || *(_DWORD *)(v8 + 436) == *(_DWORD *)(*(_DWORD *)(a1 + 344) + 204)) )
                {
                  v7 = *(_DWORD *)(v8 + 220);
                  if ( *(_DWORD *)(v8 + 220) && *(_DWORD *)(v8 + 216) != 255 )
                    v5 = *(_DWORD *)(v8 + 216);
                  goto LABEL_31;
                }
              }
            }
          }
        }
      }
    }
  }
  return result;
}
// 87A22F6: using guessed type __int16 word_87A22F6;
// 87A22F8: using guessed type __int16 word_87A22F8;
// 811F736: using guessed type int base[2050];

//----- (0811FABE) --------------------------------------------------------
int __cdecl sub_811FABE(void *s, int a2, int a3, int a4, int a5, int a6, int a7)
{
  float v7; // ST04_4
  float v8; // ST2C_4
  int v10; // [esp+28h] [ebp-20h]
  int v11; // [esp+30h] [ebp-18h]

  sub_8108134(s, a2, a3, a4, a5, a6);
  if ( *((_WORD *)s + 14) > 0x3FDu )
    return 0;
  v7 = *(float *)s * 15000.0;
  sub_811FFAA(a2, v7, a7, (int)&v11);
  v8 = sub_808F1DC(a2, &v11);
  if ( v8 >= 0.2 )
    v10 = 560 * *((unsigned __int16 *)s + 14) + 140924032;
  else
    v10 = 0;
  return v10;
}
// 808F1DC: using guessed type double __cdecl sub_808F1DC(_DWORD, _DWORD);

//----- (0811FB7A) --------------------------------------------------------
void __cdecl sub_811FB7A(int *a1)
{
  float v1; // ST28_4
  float v2; // ST24_4
  float v3; // ST20_4
  void *v4; // [esp+2Ch] [ebp-8Ch]
  char v5; // [esp+30h] [ebp-88h]
  int v6; // [esp+40h] [ebp-78h]
  int v7; // [esp+50h] [ebp-68h]
  int v8; // [esp+60h] [ebp-58h]
  char s; // [esp+70h] [ebp-48h]
  int v10; // [esp+80h] [ebp-38h]
  int v11; // [esp+A4h] [ebp-14h]
  _DWORD *v12; // [esp+A8h] [ebp-10h]
  int v13; // [esp+ACh] [ebp-Ch]

  v12 = (_DWORD *)a1[86];
  v12[3] &= 0xFFCFFFFF;
  *(_DWORD *)(a1[86] + 10284) = 0;
  sub_80F61BE((int)a1, (float *)&v8);
  sub_80F63A0((int)a1, (int)&v6, 0, 0);
  if ( v12[40] & 0x300 )
    v13 = sub_80E9270(dword_8665548[140 * v12[357]]);
  else
    v13 = sub_80E9270(*(_DWORD *)(a1[86] + 212));
  if ( *(_DWORD *)(a1[86] + 212) && *(_DWORD *)(v13 + 796) )
    v4 = &unk_816779F;
  else
    v4 = &unk_816778C;
  sub_811FFAA((int)&v8, 15000.0, (int)&v6, (int)&v7);
  v11 = sub_811FABE(&s, (int)&v8, (int)&v7, *a1, 578824193, (int)v4, (int)&v6);
  if ( v11 )
  {
    if ( *(_WORD *)(v11 + 360) != word_87A22FC
      || (*(_DWORD *)(a1[86] + 10284) = v11,
          sub_8119FCC((int *)v11, a1),
          (v11 = sub_811FABE(&s, (int)&v8, (int)&v7, *a1, 41953281, (int)v4, (int)&v6)) != 0) )
    {
      if ( *(_DWORD *)(v11 + 4) == 1 && !(v10 & 0x10) )
      {
        sub_811FF2E((float *)(v11 + 312), (float *)&v8, (float *)&v5);
        if ( *(_DWORD *)(*(_DWORD *)(v11 + 344) + 10060) == *(_DWORD *)(a1[86] + 10060) && *(_DWORD *)(a1[86] + 10060) )
        {
          v1 = sub_8120032((float *)&v5);
          if ( sub_811FEDE(*(float *)(dword_8793E3C + 8)) > v1 && !*(_DWORD *)(a1[86] + 10284) )
            *(_DWORD *)(a1[86] + 10284) = v11;
          v2 = sub_8120032((float *)&v5);
          if ( sub_811FEDE(*(float *)(dword_8793E38 + 8)) > v2 )
            v12[3] |= 0x100000u;
        }
        else
        {
          v3 = sub_8120032((float *)&v5);
          if ( sub_811FEDE(*(float *)(v13 + 608)) > v3 )
          {
            if ( !*(_DWORD *)(a1[86] + 10284) )
              *(_DWORD *)(a1[86] + 10284) = v11;
            v12[3] |= 0x200000u;
          }
        }
      }
    }
  }
}
// 8665548: using guessed type int dword_8665548[];
// 8793E38: using guessed type int dword_8793E38;
// 8793E3C: using guessed type int dword_8793E3C;
// 87A22FC: using guessed type __int16 word_87A22FC;

//----- (0811FEDE) --------------------------------------------------------
long double __cdecl sub_811FEDE(float a1)
{
  return a1 * a1;
}

//----- (0811FEEA) --------------------------------------------------------
int __cdecl sub_811FEEA(float *a1, float *a2, float *a3)
{
  int result; // eax

  *a3 = *a1 + *a2;
  a3[1] = a1[1] + a2[1];
  result = (int)(a1 + 2);
  a3[2] = a1[2] + a2[2];
  return result;
}

//----- (0811FF2E) --------------------------------------------------------
int __cdecl sub_811FF2E(float *a1, float *a2, float *a3)
{
  int result; // eax

  *a3 = *a1 - *a2;
  a3[1] = a1[1] - a2[1];
  result = (int)(a1 + 2);
  a3[2] = a1[2] - a2[2];
  return result;
}

//----- (0811FF72) --------------------------------------------------------
int __cdecl sub_811FF72(int a1, float a2, int a3)
{
  int result; // eax

  *(float *)a3 = a2 * *(float *)a1;
  *(float *)(a3 + 4) = a2 * *(float *)(a1 + 4);
  result = a1 + 8;
  *(float *)(a3 + 8) = a2 * *(float *)(a1 + 8);
  return result;
}

//----- (0811FFAA) --------------------------------------------------------
int __cdecl sub_811FFAA(int a1, float a2, int a3, int a4)
{
  int result; // eax

  *(float *)a4 = a2 * *(float *)a3 + *(float *)a1;
  *(float *)(a4 + 4) = a2 * *(float *)(a3 + 4) + *(float *)(a1 + 4);
  result = a3 + 8;
  *(float *)(a4 + 8) = a2 * *(float *)(a3 + 8) + *(float *)(a1 + 8);
  return result;
}

//----- (0811FFFE) --------------------------------------------------------
long double __cdecl sub_811FFFE(float *a1, float *a2)
{
  return *a1 * *a2 + a1[1] * a2[1] + a1[2] * a2[2];
}

//----- (08120032) --------------------------------------------------------
long double __cdecl sub_8120032(float *a1)
{
  return *a1 * *a1 + a1[1] * a1[1] + a1[2] * a1[2];
}

//----- (08120068) --------------------------------------------------------
int sub_8120068()
{
  int result; // eax

  word_87A22A0 = sub_810DD1C(&byte_8157DD0);
  word_87A22A2 = sub_810DD1C("allies");
  word_87A22A4 = sub_810DD1C("axis");
  word_87A22A6 = sub_810DD1C("current");
  word_87A22A8 = sub_810DD1C("damage");
  word_87A22AA = sub_810DD1C("death");
  word_87A22AC = sub_810DD1C("dlight");
  word_87A22AE = sub_810DD1C("done");
  word_87A22B0 = sub_810DD1C("empty");
  word_87A22B2 = sub_810DD1C("entity");
  word_87A22B4 = sub_810DD1C("failed");
  word_87A22B6 = sub_810DD1C("fraction");
  word_87A22B8 = sub_810DD1C("goal");
  word_87A22BA = sub_810DD1C("grenade");
  word_87A22BC = sub_810DD1C("info_notnull");
  word_87A22BE = sub_810DD1C("invisible");
  word_87A22C0 = sub_810DD1C("key1");
  word_87A22C2 = sub_810DD1C("key2");
  word_87A22C4 = sub_810DD1C("killanimscript");
  word_87A22C6 = sub_810DD1C("left");
  word_87A22C8 = sub_810DD1C("movedone");
  word_87A22CA = sub_810DD1C("noclass");
  word_87A22CC = sub_810DD1C("normal");
  word_87A22CE = sub_810DD1C("pistol");
  word_87A22D0 = sub_810DD1C("plane_waypoint");
  word_87A22D2 = sub_810DD1C("player");
  word_87A22D4 = sub_810DD1C("position");
  word_87A22D6 = sub_810DD1C("primary");
  word_87A22D8 = sub_810DD1C("primaryb");
  word_87A22DA = sub_810DD1C("prone");
  word_87A22DC = sub_810DD1C("right");
  word_87A22DE = sub_810DD1C("rocket");
  word_87A22E0 = sub_810DD1C("rotatedone");
  word_87A22E2 = sub_810DD1C("script_brushmodel");
  word_87A22E4 = sub_810DD1C("script_model");
  word_87A22E6 = sub_810DD1C("script_origin");
  word_87A22E8 = sub_810DD1C("spectator");
  word_87A22EA = sub_810DD1C("stand");
  word_87A22EC = sub_810DD1C("surfacetype");
  word_87A22EE = sub_810DD1C("target_script_trigger");
  word_87A22F0 = sub_810DD1C("tempEntity");
  word_87A22F2 = sub_810DD1C("touch");
  word_87A22F4 = sub_810DD1C("trigger");
  word_87A22F6 = sub_810DD1C("trigger_use");
  word_87A22F8 = sub_810DD1C("trigger_use_touch");
  word_87A22FA = sub_810DD1C("trigger_damage");
  word_87A22FC = sub_810DD1C("trigger_lookat");
  word_87A22FE = sub_810DD1C("truck_cam");
  word_87A2300 = sub_810DD1C("worldspawn");
  word_87A2302 = sub_810DD1C("binocular_enter");
  word_87A2304 = sub_810DD1C("binocular_exit");
  word_87A2306 = sub_810DD1C("binocular_fire");
  word_87A2308 = sub_810DD1C("binocular_release");
  word_87A230A = sub_810DD1C("binocular_drop");
  word_87A230C = sub_810DD1C("begin");
  word_87A230E = sub_810DD1C("intermission");
  word_87A2310 = sub_810DD1C("menuresponse");
  word_87A2312 = sub_810DD1C("playing");
  word_87A2314 = sub_810DD1C("none");
  word_87A2316 = sub_810DD1C("dead");
  word_87A2318 = sub_810DD1C("auto_change");
  word_87A231A = sub_810DD1C("manual_change");
  word_87A231C = sub_810DD1C("freelook");
  word_87A231E = sub_810DD1C("call_vote");
  word_87A2320 = sub_810DD1C("vote");
  word_87A2322 = sub_810DD1C("snd_enveffectsprio_level");
  word_87A2324 = sub_810DD1C("snd_enveffectsprio_shellshock");
  word_87A2326 = sub_810DD1C("snd_channelvolprio_holdbreath");
  word_87A2328 = sub_810DD1C("snd_channelvolprio_pain");
  word_87A232A = sub_810DD1C("snd_channelvolprio_shellshock");
  word_87A232C = sub_810DD1C("tag_flash");
  word_87A232E = sub_810DD1C("tag_flash_11");
  word_87A2330 = sub_810DD1C("tag_flash_2");
  word_87A2332 = sub_810DD1C("tag_flash_22");
  word_87A2334 = sub_810DD1C("tag_brass");
  word_87A2336 = sub_810DD1C("j_head");
  word_87A2338 = sub_810DD1C("tag_weapon");
  word_87A233A = sub_810DD1C("tag_player");
  word_87A233C = sub_810DD1C("tag_camera");
  word_87A233E = sub_810DD1C("tag_aim");
  word_87A2340 = sub_810DD1C("tag_aim_animated");
  word_87A2342 = sub_810DD1C("tag_origin");
  word_87A2344 = sub_810DD1C("tag_butt");
  word_87A2346 = sub_810DD1C("tag_weapon_right");
  word_87A2348 = sub_810DD1C("back_low");
  word_87A234A = sub_810DD1C("back_mid");
  word_87A234C = sub_810DD1C("back_up");
  word_87A234E = sub_810DD1C("neck");
  word_87A2350 = sub_810DD1C("head");
  result = sub_810DD1C("pelvis");
  word_87A2352 = result;
  return result;
}
// 87A22A0: using guessed type __int16 word_87A22A0;
// 87A22A2: using guessed type __int16 word_87A22A2;
// 87A22A4: using guessed type __int16 word_87A22A4;
// 87A22A6: using guessed type __int16 word_87A22A6;
// 87A22A8: using guessed type __int16 word_87A22A8;
// 87A22AA: using guessed type __int16 word_87A22AA;
// 87A22AC: using guessed type __int16 word_87A22AC;
// 87A22AE: using guessed type __int16 word_87A22AE;
// 87A22B0: using guessed type __int16 word_87A22B0;
// 87A22B2: using guessed type __int16 word_87A22B2;
// 87A22B4: using guessed type __int16 word_87A22B4;
// 87A22B6: using guessed type __int16 word_87A22B6;
// 87A22B8: using guessed type __int16 word_87A22B8;
// 87A22BA: using guessed type __int16 word_87A22BA;
// 87A22BC: using guessed type __int16 word_87A22BC;
// 87A22BE: using guessed type __int16 word_87A22BE;
// 87A22C0: using guessed type __int16 word_87A22C0;
// 87A22C2: using guessed type __int16 word_87A22C2;
// 87A22C4: using guessed type __int16 word_87A22C4;
// 87A22C6: using guessed type __int16 word_87A22C6;
// 87A22C8: using guessed type __int16 word_87A22C8;
// 87A22CA: using guessed type __int16 word_87A22CA;
// 87A22CC: using guessed type __int16 word_87A22CC;
// 87A22CE: using guessed type __int16 word_87A22CE;
// 87A22D0: using guessed type __int16 word_87A22D0;
// 87A22D2: using guessed type __int16 word_87A22D2;
// 87A22D4: using guessed type __int16 word_87A22D4;
// 87A22D6: using guessed type __int16 word_87A22D6;
// 87A22D8: using guessed type __int16 word_87A22D8;
// 87A22DA: using guessed type __int16 word_87A22DA;
// 87A22DC: using guessed type __int16 word_87A22DC;
// 87A22DE: using guessed type __int16 word_87A22DE;
// 87A22E0: using guessed type __int16 word_87A22E0;
// 87A22E2: using guessed type __int16 word_87A22E2;
// 87A22E4: using guessed type __int16 word_87A22E4;
// 87A22E6: using guessed type __int16 word_87A22E6;
// 87A22E8: using guessed type __int16 word_87A22E8;
// 87A22EA: using guessed type __int16 word_87A22EA;
// 87A22EC: using guessed type __int16 word_87A22EC;
// 87A22EE: using guessed type __int16 word_87A22EE;
// 87A22F0: using guessed type __int16 word_87A22F0;
// 87A22F2: using guessed type __int16 word_87A22F2;
// 87A22F4: using guessed type __int16 word_87A22F4;
// 87A22F6: using guessed type __int16 word_87A22F6;
// 87A22F8: using guessed type __int16 word_87A22F8;
// 87A22FA: using guessed type __int16 word_87A22FA;
// 87A22FC: using guessed type __int16 word_87A22FC;
// 87A22FE: using guessed type __int16 word_87A22FE;
// 87A2300: using guessed type __int16 word_87A2300;
// 87A2302: using guessed type __int16 word_87A2302;
// 87A2304: using guessed type __int16 word_87A2304;
// 87A2306: using guessed type __int16 word_87A2306;
// 87A2308: using guessed type __int16 word_87A2308;
// 87A230A: using guessed type __int16 word_87A230A;
// 87A230C: using guessed type __int16 word_87A230C;
// 87A230E: using guessed type __int16 word_87A230E;
// 87A2310: using guessed type __int16 word_87A2310;
// 87A2312: using guessed type __int16 word_87A2312;
// 87A2314: using guessed type __int16 word_87A2314;
// 87A2316: using guessed type __int16 word_87A2316;
// 87A2318: using guessed type __int16 word_87A2318;
// 87A231A: using guessed type __int16 word_87A231A;
// 87A231C: using guessed type __int16 word_87A231C;
// 87A231E: using guessed type __int16 word_87A231E;
// 87A2320: using guessed type __int16 word_87A2320;
// 87A2322: using guessed type __int16 word_87A2322;
// 87A2324: using guessed type __int16 word_87A2324;
// 87A2326: using guessed type __int16 word_87A2326;
// 87A2328: using guessed type __int16 word_87A2328;
// 87A232A: using guessed type __int16 word_87A232A;
// 87A232C: using guessed type __int16 word_87A232C;
// 87A232E: using guessed type __int16 word_87A232E;
// 87A2330: using guessed type __int16 word_87A2330;
// 87A2332: using guessed type __int16 word_87A2332;
// 87A2334: using guessed type __int16 word_87A2334;
// 87A2336: using guessed type __int16 word_87A2336;
// 87A2338: using guessed type __int16 word_87A2338;
// 87A233A: using guessed type __int16 word_87A233A;
// 87A233C: using guessed type __int16 word_87A233C;
// 87A233E: using guessed type __int16 word_87A233E;
// 87A2340: using guessed type __int16 word_87A2340;
// 87A2342: using guessed type __int16 word_87A2342;
// 87A2344: using guessed type __int16 word_87A2344;
// 87A2346: using guessed type __int16 word_87A2346;
// 87A2348: using guessed type __int16 word_87A2348;
// 87A234A: using guessed type __int16 word_87A234A;
// 87A234C: using guessed type __int16 word_87A234C;
// 87A234E: using guessed type __int16 word_87A234E;
// 87A2350: using guessed type __int16 word_87A2350;
// 87A2352: using guessed type __int16 word_87A2352;

//----- (08120708) --------------------------------------------------------
int __cdecl sub_8120708(int a1)
{
  int result; // eax

  *(_DWORD *)a1 = 0;
  *(_BYTE *)(a1 + 4) = 0;
  *(_BYTE *)(a1 + 5) = 0;
  *(_DWORD *)(a1 + 8) = 0;
  *(_DWORD *)(a1 + 20) = 0;
  *(_DWORD *)(a1 + 12) = 0;
  result = a1;
  *(_DWORD *)(a1 + 16) = 0;
  return result;
}

//----- (0812074C) --------------------------------------------------------
int __cdecl sub_812074C(int a1, int a2)
{
  int result; // eax

  *(_DWORD *)a1 = a2;
  *(_BYTE *)(a1 + 4) = 1;
  *(_BYTE *)(a1 + 5) = 0;
  *(_DWORD *)(a1 + 8) = 0;
  *(_DWORD *)(a1 + 20) = *(_DWORD *)(*(_DWORD *)a1 + 8);
  *(_DWORD *)(a1 + 12) = 0;
  result = a1;
  *(_DWORD *)(a1 + 16) = 0;
  return result;
}

//----- (08120794) --------------------------------------------------------
int __cdecl sub_8120794(int a1, int a2)
{
  int result; // eax

  *(_DWORD *)a1 = a2;
  *(_BYTE *)(a1 + 4) = 0;
  *(_BYTE *)(a1 + 5) = 1;
  *(_DWORD *)(a1 + 8) = 0;
  *(_DWORD *)(a1 + 20) = *(_DWORD *)(*(_DWORD *)a1 + 8);
  *(_DWORD *)(a1 + 12) = 0;
  result = a1;
  *(_DWORD *)(a1 + 16) = 0;
  return result;
}

//----- (081207DC) --------------------------------------------------------
void *__cdecl sub_81207DC(int *a1)
{
  char s; // [esp+20h] [ebp-98h]
  char v4[79]; // [esp+60h] [ebp-58h]
  unsigned __int8 v5; // [esp+AFh] [ebp-9h]

  v5 = sub_8121100(a1);
  if ( !v5 || v5 > 0x3Fu )
    return 0;
  sub_8120968(a1, v4, v5);
  v4[v5] = 0;
  Com_sprintf(&s, 0x40u, "fx/%s", v4);
  return sub_8129F6A(&s);
}
// 81207DC: using guessed type char var_58[79];

//----- (08120872) --------------------------------------------------------
int __cdecl sub_8120872(int *a1)
{
  char v3[79]; // [esp+20h] [ebp-58h]
  unsigned __int8 v4; // [esp+6Fh] [ebp-9h]

  v4 = sub_8121100(a1);
  if ( !v4 || v4 > 0x3Fu )
    return 0;
  sub_8120968(a1, v3, v4);
  v3[v4] = 0;
  return sub_812F0DE();
}
// 8120872: using guessed type char var_58[79];

//----- (081208D4) --------------------------------------------------------
int __cdecl sub_81208D4(int *a1)
{
  char s1[79]; // [esp+20h] [ebp-58h]
  unsigned __int8 v4; // [esp+6Fh] [ebp-9h]

  v4 = sub_8121100(a1);
  if ( !v4 || v4 > 0x3Fu )
    return 0;
  sub_8120968(a1, s1, v4);
  s1[v4] = 0;
  return sub_812F0E8(s1);
}
// 81208D4: using guessed type char s1[79];

//----- (08120936) --------------------------------------------------------
int __cdecl sub_8120936(int *a1, int a2)
{
  int result; // eax

  *(_DWORD *)(a2 + 4) = 0;
  *(float *)(a2 + 8) = sub_8121126(a1);
  result = a2;
  *(_DWORD *)a2 = 0;
  return result;
}

//----- (08120968) --------------------------------------------------------
_BYTE **__cdecl sub_8120968(int *a1, _BYTE *a2, int a3)
{
  char v3; // al
  _BYTE **result; // eax
  char v5; // al
  int v6; // [esp+Ch] [ebp-Ch]
  _BYTE *v7; // [esp+14h] [ebp-4h]

  a1[2] += a3;
  v7 = a2;
  do
  {
    while ( !a1[3] )
    {
      while ( a1[4] && a3 )
      {
        --a1[4];
        --a3;
        *v7 = 0;
        result = &v7;
        ++v7;
        if ( !a3 )
          return result;
      }
      v5 = sub_81210DA(*a1);
      v6 = v5 & 0xC0;
      if ( v6 == 64 )
      {
        a1[3] = 2;
        a1[4] = (v5 & 0x3F) + 1;
      }
      else if ( v6 > 64 )
      {
        if ( v6 == 128 )
        {
          a1[3] = 4;
          a1[4] = (v5 & 0x3F) + 1;
        }
        else
        {
LABEL_18:
          a1[3] = (v5 & 0x3F) + 1;
          a1[4] = 0;
        }
      }
      else
      {
        if ( v5 & 0xC0 )
          goto LABEL_18;
        a1[3] = 1;
        a1[4] = (v5 & 0x3F) + 1;
      }
    }
    --a1[3];
    --a3;
    v3 = sub_81210DA(*a1);
    *v7 = v3;
    result = &v7;
    ++v7;
  }
  while ( a3 );
  return result;
}

//----- (08120AA2) --------------------------------------------------------
int __cdecl sub_8120AA2(int *a1, const char **a2)
{
  size_t v2; // eax
  int result; // eax
  char *s; // [esp+10h] [ebp-8h]
  int v5; // [esp+14h] [ebp-4h]

  if ( a2 )
  {
    s = (char *)*a2;
    v2 = strlen(*a2);
  }
  else
  {
    s = (char *)&unk_81581A2;
    v2 = strlen((const char *)&unk_81581A2);
  }
  v5 = v2;
  result = sub_8121152(a1, v2);
  if ( v5 )
    result = sub_8120BFA(a1, s, v5);
  return result;
}

//----- (08120B02) --------------------------------------------------------
int __cdecl sub_8120B02(int *a1, int a2)
{
  size_t v2; // eax
  int result; // eax
  char *s; // [esp+10h] [ebp-8h]
  int v5; // [esp+14h] [ebp-4h]

  if ( a2 )
  {
    s = (char *)sub_812ADD4();
    v2 = strlen(s);
  }
  else
  {
    s = (char *)&unk_81581A2;
    v2 = strlen((const char *)&unk_81581A2);
  }
  v5 = v2;
  result = sub_8121152(a1, v2);
  if ( v5 )
    result = sub_8120BFA(a1, s, v5);
  return result;
}

//----- (08120B70) --------------------------------------------------------
int __cdecl sub_8120B70(int *a1, int a2)
{
  int result; // eax
  char *v3; // [esp+Ch] [ebp-Ch]
  size_t v4; // [esp+14h] [ebp-4h]

  if ( a2 )
    v3 = (char *)sub_80C5414(a2);
  else
    v3 = (char *)&unk_81581A2;
  v4 = strlen(v3);
  result = sub_8121152(a1, v4);
  if ( v4 )
    result = sub_8120BFA(a1, v3, v4);
  return result;
}

//----- (08120BDC) --------------------------------------------------------
int __cdecl sub_8120BDC(int *a1, int a2)
{
  return sub_812117A(a1, *(_DWORD *)(a2 + 8));
}

//----- (08120BFA) --------------------------------------------------------
int __cdecl sub_8120BFA(int *a1, char *a2, int a3)
{
  int result; // eax
  _BYTE *v4; // eax
  int v5; // [esp+Ch] [ebp-Ch]
  int v6; // [esp+10h] [ebp-8h]
  int v7; // [esp+14h] [ebp-4h]

  a1[2] += a3;
  v7 = (int)a2;
  if ( a1[5] == *(_DWORD *)(*a1 + 8) )
  {
    sub_81210B2(*a1, 192);
    sub_81210B2(*a1, *a2);
    v7 = (int)(a2 + 1);
    --a3;
  }
  v6 = 0;
LABEL_4:
  while ( 1 )
  {
    result = v6;
    if ( v6 >= a3 )
      return result;
    v5 = *(_BYTE *)(*(_DWORD *)*a1 + a1[5]) & 0xC0;
    if ( v5 == 64 )
      goto LABEL_10;
    if ( v5 <= 64 )
    {
      if ( !(*(_BYTE *)(*(_DWORD *)*a1 + a1[5]) & 0xC0) )
        goto LABEL_10;
      while ( 1 )
      {
LABEL_15:
        if ( v6 >= a3 )
          goto LABEL_4;
        if ( *(_BYTE *)(*(_DWORD *)*a1 + a1[5]) & 0x3F )
        {
          switch ( *(_BYTE *)(*(_DWORD *)*a1 + a1[5]) & 0x3F )
          {
            case 1:
              if ( !*(_BYTE *)(v7 + v6) )
              {
                *(_BYTE *)(*(_DWORD *)*a1 + a1[5]) = 64;
                ++v6;
                goto LABEL_4;
              }
              break;
            case 3:
              if ( !*(_BYTE *)(v7 + v6) )
              {
                *(_BYTE *)(*(_DWORD *)*a1 + a1[5]) = -128;
                ++v6;
                goto LABEL_4;
              }
              break;
            case 63:
              a1[5] = *(_DWORD *)(*a1 + 8);
              sub_81210B2(*a1, 192);
              sub_81210B2(*a1, *(_BYTE *)(v7 + v6++));
              continue;
            default:
              if ( (*(_BYTE *)(*(_DWORD *)*a1 + a1[5]) & 0x3F) > 5
                && !*(_BYTE *)(v7 + v6)
                && !*(_BYTE *)(*(_DWORD *)*a1 + *(_DWORD *)(*a1 + 8) - 2)
                && !*(_BYTE *)(*(_DWORD *)*a1 + *(_DWORD *)(*a1 + 8) - 1) )
              {
                *(_BYTE *)(a1[5] + *(_DWORD *)*a1) = *(_BYTE *)(*(_DWORD *)*a1 + a1[5]) - 3;
                *(_BYTE *)(*(_DWORD *)*a1 + *(_DWORD *)(*a1 + 8) - 2) = *(_BYTE *)(*(_DWORD *)*a1
                                                                                 + *(_DWORD *)(*a1 + 8)
                                                                                 - 3);
                *(_BYTE *)(*(_DWORD *)*a1 + *(_DWORD *)(*a1 + 8) - 3) = 2;
                a1[5] = (*(_DWORD *)(*a1 + 8))-- - 3;
                ++v6;
                goto LABEL_4;
              }
              break;
          }
        }
        else if ( !*(_BYTE *)(v7 + v6) )
        {
          *(_BYTE *)(*(_DWORD *)*a1 + a1[5]) = 0;
          ++v6;
          goto LABEL_4;
        }
        v4 = (_BYTE *)(*(_DWORD *)*a1 + a1[5]);
        ++*v4;
        sub_81210B2(*a1, *(_BYTE *)(v7 + v6++));
      }
    }
    if ( v5 != 128 )
      goto LABEL_15;
LABEL_10:
    while ( v6 < a3 )
    {
      if ( *(_BYTE *)(v7 + v6) || (*(_BYTE *)(*(_DWORD *)*a1 + a1[5]) & 0x3F) == 63 )
      {
        a1[5] = *(_DWORD *)(*a1 + 8);
        sub_81210B2(*a1, 192);
        sub_81210B2(*a1, *(_BYTE *)(v7 + v6++));
        goto LABEL_4;
      }
      ++*(_BYTE *)(*(_DWORD *)*a1 + a1[5]);
      ++v6;
    }
  }
}

//----- (08120F84) --------------------------------------------------------
_BYTE **__cdecl sub_8120F84(int a1, char *a2, int a3)
{
  _BYTE **result; // eax

  if ( *(_BYTE *)(a1 + 4) )
    result = sub_8120968((int *)a1, a2, a3);
  else
    result = (_BYTE **)sub_8120BFA((int *)a1, a2, a3);
  return result;
}

//----- (08120FCA) --------------------------------------------------------
const char **__cdecl sub_8120FCA(int a1, const char ***a2)
{
  const char **result; // eax

  if ( !*(_BYTE *)(a1 + 4) )
    return (const char **)sub_8120AA2((int *)a1, *a2);
  result = (const char **)sub_81207DC((int *)a1);
  *a2 = result;
  return result;
}

//----- (08121006) --------------------------------------------------------
int __cdecl sub_8121006(int a1, int *a2)
{
  int v2; // edx
  int result; // eax

  if ( !*(_BYTE *)(a1 + 4) )
    return sub_8120B02((int *)a1, *a2);
  v2 = sub_8120872((int *)a1);
  result = (int)a2;
  *a2 = v2;
  return result;
}

//----- (08121040) --------------------------------------------------------
int __cdecl sub_8121040(int a1, int *a2)
{
  int v2; // edx
  int result; // eax

  if ( !*(_BYTE *)(a1 + 4) )
    return sub_8120B70((int *)a1, *a2);
  v2 = sub_81208D4((int *)a1);
  result = (int)a2;
  *a2 = v2;
  return result;
}

//----- (0812107A) --------------------------------------------------------
int __cdecl sub_812107A(int a1, int a2)
{
  int result; // eax

  if ( *(_BYTE *)(a1 + 4) )
    result = sub_8120936((int *)a1, a2);
  else
    result = sub_8120BDC((int *)a1, a2);
  return result;
}

//----- (081210B2) --------------------------------------------------------
int __cdecl sub_81210B2(int a1, char a2)
{
  char src; // [esp+17h] [ebp-1h]

  src = a2;
  return sub_80B3636(a1, 1u, &src);
}

//----- (081210DA) --------------------------------------------------------
int __cdecl sub_81210DA(int a1)
{
  unsigned __int8 dest; // [esp+17h] [ebp-1h]

  sub_80B3796(a1, 1u, &dest);
  return dest;
}

//----- (08121100) --------------------------------------------------------
int __cdecl sub_8121100(int *a1)
{
  unsigned __int8 v2; // [esp+17h] [ebp-1h]

  sub_8120968(a1, &v2, 1);
  return v2;
}

//----- (08121126) --------------------------------------------------------
long double __cdecl sub_8121126(int *a1)
{
  float v2; // [esp+14h] [ebp-4h]

  sub_8120968(a1, &v2, 4);
  return v2;
}

//----- (08121152) --------------------------------------------------------
int __cdecl sub_8121152(int *a1, char a2)
{
  char v3; // [esp+17h] [ebp-1h]

  v3 = a2;
  return sub_8120BFA(a1, &v3, 1);
}

//----- (0812117A) --------------------------------------------------------
int sub_812117A(int *a1, ...)
{
  va_list va; // [esp+24h] [ebp+Ch]

  va_start(va, a1);
  return sub_8120BFA(a1, (char *)va, 4);
}

//----- (0812119C) --------------------------------------------------------
int __cdecl sub_812119C(_DWORD *a1, int a2, int a3, int a4)
{
  int i; // [esp+18h] [ebp-60h]
  int src; // [esp+20h] [ebp-58h]
  int v7[18]; // [esp+24h] [ebp-54h]
  int v8; // [esp+6Ch] [ebp-Ch]

  v8 = 2;
  src = 0;
  *(&src + a2 + 1) = 1065353216;
  for ( i = 0; i != a2; ++i )
  {
    v7[i] = a3;
    v7[i + a2 + 1] = a4;
  }
  *a1 = sub_8121AAC(&src, a2, 2);
  return sub_812F15A(a1 + 1, 1065353216, 1065353216);
}
// 812119C: using guessed type int var_54[18];

//----- (0812123C) --------------------------------------------------------
int __cdecl sub_812123C(int *a1, int *a2)
{
  int *v2; // ecx
  int v3; // edx
  int result; // eax

  *a2 = sub_8121C40(*a1);
  v2 = a2 + 1;
  v3 = a1[2];
  result = a1[1];
  *v2 = result;
  v2[1] = v3;
  return result;
}

//----- (08121272) --------------------------------------------------------
_DWORD *__cdecl sub_8121272(_DWORD *a1, int a2, int a3, int a4)
{
  _DWORD *result; // eax
  int i; // [esp+18h] [ebp-50h]
  int src; // [esp+20h] [ebp-48h]
  int v7[17]; // [esp+24h] [ebp-44h]

  src = 0;
  *(&src + a2 + 1) = 1065353216;
  for ( i = 0; i != a2; ++i )
  {
    v7[i] = *(_DWORD *)(a3 + 4 * i);
    v7[i + a2 + 1] = *(_DWORD *)(a4 + 4 * i);
  }
  result = sub_8121AAC(&src, a2, 2);
  *a1 = result;
  return result;
}
// 8121272: using guessed type int var_44[17];

//----- (08121304) --------------------------------------------------------
_DWORD *__cdecl sub_8121304(_DWORD *a1, int a2, int a3, int a4, int a5)
{
  _DWORD *result; // eax
  int i; // [esp+18h] [ebp-70h]
  int v7; // [esp+1Ch] [ebp-6Ch]
  int src; // [esp+20h] [ebp-68h]
  int v9[25]; // [esp+24h] [ebp-64h]

  v7 = a2 + 1;
  src = 0;
  *(&src + a2 + 1) = a5;
  *(&src + 2 * (a2 + 1)) = 1065353216;
  for ( i = 0; i != a2; ++i )
  {
    v9[i] = *(_DWORD *)(a3 + 4 * i);
    v9[i + v7] = *(_DWORD *)(a3 + 4 * i);
    v9[i + 2 * v7] = *(_DWORD *)(a4 + 4 * i);
  }
  result = sub_8121AAC(&src, a2, 3);
  *a1 = result;
  return result;
}
// 8121304: using guessed type int var_64[25];

//----- (081213C4) --------------------------------------------------------
_DWORD *__cdecl sub_81213C4(int a1, int a2, int a3, int a4, int a5, float a6, float a7)
{
  float v7; // ST1C_4
  _DWORD *result; // eax
  float v9; // [esp+20h] [ebp-228h]
  float v10; // [esp+20h] [ebp-228h]
  float v11; // [esp+24h] [ebp-224h]
  int i; // [esp+28h] [ebp-220h]
  int v13; // [esp+30h] [ebp-218h]
  float v14; // [esp+34h] [ebp-214h]
  int v15; // [esp+38h] [ebp-210h]
  float v16; // [esp+3Ch] [ebp-20Ch]
  char src[520]; // [esp+40h] [ebp-208h]

  v13 = a2 + 1;
  v15 = 0;
  v16 = 0.0;
  while ( v15 != 16 )
  {
    if ( v16 > 1.0 )
      v16 = 1.0;
    v11 = 1.0;
    v9 = 1.0;
    if ( a3 & 1 )
      v11 = 1.0 - v16;
    switch ( a3 & 0xC )
    {
      case 4:
        if ( v16 > (long double)a6 )
          v9 = 1.0 - (v16 - a6) / (1.0 - a6);
        if ( a3 & 1 )
          v11 = v11 * 0.5 + v9 * 0.5;
        else
          v11 = v9;
        break;
      case 8:
        v7 = cos(v16 * a7);
        v11 = v7 * v11;
        break;
      case 12:
        if ( a6 <= (long double)v16 )
          v10 = 0.0;
        else
          v10 = (a6 - v16) / a6;
        if ( a3 & 1 )
          v11 = v11 * 0.5 + v10 * 0.5;
        else
          v11 = v10;
        break;
    }
    *(float *)&src[4 * v13 * v15] = v16;
    for ( i = 0; i != a2; ++i )
    {
      v14 = *(float *)(a4 + 4 * i) * v11 + (1.0 - v11) * *(float *)(a5 + 4 * i);
      if ( v14 >= 0.0 )
      {
        if ( v11 > 1.0 )
          v14 = 1.0;
      }
      else
      {
        v14 = 0.0;
      }
      if ( a3 & 2 )
        v14 = sub_80A8720(0.0, v14);
      *(float *)&src[4 * v13 * v15 + 4 + 4 * i] = v14;
    }
    ++v15;
    v16 = v16 + 0.06666667;
  }
  result = sub_8121AAC(src, a2, 16);
  *(_DWORD *)a1 = result;
  return result;
}
// 81213C4: using guessed type char src[520];

//----- (081216CE) --------------------------------------------------------
_DWORD *__cdecl sub_81216CE(int a1, int a2, float a3, int a4, int a5)
{
  float v5; // ST2C_4
  long double v6; // fst7
  float v7; // ST00_4
  int v8; // ST08_4
  int v9; // ST04_4
  long double v10; // fst7
  long double v11; // fst7
  long double v12; // fst7
  float v13; // ST44_4
  int i; // [esp+3Ch] [ebp-4Ch]
  int v16; // [esp+40h] [ebp-48h]
  int v17; // [esp+48h] [ebp-40h]
  float v18; // [esp+4Ch] [ebp-3Ch]
  int v19[4]; // [esp+50h] [ebp-38h]
  int v20[4]; // [esp+60h] [ebp-28h]
  float v21; // [esp+70h] [ebp-18h]
  float v22; // [esp+74h] [ebp-14h]
  float v23; // [esp+78h] [ebp-10h]
  char v24; // [esp+7Fh] [ebp-9h]

  v24 = a4;
  v23 = 1.0;
  if ( !(_BYTE)a4 )
  {
    v5 = sub_812F1B8(a1 + 24, 0.5);
    v6 = sub_812F1B8(a1, 0.5);
    v7 = v6;
    sub_81218EE(v7, v5);
    v23 = v6 * 1.3333334;
  }
  if ( v23 < 1.0 )
    v23 = 1.0;
  v21 = (*(float *)(a1 + 4) - *(float *)a1) / 2.0;
  *(float *)&v8 = v23 + v21;
  *(float *)&v9 = v23 - v21;
  sub_812F15A((_DWORD *)(a5 + 4), v9, v8);
  v22 = 1.0 / v23;
  v18 = 0.0;
  for ( i = 0; i != a2; ++i )
  {
    v10 = sub_812F1B8(a1 + 8 * i, 0.5);
    *(float *)&v20[i] = v10 * v22;
    v11 = sub_812F1B8(a1 + 8 * i + 24, 0.5);
    *(float *)&v19[i] = v11 * v22;
    v12 = sub_812F1B8(a1 + 48, 0.5);
    v18 = v12 * v22;
  }
  *(float *)&v17 = v18 * 0.0099999998;
  v16 = *(_DWORD *)(a1 + 56);
  if ( *(_BYTE *)(a1 + 56) & 1 && !(v16 & 0xC) )
    return sub_8121272((_DWORD *)a5, a2, (int)v20, (int)v19);
  if ( ((unsigned __int8)v16 ^ 1) & 1 && (*(_DWORD *)(a1 + 56) & 0xC) == 4 )
    return sub_8121304((_DWORD *)a5, a2, (int)v20, (int)v19, v17);
  v13 = v18 * 0.003141593 * a3;
  return sub_81213C4(a5, a2, v16, (int)v20, (int)v19, *(float *)&v17, v13);
}
// 81216CE: using guessed type int var_28[4];
// 81216CE: using guessed type int var_38[4];

//----- (081218EE) --------------------------------------------------------
void __cdecl sub_81218EE(float a1, float a2)
{
  float v2; // ST00_4

  v2 = a1 - a2;
  sub_8121912(v2, a1, a2);
}

//----- (08121912) --------------------------------------------------------
long double __cdecl sub_8121912(float a1, float a2, float a3)
{
  float v4; // [esp+0h] [ebp-4h]

  if ( a1 < 0.0 )
    v4 = a3;
  else
    v4 = a2;
  return v4;
}

//----- (0812193C) --------------------------------------------------------
_DWORD *__cdecl sub_812193C(_DWORD *a1, int a2)
{
  _DWORD *result; // eax

  *a1 = a2;
  result = a1;
  a1[1] = 0;
  return result;
}

//----- (08121962) --------------------------------------------------------
long double __cdecl sub_8121962(float a1, float a2, float a3, float a4)
{
  return (a3 + a4) * 0.5 * (a2 - a1);
}

//----- (0812197E) --------------------------------------------------------
long double __cdecl sub_812197E(int a1, float a2)
{
  int v2; // ST30_4
  float v3; // ST28_4
  float *v6; // [esp+20h] [ebp-18h]
  float *v7; // [esp+24h] [ebp-14h]
  int v8; // [esp+2Ch] [ebp-Ch]
  float v9; // [esp+34h] [ebp-4h]

  v2 = *(_DWORD *)(a1 + 4);
  v8 = *(_DWORD *)a1 + 1;
  v6 = (float *)(a1 + 8);
  v7 = (float *)(a1 + 8 + 4 * v8);
  v9 = 0.0;
  while ( a2 > (long double)*v7 )
  {
    v9 = sub_8121962(*v6, *v7, v6[1], v7[1]) + v9;
    v6 = v7;
    v7 += v8;
  }
  v3 = sub_8121A60((int)v6, a2);
  return (float)(sub_8121962(*v6, a2, v6[1], v3) + v9);
}

//----- (08121A60) --------------------------------------------------------
long double __cdecl sub_8121A60(int a1, float a2)
{
  return (a2 - *(float *)a1) * (*(float *)(a1 + 12) - *(float *)(a1 + 4)) / (*(float *)(a1 + 8) - *(float *)a1)
       + *(float *)(a1 + 4);
}

//----- (08121AAC) --------------------------------------------------------
_DWORD *__cdecl sub_8121AAC(void *src, int a2, int a3)
{
  int v4; // [esp+18h] [ebp-20h]
  int v5; // [esp+1Ch] [ebp-1Ch]
  int v6; // [esp+20h] [ebp-18h]
  _DWORD *v7; // [esp+24h] [ebp-14h]
  int i; // [esp+28h] [ebp-10h]
  int j; // [esp+28h] [ebp-10h]
  signed int v10; // [esp+2Ch] [ebp-Ch]
  int v11; // [esp+2Ch] [ebp-Ch]
  bool v12; // [esp+36h] [ebp-2h]
  bool v13; // [esp+37h] [ebp-1h]

  v6 = a2 + 1;
  v13 = 0.0 != *(float *)src;
  v12 = 1.0 != *(float *)((char *)src + (a2 + 1) * (4 * a3 - 4));
  v5 = a3;
  if ( 0.0 != *(float *)src )
    v5 = a3 + 1;
  v4 = v5;
  if ( 1.0 != *(float *)((char *)src + (a2 + 1) * (4 * a3 - 4)) )
    v4 = v5 + 1;
  v7 = Hunk_AllocAlignInternal(4 * v4 * v6 + 8, 4);
  *v7 = a2;
  v10 = 0;
  if ( v13 )
  {
    v7[2] = 0;
    for ( i = 0; i != a2; ++i )
      v7[i + 3] = *((_DWORD *)src + i + 1);
    v10 = 1;
  }
  memcpy(&v7[v6 * v10 + 2], src, 4 * v6 * a3);
  v11 = a3 + v10;
  if ( v12 )
  {
    v7[v6 * v11 + 2] = 1065353216;
    for ( j = 0; j != a2; ++j )
      v7[j + 3 + v6 * v11] = *((_DWORD *)src + j + 1);
  }
  v7[1] = a3;
  return v7;
}

//----- (08121C40) --------------------------------------------------------
int __cdecl sub_8121C40(int a1)
{
  return a1;
}

//----- (08121C48) --------------------------------------------------------
unsigned int *FxMem_Init()
{
  unsigned int *result; // eax
  unsigned int i; // [esp+0h] [ebp-8h]
  _DWORD *v2; // [esp+4h] [ebp-4h]

  v2 = &unk_87A2380;
  for ( i = 0; i <= 0x1FFFFF; i += 0x8000 )
  {
    v2[8188] = -1;
    v2 += 0x2000;
    result = &i;
  }
  return result;
}

//----- (08121C8A) --------------------------------------------------------
_DWORD *__cdecl sub_8121C8A(int a1, int a2, int a3)
{
  int i; // [esp+10h] [ebp-8h]
  _DWORD *v6; // [esp+14h] [ebp-4h]

  v6 = &unk_87A2380;
  for ( i = 0; ; i += 0x8000 )
  {
    if ( (unsigned int)i > 0x1FFFFF )
    {
      Com_DPrintf("^1Out of effects memory!\n");
      return 0;
    }
    if ( v6[8188] < 0 )
      break;
    v6 += 0x2000;
  }
  if ( dword_89A2380 < i + 0x8000 )
    dword_89A2380 = i + 0x8000;
  v6[8188] = a2;
  for ( i = 0; i < a2 - 1; ++i )
    *(_DWORD *)((char *)v6 + a3 * i) = (char *)v6 + a3 * (i + 1);
  *(_DWORD *)((char *)v6 + a3 * i) = 0;
  v6[8189] = v6;
  if ( a1 )
    *(_DWORD *)(a1 + 32764) = v6;
  v6[8190] = a1;
  v6[0x1FFF] = 0;
  return v6;
}
// 89A2380: using guessed type int dword_89A2380;

//----- (08121D9A) --------------------------------------------------------
int __cdecl sub_8121D9A(int a1)
{
  int result; // eax

  if ( *(_DWORD *)(a1 + 32764) )
    *(_DWORD *)(*(_DWORD *)(a1 + 32764) + 32760) = *(_DWORD *)(a1 + 32760);
  if ( *(_DWORD *)(a1 + 32760) )
    *(_DWORD *)(*(_DWORD *)(a1 + 32760) + 32764) = *(_DWORD *)(a1 + 32764);
  *(_DWORD *)(a1 + 32764) = 0;
  result = a1;
  *(_DWORD *)(a1 + 32760) = 0;
  return result;
}

//----- (08121E02) --------------------------------------------------------
int __cdecl sub_8121E02(int a1)
{
  int result; // eax

  sub_8121D9A(a1);
  result = a1;
  *(_DWORD *)(a1 + 32752) = -1;
  return result;
}

//----- (08121E22) --------------------------------------------------------
char *__cdecl sub_8121E22(char *a1)
{
  char *v1; // edx

  *(_DWORD *)a1 = *(_DWORD *)((char *)&unk_87A2380 + ((a1 - (char *)&unk_87A2380) & 0xFFFF8000) + 32756);
  v1 = (char *)&unk_87A2380 + ((a1 - (char *)&unk_87A2380) & 0xFFFF8000);
  *((_DWORD *)v1 + 8189) = a1;
  ++*((_DWORD *)v1 + 8188);
  return (char *)&unk_87A2380 + ((a1 - (char *)&unk_87A2380) & 0xFFFF8000);
}

//----- (08121E7C) --------------------------------------------------------
void __cdecl sub_8121E7C(int a1, int a2)
{
  int i; // [esp+20h] [ebp-8h]
  int v3; // [esp+24h] [ebp-4h]

  for ( i = 0; i <= 2; ++i )
  {
    v3 = sub_8127000((signed int)(*(float *)(a1 + 4 * i) * 255.0), 0, 255);
    *(_BYTE *)(i + a2) = v3;
  }
}

//----- (08121EF6) --------------------------------------------------------
_DWORD *__userpurge sub_8121EF6@<eax>(_DWORD *a1, _DWORD *a2)
{
  _DWORD *v2; // ST20_4
  _DWORD *i; // [esp+24h] [ebp-4h]

  for ( i = (_DWORD *)dword_89A2388; i; i = (_DWORD *)i[14] )
  {
    if ( i[15] == *a2 && i[16] == a2[1] )
    {
      sub_8127798(a1, i);
      return a1;
    }
  }
  v2 = sub_8127752(68);
  sub_81220BE(v2, a2);
  sub_8127798(a1, v2);
  return a1;
}
// 89A2388: using guessed type int dword_89A2388;

//----- (08121FB2) --------------------------------------------------------
int __cdecl sub_8121FB2(int a1)
{
  int result; // eax
  int *i; // [esp+4h] [ebp-4h]

  --*(_DWORD *)a1;
  result = a1;
  if ( !*(_DWORD *)a1 )
  {
    for ( i = &dword_89A2388; *i; i = (int *)(*i + 56) )
    {
      if ( *i == a1 )
      {
        *i = *(_DWORD *)(a1 + 56);
        break;
      }
    }
    result = sub_812776E((char *)a1);
  }
  return result;
}
// 89A2388: using guessed type int dword_89A2388;

//----- (08122008) --------------------------------------------------------
int __cdecl sub_8122008(_DWORD *a1)
{
  if ( a1[15] < 0 )
    return 0;
  if ( a1[1] == dword_848B0B0 )
    return (int)(a1 + 2);
  a1[1] = dword_848B0B0;
  if ( (unsigned __int8)sub_813130E() )
    return (int)(a1 + 2);
  a1[15] = -1;
  a1[16] = -1;
  return 0;
}
// 848B0B0: using guessed type int dword_848B0B0;

//----- (081220BE) --------------------------------------------------------
_DWORD *__cdecl sub_81220BE(_DWORD *a1, _DWORD *a2)
{
  _DWORD *v2; // ecx
  int v3; // edx
  _DWORD *result; // eax

  *a1 = 0;
  a1[1] = 0;
  v2 = a1 + 15;
  v3 = a2[1];
  *v2 = *a2;
  v2[1] = v3;
  a1[14] = dword_89A2388;
  result = a1;
  dword_89A2388 = (int)a1;
  return result;
}
// 89A2388: using guessed type int dword_89A2388;

//----- (081220FC) --------------------------------------------------------
_DWORD *__cdecl sub_81220FC(int *a1, int *a2)
{
  _DWORD *result; // eax
  int v3[6]; // [esp+20h] [ebp-28h]
  int v4; // [esp+38h] [ebp-10h]
  int v5; // [esp+3Ch] [ebp-Ch]

  if ( (unsigned __int8)sub_8127A4A((int)a2) )
  {
    v4 = sub_8127A56(a2);
    if ( v4 < 0 )
    {
      result = sub_8127840(a1, 0);
    }
    else
    {
      v5 = sub_8127A56(a2);
      sub_8121EF6(v3, &v4);
      sub_81277D4(a1, v3);
      result = (_DWORD *)sub_81277B6(v3);
    }
  }
  else if ( *a1 )
  {
    sub_8127A7C(a2, *(_DWORD *)(*a1 + 60));
    result = (_DWORD *)sub_8127A7C(a2, *(_DWORD *)(*a1 + 64));
  }
  else
  {
    result = (_DWORD *)sub_8127A7C(a2, -1);
  }
  return result;
}

//----- (081221F2) --------------------------------------------------------
void *__cdecl sub_81221F2(size_t a1)
{
  return Hunk_AllocInternal(a1);
}

//----- (08122206) --------------------------------------------------------
int __cdecl sub_8122206(char *s2)
{
  return sub_80C3264(s2, (int)sub_81221F2, (int)sub_81221F2);
}

//----- (0812222A) --------------------------------------------------------
_DWORD *__cdecl sub_812222A(_DWORD *a1)
{
  *a1 = off_81584A8;
  return sub_812778A(a1 + 48);
}
// 81584A8: using guessed type int (__cdecl *off_81584A8[2])(int);

//----- (0812226E) --------------------------------------------------------
int __cdecl sub_812226E(_DWORD *a1)
{
  *a1 = off_81584A8;
  sub_81277B6(a1 + 48);
  return 0;
}
// 81584A8: using guessed type int (__cdecl *off_81584A8[2])(int);

//----- (081222A6) --------------------------------------------------------
int __cdecl sub_81222A6(_DWORD *a1)
{
  *a1 = off_81584A8;
  sub_81277B6(a1 + 48);
  return 0;
}
// 81584A8: using guessed type int (__cdecl *off_81584A8[2])(int);

//----- (081222DE) --------------------------------------------------------
int __cdecl sub_81222DE(int a1)
{
  *(_DWORD *)a1 = off_81584A8;
  sub_81277B6((int *)(a1 + 192));
  return sub_81278B0((char *)a1);
}
// 81584A8: using guessed type int (__cdecl *off_81584A8[2])(int);

//----- (08122316) --------------------------------------------------------
void sub_8122316()
{
  ;
}

//----- (0812231C) --------------------------------------------------------
int sub_812231C()
{
  return 0;
}

//----- (08122326) --------------------------------------------------------
void sub_8122326()
{
  ;
}

//----- (0812232C) --------------------------------------------------------
_BOOL4 __cdecl sub_812232C(int a1, int *a2)
{
  _DWORD *v2; // eax
  _BOOL4 v4; // [esp+4h] [ebp-4h]

  v4 = !(unsigned __int8)sub_812782E((_DWORD *)(a1 + 192))
    || (v2 = (_DWORD *)sub_812787E(a1 + 192), (*a2 = sub_8122008(v2)) != 0);
  return v4;
}

//----- (08122382) --------------------------------------------------------
int __cdecl sub_8122382(int a1)
{
  int v2; // [esp+14h] [ebp-4h]

  if ( *(_DWORD *)(a1 + 168) & 0x2000000 )
    v2 = sub_8126F9C(5, *(_DWORD *)(off_8168620 + 128));
  else
    v2 = *(_DWORD *)(off_8168620 + 128);
  return v2;
}

//----- (081223CE) --------------------------------------------------------
signed int __cdecl sub_81223CE(int a1)
{
  if ( *(_DWORD *)(a1 + 184) > *(_DWORD *)(off_8168620 + 4) )
    return 0;
  *(float *)(a1 + 60) = (long double)(*(_DWORD *)(off_8168620 + 4) - *(_DWORD *)(a1 + 184))
                      / (long double)sub_8127896(a1);
  if ( *(float *)(a1 + 60) > 1.0 )
    *(_DWORD *)(a1 + 60) = 1065353216;
  if ( *(float *)(a1 + 60) < 0.0 )
    *(_DWORD *)(a1 + 60) = 0;
  return 1;
}

//----- (08122472) --------------------------------------------------------
int __cdecl sub_8122472(int a1, int a2, int a3)
{
  int result; // eax

  *(_DWORD *)(a1 + 184) = a2;
  result = a3;
  *(_DWORD *)(a1 + 188) = a3;
  return result;
}

//----- (08122490) --------------------------------------------------------
int __cdecl sub_8122490(int a1)
{
  return *(_DWORD *)(off_8168620 + 4) - *(_DWORD *)(a1 + 184);
}

//----- (081224B2) --------------------------------------------------------
_DWORD *__cdecl sub_81224B2(int a1, _DWORD *a2)
{
  return sub_81277D4((int *)(a1 + 192), a2);
}

//----- (081224D2) --------------------------------------------------------
int sub_81224D2()
{
  return 0;
}

//----- (081224DC) --------------------------------------------------------
int __cdecl sub_81224DC(int a1, int *a2)
{
  int result; // eax

  sub_8127B04((int)a2, (char *)(a1 + 4));
  sub_8127AC0((int)a2, (char *)(a1 + 184));
  sub_8127AC0((int)a2, (char *)(a1 + 188));
  sub_8127AC0((int)a2, (char *)(a1 + 168));
  sub_8127AC0((int)a2, (char *)(a1 + 16));
  sub_8127B04((int)a2, (char *)(a1 + 20));
  sub_8127B04((int)a2, (char *)(a1 + 32));
  sub_8120FCA((int)a2, (const char ***)(a1 + 44));
  sub_8120FCA((int)a2, (const char ***)(a1 + 48));
  sub_8120F84((int)a2, (char *)(a1 + 64), 104);
  sub_8120FCA((int)a2, (const char ***)(a1 + 52));
  sub_8127AC0((int)a2, (char *)(a1 + 56));
  sub_8121006((int)a2, (int *)(a1 + 64));
  sub_8121040((int)a2, (int *)(a1 + 180));
  sub_81220FC((int *)(a1 + 192), a2);
  result = sub_8127A4A((int)a2);
  if ( (_BYTE)result )
  {
    *(_DWORD *)(a1 + 172) = sub_8130F90((float *)(a1 + 124));
    result = sub_8133348(a1);
  }
  return result;
}

//----- (08122668) --------------------------------------------------------
void sub_8122668()
{
  ;
}

//----- (0812266E) --------------------------------------------------------
void __cdecl sub_812266E(int a1, int a2)
{
  int v2; // ST08_4
  int s; // [esp+10h] [ebp-88h]
  int v4; // [esp+14h] [ebp-84h]
  int v5; // [esp+24h] [ebp-74h]
  int v6; // [esp+48h] [ebp-50h]
  int v7; // [esp+4Ch] [ebp-4Ch]
  int v8; // [esp+58h] [ebp-40h]
  int v9; // [esp+64h] [ebp-34h]
  char v10; // [esp+68h] [ebp-30h]
  char v11; // [esp+69h] [ebp-2Fh]
  char v12; // [esp+6Ah] [ebp-2Eh]
  char v13; // [esp+6Bh] [ebp-2Dh]
  int v14; // [esp+70h] [ebp-28h]
  int v15; // [esp+74h] [ebp-24h]
  int v16; // [esp+78h] [ebp-20h]
  int v17; // [esp+7Ch] [ebp-1Ch]

  memset(&s, 0, 0x74u);
  s = a2;
  v9 = *(_DWORD *)(a1 + 64);
  v17 = *(_DWORD *)(a1 + 68);
  sub_80A6FE6((_DWORD *)(a1 + 72), &v5);
  sub_8127108((_DWORD *)(a1 + 124), &v7);
  v15 = *(_DWORD *)(a1 + 136);
  v16 = *(_DWORD *)(a1 + 140);
  v10 = *(_BYTE *)(a1 + 144);
  v11 = *(_BYTE *)(a1 + 145);
  v12 = *(_BYTE *)(a1 + 146);
  v13 = *(_BYTE *)(a1 + 147);
  v14 = *(_DWORD *)(a1 + 148);
  v6 = *(_DWORD *)(a1 + 152);
  sub_8127108((_DWORD *)(a1 + 156), &v8);
  if ( *(_BYTE *)(a1 + 168) & 1 )
    v4 |= 8u;
  if ( *(_DWORD *)(a1 + 168) & 0x4000000 )
    v4 |= 0x80u;
  v2 = *(_DWORD *)(a1 + 180);
  sub_812ADC0();
}

//----- (081227C4) --------------------------------------------------------
int __cdecl sub_81227C4(_DWORD *a1)
{
  sub_812222A(a1);
  *a1 = off_8158468;
  return sub_81270BA(a1 + 49);
}
// 8158468: using guessed type int (__cdecl *off_8158468[6])(int);

//----- (081227F0) --------------------------------------------------------
int __cdecl sub_81227F0(_DWORD *a1)
{
  sub_812222A(a1);
  *a1 = off_8158468;
  return sub_81270BA(a1 + 49);
}
// 8158468: using guessed type int (__cdecl *off_8158468[6])(int);

//----- (0812281C) --------------------------------------------------------
int __cdecl sub_812281C(_DWORD *a1)
{
  *a1 = off_8158468;
  sub_812226E(a1);
  return 0;
}
// 8158468: using guessed type int (__cdecl *off_8158468[6])(int);

//----- (08122850) --------------------------------------------------------
int __cdecl sub_8122850(_DWORD *a1)
{
  *a1 = off_8158468;
  sub_812226E(a1);
  return 0;
}
// 8158468: using guessed type int (__cdecl *off_8158468[6])(int);

//----- (08122884) --------------------------------------------------------
int __cdecl sub_8122884(char *a1)
{
  *(_DWORD *)a1 = off_8158468;
  sub_812226E(a1);
  return sub_812795A(a1);
}
// 8158468: using guessed type int (__cdecl *off_8158468[6])(int);

//----- (081228B8) --------------------------------------------------------
void __cdecl sub_81228B8(int a1)
{
  int v1; // ST1C_4
  int v2; // esi
  int v3; // ST1C_4
  int v4; // ST04_4
  float v5; // ST04_4
  float v6; // [esp+2Ch] [ebp-1Ch]
  int v7; // [esp+30h] [ebp-18h]

  if ( *(_DWORD *)(a1 + 168) & 0x200 && !(*(_DWORD *)(a1 + 168) & 0x400) && *(_DWORD *)(a1 + 48) )
  {
    *(float *)&v1 = sub_80A8720(-1.0, 1.0);
    v2 = v1;
    *(float *)&v3 = sub_80A8720(-1.0, 1.0);
    *(float *)&v4 = sub_80A8720(-1.0, 1.0);
    sub_81270E4(&v7, v4, v3, v2);
    v6 = sub_812734C(&v7);
    if ( v6 >= 0.000001 )
    {
      v5 = 1.0 / v6;
      sub_81271EE((int)&v7, v5, (int)&v7);
    }
    else
    {
      sub_81270E4(&v7, 0, 0, 1065353216);
    }
    sub_8128900((int *)dword_89A2814, *(_DWORD **)(a1 + 48), (float *)(a1 + 4), &v7);
  }
}
// 812734C: using guessed type double __cdecl sub_812734C(_DWORD);

//----- (081229F0) --------------------------------------------------------
int __cdecl sub_81229F0(int a1)
{
  int v1; // eax

  v1 = sub_8122382(a1);
  return (unsigned __int8)sub_812AB74(off_8168620, (float *)(a1 + 124), *(float *)(a1 + 136), v1);
}

//----- (08122A2E) --------------------------------------------------------
void __cdecl sub_8122A2E(int a1)
{
  if ( *(float *)(a1 + 136) != 0.0 && *(float *)(a1 + 140) != 0.0 )
    sub_812266E(a1, 4);
}

//----- (08122A76) --------------------------------------------------------
signed int __cdecl sub_8122A76(float *a1)
{
  float *v3; // [esp+14h] [ebp-4h]

  v3 = 0;
  if ( !(unsigned __int8)sub_81223CE((int)a1) )
    return 0;
  if ( !(unsigned __int8)sub_812232C((int)a1, (int *)&v3) )
    return 0;
  if ( !(unsigned __int8)sub_81232B2((int)a1, v3) )
    return 0;
  if ( v3 )
    sub_80B6758(v3, a1 + 1, a1 + 31);
  else
    sub_8127108((_DWORD *)a1 + 1, (_DWORD *)a1 + 31);
  sub_8123F5C((int)a1);
  if ( a1[34] == 0.0 )
    return 1;
  sub_8123FE0((int)a1);
  if ( a1[35] != 0.0 )
  {
    sub_8124080((int)a1);
    sub_812410E((int)a1);
    sub_812427C((int)a1);
    sub_812430C((int)a1);
  }
  return 1;
}

//----- (08122BB2) --------------------------------------------------------
int __cdecl sub_8122BB2(_DWORD *a1, _DWORD *a2)
{
  sub_8127138(a2, a1 + 52);
  sub_8127138(a2 + 3, a1 + 55);
  return sub_8127138(a2 + 6, a1 + 58);
}

//----- (08122C06) --------------------------------------------------------
void __cdecl sub_8122C06(int a1, int a2)
{
  sub_812193C((_DWORD *)a2, *(_DWORD *)a1);
  *(float *)(a2 + 8) = sub_812F170((float *)(a1 + 4));
}

//----- (08122C3C) --------------------------------------------------------
void __cdecl sub_8122C3C(int a1, int a2)
{
  sub_8122C06(a2 + 256, a1 + 324);
  sub_8122C06(a2 + 268, a1 + 336);
  sub_8122C06(a2 + 280, a1 + 348);
  sub_8122C06(a2 + 292, a1 + 360);
  sub_8122C06(a2 + 304, a1 + 372);
  sub_8122C06(a2 + 316, a1 + 384);
  sub_8122C06(a2 + 328, a1 + 396);
  sub_8122C06(a2 + 340, a1 + 408);
  sub_8122C06(a2 + 376, a1 + 420);
  sub_8122C06(a2 + 388, a1 + 432);
  sub_8122C06(a2 + 400, a1 + 444);
  sub_8122C06(a2 + 412, a1 + 456);
  sub_8122C06(a2 + 424, a1 + 468);
  sub_8122C06(a2 + 436, a1 + 480);
  sub_8122C06(a2 + 448, a1 + 492);
  sub_8122C06(a2 + 460, a1 + 504);
  sub_8122C06(a2 + 472, a1 + 516);
  sub_8122C06(a2 + 484, a1 + 528);
  sub_8122C06(a2 + 496, a1 + 540);
  sub_8122C06(a2 + 508, a1 + 552);
  sub_8122C06(a2 + 520, a1 + 564);
  sub_8122C06(a2 + 532, a1 + 576);
}

//----- (08122EAC) --------------------------------------------------------
int __cdecl sub_8122EAC(int a1, int a2, int a3, int a4)
{
  return sub_81270E4((_DWORD *)(a1 + 300), a2, a3, a4);
}

//----- (08122EDA) --------------------------------------------------------
int __cdecl sub_8122EDA(int a1, int a2, int a3, int a4)
{
  return sub_81270E4((_DWORD *)(a1 + 312), a2, a3, a4);
}

//----- (08122F08) --------------------------------------------------------
long double __cdecl sub_8122F08(int a1, int a2, int a3, float a4)
{
  float v4; // ST04_4
  float v5; // ST1C_4
  float v7; // [esp+14h] [ebp-34h]
  float v8; // [esp+1Ch] [ebp-2Ch]
  int v9; // [esp+20h] [ebp-28h]
  char v10; // [esp+30h] [ebp-18h]

  sub_81271AA((float *)(a1 + 124), (float *)a2, (float *)&v10);
  v8 = sub_812727A((float *)&v10, (float *)a3);
  v4 = v8 - a4;
  if ( sub_8126F5E(v4) <= a4 )
  {
    sub_8127226(a2, v8, a3, (int)&v9);
    v5 = sub_80A1DB2((float *)(a1 + 124), (float *)&v9);
    if ( *(float *)(a1 + 136) * *(float *)(a1 + 136) <= (long double)v5 )
      v7 = 1.0;
    else
      v7 = 1.0 - (long double)*(unsigned __int8 *)(a1 + 147) * 0.0039215689;
  }
  else
  {
    v7 = 1.0;
  }
  return v7;
}

//----- (08122FEA) --------------------------------------------------------
signed int __cdecl sub_8122FEA(int a1)
{
  float *v1; // ST18_4
  signed int result; // eax

  v1 = (float *)((char *)&unk_89AD700 + 20 * dword_89AD6A0++);
  sub_8127108((_DWORD *)(a1 + 124), v1);
  v1[3] = *(float *)(a1 + 136) * *(float *)(a1 + 136);
  result = *(unsigned __int8 *)(a1 + 147);
  v1[4] = 1.0 - (long double)result * 0.0039215689;
  return result;
}
// 89AD6A0: using guessed type int dword_89AD6A0;

//----- (08123068) --------------------------------------------------------
long double __cdecl sub_8123068(int a1, float a2, float a3)
{
  float v4; // [esp+4h] [ebp-4h]

  v4 = a2 / a3;
  if ( v4 > 1.0 )
    v4 = 1.0;
  return v4;
}

//----- (0812309A) --------------------------------------------------------
_BOOL4 __cdecl sub_812309A(int a1, int a2, float a3)
{
  _BOOL4 v4; // [esp+4h] [ebp-4h]

  if ( *(float *)(a2 + 8) <= 0.0 || sub_8127318((float *)a1) >= 16.0 )
    v4 = a3 == 0.0;
  else
    v4 = 1;
  return v4;
}

//----- (08123100) --------------------------------------------------------
int __cdecl sub_8123100(int a1)
{
  int result; // eax

  *(_DWORD *)(a1 + 168) &= 0xFFFFF7DF;
  result = *(_DWORD *)(a1 + 168) | 0x1000000;
  *(_DWORD *)(a1 + 168) = result;
  return result;
}

//----- (08123134) --------------------------------------------------------
int __cdecl sub_8123134(int a1, int a2, float a3, int a4, float a5, int a6)
{
  float v7; // ST04_4
  char v8; // [esp+10h] [ebp-48h]
  float v9; // [esp+2Ch] [ebp-2Ch]
  int v10; // [esp+30h] [ebp-28h]
  int v11; // [esp+40h] [ebp-18h]

  if ( (unsigned __int8)sub_812309A(a4, a6, a5) )
    return sub_8123100(a1);
  if ( a2 )
    sub_80B6998((float *)a2, (float *)a6, (float *)&v11);
  else
    sub_8127108((_DWORD *)a6, &v11);
  sub_8123EA4(a1, a3, (int)&v10, a2);
  sub_81271AA((float *)&v10, (float *)(a1 + 196), (float *)&v8);
  sub_81271EE((int)&v10, *(float *)(a1 + 256), (int)&v10);
  sub_81271AA((float *)&v10, (float *)&v8, (float *)(a1 + 196));
  v9 = sub_812727A((float *)&v10, (float *)&v11);
  v7 = v9 * -2.0;
  return sub_8127226(a1 + 196, v7, (int)&v11, a1 + 196);
}

//----- (0812325E) --------------------------------------------------------
_BOOL4 __cdecl sub_812325E(int a1)
{
  if ( *(_BYTE *)(a1 + 35) )
    return 0;
  if ( *(_BYTE *)(a1 + 34) )
    return 0;
  return *(float *)a1 != 1.0;
}

//----- (081232B2) --------------------------------------------------------
signed int __cdecl sub_81232B2(int a1, float *a2)
{
  float v2; // ST3C_4
  float v3; // ST08_4
  float v4; // ST3C_4
  signed int v6; // [esp+2Ch] [ebp-BCh]
  float v7; // [esp+30h] [ebp-B8h]
  float v8; // [esp+34h] [ebp-B4h]
  float v9; // [esp+3Ch] [ebp-ACh]
  int v10; // [esp+40h] [ebp-A8h]
  int v11; // [esp+50h] [ebp-98h]
  int v12; // [esp+60h] [ebp-88h]
  int v13; // [esp+70h] [ebp-78h]
  int v14; // [esp+80h] [ebp-68h]
  int v15; // [esp+90h] [ebp-58h]
  int v16; // [esp+A0h] [ebp-48h]
  float s; // [esp+B0h] [ebp-38h]
  int v18; // [esp+B4h] [ebp-34h]

  if ( *(_DWORD *)(a1 + 168) & 0x1000000 )
    return 1;
  if ( !*(_DWORD *)(off_8168620 + 12) )
    return 1;
  v9 = (long double)*(signed int *)(off_8168620 + 12) * 0.001;
  v7 = (long double)sub_8122490(a1) * 0.001;
  v8 = (long double)sub_8127896(a1) * 0.001;
  v2 = sub_8123068(a1, v7, v8);
  sub_8123EA4(a1, v2, (int)&v15, (int)a2);
  sub_8127226(a1 + 4, v9, (int)&v15, (int)&v16);
  if ( *(_DWORD *)(a1 + 168) & 0x20
    && (!a2 ? (sub_8127108((_DWORD *)(a1 + 4), &v12), sub_8127108(&v16, &v11)) : (sub_80B6758(
                                                                                    a2,
                                                                                    (float *)(a1 + 4),
                                                                                    (float *)&v12),
                                                                                  sub_80B6758(
                                                                                    a2,
                                                                                    (float *)&v16,
                                                                                    (float *)&v11)),
        !(*(_DWORD *)(a1 + 168) & 0x40) ? sub_812AD4E(
                                            off_8168620,
                                            &s,
                                            (int)&v12,
                                            (int)&unk_8145E68,
                                            (int)&unk_8145E68,
                                            (int)&v11,
                                            -1,
                                            1) : (sub_8127108((_DWORD *)(a1 + 20), &v14),
                                                  sub_8127108((_DWORD *)(a1 + 32), &v13),
                                                  sub_812AD4E(
                                                    off_8168620,
                                                    &s,
                                                    (int)&v12,
                                                    (int)&v14,
                                                    (int)&v13,
                                                    (int)&v11,
                                                    -1,
                                                    1)),
        (unsigned __int8)sub_812325E((int)&s)) )
  {
    if ( *(_DWORD *)(a1 + 168) & 0x800 )
    {
      sub_80DEB7A((int)&v12, (int)&v11, s, (int)&v10);
      sub_8128900((int *)dword_89A2814, *(_DWORD **)(a1 + 44), (float *)&v10, &v18);
    }
    if ( *(_DWORD *)(a1 + 168) & 0x400 )
    {
      v6 = 0;
    }
    else
    {
      v3 = v9 * s + v7;
      v4 = sub_8123068(a1, v3, v8);
      sub_8123134(a1, (int)a2, v4, (int)&v15, s, (int)&v18);
      sub_80DEB7A(a1 + 4, (int)&v16, s, a1 + 4);
      v6 = 1;
    }
  }
  else
  {
    sub_8127108(&v16, (_DWORD *)(a1 + 4));
    v6 = 1;
  }
  return v6;
}

//----- (08123660) --------------------------------------------------------
int __cdecl sub_8123660(int a1, float a2, int a3, int a4)
{
  int result; // eax
  float v5; // [esp+20h] [ebp-18h]
  float v6; // [esp+24h] [ebp-14h]
  float v7; // [esp+28h] [ebp-10h]

  if ( *(_DWORD *)(a1 + 168) & 0x80000 )
  {
    v5 = sub_8127604(a1 + 444, a1 + 480, *(float *)(a1 + 300), a2);
    v6 = sub_8127604(a1 + 456, a1 + 492, *(float *)(a1 + 304), a2);
    v7 = sub_8127604(a1 + 468, a1 + 504, *(float *)(a1 + 308), a2);
  }
  else
  {
    v5 = sub_81275A6(a1 + 444, a2);
    v6 = sub_81275A6(a1 + 456, a2);
    v7 = sub_81275A6(a1 + 468, a2);
  }
  if ( *(_DWORD *)(a1 + 168) & 0x200000 )
  {
    if ( a4 )
      result = sub_80B6998((float *)a4, &v5, (float *)a3);
    else
      result = sub_8127108(&v5, (_DWORD *)a3);
  }
  else if ( a4 )
  {
    result = sub_8127108(&v5, (_DWORD *)a3);
  }
  else
  {
    result = sub_80A70C0(a1 + 208, v5, v6, v7, a3);
  }
  return result;
}

//----- (081237F4) --------------------------------------------------------
int __cdecl sub_81237F4(int a1, float a2, int a3, int a4)
{
  int result; // eax
  float v5; // [esp+20h] [ebp-18h]
  float v6; // [esp+24h] [ebp-14h]
  float v7; // [esp+28h] [ebp-10h]

  if ( *(_DWORD *)(a1 + 168) & 0x100000 )
  {
    v5 = sub_8127604(a1 + 516, a1 + 552, *(float *)(a1 + 312), a2);
    v6 = sub_8127604(a1 + 528, a1 + 564, *(float *)(a1 + 316), a2);
    v7 = sub_8127604(a1 + 540, a1 + 576, *(float *)(a1 + 320), a2);
  }
  else
  {
    v5 = sub_81275A6(a1 + 516, a2);
    v6 = sub_81275A6(a1 + 528, a2);
    v7 = sub_81275A6(a1 + 540, a2);
  }
  if ( *(_DWORD *)(a1 + 168) & 0x400000 )
  {
    if ( a4 )
      result = sub_80B6998((float *)a4, &v5, (float *)a3);
    else
      result = sub_8127108(&v5, (_DWORD *)a3);
  }
  else if ( a4 )
  {
    result = sub_8127108(&v5, (_DWORD *)a3);
  }
  else
  {
    result = sub_80A70C0(a1 + 208, v5, v6, v7, a3);
  }
  return result;
}

//----- (08123988) --------------------------------------------------------
int __cdecl sub_8123988(int a1, float a2, int a3, int a4)
{
  int v4; // ST00_4
  int result; // eax
  float v6[6]; // [esp+20h] [ebp-18h]

  v4 = sub_8127896(a1);
  sub_8123D1E(a1, (signed int)((long double)v4 * a2), (int)v6);
  if ( a4 )
    result = sub_80B6998((float *)a4, v6, (float *)a3);
  else
    result = sub_8127108(v6, (_DWORD *)a3);
  return result;
}

//----- (08123A0A) --------------------------------------------------------
int __cdecl sub_8123A0A(int a1, float a2, int a3)
{
  float v3; // ST08_4
  float v5; // [esp+20h] [ebp-18h]
  float v6; // [esp+24h] [ebp-14h]
  float v7; // [esp+28h] [ebp-10h]

  if ( *(_DWORD *)(a1 + 168) & 0x80000 )
  {
    v5 = sub_8127702(a1 + 444, a1 + 480, *(float *)(a1 + 300), a2);
    v6 = sub_8127702(a1 + 456, a1 + 492, *(float *)(a1 + 304), a2);
    v7 = sub_8127702(a1 + 468, a1 + 504, *(float *)(a1 + 308), a2);
  }
  else
  {
    v5 = sub_81276E0(a1 + 444, a2);
    v6 = sub_81276E0(a1 + 456, a2);
    v7 = sub_81276E0(a1 + 468, a2);
  }
  if ( *(_DWORD *)(a1 + 168) & 0x200000 )
    sub_8127108(&v5, (_DWORD *)a3);
  else
    sub_80A70C0(a1 + 208, v5, v6, v7, a3);
  v3 = (long double)sub_8127896(a1) * 0.001;
  return sub_81271EE(a3, v3, a3);
}

//----- (08123B94) --------------------------------------------------------
int __cdecl sub_8123B94(int a1, float a2, int a3)
{
  float v3; // ST08_4
  float v5; // [esp+20h] [ebp-18h]
  float v6; // [esp+24h] [ebp-14h]
  float v7; // [esp+28h] [ebp-10h]

  if ( *(_DWORD *)(a1 + 168) & 0x80000 )
  {
    v5 = sub_8127702(a1 + 516, a1 + 552, *(float *)(a1 + 312), a2);
    v6 = sub_8127702(a1 + 528, a1 + 564, *(float *)(a1 + 316), a2);
    v7 = sub_8127702(a1 + 540, a1 + 576, *(float *)(a1 + 320), a2);
  }
  else
  {
    v5 = sub_81276E0(a1 + 516, a2);
    v6 = sub_81276E0(a1 + 528, a2);
    v7 = sub_81276E0(a1 + 540, a2);
  }
  if ( *(_DWORD *)(a1 + 168) & 0x400000 )
    sub_8127108(&v5, (_DWORD *)a3);
  else
    sub_80A70C0(a1 + 208, v5, v6, v7, a3);
  v3 = (long double)sub_8127896(a1) * 0.001;
  return sub_81271EE(a3, v3, a3);
}

//----- (08123D1E) --------------------------------------------------------
int __cdecl sub_8123D1E(int a1, signed int a2, int a3)
{
  int result; // eax

  *(_DWORD *)a3 = 0;
  *(_DWORD *)(a3 + 4) = 0;
  result = a1;
  *(float *)(a3 + 8) = (long double)a2 * *(float *)(a1 + 244) * 0.001;
  return result;
}

//----- (08123D56) --------------------------------------------------------
int __cdecl sub_8123D56(int a1, signed int a2, float *a3)
{
  float v3; // ST1C_4
  float v4; // ST04_4
  float v6; // [esp+1Ch] [ebp-4Ch]
  int v7; // [esp+20h] [ebp-48h]
  int v8; // [esp+30h] [ebp-38h]
  int v9; // [esp+40h] [ebp-28h]
  float v10; // [esp+58h] [ebp-10h]
  int v11; // [esp+5Ch] [ebp-Ch]

  v11 = sub_8127896(a1);
  if ( a2 >= v11 )
  {
    v6 = 1.0;
  }
  else
  {
    v3 = (long double)a2;
    v6 = v3 / (long double)v11;
  }
  v10 = v6;
  sub_8123A0A(a1, v6, (int)&v9);
  sub_8123B94(a1, v10, (int)&v8);
  sub_8123D1E(a1, a2, (int)&v7);
  v4 = (long double)a2 * 0.001;
  sub_81271EE((int)&v7, v4, (int)&v7);
  sub_8127166((float *)&v9, (float *)&v8, a3);
  return sub_8127166(a3, (float *)&v7, a3);
}

//----- (08123E30) --------------------------------------------------------
int __cdecl sub_8123E30(int a1, _DWORD *a2)
{
  _DWORD *v2; // eax
  int v4; // [esp+14h] [ebp-4h]

  if ( (unsigned __int8)sub_812782E((_DWORD *)(a1 + 192)) )
  {
    v2 = (_DWORD *)sub_812787E(a1 + 192);
    v4 = sub_8122008(v2);
    if ( !v4 )
      return sub_81270BA(a2);
  }
  else
  {
    v4 = 0;
  }
  return sub_8123EA4(a1, 0.0, (int)a2, v4);
}

//----- (08123EA4) --------------------------------------------------------
int __cdecl sub_8123EA4(int a1, float a2, int a3, int a4)
{
  int v5; // [esp+10h] [ebp-38h]
  int v6; // [esp+20h] [ebp-28h]
  int v7; // [esp+30h] [ebp-18h]

  sub_8123660(a1, a2, (int)&v7, a4);
  sub_81237F4(a1, a2, (int)&v6, a4);
  sub_8123988(a1, a2, (int)&v5, a4);
  sub_8127166((float *)&v7, (float *)&v6, (float *)a3);
  sub_8127166((float *)a3, (float *)&v5, (float *)a3);
  return sub_8127166((float *)a3, (float *)(a1 + 196), (float *)a3);
}

//----- (08123F5C) --------------------------------------------------------
void __cdecl sub_8123F5C(int a1)
{
  if ( *(_WORD *)(a1 + 168) >= 0 )
    *(float *)(a1 + 136) = sub_81275A6(a1 + 372, *(float *)(a1 + 60));
  else
    *(float *)(a1 + 136) = sub_8127604(a1 + 372, a1 + 384, *(float *)(a1 + 288), *(float *)(a1 + 60));
}

//----- (08123FE0) --------------------------------------------------------
void __cdecl sub_8123FE0(int a1)
{
  if ( *(_BYTE *)(a1 + 260) )
  {
    if ( *(_DWORD *)(a1 + 168) & 0x10000 )
      *(float *)(a1 + 140) = sub_8127604(a1 + 396, a1 + 408, *(float *)(a1 + 292), *(float *)(a1 + 60));
    else
      *(float *)(a1 + 140) = sub_81275A6(a1 + 396, *(float *)(a1 + 60));
  }
  else
  {
    *(_DWORD *)(a1 + 140) = *(_DWORD *)(a1 + 136);
  }
}

//----- (08124080) --------------------------------------------------------
void __cdecl sub_8124080(int a1)
{
  int v1; // [esp+20h] [ebp-18h]

  if ( *(_DWORD *)(a1 + 168) & 0x2000 )
    sub_8127650(a1 + 324, a1 + 336, *(float *)(a1 + 280), (int)&v1, *(float *)(a1 + 60));
  else
    sub_81275C6(a1 + 324, (int)&v1, *(float *)(a1 + 60));
  sub_8121E7C((int)&v1, a1 + 144);
}

//----- (0812410E) --------------------------------------------------------
int __cdecl sub_812410E(int a1)
{
  int result; // eax
  float v2; // [esp+24h] [ebp-4h]
  float v3; // [esp+24h] [ebp-4h]

  if ( *(_DWORD *)(a1 + 168) & 0x4000 )
    v2 = sub_8127604(a1 + 348, a1 + 360, *(float *)(a1 + 284), *(float *)(a1 + 60));
  else
    v2 = sub_81275A6(a1 + 348, *(float *)(a1 + 60));
  v3 = sub_8126FC2(v2, 0.0, 1.0);
  if ( *(_BYTE *)(a1 + 168) >= 0 )
  {
    *(_BYTE *)(a1 + 144) = (signed __int16)((long double)*(unsigned __int8 *)(a1 + 144) * v3);
    *(_BYTE *)(a1 + 145) = (signed __int16)((long double)*(unsigned __int8 *)(a1 + 145) * v3);
    *(_BYTE *)(a1 + 146) = (signed __int16)((long double)*(unsigned __int8 *)(a1 + 146) * v3);
    result = a1;
    *(_BYTE *)(a1 + 147) = -1;
  }
  else
  {
    result = (unsigned __int16)(signed __int16)(v3 * 255.0);
    *(_BYTE *)(a1 + 147) = result;
  }
  return result;
}

//----- (0812427C) --------------------------------------------------------
int __cdecl sub_812427C(int a1)
{
  int result; // eax
  float v2; // [esp+14h] [ebp-4h]

  if ( *(_DWORD *)(a1 + 168) & 0x40000 )
    v2 = sub_8127604(a1 + 420, a1 + 432, *(float *)(a1 + 296), *(float *)(a1 + 60));
  else
    v2 = sub_81275A6(a1 + 420, *(float *)(a1 + 60));
  result = off_8168620;
  *(float *)(a1 + 68) = (long double)*(signed int *)(off_8168620 + 12) * 0.0099999998 * v2 + *(float *)(a1 + 68);
  return result;
}

//----- (0812430C) --------------------------------------------------------
int __cdecl sub_812430C(int a1)
{
  int v1; // ST08_4
  int result; // eax
  int v3; // [esp+1Ch] [ebp-Ch]

  v1 = *(_DWORD *)(a1 + 64);
  v3 = sub_812AE52();
  if ( v3 == 1 )
  {
    result = a1;
    *(_DWORD *)(a1 + 148) = 0;
  }
  else
  {
    *(_DWORD *)(a1 + 148) = *(_DWORD *)(a1 + 264)
                          + (signed int)((long double)(*(_DWORD *)(off_8168620 + 4) - *(_DWORD *)(a1 + 184))
                                       * *(float *)(a1 + 268));
    if ( *(_DWORD *)(a1 + 272) )
    {
      result = a1;
      if ( *(_DWORD *)(a1 + 272) == 1 )
      {
        if ( *(_DWORD *)(a1 + 276) <= 0 )
        {
          result = *(_DWORD *)(a1 + 148);
          if ( result >= v3 )
          {
            result = v3 - 1;
            *(_DWORD *)(a1 + 148) = v3 - 1;
          }
        }
        else
        {
          result = *(_DWORD *)(a1 + 148);
          if ( result >= v3 )
          {
            if ( *(_DWORD *)(a1 + 148) < v3 * (*(_DWORD *)(a1 + 276) + 1) )
            {
              result = *(_DWORD *)(a1 + 148) / v3;
              *(_DWORD *)(a1 + 148) %= v3;
            }
            else
            {
              *(_DWORD *)(a1 + 276) = 0;
              result = v3 - 1;
              *(_DWORD *)(a1 + 148) = v3 - 1;
            }
          }
        }
      }
    }
    else
    {
      result = *(_DWORD *)(a1 + 148);
      if ( result >= v3 )
      {
        result = *(_DWORD *)(a1 + 148) / v3;
        *(_DWORD *)(a1 + 148) %= v3;
      }
    }
  }
  return result;
}

//----- (0812447E) --------------------------------------------------------
signed int sub_812447E()
{
  return 1;
}

//----- (08124488) --------------------------------------------------------
_BYTE **__cdecl sub_8124488(char *a1, int *a2)
{
  sub_81224DC((int)a1, a2);
  sub_8127B04((int)a2, a1 + 196);
  sub_8127B04((int)a2, a1 + 208);
  sub_8127B04((int)a2, a1 + 220);
  sub_8127B04((int)a2, a1 + 232);
  sub_8127AE2((int)a2, a1 + 256);
  sub_8127A9E((int)a2, a1 + 260);
  sub_812107A((int)a2, (int)(a1 + 324));
  sub_812107A((int)a2, (int)(a1 + 336));
  sub_812107A((int)a2, (int)(a1 + 348));
  sub_812107A((int)a2, (int)(a1 + 360));
  sub_812107A((int)a2, (int)(a1 + 372));
  sub_812107A((int)a2, (int)(a1 + 384));
  sub_812107A((int)a2, (int)(a1 + 396));
  sub_812107A((int)a2, (int)(a1 + 408));
  sub_812107A((int)a2, (int)(a1 + 420));
  sub_812107A((int)a2, (int)(a1 + 432));
  sub_812107A((int)a2, (int)(a1 + 444));
  sub_812107A((int)a2, (int)(a1 + 456));
  sub_812107A((int)a2, (int)(a1 + 468));
  sub_812107A((int)a2, (int)(a1 + 480));
  sub_812107A((int)a2, (int)(a1 + 492));
  sub_812107A((int)a2, (int)(a1 + 504));
  sub_812107A((int)a2, (int)(a1 + 516));
  sub_812107A((int)a2, (int)(a1 + 528));
  sub_812107A((int)a2, (int)(a1 + 540));
  sub_812107A((int)a2, (int)(a1 + 552));
  sub_812107A((int)a2, (int)(a1 + 564));
  sub_812107A((int)a2, (int)(a1 + 576));
  sub_8127AC0((int)a2, a1 + 264);
  sub_8127AE2((int)a2, a1 + 268);
  sub_8127AC0((int)a2, a1 + 272);
  sub_8127AC0((int)a2, a1 + 276);
  sub_8127AE2((int)a2, a1 + 280);
  sub_8127AE2((int)a2, a1 + 284);
  sub_8127AE2((int)a2, a1 + 288);
  sub_8127AE2((int)a2, a1 + 292);
  sub_8127AE2((int)a2, a1 + 296);
  sub_8127B04((int)a2, a1 + 300);
  return sub_8127B04((int)a2, a1 + 312);
}

//----- (08124824) --------------------------------------------------------
int __cdecl sub_8124824(_DWORD *a1, _DWORD *a2)
{
  int result; // eax

  sub_8122668();
  a1[81] = a2[64];
  a1[84] = a2[67];
  a1[87] = a2[70];
  a1[90] = a2[73];
  a1[93] = a2[76];
  a1[96] = a2[79];
  a1[99] = a2[82];
  a1[102] = a2[85];
  a1[105] = a2[94];
  a1[108] = a2[97];
  a1[111] = a2[100];
  a1[114] = a2[103];
  a1[117] = a2[106];
  a1[120] = a2[109];
  a1[123] = a2[112];
  a1[126] = a2[115];
  a1[129] = a2[118];
  a1[132] = a2[121];
  a1[135] = a2[124];
  a1[138] = a2[127];
  a1[141] = a2[130];
  result = a2[133];
  a1[144] = result;
  return result;
}

//----- (081249E6) --------------------------------------------------------
_DWORD *__cdecl sub_81249E6(_DWORD *a1)
{
  _DWORD *result; // eax

  sub_81227C4(a1);
  result = a1;
  *a1 = off_8158428;
  return result;
}
// 8158428: using guessed type int (__cdecl *off_8158428[6])(int);

//----- (08124A02) --------------------------------------------------------
int __cdecl sub_8124A02(_DWORD *a1)
{
  *a1 = off_8158428;
  sub_812281C(a1);
  return 0;
}
// 8158428: using guessed type int (__cdecl *off_8158428[6])(int);

//----- (08124A36) --------------------------------------------------------
int __cdecl sub_8124A36(_DWORD *a1)
{
  *a1 = off_8158428;
  sub_812281C(a1);
  return 0;
}
// 8158428: using guessed type int (__cdecl *off_8158428[6])(int);

//----- (08124A6A) --------------------------------------------------------
int __cdecl sub_8124A6A(char *a1)
{
  *(_DWORD *)a1 = off_8158428;
  sub_812281C(a1);
  return sub_81279AE(a1);
}
// 8158428: using guessed type int (__cdecl *off_8158428[6])(int);

//----- (08124A9E) --------------------------------------------------------
int __cdecl sub_8124A9E(int a1)
{
  int v1; // eax

  v1 = sub_8122382(a1);
  return (unsigned __int8)sub_812AB74(off_8168620, (float *)(a1 + 124), *(float *)(a1 + 136), v1);
}

//----- (08124ADC) --------------------------------------------------------
void __cdecl sub_8124ADC(int a1)
{
  sub_812266E(a1, 7);
}

//----- (08124AF8) --------------------------------------------------------
signed int __cdecl sub_8124AF8(float *a1)
{
  float *v3; // [esp+14h] [ebp-4h]

  v3 = 0;
  if ( !(unsigned __int8)sub_81223CE((int)a1) )
    return 0;
  if ( !(unsigned __int8)sub_812232C((int)a1, (int *)&v3) )
    return 0;
  if ( !(unsigned __int8)sub_81232B2((int)a1, v3) )
    return 0;
  sub_8123F5C((int)a1);
  sub_8123FE0((int)a1);
  sub_8124080((int)a1);
  sub_812410E((int)a1);
  sub_812427C((int)a1);
  sub_812430C((int)a1);
  if ( v3 )
  {
    sub_80B6758(v3, a1 + 1, a1 + 31);
    sub_80B6806(v3, a1 + 147, a1 + 18);
  }
  else
  {
    sub_8127108((_DWORD *)a1 + 1, (_DWORD *)a1 + 31);
    sub_8127108((_DWORD *)a1 + 147, (_DWORD *)a1 + 18);
  }
  return 1;
}

//----- (08124C2C) --------------------------------------------------------
signed int sub_8124C2C()
{
  return 7;
}

//----- (08124C36) --------------------------------------------------------
_BYTE **__cdecl sub_8124C36(char *a1, int *a2)
{
  sub_8124488(a1, a2);
  return sub_8127B04((int)a2, a1 + 588);
}

//----- (08124C68) --------------------------------------------------------
void __cdecl sub_8124C68(_DWORD *a1)
{
  sub_81227C4(a1);
  *a1 = off_81583E8;
  sub_8124E0C((int)a1);
}
// 81583E8: using guessed type int (__cdecl *off_81583E8[2])(int);

//----- (08124CB6) --------------------------------------------------------
void __cdecl sub_8124CB6(_DWORD *a1)
{
  sub_81227C4(a1);
  *a1 = off_81583E8;
  sub_8124E0C((int)a1);
}
// 81583E8: using guessed type int (__cdecl *off_81583E8[2])(int);

//----- (08124D04) --------------------------------------------------------
int __cdecl sub_8124D04(_DWORD *a1)
{
  *a1 = off_81583E8;
  sub_812281C(a1);
  return 0;
}
// 81583E8: using guessed type int (__cdecl *off_81583E8[2])(int);

//----- (08124D38) --------------------------------------------------------
int __cdecl sub_8124D38(_DWORD *a1)
{
  *a1 = off_81583E8;
  sub_812281C(a1);
  return 0;
}
// 81583E8: using guessed type int (__cdecl *off_81583E8[2])(int);

//----- (08124D6C) --------------------------------------------------------
int __cdecl sub_8124D6C(char *a1)
{
  *(_DWORD *)a1 = off_81583E8;
  sub_812281C(a1);
  return sub_8127976(a1);
}
// 81583E8: using guessed type int (__cdecl *off_81583E8[2])(int);

//----- (08124DA0) --------------------------------------------------------
void sub_8124DA0()
{
  ;
}

//----- (08124DA6) --------------------------------------------------------
int __usercall sub_8124DA6@<eax>(long double a1@<st0>, float *a2)
{
  int v2; // esi
  float v3; // ST08_4

  v2 = sub_8122382((int)a2);
  sub_8126F78(a2[34], a2[35]);
  v3 = a1 + a2[38];
  return (unsigned __int8)sub_812AB74(off_8168620, a2 + 31, v3, v2);
}

//----- (08124E0C) --------------------------------------------------------
void __cdecl sub_8124E0C(int a1)
{
  int j; // [esp+14h] [ebp-14h]
  int i; // [esp+18h] [ebp-10h]
  float v3; // [esp+1Ch] [ebp-Ch]

  for ( i = 0; i != 4; ++i )
  {
    for ( j = 0; j != 3; ++j )
      *(float *)(a1 + 4 * j + 588) = sub_80A8720(-1.0, 1.0);
    v3 = sub_8127318((float *)(a1 + 588));
    if ( v3 >= 0.0099999998 && v3 <= 1.0 )
    {
      sub_80A20C0((float *)(a1 + 588));
      return;
    }
  }
  *(_DWORD *)(a1 + 588) = 1065353216;
  *(_DWORD *)(a1 + 592) = 0;
  *(_DWORD *)(a1 + 596) = 0;
}

//----- (08124EE4) --------------------------------------------------------
void __cdecl sub_8124EE4(int a1)
{
  sub_812266E(a1, 6);
}

//----- (08124F00) --------------------------------------------------------
void __cdecl sub_8124F00(int a1, int a2)
{
  sub_8122C3C(a1, a2);
  sub_8122C06(a2 + 352, a1 + 612);
  sub_8122C06(a2 + 364, a1 + 624);
}

//----- (08124F52) --------------------------------------------------------
void __cdecl sub_8124F52(int a1)
{
  if ( *(_BYTE *)(a1 + 604) )
  {
    if ( *(_DWORD *)(a1 + 168) & 0x20000 )
      *(float *)(a1 + 600) = sub_8127604(a1 + 612, a1 + 624, *(float *)(a1 + 608), *(float *)(a1 + 60));
    else
      *(float *)(a1 + 600) = sub_81275A6(a1 + 612, *(float *)(a1 + 60));
  }
}

//----- (08124FE0) --------------------------------------------------------
signed int __cdecl sub_8124FE0(int a1)
{
  float v2; // [esp+14h] [ebp-44h]
  char v4; // [esp+20h] [ebp-38h]
  int v5; // [esp+30h] [ebp-28h]
  float *v6; // [esp+4Ch] [ebp-Ch]

  v6 = 0;
  if ( !(unsigned __int8)sub_81223CE(a1) )
    return 0;
  if ( !(unsigned __int8)sub_812232C(a1, (int *)&v6) )
    return 0;
  sub_8127108((_DWORD *)(a1 + 4), &v4);
  if ( !(unsigned __int8)sub_81232B2(a1, v6) )
    return 0;
  sub_8123F5C(a1);
  sub_8123FE0(a1);
  sub_8124F52(a1);
  sub_8124080(a1);
  sub_812410E(a1);
  sub_812427C(a1);
  sub_80A58CC(*(float *)(a1 + 68), a1 + 588, (int)&v5);
  sub_80A54E2((float *)&v5, (float *)(a1 + 72));
  *(_DWORD *)(a1 + 152) = *(_DWORD *)(a1 + 136);
  *(_DWORD *)(a1 + 136) = *(_DWORD *)(a1 + 140);
  if ( *(_BYTE *)(a1 + 604) )
    v2 = *(float *)(a1 + 600);
  else
    v2 = *(float *)(a1 + 136);
  *(float *)(a1 + 140) = v2;
  if ( v6 )
    sub_80B6758(v6, (float *)(a1 + 4), (float *)(a1 + 124));
  else
    sub_8127108((_DWORD *)(a1 + 4), (_DWORD *)(a1 + 124));
  sub_8127108(&v4, (_DWORD *)(a1 + 156));
  return 1;
}

//----- (08125198) --------------------------------------------------------
signed int sub_8125198()
{
  return 12;
}

//----- (081251A2) --------------------------------------------------------
_BYTE **__cdecl sub_81251A2(char *a1, int *a2)
{
  sub_8124488(a1, a2);
  sub_8127B04((int)a2, a1 + 588);
  sub_812107A((int)a2, (int)(a1 + 612));
  sub_812107A((int)a2, (int)(a1 + 624));
  sub_8127AE2((int)a2, a1 + 608);
  return sub_8127A9E((int)a2, a1 + 604);
}

//----- (08125230) --------------------------------------------------------
int __cdecl sub_8125230(_DWORD *a1, _DWORD *a2)
{
  int result; // eax

  sub_8124824(a1, a2);
  a1[153] = a2[88];
  result = a2[91];
  a1[156] = result;
  return result;
}

//----- (0812528A) --------------------------------------------------------
_DWORD *__cdecl sub_812528A(_DWORD *a1)
{
  _DWORD *result; // eax

  sub_81227C4(a1);
  result = a1;
  *a1 = off_81583A8;
  return result;
}
// 81583A8: using guessed type int (__cdecl *off_81583A8[2])(int);

//----- (081252A6) --------------------------------------------------------
int __cdecl sub_81252A6(_DWORD *a1)
{
  *a1 = off_81583A8;
  sub_812281C(a1);
  return 0;
}
// 81583A8: using guessed type int (__cdecl *off_81583A8[2])(int);

//----- (081252DA) --------------------------------------------------------
int __cdecl sub_81252DA(_DWORD *a1)
{
  *a1 = off_81583A8;
  sub_812281C(a1);
  return 0;
}
// 81583A8: using guessed type int (__cdecl *off_81583A8[2])(int);

//----- (0812530E) --------------------------------------------------------
int __cdecl sub_812530E(char *a1)
{
  *(_DWORD *)a1 = off_81583A8;
  sub_812281C(a1);
  return sub_8127992(a1);
}
// 81583A8: using guessed type int (__cdecl *off_81583A8[2])(int);

//----- (08125342) --------------------------------------------------------
void sub_8125342()
{
  ;
}

//----- (08125348) --------------------------------------------------------
int __cdecl sub_8125348(float *a1)
{
  int v1; // eax

  v1 = sub_8122382((int)a1);
  return (unsigned __int8)sub_812AC82(off_8168620, a1 + 31, a1 + 39, a1[34], a1[34], v1);
}

//----- (081253A0) --------------------------------------------------------
void __cdecl sub_81253A0(int a1)
{
  sub_812266E(a1, 8);
}

//----- (081253BC) --------------------------------------------------------
signed int __cdecl sub_81253BC(float *a1)
{
  float *v3; // [esp+14h] [ebp-4h]

  v3 = 0;
  if ( !(unsigned __int8)sub_81223CE((int)a1) )
    return 0;
  if ( !(unsigned __int8)sub_812232C((int)a1, (int *)&v3) )
    return 0;
  if ( v3 )
  {
    sub_80B6758(v3, a1 + 1, a1 + 31);
    sub_80B6758(v3, a1 + 147, a1 + 39);
  }
  else
  {
    sub_8127108((_DWORD *)a1 + 1, (_DWORD *)a1 + 31);
    sub_8127108((_DWORD *)a1 + 147, (_DWORD *)a1 + 39);
  }
  sub_8123F5C((int)a1);
  sub_8124080((int)a1);
  sub_812410E((int)a1);
  return 1;
}

//----- (081254B2) --------------------------------------------------------
signed int sub_81254B2()
{
  return 2;
}

//----- (081254BC) --------------------------------------------------------
_BYTE **__cdecl sub_81254BC(char *a1, int *a2)
{
  sub_8124488(a1, a2);
  return sub_8127B04((int)a2, a1 + 588);
}

//----- (081254EE) --------------------------------------------------------
_DWORD *__cdecl sub_81254EE(_DWORD *a1)
{
  _DWORD *result; // eax

  sub_81227C4(a1);
  result = a1;
  *a1 = off_8158368;
  return result;
}
// 8158368: using guessed type int (__cdecl *off_8158368[6])(int);

//----- (0812550A) --------------------------------------------------------
_DWORD *__cdecl sub_812550A(_DWORD *a1)
{
  _DWORD *result; // eax

  sub_81227C4(a1);
  result = a1;
  *a1 = off_8158368;
  return result;
}
// 8158368: using guessed type int (__cdecl *off_8158368[6])(int);

//----- (08125526) --------------------------------------------------------
int __cdecl sub_8125526(_DWORD *a1)
{
  *a1 = off_8158368;
  sub_812281C(a1);
  return 0;
}
// 8158368: using guessed type int (__cdecl *off_8158368[6])(int);

//----- (0812555A) --------------------------------------------------------
int __cdecl sub_812555A(_DWORD *a1)
{
  *a1 = off_8158368;
  sub_812281C(a1);
  return 0;
}
// 8158368: using guessed type int (__cdecl *off_8158368[6])(int);

//----- (0812558E) --------------------------------------------------------
int __cdecl sub_812558E(char *a1)
{
  *(_DWORD *)a1 = off_8158368;
  sub_812281C(a1);
  return sub_81279CA(a1);
}
// 8158368: using guessed type int (__cdecl *off_8158368[6])(int);

//----- (081255C2) --------------------------------------------------------
void __cdecl sub_81255C2(float *a1)
{
  sub_81257C8((int)a1);
  sub_8125848(a1, 0);
}

//----- (081255E8) --------------------------------------------------------
int __cdecl sub_81255E8(float *a1)
{
  int v1; // eax

  v1 = sub_8122382((int)a1);
  return (unsigned __int8)sub_812AC82(off_8168620, a1 + 31, a1 + 39, a1[34], a1[34], v1);
}

//----- (08125640) --------------------------------------------------------
void __cdecl sub_8125640(int a1, int a2)
{
  sub_8122C3C(a1, a2);
  sub_8122C06(a2 + 352, a1 + 608);
  sub_8122C06(a2 + 364, a1 + 620);
}

//----- (08125692) --------------------------------------------------------
void __cdecl sub_8125692(int a1)
{
  sub_812266E(a1, 8);
}

//----- (081256AE) --------------------------------------------------------
signed int __cdecl sub_81256AE(int a1)
{
  float *v3; // [esp+14h] [ebp-4h]

  v3 = 0;
  if ( !(unsigned __int8)sub_81223CE(a1) )
    return 0;
  if ( !(unsigned __int8)sub_812232C(a1, (int *)&v3) )
    return 0;
  sub_8127108((_DWORD *)(a1 + 4), (_DWORD *)(a1 + 588));
  if ( !(unsigned __int8)sub_81232B2(a1, v3) )
    return 0;
  if ( v3 )
    sub_80B6758(v3, (float *)(a1 + 4), (float *)(a1 + 124));
  else
    sub_8127108((_DWORD *)(a1 + 4), (_DWORD *)(a1 + 124));
  sub_8123F5C(a1);
  sub_81257C8(a1);
  sub_8124080(a1);
  sub_812410E(a1);
  sub_812430C(a1);
  sub_8125848((float *)a1, v3);
  return 1;
}

//----- (081257C8) --------------------------------------------------------
void __cdecl sub_81257C8(int a1)
{
  if ( *(_DWORD *)(a1 + 168) & 0x20000 )
    *(float *)(a1 + 600) = sub_8127604(a1 + 608, a1 + 620, *(float *)(a1 + 604), *(float *)(a1 + 60));
  else
    *(float *)(a1 + 600) = sub_81275A6(a1 + 608, *(float *)(a1 + 60));
}

//----- (08125848) --------------------------------------------------------
void __cdecl sub_8125848(float *a1, float *a2)
{
  float v2; // ST04_4
  int v3; // [esp+10h] [ebp-28h]
  float v4; // [esp+2Ch] [ebp-Ch]

  sub_81271AA(a1 + 147, a1 + 1, (float *)&v3);
  v4 = sub_812734C(&v3);
  if ( v4 > 0.0 )
  {
    v2 = 1.0 / v4;
    sub_81271EE((int)&v3, v2, (int)&v3);
    if ( a2 )
    {
      sub_8127226((int)(a1 + 1), a1[150], (int)&v3, (int)&v3);
      sub_80B6758(a2, (float *)&v3, a1 + 39);
    }
    else
    {
      sub_8127226((int)(a1 + 1), a1[150], (int)&v3, (int)(a1 + 39));
    }
  }
}
// 812734C: using guessed type double __cdecl sub_812734C(_DWORD);

//----- (0812592A) --------------------------------------------------------
signed int sub_812592A()
{
  return 3;
}

//----- (08125934) --------------------------------------------------------
_BYTE **__cdecl sub_8125934(char *a1, int *a2)
{
  sub_8124488(a1, a2);
  sub_8127B04((int)a2, a1 + 588);
  sub_812107A((int)a2, (int)(a1 + 608));
  sub_812107A((int)a2, (int)(a1 + 620));
  return sub_8127AE2((int)a2, a1 + 604);
}

//----- (081259AA) --------------------------------------------------------
int __cdecl sub_81259AA(_DWORD *a1, _DWORD *a2)
{
  int result; // eax

  sub_8124824(a1, a2);
  a1[152] = a2[88];
  result = a2[91];
  a1[155] = result;
  return result;
}

//----- (08125A04) --------------------------------------------------------
_DWORD *__cdecl sub_8125A04(_DWORD *a1)
{
  _DWORD *result; // eax

  sub_81254EE(a1);
  result = a1;
  *a1 = off_8158328;
  return result;
}
// 8158328: using guessed type int (__cdecl *off_8158328[6])(int);

//----- (08125A20) --------------------------------------------------------
int __cdecl sub_8125A20(_DWORD *a1)
{
  *a1 = off_8158328;
  sub_8125526(a1);
  return 0;
}
// 8158328: using guessed type int (__cdecl *off_8158328[6])(int);

//----- (08125A54) --------------------------------------------------------
int __cdecl sub_8125A54(_DWORD *a1)
{
  *a1 = off_8158328;
  sub_8125526(a1);
  return 0;
}
// 8158328: using guessed type int (__cdecl *off_8158328[6])(int);

//----- (08125A88) --------------------------------------------------------
int __cdecl sub_8125A88(char *a1)
{
  *(_DWORD *)a1 = off_8158328;
  sub_8125526(a1);
  return sub_81279E6(a1);
}
// 8158328: using guessed type int (__cdecl *off_8158328[6])(int);

//----- (08125ABC) --------------------------------------------------------
int __cdecl sub_8125ABC(float *a1)
{
  int v1; // eax

  v1 = sub_8122382((int)a1);
  return (unsigned __int8)sub_812AC82(off_8168620, a1 + 31, a1 + 39, a1[35], a1[34], v1);
}

//----- (08125B14) --------------------------------------------------------
void __cdecl sub_8125B14(int a1)
{
  sub_812266E(a1, 9);
}

//----- (08125B30) --------------------------------------------------------
signed int __cdecl sub_8125B30(float *a1)
{
  int v3; // [esp+20h] [ebp-28h]
  float *v4; // [esp+3Ch] [ebp-Ch]

  v4 = 0;
  if ( !(unsigned __int8)sub_81223CE((int)a1) )
    return 0;
  if ( !(unsigned __int8)sub_812232C((int)a1, (int *)&v4) )
    return 0;
  sub_8123F5C((int)a1);
  sub_8123FE0((int)a1);
  sub_81257C8((int)a1);
  sub_8124080((int)a1);
  sub_812410E((int)a1);
  if ( v4 )
  {
    sub_80B6758(v4, a1 + 1, a1 + 31);
    sub_8127226((int)(a1 + 1), a1[150], (int)(a1 + 18), (int)&v3);
    sub_80B6758(v4, (float *)&v3, a1 + 39);
  }
  else
  {
    sub_8127108((_DWORD *)a1 + 1, (_DWORD *)a1 + 31);
    sub_8127226((int)(a1 + 1), a1[150], (int)(a1 + 18), (int)(a1 + 39));
  }
  return 1;
}

//----- (08125C78) --------------------------------------------------------
signed int sub_8125C78()
{
  return 4;
}

//----- (08125C82) --------------------------------------------------------
_BYTE **__cdecl sub_8125C82(char *a1, int *a2)
{
  return sub_8125934(a1, a2);
}

//----- (08125CB8) --------------------------------------------------------
_DWORD *__cdecl sub_8125CB8(_DWORD *a1)
{
  _DWORD *result; // eax

  sub_81227C4(a1);
  result = a1;
  *a1 = off_81582E8;
  return result;
}
// 81582E8: using guessed type int (__cdecl *off_81582E8[4])(int);

//----- (08125CD4) --------------------------------------------------------
int __cdecl sub_8125CD4(_DWORD *a1)
{
  *a1 = off_81582E8;
  sub_812281C(a1);
  return 0;
}
// 81582E8: using guessed type int (__cdecl *off_81582E8[4])(int);

//----- (08125D08) --------------------------------------------------------
int __cdecl sub_8125D08(_DWORD *a1)
{
  *a1 = off_81582E8;
  sub_812281C(a1);
  return 0;
}
// 81582E8: using guessed type int (__cdecl *off_81582E8[4])(int);

//----- (08125D3C) --------------------------------------------------------
int __cdecl sub_8125D3C(char *a1)
{
  *(_DWORD *)a1 = off_81582E8;
  sub_812281C(a1);
  return sub_8127A2E(a1);
}
// 81582E8: using guessed type int (__cdecl *off_81582E8[4])(int);

//----- (08125D70) --------------------------------------------------------
int sub_8125D70()
{
  return 0;
}

//----- (08125D7A) --------------------------------------------------------
void __cdecl sub_8125D7A(int a1)
{
  if ( *(_DWORD *)(a1 + 168) & 0x10 )
  {
    if ( *(float *)(a1 + 152) != 0.0 )
      sub_812266E(a1, 1);
  }
}

//----- (08125DBE) --------------------------------------------------------
signed int __cdecl sub_8125DBE(int a1)
{
  float v1; // ST08_4
  signed int i; // [esp+1Ch] [ebp-6Ch]
  char v5[48]; // [esp+20h] [ebp-68h]
  int v6; // [esp+50h] [ebp-38h]
  float v7[7]; // [esp+60h] [ebp-28h]
  float *v8; // [esp+7Ch] [ebp-Ch]

  v8 = 0;
  if ( !(unsigned __int8)sub_81223CE(a1) )
    return 0;
  if ( !(unsigned __int8)sub_812232C(a1, (int *)&v8) )
    return 0;
  sub_8127108((_DWORD *)(a1 + 4), v7);
  if ( !(unsigned __int8)sub_81232B2(a1, v8) )
    return 0;
  if ( (unsigned __int8)sub_81272AE(v7, (float *)(a1 + 4)) )
    sub_81271EE(a1 + 644, 0.69999999, a1 + 644);
  sub_81265F4(a1);
  sub_8123F5C(a1);
  if ( v8 )
    sub_81270BA(&v6);
  if ( *(_DWORD *)(a1 + 168) & 0x10 )
  {
    if ( v8 )
    {
      sub_80B6758(v8, (float *)(a1 + 4), (float *)(a1 + 124));
      for ( i = 0; i <= 2; ++i )
      {
        sub_8127108((_DWORD *)(a1 + 12 * i + 72), &v5[12 * i]);
        sub_80B6806(v8, (float *)&v5[12 * i], (float *)(a1 + 12 * i + 72));
      }
      *(_DWORD *)(a1 + 152) = *(_DWORD *)(a1 + 136);
      if ( *(_DWORD *)(a1 + 624) < *(_DWORD *)(off_8168620 + 4) )
      {
        sub_81271AA(v8, (float *)(a1 + 612), (float *)&v6);
        v1 = (long double)(*(_DWORD *)(off_8168620 + 4) - *(_DWORD *)(a1 + 624)) * 0.001;
        sub_81271EE((int)&v6, v1, (int)&v6);
      }
    }
    else
    {
      sub_8127108((_DWORD *)(a1 + 4), (_DWORD *)(a1 + 124));
      *(_DWORD *)(a1 + 152) = *(_DWORD *)(a1 + 136);
    }
  }
  sub_8126034(a1, (int)&v6, v8);
  return 1;
}
// 8125DBE: using guessed type char var_68[48];

//----- (08126034) --------------------------------------------------------
int __cdecl sub_8126034(int a1, int a2, float *a3)
{
  int result; // eax
  float v4; // ST08_4
  long double v5; // fst7
  int v6; // eax
  float v7; // ST08_4
  float v8; // ST38_4
  float v9; // ST30_4
  float v10; // ST04_4
  int v11; // ST2C_4
  float v12; // ST08_4
  float v13; // ST08_4
  float v14; // ST08_4
  float v15; // [esp+30h] [ebp-C8h]
  float v16; // [esp+38h] [ebp-C0h]
  float v17; // [esp+3Ch] [ebp-BCh]
  char v18; // [esp+40h] [ebp-B8h]
  float v19; // [esp+58h] [ebp-A0h]
  float v20; // [esp+5Ch] [ebp-9Ch]
  float v21; // [esp+60h] [ebp-98h]
  float v22; // [esp+64h] [ebp-94h]
  float v23; // [esp+68h] [ebp-90h]
  int v24; // [esp+6Ch] [ebp-8Ch]
  int v25; // [esp+70h] [ebp-88h]
  int i; // [esp+74h] [ebp-84h]
  float v27; // [esp+78h] [ebp-80h]
  float v28; // [esp+7Ch] [ebp-7Ch]
  int v29; // [esp+80h] [ebp-78h]
  int v30; // [esp+90h] [ebp-68h]
  char v31; // [esp+A0h] [ebp-58h]
  int v32[4]; // [esp+B0h] [ebp-48h]
  int v33; // [esp+C0h] [ebp-38h]
  int v34; // [esp+CCh] [ebp-2Ch]
  int v35; // [esp+D8h] [ebp-20h]

  result = *(_DWORD *)(a1 + 168) & 0x100;
  if ( result )
  {
    result = off_8168620;
    if ( *(_DWORD *)(off_8168620 + 12) )
    {
      v27 = *(float *)(a1 + 628) * *(float *)(a1 + 628);
      v24 = 0;
      v23 = 0.0;
      v25 = *(_DWORD *)(a1 + 624);
      v22 = (long double)sub_8122490(a1) * 0.001;
      v21 = (long double)sub_8127896(a1) * 0.001;
      while ( 1 )
      {
        result = v25;
        if ( v25 >= *(_DWORD *)(off_8168620 + 4) )
          break;
        v24 += 12;
        v28 = (long double)v24 * 0.001;
        sub_8127166((float *)(a1 + 588), (float *)(a1 + 612), (float *)&v31);
        v4 = v22 + v23;
        v20 = sub_8123068(a1, v4, v21);
        sub_8123EA4(a1, v20, (int)&v29, (int)a3);
        sub_8127226(a1 + 588, v28, (int)&v29, (int)v32);
        if ( a3 )
        {
          for ( i = 0; i <= 2; ++i )
            *(float *)&v32[i] = v28 * *(float *)(a2 + 4 * i) + *(float *)&v32[i];
        }
        v5 = sub_80A1DB2((float *)v32, (float *)&v31);
        if ( v27 <= v5 )
        {
          if ( a3 )
          {
            sub_80B6758(a3, (float *)v32, (float *)&v18);
            v6 = sub_812787E(a1 + 192);
            sub_8128ACC((int *)dword_89A2814, *(_DWORD **)(a1 + 656), (float *)&v18, 0, (_DWORD *)(v6 + 60));
          }
          else
          {
            v19 = sub_812734C(&v29);
            if ( v19 <= 0.0 )
            {
              sub_8127108((_DWORD *)(a1 + 72), &v33);
              sub_8127108((_DWORD *)(a1 + 84), &v34);
              sub_8127108((_DWORD *)(a1 + 96), &v35);
            }
            else
            {
              v7 = 1.0 / v19;
              sub_81271EE((int)&v29, v7, (int)&v33);
              sub_80A295E((int)&v33, (int)&v34, (float *)&v35);
            }
            sub_8128ACC((int *)dword_89A2814, *(_DWORD **)(a1 + 656), (float *)v32, &v33, 0);
          }
          v17 = sub_812727A((float *)&v29, (float *)&v29);
          v16 = (long double)v24 * 0.001;
          v15 = (v17 + v17) * v16;
          if ( v15 != 0.0 )
          {
            v8 = v16 * v16;
            v9 = v17 * v8 - v27;
            v10 = v9 / v15 * 1000.0;
            v11 = sub_8127084(v10);
            v24 -= v11;
            if ( v24 < v25 - *(_DWORD *)(a1 + 624) )
              v24 = v25 - *(_DWORD *)(a1 + 624);
            v28 = (long double)v24 * 0.001;
            v12 = v22 + v23 + v28;
            v20 = sub_8123068(a1, v12, v21);
            sub_8123EA4(a1, v20, (int)&v29, (int)a3);
            sub_8127226(a1 + 588, v28, (int)&v29, (int)v32);
          }
          v13 = v22 + v23 + v28;
          v20 = sub_8123068(a1, v13, v21);
          sub_8123EA4(a1, v20, (int)&v30, (int)a3);
          sub_8127108(v32, (_DWORD *)(a1 + 588));
          sub_8127108(&v30, (_DWORD *)(a1 + 600));
          if ( a3 )
          {
            v14 = (long double)v24 * 0.001;
            sub_8127226(a1 + 612, v14, a2, a1 + 612);
          }
          *(_DWORD *)(a1 + 624) += v24;
          v23 = v23 + v28;
          v24 = 0;
          v25 = *(_DWORD *)(a1 + 624);
          sub_8127A02((float *)a1);
          v27 = *(float *)(a1 + 628) * *(float *)(a1 + 628);
        }
        else
        {
          v25 += 12;
        }
      }
    }
  }
  return result;
}
// 812734C: using guessed type double __cdecl sub_812734C(_DWORD);
// 8126034: using guessed type int var_48[4];

//----- (081265F4) --------------------------------------------------------
int __cdecl sub_81265F4(int a1)
{
  float v1; // ST04_4

  v1 = (long double)*(signed int *)(off_8168620 + 12) * 0.0099999998;
  sub_8127226(a1 + 632, v1, a1 + 644, a1 + 632);
  return sub_80A7146((float *)(a1 + 632), a1 + 72);
}

//----- (08126652) --------------------------------------------------------
signed int sub_8126652()
{
  return 5;
}

//----- (0812665C) --------------------------------------------------------
int __cdecl sub_812665C(int a1, int *a2)
{
  int result; // eax

  sub_8124488((char *)a1, a2);
  sub_8127B04((int)a2, (char *)(a1 + 588));
  sub_8127B04((int)a2, (char *)(a1 + 600));
  sub_8127B04((int)a2, (char *)(a1 + 612));
  sub_8127AC0((int)a2, (char *)(a1 + 624));
  sub_8127AE2((int)a2, (char *)(a1 + 628));
  sub_8127B04((int)a2, (char *)(a1 + 632));
  sub_8127B04((int)a2, (char *)(a1 + 644));
  sub_8120FCA((int)a2, (const char ***)(a1 + 656));
  sub_8127AE2((int)a2, (char *)(a1 + 660));
  sub_8127AE2((int)a2, (char *)(a1 + 664));
  result = a1;
  if ( !*(_DWORD *)(a1 + 180) )
  {
    result = a1;
    *(_DWORD *)(a1 + 168) &= 0xFFFFFFEF;
  }
  return result;
}

//----- (0812677E) --------------------------------------------------------
_DWORD *__cdecl sub_812677E(_DWORD *a1)
{
  _DWORD *result; // eax

  sub_812222A(a1);
  result = a1;
  *a1 = off_81582A8;
  return result;
}
// 81582A8: using guessed type int (__cdecl *off_81582A8[2])(int);

//----- (0812679A) --------------------------------------------------------
_DWORD *__cdecl sub_812679A(_DWORD *a1)
{
  _DWORD *result; // eax

  sub_812222A(a1);
  result = a1;
  *a1 = off_81582A8;
  return result;
}
// 81582A8: using guessed type int (__cdecl *off_81582A8[2])(int);

//----- (081267B6) --------------------------------------------------------
int __cdecl sub_81267B6(_DWORD *a1)
{
  *a1 = off_81582A8;
  sub_812226E(a1);
  return 0;
}
// 81582A8: using guessed type int (__cdecl *off_81582A8[2])(int);

//----- (081267EA) --------------------------------------------------------
int __cdecl sub_81267EA(_DWORD *a1)
{
  *a1 = off_81582A8;
  sub_812226E(a1);
  return 0;
}
// 81582A8: using guessed type int (__cdecl *off_81582A8[2])(int);

//----- (0812681E) --------------------------------------------------------
int __cdecl sub_812681E(char *a1)
{
  *(_DWORD *)a1 = off_81582A8;
  sub_812226E(a1);
  return sub_81278CC(a1);
}
// 81582A8: using guessed type int (__cdecl *off_81582A8[2])(int);

//----- (08126852) --------------------------------------------------------
void __cdecl sub_8126852(int a1, int a2)
{
  sub_8122C06(a2 + 256, a1 + 204);
  sub_8122C06(a2 + 268, a1 + 216);
  sub_8122C06(a2 + 304, a1 + 228);
  sub_8122C06(a2 + 316, a1 + 240);
}

//----- (081268CA) --------------------------------------------------------
int __cdecl sub_81268CA(int a1)
{
  int v1; // eax

  v1 = sub_8122382(a1);
  return (unsigned __int8)sub_812AB74(off_8168620, (float *)(a1 + 124), *(float *)(a1 + 136), v1);
}

//----- (08126908) --------------------------------------------------------
void __cdecl sub_8126908(_DWORD *a1)
{
  int v1; // ST14_4
  int v2; // ST10_4
  int v3; // ST0C_4
  int v4; // ST08_4

  v1 = a1[29];
  v2 = a1[28];
  v3 = a1[27];
  v4 = a1[34];
  sub_812AE66();
}

//----- (08126952) --------------------------------------------------------
signed int __cdecl sub_8126952(int a1)
{
  float *v3; // [esp+14h] [ebp-4h]

  v3 = 0;
  if ( !(unsigned __int8)sub_81223CE(a1) )
    return 0;
  if ( !(unsigned __int8)sub_812232C(a1, (int *)&v3) )
    return 0;
  sub_81269F8(a1);
  sub_8126A7C(a1);
  if ( v3 )
    sub_80B6758(v3, (float *)(a1 + 4), (float *)(a1 + 124));
  else
    sub_8127108((_DWORD *)(a1 + 4), (_DWORD *)(a1 + 124));
  return 1;
}

//----- (081269F8) --------------------------------------------------------
void __cdecl sub_81269F8(int a1)
{
  if ( *(_WORD *)(a1 + 168) >= 0 )
    *(float *)(a1 + 136) = sub_81275A6(a1 + 228, *(float *)(a1 + 60));
  else
    *(float *)(a1 + 136) = sub_8127604(a1 + 228, a1 + 240, *(float *)(a1 + 200), *(float *)(a1 + 60));
}

//----- (08126A7C) --------------------------------------------------------
int __cdecl sub_8126A7C(int a1)
{
  int result; // eax

  if ( *(_DWORD *)(a1 + 168) & 0x2000 )
    result = sub_8127650(a1 + 204, a1 + 216, *(float *)(a1 + 196), a1 + 108, *(float *)(a1 + 60));
  else
    result = sub_81275C6(a1 + 204, a1 + 108, *(float *)(a1 + 60));
  return result;
}

//----- (08126AFA) --------------------------------------------------------
signed int sub_8126AFA()
{
  return 9;
}

//----- (08126B04) --------------------------------------------------------
_BYTE **__cdecl sub_8126B04(int a1, int *a2)
{
  sub_81224DC(a1, a2);
  sub_812107A((int)a2, a1 + 204);
  sub_812107A((int)a2, a1 + 216);
  sub_812107A((int)a2, a1 + 228);
  sub_812107A((int)a2, a1 + 240);
  sub_8127AE2((int)a2, (char *)(a1 + 196));
  return sub_8127AE2((int)a2, (char *)(a1 + 200));
}

//----- (08126BA8) --------------------------------------------------------
int __cdecl sub_8126BA8(_DWORD *a1, _DWORD *a2)
{
  int result; // eax

  sub_8122668();
  a1[51] = a2[64];
  a1[54] = a2[67];
  a1[57] = a2[76];
  result = a2[79];
  a1[60] = result;
  return result;
}

//----- (08126C0A) --------------------------------------------------------
signed int __cdecl sub_8126C0A(int a1)
{
  if ( !(unsigned __int8)sub_81223CE(a1) )
    return 0;
  sub_8126A7C(a1);
  return 1;
}

//----- (08126C40) --------------------------------------------------------
int __cdecl sub_8126C40(int a1)
{
  float v1; // ST1C_4
  int result; // eax
  float v3; // [esp+18h] [ebp-20h]
  float v4; // [esp+1Ch] [ebp-1Ch]
  char v5; // [esp+20h] [ebp-18h]

  sub_81271AA((float *)(a1 + 4), (float *)(off_8168620 + 20), (float *)&v5);
  v3 = sub_80A20C0((float *)&v5);
  v4 = sub_812727A((float *)&v5, (float *)(off_8168620 + 32));
  if ( v3 <= 600.0 && (v4 >= 0.5 || v3 <= 100.0) )
  {
    if ( v4 < 0.5 && v3 <= 100.0 )
      v4 = v4 + 1.1;
  }
  else
  {
    v4 = 0.0;
  }
  v1 = (1.0 - v3 * v3 / 360000.0) * v4;
  result = a1;
  *(float *)(a1 + 212) = *(float *)(a1 + 212) * v1;
  return result;
}

//----- (08126D3C) --------------------------------------------------------
void __cdecl sub_8126D3C(int a1)
{
  int v1; // ebx
  float v2[3]; // [esp+10h] [ebp-28h]
  int v3; // [esp+1Ch] [ebp-1Ch]
  int i; // [esp+2Ch] [ebp-Ch]

  for ( i = 0; i <= 2; ++i )
  {
    v1 = i;
    v2[v1] = sub_8127042(*(float *)(a1 + 4 * i + 108), 0.0, 1.0);
  }
  v3 = 1065353216;
  sub_812738A(v2, (_BYTE *)(a1 + 144));
  sub_8127108((_DWORD *)(off_8168620 + 20), (_DWORD *)(a1 + 124));
  sub_8127226(a1 + 124, 8.0, off_8168620 + 32, a1 + 124);
  *(_DWORD *)(a1 + 136) = 1094713344;
  *(_DWORD *)(a1 + 140) = *(_DWORD *)(a1 + 136);
  sub_812266E(a1, 4);
}
// 8126D3C: using guessed type float var_28[3];

//----- (08126E24) --------------------------------------------------------
signed int sub_8126E24()
{
  return 11;
}

//----- (08126E2E) --------------------------------------------------------
_BYTE **__cdecl sub_8126E2E(int a1, int *a2)
{
  return sub_8126B04(a1, a2);
}

//----- (08126E48) --------------------------------------------------------
_DWORD *__cdecl sub_8126E48(int a1, int a2)
{
  _DWORD *result; // eax

  if ( a2 == 0xFFFF && a1 == 1 )
    result = sub_8127B26(&unk_89A238C);
  if ( a2 == 0xFFFF && a1 == 1 )
    result = sub_8127B3E(&unk_89A2394);
  if ( a2 == 0xFFFF && a1 == 1 )
    result = sub_8127B56(&unk_89A239C);
  if ( a2 == 0xFFFF && a1 == 1 )
    result = sub_8127B6E(&unk_89A23A4);
  if ( a2 == 0xFFFF && a1 == 1 )
    result = sub_8127B86(&unk_89A23AC);
  if ( a2 == 0xFFFF && a1 == 1 )
    result = sub_8127B9E(&unk_89A23B4);
  if ( a2 == 0xFFFF && a1 == 1 )
    result = sub_8127BB6(&unk_89A23BC);
  if ( a2 == 0xFFFF && a1 == 1 )
    result = sub_8127BCE(&unk_89A23C4);
  if ( a2 == 0xFFFF && a1 == 1 )
    result = sub_8127BE6(&unk_89A23CC);
  if ( a2 == 0xFFFF && a1 == 1 )
    result = sub_8127BFE(&unk_89A23D4);
  return result;
}

//----- (08126F5E) --------------------------------------------------------
long double __cdecl sub_8126F5E(float a1)
{
  return (float)fabs(a1);
}

//----- (08126F78) --------------------------------------------------------
void __cdecl sub_8126F78(float a1, float a2)
{
  float v2; // ST00_4

  v2 = a1 - a2;
  sub_8127490(v2, a1, a2);
}

//----- (08126F9C) --------------------------------------------------------
int __cdecl sub_8126F9C(int a1, int a2)
{
  return sub_81274DA(a2 - a1, a1, a2);
}

//----- (08126FC2) --------------------------------------------------------
long double __cdecl sub_8126FC2(float a1, float a2, float a3)
{
  float v3; // ST00_4
  float v4; // ST08_4
  float v5; // ST00_4

  v3 = a1 - a3;
  v4 = sub_8127490(v3, a3, a1);
  v5 = a2 - a1;
  return sub_8127490(v5, a2, v4);
}

//----- (08127000) --------------------------------------------------------
int __cdecl sub_8127000(int a1, int a2, int a3)
{
  int v3; // eax

  v3 = sub_81274DA(a1 - a3, a3, a1);
  return sub_81274DA(a2 - a1, a2, v3);
}

//----- (08127042) --------------------------------------------------------
long double __cdecl sub_8127042(float a1, float a2, float a3)
{
  float v4; // [esp+0h] [ebp-4h]

  if ( a2 <= (long double)a1 )
  {
    if ( a1 <= (long double)a3 )
      v4 = a1;
    else
      v4 = a3;
  }
  else
  {
    v4 = a2;
  }
  return v4;
}

//----- (08127084) --------------------------------------------------------
int __cdecl sub_8127084(float a1)
{
  return (signed int)floor(a1 + 0.5);
}

//----- (081270BA) --------------------------------------------------------
int __cdecl sub_81270BA(_DWORD *a1)
{
  int result; // eax

  *a1 = 0;
  a1[1] = 0;
  result = 0;
  a1[2] = 0;
  return result;
}

//----- (081270E4) --------------------------------------------------------
int __cdecl sub_81270E4(_DWORD *a1, int a2, int a3, int a4)
{
  int result; // eax

  *a1 = a2;
  a1[1] = a3;
  result = a4;
  a1[2] = a4;
  return result;
}

//----- (08127108) --------------------------------------------------------
int __cdecl sub_8127108(_DWORD *a1, _DWORD *a2)
{
  int result; // eax

  *a2 = *a1;
  a2[1] = a1[1];
  result = a1[2];
  a2[2] = result;
  return result;
}

//----- (08127138) --------------------------------------------------------
int __cdecl sub_8127138(_DWORD *a1, _DWORD *a2)
{
  int result; // eax

  if ( a1 )
    result = sub_8127108(a1, a2);
  else
    result = sub_81270BA(a2);
  return result;
}

//----- (08127166) --------------------------------------------------------
int __cdecl sub_8127166(float *a1, float *a2, float *a3)
{
  int result; // eax

  *a3 = *a1 + *a2;
  a3[1] = a1[1] + a2[1];
  result = (int)(a1 + 2);
  a3[2] = a1[2] + a2[2];
  return result;
}

//----- (081271AA) --------------------------------------------------------
int __cdecl sub_81271AA(float *a1, float *a2, float *a3)
{
  int result; // eax

  *a3 = *a1 - *a2;
  a3[1] = a1[1] - a2[1];
  result = (int)(a1 + 2);
  a3[2] = a1[2] - a2[2];
  return result;
}

//----- (081271EE) --------------------------------------------------------
int __cdecl sub_81271EE(int a1, float a2, int a3)
{
  int result; // eax

  *(float *)a3 = a2 * *(float *)a1;
  *(float *)(a3 + 4) = a2 * *(float *)(a1 + 4);
  result = a1 + 8;
  *(float *)(a3 + 8) = a2 * *(float *)(a1 + 8);
  return result;
}

//----- (08127226) --------------------------------------------------------
int __cdecl sub_8127226(int a1, float a2, int a3, int a4)
{
  int result; // eax

  *(float *)a4 = a2 * *(float *)a3 + *(float *)a1;
  *(float *)(a4 + 4) = a2 * *(float *)(a3 + 4) + *(float *)(a1 + 4);
  result = a3 + 8;
  *(float *)(a4 + 8) = a2 * *(float *)(a3 + 8) + *(float *)(a1 + 8);
  return result;
}

//----- (0812727A) --------------------------------------------------------
long double __cdecl sub_812727A(float *a1, float *a2)
{
  return *a1 * *a2 + a1[1] * a2[1] + a1[2] * a2[2];
}

//----- (081272AE) --------------------------------------------------------
signed int __cdecl sub_81272AE(float *a1, float *a2)
{
  signed int v3; // [esp+0h] [ebp-4h]

  v3 = 0;
  if ( *a1 == *a2 && a1[1] == a2[1] && a1[2] == a2[2] )
    v3 = 1;
  return v3;
}

//----- (08127318) --------------------------------------------------------
long double __cdecl sub_8127318(float *a1)
{
  return *a1 * *a1 + a1[1] * a1[1] + a1[2] * a1[2];
}

//----- (0812734C) --------------------------------------------------------
void __cdecl sub_812734C(float *a1)
{
  float v1; // ST00_4

  v1 = *a1 * *a1 + a1[1] * a1[1] + a1[2] * a1[2];
  sub_81274BA(v1);
}

//----- (0812738A) --------------------------------------------------------
int __cdecl sub_812738A(float *a1, _BYTE *a2)
{
  float v2; // ST00_4
  int v3; // eax
  int v4; // eax
  float v5; // ST00_4
  int v6; // eax
  int v7; // eax
  float v8; // ST00_4
  int v9; // eax
  int v10; // eax
  float v11; // ST00_4
  int v12; // eax
  int v13; // eax
  int result; // eax

  v2 = *a1 * 255.0;
  v3 = sub_8127084(v2);
  v4 = sub_8126F9C(255, v3);
  *a2 = sub_81274FA(0, v4);
  v5 = a1[1] * 255.0;
  v6 = sub_8127084(v5);
  v7 = sub_8126F9C(255, v6);
  a2[1] = sub_81274FA(0, v7);
  v8 = a1[2] * 255.0;
  v9 = sub_8127084(v8);
  v10 = sub_8126F9C(255, v9);
  a2[2] = sub_81274FA(0, v10);
  v11 = a1[3] * 255.0;
  v12 = sub_8127084(v11);
  v13 = sub_8126F9C(255, v12);
  result = sub_81274FA(0, v13);
  a2[3] = result;
  return result;
}

//----- (08127490) --------------------------------------------------------
long double __cdecl sub_8127490(float a1, float a2, float a3)
{
  float v4; // [esp+0h] [ebp-4h]

  if ( a1 < 0.0 )
    v4 = a3;
  else
    v4 = a2;
  return v4;
}

//----- (081274BA) --------------------------------------------------------
long double __cdecl sub_81274BA(float a1)
{
  return (float)sqrt(a1);
}

//----- (081274DA) --------------------------------------------------------
int __cdecl sub_81274DA(int a1, int a2, int a3)
{
  int v4; // [esp+0h] [ebp-4h]

  if ( a1 < 0 )
    v4 = a3;
  else
    v4 = a2;
  return v4;
}

//----- (081274FA) --------------------------------------------------------
int __cdecl sub_81274FA(int a1, int a2)
{
  return sub_81274DA(a1 - a2, a1, a2);
}

//----- (08127520) --------------------------------------------------------
int __cdecl sub_8127520(int a1, int a2, float a3, int a4)
{
  int result; // eax

  *(float *)a4 = (*(float *)a2 - *(float *)a1) * a3 + *(float *)a1;
  *(float *)(a4 + 4) = (*(float *)(a2 + 4) - *(float *)(a1 + 4)) * a3 + *(float *)(a1 + 4);
  result = a2 + 8;
  *(float *)(a4 + 8) = (*(float *)(a2 + 8) - *(float *)(a1 + 8)) * a3 + *(float *)(a1 + 8);
  return result;
}

//----- (0812758A) --------------------------------------------------------
_DWORD *ctor_001()
{
  return sub_8126E48(1, 0xFFFF);
}

//----- (081275A6) --------------------------------------------------------
long double __cdecl sub_81275A6(int a1, float a2)
{
  return sub_8127C16(a1, a2) * *(float *)(a1 + 8);
}

//----- (081275C6) --------------------------------------------------------
int __cdecl sub_81275C6(int a1, int a2, float a3)
{
  sub_8127C62(a1, a2, a3);
  return sub_81271EE(a2, *(float *)(a1 + 8), a2);
}

//----- (08127604) --------------------------------------------------------
long double __cdecl sub_8127604(int a1, int a2, float a3, float a4)
{
  float v4; // ST10_4
  float v5; // ST14_4
  float v6; // ST10_4

  v4 = sub_8127C16(a1, a4);
  v5 = sub_8127C16(a2, a4);
  v6 = (v5 - v4) * a3 + v4;
  return v6 * *(float *)(a1 + 8);
}

//----- (08127650) --------------------------------------------------------
int __cdecl sub_8127650(int a1, int a2, float a3, int a4, float a5)
{
  int v6; // [esp+10h] [ebp-28h]
  int v7; // [esp+20h] [ebp-18h]

  sub_8127C62(a1, a4, a5);
  sub_8127C62(a2, (int)&v7, a5);
  sub_81271AA((float *)&v7, (float *)a4, (float *)&v6);
  sub_8127226(a4, a3, (int)&v6, a4);
  return sub_81271EE(a4, *(float *)(a1 + 8), a4);
}

//----- (081276E0) --------------------------------------------------------
long double __cdecl sub_81276E0(int a1, float a2)
{
  return sub_812197E(*(_DWORD *)a1, a2) * *(float *)(a1 + 8);
}

//----- (08127702) --------------------------------------------------------
long double __cdecl sub_8127702(int a1, int a2, float a3, float a4)
{
  float v4; // ST10_4
  float v5; // ST14_4
  float v6; // ST10_4

  v4 = sub_812197E(*(_DWORD *)a1, a4);
  v5 = sub_812197E(*(_DWORD *)a2, a4);
  v6 = (v5 - v4) * a3 + v4;
  return v6 * *(float *)(a1 + 8);
}

//----- (08127752) --------------------------------------------------------
void *__cdecl sub_8127752(int a1)
{
  return sub_8127CB8((int *)&unk_89A238C, a1);
}

//----- (0812776E) --------------------------------------------------------
int __cdecl sub_812776E(char *a1)
{
  return sub_8127DDE((int *)&unk_89A238C, a1);
}

//----- (0812778A) --------------------------------------------------------
_DWORD *__cdecl sub_812778A(_DWORD *a1)
{
  _DWORD *result; // eax

  result = a1;
  *a1 = 0;
  return result;
}

//----- (08127798) --------------------------------------------------------
_DWORD *__cdecl sub_8127798(_DWORD *a1, _DWORD *a2)
{
  _DWORD *result; // eax

  result = sub_8127CAA(a2);
  *a1 = result;
  return result;
}

//----- (081277B6) --------------------------------------------------------
int __cdecl sub_81277B6(int *a1)
{
  int result; // eax

  result = (int)a1;
  if ( *a1 )
    result = sub_8121FB2(*a1);
  return result;
}

//----- (081277D4) --------------------------------------------------------
_DWORD *__cdecl sub_81277D4(int *a1, _DWORD *a2)
{
  _DWORD *result; // eax

  result = (_DWORD *)*a1;
  if ( *a1 != *a2 )
  {
    if ( *a1 )
    {
      sub_8121FB2(*a1);
      *a1 = 0;
    }
    result = (_DWORD *)sub_812782E(a2);
    if ( (_BYTE)result )
    {
      result = sub_8127CAA((_DWORD *)*a2);
      *a1 = (int)result;
    }
  }
  return result;
}

//----- (0812782E) --------------------------------------------------------
_BOOL4 __cdecl sub_812782E(_DWORD *a1)
{
  return *a1 != 0;
}

//----- (08127840) --------------------------------------------------------
_DWORD *__cdecl sub_8127840(int *a1, _DWORD *a2)
{
  _DWORD *result; // eax

  result = (_DWORD *)*a1;
  if ( (_DWORD *)*a1 != a2 )
  {
    if ( *a1 )
      sub_8121FB2(*a1);
    result = sub_8127CAA(a2);
    *a1 = (int)result;
  }
  return result;
}

//----- (0812787E) --------------------------------------------------------
int __cdecl sub_812787E(int a1)
{
  return *(_DWORD *)a1;
}

//----- (08127888) --------------------------------------------------------
long double sub_8127888()
{
  return 1.0;
}

//----- (08127890) --------------------------------------------------------
void sub_8127890()
{
  ;
}

//----- (08127896) --------------------------------------------------------
int __cdecl sub_8127896(int a1)
{
  return *(_DWORD *)(a1 + 188) - *(_DWORD *)(a1 + 184);
}

//----- (081278B0) --------------------------------------------------------
int __cdecl sub_81278B0(char *a1)
{
  return sub_8127E76((int *)&unk_89A2394, a1);
}

//----- (081278CC) --------------------------------------------------------
int __cdecl sub_81278CC(char *a1)
{
  return sub_8127F0E((int *)&unk_89A239C, a1);
}

//----- (081278E8) --------------------------------------------------------
int __cdecl sub_81278E8(_DWORD *a1)
{
  *a1 = off_8158268;
  sub_81267B6(a1);
  return 0;
}
// 8158268: using guessed type int (__cdecl *off_8158268[2])(int);

//----- (0812791C) --------------------------------------------------------
int __cdecl sub_812791C(char *a1)
{
  *(_DWORD *)a1 = off_8158268;
  sub_81267B6(a1);
  return sub_81278CC(a1);
}
// 8158268: using guessed type int (__cdecl *off_8158268[2])(int);

//----- (08127950) --------------------------------------------------------
int sub_8127950()
{
  return 0;
}

//----- (0812795A) --------------------------------------------------------
int __cdecl sub_812795A(char *a1)
{
  return sub_8127FA6((int *)&unk_89A23A4, a1);
}

//----- (08127976) --------------------------------------------------------
int __cdecl sub_8127976(char *a1)
{
  return sub_812803E((int *)&unk_89A23D4, a1);
}

//----- (08127992) --------------------------------------------------------
int __cdecl sub_8127992(char *a1)
{
  return sub_81280D6((int *)&unk_89A23AC, a1);
}

//----- (081279AE) --------------------------------------------------------
int __cdecl sub_81279AE(char *a1)
{
  return sub_812816E((int *)&unk_89A23B4, a1);
}

//----- (081279CA) --------------------------------------------------------
int __cdecl sub_81279CA(char *a1)
{
  return sub_8128206((int *)&unk_89A23BC, a1);
}

//----- (081279E6) --------------------------------------------------------
int __cdecl sub_81279E6(char *a1)
{
  return sub_812829E((int *)&unk_89A23C4, a1);
}

//----- (08127A02) --------------------------------------------------------
float *__cdecl sub_8127A02(float *a1)
{
  long double v1; // fst7
  float *result; // eax

  v1 = sub_80A142E();
  result = a1;
  a1[157] = v1 * a1[166] + a1[165];
  return result;
}

//----- (08127A2E) --------------------------------------------------------
int __cdecl sub_8127A2E(char *a1)
{
  return sub_8128336((int *)&unk_89A23CC, a1);
}

//----- (08127A4A) --------------------------------------------------------
int __cdecl sub_8127A4A(int a1)
{
  return *(unsigned __int8 *)(a1 + 4);
}

//----- (08127A56) --------------------------------------------------------
int __cdecl sub_8127A56(int *a1)
{
  int v2; // [esp+14h] [ebp-4h]

  sub_8120968(a1, &v2, 4);
  return v2;
}

//----- (08127A7C) --------------------------------------------------------
int sub_8127A7C(int *a1, ...)
{
  va_list va; // [esp+24h] [ebp+Ch]

  va_start(va, a1);
  return sub_8120BFA(a1, (char *)va, 4);
}

//----- (08127A9E) --------------------------------------------------------
_BYTE **__cdecl sub_8127A9E(int a1, char *a2)
{
  return sub_8120F84(a1, a2, 1);
}

//----- (08127AC0) --------------------------------------------------------
_BYTE **__cdecl sub_8127AC0(int a1, char *a2)
{
  return sub_8120F84(a1, a2, 4);
}

//----- (08127AE2) --------------------------------------------------------
_BYTE **__cdecl sub_8127AE2(int a1, char *a2)
{
  return sub_8120F84(a1, a2, 4);
}

//----- (08127B04) --------------------------------------------------------
_BYTE **__cdecl sub_8127B04(int a1, char *a2)
{
  return sub_8120F84(a1, a2, 12);
}

//----- (08127B26) --------------------------------------------------------
_DWORD *__cdecl sub_8127B26(_DWORD *a1)
{
  _DWORD *result; // eax

  *a1 = 481;
  result = a1;
  a1[1] = 0;
  return result;
}

//----- (08127B3E) --------------------------------------------------------
_DWORD *__cdecl sub_8127B3E(_DWORD *a1)
{
  _DWORD *result; // eax

  *a1 = 167;
  result = a1;
  a1[1] = 0;
  return result;
}

//----- (08127B56) --------------------------------------------------------
_DWORD *__cdecl sub_8127B56(_DWORD *a1)
{
  _DWORD *result; // eax

  *a1 = 129;
  result = a1;
  a1[1] = 0;
  return result;
}

//----- (08127B6E) --------------------------------------------------------
_DWORD *__cdecl sub_8127B6E(_DWORD *a1)
{
  _DWORD *result; // eax

  *a1 = 55;
  result = a1;
  a1[1] = 0;
  return result;
}

//----- (08127B86) --------------------------------------------------------
_DWORD *__cdecl sub_8127B86(_DWORD *a1)
{
  _DWORD *result; // eax

  *a1 = 54;
  result = a1;
  a1[1] = 0;
  return result;
}

//----- (08127B9E) --------------------------------------------------------
_DWORD *__cdecl sub_8127B9E(_DWORD *a1)
{
  _DWORD *result; // eax

  *a1 = 54;
  result = a1;
  a1[1] = 0;
  return result;
}

//----- (08127BB6) --------------------------------------------------------
_DWORD *__cdecl sub_8127BB6(_DWORD *a1)
{
  _DWORD *result; // eax

  *a1 = 51;
  result = a1;
  a1[1] = 0;
  return result;
}

//----- (08127BCE) --------------------------------------------------------
_DWORD *__cdecl sub_8127BCE(_DWORD *a1)
{
  _DWORD *result; // eax

  *a1 = 51;
  result = a1;
  a1[1] = 0;
  return result;
}

//----- (08127BE6) --------------------------------------------------------
_DWORD *__cdecl sub_8127BE6(_DWORD *a1)
{
  _DWORD *result; // eax

  *a1 = 49;
  result = a1;
  a1[1] = 0;
  return result;
}

//----- (08127BFE) --------------------------------------------------------
_DWORD *__cdecl sub_8127BFE(_DWORD *a1)
{
  _DWORD *result; // eax

  *a1 = 51;
  result = a1;
  a1[1] = 0;
  return result;
}

//----- (08127C16) --------------------------------------------------------
long double __cdecl sub_8127C16(int a1, float a2)
{
  sub_8128426(a1, a2);
  return (float)sub_8121A60(*(_DWORD *)a1 + 8 * *(_DWORD *)(a1 + 4) + 8, a2);
}

//----- (08127C62) --------------------------------------------------------
int __cdecl sub_8127C62(int a1, int a2, float a3)
{
  sub_8128426(a1, a3);
  return sub_81283CE(*(_DWORD *)a1 + 16 * *(_DWORD *)(a1 + 4) + 8, a3, a2);
}

//----- (08127CAA) --------------------------------------------------------
_DWORD *__cdecl sub_8127CAA(_DWORD *a1)
{
  ++*a1;
  return a1;
}

//----- (08127CB8) --------------------------------------------------------
void *__cdecl sub_8127CB8(int *a1, int a2)
{
  void *s; // ST14_4
  _DWORD *i; // [esp+10h] [ebp-8h]

  for ( i = (_DWORD *)a1[1]; i; i = (_DWORD *)i[8190] )
  {
    if ( i[8189] )
    {
      if ( i != (_DWORD *)a1[1] )
        sub_8127D96((int)a1, (int)i);
      break;
    }
  }
  if ( i )
    goto LABEL_11;
  i = sub_8121C8A(a1[1], *a1, a2);
  if ( i )
  {
    a1[1] = (int)i;
LABEL_11:
    s = (void *)i[8189];
    i[8189] = *(_DWORD *)i[8189];
    --i[8188];
    sub_80AA83E(s, 0, 0x44u);
    return s;
  }
  return 0;
}

//----- (08127D96) --------------------------------------------------------
int __cdecl sub_8127D96(int a1, int a2)
{
  int result; // eax

  sub_8121D9A(a2);
  *(_DWORD *)(a2 + 32764) = 0;
  *(_DWORD *)(a2 + 32760) = *(_DWORD *)(a1 + 4);
  *(_DWORD *)(*(_DWORD *)(a1 + 4) + 32764) = a2;
  result = a2;
  *(_DWORD *)(a1 + 4) = a2;
  return result;
}

//----- (08127DDE) --------------------------------------------------------
int __cdecl sub_8127DDE(int *a1, char *a2)
{
  int result; // eax
  char *v3; // [esp+14h] [ebp-4h]

  v3 = sub_8121E22(a2);
  if ( !*(_DWORD *)(a1[1] + 32756) )
    return sub_8127D96((int)a1, (int)v3);
  result = *((_DWORD *)v3 + 8188);
  if ( result >= *a1 )
  {
    if ( v3 != (char *)a1[1] )
      return sub_8121E02((int)v3);
    result = (int)v3;
    if ( *((_DWORD *)v3 + 8190) )
    {
      result = *((_DWORD *)v3 + 8190);
      if ( *(_DWORD *)(result + 32752) )
      {
        a1[1] = *((_DWORD *)v3 + 8190);
        return sub_8121E02((int)v3);
      }
    }
  }
  return result;
}

//----- (08127E76) --------------------------------------------------------
int __cdecl sub_8127E76(int *a1, char *a2)
{
  int result; // eax
  char *v3; // [esp+14h] [ebp-4h]

  v3 = sub_8121E22(a2);
  if ( !*(_DWORD *)(a1[1] + 32756) )
    return sub_81284AE((int)a1, (int)v3);
  result = *((_DWORD *)v3 + 8188);
  if ( result >= *a1 )
  {
    if ( v3 != (char *)a1[1] )
      return sub_8121E02((int)v3);
    result = (int)v3;
    if ( *((_DWORD *)v3 + 8190) )
    {
      result = *((_DWORD *)v3 + 8190);
      if ( *(_DWORD *)(result + 32752) )
      {
        a1[1] = *((_DWORD *)v3 + 8190);
        return sub_8121E02((int)v3);
      }
    }
  }
  return result;
}

//----- (08127F0E) --------------------------------------------------------
int __cdecl sub_8127F0E(int *a1, char *a2)
{
  int result; // eax
  char *v3; // [esp+14h] [ebp-4h]

  v3 = sub_8121E22(a2);
  if ( !*(_DWORD *)(a1[1] + 32756) )
    return sub_81284F6((int)a1, (int)v3);
  result = *((_DWORD *)v3 + 8188);
  if ( result >= *a1 )
  {
    if ( v3 != (char *)a1[1] )
      return sub_8121E02((int)v3);
    result = (int)v3;
    if ( *((_DWORD *)v3 + 8190) )
    {
      result = *((_DWORD *)v3 + 8190);
      if ( *(_DWORD *)(result + 32752) )
      {
        a1[1] = *((_DWORD *)v3 + 8190);
        return sub_8121E02((int)v3);
      }
    }
  }
  return result;
}

//----- (08127FA6) --------------------------------------------------------
int __cdecl sub_8127FA6(int *a1, char *a2)
{
  int result; // eax
  char *v3; // [esp+14h] [ebp-4h]

  v3 = sub_8121E22(a2);
  if ( !*(_DWORD *)(a1[1] + 32756) )
    return sub_812853E((int)a1, (int)v3);
  result = *((_DWORD *)v3 + 8188);
  if ( result >= *a1 )
  {
    if ( v3 != (char *)a1[1] )
      return sub_8121E02((int)v3);
    result = (int)v3;
    if ( *((_DWORD *)v3 + 8190) )
    {
      result = *((_DWORD *)v3 + 8190);
      if ( *(_DWORD *)(result + 32752) )
      {
        a1[1] = *((_DWORD *)v3 + 8190);
        return sub_8121E02((int)v3);
      }
    }
  }
  return result;
}

//----- (0812803E) --------------------------------------------------------
int __cdecl sub_812803E(int *a1, char *a2)
{
  int result; // eax
  char *v3; // [esp+14h] [ebp-4h]

  v3 = sub_8121E22(a2);
  if ( !*(_DWORD *)(a1[1] + 32756) )
    return sub_8128586((int)a1, (int)v3);
  result = *((_DWORD *)v3 + 8188);
  if ( result >= *a1 )
  {
    if ( v3 != (char *)a1[1] )
      return sub_8121E02((int)v3);
    result = (int)v3;
    if ( *((_DWORD *)v3 + 8190) )
    {
      result = *((_DWORD *)v3 + 8190);
      if ( *(_DWORD *)(result + 32752) )
      {
        a1[1] = *((_DWORD *)v3 + 8190);
        return sub_8121E02((int)v3);
      }
    }
  }
  return result;
}

//----- (081280D6) --------------------------------------------------------
int __cdecl sub_81280D6(int *a1, char *a2)
{
  int result; // eax
  char *v3; // [esp+14h] [ebp-4h]

  v3 = sub_8121E22(a2);
  if ( !*(_DWORD *)(a1[1] + 32756) )
    return sub_81285CE((int)a1, (int)v3);
  result = *((_DWORD *)v3 + 8188);
  if ( result >= *a1 )
  {
    if ( v3 != (char *)a1[1] )
      return sub_8121E02((int)v3);
    result = (int)v3;
    if ( *((_DWORD *)v3 + 8190) )
    {
      result = *((_DWORD *)v3 + 8190);
      if ( *(_DWORD *)(result + 32752) )
      {
        a1[1] = *((_DWORD *)v3 + 8190);
        return sub_8121E02((int)v3);
      }
    }
  }
  return result;
}

//----- (0812816E) --------------------------------------------------------
int __cdecl sub_812816E(int *a1, char *a2)
{
  int result; // eax
  char *v3; // [esp+14h] [ebp-4h]

  v3 = sub_8121E22(a2);
  if ( !*(_DWORD *)(a1[1] + 32756) )
    return sub_8128616((int)a1, (int)v3);
  result = *((_DWORD *)v3 + 8188);
  if ( result >= *a1 )
  {
    if ( v3 != (char *)a1[1] )
      return sub_8121E02((int)v3);
    result = (int)v3;
    if ( *((_DWORD *)v3 + 8190) )
    {
      result = *((_DWORD *)v3 + 8190);
      if ( *(_DWORD *)(result + 32752) )
      {
        a1[1] = *((_DWORD *)v3 + 8190);
        return sub_8121E02((int)v3);
      }
    }
  }
  return result;
}

//----- (08128206) --------------------------------------------------------
int __cdecl sub_8128206(int *a1, char *a2)
{
  int result; // eax
  char *v3; // [esp+14h] [ebp-4h]

  v3 = sub_8121E22(a2);
  if ( !*(_DWORD *)(a1[1] + 32756) )
    return sub_812865E((int)a1, (int)v3);
  result = *((_DWORD *)v3 + 8188);
  if ( result >= *a1 )
  {
    if ( v3 != (char *)a1[1] )
      return sub_8121E02((int)v3);
    result = (int)v3;
    if ( *((_DWORD *)v3 + 8190) )
    {
      result = *((_DWORD *)v3 + 8190);
      if ( *(_DWORD *)(result + 32752) )
      {
        a1[1] = *((_DWORD *)v3 + 8190);
        return sub_8121E02((int)v3);
      }
    }
  }
  return result;
}

//----- (0812829E) --------------------------------------------------------
int __cdecl sub_812829E(int *a1, char *a2)
{
  int result; // eax
  char *v3; // [esp+14h] [ebp-4h]

  v3 = sub_8121E22(a2);
  if ( !*(_DWORD *)(a1[1] + 32756) )
    return sub_81286A6((int)a1, (int)v3);
  result = *((_DWORD *)v3 + 8188);
  if ( result >= *a1 )
  {
    if ( v3 != (char *)a1[1] )
      return sub_8121E02((int)v3);
    result = (int)v3;
    if ( *((_DWORD *)v3 + 8190) )
    {
      result = *((_DWORD *)v3 + 8190);
      if ( *(_DWORD *)(result + 32752) )
      {
        a1[1] = *((_DWORD *)v3 + 8190);
        return sub_8121E02((int)v3);
      }
    }
  }
  return result;
}

//----- (08128336) --------------------------------------------------------
int __cdecl sub_8128336(int *a1, char *a2)
{
  int result; // eax
  char *v3; // [esp+14h] [ebp-4h]

  v3 = sub_8121E22(a2);
  if ( !*(_DWORD *)(a1[1] + 32756) )
    return sub_81286EE((int)a1, (int)v3);
  result = *((_DWORD *)v3 + 8188);
  if ( result >= *a1 )
  {
    if ( v3 != (char *)a1[1] )
      return sub_8121E02((int)v3);
    result = (int)v3;
    if ( *((_DWORD *)v3 + 8190) )
    {
      result = *((_DWORD *)v3 + 8190);
      if ( *(_DWORD *)(result + 32752) )
      {
        a1[1] = *((_DWORD *)v3 + 8190);
        return sub_8121E02((int)v3);
      }
    }
  }
  return result;
}

//----- (081283CE) --------------------------------------------------------
int __cdecl sub_81283CE(int a1, float a2, int a3)
{
  float v3; // ST08_4

  v3 = (a2 - *(float *)a1) / (*(float *)(a1 + 16) - *(float *)a1);
  return sub_8127520(a1 + 4, a1 + 20, v3, a3);
}

//----- (08128426) --------------------------------------------------------
void __cdecl sub_8128426(int a1, float a2)
{
  int v2; // [esp+0h] [ebp-8h]
  float *v3; // [esp+4h] [ebp-4h]

  v2 = **(_DWORD **)a1 + 1;
  v3 = (float *)(*(_DWORD *)a1 + 4 * v2 * *(_DWORD *)(a1 + 4) + 8);
  if ( *v3 > (long double)a2 )
  {
    *(_DWORD *)(a1 + 4) = 0;
    v3 = (float *)(*(_DWORD *)a1 + 8);
  }
  while ( a2 > (long double)v3[v2] )
  {
    ++*(_DWORD *)(a1 + 4);
    v3 += v2;
  }
}

//----- (081284AE) --------------------------------------------------------
int __cdecl sub_81284AE(int a1, int a2)
{
  int result; // eax

  sub_8121D9A(a2);
  *(_DWORD *)(a2 + 32764) = 0;
  *(_DWORD *)(a2 + 32760) = *(_DWORD *)(a1 + 4);
  *(_DWORD *)(*(_DWORD *)(a1 + 4) + 32764) = a2;
  result = a2;
  *(_DWORD *)(a1 + 4) = a2;
  return result;
}

//----- (081284F6) --------------------------------------------------------
int __cdecl sub_81284F6(int a1, int a2)
{
  int result; // eax

  sub_8121D9A(a2);
  *(_DWORD *)(a2 + 32764) = 0;
  *(_DWORD *)(a2 + 32760) = *(_DWORD *)(a1 + 4);
  *(_DWORD *)(*(_DWORD *)(a1 + 4) + 32764) = a2;
  result = a2;
  *(_DWORD *)(a1 + 4) = a2;
  return result;
}

//----- (0812853E) --------------------------------------------------------
int __cdecl sub_812853E(int a1, int a2)
{
  int result; // eax

  sub_8121D9A(a2);
  *(_DWORD *)(a2 + 32764) = 0;
  *(_DWORD *)(a2 + 32760) = *(_DWORD *)(a1 + 4);
  *(_DWORD *)(*(_DWORD *)(a1 + 4) + 32764) = a2;
  result = a2;
  *(_DWORD *)(a1 + 4) = a2;
  return result;
}

//----- (08128586) --------------------------------------------------------
int __cdecl sub_8128586(int a1, int a2)
{
  int result; // eax

  sub_8121D9A(a2);
  *(_DWORD *)(a2 + 32764) = 0;
  *(_DWORD *)(a2 + 32760) = *(_DWORD *)(a1 + 4);
  *(_DWORD *)(*(_DWORD *)(a1 + 4) + 32764) = a2;
  result = a2;
  *(_DWORD *)(a1 + 4) = a2;
  return result;
}

//----- (081285CE) --------------------------------------------------------
int __cdecl sub_81285CE(int a1, int a2)
{
  int result; // eax

  sub_8121D9A(a2);
  *(_DWORD *)(a2 + 32764) = 0;
  *(_DWORD *)(a2 + 32760) = *(_DWORD *)(a1 + 4);
  *(_DWORD *)(*(_DWORD *)(a1 + 4) + 32764) = a2;
  result = a2;
  *(_DWORD *)(a1 + 4) = a2;
  return result;
}

//----- (08128616) --------------------------------------------------------
int __cdecl sub_8128616(int a1, int a2)
{
  int result; // eax

  sub_8121D9A(a2);
  *(_DWORD *)(a2 + 32764) = 0;
  *(_DWORD *)(a2 + 32760) = *(_DWORD *)(a1 + 4);
  *(_DWORD *)(*(_DWORD *)(a1 + 4) + 32764) = a2;
  result = a2;
  *(_DWORD *)(a1 + 4) = a2;
  return result;
}

//----- (0812865E) --------------------------------------------------------
int __cdecl sub_812865E(int a1, int a2)
{
  int result; // eax

  sub_8121D9A(a2);
  *(_DWORD *)(a2 + 32764) = 0;
  *(_DWORD *)(a2 + 32760) = *(_DWORD *)(a1 + 4);
  *(_DWORD *)(*(_DWORD *)(a1 + 4) + 32764) = a2;
  result = a2;
  *(_DWORD *)(a1 + 4) = a2;
  return result;
}

//----- (081286A6) --------------------------------------------------------
int __cdecl sub_81286A6(int a1, int a2)
{
  int result; // eax

  sub_8121D9A(a2);
  *(_DWORD *)(a2 + 32764) = 0;
  *(_DWORD *)(a2 + 32760) = *(_DWORD *)(a1 + 4);
  *(_DWORD *)(*(_DWORD *)(a1 + 4) + 32764) = a2;
  result = a2;
  *(_DWORD *)(a1 + 4) = a2;
  return result;
}

//----- (081286EE) --------------------------------------------------------
int __cdecl sub_81286EE(int a1, int a2)
{
  int result; // eax

  sub_8121D9A(a2);
  *(_DWORD *)(a2 + 32764) = 0;
  *(_DWORD *)(a2 + 32760) = *(_DWORD *)(a1 + 4);
  *(_DWORD *)(*(_DWORD *)(a1 + 4) + 32764) = a2;
  result = a2;
  *(_DWORD *)(a1 + 4) = a2;
  return result;
}

//----- (0812873E) --------------------------------------------------------
int __cdecl sub_812873E(int a1)
{
  int v2; // [esp+14h] [ebp-4h]

  sub_812875E(&v2, a1);
  return v2;
}

//----- (0812875E) --------------------------------------------------------
_DWORD *__userpurge sub_812875E@<eax>(_DWORD *a1, int a2)
{
  if ( *(_WORD *)(a2 + 4) )
    *a1 = *(_DWORD *)(*(_DWORD *)a2 + 4 * sub_80A8776(0, *(unsigned __int16 *)(a2 + 4)));
  else
    *a1 = 0;
  return a1;
}

//----- (081287D0) --------------------------------------------------------
int __cdecl sub_81287D0(int a1)
{
  int result; // eax

  *(_DWORD *)(a1 + 4) = 0;
  result = a1;
  *(_DWORD *)(a1 + 8) = 0;
  return result;
}

//----- (081287EA) --------------------------------------------------------
int __cdecl sub_81287EA(int a1, char a2, int a3)
{
  char *v3; // ST10_4
  int result; // eax

  while ( *(_DWORD *)(a1 + 4) )
  {
    v3 = *(char **)(a1 + 4);
    *(_DWORD *)(a1 + 4) = *(_DWORD *)(*(_DWORD *)(a1 + 4) + 76);
    sub_8129BF4(v3);
  }
  result = a1;
  *(_DWORD *)(a1 + 8) = 0;
  if ( a2 )
    result = sub_81298BC(a3);
  return result;
}

//----- (08128844) --------------------------------------------------------
void sub_8128844()
{
  sub_812F0A2("FxScheduler::PlayEffect called with invalid effect\n");
}

//----- (08128858) --------------------------------------------------------
void __cdecl sub_8128858(int *a1, _DWORD *a2, float *a3)
{
  char v3; // [esp+20h] [ebp-38h]
  int v4; // [esp+2Ch] [ebp-2Ch]
  int v5; // [esp+38h] [ebp-20h]

  sub_8129A02(&v3, 0, 0, 1065353216);
  sub_8129A02(&v4, 1065353216, 0, 0);
  sub_8129A02(&v5, 0, 1065353216, 0);
  sub_8128ACC(a1, a2, a3, &v3, 0);
}

//----- (08128900) --------------------------------------------------------
void __cdecl sub_8128900(int *a1, _DWORD *a2, float *a3, _DWORD *a4)
{
  char v4; // [esp+20h] [ebp-38h]
  int v5; // [esp+2Ch] [ebp-2Ch]
  int v6; // [esp+38h] [ebp-20h]

  sub_8129A26(a4, &v4);
  sub_80A295E((int)&v4, (int)&v5, (float *)&v6);
  sub_8128ACC(a1, a2, a3, &v4, 0);
}

//----- (08128962) --------------------------------------------------------
void __cdecl sub_8128962(int *a1, _DWORD *a2, float *a3, _DWORD *a4, _DWORD *a5)
{
  float v5[14]; // [esp+20h] [ebp-38h]
  float _2C[14]; // [esp+2Ch] [ebp-2Ch]
  float _38[14]; // [esp+38h] [ebp-20h]

  sub_8129A26(a4, v5);
  sub_8129A26(a5, _38);
  sub_80A1ED8(v5, _38, _2C);
  sub_8128ACC(a1, a2, a3, v5, 0);
}

//----- (081289D8) --------------------------------------------------------
signed int __cdecl sub_81289D8(int a1, float *a2)
{
  float v2; // ST1C_4
  float v3; // ST1C_4
  float v4; // ST18_4
  float v5; // ST18_4
  signed int v7; // [esp+14h] [ebp-14h]
  char v8; // [esp+23h] [ebp-5h]
  float v9; // [esp+24h] [ebp-4h]

  v8 = 0;
  v9 = 0.0;
  if ( *(float *)(a1 + 96) != 0.0 )
  {
    v8 = 1;
    v9 = sub_80A1DB2(a2, (float *)(off_8168620 + 20));
    v2 = *(float *)(a1 + 96) * *(float *)(off_8168620 + 248);
    v3 = v2 * v2;
    if ( v3 > (long double)v9 )
      return 0;
  }
  if ( *(float *)(a1 + 100) == 0.0 )
    goto LABEL_13;
  if ( !v8 )
    v9 = sub_80A1DB2(a2, (float *)(off_8168620 + 20));
  v4 = *(float *)(a1 + 100) * *(float *)(off_8168620 + 248);
  v5 = v4 * v4;
  if ( v9 <= (long double)v5 )
LABEL_13:
    v7 = 1;
  else
    v7 = 0;
  return v7;
}

//----- (08128ACC) --------------------------------------------------------
void __cdecl sub_8128ACC(int *a1, _DWORD *a2, float *a3, _DWORD *a4, _DWORD *a5)
{
  float v5; // ST00_4
  long double v6; // fst7
  _DWORD *v7; // ebx
  int v8; // eax
  _DWORD *v9; // ecx
  int v10; // edx
  int j; // [esp+28h] [ebp-60h]
  int v12; // [esp+2Ch] [ebp-5Ch]
  float v13[14]; // [esp+30h] [ebp-58h]
  float v14[14]; // [esp+3Ch] [ebp-4Ch]
  float v15; // [esp+68h] [ebp-20h]
  _DWORD *v16; // [esp+6Ch] [ebp-1Ch]
  int v17; // [esp+70h] [ebp-18h]
  int v18; // [esp+74h] [ebp-14h]
  int i; // [esp+78h] [ebp-10h]
  int v20; // [esp+7Ch] [ebp-Ch]

  i = 0;
  v18 = 0;
  v17 = 0;
  v15 = 0.0;
  *a1 = sub_812AE78(off_8168620);
  sub_80A8712(*a1);
  if ( !a2 )
  {
    sub_812ADC6(off_8168620, 1);
    a2 = sub_8129F6A("fx/error.efx");
    sub_812ADC6(off_8168620, 0);
    if ( !a2 )
    {
      sub_8128844();
      return;
    }
  }
  if ( !*(_BYTE *)(dword_89A2C98 + 8) && *(_BYTE *)(dword_89A2C80 + 8) )
  {
    if ( a5 )
    {
      if ( *a5 < 0 || !(unsigned __int8)sub_813130E() )
        return;
    }
    else
    {
      if ( a3 )
        sub_8129A26(a3, v13);
      else
        sub_81299D8(v13);
      sub_80A6FE6(a4, v14);
    }
    v12 = 0;
    for ( i = 0; i < a2[1]; ++i )
    {
      v20 = a2[i + 2];
      if ( (unsigned __int8)sub_81289D8(v20, a3)
        && (!(*(_DWORD *)(v20 + 148) & 0x400) || !(unsigned __int8)sub_812ABF4(off_8168620, a3, *(float *)(v20 + 672))) )
      {
        v18 = (signed int)(sub_812F170((float *)(v20 + 80)) + 0.5);
        if ( v18 )
        {
          if ( *(_DWORD *)(v20 + 148) & 0x200 )
          {
            v5 = *(float *)(v20 + 76) - *(float *)(v20 + 72);
            v6 = sub_812997C(v5);
            v15 = v6 / (long double)v18;
          }
          v12 += v18;
          for ( j = 0; j < v18; ++j )
          {
            if ( *(_DWORD *)(v20 + 148) & 0x200 )
              v17 = (signed int)((long double)j * v15);
            else
              v17 = (signed int)sub_812F170((float *)(v20 + 72));
            if ( v17 > 0 )
            {
              v16 = sub_8129BD8(80);
              if ( v16 )
              {
                v16[2] = *(_DWORD *)(off_8168620 + 4) + v17;
                *v16 = a2;
                v16[1] = i;
                v16[18] = j;
                v7 = v16;
                v8 = sub_812AE78(off_8168620);
                v7[17] = 57266229 * i + v8;
                if ( a5 )
                {
                  v9 = v16 + 3;
                  v10 = a5[1];
                  *v9 = *a5;
                  v9[1] = v10;
                }
                else
                {
                  v16[3] = -1;
                  v16[4] = -1;
                }
                sub_8129A26(v13, v16 + 5);
                sub_80A6FE6(v14, v16 + 8);
                v16[19] = a1[1];
                a1[1] = (int)v16;
                ++a1[2];
              }
            }
            else
            {
              sub_8129488((int)a1, (int)a2, v20, a5, v13, v14, -v17, j);
            }
          }
        }
      }
    }
  }
}
// 89A2C80: using guessed type int dword_89A2C80;
// 89A2C98: using guessed type int dword_89A2C98;

//----- (08128E8A) --------------------------------------------------------
long double __cdecl sub_8128E8A(int a1, int a2)
{
  int v2; // ST14_4
  float v4; // [esp+4h] [ebp-14h]
  float v5; // [esp+8h] [ebp-10h]
  float v6; // [esp+Ch] [ebp-Ch]
  int i; // [esp+10h] [ebp-8h]

  v4 = 0.0;
  for ( i = 0; i < *(_DWORD *)(a2 + 4); ++i )
  {
    v2 = *(_DWORD *)(a2 + 4 * i + 8);
    v6 = *(float *)(v2 + 76);
    v5 = *(float *)(v2 + 92);
    if ( v5 + v6 > (long double)v4 )
      v4 = v5 + v6;
  }
  return v4;
}

//----- (08128EFA) --------------------------------------------------------
int __cdecl sub_8128EFA(int a1, int a2, int a3)
{
  int v4; // [esp+20h] [ebp-38h]
  int v5; // [esp+30h] [ebp-28h]
  float v6; // [esp+4Ch] [ebp-Ch]

  sub_8122C06(a2 + 256, (int)&v5);
  if ( !(*(_DWORD *)(a2 + 144) & 0x2000) )
    return sub_81275C6((int)&v5, a3, 0.0);
  v6 = sub_80A8720(0.0, 1.0);
  sub_8122C06(a2 + 268, (int)&v4);
  return sub_8127650((int)&v5, (int)&v4, v6, a3, 0.0);
}

//----- (08128FA2) --------------------------------------------------------
void __cdecl sub_8128FA2(int a1, int a2)
{
  float v2; // [esp+1Ch] [ebp-3Ch]
  int v3; // [esp+20h] [ebp-38h]
  int v4; // [esp+30h] [ebp-28h]
  float v5; // [esp+4Ch] [ebp-Ch]

  sub_8122C06(a2 + 280, (int)&v4);
  if ( *(_DWORD *)(a2 + 144) & 0x4000 )
  {
    v5 = sub_80A8720(0.0, 1.0);
    sub_8122C06(a2 + 292, (int)&v3);
    v2 = sub_8127604((int)&v4, (int)&v3, v5, 0.0);
  }
  else
  {
    v2 = sub_81275A6((int)&v4, 0.0);
  }
  sub_8129996(v2, 0.0, 1.0);
}

//----- (0812905E) --------------------------------------------------------
long double __cdecl sub_812905E(int a1, int a2)
{
  float v3; // [esp+1Ch] [ebp-3Ch]
  int v4; // [esp+20h] [ebp-38h]
  int v5; // [esp+30h] [ebp-28h]
  float v6; // [esp+4Ch] [ebp-Ch]

  sub_8122C06(a2 + 304, (int)&v5);
  if ( *(_WORD *)(a2 + 144) >= 0 )
  {
    v3 = sub_81275A6((int)&v5, 0.0);
  }
  else
  {
    v6 = sub_80A8720(0.0, 1.0);
    sub_8122C06(a2 + 316, (int)&v4);
    v3 = sub_8127604((int)&v5, (int)&v4, v6, 0.0);
  }
  return v3;
}

//----- (08129104) --------------------------------------------------------
void sub_8129104()
{
  ;
}

//----- (0812910A) --------------------------------------------------------
_BOOL4 __cdecl sub_812910A(int a1, _DWORD *a2, int *a3)
{
  _DWORD *v3; // eax
  int v6[5]; // [esp+20h] [ebp-18h]

  if ( !(*(_DWORD *)(a1 + 144) & 2) || !a2 || *a2 < 0 )
    return 1;
  sub_8121EF6(v6, a2);
  sub_81277D4(a3, v6);
  sub_81277B6(v6);
  if ( !(unsigned __int8)sub_812782E(a3) )
    return 0;
  v3 = (_DWORD *)sub_812787E((int)a3);
  return sub_8122008(v3) != 0;
}

//----- (081291DE) --------------------------------------------------------
int __cdecl sub_81291DE(int a1, float *a2, int a3)
{
  int result; // eax
  float v4; // ST0C_4

  result = *(_DWORD *)(a1 + 148) & 0x100;
  if ( result )
  {
    v4 = sub_80A8720(0.0, 360.0);
    sub_80A2672((int)(a2 + 3), (int)a2, a3 + 12, v4);
    result = sub_80A1ED8(a2, a2 + 3, a2 + 6);
  }
  return result;
}

//----- (08129250) --------------------------------------------------------
void __cdecl sub_8129250(int *a1, float *a2, float *a3, signed int a4, int a5)
{
  switch ( *(_DWORD *)(a1[1] + 64) )
  {
    case 0:
      return;
    case 1:
      sub_81337F2(a1, a2, a3, a4, a5);
      break;
    case 2:
      sub_813392A(a1, a2, a3);
      break;
    case 3:
      sub_8133C04(a1, a2, a3, a4, a5);
      break;
    case 4:
      sub_8133D9E(a1, a2, a3, a4, a5);
      break;
    case 5:
      sub_8133F44(a1, a2, a3, a4);
      break;
    case 6:
      sub_813431A((int)a1, a2, a3);
      break;
    case 7:
      sub_8134642(a1, a2, a3, a4, a5);
      break;
    case 8:
      sub_8134368((int)a1, a2, a3);
      break;
    case 9:
      sub_81344EE(a1, a2, a3);
      break;
    case 0xA:
      sub_8134432((int)a1, a2, a3);
      break;
    case 0xB:
      sub_81347FC(a1, (int)a2, a3);
      break;
    case 0xC:
      sub_813493C(a1, a2, a3, a4, a5);
      break;
  }
}

//----- (08129488) --------------------------------------------------------
int __cdecl sub_8129488(int a1, int a2, int a3, _DWORD *a4, float *a5, _DWORD *a6, signed int a7, int a8)
{
  int v9; // [esp+30h] [ebp-48h]
  int v10; // [esp+34h] [ebp-44h]
  int v11; // [esp+38h] [ebp-40h]
  float v12[14]; // [esp+40h] [ebp-38h]

  sub_8129BAC((int)&v9);
  sub_80A6FE6(a6, v12);
  sub_81291DE(a3, v12, (int)a6);
  if ( (unsigned __int8)sub_812910A(a3, a4, &v11) )
  {
    v9 = a2;
    v10 = a3;
    sub_8129250(&v9, v12, a5, a7, a8);
  }
  return sub_8129BC2((int)&v9);
}

//----- (08129558) --------------------------------------------------------
int *__cdecl sub_8129558(int a1, int *a2)
{
  int *result; // eax
  char *v3; // [esp+10h] [ebp-8h]
  int j; // [esp+10h] [ebp-8h]
  int *i; // [esp+14h] [ebp-4h]

  if ( (unsigned __int8)sub_8127A4A((int)a2) )
  {
    *(_DWORD *)(a1 + 4) = 0;
    *(_DWORD *)(a1 + 8) = 0;
    result = (int *)sub_8127A56(a2);
    for ( i = result; i; i = (int *)((char *)i - 1) )
    {
      v3 = (char *)sub_8129BD8(80);
      sub_812966C((int)v3, (int)a2);
      if ( *(_DWORD *)v3
        && *((_DWORD *)v3 + 1) >= 0
        && *((_DWORD *)v3 + 1) < *(_DWORD *)(*(_DWORD *)v3 + 4)
        && *(_DWORD *)(*(_DWORD *)v3 + 4 * *((_DWORD *)v3 + 1) + 8) )
      {
        *((_DWORD *)v3 + 19) = *(_DWORD *)(a1 + 4);
        *(_DWORD *)(a1 + 4) = v3;
        ++*(_DWORD *)(a1 + 8);
      }
      else
      {
        sub_8129BF4(v3);
      }
      result = (int *)&i;
    }
  }
  else
  {
    sub_8127A7C(a2, *(_DWORD *)(a1 + 8));
    result = (int *)*((_DWORD *)dword_89A2814 + 1);
    for ( j = *((_DWORD *)dword_89A2814 + 1); j; j = *(_DWORD *)(j + 76) )
    {
      sub_812966C(j, (int)a2);
      result = *(int **)(j + 76);
    }
  }
  return result;
}

//----- (0812966C) --------------------------------------------------------
_BYTE **__cdecl sub_812966C(int a1, int a2)
{
  sub_8120FCA(a2, (const char ***)a1);
  sub_8127AC0(a2, (char *)(a1 + 4));
  sub_8127AC0(a2, (char *)(a1 + 8));
  sub_8120F84(a2, (char *)(a1 + 12), 8);
  sub_8127B04(a2, (char *)(a1 + 20));
  sub_8127B04(a2, (char *)(a1 + 32));
  sub_8127B04(a2, (char *)(a1 + 44));
  sub_8127B04(a2, (char *)(a1 + 56));
  return sub_8127AC0(a2, (char *)(a1 + 68));
}

//----- (08129736) --------------------------------------------------------
void sub_8129736()
{
  dword_89A2800 = 0;
}
// 89A2800: using guessed type int dword_89A2800;

//----- (08129746) --------------------------------------------------------
const char **__cdecl sub_8129746(char *s2)
{
  const char **v3; // [esp+10h] [ebp-8h]
  int i; // [esp+14h] [ebp-4h]

  for ( i = 0; i < dword_89A2800; ++i )
  {
    v3 = (const char **)dword_89A2400[i];
    if ( !strcmp(*v3, s2) )
      return v3;
  }
  return 0;
}
// 89A2400: using guessed type int dword_89A2400[];
// 89A2800: using guessed type int dword_89A2800;

//----- (081297A0) --------------------------------------------------------
signed int __cdecl sub_81297A0(int a1)
{
  signed int v2; // [esp+14h] [ebp-4h]

  if ( dword_89A2800 == 256 )
  {
    sub_812F0A2("^1Max effect templates of '%i' exceeded\n", 256);
    v2 = 0;
  }
  else
  {
    dword_89A2400[dword_89A2800++] = a1;
    v2 = 1;
  }
  return v2;
}
// 89A2400: using guessed type int dword_89A2400[];
// 89A2800: using guessed type int dword_89A2800;

//----- (081297F2) --------------------------------------------------------
void *__cdecl sub_81297F2(char *s2)
{
  const char **v1; // ebx
  char **v2; // ebx
  void *v4; // [esp+1Ch] [ebp-5Ch]
  int v5; // [esp+20h] [ebp-58h]
  char **v6; // [esp+68h] [ebp-10h]
  const char **v7; // [esp+6Ch] [ebp-Ch]

  sub_8130CD6((int)&v5);
  v7 = sub_8129746(s2);
  if ( v7 )
  {
    v1 = v7;
    sub_8130D4E((int)&v5);
    v4 = v1;
  }
  else
  {
    v6 = sub_812A0D2((int)&v5, s2);
    if ( v6 )
    {
      if ( (unsigned __int8)sub_81297A0((int)v6) )
      {
        v2 = v6;
        sub_8130D4E((int)&v5);
        v4 = v2;
      }
      else
      {
        sub_8130D4E((int)&v5);
        v4 = 0;
      }
    }
    else
    {
      sub_8130D4E((int)&v5);
      v4 = 0;
    }
  }
  return v4;
}

//----- (081298BC) --------------------------------------------------------
int __cdecl sub_81298BC(int a1)
{
  int result; // eax
  int v2; // [esp+Ch] [ebp-Ch]
  char v3; // [esp+13h] [ebp-5h]
  int i; // [esp+14h] [ebp-4h]

  v3 = 0;
  for ( i = 0; ; ++i )
  {
    result = i;
    if ( i >= dword_89A2800 )
      break;
    v2 = dword_89A2400[i];
    if ( v2 == a1 )
    {
      v3 = 1;
    }
    else
    {
      sub_8129E1C(v2);
      dword_89A2400[i] = 0;
    }
  }
  dword_89A2800 = 0;
  if ( v3 )
  {
    result = a1;
    dword_89A2400[dword_89A2800++] = a1;
  }
  return result;
}
// 89A2400: using guessed type int dword_89A2400[];
// 89A2800: using guessed type int dword_89A2800;

//----- (0812993E) --------------------------------------------------------
_DWORD *__cdecl sub_812993E(int a1, int a2)
{
  _DWORD *result; // eax

  if ( a2 == 0xFFFF && a1 == 1 )
    result = sub_8129C10(&unk_89A23E0);
  if ( a2 == 0xFFFF && a1 == 1 )
    result = sub_8129C28(&unk_89A2804);
  return result;
}

//----- (0812997C) --------------------------------------------------------
long double __cdecl sub_812997C(float a1)
{
  return (float)fabs(a1);
}

//----- (08129996) --------------------------------------------------------
long double __cdecl sub_8129996(float a1, float a2, float a3)
{
  float v4; // [esp+0h] [ebp-4h]

  if ( a2 <= (long double)a1 )
  {
    if ( a1 <= (long double)a3 )
      v4 = a1;
    else
      v4 = a3;
  }
  else
  {
    v4 = a2;
  }
  return v4;
}

//----- (081299D8) --------------------------------------------------------
int __cdecl sub_81299D8(_DWORD *a1)
{
  int result; // eax

  *a1 = 0;
  a1[1] = 0;
  result = 0;
  a1[2] = 0;
  return result;
}

//----- (08129A02) --------------------------------------------------------
int __cdecl sub_8129A02(_DWORD *a1, int a2, int a3, int a4)
{
  int result; // eax

  *a1 = a2;
  a1[1] = a3;
  result = a4;
  a1[2] = a4;
  return result;
}

//----- (08129A26) --------------------------------------------------------
int __cdecl sub_8129A26(_DWORD *a1, _DWORD *a2)
{
  int result; // eax

  *a2 = *a1;
  a2[1] = a1[1];
  result = a1[2];
  a2[2] = result;
  return result;
}

//----- (08129B90) --------------------------------------------------------
_DWORD *ctor_002()
{
  return sub_812993E(1, 0xFFFF);
}

//----- (08129BAC) --------------------------------------------------------
_DWORD *__cdecl sub_8129BAC(int a1)
{
  return sub_812778A((_DWORD *)(a1 + 8));
}

//----- (08129BC2) --------------------------------------------------------
int __cdecl sub_8129BC2(int a1)
{
  return sub_81277B6((int *)(a1 + 8));
}

//----- (08129BD8) --------------------------------------------------------
void *__cdecl sub_8129BD8(int a1)
{
  return sub_8129C40((int *)&unk_89A2804, a1);
}

//----- (08129BF4) --------------------------------------------------------
int __cdecl sub_8129BF4(char *a1)
{
  return sub_8129D66((int *)&unk_89A2804, a1);
}

//----- (08129C10) --------------------------------------------------------
_DWORD *__cdecl sub_8129C10(_DWORD *a1)
{
  _DWORD *result; // eax

  *a1 = 48;
  result = a1;
  a1[1] = 0;
  return result;
}

//----- (08129C28) --------------------------------------------------------
_DWORD *__cdecl sub_8129C28(_DWORD *a1)
{
  _DWORD *result; // eax

  *a1 = 409;
  result = a1;
  a1[1] = 0;
  return result;
}

//----- (08129C40) --------------------------------------------------------
void *__cdecl sub_8129C40(int *a1, int a2)
{
  void *s; // ST14_4
  _DWORD *i; // [esp+10h] [ebp-8h]

  for ( i = (_DWORD *)a1[1]; i; i = (_DWORD *)i[8190] )
  {
    if ( i[8189] )
    {
      if ( i != (_DWORD *)a1[1] )
        sub_8129D1E((int)a1, (int)i);
      break;
    }
  }
  if ( i )
    goto LABEL_11;
  i = sub_8121C8A(a1[1], *a1, a2);
  if ( i )
  {
    a1[1] = (int)i;
LABEL_11:
    s = (void *)i[8189];
    i[8189] = *(_DWORD *)i[8189];
    --i[8188];
    sub_80AA83E(s, 0, 0x50u);
    return s;
  }
  return 0;
}

//----- (08129D1E) --------------------------------------------------------
int __cdecl sub_8129D1E(int a1, int a2)
{
  int result; // eax

  sub_8121D9A(a2);
  *(_DWORD *)(a2 + 32764) = 0;
  *(_DWORD *)(a2 + 32760) = *(_DWORD *)(a1 + 4);
  *(_DWORD *)(*(_DWORD *)(a1 + 4) + 32764) = a2;
  result = a2;
  *(_DWORD *)(a1 + 4) = a2;
  return result;
}

//----- (08129D66) --------------------------------------------------------
int __cdecl sub_8129D66(int *a1, char *a2)
{
  int result; // eax
  char *v3; // [esp+14h] [ebp-4h]

  v3 = sub_8121E22(a2);
  if ( !*(_DWORD *)(a1[1] + 32756) )
    return sub_8129D1E((int)a1, (int)v3);
  result = *((_DWORD *)v3 + 8188);
  if ( result >= *a1 )
  {
    if ( v3 != (char *)a1[1] )
      return sub_8121E02((int)v3);
    result = (int)v3;
    if ( *((_DWORD *)v3 + 8190) )
    {
      result = *((_DWORD *)v3 + 8190);
      if ( *(_DWORD *)(result + 32752) )
      {
        a1[1] = *((_DWORD *)v3 + 8190);
        return sub_8121E02((int)v3);
      }
    }
  }
  return result;
}

//----- (08129E00) --------------------------------------------------------
void *__cdecl sub_8129E00(size_t n)
{
  return Hunk_AllocAlignInternal(n, 4);
}

//----- (08129E1C) --------------------------------------------------------
int __cdecl sub_8129E1C(int a1)
{
  int result; // eax
  int i; // [esp+4h] [ebp-4h]

  for ( i = 0; ; ++i )
  {
    result = i;
    if ( i >= *(_DWORD *)(a1 + 4) )
      break;
    sub_812B566(*(_DWORD *)(a1 + 4 * i + 8));
  }
  return result;
}

//----- (08129E52) --------------------------------------------------------
signed int __cdecl sub_8129E52(int a1, int a2)
{
  signed int v3; // [esp+18h] [ebp-60h]
  void *v4; // [esp+1Ch] [ebp-5Ch]
  char s; // [esp+20h] [ebp-58h]
  void *ptr; // [esp+64h] [ebp-14h]
  int v7; // [esp+68h] [ebp-10h]
  int v8; // [esp+6Ch] [ebp-Ch]

  sprintf(&s, "fx/%s.efx", a2);
  v8 = FS_FOpenFileByMode(&s, (int)&v7, 0);
  if ( v8 >= 0 )
  {
    ptr = Hunk_AllocateTempMemory(v8 + 1);
    FS_Read((int)ptr, v8, v7);
    FS_FCloseFile(v7);
    *((_BYTE *)ptr + v8) = 0;
    v4 = ptr;
    sub_8130D92(a1, (char **)&v4, 1, 0);
    sub_80AA0C8(ptr);
    v3 = 1;
  }
  else
  {
    sub_812F0A2("Effect file load failed: %s: file not found\n", &s);
    v3 = 0;
  }
  return v3;
}

//----- (08129F2C) --------------------------------------------------------
void *sub_8129F2C()
{
  void *result; // eax

  result = sub_81297F2("misc/missing_fx");
  dword_89A2818 = (int)result;
  if ( !result )
    Com_Error(1, "^1ERROR: could not load default effect file '%s'", "misc/missing_fx");
  return result;
}
// 89A2818: using guessed type int dword_89A2818;

//----- (08129F6A) --------------------------------------------------------
void *__cdecl sub_8129F6A(_BYTE *a1)
{
  char s2; // [esp+20h] [ebp-58h]
  void *v4; // [esp+6Ch] [ebp-Ch]

  if ( *a1 == 47 || *a1 == 92 )
    ++a1;
  if ( sub_812A552(a1, "fx/", 3) )
  {
    sub_812F0A2("Effect file '%s' must start with fx/.\n", a1);
    v4 = 0;
    goto LABEL_8;
  }
  sub_812A52C(a1 + 3, &s2);
  v4 = sub_81297F2(&s2);
  if ( !v4 )
  {
LABEL_8:
    v4 = (void *)dword_89A2818;
    return (void *)dword_89A2818;
  }
  return v4;
}
// 89A2818: using guessed type int dword_89A2818;

//----- (0812A004) --------------------------------------------------------
void __cdecl sub_812A004(int a1, int a2)
{
  signed int v2; // [esp+4h] [ebp-4h]

  v2 = *(_DWORD *)(a1 + 4);
  if ( v2 <= 23 )
  {
    *(_DWORD *)(a1 + 4 * v2 + 8) = a2;
    ++*(_DWORD *)(a1 + 4);
  }
  else
  {
    sub_812F0A2("FxScheduler:  Error--too many primitives in an effect\n");
  }
}

//----- (0812A03C) --------------------------------------------------------
_BOOL4 __cdecl sub_812A03C(int a1)
{
  _BOOL4 v2; // [esp+0h] [ebp-4h]

  if ( byte_8168610 )
    v2 = *(_WORD *)(a1 + 108) != 0;
  else
    v2 = 1;
  return v2;
}
// 8168610: using guessed type char byte_8168610;

//----- (0812A074) --------------------------------------------------------
signed int __cdecl sub_812A074(int a1)
{
  if ( *(_DWORD *)(a1 + 64) != 1 && *(_DWORD *)(a1 + 64) != 7 && *(_DWORD *)(a1 + 64) != 3
    || (unsigned __int8)sub_812A03C(a1) )
  {
    return 1;
  }
  sub_812F0A2("^1FX Error, no materials defined for primitive template of type '%i'\n", *(_DWORD *)(a1 + 64));
  return 0;
}

//----- (0812A0D2) --------------------------------------------------------
char **__cdecl sub_812A0D2(int a1, char *s)
{
  int v2; // ST18_4
  size_t n; // ST1C_4
  int v4; // eax
  int v7; // [esp+14h] [ebp-24h]
  signed int v8; // [esp+20h] [ebp-18h]
  char **v9; // [esp+24h] [ebp-14h]
  char *s1; // [esp+28h] [ebp-10h]
  char *dest; // [esp+2Ch] [ebp-Ch]
  int v12; // [esp+30h] [ebp-8h]

  if ( !(unsigned __int8)sub_8129E52(a1, (int)s) )
    return 0;
  v2 = sub_812A60C(a1);
  v9 = (char **)sub_8129E00(0x68u);
  n = strlen(s) + 1;
  *v9 = (char *)sub_8129E00(n);
  strcpy(*v9, s);
  v12 = sub_812A600(v2);
  v7 = 0;
  while ( v12 )
  {
    s1 = (char *)sub_812A5EA(v12);
    if ( !strcasecmp(s1, "particle") )
    {
      v8 = 1;
    }
    else if ( !strcasecmp(s1, "line") )
    {
      v8 = 2;
    }
    else if ( !strcasecmp(s1, "tail") )
    {
      v8 = 3;
    }
    else if ( !strcasecmp(s1, "cylinder") )
    {
      v8 = 4;
    }
    else if ( !strcasecmp(s1, "emitter") )
    {
      v8 = 5;
    }
    else if ( !strcasecmp(s1, "decal") )
    {
      v8 = 6;
    }
    else if ( !strcasecmp(s1, "orientedparticle") )
    {
      v8 = 7;
    }
    else if ( !strcasecmp(s1, "fxrunner") )
    {
      v8 = 8;
    }
    else if ( !strcasecmp(s1, "light") )
    {
      v8 = 9;
    }
    else if ( !strcasecmp(s1, "cameraShake") )
    {
      v8 = 10;
    }
    else if ( !strcasecmp(s1, "flash") )
    {
      v8 = 11;
    }
    else if ( !strcasecmp(s1, "cloud") )
    {
      v8 = 12;
    }
    else
    {
      v8 = 0;
    }
    if ( v8 )
    {
      dest = (char *)sub_8129E00(0x2A4u);
      sub_812B004(dest);
      *((_DWORD *)dest + 16) = v8;
      *((_DWORD *)dest + 17) = v7;
      if ( !(unsigned __int8)sub_812F060(dest, v12) )
      {
        sub_812B566((int)dest);
        sub_8129E1C((int)v9);
        v4 = sub_812A5EA(v12);
        sub_812F0A2("^1FX Error while parsing segment type '%s'\n", v4);
        return 0;
      }
      if ( !(unsigned __int8)sub_812A074((int)dest) )
      {
        sub_812B566((int)dest);
        sub_8129E1C((int)v9);
        sub_812F0A2("^1FX Error, invalid primitive template for effect '%s'\n", s);
        return 0;
      }
      sub_812A004((int)v9, (int)dest);
    }
    v12 = sub_812A5F4(v12);
    ++v7;
  }
  return v9;
}

//----- (0812A418) --------------------------------------------------------
int __cdecl sub_812A418(int a1)
{
  int result; // eax

  result = a1;
  if ( *(_DWORD *)a1 )
  {
    Z_FreeInternal(*(void **)a1);
    *(_DWORD *)a1 = 0;
    *(_WORD *)(a1 + 4) = 0;
    result = a1;
    *(_WORD *)(a1 + 6) = 0;
  }
  return result;
}

//----- (0812A452) --------------------------------------------------------
int __cdecl sub_812A452(int a1, int a2)
{
  int result; // eax
  void *dest; // [esp+14h] [ebp-4h]

  if ( *(_WORD *)(a1 + 4) == *(_WORD *)(a1 + 6) )
  {
    if ( *(_WORD *)(a1 + 6) )
      *(_WORD *)(a1 + 6) *= 2;
    else
      *(_WORD *)(a1 + 6) = 4;
    dest = Z_MallocInternal(4 * *(unsigned __int16 *)(a1 + 6));
    if ( *(_DWORD *)a1 )
    {
      memcpy(dest, *(const void **)a1, 4 * *(unsigned __int16 *)(a1 + 4));
      Z_FreeInternal(*(void **)a1);
    }
    *(_DWORD *)a1 = dest;
  }
  *(_DWORD *)(*(_DWORD *)a1 + 4 * *(unsigned __int16 *)(a1 + 4)) = a2;
  result = *(unsigned __int16 *)(a1 + 4) + 1;
  *(_WORD *)(a1 + 4) = result;
  return result;
}

//----- (0812A50C) --------------------------------------------------------
int __cdecl sub_812A50C(int a1, int a2)
{
  return sub_812A452(a1, a2);
}

//----- (0812A52C) --------------------------------------------------------
_BYTE *__cdecl sub_812A52C(_BYTE *a1, _BYTE *a2)
{
  sub_80B4E98(a1, a2);
  return strlwr(a2);
}

//----- (0812A552) --------------------------------------------------------
signed int __cdecl sub_812A552(_BYTE *a1, _BYTE *a2, int a3)
{
  signed int v4; // [esp+Ch] [ebp-Ch]
  char v6; // [esp+16h] [ebp-2h]
  char v7; // [esp+17h] [ebp-1h]

  while ( a3 && *a1 )
  {
    v7 = tolower((char)*a1);
    v6 = tolower((char)*a2);
    --a3;
    ++a1;
    ++a2;
    if ( v7 < v6 )
      return -1;
    if ( v7 > v6 )
      return 1;
  }
  if ( a3 && *a1 != *a2 )
    v4 = -1;
  else
    v4 = 0;
  return v4;
}

//----- (0812A5EA) --------------------------------------------------------
int __cdecl sub_812A5EA(int a1)
{
  return *(_DWORD *)a1;
}

//----- (0812A5F4) --------------------------------------------------------
int __cdecl sub_812A5F4(int a1)
{
  return *(_DWORD *)(a1 + 4);
}

//----- (0812A600) --------------------------------------------------------
int __cdecl sub_812A600(int a1)
{
  return *(_DWORD *)(a1 + 28);
}

//----- (0812A60C) --------------------------------------------------------
int __cdecl sub_812A60C(int a1)
{
  return a1;
}

//----- (0812A642) --------------------------------------------------------
_DWORD *__cdecl sub_812A642(_DWORD *a1)
{
  _DWORD *result; // eax

  a1[1] = 0;
  a1[2] = 0;
  a1[3] = 0;
  result = a1;
  a1[4] = 0;
  return result;
}

//----- (0812A670) --------------------------------------------------------
_DWORD *__cdecl sub_812A670(_DWORD *a1)
{
  _DWORD *result; // eax

  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  a1[3] = 0;
  a1[4] = 0;
  result = a1;
  a1[61] = 0;
  return result;
}

//----- (0812A6B4) --------------------------------------------------------
signed int __cdecl sub_812A6B4(_DWORD *a1, int a2)
{
  signed int result; // eax

  if ( *(_BYTE *)(dword_89A2C98 + 8) )
  {
    a1[3] = 0;
  }
  else
  {
    if ( *a1 )
    {
      a1[3] = a2 - *a1;
      if ( a1[3] >= 0 )
      {
        if ( a1[3] > 200 )
          a1[3] = 200;
      }
      else
      {
        a1[3] = 0;
      }
    }
    else
    {
      a1[3] = 0;
    }
    a1[2] = a1[1];
    a1[1] += a1[3];
  }
  *a1 = a2;
  a1[61] = *a1;
  result = 112;
  qmemcpy(a1 + 33, a1 + 5, 0x70u);
  return result;
}
// 89A2C98: using guessed type int dword_89A2C98;

//----- (0812A776) --------------------------------------------------------
int __cdecl sub_812A776(int *a1, int a2)
{
  int result; // eax
  int v3; // [esp+4h] [ebp-4h]

  if ( *(_BYTE *)(dword_89A2C98 + 8) )
  {
    a1[3] = 0;
  }
  else if ( *a1 )
  {
    a1[2] = a1[1];
    v3 = a2 - a1[1];
    if ( v3 >= 0 )
    {
      a1[3] = 0;
      while ( v3 > 200 )
      {
        a1[3] = 200;
        sub_8134AAE();
        sub_81324A6();
        sub_81323E6();
        a1[2] = a1[1];
        a1[1] += a1[3];
        v3 -= 200;
      }
      a1[3] = v3;
      sub_8134AAE();
      sub_81324A6();
      sub_81323E6();
      a1[1] += a1[3];
    }
    else
    {
      a1[1] = a2;
    }
  }
  else
  {
    a1[3] = 0;
  }
  *a1 = a2;
  result = *a1;
  a1[61] = *a1;
  return result;
}
// 89A2C98: using guessed type int dword_89A2C98;

//----- (0812A882) --------------------------------------------------------
void __cdecl sub_812A882(int a1, int a2, float a3)
{
  float *v3; // ebx
  float v4; // [esp+14h] [ebp-14h]
  float v5; // [esp+18h] [ebp-10h]
  float v6; // [esp+1Ch] [ebp-Ch]
  int i; // [esp+20h] [ebp-8h]

  sub_812AED6((_DWORD *)(a2 + 36), (_DWORD *)(a1 + 32));
  v6 = *(float *)(a2 + 16) * 0.008726646259971648;
  sub_812AEA8(v6, (int)&v5, (int)&v4);
  sub_812AF44(a2 + 36, v5, a1 + 48);
  sub_812AF7C(a1 + 48, v4, a2 + 48, a1 + 48);
  sub_812AF44(a2 + 36, v5, a1 + 64);
  sub_812AF7C(a1 + 64, COERCE_FLOAT(LODWORD(v4) ^ 0x80000000), a2 + 48, a1 + 64);
  v6 = *(float *)(a2 + 20) * 0.008726646259971648;
  sub_812AEA8(v6, (int)&v5, (int)&v4);
  sub_812AF44(a2 + 36, v5, a1 + 80);
  sub_812AF7C(a1 + 80, v4, a2 + 60, a1 + 80);
  sub_812AF44(a2 + 36, v5, a1 + 96);
  sub_812AF7C(a1 + 96, COERCE_FLOAT(LODWORD(v4) ^ 0x80000000), a2 + 60, a1 + 96);
  *(_DWORD *)(a1 + 128) = 5;
  if ( a3 > 0.0 )
  {
    sub_812AF06((_DWORD *)(a2 + 36), (unsigned int *)(a1 + 112));
    *(_DWORD *)(a1 + 128) = 6;
  }
  for ( i = 0; i < *(_DWORD *)(a1 + 128); ++i )
  {
    v3 = (float *)(a1 + 16 * i + 44);
    *v3 = sub_812AFD0((float *)(a1 + 20), (float *)(a1 + 16 * i + 32));
  }
  if ( a3 > 0.0 )
    *(float *)(a1 + 124) = *(float *)(a1 + 124) - a3;
}

//----- (0812AAD2) --------------------------------------------------------
void __cdecl sub_812AAD2(int a1, int a2, float a3)
{
  double v3; // ST10_8

  sub_812AED6((_DWORD *)(a2 + 24), (_DWORD *)(a1 + 20));
  sub_812A882(a1, a2, a3);
  if ( *(float *)(a2 + 16) == 80.0 )
  {
    *(_DWORD *)(a1 + 248) = 1065353216;
  }
  else
  {
    v3 = tan(0.6981317007977318);
    *(float *)(a1 + 248) = v3 / tan(*(float *)(a2 + 16) * 0.5 * 0.0174532925199433);
  }
}

//----- (0812AB74) --------------------------------------------------------
signed int __cdecl sub_812AB74(int a1, float *a2, float a3, int a4)
{
  float v4; // ST10_4
  int i; // [esp+14h] [ebp-4h]

  for ( i = 0; i < a4; ++i )
  {
    v4 = sub_812AFD0((float *)(off_8168620 + 16 * i + 32), a2) - *(float *)(off_8168620 + 16 * i + 44);
    if ( -a3 > (long double)v4 )
      return 1;
  }
  return 0;
}

//----- (0812ABF4) --------------------------------------------------------
signed int __cdecl sub_812ABF4(int a1, float *a2, float a3)
{
  float v3; // ST10_4
  int i; // [esp+14h] [ebp-4h]

  for ( i = 0; i < *(_DWORD *)(off_8168620 + 240); ++i )
  {
    v3 = sub_812AFD0((float *)(off_8168620 + 16 * i + 144), a2) - *(float *)(off_8168620 + 16 * i + 156);
    if ( -a3 > (long double)v3 )
      return 1;
  }
  return 0;
}

//----- (0812AC82) --------------------------------------------------------
signed int __cdecl sub_812AC82(int a1, float *a2, float *a3, float a4, float a5, int a6)
{
  float v6; // ST10_4
  float v7; // ST10_4
  int i; // [esp+14h] [ebp-4h]

  for ( i = 0; i < a6; ++i )
  {
    v6 = sub_812AFD0((float *)(off_8168620 + 16 * i + 32), a2) - *(float *)(off_8168620 + 16 * i + 44);
    if ( v6 <= -a4 )
    {
      v7 = sub_812AFD0((float *)(off_8168620 + 16 * i + 32), a3) - *(float *)(off_8168620 + 16 * i + 44);
      if ( v7 <= -a5 )
        return 1;
    }
  }
  return 0;
}

//----- (0812AD4E) --------------------------------------------------------
int __cdecl sub_812AD4E(int a1, void *s, int a3, int a4, int a5, int a6, int a7, int a8)
{
  int result; // eax
  unsigned __int16 v9; // [esp+22h] [ebp-6h]

  sub_805B690(s, a3, a6, a4, a5, 0, a8);
  if ( *(float *)s == 1.0 )
    v9 = 1023;
  else
    v9 = 1022;
  result = v9;
  *((_WORD *)s + 14) = v9;
  return result;
}

//----- (0812ADC0) --------------------------------------------------------
void sub_812ADC0()
{
  ;
}

//----- (0812ADC6) --------------------------------------------------------
int __cdecl sub_812ADC6(int a1, int a2)
{
  return a2;
}

//----- (0812ADD4) --------------------------------------------------------
int sub_812ADD4()
{
  return 0;
}

//----- (0812ADDE) --------------------------------------------------------
int __cdecl sub_812ADDE(int a1, int a2)
{
  int result; // eax

  sub_8127AC0(a2, (char *)(a1 + 4));
  sub_8127AC0(a2, (char *)(a1 + 8));
  sub_8127AC0(a2, (char *)(a1 + 12));
  sub_8127AC0(a2, (char *)(a1 + 16));
  result = sub_8127A4A(a2);
  if ( (_BYTE)result )
  {
    result = a1;
    *(_DWORD *)a1 = 0;
  }
  return result;
}

//----- (0812AE52) --------------------------------------------------------
int sub_812AE52()
{
  return 0;
}

//----- (0812AE5C) --------------------------------------------------------
int sub_812AE5C()
{
  return 0;
}

//----- (0812AE66) --------------------------------------------------------
void sub_812AE66()
{
  ;
}

//----- (0812AE72) --------------------------------------------------------
void sub_812AE72()
{
  ;
}

//----- (0812AE78) --------------------------------------------------------
int __cdecl sub_812AE78(int a1)
{
  int v1; // ST00_4

  v1 = *(_DWORD *)(a1 + 244);
  *(_DWORD *)(a1 + 244) *= 57266229;
  return v1;
}

//----- (0812AEA8) --------------------------------------------------------
void __cdecl sub_812AEA8(float a1, int a2, int a3)
{
  *(float *)a2 = sin(a1);
  *(float *)a3 = cos(a1);
}

//----- (0812AED6) --------------------------------------------------------
int __cdecl sub_812AED6(_DWORD *a1, _DWORD *a2)
{
  int result; // eax

  *a2 = *a1;
  a2[1] = a1[1];
  result = a1[2];
  a2[2] = result;
  return result;
}

//----- (0812AF06) --------------------------------------------------------
unsigned int __cdecl sub_812AF06(_DWORD *a1, unsigned int *a2)
{
  unsigned int result; // eax

  *a2 = *a1 ^ 0x80000000;
  a2[1] = a1[1] ^ 0x80000000;
  result = a1[2] ^ 0x80000000;
  a2[2] = result;
  return result;
}

//----- (0812AF44) --------------------------------------------------------
int __cdecl sub_812AF44(int a1, float a2, int a3)
{
  int result; // eax

  *(float *)a3 = a2 * *(float *)a1;
  *(float *)(a3 + 4) = a2 * *(float *)(a1 + 4);
  result = a1 + 8;
  *(float *)(a3 + 8) = a2 * *(float *)(a1 + 8);
  return result;
}

//----- (0812AF7C) --------------------------------------------------------
int __cdecl sub_812AF7C(int a1, float a2, int a3, int a4)
{
  int result; // eax

  *(float *)a4 = a2 * *(float *)a3 + *(float *)a1;
  *(float *)(a4 + 4) = a2 * *(float *)(a3 + 4) + *(float *)(a1 + 4);
  result = a3 + 8;
  *(float *)(a4 + 8) = a2 * *(float *)(a3 + 8) + *(float *)(a1 + 8);
  return result;
}

//----- (0812AFD0) --------------------------------------------------------
long double __cdecl sub_812AFD0(float *a1, float *a2)
{
  return *a1 * *a2 + a1[1] * a2[1] + a1[2] * a2[2];
}

//----- (0812B004) --------------------------------------------------------
int __cdecl sub_812B004(_DWORD *a1)
{
  int result; // eax

  sub_812F15A(a1 + 22, 1065353216, 1065353216);
  sub_812F15A(a1 + 20, 1065353216, 1065353216);
  sub_812F15A(a1 + 58, 1065353216, 1065353216);
  sub_812F15A(a1 + 60, 1065353216, 1065353216);
  sub_812119C(a1 + 64, 3, 1065353216, 0);
  sub_812119C(a1 + 67, 3, 1065353216, 0);
  sub_812119C(a1 + 70, 1, 1065353216, 0);
  sub_812119C(a1 + 73, 1, 1065353216, 0);
  sub_812119C(a1 + 76, 1, 1065353216, 0);
  sub_812119C(a1 + 79, 1, 1065353216, 0);
  sub_812119C(a1 + 82, 1, 1065353216, 0);
  sub_812119C(a1 + 85, 1, 1065353216, 0);
  sub_812119C(a1 + 88, 1, 1065353216, 0);
  sub_812119C(a1 + 91, 1, 1065353216, 0);
  sub_812119C(a1 + 94, 1, 0, 0);
  sub_812119C(a1 + 97, 1, 0, 0);
  sub_812119C(a1 + 100, 1, 0, 0);
  sub_812119C(a1 + 103, 1, 0, 0);
  sub_812119C(a1 + 106, 1, 0, 0);
  sub_812119C(a1 + 109, 1, 0, 0);
  sub_812119C(a1 + 112, 1, 0, 0);
  sub_812119C(a1 + 115, 1, 0, 0);
  sub_812119C(a1 + 118, 1, 0, 0);
  sub_812119C(a1 + 121, 1, 0, 0);
  sub_812119C(a1 + 124, 1, 0, 0);
  sub_812119C(a1 + 127, 1, 0, 0);
  sub_812119C(a1 + 130, 1, 0, 0);
  sub_812119C(a1 + 133, 1, 0, 0);
  sub_812F15A(a1 + 156, 1065353216, 1065353216);
  sub_812F15A(a1 + 158, 1065353216, 1065353216);
  sub_812F15A(a1 + 154, 1065353216, 1065353216);
  sub_812F15A(a1 + 152, 1092616192, 1092616192);
  a1[162] = 0;
  a1[163] = 1;
  a1[164] = 0;
  a1[165] = 1065353216;
  a1[166] = 0;
  a1[167] = 1;
  result = 0;
  a1[168] = 0;
  return result;
}

//----- (0812B566) --------------------------------------------------------
int __cdecl sub_812B566(int a1)
{
  sub_812A418(a1 + 104);
  sub_812A418(a1 + 112);
  sub_812A418(a1 + 120);
  sub_812A418(a1 + 128);
  return sub_812A418(a1 + 136);
}

//----- (0812B5B6) --------------------------------------------------------
int *__cdecl sub_812B5B6(int a1, void *s)
{
  int *result; // eax
  int j; // [esp+10h] [ebp-8h]
  int i; // [esp+14h] [ebp-4h]

  result = (int *)memset(s, 0, 0x600u);
  for ( i = 0; i != 24; ++i )
  {
    for ( j = 0; j != 3; ++j )
    {
      sub_812F15A((_DWORD *)s + 2 * (j + 8 * i), 1065353216, 1065353216);
      sub_812F15A((_DWORD *)s + 2 * (j + 8 * i) + 6, 1065353216, 1065353216);
      sub_812F15A((_DWORD *)s + 16 * i + 12, 1065353216, 1065353216);
    }
    result = &i;
  }
  return result;
}

//----- (0812B68C) --------------------------------------------------------
int *__cdecl sub_812B68C(int a1, int a2)
{
  float v2; // ST08_4
  int *result; // eax
  int i; // [esp+1Ch] [ebp-Ch]
  int v5; // [esp+20h] [ebp-8h]
  unsigned __int8 v6; // [esp+27h] [ebp-1h]

  for ( i = 0; i != 24; ++i )
  {
    if ( *(_BYTE *)(a2 + (i << 6) + 60) )
    {
      v6 = 0;
      v5 = 1;
      if ( i == 2 )
        v6 = 1;
      if ( !i )
        v5 = 3;
      v2 = sub_812F1B8(a1 + 88, 0.5);
      sub_81216CE(a2 + (i << 6), v5, v2, v6, a1 + 12 * i + 256);
    }
    result = &i;
  }
  return result;
}

//----- (0812B73A) --------------------------------------------------------
int __cdecl sub_812B73A(int a1, char *s, int a3, int a4)
{
  int v6; // [esp+14h] [ebp-4h]

  if ( !a3 || !a4 )
    return 0;
  v6 = sscanf(s, "%f %f", a3, a4);
  if ( !v6 )
    return 0;
  if ( v6 == 1 )
    *(_DWORD *)a4 = *(_DWORD *)a3;
  return 1;
}

//----- (0812B7A4) --------------------------------------------------------
int __cdecl sub_812B7A4(int a1, char *s, int a3, int a4)
{
  int v6; // [esp+24h] [ebp-4h]

  if ( !a3 || !a4 )
    return 0;
  v6 = sscanf(s, "%f %f %f   %f %f %f", a3, a3 + 4, a3 + 8, a4, a4 + 4, a4 + 8);
  if ( v6 <= 2 || v6 == 4 || v6 == 5 )
    return 0;
  if ( v6 == 3 )
    sub_812F232((_DWORD *)a3, (_DWORD *)a4);
  return 1;
}

//----- (0812B850) --------------------------------------------------------
int __cdecl sub_812B850(int a1, char *s, int a3)
{
  signed int i; // [esp+24h] [ebp-94h]
  int v6; // [esp+28h] [ebp-90h]
  unsigned __int8 v7; // [esp+2Fh] [ebp-89h]
  char dest[136]; // [esp+30h] [ebp-88h]
  char _50[136]; // [esp+50h] [ebp-68h]
  char _70[136]; // [esp+70h] [ebp-48h]
  char _90[136]; // [esp+90h] [ebp-28h]

  memcpy(dest, &unk_8158CD6, 0x80u);
  v7 = 1;
  v6 = sscanf(s, "%s %s %s %s", dest, _50, _70, _90);
  *(_DWORD *)a3 = 0;
  for ( i = 0; i <= 3; ++i )
  {
    if ( i + 1 > v6 )
      return 1;
    if ( !strcasecmp(&dest[32 * i], "linear") )
    {
      *(_DWORD *)a3 |= 1u;
    }
    else if ( !strcasecmp(&dest[32 * i], "nonlinear") )
    {
      *(_DWORD *)a3 |= 4u;
    }
    else if ( !strcasecmp(&dest[32 * i], "wave") )
    {
      *(_DWORD *)a3 |= 8u;
    }
    else if ( !strcasecmp(&dest[32 * i], "random") )
    {
      *(_DWORD *)a3 |= 2u;
    }
    else if ( !strcasecmp(&dest[32 * i], "clamp") )
    {
      *(_DWORD *)a3 |= 0xCu;
    }
    else
    {
      v7 = 0;
    }
  }
  return v7;
}
// 812B850: using guessed type char dest[136];

//----- (0812BA42) --------------------------------------------------------
int __cdecl sub_812BA42(int a1, char *s)
{
  int v4; // [esp+20h] [ebp-18h]

  if ( (unsigned __int8)sub_812B7A4(a1, s, (int)&v4, (int)&v4) != 1 )
    return 0;
  sub_812F232(&v4, (_DWORD *)(a1 + 160));
  *(_DWORD *)(a1 + 144) |= 0x60u;
  return 1;
}

//----- (0812BAAE) --------------------------------------------------------
int __cdecl sub_812BAAE(int a1, char *s)
{
  int v4; // [esp+20h] [ebp-18h]

  if ( (unsigned __int8)sub_812B7A4(a1, s, (int)&v4, (int)&v4) != 1 )
    return 0;
  sub_812F232(&v4, (_DWORD *)(a1 + 172));
  *(_DWORD *)(a1 + 144) |= 0x60u;
  return 1;
}

//----- (0812BB1A) --------------------------------------------------------
int __cdecl sub_812BB1A(int a1, char *s)
{
  int v4; // [esp+20h] [ebp-8h]
  int v5; // [esp+24h] [ebp-4h]

  if ( !(unsigned __int8)sub_812B73A(a1, s, (int)&v5, (int)&v4) )
    return 0;
  sub_812F15A((_DWORD *)(a1 + 88), v5, v4);
  return 1;
}

//----- (0812BB76) --------------------------------------------------------
int __cdecl sub_812BB76(int a1, char *s)
{
  int v4; // [esp+20h] [ebp-8h]
  int v5; // [esp+24h] [ebp-4h]

  if ( !(unsigned __int8)sub_812B73A(a1, s, (int)&v5, (int)&v4) )
    return 0;
  if ( *(float *)&v5 > (long double)*(float *)&v4 )
    return 0;
  sub_812F15A((_DWORD *)(a1 + 96), v5, v4);
  return 1;
}

//----- (0812BBEC) --------------------------------------------------------
int __cdecl sub_812BBEC(int a1, char *s)
{
  int v4; // [esp+20h] [ebp-8h]
  int v5; // [esp+24h] [ebp-4h]

  if ( !(unsigned __int8)sub_812B73A(a1, s, (int)&v5, (int)&v4) )
    return 0;
  sub_812F15A((_DWORD *)(a1 + 72), v5, v4);
  return 1;
}

//----- (0812BC48) --------------------------------------------------------
int __cdecl sub_812BC48(int a1, char *s)
{
  int v4; // [esp+20h] [ebp-8h]
  int v5; // [esp+24h] [ebp-4h]

  if ( !(unsigned __int8)sub_812B73A(a1, s, (int)&v5, (int)&v4) )
    return 0;
  sub_812F15A((_DWORD *)(a1 + 80), v5, v4);
  return 1;
}

//----- (0812BCA4) --------------------------------------------------------
int __cdecl sub_812BCA4(int a1, char *s)
{
  int v4; // [esp+20h] [ebp-8h]
  int v5; // [esp+24h] [ebp-4h]

  if ( !(unsigned __int8)sub_812B73A(a1, s, (int)&v5, (int)&v4) )
    return 0;
  if ( *(float *)&v5 > (long double)*(float *)&v4 )
    return 0;
  if ( *(float *)&v5 < 0.0 )
    return 0;
  if ( *(float *)&v5 > 1.0 )
    return 0;
  if ( *(float *)&v4 < 0.0 )
    return 0;
  if ( *(float *)&v4 > 1.0 )
    return 0;
  sub_812F15A((_DWORD *)(a1 + 640), v5, v4);
  *(_DWORD *)(a1 + 144) |= 0x20u;
  return 1;
}

//----- (0812BD9A) --------------------------------------------------------
int __cdecl sub_812BD9A(int a1, char *s)
{
  int v4; // [esp+20h] [ebp-28h]
  int v5; // [esp+24h] [ebp-24h]
  int v6; // [esp+28h] [ebp-20h]
  int v7; // [esp+30h] [ebp-18h]
  int v8; // [esp+34h] [ebp-14h]
  int v9; // [esp+38h] [ebp-10h]

  if ( (unsigned __int8)sub_812B7A4(a1, s, (int)&v7, (int)&v4) != 1 )
    return 0;
  sub_812F15A((_DWORD *)(a1 + 184), v7, v4);
  sub_812F15A((_DWORD *)(a1 + 192), v8, v5);
  sub_812F15A((_DWORD *)(a1 + 200), v9, v6);
  return 1;
}

//----- (0812BE34) --------------------------------------------------------
int __cdecl sub_812BE34(int a1, char *s)
{
  int v4; // [esp+20h] [ebp-28h]
  int v5; // [esp+24h] [ebp-24h]
  int v6; // [esp+28h] [ebp-20h]
  int v7; // [esp+30h] [ebp-18h]
  int v8; // [esp+34h] [ebp-14h]
  int v9; // [esp+38h] [ebp-10h]

  if ( (unsigned __int8)sub_812B7A4(a1, s, (int)&v7, (int)&v4) != 1 )
    return 0;
  sub_812F15A((_DWORD *)(a1 + 208), v7, v4);
  sub_812F15A((_DWORD *)(a1 + 216), v8, v5);
  sub_812F15A((_DWORD *)(a1 + 224), v9, v6);
  return 1;
}

//----- (0812BECE) --------------------------------------------------------
int __cdecl sub_812BECE(int a1, char *s)
{
  int v4; // [esp+20h] [ebp-8h]
  int v5; // [esp+24h] [ebp-4h]

  if ( !(unsigned __int8)sub_812B73A(a1, s, (int)&v5, (int)&v4) )
    return 0;
  sub_812F15A((_DWORD *)(a1 + 232), v5, v4);
  return 1;
}

//----- (0812BF2C) --------------------------------------------------------
int __cdecl sub_812BF2C(int a1, char *s)
{
  int v4; // [esp+20h] [ebp-8h]
  int v5; // [esp+24h] [ebp-4h]

  if ( !(unsigned __int8)sub_812B73A(a1, s, (int)&v5, (int)&v4) )
    return 0;
  sub_812F15A((_DWORD *)(a1 + 240), v5, v4);
  return 1;
}

//----- (0812BF8A) --------------------------------------------------------
int __cdecl sub_812BF8A(int a1, char *s)
{
  int v4; // [esp+20h] [ebp-8h]
  int v5; // [esp+24h] [ebp-4h]

  if ( !(unsigned __int8)sub_812B73A(a1, s, (int)&v5, (int)&v4) )
    return 0;
  sub_812F15A((_DWORD *)(a1 + 248), v5, v4);
  return 1;
}

//----- (0812BFE8) --------------------------------------------------------
int __cdecl sub_812BFE8(int a1, char *s)
{
  int v4; // [esp+20h] [ebp-8h]
  int v5; // [esp+24h] [ebp-4h]

  if ( !(unsigned __int8)sub_812B73A(a1, s, (int)&v5, (int)&v4) )
    return 0;
  sub_812F15A((_DWORD *)(a1 + 544), v5, v4);
  return 1;
}

//----- (0812C046) --------------------------------------------------------
long double __cdecl sub_812C046(int a1, float a2, float a3)
{
  float v4; // [esp+8h] [ebp-4h]

  if ( a3 <= fabs(a2) )
    v4 = fabs(a2);
  else
    v4 = a3;
  return v4;
}

//----- (0812C07A) --------------------------------------------------------
int __cdecl sub_812C07A(int a1, int a2, float a3, float a4, int a5, int a6)
{
  float v6; // ST14_4
  float v7; // ST18_4
  float v8; // ST18_4
  int i; // [esp+1Ch] [ebp-BCh]
  float src; // [esp+20h] [ebp-B8h]
  int v12[42]; // [esp+24h] [ebp-B4h]
  int v13; // [esp+CCh] [ebp-Ch]

  v13 = 20;
  for ( i = 0; i <= 19; ++i )
  {
    *(&src + 2 * i) = (long double)i / 19.0;
    if ( i )
    {
      v6 = a4 / 20.0;
      v7 = v6 * 0.00065;
      v8 = sub_812F1F4(v7, 0.0, 1.0);
      *(float *)&v12[2 * i] = (1.0 - v8) * *((float *)&i + 2 * i);
    }
    else if ( a3 == 0.0 )
    {
      v12[2 * i] = a2;
    }
    else
    {
      *(float *)&v12[2 * i] = *(float *)&a2 / a3;
    }
  }
  *(_DWORD *)(a1 + 12 * a5 + 256) = sub_8121AAC(&src, 1, 20);
  return sub_812F15A((_DWORD *)(a1 + 12 * a5 + 260), a6, a6);
}
// 812C07A: using guessed type int var_B4[42];

//----- (0812C1E6) --------------------------------------------------------
int __cdecl sub_812C1E6(int a1, float a2, float a3, int a4, int a5)
{
  int src; // [esp+10h] [ebp-28h]
  float v7; // [esp+14h] [ebp-24h]
  int v8; // [esp+18h] [ebp-20h]
  float v9; // [esp+1Ch] [ebp-1Ch]
  int v10; // [esp+2Ch] [ebp-Ch]

  v10 = 2;
  src = 0;
  if ( a3 == 0.0 )
    v7 = 0.0;
  else
    v7 = a2 / a3;
  v8 = 1065353216;
  v9 = v7;
  *(_DWORD *)(a1 + 12 * a4 + 256) = sub_8121AAC(&src, 1, 2);
  return sub_812F15A((_DWORD *)(a1 + 12 * a4 + 260), a5, a5);
}

//----- (0812C294) --------------------------------------------------------
int __cdecl sub_812C294(int a1, float a2, float a3, float a4, int a5, int a6)
{
  int src; // [esp+10h] [ebp-28h]
  int v8; // [esp+14h] [ebp-24h]
  int v9; // [esp+18h] [ebp-20h]
  float v10; // [esp+1Ch] [ebp-1Ch]
  int v11; // [esp+2Ch] [ebp-Ch]

  v11 = 2;
  src = 0;
  v8 = 0;
  v9 = 1065353216;
  v10 = a2 * a4 * 0.001;
  if ( a3 == 0.0 )
    v10 = 0.0;
  else
    v10 = v10 / a3;
  *(_DWORD *)(a1 + 12 * a5 + 256) = sub_8121AAC(&src, 1, 2);
  return sub_812F15A((_DWORD *)(a1 + 12 * a5 + 260), a6, a6);
}

//----- (0812C354) --------------------------------------------------------
int __cdecl sub_812C354(int a1, char *s)
{
  float v2; // ST1C_4
  int v5; // [esp+1Ch] [ebp-Ch]
  float v6; // [esp+20h] [ebp-8h]
  float v7; // [esp+24h] [ebp-4h]

  if ( !(unsigned __int8)sub_812B73A(a1, s, (int)&v7, (int)&v6) )
    return 0;
  if ( v7 > (long double)v6 )
    sub_812F2F6((int *)&v7, (int *)&v6);
  v2 = sub_812C046(a1, v7, v6);
  *(float *)&v5 = v2 + v2;
  sub_812C07A(a1, SLODWORD(v7), *(float *)&v5, *(float *)(a1 + 88), 10, v5);
  if ( v7 != v6 )
  {
    *(_DWORD *)(a1 + 144) |= 0x40000u;
    sub_812C07A(a1, SLODWORD(v6), *(float *)&v5, *(float *)(a1 + 92), 11, 1065353216);
  }
  return 1;
}

//----- (0812C46E) --------------------------------------------------------
int __cdecl sub_812C46E(int a1, char *s)
{
  int v4; // [esp+20h] [ebp-28h]
  int v5; // [esp+24h] [ebp-24h]
  int v6; // [esp+28h] [ebp-20h]
  int v7; // [esp+30h] [ebp-18h]
  int v8; // [esp+34h] [ebp-14h]
  int v9; // [esp+38h] [ebp-10h]

  if ( (unsigned __int8)sub_812B7A4(a1, s, (int)&v7, (int)&v4) != 1 )
    return 0;
  sub_812F15A((_DWORD *)(a1 + 552), v7, v4);
  sub_812F15A((_DWORD *)(a1 + 560), v8, v5);
  sub_812F15A((_DWORD *)(a1 + 568), v9, v6);
  return 1;
}

//----- (0812C508) --------------------------------------------------------
int __cdecl sub_812C508(int a1, char *s)
{
  int v4; // [esp+20h] [ebp-28h]
  int v5; // [esp+24h] [ebp-24h]
  int v6; // [esp+28h] [ebp-20h]
  int v7; // [esp+30h] [ebp-18h]
  int v8; // [esp+34h] [ebp-14h]
  int v9; // [esp+38h] [ebp-10h]

  if ( (unsigned __int8)sub_812B7A4(a1, s, (int)&v7, (int)&v4) != 1 )
    return 0;
  sub_812F15A((_DWORD *)(a1 + 576), v7, v4);
  sub_812F15A((_DWORD *)(a1 + 584), v8, v5);
  sub_812F15A((_DWORD *)(a1 + 592), v9, v6);
  return 1;
}

//----- (0812C5A2) --------------------------------------------------------
int __cdecl sub_812C5A2(int a1, char *s)
{
  float v2; // ST30_4
  float v3; // ST34_4
  float v4; // ST38_4
  float v5; // ST30_4
  float v6; // ST34_4
  long double v7; // fst7
  float v8; // ST38_4
  float v9; // ST00_4
  int v12; // [esp+2Ch] [ebp-3Ch]
  float v13; // [esp+40h] [ebp-28h]
  float v14; // [esp+44h] [ebp-24h]
  float v15; // [esp+48h] [ebp-20h]
  float v16; // [esp+50h] [ebp-18h]
  float v17; // [esp+54h] [ebp-14h]
  float v18; // [esp+58h] [ebp-10h]

  if ( (unsigned __int8)sub_812B7A4(a1, s, (int)&v16, (int)&v13) != 1 )
    return 0;
  if ( v16 > (long double)v13 )
    sub_812F2F6((int *)&v16, (int *)&v13);
  if ( v17 > (long double)v14 )
    sub_812F2F6((int *)&v17, (int *)&v14);
  if ( v18 > (long double)v15 )
    sub_812F2F6((int *)&v18, (int *)&v15);
  v2 = sub_812C046(a1, v16, v13);
  v3 = sub_812C046(a1, v17, v14);
  v4 = sub_812C046(a1, v18, v15);
  v5 = v2 + v2;
  v6 = v3 + v3;
  v7 = v4 + v4;
  v8 = v7;
  sub_812F1D0(v5, v6);
  v9 = v7;
  sub_812F1D0(v9, v8);
  *(float *)&v12 = v7;
  sub_812C1E6(a1, v16, *(float *)&v12, 12, v12);
  sub_812C1E6(a1, v17, *(float *)&v12, 13, v12);
  sub_812C1E6(a1, v18, *(float *)&v12, 14, v12);
  if ( !(unsigned __int8)sub_812F262(&v16, &v13) )
  {
    *(_DWORD *)(a1 + 144) |= 0x80000u;
    sub_812C1E6(a1, v13, *(float *)&v12, 15, 1065353216);
    sub_812C1E6(a1, v14, *(float *)&v12, 16, 1065353216);
    sub_812C1E6(a1, v15, *(float *)&v12, 17, 1065353216);
  }
  return 1;
}

//----- (0812C812) --------------------------------------------------------
int __cdecl sub_812C812(int a1, char *s2, int a3, int a4)
{
  int v6; // [esp+10h] [ebp-8h]
  int i; // [esp+14h] [ebp-4h]

  for ( i = 0; i < a4; ++i )
  {
    v6 = a3 + 12 * i;
    if ( !strcasecmp(*(const char **)(a3 + 12 * i), s2) )
    {
      *(_DWORD *)(a1 + 144) |= *(_DWORD *)(v6 + 4);
      *(_DWORD *)(a1 + 148) |= *(_DWORD *)(v6 + 8);
      return 1;
    }
  }
  return 0;
}

//----- (0812C8A0) --------------------------------------------------------
int __cdecl sub_812C8A0(int a1, char *s, int a3, int a4)
{
  unsigned __int8 v6; // [esp+23h] [ebp-15h]
  size_t v7; // [esp+24h] [ebp-14h]
  signed int v8; // [esp+28h] [ebp-10h]
  signed int size; // [esp+2Ch] [ebp-Ch]
  const char *v10; // [esp+30h] [ebp-8h]
  char *s2; // [esp+34h] [ebp-4h]

  size = strlen(s);
  if ( !size )
    return 0;
  s2 = (char *)Hunk_AllocateTempMemory(size);
  v10 = s;
  v8 = 0;
  v6 = 1;
  while ( v8 < size )
  {
    if ( sscanf(v10, "%s", s2) != 1 )
    {
      v6 = 0;
      break;
    }
    v7 = strlen(s2);
    if ( !(unsigned __int8)sub_812C812(a1, s2, a3, a4) )
    {
      v6 = 0;
      break;
    }
    v8 += v7 + 1;
    v10 = &s[v8];
  }
  sub_80AA0C8(s2);
  return v6;
}

//----- (0812C978) --------------------------------------------------------
int __cdecl sub_812C978(int a1, char *s)
{
  return (unsigned __int8)sub_812C8A0(a1, s, (int)&off_8158A40, 24);
}
// 8158A40: using guessed type char *off_8158A40;

//----- (0812C9A6) --------------------------------------------------------
int __cdecl sub_812C9A6(int a1, char *s)
{
  return (unsigned __int8)sub_812C8A0(a1, s, (int)&off_8158C20, 13);
}
// 8158C20: using guessed type char *off_8158C20;

//----- (0812C9D4) --------------------------------------------------------
int __cdecl sub_812C9D4(int a1, char *s)
{
  float v2; // ST30_4
  float v3; // ST34_4
  float v4; // ST38_4
  float v5; // ST30_4
  float v6; // ST34_4
  long double v7; // fst7
  float v8; // ST38_4
  float v9; // ST00_4
  float v10; // ST28_4
  int v13; // [esp+28h] [ebp-40h]
  float v14; // [esp+2Ch] [ebp-3Ch]
  float v15; // [esp+40h] [ebp-28h]
  float v16; // [esp+44h] [ebp-24h]
  float v17; // [esp+48h] [ebp-20h]
  float v18; // [esp+50h] [ebp-18h]
  float v19; // [esp+54h] [ebp-14h]
  float v20; // [esp+58h] [ebp-10h]

  if ( (unsigned __int8)sub_812B7A4(a1, s, (int)&v18, (int)&v15) != 1 )
    return 0;
  if ( v18 > (long double)v15 )
    sub_812F2F6((int *)&v18, (int *)&v15);
  if ( v19 > (long double)v16 )
    sub_812F2F6((int *)&v19, (int *)&v16);
  if ( v20 > (long double)v17 )
    sub_812F2F6((int *)&v20, (int *)&v17);
  v14 = *(float *)(a1 + 92);
  v2 = sub_812C046(a1, v18, v15);
  v3 = sub_812C046(a1, v19, v16);
  v4 = sub_812C046(a1, v20, v17);
  v5 = v2 + v2;
  v6 = v3 + v3;
  v7 = v4 + v4;
  v8 = v7;
  sub_812F1D0(v5, v6);
  v9 = v7;
  sub_812F1D0(v9, v8);
  v10 = v7;
  *(float *)&v13 = v14 * 0.001 * v10;
  sub_812C294(a1, v18, *(float *)&v13, v14, 18, v13);
  sub_812C294(a1, v19, *(float *)&v13, v14, 19, v13);
  sub_812C294(a1, v20, *(float *)&v13, v14, 20, v13);
  if ( !(unsigned __int8)sub_812F262(&v18, &v15) )
  {
    *(_DWORD *)(a1 + 144) |= 0x100000u;
    sub_812C294(a1, v15, *(float *)&v13, v14, 21, 1065353216);
    sub_812C294(a1, v16, *(float *)&v13, v14, 22, 1065353216);
    sub_812C294(a1, v17, *(float *)&v13, v14, 23, 1065353216);
  }
  return 1;
}

//----- (0812CC8A) --------------------------------------------------------
int __cdecl sub_812CC8A(int a1, char *s)
{
  int v4; // [esp+20h] [ebp-8h]
  int v5; // [esp+24h] [ebp-4h]

  if ( !(unsigned __int8)sub_812B73A(a1, s, (int)&v5, (int)&v4) )
    return 0;
  sub_812F15A((_DWORD *)(a1 + 600), v5, v4);
  return 1;
}

//----- (0812CCE8) --------------------------------------------------------
int __cdecl sub_812CCE8(int a1, char *s)
{
  int v4; // [esp+20h] [ebp-8h]
  int v5; // [esp+24h] [ebp-4h]

  if ( !(unsigned __int8)sub_812B73A(a1, s, (int)&v5, (int)&v4) )
    return 0;
  sub_812F15A((_DWORD *)(a1 + 608), v5, v4);
  return 1;
}

//----- (0812CD46) --------------------------------------------------------
int __cdecl sub_812CD46(int a1, char *s)
{
  int v4; // [esp+20h] [ebp-8h]
  int v5; // [esp+24h] [ebp-4h]

  if ( !(unsigned __int8)sub_812B73A(a1, s, (int)&v5, (int)&v4) )
    return 0;
  sub_812F15A((_DWORD *)(a1 + 616), v5, v4);
  return 1;
}

//----- (0812CDA4) --------------------------------------------------------
int __cdecl sub_812CDA4(int a1, char *nptr)
{
  int v4; // [esp+14h] [ebp-4h]

  v4 = atoi(nptr);
  if ( v4 < 0 || v4 > 2 )
    return 0;
  *(_DWORD *)(a1 + 648) = v4;
  return 1;
}

//----- (0812CDE8) --------------------------------------------------------
_BOOL4 __cdecl sub_812CDE8(int a1, char *nptr)
{
  *(_DWORD *)(a1 + 652) = atoi(nptr);
  return *(_DWORD *)(a1 + 652) > 0;
}

//----- (0812CE28) --------------------------------------------------------
int __cdecl sub_812CE28(int a1, char *nptr)
{
  int v4; // [esp+14h] [ebp-4h]

  v4 = atoi(nptr);
  if ( v4 < 0 || v4 > 1 )
    return 0;
  *(_DWORD *)(a1 + 656) = v4;
  return 1;
}

//----- (0812CE6C) --------------------------------------------------------
_BOOL4 __cdecl sub_812CE6C(int a1, char *nptr)
{
  *(float *)(a1 + 660) = atof(nptr);
  return *(float *)(a1 + 660) >= 0.0;
}

//----- (0812CEB4) --------------------------------------------------------
int __cdecl sub_812CEB4(int a1, char *nptr)
{
  int v4; // [esp+14h] [ebp-4h]

  v4 = atoi(nptr);
  if ( v4 < 0 || v4 > 1 )
    return 0;
  *(_DWORD *)(a1 + 664) = v4;
  return 1;
}

//----- (0812CEF8) --------------------------------------------------------
_BOOL4 __cdecl sub_812CEF8(int a1, char *nptr)
{
  *(_DWORD *)(a1 + 668) = atoi(nptr);
  return *(_DWORD *)(a1 + 668) >= 0;
}

//----- (0812CF38) --------------------------------------------------------
int __cdecl sub_812CF38(int a1, char *nptr)
{
  float v4; // [esp+14h] [ebp-4h]

  v4 = atof(nptr);
  if ( v4 < 0.0 )
    return 0;
  *(float *)(a1 + 672) = v4;
  return 1;
}

//----- (0812CF7C) --------------------------------------------------------
int __cdecl sub_812CF7C(int a1, int a2, char *s, int a4)
{
  int i; // [esp+1Ch] [ebp-2Ch]
  int v7[4]; // [esp+20h] [ebp-28h]
  int v8[6]; // [esp+30h] [ebp-18h]

  if ( !(unsigned __int8)sub_812B7A4(a1, s, (int)v8, (int)v7) )
    return 0;
  for ( i = 0; i != 3; ++i )
    sub_812F15A((_DWORD *)(a2 + 8 * (i + 8 * a4)), v8[i], v7[i]);
  *(_BYTE *)(a2 + (a4 << 6) + 60) = 1;
  return 1;
}
// 812CF7C: using guessed type int var_28[4];
// 812CF7C: using guessed type int var_18[6];

//----- (0812D010) --------------------------------------------------------
int __cdecl sub_812D010(int a1, int a2, char *s, int a4)
{
  int i; // [esp+1Ch] [ebp-2Ch]
  int v7[4]; // [esp+20h] [ebp-28h]
  int v8[6]; // [esp+30h] [ebp-18h]

  if ( !(unsigned __int8)sub_812B7A4(a1, s, (int)v8, (int)v7) )
    return 0;
  for ( i = 0; i != 3; ++i )
    sub_812F15A((_DWORD *)(a2 + 8 * (i + 8 * a4) + 24), v8[i], v7[i]);
  *(_BYTE *)(a2 + (a4 << 6) + 60) = 1;
  return 1;
}
// 812D010: using guessed type int var_28[4];
// 812D010: using guessed type int var_18[6];

//----- (0812D0A8) --------------------------------------------------------
int __cdecl sub_812D0A8(int a1, int a2, char *s, int a4)
{
  int v6; // [esp+20h] [ebp-8h]
  int v7; // [esp+24h] [ebp-4h]

  if ( !(unsigned __int8)sub_812B73A(a1, s, (int)&v7, (int)&v6) )
    return 0;
  if ( *(float *)&v7 > (long double)*(float *)&v6 )
    sub_812F2F6(&v7, &v6);
  sub_812F15A((_DWORD *)(a2 + (a4 << 6)), v7, v6);
  *(_BYTE *)(a2 + (a4 << 6) + 60) = 1;
  return 1;
}

//----- (0812D13C) --------------------------------------------------------
int __cdecl sub_812D13C(int a1, int a2, char *s, int a4)
{
  int v6; // [esp+20h] [ebp-8h]
  int v7; // [esp+24h] [ebp-4h]

  if ( !(unsigned __int8)sub_812B73A(a1, s, (int)&v7, (int)&v6) )
    return 0;
  if ( *(float *)&v7 > (long double)*(float *)&v6 )
    sub_812F2F6(&v7, &v6);
  sub_812F15A((_DWORD *)(a2 + (a4 << 6) + 24), v7, v6);
  *(_BYTE *)(a2 + (a4 << 6) + 60) = 1;
  return 1;
}

//----- (0812D1D2) --------------------------------------------------------
int __cdecl sub_812D1D2(int a1, int a2, char *s, int a4)
{
  int v6; // [esp+20h] [ebp-8h]
  int v7; // [esp+24h] [ebp-4h]

  if ( !(unsigned __int8)sub_812B73A(a1, s, (int)&v7, (int)&v6) )
    return 0;
  sub_812F15A((_DWORD *)(a2 + (a4 << 6) + 48), v7, v6);
  *(_BYTE *)(a2 + (a4 << 6) + 60) = 1;
  return 1;
}

//----- (0812D246) --------------------------------------------------------
int __cdecl sub_812D246(int a1, int a2, char *s, int a4)
{
  int v6; // [esp+14h] [ebp-4h]

  if ( !(unsigned __int8)sub_812B850(a1, s, (int)&v6) )
    return 0;
  *(_DWORD *)(a2 + (a4 << 6) + 56) |= v6;
  *(_BYTE *)(a2 + (a4 << 6) + 60) = 1;
  return 1;
}

//----- (0812D2B4) --------------------------------------------------------
signed int __cdecl sub_812D2B4(int a1, int a2)
{
  int v2; // ST10_4
  int v3; // ST10_4
  int i; // [esp+Ch] [ebp-Ch]

  if ( byte_8168610 )
  {
    if ( (unsigned __int8)sub_812FD7E(a2) )
    {
      for ( i = sub_812F330(a2); i; i = sub_812F318(i) )
      {
        sub_812A5EA(i);
        v2 = sub_812F0DE();
        sub_812A452(a1 + 104, v2);
      }
    }
    else
    {
      if ( !sub_812FDB4(a2) )
      {
        sub_812F0A2("PrimitiveTemplate::ParseMaterials called with an empty list!\n");
        return 0;
      }
      v3 = sub_812F0DE();
      sub_812A452(a1 + 104, v3);
    }
    return 1;
  }
  return 1;
}
// 8168610: using guessed type char byte_8168610;

//----- (0812D392) --------------------------------------------------------
signed int __cdecl sub_812D392(int a1, int a2)
{
  int v3; // [esp+8h] [ebp-10h]
  int i; // [esp+Ch] [ebp-Ch]
  int v5; // [esp+10h] [ebp-8h]
  int v6; // [esp+10h] [ebp-8h]
  char *s1; // [esp+14h] [ebp-4h]
  char *s1a; // [esp+14h] [ebp-4h]

  if ( (unsigned __int8)sub_812FD7E(a2) )
  {
    for ( i = sub_812F330(a2); i; i = sub_812F318(i) )
    {
      s1 = (char *)sub_812A5EA(i);
      v5 = sub_812F0E8(s1);
      if ( !v5 )
      {
        sub_812F0A2("PrimitiveTemplate::ParseModels, could not register model '%s'\n", s1);
        return 0;
      }
      sub_812A452(a1 + 104, v5);
    }
    return 1;
  }
  s1a = (char *)sub_812FDB4(a2);
  if ( s1a )
  {
    v6 = sub_812F0E8(s1a);
    if ( v6 )
    {
      sub_812A452(a1 + 104, v6);
      return 1;
    }
    sub_812F0A2("PrimitiveTemplate::ParseModels, could not register model '%s'\n", s1a);
    v3 = 0;
  }
  else
  {
    sub_812F0A2("PrimitiveTemplate::ParseModels called with an empty list!\n");
    v3 = 0;
  }
  return v3;
}

//----- (0812D4A0) --------------------------------------------------------
signed int __cdecl sub_812D4A0(int a1, int a2)
{
  _BYTE *v2; // ST14_4
  int v4; // [esp+8h] [ebp-10h]
  int i; // [esp+Ch] [ebp-Ch]
  void *v6; // [esp+10h] [ebp-8h]
  void *v7; // [esp+10h] [ebp-8h]
  _BYTE *v8; // [esp+14h] [ebp-4h]

  if ( (unsigned __int8)sub_812FD7E(a2) )
  {
    for ( i = sub_812F330(a2); i; i = sub_812F318(i) )
    {
      v2 = (_BYTE *)sub_812A5EA(i);
      v6 = sub_8129F6A(v2);
      if ( !v6 )
      {
        sub_812F0A2("FxTemplate: Impact effect file not found.\n");
        return 0;
      }
      sub_812A50C(a1 + 112, (int)v6);
    }
    goto LABEL_12;
  }
  v8 = (_BYTE *)sub_812FDB4(a2);
  if ( v8 )
  {
    v7 = sub_8129F6A(v8);
    if ( v7 )
    {
      sub_812A50C(a1 + 112, (int)v7);
LABEL_12:
      *(_DWORD *)(a1 + 144) |= 0x820u;
      return 1;
    }
    sub_812F0A2("FxTemplate: Impact effect file not found.\n");
    v4 = 0;
  }
  else
  {
    sub_812F0A2("PrimitiveTemplate::ParseImpactFxStrings called with an empty list!\n");
    v4 = 0;
  }
  return v4;
}

//----- (0812D5BC) --------------------------------------------------------
signed int __cdecl sub_812D5BC(int a1, int a2)
{
  _BYTE *v2; // ST14_4
  int v4; // [esp+8h] [ebp-10h]
  int i; // [esp+Ch] [ebp-Ch]
  void *v6; // [esp+10h] [ebp-8h]
  void *v7; // [esp+10h] [ebp-8h]
  _BYTE *v8; // [esp+14h] [ebp-4h]

  if ( (unsigned __int8)sub_812FD7E(a2) )
  {
    for ( i = sub_812F330(a2); i; i = sub_812F318(i) )
    {
      v2 = (_BYTE *)sub_812A5EA(i);
      v6 = sub_8129F6A(v2);
      if ( !v6 )
      {
        sub_812F0A2("FxTemplate: Death effect file not found.\n");
        return 0;
      }
      sub_812A50C(a1 + 120, (int)v6);
    }
    goto LABEL_12;
  }
  v8 = (_BYTE *)sub_812FDB4(a2);
  if ( v8 )
  {
    v7 = sub_8129F6A(v8);
    if ( v7 )
    {
      sub_812A50C(a1 + 120, (int)v7);
LABEL_12:
      *(_DWORD *)(a1 + 144) |= 0x200u;
      return 1;
    }
    sub_812F0A2("FxTemplate: Death effect file not found.\n");
    v4 = 0;
  }
  else
  {
    sub_812F0A2("PrimitiveTemplate::ParseDeathFxStrings called with an empty list!\n");
    v4 = 0;
  }
  return v4;
}

//----- (0812D6D8) --------------------------------------------------------
signed int __cdecl sub_812D6D8(int a1, int a2)
{
  _BYTE *v2; // ST14_4
  int v4; // [esp+8h] [ebp-10h]
  int i; // [esp+Ch] [ebp-Ch]
  void *v6; // [esp+10h] [ebp-8h]
  void *v7; // [esp+10h] [ebp-8h]
  _BYTE *v8; // [esp+14h] [ebp-4h]

  if ( (unsigned __int8)sub_812FD7E(a2) )
  {
    for ( i = sub_812F330(a2); i; i = sub_812F318(i) )
    {
      v2 = (_BYTE *)sub_812A5EA(i);
      v6 = sub_8129F6A(v2);
      if ( !v6 )
      {
        sub_812F0A2("FxTemplate: Emitter effect file not found.\n");
        return 0;
      }
      sub_812A50C(a1 + 128, (int)v6);
    }
    goto LABEL_12;
  }
  v8 = (_BYTE *)sub_812FDB4(a2);
  if ( v8 )
  {
    v7 = sub_8129F6A(v8);
    if ( v7 )
    {
      sub_812A50C(a1 + 128, (int)v7);
LABEL_12:
      *(_DWORD *)(a1 + 144) |= 0x100u;
      return 1;
    }
    sub_812F0A2("FxTemplate: Emitter effect file not found.\n");
    v4 = 0;
  }
  else
  {
    sub_812F0A2("PrimitiveTemplate::ParseEmitterFxStrings called with an empty list!\n");
    v4 = 0;
  }
  return v4;
}

//----- (0812D7F4) --------------------------------------------------------
signed int __cdecl sub_812D7F4(int a1, int a2)
{
  _BYTE *v2; // ST14_4
  int v4; // [esp+8h] [ebp-10h]
  int i; // [esp+Ch] [ebp-Ch]
  void *v6; // [esp+10h] [ebp-8h]
  void *v7; // [esp+10h] [ebp-8h]
  _BYTE *v8; // [esp+14h] [ebp-4h]

  if ( (unsigned __int8)sub_812FD7E(a2) )
  {
    for ( i = sub_812F330(a2); i; i = sub_812F318(i) )
    {
      v2 = (_BYTE *)sub_812A5EA(i);
      v6 = sub_8129F6A(v2);
      if ( !v6 )
      {
        sub_812F0A2("FxTemplate: Effect file not found.\n");
        return 0;
      }
      sub_812A50C(a1 + 136, (int)v6);
    }
    return 1;
  }
  v8 = (_BYTE *)sub_812FDB4(a2);
  if ( v8 )
  {
    v7 = sub_8129F6A(v8);
    if ( v7 )
    {
      sub_812A50C(a1 + 136, (int)v7);
      return 1;
    }
    sub_812F0A2("FxTemplate: Effect file not found.\n");
    v4 = 0;
  }
  else
  {
    sub_812F0A2("PrimitiveTemplate::ParsePlayFxStrings called with an empty list!\n");
    v4 = 0;
  }
  return v4;
}

//----- (0812D8FC) --------------------------------------------------------
void __cdecl sub_812D8FC(int a1, int a2, int a3)
{
  const char *v3; // eax
  _DWORD *ptr; // [esp+24h] [ebp-14h]
  int v5; // [esp+28h] [ebp-10h]
  int v6; // [esp+28h] [ebp-10h]
  int i; // [esp+2Ch] [ebp-Ch]
  int j; // [esp+2Ch] [ebp-Ch]
  int v9; // [esp+30h] [ebp-8h]

  v9 = sub_812F330(a2);
  v5 = 0;
  for ( i = v9; i; i = sub_812F318(i) )
    ++v5;
  ptr = Hunk_AllocateTempMemory(16 * v5);
  v6 = 0;
  for ( j = v9; j; j = sub_812F318(j) )
  {
    v3 = (const char *)sub_812A5EA(j);
    sscanf(v3, "%f %f %f %f", &ptr[4 * v6], &ptr[4 * v6 + 1], &ptr[4 * v6 + 2], &ptr[4 * v6 + 3]);
    ++v6;
  }
  *(_DWORD *)(a1 + 12 * a3 + 256) = sub_8121AAC(ptr, 3, v6);
  sub_80AA0C8(ptr);
}

//----- (0812DA14) --------------------------------------------------------
void __cdecl sub_812DA14(int a1, int a2, int a3)
{
  const char *v3; // eax
  _DWORD *ptr; // [esp+14h] [ebp-14h]
  int v5; // [esp+18h] [ebp-10h]
  int v6; // [esp+18h] [ebp-10h]
  int i; // [esp+1Ch] [ebp-Ch]
  int j; // [esp+1Ch] [ebp-Ch]
  int v9; // [esp+20h] [ebp-8h]

  v9 = sub_812F330(a2);
  v5 = 0;
  for ( i = v9; i; i = sub_812F318(i) )
    ++v5;
  ptr = Hunk_AllocateTempMemory(8 * v5);
  v6 = 0;
  for ( j = v9; j; j = sub_812F318(j) )
  {
    v3 = (const char *)sub_812A5EA(j);
    sscanf(v3, "%f %f", &ptr[2 * v6], &ptr[2 * v6 + 1]);
    ++v6;
  }
  *(_DWORD *)(a1 + 12 * a3 + 256) = sub_8121AAC(ptr, 1, v6);
  sub_80AA0C8(ptr);
}

//----- (0812DB0C) --------------------------------------------------------
int __cdecl sub_812DB0C(int a1, char *s, int a3)
{
  int result; // eax
  int v4; // [esp+10h] [ebp-8h]
  int v5; // [esp+14h] [ebp-4h]

  result = sub_812B73A(a1, s, (int)&v5, (int)&v4);
  if ( (_BYTE)result )
    result = sub_812F15A((_DWORD *)(a1 + 12 * a3 + 260), v5, v4);
  return result;
}

//----- (0812DB62) --------------------------------------------------------
signed int __cdecl sub_812DB62(int a1, int a2, int a3, int a4)
{
  char *s; // [esp+1Ch] [ebp-Ch]
  char *s1; // [esp+20h] [ebp-8h]
  int i; // [esp+24h] [ebp-4h]

  for ( i = sub_812F33C(a3); i; i = sub_812F324(i) )
  {
    s1 = (char *)sub_812A5EA(i);
    s = (char *)sub_812FDB4(i);
    if ( !strcasecmp(s1, "curve") )
    {
      if ( a4 && a4 != 1 )
        sub_812DA14(a1, i, a4);
      else
        sub_812D8FC(a1, i, a4);
    }
    else if ( !strcasecmp(s1, "scale") )
    {
      sub_812DB0C(a1, s, a4);
    }
    else if ( !strcasecmp(s1, "start") )
    {
      if ( a4 && a4 != 1 )
        sub_812D0A8(a1, a2, s, a4);
      else
        sub_812CF7C(a1, a2, s, a4);
    }
    else if ( !strcasecmp(s1, "end") )
    {
      if ( a4 && a4 != 1 )
        sub_812D13C(a1, a2, s, a4);
      else
        sub_812D010(a1, a2, s, a4);
    }
    else if ( !strcasecmp(s1, "parm") || !strcasecmp(s1, "parms") )
    {
      sub_812D1D2(a1, a2, s, a4);
    }
    else if ( !strcasecmp(s1, "flags") || !strcasecmp(s1, "flag") )
    {
      sub_812D246(a1, a2, s, a4);
    }
    else
    {
      sub_812F0A2("Unknown key parsing a channel: %s\n", s1);
    }
  }
  return 1;
}

//----- (0812DDDE) --------------------------------------------------------
int __cdecl sub_812DDDE(int a1, char *src)
{
  I_strncpyz((char *)(a1 + 32), src, 32);
  return 1;
}

//----- (0812DE08) --------------------------------------------------------
int __cdecl sub_812DE08(char *dest, void *s, int a3)
{
  signed int v4; // [esp+1Ch] [ebp-1Ch]
  char *nptr; // [esp+24h] [ebp-14h]
  char *s1; // [esp+28h] [ebp-10h]
  int v7; // [esp+2Ch] [ebp-Ch]
  int v8; // [esp+30h] [ebp-8h]

  v7 = sub_812F33C(a3);
  s1 = 0;
  sub_812B5B6((int)dest, s);
  while ( v7 )
  {
    s1 = (char *)sub_812A5EA(v7);
    nptr = (char *)sub_812FDB4(v7);
    if ( !strcasecmp(s1, "count") )
    {
      if ( !(unsigned __int8)sub_812BC48((int)dest, nptr) )
        break;
    }
    else if ( !strcasecmp(s1, "shaders") || !strcasecmp(s1, "shader") )
    {
      if ( !(unsigned __int8)sub_812D2B4((int)dest, v7) )
        break;
    }
    else if ( !strcasecmp(s1, "models") || !strcasecmp(s1, "model") )
    {
      if ( !(unsigned __int8)sub_812D392((int)dest, v7) )
        break;
    }
    else if ( !strcasecmp(s1, "impactfx") )
    {
      if ( !(unsigned __int8)sub_812D4A0((int)dest, v7) )
        break;
    }
    else if ( !strcasecmp(s1, "deathfx") )
    {
      if ( !(unsigned __int8)sub_812D5BC((int)dest, v7) )
        break;
    }
    else if ( !strcasecmp(s1, "emitfx") )
    {
      if ( !(unsigned __int8)sub_812D6D8((int)dest, v7) )
        break;
    }
    else if ( !strcasecmp(s1, "playfx") )
    {
      if ( !(unsigned __int8)sub_812D7F4((int)dest, v7) )
        break;
    }
    else if ( !strcasecmp(s1, "life") )
    {
      if ( !(unsigned __int8)sub_812BB1A((int)dest, nptr) )
        break;
    }
    else if ( !strcasecmp(s1, "cullrange") )
    {
      *((float *)dest + 25) = atof(nptr);
    }
    else if ( !strcasecmp(s1, "spawnRange") )
    {
      if ( !(unsigned __int8)sub_812BB76((int)dest, nptr) )
        break;
    }
    else if ( !strcasecmp(s1, "delay") )
    {
      if ( !(unsigned __int8)sub_812BBEC((int)dest, nptr) )
        break;
    }
    else if ( !strcasecmp(s1, "bounce") || !strcasecmp(s1, "intensity") )
    {
      if ( !(unsigned __int8)sub_812BCA4((int)dest, nptr) )
        break;
    }
    else if ( !strcasecmp(s1, "min") )
    {
      if ( !(unsigned __int8)sub_812BA42((int)dest, nptr) )
        break;
    }
    else if ( !strcasecmp(s1, "max") )
    {
      if ( !(unsigned __int8)sub_812BAAE((int)dest, nptr) )
        break;
    }
    else if ( !strcasecmp(s1, "angle") || !strcasecmp(s1, "angles") )
    {
      if ( !(unsigned __int8)sub_812C46E((int)dest, nptr) )
        break;
    }
    else if ( !strcasecmp(s1, "angleDelta") )
    {
      if ( !(unsigned __int8)sub_812C508((int)dest, nptr) )
        break;
    }
    else if ( !strcasecmp(s1, "velocity") || !strcasecmp(s1, "vel") )
    {
      if ( !(unsigned __int8)sub_812C5A2((int)dest, nptr) )
        break;
    }
    else if ( !strcasecmp(s1, "acceleration") || !strcasecmp(s1, "accel") )
    {
      if ( !(unsigned __int8)sub_812C9D4((int)dest, nptr) )
        break;
    }
    else if ( !strcasecmp(s1, "gravity") )
    {
      if ( !(unsigned __int8)sub_812CC8A((int)dest, nptr) )
        break;
    }
    else if ( !strcasecmp(s1, "density") )
    {
      if ( !(unsigned __int8)sub_812CCE8((int)dest, nptr) )
        break;
    }
    else if ( !strcasecmp(s1, "variance") )
    {
      if ( !(unsigned __int8)sub_812CD46((int)dest, nptr) )
        break;
    }
    else if ( !strcasecmp(s1, "origin") )
    {
      if ( !(unsigned __int8)sub_812BD9A((int)dest, nptr) )
        break;
    }
    else if ( !strcasecmp(s1, "origin2") )
    {
      if ( !(unsigned __int8)sub_812BE34((int)dest, nptr) )
        break;
    }
    else if ( !strcasecmp(s1, "radius") )
    {
      if ( !(unsigned __int8)sub_812BECE((int)dest, nptr) )
        break;
    }
    else if ( !strcasecmp(s1, "height") )
    {
      if ( !(unsigned __int8)sub_812BF2C((int)dest, nptr) )
        break;
    }
    else if ( !strcasecmp(s1, "wind") )
    {
      if ( !(unsigned __int8)sub_812BF8A((int)dest, nptr) )
        break;
    }
    else if ( !strcasecmp(s1, "rotation") )
    {
      if ( !(unsigned __int8)sub_812BFE8((int)dest, nptr) )
        break;
    }
    else if ( I_stricmp(s1, "rotationDelta") )
    {
      if ( !strcasecmp(s1, "flags") || !strcasecmp(s1, "flag") )
      {
        if ( !(unsigned __int8)sub_812C978((int)dest, nptr) )
          break;
      }
      else if ( !strcasecmp(s1, "spawnFlags") || !strcasecmp(s1, "spawnFlag") )
      {
        if ( !(unsigned __int8)sub_812C9A6((int)dest, nptr) )
          break;
      }
      else if ( !strcasecmp(s1, "nonUniformScale") )
      {
        dest[156] = atoi(nptr) != 0;
      }
      else if ( !strcasecmp(s1, "useLength") )
      {
        dest[157] = atoi(nptr) != 0;
      }
      else if ( !strcasecmp(s1, "name") )
      {
        if ( !nptr )
          break;
        I_strncpyz(dest, nptr, 32);
      }
      else if ( !strcasecmp(s1, "shaderImpact") )
      {
        if ( !(unsigned __int8)sub_812DDDE((int)dest, nptr) )
          break;
      }
      else if ( !strcasecmp(s1, "sequenceStartFrameMode") )
      {
        if ( !(unsigned __int8)sub_812CDA4((int)dest, nptr) )
          break;
      }
      else if ( !strcasecmp(s1, "sequenceFixedFrameValue") )
      {
        if ( !(unsigned __int8)sub_812CDE8((int)dest, nptr) )
          break;
      }
      else if ( !strcasecmp(s1, "sequencePlayRateMode") )
      {
        if ( !(unsigned __int8)sub_812CE28((int)dest, nptr) )
          break;
      }
      else if ( !strcasecmp(s1, "sequenceFixedFpsValue") )
      {
        if ( !(unsigned __int8)sub_812CE6C((int)dest, nptr) )
          break;
      }
      else if ( !strcasecmp(s1, "sequenceLoopMode") )
      {
        if ( !(unsigned __int8)sub_812CEB4((int)dest, nptr) )
          break;
      }
      else if ( !strcasecmp(s1, "sequenceLoopTimes") )
      {
        if ( !(unsigned __int8)sub_812CEF8((int)dest, nptr) )
          break;
      }
      else
      {
        if ( strcasecmp(s1, "spawnFrustumCullRadius") )
        {
          sub_812F0A2("Unknown key parsing an effect primitive: %s\n", s1);
          return 0;
        }
        if ( !(unsigned __int8)sub_812CF38((int)dest, nptr) )
          break;
      }
    }
    else if ( !(unsigned __int8)sub_812C354((int)dest, nptr) )
    {
      break;
    }
    v7 = sub_812F324(v7);
    s1 = 0;
  }
  if ( s1 )
  {
    sub_812F0A2("^1FX Error while parsing key '%s'\n", s1);
    v4 = 0;
  }
  else if ( *((float *)dest + 40) <= (long double)*((float *)dest + 43)
         && *((float *)dest + 41) <= (long double)*((float *)dest + 44)
         && *((float *)dest + 42) <= (long double)*((float *)dest + 45) )
  {
    if ( *((float *)dest + 43) - *((float *)dest + 40) <= *((float *)dest + 45) - *((float *)dest + 42)
      && *((float *)dest + 44) - *((float *)dest + 41) <= *((float *)dest + 45) - *((float *)dest + 42) )
    {
      v8 = sub_812A600(a3);
      while ( v8 )
      {
        s1 = (char *)sub_812A5EA(v8);
        if ( !strcasecmp(s1, "rgb") )
        {
          if ( !(unsigned __int8)sub_812DB62((int)dest, (int)s, v8, 0) )
            break;
        }
        else if ( !strcasecmp(s1, "rgb2") || !strcasecmp(s1, "rgbRand") )
        {
          if ( !(unsigned __int8)sub_812DB62((int)dest, (int)s, v8, 1) )
            break;
        }
        else if ( !strcasecmp(s1, "alpha") )
        {
          if ( !(unsigned __int8)sub_812DB62((int)dest, (int)s, v8, 2) )
            break;
        }
        else if ( !strcasecmp(s1, "alphaRand") )
        {
          if ( !(unsigned __int8)sub_812DB62((int)dest, (int)s, v8, 3) )
            break;
        }
        else if ( !strcasecmp(s1, "size") || !strcasecmp(s1, "width") )
        {
          if ( !(unsigned __int8)sub_812DB62((int)dest, (int)s, v8, 4) )
            break;
        }
        else if ( !strcasecmp(s1, "sizeRand") )
        {
          if ( !(unsigned __int8)sub_812DB62((int)dest, (int)s, v8, 5) )
            break;
        }
        else if ( !strcasecmp(s1, "size2") || !strcasecmp(s1, "width2") )
        {
          if ( !(unsigned __int8)sub_812DB62((int)dest, (int)s, v8, 6) )
            break;
        }
        else if ( !strcasecmp(s1, "size2Rand") )
        {
          if ( !(unsigned __int8)sub_812DB62((int)dest, (int)s, v8, 7) )
            break;
        }
        else if ( !strcasecmp(s1, "length") || !strcasecmp(s1, "height") )
        {
          if ( !(unsigned __int8)sub_812DB62((int)dest, (int)s, v8, 8) )
            break;
        }
        else if ( !strcasecmp(s1, "lengthRand") )
        {
          if ( !(unsigned __int8)sub_812DB62((int)dest, (int)s, v8, 9) )
            break;
        }
        else if ( !strcasecmp(s1, "rotationDelta") )
        {
          if ( !(unsigned __int8)sub_812DB62((int)dest, (int)s, v8, 10) )
            break;
        }
        else if ( !strcasecmp(s1, "rotationDeltaRand") )
        {
          if ( !(unsigned __int8)sub_812DB62((int)dest, (int)s, v8, 11) )
            break;
        }
        else if ( !strcasecmp(s1, "velocityX") )
        {
          if ( !(unsigned __int8)sub_812DB62((int)dest, (int)s, v8, 12) )
            break;
        }
        else if ( !strcasecmp(s1, "velocityY") )
        {
          if ( !(unsigned __int8)sub_812DB62((int)dest, (int)s, v8, 13) )
            break;
        }
        else if ( !strcasecmp(s1, "velocityZ") )
        {
          if ( !(unsigned __int8)sub_812DB62((int)dest, (int)s, v8, 14) )
            break;
        }
        else if ( !strcasecmp(s1, "velocityXRand") )
        {
          if ( !(unsigned __int8)sub_812DB62((int)dest, (int)s, v8, 15) )
            break;
        }
        else if ( !strcasecmp(s1, "velocityYRand") )
        {
          if ( !(unsigned __int8)sub_812DB62((int)dest, (int)s, v8, 16) )
            break;
        }
        else if ( !strcasecmp(s1, "velocityZRand") )
        {
          if ( !(unsigned __int8)sub_812DB62((int)dest, (int)s, v8, 17) )
            break;
        }
        else if ( !strcasecmp(s1, "velocity2X") )
        {
          if ( !(unsigned __int8)sub_812DB62((int)dest, (int)s, v8, 18) )
            break;
        }
        else if ( !strcasecmp(s1, "velocity2Y") )
        {
          if ( !(unsigned __int8)sub_812DB62((int)dest, (int)s, v8, 19) )
            break;
        }
        else if ( !strcasecmp(s1, "velocity2Z") )
        {
          if ( !(unsigned __int8)sub_812DB62((int)dest, (int)s, v8, 20) )
            break;
        }
        else if ( !strcasecmp(s1, "velocity2XRand") )
        {
          if ( !(unsigned __int8)sub_812DB62((int)dest, (int)s, v8, 21) )
            break;
        }
        else if ( !strcasecmp(s1, "velocity2YRand") )
        {
          if ( !(unsigned __int8)sub_812DB62((int)dest, (int)s, v8, 22) )
            break;
        }
        else
        {
          if ( strcasecmp(s1, "velocity2ZRand") )
          {
            sub_812F0A2("Unknown group key parsing a particle: %s\n", s1);
            return 0;
          }
          if ( !(unsigned __int8)sub_812DB62((int)dest, (int)s, v8, 23) )
            break;
        }
        v8 = sub_812A5F4(v8);
        s1 = 0;
      }
      if ( s1 )
      {
        sub_812F0A2("^1FX Error while parsing key '%s'\n", s1);
        v4 = 0;
      }
      else
      {
        sub_812B68C((int)dest, (int)s);
        v4 = 1;
      }
    }
    else
    {
      sub_812F0A2("^1FX bounding box width or depth is larger than height for effect '%s'\n", dest);
      v4 = 0;
    }
  }
  else
  {
    sub_812F0A2("^1FX bounding box mins / maxs invalid for effect '%s'\n", dest);
    v4 = 0;
  }
  return v4;
}

//----- (0812F060) --------------------------------------------------------
int __cdecl sub_812F060(char *dest, int a2)
{
  _DWORD *ptr; // ST10_4
  unsigned __int8 v3; // ST17_1

  ptr = Hunk_AllocateTempMemory(0x600u);
  v3 = sub_812DE08(dest, ptr, a2);
  sub_80AA0C8(ptr);
  return v3;
}

//----- (0812F0A2) --------------------------------------------------------
void sub_812F0A2(char *format, ...)
{
  char s; // [esp+10h] [ebp-418h]
  __gnuc_va_list __varargs; // [esp+41Ch] [ebp-Ch]
  va_list va; // [esp+434h] [ebp+Ch]

  va_start(va, format);
  va_copy(__varargs, va);
  vsprintf(&s, format, va);
  Com_Printf(&s);
}

//----- (0812F0DE) --------------------------------------------------------
int sub_812F0DE()
{
  return 0;
}

//----- (0812F0E8) --------------------------------------------------------
int __cdecl sub_812F0E8(char *s1)
{
  int v2; // [esp+10h] [ebp-8h]

  if ( (unsigned __int8)sub_80C3820(s1) )
    v2 = sub_8122206(s1 + 7);
  else
    v2 = 0;
  return v2;
}

//----- (0812F15A) --------------------------------------------------------
int __cdecl sub_812F15A(_DWORD *a1, int a2, int a3)
{
  int result; // eax

  *a1 = a2;
  result = a3;
  a1[1] = a3;
  return result;
}

//----- (0812F170) --------------------------------------------------------
long double __cdecl sub_812F170(float *a1)
{
  float v2; // [esp+14h] [ebp-4h]

  if ( *a1 == a1[1] )
    v2 = *a1;
  else
    v2 = sub_80A8720(*a1, a1[1]);
  return v2;
}

//----- (0812F1B8) --------------------------------------------------------
long double __cdecl sub_812F1B8(int a1, float a2)
{
  return (*(float *)(a1 + 4) - *(float *)a1) * a2 + *(float *)a1;
}

//----- (0812F1D0) --------------------------------------------------------
void __cdecl sub_812F1D0(float a1, float a2)
{
  float v2; // ST00_4

  v2 = a1 - a2;
  sub_812F2CC(v2, a1, a2);
}

//----- (0812F1F4) --------------------------------------------------------
long double __cdecl sub_812F1F4(float a1, float a2, float a3)
{
  float v3; // ST00_4
  float v4; // ST08_4
  float v5; // ST00_4

  v3 = a1 - a3;
  v4 = sub_812F2CC(v3, a3, a1);
  v5 = a2 - a1;
  return sub_812F2CC(v5, a2, v4);
}

//----- (0812F232) --------------------------------------------------------
int __cdecl sub_812F232(_DWORD *a1, _DWORD *a2)
{
  int result; // eax

  *a2 = *a1;
  a2[1] = a1[1];
  result = a1[2];
  a2[2] = result;
  return result;
}

//----- (0812F262) --------------------------------------------------------
signed int __cdecl sub_812F262(float *a1, float *a2)
{
  signed int v3; // [esp+0h] [ebp-4h]

  v3 = 0;
  if ( *a1 == *a2 && a1[1] == a2[1] && a1[2] == a2[2] )
    v3 = 1;
  return v3;
}

//----- (0812F2CC) --------------------------------------------------------
long double __cdecl sub_812F2CC(float a1, float a2, float a3)
{
  float v4; // [esp+0h] [ebp-4h]

  if ( a1 < 0.0 )
    v4 = a3;
  else
    v4 = a2;
  return v4;
}

//----- (0812F2F6) --------------------------------------------------------
int __cdecl sub_812F2F6(int *a1, int *a2)
{
  int v2; // ST00_4
  int result; // eax

  v2 = *a1;
  *a1 = *a2;
  result = v2;
  *a2 = v2;
  return result;
}

//----- (0812F318) --------------------------------------------------------
int __cdecl sub_812F318(int a1)
{
  return *(_DWORD *)(a1 + 4);
}

//----- (0812F324) --------------------------------------------------------
int __cdecl sub_812F324(int a1)
{
  return *(_DWORD *)(a1 + 4);
}

//----- (0812F330) --------------------------------------------------------
int __cdecl sub_812F330(int a1)
{
  return *(_DWORD *)(a1 + 16);
}

//----- (0812F33C) --------------------------------------------------------
int __cdecl sub_812F33C(int a1)
{
  return *(_DWORD *)(a1 + 16);
}

//----- (0812F348) --------------------------------------------------------
void sub_812F348()
{
  ;
}

//----- (0812F34E) --------------------------------------------------------
void sub_812F34E()
{
  int i; // [esp+4h] [ebp-4h]

  for ( i = 0; i <= 0; ++i )
  {
    if ( dword_89A280C[i] )
    {
      sub_812F348();
      return;
    }
  }
}

//----- (0812F386) --------------------------------------------------------
int __cdecl sub_812F386(int a1, int a2)
{
  int v2; // eax
  int v4; // [esp+10h] [ebp-8h]
  int v5; // [esp+14h] [ebp-4h]

  v2 = sub_806C8C0();
  v5 = sub_8062844(a1, v2);
  if ( v5 )
    v4 = sub_80B8AF6(v5, a2);
  else
    v4 = -1;
  return v4;
}

//----- (0812F3CC) --------------------------------------------------------
void __cdecl sub_812F3CC(_DWORD *a1, float *a2)
{
  sub_8128858((int *)dword_89A2814, a1, a2);
}

//----- (0812F3F0) --------------------------------------------------------
void __cdecl sub_812F3F0(_DWORD *a1, float *a2, _DWORD *a3)
{
  sub_8128900((int *)dword_89A2814, a1, a2, a3);
}

//----- (0812F41A) --------------------------------------------------------
void __cdecl sub_812F41A(_DWORD *a1, float *a2, _DWORD *a3, _DWORD *a4)
{
  sub_8128962((int *)dword_89A2814, a1, a2, a3, a4);
}

//----- (0812F44C) --------------------------------------------------------
void __cdecl sub_812F44C(_DWORD *a1, float *a2, _DWORD *a3, _DWORD *a4)
{
  sub_8128ACC((int *)dword_89A2814, a1, a2, a3, a4);
}

//----- (0812F47E) --------------------------------------------------------
signed int __cdecl sub_812F47E(char a1)
{
  return sub_8131338(a1);
}

//----- (0812F498) --------------------------------------------------------
int sub_812F498()
{
  return sub_813127A(1);
}

//----- (0812F4AC) --------------------------------------------------------
int sub_812F4AC()
{
  return sub_813127A(0);
}

//----- (0812F4C0) --------------------------------------------------------
void __cdecl sub_812F4C0(int a1, float a2)
{
  sub_812AAD2(off_8168620, a1, a2);
  dword_89A2828 = 1;
}
// 89A2828: using guessed type int dword_89A2828;

//----- (0812F4EE) --------------------------------------------------------
int __cdecl sub_812F4EE(int a1)
{
  int result; // eax

  dword_89A2828 = 0;
  sub_812A6B4((_DWORD *)off_8168620, a1);
  dword_89B63AC = dword_89B63A0;
  result = dword_89B63A4;
  dword_89B63B0 = dword_89B63A4;
  return result;
}
// 89A2828: using guessed type int dword_89A2828;
// 89B63A0: using guessed type int dword_89B63A0;
// 89B63A4: using guessed type int dword_89B63A4;
// 89B63AC: using guessed type int dword_89B63AC;
// 89B63B0: using guessed type int dword_89B63B0;

//----- (0812F528) --------------------------------------------------------
int __cdecl sub_812F528(int a1)
{
  return sub_812A776((int *)off_8168620, a1);
}

//----- (0812F544) --------------------------------------------------------
void __cdecl sub_812F544(int a1)
{
  sub_8128E8A((int)dword_89A2814, a1);
}

//----- (0812F560) --------------------------------------------------------
char *__cdecl sub_812F560(char **a1, char a2, char a3)
{
  char *v3; // edx
  char v5; // [esp+1Ah] [ebp-Eh]
  char v6; // [esp+1Bh] [ebp-Dh]
  char v7; // [esp+1Bh] [ebp-Dh]
  char v8; // [esp+1Bh] [ebp-Dh]
  signed int n; // [esp+1Ch] [ebp-Ch]
  char *v10; // [esp+20h] [ebp-8h]

  v10 = *a1;
  n = 0;
  byte_89A2840[0] = 0;
  if ( v10 )
  {
    while ( 1 )
    {
      while ( 1 )
      {
        v5 = 0;
        while ( 1 )
        {
          v6 = *v10;
          if ( *v10 > 32 )
            break;
          if ( !v6 )
          {
            *a1 = 0;
            return byte_89A2840;
          }
          if ( v6 == 10 )
            v5 = 1;
          ++v10;
        }
        if ( v5 && !a2 )
        {
          *a1 = v10;
          return byte_89A2840;
        }
        v7 = *v10;
        if ( *v10 != 47 || v10[1] != 47 )
          break;
        for ( v10 += 2; *v10 && *v10 != 10; ++v10 )
          ;
      }
      if ( v7 != 47 || v10[1] != 42 )
        break;
      for ( v10 += 2; *v10 && (*v10 != 42 || v10[1] != 47); ++v10 )
        ;
      if ( *v10 )
        v10 += 2;
    }
    if ( v7 != 34 || a3 )
    {
      if ( a3 )
      {
        while ( v7 != 10 && v7 != 13 && (v7 != 47 || v10[1] != 47 && v10[1] != 42) )
        {
          if ( n <= 1023 )
            byte_89A2840[n++] = v7;
          v7 = *++v10;
        }
        while ( n && *(_BYTE *)(n + 144320575) <= 31 )
          --n;
      }
      else
      {
        while ( v7 > 32 )
        {
          if ( n <= 1023 )
            byte_89A2840[n++] = v7;
          v7 = *++v10;
        }
      }
    }
    else
    {
      ++v10;
      while ( 1 )
      {
        v3 = v10++;
        v8 = *v3;
        if ( *v3 == 34 || !v8 )
          break;
        if ( n <= 1023 )
          byte_89A2840[n++] = v8;
      }
    }
    if ( byte_89A2840[0] == 34 )
    {
      memmove(byte_89A2840, &unk_89A2841, --n);
      if ( n )
      {
        if ( *(_BYTE *)(n + 144320575) == 34 )
          --n;
      }
    }
    if ( n > 1023 )
      n = 0;
    *(_BYTE *)(n + 144320576) = 0;
    *a1 = v10;
  }
  return byte_89A2840;
}

//----- (0812F7FC) --------------------------------------------------------
void *__cdecl sub_812F7FC(_DWORD *a1, int a2)
{
  void *result; // eax

  a1[1] = 0;
  a1[2] = a2;
  a1[3] = 0;
  result = Z_MallocInternal(a1[2]);
  *a1 = result;
  return result;
}

//----- (0812F83A) --------------------------------------------------------
void *__cdecl sub_812F83A(_DWORD *a1, int a2)
{
  void *result; // eax

  a1[1] = 0;
  a1[2] = a2;
  a1[3] = 0;
  result = Z_MallocInternal(a1[2]);
  *a1 = result;
  return result;
}

//----- (0812F878) --------------------------------------------------------
void __cdecl sub_812F878(void **a1)
{
  Z_FreeInternal(*a1);
}

//----- (0812F88E) --------------------------------------------------------
void __cdecl sub_812F88E(void **a1)
{
  Z_FreeInternal(*a1);
}

//----- (0812F8A4) --------------------------------------------------------
int __cdecl sub_812F8A4(int a1, char *s, int a3, int a4)
{
  _DWORD *ptr; // ST20_4
  int v6; // [esp+24h] [ebp-14h]
  size_t v7; // [esp+28h] [ebp-10h]
  int v8; // [esp+2Ch] [ebp-Ch]

  v7 = strlen(s);
  if ( (_BYTE)a3 )
    v6 = v7 + 1;
  else
    v6 = v7;
  if ( *(_DWORD *)(a1 + 12) + v6 + 1 <= *(_DWORD *)(a1 + 8) )
  {
    strcpy((char *)(*(_DWORD *)a1 + *(_DWORD *)(a1 + 12)), s);
    *(_DWORD *)(a1 + 12) += v6;
    *(_BYTE *)(*(_DWORD *)a1 + *(_DWORD *)(a1 + 12)) = 0;
    v8 = *(_DWORD *)a1 + *(_DWORD *)(a1 + 12) - v6;
  }
  else if ( a4 )
  {
    ptr = sub_8130EDA(0x10u);
    sub_812F83A(ptr, *(_DWORD *)(a1 + 8));
    sub_8130ECC(*(_DWORD *)a4, (int)ptr);
    *(_DWORD *)a4 = sub_8130EC0(*(_DWORD *)a4);
    v8 = sub_812F8A4(*(_DWORD *)a4, s, (unsigned __int8)a3, 0);
  }
  else
  {
    v8 = 0;
  }
  return v8;
}

//----- (0812F9F8) --------------------------------------------------------
void __cdecl sub_812F9F8(void **a1)
{
  int v1; // [esp+14h] [ebp-4h]

  while ( a1 )
  {
    v1 = sub_8130EC0((int)a1);
    if ( a1 )
    {
      sub_812F88E(a1);
      sub_8130EEE(a1);
    }
    a1 = (void **)v1;
  }
}

//----- (0812FA42) --------------------------------------------------------
_DWORD *__cdecl sub_812FA42(_DWORD *a1, int a2)
{
  _DWORD *result; // eax

  *a1 = a2;
  a1[1] = 0;
  a1[2] = 0;
  result = a1;
  a1[3] = 0;
  return result;
}

//----- (0812FA6E) --------------------------------------------------------
_DWORD *__cdecl sub_812FA6E(_DWORD *a1, int a2)
{
  _DWORD *result; // eax

  *a1 = a2;
  a1[1] = 0;
  a1[2] = 0;
  result = a1;
  a1[3] = 0;
  return result;
}

//----- (0812FA9A) --------------------------------------------------------
int __cdecl sub_812FA9A(int a1, int a2, char *s)
{
  if ( !strchr(s, 32) && *s )
  {
    sub_812F8A4(*(_DWORD *)a2, s, 0, a2);
  }
  else
  {
    sub_812F8A4(*(_DWORD *)a2, asc_8159580, 0, a2);
    sub_812F8A4(*(_DWORD *)a2, s, 0, a2);
    sub_812F8A4(*(_DWORD *)a2, asc_8159580, 0, a2);
  }
  return 1;
}

//----- (0812FB56) --------------------------------------------------------
int __cdecl sub_812FB56(int a1, int a2, char *s)
{
  int result; // eax

  sub_812FA42((_DWORD *)a1, a2);
  result = a1;
  *(_DWORD *)(a1 + 16) = 0;
  if ( s )
    result = sub_812FDE2(a1, s, 0);
  return result;
}

//----- (0812FB9A) --------------------------------------------------------
int __cdecl sub_812FB9A(int a1, int a2, char *s)
{
  int result; // eax

  sub_812FA42((_DWORD *)a1, a2);
  result = a1;
  *(_DWORD *)(a1 + 16) = 0;
  if ( s )
    result = sub_812FDE2(a1, s, 0);
  return result;
}

//----- (0812FBDE) --------------------------------------------------------
int __cdecl sub_812FBDE(int a1)
{
  int result; // eax
  int v2; // ST04_4

  while ( 1 )
  {
    result = a1;
    if ( !*(_DWORD *)(a1 + 16) )
      break;
    v2 = sub_812F318(*(_DWORD *)(a1 + 16));
    sub_8130F4C(*(void **)(a1 + 16));
    *(_DWORD *)(a1 + 16) = v2;
  }
  return result;
}

//----- (0812FC1C) --------------------------------------------------------
int __cdecl sub_812FC1C(int a1)
{
  int result; // eax
  int v2; // ST04_4

  while ( 1 )
  {
    result = a1;
    if ( !*(_DWORD *)(a1 + 16) )
      break;
    v2 = sub_812F318(*(_DWORD *)(a1 + 16));
    sub_8130F4C(*(void **)(a1 + 16));
    *(_DWORD *)(a1 + 16) = v2;
  }
  return result;
}

//----- (0812FC5A) --------------------------------------------------------
void *__cdecl sub_812FC5A(int a1, int *a2)
{
  char *v2; // eax
  void *ptr; // [esp+28h] [ebp-10h]
  char *s; // [esp+2Ch] [ebp-Ch]
  char *sa; // [esp+2Ch] [ebp-Ch]
  int i; // [esp+30h] [ebp-8h]

  if ( a2 )
    s = (char *)sub_812F8A4(*a2, *(char **)a1, 1, (int)a2);
  else
    s = *(char **)a1;
  ptr = sub_8130F38(0x14u);
  sub_812FB9A((int)ptr, (int)s, 0);
  for ( i = *(_DWORD *)(a1 + 16); i; i = sub_812F318(i) )
  {
    if ( a2 )
    {
      v2 = (char *)sub_812A5EA(i);
      sa = (char *)sub_812F8A4(*a2, v2, 1, (int)a2);
    }
    else
    {
      sa = (char *)sub_812A5EA(i);
    }
    sub_812FDE2((int)ptr, sa, 0);
  }
  return ptr;
}

//----- (0812FD7E) --------------------------------------------------------
_BOOL4 __cdecl sub_812FD7E(int a1)
{
  return *(_DWORD *)(a1 + 16) && sub_812F318(*(_DWORD *)(a1 + 16));
}

//----- (0812FDB4) --------------------------------------------------------
int __cdecl sub_812FDB4(int a1)
{
  int v2; // [esp+4h] [ebp-4h]

  if ( *(_DWORD *)(a1 + 16) )
    v2 = sub_812A5EA(*(_DWORD *)(a1 + 16));
  else
    v2 = 0;
  return v2;
}

//----- (0812FDE2) --------------------------------------------------------
int __cdecl sub_812FDE2(int a1, char *s, int a3)
{
  _DWORD *v3; // ebx
  int result; // eax
  _DWORD *v5; // ebx
  int v6; // eax
  int v7; // eax
  int v8; // eax

  if ( a3 )
    s = (char *)sub_812F8A4(*(_DWORD *)a3, s, 1, a3);
  if ( *(_DWORD *)(a1 + 16) )
  {
    v5 = sub_8130F38(0x10u);
    sub_812FA6E(v5, (int)s);
    v6 = sub_8130F10(*(_DWORD *)(a1 + 16));
    sub_8130F02(v6, (int)v5);
    v7 = sub_8130F10(*(_DWORD *)(a1 + 16));
    v8 = sub_812F318(v7);
    result = sub_8130F1C(*(_DWORD *)(a1 + 16), v8);
  }
  else
  {
    v3 = sub_8130F38(0x10u);
    sub_812FA6E(v3, (int)s);
    *(_DWORD *)(a1 + 16) = v3;
    result = sub_8130F1C(*(_DWORD *)(a1 + 16), *(_DWORD *)(a1 + 16));
  }
  return result;
}

//----- (0812FEC2) --------------------------------------------------------
signed int __cdecl sub_812FEC2(int a1, char **a2, int *a3)
{
  char *s; // ST20_4
  char *s1; // [esp+24h] [ebp-4h]

  while ( 1 )
  {
    s1 = sub_812F560(a2, 1, 1);
    if ( !*s1 )
      return 0;
    if ( !strcasecmp(s1, &asc_8159580[2]) )
      break;
    s = (char *)sub_812F8A4(*a3, s1, 1, (int)a3);
    sub_812FDE2(a1, s, 0);
  }
  return 1;
}

//----- (0812FF62) --------------------------------------------------------
signed int __cdecl sub_812FF62(int a1, int *a2, int a3)
{
  char *v3; // eax
  char *v4; // eax
  int k; // [esp+20h] [ebp-8h]
  int i; // [esp+24h] [ebp-4h]
  int j; // [esp+24h] [ebp-4h]
  int l; // [esp+24h] [ebp-4h]
  int m; // [esp+24h] [ebp-4h]

  if ( *(_DWORD *)(a1 + 16) )
  {
    for ( i = 0; i < a3; ++i )
      sub_812F8A4(*a2, &asc_8159580[4], 0, (int)a2);
    sub_812FA9A(a1, (int)a2, *(char **)a1);
    if ( sub_812F318(*(_DWORD *)(a1 + 16)) )
    {
      sub_812F8A4(*a2, "\r\n", 0, (int)a2);
      for ( j = 0; j < a3; ++j )
        sub_812F8A4(*a2, &asc_8159580[4], 0, (int)a2);
      sub_812F8A4(*a2, "[\r\n", 0, (int)a2);
      for ( k = *(_DWORD *)(a1 + 16); k; k = sub_812F318(k) )
      {
        for ( l = 0; l < a3 + 1; ++l )
          sub_812F8A4(*a2, &asc_8159580[4], 0, (int)a2);
        v4 = (char *)sub_812A5EA(k);
        sub_812FA9A(*(_DWORD *)(a1 + 16), (int)a2, v4);
        sub_812F8A4(*a2, "\r\n", 0, (int)a2);
      }
      for ( m = 0; m < a3; ++m )
        sub_812F8A4(*a2, &asc_8159580[4], 0, (int)a2);
      sub_812F8A4(*a2, "]\r\n", 0, (int)a2);
    }
    else
    {
      sub_812F8A4(*a2, "\t\t", 0, (int)a2);
      v3 = (char *)sub_812A5EA(*(_DWORD *)(a1 + 16));
      sub_812FA9A(*(_DWORD *)(a1 + 16), (int)a2, v3);
      sub_812F8A4(*a2, "\r\n", 0, (int)a2);
    }
  }
  return 1;
}

//----- (0813025C) --------------------------------------------------------
int __cdecl sub_813025C(int a1, int a2, int a3)
{
  int result; // eax

  sub_812FA42((_DWORD *)a1, a2);
  *(_DWORD *)(a1 + 16) = 0;
  *(_DWORD *)(a1 + 20) = 0;
  *(_DWORD *)(a1 + 24) = 0;
  *(_DWORD *)(a1 + 28) = 0;
  *(_DWORD *)(a1 + 32) = 0;
  *(_DWORD *)(a1 + 36) = 0;
  *(_DWORD *)(a1 + 40) = a3;
  result = a1;
  *(_BYTE *)(a1 + 44) = 0;
  return result;
}

//----- (081302C2) --------------------------------------------------------
int __cdecl sub_81302C2(int a1)
{
  return sub_8130352(a1);
}

//----- (081302D6) --------------------------------------------------------
int __cdecl sub_81302D6(int a1)
{
  return sub_8130352(a1);
}

//----- (08130352) --------------------------------------------------------
int __cdecl sub_8130352(int a1)
{
  int result; // eax
  void *v2; // [esp+Ch] [ebp-Ch]
  void *ptr; // [esp+10h] [ebp-8h]

  while ( *(_DWORD *)(a1 + 16) )
  {
    *(_DWORD *)(a1 + 24) = sub_812F324(*(_DWORD *)(a1 + 16));
    ptr = *(void **)(a1 + 16);
    if ( ptr )
    {
      sub_812FC1C((int)ptr);
      sub_8130F4C(ptr);
    }
    *(_DWORD *)(a1 + 16) = *(_DWORD *)(a1 + 24);
  }
  while ( *(_DWORD *)(a1 + 28) )
  {
    *(_DWORD *)(a1 + 36) = sub_812A5F4(*(_DWORD *)(a1 + 28));
    v2 = *(void **)(a1 + 28);
    if ( v2 )
    {
      sub_81302D6((int)v2);
      sub_8130F4C(v2);
    }
    *(_DWORD *)(a1 + 28) = *(_DWORD *)(a1 + 36);
  }
  *(_DWORD *)(a1 + 24) = 0;
  *(_DWORD *)(a1 + 20) = 0;
  *(_DWORD *)(a1 + 16) = 0;
  *(_DWORD *)(a1 + 36) = 0;
  *(_DWORD *)(a1 + 32) = 0;
  *(_DWORD *)(a1 + 28) = 0;
  *(_DWORD *)(a1 + 40) = 0;
  result = a1;
  *(_BYTE *)(a1 + 44) = 0;
  return result;
}

//----- (08130452) --------------------------------------------------------
int *__cdecl sub_8130452(int a1, int *a2)
{
  int *v2; // ebx
  int v3; // ST28_4
  void *v4; // ST24_4
  char *v6; // [esp+1Ch] [ebp-1Ch]
  int j; // [esp+20h] [ebp-18h]
  int i; // [esp+2Ch] [ebp-Ch]

  if ( a2 )
    v6 = (char *)sub_812F8A4(*a2, *(char **)a1, 1, (int)a2);
  else
    v6 = *(char **)a1;
  v2 = (int *)sub_8130F38(0x30u);
  sub_813025C((int)v2, (int)v6, 0);
  for ( i = *(_DWORD *)(a1 + 28); i; i = sub_812A5F4(i) )
  {
    v3 = sub_8130452(i, a2);
    sub_81307D4(v2, v3);
  }
  for ( j = *(_DWORD *)(a1 + 16); j; j = sub_812F324(j) )
  {
    v4 = sub_812FC5A(j, a2);
    sub_8130726(v2, (int)v4);
  }
  return v2;
}

//----- (0813055A) --------------------------------------------------------
int __cdecl sub_813055A(int a1, int a2, int *a3, int *a4, int *a5)
{
  const char *v5; // ebx
  const char *v6; // eax
  int result; // eax
  int v8; // [esp+Ch] [ebp-Ch]
  int v9; // [esp+10h] [ebp-8h]

  if ( *a3 )
  {
    sub_8130F02(*a5, a2);
    v9 = *a4;
    v8 = 0;
    while ( v9 )
    {
      v5 = (const char *)sub_812A5EA(v9);
      v6 = (const char *)sub_812A5EA(a2);
      if ( strcasecmp(v6, v5) < 0 )
        break;
      v8 = v9;
      v9 = sub_8130F10(v9);
    }
    if ( v9 )
    {
      sub_8130F2A(v9, a2);
      sub_8130F1C(a2, v9);
    }
    if ( v8 )
    {
      sub_8130F1C(v8, a2);
      sub_8130F2A(a2, v8);
    }
    else
    {
      *a4 = a2;
    }
  }
  else
  {
    *a4 = a2;
    *a3 = a2;
  }
  result = a2;
  *a5 = a2;
  return result;
}

//----- (08130652) --------------------------------------------------------
void *__cdecl sub_8130652(int a1, char *s, char *a3, int a4)
{
  void *ptr; // ST20_4

  if ( a4 )
  {
    s = (char *)sub_812F8A4(*(_DWORD *)a4, s, 1, a4);
    if ( a3 )
      a3 = (char *)sub_812F8A4(*(_DWORD *)a4, a3, 1, a4);
  }
  ptr = sub_8130F38(0x14u);
  sub_812FB9A((int)ptr, (int)s, a3);
  sub_8130726((int *)a1, (int)ptr);
  return ptr;
}

//----- (08130726) --------------------------------------------------------
int __cdecl sub_8130726(int *a1, int a2)
{
  return sub_813055A((int)a1, a2, a1 + 4, a1 + 5, a1 + 6);
}

//----- (0813075E) --------------------------------------------------------
void *__cdecl sub_813075E(int a1, char *s, int a3)
{
  void *v3; // ebx

  if ( a3 )
    s = (char *)sub_812F8A4(*(_DWORD *)a3, s, 1, a3);
  v3 = sub_8130F38(0x30u);
  sub_813025C((int)v3, (int)s, 0);
  sub_81307D4((int *)a1, (int)v3);
  return v3;
}

//----- (081307D4) --------------------------------------------------------
int __cdecl sub_81307D4(int *a1, int a2)
{
  return sub_813055A((int)a1, a2, a1 + 7, a1 + 8, a1 + 9);
}

//----- (0813080C) --------------------------------------------------------
int __cdecl sub_813080C(int a1, char *s1)
{
  const char *v2; // eax
  int i; // [esp+14h] [ebp-4h]

  for ( i = *(_DWORD *)(a1 + 28); i; i = sub_812A5F4(i) )
  {
    v2 = (const char *)sub_812A5EA(i);
    if ( !strcasecmp(s1, v2) )
      return i;
  }
  return 0;
}

//----- (08130866) --------------------------------------------------------
signed int __cdecl sub_8130866(int a1, char **a2, int *a3)
{
  void *v3; // ST1C_4
  void *v4; // ST18_4
  char dest; // [esp+20h] [ebp-418h]
  char *s1; // [esp+42Ch] [ebp-Ch]

  while ( 1 )
  {
    s1 = sub_812F560(a2, 1, 0);
    if ( !*s1 )
      break;
    if ( !strcasecmp(s1, asc_8159594) )
      return 1;
    I_strncpyz(&dest, s1, 1024);
    s1 = sub_812F560(a2, 1, 1);
    if ( !strcasecmp(s1, &asc_8159594[2]) )
    {
      v3 = sub_813075E(a1, &dest, (int)a3);
      sub_8130F60((int)v3, *(_BYTE *)(a1 + 44));
      if ( !(unsigned __int8)sub_8130866(v3, a2, a3) )
        return 0;
    }
    else if ( !strcasecmp(s1, &asc_8159594[4]) )
    {
      v4 = sub_8130652(a1, &dest, 0, (int)a3);
      if ( !(unsigned __int8)sub_812FEC2((int)v4, a2, a3) )
        return 0;
    }
    else
    {
      sub_8130652(a1, &dest, s1, (int)a3);
    }
  }
  if ( *(_DWORD *)(a1 + 40) )
    return 0;
  return 1;
}

//----- (08130A3A) --------------------------------------------------------
signed int __cdecl sub_8130A3A(int a1, int *a2, int a3)
{
  int v4; // [esp+1Ch] [ebp-Ch]
  int v5; // [esp+20h] [ebp-8h]
  int i; // [esp+24h] [ebp-4h]
  int j; // [esp+24h] [ebp-4h]
  int k; // [esp+24h] [ebp-4h]

  v5 = *(_DWORD *)(a1 + 16);
  v4 = *(_DWORD *)(a1 + 28);
  if ( a3 >= 0 )
  {
    for ( i = 0; i < a3; ++i )
      sub_812F8A4(*a2, &asc_8159580[4], 0, (int)a2);
    sub_812FA9A(a1, (int)a2, *(char **)a1);
    sub_812F8A4(*a2, "\r\n", 0, (int)a2);
    for ( j = 0; j < a3; ++j )
      sub_812F8A4(*a2, &asc_8159580[4], 0, (int)a2);
    sub_812F8A4(*a2, "{\r\n", 0, (int)a2);
  }
  while ( v5 )
  {
    sub_812FF62(v5, a2, a3 + 1);
    v5 = sub_812F324(v5);
  }
  while ( v4 )
  {
    sub_8130A3A(v4, a2, a3 + 1);
    v4 = sub_812A5F4(v4);
  }
  if ( a3 >= 0 )
  {
    for ( k = 0; k < a3; ++k )
      sub_812F8A4(*a2, &asc_8159580[4], 0, (int)a2);
    sub_812F8A4(*a2, "}\r\n", 0, (int)a2);
  }
  return 1;
}

//----- (08130C0A) --------------------------------------------------------
int __cdecl sub_8130C0A(int a1, char *s2)
{
  const char *v2; // eax
  int i; // [esp+14h] [ebp-4h]

  for ( i = *(_DWORD *)(a1 + 16); i; i = sub_812F324(i) )
  {
    v2 = (const char *)sub_812A5EA(i);
    if ( !strcasecmp(v2, s2) )
      return i;
  }
  return 0;
}

//----- (08130C66) --------------------------------------------------------
int __cdecl sub_8130C66(int a1, char *s2, int a3)
{
  int v4; // [esp+10h] [ebp-8h]
  int v5; // [esp+14h] [ebp-4h]

  v5 = sub_8130C0A(a1, s2);
  if ( v5 )
    v4 = sub_812FDB4(v5);
  else
    v4 = a3;
  return v4;
}

//----- (08130CD6) --------------------------------------------------------
int __cdecl sub_8130CD6(int a1)
{
  int result; // eax

  sub_813025C(a1, (int)"Top Level", 0);
  *(_DWORD *)(a1 + 48) = 0;
  result = a1;
  *(_BYTE *)(a1 + 52) = 0;
  return result;
}

//----- (08130D0A) --------------------------------------------------------
int __cdecl sub_8130D0A(int a1)
{
  sub_8130E6E(a1);
  return sub_81302D6(a1);
}

//----- (08130D4E) --------------------------------------------------------
int __cdecl sub_8130D4E(int a1)
{
  sub_8130E6E(a1);
  return sub_81302D6(a1);
}

//----- (08130D92) --------------------------------------------------------
int __cdecl sub_8130D92(int a1, char **a2, char a3, unsigned __int8 a4)
{
  _DWORD *ptr; // ST28_4
  int v6; // [esp+30h] [ebp-8h]
  unsigned __int8 v7; // [esp+36h] [ebp-2h]
  char v8; // [esp+37h] [ebp-1h]

  v8 = a3;
  v7 = a4;
  if ( a3 )
    sub_8130E6E(a1);
  if ( !*(_DWORD *)(a1 + 48) )
  {
    ptr = sub_8130EDA(0x10u);
    sub_812F83A(ptr, 10240);
    *(_DWORD *)(a1 + 48) = ptr;
  }
  sub_8130F78(a1, v7);
  sub_8130F60(a1, v7);
  v6 = *(_DWORD *)(a1 + 48);
  return (unsigned __int8)sub_8130866(a1, a2, &v6);
}

//----- (08130E6E) --------------------------------------------------------
int __cdecl sub_8130E6E(int a1)
{
  int result; // eax

  sub_8130352(a1);
  sub_812F9F8(*(void ***)(a1 + 48));
  result = a1;
  *(_DWORD *)(a1 + 48) = 0;
  return result;
}

//----- (08130E9A) --------------------------------------------------------
int sub_8130E9A(int a1, ...)
{
  va_list va; // [esp+24h] [ebp+Ch]

  va_start(va, a1);
  return (unsigned __int8)sub_8130A3A(a1, (int *)va, -1);
}

//----- (08130EC0) --------------------------------------------------------
int __cdecl sub_8130EC0(int a1)
{
  return *(_DWORD *)(a1 + 4);
}

//----- (08130ECC) --------------------------------------------------------
int __cdecl sub_8130ECC(int a1, int a2)
{
  int result; // eax

  result = a2;
  *(_DWORD *)(a1 + 4) = a2;
  return result;
}

//----- (08130EDA) --------------------------------------------------------
void *__cdecl sub_8130EDA(size_t size)
{
  return Z_MallocInternal(size);
}

//----- (08130EEE) --------------------------------------------------------
void __cdecl sub_8130EEE(void *ptr)
{
  Z_FreeInternal(ptr);
}

//----- (08130F02) --------------------------------------------------------
int __cdecl sub_8130F02(int a1, int a2)
{
  int result; // eax

  result = a2;
  *(_DWORD *)(a1 + 4) = a2;
  return result;
}

//----- (08130F10) --------------------------------------------------------
int __cdecl sub_8130F10(int a1)
{
  return *(_DWORD *)(a1 + 8);
}

//----- (08130F1C) --------------------------------------------------------
int __cdecl sub_8130F1C(int a1, int a2)
{
  int result; // eax

  result = a2;
  *(_DWORD *)(a1 + 8) = a2;
  return result;
}

//----- (08130F2A) --------------------------------------------------------
int __cdecl sub_8130F2A(int a1, int a2)
{
  int result; // eax

  result = a2;
  *(_DWORD *)(a1 + 12) = a2;
  return result;
}

//----- (08130F38) --------------------------------------------------------
void *__cdecl sub_8130F38(size_t size)
{
  return Z_MallocInternal(size);
}

//----- (08130F4C) --------------------------------------------------------
void __cdecl sub_8130F4C(void *ptr)
{
  Z_FreeInternal(ptr);
}

//----- (08130F60) --------------------------------------------------------
int __cdecl sub_8130F60(int a1, unsigned __int8 a2)
{
  int result; // eax

  result = a2;
  *(_BYTE *)(a1 + 44) = a2;
  return result;
}

//----- (08130F78) --------------------------------------------------------
int __cdecl sub_8130F78(int a1, unsigned __int8 a2)
{
  int result; // eax

  result = a2;
  *(_BYTE *)(a1 + 52) = a2;
  return result;
}

//----- (08130F90) --------------------------------------------------------
size_t __cdecl sub_8130F90(float *a1)
{
  float v1; // ST10_4
  signed int i; // [esp+14h] [ebp-4h]

  for ( i = 0; i < (signed int)dword_89A9D80; ++i )
  {
    v1 = sub_80A1DB2(a1, (float *)off_8168614 + 4 * i);
    if ( v1 < 131072.0 )
    {
      ++*((_DWORD *)off_8168614 + 4 * i + 3);
      return i;
    }
  }
  sub_8134DC8(a1, (_DWORD *)off_8168614 + 4 * dword_89A9D80);
  *((_DWORD *)off_8168614 + 4 * dword_89A9D80++ + 3) = 1;
  return dword_89A9D80 - 1;
}
// 8168614: using guessed type void *off_8168614;

//----- (08131042) --------------------------------------------------------
void *__cdecl sub_8131042(void *a1)
{
  void *result; // eax
  int v2; // esi
  char *v3; // ebx
  size_t v4; // ecx
  char *v5; // edx
  int i; // [esp+0h] [ebp-Ch]
  int j; // [esp+0h] [ebp-Ch]

  --*((_DWORD *)off_8168614 + 4 * (_DWORD)a1 + 3);
  result = off_8168614;
  if ( *((_DWORD *)off_8168614 + 4 * (_DWORD)a1 + 3) <= 0 )
  {
    --dword_89A9D80;
    result = a1;
    if ( a1 != (void *)dword_89A9D80 )
    {
      v2 = 16 * (_DWORD)a1;
      v3 = (char *)off_8168614;
      v4 = 16 * dword_89A9D80;
      v5 = (char *)off_8168614;
      *(_DWORD *)((char *)off_8168614 + v2) = *((_DWORD *)off_8168614 + 4 * dword_89A9D80);
      *(_DWORD *)&v3[v2 + 4] = *(_DWORD *)&v5[v4 + 4];
      *(_DWORD *)&v3[v2 + 8] = *(_DWORD *)&v5[v4 + 8];
      *(_DWORD *)&v3[v2 + 12] = *(_DWORD *)&v5[v4 + 12];
      for ( i = 0; i < dword_89B63A0; ++i )
      {
        if ( *(_DWORD *)(*((_DWORD *)off_8168618 + i) + 172) == dword_89A9D80 )
          *(_DWORD *)(*((_DWORD *)off_8168618 + i) + 172) = a1;
      }
      for ( j = 0; ; ++j )
      {
        result = (void *)j;
        if ( j >= dword_89B63A4 )
          break;
        if ( *(_DWORD *)(*((_DWORD *)off_816861C + j) + 172) == dword_89A9D80 )
          *(_DWORD *)(*((_DWORD *)off_816861C + j) + 172) = a1;
      }
    }
  }
  return result;
}
// 8168614: using guessed type void *off_8168614;
// 8168618: using guessed type void *off_8168618;
// 816861C: using guessed type void *off_816861C;
// 89B63A0: using guessed type int dword_89B63A0;
// 89B63A4: using guessed type int dword_89B63A4;

//----- (08131180) --------------------------------------------------------
int sub_8131180()
{
  int result; // eax
  int i; // [esp+4h] [ebp-4h]
  int j; // [esp+4h] [ebp-4h]

  for ( i = 0; i < dword_89B63A0; ++i )
  {
    if ( *((_DWORD *)off_8168618 + i) )
      (*(void (__cdecl **)(_DWORD))(**((_DWORD **)off_8168618 + i) + 4))(*((_DWORD *)off_8168618 + i));
  }
  for ( j = 0; ; ++j )
  {
    result = j;
    if ( j >= dword_89B63A4 )
      break;
    if ( *((_DWORD *)off_816861C + j) )
      (*(void (__cdecl **)(_DWORD))(**((_DWORD **)off_816861C + j) + 4))(*((_DWORD *)off_816861C + j));
  }
  dword_89B63A0 = 0;
  dword_89B63A4 = 0;
  *(_DWORD *)dword_89B63A8 = 0;
  dword_89B63CC = 0;
  dword_89A9D80 = 0;
  return result;
}
// 8168618: using guessed type void *off_8168618;
// 816861C: using guessed type void *off_816861C;
// 89B63A0: using guessed type int dword_89B63A0;
// 89B63A4: using guessed type int dword_89B63A4;
// 89B63CC: using guessed type int dword_89B63CC;

//----- (0813127A) --------------------------------------------------------
int __cdecl sub_813127A(char a1)
{
  int result; // eax

  result = sub_8131180();
  if ( dword_89A2814 )
  {
    result = sub_81287EA((int)dword_89A2814, a1, 0);
    if ( a1 )
    {
      sub_81355DC(dword_89A2814);
      dword_89A2814 = 0;
      result = sub_806C8C0();
      dword_89A280C[result] = 0;
    }
  }
  return result;
}

//----- (081312E4) --------------------------------------------------------
int sub_81312E4()
{
  sub_8131180();
  return sub_81287EA((int)dword_89A2814, 0, 0);
}

//----- (0813130E) --------------------------------------------------------
int sub_813130E()
{
  printf("FX_GetBoneOrientation called!\n");
  return 0;
}

//----- (08131328) --------------------------------------------------------
void sub_8131328()
{
  dword_89AD6A0 = 0;
}
// 89AD6A0: using guessed type int dword_89AD6A0;

//----- (08131338) --------------------------------------------------------
signed int __cdecl sub_8131338(char a1)
{
  void *ptr; // ST20_4

  if ( !dword_89B64DC[sub_806C8C0()] )
  {
    dword_89B64DC[sub_806C8C0()] = 1;
    dword_89B63A0 = 0;
    dword_89B63A4 = 0;
    *(_DWORD *)dword_89B63A8 = 0;
    dword_89B63CC = 0;
    dword_89A9D80 = 0;
  }
  sub_813127A(1);
  byte_8168610 = a1;
  ptr = sub_81355C8();
  sub_81287D0((int)ptr);
  dword_89A2814 = ptr;
  sub_8129736();
  dword_89A280C[sub_806C8C0()] = (int)dword_89A2814;
  sub_812A670((_DWORD *)off_8168620);
  return 1;
}
// 8168610: using guessed type char byte_8168610;
// 89B63A0: using guessed type int dword_89B63A0;
// 89B63A4: using guessed type int dword_89B63A4;
// 89B63CC: using guessed type int dword_89B63CC;
// 89B64DC: using guessed type int dword_89B64DC[];

//----- (0813142A) --------------------------------------------------------
int __cdecl sub_813142A(_DWORD *a1, char a2)
{
  int result; // eax

  if ( a2 )
    (*(void (__cdecl **)(_DWORD *))(*a1 + 8))(a1);
  result = a1[42] & 0x1000;
  if ( result )
    --dword_89B63CC;
  return result;
}
// 89B63CC: using guessed type int dword_89B63CC;

//----- (08131468) --------------------------------------------------------
int __cdecl sub_8131468(int a1, char a2)
{
  _DWORD *v2; // ST10_4

  v2 = (_DWORD *)*((_DWORD *)off_8168618 + a1);
  sub_8134F7E(a1, --dword_89B63AC);
  return sub_813142A(v2, a2);
}
// 8168618: using guessed type void *off_8168618;
// 89B63AC: using guessed type int dword_89B63AC;

//----- (081314B8) --------------------------------------------------------
int __cdecl sub_81314B8(int a1, char a2)
{
  _DWORD *v2; // ST10_4

  v2 = (_DWORD *)*((_DWORD *)off_816861C + a1);
  sub_8134FDC(a1, --dword_89B63B0);
  return sub_813142A(v2, a2);
}
// 816861C: using guessed type void *off_816861C;
// 89B63B0: using guessed type int dword_89B63B0;

//----- (08131508) --------------------------------------------------------
void sub_8131508()
{
  ;
}

//----- (0813150E) --------------------------------------------------------
char *sub_813150E()
{
  if ( ++*(_DWORD *)dword_89B63A8 <= 1800 )
    return (char *)off_8168618 + 4 * ++dword_89B63A0 - 4;
  --*(_DWORD *)dword_89B63A8;
  return 0;
}
// 8168618: using guessed type void *off_8168618;
// 89B63A0: using guessed type int dword_89B63A0;

//----- (0813155A) --------------------------------------------------------
char *sub_813155A()
{
  if ( ++*(_DWORD *)dword_89B63A8 <= 1800 )
    return (char *)off_816861C + 4 * ++dword_89B63A4 - 4;
  --*(_DWORD *)dword_89B63A8;
  return 0;
}
// 816861C: using guessed type void *off_816861C;
// 89B63A4: using guessed type int dword_89B63A4;

//----- (081315A6) --------------------------------------------------------
long double __cdecl sub_81315A6(float *a1, float *a2)
{
  long double v2; // fst7
  float v4; // [esp+10h] [ebp-38h]
  float v5; // [esp+14h] [ebp-34h]
  float v6; // [esp+18h] [ebp-30h]
  float v7; // [esp+1Ch] [ebp-2Ch]
  float v8[6]; // [esp+20h] [ebp-28h]
  int i; // [esp+38h] [ebp-10h]
  _DWORD *v10; // [esp+3Ch] [ebp-Ch]

  if ( dword_89B63CC )
  {
    sub_8134E3C(a2, a1, v8);
    v7 = sub_80A20C0(v8);
    if ( *(float *)(dword_89A2CA0 + 8) <= (long double)v7 )
    {
      v2 = v7 * 0.5;
      v6 = v2;
      v5 = 1.0;
      for ( i = 0; i < dword_89B63A4; ++i )
      {
        v10 = (_DWORD *)*((_DWORD *)off_816861C + i);
        if ( v10[42] & 0x1000 )
        {
          (*(void (__cdecl **)(_DWORD *, float *, float *, float))(*v10 + 24))(v10, a1, v8, COERCE_FLOAT(LODWORD(v6)));
          v2 = v2 * v5;
          v5 = v2;
        }
      }
      for ( i = 0; i < dword_89B63A0; ++i )
      {
        v10 = (_DWORD *)*((_DWORD *)off_8168618 + i);
        if ( v10[42] & 0x1000 )
        {
          (*(void (__cdecl **)(_DWORD *, float *, float *, float))(*v10 + 24))(v10, a1, v8, COERCE_FLOAT(LODWORD(v6)));
          v2 = v2 * v5;
          v5 = v2;
        }
      }
      v4 = v5;
    }
    else
    {
      v4 = 1.0;
    }
  }
  else
  {
    v4 = 1.0;
  }
  return v4;
}
// 8168618: using guessed type void *off_8168618;
// 816861C: using guessed type void *off_816861C;
// 89A2CA0: using guessed type int dword_89A2CA0;
// 89B63A0: using guessed type int dword_89B63A0;
// 89B63A4: using guessed type int dword_89B63A4;
// 89B63CC: using guessed type int dword_89B63CC;

//----- (08131708) --------------------------------------------------------
int sub_8131708()
{
  int result; // eax
  int i; // [esp+10h] [ebp-8h]
  int j; // [esp+10h] [ebp-8h]
  _DWORD *v3; // [esp+14h] [ebp-4h]
  _DWORD *v4; // [esp+14h] [ebp-4h]

  dword_89AD6A0 = 0;
  if ( dword_89B63CC )
  {
    for ( i = 0; i < dword_89B63A4; ++i )
    {
      v3 = (_DWORD *)*((_DWORD *)off_816861C + i);
      if ( v3[42] & 0x1000 )
        (*(void (__cdecl **)(_DWORD *))(*v3 + 28))(v3);
    }
    for ( j = 0; ; ++j )
    {
      result = j;
      if ( j >= dword_89B63A0 )
        break;
      v4 = (_DWORD *)*((_DWORD *)off_8168618 + j);
      if ( v4[42] & 0x1000 )
        (*(void (__cdecl **)(_DWORD *))(*v4 + 28))(v4);
    }
  }
  return result;
}
// 8168618: using guessed type void *off_8168618;
// 816861C: using guessed type void *off_816861C;
// 89AD6A0: using guessed type int dword_89AD6A0;
// 89B63A0: using guessed type int dword_89B63A0;
// 89B63A4: using guessed type int dword_89B63A4;
// 89B63CC: using guessed type int dword_89B63CC;

//----- (081317D0) --------------------------------------------------------
long double __cdecl sub_81317D0(float *a1, float *a2)
{
  float v2; // ST00_4
  long double v3; // fst7
  float v4; // ST18_4
  float v6; // [esp+14h] [ebp-64h]
  float v7; // [esp+1Ch] [ebp-5Ch]
  int v8; // [esp+20h] [ebp-58h]
  char v9; // [esp+30h] [ebp-48h]
  float *v10; // [esp+40h] [ebp-38h]
  float v11; // [esp+44h] [ebp-34h]
  float v12; // [esp+48h] [ebp-30h]
  float v13; // [esp+4Ch] [ebp-2Ch]
  int v14; // [esp+50h] [ebp-28h]
  int i; // [esp+6Ch] [ebp-Ch]

  if ( dword_89AD6A0 )
  {
    sub_8134E3C(a2, a1, (float *)&v14);
    v13 = sub_80A20C0((float *)&v14);
    if ( *(float *)(dword_89A2CA0 + 8) <= (long double)v13 )
    {
      v12 = v13 * 0.5;
      v11 = 1.0;
      for ( i = 0; i < dword_89AD6A0; ++i )
      {
        v10 = (float *)((char *)&unk_89AD700 + 20 * i);
        sub_8134E3C(v10, a1, (float *)&v9);
        v7 = sub_8134F0C((float *)&v9, (float *)&v14);
        v2 = v7 - v12;
        v3 = sub_8134D5C(v2);
        if ( v3 <= v12 )
        {
          sub_8134EB8((int)a1, v7, (int)&v14, (int)&v8);
          v4 = sub_80A1DB2(v10, (float *)&v8);
          if ( v4 < (long double)v10[3] )
            v11 = v11 * v10[4];
        }
      }
      v6 = v11;
    }
    else
    {
      v6 = 1.0;
    }
  }
  else
  {
    v6 = 1.0;
  }
  return v6;
}
// 89A2CA0: using guessed type int dword_89A2CA0;
// 89AD6A0: using guessed type int dword_89AD6A0;

//----- (08131926) --------------------------------------------------------
int sub_8131926()
{
  int result; // eax
  int v1; // [esp+Ch] [ebp-Ch]
  void **v2; // [esp+10h] [ebp-8h]

  v1 = dword_89B63AC;
  while ( 1 )
  {
    result = v1;
    if ( v1 >= dword_89B63B4 )
      break;
    v2 = (void **)*((_DWORD *)off_8168618 + v1);
    sub_8131042(v2[43]);
    if ( v2 )
      (*((void (__cdecl **)(void **))*v2 + 1))(v2);
    *((_DWORD *)off_8168618 + v1++) = *((_DWORD *)off_8168618 + --dword_89B63A0);
    --*(_DWORD *)dword_89B63A8;
  }
  return result;
}
// 8168618: using guessed type void *off_8168618;
// 89B63A0: using guessed type int dword_89B63A0;
// 89B63AC: using guessed type int dword_89B63AC;
// 89B63B4: using guessed type int dword_89B63B4;

//----- (081319C4) --------------------------------------------------------
int sub_81319C4()
{
  int result; // eax
  int v1; // [esp+Ch] [ebp-Ch]
  void **v2; // [esp+10h] [ebp-8h]

  v1 = dword_89B63B0;
  while ( 1 )
  {
    result = v1;
    if ( v1 >= dword_89B63B8 )
      break;
    v2 = (void **)*((_DWORD *)off_816861C + v1);
    sub_8131042(v2[43]);
    if ( v2 )
      (*((void (__cdecl **)(void **))*v2 + 1))(v2);
    *((_DWORD *)off_816861C + v1++) = *((_DWORD *)off_816861C + --dword_89B63A4);
    --*(_DWORD *)dword_89B63A8;
  }
  return result;
}
// 816861C: using guessed type void *off_816861C;
// 89B63A4: using guessed type int dword_89B63A4;
// 89B63B0: using guessed type int dword_89B63B0;
// 89B63B8: using guessed type int dword_89B63B8;

//----- (08131A62) --------------------------------------------------------
int __cdecl sub_8131A62(int a1)
{
  int v2; // [esp+14h] [ebp-4h]
  int v3; // [esp+14h] [ebp-4h]

  dword_89B63AC = dword_89B63A0;
  dword_89B63B4 = dword_89B63A0;
  v2 = 0;
  while ( v2 < dword_89B63AC )
  {
    if ( sub_81351DE(*((_DWORD *)off_8168618 + v2)) <= a1 )
      ++v2;
    else
      sub_8131468(v2, 0);
  }
  sub_8131926();
  dword_89B63B0 = dword_89B63A4;
  dword_89B63B8 = dword_89B63A4;
  v3 = 0;
  while ( v3 < dword_89B63B0 )
  {
    if ( sub_81351DE(*((_DWORD *)off_816861C + v3)) <= a1 )
      ++v3;
    else
      sub_81314B8(v3, 0);
  }
  sub_81319C4();
  return sub_81287EA((int)dword_89A2814, 0, 0);
}
// 8168618: using guessed type void *off_8168618;
// 816861C: using guessed type void *off_816861C;
// 89B63A0: using guessed type int dword_89B63A0;
// 89B63A4: using guessed type int dword_89B63A4;
// 89B63AC: using guessed type int dword_89B63AC;
// 89B63B0: using guessed type int dword_89B63B0;
// 89B63B4: using guessed type int dword_89B63B4;
// 89B63B8: using guessed type int dword_89B63B8;

//----- (08131B58) --------------------------------------------------------
int __cdecl sub_8131B58(_DWORD *a1, int *a2)
{
  char v2; // al

  v2 = (*(int (__cdecl **)(_DWORD *))(*a1 + 36))(a1);
  sub_8121152(a2, v2);
  sub_8127A7C(a2, a1[47]);
  return (*(int (__cdecl **)(_DWORD *, int *))(*a1 + 40))(a1, a2);
}

//----- (08131BB6) --------------------------------------------------------
int __cdecl sub_8131BB6(int a1)
{
  int i; // [esp+1Ch] [ebp-2Ch]
  int j; // [esp+1Ch] [ebp-2Ch]
  char v4; // [esp+20h] [ebp-28h]

  sub_8120708((int)&v4);
  sub_8120794((int)&v4, a1);
  sub_812ADDE(off_8168620, (int)&v4);
  sub_8129558((int)dword_89A2814, (int *)&v4);
  for ( i = 0; i < dword_89B63A0; ++i )
    sub_8131B58(*((_DWORD **)off_8168618 + i), (int *)&v4);
  for ( j = 0; j < dword_89B63A4; ++j )
    sub_8131B58(*((_DWORD **)off_816861C + j), (int *)&v4);
  sub_8121152((int *)&v4, 0);
  return sub_81355BA((int)&v4);
}
// 8168618: using guessed type void *off_8168618;
// 816861C: using guessed type void *off_816861C;
// 89B63A0: using guessed type int dword_89B63A0;
// 89B63A4: using guessed type int dword_89B63A4;

//----- (08131CA6) --------------------------------------------------------
int __cdecl sub_8131CA6(int a1, int a2)
{
  int v3; // [esp+0h] [ebp-8h]

  if ( a2 < *(_DWORD *)(a1 + 4) )
    v3 = *(_DWORD *)(a1 + 4 * a2 + 8);
  else
    v3 = 0;
  return v3;
}

//----- (08131CD8) --------------------------------------------------------
int __cdecl sub_8131CD8(int a1)
{
  unsigned __int8 v1; // al
  _DWORD *v2; // ST88_4
  _DWORD *v3; // ST78_4
  _DWORD *v4; // ST6C_4
  _DWORD *v5; // ST60_4
  _DWORD *v6; // ST54_4
  _DWORD *v7; // ST48_4
  _DWORD *v8; // ST3C_4
  _DWORD *v9; // ST30_4
  _DWORD *v10; // ST24_4
  int v11; // ebx
  int v12; // eax
  int v14; // [esp+8Ch] [ebp-3Ch]
  int v15[8]; // [esp+90h] [ebp-38h]
  _DWORD *v16; // [esp+B0h] [ebp-18h]
  int v17; // [esp+B4h] [ebp-14h]
  int v18; // [esp+B8h] [ebp-10h]
  int i; // [esp+BCh] [ebp-Ch]

  sub_8120708((int)v15);
  sub_813127A(0);
  sub_812074C((int)v15, a1);
  sub_812ADDE(off_8168620, (int)v15);
  sub_8129558((int)dword_89A2814, v15);
  for ( i = 0; ; ++i )
  {
    v1 = sub_8121100(v15);
    v18 = v1;
    if ( !v1 )
      break;
    v17 = sub_8127A56(v15);
    switch ( v18 )
    {
      case 0:
      case 6:
      case 8:
      case 10:
        continue;
      case 1:
        v2 = sub_813537E(588);
        sub_81227F0(v2);
        v16 = v2;
        break;
      case 2:
        v3 = sub_81353D6(600);
        sub_812528A(v3);
        v16 = v3;
        break;
      case 3:
        v4 = sub_813544E(632);
        sub_812550A(v4);
        v16 = v4;
        break;
      case 4:
        v5 = sub_8135488(632);
        sub_8125A04(v5);
        v16 = v5;
        break;
      case 5:
        v6 = sub_813559E(668);
        sub_8125CB8(v6);
        v16 = v6;
        break;
      case 7:
        v7 = sub_8135412(600);
        sub_81249E6(v7);
        v16 = v7;
        break;
      case 9:
        v8 = sub_8135228(252);
        sub_812679A(v8);
        v16 = v8;
        break;
      case 11:
        v9 = sub_8135228(252);
        sub_8135244(v9);
        v16 = v9;
        break;
      case 12:
        v10 = sub_813539A(636);
        sub_8124CB6(v10);
        v16 = v10;
        break;
    }
    (*(void (__cdecl **)(_DWORD *, int *))(*v16 + 40))(v16, v15);
    v11 = sub_81351F8((int)v16);
    v12 = sub_81351EC((int)v16);
    v14 = sub_8131CA6(v12, v11);
    if ( v14 )
    {
      (*(void (__cdecl **)(_DWORD *, int))(*v16 + 44))(v16, v14);
      if ( v16[42] & 0x1000 )
        ++dword_89B63CC;
      if ( (unsigned __int8)sub_812782E(v16 + 48) )
        *((_DWORD *)off_8168618 + dword_89B63A0++) = v16;
      else
        *((_DWORD *)off_816861C + dword_89B63A4++) = v16;
      ++*(_DWORD *)dword_89B63A8;
    }
    else if ( v16 )
    {
      (*(void (__cdecl **)(_DWORD *))(*v16 + 4))(v16);
    }
  }
  return sub_81355BA((int)v15);
}
// 8168618: using guessed type void *off_8168618;
// 816861C: using guessed type void *off_816861C;
// 89B63A0: using guessed type int dword_89B63A0;
// 89B63A4: using guessed type int dword_89B63A4;
// 89B63CC: using guessed type int dword_89B63CC;

//----- (081321D6) --------------------------------------------------------
int __cdecl sub_81321D6(const void *a1, const void *a2)
{
  int v2; // edx
  int v3; // ecx
  int v4; // edx
  int v5; // edx
  signed int v7; // [esp+4h] [ebp-24h]
  int v9; // [esp+10h] [ebp-18h]
  int v10; // [esp+14h] [ebp-14h]

  v9 = *(_DWORD *)a1;
  v10 = *(_DWORD *)a2;
  v2 = *(_DWORD *)(*(_DWORD *)a2 + 176);
  if ( *(_DWORD *)(*(_DWORD *)a1 + 176) != v2 )
    return *(_DWORD *)(*(_DWORD *)a1 + 176) - v2;
  v3 = 4 * *(_DWORD *)(v9 + 172);
  v4 = *(_DWORD *)(dword_89A9D88 + 4 * *(_DWORD *)(v10 + 172));
  if ( *(_DWORD *)(dword_89A9D88 + v3) != v4 )
    return *(_DWORD *)(dword_89A9D88 + v3) - v4;
  v5 = *(_DWORD *)(v10 + 64);
  if ( *(_DWORD *)(v9 + 64) != v5 )
    return *(_DWORD *)(v9 + 64) - v5;
  if ( *((float *)a2 + 1) <= (long double)*((float *)a1 + 1) )
    v7 = -1;
  else
    v7 = 1;
  return v7;
}
// 89A9D88: using guessed type int dword_89A9D88;

//----- (081322B8) --------------------------------------------------------
int __cdecl sub_81322B8(const void *a1, const void *a2)
{
  signed int v3; // [esp+4h] [ebp-Ch]

  if ( *((float *)a2 + 1) <= (long double)*((float *)a1 + 1) )
    v3 = -1;
  else
    v3 = 1;
  return v3;
}

//----- (081322F4) --------------------------------------------------------
void __cdecl sub_81322F4(void *a1, size_t nmemb)
{
  int v2; // ebx
  int v3[1800]; // [esp+10h] [ebp-5478h]
  int base; // [esp+1C30h] [ebp-3858h]
  float v5[3602]; // [esp+1C34h] [ebp-3854h]
  int i; // [esp+547Ch] [ebp-Ch]

  for ( i = 0; i < (signed int)dword_89A9D80; ++i )
  {
    *(&base + 2 * i) = i;
    v2 = i;
    v5[2 * v2] = sub_80A1DB2((float *)off_8168614 + 4 * i, (float *)(off_8168620 + 20));
  }
  qsort(&base, dword_89A9D80, 8u, sub_81322B8);
  for ( i = 0; i < (signed int)dword_89A9D80; ++i )
    v3[*(&base + 2 * i)] = i;
  dword_89A9D88 = (int)v3;
  qsort(a1, nmemb, 8u, sub_81321D6);
  dword_89A9D88 = 0;
}
// 8168614: using guessed type void *off_8168614;
// 89A9D88: using guessed type int dword_89A9D88;
// 81322F4: using guessed type float var_3854[3602];
// 81322F4: using guessed type int var_5478[1800];

//----- (081323E6) --------------------------------------------------------
int sub_81323E6()
{
  _DWORD *v1; // [esp+10h] [ebp-8h]
  int v2; // [esp+14h] [ebp-4h]

  dword_89B63AC = dword_89B63A0;
  dword_89B63B4 = dword_89B63A0;
  v2 = 0;
  while ( v2 < dword_89B63AC )
  {
    v1 = (_DWORD *)*((_DWORD *)off_8168618 + v2);
    if ( *(_DWORD *)(off_8168620 + 4) <= v1[47] )
    {
      if ( (*(unsigned __int8 (__cdecl **)(_DWORD *))(*v1 + 12))(v1) )
        ++v2;
      else
        sub_8131468(v2, 1);
    }
    else
    {
      sub_81350CE((int)v1, 1024);
      sub_8131468(v2, 1);
    }
  }
  return sub_8131926();
}
// 8168618: using guessed type void *off_8168618;
// 89B63A0: using guessed type int dword_89B63A0;
// 89B63AC: using guessed type int dword_89B63AC;
// 89B63B4: using guessed type int dword_89B63B4;

//----- (081324A6) --------------------------------------------------------
int sub_81324A6()
{
  _DWORD *v1; // [esp+10h] [ebp-8h]
  int v2; // [esp+14h] [ebp-4h]

  dword_89B63B0 = dword_89B63A4;
  dword_89B63B8 = dword_89B63A4;
  v2 = 0;
  while ( v2 < dword_89B63B0 )
  {
    v1 = (_DWORD *)*((_DWORD *)off_816861C + v2);
    if ( *(_DWORD *)(off_8168620 + 4) <= v1[47] )
    {
      if ( (*(unsigned __int8 (__cdecl **)(_DWORD *))(*v1 + 12))(v1) )
        ++v2;
      else
        sub_81314B8(v2, 1);
    }
    else
    {
      sub_81350CE((int)v1, 1024);
      sub_81314B8(v2, 1);
    }
  }
  return sub_81319C4();
}
// 816861C: using guessed type void *off_816861C;
// 89B63A4: using guessed type int dword_89B63A4;
// 89B63B0: using guessed type int dword_89B63B0;
// 89B63B8: using guessed type int dword_89B63B8;

//----- (08132566) --------------------------------------------------------
int __cdecl sub_8132566(int a1)
{
  int result; // eax
  int v2; // [esp+Ch] [ebp-Ch]
  _DWORD *v3; // [esp+14h] [ebp-4h]

  dword_89B63B4 = dword_89B63AC;
  v2 = a1;
  while ( 1 )
  {
    result = v2;
    if ( v2 >= dword_89B63AC )
      break;
    v3 = (_DWORD *)*((_DWORD *)off_8168618 + v2);
    if ( *(_DWORD *)(off_8168620 + 4) <= v3[47] )
    {
      if ( (*(unsigned __int8 (__cdecl **)(_DWORD *))(*v3 + 12))(v3) )
        ++v2;
      else
        sub_8131468(v2, 1);
    }
    else
    {
      sub_81350CE((int)v3, 1024);
      sub_8131468(v2, 1);
    }
  }
  return result;
}
// 8168618: using guessed type void *off_8168618;
// 89B63AC: using guessed type int dword_89B63AC;
// 89B63B4: using guessed type int dword_89B63B4;

//----- (0813261C) --------------------------------------------------------
int sub_813261C()
{
  int v0; // ebx
  int result; // eax
  int i; // [esp+Ch] [ebp-Ch]
  float *v3; // [esp+10h] [ebp-8h]

  for ( i = dword_89B63C4; i < dword_89B63AC; ++i )
  {
    v3 = (float *)*((_DWORD *)off_8168618 + i);
    if ( !*(_BYTE *)(dword_89A2C88 + 8) || !(*(unsigned __int8 (__cdecl **)(float *))(*(_DWORD *)v3 + 16))(v3) )
    {
      dword_89B9D40[2 * dword_89BD580] = (int)v3;
      v0 = dword_89BD580;
      flt_89B9D44[2 * v0] = sub_80A1DB2(v3 + 31, (float *)(off_8168620 + 20));
      ++dword_89BD580;
    }
  }
  result = dword_89B63AC;
  dword_89B63C4 = dword_89B63AC;
  return result;
}
// 8168618: using guessed type void *off_8168618;
// 89A2C88: using guessed type int dword_89A2C88;
// 89B63AC: using guessed type int dword_89B63AC;
// 89B63C4: using guessed type int dword_89B63C4;
// 89B9D40: using guessed type int dword_89B9D40[];
// 89BD580: using guessed type int dword_89BD580;

//----- (081326C8) --------------------------------------------------------
int __cdecl sub_81326C8(int a1)
{
  int result; // eax
  int v2; // [esp+Ch] [ebp-Ch]
  _DWORD *v3; // [esp+14h] [ebp-4h]

  dword_89B63B8 = dword_89B63B0;
  v2 = a1;
  while ( 1 )
  {
    result = v2;
    if ( v2 >= dword_89B63B0 )
      break;
    v3 = (_DWORD *)*((_DWORD *)off_816861C + v2);
    if ( *(_DWORD *)(off_8168620 + 4) <= v3[47] )
    {
      if ( (*(unsigned __int8 (__cdecl **)(_DWORD *))(*v3 + 12))(v3) )
        ++v2;
      else
        sub_81314B8(v2, 1);
    }
    else
    {
      sub_81350CE((int)v3, 1024);
      sub_81314B8(v2, 1);
    }
  }
  return result;
}
// 816861C: using guessed type void *off_816861C;
// 89B63B0: using guessed type int dword_89B63B0;
// 89B63B8: using guessed type int dword_89B63B8;

//----- (0813277E) --------------------------------------------------------
int sub_813277E()
{
  int result; // eax
  size_t v1; // ebx
  int i; // [esp+Ch] [ebp-Ch]
  float *v3; // [esp+10h] [ebp-8h]

  result = dword_89A2828;
  if ( dword_89A2828 )
  {
    for ( i = dword_89B63C8; i < dword_89B63B0; ++i )
    {
      v3 = (float *)*((_DWORD *)off_816861C + i);
      if ( !*(_BYTE *)(dword_89A2C88 + 8) || !(*(unsigned __int8 (__cdecl **)(float *))(*(_DWORD *)v3 + 16))(v3) )
      {
        dword_89B64E0[2 * dword_89B9D20] = (int)v3;
        v1 = dword_89B9D20;
        flt_89B64E4[2 * v1] = sub_80A1DB2(v3 + 31, (float *)(off_8168620 + 20));
        ++dword_89B9D20;
      }
    }
    result = dword_89B63B0;
    dword_89B63C8 = dword_89B63B0;
  }
  return result;
}
// 816861C: using guessed type void *off_816861C;
// 89A2828: using guessed type int dword_89A2828;
// 89A2C88: using guessed type int dword_89A2C88;
// 89B63B0: using guessed type int dword_89B63B0;
// 89B63C8: using guessed type int dword_89B63C8;
// 89B64E0: using guessed type int dword_89B64E0[];

//----- (08132838) --------------------------------------------------------
void sub_8132838()
{
  size_t v0; // ecx
  float v1; // edx
  int i; // [esp+14h] [ebp-4h]
  signed int j; // [esp+14h] [ebp-4h]

  sub_813277E();
  sub_813261C();
  for ( i = 0; i < dword_89BD580; ++i )
  {
    v0 = dword_89B9D20;
    v1 = flt_89B9D44[2 * i];
    dword_89B64E0[2 * dword_89B9D20] = dword_89B9D40[2 * i];
    flt_89B64E4[2 * v0] = v1;
    ++dword_89B9D20;
  }
  sub_8131708();
  if ( *(_BYTE *)(dword_89A2C8C + 8) )
    sub_81322F4(dword_89B64E0, dword_89B9D20);
  if ( *(_BYTE *)(dword_89A2C84 + 8) )
  {
    for ( j = 0; j < (signed int)dword_89B9D20; ++j )
      (*(void (__cdecl **)(int))(*(_DWORD *)dword_89B64E0[2 * j] + 20))(dword_89B64E0[2 * j]);
  }
  if ( *(_BYTE *)(dword_89A2C90 + 8) )
  {
    sub_812F0A2("Active    FX: %i\n", *(_DWORD *)dword_89B63A8);
    sub_812F0A2("Drawn     FX: %i\n", dword_89B9D20);
    sub_812F0A2("Scheduled FX: %i\n", *((_DWORD *)dword_89A2814 + 2));
  }
}
// 89A2C84: using guessed type int dword_89A2C84;
// 89A2C8C: using guessed type int dword_89A2C8C;
// 89A2C90: using guessed type int dword_89A2C90;
// 89B64E0: using guessed type int dword_89B64E0[];
// 89B9D40: using guessed type int dword_89B9D40[];
// 89BD580: using guessed type int dword_89BD580;

//----- (08132948) --------------------------------------------------------
float *__cdecl sub_8132948(int a1, float *a2, float *a3, float *a4)
{
  int v4; // ST2C_4
  int v5; // esi
  int v6; // ST2C_4
  int v7; // ST04_4
  float v8; // ST2C_4
  float v9; // esi
  float v10; // ST2C_4
  float v11; // ST04_4
  int v12; // ST0C_4
  int v13; // ST08_4
  int v14; // ST04_4
  float v15; // ST04_4
  float v16; // ST30_4
  float v17; // ST0C_4
  float v18; // ST04_4
  _DWORD *v19; // eax
  float *v20; // ST3C_4
  int v22; // [esp+38h] [ebp-90h]
  int v23; // [esp+40h] [ebp-88h]
  int v24; // [esp+50h] [ebp-78h]
  int v25; // [esp+54h] [ebp-74h]
  int v26; // [esp+58h] [ebp-70h]
  float v27; // [esp+68h] [ebp-60h]
  float v28; // [esp+6Ch] [ebp-5Ch]
  int v29; // [esp+70h] [ebp-58h]
  int v30; // [esp+80h] [ebp-48h]
  float v31; // [esp+9Ch] [ebp-2Ch]
  int v32; // [esp+A0h] [ebp-28h]
  int v33; // [esp+A4h] [ebp-24h]
  int v34; // [esp+A8h] [ebp-20h]
  int v35; // [esp+ACh] [ebp-1Ch]
  float v36; // [esp+B0h] [ebp-18h]
  float v37; // [esp+B4h] [ebp-14h]
  float v38; // [esp+B8h] [ebp-10h]
  float v39; // [esp+BCh] [ebp-Ch]

  v24 = 0;
  v25 = 0;
  v26 = 1065353216;
  v22 = *(_DWORD *)(a1 + 4);
  if ( *(_DWORD *)(v22 + 148) & 0x40 )
  {
    *(float *)&v4 = sub_812F170((float *)(v22 + 200));
    v5 = v4;
    *(float *)&v6 = sub_812F170((float *)(v22 + 192));
    *(float *)&v7 = sub_812F170((float *)(v22 + 184));
    sub_8134DA4(&v23, v7, v6, v5);
  }
  else
  {
    v8 = sub_812F170((float *)(v22 + 200));
    v9 = v8;
    v10 = sub_812F170((float *)(v22 + 192));
    v11 = sub_812F170((float *)(v22 + 184));
    sub_80A70C0((int)a4, v11, v10, v9, (int)&v23);
  }
  sub_8134DF8((float *)&v23, a3, (float *)&v23);
  if ( *(_BYTE *)(v22 + 148) & 1 )
  {
    v39 = sub_80A8720(0.0, 360.0) * 0.0174532925199433;
    sub_8134D76(v39, (int)&v35, (int)&v34);
    v38 = sub_80A8720(0.0, 180.0) * 0.0174532925199433;
    sub_8134D76(v38, (int)&v33, (int)&v32);
    v37 = sub_812F170((float *)(v22 + 232));
    v36 = sub_812F170((float *)(v22 + 240));
    *(float *)&v12 = *(float *)&v32 * v36;
    *(float *)&v13 = *(float *)&v34 * v37 * *(float *)&v33;
    *(float *)&v14 = *(float *)&v35 * v37 * *(float *)&v33;
    sub_8134DA4(&v30, v14, v13, v12);
    sub_8134DF8((float *)&v23, (float *)&v30, (float *)&v23);
    if ( *(_DWORD *)(v22 + 148) & 2 )
    {
      v31 = sub_8134F40(&v30);
      if ( v31 != 0.0 )
      {
        v15 = 1.0 / v31;
        sub_8134E80((int)&v30, v15, (int)a4);
        sub_80A295E((int)a4, (int)(a4 + 3), a4 + 6);
      }
    }
  }
  else if ( *(_DWORD *)(v22 + 148) & 4 )
  {
    v16 = sub_80A8720(-0.5, 0.5);
    v27 = sub_812F170((float *)(v22 + 240)) * v16;
    v28 = sub_812F170((float *)(v22 + 232));
    sub_8134E80((int)(a4 + 3), v28, (int)&v29);
    sub_8134EB8((int)&v29, v27, (int)a4, (int)&v29);
    v17 = sub_80A8720(0.0, 360.0);
    sub_80A2672((int)&v30, (int)a4, (int)&v29, v17);
    sub_8134DF8((float *)&v23, (float *)&v30, (float *)&v23);
    if ( *(_DWORD *)(v22 + 148) & 2 )
    {
      v31 = sub_8134F40(&v30);
      if ( v31 != 0.0 )
      {
        v18 = 1.0 / v31;
        sub_8134E80((int)&v30, v18, (int)a4);
        if ( sub_8134D5C(a4[2]) >= 0.99900001 )
          sub_8134DA4(&v24, 0, 1065353216, 0);
        sub_80A1ED8((float *)&v24, a4, a4 + 3);
        sub_80A20C0(a4 + 3);
        sub_80A1ED8(a4, a4 + 3, a4 + 6);
      }
    }
  }
  if ( !(unsigned __int8)sub_812782E((_DWORD *)(a1 + 8)) )
    return (float *)sub_8134DC8(&v23, a2);
  v19 = (_DWORD *)sub_812787E(a1 + 8);
  v20 = (float *)sub_8122008(v19);
  return sub_80B68EE(v20, (float *)&v23, a2);
}
// 8134F40: using guessed type double __cdecl sub_8134F40(_DWORD);

//----- (08132E4E) --------------------------------------------------------
void __cdecl sub_8132E4E(int a1, int a2, float *a3, float *a4, int a5)
{
  int v5; // ST2C_4
  int v6; // esi
  int v7; // ST2C_4
  int v8; // ST04_4
  float v9; // ST2C_4
  float v10; // esi
  float v11; // ST2C_4
  float v12; // ST04_4
  _DWORD *v13; // eax
  int v14; // ST2C_4
  int v15; // esi
  int v16; // ST2C_4
  int v17; // ST04_4
  float v18; // ST2C_4
  float v19; // esi
  float v20; // ST2C_4
  float v21; // ST04_4
  int v22; // [esp+30h] [ebp-58h]
  int v23; // [esp+40h] [ebp-48h]
  float s; // [esp+50h] [ebp-38h]
  int v25; // [esp+54h] [ebp-34h]

  if ( *(_DWORD *)(a1 + 148) & 8 )
  {
    sub_8134EB8(a2, 16384.0, a5, (int)&v23);
    if ( *(_DWORD *)(a1 + 148) & 0x20 )
    {
      if ( *(_BYTE *)(a1 + 148) >= 0 )
      {
        v9 = sub_812F170((float *)(a1 + 224));
        v10 = v9;
        v11 = sub_812F170((float *)(a1 + 216));
        v12 = sub_812F170((float *)(a1 + 208));
        sub_80A70C0(a5, v12, v11, v10, (int)&v22);
        sub_8134DF8((float *)&v23, (float *)&v22, (float *)&v23);
      }
      else
      {
        *(float *)&v5 = sub_812F170((float *)(a1 + 224));
        v6 = v5;
        *(float *)&v7 = sub_812F170((float *)(a1 + 216));
        *(float *)&v8 = sub_812F170((float *)(a1 + 208));
        sub_8134DA4(a3, v8, v7, v6);
        sub_8134DF8(a3, (float *)&v23, (float *)&v23);
      }
    }
    sub_812AD4E(off_8168620, &s, a2, (int)&unk_8145E68, (int)&unk_8145E68, (int)&v23, -1, 1);
    sub_80DEB7A(a2, (int)&v23, s, (int)a3);
    if ( *(_DWORD *)(a1 + 148) & 0x10 )
    {
      v13 = (_DWORD *)sub_812873E(a1 + 112);
      sub_8128900((int *)dword_89A2814, v13, a3, &v25);
    }
  }
  else
  {
    if ( *(_BYTE *)(a1 + 148) >= 0 )
    {
      v18 = sub_812F170((float *)(a1 + 224));
      v19 = v18;
      v20 = sub_812F170((float *)(a1 + 216));
      v21 = sub_812F170((float *)(a1 + 208));
      sub_80A70C0(a5, v21, v20, v19, (int)a3);
    }
    else
    {
      *(float *)&v14 = sub_812F170((float *)(a1 + 224));
      v15 = v14;
      *(float *)&v16 = sub_812F170((float *)(a1 + 216));
      *(float *)&v17 = sub_812F170((float *)(a1 + 208));
      sub_8134DA4(a3, v17, v16, v15);
    }
    sub_8134DF8(a3, a4, a3);
  }
}

//----- (08133120) --------------------------------------------------------
int __cdecl sub_8133120(int a1, int a2, int a3, signed int a4)
{
  float v4; // ST1C_4
  int result; // eax
  int v6; // [esp+20h] [ebp-18h]

  if ( a4 > 0 )
  {
    v4 = (long double)a4 * 0.001;
    sub_8123D56(a2, a4, (float *)&v6);
    result = sub_8134EB8(a3, v4, (int)&v6, a3);
  }
  return result;
}

//----- (08133176) --------------------------------------------------------
signed int __cdecl sub_8133176(int *a1, _DWORD *a2, float *a3)
{
  int v3; // ebx
  signed int v4; // ST10_4
  int v5; // eax
  int v6; // eax
  signed int v8; // [esp+Ch] [ebp-1Ch]
  size_t v9; // [esp+18h] [ebp-10h]
  int v10; // [esp+1Ch] [ebp-Ch]
  char *v11; // [esp+20h] [ebp-8h]

  v10 = a1[1];
  if ( (unsigned __int8)sub_812782E(a1 + 2) )
    v11 = sub_813150E();
  else
    v11 = sub_813155A();
  v9 = sub_8130F90(a3);
  if ( v11 )
  {
    if ( *(_DWORD *)(v10 + 144) & 0x1000 )
      ++dword_89B63CC;
    *(_DWORD *)v11 = a2;
    sub_8135186((int)a2, *(_DWORD *)(v10 + 144));
    v3 = off_8168620;
    v4 = (signed int)sub_812F170((float *)(v10 + 88));
    sub_8122472((int)a2, *(_DWORD *)(off_8168620 + 4), *(_DWORD *)(v3 + 4) + v4);
    sub_81351C2((int)a2, *a1);
    sub_81351D0((int)a2, *(_DWORD *)(v10 + 68));
    sub_8135198((int)a2, *(_DWORD *)(v10 + 152));
    sub_81350EA((int)a2, (_DWORD *)(v10 + 160));
    sub_813511E((int)a2, (_DWORD *)(v10 + 172));
    v5 = sub_812873E(v10 + 120);
    sub_81351B4((int)a2, v5);
    v6 = sub_812873E(v10 + 112);
    sub_81351A6((int)a2, v6);
    (*(void (__cdecl **)(_DWORD *, int))(*a2 + 32))(a2, v10);
    sub_81224B2((int)a2, a1 + 2);
    a2[43] = v9;
    v8 = 1;
  }
  else
  {
    sub_8131508();
    v8 = 0;
  }
  return v8;
}
// 89B63CC: using guessed type int dword_89B63CC;

//----- (08133348) --------------------------------------------------------
int __cdecl sub_8133348(int a1)
{
  int result; // eax
  int v2; // ST04_4

  *(_DWORD *)(a1 + 176) = 0;
  result = a1;
  if ( *(_DWORD *)(a1 + 64) )
  {
    v2 = *(_DWORD *)(a1 + 64);
    result = sub_812AE5C();
    if ( (_BYTE)result )
    {
      result = a1;
      *(_DWORD *)(a1 + 176) = -1;
    }
  }
  return result;
}

//----- (0813338E) --------------------------------------------------------
int __cdecl sub_813338E(int a1, int a2, signed int a3, int a4)
{
  int v5; // [esp+14h] [ebp-14h]
  float v6; // [esp+18h] [ebp-10h]
  int v7; // [esp+1Ch] [ebp-Ch]
  int v8; // [esp+20h] [ebp-8h]
  int v9; // [esp+24h] [ebp-4h]

  sub_812875E(&v5, a1 + 104);
  v9 = v5;
  if ( v5 )
  {
    v8 = sub_812AE52();
    if ( v8 == 1 )
    {
      v7 = 0;
      v6 = 0.0;
    }
    else
    {
      if ( *(_DWORD *)(a1 + 648) )
      {
        if ( *(_DWORD *)(a1 + 648) == 1 )
        {
          v7 = sub_80A8776(0, v8);
        }
        else if ( *(_DWORD *)(a1 + 648) == 2 )
        {
          v7 = a4;
        }
        else
        {
          v7 = 0;
        }
      }
      else
      {
        v7 = *(_DWORD *)(a1 + 652) - 1;
      }
      if ( *(_DWORD *)(a1 + 656) )
      {
        if ( *(_DWORD *)(a1 + 656) == 1 )
          v6 = (long double)v8 / (long double)a3;
        else
          v6 = 0.0;
      }
      else
      {
        v6 = *(float *)(a1 + 660) / 1000.0;
      }
    }
  }
  else
  {
    v7 = 0;
    v6 = 0.0;
  }
  sub_81352CA(a2, v7);
  sub_81352DC(a2, SLODWORD(v6));
  sub_81352EE(a2, *(_DWORD *)(a1 + 664));
  sub_8135300(a2, *(_DWORD *)(a1 + 668));
  sub_813526E(a2, v9);
  return sub_8133348(a2);
}

//----- (0813350E) --------------------------------------------------------
int __cdecl sub_813350E(int a1, _DWORD *a2, float *a3, float *a4, float *a5)
{
  int v5; // ST04_4
  int v6; // ST04_4
  int v7; // ST04_4
  int v8; // ST04_4
  int v9; // ST04_4
  int v10; // ST18_4
  int v11; // esi
  int v12; // ST18_4
  int v13; // ST04_4
  int v14; // ST18_4
  int v15; // esi
  int v16; // ST18_4
  int v17; // ST04_4
  int v18; // ST04_4
  int v19; // ST04_4
  int v20; // ST04_4
  int v21; // ST04_4
  int v23; // [esp+1Ch] [ebp-Ch]

  v23 = *(_DWORD *)(a1 + 4);
  if ( *(_DWORD *)(v23 + 144) & 0x2000 )
  {
    *(float *)&v5 = sub_80A8720(0.0, 1.0);
    sub_8135312((int)a2, v5);
  }
  if ( *(_DWORD *)(v23 + 144) & 0x4000 )
  {
    *(float *)&v6 = sub_80A8720(0.0, 1.0);
    sub_8135324((int)a2, v6);
  }
  if ( *(_WORD *)(v23 + 144) < 0 )
  {
    *(float *)&v7 = sub_80A8720(0.0, 1.0);
    sub_8135336((int)a2, v7);
  }
  if ( *(_DWORD *)(v23 + 144) & 0x10000 )
  {
    *(float *)&v8 = sub_80A8720(0.0, 1.0);
    sub_8135348((int)a2, v8);
  }
  if ( *(_DWORD *)(v23 + 144) & 0x40000 )
  {
    *(float *)&v9 = sub_80A8720(0.0, 1.0);
    sub_813535A((int)a2, v9);
  }
  if ( *(_DWORD *)(v23 + 144) & 0x80000 )
  {
    *(float *)&v10 = sub_80A8720(0.0, 1.0);
    v11 = v10;
    *(float *)&v12 = sub_80A8720(0.0, 1.0);
    *(float *)&v13 = sub_80A8720(0.0, 1.0);
    sub_8122EAC((int)a2, v13, v12, v11);
  }
  if ( *(_DWORD *)(v23 + 144) & 0x100000 )
  {
    *(float *)&v14 = sub_80A8720(0.0, 1.0);
    v15 = v14;
    *(float *)&v16 = sub_80A8720(0.0, 1.0);
    *(float *)&v17 = sub_80A8720(0.0, 1.0);
    sub_8122EDA((int)a2, v17, v16, v15);
  }
  *(float *)&v18 = sub_812F170((float *)(v23 + 600));
  sub_813527C((int)a2, v18);
  *(float *)&v19 = sub_812F170((float *)(v23 + 248));
  sub_813536C((int)a2, v19);
  sub_8132948(a1, a3, a4, a5);
  sub_8122BB2(a2, a5);
  sub_81352AE((int)a2, *(_BYTE *)(v23 + 156));
  *(float *)&v20 = sub_812F170((float *)(v23 + 640));
  sub_813529C((int)a2, v20);
  *(float *)&v21 = sub_812F170((float *)(v23 + 544));
  return sub_813528E((int)a2, v21);
}

//----- (081337F2) --------------------------------------------------------
signed int __cdecl sub_81337F2(int *a1, float *a2, float *a3, signed int a4, int a5)
{
  _DWORD *v5; // ST38_4
  signed int result; // eax
  int v7; // eax
  float v8[7]; // [esp+40h] [ebp-28h]
  _DWORD *v9; // [esp+5Ch] [ebp-Ch]

  v5 = sub_813537E(588);
  sub_81227F0(v5);
  result = (signed int)v5;
  v9 = v5;
  if ( v5 )
  {
    result = sub_8133176(a1, v9, a3);
    if ( (_BYTE)result )
    {
      sub_813350E((int)a1, v9, v8, a3, a2);
      v7 = sub_8127896((int)v9);
      sub_813338E(a1[1], (int)v9, v7, a5);
      sub_8133120(a1[1], (int)v9, (int)v8, a4);
      result = sub_8135152((int)v9, v8);
    }
    else if ( v9 )
    {
      result = (*(int (__cdecl **)(_DWORD *))(*v9 + 4))(v9);
    }
  }
  return result;
}

//----- (0813392A) --------------------------------------------------------
_DWORD *__cdecl sub_813392A(int *a1, float *a2, float *a3)
{
  _DWORD *v3; // ST2C_4
  _DWORD *result; // eax
  _DWORD *v5; // eax
  int v6; // ST04_4
  int v7; // ST04_4
  int v8; // ST04_4
  int v9; // ST04_4
  int v10; // [esp+30h] [ebp-78h]
  int v11; // [esp+34h] [ebp-74h]
  char v12; // [esp+3Bh] [ebp-6Dh]
  float *v13; // [esp+3Ch] [ebp-6Ch]
  float v14[4]; // [esp+40h] [ebp-68h]
  float v15[4]; // [esp+50h] [ebp-58h]
  char v16; // [esp+60h] [ebp-48h]
  float v17[4]; // [esp+70h] [ebp-38h]
  float v18[6]; // [esp+80h] [ebp-28h]
  int v19; // [esp+98h] [ebp-10h]
  _DWORD *v20; // [esp+9Ch] [ebp-Ch]

  v3 = sub_81353D6(600);
  sub_812528A(v3);
  result = v3;
  v20 = v3;
  if ( v3 )
  {
    result = (_DWORD *)sub_8133176(a1, v20, a3);
    v12 = (char)result;
    if ( (_BYTE)result )
    {
      sub_8132948((int)a1, v18, a3, a2);
      sub_8122BB2(v20, a2);
      v11 = a1[1];
      sub_8132E4E(v11, (int)v18, v17, a3, (int)a2);
      sub_8134DC8(v18, &v16);
      sub_8134DC8(v17, v15);
      sub_812875E(&v10, v11 + 104);
      v19 = v10;
      if ( (unsigned __int8)sub_812782E(a1 + 2) )
      {
        v5 = (_DWORD *)sub_812787E((int)(a1 + 2));
        v13 = (float *)sub_8122008(v5);
        sub_80B68EE(v13, v15, v14);
        sub_81353B6((int)v20, v14);
      }
      else
      {
        sub_81353B6((int)v20, v15);
      }
      sub_8135152((int)v20, &v16);
      sub_813526E((int)v20, v19);
      if ( *(_DWORD *)(v11 + 144) & 0x2000 )
      {
        *(float *)&v6 = sub_80A8720(0.0, 1.0);
        sub_8135312((int)v20, v6);
      }
      if ( *(_DWORD *)(v11 + 144) & 0x4000 )
      {
        *(float *)&v7 = sub_80A8720(0.0, 1.0);
        sub_8135324((int)v20, v7);
      }
      if ( *(_WORD *)(v11 + 144) < 0 )
      {
        *(float *)&v8 = sub_80A8720(0.0, 1.0);
        sub_8135336((int)v20, v8);
      }
      if ( *(_DWORD *)(v11 + 144) & 0x10000 )
      {
        *(float *)&v9 = sub_80A8720(0.0, 1.0);
        sub_8135348((int)v20, v9);
      }
      result = (_DWORD *)sub_8133348((int)v20);
    }
    else if ( v20 )
    {
      result = (_DWORD *)(*(int (__cdecl **)(_DWORD *))(*v20 + 4))(v20);
    }
  }
  return result;
}

//----- (08133C04) --------------------------------------------------------
void __cdecl sub_8133C04(int *a1, float *a2, float *a3, signed int a4, int a5)
{
  float *v5; // ST38_4
  int v6; // eax
  float *v7; // ebx
  int v8; // [esp+40h] [ebp-38h]
  int v9; // [esp+50h] [ebp-28h]
  float *v10; // [esp+6Ch] [ebp-Ch]

  v5 = (float *)sub_813544E(632);
  sub_812550A(v5);
  v10 = v5;
  if ( v5 )
  {
    if ( (unsigned __int8)sub_8133176(a1, v10, a3) )
    {
      sub_813350E((int)a1, v10, (float *)&v9, a3, a2);
      v6 = sub_8127896((int)v10);
      sub_813338E(a1[1], (int)v10, v6, a5);
      sub_8133120(a1[1], (int)v10, (int)&v9, a4);
      sub_8134EB8((int)&v9, -1.0, (int)a2, (int)&v8);
      sub_8135152((int)v10, &v9);
      sub_813542E((int)v10, &v8);
      v7 = v10;
      v7[151] = sub_80A8720(0.0, 1.0);
      sub_81255C2(v10);
    }
    else if ( v10 )
    {
      (*(void (__cdecl **)(float *))(*(_DWORD *)v10 + 4))(v10);
    }
  }
}

//----- (08133D9E) --------------------------------------------------------
signed int __cdecl sub_8133D9E(int *a1, float *a2, float *a3, int a4, int a5)
{
  _DWORD *v5; // ST34_4
  signed int result; // eax
  int v7; // eax
  _DWORD *v8; // eax
  float *v9; // ST3C_4
  float v10[4]; // [esp+40h] [ebp-58h]
  float v11[4]; // [esp+50h] [ebp-48h]
  char v12; // [esp+60h] [ebp-38h]
  float v13[7]; // [esp+70h] [ebp-28h]
  _DWORD *v14; // [esp+8Ch] [ebp-Ch]

  v5 = sub_8135488(632);
  sub_8125A04(v5);
  result = (signed int)v5;
  v14 = v5;
  if ( v5 )
  {
    result = sub_8133176(a1, v14, a3);
    if ( (_BYTE)result )
    {
      sub_813350E((int)a1, v14, v13, a3, a2);
      v7 = sub_8127896((int)v14);
      sub_813338E(a1[1], (int)v14, v7, a5);
      sub_8134DC8(v13, &v12);
      sub_8134DC8(a2, v11);
      if ( (unsigned __int8)sub_812782E(a1 + 2) )
      {
        v8 = (_DWORD *)sub_812787E((int)(a1 + 2));
        v9 = (float *)sub_8122008(v8);
        sub_80B6998(v9, v11, v10);
        sub_813546A((int)v14, v10);
      }
      else
      {
        sub_813546A((int)v14, v11);
      }
      result = sub_8135152((int)v14, &v12);
    }
    else if ( v14 )
    {
      result = (*(int (__cdecl **)(_DWORD *))(*v14 + 4))(v14);
    }
  }
  return result;
}

//----- (08133F44) --------------------------------------------------------
float *__cdecl sub_8133F44(int *a1, float *a2, float *a3, signed int a4)
{
  float *v4; // ST3C_4
  float *result; // eax
  int v6; // ST2C_4
  int v7; // esi
  int v8; // ST2C_4
  int v9; // ST04_4
  int v10; // ST2C_4
  int v11; // esi
  int v12; // ST2C_4
  int v13; // ST04_4
  _DWORD *v14; // eax
  int v15; // [esp+40h] [ebp-88h]
  float *v16; // [esp+44h] [ebp-84h]
  char v17; // [esp+4Bh] [ebp-7Dh]
  _DWORD *v18; // [esp+4Ch] [ebp-7Ch]
  char v19; // [esp+50h] [ebp-78h]
  float v20[4]; // [esp+60h] [ebp-68h]
  char v21; // [esp+70h] [ebp-58h]
  char v22; // [esp+80h] [ebp-48h]
  float v23[7]; // [esp+90h] [ebp-38h]
  int v24; // [esp+ACh] [ebp-1Ch]
  int v25; // [esp+B0h] [ebp-18h]
  int v26; // [esp+B4h] [ebp-14h]
  int v27; // [esp+B8h] [ebp-10h]
  float *v28; // [esp+BCh] [ebp-Ch]

  v4 = (float *)sub_813559E(668);
  sub_8125CB8(v4);
  result = v4;
  v28 = v4;
  if ( v4 )
  {
    result = (float *)sub_8133176(a1, v28, a3);
    v17 = (char)result;
    if ( (_BYTE)result )
    {
      sub_813350E((int)a1, v28, v20, a3, a2);
      v16 = (float *)a1[1];
      sub_8133120((int)v16, (int)v28, (int)v20, a4);
      *(float *)&v6 = sub_812F170(v16 + 142);
      v7 = v6;
      *(float *)&v8 = sub_812F170(v16 + 140);
      *(float *)&v9 = sub_812F170(v16 + 138);
      sub_8134DA4(v23, v9, v8, v7);
      sub_80A2C7E(a2, (int)&v21);
      sub_8134DF8(v23, (float *)&v21, v23);
      *(float *)&v10 = sub_812F170(v16 + 148);
      v11 = v10;
      *(float *)&v12 = sub_812F170(v16 + 146);
      *(float *)&v13 = sub_812F170(v16 + 144);
      sub_8134DA4(&v22, v13, v12, v11);
      sub_812875E(&v15, (int)(v16 + 26));
      v24 = v15;
      v27 = sub_812873E((int)(v16 + 32));
      *(float *)&v26 = sub_812F170(v16 + 152);
      *(float *)&v25 = sub_812F170(v16 + 154);
      if ( (unsigned __int8)sub_812782E(a1 + 2) )
      {
        v14 = (_DWORD *)sub_812787E((int)(a1 + 2));
        v18 = (_DWORD *)sub_8122008(v14);
        sub_813557E((int)v28, v18);
      }
      else
      {
        sub_813557E((int)v28, 0);
      }
      if ( !v24 )
        sub_81350CE((int)v28, 16);
      sub_8123E30((int)v28, &v19);
      sub_8135152((int)v28, v20);
      sub_813553E((int)v28, v20);
      sub_813555E((int)v28, &v19);
      sub_81354B6((int)v28, v23);
      sub_81354D6((int)v28, &v22);
      sub_81354A4((int)v28, v24);
      sub_81354F6((int)v28, v27);
      sub_8135508((int)v28, v26);
      sub_813551A((int)v28, v25);
      sub_813552C((int)v28, *(_DWORD *)(off_8168620 + 4));
      result = sub_8127A02(v28);
    }
    else if ( v28 )
    {
      result = (float *)(*(int (__cdecl **)(float *))(*(_DWORD *)v28 + 4))(v28);
    }
  }
  return result;
}

//----- (0813431A) --------------------------------------------------------
void __cdecl sub_813431A(int a1, float *a2, float *a3)
{
  int v3; // ST04_4
  char v4; // [esp+10h] [ebp-18h]

  sub_8132948(a1, (float *)&v4, a3, a2);
  v3 = *(_DWORD *)(a1 + 4);
  sub_8129104();
}

//----- (08134368) --------------------------------------------------------
void __cdecl sub_8134368(int a1, float *a2, float *a3)
{
  _DWORD *v3; // ebx
  _DWORD *v4; // eax
  _DWORD *v5; // eax
  int v6; // [esp+2Ch] [ebp-1Ch]
  char v7; // [esp+30h] [ebp-18h]

  sub_8132948(a1, (float *)&v7, a3, a2);
  v6 = *(_DWORD *)(a1 + 4);
  if ( (unsigned __int8)sub_812782E((_DWORD *)(a1 + 8)) )
  {
    v3 = (_DWORD *)(sub_812787E(a1 + 8) + 60);
    v4 = (_DWORD *)sub_812873E(v6 + 136);
    sub_8128ACC((int *)dword_89A2814, v4, (float *)&v7, 0, v3);
  }
  else
  {
    v5 = (_DWORD *)sub_812873E(v6 + 136);
    sub_8128ACC((int *)dword_89A2814, v5, (float *)&v7, a2, 0);
  }
}

//----- (08134432) --------------------------------------------------------
void __cdecl sub_8134432(int a1, float *a2, float *a3)
{
  float *v3; // ST2C_4
  signed int v4; // esi
  float v5; // ST08_4
  char v6; // [esp+30h] [ebp-18h]

  sub_8132948(a1, (float *)&v6, a3, a2);
  v3 = *(float **)(a1 + 4);
  v4 = (signed int)sub_812F170(v3 + 22);
  sub_812F170(v3 + 58);
  v5 = sub_812F170(v3 + 160);
  sub_812AE72();
}

//----- (081344EE) --------------------------------------------------------
signed int __cdecl sub_81344EE(int *a1, float *a2, float *a3)
{
  _DWORD *v3; // ST24_4
  signed int result; // eax
  int v5; // ST04_4
  int v6; // ST04_4
  int v7; // [esp+28h] [ebp-30h]
  float v8[7]; // [esp+30h] [ebp-28h]
  _DWORD *v9; // [esp+4Ch] [ebp-Ch]

  v3 = sub_8135228(252);
  sub_812679A(v3);
  result = (signed int)v3;
  v9 = v3;
  if ( v3 )
  {
    result = sub_8133176(a1, v9, a3);
    if ( (_BYTE)result )
    {
      sub_8132948((int)a1, v8, a3, a2);
      sub_8135152((int)v9, v8);
      v7 = a1[1];
      if ( *(_DWORD *)(v7 + 144) & 0x2000 )
      {
        *(float *)&v5 = sub_80A8720(0.0, 1.0);
        sub_8135204((int)v9, v5);
      }
      result = *(_WORD *)(v7 + 144) & 0x8000;
      if ( *(_WORD *)(v7 + 144) < 0 )
      {
        *(float *)&v6 = sub_80A8720(0.0, 1.0);
        result = sub_8135216((int)v9, v6);
      }
    }
    else if ( v9 )
    {
      result = (*(int (__cdecl **)(_DWORD *))(*v9 + 4))(v9);
    }
  }
  return result;
}

//----- (08134642) --------------------------------------------------------
signed int __cdecl sub_8134642(int *a1, float *a2, float *a3, signed int a4, int a5)
{
  _DWORD *v5; // ST30_4
  signed int result; // eax
  int v7; // ST34_4
  int v8; // eax
  _DWORD *v9; // eax
  float *v10; // ST3C_4
  float v11[4]; // [esp+40h] [ebp-48h]
  float v12[4]; // [esp+50h] [ebp-38h]
  float v13[7]; // [esp+60h] [ebp-28h]
  _DWORD *v14; // [esp+7Ch] [ebp-Ch]

  v5 = sub_8135412(600);
  sub_81249E6(v5);
  result = (signed int)v5;
  v14 = v5;
  if ( v5 )
  {
    result = sub_8133176(a1, v14, a3);
    if ( (_BYTE)result )
    {
      sub_813350E((int)a1, v14, v13, a3, a2);
      v7 = a1[1];
      v8 = sub_8127896((int)v14);
      sub_813338E(v7, (int)v14, v8, a5);
      sub_8133120(v7, (int)v14, (int)v13, a4);
      sub_8134DC8(a2, v12);
      if ( (unsigned __int8)sub_812782E(a1 + 2) )
      {
        v9 = (_DWORD *)sub_812787E((int)(a1 + 2));
        v10 = (float *)sub_8122008(v9);
        sub_80B6998(v10, v12, v11);
        sub_81353F2((int)v14, v11);
      }
      else
      {
        sub_81353F2((int)v14, v12);
      }
      result = sub_8135152((int)v14, v13);
    }
    else if ( v14 )
    {
      result = (*(int (__cdecl **)(_DWORD *))(*v14 + 4))(v14);
    }
  }
  return result;
}

//----- (081347FC) --------------------------------------------------------
signed int __cdecl sub_81347FC(int *a1, int a2, float *a3)
{
  _DWORD *v3; // ST20_4
  signed int result; // eax
  int v5; // ST04_4
  int v6; // [esp+24h] [ebp-14h]
  int v7; // [esp+28h] [ebp-10h]
  char v8; // [esp+2Fh] [ebp-9h]
  int v9; // [esp+30h] [ebp-8h]
  _DWORD *v10; // [esp+34h] [ebp-4h]

  v3 = sub_8135228(252);
  sub_8135244(v3);
  result = (signed int)v3;
  v10 = v3;
  if ( v3 )
  {
    result = sub_8133176(a1, v10, a3);
    v8 = result;
    if ( (_BYTE)result )
    {
      v7 = a1[1];
      sub_812875E(&v6, v7 + 104);
      v9 = v6;
      sub_8135152((int)v10, a3);
      sub_8135260((int)v10, v9);
      if ( *(_DWORD *)(v7 + 144) & 0x2000 )
      {
        *(float *)&v5 = sub_80A8720(0.0, 1.0);
        sub_8135204((int)v10, v5);
      }
      sub_8133348((int)v10);
      result = sub_8126C40((int)v10);
    }
    else if ( v10 )
    {
      result = (*(int (__cdecl **)(_DWORD *))(*v10 + 4))(v10);
    }
  }
  return result;
}

//----- (0813493C) --------------------------------------------------------
signed int __cdecl sub_813493C(int *a1, float *a2, float *a3, signed int a4, int a5)
{
  _DWORD *v5; // ST34_4
  signed int result; // eax
  int v7; // ST38_4
  int v8; // eax
  int v9; // ebx
  float v10[7]; // [esp+40h] [ebp-28h]
  _DWORD *v11; // [esp+5Ch] [ebp-Ch]

  v5 = sub_813539A(636);
  sub_8124CB6(v5);
  result = (signed int)v5;
  v11 = v5;
  if ( v5 )
  {
    result = sub_8133176(a1, v11, a3);
    if ( (_BYTE)result )
    {
      sub_813350E((int)a1, v11, v10, a3, a2);
      v7 = a1[1];
      v8 = sub_8127896((int)v11);
      sub_813338E(v7, (int)v11, v8, a5);
      sub_8133120(v7, (int)v11, (int)v10, a4);
      sub_8135152((int)v11, v10);
      v9 = (int)v11;
      *(float *)(v9 + 608) = sub_80A8720(0.0, 1.0);
      result = *(unsigned __int8 *)(v7 + 157);
      *((_BYTE *)v11 + 604) = result;
    }
    else if ( v11 )
    {
      result = (*(int (__cdecl **)(_DWORD *))(*v11 + 4))(v11);
    }
  }
  return result;
}

//----- (08134AAE) --------------------------------------------------------
int sub_8134AAE()
{
  int result; // eax
  int v1; // [esp+20h] [ebp-48h]
  int v2; // [esp+24h] [ebp-44h]
  int *v3; // [esp+28h] [ebp-40h]
  int i; // [esp+2Ch] [ebp-3Ch]
  char v5; // [esp+30h] [ebp-38h]
  int v6; // [esp+3Ch] [ebp-2Ch]

  result = dword_89A2C80;
  if ( *(_BYTE *)(dword_89A2C80 + 8) )
  {
    v3 = (int *)((char *)dword_89A2814 + 4);
    result = *((_DWORD *)dword_89A2814 + 1);
    for ( i = *((_DWORD *)dword_89A2814 + 1); i; i = *v3 )
    {
      if ( *(_DWORD *)(i + 8) <= *(_DWORD *)(off_8168620 + 4) )
      {
        v2 = *(_DWORD *)i;
        v1 = *(_DWORD *)(*(_DWORD *)i + 4 * *(_DWORD *)(i + 4) + 8);
        sub_80A8712(*(_DWORD *)(i + 68));
        *v3 = *(_DWORD *)(i + 76);
        --*((_DWORD *)dword_89A2814 + 2);
        if ( *(_DWORD *)(i + 12) < 0 )
        {
          sub_8129488(
            (int)dword_89A2814,
            v2,
            v1,
            (_DWORD *)(i + 12),
            (float *)(i + 20),
            (_DWORD *)(i + 32),
            *(_DWORD *)(off_8168620 + 4) - *(_DWORD *)(i + 8),
            *(_DWORD *)(i + 72));
        }
        else if ( (unsigned __int8)sub_813130E() )
        {
          sub_8129488(
            (int)dword_89A2814,
            v2,
            v1,
            (_DWORD *)(i + 12),
            (float *)&v5,
            &v6,
            *(_DWORD *)(off_8168620 + 4) - *(_DWORD *)(i + 8),
            *(_DWORD *)(i + 72));
        }
        sub_8129BF4((char *)i);
      }
      else
      {
        v3 = (int *)(i + 76);
      }
      result = *v3;
    }
  }
  return result;
}
// 89A2C80: using guessed type int dword_89A2C80;

//----- (08134C2A) --------------------------------------------------------
int sub_8134C2A()
{
  int result; // eax

  result = dword_89A2C80;
  if ( *(_BYTE *)(dword_89A2C80 + 8) )
  {
    dword_89B63C8 = 0;
    dword_89B9D20 = 0;
    sub_81326C8(0);
    result = sub_813277E();
  }
  return result;
}
// 89A2C80: using guessed type int dword_89A2C80;
// 89B63C8: using guessed type int dword_89B63C8;

//----- (08134C64) --------------------------------------------------------
int sub_8134C64()
{
  int result; // eax

  result = dword_89A2C80;
  if ( *(_BYTE *)(dword_89A2C80 + 8) )
  {
    dword_89B63C4 = 0;
    dword_89BD580 = 0;
    sub_8132566(0);
    result = sub_813261C();
  }
  return result;
}
// 89A2C80: using guessed type int dword_89A2C80;
// 89B63C4: using guessed type int dword_89B63C4;
// 89BD580: using guessed type int dword_89BD580;

//----- (08134C9E) --------------------------------------------------------
void sub_8134C9E()
{
  int v0; // ST04_4
  int v1; // ST04_4

  if ( *(_BYTE *)(dword_89A2C80 + 8) )
  {
    sub_81319C4();
    sub_8131926();
    sub_8134AAE();
    v0 = dword_89B63B0;
    dword_89B63B0 = dword_89B63A4;
    sub_81326C8(v0);
    sub_81319C4();
    v1 = dword_89B63AC;
    dword_89B63AC = dword_89B63A0;
    sub_8132566(v1);
    sub_8131926();
    sub_8132838();
  }
}
// 89A2C80: using guessed type int dword_89A2C80;
// 89B63A0: using guessed type int dword_89B63A0;
// 89B63A4: using guessed type int dword_89B63A4;
// 89B63AC: using guessed type int dword_89B63AC;
// 89B63B0: using guessed type int dword_89B63B0;

//----- (08134D0C) --------------------------------------------------------
int *__cdecl sub_8134D0C(int a1, int a2)
{
  int *result; // eax
  int v3; // [esp+Ch] [ebp-Ch]
  _DWORD *v4; // [esp+10h] [ebp-8h]
  void *v5; // [esp+14h] [ebp-4h]

  if ( a2 == 0xFFFF && a1 == 1 )
  {
    v5 = &unk_89B63E0;
    v4 = &unk_89B63E0;
    v3 = 0;
    do
    {
      sub_812A642(v4);
      v4 += 63;
      result = &v3;
      --v3;
    }
    while ( v3 != -1 );
  }
  return result;
}

//----- (08134D5C) --------------------------------------------------------
long double __cdecl sub_8134D5C(float a1)
{
  return (float)fabs(a1);
}

//----- (08134D76) --------------------------------------------------------
void __cdecl sub_8134D76(float a1, int a2, int a3)
{
  *(float *)a2 = sin(a1);
  *(float *)a3 = cos(a1);
}

//----- (08134DA4) --------------------------------------------------------
int __cdecl sub_8134DA4(_DWORD *a1, int a2, int a3, int a4)
{
  int result; // eax

  *a1 = a2;
  a1[1] = a3;
  result = a4;
  a1[2] = a4;
  return result;
}

//----- (08134DC8) --------------------------------------------------------
int __cdecl sub_8134DC8(_DWORD *a1, _DWORD *a2)
{
  int result; // eax

  *a2 = *a1;
  a2[1] = a1[1];
  result = a1[2];
  a2[2] = result;
  return result;
}

//----- (08134DF8) --------------------------------------------------------
int __cdecl sub_8134DF8(float *a1, float *a2, float *a3)
{
  int result; // eax

  *a3 = *a1 + *a2;
  a3[1] = a1[1] + a2[1];
  result = (int)(a1 + 2);
  a3[2] = a1[2] + a2[2];
  return result;
}

//----- (08134E3C) --------------------------------------------------------
int __cdecl sub_8134E3C(float *a1, float *a2, float *a3)
{
  int result; // eax

  *a3 = *a1 - *a2;
  a3[1] = a1[1] - a2[1];
  result = (int)(a1 + 2);
  a3[2] = a1[2] - a2[2];
  return result;
}

//----- (08134E80) --------------------------------------------------------
int __cdecl sub_8134E80(int a1, float a2, int a3)
{
  int result; // eax

  *(float *)a3 = a2 * *(float *)a1;
  *(float *)(a3 + 4) = a2 * *(float *)(a1 + 4);
  result = a1 + 8;
  *(float *)(a3 + 8) = a2 * *(float *)(a1 + 8);
  return result;
}

//----- (08134EB8) --------------------------------------------------------
int __cdecl sub_8134EB8(int a1, float a2, int a3, int a4)
{
  int result; // eax

  *(float *)a4 = a2 * *(float *)a3 + *(float *)a1;
  *(float *)(a4 + 4) = a2 * *(float *)(a3 + 4) + *(float *)(a1 + 4);
  result = a3 + 8;
  *(float *)(a4 + 8) = a2 * *(float *)(a3 + 8) + *(float *)(a1 + 8);
  return result;
}

//----- (08134F0C) --------------------------------------------------------
long double __cdecl sub_8134F0C(float *a1, float *a2)
{
  return *a1 * *a2 + a1[1] * a2[1] + a1[2] * a2[2];
}

//----- (08134F40) --------------------------------------------------------
void __cdecl sub_8134F40(float *a1)
{
  float v1; // ST00_4

  v1 = *a1 * *a1 + a1[1] * a1[1] + a1[2] * a1[2];
  sub_813503A(v1);
}

//----- (08134F7E) --------------------------------------------------------
int __cdecl sub_8134F7E(int a1, int a2)
{
  int v2; // ST00_4
  int result; // eax

  v2 = *((_DWORD *)off_8168618 + a1);
  *((_DWORD *)off_8168618 + a1) = *((_DWORD *)off_8168618 + a2);
  result = v2;
  *((_DWORD *)off_8168618 + a2) = v2;
  return result;
}
// 8168618: using guessed type void *off_8168618;

//----- (08134FDC) --------------------------------------------------------
int __cdecl sub_8134FDC(int a1, int a2)
{
  int v2; // ST00_4
  int result; // eax

  v2 = *((_DWORD *)off_816861C + a1);
  *((_DWORD *)off_816861C + a1) = *((_DWORD *)off_816861C + a2);
  result = v2;
  *((_DWORD *)off_816861C + a2) = v2;
  return result;
}
// 816861C: using guessed type void *off_816861C;

//----- (0813503A) --------------------------------------------------------
long double __cdecl sub_813503A(float a1)
{
  return (float)sqrt(a1);
}

//----- (0813505A) --------------------------------------------------------
int __cdecl sub_813505A(_DWORD *a1)
{
  int result; // eax

  *a1 = 0;
  a1[1] = 0;
  result = 0;
  a1[2] = 0;
  return result;
}

//----- (08135084) --------------------------------------------------------
int __cdecl sub_8135084(_DWORD *a1, _DWORD *a2)
{
  int result; // eax

  if ( a1 )
    result = sub_8134DC8(a1, a2);
  else
    result = sub_813505A(a2);
  return result;
}

//----- (081350B2) --------------------------------------------------------
int *ctor_003()
{
  return sub_8134D0C(1, 0xFFFF);
}

//----- (081350CE) --------------------------------------------------------
int __cdecl sub_81350CE(int a1, int a2)
{
  int result; // eax

  result = *(_DWORD *)(a1 + 168) & ~a2;
  *(_DWORD *)(a1 + 168) = result;
  return result;
}

//----- (081350EA) --------------------------------------------------------
int __cdecl sub_81350EA(int a1, _DWORD *a2)
{
  int result; // eax

  if ( a2 )
    result = sub_8134DC8(a2, (_DWORD *)(a1 + 20));
  else
    result = sub_813505A((_DWORD *)(a1 + 20));
  return result;
}

//----- (0813511E) --------------------------------------------------------
int __cdecl sub_813511E(int a1, _DWORD *a2)
{
  int result; // eax

  if ( a2 )
    result = sub_8134DC8(a2, (_DWORD *)(a1 + 32));
  else
    result = sub_813505A((_DWORD *)(a1 + 32));
  return result;
}

//----- (08135152) --------------------------------------------------------
int __cdecl sub_8135152(int a1, _DWORD *a2)
{
  int result; // eax

  if ( a2 )
    result = sub_8134DC8(a2, (_DWORD *)(a1 + 4));
  else
    result = sub_813505A((_DWORD *)(a1 + 4));
  return result;
}

//----- (08135186) --------------------------------------------------------
int __cdecl sub_8135186(int a1, int a2)
{
  int result; // eax

  result = a2;
  *(_DWORD *)(a1 + 168) = a2;
  return result;
}

//----- (08135198) --------------------------------------------------------
int __cdecl sub_8135198(int a1, int a2)
{
  int result; // eax

  result = a2;
  *(_DWORD *)(a1 + 16) = a2;
  return result;
}

//----- (081351A6) --------------------------------------------------------
int __cdecl sub_81351A6(int a1, int a2)
{
  int result; // eax

  result = a2;
  *(_DWORD *)(a1 + 44) = a2;
  return result;
}

//----- (081351B4) --------------------------------------------------------
int __cdecl sub_81351B4(int a1, int a2)
{
  int result; // eax

  result = a2;
  *(_DWORD *)(a1 + 48) = a2;
  return result;
}

//----- (081351C2) --------------------------------------------------------
int __cdecl sub_81351C2(int a1, int a2)
{
  int result; // eax

  result = a2;
  *(_DWORD *)(a1 + 52) = a2;
  return result;
}

//----- (081351D0) --------------------------------------------------------
int __cdecl sub_81351D0(int a1, int a2)
{
  int result; // eax

  result = a2;
  *(_DWORD *)(a1 + 56) = a2;
  return result;
}

//----- (081351DE) --------------------------------------------------------
int __cdecl sub_81351DE(int a1)
{
  return *(_DWORD *)(a1 + 184);
}

//----- (081351EC) --------------------------------------------------------
int __cdecl sub_81351EC(int a1)
{
  return *(_DWORD *)(a1 + 52);
}

//----- (081351F8) --------------------------------------------------------
int __cdecl sub_81351F8(int a1)
{
  return *(_DWORD *)(a1 + 56);
}

//----- (08135204) --------------------------------------------------------
int __cdecl sub_8135204(int a1, int a2)
{
  int result; // eax

  result = a2;
  *(_DWORD *)(a1 + 196) = a2;
  return result;
}

//----- (08135216) --------------------------------------------------------
int __cdecl sub_8135216(int a1, int a2)
{
  int result; // eax

  result = a2;
  *(_DWORD *)(a1 + 200) = a2;
  return result;
}

//----- (08135228) --------------------------------------------------------
void *__cdecl sub_8135228(int a1)
{
  return sub_81355F0((int *)&unk_89A239C, a1);
}

//----- (08135244) --------------------------------------------------------
_DWORD *__cdecl sub_8135244(_DWORD *a1)
{
  _DWORD *result; // eax

  sub_812677E(a1);
  result = a1;
  *a1 = off_8158268;
  return result;
}
// 8158268: using guessed type int (__cdecl *off_8158268[2])(int);

//----- (08135260) --------------------------------------------------------
int __cdecl sub_8135260(int a1, int a2)
{
  int result; // eax

  result = a2;
  *(_DWORD *)(a1 + 64) = a2;
  return result;
}

//----- (0813526E) --------------------------------------------------------
int __cdecl sub_813526E(int a1, int a2)
{
  int result; // eax

  result = a2;
  *(_DWORD *)(a1 + 64) = a2;
  return result;
}

//----- (0813527C) --------------------------------------------------------
int __cdecl sub_813527C(int a1, int a2)
{
  int result; // eax

  result = a2;
  *(_DWORD *)(a1 + 244) = a2;
  return result;
}

//----- (0813528E) --------------------------------------------------------
int __cdecl sub_813528E(int a1, int a2)
{
  int result; // eax

  result = a2;
  *(_DWORD *)(a1 + 68) = a2;
  return result;
}

//----- (0813529C) --------------------------------------------------------
int __cdecl sub_813529C(int a1, int a2)
{
  int result; // eax

  result = a2;
  *(_DWORD *)(a1 + 256) = a2;
  return result;
}

//----- (081352AE) --------------------------------------------------------
int __cdecl sub_81352AE(int a1, unsigned __int8 a2)
{
  int result; // eax

  result = a2;
  *(_BYTE *)(a1 + 260) = a2;
  return result;
}

//----- (081352CA) --------------------------------------------------------
int __cdecl sub_81352CA(int a1, int a2)
{
  int result; // eax

  result = a2;
  *(_DWORD *)(a1 + 264) = a2;
  return result;
}

//----- (081352DC) --------------------------------------------------------
int __cdecl sub_81352DC(int a1, int a2)
{
  int result; // eax

  result = a2;
  *(_DWORD *)(a1 + 268) = a2;
  return result;
}

//----- (081352EE) --------------------------------------------------------
int __cdecl sub_81352EE(int a1, int a2)
{
  int result; // eax

  result = a2;
  *(_DWORD *)(a1 + 272) = a2;
  return result;
}

//----- (08135300) --------------------------------------------------------
int __cdecl sub_8135300(int a1, int a2)
{
  int result; // eax

  result = a2;
  *(_DWORD *)(a1 + 276) = a2;
  return result;
}

//----- (08135312) --------------------------------------------------------
int __cdecl sub_8135312(int a1, int a2)
{
  int result; // eax

  result = a2;
  *(_DWORD *)(a1 + 280) = a2;
  return result;
}

//----- (08135324) --------------------------------------------------------
int __cdecl sub_8135324(int a1, int a2)
{
  int result; // eax

  result = a2;
  *(_DWORD *)(a1 + 284) = a2;
  return result;
}

//----- (08135336) --------------------------------------------------------
int __cdecl sub_8135336(int a1, int a2)
{
  int result; // eax

  result = a2;
  *(_DWORD *)(a1 + 288) = a2;
  return result;
}

//----- (08135348) --------------------------------------------------------
int __cdecl sub_8135348(int a1, int a2)
{
  int result; // eax

  result = a2;
  *(_DWORD *)(a1 + 292) = a2;
  return result;
}

//----- (0813535A) --------------------------------------------------------
int __cdecl sub_813535A(int a1, int a2)
{
  int result; // eax

  result = a2;
  *(_DWORD *)(a1 + 296) = a2;
  return result;
}

//----- (0813536C) --------------------------------------------------------
int __cdecl sub_813536C(int a1, int a2)
{
  int result; // eax

  result = a2;
  *(_DWORD *)(a1 + 248) = a2;
  return result;
}

//----- (0813537E) --------------------------------------------------------
void *__cdecl sub_813537E(int a1)
{
  return sub_81356CE((int *)&unk_89A23A4, a1);
}

//----- (0813539A) --------------------------------------------------------
void *__cdecl sub_813539A(int a1)
{
  return sub_81357AC((int *)&unk_89A23D4, a1);
}

//----- (081353B6) --------------------------------------------------------
int __cdecl sub_81353B6(int a1, _DWORD *a2)
{
  return sub_8134DC8(a2, (_DWORD *)(a1 + 588));
}

//----- (081353D6) --------------------------------------------------------
void *__cdecl sub_81353D6(int a1)
{
  return sub_813588A((int *)&unk_89A23AC, a1);
}

//----- (081353F2) --------------------------------------------------------
int __cdecl sub_81353F2(int a1, _DWORD *a2)
{
  return sub_8134DC8(a2, (_DWORD *)(a1 + 588));
}

//----- (08135412) --------------------------------------------------------
void *__cdecl sub_8135412(int a1)
{
  return sub_8135968((int *)&unk_89A23B4, a1);
}

//----- (0813542E) --------------------------------------------------------
int __cdecl sub_813542E(int a1, _DWORD *a2)
{
  return sub_8134DC8(a2, (_DWORD *)(a1 + 588));
}

//----- (0813544E) --------------------------------------------------------
void *__cdecl sub_813544E(int a1)
{
  return sub_8135A46((int *)&unk_89A23BC, a1);
}

//----- (0813546A) --------------------------------------------------------
int __cdecl sub_813546A(int a1, _DWORD *a2)
{
  return sub_8134DC8(a2, (_DWORD *)(a1 + 72));
}

//----- (08135488) --------------------------------------------------------
void *__cdecl sub_8135488(int a1)
{
  return sub_8135B24((int *)&unk_89A23C4, a1);
}

//----- (081354A4) --------------------------------------------------------
int __cdecl sub_81354A4(int a1, int a2)
{
  int result; // eax

  result = a2;
  *(_DWORD *)(a1 + 180) = a2;
  return result;
}

//----- (081354B6) --------------------------------------------------------
int __cdecl sub_81354B6(int a1, _DWORD *a2)
{
  return sub_8135084(a2, (_DWORD *)(a1 + 632));
}

//----- (081354D6) --------------------------------------------------------
int __cdecl sub_81354D6(int a1, _DWORD *a2)
{
  return sub_8135084(a2, (_DWORD *)(a1 + 644));
}

//----- (081354F6) --------------------------------------------------------
int __cdecl sub_81354F6(int a1, int a2)
{
  int result; // eax

  result = a2;
  *(_DWORD *)(a1 + 656) = a2;
  return result;
}

//----- (08135508) --------------------------------------------------------
int __cdecl sub_8135508(int a1, int a2)
{
  int result; // eax

  result = a2;
  *(_DWORD *)(a1 + 660) = a2;
  return result;
}

//----- (0813551A) --------------------------------------------------------
int __cdecl sub_813551A(int a1, int a2)
{
  int result; // eax

  result = a2;
  *(_DWORD *)(a1 + 664) = a2;
  return result;
}

//----- (0813552C) --------------------------------------------------------
int __cdecl sub_813552C(int a1, int a2)
{
  int result; // eax

  result = a2;
  *(_DWORD *)(a1 + 624) = a2;
  return result;
}

//----- (0813553E) --------------------------------------------------------
int __cdecl sub_813553E(int a1, _DWORD *a2)
{
  return sub_8135084(a2, (_DWORD *)(a1 + 588));
}

//----- (0813555E) --------------------------------------------------------
int __cdecl sub_813555E(int a1, _DWORD *a2)
{
  return sub_8135084(a2, (_DWORD *)(a1 + 600));
}

//----- (0813557E) --------------------------------------------------------
int __cdecl sub_813557E(int a1, _DWORD *a2)
{
  return sub_8135084(a2, (_DWORD *)(a1 + 612));
}

//----- (0813559E) --------------------------------------------------------
void *__cdecl sub_813559E(int a1)
{
  return sub_8135C02((int *)&unk_89A23CC, a1);
}

//----- (081355BA) --------------------------------------------------------
int __cdecl sub_81355BA(int a1)
{
  return *(_DWORD *)(*(_DWORD *)a1 + 8);
}

//----- (081355C8) --------------------------------------------------------
void *sub_81355C8()
{
  return Z_MallocInternal(0xCu);
}

//----- (081355DC) --------------------------------------------------------
void __cdecl sub_81355DC(void *ptr)
{
  Z_FreeInternal(ptr);
}

//----- (081355F0) --------------------------------------------------------
void *__cdecl sub_81355F0(int *a1, int a2)
{
  void *s; // ST14_4
  _DWORD *i; // [esp+10h] [ebp-8h]

  for ( i = (_DWORD *)a1[1]; i; i = (_DWORD *)i[8190] )
  {
    if ( i[8189] )
    {
      if ( i != (_DWORD *)a1[1] )
        sub_81284F6((int)a1, (int)i);
      break;
    }
  }
  if ( i )
    goto LABEL_11;
  i = sub_8121C8A(a1[1], *a1, a2);
  if ( i )
  {
    a1[1] = (int)i;
LABEL_11:
    s = (void *)i[8189];
    i[8189] = *(_DWORD *)i[8189];
    --i[8188];
    sub_80AA83E(s, 0, 0xFCu);
    return s;
  }
  return 0;
}

//----- (081356CE) --------------------------------------------------------
void *__cdecl sub_81356CE(int *a1, int a2)
{
  void *s; // ST14_4
  _DWORD *i; // [esp+10h] [ebp-8h]

  for ( i = (_DWORD *)a1[1]; i; i = (_DWORD *)i[8190] )
  {
    if ( i[8189] )
    {
      if ( i != (_DWORD *)a1[1] )
        sub_812853E((int)a1, (int)i);
      break;
    }
  }
  if ( i )
    goto LABEL_11;
  i = sub_8121C8A(a1[1], *a1, a2);
  if ( i )
  {
    a1[1] = (int)i;
LABEL_11:
    s = (void *)i[8189];
    i[8189] = *(_DWORD *)i[8189];
    --i[8188];
    sub_80AA83E(s, 0, 0x24Cu);
    return s;
  }
  return 0;
}

//----- (081357AC) --------------------------------------------------------
void *__cdecl sub_81357AC(int *a1, int a2)
{
  void *s; // ST14_4
  _DWORD *i; // [esp+10h] [ebp-8h]

  for ( i = (_DWORD *)a1[1]; i; i = (_DWORD *)i[8190] )
  {
    if ( i[8189] )
    {
      if ( i != (_DWORD *)a1[1] )
        sub_8128586((int)a1, (int)i);
      break;
    }
  }
  if ( i )
    goto LABEL_11;
  i = sub_8121C8A(a1[1], *a1, a2);
  if ( i )
  {
    a1[1] = (int)i;
LABEL_11:
    s = (void *)i[8189];
    i[8189] = *(_DWORD *)i[8189];
    --i[8188];
    sub_80AA83E(s, 0, 0x27Cu);
    return s;
  }
  return 0;
}

//----- (0813588A) --------------------------------------------------------
void *__cdecl sub_813588A(int *a1, int a2)
{
  void *s; // ST14_4
  _DWORD *i; // [esp+10h] [ebp-8h]

  for ( i = (_DWORD *)a1[1]; i; i = (_DWORD *)i[8190] )
  {
    if ( i[8189] )
    {
      if ( i != (_DWORD *)a1[1] )
        sub_81285CE((int)a1, (int)i);
      break;
    }
  }
  if ( i )
    goto LABEL_11;
  i = sub_8121C8A(a1[1], *a1, a2);
  if ( i )
  {
    a1[1] = (int)i;
LABEL_11:
    s = (void *)i[8189];
    i[8189] = *(_DWORD *)i[8189];
    --i[8188];
    sub_80AA83E(s, 0, 0x258u);
    return s;
  }
  return 0;
}

//----- (08135968) --------------------------------------------------------
void *__cdecl sub_8135968(int *a1, int a2)
{
  void *s; // ST14_4
  _DWORD *i; // [esp+10h] [ebp-8h]

  for ( i = (_DWORD *)a1[1]; i; i = (_DWORD *)i[8190] )
  {
    if ( i[8189] )
    {
      if ( i != (_DWORD *)a1[1] )
        sub_8128616((int)a1, (int)i);
      break;
    }
  }
  if ( i )
    goto LABEL_11;
  i = sub_8121C8A(a1[1], *a1, a2);
  if ( i )
  {
    a1[1] = (int)i;
LABEL_11:
    s = (void *)i[8189];
    i[8189] = *(_DWORD *)i[8189];
    --i[8188];
    sub_80AA83E(s, 0, 0x258u);
    return s;
  }
  return 0;
}

//----- (08135A46) --------------------------------------------------------
void *__cdecl sub_8135A46(int *a1, int a2)
{
  void *s; // ST14_4
  _DWORD *i; // [esp+10h] [ebp-8h]

  for ( i = (_DWORD *)a1[1]; i; i = (_DWORD *)i[8190] )
  {
    if ( i[8189] )
    {
      if ( i != (_DWORD *)a1[1] )
        sub_812865E((int)a1, (int)i);
      break;
    }
  }
  if ( i )
    goto LABEL_11;
  i = sub_8121C8A(a1[1], *a1, a2);
  if ( i )
  {
    a1[1] = (int)i;
LABEL_11:
    s = (void *)i[8189];
    i[8189] = *(_DWORD *)i[8189];
    --i[8188];
    sub_80AA83E(s, 0, 0x278u);
    return s;
  }
  return 0;
}

//----- (08135B24) --------------------------------------------------------
void *__cdecl sub_8135B24(int *a1, int a2)
{
  void *s; // ST14_4
  _DWORD *i; // [esp+10h] [ebp-8h]

  for ( i = (_DWORD *)a1[1]; i; i = (_DWORD *)i[8190] )
  {
    if ( i[8189] )
    {
      if ( i != (_DWORD *)a1[1] )
        sub_81286A6((int)a1, (int)i);
      break;
    }
  }
  if ( i )
    goto LABEL_11;
  i = sub_8121C8A(a1[1], *a1, a2);
  if ( i )
  {
    a1[1] = (int)i;
LABEL_11:
    s = (void *)i[8189];
    i[8189] = *(_DWORD *)i[8189];
    --i[8188];
    sub_80AA83E(s, 0, 0x278u);
    return s;
  }
  return 0;
}

//----- (08135C02) --------------------------------------------------------
void *__cdecl sub_8135C02(int *a1, int a2)
{
  void *s; // ST14_4
  _DWORD *i; // [esp+10h] [ebp-8h]

  for ( i = (_DWORD *)a1[1]; i; i = (_DWORD *)i[8190] )
  {
    if ( i[8189] )
    {
      if ( i != (_DWORD *)a1[1] )
        sub_81286EE((int)a1, (int)i);
      break;
    }
  }
  if ( i )
    goto LABEL_11;
  i = sub_8121C8A(a1[1], *a1, a2);
  if ( i )
  {
    a1[1] = (int)i;
LABEL_11:
    s = (void *)i[8189];
    i[8189] = *(_DWORD *)i[8189];
    --i[8188];
    sub_80AA83E(s, 0, 0x29Cu);
    return s;
  }
  return 0;
}

//----- (08135CE0) --------------------------------------------------------
unsigned int Language_UpdateCurrentAsian()
{
  unsigned int result; // eax

  result = *(_DWORD *)(loc_language + 8) - 8;
  g_currentAsian = result <= 4;
  return result;
}
// 8523140: using guessed type int loc_language;
// 89BD5A0: using guessed type int g_currentAsian;

//----- (08135D0C) --------------------------------------------------------
int sub_8135D0C()
{
  return *(_DWORD *)(loc_language + 8);
}
// 8523140: using guessed type int loc_language;

//----- (08135D1A) --------------------------------------------------------
unsigned int __usercall SEH_InitLanguage@<eax>(long double a1@<st0>)
{
  loc_language = (int)Dvar_RegisterInt(a1, "loc_language", 0, 0, 13, 4129);
  loc_forceEnglish = (int)Dvar_RegisterBool(a1, "loc_forceEnglish", 0, 4129);
  loc_translate = (int)Dvar_RegisterBool(a1, "loc_translate", 1, 4128);
  loc_warnings = (int)Dvar_RegisterBool(a1, "loc_warnings", 0, 4096);
  loc_warningsAsErrors = (int)Dvar_RegisterBool(a1, "loc_warningsAsErrors", 0, 4096);
  return Language_UpdateCurrentAsian();
}
// 8523140: using guessed type int loc_language;
// 8523144: using guessed type int loc_forceEnglish;
// 8523148: using guessed type int loc_translate;
// 852314C: using guessed type int loc_warnings;
// 8523150: using guessed type int loc_warningsAsErrors;

//----- (08135DDC) --------------------------------------------------------
unsigned int __usercall SEH_UpdateLanguageInfo@<eax>(long double a1@<st0>)
{
  unsigned int result; // eax
  int v2; // [esp+20h] [ebp-8h]
  int i; // [esp+24h] [ebp-4h]

  Dvar_RegisterInt(a1, *(char **)loc_language, 0, 0, 13, 4129);
  Dvar_RegisterBool(a1, *(char **)loc_forceEnglish, 0, 4129);
  Language_UpdateCurrentAsian();
  v2 = 0;
  for ( i = 0; i <= 13; ++i )
  {
    if ( FS_LanguageHasAssets(i) )
    {
      g_languages[2 * i] = 1;
      ++v2;
    }
    else
    {
      g_languages[2 * i] = 0;
    }
  }
  if ( v2 <= 0 )
    Com_Printf("^1ERROR: No languages available because no localized assets were found\n");
  result = SEH_StringEd_SetLanguageStrings(*(_DWORD *)(loc_language + 8));
  if ( !result )
  {
    for ( i = 0; i <= 13; ++i )
    {
      Dvar_SetInt(loc_language, (char *)i);
      Language_UpdateCurrentAsian();
      result = SEH_StringEd_SetLanguageStrings(i);
      if ( result )
        return result;
    }
    Dvar_SetInt(loc_language, 0);
    result = Language_UpdateCurrentAsian();
  }
  return result;
}
// 8168644: using guessed type int g_languages[];
// 8523140: using guessed type int loc_language;
// 8523144: using guessed type int loc_forceEnglish;

//----- (08135FAE) --------------------------------------------------------
int sub_8135FAE()
{
  return sub_8138336();
}

//----- (08135FBC) --------------------------------------------------------
void sub_8135FBC()
{
  sub_813839E();
}

//----- (08135FCA) --------------------------------------------------------
signed int __cdecl SEH_StringEd_SetLanguageStrings(signed int a1)
{
  char *v1; // eax
  char *v2; // eax
  char *v5; // [esp+14h] [ebp-4h]

  if ( !g_languages[2 * a1] )
    return 0;
  v5 = sub_81383EC(*(_BYTE *)(loc_forceEnglish + 8));
  if ( !v5 )
    return 1;
  if ( !*(_BYTE *)(fs_ignoreLocalized + 8) && *(_BYTE *)(loc_warnings + 8) )
  {
    if ( *(_BYTE *)(loc_warningsAsErrors + 8) )
    {
      v1 = sub_8136D72(a1);
      Com_Error(6, "Could not load localization strings for %s: %s", v1, v5);
    }
    v2 = sub_8136D72(a1);
    Com_Printf("^3WARNING: Could not load localization strings for %s: %s\n", v2, v5);
  }
  return 0;
}
// 8168644: using guessed type int g_languages[];
// 848B7E4: using guessed type int fs_ignoreLocalized;
// 8523144: using guessed type int loc_forceEnglish;
// 852314C: using guessed type int loc_warnings;
// 8523150: using guessed type int loc_warningsAsErrors;

//----- (0813608C) --------------------------------------------------------
int __cdecl sub_813608C(_BYTE *a1)
{
  if ( !loc_translate || !*(_BYTE *)(loc_translate + 8) )
    return (int)a1;
  if ( *a1 && (!*a1 || a1[1]) )
    return sub_813821E((int)a1);
  return (int)a1;
}
// 8523148: using guessed type int loc_translate;

//----- (081360E2) --------------------------------------------------------
char *__cdecl sub_81360E2(char *src)
{
  char *v2; // [esp+14h] [ebp-4h]

  v2 = (char *)sub_813608C(src);
  if ( !v2 )
  {
    if ( *(_BYTE *)(loc_warnings + 8) )
    {
      if ( *(_BYTE *)(loc_warningsAsErrors + 8) )
        Com_Error(6, "Could not translate exe string \"%s\"", src);
      Com_Printf("^3WARNING: Could not translate exe string \"%s\"\n", src);
      strcpy(byte_89BD5C0, "^1UNLOCALIZED(^7");
      sub_80B57C0(byte_89BD5C0, 1024, src);
      sub_80B57C0(byte_89BD5C0, 1024, "^1)^7");
    }
    else
    {
      I_strncpyz(byte_89BD5C0, src, 1024);
    }
    v2 = byte_89BD5C0;
  }
  return v2;
}
// 852314C: using guessed type int loc_warnings;
// 8523150: using guessed type int loc_warningsAsErrors;

//----- (081361BE) --------------------------------------------------------
int __cdecl sub_81361BE(char *dest, int a2, int a3, int a4)
{
  const char *src; // [esp+14h] [ebp-4h]

  src = (const char *)sub_813608C((_BYTE *)a2);
  if ( src )
    goto LABEL_16;
  if ( loc_warnings && *(_BYTE *)(loc_warnings + 8) )
  {
    if ( loc_warningsAsErrors && *(_BYTE *)(loc_warningsAsErrors + 8) && a4 != 1 )
      Com_Error(6, "Could not translate part of %s: \"%s\"", a3, a2);
    Com_Printf("^3WARNING: Could not translate part of %s: \"%s\"\n", a3, a2);
    src = va("^1UNLOCALIZED(^7%s^1)^7", a2);
  }
  else
  {
    src = va("%s", a2);
  }
  if ( a4 == 1 )
    return 0;
LABEL_16:
  strcpy(dest, src);
  return 1;
}
// 852314C: using guessed type int loc_warnings;
// 8523150: using guessed type int loc_warningsAsErrors;

//----- (081362A4) --------------------------------------------------------
int __cdecl sub_81362A4(char *a1, int a2, int a3)
{
  int v3; // edx
  int v6; // [esp+20h] [ebp-838h]
  signed int v7; // [esp+24h] [ebp-834h]
  signed int v8; // [esp+28h] [ebp-830h]
  int v9; // [esp+2Ch] [ebp-82Ch]
  signed int v10; // [esp+30h] [ebp-828h]
  signed int v11; // [esp+34h] [ebp-824h]
  char *v12; // [esp+38h] [ebp-820h]
  char *src; // [esp+3Ch] [ebp-81Ch]
  char dest; // [esp+40h] [ebp-818h]
  char s[2]; // [esp+440h] [ebp-418h]
  char v16[1022]; // [esp+442h] [ebp-416h]
  int v17; // [esp+840h] [ebp-18h]
  size_t v18; // [esp+844h] [ebp-14h]
  int v19; // [esp+848h] [ebp-10h]
  int i; // [esp+84Ch] [ebp-Ch]

  v3 = dword_89BD9C0 + 1;
  dword_89BD9C0 = (dword_89BD9C0 + 1) / 2;
  dword_89BD9C0 = v3 - 2 * dword_89BD9C0;
  memset((void *)((dword_89BD9C0 << 10) + 144431584), 0, 0x400u);
  v17 = (int)&unk_89BD9E0 + 1024 * dword_89BD9C0;
  v19 = 0;
  v11 = 1;
  v10 = 1;
  v9 = 0;
  v7 = 1;
  v8 = 0;
  src = a1;
  v12 = a1;
  while ( *src )
  {
    if ( *v12 && *v12 != 20 && *v12 != 21 && *v12 != 22 )
    {
      ++v12;
    }
    else
    {
      if ( v12 > src )
      {
        v18 = v12 - src;
        I_strncpyz(s, src, v12 - src + 1);
        if ( v11 )
        {
          if ( !sub_81361BE(s, (int)s, a2, a3) )
            return 0;
          v18 = strlen(s);
        }
        if ( v19 + v18 > 0x3FF )
        {
          if ( loc_warnings
            && *(_BYTE *)(loc_warnings + 8)
            && loc_warningsAsErrors
            && *(_BYTE *)(loc_warningsAsErrors + 8)
            && a3 != 1 )
          {
            Com_Error(1, "%s too long when translated: \"%s\"", a2, a1);
          }
          Com_Printf("%s too long when translated: \"%s\"\n", a2, a1);
        }
        for ( i = 0; i < (signed int)(v18 - 2); ++i )
        {
          if ( !strncmp(&s[i], "&&", 2u) && *(_WORD *)(_ctype_b + 2 * v16[i]) & 0x800 )
          {
            if ( v10 )
            {
              ++v9;
            }
            else
            {
              s[i] = 22;
              v8 = 1;
            }
          }
        }
        if ( v9 <= 0 || v19 <= 0 )
        {
          strcpy((char *)(v17 + v19), s);
        }
        else
        {
          for ( i = 0; i < v19 - 2; ++i )
          {
            if ( !strncmp((const char *)(v17 + i), "&&", 2u)
              && *(_WORD *)(_ctype_b + 2 * *(char *)(v17 + i + 2)) & 0x800 )
            {
              v6 = *(char *)(v17 + i + 2) - 48;
              if ( *(_BYTE *)(v17 + i + 2) == 48 )
                Com_Printf("%s cannot have &&0 as conversion format: \"%s\"\n", a2, a1);
              if ( v6 == v7 )
              {
                strcpy(&dest, (const char *)(v17 + i + 3));
                *(_BYTE *)(v17 + i) = 0;
                ++v7;
                break;
              }
            }
          }
          strcpy((char *)(v17 + i), s);
          strcpy((char *)(v17 + i + v18), &dest);
          v19 -= 3;
          --v9;
        }
        v19 += v18;
      }
      v10 = 1;
      if ( *v12 == 20 )
      {
        v11 = 1;
        ++v12;
      }
      else if ( *v12 == 21 )
      {
        v11 = 0;
        ++v12;
      }
      if ( *v12 == 22 )
      {
        v10 = 0;
        ++v12;
      }
      src = v12;
    }
  }
  if ( v8 )
  {
    for ( i = 0; i < v19; ++i )
    {
      if ( *(_BYTE *)(v17 + i) == 22 )
        *(_BYTE *)(v17 + i) = 37;
    }
  }
  return v17;
}
// 8185A64: using guessed type int _ctype_b;
// 852314C: using guessed type int loc_warnings;
// 8523150: using guessed type int loc_warningsAsErrors;
// 89BD9C0: using guessed type int dword_89BD9C0;
// 81362A4: using guessed type char s[2];
// 81362A4: using guessed type char var_416[1022];

//----- (081367A0) --------------------------------------------------------
_BOOL4 __cdecl sub_81367A0(__int16 a1)
{
  return (HIBYTE(a1) > 0xA0u && HIBYTE(a1) <= 0xC6u || HIBYTE(a1) > 0xC8u && HIBYTE(a1) <= 0xF9u)
      && ((unsigned __int8)a1 > 0x3Fu && (unsigned __int8)a1 <= 0x7Eu || (unsigned __int8)a1 > 0xA0u && (_BYTE)a1 != -1);
}

//----- (08136800) --------------------------------------------------------
_BOOL4 __cdecl sub_8136800(unsigned int a1)
{
  return a1 > 0xA13F && a1 <= 0xA153;
}

//----- (0813688A) --------------------------------------------------------
_BOOL4 __cdecl sub_813688A(unsigned __int8 a1, unsigned __int8 a2)
{
  return (a1 > 0x80u && a1 <= 0x9Fu || a1 > 0xDFu && a1 <= 0xEFu)
      && (a2 > 0x3Fu && a2 <= 0x7Eu || (a2 & 0x80u) != 0 && a2 <= 0xFCu);
}

//----- (081368E6) --------------------------------------------------------
_BOOL4 __cdecl sub_81368E6(unsigned int a1)
{
  return a1 > 0x813F && a1 <= 0x8151;
}

//----- (08136980) --------------------------------------------------------
signed int __cdecl sub_8136980(unsigned __int8 a1, unsigned __int8 a2)
{
  signed int v3; // [esp+0h] [ebp-8h]

  v3 = 0;
  if ( a1 > 0xA0u && a1 <= 0xF7u && a2 > 0xA0u && a2 != -1 )
    v3 = 1;
  return v3;
}

//----- (081369BE) --------------------------------------------------------
_BOOL4 __cdecl sub_81369BE(unsigned int a1)
{
  return a1 > 0xA1A0 && a1 <= 0xA1AD;
}

//----- (08136A38) --------------------------------------------------------
int __cdecl sub_8136A38(unsigned __int8 **a1, signed int *a2)
{
  signed int v3; // [esp+14h] [ebp-24h]
  int v4; // [esp+1Ch] [ebp-1Ch]
  unsigned int v5; // [esp+28h] [ebp-10h]
  int v6; // [esp+2Ch] [ebp-Ch]
  unsigned int v7; // [esp+2Ch] [ebp-Ch]
  unsigned int v8; // [esp+2Ch] [ebp-Ch]
  unsigned int v9; // [esp+2Ch] [ebp-Ch]
  int v10; // [esp+2Ch] [ebp-Ch]
  unsigned __int8 *v11; // [esp+30h] [ebp-8h]

  v11 = *a1;
  if ( !Language_IsAsian() )
    goto LABEL_25;
  v4 = sub_8135D0C();
  if ( v4 == 9 )
  {
    if ( !(unsigned __int8)sub_81367A0(v11[1] + (*v11 << 8)) )
      goto LABEL_25;
    v7 = v11[1] + (*v11 << 8);
    *a1 += 2;
    if ( a2 )
      *a2 = (unsigned __int8)sub_8136800(v7);
    v5 = v7;
  }
  else
  {
    if ( v4 <= 9 )
    {
      if ( v4 == 8 && (unsigned __int8)sub_8136E02(*v11, v11[1]) )
      {
        v6 = v11[1] + (*v11 << 8);
        *a1 += 2;
        if ( a2 )
          *a2 = 0;
        return v6;
      }
      goto LABEL_25;
    }
    if ( v4 != 10 )
    {
      if ( v4 == 11 && (unsigned __int8)sub_8136E88(v11[1] + (*v11 << 8)) )
      {
        v9 = v11[1] + (*v11 << 8);
        *a1 += 2;
        if ( a2 )
          *a2 = (unsigned __int8)sub_81369BE(v9) != 0;
        return v9;
      }
LABEL_25:
      v10 = *v11;
      ++*a1;
      if ( a2 )
      {
        v3 = 0;
        if ( v10 == 33 || v10 == 63 || v10 == 44 || v10 == 46 || v10 == 59 || v10 == 58 )
          v3 = 1;
        *a2 = v3;
      }
      return v10;
    }
    if ( !(unsigned __int8)sub_813688A(*v11, v11[1]) )
      goto LABEL_25;
    v8 = v11[1] + (*v11 << 8);
    *a1 += 2;
    if ( a2 )
      *a2 = (unsigned __int8)sub_81368E6(v8);
    v5 = v8;
  }
  return v5;
}

//----- (08136CB4) --------------------------------------------------------
int Language_IsAsian()
{
  return g_currentAsian;
}
// 89BD5A0: using guessed type int g_currentAsian;

//----- (08136CE6) --------------------------------------------------------
int __cdecl sub_8136CE6(_BYTE *a1)
{
  _BYTE *v3; // [esp+Ch] [ebp-Ch]
  int v4; // [esp+10h] [ebp-8h]
  int v5; // [esp+14h] [ebp-4h]

  if ( !a1 )
    return 0;
  v5 = 0;
  v3 = a1;
  while ( *v3 )
  {
    v4 = sub_8136A38(&v3, 0);
    if ( v4 == 94 && v3 && *v3 != 94 && *v3 > 47 && *v3 <= 57 )
    {
      ++v3;
    }
    else if ( v4 != 10 && v4 != 13 )
    {
      ++v5;
    }
  }
  return v5;
}

//----- (08136D72) --------------------------------------------------------
char *__cdecl sub_8136D72(signed int a1)
{
  char *v2; // [esp+0h] [ebp-4h]

  if ( a1 >= 0 && a1 <= 13 )
    v2 = (&off_8168640)[2 * a1];
  else
    v2 = off_8168640;
  return v2;
}
// 8168640: using guessed type char *off_8168640;

//----- (08136DA2) --------------------------------------------------------
signed int __cdecl sub_8136DA2(char *a1, signed int *a2)
{
  signed int i; // [esp+14h] [ebp-4h]

  for ( i = 0; i <= 13; ++i )
  {
    if ( !I_stricmp(a1, (&off_8168640)[2 * i]) )
    {
      *a2 = i;
      return 1;
    }
  }
  *a2 = 0;
  return 0;
}
// 8168640: using guessed type char *off_8168640;

//----- (08136E02) --------------------------------------------------------
signed int __cdecl sub_8136E02(unsigned __int8 a1, unsigned __int8 a2)
{
  signed int v3; // [esp+0h] [ebp-8h]

  v3 = 0;
  if ( a1 > 0xAFu && a1 <= 0xC8u && a2 > 0xA0u && a2 != -1 )
    v3 = 1;
  return v3;
}

//----- (08136E40) --------------------------------------------------------
int __cdecl sub_8136E40(__int16 a1)
{
  return (unsigned __int8)sub_8136E02(HIBYTE(a1), a1);
}

//----- (08136E64) --------------------------------------------------------
int __cdecl sub_8136E64(__int16 a1)
{
  return (unsigned __int8)sub_813688A(HIBYTE(a1), a1);
}

//----- (08136E88) --------------------------------------------------------
int __cdecl sub_8136E88(__int16 a1)
{
  return (unsigned __int8)sub_8136980(HIBYTE(a1), a1);
}

//----- (08136EAC) --------------------------------------------------------
int __cdecl sub_8136EAC(_BYTE *a1)
{
  int v2; // [esp+Ch] [ebp-Ch]
  int v3; // [esp+14h] [ebp-4h]

  if ( FS_ReadFile(a1, &v3) <= 0 )
    v2 = 0;
  else
    v2 = v3;
  return v2;
}

//----- (08136EE2) --------------------------------------------------------
void __cdecl sub_8136EE2(void *a1)
{
  FS_FreeFile(a1);
}

//----- (08136EF6) --------------------------------------------------------
void __cdecl sub_8136EF6(char *a1, int a2, int a3)
{
  signed int v3; // [esp+10h] [ebp-78h]
  signed int v4; // [esp+10h] [ebp-78h]
  char s; // [esp+20h] [ebp-68h]
  int v6; // [esp+6Ch] [ebp-1Ch]
  int i; // [esp+70h] [ebp-18h]
  int v8; // [esp+74h] [ebp-14h]
  void *v9; // [esp+78h] [ebp-10h]
  void *ptr; // [esp+7Ch] [ebp-Ch]

  v3 = 10;
  v9 = sub_809F7B2(a2, "/", 0, (int)&v6);
  for ( i = 0; i < v6; ++i )
  {
    if ( **((_BYTE **)v9 + i) )
    {
      if ( **((_BYTE **)v9 + i) != 46 )
      {
        sprintf(&s, "%s/%s", a2, *((_DWORD *)v9 + i), v3);
        sub_8136EF6(a1, (int)&s, a3);
      }
    }
  }
  v4 = 10;
  ptr = sub_809F7B2(a2, a1, 0, (int)&v8);
  for ( i = 0; i < v8; ++i )
  {
    sprintf(&s, "%s/%s", a2, *((_DWORD *)ptr + i), v4);
    std::string::operator+=(a3, &s);
    std::string::operator+=(a3, 59);
    ++dword_89BE1E0;
  }
  FS_FreeFileList(ptr);
  FS_FreeFileList(v9);
}
// 804A090: using guessed type int __cdecl std::string::operator+=(_DWORD, _DWORD);
// 804A380: using guessed type int __cdecl std::string::operator+=(_DWORD, _DWORD);
// 89BE1E0: using guessed type int dword_89BE1E0;

//----- (0813707E) --------------------------------------------------------
int __cdecl sub_813707E(int a1, int a2)
{
  dword_89BE1E0 = 0;
  std::string::operator=(a2, &unk_8159A3C);
  sub_8136EF6("str", a1, a2);
  return dword_89BE1E0;
}
// 8049C10: using guessed type int __cdecl std::string::operator=(_DWORD, _DWORD);
// 89BE1E0: using guessed type int dword_89BE1E0;

//----- (081370C4) --------------------------------------------------------
int __cdecl sub_81370C4(_DWORD *a1)
{
  sub_8138892((int)(a1 + 4));
  *a1 = 0;
  std::string::operator=(a1 + 1, &unk_8159A60);
  return std::string::operator=(a1 + 2, &unk_8159A60);
}
// 8049C10: using guessed type int __cdecl std::string::operator=(_DWORD, _DWORD);

//----- (08137110) --------------------------------------------------------
char *__cdecl sub_8137110(int a1, char *src)
{
  char *v3; // [esp+18h] [ebp-10h]
  char *v4; // [esp+24h] [ebp-4h]

  I_strncpyz(byte_89BE220, src, 64);
  v4 = sub_8138700(byte_89BE220, 92);
  v3 = sub_8138700(byte_89BE220, 47);
  if ( v3 < v4 )
    v3 = v4;
  if ( v3 )
    *v3 = 0;
  return byte_89BE220;
}

//----- (0813718C) --------------------------------------------------------
char *__cdecl sub_813718C(int a1, char *src)
{
  char *v3; // [esp+Ch] [ebp-Ch]
  char *v4; // [esp+10h] [ebp-8h]
  char *v5; // [esp+14h] [ebp-4h]

  strcpy(byte_89BE260, src);
  v5 = sub_8138700(byte_89BE260, 46);
  v4 = sub_8138700(byte_89BE260, 92);
  v3 = sub_8138700(byte_89BE260, 47);
  if ( v5 && (!v4 || v4 && v5 > v4) && (!v3 || v3 && v5 > v3) )
    *v5 = 0;
  return byte_89BE260;
}

//----- (0813722A) --------------------------------------------------------
char *__cdecl sub_813722A(int a1, char *a2)
{
  char *src; // [esp+14h] [ebp-4h]

  src = a2;
  while ( *a2 )
  {
    if ( *a2 == 47 || *a2 == 92 )
      src = a2 + 1;
    ++a2;
  }
  strcpy(byte_89BE2A0, src);
  return byte_89BE2A0;
}

//----- (0813727A) --------------------------------------------------------
char *__cdecl sub_813727A(int a1, char *src)
{
  char *v2; // eax

  v2 = sub_8137110(a1, src);
  return sub_813722A(a1, v2);
}

//----- (081372A4) --------------------------------------------------------
int __cdecl sub_81372A4(int a1, char *src)
{
  char *v2; // eax
  char *v3; // eax
  char dest; // [esp+10h] [ebp-48h]

  v2 = sub_813718C(a1, src);
  v3 = sub_813722A(a1, v2);
  strcpy(&dest, v3);
  sub_80B577E(&dest);
  return std::string::operator=(a1 + 12, &dest);
}
// 8049C10: using guessed type int __cdecl std::string::operator=(_DWORD, _DWORD);

//----- (081372FC) --------------------------------------------------------
int __cdecl sub_81372FC(int a1, char *s, int a3)
{
  size_t v3; // eax

  v3 = strlen(s);
  if ( strncasecmp(s, *(const char **)a3, v3) )
    return 0;
  for ( *(_DWORD *)a3 += strlen(s); **(_BYTE **)a3 == 9 || **(_BYTE **)a3 == 32; ++*(_DWORD *)a3 )
    ;
  return 1;
}

//----- (08137378) --------------------------------------------------------
int __cdecl sub_8137378(int a1, char *haystack)
{
  int v3; // [esp+0h] [ebp-48h]
  int v5; // [esp+1Ch] [ebp-2Ch]
  char s[28]; // [esp+20h] [ebp-28h]
  char *i; // [esp+3Ch] [ebp-Ch]

  memset(s, 0, 9u);
  for ( i = strstr(haystack, "&&"); i; i = strstr(i, "&&") )
  {
    i += 2;
    v3 = *i;
    if ( !isdigit(v3) )
      return 0;
    v5 = *i - 48;
    if ( s[--v5] )
      return 0;
    s[v5] = 1;
    ++i;
  }
  return 1;
}
// 8137378: using guessed type char s[28];

//----- (08137430) --------------------------------------------------------
std::string *__stdcall sub_8137430(std::string *a1, int a2, int a3)
{
  int v4; // [esp+20h] [ebp-8h]

  std::string::string(a1);
  std::string::operator=(a1, a3);
  while ( 1 )
  {
    v4 = std::string::find(a1, "\\n", 0);
    if ( v4 == -1 )
      break;
    *(_BYTE *)std::string::operator[](a1, v4) = 10;
    std::string::erase(a1, v4 + 1, 1u);
  }
  return a1;
}
// 8049E90: using guessed type int __cdecl std::string::operator=(_DWORD, _DWORD);
// 8049EE0: using guessed type int __cdecl std::string::operator[](_DWORD, _DWORD);

//----- (081374D8) --------------------------------------------------------
char *__cdecl sub_81374D8(int a1, char *a2)
{
  char *result; // eax
  char *j; // [esp+14h] [ebp-14h]
  int v4; // [esp+18h] [ebp-10h]
  int i; // [esp+1Ch] [ebp-Ch]
  char *v6; // [esp+20h] [ebp-8h]
  char *s; // [esp+24h] [ebp-4h]

  s = a2;
  for ( i = 0; ; i = v4 )
  {
    result = sub_813871A(s, "//");
    v6 = result;
    if ( !result )
      break;
    v4 = i;
    for ( j = 0; (signed int)j < v6 - s; ++j )
    {
      if ( j[(_DWORD)s] == 34 )
        ++v4;
    }
    if ( ((unsigned __int8)v4 ^ 1) & 1 )
    {
      *v6 = 0;
      result = s;
      if ( *s )
      {
        result = (char *)(strlen(s) - 1);
        for ( j = result; (signed int)j >= 0; --j )
        {
          result = (char *)isspace(j[(_DWORD)s]);
          if ( !result )
            break;
          j[(_DWORD)s] = 0;
          result = (char *)&j;
        }
      }
      return result;
    }
    s = v6 + 1;
  }
  return result;
}

//----- (081375AC) --------------------------------------------------------
int __cdecl sub_81375AC(int a1, int a2, char *dest)
{
  size_t v3; // ST18_4
  signed int n; // [esp+18h] [ebp-10h]
  char *v7; // [esp+1Ch] [ebp-Ch]

  if ( !**(_BYTE **)a2 )
    return 0;
  v7 = strchr(*(const char **)a2, 10);
  if ( v7 )
  {
    v3 = (size_t)&v7[-*(_DWORD *)a2];
    strncpy(dest, *(const char **)a2, (size_t)&v7[-*(_DWORD *)a2]);
    dest[v3] = 0;
    for ( *(_DWORD *)a2 += v3; **(_BYTE **)a2 && strchr("\r\n", **(char **)a2); ++*(_DWORD *)a2 )
      ;
  }
  else
  {
    strcpy(dest, *(const char **)a2);
    *(_DWORD *)a2 += strlen(*(const char **)a2);
  }
  if ( *dest )
  {
    for ( n = strlen(dest) - 1; n >= 0 && isspace(dest[n]); --n )
      dest[n] = 0;
    sub_81374D8(a1, dest);
  }
  return 1;
}

//----- (081376E8) --------------------------------------------------------
std::string *__stdcall sub_81376E8(std::string *a1, int a2, _BYTE *a3)
{
  int v3; // ST20_4
  const char *v4; // eax
  int v5; // ST1C_4
  const char *v6; // eax
  const char *v7; // eax
  size_t v8; // eax
  int v9; // ST18_4
  const char *v10; // eax
  const char *v11; // eax
  size_t v12; // eax

  std::string::string(a1);
  std::string::operator=(a1, &unk_8159A60);
  while ( *a3 == 32 || *a3 == 9 )
    ++a3;
  if ( *a3 == 34 )
    ++a3;
  std::string::operator=(a1, a3);
  if ( *a3 )
  {
    while ( 1 )
    {
      v3 = std::string::c_str(a1);
      v4 = (const char *)std::string::c_str(a1);
      if ( *(_BYTE *)(strlen(v4) + v3 - 1) != 32 )
      {
        v5 = std::string::c_str(a1);
        v6 = (const char *)std::string::c_str(a1);
        if ( *(_BYTE *)(strlen(v6) + v5 - 1) != 9 )
          break;
      }
      v7 = (const char *)std::string::c_str(a1);
      v8 = strlen(v7);
      std::string::erase(a1, v8 - 1, 1u);
    }
    v9 = std::string::c_str(a1);
    v10 = (const char *)std::string::c_str(a1);
    if ( *(_BYTE *)(strlen(v10) + v9 - 1) == 34 )
    {
      v11 = (const char *)std::string::c_str(a1);
      v12 = strlen(v11);
      std::string::erase(a1, v12 - 1, 1u);
    }
  }
  return a1;
}
// 8049C10: using guessed type int __cdecl std::string::operator=(_DWORD, _DWORD);

//----- (0813785C) --------------------------------------------------------
char *__cdecl sub_813785C(int a1, char *s2, int a3)
{
  const char *v3; // eax
  int v4; // eax
  size_t v5; // eax
  char *v6; // eax
  int v7; // eax
  char *v8; // eax
  _BOOL4 v10; // [esp+1Ch] [ebp-45Ch]
  char v11; // [esp+20h] [ebp-458h]
  size_t n; // [esp+3Ch] [ebp-43Ch]
  char dest; // [esp+40h] [ebp-438h]
  char *i; // [esp+448h] [ebp-30h]
  char v15[4]; // [esp+44Ch] [ebp-2Ch]
  char v16; // [esp+450h] [ebp-28h]
  char *v17; // [esp+468h] [ebp-10h]
  char v18; // [esp+46Fh] [ebp-9h]

  v18 = a3;
  v17 = 0;
  if ( s2 )
  {
    if ( sub_81372FC(a1, "VERSION", (int)&s2) )
    {
      sub_81376E8((std::string *)&v16, a1, s2);
      v3 = (const char *)std::string::c_str((std::string *)&v16);
      *(_DWORD *)v15 = atoi(v3);
      if ( *(_DWORD *)v15 != 1 )
        v17 = va("Unexpected version number %d, expecting %d!\n", *(_DWORD *)v15, 1);
      std::string::~string((std::string *)&v16);
    }
    else if ( !sub_81372FC(a1, "CONFIG", (int)&s2)
           && !sub_81372FC(a1, "FILENOTES", (int)&s2)
           && !sub_81372FC(a1, "NOTES", (int)&s2)
           && !sub_81372FC(a1, "FLAGS", (int)&s2) )
    {
      if ( sub_81372FC(a1, "REFERENCE", (int)&s2) )
      {
        sub_81376E8((std::string *)&v16, a1, s2);
        v4 = std::string::c_str((std::string *)&v16);
        sub_8137CE8(a1, v4);
        std::string::~string((std::string *)&v16);
      }
      else if ( sub_81372FC(a1, "ENDMARKER", (int)&s2) )
      {
        *(_DWORD *)a1 = 1;
      }
      else if ( !strncasecmp("LANG_", s2, 5u) )
      {
        *(_DWORD *)v15 = sub_8137CD2(a1);
        if ( **(_BYTE **)v15 )
        {
          s2 += 5;
          for ( i = s2; *i && *i != 32 && *i != 9; ++i )
            ;
          memset(&dest, 0, 0x400u);
          n = i - s2;
          if ( (unsigned int)(i - s2) > 0x3FF )
            n = 1023;
          strncpy(&dest, s2, n);
          v5 = strlen(&dest);
          s2 += v5;
          sub_81376E8((std::string *)&v11, a1, s2);
          sub_8137430((std::string *)&v16, a1, (int)&v11);
          std::string::~string((std::string *)&v11);
          v6 = (char *)std::string::c_str((std::string *)&v16);
          if ( !(unsigned __int8)sub_8137378(a1, v6) )
          {
            v7 = std::string::c_str((std::string *)&v16);
            v17 = va("Illegal string format \"%s\"\n", v7);
          }
          v10 = strcasecmp(&dest, "english") == 0;
          if ( !v17 && (v10 || !v18) )
          {
            v8 = (char *)std::string::c_str((std::string *)&v16);
            sub_8137EEC(a1, *(int *)v15, v8, v10);
          }
          std::string::~string((std::string *)&v16);
        }
        else
        {
          v17 = "Error parsing file: Unexpected \"LANG_\"\n";
        }
      }
      else
      {
        v17 = va("Unknown keyword at linestart: \"%s\"\n", s2);
      }
    }
  }
  return v17;
}

//----- (08137CD2) --------------------------------------------------------
int __cdecl sub_8137CD2(int a1)
{
  return std::string::c_str((std::string *)(a1 + 4));
}

//----- (08137CE8) --------------------------------------------------------
int __cdecl sub_8137CE8(int a1, int a2)
{
  int v2; // eax
  char *v3; // eax
  int v4; // eax
  char *v5; // eax
  int v6; // eax
  char v8; // [esp+20h] [ebp-58h]
  char v9; // [esp+30h] [ebp-48h]
  char v10; // [esp+40h] [ebp-38h]
  char v11; // [esp+50h] [ebp-28h]
  int v12[5]; // [esp+60h] [ebp-18h]

  std::allocator<char>::allocator(&v10);
  v2 = std::string::c_str((std::string *)(a1 + 12));
  v3 = va("%s_%s", v2, a2);
  std::string::string(&v11, v3, &v10);
  sub_81384A6(v12, a1 + 16, (std::string *)&v11);
  std::string::~string((std::string *)&v11);
  std::allocator<char>::~allocator(&v10);
  sub_81384D2(&v10, a1 + 16);
  if ( (unsigned __int8)sub_8138490(v12, &v10) )
  {
    std::string::string((std::string *)&v11);
    std::allocator<char>::allocator(&v8);
    v4 = std::string::c_str((std::string *)(a1 + 12));
    v5 = va("%s_%s", v4, a2);
    std::string::string(&v9, v5, &v8);
    v6 = sub_81384F8(a1 + 16, (std::string *)&v9);
    std::string::operator=(v6, &v11);
    std::string::~string((std::string *)&v9);
    std::allocator<char>::~allocator(&v8);
    std::string::~string((std::string *)&v11);
  }
  return std::string::operator=(a1 + 4, a2);
}
// 8049C10: using guessed type int __cdecl std::string::operator=(_DWORD, _DWORD);
// 8049C80: using guessed type int __cdecl std::allocator<char>::allocator(_DWORD);
// 8049D80: using guessed type int __cdecl std::string::string(_DWORD, _DWORD, _DWORD);
// 8049E90: using guessed type int __cdecl std::string::operator=(_DWORD, _DWORD);
// 804A1B0: using guessed type int __cdecl std::allocator<char>::~allocator(_DWORD);

//----- (08137EEC) --------------------------------------------------------
int __cdecl sub_8137EEC(int a1, int a2, char *s1, int a4)
{
  int v4; // eax
  char *v5; // eax
  int result; // eax
  int v7; // [esp+1Ch] [ebp-3Ch]
  char v8; // [esp+20h] [ebp-38h]
  char v9; // [esp+30h] [ebp-28h]
  int v10[5]; // [esp+40h] [ebp-18h]

  std::allocator<char>::allocator(&v8);
  v4 = std::string::c_str((std::string *)(a1 + 12));
  v5 = va("%s_%s", v4, a2);
  std::string::string(&v9, v5, &v8);
  sub_81384A6(v10, a1 + 16, (std::string *)&v9);
  std::string::~string((std::string *)&v9);
  std::allocator<char>::~allocator(&v8);
  v7 = sub_8138676(v10) + 4;
  if ( a4 )
  {
    std::string::operator=(v7, s1);
    result = std::string::operator=(a1 + 8, s1);
  }
  else if ( !strcasecmp(s1, "#same") )
  {
    result = std::string::operator=(v7, a1 + 8);
  }
  else
  {
    result = std::string::operator=(v7, s1);
  }
  return result;
}
// 8049C10: using guessed type int __cdecl std::string::operator=(_DWORD, _DWORD);
// 8049C80: using guessed type int __cdecl std::allocator<char>::allocator(_DWORD);
// 8049D80: using guessed type int __cdecl std::string::string(_DWORD, _DWORD, _DWORD);
// 8049E90: using guessed type int __cdecl std::string::operator=(_DWORD, _DWORD);
// 804A1B0: using guessed type int __cdecl std::allocator<char>::~allocator(_DWORD);

//----- (0813803A) --------------------------------------------------------
char *__cdecl sub_813803A(std::string *a1)
{
  const char *v1; // eax
  char *v4; // [esp+14h] [ebp-4h]

  if ( !*(_BYTE *)std::string::c_str(a1) )
    return 0;
  v1 = (const char *)std::string::c_str(a1);
  strncpy(byte_89BE2E0, v1, 0x3Fu);
  byte_89BE31F = 0;
  v4 = sub_81386E6(byte_89BE2E0, 59);
  if ( v4 )
  {
    *v4 = 0;
    std::string::erase(a1, 0, (unsigned int)&v4[1 - (_DWORD)byte_89BE2E0]);
  }
  else
  {
    std::string::erase(a1, 0, 0xFFFFFFFF);
  }
  return byte_89BE2E0;
}
// 89BE31F: using guessed type char byte_89BE31F;

//----- (081380F6) --------------------------------------------------------
char *__cdecl sub_81380F6(char *src, int a2)
{
  int v4; // [esp+14h] [ebp-4024h]
  void *v5; // [esp+18h] [ebp-4020h]
  char *v6; // [esp+1Ch] [ebp-401Ch]
  char dest; // [esp+20h] [ebp-4018h]
  unsigned __int8 v8; // [esp+402Fh] [ebp-9h]

  v8 = a2;
  v6 = 0;
  v5 = (void *)sub_8136EAC(src);
  if ( !v5 )
    return va("Unable to load \"%s\"!", src);
  v4 = (int)v5;
  sub_81372A4(dword_89BE200, src);
  while ( !v6 && sub_81375AC(dword_89BE200, (int)&v4, &dest) )
  {
    if ( dest )
      v6 = sub_813785C(dword_89BE200, &dest, v8);
  }
  sub_8136EE2(v5);
  if ( !v6 && !sub_8138888(dword_89BE200) )
    v6 = va("Truncated file, failed to find \"%s\" at file end!", "ENDMARKER");
  return v6;
}

//----- (0813821E) --------------------------------------------------------
int __cdecl sub_813821E(int a1)
{
  std::string *v1; // ST1C_4
  char v4; // [esp+20h] [ebp-38h]
  char v5; // [esp+30h] [ebp-28h]
  int v6[5]; // [esp+40h] [ebp-18h]

  std::allocator<char>::allocator(&v4);
  std::string::string(&v5, a1, &v4);
  sub_81384A6(v6, dword_89BE200 + 16, (std::string *)&v5);
  std::string::~string((std::string *)&v5);
  std::allocator<char>::~allocator(&v4);
  sub_81384D2(&v4, dword_89BE200 + 16);
  if ( !(unsigned __int8)sub_813868A(v6, &v4) )
    return 0;
  v1 = (std::string *)(sub_8138676(v6) + 4);
  return std::string::c_str(v1);
}
// 8049C80: using guessed type int __cdecl std::allocator<char>::allocator(_DWORD);
// 8049D80: using guessed type int __cdecl std::string::string(_DWORD, _DWORD, _DWORD);
// 804A1B0: using guessed type int __cdecl std::allocator<char>::~allocator(_DWORD);

//----- (08138320) --------------------------------------------------------
int sub_8138320()
{
  return sub_81370C4((_DWORD *)dword_89BE200);
}

//----- (08138336) --------------------------------------------------------
int sub_8138336()
{
  _DWORD *ptr; // ST24_4

  ptr = sub_8138860();
  sub_8138734((int)ptr);
  dword_89BE200 = (int)ptr;
  return sub_81370C4(ptr);
}

//----- (0813839E) --------------------------------------------------------
void sub_813839E()
{
  void *ptr; // [esp+4h] [ebp-4h]

  if ( dword_89BE200 )
  {
    sub_81370C4((_DWORD *)dword_89BE200);
    ptr = (void *)dword_89BE200;
    if ( dword_89BE200 )
    {
      sub_81387C6(dword_89BE200);
      sub_8138874(ptr);
    }
    dword_89BE200 = 0;
  }
}

//----- (081383EC) --------------------------------------------------------
char *__cdecl sub_81383EC(unsigned __int8 a1)
{
  char *v1; // ebx
  char *src; // [esp+1Ch] [ebp-2Ch]
  char v4; // [esp+20h] [ebp-28h]
  char *v5; // [esp+38h] [ebp-10h]
  unsigned __int8 v6; // [esp+3Fh] [ebp-9h]

  v6 = a1;
  v5 = 0;
  std::string::string((std::string *)&v4);
  sub_8138320();
  sub_813707E((int)"localizedstrings", (int)&v4);
  while ( 1 )
  {
    src = sub_813803A((std::string *)&v4);
    if ( !src || v5 )
      break;
    v5 = sub_81380F6(src, v6);
  }
  v1 = v5;
  std::string::~string((std::string *)&v4);
  return v1;
}

//----- (08138490) --------------------------------------------------------
_BOOL4 __cdecl sub_8138490(_DWORD *a1, _DWORD *a2)
{
  return *a1 == *a2;
}

//----- (081384A6) --------------------------------------------------------
int *__userpurge sub_81384A6@<eax>(int *a1, int a2, std::string *a3)
{
  sub_8138BC4(a1, a2, a3);
  return a1;
}

//----- (081384D2) --------------------------------------------------------
_DWORD *__userpurge sub_81384D2@<eax>(_DWORD *a1, int a2)
{
  sub_8138B9E(a1, a2);
  return a1;
}

//----- (081384F8) --------------------------------------------------------
int __cdecl sub_81384F8(int a1, std::string *a2)
{
  std::string *v2; // ebx
  char v4; // [esp+1Fh] [ebp-79h]
  char v5; // [esp+20h] [ebp-78h]
  char v6; // [esp+30h] [ebp-68h]
  char v7; // [esp+40h] [ebp-58h]
  int v8; // [esp+50h] [ebp-48h]
  int v9; // [esp+6Fh] [ebp-29h]
  int v10; // [esp+80h] [ebp-18h]

  sub_8138CD6(&v10, a1, a2);
  v4 = 0;
  sub_81384D2((int *)((char *)&v9 + 1), a1);
  if ( (unsigned __int8)sub_8138490(&v10, (int *)((char *)&v9 + 1))
    || (v2 = (std::string *)sub_8138D96(&v10), sub_8138DA4((int)&v9), (unsigned __int8)sub_8138B62((int)&v9, a2, v2)) )
  {
    v4 = 1;
  }
  if ( v4 )
  {
    std::string::string((std::string *)&v6);
    sub_8138DD4((std::string *)&v7, a2, (std::string *)&v6);
    sub_81389BC((int *)&v5, &v10);
    sub_81386A0(&v8, a1, (int *)&v5, (std::string *)&v7);
    v10 = v8;
    sub_8138926((std::string *)&v7);
    std::string::~string((std::string *)&v6);
  }
  return sub_8138D96(&v10) + 4;
}

//----- (08138676) --------------------------------------------------------
int __cdecl sub_8138676(_DWORD *a1)
{
  return sub_8138D96(a1);
}

//----- (0813868A) --------------------------------------------------------
_BOOL4 __cdecl sub_813868A(_DWORD *a1, _DWORD *a2)
{
  return *a1 != *a2;
}

//----- (081386A0) --------------------------------------------------------
int *__userpurge sub_81386A0@<eax>(int *a1, int a2, int *a3, std::string *a4)
{
  char v5; // [esp+10h] [ebp-18h]

  sub_81389BC((int *)&v5, a3);
  sub_8138E2A(a1, a2, (int *)&v5, a4);
  return a1;
}

//----- (081386E6) --------------------------------------------------------
char *__cdecl sub_81386E6(char *s, int c)
{
  return strchr(s, c);
}

//----- (08138700) --------------------------------------------------------
char *__cdecl sub_8138700(char *s, int c)
{
  return strrchr(s, c);
}

//----- (0813871A) --------------------------------------------------------
char *__cdecl sub_813871A(char *haystack, char *needle)
{
  return strstr(haystack, needle);
}

//----- (08138734) --------------------------------------------------------
int __cdecl sub_8138734(int a1)
{
  std::string::string((std::string *)(a1 + 4));
  std::string::string((std::string *)(a1 + 8));
  std::string::string((std::string *)(a1 + 12));
  return sub_81389DA(a1 + 16);
}

//----- (081387C6) --------------------------------------------------------
int __cdecl sub_81387C6(int a1)
{
  sub_81393A2(a1 + 16);
  std::string::~string((std::string *)(a1 + 12));
  std::string::~string((std::string *)(a1 + 8));
  return std::string::~string((std::string *)(a1 + 4));
}

//----- (08138860) --------------------------------------------------------
void *sub_8138860()
{
  return Z_MallocInternal(0x20u);
}

//----- (08138874) --------------------------------------------------------
void __cdecl sub_8138874(void *ptr)
{
  Z_FreeInternal(ptr);
}

//----- (08138888) --------------------------------------------------------
int __cdecl sub_8138888(int a1)
{
  return *(_DWORD *)a1;
}

//----- (08138892) --------------------------------------------------------
int __cdecl sub_8138892(int a1)
{
  return sub_81388A6(a1);
}

//----- (081388A6) --------------------------------------------------------
int __cdecl sub_81388A6(int a1)
{
  int result; // eax
  void **v2; // eax

  result = a1;
  if ( *(_DWORD *)(a1 + 8) )
  {
    v2 = (void **)sub_8138918(a1);
    sub_8138948(a1, *v2);
    *(_DWORD *)sub_81389A0(a1) = *(_DWORD *)(a1 + 4);
    *(_DWORD *)sub_8138918(a1) = 0;
    *(_DWORD *)sub_81389AE(a1) = *(_DWORD *)(a1 + 4);
    result = a1;
    *(_DWORD *)(a1 + 8) = 0;
  }
  return result;
}

//----- (08138918) --------------------------------------------------------
int __cdecl sub_8138918(int a1)
{
  return *(_DWORD *)(a1 + 4) + 4;
}

//----- (08138926) --------------------------------------------------------
int __cdecl sub_8138926(std::string *a1)
{
  std::string::~string((std::string *)((char *)a1 + 4));
  return std::string::~string(a1);
}

//----- (08138948) --------------------------------------------------------
void __cdecl sub_8138948(int a1, void *ptr)
{
  void **v2; // eax
  void *v3; // ST14_4

  while ( ptr )
  {
    v2 = (void **)sub_81393B6((int)ptr);
    sub_8138948(a1, *v2);
    v3 = *(void **)sub_8138B2E((int)ptr);
    sub_8138B3A(a1, ptr);
    ptr = v3;
  }
}

//----- (081389A0) --------------------------------------------------------
int __cdecl sub_81389A0(int a1)
{
  return *(_DWORD *)(a1 + 4) + 8;
}

//----- (081389AE) --------------------------------------------------------
int __cdecl sub_81389AE(int a1)
{
  return *(_DWORD *)(a1 + 4) + 12;
}

//----- (081389BC) --------------------------------------------------------
int __cdecl sub_81389BC(int *a1, int *a2)
{
  int result; // eax

  sub_81392FE();
  result = *a2;
  *a1 = *a2;
  return result;
}

//----- (081389DA) --------------------------------------------------------
int __cdecl sub_81389DA(int a1)
{
  sub_8138A06();
  return sub_8138A0C(a1);
}

//----- (08138A06) --------------------------------------------------------
void sub_8138A06()
{
  ;
}

//----- (08138A0C) --------------------------------------------------------
int __cdecl sub_8138A0C(int a1)
{
  sub_8138A3C(a1);
  *(_DWORD *)(a1 + 8) = 0;
  return sub_8138ACE(a1);
}

//----- (08138A3C) --------------------------------------------------------
void *__cdecl sub_8138A3C(int a1)
{
  void *result; // eax

  sub_8138A6C(a1);
  result = sub_8138A96(a1);
  *(_DWORD *)(a1 + 4) = result;
  return result;
}

//----- (08138A6C) --------------------------------------------------------
int __cdecl sub_8138A6C(int a1)
{
  int result; // eax

  sub_8138A90();
  result = a1;
  *(_DWORD *)(a1 + 4) = 0;
  return result;
}

//----- (08138A90) --------------------------------------------------------
void sub_8138A90()
{
  ;
}

//----- (08138A96) --------------------------------------------------------
void *__cdecl sub_8138A96(int a1)
{
  return sub_8138AB2(a1, 1);
}

//----- (08138AB2) --------------------------------------------------------
void *__cdecl sub_8138AB2(int a1, int a2)
{
  return malloc(24 * a2);
}

//----- (08138ACE) --------------------------------------------------------
int __cdecl sub_8138ACE(int a1)
{
  _DWORD *v1; // edx
  int result; // eax

  *(_DWORD *)sub_8138B26(*(_DWORD *)(a1 + 4)) = 0;
  *(_DWORD *)sub_8138918(a1) = 0;
  *(_DWORD *)sub_81389A0(a1) = *(_DWORD *)(a1 + 4);
  v1 = (_DWORD *)sub_81389AE(a1);
  result = *(_DWORD *)(a1 + 4);
  *v1 = result;
  return result;
}

//----- (08138B26) --------------------------------------------------------
int __cdecl sub_8138B26(int a1)
{
  return a1;
}

//----- (08138B2E) --------------------------------------------------------
int __cdecl sub_8138B2E(int a1)
{
  return a1 + 8;
}

//----- (08138B3A) --------------------------------------------------------
void __cdecl sub_8138B3A(int a1, void *ptr)
{
  sub_813943C((std::string *)((char *)ptr + 16));
  sub_81393C2(a1, ptr);
}

//----- (08138B62) --------------------------------------------------------
int __cdecl sub_8138B62(int a1, std::string *a2, std::string *a3)
{
  return (unsigned __int8)sub_8138B80(a2, a3);
}

//----- (08138B80) --------------------------------------------------------
int __cdecl sub_8138B80(std::string *a1, std::string *a2)
{
  return std::string::compare(a1, a2) >> 31;
}

//----- (08138B9E) --------------------------------------------------------
_DWORD *__userpurge sub_8138B9E@<eax>(_DWORD *a1, int a2)
{
  sub_8139486(a1, *(_DWORD *)(a2 + 4));
  return a1;
}

//----- (08138BC4) --------------------------------------------------------
int *__userpurge sub_8138BC4@<eax>(int *a1, int a2, std::string *a3)
{
  std::string *v3; // eax
  std::string *v4; // eax
  char v6; // [esp+10h] [ebp-38h]
  int v7; // [esp+20h] [ebp-28h]
  int v8; // [esp+38h] [ebp-10h]
  int v9; // [esp+3Ch] [ebp-Ch]

  v9 = *(_DWORD *)(a2 + 4);
  v8 = *(_DWORD *)sub_8138918(a2);
  while ( v8 )
  {
    v3 = (std::string *)sub_8139450(v8);
    if ( (unsigned __int8)sub_8138B62(a2 + 12, v3, a3) )
    {
      v8 = *(_DWORD *)sub_81393B6(v8);
    }
    else
    {
      v9 = v8;
      v8 = *(_DWORD *)sub_8138B2E(v8);
    }
  }
  sub_8139486(&v7, v9);
  sub_8138B9E(&v6, a2);
  if ( (unsigned __int8)sub_8138490(&v7, &v6)
    || (v4 = (std::string *)sub_81394A2(v7), (unsigned __int8)sub_8138B62(a2 + 12, a3, v4)) )
  {
    sub_8138B9E(a1, a2);
  }
  else
  {
    sub_81389BC(a1, &v7);
  }
  return a1;
}

//----- (08138CD6) --------------------------------------------------------
_DWORD *__userpurge sub_8138CD6@<eax>(_DWORD *a1, int a2, std::string *a3)
{
  sub_8138D02(a1, a2, a3);
  return a1;
}

//----- (08138D02) --------------------------------------------------------
_DWORD *__userpurge sub_8138D02@<eax>(_DWORD *a1, int a2, std::string *a3)
{
  std::string *v3; // eax
  int v5; // [esp+10h] [ebp-8h]
  int v6; // [esp+14h] [ebp-4h]

  v6 = *(_DWORD *)(a2 + 4);
  v5 = *(_DWORD *)sub_8138918(a2);
  while ( v5 )
  {
    v3 = (std::string *)sub_8139450(v5);
    if ( (unsigned __int8)sub_8138B62(a2 + 12, v3, a3) )
    {
      v5 = *(_DWORD *)sub_81393B6(v5);
    }
    else
    {
      v6 = v5;
      v5 = *(_DWORD *)sub_8138B2E(v5);
    }
  }
  sub_8139486(a1, v6);
  return a1;
}

//----- (08138D96) --------------------------------------------------------
int __cdecl sub_8138D96(_DWORD *a1)
{
  return *a1 + 16;
}

//----- (08138DA4) --------------------------------------------------------
int __stdcall sub_8138DA4(int a1)
{
  sub_8138DCA(a1);
  return a1;
}

//----- (08138DCA) --------------------------------------------------------
int __stdcall sub_8138DCA(int a1)
{
  return a1;
}

//----- (08138DD4) --------------------------------------------------------
int __cdecl sub_8138DD4(std::string *a1, std::string *a2, std::string *a3)
{
  std::string::string(a1, a2);
  return std::string::string((std::string *)((char *)a1 + 4), a3);
}

//----- (08138E2A) --------------------------------------------------------
int *__userpurge sub_8138E2A@<eax>(int *a1, int a2, int *a3, std::string *a4)
{
  std::string *v4; // ebx
  std::string *v5; // eax
  std::string *v6; // ebx
  int *v7; // eax
  std::string *v8; // eax
  int *v9; // eax
  std::string *v10; // ebx
  std::string *v11; // eax
  std::string *v12; // ebx
  std::string *v13; // eax
  char v15; // [esp+2Fh] [ebp-49h]
  char v16; // [esp+30h] [ebp-48h]
  char v17; // [esp+4Dh] [ebp-2Bh]
  char v18; // [esp+4Eh] [ebp-2Ah]
  char v19; // [esp+4Fh] [ebp-29h]
  int v20; // [esp+50h] [ebp-28h]
  char v21; // [esp+6Fh] [ebp-9h]

  if ( *a3 == *(_DWORD *)(*(_DWORD *)(a2 + 4) + 8) )
  {
    if ( sub_81394CC(a2)
      && (v4 = (std::string *)sub_81394A2(*a3),
          v5 = (std::string *)sub_81394C4((int)&v21, (int)a4),
          (unsigned __int8)sub_8138B62(a2 + 12, v5, v4)) )
    {
      sub_81394D8(a1, a2, *a3, *a3, a4);
    }
    else
    {
      sub_81390FA((int)&v20, a2, a4);
      sub_81389BC(a1, &v20);
    }
  }
  else if ( *a3 == *(_DWORD *)(a2 + 4) )
  {
    v6 = (std::string *)sub_81394C4((int)&v19, (int)a4);
    v7 = (int *)sub_81389AE(a2);
    v8 = (std::string *)sub_8139450(*v7);
    if ( (unsigned __int8)sub_8138B62(a2 + 12, v8, v6) )
    {
      v9 = (int *)sub_81389AE(a2);
      sub_81394D8(a1, a2, 0, *v9, a4);
    }
    else
    {
      sub_81390FA((int)&v20, a2, a4);
      sub_81389BC(a1, &v20);
    }
  }
  else
  {
    sub_81389BC(&v20, a3);
    sub_81392DC((int)&v20);
    v15 = 0;
    v10 = (std::string *)sub_81394C4((int)&v18, (int)a4);
    v11 = (std::string *)sub_81394A2(v20);
    if ( (unsigned __int8)sub_8138B62(a2 + 12, v11, v10) )
    {
      v12 = (std::string *)sub_81394A2(*a3);
      v13 = (std::string *)sub_81394C4((int)&v17, (int)a4);
      if ( (unsigned __int8)sub_8138B62(a2 + 12, v13, v12) )
        v15 = 1;
    }
    if ( v15 )
    {
      if ( *(_DWORD *)sub_81392F2(v20) )
        sub_81394D8(a1, a2, *a3, *a3, a4);
      else
        sub_81394D8(a1, a2, 0, v20, a4);
    }
    else
    {
      sub_81390FA((int)&v16, a2, a4);
      sub_81389BC(a1, (int *)&v16);
    }
  }
  return a1;
}

//----- (081390FA) --------------------------------------------------------
int __userpurge sub_81390FA@<eax>(int a1, int a2, std::string *a3)
{
  std::string *v3; // ebx
  std::string *v4; // eax
  std::string *v5; // ebx
  std::string *v6; // eax
  int v8; // [esp+28h] [ebp-50h]
  char v9; // [esp+2Ch] [ebp-4Ch]
  char v10; // [esp+2Dh] [ebp-4Bh]
  char v11; // [esp+2Eh] [ebp-4Ah]
  char v12; // [esp+2Fh] [ebp-49h]
  int v13[4]; // [esp+30h] [ebp-48h]
  char v14; // [esp+40h] [ebp-38h]
  int v15; // [esp+50h] [ebp-28h]
  char v16; // [esp+66h] [ebp-12h]
  char v17; // [esp+67h] [ebp-11h]
  int v18; // [esp+68h] [ebp-10h]
  int v19; // [esp+6Ch] [ebp-Ch]

  v19 = *(_DWORD *)(a2 + 4);
  v18 = *(_DWORD *)sub_8138918(a2);
  v17 = 1;
  while ( v18 )
  {
    v19 = v18;
    v3 = (std::string *)sub_8139450(v18);
    v4 = (std::string *)sub_81394C4((int)&v16, (int)a3);
    v17 = sub_8138B62(a2 + 12, v4, v3);
    if ( v17 )
      v8 = *(_DWORD *)sub_8138B2E(v18);
    else
      v8 = *(_DWORD *)sub_81393B6(v18);
    v18 = v8;
  }
  sub_8139486(&v15, v19);
  if ( v17 )
  {
    sub_8139682(&v14, a2);
    if ( (unsigned __int8)sub_8138490(&v15, &v14) )
    {
      sub_81394D8(v13, a2, v18, v19, a3);
      v12 = 1;
      sub_81396B0(a1, v13, (unsigned __int8 *)&v12);
      return a1;
    }
    sub_81392DC((int)&v15);
  }
  v5 = (std::string *)sub_81394C4((int)&v11, (int)a3);
  v6 = (std::string *)sub_81394A2(v15);
  if ( (unsigned __int8)sub_8138B62(a2 + 12, v6, v5) )
  {
    sub_81394D8(v13, a2, v18, v19, a3);
    v10 = 1;
    sub_81396B0(a1, v13, (unsigned __int8 *)&v10);
  }
  else
  {
    v9 = 0;
    sub_81396B0(a1, &v15, (unsigned __int8 *)&v9);
  }
  return a1;
}

//----- (081392DC) --------------------------------------------------------
int __cdecl sub_81392DC(int a1)
{
  sub_8139304(a1);
  return a1;
}

//----- (081392F2) --------------------------------------------------------
int __cdecl sub_81392F2(int a1)
{
  return a1 + 12;
}

//----- (081392FE) --------------------------------------------------------
void sub_81392FE()
{
  ;
}

//----- (08139304) --------------------------------------------------------
int __cdecl sub_8139304(int a1)
{
  int result; // eax
  int i; // [esp+0h] [ebp-4h]
  int j; // [esp+0h] [ebp-4h]

  if ( **(_DWORD **)a1 || *(_DWORD *)(*(_DWORD *)(*(_DWORD *)a1 + 4) + 4) != *(_DWORD *)a1 )
  {
    if ( *(_DWORD *)(*(_DWORD *)a1 + 8) )
    {
      for ( i = *(_DWORD *)(*(_DWORD *)a1 + 8); *(_DWORD *)(i + 12); i = *(_DWORD *)(i + 12) )
        ;
      result = i;
      *(_DWORD *)a1 = i;
    }
    else
    {
      for ( j = *(_DWORD *)(*(_DWORD *)a1 + 4); *(_DWORD *)a1 == *(_DWORD *)(j + 8); j = *(_DWORD *)(j + 4) )
        *(_DWORD *)a1 = j;
      result = j;
      *(_DWORD *)a1 = j;
    }
  }
  else
  {
    result = *(_DWORD *)(*(_DWORD *)a1 + 12);
    *(_DWORD *)a1 = result;
  }
  return result;
}

//----- (081393A2) --------------------------------------------------------
void __cdecl sub_81393A2(int a1)
{
  sub_81393F8(a1);
}

//----- (081393B6) --------------------------------------------------------
int __cdecl sub_81393B6(int a1)
{
  return a1 + 12;
}

//----- (081393C2) --------------------------------------------------------
void __cdecl sub_81393C2(int a1, void *ptr)
{
  sub_81393E4(a1, ptr);
}

//----- (081393E4) --------------------------------------------------------
void __cdecl sub_81393E4(int a1, void *ptr)
{
  free(ptr);
}

//----- (081393F8) --------------------------------------------------------
void __cdecl sub_81393F8(int a1)
{
  sub_81388A6(a1);
  sub_813988E(a1);
}

//----- (0813943C) --------------------------------------------------------
int __cdecl sub_813943C(std::string *a1)
{
  return sub_8138926(a1);
}

//----- (08139450) --------------------------------------------------------
int __cdecl sub_8139450(int a1)
{
  int v1; // eax
  char v3; // [esp+17h] [ebp-1h]

  v1 = sub_8139472(a1);
  return sub_813947E((int)&v3, v1);
}

//----- (08139472) --------------------------------------------------------
int __cdecl sub_8139472(int a1)
{
  return a1 + 16;
}

//----- (0813947E) --------------------------------------------------------
int __cdecl sub_813947E(int a1, int a2)
{
  return a2;
}

//----- (08139486) --------------------------------------------------------
int __cdecl sub_8139486(_DWORD *a1, int a2)
{
  int result; // eax

  sub_81392FE();
  result = a2;
  *a1 = a2;
  return result;
}

//----- (081394A2) --------------------------------------------------------
int __cdecl sub_81394A2(int a1)
{
  int v1; // eax
  char v3; // [esp+17h] [ebp-1h]

  v1 = sub_8139472(a1);
  return sub_813947E((int)&v3, v1);
}

//----- (081394C4) --------------------------------------------------------
int __cdecl sub_81394C4(int a1, int a2)
{
  return a2;
}

//----- (081394CC) --------------------------------------------------------
int __cdecl sub_81394CC(int a1)
{
  return *(_DWORD *)(a1 + 8);
}

//----- (081394D8) --------------------------------------------------------
_DWORD *__userpurge sub_81394D8@<eax>(_DWORD *a1, int a2, int a3, int a4, std::string *a5)
{
  std::string *v5; // ebx
  std::string *v6; // eax
  _DWORD *v7; // eax
  _DWORD *v8; // eax
  _DWORD *v9; // eax
  _DWORD *v10; // eax
  _DWORD *v11; // eax
  _DWORD *v12; // eax
  _DWORD *v13; // eax
  _DWORD *v14; // eax
  _DWORD *v15; // eax
  char v17; // [esp+17h] [ebp-11h]
  _DWORD *v18; // [esp+18h] [ebp-10h]
  int v19; // [esp+1Ch] [ebp-Ch]
  int v20; // [esp+20h] [ebp-8h]

  v20 = a3;
  v19 = a4;
  if ( a4 == *(_DWORD *)(a2 + 4)
    || v20
    || (v5 = (std::string *)sub_8139450(v19),
        v6 = (std::string *)sub_81394C4((int)&v17, (int)a5),
        (unsigned __int8)sub_8138B62(a2 + 12, v6, v5)) )
  {
    v18 = (_DWORD *)sub_81398AC(a2, a5);
    v7 = (_DWORD *)sub_8138B2E(v19);
    *v7 = v18;
    if ( v19 == *(_DWORD *)(a2 + 4) )
    {
      v8 = (_DWORD *)sub_8138918(a2);
      *v8 = v18;
      v9 = (_DWORD *)sub_81389AE(a2);
      *v9 = v18;
    }
    else
    {
      v10 = (_DWORD *)sub_81389A0(a2);
      if ( v19 == *v10 )
      {
        v11 = (_DWORD *)sub_81389A0(a2);
        *v11 = v18;
      }
    }
  }
  else
  {
    v18 = (_DWORD *)sub_81398AC(a2, a5);
    v12 = (_DWORD *)sub_81393B6(v19);
    *v12 = v18;
    v13 = (_DWORD *)sub_81389AE(a2);
    if ( v19 == *v13 )
    {
      v14 = (_DWORD *)sub_81389AE(a2);
      *v14 = v18;
    }
  }
  v15 = (_DWORD *)sub_8139676((int)v18);
  *v15 = v19;
  *(_DWORD *)sub_8138B2E((int)v18) = 0;
  *(_DWORD *)sub_81393B6((int)v18) = 0;
  sub_81396D6(v18, (_DWORD *)(*(_DWORD *)(a2 + 4) + 4));
  ++*(_DWORD *)(a2 + 8);
  sub_8139486(a1, (int)v18);
  return a1;
}

//----- (08139676) --------------------------------------------------------
int __cdecl sub_8139676(int a1)
{
  return a1 + 4;
}

//----- (08139682) --------------------------------------------------------
_DWORD *__userpurge sub_8139682@<eax>(_DWORD *a1, int a2)
{
  int *v2; // eax

  v2 = (int *)sub_81389A0(a2);
  sub_8139486(a1, *v2);
  return a1;
}

//----- (081396B0) --------------------------------------------------------
int __cdecl sub_81396B0(int a1, int *a2, unsigned __int8 *a3)
{
  int result; // eax

  sub_81389BC((int *)a1, a2);
  result = *a3;
  *(_BYTE *)(a1 + 4) = result;
  return result;
}

//----- (081396D6) --------------------------------------------------------
_DWORD *__cdecl sub_81396D6(_DWORD *a1, _DWORD *a2)
{
  _DWORD *result; // eax
  _DWORD *v3; // [esp+14h] [ebp-4h]
  _DWORD *v4; // [esp+14h] [ebp-4h]

  *a1 = 0;
  while ( a1 != (_DWORD *)*a2 && !*(_DWORD *)a1[1] )
  {
    if ( a1[1] == *(_DWORD *)(*(_DWORD *)(a1[1] + 4) + 8) )
    {
      v3 = *(_DWORD **)(*(_DWORD *)(a1[1] + 4) + 12);
      if ( !v3 || *v3 )
      {
        if ( a1 == *(_DWORD **)(a1[1] + 12) )
        {
          a1 = (_DWORD *)a1[1];
          sub_81399AA((int)a1, a2);
        }
        *(_DWORD *)a1[1] = 1;
        **(_DWORD **)(a1[1] + 4) = 0;
        sub_8139A36(*(_DWORD *)(a1[1] + 4), a2);
      }
      else
      {
        *(_DWORD *)a1[1] = 1;
        *v3 = 1;
        **(_DWORD **)(a1[1] + 4) = 0;
        a1 = *(_DWORD **)(a1[1] + 4);
      }
    }
    else
    {
      v4 = *(_DWORD **)(*(_DWORD *)(a1[1] + 4) + 8);
      if ( !v4 || *v4 )
      {
        if ( a1 == *(_DWORD **)(a1[1] + 8) )
        {
          a1 = (_DWORD *)a1[1];
          sub_8139A36((int)a1, a2);
        }
        *(_DWORD *)a1[1] = 1;
        **(_DWORD **)(a1[1] + 4) = 0;
        sub_81399AA(*(_DWORD *)(a1[1] + 4), a2);
      }
      else
      {
        *(_DWORD *)a1[1] = 1;
        *v4 = 1;
        **(_DWORD **)(a1[1] + 4) = 0;
        a1 = *(_DWORD **)(a1[1] + 4);
      }
    }
  }
  result = (_DWORD *)*a2;
  *(_DWORD *)*a2 = 1;
  return result;
}

//----- (0813988E) --------------------------------------------------------
void __cdecl sub_813988E(int a1)
{
  sub_81393C2(a1, *(void **)(a1 + 4));
}

//----- (081398AC) --------------------------------------------------------
#error "81398F3: call analysis failed (funcsize=30)"

//----- (08139920) --------------------------------------------------------
std::string *__cdecl sub_8139920(int a1, std::string *a2)
{
  std::string *result; // eax

  result = (std::string *)sub_813999C(8, a1);
  if ( result )
    result = (std::string *)sub_8139AC2(result, a2);
  return result;
}

//----- (0813999C) --------------------------------------------------------
int __cdecl sub_813999C(int a1, int a2)
{
  return a2;
}

//----- (081399A4) --------------------------------------------------------
void sub_81399A4()
{
  ;
}

//----- (081399AA) --------------------------------------------------------
int __cdecl sub_81399AA(int a1, _DWORD *a2)
{
  int result; // eax
  int v3; // [esp+0h] [ebp-4h]

  v3 = *(_DWORD *)(a1 + 12);
  *(_DWORD *)(a1 + 12) = *(_DWORD *)(v3 + 8);
  if ( *(_DWORD *)(v3 + 8) )
    *(_DWORD *)(*(_DWORD *)(v3 + 8) + 4) = a1;
  *(_DWORD *)(v3 + 4) = *(_DWORD *)(a1 + 4);
  if ( a1 == *a2 )
  {
    *a2 = v3;
  }
  else if ( a1 == *(_DWORD *)(*(_DWORD *)(a1 + 4) + 8) )
  {
    *(_DWORD *)(*(_DWORD *)(a1 + 4) + 8) = v3;
  }
  else
  {
    *(_DWORD *)(*(_DWORD *)(a1 + 4) + 12) = v3;
  }
  *(_DWORD *)(v3 + 8) = a1;
  result = v3;
  *(_DWORD *)(a1 + 4) = v3;
  return result;
}

//----- (08139A36) --------------------------------------------------------
int __cdecl sub_8139A36(int a1, _DWORD *a2)
{
  int result; // eax
  int v3; // [esp+0h] [ebp-4h]

  v3 = *(_DWORD *)(a1 + 8);
  *(_DWORD *)(a1 + 8) = *(_DWORD *)(v3 + 12);
  if ( *(_DWORD *)(v3 + 12) )
    *(_DWORD *)(*(_DWORD *)(v3 + 12) + 4) = a1;
  *(_DWORD *)(v3 + 4) = *(_DWORD *)(a1 + 4);
  if ( a1 == *a2 )
  {
    *a2 = v3;
  }
  else if ( a1 == *(_DWORD *)(*(_DWORD *)(a1 + 4) + 12) )
  {
    *(_DWORD *)(*(_DWORD *)(a1 + 4) + 12) = v3;
  }
  else
  {
    *(_DWORD *)(*(_DWORD *)(a1 + 4) + 8) = v3;
  }
  *(_DWORD *)(v3 + 12) = a1;
  result = v3;
  *(_DWORD *)(a1 + 4) = v3;
  return result;
}

//----- (08139AC2) --------------------------------------------------------
int __cdecl sub_8139AC2(std::string *a1, std::string *a2)
{
  std::string::string(a1, a2);
  return std::string::string((std::string *)((char *)a1 + 4), (std::string *)((char *)a2 + 4));
}

//----- (08139B20) --------------------------------------------------------
int sub_8139B20()
{
  void (__cdecl **v0)(); // ebx
  void (__cdecl *v1)(); // eax
  int v3; // [esp+0h] [ebp-8h]

  v0 = (void (__cdecl **)())&off_8185784;
  v1 = (void (__cdecl *)())off_8185784;
  if ( off_8185784 != (int (*)())-1 )
  {
    do
    {
      --v0;
      v1();
      v1 = *v0;
    }
    while ( *v0 != (void (__cdecl *)())-1 );
  }
  return v3;
}
// 8185784: using guessed type int (*off_8185784)();

//----- (08139B50) --------------------------------------------------------
void term_proc(void)
{
  sub_804A4E0();
}

#error "There were 2 decompilation failure(s) on 4608 function(s)"
