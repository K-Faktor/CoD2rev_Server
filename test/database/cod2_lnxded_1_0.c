/* This file was generated by the Hex-Rays decompiler version 7.7.0.220118.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: GNU C++
*/

#include <math.h>
#include <defs.h>

#include <stdarg.h>


//-------------------------------------------------------------------------
// Function declarations

void init_proc(void); // idb
void stop();
// int usleep(__useconds_t useconds);
// int mkdir(const char *path, __mode_t mode);
// double cos(double x);
// uint32_t ntohl(uint32_t netlong);
// int __cdecl std::string::operator=(_DWORD, _DWORD); weak
// int rename(const char *old, const char *new);
// _DWORD __cdecl std::string::compare(std::string *__hidden this, const std::string *); idb
// int execl(const char *path, const char *arg, ...);
// char *strncat(char *dest, const char *src, size_t n);
// int vsprintf(char *s, const char *format, __gnuc_va_list arg);
// char *strchr(const char *s, int c);
// int __cdecl std::allocator<char>::allocator(_DWORD); weak
// double atan(double x);
// ssize_t write(int fd, const void *buf, size_t n);
// struct tm *localtime(const time_t *timer);
// ssize_t recvfrom(int fd, void *buf, size_t n, int flags, struct sockaddr *addr, socklen_t *addr_len);
// int fileno(FILE *stream);
// int strcmp(const char *s1, const char *s2);
// int isspace(int);
// int close(int fd);
// double asin(double x);
// void *dlsym(void *handle, const char *name);
// int fprintf(FILE *stream, const char *format, ...);
// __pid_t fork(void);
// char *getenv(const char *name);
// __sighandler_t signal(int sig, __sighandler_t handler);
// int __cdecl std::string::string(_DWORD, _DWORD, _DWORD); weak
// int fflush(FILE *stream);
// int seteuid(__uid_t uid);
// int unlink(const char *name);
// int select(int nfds, fd_set *readfds, fd_set *writefds, fd_set *exceptfds, struct timeval *timeout);
// int vsnprintf(char *s, size_t maxlen, const char *format, __gnuc_va_list arg);
// char *strerror(int errnum);
// int tcsetattr(int fd, int optional_actions, const struct termios *termios_p);
// struct passwd *getpwuid(__uid_t uid);
// int __cdecl __deregister_frame_info_bases(_DWORD); weak
// int *__errno_location(void);
// int ftell(FILE *stream);
// _DWORD std::string::c_str(std::string *__hidden this); idb
// int system(const char *command);
// int chmod(const char *file, __mode_t mode);
// int tolower(int c);
// int access(const char *name, int type);
// int __cdecl std::string::operator=(_DWORD, _DWORD); weak
// void *malloc(size_t size);
// void __cdecl std::string::~string(std::string *__hidden this); idb
// size_t fread(void *ptr, size_t size, size_t n, FILE *stream);
// void *memmove(void *dest, const void *src, size_t n);
// int __cdecl std::string::operator[](_DWORD, _DWORD); weak
// ssize_t sendto(int fd, const void *buf, size_t n, int flags, const struct sockaddr *addr, socklen_t addr_len);
// int remove(const char *filename);
// void __noreturn __cxa_rethrow(void);
// double rint(double x);
// _DWORD std::string::string(std::string *__hidden this); idb
// int __sigsetjmp(struct __jmp_buf_tag *env, int savemask);
// int __xstat(int ver, const char *filename, struct stat *stat_buf);
// int setsockopt(int fd, int level, int optname, const void *optval, socklen_t optlen);
// int fseek(FILE *stream, int off, int whence);
// time_t time(time_t *timer);
// int fputs(const char *s, FILE *stream);
// char *strstr(const char *haystack, const char *needle);
// size_t strlen(const char *s);
// void longjmp(struct __jmp_buf_tag env[1], int val);
// unsigned int sleep(unsigned int seconds);
// void qsort(void *base, size_t nmemb, size_t size, __compar_fn_t compar);
// double atof(const char *nptr);
// double atan2(double y, double x);
// int strncmp(const char *s1, const char *s2, size_t n);
// in_addr_t inet_addr(const char *cp);
// double floor(double x);
// int memcmp(const void *s1, const void *s2, size_t n);
// _DWORD __cdecl std::string::erase(std::string *__hidden this, unsigned int, unsigned int); idb
// pthread_t pthread_self(void);
// int __cdecl std::string::operator+=(_DWORD, _DWORD); weak
// char *dlerror(void);
// int __cdecl __register_frame_info_bases(_DWORD, _DWORD, _DWORD, _DWORD); weak
// int __cdecl __libc_start_main(int (__cdecl *main)(int, char **, char **), int argc, char **ubp_av, void (*init)(void), void (*fini)(void), void (*rtld_fini)(void), void *stack_end);
// _DWORD __cdecl std::string::find(std::string *__hidden this, const char *, unsigned int); idb
// int toupper(int c);
// float sqrtf(float x);
// void *realloc(void *ptr, size_t size);
// char *strcat(char *dest, const char *src);
// double tan(double x);
// char *asctime(const struct tm *tp);
// int printf(const char *format, ...);
// int bind(int fd, const struct sockaddr *addr, socklen_t len);
// __uid_t getuid(void);
// int fcntl(int fd, int cmd, ...);
// void *memcpy(void *dest, const void *src, size_t n);
// double sqrt(double x);
// _DWORD __cdecl std::string::string(std::string *__hidden this, const std::string *); idb
// int __cdecl std::allocator<char>::~allocator(_DWORD); weak
// int fclose(FILE *stream);
// char *strrchr(const char *s, int c);
// char *ctime(const time_t *timer);
// int isdigit(int);
// int rmdir(const char *path);
// int closedir(DIR *dirp);
// int gettimeofday(struct timeval *tv, __timezone_ptr_t tz);
// void srand(unsigned int seed);
// DIR *opendir(const char *name);
// int snprintf(char *s, size_t maxlen, const char *format, ...);
// int gethostname(char *name, size_t len);
// struct hostent *gethostbyname(const char *name);
// int strcasecmp(const char *s1, const char *s2);
// int dlclose(void *handle);
// void exit(int status);
// int atoi(const char *nptr);
// int sscanf(const char *s, const char *format, ...);
// void free(void *ptr);
// int ioctl(int fd, unsigned int request, ...);
// uint16_t htons(uint16_t hostshort);
// char *getcwd(char *buf, size_t size);
// void *__cdecl __cxa_begin_catch(void *);
// int isatty(int fd);
// double acos(double x);
// void *memset(void *s, int c, size_t n);
// void _exit(int status);
// int strncasecmp(const char *s1, const char *s2, size_t n);
// char *strncpy(char *dest, const char *src, size_t n);
// int __cdecl std::string::operator+=(_DWORD, _DWORD); weak
// FILE *fopen(const char *filename, const char *modes);
// _DWORD __cdecl operator new[](unsigned int); idb
// void __cdecl operator delete[](void *); idb
// int sprintf(char *s, const char *format, ...);
// size_t fwrite(const void *ptr, size_t size, size_t n, FILE *s);
// double sin(double x);
// int socket(int domain, int type, int protocol);
// struct dirent *readdir(DIR *dirp);
// int rand(void);
// double log(double x);
// int tcgetattr(int fd, struct termios *termios_p);
// ssize_t read(int fd, void *buf, size_t nbytes);
// __uid_t geteuid(void);
// int __gmon_start__(void); weak
// double ceil(double x);
// void *dlopen(const char *file, int mode);
// char *strcpy(char *dest, const char *src);
// void __usercall __noreturn start(int a1@<eax>, void (*a2)(void)@<edx>);
void deregister_frame_info();
int register_frame_info();
_DWORD *__cdecl GetMemory(int a1);
_DWORD *__cdecl GetClearedMemory(size_t n);
void __cdecl FreeMemory(int a1);
void SourceError(int a1, char *format, ...);
void SourceWarning(int a1, char *format, ...);
_DWORD *__cdecl PC_PushIndent(_DWORD *a1, int a2, int a3);
void __cdecl PC_PopIndent(_DWORD *a1, _DWORD *a2, _DWORD *a3);
void __cdecl PC_PushScript(int a1, int a2);
_DWORD *__cdecl PC_CopyToken(void *src);
void __cdecl PC_FreeToken(int a1);
int __cdecl PC_ReadSourceToken(int a1, _BYTE *dest);
int __cdecl PC_UnreadSourceToken(int, void *src); // idb
int __cdecl PC_ReadDefineParms(int a1, const char **a2, int a3, int a4);
int __cdecl PC_StringizeTokens(int, char *dest); // idb
int __cdecl PC_MergeTokens(char *dest, char *src); // idb
int __cdecl PC_NameHash(int a1);
int *__cdecl PC_AddDefineToHash(int *a1, int a2);
int __cdecl PC_FindHashedDefine(int, char *s2); // idb
int __cdecl PC_FindDefine(int, char *s2); // idb
int __cdecl PC_FindDefineParm(int, char *s2); // idb
void __cdecl PC_FreeDefine(int a1);
int __cdecl PC_AddBuiltinDefines(int a1);
int __cdecl PC_ExpandBuiltinDefine(int a1, void *src, int a3, char **a4, char **a5);
int __cdecl PC_ExpandDefine(int a1, void *a2, int a3, char **a4, char **a5);
int __cdecl PC_ExpandDefineIntoSource(int, void *, int); // idb
char *__cdecl PC_ConvertPath(char *a1);
int __cdecl PC_Directive_include(int a1);
int __cdecl PC_ReadLine(int, char *s1); // idb
_BOOL4 __cdecl PC_WhiteSpaceBeforeToken(int a1);
_DWORD *__cdecl PC_ClearTokenWhiteSpace(_DWORD *a1);
int __cdecl PC_Directive_undef(int a1);
int __cdecl PC_Directive_define(int *a1);
int __cdecl PC_DefineFromString(char *s); // idb
int __cdecl PC_AddDefine(int, char *s); // idb
int __cdecl PC_AddGlobalDefine(char *s); // idb
int __cdecl PC_RemoveGlobalDefine(char *s2); // idb
int PC_RemoveAllGlobalDefines();
char **__cdecl PC_CopyDefine(int a1, int a2);
int __cdecl PC_AddGlobalDefinesToSource(int a1);
int __cdecl PC_Directive_if_def(_DWORD *a1, int a2);
int __cdecl PC_Directive_ifdef(_DWORD *a1);
int __cdecl PC_Directive_ifndef(_DWORD *a1);
int __cdecl PC_Directive_else(_DWORD *a1);
int __cdecl PC_Directive_endif(_DWORD *a1);
int __cdecl PC_OperatorPriority(int a1);
int __cdecl PC_EvaluateTokens(int a1, char *a2, _DWORD *a3, double *a4, int a5);
int __cdecl PC_Evaluate(int a1, _DWORD *a2, double *a3, int a4);
int __cdecl PC_DollarEvaluate(int a1, _DWORD *a2, double *a3, int a4);
int __cdecl PC_Directive_elif(_DWORD *a1);
int __cdecl PC_Directive_if(_DWORD *a1);
int __cdecl PC_Directive_line(int a1);
int __cdecl PC_Directive_error(int a1);
int __cdecl PC_Directive_pragma(int a1);
int __cdecl UnreadSignToken(int a1);
int __cdecl PC_Directive_eval(int a1);
int __cdecl PC_Directive_evalfloat(int a1);
int __cdecl PC_ReadDirective(int a1);
int __cdecl PC_DollarDirective_evalint(int a1);
int __cdecl PC_DollarDirective_evalfloat(int a1);
int __cdecl PC_ReadDollarDirective(int a1);
int __cdecl PC_ReadToken(int *a1, char *s);
int __cdecl PC_ExpectTokenString(int *a1, char *s2);
int __cdecl PC_ExpectTokenType(int *a1, int a2, int a3, char *s);
int __cdecl PC_ExpectAnyToken(int *a1, char *s);
int __cdecl PC_CheckTokenString(int *a1, char *s2);
int __cdecl PC_CheckTokenType(int *a1, int a2, int a3, void *dest);
int __cdecl PC_SkipUntilString(int *a1, char *s2);
int __cdecl PC_UnreadLastToken(int a1);
int __cdecl PC_UnreadToken(int, void *src); // idb
char *__cdecl PC_SetIncludePath(int a1, char *src);
_DWORD *__cdecl LoadSourceFile(char *src);
_DWORD *__cdecl LoadSourceMemory(void *a1, size_t n, char *src);
void __cdecl FreeSource(_DWORD *a1);
int __cdecl PC_LoadSourceHandle(char *src); // idb
int __cdecl PC_FreeSourceHandle(int a1);
int __cdecl PC_ReadTokenHandle(int a1, int a2);
int __cdecl PC_ReadLineHandle(int a1, int a2);
int __cdecl PC_SourceFileAndLine(int a1, char *dest, _DWORD *a3);
int *PC_CheckOpenSourceHandles();
long double __cdecl Q_fabs(float a1);
int __cdecl PS_CreatePunctuationTable(int a1, int a2);
void ScriptError(int a1, char *format, ...);
void ScriptWarning(int a1, char *format, ...);
int __cdecl SetScriptPunctuations(int a1, int a2);
int __cdecl PS_ReadWhiteSpace(int a1);
int __cdecl PS_ReadEscapeCharacter(int a1, char *a2);
int __cdecl PS_ReadString(_DWORD *a1, int a2, int a3);
int __cdecl PS_ReadName(int a1, int a2);
int __cdecl NumberValue(_BYTE *a1, __int16 a2, _DWORD *a3, long double *a4);
int __cdecl PS_ReadNumber(int a1, int a2);
int __cdecl PS_ReadLiteral(int a1, int a2);
int __cdecl PS_ReadPunctuation(int, char *dest); // idb
int __cdecl PS_ReadPrimitive(int a1, _BYTE *src);
int __cdecl PS_ReadToken(_DWORD *a1, _BYTE *dest);
int __cdecl PS_ExpectTokenString(_DWORD *a1, char *s2);
int __cdecl PS_ExpectTokenType(_DWORD *a1, int a2, int a3, char *a4);
int __cdecl PS_ExpectAnyToken(_DWORD *a1, _BYTE *dest);
int __cdecl PS_CheckTokenString(_DWORD *a1, char *s2);
int __cdecl PS_CheckTokenType(_DWORD *a1, int a2, int a3, void *dest);
int __cdecl PS_SkipUntilString(_DWORD *a1, char *s2);
int __cdecl PS_UnreadToken(int, void *src); // idb
char *__cdecl StripDoubleQuotes(char *dest);
char *__cdecl StripSingleQuotes(char *dest);
long double __cdecl ReadSignedFloat(_DWORD *a1);
int __cdecl ReadSignedInt(_DWORD *a1);
void *__cdecl ResetScript(_DWORD *a1);
_BOOL4 __cdecl EndOfScript(int a1);
int __cdecl ScriptSkipTo(int, char *s); // idb
char *__cdecl LoadScriptFile(char *src);
char *__cdecl LoadScriptMemory(void *a1, size_t n, char *src);
void __cdecl FreeScript(int a1);
char *getBuildNumber();
_BOOL4 Com_IsBspLoaded();
void *__cdecl Com_GetBspHeader(_DWORD *a1, _DWORD *a2);
int *__cdecl Com_LoadBsp(const char *a1);
void Com_UnloadBsp();
void Com_CleanupBsp();
int __cdecl Com_GetBspHeaderData(int a1);
int __cdecl CM_InitThreadData(int a1);
int CM_InitAllThreadData();
// char *__usercall CM_LoadMapData@<eax>(long double a1@<st0>, char *s);
// int __usercall CM_LoadMap@<eax>(long double a1@<st0>, char *s2, _DWORD *a3);
void *CM_Shutdown();
int __cdecl sub_805202A(int a1, int a2);
void __cdecl CM_SaveLump(int a1, char *a2, int a3, int *a4);
void *sub_80524EA();
int __cdecl sub_80524F4(int a1);
int __cdecl sub_8052518(int a1, _DWORD *a2, _DWORD *a3);
void *__cdecl CM_Hunk_Alloc(size_t a1);
void Hunk_UserCreate();
void CM_Hunk_CheckTempMemoryHighClear();
size_t __cdecl CM_Hunk_AllocateTempMemoryHigh(int a1);
int Hunk_UserDestroy();
int CM_Hunk_ClearTempMemoryHigh();
int __cdecl sub_80525A6(_DWORD *a1, _DWORD *a2);
int __cdecl sub_80525D6(int a1);
int __cdecl CMod_LoadMaterials(_DWORD *a1);
_DWORD *CMod_AllocLeafBrushNode();
// int __usercall CMod_LoadSubmodels@<eax>(long double a1@<st0>, _DWORD *a2);
long double __cdecl CMod_GetPartitionScore(int a1, int a2, int a3, int a4, int a5, float *a6);
_DWORD *__cdecl CMod_PartionLeafBrushes_r(unsigned __int16 *src, int a2, _DWORD *a3, _DWORD *a4);
void __cdecl CMod_PartionLeafBrushes(unsigned __int16 *src, int a2, _DWORD *a3);
int __cdecl CMod_GetLeafTerrainContents(unsigned __int16 *a1);
int __cdecl CMod_LoadSubmodelBrushNodes(int a1);
signed int __cdecl CMod_LoadNodes(_DWORD *a1);
// int __usercall CMod_LoadBrushes@<eax>(long double a1@<st0>, _DWORD *a2, _DWORD *a3);
signed int __cdecl CMod_LoadLeafs(_DWORD *a1, char a2);
int __cdecl CMod_LoadLeafBrushNodes(int a1);
// int __usercall CMod_LoadPlanes@<eax>(long double a1@<st0>, int a2, _DWORD *a3);
int __cdecl CMod_LoadLeafBrushes(_DWORD *a1);
int __cdecl CMod_LoadLeafSurfaces(_DWORD *a1);
// int __usercall CMod_LoadCollisionVerts@<eax>(long double a1@<st0>, _DWORD *a2);
// signed int __usercall CMod_LoadCollisionEdges@<eax>(long double a1@<st0>, _DWORD *a2);
// signed int __usercall CMod_LoadCollisionTriangles@<eax>(long double a1@<st0>, _DWORD *a2);
// signed int __usercall CMod_LoadCollisionBorders@<eax>(long double a1@<st0>, _DWORD *a2);
signed int __cdecl CMod_LoadCollisionPartitions(_DWORD *a1);
// int __usercall CMod_LoadCollisionAabbTrees@<eax>(long double a1@<st0>, _DWORD *a2);
void *__cdecl CMod_LoadEntityString(size_t *a1);
void *__cdecl CMod_LoadVisibility(int *a1);
// int __usercall CMod_LoadBrushRelated@<eax>(long double a1@<st0>, _DWORD *a2, char a3);
// void *__usercall CM_LoadMapFromBsp@<eax>(long double a1@<st0>, char *s, char a3);
int CM_InitBoxHull();
void CM_Cleanup();
int __cdecl sub_8054E72(int a1, _DWORD *a2);
void sub_8054FE2();
long double __cdecl sub_8054FF8(float a1);
void __cdecl sub_8055012(float, float);
void __cdecl sub_8055036(float, float);
int __cdecl sub_805505A(int a1, int a2);
int __cdecl sub_8055080(int a1);
int __cdecl CM_VectorSet(_DWORD *a1, int a2, int a3, int a4);
int __cdecl CM_VectorCopy(_DWORD *a1, _DWORD *a2);
float *__cdecl sub_80550DE(float *a1, float a2, float *a3);
void __cdecl sub_8055116(float *);
int __cdecl sub_8055154(__int16 a1);
int __cdecl CM_DataFromHeader(int a1);
void __cdecl sub_8055170(float);
long double __cdecl sub_8055184(float a1, float a2, float a3);
long double __cdecl sub_80551AE(float a1);
int __cdecl sub_80551CE(int a1, int a2, int a3);
long double __cdecl sub_80551EE(float a1);
_BOOL4 __cdecl sub_8055200(int a1, float *a2, float *a3);
void __cdecl sub_80553B2(int a1, float *a2, int a3);
void __cdecl sub_80558EC(int a1, int a2, int a3);
int __cdecl sub_8055B48(int a1, int a2, int a3);
void __cdecl sub_8055C74(int a1, int a2, int a3);
void __cdecl sub_8055CFE(int a1, int a2, int a3);
int __cdecl sub_8055D4C(int a1, unsigned __int16 *a2, int a3);
int __cdecl sub_8055E02(float *a1, float *a2, float *a3, float *a4, float *a5, float *a6, float *a7, float *a8);
long double __cdecl sub_8055F88(float a1);
int __cdecl sub_8055FA2(_DWORD *a1, _DWORD *a2);
float *__cdecl sub_8055FD2(float *a1, float *a2, float *a3);
float *__cdecl sub_8056016(float *a1, float *a2, float *a3);
float *__cdecl sub_805605A(float *a1, float a2, float *a3, float *a4);
long double __cdecl sub_80560AE(float *a1, float *a2);
long double __cdecl sub_80560E2(float *a1);
void __cdecl sub_8056116(float *a1, float *a2, int a3);
void __cdecl sub_805628C(int a1, float *a2, float a3, int a4);
void __cdecl sub_8056E42(float *a1, int a2, int a3);
long double __cdecl sub_805739C(float a1);
void __cdecl sub_80573BC(float, float);
float *__cdecl sub_80573E0(float *a1, float *a2, float *a3);
long double __cdecl sub_805740C(float *a1, float *a2);
long double __cdecl sub_805742E(float *a1);
int __cdecl sub_8057450(_DWORD *a1, int a2, int a3, int a4);
float *__cdecl sub_8057474(float *a1, float a2, float *a3);
long double __cdecl sub_80574AC(float a1, float a2, float a3);
void *__cdecl sub_80574D8(int a1);
void __cdecl sub_8057520(_DWORD *ptr);
float *__cdecl sub_8057656(float *a1, float a2);
void *__cdecl sub_80578D2(int *src);
void **__cdecl sub_805791A(void **a1, float *a2, float a3, float a4);
long double __cdecl sub_8057DB2(float a1);
int __cdecl sub_8057DCC(_DWORD *a1, _DWORD *a2);
float *__cdecl sub_8057DFC(float *a1, float *a2, float *a3);
float *__cdecl sub_8057E40(float *a1, float *a2, float *a3);
float *__cdecl sub_8057E84(float *a1, float a2, float *a3);
float *__cdecl sub_8057EBC(float *a1, float a2, float *a3, float *a4);
long double __cdecl sub_8057F10(float *a1, float *a2);
void *__cdecl sub_8057F44(size_t a1);
void *__cdecl sub_8057F58(size_t a1);
int __cdecl sub_8057F6C(char *s2);
int __cdecl sub_8057F90(int a1, int a2, float *a3, float *a4, int a5);
unsigned int __cdecl sub_805809A(int a1, float *a2, float *a3, int a4);
int __cdecl sub_8058162(_DWORD *a1, _DWORD *a2);
float *__cdecl sub_8058192(float *a1, float *a2, float *a3);
float *__cdecl sub_80581D8(int a1, float *a2, float *a3, float *a4);
int __cdecl sub_80582EC(int a1, char *a2, float *a3, float *a4, float *a5);
char *CM_LoadStaticModels();
int __cdecl sub_80588E0(_DWORD *a1, _DWORD *a2);
float *__cdecl sub_8058910(float *a1, float *a2, float *a3);
float *__cdecl sub_8058954(float *a1, float a2, float *a3);
int __cdecl sub_805898C(float *a1, int a2);
int __cdecl sub_8058A2C(float *a1);
_DWORD *__cdecl sub_8058A48(_DWORD *a1, int a2);
_DWORD *__cdecl sub_8058ABE(int a1, int a2);
int __cdecl sub_8058B66(_DWORD *a1, _DWORD *a2, int a3, int a4, _DWORD *a5);
int __cdecl sub_8058BD8(float *a1, unsigned __int8 *a2);
int __cdecl sub_8058D88(float *a1, int a2);
int __cdecl sub_8058E94(float *a1, int a2, float *a3, float *a4);
char *__cdecl sub_8058F82(int a1);
int __cdecl sub_8058FC4(_DWORD *a1, _DWORD *a2);
float *__cdecl sub_8058FF4(float *a1, float *a2, float *a3);
long double __cdecl sub_8059038(float *a1, float *a2);
int __cdecl CM_GetTraceThreadInfo(_DWORD *a1);
int __cdecl sub_80590B0(_DWORD *a1, _DWORD *a2);
int __cdecl sub_80590DE(_DWORD *a1, _DWORD *a2, int a3);
int __cdecl CM_ClipHandleToModel(int a1);
int __cdecl sub_805919A(int a1);
long double __cdecl sub_80591BC(int a1);
int __cdecl sub_80591DE(int a1, float *a2);
int *__cdecl sub_805924A(int a1, int a2);
unsigned int __cdecl sub_80592B6(float *a1, int a2);
void __cdecl sub_80592F2(float *a1, int a2, int a3);
int __cdecl sub_8059432(int a1, unsigned __int8 *a2, int a3);
int __cdecl sub_80595CA(int a1, int a2, int a3);
int __cdecl sub_8059674(int a1, int a2, int a3);
void __cdecl CM_TraceCapsuleThroughCapsule(int a1, int a2);
_DWORD *__cdecl sub_8059A48(float *a1, int a2);
void __cdecl sub_8059BBC(float *a1, _DWORD *a2, int a3);
void __cdecl sub_8059FDC(int a1, unsigned __int8 *a2, _DWORD *a3, float *a4, float *a5);
_BOOL4 __cdecl sub_805A3A4(int a1, int a2, float *a3);
void __cdecl sub_805A4AA(int a1, unsigned __int16 *a2, float *a3);
int __cdecl sub_805A564(int a1, float *a2, float *a3, float *a4, float a5, int a6);
int __cdecl sub_805A75A(int a1, float *a2, float a3, float a4, int a5);
void __cdecl sub_805AA0E(int a1, int a2);
void __cdecl sub_805AE54(int a1, int a2, _DWORD *a3, float *a4, float *a5);
_BOOL4 __cdecl CM_SetAxialCullOnly(int a1);
void __cdecl CM_Trace(int a1, float *a2, float *a3, int a4, int a5, int a6, int a7);
void __cdecl CM_BoxTrace(_DWORD *s, float *a2, float *a3, int a4, int a5, int a6, int a7);
void __cdecl sub_805B6F2(float *a1, int a2, int a3, int a4, int a5, int a6, int a7, float *a8, float *a9);
void __cdecl sub_805B972(_DWORD *s, int a2, int a3, int a4, int a5, int a6, int a7, float *a8, float *a9);
int __cdecl sub_805B9E2(float *a1, int a2);
int __cdecl sub_805BCEE(int a1, unsigned __int8 *a2, _DWORD *a3, float *a4);
int __cdecl sub_805C0BC(int a1, int a2);
int __cdecl sub_805C16E(int a1, unsigned __int16 *a2, float *a3);
_BOOL4 __cdecl sub_805C23C(float *a1, float *a2, int a3, float *a4, float a5, float *a6);
_BOOL4 __cdecl sub_805C370(float *a1, float *a2, float a3, float a4, float *a5);
int __cdecl sub_805C534(int a1, float *a2);
int __cdecl sub_805C9DE(int a1, int a2, _DWORD *a3, float *a4, float *a5);
int __cdecl CM_BoxSightTrace(int a1, int a2, int a3, int a4, int a5, int a6, int a7);
int __cdecl sub_805D124(int a1, int a2, int a3, int a4, int a5, int a6, int a7, float *a8, float *a9);
long double __cdecl sub_805D34E(float a1, float a2, float a3);
long double __cdecl CM_Fabs(float a1);
long double __cdecl CM_Sqrt(float a1);
_BOOL4 __cdecl sub_805D3B2(float a1);
void __cdecl sub_805D3CA(float, float);
void __cdecl sub_805D3EE(float, float);
long double __cdecl sub_805D412(float *a1, float *a2);
int __cdecl sub_805D434(_DWORD *a1);
int __cdecl CM_VectorCopy2(_DWORD *a1, _DWORD *a2);
unsigned int __cdecl sub_805D48E(_DWORD *a1);
float *__cdecl sub_805D4CC(float *a1, float *a2, float *a3);
float *__cdecl CM_VectorSubtract(float *a1, float *a2, float *a3);
long double __cdecl sub_805D554(float *a1, float *a2);
int __cdecl CM_VectorCompare(float *a1, float *a2);
long double __cdecl CM_VectorLengthSquared(float *a1);
int __cdecl sub_805D626(_DWORD *a1, _DWORD *a2);
int *__cdecl CM_CalcTraceExtents(int a1);
int __cdecl sub_805D6DC(int a1, int a2, int a3, float a4);
void __cdecl sub_805D852(float, float);
void __cdecl sub_805D876(float, float);
long double __cdecl sub_805D89A(float a1, float a2, float a3);
int __cdecl sub_805D8C4(float *a1, float *a2);
__int64 sub_805D9A8();
int sub_805DA8E();
int __cdecl sub_805DAA0(unsigned __int16 *a1);
int __cdecl sub_805DCC8(unsigned __int16 *a1, unsigned __int16 a2);
int __cdecl sub_805DD50(_WORD *a1, unsigned __int16 a2);
int __cdecl sub_805DDD0(int a1, float *a2, float *a3);
int __cdecl sub_805E18C(int a1, _DWORD *a2, _DWORD *a3, int a4);
int __cdecl sub_805E3D8(int a1);
int sub_805E51A();
void __cdecl sub_805E56A(unsigned __int16 a1, int a2);
int __cdecl sub_805E782(int a1, int a2, int a3, int a4, int a5);
void __cdecl sub_805E7C6(int a1, unsigned __int16 a2, _DWORD *a3, float *a4, float *a5);
void __cdecl sub_805EA28(float *a1, _DWORD *a2, _DWORD *a3, int a4);
int __cdecl sub_805EAD0(int a1, unsigned __int16 a2, _DWORD *a3, float *a4);
int __cdecl sub_805ED1E(_DWORD *a1, _DWORD *a2, float a3);
void __cdecl sub_805ED88(int a1, unsigned __int16 a2, _DWORD *a3, float *a4, float *a5);
void __cdecl sub_805F0A4(int a1, float *a2);
int __cdecl sub_805F10E(_DWORD *a1, unsigned __int16 a2, _DWORD *a3, float *a4);
int __cdecl sub_805F3F6(int a1);
void __cdecl sub_805F42C(int a1, unsigned __int16 a2, _DWORD *a3, float *a4, float *a5);
void __cdecl sub_805F61E(_DWORD *a1, float *a2);
int __cdecl sub_805F686(_DWORD *a1, unsigned __int16 a2, float *a3, float *a4);
int __cdecl sub_805F8C6(int a1);
long double __cdecl sub_805F8F8(float a1, float a2, float a3);
long double __cdecl sub_805F922(float a1);
_BOOL4 __cdecl sub_805F93C(float a1);
void __cdecl sub_805F954(float, float);
void __cdecl sub_805F978(float, float);
int __cdecl sub_805F99C(_DWORD *a1, _DWORD *a2);
float *__cdecl sub_805F9BC(float *a1, float *a2, float *a3);
int __cdecl sub_805F9E8(_DWORD *a1, _DWORD *a2);
int __cdecl sub_805FA18(_DWORD *a1, _DWORD *a2);
int Cmd_Wait_f();
int *Cbuf_Init();
void __cdecl Cbuf_AddText(char *s);
void __cdecl Cbuf_InsertText(char *s);
void __cdecl Cbuf_ExecuteText(int a1, char *s);
// int __usercall Cbuf_ExecuteInternal@<eax>(long double a1@<st0>);
// int __usercall Cbuf_Execute@<eax>(long double a1@<st0>);
int __cdecl Cmd_ExecFromDisk(const char *a1);
void Cmd_Exec_f();
void Cmd_Vstr_f();
void sub_805FF92();
int Cmd_Argc();
int SV_Cmd_Argc();
char *__cdecl Cmd_Argv(unsigned int a1);
char *__cdecl SV_Cmd_Argv(unsigned int a1);
char *__cdecl Cmd_ArgvBuffer(int a1, char *dest, int a3);
char *__cdecl SV_Cmd_ArgvBuffer(int a1, char *dest, int a3);
char *__cdecl Cmd_Args(int a1);
char *__cdecl sub_8060118(char *dest, int a2);
int __cdecl Cmd_TokenizeStringInternal(char *a1, int a2, int a3, char *a4);
int __cdecl Cmd_TokenizeStringWithLimit(char *a1, int a2);
int __cdecl SV_Cmd_TokenizeStringWithLimit(char *a1, int a2);
int __cdecl Cmd_TokenizeString(char *a1);
int __cdecl SV_Cmd_TokenizeString(char *a1);
int __cdecl Cmd_FindCommand(char *s1); // idb
void __cdecl Cmd_AddCommand(char *s1, int a2);
void __cdecl Cmd_RemoveCommand(char *s1);
int __cdecl Cmd_SetAutoComplete(char *s1, int, int); // idb
void Cmd_Shutdown();
int __cdecl sub_8060604(void (__cdecl *a1)(int));
_DWORD *__cdecl sub_8060634(char *s1, int *a2);
// int __usercall Cmd_ExecuteString@<eax>(long double a1@<st0>, char *a2);
// int __usercall SV_Cmd_ExecuteString@<eax>(long double a1@<st0>, char *a2);
void Cmd_List_f();
void Cmd_Init();
size_t __cdecl FS_FileRead(void *ptr, size_t size, size_t n, FILE *stream);
size_t __cdecl FS_FileWrite(void *ptr, size_t size, size_t n, FILE *s);
FILE *__cdecl FS_FileOpen(char *filename, char *modes);
int __cdecl FS_FileClose(FILE *stream); // idb
int __cdecl FS_FileSeek(FILE *stream, int off, int whence); // idb
int Hunk_ClearTempMemoryHigh();
void sub_8060924();
char *__cdecl Com_BeginRedirect(char *a1, int a2, int a3);
int Com_EndRedirect();
void CL_SwitchToLocalClient();
void __cdecl Com_PrintMessage(int a1, char *s);
void Com_Printf(char *format, ...);
void Com_DPrintf(char *format, ...);
// void *__usercall Com_ShutdownInternal@<eax>(long double a1@<st0>, const char *a2);
// void *__usercall Com_Shutdown@<eax>(long double a1@<st0>, const char *a2);
int Hunk_ClearTempMemory();
int __cdecl sub_8060C2E(char *s2); // idb
// void __usercall Com_SetErrorMessage(long double a1@<st0>, char *src);
// void *__usercall Com_ErrorCleanup@<eax>(long double a1@<st0>);
void __noreturn Com_Error(int a1, char *format, ...);
// void __usercall __noreturn Com_Quit_f(long double a1@<st0>);
char *__cdecl Com_ParseCommandLine(char *a1);
int Com_SafeMode();
// int __usercall Com_StartupVariable@<eax>(long double a1@<st0>, char *s2);
int Com_AddStartupCommands();
void __cdecl Info_Print(char *a1);
void *Com_InitPushEvent();
int __cdecl Com_PushEvent(int *a1);
int sub_806141C();
_DWORD *__stdcall Com_GetEvent(_DWORD *a1);
// int __usercall Com_EventLoop@<eax>(long double a1@<st0>);
int sub_80617B4();
int Com_Milliseconds();
int sub_80618CE();
void __noreturn Com_Error_f();
void Com_Freeze_f();
void Com_Crash_f();
bool Scr_Settings();
void Com_SetCinematic();
// void __usercall Com_InitDvars(long double a1@<st0>);
// int __usercall Com_RunAutoExec@<eax>(long double a1@<st0>);
// int __usercall Com_ExecStartupConfigs@<eax>(long double a1@<st0>, const char *a2);
// int __usercall Com_InitPlayerProfiles@<eax>(long double a1@<st0>);
// void __usercall Com_Init_Try_Block_Function(long double a1@<st0>, char *a2);
// void __usercall Com_Init(long double a1@<st0>, char *a2);
void __cdecl Com_WriteConfigToFile(char *src);
void __cdecl Com_WriteDefaultConfigToFile(char *src);
void Com_WriteConfiguration();
void Com_WriteConfig_f();
void Com_WriteDefaults_f();
int __cdecl Com_ModifyMsec(int a1);
int Com_UpdateViewLog();
// void __usercall Com_Frame_Try_Block_Function(long double a1@<st0>);
void sub_80624CC();
int Com_ResetFrametime();
// void __usercall Com_Frame(long double a1@<st0>);
void *Com_CloseLogFile();
void Com_Close();
_DWORD *__cdecl Field_Clear(_DWORD *a1);
// void *__usercall Com_Restart@<eax>(long double a1@<st0>);
int __cdecl sub_8062622(int a1);
_DWORD *__cdecl sub_806263E(int a1);
int __cdecl sub_806265A(_DWORD *a1);
int __cdecl sub_8062676(int a1);
void __cdecl sub_8062684(int a1);
int __cdecl sub_80626A8(_BYTE *a1, int a2, int a3, int a4, int a5);
int sub_8062782();
int __cdecl sub_806278C(float a1, char *s, unsigned int a3, int a4);
int __cdecl sub_8062808(float); // idb
void sub_806283E();
int __cdecl sub_8062844(int a1, int a2);
int __cdecl Com_GetServerDObj(int a1);
int sub_80628E4();
int __cdecl sub_8062988(__int16 ***a1, unsigned __int16 a2, int a3, int a4);
int *sub_8062A0C();
int __cdecl sub_8062A66(__int16 ***a1, unsigned __int16 a2, int a3, int a4);
int __cdecl sub_8062AEC(int a1);
int __cdecl Com_SafeServerDObjFree(int a1);
void *Com_InitDObj();
void Com_ShutdownDObj();
void Com_AbortDObj();
int __cdecl Dvar_ForEach(void (__cdecl *a1)(_DWORD));
signed int __cdecl Dvar_GetCombinedString(char *s, signed int a2);
// int __usercall Dvar_Command@<eax>(long double a1@<st0>);
int __cdecl Dvar_ToggleSimple(int a1);
// int __usercall Dvar_ToggleInternal@<eax>(long double a1@<st0>);
// int __usercall Dvar_Toggle_f@<eax>(long double a1@<st0>);
// void __usercall Dvar_TogglePrint_f(long double a1@<st0>);
// void __usercall Dvar_Set_f(long double a1@<st0>);
// void __usercall Dvar_RegisterBool_f(long double a1@<st0>);
// void __usercall Dvar_RegisterInt_f(long double a1@<st0>);
void Dvar_RegisterFloat_f();
// void __usercall Dvar_SetU_f(long double a1@<st0>);
// void __usercall Dvar_SetS_f(long double a1@<st0>);
// void __usercall Dvar_SetA_f(long double a1@<st0>);
// void __usercall Dvar_SetFromDvar_f(long double a1@<st0>);
void Dvar_Reset_f();
int __cdecl Dvar_WriteVariables(int a1);
int __cdecl Dvar_WriteDefaults(int a1);
void Dvar_List_f();
void __cdecl Com_DvarDump(int a1);
void Dvar_Dump_f();
int __cdecl SV_SetConfig(int a1, int a2, unsigned __int16 a3);
char *__cdecl Dvar_InfoString(unsigned __int16 a1);
char *__cdecl Dvar_InfoString_Big(unsigned __int16 a1);
void Dvar_AddCommands();
int __cdecl sub_8063F00(char *a1);
int __cdecl FS_SV_FOpenFileWrite(char *src); // idb
int __cdecl FS_SV_FOpenFileRead(char *src, _DWORD *a2);
int __cdecl FS_SV_Rename(char *a1, char *a2);
void *__cdecl sub_806451C(char *s, char a2);
int __cdecl sub_8064574(int a1, unsigned int a2, int a3);
int __cdecl sub_8064616(_DWORD *a1);
_DWORD *__cdecl sub_8064644(_DWORD *ptr, _DWORD *a2, _DWORD *a3);
int __cdecl FS_GetModList(char *, int); // idb
void FS_Dir_f();
void FS_NewDir_f();
void FS_TouchFile_f();
int __cdecl FS_iwIwd(char *haystack, const char *a2);
int __cdecl FS_CompareIwds(char *a1, int a2, int a3);
void FS_RemoveCommands();
void FS_AddCommands();
// _DWORD *__usercall FS_SetRestrictions@<eax>(long double a1@<st0>);
char *FS_LoadedIwdChecksums();
char *FS_LoadedIwdNames();
char *FS_LoadedIwdPureChecksums();
char *FS_ReferencedIwdChecksums();
char *FS_ReferencedIwdNames();
char *FS_ReferencedIwdPureChecksums();
void *__cdecl FS_PureServerSetLoadedIwds(char *a1, char *a2);
int __cdecl sub_8065AD2(char *a1, char *a2);
void *__cdecl sub_8065BE0(char *s);
int __cdecl sub_8065D50(char a1, int a2);
int __cdecl sub_8065DBA(int a1);
_DWORD *__cdecl sub_8065DEE(int a1);
_DWORD *__cdecl sub_8065E3E(int a1, _DWORD *a2);
_DWORD *__cdecl sub_8065E5E(int a1, int a2, int a3);
int __cdecl sub_8065EE6(int a1, int a2);
void __cdecl sub_8065FA6(int a1, int a2);
void __cdecl Huff_addRef(_DWORD *a1, unsigned __int8 a2);
int __cdecl sub_8066394(_DWORD *a1, _DWORD *a2, int a3);
int __cdecl Huff_offsetReceive(_DWORD *a1, _DWORD *a2, int a3, int *a4);
int __cdecl sub_8066466(int a1, int a2, int a3);
int *__cdecl sub_80664CC(int a1, int a2, int a3);
int __cdecl Huff_offsetTransmit(int a1, int a2, int a3, int *a4);
int __cdecl sub_806658E(_DWORD *a1, int a2);
int __cdecl sub_8066838(int a1, int a2);
int __cdecl Huff_Init(char *s);
_DWORD *__cdecl sub_8066C14(_DWORD *a1);
void *__cdecl sub_8066C54(int *a1, char *src, unsigned int a3);
void *__cdecl sub_8066D50(int a1, int *s);
void *__cdecl sub_8066E12(int *a1, int a2);
unsigned int __cdecl sub_806751E(int a1, int a2, unsigned int a3);
unsigned int __cdecl sub_80675C6(int a1, int a2, unsigned int a3);
int __cdecl Com_BlockChecksum(char *src, int a2);
int sub_806769E(char *a1, int a2, ...);
int __cdecl MSG_Init(void *s, int, int); // idb
_DWORD *__cdecl MSG_BeginReading(_DWORD *a1);
int __cdecl MSG_WriteBits(_DWORD *a1, int a2, int a3);
_DWORD *__cdecl MSG_WriteBit0(_DWORD *a1);
_DWORD *__cdecl MSG_WriteBit1(_DWORD *a1);
int __cdecl MSG_ReadBits(_DWORD *a1, int a2);
int __cdecl MSG_ReadBit(_DWORD *a1);
int __cdecl MSG_WriteBitsCompress(unsigned __int8 *a1, int a2, int a3);
_BYTE *__cdecl MSG_ReadBitsCompress(int a1, _BYTE *a2, int a3);
_DWORD *__cdecl MSG_WriteByte(_DWORD *a1, char a2);
_DWORD *__cdecl MSG_WriteData(_DWORD *a1, void *src, size_t n);
_DWORD *__cdecl MSG_WriteShort(_DWORD *a1, __int16 a2);
_DWORD *__cdecl MSG_WriteLong(_DWORD *a1, int a2);
_DWORD *__cdecl MSG_ReadString(_DWORD *a1, int a2, int a3);
_DWORD *__cdecl MSG_WriteString(_DWORD *a1, char *s);
_DWORD *__cdecl MSG_WriteBigString(_DWORD *a1, char *s);
_DWORD *__cdecl MSG_WriteAngle16(_DWORD *a1, float a2);
int __cdecl MSG_ReadByte(_DWORD *a1);
int __cdecl MSG_ReadShort(_DWORD *a1);
int __cdecl MSG_ReadLong(_DWORD *a1);
unsigned __int64 __cdecl MSG_ReadLong64(_DWORD *a1);
void *__cdecl MSG_ReadCommandString(_DWORD *a1);
void *__cdecl MSG_ReadBigString(_DWORD *a1);
void *__cdecl MSG_ReadStringLine(_DWORD *a1);
long double __cdecl MSG_ReadAngle16(_DWORD *a1);
void *__cdecl MSG_ReadData(_DWORD *a1, void *dest, size_t n);
_DWORD *__cdecl sub_806825C(_DWORD *a1, int a2, int a3, int a4, int a5);
int __cdecl MSG_ReadDeltaKey(_DWORD *a1, int a2, int a3, int a4);
int __cdecl sub_80682E8(_DWORD *a1, int a2, int a3, int a4);
int __cdecl MSG_ReadKey(_DWORD *a1, int a2, int a3);
_DWORD *__cdecl sub_80683AE(_DWORD *a1, __int16 a2, __int16 a3, __int16 a4);
int __cdecl MSG_ReadDeltaKeyShort(_DWORD *a1, __int16 a2, int a3);
_BYTE *__cdecl MSG_WriteReliableCommandToBuffer(char *s, _BYTE *a2, int a3);
void __cdecl MSG_SetDefaultUserCmd(int a1, void *s);
int __cdecl MSG_ReadForwardRightMoveMask(int a1, int a2);
_BYTE *__cdecl MSG_ClampForwardRightmove(char a1, _BYTE *a2, _BYTE *a3);
_BYTE *__cdecl MSG_ReadDeltaUsercmdKey(_DWORD *a1, int a2, int a3, int a4);
int *__cdecl MSG_WriteDeltaField(_DWORD *a1, int a2, int a3, int a4);
_DWORD *__cdecl MSG_WriteDeltaObjective(_DWORD *a1, int a2, int a3, int a4, int a5, int a6);
_DWORD *__cdecl MSG_WriteDeltaStruct(_DWORD *a1, int *a2, int *a3, int a4, int a5, int a6, int a7, int a8);
_DWORD *__cdecl MSG_WriteDeltaEntity(_DWORD *a1, int *a2, int *a3, int a4);
_DWORD *__cdecl MSG_WriteDeltaArchivedEntity(_DWORD *a1, int *a2, int *a3, int a4);
_DWORD *__cdecl MSG_WriteDeltaClient(_DWORD *a1, int *a2, int *a3, int a4);
void __cdecl MSG_ReadDeltaField(_DWORD *a1, int a2, int a3, const char **a4, int a5);
int __cdecl MSG_ReadDeltaObjective(_DWORD *a1, int a2, int a3, int a4, int a5);
int __cdecl MSG_ReadDeltaStruct(_DWORD *a1, int src, int dest, int a4, int a5, int a6, const char **a7);
int __cdecl MSG_ReadDeltaEntity(_DWORD *a1, void *src, void *dest, int a4);
int __cdecl MSG_ReadDeltaArchivedEntity(_DWORD *a1, void *src, void *dest, int a4);
int __cdecl MSG_ReadDeltaClient(_DWORD *a1, char *src, void *dest, int a4);
int __cdecl MSG_WriteDeltaHudElems(_DWORD *a1, int a2, int a3, int a4);
void *__cdecl MSG_ReadDeltaHudElems(_DWORD *a1, int a2, int a3, int a4);
_DWORD *__cdecl MSG_WriteDeltaPlayerstate(_DWORD *a1, char *a2, _DWORD *a3);
void *__cdecl MSG_ReadDeltaPlayerstate(_DWORD *a1, char *a2, char *a3);
int *MSG_initHuffmanInternal();
int *MSG_initHuffman();
int __cdecl MSG_ShortSwap(__int16 a1);
int __cdecl MSG_LongSwap(int a1);
char *__cdecl NET_AdrToString(int a1, int a2, int a3, int a4, int a5);
void **__cdecl NetProf_PrepProfiling(void **a1);
int __cdecl sub_806AF0A(int a1, int a2, int a3);
void __cdecl sub_806AF90(int a1, int a2, int a3);
void __cdecl sub_806B012(int a1, int a2, int a3);
_DWORD *__cdecl NetProf_UpdateStatistics(_DWORD *a1);
void Net_DumpProfile_f();
// void __usercall Netchan_Init(long double a1@<st0>, unsigned __int16 a2);
void **__cdecl sub_806B510(void *a1, void **s, void *a3, void *a4, void *a5, void *a6, void *a7, void *a8);
_BOOL4 __cdecl Netchan_TransmitNextFragment(int a1);
_BOOL4 __cdecl Netchan_Transmit(int a1, int n, void *src);
int __cdecl Netchan_Process(int a1, _DWORD *a2);
int __cdecl NET_CompareBaseAdrSigned(int a1, int a2);
_BOOL4 __cdecl NET_CompareBaseAdr(char a1, int a2, int a3, int a4, int a5, char a6);
int __cdecl NET_CompareAdrSigned(int a1, int a2);
_BOOL4 __cdecl NET_CompareAdr(char a1, int a2, int a3, int a4, int a5, char a6);
int __cdecl NET_IsLocalAddress(int a1);
int __cdecl NET_GetPacket(int *a1, int a2);
int __cdecl NET_GetLoopPacketInternal(int a1, _DWORD *s, int a3);
int __cdecl NET_GetLoopPacket(int a1, _DWORD *s, int a3);
int __cdecl NET_SendLoopPacket(int a1, size_t n, void *src, int a4, int a5, unsigned __int16 a6);
int __cdecl NET_SendPacket(int a1, size_t n, _DWORD *src, int a4, int a5, int a6, int a7, int a8);
_BOOL4 __cdecl NET_OutOfBandPrint(int a1, int a2, int a3, int a4, int a5, int a6, char *s);
_BOOL4 __cdecl NET_OutOfBandData(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8);
int __cdecl NET_OutOfBandVoiceData(int a1, int a2, int a3, int a4, int a5, int a6, void *src, size_t n);
int __cdecl NET_StringToAdr(char *s1, _DWORD *s);
int __cdecl sub_806C8B8(int a1);
int sub_806C8C0();
void *sub_806C8EA();
int __cdecl SetAnimCheck(int a1);
char *__cdecl sub_806C926(const char *a1);
int sub_806C95E();
int __cdecl sub_806CA12(_DWORD *a1, unsigned int a2, int a3);
char *__cdecl sub_806CA94(_DWORD *a1, unsigned int a2, int a3);
int __cdecl AnimTreeParseInternal(int a1, int a2, char a3, char a4, char a5);
_DWORD *__cdecl sub_806CE74(int a1, int a2, int a3);
void *__cdecl sub_806CED4(size_t n);
int __cdecl sub_806CEF0(int a1);
int __cdecl sub_806CF7E(int a1, __int16 a2, int a3, int a4, __int16 a5);
int __cdecl Scr_GetAnims(int a1);
int __cdecl sub_806D084(int, int, int, int, char *s, int, int, int); // idb
int __cdecl sub_806D2DC(int a1, int a2);
int __cdecl sub_806D3B4(int a1);
int __cdecl sub_806D43C(char *a1, int *a2, int a3);
char *__cdecl sub_806D55A(char *a1, int a2);
_BOOL4 __cdecl sub_806D5A6(const char *a1, int a2, int a3);
int __cdecl sub_806D668(int a1, int (__cdecl *a2)(int), int a3);
// _DWORD *__userpurge sub_806D8CE@<eax>(_DWORD *a1, char *a2);
int __cdecl Scr_FindAnim(char *a1, char *s, _DWORD *a3, int a4);
int __cdecl sub_806D9EC(int a1);
int __cdecl sub_806DA0A(int a1);
int __cdecl sub_806DA66(int a1);
int __cdecl sub_806DA94(int a1, unsigned __int8 a2);
int __cdecl sub_806DAD8(int a1, int a2, int a3);
int sub_806DEC6();
int sub_806DEEA();
int __cdecl sub_806DF0E(int a1);
int __cdecl sub_806DF32(unsigned __int16 a1);
int __cdecl sub_806DF60(unsigned __int16 a1);
int __cdecl sub_806DF8E(unsigned __int8 a1);
int __cdecl sub_806DFBA(int a1);
int __cdecl sub_806DFDE(int a1);
int __cdecl sub_806E004(int a1);
int __cdecl sub_806E028(int a1, int a2);
void __cdecl sub_806E042(int a1);
int __cdecl sub_806E07A(int a1, int a2, _DWORD *a3);
void __cdecl sub_806E09C(int a1, int a2);
int __cdecl sub_806E250(int a1, int a2, _DWORD *a3);
int __cdecl sub_806E272(int a1, int a2);
void __cdecl sub_806E2B4(int a1);
void __cdecl sub_806E2EE(int a1);
int __cdecl sub_806E326(int a1, int a2, int a3);
int __cdecl sub_806E36A(int a1, int a2, char a3, int a4);
int __cdecl sub_806E4CA(int a1);
int __cdecl sub_806E53A(_DWORD *a1, int a2);
int __cdecl sub_806E59A(char a1, int a2, _DWORD *a3);
void __cdecl sub_806E5EC(int a1);
void __cdecl sub_806E614(int a1);
_DWORD *__cdecl sub_806E638(_DWORD *a1, int a2, _DWORD *a3);
_DWORD *__cdecl sub_806E69A(_DWORD *a1, size_t *a2);
int __cdecl sub_806E714(int a1, int a2, int a3);
void __cdecl sub_806E846(int a1, int a2, _DWORD *a3);
void __cdecl sub_806E94E(int a1, int a2, _DWORD *a3);
_DWORD *__cdecl sub_806EA5A(int a1, _DWORD *a2);
void __cdecl sub_806EB94(int a1, int a2, int a3);
_DWORD *__cdecl sub_806EC16(_DWORD *a1, int a2, _DWORD *a3);
void __cdecl sub_806EC38(int a1, int a2, int a3);
int __cdecl sub_806ECA0(int a1, int a2, _DWORD *a3);
int __cdecl sub_806ECC2(int a1, int a2);
int __cdecl sub_806ED18(int a1, int a2, _DWORD *a3);
int __cdecl sub_806ED3A(int a1, int a2);
int __cdecl sub_806ED90(int a1, int a2);
void __cdecl sub_806EE00(int *a1);
char *__cdecl sub_806EEC6(int *a1);
void sub_806EF26();
void __cdecl sub_806EF32(int a1);
void __cdecl sub_806EF6A(int a1);
void __cdecl sub_806EFA2(int a1);
void __cdecl sub_806EFDA(int a1, int a2, int a3);
void __cdecl sub_806F024(int a1);
void __cdecl sub_806F05C(int a1);
void __cdecl sub_806F094(int a1);
void __cdecl sub_806F0CC(int a1);
void __cdecl sub_806F104(int a1);
void __cdecl sub_806F13C(int a1);
void __cdecl sub_806F174(int a1);
void __cdecl sub_806F1AC(int a1, int a2, int a3);
void __cdecl sub_806F230(int a1, int a2, int a3);
_DWORD *__cdecl sub_806F2B2(_DWORD *a1, int a2, _DWORD *a3);
void __cdecl sub_806F2D4(int a1);
void __cdecl sub_806F30C(int a1, int a2);
void __cdecl sub_806F356(int a1, int a2);
void __cdecl sub_806F3A0(int a1, int a2);
void __cdecl sub_806F3EA(int a1);
int __cdecl sub_806F422(unsigned int a1, int a2);
int __cdecl sub_806F48C(_DWORD *a1, int a2, int a3, int a4);
int __cdecl sub_806F4E8(_DWORD *a1, int a2, int a3, int a4);
int __cdecl sub_806F530(_DWORD *a1, int a2, int a3, int a4, int a5);
char *__cdecl sub_806F58C(int a1, int a2);
int sub_806F6FE();
void __cdecl sub_806F722(int a1);
void __cdecl sub_806F75A(int a1, _DWORD *a2, int a3, int a4, int a5);
void __cdecl sub_806F798(_DWORD *a1, _DWORD *a2, int a3, int a4, int a5);
int __cdecl sub_806F7DE(int *a1, int a2);
void __cdecl sub_806F7F8(_DWORD *a1, _DWORD *a2, int a3, int a4, int a5);
void __cdecl sub_806F83E(int *a1, int a2);
int __cdecl sub_806F96C(int *a1);
int __cdecl sub_806F9A0(int *a1, int a2);
int __cdecl sub_806F9EA(int a1);
_DWORD *__cdecl sub_806FA26(_DWORD *a1);
int __cdecl sub_806FA70(unsigned int a1, int a2, char a3);
void __cdecl sub_806FADC(_DWORD *a1, int a2);
void __cdecl sub_806FE34(_DWORD *a1, int a2);
int __cdecl sub_806FE7E(int a1);
void __cdecl sub_806FEF6(_DWORD *a1, int a2, char a3, int a4);
void __cdecl sub_806FF6C(int a1, int a2, char a3, int a4, int a5, int a6);
int __cdecl sub_806FFF8(_DWORD *a1, int a2, char a3, int a4);
int __cdecl sub_807007C(int a1, int a2, char a3, int a4, int a5);
void __cdecl sub_80700FE(_DWORD *a1, int a2, char a3, int a4, int a5);
void __cdecl sub_8070184(_DWORD *a1, int a2, char a3, int a4, int a5, int a6);
int __cdecl sub_8070216(_DWORD *a1);
void __cdecl sub_8070242(int a1, int a2, char a3, int a4);
int __cdecl sub_80702D8(_DWORD *a1);
_DWORD *__cdecl sub_807035E(_DWORD *a1, unsigned int *a2);
unsigned int __cdecl sub_80703B6(int a1, int *a2);
int __cdecl sub_80703E6(int a1);
_BOOL4 __cdecl sub_807040A(int a1);
void __cdecl sub_8070430(int a1, int a2);
void __cdecl sub_8070496(int a1, int a2);
char *__cdecl EmitCall(_DWORD *a1, int *a2, char a3, int a4);
char *__cdecl EmitMethod(int a1, _DWORD *a2, _DWORD *a3, int a4, char a5, int a6);
int __cdecl sub_807098C(int a1, _DWORD *a2, char a3);
int __cdecl sub_8070AA8(int a1);
int __cdecl sub_8070B86(int a1, int a2, int a3, int a4);
unsigned int __cdecl sub_8070C7A(int a1);
char *__cdecl sub_8070CB2(int a1, unsigned __int8 a2, int a3);
void __cdecl sub_8070D46(int a1, int a2);
char *__cdecl sub_8070DF8(int a1, char **a2);
int __cdecl sub_8070EE4(int *a1, int a2, int a3);
int __cdecl sub_8070FC0(int *a1, int a2, int a3, int a4);
char *__cdecl sub_807112A(int a1, int a2, int a3);
int __cdecl sub_8071180(_DWORD *a1, _DWORD *a2);
int __cdecl sub_8071370(_DWORD *a1, _DWORD *a2, int a3);
void __cdecl sub_8071552(int a1, int a2);
unsigned int __cdecl sub_8071586(int a1, int a2, int a3, int a4, int a5);
unsigned int __cdecl sub_807162A(int a1, int a2, int a3, int a4, int a5);
int __cdecl sub_80716CE(int a1, int a2, int a3, int a4, _DWORD *a5);
int __cdecl sub_807179C(int a1, int a2, int a3, int a4, _DWORD *a5, int a6);
void __cdecl sub_80718AE(int *a1, _DWORD *a2, char a3, int a4, int a5);
_DWORD *__cdecl sub_8071934(int a1, _DWORD *a2);
int __cdecl sub_807194E(_DWORD *a1, _DWORD *a2);
int __cdecl sub_80719D8(_DWORD *a1, _DWORD *a2, int a3);
void __cdecl sub_8071B6C(_DWORD *a1, int a2);
void __cdecl sub_8071BA0(int *a1, int a2);
_DWORD *__cdecl sub_8071CB0(int a1, _DWORD *a2);
void __cdecl sub_8071D0A(_DWORD *a1, int a2, int a3);
int __cdecl sub_8071D66(int *a1, int a2);
void __cdecl sub_8071D92(_DWORD *a1, int a2, int a3);
char *__cdecl sub_8071E6A(_DWORD *a1, int a2, int a3);
int sub_8071EB6();
int sub_8071EFA();
_BOOL4 __cdecl sub_8071F3E(_DWORD *a1);
int __cdecl sub_8071F50(int a1);
int __cdecl sub_8071F86(int a1, int a2, int a3);
void __cdecl sub_8072088(int *a1, _DWORD *a2, int a3, int a4, int a5);
_DWORD *__cdecl sub_80720EE(int a1, int a2, _DWORD *a3);
char *__cdecl sub_8072108(int a1, int a2);
void __cdecl sub_807212A(_DWORD *a1, int a2, _DWORD *a3);
void __cdecl sub_807216E(int a1, _DWORD *a2);
void __cdecl sub_80721A0(_DWORD *a1, int a2, int a3, int a4);
void __cdecl sub_8072210(int a1);
unsigned int __cdecl sub_807225A(_DWORD *a1, int a2, int a3, unsigned __int8 a4, int a5, int a6, _DWORD **a7);
void __cdecl sub_807233A(int a1, _DWORD *a2, size_t *a3);
int __cdecl sub_8072382(_DWORD *a1, int a2, int a3, int a4, int a5, unsigned __int8 a6, int a7, int a8, int *a9, _DWORD **a10);
void __cdecl sub_80725C2(int a1, int a2, int *a3, size_t *a4, size_t *a5);
int __cdecl sub_80726C0(_DWORD *a1);
int __cdecl sub_807270E(_DWORD *a1);
int __cdecl sub_807275C(_DWORD *a1, _DWORD *a2, int a3, int a4, int a5, int *a6);
int __cdecl sub_8072AE6(_DWORD *a1, int a2, int *a3, size_t *a4);
int __cdecl sub_8072C7E(int a1, int a2, int a3, _DWORD *a4, int a5, int a6, int a7, int *a8, int *a9);
int __cdecl sub_80730A4(int a1, int a2, int a3, int a4, int *a5, size_t *a6, size_t *a7);
void __cdecl sub_80732BA(int *a1, int a2, int a3);
_DWORD *__cdecl sub_807331C(int a1, _DWORD *a2);
void __cdecl sub_8073336(int *a1, int a2, int a3);
int **__cdecl sub_8073398(int **a1, int a2);
_DWORD ***__cdecl sub_80733DA(_DWORD ***a1, _DWORD *a2);
int **__cdecl sub_807341C(int **a1, int a2);
int __cdecl sub_807345E(int a1, int a2, int a3, int a4, int a5);
_DWORD ***__cdecl sub_8073538(int a1, _DWORD *a2);
int __cdecl sub_8073560(int a1, int a2, int a3, int a4, int a5);
void __cdecl sub_80736AC(int a1, int *a2, int a3, int a4, int a5);
void __cdecl sub_80737A2(int a1, _DWORD *a2, int a3, int a4, int a5);
int __cdecl compar(_DWORD *a1, _DWORD *a2);
int __cdecl sub_807384C(int a1);
void __cdecl sub_80738A8(_DWORD *a1, int a2);
void __cdecl sub_8073964(int a1);
char *__cdecl sub_8073980(int a1, char a2, int a3, int a4);
int __cdecl sub_8073BC8(int a1, int *a2);
char *__cdecl sub_8073DBC(_DWORD *a1, int a2, int a3, char a4, int a5, int a6);
void __cdecl sub_8074020(int a1, int a2);
char *__cdecl sub_807407E(int a1, _DWORD *a2);
char *__cdecl sub_8074158(int a1, _DWORD *a2);
void sub_8074230();
int __cdecl sub_8074236(int a1, int a2, unsigned __int8 a3);
int __cdecl sub_807428E(int a1, int a2);
int __cdecl sub_80742B0(int a1, int a2);
void __cdecl sub_80742D2(int a1, unsigned __int8 a2, int a3, _DWORD *a4);
void __cdecl sub_8074842(size_t *a1, int *a2);
int *__cdecl sub_8074A7A(int a1, char a2, int a3, _DWORD *a4);
int __cdecl sub_8074AF6(int a1, int *a2);
void __cdecl sub_8074B34(int a1, _DWORD *a2, size_t *a3);
char *__cdecl sub_8074B7C(int a1, int a2, int a3, int *a4);
void __cdecl sub_8074C6A(int ***a1, int a2, int a3);
_DWORD ***__cdecl sub_8074CB6(_DWORD ****a1, _DWORD *a2);
char *__cdecl sub_8074CD2(char **a1);
int __cdecl sub_8074DEE(int a1, int a2, int a3, int a4, _DWORD *a5);
int __cdecl sub_8074ED8(_DWORD ****a1, int a2, int **a3);
void __cdecl sub_8074F74(int a1);
int __cdecl sub_807501A(int *a1, _DWORD **a2);
int __cdecl sub_807509C(int *a1, _DWORD **a2);
char *__cdecl sub_80751B4(int a1);
int *__cdecl sub_80752BA(int a1);
int __cdecl sub_8075354(int a1);
int *__cdecl sub_80753A6(int a1);
char *__cdecl sub_80753DE(int *a1, int a2, int a3);
int __cdecl sub_8075710(int a1);
void sub_8075758();
int __cdecl sub_807578C(int *a1);
int __cdecl RemoveRefToValue(_DWORD *a1);
_BOOL4 __cdecl Scr_IsInOpcodeMemory(int a1);
int __cdecl sub_8075828(_BYTE *a1);
int __cdecl sub_8075874(char *a1, char *s);
void *sub_80759A6();
unsigned int *sub_80759D2();
int __cdecl sub_80759F2(int a1);
int __cdecl sub_8075A60(char *s2);
void sub_8075ABA();
int sub_8075B54();
int __cdecl sub_8075B72(int a1);
int __cdecl sub_8075BBE(int a1, int a2);
int __cdecl sub_8075C54(char *a1);
int sub_8075E10();
int sub_8075E1E();
int __cdecl sub_8075ECE(int (__cdecl *a1)(int), int a2);
void *sub_8075F0E();
void sub_8075F74();
int __cdecl sub_8075FE8(int a1);
void sub_8076040();
int *sub_8076134();
int __cdecl sub_80761F6(int a1);
int __cdecl sub_807626A(int a1, int a2);
int __cdecl sub_80763CA(int a1, int a2);
int __cdecl sub_80765A0(int a1);
int *sub_80766E6();
void __cdecl sub_8076776(const char *a1, int a2);
int __cdecl sub_80767AA(int a1);
int __cdecl sub_807682A(int a1);
int __cdecl sub_80768E2(int a1, int a2);
int __cdecl sub_8076960(int a1);
int __cdecl sub_8076A2A(int a1);
int __cdecl sub_8076A50(int a1, int a2);
void *sub_8076A72();
int *__cdecl sub_8076A9A(int a1, unsigned int a2, int a3);
void __cdecl sub_8076B14(unsigned __int8 *ptr);
_BOOL4 __cdecl sub_8076B6C(int a1, int a2);
void sub_8076B9C();
void sub_8076C84();
void __cdecl sub_8076D92(int a1, int a2);
int sub_8076FAE();
_DWORD *__cdecl sub_8077016(int a1);
char *__cdecl sub_80773B6(unsigned int a1);
char *__cdecl sub_8077474(unsigned int a1);
int __cdecl sub_807752A(unsigned int a1, int a2);
int __cdecl sub_8077554(_BYTE *a1, int a2, _DWORD *a3, _DWORD *a4);
int __cdecl sub_80775A6(int a1, int a2);
int __cdecl sub_80775E4(unsigned int a1, int a2, int *a3);
char *sub_80776B8();
int __cdecl sub_8077750(char *s, int a2, char *a3, int a4, int a5, unsigned __int8 a6);
int __cdecl sub_80778BC(int a1, char *s, int a3, unsigned __int8 a4);
char *__cdecl sub_807799E(int a1, char *s, int a3, unsigned __int8 a4);
int __cdecl sub_8077AE8(_BYTE *a1, int a2, _DWORD *a3, int a4);
void __cdecl sub_8077B96(int a1, const char *a2, _BYTE *a3, int a4);
int __cdecl sub_8077C92(int, int, char *s, size_t maxlen); // idb
int __cdecl sub_8077D5A(unsigned int a1);
void __cdecl Scr_PrintPrevCodePos(int a1, const char *a2, int a3);
int __cdecl sub_8077EF6(int, int, char *s, size_t maxlen); // idb
char *CompileError(int a1, char *format, ...);
void __noreturn sub_80780F6(const char *a1, char *format, ...);
void __cdecl runtimeError(int a1, const char *a2, int a3, const char *a4);
void __cdecl scriptError(const char *a1, int a2, const char *a3, void *a4);
// _DWORD *__userpurge sub_8078390@<eax>(_DWORD *a1, int a2);
// _DWORD *__userpurge sub_80783A2@<eax>(_DWORD *a1, int a2);
// size_t *__userpurge sub_80783B4@<eax>(size_t *a1, int a2);
// int __userpurge sub_80783DE@<eax>(int a1, int a2, int a3);
// int __userpurge sub_8078412@<eax>(int a1, int a2, int a3, int a4);
// int __userpurge sub_8078450@<eax>(int a1, int a2, int a3);
// int __userpurge sub_8078484@<eax>(int a1, int a2, int a3, int a4, int a5);
// int __userpurge sub_80784CC@<eax>(int a1, int a2, int a3, int a4);
// int __userpurge sub_807850A@<eax>(int a1, int a2, int a3, int a4, int a5, int a6);
// int __userpurge sub_807855C@<eax>(int a1, int a2, int a3, int a4, int a5);
// int __userpurge sub_80785A4@<eax>(int a1, int a2, int a3, int a4, int a5, int a6, int a7);
// int __userpurge sub_8078600@<eax>(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8);
// int __userpurge sub_8078666@<eax>(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, int a9);
// int __userpurge sub_80786D6@<eax>(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, int a9, int a10);
// int __userpurge sub_8078750@<eax>(int a1, int a2);
// _DWORD *__userpurge sub_80787A6@<eax>(_DWORD *a1, int a2, _DWORD *a3);
// _DWORD *__userpurge sub_80787EC@<eax>(_DWORD *a1, int a2, int a3);
int __cdecl sub_8078878(int a1);
int __cdecl sub_807888A(int a1);
int __cdecl SL_ConvertToString(int a1);
int __cdecl sub_80788C2(_BYTE *a1);
int __cdecl sub_80788FC(int a1);
int __cdecl sub_807891E(int a1);
int __cdecl sub_8078946(int a1);
unsigned int __cdecl sub_8078962(char *a1, unsigned int a2);
unsigned int sub_8078A24();
void sub_8078AB2();
void sub_8078AD0();
int __cdecl sub_8078AE8(char *s2, size_t n);
int __cdecl sub_8078CC6(char *s2);
int __cdecl sub_8078CEA(char *s); // idb
int __cdecl sub_8078D94(int a1, unsigned __int8 a2);
int __cdecl SL_GetStringOfLen(char *s2, unsigned __int8 a2, size_t n);
int __cdecl SL_GetString(char *s, unsigned __int8 a2);
int __cdecl sub_80792C4(char *s, unsigned __int8 a2);
int __cdecl sub_80792E6(const char *a1, unsigned __int8 a2, size_t n);
int __cdecl sub_807939E(char *s, unsigned __int8 a2);
int __cdecl sub_80793D2(char *s, unsigned __int8 a2);
int __cdecl sub_80793F4(int a1, unsigned __int8 a2);
int __cdecl sub_80794D8(int a1, unsigned __int8 a2);
int __cdecl sub_807951E(int a1);
int __cdecl sub_8079544(int a1, int a2, unsigned int a3);
int __cdecl SL_RemoveRefToString(int a1);
int __cdecl sub_80796DA(int a1);
int __cdecl sub_8079746(int a1, unsigned int a2);
int __cdecl Scr_SetString(_WORD *a1, int a2);
int __cdecl sub_80797CA(_WORD *a1, char *s);
int __cdecl sub_8079808(char *s); // idb
int __cdecl sub_8079824(float); // idb
int __cdecl sub_807986A(int a1);
int __cdecl sub_80798B0(float *a1);
void __cdecl sub_8079910(unsigned __int8 a1);
void sub_80799B6();
void sub_8079A58();
_BYTE *__cdecl sub_8079B84(_BYTE *a1, char *a2, int a3);
int __cdecl sub_8079C2A(char *a1);
size_t __cdecl I_strlen(char *s);
void TempMemoryReset();
unsigned int __cdecl TempMalloc(int a1);
unsigned int __cdecl TempMallocAlign(int a1);
unsigned int __cdecl TempMallocAlignStrict(int a1);
unsigned int __cdecl TempMemorySetPos(int a1);
_BOOL4 __cdecl sub_8079D48(int a1);
int __cdecl ThreadInfoCompare(_DWORD *a1, _DWORD *a2);
void Scr_DumpScriptThreads();
void Scr_DumpScriptVariablesDefault();
int sub_807A29E();
int *sub_807A368();
int sub_807A3B6();
unsigned int __cdecl sub_807A3E8(int a1);
int __cdecl sub_807A402(int a1, int a2);
int __cdecl sub_807A4D2(int a1, int a2);
int __cdecl sub_807A514(int a1, unsigned int a2, int a3);
int __cdecl sub_807AA14(int a1, unsigned int a2, int a3);
int __cdecl sub_807AAC0(int a1, unsigned int a2, int a3);
int __cdecl sub_807AB96(int a1, unsigned int a2);
int __cdecl sub_807ABDE(int a1, unsigned int a2);
int __cdecl sub_807AC26(int a1, unsigned int a2);
int __cdecl sub_807AC94(__int16 *a1, int a2);
int __cdecl sub_807AEBA(int a1);
int __cdecl sub_807AF82(int a1);
int __cdecl sub_807AFAC(int a1, int a2);
int __cdecl sub_807B004(int a1);
int __cdecl sub_807B04E(int a1);
int __cdecl sub_807B084(int a1);
int __cdecl sub_807B110(int a1);
int __cdecl sub_807B128(int a1, int a2);
int __cdecl sub_807B190(int a1);
unsigned int __cdecl sub_807B1C8(int a1);
unsigned int __cdecl GetParentLocalId(int a1);
unsigned int __cdecl sub_807B1F0(int a1);
unsigned int __cdecl sub_807B22A(unsigned int a1);
int __cdecl sub_807B25E(int a1);
int __cdecl sub_807B360(int a1);
int sub_807B3A8();
int __cdecl sub_807B4A0(int a1);
int sub_807B562();
int sub_807B5A0();
int __cdecl sub_807B5EA(int a1, __int16 a2);
int sub_807B658();
int __cdecl AllocThread(__int16 a1);
int __cdecl sub_807B700(__int16 a1, int a2);
int __cdecl sub_807B766(int a1);
int __cdecl sub_807B778(int a1);
int __cdecl AddRefToObject(int a1);
int __cdecl RemoveRefToObject(int a1);
int __cdecl sub_807B8D4(int a1);
_DWORD *sub_807B936();
_DWORD *__cdecl sub_807B968(_DWORD *a1);
int __cdecl sub_807B9A6(int a1);
int __cdecl RemoveRefToVector(int a1);
int __cdecl sub_807BA14(int a1, int a2);
int __cdecl RemoveRefToValueInternal(int a1, int a2);
_BOOL4 __cdecl IsValidArrayIndex(int a1);
int __cdecl sub_807BADA(int a1);
int __cdecl sub_807BAEC(int a1, int a2);
int __cdecl FindArrayVariable(int a1, int a2);
int __cdecl FindVariable(int a1, int a2);
int __cdecl sub_807BB58(int a1, int a2);
int __cdecl sub_807BB82(int a1, int a2);
int __cdecl sub_807BBA6(int a1, int a2);
int __cdecl sub_807BBCA(int a1, int a2);
// int *__userpurge sub_807BC7C@<eax>(int *a1, int a2, int a3);
// _DWORD *__userpurge sub_807BF2C@<eax>(_DWORD *a1, unsigned int a2);
int __cdecl sub_807BF8E(int a1, int a2, int a3);
int __cdecl sub_807C060(int a1, int a2);
int __cdecl sub_807C084(int a1, int a2);
int __cdecl sub_807C0A8(int a1, unsigned int a2);
int __cdecl sub_807C0CC(int a1, unsigned int a2);
int __cdecl sub_807C0F0(int a1, int a2);
int __cdecl sub_807C11A(int a1, int a2);
int __cdecl sub_807C144(int a1, int a2);
int __cdecl sub_807C16E(int a1, int a2);
int __cdecl sub_807C1CC(int a1);
int __cdecl sub_807C228(int a1, int a2);
int __cdecl sub_807C248(int a1, int a2);
int __cdecl sub_807C26C(int a1, int a2);
int __cdecl sub_807C290(int a1, int a2);
int __cdecl sub_807C2F6(int a1, int a2);
int __cdecl sub_807C45C(int a1, int *a2);
int __cdecl sub_807C4C2(int a1, int *a2);
__int16 *__cdecl sub_807C4FC(int a1);
int __cdecl sub_807C51C(int a1, unsigned int a2, int *a3);
unsigned int __cdecl sub_807C5E2(int a1);
int __cdecl sub_807C628(int a1, int *a2);
// int *__userpurge sub_807C66A@<eax>(int *a1, int a2);
int __cdecl sub_807C6AE(int a1);
// int *__userpurge sub_807C72C@<eax>(int *a1, int a2, int a3);
// int *__userpurge sub_807C83C@<eax>(int *a1, int a2);
void __cdecl sub_807C8B2(int *a1);
int __cdecl sub_807C9AC(int a1);
int __cdecl sub_807C9CE(int a1);
int __cdecl sub_807CA16(int a1);
unsigned int __cdecl GetVariableName(int a1);
int __cdecl sub_807CA86(int a1);
int __cdecl sub_807CAD2(int a1);
int __cdecl sub_807CB1E(int a1);
_BOOL4 __cdecl sub_807CB3E(int a1);
_BOOL4 __cdecl sub_807CBAA(int a1);
void __cdecl sub_807CBD8(int *a1);
void __cdecl sub_807CC38(float *a1);
int __cdecl sub_807CCCE(int *a1);
int __cdecl sub_807CDD0(int *a1);
int __cdecl sub_807CEE4(int a1);
void __cdecl sub_807CF1E(_DWORD *a1);
int __cdecl sub_807CFFA(int a1, int *a2);
void __cdecl sub_807D08C(int *a1, int *a2);
void __cdecl sub_807D15A(int *a1, int *a2);
void __cdecl sub_807D1D4(int *a1, int a2);
void __cdecl Scr_EvalOr(int *a1, int *a2);
void __cdecl Scr_EvalExOr(int *a1, int *a2);
void __cdecl Scr_EvalAnd(int *a1, int *a2);
void __cdecl Scr_EvalEquality(int *a1, int *a2);
_BOOL4 __cdecl Scr_EvalInequality(int *a1, int *a2);
void __cdecl Scr_EvalLess(int *a1, int *a2);
_BOOL4 __cdecl Scr_EvalGreaterEqual(int *a1, int *a2);
void __cdecl Scr_EvalGreater(int *a1, int *a2);
_BOOL4 __cdecl Scr_EvalLessEqual(int *a1, int *a2);
void __cdecl Scr_EvalShiftLeft(int *a1, int *a2);
void __cdecl Scr_EvalShiftRight(int *a1, int *a2);
void __cdecl Scr_EvalPlus(int *a1, int *a2);
void __cdecl Scr_EvalMinus(int *a1, int *a2);
void __cdecl Scr_EvalMultiply(int *a1, int *a2);
void __cdecl Scr_EvalDivide(int *a1, int *a2);
void __cdecl Scr_EvalMod(int *a1, int *a2);
void __cdecl Scr_EvalBinaryOperator(int a1, int *a2, int *a3);
_BOOL4 __cdecl sub_807DF52(int a1);
int __cdecl GetVarType(int a1);
void __cdecl Scr_FreeEntityNum(int a1, int a2);
int sub_807E04A();
unsigned int *sub_807E0C6();
int __cdecl sub_807E13C(int a1);
int __cdecl sub_807E182(int a1);
int __cdecl sub_807E1F6(int a1, char *s2, unsigned __int16 a3);
int __cdecl sub_807E2EA(int a1, int a2);
int __cdecl sub_807E346(int a1, int a2);
int __cdecl sub_807E3A6(int a1, int a2);
int __cdecl sub_807E43A(int a1, int *a2);
int __cdecl Scr_FindArrayIndex(int a1, int *a2);
void __cdecl Scr_EvalArray(int *a1, int *a2);
int __cdecl Scr_EvalArrayRef(int a1);
void __cdecl sub_807EB00(int a1, int *a2);
int __cdecl sub_807ED9A(int a1);
// _WORD *__userpurge sub_807EDC4@<eax>(_WORD *a1, int a2);
int __cdecl sub_807EDFC(int a1, int a2);
int __cdecl sub_807EECE(int a1, int a2, int a3);
long double __cdecl Scr_GetEntryUsage(int a1, int a2);
long double __cdecl sub_807EF84(int a1);
long double __cdecl Scr_GetEndonUsage(int a1);
long double __cdecl Scr_GetObjectUsage(int a1);
long double __cdecl Scr_GetThreadUsage(int a1, float *a2);
int __cdecl sub_807F168(char *s1, _DWORD *a2);
int __cdecl Scr_AddFieldsForFile(char *src);
int __cdecl Scr_AddFields(const char *a1, char *a2);
int __cdecl sub_807F554(int a1);
int __cdecl sub_807F568(int a1);
void sub_807F64C();
int __cdecl sub_807F676(int a1);
int __cdecl sub_807F6F2(char a1);
int sub_807F740();
int __cdecl sub_807F74E(int, char *s); // idb
int __cdecl sub_807F7E0(int a1);
long double __cdecl sub_807F7F4(float a1);
void sub_807F810();
int sub_807F834();
int sub_807F8F6();
int Scr_Init();
bool __cdecl sub_807F988(int a1, int a2, int a3);
void Scr_Shutdown();
void Scr_Abort();
int __cdecl sub_807F9F2(int a1);
void sub_807FA00();
int sub_807FA9C();
int sub_807FACC();
int sub_807FAEE();
int __cdecl sub_807FB08(unsigned __int8 *a1, int a2, int a3, _DWORD *a4, char *a5);
void *__cdecl sub_8081F8C(_DWORD *a1);
char *__cdecl sub_8081FD6(int *a1, char *a2, int a3, int a4, _DWORD *a5);
int __cdecl sub_8082366(int a1, int a2, int a3, int a4, int a5);
int __cdecl sub_80823CE(int a1, int a2);
int __cdecl sub_808244A(int a1, int a2, _DWORD *a3, int a4, int *a5);
int __cdecl sub_8082572(int a1);
int __cdecl sub_80825C2(int a1, _DWORD *a2, int a3);
int __cdecl sub_8082754(int a1, int a2, int a3);
int __cdecl sub_80828BE(int a1, int a2, char a3);
int __cdecl sub_8082A4A(int a1);
int __cdecl sub_8082AC0(int a1, int a2);
int __cdecl sub_8082B7E(int a1);
int __cdecl sub_8082C1A(int a1, int a2);
int __cdecl sub_8082D9A(int a1, int a2);
_BOOL4 __cdecl sub_8082E74(unsigned int a1);
int __cdecl sub_8082EE2(unsigned int a1);
int __cdecl sub_8082F56(int a1, int a2, int *a3);
int __cdecl sub_8083426(int a1, int a2, int a3, int a4);
int __cdecl sub_80834DC(int a1);
int __cdecl sub_8083640(int a1);
unsigned int __cdecl sub_80836CA(int a1);
int sub_80837B0();
int __cdecl VM_Execute(int a1, char *a2, int a3);
int __cdecl Scr_ExecThread(int a1, int a2);
int __cdecl sub_8083A1A(int a1, int a2, int a3, int a4);
int __cdecl sub_8083AAC(int a1, int a2);
int __cdecl sub_8083B14(int a1, int a2, int a3, int a4);
int __cdecl Scr_FreeThread(unsigned __int16 a1);
int __cdecl sub_8083BAA(char *a1, int a2);
void sub_8083C5C();
int __cdecl sub_8083CBA(int a1, int a2, int a3, char a4, int a5);
int __cdecl sub_8083D82(int a1, int *a2, int a3);
int sub_8083E96();
unsigned int *__cdecl sub_8083EDA(int a1, int a2);
_BOOL4 Scr_IsSystemActive();
int __cdecl Scr_GetInt(unsigned int a1);
// unsigned __int16 *__userpurge Scr_GetAnim@<eax>(unsigned __int16 *a1, unsigned int a2, int a3);
// _DWORD *__userpurge Scr_GetAnimTree@<eax>(_DWORD *a1, unsigned int a2);
long double __cdecl Scr_GetFloat(unsigned int a1);
int __cdecl Scr_GetConstString(unsigned int a1);
int __cdecl sub_8084434(unsigned int a1);
int __cdecl Scr_GetString(unsigned int a1);
int __cdecl sub_8084586(unsigned int a1);
int __cdecl sub_80845C8(unsigned int a1);
int __cdecl sub_80845E4(unsigned int a1);
int __cdecl sub_808464E(unsigned int a1);
int __cdecl Scr_GetIString(unsigned int a1);
void __cdecl Scr_GetVector(unsigned int a1, _DWORD *a2);
int __cdecl Scr_GetFunc(unsigned int a1);
// _WORD *__userpurge Scr_GetEntityRef@<eax>(_WORD *a1, unsigned int a2);
int __cdecl sub_808491A(unsigned int a1);
int __cdecl Scr_GetType(unsigned int a1);
int __cdecl sub_80849F8(unsigned int a1);
int __cdecl Scr_GetPointerType(unsigned int a1);
int Scr_GetNumParam();
int __cdecl Scr_AddBool(int a1);
int __cdecl Scr_AddInt(int a1);
int __cdecl Scr_AddFloat(int a1);
int __cdecl sub_8084B64(int a1);
int Scr_AddUndefined();
int __cdecl Scr_AddObject(int a1);
int __cdecl Scr_AddEntityNum(int a1, int a2);
int sub_8084BF4();
int __cdecl Scr_AddString(char *s); // idb
int __cdecl sub_8084C54(char *s); // idb
int __cdecl Scr_AddConstString(int a1);
_DWORD *__cdecl Scr_AddVector(_DWORD *a1);
int Scr_MakeArray();
int Scr_AddArray();
int __cdecl sub_8084D6E(unsigned int a1);
void __cdecl Scr_Error(int a1);
void __cdecl sub_8084DD2(int a1, int a2);
void __cdecl sub_8084DF0(int a1);
void __cdecl Scr_ParamError(int a1, int a2);
void __cdecl Scr_ObjectError(int a1);
int __cdecl sub_8084E4E(int a1, int a2, int a3, int a4);
// _DWORD *__userpurge sub_8084ECA@<eax>(_DWORD *a1, char *a2, int a3, int a4);
int __cdecl sub_8084F28(int a1, int a2);
int __cdecl sub_8084F6A(int a1, int a2, int a3);
int sub_8084F9A();
void sub_8084FD2();
int sub_8084FE0();
int __cdecl sub_80850EE(float); // idb
int __cdecl sub_8085124(_DWORD *a1, _DWORD *a2);
int __cdecl sub_8085154(int a1);
int __cdecl sub_808516A(unsigned __int8 *a1);
int __cdecl sub_8085180(_DWORD **a1);
int __cdecl sub_80851A2(int *a1);
int __cdecl sub_80851C2(int *a1, int a2);
int __cdecl sub_80851E6(_WORD **a1);
int __cdecl sub_80851FC(_DWORD **a1);
long double __cdecl sub_8085210(_DWORD **a1);
int __cdecl sub_8085238(_DWORD **a1);
int __cdecl sub_808524C(_WORD **a1);
int __cdecl sub_8085274(int a1);
int __cdecl sub_80852B8(char *s2, int a2);
int __cdecl sub_80852E8(const char *a1, int a2);
int __cdecl sub_8085425(char *s); // idb
int __cdecl sub_8085448(char *s); // idb
int sub_808546B();
int sub_8086881();
int sub_8086AF2();
int __cdecl sub_8086BCA(int a1);
int sub_8086C86();
int __cdecl sub_8086D87(FILE *stream); // idb
int __cdecl sub_8086DCB(int a1);
int sub_8086E2A();
_DWORD *__cdecl sub_8086E67(FILE *stream, int a2);
int __cdecl sub_8086F30(_DWORD *a1, FILE *stream);
int __cdecl sub_8086F8F(int a1);
_DWORD *__cdecl sub_8086FEC(int a1, unsigned int a2);
_DWORD *__cdecl sub_80870EE(int a1, int a2);
void __cdecl __noreturn sub_8087193(const char *a1);
void *__cdecl sub_80871C1(size_t size);
void *__cdecl sub_80871D4(void *ptr, size_t size);
void __cdecl sub_80871EE(void *ptr);
int sub_8087201();
int __cdecl ScriptParse(_DWORD *a1, char a2);
int sub_80872FC();
int yyparse();
char *SV_GetPlayerByName();
char *sub_808AB48();
void *__cdecl sub_808AC6A(char *s);
// void __usercall sub_808AC7E(long double a1@<st0>);
// void __usercall sub_808AD76(long double a1@<st0>, int a2);
// void __usercall sub_808AFE0(long double a1@<st0>);
// void __usercall sub_808AFF4(long double a1@<st0>);
char *sub_808B008();
// void __usercall sub_808B06A(long double a1@<st0>);
// int __usercall sub_808B24C@<eax>(long double a1@<st0>, int a2, char *dest, int a4);
// int __usercall sub_808B2F2@<eax>(long double a1@<st0>, char *dest, int a3);
// int __usercall sub_808B406@<eax>(long double a1@<st0>, char *dest, int a3);
// int __usercall sub_808B494@<eax>(long double a1@<st0>);
// void __usercall sub_808B4DE(long double a1@<st0>);
// void __usercall sub_808B532(long double a1@<st0>);
void sub_808B586();
// int __usercall sub_808B5BA@<eax>(long double a1@<st0>);
// int __usercall sub_808B5D6@<eax>(long double a1@<st0>);
// int __usercall sub_808B5F2@<eax>(long double a1@<st0>);
void sub_808B63C();
void sub_808B8DC();
void sub_808B9A2();
void sub_808BACE();
void sub_808BADE();
void sub_808BB06();
void sub_808BB2E();
// void *__usercall sub_808BB9E@<eax>(long double a1@<st0>);
void sub_808BBB2();
void sub_808BBC0();
void sub_808BBCE();
void SV_AddOperatorCommands();
void SV_RemoveOperatorCommands();
void sub_808BE02();
void sub_808BE32();
// void __usercall SV_GetChallenge(long double a1@<st0>, int a2, int a3, int a4, int a5, int a6);
// void __usercall sub_808C21C(long double a1@<st0>, int a2, int a3, int a4, int a5, int a6, int a7);
int __cdecl sub_808C34C(int a1);
int __cdecl sub_808C3D0(int a1);
unsigned int sub_808C46E();
int __cdecl sub_808C4CE(int a1);
// void __usercall sub_808C4FA(long double a1@<st0>, int a2);
void __cdecl sub_808C626(char *a1);
void __cdecl sub_808C7CA(char a1, int a2, int a3, int a4, int a5);
// int __usercall sub_808D026@<eax>(long double a1@<st0>, int a2);
// void __usercall SV_FreeClients(long double a1@<st0>);
// void __usercall SV_DirectConnect(long double a1@<st0>, void *a2, void *a3, void *a4, void *a5, void *a6);
int sub_808DC2C();
// void __usercall SV_DropClient(long double a1@<st0>, int a2, char *a3);
_DWORD *__cdecl sub_808DEA6(_DWORD *a1, _DWORD *a2);
// int __usercall sub_808DECA@<eax>(long double a1@<st0>, int a2);
int __cdecl sub_808E1F0(int a1, _DWORD *a2);
int *__cdecl sub_808E2BE(int a1);
int *__cdecl sub_808E348(int a1);
// int __usercall sub_808E398@<eax>(long double a1@<st0>, int a2);
int __cdecl sub_808E3C4(int a1);
// void __usercall sub_808E404(long double a1@<st0>, int a2);
char *__cdecl sub_808E508(int a1);
int __cdecl SV_WriteDownloadToClient(int a1, _DWORD *a2);
// void __usercall sub_808EC4A(long double a1@<st0>, int a2);
int __cdecl SV_VerifyIwds_f(int a1);
int __cdecl SV_ResetPureClient_f(int a1);
int __cdecl sub_808EEFE(int a1);
int __cdecl sub_808F0E6(int a1);
void __cdecl sub_808F13C(int a1);
void __cdecl sub_808F18C(int a1);
void __cdecl sub_808F1DC(float *, float *);
// void __usercall sub_808F1F6(long double a1@<st0>, int a2, char *a3, int a4);
// int __usercall sub_808F288@<eax>(long double a1@<st0>, int a2, _DWORD *a3);
// int __usercall SV_ClientThink@<eax>(long double a1@<st0>, char *a2, int *a3);
// void __usercall sub_808F510(long double a1@<st0>, int a2, _DWORD *a3, int a4);
// void __usercall SV_ExecuteClientMessage(long double a1@<st0>, int a2, _DWORD *a3);
// int __usercall SV_AddTestClient@<eax>(long double a1@<st0>);
int __cdecl sub_808FD2A(_BYTE *a1, _BYTE *a2, int a3);
int __cdecl SV_GentityNum(int a1);
int __cdecl SV_GameClientNum(int a1);
int __cdecl sub_808FE20(_DWORD *a1);
int __cdecl sub_808FE68(int a1);
int __cdecl SV_GameSendServerCommand(int a1, int a2, const char *a3);
// void __usercall sub_808FF0A(long double a1@<st0>, int a2, char *a3);
int __cdecl SV_SetBrushModel(int a1);
_BOOL4 __cdecl sub_808FFBC(float *a1, int a2);
int __cdecl sub_80901C2(float *a1, float *a2, int a3);
char *__cdecl SV_GetServerinfo(char *dest, int a2);
void *__cdecl sub_8090408(size_t a1);
void *__cdecl sub_8090438(size_t n, int a2);
_DWORD *__cdecl sub_8090470(size_t size);
void __cdecl sub_8090484(_DWORD *ptr);
int __cdecl sub_8090498(int a1, int a2, int a3, int a4, int a5);
int __cdecl sub_80904C6(int a1, _DWORD *a2);
void *__cdecl sub_809050C(size_t a1);
void *__cdecl sub_8090520(size_t a1);
int __cdecl SV_XModelGet(char *s1); // idb
void __cdecl SV_DObjDumpInfo(int *a1);
unsigned int sub_80905C8();
int __cdecl sub_80905FA(int a1);
int __cdecl sub_8090666(int *a1, int a2);
int __cdecl sub_80906EE(int *a1, int a2);
int __cdecl sub_8090776(int *a1, float a2, int a3);
_DWORD **__cdecl sub_80907BC(int *a1, float a2);
int __cdecl sub_80907EE(int *a1, int a2, int a3);
int __cdecl sub_8090820(int *a1, int a2);
int *__cdecl sub_809084A(int *a1, int a2);
int __cdecl sub_8090874(int *a1);
int __cdecl sub_8090898(int *a1, int a2);
int __cdecl sub_80908D8(int *a1);
void __cdecl sub_80908FC(int *a1);
int __cdecl sub_8090928(int *a1);
int __cdecl sub_809094C(int *a1, int a2, int a3);
int __cdecl sub_809097E(int *a1, int a2, int a3);
int __cdecl sub_80909B0(int *a1);
void sub_80909E8();
_BOOL4 __cdecl SV_MapExists(char *s);
void *sub_8090A48();
_BOOL4 __cdecl SV_DObjExists(int *a1);
int SV_SetWeaponInfoMemory();
void Com_FreeWeaponInfoMemory();
int __cdecl sub_8090AAA(char *dest, int); // idb
int __cdecl sub_8090AFE(int a1);
int __cdecl sub_8090B42(int a1);
int __cdecl sub_8090B5E(int a1);
// void __usercall SV_ShutdownGameProgs(long double a1@<st0>);
// void __usercall SV_SetGametype(long double a1@<st0>);
// void __usercall SV_InitGameVM(long double a1@<st0>, int a2, int a3);
// void __usercall SV_RestartGameProgs(long double a1@<st0>, int a2);
// void __usercall SV_InitGameProgs(long double a1@<st0>, int a2);
int SV_GameCommand();
float *__cdecl sub_8090DE8(float *a1, float *a2, float *a3);
float *__cdecl sub_8090E14(float *a1, float a2, float *a3);
int __cdecl sub_8090E3A(_DWORD *a1, _DWORD *a2);
int __cdecl SV_SetConfigstring(unsigned int a1, char *s1);
char *__cdecl SV_GetConfigstring(unsigned int a1, char *dest, int a3);
const char *__cdecl SV_GetConfigstringConst(int a1);
char *__cdecl sub_8091134(int a1, int a2, char *s1);
int __cdecl sub_80911AA(int, int, char *s1, char *); // idb
char *__cdecl sub_8091246(int a1, char *src);
char *__cdecl SV_GetUserinfo(int a1, char *dest, int a3);
int sub_8091372();
// void __usercall sub_809147E(long double a1@<st0>, char *a2);
// void __usercall sub_80914E6(long double a1@<st0>);
// int __usercall sub_80915D0@<eax>(long double a1@<st0>);
void __cdecl sub_809188A(char *a1);
void *sub_8091998();
void *__cdecl sub_80919F4(int a1);
void sub_8091A70();
void sub_8091AB2();
_WORD *sub_8091B5A();
int sub_8091B68();
// void __usercall SV_SpawnServer(long double a1@<st0>, char *a2);
_BOOL4 sub_809215C();
// char *__usercall SV_Init@<eax>(long double a1@<st0>);
// int *__usercall SV_FinalMessage@<eax>(long double a1@<st0>, const char *a2);
// int __usercall SV_DisconnectAllClients@<eax>(long double a1@<st0>);
// void __usercall SV_Shutdown(long double a1@<st0>, const char *a2);
int __cdecl sub_80929F8(_DWORD *a1, _DWORD *a2);
_BYTE *__cdecl sub_8092A28(_BYTE *a1);
int __cdecl sub_8092AB6(_BYTE *a1, _BYTE *a2);
int __cdecl sub_8092B3C(int a1, char *a2);
int __cdecl sub_8092C6C(int a1);
_DWORD *__cdecl sub_8092D5C(_DWORD *a1, int a2, char *s);
int SV_SendServerCommand(_DWORD *a1, int a2, char *format, ...);
int __cdecl sub_809315A(char a1, int a2, int a3, int a4, int a5, _DWORD *a6);
int __cdecl SVC_Status(int a1, int a2, int a3, int a4, int a5);
int __cdecl sub_80936D4(int a1, int a2, int a3, int a4, int a5);
_BOOL4 __cdecl SVC_Info(int a1, int a2, int a3, int a4, int a5);
// void __usercall SV_ConnectionlessPacket(long double a1@<st0>, void *a2, void *a3, void *a4, void *a5, void *a6, _DWORD *a7);
// void __usercall SV_PacketEvent(long double a1@<st0>, void *a2, void *a3, void *a4, void *a5, void *a6, _DWORD *a7);
int SV_CalcPings();
int __cdecl sub_8094586(int a1);
// int __usercall SV_CheckTimeouts@<eax>(long double a1@<st0>);
int SV_CheckPaused();
// void __usercall sub_8094780(long double a1@<st0>);
// int __usercall sub_809479A@<eax>(long double a1@<st0>, int a2);
// int __usercall sub_8094980@<eax>(long double a1@<st0>);
// void __usercall SV_Frame(long double a1@<st0>, int a2);
int *sub_8094E38();
void __cdecl SV_MasterHeartbeat(const char *a1);
void sub_8094FFC();
void SV_MasterShutdown();
_BOOL4 __cdecl sub_809507C(char *s);
// int __usercall SVC_RemoteCommand@<eax>(long double a1@<st0>, int a2, int a3, int a4, int a5, int a6);
void sub_809544E();
int __cdecl sub_8095454(int a1, _BYTE *a2, int a3);
int __cdecl sub_80954DE(int a1, _BYTE *a2, int a3);
_BOOL4 __cdecl SV_Netchan_TransmitNextFragment(int a1);
_BOOL4 __cdecl sub_80955A2(int a1, _BYTE *src, int n);
int __cdecl SV_Netchan_AddOOBProfilePacket(int a1);
int __cdecl sub_8095626(size_t n, _DWORD *src, int a3, int a4, int a5, int a6, int a7);
int SV_Netchan_UpdateProfileStats();
int __cdecl SV_Netchan_PrintProfileStats(int a1);
void __cdecl sub_80960BA(float, float);
void __cdecl sub_80960DE(float, float);
long double __cdecl sub_8096102(float a1, float a2, float a3);
int __cdecl sub_809612C(int a1, int a2, int a3, int a4, int a5, _DWORD *a6);
_DWORD *__cdecl sub_80962A0(int a1, int a2, int a3, int a4, int a5, _DWORD *a6);
int __cdecl sub_80963EC(int a1, _DWORD *a2);
int __cdecl SV_UpdateServerCommandsToClient(int a1, _DWORD *a2);
int __cdecl sub_80967E4(_DWORD *a1, _DWORD *a2, signed int a3);
void __cdecl SV_ShowClientUnAckCommands(int a1);
_DWORD *__cdecl sub_8096970(int a1, _DWORD *a2);
_DWORD *__cdecl sub_8096996(int a1, _DWORD *a2);
int __cdecl sub_80969BC(float *a1, int a2, _DWORD *a3);
int __cdecl sub_8096C56(int a1, int a2, float *a3, int a4, _DWORD *a5);
_DWORD *__cdecl sub_8096E9E(int a1);
_DWORD *__cdecl sub_8097A28(int *a1);
int __cdecl sub_8097B54(int a1, _DWORD *a2, void *a3);
int __cdecl sub_8097BD0(int a1, int a2, int a3);
int __cdecl sub_8097EDA(int a1, int *a2, _DWORD *a3, void *a4);
int __cdecl SV_BuildClientSnapshot(char *a1);
int __cdecl SV_RateMsec(int a1, int a2);
// int __usercall SV_SendMessageToClient@<eax>(long double a1@<st0>, int a2, int a3);
// int __usercall SV_SendClientSnapshot@<eax>(long double a1@<st0>, int a2);
int SV_ArchiveSnapshot();
// void __usercall SV_SendClientMessages(long double a1@<st0>);
long double __cdecl sub_8099D74(float a1, float a2, float a3);
int __cdecl sub_8099D8A(_DWORD *a1);
int __cdecl sub_8099DB4(_DWORD *a1, _DWORD *a2);
int __cdecl SV_WriteClientVoiceData(int a1, _DWORD *a2);
int __cdecl SV_SendClientVoiceData(int a1);
int __cdecl sub_809A000(int a1);
int __cdecl SV_ClientHasClientMuted(int a1, int a2);
char *__cdecl sub_809A040(char a1, int a2, int a3);
void __cdecl sub_809A112(int a1, _DWORD *a2);
void __cdecl sub_809A1EA(int a1, _DWORD *a2);
int __cdecl sub_809A368(int a1);
int __cdecl SV_UnlinkEntity(int a1);
void __cdecl sub_809A3E6(int a1);
int __cdecl SV_LinkEntity(int a1);
void __cdecl sub_809AB88(int a1, int a2, int a3);
void __cdecl sub_809AD2C(int a1, int a2, int a3);
int __cdecl sub_809B1A0(_DWORD *a1, int a2);
int __cdecl sub_809B30E(_DWORD *a1, int a2);
void __cdecl SV_Trace(float *s, float *a2, float *a3, float *a4, float *a5, int a6, int a7, int a8, int a9, int a10);
int __cdecl SV_TracePassed(float *a1, float *a2, float *a3, float *a4, int a5, int a6, int a7, int a8, int a9);
int *__cdecl SV_SightTrace(int *a1, float *a2, float *a3, float *a4, float *a5, int a6, int a7, int a8);
int __cdecl sub_809BE82(int a1, int a2, int a3, int a4, int a5, int a6);
void __cdecl sub_809C0CE(_DWORD *s, _DWORD *a2, _DWORD *a3, int a4, int a5, int a6);
int __cdecl sub_809C18C(float *a1, int a2, int a3);
int __cdecl sub_809C294(float); // idb
float *__cdecl sub_809C2CA(float *a1, float *a2, float *a3);
int __cdecl sub_809C2F6(_DWORD *a1, _DWORD *a2);
float *__cdecl sub_809C326(float *a1, float *a2, float *a3);
float *__cdecl sub_809C36A(float *a1, float *a2, float *a3);
float *__cdecl sub_809C3AE(float *a1, float a2, float *a3);
int RefreshQuitOnErrorCondition();
int QuitOnError();
_BOOL4 FS_Initialized();
void FS_CheckFileSystemStarted();
int __cdecl FS_IwdIsPure(int a1);
int FS_LoadStack();
_BOOL4 __cdecl FS_UseSearchPath(int a1);
int __cdecl FS_LanguageHasAssets(int a1);
int __cdecl FS_HashFileName(int a1, int a2);
int __cdecl FS_HandleForFile(int a1);
int __cdecl FS_FileForHandle(int a1);
int __cdecl FS_filelength(int a1);
_BYTE *__cdecl sub_809C748(_BYTE *a1);
_BYTE *__cdecl FS_BuildOSPath_Internal(char *src, char *s, char *a3, char *dest, int a5);
_BYTE *__cdecl FS_BuildOSPath(char *src, char *s, char *a3, char *dest);
int __cdecl FS_CreatePath(char *haystack); // idb
void __cdecl FS_CopyFile(char *filename, char *haystack);
int __cdecl sub_809CACA(char *filename); // idb
int __cdecl sub_809CADE(char *); // idb
int __cdecl sub_809CB58(char *, char *); // idb
void *__cdecl FS_FCloseFile(int a1);
int __cdecl FS_GetHandleAndOpenFile(char *src, char *filename, char *modes, int); // idb
int __cdecl FS_FOpenFileWrite(char *src); // idb
int __cdecl FS_FOpenTextFileWrite(char *src); // idb
int __cdecl FS_FOpenFileAppend(char *src); // idb
int __cdecl FS_FilenameCompare(char *a1, char *a2);
int __cdecl sub_809D1C6(char *filename, char *); // idb
char *__cdecl sub_809D424(char *haystack, int a2, char a3);
_BOOL4 __cdecl FS_PureIgnoreFiles(char *s1);
_BOOL4 __cdecl sub_809D516(_BYTE *a1);
_BOOL4 __cdecl FS_IsBackupSubStr(char a1);
int __cdecl FS_SanitizeFilename(int a1, int a2);
int __cdecl sub_809D6A2(char *); // idb
int __cdecl FS_FOpenFileRead_Internal(const char *a1, int *a2, int a3, int a4);
int __cdecl FS_FOpenFileReadStream(const char *a1, int *a2, int a3);
int __cdecl FS_FOpenFileRead(const char *a1, int *a2, int a3);
int __cdecl FS_TouchFile(const char *a1);
char *__cdecl sub_809E0E4(char *a1);
_BOOL4 __cdecl sub_809E1DA(char *a1);
_BOOL4 __cdecl sub_809E256(char *a1, int a2);
int __cdecl FS_Read(int a1, unsigned int a2, int a3);
size_t __cdecl FS_Write(char *a1, size_t a2, int a3);
size_t FS_Printf(int a1, char *format, ...);
int __cdecl sub_809E580(int, int off, int); // idb
int __cdecl FS_ReadFile(const char *a1, _DWORD *a2);
void FS_ResetFiles();
void __cdecl FS_FreeFile(_DWORD *ptr);
int __cdecl sub_809E99E(char *src, char *a2, int a3);
int __cdecl sub_809EA28(int, char *filename); // idb
int sub_809EB4A();
char *__cdecl FS_LoadZipFile(char *filename, char *a2);
int __cdecl sub_809F09C(char *src, char *dest, _DWORD *a3);
int __cdecl sub_809F12A(char *src, int, int); // idb
_DWORD *__cdecl FS_ListFilteredFiles(int a1, int a2, char *a3, int a4, int a5, int *a6);
_DWORD *__cdecl FS_ListFiles(int a1, char *a2, int a3, int *a4);
_DWORD *__cdecl sub_809F7F2(int a1, char *a2, int a3, int *a4, int a5);
_BOOL4 __cdecl sub_809F830(char *a1, int a2);
_DWORD *__cdecl sub_809F98A(int a1, char *a2, int a3, int a4, int *a5, int a6);
void __cdecl FS_FreeFileList(void **ptr);
int __cdecl FS_GetFileList(char *a1, char *a2, int a3, char *dest, int a5);
_BYTE *__cdecl FS_ConvertPath(_BYTE *a1);
int __cdecl FS_PathCmp(char *a1, char *a2);
void __cdecl FS_SortFileList(char **dest, int a2);
void __cdecl FS_DisplayPath(int a1);
void FS_FullPath_f();
void FS_Path_f();
int __cdecl IwdFileLanguage(char *s); // idb
int __cdecl iwdsort(char **a1, char **a2);
void **__cdecl FS_AddSearchPath(void **a1);
void __cdecl FS_AddIwdFilesForGameDirectory(char *a1, char *src);
void __cdecl FS_AddGameDirectoryInternal(char *a1, char *src, void *a3, void *a4);
void __cdecl FS_AddGameDirectory(char *a1, char *src);
void *__cdecl FS_ShutdownSearchPaths(void *ptr);
int FS_ShutdownServerIwdNames();
int FS_ShutdownServerReferencedIwds();
void FS_Shutdown();
// int __usercall FS_RegisterDvars@<eax>(long double a1@<st0>);
// void __usercall FS_Startup(long double a1@<st0>, char *src);
_DWORD *FS_ClearIwdReferences();
// char *__usercall FS_InitFilesystem@<eax>(long double a1@<st0>);
// char *__usercall FS_Restart@<eax>(long double a1@<st0>, int a2);
// int __usercall FS_ConditionalRestart@<eax>(long double a1@<st0>, int a2);
int __cdecl FS_FOpenFileByMode(char *src, int *a2, int a3);
int __cdecl FS_FTell(int a1);
int __cdecl FS_Flush(int a1);
char *GetBspExtension();
int __cdecl LittleLong(int a1);
int __cdecl FS_stat(char *filename, struct stat *stat_buf); // idb
long double sub_80A1410();
long double sub_80A142E();
float *__cdecl sub_80A1442(float *a1, float *a2);
float *__cdecl sub_80A14BA(float a1, float a2, float *a3);
int __cdecl sub_80A1516(float a1, float a2, float *a3);
int __cdecl sub_80A158C(int, float, int); // idb
int __cdecl sub_80A15FA(int a1, float *a2, int a3);
int __cdecl sub_80A16B2(int a1, float *a2, int a3);
int __cdecl sub_80A1788(int a1, float *a2, int a3);
long double __cdecl sub_80A1866(float a1, float a2, float a3, float a4);
void __cdecl sub_80A1902(float a1, float a2, float a3, float a4);
long double __cdecl sub_80A1986(float a1, float a2, float a3, float a4);
void __cdecl sub_80A1A02(float, float, float, float);
long double __cdecl sub_80A1B68(float a1);
int __cdecl DirToByte(float *a1);
void __cdecl Vec3Distance(float *, float *);
long double __cdecl sub_80A1DB2(float *a1, float *a2);
void __cdecl sub_80A1E7C(float *a1, float *a2);
long double __cdecl sub_80A1EA8(float *a1, float *a2);
float *__cdecl sub_80A1ED8(float *a1, float *a2, float *a3);
_DWORD *__cdecl sub_80A1FA2(float *a1, _DWORD *a2, _DWORD *a3);
long double __cdecl Vec3Normalize(float *a1);
long double __cdecl sub_80A215E(float *a1);
long double __cdecl sub_80A21D6(float *a1);
long double __cdecl sub_80A2298(float *a1, int a2);
long double __cdecl sub_80A2342(float *a1, int a2);
float *__cdecl sub_80A2672(int a1, int a2, float *a3, float a4);
float *__cdecl sub_80A28D8(float *a1, float a2);
float *__cdecl sub_80A295E(int a1, int a2, float *a3);
long double __cdecl sub_80A29F6(float *a1);
long double __cdecl sub_80A2A84(float *a1);
long double __cdecl sub_80A2AF6(float *a1);
long double __cdecl sub_80A2BC8(float *a1);
int __cdecl vectoangles(float *a1, int a2);
int __cdecl sub_80A2DBE(float *a1, int a2);
void __cdecl AngleVectors(float *a1, int a2, float *a3, float *a4);
void __cdecl sub_80A303A(float a1, int *a2, int *a3);
void __cdecl sub_80A30BA(float *a1, float *a2);
void __cdecl sub_80A318C(float *a1, float *a2, float *a3, float *a4);
int __cdecl sub_80A3416(_DWORD *s);
void *__cdecl sub_80A345E(void *dest);
float *__cdecl sub_80A358E(float *a1, float *a2, float *a3);
float *__cdecl sub_80A3C8E(float *a1, float *a2, float *a3);
int __cdecl sub_80A442E(_DWORD *a1, _DWORD *a2);
float *__cdecl sub_80A45BE(float *a1, float *a2);
float *__cdecl sub_80A47DE(int a1, int a2);
float *__cdecl sub_80A4E52(float *a1, float *a2, float *a3);
float *__cdecl sub_80A5028(float *a1, float *a2, float *a3);
float *__cdecl sub_80A50D2(float *a1, float *a2, float *a3);
float *__cdecl sub_80A5194(float *a1, float *a2, float *a3);
int __cdecl sub_80A530C(float *a1, float a2);
float *__cdecl sub_80A5372(float *a1, float *a2, float *a3);
unsigned int __cdecl sub_80A5494(_DWORD *a1, unsigned int *a2);
float *__cdecl sub_80A54E2(float *a1, float *a2);
long double __cdecl sub_80A5662(float *a1);
long double __cdecl sub_80A5706(float a1);
long double __cdecl sub_80A5774(float *a1);
void __cdecl sub_80A57E8(float a1, int a2);
void __cdecl sub_80A5834(float a1, int a2);
void __cdecl sub_80A5880(float a1, int a2);
float *__cdecl sub_80A58CC(float a1, float *a2, float *a3);
int __cdecl sub_80A5918(_DWORD *a1, float a2);
int __cdecl sub_80A59B0(int *a1, float a2);
int __cdecl sub_80A5A48(int *a1, float a2);
int __cdecl sub_80A5AE0(float *s, float a2, float a3, int a4);
int __cdecl sub_80A5B9C(float *s, float a2, float a3, float a4);
long double __cdecl sub_80A5F4C(float a1);
long double __cdecl sub_80A6000(float a1, float a2);
float *__cdecl sub_80A6062(float *a1, float *a2, float *a3);
long double __cdecl sub_80A60CE(float a1);
long double __cdecl sub_80A6112(float a1);
long double __cdecl sub_80A6154(float a1);
long double __cdecl sub_80A61D2(float a1);
void __cdecl sub_80A6258(float, float);
void __cdecl sub_80A626E(int, int);
void __cdecl sub_80A62FC(int, int);
// void __usercall sub_80A6450(long double a1@<st0>, float *a2, float *a3);
void __cdecl sub_80A64CE(float *a1, float *a2);
void __cdecl sub_80A660A(float *a1, float *a2, float *a3);
void __cdecl sub_80A6B48(float *a1, float *a2, float *a3, float *a4);
void __cdecl sub_80A6CC8(int a1, int a2, int a3, int a4);
int __cdecl sub_80A6FE6(_DWORD *a1, _DWORD *a2);
float *__cdecl sub_80A70C0(float *a1, float a2, float a3, float a4, float *a5);
float *__cdecl sub_80A7146(float *a1, int a2);
float *__cdecl sub_80A718E(float a1, int a2);
int __cdecl sub_80A71F4(int a1, int a2);
int __cdecl sub_80A7338(int a1, int a2);
int __cdecl sub_80A7CE6(float *a1, float *a2, float *a3, float *a4);
float *__cdecl sub_80A7D80(float *a1, float *a2, float *a3);
int __cdecl sub_80A7E1A(float *a1, float *a2, int a3);
int __cdecl sub_80A81F8(float *a1, float a2, float *a3, float a4, float a5, float a6, float a7);
_BOOL4 __cdecl sub_80A831C(float *a1, float *a2, float *a3, float a4);
int __cdecl sub_80A84C6(_DWORD *a1, int a2, _DWORD *a3);
float *__cdecl sub_80A8610(float *a1, int a2, float *a3, float *a4);
float *__cdecl sub_80A8664(float *a1, float a2, float a3);
void __cdecl sub_80A86CC(float, float *);
int __cdecl sub_80A8712(int a1);
long double __cdecl sub_80A8720(float a1, float a2);
int __cdecl sub_80A8776(int a1, int a2);
float *__cdecl sub_80A87D8(float *a1, float *a2);
void __cdecl sub_80A8972(float a1, float *a2, float *a3);
long double __cdecl sub_80A8A66(float a1, int a2, char a3);
long double __cdecl sub_80A8B40(float a1);
long double __cdecl sub_80A8B5A(float a1);
void __cdecl sub_80A8B7A(float, float);
long double __cdecl sub_80A8B9E(float a1, float a2, float a3);
int __cdecl sub_80A8BDC(int a1);
int __cdecl sub_80A8BE6(float); // idb
void __cdecl sub_80A8C1C(float a1, float *a2, float *a3);
double *__cdecl sub_80A8C4A(double a1, double *a2, double *a3);
int __cdecl sub_80A8C78(_DWORD *a1);
int __cdecl sub_80A8C94(_DWORD *a1, int a2, int a3);
float *__cdecl sub_80A8CAC(float *a1, float *a2, float *a3);
long double __cdecl sub_80A8CD8(float *a1, float *a2);
void __cdecl sub_80A8CFA(float *a1);
int __cdecl sub_80A8D26(_DWORD *a1);
int __cdecl sub_80A8D50(_DWORD *a1, int a2, int a3, int a4);
int __cdecl sub_80A8D74(_DWORD *a1, _DWORD *a2);
float *__cdecl sub_80A8DA4(float *a1, float *a2, float *a3);
float *__cdecl sub_80A8DE8(float *a1, float *a2, float *a3);
float *__cdecl sub_80A8E2C(float *a1, float a2, float *a3);
float *__cdecl sub_80A8E64(float *a1, float *a2, float *a3);
float *__cdecl sub_80A8EA8(float *a1, float a2, float *a3, float *a4);
long double __cdecl sub_80A8EFC(float *a1, float *a2);
int __cdecl sub_80A8F30(float *a1, float *a2);
void __cdecl sub_80A8F9A(float *a1);
float *__cdecl sub_80A8FD8(float *a1, float a2, float *a3);
long double __cdecl sub_80A9024(float *a1);
long double __cdecl sub_80A906A(float a1, float a2, float a3);
float *__cdecl sub_80A9094(float *a1, float *a2, float *a3);
float *__cdecl sub_80A913C(float *a1, float *a2);
void __cdecl Z_FreeInternal(void *ptr);
void __cdecl Z_VirtualFreeInternal(void *ptr);
void __cdecl __noreturn Sys_OutOfMemErrorInternal(_DWORD); // weak
void *__cdecl MallocInternal(size_t size);
void *__cdecl Z_TryMallocInternal(size_t size);
void *__cdecl Z_MallocInternal(size_t size);
void *__cdecl Z_MallocGarbageInternal(size_t size);
void *__cdecl VirtualAlloc(size_t size);
void *__cdecl Z_VirtualAllocInternal(size_t size);
char *__cdecl CopyStringInternal(char *src);
char *__cdecl ReplaceStringInternal(char **a1, char *src);
void Com_Meminfo_f();
void Com_TouchMemory();
// void __usercall Com_InitHunkMemory(long double a1@<st0>);
void *Hunk_Shutdown();
int __cdecl Hunk_FindDataForFileInternal(int, char *s2, int); // idb
int __cdecl Hunk_FindDataForFile(int, char *s2); // idb
_BOOL4 __cdecl Hunk_DataOnHunk(size_t a1);
int __cdecl Hunk_SetDataForFile(char a1, char *src, int a3, int (__cdecl *a4)(size_t));
int __cdecl Hunk_AddData(char a1, int a2, int (__cdecl *a3)(int));
int __cdecl Hunk_OverrideDataForFile(int, char *s2, int); // idb
unsigned int *__cdecl Hunk_ClearDataFor(unsigned int *a1, unsigned int a2, unsigned int a3);
unsigned int *Hunk_ClearData();
int __cdecl sub_80A9A8E(int a1, int a2, void (__cdecl *a3)(_DWORD, int), int a4);
unsigned int *__cdecl sub_80A9AEC(unsigned int *a1, void (__cdecl *a2)(_DWORD, int), int a3, char a4);
int Hunk_SetMark();
unsigned int *__cdecl Hunk_ClearHigh(int a1);
unsigned int *__cdecl Hunk_ClearLow(int a1);
unsigned int *Hunk_Clear();
void *__cdecl Hunk_AllocInternal(size_t n);
void *__cdecl Hunk_AllocAlignInternal(size_t n, int a2);
size_t __cdecl Hunk_AllocateTempMemoryHighInternal(int a1);
int Hunk_ClearTempMemoryHighInternal();
void *__cdecl Hunk_AllocLowInternal(size_t n);
void *__cdecl Hunk_AllocLowAlignInternal(size_t n, int a2);
int Hunk_ConvertTempToPermLowInternal();
_DWORD *__cdecl Hunk_AllocateTempMemoryInternal(size_t size);
unsigned int __cdecl Hunk_ReallocateTempMemoryInternal(int a1);
void __cdecl Hunk_FreeTempMemory(_DWORD *ptr);
int Hunk_ClearTempMemoryInternal();
int Hunk_HideTempMemory();
int __cdecl Hunk_ShowTempMemory(int a1);
int __cdecl sub_80AA194(int a1);
int __cdecl sub_80AA1BC(int a1);
char *__cdecl sub_80AA1CA(int a1);
int __cdecl LargeLocal(int *a1, int a2);
int __cdecl LargeLocalDealloc(int *a1);
char *__cdecl LargeLocalGetBuf(int *a1);
void LargeLocalReset();
char *__cdecl sub_80AA268(char *s, char *a2, int (__cdecl *a3)(char *, char *));
int __cdecl Com_Filter(char *a1, char *a2, int a3);
int __cdecl Com_FilterPath(int a1, int a2, int a3);
int __cdecl sub_80AA70C(int a1, int a2);
void *__cdecl Com_Memcpy(void *dest, void *src, size_t n);
void *__cdecl Com_Memset(void *s, int c, size_t n);
int __cdecl sub_80AA860(_BYTE *a1);
int __cdecl sub_80AA8AA(char *a1);
int __cdecl sub_80AA91A(char **a1);
int __cdecl SND_GetAliasWithOffset(char *a1, int a2);
int __cdecl sub_80AAA06(char *a1, int a2);
char *__cdecl sub_80AAA84(_DWORD *a1, char *s);
void sub_80AABBA();
void __cdecl Com_LoadSoundAliases(char *src, char *s2, int a3);
int __cdecl Com_UnloadSoundAliases(int a1);
int __cdecl sub_80AAF4A(char *a1);
int __cdecl sub_80AAF92(int a1);
int __cdecl sub_80AB0E2(char *a1);
int sub_80AB104();
void *sub_80AB112();
_DWORD *__cdecl sub_80AB11C(size_t size);
void *__cdecl sub_80AB130(size_t a1);
int __cdecl sub_80AB144(_BYTE *a1, _BYTE *a2, int a3);
int sub_80AB1DC();
long double __cdecl sub_80AB204(char *s1, int a2);
char *__cdecl sub_80AB28A(char *dest, char *src, char *s1);
int __cdecl sub_80AB40A(char *a1);
int __cdecl sub_80AB496(char *a1, const char *a2, int a3);
int __cdecl sub_80AB5B2(char *a1, const char *a2, int a3);
int __cdecl sub_80AB650(char *a1, const char *a2, int a3);
int __cdecl sub_80AB6C2(char *s, char *s2, char *src, const char *a4);
void __cdecl sub_80AB830(char *s1, const char *a2, int a3);
char *__cdecl sub_80AB8F4(char *haystack, char *a2);
void __cdecl Com_LoadSoundAliasField(char *a1, char *s2, const char *a3, char *s, int a5, int a6, int a7);
int __cdecl sub_80ABEF8(int a1);
int __cdecl sub_80AC1A8(_DWORD *a1);
void sub_80AC22C();
_DWORD *__cdecl Com_LoadSoundAliasFile(int a1);
void sub_80AC576();
_DWORD *__cdecl sub_80AC582(char *s1, char *s2, char *src);
int __cdecl sub_80AC880(int a1, int a2);
int __cdecl sub_80AC8A0(int a1, _DWORD *a2, int (__cdecl *a3)(char *, char *), unsigned __int8 a4);
int __cdecl sub_80ACAF4(int a1, int a2);
void __cdecl sub_80ACB66(int a1, int a2);
int __cdecl sub_80ACC2E(_DWORD *a1, int a2, int a3);
int __cdecl sub_80ACC4E(int a1, int a2, int a3, int a4, int a5);
int __cdecl sub_80ACE9A(int a1, _DWORD *a2);
int __cdecl sub_80AD3E6(char *a1, char *src, float *a3);
int __cdecl sub_80AD6F6(const char *a1, float *a2);
_DWORD *__cdecl sub_80AD920(_DWORD *a1);
int __cdecl sub_80AD964(char *a1);
char *__cdecl Com_GetSubtitleStringEdReference(char *a1);
size_t __cdecl Com_WriteStringEdReferenceToFile(char *a1, char *a2, int a3);
void __cdecl sub_80ADC96(int a1, char *a2);
void __cdecl Com_ProcessSoundAliasFileLocalization(char *a1, char *s2);
void __cdecl sub_80AEB14(char *filename, char *a2);
void Com_WriteLocalizedSoundAliasFiles();
long double __cdecl sub_80AEE5E(float a1, float a2, float a3);
long double __cdecl sub_80AEE9C(float a1, float a2, float a3);
int __cdecl Dvar_SetInAutoExec(unsigned __int8 a1);
int Dvar_IsSystemActive();
int __cdecl generateHashValue(int a1);
int __cdecl sub_80AEF62(int a1);
char *__cdecl sub_80AEFD0(int a1);
int __cdecl sub_80AF012(int a1);
void __cdecl Dvar_FreeString(int a1);
char *__cdecl Dvar_CopyString(char *src);
void __cdecl Dvar_FreeNameString(void *ptr);
char *__cdecl sub_80AF0A8(char *s);
void __cdecl sub_80AF180(char *ptr);
int __cdecl sub_80AF1CE(int a1);
int __cdecl sub_80AF20A(int a1);
int __cdecl sub_80AF246(int a1);
char *__cdecl sub_80AF282(int a1, char *s1);
char *__cdecl sub_80AF316(int a1, char *s1);
char *__cdecl sub_80AF3AA(int a1, char *s1);
void *__cdecl Dvar_EnumToString(_DWORD *a1);
void *__cdecl Dvar_IndexStringToEnumString(int a1, char *nptr);
char *__cdecl Dvar_ValueToString(int a1, float *a2);
_BOOL4 __cdecl Dvar_StringToBool(char *nptr);
int __cdecl Dvar_StringToInt(char *nptr); // idb
long double __cdecl Dvar_StringToFloat(char *nptr);
char *__cdecl Dvar_StringToVec2(char *s);
char *__cdecl Dvar_StringToVec3(char *s);
char *__cdecl Dvar_StringToVec4(char *s);
int __cdecl Dvar_StringToEnum(int *a1, char *s1);
// int __usercall Dvar_StringToColorInternal@<eax>(long double a1@<st0>, char *s, _BYTE *a3);
// float *__userpurge sub_80AFA9E@<eax>(long double a1@<st0>, float *a2, char a3, int a4, int a5, char *nptr);
char *__cdecl Dvar_DisplayableValue(int a1);
char *__cdecl Dvar_DisplayableResetValue(int a1);
char *__cdecl Dvar_DisplayableLatchedValue(int a1);
int __cdecl sub_80AFBFE(int, int, float, float); // idb
int __cdecl sub_80AFC80(int, int, float, float); // idb
// float *__userpurge sub_80AFCF6@<eax>(float *a1, char a2, int a3, int a4, float a5, float a6);
int __cdecl sub_80AFE1A(char a1, int a2, float a3, float a4);
int __cdecl Dvar_VectorDomainToString(int, int, int, char *s, size_t maxlen); // idb
char *__cdecl Dvar_DomainToString_Internal(char a1, int a2, int a3, char *s, size_t maxlen, _DWORD *a6);
char *__cdecl sub_80B0410(char a1, int a2, int a3, char *s, size_t maxlen);
char *__cdecl sub_80B045A(char a1, int a2, int a3, char *s, size_t maxlen, _DWORD *a6);
void __cdecl Dvar_PrintDomain(char a1, int a2, int a3);
int __cdecl Dvar_ValuesEqual(char a1, char *s1, char *s2);
char *__cdecl sub_80B0620(int a1, char *s1);
int __cdecl Dvar_HasLatchedValue(int a1);
int __cdecl Dvar_IsAtDefaultValue(int a1);
void __cdecl Dvar_SetVariant(const char **a1, float *s1, int a3);
int __cdecl Dvar_FindMalleableVar(char *a1);
int __cdecl Dvar_FindVar(char *a1);
int __cdecl Dvar_ClearModified(int a1);
int __cdecl Dvar_GetBool(char *a1);
int __cdecl Dvar_GetInt(char *a1);
long double __cdecl Dvar_GetFloat(char *a1);
char *__cdecl Dvar_GetVec2(char *a1);
char *__cdecl Dvar_GetVec3(char *a1);
char *__cdecl Dvar_GetVec4(char *a1);
void *__cdecl Dvar_GetString(char *a1);
char *__cdecl Dvar_GetVariantString(char *a1);
// int __usercall Dvar_StringToColor@<eax>(long double a1@<st0>, int a2, float *a3);
// int __usercall Dvar_GetUnpackedColor@<eax>(long double a1@<st0>, char *a2, float *a3);
void *Dvar_Shutdown();
void __cdecl sub_80B0FF8(int a1);
void __cdecl sub_80B10CE(int a1, __int16 a2);
int __cdecl sub_80B1120(__int16 a1);
char *__cdecl sub_80B1164(int a1, char *s1);
char *__cdecl sub_80B1208(int a1, char *s1);
char *__cdecl sub_80B1222(int a1, char *s1);
// int __usercall sub_80B1334@<eax>(long double a1@<st0>, int a2, int a3, char a4, unsigned __int16 a5, char *s1, float a7, float a8);
// _DWORD *__userpurge sub_80B1498@<eax>(_DWORD *a1, int a2, int a3);
// int __usercall sub_80B14CC@<eax>(long double a1@<st0>, int a2, int a3, char a4, unsigned __int16 a5, int a6, int a7, int a8);
int __cdecl sub_80B15C0(int a1, int a2, int a3, __int16 a4, int a5, int a6, int a7);
void __cdecl sub_80B1634(int a1);
char *__cdecl sub_80B165C(int a1);
// void __usercall Dvar_Reregister(long double a1@<st0>, int a2, int a3, unsigned __int8 a4, unsigned __int16 a5, char *s1, int a7, int a8);
char *__cdecl Dvar_RegisterNew(char *src, unsigned __int8 a2, __int16 a3, char *s, int a5, int a6);
// char *__usercall Dvar_RegisterVariant@<eax>(long double a1@<st0>, char *src, unsigned __int8 a3, __int16 a4, char *s1, int a6, int a7);
// char *__usercall Dvar_RegisterBool@<eax>(long double a1@<st0>, char *src, char a3, __int16 a4);
// char *__usercall Dvar_RegisterInt@<eax>(long double a1@<st0>, char *src, char *a3, int a4, int a5, __int16 a6);
// char *__usercall Dvar_RegisterFloat@<eax>(long double a1@<st0>, char *src, char *a3, int a4, int a5, __int16 a6);
// char *__usercall sub_80B1C7E@<eax>(long double a1@<st0>, char *src, int a3, int a4, int a5, int a6, __int16 a7);
// char *__usercall sub_80B1CE8@<eax>(long double a1@<st0>, char *src, int a3, int a4, int a5, int a6, int a7, __int16 a8);
// char *__usercall sub_80B1D5A@<eax>(long double a1@<st0>, char *src, int a3, int a4, int a5, int a6, int a7, int a8, __int16 a9);
// char *__usercall Dvar_RegisterString@<eax>(long double a1@<st0>, char *src, char *a3, __int16 a4);
// char *__usercall sub_80B1E32@<eax>(long double a1@<st0>, char *src, int a3, char *a4, __int16 a5);
// char *__usercall sub_80B1EA0@<eax>(long double a1@<st0>, char *src, float a3, float a4, float a5, float a6, __int16 a7);
void __cdecl Dvar_SetBoolFromSource(int a1, char a2, int a3);
void __cdecl Dvar_SetIntFromSource(int a1, char *a2, int a3);
void __cdecl Dvar_SetFloatFromSource(int a1, char *a2, int a3);
void __cdecl sub_80B20F0(int a1, int a2, int a3, int a4);
void __cdecl sub_80B216A(int a1, int a2, int a3, int a4, int a5);
void __cdecl sub_80B21FC(int a1, int a2, int a3, int a4, int a5, int a6);
void __cdecl Dvar_SetStringFromSource(int a1, char *src, int a3);
// void __usercall sub_80B230A(long double a1@<st0>, int a2, float a3, float a4, float a5, float a6, int a7);
void __cdecl Dvar_SetBool(int a1, char a2);
void __cdecl Dvar_SetInt(int a1, char *a2);
void __cdecl Dvar_SetFloat(int a1, char *a2);
void __cdecl sub_80B24CE(int a1, int a2, int a3);
void __cdecl sub_80B24F8(int a1, int a2, int a3, int a4);
void __cdecl sub_80B2528(int a1, int a2, int a3, int a4, int a5);
void __cdecl Dvar_SetString(int a1, char *src);
// void __usercall sub_80B2582(long double a1@<st0>, int a2, float a3, float a4, float a5, float a6);
// void __usercall Dvar_SetFromStringFromSource(long double a1@<st0>, const char **a2, char *src, int a4);
// void __usercall Dvar_SetFromString(long double a1@<st0>, const char **a2, char *src);
// void __usercall Dvar_SetBoolByName(long double a1@<st0>, char *src, char a3);
// void __usercall Dvar_SetIntByName(long double a1@<st0>, char *src, char *a3);
void __cdecl Dvar_SetFloatByName(char *src, char *a2);
void __cdecl sub_80B27EC(char *src, int a2, int a3);
void __cdecl sub_80B2854(char *src, int a2, int a3, int a4);
void __cdecl sub_80B28CA(char *src, int a2, int a3, int a4, int a5);
// void __usercall Dvar_SetStringByName(long double a1@<st0>, char *src, char *a3);
// void __usercall sub_80B2998(long double a1@<st0>, char *src, unsigned __int8 a3, unsigned __int8 a4, unsigned __int8 a5, unsigned __int8 a6);
// char *__usercall sub_80B2A6A@<eax>(long double a1@<st0>, char *src, char *a3, int a4);
// char *__usercall sub_80B2AC2@<eax>(long double a1@<st0>, char *src, char *a3);
// char *__usercall Dvar_SetCommand@<eax>(long double a1@<st0>, char *src, char *a3);
int __cdecl Dvar_AddFlags(int a1, int a2);
void __cdecl Dvar_Reset(int a1, int a2);
int sub_80B2B80();
// void __usercall Dvar_Init(long double a1@<st0>);
_WORD *sub_80B2C06();
int sub_80B2C3C();
size_t __cdecl sub_80B2C82(int a1, unsigned __int16 a2);
// int __usercall sub_80B2D56@<eax>(long double a1@<st0>, int a2, int a3);
int __cdecl sub_80B2E34(unsigned __int16 a1, int a2);
int __cdecl sub_80B2E78(int, int, char *s, size_t maxlen); // idb
// int __usercall sub_80B2F1A@<eax>(long double a1@<st0>, int a2, int n, char *a4, char *src);
void __cdecl sub_80B30FE(float, float);
void __cdecl sub_80B3122(float, float);
int __cdecl sub_80B3146(float); // idb
int __cdecl sub_80B317C(_DWORD *a1);
int __cdecl sub_80B3198(_DWORD *a1, int a2, int a3);
int __cdecl sub_80B31B0(_DWORD *a1, _DWORD *a2);
int __cdecl sub_80B31D0(float *a1, float *a2);
int __cdecl sub_80B321E(_DWORD *a1);
int __cdecl sub_80B3248(_DWORD *a1, int a2, int a3, int a4);
int __cdecl sub_80B326C(_DWORD *a1, _DWORD *a2);
int __cdecl sub_80B329C(float *a1, float *a2);
int __cdecl sub_80B3306(_DWORD *a1);
int __cdecl sub_80B333C(_DWORD *a1, int a2, int a3, int a4, int a5);
int __cdecl sub_80B336A(_DWORD *a1, _DWORD *a2);
int __cdecl sub_80B33AA(float *a1, float *a2);
_DWORD *__cdecl sub_80B3432(_DWORD *a1, _DWORD *a2);
_BOOL4 __cdecl sub_80B3442(_DWORD *a1, _DWORD *a2);
int __cdecl sub_80B3458(_BYTE *a1, _BYTE *a2, int a3);
long double __cdecl sub_80B34F0(float a1, float a2, float a3);
int __cdecl sub_80B351C(int a1, size_t n, void *src);
int __cdecl sub_80B353E(int a1, int a2, int a3, char a4);
void *__cdecl sub_80B35E6(void *s);
int __cdecl sub_80B3636(int, size_t n, void *src); // idb
int __cdecl sub_80B36E4(int, char *s); // idb
int __cdecl sub_80B3710(int a1, int a2);
int __cdecl MemFile_ReadData(int, size_t n, void *dest); // idb
void *__cdecl MemFile_ReadCString(int a1);
void *Com_GetParseThreadInfo();
int __cdecl Com_InitParseInfo(int a1);
char *__cdecl Com_BeginParseSession(char *src);
_DWORD *Com_EndParseSession();
_DWORD *Com_ResetParseSessions();
bool __cdecl sub_80B3B00(int a1);
int sub_80B3B6C();
void __noreturn Com_ScriptErrorDrop(char *format, ...);
void Com_ScriptWarning(char *format, ...);
int Com_UngetToken();
int __cdecl Com_ParseSetMark(_DWORD *a1, _DWORD *a2);
int __cdecl Com_ParseReturnToMark(_DWORD *a1, _DWORD *a2);
_BYTE *__cdecl SkipWhitespace(_BYTE *a1, _DWORD *a2);
int __cdecl Com_Compress(_BYTE *a1);
int Com_GetLastTokenPos();
_BYTE *__cdecl Com_ParseCSV(_BYTE **a1, int a2);
char *__cdecl Com_ParseExt(char **a1, int a2);
char *__cdecl Com_Parse(char **a1);
char *__cdecl Com_ParseOnLine(char **a1);
int __cdecl Com_MatchToken(char **a1, char *s2, int a3);
int __cdecl sub_80B494C(char **a1, int a2);
_BYTE *__cdecl Com_SkipRestOfLine(_DWORD *a1);
int __cdecl Com_GetArgCountOnLine(char **a1);
char *__cdecl sub_80B4A72(char **a1);
long double __cdecl sub_80B4AEE(char **a1);
long double __cdecl sub_80B4B1C(char **a1);
int __cdecl sub_80B4B4A(char **a1);
int __cdecl sub_80B4B6C(char **a1);
int __cdecl sub_80B4B8E(char **a1, int a2, int a3);
int __cdecl sub_80B4C14(char **a1, int a2, int a3, int a4);
int __cdecl sub_80B4C8E(char **a1, int a2, int a3, int a4, int a5);
int __cdecl ColorIndex(char a1);
_BYTE *__cdecl sub_80B4D44(_BYTE *a1);
void *__cdecl sub_80B4D74(char *src, char *s, char *a3, char *dest, int a5);
_BYTE *__cdecl Com_GetExtensionSubString(_BYTE *a1);
_BYTE *__cdecl sub_80B4E98(_BYTE *a1, _BYTE *a2);
char *__cdecl sub_80B4ED6(_BYTE *src, char *dest);
char *__cdecl Com_DefaultExtension(char *s, size_t maxlen, const char *a3);
int __cdecl BigShort(__int16 a1);
int __cdecl sub_80B4FB8(int a1);
int __cdecl sub_80B4FCE(int a1, int a2);
int __cdecl sub_80B4FF6(__int16 a1);
int __cdecl sub_80B5014(int a1);
int __cdecl sub_80B502A(int a1);
int __cdecl sub_80B5040(int a1);
int __cdecl sub_80B5056(__int16 a1);
int __cdecl sub_80B508E(__int16 a1);
int __cdecl sub_80B50A2(int a1);
int __cdecl sub_80B50FE(int a1);
unsigned __int64 __cdecl sub_80B5106(__int64 a1);
__int64 __cdecl sub_80B5242(__int64 a1);
long double __cdecl sub_80B525C(int a1);
void __cdecl sub_80B5290(float a1);
int __cdecl sub_80B52A4(int a1);
int __cdecl sub_80B52D2(char a1);
void sub_80B52E6();
void sub_80B5332();
void Swap_Init();
int __cdecl sub_80B53C8(int a1);
int __cdecl sub_80B53EE(int a1);
int __cdecl sub_80B5414(int a1);
int __cdecl sub_80B5448(int a1);
int __cdecl sub_80B546E(int a1);
char *__cdecl I_strncpyz(char *dest, char *src, int a3);
int __cdecl sub_80B550A(char *a1, char *a2, int a3);
int __cdecl I_strncmp(char *a1, char *a2, int a3);
int __cdecl I_stricmp(char *a1, char *a2);
int __cdecl sub_80B5642(char *a1, char *a2);
int __cdecl sub_80B5664(char *a1, char *a2);
_BYTE *__cdecl I_strlwr(_BYTE *a1);
_BYTE *__cdecl I_strupr(_BYTE *a1);
char *__cdecl I_strncat(char *s, int a2, char *src);
int __cdecl sub_80B5814(_BYTE *a1);
char *__cdecl sub_80B587C(char *a1);
int __cdecl I_CleanChar(char a1);
int Com_sprintf(char *s, size_t maxlen, char *format, ...);
_BOOL4 __cdecl sub_80B5970(unsigned int a1);
char *va(char *format, ...);
int __cdecl Com_InitThreadData(int a1);
char *__cdecl Info_ValueForKey(char *s, char *a2);
char *__cdecl sub_80B5D40(char *s, char *s1);
char *__cdecl sub_80B5E72(char *s, char *s1);
_BOOL4 __cdecl sub_80B5FA4(char *s);
void __cdecl Info_SetValueForKey(char *s, char *s1, int a3);
void __cdecl sub_80B622A(char *s, char *s1, int a3);
_BOOL4 __cdecl sub_80B645E(int a1, int a2, int a3, char *s, int a5, int (__cdecl *a6)(int, char *, _DWORD), void (__cdecl *a7)(int, char *));
long double __cdecl sub_80B6688(float a1);
long double __cdecl sub_80B66A6(float a1);
void __cdecl sub_80B66C0(float *a1, int a2, float a3, float a4, float a5);
float *__cdecl sub_80B6758(float *a1, float *a2, float *a3);
float *__cdecl sub_80B6806(float *a1, float *a2, float *a3);
float *__cdecl sub_80B68EE(float *a1, float *a2, float *a3);
float *__cdecl sub_80B6998(float *a1, float *a2, float *a3);
long double __cdecl sub_80B6D1E(float a1);
long double __cdecl sub_80B6D38(float a1);
int __cdecl sub_80B6D58(int a1);
long double __cdecl sub_80B6D62(float a1);
int __cdecl sub_80B6D74(_DWORD *a1, int a2, int a3, int a4);
float *__cdecl sub_80B6D98(float *a1, float a2, float *a3, float *a4);
long double __cdecl sub_80B6DEC(float *a1, float *a2);
int __cdecl sub_80B6E20(char *s1); // idb
const char *__cdecl sub_80B6EB2(int a1);
int DObjInit();
int DObjShutdown();
void DObjAbort();
void __cdecl sub_80B6F74(int a1);
int __cdecl sub_80B712C(int a1, int a2);
int __cdecl DObjCreateDuplicateParts(int a1);
int __cdecl sub_80B73C0(int a1, int a2, int a3);
int *__cdecl sub_80B75A8(int a1, int a2);
int __cdecl sub_80B7796(int a1, int a2);
int __cdecl sub_80B77C2(int a1, int a2);
int *__cdecl sub_80B7822(int a1, int a2);
_DWORD *__cdecl sub_80B7D70(_DWORD *a1, int a2);
int __cdecl sub_80B7DFC(int a1);
int __cdecl sub_80B7EFC(__int16 ***a1, unsigned int a2, int a3, int a4, __int16 a5);
_DWORD *__cdecl sub_80B812E(const void *a1, int a2, int a3);
int __cdecl sub_80B819E(int a1);
int __cdecl sub_80B821A(unsigned __int8 *a1, _DWORD *a2, _WORD *a3, _DWORD *a4, _WORD *a5);
int __cdecl sub_80B8380(int a1);
_BOOL4 __cdecl DObjSkelExists(int a1, int a2);
int __cdecl sub_80B840A(int a1);
int *__cdecl sub_80B8424(int a1, int a2, int *a3);
int __cdecl sub_80B8490(int a1, int a2);
int __cdecl sub_80B84A0(int a1, _DWORD *a2, _DWORD *a3);
int __cdecl sub_80B84D2(int a1);
int __cdecl sub_80B858C(int a1, int a2, int a3);
int __cdecl sub_80B8616(int a1, int a2, int a3);
const char *__cdecl sub_80B8768(int a1, int a2, int a3, int a4);
int __cdecl sub_80B87BE(int, int, void *s, int); // idb
int __cdecl sub_80B8AF6(int a1, int a2);
int __cdecl sub_80B8B16(int a1, int a2);
int __cdecl sub_80B8BB6(int a1);
int __cdecl sub_80B8BC0(int a1);
int __cdecl sub_80B8C0C(int a1);
float *__cdecl sub_80B8C18(float *a1, float *a2, float *a3);
void __cdecl sub_80B8CA6(int a1, float *a2, float *a3, int a4, int a5);
int __cdecl sub_80B955A(int a1, float *a2, float *a3, int a4, int a5);
int __cdecl sub_80B9676(int, int, float); // idb
long double __cdecl sub_80B9698(int a1);
int __cdecl sub_80B96F8(int a1, int a2);
float *__cdecl sub_80B9748(int a1, _DWORD *a2, float *a3, int a4);
int __cdecl sub_80B98CC(int a1, int a2, int a3, float *a4);
int __cdecl sub_80B994A(int a1, int a2, int a3, _DWORD *a4, float *a5);
int __cdecl sub_80B99C6(int a1, int a2, int a3, _DWORD *a4, float *a5);
void __cdecl sub_80B9A48(float);
void __cdecl sub_80B9A6E(float a1, float *a2, float *a3);
int __cdecl sub_80B9A9C(_DWORD *a1, _DWORD *a2);
long double __cdecl sub_80B9ABC(float *a1, float *a2);
int __cdecl sub_80B9ADE(_DWORD *a1);
int __cdecl sub_80B9B08(_DWORD *a1, int a2, int a3, int a4);
int __cdecl sub_80B9B2C(_DWORD *a1, _DWORD *a2);
float *__cdecl sub_80B9B5C(float *a1, float *a2, float *a3);
float *__cdecl sub_80B9BA0(float *a1, float *a2, float *a3);
float *__cdecl sub_80B9BE4(float *a1, float a2, float *a3);
float *__cdecl sub_80B9C1C(float *a1, float a2, float *a3, float *a4);
long double __cdecl sub_80B9C70(float *a1, float *a2);
long double __cdecl sub_80B9CA4(float *a1);
int __cdecl sub_80B9CD8(_DWORD *a1, int a2, int a3, int a4, int a5);
long double __cdecl sub_80B9D06(float a1, float a2, float a3);
long double __cdecl sub_80B9D30(float *a1);
int __cdecl sub_80B9D76(int a1);
int __cdecl sub_80B9DC6(float *a1, float *a2);
int __cdecl sub_80B9E7A(float *a1, float *a2);
int __cdecl sub_80B9FB2(float *a1, float *a2);
bool XAnimInit();
int XAnimShutdown();
void XAnimAbort();
int __cdecl XAnimFree(int a1);
int __cdecl sub_80BA2DE(char *s2); // idb
int __cdecl sub_80BA2FA(const void *a1, int (__cdecl *a2)(int));
unsigned __int16 *__cdecl sub_80BA3AE(char *src, int (__cdecl *a2)(int));
char *__cdecl sub_80BA4D8(int a1, int a2, char *s);
char *__cdecl sub_80BA57A(int a1, int a2, char *s, __int16 a4, unsigned int a5, __int16 a6);
char **__cdecl sub_80BA626(char *s, int a2, int (__cdecl *a3)(int));
int __cdecl sub_80BA6D0(int a1, int (__cdecl *a2)(int, int));
int __cdecl XAnimFreeList(int a1);
int __cdecl sub_80BA7BC(int a1);
_DWORD *__cdecl sub_80BA7E4(int a1, int (__cdecl *a2)(int));
int __cdecl sub_80BA836(_DWORD *a1, int (__cdecl *a2)(_DWORD *, int));
int __cdecl sub_80BA87C(int a1);
int __cdecl sub_80BA886(int a1, int a2, int a3);
__int16 __cdecl sub_80BAACE(float a1, int a2, int a3);
__int16 *__cdecl sub_80BAB16(unsigned __int16 *a1, float a2, float *a3);
__int16 *__cdecl sub_80BAB6C(unsigned __int16 *a1, float a2, float *a3);
float *__cdecl sub_80BABCE(unsigned __int16 *a1, float a2, float *a3);
int __cdecl sub_80BAC36(int, int, float, int, int); // idb
int __cdecl sub_80BAD76(int a1, _DWORD *a2, int a3);
__int16 *__cdecl sub_80BADE6(unsigned __int16 *a1, float *a2);
int __cdecl sub_80BAE2E(int a1, int a2);
int __cdecl sub_80BAE6E(unsigned __int16 *a1, _DWORD *a2);
int __cdecl sub_80BAEBA(unsigned __int16 **a1, _DWORD *a2);
int __cdecl sub_80BAEEC(int a1, int a2, int a3, int *a4, float *a5);
int __cdecl sub_80BB060(int a1, int a2, int a3, int *a4, float *a5);
__int16 *__cdecl sub_80BB0BA(__int16 *a1, float a2, int a3, float *a4);
int __cdecl sub_80BB15E(int a1, float a2, int a3, int a4);
float *__cdecl sub_80BB1AC(unsigned __int16 *a1, float a2, int a3, float *a4);
float *__cdecl sub_80BB25E(unsigned __int16 **a1, float a2, int a3, float *a4);
int __cdecl sub_80BB29E(int a1, int a2, int a3, int *a4, float *a5);
int __cdecl sub_80BB444(int a1, int a2, int a3, int *a4, float *a5);
__int16 *__cdecl sub_80BB49E(__int16 *a1, float a2, int a3, float *a4);
int __cdecl sub_80BB542(int a1, float a2, int a3, int a4);
float *__cdecl sub_80BB590(unsigned __int16 *a1, float a2, int a3, float *a4);
float *__cdecl sub_80BB642(unsigned __int16 **a1, float a2, int a3, float *a4);
float *__cdecl sub_80BB682(unsigned __int16 *a1, float a2, int a3, float *a4);
void __cdecl sub_80BB77C(float *a1, float *a2);
float *__cdecl sub_80BB82A(int a1, float a2, float a3, float a4, float *a5, int a6);
float *__cdecl sub_80BB9A8(unsigned __int16 *a1, float a2, float a3, float *a4);
int __cdecl sub_80BBA2E(int a1);
int __cdecl sub_80BBA62(int a1, int a2);
long double __cdecl sub_80BBAD0(_DWORD *a1, int a2);
int __cdecl sub_80BBC06(int, float); // idb
long double __cdecl sub_80BBC94(int a1, int a2, float a3, float a4);
long double __cdecl sub_80BBDC8(int a1, float *a2, int a3, int a4, int a5, float a6);
int __cdecl sub_80BBED6(int, int, float, int); // idb
void __cdecl sub_80BBF7C(int a1, int a2, float a3);
void __cdecl sub_80BC382(_DWORD *a1, int a2, unsigned __int8 a3, int a4, float a5);
void __cdecl sub_80BC52E(_DWORD *a1, int a2, float a3, unsigned __int8 a4);
_WORD *__cdecl sub_80BC8C8(_WORD *a1);
int __cdecl sub_80BC912(int a1, int a2);
int __cdecl sub_80BCA42(int a1);
int __cdecl sub_80BCAB4(_DWORD *a1, int a2);
int __cdecl sub_80BCB3A(_DWORD *a1, int a2, int a3, float a4, char a5, _BYTE *a6, _BYTE *a7);
int __cdecl sub_80BCE1C(int a1, int a2, int a3);
long double __cdecl sub_80BCE56(_DWORD *a1, float *a2, unsigned __int16 *a3, int a4, int a5, float a6);
long double __cdecl sub_80BCF74(_DWORD *a1, int a2, float a3);
void __cdecl sub_80BD2FC(int a1, float *a2, int a3, float a4);
void __cdecl sub_80BD62C(int a1, int a2, float a3, int a4, unsigned __int8 a5, unsigned __int8 a6, int a7, int a8);
void __cdecl sub_80BDE00(int *a1, int a2, int a3);
void __cdecl sub_80BE1F4(int a1, int a2, float a3, unsigned __int8 a4, unsigned __int8 a5, _DWORD *a6);
long double __cdecl sub_80BE760(int a1, int a2);
int __cdecl sub_80BE794(int a1, int a2);
long double __cdecl sub_80BE7D2(int a1, int a2);
long double __cdecl sub_80BE816(int a1, int a2);
int __cdecl sub_80BE8E4(int a1, int a2);
int __cdecl sub_80BE8F4(int a1, int a2, int a3);
void *__cdecl sub_80BE908(int a1, int a2);
int __cdecl sub_80BE940(int a1);
char *__cdecl sub_80BE94C(int a1, int a2);
int __cdecl sub_80BEA0E(int a1);
int __cdecl sub_80BEA18(int a1);
int *__cdecl sub_80BEA24(int *a1, int *a2, float a3);
_DWORD **__cdecl sub_80BEA94(_DWORD **a1, float a2);
void __cdecl sub_80BEAEE(_DWORD **a1, float a2);
int __cdecl sub_80BEB76(_DWORD **a1, float a2, int a3);
int __cdecl sub_80BEC88(int a1, int a2);
void __cdecl sub_80BEEE4(int **a1);
int __cdecl sub_80BEF2C(int a1, int a2, _DWORD *a3, _DWORD *a4, char a5);
int __cdecl sub_80BEFE2(int a1, int a2, _DWORD *a3, _DWORD *a4);
int __cdecl XAnimGetRelDelta(int a1, int a2, _DWORD *a3, _DWORD *a4, float a5, float a6);
int __cdecl sub_80BF1A4(int a1, int a2, _DWORD *a3, _DWORD *a4, float a5);
int __cdecl sub_80BF2AE(int a1, int a2);
int __cdecl sub_80BF346(int a1, int a2, float a3);
int __cdecl sub_80BF3FE(_DWORD *a1, int a2, float a3);
int __cdecl sub_80BF482(_DWORD *a1, int a2, float a3);
int __cdecl sub_80BF4DC(_DWORD *a1, int a2, float a3, float a4);
void __cdecl sub_80BF62C(_DWORD *a1, int a2, float a3, float a4, int a5, int a6, int a7);
int __cdecl sub_80BF6AC(_DWORD *a1, int a2, int a3, float a4, float a5, int a6, int a7, int a8);
int __cdecl sub_80BF81E(_DWORD *a1, int a2, float a3, float a4, int a5, int a6, int a7);
int __cdecl sub_80BF89E(_DWORD *a1, int a2, float a3);
int __cdecl sub_80BF8F8(_DWORD *a1, int a2);
int __cdecl sub_80BF980(int a1);
int __cdecl sub_80BFA1E(_DWORD *a1);
int __cdecl sub_80BFA44(_DWORD *a1, int a2);
int __cdecl sub_80BFB06(_DWORD *a1, int a2, float a3, float a4, int a5, char a6, int a7, __int16 a8);
int __cdecl sub_80BFD38(int a1, int a2, int a3);
void *__cdecl sub_80BFD6A(size_t n);
int __cdecl sub_80BFD86(_DWORD *a1, int a2, unsigned __int8 a3);
int __cdecl sub_80BFF8E(_DWORD *a1, int a2);
int __cdecl sub_80C006C(_DWORD *a1);
int __cdecl sub_80C0088(int a1, int a2);
_BOOL4 __cdecl sub_80C00CA(int a1, int a2);
char *__cdecl sub_80C00E2(int a1, int a2, int a3);
void __cdecl sub_80C0164(_DWORD *a1, float *a2, _WORD *a3);
int __cdecl sub_80C01C8(_DWORD *a1, int a2);
int __cdecl sub_80C02D8(_DWORD *a1, int a2, int a3);
int __cdecl sub_80C0354(_DWORD *a1, int a2, float a3, int a4, int a5, int a6, __int16 a7, int a8);
int __cdecl sub_80C03EA(int a1, int a2, int a3);
int __cdecl sub_80C040C(int a1, int a2);
int __cdecl sub_80C044E(int a1, int a2, int a3);
void __cdecl sub_80C04C6(_DWORD *a1, int a2, float a3, int a4, int a5, int a6, __int16 a7, int a8);
int __cdecl sub_80C05DA(_DWORD *a1, _DWORD *a2);
int __cdecl sub_80C063C(int a1, int a2);
int __cdecl sub_80C072E(_DWORD *a1, int a2);
int __cdecl sub_80C078E(int a1, int a2);
void __cdecl sub_80C0820(int a1, unsigned __int16 *a2, float a3, float *a4);
void __cdecl sub_80C08C6(int a1, unsigned __int16 *a2, float a3, float *a4);
void __cdecl sub_80C096C(int a1, unsigned __int16 *a2, float a3, float *a4);
int __cdecl sub_80C0A1E(unsigned __int16 *a1, int a2, int a3, float a4, int a5, int a6);
void __cdecl sub_80C0B94(int a1, unsigned __int16 *a2, float a3, float *a4);
void __cdecl sub_80C0C3A(int a1, unsigned __int16 *a2, float a3, float *a4);
void __cdecl sub_80C0CE0(int a1, unsigned __int16 *a2, float a3, float *a4);
int __cdecl sub_80C0D92(unsigned __int16 *a1, int a2, int a3, float a4, int a5, int a6);
long double __cdecl sub_80C0F08(float a1);
long double __cdecl sub_80C0F22(int a1);
int __cdecl sub_80C0F86(_DWORD *a1);
int __cdecl sub_80C0FA2(_DWORD *a1, _DWORD *a2);
float *__cdecl sub_80C0FC2(float *a1, float a2, float *a3);
float *__cdecl sub_80C0FE8(float *a1, float a2, float *a3, float *a4);
long double __cdecl sub_80C101E(float *a1);
int __cdecl sub_80C1040(_DWORD *a1);
int __cdecl sub_80C106A(_DWORD *a1, _DWORD *a2);
float *__cdecl sub_80C109A(float *a1, float *a2, float *a3);
float *__cdecl sub_80C10DE(float *a1, float *a2, float *a3);
float *__cdecl sub_80C1122(float *a1, float *a2, float a3, float *a4);
float *__cdecl sub_80C118C(float *a1, float a2, float *a3);
float *__cdecl sub_80C11C4(float *a1, float a2, float *a3, float *a4);
int __cdecl sub_80C1218(_DWORD *a1);
float *__cdecl sub_80C124E(float *a1, float a2, float *a3);
float *__cdecl sub_80C129A(float *a1, float a2, float *a3, float *a4);
long double __cdecl sub_80C130A(float *a1);
float *__cdecl sub_80C1350(__int16 *a1, __int16 *a2, float a3, float *a4);
void __cdecl sub_80C13AA(float *a1, float a2, __int16 *a3, __int16 *a4, float a5, float *a6);
void __cdecl sub_80C1422(float *a1, float a2, __int16 *a3, __int16 *a4, float a5, float *a6);
__int16 *__cdecl sub_80C150E(float *a1, float a2, __int16 *a3, float *a4);
__int16 *__cdecl sub_80C1544(float *a1, float a2, __int16 *a3, float *a4);
__int16 *__cdecl sub_80C15B4(__int16 *a1, float a2, float *a3);
void __cdecl sub_80C1608(float *a1, float a2, float *a3, float *a4, float a5, float *a6);
__int16 *__cdecl sub_80C16B4(__int16 *a1, float *a2);
long double __cdecl sub_80C16D4(__int16 a1, __int16 a2, float a3);
long double __cdecl sub_80C1706(float a1, float a2, float a3);
int __cdecl sub_80C1718(const void **a1, __int16 *a2);
int __cdecl sub_80C17FA(const void **a1, __int16 *a2);
int __cdecl sub_80C1886(int a1, char **a2, unsigned __int16 *a3, int (__cdecl *a4)(int));
unsigned __int16 *__cdecl sub_80C19AE(const char *a1, int (__cdecl *a2)(int));
long double __cdecl sub_80C2C4E(float a1);
int __cdecl sub_80C2C6E(_DWORD *a1, _DWORD *a2);
int __cdecl sub_80C2C9E(const void **a1);
int __cdecl sub_80C2CD4(const void **a1);
long double __cdecl sub_80C2D0A(const void **a1);
int __cdecl XModelBad(int a1);
int __cdecl XModelPartsFree(__int16 *a1);
int *__cdecl XModelFree(int a1);
void *sub_80C2E74();
_DWORD *sub_80C2EF2();
_DWORD *__cdecl sub_80C2F0E(int a1);
int __cdecl sub_80C306A(int (__cdecl *a1)(int));
int __cdecl sub_80C3090(char *s2); // idb
int __cdecl sub_80C30AC(char *src, int a2, int (__cdecl *a3)(size_t));
int __cdecl sub_80C30D6(char *s2); // idb
int __cdecl sub_80C30F2(char *src, int a2, int (__cdecl *a3)(size_t));
int __cdecl sub_80C311C(char *s2); // idb
int __cdecl sub_80C3138(char *src, int (__cdecl *a2)(int));
int *__cdecl sub_80C3172(_DWORD *a1, const void *a2);
int __cdecl XModelPrecache(char *s2, int (__cdecl *a2)(int), int (__cdecl *a3)(int));
int __cdecl sub_80C3314(int a1);
int __cdecl sub_80C3324(__int16 **a1, int a2);
int __cdecl sub_80C337C(int a1, _DWORD *a2, _DWORD *a3);
int __cdecl sub_80C33CA(int a1);
int __cdecl sub_80C33FE(int a1, int a2, int a3, float *a4, float *a5, int a6);
int __cdecl Com_ValidXModelName(char *s1); // idb
void __cdecl sub_80C3888(float, float);
int __cdecl sub_80C38AC(_DWORD *a1, _DWORD *a2);
float *__cdecl sub_80C38DC(float *a1, float *a2, float *a3);
float *__cdecl sub_80C3920(float *a1, float a2, float *a3, float *a4);
long double __cdecl sub_80C3974(float *a1, float *a2);
long double __cdecl sub_80C39A8(float a1, float a2, float a3);
float *__cdecl sub_80C3A0A(float *a1, float *a2, float *a3);
float *__cdecl sub_80C3AB4(float *a1, float *a2, float *a3);
int __cdecl sub_80C3B60(const void **a1, __int16 *a2);
void *__cdecl sub_80C3C42(__int16 *a1);
__int16 *__cdecl sub_80C3DE8(int a1, const char *a2, int (__cdecl *a3)(int));
int __cdecl sub_80C4280(const char *a1, const void **a2, int a3);
_DWORD *__cdecl sub_80C43F4(const void **a1, _DWORD *a2, int (__cdecl *a3)(int));
__int16 *__cdecl sub_80C468A(int a1, char *s2, int (__cdecl *a3)(int));
int __cdecl sub_80C470E(const char *a1, int (__cdecl *a2)(int), int (__cdecl *a3)(int));
int sub_80C4E50();
int sub_80C4E5A();
int __cdecl sub_80C4E74(int a1, char *s2, int (__cdecl *a3)(size_t));
int __cdecl sub_80C4F0E(int a1, int (__cdecl *a2)(size_t));
int __cdecl XModelLoad(const char *a1, int (__cdecl *a2)(int), int (__cdecl *a3)(int));
int __cdecl sub_80C501A(int a1, float *a2, _DWORD *a3, _DWORD *a4);
long double __cdecl sub_80C51F0(float a1);
int __cdecl sub_80C5210(_DWORD *a1);
int __cdecl sub_80C523A(_DWORD *a1, int a2, int a3, int a4);
int __cdecl sub_80C525E(_DWORD *a1, _DWORD *a2);
float *__cdecl sub_80C528E(float *a1, float *a2, float *a3);
float *__cdecl sub_80C52D2(float *a1, float *a2, float *a3);
long double __cdecl sub_80C532E(float *a1);
int __cdecl sub_80C53E0(const void **a1);
int __cdecl sub_80C5414(int a1);
const char *__cdecl sub_80C5432(int a1, int a2, int a3);
int __cdecl sub_80C5482(int a1, _DWORD *a2, int a3, _DWORD *a4);
int __cdecl sub_80C54C2(int a1);
int __cdecl sub_80C54CE(__int16 **a1);
int __cdecl sub_80C54DC(_DWORD *a1);
long double __cdecl sub_80C5506(int a1);
int __cdecl sub_80C5556(int, float); // idb
int __cdecl sub_80C5628(int a1, unsigned __int8 *a2, unsigned int a3);
int __cdecl sub_80C5874(int a1, int *a2, int a3, int a4, unsigned int a5);
int __cdecl sub_80C5988(_DWORD *a1, unsigned int a2, _BYTE *a3, int a4);
int __cdecl sub_80C59D0(_DWORD *a1, unsigned int a2, int a3, int a4, int a5, unsigned int a6, _BYTE *a7, int a8);
int __cdecl sub_80C5ECE(_DWORD *a1);
int __cdecl sub_80C6104(int a1, __int16 a2);
size_t __cdecl sub_80C613D(int a1);
int __cdecl sub_80C620B(int a1, int a2);
int __cdecl sub_80C65F4(int a1);
unsigned int __cdecl sub_80C6A0C(int a1, void *dest, unsigned int a3);
int __cdecl sub_80C6AC0(int a1);
int __cdecl sub_80C6BCD(_DWORD *a1, unsigned int a2);
int __cdecl sub_80C6E57(int a1);
int __cdecl sub_80C70A8(int *a1, int a2);
int __cdecl sub_80C8044(int a1, int a2, _DWORD *a3);
_DWORD *__cdecl sub_80C8114(int a1, int a2, int a3);
int __cdecl sub_80C8256(int a1, int a2, int a3);
int __cdecl sub_80C969D(int a1, int a2);
int __cdecl sub_80C9712(int, void *src, size_t n); // idb
_BOOL4 __cdecl sub_80C9753(_DWORD *a1);
int __cdecl sub_80C9764(char a1, char a2, int a3, int a4, int a5);
int __cdecl sub_80C97C9(_DWORD *a1, _DWORD *a2, int a3);
int __cdecl sub_80CA538(int a1, int a2);
int __cdecl sub_80CA558(int a1, int a2, int a3, int a4, _DWORD *a5, _DWORD *a6);
int __cdecl sub_80CAC68(_DWORD *a1);
int __cdecl sub_80CACFD(_DWORD *a1);
int __cdecl sub_80CAD79(_DWORD *a1, int a2, _BYTE *a3, int a4);
int __cdecl sub_80CAF10(_DWORD *a1, _BYTE *a2, int a3);
int __cdecl sub_80CAF39(unsigned __int8 **a1, int a2);
int __cdecl sub_80CB75C(int *a1, unsigned int a2, unsigned int a3, int a4, int a5, _DWORD *a6, unsigned int *a7, int a8, _DWORD *a9, int *a10);
int __cdecl sub_80CBF7B(int *a1, unsigned int *a2, _DWORD *a3, int a4, int a5);
int __cdecl sub_80CC064(unsigned int a1, unsigned int a2, int *a3, unsigned int *a4, unsigned int *a5, _DWORD *a6, _DWORD *a7, int a8, int a9);
int __cdecl sub_80CC247(_DWORD *a1, _DWORD *a2, _DWORD *a3, _DWORD *a4);
int __cdecl sub_80CC278(int a1, _DWORD *a2, int a3);
void sub_80CC478();
int __cdecl sub_80CC47D(int a1);
int __cdecl sub_80CC515(int a1);
int __cdecl sub_80CC5D2(int a1, int a2, int a3);
int *__cdecl sub_80CC794(_DWORD *a1, int a2);
int __cdecl sub_80CCAD0(int a1, int a2, int a3);
int __cdecl sub_80CCB86(_DWORD *a1, int a2);
int __cdecl sub_80CCF25(_WORD *a1, int a2, int a3);
int __cdecl sub_80CD0B8(int a1, int a2, int a3);
int __cdecl sub_80CDA7E(int a1);
int __cdecl sub_80CDB3D(int a1, int a2, int a3, int a4);
int *__cdecl sub_80CDFE1(int a1, _BYTE *a2, int a3, int a4);
int __cdecl sub_80CE10F(int a1);
int __cdecl sub_80CE57D(int a1, _BYTE *a2, int a3, int a4);
int __cdecl sub_80CEA8B(int a1, int a2, int a3);
bool __cdecl sub_80CF236(int a1);
unsigned int __cdecl sub_80CF2D0(unsigned int a1, int a2);
int __cdecl sub_80CF2FE(int a1);
int __cdecl sub_80CF3C1(int a1);
int *__cdecl sub_80CF458(_DWORD *a1, _BYTE *a2, int a3, int a4);
int __cdecl sub_80CF610(FILE *stream, _DWORD *a2);
int __cdecl sub_80CF648(FILE *stream, _DWORD *a2);
int __cdecl sub_80CF67F(char *a1, char *a2);
int __cdecl sub_80CF724(char *s1, char *s2, int); // idb
size_t __cdecl sub_80CF76E(FILE *stream);
_DWORD *__cdecl sub_80CF90C(char *filename, void *src);
int *__cdecl unzOpen(char *filename);
int __cdecl sub_80CFC62(int a1);
int __cdecl unzGetGlobalInfo(int a1, _DWORD *a2);
int __cdecl sub_80CFCED(int a1, int *a2);
int __cdecl sub_80CFD61(FILE **a1, int *a2, int *a3, _BYTE *ptr, unsigned int a5, void *a6, unsigned int a7, _BYTE *a8, unsigned int a9);
int __cdecl unzGetCurrentFileInfo(FILE **a1, int *a2, _BYTE *ptr, int a4, void *a5, int a6, _BYTE *a7, int a8);
int __cdecl unzGoToFirstFile(int a1);
int __cdecl unzGoToNextFile(int a1);
int __cdecl sub_80D0417(int a1, _DWORD *a2);
int __cdecl unzSetCurrentFileInfoPosition(int a1, int a2);
int __cdecl sub_80D060A(int a1, _DWORD *a2, _DWORD *a3, int *a4);
int __cdecl unzOpenCurrentFile(_DWORD *a1);
int __cdecl sub_80D0AA8(int a1, int a2, unsigned int a3);
int __cdecl sub_80D0D98(int a1);
int __cdecl sub_80D0F1A(int a1);
void *__cdecl sub_80D1096(int a1, int a2, int a3);
void __cdecl sub_80D10AD(int a1, void *ptr);
void sub_80D1178();
ssize_t tty_FlushIn();
ssize_t sub_80D11A8();
int sub_80D120E();
int sub_80D1256();
int Sys_ConsoleInputShutdown();
unsigned int __cdecl sub_80D12EC(_DWORD *a1);
int sub_80D13C8();
int sub_80D140A();
void __cdecl __noreturn Sys_Exit(int status); // idb
void __cdecl __noreturn Sys_Quit(_DWORD); // weak
// char *__usercall Sys_Init@<eax>(long double a1@<st0>);
void __noreturn Sys_Error(char *format, ...);
int Sys_Warn(char *format, ...);
__time_t __cdecl sub_80D1658(char *filename);
void handler();
// void __usercall Sys_ConsoleInputInit(long double a1@<st0>);
char *Sys_ConsoleInput();
void __cdecl Sys_UnloadGame(void *handle);
void sub_80D1D86();
void __cdecl __noreturn sub_80D1DA6(const char *a1, int a2);
void __noreturn sub_80D1DDC();
void *__cdecl Sys_LoadDll(const char *a1, char *dest, const void **a3, int a4);
void sub_80D2168();
int __cdecl sub_80D216E(int a1, int a2, int a3, int a4);
int __cdecl sub_80D2194(int, int off, int); // idb
int __cdecl Sys_QueEvent(int a1, int a2, int a3, int a4, int a5, int a6);
_DWORD *__stdcall Sys_GetEvent(_DWORD *a1);
int __cdecl sub_80D24F4(char *s); // idb
void Sys_ConfigureFPU();
int __cdecl Sys_PrintBinVersion(const char *a1);
void __cdecl sub_80D25D2(char *file, int a2);
__pid_t __cdecl sub_80D266A(char *s);
void __cdecl Sys_StartProcess(char *src, int a2);
void __cdecl Sys_OpenURL(const char *a1, int a2);
void __cdecl Sys_ParseArgs(int a1, const char **a2);
void __noreturn Sys_LoadRenderer();
void __noreturn Sys_UnloadRenderer();
int __cdecl NetadrToSockadr(int a1, _WORD *s);
int __cdecl SockadrToNetadr(int a1, int a2);
char *__cdecl sub_80D2C0E(int a1, int a2);
int __cdecl sub_80D2C58(char *cp, _WORD *s);
int __cdecl sub_80D2CF0(char *cp, int); // idb
int __cdecl Sys_GetPacket(int *a1, int a2);
int __cdecl Sys_SendPacket(size_t n, void *buf, int, int, int, int, int); // idb
int __cdecl Sys_IsLANAddress(int a1, int a2);
int Sys_ShowIP();
struct hostent *NET_GetLocalAddress();
// struct hostent *__usercall NET_OpenIP@<eax>(long double a1@<st0>);
// struct hostent *__usercall NET_Init@<eax>(long double a1@<st0>);
int __cdecl NET_IPSocket(char *cp, int a2);
int sub_80D360E();
char *NET_ErrorString();
int __cdecl NET_Sleep(int a1);
int Sys_MilliSeconds();
int sub_80D37B0();
void __cdecl sub_80D3824(float *a1);
int __cdecl Sys_Mkdir(char *path); // idb
DIR *__cdecl Sys_ListFilteredFiles(const char *a1, const char *a2, int a3, int a4, int *a5);
_DWORD *__cdecl Sys_ListFiles(char *name, char *s, int a3, _DWORD *a4, int a5);
void __cdecl Sys_FreeFileList(void **ptr);
char *Sys_Cwd();
char *__cdecl Sys_SetDefaultCDPath(char *src);
char *Sys_DefaultCDPath();
char *sub_80D3F64();
char *__cdecl Sys_SetDefaultInstallPath(char *src);
char *Sys_DefaultInstallPath();
char *__cdecl sub_80D3FD4(char *src);
char *Sys_DefaultHomePath();
void sub_80D40EA();
const char *Sys_GetCurrentUser();
_BYTE *__cdecl strlwr(_BYTE *a1);
int __cdecl Sys_DirectoryHasContents(char *s); // idb
int __cdecl sub_80D425A(char *s); // idb
int Sys_InitMainThread();
_BOOL4 Sys_IsMainThread();
int __cdecl Sys_SetValue(int a1, int a2);
int __cdecl Sys_GetValue(int a1);
// char *__usercall sub_80D4560@<eax>(long double a1@<st0>);
void sub_80D4590();
int __cdecl BG_StringHashValue_Lwr(int a1);
void __noreturn BG_AnimParseError(char *format, ...);
int __cdecl BG_AnimationIndexForString(char *src); // idb
int __cdecl sub_80D4832(char *a1);
int __cdecl sub_80D48C6(char *a1, int *a2, int a3);
char *__cdecl sub_80D4970(char *s, int a2, unsigned int a3, _DWORD *a4);
int __cdecl sub_80D49D8(int a1, int a2);
int sub_80D4A08();
unsigned __int16 *__cdecl sub_80D4A32(unsigned int a1);
void *__cdecl sub_80D4ABE(int a1);
void *sub_80D4BC2();
void *__cdecl sub_80D4ED4(char **a1, int *a2, int a3, _DWORD *s);
int __cdecl sub_80D5250(char **a1, _DWORD *a2);
size_t __cdecl sub_80D5424(char **a1, _DWORD *a2, int a3);
_DWORD *__cdecl sub_80D5B94(int a1, int a2, int a3);
int __cdecl sub_80D688A(int a1, _DWORD *a2);
_DWORD *__cdecl sub_80D6944(int a1, _DWORD *a2);
int __cdecl sub_80D69B2(_DWORD *a1, int a2, int a3, int a4, int a5, int a6, int a7);
int __cdecl sub_80D6B7C(_DWORD *a1, char *src, int a3, int a4, int a5, int a6);
int __cdecl sub_80D6BC4(_DWORD *a1, __int16 *a2, int a3, int a4, int a5);
int __cdecl sub_80D6D82(_DWORD *a1, int a2, int a3, int a4);
int __cdecl sub_80D6EDC(_DWORD *a1, int a2, int a3);
int __cdecl BG_AnimScriptEvent(_DWORD *a1, int a2, int a3, int a4);
int __cdecl sub_80D70AA(int a1, unsigned int a2);
int __cdecl sub_80D70E2(int a1, int a2, int a3, int a4);
unsigned int __cdecl sub_80D7180(int a1, int a2, int a3);
int __cdecl sub_80D72B8(int a1, unsigned int a2);
int __cdecl sub_80D72F8(int *a1);
_BOOL4 __cdecl sub_80D74DE(int a1, int a2);
_BOOL4 __cdecl sub_80D7534(int a1, int a2);
_BOOL4 __cdecl sub_80D7588(int a1, int a2);
void __cdecl sub_80D75DC(int *a1, int *a2, int a3, int a4);
int __cdecl sub_80D7D06(int *a1, int a2, int a3, int a4);
void __cdecl sub_80D8052(int a1, _DWORD *a2);
void __cdecl sub_80D80B8(float a1, float a2, float a3, float a4, float *a5, _DWORD *a6);
void __cdecl sub_80D82A4(int a1, int a2);
int __cdecl sub_80D8882(_DWORD *a1, int a2);
void *__cdecl sub_80D8C3E(int a1, int a2, int a3, int a4, void *s);
int *__cdecl sub_80D93D8(int a1, float a2, int a3);
void __cdecl sub_80D94B8(float *a1, float a2, float *a3);
int __cdecl sub_80D954C(int a1, int a2, int a3, int a4, int a5);
int __cdecl sub_80D9698(int a1, _DWORD *a2, int *a3);
int __cdecl sub_80D978C(int a1, _DWORD *a2, int a3, int a4);
int sub_80D99BE();
// _DWORD *__userpurge sub_80D9A8A@<eax>(_DWORD *a1, char *a2, int a3);
int sub_80D9ADE();
int sub_80D9B7E();
long double __cdecl sub_80D9C30(float a1);
long double __cdecl sub_80D9C4A(int a1);
void __cdecl sub_80D9CAE(float a1, float *a2, float *a3);
int __cdecl sub_80D9CDC(_DWORD *a1);
int __cdecl sub_80D9D06(_DWORD *a1, int a2, int a3, int a4);
int __cdecl sub_80D9D2A(_DWORD *a1, _DWORD *a2);
float *__cdecl sub_80D9D5A(float *a1, float *a2, float *a3);
float *__cdecl sub_80D9D9E(float *a1, float a2, float *a3, float *a4);
long double __cdecl sub_80D9DF2(float *a1);
void __cdecl sub_80D9E26(float *);
long double __cdecl sub_80D9E64(float a1);
int __cdecl sub_80D9E84(int a1, int a2);
int __cdecl sub_80D9EAA(int a1, int a2);
// char *__usercall Jump_RegisterDvars@<eax>(long double a1@<st0>);
int __cdecl Jump_ClearState(int a1);
int __cdecl Jump_GetStepHeight(int a1, int a2, float *a3);
_BOOL4 __cdecl Jump_IsPlayerAboveMax(int a1);
int __cdecl Jump_ActivateSlowdown(int a1);
float *__cdecl Jump_ApplySlowdown(int a1);
long double __cdecl Jump_ReduceFriction(int a1);
long double __cdecl sub_80DA1F8(int a1);
void __cdecl Jump_ClampVelocity(int a1, int a2);
long double __cdecl sub_80DA2CA(int a1);
void __cdecl sub_80DA31C(int *a1, _DWORD *a2, float a3);
unsigned int __cdecl sub_80DA424(int a1, int *a2);
int __cdecl sub_80DA52E(int a1, int a2);
int __cdecl Jump_Check(int *a1, int *a2);
long double __cdecl sub_80DA70C(float a1);
float *__cdecl sub_80DA72C(float *a1, float a2, float *a3);
int __cdecl sub_80DA752(_DWORD *a1, int a2, int a3, int a4);
int __cdecl sub_80DA776(_DWORD *a1, _DWORD *a2);
float *__cdecl sub_80DA7A6(float *a1, float a2, float *a3);
float *__cdecl sub_80DA7DE(float *a1, float a2, float *a3, float *a4);
long double __cdecl sub_80DA832(float *a1, float *a2);
// char *__usercall Mantle_RegisterDvars@<eax>(long double a1@<st0>);
void *__cdecl sub_80DA9B8(size_t n);
void __cdecl Mantle_DebugPrint(const char *a1);
int __cdecl sub_80DA9FC(int a1);
int __cdecl sub_80DAA36(int a1);
int __cdecl sub_80DAA8E(int a1);
int __cdecl sub_80DAAF2(int a1, int a2, float *a3);
int __cdecl sub_80DAC38(float, float); // idb
int __cdecl sub_80DACB8(int **a1, int a2);
int __cdecl sub_80DAE2E(int a1, int a2, int a3);
int __cdecl sub_80DAF36(int *a1, int a2, int a3, float a4);
void __cdecl sub_80DB380(int (__cdecl *a1)(int));
void sub_80DB6CA();
int __cdecl sub_80DB6DA(int *a1, _DWORD *a2, float *s, unsigned int *a4);
void __cdecl Mantle_Check(int *a1, _DWORD *a2);
int __cdecl sub_80DBB3C(int a1, int a2, int a3);
// void __usercall sub_80DBD56(long double a1@<st0>, int a2);
int __cdecl sub_80DBE96(int a1);
_BOOL4 __cdecl sub_80DBEB0(int a1);
long double __cdecl sub_80DBF16(float a1);
int __cdecl sub_80DBF30(_DWORD *a1, int a2, int a3, int a4);
int __cdecl sub_80DBF54(_DWORD *a1, _DWORD *a2);
unsigned int __cdecl sub_80DBF84(_DWORD *a1, unsigned int *a2);
float *__cdecl sub_80DBFC2(float *a1, float *a2, float *a3);
float *__cdecl sub_80DC006(float *a1, float *a2, float *a3);
float *__cdecl sub_80DC04A(float *a1, float a2, float *a3);
float *__cdecl sub_80DC082(float *a1, float a2, float *a3, float *a4);
long double __cdecl sub_80DC0D6(float *a1, float *a2);
// char *__usercall BG_RegisterDvars@<eax>(long double a1@<st0>);
int __cdecl BG_FindItemForWeapon(int a1);
char *__cdecl sub_80DCB02(char *s1);
_BOOL4 __cdecl sub_80DCBB6(float *a1, int a2, int a3);
_BOOL4 __cdecl sub_80DCC7A(_DWORD *a1, _DWORD *a2, int a3);
float *__cdecl BG_EvaluateTrajectory(int a1, int a2, int a3);
float *__cdecl sub_80DD224(float *a1, int a2, int a3);
// int __usercall sub_80DD452@<eax>(long double a1@<st0>, _DWORD *a2, float *a3, _DWORD *a4);
int __cdecl BG_AddPredictableEventToPlayerstate(int a1, unsigned __int8 a2, int a3);
int __cdecl sub_80DD59E(int a1, int a2, int a3, unsigned __int8 a4);
int __cdecl sub_80DDAD0(int a1, float *a2, int a3, int a4, float a5, _DWORD *a6, float *a7, float *a8, int a9, int a10, int a11, unsigned __int8 a12, int a13, float a14);
int __cdecl sub_80DE734(int a1, float *a2, int a3, int a4, float a5, _DWORD *a6, float *a7, float *a8, int a9, int a10, int a11, unsigned __int8 a12, int a13, float a14);
int __cdecl sub_80DE918(_DWORD *a1);
int __cdecl sub_80DE942(_DWORD *a1, int a2, int a3, int a4);
int __cdecl sub_80DE966(_DWORD *a1, _DWORD *a2);
unsigned int __cdecl sub_80DE996(_DWORD *a1, unsigned int *a2);
float *__cdecl sub_80DE9D4(float *a1, float *a2, float *a3);
float *__cdecl sub_80DEA18(float *a1, float *a2, float *a3);
float *__cdecl sub_80DEA5C(float *a1, float a2, float *a3);
float *__cdecl sub_80DEA94(float *a1, float a2, float *a3, float *a4);
long double __cdecl sub_80DEAE8(float *a1, float *a2);
void __cdecl sub_80DEB1C(float *);
long double __cdecl sub_80DEB5A(float a1);
float *__cdecl sub_80DEB7A(float *a1, float *a2, float a3, float *a4);
void __cdecl sub_80DEBE4(int a1, void *s, int a3, int a4, int a5, int a6, int a7, int a8);
void __cdecl sub_80DEC3C(int a1, unsigned __int16 *s, int a3, int a4, int a5, int a6, int a7, int a8);
int __cdecl sub_80DED2E(int a1, int a2);
int __cdecl sub_80DED50(int a1, int a2);
float *__cdecl sub_80DEDB0(float *a1, float *a2, float *a3);
int __cdecl PM_GetEffectiveStance(int a1);
// int __usercall sub_80DEE4A@<eax>(long double a1@<st0>, int a2, int a3);
int __cdecl sub_80DEFE8(int a1, float a2, float *a3);
long double __cdecl sub_80DF0DA(int a1, float a2, float *a3);
void __cdecl sub_80DF16A(int a1, int a2, float *a3, float a4, float a5);
long double __cdecl sub_80DF2DE(int a1, float a2, float a3, float a4);
long double __cdecl sub_80DF3FA(int a1, int a2);
long double __cdecl sub_80DF534(int *a1, int a2);
long double __cdecl sub_80DF7FC(int a1);
// int __usercall sub_80DF868@<eax>(long double a1@<st0>, int a2, int a3);
int __cdecl PM_GroundSurfaceType(int a1);
// void __usercall sub_80DFB3A(long double a1@<st0>, int a2, int a3);
// int __usercall sub_80DFCD4@<eax>(long double a1@<st0>, int a2, int a3);
// int __usercall sub_80DFE82@<eax>(long double a1@<st0>, int a2, int a3);
// float *__usercall sub_80E02FE@<eax>(long double a1@<st0>, int a2, int a3);
// float *__usercall sub_80E037E@<eax>(long double a1@<st0>, int a2, int a3);
float *__cdecl sub_80E05C8(int a1, int a2);
int __cdecl sub_80E088C(int a1, int a2);
int __cdecl sub_80E0906(int a1);
int __cdecl sub_80E0938(int a1);
int __cdecl sub_80E0968(int a1);
int __cdecl sub_80E0984(int a1);
void __cdecl sub_80E09A0(int a1, int a2);
int __cdecl sub_80E0DA2(int *a1, _DWORD *a2, unsigned __int16 *s);
_DWORD *__cdecl sub_80E0F86(int a1, _DWORD *a2);
_DWORD *__cdecl sub_80E117E(int *a1, int a2);
int __cdecl sub_80E1522(int a1, int a2, int a3);
long double __cdecl sub_80E1562(int a1, int a2, float *a3);
long double __cdecl sub_80E168A(_DWORD *a1, int a2, int a3);
void __cdecl sub_80E178C(int *a1, int a2);
void __cdecl sub_80E1F20(int a1, int a2);
char __cdecl sub_80E2CDE(int *a1, int a2, char a3, char a4, int a5);
_BOOL4 __cdecl sub_80E2EA6(int *a1);
int __cdecl sub_80E2F4E(float); // idb
void __cdecl sub_80E3008(int a1, int a2);
void __cdecl sub_80E4060(int a1);
_DWORD *__cdecl sub_80E4212(_DWORD *a1, int a2);
void __cdecl sub_80E42D0(int a1, float a2, int a3, void (__cdecl *a4)(float *, _DWORD *, _DWORD *, _DWORD *, int *, _DWORD, int));
// int __usercall sub_80E4688@<eax>(long double a1@<st0>, int a2, float a3, unsigned __int8 a4);
void __cdecl sub_80E4794(int a1, float a2, int a3, unsigned __int8 a4);
// void __usercall sub_80E54DC(long double a1@<st0>, _BYTE *a2, int a3);
int __cdecl sub_80E5820(int a1);
int __cdecl sub_80E5844(int **a1);
int __cdecl sub_80E58EE(int a1);
int __cdecl sub_80E5902(int a1);
int __cdecl sub_80E5936(int a1, int *a2);
// int __usercall sub_80E5D4A@<eax>(long double a1@<st0>, int a2, int a3);
void __cdecl sub_80E6200(int a1);
int __cdecl sub_80E6D30(int **a1);
// long double __usercall sub_80E6DF4@<st0>(long double a1@<st0>, int a2, int a3);
long double __cdecl sub_80E6E42(float a1);
long double __cdecl sub_80E6E5C(float a1);
void __cdecl sub_80E6E7C(float, float);
void __cdecl sub_80E6EA0(float, float);
int __cdecl sub_80E6EC4(int a1, int a2, int a3);
long double __cdecl sub_80E6F06(float a1);
unsigned int __cdecl sub_80E6F12(unsigned int a1);
int __cdecl sub_80E6F38(_DWORD *a1, _DWORD *a2);
float *__cdecl sub_80E6F58(float *a1, float *a2, float *a3);
float *__cdecl sub_80E6F84(float *a1, float *a2, float *a3);
float *__cdecl sub_80E6FB0(float *a1, float a2, float *a3);
float *__cdecl sub_80E6FD6(float *a1, float a2, float *a3, float *a4);
long double __cdecl sub_80E700C(float *a1, float *a2);
long double __cdecl sub_80E702E(float *a1);
void __cdecl sub_80E7050(float *);
int __cdecl sub_80E707C(_DWORD *a1);
int __cdecl sub_80E70A6(_DWORD *a1, int a2, int a3, int a4);
int __cdecl sub_80E70CA(_DWORD *a1, _DWORD *a2);
unsigned int __cdecl sub_80E70FA(_DWORD *a1, unsigned int *a2);
float *__cdecl sub_80E7138(float *a1, float *a2, float *a3);
float *__cdecl sub_80E717C(float *a1, float *a2, float *a3);
float *__cdecl sub_80E71C0(float *a1, float a2, float *a3);
float *__cdecl sub_80E71F8(float *a1, float a2, float *a3, float *a4);
long double __cdecl sub_80E724C(float *a1, float *a2);
long double __cdecl sub_80E7280(float *a1);
void __cdecl sub_80E72B4(float *);
long double __cdecl sub_80E72F2(float a1, float a2, float a3);
int __cdecl sub_80E731C(int a1, int a2, int a3);
unsigned int __cdecl sub_80E733C(unsigned int a1);
int __cdecl sub_80E7348(unsigned __int8 *a1, _DWORD *a2, _DWORD *a3);
long double __cdecl sub_80E7448(float *a1, int a2, int a3, _DWORD *a4);
_BOOL4 __cdecl sub_80E750E(int *a1, int a2, int a3);
void __cdecl sub_80E7CC0(int *a1, int a2, int a3);
long double __cdecl sub_80E86BE(float a1);
int __cdecl sub_80E86D8(float); // idb
float *__cdecl sub_80E870E(float *a1, float *a2, float *a3);
long double __cdecl sub_80E873A(float *a1, float *a2);
int __cdecl sub_80E875C(_DWORD *a1);
int __cdecl sub_80E8786(_DWORD *a1, int a2, int a3, int a4);
int __cdecl sub_80E87AA(_DWORD *a1, _DWORD *a2);
float *__cdecl sub_80E87DA(float *a1, float *a2, float *a3);
float *__cdecl sub_80E881E(float *a1, float a2, float *a3);
float *__cdecl sub_80E8856(float *a1, float a2, float *a3, float *a4);
long double __cdecl sub_80E88AA(float *a1, float *a2);
void sub_80E88E0();
int __cdecl sub_80E88F0(int a1);
int __cdecl BG_FillInAmmoItems(void (__cdecl *a1)(int));
int __cdecl sub_80E8B16(int a1);
_BYTE *__cdecl sub_80E8C8C(int a1);
int __cdecl sub_80E8E44(int a1);
_BYTE *__cdecl sub_80E8FBA(int a1, int a2);
int BG_ClearWeaponDef();
int __cdecl sub_80E9154(int a1);
int __cdecl sub_80E9188(int a1, void (__cdecl *a2)(int));
int sub_80E91DC();
int __cdecl sub_80E9210(int a1, int a2);
int __cdecl sub_80E9240(int a1, int a2);
int __cdecl BG_WeaponDefs(int a1);
int *__cdecl sub_80E9280(int a1);
int BG_GetNumWeapons();
int __cdecl sub_80E9336(int a1);
int __cdecl sub_80E9356(int a1);
int __cdecl sub_80E936C(int a1);
int __cdecl sub_80E93C4(char *a1);
int __cdecl sub_80E9430(char *a1);
int __cdecl BG_FindWeaponIndexForName(char *a1);
int __cdecl sub_80E94F0(char *s1, void (__cdecl *a2)(int));
int __cdecl sub_80E958C(char *s1); // idb
int sub_80E95A8();
int __cdecl sub_80E95EE(_DWORD *a1);
int __cdecl sub_80E963A(int a1, int a2);
int __cdecl sub_80E973E(int a1);
int __cdecl sub_80E9758(int a1);
int __cdecl sub_80E9782(int a1);
int __cdecl sub_80E97BE(int a1);
_BOOL4 __cdecl BG_IsWeaponValid(int a1, int a2);
_BOOL4 __cdecl sub_80E9882(int a1);
int __cdecl sub_80E98CA(int a1, int a2);
int __cdecl sub_80E9A9E(int a1, int a2, int a3);
int __cdecl sub_80E9B54(int a1, int a2, int a3);
int __cdecl sub_80E9C10(int a1, int a2);
int __cdecl sub_80E9C6A(int a1, int a2, int a3);
int __cdecl sub_80E9DE0(int a1, int a2);
int __cdecl sub_80E9FD2(int a1, int a2);
float *__cdecl sub_80EA198(int a1, int a2, float *a3, float *a4);
int __cdecl sub_80EA28E(int a1);
_BOOL4 __cdecl sub_80EA2B6(_DWORD *a1, int a2);
int __cdecl sub_80EA3DA(int a1);
int __cdecl sub_80EA40E(int a1, int a2);
unsigned int __cdecl sub_80EA53E(int a1);
void __cdecl sub_80EA568(int *a1, int a2);
int __cdecl sub_80EA838(int a1);
int __cdecl sub_80EA850(int a1);
void __cdecl sub_80EA868(int a1);
void __cdecl sub_80EA950(int *a1, int a2);
int __cdecl sub_80EABAA(_DWORD *a1);
int __cdecl sub_80EAC7A(int a1);
int __cdecl sub_80EAC94(int a1);
int __cdecl sub_80EACAE(int a1);
int __cdecl sub_80EACC8(int a1, int a2);
int __cdecl sub_80EAD0C(int a1);
int __cdecl sub_80EAE8C(int a1, int a2, int a3);
int __cdecl sub_80EAEC8(int a1);
_BOOL4 __cdecl sub_80EAEF2(int a1);
int __cdecl sub_80EAF30(int a1);
int __cdecl sub_80EAF58(int a1, int a2);
int __cdecl sub_80EB180(_DWORD *a1);
int __cdecl sub_80EB2E8(_DWORD *a1);
int __cdecl sub_80EB3D0(_DWORD *a1);
int __cdecl sub_80EB4FC(_DWORD *a1, int a2);
int __cdecl sub_80EB738(unsigned __int8 *a1);
int __cdecl sub_80EBA76(int a1);
int __cdecl sub_80EBA9E(int a1);
int __cdecl sub_80EBBA8(_DWORD *a1);
int __cdecl sub_80EBD80(_DWORD *a1, int a2);
int __cdecl sub_80EBE96(_DWORD *a1, int a2);
int __cdecl sub_80EBFC8(int a1);
char __cdecl sub_80EBFF0(int a1);
int __cdecl sub_80EC22A(int a1);
void __cdecl sub_80EC2BA(_BYTE *a1, int a2);
int __cdecl sub_80EC560(_BYTE *a1, int a2);
int __cdecl sub_80EC7D2(unsigned __int8 *a1);
int __cdecl sub_80ECA14(_BYTE *a1, int a2);
int __cdecl sub_80ECA78(int a1, int a2);
int sub_80ECC42();
int __cdecl sub_80ECC4C(_DWORD *a1);
int __cdecl sub_80ECD62(int a1);
void __cdecl sub_80ECDD6(int a1);
int __cdecl sub_80ECE56(_DWORD *a1, int a2);
int __cdecl sub_80ECF70(_DWORD *a1);
int __cdecl sub_80ECFF2(int a1);
int __cdecl sub_80ED01A(int *a1, int a2);
int __cdecl sub_80ED212(_DWORD *a1);
int __cdecl sub_80ED282(_DWORD *a1);
int __cdecl sub_80ED2F2(_DWORD *a1);
int __cdecl sub_80ED382(_DWORD *a1);
int __cdecl sub_80ED3DE(int *a1);
unsigned int __cdecl sub_80ED50A(_DWORD *a1);
int __cdecl sub_80ED592(int a1);
int __cdecl sub_80ED5AE(int *a1);
int __cdecl sub_80ED780(_DWORD *a1, int a2);
int __cdecl sub_80ED84E(int a1);
int __cdecl sub_80ED87A(int a1);
int __cdecl sub_80ED8A6(int a1);
_DWORD *__cdecl sub_80ED8D2(_DWORD *a1);
int __cdecl sub_80ED928(_DWORD *a1);
int __cdecl sub_80ED97E(_DWORD *a1);
_DWORD *__cdecl sub_80ED9E0(_DWORD *a1);
int __cdecl sub_80EDA06(_DWORD *a1);
int __cdecl sub_80EDA78(int a1);
int __cdecl sub_80EDB00(int a1);
int __cdecl sub_80EDF3A(int a1, int a2);
int __cdecl sub_80EE212(_DWORD *a1);
float *__cdecl sub_80EE226(int a1, float *a2, int a3);
long double __cdecl sub_80EE4AA(int a1);
long double __cdecl sub_80EE506(int a1, float a2, float a3, float a4);
long double __cdecl sub_80EE5C6(int a1, float a2, float a3, float a4);
void __cdecl sub_80EE640(float *a1, float *a2);
void __cdecl sub_80EEA0C(float *a1, float *a2);
float *__cdecl sub_80EEA7C(float *a1, float *a2);
float *__cdecl sub_80EED76(int *a1, float *a2);
void __cdecl sub_80EEF38(float *a1, float *a2);
int __cdecl sub_80EF12E(float *a1, float *a2, float a3, float a4, float a5, float a6, float a7, float a8);
float *__cdecl sub_80EF336(float *a1, float *a2);
int __cdecl sub_80EF52C(float *a1, int a2);
void __cdecl sub_80EF61E(float *a1, float *a2);
int __cdecl sub_80EF7AA(float *a1, float *a2);
float *__cdecl sub_80EFA86(int *a1, float *a2);
void __cdecl sub_80EFC4A(_DWORD **a1, float *a2);
void __cdecl sub_80EFD94(float *a1, float *a2);
int __cdecl sub_80EFDF0(int a1, float *a2, int a3, float *a4, float a5, int a6);
char **__cdecl sub_80F0110(const char *a1, char *s);
long double __cdecl sub_80F0198(float a1);
void __cdecl sub_80F01B2(float, float);
void __cdecl sub_80F01D6(float, float);
int __cdecl sub_80F01FA(int a1, int a2);
long double __cdecl sub_80F0220(float a1, float a2, float a3);
long double __cdecl sub_80F025E(float a1);
long double __cdecl sub_80F026A(float *a1);
int __cdecl sub_80F028C(_DWORD *a1);
int __cdecl sub_80F02B6(_DWORD *a1, _DWORD *a2);
float *__cdecl sub_80F02E6(float *a1, float *a2, float *a3);
float *__cdecl sub_80F032A(float *a1, float a2, float *a3);
float *__cdecl sub_80F0362(float *a1, float a2, float *a3, float *a4);
long double __cdecl sub_80F03B6(float a1, float a2, float a3);
int __cdecl sub_80F03E0(int a1, int a2, int a3);
int __cdecl sub_80F0400(int a1, int a2);
int __cdecl sub_80F0450(char *s1); // idb
char *__cdecl sub_80F049E(int a1);
int sub_80F04AE();
_DWORD *BG_LoadPlayerAnimTypes();
int __cdecl sub_80F065E(char *s1, int, int); // idb
int __cdecl sub_80F06B4(_DWORD *a1, char *s1, int a3);
int __cdecl sub_80F09D6(int *a1);
void __cdecl sub_80F0A52(int a1);
void __cdecl sub_80F0AA6(int a1);
char *__cdecl sub_80F0B8E(char **a1, char *s);
char *__cdecl sub_80F0BE2(char **a1, char *s);
char ***__cdecl sub_80F0BFC(char ***a1);
int __cdecl BG_LoadWeaponDefInternal(const char *a1, char *a2);
void *BG_LoadDefaultWeaponDef();
// float *__usercall sub_80F0FEC@<eax>(long double a1@<st0>, float *a2, float *a3, float *a4, float *a5, float a6, float *a7);
// int __usercall sub_80F10F4@<eax>(long double a1@<st0>, float *a2, float *a3, float *a4, float *a5, int a6, int a7, int a8, int a9);
void __cdecl sub_80F15AA(float *s, float *a2, float *a3, float *a4, float *a5, int a6, int a7);
int __cdecl sub_80F166C(float *a1, int a2, int a3);
void __cdecl sub_80F172C(float, float);
void __cdecl sub_80F1750(float, float);
int __cdecl sub_80F1774(_DWORD *a1);
int __cdecl sub_80F179E(_DWORD *a1, _DWORD *a2);
long double __cdecl sub_80F17CE(float a1, float a2, float a3);
void *__cdecl sub_80F17F8(char *s, int a2);
int __cdecl G_ParseSpawnVars(int a1);
int __cdecl G_SpawnStringInternal(int a1, char *s1, int a3, _DWORD *a4);
int __cdecl G_NewString(char *s); // idb
char *__cdecl vtos(float *a1);
int __cdecl sub_80F1C24(char *a1, char *src, int a3, int *a4);
int __cdecl G_ParseWeaponAccurayGraphs(int a1, const char *a2, const char *a3, int a4, int *a5);
int __cdecl sub_80F1F7E(int a1);
int __cdecl sub_80F20C8(int a1);
int __cdecl sub_80F2350(int a1);
int __cdecl sub_80F2362(int a1, int a2);
int __cdecl sub_80F24C6(int a1);
int __cdecl sub_80F275E(int a1, int **a2);
// int __usercall sub_80F29CA@<eax>(long double a1@<st0>, int a2);
int __cdecl sub_80F2B22(int a1);
int __cdecl sub_80F2B86(int *a1, int a2);
int __cdecl sub_80F2EC0(int a1, int a2);
int __cdecl sub_80F2F2E(int a1);
void __cdecl sub_80F2FA4(int a1, int a2, int a3, int a4);
int __cdecl sub_80F34E0(_DWORD *a1, int a2, int a3);
// int __usercall sub_80F35DA@<eax>(long double a1@<st0>, int *a2, int **a3);
// int __usercall sub_80F3EA4@<eax>(long double a1@<st0>, int a2);
// int __usercall sub_80F3F74@<eax>(long double a1@<st0>, int *a2);
int __cdecl sub_80F40C4(int a1);
_DWORD *__cdecl sub_80F41C2(int a1);
int __cdecl sub_80F467C(int a1, char a2);
int __cdecl sub_80F4696(int a1, _DWORD *a2);
int __cdecl sub_80F474A(int a1);
int __cdecl sub_80F4B46(int *a1, int a2);
int __cdecl sub_80F4BA4(int a1);
// int __usercall sub_80F4DBE@<eax>(long double a1@<st0>, int a2);
float *__cdecl sub_80F53E0(int a1, int a2);
float *__cdecl sub_80F543C(float *a1, float *a2, float *a3);
float *__cdecl sub_80F5468(float *a1, float a2, float *a3);
long double __cdecl sub_80F548E(float *a1);
void __cdecl sub_80F54B0(float *);
int __cdecl sub_80F54DC(_DWORD *a1);
int __cdecl sub_80F5506(_DWORD *a1, int a2, int a3, int a4);
int __cdecl sub_80F552A(_DWORD *a1, _DWORD *a2);
float *__cdecl sub_80F555A(float *a1, float *a2, float *a3);
float *__cdecl sub_80F559E(float *a1, float *a2, float *a3);
long double __cdecl sub_80F55E2(float *a1, float *a2);
long double __cdecl sub_80F5616(float a1);
void __cdecl ClientScr_ReadOnly(int a1, const char **a2);
void __cdecl ClientScr_SetSessionTeam(int a1);
int __cdecl sub_80F572C(int a1);
void __cdecl sub_80F57A4(int a1);
int __cdecl sub_80F5868(int a1);
int __cdecl sub_80F58E0(_DWORD *a1);
void __cdecl sub_80F598C(int a1);
int __cdecl sub_80F59B4(int a1);
int __cdecl sub_80F59F2(int a1);
int __cdecl sub_80F5A22(int a1);
int __cdecl sub_80F5A7C(int a1);
int __cdecl sub_80F5AD2(int a1);
void __cdecl ClientScr_SetHeadIconTeam(int a1);
int __cdecl sub_80F5C30(int a1);
__int16 __cdecl sub_80F5CC8(int a1);
int __cdecl sub_80F5D08(int a1);
int __cdecl sub_80F5D2A(int a1);
int __cdecl sub_80F5D4C(int a1);
char **sub_80F5D66();
int __cdecl sub_80F5DBC(int a1, int a2);
int __cdecl sub_80F5E1E(int a1, int a2);
// int __usercall sub_80F5E80@<eax>(long double a1@<st0>, int a2, _DWORD *a3);
void __cdecl sub_80F61BE(int a1, float *a2);
void __cdecl sub_80F63A0(int a1, int a2, float *a3, float *a4);
char *__cdecl sub_80F63D4(char *a1, char *a2, int a3);
int __cdecl ClientUserinfoChanged(int a1);
// const char *__usercall ClientConnect@<eax>(long double a1@<st0>, int a2, __int16 a3);
int __cdecl sub_80F6954(int a1);
// int __usercall sub_80F69B4@<eax>(long double a1@<st0>, int a2, _DWORD *a3, _DWORD *a4);
// void __usercall ClientDisconnect(long double a1@<st0>, int a2);
int __cdecl sub_80F6ED0(int a1, float *a2, int a3);
int *__cdecl G_BroadcastVoice(int *a1, int a2);
float *__cdecl sub_80F736E(float *a1, float *a2, float *a3);
int __cdecl sub_80F739A(_DWORD *a1, _DWORD *a2);
float *__cdecl sub_80F73CA(float *a1, float a2, float *a3, float *a4);
int __cdecl sub_80F7420(int a1);
int __cdecl sub_80F761E(int a1);
int __cdecl sub_80F76F8(int a1);
_BOOL4 __cdecl sub_80F77E2(int a1);
int __cdecl sub_80F77FE(int a1);
int __cdecl sub_80F78C4(int a1);
int __cdecl sub_80F798A(int a1);
int __cdecl sub_80F7A4A(int a1);
int __cdecl sub_80F7B40(int a1);
int __cdecl sub_80F7C36(int a1);
int __cdecl sub_80F7D32(int a1);
int __cdecl sub_80F7E38(int a1);
int __cdecl sub_80F7F72(int a1);
int __cdecl sub_80F80CC(int a1);
// int __usercall sub_80F81F8@<eax>(long double a1@<st0>, int a2);
_DWORD *__cdecl sub_80F8280(int a1);
int __cdecl sub_80F82F8(int a1);
int __cdecl sub_80F839A(int a1);
int __cdecl sub_80F843C(int a1);
int __cdecl sub_80F84DE(int a1);
int __cdecl sub_80F8558(int a1);
int __cdecl sub_80F85E6(int a1);
int __cdecl PlayerCmd_SetViewmodel(int a1);
int __cdecl sub_80F8738(int a1);
int __cdecl sub_80F87C0(int a1);
int __cdecl sub_80F882E(int a1);
int __cdecl sub_80F88EE(int a1);
int __cdecl sub_80F8A04(int a1);
int __cdecl sub_80F9448(int a1);
int __cdecl sub_80F9528(int a1);
int __cdecl sub_80F9600(int a1);
int __cdecl sub_80F96D8(int a1);
int __cdecl sub_80F9766(int a1);
int __cdecl sub_80F97F4(int a1);
int __cdecl sub_80F991C(int a1);
int __cdecl sub_80F9C02(int a1);
int __cdecl sub_80F9D6C(int a1);
int __cdecl sub_80F9F20(int a1);
int __cdecl sub_80FA064(int a1);
int __cdecl sub_80FA1B2(int a1);
int __cdecl sub_80FA2AC(int a1);
int __cdecl sub_80FA332(int a1);
// int __usercall sub_80FA3B8@<eax>(long double a1@<st0>, int a2);
int __cdecl sub_80FA45A(int a1);
// int __usercall sub_80FA50A@<eax>(long double a1@<st0>, int a2);
void __cdecl PlayerCmd_SetClientDvar(int a1);
int __cdecl sub_80FA9EE(int a1);
int __cdecl sub_80FAA98(int a1);
int __cdecl sub_80FAB1A(int a1);
unsigned int __cdecl sub_80FAB9A(int a1);
void __cdecl PlayerCmd_SetReverb(int a1);
void __cdecl PlayerCmd_DeactivateReverb(int a1);
void __cdecl PlayerCmd_SetChannelVolumes(int a1);
void __cdecl PlayerCmd_DeactivateChannelVolumes(int a1);
int __cdecl ScrCmd_IsLookingAt(int a1);
int __cdecl ScrCmd_PlayLocalSound(int a1);
void __cdecl PlayerCmd_SayAll(int a1);
void __cdecl PlayerCmd_SayTeam(int a1);
int __cdecl PlayerCmd_AllowSpectateTeam(int a1);
int __cdecl PlayerCmd_GetGuid(int a1);
int (__cdecl *__cdecl Player_GetMethod(char **a1))(int);
int __cdecl sub_80FB6C4(_DWORD *a1);
int __cdecl sub_80FB6EE(_DWORD *a1, _DWORD *a2);
float *__cdecl sub_80FB71E(float *a1, float *a2, float *a3);
float *__cdecl sub_80FB762(float *a1, float a2, float *a3);
int __cdecl DeathmatchScoreboardMessage(int a1);
int __cdecl sub_80FB982(int a1);
int __cdecl CheatsOk(int a1);
void *__cdecl sub_80FBA44(int a1);
_BYTE *__cdecl sub_80FBB0A(char *a1, _BYTE *a2);
int __cdecl sub_80FBB62(int, char *nptr); // idb
void __cdecl sub_80FBD50(char *s);
void sub_80FBE00();
// char *__usercall sub_80FBE1C@<eax>(long double a1@<st0>, int *a2);
char *__cdecl sub_80FC25E(int a1);
int __cdecl Cmd_God_f(int a1);
int __cdecl Cmd_DemiGod_f(int a1);
int __cdecl Cmd_Notarget_f(int a1);
int __cdecl Cmd_Noclip_f(int a1);
int __cdecl Cmd_UFO_f(int a1);
int __cdecl sub_80FCA4C(int *a1);
_DWORD *__cdecl sub_80FCAE6(char *a1);
int __cdecl sub_80FCD40(int a1, int a2);
_BOOL4 __cdecl sub_80FCEA8(int a1);
void __cdecl sub_80FCEC4(int a1, int a2, int a3, int a4, int a5, int a6);
void __cdecl G_Say(int *a1, int a2, int a3, char *src);
void __cdecl sub_80FD38E(int *a1, int a2, int a3);
void __cdecl sub_80FD3F0(int *a1);
void __cdecl sub_80FD5B6(int *a1);
int __cdecl sub_80FD692(int a1);
// int __usercall Cmd_CallVote_f@<eax>(long double a1@<st0>, int *a2);
int __cdecl Cmd_Vote_f(int *a1);
int __cdecl sub_80FE6BE(int a1);
void Cmd_EntityCount_f();
int __cdecl sub_80FE84C(int *a1);
int sub_80FE98A();
// void __usercall ClientCommand(long double a1@<st0>, int a2);
int __cdecl sub_80FEDEE(_DWORD *a1);
int __cdecl sub_80FEE18(_DWORD *a1, int a2, int a3, int a4);
int __cdecl sub_80FEE3C(_DWORD *a1, _DWORD *a2);
float *__cdecl sub_80FEE6C(float *a1, float a2, float *a3, float *a4);
char *__cdecl sub_80FEEC0(char *dest, char *src);
_BOOL4 sub_80FEEDA();
__int16 __cdecl sub_80FF17A(int a1, int a2, int a3);
int __cdecl G_IndexForMeansOfDeath(char *a1);
int __cdecl sub_80FF2CA(int a1, int *a2, int *a3, int a4, unsigned int a5, int a6, _DWORD *a7, int a8, int a9);
long double __cdecl sub_80FF652(int a1, int a2);
__int16 __cdecl sub_80FF6B0(int a1, int *a2, int *a3, _DWORD *a4, _DWORD *a5, int a6, int a7, unsigned int a8, int a9, int a10);
__int16 __cdecl sub_80FF7C8(int *a1, int *a2, int *a3, float *a4, _DWORD *a5, int a6, int a7, unsigned int a8, int a9, int a10);
long double __cdecl sub_80FFA56(int a1, float *a2);
int __cdecl G_RadiusDamage(float *a1, int *a2, int *a3, float a4, float a5, float a6, int *a7, int a8);
int __cdecl G_GetHitLocationString(int a1);
int __cdecl sub_81003F6(__int16 a1);
int __cdecl sub_810043E(_DWORD *a1, _DWORD *a2);
float *__cdecl sub_810046E(float *a1, float *a2, float *a3);
float *__cdecl sub_81004B2(float *a1, float *a2, float *a3);
float *__cdecl sub_81004F6(float *a1, float a2, float *a3);
float *__cdecl sub_810052E(float *a1, float a2, float *a3, float *a4);
void __cdecl sub_8100582(float *);
long double __cdecl sub_81005C0(float a1);
void sub_81005E0();
void __cdecl sub_81005E6(float *a1, int a2, int a3, float a4);
float *__cdecl sub_81007DE(float *a1, float a2, int a3, int a4, int a5);
float *__cdecl sub_8100884(float *a1, float a2, float *a3);
void __cdecl sub_8100A5A(float *a1, float a2, float a3, float a4);
void __cdecl sub_8100C02(float a1, float *a2, float *a3);
int __cdecl sub_8100C30(_DWORD *a1, _DWORD *a2);
int __cdecl sub_8100C50(_DWORD *a1, int a2, int a3, int a4);
int __cdecl sub_8100C74(_DWORD *a1, _DWORD *a2);
float *__cdecl sub_8100CA4(float *a1, float *a2, float *a3);
float *__cdecl sub_8100CE8(float *a1, float *a2, float *a3);
float *__cdecl sub_8100D2C(float *a1, float a2, float *a3, float *a4);
_DWORD *__cdecl sub_8100D80(_DWORD *a1);
_DWORD *__cdecl sub_8100E1E(_DWORD *a1);
int __cdecl sub_8100EDA(int a1, int a2);
_DWORD *__cdecl sub_8100F68(_DWORD *a1);
int *__cdecl sub_8100F84(_DWORD *a1);
void *sub_8100FE6();
void __cdecl sub_810104E(int a1, int a2, int a3, int a4);
int __cdecl sub_8101188(int a1, int a2, int a3);
int *__cdecl sub_81011D0(int a1, int a2);
int __cdecl sub_810121A(int a1, int a2);
// int __usercall sub_810125C@<eax>(long double a1@<st0>, _BYTE *a2);
_DWORD *__cdecl sub_810132E(unsigned __int8 *a1);
int __cdecl sub_8101390(int a1);
int __cdecl sub_81013E8(int a1);
int __cdecl sub_8101410(int a1);
void __cdecl sub_810145A(int a1, int a2);
int __cdecl sub_8101494(int a1, int a2);
void __cdecl sub_81014CE(int a1, int a2);
int __cdecl sub_8101508(int a1, int a2);
void __cdecl sub_8101542(int a1, int a2);
int __cdecl sub_810157C(int a1, int a2);
void __cdecl sub_81015B6(int a1, int a2);
int __cdecl sub_81015F0(int a1, int a2);
void __cdecl sub_810162A(int a1, int a2);
int __cdecl sub_8101664(int a1, int a2);
int __cdecl sub_810169E(int a1, int a2);
int __cdecl sub_8101716(int a1, int a2);
__int16 **__cdecl Scr_FreeHudElemConstStrings(int a1);
int sub_81017D2();
int sub_810180E();
int sub_810187A();
char **sub_810193A();
int __cdecl sub_8101988(int a1);
int __cdecl sub_81019C2(int a1);
void __cdecl HECmd_SetPlayerNameString(int a1);
void __cdecl HECmd_SetGameTypeString(int a1);
void __cdecl HECmd_SetMapNameString(int a1);
int __cdecl HECmd_SetShader(int a1);
int __cdecl HECmd_SetTimer_Internal(int a1, int a2, const char *a3);
int __cdecl HECmd_SetClock_Internal(int a1, int a2, const char *a3);
int __cdecl sub_8101F16(int a1);
int __cdecl sub_8101F3A(int a1);
int __cdecl sub_8101F5E(int a1);
int __cdecl sub_8101F82(int a1);
int __cdecl sub_8101FA6(int a1);
int __cdecl sub_8101FCA(int a1);
int __cdecl sub_8101FEE(int a1);
int __cdecl sub_8102030(int a1);
int __cdecl sub_8102068(int a1);
int __cdecl HECmd_ScaleOverTime(int a1);
int __cdecl HECmd_MoveOverTime(int a1);
_DWORD *__cdecl sub_810232A(int a1);
_DWORD *__cdecl sub_810234C(int a1);
int (__cdecl *__cdecl HudElem_GetMethod(char **a1))(int);
int **__cdecl sub_81023F2(_DWORD *a1, int a2, unsigned __int8 a3);
void __cdecl sub_810255C(float, float);
void __cdecl sub_8102580(float, float);
int __cdecl sub_81025A4(float); // idb
int __cdecl sub_81025DA(float); // idb
long double __cdecl sub_8102608(float a1, float a2, float a3);
int __cdecl sub_8102634(int a1, int a2);
int __cdecl sub_8102704(int a1, int a2, int a3, int a4);
int __cdecl sub_81029D4(int a1, int *a2);
int __cdecl sub_8102BE2(int a1, int *a2, _DWORD *a3, int a4);
int __cdecl sub_8103530(int a1, int *a2);
// int __usercall sub_81037F0@<eax>(long double a1@<st0>, int a2, int *a3, int a4);
// int __usercall sub_810381C@<eax>(long double a1@<st0>, unsigned __int16 *s, int *a3, int a4);
// int __usercall sub_8103B6A@<eax>(long double a1@<st0>);
int __cdecl sub_8103CB2(char **a1, _WORD *a2);
// int __usercall sub_8103D3C@<eax>(long double a1@<st0>, int a2, _DWORD *a3, _DWORD *a4, int a5);
int __cdecl sub_8103F44(int, int, float, int); // idb
float *__cdecl sub_810404E(int a1, int a2, int a3);
int __cdecl FinishSpawningItem(_DWORD *a1);
void *ClearRegisteredItems();
int sub_8104A30();
int sub_8104AEC();
int __cdecl sub_8104C84(int a1, int a2);
int __cdecl G_RegisterWeapon(int a1);
int __cdecl IsItemRegistered(int a1);
// int __usercall sub_8104EB2@<eax>(long double a1@<st0>, int a2, int a3);
int __cdecl sub_81050FE(int a1, int a2, int a3, _DWORD *a4);
int __cdecl sub_81052AA(int a1, int a2);
int __cdecl sub_8105382(int a1, int *a2, _DWORD *a3);
int *__cdecl sub_81053B6(float *a1);
int __cdecl sub_81058A0(int *a1);
int __cdecl sub_810592C(float *a1);
void __cdecl sub_8105956(_DWORD *a1);
int __cdecl sub_8105D5E(float); // idb
int __cdecl sub_8105D94(_DWORD *a1);
int __cdecl sub_8105DBE(_DWORD *a1, int a2, int a3, int a4);
int __cdecl sub_8105DE2(_DWORD *a1, _DWORD *a2);
float *__cdecl sub_8105E12(float *a1, float *a2, float *a3);
float *__cdecl sub_8105E56(float *a1, float *a2, float *a3);
float *__cdecl sub_8105E9A(float *a1, float *a2, float *a3);
float *__cdecl sub_8105EF6(float *a1, float a2, float *a3);
float *__cdecl sub_8105F2E(float *a1, float a2, float *a3, float *a4);
long double __cdecl sub_8105F82(float *a1, float *a2);
long double __cdecl sub_8105FB6(float *a1);
int __cdecl sub_8105FEA(int a1);
// char *__usercall G_RegisterDvars@<eax>(long double a1@<st0>);
int G_GetSavePersist();
int __cdecl sub_8106968(int a1);
long double sub_8106976();
int __cdecl sub_810698A(int a1);
int __cdecl sub_81069A6(int a1);
int __cdecl sub_81069C2(int a1, int a2);
int __cdecl sub_81069E2(int a1);
// int __usercall sub_81069FC@<eax>(long double a1@<st0>);
int __cdecl G_CreateDObj(__int16 ***a1, unsigned __int16 a2, int a3, int a4);
int *sub_8106AAC();
int *sub_8106B36();
void *__cdecl Hunk_AllocXAnimServer(size_t a1);
// int __usercall G_InitGame@<eax>(long double a1@<st0>, int a2, unsigned int seed, int a4, int a5);
// unsigned int *__usercall G_ShutdownGame@<eax>(long double a1@<st0>, int a2);
int sub_8107186();
int __cdecl SortRanks(_DWORD *a1, _DWORD *a2);
void CalculateRanks();
void ExitLevel();
void G_LogPrintf(char *format, ...);
void CheckVote();
int sub_8107848();
int sub_8107962();
int __cdecl sub_81079C8(int a1);
void sub_8107A40();
int __cdecl sub_8107A7C(int a1);
// void __usercall sub_8107AC4(long double a1@<st0>, int *s);
// void __usercall sub_8107CA2(long double a1@<st0>, int a2);
void __cdecl G_TraceCapsule(float *s, float *a2, float *a3, float *a4, float *a5, int a6, int a7);
int __cdecl G_TraceCapsuleComplete(float *a1, float *a2, float *a3, float *a4, int a5, int a6);
void __cdecl G_LocationalTrace(float *s, float *a2, float *a3, int a4, int a5, int a6);
int __cdecl G_LocationalTracePassed(float *a1, float *a2, int a3, int a4);
int *__cdecl G_SightTrace(int *a1, float *a2, float *a3, int a4, int a5);
void G_AddDebugString();
// int __usercall sub_8108228@<eax>(long double a1@<st0>, int *s);
int __cdecl sub_810823C(_DWORD *a1);
// int __usercall sub_810825C@<eax>(long double a1@<st0>, int *s);
int __cdecl sub_8108270(int a1, _DWORD *a2, _DWORD *a3);
// int __usercall sub_8108354@<eax>(long double a1@<st0>, int *s);
int __cdecl sub_8108368(int a1);
// int __usercall sub_810839E@<eax>(long double a1@<st0>, int *s);
int *sub_81083B2();
float *__cdecl sub_81083E8(int a1, int a2, int a3);
int __cdecl sub_81084EA(int a1, int *a2);
void __cdecl sub_81085B8(int a1, int a2);
int __cdecl sub_8109236(int a1, int a2);
int *__cdecl sub_8109348(int a1, int *a2);
int __cdecl sub_81093B8(_DWORD *a1, int *a2);
int __cdecl sub_810948E(_DWORD *a1);
unsigned int __cdecl sub_810950C(int a1);
int __cdecl sub_8109672(_DWORD *a1);
int __cdecl sub_81096DE(int a1, int a2, int a3);
int __cdecl sub_8109984(int a1, int a2);
char *__cdecl sub_81099D6(_DWORD *a1);
int __cdecl sub_8109A68(int a1);
int __cdecl sub_8109C76(int *a1, int a2);
_BOOL4 __cdecl sub_8109D26(int a1, int a2);
int __cdecl sub_8109E54(int a1);
_BOOL4 __cdecl sub_8109EC0(int a1, int a2);
void __cdecl sub_8109F46(int a1, int a2);
int __cdecl G_SpawnTurret(int a1, char *s1);
int __cdecl sub_810A7F2(int a1);
long double __cdecl sub_810A840(float a1);
long double __cdecl sub_810A85A(float a1, float a2, float a3);
float *__cdecl sub_810A898(float *a1, float *a2, float *a3);
int __cdecl sub_810A8C4(_DWORD *a1);
int __cdecl sub_810A8EE(_DWORD *a1, int a2, int a3, int a4);
int __cdecl sub_810A912(_DWORD *a1, _DWORD *a2);
float *__cdecl sub_810A942(float *a1, float *a2, float *a3);
float *__cdecl sub_810A986(float *a1, float *a2, float *a3);
float *__cdecl sub_810A9CA(float *a1, float a2, float *a3, float *a4);
long double __cdecl sub_810AA1E(float *a1, float *a2);
long double __cdecl sub_810AA52(float a1, float a2, float a3);
void __cdecl sub_810AAB4(int a1, float *a2, int a3, int a4);
_BOOL4 __cdecl sub_810AD10(int a1, int a2);
// int __usercall sub_810B07A@<eax>(long double a1@<st0>, int a2, int a3, int a4, float *a5);
int __cdecl sub_810B4D8(int a1);
void __cdecl sub_810B894(float *s, float *a2, float *a3, int a4, int a5);
int __cdecl sub_810B90E(float *s, int a2, int a3, float *a4);
long double __cdecl sub_810B988(float a1);
int __cdecl sub_810B9B6(int a1);
int __cdecl sub_810BB8C(float *a1, int a2);
unsigned __int8 *__cdecl sub_810BC36(unsigned __int8 *a1);
int __cdecl sub_810C1F6(_DWORD *a1, _DWORD *a2, float *a3, int a4, int a5);
int __cdecl sub_810C4A0(_DWORD *a1, _DWORD *a2, float *a3);
long double __cdecl sub_810C6D2(float a1);
int __cdecl sub_810C6EC(_DWORD *a1);
int __cdecl sub_810C716(_DWORD *a1, _DWORD *a2);
float *__cdecl sub_810C746(float *a1, float *a2, float *a3);
float *__cdecl sub_810C78A(float *a1, float *a2, float *a3);
float *__cdecl sub_810C7CE(float *a1, float a2, float *a3);
float *__cdecl sub_810C806(float *a1, float a2, float *a3, float *a4);
long double __cdecl sub_810C85A(float *a1, float *a2);
void __cdecl sub_810C88E(float *);
long double __cdecl sub_810C8CC(float a1);
int __cdecl sub_810C8EC(int a1, float *a2);
unsigned int __cdecl sub_810C9F0(float *a1, int a2);
int *__cdecl sub_810CA2C(int a1, int a2);
int __cdecl sub_810CA98(int a1, float *a2);
int __cdecl sub_810CB04(int a1, int a2, float *a3, float *a4);
int __cdecl sub_810D058(int a1, float *a2, float *a3, _DWORD *a4);
int (__cdecl *__cdecl sub_810D672(int a1))(int);
int __cdecl sub_810D966(_DWORD *a1);
int __cdecl sub_810D9B8(int a1);
int __cdecl sub_810DBA6(int a1);
int __cdecl sub_810DBBA(int a1);
int __cdecl sub_810DBCE(_DWORD *a1, int a2, int a3, int a4);
int __cdecl sub_810DBF2(_DWORD *a1, _DWORD *a2);
unsigned int __cdecl sub_810DC22(_DWORD *a1);
float *__cdecl sub_810DC60(float *a1, float *a2, float *a3);
float *__cdecl sub_810DCA4(float *a1, float *a2, float *a3);
long double __cdecl sub_810DCE8(float *a1, float *a2);
int __cdecl sub_810DD1C(char *s); // idb
void sub_810DD38();
int __cdecl Scr_GetFunctionHandle(char *a1, char *s, int a3);
int GScr_LoadGameTypeScript();
// int __usercall sub_810DEE2@<eax>(long double a1@<st0>);
int sub_810DF4E();
// int __usercall GScr_LoadScripts@<eax>(long double a1@<st0>);
int *sub_810E010();
int __cdecl Scr_EntityForRef(int a1);
int __cdecl GetPlayerEntity(int a1);
int sub_810E128();
int sub_810E13C();
int sub_810E150();
int sub_810E164();
int sub_810E178();
int sub_810E18C();
void sub_810E1DC();
void __cdecl __noreturn sub_810E202(int a1, char *format);
void __cdecl sub_810E21E(int a1, const char *a2, int a3);
int __cdecl Scr_ConstructMessageString(signed int a1, signed int a2, const char *a3, int a4, int a5);
int __cdecl sub_810E5D8(int a1, const char *a2);
int sub_810E64A();
int sub_810E676();
void sub_810E6A2();
void assertCmd();
void assertexCmd();
void assertmsgCmd();
int GScr_IsDefined();
int GScr_IsString();
int GScr_IsAlive();
int GScr_GetDvar();
int GScr_GetDvarInt();
int GScr_GetDvarFloat();
// void __usercall GScr_SetDvar(long double a1@<st0>);
int sub_810EB8A();
unsigned int sub_810EBA0();
int Scr_GetWeaponModel();
int __cdecl sub_810EC7C(int a1);
int GScr_GetAnimLength();
int GScr_AnimHasNotetrack();
_DWORD *sub_810EDD4();
// void __usercall GScr_Spawn(long double a1@<st0>);
int GScr_SpawnTurret();
int GScr_PrecacheTurret();
// void __usercall ScrCmd_attach(long double a1@<st0>, int a2);
// void __usercall ScrCmd_detach(long double a1@<st0>, int a2);
// _DWORD *__usercall sub_810F1E4@<eax>(long double a1@<st0>, int a2);
int __cdecl sub_810F206(int a1);
int __cdecl ScrCmd_GetAttachModelName(int a1);
int __cdecl ScrCmd_GetAttachTagName(int a1);
int __cdecl ScrCmd_GetAttachIgnoreCollision(int a1);
// void __usercall ScrCmd_LinkTo(long double a1@<st0>, int a2);
// int __usercall ScrCmd_Unlink@<eax>(long double a1@<st0>, int a2);
int __cdecl ScrCmd_EnableLinkTo(int a1);
_DWORD *__cdecl sub_810F658(int a1);
_DWORD *__cdecl sub_810F690(int a1);
int (__cdecl *__cdecl sub_810F6D6(int a1))(int, int *, int *);
// int __usercall sub_810F760@<eax>(long double a1@<st0>, int a2);
int sub_810F872();
int __cdecl sub_810F8A4(int a1);
int __cdecl sub_810F914(int a1);
int __cdecl sub_810F984(int a1);
int __cdecl sub_810F9D2(int a1);
// int __usercall sub_810FA1A@<eax>(long double a1@<st0>, int a2);
// int __usercall sub_810FA8A@<eax>(long double a1@<st0>, int a2);
int __cdecl sub_810FAD8(int a1);
void __cdecl ScrCmd_SetNormalHealth(int a1);
_DWORD *__cdecl sub_810FC60(int a1);
_DWORD *__cdecl sub_810FCA8(int a1);
void __cdecl ScrCmd_ShowToPlayer(int a1);
int __cdecl sub_810FD84(int a1);
int __cdecl Scr_SetStableMissile(int a1);
void __cdecl GScr_SetCursorHint(int a1);
int __cdecl sub_810FFAA(_DWORD *a1, char *s1);
int __cdecl GScr_SetHintString(int a1);
int __cdecl sub_8110172(int a1);
int __cdecl GScr_EnableGrenadeTouchDamage(int a1);
int __cdecl GScr_DisableGrenadeTouchDamage(int a1);
unsigned int __cdecl sub_8110232(int a1);
int __cdecl sub_8110260(int a1);
int __cdecl GScr_EnableAimAssist(int a1);
int __cdecl GScr_DisableAimAssist(int a1);
int *sub_811030E();
int __cdecl sub_8110346(_DWORD *a1, int a2);
int __cdecl sub_81103B0(int a1);
_DWORD *__cdecl sub_8110408(_DWORD *a1);
int __cdecl SetObjectiveIcon(int a1, unsigned int a2);
int Scr_Objective_Add();
_DWORD *Scr_Objective_Delete();
int Scr_Objective_State();
int Scr_Objective_Icon();
int sub_8110886();
int sub_811097C();
char *sub_8110A1C();
void GScr_Objective_Team();
void GScr_LogPrint();
int GScr_WorldEntNumber();
int GScr_Obituary();
int sub_8110DA4();
int sub_8110EAC();
void GScr_PrecacheMenu();
int __cdecl GScr_GetScriptMenuIndex(char *a1);
void GScr_PrecacheStatusIcon();
int __cdecl GScr_GetStatusIconIndex(char *a1);
void GScr_PrecacheHeadIcon();
int __cdecl GScr_GetHeadIconIndex(char *a1);
int sub_8111390();
int sub_81115C2();
// int __usercall sub_8111684@<eax>(long double a1@<st0>);
_DWORD *sub_8111786();
void Scr_RandomInt();
int sub_8111876();
int Scr_RandomIntRange();
int Scr_RandomFloatRange();
int GScr_sin();
int GScr_cos();
int GScr_tan();
int GScr_asin();
int GScr_acos();
int GScr_atan();
void GScr_CastInt();
// int __usercall Scr_Distance@<eax>(long double a1@<st0>);
int Scr_DistanceSquared();
// int __usercall sub_8111CD6@<eax>(long double a1@<st0>);
int sub_8111D04();
int sub_8111D32();
int sub_8111DB8();
_DWORD *sub_8111E00();
_DWORD *Scr_VectorToAngles();
_DWORD *Scr_AnglesToUp();
_DWORD *Scr_AnglesToRight();
_DWORD *Scr_AnglesToForward();
int Scr_IsSubStr();
int Scr_GetSubStr();
void Scr_ToLower();
int Scr_StrTok();
int Scr_MusicPlay();
void Scr_MusicStop();
int Scr_SoundFade();
int Scr_PrecacheModel();
int Scr_PrecacheShellShock();
int Scr_PrecacheItem();
int Scr_PrecacheShader();
char *Scr_PrecacheString();
void Scr_AmbientPlay();
void Scr_AmbientStop();
int sub_811272E();
int GScr_RadiusDamage();
int GScr_SetPlayerIgnoreRadiusDamage();
_DWORD *GScr_GetMoveDelta();
int GScr_GetAngleDelta();
int GScr_GetNorthYaw();
int Scr_LoadFX();
void __cdecl sub_8112BAC(const char *a1, int a2);
// int __usercall Scr_PlayFX@<eax>(long double a1@<st0>);
int Scr_PlayFXOnTag();
int Scr_PlayLoopedFX();
void __cdecl Scr_SetFog(const char *a1, float a2, float a3, float a4, float a5, float a6, float a7, float a8);
void Scr_SetLinearFog();
void Scr_SetExponentialFog();
int GScr_IsPlayer();
int GScr_IsPlayerNumber();
int GScr_SetWinningPlayer();
void GScr_SetWinningTeam();
int GScr_Announcement();
int GScr_ClientAnnouncement();
int GScr_GetTeamScore();
int GScr_SetTeamScore();
void GScr_SetClientNameMode();
int GScr_UpdateClientNames();
int GScr_GetTeamPlayersAlive();
int sub_8113C58();
int GScr_GetPartName();
int GScr_Earthquake();
void __cdecl GScr_ShellShock(int a1);
int __cdecl GScr_StopShellShock(int a1);
float *__cdecl GScr_ViewKick(int a1);
_DWORD *__cdecl sub_81140EC(int a1);
void __cdecl sub_811416E(int a1);
void __cdecl sub_81141E2(int a1);
void __cdecl sub_811424A(int a1);
void __cdecl sub_81142BE(int a1);
int __cdecl GScr_PlaceSpawnPoint(int a1);
int __cdecl GScr_UpdateScores(int a1);
void GScr_MapRestart();
void GScr_LoadMap();
void GScr_ExitLevel();
// int *__usercall GScr_AddTestClient@<eax>(long double a1@<st0>);
// char *__usercall GScr_MakeDvarServerInfo@<eax>(long double a1@<st0>);
int GScr_AllClientsPrint();
int GScr_MapExists();
int GScr_IsValidGameType();
int GScr_SetVoteString();
int GScr_SetVoteTime();
int GScr_SetVoteYesCount();
int GScr_SetVoteNoCount();
void GScr_KickPlayer();
void GScr_BanPlayer();
int GScr_ClientPrint();
unsigned int GScr_OpenFile();
int GScr_CloseFile();
int GScr_FPrintln();
int GScr_FReadLn();
int GScr_FGetArg();
void *sub_8115462();
int sub_8115490();
void __cdecl GScr_SetTeamForTrigger(int a1);
int __cdecl GScr_ClientClaimTrigger(int a1);
int __cdecl GScr_ClientReleaseTrigger(int a1);
int __cdecl GScr_ReleaseClaimedTrigger(int a1);
int __cdecl Scr_GetFunction(char **a1, _DWORD *a2);
int __cdecl Script_GetMethod(char **a1, _DWORD *a2);
int (__cdecl *__cdecl Scr_GetMethod(char **a1, _DWORD *a2))(int);
int __cdecl sub_81159D4(int a1);
int __cdecl sub_8115A18(_DWORD *a1);
int __cdecl sub_8115A46(_DWORD *a1);
_DWORD *__cdecl GScr_AddVector(_DWORD *a1);
int __cdecl GScr_AddEntity(int *a1);
int Scr_ParseGameTypeList();
int __cdecl sub_8115DD2(char *a1);
_BOOL4 __cdecl Scr_IsValidGameType(char *a1);
int sub_8115E66();
int sub_8115E94();
int __cdecl Scr_PlayerConnect(int *a1);
int __cdecl sub_8115EF6(int *a1);
int __cdecl Scr_PlayerDamage(int *a1, int *a2, int *a3, int a4, int a5, unsigned int a6, int a7, _DWORD *a8, _DWORD *a9, int a10, int a11);
int __cdecl Scr_PlayerKilled(int *a1, int *a2, int *a3, int a4, unsigned int a5, int a6, _DWORD *a7, int a8, int a9, int a10);
int __cdecl sub_81160D4(int *a1, char *a2, char *a3, char *s);
int __cdecl sub_811611C(int *a1, char *s);
int __cdecl floorf(float); // idb
void __cdecl sub_811618E(float a1, float *a2, float *a3);
int __cdecl sub_81161BC(_DWORD *a1);
int __cdecl sub_81161E6(_DWORD *a1, int a2, int a3, int a4);
int __cdecl Scr_VectorCopy(_DWORD *a1, _DWORD *a2);
float *__cdecl sub_811623A(float *a1, float *a2, float *a3);
float *__cdecl sub_811627E(float *a1, float *a2, float *a3);
float *__cdecl sub_81162C2(float *a1, float a2, float *a3);
long double __cdecl sub_81162FA(float *a1, float *a2);
long double __cdecl sub_811632E(float *a1);
void __cdecl sub_8116362(float *);
long double __cdecl sub_81163A0(float a1);
int __cdecl sub_81163C0(int a1, int a2, float a3, float a4, float a5, float *a6, float *a7, float *a8);
int __cdecl sub_81165A0(int a1);
float *__cdecl sub_81167BA(int a1, float *a2, float a3, float a4, float a5, float *a6, float *a7, float *a8, float *a9, float *a10, float *a11, _DWORD *a12);
float *__cdecl sub_8116B6E(_DWORD *a1, float *a2, float a3, float a4, float a5, _DWORD *a6, float *a7, float *a8, float *a9, float *a10, float *a11, _DWORD *a12);
int __cdecl sub_8116F18(int a1, float *a2, float a3, float a4, float a5);
int __cdecl sub_8116FAA(_DWORD *a1, _DWORD *a2, float a3);
int __cdecl sub_8117050(int a1, float *a2, float a3, float a4, float a5);
int __cdecl sub_81170E2(int a1, float *a2, float a3, float a4, float a5);
int __cdecl sub_8117174(int a1);
int __cdecl sub_8117316(int a1);
// int __usercall sub_811734C@<eax>(long double a1@<st0>, int a2);
int __cdecl sub_8117398(int a1);
void __cdecl sub_81173F6(float *a1, float *a2, float *a3);
int __cdecl sub_81174FA(int a1);
int __cdecl sub_81175DC(int a1);
int __cdecl sub_81176A6(int a1, int a2);
int __cdecl sub_81177AC(int a1);
int __cdecl sub_81177C8(int a1);
int __cdecl sub_81177E4(int a1);
int __cdecl sub_8117800(int a1);
int __cdecl sub_8117938(int a1, int a2);
int __cdecl sub_8117A3E(int a1);
int __cdecl sub_8117A5A(int a1);
int __cdecl sub_8117A76(int a1);
int __cdecl sub_8117A92(int a1);
void __cdecl ScriptEntCmd_Solid(int a1);
void __cdecl ScriptEntCmd_NotSolid(int a1);
int (__cdecl *__cdecl ScriptEnt_GetMethod(char **a1))(int);
int __cdecl sub_8117DEE(_DWORD *a1, _DWORD *a2);
float *__cdecl sub_8117E1E(float *a1, float *a2, float *a3);
float *__cdecl sub_8117E62(float *a1, float a2, float *a3);
float *__cdecl sub_8117E9A(float *a1, float a2, float *a3, float *a4);
void __cdecl sub_8117EEE(float *);
long double __cdecl sub_8117F2C(float a1);
int __cdecl sub_8117F4C(char *s1, int a2, _DWORD *a3);
int __cdecl sub_8117F76(char *s1, int a2, float *a3);
int __cdecl sub_8117FB2(char *s1, int a2, int *a3);
int __cdecl sub_8117FEC(char *s1, int a2, _DWORD *a3);
void sub_811804C();
int __cdecl sub_8118060(char *s1, char *nptr); // idb
int __cdecl sub_8118148(char *s1, char *nptr, int *a3);
void __cdecl sub_8118180(char *s1, char *s, int *a3);
int __cdecl sub_8118320(int *a1);
int sub_8118398();
char **__cdecl sub_811841C(int a1, int a2);
int __cdecl sub_8118504(int *a1, int *a2);
int __cdecl sub_811852A(char *s1); // idb
// void __usercall G_CallSpawn(long double a1@<st0>);
// int __usercall G_CallSpawnEntity@<eax>(long double a1@<st0>, int a2);
char **sub_81187B8();
int GScr_AddFieldsForRadiant();
int __cdecl sub_8118822(int a1, int a2);
int __cdecl sub_81188EE(int a1, int a2, int a3);
int __cdecl sub_81189D2(int a1, int a2, int a3);
char *__cdecl sub_8118A22(int a1, int a2);
int __cdecl sub_8118AAC(int a1, int a2, int a3);
char *__cdecl sub_8118BCC(char *a1, int a2, int a3);
int *__cdecl sub_8118C0E(int a1);
void __cdecl sub_8118C98(int *a1);
int __cdecl Scr_AddEntity(int *a1);
int __cdecl Scr_GetEntity(unsigned int a1);
void __cdecl Scr_FreeHudElem(int a1);
int __cdecl Scr_AddHudElem(int a1);
int __cdecl sub_8118D98(unsigned int a1);
int __cdecl Scr_ExecEntThread(int *a1, int a2, int a3);
int __cdecl sub_8118E22(int *a1, int a2, int a3);
int __cdecl Scr_Notify(int *a1, unsigned __int16 a2, int a3);
int Scr_GetEnt();
int sub_8118F7E();
int __cdecl sub_81190B6(int *a1, int a2);
int SP_worldspawn();
// int __usercall G_SpawnEntitiesFromString@<eax>(long double a1@<st0>);
void *G_LoadStructs();
int __cdecl sub_81193A8(_DWORD *a1);
int __cdecl sub_81193D2(_DWORD *a1, _DWORD *a2);
int __cdecl sub_8119404(const char *a1, _DWORD *a2);
void sub_811956E();
void __cdecl sub_8119642(const char *a1);
char *G_ProcessIPBans();
void sub_8119772();
void sub_81197C2();
int Svcmd_EntityList_f();
int __cdecl sub_81199B4(char *nptr); // idb
int sub_8119AD4();
_BOOL4 __cdecl sub_8119C40(int a1, int a2);
int __cdecl sub_8119CB8(int a1);
int sub_8119EF2();
float *__cdecl sub_8119F76(float *a1, float a2, float *a3, float *a4);
int __cdecl sub_8119FCC(int *a1, int *a2);
int __cdecl sub_811A074(int a1);
void __cdecl sub_811A0AE(int a1, int a2);
int __cdecl sub_811A106(int a1);
int __cdecl sub_811A1B8(int *a1);
int __cdecl sub_811A1DE(int *a1, int *a2);
int __cdecl sub_811A20A(int a1);
int __cdecl sub_811A250(int a1);
int __cdecl sub_811A3F0(int a1);
int __cdecl sub_811A4FC(int a1, int a2);
int __cdecl SP_trigger_hurt(int a1);
int __cdecl sub_811A6A6(int a1);
_BOOL4 __cdecl sub_811A6EE(int a1, int a2);
int __cdecl sub_811A826(int *a1, int *a2, int a3, int a4);
int __cdecl sub_811A8D2(int *a1, int *a2);
int *__cdecl sub_811A902(int *a1, int *a2, int a3, int a4, int a5);
int *__cdecl sub_811A944(int *a1, int a2, int *a3, int a4, int a5);
int __cdecl SP_trigger_damage(int a1);
int __cdecl sub_811AA18(int *a1, _DWORD *a2, float *a3, int a4, int a5);
int __cdecl sub_811AC06(int *a1, _DWORD *a2, float *a3, int a4, int a5);
int __cdecl sub_811ADB6(int a1);
int __cdecl sub_811ADFA(_DWORD *a1, _DWORD *a2);
float *__cdecl sub_811AE2A(float *a1, float *a2, float *a3);
int __cdecl G_FindConfigstringIndex(char *s2, int a2, int a3, int a4, const char *a5);
int __cdecl G_LocalizedStringIndex(char *s2); // idb
int __cdecl sub_811AFBA(char *src); // idb
int __cdecl G_ModelIndex(char *s2); // idb
int __cdecl SV_XModelForIndex(int a1);
int __cdecl G_XModelBad(int a1);
const char *__cdecl G_ModelName(int a1);
int __cdecl sub_811B13C(char *s2); // idb
int __cdecl G_EffectIndex(char *s2); // idb
int __cdecl G_ShellShockIndex(char *s2); // idb
int __cdecl sub_811B1D8(char *s2); // idb
// _DWORD *__usercall sub_811B20E@<eax>(long double a1@<st0>, int a2);
int __cdecl sub_811B3EA(int, char *s2); // idb
int __cdecl G_OverrideModel(int, char *s1); // idb
// int __usercall sub_811B470@<eax>(long double a1@<st0>, int a2, char *s2, int a4, int a5);
// int __usercall sub_811B528@<eax>(long double a1@<st0>, int a2, char *s2, int a4);
// _DWORD *__usercall sub_811B6C2@<eax>(long double a1@<st0>, int a2);
// int __usercall sub_811B720@<eax>(long double a1@<st0>, int *a2, int *a3, int a4);
// int __usercall sub_811B86E@<eax>(long double a1@<st0>, int *a2, int *a3, int a4);
// int __usercall sub_811B8BA@<eax>(long double a1@<st0>, int *a2, int *a3, int a4, _DWORD *a5, float *a6);
// int __usercall G_EntUnlink@<eax>(long double a1@<st0>, _DWORD *a2);
// int __usercall sub_811BA8A@<eax>(long double a1@<st0>, _DWORD *a2, int a3);
// _DWORD *__usercall sub_811BAF4@<eax>(long double a1@<st0>, int a2, int a3);
float *__cdecl sub_811BB3A(int a1, int a2);
float *__cdecl sub_811BC46(int a1, float *a2);
float *__cdecl sub_811BC88(int a1, int a2);
void __cdecl sub_811BD52(int a1, int a2);
int __cdecl sub_811BE86(_DWORD *a1);
int __cdecl sub_811BEEE(int *a1);
int __cdecl sub_811BF04(int *a1, int a2);
int *__cdecl sub_811BF30(int a1);
int *__cdecl sub_811BFC4(int a1, int a2);
int __cdecl sub_811C056(int *a1, int a2);
int __cdecl sub_811C0B2(int a1, int a2, float *a3);
int __cdecl sub_811C16A(int a1, int a2, float *a3);
char *__cdecl sub_811C1EE(int a1, int a2, __int16 a3);
char *__cdecl sub_811C272(int a1, int a2, char *a3);
int __cdecl G_PickTarget(unsigned __int16 a1);
int __cdecl G_InitGentity(int a1);
int G_PrintEntities();
_BOOL4 __cdecl sub_811C4F8(int a1);
int G_Spawn();
// int *__usercall sub_811C614@<eax>(long double a1@<st0>);
int *__cdecl sub_811C6AE(int *a1);
int __cdecl sub_811C830(_DWORD *a1);
// int __usercall sub_811C87C@<eax>(long double a1@<st0>);
int __cdecl sub_811C996(_DWORD *a1);
// int __usercall G_FreeEntity@<eax>(long double a1@<st0>, int *s);
int __cdecl sub_811CB00(int *a1);
_DWORD *__cdecl G_TempEntity(_DWORD *a1, int a2);
int __cdecl sub_811CC24(int a1);
int __cdecl G_AddPredictableEvent(int a1, int a2, unsigned __int8 a3);
int __cdecl G_AddEvent(_DWORD *a1, int a2, int a3);
int __cdecl sub_811CE66(_DWORD *a1, int a2);
int __cdecl sub_811CE9E(_DWORD *a1, int a2);
int __cdecl sub_811CEFE(int a1, char **a2);
int __cdecl sub_811CF36(_DWORD *a1, _DWORD *a2);
int __cdecl sub_811CF96(_DWORD *a1, _DWORD *a2);
_BOOL4 __cdecl sub_811CFF6(int a1, int a2);
int __cdecl sub_811D098(_WORD *a1, char *s);
int __cdecl sub_811D0D2(_DWORD *a1);
int __cdecl sub_811D0FC(_DWORD *a1, _DWORD *a2);
float *__cdecl sub_811D12C(float *a1, float *a2, float *a3);
float *__cdecl sub_811D170(float *a1, float *a2, float *a3);
long double __cdecl sub_811D1B4(float *a1, float *a2);
int __cdecl sub_811D220(int *a1, float *a2, int a3, float a4, float a5, float a6, float *s, float *a8);
__int16 __cdecl sub_811D3B4(int *a1, float *a2, float a3, float a4, float a5);
int *__cdecl sub_811D53A(int a1, int a2);
float *__cdecl sub_811D5E0(float *a1, float *a2);
float *__cdecl sub_811D638(float a1, float *a2, float *a3, float a4);
int __cdecl sub_811D6EC(int, float); // idb
int __cdecl sub_811D7E6(int a1, char *s);
int __cdecl sub_811D95C(int a1);
void __cdecl sub_811DA00(int *a1, int *a2, float *a3, float *a4, float a5, int a6, int a7, _DWORD *a8, int a9);
int __cdecl sub_811DF44(int *a1, int *a2, int a3, int a4, float a5);
int __cdecl sub_811DFF4(int *a1, float a2, int a3, int *a4, int a5);
int __cdecl sub_811E0C2(_DWORD *a1, int a2, int a3);
float *__cdecl sub_811E18A(float *a1, float a2, int a3);
_BOOL4 __cdecl sub_811E2C2(int a1, int a2);
void __cdecl sub_811E35C(int a1, float *a2);
float *__cdecl sub_811E3E0(int a1, int a2);
float *__cdecl sub_811E56A(int a1);
int __cdecl sub_811E586(_DWORD *a1);
__int16 __cdecl sub_811E5E0(int a1);
int __cdecl sub_811E696(int a1, int a2);
void sub_811E8E4();
int __cdecl G_GetWeaponIndexForName(char *s1); // idb
int __cdecl sub_811E97A(int a1, int a2);
int __cdecl sub_811E9B4(int a1, int a2);
long double __cdecl sub_811E9EE(float a1, float a2, float a3);
void __cdecl sub_811EA04(float a1, float *a2, float *a3);
int __cdecl sub_811EA32(_DWORD *a1, _DWORD *a2);
float *__cdecl sub_811EA62(float *a1, float *a2, float *a3);
float *__cdecl sub_811EAA6(float *a1, float a2, float *a3);
float *__cdecl sub_811EADE(float *a1, float a2, float *a3, float *a4);
long double __cdecl sub_811EB32(float *a1, float *a2);
void __cdecl sub_811EB66(float *);
long double __cdecl sub_811EBA4(float a1);
int __cdecl sub_811EBC4(int *a1, int a2);
int __cdecl sub_811ECE4(int a1);
int __cdecl sub_811EDD4(int *a1);
int __cdecl sub_811EE84(int *a1);
int __cdecl sub_811EFC8(float *a1, float *a2);
int __cdecl sub_811F004(float *a1, _DWORD *base);
int __cdecl sub_811F61A(int a1, int a2);
_BYTE *__cdecl sub_811F6A6(int a1);
int *__cdecl sub_811F736(int a1);
int __cdecl sub_811FABE(float *s, float *a2, float *a3, int a4, int a5, int a6, float *a7);
void __cdecl sub_811FB7A(int *a1);
long double __cdecl sub_811FEDE(float a1);
float *__cdecl sub_811FEEA(float *a1, float *a2, float *a3);
float *__cdecl sub_811FF2E(float *a1, float *a2, float *a3);
float *__cdecl sub_811FF72(float *a1, float a2, float *a3);
float *__cdecl sub_811FFAA(float *a1, float a2, float *a3, float *a4);
long double __cdecl sub_811FFFE(float *a1, float *a2);
long double __cdecl sub_8120032(float *a1);
int sub_8120068();
int __cdecl sub_8120708(int a1);
int __cdecl sub_812074C(int a1, int a2);
int __cdecl sub_8120794(int a1, int a2);
int __cdecl sub_81207DC(int *a1);
int __cdecl sub_8120872(int *a1);
int __cdecl sub_81208D4(int *a1);
int __cdecl sub_8120936(int *a1, int a2);
_BYTE **__cdecl sub_8120968(int *a1, _BYTE *a2, int a3);
int __cdecl sub_8120AA2(int *a1, const char **a2);
int __cdecl sub_8120B02(int *a1, int a2);
int __cdecl sub_8120B70(int *a1, int a2);
int __cdecl sub_8120BDC(int *a1, int a2);
int __cdecl sub_8120BFA(int *a1, char *a2, int a3);
_BYTE **__cdecl sub_8120F84(int a1, char *a2, int a3);
int __cdecl sub_8120FCA(int a1, const char ***a2);
int __cdecl sub_8121006(int a1, int *a2);
int __cdecl sub_8121040(int a1, int *a2);
int __cdecl sub_812107A(int a1, int a2);
int __cdecl sub_81210B2(int a1, char a2);
int __cdecl sub_81210DA(int a1);
int __cdecl sub_8121100(int *a1);
long double __cdecl sub_8121126(int *a1);
int __cdecl sub_8121152(int *a1, char a2);
int sub_812117A(int *a1, ...);
int __cdecl sub_812119C(_DWORD *a1, int a2, int a3, int a4);
int __cdecl sub_812123C(int *a1, int *a2);
_DWORD *__cdecl sub_8121272(_DWORD *a1, int a2, int a3, int a4);
_DWORD *__cdecl sub_8121304(_DWORD *a1, int a2, int a3, int a4, int a5);
_DWORD *__cdecl sub_81213C4(_DWORD *a1, int a2, char a3, int a4, int a5, float a6, float a7);
_DWORD *__cdecl sub_81216CE(int a1, int a2, float a3, char a4, _DWORD *a5);
void __cdecl sub_81218EE(float, float);
long double __cdecl sub_8121912(float a1, float a2, float a3);
_DWORD *__cdecl sub_812193C(_DWORD *a1, int a2);
long double __cdecl sub_8121962(float a1, float a2, float a3, float a4);
long double __cdecl sub_812197E(_DWORD *a1, float a2);
long double __cdecl sub_8121A60(float *a1, float a2);
_DWORD *__cdecl sub_8121AAC(float *src, int a2, int a3);
int __cdecl sub_8121C40(int a1);
unsigned int *FxMem_Init();
int *__cdecl sub_8121C8A(int a1, int a2, int a3);
int __cdecl sub_8121D9A(int a1);
int __cdecl sub_8121E02(int a1);
char *__cdecl sub_8121E22(char *a1);
void __cdecl sub_8121E7C(int a1, int a2);
// _DWORD *__userpurge sub_8121EF6@<eax>(_DWORD *a1, _DWORD *a2);
int __cdecl sub_8121FB2(int a1);
_DWORD *__cdecl sub_8122008(_DWORD *a1);
_DWORD *__cdecl sub_81220BE(_DWORD *a1, _DWORD *a2);
_DWORD *__cdecl sub_81220FC(int *a1, int *a2);
void *__cdecl sub_81221F2(size_t a1);
int __cdecl sub_8122206(char *s2); // idb
_DWORD *__cdecl sub_812222A(_DWORD *a1);
int __cdecl sub_812226E(_DWORD *a1);
int __cdecl sub_81222A6(_DWORD *a1);
int __cdecl sub_81222DE(int a1);
void sub_8122316();
int sub_812231C();
void sub_8122326();
_BOOL4 __cdecl sub_812232C(int a1, _DWORD *a2);
int __cdecl sub_8122382(int a1);
int __cdecl sub_81223CE(int a1);
int __cdecl sub_8122472(int a1, int a2, int a3);
int __cdecl sub_8122490(int a1);
_DWORD *__cdecl sub_81224B2(int a1, _DWORD *a2);
int sub_81224D2();
int __cdecl sub_81224DC(int a1, int *a2);
void sub_8122668();
void __cdecl sub_812266E(int a1, int a2);
int __cdecl sub_81227C4(_DWORD *a1);
int __cdecl sub_81227F0(_DWORD *a1);
int __cdecl sub_812281C(_DWORD *a1);
int __cdecl sub_8122850(_DWORD *a1);
int __cdecl sub_8122884(char *a1);
void __cdecl sub_81228B8(int a1);
int __cdecl sub_81229F0(int a1);
void __cdecl sub_8122A2E(int a1);
int __cdecl sub_8122A76(float *a1);
int __cdecl sub_8122BB2(_DWORD *a1, _DWORD *a2);
void __cdecl sub_8122C06(int a1, int a2);
void __cdecl sub_8122C3C(int a1, int a2);
int __cdecl sub_8122EAC(int a1, int a2, int a3, int a4);
int __cdecl sub_8122EDA(int a1, int a2, int a3, int a4);
long double __cdecl sub_8122F08(int a1, float *a2, float *a3, float a4);
int __cdecl sub_8122FEA(int a1);
long double __cdecl sub_8123068(int a1, float a2, float a3);
_BOOL4 __cdecl sub_812309A(float *a1, int a2, float a3);
int __cdecl sub_8123100(int a1);
float *__cdecl sub_8123134(int a1, float *a2, float a3, float *a4, float a5, float *a6);
_BOOL4 __cdecl sub_812325E(int a1);
int __cdecl sub_81232B2(int a1, float *a2);
float *__cdecl sub_8123660(int a1, float a2, float *a3, float *a4);
float *__cdecl sub_81237F4(int a1, float a2, float *a3, float *a4);
float *__cdecl sub_8123988(int a1, float a2, float *a3, float *a4);
float *__cdecl sub_8123A0A(int a1, float a2, float *a3);
float *__cdecl sub_8123B94(int a1, float a2, float *a3);
int __cdecl sub_8123D1E(int a1, int a2, int a3);
float *__cdecl sub_8123D56(int a1, int a2, float *a3);
float *__cdecl sub_8123E30(int a1, float *a2);
float *__cdecl sub_8123EA4(int a1, float a2, float *a3, float *a4);
void __cdecl sub_8123F5C(int a1);
void __cdecl sub_8123FE0(int a1);
void __cdecl sub_8124080(int a1);
int __cdecl sub_812410E(int a1);
int __cdecl sub_812427C(int a1);
int __cdecl sub_812430C(int a1);
int sub_812447E();
_BYTE **__cdecl sub_8124488(char *a1, int *a2);
int __cdecl sub_8124824(_DWORD *a1, _DWORD *a2);
_DWORD *__cdecl sub_81249E6(_DWORD *a1);
int __cdecl sub_8124A02(_DWORD *a1);
int __cdecl sub_8124A36(_DWORD *a1);
int __cdecl sub_8124A6A(char *a1);
int __cdecl sub_8124A9E(int a1);
void __cdecl sub_8124ADC(int a1);
int __cdecl sub_8124AF8(float *a1);
int sub_8124C2C();
_BYTE **__cdecl sub_8124C36(char *a1, int *a2);
void __cdecl sub_8124C68(_DWORD *a1);
void __cdecl sub_8124CB6(_DWORD *a1);
int __cdecl sub_8124D04(_DWORD *a1);
int __cdecl sub_8124D38(_DWORD *a1);
int __cdecl sub_8124D6C(char *a1);
void sub_8124DA0();
// int __usercall sub_8124DA6@<eax>(long double a1@<st0>, float *a2);
void __cdecl sub_8124E0C(int a1);
void __cdecl sub_8124EE4(int a1);
void __cdecl sub_8124F00(int a1, int a2);
void __cdecl sub_8124F52(int a1);
int __cdecl sub_8124FE0(int a1);
int sub_8125198();
_BYTE **__cdecl sub_81251A2(char *a1, int *a2);
int __cdecl sub_8125230(_DWORD *a1, _DWORD *a2);
_DWORD *__cdecl sub_812528A(_DWORD *a1);
int __cdecl sub_81252A6(_DWORD *a1);
int __cdecl sub_81252DA(_DWORD *a1);
int __cdecl sub_812530E(char *a1);
void sub_8125342();
int __cdecl sub_8125348(float *a1);
void __cdecl sub_81253A0(int a1);
int __cdecl sub_81253BC(float *a1);
int sub_81254B2();
_BYTE **__cdecl sub_81254BC(char *a1, int *a2);
_DWORD *__cdecl sub_81254EE(_DWORD *a1);
_DWORD *__cdecl sub_812550A(_DWORD *a1);
int __cdecl sub_8125526(_DWORD *a1);
int __cdecl sub_812555A(_DWORD *a1);
int __cdecl sub_812558E(char *a1);
// void __usercall sub_81255C2(long double a1@<st0>, float *a2);
int __cdecl sub_81255E8(float *a1);
void __cdecl sub_8125640(int a1, int a2);
void __cdecl sub_8125692(int a1);
// int __usercall sub_81256AE@<eax>(long double a1@<st0>, int a2);
void __cdecl sub_81257C8(int a1);
// void __usercall sub_8125848(long double a1@<st0>, float *a2, float *a3);
int sub_812592A();
_BYTE **__cdecl sub_8125934(char *a1, int *a2);
int __cdecl sub_81259AA(_DWORD *a1, _DWORD *a2);
_DWORD *__cdecl sub_8125A04(_DWORD *a1);
int __cdecl sub_8125A20(_DWORD *a1);
int __cdecl sub_8125A54(_DWORD *a1);
int __cdecl sub_8125A88(char *a1);
int __cdecl sub_8125ABC(float *a1);
void __cdecl sub_8125B14(int a1);
int __cdecl sub_8125B30(float *a1);
int sub_8125C78();
_BYTE **__cdecl sub_8125C82(char *a1, int *a2);
_DWORD *__cdecl sub_8125CB8(_DWORD *a1);
int __cdecl sub_8125CD4(_DWORD *a1);
int __cdecl sub_8125D08(_DWORD *a1);
int __cdecl sub_8125D3C(char *a1);
int sub_8125D70();
void __cdecl sub_8125D7A(int a1);
int __cdecl sub_8125DBE(int a1);
int __cdecl sub_8126034(int a1, float *a2, float *a3);
float *__cdecl sub_81265F4(int a1);
int sub_8126652();
int __cdecl sub_812665C(int a1, int *a2);
_DWORD *__cdecl sub_812677E(_DWORD *a1);
_DWORD *__cdecl sub_812679A(_DWORD *a1);
int __cdecl sub_81267B6(_DWORD *a1);
int __cdecl sub_81267EA(_DWORD *a1);
int __cdecl sub_812681E(char *a1);
void __cdecl sub_8126852(int a1, int a2);
int __cdecl sub_81268CA(int a1);
void sub_8126908();
int __cdecl sub_8126952(int a1);
void __cdecl sub_81269F8(int a1);
float *__cdecl sub_8126A7C(int a1);
int sub_8126AFA();
_BYTE **__cdecl sub_8126B04(int a1, int *a2);
int __cdecl sub_8126BA8(_DWORD *a1, _DWORD *a2);
int __cdecl sub_8126C0A(int a1);
int __cdecl sub_8126C40(int a1);
void __cdecl sub_8126D3C(int a1);
int sub_8126E24();
_BYTE **__cdecl sub_8126E2E(int a1, int *a2);
_DWORD *__cdecl sub_8126E48(int a1, int a2);
long double __cdecl sub_8126F5E(float a1);
void __cdecl sub_8126F78(float, float);
int __cdecl sub_8126F9C(int a1, int a2);
long double __cdecl sub_8126FC2(float a1, float a2, float a3);
int __cdecl sub_8127000(int a1, int a2, int a3);
long double __cdecl sub_8127042(float a1, float a2, float a3);
int __cdecl sub_8127084(float); // idb
int __cdecl sub_81270BA(_DWORD *a1);
int __cdecl sub_81270E4(_DWORD *a1, int a2, int a3, int a4);
int __cdecl sub_8127108(_DWORD *a1, _DWORD *a2);
int __cdecl sub_8127138(_DWORD *a1, _DWORD *a2);
float *__cdecl sub_8127166(float *a1, float *a2, float *a3);
float *__cdecl sub_81271AA(float *a1, float *a2, float *a3);
float *__cdecl sub_81271EE(float *a1, float a2, float *a3);
float *__cdecl sub_8127226(float *a1, float a2, float *a3, float *a4);
long double __cdecl sub_812727A(float *a1, float *a2);
int __cdecl sub_81272AE(float *a1, float *a2);
long double __cdecl sub_8127318(float *a1);
void __cdecl sub_812734C(float *);
int __cdecl sub_812738A(float *a1, _BYTE *a2);
long double __cdecl sub_8127490(float a1, float a2, float a3);
long double __cdecl sub_81274BA(float a1);
int __cdecl sub_81274DA(int a1, int a2, int a3);
int __cdecl sub_81274FA(int a1, int a2);
float *__cdecl sub_8127520(float *a1, float *a2, float a3, float *a4);
_DWORD *ctor_001();
long double __cdecl sub_81275A6(int a1, float a2);
float *__cdecl sub_81275C6(int a1, float *a2, float a3);
long double __cdecl sub_8127604(int a1, _DWORD *a2, float a3, float a4);
float *__cdecl sub_8127650(int a1, _DWORD *a2, float a3, float *a4, float a5);
long double __cdecl sub_81276E0(int a1, float a2);
long double __cdecl sub_8127702(int a1, _DWORD **a2, float a3, float a4);
int *__cdecl sub_8127752(int a1);
int __cdecl sub_812776E(char *a1);
_DWORD *__cdecl sub_812778A(_DWORD *a1);
_DWORD *__cdecl sub_8127798(_DWORD *a1, _DWORD *a2);
int __cdecl sub_81277B6(int *a1);
_DWORD *__cdecl sub_81277D4(int *a1, _DWORD *a2);
_BOOL4 __cdecl sub_812782E(_DWORD *a1);
_DWORD *__cdecl sub_8127840(int *a1, _DWORD *a2);
int __cdecl sub_812787E(int a1);
long double sub_8127888();
void sub_8127890();
int __cdecl sub_8127896(int a1);
int __cdecl sub_81278B0(char *a1);
int __cdecl sub_81278CC(char *a1);
int __cdecl sub_81278E8(_DWORD *a1);
int __cdecl sub_812791C(char *a1);
int sub_8127950();
int __cdecl sub_812795A(char *a1);
int __cdecl sub_8127976(char *a1);
int __cdecl sub_8127992(char *a1);
int __cdecl sub_81279AE(char *a1);
int __cdecl sub_81279CA(char *a1);
int __cdecl sub_81279E6(char *a1);
float *__cdecl sub_8127A02(float *a1);
int __cdecl sub_8127A2E(char *a1);
int __cdecl sub_8127A4A(int a1);
int __cdecl sub_8127A56(int *a1);
int sub_8127A7C(int *a1, ...);
_BYTE **__cdecl sub_8127A9E(int a1, char *a2);
_BYTE **__cdecl sub_8127AC0(int a1, char *a2);
_BYTE **__cdecl sub_8127AE2(int a1, char *a2);
_BYTE **__cdecl sub_8127B04(int a1, char *a2);
_DWORD *__cdecl sub_8127B26(_DWORD *a1);
_DWORD *__cdecl sub_8127B3E(_DWORD *a1);
_DWORD *__cdecl sub_8127B56(_DWORD *a1);
_DWORD *__cdecl sub_8127B6E(_DWORD *a1);
_DWORD *__cdecl sub_8127B86(_DWORD *a1);
_DWORD *__cdecl sub_8127B9E(_DWORD *a1);
_DWORD *__cdecl sub_8127BB6(_DWORD *a1);
_DWORD *__cdecl sub_8127BCE(_DWORD *a1);
_DWORD *__cdecl sub_8127BE6(_DWORD *a1);
_DWORD *__cdecl sub_8127BFE(_DWORD *a1);
long double __cdecl sub_8127C16(_DWORD *a1, float a2);
float *__cdecl sub_8127C62(_DWORD *a1, float *a2, float a3);
_DWORD *__cdecl sub_8127CAA(_DWORD *a1);
int *__cdecl sub_8127CB8(int *a1, int a2);
int __cdecl sub_8127D96(int a1, int a2);
int __cdecl sub_8127DDE(int *a1, char *a2);
int __cdecl sub_8127E76(int *a1, char *a2);
int __cdecl sub_8127F0E(int *a1, char *a2);
int __cdecl sub_8127FA6(int *a1, char *a2);
int __cdecl sub_812803E(int *a1, char *a2);
int __cdecl sub_81280D6(int *a1, char *a2);
int __cdecl sub_812816E(int *a1, char *a2);
int __cdecl sub_8128206(int *a1, char *a2);
int __cdecl sub_812829E(int *a1, char *a2);
int __cdecl sub_8128336(int *a1, char *a2);
float *__cdecl sub_81283CE(float *a1, float a2, float *a3);
void __cdecl sub_8128426(_DWORD *a1, float a2);
int __cdecl sub_81284AE(int a1, int a2);
int __cdecl sub_81284F6(int a1, int a2);
int __cdecl sub_812853E(int a1, int a2);
int __cdecl sub_8128586(int a1, int a2);
int __cdecl sub_81285CE(int a1, int a2);
int __cdecl sub_8128616(int a1, int a2);
int __cdecl sub_812865E(int a1, int a2);
int __cdecl sub_81286A6(int a1, int a2);
int __cdecl sub_81286EE(int a1, int a2);
int __cdecl sub_812873E(int a1);
// _DWORD *__userpurge sub_812875E@<eax>(_DWORD *a1, int a2);
int __cdecl sub_81287D0(int a1);
int __cdecl sub_81287EA(int a1, char a2, int a3);
void sub_8128844();
void __cdecl sub_8128858(int *a1, int a2, float *a3);
void __cdecl sub_8128900(int *a1, int a2, float *a3, _DWORD *a4);
void __cdecl sub_8128962(int *a1, int a2, float *a3, _DWORD *a4, _DWORD *a5);
_BOOL4 __cdecl sub_81289D8(int a1, float *a2);
void __cdecl sub_8128ACC(int *a1, int a2, float *a3, _DWORD *a4, int *a5);
long double __cdecl sub_8128E8A(int a1, int a2);
float *__cdecl sub_8128EFA(int a1, int a2, float *a3);
void __cdecl sub_8128FA2(int a1, int a2);
long double __cdecl sub_812905E(int a1, int a2);
void sub_8129104();
_BOOL4 __cdecl sub_812910A(int a1, int *a2, int *a3);
float *__cdecl sub_81291DE(int a1, float *a2, int a3);
void __cdecl sub_8129250(int *a1, float *a2, float *a3, int a4, int a5);
int __cdecl sub_8129488(int a1, int a2, int a3, int *a4, float *a5, _DWORD *a6, int a7, int a8);
int *__cdecl sub_8129558(int a1, int *a2);
_BYTE **__cdecl sub_812966C(int a1, int a2);
void sub_8129736();
const char **__cdecl sub_8129746(char *s2);
int __cdecl sub_81297A0(int a1);
char **__cdecl sub_81297F2(char *s2);
int __cdecl sub_81298BC(int a1);
_DWORD *__cdecl sub_812993E(int a1, int a2);
long double __cdecl sub_812997C(float a1);
long double __cdecl sub_8129996(float a1, float a2, float a3);
int __cdecl sub_81299D8(_DWORD *a1);
int __cdecl sub_8129A02(_DWORD *a1, int a2, int a3, int a4);
int __cdecl sub_8129A26(_DWORD *a1, _DWORD *a2);
_DWORD *ctor_002();
_DWORD *__cdecl sub_8129BAC(int a1);
int __cdecl sub_8129BC2(int a1);
int *__cdecl sub_8129BD8(int a1);
int __cdecl sub_8129BF4(char *a1);
_DWORD *__cdecl sub_8129C10(_DWORD *a1);
_DWORD *__cdecl sub_8129C28(_DWORD *a1);
int *__cdecl sub_8129C40(int *a1, int a2);
int __cdecl sub_8129D1E(int a1, int a2);
int __cdecl sub_8129D66(int *a1, char *a2);
void *__cdecl sub_8129E00(size_t n);
int __cdecl sub_8129E1C(int a1);
int __cdecl sub_8129E52(int a1, const char *a2);
char **sub_8129F2C();
int __cdecl sub_8129F6A(int a1);
void __cdecl sub_812A004(int a1, int a2);
_BOOL4 __cdecl sub_812A03C(int a1);
int __cdecl sub_812A074(int a1);
char **__cdecl sub_812A0D2(int a1, char *s);
int __cdecl sub_812A418(int a1);
int __cdecl sub_812A452(int a1, int a2);
int __cdecl sub_812A50C(int a1, int a2);
_BYTE *__cdecl sub_812A52C(_BYTE *a1, _BYTE *a2);
int __cdecl sub_812A552(_BYTE *a1, _BYTE *a2, int a3);
int __cdecl sub_812A5EA(int a1);
int __cdecl sub_812A5F4(int a1);
int __cdecl sub_812A600(int a1);
int __cdecl sub_812A60C(int a1);
_DWORD *__cdecl sub_812A642(_DWORD *a1);
_DWORD *__cdecl sub_812A670(_DWORD *a1);
int __cdecl sub_812A6B4(_DWORD *a1, int a2);
int __cdecl sub_812A776(int *a1, int a2);
void __cdecl sub_812A882(int a1, int a2, float a3);
void __cdecl sub_812AAD2(int a1, int a2, float a3);
int __cdecl sub_812AB74(int a1, float *a2, float a3, int a4);
int __cdecl sub_812ABF4(int a1, float *a2, float a3);
int __cdecl sub_812AC82(int a1, float *a2, float *a3, float a4, float a5, int a6);
int __cdecl sub_812AD4E(int a1, float *s, float *a3, int a4, int a5, float *a6, int a7, int a8);
void sub_812ADC0();
int __cdecl sub_812ADC6(int a1, int a2);
int sub_812ADD4();
int __cdecl sub_812ADDE(int a1, int a2);
int sub_812AE52();
int sub_812AE5C();
void sub_812AE66();
void sub_812AE72();
int __cdecl sub_812AE78(int a1);
void __cdecl sub_812AEA8(float a1, float *a2, float *a3);
int __cdecl sub_812AED6(_DWORD *a1, _DWORD *a2);
unsigned int __cdecl sub_812AF06(_DWORD *a1, unsigned int *a2);
float *__cdecl sub_812AF44(float *a1, float a2, float *a3);
float *__cdecl sub_812AF7C(float *a1, float a2, float *a3, float *a4);
long double __cdecl sub_812AFD0(float *a1, float *a2);
int __cdecl sub_812B004(_DWORD *a1);
int __cdecl sub_812B566(int a1);
int *__cdecl sub_812B5B6(int a1, void *s);
int *__cdecl sub_812B68C(int a1, int a2);
int __cdecl sub_812B73A(int a1, char *s, _DWORD *a3, _DWORD *a4);
int __cdecl sub_812B7A4(int a1, char *s, _DWORD *a3, _DWORD *a4);
int __cdecl sub_812B850(int a1, char *s, _DWORD *a3);
int __cdecl sub_812BA42(int, char *s); // idb
int __cdecl sub_812BAAE(int, char *s); // idb
int __cdecl sub_812BB1A(int, char *s); // idb
int __cdecl sub_812BB76(int, char *s); // idb
int __cdecl sub_812BBEC(int, char *s); // idb
int __cdecl sub_812BC48(int, char *s); // idb
int __cdecl sub_812BCA4(int, char *s); // idb
int __cdecl sub_812BD9A(_DWORD *a1, char *s);
int __cdecl sub_812BE34(_DWORD *a1, char *s);
int __cdecl sub_812BECE(int, char *s); // idb
int __cdecl sub_812BF2C(int, char *s); // idb
int __cdecl sub_812BF8A(int, char *s); // idb
int __cdecl sub_812BFE8(int, char *s); // idb
long double __cdecl sub_812C046(int a1, float a2, float a3);
int __cdecl sub_812C07A(int a1, float a2, float a3, float a4, int a5, int a6);
int __cdecl sub_812C1E6(int, float, float, int, int); // idb
int __cdecl sub_812C294(int, float, float, float, int, int); // idb
int __cdecl sub_812C354(int, char *s); // idb
int __cdecl sub_812C46E(_DWORD *a1, char *s);
int __cdecl sub_812C508(_DWORD *a1, char *s);
int __cdecl sub_812C5A2(int, char *s); // idb
int __cdecl sub_812C812(int, char *s2, int, int); // idb
int __cdecl sub_812C8A0(int, char *s, int, int); // idb
int __cdecl sub_812C978(int, char *s); // idb
int __cdecl sub_812C9A6(int, char *s); // idb
int __cdecl sub_812C9D4(int, char *s); // idb
int __cdecl sub_812CC8A(int, char *s); // idb
int __cdecl sub_812CCE8(int, char *s); // idb
int __cdecl sub_812CD46(int, char *s); // idb
int __cdecl sub_812CDA4(int, char *nptr); // idb
_BOOL4 __cdecl sub_812CDE8(int a1, char *nptr);
int __cdecl sub_812CE28(int, char *nptr); // idb
_BOOL4 __cdecl sub_812CE6C(int a1, char *nptr);
int __cdecl sub_812CEB4(int, char *nptr); // idb
_BOOL4 __cdecl sub_812CEF8(int a1, char *nptr);
int __cdecl sub_812CF38(int, char *nptr); // idb
int __cdecl sub_812CF7C(int, int, char *s, int); // idb
int __cdecl sub_812D010(int, int, char *s, int); // idb
int __cdecl sub_812D0A8(int, int, char *s, int); // idb
int __cdecl sub_812D13C(int, int, char *s, int); // idb
int __cdecl sub_812D1D2(int, int, char *s, int); // idb
int __cdecl sub_812D246(int, int, char *s, int); // idb
int __cdecl sub_812D2B4(int a1, int a2);
int __cdecl sub_812D392(int a1, int a2);
int __cdecl sub_812D4A0(int a1, int a2);
int __cdecl sub_812D5BC(int a1, int a2);
int __cdecl sub_812D6D8(int a1, int a2);
int __cdecl sub_812D7F4(int a1, int a2);
void __cdecl sub_812D8FC(int a1, int a2, int a3);
void __cdecl sub_812DA14(int a1, int a2, int a3);
int __cdecl sub_812DB0C(int, char *s, int); // idb
int __cdecl sub_812DB62(int a1, int a2, int a3, unsigned int a4);
int __cdecl sub_812DDDE(int, char *src); // idb
int __cdecl sub_812DE08(char *dest, void *s, int); // idb
int __cdecl sub_812F060(char *dest, int); // idb
void sub_812F0A2(char *format, ...);
int sub_812F0DE();
int __cdecl sub_812F0E8(char *s1); // idb
int __cdecl sub_812F15A(_DWORD *a1, int a2, int a3);
long double __cdecl sub_812F170(float *a1);
long double __cdecl sub_812F1B8(float *a1, float a2);
void __cdecl sub_812F1D0(float, float);
long double __cdecl sub_812F1F4(float a1, float a2, float a3);
int __cdecl sub_812F232(_DWORD *a1, _DWORD *a2);
int __cdecl sub_812F262(float *a1, float *a2);
long double __cdecl sub_812F2CC(float a1, float a2, float a3);
int __cdecl sub_812F2F6(int *a1, int *a2);
int __cdecl sub_812F318(int a1);
int __cdecl sub_812F324(int a1);
int __cdecl sub_812F330(int a1);
int __cdecl sub_812F33C(int a1);
void sub_812F348();
void sub_812F34E();
int __cdecl sub_812F386(int a1, int a2);
void __cdecl sub_812F3CC(int a1, float *a2);
void __cdecl sub_812F3F0(int a1, float *a2, _DWORD *a3);
void __cdecl sub_812F41A(int a1, float *a2, _DWORD *a3, _DWORD *a4);
void __cdecl sub_812F44C(int a1, float *a2, _DWORD *a3, int *a4);
int __cdecl sub_812F47E(char a1);
int FX_FreeSystem();
int FX_FreeActive();
void __cdecl FX_AdjustCamera(int a1, float a2);
int __cdecl FX_AdjustTime(int a1);
int __cdecl FX_WarpTime(int a1);
void __cdecl sub_812F544(int);
char *__cdecl sub_812F560(char **a1, char a2, char a3);
void *__cdecl sub_812F7FC(_DWORD *a1, int a2);
void *__cdecl sub_812F83A(_DWORD *a1, int a2);
void __cdecl sub_812F878(void **a1);
void __cdecl sub_812F88E(void **a1);
size_t __cdecl sub_812F8A4(_DWORD *a1, char *s, unsigned __int8 a3, int *a4);
void __cdecl sub_812F9F8(void **a1);
_DWORD *__cdecl sub_812FA42(_DWORD *a1, int a2);
_DWORD *__cdecl sub_812FA6E(_DWORD *a1, int a2);
int __cdecl sub_812FA9A(int a1, int *a2, char *s);
_DWORD *__cdecl sub_812FB56(_DWORD *a1, int a2, char *s);
_DWORD *__cdecl sub_812FB9A(_DWORD *a1, int a2, char *s);
int __cdecl sub_812FBDE(int a1);
int __cdecl sub_812FC1C(int a1);
_DWORD *__cdecl sub_812FC5A(int a1, int *a2);
_BOOL4 __cdecl sub_812FD7E(int a1);
int __cdecl sub_812FDB4(int a1);
int __cdecl sub_812FDE2(int a1, char *s, int *a3);
int __cdecl sub_812FEC2(int a1, char **a2, int *a3);
int __cdecl sub_812FF62(int a1, int *a2, int a3);
int __cdecl sub_813025C(int a1, int a2, int a3);
int __cdecl sub_81302C2(int a1);
int __cdecl sub_81302D6(int a1);
int __cdecl sub_8130352(int a1);
int *__cdecl sub_8130452(int a1, int *a2);
int __cdecl sub_813055A(int a1, int a2, int *a3, int *a4, int *a5);
_DWORD *__cdecl sub_8130652(int *a1, char *s, char *a3, int *a4);
int __cdecl sub_8130726(int *a1, int a2);
void *__cdecl sub_813075E(int *a1, char *s, int *a3);
int __cdecl sub_81307D4(int *a1, int a2);
int __cdecl sub_813080C(int, char *s1); // idb
_BOOL4 __cdecl sub_8130866(int a1, char **a2, int *a3);
int __cdecl sub_8130A3A(int a1, int *a2, int a3);
int __cdecl sub_8130C0A(int, char *s2); // idb
int __cdecl sub_8130C66(int, char *s2, int); // idb
int __cdecl sub_8130CD6(int a1);
int __cdecl sub_8130D0A(int a1);
int __cdecl sub_8130D4E(int a1);
_BOOL4 __cdecl sub_8130D92(int a1, char **a2, char a3, unsigned __int8 a4);
int __cdecl sub_8130E6E(int a1);
int sub_8130E9A(int a1, ...);
int __cdecl sub_8130EC0(int a1);
int __cdecl sub_8130ECC(int a1, int a2);
void *__cdecl sub_8130EDA(size_t size);
void __cdecl sub_8130EEE(void *ptr);
int __cdecl sub_8130F02(int a1, int a2);
int __cdecl sub_8130F10(int a1);
int __cdecl sub_8130F1C(int a1, int a2);
int __cdecl sub_8130F2A(int a1, int a2);
void *__cdecl sub_8130F38(size_t size);
void __cdecl sub_8130F4C(void *ptr);
int __cdecl sub_8130F60(int a1, unsigned __int8 a2);
int __cdecl sub_8130F78(int a1, unsigned __int8 a2);
size_t __cdecl sub_8130F90(float *a1);
void *__cdecl sub_8131042(void *a1);
int sub_8131180();
int __cdecl FX_Free(char a1);
int sub_81312E4();
int FX_GetBoneOrientation();
void sub_8131328();
int __cdecl sub_8131338(char a1);
int __cdecl sub_813142A(_DWORD *a1, char a2);
int __cdecl sub_8131468(int a1, char a2);
int __cdecl sub_81314B8(int a1, char a2);
void sub_8131508();
char *sub_813150E();
char *sub_813155A();
long double __cdecl sub_81315A6(float *a1, float *a2);
int sub_8131708();
long double __cdecl sub_81317D0(float *a1, float *a2);
int sub_8131926();
int sub_81319C4();
int __cdecl sub_8131A62(int a1);
int __cdecl sub_8131B58(_DWORD *a1, int *a2);
int __cdecl sub_8131BB6(int a1);
int __cdecl sub_8131CA6(int a1, int a2);
int __cdecl sub_8131CD8(int a1);
int __cdecl sub_81321D6(float *a1, float *a2);
int __cdecl sub_81322B8(float *a1, float *a2);
void __cdecl sub_81322F4(void *a1, size_t nmemb);
int sub_81323E6();
int sub_81324A6();
int __cdecl sub_8132566(int a1);
int sub_813261C();
int __cdecl sub_81326C8(int a1);
int sub_813277E();
void sub_8132838();
float *__cdecl sub_8132948(int a1, float *a2, float *a3, float *a4);
float *__cdecl sub_8132E4E(int a1, float *a2, float *a3, float *a4, float *a5);
float *__cdecl sub_8133120(int a1, int a2, float *a3, int a4);
int __cdecl sub_8133176(int *a1, _DWORD *a2, float *a3);
int __cdecl sub_8133348(int a1);
int __cdecl sub_813338E(int a1, int a2, int a3, int a4);
int __cdecl sub_813350E(int a1, _DWORD *a2, float *a3, float *a4, float *a5);
int __cdecl sub_81337F2(int *a1, float *a2, float *a3, int a4, int a5);
int __cdecl sub_813392A(int *a1, float *a2, float *a3);
void __cdecl sub_8133C04(int *a1, float *a2, float *a3, int a4, int a5);
int __cdecl sub_8133D9E(int *a1, float *a2, float *a3, int a4, int a5);
float *__cdecl sub_8133F44(int *a1, float *a2, float *a3, int a4);
void __cdecl sub_813431A(int a1, float *a2, float *a3);
int __cdecl sub_8134368(int a1, float *a2, float *a3);
void __cdecl sub_8134432(int a1, float *a2, float *a3);
int __cdecl sub_81344EE(int *a1, float *a2, float *a3);
int __cdecl sub_8134642(int *a1, float *a2, float *a3, int a4, int a5);
int __cdecl sub_81347FC(int *a1, int a2, float *a3);
int __cdecl sub_813493C(int *a1, float *a2, float *a3, int a4, int a5);
int sub_8134AAE();
int sub_8134C2A();
int sub_8134C64();
void sub_8134C9E();
int *__cdecl sub_8134D0C(int a1, int a2);
long double __cdecl sub_8134D5C(float a1);
void __cdecl sub_8134D76(float a1, float *a2, float *a3);
int __cdecl sub_8134DA4(_DWORD *a1, int a2, int a3, int a4);
int __cdecl sub_8134DC8(_DWORD *a1, _DWORD *a2);
float *__cdecl sub_8134DF8(float *a1, float *a2, float *a3);
float *__cdecl sub_8134E3C(float *a1, float *a2, float *a3);
float *__cdecl sub_8134E80(float *a1, float a2, float *a3);
float *__cdecl sub_8134EB8(float *a1, float a2, float *a3, float *a4);
long double __cdecl sub_8134F0C(float *a1, float *a2);
void __cdecl sub_8134F40(float *);
int __cdecl sub_8134F7E(int a1, int a2);
int __cdecl sub_8134FDC(int a1, int a2);
long double __cdecl sub_813503A(float a1);
int __cdecl sub_813505A(_DWORD *a1);
int __cdecl sub_8135084(_DWORD *a1, _DWORD *a2);
int *ctor_003();
int __cdecl sub_81350CE(int a1, int a2);
int __cdecl sub_81350EA(int a1, _DWORD *a2);
int __cdecl sub_813511E(int a1, _DWORD *a2);
int __cdecl sub_8135152(int a1, _DWORD *a2);
int __cdecl sub_8135186(int a1, int a2);
int __cdecl sub_8135198(int a1, int a2);
int __cdecl sub_81351A6(int a1, int a2);
int __cdecl sub_81351B4(int a1, int a2);
int __cdecl sub_81351C2(int a1, int a2);
int __cdecl sub_81351D0(int a1, int a2);
int __cdecl sub_81351DE(int a1);
int __cdecl sub_81351EC(int a1);
int __cdecl sub_81351F8(int a1);
int __cdecl sub_8135204(int a1, int a2);
int __cdecl sub_8135216(int a1, int a2);
int *__cdecl sub_8135228(int a1);
_DWORD *__cdecl sub_8135244(_DWORD *a1);
int __cdecl sub_8135260(int a1, int a2);
int __cdecl sub_813526E(int a1, int a2);
int __cdecl sub_813527C(int a1, int a2);
int __cdecl sub_813528E(int a1, int a2);
int __cdecl sub_813529C(int a1, int a2);
int __cdecl sub_81352AE(int a1, unsigned __int8 a2);
int __cdecl sub_81352CA(int a1, int a2);
int __cdecl sub_81352DC(int a1, int a2);
int __cdecl sub_81352EE(int a1, int a2);
int __cdecl sub_8135300(int a1, int a2);
int __cdecl sub_8135312(int a1, int a2);
int __cdecl sub_8135324(int a1, int a2);
int __cdecl sub_8135336(int a1, int a2);
int __cdecl sub_8135348(int a1, int a2);
int __cdecl sub_813535A(int a1, int a2);
int __cdecl sub_813536C(int a1, int a2);
int *__cdecl sub_813537E(int a1);
int *__cdecl sub_813539A(int a1);
int __cdecl sub_81353B6(int a1, _DWORD *a2);
int *__cdecl sub_81353D6(int a1);
int __cdecl sub_81353F2(int a1, _DWORD *a2);
int *__cdecl sub_8135412(int a1);
int __cdecl sub_813542E(int a1, _DWORD *a2);
int *__cdecl sub_813544E(int a1);
int __cdecl sub_813546A(int a1, _DWORD *a2);
int *__cdecl sub_8135488(int a1);
int __cdecl sub_81354A4(int a1, int a2);
int __cdecl sub_81354B6(int a1, _DWORD *a2);
int __cdecl sub_81354D6(int a1, _DWORD *a2);
int __cdecl sub_81354F6(int a1, int a2);
int __cdecl sub_8135508(int a1, int a2);
int __cdecl sub_813551A(int a1, int a2);
int __cdecl sub_813552C(int a1, int a2);
int __cdecl sub_813553E(int a1, _DWORD *a2);
int __cdecl sub_813555E(int a1, _DWORD *a2);
int __cdecl sub_813557E(int a1, _DWORD *a2);
int *__cdecl sub_813559E(int a1);
int __cdecl sub_81355BA(int a1);
void *sub_81355C8();
void __cdecl sub_81355DC(void *ptr);
int *__cdecl sub_81355F0(int *a1, int a2);
int *__cdecl sub_81356CE(int *a1, int a2);
int *__cdecl sub_81357AC(int *a1, int a2);
int *__cdecl sub_813588A(int *a1, int a2);
int *__cdecl sub_8135968(int *a1, int a2);
int *__cdecl sub_8135A46(int *a1, int a2);
int *__cdecl sub_8135B24(int *a1, int a2);
int *__cdecl sub_8135C02(int *a1, int a2);
unsigned int Language_UpdateCurrentAsian();
int sub_8135D0C();
// unsigned int __usercall SEH_InitLanguage@<eax>(long double a1@<st0>);
// int __usercall SEH_UpdateLanguageInfo@<eax>(long double a1@<st0>);
int sub_8135FAE();
void sub_8135FBC();
int __cdecl SEH_StringEd_SetLanguageStrings(unsigned int a1);
int __cdecl sub_813608C(_BYTE *a1);
char *__cdecl sub_81360E2(char *src);
int __cdecl sub_81361BE(char *dest, _BYTE *a2, const char *a3, int a4);
int __cdecl sub_81362A4(const char *a1, const char *a2, int a3);
_BOOL4 __cdecl sub_81367A0(__int16 a1);
_BOOL4 __cdecl sub_8136800(unsigned int a1);
_BOOL4 __cdecl sub_813688A(unsigned __int8 a1, char a2);
_BOOL4 __cdecl sub_81368E6(unsigned int a1);
int __cdecl sub_8136980(unsigned __int8 a1, unsigned __int8 a2);
_BOOL4 __cdecl sub_81369BE(unsigned int a1);
int __cdecl sub_8136A38(unsigned __int8 **a1, _DWORD *a2);
int Language_IsAsian();
int __cdecl sub_8136CE6(unsigned __int8 *a1);
char *__cdecl sub_8136D72(unsigned int a1);
int __cdecl sub_8136DA2(char *a1, int *a2);
int __cdecl sub_8136E02(unsigned __int8 a1, unsigned __int8 a2);
int __cdecl sub_8136E40(__int16 a1);
_BOOL4 __cdecl sub_8136E64(__int16 a1);
int __cdecl sub_8136E88(__int16 a1);
int __cdecl sub_8136EAC(const char *a1);
void __cdecl sub_8136EE2(_DWORD *a1);
void __cdecl sub_8136EF6(char *a1, const char *a2, int a3);
int __cdecl sub_813707E(const char *a1, int a2);
int __cdecl sub_81370C4(_DWORD *a1);
char *__cdecl sub_8137110(int a1, char *src);
char *__cdecl sub_813718C(int a1, char *src);
char *__cdecl sub_813722A(int a1, char *a2);
char *__cdecl sub_813727A(int a1, char *src);
int __cdecl sub_81372A4(int, char *src); // idb
int __cdecl sub_81372FC(int a1, char *s, const char **a3);
int __cdecl sub_8137378(int, char *haystack); // idb
std::string *__stdcall sub_8137430(std::string *a1, int a2, int a3);
char *__cdecl sub_81374D8(int a1, char *a2);
int __cdecl sub_81375AC(int a1, const char **a2, char *dest);
std::string *__stdcall sub_81376E8(std::string *a1, int a2, _BYTE *a3);
char *__cdecl sub_813785C(_DWORD *a1, char *s2, char a3);
int __cdecl sub_8137CD2(int a1);
int __cdecl sub_8137CE8(int a1, const char *a2);
int __cdecl sub_8137EEC(int a1, const char *a2, char *s1, int a4);
char *__cdecl sub_813803A(std::string *a1);
char *__cdecl sub_81380F6(char *src, char a2);
int __cdecl sub_813821E(int a1);
int sub_8138320();
int sub_8138336();
void sub_813839E();
char *__cdecl sub_81383EC(char a1);
_BOOL4 __cdecl sub_8138490(_DWORD *a1, _DWORD *a2);
// int *__userpurge sub_81384A6@<eax>(int *a1, int a2, std::string *a3);
// _DWORD *__userpurge sub_81384D2@<eax>(_DWORD *a1, int a2);
int __cdecl sub_81384F8(int, std::string *); // idb
int __cdecl sub_8138676(_DWORD *a1);
_BOOL4 __cdecl sub_813868A(_DWORD *a1, _DWORD *a2);
// int *__userpurge sub_81386A0@<eax>(int *a1, int a2, int *a3, std::string *a4);
char *__cdecl sub_81386E6(char *s, int c);
char *__cdecl sub_8138700(char *s, int c);
char *__cdecl sub_813871A(char *haystack, char *needle);
int __cdecl sub_8138734(int a1);
void __cdecl sub_81387C6(int a1);
void *sub_8138860();
void __cdecl sub_8138874(void *ptr);
int __cdecl sub_8138888(int a1);
int __cdecl sub_8138892(int a1);
int __cdecl sub_81388A6(int a1);
int __cdecl sub_8138918(int a1);
void __cdecl sub_8138926(std::string *a1);
void __cdecl sub_8138948(int a1, char *ptr);
int __cdecl sub_81389A0(int a1);
int __cdecl sub_81389AE(int a1);
int __cdecl sub_81389BC(int *a1, int *a2);
int __cdecl sub_81389DA(int a1);
void sub_8138A06();
int __cdecl sub_8138A0C(int a1);
void *__cdecl sub_8138A3C(int a1);
int __cdecl sub_8138A6C(int a1);
void sub_8138A90();
void *__cdecl sub_8138A96(int a1);
void *__cdecl sub_8138AB2(int a1, int a2);
int __cdecl sub_8138ACE(int a1);
int __cdecl sub_8138B26(int a1);
int __cdecl sub_8138B2E(int a1);
void __cdecl sub_8138B3A(int a1, char *ptr);
int __cdecl sub_8138B62(int, std::string *, std::string *); // idb
int __cdecl sub_8138B80(std::string *, std::string *); // idb
// _DWORD *__userpurge sub_8138B9E@<eax>(_DWORD *a1, int a2);
// int *__userpurge sub_8138BC4@<eax>(int *a1, int a2, std::string *a3);
// _DWORD *__userpurge sub_8138CD6@<eax>(_DWORD *a1, int a2, std::string *a3);
// _DWORD *__userpurge sub_8138D02@<eax>(_DWORD *a1, int a2, std::string *a3);
int __cdecl sub_8138D96(_DWORD *a1);
int __stdcall sub_8138DA4(int a1);
int __stdcall sub_8138DCA(int a1);
int __cdecl sub_8138DD4(std::string *, std::string *, std::string *); // idb
// int *__userpurge sub_8138E2A@<eax>(int *a1, int a2, int *a3, std::string *a4);
// int __userpurge sub_81390FA@<eax>(int a1, int a2, std::string *a3);
int __cdecl sub_81392DC(int a1);
int __cdecl sub_81392F2(int a1);
void sub_81392FE();
int __cdecl sub_8139304(int a1);
void __cdecl sub_81393A2(int a1);
int __cdecl sub_81393B6(int a1);
void __cdecl sub_81393C2(int a1, void *ptr);
void __cdecl sub_81393E4(int a1, void *ptr);
void __cdecl sub_81393F8(int a1);
void __cdecl sub_813943C(std::string *a1);
int __cdecl sub_8139450(int a1);
int __cdecl sub_8139472(int a1);
int __cdecl sub_813947E(int a1, int a2);
int __cdecl sub_8139486(_DWORD *a1, int a2);
int __cdecl sub_81394A2(int a1);
int __cdecl sub_81394C4(int a1, int a2);
int __cdecl sub_81394CC(int a1);
// _DWORD *__userpurge sub_81394D8@<eax>(_DWORD *a1, int a2, int a3, int a4, std::string *a5);
int __cdecl sub_8139676(int a1);
// _DWORD *__userpurge sub_8139682@<eax>(_DWORD *a1, int a2);
int __cdecl sub_81396B0(int a1, int *a2, unsigned __int8 *a3);
_DWORD *__cdecl sub_81396D6(_DWORD *a1, _DWORD *a2);
void __cdecl sub_813988E(int a1);
void *__cdecl sub_81398AC(int a1, std::string *a2);
std::string *__cdecl sub_8139920(int a1, std::string *a2);
int __cdecl sub_813999C(int a1, int a2);
void sub_81399A4();
int __cdecl sub_81399AA(int a1, _DWORD *a2);
int __cdecl sub_8139A36(int a1, _DWORD *a2);
int __cdecl sub_8139AC2(std::string *, std::string *); // idb
int sub_8139B20();
void term_proc(void); // idb

//-------------------------------------------------------------------------
// Data declarations

_UNKNOWN main;
const char byte_813A549 = '\0'; // idb
const char aExeErrCouldntL_1[20] = "EXE_ERR_COULDNT_LOAD"; // idb
const char aExeErrWrongMap[29] = "EXE_ERR_WRONG_MAP_VERSION_NUM"; // idb
const char byte_813AE20 = '\x15'; // idb
const char aExeErrCouldntL[20] = "EXE_ERR_COULDNT_LOAD"; // idb
const char byte_813AEC0 = '\x15'; // idb
const char byte_813AEE5 = '\x15'; // idb
const char byte_813AF20 = '\x15'; // idb
const char byte_813AF45 = '\x15'; // idb
const char byte_813AF6C = '\x15'; // idb
const char byte_813AFA0 = '\x15'; // idb
const char byte_813AFE0 = '\x15'; // idb
const char byte_813B020 = '\x15'; // idb
const char byte_813B080 = '\x15'; // idb
const char byte_813B0E0 = '\x15'; // idb
const char byte_813B120 = '\x15'; // idb
const char byte_813B141 = '\x15'; // idb
const char byte_813B180 = '\x15'; // idb
const char byte_813B1C0 = '\x15'; // idb
const char byte_813B200 = '\x15'; // idb
const char byte_813B260 = '\x15'; // idb
const char byte_813B2A0 = '\x15'; // idb
const char byte_813B2E0 = '\x15'; // idb
const char byte_813B320 = '\x15'; // idb
const char byte_813B360 = '\x15'; // idb
const char byte_813B381 = '\x15'; // idb
const char byte_813B3C0 = '\x15'; // idb
const char byte_813B400 = '\x15'; // idb
const char byte_813B440 = '\x15'; // idb
const char byte_813B468 = '\x15'; // idb
const char byte_813B4A0 = '\x15'; // idb
const char byte_813B4E0 = '\x15'; // idb
const char byte_813B520 = '\x15'; // idb
const char byte_813B560 = '\x15'; // idb
const char byte_813B5C0 = '\x15'; // idb
const char byte_813B620 = '\x15'; // idb
const char byte_813B680 = '\x15'; // idb
const char byte_813B6E0 = '\x15'; // idb
const char byte_813B740 = '\x15'; // idb
const char aExeErrCouldntL_0[20] = "EXE_ERR_COULDNT_LOAD"; // idb
const char byte_813B860 = '\x15'; // idb
const char byte_813B8A0 = '\x15'; // idb
const char byte_813B8E0 = '\x15'; // idb
const char byte_813B920 = '\x15'; // idb
const char byte_813B960 = '\x15'; // idb
const char byte_813B980 = '\x15'; // idb
const char byte_813B9C0 = '\x15'; // idb
const char byte_813BA00 = '\x15'; // idb
const char byte_813BB60 = '\x15'; // idb
_UNKNOWN unk_813BC6B; // weak
_UNKNOWN unk_813BDA4; // weak
const char byte_813BF00 = '\x15'; // idb
const char byte_813BF60 = '\x15'; // idb
const char byte_813BF74 = '\x15'; // idb
const char byte_813C2EC = '\x15'; // idb
const char aSurialc[] = "S\x00U\x00R\x00I\x00A\x00L\x00C"; // idb
const char byte_813C8A0 = '\0'; // idb
_UNKNOWN unk_813CD62; // weak
char *off_813D120 = "pos.trTime"; // weak
char *off_813D460 = "absmin[1]"; // weak
char *off_813D8E0 = "team"; // weak
char *off_813DE80 = "commandTime"; // weak
_UNKNOWN unk_813E42E; // weak
const char byte_813E560 = '\x15'; // idb
const char byte_813E9E0 = '\x15'; // idb
const char byte_813EA4D = '\x15'; // idb
const char byte_813ED81 = '\x15'; // idb
_UNKNOWN unk_813F86C; // weak
const char byte_813F960 = '\x15'; // idb
const char byte_813FA00 = '\x15'; // idb
const char byte_813FA40 = '\x15'; // idb
const char byte_813FAC0 = '\x15'; // idb
const char byte_81400D1 = '\x15'; // idb
const char byte_81400F1 = '\x15'; // idb
const char byte_814010C = '\x15'; // idb
const char byte_8140128 = '\x15'; // idb
const char byte_8140180 = '\x15'; // idb
const char byte_8140CE0 = '\x15'; // idb
__int16 word_81410A0[256] =
{
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  94,
  92,
  1,
  4,
  33,
  92,
  92,
  89,
  32,
  19,
  11,
  12,
  30,
  28,
  37,
  29,
  38,
  31,
  35,
  40,
  42,
  22,
  41,
  23,
  39,
  90,
  13,
  14,
  18,
  90,
  90,
  90,
  90,
  90,
  90,
  90,
  90,
  90,
  90,
  90,
  90,
  90,
  90,
  90,
  90,
  9,
  17,
  10,
  34,
  3,
  3,
  4,
  21,
  0,
  7,
  0,
  88,
  0,
  0,
  0,
  66,
  0,
  16,
  59,
  64,
  55,
  62,
  56,
  63,
  36,
  0,
  87,
  6,
  5,
  65,
  0,
  35,
  0,
  71,
  26,
  24,
  20,
  25,
  27,
  90,
  0,
  58,
  90,
  90,
  90,
  90,
  90,
  90,
  90,
  90,
  90,
  90,
  51,
  90,
  90,
  90,
  90,
  90,
  90,
  90,
  90,
  90,
  90,
  90,
  57,
  15,
  2,
  0,
  0,
  0,
  0,
  8,
  0,
  0,
  5,
  0,
  36,
  60,
  61,
  91,
  90,
  90,
  90,
  90,
  90,
  90,
  90,
  90,
  54,
  90,
  90,
  90,
  90,
  90,
  90,
  90,
  90,
  90,
  90,
  90,
  90,
  0,
  0,
  0,
  0,
  91,
  50,
  90,
  77,
  90,
  90,
  52,
  90,
  90,
  49,
  90,
  90,
  90,
  90,
  47,
  90,
  90,
  83,
  90,
  44,
  90,
  0,
  0,
  0,
  67,
  79,
  90,
  90,
  81,
  82,
  48,
  90,
  90,
  90,
  90,
  90,
  90,
  90,
  53,
  0,
  0,
  0,
  90,
  90,
  90,
  75,
  90,
  90,
  43,
  76,
  45,
  90,
  90,
  0,
  0,
  0,
  90,
  90,
  78,
  90,
  90,
  90,
  90,
  0,
  70,
  0,
  90,
  80,
  90,
  86,
  90,
  72,
  69,
  0,
  90,
  90,
  46,
  90,
  90,
  0,
  84,
  85,
  90,
  90,
  0,
  90,
  90,
  0,
  90,
  90,
  0,
  90,
  73,
  0,
  90,
  68,
  90,
  74,
  0
}; // weak
char byte_81412A0[] = { '\0' }; // weak
char byte_81416A0[] = { '\0' }; // weak
__int16 word_81417A0[272] =
{
  0,
  427,
  426,
  0,
  0,
  56,
  57,
  428,
  431,
  431,
  425,
  404,
  56,
  45,
  431,
  403,
  58,
  431,
  431,
  402,
  51,
  431,
  50,
  48,
  64,
  71,
  404,
  431,
  53,
  400,
  56,
  431,
  393,
  431,
  431,
  398,
  54,
  43,
  60,
  55,
  65,
  71,
  72,
  73,
  66,
  78,
  80,
  83,
  84,
  85,
  86,
  89,
  431,
  93,
  431,
  431,
  431,
  402,
  416,
  431,
  113,
  431,
  0,
  431,
  373,
  372,
  367,
  431,
  117,
  431,
  431,
  431,
  431,
  431,
  431,
  431,
  107,
  374,
  431,
  431,
  0,
  431,
  395,
  113,
  122,
  431,
  390,
  431,
  431,
  431,
  389,
  382,
  0,
  431,
  98,
  106,
  115,
  116,
  118,
  119,
  122,
  120,
  123,
  125,
  381,
  124,
  128,
  126,
  130,
  131,
  136,
  133,
  137,
  146,
  138,
  144,
  431,
  431,
  431,
  368,
  373,
  366,
  164,
  431,
  0,
  351,
  0,
  386,
  385,
  431,
  431,
  374,
  154,
  157,
  155,
  158,
  162,
  160,
  165,
  167,
  373,
  170,
  172,
  171,
  175,
  173,
  176,
  177,
  181,
  186,
  188,
  190,
  191,
  357,
  357,
  354,
  361,
  368,
  367,
  193,
  366,
  192,
  197,
  365,
  199,
  200,
  364,
  202,
  201,
  209,
  203,
  363,
  207,
  214,
  362,
  217,
  220,
  221,
  340,
  338,
  349,
  431,
  224,
  223,
  230,
  358,
  357,
  356,
  225,
  227,
  231,
  234,
  233,
  236,
  237,
  355,
  335,
  346,
  349,
  238,
  243,
  246,
  351,
  251,
  252,
  350,
  349,
  348,
  253,
  256,
  339,
  338,
  341,
  254,
  263,
  344,
  262,
  257,
  273,
  260,
  335,
  431,
  326,
  261,
  341,
  275,
  340,
  276,
  279,
  431,
  327,
  278,
  280,
  338,
  282,
  285,
  318,
  329,
  323,
  286,
  284,
  291,
  291,
  292,
  292,
  295,
  293,
  302,
  300,
  307,
  250,
  297,
  431,
  302,
  228,
  431,
  341,
  345,
  349,
  351,
  355,
  359,
  198,
  361,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0
}; // weak
__int16 word_81419C0[272] =
{
  0,
  256,
  256,
  255,
  3,
  257,
  257,
  255,
  255,
  255,
  255,
  255,
  258,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  259,
  255,
  255,
  255,
  259,
  259,
  259,
  259,
  259,
  259,
  259,
  259,
  259,
  259,
  259,
  259,
  259,
  259,
  259,
  259,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  258,
  255,
  258,
  255,
  255,
  255,
  255,
  255,
  260,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  261,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  259,
  262,
  255,
  259,
  259,
  259,
  259,
  259,
  259,
  259,
  259,
  259,
  259,
  259,
  259,
  259,
  259,
  259,
  259,
  259,
  259,
  259,
  259,
  259,
  259,
  255,
  255,
  255,
  255,
  255,
  255,
  260,
  255,
  260,
  255,
  261,
  255,
  255,
  255,
  255,
  263,
  259,
  259,
  259,
  259,
  259,
  259,
  259,
  259,
  259,
  259,
  259,
  259,
  259,
  259,
  259,
  259,
  259,
  259,
  259,
  259,
  259,
  255,
  255,
  255,
  255,
  263,
  259,
  259,
  259,
  259,
  259,
  259,
  259,
  259,
  259,
  259,
  259,
  259,
  259,
  259,
  259,
  259,
  259,
  259,
  259,
  259,
  255,
  255,
  255,
  255,
  259,
  259,
  259,
  259,
  259,
  259,
  259,
  259,
  259,
  259,
  259,
  259,
  259,
  259,
  255,
  255,
  255,
  259,
  259,
  259,
  259,
  259,
  259,
  259,
  259,
  259,
  259,
  259,
  255,
  255,
  255,
  259,
  259,
  259,
  259,
  259,
  259,
  259,
  255,
  255,
  255,
  259,
  259,
  259,
  259,
  259,
  259,
  255,
  255,
  259,
  259,
  259,
  259,
  259,
  255,
  259,
  259,
  259,
  259,
  255,
  259,
  259,
  255,
  259,
  259,
  255,
  259,
  259,
  255,
  259,
  255,
  259,
  259,
  0,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0
}; // weak
__int16 word_8141BE0[496] =
{
  0,
  8,
  10,
  9,
  11,
  12,
  13,
  14,
  15,
  16,
  17,
  18,
  19,
  20,
  21,
  22,
  23,
  24,
  25,
  26,
  27,
  28,
  29,
  30,
  31,
  32,
  32,
  33,
  8,
  34,
  35,
  32,
  36,
  37,
  38,
  39,
  40,
  41,
  42,
  32,
  43,
  32,
  44,
  32,
  45,
  32,
  46,
  47,
  48,
  49,
  50,
  32,
  51,
  32,
  32,
  52,
  53,
  54,
  55,
  9,
  9,
  61,
  63,
  68,
  72,
  74,
  76,
  69,
  57,
  57,
  78,
  92,
  75,
  73,
  86,
  87,
  79,
  64,
  89,
  90,
  70,
  80,
  92,
  92,
  62,
  65,
  81,
  82,
  92,
  83,
  95,
  98,
  96,
  92,
  92,
  66,
  77,
  84,
  94,
  92,
  92,
  92,
  105,
  101,
  103,
  97,
  92,
  99,
  92,
  100,
  104,
  92,
  92,
  92,
  92,
  116,
  102,
  92,
  61,
  108,
  109,
  114,
  123,
  106,
  111,
  76,
  92,
  107,
  115,
  82,
  113,
  83,
  112,
  84,
  92,
  127,
  110,
  127,
  132,
  84,
  128,
  62,
  133,
  92,
  92,
  124,
  92,
  92,
  92,
  117,
  92,
  92,
  92,
  92,
  92,
  136,
  92,
  138,
  92,
  92,
  135,
  92,
  139,
  134,
  92,
  92,
  92,
  137,
  141,
  123,
  140,
  144,
  92,
  146,
  92,
  142,
  147,
  143,
  151,
  145,
  148,
  150,
  92,
  92,
  152,
  92,
  92,
  149,
  92,
  159,
  92,
  160,
  124,
  92,
  162,
  92,
  163,
  158,
  92,
  92,
  92,
  92,
  131,
  92,
  92,
  92,
  166,
  161,
  167,
  92,
  164,
  168,
  169,
  171,
  92,
  165,
  92,
  173,
  92,
  92,
  92,
  92,
  174,
  170,
  175,
  92,
  172,
  92,
  92,
  92,
  92,
  92,
  183,
  177,
  182,
  92,
  186,
  92,
  188,
  176,
  189,
  191,
  92,
  185,
  187,
  92,
  192,
  184,
  92,
  92,
  190,
  92,
  92,
  92,
  193,
  92,
  92,
  195,
  92,
  92,
  203,
  92,
  92,
  204,
  92,
  92,
  92,
  200,
  207,
  194,
  199,
  92,
  201,
  206,
  92,
  205,
  208,
  209,
  202,
  92,
  92,
  92,
  92,
  213,
  92,
  92,
  252,
  216,
  92,
  92,
  92,
  92,
  226,
  214,
  223,
  215,
  217,
  218,
  219,
  224,
  225,
  92,
  228,
  92,
  92,
  231,
  92,
  92,
  92,
  227,
  92,
  233,
  92,
  92,
  92,
  232,
  234,
  240,
  242,
  92,
  92,
  92,
  235,
  92,
  238,
  92,
  246,
  237,
  92,
  239,
  92,
  248,
  249,
  243,
  245,
  92,
  251,
  254,
  250,
  247,
  244,
  253,
  8,
  8,
  8,
  8,
  56,
  56,
  56,
  56,
  60,
  92,
  60,
  60,
  91,
  91,
  122,
  92,
  122,
  122,
  126,
  241,
  126,
  126,
  157,
  157,
  92,
  236,
  92,
  92,
  230,
  229,
  92,
  222,
  221,
  220,
  92,
  92,
  92,
  92,
  212,
  211,
  210,
  92,
  92,
  92,
  92,
  198,
  197,
  196,
  92,
  92,
  92,
  92,
  92,
  92,
  92,
  181,
  180,
  179,
  178,
  92,
  92,
  128,
  128,
  156,
  155,
  154,
  153,
  92,
  92,
  130,
  129,
  76,
  125,
  121,
  120,
  119,
  58,
  118,
  93,
  92,
  88,
  85,
  71,
  67,
  59,
  58,
  255,
  9,
  9,
  7,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  0,
  0,
  0,
  0,
  0,
  0
}; // weak
__int16 word_8141FC0[496] =
{
  0,
  3,
  3,
  3,
  3,
  3,
  3,
  3,
  3,
  3,
  3,
  3,
  3,
  3,
  3,
  3,
  3,
  3,
  3,
  3,
  3,
  3,
  3,
  3,
  3,
  3,
  3,
  3,
  3,
  3,
  3,
  3,
  3,
  3,
  3,
  3,
  3,
  3,
  3,
  3,
  3,
  3,
  3,
  3,
  3,
  3,
  3,
  3,
  3,
  3,
  3,
  3,
  3,
  3,
  3,
  3,
  3,
  3,
  3,
  5,
  6,
  12,
  13,
  16,
  20,
  22,
  23,
  16,
  5,
  6,
  24,
  37,
  22,
  20,
  28,
  28,
  24,
  13,
  30,
  30,
  16,
  24,
  36,
  39,
  12,
  13,
  24,
  25,
  38,
  25,
  37,
  39,
  38,
  40,
  44,
  13,
  23,
  25,
  36,
  41,
  42,
  43,
  44,
  41,
  42,
  38,
  45,
  40,
  46,
  40,
  43,
  47,
  48,
  49,
  50,
  53,
  41,
  51,
  60,
  47,
  48,
  51,
  68,
  45,
  49,
  76,
  94,
  46,
  51,
  83,
  50,
  83,
  49,
  76,
  95,
  84,
  48,
  84,
  94,
  83,
  84,
  60,
  95,
  96,
  97,
  68,
  98,
  99,
  101,
  53,
  100,
  102,
  105,
  103,
  107,
  98,
  106,
  100,
  108,
  109,
  97,
  111,
  101,
  96,
  110,
  112,
  114,
  99,
  103,
  122,
  102,
  107,
  115,
  109,
  113,
  105,
  110,
  106,
  114,
  108,
  111,
  113,
  132,
  134,
  115,
  133,
  135,
  112,
  137,
  133,
  136,
  134,
  122,
  138,
  136,
  139,
  137,
  132,
  141,
  143,
  142,
  145,
  262,
  144,
  146,
  147,
  141,
  135,
  142,
  148,
  138,
  143,
  144,
  146,
  149,
  139,
  150,
  148,
  151,
  152,
  161,
  159,
  149,
  145,
  150,
  162,
  147,
  164,
  165,
  168,
  167,
  170,
  161,
  152,
  159,
  172,
  165,
  169,
  168,
  151,
  169,
  172,
  173,
  164,
  167,
  175,
  173,
  162,
  176,
  177,
  170,
  183,
  182,
  188,
  175,
  189,
  254,
  177,
  184,
  190,
  189,
  192,
  191,
  189,
  193,
  194,
  199,
  183,
  192,
  176,
  182,
  200,
  184,
  191,
  201,
  190,
  193,
  194,
  188,
  203,
  204,
  208,
  213,
  199,
  209,
  217,
  250,
  203,
  219,
  223,
  216,
  214,
  217,
  200,
  213,
  201,
  204,
  208,
  209,
  214,
  216,
  218,
  219,
  225,
  227,
  223,
  231,
  228,
  232,
  218,
  234,
  227,
  240,
  235,
  239,
  225,
  228,
  235,
  239,
  242,
  243,
  246,
  228,
  245,
  232,
  251,
  243,
  231,
  248,
  234,
  253,
  245,
  246,
  240,
  242,
  249,
  248,
  253,
  247,
  244,
  241,
  251,
  256,
  256,
  256,
  256,
  257,
  257,
  257,
  257,
  258,
  238,
  258,
  258,
  259,
  259,
  260,
  237,
  260,
  260,
  261,
  236,
  261,
  261,
  263,
  263,
  233,
  230,
  226,
  224,
  222,
  220,
  215,
  212,
  211,
  210,
  207,
  206,
  205,
  202,
  198,
  197,
  196,
  195,
  187,
  186,
  185,
  180,
  179,
  178,
  174,
  171,
  166,
  163,
  160,
  158,
  157,
  156,
  155,
  154,
  153,
  140,
  131,
  128,
  127,
  125,
  121,
  120,
  119,
  104,
  91,
  90,
  86,
  82,
  77,
  66,
  65,
  64,
  58,
  57,
  35,
  32,
  29,
  26,
  19,
  15,
  11,
  10,
  7,
  2,
  1,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  0,
  0,
  0,
  0,
  0,
  0
}; // weak
const char byte_8142A4E = '\0'; // idb
const char aC_2[4] = "%c \""; // idb
const char byte_814309B = '\0'; // idb
const char aError_1[6] = "error\n"; // idb
const char aError_2[6] = "error\n"; // idb
const char aErrorExeServer_0[33] = "error\nEXE_SERVER_IS_DIFFERENT_VER"; // idb
const char aC_3[4] = "%c \""; // idb
const char aExeCantautodlg[21] = "EXE_CANTAUTODLGAMEIWD"; // idb
const char aExeAutodlServe[30] = "EXE_AUTODL_SERVERDISABLED_PURE"; // idb
const char aExeAutodlServe_0[25] = "EXE_AUTODL_SERVERDISABLED"; // idb
const char aExeAutodlFilen[26] = "EXE_AUTODL_FILENOTONSERVER"; // idb
const char byte_8143DA0 = '\x15'; // idb
const char byte_8143DE0 = '\x15'; // idb
const char byte_8143E20 = '\x15'; // idb
const char byte_8143E80 = '\x15'; // idb
const char byte_8143EDA = '\x15'; // idb
const char byte_8143FA0 = '\x15'; // idb
const char byte_8143FC3 = '\0'; // idb
const char byte_8143FE0 = '\x15'; // idb
const char byte_8144020 = '\x15'; // idb
const char byte_8144060 = '\x15'; // idb
const char byte_81440A0 = '\x15'; // idb
const char byte_81440E0 = '\x15'; // idb
const char byte_8144120 = '\x15'; // idb
const char byte_814414D = '\x15'; // idb
const char byte_8144180 = '\x15'; // idb
const char aExeServerresta_6[] = "EXE_SERVERRESTARTMISC"; // idb
const char aExeServerresta_5[] = "EXE_SERVERRESTARTMISC"; // idb
const char aExeServerresta_4[] = "EXE_SERVERRESTARTMISC"; // idb
const char aExeServerresta_3[] = "EXE_SERVERRESTARTMISC"; // idb
const char aExeServerresta_2[] = "EXE_SERVERRESTARTMISC"; // idb
const char aExeServerresta_1[] = "EXE_SERVERRESTARTMISC"; // idb
const char aExeServerresta_0[] = "EXE_SERVERRESTARTMISC"; // idb
const char byte_8145200 = '\x15'; // idb
const char byte_8145240 = '\x15'; // idb
const char byte_8145280 = '\x15'; // idb
const char byte_81452C0 = '\x15'; // idb
const char byte_8145300 = '\x15'; // idb
const char byte_8145340 = '\x15'; // idb
const char byte_8145380 = '\x15'; // idb
const char byte_81454E0 = '\x15'; // idb
const char byte_8145520 = '\x15'; // idb
const char byte_8145690 = '\x15'; // idb
const char byte_81456C0 = '\x15'; // idb
const char byte_8145733 = '\x15'; // idb
const char byte_8145760 = '\x15'; // idb
const char byte_81457E0 = '\x15'; // idb
const char byte_8145820 = '\x15'; // idb
const char byte_8145895 = '\0'; // idb
const char byte_8145896 = '\x15'; // idb
const char aExeUnpureclien_0[24] = "EXE_UNPURECLIENTDETECTED"; // idb
const char byte_814595B = '\x15'; // idb
const char byte_8145973 = '\x15'; // idb
const char byte_8145E1D = '\x15'; // idb
_UNKNOWN unk_8145E60; // weak
float flt_8145E68[3] = { 0.0, 0.0, 0.0 }; // weak
_UNKNOWN unk_8145E74; // weak
_UNKNOWN unk_8145FA0; // weak
const char byte_8146220 = '\x15'; // idb
const char byte_81462E0 = '\x15'; // idb
const char byte_8146340 = '\x15'; // idb
const char byte_81463A0 = '\x15'; // idb
const char byte_8146400 = '\x15'; // idb
const char byte_8146480 = '\x15'; // idb
const char byte_81464E0 = '\x15'; // idb
const char byte_8146580 = '\x15'; // idb
const char byte_81465E0 = '\x15'; // idb
const char byte_81467C0 = '\x15'; // idb
const char byte_8147777 = '\0'; // idb
const char byte_8147800 = '\x15'; // idb
const char byte_81479C0 = '\x15'; // idb
const char byte_8147A00 = '\x15'; // idb
const char byte_8147AA0 = '\x15'; // idb
const char byte_8147AE0 = '\x15'; // idb
const char byte_8147CC0 = '\x15'; // idb
_UNKNOWN unk_8147CE0; // weak
char a1_3[2] = "1"; // weak
char a0_6[2] = "0"; // weak
__int16 a0123456789[10] = { 48, 49, 50, 51, 52, 53, 54, 55, 56, 57 }; // weak
_UNKNOWN unk_81483E1; // weak
_UNKNOWN unk_814846A; // weak
const char byte_81484A0 = '\x15'; // idb
const char byte_81484E0 = '\x15'; // idb
const char byte_8148508 = '\x15'; // idb
const char byte_8148520 = '\x15'; // idb
_DWORD dword_8148660[24] =
{
  1065353216,
  1065353216,
  1065353216,
  1065353216,
  1061158912,
  1061158912,
  1061158912,
  1065353216,
  1056964608,
  1056964608,
  1056964608,
  1065353216,
  1048576000,
  1048576000,
  1048576000,
  1065353216,
  1065353216,
  1060320051,
  0,
  1065353216,
  1061158912,
  1057384038,
  0,
  1065353216
}; // weak
const char byte_8148700 = '\x15'; // idb
const char byte_8148720 = '\x15'; // idb
_UNKNOWN unk_814874D; // weak
const char byte_8148760 = '\x15'; // idb
const char byte_81487A0 = '\x15'; // idb
const char byte_81487E0 = '\x15'; // idb
const char byte_8148820 = '\x15'; // idb
const char byte_8148860 = '\x15'; // idb
const char byte_81488A0 = '\x15'; // idb
const char byte_81488E0 = '\x15'; // idb
const char byte_8148920 = '\x15'; // idb
const char byte_8148980 = '\x15'; // idb
const char byte_81489C4 = '\x15'; // idb
const char byte_8148D20 = '\x15'; // idb
const char byte_8148E87 = '\x15'; // idb
const char byte_8148EA0 = '\x15'; // idb
_UNKNOWN unk_8148F07; // weak
const char byte_81490E0 = '\x15'; // idb
const char byte_8149140 = '\x15'; // idb
const char byte_81491A0 = '\x15'; // idb
const char byte_81491E0 = '\x15'; // idb
const char byte_8149220 = '\x15'; // idb
const char byte_8149280 = '\x15'; // idb
_UNKNOWN unk_81493E0; // weak
__int16 word_81497A0[] = { 0 }; // weak
__int16 word_81497A2[] = { 0 }; // weak
__int16 word_81497A4[] = { 0 }; // weak
__int16 word_81497A6[] = { 0 }; // weak
int (__cdecl *funcs_80C6485[28])(int, int) =
{
  &sub_80C70A8,
  (int (__cdecl *)(int, int))0x40004,
  (int (__cdecl *)(int, int))0x40008,
  &loc_80C733F,
  (int (__cdecl *)(int, int))0x50004,
  (int (__cdecl *)(int, int))0x80010,
  &loc_80C733F,
  (int (__cdecl *)(int, int))0x60004,
  (int (__cdecl *)(int, int))0x200020,
  &loc_80C733F,
  (int (__cdecl *)(int, int))0x40004,
  (int (__cdecl *)(int, int))0x100010,
  &loc_80C78FE,
  (int (__cdecl *)(int, int))0x100008,
  (int (__cdecl *)(int, int))0x200020,
  &loc_80C78FE,
  (int (__cdecl *)(int, int))0x100008,
  (int (__cdecl *)(int, int))0x800080,
  &loc_80C78FE,
  (int (__cdecl *)(int, int))0x200008,
  (int (__cdecl *)(int, int))0x1000080,
  &loc_80C78FE,
  (int (__cdecl *)(int, int))0x800020,
  (int (__cdecl *)(int, int))0x4000102,
  &loc_80C78FE,
  (int (__cdecl *)(int, int))0x1020020,
  (int (__cdecl *)(int, int))0x10000102,
  &loc_80C78FE
}; // weak
int dword_8149820[19] = { 16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15 }; // weak
_UNKNOWN unk_8149A80; // weak
_UNKNOWN unk_8149B00; // weak
_UNKNOWN unk_8149B80; // weak
_UNKNOWN unk_8149C00; // weak
int dword_8149DE0[] = { 0 }; // weak
int dword_8149E60[] = { 0 }; // weak
_UNKNOWN unk_8149F40; // weak
_UNKNOWN unk_814A3C0; // weak
char byte_814A540[] = { '\0' }; // weak
int dword_814A740[32] =
{
  0,
  1,
  2,
  3,
  4,
  5,
  6,
  7,
  8,
  10,
  12,
  14,
  16,
  20,
  24,
  28,
  32,
  40,
  48,
  56,
  64,
  80,
  96,
  112,
  128,
  160,
  192,
  224,
  0,
  0,
  0,
  0
}; // weak
int dword_814A7C0[30] =
{
  0,
  1,
  2,
  3,
  4,
  6,
  8,
  12,
  16,
  24,
  32,
  48,
  64,
  96,
  128,
  192,
  256,
  384,
  512,
  768,
  1024,
  1536,
  2048,
  3072,
  4096,
  6144,
  8192,
  12288,
  16384,
  24576
}; // weak
const char byte_814AE9F = '\0'; // idb
_UNKNOWN unk_814B1CE; // weak
const char byte_814B63B = '\x15'; // idb
const char byte_814B64E = '\x15'; // idb
const char byte_814B6C0 = '\x15'; // idb
const char byte_814B780 = '\x15'; // idb
const char byte_814BB40 = '\x15'; // idb
const char byte_814BFE0 = '\x15'; // idb
const char byte_814C020 = '\x15'; // idb
const char byte_814C140 = '\x15'; // idb
int dword_814D70C[7] = { 140, 141, 142, 143, 185, 186, -1 }; // weak
const char byte_814DB20 = '\x15'; // idb
const char byte_814DB64 = '\x15'; // idb
const char byte_814DBA0 = '\x15'; // idb
const char byte_814DC20 = '\x15'; // idb
const char byte_814E260 = '\x15'; // idb
const char byte_814E2C0 = '\x15'; // idb
const char byte_814E320 = '\x15'; // idb
const char byte_814E3A0 = '\x15'; // idb
const char byte_814E400 = '\x15'; // idb
const char byte_814E440 = '\x15'; // idb
const char byte_814E4A0 = '\x15'; // idb
const char byte_814E500 = '\x15'; // idb
const char byte_814E800 = '\x15'; // idb
const char byte_814FFCE = '\x15'; // idb
const char byte_814FFE7 = '\x15'; // idb
const char byte_8150020 = '\x15'; // idb
const char byte_8150060 = '\x15'; // idb
const char byte_81500A0 = '\x15'; // idb
const char byte_81500E0 = '\x15'; // idb
const char byte_8150120 = '\x15'; // idb
const char byte_8150160 = '\x15'; // idb
const char byte_81501A0 = '\x15'; // idb
const char byte_81501E0 = '\x15'; // idb
const char byte_8150220 = '\x15'; // idb
const char byte_8150246 = '\x15'; // idb
_UNKNOWN unk_81503AC; // weak
const char byte_8150540 = '\x15'; // idb
const char byte_8150580 = '\x15'; // idb
const char byte_81505C0 = '\x15'; // idb
const char byte_8150600 = '\x15'; // idb
const char byte_8150640 = '\x15'; // idb
const char byte_8150662 = '\x15'; // idb
const char byte_8150A80[32] =
{
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0'
}; // idb
char *off_8150B80 = "name"; // weak
const char byte_8150CC0 = '\x15'; // idb
char *off_81518E0 = "giveweapon"; // weak
int (__cdecl *off_81518E4[183])(int) =
{
  &sub_80F7420,
  NULL,
  &aTakeweapon,
  &sub_80F761E,
  NULL,
  &aTakeallweapons,
  &sub_80F76F8,
  NULL,
  &aGetcurrentweap,
  &sub_80F77FE,
  NULL,
  &aGetcurrentoffh,
  &sub_80F78C4,
  NULL,
  &aHasweapon,
  &sub_80F798A,
  NULL,
  &aSwitchtoweapon,
  &sub_80F7A4A,
  NULL,
  &aSwitchtooffhan,
  &sub_80F7B40,
  NULL,
  &aGivestartammo,
  &sub_80F7C36,
  NULL,
  &aGivemaxammo,
  &sub_80F7D32,
  NULL,
  &aGetfractionsta,
  &sub_80F7E38,
  NULL,
  &aGetfractionmax,
  &sub_80F7F72,
  NULL,
  &aSetorigin,
  &sub_80F80CC,
  NULL,
  &aSetplayerangle,
  &sub_80F81F8,
  NULL,
  &aGetplayerangle,
  &sub_80F8280,
  NULL,
  &aUsebuttonpress,
  &sub_80F82F8,
  NULL,
  &aAttackbuttonpr,
  &sub_80F839A,
  NULL,
  &aMeleebuttonpre,
  &sub_80F843C,
  NULL,
  &aPlayerads,
  &sub_80F84DE,
  NULL,
  &aIsonground,
  &sub_80F8558,
  NULL,
  &aPingplayer,
  &sub_80F85E6,
  NULL,
  &aSetviewmodel,
  &PlayerCmd_SetViewmodel,
  NULL,
  &aGetviewmodel,
  &sub_80F8738,
  NULL,
  &aSayall,
  &PlayerCmd_SayAll,
  NULL,
  &aSayteam,
  &PlayerCmd_SayTeam,
  NULL,
  &aShowscoreboard,
  &sub_80F87C0,
  NULL,
  &aSetspawnweapon,
  &sub_80F882E,
  NULL,
  &aDropitem,
  &sub_80F88EE,
  NULL,
  &aFinishplayerda,
  &sub_80F8A04,
  NULL,
  &aSuicide,
  &sub_80F9448,
  NULL,
  &aOpenmenu,
  &sub_80F9528,
  NULL,
  &aOpenmenunomous,
  &sub_80F9600,
  NULL,
  &aClosemenu,
  &sub_80F96D8,
  NULL,
  &aCloseingamemen,
  &sub_80F9766,
  NULL,
  &aFreezecontrols,
  &sub_80FAA98,
  NULL,
  &aDisableweapon,
  &sub_80FAB1A,
  NULL,
  &aEnableweapon,
  &sub_80FAB9A,
  NULL,
  &aSetreverb,
  &PlayerCmd_SetReverb,
  NULL,
  &aDeactivatereve,
  &PlayerCmd_DeactivateReverb,
  NULL,
  &aSetchannelvolu,
  &PlayerCmd_SetChannelVolumes,
  NULL,
  &aDeactivatechan,
  &PlayerCmd_DeactivateChannelVolumes,
  NULL,
  &aGetweaponslotw,
  &sub_80F97F4,
  NULL,
  &aSetweaponslotw,
  &sub_80F991C,
  NULL,
  &aGetweaponslota,
  &sub_80F9C02,
  NULL,
  &aSetweaponslota,
  &sub_80F9D6C,
  NULL,
  &aGetweaponslotc,
  &sub_80F9F20,
  NULL,
  &aSetweaponslotc,
  &sub_80FA064,
  NULL,
  &aSetweaponclipa,
  &sub_80FA1B2,
  NULL,
  &aIprintln,
  &sub_80FA2AC,
  NULL,
  &aIprintlnbold,
  &sub_80FA332,
  NULL,
  &aSpawn,
  &sub_80FA3B8,
  NULL,
  &aSetentertime,
  &sub_80FA45A,
  NULL,
  &aCloneplayer,
  &sub_80FA50A,
  NULL,
  &aSetclientcvar,
  &PlayerCmd_SetClientDvar,
  NULL,
  &aIslookingat,
  &ScrCmd_IsLookingAt,
  NULL,
  &aPlaylocalsound,
  &ScrCmd_PlayLocalSound,
  NULL,
  &aIstalking,
  &sub_80FA9EE,
  NULL,
  &aAllowspectatet,
  &PlayerCmd_AllowSpectateTeam,
  NULL,
  &aGetguid,
  &PlayerCmd_GetGuid,
  NULL,
  NULL,
  NULL,
  NULL,
  NULL,
  NULL,
  NULL,
  NULL
}; // weak
const char aCGameBadclient[22] = "%c \"GAME_BADCLIENTSLOT"; // idb
const char aCGameClientnot_0[24] = "%c \"GAME_CLIENTNOTACTIVE"; // idb
const char aCGameUsernoton[24] = "%c \"GAME_USERNOTONSERVER"; // idb
const char byte_8151D60 = '\x15'; // idb
const char aC_4[4] = "%c \""; // idb
_UNKNOWN unk_8151D8E; // weak
_UNKNOWN unk_8151D91; // weak
_UNKNOWN unk_8151D94; // weak
const char byte_8151D95 = '\x15'; // idb
const char byte_8151DA9 = '\x15'; // idb
const char byte_8151DBA = '\x15'; // idb
const char aS_33[3] = "%s("; // idb
const char aC_5[4] = "%c \""; // idb
const char aCGameVotecomma[24] = "%c \"GAME_VOTECOMMANDSARE"; // idb
const char aC_6[4] = "%c \""; // idb
const char aGameVoteGamety[18] = "GAME_VOTE_GAMETYPE"; // idb
const char aGameVoteMap[13] = "GAME_VOTE_MAP"; // idb
const char aGameVoteGamety_0[18] = "GAME_VOTE_GAMETYPE"; // idb
const char aGameVoteKick[14] = "GAME_VOTE_KICK"; // idb
const char aCGameCalledavo[20] = "%c \"GAME_CALLEDAVOTE"; // idb
const char aCGameUsage[14] = "%c \"GAME_USAGE"; // idb
const char aCGameUnknowncl[29] = "%c \"GAME_UNKNOWNCLIENTCOMMAND"; // idb
const char byte_8152520 = '\x15'; // idb
const char byte_8152560 = '\x15'; // idb
const char byte_81525A0 = '\x15'; // idb
const char byte_81525E0 = '\x15'; // idb
const char byte_8152620 = '\x15'; // idb
__int16 *off_8152E40 = &aXyz; // weak
char *off_81530E0 = "settext"; // weak
int (__cdecl *off_81530E4[55])(int) =
{
  &sub_81019C2,
  NULL,
  &aSetplayernames,
  &HECmd_SetPlayerNameString,
  NULL,
  &aSetmapnamestri,
  &HECmd_SetMapNameString,
  NULL,
  &aSetgametypestr,
  &HECmd_SetGameTypeString,
  NULL,
  &aSetshader,
  &HECmd_SetShader,
  NULL,
  &aSettimer_0,
  &sub_8101F16,
  NULL,
  &aSettimerup_0,
  &sub_8101F3A,
  NULL,
  &aSettenthstimer_1,
  &sub_8101F5E,
  NULL,
  &aSettenthstimer_2,
  &sub_8101F82,
  NULL,
  &aSetclock_0,
  &sub_8101FA6,
  NULL,
  &aSetclockup_0,
  &sub_8101FCA,
  NULL,
  &aSetvalue,
  &sub_8101FEE,
  NULL,
  &aSetwaypoint,
  &sub_8102030,
  NULL,
  &aFadeovertime,
  &sub_8102068,
  NULL,
  &aScaleovertime,
  &HECmd_ScaleOverTime,
  NULL,
  &aMoveovertime,
  &HECmd_MoveOverTime,
  NULL,
  &aReset_0,
  &sub_810232A,
  NULL,
  &aDestroy,
  &sub_810234C,
  NULL,
  NULL,
  NULL
}; // weak
const char aCGamePickupCli[29] = "%c \"GAME_PICKUP_CLIPONLY_AMMO"; // idb
const char aCGamePickupAmm[20] = "%c \"GAME_PICKUP_AMMO"; // idb
const char aCGamePickupHea[22] = "%c \"GAME_PICKUP_HEALTH"; // idb
const char aCGamePickupCan[33] = "%c \"GAME_PICKUP_CANTCARRYMOREAMMO"; // idb
const char byte_8153420 = '\x15'; // idb
const char byte_81534F7 = '\0'; // idb
const char byte_8153A87 = '\x15'; // idb
const char byte_8153AE0 = '\x15'; // idb
const char byte_8153B80 = '\x15'; // idb
const char byte_8153BE0 = '\x15'; // idb
const char byte_8153C20 = '\x15'; // idb
_UNKNOWN unk_8153CDC; // weak
const char byte_8153D40 = '\x15'; // idb
_UNKNOWN unk_8153DE0; // weak
const char byte_8153E60 = '\x15'; // idb
const char byte_8153EC0 = '\x15'; // idb
const char byte_8153EE0 = '\x15'; // idb
const char byte_8153FCE = '\0'; // idb
_UNKNOWN unk_8157110; // weak
char *off_8157300 = "moveto"; // weak
int (__cdecl *off_8157304[39])(int) =
{
  &sub_81174FA,
  NULL,
  &aMovex,
  &sub_81177AC,
  NULL,
  &aMovey,
  &sub_81177C8,
  NULL,
  &aMovez,
  &sub_81177E4,
  NULL,
  &aMovegravity,
  &sub_81175DC,
  NULL,
  &aRotateto,
  &sub_8117800,
  NULL,
  &aRotatepitch,
  &sub_8117A3E,
  NULL,
  &aRotateyaw,
  &sub_8117A5A,
  NULL,
  &aRotateroll,
  &sub_8117A76,
  NULL,
  &aRotatevelocity,
  &sub_8117A92,
  NULL,
  &aSolid_0,
  &ScriptEntCmd_Solid,
  NULL,
  &aNotsolid,
  &ScriptEntCmd_NotSolid,
  NULL,
  NULL,
  NULL,
  NULL,
  NULL
}; // weak
const char byte_8157544 = '\0'; // idb
const char byte_81576A0 = '\x15'; // idb
const char byte_8157717 = '\x15'; // idb
char *off_8157780 = "classname"; // weak
const char aCGameServer[15] = "%c \"GAME_SERVER"; // idb
_UNKNOWN unk_8157A40; // weak
const char byte_8157B80 = '\x15'; // idb
const char byte_8157BDF = '\x15'; // idb
_UNKNOWN unk_8157C43; // weak
const char byte_8157C61 = '\x15'; // idb
float flt_8157C80[] = { 0.0 }; // weak
float flt_8157C84[9] = { 0.0, 1.0, 1.0, 1.0, -1.0, -1.0, 1.0, -1.0, -1.0 }; // weak
const char byte_8157D40 = '\x15'; // idb
float flt_8157DAC[3] = { 192.0, 192.0, 96.0 }; // weak
const char byte_8157DD0 = '\0'; // idb
char byte_81581A2[2] = { '\0', '\0' }; // weak
int (__cdecl *off_8158268[2])(int) = { &sub_81278E8, &sub_812791C }; // weak
int (__cdecl *off_81582A8[2])(int) = { &sub_81267EA, &sub_812681E }; // weak
int (__cdecl *off_81582E8[4])(int) = { &sub_8125D08, &sub_8125D3C, &sub_81228B8, &sub_8125DBE }; // weak
int (__cdecl *off_8158328[6])(int) =
{
  &sub_8125A54,
  &sub_8125A88,
  &sub_81228B8,
  &sub_8125B30,
  &sub_8125ABC,
  &sub_8125B14
}; // weak
int (__cdecl *off_8158368[6])(int) =
{
  &sub_812555A,
  &sub_812558E,
  &sub_81228B8,
  &sub_81256AE,
  &sub_81255E8,
  &sub_8125692
}; // weak
int (__cdecl *off_81583A8[2])(int) = { &sub_81252DA, &sub_812530E }; // weak
int (__cdecl *off_81583E8[2])(int) = { &sub_8124D38, &sub_8124D6C }; // weak
int (__cdecl *off_8158428[6])(int) =
{
  &sub_8124A36,
  &sub_8124A6A,
  &sub_81228B8,
  &sub_8124AF8,
  &sub_8124A9E,
  &sub_8124ADC
}; // weak
int (__cdecl *off_8158468[6])(int) =
{
  &sub_8122850,
  &sub_8122884,
  &sub_81228B8,
  &sub_8122A76,
  &sub_81229F0,
  &sub_8122A2E
}; // weak
int (__cdecl *off_81584A8[2])(int) = { &sub_81222A6, &sub_81222DE }; // weak
char *off_8158A40 = "depthHack"; // weak
char *off_8158C20 = "org2fromTrace"; // weak
_UNKNOWN unk_8158CD6; // weak
const char asc_8159580[] = "\"\x00]\x00\t"; // idb
const char asc_8159594[] = "}\x00{\x00["; // idb
_UNKNOWN unk_8159A3C; // weak
_UNKNOWN unk_8159A60; // weak
int *off_815A008 = &dword_8185790; // weak
char *s1 = "if"; // idb
int (__cdecl *off_815A024)(int) = &PC_Directive_if; // weak
char *off_815A0C0 = "evalint"; // idb
int (__cdecl *off_815A0C4)(int) = &PC_DollarDirective_evalint; // weak
char *off_815A160 = ">>="; // weak
int off_815A3DC = 135839236; // weak
char *off_815A3E0 = "EXE_SERVER_DISCONNECTED"; // idb
void *off_815A498 = &unk_81E6160; // weak
char byte_815A4A0[64] =
{
  '\x80',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0'
}; // weak
int kbitmask[40] =
{
  0,
  1,
  3,
  7,
  15,
  31,
  63,
  127,
  255,
  511,
  1023,
  2047,
  4095,
  8191,
  16383,
  32767,
  65535,
  131071,
  262143,
  524287,
  1048575,
  2097151,
  4194303,
  8388607,
  16777215,
  33554431,
  67108863,
  134217727,
  268435455,
  536870911,
  1073741823,
  2147483647,
  -1,
  0,
  0,
  0,
  0,
  0,
  0,
  0
}; // weak
char *off_815A580 = "origin[0]"; // weak
int dword_815A5E4[95] =
{
  8,
  -99,
  135515156,
  0,
  4,
  135515161,
  32,
  32,
  135515172,
  4,
  -99,
  135515174,
  28,
  6,
  135515186,
  16,
  0,
  135515196,
  60,
  8,
  135515210,
  52,
  10,
  135515216,
  56,
  10,
  135515223,
  40,
  32,
  135515237,
  36,
  32,
  135515252,
  44,
  16,
  135515261,
  112,
  0,
  135515267,
  104,
  32,
  135515272,
  12,
  -99,
  135515274,
  24,
  4,
  135515283,
  120,
  0,
  135515288,
  116,
  8,
  135515293,
  20,
  4,
  135515298,
  72,
  32,
  135515313,
  76,
  16,
  135515323,
  68,
  10,
  135515334,
  48,
  8,
  135515340,
  64,
  10,
  135515350,
  96,
  32,
  135515364,
  100,
  16,
  135515373,
  80,
  -99,
  135515379,
  84,
  -99,
  135515385,
  92,
  6,
  135515401,
  88,
  4,
  135515414,
  108,
  32,
  135515423,
  124,
  1
}; // weak
int dword_815A760[255] =
{
  250315,
  41193,
  6292,
  7106,
  3730,
  3750,
  6110,
  23283,
  33317,
  6950,
  7838,
  9714,
  9257,
  17259,
  3949,
  1778,
  8288,
  1604,
  1590,
  1663,
  1100,
  1213,
  1238,
  1134,
  1749,
  1059,
  1246,
  1149,
  1273,
  4486,
  2805,
  3472,
  21819,
  1159,
  1670,
  1066,
  1043,
  1012,
  1053,
  1070,
  1726,
  888,
  1180,
  850,
  960,
  780,
  1752,
  3296,
  10630,
  4514,
  5881,
  2685,
  4650,
  3837,
  2093,
  1867,
  2584,
  1949,
  1972,
  940,
  1134,
  1788,
  1670,
  1206,
  5719,
  6128,
  7222,
  6654,
  3710,
  3795,
  1492,
  1524,
  2215,
  1140,
  1355,
  971,
  2180,
  1248,
  1328,
  1195,
  1770,
  1078,
  1264,
  1266,
  1168,
  965,
  1155,
  1186,
  1347,
  1228,
  1529,
  1600,
  2617,
  2048,
  2546,
  3275,
  2410,
  3585,
  2504,
  2800,
  2675,
  6146,
  3663,
  2840,
  14253,
  3164,
  2221,
  1687,
  3208,
  2739,
  3512,
  4796,
  4091,
  3515,
  5288,
  4016,
  7937,
  6031,
  5360,
  3924,
  4892,
  3743,
  4566,
  4807,
  5852,
  6400,
  6225,
  8291,
  23243,
  7838,
  7073,
  8935,
  5437,
  4483,
  3641,
  5256,
  5312,
  5328,
  5370,
  3492,
  2458,
  1694,
  1821,
  2121,
  1916,
  1149,
  1516,
  1367,
  1236,
  1029,
  1258,
  1104,
  1245,
  1006,
  1149,
  1025,
  1241,
  952,
  1287,
  997,
  1713,
  1009,
  1187,
  879,
  1099,
  929,
  1078,
  951,
  1656,
  930,
  1153,
  1030,
  1262,
  1062,
  1214,
  1060,
  1621,
  930,
  1106,
  912,
  1034,
  892,
  1158,
  990,
  1175,
  850,
  1121,
  903,
  1087,
  920,
  1144,
  1056,
  3462,
  2240,
  4397,
  12136,
  7758,
  1345,
  1307,
  3278,
  1950,
  886,
  1023,
  1112,
  1077,
  1042,
  1061,
  1071,
  1484,
  1001,
  1096,
  915,
  1052,
  995,
  1070,
  876,
  1111,
  851,
  1059,
  805,
  1112,
  923,
  1103,
  817,
  1899,
  1872,
  976,
  841,
  1127,
  956,
  1159,
  950,
  7791,
  954,
  1289,
  933,
  1127,
  3207,
  1020,
  927,
  1355,
  768,
  1040,
  745,
  952,
  805,
  1073,
  740,
  1013,
  805,
  1008,
  796,
  996,
  1057,
  11457
}; // weak
char dword_815AB5C[] = { '\xC0', '4', '\0', '\0' }; // idb
char off_815AB60[] = { '\x80', '\xE3', '\x13', '\b' }; // idb
char *off_815AB68 = "loopsync"; // idb
__int16 word_815AB80[] = { 0 }; // weak
__int16 word_815AB82[] = { 0 }; // weak
char byte_815AB84[] = { 'e' }; // weak
char *off_815AB88 = "entity"; // weak
char off_815ABC0[] = { '$', '\xFB', '\x13', '\b' }; // idb
__int16 word_815AC60[144] =
{
  -1,
  0,
  0,
  0,
  0,
  3,
  3,
  3,
  3,
  3,
  3,
  3,
  3,
  3,
  3,
  3,
  3,
  3,
  3,
  3,
  3,
  3,
  3,
  3,
  3,
  3,
  7,
  7,
  8,
  8,
  9,
  9,
  10,
  10,
  11,
  11,
  12,
  12,
  13,
  13,
  6,
  6,
  6,
  6,
  6,
  6,
  6,
  6,
  6,
  6,
  6,
  6,
  6,
  6,
  6,
  6,
  6,
  6,
  6,
  6,
  6,
  15,
  15,
  15,
  15,
  15,
  4,
  4,
  4,
  4,
  4,
  4,
  4,
  4,
  4,
  4,
  4,
  4,
  4,
  4,
  4,
  4,
  4,
  4,
  4,
  4,
  4,
  4,
  4,
  4,
  4,
  4,
  19,
  19,
  20,
  20,
  5,
  5,
  5,
  5,
  5,
  5,
  5,
  5,
  22,
  22,
  22,
  22,
  21,
  21,
  14,
  14,
  14,
  23,
  23,
  23,
  16,
  16,
  17,
  17,
  18,
  18,
  24,
  24,
  24,
  24,
  2,
  2,
  25,
  1,
  1,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0
}; // weak
__int16 word_815AD80[144] =
{
  2,
  3,
  2,
  2,
  2,
  1,
  3,
  3,
  3,
  3,
  3,
  3,
  3,
  3,
  3,
  3,
  3,
  3,
  3,
  3,
  3,
  3,
  3,
  3,
  2,
  2,
  1,
  0,
  1,
  1,
  3,
  1,
  3,
  2,
  1,
  5,
  1,
  2,
  4,
  5,
  3,
  1,
  1,
  2,
  2,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  2,
  1,
  2,
  2,
  1,
  1,
  1,
  3,
  4,
  1,
  2,
  3,
  3,
  2,
  1,
  2,
  2,
  2,
  3,
  3,
  3,
  3,
  3,
  3,
  3,
  3,
  3,
  3,
  5,
  5,
  1,
  5,
  5,
  1,
  1,
  1,
  4,
  4,
  1,
  1,
  0,
  1,
  2,
  3,
  5,
  7,
  5,
  8,
  7,
  3,
  1,
  3,
  2,
  1,
  2,
  0,
  3,
  1,
  0,
  3,
  1,
  0,
  3,
  1,
  3,
  1,
  3,
  1,
  7,
  5,
  1,
  1,
  2,
  0,
  2,
  3,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0
}; // weak
__int16 word_815AEA0[256] =
{
  0,
  130,
  0,
  0,
  0,
  0,
  45,
  46,
  109,
  0,
  0,
  0,
  0,
  0,
  0,
  41,
  42,
  0,
  0,
  0,
  49,
  50,
  51,
  52,
  53,
  0,
  0,
  0,
  60,
  0,
  29,
  84,
  0,
  87,
  88,
  58,
  59,
  89,
  0,
  0,
  109,
  0,
  0,
  0,
  4,
  0,
  0,
  34,
  55,
  36,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  47,
  0,
  48,
  0,
  56,
  43,
  44,
  57,
  24,
  25,
  0,
  0,
  0,
  0,
  0,
  37,
  0,
  0,
  0,
  33,
  0,
  0,
  0,
  0,
  64,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  54,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  70,
  71,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  96,
  28,
  128,
  0,
  0,
  124,
  125,
  126,
  129,
  97,
  104,
  0,
  0,
  93,
  107,
  0,
  108,
  40,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  103,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  21,
  22,
  23,
  0,
  0,
  61,
  65,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  106,
  0,
  0,
  30,
  0,
  0,
  0,
  0,
  0,
  90,
  91,
  62,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  38,
  114,
  0,
  0,
  105,
  35,
  0,
  100,
  0,
  109,
  82,
  0,
  83,
  0,
  85,
  0,
  86,
  39,
  0,
  0,
  0,
  0,
  95,
  0,
  0,
  116,
  0,
  0,
  109,
  113,
  123,
  99,
  0,
  102,
  0,
  101,
  122,
  0,
  0
}; // weak
__int16 word_815B0A0[32] =
{
  3,
  4,
  55,
  58,
  139,
  140,
  59,
  204,
  46,
  47,
  48,
  49,
  50,
  60,
  61,
  62,
  210,
  212,
  214,
  53,
  240,
  57,
  142,
  219,
  133,
  56,
  0,
  0,
  0,
  0,
  0,
  0
}; // weak
__int16 word_815B0E0[] = { -268 }; // weak
__int16 word_815B2E0[] = { 0 }; // weak
__int16 word_815B4E0[32] =
{
  0,
  0,
  0,
  949,
  192,
  31,
  2,
  0,
  -16,
  0,
  0,
  176,
  -36,
  6,
  -110,
  770,
  0,
  0,
  0,
  -29,
  0,
  -40,
  124,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0
}; // weak
__int16 word_815B520[2064] =
{
  83,
  98,
  182,
  74,
  45,
  129,
  31,
  127,
  51,
  110,
  174,
  54,
  1,
  68,
  2,
  72,
  67,
  67,
  3,
  69,
  66,
  79,
  73,
  110,
  127,
  111,
  143,
  72,
  6,
  74,
  84,
  217,
  76,
  44,
  227,
  5,
  6,
  7,
  128,
  77,
  9,
  78,
  10,
  74,
  63,
  229,
  100,
  101,
  102,
  63,
  64,
  175,
  144,
  80,
  81,
  65,
  66,
  144,
  11,
  141,
  228,
  12,
  82,
  51,
  15,
  16,
  28,
  130,
  231,
  112,
  216,
  230,
  17,
  18,
  19,
  20,
  21,
  22,
  23,
  24,
  141,
  30,
  73,
  146,
  51,
  141,
  63,
  131,
  132,
  51,
  30,
  234,
  126,
  134,
  232,
  72,
  235,
  151,
  28,
  152,
  29,
  30,
  103,
  112,
  31,
  110,
  111,
  115,
  176,
  33,
  34,
  72,
  35,
  36,
  37,
  38,
  39,
  144,
  103,
  41,
  110,
  117,
  236,
  8,
  177,
  74,
  104,
  178,
  179,
  112,
  206,
  119,
  111,
  115,
  19,
  180,
  181,
  197,
  121,
  196,
  118,
  120,
  104,
  194,
  221,
  72,
  110,
  117,
  195,
  200,
  19,
  218,
  103,
  74,
  75,
  220,
  105,
  119,
  32,
  207,
  110,
  30,
  106,
  107,
  121,
  108,
  118,
  120,
  222,
  226,
  237,
  109,
  105,
  225,
  238,
  242,
  104,
  30,
  246,
  245,
  74,
  247,
  2,
  249,
  19,
  1,
  241,
  76,
  77,
  78,
  27,
  26,
  94,
  79,
  43,
  75,
  239,
  80,
  13,
  81,
  113,
  0,
  149,
  141,
  141,
  251,
  105,
  51,
  51,
  0,
  0,
  30,
  0,
  0,
  114,
  115,
  116,
  117,
  118,
  119,
  120,
  121,
  122,
  123,
  124,
  125,
  0,
  141,
  0,
  47,
  0,
  51,
  223,
  224,
  98,
  99,
  100,
  101,
  102,
  0,
  141,
  0,
  0,
  141,
  51,
  0,
  0,
  51,
  0,
  0,
  0,
  141,
  0,
  141,
  0,
  51,
  0,
  51,
  0,
  98,
  98,
  98,
  98,
  98,
  98,
  127,
  98,
  0,
  17,
  248,
  96,
  97,
  98,
  99,
  100,
  101,
  102,
  68,
  0,
  0,
  252,
  67,
  98,
  69,
  66,
  98,
  98,
  98,
  98,
  98,
  0,
  72,
  6,
  98,
  6,
  6,
  98,
  98,
  98,
  98,
  98,
  98,
  98,
  98,
  98,
  68,
  98,
  98,
  48,
  67,
  93,
  69,
  66,
  0,
  0,
  0,
  0,
  0,
  6,
  72,
  6,
  0,
  98,
  0,
  98,
  98,
  0,
  127,
  98,
  0,
  98,
  98,
  98,
  98,
  98,
  0,
  98,
  98,
  98,
  98,
  98,
  98,
  98,
  98,
  63,
  19,
  73,
  127,
  127,
  31,
  63,
  63,
  63,
  63,
  63,
  63,
  63,
  63,
  63,
  63,
  63,
  63,
  63,
  63,
  63,
  63,
  63,
  63,
  63,
  63,
  63,
  0,
  0,
  0,
  73,
  63,
  63,
  63,
  63,
  63,
  5,
  0,
  0,
  63,
  0,
  0,
  0,
  8,
  0,
  8,
  8,
  8,
  8,
  63,
  63,
  63,
  63,
  63,
  63,
  63,
  63,
  63,
  63,
  63,
  63,
  63,
  0,
  20,
  0,
  28,
  63,
  63,
  63,
  8,
  63,
  8,
  32,
  74,
  75,
  0,
  63,
  30,
  32,
  32,
  32,
  32,
  32,
  32,
  32,
  32,
  32,
  32,
  32,
  32,
  32,
  32,
  32,
  32,
  32,
  32,
  32,
  32,
  32,
  18,
  0,
  74,
  75,
  32,
  32,
  32,
  32,
  76,
  77,
  78,
  0,
  32,
  0,
  79,
  0,
  0,
  0,
  80,
  13,
  81,
  13,
  13,
  13,
  13,
  13,
  13,
  13,
  13,
  13,
  13,
  13,
  13,
  14,
  32,
  0,
  76,
  77,
  78,
  32,
  32,
  32,
  79,
  32,
  47,
  13,
  80,
  13,
  81,
  32,
  92,
  47,
  0,
  47,
  47,
  47,
  47,
  47,
  47,
  47,
  47,
  47,
  47,
  47,
  47,
  47,
  47,
  47,
  47,
  47,
  47,
  15,
  0,
  0,
  0,
  47,
  0,
  0,
  92,
  0,
  0,
  0,
  0,
  47,
  0,
  0,
  0,
  0,
  0,
  17,
  0,
  17,
  17,
  17,
  17,
  17,
  17,
  17,
  17,
  17,
  17,
  17,
  17,
  17,
  17,
  47,
  16,
  0,
  0,
  0,
  47,
  47,
  47,
  0,
  47,
  17,
  0,
  17,
  0,
  0,
  47,
  11,
  0,
  48,
  0,
  0,
  0,
  0,
  0,
  0,
  48,
  0,
  48,
  48,
  48,
  48,
  48,
  48,
  48,
  48,
  48,
  48,
  48,
  48,
  48,
  48,
  48,
  48,
  48,
  48,
  12,
  0,
  0,
  0,
  48,
  0,
  0,
  0,
  0,
  0,
  10,
  0,
  48,
  0,
  0,
  0,
  19,
  0,
  19,
  19,
  19,
  19,
  19,
  19,
  19,
  19,
  19,
  19,
  19,
  19,
  19,
  19,
  19,
  19,
  48,
  0,
  0,
  9,
  0,
  48,
  48,
  48,
  19,
  48,
  19,
  7,
  0,
  0,
  0,
  48,
  0,
  5,
  0,
  5,
  5,
  5,
  5,
  5,
  5,
  5,
  5,
  5,
  5,
  5,
  5,
  5,
  5,
  5,
  5,
  5,
  5,
  5,
  5,
  0,
  0,
  0,
  0,
  5,
  20,
  5,
  20,
  20,
  20,
  20,
  20,
  20,
  20,
  20,
  20,
  20,
  20,
  20,
  20,
  20,
  20,
  20,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  20,
  0,
  20,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  18,
  0,
  18,
  18,
  18,
  18,
  18,
  18,
  18,
  18,
  18,
  18,
  18,
  18,
  18,
  18,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  18,
  0,
  18,
  0,
  0,
  0,
  0,
  14,
  0,
  14,
  14,
  14,
  14,
  14,
  14,
  14,
  14,
  14,
  14,
  14,
  14,
  92,
  93,
  94,
  95,
  96,
  97,
  98,
  99,
  100,
  101,
  102,
  0,
  14,
  0,
  14,
  0,
  0,
  0,
  52,
  0,
  0,
  0,
  0,
  0,
  15,
  0,
  15,
  15,
  15,
  15,
  15,
  15,
  15,
  15,
  15,
  15,
  15,
  15,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  15,
  0,
  15,
  0,
  0,
  0,
  0,
  0,
  0,
  16,
  0,
  16,
  16,
  16,
  16,
  16,
  16,
  16,
  16,
  16,
  16,
  16,
  16,
  52,
  11,
  0,
  11,
  11,
  11,
  11,
  11,
  11,
  11,
  11,
  0,
  16,
  0,
  16,
  0,
  0,
  0,
  0,
  0,
  0,
  52,
  0,
  0,
  0,
  0,
  52,
  11,
  0,
  11,
  12,
  0,
  12,
  12,
  12,
  12,
  12,
  12,
  12,
  12,
  10,
  0,
  10,
  10,
  10,
  10,
  10,
  10,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  12,
  0,
  12,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  10,
  9,
  10,
  9,
  9,
  9,
  9,
  9,
  0,
  7,
  0,
  7,
  7,
  7,
  90,
  91,
  92,
  93,
  94,
  95,
  96,
  97,
  98,
  99,
  100,
  101,
  102,
  9,
  0,
  9,
  0,
  0,
  0,
  0,
  0,
  7,
  0,
  7,
  0,
  5,
  5,
  5,
  5,
  5,
  5,
  5,
  5,
  5,
  5,
  5,
  5,
  5,
  5,
  5,
  5,
  5,
  5,
  0,
  42,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  68,
  69,
  0,
  0,
  70,
  71,
  0,
  0,
  201,
  52,
  52,
  85,
  86,
  87,
  88,
  89,
  90,
  91,
  92,
  93,
  94,
  95,
  96,
  97,
  98,
  99,
  100,
  101,
  102,
  0,
  0,
  0,
  0,
  52,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  52,
  0,
  0,
  52,
  145,
  0,
  0,
  0,
  0,
  0,
  0,
  52,
  0,
  52,
  0,
  0,
  0,
  147,
  148,
  0,
  0,
  150,
  0,
  0,
  0,
  0,
  154,
  155,
  156,
  157,
  158,
  159,
  160,
  161,
  162,
  163,
  164,
  165,
  166,
  167,
  168,
  169,
  170,
  171,
  173,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  183,
  0,
  0,
  184,
  185,
  186,
  187,
  188,
  189,
  190,
  191,
  192,
  193,
  85,
  86,
  87,
  88,
  89,
  90,
  91,
  92,
  93,
  94,
  95,
  96,
  97,
  98,
  99,
  100,
  101,
  102,
  198,
  0,
  0,
  0,
  0,
  203,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  5,
  6,
  7,
  8,
  135,
  9,
  0,
  10,
  0,
  0,
  145,
  0,
  0,
  0,
  209,
  211,
  213,
  215,
  0,
  0,
  0,
  0,
  0,
  11,
  0,
  0,
  12,
  0,
  0,
  15,
  16,
  0,
  0,
  0,
  136,
  0,
  0,
  17,
  18,
  19,
  20,
  21,
  22,
  23,
  24,
  25,
  0,
  26,
  27,
  89,
  90,
  91,
  92,
  93,
  94,
  95,
  96,
  97,
  98,
  99,
  100,
  101,
  102,
  28,
  0,
  29,
  30,
  0,
  243,
  31,
  244,
  32,
  137,
  138,
  33,
  34,
  0,
  35,
  36,
  37,
  38,
  39,
  40,
  0,
  41,
  5,
  6,
  7,
  8,
  0,
  9,
  0,
  10,
  88,
  89,
  90,
  91,
  92,
  93,
  94,
  95,
  96,
  97,
  98,
  99,
  100,
  101,
  102,
  11,
  0,
  0,
  12,
  0,
  0,
  15,
  16,
  0,
  0,
  0,
  136,
  0,
  0,
  17,
  18,
  19,
  20,
  21,
  22,
  23,
  24,
  25,
  0,
  26,
  27,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  28,
  0,
  29,
  30,
  0,
  0,
  31,
  0,
  32,
  137,
  138,
  33,
  34,
  0,
  35,
  36,
  37,
  38,
  39,
  40,
  153,
  41,
  5,
  6,
  7,
  8,
  250,
  9,
  0,
  10,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  11,
  0,
  0,
  12,
  0,
  0,
  15,
  16,
  0,
  0,
  0,
  136,
  0,
  0,
  17,
  18,
  19,
  20,
  21,
  22,
  23,
  24,
  25,
  0,
  26,
  27,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  28,
  0,
  29,
  30,
  0,
  0,
  31,
  0,
  32,
  137,
  138,
  33,
  34,
  0,
  35,
  36,
  37,
  38,
  39,
  40,
  0,
  41,
  5,
  6,
  7,
  8,
  253,
  9,
  0,
  10,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  11,
  0,
  0,
  12,
  0,
  0,
  15,
  16,
  0,
  0,
  0,
  136,
  0,
  0,
  17,
  18,
  19,
  20,
  21,
  22,
  23,
  24,
  25,
  0,
  26,
  27,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  28,
  0,
  29,
  30,
  0,
  0,
  31,
  0,
  32,
  137,
  138,
  33,
  34,
  0,
  35,
  36,
  37,
  38,
  39,
  40,
  0,
  41,
  5,
  6,
  7,
  8,
  0,
  9,
  0,
  10,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  11,
  0,
  0,
  12,
  0,
  0,
  15,
  16,
  0,
  0,
  0,
  136,
  0,
  0,
  17,
  18,
  19,
  20,
  21,
  22,
  23,
  24,
  25,
  0,
  26,
  27,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  28,
  0,
  29,
  30,
  0,
  0,
  31,
  0,
  32,
  137,
  138,
  33,
  34,
  0,
  35,
  36,
  37,
  38,
  39,
  40,
  0,
  41,
  5,
  6,
  7,
  8,
  0,
  9,
  0,
  10,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  11,
  0,
  0,
  12,
  13,
  14,
  15,
  16,
  0,
  0,
  0,
  0,
  0,
  0,
  17,
  18,
  19,
  20,
  21,
  22,
  23,
  24,
  25,
  0,
  26,
  27,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  28,
  0,
  29,
  30,
  0,
  0,
  31,
  0,
  32,
  0,
  0,
  33,
  34,
  0,
  35,
  36,
  37,
  38,
  39,
  40,
  0,
  41,
  5,
  6,
  7,
  8,
  0,
  9,
  0,
  10,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  11,
  0,
  0,
  12,
  0,
  0,
  15,
  16,
  0,
  0,
  0,
  0,
  0,
  0,
  17,
  18,
  19,
  20,
  21,
  22,
  23,
  24,
  25,
  0,
  26,
  27,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  28,
  0,
  29,
  30,
  0,
  0,
  31,
  0,
  32,
  0,
  0,
  33,
  34,
  0,
  35,
  36,
  37,
  38,
  39,
  40,
  0,
  41,
  5,
  6,
  7,
  0,
  0,
  9,
  0,
  172,
  64,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  11,
  0,
  0,
  12,
  13,
  14,
  15,
  16,
  5,
  6,
  7,
  0,
  0,
  9,
  0,
  10,
  19,
  20,
  21,
  22,
  23,
  24,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  11,
  0,
  0,
  12,
  13,
  14,
  15,
  16,
  0,
  28,
  0,
  29,
  30,
  0,
  0,
  0,
  19,
  20,
  21,
  22,
  23,
  24,
  0,
  35,
  36,
  0,
  0,
  0,
  0,
  0,
  41,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  28,
  0,
  29,
  30,
  5,
  6,
  7,
  0,
  0,
  9,
  0,
  172,
  0,
  0,
  35,
  36,
  0,
  0,
  0,
  0,
  0,
  41,
  0,
  0,
  0,
  0,
  0,
  11,
  0,
  0,
  12,
  13,
  14,
  15,
  16,
  5,
  6,
  7,
  0,
  0,
  9,
  0,
  10,
  19,
  20,
  21,
  22,
  23,
  24,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  11,
  0,
  0,
  12,
  0,
  0,
  15,
  16,
  0,
  28,
  0,
  29,
  30,
  0,
  0,
  0,
  19,
  20,
  21,
  22,
  23,
  24,
  0,
  35,
  36,
  0,
  0,
  0,
  0,
  0,
  41,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  28,
  0,
  29,
  30,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  35,
  36,
  0,
  0,
  0,
  202,
  0,
  41,
  85,
  86,
  87,
  88,
  89,
  90,
  91,
  92,
  93,
  94,
  95,
  96,
  97,
  98,
  99,
  100,
  101,
  102,
  205,
  0,
  0,
  85,
  86,
  87,
  88,
  89,
  90,
  91,
  92,
  93,
  94,
  95,
  96,
  97,
  98,
  99,
  100,
  101,
  102,
  233,
  0,
  0,
  85,
  86,
  87,
  88,
  89,
  90,
  91,
  92,
  93,
  94,
  95,
  96,
  97,
  98,
  99,
  100,
  101,
  102,
  199,
  85,
  86,
  87,
  88,
  89,
  90,
  91,
  92,
  93,
  94,
  95,
  96,
  97,
  98,
  99,
  100,
  101,
  102,
  208,
  85,
  86,
  87,
  88,
  89,
  90,
  91,
  92,
  93,
  94,
  95,
  96,
  97,
  98,
  99,
  100,
  101,
  102,
  86,
  87,
  88,
  89,
  90,
  91,
  92,
  93,
  94,
  95,
  96,
  97,
  98,
  99,
  100,
  101,
  102,
  87,
  88,
  89,
  90,
  91,
  92,
  93,
  94,
  95,
  96,
  97,
  98,
  99,
  100,
  101,
  102,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0
}; // weak
__int16 word_815C540[] = { 40 }; // weak
int dword_815D548 = 1; // weak
char *off_815D560 = "userinfo"; // weak
int dword_815D6E0 = 2; // weak
int dword_815D6E4 = 1; // weak
float flt_815D6E8[3] = { -64.0, -64.0, -32.0 }; // weak
float flt_815D6F4[489] =
{
  64.0,
  64.0,
  72.0,
  -0.52573103,
  0.0,
  0.85065103,
  -0.44286299,
  0.238856,
  0.86418802,
  -0.29524201,
  0.0,
  0.955423,
  -0.309017,
  0.5,
  0.809017,
  -0.16246,
  0.26286599,
  0.951056,
  0.0,
  0.0,
  1.0,
  0.0,
  0.85065103,
  0.52573103,
  -0.14762101,
  0.71656698,
  0.68171799,
  0.14762101,
  0.71656698,
  0.68171799,
  0.0,
  0.52573103,
  0.85065103,
  0.309017,
  0.5,
  0.809017,
  0.52573103,
  0.0,
  0.85065103,
  0.29524201,
  0.0,
  0.955423,
  0.44286299,
  0.238856,
  0.86418802,
  0.16246,
  0.26286599,
  0.951056,
  -0.68171799,
  0.14762101,
  0.71656698,
  -0.809017,
  0.309017,
  0.5,
  -0.58778501,
  0.42532501,
  0.688191,
  -0.85065103,
  0.52573103,
  0.0,
  -0.86418802,
  0.44286299,
  0.238856,
  -0.71656698,
  0.68171799,
  0.14762101,
  -0.688191,
  0.58778501,
  0.42532501,
  -0.5,
  0.809017,
  0.309017,
  -0.238856,
  0.86418802,
  0.44286299,
  -0.42532501,
  0.688191,
  0.58778501,
  -0.71656698,
  0.68171799,
  -0.14762101,
  -0.5,
  0.809017,
  -0.309017,
  -0.52573103,
  0.85065103,
  0.0,
  0.0,
  0.85065103,
  -0.52573103,
  -0.238856,
  0.86418802,
  -0.44286299,
  0.0,
  0.955423,
  -0.29524201,
  -0.26286599,
  0.951056,
  -0.16246,
  0.0,
  1.0,
  0.0,
  0.0,
  0.955423,
  0.29524201,
  -0.26286599,
  0.951056,
  0.16246,
  0.238856,
  0.86418802,
  0.44286299,
  0.26286599,
  0.951056,
  0.16246,
  0.5,
  0.809017,
  0.309017,
  0.238856,
  0.86418802,
  -0.44286299,
  0.26286599,
  0.951056,
  -0.16246,
  0.5,
  0.809017,
  -0.309017,
  0.85065103,
  0.52573103,
  0.0,
  0.71656698,
  0.68171799,
  0.14762101,
  0.71656698,
  0.68171799,
  -0.14762101,
  0.52573103,
  0.85065103,
  0.0,
  0.42532501,
  0.688191,
  0.58778501,
  0.86418802,
  0.44286299,
  0.238856,
  0.688191,
  0.58778501,
  0.42532501,
  0.809017,
  0.309017,
  0.5,
  0.68171799,
  0.14762101,
  0.71656698,
  0.58778501,
  0.42532501,
  0.688191,
  0.955423,
  0.29524201,
  0.0,
  1.0,
  0.0,
  0.0,
  0.951056,
  0.16246,
  0.26286599,
  0.85065103,
  -0.52573103,
  0.0,
  0.955423,
  -0.29524201,
  0.0,
  0.86418802,
  -0.44286299,
  0.238856,
  0.951056,
  -0.16246,
  0.26286599,
  0.809017,
  -0.309017,
  0.5,
  0.68171799,
  -0.14762101,
  0.71656698,
  0.85065103,
  0.0,
  0.52573103,
  0.86418802,
  0.44286299,
  -0.238856,
  0.809017,
  0.309017,
  -0.5,
  0.951056,
  0.16246,
  -0.26286599,
  0.52573103,
  0.0,
  -0.85065103,
  0.68171799,
  0.14762101,
  -0.71656698,
  0.68171799,
  -0.14762101,
  -0.71656698,
  0.85065103,
  0.0,
  -0.52573103,
  0.809017,
  -0.309017,
  -0.5,
  0.86418802,
  -0.44286299,
  -0.238856,
  0.951056,
  -0.16246,
  -0.26286599,
  0.14762101,
  0.71656698,
  -0.68171799,
  0.309017,
  0.5,
  -0.809017,
  0.42532501,
  0.688191,
  -0.58778501,
  0.44286299,
  0.238856,
  -0.86418802,
  0.58778501,
  0.42532501,
  -0.688191,
  0.688191,
  0.58778501,
  -0.42532501,
  -0.14762101,
  0.71656698,
  -0.68171799,
  -0.309017,
  0.5,
  -0.809017,
  0.0,
  0.52573103,
  -0.85065103,
  -0.52573103,
  0.0,
  -0.85065103,
  -0.44286299,
  0.238856,
  -0.86418802,
  -0.29524201,
  0.0,
  -0.955423,
  -0.16246,
  0.26286599,
  -0.951056,
  0.0,
  0.0,
  -1.0,
  0.29524201,
  0.0,
  -0.955423,
  0.16246,
  0.26286599,
  -0.951056,
  -0.44286299,
  -0.238856,
  -0.86418802,
  -0.309017,
  -0.5,
  -0.809017,
  -0.16246,
  -0.26286599,
  -0.951056,
  0.0,
  -0.85065103,
  -0.52573103,
  -0.14762101,
  -0.71656698,
  -0.68171799,
  0.14762101,
  -0.71656698,
  -0.68171799,
  0.0,
  -0.52573103,
  -0.85065103,
  0.309017,
  -0.5,
  -0.809017,
  0.44286299,
  -0.238856,
  -0.86418802,
  0.16246,
  -0.26286599,
  -0.951056,
  0.238856,
  -0.86418802,
  -0.44286299,
  0.5,
  -0.809017,
  -0.309017,
  0.42532501,
  -0.688191,
  -0.58778501,
  0.71656698,
  -0.68171799,
  -0.14762101,
  0.688191,
  -0.58778501,
  -0.42532501,
  0.58778501,
  -0.42532501,
  -0.688191,
  0.0,
  -0.955423,
  -0.29524201,
  0.0,
  -1.0,
  0.0,
  0.26286599,
  -0.951056,
  -0.16246,
  0.0,
  -0.85065103,
  0.52573103,
  0.0,
  -0.955423,
  0.29524201,
  0.238856,
  -0.86418802,
  0.44286299,
  0.26286599,
  -0.951056,
  0.16246,
  0.5,
  -0.809017,
  0.309017,
  0.71656698,
  -0.68171799,
  0.14762101,
  0.52573103,
  -0.85065103,
  0.0,
  -0.238856,
  -0.86418802,
  -0.44286299,
  -0.5,
  -0.809017,
  -0.309017,
  -0.26286599,
  -0.951056,
  -0.16246,
  -0.85065103,
  -0.52573103,
  0.0,
  -0.71656698,
  -0.68171799,
  -0.14762101,
  -0.71656698,
  -0.68171799,
  0.14762101,
  -0.52573103,
  -0.85065103,
  0.0,
  -0.5,
  -0.809017,
  0.309017,
  -0.238856,
  -0.86418802,
  0.44286299,
  -0.26286599,
  -0.951056,
  0.16246,
  -0.86418802,
  -0.44286299,
  0.238856,
  -0.809017,
  -0.309017,
  0.5,
  -0.688191,
  -0.58778501,
  0.42532501,
  -0.68171799,
  -0.14762101,
  0.71656698,
  -0.44286299,
  -0.238856,
  0.86418802,
  -0.58778501,
  -0.42532501,
  0.688191,
  -0.309017,
  -0.5,
  0.809017,
  -0.14762101,
  -0.71656698,
  0.68171799,
  -0.42532501,
  -0.688191,
  0.58778501,
  -0.16246,
  -0.26286599,
  0.951056,
  0.44286299,
  -0.238856,
  0.86418802,
  0.16246,
  -0.26286599,
  0.951056,
  0.309017,
  -0.5,
  0.809017,
  0.14762101,
  -0.71656698,
  0.68171799,
  0.0,
  -0.52573103,
  0.85065103,
  0.42532501,
  -0.688191,
  0.58778501,
  0.58778501,
  -0.42532501,
  0.688191,
  0.688191,
  -0.58778501,
  0.42532501,
  -0.955423,
  0.29524201,
  0.0,
  -0.951056,
  0.16246,
  0.26286599,
  -1.0,
  0.0,
  0.0,
  -0.85065103,
  0.0,
  0.52573103,
  -0.955423,
  -0.29524201,
  0.0,
  -0.951056,
  -0.16246,
  0.26286599,
  -0.86418802,
  0.44286299,
  -0.238856,
  -0.951056,
  0.16246,
  -0.26286599,
  -0.809017,
  0.309017,
  -0.5,
  -0.86418802,
  -0.44286299,
  -0.238856,
  -0.951056,
  -0.16246,
  -0.26286599,
  -0.809017,
  -0.309017,
  -0.5,
  -0.68171799,
  0.14762101,
  -0.71656698,
  -0.68171799,
  -0.14762101,
  -0.71656698,
  -0.85065103,
  0.0,
  -0.52573103,
  -0.688191,
  0.58778501,
  -0.42532501,
  -0.58778501,
  0.42532501,
  -0.688191,
  -0.42532501,
  0.688191,
  -0.58778501,
  -0.42532501,
  -0.688191,
  -0.58778501,
  -0.58778501,
  -0.42532501,
  -0.688191,
  -0.688191,
  -0.58778501,
  -0.42532501
}; // weak
int dword_815DE98 = -1985229329; // weak
int dword_815DEA0[] = { 0 }; // weak
char *off_815DF00[13] =
{
  "auto",
  "auto2d",
  "menu",
  "weapon",
  "voice",
  "item",
  "body",
  "local",
  "music",
  "announcer",
  "shellshock",
  "off",
  "on"
}; // weak
char *off_815DF2C[2] = { "off", "on" }; // weak
char *off_815DF30 = "on"; // weak
char *off_815DF40[14] =
{
  "+=",
  "-=",
  "*=",
  "/=",
  "&=",
  "|=",
  "++",
  "--",
  "&&",
  "||",
  "<=",
  ">=",
  "==",
  "!="
}; // weak
_UNKNOWN unk_815DF80; // weak
int dword_816294C[] = { 0 }; // weak
char *off_8162960 = "bark"; // weak
int dword_8162968[263] =
{
  1048576,
  0,
  0,
  135563781,
  0,
  2097152,
  0,
  0,
  135563787,
  0,
  3145728,
  0,
  0,
  135563794,
  0,
  4194304,
  0,
  0,
  135563800,
  0,
  5242880,
  0,
  0,
  135563809,
  0,
  6291456,
  0,
  0,
  135563814,
  0,
  7340032,
  0,
  0,
  135563820,
  1,
  8388608,
  2,
  0,
  135563828,
  1,
  9437184,
  16,
  0,
  135563834,
  0,
  10485760,
  0,
  0,
  135563840,
  0,
  11534336,
  0,
  0,
  135563847,
  0,
  12582912,
  0,
  0,
  135563851,
  0,
  13631488,
  0,
  0,
  135563857,
  0,
  14680064,
  0,
  0,
  135563861,
  0,
  15728640,
  0,
  0,
  135563867,
  0,
  16777216,
  0,
  0,
  135563875,
  0,
  17825792,
  0,
  0,
  135563880,
  0,
  18874368,
  0,
  0,
  135563885,
  0,
  19922944,
  0,
  0,
  135563890,
  1,
  20971520,
  32,
  0,
  135563896,
  0,
  22020096,
  0,
  0,
  135563901,
  0,
  23068672,
  0,
  0,
  135563909,
  0,
  9437184,
  0,
  0,
  135563921,
  1,
  0,
  128,
  0,
  135563933,
  1,
  0,
  4096,
  0,
  135563944,
  1,
  0,
  8192,
  0,
  135563953,
  1,
  0,
  65536,
  0,
  135563964,
  1,
  0,
  131072,
  0,
  135563976,
  1,
  0,
  512,
  0,
  135563988,
  1,
  0,
  1024,
  0,
  135563997,
  1,
  0,
  2147483648,
  0,
  135564004,
  1,
  16384,
  0,
  0,
  135564013,
  0,
  0,
  134217728,
  0,
  135564020,
  0,
  0,
  268435456,
  0,
  135564031,
  1,
  2147483648,
  0,
  0,
  135564038,
  0,
  0,
  64,
  0,
  135564051,
  1,
  0,
  0,
  4,
  135564058,
  0,
  4,
  2048,
  0,
  135564062,
  0,
  65536,
  0,
  0,
  135564074,
  0,
  262144,
  0,
  0,
  135564087,
  0,
  2,
  0,
  0,
  135564093,
  0,
  16,
  0,
  0,
  135564102,
  0,
  32,
  0,
  0,
  135564110,
  0,
  8,
  0,
  0,
  135564117,
  0,
  1,
  0,
  0,
  135564126,
  0,
  33554432,
  16777216,
  0,
  135564135,
  0,
  67108864,
  16777216,
  0,
  135564146,
  0,
  8192,
  0,
  0,
  135564154,
  0,
  128,
  0,
  0,
  135564161,
  0,
  2048,
  0,
  0,
  135564172,
  0,
  1024,
  0,
  0,
  135564183,
  0,
  131072,
  0,
  0,
  0,
  0,
  0,
  0,
  0
}; // weak
char *off_8162D84 = "1.1.4"; // weak
int dword_8162DA0 = 9; // weak
int dword_8162DA4 = 5; // weak
_UNKNOWN unk_8162DC0; // weak
_UNKNOWN unk_8163DC0; // weak
int dword_8163EC0[17] =
{
  0,
  1,
  3,
  7,
  15,
  31,
  63,
  127,
  255,
  511,
  1023,
  2047,
  4095,
  8191,
  16383,
  32767,
  65535
}; // weak
void *off_8163F04 = &unk_8149F40; // weak
void *off_8163F18 = &unk_814A3C0; // weak
_UNKNOWN unk_8163F2C; // weak
char *off_8163F50[5] =
{
  "stream error",
  "data error",
  "insufficient memory",
  "buffer error",
  "incompatible version"
}; // weak
char *off_8163F58[3] = { "insufficient memory", "buffer error", "incompatible version" }; // weak
char *off_8163F5C[2] = { "buffer error", "incompatible version" }; // weak
int dword_8163F80 = 1; // weak
int dword_8163F84 = -1; // weak
char byte_8163FA0 = '\0'; // idb
char off_81643C0[] = { '`', '\xB2', '\x14', '\b' }; // idb
char *off_81643E0 = "RELAXED"; // weak
char *off_8164420 = "** UNUSED **"; // weak
char *off_8164580 = "PAIN"; // weak
char *off_8164620 = "** UNUSED **"; // weak
char *off_8164760 = "PLAYERANIMTYPE"; // weak
int dword_81647C0[] = { 0 }; // weak
int off_81647C4[17] =
{
  139942976,
  0,
  135677632,
  1,
  135677584,
  0,
  135676960,
  1,
  0,
  1,
  0,
  1,
  0,
  1,
  135677720,
  1,
  135677760
}; // weak
_UNKNOWN off_8164808; // weak
char *off_8164820 = "defines"; // weak
int dword_8164860[] = { 1 }; // weak
int dword_8164864[] = { 8 }; // weak
float flt_8164868[22] =
{
  57.0,
  ?flt,
  ?flt,
  51.0,
  ?flt,
  ?flt,
  45.0,
  ?flt,
  ?flt,
  39.0,
  ?flt,
  ?flt,
  33.0,
  ?flt,
  ?flt,
  27.0,
  ?flt,
  ?flt,
  21.0,
  0.0,
  0.0,
  0.0
}; // weak
char *off_81648C0 = "mp_mantle_root"; // idb
_UNKNOWN unk_8164C20; // weak
int dword_8164C28[] = { 0 }; // weak
int dword_8164C2C[] = { 0 }; // weak
int dword_8164C34[] = { 0 }; // weak
int dword_8164C3C[1449] =
{
  0,
  0,
  0,
  0,
  0,
  135584964,
  135584964,
  135584964,
  135584964,
  135584964,
  0,
  0,
  0,
  0,
  0,
  0,
  135584964,
  135584964,
  135584964,
  135584964,
  135584964,
  0,
  0,
  0,
  0,
  0,
  0,
  135584964,
  135584964,
  135584964,
  135584964,
  135584964,
  0,
  0,
  0,
  0,
  0,
  0,
  135584964,
  135584964,
  135584964,
  135584964,
  135584964,
  0,
  0,
  0,
  0,
  0,
  0,
  135584964,
  135584964,
  135584964,
  135584964,
  135584964,
  0,
  0,
  0,
  0,
  0,
  0,
  135584964,
  135584964,
  135584964,
  135584964,
  135584964,
  0,
  0,
  0,
  0,
  0,
  0,
  135584964,
  135584964,
  135584964,
  135584964,
  135584964,
  0,
  0,
  0,
  0,
  0,
  0,
  135584964,
  135584964,
  135584964,
  135584964,
  135584964,
  0,
  0,
  0,
  0,
  0,
  0,
  135584964,
  135584964,
  135584964,
  135584964,
  135584964,
  0,
  0,
  0,
  0,
  0,
  0,
  135584964,
  135584964,
  135584964,
  135584964,
  135584964,
  0,
  0,
  0,
  0,
  0,
  0,
  135584964,
  135584964,
  135584964,
  135584964,
  135584964,
  0,
  0,
  0,
  0,
  0,
  0,
  135584964,
  135584964,
  135584964,
  135584964,
  135584964,
  0,
  0,
  0,
  0,
  0,
  0,
  135584964,
  135584964,
  135584964,
  135584964,
  135584964,
  0,
  0,
  0,
  0,
  0,
  0,
  135584964,
  135584964,
  135584964,
  135584964,
  135584964,
  0,
  0,
  0,
  0,
  0,
  0,
  135584964,
  135584964,
  135584964,
  135584964,
  135584964,
  0,
  0,
  0,
  0,
  0,
  0,
  135584964,
  135584964,
  135584964,
  135584964,
  135584964,
  0,
  0,
  0,
  0,
  0,
  0,
  135584964,
  135584964,
  135584964,
  135584964,
  135584964,
  0,
  0,
  0,
  0,
  0,
  0,
  135584964,
  135584964,
  135584964,
  135584964,
  135584964,
  0,
  0,
  0,
  0,
  0,
  0,
  135584964,
  135584964,
  135584964,
  135584964,
  135584964,
  0,
  0,
  0,
  0,
  0,
  0,
  135584964,
  135584964,
  135584964,
  135584964,
  135584964,
  0,
  0,
  0,
  0,
  0,
  0,
  135584964,
  135584964,
  135584964,
  135584964,
  135584964,
  0,
  0,
  0,
  0,
  0,
  0,
  135584964,
  135584964,
  135584964,
  135584964,
  135584964,
  0,
  0,
  0,
  0,
  0,
  0,
  135584964,
  135584964,
  135584964,
  135584964,
  135584964,
  0,
  0,
  0,
  0,
  0,
  0,
  135584964,
  135584964,
  135584964,
  135584964,
  135584964,
  0,
  0,
  0,
  0,
  0,
  0,
  135584964,
  135584964,
  135584964,
  135584964,
  135584964,
  0,
  0,
  0,
  0,
  0,
  0,
  135584964,
  135584964,
  135584964,
  135584964,
  135584964,
  0,
  0,
  0,
  0,
  0,
  0,
  135584964,
  135584964,
  135584964,
  135584964,
  135584964,
  0,
  0,
  0,
  0,
  0,
  0,
  135584964,
  135584964,
  135584964,
  135584964,
  135584964,
  0,
  0,
  0,
  0,
  0,
  0,
  135584964,
  135584964,
  135584964,
  135584964,
  135584964,
  0,
  0,
  0,
  0,
  0,
  0,
  135584964,
  135584964,
  135584964,
  135584964,
  135584964,
  0,
  0,
  0,
  0,
  0,
  0,
  135584964,
  135584964,
  135584964,
  135584964,
  135584964,
  0,
  0,
  0,
  0,
  0,
  0,
  135584964,
  135584964,
  135584964,
  135584964,
  135584964,
  0,
  0,
  0,
  0,
  0,
  0,
  135584964,
  135584964,
  135584964,
  135584964,
  135584964,
  0,
  0,
  0,
  0,
  0,
  0,
  135584964,
  135584964,
  135584964,
  135584964,
  135584964,
  0,
  0,
  0,
  0,
  0,
  0,
  135584964,
  135584964,
  135584964,
  135584964,
  135584964,
  0,
  0,
  0,
  0,
  0,
  0,
  135584964,
  135584964,
  135584964,
  135584964,
  135584964,
  0,
  0,
  0,
  0,
  0,
  0,
  135584964,
  135584964,
  135584964,
  135584964,
  135584964,
  0,
  0,
  0,
  0,
  0,
  0,
  135584964,
  135584964,
  135584964,
  135584964,
  135584964,
  0,
  0,
  0,
  0,
  0,
  0,
  135584964,
  135584964,
  135584964,
  135584964,
  135584964,
  0,
  0,
  0,
  0,
  0,
  0,
  135584964,
  135584964,
  135584964,
  135584964,
  135584964,
  0,
  0,
  0,
  0,
  0,
  0,
  135584964,
  135584964,
  135584964,
  135584964,
  135584964,
  0,
  0,
  0,
  0,
  0,
  0,
  135584964,
  135584964,
  135584964,
  135584964,
  135584964,
  0,
  0,
  0,
  0,
  0,
  0,
  135584964,
  135584964,
  135584964,
  135584964,
  135584964,
  0,
  0,
  0,
  0,
  0,
  0,
  135584964,
  135584964,
  135584964,
  135584964,
  135584964,
  0,
  0,
  0,
  0,
  0,
  0,
  135584964,
  135584964,
  135584964,
  135584964,
  135584964,
  0,
  0,
  0,
  0,
  0,
  0,
  135584964,
  135584964,
  135584964,
  135584964,
  135584964,
  0,
  0,
  0,
  0,
  0,
  0,
  135584964,
  135584964,
  135584964,
  135584964,
  135584964,
  0,
  0,
  0,
  0,
  0,
  0,
  135584964,
  135584964,
  135584964,
  135584964,
  135584964,
  0,
  0,
  0,
  0,
  0,
  0,
  135584964,
  135584964,
  135584964,
  135584964,
  135584964,
  0,
  0,
  0,
  0,
  0,
  0,
  135584964,
  135584964,
  135584964,
  135584964,
  135584964,
  0,
  0,
  0,
  0,
  0,
  0,
  135584964,
  135584964,
  135584964,
  135584964,
  135584964,
  0,
  0,
  0,
  0,
  0,
  0,
  135584964,
  135584964,
  135584964,
  135584964,
  135584964,
  0,
  0,
  0,
  0,
  0,
  0,
  135584964,
  135584964,
  135584964,
  135584964,
  135584964,
  0,
  0,
  0,
  0,
  0,
  0,
  135584964,
  135584964,
  135584964,
  135584964,
  135584964,
  0,
  0,
  0,
  0,
  0,
  0,
  135584964,
  135584964,
  135584964,
  135584964,
  135584964,
  0,
  0,
  0,
  0,
  0,
  0,
  135584964,
  135584964,
  135584964,
  135584964,
  135584964,
  0,
  0,
  0,
  0,
  0,
  0,
  135584964,
  135584964,
  135584964,
  135584964,
  135584964,
  0,
  0,
  0,
  0,
  0,
  0,
  135584964,
  135584964,
  135584964,
  135584964,
  135584964,
  0,
  0,
  0,
  0,
  0,
  0,
  135584964,
  135584964,
  135584964,
  135584964,
  135584964,
  0,
  0,
  0,
  0,
  0,
  0,
  135584964,
  135584964,
  135584964,
  135584964,
  135584964,
  0,
  0,
  0,
  0,
  0,
  0,
  135584964,
  135584964,
  135584964,
  135584964,
  135584964,
  0,
  0,
  0,
  0,
  0,
  0,
  135584964,
  135584964,
  135584964,
  135584964,
  135584964,
  0,
  0,
  0,
  0,
  0,
  0,
  135584964,
  135584964,
  135584964,
  135584964,
  135584964,
  0,
  0,
  0,
  0,
  0,
  0,
  135584964,
  135584964,
  135584964,
  135584964,
  135584964,
  0,
  0,
  0,
  0,
  0,
  0,
  135584964,
  135584964,
  135584964,
  135584964,
  135584964,
  0,
  0,
  0,
  0,
  0,
  0,
  135584964,
  135584964,
  135584964,
  135584964,
  135584964,
  0,
  0,
  0,
  0,
  0,
  0,
  135584964,
  135584964,
  135584964,
  135584964,
  135584964,
  0,
  0,
  0,
  0,
  0,
  0,
  135584964,
  135584964,
  135584964,
  135584964,
  135584964,
  0,
  0,
  0,
  0,
  0,
  0,
  135584964,
  135584964,
  135584964,
  135584964,
  135584964,
  0,
  0,
  0,
  0,
  0,
  0,
  135584964,
  135584964,
  135584964,
  135584964,
  135584964,
  0,
  0,
  0,
  0,
  0,
  0,
  135584964,
  135584964,
  135584964,
  135584964,
  135584964,
  0,
  0,
  0,
  0,
  0,
  0,
  135584964,
  135584964,
  135584964,
  135584964,
  135584964,
  0,
  0,
  0,
  0,
  0,
  0,
  135584964,
  135584964,
  135584964,
  135584964,
  135584964,
  0,
  0,
  0,
  0,
  0,
  0,
  135584964,
  135584964,
  135584964,
  135584964,
  135584964,
  0,
  0,
  0,
  0,
  0,
  0,
  135584964,
  135584964,
  135584964,
  135584964,
  135584964,
  0,
  0,
  0,
  0,
  0,
  0,
  135584964,
  135584964,
  135584964,
  135584964,
  135584964,
  0,
  0,
  0,
  0,
  0,
  0,
  135584964,
  135584964,
  135584964,
  135584964,
  135584964,
  0,
  0,
  0,
  0,
  0,
  0,
  135584964,
  135584964,
  135584964,
  135584964,
  135584964,
  0,
  0,
  0,
  0,
  0,
  0,
  135584964,
  135584964,
  135584964,
  135584964,
  135584964,
  0,
  0,
  0,
  0,
  0,
  0,
  135584964,
  135584964,
  135584964,
  135584964,
  135584964,
  0,
  0,
  0,
  0,
  0,
  0,
  135584964,
  135584964,
  135584964,
  135584964,
  135584964,
  0,
  0,
  0,
  0,
  0,
  0,
  135584964,
  135584964,
  135584964,
  135584964,
  135584964,
  0,
  0,
  0,
  0,
  0,
  0,
  135584964,
  135584964,
  135584964,
  135584964,
  135584964,
  0,
  0,
  0,
  0,
  0,
  0,
  135584964,
  135584964,
  135584964,
  135584964,
  135584964,
  0,
  0,
  0,
  0,
  0,
  0,
  135584964,
  135584964,
  135584964,
  135584964,
  135584964,
  0,
  0,
  0,
  0,
  0,
  0,
  135584964,
  135584964,
  135584964,
  135584964,
  135584964,
  0,
  0,
  0,
  0,
  0,
  0,
  135584964,
  135584964,
  135584964,
  135584964,
  135584964,
  0,
  0,
  0,
  0,
  0,
  0,
  135584964,
  135584964,
  135584964,
  135584964,
  135584964,
  0,
  0,
  0,
  0,
  0,
  0,
  135584964,
  135584964,
  135584964,
  135584964,
  135584964,
  0,
  0,
  0,
  0,
  0,
  0,
  135584964,
  135584964,
  135584964,
  135584964,
  135584964,
  0,
  0,
  0,
  0,
  0,
  0,
  135584964,
  135584964,
  135584964,
  135584964,
  135584964,
  0,
  0,
  0,
  0,
  0,
  0,
  135584964,
  135584964,
  135584964,
  135584964,
  135584964,
  0,
  0,
  0,
  0,
  0,
  0,
  135584964,
  135584964,
  135584964,
  135584964,
  135584964,
  0,
  0,
  0,
  0,
  0,
  0,
  135584964,
  135584964,
  135584964,
  135584964,
  135584964,
  0,
  0,
  0,
  0,
  0,
  0,
  135584964,
  135584964,
  135584964,
  135584964,
  135584964,
  0,
  0,
  0,
  0,
  0,
  0,
  135584964,
  135584964,
  135584964,
  135584964,
  135584964,
  0,
  0,
  0,
  0,
  0,
  0,
  135584964,
  135584964,
  135584964,
  135584964,
  135584964,
  0,
  0,
  0,
  0,
  0,
  0,
  135584964,
  135584964,
  135584964,
  135584964,
  135584964,
  0,
  0,
  0,
  0,
  0,
  0,
  135584964,
  135584964,
  135584964,
  135584964,
  135584964,
  0,
  0,
  0,
  0,
  0,
  0,
  135584964,
  135584964,
  135584964,
  135584964,
  135584964,
  0,
  0,
  0,
  0,
  0,
  0,
  135584964,
  135584964,
  135584964,
  135584964,
  135584964,
  0,
  0,
  0,
  0,
  0,
  0,
  135584964,
  135584964,
  135584964,
  135584964,
  135584964,
  0,
  0,
  0,
  0,
  0,
  0,
  135584964,
  135584964,
  135584964,
  135584964,
  135584964,
  0,
  0,
  0,
  0,
  0,
  0,
  135584964,
  135584964,
  135584964,
  135584964,
  135584964,
  0,
  0,
  0,
  0,
  0,
  0,
  135584964,
  135584964,
  135584964,
  135584964,
  135584964,
  0,
  0,
  0,
  0,
  0,
  0,
  135584964,
  135584964,
  135584964,
  135584964,
  135584964,
  0,
  0,
  0,
  0,
  0,
  0,
  135584964,
  135584964,
  135584964,
  135584964,
  135584964,
  0,
  0,
  0,
  0,
  0,
  0,
  135584964,
  135584964,
  135584964,
  135584964,
  135584964,
  0,
  0,
  0,
  0,
  0,
  0,
  135584964,
  135584964,
  135584964,
  135584964,
  135584964,
  0,
  0,
  0,
  0,
  0,
  0,
  135584964,
  135584964,
  135584964,
  135584964,
  135584964,
  0,
  0,
  0,
  0,
  0,
  0,
  135584964,
  135584964,
  135584964,
  135584964,
  135584964,
  0,
  0,
  0,
  0,
  0,
  0,
  135584964,
  135584964,
  135584964,
  135584964,
  135584964,
  0,
  0,
  0,
  0,
  0,
  0,
  135584964,
  135584964,
  135584964,
  135584964,
  135584964,
  0,
  0,
  0,
  0,
  0,
  0,
  135584964,
  135584964,
  135584964,
  135584964,
  135584964,
  0,
  0,
  0,
  0,
  0,
  0,
  135584964,
  135584964,
  135584964,
  135584964,
  135584964,
  0,
  0,
  0,
  0,
  0,
  0,
  135584964,
  135584964,
  135584964,
  135584964,
  135584964,
  0,
  0,
  0,
  0,
  0,
  0,
  135584964,
  135584964,
  135584964,
  135584964,
  135584964,
  0,
  0,
  0,
  0,
  0,
  0,
  135584964,
  135584964,
  135584964,
  135584964,
  135584964,
  0,
  0,
  0,
  0,
  0,
  0,
  135584964,
  135584964,
  135584964,
  135584964,
  135584964,
  0,
  0,
  0,
  0,
  0,
  0,
  135584964,
  135584964,
  135584964,
  135584964,
  135584964,
  0,
  0,
  0,
  0,
  0,
  0,
  135584964,
  135584964,
  135584964,
  135584964,
  135584964,
  0,
  0,
  0,
  0,
  0,
  0,
  135584964,
  135584964,
  135584964,
  135584964,
  135584964,
  0,
  0,
  0,
  0,
  0,
  0,
  135584964,
  135584964,
  135584964,
  135584964,
  135584964,
  0,
  0,
  0,
  0,
  0,
  0,
  135584964,
  135584964,
  135584964,
  135584964,
  135584964,
  0,
  0,
  0,
  0,
  0,
  0,
  135584964,
  135584964,
  135584964,
  135584964,
  135584964,
  0,
  0,
  0,
  0,
  0,
  0,
  135584964,
  135584964,
  135584964,
  135584964,
  135584964,
  0,
  0,
  0,
  0,
  0,
  0,
  135584964,
  135584964,
  135584964,
  135584964,
  135584964,
  0,
  0,
  0,
  0,
  0,
  0,
  135584964,
  135584964,
  135584964,
  135584964,
  135584964,
  0,
  0,
  0,
  0,
  0,
  135584965,
  135584983,
  135585003,
  0,
  135585023,
  135585041,
  10,
  3,
  0,
  0,
  0,
  135585054,
  135585072,
  135585092,
  0,
  135585112,
  135585130,
  50,
  3,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0
}; // weak
_UNKNOWN unk_81662E0; // weak
_UNKNOWN unk_8166360; // weak
_UNKNOWN unk_81663E0; // weak
_UNKNOWN unk_81664C0; // weak
int (__cdecl *funcs_80DDC6A[2])(void *s, int, int, int, int, int, int) = { &sub_80F15AA, &sub_80F166C }; // weak
int dword_8166528[] = { 0 }; // weak
char *off_8166540[15] =
{
  "bullet",
  "grenade",
  "projectile",
  "binoculars",
  "none",
  "primary",
  "primaryb",
  "grenade",
  "rocket",
  "none",
  "none",
  "crosshair",
  "FG42",
  "Springfield",
  "binoculars"
}; // weak
char *off_8166550 = "none"; // idb
char *off_816655C[8] =
{
  "grenade",
  "rocket",
  "none",
  "none",
  "crosshair",
  "FG42",
  "Springfield",
  "binoculars"
}; // weak
char *off_8166568[5] = { "none", "crosshair", "FG42", "Springfield", "binoculars" }; // weak
char *off_8166580[17] =
{
  "rifle",
  "mg",
  "smg",
  "spread",
  "pistol",
  "grenade",
  "rocketlauncher",
  "turret",
  "non-player",
  "item",
  "stand",
  "duck",
  "prone",
  "None",
  "Frag Grenade",
  "Smoke Grenade",
  "displayName"
}; // weak
char *off_81665A8[7] =
{
  "stand",
  "duck",
  "prone",
  "None",
  "Frag Grenade",
  "Smoke Grenade",
  "displayName"
}; // weak
char *off_81665B4[4] = { "None", "Frag Grenade", "Smoke Grenade", "displayName" }; // weak
char *off_81665C0 = "displayName"; // weak
char *off_81676E8[2] = { "aivsai", "aivsplayer" }; // weak
float flt_81676F4[3] = { 40.0, 40.0, 52.0 }; // weak
_DWORD dword_8167700[3] = { -1049624576, -1049624576, 0 }; // weak
_DWORD dword_816770C[3] = { 1097859072, 1097859072, 1116471296 }; // weak
char *off_8167718 = "GAME_GC_HOLDYOURPOSITION"; // idb
char *off_8167740 = "none"; // idb
_UNKNOWN unk_816778C; // weak
_UNKNOWN unk_816779F; // weak
char *off_81677C0 = "MOD_UNKNOWN"; // idb
char *off_8167800[9] =
{
  "default",
  "bigfixed",
  "smallfixed",
  "left",
  "center",
  "right",
  "top",
  "middle",
  "bottom"
}; // weak
char *off_816780C[6] = { "left", "center", "right", "top", "middle", "bottom" }; // weak
char *off_8167818[3] = { "top", "middle", "bottom" }; // weak
char *off_8167840[16] =
{
  "subleft",
  "left",
  "center",
  "right",
  "fullscreen",
  "noscale",
  "alignto640",
  "center_safearea",
  "subtop",
  "top",
  "middle",
  "bottom",
  "fullscreen",
  "noscale",
  "alignto480",
  "center_safearea"
}; // weak
char *off_8167860[8] =
{
  "subtop",
  "top",
  "middle",
  "bottom",
  "fullscreen",
  "noscale",
  "alignto480",
  "center_safearea"
}; // weak
int dword_8167880[] = { 0 }; // weak
int dword_8167884[] = { 0 }; // weak
int dword_8167888[] = { 0 }; // weak
int dword_816788C[] = { 0 }; // weak
int dword_8167890[] = { 0 }; // weak
int dword_8167894[] = { 0 }; // weak
int dword_8167898[] = { 0 }; // weak
int dword_816789C[] = { 0 }; // weak
int dword_81678A0[] = { 0 }; // weak
int dword_81678A4[191] =
{
  0,
  0,
  0,
  0,
  135373278,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  135374338,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  135374076,
  135374338,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  135375058,
  135375106,
  135375172,
  0,
  0,
  0,
  0,
  135357856,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  135357856,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  135312600,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  3,
  4,
  135312600,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  5,
  6,
  0,
  0,
  0,
  0,
  0,
  0,
  135262922,
  135220038,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  135262922,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  135220038,
  0,
  0,
  135242972,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  135305832,
  0,
  0,
  0,
  135307078,
  0,
  0,
  135306358,
  0,
  0,
  135305686,
  0,
  0,
  0,
  135307078,
  0,
  0,
  135306358,
  0,
  0,
  135281824,
  0,
  0,
  135280624,
  0,
  0,
  0,
  0,
  0,
  0,
  135284224,
  0,
  0,
  135280624,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  135280624,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  135322034,
  0,
  0,
  0,
  0,
  0,
  135383488,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0
}; // weak
char off_8167BA0[] = { '\xE0', '=', '\x15', '\b' }; // idb
char *off_8167BC0 = "print"; // weak
int (*off_8167BC4)() = &sub_810E18C; // weak
int dword_8167BC8[] = { 1 }; // weak
char *off_8168280 = "attach"; // weak
int (__cdecl *off_8168284)(int) = &ScrCmd_attach; // weak
int dword_8168288[] = { 0 }; // weak
char *off_8168560 = "info_null"; // weak
char byte_8168610 = '\x01'; // weak
void *off_8168614 = &unk_89A2D00; // weak
void *off_8168618 = &unk_89A9E00; // weak
void *off_816861C = &unk_89ABA80; // weak
int off_8168620 = 144401376; // idb
char *off_8168640 = "english"; // weak
int g_languages[] = { 0 }; // weak
_UNKNOWN unk_81686B0; // weak
int (*off_8185784)() = &ctor_003; // weak
int dword_8185794 = 0; // weak
Elf32_Dyn *off_8185798 = &stru_8185688; // weak
FILE *stdout; // idb
FILE *stderr; // idb
int _ctype_b; // weak
int stdin; // weak
char byte_8185A6C; // weak
_UNKNOWN unk_8185A70; // weak
int dword_8185AA0; // weak
int dword_8185AA4; // idb
char *dword_8185AC0; // idb
void *comBspGlob; // idb
size_t dword_8185BCC; // idb
int dword_8185BD0; // weak
char *dest; // idb
int dword_8185BE4; // weak
int dword_8185BE8; // weak
int dword_8185BEC; // weak
void *dword_8185BF0; // idb
int dword_8185BF4; // weak
int dword_8185BF8; // weak
int dword_8185BFC; // weak
int dword_8185C00; // weak
int dword_8185C04; // weak
int dword_8185C08; // weak
int dword_8185C0C; // weak
void *dword_8185C10; // idb
int dword_8185C14; // weak
int dword_8185C18; // weak
int dword_8185C1C; // weak
int dword_8185C20; // weak
int dword_8185C24; // weak
int dword_8185C28; // weak
int dword_8185C2C; // weak
int dword_8185C30; // weak
int dword_8185C34; // weak
int dword_8185C38; // weak
int dword_8185C3C; // weak
int dword_8185C40; // weak
int dword_8185C44; // weak
int dword_8185C48; // weak
int dword_8185C4C; // weak
int dword_8185C50; // weak
int dword_8185C54; // weak
int dword_8185C58; // weak
__int16 word_8185C5C; // weak
int dword_8185C60; // weak
int dword_8185C64; // weak
size_t n; // idb
void *dword_8185C6C; // idb
int dword_8185C70; // weak
int dword_8185C74; // weak
void *dword_8185C78; // idb
int dword_8185C7C; // weak
_UNKNOWN unk_8185C80; // weak
int dword_8185CA0; // weak
int dword_8185CA4; // weak
_DWORD dword_8185CA8[3]; // weak
_DWORD dword_8185CB4[3]; // weak
int dword_8185CC0; // weak
int dword_8185CEC; // weak
int cme; // weak
int dword_8185CF8; // weak
int dword_8185CFC; // weak
void *dword_8185D00; // idb
int dword_8185D0C; // weak
int dword_8185D10; // weak
float flt_8185D14; // weak
float flt_8185D80[3]; // weak
float flt_8185D8C[3]; // weak
char byte_8185D98; // weak
__int16 word_8185D9A; // weak
int dword_8185D9C[]; // weak
int dword_8185DA0[]; // weak
_UNKNOWN unk_8185DA4; // weak
_UNKNOWN unk_8185DA6; // weak
_UNKNOWN unk_8185DA8; // weak
_UNKNOWN unk_8185DAC; // weak
__int16 word_8185DAE[]; // weak
char algn_8185DB0[16]; // weak
float flt_8185DC0; // weak
__int16 word_8185DC4; // weak
__int16 word_818BD96; // weak
int dword_818BE00; // weak
int dword_818BE04[]; // weak
int dword_818BE08[]; // weak
int dword_818BE0C[]; // weak
_UNKNOWN unk_818BE80; // weak
int dword_819BE80; // weak
char *dword_819BF00; // idb
char byte_819C700[8704]; // weak
int dword_819E900; // weak
char byte_819E980; // idb
int com_errorType; // weak
int logfile; // weak
int com_viewlog; // weak
int com_developer; // weak
int com_developer_script; // weak
int com_timescale; // weak
float flt_819EF08; // weak
int com_fixedtime; // weak
int com_maxfps; // weak
int com_sv_running; // weak
int com_logfile; // weak
int version; // idb
int shortversion; // weak
int com_introPlayed; // weak
int cl_paused; // weak
int nextmap; // idb
int com_expectedHunkUsage; // weak
int sv_paused; // weak
int com_animCheck; // weak
int com_frameTime; // weak
int com_lastFrameTime; // weak
int com_codeTimeScale; // weak
int com_frameNumber; // weak
int com_errorEntered; // weak
int com_fixedConsolePosition; // weak
int com_fullyInitialized; // weak
char com_errorMessage[4095]; // idb
char byte_819FF7F; // weak
int ui_errorMessage; // idb
int ui_errorTitle; // weak
int dword_819FF88; // weak
int dword_819FF8C; // weak
int dword_81A0000[]; // weak
int dword_81A0004[]; // weak
int dword_81A0008[]; // weak
int dword_81A000C[]; // weak
int dword_81A0010[]; // weak
int dword_81A0014[1821]; // weak
int dword_81A1C88; // weak
int dword_81A1C90; // weak
char *dword_81A1C94; // idb
int dword_81A1C98; // idb
int (__cdecl *dword_81A1C9C)(_DWORD); // weak
int dword_81A1CA0; // weak
int currentTime; // weak
int errorCount; // weak
int dword_81A1CB0; // weak
char *dword_81A1CC0; // idb
int dword_81A1D40; // weak
_UNKNOWN unk_81D3D80; // weak
int dword_81D4580; // weak
__int16 word_81D4600[1152]; // weak
__int16 word_81D4F00[1024]; // weak
int dword_81D5700; // weak
int dword_81D5704; // weak
char byte_81D5780; // idb
char byte_81D5B80; // idb
char byte_81D7D00; // idb
char byte_81D9D00; // idb
char byte_81DBD00; // idb
char byte_81DDD00; // idb
char byte_81DFD00; // idb
char byte_81DFD01[]; // weak
char byte_81DFD02[16382]; // weak
char byte_81E3D00; // idb
_UNKNOWN unk_81E5D00; // weak
_UNKNOWN unk_81E6100; // weak
int dword_81E6144; // weak
char msgHuff[28700]; // weak
_DWORD dword_81ED87C[2]; // weak
int dword_81ED884; // weak
int msgInit; // weak
_UNKNOWN unk_81F48A0; // weak
char byte_81F4C9F; // weak
_UNKNOWN unk_81F4CA0; // weak
char byte_81F6C9F; // weak
_UNKNOWN unk_81F6CA0; // weak
char byte_81F709F; // weak
int showpackets; // weak
int showdrop; // weak
int packetDebug; // weak
int net_profile; // weak
int net_showprofile; // weak
int net_lanauthorize; // weak
int dword_81F7118; // weak
int dword_81F711C; // weak
_UNKNOWN unk_81F7180; // weak
char byte_82021A0[64]; // idb
_UNKNOWN unk_82021E0; // weak
int dword_8202218; // weak
int dword_8202220; // weak
int dword_8202224; // weak
__int16 word_8202228[256]; // weak
int dword_8202428; // weak
int dword_8202440; // weak
int dword_8202444; // idb
int dword_8202448; // weak
int dword_820244C[128]; // weak
int dword_820264C[128]; // weak
int dword_820284C[]; // weak
int dword_8202850; // weak
int dword_8202854; // weak
char byte_8202858; // weak
int dword_8202860; // weak
int dword_8202864; // weak
int dword_8202868; // weak
int dword_820286C; // weak
int dword_8202870; // weak
int dword_8202874; // weak
int dword_8202878; // weak
char byte_820287C; // weak
char byte_820287D; // weak
int dword_8202880; // idb
char byte_8202884; // weak
char byte_8202885; // weak
char byte_8202886; // weak
int dword_8202888; // weak
char byte_820288C; // weak
char byte_820288D; // weak
int dword_8202890; // weak
char byte_8202894; // weak
char byte_8202895; // weak
int dword_8202898; // weak
int dword_820289C; // weak
int dword_82028A0; // weak
int dword_82028A4; // weak
int dword_82028A8; // weak
int dword_82028AC; // weak
char byte_82028B0; // weak
int dword_82028B4; // weak
int dword_82028B8; // weak
int dword_82028BC[]; // weak
int dword_82028C0[]; // weak
int dword_82028C4[]; // weak
int dword_8202A40; // weak
int dword_8202A44; // weak
int dword_8202A48; // weak
int dword_8202A4C; // weak
int dword_8202A50; // weak
int dword_8202A54; // weak
int dword_8202A58; // weak
int dword_8202A5C; // weak
int dword_8202A60; // weak
char byte_8202A64; // weak
char byte_8202A65; // weak
int dword_8202A68; // weak
int dword_8202A6C; // weak
int dword_8202A70; // weak
int dword_8202A74; // weak
int dword_8202A78[1058]; // weak
int dword_8203B00[]; // weak
int dword_8203B04[131071]; // weak
_BYTE byte_8283B00[512]; // weak
char byte_8283D00[]; // weak
__int16 word_8283E00[18]; // weak
int dword_8283E24; // weak
char dword_8283E28[]; // idb
int dword_8283E80; // weak
void *dword_8283EA0; // idb
int dword_8283EA4; // weak
int dword_8283EA8; // weak
void *dword_8283EAC; // idb
int dword_8283EB0; // weak
int dword_8283EB4; // weak
int dword_8283EB8; // weak
int dword_8283EBC; // weak
int dword_8283EC0; // weak
void *dword_8283EC4; // idb
int dword_8283EC8; // weak
int dword_8283ECC; // weak
int dword_8283ED0; // weak
void *dword_8283ED4; // idb
int dword_8283ED8; // weak
char dword_8283EDC[]; // idb
char dword_8283EE0[]; // idb
__int16 word_8283F00[]; // weak
__int16 word_8283F02[32767]; // weak
char byte_8293F00; // weak
int dword_8293F04; // weak
int dword_8293F84; // weak
__int16 word_8294000[]; // weak
__int16 word_8294002[]; // weak
int dword_8294004[]; // weak
int dword_8294008[]; // weak
__int16 word_829400C[]; // weak
__int16 word_829400E[524281]; // weak
int dword_8394000; // weak
int dword_8394004; // weak
__int16 word_8394008; // weak
char byte_839400A; // weak
char byte_839400B; // weak
char byte_839400C; // weak
char dword_8394010[]; // idb
int dword_8394014; // weak
int dword_8394018; // weak
int dword_839401C; // weak
int dword_8394020; // weak
int dword_8394024; // weak
int dword_8394028; // weak
int dword_839402C; // weak
int dword_8394030; // weak
int dword_8394034; // weak
char byte_8394038; // weak
int dword_839403C; // weak
int dword_8394040; // weak
int dword_8394044; // weak
int dword_8394048; // weak
int dword_839404C; // weak
_UNKNOWN unk_83D4100; // weak
int dword_83D553C; // weak
int dword_83D5580; // weak
int dword_83D5584; // weak
int dword_83D5590; // weak
int dword_83D5594; // weak
int dword_83D5598; // weak
int dword_83D7600; // weak
int dword_83D7604; // weak
int dword_83D7608; // weak
int dword_83D760C; // weak
int dword_83D7610; // weak
char byte_83D7614; // weak
char byte_83D7615; // weak
char byte_83D7616; // weak
int dword_83D7618; // weak
int dword_83D761C; // weak
int dword_83D7620[]; // weak
int dword_83D7624[]; // weak
int dword_83D7628[190]; // weak
_UNKNOWN unk_83D7920; // weak
int dword_83D7924; // weak
_UNKNOWN unk_83DB918; // weak
int dword_83DB9A0; // idb
int dword_83DB9A4; // weak
int dword_83DB9A8; // weak
FILE *stream; // idb
FILE *dword_83DB9B0; // idb
int dword_83DB9B4; // weak
int dword_83DB9B8; // weak
int dword_83DB9BC; // idb
char byte_83DB9C0; // weak
int dword_83DB9C4; // weak
char byte_83DB9C8; // weak
int dword_83DB9CC; // weak
int dword_83DB9D0; // weak
int dword_83DB9D4; // weak
int dword_83DB9D8; // weak
_UNKNOWN unk_83DB9E0; // weak
int dword_83DF9E8; // weak
int dword_83DF9EC; // weak
int gameInitialized; // weak
_UNKNOWN unk_83DFA8F; // weak
int dword_841FA80; // weak
int dword_841FA84; // weak
int dword_841FA88; // weak
int dword_841FB00; // weak
int dword_841FB04; // idb
int dword_841FB08; // weak
void *dword_841FB0C; // idb
int dword_841FB10; // weak
int dword_841FB14; // weak
int dword_841FB18; // weak
int dword_841FB1C; // weak
int dword_841FB20; // weak
int dword_841FB24; // weak
int dword_841FB28; // weak
int dword_841FB2C; // weak
void *dword_841FB30; // idb
void *dword_841FB34; // idb
int dword_841FB38; // weak
int dword_841FB3C; // weak
int dword_841FB40; // weak
int dword_841FB44; // weak
void *dword_841FB48; // idb
void *dword_841FB4C; // idb
void *dword_841FB50; // idb
int dword_841FB54; // weak
int dword_841FB58; // weak
int dword_841FB5C[]; // weak
int dword_841FB60[]; // weak
int dword_841FB64[]; // weak
int dword_841FB68[]; // weak
int dword_841FB6C[]; // weak
int dword_841FB70[]; // weak
int dword_841FB78[]; // weak
int dword_841FB80[]; // weak
int dword_841FB84[]; // weak
int dword_841FB88[1343]; // weak
_UNKNOWN unk_8421085; // weak
int dword_842BB5C; // idb
int dword_842BB60; // idb
__int16 dword_842BB64; // idb
int dword_842BB68; // idb
int dword_842BB6C; // idb
int dword_842BB70; // idb
int dword_842BB74; // idb
__int16 dword_842BB78; // idb
int dword_842BB7C; // idb
int dword_842BB80; // idb
int dword_842BB84; // weak
int dword_842BB88[]; // weak
int dword_842BB8C[61]; // weak
int dword_842BC80; // weak
int dword_842BC84; // weak
int dword_842BC88; // weak
int dword_842BC8C; // weak
int dword_842BC90; // weak
char *dword_842C098; // idb
_UNKNOWN unk_842DF24; // weak
_UNKNOWN unk_842DF26; // weak
_UNKNOWN unk_842E084; // weak
_UNKNOWN unk_842E09C; // weak
int dword_842E18C[]; // weak
int dword_842E190[]; // weak
int dword_842E194[95169]; // weak
int dword_848B098; // weak
int dword_848B09C; // weak
int dword_848B0A0; // weak
int dword_848B0A4; // weak
int dword_848B0A8; // weak
int dword_848B0AC; // weak
int dword_848B0B0; // weak
int dword_848B0B4; // weak
int dword_848B0B8[]; // weak
int dword_848B0BC[18]; // weak
int dword_848B104; // weak
int dword_848B108; // weak
int dword_848B10C; // weak
int dword_848B110; // weak
int dword_848B114[]; // weak
int dword_848B118[18]; // weak
int dword_848B160; // weak
int dword_848B164; // weak
int dword_848B168; // weak
float flt_848B16C; // weak
int dword_848B170; // weak
char byte_848B174[64]; // idb
int sv_fps; // weak
int sv_timeout; // weak
int sv_zombietime; // weak
int rcon_password; // weak
int sv_privatePassword; // weak
int sv_allowDownload; // weak
int sv_maxclients; // weak
int sv_privateClients; // weak
int sv_hostname; // weak
int sv_reconnectlimit; // weak
int sv_padPackets; // weak
int mapname; // weak
int sv_serverid; // weak
int sv_maxRate; // weak
int sv_minPing; // weak
int sv_maxPing; // weak
int g_gametype; // idb
int sv_debugRate; // weak
int sv_debugReliableCmds; // weak
int sv_pure; // weak
int sv_floodProtect; // weak
int sv_cheats; // weak
int sv_allowAnonymous; // weak
int sv_showCommands; // weak
int sv_packet_info; // weak
int sv_showAverageBPS; // weak
int sv_mapRotation; // weak
int sv_mapRotationCurrent; // idb
int sv_kickBanTime; // weak
int sv_disableClientConsole; // weak
int sv_voice; // weak
int sv_voiceQuality; // weak
int sv_iwds; // idb
int sv_iwdNames; // idb
int sv_referencedIwds; // idb
int sv_referencedIwdNames; // idb
int sv_allowedClan1; // weak
int sv_allowedClan2; // weak
_BYTE byte_848B260[1024]; // weak
int dword_848B660; // weak
char byte_848B664; // weak
char byte_848B665; // weak
char byte_848B666; // weak
char byte_848B667; // weak
__int16 word_848B668; // weak
int dword_848B674; // weak
char byte_848B67C; // weak
int dword_848B6A0; // weak
int fs_loadStack; // weak
char byte_848B6C0[256]; // idb
int fs_debug; // weak
int fs_homepath; // weak
int fs_basepath; // idb
int fs_basegame; // weak
int fs_useOldAssets; // weak
int fs_cdpath; // weak
int fs_copyfiles; // weak
int fs_gameDirVar; // idb
int fs_restrict; // weak
int fs_ignoreLocalized; // weak
void *fs_searchpaths; // idb
char fs_packFiles[]; // idb
char dword_848B7F0[]; // idb
int fs_checksumFeed; // weak
int dword_848B800[]; // weak
int dword_848B804[]; // weak
int dword_848B808[]; // weak
int dword_848B80C[]; // weak
int dword_848B810[]; // weak
int dword_848B814[]; // weak
int dword_848B818[4538]; // weak
int fs_numServerIwds; // weak
int dword_848FF20[1024]; // weak
void *dword_8490F20; // idb
int dword_8491F20; // weak
int dword_8491F40[1024]; // weak
char *dword_8492F40; // idb
char lastValidBase; // idb
char lastValidGame; // idb
_UNKNOWN unk_8494136; // weak
char byte_8494140[128]; // weak
int dword_84941C0; // weak
int com_dedicated; // weak
int com_fileDataHashTable[1024]; // weak
int com_hunkData; // weak
int g_largeLocalPos; // weak
_UNKNOWN unk_8495280; // weak
char dword_8515284[]; // idb
char dword_8515288[]; // idb
char dword_851528C[]; // idb
char dword_8515290[]; // idb
int dword_8515294; // weak
void *dword_8515298; // idb
size_t s_hunkTotal; // idb
int dword_85152C4; // weak
int dword_85152C8[1025]; // weak
int dword_85162CC[]; // weak
int dword_85162D0[]; // weak
int dword_85162D8; // weak
int dword_85162DC; // weak
int dword_85162E0; // weak
int dword_85162E4; // weak
int dword_85162E8; // weak
int dword_85162EC; // weak
int dword_85162F0; // weak
int dword_85162F4; // weak
int dword_8516300; // weak
int dword_8516304; // weak
int dword_8516308; // weak
int dword_851630C; // weak
char byte_8516350; // weak
_DWORD dword_8516354[547]; // weak
int dword_8516BE0; // weak
int dword_8516BE4; // weak
_UNKNOWN unk_8516BE8; // weak
float dword_8516C28[528]; // weak
char byte_8517468; // weak
char byte_8517469; // weak
char byte_8517480[1056]; // idb
int sortedDvars; // weak
int dvar_cheats; // weak
int dvar_modifiedFlags; // weak
_UNKNOWN unk_85178C0; // weak
char dword_8522CC0[]; // idb
int dword_8522CE0[256]; // weak
_UNKNOWN unk_85230E0; // weak
int dword_8523110; // weak
char isDvarSystemActive; // weak
char isLoadingAutoExecGlobalFlag; // weak
int loc_language; // weak
int loc_forceEnglish; // weak
int loc_translate; // weak
int loc_warnings; // weak
int loc_warningsAsErrors; // weak
_UNKNOWN unk_8523A1C; // weak
_UNKNOWN unk_8523A40; // weak
int (__cdecl *dword_8527A40)(_DWORD); // weak
int (__cdecl *dword_8527A44)(_DWORD); // weak
int (__cdecl *dword_8527A48)(_DWORD); // weak
int (__cdecl *dword_8527A4C)(_DWORD); // weak
int (__cdecl *dword_8527A50)(_DWORD, _DWORD); // weak
int (__cdecl *dword_8527A54)(_DWORD); // weak
int (__cdecl *dword_8527A58)(_DWORD); // weak
int dword_8527A5C; // weak
int dword_8527A68; // weak
_UNKNOWN unk_8527A80; // weak
__int16 word_8527A88[]; // weak
__int16 word_8527A8A[]; // weak
int dword_8527A8C[]; // weak
int dword_8527A90[]; // weak
__int16 word_8527A94; // weak
__int16 word_8527A96[]; // weak
_UNKNOWN unk_8527A98; // weak
int dword_8527A9C[]; // weak
int dword_8527AA0[]; // weak
int dword_8527AA4[40951]; // weak
int g_end; // idb
_UNKNOWN unk_854FAA0; // weak
_DWORD dword_854FAAC[381]; // weak
int dword_85500A0; // weak
char g_anim_developer; // weak
_WORD word_85500C0[2]; // weak
_DWORD dword_85500C4[2]; // weak
_UNKNOWN unk_85500CC; // weak
_DWORD dword_8550130[5]; // weak
_DWORD dword_8550144[10]; // weak
char byte_855016C; // weak
__int16 word_855016E; // weak
char byte_8550180[]; // weak
float flt_8550184[16]; // weak
int saved_euid; // weak
int ttycon; // weak
int dword_85501CC; // weak
int dword_85501D0; // weak
int dword_85501D4; // weak
int dword_85501D8; // weak
struct termios termios_p; // idb
int dword_8550220; // weak
_UNKNOWN unk_8550228; // weak
char byte_8550238; // idb
_DWORD dword_8550340[2240]; // weak
int dword_8552640; // weak
int arch; // weak
int dword_8552648; // weak
char buf[256]; // idb
int dword_8552760[]; // weak
int dword_8552764[]; // weak
int dword_8552768[]; // weak
int dword_855276C[]; // weak
int dword_8552770[]; // weak
int dword_8552774[]; // weak
int dword_8553F60; // weak
int dword_8553F64; // weak
_UNKNOWN unk_8553F80; // weak
int net_noudp; // weak
int fd; // idb
int dword_8557F9C; // weak
int dword_8557FA0; // weak
char byte_8557FC0[]; // weak
char byte_8557FC1[]; // weak
char byte_8557FC2[]; // weak
char byte_8557FC3[8317]; // weak
char byte_855A040[64]; // idb
char byte_855A080[256]; // idb
char byte_855A180; // idb
char path; // idb
int dword_855A380; // weak
int dword_855A384; // weak
char byte_855A3A0[255]; // idb
char byte_855A49F; // weak
int dword_855A4A0[5]; // weak
int dword_855A4B4; // weak
int snd_errorOnMissing; // weak
void *dword_855A4E0; // idb
int dword_855A4E4; // weak
int dword_855A500[]; // weak
_UNKNOWN unk_855A540; // weak
int dword_855CC50; // weak
int dword_855CC60[]; // weak
int dword_855CC64[287]; // weak
int dword_855D0E0[]; // weak
int dword_855D0E4[287]; // weak
int dword_855D560; // weak
int dword_855D564; // weak
int dword_855D568; // weak
int dword_855D56C; // weak
_UNKNOWN unk_855D580; // weak
int dword_8575C20; // weak
int dword_8575C40[]; // weak
int dword_8575C44[255]; // weak
int jump_height; // weak
int jump_stepSize; // weak
int jump_slowdownEnable; // weak
int jump_ladderPushVel; // weak
int jump_spreadAdd; // weak
int mantle_enable; // weak
int mantle_debug; // weak
int mantle_check_range; // weak
int mantle_check_radius; // weak
int mantle_check_angle; // weak
int mantle_view_yawcap; // weak
int dword_857606C; // idb
int player_view_pitch_up; // weak
int player_view_pitch_down; // weak
int bg_ladder_yawcap; // weak
int bg_prone_yawcap; // weak
int bg_foliagesnd_minspeed; // weak
int bg_foliagesnd_maxspeed; // weak
int bg_foliagesnd_slowinterval; // weak
int bg_foliagesnd_fastinterval; // weak
int bg_foliagesnd_resetinterval; // weak
int bg_fallDamageMinHeight; // weak
int bg_fallDamageMaxHeight; // weak
int inertiaMax; // weak
int inertiaDebug; // weak
int inertiaAngle; // weak
int stopspeed; // weak
int friction; // weak
int bg_swingSpeed; // weak
int bg_bobAmplitudeStanding; // weak
int bg_bobAmplitudeDucked; // weak
int bg_bobAmplitudeProne; // weak
int bg_bobMax; // weak
int bg_aimSpreadMoveSpeedThreshold; // weak
int player_breath_hold_time; // weak
int player_breath_gasp_time; // weak
int player_breath_fire_delay; // weak
int player_breath_gasp_scale; // weak
int player_breath_hold_lerp; // weak
int player_breath_gasp_lerp; // weak
int player_breath_snd_lerp; // weak
int player_breath_snd_delay; // weak
int player_toggleBinoculars; // weak
int player_scopeExitOnDamage; // weak
int player_adsExitDelay; // weak
int player_moveThreshhold; // weak
int player_footstepsThreshhold; // weak
int player_strafeSpeedScale; // weak
int player_backSpeedScale; // weak
int player_spectateSpeedScale; // weak
int player_turnAnims; // weak
int player_dmgtimer_timePerPoint; // weak
int player_dmgtimer_maxTime; // weak
int player_dmgtimer_minScale; // weak
int player_dmgtimer_stumbleTime; // weak
int player_dmgtimer_flinchTime; // weak
int dword_8576140; // weak
int dword_8576160[128]; // weak
int dword_8576360[128]; // weak
int dword_8576560; // weak
int dword_8576580[128]; // weak
int dword_8576780; // weak
int dword_85767A0[128]; // weak
int dword_85769A0; // weak
_UNKNOWN unk_85769C0; // weak
int dword_8576FC4; // idb
char *dword_8576FE0; // idb
int dword_85771F8; // weak
int dword_8577200[520]; // weak
int dword_8577A20; // weak
_UNKNOWN unk_8577A40; // weak
_UNKNOWN unk_8577B60; // weak
float dword_8577F60[18]; // weak
int dword_8577FA8; // weak
__int16 word_8577FC0[]; // weak
int dword_8578000[]; // weak
int dword_8578080[]; // weak
int dword_8578084[35807]; // weak
int dword_859B000[]; // weak
int dword_859B400; // weak
int dword_859B404; // weak
char dword_859B40C[]; // idb
int dword_859B410; // weak
int dword_859B414; // weak
int dword_859B418; // weak
int dword_859B41C; // idb
int dword_859B420; // weak
_DWORD dword_859B424[112]; // weak
int dword_859B5E4; // weak
int dword_859B5E8; // weak
int dword_859B5EC; // idb
int dword_859B5F0; // weak
int dword_859B5F4; // weak
char dword_859B5F8[]; // idb
char dword_859B600[]; // idb
char dword_859B604[]; // idb
int dword_859B60C; // weak
int dword_859B610; // weak
int dword_859B614; // weak
size_t nmemb; // idb
char dword_859B61C[]; // idb
char byte_859B71C[1024]; // idb
char byte_859BB1C[1024]; // idb
char dword_859BF1C[]; // idb
int dword_859BF20; // weak
char dword_859BF24[]; // idb
char dword_859BF28[]; // idb
int dword_859BF2C; // weak
char byte_859C748; // weak
int dword_859C74C; // weak
char *dword_859C750; // idb
char *nptr; // idb
int dword_859D154; // weak
int dword_859D158[32]; // weak
int dword_859D1D8; // weak
int dword_859D1DC; // weak
int dword_859D1E4; // weak
_UNKNOWN unk_859D1E8; // weak
int dword_859DDE8[]; // weak
int dword_859DDEC[]; // weak
int dword_859DDF0[]; // weak
int dword_859E9E8; // weak
int dword_859E9EC; // weak
int dword_859E9F0; // weak
int dword_859E9F4; // weak
int dword_859E9F8; // weak
int dword_859E9FC; // weak
int dword_859EA00; // weak
int dword_859EA04; // weak
int dword_859EA08[]; // weak
void *dword_859EA0C; // idb
int dword_859EA10[]; // weak
_UNKNOWN unk_859EA40; // weak
int dword_86525F4; // weak
int dword_8652608; // weak
int dword_865261C; // weak
int dword_8652620; // weak
int dword_8652624; // weak
int dword_8652628; // weak
int dword_865262C; // weak
int dword_8652630; // weak
int dword_8652634; // weak
int dword_8652638; // weak
_UNKNOWN unk_8652644; // weak
_UNKNOWN unk_8652668; // weak
_UNKNOWN unk_86529CC; // weak
_UNKNOWN unk_8652A1C; // weak
int dword_8652AE0[19048]; // weak
_UNKNOWN unk_8665480; // weak
int dword_8665488[]; // weak
int dword_8665548[]; // weak
float flt_86655B8[]; // weak
float flt_86655BC[]; // weak
float flt_86655C0[]; // weak
int dword_86655D8[]; // weak
__int16 word_86655E8[]; // weak
__int16 word_86655F4[]; // weak
int dword_8665614[]; // weak
_UNKNOWN unk_86656B0; // weak
int dword_86F1020; // weak
char byte_86F111C; // weak
_WORD word_86F1188[4]; // weak
int dword_86F1190; // weak
_UNKNOWN unk_86F1250; // weak
_UNKNOWN unk_86F1480; // weak
int sv_gametype; // weak
int g_password; // weak
int g_maxclients; // weak
int dedicated; // weak
int g_speed; // weak
int g_gravity; // weak
int g_cheats; // weak
int g_knockback; // weak
int g_useholdtime; // weak
int g_useholdspawndelay; // weak
int g_inactivity; // weak
int g_debugDamage; // weak
int g_debugBullets; // weak
int g_weaponAmmoPools; // weak
int g_maxDroppedWeapons; // weak
int g_motd; // weak
int g_synchronousClients; // weak
int g_playerCollisionEjectSpeed; // weak
int g_dropForwardSpeed; // weak
int g_dropUpSpeedBase; // weak
int g_dropUpSpeedRand; // weak
int g_clonePlayerMaxVelocity; // weak
int g_mantleBlockTimeBuffer; // weak
int voice_localEcho; // weak
int voice_global; // weak
int voice_deadChat; // weak
int g_voiceChatTalkingDuration; // weak
int g_log; // weak
int g_logSync; // weak
int g_allowVote; // weak
int g_deadChat; // weak
int g_listEntity; // weak
int g_banIPs; // idb
int g_smoothClients; // weak
int g_ScoresBanner_Allies; // weak
int g_ScoresBanner_Axis; // weak
int g_ScoresBanner_None; // weak
int g_ScoresBanner_Spectators; // weak
int g_TeamName_Allies; // weak
int g_TeamName_Axis; // weak
int g_TeamColor_Allies; // weak
int g_TeamColor_Axis; // weak
int g_no_script_spam; // weak
int g_debugLocDamage; // weak
int g_friendlyfireDist; // weak
int g_friendlyNameDist; // weak
int player_meleeRange; // weak
int player_meleeWidth; // weak
int player_meleeHeight; // weak
int g_antilag; // weak
int g_oldVoting; // weak
int g_voteAbstainWeight; // weak
int g_dumpAnims; // weak
int dword_8793E60[552]; // weak
_UNKNOWN unk_8794700; // weak
int dword_879C700; // weak
int dword_879C780; // weak
int dword_879C788; // weak
int dword_879C78C; // weak
int dword_879C790; // weak
int dword_879C794; // weak
int dword_879C798; // weak
int dword_879C79C; // weak
int dword_879C7A8; // weak
_UNKNOWN unk_879C7AC; // weak
int dword_879D82C; // weak
int dword_879D830; // weak
int dword_879D834; // weak
int dword_879D838[]; // weak
int dword_879D83C[2449]; // weak
int dword_879FE80[]; // weak
int dword_879FE84[2047]; // weak
int dword_87A1E80; // weak
int dword_87A1EA0[256]; // weak
__int16 word_87A22A0; // weak
__int16 word_87A22A2; // weak
__int16 word_87A22A4; // weak
__int16 word_87A22A6; // weak
__int16 word_87A22A8; // weak
__int16 word_87A22AA; // weak
__int16 word_87A22AC; // weak
__int16 word_87A22AE; // weak
__int16 word_87A22B0; // weak
__int16 word_87A22B2; // weak
__int16 word_87A22B4; // weak
__int16 word_87A22B6; // weak
__int16 word_87A22B8; // weak
__int16 word_87A22BA; // weak
__int16 word_87A22BC; // weak
__int16 word_87A22BE; // weak
__int16 word_87A22C0; // weak
__int16 word_87A22C2; // weak
__int16 word_87A22C4; // weak
__int16 word_87A22C6; // weak
__int16 word_87A22C8; // weak
__int16 word_87A22CA; // weak
__int16 word_87A22CC; // weak
__int16 word_87A22CE; // weak
__int16 word_87A22D0; // weak
__int16 word_87A22D2; // weak
__int16 word_87A22D4; // weak
__int16 word_87A22D6; // weak
__int16 word_87A22D8; // weak
__int16 word_87A22DA; // weak
__int16 word_87A22DC; // weak
__int16 word_87A22DE; // weak
__int16 word_87A22E0; // weak
__int16 word_87A22E2; // weak
__int16 word_87A22E4; // weak
__int16 word_87A22E6; // weak
__int16 word_87A22E8; // weak
__int16 word_87A22EA; // weak
__int16 word_87A22EC; // weak
__int16 word_87A22EE; // weak
__int16 word_87A22F0; // weak
__int16 word_87A22F2; // weak
__int16 word_87A22F4; // weak
__int16 word_87A22F6; // weak
__int16 word_87A22F8; // weak
__int16 word_87A22FA; // weak
__int16 word_87A22FC; // weak
__int16 word_87A22FE; // weak
__int16 word_87A2300; // weak
__int16 word_87A2302; // weak
__int16 word_87A2304; // weak
__int16 word_87A2306; // weak
__int16 word_87A2308; // weak
__int16 word_87A230A; // weak
__int16 word_87A230C; // weak
__int16 word_87A230E; // weak
__int16 word_87A2310; // weak
__int16 word_87A2312; // weak
__int16 word_87A2314; // weak
__int16 word_87A2316; // weak
__int16 word_87A2318; // weak
__int16 word_87A231A; // weak
__int16 word_87A231C; // weak
__int16 word_87A231E; // weak
__int16 word_87A2320; // weak
__int16 word_87A2322; // weak
__int16 word_87A2324; // weak
__int16 word_87A2326; // weak
__int16 word_87A2328; // weak
__int16 word_87A232A; // weak
__int16 word_87A232C; // weak
__int16 word_87A232E; // weak
__int16 word_87A2330; // weak
__int16 word_87A2332; // weak
__int16 word_87A2334; // weak
__int16 word_87A2336; // weak
__int16 word_87A2338; // weak
__int16 word_87A233A; // weak
__int16 word_87A233C; // weak
__int16 word_87A233E; // weak
__int16 word_87A2340; // weak
__int16 word_87A2342; // weak
__int16 word_87A2344; // weak
__int16 word_87A2346; // weak
__int16 word_87A2348; // weak
__int16 word_87A234A; // weak
__int16 word_87A234C; // weak
__int16 word_87A234E; // weak
__int16 word_87A2350; // weak
__int16 word_87A2352; // weak
_UNKNOWN unk_87A2380; // weak
int dword_89A2380; // weak
int dword_89A2388; // weak
_DWORD dword_89A238C[2]; // weak
_DWORD dword_89A2394[2]; // weak
_DWORD dword_89A239C[2]; // weak
_DWORD dword_89A23A4[2]; // weak
_DWORD dword_89A23AC[2]; // weak
_DWORD dword_89A23B4[2]; // weak
_DWORD dword_89A23BC[2]; // weak
_DWORD dword_89A23C4[2]; // weak
_DWORD dword_89A23CC[2]; // weak
int dword_89A23D4[3]; // weak
_DWORD dword_89A23E0[8]; // weak
int dword_89A2400[]; // weak
int dword_89A2800; // weak
_DWORD dword_89A2804[2]; // weak
int dword_89A280C[]; // weak
void *dword_89A2814; // idb
int dword_89A2818; // weak
int dword_89A2828; // weak
char byte_89A2840[]; // weak
_UNKNOWN unk_89A2841; // weak
int dword_89A2C80; // weak
int dword_89A2C84; // weak
int dword_89A2C88; // weak
int dword_89A2C8C; // weak
int dword_89A2C90; // weak
int dword_89A2C98; // weak
int dword_89A2CA0; // weak
size_t dword_89A9D80; // idb
int dword_89A9D88; // weak
int dword_89AD6A0; // weak
_UNKNOWN unk_89AD700; // weak
int dword_89B63A0; // weak
int dword_89B63A4; // weak
char dword_89B63A8[]; // idb
int dword_89B63AC; // weak
int dword_89B63B0; // weak
int dword_89B63B4; // weak
int dword_89B63B8; // weak
int dword_89B63C4; // weak
int dword_89B63C8; // weak
int dword_89B63CC; // weak
_UNKNOWN unk_89B63E0; // weak
int dword_89B64DC[]; // weak
int dword_89B64E0[]; // weak
float flt_89B64E4[3599]; // weak
size_t dword_89B9D20; // idb
int dword_89B9D40[]; // weak
float flt_89B9D44[3599]; // weak
int dword_89BD580; // weak
int g_currentAsian; // weak
char byte_89BD5C0[1024]; // idb
int dword_89BD9C0; // weak
_UNKNOWN unk_89BD9E0; // weak
int dword_89BE1E0; // weak
int dword_89BE200; // idb
char byte_89BE220[64]; // idb
char byte_89BE260[64]; // idb
char byte_89BE2A0[64]; // idb
char byte_89BE2E0[63]; // idb
char byte_89BE31F; // weak
char s[1024]; // idb
int dword_89BE720; // weak
char *ptr; // idb
int dword_89BE728; // weak
int dword_89BE72C; // weak
int dword_89BE730; // weak
int dword_89BE734; // weak
int dword_89BE738; // weak
size_t size; // idb
_WORD word_89BE740[499]; // weak
_UNKNOWN unk_89BEB26; // weak
int dword_89BEB2C; // weak
int dword_89BEB30; // weak
_UNKNOWN unk_89BEB40; // weak
int dword_89BFAE0; // weak
// extern _UNKNOWN _gmon_start__; weak


//----- (08049B90) --------------------------------------------------------
void init_proc(void)
{
  if ( &_gmon_start__ )
    __gmon_start__();
  register_frame_info();
  sub_8139B20();
}
// 804A470: using guessed type int __gmon_start__(void);

//----- (08049BC0) --------------------------------------------------------
void stop()
{
  JUMPOUT(0);
}
// 8049BC6: control flows out of bounds to 0

//----- (0804A4B0) --------------------------------------------------------
// positive sp value has been detected, the output may be wrong!
void __usercall __noreturn start(int a1@<eax>, void (*a2)(void)@<edx>)
{
  int v2; // esi
  int v3; // [esp-4h] [ebp-4h] BYREF
  char *retaddr; // [esp+0h] [ebp+0h] BYREF

  v2 = v3;
  v3 = a1;
  __libc_start_main((int (__cdecl *)(int, char **, char **))main, v2, &retaddr, init_proc, term_proc, a2, &v3);
  __halt();
}
// 804A4B3: positive sp value 4 has been found

//----- (0804A4E0) --------------------------------------------------------
void deregister_frame_info()
{
  int *v0; // eax
  void (*i)(void); // edx

  if ( !byte_8185A6C )
  {
    v0 = off_815A008;
    for ( i = (void (*)(void))*off_815A008; *off_815A008; i = (void (*)(void))*off_815A008 )
    {
      off_815A008 = v0 + 1;
      i();
      v0 = off_815A008;
    }
    if ( __deregister_frame_info_bases )
      __deregister_frame_info_bases(&unk_81686B0);
    byte_8185A6C = 1;
  }
}
// 8049E10: using guessed type int __cdecl __deregister_frame_info_bases(_DWORD);
// 815A008: using guessed type int *off_815A008;
// 8185A6C: using guessed type char byte_8185A6C;

//----- (0804A540) --------------------------------------------------------
int register_frame_info()
{
  int result; // eax

  if ( __register_frame_info_bases )
    __register_frame_info_bases(&unk_81686B0, &unk_8185A70, 0, &off_8185798);
  result = dword_8185794;
  if ( dword_8185794 )
    return 0;
  return result;
}
// 804A0B0: using guessed type int __cdecl __register_frame_info_bases(_DWORD, _DWORD, _DWORD, _DWORD);
// 8185794: using guessed type int dword_8185794;
// 8185798: using guessed type Elf32_Dyn *off_8185798;

//----- (0804A5A4) --------------------------------------------------------
_DWORD *__cdecl GetMemory(int a1)
{
  _DWORD *v3; // [esp+14h] [ebp-4h]

  v3 = Z_MallocInternal(a1 + 4);
  if ( !v3 )
    return 0;
  *v3 = 305419896;
  return v3 + 1;
}

//----- (0804A5E8) --------------------------------------------------------
_DWORD *__cdecl GetClearedMemory(size_t n)
{
  _DWORD *s; // [esp+14h] [ebp-4h]

  s = GetMemory(n);
  memset(s, 0, n);
  return s;
}

//----- (0804A61C) --------------------------------------------------------
void __cdecl FreeMemory(int a1)
{
  if ( *(_DWORD *)(a1 - 4) == 305419896 )
    Z_FreeInternal((void *)(a1 - 4));
}

//----- (0804A644) --------------------------------------------------------
void SourceError(int a1, char *format, ...)
{
  char s[1032]; // [esp+20h] [ebp-408h] BYREF
  va_list va; // [esp+438h] [ebp+10h] BYREF

  va_start(va, format);
  vsprintf(s, format, va);
  Com_Printf("^1Error: file %s, line %d: %s\n", *(const char **)(a1 + 132), *(_DWORD *)(*(_DWORD *)(a1 + 132) + 92), s);
}

//----- (0804A6AA) --------------------------------------------------------
void SourceWarning(int a1, char *format, ...)
{
  char s[1032]; // [esp+20h] [ebp-408h] BYREF
  va_list va; // [esp+438h] [ebp+10h] BYREF

  va_start(va, format);
  vsprintf(s, format, va);
  Com_Printf(
    "^3Warning: file %s, line %d: %s\n",
    *(const char **)(a1 + 132),
    *(_DWORD *)(*(_DWORD *)(a1 + 132) + 92),
    s);
}

//----- (0804A710) --------------------------------------------------------
_DWORD *__cdecl PC_PushIndent(_DWORD *a1, int a2, int a3)
{
  _DWORD *result; // eax

  result = GetMemory(16);
  *result = a2;
  result[2] = a1[33];
  result[1] = a3 != 0;
  a1[38] += result[1];
  result[3] = a1[37];
  a1[37] = result;
  return result;
}

//----- (0804A782) --------------------------------------------------------
void __cdecl PC_PopIndent(_DWORD *a1, _DWORD *a2, _DWORD *a3)
{
  _DWORD *v3; // [esp+10h] [ebp-8h]

  *a2 = 0;
  *a3 = 0;
  v3 = (_DWORD *)a1[37];
  if ( v3 )
  {
    if ( *(_DWORD *)(a1[37] + 8) == a1[33] )
    {
      *a2 = *v3;
      *a3 = v3[1];
      a1[37] = *(_DWORD *)(a1[37] + 12);
      a1[38] -= v3[1];
      FreeMemory((int)v3);
    }
  }
}

//----- (0804A81E) --------------------------------------------------------
void __cdecl PC_PushScript(int a1, int a2)
{
  int i; // [esp+14h] [ebp-4h]

  for ( i = *(_DWORD *)(a1 + 132); i; i = *(_DWORD *)(i + 1184) )
  {
    if ( !I_stricmp((char *)i, (char *)a2) )
    {
      SourceError(a1, "%s recursively included", (const char *)a2);
      return;
    }
  }
  *(_DWORD *)(a2 + 1184) = *(_DWORD *)(a1 + 132);
  *(_DWORD *)(a1 + 132) = a2;
}

//----- (0804A898) --------------------------------------------------------
_DWORD *__cdecl PC_CopyToken(void *src)
{
  _DWORD *dest; // [esp+14h] [ebp-4h]

  dest = GetMemory(1068);
  if ( !dest )
    Com_Error(0, "EXE_ERR_OUT_OF_MEMORY");
  memcpy(dest, src, 0x42Cu);
  dest[266] = 0;
  ++dword_8185AA0;
  return dest;
}
// 8185AA0: using guessed type int dword_8185AA0;

//----- (0804A908) --------------------------------------------------------
void __cdecl PC_FreeToken(int a1)
{
  FreeMemory(a1);
  --dword_8185AA0;
}
// 8185AA0: using guessed type int dword_8185AA0;

//----- (0804A922) --------------------------------------------------------
int __cdecl PC_ReadSourceToken(int a1, _BYTE *dest)
{
  int v4; // [esp+18h] [ebp-10h] BYREF
  int v5; // [esp+1Ch] [ebp-Ch] BYREF
  int v6; // [esp+20h] [ebp-8h]
  int v7; // [esp+24h] [ebp-4h]

  while ( !*(_DWORD *)(a1 + 136) )
  {
    if ( PS_ReadToken(*(_DWORD **)(a1 + 132), dest) )
      return 1;
    if ( EndOfScript(*(_DWORD *)(a1 + 132)) )
    {
      while ( *(_DWORD *)(a1 + 148) && *(_DWORD *)(*(_DWORD *)(a1 + 148) + 8) == *(_DWORD *)(a1 + 132) )
      {
        SourceWarning(a1, "missing #endif");
        PC_PopIndent((_DWORD *)a1, &v5, &v4);
      }
    }
    if ( !*(_DWORD *)(*(_DWORD *)(a1 + 132) + 1184) )
      return 0;
    v6 = *(_DWORD *)(a1 + 132);
    *(_DWORD *)(a1 + 132) = *(_DWORD *)(*(_DWORD *)(a1 + 132) + 1184);
    FreeScript(v6);
  }
  memcpy(dest, *(const void **)(a1 + 136), 0x42Cu);
  v7 = *(_DWORD *)(a1 + 136);
  *(_DWORD *)(a1 + 136) = *(_DWORD *)(*(_DWORD *)(a1 + 136) + 1064);
  PC_FreeToken(v7);
  return 1;
}

//----- (0804AA78) --------------------------------------------------------
int __cdecl PC_UnreadSourceToken(int a1, void *src)
{
  _DWORD *v2; // eax

  v2 = PC_CopyToken(src);
  v2[266] = *(_DWORD *)(a1 + 136);
  *(_DWORD *)(a1 + 136) = v2;
  return 1;
}

//----- (0804AAB2) --------------------------------------------------------
int __cdecl PC_ReadDefineParms(int a1, const char **a2, int a3, int a4)
{
  int v6; // [esp+14h] [ebp-454h]
  int v7; // [esp+18h] [ebp-450h]
  int v8; // [esp+1Ch] [ebp-44Ch]
  int v9; // [esp+20h] [ebp-448h]
  int i; // [esp+24h] [ebp-444h]
  _DWORD *v11; // [esp+28h] [ebp-440h]
  _DWORD *v12; // [esp+2Ch] [ebp-43Ch]
  char s1[1080]; // [esp+30h] [ebp-438h] BYREF

  if ( PC_ReadSourceToken(a1, s1) )
  {
    if ( (int)a2[3] <= a4 )
    {
      for ( i = 0; i < (int)a2[3]; ++i )
        *(_DWORD *)(a3 + 4 * i) = 0;
      if ( !strcmp(s1, "(") )
      {
        v9 = 0;
        v7 = 0;
        v6 = 0;
        while ( !v9 )
        {
          if ( v7 >= a4 )
          {
            SourceError(a1, "define %s with too many parms", *a2);
            return 0;
          }
          if ( v7 >= (int)a2[3] )
          {
            SourceWarning(a1, "define %s has too many parms", *a2);
            return 0;
          }
          *(_DWORD *)(a3 + 4 * v7) = 0;
          v8 = 1;
          v11 = 0;
          while ( 1 )
          {
            while ( 1 )
            {
              if ( !PC_ReadSourceToken(a1, s1) )
              {
                SourceError(a1, "define %s incomplete", *a2);
                return 0;
              }
              if ( !strcmp(s1, ",") && v6 <= 0 )
              {
                if ( v8 )
                  SourceWarning(a1, "too many comma's");
                goto LABEL_36;
              }
              v8 = 0;
              if ( strcmp(s1, "(") )
                break;
              ++v6;
            }
            if ( !strcmp(s1, ")") && --v6 <= 0 )
              break;
            if ( v7 < (int)a2[3] )
            {
              v12 = PC_CopyToken(s1);
              v12[266] = 0;
              if ( v11 )
                v11[266] = v12;
              else
                *(_DWORD *)(a3 + 4 * v7) = v12;
              v11 = v12;
            }
          }
          if ( !*(_DWORD *)(a3 + 4 * (_DWORD)a2[3] - 4) )
            SourceWarning(a1, "too few define parms");
          v9 = 1;
LABEL_36:
          ++v7;
        }
        return 1;
      }
      else
      {
        PC_UnreadSourceToken(a1, s1);
        SourceError(a1, "define %s missing parms", *a2);
        return 0;
      }
    }
    else
    {
      SourceError(a1, "define with more than %d parameters", a4);
      return 0;
    }
  }
  else
  {
    SourceError(a1, "define %s missing parms", *a2);
    return 0;
  }
}
// 804AC95: conditional instruction was optimized away because %var_448.4==0

//----- (0804AE5A) --------------------------------------------------------
int __cdecl PC_StringizeTokens(int a1, char *dest)
{
  size_t v2; // eax
  size_t v3; // eax

  *((_DWORD *)dest + 256) = 1;
  *((_DWORD *)dest + 262) = 0;
  *((_DWORD *)dest + 263) = 0;
  *dest = 0;
  strcat(dest, "\"");
  while ( a1 )
  {
    v2 = strlen(dest);
    strncat(dest, (const char *)a1, 1024 - v2);
    a1 = *(_DWORD *)(a1 + 1064);
  }
  v3 = strlen(dest);
  strncat(dest, "\"", 1024 - v3);
  return 1;
}

//----- (0804AF18) --------------------------------------------------------
int __cdecl PC_MergeTokens(char *dest, char *src)
{
  if ( *((_DWORD *)dest + 256) == 4 && (*((_DWORD *)src + 256) == 4 || *((_DWORD *)src + 256) == 3) )
  {
    strcat(dest, src);
    return 1;
  }
  else if ( *((_DWORD *)dest + 256) == 1 && *((_DWORD *)src + 256) == 1 )
  {
    dest[strlen(dest) - 1] = 0;
    strcat(dest, src + 1);
    return 1;
  }
  else
  {
    return 0;
  }
}

//----- (0804AFB8) --------------------------------------------------------
int __cdecl PC_NameHash(int a1)
{
  int i; // [esp+0h] [ebp-8h]
  int v3; // [esp+4h] [ebp-4h]

  v3 = 0;
  for ( i = 0; *(_BYTE *)(i + a1); ++i )
    v3 += *(char *)(i + a1) * (i + 119);
  return ((unsigned __int16)(v3 >> 20) ^ (unsigned __int16)((v3 >> 10) ^ v3)) & 0x3FF;
}

//----- (0804B018) --------------------------------------------------------
int *__cdecl PC_AddDefineToHash(int *a1, int a2)
{
  int v2; // eax
  int v3; // ecx
  int *result; // eax

  v2 = PC_NameHash(*a1);
  a1[7] = *(_DWORD *)(a2 + 4 * v2);
  v3 = 4 * v2;
  result = a1;
  *(_DWORD *)(a2 + v3) = a1;
  return result;
}

//----- (0804B05A) --------------------------------------------------------
int __cdecl PC_FindHashedDefine(int a1, char *s2)
{
  int i; // [esp+14h] [ebp-4h]

  for ( i = *(_DWORD *)(a1 + 4 * PC_NameHash((int)s2)); i; i = *(_DWORD *)(i + 28) )
  {
    if ( !strcmp(*(const char **)i, s2) )
      return i;
  }
  return 0;
}

//----- (0804B0C0) --------------------------------------------------------
int __cdecl PC_FindDefine(int a1, char *s2)
{
  while ( a1 )
  {
    if ( !strcmp(*(const char **)a1, s2) )
      return a1;
    a1 = *(_DWORD *)(a1 + 24);
  }
  return 0;
}

//----- (0804B10C) --------------------------------------------------------
int __cdecl PC_FindDefineParm(int a1, char *s2)
{
  int v4; // [esp+10h] [ebp-8h]
  char *s1; // [esp+14h] [ebp-4h]

  v4 = 0;
  for ( s1 = *(char **)(a1 + 16); s1; s1 = (char *)*((_DWORD *)s1 + 266) )
  {
    if ( !strcmp(s1, s2) )
      return v4;
    ++v4;
  }
  return -1;
}

//----- (0804B168) --------------------------------------------------------
void __cdecl PC_FreeDefine(int a1)
{
  int v1; // [esp+10h] [ebp-8h]
  int v2; // [esp+10h] [ebp-8h]
  int i; // [esp+14h] [ebp-4h]
  int j; // [esp+14h] [ebp-4h]

  for ( i = *(_DWORD *)(a1 + 16); i; i = v1 )
  {
    v1 = *(_DWORD *)(i + 1064);
    PC_FreeToken(i);
  }
  for ( j = *(_DWORD *)(a1 + 20); j; j = v2 )
  {
    v2 = *(_DWORD *)(j + 1064);
    PC_FreeToken(j);
  }
  FreeMemory(a1);
}

//----- (0804B1DC) --------------------------------------------------------
int __cdecl PC_AddBuiltinDefines(int a1)
{
  int result; // eax
  size_t v2; // eax
  char *s; // [esp+10h] [ebp-48h]
  int v4[13]; // [esp+14h] [ebp-44h]
  void *v5; // [esp+48h] [ebp-10h]
  int i; // [esp+4Ch] [ebp-Ch]

  s = "__LINE__";
  v4[0] = 1;
  v4[1] = (int)"__FILE__";
  v4[2] = 2;
  v4[3] = (int)"__DATE__";
  v4[4] = 3;
  v4[5] = (int)"__TIME__";
  v4[6] = 4;
  v4[7] = 0;
  v4[8] = 0;
  for ( i = 0; ; ++i )
  {
    result = i;
    if ( !v4[2 * i - 1] )
      break;
    v2 = strlen((const char *)v4[2 * i - 1]);
    v5 = GetMemory(v2 + 33);
    memset(v5, 0, 0x20u);
    *(_DWORD *)v5 = (char *)v5 + 32;
    strcpy(*(char **)v5, (const char *)v4[2 * i - 1]);
    *((_DWORD *)v5 + 1) |= 1u;
    *((_DWORD *)v5 + 2) = v4[2 * i];
    PC_AddDefineToHash((int *)v5, *(_DWORD *)(a1 + 144));
  }
  return result;
}

//----- (0804B2DA) --------------------------------------------------------
int __cdecl PC_ExpandBuiltinDefine(int a1, void *src, int a3, char **a4, char **a5)
{
  char *v5; // ebx
  char *v6; // ebx
  char *ptr; // [esp+18h] [ebp-10h]
  char *ptra; // [esp+18h] [ebp-10h]
  time_t timer; // [esp+1Ch] [ebp-Ch] BYREF
  char *s; // [esp+20h] [ebp-8h]

  s = (char *)PC_CopyToken(src);
  switch ( *(_DWORD *)(a3 + 8) )
  {
    case 1:
      sprintf(s, "%d", *((_DWORD *)src + 264));
      *((_DWORD *)s + 258) = *((_DWORD *)src + 264);
      *(long double *)(s + 1036) = (long double)*((int *)src + 264);
      *((_DWORD *)s + 256) = 3;
      *((_DWORD *)s + 257) = 4104;
      *a4 = s;
      *a5 = s;
      break;
    case 2:
      strcpy(s, *(const char **)(a1 + 132));
      *((_DWORD *)s + 256) = 4;
      *((_DWORD *)s + 257) = strlen(s);
      *a4 = s;
      *a5 = s;
      break;
    case 3:
      timer = time(0);
      ptr = ctime(&timer);
      strcpy(s, "\"");
      strncat(s, ptr + 4, 7u);
      strncat(s + 7, ptr + 20, 4u);
      strcat(s, "\"");
      free(ptr);
      *((_DWORD *)s + 256) = 4;
      v5 = s;
      *((_DWORD *)v5 + 257) = strlen(s);
      *a4 = s;
      *a5 = s;
      break;
    case 4:
      timer = time(0);
      ptra = ctime(&timer);
      strcpy(s, "\"");
      strncat(s, ptra + 11, 8u);
      strcat(s, "\"");
      free(ptra);
      *((_DWORD *)s + 256) = 4;
      v6 = s;
      *((_DWORD *)v6 + 257) = strlen(s);
      *a4 = s;
      *a5 = s;
      break;
    default:
      *a4 = 0;
      *a5 = 0;
      break;
  }
  return 1;
}

//----- (0804B550) --------------------------------------------------------
int __cdecl PC_ExpandDefine(int a1, void *a2, int a3, char **a4, char **a5)
{
  int j; // [esp+28h] [ebp-660h]
  int v8; // [esp+2Ch] [ebp-65Ch]
  int v9; // [esp+2Ch] [ebp-65Ch]
  char dest[1072]; // [esp+30h] [ebp-658h] BYREF
  void *v11; // [esp+460h] [ebp-228h]
  char *v12; // [esp+464h] [ebp-224h]
  _DWORD *v13; // [esp+468h] [ebp-220h]
  char *src; // [esp+46Ch] [ebp-21Ch]
  char *v15; // [esp+470h] [ebp-218h]
  _DWORD *v16; // [esp+474h] [ebp-214h]
  void *i; // [esp+478h] [ebp-210h]
  char *s2; // [esp+47Ch] [ebp-20Ch]
  int v19[130]; // [esp+480h] [ebp-208h] BYREF

  if ( *(_DWORD *)(a3 + 8) )
    return PC_ExpandBuiltinDefine(a1, a2, a3, a4, a5);
  if ( *(_DWORD *)(a3 + 12) && !PC_ReadDefineParms(a1, (const char **)a3, (int)v19, 128) )
    return 0;
  v13 = 0;
  v12 = 0;
  for ( s2 = *(char **)(a3 + 20); s2; s2 = (char *)*((_DWORD *)s2 + 266) )
  {
    v8 = -1;
    if ( *((_DWORD *)s2 + 256) == 4 )
      v8 = PC_FindDefineParm(a3, s2);
    if ( v8 < 0 )
    {
      if ( *s2 != 35 || s2[1] )
      {
        v16 = PC_CopyToken(s2);
      }
      else
      {
        if ( *((_DWORD *)s2 + 266) )
          v9 = PC_FindDefineParm(a3, *((char **)s2 + 266));
        else
          v9 = -1;
        if ( v9 < 0 )
        {
          SourceWarning(a1, "stringizing operator without define parameter");
          continue;
        }
        s2 = (char *)*((_DWORD *)s2 + 266);
        if ( !PC_StringizeTokens(v19[v9], dest) )
        {
          SourceError(a1, "can't stringize tokens");
          return 0;
        }
        v16 = PC_CopyToken(dest);
      }
      v16[266] = 0;
      if ( v12 )
        *((_DWORD *)v12 + 266) = v16;
      else
        v13 = v16;
      v12 = (char *)v16;
    }
    else
    {
      for ( i = (void *)v19[v8]; i; i = (void *)*((_DWORD *)i + 266) )
      {
        v16 = PC_CopyToken(i);
        v16[266] = 0;
        if ( v12 )
          *((_DWORD *)v12 + 266) = v16;
        else
          v13 = v16;
        v12 = (char *)v16;
      }
    }
  }
  v16 = v13;
  while ( v16 )
  {
    if ( v16[266]
      && *(_BYTE *)v16[266] == 35
      && *(_BYTE *)(v16[266] + 1) == 35
      && (v15 = (char *)v16, (src = *(char **)(v16[266] + 1064)) != 0) )
    {
      if ( !PC_MergeTokens(v15, src) )
      {
        SourceError(a1, "can't merge %s with %s", v15, src);
        return 0;
      }
      PC_FreeToken(*((_DWORD *)v15 + 266));
      *((_DWORD *)v15 + 266) = *((_DWORD *)src + 266);
      if ( src == v12 )
        v12 = v15;
      PC_FreeToken((int)src);
    }
    else
    {
      v16 = (_DWORD *)v16[266];
    }
  }
  *a4 = (char *)v13;
  *a5 = v12;
  for ( j = 0; j < *(_DWORD *)(a3 + 12); ++j )
  {
    for ( i = (void *)v19[j]; i; i = v11 )
    {
      v11 = (void *)*((_DWORD *)i + 266);
      PC_FreeToken((int)i);
    }
  }
  return 1;
}
// 804B550: using guessed type int var_208[130];

//----- (0804BA0A) --------------------------------------------------------
int __cdecl PC_ExpandDefineIntoSource(int a1, void *a2, int a3)
{
  int v5; // [esp+20h] [ebp-8h] BYREF
  int v6; // [esp+24h] [ebp-4h] BYREF

  if ( !PC_ExpandDefine(a1, a2, a3, (char **)&v6, (char **)&v5) )
    return 0;
  if ( !v6 || !v5 )
    return 0;
  *(_DWORD *)(v5 + 1064) = *(_DWORD *)(a1 + 136);
  *(_DWORD *)(a1 + 136) = v6;
  return 1;
}

//----- (0804BA84) --------------------------------------------------------
char *__cdecl PC_ConvertPath(char *a1)
{
  char *result; // eax
  char *dest; // [esp+14h] [ebp-4h]
  char *desta; // [esp+14h] [ebp-4h]

  dest = a1;
  while ( *dest )
  {
    if ( (*dest == 92 || *dest == 47) && (dest[1] == 92 || dest[1] == 47) )
      strcpy(dest, dest + 1);
    else
      ++dest;
  }
  for ( desta = a1; ; ++desta )
  {
    result = desta;
    if ( !*desta )
      break;
    if ( *desta == 47 || *desta == 92 )
      *desta = 47;
  }
  return result;
}

//----- (0804BB0E) --------------------------------------------------------
int __cdecl PC_Directive_include(int a1)
{
  char dest[64]; // [esp+20h] [ebp-488h] BYREF
  char src[1024]; // [esp+60h] [ebp-448h] BYREF
  int v5; // [esp+460h] [ebp-48h]
  int v6; // [esp+484h] [ebp-24h]
  char *v7; // [esp+49Ch] [ebp-Ch]

  if ( *(int *)(a1 + 152) > 0 )
    return 1;
  if ( !PC_ReadSourceToken(a1, src) || v6 > 0 )
    goto LABEL_4;
  if ( v5 != 1 )
  {
    if ( v5 == 5 && src[0] == 60 )
    {
      strcpy(dest, (const char *)(a1 + 64));
      while ( PC_ReadSourceToken(a1, src) )
      {
        if ( v6 > 0 )
        {
          PC_UnreadSourceToken(a1, src);
          break;
        }
        if ( v5 == 5 && src[0] == 62 )
          break;
        strncat(dest, src, 0x40u);
      }
      if ( src[0] != 62 )
        SourceWarning(a1, "#include missing trailing >");
      if ( !dest[0] )
      {
        SourceError(a1, "#include without file name between < >");
        return 0;
      }
      PC_ConvertPath(dest);
      v7 = LoadScriptFile(dest);
      goto LABEL_24;
    }
LABEL_4:
    SourceError(a1, "#include without file name");
    return 0;
  }
  StripDoubleQuotes(src);
  PC_ConvertPath(src);
  v7 = LoadScriptFile(src);
  if ( !v7 )
  {
    strcpy(dest, (const char *)(a1 + 64));
    strcat(dest, src);
    v7 = LoadScriptFile(dest);
  }
LABEL_24:
  if ( v7 )
  {
    PC_PushScript(a1, (int)v7);
    return 1;
  }
  else
  {
    SourceError(a1, "file %s not found", dest);
    return 0;
  }
}

//----- (0804BD8C) --------------------------------------------------------
int __cdecl PC_ReadLine(int a1, char *s1)
{
  int v4; // [esp+10h] [ebp-8h]
  int v5; // [esp+14h] [ebp-4h]

  v5 = 0;
  do
  {
    if ( !PC_ReadSourceToken(a1, s1) )
      return 0;
    if ( *((_DWORD *)s1 + 265) > v5 )
    {
      PC_UnreadSourceToken(a1, s1);
      return 0;
    }
    if ( *((_DWORD *)s1 + 256) == 4 )
    {
      v4 = PC_FindHashedDefine(*(_DWORD *)(a1 + 144), s1);
      if ( v4 )
      {
        if ( !PC_ExpandDefineIntoSource(a1, s1, v4) )
          return 0;
        if ( !PC_ReadSourceToken(a1, s1) )
          return 0;
      }
    }
    v5 = 1;
  }
  while ( !strcmp(s1, "\\") );
  return 1;
}

//----- (0804BE88) --------------------------------------------------------
_BOOL4 __cdecl PC_WhiteSpaceBeforeToken(int a1)
{
  return *(_DWORD *)(a1 + 1052) - *(_DWORD *)(a1 + 1048) > 0;
}

//----- (0804BEB8) --------------------------------------------------------
_DWORD *__cdecl PC_ClearTokenWhiteSpace(_DWORD *a1)
{
  _DWORD *result; // eax

  a1[262] = 0;
  a1[263] = 0;
  result = a1;
  a1[265] = 0;
  return result;
}

//----- (0804BEE4) --------------------------------------------------------
int __cdecl PC_Directive_undef(int a1)
{
  int v3; // [esp+14h] [ebp-444h]
  int v4; // [esp+18h] [ebp-440h]
  int i; // [esp+1Ch] [ebp-43Ch]
  char s2[1024]; // [esp+20h] [ebp-438h] BYREF
  int v7; // [esp+420h] [ebp-38h]

  if ( *(int *)(a1 + 152) > 0 )
    return 1;
  if ( PC_ReadLine(a1, s2) )
  {
    if ( v7 == 4 )
    {
      v3 = PC_NameHash((int)s2);
      v4 = 0;
      for ( i = *(_DWORD *)(*(_DWORD *)(a1 + 144) + 4 * v3); i; i = *(_DWORD *)(i + 28) )
      {
        if ( !strcmp(*(const char **)i, s2) )
        {
          if ( (*(_BYTE *)(i + 4) & 1) != 0 )
          {
            SourceWarning(a1, "can't undef %s", s2);
          }
          else
          {
            if ( v4 )
              *(_DWORD *)(v4 + 28) = *(_DWORD *)(i + 28);
            else
              *(_DWORD *)(*(_DWORD *)(a1 + 144) + 4 * v3) = *(_DWORD *)(i + 28);
            PC_FreeDefine(i);
          }
          return 1;
        }
        v4 = i;
      }
      return 1;
    }
    else
    {
      PC_UnreadSourceToken(a1, s2);
      SourceError(a1, "expected name, found %s", s2);
      return 0;
    }
  }
  else
  {
    SourceError(a1, "undef without name");
    return 0;
  }
}

//----- (0804C0A4) --------------------------------------------------------
int __cdecl PC_Directive_define(int *a1)
{
  size_t v1; // eax
  _BYTE *v4; // [esp+14h] [ebp-444h]
  char **v5; // [esp+14h] [ebp-444h]
  char *v6; // [esp+18h] [ebp-440h]
  char *v7; // [esp+18h] [ebp-440h]
  char *s1; // [esp+1Ch] [ebp-43Ch]
  char *s1a; // [esp+1Ch] [ebp-43Ch]
  char s[1024]; // [esp+20h] [ebp-438h] BYREF
  int v11; // [esp+420h] [ebp-38h]

  if ( a1[38] > 0 )
    return 1;
  if ( !PC_ReadLine((int)a1, s) )
  {
    SourceError((int)a1, "#define without name");
    return 0;
  }
  if ( v11 != 4 )
  {
    PC_UnreadSourceToken((int)a1, s);
    SourceError((int)a1, "expected name after #define, found %s", s);
    return 0;
  }
  v4 = (_BYTE *)PC_FindHashedDefine(a1[36], s);
  if ( v4 )
  {
    if ( (v4[4] & 1) != 0 )
    {
      SourceError((int)a1, "can't redefine %s", s);
      return 0;
    }
    SourceWarning((int)a1, "redefinition of %s", s);
    PC_UnreadSourceToken((int)a1, s);
    if ( !PC_Directive_undef((int)a1) )
      return 0;
    PC_FindHashedDefine(a1[36], s);
  }
  v1 = strlen(s);
  v5 = (char **)GetMemory(v1 + 33);
  memset(v5, 0, 0x20u);
  *v5 = (char *)(v5 + 8);
  strcpy(*v5, s);
  PC_AddDefineToHash((int *)v5, a1[36]);
  if ( !PC_ReadLine((int)a1, s) )
    return 1;
  if ( PC_WhiteSpaceBeforeToken((int)s) || strcmp(s, "(") )
    goto LABEL_34;
  v6 = 0;
  if ( PC_CheckTokenString(a1, ")") )
  {
LABEL_32:
    if ( !PC_ReadLine((int)a1, s) )
      return 1;
LABEL_34:
    v7 = 0;
    do
    {
      s1a = (char *)PC_CopyToken(s);
      if ( *((_DWORD *)s1a + 256) == 4 && !strcmp(s1a, *v5) )
      {
        SourceError((int)a1, "recursive define (removed recursion)");
      }
      else
      {
        PC_ClearTokenWhiteSpace(s1a);
        *((_DWORD *)s1a + 266) = 0;
        if ( v7 )
          *((_DWORD *)v7 + 266) = s1a;
        else
          v5[5] = s1a;
        v7 = s1a;
      }
    }
    while ( PC_ReadLine((int)a1, s) );
    if ( !v7 || strcmp(v5[5], "##") && strcmp(v7, "##") )
      return 1;
    SourceError((int)a1, "define with misplaced ##");
    return 0;
  }
  do
  {
    if ( !PC_ReadLine((int)a1, s) )
    {
      SourceError((int)a1, "expected define parameter");
      return 0;
    }
    if ( v11 != 4 )
    {
      SourceError((int)a1, "invalid define parameter");
      return 0;
    }
    if ( PC_FindDefineParm((int)v5, s) >= 0 )
    {
      SourceError((int)a1, "two the same define parameters");
      return 0;
    }
    s1 = (char *)PC_CopyToken(s);
    PC_ClearTokenWhiteSpace(s1);
    *((_DWORD *)s1 + 266) = 0;
    if ( v6 )
      *((_DWORD *)v6 + 266) = s1;
    else
      v5[4] = s1;
    v6 = s1;
    ++v5[3];
    if ( !PC_ReadLine((int)a1, s) )
    {
      SourceError((int)a1, "define parameters not terminated");
      return 0;
    }
    if ( !strcmp(s, ")") )
      goto LABEL_32;
  }
  while ( !strcmp(s, ",") );
  SourceError((int)a1, "define not terminated");
  return 0;
}

//----- (0804C640) --------------------------------------------------------
int __cdecl PC_DefineFromString(char *s)
{
  size_t v1; // eax
  int v4; // [esp+20h] [ebp-4F8h]
  int j; // [esp+24h] [ebp-4F4h]
  int v6; // [esp+28h] [ebp-4F0h]
  int i; // [esp+2Ch] [ebp-4ECh]
  int dest[33]; // [esp+30h] [ebp-4E8h] BYREF
  char *v9; // [esp+B4h] [ebp-464h]
  int v10; // [esp+B8h] [ebp-460h]
  int v11; // [esp+BCh] [ebp-45Ch]
  _DWORD *v12; // [esp+C0h] [ebp-458h]
  char *v13; // [esp+50Ch] [ebp-Ch]

  v1 = strlen(s);
  v13 = LoadScriptMemory(s, v1, "*extern");
  memset(dest, 0, 0x4C8u);
  strncpy((char *)dest, "*extern", 0x40u);
  v9 = v13;
  v12 = GetClearedMemory(0x1000u);
  v6 = PC_Directive_define(dest);
  for ( i = v10; i; i = v10 )
  {
    v10 = *(_DWORD *)(v10 + 1064);
    PC_FreeToken(i);
  }
  v4 = 0;
  for ( j = 0; j <= 1023; ++j )
  {
    if ( v12[j] )
    {
      v4 = v12[j];
      break;
    }
  }
  FreeMemory((int)v12);
  FreeScript((int)v13);
  if ( v6 > 0 )
    return v4;
  if ( v11 )
    PC_FreeDefine(v4);
  return 0;
}
// 804C640: using guessed type int dest[33];

//----- (0804C7DA) --------------------------------------------------------
int __cdecl PC_AddDefine(int a1, char *s)
{
  int *v4; // [esp+14h] [ebp-4h]

  v4 = (int *)PC_DefineFromString(s);
  if ( !v4 )
    return 0;
  PC_AddDefineToHash(v4, *(_DWORD *)(a1 + 144));
  return 1;
}

//----- (0804C822) --------------------------------------------------------
int __cdecl PC_AddGlobalDefine(char *s)
{
  int v3; // [esp+14h] [ebp-4h]

  v3 = PC_DefineFromString(s);
  if ( !v3 )
    return 0;
  *(_DWORD *)(v3 + 24) = dword_8185AA4;
  dword_8185AA4 = v3;
  return 1;
}

//----- (0804C866) --------------------------------------------------------
int __cdecl PC_RemoveGlobalDefine(char *s2)
{
  int v3; // [esp+14h] [ebp-4h]

  v3 = PC_FindDefine(dword_8185AA4, s2);
  if ( !v3 )
    return 0;
  PC_FreeDefine(v3);
  return 1;
}

//----- (0804C8AA) --------------------------------------------------------
int PC_RemoveAllGlobalDefines()
{
  int result; // eax
  int i; // [esp+4h] [ebp-4h]

  result = dword_8185AA4;
  for ( i = dword_8185AA4; i; i = dword_8185AA4 )
  {
    dword_8185AA4 = *(_DWORD *)(dword_8185AA4 + 24);
    PC_FreeDefine(i);
    result = dword_8185AA4;
  }
  return result;
}

//----- (0804C8E4) --------------------------------------------------------
char **__cdecl PC_CopyDefine(int a1, int a2)
{
  size_t v2; // eax
  char *v4; // [esp+8h] [ebp-10h]
  char *v5; // [esp+8h] [ebp-10h]
  char *v6; // [esp+Ch] [ebp-Ch]
  char *v7; // [esp+Ch] [ebp-Ch]
  _DWORD *src; // [esp+10h] [ebp-8h]
  _DWORD *srca; // [esp+10h] [ebp-8h]
  char **v10; // [esp+14h] [ebp-4h]

  v2 = strlen(*(const char **)a2);
  v10 = (char **)GetMemory(v2 + 33);
  *v10 = (char *)(v10 + 8);
  strcpy(*v10, *(const char **)a2);
  v10[1] = *(char **)(a2 + 4);
  v10[2] = *(char **)(a2 + 8);
  v10[3] = *(char **)(a2 + 12);
  v10[6] = 0;
  v10[7] = 0;
  v10[5] = 0;
  v4 = 0;
  for ( src = *(_DWORD **)(a2 + 20); src; src = (_DWORD *)src[266] )
  {
    v6 = (char *)PC_CopyToken(src);
    *((_DWORD *)v6 + 266) = 0;
    if ( v4 )
      *((_DWORD *)v4 + 266) = v6;
    else
      v10[5] = v6;
    v4 = v6;
  }
  v10[4] = 0;
  v5 = 0;
  for ( srca = *(_DWORD **)(a2 + 16); srca; srca = (_DWORD *)srca[266] )
  {
    v7 = (char *)PC_CopyToken(srca);
    *((_DWORD *)v7 + 266) = 0;
    if ( v5 )
      *((_DWORD *)v5 + 266) = v7;
    else
      v10[4] = v7;
    v5 = v7;
  }
  return v10;
}

//----- (0804CA40) --------------------------------------------------------
int __cdecl PC_AddGlobalDefinesToSource(int a1)
{
  int result; // eax
  int *v2; // [esp+10h] [ebp-8h]
  int i; // [esp+14h] [ebp-4h]

  result = dword_8185AA4;
  for ( i = dword_8185AA4; i; i = result )
  {
    v2 = (int *)PC_CopyDefine(a1, i);
    PC_AddDefineToHash(v2, *(_DWORD *)(a1 + 144));
    result = *(_DWORD *)(i + 24);
  }
  return result;
}

//----- (0804CA90) --------------------------------------------------------
int __cdecl PC_Directive_if_def(_DWORD *a1, int a2)
{
  int v4; // [esp+1Ch] [ebp-43Ch]
  char s2[1024]; // [esp+20h] [ebp-438h] BYREF
  int v6; // [esp+420h] [ebp-38h]

  if ( PC_ReadLine((int)a1, s2) )
  {
    if ( v6 == 4 )
    {
      v4 = PC_FindHashedDefine(a1[36], s2);
      PC_PushIndent(a1, a2, (a2 != 8) ^ (v4 == 0));
      return 1;
    }
    else
    {
      PC_UnreadSourceToken((int)a1, s2);
      SourceError((int)a1, "expected name after #ifdef, found %s", s2);
      return 0;
    }
  }
  else
  {
    SourceError((int)a1, "#ifdef without name");
    return 0;
  }
}

//----- (0804CB86) --------------------------------------------------------
int __cdecl PC_Directive_ifdef(_DWORD *a1)
{
  return PC_Directive_if_def(a1, 8);
}

//----- (0804CBA2) --------------------------------------------------------
int __cdecl PC_Directive_ifndef(_DWORD *a1)
{
  return PC_Directive_if_def(a1, 16);
}

//----- (0804CBBE) --------------------------------------------------------
int __cdecl PC_Directive_else(_DWORD *a1)
{
  char v3[4]; // [esp+10h] [ebp-8h] BYREF
  int v4; // [esp+14h] [ebp-4h] BYREF

  PC_PopIndent(a1, &v4, v3);
  if ( v4 )
  {
    if ( v4 == 2 )
    {
      SourceError((int)a1, "#else after #else");
      return 0;
    }
    else
    {
      PC_PushIndent(a1, 2, *(_DWORD *)v3 == 0);
      return 1;
    }
  }
  else
  {
    SourceError((int)a1, "misplaced #else");
    return 0;
  }
}

//----- (0804CC4E) --------------------------------------------------------
int __cdecl PC_Directive_endif(_DWORD *a1)
{
  int v3; // [esp+10h] [ebp-8h] BYREF
  int v4; // [esp+14h] [ebp-4h] BYREF

  PC_PopIndent(a1, &v4, &v3);
  if ( v4 )
    return 1;
  SourceError((int)a1, "misplaced #endif");
  return 0;
}

//----- (0804CC9C) --------------------------------------------------------
int __cdecl PC_OperatorPriority(int a1)
{
  int v2; // [esp+4h] [ebp-4h]

  switch ( a1 )
  {
    case 5:
      v2 = 7;
      break;
    case 6:
      v2 = 6;
      break;
    case 7:
      v2 = 12;
      break;
    case 8:
      v2 = 12;
      break;
    case 9:
      v2 = 11;
      break;
    case 10:
      v2 = 11;
      break;
    case 21:
      v2 = 13;
      break;
    case 22:
      v2 = 13;
      break;
    case 26:
      v2 = 15;
      break;
    case 27:
      v2 = 15;
      break;
    case 28:
      v2 = 15;
      break;
    case 29:
      v2 = 14;
      break;
    case 30:
      v2 = 14;
      break;
    case 32:
      v2 = 10;
      break;
    case 33:
      v2 = 8;
      break;
    case 34:
      v2 = 9;
      break;
    case 35:
      v2 = 16;
      break;
    case 36:
      v2 = 16;
      break;
    case 37:
      v2 = 12;
      break;
    case 38:
      v2 = 12;
      break;
    case 42:
      v2 = 5;
      break;
    case 43:
      v2 = 5;
      break;
    default:
      v2 = 0;
      break;
  }
  return v2;
}

//----- (0804CDAC) --------------------------------------------------------
int __cdecl PC_EvaluateTokens(int a1, char *a2, _DWORD *a3, double *a4, int a5)
{
  _DWORD *v5; // ebx
  double v7; // [esp+38h] [ebp-C10h]
  double v8; // [esp+48h] [ebp-C00h]
  double v9; // [esp+58h] [ebp-BF0h]
  double v10; // [esp+68h] [ebp-BE0h]
  double v11; // [esp+78h] [ebp-BD0h]
  double v12; // [esp+88h] [ebp-BC0h]
  unsigned __int8 v13; // [esp+9Bh] [ebp-BADh]
  int v14; // [esp+A0h] [ebp-BA8h]
  unsigned __int8 v15; // [esp+ABh] [ebp-B9Dh]
  int v16; // [esp+B0h] [ebp-B98h]
  double v17; // [esp+B8h] [ebp-B90h]
  int v18; // [esp+C4h] [ebp-B84h]
  int v20; // [esp+DCh] [ebp-B6Ch]
  _QWORD v21[193]; // [esp+E0h] [ebp-B68h] BYREF
  int v22; // [esp+6ECh] [ebp-55Ch]
  _DWORD v23[320]; // [esp+6F0h] [ebp-558h] BYREF
  int v24; // [esp+BF0h] [ebp-58h]
  int v25; // [esp+BF4h] [ebp-54h]
  double v26; // [esp+BF8h] [ebp-50h]
  int v27; // [esp+C04h] [ebp-44h]
  int v28; // [esp+C08h] [ebp-40h]
  int v29; // [esp+C0Ch] [ebp-3Ch]
  int v30; // [esp+C10h] [ebp-38h]
  int v31; // [esp+C14h] [ebp-34h]
  int v32; // [esp+C18h] [ebp-30h]
  char *s1; // [esp+C1Ch] [ebp-2Ch]
  int v34; // [esp+C20h] [ebp-28h]
  _QWORD *v35; // [esp+C24h] [ebp-24h]
  _QWORD *v36; // [esp+C28h] [ebp-20h]
  _QWORD *v37; // [esp+C2Ch] [ebp-1Ch]
  _QWORD *j; // [esp+C30h] [ebp-18h]
  _DWORD *v39; // [esp+C34h] [ebp-14h]
  _DWORD *v40; // [esp+C38h] [ebp-10h]
  _DWORD *i; // [esp+C3Ch] [ebp-Ch]

  v32 = 0;
  v31 = 0;
  v30 = 0;
  v29 = 0;
  v28 = 0;
  v27 = 0;
  v26 = 0.0;
  v25 = 0;
  v24 = 0;
  v22 = 0;
  v20 = 0;
  v39 = 0;
  v40 = 0;
  v36 = 0;
  v37 = 0;
  if ( a3 )
    *a3 = 0;
  if ( a4 )
    *a4 = 0.0;
  for ( s1 = a2; s1; s1 = (char *)*((_DWORD *)s1 + 266) )
  {
    v18 = *((_DWORD *)s1 + 256);
    if ( v18 == 4 )
    {
      if ( v29 || v28 )
      {
LABEL_37:
        SourceError(a1, "syntax error in #if/#elif");
        v30 = 1;
        goto LABEL_80;
      }
      if ( strcmp(s1, "defined") )
      {
        SourceError(a1, "undefined name %s in #if/#elif", s1);
        v30 = 1;
        goto LABEL_80;
      }
      s1 = (char *)*((_DWORD *)s1 + 266);
      if ( !strcmp(s1, "(") )
      {
        v32 = 1;
        s1 = (char *)*((_DWORD *)s1 + 266);
      }
      if ( !s1 || *((_DWORD *)s1 + 256) != 4 )
      {
        SourceError(a1, "defined without name in #if/#elif");
        v30 = 1;
        goto LABEL_80;
      }
      if ( v20 > 63 )
      {
LABEL_24:
        SourceError(a1, "out of value space\n");
        v30 = 1;
        goto LABEL_80;
      }
      j = &v21[3 * v20++];
      if ( PC_FindHashedDefine(*(_DWORD *)(a1 + 144), s1) )
      {
        *(_DWORD *)j = 1;
        *(double *)((char *)j + 4) = 1.0;
      }
      else
      {
        *(_DWORD *)j = 0;
        *(double *)((char *)j + 4) = 0.0;
      }
      *((_DWORD *)j + 3) = v31;
      *((_DWORD *)j + 5) = 0;
      *((_DWORD *)j + 4) = v36;
      if ( v36 )
        *((_DWORD *)v36 + 5) = j;
      else
        v37 = j;
      v36 = j;
      if ( !v32 || (s1 = (char *)*((_DWORD *)s1 + 266)) != 0 && !strcmp(s1, ")") )
      {
        v32 = 0;
        v29 = 1;
      }
      else
      {
        SourceError(a1, "defined without ) in #if/#elif");
        v30 = 1;
      }
    }
    else if ( v18 > 4 )
    {
      if ( v18 != 5 )
      {
LABEL_79:
        SourceError(a1, "unknown %s in #if/#elif", s1);
        v30 = 1;
        goto LABEL_80;
      }
      if ( v28 )
      {
        SourceError(a1, "misplaced minus sign in #if/#elif");
        v30 = 1;
      }
      else if ( *((_DWORD *)s1 + 257) == 44 )
      {
        ++v31;
      }
      else if ( *((_DWORD *)s1 + 257) == 45 )
      {
        if ( --v31 < 0 )
        {
          SourceError(a1, "too many ) in #if/#elsif");
          v30 = 1;
        }
      }
      else if ( !a5
             && (*((_DWORD *)s1 + 257) == 35
              || *((_DWORD *)s1 + 257) == 28
              || *((_DWORD *)s1 + 257) == 21
              || *((_DWORD *)s1 + 257) == 22
              || *((_DWORD *)s1 + 257) == 32
              || *((_DWORD *)s1 + 257) == 33
              || *((_DWORD *)s1 + 257) == 34) )
      {
        SourceError(a1, "illigal operator %s on floating point operands\n", s1);
        v30 = 1;
      }
      else
      {
        switch ( *((_DWORD *)s1 + 257) )
        {
          case 5:
          case 6:
          case 7:
          case 8:
          case 9:
          case 0xA:
          case 0x15:
          case 0x16:
          case 0x1A:
          case 0x1B:
          case 0x1C:
          case 0x1D:
          case 0x20:
          case 0x21:
          case 0x22:
          case 0x25:
          case 0x26:
          case 0x2A:
          case 0x2B:
            goto LABEL_68;
          case 0x10:
          case 0x11:
            SourceError(a1, "++ or -- used in #if/#elif");
            break;
          case 0x1E:
            if ( v29 )
            {
LABEL_68:
              if ( !v29 )
              {
                SourceError(a1, "operator %s after operator in #if/#elif", s1);
                v30 = 1;
              }
            }
            else
            {
              v28 = 1;
            }
            break;
          case 0x23:
          case 0x24:
            if ( v29 )
            {
              SourceError(a1, "! or ~ after value in #if/#elif");
              v30 = 1;
            }
            break;
          default:
            SourceError(a1, "invalid operator %s in #if/#elif", s1);
            v30 = 1;
            break;
        }
        if ( !v30 && !v28 )
        {
          if ( v22 <= 63 )
          {
            i = &v23[5 * v22++];
            *i = *((_DWORD *)s1 + 257);
            v5 = i;
            v5[1] = PC_OperatorPriority(*((_DWORD *)s1 + 257));
            i[2] = v31;
            i[4] = 0;
            i[3] = v39;
            if ( v39 )
              v39[4] = i;
            else
              v40 = i;
            v39 = i;
            v29 = 0;
          }
          else
          {
            SourceError(a1, "out of operator space\n");
            v30 = 1;
          }
        }
      }
    }
    else
    {
      if ( v18 != 3 )
        goto LABEL_79;
      if ( v29 )
        goto LABEL_37;
      if ( v20 > 63 )
        goto LABEL_24;
      j = &v21[3 * v20++];
      if ( v28 )
      {
        *(_DWORD *)j = -*((_DWORD *)s1 + 258);
        *(double *)((char *)j + 4) = -*(long double *)(s1 + 1036);
      }
      else
      {
        *(_DWORD *)j = *((_DWORD *)s1 + 258);
        *(double *)((char *)j + 4) = *(long double *)(s1 + 1036);
      }
      *((_DWORD *)j + 3) = v31;
      *((_DWORD *)j + 5) = 0;
      *((_DWORD *)j + 4) = v36;
      if ( v36 )
        *((_DWORD *)v36 + 5) = j;
      else
        v37 = j;
      v36 = j;
      v29 = 1;
      v28 = 0;
    }
LABEL_80:
    if ( v30 )
      break;
  }
  if ( !v30 )
  {
    if ( v29 )
    {
      if ( v31 )
      {
        SourceError(a1, "too many ( in #if/#elif");
        v30 = 1;
      }
    }
    else
    {
      SourceError(a1, "trailing operator in #if/#elif");
      v30 = 1;
    }
  }
  v25 = 0;
  v27 = 0;
  v26 = 0.0;
  while ( !v30 && v40 )
  {
    j = v37;
    for ( i = v40;
          i[4] && i[2] <= *(_DWORD *)(i[4] + 8) && (i[2] != *(_DWORD *)(i[4] + 8) || i[1] < *(_DWORD *)(i[4] + 4));
          i = (_DWORD *)i[4] )
    {
      if ( *i != 36 && *i != 35 )
        j = (_QWORD *)*((_DWORD *)j + 5);
      if ( !j )
      {
        SourceError(a1, "mising values in #if/#elif");
        v30 = 1;
        break;
      }
    }
    if ( v30 )
      break;
    v35 = j;
    v34 = *((_DWORD *)j + 5);
    switch ( *i )
    {
      case 5:
        v16 = 0;
        if ( *(_DWORD *)v35 && *(_DWORD *)v34 )
          v16 = 1;
        *(_DWORD *)v35 = v16;
        v15 = 0;
        if ( *(double *)((char *)v35 + 4) != 0.0 && *(double *)(v34 + 4) != 0.0 )
          v15 = 1;
        *(double *)((char *)v35 + 4) = (double)v15;
        break;
      case 6:
        v14 = 0;
        if ( *(_DWORD *)v35 || *(_DWORD *)v34 )
          v14 = 1;
        *(_DWORD *)v35 = v14;
        v13 = 0;
        if ( *(double *)((char *)v35 + 4) != 0.0 || *(double *)(v34 + 4) != 0.0 )
          v13 = 1;
        *(double *)((char *)v35 + 4) = (double)v13;
        break;
      case 7:
        *(_DWORD *)v35 = *(_DWORD *)v35 >= *(_DWORD *)v34;
        if ( *(double *)((char *)v35 + 4) < (long double)*(double *)(v34 + 4) )
          v12 = 0.0;
        else
          v12 = 1.0;
        *(double *)((char *)v35 + 4) = v12;
        break;
      case 8:
        *(_DWORD *)v35 = *(_DWORD *)v35 <= *(_DWORD *)v34;
        if ( *(double *)(v34 + 4) < (long double)*(double *)((char *)v35 + 4) )
          v11 = 0.0;
        else
          v11 = 1.0;
        *(double *)((char *)v35 + 4) = v11;
        break;
      case 9:
        *(_DWORD *)v35 = *(_DWORD *)v35 == *(_DWORD *)v34;
        if ( *(double *)((char *)v35 + 4) == *(double *)(v34 + 4) )
          v10 = 1.0;
        else
          v10 = 0.0;
        *(double *)((char *)v35 + 4) = v10;
        break;
      case 0xA:
        *(_DWORD *)v35 = *(_DWORD *)v35 != *(_DWORD *)v34;
        if ( *(double *)((char *)v35 + 4) == *(double *)(v34 + 4) )
          v9 = 0.0;
        else
          v9 = 1.0;
        *(double *)((char *)v35 + 4) = v9;
        break;
      case 0x15:
        *(int *)v35 >>= *(_BYTE *)v34;
        break;
      case 0x16:
        *(_DWORD *)v35 <<= *(_BYTE *)v34;
        break;
      case 0x1A:
        *(_DWORD *)v35 *= *(_DWORD *)v34;
        *(double *)((char *)v35 + 4) = *(double *)((char *)v35 + 4) * *(double *)(v34 + 4);
        break;
      case 0x1B:
        if ( !*(_DWORD *)v34 || *(double *)(v34 + 4) == 0.0 )
          goto LABEL_114;
        *(int *)v35 /= *(int *)v34;
        *(double *)((char *)v35 + 4) = *(double *)((char *)v35 + 4) / *(double *)(v34 + 4);
        break;
      case 0x1C:
        if ( *(_DWORD *)v34 )
        {
          *(int *)v35 %= *(_DWORD *)v34;
        }
        else
        {
LABEL_114:
          SourceError(a1, "divide by zero in #if/#elif\n");
          v30 = 1;
        }
        break;
      case 0x1D:
        *(_DWORD *)v35 += *(_DWORD *)v34;
        *(double *)((char *)v35 + 4) = *(double *)((char *)v35 + 4) + *(double *)(v34 + 4);
        break;
      case 0x1E:
        *(_DWORD *)v35 -= *(_DWORD *)v34;
        *(double *)((char *)v35 + 4) = *(double *)((char *)v35 + 4) - *(double *)(v34 + 4);
        break;
      case 0x20:
        *(_DWORD *)v35 &= *(_DWORD *)v34;
        break;
      case 0x21:
        *(_DWORD *)v35 |= *(_DWORD *)v34;
        break;
      case 0x22:
        *(_DWORD *)v35 ^= *(_DWORD *)v34;
        break;
      case 0x23:
        *(_DWORD *)v35 = ~*(_DWORD *)v35;
        break;
      case 0x24:
        *(_DWORD *)v35 = *(_DWORD *)v35 == 0;
        if ( *(double *)((char *)v35 + 4) == 0.0 )
          v17 = 1.0;
        else
          v17 = 0.0;
        *(double *)((char *)v35 + 4) = v17;
        break;
      case 0x25:
        *(_DWORD *)v35 = *(_DWORD *)v35 > *(_DWORD *)v34;
        if ( *(double *)((char *)v35 + 4) <= (long double)*(double *)(v34 + 4) )
          v8 = 0.0;
        else
          v8 = 1.0;
        *(double *)((char *)v35 + 4) = v8;
        break;
      case 0x26:
        *(_DWORD *)v35 = *(_DWORD *)v35 < *(_DWORD *)v34;
        if ( *(double *)(v34 + 4) <= (long double)*(double *)((char *)v35 + 4) )
          v7 = 0.0;
        else
          v7 = 1.0;
        *(double *)((char *)v35 + 4) = v7;
        break;
      case 0x2A:
        if ( v25 )
        {
          if ( a5 )
          {
            if ( !v27 )
              *(_DWORD *)v35 = *(_DWORD *)v34;
          }
          else if ( v26 == 0.0 )
          {
            *(double *)((char *)v35 + 4) = *(double *)(v34 + 4);
          }
          v25 = 0;
        }
        else
        {
          SourceError(a1, ": without ? in #if/#elif");
          v30 = 1;
        }
        break;
      case 0x2B:
        if ( v25 )
        {
          SourceError(a1, "? after ? in #if/#elif");
          v30 = 1;
        }
        else
        {
          v27 = *(_DWORD *)v35;
          v26 = *(double *)((char *)v35 + 4);
          v25 = 1;
        }
        break;
      default:
        break;
    }
    if ( v30 )
      break;
    v24 = *i;
    if ( *i != 36 && *i != 35 )
    {
      if ( *i != 43 )
        j = (_QWORD *)*((_DWORD *)j + 5);
      if ( *((_DWORD *)j + 4) )
        *(_DWORD *)(*((_DWORD *)j + 4) + 20) = *((_DWORD *)j + 5);
      else
        v37 = (_QWORD *)*((_DWORD *)j + 5);
      if ( *((_DWORD *)j + 5) )
        *(_DWORD *)(*((_DWORD *)j + 5) + 16) = *((_DWORD *)j + 4);
      else
        v36 = (_QWORD *)*((_DWORD *)j + 4);
    }
    if ( i[3] )
      *(_DWORD *)(i[3] + 16) = i[4];
    else
      v40 = (_DWORD *)i[4];
    if ( i[4] )
      *(_DWORD *)(i[4] + 12) = i[3];
    else
      v39 = (_DWORD *)i[3];
  }
  if ( v37 )
  {
    if ( a3 )
      *a3 = *(_DWORD *)v37;
    if ( a4 )
      *a4 = *(double *)((char *)v37 + 4);
  }
  for ( i = v40; i; i = v39 )
    v39 = (_DWORD *)i[4];
  for ( j = v37; j; j = v36 )
    v36 = (_QWORD *)*((_DWORD *)j + 5);
  if ( !v30 )
    return 1;
  if ( a3 )
    *a3 = 0;
  if ( a4 )
    *a4 = 0.0;
  return 0;
}

//----- (0804DD32) --------------------------------------------------------
int __cdecl PC_Evaluate(int a1, _DWORD *a2, double *a3, int a4)
{
  int v6; // [esp+28h] [ebp-450h]
  int v7; // [esp+2Ch] [ebp-44Ch]
  int v8; // [esp+30h] [ebp-448h]
  char *v9; // [esp+34h] [ebp-444h]
  char *v10; // [esp+34h] [ebp-444h]
  char *v11; // [esp+34h] [ebp-444h]
  int i; // [esp+34h] [ebp-444h]
  char *v13; // [esp+38h] [ebp-440h]
  char *v14; // [esp+3Ch] [ebp-43Ch]
  char s1[1024]; // [esp+40h] [ebp-438h] BYREF
  int v16; // [esp+440h] [ebp-38h]

  v6 = 0;
  if ( a2 )
    *a2 = 0;
  if ( a3 )
    *a3 = 0.0;
  if ( PC_ReadLine(a1, s1) )
  {
    v14 = 0;
    v13 = 0;
    do
    {
      if ( v16 == 4 )
      {
        if ( v6 )
        {
          v6 = 0;
          v9 = (char *)PC_CopyToken(s1);
          *((_DWORD *)v9 + 266) = 0;
          if ( v13 )
            *((_DWORD *)v13 + 266) = v9;
          else
            v14 = v9;
          v13 = v9;
        }
        else if ( !strcmp(s1, "defined") )
        {
          v6 = 1;
          v10 = (char *)PC_CopyToken(s1);
          *((_DWORD *)v10 + 266) = 0;
          if ( v13 )
            *((_DWORD *)v13 + 266) = v10;
          else
            v14 = v10;
          v13 = v10;
        }
        else
        {
          v7 = PC_FindHashedDefine(*(_DWORD *)(a1 + 144), s1);
          if ( !v7 )
          {
            SourceError(a1, "can't evaluate %s, not defined", s1);
            return 0;
          }
          if ( !PC_ExpandDefineIntoSource(a1, s1, v7) )
            return 0;
        }
      }
      else
      {
        if ( v16 != 3 && v16 != 5 )
        {
          SourceError(a1, "can't evaluate %s", s1);
          return 0;
        }
        v11 = (char *)PC_CopyToken(s1);
        *((_DWORD *)v11 + 266) = 0;
        if ( v13 )
          *((_DWORD *)v13 + 266) = v11;
        else
          v14 = v11;
        v13 = v11;
      }
    }
    while ( PC_ReadLine(a1, s1) );
    if ( PC_EvaluateTokens(a1, v14, a2, a3, a4) )
    {
      for ( i = (int)v14; i; i = v8 )
      {
        v8 = *(_DWORD *)(i + 1064);
        PC_FreeToken(i);
      }
      return 1;
    }
    else
    {
      return 0;
    }
  }
  else
  {
    SourceError(a1, "no value after #if/#elif");
    return 0;
  }
}

//----- (0804E07C) --------------------------------------------------------
int __cdecl PC_DollarEvaluate(int a1, _DWORD *a2, double *a3, int a4)
{
  int v6; // [esp+2Ch] [ebp-45Ch]
  int v7; // [esp+30h] [ebp-458h]
  char *v8; // [esp+34h] [ebp-454h]
  char *v9; // [esp+34h] [ebp-454h]
  char *v10; // [esp+34h] [ebp-454h]
  int i; // [esp+34h] [ebp-454h]
  char *v12; // [esp+38h] [ebp-450h]
  char *v13; // [esp+3Ch] [ebp-44Ch]
  char s1[1024]; // [esp+40h] [ebp-448h] BYREF
  int v15; // [esp+440h] [ebp-48h]
  int v16; // [esp+478h] [ebp-10h]
  int v17; // [esp+47Ch] [ebp-Ch]

  v16 = 0;
  if ( a2 )
    *a2 = 0;
  if ( a3 )
    *a3 = 0.0;
  if ( !PC_ReadSourceToken(a1, s1) )
  {
    SourceError(a1, "no leading ( after $evalint/$evalfloat");
    return 0;
  }
  if ( !PC_ReadSourceToken(a1, s1) )
  {
    SourceError(a1, "nothing to evaluate");
    return 0;
  }
  v17 = 1;
  v13 = 0;
  v12 = 0;
  do
  {
    if ( v15 == 4 )
    {
      if ( v16 )
      {
        v16 = 0;
        v8 = (char *)PC_CopyToken(s1);
        *((_DWORD *)v8 + 266) = 0;
        if ( v12 )
          *((_DWORD *)v12 + 266) = v8;
        else
          v13 = v8;
        v12 = v8;
      }
      else if ( !strcmp(s1, "defined") )
      {
        v16 = 1;
        v9 = (char *)PC_CopyToken(s1);
        *((_DWORD *)v9 + 266) = 0;
        if ( v12 )
          *((_DWORD *)v12 + 266) = v9;
        else
          v13 = v9;
        v12 = v9;
      }
      else
      {
        v6 = PC_FindHashedDefine(*(_DWORD *)(a1 + 144), s1);
        if ( !v6 )
        {
          SourceError(a1, "can't evaluate %s, not defined", s1);
          return 0;
        }
        if ( !PC_ExpandDefineIntoSource(a1, s1, v6) )
          return 0;
      }
      continue;
    }
    if ( v15 != 3 && v15 != 5 )
    {
      SourceError(a1, "can't evaluate %s", s1);
      return 0;
    }
    if ( s1[0] == 40 )
    {
      ++v17;
    }
    else if ( s1[0] == 41 )
    {
      --v17;
    }
    if ( v17 <= 0 )
      break;
    v10 = (char *)PC_CopyToken(s1);
    *((_DWORD *)v10 + 266) = 0;
    if ( v12 )
      *((_DWORD *)v12 + 266) = v10;
    else
      v13 = v10;
    v12 = v10;
  }
  while ( PC_ReadSourceToken(a1, s1) );
  if ( !PC_EvaluateTokens(a1, v13, a2, a3, a4) )
    return 0;
  for ( i = (int)v13; i; i = v7 )
  {
    v7 = *(_DWORD *)(i + 1064);
    PC_FreeToken(i);
  }
  return 1;
}

//----- (0804E428) --------------------------------------------------------
int __cdecl PC_Directive_elif(_DWORD *a1)
{
  char v3[4]; // [esp+1Ch] [ebp-Ch] BYREF
  int v4; // [esp+20h] [ebp-8h] BYREF
  int v5; // [esp+24h] [ebp-4h] BYREF

  PC_PopIndent(a1, &v4, v3);
  if ( v4 && v4 != 2 )
  {
    if ( PC_Evaluate((int)a1, &v5, 0, 1) )
    {
      *(_DWORD *)v3 = v5 == 0;
      PC_PushIndent(a1, 4, *(int *)v3);
      return 1;
    }
    else
    {
      return 0;
    }
  }
  else
  {
    SourceError((int)a1, "misplaced #elif");
    return 0;
  }
}

//----- (0804E4D4) --------------------------------------------------------
int __cdecl PC_Directive_if(_DWORD *a1)
{
  int v3; // [esp+24h] [ebp-4h] BYREF

  if ( !PC_Evaluate((int)a1, &v3, 0, 1) )
    return 0;
  PC_PushIndent(a1, 1, v3 == 0);
  return 1;
}

//----- (0804E53C) --------------------------------------------------------
int __cdecl PC_Directive_line(int a1)
{
  SourceError(a1, "#line directive not supported");
  return 0;
}

//----- (0804E55C) --------------------------------------------------------
int __cdecl PC_Directive_error(int a1)
{
  char dest[1080]; // [esp+10h] [ebp-438h] BYREF

  strcpy(dest, &byte_813A549);
  PC_ReadSourceToken(a1, dest);
  SourceError(a1, "#error directive: %s", dest);
  return 0;
}

//----- (0804E5B4) --------------------------------------------------------
int __cdecl PC_Directive_pragma(int a1)
{
  char s1[1080]; // [esp+10h] [ebp-438h] BYREF

  SourceWarning(a1, "#pragma directive not supported");
  while ( PC_ReadLine(a1, s1) )
    ;
  return 1;
}
// 804E5B4: using guessed type char s1[1080];

//----- (0804E5F0) --------------------------------------------------------
int __cdecl UnreadSignToken(int a1)
{
  char dest[1024]; // [esp+10h] [ebp-438h] BYREF
  int v3; // [esp+410h] [ebp-38h]
  int v4; // [esp+414h] [ebp-34h]
  int v5; // [esp+428h] [ebp-20h]
  int v6; // [esp+42Ch] [ebp-1Ch]
  int v7; // [esp+430h] [ebp-18h]
  int v8; // [esp+434h] [ebp-14h]

  v7 = *(_DWORD *)(*(_DWORD *)(a1 + 132) + 92);
  v5 = *(_DWORD *)(*(_DWORD *)(a1 + 132) + 68);
  v6 = *(_DWORD *)(*(_DWORD *)(a1 + 132) + 68);
  v8 = 0;
  strcpy(dest, "-");
  v3 = 5;
  v4 = 30;
  return PC_UnreadSourceToken(a1, dest);
}

//----- (0804E668) --------------------------------------------------------
int __cdecl PC_Directive_eval(int a1)
{
  int v2; // [esp+18h] [ebp-450h]
  char s[1024]; // [esp+20h] [ebp-448h] BYREF
  int v5; // [esp+420h] [ebp-48h]
  int v6; // [esp+424h] [ebp-44h]
  int v7; // [esp+438h] [ebp-30h]
  int v8; // [esp+43Ch] [ebp-2Ch]
  int v9; // [esp+440h] [ebp-28h]
  int v10; // [esp+444h] [ebp-24h]
  int v11[3]; // [esp+45Ch] [ebp-Ch] BYREF

  if ( !PC_Evaluate(a1, v11, 0, 1) )
    return 0;
  v9 = *(_DWORD *)(*(_DWORD *)(a1 + 132) + 92);
  v7 = *(_DWORD *)(*(_DWORD *)(a1 + 132) + 68);
  v8 = *(_DWORD *)(*(_DWORD *)(a1 + 132) + 68);
  v10 = 0;
  v2 = v11[0];
  if ( v11[0] < 0 )
    v2 = -v11[0];
  sprintf(s, "%d", v2);
  v5 = 3;
  v6 = 12296;
  PC_UnreadSourceToken(a1, s);
  if ( v11[0] < 0 )
    UnreadSignToken(a1);
  return 1;
}
// 804E668: using guessed type int var_C[3];

//----- (0804E758) --------------------------------------------------------
int __cdecl PC_Directive_evalfloat(int a1)
{
  long double v1; // fst7
  float v3; // [esp+0h] [ebp-468h]
  char s[1024]; // [esp+20h] [ebp-448h] BYREF
  int v6; // [esp+420h] [ebp-48h]
  int v7; // [esp+424h] [ebp-44h]
  int v8; // [esp+438h] [ebp-30h]
  int v9; // [esp+43Ch] [ebp-2Ch]
  int v10; // [esp+440h] [ebp-28h]
  int v11; // [esp+444h] [ebp-24h]
  double v12[2]; // [esp+458h] [ebp-10h] BYREF

  if ( !PC_Evaluate(a1, 0, v12, 0) )
    return 0;
  v10 = *(_DWORD *)(*(_DWORD *)(a1 + 132) + 92);
  v8 = *(_DWORD *)(*(_DWORD *)(a1 + 132) + 68);
  v9 = *(_DWORD *)(*(_DWORD *)(a1 + 132) + 68);
  v11 = 0;
  v3 = v12[0];
  v1 = Q_fabs(v3);
  sprintf(s, "%1.2f", (double)v1);
  v6 = 3;
  v7 = 10248;
  PC_UnreadSourceToken(a1, s);
  if ( v12[0] < 0.0 )
    UnreadSignToken(a1);
  return 1;
}
// 804E758: using guessed type double var_10[2];

//----- (0804E83E) --------------------------------------------------------
int __cdecl PC_ReadDirective(int a1)
{
  int i; // [esp+1Ch] [ebp-43Ch]
  char s2[1024]; // [esp+20h] [ebp-438h] BYREF
  int v5; // [esp+420h] [ebp-38h]
  int v6; // [esp+444h] [ebp-14h]

  if ( PC_ReadSourceToken(a1, s2) )
  {
    if ( v6 <= 0 )
    {
      if ( v5 == 4 )
      {
        for ( i = 0; (&s1)[2 * i]; ++i )
        {
          if ( !strcmp((&s1)[2 * i], s2) )
            return (*(&off_815A024 + 2 * i))(a1);
        }
      }
      SourceError(a1, "unknown precompiler directive %s", s2);
      return 0;
    }
    else
    {
      PC_UnreadSourceToken(a1, s2);
      SourceError(a1, "found # at end of line");
      return 0;
    }
  }
  else
  {
    SourceError(a1, "found # without name");
    return 0;
  }
}
// 815A024: using guessed type int (__cdecl *off_815A024)(int);

//----- (0804E95A) --------------------------------------------------------
int __cdecl PC_DollarDirective_evalint(int a1)
{
  int v2; // [esp+18h] [ebp-450h]
  char s[1024]; // [esp+20h] [ebp-448h] BYREF
  int v5; // [esp+420h] [ebp-48h]
  int v6; // [esp+424h] [ebp-44h]
  int v7; // [esp+428h] [ebp-40h]
  long double v8; // [esp+42Ch] [ebp-3Ch]
  int v9; // [esp+438h] [ebp-30h]
  int v10; // [esp+43Ch] [ebp-2Ch]
  int v11; // [esp+440h] [ebp-28h]
  int v12; // [esp+444h] [ebp-24h]
  int v13[3]; // [esp+45Ch] [ebp-Ch] BYREF

  if ( !PC_DollarEvaluate(a1, v13, 0, 1) )
    return 0;
  v11 = *(_DWORD *)(*(_DWORD *)(a1 + 132) + 92);
  v9 = *(_DWORD *)(*(_DWORD *)(a1 + 132) + 68);
  v10 = *(_DWORD *)(*(_DWORD *)(a1 + 132) + 68);
  v12 = 0;
  v2 = v13[0];
  if ( v13[0] < 0 )
    v2 = -v13[0];
  sprintf(s, "%d", v2);
  v5 = 3;
  v6 = 12296;
  v7 = v13[0];
  v8 = (long double)v13[0];
  PC_UnreadSourceToken(a1, s);
  if ( v13[0] < 0 )
    UnreadSignToken(a1);
  return 1;
}
// 804E95A: using guessed type int var_C[3];
// 804E95A: using guessed type long double var_3C;

//----- (0804EA56) --------------------------------------------------------
int __cdecl PC_DollarDirective_evalfloat(int a1)
{
  long double v1; // fst7
  float v3; // [esp+0h] [ebp-478h]
  char s[1024]; // [esp+30h] [ebp-448h] BYREF
  int v6; // [esp+430h] [ebp-48h]
  int v7; // [esp+434h] [ebp-44h]
  int v8; // [esp+438h] [ebp-40h]
  long double v9; // [esp+43Ch] [ebp-3Ch]
  int v10; // [esp+448h] [ebp-30h]
  int v11; // [esp+44Ch] [ebp-2Ch]
  int v12; // [esp+450h] [ebp-28h]
  int v13; // [esp+454h] [ebp-24h]
  double v14[2]; // [esp+468h] [ebp-10h] BYREF

  if ( !PC_DollarEvaluate(a1, 0, v14, 0) )
    return 0;
  v12 = *(_DWORD *)(*(_DWORD *)(a1 + 132) + 92);
  v10 = *(_DWORD *)(*(_DWORD *)(a1 + 132) + 68);
  v11 = *(_DWORD *)(*(_DWORD *)(a1 + 132) + 68);
  v13 = 0;
  v3 = v14[0];
  v1 = Q_fabs(v3);
  sprintf(s, "%1.2f", (double)v1);
  v6 = 3;
  v7 = 10248;
  v8 = (__int64)v14[0];
  v9 = v14[0];
  PC_UnreadSourceToken(a1, s);
  if ( v14[0] < 0.0 )
    UnreadSignToken(a1);
  return 1;
}
// 804EA56: using guessed type double var_10[2];
// 804EA56: using guessed type long double var_3C;

//----- (0804EB7E) --------------------------------------------------------
int __cdecl PC_ReadDollarDirective(int a1)
{
  int i; // [esp+1Ch] [ebp-43Ch]
  char s2[1024]; // [esp+20h] [ebp-438h] BYREF
  int v5; // [esp+420h] [ebp-38h]
  int v6; // [esp+444h] [ebp-14h]

  if ( PC_ReadSourceToken(a1, s2) )
  {
    if ( v6 <= 0 )
    {
      if ( v5 == 4 )
      {
        for ( i = 0; (&off_815A0C0)[2 * i]; ++i )
        {
          if ( !strcmp((&off_815A0C0)[2 * i], s2) )
            return (*(&off_815A0C4 + 2 * i))(a1);
        }
      }
      PC_UnreadSourceToken(a1, s2);
      SourceError(a1, "unknown precompiler directive %s", s2);
      return 0;
    }
    else
    {
      PC_UnreadSourceToken(a1, s2);
      SourceError(a1, "found $ at end of line");
      return 0;
    }
  }
  else
  {
    SourceError(a1, "found $ without name");
    return 0;
  }
}
// 815A0C4: using guessed type int (__cdecl *off_815A0C4)(int);

//----- (0804ECB0) --------------------------------------------------------
int __cdecl PC_ReadToken(int *a1, char *s)
{
  size_t v2; // ebx
  char src; // [esp+20h] [ebp-448h] BYREF
  char v6[1023]; // [esp+21h] [ebp-447h] BYREF
  int v7; // [esp+420h] [ebp-48h]
  int v8; // [esp+45Ch] [ebp-Ch]

  while ( 1 )
  {
    do
    {
      while ( 1 )
      {
        while ( 1 )
        {
          if ( !PC_ReadSourceToken((int)a1, s) )
            return 0;
          if ( *((_DWORD *)s + 256) != 5 || *s != 35 )
            break;
          if ( !PC_ReadDirective((int)a1) )
            return 0;
        }
        if ( *((_DWORD *)s + 256) != 5 || *s != 36 )
          break;
        if ( !PC_ReadDollarDirective((int)a1) )
          return 0;
      }
      if ( *((_DWORD *)s + 256) == 1 && PC_ReadToken((int)a1, &src) )
      {
        if ( v7 == 1 )
        {
          s[strlen(s) - 1] = 0;
          v2 = strlen(s);
          if ( strlen(v6) + v2 + 1 > 0x3FF )
          {
            SourceError((int)a1, "string longer than MAX_TOKEN %d\n", 1024);
            return 0;
          }
          strcat(s, v6);
        }
        else
        {
          PC_UnreadToken((int)a1, &src);
        }
      }
    }
    while ( a1[38] );
    if ( *((_DWORD *)s + 256) != 4 )
      break;
    v8 = PC_FindHashedDefine(a1[36], s);
    if ( !v8 )
      break;
    if ( !PC_ExpandDefineIntoSource((int)a1, s, v8) )
      return 0;
  }
  memcpy(a1 + 39, s, 0x42Cu);
  return 1;
}

//----- (0804EEAC) --------------------------------------------------------
int __cdecl PC_ExpectTokenString(int *a1, char *s2)
{
  char s1[1080]; // [esp+20h] [ebp-438h] BYREF

  if ( PC_ReadToken(a1, s1) )
  {
    if ( !strcmp(s1, s2) )
    {
      return 1;
    }
    else
    {
      SourceError((int)a1, "expected %s, found %s", s2, s1);
      return 0;
    }
  }
  else
  {
    SourceError((int)a1, "couldn't find expected %s", s2);
    return 0;
  }
}

//----- (0804EF50) --------------------------------------------------------
int __cdecl PC_ExpectTokenType(int *a1, int a2, int a3, char *s)
{
  char dest[1032]; // [esp+20h] [ebp-408h] BYREF

  if ( !PC_ReadToken(a1, s) )
  {
    SourceError((int)a1, "couldn't read expected token");
    return 0;
  }
  if ( *((_DWORD *)s + 256) != a2 )
  {
    strcpy(dest, &byte_813A549);
    if ( a2 == 1 )
      strcpy(dest, "string");
    if ( a2 == 2 )
      strcpy(dest, "literal");
    if ( a2 == 3 )
      strcpy(dest, "number");
    if ( a2 == 4 )
      strcpy(dest, "name");
    if ( a2 == 5 )
      strcpy(dest, "punctuation");
    SourceError((int)a1, "expected a %s, found %s", dest, s);
    return 0;
  }
  if ( *((_DWORD *)s + 256) != 3 )
  {
    if ( *((_DWORD *)s + 256) == 5 && *((_DWORD *)s + 257) != a3 )
    {
      SourceError((int)a1, "found %s", s);
      return 0;
    }
    return 1;
  }
  if ( (a3 & *((_DWORD *)s + 257)) == a3 )
    return 1;
  if ( (a3 & 8) != 0 )
    strcpy(dest, "decimal");
  if ( (a3 & 0x100) != 0 )
    strcpy(dest, "hex");
  if ( (a3 & 0x200) != 0 )
    strcpy(dest, "octal");
  if ( (a3 & 0x400) != 0 )
    strcpy(dest, "binary");
  if ( (a3 & 0x2000) != 0 )
    strcat(dest, " long");
  if ( (a3 & 0x4000) != 0 )
    strcat(dest, " unsigned");
  if ( (a3 & 0x800) != 0 )
    strcat(dest, " float");
  if ( (a3 & 0x1000) != 0 )
    strcat(dest, " integer");
  SourceError((int)a1, "expected %s, found %s", dest, s);
  return 0;
}

//----- (0804F230) --------------------------------------------------------
int __cdecl PC_ExpectAnyToken(int *a1, char *s)
{
  if ( PC_ReadToken(a1, s) )
    return 1;
  SourceError((int)a1, "couldn't read expected token");
  return 0;
}

//----- (0804F274) --------------------------------------------------------
int __cdecl PC_CheckTokenString(int *a1, char *s2)
{
  char s1[1080]; // [esp+20h] [ebp-438h] BYREF

  if ( !PC_ReadToken(a1, s1) )
    return 0;
  if ( !strcmp(s1, s2) )
    return 1;
  PC_UnreadSourceToken((int)a1, s1);
  return 0;
}

//----- (0804F2EE) --------------------------------------------------------
int __cdecl PC_CheckTokenType(int *a1, int a2, int a3, void *dest)
{
  char src[1024]; // [esp+20h] [ebp-438h] BYREF
  int v7; // [esp+420h] [ebp-38h]
  int v8; // [esp+424h] [ebp-34h]

  if ( !PC_ReadToken(a1, src) )
    return 0;
  if ( v7 == a2 && (v8 & a3) == a3 )
  {
    memcpy(dest, src, 0x42Cu);
    return 1;
  }
  else
  {
    PC_UnreadSourceToken((int)a1, src);
    return 0;
  }
}

//----- (0804F380) --------------------------------------------------------
int __cdecl PC_SkipUntilString(int *a1, char *s2)
{
  char s1[1080]; // [esp+20h] [ebp-438h] BYREF

  while ( PC_ReadToken(a1, s1) )
  {
    if ( !strcmp(s1, s2) )
      return 1;
  }
  return 0;
}

//----- (0804F3DC) --------------------------------------------------------
int __cdecl PC_UnreadLastToken(int a1)
{
  return PC_UnreadSourceToken(a1, (void *)(a1 + 156));
}

//----- (0804F3FC) --------------------------------------------------------
int __cdecl PC_UnreadToken(int a1, void *src)
{
  return PC_UnreadSourceToken(a1, src);
}

//----- (0804F416) --------------------------------------------------------
char *__cdecl PC_SetIncludePath(int a1, char *src)
{
  char *result; // eax

  strncpy((char *)(a1 + 64), src, 0x40u);
  result = (char *)strlen((const char *)(a1 + 64));
  if ( result[a1 + 63] != 92 )
  {
    result = (char *)strlen((const char *)(a1 + 64));
    if ( result[a1 + 63] != 47 )
      return strcat((char *)(a1 + 64), "/");
  }
  return result;
}

//----- (0804F498) --------------------------------------------------------
_DWORD *__cdecl LoadSourceFile(char *src)
{
  char *v3; // [esp+1Ch] [ebp-Ch]
  _DWORD *s; // [esp+20h] [ebp-8h]

  v3 = LoadScriptFile(src);
  if ( !v3 )
    return 0;
  *((_DWORD *)v3 + 296) = 0;
  s = GetMemory(1224);
  memset(s, 0, 0x4C8u);
  strncpy((char *)s, src, 0x40u);
  s[33] = v3;
  s[34] = 0;
  s[35] = 0;
  s[37] = 0;
  s[38] = 0;
  s[36] = GetClearedMemory(0x1000u);
  PC_AddGlobalDefinesToSource((int)s);
  return s;
}

//----- (0804F580) --------------------------------------------------------
_DWORD *__cdecl LoadSourceMemory(void *a1, size_t n, char *src)
{
  char *v5; // [esp+1Ch] [ebp-Ch]
  _DWORD *s; // [esp+20h] [ebp-8h]

  v5 = LoadScriptMemory(a1, n, src);
  if ( !v5 )
    return 0;
  *((_DWORD *)v5 + 296) = 0;
  s = GetMemory(1224);
  memset(s, 0, 0x4C8u);
  strncpy((char *)s, src, 0x40u);
  s[33] = v5;
  s[34] = 0;
  s[35] = 0;
  s[37] = 0;
  s[38] = 0;
  s[36] = GetClearedMemory(0x1000u);
  PC_AddGlobalDefinesToSource((int)s);
  return s;
}

//----- (0804F676) --------------------------------------------------------
void __cdecl FreeSource(_DWORD *a1)
{
  int i; // [esp+Ch] [ebp-1Ch]
  int v2; // [esp+10h] [ebp-18h]
  int v3; // [esp+14h] [ebp-14h]
  int v4; // [esp+18h] [ebp-10h]
  int v5; // [esp+1Ch] [ebp-Ch]

  while ( a1[33] )
  {
    v5 = a1[33];
    a1[33] = *(_DWORD *)(v5 + 1184);
    FreeScript(v5);
  }
  while ( a1[34] )
  {
    v4 = a1[34];
    a1[34] = *(_DWORD *)(v4 + 1064);
    PC_FreeToken(v4);
  }
  for ( i = 0; i <= 1023; ++i )
  {
    while ( *(_DWORD *)(a1[36] + 4 * i) )
    {
      v3 = *(_DWORD *)(a1[36] + 4 * i);
      *(_DWORD *)(a1[36] + 4 * i) = *(_DWORD *)(v3 + 28);
      PC_FreeDefine(v3);
    }
  }
  while ( a1[37] )
  {
    v2 = a1[37];
    a1[37] = *(_DWORD *)(v2 + 12);
    FreeMemory(v2);
  }
  if ( a1[36] )
    FreeMemory(a1[36]);
  FreeMemory((int)a1);
}

//----- (0804F7F6) --------------------------------------------------------
int __cdecl PC_LoadSourceHandle(char *src)
{
  int i; // [esp+10h] [ebp-8h]
  char *v4; // [esp+14h] [ebp-4h]

  for ( i = 1; i <= 63 && (&dword_8185AC0)[i]; ++i )
    ;
  if ( i > 63 )
    return 0;
  v4 = (char *)LoadSourceFile(src);
  if ( !v4 )
    return 0;
  (&dword_8185AC0)[i] = v4;
  return i;
}

//----- (0804F866) --------------------------------------------------------
int __cdecl PC_FreeSourceHandle(int a1)
{
  if ( a1 <= 0 || a1 > 63 )
    return 0;
  if ( !(&dword_8185AC0)[a1] )
    return 0;
  FreeSource((&dword_8185AC0)[a1]);
  (&dword_8185AC0)[a1] = 0;
  return 1;
}

//----- (0804F8C6) --------------------------------------------------------
int __cdecl PC_ReadTokenHandle(int a1, int a2)
{
  int v4; // [esp+1Ch] [ebp-43Ch]
  char src[1024]; // [esp+20h] [ebp-438h] BYREF
  int v6; // [esp+420h] [ebp-38h]
  int v7; // [esp+424h] [ebp-34h]
  int v8; // [esp+428h] [ebp-30h]
  long double v9[3]; // [esp+42Ch] [ebp-2Ch]

  if ( a1 <= 0 || a1 > 63 )
    return 0;
  if ( !(&dword_8185AC0)[a1] )
    return 0;
  v4 = PC_ReadToken((int *)(&dword_8185AC0)[a1], src);
  strcpy((char *)(a2 + 16), src);
  *(_DWORD *)a2 = v6;
  *(_DWORD *)(a2 + 4) = v7;
  *(_DWORD *)(a2 + 8) = v8;
  *(float *)(a2 + 12) = v9[0];
  if ( *(_DWORD *)a2 == 1 )
    StripDoubleQuotes((char *)(a2 + 16));
  return v4;
}
// 804F8C6: using guessed type long double var_2C[3];

//----- (0804F98C) --------------------------------------------------------
int __cdecl PC_ReadLineHandle(int a1, int a2)
{
  int v4; // [esp+1Ch] [ebp-43Ch]
  char src[1024]; // [esp+20h] [ebp-438h] BYREF
  int v6; // [esp+420h] [ebp-38h]
  int v7; // [esp+424h] [ebp-34h]
  int v8; // [esp+428h] [ebp-30h]
  long double v9[3]; // [esp+42Ch] [ebp-2Ch]

  if ( a1 <= 0 || a1 > 63 )
    return 0;
  if ( !(&dword_8185AC0)[a1] )
    return 0;
  v4 = PC_ReadLine((int)(&dword_8185AC0)[a1], src);
  strcpy((char *)(a2 + 16), src);
  *(_DWORD *)a2 = v6;
  *(_DWORD *)(a2 + 4) = v7;
  *(_DWORD *)(a2 + 8) = v8;
  *(float *)(a2 + 12) = v9[0];
  if ( *(_DWORD *)a2 == 1 )
    StripDoubleQuotes((char *)(a2 + 16));
  return v4;
}
// 804F98C: using guessed type long double var_2C[3];

//----- (0804FA52) --------------------------------------------------------
int __cdecl PC_SourceFileAndLine(int a1, char *dest, _DWORD *a3)
{
  char *src; // [esp+14h] [ebp-4h]

  if ( a1 <= 0 || a1 > 63 )
    return 0;
  if ( !(&dword_8185AC0)[a1] )
    return 0;
  src = (char *)*((_DWORD *)(&dword_8185AC0)[a1] + 33);
  if ( src )
  {
    strcpy(dest, src);
    *a3 = *((_DWORD *)src + 23);
  }
  else
  {
    strcpy(dest, (&dword_8185AC0)[a1]);
    *a3 = 0;
  }
  return 1;
}

//----- (0804FAEC) --------------------------------------------------------
int *PC_CheckOpenSourceHandles()
{
  int *result; // eax
  int i; // [esp+14h] [ebp-4h] BYREF

  for ( i = 1; i <= 63; ++i )
  {
    if ( (&dword_8185AC0)[i] )
      Com_Printf("^1Error: file %s still open in precompiler\n", *((const char **)(&dword_8185AC0)[i] + 33));
    result = &i;
  }
  return result;
}

//----- (0804FB38) --------------------------------------------------------
long double __cdecl Q_fabs(float a1)
{
  return (float)fabs(a1);
}

//----- (0804FB54) --------------------------------------------------------
int __cdecl PS_CreatePunctuationTable(int a1, int a2)
{
  int result; // eax
  size_t v3; // ebx
  const char **v4; // [esp+14h] [ebp-14h]
  int v5; // [esp+18h] [ebp-10h]
  int j; // [esp+1Ch] [ebp-Ch]
  int i; // [esp+20h] [ebp-8h]

  if ( !*(_DWORD *)(a1 + 112) )
    *(_DWORD *)(a1 + 112) = GetMemory(1024);
  memset(*(void **)(a1 + 112), 0, 0x400u);
  for ( i = 0; ; ++i )
  {
    result = a2;
    if ( !*(_DWORD *)(a2 + 12 * i) )
      break;
    v4 = (const char **)(a2 + 12 * i);
    v5 = 0;
    for ( j = *(_DWORD *)(*(_DWORD *)(a1 + 112) + 4 * **v4); j; j = *(_DWORD *)(j + 8) )
    {
      v3 = strlen(*(const char **)j);
      if ( v3 < strlen(*v4) )
      {
        v4[2] = (const char *)j;
        if ( v5 )
          *(_DWORD *)(v5 + 8) = v4;
        else
          *(_DWORD *)(*(_DWORD *)(a1 + 112) + 4 * **v4) = v4;
        break;
      }
      v5 = j;
    }
    if ( !j )
    {
      v4[2] = 0;
      if ( v5 )
        *(_DWORD *)(v5 + 8) = v4;
      else
        *(_DWORD *)(*(_DWORD *)(a1 + 112) + 4 * **v4) = v4;
    }
  }
  return result;
}

//----- (0804FD26) --------------------------------------------------------
void ScriptError(int a1, char *format, ...)
{
  char s[1032]; // [esp+20h] [ebp-408h] BYREF
  va_list va; // [esp+438h] [ebp+10h] BYREF

  va_start(va, format);
  if ( (*(_BYTE *)(a1 + 104) & 1) == 0 )
  {
    vsprintf(s, format, va);
    Com_Printf("^1Error: file %s, line %d: %s\n", (const char *)a1, *(_DWORD *)(a1 + 92), s);
  }
}
// 804FD26: using guessed type int arg_0;

//----- (0804FD90) --------------------------------------------------------
void ScriptWarning(int a1, char *format, ...)
{
  char s[1032]; // [esp+20h] [ebp-408h] BYREF
  va_list va; // [esp+438h] [ebp+10h] BYREF

  va_start(va, format);
  if ( (*(_DWORD *)(a1 + 104) & 2) == 0 )
  {
    vsprintf(s, format, va);
    Com_Printf("^3Warning: file %s, line %d: %s\n", (const char *)a1, *(_DWORD *)(a1 + 92), s);
  }
}
// 804FD90: using guessed type int arg_0;

//----- (0804FDFA) --------------------------------------------------------
int __cdecl SetScriptPunctuations(int a1, int a2)
{
  int result; // eax

  if ( a2 )
  {
    PS_CreatePunctuationTable(a1, a2);
    result = a2;
    *(_DWORD *)(a1 + 108) = a2;
  }
  else
  {
    PS_CreatePunctuationTable(a1, (int)&off_815A160);
    result = a1;
    *(_DWORD *)(a1 + 108) = &off_815A160;
  }
  return result;
}
// 815A160: using guessed type char *off_815A160;

//----- (0804FE42) --------------------------------------------------------
int __cdecl PS_ReadWhiteSpace(int a1)
{
  while ( 1 )
  {
    while ( **(char **)(a1 + 68) <= 32 )
    {
      if ( !**(_BYTE **)(a1 + 68) )
        return 0;
      if ( **(_BYTE **)(a1 + 68) == 10 )
        ++*(_DWORD *)(a1 + 92);
      ++*(_DWORD *)(a1 + 68);
    }
    if ( **(_BYTE **)(a1 + 68) != 47 )
      break;
    if ( *(_BYTE *)(*(_DWORD *)(a1 + 68) + 1) == 47 )
    {
      ++*(_DWORD *)(a1 + 68);
      do
      {
        if ( !*(_BYTE *)++*(_DWORD *)(a1 + 68) )
          return 0;
      }
      while ( **(_BYTE **)(a1 + 68) != 10 );
      ++*(_DWORD *)(a1 + 92);
      if ( !*(_BYTE *)++*(_DWORD *)(a1 + 68) )
        return 0;
    }
    else
    {
      if ( *(_BYTE *)(*(_DWORD *)(a1 + 68) + 1) != 42 )
        return 1;
      ++*(_DWORD *)(a1 + 68);
      do
      {
        if ( !*(_BYTE *)++*(_DWORD *)(a1 + 68) )
          return 0;
        if ( **(_BYTE **)(a1 + 68) == 10 )
          ++*(_DWORD *)(a1 + 92);
      }
      while ( **(_BYTE **)(a1 + 68) != 42 || *(_BYTE *)(*(_DWORD *)(a1 + 68) + 1) != 47 );
      if ( !*(_BYTE *)++*(_DWORD *)(a1 + 68) )
        return 0;
      if ( !*(_BYTE *)++*(_DWORD *)(a1 + 68) )
        return 0;
    }
  }
  return 1;
}

//----- (0804FF92) --------------------------------------------------------
int __cdecl PS_ReadEscapeCharacter(int a1, char *a2)
{
  int v3; // [esp+Ch] [ebp-Ch]
  int v4; // [esp+Ch] [ebp-Ch]
  int v5; // [esp+10h] [ebp-8h]
  int v6; // [esp+10h] [ebp-8h]
  char v7; // [esp+14h] [ebp-4h]
  int v8; // [esp+14h] [ebp-4h]
  int v9; // [esp+14h] [ebp-4h]
  int v10; // [esp+14h] [ebp-4h]

  switch ( *(_BYTE *)++*(_DWORD *)(a1 + 68) )
  {
    case '"':
      v7 = 34;
      goto LABEL_37;
    case '\'':
      v7 = 39;
      goto LABEL_37;
    case '?':
      v7 = 63;
      goto LABEL_37;
    case '\\':
      v7 = 92;
      goto LABEL_37;
    case 'a':
      v7 = 7;
      goto LABEL_37;
    case 'b':
      v7 = 8;
      goto LABEL_37;
    case 'f':
      v7 = 12;
      goto LABEL_37;
    case 'n':
      v7 = 10;
      goto LABEL_37;
    case 'r':
      v7 = 13;
      goto LABEL_37;
    case 't':
      v7 = 9;
      goto LABEL_37;
    case 'v':
      v7 = 11;
      goto LABEL_37;
    case 'x':
      ++*(_DWORD *)(a1 + 68);
      v3 = 0;
      v5 = 0;
      break;
    default:
      if ( **(char **)(a1 + 68) <= 47 || **(char **)(a1 + 68) > 57 )
        ScriptError(a1, "unknown escape char");
      v4 = 0;
      v6 = 0;
      while ( 1 )
      {
        v10 = **(char **)(a1 + 68);
        if ( v10 <= 47 || v10 > 57 )
          break;
        v6 = v10 - 48 + 10 * v6;
        ++v4;
        ++*(_DWORD *)(a1 + 68);
      }
      --*(_DWORD *)(a1 + 68);
      if ( v6 > 255 )
      {
        ScriptWarning(a1, "too large value in escape character");
        LOBYTE(v6) = -1;
      }
      v7 = v6;
      goto LABEL_37;
  }
  while ( 1 )
  {
    v8 = **(char **)(a1 + 68);
    if ( v8 > 47 && v8 <= 57 )
    {
      v9 = v8 - 48;
      goto LABEL_23;
    }
    if ( v8 > 64 && v8 <= 90 )
    {
      v9 = v8 - 55;
      goto LABEL_23;
    }
    if ( v8 <= 96 || v8 > 122 )
      break;
    v9 = v8 - 87;
LABEL_23:
    v5 = v9 + 16 * v5;
    ++v3;
    ++*(_DWORD *)(a1 + 68);
  }
  --*(_DWORD *)(a1 + 68);
  if ( v5 > 255 )
  {
    ScriptWarning(a1, "too large value in escape character");
    LOBYTE(v5) = -1;
  }
  v7 = v5;
LABEL_37:
  ++*(_DWORD *)(a1 + 68);
  *a2 = v7;
  return 1;
}

//----- (080501AA) --------------------------------------------------------
int __cdecl PS_ReadString(_DWORD *a1, int a2, int a3)
{
  _BYTE *v3; // edx
  _BYTE *v4; // edx
  int v7; // [esp+18h] [ebp-10h]
  int v8; // [esp+1Ch] [ebp-Ch]
  int v9; // [esp+20h] [ebp-8h]
  int v10; // [esp+20h] [ebp-8h]

  if ( a3 == 34 )
    *(_DWORD *)(a2 + 1024) = 1;
  else
    *(_DWORD *)(a2 + 1024) = 2;
  v3 = (_BYTE *)a1[17];
  a1[17] = v3 + 1;
  *(_BYTE *)a2 = *v3;
  v9 = 1;
  while ( 1 )
  {
    while ( 1 )
    {
      while ( 1 )
      {
        if ( v9 > 1021 )
        {
          ScriptError((int)a1, "string longer than MAX_TOKEN = %d", 1024);
          return 0;
        }
        if ( *(_BYTE *)a1[17] != 92 || (a1[26] & 8) != 0 )
          break;
        if ( !PS_ReadEscapeCharacter((int)a1, (char *)(a2 + v9)) )
        {
          *(_BYTE *)(v9 + a2) = 0;
          return 0;
        }
        ++v9;
      }
      if ( *(char *)a1[17] == a3 )
        break;
      if ( !*(_BYTE *)a1[17] )
      {
        *(_BYTE *)(v9 + a2) = 0;
        ScriptError((int)a1, "missing trailing quote");
        return 0;
      }
      if ( *(_BYTE *)a1[17] == 10 )
      {
        *(_BYTE *)(v9 + a2) = 0;
        ScriptError((int)a1, "newline inside string %s", (const char *)a2);
        return 0;
      }
      v4 = (_BYTE *)a1[17];
      a1[17] = v4 + 1;
      *(_BYTE *)(a2 + v9++) = *v4;
    }
    ++a1[17];
    if ( (a1[26] & 4) != 0 )
      break;
    v7 = a1[17];
    v8 = a1[23];
    if ( !PS_ReadWhiteSpace((int)a1) )
    {
      a1[17] = v7;
      a1[23] = v8;
      break;
    }
    if ( *(char *)a1[17] != a3 )
    {
      a1[17] = v7;
      a1[23] = v8;
      break;
    }
    ++a1[17];
  }
  *(_BYTE *)(a2 + v9) = a3;
  v10 = v9 + 1;
  *(_BYTE *)(v10 + a2) = 0;
  *(_DWORD *)(a2 + 1028) = v10;
  return 1;
}
// 80501AA: using guessed type _DWORD arg_4;

//----- (080503CE) --------------------------------------------------------
int __cdecl PS_ReadName(int a1, int a2)
{
  _BYTE *v2; // edx
  char v5; // [esp+1Fh] [ebp-9h]
  int v6; // [esp+20h] [ebp-8h]

  v6 = 0;
  *(_DWORD *)(a2 + 1024) = 4;
  do
  {
    v2 = *(_BYTE **)(a1 + 68);
    *(_DWORD *)(a1 + 68) = v2 + 1;
    *(_BYTE *)(a2 + v6++) = *v2;
    if ( v6 > 1023 )
    {
      ScriptError(a1, "name longer than MAX_TOKEN = %d", 1024);
      return 0;
    }
    v5 = **(_BYTE **)(a1 + 68);
  }
  while ( v5 > 96 && v5 <= 122 || v5 > 64 && v5 <= 90 || v5 > 47 && v5 <= 57 || v5 == 95 );
  *(_BYTE *)(v6 + a2) = 0;
  *(_DWORD *)(a2 + 1028) = v6;
  return 1;
}

//----- (0805048E) --------------------------------------------------------
int __cdecl NumberValue(_BYTE *a1, __int16 a2, _DWORD *a3, long double *a4)
{
  __int64 v4; // rax
  int v6; // [esp+Ch] [ebp-Ch]
  char *i; // [esp+20h] [ebp+8h]
  _BYTE *j; // [esp+20h] [ebp+8h]
  _BYTE *k; // [esp+20h] [ebp+8h]

  v6 = 0;
  *a3 = 0;
  *(_DWORD *)a4 = 0;
  *((_DWORD *)a4 + 1) = 0;
  *((_DWORD *)a4 + 2) = 0;
  if ( (a2 & 0x800) != 0 )
  {
    while ( *a1 )
    {
      LODWORD(v4) = a1;
      if ( *a1 == 46 )
      {
        if ( v6 )
          return v4;
        v6 = 10;
        ++a1;
      }
      if ( v6 )
      {
        *a4 = (long double)((char)*a1 - 48) / (long double)(unsigned int)v6 + *a4;
        v6 *= 10;
      }
      else
      {
        *a4 = *a4 * 10.0 + (long double)((char)*a1 - 48);
      }
      ++a1;
    }
    v4 = (__int64)*a4;
    *a3 = v4;
  }
  else if ( (a2 & 8) != 0 )
  {
    while ( *a1 )
      *a3 = (char)*a1++ + 10 * *a3 - 48;
    LODWORD(v4) = *a3;
    *a4 = (long double)(unsigned int)*a3;
  }
  else if ( (a2 & 0x100) != 0 )
  {
    for ( i = a1 + 2; *i; ++i )
    {
      *a3 *= 16;
      if ( *i <= 96 || *i > 102 )
      {
        if ( *i <= 64 || *i > 70 )
          *a3 = *a3 + *i - 48;
        else
          *a3 = *a3 + *i - 55;
      }
      else
      {
        *a3 = *a3 + *i - 87;
      }
    }
    LODWORD(v4) = *a3;
    *a4 = (long double)(unsigned int)*a3;
  }
  else if ( (a2 & 0x200) != 0 )
  {
    for ( j = a1 + 1; *j; ++j )
      *a3 = (char)*j + 8 * *a3 - 48;
    LODWORD(v4) = *a3;
    *a4 = (long double)(unsigned int)*a3;
  }
  else
  {
    LODWORD(v4) = a2 & 0x400;
    if ( (a2 & 0x400) != 0 )
    {
      for ( k = a1 + 2; *k; ++k )
        *a3 = (char)*k + 2 * *a3 - 48;
      LODWORD(v4) = *a3;
      *a4 = (long double)(unsigned int)*a3;
    }
  }
  return v4;
}

//----- (08050746) --------------------------------------------------------
int __cdecl PS_ReadNumber(int a1, int a2)
{
  _BYTE *v2; // edx
  _BYTE *v3; // edx
  _BYTE *v4; // edx
  _BYTE *v5; // edx
  _BYTE *v6; // edx
  _BYTE *v7; // edx
  _BYTE *v8; // edx
  int v9; // edx
  char i; // [esp+23h] [ebp-15h]
  char j; // [esp+23h] [ebp-15h]
  char v14; // [esp+23h] [ebp-15h]
  char v15; // [esp+23h] [ebp-15h]
  int v16; // [esp+24h] [ebp-14h]
  int v17; // [esp+28h] [ebp-10h]
  int k; // [esp+2Ch] [ebp-Ch]
  int v19; // [esp+30h] [ebp-8h]

  v19 = 0;
  *(_DWORD *)(a2 + 1024) = 3;
  if ( **(_BYTE **)(a1 + 68) == 48
    && (*(_BYTE *)(*(_DWORD *)(a1 + 68) + 1) == 120 || *(_BYTE *)(*(_DWORD *)(a1 + 68) + 1) == 88) )
  {
    v2 = *(_BYTE **)(a1 + 68);
    *(_DWORD *)(a1 + 68) = v2 + 1;
    *(_BYTE *)a2 = *v2;
    v3 = *(_BYTE **)(a1 + 68);
    *(_DWORD *)(a1 + 68) = v3 + 1;
    *(_BYTE *)(a2 + 1) = *v3;
    v19 = 2;
    for ( i = **(_BYTE **)(a1 + 68); i > 47 && i <= 57 || i > 96 && i <= 102 || i == 65; i = **(_BYTE **)(a1 + 68) )
    {
      v4 = *(_BYTE **)(a1 + 68);
      *(_DWORD *)(a1 + 68) = v4 + 1;
      *(_BYTE *)(a2 + v19++) = *v4;
      if ( v19 > 1023 )
      {
        ScriptError(a1, "hexadecimal number longer than MAX_TOKEN = %d", 1024);
        return 0;
      }
    }
    *(_DWORD *)(a2 + 1028) |= 0x100u;
    goto LABEL_40;
  }
  if ( **(_BYTE **)(a1 + 68) == 48
    && (*(_BYTE *)(*(_DWORD *)(a1 + 68) + 1) == 98 || *(_BYTE *)(*(_DWORD *)(a1 + 68) + 1) == 66) )
  {
    v5 = *(_BYTE **)(a1 + 68);
    *(_DWORD *)(a1 + 68) = v5 + 1;
    *(_BYTE *)a2 = *v5;
    v6 = *(_BYTE **)(a1 + 68);
    *(_DWORD *)(a1 + 68) = v6 + 1;
    *(_BYTE *)(a2 + 1) = *v6;
    v19 = 2;
    for ( j = **(_BYTE **)(a1 + 68); j == 48 || j == 49; j = **(_BYTE **)(a1 + 68) )
    {
      v7 = *(_BYTE **)(a1 + 68);
      *(_DWORD *)(a1 + 68) = v7 + 1;
      *(_BYTE *)(a2 + v19++) = *v7;
      if ( v19 > 1023 )
      {
        ScriptError(a1, "binary number longer than MAX_TOKEN = %d", 1024);
        return 0;
      }
    }
    *(_DWORD *)(a2 + 1028) |= 0x400u;
    goto LABEL_40;
  }
  v17 = 0;
  v16 = 0;
  if ( **(_BYTE **)(a1 + 68) == 48 )
    v17 = 1;
  while ( 1 )
  {
    v14 = **(_BYTE **)(a1 + 68);
    if ( v14 != 46 )
      break;
    v16 = 1;
LABEL_33:
    v8 = *(_BYTE **)(a1 + 68);
    *(_DWORD *)(a1 + 68) = v8 + 1;
    *(_BYTE *)(a2 + v19++) = *v8;
    if ( v19 > 1022 )
    {
      ScriptError(a1, "number longer than MAX_TOKEN = %d", 1024);
      return 0;
    }
  }
  if ( v14 == 56 || v14 == 57 )
  {
    v17 = 0;
    goto LABEL_33;
  }
  if ( v14 > 47 && v14 <= 57 )
    goto LABEL_33;
  if ( v17 )
    v9 = *(_DWORD *)(a2 + 1028) | 0x200;
  else
    v9 = *(_DWORD *)(a2 + 1028) | 8;
  *(_DWORD *)(a2 + 1028) = v9;
  if ( v16 )
    *(_DWORD *)(a2 + 1028) |= 0x800u;
LABEL_40:
  for ( k = 0; k <= 1; ++k )
  {
    v15 = **(_BYTE **)(a1 + 68);
    if ( (v15 == 108 || v15 == 76) && (*(_DWORD *)(a2 + 1028) & 0x2000) == 0 )
    {
      ++*(_DWORD *)(a1 + 68);
      *(_DWORD *)(a2 + 1028) |= 0x2000u;
    }
    else if ( (v15 == 117 || v15 == 85) && (*(_DWORD *)(a2 + 1028) & 0x4800) == 0 )
    {
      ++*(_DWORD *)(a1 + 68);
      *(_DWORD *)(a2 + 1028) |= 0x4000u;
    }
  }
  *(_BYTE *)(v19 + a2) = 0;
  NumberValue((_BYTE *)a2, *(_DWORD *)(a2 + 1028), (_DWORD *)(a2 + 1032), (long double *)(a2 + 1036));
  if ( (*(_DWORD *)(a2 + 1028) & 0x800) == 0 )
    *(_DWORD *)(a2 + 1028) |= 0x1000u;
  return 1;
}

//----- (08050B78) --------------------------------------------------------
int __cdecl PS_ReadLiteral(int a1, int a2)
{
  _BYTE *v2; // edx
  _BYTE *v3; // edx
  _BYTE *v4; // edx

  *(_DWORD *)(a2 + 1024) = 2;
  v2 = *(_BYTE **)(a1 + 68);
  *(_DWORD *)(a1 + 68) = v2 + 1;
  *(_BYTE *)a2 = *v2;
  if ( **(_BYTE **)(a1 + 68) )
  {
    if ( **(_BYTE **)(a1 + 68) == 92 )
    {
      if ( !PS_ReadEscapeCharacter(a1, (char *)(a2 + 1)) )
        return 0;
    }
    else
    {
      v3 = *(_BYTE **)(a1 + 68);
      *(_DWORD *)(a1 + 68) = v3 + 1;
      *(_BYTE *)(a2 + 1) = *v3;
    }
    if ( **(_BYTE **)(a1 + 68) != 39 )
    {
      ScriptWarning(a1, "too many characters in literal, ignored");
      while ( **(_BYTE **)(a1 + 68) && **(_BYTE **)(a1 + 68) != 39 && **(_BYTE **)(a1 + 68) != 10 )
        ++*(_DWORD *)(a1 + 68);
      if ( **(_BYTE **)(a1 + 68) == 39 )
        ++*(_DWORD *)(a1 + 68);
    }
    v4 = *(_BYTE **)(a1 + 68);
    *(_DWORD *)(a1 + 68) = v4 + 1;
    *(_BYTE *)(a2 + 2) = *v4;
    *(_BYTE *)(a2 + 3) = 0;
    *(_DWORD *)(a2 + 1028) = *(char *)(a2 + 1);
    return 1;
  }
  else
  {
    ScriptError(a1, "end of file before trailing '");
    return 0;
  }
}

//----- (08050C96) --------------------------------------------------------
int __cdecl PS_ReadPunctuation(int a1, char *dest)
{
  int i; // [esp+1Ch] [ebp-Ch]
  char *s; // [esp+20h] [ebp-8h]
  size_t n; // [esp+24h] [ebp-4h]

  for ( i = *(_DWORD *)(*(_DWORD *)(a1 + 112) + 4 * **(char **)(a1 + 68)); i; i = *(_DWORD *)(i + 8) )
  {
    s = *(char **)i;
    n = strlen(*(const char **)i);
    if ( n + *(_DWORD *)(a1 + 68) <= *(_DWORD *)(a1 + 72) && !strncmp(*(const char **)(a1 + 68), s, n) )
    {
      strncpy(dest, s, 0x400u);
      *(_DWORD *)(a1 + 68) += n;
      *((_DWORD *)dest + 256) = 5;
      *((_DWORD *)dest + 257) = *(_DWORD *)(i + 4);
      return 1;
    }
  }
  return 0;
}

//----- (08050D74) --------------------------------------------------------
int __cdecl PS_ReadPrimitive(int a1, _BYTE *src)
{
  _BYTE *v2; // edx
  int v5; // [esp+10h] [ebp-8h]

  v5 = 0;
  while ( **(char **)(a1 + 68) > 32 && **(_BYTE **)(a1 + 68) != 59 )
  {
    if ( v5 > 1023 )
    {
      ScriptError(a1, "primitive token longer than MAX_TOKEN = %d", 1024);
      return 0;
    }
    v2 = *(_BYTE **)(a1 + 68);
    *(_DWORD *)(a1 + 68) = v2 + 1;
    src[v5++] = *v2;
  }
  src[v5] = 0;
  memcpy((void *)(a1 + 116), src, 0x42Cu);
  return 1;
}

//----- (08050E1C) --------------------------------------------------------
int __cdecl PS_ReadToken(_DWORD *a1, _BYTE *dest)
{
  if ( a1[25] )
  {
    a1[25] = 0;
    memcpy(dest, a1 + 29, 0x42Cu);
    return 1;
  }
  else
  {
    a1[19] = a1[17];
    a1[24] = a1[23];
    memset(dest, 0, 0x42Cu);
    a1[20] = a1[17];
    *((_DWORD *)dest + 262) = a1[17];
    if ( PS_ReadWhiteSpace((int)a1) )
    {
      a1[21] = a1[17];
      *((_DWORD *)dest + 263) = a1[17];
      *((_DWORD *)dest + 264) = a1[23];
      *((_DWORD *)dest + 265) = a1[23] - a1[24];
      if ( *(_BYTE *)a1[17] == 34 )
      {
        if ( !PS_ReadString(a1, (int)dest, 34) )
          return 0;
      }
      else if ( *(_BYTE *)a1[17] == 39 )
      {
        if ( !PS_ReadString(a1, (int)dest, 39) )
          return 0;
      }
      else if ( *(char *)a1[17] > 47 && *(char *)a1[17] <= 57
             || *(_BYTE *)a1[17] == 46 && *(char *)(a1[17] + 1) > 47 && *(char *)(a1[17] + 1) <= 57 )
      {
        if ( !PS_ReadNumber((int)a1, (int)dest) )
          return 0;
      }
      else
      {
        if ( (a1[26] & 0x10) != 0 )
          return PS_ReadPrimitive((int)a1, dest);
        if ( *(char *)a1[17] > 96 && *(char *)a1[17] <= 122
          || *(char *)a1[17] > 64 && *(char *)a1[17] <= 90
          || *(_BYTE *)a1[17] == 95 )
        {
          if ( !PS_ReadName((int)a1, (int)dest) )
            return 0;
        }
        else if ( !PS_ReadPunctuation((int)a1, dest) )
        {
          ScriptError((int)a1, "can't read token");
          return 0;
        }
      }
      memcpy(a1 + 29, dest, 0x42Cu);
      return 1;
    }
    return 0;
  }
}

//----- (080510BA) --------------------------------------------------------
int __cdecl PS_ExpectTokenString(_DWORD *a1, char *s2)
{
  char s1[1080]; // [esp+20h] [ebp-438h] BYREF

  if ( PS_ReadToken(a1, s1) )
  {
    if ( !strcmp(s1, s2) )
    {
      return 1;
    }
    else
    {
      ScriptError((int)a1, "expected %s, found %s", s2, s1);
      return 0;
    }
  }
  else
  {
    ScriptError((int)a1, "couldn't find expected %s", s2);
    return 0;
  }
}

//----- (0805115E) --------------------------------------------------------
int __cdecl PS_ExpectTokenType(_DWORD *a1, int a2, int a3, char *a4)
{
  char dest[1032]; // [esp+30h] [ebp-408h] BYREF

  if ( !PS_ReadToken(a1, a4) )
  {
    ScriptError((int)a1, "couldn't read expected token");
    return 0;
  }
  if ( *((_DWORD *)a4 + 256) != a2 )
  {
    if ( a2 == 1 )
      strcpy(dest, "string");
    if ( a2 == 2 )
      strcpy(dest, "literal");
    if ( a2 == 3 )
      strcpy(dest, "number");
    if ( a2 == 4 )
      strcpy(dest, "name");
    if ( a2 == 5 )
      strcpy(dest, "punctuation");
    ScriptError((int)a1, "expected a %s, found %s", dest, a4);
    return 0;
  }
  if ( *((_DWORD *)a4 + 256) != 3 )
  {
    if ( *((_DWORD *)a4 + 256) == 5 )
    {
      if ( a3 < 0 )
      {
        ScriptError((int)a1, "BUG: wrong punctuation subtype");
        return 0;
      }
      if ( *((_DWORD *)a4 + 257) != a3 )
      {
        ScriptError(
          (int)a1,
          "expected %s, found %s",
          *(const char **)(a1[27] + 12 * a3),
          *(const char **)(a1[27] + 12 * a3 + 4));
        return 0;
      }
    }
    return 1;
  }
  if ( (a3 & *((_DWORD *)a4 + 257)) == a3 )
    return 1;
  if ( (a3 & 8) != 0 )
    strcpy(dest, "decimal");
  if ( (a3 & 0x100) != 0 )
    strcpy(dest, "hex");
  if ( (a3 & 0x200) != 0 )
    strcpy(dest, "octal");
  if ( (a3 & 0x400) != 0 )
    strcpy(dest, "binary");
  if ( (a3 & 0x2000) != 0 )
    strcat(dest, " long");
  if ( (a3 & 0x4000) != 0 )
    strcat(dest, " unsigned");
  if ( (a3 & 0x800) != 0 )
    strcat(dest, " float");
  if ( (a3 & 0x1000) != 0 )
    strcat(dest, " integer");
  ScriptError((int)a1, "expected %s, found %s", dest, a4);
  return 0;
}

//----- (08051488) --------------------------------------------------------
int __cdecl PS_ExpectAnyToken(_DWORD *a1, _BYTE *dest)
{
  if ( PS_ReadToken(a1, dest) )
    return 1;
  ScriptError((int)a1, "couldn't read expected token");
  return 0;
}

//----- (080514CC) --------------------------------------------------------
int __cdecl PS_CheckTokenString(_DWORD *a1, char *s2)
{
  char s1[1080]; // [esp+20h] [ebp-438h] BYREF

  if ( !PS_ReadToken(a1, s1) )
    return 0;
  if ( !strcmp(s1, s2) )
    return 1;
  a1[17] = a1[19];
  return 0;
}

//----- (0805153E) --------------------------------------------------------
int __cdecl PS_CheckTokenType(_DWORD *a1, int a2, int a3, void *dest)
{
  char src[1024]; // [esp+20h] [ebp-438h] BYREF
  int v7; // [esp+420h] [ebp-38h]
  int v8; // [esp+424h] [ebp-34h]

  if ( !PS_ReadToken(a1, src) )
    return 0;
  if ( v7 == a2 && (v8 & a3) == a3 )
  {
    memcpy(dest, src, 0x42Cu);
    return 1;
  }
  else
  {
    a1[17] = a1[19];
    return 0;
  }
}

//----- (080515C6) --------------------------------------------------------
int __cdecl PS_SkipUntilString(_DWORD *a1, char *s2)
{
  char s1[1080]; // [esp+20h] [ebp-438h] BYREF

  while ( PS_ReadToken(a1, s1) )
  {
    if ( !strcmp(s1, s2) )
      return 1;
  }
  return 0;
}

//----- (08051632) --------------------------------------------------------
int __cdecl PS_UnreadToken(int a1, void *src)
{
  int result; // eax

  memcpy((void *)(a1 + 116), src, 0x42Cu);
  result = a1;
  *(_DWORD *)(a1 + 100) = 1;
  return result;
}

//----- (08051694) --------------------------------------------------------
char *__cdecl StripDoubleQuotes(char *dest)
{
  char *result; // eax

  if ( *dest == 34 )
    strcpy(dest, dest + 1);
  result = &dest[strlen(dest) - 1];
  if ( *result == 34 )
  {
    result = &dest[strlen(dest) - 1];
    *result = 0;
  }
  return result;
}

//----- (080516DE) --------------------------------------------------------
char *__cdecl StripSingleQuotes(char *dest)
{
  char *result; // eax

  if ( *dest == 39 )
    strcpy(dest, dest + 1);
  result = &dest[strlen(dest) - 1];
  if ( *result == 39 )
  {
    result = &dest[strlen(dest) - 1];
    *result = 0;
  }
  return result;
}

//----- (08051728) --------------------------------------------------------
long double __cdecl ReadSignedFloat(_DWORD *a1)
{
  long double v2; // [esp+10h] [ebp-448h]
  char s1[1024]; // [esp+20h] [ebp-438h] BYREF
  int v4; // [esp+420h] [ebp-38h]
  long double v5[3]; // [esp+42Ch] [ebp-2Ch]

  v2 = 1.0;
  PS_ExpectAnyToken(a1, s1);
  if ( !strcmp(s1, "-") )
  {
    v2 = -1.0;
    PS_ExpectTokenType(a1, 3, 0, s1);
  }
  else if ( v4 != 3 )
  {
    ScriptError((int)a1, "expected float value, found %s\n", s1);
  }
  return v2 * v5[0];
}
// 8051728: using guessed type long double var_2C[3];

//----- (080517FA) --------------------------------------------------------
int __cdecl ReadSignedInt(_DWORD *a1)
{
  int v2; // [esp+1Ch] [ebp-43Ch]
  char s1[1024]; // [esp+20h] [ebp-438h] BYREF
  int v4; // [esp+420h] [ebp-38h]
  int v5; // [esp+424h] [ebp-34h]
  int v6; // [esp+428h] [ebp-30h]

  v2 = 1;
  PS_ExpectAnyToken(a1, s1);
  if ( !strcmp(s1, "-") )
  {
    v2 = -1;
    PS_ExpectTokenType(a1, 3, 4096, s1);
  }
  else if ( v4 != 3 || v5 == 2048 )
  {
    ScriptError((int)a1, "expected integer value, found %s\n", s1);
  }
  return v6 * v2;
}

//----- (080518C2) --------------------------------------------------------
void *__cdecl ResetScript(_DWORD *a1)
{
  a1[17] = a1[16];
  a1[19] = a1[16];
  a1[20] = 0;
  a1[21] = 0;
  a1[25] = 0;
  a1[23] = 1;
  a1[24] = 1;
  return memset(a1 + 29, 0, 0x42Cu);
}

//----- (08051932) --------------------------------------------------------
_BOOL4 __cdecl EndOfScript(int a1)
{
  return *(_DWORD *)(a1 + 68) >= *(_DWORD *)(a1 + 72);
}

//----- (0805195E) --------------------------------------------------------
int __cdecl ScriptSkipTo(int a1, char *s)
{
  char v4; // [esp+13h] [ebp-5h]
  size_t n; // [esp+14h] [ebp-4h]

  v4 = *s;
  n = strlen(s);
  while ( 1 )
  {
    if ( !PS_ReadWhiteSpace(a1) )
      return 0;
    if ( **(_BYTE **)(a1 + 68) == v4 && !strncmp(*(const char **)(a1 + 68), s, n) )
      break;
    ++*(_DWORD *)(a1 + 68);
  }
  return 1;
}

//----- (080519D8) --------------------------------------------------------
char *__cdecl LoadScriptFile(char *src)
{
  char *dest; // [esp+14h] [ebp-64h]
  int v4; // [esp+1Ch] [ebp-5Ch]
  char s[76]; // [esp+20h] [ebp-58h] BYREF
  int v6[3]; // [esp+6Ch] [ebp-Ch] BYREF

  Com_sprintf(s, 0x40u, "%s", src);
  v4 = FS_FOpenFileRead(s, v6, 1);
  if ( !v6[0] )
    return 0;
  dest = (char *)GetClearedMemory(v4 + 1189);
  strcpy(dest, src);
  *((_DWORD *)dest + 16) = dest + 1188;
  *(_BYTE *)(*((_DWORD *)dest + 16) + v4) = 0;
  *((_DWORD *)dest + 22) = v4;
  *((_DWORD *)dest + 17) = *((_DWORD *)dest + 16);
  *((_DWORD *)dest + 19) = *((_DWORD *)dest + 16);
  *((_DWORD *)dest + 18) = *((_DWORD *)dest + 16) + v4;
  *((_DWORD *)dest + 25) = 0;
  *((_DWORD *)dest + 23) = 1;
  *((_DWORD *)dest + 24) = 1;
  SetScriptPunctuations((int)dest, 0);
  FS_Read(*((_DWORD *)dest + 16), v4, v6[0]);
  FS_FCloseFile(v6[0]);
  *((_DWORD *)dest + 22) = Com_Compress(*((_BYTE **)dest + 16));
  return dest;
}
// 80519D8: using guessed type int var_C[3];

//----- (08051B20) --------------------------------------------------------
char *__cdecl LoadScriptMemory(void *a1, size_t n, char *src)
{
  char *dest; // [esp+10h] [ebp-8h]

  dest = (char *)GetClearedMemory(n + 1189);
  strcpy(dest, src);
  *((_DWORD *)dest + 16) = dest + 1188;
  *(_BYTE *)(*((_DWORD *)dest + 16) + n) = 0;
  *((_DWORD *)dest + 22) = n;
  *((_DWORD *)dest + 17) = *((_DWORD *)dest + 16);
  *((_DWORD *)dest + 19) = *((_DWORD *)dest + 16);
  *((_DWORD *)dest + 18) = *((_DWORD *)dest + 16) + n;
  *((_DWORD *)dest + 25) = 0;
  *((_DWORD *)dest + 23) = 1;
  *((_DWORD *)dest + 24) = 1;
  SetScriptPunctuations((int)dest, 0);
  memcpy(*((void **)dest + 16), a1, n);
  return dest;
}

//----- (08051BEE) --------------------------------------------------------
void __cdecl FreeScript(int a1)
{
  if ( *(_DWORD *)(a1 + 112) )
    FreeMemory(*(_DWORD *)(a1 + 112));
  FreeMemory(a1);
}

//----- (08051C18) --------------------------------------------------------
char *getBuildNumber()
{
  sprintf(s, "%d %s %s", 696, "Oct 24 2005", "17:45:05");
  return s;
}

//----- (08051C54) --------------------------------------------------------
_BOOL4 Com_IsBspLoaded()
{
  return comBspGlob != 0;
}

//----- (08051C66) --------------------------------------------------------
void *__cdecl Com_GetBspHeader(_DWORD *a1, _DWORD *a2)
{
  if ( a1 )
    *a1 = dword_8185BCC;
  if ( a2 )
    *a2 = dword_8185BD0;
  return comBspGlob;
}
// 8185BD0: using guessed type int dword_8185BD0;

//----- (08051C90) --------------------------------------------------------
int *__cdecl Com_LoadBsp(const char *a1)
{
  char *v1; // eax
  char *v2; // eax
  int *v3; // ebx
  _DWORD *v4; // ebx
  int *result; // eax
  char *v6; // eax
  _DWORD *v7; // esi
  int v8; // ebx
  _DWORD *v9; // esi
  int v10; // ebx
  char v11[4]; // [esp+14h] [ebp-14h] BYREF
  int i; // [esp+18h] [ebp-10h] BYREF
  int v13; // [esp+1Ch] [ebp-Ch]

  dword_8185BCC = FS_FOpenFileRead(a1, (int *)v11, 0);
  if ( !*(_DWORD *)v11 )
  {
    v1 = va(aExeErrCouldntL_1, a1);
    Com_Error(1, v1);
  }
  comBspGlob = Z_MallocGarbageInternal(dword_8185BCC);
  v13 = FS_Read((int)comBspGlob, dword_8185BCC, *(int *)v11);
  FS_FCloseFile(*(int *)v11);
  if ( v13 != dword_8185BCC || dword_8185BCC <= 0x13F )
  {
    Z_FreeInternal(comBspGlob);
    v2 = va(aExeErrCouldntL_1, a1);
    Com_Error(1, v2);
  }
  dword_8185BD0 = Com_BlockChecksum((char *)comBspGlob, dword_8185BCC);
  v3 = (int *)comBspGlob;
  *v3 = Com_GetBspHeaderData(*(_DWORD *)comBspGlob);
  v4 = comBspGlob;
  v4[1] = Com_GetBspHeaderData(*((_DWORD *)comBspGlob + 1));
  if ( *(_DWORD *)comBspGlob != 1347633737 || (result = (int *)comBspGlob, *((_DWORD *)comBspGlob + 1) != 4) )
  {
    Z_FreeInternal(comBspGlob);
    v6 = va(aExeErrWrongMap, a1);
    Com_Error(1, v6);
  }
  for ( i = 0; i != 39; ++i )
  {
    v7 = comBspGlob;
    v8 = i;
    v7[2 * v8 + 2] = Com_GetBspHeaderData(*((_DWORD *)comBspGlob + 2 * i + 2));
    v9 = comBspGlob;
    v10 = i;
    v9[2 * v10 + 3] = Com_GetBspHeaderData(*((_DWORD *)comBspGlob + 2 * i + 3));
    result = &i;
  }
  return result;
}
// 8185BD0: using guessed type int dword_8185BD0;

//----- (08051E5C) --------------------------------------------------------
void Com_UnloadBsp()
{
  Z_FreeInternal(comBspGlob);
  comBspGlob = 0;
}

//----- (08051E7C) --------------------------------------------------------
void Com_CleanupBsp()
{
  if ( Com_IsBspLoaded() )
    Com_UnloadBsp();
}

//----- (08051E92) --------------------------------------------------------
int __cdecl Com_GetBspHeaderData(int a1)
{
  return a1;
}

//----- (08051E9C) --------------------------------------------------------
int __cdecl CM_InitThreadData(int a1)
{
  int result; // eax
  char *v2; // [esp+8h] [ebp-10h]

  v2 = (char *)&unk_8523A1C + 24 * a1;
  *(_DWORD *)v2 = 0;
  *((_DWORD *)v2 + 3) = Hunk_AllocInternal(2 * dword_8185C44);
  *((_DWORD *)v2 + 1) = Hunk_AllocInternal(4 * dword_8185C2C);
  *((_DWORD *)v2 + 2) = Hunk_AllocInternal(4 * dword_8185C24);
  *((_DWORD *)v2 + 4) = Hunk_AllocInternal(0x30u);
  qmemcpy(*((void **)v2 + 4), (const void *)dword_8185C7C, 0x30u);
  *((_DWORD *)v2 + 5) = Hunk_AllocInternal(0x48u);
  result = 72;
  qmemcpy(*((void **)v2 + 5), &unk_8185C80, 0x48u);
  return result;
}
// 8185C24: using guessed type int dword_8185C24;
// 8185C2C: using guessed type int dword_8185C2C;
// 8185C44: using guessed type int dword_8185C44;
// 8185C7C: using guessed type int dword_8185C7C;

//----- (08051F6A) --------------------------------------------------------
int CM_InitAllThreadData()
{
  return CM_InitThreadData(0);
}

//----- (08051F7E) --------------------------------------------------------
char *__usercall CM_LoadMapData@<eax>(long double a1@<st0>, char *s)
{
  CM_LoadMapFromBsp(a1, s, 1);
  return CM_LoadStaticModels();
}

//----- (08051F9E) --------------------------------------------------------
int __usercall CM_LoadMap@<eax>(long double a1@<st0>, char *s2, _DWORD *a3)
{
  int result; // eax

  if ( !s2 || !*s2 )
    Com_Error(1, (char *)&byte_813AE20);
  if ( !dest || strcasecmp(dest, s2) )
  {
    CM_LoadMapData(a1, s2);
    CM_InitAllThreadData();
  }
  result = dword_8185CEC;
  *a3 = dword_8185CEC;
  return result;
}
// 8185CEC: using guessed type int dword_8185CEC;

//----- (08052006) --------------------------------------------------------
void *CM_Shutdown()
{
  return Com_Memset(&dest, 0, 0x110u);
}

//----- (0805202A) --------------------------------------------------------
int __cdecl sub_805202A(int a1, int a2)
{
  int result; // eax
  int i; // [esp+14h] [ebp-4h]

  for ( i = 0; ; ++i )
  {
    result = i;
    if ( i >= a2 )
      break;
    *(_DWORD *)(a1 + 4 * i) = sub_80525D6(*(_DWORD *)(a1 + 4 * i));
  }
  return result;
}

//----- (0805208A) --------------------------------------------------------
void __cdecl CM_SaveLump(int a1, char *a2, int a3, int *a4)
{
  unsigned int v4; // [esp+14h] [ebp-2E4h]
  char *v5; // [esp+18h] [ebp-2E0h]
  int *v6; // [esp+1Ch] [ebp-2DCh]
  int v7; // [esp+20h] [ebp-2D8h]
  unsigned int v8; // [esp+24h] [ebp-2D4h]
  char *v9; // [esp+28h] [ebp-2D0h]
  char *v10; // [esp+2Ch] [ebp-2CCh]
  int v11; // [esp+30h] [ebp-2C8h] BYREF
  int v12; // [esp+34h] [ebp-2C4h] BYREF
  size_t v13; // [esp+38h] [ebp-2C0h]
  int v14; // [esp+3Ch] [ebp-2BCh]
  int i; // [esp+40h] [ebp-2B8h]
  int v16; // [esp+44h] [ebp-2B4h]
  int v17; // [esp+48h] [ebp-2B0h]
  int v18; // [esp+4Ch] [ebp-2ACh]
  int v19; // [esp+50h] [ebp-2A8h] BYREF
  _BYTE v20[316]; // [esp+54h] [ebp-2A4h] BYREF
  int v21; // [esp+190h] [ebp-168h] BYREF
  char v22[4]; // [esp+194h] [ebp-164h] BYREF
  int v23[80]; // [esp+198h] [ebp-160h]
  char *v24; // [esp+2D8h] [ebp-20h]
  void *ptr; // [esp+2DCh] [ebp-1Ch] BYREF

  v18 = FS_FOpenFileRead(dest, &v11, 0);
  if ( !v11 )
    Com_Error(1, aExeErrCouldntL, dest);
  ptr = Z_MallocInternal(v18 + 1);
  FS_Read((int)ptr, v18, v11);
  *((_BYTE *)ptr + v18) = 0;
  FS_FCloseFile(v11);
  v10 = (char *)&v21;
  v9 = (char *)ptr;
  v8 = 320;
  if ( ((unsigned __int8)&v21 & 4) != 0 )
  {
    v21 = *(_DWORD *)ptr;
    v10 = v22;
    v9 = (char *)ptr + 4;
    v8 = 316;
  }
  qmemcpy(v10, v9, 4 * (v8 >> 2));
  v7 = sub_80525D6(*(int *)v22);
  if ( v7 != 4 && v7 != 61 )
    Com_Error(1, "bad bsp version %d", *(_DWORD *)v22);
  v14 = 39;
  sub_805202A((int)&v21, 39);
  v6 = &v19;
  v5 = (char *)&v21;
  v4 = 320;
  if ( ((unsigned __int8)&v19 & 4) != 0 )
  {
    v19 = v21;
    v6 = (int *)v20;
    v5 = v22;
    v4 = 316;
  }
  qmemcpy(v6, v5, 4 * (v4 >> 2));
  v11 = sub_809EB4A();
  if ( !v11 )
    Com_Error(1, "Failed to open file %s for writing", dest);
  v16 = 8 * v14 + 8;
  v17 = v16;
  for ( i = 0; i < v14; ++i )
  {
    if ( i == a1 )
      v23[2 * i] = a3;
    v23[2 * i + 1] = v17;
    v17 += (v23[2 * i] + 3) & 0xFFFFFFFC;
  }
  sub_805202A((int)&v21, v14);
  FS_Write((char *)&v21, v16, v11);
  sub_805202A((int)&v21, v14);
  v12 = 0;
  for ( i = 0; i < v14; ++i )
  {
    if ( v23[2 * i] )
    {
      v24 = i == a1 ? a2 : (char *)ptr + *(_DWORD *)&v20[8 * i + 8];
      FS_Write(v24, v23[2 * i], v11);
      v13 = ((v23[2 * i] + 3) & 0xFFFFFFFC) - v23[2 * i];
      if ( v13 )
        FS_Write((char *)&v12, v13, v11);
    }
  }
  FS_FCloseFile(v11);
  Z_FreeInternal(ptr);
  if ( a4 )
  {
    v17 = FS_ReadFile(dest, &ptr);
    *a4 = Com_BlockChecksum((char *)ptr, v17);
    FS_FreeFile(ptr);
  }
}

//----- (080524EA) --------------------------------------------------------
void *sub_80524EA()
{
  return dword_8185C78;
}

//----- (080524F4) --------------------------------------------------------
int __cdecl sub_80524F4(int a1)
{
  return *(__int16 *)(dword_8185C08 + 44 * a1 + 40);
}
// 8185C08: using guessed type int dword_8185C08;

//----- (08052518) --------------------------------------------------------
int __cdecl sub_8052518(int a1, _DWORD *a2, _DWORD *a3)
{
  _DWORD *v4; // [esp+14h] [ebp-4h]

  v4 = (_DWORD *)CM_ClipHandleToModel(a1);
  sub_80525A6(v4, a2);
  return sub_80525A6(v4 + 3, a3);
}

//----- (08052556) --------------------------------------------------------
void *__cdecl CM_Hunk_Alloc(size_t a1)
{
  return Hunk_AllocInternal(a1);
}

//----- (0805256A) --------------------------------------------------------
void Hunk_UserCreate()
{
  ;
}

//----- (08052570) --------------------------------------------------------
void CM_Hunk_CheckTempMemoryHighClear()
{
  ;
}

//----- (08052576) --------------------------------------------------------
size_t __cdecl CM_Hunk_AllocateTempMemoryHigh(int a1)
{
  return Hunk_AllocateTempMemoryHighInternal(a1);
}

//----- (0805258A) --------------------------------------------------------
int Hunk_UserDestroy()
{
  return Hunk_ClearTempMemoryInternal();
}

//----- (08052598) --------------------------------------------------------
int CM_Hunk_ClearTempMemoryHigh()
{
  return Hunk_ClearTempMemoryHighInternal();
}

//----- (080525A6) --------------------------------------------------------
int __cdecl sub_80525A6(_DWORD *a1, _DWORD *a2)
{
  int result; // eax

  *a2 = *a1;
  a2[1] = a1[1];
  result = a1[2];
  a2[2] = result;
  return result;
}

//----- (080525D6) --------------------------------------------------------
int __cdecl sub_80525D6(int a1)
{
  return a1;
}

//----- (080525E0) --------------------------------------------------------
int __cdecl CMod_LoadMaterials(_DWORD *a1)
{
  int result; // eax
  signed int v2; // [esp+14h] [ebp-14h]
  int i; // [esp+18h] [ebp-10h]
  _DWORD *v4; // [esp+1Ch] [ebp-Ch]
  char *src; // [esp+20h] [ebp-8h]

  src = (char *)(dword_8185CFC + a1[1]);
  if ( *a1 % 0x48u )
    Com_Error(1, (char *)&byte_813AEC0);
  v2 = *a1 / 0x48u;
  if ( v2 <= 0 )
    Com_Error(1, (char *)&byte_813AEE5);
  dword_8185BF0 = (char *)CM_Hunk_Alloc(72 * v2 + 72) + 72;
  dword_8185BEC = v2;
  Com_Memcpy(dword_8185BF0, src, 72 * v2);
  result = CM_DataFromHeader(1);
  if ( result != 1 )
  {
    v4 = dword_8185BF0;
    for ( i = 0; ; ++i )
    {
      result = i;
      if ( i >= v2 )
        break;
      v4[17] = CM_DataFromHeader(v4[17]);
      v4[16] = CM_DataFromHeader(v4[16]);
      src += 72;
      v4 += 18;
    }
  }
  return result;
}
// 8185BEC: using guessed type int dword_8185BEC;
// 8185CFC: using guessed type int dword_8185CFC;

//----- (08052728) --------------------------------------------------------
_DWORD *CMod_AllocLeafBrushNode()
{
  _DWORD *s; // [esp+14h] [ebp-4h]

  s = (_DWORD *)TempMalloc(20);
  memset(s, 0, 0x14u);
  s[2] = -8388609;
  return s;
}

//----- (08052768) --------------------------------------------------------
int __usercall CMod_LoadSubmodels@<eax>(long double a1@<st0>, _DWORD *a2)
{
  int result; // eax
  int v3; // ebx
  int v4; // esi
  int v5; // eax
  long double v6; // fst7
  int v7; // ebx
  int v8; // esi
  int v9; // eax
  int v10; // esi
  int v11; // ebx
  float v12; // [esp+0h] [ebp-58h]
  float v13; // [esp+1Ch] [ebp-3Ch]
  float v14[5]; // [esp+20h] [ebp-38h] BYREF
  int v15; // [esp+34h] [ebp-24h]
  int v16; // [esp+38h] [ebp-20h]
  int v17; // [esp+3Ch] [ebp-1Ch]
  int i; // [esp+40h] [ebp-18h]
  int v19; // [esp+44h] [ebp-14h]
  int v20; // [esp+48h] [ebp-10h]
  int v21; // [esp+4Ch] [ebp-Ch]

  v21 = dword_8185CFC + a2[1];
  if ( *a2 % 0x30u )
    Com_Error(1, (char *)&byte_813AF20);
  v17 = *a2 / 0x30u;
  if ( v17 <= 0 )
    Com_Error(1, (char *)&byte_813AF45);
  LODWORD(v14[4]) = 72 * v17;
  dword_8185C58 = (int)CM_Hunk_Alloc(72 * v17);
  dword_8185C54 = v17;
  if ( v17 > 1023 )
    Com_Error(1, (char *)&byte_813AF6C, 22);
  v19 = 0;
  while ( 1 )
  {
    result = v19;
    if ( v19 >= v17 )
      break;
    v20 = dword_8185C58 + 72 * v19;
    for ( i = 0; i <= 2; ++i )
    {
      v3 = v20;
      v4 = i;
      v5 = sub_8055080(v21 + 4 * i);
      sub_8055170(*(float *)&v5);
      v6 = a1 - 1.0;
      *(float *)(v3 + 4 * v4) = v6;
      v7 = v20;
      v8 = i;
      v9 = sub_8055080(v21 + 4 * i + 12);
      sub_8055170(*(float *)&v9);
      *(float *)(v7 + 4 * v8 + 12) = v6 + 1.0;
      v10 = i;
      v13 = sub_8054FF8(*(float *)(v20 + 4 * i + 12));
      a1 = sub_8054FF8(*(float *)(v20 + 4 * i));
      v12 = a1;
      sub_8055012(v12, v13);
      v14[v10] = a1;
    }
    v11 = v20;
    sub_8055116(v14);
    *(float *)(v11 + 24) = a1;
    if ( v19 )
    {
      v16 = CM_DataFromHeader(*(_DWORD *)(v21 + 36));
      *(_WORD *)(v20 + 30) = v16;
      if ( *(unsigned __int16 *)(v20 + 30) != v16 )
        Com_Error(1, (char *)&byte_813AFA0, 22);
      v15 = CM_DataFromHeader(*(_DWORD *)(v21 + 32));
      *(_WORD *)(v20 + 28) = v15;
      if ( *(unsigned __int16 *)(v20 + 28) != v15 )
        Com_Error(1, (char *)&byte_813AFE0, 22);
    }
    ++v19;
    v21 += 48;
  }
  return result;
}
// 8185C54: using guessed type int dword_8185C54;
// 8185C58: using guessed type int dword_8185C58;
// 8185CFC: using guessed type int dword_8185CFC;

//----- (080529AE) --------------------------------------------------------
long double __cdecl CMod_GetPartitionScore(int a1, int a2, int a3, int a4, int a5, float *a6)
{
  long double v6; // fst7
  float v8; // [esp+0h] [ebp-38h]
  float v9; // [esp+4h] [ebp-34h]
  float v10; // [esp+14h] [ebp-24h]
  float v12; // [esp+18h] [ebp-20h]
  float v13; // [esp+1Ch] [ebp-1Ch]
  int v14; // [esp+20h] [ebp-18h]
  int v15; // [esp+24h] [ebp-14h]
  int i; // [esp+2Ch] [ebp-Ch]
  int v17; // [esp+30h] [ebp-8h]
  int v18; // [esp+34h] [ebp-4h]

  v18 = -1;
  v17 = -1;
  v13 = -3.4028235e38;
  v12 = 3.4028235e38;
  for ( i = 0; i < a2; ++i )
  {
    v15 = dword_8185C60 + 48 * *(unsigned __int16 *)(a1 + 2 * i);
    if ( *(float *)(v15 + 4 * a3) < (long double)*a6 )
    {
      if ( *a6 >= (long double)*(float *)(v15 + 4 * a3 + 16) )
      {
        ++v17;
        if ( *(float *)(v15 + 4 * a3 + 16) > (long double)v13 )
          v13 = *(float *)(v15 + 4 * a3 + 16);
      }
    }
    else
    {
      ++v18;
      if ( v12 > (long double)*(float *)(v15 + 4 * a3) )
        v12 = *(float *)(v15 + 4 * a3);
    }
  }
  v14 = sub_805505A(v17, v18);
  *a6 = (v13 + v12) * 0.5;
  if ( v14 <= 0 )
  {
    return (float)0.0;
  }
  else
  {
    v9 = *(float *)(a5 + 4 * a3) - v13;
    v6 = v12 - *(float *)(a4 + 4 * a3);
    v8 = v6;
    sub_8055036(v8, v9);
    v10 = v6;
    return (float)((long double)v14 * v10);
  }
}
// 8185C60: using guessed type int dword_8185C60;

//----- (08052B12) --------------------------------------------------------
_DWORD *__cdecl CMod_PartionLeafBrushes_r(unsigned __int16 *src, int a2, _DWORD *a3, _DWORD *a4)
{
  long double v4; // fst7
  long double v5; // fst7
  float v7; // [esp+4h] [ebp-94h]
  float v8; // [esp+4h] [ebp-94h]
  float v10; // [esp+28h] [ebp-70h]
  int v11; // [esp+2Ch] [ebp-6Ch]
  float v12[4]; // [esp+30h] [ebp-68h] BYREF
  float v13[4]; // [esp+40h] [ebp-58h] BYREF
  int v14; // [esp+50h] [ebp-48h]
  int v15; // [esp+54h] [ebp-44h]
  void *dest; // [esp+58h] [ebp-40h]
  size_t n; // [esp+5Ch] [ebp-3Ch]
  int v18; // [esp+60h] [ebp-38h]
  int v19; // [esp+64h] [ebp-34h]
  _DWORD *v20; // [esp+68h] [ebp-30h]
  int v21; // [esp+6Ch] [ebp-2Ch]
  float v22; // [esp+70h] [ebp-28h]
  float v23; // [esp+74h] [ebp-24h]
  float v24; // [esp+78h] [ebp-20h] BYREF
  float v25; // [esp+7Ch] [ebp-1Ch]
  int v26; // [esp+80h] [ebp-18h]
  int v27; // [esp+84h] [ebp-14h]
  int j; // [esp+88h] [ebp-10h]
  unsigned __int8 i; // [esp+8Fh] [ebp-9h]

  v20 = CMod_AllocLeafBrushNode();
  v22 = 0.0;
  v21 = -1;
  v23 = 0.0;
  for ( i = 0; i <= 2u; ++i )
  {
    for ( j = 0; j < a2; ++j )
    {
      v27 = src[j];
      v26 = dword_8185C60 + 48 * v27;
      v24 = *(float *)(v26 + 4 * i);
      v25 = CMod_GetPartitionScore((int)src, a2, i, (int)a3, (int)a4, &v24);
      if ( v25 > (long double)v22 )
      {
        v22 = v25;
        v21 = i;
        v23 = v24;
      }
      v24 = *(float *)(v26 + 4 * i + 16);
      v25 = CMod_GetPartitionScore((int)src, a2, i, (int)a3, (int)a4, &v24);
      if ( v25 > (long double)v22 )
      {
        v22 = v25;
        v21 = i;
        v23 = v24;
      }
    }
  }
  if ( v21 >= 0 )
  {
    n = 2 * a2;
    dest = (void *)CM_Hunk_AllocateTempMemoryHigh(2 * a2);
    memcpy(dest, src, 2 * a2);
    v15 = 0;
    for ( j = 0; j < a2; ++j )
    {
      v27 = *((unsigned __int16 *)dest + j);
      v26 = dword_8185C60 + 48 * v27;
      if ( *(float *)(v26 + 4 * v21) < (long double)v23 && v23 < (long double)*(float *)(v26 + 4 * v21 + 16) )
        src[v15++] = v27;
    }
    if ( v15 )
    {
      v19 = CMod_PartionLeafBrushes_r(src, v15, (int)a3, (int)a4);
      *((_WORD *)v20 + 1) = -1;
      v20[1] = *(_DWORD *)(v19 + 4);
      src += v15;
    }
    v10 = 3.4028235e38;
    *(_BYTE *)v20 = v21;
    *((float *)v20 + 2) = v23;
    v14 = 0;
LABEL_27:
    if ( v14 > 1 )
    {
      *((float *)v20 + 3) = v10;
      return v20;
    }
    v15 = 0;
    for ( j = 0; ; ++j )
    {
      if ( j >= a2 )
      {
        CM_VectorCopy(a3, v13);
        CM_VectorCopy(a4, v12);
        if ( v14 )
          v12[v21] = v23 - v10;
        else
          v13[v21] = v23 + v10;
        v18 = CMod_PartionLeafBrushes_r(src, v15, (int)v13, (int)v12);
        v11 = -858993459 * ((v18 - (int)v20) >> 2);
        *((_WORD *)v20 + v14 + 8) = -13107 * ((v18 - (int)v20) >> 2);
        if ( *((unsigned __int16 *)v20 + v14 + 8) != v11 )
          Com_Error(1, (char *)&byte_813B080);
        v20[1] |= *(_DWORD *)(v18 + 4);
        src += v15;
        ++v14;
        goto LABEL_27;
      }
      v27 = *((unsigned __int16 *)dest + j);
      v26 = dword_8185C60 + 48 * v27;
      if ( v14 )
      {
        if ( *(float *)(v26 + 4 * v21 + 16) > (long double)v23 )
          continue;
        v5 = v23 - *(float *)(v26 + 4 * v21 + 16);
        v8 = v5;
        sub_8055036(v10, v8);
        v10 = v5;
      }
      else
      {
        if ( v23 > (long double)*(float *)(v26 + 4 * v21) )
          continue;
        v4 = *(float *)(v26 + 4 * v21) - v23;
        v7 = v4;
        sub_8055036(v10, v7);
        v10 = v4;
      }
      src[v15++] = v27;
    }
  }
  *((_WORD *)v20 + 1) = a2;
  if ( *((__int16 *)v20 + 1) != a2 )
    Com_Error(1, (char *)&byte_813B020);
  for ( j = 0; j < a2; ++j )
  {
    v27 = src[j];
    v26 = dword_8185C60 + 48 * v27;
    v20[1] |= *(_DWORD *)(v26 + 12);
  }
  v20[2] = src;
  return v20;
}
// 8185C60: using guessed type int dword_8185C60;
// 8052B12: using guessed type int arg_8;
// 8052B12: using guessed type float var_58[4];
// 8052B12: using guessed type float var_68[4];

//----- (08052FD4) --------------------------------------------------------
void __cdecl CMod_PartionLeafBrushes(unsigned __int16 *src, int a2, _DWORD *a3)
{
  int j; // [esp+10h] [ebp-38h]
  int k; // [esp+10h] [ebp-38h]
  int v5; // [esp+14h] [ebp-34h]
  int i; // [esp+1Ch] [ebp-2Ch]
  float v7[4]; // [esp+20h] [ebp-28h] BYREF
  float v8[6]; // [esp+30h] [ebp-18h] BYREF

  if ( a2 )
  {
    CM_VectorSet(v8, 2139095039, 2139095039, 2139095039);
    CM_VectorSet(v7, -8388609, -8388609, -8388609);
    for ( i = 0; i < a2; ++i )
    {
      v5 = dword_8185C60 + 48 * src[i];
      for ( j = 0; j <= 2; ++j )
      {
        if ( v8[j] > (long double)*(float *)(v5 + 4 * j) )
          v8[j] = *(float *)(v5 + 4 * j);
        if ( *(float *)(v5 + 4 * j + 16) > (long double)v7[j] )
          v7[j] = *(float *)(v5 + 4 * j + 16);
      }
    }
    CM_VectorCopy(v8, a3 + 3);
    CM_VectorCopy(v7, a3 + 6);
    for ( k = 0; k <= 2; ++k )
    {
      *(float *)&a3[k + 3] = *(float *)&a3[k + 3] - 0.125;
      *(float *)&a3[k + 6] = *(float *)&a3[k + 6] + 0.125;
    }
    CM_Hunk_CheckTempMemoryHighClear();
    a3[9] = -858993459 * (((char *)CMod_PartionLeafBrushes_r(src, a2, v8, v7) - (_BYTE *)dword_8185C10) >> 2);
    CM_Hunk_ClearTempMemoryHigh();
  }
}
// 8185C60: using guessed type int dword_8185C60;
// 8052FD4: using guessed type float var_18[6];
// 8052FD4: using guessed type float var_28[4];

//----- (0805319E) --------------------------------------------------------
int __cdecl CMod_GetLeafTerrainContents(unsigned __int16 *a1)
{
  int i; // [esp+0h] [ebp-8h]
  int v3; // [esp+4h] [ebp-4h]

  v3 = 0;
  for ( i = 0; i < a1[1]; ++i )
    v3 |= *((_DWORD *)dword_8185BF0 + 18 * *(unsigned __int16 *)(dword_8185C50 + 32 * (i + *a1) + 24) + 17);
  return v3;
}
// 8185C50: using guessed type int dword_8185C50;

//----- (08053200) --------------------------------------------------------
int __cdecl CMod_LoadSubmodelBrushNodes(int a1)
{
  int result; // eax
  int v2; // eax
  int v3; // [esp+14h] [ebp-24h]
  int v4; // [esp+1Ch] [ebp-1Ch]
  unsigned __int16 *src; // [esp+20h] [ebp-18h]
  int j; // [esp+24h] [ebp-14h]
  int i; // [esp+28h] [ebp-10h]
  int v8; // [esp+2Ch] [ebp-Ch]
  int v9; // [esp+30h] [ebp-8h]

  v9 = dword_8185CFC + *(_DWORD *)(a1 + 4);
  for ( i = 0; ; ++i )
  {
    result = i;
    if ( i >= dword_8185C54 )
      break;
    if ( i )
    {
      v8 = dword_8185C58 + 72 * i;
      v4 = CM_DataFromHeader(*(_DWORD *)(v9 + 44));
      src = (unsigned __int16 *)CM_Hunk_Alloc(2 * v4);
      v3 = 0;
      for ( j = 0; j < v4; ++j )
      {
        v2 = CM_DataFromHeader(*(_DWORD *)(v9 + 40));
        src[j] = j + v2;
        if ( src[j] != j + v2 )
          Com_Error(1, (char *)&byte_813B0E0, 22);
        v3 |= *(_DWORD *)(dword_8185C60 + 48 * (j + v2) + 12);
      }
      *(_DWORD *)(v8 + 32) = v3;
      *(_DWORD *)(v8 + 36) = CMod_GetLeafTerrainContents((unsigned __int16 *)(v8 + 28));
      CMod_PartionLeafBrushes(src, v4, (_DWORD *)(v8 + 28));
    }
    v9 += 48;
  }
  return result;
}
// 8185C54: using guessed type int dword_8185C54;
// 8185C58: using guessed type int dword_8185C58;
// 8185C60: using guessed type int dword_8185C60;
// 8185CFC: using guessed type int dword_8185CFC;

//----- (08053354) --------------------------------------------------------
signed int __cdecl CMod_LoadNodes(_DWORD *a1)
{
  signed int result; // eax
  signed int v2; // [esp+1Ch] [ebp-1Ch]
  int j; // [esp+20h] [ebp-18h]
  signed int i; // [esp+24h] [ebp-14h]
  _DWORD *v5; // [esp+28h] [ebp-10h]
  int v6; // [esp+2Ch] [ebp-Ch]
  int *v7; // [esp+30h] [ebp-8h]

  v7 = (int *)(dword_8185CFC + a1[1]);
  if ( *a1 % 0x24u )
    Com_Error(1, (char *)&byte_813B120);
  v2 = *a1 / 0x24u;
  if ( v2 <= 0 )
    Com_Error(1, (char *)&byte_813B141);
  dword_8185C00 = (int)CM_Hunk_Alloc(8 * v2);
  dword_8185BFC = v2;
  v5 = (_DWORD *)dword_8185C00;
  for ( i = 0; ; ++i )
  {
    result = i;
    if ( i >= v2 )
      break;
    *v5 = dword_8185CF8 + 20 * CM_DataFromHeader(*v7);
    for ( j = 0; j <= 1; ++j )
    {
      v6 = CM_DataFromHeader(v7[j + 1]);
      *((_WORD *)v5 + j + 2) = v6;
      if ( *((__int16 *)v5 + j + 2) != v6 )
        Com_Error(1, (char *)&byte_813B180, 21);
    }
    v5 += 2;
    v7 += 9;
  }
  return result;
}
// 8185BFC: using guessed type int dword_8185BFC;
// 8185C00: using guessed type int dword_8185C00;
// 8185CF8: using guessed type int dword_8185CF8;
// 8185CFC: using guessed type int dword_8185CFC;

//----- (080534B8) --------------------------------------------------------
int __usercall CMod_LoadBrushes@<eax>(long double a1@<st0>, _DWORD *a2, _DWORD *a3)
{
  int result; // eax
  int v4; // eax
  _DWORD *v5; // [esp+18h] [ebp-50h]
  _DWORD *v6; // [esp+20h] [ebp-48h]
  int k; // [esp+34h] [ebp-34h]
  int v8; // [esp+3Ch] [ebp-2Ch]
  int v9; // [esp+3Ch] [ebp-2Ch]
  int v10; // [esp+40h] [ebp-28h]
  int v11; // [esp+44h] [ebp-24h]
  int j; // [esp+48h] [ebp-20h]
  int m; // [esp+48h] [ebp-20h]
  int i; // [esp+4Ch] [ebp-1Ch]
  _DWORD *v15; // [esp+50h] [ebp-18h]
  _DWORD *v16; // [esp+54h] [ebp-14h]
  int *v17; // [esp+58h] [ebp-10h]
  __int16 *v18; // [esp+5Ch] [ebp-Ch]

  v18 = (__int16 *)(dword_8185CFC + a2[1]);
  if ( (*a2 & 3) != 0 )
    Com_Error(1, (char *)&byte_813B1C0);
  v11 = *a2 >> 2;
  v17 = (int *)(dword_8185CFC + a3[1]);
  if ( (*a3 & 7) != 0 )
    Com_Error(1, (char *)&byte_813B1C0);
  v10 = (*a3 >> 3) - 6 * v11;
  if ( v10 < 0 )
    Com_Error(1, (char *)&byte_813B200);
  if ( v10 )
    v6 = CM_Hunk_Alloc(8 * v10);
  else
    v6 = 0;
  dword_8185BF8 = (int)v6;
  dword_8185BF4 = v10;
  v15 = v6;
  dword_8185C60 = (int)CM_Hunk_Alloc(48 * (v11 + 1));
  word_8185C5C = v11;
  if ( (unsigned __int16)v11 != v11 )
    Com_Error(1, (char *)&byte_813B260, 22);
  v16 = (_DWORD *)dword_8185C60;
  for ( i = 0; ; ++i )
  {
    result = i;
    if ( i >= v11 )
      break;
    v16[7] = (__int16)sub_8055154(*v18) - 6;
    if ( (int)v16[7] < 0 )
      Com_Error(1, (char *)&byte_813B2A0, 22);
    if ( v16[7] )
      v5 = v15;
    else
      v5 = 0;
    v16[8] = v5;
    for ( j = 0; j <= 2; ++j )
    {
      for ( k = 0; k <= 1; ++k )
      {
        v4 = sub_8055080((int)v17);
        sub_8055170(*(float *)&v4);
        if ( k )
          *(float *)&v16[j + 4] = a1;
        else
          *(float *)&v16[j] = a1;
        v8 = CM_DataFromHeader(v17[1]);
        if ( v8 < 0 || v8 >= dword_8185BEC )
          Com_Error(1, (char *)&byte_813B2E0, v8);
        *((_WORD *)v16 + 3 * k + j + 18) = v8;
        if ( *((__int16 *)v16 + 3 * k + j + 18) != v8 )
          Com_Error(1, (char *)&byte_813B320, 22);
        v17 += 2;
      }
    }
    for ( m = 0; m < v16[7]; ++m )
    {
      *v15 = dword_8185CF8 + 20 * CM_DataFromHeader(*v17);
      v15[1] = CM_DataFromHeader(v17[1]);
      if ( (int)v15[1] < 0 || v15[1] >= dword_8185BEC )
        Com_Error(1, (char *)&byte_813B2E0, v15[1]);
      v17 += 2;
      v15 += 2;
    }
    v9 = (__int16)sub_8055154(v18[1]);
    if ( v9 < 0 || v9 >= dword_8185BEC )
      Com_Error(1, (char *)&byte_813B2E0, v9);
    v16[3] = *((_DWORD *)dword_8185BF0 + 18 * v9 + 17) & 0xDFFFFFFB;
    v16 += 12;
    v18 += 2;
  }
  return result;
}
// 8185BEC: using guessed type int dword_8185BEC;
// 8185BF4: using guessed type int dword_8185BF4;
// 8185BF8: using guessed type int dword_8185BF8;
// 8185C5C: using guessed type __int16 word_8185C5C;
// 8185C60: using guessed type int dword_8185C60;
// 8185CF8: using guessed type int dword_8185CF8;
// 8185CFC: using guessed type int dword_8185CFC;

//----- (080538BC) --------------------------------------------------------
signed int __cdecl CMod_LoadLeafs(_DWORD *a1, char a2)
{
  signed int result; // eax
  int v3; // [esp+18h] [ebp-20h]
  int v4; // [esp+1Ch] [ebp-1Ch]
  int v5; // [esp+20h] [ebp-18h]
  signed int v6; // [esp+24h] [ebp-14h]
  int *v7; // [esp+28h] [ebp-10h]
  unsigned __int16 *v8; // [esp+2Ch] [ebp-Ch]
  signed int i; // [esp+30h] [ebp-8h]

  v7 = (int *)(dword_8185CFC + a1[1]);
  if ( *a1 % 0x24u )
    Com_Error(1, (char *)&byte_813B360);
  v6 = *a1 / 0x24u;
  if ( v6 <= 0 )
    Com_Error(1, (char *)&byte_813B381);
  dword_8185C08 = (int)CM_Hunk_Alloc(44 * v6);
  dword_8185C04 = v6;
  v5 = 0;
  v8 = (unsigned __int16 *)dword_8185C08;
  for ( i = 0; ; ++i )
  {
    result = i;
    if ( i >= v6 )
      break;
    if ( a2 )
    {
      v5 = CM_DataFromHeader(*v7);
      v8[20] = v5;
      if ( (__int16)v8[20] != v5 )
        Com_Error(1, (char *)&byte_813B3C0, 21);
    }
    v4 = CM_DataFromHeader(v7[2]);
    *v8 = v4;
    if ( *v8 != v4 )
      Com_Error(1, (char *)&byte_813B400, 21);
    v3 = CM_DataFromHeader(v7[3]);
    v8[1] = v3;
    if ( v8[1] != v3 )
      Com_Error(1, (char *)&byte_813B440, 21);
    if ( a2 )
    {
      if ( v5 >= dword_8185C64 )
        dword_8185C64 = v5 + 1;
    }
    v7 += 9;
    v8 += 22;
  }
  return result;
}
// 8185C04: using guessed type int dword_8185C04;
// 8185C08: using guessed type int dword_8185C08;
// 8185C64: using guessed type int dword_8185C64;
// 8185CFC: using guessed type int dword_8185CFC;

//----- (08053A80) --------------------------------------------------------
int __cdecl CMod_LoadLeafBrushNodes(int a1)
{
  int result; // eax
  int j; // [esp+18h] [ebp-20h]
  int v3; // [esp+1Ch] [ebp-1Ch]
  int v4; // [esp+20h] [ebp-18h]
  int v5; // [esp+24h] [ebp-14h]
  int v6; // [esp+28h] [ebp-10h]
  int v7; // [esp+2Ch] [ebp-Ch]
  int i; // [esp+30h] [ebp-8h]

  v6 = dword_8185CFC + *(_DWORD *)(a1 + 4);
  v7 = dword_8185C08;
  for ( i = 0; ; ++i )
  {
    result = i;
    if ( i >= dword_8185C04 )
      break;
    v5 = CM_DataFromHeader(*(_DWORD *)(v6 + 20));
    v4 = CM_DataFromHeader(*(_DWORD *)(v6 + 16));
    v3 = 0;
    for ( j = 0; j < v5; ++j )
      v3 |= *(_DWORD *)(dword_8185C60 + 48 * *(unsigned __int16 *)(dword_8185C18 + 2 * (v4 + j)) + 12);
    *(_DWORD *)(v7 + 4) = v3;
    *(_DWORD *)(v7 + 8) = CMod_GetLeafTerrainContents((unsigned __int16 *)v7);
    CMod_PartionLeafBrushes((unsigned __int16 *)(dword_8185C18 + 2 * v4), v5, (_DWORD *)v7);
    v6 += 36;
    v7 += 44;
  }
  return result;
}
// 8185C04: using guessed type int dword_8185C04;
// 8185C08: using guessed type int dword_8185C08;
// 8185C18: using guessed type int dword_8185C18;
// 8185C60: using guessed type int dword_8185C60;
// 8185CFC: using guessed type int dword_8185CFC;

//----- (08053B7E) --------------------------------------------------------
int __usercall CMod_LoadPlanes@<eax>(long double a1@<st0>, int a2, _DWORD *a3)
{
  int result; // eax
  int v4; // eax
  int v5; // eax
  char v6; // [esp+Fh] [ebp-29h]
  char v7; // [esp+17h] [ebp-21h]
  int v8; // [esp+1Ch] [ebp-1Ch]
  int v9; // [esp+20h] [ebp-18h]
  int v10; // [esp+24h] [ebp-14h]
  int j; // [esp+28h] [ebp-10h]
  int i; // [esp+2Ch] [ebp-Ch]

  v9 = a2 + a3[1];
  if ( (*a3 & 0xF) != 0 )
    Com_Error(1, (char *)&byte_813B120);
  v8 = *a3 >> 4;
  if ( !v8 )
    Com_Error(1, (char *)&byte_813B468);
  dword_8185CF8 = (int)CM_Hunk_Alloc(20 * v8);
  cme = v8;
  v10 = dword_8185CF8;
  for ( i = 0; ; ++i )
  {
    result = i;
    if ( i >= v8 )
      break;
    v7 = 0;
    for ( j = 0; j <= 2; ++j )
    {
      v4 = sub_8055080(v9 + 4 * j);
      sub_8055170(*(float *)&v4);
      *(float *)(v10 + 4 * j) = a1;
      a1 = *(float *)(v10 + 4 * j);
      if ( a1 < 0.0 )
        v7 |= 1 << j;
    }
    v5 = sub_8055080(v9 + 12);
    sub_8055170(*(float *)&v5);
    *(float *)(v10 + 12) = a1;
    a1 = 1.0;
    if ( *(float *)v10 == 1.0 )
    {
      v6 = 0;
    }
    else
    {
      a1 = 1.0;
      if ( *(float *)(v10 + 4) == 1.0 )
      {
        v6 = 1;
      }
      else
      {
        a1 = 1.0;
        if ( *(float *)(v10 + 8) == 1.0 )
          v6 = 2;
        else
          v6 = 3;
      }
    }
    *(_BYTE *)(v10 + 16) = v6;
    *(_BYTE *)(v10 + 17) = v7;
    v9 += 16;
    v10 += 20;
  }
  return result;
}
// 8185CF4: using guessed type int cme;
// 8185CF8: using guessed type int dword_8185CF8;

//----- (08053D34) --------------------------------------------------------
int __cdecl CMod_LoadLeafBrushes(_DWORD *a1)
{
  int result; // eax
  int v2; // [esp+10h] [ebp-18h]
  int v3; // [esp+18h] [ebp-10h]
  int *v4; // [esp+1Ch] [ebp-Ch]
  _WORD *v5; // [esp+20h] [ebp-8h]
  int i; // [esp+24h] [ebp-4h]

  v4 = (int *)(dword_8185CFC + a1[1]);
  if ( (*a1 & 3) != 0 )
    Com_Error(1, (char *)&byte_813B4A0);
  v3 = *a1 >> 2;
  dword_8185C18 = (int)CM_Hunk_Alloc(2 * v3 + 2);
  dword_8185C14 = v3;
  v5 = (_WORD *)dword_8185C18;
  for ( i = 0; ; ++i )
  {
    result = i;
    if ( i >= v3 )
      break;
    v2 = CM_DataFromHeader(*v4);
    *v5 = v2;
    if ( (unsigned __int16)*v5 != v2 )
      Com_Error(1, (char *)&byte_813B4E0, 22);
    ++v4;
    ++v5;
  }
  return result;
}
// 8185C14: using guessed type int dword_8185C14;
// 8185C18: using guessed type int dword_8185C18;
// 8185CFC: using guessed type int dword_8185CFC;

//----- (08053E0E) --------------------------------------------------------
int __cdecl CMod_LoadLeafSurfaces(_DWORD *a1)
{
  int result; // eax
  int v2; // [esp+18h] [ebp-10h]
  int *v3; // [esp+1Ch] [ebp-Ch]
  int *v4; // [esp+20h] [ebp-8h]
  int i; // [esp+24h] [ebp-4h]

  v3 = (int *)(dword_8185CFC + a1[1]);
  if ( (*a1 & 3) != 0 )
    Com_Error(1, (char *)&byte_813B520);
  v2 = *a1 >> 2;
  dword_8185C20 = (int)CM_Hunk_Alloc(4 * v2);
  dword_8185C1C = v2;
  v4 = (int *)dword_8185C20;
  for ( i = 0; ; ++i )
  {
    result = i;
    if ( i >= v2 )
      break;
    *v4++ = CM_DataFromHeader(*v3++);
  }
  return result;
}
// 8185C1C: using guessed type int dword_8185C1C;
// 8185C20: using guessed type int dword_8185C20;
// 8185CFC: using guessed type int dword_8185CFC;

//----- (08053EC2) --------------------------------------------------------
int __usercall CMod_LoadCollisionVerts@<eax>(long double a1@<st0>, _DWORD *a2)
{
  int result; // eax
  int v3; // eax
  int v4; // eax
  int v5; // eax
  int v6; // [esp+14h] [ebp-14h]
  int v7; // [esp+18h] [ebp-10h]
  float *v8; // [esp+1Ch] [ebp-Ch]
  int i; // [esp+20h] [ebp-8h]

  v7 = dword_8185CFC + a2[1];
  if ( (*a2 & 0xF) != 0 )
    Com_Error(1, (char *)&byte_813B560);
  v6 = *a2 >> 4;
  dword_8185C28 = (int)CM_Hunk_Alloc(12 * v6);
  dword_8185C24 = v6;
  v8 = (float *)dword_8185C28;
  for ( i = 0; ; ++i )
  {
    result = i;
    if ( i >= v6 )
      break;
    v3 = sub_8055080(v7 + 4);
    sub_8055170(*(float *)&v3);
    *v8 = a1;
    v4 = sub_8055080(v7 + 8);
    sub_8055170(*(float *)&v4);
    v8[1] = a1;
    v5 = sub_8055080(v7 + 12);
    sub_8055170(*(float *)&v5);
    v8[2] = a1;
    v7 += 16;
    v8 += 3;
  }
  return result;
}
// 8185C24: using guessed type int dword_8185C24;
// 8185C28: using guessed type int dword_8185C28;
// 8185CFC: using guessed type int dword_8185CFC;

//----- (08053FC0) --------------------------------------------------------
signed int __usercall CMod_LoadCollisionEdges@<eax>(long double a1@<st0>, _DWORD *a2)
{
  signed int result; // eax
  int v3; // eax
  int v4; // eax
  int v5; // eax
  int v6; // eax
  int v7; // eax
  int v8; // eax
  int v9; // eax
  int v10; // eax
  int v11; // eax
  int v12; // eax
  int v13; // eax
  int v14; // eax
  int v15; // eax
  float v16; // [esp+18h] [ebp-20h]
  float v17; // [esp+1Ch] [ebp-1Ch]
  signed int v18; // [esp+24h] [ebp-14h]
  int v19; // [esp+28h] [ebp-10h]
  float *v20; // [esp+2Ch] [ebp-Ch]
  signed int i; // [esp+30h] [ebp-8h]

  v19 = dword_8185CFC + a2[1];
  if ( *a2 % 0x38u )
    Com_Error(1, (char *)&byte_813B5C0);
  v18 = *a2 / 0x38u;
  dword_8185C30 = (int)CM_Hunk_Alloc(48 * v18);
  dword_8185C2C = v18;
  v20 = (float *)dword_8185C30;
  for ( i = 0; ; ++i )
  {
    result = i;
    if ( i >= v18 )
      break;
    v3 = sub_8055080(v19 + 4);
    sub_8055170(*(float *)&v3);
    *v20 = a1;
    v4 = sub_8055080(v19 + 8);
    sub_8055170(*(float *)&v4);
    v20[1] = a1;
    v5 = sub_8055080(v19 + 12);
    sub_8055170(*(float *)&v5);
    v20[2] = a1;
    v6 = sub_8055080(v19 + 16);
    sub_8055170(*(float *)&v6);
    v20[3] = a1;
    v7 = sub_8055080(v19 + 20);
    sub_8055170(*(float *)&v7);
    v20[4] = a1;
    v8 = sub_8055080(v19 + 24);
    sub_8055170(*(float *)&v8);
    v20[5] = a1;
    v9 = sub_8055080(v19 + 28);
    sub_8055170(*(float *)&v9);
    v20[6] = a1;
    v10 = sub_8055080(v19 + 32);
    sub_8055170(*(float *)&v10);
    v20[7] = a1;
    v11 = sub_8055080(v19 + 36);
    sub_8055170(*(float *)&v11);
    v20[8] = a1;
    v12 = sub_8055080(v19 + 40);
    sub_8055170(*(float *)&v12);
    v20[9] = a1;
    v13 = sub_8055080(v19 + 44);
    sub_8055170(*(float *)&v13);
    v20[10] = a1;
    v14 = sub_8055080(v19 + 48);
    sub_8055170(*(float *)&v14);
    v20[11] = a1;
    v15 = sub_8055080(v19 + 52);
    sub_8055170(*(float *)&v15);
    v17 = a1;
    a1 = 1.0 / v17;
    v16 = a1;
    sub_80550DE(v20 + 9, v16, v20 + 9);
    v19 += 56;
    v20 += 12;
  }
  return result;
}
// 8185C2C: using guessed type int dword_8185C2C;
// 8185C30: using guessed type int dword_8185C30;
// 8185CFC: using guessed type int dword_8185CFC;

//----- (08054220) --------------------------------------------------------
signed int __usercall CMod_LoadCollisionTriangles@<eax>(long double a1@<st0>, _DWORD *a2)
{
  signed int result; // eax
  int v3; // eax
  int v4; // eax
  int v5; // eax
  int v6; // eax
  int v7; // eax
  int v8; // eax
  int v9; // eax
  int v10; // eax
  int v11; // eax
  int v12; // eax
  int v13; // eax
  int v14; // eax
  int j; // [esp+1Ch] [ebp-1Ch]
  signed int v16; // [esp+20h] [ebp-18h]
  int v17; // [esp+24h] [ebp-14h]
  float *v18; // [esp+28h] [ebp-10h]
  signed int i; // [esp+2Ch] [ebp-Ch]

  v17 = dword_8185CFC + a2[1];
  if ( *a2 % 0x48u )
    Com_Error(1, (char *)&byte_813B620);
  v16 = *a2 / 0x48u;
  dword_8185C38 = (int)CM_Hunk_Alloc(72 * v16);
  dword_8185C34 = v16;
  v18 = (float *)dword_8185C38;
  for ( i = 0; ; ++i )
  {
    result = i;
    if ( i >= v16 )
      break;
    v3 = sub_8055080(v17);
    sub_8055170(*(float *)&v3);
    *v18 = a1;
    v4 = sub_8055080(v17 + 4);
    sub_8055170(*(float *)&v4);
    v18[1] = a1;
    v5 = sub_8055080(v17 + 8);
    sub_8055170(*(float *)&v5);
    v18[2] = a1;
    v6 = sub_8055080(v17 + 12);
    sub_8055170(*(float *)&v6);
    v18[3] = a1;
    v7 = sub_8055080(v17 + 16);
    sub_8055170(*(float *)&v7);
    v18[4] = a1;
    v8 = sub_8055080(v17 + 20);
    sub_8055170(*(float *)&v8);
    v18[5] = a1;
    v9 = sub_8055080(v17 + 24);
    sub_8055170(*(float *)&v9);
    v18[6] = a1;
    v10 = sub_8055080(v17 + 28);
    sub_8055170(*(float *)&v10);
    v18[7] = a1;
    v11 = sub_8055080(v17 + 32);
    sub_8055170(*(float *)&v11);
    v18[8] = a1;
    v12 = sub_8055080(v17 + 36);
    sub_8055170(*(float *)&v12);
    v18[9] = a1;
    v13 = sub_8055080(v17 + 40);
    sub_8055170(*(float *)&v13);
    v18[10] = a1;
    v14 = sub_8055080(v17 + 44);
    sub_8055170(*(float *)&v14);
    v18[11] = a1;
    for ( j = 0; j <= 2; ++j )
    {
      LODWORD(v18[j + 15]) = CM_DataFromHeader(*(_DWORD *)(v17 + 4 * j + 60));
      LODWORD(v18[j + 12]) = CM_DataFromHeader(*(_DWORD *)(v17 + 4 * j + 48));
    }
    v17 += 72;
    v18 += 18;
  }
  return result;
}
// 8185C34: using guessed type int dword_8185C34;
// 8185C38: using guessed type int dword_8185C38;
// 8185CFC: using guessed type int dword_8185CFC;

//----- (0805448C) --------------------------------------------------------
signed int __usercall CMod_LoadCollisionBorders@<eax>(long double a1@<st0>, _DWORD *a2)
{
  signed int result; // eax
  int v3; // eax
  int v4; // eax
  int v5; // eax
  int v6; // eax
  int v7; // eax
  int v8; // eax
  int v9; // eax
  signed int v10; // [esp+14h] [ebp-14h]
  int v11; // [esp+18h] [ebp-10h]
  float *v12; // [esp+1Ch] [ebp-Ch]
  signed int i; // [esp+20h] [ebp-8h]

  v11 = dword_8185CFC + a2[1];
  if ( *a2 % 0x1Cu )
    Com_Error(1, (char *)&byte_813B680);
  v10 = *a2 / 0x1Cu;
  dword_8185C40 = (int)CM_Hunk_Alloc(28 * v10);
  dword_8185C3C = v10;
  v12 = (float *)dword_8185C40;
  for ( i = 0; ; ++i )
  {
    result = i;
    if ( i >= v10 )
      break;
    v3 = sub_8055080(v11);
    sub_8055170(*(float *)&v3);
    *v12 = a1;
    v4 = sub_8055080(v11 + 4);
    sub_8055170(*(float *)&v4);
    v12[1] = a1;
    v5 = sub_8055080(v11 + 8);
    sub_8055170(*(float *)&v5);
    v12[2] = a1;
    v6 = sub_8055080(v11 + 12);
    sub_8055170(*(float *)&v6);
    v12[3] = a1;
    v7 = sub_8055080(v11 + 16);
    sub_8055170(*(float *)&v7);
    v12[4] = a1;
    v8 = sub_8055080(v11 + 20);
    sub_8055170(*(float *)&v8);
    v12[5] = a1;
    v9 = sub_8055080(v11 + 24);
    sub_8055170(*(float *)&v9);
    v12[6] = a1;
    v11 += 28;
    v12 += 7;
  }
  return result;
}
// 8185C3C: using guessed type int dword_8185C3C;
// 8185C40: using guessed type int dword_8185C40;
// 8185CFC: using guessed type int dword_8185CFC;

//----- (0805461E) --------------------------------------------------------
signed int __cdecl CMod_LoadCollisionPartitions(_DWORD *a1)
{
  signed int result; // eax
  signed int v2; // [esp+14h] [ebp-14h]
  int v3; // [esp+18h] [ebp-10h]
  int v4; // [esp+1Ch] [ebp-Ch]
  signed int i; // [esp+20h] [ebp-8h]

  v3 = dword_8185CFC + a1[1];
  if ( *a1 % 0xCu )
    Com_Error(1, (char *)&byte_813B6E0);
  v2 = *a1 / 0xCu;
  dword_8185C48 = (int)CM_Hunk_Alloc(12 * v2);
  dword_8185C44 = v2;
  v4 = dword_8185C48;
  for ( i = 0; ; ++i )
  {
    result = i;
    if ( i >= v2 )
      break;
    *(_BYTE *)v4 = *(_BYTE *)(v3 + 2);
    *(_BYTE *)(v4 + 1) = *(_BYTE *)(v3 + 3);
    *(_DWORD *)(v4 + 4) = dword_8185C38 + 72 * CM_DataFromHeader(*(_DWORD *)(v3 + 4));
    *(_DWORD *)(v4 + 8) = dword_8185C40 + 28 * CM_DataFromHeader(*(_DWORD *)(v3 + 8));
    v3 += 12;
    v4 += 12;
  }
  return result;
}
// 8185C38: using guessed type int dword_8185C38;
// 8185C40: using guessed type int dword_8185C40;
// 8185C44: using guessed type int dword_8185C44;
// 8185C48: using guessed type int dword_8185C48;
// 8185CFC: using guessed type int dword_8185CFC;

//----- (0805474E) --------------------------------------------------------
int __usercall CMod_LoadCollisionAabbTrees@<eax>(long double a1@<st0>, _DWORD *a2)
{
  int result; // eax
  int v3; // eax
  int v4; // eax
  int v5; // eax
  int v6; // eax
  int v7; // eax
  int v8; // eax
  int v9; // [esp+14h] [ebp-14h]
  int v10; // [esp+18h] [ebp-10h]
  int v11; // [esp+1Ch] [ebp-Ch]
  int i; // [esp+20h] [ebp-8h]

  v10 = dword_8185CFC + a2[1];
  if ( (*a2 & 0x1F) != 0 )
    Com_Error(1, (char *)&byte_813B740);
  v9 = *a2 >> 5;
  dword_8185C50 = (int)CM_Hunk_Alloc(32 * v9);
  dword_8185C4C = v9;
  v11 = dword_8185C50;
  for ( i = 0; ; ++i )
  {
    result = i;
    if ( i >= v9 )
      break;
    v3 = sub_8055080(v10);
    sub_8055170(*(float *)&v3);
    *(float *)v11 = a1;
    v4 = sub_8055080(v10 + 4);
    sub_8055170(*(float *)&v4);
    *(float *)(v11 + 4) = a1;
    v5 = sub_8055080(v10 + 8);
    sub_8055170(*(float *)&v5);
    *(float *)(v11 + 8) = a1;
    v6 = sub_8055080(v10 + 12);
    sub_8055170(*(float *)&v6);
    *(float *)(v11 + 12) = a1;
    v7 = sub_8055080(v10 + 16);
    sub_8055170(*(float *)&v7);
    *(float *)(v11 + 16) = a1;
    v8 = sub_8055080(v10 + 20);
    sub_8055170(*(float *)&v8);
    *(float *)(v11 + 20) = a1;
    *(_WORD *)(v11 + 24) = sub_8055154(*(_WORD *)(v10 + 24));
    *(_WORD *)(v11 + 26) = sub_8055154(*(_WORD *)(v10 + 26));
    *(_DWORD *)(v11 + 28) = CM_DataFromHeader(*(_DWORD *)(v10 + 28));
    v10 += 32;
    v11 += 32;
  }
  return result;
}
// 8185C4C: using guessed type int dword_8185C4C;
// 8185C50: using guessed type int dword_8185C50;
// 8185CFC: using guessed type int dword_8185CFC;

//----- (080548DC) --------------------------------------------------------
void *__cdecl CMod_LoadEntityString(size_t *a1)
{
  dword_8185C74 = *a1;
  dword_8185C78 = CM_Hunk_Alloc(*a1);
  return Com_Memcpy(dword_8185C78, (void *)(dword_8185CFC + a1[1]), *a1);
}
// 8185C74: using guessed type int dword_8185C74;
// 8185CFC: using guessed type int dword_8185CFC;

//----- (08054936) --------------------------------------------------------
void *__cdecl CMod_LoadVisibility(int *a1)
{
  int *v2; // [esp+10h] [ebp-8h]
  int v3; // [esp+14h] [ebp-4h]

  v3 = *a1;
  if ( *a1 )
  {
    v2 = (int *)(dword_8185CFC + a1[1]);
    dword_8185C70 = 1;
    dword_8185C64 = CM_DataFromHeader(*v2);
    n = CM_DataFromHeader(v2[1]);
    dword_8185C6C = CM_Hunk_Alloc(v3 - 8);
    return Com_Memcpy(dword_8185C6C, v2 + 2, v3 - 8);
  }
  else
  {
    n = (dword_8185C64 + 31) & 0xFFFFFFE0;
    dword_8185C6C = CM_Hunk_Alloc((dword_8185C64 + 31) & 0xFFFFFFE0);
    return Com_Memset(dword_8185C6C, 255, n);
  }
}
// 8185C64: using guessed type int dword_8185C64;
// 8185C70: using guessed type int dword_8185C70;
// 8185CFC: using guessed type int dword_8185CFC;

//----- (08054A26) --------------------------------------------------------
int __usercall CMod_LoadBrushRelated@<eax>(long double a1@<st0>, _DWORD *a2, char a3)
{
  unsigned int v3; // eax
  char *v5; // [esp+18h] [ebp-10h]
  int n; // [esp+1Ch] [ebp-Ch]

  CMod_LoadBrushes(a1, a2 + 14, a2 + 12);
  CMod_LoadLeafBrushes(a2 + 56);
  CMod_LoadCollisionAabbTrees(a1, a2 + 70);
  CMod_LoadLeafs(a2 + 54, a3);
  CMod_LoadSubmodels(a1, a2 + 72);
  Hunk_UserCreate();
  TempMemoryReset();
  dword_8185C10 = (void *)(TempMalloc(0) - 20);
  CMod_LoadLeafBrushNodes((int)(a2 + 54));
  CMod_LoadSubmodelBrushNodes((int)(a2 + 72));
  CM_InitBoxHull();
  dword_8185C10 = (char *)dword_8185C10 + 20;
  v3 = TempMalloc(0);
  n = 4 * ((int)(v3 - (_DWORD)dword_8185C10) >> 2);
  dword_8185C0C = -858993459 * ((int)(v3 - (_DWORD)dword_8185C10) >> 2) + 1;
  v5 = (char *)CM_Hunk_Alloc(20 * dword_8185C0C);
  memcpy(v5 + 20, dword_8185C10, n);
  dword_8185C10 = v5;
  return Hunk_UserDestroy();
}
// 8185C0C: using guessed type int dword_8185C0C;

//----- (08054B6C) --------------------------------------------------------
void *__usercall CM_LoadMapFromBsp@<eax>(long double a1@<st0>, char *s, char a3)
{
  size_t v3; // eax
  void *result; // eax
  _DWORD *v5; // [esp+10h] [ebp-8h]

  Com_Memset(&dest, 0, 0x110u);
  Com_Memset(&cme, 0, 0xCu);
  v3 = strlen(s);
  dest = (char *)CM_Hunk_Alloc(v3 + 1);
  strcpy(dest, s);
  v5 = Com_GetBspHeader(0, &dword_8185CEC);
  dword_8185CFC = (int)v5;
  CMod_LoadMaterials(v5 + 2);
  CMod_LoadPlanes(a1, dword_8185CFC, v5 + 10);
  CMod_LoadBrushRelated(a1, v5, a3);
  CMod_LoadNodes(v5 + 52);
  CMod_LoadLeafSurfaces(v5 + 58);
  CMod_LoadCollisionVerts(a1, v5 + 60);
  CMod_LoadCollisionEdges(a1, v5 + 62);
  CMod_LoadCollisionTriangles(a1, v5 + 64);
  CMod_LoadCollisionBorders(a1, v5 + 66);
  CMod_LoadCollisionPartitions(v5 + 68);
  if ( a3 )
  {
    CMod_LoadVisibility(v5 + 74);
  }
  else if ( v5[74] )
  {
    Com_Error(1, "In single player, do not compile the bsp with visibility", 21);
  }
  result = CMod_LoadEntityString(v5 + 76);
  dword_8185CFC = 0;
  return result;
}
// 8185CEC: using guessed type int dword_8185CEC;
// 8185CF4: using guessed type int cme;
// 8185CFC: using guessed type int dword_8185CFC;

//----- (08054D08) --------------------------------------------------------
int CM_InitBoxHull()
{
  char *v0; // eax
  int result; // eax

  dword_8185C7C = dword_8185C60 + 48 * (unsigned __int16)word_8185C5C;
  *(_DWORD *)(dword_8185C7C + 28) = 0;
  *(_DWORD *)(dword_8185C7C + 32) = 0;
  *(_DWORD *)(dword_8185C7C + 12) = -1;
  dword_8185CA0 = -1;
  dword_8185CA4 = 0;
  CM_VectorSet(dword_8185CA8, 2139095039, 2139095039, 2139095039);
  CM_VectorSet(dword_8185CB4, -8388609, -8388609, -8388609);
  *(_WORD *)(dword_8185C7C + 36) = -1;
  *(_WORD *)(dword_8185C7C + 38) = -1;
  *(_WORD *)(dword_8185C7C + 40) = -1;
  *(_WORD *)(dword_8185C7C + 42) = -1;
  *(_WORD *)(dword_8185C7C + 44) = -1;
  *(_WORD *)(dword_8185C7C + 46) = -1;
  v0 = (char *)CMod_AllocLeafBrushNode();
  dword_8185CC0 = -858993459 * ((v0 - (_BYTE *)dword_8185C10) >> 2);
  *((_WORD *)v0 + 1) = 1;
  *((_DWORD *)v0 + 2) = dword_8185C18 + 2 * dword_8185C14;
  result = (unsigned __int16)word_8185C5C;
  *(_WORD *)(dword_8185C18 + 2 * dword_8185C14) = word_8185C5C;
  return result;
}
// 8185C14: using guessed type int dword_8185C14;
// 8185C18: using guessed type int dword_8185C18;
// 8185C5C: using guessed type __int16 word_8185C5C;
// 8185C60: using guessed type int dword_8185C60;
// 8185C7C: using guessed type int dword_8185C7C;
// 8185CA0: using guessed type int dword_8185CA0;
// 8185CA4: using guessed type int dword_8185CA4;
// 8185CA8: using guessed type _DWORD dword_8185CA8[3];
// 8185CB4: using guessed type _DWORD dword_8185CB4[3];
// 8185CC0: using guessed type int dword_8185CC0;

//----- (08054E4A) --------------------------------------------------------
void CM_Cleanup()
{
  dword_8185CFC = 0;
}
// 8185CFC: using guessed type int dword_8185CFC;

//----- (08054E72) --------------------------------------------------------
int __cdecl sub_8054E72(int a1, _DWORD *a2)
{
  int v2; // eax
  int size; // [esp+14h] [ebp-154h]
  int v6; // [esp+18h] [ebp-150h] BYREF
  unsigned int i; // [esp+1Ch] [ebp-14Ch]
  int v8[82]; // [esp+20h] [ebp-148h] BYREF

  FS_FOpenFileRead(dest, &v6, 0);
  if ( !v6 )
    Com_Error(1, aExeErrCouldntL_0, dest);
  FS_Read((int)v8, 0x140u, v6);
  for ( i = 0; i <= 0x4F; ++i )
  {
    v2 = CM_DataFromHeader(v8[i]);
    v8[i] = v2;
  }
  size = v8[2 * a1 + 2];
  if ( size )
  {
    sub_809E580(v6, v8[2 * a1 + 3] - 320, 0);
    dword_8185D00 = Hunk_AllocateTempMemoryInternal(size);
    FS_Read((int)dword_8185D00, size, v6);
    FS_FCloseFile(v6);
    *a2 = dword_8185D00;
    return size;
  }
  else
  {
    FS_FCloseFile(v6);
    return 0;
  }
}

//----- (08054FE2) --------------------------------------------------------
void sub_8054FE2()
{
  Hunk_FreeTempMemory(dword_8185D00);
}

//----- (08054FF8) --------------------------------------------------------
long double __cdecl sub_8054FF8(float a1)
{
  return (float)fabs(a1);
}

//----- (08055012) --------------------------------------------------------
void __cdecl sub_8055012(float a1, float a2)
{
  float v2; // [esp+0h] [ebp-18h]

  v2 = a1 - a2;
  sub_8055184(v2, a1, a2);
}

//----- (08055036) --------------------------------------------------------
void __cdecl sub_8055036(float a1, float a2)
{
  float v2; // [esp+0h] [ebp-18h]

  v2 = a2 - a1;
  sub_8055184(v2, a1, a2);
}

//----- (0805505A) --------------------------------------------------------
int __cdecl sub_805505A(int a1, int a2)
{
  return sub_80551CE(a2 - a1, a1, a2);
}

//----- (08055080) --------------------------------------------------------
int __cdecl sub_8055080(int a1)
{
  return *(_DWORD *)a1;
}

//----- (0805508A) --------------------------------------------------------
int __cdecl CM_VectorSet(_DWORD *a1, int a2, int a3, int a4)
{
  int result; // eax

  *a1 = a2;
  a1[1] = a3;
  result = a4;
  a1[2] = a4;
  return result;
}

//----- (080550AE) --------------------------------------------------------
int __cdecl CM_VectorCopy(_DWORD *a1, _DWORD *a2)
{
  int result; // eax

  *a2 = *a1;
  a2[1] = a1[1];
  result = a1[2];
  a2[2] = result;
  return result;
}

//----- (080550DE) --------------------------------------------------------
float *__cdecl sub_80550DE(float *a1, float a2, float *a3)
{
  float *result; // eax

  *a3 = a2 * *a1;
  a3[1] = a2 * a1[1];
  result = a1 + 2;
  a3[2] = a2 * a1[2];
  return result;
}

//----- (08055116) --------------------------------------------------------
void __cdecl sub_8055116(float *a1)
{
  float v1; // [esp+0h] [ebp-8h]

  v1 = *a1 * *a1 + a1[1] * a1[1] + a1[2] * a1[2];
  sub_80551AE(v1);
}

//----- (08055154) --------------------------------------------------------
int __cdecl sub_8055154(__int16 a1)
{
  return a1;
}

//----- (08055168) --------------------------------------------------------
int __cdecl CM_DataFromHeader(int a1)
{
  return a1;
}

//----- (08055170) --------------------------------------------------------
void __cdecl sub_8055170(float a1)
{
  sub_80551EE(a1);
}

//----- (08055184) --------------------------------------------------------
long double __cdecl sub_8055184(float a1, float a2, float a3)
{
  if ( a1 < 0.0 )
    return a3;
  return a2;
}

//----- (080551AE) --------------------------------------------------------
long double __cdecl sub_80551AE(float a1)
{
  return (float)sqrt(a1);
}

//----- (080551CE) --------------------------------------------------------
int __cdecl sub_80551CE(int a1, int a2, int a3)
{
  if ( a1 < 0 )
    return a3;
  return a2;
}

//----- (080551EE) --------------------------------------------------------
long double __cdecl sub_80551EE(float a1)
{
  return a1;
}

//----- (08055200) --------------------------------------------------------
_BOOL4 __cdecl sub_8055200(int a1, float *a2, float *a3)
{
  long double v3; // fst7
  long double v4; // fst7
  long double v5; // fst7
  long double v6; // fst7
  long double v7; // fst7
  long double v8; // fst7
  float v10; // [esp+0h] [ebp-48h]
  float v11; // [esp+0h] [ebp-48h]
  float v12; // [esp+0h] [ebp-48h]
  float v14; // [esp+20h] [ebp-28h] BYREF
  float v15; // [esp+24h] [ebp-24h]
  float v16; // [esp+28h] [ebp-20h]
  float v17; // [esp+30h] [ebp-18h] BYREF
  float v18; // [esp+34h] [ebp-14h]
  float v19; // [esp+38h] [ebp-10h]

  sub_8056016((float *)(a1 + 56), a2, &v17);
  sub_8055FD2(a3, (float *)(a1 + 92), &v14);
  v3 = sub_8055F88(v17);
  if ( v3 > v14 + *(float *)(a1 + 80) )
    return 1;
  v4 = sub_8055F88(v18);
  if ( v4 > v15 + *(float *)(a1 + 84) )
    return 1;
  v5 = sub_8055F88(v19);
  if ( v5 > v16 + *(float *)(a1 + 88) )
    return 1;
  if ( *(_DWORD *)(a1 + 136) )
    return 0;
  v10 = *(float *)(a1 + 72) * v19 - *(float *)(a1 + 76) * v18;
  v6 = sub_8055F88(v10);
  if ( v6 > v15 * *(float *)(a1 + 88) + v16 * *(float *)(a1 + 84) )
    return 1;
  v11 = *(float *)(a1 + 76) * v17 - *(float *)(a1 + 68) * v19;
  v7 = sub_8055F88(v11);
  if ( v7 > v16 * *(float *)(a1 + 80) + v14 * *(float *)(a1 + 88) )
    return 1;
  v12 = *(float *)(a1 + 68) * v18 - *(float *)(a1 + 72) * v17;
  v8 = sub_8055F88(v12);
  return v8 > v14 * *(float *)(a1 + 84) + v15 * *(float *)(a1 + 80);
}

//----- (080553B2) --------------------------------------------------------
void __cdecl sub_80553B2(int a1, float *a2, int a3)
{
  float v3; // [esp+0h] [ebp-C8h]
  int v4; // [esp+1Ch] [ebp-ACh]
  int v5; // [esp+20h] [ebp-A8h]
  int v6; // [esp+24h] [ebp-A4h]
  float v7; // [esp+28h] [ebp-A0h]
  float v8; // [esp+2Ch] [ebp-9Ch]
  float v9; // [esp+30h] [ebp-98h]
  float v10; // [esp+34h] [ebp-94h]
  float v11; // [esp+38h] [ebp-90h]
  float v12; // [esp+3Ch] [ebp-8Ch]
  int v13[2]; // [esp+40h] [ebp-88h] BYREF
  float v14; // [esp+48h] [ebp-80h]
  float v15; // [esp+5Ch] [ebp-6Ch]
  float v16; // [esp+60h] [ebp-68h]
  float v17; // [esp+64h] [ebp-64h]
  float v18; // [esp+68h] [ebp-60h]
  float *v19; // [esp+6Ch] [ebp-5Ch]
  float v20; // [esp+70h] [ebp-58h]
  float *v21; // [esp+74h] [ebp-54h]
  float v22; // [esp+78h] [ebp-50h]
  float v23; // [esp+7Ch] [ebp-4Ch]
  int v24[5]; // [esp+80h] [ebp-48h] BYREF
  int v25; // [esp+94h] [ebp-34h]
  float v26; // [esp+98h] [ebp-30h]
  float v27; // [esp+9Ch] [ebp-2Ch]
  int v28[7]; // [esp+A0h] [ebp-28h] BYREF
  int i; // [esp+BCh] [ebp-Ch]

  v7 = *(float *)(a1 + 144);
  if ( a2[2] < 0.0 )
    HIBYTE(v7) ^= 0x80u;
  sub_8055FA2((_DWORD *)a1, v13);
  v14 = v14 - v7;
  v17 = *(float *)(a1 + 140);
  v11 = sub_80560AE((float *)v13, a2) - a2[3];
  if ( v11 < (long double)v17 )
  {
    LODWORD(v18) = LODWORD(v17) ^ 0x80000000;
    if ( COERCE_FLOAT(LODWORD(v17) ^ 0x80000000) < (long double)v11 )
    {
      v25 = 0;
      sub_805605A((float *)v13, COERCE_FLOAT(LODWORD(v11) ^ 0x80000000), a2, (float *)v28);
      v27 = sub_80560AE((float *)v28, a2 + 4) - a2[7];
      v26 = sub_80560AE((float *)v28, a2 + 8) - a2[11];
      v6 = v25;
      if ( v27 + v26 > 1.0 )
        v6 = v25 | 1;
      v25 = v6;
      v5 = v6;
      if ( v27 < 0.0 )
        v5 = v6 | 2;
      v25 = v5;
      v4 = v5;
      if ( v26 < 0.0 )
        v4 = v5 | 4;
      v25 = v4;
      if ( v4 )
      {
        for ( i = 0; i <= 2; ++i )
        {
          if ( ((v25 >> i) & 1) != 0 )
          {
            v22 = a2[i + 15];
            if ( v22 >= 0.0 )
            {
              v21 = (float *)(dword_8185C30 + 48 * LODWORD(v22));
              sub_8056016((float *)v13, v21, (float *)v24);
              v23 = sub_80560AE((float *)v24, v21 + 9);
              v3 = v23 - 0.5;
              if ( sub_8055F88(v3) <= 0.5 )
              {
                v8 = sub_80560E2(v21 + 9);
                v23 = v23 / v8;
                sub_805605A((float *)v24, COERCE_FLOAT(LODWORD(v23) ^ 0x80000000), v21 + 9, (float *)v24);
                if ( *(float *)(a1 + 140) * *(float *)(a1 + 140) > sub_80560E2((float *)v24) )
                {
                  *(_BYTE *)(a3 + 35) = 1;
                  *(_BYTE *)(a3 + 34) = 1;
                  *(_DWORD *)a3 = 0;
                  return;
                }
              }
            }
          }
          else
          {
            v20 = a2[i + 12];
            if ( v20 >= 0.0 )
            {
              v19 = (float *)(dword_8185C28 + 12 * LODWORD(v20));
              sub_8056016((float *)v13, v19, (float *)v24);
              if ( *(float *)(a1 + 140) * *(float *)(a1 + 140) > sub_80560E2((float *)v24) )
              {
                *(_BYTE *)(a3 + 35) = 1;
                *(_BYTE *)(a3 + 34) = 1;
                *(_DWORD *)a3 = 0;
                return;
              }
            }
          }
        }
      }
      else
      {
        *(_BYTE *)(a3 + 35) = 1;
        *(_BYTE *)(a3 + 34) = 1;
        *(_DWORD *)a3 = 0;
      }
    }
    else
    {
      v12 = v7 + v7;
      v15 = v12 * a2[2] + v11;
      if ( v18 < (long double)v15 )
      {
        v16 = (v18 - v11) / a2[2];
        v10 = sub_80560AE((float *)v13, a2 + 4) - a2[7];
        v9 = sub_80560AE((float *)v13, a2 + 8) - a2[11];
        v27 = v16 * a2[6] + v10;
        if ( v27 < 0.0 || (v26 = v16 * a2[10] + v9, v26 < 0.0) || v27 + v26 > 1.0 )
        {
          if ( v17 <= (long double)v15 )
            v16 = (v17 - v11) / a2[2];
          else
            v16 = v7 + v7;
          v27 = v16 * a2[6] + v10;
          if ( v27 >= 0.0 )
          {
            v26 = v16 * a2[10] + v9;
            if ( v26 >= 0.0 && v27 + v26 <= 1.0 )
            {
              *(_BYTE *)(a3 + 35) = 1;
              *(_BYTE *)(a3 + 34) = 1;
              *(_DWORD *)a3 = 0;
            }
          }
        }
        else
        {
          *(_BYTE *)(a3 + 35) = 1;
          *(_BYTE *)(a3 + 34) = 1;
          *(_DWORD *)a3 = 0;
        }
      }
    }
  }
}
// 8185C28: using guessed type int dword_8185C28;
// 8185C30: using guessed type int dword_8185C30;

//----- (080558EC) --------------------------------------------------------
void __cdecl sub_80558EC(int a1, int a2, int a3)
{
  float *v3; // [esp+18h] [ebp-20h]
  int i; // [esp+1Ch] [ebp-1Ch]
  int j; // [esp+1Ch] [ebp-1Ch]
  int k; // [esp+20h] [ebp-18h]
  __int16 v7; // [esp+26h] [ebp-12h]
  unsigned __int8 *v8; // [esp+28h] [ebp-10h]
  int v9; // [esp+2Ch] [ebp-Ch]
  int v10; // [esp+30h] [ebp-8h]
  int v11; // [esp+34h] [ebp-4h]

  if ( !sub_8055200(a1, (float *)a2, (float *)(a2 + 12)) )
  {
    if ( *(_WORD *)(a2 + 26) )
    {
      v11 = 0;
      v10 = dword_8185C50 + 32 * *(_DWORD *)(a2 + 28);
      while ( v11 < *(unsigned __int16 *)(a2 + 26) )
      {
        sub_80558EC(a1, v10, a3);
        ++v11;
        v10 += 32;
      }
    }
    else
    {
      v9 = *(_DWORD *)(a2 + 28);
      v7 = *(_WORD *)(a1 + 160);
      if ( *(unsigned __int16 *)(*(_DWORD *)(a1 + 172) + 2 * v9) != v7 )
      {
        *(_WORD *)(*(_DWORD *)(a1 + 172) + 2 * v9) = v7;
        v8 = (unsigned __int8 *)(dword_8185C48 + 12 * v9);
        if ( *(_DWORD *)(a1 + 132) )
        {
          for ( i = 0; i < *v8; ++i )
            sub_8056116((float *)a1, (float *)(*((_DWORD *)v8 + 1) + 72 * i), a3);
        }
        else
        {
          for ( j = 0; j < *v8; ++j )
          {
            v3 = (float *)(*((_DWORD *)v8 + 1) + 72 * j);
            sub_805628C(a1, v3, *(float *)(a1 + 144), a3);
            if ( v3[2] < 0.0 )
              sub_805628C(a1, v3, COERCE_FLOAT(*(_DWORD *)(a1 + 144) ^ 0x80000000), a3);
          }
          if ( (*(float *)(a1 + 36) != 0.0 || *(float *)(a1 + 40) != 0.0) && *(float *)(a1 + 144) != 0.0 )
          {
            for ( k = 0; k < v8[1]; ++k )
              sub_8056E42((float *)a1, *((_DWORD *)v8 + 2) + 28 * k, a3);
          }
        }
      }
    }
  }
}
// 8185C48: using guessed type int dword_8185C48;
// 8185C50: using guessed type int dword_8185C50;

//----- (08055B48) --------------------------------------------------------
int __cdecl sub_8055B48(int a1, int a2, int a3)
{
  int result; // eax
  int j; // [esp+10h] [ebp-18h]
  __int16 v5; // [esp+16h] [ebp-12h]
  unsigned __int8 *v6; // [esp+18h] [ebp-10h]
  int v7; // [esp+1Ch] [ebp-Ch]
  int i; // [esp+20h] [ebp-8h]
  int v9; // [esp+24h] [ebp-4h]

  result = sub_8055200(a1, (float *)a2, (float *)(a2 + 12));
  if ( !(_BYTE)result )
  {
    if ( *(_WORD *)(a2 + 26) )
    {
      v9 = 0;
      for ( i = dword_8185C50 + 32 * *(_DWORD *)(a2 + 28); ; i += 32 )
      {
        result = *(unsigned __int16 *)(a2 + 26);
        if ( v9 >= result )
          break;
        sub_8055B48(a1, i, a3);
        ++v9;
      }
    }
    else
    {
      v7 = *(_DWORD *)(a2 + 28);
      v5 = *(_WORD *)(a1 + 160);
      result = v5;
      if ( *(unsigned __int16 *)(*(_DWORD *)(a1 + 172) + 2 * v7) != v5 )
      {
        *(_WORD *)(*(_DWORD *)(a1 + 172) + 2 * v7) = v5;
        v6 = (unsigned __int8 *)(dword_8185C48 + 12 * v7);
        for ( j = 0; ; ++j )
        {
          result = *v6;
          if ( j >= result )
            break;
          sub_80553B2(a1, (float *)(*((_DWORD *)v6 + 1) + 72 * j), a3);
        }
      }
    }
  }
  return result;
}
// 8185C48: using guessed type int dword_8185C48;
// 8185C50: using guessed type int dword_8185C50;

//----- (08055C74) --------------------------------------------------------
void __cdecl sub_8055C74(int a1, int a2, int a3)
{
  char *v3; // [esp+10h] [ebp-8h]
  float v4; // [esp+14h] [ebp-4h]

  v3 = (char *)dword_8185BF0 + 72 * *(unsigned __int16 *)(a2 + 24);
  if ( (*(_DWORD *)(a1 + 128) & *((_DWORD *)v3 + 17)) != 0 )
  {
    v4 = *(float *)a3;
    sub_80558EC(a1, a2, a3);
    if ( v4 > (long double)*(float *)a3 )
    {
      *(_DWORD *)(a3 + 16) = *((_DWORD *)v3 + 16);
      *(_DWORD *)(a3 + 20) = *((_DWORD *)v3 + 17);
      *(_DWORD *)(a3 + 24) = v3;
    }
  }
}

//----- (08055CFE) --------------------------------------------------------
void __cdecl sub_8055CFE(int a1, int a2, int a3)
{
  if ( (*(_DWORD *)(a1 + 128) & *((_DWORD *)dword_8185BF0 + 18 * *(unsigned __int16 *)(a2 + 24) + 17)) != 0 )
    sub_8055C74(a1, a2, a3);
}

//----- (08055D4C) --------------------------------------------------------
int __cdecl sub_8055D4C(int a1, unsigned __int16 *a2, int a3)
{
  int result; // eax
  int v4; // [esp+Ch] [ebp-Ch]
  char *v5; // [esp+10h] [ebp-8h]
  int i; // [esp+14h] [ebp-4h]

  for ( i = 0; ; ++i )
  {
    result = a2[1];
    if ( i >= result )
      break;
    v4 = dword_8185C50 + 32 * (i + *a2);
    v5 = (char *)dword_8185BF0 + 72 * *(unsigned __int16 *)(v4 + 24);
    if ( (*(_DWORD *)(a1 + 128) & *((_DWORD *)v5 + 17)) != 0 )
    {
      sub_8055B48(a1, v4, a3);
      if ( *(_BYTE *)(a3 + 34) )
      {
        *(_DWORD *)(a3 + 16) = *((_DWORD *)v5 + 16);
        *(_DWORD *)(a3 + 20) = *((_DWORD *)v5 + 17);
        result = (int)v5;
        *(_DWORD *)(a3 + 24) = v5;
        return result;
      }
    }
  }
  return result;
}
// 8185C50: using guessed type int dword_8185C50;

//----- (08055E02) --------------------------------------------------------
int __cdecl sub_8055E02(float *a1, float *a2, float *a3, float *a4, float *a5, float *a6, float *a7, float *a8)
{
  float v10; // [esp+1Ch] [ebp-6Ch]
  float v11[4]; // [esp+20h] [ebp-68h] BYREF
  float v12[4]; // [esp+30h] [ebp-58h] BYREF
  float v13[4]; // [esp+40h] [ebp-48h] BYREF
  float v14[4]; // [esp+50h] [ebp-38h] BYREF
  float v15[6]; // [esp+60h] [ebp-28h] BYREF
  float v16; // [esp+78h] [ebp-10h]
  float v17; // [esp+7Ch] [ebp-Ch]

  sub_8056016(a4, a3, v15);
  sub_8056016(a5, a3, v14);
  sub_80A1ED8(a2, v14, v12);
  v10 = sub_80560AE(v15, v12);
  if ( v10 < 0.001 )
    return 0;
  sub_8056016(a1, a3, v13);
  v17 = sub_80560AE(v13, v12);
  if ( v17 < 0.0 || v17 > (long double)v10 )
    return 0;
  sub_80A1ED8(v13, v15, v11);
  v16 = sub_80560AE(a2, v11);
  if ( v16 < 0.0 || v17 + v16 > (long double)v10 )
    return 0;
  *a6 = sub_80560AE(v14, v11) / v10;
  if ( a7 )
    *a7 = v17 / v10;
  if ( a8 )
    *a8 = v16 / v10;
  return 1;
}
// 8055E02: using guessed type float var_28[6];
// 8055E02: using guessed type float var_38[4];
// 8055E02: using guessed type float var_58[4];
// 8055E02: using guessed type float var_48[4];
// 8055E02: using guessed type float var_68[4];

//----- (08055F88) --------------------------------------------------------
long double __cdecl sub_8055F88(float a1)
{
  return (float)fabs(a1);
}

//----- (08055FA2) --------------------------------------------------------
int __cdecl sub_8055FA2(_DWORD *a1, _DWORD *a2)
{
  int result; // eax

  *a2 = *a1;
  a2[1] = a1[1];
  result = a1[2];
  a2[2] = result;
  return result;
}

//----- (08055FD2) --------------------------------------------------------
float *__cdecl sub_8055FD2(float *a1, float *a2, float *a3)
{
  float *result; // eax

  *a3 = *a1 + *a2;
  a3[1] = a1[1] + a2[1];
  result = a1 + 2;
  a3[2] = a1[2] + a2[2];
  return result;
}

//----- (08056016) --------------------------------------------------------
float *__cdecl sub_8056016(float *a1, float *a2, float *a3)
{
  float *result; // eax

  *a3 = *a1 - *a2;
  a3[1] = a1[1] - a2[1];
  result = a1 + 2;
  a3[2] = a1[2] - a2[2];
  return result;
}

//----- (0805605A) --------------------------------------------------------
float *__cdecl sub_805605A(float *a1, float a2, float *a3, float *a4)
{
  float *result; // eax

  *a4 = a2 * *a3 + *a1;
  a4[1] = a2 * a3[1] + a1[1];
  result = a3 + 2;
  a4[2] = a2 * a3[2] + a1[2];
  return result;
}

//----- (080560AE) --------------------------------------------------------
long double __cdecl sub_80560AE(float *a1, float *a2)
{
  return *a1 * *a2 + a1[1] * a2[1] + a1[2] * a2[2];
}

//----- (080560E2) --------------------------------------------------------
long double __cdecl sub_80560E2(float *a1)
{
  return *a1 * *a1 + a1[1] * a1[1] + a1[2] * a1[2];
}

//----- (08056116) --------------------------------------------------------
void __cdecl sub_8056116(float *a1, float *a2, int a3)
{
  float v3; // [esp+18h] [ebp-30h]
  float v4; // [esp+1Ch] [ebp-2Ch]
  int v5[4]; // [esp+20h] [ebp-28h] BYREF
  float v6; // [esp+30h] [ebp-18h]
  float v7; // [esp+34h] [ebp-14h]
  float v8; // [esp+38h] [ebp-10h]
  float v9; // [esp+3Ch] [ebp-Ch]

  v8 = sub_80560AE(a1 + 3, a2) - a2[3];
  if ( v8 < 0.0 )
  {
    v9 = sub_80560AE(a1, a2) - a2[3];
    if ( v9 > 0.0 )
    {
      v7 = (v9 - 0.125) / (v9 - v8);
      sub_80573BC(v7, 0.0);
      if ( v7 < (long double)*(float *)a3 )
      {
        v6 = v9 / (v9 - v8);
        sub_805605A(a1, v6, a1 + 9, (float *)v5);
        v4 = sub_80560AE((float *)v5, a2 + 4) - a2[7];
        if ( v4 >= -0.001 && v4 <= 1.001 )
        {
          v3 = sub_80560AE((float *)v5, a2 + 8) - a2[11];
          if ( v3 >= -0.001 && v4 + v3 <= 1.001 )
          {
            *(float *)a3 = v7;
            sub_8055FA2(a2, (_DWORD *)(a3 + 4));
          }
        }
      }
    }
  }
}

//----- (0805628C) --------------------------------------------------------
void __cdecl sub_805628C(int a1, float *a2, float a3, int a4)
{
  long double v4; // fst7
  long double v5; // fst7
  float v6; // [esp+0h] [ebp-E8h]
  float v7; // [esp+0h] [ebp-E8h]
  float v8; // [esp+4h] [ebp-E4h]
  int v9; // [esp+14h] [ebp-D4h]
  int v10; // [esp+18h] [ebp-D0h]
  float v11; // [esp+1Ch] [ebp-CCh]
  float v12; // [esp+20h] [ebp-C8h]
  float v13; // [esp+24h] [ebp-C4h]
  float v14; // [esp+28h] [ebp-C0h]
  float v15; // [esp+2Ch] [ebp-BCh]
  float v16[2]; // [esp+30h] [ebp-B8h] BYREF
  float v17; // [esp+38h] [ebp-B0h]
  int v18[2]; // [esp+40h] [ebp-A8h] BYREF
  float v19; // [esp+48h] [ebp-A0h]
  float *v20; // [esp+50h] [ebp-98h]
  float v21; // [esp+54h] [ebp-94h]
  float *v22; // [esp+58h] [ebp-90h]
  float v23; // [esp+5Ch] [ebp-8Ch]
  float v24; // [esp+60h] [ebp-88h]
  float v25; // [esp+64h] [ebp-84h]
  float v26; // [esp+68h] [ebp-80h]
  float v27; // [esp+6Ch] [ebp-7Ch]
  float v28; // [esp+70h] [ebp-78h] BYREF
  float v29; // [esp+74h] [ebp-74h]
  float v30; // [esp+78h] [ebp-70h]
  float v31; // [esp+80h] [ebp-68h] BYREF
  float v32; // [esp+84h] [ebp-64h]
  int v33[4]; // [esp+90h] [ebp-58h] BYREF
  float v34; // [esp+A0h] [ebp-48h]
  int v35; // [esp+A4h] [ebp-44h]
  float v36; // [esp+A8h] [ebp-40h]
  float v37; // [esp+ACh] [ebp-3Ch]
  float v38; // [esp+B0h] [ebp-38h] BYREF
  float v39; // [esp+B4h] [ebp-34h]
  float v40; // [esp+B8h] [ebp-30h]
  float v41; // [esp+C8h] [ebp-20h]
  float v42; // [esp+CCh] [ebp-1Ch]
  float v43; // [esp+D0h] [ebp-18h]
  float v44; // [esp+D4h] [ebp-14h]
  float v45; // [esp+D8h] [ebp-10h]
  int i; // [esp+DCh] [ebp-Ch]

  sub_8055FA2((_DWORD *)(a1 + 12), v16);
  v17 = v17 - a3;
  v44 = *(float *)(a1 + 140) + 0.125;
  v42 = sub_80560AE(v16, a2) - a2[3];
  if ( v42 < (long double)v44 )
  {
    sub_8055FA2((_DWORD *)a1, v18);
    v19 = v19 - a3;
    v43 = sub_80560AE((float *)v18, a2) - a2[3];
    v11 = v43 - v42;
    if ( v11 > 0.000099999997 )
    {
      LODWORD(v45) = LODWORD(v44) ^ 0x80000000;
      if ( COERCE_FLOAT(LODWORD(v44) ^ 0x80000000) < (long double)v43 )
      {
        if ( v43 - v44 > 0.0 )
        {
          v41 = (v43 - v44) / v11;
          if ( v41 > (long double)*(float *)a4 )
            return;
          sub_805605A((float *)v18, v41, (float *)(a1 + 36), &v38);
        }
        else
        {
          v41 = 0.0;
          sub_8055FA2(v18, &v38);
        }
        v37 = sub_80560AE(&v38, a2 + 4) - a2[7];
        v36 = sub_80560AE(&v38, a2 + 8) - a2[11];
        v35 = v37 + v36 > 1.0;
        v10 = v35;
        if ( v37 < 0.0 )
          v10 = v35 | 2;
        v35 = v10;
        v9 = v10;
        if ( v36 < 0.0 )
          v9 = v10 | 4;
        v35 = v9;
        if ( v9 )
        {
          for ( i = 0; i <= 2; ++i )
          {
            if ( ((v35 >> i) & 1) != 0 )
            {
              v23 = a2[i + 15];
              if ( v23 >= 0.0 && *(_DWORD *)(*(_DWORD *)(a1 + 164) + 4 * LODWORD(v23)) != *(_DWORD *)(a1 + 160) )
              {
                *(_DWORD *)(*(_DWORD *)(a1 + 164) + 4 * LODWORD(v23)) = *(_DWORD *)(a1 + 160);
                v22 = (float *)(dword_8185C30 + 48 * LODWORD(v23));
                sub_8056016((float *)v18, v22, (float *)v33);
                v28 = sub_80560AE((float *)v33, v22 + 3);
                v29 = sub_80560AE((float *)v33, v22 + 6);
                v31 = sub_80560AE((float *)(a1 + 36), v22 + 3);
                v32 = sub_80560AE((float *)(a1 + 36), v22 + 6);
                v25 = sub_805740C(&v31, &v28);
                if ( v25 < 0.0 )
                {
                  v34 = sub_805740C(&v28, &v28);
                  v24 = v34 - v44 * v44;
                  if ( v24 > 0.0 )
                  {
                    v26 = sub_805742E(&v31);
                    v27 = v25 * v25 - v26 * v24;
                    if ( v27 > 0.0 )
                    {
                      v4 = sub_805739C(v27);
                      v41 = (-v4 - v25) / v26;
                      if ( *(float *)a4 > (long double)v41 )
                      {
                        sub_805605A((float *)v33, v41, (float *)(a1 + 36), (float *)v33);
                        v40 = sub_80560AE((float *)v33, v22 + 9);
                        v7 = v40 - 0.5;
                        if ( sub_8055F88(v7) <= 0.5 )
                        {
                          v38 = (v41 * v31 + v28) / v44;
                          v39 = (v41 * v32 + v29) / v44;
                          sub_8057474(v22 + 3, v38, (float *)(a4 + 4));
                          sub_805605A((float *)(a4 + 4), v39, v22 + 6, (float *)(a4 + 4));
                          if ( a2[2] >= 0.69999999
                            && *(float *)(a4 + 12) >= 0.0
                            && *(float *)(a4 + 12) < 0.69999999
                            && v19 > (long double)v17 )
                          {
                            sub_8055FA2(a2, (_DWORD *)(a4 + 4));
                          }
                          *(float *)a4 = v41;
                        }
                      }
                    }
                  }
                  else
                  {
                    v30 = sub_80560AE((float *)v33, v22 + 9);
                    v6 = v30 - 0.5;
                    if ( sub_8055F88(v6) <= 0.5 )
                    {
                      sub_8057474(v22 + 3, v28, (float *)(a4 + 4));
                      sub_805605A((float *)(a4 + 4), v29, v22 + 6, (float *)(a4 + 4));
                      Vec3Normalize((float *)(a4 + 4));
                      if ( a2[2] >= 0.69999999
                        && *(float *)(a4 + 12) >= 0.0
                        && *(float *)(a4 + 12) < 0.69999999
                        && v19 > (long double)v17 )
                      {
                        sub_8055FA2(a2, (_DWORD *)(a4 + 4));
                      }
                      *(_DWORD *)a4 = 0;
                      if ( *(float *)(a1 + 140) * *(float *)(a1 + 140) > (long double)v34 )
                        *(_BYTE *)(a4 + 35) = 1;
                      return;
                    }
                  }
                }
              }
            }
            else
            {
              v21 = a2[i + 12];
              if ( v21 >= 0.0 && *(_DWORD *)(*(_DWORD *)(a1 + 168) + 4 * LODWORD(v21)) != *(_DWORD *)(a1 + 160) )
              {
                *(_DWORD *)(*(_DWORD *)(a1 + 168) + 4 * LODWORD(v21)) = *(_DWORD *)(a1 + 160);
                v20 = (float *)(dword_8185C28 + 12 * LODWORD(v21));
                sub_8056016((float *)v18, v20, (float *)v33);
                v25 = sub_80560AE((float *)(a1 + 36), (float *)v33);
                if ( v25 < 0.0 )
                {
                  v34 = sub_80560AE((float *)v33, (float *)v33);
                  v24 = v34 - v44 * v44;
                  if ( v24 <= 0.0 )
                  {
                    v41 = 1.0 / sub_805739C(v34);
                    sub_8057474((float *)v33, v41, (float *)(a4 + 4));
                    if ( a2[2] >= 0.69999999
                      && *(float *)(a4 + 12) >= 0.0
                      && *(float *)(a4 + 12) < 0.69999999
                      && v19 > (long double)v17 )
                    {
                      sub_8055FA2(a2, (_DWORD *)(a4 + 4));
                    }
                    *(_DWORD *)a4 = 0;
                    if ( *(float *)(a1 + 140) * *(float *)(a1 + 140) > (long double)v34 )
                      *(_BYTE *)(a4 + 35) = 1;
                    return;
                  }
                  v26 = *(float *)(a1 + 52);
                  v27 = v25 * v25 - v26 * v24;
                  if ( v27 >= 0.0 )
                  {
                    v5 = sub_805739C(v27);
                    v41 = (-v5 - v25) / v26;
                    if ( *(float *)a4 > (long double)v41 )
                    {
                      sub_805605A((float *)v33, v41, (float *)(a1 + 36), (float *)(a4 + 4));
                      v8 = 1.0 / v44;
                      sub_8057474((float *)(a4 + 4), v8, (float *)(a4 + 4));
                      if ( a2[2] >= 0.69999999
                        && *(float *)(a4 + 12) >= 0.0
                        && *(float *)(a4 + 12) < 0.69999999
                        && v19 > (long double)v17 )
                      {
                        sub_8055FA2(a2, (_DWORD *)(a4 + 4));
                      }
                      *(float *)a4 = v41;
                    }
                  }
                }
              }
            }
          }
        }
        else
        {
          sub_8055FA2(a2, (_DWORD *)(a4 + 4));
          *(float *)a4 = v41;
          if ( *(float *)(a1 + 140) > (long double)v43 )
            *(_BYTE *)(a4 + 35) = 1;
        }
      }
      else
      {
        v14 = a3 + a3;
        v15 = v14 * a2[2] + v43;
        if ( v45 < (long double)v15 )
        {
          v41 = (v45 - v43) / a2[2];
          v13 = sub_80560AE((float *)v18, a2 + 4) - a2[7];
          v12 = sub_80560AE((float *)v18, a2 + 8) - a2[11];
          v37 = v41 * a2[6] + v13;
          if ( v37 >= 0.0 )
          {
            v36 = v41 * a2[10] + v12;
            if ( v36 >= 0.0 && v37 + v36 <= 1.0 )
              goto LABEL_8;
          }
          v41 = v44 <= (long double)v15 ? (v44 - v43) / a2[2] : a3 + a3;
          v37 = v41 * a2[6] + v13;
          if ( v37 >= 0.0 )
          {
            v36 = v41 * a2[10] + v12;
            if ( v36 >= 0.0 && v37 + v36 <= 1.0 )
            {
LABEL_8:
              sub_8055FA2(a2, (_DWORD *)(a4 + 4));
              *(_DWORD *)a4 = 0;
              *(_BYTE *)(a4 + 35) = 1;
            }
          }
        }
      }
    }
  }
}
// 8185C28: using guessed type int dword_8185C28;
// 8185C30: using guessed type int dword_8185C30;
// 805628C: using guessed type float var_B8[2];

//----- (08056E42) --------------------------------------------------------
void __cdecl sub_8056E42(float *a1, int a2, int a3)
{
  float v3; // [esp+0h] [ebp-98h]
  float v4; // [esp+0h] [ebp-98h]
  float v5; // [esp+0h] [ebp-98h]
  float v6; // [esp+28h] [ebp-70h]
  float v7; // [esp+2Ch] [ebp-6Ch]
  float v8; // [esp+30h] [ebp-68h] BYREF
  float v9; // [esp+34h] [ebp-64h]
  float v10; // [esp+38h] [ebp-60h]
  float v11; // [esp+40h] [ebp-58h]
  float v12; // [esp+44h] [ebp-54h]
  float v13; // [esp+48h] [ebp-50h]
  float v14; // [esp+4Ch] [ebp-4Ch]
  float v15[3]; // [esp+50h] [ebp-48h] BYREF
  float v16; // [esp+5Ch] [ebp-3Ch]
  int v17[7]; // [esp+60h] [ebp-38h] BYREF
  float v18; // [esp+7Ch] [ebp-1Ch]
  float v19; // [esp+80h] [ebp-18h]
  float v20; // [esp+84h] [ebp-14h]
  float v21; // [esp+88h] [ebp-10h]
  float v22; // [esp+8Ch] [ebp-Ch]

  v20 = sub_805740C(a1 + 9, (float *)a2);
  if ( v20 >= 0.0 )
    return;
  v22 = a1[35] + 0.125;
  v21 = sub_805740C(a1, (float *)a2) - *(float *)(a2 + 8);
  v19 = (v22 - v21) / v20;
  if ( v19 >= (long double)*(float *)a3 || -v22 > v19 * a1[12] )
    return;
  sub_805605A(a1, v19, a1 + 9, (float *)v17);
  v18 = *(float *)(a2 + 4) * *(float *)v17 - *(float *)a2 * *(float *)&v17[1] - *(float *)(a2 + 20);
  if ( v18 < 0.0 )
  {
    v8 = *(float *)(a2 + 4) * *(float *)(a2 + 20) + *(float *)a2 * *(float *)(a2 + 8);
    v9 = *(float *)(a2 + 4) * *(float *)(a2 + 8) - *(float *)a2 * *(float *)(a2 + 20);
    sub_80573E0(a1, &v8, v15);
    v14 = sub_805740C(a1 + 9, v15);
    if ( v14 >= 0.0 )
      return;
    v13 = sub_805740C(v15, v15);
    v11 = v13 - v22 * v22;
    if ( v11 < 0.0 )
    {
      v10 = *(float *)(a2 + 12);
      v3 = v10 - a1[2];
      if ( sub_8055F88(v3) <= a1[36] )
      {
        sub_8057450((_DWORD *)(a3 + 4), *(_DWORD *)a2, *(_DWORD *)(a2 + 4), 0);
        *(_DWORD *)a3 = 0;
        if ( a1[35] * a1[35] > (long double)v13 )
          *(_BYTE *)(a3 + 35) = 1;
      }
      return;
    }
    v12 = v14 * v14 - a1[13] * v11;
    if ( v12 < 0.0 )
      return;
    LODWORD(v7) = LODWORD(v14) ^ 0x80000000;
    v19 = (v7 - sub_805739C(v12)) / a1[13];
    if ( v19 >= (long double)*(float *)a3 || v19 <= 0.0 )
      return;
    sub_805605A(a1, v19, a1 + 9, (float *)v17);
    v18 = 0.0;
    goto LABEL_26;
  }
  if ( v18 <= (long double)*(float *)(a2 + 24) )
  {
    if ( v19 < 0.0 )
      v19 = 0.0;
LABEL_26:
    v16 = v18 * *(float *)(a2 + 16) + *(float *)(a2 + 12);
    v5 = *(float *)&v17[2] - v16;
    if ( sub_8055F88(v5) <= a1[36] )
    {
      *(float *)a3 = v19;
      sub_8057450((_DWORD *)(a3 + 4), *(_DWORD *)a2, *(_DWORD *)(a2 + 4), 0);
    }
    return;
  }
  v8 = (*(float *)(a2 + 20) + *(float *)(a2 + 24)) * *(float *)(a2 + 4) + *(float *)a2 * *(float *)(a2 + 8);
  v9 = *(float *)(a2 + 4) * *(float *)(a2 + 8) - (*(float *)(a2 + 20) + *(float *)(a2 + 24)) * *(float *)a2;
  sub_80573E0(a1, &v8, v15);
  v14 = sub_805740C(a1 + 9, v15);
  if ( v14 >= 0.0 )
    return;
  v13 = sub_805740C(v15, v15);
  v11 = v13 - v22 * v22;
  if ( v11 >= 0.0 )
  {
    v12 = v14 * v14 - a1[13] * v11;
    if ( v12 < 0.0 )
      return;
    LODWORD(v6) = LODWORD(v14) ^ 0x80000000;
    v19 = (v6 - sub_805739C(v12)) / a1[13];
    if ( v19 >= (long double)*(float *)a3 || v19 <= 0.0 )
      return;
    sub_805605A(a1, v19, a1 + 9, (float *)v17);
    v18 = *(float *)(a2 + 24);
    goto LABEL_26;
  }
  v10 = *(float *)(a2 + 16) * *(float *)(a2 + 24) + *(float *)(a2 + 12);
  v4 = a1[2] - v10;
  if ( sub_8055F88(v4) <= a1[36] )
  {
    sub_8057450((_DWORD *)(a3 + 4), *(_DWORD *)a2, *(_DWORD *)(a2 + 4), 0);
    *(_DWORD *)a3 = 0;
    if ( a1[35] * a1[35] > (long double)v13 )
      *(_BYTE *)(a3 + 35) = 1;
  }
}
// 8056E42: using guessed type float var_48[3];

//----- (0805739C) --------------------------------------------------------
long double __cdecl sub_805739C(float a1)
{
  return (float)sqrt(a1);
}

//----- (080573BC) --------------------------------------------------------
void __cdecl sub_80573BC(float a1, float a2)
{
  float v2; // [esp+0h] [ebp-18h]

  v2 = a1 - a2;
  sub_80574AC(v2, a1, a2);
}

//----- (080573E0) --------------------------------------------------------
float *__cdecl sub_80573E0(float *a1, float *a2, float *a3)
{
  float *result; // eax

  *a3 = *a1 - *a2;
  result = a1 + 1;
  a3[1] = a1[1] - a2[1];
  return result;
}

//----- (0805740C) --------------------------------------------------------
long double __cdecl sub_805740C(float *a1, float *a2)
{
  return *a1 * *a2 + a1[1] * a2[1];
}

//----- (0805742E) --------------------------------------------------------
long double __cdecl sub_805742E(float *a1)
{
  return *a1 * *a1 + a1[1] * a1[1];
}

//----- (08057450) --------------------------------------------------------
int __cdecl sub_8057450(_DWORD *a1, int a2, int a3, int a4)
{
  int result; // eax

  *a1 = a2;
  a1[1] = a3;
  result = a4;
  a1[2] = a4;
  return result;
}

//----- (08057474) --------------------------------------------------------
float *__cdecl sub_8057474(float *a1, float a2, float *a3)
{
  float *result; // eax

  *a3 = a2 * *a1;
  a3[1] = a2 * a1[1];
  result = a1 + 2;
  a3[2] = a2 * a1[2];
  return result;
}

//----- (080574AC) --------------------------------------------------------
long double __cdecl sub_80574AC(float a1, float a2, float a3)
{
  if ( a1 < 0.0 )
    return a3;
  return a2;
}

//----- (080574D8) --------------------------------------------------------
void *__cdecl sub_80574D8(int a1)
{
  if ( ++dword_8185D0C > dword_8185D10 )
    dword_8185D10 = dword_8185D0C;
  return Z_MallocInternal(12 * a1 + 4);
}
// 8185D0C: using guessed type int dword_8185D0C;
// 8185D10: using guessed type int dword_8185D10;

//----- (08057520) --------------------------------------------------------
void __cdecl sub_8057520(_DWORD *ptr)
{
  if ( *ptr == -559030611 )
    Com_Error(0, (char *)&byte_813B860);
  *ptr = -559030611;
  --dword_8185D0C;
  Z_FreeInternal(ptr);
}
// 8185D0C: using guessed type int dword_8185D0C;

//----- (08057656) --------------------------------------------------------
float *__cdecl sub_8057656(float *a1, float a2)
{
  float *v3; // [esp+1Ch] [ebp-4Ch]
  int v4[4]; // [esp+20h] [ebp-48h] BYREF
  int v5[4]; // [esp+30h] [ebp-38h] BYREF
  int v6[4]; // [esp+40h] [ebp-28h] BYREF
  float v7; // [esp+50h] [ebp-18h]
  float v8; // [esp+54h] [ebp-14h]
  int v9; // [esp+58h] [ebp-10h]
  int i; // [esp+5Ch] [ebp-Ch]

  v8 = -131072.0;
  v9 = -1;
  for ( i = 0; i <= 2; ++i )
  {
    v7 = sub_8057DB2(a1[i]);
    if ( v7 > (long double)v8 )
    {
      v9 = i;
      v8 = v7;
    }
  }
  if ( v9 == -1 )
    Com_Error(1, (char *)&byte_813B8A0);
  sub_8057DCC(flt_8145E68, v4);
  if ( v9 >= 0 )
  {
    if ( v9 <= 1 )
    {
      v4[2] = 1065353216;
    }
    else if ( v9 == 2 )
    {
      v4[0] = 1065353216;
    }
  }
  v7 = sub_8057F10((float *)v4, a1);
  sub_8057EBC((float *)v4, COERCE_FLOAT(LODWORD(v7) ^ 0x80000000), a1, (float *)v4);
  sub_80A2298((float *)v4, (int)v4);
  sub_8057E84(a1, a2, (float *)v6);
  sub_80A1ED8((float *)v4, a1, (float *)v5);
  sub_8057E84((float *)v4, 131072.0, (float *)v4);
  sub_8057E84((float *)v5, 131072.0, (float *)v5);
  v3 = (float *)sub_80574D8(4);
  sub_8057E40((float *)v6, (float *)v5, v3 + 1);
  sub_8057DFC(v3 + 1, (float *)v4, v3 + 1);
  sub_8057DFC((float *)v6, (float *)v5, v3 + 4);
  sub_8057DFC(v3 + 4, (float *)v4, v3 + 4);
  sub_8057DFC((float *)v6, (float *)v5, v3 + 7);
  sub_8057E40(v3 + 7, (float *)v4, v3 + 7);
  sub_8057E40((float *)v6, (float *)v5, v3 + 10);
  sub_8057E40(v3 + 10, (float *)v4, v3 + 10);
  *(_DWORD *)v3 = 4;
  return v3;
}
// 8145E68: using guessed type float flt_8145E68[3];

//----- (080578D2) --------------------------------------------------------
void *__cdecl sub_80578D2(int *src)
{
  void *dest; // [esp+10h] [ebp-8h]

  dest = sub_80574D8(*src);
  Com_Memcpy(dest, src, 12 * *src + 4);
  return dest;
}

//----- (0805791A) --------------------------------------------------------
void **__cdecl sub_805791A(void **a1, float *a2, float a3, float a4)
{
  void **result; // eax
  int v5; // [esp+28h] [ebp-280h]
  int *v6; // [esp+2Ch] [ebp-27Ch]
  float v7[4]; // [esp+30h] [ebp-278h] BYREF
  int v8; // [esp+40h] [ebp-268h]
  _DWORD *v9; // [esp+44h] [ebp-264h]
  int j; // [esp+48h] [ebp-260h]
  int i; // [esp+4Ch] [ebp-25Ch]
  int v12; // [esp+50h] [ebp-258h]
  int v13; // [esp+54h] [ebp-254h]
  int v14; // [esp+58h] [ebp-250h]
  int v15[68]; // [esp+60h] [ebp-248h]
  int v16[71]; // [esp+170h] [ebp-138h]
  void *ptr; // [esp+28Ch] [ebp-1Ch]

  ptr = *a1;
  v14 = 0;
  v13 = 0;
  v12 = 0;
  for ( i = 0; i < *(_DWORD *)ptr; ++i )
  {
    flt_8185D14 = sub_8057F10((float *)ptr + 3 * i + 1, a2);
    flt_8185D14 = flt_8185D14 - a3;
    v16[i] = LODWORD(flt_8185D14);
    if ( flt_8185D14 <= (long double)a4 )
    {
      if ( -a4 <= (long double)flt_8185D14 )
        v15[i] = 2;
      else
        v15[i] = 1;
    }
    else
    {
      v15[i] = 0;
    }
    ++*(&v12 + v15[i]);
  }
  v15[i] = v15[0];
  result = (void **)v16[0];
  v16[i] = v16[0];
  if ( v12 )
  {
    if ( v13 )
    {
      v5 = *(_DWORD *)ptr + 4;
      v6 = (int *)sub_80574D8(v5);
      for ( i = 0; i < *(_DWORD *)ptr; ++i )
      {
        v9 = (char *)ptr + 12 * i + 4;
        if ( v15[i] == 2 )
        {
          sub_8057DCC(v9, &v6[3 * *v6 + 1]);
          ++*v6;
        }
        else
        {
          if ( !v15[i] )
          {
            sub_8057DCC(v9, &v6[3 * *v6 + 1]);
            ++*v6;
          }
          if ( v15[i + 1] != 2 && v15[i + 1] != v15[i] )
          {
            v8 = (int)ptr + 12 * ((i + 1) % *(_DWORD *)ptr) + 4;
            flt_8185D14 = *(float *)&v16[i] / (*(float *)&v16[i] - *(float *)&v16[i + 1]);
            for ( j = 0; j <= 2; ++j )
            {
              if ( a2[j] == 1.0 )
              {
                v7[j] = a3;
              }
              else if ( a2[j] == -1.0 )
              {
                LODWORD(v7[j]) = LODWORD(a3) ^ 0x80000000;
              }
              else
              {
                v7[j] = (*(float *)(v8 + 4 * j) - *(float *)&v9[j]) * flt_8185D14 + *(float *)&v9[j];
              }
            }
            sub_8057DCC(v7, &v6[3 * *v6 + 1]);
            ++*v6;
          }
        }
      }
      if ( *v6 > v5 )
        Com_Error(1, (char *)&byte_813B8E0);
      if ( *v6 > 64 )
        Com_Error(1, (char *)&byte_813B920);
      sub_8057520(ptr);
      result = (void **)v6;
      *a1 = v6;
    }
  }
  else
  {
    sub_8057520(ptr);
    result = a1;
    *a1 = 0;
  }
  return result;
}
// 8185D14: using guessed type float flt_8185D14;
// 805791A: using guessed type float var_278[4];

//----- (08057DB2) --------------------------------------------------------
long double __cdecl sub_8057DB2(float a1)
{
  return (float)fabs(a1);
}

//----- (08057DCC) --------------------------------------------------------
int __cdecl sub_8057DCC(_DWORD *a1, _DWORD *a2)
{
  int result; // eax

  *a2 = *a1;
  a2[1] = a1[1];
  result = a1[2];
  a2[2] = result;
  return result;
}

//----- (08057DFC) --------------------------------------------------------
float *__cdecl sub_8057DFC(float *a1, float *a2, float *a3)
{
  float *result; // eax

  *a3 = *a1 + *a2;
  a3[1] = a1[1] + a2[1];
  result = a1 + 2;
  a3[2] = a1[2] + a2[2];
  return result;
}

//----- (08057E40) --------------------------------------------------------
float *__cdecl sub_8057E40(float *a1, float *a2, float *a3)
{
  float *result; // eax

  *a3 = *a1 - *a2;
  a3[1] = a1[1] - a2[1];
  result = a1 + 2;
  a3[2] = a1[2] - a2[2];
  return result;
}

//----- (08057E84) --------------------------------------------------------
float *__cdecl sub_8057E84(float *a1, float a2, float *a3)
{
  float *result; // eax

  *a3 = a2 * *a1;
  a3[1] = a2 * a1[1];
  result = a1 + 2;
  a3[2] = a2 * a1[2];
  return result;
}

//----- (08057EBC) --------------------------------------------------------
float *__cdecl sub_8057EBC(float *a1, float a2, float *a3, float *a4)
{
  float *result; // eax

  *a4 = a2 * *a3 + *a1;
  a4[1] = a2 * a3[1] + a1[1];
  result = a3 + 2;
  a4[2] = a2 * a3[2] + a1[2];
  return result;
}

//----- (08057F10) --------------------------------------------------------
long double __cdecl sub_8057F10(float *a1, float *a2)
{
  return *a1 * *a2 + a1[1] * a2[1] + a1[2] * a2[2];
}

//----- (08057F44) --------------------------------------------------------
void *__cdecl sub_8057F44(size_t a1)
{
  return Hunk_AllocInternal(a1);
}

//----- (08057F58) --------------------------------------------------------
void *__cdecl sub_8057F58(size_t a1)
{
  return Hunk_AllocInternal(a1);
}

//----- (08057F6C) --------------------------------------------------------
int __cdecl sub_8057F6C(char *s2)
{
  return XModelPrecache(s2, (int (__cdecl *)(int))sub_8057F44, (int (__cdecl *)(int))sub_8057F58);
}

//----- (08057F90) --------------------------------------------------------
int __cdecl sub_8057F90(int a1, int a2, float *a3, float *a4, int a5)
{
  int result; // eax
  float v6[4]; // [esp+20h] [ebp-58h] BYREF
  float v7[4]; // [esp+30h] [ebp-48h] BYREF
  float v8[4]; // [esp+40h] [ebp-38h] BYREF
  float v9[7]; // [esp+50h] [ebp-28h] BYREF
  int v10; // [esp+6Ch] [ebp-Ch]

  sub_8058192(a3, (float *)(a1 + 8), v7);
  sub_80A4E52(v7, (float *)(a1 + 20), v8);
  sub_8058192(a4, (float *)(a1 + 8), v7);
  sub_80A4E52(v7, (float *)(a1 + 20), v9);
  v10 = sub_80C54DC(*(_DWORD **)(a1 + 4));
  result = sub_80C33FE(*(_DWORD *)(a1 + 4), a2, v10, v8, v9, a5);
  if ( result >= 0 )
  {
    *(_WORD *)(a2 + 28) = 1022;
    sub_80A5028((float *)(a2 + 4), (float *)(a1 + 20), v6);
    Vec3Normalize(v6);
    return sub_8058162(v6, (_DWORD *)(a2 + 4));
  }
  return result;
}
// 8057F90: using guessed type float var_48[4];
// 8057F90: using guessed type float var_38[4];
// 8057F90: using guessed type float var_28[7];
// 8057F90: using guessed type float var_58[4];

//----- (0805809A) --------------------------------------------------------
unsigned int __cdecl sub_805809A(int a1, float *a2, float *a3, int a4)
{
  int v5[12]; // [esp+20h] [ebp-78h] BYREF
  float v6[4]; // [esp+50h] [ebp-48h] BYREF
  float v7[4]; // [esp+60h] [ebp-38h] BYREF
  float v8[7]; // [esp+70h] [ebp-28h] BYREF
  int v9; // [esp+8Ch] [ebp-Ch]

  sub_8058192(a2, (float *)(a1 + 8), v6);
  sub_80A4E52(v6, (float *)(a1 + 20), v7);
  sub_8058192(a3, (float *)(a1 + 8), v6);
  sub_80A4E52(v6, (float *)(a1 + 20), v8);
  v5[0] = 1065353216;
  v9 = sub_80C54DC(*(_DWORD **)(a1 + 4));
  return (unsigned int)sub_80C33FE(*(_DWORD *)(a1 + 4), (int)v5, v9, v7, v8, a4) >> 31;
}
// 805809A: using guessed type float var_48[4];
// 805809A: using guessed type float var_38[4];
// 805809A: using guessed type float var_28[7];
// 805809A: using guessed type int var_78[12];

//----- (08058162) --------------------------------------------------------
int __cdecl sub_8058162(_DWORD *a1, _DWORD *a2)
{
  int result; // eax

  *a2 = *a1;
  a2[1] = a1[1];
  result = a1[2];
  a2[2] = result;
  return result;
}

//----- (08058192) --------------------------------------------------------
float *__cdecl sub_8058192(float *a1, float *a2, float *a3)
{
  float *result; // eax

  *a3 = *a1 - *a2;
  a3[1] = a1[1] - a2[1];
  result = a1 + 2;
  a3[2] = a1[2] - a2[2];
  return result;
}

//----- (080581D8) --------------------------------------------------------
float *__cdecl sub_80581D8(int a1, float *a2, float *a3, float *a4)
{
  float *result; // eax
  int v5[3]; // [esp+10h] [ebp-38h] BYREF
  float v6[3]; // [esp+1Ch] [ebp-2Ch] BYREF
  float v7[8]; // [esp+28h] [ebp-20h] BYREF

  sub_80588E0(a2, (_DWORD *)(a1 + 8));
  sub_80A7146(a3, (int)v5);
  sub_8058954((float *)v5, *a4, (float *)v5);
  sub_8058954(v6, a4[1], v6);
  sub_8058954(v7, a4[2], v7);
  sub_80A45BE((float *)v5, (float *)(a1 + 20));
  result = (float *)sub_80C501A(*(_DWORD *)(a1 + 4), (float *)v5, (_DWORD *)(a1 + 56), (_DWORD *)(a1 + 68));
  if ( result )
  {
    sub_8058910((float *)(a1 + 56), a2, (float *)(a1 + 56));
    return sub_8058910((float *)(a1 + 68), a2, (float *)(a1 + 68));
  }
  return result;
}

//----- (080582EC) --------------------------------------------------------
int __cdecl sub_80582EC(int a1, char *a2, float *a3, float *a4, float *a5)
{
  int v5; // eax

  if ( !a2 || !*a2 )
    Com_Error(1, (char *)&byte_813B960);
  if ( *a5 == 0.0 )
    Com_Error(1, (char *)&byte_813B980, a2);
  if ( a5[1] == 0.0 )
    Com_Error(1, (char *)&byte_813B9C0, a2);
  if ( a5[2] == 0.0 )
    Com_Error(1, (char *)&byte_813BA00, a2);
  v5 = sub_8057F6C(a2);
  if ( !v5 )
    return 0;
  *(_DWORD *)(a1 + 4) = v5;
  sub_80581D8(a1, a3, a4, a5);
  return 1;
}
// 80582EC: using guessed type char *arg_4;

//----- (080583FA) --------------------------------------------------------
char *CM_LoadStaticModels()
{
  char *result; // eax
  int v1; // [esp+28h] [ebp-110h]
  int v2; // [esp+2Ch] [ebp-10Ch]
  int v3; // [esp+2Ch] [ebp-10Ch]
  int v4; // [esp+30h] [ebp-108h] BYREF
  int v5; // [esp+34h] [ebp-104h] BYREF
  float v6; // [esp+38h] [ebp-100h] BYREF
  int v7; // [esp+40h] [ebp-F8h] BYREF
  int v8; // [esp+44h] [ebp-F4h] BYREF
  int v9; // [esp+48h] [ebp-F0h] BYREF
  int v10; // [esp+50h] [ebp-E8h] BYREF
  int v11; // [esp+54h] [ebp-E4h] BYREF
  int v12; // [esp+58h] [ebp-E0h] BYREF
  char s1[64]; // [esp+60h] [ebp-D8h] BYREF
  char dest[64]; // [esp+A0h] [ebp-98h] BYREF
  char v15[7]; // [esp+E0h] [ebp-58h] BYREF
  char v16[65]; // [esp+E7h] [ebp-51h] BYREF
  char *v17; // [esp+128h] [ebp-10h] BYREF
  char *src; // [esp+12Ch] [ebp-Ch]

  v17 = (char *)dword_8185C78;
  dword_8185BE4 = 0;
  dword_8185BE8 = 0;
  while ( 1 )
  {
    result = Com_Parse(&v17);
    src = result;
    if ( !v17 )
      break;
    result = src;
    if ( *src != 123 )
      break;
    v15[0] = 0;
    v2 = 0;
    while ( 1 )
    {
      src = Com_Parse(&v17);
      if ( !v17 )
        break;
      if ( *src == 125 )
        break;
      strcpy(dest, src);
      src = Com_Parse(&v17);
      if ( !v17 )
        break;
      strcpy(s1, src);
      if ( !strcasecmp(dest, "classname") )
      {
        if ( !strcasecmp(s1, "misc_model") )
          v2 = 1;
      }
      else if ( !strcasecmp(dest, "model") )
      {
        strcpy(v15, s1);
      }
    }
    if ( v2 && (unsigned __int8)Com_ValidXModelName(v15) )
      ++dword_8185BE4;
  }
  if ( dword_8185BE4 )
  {
    dword_8185BE8 = (int)CM_Hunk_Alloc(80 * dword_8185BE4);
    v17 = (char *)dword_8185C78;
    v1 = 0;
    while ( 1 )
    {
      result = Com_Parse(&v17);
      src = result;
      if ( !v17 )
        break;
      result = src;
      if ( *src != 123 )
        break;
      v15[0] = 0;
      v12 = 0;
      v11 = 0;
      v10 = 0;
      v9 = 0;
      v8 = 0;
      v7 = 0;
      v6 = 1.0;
      v5 = 1065353216;
      v4 = 1065353216;
      v3 = 0;
      while ( 1 )
      {
        src = Com_Parse(&v17);
        if ( !v17 )
          break;
        if ( *src == 125 )
          break;
        strcpy(dest, src);
        src = Com_Parse(&v17);
        if ( !v17 )
          break;
        strcpy(s1, src);
        if ( !strcasecmp(dest, "classname") )
        {
          if ( !strcasecmp(s1, "misc_model") )
            v3 = 1;
        }
        else if ( !strcasecmp(dest, "model") )
        {
          strcpy(v15, s1);
        }
        else if ( !strcasecmp(dest, "origin") )
        {
          sscanf(s1, "%f %f %f", &v10, &v11, &v12);
        }
        else if ( !strcasecmp(dest, "angles") )
        {
          sscanf(s1, "%f %f %f", &v7, &v8, &v9);
        }
        else if ( !strcasecmp(dest, "modelscale_vec") )
        {
          sscanf(s1, "%f %f %f", &v4, &v5, &v6);
        }
        else if ( !strcasecmp(dest, "modelscale") )
        {
          v6 = atof(s1);
          v5 = LODWORD(v6);
          v4 = LODWORD(v6);
        }
      }
      if ( v3 && (unsigned __int8)Com_ValidXModelName(v15) )
      {
        if ( (unsigned __int8)sub_80582EC(dword_8185BE8 + 80 * v1, v16, (float *)&v10, (float *)&v7, (float *)&v4) )
          ++v1;
        else
          --dword_8185BE4;
      }
    }
  }
  return result;
}
// 8185BE4: using guessed type int dword_8185BE4;
// 8185BE8: using guessed type int dword_8185BE8;
// 80583FA: using guessed type char anonymous_0[65];

//----- (080588E0) --------------------------------------------------------
int __cdecl sub_80588E0(_DWORD *a1, _DWORD *a2)
{
  int result; // eax

  *a2 = *a1;
  a2[1] = a1[1];
  result = a1[2];
  a2[2] = result;
  return result;
}

//----- (08058910) --------------------------------------------------------
float *__cdecl sub_8058910(float *a1, float *a2, float *a3)
{
  float *result; // eax

  *a3 = *a1 + *a2;
  a3[1] = a1[1] + a2[1];
  result = a1 + 2;
  a3[2] = a1[2] + a2[2];
  return result;
}

//----- (08058954) --------------------------------------------------------
float *__cdecl sub_8058954(float *a1, float a2, float *a3)
{
  float *result; // eax

  *a3 = a2 * *a1;
  a3[1] = a2 * a1[1];
  result = a1 + 2;
  a3[2] = a2 * a1[2];
  return result;
}

//----- (0805898C) --------------------------------------------------------
int __cdecl sub_805898C(float *a1, int a2)
{
  int v3; // [esp+Ch] [ebp-Ch]
  __int16 *v4; // [esp+10h] [ebp-8h]
  float v5; // [esp+14h] [ebp-4h]

  while ( a2 >= 0 )
  {
    v4 = (__int16 *)(dword_8185C00 + 8 * a2);
    v3 = *(_DWORD *)v4;
    if ( *(_BYTE *)(*(_DWORD *)v4 + 16) > 2u )
      v5 = sub_8059038((float *)v3, a1) - *(float *)(v3 + 12);
    else
      v5 = a1[*(unsigned __int8 *)(v3 + 16)] - *(float *)(v3 + 12);
    if ( v5 >= 0.0 )
      a2 = v4[2];
    else
      a2 = v4[3];
  }
  return -1 - a2;
}
// 8185C00: using guessed type int dword_8185C00;

//----- (08058A2C) --------------------------------------------------------
int __cdecl sub_8058A2C(float *a1)
{
  return sub_805898C(a1, 0);
}

//----- (08058A48) --------------------------------------------------------
_DWORD *__cdecl sub_8058A48(_DWORD *a1, int a2)
{
  _DWORD *result; // eax
  int v3; // [esp+0h] [ebp-8h]

  v3 = -1 - a2;
  if ( *(_WORD *)(dword_8185C08 + 44 * (-1 - a2) + 40) != 0xFFFF )
    a1[10] = v3;
  if ( *a1 < a1[1] )
  {
    result = (_DWORD *)(-1 - a2);
    *(_DWORD *)(a1[3] + 4 * (*a1)++) = v3;
  }
  else
  {
    result = a1;
    a1[2] = 1;
  }
  return result;
}
// 8185C08: using guessed type int dword_8185C08;

//----- (08058ABE) --------------------------------------------------------
_DWORD *__cdecl sub_8058ABE(int a1, int a2)
{
  int v3; // [esp+Ch] [ebp-Ch]
  int v4; // [esp+10h] [ebp-8h]

  while ( a2 >= 0 )
  {
    v4 = dword_8185C00 + 8 * a2;
    v3 = sub_80A7E1A((float *)(a1 + 16), (float *)(a1 + 28), *(_DWORD *)v4);
    if ( v3 == 1 )
    {
      a2 = *(__int16 *)(v4 + 4);
    }
    else
    {
      if ( v3 != 2 )
        sub_8058ABE(a1, *(__int16 *)(v4 + 4));
      a2 = *(__int16 *)(v4 + 6);
    }
  }
  return sub_8058A48((_DWORD *)a1, a2);
}
// 8185C00: using guessed type int dword_8185C00;

//----- (08058B66) --------------------------------------------------------
int __cdecl sub_8058B66(_DWORD *a1, _DWORD *a2, int a3, int a4, _DWORD *a5)
{
  int v6[4]; // [esp+10h] [ebp-38h] BYREF
  int v7[3]; // [esp+20h] [ebp-28h] BYREF
  int v8[3]; // [esp+2Ch] [ebp-1Ch] BYREF
  int v9; // [esp+38h] [ebp-10h]

  sub_8058FC4(a1, v7);
  sub_8058FC4(a2, v8);
  v6[0] = 0;
  v6[1] = a4;
  v6[3] = a3;
  v9 = 0;
  v6[2] = 0;
  sub_8058ABE((int)v6, 0);
  *a5 = v9;
  return v6[0];
}
// 8058B66: using guessed type int anonymous_0[3];
// 8058B66: using guessed type int anonymous_1[3];

//----- (08058BD8) --------------------------------------------------------
int __cdecl sub_8058BD8(float *a1, unsigned __int8 *a2)
{
  int v3; // [esp+10h] [ebp-28h]
  int v4; // [esp+1Ch] [ebp-1Ch]
  int v5; // [esp+20h] [ebp-18h]
  int j; // [esp+24h] [ebp-14h]
  int k; // [esp+24h] [ebp-14h]
  _DWORD *v8; // [esp+28h] [ebp-10h]
  int i; // [esp+30h] [ebp-8h]

  v4 = 0;
  while ( 1 )
  {
    if ( !*((_WORD *)a2 + 1) )
      goto LABEL_19;
    if ( *((__int16 *)a2 + 1) > 0 )
      break;
    v4 |= sub_8058BD8(a1, a2 + 20);
LABEL_19:
    if ( *((float *)a2 + 2) < (long double)a1[*a2] )
      v3 = 0;
    else
      v3 = 2;
    a2 += 20 * *(unsigned __int16 *)&a2[v3 + 16];
  }
  for ( i = 0; i < *((__int16 *)a2 + 1); ++i )
  {
    v8 = (_DWORD *)(dword_8185C60 + 48 * *(unsigned __int16 *)(*((_DWORD *)a2 + 2) + 2 * i));
    for ( j = 0; j <= 2; ++j )
    {
      if ( *(float *)&v8[j] > (long double)a1[j] || a1[j] > (long double)*(float *)&v8[j + 4] )
        goto LABEL_16;
    }
    v5 = v8[8];
    for ( k = v8[7]; k; --k )
    {
      if ( sub_8059038(a1, (float *)*(_DWORD *)v5) > *(float *)(*(_DWORD *)v5 + 12) )
        goto LABEL_16;
      v5 += 8;
    }
    v4 |= v8[3];
LABEL_16:
    ;
  }
  return v4;
}
// 8185C60: using guessed type int dword_8185C60;

//----- (08058D88) --------------------------------------------------------
int __cdecl sub_8058D88(float *a1, int a2)
{
  int i; // [esp+14h] [ebp-14h]
  int v5; // [esp+1Ch] [ebp-Ch]

  if ( a2 )
    v5 = CM_ClipHandleToModel(a2) + 28;
  else
    v5 = dword_8185C08 + 44 * sub_805898C(a1, 0);
  if ( !*(_DWORD *)(v5 + 36) )
    return 0;
  for ( i = 0; i <= 2; ++i )
  {
    if ( *(float *)(v5 + 4 * i + 12) >= (long double)a1[i] )
      return 0;
    if ( a1[i] >= (long double)*(float *)(v5 + 4 * i + 24) )
      return 0;
  }
  return sub_8058BD8(a1, (unsigned __int8 *)dword_8185C10 + 20 * *(_DWORD *)(v5 + 36));
}
// 8185C08: using guessed type int dword_8185C08;

//----- (08058E94) --------------------------------------------------------
int __cdecl sub_8058E94(float *a1, int a2, float *a3, float *a4)
{
  float v5; // [esp+1Ch] [ebp-5Ch]
  float v6[4]; // [esp+20h] [ebp-58h] BYREF
  float v7[4]; // [esp+30h] [ebp-48h] BYREF
  float v8[4]; // [esp+40h] [ebp-38h] BYREF
  float v9[4]; // [esp+50h] [ebp-28h] BYREF
  float v10[6]; // [esp+60h] [ebp-18h] BYREF

  sub_8058FF4(a1, a3, v10);
  if ( *a4 != 0.0 || a4[1] != 0.0 || a4[2] != 0.0 )
  {
    AngleVectors(a4, (int)v8, v7, v6);
    sub_8058FC4(v10, v9);
    v10[0] = sub_8059038(v9, v8);
    v5 = sub_8059038(v9, v7);
    LODWORD(v10[1]) = LODWORD(v5) ^ 0x80000000;
    v10[2] = sub_8059038(v9, v6);
  }
  return sub_8058D88(v10, a2);
}
// 8058E94: using guessed type float var_58[4];
// 8058E94: using guessed type float var_48[4];
// 8058E94: using guessed type float var_38[4];
// 8058E94: using guessed type float var_28[4];

//----- (08058F82) --------------------------------------------------------
char *__cdecl sub_8058F82(int a1)
{
  if ( a1 >= 0 && a1 < dword_8185C64 && dword_8185C70 )
    return (char *)dword_8185C6C + n * a1;
  else
    return (char *)dword_8185C6C;
}
// 8185C64: using guessed type int dword_8185C64;
// 8185C70: using guessed type int dword_8185C70;

//----- (08058FC4) --------------------------------------------------------
int __cdecl sub_8058FC4(_DWORD *a1, _DWORD *a2)
{
  int result; // eax

  *a2 = *a1;
  a2[1] = a1[1];
  result = a1[2];
  a2[2] = result;
  return result;
}

//----- (08058FF4) --------------------------------------------------------
float *__cdecl sub_8058FF4(float *a1, float *a2, float *a3)
{
  float *result; // eax

  *a3 = *a1 - *a2;
  a3[1] = a1[1] - a2[1];
  result = a1 + 2;
  a3[2] = a1[2] - a2[2];
  return result;
}

//----- (08059038) --------------------------------------------------------
long double __cdecl sub_8059038(float *a1, float *a2)
{
  return *a1 * *a2 + a1[1] * a2[1] + a1[2] * a2[2];
}

//----- (0805906C) --------------------------------------------------------
int __cdecl CM_GetTraceThreadInfo(_DWORD *a1)
{
  _DWORD *v1; // eax
  int result; // eax

  v1 = (_DWORD *)Sys_GetValue(3);
  *a1 = ++*v1;
  a1[1] = v1[1];
  a1[2] = v1[2];
  a1[3] = v1[3];
  a1[4] = v1[4];
  result = v1[5];
  a1[5] = result;
  return result;
}

//----- (080590B0) --------------------------------------------------------
int __cdecl sub_80590B0(_DWORD *a1, _DWORD *a2)
{
  int v2; // eax
  int result; // eax

  v2 = Sys_GetValue(3);
  *a1 = *(_DWORD *)(v2 + 16);
  result = *(_DWORD *)(v2 + 20);
  *a2 = result;
  return result;
}

//----- (080590DE) --------------------------------------------------------
int __cdecl sub_80590DE(_DWORD *a1, _DWORD *a2, int a3)
{
  _DWORD *v4; // [esp+10h] [ebp-8h] BYREF
  _DWORD *v5; // [esp+14h] [ebp-4h] BYREF

  sub_80590B0(&v5, &v4);
  CM_VectorCopy2(a1, v4);
  CM_VectorCopy2(a2, v4 + 3);
  CM_VectorCopy2(a1, v5);
  CM_VectorCopy2(a2, v5 + 4);
  v5[3] = a3;
  return 1023;
}

//----- (08059154) --------------------------------------------------------
int __cdecl CM_ClipHandleToModel(int a1)
{
  int v3; // [esp+10h] [ebp-8h] BYREF
  int v4; // [esp+14h] [ebp-4h] BYREF

  if ( a1 < dword_8185C54 )
    return dword_8185C58 + 72 * a1;
  sub_80590B0(&v4, &v3);
  return v3;
}
// 8185C54: using guessed type int dword_8185C54;
// 8185C58: using guessed type int dword_8185C58;

//----- (0805919A) --------------------------------------------------------
int __cdecl sub_805919A(int a1)
{
  int v1; // edx

  v1 = CM_ClipHandleToModel(a1);
  return *(_DWORD *)(v1 + 32) | *(_DWORD *)(v1 + 36);
}

//----- (080591BC) --------------------------------------------------------
long double __cdecl sub_80591BC(int a1)
{
  return *(float *)(CM_ClipHandleToModel(a1) + 24);
}

//----- (080591DE) --------------------------------------------------------
int __cdecl sub_80591DE(int a1, float *a2)
{
  long double v2; // fst7
  int result; // eax
  float v4[6]; // [esp+10h] [ebp-18h] BYREF

  CM_VectorCopy2((_DWORD *)a1, v4);
  *(float *)a1 = sub_805D554(a2, v4);
  *(float *)(a1 + 4) = sub_805D554(a2 + 3, v4);
  v2 = sub_805D554(a2 + 6, v4);
  result = a1 + 8;
  *(float *)(a1 + 8) = v2;
  return result;
}
// 80591DE: using guessed type float var_18[6];

//----- (0805924A) --------------------------------------------------------
int *__cdecl sub_805924A(int a1, int a2)
{
  int *result; // eax
  int j; // [esp+0h] [ebp-Ch]
  int i; // [esp+4h] [ebp-8h] BYREF

  for ( i = 0; i <= 2; ++i )
  {
    for ( j = 0; j <= 2; ++j )
      *(_DWORD *)(a2 + 4 * (j + 3 * i)) = *(_DWORD *)(a1 + 4 * (i + 3 * j));
    result = &i;
  }
  return result;
}

//----- (080592B6) --------------------------------------------------------
unsigned int __cdecl sub_80592B6(float *a1, int a2)
{
  AngleVectors(a1, a2, (float *)(a2 + 12), (float *)(a2 + 24));
  return sub_805D48E((_DWORD *)(a2 + 12));
}

//----- (080592F2) --------------------------------------------------------
void __cdecl sub_80592F2(float *a1, int a2, int a3)
{
  float v3; // [esp+0h] [ebp-28h]
  float v4; // [esp+10h] [ebp-18h]
  float **v5; // [esp+14h] [ebp-14h]
  float v6; // [esp+18h] [ebp-10h]
  float v7; // [esp+1Ch] [ebp-Ch]
  float *v8; // [esp+20h] [ebp-8h]
  int i; // [esp+24h] [ebp-4h]

  if ( a1[26] <= (long double)*(float *)(a2 + 16)
    && a1[27] <= (long double)*(float *)(a2 + 20)
    && a1[28] <= (long double)*(float *)(a2 + 24)
    && *(float *)a2 <= (long double)a1[29]
    && *(float *)(a2 + 4) <= (long double)a1[30]
    && *(float *)(a2 + 8) <= (long double)a1[31] )
  {
    v5 = *(float ***)(a2 + 32);
    for ( i = *(_DWORD *)(a2 + 28); i; --i )
    {
      v8 = *v5;
      v3 = (*v5)[2] * a1[36];
      v4 = CM_Fabs(v3);
      v7 = v8[3] + a1[35] + v4;
      v6 = sub_805D554(a1, v8) - v7;
      if ( v6 > 0.0 )
        return;
      v5 += 2;
    }
    *(_BYTE *)(a3 + 34) = 1;
    *(_BYTE *)(a3 + 35) = 1;
    *(_DWORD *)a3 = 0;
    *(_DWORD *)(a3 + 20) = *(_DWORD *)(a2 + 12);
  }
}

//----- (08059432) --------------------------------------------------------
int __cdecl sub_8059432(int a1, unsigned __int8 *a2, int a3)
{
  int result; // eax
  int i; // [esp+14h] [ebp-4h]

  while ( 1 )
  {
    result = *((_DWORD *)a2 + 1) & *(_DWORD *)(a1 + 128);
    if ( !result )
      break;
    if ( *((_WORD *)a2 + 1) )
    {
      if ( *((__int16 *)a2 + 1) > 0 )
      {
        for ( i = 0; ; ++i )
        {
          result = *((__int16 *)a2 + 1);
          if ( i >= result )
            break;
          if ( (*(_DWORD *)(dword_8185C60 + 48 * *(unsigned __int16 *)(*((_DWORD *)a2 + 2) + 2 * i) + 12) & *(_DWORD *)(a1 + 128)) != 0 )
          {
            sub_80592F2((float *)a1, dword_8185C60 + 48 * *(unsigned __int16 *)(*((_DWORD *)a2 + 2) + 2 * i), a3);
            result = a3;
            if ( *(_BYTE *)(a3 + 34) )
              break;
          }
        }
        return result;
      }
      sub_8059432(a1, a2 + 20, a3);
      result = a3;
      if ( *(_BYTE *)(a3 + 34) )
        return result;
    }
    if ( *(float *)(a1 + 4 * *a2 + 104) <= (long double)*((float *)a2 + 2) )
    {
      if ( *(float *)(a1 + 4 * *a2 + 116) >= (long double)*((float *)a2 + 2) )
      {
        sub_8059432(a1, &a2[20 * *((unsigned __int16 *)a2 + 8)], a3);
        result = a3;
        if ( *(_BYTE *)(a3 + 34) )
          return result;
      }
      a2 += 20 * *((unsigned __int16 *)a2 + 9);
    }
    else
    {
      a2 += 20 * *((unsigned __int16 *)a2 + 8);
    }
  }
  return result;
}
// 8185C60: using guessed type int dword_8185C60;

//----- (080595CA) --------------------------------------------------------
int __cdecl sub_80595CA(int a1, int a2, int a3)
{
  int i; // [esp+10h] [ebp-8h]

  for ( i = 0; i <= 2; ++i )
  {
    if ( *(float *)(a2 + 4 * i + 12) >= (long double)*(float *)(a1 + 4 * i + 116) )
      return 0;
    if ( *(float *)(a1 + 4 * i + 104) >= (long double)*(float *)(a2 + 4 * i + 24) )
      return 0;
  }
  sub_8059432(a1, (unsigned __int8 *)dword_8185C10 + 20 * *(_DWORD *)(a2 + 36), a3);
  return *(unsigned __int8 *)(a3 + 34);
}

//----- (08059674) --------------------------------------------------------
int __cdecl sub_8059674(int a1, int a2, int a3)
{
  int result; // eax

  if ( (*(_DWORD *)(a2 + 4) & *(_DWORD *)(a1 + 128)) == 0 || (result = sub_80595CA(a1, a2, a3)) == 0 )
  {
    result = *(_DWORD *)(a2 + 8) & *(_DWORD *)(a1 + 128);
    if ( result )
      return sub_8055D4C(a1, (unsigned __int16 *)a2, a3);
  }
  return result;
}

//----- (080596DA) --------------------------------------------------------
void __cdecl CM_TraceCapsuleThroughCapsule(int a1, int a2)
{
  float v2; // [esp+10h] [ebp-B8h]
  float v3; // [esp+14h] [ebp-B4h]
  float v4; // [esp+18h] [ebp-B0h]
  float v5; // [esp+1Ch] [ebp-ACh]
  float v6; // [esp+20h] [ebp-A8h]
  float v7[3]; // [esp+30h] [ebp-98h]
  float v8[2]; // [esp+3Ch] [ebp-8Ch]
  float v9; // [esp+44h] [ebp-84h]
  _DWORD v10[4]; // [esp+50h] [ebp-78h] BYREF
  float v11[4]; // [esp+60h] [ebp-68h] BYREF
  float v12[2]; // [esp+70h] [ebp-58h] BYREF
  float v13; // [esp+78h] [ebp-50h]
  float v14[2]; // [esp+80h] [ebp-48h] BYREF
  float v15; // [esp+88h] [ebp-40h]
  float v16[2]; // [esp+90h] [ebp-38h] BYREF
  float v17; // [esp+98h] [ebp-30h]
  float v18[2]; // [esp+A0h] [ebp-28h] BYREF
  float v19; // [esp+A8h] [ebp-20h]
  int i; // [esp+BCh] [ebp-Ch]

  CM_VectorCopy2((_DWORD *)a1, v18);
  v19 = v19 + *(float *)(a1 + 144);
  CM_VectorCopy2((_DWORD *)a1, v16);
  v17 = v17 - *(float *)(a1 + 144);
  for ( i = 0; i <= 2; ++i )
  {
    *(float *)&v10[i] = (*(float *)(*(_DWORD *)(a1 + 180) + 4 * i) + *(float *)(*(_DWORD *)(a1 + 180) + 4 * i + 12))
                      * 0.5;
    v7[i] = *(float *)(*(_DWORD *)(a1 + 180) + 4 * i) - *(float *)&v10[i];
    v8[i] = *(float *)(*(_DWORD *)(a1 + 180) + 4 * i + 12) - *(float *)&v10[i];
  }
  if ( v8[0] <= (long double)v9 )
    v2 = v8[0];
  else
    v2 = v9;
  v6 = v9 - v2;
  v5 = (*(float *)(a1 + 140) + v2) * (*(float *)(a1 + 140) + v2);
  CM_VectorCopy2(v10, v14);
  v15 = v15 + v6;
  CM_VectorSubtract(v14, v18, v11);
  if ( v5 > CM_VectorLengthSquared(v11) )
  {
    *(_BYTE *)(a2 + 34) = 1;
    *(_BYTE *)(a2 + 35) = 1;
    *(_DWORD *)a2 = 0;
  }
  CM_VectorSubtract(v14, v16, v11);
  if ( v5 > CM_VectorLengthSquared(v11) )
  {
    *(_BYTE *)(a2 + 34) = 1;
    *(_BYTE *)(a2 + 35) = 1;
    *(_DWORD *)a2 = 0;
  }
  CM_VectorCopy2(v10, v12);
  v13 = v13 - v6;
  CM_VectorSubtract(v12, v18, v11);
  if ( v5 > CM_VectorLengthSquared(v11) )
  {
    *(_BYTE *)(a2 + 34) = 1;
    *(_BYTE *)(a2 + 35) = 1;
    *(_DWORD *)a2 = 0;
  }
  CM_VectorSubtract(v12, v16, v11);
  if ( v5 > CM_VectorLengthSquared(v11) )
  {
    *(_BYTE *)(a2 + 34) = 1;
    *(_BYTE *)(a2 + 35) = 1;
    *(_DWORD *)a2 = 0;
  }
  v4 = *(float *)(a1 + 8) - *(float *)&v10[2];
  v3 = v6 + *(float *)(a1 + 100) - *(float *)(a1 + 140);
  if ( v3 >= CM_Fabs(v4) )
  {
    v15 = 0.0;
    v19 = 0.0;
    CM_VectorSubtract(v18, v14, v11);
    if ( v5 > CM_VectorLengthSquared(v11) )
    {
      *(_BYTE *)(a2 + 34) = 1;
      *(_BYTE *)(a2 + 35) = 1;
      *(_DWORD *)a2 = 0;
    }
  }
}
// 80596DA: using guessed type float var_28[2];
// 80596DA: using guessed type float var_38[2];
// 80596DA: using guessed type float var_98[3];
// 80596DA: using guessed type float var_8C[2];
// 80596DA: using guessed type float var_48[2];
// 80596DA: using guessed type float var_68[4];
// 80596DA: using guessed type float var_58[2];

//----- (08059A48) --------------------------------------------------------
_DWORD *__cdecl sub_8059A48(float *a1, int a2)
{
  _DWORD *result; // eax
  int v3[4]; // [esp+10h] [ebp-1048h] BYREF
  float v4[3]; // [esp+20h] [ebp-1038h] BYREF
  float v5[8]; // [esp+2Ch] [ebp-102Ch] BYREF
  int i; // [esp+4Ch] [ebp-100Ch]
  int v7[1026]; // [esp+50h] [ebp-1008h] BYREF

  result = (_DWORD *)a2;
  if ( !*(_BYTE *)(a2 + 34) )
  {
    CM_VectorSubtract(a1, a1 + 23, v4);
    sub_805D4CC(a1, a1 + 23, v5);
    for ( i = 0; i <= 2; ++i )
    {
      v4[i] = v4[i] - 1.0;
      v5[i] = v5[i] + 1.0;
    }
    v3[0] = 0;
    v3[1] = 1024;
    v3[3] = (int)v7;
    v5[3] = 0.0;
    v3[2] = 0;
    result = sub_8058ABE((int)v3, 0);
    if ( v3[0] )
    {
      for ( i = 0; ; ++i )
      {
        result = (_DWORD *)i;
        if ( i >= v3[0] )
          break;
        result = (_DWORD *)a2;
        if ( *(_BYTE *)(a2 + 34) )
          break;
        sub_8059674((int)a1, dword_8185C08 + 44 * v7[i], a2);
      }
    }
  }
  return result;
}
// 8185C08: using guessed type int dword_8185C08;
// 8059A48: using guessed type float var_1038[3];
// 8059A48: using guessed type int var_1008[1026];

//----- (08059BBC) --------------------------------------------------------
void __cdecl sub_8059BBC(float *a1, _DWORD *a2, int a3)
{
  long double v3; // fst7
  long double v4; // fst7
  float v5; // [esp+0h] [ebp-98h]
  float v6; // [esp+18h] [ebp-80h]
  float v7; // [esp+18h] [ebp-80h]
  int v8; // [esp+1Ch] [ebp-7Ch]
  float v9[10]; // [esp+20h] [ebp-78h] BYREF
  int v10[2]; // [esp+48h] [ebp-50h] BYREF
  int i; // [esp+50h] [ebp-48h]
  _DWORD *v12; // [esp+54h] [ebp-44h]
  float v13; // [esp+58h] [ebp-40h]
  float v14; // [esp+5Ch] [ebp-3Ch]
  float v15; // [esp+60h] [ebp-38h]
  int *v16; // [esp+64h] [ebp-34h]
  float **v17; // [esp+68h] [ebp-30h]
  float v18; // [esp+6Ch] [ebp-2Ch]
  int v19; // [esp+70h] [ebp-28h]
  float v20; // [esp+74h] [ebp-24h]
  float v21; // [esp+78h] [ebp-20h]
  float v22; // [esp+7Ch] [ebp-1Ch]
  float v23; // [esp+80h] [ebp-18h]
  float v24; // [esp+84h] [ebp-14h]
  float *v25; // [esp+88h] [ebp-10h]
  int v26; // [esp+8Ch] [ebp-Ch]

  v23 = 0.0;
  v22 = *(float *)a3;
  v19 = 1;
  v16 = 0;
  v13 = -1.0;
  v12 = a2;
  v8 = 0;
  while ( 2 )
  {
    for ( i = 0; i <= 2; ++i )
    {
      v21 = (a1[i] - *(float *)&v12[i]) * v13 - a1[i + 37];
      v20 = (a1[i + 3] - *(float *)&v12[i]) * v13 - a1[i + 37];
      if ( v21 <= 0.0 )
      {
        if ( v20 > 0.0 )
        {
          v7 = v21 * a1[i + 6] * v13;
          if ( v23 >= (long double)v7 )
            return;
          v19 = 0;
          sub_805D3EE(v22, v7);
          v22 = v7;
        }
      }
      else
      {
        sub_805D3EE(v21, 0.125);
        if ( v20 >= 0.0 )
          return;
        v6 = (v21 - 0.125) * a1[i + 6] * v13;
        if ( v6 >= (long double)v22 )
          return;
        if ( v20 > 0.0 )
          v19 = 0;
        if ( v6 <= (long double)v23 )
        {
          if ( v16 )
            continue;
        }
        else
        {
          v23 = v6;
        }
        v10[1] = *((__int16 *)a2 + 3 * v8 + i + 18);
        sub_805D434(v9);
        v9[i] = v13;
        v10[0] = (int)v9;
        v16 = v10;
      }
    }
    if ( !v8 )
    {
      v13 = 1.0;
      v12 = a2 + 4;
      v8 = 1;
      continue;
    }
    break;
  }
  v17 = (float **)a2[8];
  v26 = a2[7];
  while ( 2 )
  {
    if ( v26 )
    {
      v25 = *v17;
      v5 = v25[2] * a1[36];
      v15 = CM_Fabs(v5);
      v24 = v25[3] + a1[35] + v15;
      v3 = sub_805D554(a1, v25);
      v21 = v3 - v24;
      v4 = sub_805D554(a1 + 3, v25);
      v20 = v4 - v24;
      if ( v21 <= 0.0 )
      {
        if ( v20 > 0.0 )
        {
          v14 = v21 - v20;
          if ( v21 > v22 * v14 )
          {
            v22 = v21 / v14;
            if ( v23 >= (long double)v22 )
              return;
          }
          v19 = 0;
        }
      }
      else
      {
        sub_805D3EE(v21, 0.125);
        if ( v20 >= 0.0 )
          return;
        if ( v20 > 0.0 )
          v19 = 0;
        v14 = v21 - v20;
        v18 = v21 - 0.125;
        if ( v18 <= v23 * v14 )
        {
          if ( !v16 )
            goto LABEL_29;
        }
        else
        {
          v23 = v18 / v14;
          if ( v23 >= (long double)v22 )
            return;
LABEL_29:
          v16 = (int *)v17;
        }
      }
      --v26;
      v17 += 2;
      continue;
    }
    break;
  }
  *(_DWORD *)(a3 + 20) = a2[3];
  if ( v16 )
  {
    *(float *)a3 = v23;
    CM_VectorCopy2((_DWORD *)*v16, (_DWORD *)(a3 + 4));
    *(_DWORD *)(a3 + 16) = *((_DWORD *)dword_8185BF0 + 18 * v16[1] + 16);
    *(_DWORD *)(a3 + 24) = (char *)dword_8185BF0 + 72 * v16[1];
  }
  else
  {
    *(_BYTE *)(a3 + 35) = 1;
    if ( v19 )
    {
      *(_BYTE *)(a3 + 34) = 1;
      *(_DWORD *)a3 = 0;
    }
  }
}
// 8059BBC: using guessed type float var_78[10];

//----- (08059FDC) --------------------------------------------------------
void __cdecl sub_8059FDC(int a1, unsigned __int8 *a2, _DWORD *a3, float *a4, float *a5)
{
  long double v5; // fst7
  long double v6; // fst7
  long double v7; // fst7
  float v8; // [esp+38h] [ebp-70h]
  float v9; // [esp+3Ch] [ebp-6Ch]
  float v10[4]; // [esp+40h] [ebp-68h] BYREF
  float v11; // [esp+50h] [ebp-58h]
  float v12; // [esp+54h] [ebp-54h]
  _BOOL4 v13; // [esp+58h] [ebp-50h]
  float v14; // [esp+5Ch] [ebp-4Ch]
  float v15; // [esp+60h] [ebp-48h] BYREF
  float v16; // [esp+64h] [ebp-44h]
  float v17; // [esp+68h] [ebp-40h]
  float v18; // [esp+6Ch] [ebp-3Ch]
  float v19; // [esp+7Ch] [ebp-2Ch]
  float v20; // [esp+80h] [ebp-28h]
  float v21; // [esp+84h] [ebp-24h]
  float v22; // [esp+88h] [ebp-20h]
  float v23; // [esp+8Ch] [ebp-1Ch]
  float v24; // [esp+90h] [ebp-18h]
  _DWORD *v25; // [esp+94h] [ebp-14h]
  int v26; // [esp+98h] [ebp-10h]
  int i; // [esp+9Ch] [ebp-Ch]

  sub_805D626(a3, &v15);
  while ( (*((_DWORD *)a2 + 1) & *(_DWORD *)(a1 + 128)) != 0 )
  {
    if ( *((_WORD *)a2 + 1) )
    {
      if ( *((__int16 *)a2 + 1) > 0 )
      {
        for ( i = 0; i < *((__int16 *)a2 + 1); ++i )
        {
          v26 = *(unsigned __int16 *)(*((_DWORD *)a2 + 2) + 2 * i);
          v25 = (_DWORD *)(dword_8185C60 + 48 * v26);
          if ( (v25[3] & *(_DWORD *)(a1 + 128)) != 0 )
            sub_8059BBC((float *)a1, v25, (int)a5);
        }
        return;
      }
      sub_8059FDC(a1, a2 + 20, &v15, a4, a5);
    }
    v23 = *(&v15 + *a2) - *((float *)a2 + 2);
    v22 = a4[*a2] - *((float *)a2 + 2);
    v5 = *(float *)(a1 + 4 * *a2 + 92) + 0.125 - *((float *)a2 + 3);
    v24 = v5;
    sub_805D3CA(v23, v22);
    v19 = v5;
    sub_805D3EE(v23, v22);
    v20 = v5;
    if ( v20 < (long double)v24 )
    {
      if ( -v24 < (long double)v19 )
      {
        if ( v18 >= (long double)*a5 )
          return;
        v9 = v22 - v23;
        v8 = CM_Fabs(v9);
        v6 = 0.00000047683716;
        if ( v8 <= 0.00000047683716 )
        {
          v13 = 0;
          v12 = 1.0;
          v11 = 0.0;
        }
        else
        {
          v21 = sub_805D34E(v9, COERCE_FLOAT(LODWORD(v23) ^ 0x80000000), v23);
          v14 = 1.0 / v8;
          v11 = (v21 - v24) * v14;
          v6 = (v21 + v24) * v14;
          v12 = v6;
          v13 = sub_805D3B2(v9);
        }
        sub_805D3EE(v12, 1.0);
        v12 = v6;
        v10[0] = (*a4 - v15) * v12 + v15;
        v10[1] = (a4[1] - v16) * v12 + v16;
        v10[2] = (a4[2] - v17) * v12 + v17;
        v7 = (a4[3] - v18) * v12 + v18;
        v10[3] = v7;
        sub_8059FDC(a1, &a2[20 * *(unsigned __int16 *)&a2[2 * v13 + 16]], &v15, v10, a5);
        sub_805D3CA(v11, 0.0);
        v11 = v7;
        v15 = (*a4 - v15) * v11 + v15;
        v16 = (a4[1] - v16) * v11 + v16;
        v17 = (a4[2] - v17) * v11 + v17;
        v18 = (a4[3] - v18) * v11 + v18;
        a2 += 20 * *(unsigned __int16 *)&a2[2 * (1 - v13) + 16];
      }
      else
      {
        a2 += 20 * *((unsigned __int16 *)a2 + 9);
      }
    }
    else
    {
      if ( -v24 >= (long double)v19 )
        return;
      a2 += 20 * *((unsigned __int16 *)a2 + 8);
    }
  }
}
// 8185C60: using guessed type int dword_8185C60;

//----- (0805A3A4) --------------------------------------------------------
_BOOL4 __cdecl sub_805A3A4(int a1, int a2, float *a3)
{
  float v5[4]; // [esp+30h] [ebp-48h] BYREF
  _DWORD v6[4]; // [esp+40h] [ebp-38h] BYREF
  float v7[4]; // [esp+50h] [ebp-28h] BYREF
  float v8[6]; // [esp+60h] [ebp-18h] BYREF

  CM_VectorSubtract((float *)(a2 + 12), (float *)(a1 + 92), v8);
  sub_805D4CC((float *)(a2 + 24), (float *)(a1 + 92), v7);
  if ( sub_805D6DC(a1, (int)v8, (int)v7, *a3) )
    return 0;
  CM_VectorCopy2((_DWORD *)a1, v6);
  CM_VectorCopy2((_DWORD *)(a1 + 12), v5);
  v6[3] = 0;
  v5[3] = *a3;
  sub_8059FDC(a1, (unsigned __int8 *)dword_8185C10 + 20 * *(_DWORD *)(a2 + 36), v6, v5, a3);
  return 0.0 == *a3;
}
// 805A3A4: using guessed type float var_18[6];
// 805A3A4: using guessed type float var_28[4];

//----- (0805A4AA) --------------------------------------------------------
void __cdecl sub_805A4AA(int a1, unsigned __int16 *a2, float *a3)
{
  int i; // [esp+14h] [ebp-4h]

  if ( *a3 != 0.0
    && ((*((_DWORD *)a2 + 1) & *(_DWORD *)(a1 + 128)) == 0 || !sub_805A3A4(a1, (int)a2, a3))
    && (*((_DWORD *)a2 + 2) & *(_DWORD *)(a1 + 128)) != 0 )
  {
    for ( i = 0; i < a2[1] && *a3 != 0.0; ++i )
      sub_8055C74(a1, dword_8185C50 + 32 * (i + *a2), (int)a3);
  }
}
// 8185C50: using guessed type int dword_8185C50;

//----- (0805A564) --------------------------------------------------------
int __cdecl sub_805A564(int a1, float *a2, float *a3, float *a4, float a5, int a6)
{
  long double v6; // fst7
  long double v7; // fst7
  float v9; // [esp+18h] [ebp-50h]
  _DWORD v11[5]; // [esp+20h] [ebp-48h] BYREF
  float v12; // [esp+34h] [ebp-34h]
  float v13; // [esp+38h] [ebp-30h]
  float v14; // [esp+3Ch] [ebp-2Ch]
  float v15; // [esp+40h] [ebp-28h]
  float v16; // [esp+44h] [ebp-24h]
  float v17; // [esp+48h] [ebp-20h]
  float v18; // [esp+4Ch] [ebp-1Ch]
  float v19[6]; // [esp+50h] [ebp-18h] BYREF

  CM_VectorSubtract(a2, a4, v19);
  v14 = (a5 + *(float *)(a1 + 140)) * (a5 + *(float *)(a1 + 140));
  v16 = sub_805D554(v19, v19) - v14;
  if ( v16 > 0.0 )
  {
    v17 = sub_805D554((float *)(a1 + 36), v19);
    if ( v17 < 0.0 )
    {
      v18 = *(float *)(a1 + 52);
      v15 = v17 * v17 - v18 * v16;
      if ( v15 >= 0.0 )
      {
        v12 = sub_80A2298(v19, (int)v11);
        LODWORD(v9) = LODWORD(v17) ^ 0x80000000;
        v6 = CM_Sqrt(v15);
        v13 = (v9 - v6) / v18 + v12 * 0.125 / v17;
        v7 = v13;
        if ( *(float *)a6 <= (long double)v13 )
        {
          return 1;
        }
        else
        {
          sub_805D3CA(v13, 0.0);
          *(float *)a6 = v7;
          CM_VectorCopy2(v11, (_DWORD *)(a6 + 4));
          *(_DWORD *)(a6 + 20) = *(_DWORD *)(*(_DWORD *)(a1 + 176) + 12);
          return 0;
        }
      }
      else
      {
        return 1;
      }
    }
    else
    {
      return 1;
    }
  }
  else
  {
    *(_DWORD *)a6 = 0;
    *(_BYTE *)(a6 + 35) = 1;
    sub_80A2298(v19, a6 + 4);
    *(_DWORD *)(a6 + 20) = *(_DWORD *)(*(_DWORD *)(a1 + 176) + 12);
    CM_VectorSubtract(a3, a4, v19);
    if ( v14 >= CM_VectorLengthSquared(v19) )
      *(_BYTE *)(a6 + 34) = 1;
    return 0;
  }
}
// 805A564: using guessed type float var_18[6];
// 805A564: using guessed type _DWORD var_48[5];

//----- (0805A75A) --------------------------------------------------------
int __cdecl sub_805A75A(int a1, float *a2, float a3, float a4, int a5)
{
  long double v5; // fst7
  float v7; // [esp+10h] [ebp-58h]
  float v9; // [esp+18h] [ebp-50h]
  float v10; // [esp+1Ch] [ebp-4Ch]
  float v11; // [esp+1Ch] [ebp-4Ch]
  _DWORD v12[4]; // [esp+20h] [ebp-48h] BYREF
  float v13; // [esp+30h] [ebp-38h]
  float v14; // [esp+34h] [ebp-34h]
  float v15; // [esp+38h] [ebp-30h]
  float v16; // [esp+3Ch] [ebp-2Ch]
  float v17; // [esp+40h] [ebp-28h]
  float v18; // [esp+44h] [ebp-24h]
  float v19; // [esp+48h] [ebp-20h]
  float v20; // [esp+4Ch] [ebp-1Ch]
  float v21[2]; // [esp+50h] [ebp-18h] BYREF
  float v22; // [esp+58h] [ebp-10h]

  CM_VectorSubtract((float *)a1, a2, v21);
  v16 = (a4 + *(float *)(a1 + 140)) * (a4 + *(float *)(a1 + 140));
  v18 = sub_805D412(v21, v21) - v16;
  if ( v18 > 0.0 )
  {
    v19 = sub_805D412((float *)(a1 + 36), v21);
    if ( v19 < 0.0 )
    {
      v20 = sub_805D412((float *)(a1 + 36), (float *)(a1 + 36));
      v17 = v19 * v19 - v20 * v18;
      if ( v17 >= 0.0 )
      {
        v22 = 0.0;
        v13 = sub_80A2298(v21, (int)v12);
        v14 = v13 * 0.125 / v19;
        LODWORD(v7) = LODWORD(v19) ^ 0x80000000;
        v5 = CM_Sqrt(v17);
        v15 = (v7 - v5) / v20 + v14;
        if ( *(float *)a5 <= (long double)v15 )
        {
          return 1;
        }
        else
        {
          v11 = *(float *)(a1 + 100) - *(float *)(a1 + 140) + a3;
          v9 = (v15 - v14) * *(float *)(a1 + 44) + *(float *)(a1 + 8) - a2[2];
          if ( CM_Fabs(v9) <= v11 )
          {
            sub_805D3CA(v15, 0.0);
            *(float *)a5 = v11;
            CM_VectorCopy2(v12, (_DWORD *)(a5 + 4));
            *(_DWORD *)(a5 + 20) = *(_DWORD *)(*(_DWORD *)(a1 + 176) + 12);
            return 0;
          }
          else
          {
            return 1;
          }
        }
      }
      else
      {
        return 1;
      }
    }
    else
    {
      return 1;
    }
  }
  else
  {
    v10 = *(float *)(a1 + 100) - *(float *)(a1 + 140) + a3;
    if ( CM_Fabs(v22) <= v10 )
    {
      *(_DWORD *)a5 = 0;
      *(_BYTE *)(a5 + 35) = 1;
      v22 = 0.0;
      sub_80A2298(v21, a5 + 4);
      *(_DWORD *)(a5 + 20) = *(_DWORD *)(*(_DWORD *)(a1 + 176) + 12);
      CM_VectorSubtract((float *)(a1 + 12), a2, v21);
      if ( v10 >= CM_Fabs(v22) )
        *(_BYTE *)(a5 + 34) = 1;
      return 0;
    }
    else
    {
      return 1;
    }
  }
}
// 805A75A: using guessed type float var_18[2];
// 805A75A: using guessed type _DWORD var_48[4];

//----- (0805AA0E) --------------------------------------------------------
void __cdecl sub_805AA0E(int a1, int a2)
{
  float v2; // [esp+2Ch] [ebp-BCh]
  float v3; // [esp+30h] [ebp-B8h]
  float v4[3]; // [esp+40h] [ebp-A8h]
  float v5[2]; // [esp+4Ch] [ebp-9Ch]
  float v6; // [esp+54h] [ebp-94h]
  float v7[4]; // [esp+60h] [ebp-88h] BYREF
  int v8[2]; // [esp+70h] [ebp-78h] BYREF
  float v9; // [esp+78h] [ebp-70h]
  int v10[2]; // [esp+80h] [ebp-68h] BYREF
  float v11; // [esp+88h] [ebp-60h]
  int v12[2]; // [esp+90h] [ebp-58h] BYREF
  float v13; // [esp+98h] [ebp-50h]
  int v14[2]; // [esp+A0h] [ebp-48h] BYREF
  float v15; // [esp+A8h] [ebp-40h]
  int v16[2]; // [esp+B0h] [ebp-38h] BYREF
  float v17; // [esp+B8h] [ebp-30h]
  int v18[2]; // [esp+C0h] [ebp-28h] BYREF
  float v19; // [esp+C8h] [ebp-20h]
  int i; // [esp+DCh] [ebp-Ch]

  if ( *(float *)(a1 + 104) <= *(float *)(*(_DWORD *)(a1 + 180) + 12) + 1.0
    && *(float *)(a1 + 108) <= *(float *)(*(_DWORD *)(a1 + 180) + 16) + 1.0
    && *(float *)(a1 + 112) <= *(float *)(*(_DWORD *)(a1 + 180) + 20) + 1.0
    && **(float **)(a1 + 180) - 1.0 <= *(float *)(a1 + 116)
    && *(float *)(*(_DWORD *)(a1 + 180) + 4) - 1.0 <= *(float *)(a1 + 120)
    && *(float *)(*(_DWORD *)(a1 + 180) + 8) - 1.0 <= *(float *)(a1 + 124) )
  {
    CM_VectorCopy2((_DWORD *)a1, v14);
    v15 = v15 + *(float *)(a1 + 144);
    CM_VectorCopy2((_DWORD *)a1, v12);
    v13 = v13 - *(float *)(a1 + 144);
    CM_VectorCopy2((_DWORD *)(a1 + 12), v10);
    v11 = v11 + *(float *)(a1 + 144);
    CM_VectorCopy2((_DWORD *)(a1 + 12), v8);
    v9 = v9 - *(float *)(a1 + 144);
    for ( i = 0; i <= 2; ++i )
    {
      v7[i] = (*(float *)(*(_DWORD *)(a1 + 180) + 4 * i) + *(float *)(*(_DWORD *)(a1 + 180) + 4 * i + 12)) * 0.5;
      v4[i] = *(float *)(*(_DWORD *)(a1 + 180) + 4 * i) - v7[i];
      v5[i] = *(float *)(*(_DWORD *)(a1 + 180) + 4 * i + 12) - v7[i];
    }
    if ( v5[0] <= (long double)v6 )
      v2 = v5[0];
    else
      v2 = v6;
    v3 = v6 - v2;
    CM_VectorCopy2(v7, v18);
    v19 = v19 + v3;
    CM_VectorCopy2(v7, v16);
    v17 = v17 - v3;
    if ( v13 <= (long double)v19 )
    {
      if ( v17 > (long double)v15
        && (!sub_805A564(a1, (float *)v14, (float *)v10, (float *)v16, v2, a2) || *(float *)(a1 + 44) <= 0.0) )
      {
        return;
      }
    }
    else if ( !sub_805A564(a1, (float *)v12, (float *)v8, (float *)v18, v2, a2) || *(float *)(a1 + 44) >= 0.0 )
    {
      return;
    }
    if ( sub_805A75A(a1, v7, v3, v2, a2) )
    {
      if ( v9 <= (long double)v19 )
      {
        if ( v17 > (long double)v11 && v15 >= (long double)v17 )
          sub_805A564(a1, (float *)v14, (float *)v10, (float *)v16, v2, a2);
      }
      else if ( v19 >= (long double)v13 )
      {
        sub_805A564(a1, (float *)v12, (float *)v8, (float *)v18, v2, a2);
      }
    }
  }
}
// 805AA0E: using guessed type float var_88[4];
// 805AA0E: using guessed type float var_A8[3];
// 805AA0E: using guessed type float var_9C[2];

//----- (0805AE54) --------------------------------------------------------
void __cdecl sub_805AE54(int a1, int a2, _DWORD *a3, float *a4, float *a5)
{
  long double v5; // fst7
  long double v6; // fst7
  long double v7; // fst7
  long double v8; // fst6
  long double v9; // fst7
  long double v10; // fst7
  long double v11; // fst7
  float v12; // [esp+34h] [ebp-64h]
  float v13; // [esp+38h] [ebp-60h]
  float v14; // [esp+3Ch] [ebp-5Ch]
  float v15; // [esp+40h] [ebp-58h] BYREF
  float v16; // [esp+44h] [ebp-54h]
  float v17; // [esp+48h] [ebp-50h]
  float v18; // [esp+4Ch] [ebp-4Ch]
  _BOOL4 v19; // [esp+5Ch] [ebp-3Ch]
  float v20[4]; // [esp+60h] [ebp-38h] BYREF
  float v21; // [esp+70h] [ebp-28h]
  float v22; // [esp+74h] [ebp-24h]
  float v23; // [esp+78h] [ebp-20h]
  float v24; // [esp+7Ch] [ebp-1Ch]
  float v25; // [esp+80h] [ebp-18h]
  float v26; // [esp+84h] [ebp-14h]
  float *v27; // [esp+88h] [ebp-10h]
  int v28; // [esp+8Ch] [ebp-Ch]

  sub_805D626(a3, &v15);
  while ( a2 >= 0 )
  {
    v28 = dword_8185C00 + 8 * a2;
    v27 = *(float **)v28;
    if ( *((_BYTE *)v27 + 16) > 2u )
    {
      v6 = sub_805D554(v27, &v15);
      v26 = v6 - v27[3];
      v7 = sub_805D554(v27, a4);
      v5 = v7 - v27[3];
      v25 = v5;
      if ( *(_DWORD *)(a1 + 132) )
        v24 = 0.125;
      else
        v24 = 2048.0;
    }
    else
    {
      v26 = *(&v15 + *((unsigned __int8 *)v27 + 16)) - v27[3];
      v25 = a4[*((unsigned __int8 *)v27 + 16)] - v27[3];
      v5 = *(float *)(a1 + 4 * *((unsigned __int8 *)v27 + 16) + 92) + 0.125;
      v24 = v5;
    }
    sub_805D3EE(v26, v25);
    v8 = v5;
    v9 = v24;
    if ( v8 < v24 )
    {
      sub_805D3CA(v26, v25);
      if ( -v24 < v9 )
      {
        if ( v18 >= (long double)*a5 )
          return;
        v14 = v25 - v26;
        v13 = CM_Fabs(v14);
        v10 = 0.00000047683716;
        if ( v13 <= 0.00000047683716 )
        {
          v19 = 0;
          v22 = 1.0;
          v21 = 0.0;
        }
        else
        {
          v23 = sub_805D34E(v14, COERCE_FLOAT(LODWORD(v26) ^ 0x80000000), v26);
          v12 = 1.0 / v13;
          v21 = (v23 - v24) * v12;
          v10 = (v23 + v24) * v12;
          v22 = v10;
          v19 = sub_805D3B2(v14);
        }
        sub_805D3EE(v22, 1.0);
        v22 = v10;
        v20[0] = (*a4 - v15) * v22 + v15;
        v20[1] = (a4[1] - v16) * v22 + v16;
        v20[2] = (a4[2] - v17) * v22 + v17;
        v11 = (a4[3] - v18) * v22 + v18;
        v20[3] = v11;
        sub_805AE54(a1, *(__int16 *)(v28 + 2 * v19 + 4), &v15, v20, a5);
        sub_805D3CA(v21, 0.0);
        v21 = v11;
        v15 = (*a4 - v15) * v21 + v15;
        v16 = (a4[1] - v16) * v21 + v16;
        v17 = (a4[2] - v17) * v21 + v17;
        v18 = (a4[3] - v18) * v21 + v18;
        a2 = *(__int16 *)(v28 + 2 * !v19 + 4);
      }
      else
      {
        a2 = *(__int16 *)(v28 + 6);
      }
    }
    else
    {
      a2 = *(__int16 *)(v28 + 4);
    }
  }
  sub_805A4AA(a1, (unsigned __int16 *)(dword_8185C08 + 44 * (-1 - a2)), a5);
}
// 8185C00: using guessed type int dword_8185C00;
// 8185C08: using guessed type int dword_8185C08;

//----- (0805B198) --------------------------------------------------------
_BOOL4 __cdecl CM_SetAxialCullOnly(int a1)
{
  _BOOL4 result; // eax
  float v2; // [esp+14h] [ebp-24h]
  float v3; // [esp+18h] [ebp-20h]
  float v4; // [esp+1Ch] [ebp-1Ch]
  float v5[6]; // [esp+20h] [ebp-18h] BYREF

  CM_VectorSubtract((float *)(a1 + 116), (float *)(a1 + 104), v5);
  v4 = v5[0] * v5[1] * v5[2];
  v3 = *(float *)(a1 + 92) * *(float *)(a1 + 96) * *(float *)(a1 + 100);
  v2 = v3 * 16.0 * *(float *)(a1 + 48);
  result = v2 > (long double)v4;
  *(_DWORD *)(a1 + 136) = result;
  return result;
}

//----- (0805B210) --------------------------------------------------------
void __cdecl CM_Trace(int a1, float *a2, float *a3, int a4, int a5, int a6, int a7)
{
  int v7; // ebx
  float v8; // [esp+2Ch] [ebp-11Ch]
  float v9[4]; // [esp+30h] [ebp-118h] BYREF
  _DWORD v10[7]; // [esp+40h] [ebp-108h] BYREF
  int v11; // [esp+5Ch] [ebp-ECh]
  float v12[4]; // [esp+60h] [ebp-E8h]
  float v13[2]; // [esp+70h] [ebp-D8h] BYREF
  float v14; // [esp+78h] [ebp-D0h]
  float v15[2]; // [esp+7Ch] [ebp-CCh] BYREF
  float v16; // [esp+84h] [ebp-C4h]
  float v17[4]; // [esp+94h] [ebp-B4h] BYREF
  float v18; // [esp+A4h] [ebp-A4h]
  float v19[9]; // [esp+A8h] [ebp-A0h]
  float v20[2]; // [esp+CCh] [ebp-7Ch]
  float v21; // [esp+D4h] [ebp-74h]
  float v22[2]; // [esp+D8h] [ebp-70h]
  float v23; // [esp+E0h] [ebp-68h]
  float v24[2]; // [esp+E4h] [ebp-64h]
  float v25; // [esp+ECh] [ebp-5Ch]
  int v26; // [esp+F0h] [ebp-58h]
  _BOOL4 v27; // [esp+F4h] [ebp-54h]
  float v28; // [esp+FCh] [ebp-4Ch]
  float v29; // [esp+100h] [ebp-48h]
  float v30; // [esp+104h] [ebp-44h]
  float v31; // [esp+108h] [ebp-40h]
  float v32; // [esp+10Ch] [ebp-3Ch]
  int v33[4]; // [esp+110h] [ebp-38h] BYREF
  int v34; // [esp+120h] [ebp-28h]
  int i; // [esp+13Ch] [ebp-Ch]

  v11 = CM_ClipHandleToModel(a6);
  v26 = a7;
  for ( i = 0; i <= 2; ++i )
  {
    v12[i] = (*(float *)(a4 + 4 * i) + *(float *)(a5 + 4 * i)) * 0.5;
    v20[i] = *(float *)(a5 + 4 * i) - v12[i];
    v13[i] = a2[i] + v12[i];
    v15[i] = a3[i] + v12[i];
    v19[i] = (v13[i] + v15[i]) * 0.5;
    v17[i] = v15[i] - v13[i];
    v19[i + 3] = v17[i] * 0.5;
    v7 = i;
    v19[v7 + 6] = CM_Fabs(v19[i + 3]);
  }
  CM_CalcTraceExtents((int)v13);
  v18 = CM_VectorLengthSquared(v17);
  v17[3] = CM_Sqrt(v18);
  if ( v20[0] <= (long double)v21 )
    v8 = v20[0];
  else
    v8 = v21;
  v28 = v8;
  v29 = v21 - v8;
  for ( i = 0; i <= 1; ++i )
  {
    if ( v15[i] <= (long double)v13[i] )
    {
      v22[i] = v15[i] - v28;
      v24[i] = v13[i] + v28;
    }
    else
    {
      v22[i] = v13[i] - v28;
      v24[i] = v15[i] + v28;
    }
  }
  if ( v16 <= (long double)v14 )
  {
    v23 = v16 - v29 - v28;
    v25 = v14 + v29 + v28;
  }
  else
  {
    v23 = v14 - v29 - v28;
    v25 = v16 + v29 + v28;
  }
  CM_SetAxialCullOnly((int)v13);
  CM_GetTraceThreadInfo(v33);
  if ( (unsigned __int8)CM_VectorCompare(a2, a3) )
  {
    v27 = 0;
    if ( a6 )
    {
      if ( a6 == 1023 )
      {
        if ( (v26 & *(_DWORD *)(v34 + 12)) != 0 )
          CM_TraceCapsuleThroughCapsule((int)v13, a1);
      }
      else if ( !*(_BYTE *)(a1 + 34) )
      {
        sub_8059674((int)v13, v11 + 28, a1);
      }
    }
    else
    {
      sub_8059A48(v13, a1);
    }
  }
  else
  {
    v27 = 0.0 == v20[0] + v20[1] + v21;
    v30 = v28;
    v31 = v28;
    v32 = v28 + v29;
    if ( a6 )
    {
      if ( a6 == 1023 )
      {
        if ( (v26 & *(_DWORD *)(v34 + 12)) != 0 )
          sub_805AA0E((int)v13, a1);
      }
      else
      {
        sub_805A4AA((int)v13, (unsigned __int16 *)(v11 + 28), (float *)a1);
      }
    }
    else
    {
      CM_VectorCopy2(v13, v10);
      v10[3] = 0;
      CM_VectorCopy2(v15, v9);
      v9[3] = *(float *)a1;
      sub_805AE54((int)v13, 0, v10, v9, (float *)a1);
    }
  }
}
// 805B210: using guessed type float var_E8[4];
// 805B210: using guessed type float var_D8[2];
// 805B210: using guessed type float var_CC[2];
// 805B210: using guessed type float var_70[2];
// 805B210: using guessed type float var_64[2];
// 805B210: using guessed type int anonymous_0[4];

//----- (0805B690) --------------------------------------------------------
void __cdecl CM_BoxTrace(_DWORD *s, float *a2, float *a3, int a4, int a5, int a6, int a7)
{
  memset(s, 0, 0x24u);
  *s = 1065353216;
  CM_Trace((int)s, a2, a3, a4, a5, a6, a7);
}

//----- (0805B6F2) --------------------------------------------------------
void __cdecl sub_805B6F2(float *a1, int a2, int a3, int a4, int a5, int a6, int a7, float *a8, float *a9)
{
  int v9; // [esp+2Ch] [ebp-DCh]
  float v10; // [esp+30h] [ebp-D8h]
  int i; // [esp+3Ch] [ebp-CCh]
  float v12[12]; // [esp+40h] [ebp-C8h] BYREF
  float v13[12]; // [esp+70h] [ebp-98h] BYREF
  float v14[3]; // [esp+A0h] [ebp-68h] BYREF
  float v15[12]; // [esp+ACh] [ebp-5Ch] BYREF
  int v16; // [esp+DCh] [ebp-2Ch]
  float v17[4]; // [esp+E0h] [ebp-28h] BYREF
  float v18[6]; // [esp+F0h] [ebp-18h] BYREF

  for ( i = 0; i <= 2; ++i )
  {
    v15[i + 5] = (*(float *)(a4 + 4 * i) + *(float *)(a5 + 4 * i)) * 0.5;
    v14[i] = *(float *)(a4 + 4 * i) - v15[i + 5];
    v15[i] = *(float *)(a5 + 4 * i) - v15[i + 5];
    v18[i] = *(float *)(a2 + 4 * i) + v15[i + 5];
    v17[i] = *(float *)(a3 + 4 * i) + v15[i + 5];
  }
  CM_VectorSubtract(v18, a8, v18);
  CM_VectorSubtract(v17, a8, v17);
  v9 = 0;
  if ( *a9 != 0.0 || a9[1] != 0.0 || a9[2] != 0.0 )
    v9 = 1;
  v16 = v9;
  if ( v9 )
  {
    sub_80592B6(a9, (int)v13);
    sub_80591DE((int)v18, v13);
    sub_80591DE((int)v17, v13);
  }
  v10 = *a1;
  CM_Trace((int)a1, v18, v17, (int)v14, (int)v15, a6, a7);
  if ( v16 )
  {
    if ( v10 > (long double)*a1 )
    {
      sub_805924A((int)v13, (int)v12);
      sub_80591DE((int)(a1 + 1), v12);
    }
  }
}
// 805B6F2: using guessed type float var_68[3];
// 805B6F2: using guessed type float var_18[6];
// 805B6F2: using guessed type float var_28[4];
// 805B6F2: using guessed type float var_98[12];
// 805B6F2: using guessed type float var_C8[12];

//----- (0805B972) --------------------------------------------------------
void __cdecl sub_805B972(_DWORD *s, int a2, int a3, int a4, int a5, int a6, int a7, float *a8, float *a9)
{
  memset(s, 0, 0x24u);
  *s = 1065353216;
  sub_805B6F2((float *)s, a2, a3, a4, a5, a6, a7, a8, a9);
}

//----- (0805B9E2) --------------------------------------------------------
int __cdecl sub_805B9E2(float *a1, int a2)
{
  float v3; // [esp+0h] [ebp-58h]
  int i; // [esp+18h] [ebp-40h]
  int v6; // [esp+1Ch] [ebp-3Ch]
  float v7; // [esp+20h] [ebp-38h]
  int j; // [esp+24h] [ebp-34h]
  float v9; // [esp+28h] [ebp-30h]
  float v10; // [esp+28h] [ebp-30h]
  float v11; // [esp+2Ch] [ebp-2Ch]
  float **v12; // [esp+30h] [ebp-28h]
  float v13; // [esp+34h] [ebp-24h]
  float v14; // [esp+34h] [ebp-24h]
  float v15; // [esp+38h] [ebp-20h]
  float v16; // [esp+38h] [ebp-20h]
  float v17; // [esp+3Ch] [ebp-1Ch]
  float v18; // [esp+3Ch] [ebp-1Ch]
  float v19; // [esp+40h] [ebp-18h]
  float v20; // [esp+44h] [ebp-14h]
  float v21; // [esp+48h] [ebp-10h]
  float *v22; // [esp+4Ch] [ebp-Ch]
  int k; // [esp+50h] [ebp-8h]

  v20 = 0.0;
  v19 = 1.0;
  v7 = -1.0;
  v6 = a2;
  for ( i = 0; ; i = 1 )
  {
    for ( j = 0; j <= 2; ++j )
    {
      v15 = (a1[j] - *(float *)(v6 + 4 * j)) * v7 - a1[j + 37];
      v13 = (a1[j + 3] - *(float *)(v6 + 4 * j)) * v7 - a1[j + 37];
      if ( v15 <= 0.0 )
      {
        if ( v13 > 0.0 )
        {
          v10 = v15 * a1[j + 6] * v7;
          if ( v20 >= (long double)v10 )
            return 0;
          sub_805D3EE(v19, v10);
          v19 = v10;
        }
      }
      else
      {
        if ( v13 > 0.0 )
          return 0;
        v9 = v15 * a1[j + 6] * v7;
        if ( v9 >= (long double)v19 )
          return 0;
        sub_805D3CA(v20, v9);
        v20 = v19;
      }
    }
    if ( i )
      break;
    v7 = 1.0;
    v6 = a2 + 16;
  }
  v12 = *(float ***)(a2 + 32);
  for ( k = *(_DWORD *)(a2 + 28); k; --k )
  {
    v22 = *v12;
    v3 = (*v12)[2] * a1[36];
    v11 = CM_Fabs(v3);
    v21 = v22[3] + a1[35] + v11;
    v16 = sub_805D554(a1, v22) - v21;
    v14 = sub_805D554(a1 + 3, v22) - v21;
    if ( v16 <= 0.0 )
    {
      if ( v14 > 0.0 )
      {
        v18 = v16 - v14;
        if ( v16 > v19 * v18 )
        {
          v19 = v16 / v18;
          if ( v20 >= (long double)v19 )
            return 0;
        }
      }
    }
    else
    {
      v17 = v16 - v14;
      if ( v14 > 0.0 )
        return 0;
      if ( v16 > v20 * v17 )
      {
        v20 = v16 / v17;
        if ( v20 >= (long double)v19 )
          return 0;
      }
    }
    v12 += 2;
  }
  return -1431655765 * ((a2 - dword_8185C60) >> 4) + 1;
}
// 8185C60: using guessed type int dword_8185C60;

//----- (0805BCEE) --------------------------------------------------------
int __cdecl sub_805BCEE(int a1, unsigned __int8 *a2, _DWORD *a3, float *a4)
{
  long double v4; // fst7
  long double v5; // fst7
  long double v6; // fst7
  float v9; // [esp+28h] [ebp-70h]
  float v10; // [esp+2Ch] [ebp-6Ch]
  float v11[4]; // [esp+30h] [ebp-68h] BYREF
  float v12; // [esp+40h] [ebp-58h]
  float v13; // [esp+44h] [ebp-54h]
  _BOOL4 v14; // [esp+48h] [ebp-50h]
  float v15; // [esp+4Ch] [ebp-4Ch]
  float v16; // [esp+50h] [ebp-48h] BYREF
  float v17; // [esp+54h] [ebp-44h]
  float v18; // [esp+58h] [ebp-40h]
  float v19; // [esp+68h] [ebp-30h]
  float v20; // [esp+6Ch] [ebp-2Ch]
  float v21; // [esp+70h] [ebp-28h]
  float v22; // [esp+74h] [ebp-24h]
  float v23; // [esp+78h] [ebp-20h]
  float v24; // [esp+7Ch] [ebp-1Ch]
  int v25; // [esp+80h] [ebp-18h]
  int v26; // [esp+84h] [ebp-14h]
  int v27; // [esp+88h] [ebp-10h]
  int i; // [esp+8Ch] [ebp-Ch]

  CM_VectorCopy2(a3, &v16);
  while ( 1 )
  {
    if ( (*((_DWORD *)a2 + 1) & *(_DWORD *)(a1 + 128)) == 0 )
      return 0;
    if ( *((_WORD *)a2 + 1) )
      break;
LABEL_15:
    v23 = *(&v16 + *a2) - *((float *)a2 + 2);
    v22 = a4[*a2] - *((float *)a2 + 2);
    v4 = *(float *)(a1 + 4 * *a2 + 92) + 0.125 - *((float *)a2 + 3);
    v24 = v4;
    sub_805D3CA(v23, v22);
    v19 = v4;
    sub_805D3EE(v23, v22);
    v20 = v4;
    if ( v20 < (long double)v24 )
    {
      if ( -v24 < (long double)v19 )
      {
        v10 = v22 - v23;
        v9 = CM_Fabs(v10);
        v5 = 0.00000047683716;
        if ( v9 <= 0.00000047683716 )
        {
          v14 = 0;
          v13 = 1.0;
          v12 = 0.0;
        }
        else
        {
          v21 = sub_805D34E(v10, COERCE_FLOAT(LODWORD(v23) ^ 0x80000000), v23);
          v15 = 1.0 / v9;
          v12 = (v21 - v24) * v15;
          v5 = (v21 + v24) * v15;
          v13 = v5;
          v14 = sub_805D3B2(v10);
        }
        sub_805D3EE(v13, 1.0);
        v13 = v5;
        v11[0] = (*a4 - v16) * v13 + v16;
        v11[1] = (a4[1] - v17) * v13 + v17;
        v6 = (a4[2] - v18) * v13 + v18;
        v11[2] = v6;
        v25 = sub_805BCEE(a1, &a2[20 * *(unsigned __int16 *)&a2[2 * v14 + 16]], &v16, v11);
        if ( v25 )
          return v25;
        sub_805D3CA(v12, 0.0);
        v12 = v6;
        v16 = (*a4 - v16) * v12 + v16;
        v17 = (a4[1] - v17) * v12 + v17;
        v18 = (a4[2] - v18) * v12 + v18;
        a2 += 20 * *(unsigned __int16 *)&a2[2 * (1 - v14) + 16];
      }
      else
      {
        a2 += 20 * *((unsigned __int16 *)a2 + 9);
      }
    }
    else
    {
      if ( -v24 >= (long double)v19 )
        return 0;
      a2 += 20 * *((unsigned __int16 *)a2 + 8);
    }
  }
  if ( *((__int16 *)a2 + 1) <= 0 )
  {
    v25 = sub_805BCEE(a1, a2 + 20, &v16, a4);
    if ( v25 )
      return v25;
    goto LABEL_15;
  }
  for ( i = 0; i < *((__int16 *)a2 + 1); ++i )
  {
    v27 = *(unsigned __int16 *)(*((_DWORD *)a2 + 2) + 2 * i);
    v26 = dword_8185C60 + 48 * v27;
    if ( (*(_DWORD *)(v26 + 12) & *(_DWORD *)(a1 + 128)) != 0 )
    {
      v25 = sub_805B9E2((float *)a1, v26);
      if ( v25 )
        return v25;
    }
  }
  return 0;
}
// 8185C60: using guessed type int dword_8185C60;

//----- (0805C0BC) --------------------------------------------------------
int __cdecl sub_805C0BC(int a1, int a2)
{
  float v4[4]; // [esp+20h] [ebp-28h] BYREF
  float v5[6]; // [esp+30h] [ebp-18h] BYREF

  CM_VectorSubtract((float *)(a2 + 12), (float *)(a1 + 92), v5);
  sub_805D4CC((float *)(a2 + 24), (float *)(a1 + 92), v4);
  if ( sub_805D6DC(a1, (int)v5, (int)v4, 1.0) )
    return 0;
  else
    return sub_805BCEE(
             a1,
             (unsigned __int8 *)dword_8185C10 + 20 * *(_DWORD *)(a2 + 36),
             (_DWORD *)a1,
             (float *)(a1 + 12));
}
// 805C0BC: using guessed type float var_18[6];
// 805C0BC: using guessed type float var_28[4];

//----- (0805C16E) --------------------------------------------------------
int __cdecl sub_805C16E(int a1, unsigned __int16 *a2, float *a3)
{
  int v5; // [esp+10h] [ebp-8h]
  int i; // [esp+14h] [ebp-4h]

  if ( (*((_DWORD *)a2 + 1) & *(_DWORD *)(a1 + 128)) != 0 )
  {
    v5 = sub_805C0BC(a1, (int)a2);
    if ( v5 )
      return v5;
  }
  if ( (*((_DWORD *)a2 + 2) & *(_DWORD *)(a1 + 128)) != 0 )
  {
    for ( i = 0; i < a2[1]; ++i )
    {
      sub_8055CFE(a1, dword_8185C50 + 32 * (i + *a2), (int)a3);
      if ( *a3 != 1.0 )
        return i + *a2 + (unsigned __int16)word_8185C5C + 1;
    }
  }
  return 0;
}
// 8185C50: using guessed type int dword_8185C50;
// 8185C5C: using guessed type __int16 word_8185C5C;

//----- (0805C23C) --------------------------------------------------------
_BOOL4 __cdecl sub_805C23C(float *a1, float *a2, int a3, float *a4, float a5, float *a6)
{
  long double v6; // fst7
  float v8; // [esp+18h] [ebp-50h]
  char v10[20]; // [esp+20h] [ebp-48h] BYREF
  float v11; // [esp+34h] [ebp-34h]
  float v12; // [esp+38h] [ebp-30h]
  float v13; // [esp+3Ch] [ebp-2Ch]
  float v14; // [esp+40h] [ebp-28h]
  float v15; // [esp+44h] [ebp-24h]
  float v16; // [esp+48h] [ebp-20h]
  float v17; // [esp+4Ch] [ebp-1Ch]
  float v18[6]; // [esp+50h] [ebp-18h] BYREF

  CM_VectorSubtract(a2, a4, v18);
  v13 = (a5 + a1[35]) * (a5 + a1[35]);
  v15 = sub_805D554(v18, v18) - v13;
  if ( v15 <= 0.0 )
    return 0;
  v16 = sub_805D554(a1 + 9, v18);
  if ( v16 >= 0.0 )
    return 1;
  v17 = a1[13];
  v14 = v16 * v16 - v17 * v15;
  if ( v14 < 0.0 )
    return 1;
  v11 = sub_80A2298(v18, (int)v10);
  LODWORD(v8) = LODWORD(v16) ^ 0x80000000;
  v6 = CM_Sqrt(v14);
  v12 = (v8 - v6) / v17 + v16 * 0.125 / v11;
  return v12 >= (long double)*a6;
}
// 805C23C: using guessed type float var_18[6];
// 805C23C: using guessed type char var_48[20];

//----- (0805C370) --------------------------------------------------------
_BOOL4 __cdecl sub_805C370(float *a1, float *a2, float a3, float a4, float *a5)
{
  long double v5; // fst7
  float v7; // [esp+10h] [ebp-58h]
  float v9; // [esp+18h] [ebp-50h]
  float v10; // [esp+1Ch] [ebp-4Ch]
  float v11; // [esp+1Ch] [ebp-4Ch]
  char v12[16]; // [esp+20h] [ebp-48h] BYREF
  float v13; // [esp+30h] [ebp-38h]
  float v14; // [esp+34h] [ebp-34h]
  float v15; // [esp+38h] [ebp-30h]
  float v16; // [esp+3Ch] [ebp-2Ch]
  float v17; // [esp+40h] [ebp-28h]
  float v18; // [esp+44h] [ebp-24h]
  float v19; // [esp+48h] [ebp-20h]
  float v20; // [esp+4Ch] [ebp-1Ch]
  float v21[2]; // [esp+50h] [ebp-18h] BYREF
  float v22; // [esp+58h] [ebp-10h]

  CM_VectorSubtract(a1, a2, v21);
  v16 = (a4 + a1[35]) * (a4 + a1[35]);
  v18 = sub_805D412(v21, v21) - v16;
  if ( v18 > 0.0 )
  {
    v19 = sub_805D412(a1 + 9, v21);
    if ( v19 < 0.0 )
    {
      v20 = a1[13];
      v17 = v19 * v19 - v20 * v18;
      if ( v17 >= 0.0 )
      {
        v22 = 0.0;
        v13 = sub_80A2298(v21, (int)v12);
        v14 = v19 * 0.125 / v13;
        LODWORD(v7) = LODWORD(v19) ^ 0x80000000;
        v5 = CM_Sqrt(v17);
        v15 = (v7 - v5) / v20 + v14;
        if ( v15 < (long double)*a5 )
        {
          v11 = a1[25] - a1[35] + a3;
          v9 = (v15 - v14) * a1[11] + a1[2] - a2[2];
          return CM_Fabs(v9) > v11;
        }
        else
        {
          return 1;
        }
      }
      else
      {
        return 1;
      }
    }
    else
    {
      return 1;
    }
  }
  else
  {
    v10 = a1[25] - a1[35] + a3;
    return CM_Fabs(v22) > v10;
  }
}
// 805C370: using guessed type float var_18[2];
// 805C370: using guessed type char var_48[16];

//----- (0805C534) --------------------------------------------------------
int __cdecl sub_805C534(int a1, float *a2)
{
  float v3; // [esp+28h] [ebp-C0h]
  float v5; // [esp+30h] [ebp-B8h]
  float v6[3]; // [esp+40h] [ebp-A8h]
  float v7[2]; // [esp+4Ch] [ebp-9Ch]
  float v8; // [esp+54h] [ebp-94h]
  float v9[4]; // [esp+60h] [ebp-88h] BYREF
  int v10[2]; // [esp+70h] [ebp-78h] BYREF
  float v11; // [esp+78h] [ebp-70h]
  int v12[2]; // [esp+80h] [ebp-68h] BYREF
  float v13; // [esp+88h] [ebp-60h]
  int v14[2]; // [esp+90h] [ebp-58h] BYREF
  float v15; // [esp+98h] [ebp-50h]
  int v16[2]; // [esp+A0h] [ebp-48h] BYREF
  float v17; // [esp+A8h] [ebp-40h]
  int v18[2]; // [esp+B0h] [ebp-38h] BYREF
  float v19; // [esp+B8h] [ebp-30h]
  int v20[2]; // [esp+C0h] [ebp-28h] BYREF
  float v21; // [esp+C8h] [ebp-20h]
  int i; // [esp+DCh] [ebp-Ch]

  if ( *(float *)(a1 + 104) > *(float *)(*(_DWORD *)(a1 + 180) + 12) + 1.0
    || *(float *)(a1 + 108) > *(float *)(*(_DWORD *)(a1 + 180) + 16) + 1.0
    || *(float *)(a1 + 112) > *(float *)(*(_DWORD *)(a1 + 180) + 20) + 1.0
    || **(float **)(a1 + 180) - 1.0 > *(float *)(a1 + 116)
    || *(float *)(*(_DWORD *)(a1 + 180) + 4) - 1.0 > *(float *)(a1 + 120)
    || *(float *)(*(_DWORD *)(a1 + 180) + 8) - 1.0 > *(float *)(a1 + 124) )
  {
    return 0;
  }
  CM_VectorCopy2((_DWORD *)a1, v16);
  v17 = v17 + *(float *)(a1 + 144);
  CM_VectorCopy2((_DWORD *)a1, v14);
  v15 = v15 - *(float *)(a1 + 144);
  CM_VectorCopy2((_DWORD *)(a1 + 12), v12);
  v13 = v13 + *(float *)(a1 + 144);
  CM_VectorCopy2((_DWORD *)(a1 + 12), v10);
  v11 = v11 - *(float *)(a1 + 144);
  for ( i = 0; i <= 2; ++i )
  {
    v9[i] = (*(float *)(*(_DWORD *)(a1 + 180) + 4 * i) + *(float *)(*(_DWORD *)(a1 + 180) + 4 * i + 12)) * 0.5;
    v6[i] = *(float *)(*(_DWORD *)(a1 + 180) + 4 * i) - v9[i];
    v7[i] = *(float *)(*(_DWORD *)(a1 + 180) + 4 * i + 12) - v9[i];
  }
  if ( v7[0] <= (long double)v8 )
    v3 = v7[0];
  else
    v3 = v8;
  v5 = v8 - v3;
  CM_VectorCopy2(v9, v20);
  v21 = v21 + v5;
  CM_VectorCopy2(v9, v18);
  v19 = v19 - v5;
  if ( v15 <= (long double)v21 )
  {
    if ( v19 > (long double)v17 )
    {
      if ( !sub_805C23C((float *)a1, (float *)v16, (int)v12, (float *)v18, v3, a2) )
        return -1;
      if ( *(float *)(a1 + 44) <= 0.0 )
        return 0;
    }
  }
  else
  {
    if ( !sub_805C23C((float *)a1, (float *)v14, (int)v10, (float *)v20, v3, a2) )
      return -1;
    if ( *(float *)(a1 + 44) >= 0.0 )
      return 0;
  }
  if ( sub_805C370((float *)a1, v9, v5, v3, a2) )
  {
    if ( v11 <= (long double)v21 )
    {
      if ( v19 > (long double)v13
        && v17 >= (long double)v19
        && !sub_805C23C((float *)a1, (float *)v16, (int)v12, (float *)v18, v3, a2) )
      {
        return -1;
      }
    }
    else if ( v21 >= (long double)v15 && !sub_805C23C((float *)a1, (float *)v14, (int)v10, (float *)v20, v3, a2) )
    {
      return -1;
    }
    return 0;
  }
  return -1;
}
// 805C534: using guessed type float var_88[4];
// 805C534: using guessed type float var_A8[3];
// 805C534: using guessed type float var_9C[2];

//----- (0805C9DE) --------------------------------------------------------
int __cdecl sub_805C9DE(int a1, int a2, _DWORD *a3, float *a4, float *a5)
{
  long double v5; // fst7
  long double v6; // fst7
  long double v7; // fst7
  long double v8; // fst6
  long double v9; // fst7
  long double v10; // fst7
  long double v11; // fst7
  float v14; // [esp+34h] [ebp-64h]
  float v15; // [esp+38h] [ebp-60h]
  float v16; // [esp+3Ch] [ebp-5Ch]
  float v17; // [esp+40h] [ebp-58h] BYREF
  float v18; // [esp+44h] [ebp-54h]
  float v19; // [esp+48h] [ebp-50h]
  int v20; // [esp+58h] [ebp-40h]
  _BOOL4 v21; // [esp+5Ch] [ebp-3Ch]
  float v22[4]; // [esp+60h] [ebp-38h] BYREF
  float v23; // [esp+70h] [ebp-28h]
  float v24; // [esp+74h] [ebp-24h]
  float v25; // [esp+78h] [ebp-20h]
  float v26; // [esp+7Ch] [ebp-1Ch]
  float v27; // [esp+80h] [ebp-18h]
  float v28; // [esp+84h] [ebp-14h]
  float *v29; // [esp+88h] [ebp-10h]
  int v30; // [esp+8Ch] [ebp-Ch]

  CM_VectorCopy2(a3, &v17);
  while ( 1 )
  {
    while ( 1 )
    {
      while ( 1 )
      {
        if ( a2 < 0 )
          return sub_805C16E(a1, (unsigned __int16 *)(dword_8185C08 + 44 * (-1 - a2)), a5);
        v30 = dword_8185C00 + 8 * a2;
        v29 = *(float **)v30;
        if ( *((_BYTE *)v29 + 16) > 2u )
        {
          v6 = sub_805D554(v29, &v17);
          v28 = v6 - v29[3];
          v7 = sub_805D554(v29, a4);
          v5 = v7 - v29[3];
          v27 = v5;
          v26 = *(_DWORD *)(a1 + 132) ? 0.125 : 2048.0;
        }
        else
        {
          v28 = *(&v17 + *((unsigned __int8 *)v29 + 16)) - v29[3];
          v27 = a4[*((unsigned __int8 *)v29 + 16)] - v29[3];
          v5 = *(float *)(a1 + 4 * *((unsigned __int8 *)v29 + 16) + 92) + 0.125;
          v26 = v5;
        }
        sub_805D3EE(v28, v27);
        v8 = v5;
        v9 = v26;
        if ( v8 < v26 )
          break;
        a2 = *(__int16 *)(v30 + 4);
      }
      sub_805D3CA(v28, v27);
      if ( -v26 < v9 )
        break;
      a2 = *(__int16 *)(v30 + 6);
    }
    v16 = v27 - v28;
    v15 = CM_Fabs(v16);
    v10 = 0.00000047683716;
    if ( v15 <= 0.00000047683716 )
    {
      v21 = 0;
      v24 = 1.0;
      v23 = 0.0;
    }
    else
    {
      v25 = sub_805D34E(v16, COERCE_FLOAT(LODWORD(v28) ^ 0x80000000), v28);
      v14 = 1.0 / v15;
      v23 = (v25 - v26) * v14;
      v10 = (v25 + v26) * v14;
      v24 = v10;
      v21 = sub_805D3B2(v16);
    }
    sub_805D3EE(v24, 1.0);
    v24 = v10;
    v22[0] = (*a4 - v17) * v24 + v17;
    v22[1] = (a4[1] - v18) * v24 + v18;
    v11 = (a4[2] - v19) * v24 + v19;
    v22[2] = v11;
    v20 = sub_805C9DE(a1, *(__int16 *)(v30 + 2 * v21 + 4), &v17, v22, a5);
    if ( v20 )
      break;
    sub_805D3CA(v23, 0.0);
    v23 = v11;
    v17 = (*a4 - v17) * v23 + v17;
    v18 = (a4[1] - v18) * v23 + v18;
    v19 = (a4[2] - v19) * v23 + v19;
    a2 = *(__int16 *)(v30 + 2 * !v21 + 4);
  }
  return v20;
}
// 8185C00: using guessed type int dword_8185C00;
// 8185C08: using guessed type int dword_8185C08;

//----- (0805CCFA) --------------------------------------------------------
int __cdecl CM_BoxSightTrace(int a1, int a2, int a3, int a4, int a5, int a6, int a7)
{
  int v7; // ebx
  float v9; // [esp+2Ch] [ebp-12Ch]
  int v10[8]; // [esp+30h] [ebp-128h] BYREF
  char v11; // [esp+52h] [ebp-106h]
  char v12; // [esp+53h] [ebp-105h]
  int v13; // [esp+68h] [ebp-F0h]
  int v14; // [esp+6Ch] [ebp-ECh]
  float v15[4]; // [esp+70h] [ebp-E8h]
  float v16[2]; // [esp+80h] [ebp-D8h] BYREF
  float v17; // [esp+88h] [ebp-D0h]
  float v18[2]; // [esp+8Ch] [ebp-CCh] BYREF
  float v19; // [esp+94h] [ebp-C4h]
  float v20[4]; // [esp+A4h] [ebp-B4h] BYREF
  float v21; // [esp+B4h] [ebp-A4h]
  float v22[9]; // [esp+B8h] [ebp-A0h]
  float v23[2]; // [esp+DCh] [ebp-7Ch]
  float v24; // [esp+E4h] [ebp-74h]
  float v25[2]; // [esp+E8h] [ebp-70h]
  float v26; // [esp+F0h] [ebp-68h]
  float v27[2]; // [esp+F4h] [ebp-64h]
  float v28; // [esp+FCh] [ebp-5Ch]
  int v29; // [esp+100h] [ebp-58h]
  _BOOL4 v30; // [esp+104h] [ebp-54h]
  float v31; // [esp+10Ch] [ebp-4Ch]
  float v32; // [esp+110h] [ebp-48h]
  float v33; // [esp+114h] [ebp-44h]
  float v34; // [esp+118h] [ebp-40h]
  float v35; // [esp+11Ch] [ebp-3Ch]
  _DWORD v36[11]; // [esp+120h] [ebp-38h] BYREF
  int i; // [esp+14Ch] [ebp-Ch]
  int v38; // [esp+160h] [ebp+8h]

  v14 = CM_ClipHandleToModel(a6);
  v10[0] = 1065353216;
  v12 = 0;
  v11 = 0;
  v29 = a7;
  for ( i = 0; i <= 2; ++i )
  {
    v15[i] = (*(float *)(a4 + 4 * i) + *(float *)(a5 + 4 * i)) * 0.5;
    v23[i] = *(float *)(a5 + 4 * i) - v15[i];
    v16[i] = *(float *)(a2 + 4 * i) + v15[i];
    v18[i] = *(float *)(a3 + 4 * i) + v15[i];
    v22[i] = (v16[i] + v18[i]) * 0.5;
    v20[i] = v18[i] - v16[i];
    v22[i + 3] = v20[i] * 0.5;
    v7 = i;
    v22[v7 + 6] = CM_Fabs(v22[i + 3]);
  }
  CM_CalcTraceExtents((int)v16);
  v21 = CM_VectorLengthSquared(v20);
  v20[3] = CM_Sqrt(v21);
  if ( v23[0] <= (long double)v24 )
    v9 = v23[0];
  else
    v9 = v24;
  v31 = v9;
  v32 = v24 - v9;
  for ( i = 0; i <= 1; ++i )
  {
    if ( v18[i] <= (long double)v16[i] )
    {
      v25[i] = v18[i] - v31;
      v27[i] = v16[i] + v31;
    }
    else
    {
      v25[i] = v16[i] - v31;
      v27[i] = v18[i] + v31;
    }
  }
  if ( v19 <= (long double)v17 )
  {
    v26 = v19 - v32 - v31;
    v28 = v17 + v32 + v31;
  }
  else
  {
    v26 = v17 - v32 - v31;
    v28 = v19 + v32 + v31;
  }
  CM_SetAxialCullOnly((int)v16);
  v30 = 0.0 == v23[0] + v23[1] + v24;
  v33 = v31;
  v34 = v31;
  v35 = v31 + v32;
  CM_GetTraceThreadInfo(v36);
  if ( a6 )
  {
    if ( a6 == 1023 )
    {
      if ( (v29 & *(_DWORD *)(v36[4] + 12)) != 0 )
        return sub_805C534((int)v16, (float *)v10);
      else
        return 0;
    }
    else
    {
      return sub_805C16E((int)v16, (unsigned __int16 *)(v14 + 28), (float *)v10);
    }
  }
  else
  {
    v13 = 0;
    if ( a1 > 0 )
    {
      v38 = a1 - 1;
      if ( v38 < (unsigned __int16)word_8185C5C )
        v13 = sub_805B9E2(v16, dword_8185C60 + 48 * v38);
    }
    if ( !v13 )
      return sub_805C9DE((int)v16, 0, v16, v18, (float *)v10);
  }
  return v13;
}
// 8185C5C: using guessed type __int16 word_8185C5C;
// 8185C60: using guessed type int dword_8185C60;
// 805CCFA: using guessed type float var_E8[4];
// 805CCFA: using guessed type float var_D8[2];
// 805CCFA: using guessed type float var_CC[2];
// 805CCFA: using guessed type float var_70[2];
// 805CCFA: using guessed type float var_64[2];

//----- (0805D124) --------------------------------------------------------
int __cdecl sub_805D124(int a1, int a2, int a3, int a4, int a5, int a6, int a7, float *a8, float *a9)
{
  int v10; // [esp+20h] [ebp-A8h]
  int i; // [esp+2Ch] [ebp-9Ch]
  float v12[12]; // [esp+30h] [ebp-98h] BYREF
  float v13[3]; // [esp+60h] [ebp-68h] BYREF
  float v14[13]; // [esp+6Ch] [ebp-5Ch] BYREF
  float v15[4]; // [esp+A0h] [ebp-28h] BYREF
  float v16[6]; // [esp+B0h] [ebp-18h] BYREF

  for ( i = 0; i <= 2; ++i )
  {
    v14[i + 5] = (*(float *)(a4 + 4 * i) + *(float *)(a5 + 4 * i)) * 0.5;
    v13[i] = *(float *)(a4 + 4 * i) - v14[i + 5];
    v14[i] = *(float *)(a5 + 4 * i) - v14[i + 5];
    v16[i] = *(float *)(a2 + 4 * i) + v14[i + 5];
    v15[i] = *(float *)(a3 + 4 * i) + v14[i + 5];
  }
  CM_VectorSubtract(v16, a8, v16);
  CM_VectorSubtract(v15, a8, v15);
  v10 = 0;
  if ( *a9 != 0.0 || a9[1] != 0.0 || a9[2] != 0.0 )
    v10 = 1;
  LODWORD(v14[12]) = v10;
  if ( v10 )
  {
    sub_80592B6(a9, (int)v12);
    sub_80591DE((int)v16, v12);
    sub_80591DE((int)v15, v12);
  }
  return CM_BoxSightTrace(a1, (int)v16, (int)v15, (int)v13, (int)v14, a6, a7);
}
// 805D124: using guessed type float var_68[3];
// 805D124: using guessed type float var_18[6];
// 805D124: using guessed type float var_28[4];
// 805D124: using guessed type float var_98[12];

//----- (0805D34E) --------------------------------------------------------
long double __cdecl sub_805D34E(float a1, float a2, float a3)
{
  if ( a1 < 0.0 )
    return a3;
  return a2;
}

//----- (0805D378) --------------------------------------------------------
long double __cdecl CM_Fabs(float a1)
{
  return (float)fabs(a1);
}

//----- (0805D392) --------------------------------------------------------
long double __cdecl CM_Sqrt(float a1)
{
  return (float)sqrt(a1);
}

//----- (0805D3B2) --------------------------------------------------------
_BOOL4 __cdecl sub_805D3B2(float a1)
{
  return a1 >= 0.0;
}

//----- (0805D3CA) --------------------------------------------------------
void __cdecl sub_805D3CA(float a1, float a2)
{
  float v2; // [esp+0h] [ebp-18h]

  v2 = a1 - a2;
  sub_805D34E(v2, a1, a2);
}

//----- (0805D3EE) --------------------------------------------------------
void __cdecl sub_805D3EE(float a1, float a2)
{
  float v2; // [esp+0h] [ebp-18h]

  v2 = a2 - a1;
  sub_805D34E(v2, a1, a2);
}

//----- (0805D412) --------------------------------------------------------
long double __cdecl sub_805D412(float *a1, float *a2)
{
  return *a1 * *a2 + a1[1] * a2[1];
}

//----- (0805D434) --------------------------------------------------------
int __cdecl sub_805D434(_DWORD *a1)
{
  int result; // eax

  *a1 = 0;
  a1[1] = 0;
  result = 0;
  a1[2] = 0;
  return result;
}

//----- (0805D45E) --------------------------------------------------------
int __cdecl CM_VectorCopy2(_DWORD *a1, _DWORD *a2)
{
  int result; // eax

  *a2 = *a1;
  a2[1] = a1[1];
  result = a1[2];
  a2[2] = result;
  return result;
}

//----- (0805D48E) --------------------------------------------------------
unsigned int __cdecl sub_805D48E(_DWORD *a1)
{
  unsigned int result; // eax

  *a1 ^= 0x80000000;
  a1[1] ^= 0x80000000;
  result = a1[2] ^ 0x80000000;
  a1[2] = result;
  return result;
}

//----- (0805D4CC) --------------------------------------------------------
float *__cdecl sub_805D4CC(float *a1, float *a2, float *a3)
{
  float *result; // eax

  *a3 = *a1 + *a2;
  a3[1] = a1[1] + a2[1];
  result = a1 + 2;
  a3[2] = a1[2] + a2[2];
  return result;
}

//----- (0805D510) --------------------------------------------------------
float *__cdecl CM_VectorSubtract(float *a1, float *a2, float *a3)
{
  float *result; // eax

  *a3 = *a1 - *a2;
  a3[1] = a1[1] - a2[1];
  result = a1 + 2;
  a3[2] = a1[2] - a2[2];
  return result;
}

//----- (0805D554) --------------------------------------------------------
long double __cdecl sub_805D554(float *a1, float *a2)
{
  return *a1 * *a2 + a1[1] * a2[1] + a1[2] * a2[2];
}

//----- (0805D588) --------------------------------------------------------
int __cdecl CM_VectorCompare(float *a1, float *a2)
{
  int v3; // [esp+0h] [ebp-4h]

  v3 = 0;
  if ( *a1 == *a2 && a1[1] == a2[1] && a1[2] == a2[2] )
    return 1;
  return v3;
}

//----- (0805D5F2) --------------------------------------------------------
long double __cdecl CM_VectorLengthSquared(float *a1)
{
  return *a1 * *a1 + a1[1] * a1[1] + a1[2] * a1[2];
}

//----- (0805D626) --------------------------------------------------------
int __cdecl sub_805D626(_DWORD *a1, _DWORD *a2)
{
  int result; // eax

  *a2 = *a1;
  a2[1] = a1[1];
  a2[2] = a1[2];
  result = a1[3];
  a2[3] = result;
  return result;
}

//----- (0805D668) --------------------------------------------------------
int *__cdecl CM_CalcTraceExtents(int a1)
{
  int *result; // eax
  float v2; // [esp+0h] [ebp-18h]
  float v3; // [esp+Ch] [ebp-Ch]
  int i; // [esp+10h] [ebp-8h] BYREF

  for ( i = 0; i <= 2; ++i )
  {
    v3 = *(float *)(a1 + 4 * i) - *(float *)(a1 + 4 * i + 12);
    if ( v3 == 0.0 )
      v2 = 0.0;
    else
      v2 = 1.0 / v3;
    *(float *)(a1 + 4 * i + 24) = v2;
    result = &i;
  }
  return result;
}

//----- (0805D6DC) --------------------------------------------------------
int __cdecl sub_805D6DC(int a1, int a2, int a3, float a4)
{
  int i; // [esp+18h] [ebp-20h]
  float v8; // [esp+1Ch] [ebp-1Ch]
  float v9; // [esp+1Ch] [ebp-1Ch]
  float v10; // [esp+20h] [ebp-18h]
  float v11; // [esp+24h] [ebp-14h]
  float v12; // [esp+28h] [ebp-10h]
  float v14; // [esp+30h] [ebp-8h]

  v14 = 0.0;
  v12 = -1.0;
  while ( 1 )
  {
    for ( i = 0; i <= 2; ++i )
    {
      v11 = (*(float *)(a1 + 4 * i) - *(float *)(a2 + 4 * i)) * v12;
      v10 = (*(float *)(a1 + 4 * i + 12) - *(float *)(a2 + 4 * i)) * v12;
      if ( v11 <= 0.0 )
      {
        if ( v10 > 0.0 )
        {
          v9 = v11 * *(float *)(a1 + 4 * i + 24) * v12;
          if ( v14 >= (long double)v9 )
            return 1;
          sub_805D876(a4, v9);
          a4 = v9;
        }
      }
      else
      {
        if ( v10 > 0.0 )
          return 1;
        v8 = v11 * *(float *)(a1 + 4 * i + 24) * v12;
        if ( v8 >= (long double)a4 )
          return 1;
        sub_805D852(v14, v8);
        v14 = a4;
      }
    }
    if ( v12 == 1.0 )
      break;
    v12 = 1.0;
    a2 = a3;
  }
  return 0;
}

//----- (0805D852) --------------------------------------------------------
void __cdecl sub_805D852(float a1, float a2)
{
  float v2; // [esp+0h] [ebp-18h]

  v2 = a1 - a2;
  sub_805D89A(v2, a1, a2);
}

//----- (0805D876) --------------------------------------------------------
void __cdecl sub_805D876(float a1, float a2)
{
  float v2; // [esp+0h] [ebp-18h]

  v2 = a2 - a1;
  sub_805D89A(v2, a1, a2);
}

//----- (0805D89A) --------------------------------------------------------
long double __cdecl sub_805D89A(float a1, float a2, float a3)
{
  if ( a1 < 0.0 )
    return a3;
  return a2;
}

//----- (0805D8C4) --------------------------------------------------------
int __cdecl sub_805D8C4(float *a1, float *a2)
{
  unsigned int v2; // eax
  _BOOL2 v5; // [esp+24h] [ebp-14h]
  unsigned __int16 v6; // [esp+26h] [ebp-12h]
  float v7; // [esp+28h] [ebp-10h] BYREF
  float v8; // [esp+2Ch] [ebp-Ch]

  v6 = word_8185D9A;
  if ( !word_8185D9A )
    return 0;
  sub_805F9BC(a2, a1, &v7);
  v5 = v8 >= (long double)v7;
  if ( *(&v7 + (v8 >= (long double)v7)) <= 512.0 )
    return 0;
  v2 = 24 * v6;
  word_8185D9A = word_8185DAE[v2 / 2];
  *(_WORD *)(v2 + 135814572) = v5;
  *(float *)(v2 + 135814568) = (a2[v5] + a1[v5]) * 0.5;
  return v6;
}
// 8185D9A: using guessed type __int16 word_8185D9A;
// 8185DAE: using guessed type __int16 word_8185DAE[];

//----- (0805D9A8) --------------------------------------------------------
__int64 sub_805D9A8()
{
  __int64 result; // rax
  float v1; // [esp+18h] [ebp-10h] BYREF
  float v2; // [esp+1Ch] [ebp-Ch]
  unsigned int i; // [esp+24h] [ebp-4h]

  memset(flt_8185D80, 0, 0x601Cu);
  sub_8052518(0, flt_8185D80, flt_8185D8C);
  word_8185D9A = 2;
  for ( i = 2; i <= 0x3FE; ++i )
    word_8185DAE[12 * i] = i + 1;
  word_818BD96 = 0;
  sub_805F9BC(flt_8185D8C, flt_8185D80, &v1);
  word_8185DC4 = v2 >= (long double)v1;
  LODWORD(result) = v2 >= (long double)v1;
  HIDWORD(result) = result;
  flt_8185DC0 = (flt_8185D8C[(_DWORD)result] + flt_8185D80[(_DWORD)result]) * 0.5;
  return result;
}
// 8185D80: using guessed type float flt_8185D80[3];
// 8185D8C: using guessed type float flt_8185D8C[3];
// 8185D9A: using guessed type __int16 word_8185D9A;
// 8185DAE: using guessed type __int16 word_8185DAE[];
// 8185DC0: using guessed type float flt_8185DC0;
// 8185DC4: using guessed type __int16 word_8185DC4;
// 818BD96: using guessed type __int16 word_818BD96;

//----- (0805DA8E) --------------------------------------------------------
int sub_805DA8E()
{
  sub_805D9A8();
  return sub_805E51A();
}

//----- (0805DAA0) --------------------------------------------------------
int __cdecl sub_805DAA0(unsigned __int16 *a1)
{
  int result; // eax
  int j; // eax
  unsigned __int16 v3; // [esp+6h] [ebp-12h]
  int v4; // [esp+8h] [ebp-10h]
  unsigned __int16 v5; // [esp+Eh] [ebp-Ah]
  unsigned __int16 v6; // [esp+Eh] [ebp-Ah]
  int v7; // [esp+10h] [ebp-8h]
  int i; // [esp+14h] [ebp-4h]
  int v9; // [esp+14h] [ebp-4h]

  result = *a1;
  v3 = *a1;
  if ( *a1 )
  {
    v7 = 24 * v3 + 135814556;
    *a1 = 0;
    if ( (unsigned __int16 *)(372 * *((unsigned __int16 *)&unk_8185DA4 + 12 * v3) + 138600228) == a1 )
    {
      *((_WORD *)&unk_8185DA4 + 12 * v3) = a1[1];
    }
    else
    {
      for ( i = 372 * *((unsigned __int16 *)&unk_8185DA4 + 12 * v3) + 138600228;
            (unsigned __int16 *)(372 * *(unsigned __int16 *)(i + 2) + 138600228) != a1;
            i = 372 * *(unsigned __int16 *)(i + 2) + 138600228 )
      {
        ;
      }
      *(_WORD *)(i + 2) = a1[1];
    }
    while ( !*(_WORD *)(v7 + 8) )
    {
      if ( *(_WORD *)(v7 + 10) )
        break;
      if ( *(_WORD *)(v7 + 20) )
        break;
      if ( *(_WORD *)(v7 + 22) )
        break;
      *(_DWORD *)(v7 + 4) = 0;
      if ( !*(_WORD *)(v7 + 18) )
        break;
      v5 = *(_WORD *)(v7 + 18);
      *(_WORD *)(v7 + 18) = word_8185D9A;
      word_8185D9A = v3;
      v7 = 24 * v5 + 135814556;
      if ( *(_WORD *)&algn_8185DB0[24 * v5] == v3 )
        *(_WORD *)&algn_8185DB0[24 * v5] = 0;
      else
        *(_WORD *)&algn_8185DB0[24 * v5 + 2] = 0;
      v3 = v5;
    }
    while ( 1 )
    {
      v4 = dword_8185DA0[6 * *(unsigned __int16 *)(v7 + 20)] | dword_8185DA0[6 * *(unsigned __int16 *)(v7 + 22)];
      if ( *(_WORD *)(v7 + 8) )
      {
        v9 = 372 * *(unsigned __int16 *)(v7 + 8) + 138600228;
        for ( j = sub_808FE68(v9); ; j = sub_808FE68(v9) )
        {
          v4 |= *(_DWORD *)(j + 284);
          if ( !*(_WORD *)(v9 + 2) )
            break;
          v9 = 372 * *(unsigned __int16 *)(v9 + 2) + 138600228;
        }
      }
      *(_DWORD *)(v7 + 4) = v4;
      result = *(unsigned __int16 *)(v7 + 18);
      v6 = *(_WORD *)(v7 + 18);
      if ( !v6 )
        break;
      v7 = 24 * v6 + 135814556;
    }
  }
  return result;
}
// 8185D9A: using guessed type __int16 word_8185D9A;
// 8185DA0: using guessed type int dword_8185DA0[];

//----- (0805DCC8) --------------------------------------------------------
int __cdecl sub_805DCC8(unsigned __int16 *a1, unsigned __int16 a2)
{
  int result; // eax
  unsigned __int16 v3; // [esp+2h] [ebp-Ah]
  unsigned __int16 *i; // [esp+4h] [ebp-8h]

  v3 = -11275 * (((int)a1 - (int)&dword_842BC80 - 9240) >> 2);
  for ( i = (unsigned __int16 *)(24 * a2 + 135814564);
        v3 >= (unsigned __int16)(*i - 1);
        i = (unsigned __int16 *)(372 * *i + 138600230) )
  {
    ;
  }
  *a1 = a2;
  a1[1] = *i;
  result = v3 + 1;
  *i = result;
  return result;
}
// 842BC80: using guessed type int dword_842BC80;

//----- (0805DD50) --------------------------------------------------------
int __cdecl sub_805DD50(_WORD *a1, unsigned __int16 a2)
{
  int result; // eax
  unsigned __int16 v3; // [esp+2h] [ebp-Ah]
  _WORD *i; // [esp+4h] [ebp-8h]

  v3 = -13107 * (((int)a1 - dword_8185BE8) >> 4);
  for ( i = (_WORD *)(24 * a2 + 135814566);
        v3 >= (unsigned __int16)(*i - 1);
        i = (_WORD *)(dword_8185BE8 + 80 * (unsigned __int16)*i - 80) )
  {
    ;
  }
  *a1 = *i;
  result = v3 + 1;
  *i = result;
  return result;
}
// 8185BE8: using guessed type int dword_8185BE8;

//----- (0805DDD0) --------------------------------------------------------
int __cdecl sub_805DDD0(int a1, float *a2, float *a3)
{
  int result; // eax
  unsigned __int16 v4; // [esp+Eh] [ebp-2Ah]
  unsigned __int16 v5; // [esp+10h] [ebp-28h]
  unsigned __int16 v6; // [esp+12h] [ebp-26h]
  unsigned __int16 v7; // [esp+12h] [ebp-26h]
  unsigned __int16 *v8; // [esp+14h] [ebp-24h]
  int v9; // [esp+18h] [ebp-20h]
  float v10; // [esp+1Ch] [ebp-1Ch]
  int v11; // [esp+20h] [ebp-18h]
  unsigned __int16 *v12; // [esp+24h] [ebp-14h]
  unsigned __int16 *v13; // [esp+28h] [ebp-10h]

  result = a1;
  if ( !byte_8185D98 )
  {
    v11 = *((unsigned __int16 *)&unk_8185DAC + 12 * (unsigned __int16)a1);
    v10 = *((float *)&unk_8185DA8 + 6 * (unsigned __int16)a1);
    v9 = 0;
    v5 = *((_WORD *)&unk_8185DA4 + 12 * (unsigned __int16)a1);
    while ( v5 )
    {
      v13 = (unsigned __int16 *)(372 * v5 + 138600228);
      if ( *((float *)&unk_842DF24 + 93 * v5 + v11 + 89) <= (long double)v10 )
      {
        if ( v10 > (long double)*((float *)&unk_842DF24 + 93 * v5 + v11 + 91) )
        {
          v6 = *(_WORD *)&algn_8185DB0[24 * (unsigned __int16)a1 + 2];
          if ( v6 )
            goto LABEL_13;
          v6 = sub_805D8C4(a2, a3);
          if ( v6 )
          {
            *(_WORD *)&algn_8185DB0[24 * (unsigned __int16)a1 + 2] = v6;
            word_8185DAE[12 * v6] = a1;
            goto LABEL_13;
          }
        }
        goto LABEL_12;
      }
      v6 = *(_WORD *)&algn_8185DB0[24 * (unsigned __int16)a1];
      if ( v6 )
      {
LABEL_13:
        v5 = *((_WORD *)&unk_842DF26 + 186 * v5);
        sub_805DCC8(v13, v6);
        dword_8185DA0[6 * v6] |= *(_DWORD *)(sub_808FE68((int)v13) + 284);
        if ( v9 )
          *(_WORD *)(v9 + 2) = v5;
        else
          *((_WORD *)&unk_8185DA4 + 12 * (unsigned __int16)a1) = v5;
      }
      else
      {
        v6 = sub_805D8C4(a2, a3);
        if ( v6 )
        {
          *(_WORD *)&algn_8185DB0[24 * (unsigned __int16)a1] = v6;
          word_8185DAE[12 * v6] = a1;
          goto LABEL_13;
        }
LABEL_12:
        v9 = 372 * v5 + 138600228;
        v5 = *((_WORD *)&unk_842DF26 + 186 * v5);
      }
    }
    v8 = 0;
    result = *((unsigned __int16 *)&unk_8185DA6 + 12 * (unsigned __int16)a1);
    v4 = *((_WORD *)&unk_8185DA6 + 12 * (unsigned __int16)a1);
    while ( 1 )
    {
      if ( !v4 )
        return result;
      v12 = (unsigned __int16 *)(dword_8185BE8 + 80 * v4 - 80);
      if ( *(float *)&v12[2 * v11 + 28] <= (long double)v10 )
        break;
      v7 = *(_WORD *)&algn_8185DB0[24 * (unsigned __int16)a1];
      if ( v7 )
      {
LABEL_27:
        v4 = *v12;
        sub_805DD50(v12, v7);
        dword_8185D9C[6 * v7] |= sub_80C33CA(*((_DWORD *)v12 + 1));
        result = v4;
        if ( v8 )
          *v8 = v4;
        else
          *((_WORD *)&unk_8185DA6 + 12 * (unsigned __int16)a1) = v4;
      }
      else
      {
        v7 = sub_805D8C4(a2, a3);
        if ( v7 )
        {
          *(_WORD *)&algn_8185DB0[24 * (unsigned __int16)a1] = v7;
          word_8185DAE[12 * v7] = a1;
          goto LABEL_27;
        }
LABEL_26:
        v8 = v12;
        result = *v12;
        v4 = *v12;
      }
    }
    if ( v10 > (long double)*(float *)&v12[2 * v11 + 34] )
    {
      v7 = *(_WORD *)&algn_8185DB0[24 * (unsigned __int16)a1 + 2];
      if ( v7 )
        goto LABEL_27;
      v7 = sub_805D8C4(a2, a3);
      if ( v7 )
      {
        *(_WORD *)&algn_8185DB0[24 * (unsigned __int16)a1 + 2] = v7;
        word_8185DAE[12 * v7] = a1;
        goto LABEL_27;
      }
    }
    goto LABEL_26;
  }
  return result;
}
// 8185BE8: using guessed type int dword_8185BE8;
// 8185D98: using guessed type char byte_8185D98;
// 8185D9C: using guessed type int dword_8185D9C[];
// 8185DA0: using guessed type int dword_8185DA0[];
// 8185DAE: using guessed type __int16 word_8185DAE[];

//----- (0805E18C) --------------------------------------------------------
int __cdecl sub_805E18C(int a1, _DWORD *a2, _DWORD *a3, int a4)
{
  int v5; // [esp+1Ch] [ebp-2Ch]
  int v6; // [esp+20h] [ebp-28h]
  int v7; // [esp+24h] [ebp-24h]
  float v8[2]; // [esp+28h] [ebp-20h] BYREF
  float v9[3]; // [esp+30h] [ebp-18h] BYREF
  float v10; // [esp+3Ch] [ebp-Ch]
  int v11; // [esp+40h] [ebp-8h]
  unsigned __int16 i; // [esp+46h] [ebp-2h]

  v5 = CM_ClipHandleToModel(a4);
  v6 = *(_DWORD *)(v5 + 32) | *(_DWORD *)(v5 + 36);
  if ( !*(_QWORD *)(v5 + 32) )
    return sub_805DAA0((unsigned __int16 *)a1);
  while ( 1 )
  {
    sub_805F99C(flt_8185D80, v9);
    sub_805F99C(flt_8185D8C, v8);
    for ( i = 1; ; i = *(_WORD *)(v7 + 22) )
    {
      while ( 1 )
      {
        dword_8185DA0[6 * i] |= v6;
        v7 = 24 * i + 135814556;
        v11 = *((unsigned __int16 *)&unk_8185DAC + 12 * i);
        v10 = *((float *)&unk_8185DA8 + 6 * i);
        if ( *(float *)&a2[v11] <= (long double)v10 )
          break;
        v9[v11] = v10;
        if ( !*(_WORD *)(v7 + 20) )
          goto LABEL_13;
        i = *(_WORD *)(v7 + 20);
      }
      if ( v10 <= (long double)*(float *)&a3[v11] )
        break;
      v8[v11] = v10;
      if ( !*(_WORD *)(v7 + 22) )
        goto LABEL_13;
    }
    if ( i == *(_WORD *)a1 && (*(_DWORD *)(a1 + 352) & ~v6) == 0 )
    {
      *(_DWORD *)(a1 + 352) = v6;
      sub_805F99C(a2, (_DWORD *)(a1 + 356));
      return sub_805F99C(a3, (_DWORD *)(a1 + 364));
    }
LABEL_13:
    if ( !*(_WORD *)a1 )
      break;
    if ( i == *(_WORD *)a1 && (*(_DWORD *)(a1 + 352) & ~v6) == 0 )
      goto LABEL_18;
    sub_805DAA0((unsigned __int16 *)a1);
  }
  sub_805DCC8((unsigned __int16 *)a1, i);
LABEL_18:
  *(_DWORD *)(a1 + 352) = v6;
  sub_805F99C(a2, (_DWORD *)(a1 + 356));
  sub_805F99C(a3, (_DWORD *)(a1 + 364));
  return sub_805DDD0(i, v9, v8);
}
// 8185D80: using guessed type float flt_8185D80[3];
// 8185D8C: using guessed type float flt_8185D8C[3];
// 8185DA0: using guessed type int dword_8185DA0[];
// 805E18C: using guessed type float var_18[3];
// 805E18C: using guessed type float var_20[2];

//----- (0805E3D8) --------------------------------------------------------
int __cdecl sub_805E3D8(int a1)
{
  int v2; // [esp+14h] [ebp-24h]
  float v3[2]; // [esp+18h] [ebp-20h] BYREF
  float v4[2]; // [esp+20h] [ebp-18h] BYREF
  int v5; // [esp+28h] [ebp-10h]
  float v6; // [esp+2Ch] [ebp-Ch]
  int v7; // [esp+30h] [ebp-8h]
  unsigned __int16 i; // [esp+36h] [ebp-2h]

  v5 = sub_80C33CA(*(_DWORD *)(a1 + 4));
  sub_805F99C(flt_8185D80, v4);
  sub_805F99C(flt_8185D8C, v3);
  for ( i = 1; ; i = *(_WORD *)(v2 + 22) )
  {
    while ( 1 )
    {
      dword_8185D9C[6 * i] |= v5;
      v2 = 24 * i + 135814556;
      v7 = *((unsigned __int16 *)&unk_8185DAC + 12 * i);
      v6 = *((float *)&unk_8185DA8 + 6 * i);
      if ( *(float *)(a1 + 4 * v7 + 56) <= (long double)v6 )
        break;
      v4[v7] = v6;
      if ( !*(_WORD *)(v2 + 20) )
        goto LABEL_8;
      i = *(_WORD *)(v2 + 20);
    }
    if ( v6 <= (long double)*(float *)(a1 + 4 * v7 + 68) )
      break;
    v3[v7] = v6;
    if ( !*(_WORD *)(v2 + 22) )
      break;
  }
LABEL_8:
  sub_805DD50((_WORD *)a1, i);
  return sub_805DDD0(i, v4, v3);
}
// 8185D80: using guessed type float flt_8185D80[3];
// 8185D8C: using guessed type float flt_8185D8C[3];
// 8185D9C: using guessed type int dword_8185D9C[];
// 805E3D8: using guessed type float var_18[2];
// 805E3D8: using guessed type float var_20[2];

//----- (0805E51A) --------------------------------------------------------
int sub_805E51A()
{
  int result; // eax
  int v1; // [esp+10h] [ebp-8h]
  int i; // [esp+14h] [ebp-4h]

  v1 = 0;
  for ( i = dword_8185BE8; ; i += 80 )
  {
    result = v1;
    if ( v1 >= dword_8185BE4 )
      break;
    if ( sub_80C33CA(*(_DWORD *)(i + 4)) )
      sub_805E3D8(i);
    ++v1;
  }
  return result;
}
// 8185BE4: using guessed type int dword_8185BE4;
// 8185BE8: using guessed type int dword_8185BE8;

//----- (0805E56A) --------------------------------------------------------
void __cdecl sub_805E56A(unsigned __int16 a1, int a2)
{
  unsigned __int16 i; // [esp+1Ah] [ebp-Eh]
  int v3; // [esp+1Ch] [ebp-Ch]

  if ( (dword_8185DA0[6 * a1] & *(_DWORD *)(a2 + 24)) != 0 )
  {
    for ( i = *((_WORD *)&unk_8185DA4 + 12 * a1); i; i = *((_WORD *)&unk_842DF26 + 186 * i) )
    {
      v3 = sub_808FE68(372 * i + 138600228);
      if ( (*(_DWORD *)(v3 + 284) & *(_DWORD *)(a2 + 24)) != 0
        && *(float *)(v3 + 288) <= (long double)**(float **)(a2 + 8)
        && **(float **)(a2 + 4) <= (long double)*(float *)(v3 + 300)
        && *(float *)(v3 + 292) <= (long double)*(float *)(*(_DWORD *)(a2 + 8) + 4)
        && *(float *)(*(_DWORD *)(a2 + 4) + 4) <= (long double)*(float *)(v3 + 304)
        && *(float *)(v3 + 296) <= (long double)*(float *)(*(_DWORD *)(a2 + 8) + 8)
        && *(float *)(*(_DWORD *)(a2 + 4) + 8) <= (long double)*(float *)(v3 + 308) )
      {
        if ( *(_DWORD *)(a2 + 16) == *(_DWORD *)(a2 + 20) )
        {
          Com_DPrintf("CM_AreaEntities: MAXCOUNT\n");
          return;
        }
        *(_DWORD *)(*(_DWORD *)(a2 + 12) + 4 * (*(_DWORD *)(a2 + 16))++) = 1062196213
                                                                         * ((372 * i
                                                                           + 138600228
                                                                           + -(int)&dword_842BC80
                                                                           - 9240) >> 2);
      }
    }
    if ( *(float *)(*(_DWORD *)(a2 + 8) + 4 * *((unsigned __int16 *)&unk_8185DAC + 12 * a1)) > (long double)*((float *)&unk_8185DA8 + 6 * a1) )
      sub_805E56A(*(unsigned __int16 *)&algn_8185DB0[24 * a1], a2);
    if ( *((float *)&unk_8185DA8 + 6 * a1) > (long double)*(float *)(*(_DWORD *)(a2 + 4)
                                                                   + 4 * *((unsigned __int16 *)&unk_8185DAC + 12 * a1)) )
      sub_805E56A(*(unsigned __int16 *)&algn_8185DB0[24 * a1 + 2], a2);
  }
}
// 8185DA0: using guessed type int dword_8185DA0[];
// 842BC80: using guessed type int dword_842BC80;

//----- (0805E782) --------------------------------------------------------
int __cdecl sub_805E782(int a1, int a2, int a3, int a4, int a5)
{
  char v6[4]; // [esp+10h] [ebp-28h] BYREF
  int v7; // [esp+14h] [ebp-24h]
  int v8; // [esp+18h] [ebp-20h]
  int v9; // [esp+1Ch] [ebp-1Ch]
  int v10; // [esp+20h] [ebp-18h]
  int v11; // [esp+24h] [ebp-14h]
  int v12; // [esp+28h] [ebp-10h]

  v7 = a1;
  v8 = a2;
  v9 = a3;
  v10 = 0;
  v11 = a4;
  v12 = a5;
  sub_805E56A(1u, (int)v6);
  return v10;
}
// 805E782: using guessed type char var_28[4];

//----- (0805E7C6) --------------------------------------------------------
void __cdecl sub_805E7C6(int a1, unsigned __int16 a2, _DWORD *a3, float *a4, float *a5)
{
  int v5; // ebx
  float v6; // [esp+20h] [ebp-58h] BYREF
  float v7; // [esp+24h] [ebp-54h]
  float v8; // [esp+28h] [ebp-50h]
  float v9; // [esp+2Ch] [ebp-4Ch]
  int v10; // [esp+34h] [ebp-44h]
  unsigned __int16 i; // [esp+3Ah] [ebp-3Eh]
  int v12; // [esp+3Ch] [ebp-3Ch]
  float v13[7]; // [esp+40h] [ebp-38h] BYREF
  _BOOL4 v14; // [esp+5Ch] [ebp-1Ch]
  float v15; // [esp+60h] [ebp-18h]
  float v16; // [esp+64h] [ebp-14h]
  float v17; // [esp+68h] [ebp-10h]
  unsigned __int16 v18; // [esp+6Eh] [ebp-Ah]

  v18 = a2;
  sub_805FA18(a3, &v6);
  while ( 1 )
  {
    v10 = 24 * v18 + 135814556;
    if ( (dword_8185D9C[6 * v18] & *(_DWORD *)a1) == 0 )
      break;
    for ( i = *(_WORD *)(v10 + 10); i; i = *(_WORD *)v12 )
    {
      v12 = dword_8185BE8 + 80 * i - 80;
      if ( (*(_DWORD *)a1 & sub_80C33CA(*(_DWORD *)(v12 + 4))) != 0 && !sub_805D6DC(a1 + 4, v12 + 56, v12 + 68, *a5) )
        sub_8057F90(v12, (int)a5, (float *)(a1 + 4), (float *)(a1 + 16), *(_DWORD *)a1);
    }
    v17 = *(&v6 + *(unsigned __int16 *)(v10 + 16)) - *(float *)(v10 + 12);
    v16 = a4[*(unsigned __int16 *)(v10 + 16)] - *(float *)(v10 + 12);
    if ( v17 * v16 < 0.0 )
    {
      if ( v9 >= (long double)*a5 )
        return;
      v15 = v17 / (v17 - v16);
      v13[0] = (*a4 - v6) * v15 + v6;
      v13[1] = (a4[1] - v7) * v15 + v7;
      v13[2] = (a4[2] - v8) * v15 + v8;
      v13[3] = (a4[3] - v9) * v15 + v9;
      v14 = sub_805F93C(v16);
      sub_805E7C6(a1, *(unsigned __int16 *)(v10 + 2 * v14 + 20), &v6, v13, a5);
      v18 = *(_WORD *)(v10 + 2 * (1 - v14) + 20);
      sub_805FA18(v13, &v6);
    }
    else
    {
      v5 = v10;
      sub_805F978(v17, v16);
      v18 = *(_WORD *)(v5 + 2 * (1 - sub_805F93C(0.0)) + 20);
    }
  }
}
// 8185BE8: using guessed type int dword_8185BE8;
// 8185D9C: using guessed type int dword_8185D9C[];

//----- (0805EA28) --------------------------------------------------------
void __cdecl sub_805EA28(float *a1, _DWORD *a2, _DWORD *a3, int a4)
{
  float v4[4]; // [esp+20h] [ebp-58h] BYREF
  _DWORD v5[4]; // [esp+30h] [ebp-48h] BYREF
  int v6; // [esp+40h] [ebp-38h] BYREF
  _DWORD v7[3]; // [esp+44h] [ebp-34h] BYREF
  _DWORD v8[10]; // [esp+50h] [ebp-28h] BYREF

  v6 = a4;
  sub_805F9E8(a2, v7);
  sub_805F9E8(a3, v8);
  CM_CalcTraceExtents((int)v7);
  sub_805F9E8(v7, v5);
  v5[3] = 0;
  sub_805F9E8(v8, v4);
  v4[3] = *a1;
  sub_805E7C6((int)&v6, 1u, v5, v4, a1);
}

//----- (0805EAD0) --------------------------------------------------------
int __cdecl sub_805EAD0(int a1, unsigned __int16 a2, _DWORD *a3, float *a4)
{
  int v4; // ebx
  float v7; // [esp+20h] [ebp-58h] BYREF
  float v8; // [esp+24h] [ebp-54h]
  float v9; // [esp+28h] [ebp-50h]
  int v10; // [esp+34h] [ebp-44h]
  unsigned __int16 i; // [esp+3Ah] [ebp-3Eh]
  int v12; // [esp+3Ch] [ebp-3Ch]
  float v13[7]; // [esp+40h] [ebp-38h] BYREF
  _BOOL4 v14; // [esp+5Ch] [ebp-1Ch]
  float v15; // [esp+60h] [ebp-18h]
  float v16; // [esp+64h] [ebp-14h]
  float v17; // [esp+68h] [ebp-10h]
  unsigned __int16 v18; // [esp+6Eh] [ebp-Ah]

  v18 = a2;
  sub_805F9E8(a3, &v7);
  while ( 1 )
  {
    while ( 1 )
    {
      v10 = 24 * v18 + 135814556;
      if ( (dword_8185D9C[6 * v18] & *(_DWORD *)(a1 + 36)) == 0 )
        return 1;
      for ( i = *(_WORD *)(v10 + 10); i; i = *(_WORD *)v12 )
      {
        v12 = dword_8185BE8 + 80 * i - 80;
        if ( (*(_DWORD *)(a1 + 36) & sub_80C33CA(*(_DWORD *)(v12 + 4))) != 0
          && !sub_805D6DC(a1, v12 + 56, v12 + 68, 1.0)
          && !sub_805809A(v12, (float *)a1, (float *)(a1 + 12), *(_DWORD *)(a1 + 36)) )
        {
          return 0;
        }
      }
      v17 = *(&v7 + *(unsigned __int16 *)(v10 + 16)) - *(float *)(v10 + 12);
      v16 = a4[*(unsigned __int16 *)(v10 + 16)] - *(float *)(v10 + 12);
      if ( v17 * v16 < 0.0 )
        break;
      v4 = v10;
      sub_805F978(v17, v16);
      v18 = *(_WORD *)(v4 + 2 * (1 - sub_805F93C(0.0)) + 20);
    }
    v15 = v17 / (v17 - v16);
    v13[0] = (*a4 - v7) * v15 + v7;
    v13[1] = (a4[1] - v8) * v15 + v8;
    v13[2] = (a4[2] - v9) * v15 + v9;
    v14 = sub_805F93C(v16);
    if ( !sub_805EAD0(a1, *(unsigned __int16 *)(v10 + 2 * v14 + 20), &v7, v13) )
      break;
    v18 = *(_WORD *)(v10 + 2 * (1 - v14) + 20);
    sub_805F9E8(v13, &v7);
  }
  return 0;
}
// 8185BE8: using guessed type int dword_8185BE8;
// 8185D9C: using guessed type int dword_8185D9C[];

//----- (0805ED1E) --------------------------------------------------------
int __cdecl sub_805ED1E(_DWORD *a1, _DWORD *a2, float a3)
{
  _DWORD v4[3]; // [esp+20h] [ebp-38h] BYREF
  float v5[11]; // [esp+2Ch] [ebp-2Ch] BYREF

  v5[6] = a3;
  sub_805F9E8(a1, v4);
  sub_805F9E8(a2, v5);
  CM_CalcTraceExtents((int)v4);
  return sub_805EAD0((int)v4, 1u, v4, v5);
}
// 805ED1E: using guessed type _DWORD var_38[3];

//----- (0805ED88) --------------------------------------------------------
void __cdecl sub_805ED88(int a1, unsigned __int16 a2, _DWORD *a3, float *a4, float *a5)
{
  long double v5; // fst7
  long double v6; // fst6
  long double v7; // fst7
  long double v8; // fst7
  long double v9; // fst7
  float v10; // [esp+34h] [ebp-74h]
  float v11; // [esp+38h] [ebp-70h]
  float v12; // [esp+3Ch] [ebp-6Ch]
  float v13; // [esp+40h] [ebp-68h] BYREF
  float v14; // [esp+44h] [ebp-64h]
  float v15; // [esp+48h] [ebp-60h]
  float v16; // [esp+4Ch] [ebp-5Ch]
  int v17; // [esp+5Ch] [ebp-4Ch]
  unsigned __int16 i; // [esp+62h] [ebp-46h]
  float v19; // [esp+64h] [ebp-44h]
  float v20; // [esp+68h] [ebp-40h]
  int v21; // [esp+6Ch] [ebp-3Ch]
  float v22[6]; // [esp+70h] [ebp-38h] BYREF
  _BOOL4 v23; // [esp+88h] [ebp-20h]
  float v24; // [esp+8Ch] [ebp-1Ch]
  float v25; // [esp+90h] [ebp-18h]
  float v26; // [esp+94h] [ebp-14h]
  float v27; // [esp+98h] [ebp-10h]
  unsigned __int16 v28; // [esp+9Eh] [ebp-Ah]

  v28 = a2;
  sub_805FA18(a3, &v13);
  while ( 1 )
  {
    v17 = 24 * v28 + 135814556;
    if ( (dword_8185DA0[6 * v28] & *(_DWORD *)(a1 + 80)) == 0 )
      break;
    for ( i = *(_WORD *)(v17 + 8); i; i = *(_WORD *)(v21 + 2) )
    {
      v21 = 372 * i + 138600228;
      if ( (*(_DWORD *)(a1 + 80) & *((_DWORD *)&unk_842E084 + 93 * i)) != 0 )
        sub_809AB88(a1, v21, (int)a5);
    }
    v27 = *(&v13 + *(unsigned __int16 *)(v17 + 16)) - *(float *)(v17 + 12);
    v5 = a4[*(unsigned __int16 *)(v17 + 16)] - *(float *)(v17 + 12);
    v26 = v5;
    v20 = *(float *)(a1 + 4 * *(unsigned __int16 *)(v17 + 16) + 24);
    sub_805F978(v27, v26);
    v6 = v5;
    v7 = v20;
    if ( v6 < v20 )
    {
      sub_805F954(v27, v26);
      if ( -v20 < v7 )
      {
        if ( v16 >= (long double)*a5 )
          return;
        v12 = v26 - v27;
        v8 = 0.0;
        if ( v12 == 0.0 )
        {
          v23 = 0;
          v25 = 1.0;
          v24 = 0.0;
        }
        else
        {
          v11 = sub_805F922(v12);
          v10 = sub_805F8F8(v12, COERCE_FLOAT(LODWORD(v27) ^ 0x80000000), v27);
          v19 = 1.0 / v11;
          v24 = (v10 - v20) * v19;
          v8 = (v10 + v20) * v19;
          v25 = v8;
          v23 = sub_805F93C(v12);
        }
        sub_805F978(v25, 1.0);
        v25 = v8;
        v22[0] = (*a4 - v13) * v25 + v13;
        v22[1] = (a4[1] - v14) * v25 + v14;
        v22[2] = (a4[2] - v15) * v25 + v15;
        v9 = (a4[3] - v16) * v25 + v16;
        v22[3] = v9;
        sub_805ED88(a1, *(unsigned __int16 *)(v17 + 2 * v23 + 20), &v13, v22, a5);
        sub_805F954(v24, 0.0);
        v24 = v9;
        v13 = (*a4 - v13) * v24 + v13;
        v14 = (a4[1] - v14) * v24 + v14;
        v15 = (a4[2] - v15) * v24 + v15;
        v16 = (a4[3] - v16) * v24 + v16;
        v28 = *(_WORD *)(v17 + 2 * (1 - v23) + 20);
      }
      else
      {
        v28 = *(_WORD *)(v17 + 22);
      }
    }
    else
    {
      v28 = *(_WORD *)(v17 + 20);
    }
  }
}
// 8185DA0: using guessed type int dword_8185DA0[];

//----- (0805F0A4) --------------------------------------------------------
void __cdecl sub_805F0A4(int a1, float *a2)
{
  float v2[4]; // [esp+20h] [ebp-28h] BYREF
  _DWORD v3[6]; // [esp+30h] [ebp-18h] BYREF

  sub_805F9E8((_DWORD *)(a1 + 36), v3);
  sub_805F9E8((_DWORD *)(a1 + 48), v2);
  v3[3] = 0;
  v2[3] = *a2;
  sub_805ED88(a1, 1u, v3, v2, a2);
}

//----- (0805F10E) --------------------------------------------------------
int __cdecl sub_805F10E(_DWORD *a1, unsigned __int16 a2, _DWORD *a3, float *a4)
{
  long double v4; // fst7
  long double v5; // fst6
  long double v6; // fst7
  long double v7; // fst7
  long double v8; // fst7
  float v11; // [esp+24h] [ebp-74h]
  float v12; // [esp+28h] [ebp-70h]
  float v13; // [esp+2Ch] [ebp-6Ch]
  float v14; // [esp+30h] [ebp-68h] BYREF
  float v15; // [esp+34h] [ebp-64h]
  float v16; // [esp+38h] [ebp-60h]
  int v17; // [esp+48h] [ebp-50h]
  unsigned __int16 i; // [esp+4Eh] [ebp-4Ah]
  int v19; // [esp+50h] [ebp-48h]
  float v20; // [esp+54h] [ebp-44h]
  float v21; // [esp+58h] [ebp-40h]
  int v22; // [esp+5Ch] [ebp-3Ch]
  float v23[6]; // [esp+60h] [ebp-38h] BYREF
  _BOOL4 v24; // [esp+78h] [ebp-20h]
  float v25; // [esp+7Ch] [ebp-1Ch]
  float v26; // [esp+80h] [ebp-18h]
  float v27; // [esp+84h] [ebp-14h]
  float v28; // [esp+88h] [ebp-10h]
  unsigned __int16 v29; // [esp+8Eh] [ebp-Ah]

  v29 = a2;
  sub_805F9E8(a3, &v14);
  while ( 1 )
  {
    while ( 1 )
    {
      while ( 1 )
      {
        v17 = 24 * v29 + 135814556;
        if ( (dword_8185DA0[6 * v29] & a1[17]) == 0 )
          return 0;
        for ( i = *(_WORD *)(v17 + 8); i; i = *(_WORD *)(v22 + 2) )
        {
          v22 = 372 * i + 138600228;
          v19 = sub_809B1A0(a1, v22);
          if ( v19 )
            return v19;
        }
        v28 = *(&v14 + *(unsigned __int16 *)(v17 + 16)) - *(float *)(v17 + 12);
        v4 = a4[*(unsigned __int16 *)(v17 + 16)] - *(float *)(v17 + 12);
        v27 = v4;
        v21 = *(float *)&a1[*(unsigned __int16 *)(v17 + 16) + 6];
        sub_805F978(v28, v27);
        v5 = v4;
        v6 = v21;
        if ( v5 < v21 )
          break;
        v29 = *(_WORD *)(v17 + 20);
      }
      sub_805F954(v28, v27);
      if ( -v21 < v6 )
        break;
      v29 = *(_WORD *)(v17 + 22);
    }
    v13 = v27 - v28;
    v7 = 0.0;
    if ( v13 == 0.0 )
    {
      v24 = 0;
      v26 = 1.0;
      v25 = 0.0;
    }
    else
    {
      v12 = sub_805F922(v13);
      v11 = sub_805F8F8(v13, COERCE_FLOAT(LODWORD(v28) ^ 0x80000000), v28);
      v20 = 1.0 / v12;
      v25 = (v11 - v21) * v20;
      v7 = (v11 + v21) * v20;
      v26 = v7;
      v24 = sub_805F93C(v13);
    }
    sub_805F978(v26, 1.0);
    v26 = v7;
    v23[0] = (*a4 - v14) * v26 + v14;
    v23[1] = (a4[1] - v15) * v26 + v15;
    v8 = (a4[2] - v16) * v26 + v16;
    v23[2] = v8;
    v19 = sub_805F10E(a1, *(unsigned __int16 *)(v17 + 2 * v24 + 20), &v14, v23);
    if ( v19 )
      break;
    sub_805F954(v25, 0.0);
    v25 = v8;
    v14 = (*a4 - v14) * v25 + v14;
    v15 = (a4[1] - v15) * v25 + v15;
    v16 = (a4[2] - v16) * v25 + v16;
    v29 = *(_WORD *)(v17 + 2 * (1 - v24) + 20);
  }
  return v19;
}
// 8185DA0: using guessed type int dword_8185DA0[];

//----- (0805F3F6) --------------------------------------------------------
int __cdecl sub_805F3F6(int a1)
{
  return sub_805F10E((_DWORD *)a1, 1u, (_DWORD *)(a1 + 36), (float *)(a1 + 48));
}

//----- (0805F42C) --------------------------------------------------------
void __cdecl sub_805F42C(int a1, unsigned __int16 a2, _DWORD *a3, float *a4, float *a5)
{
  int v5; // ebx
  float v6; // [esp+20h] [ebp-58h] BYREF
  float v7; // [esp+24h] [ebp-54h]
  float v8; // [esp+28h] [ebp-50h]
  float v9; // [esp+2Ch] [ebp-4Ch]
  int v10; // [esp+34h] [ebp-44h]
  unsigned __int16 i; // [esp+3Ah] [ebp-3Eh]
  int v12; // [esp+3Ch] [ebp-3Ch]
  float v13[7]; // [esp+40h] [ebp-38h] BYREF
  _BOOL4 v14; // [esp+5Ch] [ebp-1Ch]
  float v15; // [esp+60h] [ebp-18h]
  float v16; // [esp+64h] [ebp-14h]
  float v17; // [esp+68h] [ebp-10h]
  unsigned __int16 v18; // [esp+6Eh] [ebp-Ah]

  v18 = a2;
  sub_805FA18(a3, &v6);
  while ( 1 )
  {
    v10 = 24 * v18 + 135814556;
    if ( (dword_8185DA0[6 * v18] & *(_DWORD *)(a1 + 44)) == 0 )
      break;
    for ( i = *(_WORD *)(v10 + 8); i; i = *(_WORD *)(v12 + 2) )
    {
      v12 = 372 * i + 138600228;
      sub_809AD2C(a1, v12, (int)a5);
    }
    v17 = *(&v6 + *(unsigned __int16 *)(v10 + 16)) - *(float *)(v10 + 12);
    v16 = a4[*(unsigned __int16 *)(v10 + 16)] - *(float *)(v10 + 12);
    if ( v17 * v16 < 0.0 )
    {
      if ( v9 >= (long double)*a5 )
        return;
      v15 = v17 / (v17 - v16);
      v13[0] = (*a4 - v6) * v15 + v6;
      v13[1] = (a4[1] - v7) * v15 + v7;
      v13[2] = (a4[2] - v8) * v15 + v8;
      v13[3] = (a4[3] - v9) * v15 + v9;
      v14 = sub_805F93C(v16);
      sub_805F42C(a1, *(unsigned __int16 *)(v10 + 2 * v14 + 20), &v6, v13, a5);
      v18 = *(_WORD *)(v10 + 2 * (1 - v14) + 20);
      sub_805FA18(v13, &v6);
    }
    else
    {
      v5 = v10;
      sub_805F978(v17, v16);
      v18 = *(_WORD *)(v5 + 2 * (1 - sub_805F93C(0.0)) + 20);
    }
  }
}
// 8185DA0: using guessed type int dword_8185DA0[];

//----- (0805F61E) --------------------------------------------------------
void __cdecl sub_805F61E(_DWORD *a1, float *a2)
{
  float v2[4]; // [esp+20h] [ebp-28h] BYREF
  _DWORD v3[6]; // [esp+30h] [ebp-18h] BYREF

  sub_805F9E8(a1, v3);
  sub_805F9E8(a1 + 3, v2);
  v3[3] = 0;
  v2[3] = *a2;
  sub_805F42C((int)a1, 1u, v3, v2, a2);
}

//----- (0805F686) --------------------------------------------------------
int __cdecl sub_805F686(_DWORD *a1, unsigned __int16 a2, float *a3, float *a4)
{
  _BOOL4 v4; // eax
  int v7; // [esp+26h] [ebp-42h]
  int v8; // [esp+28h] [ebp-40h]
  int v9; // [esp+28h] [ebp-40h]
  int v10; // [esp+28h] [ebp-40h]
  int v11; // [esp+28h] [ebp-40h]
  float v12[7]; // [esp+30h] [ebp-38h] BYREF
  _BOOL4 v13; // [esp+4Ch] [ebp-1Ch]
  float v14; // [esp+50h] [ebp-18h]
  float v15; // [esp+54h] [ebp-14h]
  float v16; // [esp+58h] [ebp-10h]
  unsigned __int16 v17; // [esp+5Eh] [ebp-Ah]

  v17 = a2;
  if ( (dword_8185DA0[6 * a2] & a1[8]) == 0 )
    return 0;
  v16 = a3[*((unsigned __int16 *)&unk_8185DAC + 12 * a2)] - *((float *)&unk_8185DA8 + 6 * a2);
  v15 = a4[*((unsigned __int16 *)&unk_8185DAC + 12 * a2)] - *((float *)&unk_8185DA8 + 6 * a2);
  if ( v16 * v15 < 0.0 )
  {
    v14 = v16 / (v16 - v15);
    v12[0] = (*a4 - *a3) * v14 + *a3;
    v12[1] = (a4[1] - a3[1]) * v14 + a3[1];
    v12[2] = (a4[2] - a3[2]) * v14 + a3[2];
    v13 = sub_805F93C(v15);
    v9 = sub_805F686(a1, *((unsigned __int16 *)&dword_8185D9C[6 * a2 + 5] + v13), a3, v12);
    if ( v9 )
      return v9;
    v10 = sub_805F686(a1, *((unsigned __int16 *)&dword_8185D9C[6 * a2 + 5] + 1 - v13), v12, a4);
    if ( v10 )
      return v10;
  }
  else
  {
    sub_805F978(v16, v15);
    v4 = sub_805F93C(0.0);
    v8 = sub_805F686(a1, *((unsigned __int16 *)&dword_8185D9C[6 * a2 + 5] + 1 - v4), a3, a4);
    if ( v8 )
      return v8;
  }
  LOWORD(v7) = *((_WORD *)&unk_8185DA4 + 12 * a2);
  while ( (_WORD)v7 )
  {
    v11 = sub_809B30E(a1, 372 * (unsigned __int16)v7 + 138600228);
    if ( v11 )
      return v11;
    v7 = *((unsigned __int16 *)&unk_842DF26 + 186 * (unsigned __int16)v7);
  }
  return 0;
}
// 8185D9C: using guessed type int dword_8185D9C[];
// 8185DA0: using guessed type int dword_8185DA0[];

//----- (0805F8C6) --------------------------------------------------------
int __cdecl sub_805F8C6(int a1)
{
  return sub_805F686((_DWORD *)a1, 1u, (float *)a1, (float *)(a1 + 12));
}

//----- (0805F8F8) --------------------------------------------------------
long double __cdecl sub_805F8F8(float a1, float a2, float a3)
{
  if ( a1 < 0.0 )
    return a3;
  return a2;
}

//----- (0805F922) --------------------------------------------------------
long double __cdecl sub_805F922(float a1)
{
  return (float)fabs(a1);
}

//----- (0805F93C) --------------------------------------------------------
_BOOL4 __cdecl sub_805F93C(float a1)
{
  return a1 >= 0.0;
}

//----- (0805F954) --------------------------------------------------------
void __cdecl sub_805F954(float a1, float a2)
{
  float v2; // [esp+0h] [ebp-18h]

  v2 = a1 - a2;
  sub_805F8F8(v2, a1, a2);
}

//----- (0805F978) --------------------------------------------------------
void __cdecl sub_805F978(float a1, float a2)
{
  float v2; // [esp+0h] [ebp-18h]

  v2 = a2 - a1;
  sub_805F8F8(v2, a1, a2);
}

//----- (0805F99C) --------------------------------------------------------
int __cdecl sub_805F99C(_DWORD *a1, _DWORD *a2)
{
  int result; // eax

  *a2 = *a1;
  result = a1[1];
  a2[1] = result;
  return result;
}

//----- (0805F9BC) --------------------------------------------------------
float *__cdecl sub_805F9BC(float *a1, float *a2, float *a3)
{
  float *result; // eax

  *a3 = *a1 - *a2;
  result = a1 + 1;
  a3[1] = a1[1] - a2[1];
  return result;
}

//----- (0805F9E8) --------------------------------------------------------
int __cdecl sub_805F9E8(_DWORD *a1, _DWORD *a2)
{
  int result; // eax

  *a2 = *a1;
  a2[1] = a1[1];
  result = a1[2];
  a2[2] = result;
  return result;
}

//----- (0805FA18) --------------------------------------------------------
int __cdecl sub_805FA18(_DWORD *a1, _DWORD *a2)
{
  int result; // eax

  *a2 = *a1;
  a2[1] = a1[1];
  a2[2] = a1[2];
  result = a1[3];
  a2[3] = result;
  return result;
}

//----- (0805FA5E) --------------------------------------------------------
int Cmd_Wait_f()
{
  int result; // eax
  char *v1; // eax

  result = Cmd_Argc();
  if ( result == 2 )
  {
    v1 = Cmd_Argv(1u);
    result = atoi(v1);
    dword_818BE00 = result;
  }
  else
  {
    dword_818BE00 = 1;
  }
  return result;
}
// 818BE00: using guessed type int dword_818BE00;

//----- (0805FA96) --------------------------------------------------------
int *Cbuf_Init()
{
  int *result; // eax
  int i; // [esp+0h] [ebp-4h] BYREF

  for ( i = 0; i <= 0; ++i )
  {
    dword_818BE04[3 * i] = (int)&unk_818BE80 + 0x10000 * i;
    dword_818BE08[3 * i] = 0x10000;
    dword_818BE0C[3 * i] = 0;
    result = &i;
  }
  return result;
}
// 818BE04: using guessed type int dword_818BE04[];
// 818BE08: using guessed type int dword_818BE08[];
// 818BE0C: using guessed type int dword_818BE0C[];

//----- (0805FB06) --------------------------------------------------------
void __cdecl Cbuf_AddText(char *s)
{
  size_t n; // [esp+14h] [ebp-4h]

  n = strlen(s);
  if ( (signed int)(n + *(_DWORD *)(off_815A3DC + 8)) < *(_DWORD *)(off_815A3DC + 4) )
  {
    memcpy((void *)(*(_DWORD *)off_815A3DC + *(_DWORD *)(off_815A3DC + 8)), s, n);
    *(_DWORD *)(off_815A3DC + 8) += n;
  }
  else
  {
    Com_Printf("Cbuf_AddText: overflow\n");
  }
}
// 815A3DC: using guessed type int off_815A3DC;

//----- (0805FB7E) --------------------------------------------------------
void __cdecl Cbuf_InsertText(char *s)
{
  int i; // [esp+10h] [ebp-8h]
  size_t v2; // [esp+14h] [ebp-4h]

  v2 = strlen(s) + 1;
  if ( (signed int)(*(_DWORD *)(off_815A3DC + 8) + v2) <= *(_DWORD *)(off_815A3DC + 4) )
  {
    for ( i = *(_DWORD *)(off_815A3DC + 8) - 1; i >= 0; --i )
      *(_BYTE *)(*(_DWORD *)off_815A3DC + i + v2) = *(_BYTE *)(*(_DWORD *)off_815A3DC + i);
    memcpy(*(void **)off_815A3DC, s, v2 - 1);
    *(_BYTE *)(*(_DWORD *)off_815A3DC + v2 - 1) = 10;
    *(_DWORD *)(off_815A3DC + 8) += v2;
  }
  else
  {
    Com_Printf("Cbuf_InsertText overflowed\n");
  }
}
// 815A3DC: using guessed type int off_815A3DC;

//----- (0805FC38) --------------------------------------------------------
void __cdecl Cbuf_ExecuteText(int a1, char *s)
{
  if ( a1 == 1 )
  {
    Cbuf_InsertText(s);
  }
  else if ( a1 > 1 )
  {
    if ( a1 != 2 )
LABEL_13:
      Com_Error(0, (char *)&byte_813BB60);
    Cbuf_AddText(s);
  }
  else
  {
    if ( a1 )
      goto LABEL_13;
    if ( s && *s )
      Cmd_ExecuteString(s);
    else
      Cbuf_Execute();
  }
}
// 805FDFC: using guessed type int Cbuf_Execute(void);
// 80606A2: using guessed type _DWORD __cdecl Cmd_ExecuteString(_DWORD);

//----- (0805FCB2) --------------------------------------------------------
int __usercall Cbuf_ExecuteInternal@<eax>(long double a1@<st0>)
{
  int result; // eax
  unsigned __int8 v2; // [esp+1Ch] [ebp-101Ch]
  char dest[4104]; // [esp+20h] [ebp-1018h] BYREF
  void *src; // [esp+1028h] [ebp-10h]
  size_t n; // [esp+102Ch] [ebp-Ch]

  while ( 1 )
  {
    result = off_815A3DC;
    if ( !*(_DWORD *)(off_815A3DC + 8) )
      break;
    if ( dword_818BE00 )
    {
      --dword_818BE00;
      return result;
    }
    src = *(void **)off_815A3DC;
    v2 = 0;
    for ( n = 0; (signed int)n < *(_DWORD *)(off_815A3DC + 8); ++n )
    {
      if ( *((_BYTE *)src + n) == 34 )
        ++v2;
      if ( ((v2 ^ 1) & 1) != 0 && *((_BYTE *)src + n) == 59 || *((_BYTE *)src + n) == 10 || *((_BYTE *)src + n) == 13 )
        break;
    }
    if ( (int)n > 4094 )
      n = 4095;
    memcpy(dest, src, n);
    dest[n] = 0;
    if ( n == *(_DWORD *)(off_815A3DC + 8) )
    {
      *(_DWORD *)(off_815A3DC + 8) = 0;
    }
    else
    {
      *(_DWORD *)(off_815A3DC + 8) -= ++n;
      memmove(src, (char *)src + n, *(_DWORD *)(off_815A3DC + 8));
    }
    Cmd_ExecuteString(a1, dest);
  }
  return result;
}
// 815A3DC: using guessed type int off_815A3DC;
// 818BE00: using guessed type int dword_818BE00;
// 805FCB2: using guessed type char dest[4104];

//----- (0805FDFC) --------------------------------------------------------
int __usercall Cbuf_Execute@<eax>(long double a1@<st0>)
{
  return Cbuf_ExecuteInternal(a1);
}

//----- (0805FE0A) --------------------------------------------------------
int __cdecl Cmd_ExecFromDisk(const char *a1)
{
  char *s; // [esp+14h] [ebp-4h] BYREF

  FS_ReadFile(a1, &s);
  if ( !s )
    return 0;
  Com_Printf("execing %s\n", a1);
  Cbuf_InsertText(s);
  FS_FreeFile(s);
  return 1;
}

//----- (0805FE66) --------------------------------------------------------
void Cmd_Exec_f()
{
  char *v0; // eax
  char *v1; // eax
  char dest[72]; // [esp+10h] [ebp-48h] BYREF

  if ( Cmd_Argc() == 2 )
  {
    v0 = Cmd_Argv(1u);
    I_strncpyz(dest, v0, 64);
    Com_DefaultExtension(dest, 0x40u, ".cfg");
    if ( !(unsigned __int8)Cmd_ExecFromDisk(dest) )
    {
      v1 = Cmd_Argv(1u);
      Com_Printf("couldn't exec %s\n", v1);
    }
  }
  else
  {
    Com_Printf("exec <filename> : execute a script file\n");
  }
}

//----- (0805FEF2) --------------------------------------------------------
void Cmd_Vstr_f()
{
  char *v0; // eax
  char *v1; // [esp+10h] [ebp-8h]
  int v2; // [esp+14h] [ebp-4h]

  if ( Cmd_Argc() == 2 )
  {
    v1 = Cmd_Argv(1u);
    v2 = Dvar_FindVar(v1);
    if ( v2 )
    {
      if ( *(_BYTE *)(v2 + 6) == 7 || *(_BYTE *)(v2 + 6) == 6 )
      {
        v0 = va("%s\n", *(const char **)(v2 + 8));
        Cbuf_InsertText(v0);
      }
      else
      {
        Com_Printf("%s is not a string-based dvar\n", *(const char **)v2);
      }
    }
    else
    {
      Com_Printf("%s doesn't exist\n", v1);
    }
  }
  else
  {
    Com_Printf("vstr <variablename> : execute a variable command\n");
  }
}

//----- (0805FF92) --------------------------------------------------------
void sub_805FF92()
{
  char *v0; // eax
  int i; // [esp+14h] [ebp-4h]

  for ( i = 1; i < Cmd_Argc(); ++i )
  {
    v0 = Cmd_Argv(i);
    Com_Printf("^3%s ", v0);
  }
  Com_Printf("\n");
}

//----- (0805FFDC) --------------------------------------------------------
int Cmd_Argc()
{
  return dword_819BE80;
}
// 819BE80: using guessed type int dword_819BE80;

//----- (0805FFE6) --------------------------------------------------------
int SV_Cmd_Argc()
{
  return dword_819BE80;
}
// 819BE80: using guessed type int dword_819BE80;

//----- (0805FFF0) --------------------------------------------------------
char *__cdecl Cmd_Argv(unsigned int a1)
{
  if ( a1 < dword_819BE80 )
    return (&dword_819BF00)[a1];
  else
    return (char *)&unk_813BC6B;
}
// 819BE80: using guessed type int dword_819BE80;

//----- (0806001C) --------------------------------------------------------
char *__cdecl SV_Cmd_Argv(unsigned int a1)
{
  if ( a1 < dword_819BE80 )
    return (&dword_819BF00)[a1];
  else
    return (char *)&unk_813BC6B;
}
// 819BE80: using guessed type int dword_819BE80;

//----- (08060048) --------------------------------------------------------
char *__cdecl Cmd_ArgvBuffer(int a1, char *dest, int a3)
{
  char *v3; // eax

  v3 = Cmd_Argv(a1);
  return I_strncpyz(dest, v3, a3);
}

//----- (08060074) --------------------------------------------------------
char *__cdecl SV_Cmd_ArgvBuffer(int a1, char *dest, int a3)
{
  char *v3; // eax

  v3 = SV_Cmd_Argv(a1);
  return I_strncpyz(dest, v3, a3);
}

//----- (080600A0) --------------------------------------------------------
char *__cdecl Cmd_Args(int a1)
{
  byte_819E980 = 0;
  while ( a1 < dword_819BE80 )
  {
    I_strncat(&byte_819E980, 1024, (&dword_819BF00)[a1]);
    if ( a1 != dword_819BE80 - 1 )
      I_strncat(&byte_819E980, 1024, " ");
    ++a1;
  }
  return &byte_819E980;
}
// 819BE80: using guessed type int dword_819BE80;

//----- (08060118) --------------------------------------------------------
char *__cdecl sub_8060118(char *dest, int a2)
{
  char *v2; // eax

  v2 = Cmd_Args(1);
  return I_strncpyz(dest, v2, a2);
}

//----- (08060142) --------------------------------------------------------
int __cdecl Cmd_TokenizeStringInternal(char *a1, int a2, int a3, char *a4)
{
  char *v4; // edx
  char *v5; // edx
  char *v6; // edx
  int v9; // [esp+4h] [ebp-8h]
  int v10; // [esp+4h] [ebp-8h]
  char *i; // [esp+8h] [ebp-4h]

  v9 = 0;
  while ( 1 )
  {
    if ( v9 == 512 )
      return 0;
    if ( !--a2 )
      break;
    while ( 1 )
    {
      while ( *a1 && *a1 <= 32 )
        ++a1;
      if ( !*a1 )
        return v9;
      if ( *a1 == 47 && a1[1] == 47 )
        return v9;
      if ( *a1 != 47 || a1[1] != 42 )
        break;
      while ( *a1 && (*a1 != 42 || a1[1] != 47) )
        ++a1;
      if ( !*a1 )
        return v9;
      a1 += 2;
    }
    if ( *a1 == 34 )
    {
      *(_DWORD *)(a3 + 4 * v9++) = a4;
      for ( i = a1 + 1; *i && *i != 34; ++i )
      {
        if ( *i == 92 && i[1] == 34 )
          ++i;
        v4 = i;
        *a4++ = *v4;
      }
      *a4++ = 0;
      if ( !*i )
        return v9;
      a1 = i + 1;
      if ( !*a1 )
        return v9;
      if ( *a1 <= 32 )
        ++a1;
    }
    else
    {
      *(_DWORD *)(a3 + 4 * v9++) = a4;
      while ( *a1 > 32 && *a1 != 34 && (*a1 != 47 || a1[1] != 47) && (*a1 != 47 || a1[1] != 42) )
      {
        v5 = a1++;
        *a4++ = *v5;
      }
      *a4++ = 0;
      if ( !*a1 )
        return v9;
      if ( *a1 <= 32 )
        ++a1;
    }
  }
  if ( !*a1 )
    return v9;
  *(_DWORD *)(a3 + 4 * v9) = a4;
  v10 = v9 + 1;
  while ( *a1 )
  {
    v6 = a1++;
    *a4++ = *v6;
  }
  *a4 = 0;
  return v10;
}

//----- (080603CC) --------------------------------------------------------
int __cdecl Cmd_TokenizeStringWithLimit(char *a1, int a2)
{
  int result; // eax

  result = Cmd_TokenizeStringInternal(a1, a2, (int)&dword_819BF00, byte_819C700);
  dword_819BE80 = result;
  return result;
}
// 819BE80: using guessed type int dword_819BE80;

//----- (080603FC) --------------------------------------------------------
int __cdecl SV_Cmd_TokenizeStringWithLimit(char *a1, int a2)
{
  int result; // eax

  result = Cmd_TokenizeStringInternal(a1, a2, (int)&dword_819BF00, byte_819C700);
  dword_819BE80 = result;
  return result;
}
// 819BE80: using guessed type int dword_819BE80;

//----- (0806042C) --------------------------------------------------------
int __cdecl Cmd_TokenizeString(char *a1)
{
  return Cmd_TokenizeStringWithLimit(a1, 0);
}

//----- (08060448) --------------------------------------------------------
int __cdecl SV_Cmd_TokenizeString(char *a1)
{
  return SV_Cmd_TokenizeStringWithLimit(a1, 0);
}

//----- (08060464) --------------------------------------------------------
int __cdecl Cmd_FindCommand(char *s1)
{
  int i; // [esp+14h] [ebp-4h]

  for ( i = dword_819E900; i; i = *(_DWORD *)i )
  {
    if ( !strcmp(s1, *(const char **)(i + 4)) )
      return i;
  }
  return 0;
}
// 819E900: using guessed type int dword_819E900;

//----- (080604B2) --------------------------------------------------------
void __cdecl Cmd_AddCommand(char *s1, int a2)
{
  _DWORD *v2; // ebx

  if ( Cmd_FindCommand(s1) )
  {
    if ( a2 )
      Com_Printf("Cmd_AddCommand: %s already defined\n", s1);
  }
  else
  {
    v2 = Z_MallocInternal(0x14u);
    v2[1] = CopyStringInternal(s1);
    v2[4] = a2;
    *v2 = dword_819E900;
    dword_819E900 = (int)v2;
  }
}
// 819E900: using guessed type int dword_819E900;

//----- (0806052A) --------------------------------------------------------
void __cdecl Cmd_RemoveCommand(char *s1)
{
  const char ***i; // [esp+10h] [ebp-8h]
  const char **ptr; // [esp+14h] [ebp-4h]

  for ( i = (const char ***)&dword_819E900; ; i = (const char ***)ptr )
  {
    ptr = *i;
    if ( !*i )
      break;
    if ( !strcmp(s1, ptr[1]) )
    {
      *i = (const char **)*ptr;
      if ( ptr[1] )
        Z_FreeInternal((void *)ptr[1]);
      Z_FreeInternal(ptr);
      return;
    }
  }
}
// 819E900: using guessed type int dword_819E900;

//----- (08060598) --------------------------------------------------------
int __cdecl Cmd_SetAutoComplete(char *s1, int a2, int a3)
{
  int v3; // eax
  int v4; // edx
  int result; // eax

  v3 = Cmd_FindCommand(s1);
  *(_DWORD *)(v3 + 8) = a2;
  v4 = v3;
  result = a3;
  *(_DWORD *)(v4 + 12) = a3;
  return result;
}

//----- (080605C0) --------------------------------------------------------
void Cmd_Shutdown()
{
  void **ptr; // [esp+4h] [ebp-4h]

  while ( dword_819E900 )
  {
    ptr = (void **)dword_819E900;
    dword_819E900 = *(_DWORD *)dword_819E900;
    Z_FreeInternal(ptr[1]);
    Z_FreeInternal(ptr);
  }
}
// 819E900: using guessed type int dword_819E900;

//----- (08060604) --------------------------------------------------------
int __cdecl sub_8060604(void (__cdecl *a1)(int))
{
  int result; // eax
  int *i; // [esp+4h] [ebp-4h]

  result = dword_819E900;
  for ( i = (int *)dword_819E900; i; i = (int *)*i )
  {
    a1(i[1]);
    result = *i;
  }
  return result;
}
// 819E900: using guessed type int dword_819E900;

//----- (08060634) --------------------------------------------------------
_DWORD *__cdecl sub_8060634(char *s1, int *a2)
{
  int v4; // [esp+24h] [ebp-4h]

  *a2 = 0;
  v4 = Cmd_FindCommand(s1);
  if ( *(_DWORD *)(v4 + 8) && *(_DWORD *)(v4 + 12) )
    return FS_ListFiles(*(_DWORD *)(v4 + 8), *(char **)(v4 + 12), 0, a2);
  else
    return 0;
}

//----- (080606A2) --------------------------------------------------------
int __usercall Cmd_ExecuteString@<eax>(long double a1@<st0>, char *a2)
{
  int result; // eax
  int *i; // [esp+10h] [ebp-8h]
  int v4; // [esp+14h] [ebp-4h]

  Cmd_TokenizeString(a2);
  result = Cmd_Argc();
  if ( result )
  {
    for ( i = &dword_819E900; *i; i = (int *)v4 )
    {
      v4 = *i;
      if ( !I_stricmp(dword_819BF00, *(char **)(*i + 4)) )
      {
        *i = *(_DWORD *)v4;
        *(_DWORD *)v4 = dword_819E900;
        dword_819E900 = v4;
        if ( *(_DWORD *)(v4 + 16) )
          return (*(int (**)(void))(v4 + 16))();
        break;
      }
    }
    result = Dvar_Command(a1);
    if ( !result && com_sv_running )
    {
      result = com_sv_running;
      if ( *(_BYTE *)(com_sv_running + 8) )
        return SV_GameCommand();
    }
  }
  return result;
}
// 819E900: using guessed type int dword_819E900;
// 819EF14: using guessed type int com_sv_running;

//----- (08060754) --------------------------------------------------------
int __usercall SV_Cmd_ExecuteString@<eax>(long double a1@<st0>, char *a2)
{
  return Cmd_ExecuteString(a1, a2);
}

//----- (08060768) --------------------------------------------------------
void Cmd_List_f()
{
  char *v0; // [esp+Ch] [ebp-Ch]
  int v1; // [esp+10h] [ebp-8h]
  int i; // [esp+14h] [ebp-4h]

  if ( Cmd_Argc() <= 1 )
    v0 = 0;
  else
    v0 = Cmd_Argv(1u);
  v1 = 0;
  for ( i = dword_819E900; i; i = *(_DWORD *)i )
  {
    if ( !v0 || (unsigned __int8)Com_Filter(v0, *(char **)(i + 4), 0) )
    {
      Com_Printf("%s\n", *(const char **)(i + 4));
      ++v1;
    }
  }
  Com_Printf("%i commands\n", v1);
}
// 819E900: using guessed type int dword_819E900;

//----- (0806080A) --------------------------------------------------------
void Cmd_Init()
{
  Cmd_AddCommand("cmdlist", (int)Cmd_List_f);
  Cmd_AddCommand("exec", (int)Cmd_Exec_f);
  Cmd_AddCommand("vstr", (int)Cmd_Vstr_f);
  Cmd_AddCommand("wait", (int)Cmd_Wait_f);
}

//----- (08060864) --------------------------------------------------------
size_t __cdecl FS_FileRead(void *ptr, size_t size, size_t n, FILE *stream)
{
  return fread(ptr, size, n, stream);
}

//----- (08060892) --------------------------------------------------------
size_t __cdecl FS_FileWrite(void *ptr, size_t size, size_t n, FILE *s)
{
  return fwrite(ptr, size, n, s);
}

//----- (080608BA) --------------------------------------------------------
FILE *__cdecl FS_FileOpen(char *filename, char *modes)
{
  return fopen(filename, modes);
}

//----- (080608DA) --------------------------------------------------------
int __cdecl FS_FileClose(FILE *stream)
{
  return fclose(stream);
}

//----- (080608EE) --------------------------------------------------------
int __cdecl FS_FileSeek(FILE *stream, int off, int whence)
{
  return fseek(stream, off, whence);
}

//----- (08060918) --------------------------------------------------------
int Hunk_ClearTempMemoryHigh()
{
  return 0;
}

//----- (08060924) --------------------------------------------------------
void sub_8060924()
{
  ;
}

//----- (0806092A) --------------------------------------------------------
char *__cdecl Com_BeginRedirect(char *a1, int a2, int a3)
{
  char *result; // eax

  if ( a1 && a2 )
  {
    if ( a3 )
    {
      dword_81A1C94 = a1;
      dword_81A1C98 = a2;
      dword_81A1C9C = a3;
      result = a1;
      *a1 = 0;
    }
  }
  return result;
}
// 81A1C9C: using guessed type int dword_81A1C9C;

//----- (08060964) --------------------------------------------------------
int Com_EndRedirect()
{
  int result; // eax

  if ( dword_81A1C9C )
    result = dword_81A1C9C(dword_81A1C94);
  dword_81A1C94 = 0;
  dword_81A1C98 = 0;
  dword_81A1C9C = 0;
  return result;
}
// 81A1C9C: invalid function type has been ignored
// 81A1C9C: using guessed type int (__cdecl *dword_81A1C9C)(_DWORD);

//----- (080609A2) --------------------------------------------------------
void CL_SwitchToLocalClient()
{
  ;
}

//----- (080609A8) --------------------------------------------------------
void __cdecl Com_PrintMessage(int a1, char *s)
{
  size_t v2; // ebx
  char v3; // al
  size_t v4; // eax
  time_t timer; // [esp+Ch] [ebp-Ch] BYREF
  struct tm *tp; // [esp+10h] [ebp-8h]

  if ( dword_81A1C94 )
  {
    if ( a1 != 4 )
    {
      v2 = strlen(s);
      if ( strlen(dword_81A1C94) + v2 > dword_81A1C98 - 1 )
      {
        dword_81A1C9C(dword_81A1C94);
        *dword_81A1C94 = 0;
      }
      I_strncat(dword_81A1C94, dword_81A1C98, s);
    }
  }
  else
  {
    if ( *s == 94 && s[1] )
      s += 2;
    if ( a1 != 4 )
      sub_80D24F4(s);
    if ( com_logfile && *(_DWORD *)(com_logfile + 8) && FS_Initialized() )
    {
      if ( !logfile && !dword_81A1CA0 )
      {
        dword_81A1CA0 = 1;
        time(&timer);
        tp = localtime(&timer);
        logfile = FS_FOpenTextFileWrite("console_mp_server.log");
        v3 = (unsigned __int8)asctime(tp);
        Com_Printf("logfile opened on %s\n", v3);
        dword_81A1CA0 = 0;
      }
      if ( logfile )
      {
        v4 = strlen(s);
        FS_Write(s, v4, logfile);
        if ( *(int *)(com_logfile + 8) > 1 )
          FS_Flush(logfile);
      }
    }
  }
}
// 819EEF4: using guessed type int logfile;
// 819EF18: using guessed type int com_logfile;
// 81A1C9C: using guessed type int (__cdecl *dword_81A1C9C)(_DWORD);
// 81A1CA0: using guessed type int dword_81A1CA0;

//----- (08060B2C) --------------------------------------------------------
void Com_Printf(char *format, ...)
{
  char s[4108]; // [esp+10h] [ebp-1018h] BYREF
  __gnuc_va_list __varargs; // [esp+101Ch] [ebp-Ch]
  va_list va; // [esp+1034h] [ebp+Ch] BYREF

  va_start(va, format);
  va_copy(__varargs, va);
  vsnprintf(s, 0x1000u, format, va);
  s[4095] = 0;
  Com_PrintMessage(0, s);
}

//----- (08060B7C) --------------------------------------------------------
void Com_DPrintf(char *format, ...)
{
  char s[4108]; // [esp+10h] [ebp-1018h] BYREF
  __gnuc_va_list __varargs; // [esp+101Ch] [ebp-Ch]
  va_list va; // [esp+1034h] [ebp+Ch] BYREF

  va_start(va, format);
  if ( com_developer )
  {
    if ( *(_DWORD *)(com_developer + 8) )
    {
      va_copy(__varargs, va);
      vsnprintf(s, 0x1000u, format, va);
      s[4095] = 0;
      Com_Printf("%s", s);
    }
  }
}
// 819EEFC: using guessed type int com_developer;

//----- (08060BE2) --------------------------------------------------------
void *__usercall Com_ShutdownInternal@<eax>(long double a1@<st0>, const char *a2)
{
  SV_Shutdown(a1, a2);
  return Com_Restart(a1);
}

//----- (08060BFA) --------------------------------------------------------
void *__usercall Com_Shutdown@<eax>(long double a1@<st0>, const char *a2)
{
  return Com_ShutdownInternal(a1, a2);
}

//----- (08060C0E) --------------------------------------------------------
int Hunk_ClearTempMemory()
{
  Hunk_ClearTempMemoryInternal();
  return Hunk_ClearTempMemoryHighInternal();
}

//----- (08060C2E) --------------------------------------------------------
int __cdecl sub_8060C2E(char *s2)
{
  int i; // [esp+14h] [ebp-4h]

  for ( i = 0; *(&off_815A3E0)[i]; ++i )
  {
    if ( !strcasecmp((&off_815A3E0)[i], s2) )
      return 1;
  }
  return 0;
}

//----- (08060C86) --------------------------------------------------------
void __usercall Com_SetErrorMessage(long double a1@<st0>, char *src)
{
  ui_errorMessage = (int)Dvar_RegisterString(a1, "com_errorMessage", (char *)&unk_813BDA4, 4160);
  ui_errorTitle = (int)Dvar_RegisterString(a1, "com_errorTitle", (char *)&unk_813BDA4, 4160);
  Dvar_SetString(ui_errorMessage, src);
}
// 819FF84: using guessed type int ui_errorTitle;

//----- (08060CE4) --------------------------------------------------------
void *__usercall Com_ErrorCleanup@<eax>(long double a1@<st0>)
{
  void *result; // eax
  char dest[4108]; // [esp+10h] [ebp-1018h] BYREF
  int v3; // [esp+101Ch] [ebp-Ch]

  LargeLocalReset();
  Dvar_SetInAutoExec(0);
  Hunk_ClearTempMemory();
  Hunk_ClearTempMemoryHigh();
  Dvar_SetIntByName(a1, "cl_paused", 0);
  FS_PureServerSetLoadedIwds((char *)&unk_813BDA4, (char *)&unk_813BDA4);
  strcpy(dest, com_errorMessage);
  if ( com_errorType != 3 )
    Com_SetErrorMessage(a1, com_errorMessage);
  if ( com_errorType != 3 )
    Scr_Abort();
  Com_CleanupBsp();
  CM_Cleanup();
  Com_ResetParseSessions();
  FS_ResetFiles();
  if ( com_errorType == 1 )
    Cbuf_Init();
  v3 = Sys_MilliSeconds();
  if ( v3 - currentTime > 99 )
  {
    errorCount = 0;
  }
  else if ( ++errorCount > 3 )
  {
    com_errorType = 0;
  }
  currentTime = v3;
  if ( com_errorType != 2 && com_errorType != 1 && com_errorType != 3 )
    Sys_Error("%s", com_errorMessage);
  if ( com_errorType == 2 )
  {
    result = Com_ShutdownInternal(a1, "EXE_DISCONNECTEDFROMOWNLISTENSERVER");
  }
  else
  {
    Com_Printf("********************\nERROR: %s\n********************\n", com_errorMessage);
    result = Com_ShutdownInternal(a1, dest);
    if ( com_errorType == 1 )
    {
      result = (void *)QuitOnError();
      if ( (_BYTE)result )
        Com_Quit_f(a1);
    }
  }
  com_fixedConsolePosition = 0;
  com_errorEntered = 0;
  return result;
}
// 819EEEC: using guessed type int com_errorType;
// 819EF50: using guessed type int com_errorEntered;
// 819EF54: using guessed type int com_fixedConsolePosition;
// 81A1CA8: using guessed type int currentTime;
// 81A1CAC: using guessed type int errorCount;

//----- (08060E66) --------------------------------------------------------
void __noreturn Com_Error(int a1, char *format, ...)
{
  struct __jmp_buf_tag *v2; // eax
  va_list va; // [esp+28h] [ebp+10h] BYREF

  va_start(va, format);
  if ( com_errorEntered )
    Sys_Error("recursive error after: %s", com_errorMessage);
  com_errorEntered = 1;
  vsnprintf(com_errorMessage, 0x1000u, format, va);
  byte_819FF7F = 0;
  if ( a1 == 4 || a1 == 6 )
  {
    a1 = 1;
  }
  else if ( a1 == 5 )
  {
    a1 = 1;
  }
  else
  {
    com_fixedConsolePosition = 0;
  }
  com_errorType = a1;
  v2 = (struct __jmp_buf_tag *)Sys_GetValue(2);
  longjmp(v2, -1);
}
// 819EEEC: using guessed type int com_errorType;
// 819EF50: using guessed type int com_errorEntered;
// 819EF54: using guessed type int com_fixedConsolePosition;
// 819FF7F: using guessed type char byte_819FF7F;

//----- (08060F48) --------------------------------------------------------
void __usercall __noreturn Com_Quit_f(long double a1@<st0>)
{
  int v1; // [esp+0h] [ebp-8h]

  Com_Printf("quitting...\n");
  if ( !com_errorEntered )
  {
    Hunk_ClearTempMemory();
    SV_Shutdown(a1, "EXE_SERVERQUIT");
    Com_Close();
    Com_CloseLogFile();
    v1 = 1;
    FS_Shutdown();
    FS_ShutdownServerIwdNames();
    FS_ShutdownServerReferencedIwds();
  }
  Sys_Quit(v1);
}
// 8060F94: variable 'v1' is possibly undefined
// 80D148E: using guessed type void __cdecl __noreturn Sys_Quit(_DWORD);
// 819EF50: using guessed type int com_errorEntered;

//----- (08060F9C) --------------------------------------------------------
char *__cdecl Com_ParseCommandLine(char *a1)
{
  char *result; // eax

  dword_81A1CC0 = a1;
  dword_81A1CB0 = 1;
  while ( 1 )
  {
    result = a1;
    if ( !*a1 )
      break;
    result = a1;
    if ( *a1 == 43 || (result = a1, *a1 == 10) )
    {
      if ( dword_81A1CB0 == 32 )
        return result;
      (&dword_81A1CC0)[dword_81A1CB0++] = a1 + 1;
      *a1 = 0;
    }
    ++a1;
  }
  return result;
}
// 81A1CB0: using guessed type int dword_81A1CB0;

//----- (08060FFC) --------------------------------------------------------
int Com_SafeMode()
{
  char *v0; // eax
  char *v1; // eax
  int i; // [esp+14h] [ebp-4h]

  for ( i = 0; i < dword_81A1CB0; ++i )
  {
    Cmd_TokenizeString((&dword_81A1CC0)[i]);
    v0 = Cmd_Argv(0);
    if ( I_stricmp(v0, "safe") )
    {
      v1 = Cmd_Argv(0);
      if ( I_stricmp(v1, "dvar_restart") )
        continue;
    }
    *(&dword_81A1CC0)[i] = 0;
    return 1;
  }
  return dword_81A1C88;
}
// 81A1C88: using guessed type int dword_81A1C88;
// 81A1CB0: using guessed type int dword_81A1CB0;

//----- (080610A2) --------------------------------------------------------
int __usercall Com_StartupVariable@<eax>(long double a1@<st0>, char *s2)
{
  int result; // eax
  char *v3; // eax
  char *v4; // eax
  char *v5; // eax
  int i; // [esp+14h] [ebp-4h]

  for ( i = 0; ; ++i )
  {
    result = i;
    if ( i >= dword_81A1CB0 )
      break;
    Cmd_TokenizeString((&dword_81A1CC0)[i]);
    if ( s2 )
    {
      v3 = Cmd_Argv(1u);
      if ( strcmp(v3, s2) )
        continue;
    }
    v4 = Cmd_Argv(0);
    if ( !strcasecmp(v4, "set") )
    {
      Dvar_Set_f(a1);
    }
    else
    {
      v5 = Cmd_Argv(0);
      if ( !strcasecmp(v5, "seta") )
        Dvar_SetA_f(a1);
    }
  }
  return result;
}
// 81A1CB0: using guessed type int dword_81A1CB0;

//----- (08061150) --------------------------------------------------------
int Com_AddStartupCommands()
{
  int v1; // [esp+10h] [ebp-8h]
  int i; // [esp+14h] [ebp-4h]

  v1 = 0;
  for ( i = 0; i < dword_81A1CB0; ++i )
  {
    if ( (&dword_81A1CC0)[i] && *(&dword_81A1CC0)[i] )
    {
      if ( sub_80B550A((&dword_81A1CC0)[i], "set", 3) )
        v1 = 1;
      Cbuf_AddText((&dword_81A1CC0)[i]);
      Cbuf_AddText("\n");
    }
  }
  return v1;
}
// 81A1CB0: using guessed type int dword_81A1CB0;

//----- (080611E6) --------------------------------------------------------
void __cdecl Info_Print(char *a1)
{
  char *v1; // eax
  char *v2; // eax
  char *s; // [esp+1Ch] [ebp-40Ch]
  char *sa; // [esp+1Ch] [ebp-40Ch]
  char v5[512]; // [esp+20h] [ebp-408h] BYREF
  char v6[520]; // [esp+220h] [ebp-208h] BYREF

  if ( *a1 == 92 )
    ++a1;
  while ( *a1 )
  {
    s = v6;
    while ( *a1 && *a1 != 92 )
    {
      v1 = a1++;
      *s++ = *v1;
    }
    if ( s - v6 > 19 )
    {
      *s = 0;
    }
    else
    {
      memset(s, 32, 20 - (s - v6));
      v6[20] = 0;
    }
    Com_Printf("%s", v6);
    if ( !*a1 )
    {
      Com_Printf("MISSING VALUE\n");
      return;
    }
    sa = v5;
    ++a1;
    while ( *a1 && *a1 != 92 )
    {
      v2 = a1++;
      *sa++ = *v2;
    }
    *sa = 0;
    if ( *a1 )
      ++a1;
    Com_Printf("%s\n", v5);
  }
}

//----- (08061334) --------------------------------------------------------
void *Com_InitPushEvent()
{
  void *result; // eax

  result = memset(&dword_81A0000, 0, 0x1800u);
  dword_819FF88 = 0;
  dword_819FF8C = 0;
  return result;
}
// 819FF88: using guessed type int dword_819FF88;
// 819FF8C: using guessed type int dword_819FF8C;
// 81A0000: using guessed type int dword_81A0000;

//----- (0806136C) --------------------------------------------------------
int __cdecl Com_PushEvent(int *a1)
{
  int result; // eax
  int *v2; // [esp+4h] [ebp-4h]

  v2 = &dword_81A0000[6 * (unsigned __int8)dword_819FF88];
  if ( dword_819FF88 - dword_819FF8C <= 255 )
  {
    dword_81A1D40 = 0;
  }
  else
  {
    if ( !dword_81A1D40 )
    {
      dword_81A1D40 = 1;
      Com_Printf("WARNING: Com_PushEvent overflow\n");
    }
    if ( v2[5] )
      Z_FreeInternal((void *)v2[5]);
    ++dword_819FF8C;
  }
  *v2 = *a1;
  v2[1] = a1[1];
  v2[2] = a1[2];
  v2[3] = a1[3];
  v2[4] = a1[4];
  result = a1[5];
  v2[5] = result;
  ++dword_819FF88;
  return result;
}
// 819FF88: using guessed type int dword_819FF88;
// 819FF8C: using guessed type int dword_819FF8C;
// 81A0000: using guessed type int dword_81A0000[];
// 81A1D40: using guessed type int dword_81A1D40;

//----- (0806141C) --------------------------------------------------------
int sub_806141C()
{
  int result; // eax
  void *ptr; // [esp+24h] [ebp-14h]

  while ( 1 )
  {
    result = dword_819FF88;
    if ( dword_819FF88 <= dword_819FF8C )
      break;
    ptr = (void *)dword_81A0014[6 * (unsigned __int8)dword_819FF8C++];
    if ( ptr )
      Z_FreeInternal(ptr);
  }
  return result;
}
// 819FF88: using guessed type int dword_819FF88;
// 819FF8C: using guessed type int dword_819FF8C;
// 81A0014: using guessed type int dword_81A0014[1821];

//----- (08061498) --------------------------------------------------------
_DWORD *__stdcall Com_GetEvent(_DWORD *a1)
{
  int v1; // edx

  if ( dword_819FF88 <= dword_819FF8C )
  {
    Sys_GetEvent(a1);
  }
  else
  {
    v1 = 6 * (unsigned __int8)dword_819FF8C++;
    *a1 = dword_81A0000[v1];
    a1[1] = dword_81A0004[v1];
    a1[2] = dword_81A0008[v1];
    a1[3] = dword_81A000C[v1];
    a1[4] = dword_81A0010[v1];
    a1[5] = dword_81A0014[v1];
  }
  return a1;
}
// 819FF88: using guessed type int dword_819FF88;
// 819FF8C: using guessed type int dword_819FF8C;
// 81A0000: using guessed type int dword_81A0000[];
// 81A0004: using guessed type int dword_81A0004[];
// 81A0008: using guessed type int dword_81A0008[];
// 81A000C: using guessed type int dword_81A000C[];
// 81A0010: using guessed type int dword_81A0010[];
// 81A0014: using guessed type int dword_81A0014[];

//----- (08061526) --------------------------------------------------------
int __usercall Com_EventLoop@<eax>(long double a1@<st0>)
{
  int v1; // ebx
  int v3; // [esp+30h] [ebp-A8h] BYREF
  int v4; // [esp+34h] [ebp-A4h]
  int v5; // [esp+38h] [ebp-A0h]
  int v6; // [esp+3Ch] [ebp-9Ch]
  int v7; // [esp+40h] [ebp-98h]
  void *v8; // [esp+44h] [ebp-94h]
  char v9[4]; // [esp+5Ch] [ebp-7Ch]
  int v10[4]; // [esp+60h] [ebp-78h] BYREF
  void *s; // [esp+70h] [ebp-68h] BYREF
  void *v12; // [esp+74h] [ebp-64h]
  void *v13; // [esp+78h] [ebp-60h]
  void *v14; // [esp+7Ch] [ebp-5Ch]
  void *v15; // [esp+80h] [ebp-58h]
  int v16[3]; // [esp+90h] [ebp-48h] BYREF
  size_t n; // [esp+9Ch] [ebp-3Ch]
  int v18; // [esp+B0h] [ebp-28h]
  char v19[4]; // [esp+B4h] [ebp-24h]
  int v20; // [esp+B8h] [ebp-20h]
  int v21; // [esp+BCh] [ebp-1Ch]
  int v22; // [esp+C0h] [ebp-18h]
  void *ptr; // [esp+C4h] [ebp-14h]

  LargeLocal(v10, 0x4000);
  *(_DWORD *)v9 = LargeLocalGetBuf(v10);
  MSG_Init(v16, *(int *)v9, 0x4000);
  while ( 1 )
  {
    while ( 1 )
    {
      Com_GetEvent(&v3);
      v18 = v3;
      *(_DWORD *)v19 = v4;
      v20 = v5;
      v21 = v6;
      v22 = v7;
      ptr = v8;
      if ( v4 != 4 )
        break;
      CL_SwitchToLocalClient();
      Cbuf_AddText((char *)ptr);
      Z_FreeInternal(ptr);
      Cbuf_AddText("\n");
    }
    if ( v4 <= 4 )
      break;
    if ( v4 != 5 )
      goto LABEL_7;
    s = *(void **)ptr;
    v12 = (void *)*((_DWORD *)ptr + 1);
    v13 = (void *)*((_DWORD *)ptr + 2);
    v14 = (void *)*((_DWORD *)ptr + 3);
    v15 = (void *)*((_DWORD *)ptr + 4);
    n = v22 - 20;
    if ( (unsigned int)(v22 - 20) <= v16[2] )
    {
      memcpy((void *)v16[1], (char *)ptr + 20, n);
      Z_FreeInternal(ptr);
      if ( *(_BYTE *)(com_sv_running + 8) )
      {
        CL_SwitchToLocalClient();
        SV_PacketEvent(a1, s, v12, v13, v14, v15, v16);
      }
    }
    else
    {
      Z_FreeInternal(ptr);
      Com_Printf("Com_EventLoop: oversize packet\n");
    }
  }
  if ( v4 )
LABEL_7:
    Com_Error(0, (char *)&byte_813BF00, *(_DWORD *)v19);
  while ( NET_GetLoopPacket(1, &s, (int)v16) )
  {
    CL_SwitchToLocalClient();
    if ( *(_BYTE *)(com_sv_running + 8) )
      SV_PacketEvent(a1, s, v12, v13, v14, v15, v16);
  }
  v1 = v18;
  LargeLocalDealloc(v10);
  return v1;
}
// 819EF14: using guessed type int com_sv_running;
// 8061526: using guessed type int var_78[4];

//----- (080617B4) --------------------------------------------------------
int sub_80617B4()
{
  int v1; // [esp+20h] [ebp-58h] BYREF
  int v2; // [esp+24h] [ebp-54h]
  int v3; // [esp+28h] [ebp-50h]
  int v4; // [esp+2Ch] [ebp-4Ch]
  int v5; // [esp+30h] [ebp-48h]
  void *v6; // [esp+34h] [ebp-44h]
  int i; // [esp+4Ch] [ebp-2Ch]
  int v8; // [esp+50h] [ebp-28h]
  char v9[4]; // [esp+54h] [ebp-24h]
  int v10; // [esp+58h] [ebp-20h]
  int v11; // [esp+5Ch] [ebp-1Ch]
  int v12; // [esp+60h] [ebp-18h]
  void *ptr; // [esp+64h] [ebp-14h]

  for ( i = 0; ; i = 1 )
  {
    Com_GetEvent(&v1);
    v8 = v1;
    *(_DWORD *)v9 = v2;
    v10 = v3;
    v11 = v4;
    v12 = v5;
    ptr = v6;
    if ( v2 == 4 )
    {
      Cbuf_AddText((char *)ptr);
      Z_FreeInternal(ptr);
      Cbuf_AddText("\n");
      continue;
    }
    if ( v2 <= 4 )
      break;
    if ( v2 != 5 )
      goto LABEL_7;
    Z_FreeInternal(ptr);
  }
  if ( v2 )
LABEL_7:
    Com_Error(0, (char *)&byte_813BF00, *(_DWORD *)v9);
  return i;
}

//----- (08061878) --------------------------------------------------------
int Com_Milliseconds()
{
  int v1; // [esp+10h] [ebp-48h] BYREF
  int v2; // [esp+14h] [ebp-44h]
  int v3; // [esp+18h] [ebp-40h]
  int v4; // [esp+1Ch] [ebp-3Ch]
  int v5; // [esp+20h] [ebp-38h]
  int v6; // [esp+24h] [ebp-34h]
  int v7; // [esp+30h] [ebp-28h] BYREF
  int v8; // [esp+34h] [ebp-24h]
  int v9; // [esp+38h] [ebp-20h]
  int v10; // [esp+3Ch] [ebp-1Ch]
  int v11; // [esp+40h] [ebp-18h]
  int v12; // [esp+44h] [ebp-14h]

  do
  {
    Sys_GetEvent(&v1);
    v7 = v1;
    v8 = v2;
    v9 = v3;
    v10 = v4;
    v11 = v5;
    v12 = v6;
    if ( v2 )
      Com_PushEvent(&v7);
  }
  while ( v8 );
  return v7;
}

//----- (080618CE) --------------------------------------------------------
int sub_80618CE()
{
  int result; // eax
  int v1; // [esp+10h] [ebp-48h] BYREF
  int v2; // [esp+14h] [ebp-44h]
  int v3; // [esp+18h] [ebp-40h]
  int v4; // [esp+1Ch] [ebp-3Ch]
  int v5; // [esp+20h] [ebp-38h]
  int v6; // [esp+24h] [ebp-34h]
  int v7[10]; // [esp+30h] [ebp-28h] BYREF

  while ( 1 )
  {
    Sys_GetEvent(&v1);
    v7[0] = v1;
    v7[1] = v2;
    v7[2] = v3;
    v7[3] = v4;
    v7[4] = v5;
    result = v6;
    v7[5] = v6;
    if ( !v2 )
      break;
    Com_PushEvent(v7);
  }
  return result;
}

//----- (0806191E) --------------------------------------------------------
void __noreturn Com_Error_f()
{
  if ( Cmd_Argc() > 1 )
    Com_Error(1, (char *)&byte_813BF60);
  Com_Error(0, (char *)&byte_813BF74);
}

//----- (0806195A) --------------------------------------------------------
void Com_Freeze_f()
{
  char *v0; // eax
  int v1; // [esp+10h] [ebp-8h]
  float v2; // [esp+14h] [ebp-4h]

  if ( Cmd_Argc() == 2 )
  {
    v0 = Cmd_Argv(1u);
    v2 = atof(v0);
    v1 = Com_Milliseconds();
    while ( (long double)(Com_Milliseconds() - v1) * 0.001 <= v2 )
      ;
  }
  else
  {
    Com_Printf("freeze <seconds>\n");
  }
}

//----- (080619C8) --------------------------------------------------------
void Com_Crash_f()
{
  MEMORY[0] = 305419896;
}

//----- (080619D8) --------------------------------------------------------
bool Scr_Settings()
{
  int v1; // [esp+Ch] [ebp-Ch]

  v1 = 0;
  if ( *(_DWORD *)(com_developer + 8) || *(_DWORD *)(com_logfile + 8) )
    v1 = 1;
  return sub_807F988(v1, *(unsigned __int8 *)(com_developer_script + 8), *(_DWORD *)(com_developer + 8));
}
// 819EEFC: using guessed type int com_developer;
// 819EF00: using guessed type int com_developer_script;
// 819EF18: using guessed type int com_logfile;

//----- (08061A36) --------------------------------------------------------
void Com_SetCinematic()
{
  if ( !*(_DWORD *)(com_dedicated + 8) && !*(_BYTE *)(com_introPlayed + 8) )
  {
    Cbuf_AddText("cinematic atvi\n");
    Dvar_SetString(nextmap, "cinematic IW_logo; set nextmap cinematic cod_intro");
    Dvar_SetBool(com_introPlayed, 1);
  }
}
// 819EF24: using guessed type int com_introPlayed;
// 8494204: using guessed type int com_dedicated;

//----- (08061A8E) --------------------------------------------------------
void __usercall Com_InitDvars(long double a1@<st0>)
{
  com_dedicated = (int)Dvar_RegisterInt(a1, "dedicated", (char *)2, 0, 2, 4160);
  com_maxfps = (int)Dvar_RegisterInt(a1, "com_maxfps", (char *)0x55, 0, 1000, 4097);
  com_developer = (int)Dvar_RegisterInt(a1, "developer", 0, 0, 2, 4096);
  com_developer_script = (int)Dvar_RegisterBool(a1, "developer_script", 0, 4096);
  com_logfile = (int)Dvar_RegisterInt(a1, "logfile", 0, 0, 2, 4096);
  com_timescale = (int)Dvar_RegisterFloat(a1, "timescale", (char *)0x3F800000, 981668463, 1148846080, 4232);
  com_fixedtime = (int)Dvar_RegisterInt(a1, "fixedtime", 0, 0, 1000, 4224);
  com_viewlog = (int)Dvar_RegisterInt(a1, "viewlog", 0, 0, 2, 4224);
  sv_paused = (int)Dvar_RegisterInt(a1, "sv_paused", 0, 0, 2, 4160);
  cl_paused = (int)Dvar_RegisterInt(a1, "cl_paused", 0, 0, 2, 4160);
  com_sv_running = (int)Dvar_RegisterBool(a1, "sv_running", 0, 4160);
  *((_DWORD *)off_815A498 + 1) = 0;
  com_introPlayed = (int)Dvar_RegisterBool(a1, "com_introPlayed", 0, 4097);
  com_animCheck = (int)Dvar_RegisterBool(a1, "com_animCheck", 0, 4096);
  if ( *(_DWORD *)(com_dedicated + 8) )
  {
    if ( !*(_DWORD *)(com_viewlog + 8) )
      Dvar_SetInt(com_viewlog, (char *)1);
  }
}
// 815A498: using guessed type void *off_815A498;
// 819EEF8: using guessed type int com_viewlog;
// 819EEFC: using guessed type int com_developer;
// 819EF00: using guessed type int com_developer_script;
// 819EF04: using guessed type int com_timescale;
// 819EF0C: using guessed type int com_fixedtime;
// 819EF10: using guessed type int com_maxfps;
// 819EF14: using guessed type int com_sv_running;
// 819EF18: using guessed type int com_logfile;
// 819EF24: using guessed type int com_introPlayed;
// 819EF28: using guessed type int cl_paused;
// 819EF34: using guessed type int sv_paused;
// 819EF3C: using guessed type int com_animCheck;
// 8494204: using guessed type int com_dedicated;

//----- (08061D0E) --------------------------------------------------------
int __usercall Com_RunAutoExec@<eax>(long double a1@<st0>)
{
  Dvar_SetInAutoExec(1u);
  Cbuf_Execute(a1);
  return Dvar_SetInAutoExec(0);
}

//----- (08061D34) --------------------------------------------------------
int __usercall Com_ExecStartupConfigs@<eax>(long double a1@<st0>, const char *a2)
{
  char *v2; // eax

  Cbuf_AddText("exec default_mp.cfg\n");
  Cbuf_AddText("exec language.cfg\n");
  if ( a2 )
  {
    v2 = va("exec %s\n", a2);
    Cbuf_AddText(v2);
  }
  Cbuf_Execute(a1);
  Com_RunAutoExec(a1);
  if ( Com_SafeMode() )
    Cbuf_AddText("exec safemode_mp_server.cfg\n");
  return Cbuf_Execute(a1);
}

//----- (08061D9A) --------------------------------------------------------
int __usercall Com_InitPlayerProfiles@<eax>(long double a1@<st0>)
{
  return Com_ExecStartupConfigs(a1, "config_mp_server.cfg");
}

//----- (08061DAE) --------------------------------------------------------
void __usercall Com_Init_Try_Block_Function(long double a1@<st0>, char *a2)
{
  char *v2; // eax
  unsigned __int16 v3; // ax
  int i; // [esp+20h] [ebp-8h]
  char *src; // [esp+24h] [ebp-4h]

  Com_Printf("%s %s build %s %s\n", "CoD2 MP", "1.0", "linux-i386", "Oct 24 2005");
  Com_InitPushEvent();
  Com_ParseCommandLine(a2);
  Swap_Init();
  Cbuf_Init();
  Cmd_Init();
  Com_StartupVariable(a1, 0);
  Com_StartupVariable(a1, "developer");
  FS_InitFilesystem(a1);
  Com_InitDvars(a1);
  for ( i = 0; i <= 0; ++i )
  {
    CL_SwitchToLocalClient();
    Com_InitPlayerProfiles(a1);
  }
  CL_SwitchToLocalClient();
  Cbuf_Execute(a1);
  sub_806283E();
  Com_StartupVariable(a1, 0);
  Com_InitHunkMemory(a1);
  dvar_modifiedFlags &= ~1u;
  com_codeTimeScale = 1065353216;
  if ( *(_DWORD *)(com_developer + 8) )
  {
    Cmd_AddCommand("error", (int)Com_Error_f);
    Cmd_AddCommand("crash", (int)Com_Crash_f);
    Cmd_AddCommand("freeze", (int)Com_Freeze_f);
  }
  Cmd_AddCommand("quit", (int)Com_Quit_f);
  Cmd_AddCommand("writeconfig", (int)Com_WriteConfig_f);
  Cmd_AddCommand("writedefaults", (int)Com_WriteDefaults_f);
  v2 = getBuildNumber();
  src = va("%s %s build %s %s", "CoD2 MP", "1.0", v2, "linux-i386");
  version = (int)Dvar_RegisterString(a1, "version", (char *)&unk_813BDA4, 4160);
  Dvar_SetString(version, src);
  shortversion = (int)Dvar_RegisterString(a1, "shortversion", "1.0", 4164);
  FxMem_Init();
  Sys_Init(a1);
  v3 = Com_Milliseconds();
  Netchan_Init(a1, v3);
  Scr_Init();
  Scr_Settings();
  XAnimInit();
  DObjInit();
  SV_Init(a1);
  NET_Init(a1);
  com_frameTime = Com_Milliseconds();
  Com_AddStartupCommands();
  Com_SetCinematic();
  com_fullyInitialized = 1;
  Com_Printf("--- Common Initialization Complete ---\n");
  Cbuf_Execute(a1);
  if ( !*(_BYTE *)(com_sv_running + 8) )
    sub_80624CC();
}
// 819EEFC: using guessed type int com_developer;
// 819EF14: using guessed type int com_sv_running;
// 819EF20: using guessed type int shortversion;
// 819EF40: using guessed type int com_frameTime;
// 819EF48: using guessed type int com_codeTimeScale;
// 819EF58: using guessed type int com_fullyInitialized;
// 85178A8: using guessed type int dvar_modifiedFlags;

//----- (08062004) --------------------------------------------------------
void __usercall Com_Init(long double a1@<st0>, char *a2)
{
  struct __jmp_buf_tag *v2; // eax
  char *v3; // eax

  v2 = (struct __jmp_buf_tag *)Sys_GetValue(2);
  if ( __sigsetjmp(v2, 0) )
  {
    v3 = va("Error during initialization:\n%s\n", com_errorMessage);
    Sys_Error(v3);
  }
  Com_Init_Try_Block_Function(a1, a2);
}

//----- (0806205E) --------------------------------------------------------
void __cdecl Com_WriteConfigToFile(char *src)
{
  int v1; // [esp+14h] [ebp-4h]

  v1 = FS_FOpenFileWrite(src);
  if ( v1 )
  {
    FS_Printf(v1, "// generated by Call of Duty, do not modify\n");
    Dvar_WriteVariables(v1);
    FS_FCloseFile(v1);
  }
  else
  {
    Com_Printf("Couldn't write %s.\n", src);
  }
}

//----- (080620B8) --------------------------------------------------------
void __cdecl Com_WriteDefaultConfigToFile(char *src)
{
  int v1; // [esp+14h] [ebp-4h]

  v1 = FS_FOpenFileWrite(src);
  if ( v1 )
  {
    FS_Printf(v1, "// generated by Call of Duty, do not modify\n");
    Dvar_WriteDefaults(v1);
    FS_FCloseFile(v1);
  }
  else
  {
    Com_Printf("Couldn't write %s.\n", src);
  }
}

//----- (08062112) --------------------------------------------------------
void Com_WriteConfiguration()
{
  char dest[72]; // [esp+10h] [ebp-48h] BYREF

  if ( com_fullyInitialized )
  {
    if ( (((unsigned __int8)dvar_modifiedFlags ^ 1) & 1) == 0 )
    {
      dvar_modifiedFlags &= ~1u;
      I_strncpyz(dest, "config_mp_server.cfg", 64);
      Com_WriteConfigToFile(dest);
    }
  }
}
// 819EF58: using guessed type int com_fullyInitialized;
// 85178A8: using guessed type int dvar_modifiedFlags;

//----- (08062164) --------------------------------------------------------
void Com_WriteConfig_f()
{
  char *v0; // eax
  char dest[72]; // [esp+10h] [ebp-48h] BYREF

  if ( Cmd_Argc() == 2 )
  {
    v0 = Cmd_Argv(1u);
    I_strncpyz(dest, v0, 64);
    Com_DefaultExtension(dest, 0x40u, ".cfg");
    Com_Printf("Writing %s.\n", dest);
    Com_WriteConfigToFile(dest);
  }
  else
  {
    Com_Printf("Usage: writeconfig <filename>\n");
  }
}

//----- (080621E0) --------------------------------------------------------
void Com_WriteDefaults_f()
{
  char *v0; // eax
  char dest[72]; // [esp+10h] [ebp-48h] BYREF

  if ( Cmd_Argc() == 2 )
  {
    v0 = Cmd_Argv(1u);
    I_strncpyz(dest, v0, 64);
    Com_DefaultExtension(dest, 0x40u, ".cfg");
    Com_Printf("Writing %s.\n", dest);
    Com_WriteDefaultConfigToFile(dest);
  }
  else
  {
    Com_Printf("Usage: writedefaults <filename>\n");
  }
}

//----- (0806228A) --------------------------------------------------------
int __cdecl Com_ModifyMsec(int a1)
{
  float v2; // [esp+0h] [ebp-18h]
  float v3; // [esp+8h] [ebp-10h]
  float v4; // [esp+8h] [ebp-10h]
  int v5; // [esp+Ch] [ebp-Ch]
  char v6; // [esp+13h] [ebp-5h]
  int v7; // [esp+14h] [ebp-4h]

  v5 = a1;
  if ( *(_DWORD *)(com_fixedtime + 8) )
  {
    a1 = *(_DWORD *)(com_fixedtime + 8);
    v6 = 1;
  }
  else if ( *(float *)(com_timescale + 8) == 1.0 && *(float *)&com_codeTimeScale == 1.0 )
  {
    v6 = 0;
  }
  else
  {
    v2 = (long double)a1 * *(float *)(com_timescale + 8) * *(float *)&com_codeTimeScale;
    a1 = sub_8062808(v2);
    v6 = 1;
  }
  if ( a1 <= 0 )
    a1 = 1;
  if ( *(_DWORD *)(com_dedicated + 8) )
  {
    if ( a1 > 500 && a1 <= 499999 )
      Com_Printf("Hitch warning: %i msec frame time\n", a1);
    v7 = 5000;
  }
  else if ( *(_BYTE *)(com_sv_running + 8) )
  {
    v7 = 200;
  }
  else
  {
    v7 = 5000;
  }
  if ( a1 > v7 )
    a1 = v7;
  if ( v6 && v5 )
  {
    v3 = (float)a1;
    v4 = v3 / (long double)v5;
  }
  else
  {
    v4 = 1.0;
  }
  flt_819EF08 = v4;
  return a1;
}
// 819EF04: using guessed type int com_timescale;
// 819EF08: using guessed type float flt_819EF08;
// 819EF0C: using guessed type int com_fixedtime;
// 819EF14: using guessed type int com_sv_running;
// 819EF48: using guessed type int com_codeTimeScale;
// 8494204: using guessed type int com_dedicated;

//----- (080623A4) --------------------------------------------------------
int Com_UpdateViewLog()
{
  int result; // eax

  result = com_viewlog;
  if ( *(_BYTE *)(com_viewlog + 7) )
  {
    if ( !*(_DWORD *)(com_dedicated + 8) )
      sub_80D40EA();
    return Dvar_ClearModified(com_viewlog);
  }
  return result;
}
// 819EEF8: using guessed type int com_viewlog;
// 8494204: using guessed type int com_dedicated;

//----- (080623EA) --------------------------------------------------------
void __usercall Com_Frame_Try_Block_Function(long double a1@<st0>)
{
  int v1; // [esp+10h] [ebp-8h]
  int v2; // [esp+14h] [ebp-4h]
  int v3; // [esp+14h] [ebp-4h]

  Com_WriteConfiguration();
  Com_UpdateViewLog();
  SetAnimCheck(*(unsigned __int8 *)(com_animCheck + 8));
  v1 = 1;
  if ( *(int *)(com_maxfps + 8) > 0 && !*(_DWORD *)(com_dedicated + 8) )
  {
    v1 = 1000 / *(_DWORD *)(com_maxfps + 8);
    if ( !v1 )
      v1 = 1;
  }
  while ( 1 )
  {
    com_frameTime = Com_EventLoop(a1);
    if ( com_lastFrameTime > com_frameTime )
      com_lastFrameTime = com_frameTime;
    v2 = com_frameTime - com_lastFrameTime;
    if ( com_frameTime - com_lastFrameTime >= v1 )
      break;
    NET_Sleep(0);
  }
  Cbuf_Execute(a1);
  com_lastFrameTime = com_frameTime;
  v3 = Com_ModifyMsec(v2);
  CL_SwitchToLocalClient();
  SV_Frame(a1, v3);
}
// 819EF10: using guessed type int com_maxfps;
// 819EF3C: using guessed type int com_animCheck;
// 819EF40: using guessed type int com_frameTime;
// 819EF44: using guessed type int com_lastFrameTime;
// 8494204: using guessed type int com_dedicated;

//----- (080624CC) --------------------------------------------------------
void sub_80624CC()
{
  ;
}

//----- (080624D2) --------------------------------------------------------
int Com_ResetFrametime()
{
  int result; // eax

  result = Sys_MilliSeconds();
  com_lastFrameTime = result;
  return result;
}
// 819EF44: using guessed type int com_lastFrameTime;

//----- (080624EA) --------------------------------------------------------
void __usercall Com_Frame(long double a1@<st0>)
{
  struct __jmp_buf_tag *v1; // eax

  sub_806283E();
  v1 = (struct __jmp_buf_tag *)Sys_GetValue(2);
  if ( !__sigsetjmp(v1, 0) )
  {
    Com_Frame_Try_Block_Function(a1);
    ++com_frameNumber;
  }
  if ( com_errorEntered )
    Com_ErrorCleanup(a1);
}
// 819EF4C: using guessed type int com_frameNumber;
// 819EF50: using guessed type int com_errorEntered;

//----- (0806253C) --------------------------------------------------------
void *Com_CloseLogFile()
{
  void *result; // eax

  if ( logfile )
  {
    result = FS_FCloseFile(logfile);
    logfile = 0;
  }
  return result;
}
// 819EEF4: using guessed type int logfile;

//----- (08062564) --------------------------------------------------------
void Com_Close()
{
  Com_ShutdownDObj();
  DObjShutdown();
  XAnimShutdown();
  CM_Shutdown();
  sub_80D4590();
  Hunk_Clear();
  Scr_Shutdown();
}

//----- (08062590) --------------------------------------------------------
_DWORD *__cdecl Field_Clear(_DWORD *a1)
{
  _DWORD *result; // eax

  memset(a1 + 6, 0, 0x100u);
  *a1 = 0;
  a1[1] = 0;
  result = a1;
  a1[2] = 256;
  return result;
}

//----- (080625D4) --------------------------------------------------------
void *__usercall Com_Restart@<eax>(long double a1@<st0>)
{
  SV_ShutdownGameProgs(a1);
  Com_ShutdownDObj();
  DObjShutdown();
  XAnimShutdown();
  CM_Shutdown();
  sub_80D4590();
  Hunk_Clear();
  Scr_Init();
  Scr_Settings();
  com_fixedConsolePosition = 0;
  XAnimInit();
  DObjInit();
  return Com_InitDObj();
}
// 819EF54: using guessed type int com_fixedConsolePosition;

//----- (08062622) --------------------------------------------------------
int __cdecl sub_8062622(int a1)
{
  return sub_8076A2A(a1);
}

//----- (0806263E) --------------------------------------------------------
_DWORD *__cdecl sub_806263E(int a1)
{
  return sub_80BA7E4(a1, sub_8062622);
}

//----- (0806265A) --------------------------------------------------------
int __cdecl sub_806265A(_DWORD *a1)
{
  return sub_80BA836(a1, (int (__cdecl *)(_DWORD *, int))sub_8076A50);
}

//----- (08062676) --------------------------------------------------------
int __cdecl sub_8062676(int a1)
{
  int result; // eax

  result = a1;
  dword_81A1C90 = a1;
  return result;
}
// 81A1C90: using guessed type int dword_81A1C90;

//----- (08062684) --------------------------------------------------------
void __cdecl sub_8062684(int a1)
{
  if ( a1 == dword_81A1C90 )
  {
    dword_81A1C90 = 0;
    sub_80E88E0();
  }
}
// 81A1C90: using guessed type int dword_81A1C90;

//----- (080626A8) --------------------------------------------------------
int __cdecl sub_80626A8(_BYTE *a1, int a2, int a3, int a4, int a5)
{
  int i; // [esp+0h] [ebp-8h]
  int j; // [esp+0h] [ebp-8h]
  int v8; // [esp+4h] [ebp-4h]

  v8 = 0;
  if ( a5 )
  {
    if ( *a1 )
    {
      for ( i = 0; i < a4 - a3 && a1[i]; ++i )
      {
        if ( (char)a1[i] <= 32 )
        {
          v8 = 1;
          break;
        }
      }
    }
    else
    {
      v8 = 1;
    }
  }
  if ( v8 && a3 < a4 )
    *(_BYTE *)(a2 + a3++) = 34;
  for ( j = 0; a3 < a4 && a1[j]; ++j )
    *(_BYTE *)(a2 + a3++) = a1[j];
  if ( v8 && a3 < a4 )
    *(_BYTE *)(a2 + a3++) = 34;
  return a3;
}

//----- (08062782) --------------------------------------------------------
int sub_8062782()
{
  return 46;
}

//----- (0806278C) --------------------------------------------------------
int __cdecl sub_806278C(float a1, char *s, unsigned int a3, int a4)
{
  int result; // eax
  unsigned __int8 v5; // [esp+23h] [ebp-5h]
  unsigned int i; // [esp+24h] [ebp-4h]

  snprintf(s, a3 - 1, "%.*f", a4, a1);
  s[a3 - 1] = 0;
  result = sub_8062782();
  v5 = result;
  if ( (_BYTE)result != 46 )
  {
    for ( i = 0; ; ++i )
    {
      result = i;
      if ( i >= a3 )
        break;
      if ( s[i] == 46 )
      {
        result = v5;
        s[i] = v5;
        return result;
      }
    }
  }
  return result;
}

//----- (08062808) --------------------------------------------------------
int __cdecl sub_8062808(float a1)
{
  return (int)floor(a1 + 0.5);
}

//----- (0806283E) --------------------------------------------------------
void sub_806283E()
{
  ;
}

//----- (08062844) --------------------------------------------------------
int __cdecl sub_8062844(int a1, int a2)
{
  int v4; // [esp+Ch] [ebp+8h]

  v4 = 1152 * a2 + a1;
  if ( word_81D4600[v4] )
    return 100 * word_81D4600[v4] + 135929216;
  else
    return 0;
}
// 81D4600: using guessed type __int16 word_81D4600[1152];

//----- (0806289C) --------------------------------------------------------
int __cdecl Com_GetServerDObj(int a1)
{
  if ( word_81D4F00[a1] )
    return 100 * word_81D4F00[a1] + 135929216;
  else
    return 0;
}
// 81D4F00: using guessed type __int16 word_81D4F00[1024];

//----- (080628E4) --------------------------------------------------------
int sub_80628E4()
{
  int i; // [esp+4h] [ebp-4h]
  int j; // [esp+4h] [ebp-4h]

  for ( i = dword_81D5700 + 1; i <= 2047; ++i )
  {
    if ( !*(_BYTE *)(i + 136134016) )
    {
      dword_81D5700 = i;
      *(_BYTE *)(i + 136134016) = 1;
      --dword_81D4580;
      return i;
    }
  }
  for ( j = 1; j <= dword_81D5700; ++j )
  {
    if ( !*(_BYTE *)(j + 136134016) )
    {
      dword_81D5700 = j;
      *(_BYTE *)(j + 136134016) = 1;
      --dword_81D4580;
      return j;
    }
  }
  return 0;
}
// 81D4580: using guessed type int dword_81D4580;
// 81D5700: using guessed type int dword_81D5700;

//----- (08062988) --------------------------------------------------------
int __cdecl sub_8062988(__int16 ***a1, unsigned __int16 a2, int a3, int a4)
{
  int result; // eax
  int v5; // [esp+20h] [ebp-8h]

  v5 = sub_80628E4();
  word_81D4600[a4] = v5;
  result = sub_80B7EFC(a1, a2, a3, 100 * v5 + 135929216, 0);
  if ( !dword_81D4580 )
    Com_Error(1, (char *)&byte_813C2EC);
  return result;
}
// 81D4580: using guessed type int dword_81D4580;
// 81D4600: using guessed type __int16 word_81D4600[1152];
// 8062988: using guessed type int arg_8;

//----- (08062A0C) --------------------------------------------------------
int *sub_8062A0C()
{
  int *result; // eax
  int i; // [esp+14h] [ebp-4h] BYREF

  for ( i = 0; i <= 1151; ++i )
  {
    if ( word_81D4600[i] )
      sub_80B840A(100 * word_81D4600[i] + 135929216);
    result = &i;
  }
  return result;
}
// 81D4600: using guessed type __int16 word_81D4600[1152];

//----- (08062A66) --------------------------------------------------------
int __cdecl sub_8062A66(__int16 ***a1, unsigned __int16 a2, int a3, int a4)
{
  int result; // eax
  int v5; // [esp+20h] [ebp-8h]

  v5 = sub_80628E4();
  word_81D4F00[a4] = v5;
  result = sub_80B7EFC(a1, a2, a3, 100 * v5 + 135929216, a4 + 1);
  if ( !dword_81D4580 )
    Com_Error(1, (char *)&byte_813C2EC);
  return result;
}
// 81D4580: using guessed type int dword_81D4580;
// 81D4F00: using guessed type __int16 word_81D4F00[1024];
// 8062A66: using guessed type int arg_8;

//----- (08062AEC) --------------------------------------------------------
int __cdecl sub_8062AEC(int a1)
{
  int result; // eax

  result = word_81D4600[a1];
  if ( word_81D4600[a1] )
  {
    word_81D4600[a1] = 0;
    *(_BYTE *)(result + 136134016) = 0;
    ++dword_81D4580;
    return sub_80B819E(100 * result + 135929216);
  }
  return result;
}
// 81D4580: using guessed type int dword_81D4580;
// 81D4600: using guessed type __int16 word_81D4600[1152];

//----- (08062B4C) --------------------------------------------------------
int __cdecl Com_SafeServerDObjFree(int a1)
{
  int result; // eax

  result = word_81D4F00[a1];
  if ( word_81D4F00[a1] )
  {
    word_81D4F00[a1] = 0;
    *(_BYTE *)(result + 136134016) = 0;
    ++dword_81D4580;
    return sub_80B819E(100 * result + 135929216);
  }
  return result;
}
// 81D4580: using guessed type int dword_81D4580;
// 81D4F00: using guessed type __int16 word_81D4F00[1024];

//----- (08062BAC) --------------------------------------------------------
void *Com_InitDObj()
{
  void *result; // eax

  Com_Memset(&unk_81D3D80, 0, 0x800u);
  dword_81D4580 = 2047;
  Com_Memset(word_81D4600, 0, 0x900u);
  result = Com_Memset(word_81D4F00, 0, 0x800u);
  dword_81D5700 = 1;
  dword_81D5704 = 1;
  return result;
}
// 81D4580: using guessed type int dword_81D4580;
// 81D4600: using guessed type __int16 word_81D4600[1152];
// 81D4F00: using guessed type __int16 word_81D4F00[1024];
// 81D5700: using guessed type int dword_81D5700;
// 81D5704: using guessed type int dword_81D5704;

//----- (08062C26) --------------------------------------------------------
void Com_ShutdownDObj()
{
  if ( dword_81D5704 )
    dword_81D5704 = 0;
}
// 81D5704: using guessed type int dword_81D5704;

//----- (08062C40) --------------------------------------------------------
void Com_AbortDObj()
{
  dword_81D5704 = 0;
}
// 81D5704: using guessed type int dword_81D5704;

//----- (08062C50) --------------------------------------------------------
int __cdecl Dvar_ForEach(void (__cdecl *a1)(_DWORD))
{
  int result; // eax
  _DWORD *i; // [esp+4h] [ebp-4h]

  result = sortedDvars;
  for ( i = (_DWORD *)sortedDvars; i; i = (_DWORD *)result )
  {
    a1(*i);
    result = i[7];
  }
  return result;
}
// 85178A0: using guessed type int sortedDvars;

//----- (08062C80) --------------------------------------------------------
signed int __cdecl Dvar_GetCombinedString(char *s, signed int a2)
{
  signed int result; // eax
  char *v3; // eax
  char *v4; // eax
  size_t v5; // [esp+18h] [ebp-10h]
  int v6; // [esp+1Ch] [ebp-Ch]
  int v7; // [esp+20h] [ebp-8h]

  v7 = Cmd_Argc();
  *s = 0;
  v6 = 0;
  while ( 1 )
  {
    result = a2;
    if ( a2 >= v7 )
      break;
    v3 = Cmd_Argv(a2);
    v5 = strlen(v3 + 1);
    result = v6 + v5;
    if ( (int)(v6 + v5) > 4093 )
      break;
    v4 = Cmd_Argv(a2);
    I_strncat(s, 4096, v4);
    if ( a2 != v7 - 1 )
      I_strncat(s, 4096, " ");
    v6 += v5;
    ++a2;
  }
  return result;
}

//----- (08062D2C) --------------------------------------------------------
int __usercall Dvar_Command@<eax>(long double a1@<st0>)
{
  char *v1; // eax
  char *v2; // ebx
  char *v3; // eax
  char *v4; // eax
  char *v5; // eax
  char v8[4108]; // [esp+20h] [ebp-1018h] BYREF
  int v9; // [esp+102Ch] [ebp-Ch]

  v1 = Cmd_Argv(0);
  v9 = Dvar_FindVar(v1);
  if ( !v9 )
    return 0;
  if ( Cmd_Argc() == 1 )
  {
    v2 = Dvar_DisplayableResetValue(v9);
    v3 = Dvar_DisplayableValue(v9);
    Com_Printf("\"%s\" is: \"%s^7\" default: \"%s^7\"\n", *(const char **)v9, v3, v2);
    if ( (unsigned __int8)Dvar_HasLatchedValue(v9) )
    {
      v4 = Dvar_DisplayableLatchedValue(v9);
      Com_Printf("latched: \"%s\"\n", v4);
    }
    Dvar_PrintDomain(*(_BYTE *)(v9 + 6), *(_DWORD *)(v9 + 20), *(_DWORD *)(v9 + 24));
    return 1;
  }
  else
  {
    Dvar_GetCombinedString(v8, 1);
    v5 = Cmd_Argv(0);
    Dvar_SetCommand(a1, v5, v8);
    return 1;
  }
}

//----- (08062E4C) --------------------------------------------------------
int __cdecl Dvar_ToggleSimple(int a1)
{
  int v2; // [esp+14h] [ebp-4h]

  switch ( *(_BYTE *)(a1 + 6) )
  {
    case 0:
      Dvar_SetBoolFromSource(a1, *(_BYTE *)(a1 + 8) ^ 1, 1);
      v2 = 1;
      break;
    case 1:
      if ( *(float *)(a1 + 20) > 0.0 || *(float *)(a1 + 24) < 1.0 )
      {
        if ( *(float *)(a1 + 8) == *(float *)(a1 + 20) )
          Dvar_SetFloatFromSource(a1, *(char **)(a1 + 24), 1);
        else
          Dvar_SetFloatFromSource(a1, *(char **)(a1 + 20), 1);
      }
      else if ( *(float *)(a1 + 8) == 0.0 )
      {
        Dvar_SetFloatFromSource(a1, (char *)0x3F800000, 1);
      }
      else
      {
        Dvar_SetFloatFromSource(a1, 0, 1);
      }
      v2 = 1;
      break;
    case 2:
    case 3:
    case 4:
    case 7:
    case 8:
      Com_Printf("'toggle' with no arguments makes no sense for dvar '%s'\n", *(const char **)a1);
      v2 = 0;
      break;
    case 5:
      if ( *(int *)(a1 + 20) > 0 || *(int *)(a1 + 24) <= 0 )
      {
        if ( *(_DWORD *)(a1 + 8) == *(_DWORD *)(a1 + 20) )
          Dvar_SetIntFromSource(a1, *(char **)(a1 + 24), 1);
        else
          Dvar_SetIntFromSource(a1, *(char **)(a1 + 20), 1);
      }
      else if ( *(_DWORD *)(a1 + 8) )
      {
        Dvar_SetIntFromSource(a1, 0, 1);
      }
      else
      {
        Dvar_SetIntFromSource(a1, (char *)1, 1);
      }
      v2 = 1;
      break;
    case 6:
      if ( *(_DWORD *)(a1 + 20) )
        Dvar_SetIntFromSource(a1, (char *)((*(_DWORD *)(a1 + 8) + 1) % *(_DWORD *)(a1 + 20)), 1);
      v2 = 1;
      break;
    default:
      v2 = 0;
      break;
  }
  return v2;
}

//----- (08063088) --------------------------------------------------------
int __usercall Dvar_ToggleInternal@<eax>(long double a1@<st0>)
{
  char *v1; // eax
  char *v2; // eax
  char *v5; // [esp+Ch] [ebp-1Ch]
  char *v6; // [esp+Ch] [ebp-1Ch]
  char *s2; // [esp+10h] [ebp-18h]
  char *s2a; // [esp+10h] [ebp-18h]
  unsigned int i; // [esp+14h] [ebp-14h]
  const char *s1; // [esp+18h] [ebp-10h]
  int v11; // [esp+1Ch] [ebp-Ch]
  char *src; // [esp+20h] [ebp-8h]

  if ( Cmd_Argc() > 1 )
  {
    src = Cmd_Argv(1u);
    v11 = Dvar_FindVar(src);
    if ( v11 )
    {
      if ( Cmd_Argc() == 2 )
      {
        return (unsigned __int8)Dvar_ToggleSimple(v11);
      }
      else
      {
        s1 = Dvar_DisplayableValue(v11);
        for ( i = 2; (int)(i + 1) < Cmd_Argc(); ++i )
        {
          s2 = Cmd_Argv(i);
          if ( *(_BYTE *)(v11 + 6) == 6 )
          {
            v5 = (char *)Dvar_IndexStringToEnumString(v11, s2);
            if ( *v5 )
              s2 = v5;
          }
          if ( !strcasecmp(s1, s2) )
          {
            v2 = Cmd_Argv(i + 1);
            Dvar_SetCommand(a1, src, v2);
            return 1;
          }
        }
        s2a = Cmd_Argv(2u);
        if ( *(_BYTE *)(v11 + 6) == 6 )
        {
          v6 = (char *)Dvar_IndexStringToEnumString(v11, s2a);
          if ( *v6 )
            s2a = v6;
        }
        Dvar_SetCommand(a1, src, s2a);
        return 1;
      }
    }
    else
    {
      Com_Printf("toggle failed: dvar '%s' not found.\n", src);
      return 0;
    }
  }
  else
  {
    v1 = Cmd_Argv(0);
    Com_Printf("USAGE: %s <variable> <optional value sequence>\n", v1);
    return 0;
  }
}

//----- (08063222) --------------------------------------------------------
int __usercall Dvar_Toggle_f@<eax>(long double a1@<st0>)
{
  return Dvar_ToggleInternal(a1);
}

//----- (08063230) --------------------------------------------------------
void __usercall Dvar_TogglePrint_f(long double a1@<st0>)
{
  char *v1; // [esp+Ch] [ebp-Ch]
  int v2; // [esp+10h] [ebp-8h]
  char *v3; // [esp+14h] [ebp-4h]

  if ( (unsigned __int8)Dvar_ToggleInternal(a1) )
  {
    v3 = Cmd_Argv(1u);
    v2 = Dvar_FindVar(v3);
    v1 = Dvar_DisplayableValue(v2);
    Com_Printf("%s toggled to %s\n", v3, v1);
  }
}

//----- (08063288) --------------------------------------------------------
void __usercall Dvar_Set_f(long double a1@<st0>)
{
  char *v1; // eax
  char *v2; // eax
  char *v3; // [esp+1Ch] [ebp-101Ch]
  char v4[4108]; // [esp+20h] [ebp-1018h] BYREF
  int v5; // [esp+102Ch] [ebp-Ch]

  v5 = Cmd_Argc();
  if ( v5 > 2 )
  {
    v3 = Cmd_Argv(1u);
    if ( (unsigned __int8)sub_80AEF62((int)v3) )
    {
      Dvar_GetCombinedString(v4, 2);
      v2 = Cmd_Argv(1u);
      Dvar_SetCommand(a1, v2, v4);
    }
    else
    {
      v1 = Cmd_Argv(1u);
      Com_Printf("invalid variable name: %s\n", v1);
    }
  }
  else
  {
    Com_Printf("USAGE: set <variable> <value>\n");
  }
}

//----- (08063328) --------------------------------------------------------
void __usercall Dvar_RegisterBool_f(long double a1@<st0>)
{
  char *v1; // eax
  char *v2; // eax
  bool v3; // [esp+1Bh] [ebp-Dh]
  char *src; // [esp+1Ch] [ebp-Ch]
  int v5; // [esp+20h] [ebp-8h]

  if ( Cmd_Argc() == 3 )
  {
    src = Cmd_Argv(1u);
    v2 = Cmd_Argv(2u);
    v3 = atoi(v2) != 0;
    v5 = Dvar_FindVar(src);
    if ( !v5 || *(_BYTE *)(v5 + 6) == 7 && (*(_WORD *)(v5 + 4) & 0x4000) != 0 )
    {
      Dvar_RegisterBool(a1, src, v3, 0x4000);
    }
    else if ( *(_BYTE *)(v5 + 6) )
    {
      Com_Printf("dvar '%s' is not a boolean dvar\n", *(const char **)v5);
    }
  }
  else
  {
    v1 = Cmd_Argv(0);
    Com_Printf("USAGE: %s <name> <default>\n", v1);
  }
}

//----- (080633F4) --------------------------------------------------------
void __usercall Dvar_RegisterInt_f(long double a1@<st0>)
{
  char *v1; // eax
  char *v2; // eax
  char *v3; // eax
  char *v4; // eax
  int v5; // [esp+20h] [ebp-18h]
  int v6; // [esp+24h] [ebp-14h]
  char *v7; // [esp+28h] [ebp-10h]
  char *src; // [esp+2Ch] [ebp-Ch]
  int v9; // [esp+30h] [ebp-8h]

  if ( Cmd_Argc() == 5 )
  {
    src = Cmd_Argv(1u);
    v2 = Cmd_Argv(2u);
    v7 = (char *)atoi(v2);
    v3 = Cmd_Argv(3u);
    v6 = atoi(v3);
    v4 = Cmd_Argv(4u);
    v5 = atoi(v4);
    if ( v6 <= v5 )
    {
      v9 = Dvar_FindVar(src);
      if ( !v9 || *(_BYTE *)(v9 + 6) == 7 && (*(_WORD *)(v9 + 4) & 0x4000) != 0 )
      {
        Dvar_RegisterInt(a1, src, v7, v6, v5, 0x4000);
      }
      else if ( *(_BYTE *)(v9 + 6) != 5 && *(_BYTE *)(v9 + 6) != 6 )
      {
        Com_Printf("dvar '%s' is not an integer dvar\n", *(const char **)v9);
      }
    }
    else
    {
      Com_Printf("dvar %s: min %i should not be greater than max %i\n", src, v6, v5);
    }
  }
  else
  {
    v1 = Cmd_Argv(0);
    Com_Printf("USAGE: %s <name> <default> <min> <max>\n", v1);
  }
}

//----- (0806352E) --------------------------------------------------------
void Dvar_RegisterFloat_f()
{
  char *v0; // eax
  char *v1; // eax
  char *v2; // eax
  char *v3; // eax
  int v4; // [esp+20h] [ebp-18h]
  int v5; // [esp+24h] [ebp-14h]
  int v6; // [esp+28h] [ebp-10h]
  char *src; // [esp+2Ch] [ebp-Ch]
  int v8; // [esp+30h] [ebp-8h]

  if ( Cmd_Argc() == 5 )
  {
    src = Cmd_Argv(1u);
    v1 = Cmd_Argv(2u);
    *(float *)&v6 = atof(v1);
    v2 = Cmd_Argv(3u);
    *(float *)&v5 = atof(v2);
    v3 = Cmd_Argv(4u);
    *(float *)&v4 = atof(v3);
    if ( *(float *)&v5 <= (long double)*(float *)&v4 )
    {
      v8 = Dvar_FindVar(src);
      if ( !v8 || *(_BYTE *)(v8 + 6) == 7 && (*(_WORD *)(v8 + 4) & 0x4000) != 0 )
      {
        Dvar_RegisterFloat(*(float *)&v4, src, (char *)v6, v5, v4, 0x4000);
      }
      else if ( *(_BYTE *)(v8 + 6) != 1 )
      {
        Com_Printf("dvar '%s' is not an integer dvar\n", *(const char **)v8);
      }
    }
    else
    {
      Com_Printf("dvar %s: min %g should not be greater than max %g\n", src, *(float *)&v5, *(float *)&v4);
    }
  }
  else
  {
    v0 = Cmd_Argv(0);
    Com_Printf("USAGE: %s <name> <default> <min> <max>\n", v0);
  }
}

//----- (08063664) --------------------------------------------------------
void __usercall Dvar_SetU_f(long double a1@<st0>)
{
  char *v1; // eax
  int v2; // [esp+14h] [ebp-4h]

  if ( Cmd_Argc() > 2 )
  {
    Dvar_Set_f(a1);
    v1 = Cmd_Argv(1u);
    v2 = Dvar_FindVar(v1);
    if ( v2 )
      Dvar_AddFlags(v2, 2);
  }
  else
  {
    Com_Printf("USAGE: setu <variable> <value>\n");
  }
}

//----- (080636BC) --------------------------------------------------------
void __usercall Dvar_SetS_f(long double a1@<st0>)
{
  char *v1; // eax
  int v2; // [esp+14h] [ebp-4h]

  if ( Cmd_Argc() > 2 )
  {
    Dvar_Set_f(a1);
    v1 = Cmd_Argv(1u);
    v2 = Dvar_FindVar(v1);
    if ( v2 )
      Dvar_AddFlags(v2, 4);
  }
  else
  {
    Com_Printf("USAGE: sets <variable> <value>\n");
  }
}

//----- (08063714) --------------------------------------------------------
void __usercall Dvar_SetA_f(long double a1@<st0>)
{
  char *v1; // eax
  int v2; // [esp+14h] [ebp-4h]

  if ( Cmd_Argc() > 2 )
  {
    Dvar_Set_f(a1);
    v1 = Cmd_Argv(1u);
    v2 = Dvar_FindVar(v1);
    if ( v2 )
      Dvar_AddFlags(v2, 1);
  }
  else
  {
    Com_Printf("USAGE: seta <variable> <value>\n");
  }
}

//----- (0806376C) --------------------------------------------------------
void __usercall Dvar_SetFromDvar_f(long double a1@<st0>)
{
  char *v1; // eax
  char *v2; // eax
  char *v3; // ebx
  char *v4; // eax
  int v5; // [esp+10h] [ebp-8h]

  if ( Cmd_Argc() == 3 )
  {
    v1 = Cmd_Argv(2u);
    v5 = Dvar_FindVar(v1);
    if ( v5 )
    {
      v3 = Dvar_DisplayableValue(v5);
      v4 = Cmd_Argv(1u);
      Dvar_SetCommand(a1, v4, v3);
    }
    else
    {
      v2 = Cmd_Argv(2u);
      Com_Printf("dvar '%s' doesn't exist\n", v2);
    }
  }
  else
  {
    Com_Printf("USAGE: setfromdvar <dest_dvar> <source_dvar>\n");
  }
}

//----- (080637F2) --------------------------------------------------------
void Dvar_Reset_f()
{
  char *v0; // eax
  int v1; // [esp+14h] [ebp-4h]

  if ( Cmd_Argc() == 2 )
  {
    v0 = Cmd_Argv(1u);
    v1 = Dvar_FindVar(v0);
    if ( v1 )
      Dvar_Reset(v1, 1);
  }
  else
  {
    Com_Printf("USAGE: reset <variable>\n");
  }
}

//----- (08063844) --------------------------------------------------------
int __cdecl Dvar_WriteVariables(int a1)
{
  int result; // eax
  char *v2; // eax
  int i; // [esp+14h] [ebp-4h]

  result = sortedDvars;
  for ( i = sortedDvars; i; i = result )
  {
    if ( I_stricmp(*(char **)i, "cl_cdkey") )
    {
      if ( (((unsigned __int8)*(_WORD *)(i + 4) ^ 1) & 1) == 0 )
      {
        v2 = Dvar_DisplayableLatchedValue(i);
        FS_Printf(a1, "seta %s \"%s\"\n", *(const char **)i, v2);
      }
    }
    result = *(_DWORD *)(i + 28);
  }
  return result;
}
// 85178A0: using guessed type int sortedDvars;

//----- (080638BE) --------------------------------------------------------
int __cdecl Dvar_WriteDefaults(int a1)
{
  int result; // eax
  char *v2; // eax
  int i; // [esp+14h] [ebp-4h]

  result = sortedDvars;
  for ( i = sortedDvars; i; i = result )
  {
    if ( I_stricmp(*(char **)i, "cl_cdkey") )
    {
      if ( (*(_WORD *)(i + 4) & 0x40C0) == 0 )
      {
        v2 = Dvar_DisplayableResetValue(i);
        FS_Printf(a1, "set %s \"%s\"\n", *(const char **)i, v2);
      }
    }
    result = *(_DWORD *)(i + 28);
  }
  return result;
}
// 85178A0: using guessed type int sortedDvars;

//----- (0806393A) --------------------------------------------------------
void Dvar_List_f()
{
  char *v0; // eax
  char *v1; // [esp+10h] [ebp-8h]
  char **i; // [esp+14h] [ebp-4h]

  if ( Cmd_Argc() <= 1 )
    v1 = 0;
  else
    v1 = Cmd_Argv(1u);
  for ( i = (char **)sortedDvars; i; i = (char **)i[7] )
  {
    if ( !v1 || (unsigned __int8)Com_Filter(v1, *i, 0) )
    {
      if ( ((_WORD)i[1] & 0x404) != 0 )
        Com_Printf((char *)aSurialc);
      else
        Com_Printf(" ");
      if ( ((_WORD)i[1] & 2) != 0 )
        Com_Printf((char *)&aSurialc[2]);
      else
        Com_Printf(" ");
      if ( ((_WORD)i[1] & 0x40) != 0 )
        Com_Printf((char *)&aSurialc[4]);
      else
        Com_Printf(" ");
      if ( ((_WORD)i[1] & 0x10) != 0 )
        Com_Printf((char *)&aSurialc[6]);
      else
        Com_Printf(" ");
      if ( ((_WORD)i[1] & 1) != 0 )
        Com_Printf((char *)&aSurialc[8]);
      else
        Com_Printf(" ");
      if ( ((_WORD)i[1] & 0x20) != 0 )
        Com_Printf((char *)&aSurialc[10]);
      else
        Com_Printf(" ");
      if ( *((char *)i + 4) >= 0 )
        Com_Printf(" ");
      else
        Com_Printf((char *)&aSurialc[12]);
      v0 = Dvar_DisplayableValue((int)i);
      Com_Printf(" %s \"%s\"\n", *i, v0);
    }
  }
  Com_Printf("\n%i total dvars\n", *(_DWORD *)dword_8522CC0);
}
// 85178A0: using guessed type int sortedDvars;

//----- (08063B04) --------------------------------------------------------
void __cdecl Com_DvarDump(int a1)
{
  char *v1; // ebx
  char *v2; // eax
  char *v3; // eax
  char s[8196]; // [esp+20h] [ebp-2018h] BYREF
  int v5; // [esp+2024h] [ebp-14h]
  char v6[4]; // [esp+2028h] [ebp-10h]
  const char **v7; // [esp+202Ch] [ebp-Ch]

  if ( Cmd_Argc() <= 1 )
    v5 = 0;
  else
    v5 = (int)Cmd_Argv(1u);
  if ( a1 || com_logfile && *(_DWORD *)(com_logfile + 8) )
  {
    *(_DWORD *)v6 = 0;
    Com_PrintMessage(a1, "=============================== DVAR DUMP ========================================\n");
    v7 = (const char **)sortedDvars;
    while ( v7 )
    {
      if ( !v5 || (unsigned __int8)Com_Filter((char *)v5, (char *)*v7, 0) )
      {
        if ( (unsigned __int8)Dvar_HasLatchedValue((int)v7) )
        {
          v1 = Dvar_DisplayableLatchedValue((int)v7);
          v2 = Dvar_DisplayableValue((int)v7);
          Com_sprintf(s, 0x2000u, "      %s \"%s\" -- latched \"%s\"\n", *v7, v2, v1);
        }
        else
        {
          v3 = Dvar_DisplayableValue((int)v7);
          Com_sprintf(s, 0x2000u, "      %s \"%s\"\n", *v7, v3);
        }
        Com_PrintMessage(a1, s);
      }
      v7 = (const char **)v7[7];
      ++*(_DWORD *)v6;
    }
    Com_sprintf(s, 0x2000u, "\n%i total dvars\n%i dvar indexes\n", *(_DWORD *)v6, *(_DWORD *)dword_8522CC0);
    Com_PrintMessage(a1, s);
    Com_PrintMessage(a1, "=============================== END DVAR DUMP =====================================\n");
  }
}
// 819EF18: using guessed type int com_logfile;
// 85178A0: using guessed type int sortedDvars;

//----- (08063CC0) --------------------------------------------------------
void Dvar_Dump_f()
{
  Com_DvarDump(0);
}

//----- (08063CD4) --------------------------------------------------------
int __cdecl SV_SetConfig(int a1, int a2, unsigned __int16 a3)
{
  int result; // eax
  char *v4; // eax
  int i; // [esp+14h] [ebp-4h]

  result = sortedDvars;
  for ( i = sortedDvars; i; i = result )
  {
    if ( (a3 & *(_WORD *)(i + 4)) != 0 )
    {
      v4 = Dvar_DisplayableValue(i);
      sub_80911AA(a1, a2, *(char **)i, v4);
    }
    result = *(_DWORD *)(i + 28);
  }
  return result;
}
// 85178A0: using guessed type int sortedDvars;

//----- (08063D30) --------------------------------------------------------
char *__cdecl Dvar_InfoString(unsigned __int16 a1)
{
  char *v1; // eax
  int i; // [esp+14h] [ebp-4h]

  byte_81D5780 = 0;
  for ( i = sortedDvars; i; i = *(_DWORD *)(i + 28) )
  {
    if ( (a1 & *(_WORD *)(i + 4)) != 0 )
    {
      v1 = Dvar_DisplayableValue(i);
      Info_SetValueForKey(&byte_81D5780, *(char **)i, (int)v1);
    }
  }
  return &byte_81D5780;
}
// 85178A0: using guessed type int sortedDvars;

//----- (08063D92) --------------------------------------------------------
char *__cdecl Dvar_InfoString_Big(unsigned __int16 a1)
{
  char *v1; // eax
  int i; // [esp+14h] [ebp-4h]

  byte_81D5B80 = 0;
  for ( i = sortedDvars; i; i = *(_DWORD *)(i + 28) )
  {
    if ( (a1 & *(_WORD *)(i + 4)) != 0 )
    {
      v1 = Dvar_DisplayableValue(i);
      sub_80B622A(&byte_81D5B80, *(char **)i, (int)v1);
    }
  }
  return &byte_81D5B80;
}
// 85178A0: using guessed type int sortedDvars;

//----- (08063DF4) --------------------------------------------------------
void Dvar_AddCommands()
{
  Cmd_AddCommand("toggle", (int)Dvar_Toggle_f);
  Cmd_AddCommand("togglep", (int)Dvar_TogglePrint_f);
  Cmd_AddCommand("set", (int)Dvar_Set_f);
  Cmd_AddCommand("sets", (int)Dvar_SetS_f);
  Cmd_AddCommand("seta", (int)Dvar_SetA_f);
  Cmd_AddCommand("setfromdvar", (int)Dvar_SetFromDvar_f);
  Cmd_AddCommand("reset", (int)Dvar_Reset_f);
  Cmd_AddCommand("dvarlist", (int)Dvar_List_f);
  Cmd_AddCommand("dvardump", (int)Dvar_Dump_f);
  Cmd_AddCommand("dvar_bool", (int)Dvar_RegisterBool_f);
  Cmd_AddCommand("dvar_int", (int)Dvar_RegisterInt_f);
  Cmd_AddCommand("dvar_float", (int)Dvar_RegisterFloat_f);
  Cmd_AddCommand("setu", (int)Dvar_SetU_f);
}

//----- (08063F00) --------------------------------------------------------
int __cdecl sub_8063F00(char *a1)
{
  char s[268]; // [esp+20h] [ebp-118h] BYREF
  FILE *stream; // [esp+12Ch] [ebp-Ch]

  FS_BuildOSPath(*(char **)(fs_homepath + 8), a1, (char *)&byte_813C8A0, s);
  s[strlen(s) - 1] = 0;
  stream = FS_FileOpen(s, "rb");
  if ( !stream )
    return 0;
  FS_FileClose(stream);
  return 1;
}
// 848B7C4: using guessed type int fs_homepath;

//----- (08063F90) --------------------------------------------------------
int __cdecl FS_SV_FOpenFileWrite(char *src)
{
  int v1; // ebx
  int v4; // [esp+1Ch] [ebp-10Ch]
  char s[264]; // [esp+20h] [ebp-108h] BYREF

  FS_CheckFileSystemStarted();
  FS_BuildOSPath(*(char **)(fs_homepath + 8), src, (char *)&byte_813C8A0, s);
  s[strlen(s) - 1] = 0;
  v4 = FS_HandleForFile(0);
  dword_848B814[71 * v4] = 0;
  if ( *(_DWORD *)(fs_debug + 8) )
    Com_Printf("FS_SV_FOpenFileWrite: %s\n", s);
  if ( FS_CreatePath(s) )
    return 0;
  Com_DPrintf("writing to: %s\n", s);
  v1 = 71 * v4;
  dword_848B800[v1] = (int)FS_FileOpen(s, "wb");
  I_strncpyz((char *)(284 * v4 + 138983452), src, 256);
  dword_848B808[71 * v4] = 0;
  if ( !dword_848B800[71 * v4] )
    return 0;
  return v4;
}
// 848B7C0: using guessed type int fs_debug;
// 848B7C4: using guessed type int fs_homepath;
// 848B800: using guessed type int dword_848B800[];
// 848B808: using guessed type int dword_848B808[];
// 848B814: using guessed type int dword_848B814[];

//----- (08064100) --------------------------------------------------------
int __cdecl FS_SV_FOpenFileRead(char *src, _DWORD *a2)
{
  int v2; // ebx
  int v3; // ebx
  int v4; // ebx
  int v7; // [esp+1Ch] [ebp-10Ch]
  char s[264]; // [esp+20h] [ebp-108h] BYREF

  FS_CheckFileSystemStarted();
  v7 = FS_HandleForFile(0);
  dword_848B814[71 * v7] = 0;
  I_strncpyz((char *)(284 * v7 + 138983452), src, 256);
  FS_BuildOSPath(*(char **)(fs_homepath + 8), src, (char *)&byte_813C8A0, s);
  s[strlen(s) - 1] = 0;
  if ( *(_DWORD *)(fs_debug + 8) )
    Com_Printf("FS_SV_FOpenFileRead (fs_homepath): %s\n", s);
  v2 = 71 * v7;
  dword_848B800[v2] = (int)FS_FileOpen(s, "rb");
  dword_848B808[71 * v7] = 0;
  if ( !dword_848B800[71 * v7] && I_stricmp(*(char **)(fs_homepath + 8), *(char **)(fs_basepath + 8)) )
  {
    FS_BuildOSPath(*(char **)(fs_basepath + 8), src, (char *)&byte_813C8A0, s);
    s[strlen(s) - 1] = 0;
    if ( *(_DWORD *)(fs_debug + 8) )
      Com_Printf("FS_SV_FOpenFileRead (fs_basepath): %s\n", s);
    v3 = 71 * v7;
    dword_848B800[v3] = (int)FS_FileOpen(s, "rb");
    dword_848B808[71 * v7] = 0;
    if ( !dword_848B800[71 * v7] )
      v7 = 0;
  }
  if ( !dword_848B800[71 * v7] )
  {
    FS_BuildOSPath(*(char **)(fs_cdpath + 8), src, (char *)&byte_813C8A0, s);
    s[strlen(s) - 1] = 0;
    if ( *(_DWORD *)(fs_debug + 8) )
      Com_Printf("FS_SV_FOpenFileRead (fs_cdpath) : %s\n", s);
    v4 = 71 * v7;
    dword_848B800[v4] = (int)FS_FileOpen(s, "rb");
    dword_848B808[71 * v7] = 0;
    if ( !dword_848B800[71 * v7] )
      v7 = 0;
  }
  *a2 = v7;
  if ( v7 )
    return FS_filelength(v7);
  else
    return 0;
}
// 848B7C0: using guessed type int fs_debug;
// 848B7C4: using guessed type int fs_homepath;
// 848B7D4: using guessed type int fs_cdpath;
// 848B800: using guessed type int dword_848B800[];
// 848B808: using guessed type int dword_848B808[];
// 848B814: using guessed type int dword_848B814[];

//----- (08064420) --------------------------------------------------------
int __cdecl FS_SV_Rename(char *a1, char *a2)
{
  int result; // eax
  char newa[256]; // [esp+10h] [ebp-208h] BYREF
  char s[264]; // [esp+110h] [ebp-108h] BYREF

  FS_CheckFileSystemStarted();
  FS_BuildOSPath(*(char **)(fs_homepath + 8), a1, (char *)&byte_813C8A0, s);
  FS_BuildOSPath(*(char **)(fs_homepath + 8), a2, (char *)&byte_813C8A0, newa);
  newa[strlen(s) + 255] = 0;
  newa[strlen(newa) - 1] = 0;
  if ( *(_DWORD *)(fs_debug + 8) )
    Com_Printf("FS_SV_Rename: %s --> %s\n", s, newa);
  result = rename(s, newa);
  if ( result )
  {
    FS_CopyFile(s, newa);
    return sub_809CACA(s);
  }
  return result;
}
// 848B7C0: using guessed type int fs_debug;
// 848B7C4: using guessed type int fs_homepath;

//----- (0806451C) --------------------------------------------------------
void *__cdecl sub_806451C(char *s, char a2)
{
  signed int v3; // [esp+10h] [ebp-8h]
  signed int i; // [esp+14h] [ebp-4h]

  v3 = strlen(s);
  for ( i = 0; i < v3; ++i )
    *(_BYTE *)(i + 136207616) = s[i] + a2;
  *(_BYTE *)(i + 136207616) = 0;
  return &unk_81E5D00;
}

//----- (08064574) --------------------------------------------------------
int __cdecl sub_8064574(int a1, unsigned int a2, int a3)
{
  int v5; // [esp+14h] [ebp-4h]

  FS_CheckFileSystemStarted();
  if ( !a3 )
    return 0;
  if ( !dword_848B818[71 * a3] )
    return FS_Read(a1, a2, a3);
  dword_848B818[71 * a3] = 0;
  v5 = sub_80D216E(a1, a2, 1, a3);
  dword_848B818[71 * a3] = 1;
  return v5;
}
// 848B818: using guessed type int dword_848B818[4538];

//----- (08064616) --------------------------------------------------------
int __cdecl sub_8064616(_DWORD *a1)
{
  int v2; // [esp+0h] [ebp-4h]

  v2 = 0;
  if ( a1 )
  {
    while ( *a1 )
    {
      ++a1;
      ++v2;
    }
  }
  return v2;
}

//----- (08064644) --------------------------------------------------------
_DWORD *__cdecl sub_8064644(_DWORD *ptr, _DWORD *a2, _DWORD *a3)
{
  int v3; // eax
  _DWORD *i; // [esp+8h] [ebp-10h]
  _DWORD *j; // [esp+8h] [ebp-10h]
  _DWORD *k; // [esp+8h] [ebp-10h]
  _DWORD *v8; // [esp+Ch] [ebp-Ch]
  _DWORD *v9; // [esp+10h] [ebp-8h]
  int v10; // [esp+14h] [ebp-4h]
  int v11; // [esp+14h] [ebp-4h]

  v10 = sub_8064616(ptr);
  v11 = sub_8064616(a2) + v10;
  v3 = sub_8064616(a3);
  v9 = Z_MallocInternal(4 * (v3 + v11) + 4);
  v8 = v9;
  if ( ptr )
  {
    for ( i = ptr; *i; ++i )
      *v8++ = *i;
  }
  if ( a2 )
  {
    for ( j = a2; *j; ++j )
      *v8++ = *j;
  }
  if ( a3 )
  {
    for ( k = a3; *k; ++k )
      *v8++ = *k;
  }
  *v8 = 0;
  if ( ptr )
    Z_FreeInternal(ptr);
  if ( a2 )
    Z_FreeInternal(a2);
  if ( a3 )
    Z_FreeInternal(a3);
  return v9;
}

//----- (08064774) --------------------------------------------------------
int __cdecl FS_GetModList(char *a1, int a2)
{
  FILE *stream; // [esp+24h] [ebp-254h]
  int v4; // [esp+28h] [ebp-250h]
  _DWORD *v5; // [esp+2Ch] [ebp-24Ch]
  _DWORD *v6; // [esp+30h] [ebp-248h]
  _DWORD *v7; // [esp+34h] [ebp-244h]
  int v8; // [esp+38h] [ebp-240h] BYREF
  int v9; // [esp+3Ch] [ebp-23Ch] BYREF
  char dest[256]; // [esp+40h] [ebp-238h] BYREF
  char name[260]; // [esp+140h] [ebp-138h] BYREF
  char *s; // [esp+244h] [ebp-34h]
  void *ptr; // [esp+248h] [ebp-30h]
  void *v14; // [esp+24Ch] [ebp-2Ch]
  int v15; // [esp+250h] [ebp-28h]
  int v16; // [esp+254h] [ebp-24h]
  int v17; // [esp+258h] [ebp-20h] BYREF
  size_t v18; // [esp+25Ch] [ebp-1Ch]
  int v19; // [esp+260h] [ebp-18h]
  int j; // [esp+264h] [ebp-14h]
  int i; // [esp+268h] [ebp-10h]
  int v22; // [esp+26Ch] [ebp-Ch]
  char *v23; // [esp+280h] [ebp+8h]

  v14 = 0;
  ptr = 0;
  v5 = 0;
  v4 = 0;
  *a1 = 0;
  v19 = 0;
  v16 = 0;
  v22 = 0;
  v7 = Sys_ListFiles(*(char **)(fs_homepath + 8), 0, 0, &v8, 1);
  v6 = Sys_ListFiles(*(char **)(fs_basepath + 8), 0, 0, &v8, 1);
  if ( *(_DWORD *)(fs_cdpath + 8) && **(_BYTE **)(fs_cdpath + 8) )
    v5 = Sys_ListFiles(*(char **)(fs_cdpath + 8), 0, 0, &v8, 1);
  v14 = sub_8064644(v7, v6, v5);
  v16 = sub_8064616(v14);
  for ( i = 0; i < v16; ++i )
  {
    s = (char *)*((_DWORD *)v14 + i);
    if ( i )
    {
      v4 = 0;
      for ( j = 0; j < i; ++j )
      {
        if ( !I_stricmp(*((char **)v14 + j), s) )
        {
          v4 = 1;
          break;
        }
      }
    }
    if ( !v4 && sub_80B550A(s, ".", 1) )
    {
      FS_BuildOSPath(*(char **)(fs_basepath + 8), s, (char *)&byte_813C8A0, name);
      v17 = 0;
      ptr = Sys_ListFiles(name, "iwd", 0, &v17, 0);
      Sys_FreeFileList((void **)ptr);
      if ( v17 <= 0 )
      {
        FS_BuildOSPath(*(char **)(fs_cdpath + 8), s, (char *)&byte_813C8A0, name);
        v17 = 0;
        ptr = Sys_ListFiles(name, "iwd", 0, &v17, 0);
        Sys_FreeFileList((void **)ptr);
      }
      if ( v17 <= 0 )
      {
        FS_BuildOSPath(*(char **)(fs_homepath + 8), s, (char *)&byte_813C8A0, name);
        v17 = 0;
        ptr = Sys_ListFiles(name, "iwd", 0, &v17, 0);
        Sys_FreeFileList((void **)ptr);
      }
      if ( v17 > 0 )
      {
        v18 = strlen(s) + 1;
        strcpy(dest, s);
        I_strncat(dest, 256, "/description.txt");
        v15 = FS_SV_FOpenFileRead(dest, &v9);
        if ( v15 > 0 && v9 )
        {
          stream = (FILE *)FS_FileForHandle(v9);
          Com_Memset(dest, 0, 0x100u);
          v15 = FS_FileRead(dest, 1u, 0x30u, stream);
          if ( v15 >= 0 )
            dest[v15] = 0;
          FS_FCloseFile(v9);
        }
        else if ( I_stricmp(s, "main") )
        {
          strcpy(dest, s);
        }
        else
        {
          strcpy(dest, "Call of Duty 2 Multiplayer");
        }
        v15 = strlen(dest) + 1;
        if ( (int)(v15 + v19 + v18 + 2) >= a2 )
          break;
        strcpy(a1, s);
        v23 = &a1[v18];
        strcpy(v23, dest);
        a1 = &v23[v15];
        v19 += v15 + v18;
        ++v22;
      }
    }
  }
  Sys_FreeFileList((void **)v14);
  return v22;
}
// 848B7C4: using guessed type int fs_homepath;
// 848B7D4: using guessed type int fs_cdpath;
// 8064774: using guessed type char dest[256];

//----- (08064C7C) --------------------------------------------------------
void FS_Dir_f()
{
  int i; // [esp+14h] [ebp-14h]
  int v1; // [esp+18h] [ebp-10h] BYREF
  void *ptr; // [esp+1Ch] [ebp-Ch]
  char *v3; // [esp+20h] [ebp-8h]
  char v4[4]; // [esp+24h] [ebp-4h]

  if ( Cmd_Argc() > 1 && Cmd_Argc() <= 3 )
  {
    if ( Cmd_Argc() == 2 )
    {
      *(_DWORD *)v4 = Cmd_Argv(1u);
      v3 = (char *)&byte_813C8A0;
    }
    else
    {
      *(_DWORD *)v4 = Cmd_Argv(1u);
      v3 = Cmd_Argv(2u);
    }
    Com_Printf("Directory of %s %s\n", *(const char **)v4, v3);
    Com_Printf("---------------\n");
    ptr = FS_ListFiles(*(int *)v4, v3, 0, &v1);
    for ( i = 0; i < v1; ++i )
      Com_Printf("%s\n", *((const char **)ptr + i));
    FS_FreeFileList((void **)ptr);
  }
  else
  {
    Com_Printf("usage: dir <directory> [extension]\n");
  }
}

//----- (08064D88) --------------------------------------------------------
void FS_NewDir_f()
{
  int i; // [esp+28h] [ebp-10h]
  char v1[4]; // [esp+2Ch] [ebp-Ch] BYREF
  void *ptr; // [esp+30h] [ebp-8h]
  int v3; // [esp+34h] [ebp-4h]

  if ( Cmd_Argc() > 1 )
  {
    v3 = (int)Cmd_Argv(1u);
    Com_Printf("---------------\n");
    ptr = FS_ListFilteredFiles((int)fs_searchpaths, (int)&byte_813C8A0, (char *)&byte_813C8A0, v3, 0, (int *)v1);
    FS_SortFileList((char **)ptr, *(int *)v1);
    for ( i = 0; i < *(int *)v1; ++i )
    {
      FS_ConvertPath(*((_BYTE **)ptr + i));
      Com_Printf("%s\n", *((const char **)ptr + i));
    }
    Com_Printf("%d files listed\n", *(_DWORD *)v1);
    FS_FreeFileList((void **)ptr);
  }
  else
  {
    Com_Printf("usage: fdir <filter>\n");
    Com_Printf("example: fdir *q3dm*.bsp\n");
  }
}

//----- (08064E98) --------------------------------------------------------
void FS_TouchFile_f()
{
  char *v0; // eax

  if ( Cmd_Argc() == 2 )
  {
    v0 = Cmd_Argv(1u);
    FS_TouchFile(v0);
  }
  else
  {
    Com_Printf("Usage: touchFile <file>\n");
  }
}

//----- (08064ECC) --------------------------------------------------------
int __cdecl FS_iwIwd(char *haystack, const char *a2)
{
  char *v2; // eax
  char *v3; // eax
  char *v4; // eax
  char *v7; // [esp+1Ch] [ebp-5Ch]
  char dest[76]; // [esp+20h] [ebp-58h] BYREF
  int v9[3]; // [esp+6Ch] [ebp-Ch]

  for ( v9[0] = 0; v9[0] <= 24; ++v9[0] )
  {
    v2 = va("%s/iw_%02d", a2, v9[0]);
    if ( !FS_FilenameCompare(haystack, v2) )
      return 1;
  }
  v7 = strstr(haystack, "localized_");
  if ( v7 )
  {
    strcpy(dest, haystack);
    dest[v7 - haystack + 10] = 0;
    v3 = va("%s/localized_", a2);
    if ( !FS_FilenameCompare(dest, v3) )
    {
      strcpy(dest, v7 + 10);
      I_strlwr(dest);
      for ( v9[0] = 0; v9[0] <= 24; ++v9[0] )
      {
        v4 = va("_iw%02d", v9[0]);
        if ( strstr(dest, v4) )
          return 1;
      }
    }
  }
  return 0;
}
// 8064ECC: using guessed type int var_C[3];

//----- (08064FF8) --------------------------------------------------------
int __cdecl FS_CompareIwds(char *a1, int a2, int a3)
{
  char *v3; // eax
  char *v4; // eax
  char s[260]; // [esp+30h] [ebp-118h] BYREF
  int i; // [esp+134h] [ebp-14h]
  int v9; // [esp+138h] [ebp-10h]
  int *j; // [esp+13Ch] [ebp-Ch]

  if ( !dword_8491F20 )
    return 0;
  *a1 = 0;
  for ( i = 0; i < dword_8491F20; ++i )
  {
    v9 = 0;
    if ( !FS_iwIwd((&dword_8492F40)[i], "main") )
    {
      for ( j = (int *)fs_searchpaths; j; j = (int *)*j )
      {
        if ( j[1] && *(_DWORD *)(j[1] + 772) == dword_8491F40[i] )
        {
          v9 = 1;
          break;
        }
      }
      if ( !v9 && (&dword_8492F40)[i] && *(&dword_8492F40)[i] )
      {
        if ( a3 )
        {
          I_strncat(a1, a2, "@");
          I_strncat(a1, a2, (&dword_8492F40)[i]);
          I_strncat(a1, a2, ".iwd");
          I_strncat(a1, a2, "@");
          v3 = va("%s.iwd", (&dword_8492F40)[i]);
          if ( sub_8063F00(v3) )
          {
            Com_sprintf(s, 0x100u, "%s.%08x.iwd", (&dword_8492F40)[i], dword_8491F40[i]);
            I_strncat(a1, a2, s);
          }
          else
          {
            I_strncat(a1, a2, (&dword_8492F40)[i]);
            I_strncat(a1, a2, ".iwd");
          }
        }
        else
        {
          I_strncat(a1, a2, (&dword_8492F40)[i]);
          I_strncat(a1, a2, ".iwd");
          v4 = va("%s.iwd", (&dword_8492F40)[i]);
          if ( sub_8063F00(v4) )
            I_strncat(a1, a2, " (local file exists with wrong checksum)");
          I_strncat(a1, a2, "\n");
        }
      }
    }
  }
  if ( !*a1 )
    return 0;
  Com_Printf("Need iwds: %s\n", a1);
  return 1;
}
// 8491F20: using guessed type int dword_8491F20;
// 8491F40: using guessed type int dword_8491F40[1024];

//----- (080652E2) --------------------------------------------------------
void FS_RemoveCommands()
{
  Cmd_RemoveCommand("path");
  Cmd_RemoveCommand("dir");
  Cmd_RemoveCommand("fdir");
  Cmd_RemoveCommand("touchFile");
}

//----- (0806531A) --------------------------------------------------------
void FS_AddCommands()
{
  Cmd_AddCommand("path", (int)FS_Path_f);
  Cmd_AddCommand("fullpath", (int)FS_FullPath_f);
  Cmd_AddCommand("dir", (int)FS_Dir_f);
  Cmd_AddCommand("fdir", (int)FS_NewDir_f);
  Cmd_AddCommand("touchFile", (int)FS_TouchFile_f);
}

//----- (08065386) --------------------------------------------------------
_DWORD *__usercall FS_SetRestrictions@<eax>(long double a1@<st0>)
{
  _DWORD *result; // eax
  _DWORD *i; // [esp+14h] [ebp-4h]

  result = (_DWORD *)fs_restrict;
  if ( *(_BYTE *)(fs_restrict + 8) )
  {
    Dvar_SetBool(fs_restrict, 1);
    Com_Printf("\nRunning in restricted demo mode.\n\n");
    FS_Shutdown();
    FS_Startup(a1, "demomain");
    result = fs_searchpaths;
    for ( i = fs_searchpaths; i; i = (_DWORD *)*i )
    {
      if ( FS_UseSearchPath((int)i) && i[1] && (*(_DWORD *)(i[1] + 772) ^ 0x2261994) != -1277981599 )
        Com_Error(0, "Corrupted iw0.iwd: %u", *(_DWORD *)(i[1] + 772));
      result = (_DWORD *)*i;
    }
  }
  return result;
}
// 848B7E0: using guessed type int fs_restrict;

//----- (08065448) --------------------------------------------------------
char *FS_LoadedIwdChecksums()
{
  char *v0; // eax
  _DWORD *i; // [esp+14h] [ebp-4h]

  byte_81D7D00 = 0;
  for ( i = fs_searchpaths; i; i = (_DWORD *)*i )
  {
    if ( i[1] )
    {
      if ( !i[3] )
      {
        v0 = va("%i ", *(_DWORD *)(i[1] + 772));
        I_strncat(&byte_81D7D00, 0x2000, v0);
      }
    }
  }
  return &byte_81D7D00;
}

//----- (080654C0) --------------------------------------------------------
char *FS_LoadedIwdNames()
{
  _DWORD *i; // [esp+14h] [ebp-4h]

  byte_81D9D00 = 0;
  for ( i = fs_searchpaths; i; i = (_DWORD *)*i )
  {
    if ( i[1] && !i[3] )
    {
      if ( byte_81D9D00 )
        I_strncat(&byte_81D9D00, 0x2000, " ");
      I_strncat(&byte_81D9D00, 0x2000, (char *)(i[1] + 256));
    }
  }
  return &byte_81D9D00;
}

//----- (0806554C) --------------------------------------------------------
char *FS_LoadedIwdPureChecksums()
{
  char *v0; // eax
  _DWORD *i; // [esp+14h] [ebp-4h]

  byte_81DBD00 = 0;
  for ( i = fs_searchpaths; i; i = (_DWORD *)*i )
  {
    if ( i[1] )
    {
      if ( !i[3] )
      {
        v0 = va("%i ", *(_DWORD *)(i[1] + 776));
        I_strncat(&byte_81DBD00, 0x2000, v0);
      }
    }
  }
  return &byte_81DBD00;
}

//----- (080655C4) --------------------------------------------------------
char *FS_ReferencedIwdChecksums()
{
  char *v0; // eax
  _DWORD *i; // [esp+14h] [ebp-4h]

  byte_81DDD00 = 0;
  for ( i = fs_searchpaths; i; i = (_DWORD *)*i )
  {
    if ( i[1] && (*(_BYTE *)(i[1] + 784) || sub_80B550A((char *)(i[1] + 512), "main", 4)) )
    {
      v0 = va("%i ", *(_DWORD *)(i[1] + 772));
      I_strncat(&byte_81DDD00, 0x2000, v0);
    }
  }
  return &byte_81DDD00;
}

//----- (08065670) --------------------------------------------------------
char *FS_ReferencedIwdNames()
{
  _DWORD *i; // [esp+14h] [ebp-4h]

  byte_81E3D00 = 0;
  for ( i = fs_searchpaths; i; i = (_DWORD *)*i )
  {
    if ( i[1] && (*(_BYTE *)(i[1] + 784) || sub_80B550A((char *)(i[1] + 512), "main", 4)) )
    {
      if ( byte_81E3D00 )
        I_strncat(&byte_81E3D00, 0x2000, " ");
      I_strncat(&byte_81E3D00, 0x2000, (char *)(i[1] + 512));
      I_strncat(&byte_81E3D00, 0x2000, "/");
      I_strncat(&byte_81E3D00, 0x2000, (char *)(i[1] + 256));
    }
  }
  return &byte_81E3D00;
}

//----- (08065774) --------------------------------------------------------
char *FS_ReferencedIwdPureChecksums()
{
  char *v0; // eax
  char *v1; // eax
  char *v2; // eax
  int v4; // [esp+Ch] [ebp-Ch]
  int v5; // [esp+10h] [ebp-8h]
  _DWORD *i; // [esp+14h] [ebp-4h]

  byte_81DFD00 = 0;
  v4 = fs_checksumFeed;
  v5 = 0;
  byte_81DFD01[strlen(&byte_81DFD00)] = 0;
  byte_81DFD02[strlen(&byte_81DFD00)] = 0;
  *(&byte_81DFD00 + strlen(&byte_81DFD00)) = 64;
  *(&byte_81DFD00 + strlen(&byte_81DFD00)) = 32;
  for ( i = fs_searchpaths; i; i = (_DWORD *)*i )
  {
    if ( i[1] && !i[3] )
    {
      if ( *(_BYTE *)(i[1] + 784) )
      {
        v0 = va("%i ", *(_DWORD *)(i[1] + 776));
        I_strncat(&byte_81DFD00, 0x2000, v0);
        v4 ^= *(_DWORD *)(i[1] + 776);
        ++v5;
      }
    }
  }
  if ( *(_DWORD *)dword_848B7F0 )
  {
    v1 = va("%i ", *(_DWORD *)dword_848B7F0);
    I_strncat(&byte_81DFD00, 0x2000, v1);
  }
  v2 = va("%i ", v5 ^ v4);
  I_strncat(&byte_81DFD00, 0x2000, v2);
  return &byte_81DFD00;
}
// 848B7F4: using guessed type int fs_checksumFeed;

//----- (080658D8) --------------------------------------------------------
void *__cdecl FS_PureServerSetLoadedIwds(char *a1, char *a2)
{
  signed int v2; // ebx
  char *v3; // eax
  signed int v4; // ebx
  char *v5; // eax
  void *result; // eax
  void *ptr[1024]; // [esp+10h] [ebp-2018h] BYREF
  int src[1024]; // [esp+1010h] [ebp-1018h] BYREF
  int v9; // [esp+2010h] [ebp-18h]
  int v10; // [esp+2014h] [ebp-14h]
  int j; // [esp+2018h] [ebp-10h]
  signed int i; // [esp+201Ch] [ebp-Ch]

  Cmd_TokenizeString(a1);
  v10 = Cmd_Argc();
  if ( v10 > 1024 )
    v10 = 1024;
  for ( i = 0; i < v10; ++i )
  {
    v2 = i;
    v3 = Cmd_Argv(i);
    src[v2] = atoi(v3);
  }
  Cmd_TokenizeString(a2);
  v9 = Cmd_Argc();
  if ( v9 > 1024 )
    v9 = 1024;
  for ( i = 0; i < v9; ++i )
  {
    v4 = i;
    v5 = Cmd_Argv(i);
    ptr[v4] = CopyStringInternal(v5);
  }
  if ( v10 != v9 )
    Com_Error(1, "iwd sum/name mismatch");
  if ( v10 == fs_numServerIwds )
  {
    i = 0;
LABEL_15:
    if ( i >= v10 )
    {
      for ( i = 0; ; ++i )
      {
        result = (void *)i;
        if ( i >= v9 )
          break;
        Z_FreeInternal(ptr[i]);
      }
      return result;
    }
    for ( j = 0; j < fs_numServerIwds; ++j )
    {
      if ( src[i] == dword_848FF20[j] && !I_stricmp((char *)ptr[i], (char *)*(&dword_8490F20 + j)) )
      {
        ++i;
        goto LABEL_15;
      }
    }
  }
  FS_ShutdownServerIwdNames();
  result = (void *)v10;
  fs_numServerIwds = v10;
  if ( v10 )
  {
    Com_DPrintf("Connected to a pure server.\n");
    Com_Memcpy(dword_848FF20, src, 4 * fs_numServerIwds);
    result = Com_Memcpy(&dword_8490F20, ptr, 4 * fs_numServerIwds);
    *(_DWORD *)dword_848B7F0 = 0;
  }
  return result;
}
// 848FF00: using guessed type int fs_numServerIwds;
// 848FF20: using guessed type int dword_848FF20[1024];
// 80658D8: using guessed type int src[1024];

//----- (08065AD2) --------------------------------------------------------
int __cdecl sub_8065AD2(char *a1, char *a2)
{
  char *v2; // eax
  char *v3; // eax
  int result; // eax
  int v5; // [esp+8h] [ebp-10h]
  int v6; // [esp+Ch] [ebp-Ch]
  signed int i; // [esp+10h] [ebp-8h]
  signed int j; // [esp+10h] [ebp-8h]

  Cmd_TokenizeString(a1);
  v6 = Cmd_Argc();
  if ( v6 > 1024 )
    v6 = 1024;
  FS_ShutdownServerReferencedIwds();
  for ( i = 0; i < v6; ++i )
  {
    v2 = Cmd_Argv(i);
    dword_8491F40[i] = atoi(v2);
  }
  if ( a2 && *a2 )
  {
    Cmd_TokenizeString(a2);
    v5 = Cmd_Argc();
    if ( v5 > 1024 )
      v5 = 1024;
    if ( v6 != v5 )
      Com_Error(1, "iwd sum/name mismatch");
    for ( j = 0; j < v5; ++j )
    {
      v3 = Cmd_Argv(j);
      (&dword_8492F40)[j] = CopyStringInternal(v3);
    }
  }
  else if ( v6 )
  {
    Com_Error(1, "iwd sum/name mismatch");
  }
  result = v6;
  dword_8491F20 = v6;
  return result;
}
// 8491F20: using guessed type int dword_8491F20;
// 8491F40: using guessed type int dword_8491F40[1024];

//----- (08065BE0) --------------------------------------------------------
void *__cdecl sub_8065BE0(char *s)
{
  signed int i; // [esp+10h] [ebp-8h]
  signed int n; // [esp+14h] [ebp-4h]

  if ( !sub_80B550A(s, "maps/mp/", 8) )
    s += 8;
  n = strlen(s);
  if ( !strcasecmp(&s[n - 3], "bsp") )
    n -= 7;
  memcpy(&unk_81E6100, s, n);
  *(_BYTE *)(n + 136208640) = 0;
  for ( i = 0; i < n; ++i )
  {
    if ( *(_BYTE *)(i + 136208640) == 37 )
      *(_BYTE *)(i + 136208640) = 95;
  }
  return &unk_81E6100;
}

//----- (08065D50) --------------------------------------------------------
int __cdecl sub_8065D50(char a1, int a2)
{
  int result; // eax

  if ( (dword_81E6144 & 7) == 0 )
    *(_BYTE *)((dword_81E6144 >> 3) + a2) = 0;
  result = a1 << (dword_81E6144 & 7);
  LOBYTE(result) = *(_BYTE *)((dword_81E6144 >> 3) + a2) | result;
  *(_BYTE *)((dword_81E6144++ >> 3) + a2) = result;
  return result;
}
// 81E6144: using guessed type int dword_81E6144;

//----- (08065DBA) --------------------------------------------------------
int __cdecl sub_8065DBA(int a1)
{
  int v2; // [esp+0h] [ebp-4h]

  v2 = ((int)*(unsigned __int8 *)((dword_81E6144 >> 3) + a1) >> (dword_81E6144 & 7)) & 1;
  ++dword_81E6144;
  return v2;
}
// 81E6144: using guessed type int dword_81E6144;

//----- (08065DEE) --------------------------------------------------------
_DWORD *__cdecl sub_8065DEE(int a1)
{
  int v1; // eax
  _DWORD *v4; // [esp+4h] [ebp-4h]

  if ( *(_DWORD *)(a1 + 1048) )
  {
    v4 = *(_DWORD **)(a1 + 1048);
    *(_DWORD *)(a1 + 1048) = *v4;
    return v4;
  }
  else
  {
    v1 = a1 + 4 * (*(_DWORD *)(a1 + 4))++;
    return (_DWORD *)(v1 + 25628);
  }
}

//----- (08065E3E) --------------------------------------------------------
_DWORD *__cdecl sub_8065E3E(int a1, _DWORD *a2)
{
  _DWORD *result; // eax

  *a2 = *(_DWORD *)(a1 + 1048);
  result = a2;
  *(_DWORD *)(a1 + 1048) = a2;
  return result;
}

//----- (08065E5E) --------------------------------------------------------
_DWORD *__cdecl sub_8065E5E(int a1, int a2, int a3)
{
  _DWORD *result; // eax
  _DWORD *v4; // [esp+0h] [ebp-8h]
  _DWORD *v5; // [esp+4h] [ebp-4h]

  v5 = *(_DWORD **)(a2 + 8);
  v4 = *(_DWORD **)(a3 + 8);
  if ( v5 )
  {
    if ( *v5 == a2 )
      *v5 = a3;
    else
      v5[1] = a3;
  }
  else
  {
    *(_DWORD *)(a1 + 8) = a3;
  }
  if ( v4 )
  {
    if ( *v4 == a3 )
      *v4 = a2;
    else
      v4[1] = a2;
  }
  else
  {
    *(_DWORD *)(a1 + 8) = a2;
  }
  *(_DWORD *)(a2 + 8) = v4;
  result = v5;
  *(_DWORD *)(a3 + 8) = v5;
  return result;
}

//----- (08065EE6) --------------------------------------------------------
int __cdecl sub_8065EE6(int a1, int a2)
{
  int result; // eax
  int v3; // [esp+0h] [ebp-4h]
  int v4; // [esp+0h] [ebp-4h]

  v3 = *(_DWORD *)(a1 + 12);
  *(_DWORD *)(a1 + 12) = *(_DWORD *)(a2 + 12);
  *(_DWORD *)(a2 + 12) = v3;
  v4 = *(_DWORD *)(a1 + 16);
  *(_DWORD *)(a1 + 16) = *(_DWORD *)(a2 + 16);
  *(_DWORD *)(a2 + 16) = v4;
  if ( *(_DWORD *)(a1 + 12) == a1 )
    *(_DWORD *)(a1 + 12) = a2;
  if ( *(_DWORD *)(a2 + 12) == a2 )
    *(_DWORD *)(a2 + 12) = a1;
  if ( *(_DWORD *)(a1 + 12) )
    *(_DWORD *)(*(_DWORD *)(a1 + 12) + 16) = a1;
  if ( *(_DWORD *)(a2 + 12) )
    *(_DWORD *)(*(_DWORD *)(a2 + 12) + 16) = a2;
  if ( *(_DWORD *)(a1 + 16) )
    *(_DWORD *)(*(_DWORD *)(a1 + 16) + 12) = a1;
  result = a2;
  if ( *(_DWORD *)(a2 + 16) )
  {
    result = a2;
    *(_DWORD *)(*(_DWORD *)(a2 + 16) + 12) = a2;
  }
  return result;
}

//----- (08065FA6) --------------------------------------------------------
void __cdecl sub_8065FA6(int a1, int a2)
{
  int v2; // [esp+10h] [ebp-8h]

  if ( a2 )
  {
    if ( *(_DWORD *)(a2 + 12) && *(_DWORD *)(*(_DWORD *)(a2 + 12) + 24) == *(_DWORD *)(a2 + 24) )
    {
      v2 = **(_DWORD **)(a2 + 20);
      if ( v2 != *(_DWORD *)(a2 + 8) )
        sub_8065E5E(a1, v2, a2);
      sub_8065EE6(v2, a2);
    }
    if ( *(_DWORD *)(a2 + 16) && *(_DWORD *)(*(_DWORD *)(a2 + 16) + 24) == *(_DWORD *)(a2 + 24) )
    {
      **(_DWORD **)(a2 + 20) = *(_DWORD *)(a2 + 16);
    }
    else
    {
      **(_DWORD **)(a2 + 20) = 0;
      sub_8065E3E(a1, *(_DWORD **)(a2 + 20));
    }
    ++*(_DWORD *)(a2 + 24);
    if ( *(_DWORD *)(a2 + 12) && *(_DWORD *)(*(_DWORD *)(a2 + 12) + 24) == *(_DWORD *)(a2 + 24) )
    {
      *(_DWORD *)(a2 + 20) = *(_DWORD *)(*(_DWORD *)(a2 + 12) + 20);
    }
    else
    {
      *(_DWORD *)(a2 + 20) = sub_8065DEE(a1);
      **(_DWORD **)(a2 + 20) = a2;
    }
    if ( *(_DWORD *)(a2 + 8) )
    {
      sub_8065FA6(a1, *(_DWORD *)(a2 + 8));
      if ( *(_DWORD *)(a2 + 16) == *(_DWORD *)(a2 + 8) )
      {
        sub_8065EE6(a2, *(_DWORD *)(a2 + 8));
        if ( **(_DWORD **)(a2 + 20) == a2 )
          **(_DWORD **)(a2 + 20) = *(_DWORD *)(a2 + 8);
      }
    }
  }
}

//----- (0806610E) --------------------------------------------------------
void __cdecl Huff_addRef(_DWORD *a1, unsigned __int8 a2)
{
  int v2; // ecx
  _DWORD *v3; // [esp+8h] [ebp-10h]
  _DWORD *v4; // [esp+Ch] [ebp-Ch]

  if ( a1[a2 + 5] )
  {
    sub_8065FA6((int)a1, a1[a2 + 5]);
  }
  else
  {
    v4 = &a1[8 * (*a1)++ + 263];
    v3 = &a1[8 * (*a1)++ + 263];
    v3[7] = 257;
    v3[6] = 1;
    v3[3] = *(_DWORD *)(a1[3] + 12);
    if ( *(_DWORD *)(a1[3] + 12)
      && (*(_DWORD *)(*(_DWORD *)(a1[3] + 12) + 16) = v3, *(_DWORD *)(*(_DWORD *)(a1[3] + 12) + 24) == 1) )
    {
      v3[5] = *(_DWORD *)(*(_DWORD *)(a1[3] + 12) + 20);
    }
    else
    {
      v3[5] = sub_8065DEE((int)a1);
      *(_DWORD *)v3[5] = v3;
    }
    *(_DWORD *)(a1[3] + 12) = v3;
    v3[4] = a1[3];
    v4[7] = a2;
    v4[6] = 1;
    v4[3] = *(_DWORD *)(a1[3] + 12);
    if ( *(_DWORD *)(a1[3] + 12) )
    {
      *(_DWORD *)(*(_DWORD *)(a1[3] + 12) + 16) = v4;
      if ( *(_DWORD *)(*(_DWORD *)(a1[3] + 12) + 24) == 1 )
      {
        v4[5] = *(_DWORD *)(*(_DWORD *)(a1[3] + 12) + 20);
      }
      else
      {
        v4[5] = sub_8065DEE((int)a1);
        *(_DWORD *)v4[5] = v3;
      }
    }
    else
    {
      v4[5] = sub_8065DEE((int)a1);
      *(_DWORD *)v4[5] = v4;
    }
    *(_DWORD *)(a1[3] + 12) = v4;
    v4[4] = a1[3];
    v4[1] = 0;
    *v4 = 0;
    if ( *(_DWORD *)(a1[3] + 8) )
    {
      if ( **(_DWORD **)(a1[3] + 8) == a1[3] )
        **(_DWORD **)(a1[3] + 8) = v3;
      else
        *(_DWORD *)(*(_DWORD *)(a1[3] + 8) + 4) = v3;
    }
    else
    {
      a1[2] = v3;
    }
    v3[1] = v4;
    *v3 = a1[3];
    v3[2] = *(_DWORD *)(a1[3] + 8);
    v2 = a1[3];
    v4[2] = v3;
    *(_DWORD *)(v2 + 8) = v3;
    a1[a2 + 5] = v4;
    sub_8065FA6((int)a1, v3[2]);
  }
}

//----- (08066394) --------------------------------------------------------
int __cdecl sub_8066394(_DWORD *a1, _DWORD *a2, int a3)
{
  int v3; // edx

  while ( a1 && a1[7] == 257 )
  {
    if ( sub_8065DBA(a3) )
      a1 = (_DWORD *)a1[1];
    else
      a1 = (_DWORD *)*a1;
  }
  if ( !a1 )
    return 0;
  v3 = a1[7];
  *a2 = v3;
  return v3;
}

//----- (080663F6) --------------------------------------------------------
int __cdecl Huff_offsetReceive(_DWORD *a1, _DWORD *a2, int a3, int *a4)
{
  int result; // eax

  dword_81E6144 = *a4;
  while ( a1 && a1[7] == 257 )
  {
    if ( sub_8065DBA(a3) )
      a1 = (_DWORD *)a1[1];
    else
      a1 = (_DWORD *)*a1;
  }
  if ( a1 )
  {
    *a2 = a1[7];
    result = dword_81E6144;
    *a4 = dword_81E6144;
  }
  else
  {
    result = (int)a2;
    *a2 = 0;
  }
  return result;
}
// 81E6144: using guessed type int dword_81E6144;

//----- (08066466) --------------------------------------------------------
int __cdecl sub_8066466(int a1, int a2, int a3)
{
  int result; // eax

  result = a1;
  if ( *(_DWORD *)(a1 + 8) )
    result = sub_8066466(*(_DWORD *)(a1 + 8), a1, a3);
  if ( a2 )
  {
    if ( *(_DWORD *)(a1 + 4) == a2 )
      return sub_8065D50(1, a3);
    else
      return sub_8065D50(0, a3);
  }
  return result;
}

//----- (080664CC) --------------------------------------------------------
int *__cdecl sub_80664CC(int a1, int a2, int a3)
{
  int *result; // eax
  int i; // [esp+14h] [ebp-4h] BYREF

  if ( *(_DWORD *)(a1 + 4 * a2 + 20) )
    return (int *)sub_8066466(*(_DWORD *)(a1 + 4 * a2 + 20), 0, a3);
  result = (int *)sub_80664CC(a1, 256, a3);
  for ( i = 7; i >= 0; --i )
  {
    sub_8065D50((a2 >> i) & 1, a3);
    result = &i;
  }
  return result;
}

//----- (08066550) --------------------------------------------------------
int __cdecl Huff_offsetTransmit(int a1, int a2, int a3, int *a4)
{
  int result; // eax

  dword_81E6144 = *a4;
  sub_8066466(*(_DWORD *)(a1 + 4 * a2 + 20), 0, a3);
  result = dword_81E6144;
  *a4 = dword_81E6144;
  return result;
}
// 81E6144: using guessed type int dword_81E6144;

//----- (0806658E) --------------------------------------------------------
int __cdecl sub_806658E(_DWORD *a1, int a2)
{
  int v3; // eax
  int v4; // edx
  _DWORD *v5; // ecx
  int v6; // ebx
  char *s; // [esp+1Ch] [ebp-6Ch]
  int v8[7]; // [esp+20h] [ebp-68h] BYREF
  void *src; // [esp+3Ch] [ebp-4Ch]
  int v10[6]; // [esp+40h] [ebp-48h] BYREF
  unsigned __int8 *v11; // [esp+58h] [ebp-30h]
  int v12; // [esp+5Ch] [ebp-2Ch]
  int i; // [esp+60h] [ebp-28h]
  int j; // [esp+64h] [ebp-24h]
  size_t n; // [esp+68h] [ebp-20h]
  int v16[7]; // [esp+6Ch] [ebp-1Ch] BYREF

  LargeLocal(v10, 0x10000);
  src = LargeLocalGetBuf(v10);
  LargeLocal(v8, 28700);
  s = LargeLocalGetBuf(v8);
  v12 = a1[3] - a2;
  v11 = (unsigned __int8 *)(a1[1] + a2);
  if ( v12 > 0 )
  {
    Com_Memset(s, 0, 0x701Cu);
    *((_DWORD *)s + 261) = &s[32 * *(_DWORD *)s + 1052];
    v3 = *((_DWORD *)s + 261);
    ++*(_DWORD *)s;
    *((_DWORD *)s + 4) = v3;
    *((_DWORD *)s + 3) = v3;
    *((_DWORD *)s + 2) = v3;
    *(_DWORD *)(*((_DWORD *)s + 2) + 28) = 256;
    *(_DWORD *)(*((_DWORD *)s + 2) + 24) = 0;
    v4 = *((_DWORD *)s + 3);
    *(_DWORD *)(v4 + 16) = 0;
    *(_DWORD *)(v4 + 12) = 0;
    v5 = (_DWORD *)*((_DWORD *)s + 2);
    v5[1] = 0;
    *v5 = 0;
    v5[2] = 0;
    n = v11[1] + (*v11 << 8);
    if ( (int)n > a1[2] - a2 )
      n = a1[2] - a2;
    dword_81E6144 = 16;
    for ( i = 0; i < (int)n; ++i )
    {
      v16[0] = 0;
      if ( dword_81E6144 >> 3 > v12 )
      {
        *((_BYTE *)src + i) = 0;
        break;
      }
      sub_8066394(*((_DWORD **)s + 2), v16, (int)v11);
      if ( v16[0] == 256 )
      {
        v16[0] = 0;
        for ( j = 0; j <= 7; ++j )
        {
          v6 = 2 * v16[0];
          v16[0] = sub_8065DBA((int)v11) + v6;
        }
      }
      *((_BYTE *)src + i) = v16[0];
      Huff_addRef(s, v16[0]);
    }
    a1[3] = n + a2;
    Com_Memcpy((void *)(a1[1] + a2), src, n);
    LargeLocalDealloc(v8);
    return LargeLocalDealloc(v10);
  }
  else
  {
    LargeLocalDealloc(v8);
    return LargeLocalDealloc(v10);
  }
}
// 81E6144: using guessed type int dword_81E6144;
// 806658E: using guessed type int var_48[6];
// 806658E: using guessed type int var_68[7];
// 806658E: using guessed type int var_1C[7];

//----- (08066838) --------------------------------------------------------
int __cdecl sub_8066838(int a1, int a2)
{
  int v3; // eax
  int v4; // edx
  _DWORD *v5; // ecx
  char *s; // [esp+1Ch] [ebp-4Ch]
  int v7[7]; // [esp+20h] [ebp-48h] BYREF
  void *src; // [esp+3Ch] [ebp-2Ch]
  int v9[4]; // [esp+40h] [ebp-28h] BYREF
  int v10; // [esp+50h] [ebp-18h]
  int v11; // [esp+54h] [ebp-14h]
  int v12; // [esp+58h] [ebp-10h]
  int i; // [esp+5Ch] [ebp-Ch]

  LargeLocal(v9, 0x10000);
  src = LargeLocalGetBuf(v9);
  LargeLocal(v7, 28700);
  s = LargeLocalGetBuf(v7);
  v11 = *(_DWORD *)(a1 + 12) - a2;
  v10 = *(_DWORD *)(a1 + 4) + a2;
  if ( v11 > 0 )
  {
    Com_Memset(s, 0, 0x701Cu);
    *((_DWORD *)s + 261) = &s[32 * *(_DWORD *)s + 1052];
    v3 = *((_DWORD *)s + 261);
    ++*(_DWORD *)s;
    *((_DWORD *)s + 3) = v3;
    *((_DWORD *)s + 2) = v3;
    *(_DWORD *)(*((_DWORD *)s + 2) + 28) = 256;
    *(_DWORD *)(*((_DWORD *)s + 2) + 24) = 0;
    v4 = *((_DWORD *)s + 3);
    *(_DWORD *)(v4 + 16) = 0;
    *(_DWORD *)(v4 + 12) = 0;
    v5 = (_DWORD *)*((_DWORD *)s + 2);
    v5[1] = 0;
    *v5 = 0;
    v5[2] = 0;
    *((_DWORD *)s + 261) = *((_DWORD *)s + 2);
    *(_BYTE *)src = BYTE1(v11);
    *((_BYTE *)src + 1) = v11;
    dword_81E6144 = 16;
    for ( i = 0; i < v11; ++i )
    {
      v12 = *(unsigned __int8 *)(v10 + i);
      sub_80664CC((int)s, v12, (int)src);
      Huff_addRef(s, v12);
    }
    dword_81E6144 += 8;
    *(_DWORD *)(a1 + 12) = a2 + (dword_81E6144 >> 3);
    Com_Memcpy((void *)(*(_DWORD *)(a1 + 4) + a2), src, dword_81E6144 >> 3);
    LargeLocalDealloc(v7);
    return LargeLocalDealloc(v9);
  }
  else
  {
    LargeLocalDealloc(v7);
    return LargeLocalDealloc(v9);
  }
}
// 81E6144: using guessed type int dword_81E6144;
// 8066838: using guessed type int var_28[4];
// 8066838: using guessed type int var_48[7];

//----- (08066A70) --------------------------------------------------------
int __cdecl Huff_Init(char *s)
{
  int v1; // eax
  int v2; // edx
  _DWORD *v3; // ecx
  int v4; // eax
  int v5; // edx
  _DWORD *v6; // ecx
  int result; // eax

  Com_Memset(s, 0, 0x701Cu);
  Com_Memset(s + 28700, 0, 0x701Cu);
  *((_DWORD *)s + 7436) = &s[32 * *((_DWORD *)s + 7175) + 29752];
  v1 = *((_DWORD *)s + 7436);
  ++*((_DWORD *)s + 7175);
  *((_DWORD *)s + 7179) = v1;
  *((_DWORD *)s + 7178) = v1;
  *((_DWORD *)s + 7177) = v1;
  *(_DWORD *)(*((_DWORD *)s + 7177) + 28) = 256;
  *(_DWORD *)(*((_DWORD *)s + 7177) + 24) = 0;
  v2 = *((_DWORD *)s + 7178);
  *(_DWORD *)(v2 + 16) = 0;
  *(_DWORD *)(v2 + 12) = 0;
  v3 = (_DWORD *)*((_DWORD *)s + 7177);
  v3[1] = 0;
  *v3 = 0;
  v3[2] = 0;
  *((_DWORD *)s + 261) = &s[32 * *(_DWORD *)s + 1052];
  v4 = *((_DWORD *)s + 261);
  ++*(_DWORD *)s;
  *((_DWORD *)s + 3) = v4;
  *((_DWORD *)s + 2) = v4;
  *(_DWORD *)(*((_DWORD *)s + 2) + 28) = 256;
  *(_DWORD *)(*((_DWORD *)s + 2) + 24) = 0;
  v5 = *((_DWORD *)s + 3);
  *(_DWORD *)(v5 + 16) = 0;
  *(_DWORD *)(v5 + 12) = 0;
  v6 = (_DWORD *)*((_DWORD *)s + 2);
  v6[1] = 0;
  *v6 = 0;
  v6[2] = 0;
  result = *((_DWORD *)s + 2);
  *((_DWORD *)s + 261) = result;
  return result;
}

//----- (08066C14) --------------------------------------------------------
_DWORD *__cdecl sub_8066C14(_DWORD *a1)
{
  _DWORD *result; // eax

  a1[5] = 0;
  a1[4] = 0;
  *a1 = 1732584193;
  a1[1] = -271733879;
  a1[2] = -1732584194;
  result = a1;
  a1[3] = 271733878;
  return result;
}

//----- (08066C54) --------------------------------------------------------
void *__cdecl sub_8066C54(int *a1, char *src, unsigned int a3)
{
  int v4; // [esp+10h] [ebp-8h]
  int i; // [esp+14h] [ebp-4h]

  v4 = ((unsigned int)a1[4] >> 3) & 0x3F;
  a1[4] += 8 * a3;
  if ( a1[4] < 8 * a3 )
    ++a1[5];
  a1[5] += a3 >> 29;
  if ( a3 < 64 - v4 )
  {
    i = 0;
  }
  else
  {
    Com_Memcpy((char *)a1 + v4 + 24, src, 64 - v4);
    sub_8066E12(a1, (int)(a1 + 6));
    for ( i = 64 - v4; i + 63 < a3; i += 64 )
      sub_8066E12(a1, (int)&src[i]);
    v4 = 0;
  }
  return Com_Memcpy((char *)a1 + v4 + 24, &src[i], a3 - i);
}

//----- (08066D50) --------------------------------------------------------
void *__cdecl sub_8066D50(int a1, int *s)
{
  unsigned int v3; // [esp+14h] [ebp-14h]
  unsigned int v4; // [esp+1Ch] [ebp-Ch]
  char src[8]; // [esp+20h] [ebp-8h] BYREF

  sub_806751E((int)src, (int)(s + 4), 8u);
  v4 = ((unsigned int)s[4] >> 3) & 0x3F;
  if ( v4 > 0x37 )
    v3 = 120 - v4;
  else
    v3 = 56 - v4;
  sub_8066C54(s, byte_815A4A0, v3);
  sub_8066C54(s, src, 8u);
  sub_806751E(a1, (int)s, 0x10u);
  return Com_Memset(s, 0, 0x58u);
}

//----- (08066E12) --------------------------------------------------------
void *__cdecl sub_8066E12(int *a1, int a2)
{
  int s; // [esp+10h] [ebp-58h] BYREF
  int v4; // [esp+14h] [ebp-54h]
  int v5; // [esp+18h] [ebp-50h]
  int v6; // [esp+1Ch] [ebp-4Ch]
  int v7; // [esp+20h] [ebp-48h]
  int v8; // [esp+24h] [ebp-44h]
  int v9; // [esp+28h] [ebp-40h]
  int v10; // [esp+2Ch] [ebp-3Ch]
  int v11; // [esp+30h] [ebp-38h]
  int v12; // [esp+34h] [ebp-34h]
  int v13; // [esp+38h] [ebp-30h]
  int v14; // [esp+3Ch] [ebp-2Ch]
  int v15; // [esp+40h] [ebp-28h]
  int v16; // [esp+44h] [ebp-24h]
  int v17; // [esp+48h] [ebp-20h]
  int v18; // [esp+4Ch] [ebp-1Ch]
  int v19; // [esp+50h] [ebp-18h]
  int v20; // [esp+54h] [ebp-14h]
  int v21; // [esp+58h] [ebp-10h]
  int v22; // [esp+5Ch] [ebp-Ch]

  v22 = *a1;
  v21 = a1[1];
  v20 = a1[2];
  v19 = a1[3];
  sub_80675C6((int)&s, a2, 0x40u);
  v22 += s + (v20 & v21 | v19 & ~v21);
  v22 = __ROL4__(v22, 3);
  v19 += v4 + (v21 & v22 | v20 & ~v22);
  v19 = __ROL4__(v19, 7);
  v20 += v5 + (v22 & v19 | v21 & ~v19);
  v20 = __ROL4__(v20, 11);
  v21 += v6 + (v19 & v20 | v22 & ~v20);
  v21 = __ROL4__(v21, 19);
  v22 += v7 + (v20 & v21 | v19 & ~v21);
  v22 = __ROL4__(v22, 3);
  v19 += v8 + (v21 & v22 | v20 & ~v22);
  v19 = __ROL4__(v19, 7);
  v20 += v9 + (v22 & v19 | v21 & ~v19);
  v20 = __ROL4__(v20, 11);
  v21 += v10 + (v19 & v20 | v22 & ~v20);
  v21 = __ROL4__(v21, 19);
  v22 += v11 + (v20 & v21 | v19 & ~v21);
  v22 = __ROL4__(v22, 3);
  v19 += v12 + (v21 & v22 | v20 & ~v22);
  v19 = __ROL4__(v19, 7);
  v20 += v13 + (v22 & v19 | v21 & ~v19);
  v20 = __ROL4__(v20, 11);
  v21 += v14 + (v19 & v20 | v22 & ~v20);
  v21 = __ROL4__(v21, 19);
  v22 += v15 + (v20 & v21 | v19 & ~v21);
  v22 = __ROL4__(v22, 3);
  v19 += v16 + (v21 & v22 | v20 & ~v22);
  v19 = __ROL4__(v19, 7);
  v20 += v17 + (v22 & v19 | v21 & ~v19);
  v20 = __ROL4__(v20, 11);
  v21 += v18 + (v19 & v20 | v22 & ~v20);
  v21 = __ROL4__(v21, 19);
  v22 += s + (v21 & (v20 | v19) | v20 & v19) + 1518500249;
  v22 = __ROL4__(v22, 3);
  v19 += v7 + (v22 & (v21 | v20) | v21 & v20) + 1518500249;
  v19 = __ROL4__(v19, 5);
  v20 += v11 + (v19 & (v22 | v21) | v22 & v21) + 1518500249;
  v20 = __ROL4__(v20, 9);
  v21 += v15 + (v20 & (v19 | v22) | v19 & v22) + 1518500249;
  v21 = __ROL4__(v21, 13);
  v22 += v4 + (v21 & (v20 | v19) | v20 & v19) + 1518500249;
  v22 = __ROL4__(v22, 3);
  v19 += v8 + (v22 & (v21 | v20) | v21 & v20) + 1518500249;
  v19 = __ROL4__(v19, 5);
  v20 += v12 + (v19 & (v22 | v21) | v22 & v21) + 1518500249;
  v20 = __ROL4__(v20, 9);
  v21 += v16 + (v20 & (v19 | v22) | v19 & v22) + 1518500249;
  v21 = __ROL4__(v21, 13);
  v22 += v5 + (v21 & (v20 | v19) | v20 & v19) + 1518500249;
  v22 = __ROL4__(v22, 3);
  v19 += v9 + (v22 & (v21 | v20) | v21 & v20) + 1518500249;
  v19 = __ROL4__(v19, 5);
  v20 += v13 + (v19 & (v22 | v21) | v22 & v21) + 1518500249;
  v20 = __ROL4__(v20, 9);
  v21 += v17 + (v20 & (v19 | v22) | v19 & v22) + 1518500249;
  v21 = __ROL4__(v21, 13);
  v22 += v6 + (v21 & (v20 | v19) | v20 & v19) + 1518500249;
  v22 = __ROL4__(v22, 3);
  v19 += v10 + (v22 & (v21 | v20) | v21 & v20) + 1518500249;
  v19 = __ROL4__(v19, 5);
  v20 += v14 + (v19 & (v22 | v21) | v22 & v21) + 1518500249;
  v20 = __ROL4__(v20, 9);
  v21 += v18 + (v20 & (v19 | v22) | v19 & v22) + 1518500249;
  v21 = __ROL4__(v21, 13);
  v22 += s + (v19 ^ v21 ^ v20) + 1859775393;
  v22 = __ROL4__(v22, 3);
  v19 += v11 + (v20 ^ v22 ^ v21) + 1859775393;
  v19 = __ROL4__(v19, 9);
  v20 += v7 + (v21 ^ v19 ^ v22) + 1859775393;
  v20 = __ROL4__(v20, 11);
  v21 += v15 + (v22 ^ v20 ^ v19) + 1859775393;
  v21 = __ROL4__(v21, 15);
  v22 += v5 + (v19 ^ v21 ^ v20) + 1859775393;
  v22 = __ROL4__(v22, 3);
  v19 += v13 + (v20 ^ v22 ^ v21) + 1859775393;
  v19 = __ROL4__(v19, 9);
  v20 += v9 + (v21 ^ v19 ^ v22) + 1859775393;
  v20 = __ROL4__(v20, 11);
  v21 += v17 + (v22 ^ v20 ^ v19) + 1859775393;
  v21 = __ROL4__(v21, 15);
  v22 += v4 + (v19 ^ v21 ^ v20) + 1859775393;
  v22 = __ROL4__(v22, 3);
  v19 += v12 + (v20 ^ v22 ^ v21) + 1859775393;
  v19 = __ROL4__(v19, 9);
  v20 += v8 + (v21 ^ v19 ^ v22) + 1859775393;
  v20 = __ROL4__(v20, 11);
  v21 += v16 + (v22 ^ v20 ^ v19) + 1859775393;
  v21 = __ROL4__(v21, 15);
  v22 += v6 + (v19 ^ v21 ^ v20) + 1859775393;
  v22 = __ROL4__(v22, 3);
  v19 += v14 + (v20 ^ v22 ^ v21) + 1859775393;
  v19 = __ROL4__(v19, 9);
  v20 += v10 + (v21 ^ v19 ^ v22) + 1859775393;
  v20 = __ROL4__(v20, 11);
  v21 += v18 + (v22 ^ v20 ^ v19) + 1859775393;
  v21 = __ROL4__(v21, 15);
  *a1 += v22;
  a1[1] += v21;
  a1[2] += v20;
  a1[3] += v19;
  return Com_Memset(&s, 0, 0x40u);
}

//----- (0806751E) --------------------------------------------------------
unsigned int __cdecl sub_806751E(int a1, int a2, unsigned int a3)
{
  unsigned int result; // eax
  unsigned int i; // [esp+0h] [ebp-8h]
  int v5; // [esp+4h] [ebp-4h]

  v5 = 0;
  for ( i = 0; ; i += 4 )
  {
    result = i;
    if ( i >= a3 )
      break;
    *(_WORD *)(i + a1) = __PAIR16__(BYTE1(*(_DWORD *)(a2 + 4 * v5)), *(_BYTE *)(a2 + 4 * v5));
    *(_BYTE *)(a1 + i + 2) = BYTE2(*(_DWORD *)(a2 + 4 * v5));
    *(_BYTE *)(a1 + i + 3) = HIBYTE(*(_DWORD *)(a2 + 4 * v5++));
  }
  return result;
}

//----- (080675C6) --------------------------------------------------------
unsigned int __cdecl sub_80675C6(int a1, int a2, unsigned int a3)
{
  unsigned int result; // eax
  unsigned int i; // [esp+0h] [ebp-Ch]
  int v5; // [esp+4h] [ebp-8h]

  v5 = 0;
  for ( i = 0; ; i += 4 )
  {
    result = i;
    if ( i >= a3 )
      break;
    *(_DWORD *)(a1 + 4 * v5++) = (*(unsigned __int8 *)(a2 + i + 2) << 16) | *(unsigned __int16 *)(a2 + i) | (*(unsigned __int8 *)(a2 + i + 3) << 24);
  }
  return result;
}

//----- (08067642) --------------------------------------------------------
int __cdecl Com_BlockChecksum(char *src, int a2)
{
  int s[27]; // [esp+10h] [ebp-88h] BYREF
  int v4[6]; // [esp+80h] [ebp-18h] BYREF

  sub_8066C14(s);
  sub_8066C54(s, src, a2);
  sub_8066D50((int)v4, s);
  return v4[3] ^ v4[2] ^ v4[0] ^ v4[1];
}

//----- (0806769E) --------------------------------------------------------
int sub_806769E(char *a1, int a2, ...)
{
  int s[27]; // [esp+10h] [ebp-88h] BYREF
  int v4[6]; // [esp+80h] [ebp-18h] BYREF
  va_list va; // [esp+A8h] [ebp+10h] BYREF

  va_start(va, a2);
  sub_8066C14(s);
  sub_8066C54(s, (char *)va, 4u);
  sub_8066C54(s, a1, a2);
  sub_8066D50((int)v4, s);
  return v4[3] ^ v4[2] ^ v4[0] ^ v4[1];
}

//----- (08067718) --------------------------------------------------------
int __cdecl MSG_Init(void *s, int a2, int a3)
{
  int result; // eax

  if ( !msgInit )
    MSG_initHuffman();
  memset(s, 0, 0x18u);
  *((_DWORD *)s + 1) = a2;
  result = a3;
  *((_DWORD *)s + 2) = a3;
  return result;
}
// 81F4898: using guessed type int msgInit;

//----- (0806775C) --------------------------------------------------------
_DWORD *__cdecl MSG_BeginReading(_DWORD *a1)
{
  _DWORD *result; // eax

  *a1 = 0;
  a1[4] = 0;
  result = a1;
  a1[5] = 0;
  return result;
}

//----- (080677A2) --------------------------------------------------------
int __cdecl MSG_WriteBits(_DWORD *a1, int a2, int a3)
{
  int result; // eax
  int v4; // [esp+0h] [ebp-10h]

  result = a1[2] - a1[3];
  if ( result > 3 )
  {
    while ( a3 )
    {
      --a3;
      v4 = a1[5] & 7;
      if ( !v4 )
      {
        a1[5] = 8 * a1[3];
        *(_BYTE *)(a1[1] + a1[3]++) = 0;
      }
      if ( (a2 & 1) != 0 )
        *(_BYTE *)(((int)a1[5] >> 3) + a1[1]) |= 1 << v4;
      ++a1[5];
      result = (int)&a2;
      a2 >>= 1;
    }
  }
  else
  {
    result = (int)a1;
    *a1 = 1;
  }
  return result;
}

//----- (08067868) --------------------------------------------------------
_DWORD *__cdecl MSG_WriteBit0(_DWORD *a1)
{
  _DWORD *result; // eax

  if ( a1[3] < a1[2] )
  {
    if ( (a1[5] & 7) == 0 )
    {
      a1[5] = 8 * a1[3];
      *(_BYTE *)(a1[1] + a1[3]++) = 0;
    }
    result = a1;
    ++a1[5];
  }
  else
  {
    result = a1;
    *a1 = 1;
  }
  return result;
}

//----- (080678C6) --------------------------------------------------------
_DWORD *__cdecl MSG_WriteBit1(_DWORD *a1)
{
  _DWORD *result; // eax
  int v2; // [esp+0h] [ebp-10h]

  if ( a1[3] < a1[2] )
  {
    v2 = a1[5] & 7;
    if ( !v2 )
    {
      a1[5] = 8 * a1[3];
      *(_BYTE *)(a1[1] + a1[3]++) = 0;
    }
    *(_BYTE *)(((int)a1[5] >> 3) + a1[1]) |= 1 << v2;
    result = a1;
    ++a1[5];
  }
  else
  {
    result = a1;
    *a1 = 1;
  }
  return result;
}

//----- (08067960) --------------------------------------------------------
int __cdecl MSG_ReadBits(_DWORD *a1, int a2)
{
  int i; // [esp+4h] [ebp-Ch]
  int v5; // [esp+8h] [ebp-8h]
  int v6; // [esp+Ch] [ebp-4h]

  v6 = 0;
  for ( i = 0; i < a2; ++i )
  {
    v5 = a1[5] & 7;
    if ( !v5 )
    {
      if ( a1[4] >= a1[3] )
      {
        *a1 = 1;
        return -1;
      }
      a1[5] = 8 * a1[4]++;
    }
    v6 |= (((int)*(unsigned __int8 *)(((int)a1[5]++ >> 3) + a1[1]) >> v5) & 1) << i;
  }
  return v6;
}

//----- (08067A0E) --------------------------------------------------------
int __cdecl MSG_ReadBit(_DWORD *a1)
{
  int v3; // [esp+4h] [ebp-8h]

  v3 = a1[5] & 7;
  if ( v3 )
    return ((int)*(unsigned __int8 *)(((int)a1[5]++ >> 3) + a1[1]) >> v3) & 1;
  if ( a1[4] < a1[3] )
  {
    a1[5] = 8 * a1[4]++;
    return ((int)*(unsigned __int8 *)(((int)a1[5]++ >> 3) + a1[1]) >> v3) & 1;
  }
  *a1 = 1;
  return -1;
}

//----- (08067A8E) --------------------------------------------------------
int __cdecl MSG_WriteBitsCompress(unsigned __int8 *a1, int a2, int a3)
{
  int v4; // [esp+10h] [ebp-8h] BYREF
  int v5; // [esp+14h] [ebp-4h]

  v4 = 0;
  v5 = a3;
  while ( v5 )
  {
    Huff_offsetTransmit((int)msgHuff, *a1, a2, &v4);
    --v5;
    ++a1;
  }
  return (v4 + 7) >> 3;
}

//----- (08067AE2) --------------------------------------------------------
_BYTE *__cdecl MSG_ReadBitsCompress(int a1, _BYTE *a2, int a3)
{
  _BYTE *v4; // [esp+14h] [ebp-14h]
  int v5; // [esp+1Ch] [ebp-Ch] BYREF
  int v6; // [esp+20h] [ebp-8h]
  int v7; // [esp+24h] [ebp-4h] BYREF

  v6 = 8 * a3;
  v4 = a2;
  v5 = 0;
  while ( v5 < v6 )
  {
    Huff_offsetReceive((_DWORD *)dword_81ED884, &v7, a1, &v5);
    *v4++ = v7;
  }
  return (_BYTE *)(v4 - a2);
}
// 81ED884: using guessed type int dword_81ED884;

//----- (08067B4C) --------------------------------------------------------
_DWORD *__cdecl MSG_WriteByte(_DWORD *a1, char a2)
{
  _DWORD *result; // eax

  if ( a1[3] >= a1[2] )
  {
    result = a1;
    *a1 = 1;
  }
  else
  {
    *(_BYTE *)(a1[3] + a1[1]) = a2;
    result = a1;
    ++a1[3];
  }
  return result;
}

//----- (08067B84) --------------------------------------------------------
_DWORD *__cdecl MSG_WriteData(_DWORD *a1, void *src, size_t n)
{
  _DWORD *result; // eax
  _DWORD *v4; // [esp+14h] [ebp-4h]

  v4 = (_DWORD *)(a1[3] + n);
  if ( (int)v4 > a1[2] )
  {
    result = a1;
    *a1 = 1;
  }
  else
  {
    memcpy((void *)(a1[1] + a1[3]), src, n);
    result = v4;
    a1[3] = v4;
  }
  return result;
}

//----- (08067BDA) --------------------------------------------------------
_DWORD *__cdecl MSG_WriteShort(_DWORD *a1, __int16 a2)
{
  _DWORD *result; // eax
  int v3; // [esp+4h] [ebp-4h]

  v3 = a1[3] + 2;
  if ( v3 > a1[2] )
  {
    result = a1;
    *a1 = 1;
  }
  else
  {
    *(_WORD *)(a1[1] + a1[3]) = MSG_ShortSwap(a2);
    result = (_DWORD *)v3;
    a1[3] = v3;
  }
  return result;
}

//----- (08067C2A) --------------------------------------------------------
_DWORD *__cdecl MSG_WriteLong(_DWORD *a1, int a2)
{
  _DWORD *result; // eax
  int v3; // [esp+4h] [ebp-4h]

  v3 = a1[3] + 4;
  if ( v3 > a1[2] )
  {
    result = a1;
    *a1 = 1;
  }
  else
  {
    *(_DWORD *)(a1[1] + a1[3]) = MSG_LongSwap(a2);
    result = (_DWORD *)v3;
    a1[3] = v3;
  }
  return result;
}

//----- (08067C78) --------------------------------------------------------
_DWORD *__cdecl MSG_ReadString(_DWORD *a1, int a2, int a3)
{
  int v3; // eax
  int v4; // edx
  int v5; // ecx
  int v6; // edx
  int *v7; // eax
  _DWORD *result; // eax
  int v9; // [esp+14h] [ebp-14h]

  v9 = a1[3] + 8;
  if ( v9 > a1[2] )
  {
    result = a1;
    *a1 = 1;
  }
  else
  {
    v3 = sub_80B4FCE(a2, a3);
    v5 = v4;
    v6 = v3;
    v7 = (int *)(a1[1] + a1[3]);
    *v7 = v6;
    v7[1] = v5;
    result = (_DWORD *)v9;
    a1[3] = v9;
  }
  return result;
}
// 8067CB4: variable 'v4' is possibly undefined

//----- (08067CE4) --------------------------------------------------------
_DWORD *__cdecl MSG_WriteString(_DWORD *a1, char *s)
{
  char *v3; // ebx
  char src[1032]; // [esp+10h] [ebp-418h] BYREF
  int i; // [esp+418h] [ebp-10h]
  int v6; // [esp+41Ch] [ebp-Ch]

  v6 = strlen(s);
  if ( v6 <= 1023 )
  {
    for ( i = 0; i < v6; ++i )
    {
      v3 = &src[i];
      *v3 = I_CleanChar(s[i]);
    }
    src[i] = 0;
    return MSG_WriteData(a1, src, v6 + 1);
  }
  else
  {
    Com_Printf("MSG_WriteString: MAX_STRING_CHARS");
    return MSG_WriteData(a1, &unk_813CD62, 1u);
  }
}
// 8067CE4: using guessed type char src[1032];

//----- (08067D96) --------------------------------------------------------
_DWORD *__cdecl MSG_WriteBigString(_DWORD *a1, char *s)
{
  char *v3; // ebx
  char src[8200]; // [esp+10h] [ebp-2018h] BYREF
  int i; // [esp+2018h] [ebp-10h]
  int v6; // [esp+201Ch] [ebp-Ch]

  v6 = strlen(s);
  if ( v6 <= 0x1FFF )
  {
    I_strncpyz(src, s, 0x2000);
    for ( i = 0; i < v6; ++i )
    {
      v3 = &src[i];
      *v3 = I_CleanChar(src[i]);
    }
    return MSG_WriteData(a1, src, v6 + 1);
  }
  else
  {
    Com_Printf("MSG_WriteString: BIG_INFO_STRING");
    return MSG_WriteData(a1, &unk_813CD62, 1u);
  }
}
// 8067D96: using guessed type char src[8200];

//----- (08067EA6) --------------------------------------------------------
_DWORD *__cdecl MSG_WriteAngle16(_DWORD *a1, float a2)
{
  return MSG_WriteShort(a1, (int)(a2 * 182.04445));
}

//----- (08067EE8) --------------------------------------------------------
int __cdecl MSG_ReadByte(_DWORD *a1)
{
  if ( a1[4] >= a1[3] )
  {
    *a1 = 1;
    return -1;
  }
  else
  {
    return *(unsigned __int8 *)(a1[1] + a1[4]++);
  }
}

//----- (08067F32) --------------------------------------------------------
int __cdecl MSG_ReadShort(_DWORD *a1)
{
  __int16 v1; // ax
  int v4; // [esp+10h] [ebp-8h]

  v4 = a1[4] + 2;
  if ( v4 > a1[3] )
  {
    *a1 = 1;
    return -1;
  }
  else
  {
    v1 = MSG_ShortSwap(*(_WORD *)(a1[1] + a1[4]));
    a1[4] = v4;
    return v1;
  }
}

//----- (08067F90) --------------------------------------------------------
int __cdecl MSG_ReadLong(_DWORD *a1)
{
  int v3; // [esp+10h] [ebp-8h]
  int v4; // [esp+14h] [ebp-4h]

  v3 = a1[4] + 4;
  if ( v3 > a1[3] )
  {
    *a1 = 1;
    return -1;
  }
  else
  {
    v4 = MSG_LongSwap(*(_DWORD *)(a1[1] + a1[4]));
    a1[4] = v3;
    return v4;
  }
}

//----- (08067FEC) --------------------------------------------------------
unsigned __int64 __cdecl MSG_ReadLong64(_DWORD *a1)
{
  int *v1; // eax
  unsigned int v2; // edx
  int v5; // [esp+1Ch] [ebp-Ch]
  int v6; // [esp+20h] [ebp-8h]

  v5 = a1[4] + 8;
  if ( v5 > a1[3] )
  {
    *a1 = 1;
    return 0LL;
  }
  else
  {
    v1 = (int *)(a1[1] + a1[4]);
    v6 = sub_80B4FCE(*v1, v1[1]);
    a1[4] = v5;
    return __PAIR64__(v2, v6);
  }
}
// 806803B: variable 'v2' is possibly undefined

//----- (08068062) --------------------------------------------------------
void *__cdecl MSG_ReadCommandString(_DWORD *a1)
{
  int v2; // [esp+Ch] [ebp-Ch]
  unsigned int i; // [esp+10h] [ebp-8h]

  for ( i = 0; ; ++i )
  {
    v2 = MSG_ReadByte(a1);
    if ( v2 == -1 )
      v2 = 0;
    if ( i <= 0x3FF )
      *(_BYTE *)(i + 136267936) = I_CleanChar(v2);
    if ( !v2 )
      break;
  }
  byte_81F4C9F = 0;
  return &unk_81F48A0;
}
// 81F4C9F: using guessed type char byte_81F4C9F;

//----- (080680CC) --------------------------------------------------------
void *__cdecl MSG_ReadBigString(_DWORD *a1)
{
  int v2; // [esp+Ch] [ebp-Ch]
  unsigned int i; // [esp+10h] [ebp-8h]

  for ( i = 0; ; ++i )
  {
    v2 = MSG_ReadByte(a1);
    if ( v2 == 37 )
    {
      v2 = 46;
    }
    else if ( v2 == -1 )
    {
      v2 = 0;
    }
    if ( i <= 0x1FFF )
      *(_BYTE *)(i + 136268960) = I_CleanChar(v2);
    if ( !v2 )
      break;
  }
  byte_81F6C9F = 0;
  return &unk_81F4CA0;
}
// 81F6C9F: using guessed type char byte_81F6C9F;

//----- (08068146) --------------------------------------------------------
void *__cdecl MSG_ReadStringLine(_DWORD *a1)
{
  int v2; // [esp+Ch] [ebp-Ch]
  unsigned int i; // [esp+10h] [ebp-8h]

  for ( i = 0; ; ++i )
  {
    v2 = MSG_ReadByte(a1);
    if ( v2 == 37 )
    {
      v2 = 46;
    }
    else if ( v2 == 10 || v2 == -1 )
    {
      v2 = 0;
    }
    if ( i <= 0x3FF )
      *(_BYTE *)(i + 136277152) = I_CleanChar(v2);
    if ( !v2 )
      break;
  }
  byte_81F709F = 0;
  return &unk_81F6CA0;
}
// 81F709F: using guessed type char byte_81F709F;

//----- (080681C8) --------------------------------------------------------
long double __cdecl MSG_ReadAngle16(_DWORD *a1)
{
  return (long double)MSG_ReadShort(a1) * 0.0054931641;
}

//----- (080681EC) --------------------------------------------------------
void *__cdecl MSG_ReadData(_DWORD *a1, void *dest, size_t n)
{
  void *result; // eax
  int v4; // [esp+14h] [ebp-4h]

  v4 = a1[4] + n;
  if ( v4 > a1[3] )
  {
    *a1 = 1;
    return memset(dest, -1, n);
  }
  else
  {
    memcpy(dest, (const void *)(a1[1] + a1[4]), n);
    result = (void *)v4;
    a1[4] = v4;
  }
  return result;
}

//----- (0806825C) --------------------------------------------------------
_DWORD *__cdecl sub_806825C(_DWORD *a1, int a2, int a3, int a4, int a5)
{
  if ( a3 == a4 )
    return MSG_WriteBit0(a1);
  MSG_WriteBit1(a1);
  return (_DWORD *)MSG_WriteBits(a1, a4 ^ a2, a5);
}

//----- (080682A0) --------------------------------------------------------
int __cdecl MSG_ReadDeltaKey(_DWORD *a1, int a2, int a3, int a4)
{
  if ( MSG_ReadBit(a1) )
    return a2 & kbitmask[a4] ^ MSG_ReadBits(a1, a4);
  else
    return a3;
}
// 815A4E0: using guessed type int kbitmask[40];

//----- (080682E8) --------------------------------------------------------
int __cdecl sub_80682E8(_DWORD *a1, int a2, int a3, int a4)
{
  return MSG_WriteBits(a1, a3 ^ a2, a4);
}

//----- (0806830C) --------------------------------------------------------
int __cdecl MSG_ReadKey(_DWORD *a1, int a2, int a3)
{
  return a2 & kbitmask[a3] ^ MSG_ReadBits(a1, a3);
}
// 815A4E0: using guessed type int kbitmask[40];

//----- (080683AE) --------------------------------------------------------
_DWORD *__cdecl sub_80683AE(_DWORD *a1, __int16 a2, __int16 a3, __int16 a4)
{
  if ( a3 == a4 )
    return MSG_WriteBit0(a1);
  MSG_WriteBit1(a1);
  return MSG_WriteShort(a1, a4 ^ a2);
}

//----- (080683EC) --------------------------------------------------------
int __cdecl MSG_ReadDeltaKeyShort(_DWORD *a1, __int16 a2, int a3)
{
  if ( MSG_ReadBit(a1) )
    return (__int16)(MSG_ReadShort(a1) ^ a2);
  else
    return a3;
}

//----- (08068424) --------------------------------------------------------
_BYTE *__cdecl MSG_WriteReliableCommandToBuffer(char *s, _BYTE *a2, int a3)
{
  _BYTE *result; // eax
  _BYTE *v4; // [esp+1Ch] [ebp-Ch]
  signed int v5; // [esp+20h] [ebp-8h]
  int i; // [esp+24h] [ebp-4h]

  v5 = strlen(s);
  if ( v5 >= a3 )
    Com_Printf("WARNING: Reliable command is too long (%i/%i) and will be truncated: '%s'\n", v5, a3, s);
  if ( !v5 )
    Com_Printf("WARNING: Empty reliable command\n");
  v4 = a2;
  for ( i = 0; i < a3 && s[i]; ++i )
  {
    *v4 = I_CleanChar(s[i]);
    if ( *v4 == 37 )
      *v4 = 46;
    ++v4;
  }
  if ( i >= a3 )
  {
    result = &a2[a3 - 1];
    *result = 0;
  }
  else
  {
    result = &a2[i];
    a2[i] = 0;
  }
  return result;
}

//----- (080684E6) --------------------------------------------------------
void __cdecl MSG_SetDefaultUserCmd(int a1, void *s)
{
  int i; // [esp+1Ch] [ebp-Ch]

  memset(s, 0, 0x1Cu);
  *((_BYTE *)s + 8) = *(_BYTE *)(a1 + 212);
  *((_BYTE *)s + 9) = *(_BYTE *)(a1 + 208);
  for ( i = 0; i <= 1; ++i )
    *((_DWORD *)s + i + 3) = (unsigned __int16)((int)(*(float *)(a1 + 4 * i + 232) * 182.04445)
                                              - *(_WORD *)(a1 + 4 * i + 84));
  if ( (*(_DWORD *)(a1 + 12) & 0x800000) != 0 )
  {
    if ( (*(_DWORD *)(a1 + 160) & 8) != 0 )
    {
      *((_DWORD *)s + 1) |= 0x100u;
    }
    else if ( (*(_DWORD *)(a1 + 160) & 4) != 0 )
    {
      *((_DWORD *)s + 1) |= 0x200u;
    }
    if ( *(float *)(a1 + 76) <= 0.0 )
    {
      if ( *(float *)(a1 + 76) < 0.0 )
        *((_DWORD *)s + 1) |= 0x40u;
    }
    else
    {
      *((_DWORD *)s + 1) |= 0x80u;
    }
    if ( *(float *)(a1 + 220) != 0.0 )
      *((_DWORD *)s + 1) |= 0x1000u;
  }
}

//----- (08068660) --------------------------------------------------------
int __cdecl MSG_ReadForwardRightMoveMask(int a1, int a2)
{
  int v3; // [esp+0h] [ebp-4h]

  v3 = 0;
  if ( a1 <= 10 )
  {
    if ( a1 < -10 )
      v3 = 2;
  }
  else
  {
    v3 = 1;
  }
  if ( a2 > 10 )
    return v3 | 4;
  if ( a2 < -10 )
    return v3 | 8;
  return v3;
}

//----- (080686A6) --------------------------------------------------------
_BYTE *__cdecl MSG_ClampForwardRightmove(char a1, _BYTE *a2, _BYTE *a3)
{
  _BYTE *result; // eax

  if ( (a1 & 1) != 0 )
  {
    *a2 = 127;
  }
  else if ( (a1 & 2) != 0 )
  {
    *a2 = -127;
  }
  else
  {
    *a2 = 0;
  }
  if ( (a1 & 4) != 0 )
  {
    result = a3;
    *a3 = 127;
  }
  else
  {
    result = a3;
    if ( (a1 & 8) != 0 )
      *a3 = -127;
    else
      *a3 = 0;
  }
  return result;
}

//----- (08068ADE) --------------------------------------------------------
_BYTE *__cdecl MSG_ReadDeltaUsercmdKey(_DWORD *a1, int a2, int a3, int a4)
{
  _BYTE *result; // eax
  int v5; // [esp+18h] [ebp-10h]
  int v6; // [esp+18h] [ebp-10h]
  char v7; // [esp+1Ch] [ebp-Ch]
  char v8; // [esp+1Ch] [ebp-Ch]
  int v9; // [esp+34h] [ebp+Ch]
  int v10; // [esp+34h] [ebp+Ch]

  *(_DWORD *)a4 = *(_DWORD *)a3;
  *(_DWORD *)(a4 + 4) = *(_DWORD *)(a3 + 4);
  *(_DWORD *)(a4 + 8) = *(_DWORD *)(a3 + 8);
  *(_DWORD *)(a4 + 12) = *(_DWORD *)(a3 + 12);
  *(_DWORD *)(a4 + 16) = *(_DWORD *)(a3 + 16);
  *(_DWORD *)(a4 + 20) = *(_DWORD *)(a3 + 20);
  *(_DWORD *)(a4 + 24) = *(_DWORD *)(a3 + 24);
  if ( MSG_ReadBit(a1) )
    *(_DWORD *)a4 = *(_DWORD *)a3 + MSG_ReadByte(a1);
  else
    *(_DWORD *)a4 = MSG_ReadLong(a1);
  result = (_BYTE *)MSG_ReadKey(a1, a2, 1);
  if ( result )
  {
    *(_DWORD *)(a4 + 4) &= ~1u;
    if ( MSG_ReadKey(a1, a2, 1) )
    {
      *(_DWORD *)(a4 + 4) |= MSG_ReadKey(a1, a2, 1);
      *(_DWORD *)(a4 + 12) = (unsigned __int16)MSG_ReadDeltaKeyShort(a1, a2, *(_DWORD *)(a3 + 12));
      *(_DWORD *)(a4 + 16) = (unsigned __int16)MSG_ReadDeltaKeyShort(a1, a2, *(_DWORD *)(a3 + 16));
      v6 = MSG_ReadForwardRightMoveMask(*(char *)(a3 + 24), *(char *)(a3 + 25));
      v8 = MSG_ReadDeltaKey(a1, a2, v6, 4);
      MSG_ClampForwardRightmove(v8, (_BYTE *)(a4 + 24), (_BYTE *)(a4 + 25));
      v10 = *(_DWORD *)a4 ^ a2;
      *(_DWORD *)(a4 + 20) = (unsigned __int16)MSG_ReadDeltaKeyShort(a1, v10, *(_DWORD *)(a3 + 20));
      *(_DWORD *)(a4 + 4) &= 1u;
      *(_DWORD *)(a4 + 4) |= 2 * MSG_ReadDeltaKey(a1, v10, *(int *)(a3 + 4) >> 1, 18);
      *(_BYTE *)(a4 + 8) = MSG_ReadDeltaKey(a1, v10, *(unsigned __int8 *)(a3 + 8), 7);
      result = (_BYTE *)MSG_ReadDeltaKey(a1, v10, *(unsigned __int8 *)(a3 + 9), 7);
      *(_BYTE *)(a4 + 9) = (_BYTE)result;
    }
    else
    {
      v9 = *(_DWORD *)a4 ^ a2;
      *(_DWORD *)(a4 + 4) |= MSG_ReadKey(a1, v9, 1);
      *(_DWORD *)(a4 + 12) = (unsigned __int16)MSG_ReadDeltaKeyShort(a1, v9, *(_DWORD *)(a3 + 12));
      *(_DWORD *)(a4 + 16) = (unsigned __int16)MSG_ReadDeltaKeyShort(a1, v9, *(_DWORD *)(a3 + 16));
      v5 = MSG_ReadForwardRightMoveMask(*(char *)(a3 + 24), *(char *)(a3 + 25));
      v7 = MSG_ReadDeltaKey(a1, v9, v5, 4);
      return MSG_ClampForwardRightmove(v7, (_BYTE *)(a4 + 24), (_BYTE *)(a4 + 25));
    }
  }
  return result;
}

//----- (08068E1C) --------------------------------------------------------
int *__cdecl MSG_WriteDeltaField(_DWORD *a1, int a2, int a3, int a4)
{
  int *result; // eax
  int v5; // [esp+14h] [ebp-24h]
  int *v6; // [esp+1Ch] [ebp-1Ch]
  int v7; // [esp+20h] [ebp-18h] BYREF
  int v8; // [esp+24h] [ebp-14h] BYREF
  float v9; // [esp+28h] [ebp-10h]
  int v10; // [esp+2Ch] [ebp-Ch]
  float *v11; // [esp+30h] [ebp-8h]
  _DWORD *v12; // [esp+34h] [ebp-4h]

  v12 = (_DWORD *)(a2 + *(_DWORD *)(a4 + 4));
  v11 = (float *)(a3 + *(_DWORD *)(a4 + 4));
  if ( *v12 == *(_DWORD *)v11 )
    return MSG_WriteBit0(a1);
  MSG_WriteBit1(a1);
  if ( !*(_DWORD *)(a4 + 8) )
  {
    v9 = *v11;
    v10 = (int)v9;
    if ( v9 != 0.0 )
    {
      MSG_WriteBit1(a1);
      if ( (long double)v10 == v9 && (unsigned int)(v10 + 4096) <= 0x1FFF )
      {
        MSG_WriteBit0(a1);
        v10 += 4096;
        MSG_WriteBits(a1, v10, 5);
        return MSG_WriteByte(a1, v10 >> 5);
      }
      goto LABEL_9;
    }
    return MSG_WriteBit0(a1);
  }
  if ( *(_DWORD *)(a4 + 8) != -99 )
  {
    if ( *(_DWORD *)(a4 + 8) == -100 )
    {
      if ( *(_DWORD *)v11 )
      {
        MSG_WriteBit1(a1);
        return MSG_WriteAngle16(a1, *v11);
      }
      return MSG_WriteBit0(a1);
    }
    if ( *(_DWORD *)v11 )
    {
      MSG_WriteBit1(a1);
      v8 = *(_DWORD *)v11;
      v5 = *(_DWORD *)(a4 + 8);
      if ( v5 < 0 )
        v5 = -v5;
      v7 = v5;
      result = (int *)(v5 & 7);
      v6 = result;
      if ( (v5 & 7) != 0 )
      {
        MSG_WriteBits(a1, v8, (int)result);
        v7 -= (int)v6;
        result = &v8;
        v8 >>= (char)v6;
      }
      while ( v7 )
      {
        MSG_WriteByte(a1, v8);
        v8 >>= 8;
        result = &v7;
        v7 -= 8;
      }
      return result;
    }
    return MSG_WriteBit0(a1);
  }
  v9 = *v11;
  v10 = (int)v9;
  if ( v9 == 0.0 )
    return MSG_WriteBit0(a1);
  MSG_WriteBit1(a1);
  if ( (long double)v10 != v9 || (unsigned int)(v10 + 512) > 0x3FF )
  {
LABEL_9:
    MSG_WriteBit1(a1);
    return MSG_WriteLong(a1, *(_DWORD *)v11);
  }
  MSG_WriteBit0(a1);
  v10 += 512;
  MSG_WriteBits(a1, v10, 2);
  return MSG_WriteByte(a1, v10 >> 2);
}

//----- (08069142) --------------------------------------------------------
_DWORD *__cdecl MSG_WriteDeltaObjective(_DWORD *a1, int a2, int a3, int a4, int a5, int a6)
{
  _DWORD *result; // eax
  int j; // [esp+24h] [ebp-4h]
  int i; // [esp+24h] [ebp-4h]

  if ( a4 )
  {
LABEL_7:
    MSG_WriteBit1(a1);
    for ( i = 0; ; ++i )
    {
      result = (_DWORD *)i;
      if ( i >= a5 )
        break;
      MSG_WriteDeltaField(a1, a2, a3, a6 + 12 * i);
    }
  }
  else
  {
    for ( j = 0; j < a5; ++j )
    {
      if ( *(_DWORD *)(a2 + *(_DWORD *)(a6 + 12 * j + 4)) != *(_DWORD *)(a3 + *(_DWORD *)(a6 + 12 * j + 4)) )
        goto LABEL_7;
    }
    return MSG_WriteBit0(a1);
  }
  return result;
}

//----- (080691FC) --------------------------------------------------------
_DWORD *__cdecl MSG_WriteDeltaStruct(_DWORD *a1, int *a2, int *a3, int a4, int a5, int a6, int a7, int a8)
{
  _DWORD *result; // eax
  int i; // [esp+1Ch] [ebp-Ch]
  int j; // [esp+1Ch] [ebp-Ch]
  char *v11; // [esp+20h] [ebp-8h]
  _DWORD *v12; // [esp+24h] [ebp-4h]
  _DWORD *v13; // [esp+24h] [ebp-4h]

  if ( a3 )
  {
    v11 = 0;
    v12 = 0;
    for ( i = a7; ; i += 12 )
    {
      result = v12;
      if ( (int)v12 >= a5 )
        break;
      if ( *(int *)((char *)a2 + *(_DWORD *)(i + 4)) != *(int *)((char *)a3 + *(_DWORD *)(i + 4)) )
        v11 = (char *)v12 + 1;
      v12 = (_DWORD *)((char *)v12 + 1);
    }
    if ( v11 )
    {
      if ( a8 )
        MSG_WriteBit1(a1);
      MSG_WriteBits(a1, *a3, a6);
      MSG_WriteBit0(a1);
      MSG_WriteBit1(a1);
      MSG_WriteByte(a1, (char)v11);
      v13 = 0;
      for ( j = a7; ; j += 12 )
      {
        result = v13;
        if ( (int)v13 >= (int)v11 )
          break;
        MSG_WriteDeltaField(a1, (int)a2, (int)a3, j);
        v13 = (_DWORD *)((char *)v13 + 1);
      }
    }
    else if ( a4 )
    {
      if ( a8 )
        MSG_WriteBit1(a1);
      MSG_WriteBits(a1, *a3, a6);
      MSG_WriteBit0(a1);
      return MSG_WriteBit0(a1);
    }
  }
  else
  {
    if ( a8 )
      MSG_WriteBit1(a1);
    MSG_WriteBits(a1, *a2, a6);
    return MSG_WriteBit1(a1);
  }
  return result;
}

//----- (0806938C) --------------------------------------------------------
_DWORD *__cdecl MSG_WriteDeltaEntity(_DWORD *a1, int *a2, int *a3, int a4)
{
  return MSG_WriteDeltaStruct(a1, a2, a3, a4, 59, 10, (int)&off_813D120, 0);
}
// 813D120: using guessed type char *off_813D120;

//----- (080693DA) --------------------------------------------------------
_DWORD *__cdecl MSG_WriteDeltaArchivedEntity(_DWORD *a1, int *a2, int *a3, int a4)
{
  return MSG_WriteDeltaStruct(a1, a2, a3, a4, 68, 10, (int)&off_813D460, 0);
}
// 813D460: using guessed type char *off_813D460;

//----- (08069428) --------------------------------------------------------
_DWORD *__cdecl MSG_WriteDeltaClient(_DWORD *a1, int *a2, int *a3, int a4)
{
  char s[108]; // [esp+20h] [ebp-78h] BYREF
  int v6; // [esp+8Ch] [ebp-Ch]

  v6 = 22;
  if ( !a2 )
  {
    a2 = (int *)s;
    memset(s, 0, 0x5Cu);
  }
  return MSG_WriteDeltaStruct(a1, a2, a3, a4, v6, 6, (int)&off_813D8E0, 1);
}
// 813D8E0: using guessed type char *off_813D8E0;

//----- (080694A0) --------------------------------------------------------
void __cdecl MSG_ReadDeltaField(_DWORD *a1, int a2, int a3, const char **a4, int a5)
{
  int v5; // [esp+10h] [ebp-28h]
  int v6; // [esp+14h] [ebp-24h]
  int i; // [esp+18h] [ebp-20h]
  int v8; // [esp+1Ch] [ebp-1Ch]
  unsigned int v9; // [esp+28h] [ebp-10h]
  int v10; // [esp+2Ch] [ebp-Ch]
  int v11; // [esp+2Ch] [ebp-Ch]
  int v12; // [esp+2Ch] [ebp-Ch]
  float *v13; // [esp+30h] [ebp-8h]
  float *v14; // [esp+34h] [ebp-4h]

  v14 = (float *)&a4[1][a2];
  v13 = (float *)&a4[1][a3];
  if ( !MSG_ReadBit(a1) )
  {
    *v13 = *v14;
    return;
  }
  if ( a4[2] )
  {
    if ( a4[2] == (const char *)-99 )
    {
      if ( MSG_ReadBit(a1) )
      {
        if ( MSG_ReadBit(a1) )
        {
          *(_DWORD *)v13 = MSG_ReadLong(a1);
          if ( a5 )
LABEL_10:
            Com_Printf("%s:%f ", *a4, *v13);
        }
        else
        {
          v12 = MSG_ReadBits(a1, 2);
          v11 = 4 * MSG_ReadByte(a1) + v12 - 512;
          *v13 = (float)v11;
          if ( a5 )
LABEL_8:
            Com_Printf("%s:%i ", *a4, v11);
        }
      }
      else
      {
        *v13 = 0.0;
      }
    }
    else if ( a4[2] == (const char *)-100 )
    {
      if ( MSG_ReadBit(a1) )
        *v13 = MSG_ReadAngle16(a1);
      else
        *v13 = 0.0;
    }
    else if ( MSG_ReadBit(a1) )
    {
      v9 = (unsigned int)a4[2] >> 31;
      v6 = (int)a4[2];
      if ( v6 < 0 )
        v6 = -v6;
      if ( (v6 & 7) != 0 )
        v5 = MSG_ReadBits(a1, v6 & 7);
      else
        v5 = 0;
      v8 = v5;
      for ( i = v6 & 7; i < v6; i += 8 )
        v8 |= MSG_ReadByte(a1) << i;
      if ( v9 && ((v8 >> (v6 - 1)) & 1) != 0 )
        v8 |= ~((1 << v6) - 1);
      *(_DWORD *)v13 = v8;
      if ( a5 )
        Com_Printf("%s:%i ", *a4, *(_DWORD *)v13);
    }
    else
    {
      *v13 = 0.0;
    }
  }
  else
  {
    if ( !MSG_ReadBit(a1) )
    {
      *v13 = 0.0;
      return;
    }
    if ( !MSG_ReadBit(a1) )
    {
      v10 = MSG_ReadBits(a1, 5);
      v11 = 32 * MSG_ReadByte(a1) + v10 - 4096;
      *v13 = (float)v11;
      if ( !a5 )
        return;
      goto LABEL_8;
    }
    *(_DWORD *)v13 = MSG_ReadLong(a1);
    if ( a5 )
      goto LABEL_10;
  }
}

//----- (080697D8) --------------------------------------------------------
int __cdecl MSG_ReadDeltaObjective(_DWORD *a1, int a2, int a3, int a4, int a5)
{
  int result; // eax
  int i; // [esp+24h] [ebp-4h]
  int j; // [esp+24h] [ebp-4h]

  if ( MSG_ReadBit(a1) )
  {
    for ( i = 0; ; ++i )
    {
      result = i;
      if ( i >= a4 )
        break;
      MSG_ReadDeltaField(a1, a2, a3, (const char **)(a5 + 12 * i), 0);
    }
  }
  else
  {
    for ( j = 0; ; ++j )
    {
      result = j;
      if ( j >= a4 )
        break;
      *(_DWORD *)(a3 + *(_DWORD *)(a5 + 12 * j + 4)) = *(_DWORD *)(a2 + *(_DWORD *)(a5 + 12 * j + 4));
    }
  }
  return result;
}

//----- (0806988A) --------------------------------------------------------
int __cdecl MSG_ReadDeltaStruct(_DWORD *a1, int src, int dest, int a4, int a5, int a6, const char **a7)
{
  const char **v9; // [esp+2Ch] [ebp-Ch]
  const char **v10; // [esp+2Ch] [ebp-Ch]
  int v11; // [esp+30h] [ebp-8h]
  int v12; // [esp+34h] [ebp-4h]
  int v13; // [esp+34h] [ebp-4h]

  if ( MSG_ReadBit(a1) == 1 )
    return 1;
  if ( MSG_ReadBit(a1) )
  {
    v11 = MSG_ReadByte(a1);
    if ( v11 <= a5 )
    {
      *(_DWORD *)dest = a4;
      v12 = 0;
      v9 = a7;
      while ( v12 < v11 )
      {
        MSG_ReadDeltaField(a1, src, dest, v9, 0);
        ++v12;
        v9 += 3;
      }
      v13 = v11;
      v10 = &a7[3 * v11];
      while ( v13 < a5 )
      {
        *(_DWORD *)&v10[1][dest] = *(_DWORD *)&v10[1][src];
        ++v13;
        v10 += 3;
      }
      return 0;
    }
    else
    {
      *a1 = 1;
      return 0;
    }
  }
  else
  {
    memcpy((void *)dest, (const void *)src, 4 * a5 + 4);
    return 0;
  }
}

//----- (080699C8) --------------------------------------------------------
int __cdecl MSG_ReadDeltaEntity(_DWORD *a1, void *src, void *dest, int a4)
{
  return MSG_ReadDeltaStruct(a1, (int)src, (int)dest, a4, 59, 10, (const char **)&off_813D120);
}
// 813D120: using guessed type char *off_813D120;

//----- (08069A0E) --------------------------------------------------------
int __cdecl MSG_ReadDeltaArchivedEntity(_DWORD *a1, void *src, void *dest, int a4)
{
  return MSG_ReadDeltaStruct(a1, (int)src, (int)dest, a4, 68, 10, (const char **)&off_813D460);
}
// 813D460: using guessed type char *off_813D460;

//----- (08069A54) --------------------------------------------------------
int __cdecl MSG_ReadDeltaClient(_DWORD *a1, char *src, void *dest, int a4)
{
  char s[108]; // [esp+20h] [ebp-78h] BYREF
  int v6; // [esp+8Ch] [ebp-Ch]

  v6 = 22;
  if ( !src )
  {
    src = s;
    memset(s, 0, 0x5Cu);
  }
  return MSG_ReadDeltaStruct(a1, (int)src, (int)dest, a4, v6, 6, (const char **)&off_813D8E0);
}
// 813D8E0: using guessed type char *off_813D8E0;

//----- (08069AC4) --------------------------------------------------------
int __cdecl MSG_WriteDeltaHudElems(_DWORD *a1, int a2, int a3, int a4)
{
  int result; // eax
  int v5; // [esp+18h] [ebp-10h]
  int i; // [esp+1Ch] [ebp-Ch]
  unsigned int k; // [esp+20h] [ebp-8h]
  int m; // [esp+20h] [ebp-8h]
  int j; // [esp+24h] [ebp-4h]

  for ( i = 0; i < a4 && *(_DWORD *)(a3 + (i << 7)); ++i )
    ;
  MSG_WriteBits(a1, i, 5);
  for ( j = 0; ; ++j )
  {
    result = j;
    if ( j >= i )
      break;
    v5 = 0;
    for ( k = 0; k <= 0x1F; ++k )
    {
      if ( *(_DWORD *)(dword_815A5E4[3 * k] + a2 + (j << 7)) != *(_DWORD *)(dword_815A5E4[3 * k] + a3 + (j << 7)) )
        v5 = k;
    }
    MSG_WriteBits(a1, v5, 5);
    for ( m = 0; m <= v5; ++m )
      MSG_WriteDeltaField(a1, a2 + (j << 7), a3 + (j << 7), 12 * m + 135636448);
  }
  return result;
}
// 815A5E4: using guessed type int dword_815A5E4[95];

//----- (08069C10) --------------------------------------------------------
void *__cdecl MSG_ReadDeltaHudElems(_DWORD *a1, int a2, int a3, int a4)
{
  int v5; // [esp+14h] [ebp-14h]
  int v6; // [esp+18h] [ebp-10h]
  unsigned int j; // [esp+1Ch] [ebp-Ch]
  int i; // [esp+20h] [ebp-8h]

  v6 = MSG_ReadBits(a1, 5);
  for ( i = 0; i < v6; ++i )
  {
    v5 = MSG_ReadBits(a1, 5);
    for ( j = 0; (int)j <= v5; ++j )
      MSG_ReadDeltaField(a1, a2 + (i << 7), a3 + (i << 7), (const char **)(12 * j + 135636448), 0);
    while ( j <= 0x1F )
    {
      *(_DWORD *)(dword_815A5E4[3 * j] + a3 + (i << 7)) = *(_DWORD *)(dword_815A5E4[3 * j] + a2 + (i << 7));
      ++j;
    }
  }
  return memset((void *)(a3 + (v6 << 7)), 0, (a4 - v6) << 7);
}
// 815A5E4: using guessed type int dword_815A5E4[95];

//----- (08069D40) --------------------------------------------------------
_DWORD *__cdecl MSG_WriteDeltaPlayerstate(_DWORD *a1, char *a2, _DWORD *a3)
{
  int v4; // [esp+20h] [ebp-2718h]
  int v5; // [esp+28h] [ebp-2710h]
  int v6; // [esp+2Ch] [ebp-270Ch]
  float v7; // [esp+30h] [ebp-2708h]
  int v8; // [esp+34h] [ebp-2704h]
  int v9; // [esp+34h] [ebp-2704h]
  float *v10; // [esp+3Ch] [ebp-26FCh]
  char **v11; // [esp+44h] [ebp-26F4h]
  char **v12; // [esp+44h] [ebp-26F4h]
  int v13; // [esp+4Ch] [ebp-26ECh]
  int v14[7]; // [esp+50h] [ebp-26E8h]
  int v15; // [esp+6Ch] [ebp-26CCh]
  char s[9908]; // [esp+70h] [ebp-26C8h] BYREF
  int v17; // [esp+2724h] [ebp-14h]
  int j; // [esp+2728h] [ebp-10h]
  int i; // [esp+272Ch] [ebp-Ch]

  if ( !a2 )
  {
    a2 = s;
    memset(s, 0, 0x26A8u);
  }
  v17 = 0;
  i = 0;
  v11 = &off_813DE80;
  while ( i < 105 )
  {
    if ( *(_DWORD *)&v11[1][(_DWORD)a2] != *(_DWORD *)&v11[1][(_DWORD)a3] )
      v17 = i + 1;
    ++i;
    v11 += 3;
  }
  MSG_WriteByte(a1, v17);
  i = 0;
  v12 = &off_813DE80;
  while ( i < v17 )
  {
    v10 = (float *)&v12[1][(_DWORD)a3];
    if ( *(_DWORD *)&v12[1][(_DWORD)a2] == *(_DWORD *)v10 )
      goto LABEL_11;
    MSG_WriteBit1(a1);
    if ( v12[2] )
    {
      if ( v12[2] == (char *)-100 )
      {
        if ( !*(_DWORD *)v10 )
        {
LABEL_11:
          MSG_WriteBit0(a1);
          goto LABEL_26;
        }
        MSG_WriteBit1(a1);
        MSG_WriteAngle16(a1, *v10);
      }
      else
      {
        v7 = *v10;
        v4 = (int)v12[2];
        if ( v4 < 0 )
          v4 = -v4;
        v6 = v4;
        v5 = v4 & 7;
        if ( (v4 & 7) != 0 )
        {
          MSG_WriteBits(a1, SLODWORD(v7), v5);
          v6 = v4 - v5;
          SLODWORD(v7) >>= v5;
        }
        while ( v6 )
        {
          MSG_WriteByte(a1, SLOBYTE(v7));
          SLODWORD(v7) >>= 8;
          v6 -= 8;
        }
      }
    }
    else
    {
      v8 = (int)*v10;
      if ( (long double)v8 == *v10 && (unsigned int)(v8 + 4096) <= 0x1FFF )
      {
        MSG_WriteBit0(a1);
        v9 = v8 + 4096;
        MSG_WriteBits(a1, v9, 5);
        MSG_WriteByte(a1, v9 >> 5);
      }
      else
      {
        MSG_WriteBit1(a1);
        MSG_WriteLong(a1, *(_DWORD *)v10);
      }
    }
LABEL_26:
    ++i;
    v12 += 3;
  }
  v15 = 0;
  for ( i = 0; i <= 5; ++i )
  {
    if ( a3[i + 75] != *(_DWORD *)&a2[4 * i + 300] )
      v15 |= 1 << i;
  }
  if ( v15 )
  {
    MSG_WriteBit1(a1);
    MSG_WriteBits(a1, v15, 6);
    if ( (v15 & 1) != 0 )
      MSG_WriteShort(a1, a3[75]);
    if ( (v15 & 2) != 0 )
      MSG_WriteShort(a1, a3[76]);
    if ( (v15 & 4) != 0 )
      MSG_WriteShort(a1, a3[77]);
    if ( (v15 & 8) != 0 )
      MSG_WriteBits(a1, a3[78], 6);
    if ( (v15 & 0x10) != 0 )
      MSG_WriteShort(a1, a3[79]);
    if ( (v15 & 0x20) != 0 )
      MSG_WriteByte(a1, a3[80]);
  }
  else
  {
    MSG_WriteBit0(a1);
  }
  for ( j = 0; j <= 3; ++j )
  {
    v14[j] = 0;
    for ( i = 0; i <= 15; ++i )
    {
      if ( a3[16 * j + 81 + i] != *(_DWORD *)&a2[64 * j + 324 + 4 * i] )
        v14[j] |= 1 << i;
    }
  }
  if ( v14[0] || v14[1] || v14[2] || v14[3] )
  {
    MSG_WriteBit1(a1);
    for ( j = 0; j <= 3; ++j )
    {
      if ( v14[j] )
      {
        MSG_WriteBit1(a1);
        MSG_WriteShort(a1, v14[j]);
        for ( i = 0; i <= 15; ++i )
        {
          if ( ((v14[j] >> i) & 1) != 0 )
            MSG_WriteShort(a1, a3[16 * j + 81 + i]);
        }
      }
      else
      {
        MSG_WriteBit0(a1);
      }
    }
  }
  else
  {
    MSG_WriteBit0(a1);
  }
  for ( j = 0; j <= 3; ++j )
  {
    v13 = 0;
    for ( i = 0; i <= 15; ++i )
    {
      if ( a3[16 * j + 209 + i] != *(_DWORD *)&a2[64 * j + 836 + 4 * i] )
        v13 |= 1 << i;
    }
    if ( v13 )
    {
      MSG_WriteBit1(a1);
      MSG_WriteShort(a1, v13);
      for ( i = 0; i <= 15; ++i )
      {
        if ( ((v13 >> i) & 1) != 0 )
          MSG_WriteShort(a1, a3[16 * j + 209 + i]);
      }
    }
    else
    {
      MSG_WriteBit0(a1);
    }
  }
  if ( !memcmp(a2 + 1508, a3 + 377, 0x1C0u) )
  {
    MSG_WriteBit0(a1);
  }
  else
  {
    MSG_WriteBit1(a1);
    for ( i = 0; i <= 15; ++i )
    {
      MSG_WriteBits(a1, a3[7 * i + 377], 3);
      MSG_WriteDeltaObjective(a1, (int)&a2[28 * i + 1508], (int)&a3[7 * i + 377], 0, 6, (int)&off_815A580);
    }
  }
  if ( !memcmp(a2 + 1960, a3 + 490, 0x1F00u) )
    return MSG_WriteBit0(a1);
  MSG_WriteBit1(a1);
  MSG_WriteDeltaHudElems(a1, (int)(a2 + 5928), (int)(a3 + 1482), 31);
  return (_DWORD *)MSG_WriteDeltaHudElems(a1, (int)(a2 + 1960), (int)(a3 + 490), 31);
}
// 813DE80: using guessed type char *off_813DE80;
// 815A580: using guessed type char *off_815A580;

//----- (0806A608) --------------------------------------------------------
void *__cdecl MSG_ReadDeltaPlayerstate(_DWORD *a1, char *a2, char *a3)
{
  int v3; // edx
  int v4; // eax
  long double v5; // fst7
  int v6; // eax
  int v7; // ebx
  int v8; // ebx
  int *v9; // ebx
  void *result; // eax
  int v11; // [esp+2Ch] [ebp-271Ch]
  int v12; // [esp+30h] [ebp-2718h]
  unsigned int v13; // [esp+34h] [ebp-2714h]
  char *v14; // [esp+38h] [ebp-2710h]
  char *v15; // [esp+3Ch] [ebp-270Ch]
  char s[9916]; // [esp+40h] [ebp-2708h] BYREF
  int v17; // [esp+26FCh] [ebp-4Ch]
  int v18; // [esp+2700h] [ebp-48h]
  unsigned int v19; // [esp+2704h] [ebp-44h]
  int v20; // [esp+2708h] [ebp-40h]
  float *v21; // [esp+270Ch] [ebp-3Ch]
  float *v22; // [esp+2710h] [ebp-38h]
  int v23; // [esp+2714h] [ebp-34h]
  int v24; // [esp+2718h] [ebp-30h]
  char **v25; // [esp+271Ch] [ebp-2Ch]
  int v26; // [esp+2720h] [ebp-28h]
  int v27; // [esp+2724h] [ebp-24h]
  int i; // [esp+2728h] [ebp-20h]
  int j; // [esp+272Ch] [ebp-1Ch]

  if ( !a2 )
  {
    a2 = s;
    memset(s, 0, 0x26A8u);
  }
  v15 = a3;
  v14 = a2;
  v13 = 9896;
  if ( ((unsigned __int8)a3 & 4) != 0 )
  {
    *(_DWORD *)a3 = *(_DWORD *)a2;
    v15 = a3 + 4;
    v14 = a2 + 4;
    v13 = 9892;
  }
  qmemcpy(v15, v14, 4 * (v13 >> 2));
  v23 = 0;
  v24 = 105;
  v27 = MSG_ReadByte(a1);
  j = 0;
  v25 = &off_813DE80;
  while ( j < v27 )
  {
    v22 = (float *)&v25[1][(_DWORD)a2];
    v21 = (float *)&v25[1][(_DWORD)a3];
    if ( MSG_ReadBit(a1) )
    {
      if ( v25[2] )
      {
        if ( v25[2] == (char *)-100 )
        {
          if ( MSG_ReadBit(a1) )
          {
            v5 = MSG_ReadAngle16(a1);
            *v21 = v5;
          }
          else
          {
            *v21 = 0.0;
          }
        }
        else
        {
          v19 = (unsigned int)v25[2] >> 31;
          v12 = (int)v25[2];
          if ( v19 )
            v12 = -v12;
          v26 = v12;
          v18 = v12 & 7;
          if ( (v12 & 7) != 0 )
            v11 = MSG_ReadBits(a1, v18);
          else
            v11 = 0;
          v17 = v11;
          for ( i = v18; i < v26; i += 8 )
          {
            v6 = MSG_ReadByte(a1);
            v17 |= v6 << i;
          }
          if ( v19 && ((v17 >> (v26 - 1)) & 1) != 0 )
            v17 |= ~((1 << v26) - 1);
          *(_DWORD *)v21 = v17;
          if ( v23 )
            Com_Printf("%s:%i ", *v25, *(_DWORD *)v21);
        }
      }
      else if ( MSG_ReadBit(a1) )
      {
        v4 = MSG_ReadLong(a1);
        *(_DWORD *)v21 = v4;
        if ( v23 )
          Com_Printf("%s:%f ", *v25, *v21);
      }
      else
      {
        v20 = MSG_ReadBits(a1, 5);
        v3 = 32 * MSG_ReadByte(a1);
        v20 += v3;
        v20 -= 4096;
        *v21 = (float)v20;
        if ( v23 )
          Com_Printf("%s:%i ", *v25, v20);
      }
    }
    else
    {
      *v21 = *v22;
    }
    ++j;
    v25 += 3;
  }
  j = v27;
  v25 = &(&off_813DE80)[3 * v27];
  while ( j < v24 )
  {
    v22 = (float *)&v25[1][(_DWORD)a2];
    v21 = (float *)&v25[1][(_DWORD)a3];
    *v21 = *v22;
    ++j;
    v25 += 3;
  }
  if ( MSG_ReadBit(a1) )
  {
    v26 = MSG_ReadBits(a1, 6);
    if ( (v26 & 1) != 0 )
      *((_DWORD *)a3 + 75) = MSG_ReadShort(a1);
    if ( (v26 & 2) != 0 )
      *((_DWORD *)a3 + 76) = MSG_ReadShort(a1);
    if ( (v26 & 4) != 0 )
      *((_DWORD *)a3 + 77) = MSG_ReadShort(a1);
    if ( (v26 & 8) != 0 )
      *((_DWORD *)a3 + 78) = MSG_ReadBits(a1, 6);
    if ( (v26 & 0x10) != 0 )
      *((_DWORD *)a3 + 79) = MSG_ReadShort(a1);
    if ( (v26 & 0x20) != 0 )
      *((_DWORD *)a3 + 80) = MSG_ReadByte(a1);
  }
  if ( MSG_ReadBit(a1) )
  {
    for ( i = 0; i <= 3; ++i )
    {
      if ( MSG_ReadBit(a1) )
      {
        v26 = MSG_ReadShort(a1);
        for ( j = 0; j <= 15; ++j )
        {
          if ( ((v26 >> j) & 1) != 0 )
          {
            v7 = j + 16 * i;
            *(_DWORD *)&a3[4 * v7 + 324] = MSG_ReadShort(a1);
          }
        }
      }
    }
  }
  for ( i = 0; i <= 3; ++i )
  {
    if ( MSG_ReadBit(a1) )
    {
      v26 = MSG_ReadShort(a1);
      for ( j = 0; j <= 15; ++j )
      {
        if ( ((v26 >> j) & 1) != 0 )
        {
          v8 = j + 16 * i;
          *(_DWORD *)&a3[4 * v8 + 836] = MSG_ReadShort(a1);
        }
      }
    }
  }
  if ( MSG_ReadBit(a1) )
  {
    for ( j = 0; j <= 15; ++j )
    {
      v9 = (int *)&a3[28 * j + 1508];
      *v9 = MSG_ReadBits(a1, 3);
      MSG_ReadDeltaObjective(a1, (int)&a2[28 * j + 1508], (int)&a3[28 * j + 1508], 6, (int)&off_815A580);
    }
  }
  result = (void *)MSG_ReadBit(a1);
  if ( result )
  {
    MSG_ReadDeltaHudElems(a1, (int)(a2 + 5928), (int)(a3 + 5928), 31);
    return MSG_ReadDeltaHudElems(a1, (int)(a2 + 1960), (int)(a3 + 1960), 31);
  }
  return result;
}
// 813DE80: using guessed type char *off_813DE80;
// 815A580: using guessed type char *off_815A580;

//----- (0806AC6A) --------------------------------------------------------
int *MSG_initHuffmanInternal()
{
  int *result; // eax
  int j; // [esp+10h] [ebp-8h]
  int i; // [esp+14h] [ebp-4h] BYREF

  result = (int *)Huff_Init(msgHuff);
  for ( i = 0; i <= 255; ++i )
  {
    for ( j = 0; j < dword_815A760[i]; ++j )
    {
      Huff_addRef(msgHuff, i);
      Huff_addRef(dword_81ED87C, i);
    }
    result = &i;
  }
  return result;
}
// 815A760: using guessed type int dword_815A760[255];
// 81ED87C: using guessed type _DWORD dword_81ED87C[2];

//----- (0806ACDE) --------------------------------------------------------
int *MSG_initHuffman()
{
  msgInit = 1;
  return MSG_initHuffmanInternal();
}
// 81F4898: using guessed type int msgInit;

//----- (0806ACF6) --------------------------------------------------------
int __cdecl MSG_ShortSwap(__int16 a1)
{
  return a1;
}

//----- (0806AD0A) --------------------------------------------------------
int __cdecl MSG_LongSwap(int a1)
{
  return a1;
}

//----- (0806AD14) --------------------------------------------------------
char *__cdecl NET_AdrToString(int a1, int a2, int a3, int a4, int a5)
{
  __int16 v5; // ax

  if ( a1 == 2 )
  {
    Com_sprintf(byte_82021A0, 0x40u, "loopback");
  }
  else
  {
    v5 = BigShort(a3);
    if ( a1 == 4 )
      Com_sprintf(byte_82021A0, 0x40u, "%i.%i.%i.%i:%i", (unsigned __int8)a2, BYTE1(a2), BYTE2(a2), HIBYTE(a2), v5);
    else
      Com_sprintf(
        byte_82021A0,
        0x40u,
        "%02x%02x%02x%02x.%02x%02x%02x%02x%02x%02x:%i",
        BYTE2(a3),
        HIBYTE(a3),
        (unsigned __int8)a4,
        BYTE1(a4),
        BYTE2(a4),
        HIBYTE(a4),
        (unsigned __int8)a5,
        BYTE1(a5),
        BYTE2(a5),
        HIBYTE(a5),
        v5);
  }
  return byte_82021A0;
}

//----- (0806AE1A) --------------------------------------------------------
void **__cdecl NetProf_PrepProfiling(void **a1)
{
  void **result; // eax

  if ( *(_DWORD *)(net_profile + 8) )
  {
    if ( !dword_81F711C )
    {
      if ( !*(_BYTE *)(com_sv_running + 8) || *((_DWORD *)off_815A498 + 1) && *(_DWORD *)(net_profile + 8) == 2 )
        dword_81F711C = 1;
      else
        dword_81F711C = 2;
      Com_Printf("Net Profiling turned on: %s\n", *(const char **)&dword_815AB5C[4 * dword_81F711C]);
    }
    result = a1;
    if ( !*a1 )
    {
      *a1 = malloc(0x5E0u);
      return (void **)memset(*a1, 0, 0x5E0u);
    }
  }
  else
  {
    if ( dword_81F711C )
    {
      dword_81F711C = 0;
      Com_Printf("Net Profiling turned off\n");
    }
    result = a1;
    if ( *a1 )
    {
      free(*a1);
      result = a1;
      *a1 = 0;
    }
  }
  return result;
}
// 815A498: using guessed type void *off_815A498;
// 819EF14: using guessed type int com_sv_running;
// 81F710C: using guessed type int net_profile;
// 81F711C: using guessed type int dword_81F711C;

//----- (0806AF0A) --------------------------------------------------------
int __cdecl sub_806AF0A(int a1, int a2, int a3)
{
  int v3; // ecx
  int result; // eax
  int *v5; // [esp+0h] [ebp-8h]

  v3 = *(_DWORD *)(a1 + 720) + 1;
  *(_DWORD *)(a1 + 720) = v3 / 60;
  *(_DWORD *)(a1 + 720) = v3 - 60 * *(_DWORD *)(a1 + 720);
  v5 = (int *)(a1 + 12 * *(_DWORD *)(a1 + 720));
  *v5 = Sys_MilliSeconds();
  v5[1] = a2;
  result = a3;
  v5[2] = a3;
  return result;
}

//----- (0806AF90) --------------------------------------------------------
void __cdecl sub_806AF90(int a1, int a2, int a3)
{
  if ( dword_81F711C )
  {
    sub_806AF0A(*(_DWORD *)(a1 + 32828), a2, a3);
    if ( (*(_DWORD *)(net_showprofile + 8) & 2) != 0 )
    {
      if ( a3 )
        Com_Printf("%s send%s: %i\n", *(const char **)&off_815AB60[4 * *(_DWORD *)(a1 + 4)], " fragment", a2);
      else
        Com_Printf(
          "%s send%s: %i\n",
          *(const char **)&off_815AB60[4 * *(_DWORD *)(a1 + 4)],
          (const char *)&unk_813E42E,
          a2);
    }
  }
}
// 81F7110: using guessed type int net_showprofile;
// 81F711C: using guessed type int dword_81F711C;

//----- (0806B012) --------------------------------------------------------
void __cdecl sub_806B012(int a1, int a2, int a3)
{
  if ( dword_81F711C )
  {
    sub_806AF0A(*(_DWORD *)(a1 + 32828) + 752, a2, a3);
    if ( (*(_DWORD *)(net_showprofile + 8) & 2) != 0 )
    {
      if ( a3 )
        Com_Printf("%s recieve%s: %i\n", *(const char **)&off_815AB60[4 * *(_DWORD *)(a1 + 4)], " fragment", a2);
      else
        Com_Printf(
          "%s recieve%s: %i\n",
          *(const char **)&off_815AB60[4 * *(_DWORD *)(a1 + 4)],
          (const char *)&unk_813E42E,
          a2);
    }
  }
}
// 81F7110: using guessed type int net_showprofile;
// 81F711C: using guessed type int dword_81F711C;

//----- (0806B09A) --------------------------------------------------------
_DWORD *__cdecl NetProf_UpdateStatistics(_DWORD *a1)
{
  _DWORD *result; // eax
  int v2; // ebx
  int v3; // [esp+10h] [ebp-28h]
  int v4; // [esp+14h] [ebp-24h]
  int v5; // [esp+18h] [ebp-20h]
  int v6; // [esp+1Ch] [ebp-1Ch]
  int v7; // [esp+20h] [ebp-18h]
  int v8; // [esp+24h] [ebp-14h]
  _DWORD *v9; // [esp+28h] [ebp-10h]
  int v10; // [esp+2Ch] [ebp-Ch]
  int i; // [esp+30h] [ebp-8h]

  v10 = 0;
  v9 = 0;
  v8 = -1;
  v7 = Sys_MilliSeconds();
  v5 = 0;
  v4 = 9999;
  v3 = 0;
  for ( i = 0; i <= 59; ++i )
  {
    if ( a1[3 * i] && Sys_MilliSeconds() <= a1[3 * i] + 1000 )
    {
      ++v10;
      if ( a1[3 * i + 2] )
        v9 = (_DWORD *)((char *)v9 + 1);
      if ( a1[3 * i] < v7 )
      {
        v8 = i;
        v7 = a1[3 * i];
      }
      v5 += a1[3 * i + 1];
      if ( a1[3 * i + 1] < v4 )
        v4 = a1[3 * i + 1];
      if ( a1[3 * i + 1] > v3 )
        v3 = a1[3 * i + 1];
    }
  }
  if ( v10 )
  {
    if ( v9 )
      a1[185] = 100 * (int)v9 / v10;
    else
      a1[185] = 0;
    a1[186] = v3;
    a1[187] = v4;
    v2 = a1[182] + 100;
    if ( v2 < Sys_MilliSeconds() )
    {
      v6 = Sys_MilliSeconds() - v7;
      if ( v8 != -1 )
      {
        v5 -= a1[3 * v8 + 1];
        --v10;
        if ( a1[3 * v8 + 2] )
          v9 = (_DWORD *)((char *)v9 - 1);
      }
      if ( v6 > 0 && v10 )
      {
        if ( v5 )
          a1[181] = (int)((long double)v5 / ((long double)v6 * 0.001));
        else
          a1[181] = 0;
        a1[182] = Sys_MilliSeconds();
      }
      else
      {
        a1[181] = 0;
      }
    }
    a1[183] = v10;
    result = v9;
    a1[184] = v9;
  }
  else
  {
    a1[181] = 0;
    a1[182] = 0;
    a1[183] = 0;
    a1[184] = 0;
    a1[185] = 0;
    a1[186] = 0;
    result = a1;
    a1[187] = 0;
  }
  return result;
}

//----- (0806B3D2) --------------------------------------------------------
void Net_DumpProfile_f()
{
  if ( dword_81F711C )
    SV_Netchan_PrintProfileStats(1);
  else
    Com_Printf("Network profiling is not on. Set net_profile to turn on network profiling\n");
}
// 81F711C: using guessed type int dword_81F711C;

//----- (0806B3FE) --------------------------------------------------------
void __usercall Netchan_Init(long double a1@<st0>, unsigned __int16 a2)
{
  showpackets = (int)Dvar_RegisterBool(a1, "showpackets", 0, 4096);
  showdrop = (int)Dvar_RegisterBool(a1, "showdrop", 0, 4096);
  packetDebug = (int)Dvar_RegisterBool(a1, "packetDebug", 0, 4096);
  dword_81F7118 = a2;
  net_profile = (int)Dvar_RegisterInt(a1, "net_profile", 0, 0, 2, 4096);
  net_showprofile = (int)Dvar_RegisterInt(a1, "net_showprofile", 0, 0, 3, 4096);
  net_lanauthorize = (int)Dvar_RegisterBool(a1, "net_lanauthorize", 0, 4096);
  Cmd_AddCommand("net_dumpprofile", (int)Net_DumpProfile_f);
}
// 81F7100: using guessed type int showpackets;
// 81F7104: using guessed type int showdrop;
// 81F7108: using guessed type int packetDebug;
// 81F710C: using guessed type int net_profile;
// 81F7110: using guessed type int net_showprofile;
// 81F7114: using guessed type int net_lanauthorize;
// 81F7118: using guessed type int dword_81F7118;

//----- (0806B510) --------------------------------------------------------
void **__cdecl sub_806B510(void *a1, void **s, void *a3, void *a4, void *a5, void *a6, void *a7, void *a8)
{
  memset(s, 0, 0x8040u);
  s[1] = a1;
  s[4] = a3;
  s[5] = a4;
  s[6] = a5;
  s[7] = a6;
  s[8] = a7;
  s[9] = a8;
  s[3] = 0;
  *s = (void *)1;
  return NetProf_PrepProfiling(s + 8207);
}

//----- (0806B58C) --------------------------------------------------------
_BOOL4 __cdecl Netchan_TransmitNextFragment(int a1)
{
  int v1; // eax
  int v3; // [esp+28h] [ebp-5B0h]
  int n; // [esp+2Ch] [ebp-5ACh]
  int v5[352]; // [esp+30h] [ebp-5A8h] BYREF
  int s[3]; // [esp+5B0h] [ebp-28h] BYREF
  size_t v7; // [esp+5BCh] [ebp-1Ch]

  NetProf_PrepProfiling((void **)(a1 + 32828));
  MSG_Init(s, (int)v5, 1400);
  MSG_WriteLong(s, *(_DWORD *)a1 | 0x80000000);
  if ( *(int *)(a1 + 4) <= 0 )
    MSG_WriteShort(s, *(_DWORD *)(a1 + 36));
  n = 1300;
  if ( *(_DWORD *)(a1 + 16436) + 1300 > *(_DWORD *)(a1 + 16440) )
    n = *(_DWORD *)(a1 + 16440) - *(_DWORD *)(a1 + 16436);
  MSG_WriteShort(s, *(_DWORD *)(a1 + 16436));
  MSG_WriteShort(s, n);
  MSG_WriteData(s, (void *)(a1 + *(_DWORD *)(a1 + 16436) + 16444), n);
  v3 = (unsigned __int8)NET_SendPacket(
                          *(_DWORD *)(a1 + 4),
                          v7,
                          (_DWORD *)s[1],
                          *(_DWORD *)(a1 + 16),
                          *(_DWORD *)(a1 + 20),
                          *(_DWORD *)(a1 + 24),
                          *(_DWORD *)(a1 + 28),
                          *(_DWORD *)(a1 + 32));
  sub_806AF90(a1, v7, 1);
  if ( *(_BYTE *)(showpackets + 8) )
  {
    v1 = sub_806C8C0();
    Com_Printf(
      "[client %i] %s send %4i : s=%i fragment=%i,%i\n",
      v1,
      *(const char **)&off_815AB60[4 * *(_DWORD *)(a1 + 4)],
      v7,
      *(_DWORD *)a1 - 1,
      *(_DWORD *)(a1 + 16436),
      n);
  }
  *(_DWORD *)(a1 + 16436) += n;
  if ( *(_DWORD *)(a1 + 16436) == *(_DWORD *)(a1 + 16440) && n != 1300 )
  {
    ++*(_DWORD *)a1;
    *(_DWORD *)(a1 + 16432) = 0;
  }
  return v3 > 0;
}
// 81F7100: using guessed type int showpackets;
// 806B58C: using guessed type int var_5A8[352];

//----- (0806B7AC) --------------------------------------------------------
_BOOL4 __cdecl Netchan_Transmit(int a1, int n, void *src)
{
  int v3; // eax
  int v6; // [esp+2Ch] [ebp-5ACh]
  int v7[352]; // [esp+30h] [ebp-5A8h] BYREF
  int s[3]; // [esp+5B0h] [ebp-28h] BYREF
  size_t v9; // [esp+5BCh] [ebp-1Ch]

  if ( n > 0x4000 )
    Com_Error(1, (char *)&byte_813E560, n);
  *(_DWORD *)(a1 + 16436) = 0;
  if ( n <= 1299 )
  {
    NetProf_PrepProfiling((void **)(a1 + 32828));
    MSG_Init(s, (int)v7, 1400);
    MSG_WriteLong(s, *(_DWORD *)a1);
    ++*(_DWORD *)a1;
    if ( *(int *)(a1 + 4) <= 0 )
      MSG_WriteShort(s, *(_DWORD *)(a1 + 36));
    if ( *(_BYTE *)(packetDebug + 8) )
      Com_Printf("Adding %i byte payload to packet\n", n);
    MSG_WriteData(s, src, n);
    if ( *(_BYTE *)(packetDebug + 8) )
      Com_Printf("Sending %i byte packet\n", v9);
    v6 = (unsigned __int8)NET_SendPacket(
                            *(_DWORD *)(a1 + 4),
                            v9,
                            (_DWORD *)s[1],
                            *(_DWORD *)(a1 + 16),
                            *(_DWORD *)(a1 + 20),
                            *(_DWORD *)(a1 + 24),
                            *(_DWORD *)(a1 + 28),
                            *(_DWORD *)(a1 + 32));
    sub_806AF90(a1, v9, 0);
    if ( *(_BYTE *)(showpackets + 8) )
    {
      v3 = sub_806C8C0();
      Com_Printf(
        "[client %i] %s send %4i : s=%i ack=%i\n",
        v3 + 1,
        *(const char **)&off_815AB60[4 * *(_DWORD *)(a1 + 4)],
        v9,
        *(_DWORD *)a1 - 1,
        *(_DWORD *)(a1 + 12));
    }
    return v6 > 0;
  }
  else
  {
    *(_DWORD *)(a1 + 16432) = 1;
    *(_DWORD *)(a1 + 16440) = n;
    Com_Memcpy((void *)(a1 + 16444), src, n);
    Netchan_TransmitNextFragment(a1);
    return 1;
  }
}
// 81F7100: using guessed type int showpackets;
// 81F7108: using guessed type int packetDebug;
// 806B7AC: using guessed type int var_5A8[352];

//----- (0806B9CA) --------------------------------------------------------
int __cdecl Netchan_Process(int a1, _DWORD *a2)
{
  int v2; // eax
  char *v3; // ebx
  int v4; // eax
  char *v5; // ebx
  int v6; // eax
  char *v7; // eax
  char *v8; // eax
  char *v9; // eax
  int v12; // [esp+20h] [ebp-18h]
  int n; // [esp+24h] [ebp-14h]
  int v14; // [esp+28h] [ebp-10h]
  int v15; // [esp+30h] [ebp-8h]

  NetProf_PrepProfiling((void **)(a1 + 32828));
  MSG_BeginReading(a2);
  v15 = MSG_ReadLong(a2);
  if ( (v15 & 0x80000000) != 0 )
  {
    v15 &= ~0x80000000;
    v12 = 1;
  }
  else
  {
    v12 = 0;
  }
  if ( *(_DWORD *)(a1 + 4) == 1 )
    MSG_ReadShort(a2);
  if ( v12 )
  {
    v14 = MSG_ReadShort(a2);
    n = MSG_ReadShort(a2);
  }
  else
  {
    v14 = 0;
    n = 0;
  }
  sub_806B012(a1, a2[3], v12);
  if ( *(_BYTE *)(showpackets + 8) )
  {
    v2 = sub_806C8C0();
    if ( v12 )
      Com_Printf(
        "[client %i] %s recv %4i : s=%i fragment=%i,%i\n",
        v2 + 1,
        *(const char **)&off_815AB60[4 * *(_DWORD *)(a1 + 4)],
        a2[3],
        v15,
        v14,
        n);
    else
      Com_Printf(
        "[client %i] %s recv %4i : s=%i\n",
        v2 + 1,
        *(const char **)&off_815AB60[4 * *(_DWORD *)(a1 + 4)],
        a2[3],
        v15);
  }
  if ( v15 <= *(_DWORD *)(a1 + 12) )
  {
    if ( *(_BYTE *)(showdrop + 8) || *(_BYTE *)(showpackets + 8) )
    {
      v3 = NET_AdrToString(
             *(_DWORD *)(a1 + 16),
             *(_DWORD *)(a1 + 20),
             *(_DWORD *)(a1 + 24),
             *(_DWORD *)(a1 + 28),
             *(_DWORD *)(a1 + 32));
      v4 = sub_806C8C0();
      Com_Printf("[client %i] %s:Out of order packet %i at %i\n", v4 + 1, v3, v15, *(_DWORD *)(a1 + 12));
    }
    return 0;
  }
  *(_DWORD *)(a1 + 8) = v15 - *(_DWORD *)(a1 + 12) - 1;
  if ( *(int *)(a1 + 8) > 0 && (*(_BYTE *)(showdrop + 8) || *(_BYTE *)(showpackets + 8)) )
  {
    v5 = NET_AdrToString(
           *(_DWORD *)(a1 + 16),
           *(_DWORD *)(a1 + 20),
           *(_DWORD *)(a1 + 24),
           *(_DWORD *)(a1 + 28),
           *(_DWORD *)(a1 + 32));
    v6 = sub_806C8C0();
    Com_Printf("[client %i] %s: Dropped %i packets at %i\n", v6 + 1, v5, *(_DWORD *)(a1 + 8), v15);
  }
  if ( !v12 )
  {
LABEL_42:
    *(_DWORD *)(a1 + 12) = v15;
    return 1;
  }
  if ( v15 != *(_DWORD *)(a1 + 40) )
  {
    *(_DWORD *)(a1 + 40) = v15;
    *(_DWORD *)(a1 + 44) = 0;
  }
  if ( v14 != *(_DWORD *)(a1 + 44) )
  {
    if ( *(_BYTE *)(showdrop + 8) || *(_BYTE *)(showpackets + 8) )
    {
      v7 = NET_AdrToString(
             *(_DWORD *)(a1 + 16),
             *(_DWORD *)(a1 + 20),
             *(_DWORD *)(a1 + 24),
             *(_DWORD *)(a1 + 28),
             *(_DWORD *)(a1 + 32));
      Com_Printf("%s:Dropped a message fragment\n", v7);
    }
    return 0;
  }
  if ( n >= 0 && n + a2[4] <= a2[3] && (unsigned int)(n + *(_DWORD *)(a1 + 44)) <= 0x4000 )
  {
    memcpy((void *)(a1 + *(_DWORD *)(a1 + 44) + 48), (const void *)(a2[1] + a2[4]), n);
    *(_DWORD *)(a1 + 44) += n;
    if ( n == 1300 )
      return 0;
    if ( *(_DWORD *)(a1 + 44) > a2[2] )
    {
      v9 = NET_AdrToString(
             *(_DWORD *)(a1 + 16),
             *(_DWORD *)(a1 + 20),
             *(_DWORD *)(a1 + 24),
             *(_DWORD *)(a1 + 28),
             *(_DWORD *)(a1 + 32));
      Com_Printf("%s:fragmentLength %i > msg->maxsize\n", v9, *(_DWORD *)(a1 + 44));
      return 0;
    }
    *(_DWORD *)a2[1] = sub_806C8B8(v15);
    memcpy((void *)(a2[1] + 4), (const void *)(a1 + 48), *(_DWORD *)(a1 + 44));
    a2[3] = *(_DWORD *)(a1 + 44) + 4;
    *(_DWORD *)(a1 + 44) = 0;
    MSG_BeginReading(a2);
    MSG_ReadLong(a2);
    goto LABEL_42;
  }
  if ( *(_BYTE *)(showdrop + 8) || *(_BYTE *)(showpackets + 8) )
  {
    v8 = NET_AdrToString(
           *(_DWORD *)(a1 + 16),
           *(_DWORD *)(a1 + 20),
           *(_DWORD *)(a1 + 24),
           *(_DWORD *)(a1 + 28),
           *(_DWORD *)(a1 + 32));
    Com_Printf("%s:illegal fragment length\n", v8);
  }
  return 0;
}
// 81F7100: using guessed type int showpackets;
// 81F7104: using guessed type int showdrop;

//----- (0806BE8E) --------------------------------------------------------
int __cdecl NET_CompareBaseAdrSigned(int a1, int a2)
{
  if ( *(_DWORD *)a1 != *(_DWORD *)a2 )
    return *(_DWORD *)a1 - *(_DWORD *)a2;
  switch ( *(_DWORD *)a1 )
  {
    case 2:
      return *(unsigned __int16 *)(a1 + 8) - *(unsigned __int16 *)(a2 + 8);
    case 0:
      return *(unsigned __int16 *)(a1 + 8) - *(unsigned __int16 *)(a2 + 8);
    case 4:
      return memcmp((const void *)(a1 + 4), (const void *)(a2 + 4), 4u);
    case 5:
      return memcmp((const void *)(a1 + 10), (const void *)(a2 + 10), 0xAu);
  }
  Com_Printf("NET_CompareBaseAdrSigned: bad address type\n");
  return 0;
}

//----- (0806BF64) --------------------------------------------------------
_BOOL4 __cdecl NET_CompareBaseAdr(char a1, int a2, int a3, int a4, int a5, char a6)
{
  return NET_CompareBaseAdrSigned((int)&a1, (int)&a6) == 0;
}

//----- (0806BF92) --------------------------------------------------------
int __cdecl NET_CompareAdrSigned(int a1, int a2)
{
  if ( *(_DWORD *)a1 != *(_DWORD *)a2 )
    return *(_DWORD *)a1 - *(_DWORD *)a2;
  switch ( *(_DWORD *)a1 )
  {
    case 2:
      return 0;
    case 4:
      if ( *(_WORD *)(a1 + 8) == *(_WORD *)(a2 + 8) )
        return memcmp((const void *)(a1 + 4), (const void *)(a2 + 4), 4u);
      else
        return *(unsigned __int16 *)(a1 + 8) - *(unsigned __int16 *)(a2 + 8);
    case 5:
      if ( *(_WORD *)(a1 + 8) == *(_WORD *)(a2 + 8) )
        return memcmp((const void *)(a1 + 10), (const void *)(a2 + 10), 0xAu);
      else
        return *(unsigned __int16 *)(a1 + 8) - *(unsigned __int16 *)(a2 + 8);
    default:
      Com_Printf("NET_CompareAdrSigned: bad address type\n");
      return 0;
  }
}

//----- (0806C08C) --------------------------------------------------------
_BOOL4 __cdecl NET_CompareAdr(char a1, int a2, int a3, int a4, int a5, char a6)
{
  return NET_CompareAdrSigned((int)&a1, (int)&a6) == 0;
}

//----- (0806C0BA) --------------------------------------------------------
int __cdecl NET_IsLocalAddress(int a1)
{
  int v2; // [esp+0h] [ebp-4h]

  v2 = 0;
  if ( a1 == 2 || !a1 )
    return 1;
  return v2;
}

//----- (0806C0E0) --------------------------------------------------------
int __cdecl NET_GetPacket(int *a1, int a2)
{
  return Sys_GetPacket(a1, a2);
}

//----- (0806C0FA) --------------------------------------------------------
int __cdecl NET_GetLoopPacketInternal(int a1, _DWORD *s, int a3)
{
  char *v5; // [esp+1Ch] [ebp-Ch]
  int v6; // [esp+20h] [ebp-8h]

  v5 = (char *)&unk_81F7180 + 22536 * a1;
  if ( *((_DWORD *)v5 + 5633) - *((_DWORD *)v5 + 5632) > 16 )
    *((_DWORD *)v5 + 5632) = *((_DWORD *)v5 + 5633) - 16;
  if ( *((_DWORD *)v5 + 5632) >= *((_DWORD *)v5 + 5633) )
    return 0;
  v6 = (*((_DWORD *)v5 + 5632))++ & 0xF;
  memcpy(*(void **)(a3 + 4), &v5[1408 * v6], *(_DWORD *)&v5[1408 * v6 + 1400]);
  *(_DWORD *)(a3 + 12) = *(_DWORD *)&v5[1408 * v6 + 1400];
  memset(s, 0, 0x14u);
  *s = 2;
  *((_WORD *)s + 4) = *(_WORD *)&v5[1408 * v6 + 1404];
  return 1;
}

//----- (0806C240) --------------------------------------------------------
int __cdecl NET_GetLoopPacket(int a1, _DWORD *s, int a3)
{
  return NET_GetLoopPacketInternal(a1, s, a3);
}

//----- (0806C262) --------------------------------------------------------
int __cdecl NET_SendLoopPacket(int a1, size_t n, void *src, int a4, int a5, unsigned __int16 a6)
{
  int result; // eax
  int v7; // [esp+Ch] [ebp-Ch]
  char *v8; // [esp+10h] [ebp-8h]
  int v9; // [esp+14h] [ebp-4h]

  v7 = 0;
  if ( a1 > 0 )
  {
    if ( a1 == 1 )
      a1 = a6;
  }
  else
  {
    v7 = a1;
    a1 = 1;
  }
  v8 = (char *)&unk_81F7180 + 22536 * a1;
  v9 = (*((_DWORD *)v8 + 5633))++ & 0xF;
  memcpy(&v8[1408 * v9], src, n);
  *(_DWORD *)&v8[1408 * v9 + 1400] = n;
  result = v7;
  *(_DWORD *)&v8[1408 * v9 + 1404] = v7;
  return result;
}

//----- (0806C32C) --------------------------------------------------------
int __cdecl NET_SendPacket(int a1, size_t n, _DWORD *src, int a4, int a5, int a6, int a7, int a8)
{
  int v8; // eax

  if ( *(_BYTE *)(showpackets + 8) && *src == -1 )
  {
    v8 = sub_806C8C0();
    Com_Printf("[client %i] send packet %4i\n", v8, n);
  }
  if ( a4 == 2 )
  {
    NET_SendLoopPacket(a1, n, src, 2, a5, a6);
    return 1;
  }
  else if ( a4 == 1 )
  {
    return 0;
  }
  else if ( a4 )
  {
    return (unsigned __int8)Sys_SendPacket(n, src, a4, a5, a6, a7, a8);
  }
  else
  {
    return 0;
  }
}
// 81F7100: using guessed type int showpackets;
// 806C32C: using guessed type int arg_14;

//----- (0806C40C) --------------------------------------------------------
_BOOL4 __cdecl NET_OutOfBandPrint(int a1, int a2, int a3, int a4, int a5, int a6, char *s)
{
  size_t v7; // eax
  size_t v8; // eax
  _BOOL4 v9; // ebx
  char *v12; // [esp+2Ch] [ebp-2Ch]
  int v13[6]; // [esp+30h] [ebp-28h] BYREF
  int v14; // [esp+48h] [ebp-10h]
  size_t n; // [esp+4Ch] [ebp-Ch]

  LargeLocal(v13, 0x4000);
  v12 = LargeLocalGetBuf(v13);
  *v12 = -1;
  v12[1] = -1;
  v12[2] = -1;
  v12[3] = -1;
  if ( *(_BYTE *)(showpackets + 8) )
    Com_DPrintf("OOB Print: %s\n", s);
  if ( strlen(s) + 1 <= 0x3FFC )
  {
    v8 = strlen(s);
    memcpy(v12 + 4, s, v8 + 1);
    n = strlen(v12);
    v14 = (unsigned __int8)NET_SendPacket(a1, n, v12, a2, a3, a4, a5, a6);
    if ( a1 == 1 )
      SV_Netchan_AddOOBProfilePacket(n);
    v9 = v14 > 0;
    LargeLocalDealloc(v13);
    return v9;
  }
  else
  {
    v7 = strlen(s);
    Com_DPrintf("OOB Packet is %i bytes - too large to send\n", v7);
    LargeLocalDealloc(v13);
    return 0;
  }
}
// 81F7100: using guessed type int showpackets;
// 806C40C: using guessed type int var_28[6];
// 806C40C: using guessed type int arg_C;

//----- (0806C57E) --------------------------------------------------------
_BOOL4 __cdecl NET_OutOfBandData(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8)
{
  _BOOL4 v8; // ebx
  char *v10; // [esp+2Ch] [ebp-5Ch]
  int v11[7]; // [esp+30h] [ebp-58h] BYREF
  int v12; // [esp+4Ch] [ebp-3Ch]
  void *src; // [esp+54h] [ebp-34h]
  size_t n; // [esp+5Ch] [ebp-2Ch]
  int i; // [esp+7Ch] [ebp-Ch]

  LargeLocal(v11, 0x4000);
  v10 = LargeLocalGetBuf(v11);
  *v10 = -1;
  v10[1] = -1;
  v10[2] = -1;
  v10[3] = -1;
  for ( i = 0; i < a8; ++i )
    v10[i + 4] = *(_BYTE *)(a7 + i);
  src = v10;
  n = a8 + 4;
  v12 = (unsigned __int8)NET_SendPacket(a1, a8 + 4, v10, a2, a3, a4, a5, a6);
  if ( a1 == 1 )
    SV_Netchan_AddOOBProfilePacket(n);
  v8 = v12 > 0;
  LargeLocalDealloc(v11);
  return v8;
}
// 806C57E: using guessed type int var_58[7];
// 806C57E: using guessed type int arg_C;

//----- (0806C69C) --------------------------------------------------------
int __cdecl NET_OutOfBandVoiceData(int a1, int a2, int a3, int a4, int a5, int a6, void *src, size_t n)
{
  int result; // eax
  int v9; // [esp+40h] [ebp-8008h] BYREF
  int v10; // [esp+44h] [ebp-8004h] BYREF

  v9 = -1;
  memcpy(&v10, src, n);
  result = NET_SendPacket(a1, n + 4, &v9, a2, a3, a4, a5, a6);
  if ( a1 == 1 )
    return SV_Netchan_AddOOBProfilePacket(n + 4);
  return result;
}
// 806C69C: using guessed type int arg_C;

//----- (0806C750) --------------------------------------------------------
int __cdecl NET_StringToAdr(char *s1, _DWORD *s)
{
  __int16 v2; // ax
  const char *nptr; // [esp+1Ch] [ebp-41Ch]
  char haystack[1036]; // [esp+20h] [ebp-418h] BYREF

  if ( !strcmp(s1, "localhost") )
  {
    memset(s, 0, 0x14u);
    *s = 2;
    return 1;
  }
  else
  {
    I_strncpyz(haystack, s1, 1024);
    nptr = strstr(haystack, ":");
    if ( nptr )
      *nptr++ = 0;
    if ( sub_80D2CF0(haystack, (int)s) )
    {
      if ( *((_BYTE *)s + 4) == 0xFF
        && *((_BYTE *)s + 5) == 0xFF
        && *((_BYTE *)s + 6) == 0xFF
        && *((_BYTE *)s + 7) == 0xFF )
      {
        *s = 1;
        return 0;
      }
      else
      {
        if ( nptr )
        {
          v2 = atoi(nptr);
          *((_WORD *)s + 4) = BigShort(v2);
        }
        else
        {
          *((_WORD *)s + 4) = BigShort(28960);
        }
        return 1;
      }
    }
    else
    {
      *s = 1;
      return 0;
    }
  }
}

//----- (0806C8B8) --------------------------------------------------------
int __cdecl sub_806C8B8(int a1)
{
  return a1;
}

//----- (0806C8C0) --------------------------------------------------------
int sub_806C8C0()
{
  return 0;
}

//----- (0806C8EA) --------------------------------------------------------
void *sub_806C8EA()
{
  void *result; // eax

  result = memset(&unk_82021E0, 0, 0x38u);
  dword_8202218 = 0;
  return result;
}
// 8202218: using guessed type int dword_8202218;

//----- (0806C918) --------------------------------------------------------
int __cdecl SetAnimCheck(int a1)
{
  int result; // eax

  result = a1;
  dword_8202428 = a1;
  return result;
}
// 8202428: using guessed type int dword_8202428;

//----- (0806C926) --------------------------------------------------------
char *__cdecl sub_806C926(const char *a1)
{
  int v2; // [esp+14h] [ebp-4h]

  v2 = Com_GetLastTokenPos();
  Com_EndParseSession();
  return CompileError(v2 - dword_8202220, "%s", a1);
}
// 8202220: using guessed type int dword_8202220;

//----- (0806C95E) --------------------------------------------------------
int sub_806C95E()
{
  int v1; // [esp+Ch] [ebp-Ch]
  int i; // [esp+10h] [ebp-8h]
  char *s1; // [esp+14h] [ebp-4h]

  v1 = 0;
  while ( 1 )
  {
    s1 = Com_ParseOnLine((char **)&dword_8202224);
    if ( !*s1 )
      return v1;
    for ( i = 0; (unsigned int)i <= 2 && strcasecmp(s1, (&off_815AB68)[i]); ++i )
      ;
    if ( i == 1 )
    {
      v1 |= 2u;
    }
    else if ( i > 1 )
    {
      if ( i == 2 )
        v1 |= 8u;
      else
LABEL_16:
        sub_806C926("unknown anim property");
    }
    else
    {
      if ( i )
        goto LABEL_16;
      v1 |= 1u;
    }
  }
}
// 8202224: using guessed type int dword_8202224;

//----- (0806CA12) --------------------------------------------------------
int __cdecl sub_806CA12(_DWORD *a1, unsigned int a2, int a3)
{
  int result; // eax
  __int16 *v4; // eax
  __int16 *v5; // edx
  int v6; // [esp+8h] [ebp-10h]
  int v7; // [esp+8h] [ebp-10h]
  int v8[2]; // [esp+10h] [ebp-8h] BYREF

  v6 = FindVariable(a3, a2);
  if ( v6 )
  {
    v4 = sub_807C4FC(v6);
    *a1 = *(_DWORD *)v4;
    v5 = v4;
    result = (int)a1;
    *(_DWORD *)v5 = a1;
  }
  else
  {
    v7 = sub_807C0CC(a3, a2);
    *a1 = 0;
    v8[1] = 7;
    v8[0] = (int)a1;
    return sub_807C45C(v7, v8);
  }
  return result;
}

//----- (0806CA94) --------------------------------------------------------
char *__cdecl sub_806CA94(_DWORD *a1, unsigned int a2, int a3)
{
  if ( dword_8202448 )
    return (char *)sub_806CA12(a1, a2, dword_8202448);
  else
    return CompileError(a3, "#using_animtree was not specified");
}
// 8202448: using guessed type int dword_8202448;

//----- (0806CADC) --------------------------------------------------------
int __cdecl AnimTreeParseInternal(int a1, int a2, char a3, char a4, char a5)
{
  int v5; // eax
  int v6; // eax
  int v8; // [esp+20h] [ebp-28h]
  char v9; // [esp+25h] [ebp-23h]
  unsigned __int8 v10; // [esp+26h] [ebp-22h]
  char v11; // [esp+27h] [ebp-21h]
  int v12; // [esp+28h] [ebp-20h]
  int v13; // [esp+2Ch] [ebp-1Ch]
  int v14[2]; // [esp+30h] [ebp-18h] BYREF
  int v15; // [esp+38h] [ebp-10h]
  int v16; // [esp+3Ch] [ebp-Ch]
  char *v17; // [esp+40h] [ebp-8h]
  char v18; // [esp+45h] [ebp-3h]
  char v19; // [esp+46h] [ebp-2h]
  char v20; // [esp+47h] [ebp-1h]

  v20 = a3;
  v19 = a4;
  v18 = a5;
  v14[1] = 6;
  v15 = 0;
  v16 = 0;
  v12 = 0;
  v11 = 0;
  while ( 1 )
  {
    while ( 1 )
    {
      while ( 1 )
      {
        v17 = Com_Parse((char **)&dword_8202224);
        if ( !dword_8202224 )
        {
          v10 = 1;
          goto LABEL_46;
        }
        if ( !(unsigned __int8)sub_8075828(v17) )
          break;
        if ( v11 )
          sub_807C16E(a1, v15);
        v15 = sub_807939E(v17, 2u);
        if ( FindVariable(a1, v15) )
          sub_806C926("duplicate animation");
        v16 = sub_807C0A8(a1, v15);
        v9 = 0;
        if ( !v18 && !FindVariable(a2, v15) && !dword_8202428 )
          v9 = 1;
        v11 = v9;
        v12 = 0;
        v17 = Com_ParseOnLine((char **)&dword_8202224);
        if ( *v17 )
        {
          if ( (unsigned __int8)sub_8075828(v17) )
            sub_806C926("FIXME: aliases not yet implemented");
          if ( *v17 != 58 || v17[1] )
            sub_806C926("bad token");
          v12 = sub_806C95E();
          v17 = Com_Parse((char **)&dword_8202224);
          if ( *v17 != 123 || v17[1] )
            sub_806C926("properties cannot be applied to primitive animations");
          break;
        }
      }
      if ( *v17 != 123 )
        break;
      if ( v17[1] )
        sub_806C926("bad token");
      if ( *Com_ParseOnLine((char **)&dword_8202224) )
        sub_806C926("token not allowed after '{'");
      if ( !v16 )
        sub_806C926("no animation specified for this block");
      v13 = sub_807CAD2(v16);
      v8 = 0;
      if ( v18 || (v12 & 8) != 0 && !v11 )
        v8 = 1;
      if ( (unsigned __int8)AnimTreeParseInternal(v13, a2, (unsigned __int8)v11 ^ 1, v12 & 1, v8) )
        sub_806C926("unexpected end of file");
      if ( sub_807C9AC(v13) )
      {
        v14[0] = v12;
        v5 = sub_807C060(v13, 0);
        sub_807C45C(v5, v14);
      }
      else
      {
        sub_807C16E(a1, v15);
      }
      v16 = 0;
      v11 = 0;
    }
    if ( *v17 == 125 )
      break;
    sub_806C926("bad token");
  }
  if ( v17[1] )
    sub_806C926("bad token");
  if ( *Com_ParseOnLine((char **)&dword_8202224) )
    sub_806C926("token not allowed after '}'");
  v10 = 0;
LABEL_46:
  if ( v11 )
    sub_807C16E(a1, v15);
  if ( v20 && !sub_807C9AC(a1) )
  {
    if ( v19 )
      v6 = SL_GetString("void_loop", 0);
    else
      v6 = SL_GetString("void", 0);
    v15 = v6;
    sub_807C0A8(a1, v6);
    SL_RemoveRefToString(v15);
  }
  return v10;
}
// 8202224: using guessed type int dword_8202224;
// 8202428: using guessed type int dword_8202428;

//----- (0806CE74) --------------------------------------------------------
_DWORD *__cdecl sub_806CE74(int a1, int a2, int a3)
{
  Com_BeginParseSession("Scr_AnimTreeParse");
  dword_8202224 = a1;
  dword_8202220 = a1;
  if ( !(unsigned __int8)AnimTreeParseInternal(a2, a3, 1, 0, 0) )
    sub_806C926("bad token");
  return Com_EndParseSession();
}
// 8202220: using guessed type int dword_8202220;
// 8202224: using guessed type int dword_8202224;

//----- (0806CED4) --------------------------------------------------------
void *__cdecl sub_806CED4(size_t n)
{
  return Hunk_AllocAlignInternal(n, 4);
}

//----- (0806CEF0) --------------------------------------------------------
int __cdecl sub_806CEF0(int a1)
{
  int v1; // eax
  int v3; // [esp+Ch] [ebp-Ch]
  int i; // [esp+14h] [ebp-4h]

  v3 = 0;
  for ( i = sub_807C9CE(a1); i; i = sub_807C9CE(i) )
  {
    if ( GetVariableName(i) <= 0xFFFF )
    {
      if ( GetVarType(i) == 1 )
      {
        v1 = sub_807CB1E(i);
        v3 += sub_806CEF0(v1);
      }
      else
      {
        ++v3;
      }
    }
  }
  if ( v3 )
    ++v3;
  return v3;
}

//----- (0806CF7E) --------------------------------------------------------
int __cdecl sub_806CF7E(int a1, __int16 a2, int a3, int a4, __int16 a5)
{
  int result; // eax
  int v6; // ebx
  int v7; // eax
  int v8; // [esp+10h] [ebp-18h]
  _DWORD *v9; // [esp+14h] [ebp-14h]
  _DWORD *i; // [esp+18h] [ebp-10h]
  __int16 *v11; // [esp+1Ch] [ebp-Ch]

  result = FindVariable(a1, a4);
  if ( result )
  {
    v11 = sub_807C4FC(result);
    if ( !*(_DWORD *)v11 )
    {
      v6 = SL_ConvertToString(a3);
      v7 = SL_ConvertToString(a4);
      Com_Error(1, (char *)&byte_813E9E0, v7, v6);
    }
    LOWORD(v8) = a2;
    HIWORD(v8) = a5;
    for ( i = *(_DWORD **)v11; i; i = v9 )
    {
      v9 = (_DWORD *)*i;
      *i = v8;
    }
    result = (int)v11;
    *(_DWORD *)v11 = 0;
  }
  return result;
}

//----- (0806D074) --------------------------------------------------------
int __cdecl Scr_GetAnims(int a1)
{
  return dword_820264C[a1];
}
// 820264C: using guessed type int dword_820264C[128];

//----- (0806D084) --------------------------------------------------------
int __cdecl sub_806D084(int a1, int a2, int a3, int a4, char *s, int a6, int a7, int a8)
{
  char *v8; // ebx
  int v9; // eax
  char *v10; // eax
  unsigned __int16 v12; // [esp+20h] [ebp-18h]
  int v13; // [esp+24h] [ebp-14h]
  int v14; // [esp+28h] [ebp-10h]
  unsigned int v15; // [esp+2Ch] [ebp-Ch]
  int i; // [esp+30h] [ebp-8h]
  int j; // [esp+30h] [ebp-8h]
  int v18; // [esp+4Ch] [ebp+14h]
  int v19; // [esp+54h] [ebp+1Ch]

  v14 = 0;
  for ( i = sub_807C9CE(a1); i; i = sub_807C9CE(i) )
  {
    if ( GetVariableName(i) <= 0xFFFF )
      ++v14;
  }
  v13 = FindArrayVariable(a1, 0);
  if ( v13 )
    v12 = *sub_807C4FC(v13);
  else
    v12 = 0;
  dword_839403C *= 31;
  dword_839403C += a6;
  dword_839403C *= 31;
  dword_839403C += a4;
  dword_839403C *= 31;
  dword_839403C += v14;
  dword_839403C *= 31;
  dword_839403C += v12;
  sub_80BA57A(a3, a6, s, a4, v14, v12);
  v19 = a4;
  v18 = v14 + a4;
  for ( j = sub_807C9CE(a1); j; j = sub_807C9CE(j) )
  {
    v15 = GetVariableName(j);
    if ( v15 <= 0xFFFF )
    {
      sub_806CF7E(a2, v19, a7, (unsigned __int16)v15, a8);
      if ( GetVarType(j) == 1 )
      {
        v8 = (char *)SL_ConvertToString(v15);
        v9 = sub_807CB1E(j);
        v18 = sub_806D084(v9, a2, a3, v18, v8, v19, a7, a8);
      }
      else
      {
        dword_839403C *= 31;
        dword_839403C += v19;
        v10 = (char *)SL_ConvertToString(v15);
        sub_80BA4D8(a3, v19, v10);
      }
      ++v19;
    }
  }
  return v18;
}
// 839403C: using guessed type int dword_839403C;

//----- (0806D2DC) --------------------------------------------------------
int __cdecl sub_806D2DC(int a1, int a2)
{
  int result; // eax
  const char *v3; // ebx
  const char *v4; // eax
  char *v5; // [esp+14h] [ebp-14h]
  __int16 *v6; // [esp+18h] [ebp-10h]
  int i; // [esp+1Ch] [ebp-Ch]
  int v8; // [esp+20h] [ebp-8h]

  result = sub_807C9CE(a1);
  for ( i = result; i; i = result )
  {
    v8 = GetVariableName(i);
    v6 = sub_807C4FC(i);
    if ( *(_DWORD *)v6 )
    {
      v3 = (const char *)SL_ConvertToString(a2);
      v4 = (const char *)SL_ConvertToString(v8);
      v5 = va("animation '%s' not defined in anim tree '%s'", v4, v3);
      if ( Scr_IsInOpcodeMemory(*(_DWORD *)v6) )
        sub_80780F6(*(const char **)v6, "%s", v5);
      Com_Error(1, (char *)&byte_813EA4D, v5);
    }
    result = sub_807C9CE(i);
  }
  return result;
}

//----- (0806D3B4) --------------------------------------------------------
int __cdecl sub_806D3B4(int a1)
{
  int result; // eax
  int v2; // eax
  char *v3; // eax
  unsigned int v4; // [esp+10h] [ebp-8h]
  int i; // [esp+14h] [ebp-4h]

  result = sub_807C9CE(a1);
  for ( i = result; i; i = result )
  {
    v4 = GetVariableName(i);
    if ( v4 <= 0xFFFF )
    {
      if ( GetVarType(i) == 1 )
      {
        v2 = sub_807CB1E(i);
        sub_806D3B4(v2);
      }
      else
      {
        v3 = (char *)SL_ConvertToString(v4);
        sub_80BA3AE(v3, (int (__cdecl *)(int))sub_806CED4);
      }
    }
    result = sub_807C9CE(i);
  }
  return result;
}

//----- (0806D43C) --------------------------------------------------------
int __cdecl sub_806D43C(char *a1, int *a2, int a3)
{
  int v3; // eax
  int i; // [esp+14h] [ebp-14h]
  int v6; // [esp+18h] [ebp-10h]
  int v7; // [esp+18h] [ebp-10h]
  int v8; // [esp+1Ch] [ebp-Ch]
  int v9; // [esp+1Ch] [ebp-Ch]
  int v10; // [esp+20h] [ebp-8h]
  int v11; // [esp+24h] [ebp-4h]

  v11 = sub_8079C2A(a1);
  v8 = FindVariable(dword_8202440, v11);
  if ( v8 )
  {
    v7 = sub_807CB1E(v8);
    *a2 = 0;
    for ( i = 1; i <= dword_820284C[a3]; ++i )
    {
      if ( (unsigned __int16)word_8202228[128 * a3 + i] == v8 )
      {
        *a2 = i;
        break;
      }
    }
    v3 = sub_807C0A8(v7, 0);
  }
  else
  {
    v9 = sub_807C0CC(dword_8202440, v11);
    v6 = sub_807CA86(v9);
    word_8202228[128 * a3 + ++dword_820284C[a3]] = v9;
    *a2 = dword_820284C[a3];
    v3 = sub_807C0A8(v6, 0);
  }
  v10 = sub_807CAD2(v3);
  SL_RemoveRefToString(v11);
  return v10;
}
// 8202228: using guessed type __int16 word_8202228[256];
// 8202440: using guessed type int dword_8202440;
// 820284C: using guessed type int dword_820284C[];

//----- (0806D55A) --------------------------------------------------------
char *__cdecl sub_806D55A(char *a1, int a2)
{
  char *result; // eax

  if ( !(unsigned __int8)sub_8075828(a1) )
    return CompileError(a2, "bad anim tree name");
  result = (char *)sub_806D43C(a1, &dword_8202854, 1);
  dword_8202448 = (int)result;
  return result;
}
// 8202448: using guessed type int dword_8202448;
// 8202854: using guessed type int dword_8202854;

//----- (0806D5A6) --------------------------------------------------------
_BOOL4 __cdecl sub_806D5A6(const char *a1, int a2, int a3)
{
  int v5; // [esp+24h] [ebp-54h]
  int v6; // [esp+28h] [ebp-50h]
  char *v7; // [esp+2Ch] [ebp-4Ch]
  char s[72]; // [esp+30h] [ebp-48h] BYREF

  sprintf(s, "animtrees/%s.atr", a1);
  v5 = *(_DWORD *)dword_8283EE0;
  v7 = sub_807799E(0, s, 0, 1u);
  if ( !v7 )
    return 0;
  v6 = *(_DWORD *)dword_8283EDC;
  *(_DWORD *)dword_8283EDC = s;
  sub_806CE74((int)v7, a2, a3);
  *(_DWORD *)dword_8283EDC = v6;
  *(_DWORD *)dword_8283EE0 = v5;
  Hunk_ClearTempMemoryHighInternal();
  return sub_807C9AC(a2) != 0;
}

//----- (0806D668) --------------------------------------------------------
int __cdecl sub_806D668(int a1, int (__cdecl *a2)(int), int a3)
{
  int result; // eax
  const char *v4; // eax
  const char *v5; // eax
  char *v6; // eax
  char *v7; // eax
  int v8; // eax
  int v9; // [esp+20h] [ebp-28h]
  int v10; // [esp+24h] [ebp-24h]
  int v11; // [esp+28h] [ebp-20h]
  char **v12; // [esp+2Ch] [ebp-1Ch]
  int v13; // [esp+30h] [ebp-18h]
  int v14; // [esp+38h] [ebp-10h]
  int v15; // [esp+3Ch] [ebp-Ch]
  int v16; // [esp+3Ch] [ebp-Ch]
  int v17[2]; // [esp+40h] [ebp-8h] BYREF

  v9 = (unsigned __int16)word_8202228[128 * a3 + a1];
  v13 = (unsigned __int16)GetVariableName(v9);
  v10 = sub_807CB1E(v9);
  result = FindVariable(v10, 1);
  if ( !result )
  {
    v15 = FindVariable(v10, 0);
    if ( v15 )
    {
      v16 = sub_807CB1E(v15);
      dword_8202444 = sub_807B658();
      v4 = (const char *)SL_ConvertToString(v13);
      if ( !sub_806D5A6(v4, dword_8202444, v16) )
      {
        v5 = (const char *)SL_ConvertToString(v13);
        v6 = va("unknown anim tree '%s'", v5);
        Com_Error(1, v6);
      }
      v14 = sub_806CEF0(dword_8202444);
      v7 = (char *)SL_ConvertToString(v13);
      v12 = sub_80BA626(v7, v14, a2);
      v11 = SL_GetString("root", 0);
      sub_806CF7E(v16, 0, v13, v11, a1);
      SL_RemoveRefToString(v11);
      sub_806D3B4(dword_8202444);
      sub_806D084(dword_8202444, v16, (int)v12, 1, "root", 0, v13, a1);
      sub_806D2DC(v16, v13);
      sub_807C16E(v10, 0);
      RemoveRefToObject(dword_8202444);
      dword_8202444 = 0;
      v17[1] = 7;
      v17[0] = (int)v12;
      v8 = sub_807C0A8(v10, 1u);
      sub_807C45C(v8, v17);
      sub_80C006C(v12);
      result = (int)v12;
      dword_820244C[128 * a3 + a1] = (int)v12;
    }
    else
    {
      result = 0;
      dword_820244C[128 * a3 + a1] = 0;
    }
  }
  return result;
}
// 8202228: using guessed type __int16 word_8202228[256];
// 820244C: using guessed type int dword_820244C[128];

//----- (0806D8CE) --------------------------------------------------------
_DWORD *__userpurge sub_806D8CE@<eax>(_DWORD *a1, char *a2)
{
  int v3[5]; // [esp+8h] [ebp-20h] BYREF
  int v4; // [esp+1Ch] [ebp-Ch]
  int v5; // [esp+20h] [ebp-8h]
  int v6; // [esp+24h] [ebp-4h]

  v5 = sub_8079C2A(a2);
  v6 = FindVariable(dword_8202440, v5);
  SL_RemoveRefToString(v5);
  *a1 = 0;
  if ( v6 )
  {
    v5 = (unsigned __int16)GetVariableName(v6);
    v6 = sub_807CB1E(v6);
    v4 = FindVariable(v6, 1);
    if ( v4 )
    {
      sub_807C66A(v3, v4);
      v3[2] = v3[0];
      v3[3] = v3[1];
      *a1 = v3[0];
    }
  }
  return a1;
}
// 8202440: using guessed type int dword_8202440;

//----- (0806D982) --------------------------------------------------------
int __cdecl Scr_FindAnim(char *a1, char *s, _DWORD *a3, int a4)
{
  int v4; // eax
  int v6; // [esp+10h] [ebp-8h] BYREF
  int v7; // [esp+14h] [ebp-4h]

  v7 = sub_807939E(s, 0);
  v4 = sub_806D43C(a1, &v6, a4);
  sub_806CA12(a3, v7, v4);
  return SL_RemoveRefToString(v7);
}

//----- (0806D9EC) --------------------------------------------------------
int __cdecl sub_806D9EC(int a1)
{
  int result; // eax

  if ( !byte_820287C )
    return SL_RemoveRefToString(a1);
  return result;
}
// 820287C: using guessed type char byte_820287C;

//----- (0806DA0A) --------------------------------------------------------
int __cdecl sub_806DA0A(int a1)
{
  int result; // eax
  _WORD *v2; // ebx

  dword_8202860 = TempMallocAlign(2);
  if ( dword_8202A68 == 2 )
    return sub_806D9EC(a1);
  if ( byte_820287C )
    sub_807951E(a1);
  v2 = (_WORD *)dword_8202860;
  result = sub_80759F2(a1);
  *v2 = result;
  return result;
}
// 8202860: using guessed type int dword_8202860;
// 820287C: using guessed type char byte_820287C;
// 8202A68: using guessed type int dword_8202A68;

//----- (0806DA66) --------------------------------------------------------
int __cdecl sub_806DA66(int a1)
{
  int result; // eax
  unsigned __int8 v2; // [esp+7h] [ebp-1h]

  v2 = byte_820287C;
  byte_820287C = 1;
  sub_806DA0A(a1);
  result = v2;
  byte_820287C = v2;
  return result;
}
// 820287C: using guessed type char byte_820287C;

//----- (0806DA94) --------------------------------------------------------
int __cdecl sub_806DA94(int a1, unsigned __int8 a2)
{
  if ( dword_8202A68 == 2 )
    return sub_806D9EC(a1);
  if ( byte_820287C )
    sub_807951E(a1);
  return sub_80794D8(a1, a2);
}
// 820287C: using guessed type char byte_820287C;
// 8202A68: using guessed type int dword_8202A68;

//----- (0806DAD8) --------------------------------------------------------
int __cdecl sub_806DAD8(int a1, int a2, int a3)
{
  int result; // eax
  unsigned int v4; // [esp+Ch] [ebp-Ch]
  unsigned int v5; // [esp+Ch] [ebp-Ch]
  int v6; // [esp+10h] [ebp-8h]
  int i; // [esp+14h] [ebp-4h]

  if ( dword_8202A40 )
  {
    v6 = dword_8202A40;
    dword_8202A40 = 0;
    for ( i = 0; i < v6; ++i )
      sub_806EE00((int *)(12 * i + 136325308));
  }
  byte_8202A65 = 0;
  if ( !dword_8202870 || a3 == 2 || a3 == 3 )
    byte_8202A65 = 1;
  dword_8202870 += a2;
  if ( dword_8202874 < dword_8202870 )
    dword_8202874 = dword_8202870;
  if ( a3 && dword_8202878 < dword_8202870 )
    dword_8202878 = dword_8202870;
  dword_839403C *= 31;
  dword_839403C += a1;
  if ( dword_8202A6C )
  {
    dword_8202860 = dword_8202A6C;
    switch ( a1 )
    {
      case ' ':
        if ( *(_BYTE *)dword_8202A6C == 30 )
        {
          sub_8076FAE();
          result = dword_8202A6C;
          *(_BYTE *)dword_8202A6C = 31;
          return result;
        }
        v4 = *(unsigned __int8 *)dword_8202A6C - 24;
        if ( v4 > 5 )
          goto LABEL_61;
        sub_8076FAE();
        *(_BYTE *)dword_8202A6C = 31;
        return sub_806DF8E(v4);
      case '#':
        if ( *(_BYTE *)dword_8202A6C == 55 )
        {
          sub_8076FAE();
          result = dword_8202A6C;
          *(_BYTE *)dword_8202A6C = 34;
          return result;
        }
        if ( *(_BYTE *)dword_8202A6C != 54 )
          goto LABEL_61;
        sub_8076FAE();
        result = dword_8202A6C;
        *(_BYTE *)dword_8202A6C = 33;
        return result;
      case '*':
        if ( *(_BYTE *)dword_8202A6C == 38 )
        {
          result = dword_8202A6C;
          *(_BYTE *)dword_8202A6C = 41;
          return result;
        }
        if ( *(_BYTE *)dword_8202A6C == 13 )
        {
          result = dword_8202A6C;
          *(_BYTE *)dword_8202A6C = 39;
          return result;
        }
        if ( *(_BYTE *)dword_8202A6C != 14 )
          goto LABEL_61;
        result = dword_8202A6C;
        *(_BYTE *)dword_8202A6C = 40;
        return result;
      case '.':
        if ( *(_BYTE *)dword_8202A6C == 38 )
        {
          result = dword_8202A6C;
          *(_BYTE *)dword_8202A6C = 45;
          return result;
        }
        if ( *(_BYTE *)dword_8202A6C == 13 )
        {
          result = dword_8202A6C;
          *(_BYTE *)dword_8202A6C = 43;
          return result;
        }
        if ( *(_BYTE *)dword_8202A6C != 14 )
          goto LABEL_61;
        result = dword_8202A6C;
        *(_BYTE *)dword_8202A6C = 44;
        return result;
      case '1':
        if ( *(_BYTE *)dword_8202A6C != 22 )
          goto LABEL_61;
        result = dword_8202A6C;
        *(_BYTE *)dword_8202A6C = 48;
        return result;
      case '9':
        switch ( *(_BYTE *)dword_8202A6C )
        {
          case '7':
            sub_8076FAE();
            result = dword_8202A6C;
            *(_BYTE *)dword_8202A6C = 61;
            return result;
          case '6':
            sub_8076FAE();
            result = dword_8202A6C;
            *(_BYTE *)dword_8202A6C = 60;
            return result;
          case '-':
            sub_8076FAE();
            result = dword_8202A6C;
            *(_BYTE *)dword_8202A6C = 59;
            return result;
          case '+':
            sub_8076FAE();
            result = dword_8202A6C;
            *(_BYTE *)dword_8202A6C = 56;
            return result;
        }
        if ( *(_BYTE *)dword_8202A6C != 44 )
          goto LABEL_61;
        sub_8076FAE();
        result = dword_8202A6C;
        *(_BYTE *)dword_8202A6C = 58;
        return result;
      case 'P':
        if ( *(_BYTE *)dword_8202A6C != 78 )
          goto LABEL_61;
        result = dword_8202A6C;
        *(_BYTE *)dword_8202A6C = 79;
        return result;
      case 'R':
        if ( *(_BYTE *)dword_8202A6C != 15 )
          goto LABEL_61;
        sub_8076FAE();
        *(_BYTE *)dword_8202A6C = 80;
        result = dword_8202864;
        if ( *(_BYTE *)dword_8202864 == 78 )
        {
          TempMemorySetPos(dword_8202A6C);
          --dword_8202A6C;
          dword_8202864 = 0;
          dword_8202860 = dword_8202A6C;
          result = dword_8202A6C;
          *(_BYTE *)dword_8202A6C = 79;
        }
        return result;
      case 'V':
        if ( *(_BYTE *)dword_8202A6C != 15 )
          goto LABEL_61;
        sub_8076FAE();
        result = dword_8202A6C;
        *(_BYTE *)dword_8202A6C = 84;
        return result;
      case 'Y':
        if ( *(_BYTE *)dword_8202A6C == 30 )
        {
          result = dword_8202A6C;
          *(_BYTE *)dword_8202A6C = 90;
          return result;
        }
        v5 = *(unsigned __int8 *)dword_8202A6C - 24;
        if ( v5 > 5 )
          goto LABEL_61;
        *(_BYTE *)dword_8202A6C = 90;
        result = sub_806DF8E(v5);
        break;
      case '^':
        if ( *(_BYTE *)dword_8202A6C != 92 )
          goto LABEL_61;
        sub_8076FAE();
        result = dword_8202A6C;
        *(_BYTE *)dword_8202A6C = 95;
        return result;
      default:
        goto LABEL_61;
    }
  }
  else
  {
LABEL_61:
    dword_8202864 = dword_8202A6C;
    dword_8202A6C = TempMalloc(1);
    dword_8202860 = dword_8202A6C;
    result = (unsigned __int8)a1;
    *(_BYTE *)dword_8202A6C = a1;
  }
  return result;
}
// 8202860: using guessed type int dword_8202860;
// 8202864: using guessed type int dword_8202864;
// 8202870: using guessed type int dword_8202870;
// 8202874: using guessed type int dword_8202874;
// 8202878: using guessed type int dword_8202878;
// 8202A40: using guessed type int dword_8202A40;
// 8202A65: using guessed type char byte_8202A65;
// 8202A6C: using guessed type int dword_8202A6C;
// 839403C: using guessed type int dword_839403C;

//----- (0806DEC6) --------------------------------------------------------
int sub_806DEC6()
{
  return sub_806DAD8(0, 0, 0);
}

//----- (0806DEEA) --------------------------------------------------------
int sub_806DEEA()
{
  return sub_806DAD8(1, -1, 0);
}

//----- (0806DF0E) --------------------------------------------------------
int __cdecl sub_806DF0E(int a1)
{
  int result; // eax

  dword_8202860 = TempMallocAlign(4);
  result = a1;
  *(_DWORD *)dword_8202860 = a1;
  return result;
}
// 8202860: using guessed type int dword_8202860;

//----- (0806DF32) --------------------------------------------------------
int __cdecl sub_806DF32(unsigned __int16 a1)
{
  int result; // eax

  dword_8202860 = TempMallocAlign(2);
  result = a1;
  *(_WORD *)dword_8202860 = a1;
  return result;
}
// 8202860: using guessed type int dword_8202860;

//----- (0806DF60) --------------------------------------------------------
int __cdecl sub_806DF60(unsigned __int16 a1)
{
  int result; // eax

  dword_8202860 = TempMallocAlign(2);
  result = a1;
  *(_WORD *)dword_8202860 = a1;
  return result;
}
// 8202860: using guessed type int dword_8202860;

//----- (0806DF8E) --------------------------------------------------------
int __cdecl sub_806DF8E(unsigned __int8 a1)
{
  int result; // eax

  dword_8202860 = TempMalloc(1);
  result = a1;
  *(_BYTE *)dword_8202860 = a1;
  return result;
}
// 8202860: using guessed type int dword_8202860;

//----- (0806DFBA) --------------------------------------------------------
int __cdecl sub_806DFBA(int a1)
{
  int result; // eax

  dword_8202860 = TempMallocAlignStrict(4);
  result = a1;
  *(_DWORD *)dword_8202860 = a1;
  return result;
}
// 8202860: using guessed type int dword_8202860;

//----- (0806DFDE) --------------------------------------------------------
int __cdecl sub_806DFDE(int a1)
{
  int result; // eax

  dword_8202860 = TempMallocAlign(2);
  result = a1;
  *(_WORD *)dword_8202860 = a1;
  return result;
}
// 8202860: using guessed type int dword_8202860;

//----- (0806E004) --------------------------------------------------------
int __cdecl sub_806E004(int a1)
{
  int result; // eax

  dword_8202860 = TempMallocAlign(4);
  result = a1;
  *(_DWORD *)dword_8202860 = a1;
  return result;
}
// 8202860: using guessed type int dword_8202860;

//----- (0806E028) --------------------------------------------------------
int __cdecl sub_806E028(int a1, int a2)
{
  int result; // eax

  *(_DWORD *)(a2 + 4) = 0;
  result = a1;
  *(_DWORD *)(a2 + 8) = a1;
  return result;
}

//----- (0806E042) --------------------------------------------------------
void __cdecl sub_806E042(int a1)
{
  sub_806DAD8(2, 1, 0);
  sub_8076D92(a1, 1);
}
// 806DAD8: using guessed type _DWORD __cdecl sub_806DAD8(_DWORD, _DWORD, _DWORD);

//----- (0806E07A) --------------------------------------------------------
int __cdecl sub_806E07A(int a1, int a2, _DWORD *a3)
{
  int result; // eax

  a3[1] = 6;
  *a3 = a1;
  result = a2;
  a3[2] = a2;
  return result;
}

//----- (0806E09C) --------------------------------------------------------
void __cdecl sub_806E09C(int a1, int a2)
{
  if ( a1 < 0 )
  {
    if ( a1 > -256 )
    {
      sub_806DAD8(5, 1, 0);
      sub_8076D92(a2, 1);
      sub_806DF8E(-(char)a1);
      return;
    }
    if ( a1 > -65536 )
    {
      sub_806DAD8(7, 1, 0);
      sub_8076D92(a2, 1);
      sub_806DF60(-(__int16)a1);
      return;
    }
  }
  else
  {
    if ( !a1 )
    {
      sub_806DAD8(3, 1, 0);
      sub_8076D92(a2, 1);
      return;
    }
    if ( a1 <= 255 )
    {
      sub_806DAD8(4, 1, 0);
      sub_8076D92(a2, 1);
      sub_806DF8E(a1);
      return;
    }
    if ( a1 <= 0xFFFF )
    {
      sub_806DAD8(6, 1, 0);
      sub_8076D92(a2, 1);
      sub_806DF60(a1);
      return;
    }
  }
  sub_806DAD8(8, 1, 0);
  sub_8076D92(a2, 1);
  sub_806DF0E(a1);
}
// 806DAD8: using guessed type _DWORD __cdecl sub_806DAD8(_DWORD, _DWORD, _DWORD);

//----- (0806E250) --------------------------------------------------------
int __cdecl sub_806E250(int a1, int a2, _DWORD *a3)
{
  int result; // eax

  a3[1] = 5;
  *a3 = a1;
  result = a2;
  a3[2] = a2;
  return result;
}

//----- (0806E272) --------------------------------------------------------
int __cdecl sub_806E272(int a1, int a2)
{
  sub_806DAD8(9, 1, 0);
  sub_8076D92(a2, 1);
  return sub_806DFBA(a1);
}
// 806DAD8: using guessed type _DWORD __cdecl sub_806DAD8(_DWORD, _DWORD, _DWORD);

//----- (0806E2B4) --------------------------------------------------------
void __cdecl sub_806E2B4(int a1)
{
  if ( dword_8202854 )
    sub_806E09C(dword_8202854, a1);
  else
    CompileError(a1, "#using_animtree was not specified");
}
// 8202854: using guessed type int dword_8202854;

//----- (0806E2EE) --------------------------------------------------------
void __cdecl sub_806E2EE(int a1)
{
  sub_806DAD8(57, -1, 0);
  sub_8076D92(a1, 0);
}

//----- (0806E326) --------------------------------------------------------
int __cdecl sub_806E326(int a1, int a2, int a3)
{
  while ( a2 < *(_DWORD *)(a1 + 12) )
  {
    if ( *(_DWORD *)(a1 + 4 * a2 + 24) == a3 )
      return a2;
    ++a2;
  }
  return -1;
}

//----- (0806E36A) --------------------------------------------------------
int __cdecl sub_806E36A(int a1, int a2, char a3, int a4)
{
  const char *v4; // eax
  int i; // [esp+18h] [ebp-10h]

  if ( !a4 )
    goto LABEL_16;
  for ( i = 0; ; ++i )
  {
    if ( i >= *(_DWORD *)(a4 + 12) )
      goto LABEL_13;
    if ( i == *(_DWORD *)(a4 + 4) )
    {
      ++*(_DWORD *)(a4 + 4);
      sub_806DAD8(22, 0, 0);
      sub_806DA66(*(_DWORD *)(a4 + 4 * i + 24));
    }
    if ( *(_DWORD *)(a4 + 4 * i + 24) == a1 )
      break;
  }
  sub_806D9EC(a1);
  if ( (*(_BYTE *)(a4 + (i >> 3) + 16) & (unsigned __int8)(1 << (i & 7))) != 0 )
    return *(_DWORD *)(a4 + 4) - i - 1;
  if ( a3 && !byte_82028B0 )
  {
    *(_BYTE *)(a4 + (i >> 3) + 16) |= 1 << (i & 7);
    return *(_DWORD *)(a4 + 4) - i - 1;
  }
LABEL_13:
  if ( !a3 || byte_82028B0 )
  {
    v4 = (const char *)SL_ConvertToString(a1);
    CompileError(a2, "uninitialised variable '%s'", v4);
    return 0;
  }
  else
  {
LABEL_16:
    CompileError(a2, "unreachable code");
    return 0;
  }
}
// 82028B0: using guessed type char byte_82028B0;

//----- (0806E4CA) --------------------------------------------------------
int __cdecl sub_806E4CA(int a1)
{
  int result; // eax
  int i; // [esp+14h] [ebp-4h]

  result = *(_DWORD *)(a1 + 4);
  if ( result != *(_DWORD *)(a1 + 8) )
  {
    for ( i = *(_DWORD *)(a1 + 4); i < *(_DWORD *)(a1 + 8); ++i )
    {
      sub_806DAD8(22, 0, 0);
      sub_806DA66(*(_DWORD *)(a1 + 4 * i + 24));
    }
    result = a1;
    *(_DWORD *)(a1 + 4) = *(_DWORD *)(a1 + 8);
  }
  return result;
}

//----- (0806E53A) --------------------------------------------------------
int __cdecl sub_806E53A(_DWORD *a1, int a2)
{
  int result; // eax
  unsigned __int8 v3; // [esp+14h] [ebp-4h]

  result = (int)a1;
  if ( !*a1 )
  {
    result = a1[1] - *(_DWORD *)(a2 + 8);
    v3 = result;
    if ( result )
    {
      sub_806DAD8(23, 0, 0);
      sub_806DF8E(v3);
      result = a1[2];
      a1[1] = result;
    }
  }
  return result;
}

//----- (0806E59A) --------------------------------------------------------
int __cdecl sub_806E59A(char a1, int a2, _DWORD *a3)
{
  int result; // eax
  int v4; // [esp+10h] [ebp-8h]

  v4 = dword_839403C;
  if ( a1 )
  {
    sub_806DEC6();
    sub_8076D92(a2, 1);
  }
  else
  {
    sub_806E53A(a3, (int)a3);
  }
  result = v4 + 1;
  dword_839403C = v4 + 1;
  return result;
}
// 839403C: using guessed type int dword_839403C;

//----- (0806E5EC) --------------------------------------------------------
void __cdecl sub_806E5EC(int a1)
{
  if ( a1 > 1023 )
    Com_Error(1, "MAX_SWITCH_CASES exceeded");
}

//----- (0806E614) --------------------------------------------------------
void __cdecl sub_806E614(int a1)
{
  if ( a1 > 63 )
    Com_Error(1, "LOCAL_VAR_STACK_SIZE exceeded");
}

//----- (0806E638) --------------------------------------------------------
_DWORD *__cdecl sub_806E638(_DWORD *a1, int a2, _DWORD *a3)
{
  _DWORD *result; // eax
  int i; // [esp+4h] [ebp-4h]

  result = a3;
  if ( !*a3 )
  {
    for ( i = 0; i < a3[3]; ++i )
    {
      result = (_DWORD *)a3[i + 6];
      if ( result == a1 )
        return result;
    }
    sub_806E614(a3[3]);
    a3[a3[3] + 6] = a1;
    result = a3;
    ++a3[3];
  }
  return result;
}

//----- (0806E69A) --------------------------------------------------------
_DWORD *__cdecl sub_806E69A(_DWORD *a1, size_t *a2)
{
  _DWORD *result; // eax
  unsigned int v3; // [esp+10h] [ebp-18h]
  const void *v4; // [esp+14h] [ebp-14h]
  _DWORD *v5; // [esp+18h] [ebp-10h]

  if ( !*a2 )
    *a2 = Hunk_AllocateTempMemoryHighInternal(280);
  v5 = (_DWORD *)*a2;
  v4 = a1;
  v3 = 280;
  if ( (*a2 & 4) != 0 )
  {
    *v5++ = *a1;
    v4 = a1 + 1;
    v3 = 276;
  }
  qmemcpy(v5, v4, 4 * (v3 >> 2));
  result = (_DWORD *)*a2;
  *(_DWORD *)(*a2 + 8) = 0;
  return result;
}

//----- (0806E714) --------------------------------------------------------
int __cdecl sub_806E714(int a1, int a2, int a3)
{
  int result; // eax
  int v4; // [esp+0h] [ebp-20h]
  int v5; // [esp+8h] [ebp-18h]
  int i; // [esp+Ch] [ebp-14h]
  int k; // [esp+Ch] [ebp-14h]
  int j; // [esp+10h] [ebp-10h]

  if ( a2 )
  {
    v4 = *(_DWORD *)(*(_DWORD *)a1 + 8);
    for ( i = 1; i < a2; ++i )
    {
      v5 = *(_DWORD *)(a1 + 4 * i);
      if ( *(_DWORD *)(v5 + 8) < v4 )
        v4 = *(_DWORD *)(v5 + 8);
    }
    *(_DWORD *)(a3 + 4) = v4;
    for ( j = 0; ; ++j )
    {
      result = j;
      if ( j >= v4 )
        break;
      if ( (((int)*(unsigned __int8 *)(a3 + (j >> 3) + 16) >> (j & 7)) & 1) == 0 )
      {
        for ( k = 0; k < a2; ++k )
        {
          if ( (((unsigned __int8)((int)*(unsigned __int8 *)(*(_DWORD *)(a1 + 4 * k) + (j >> 3) + 16) >> (j & 7)) ^ 1) & 1) != 0 )
            goto LABEL_15;
        }
        *(_BYTE *)(a3 + (j >> 3) + 16) |= 1 << (j & 7);
      }
LABEL_15:
      ;
    }
  }
  return result;
}

//----- (0806E846) --------------------------------------------------------
void __cdecl sub_806E846(int a1, int a2, _DWORD *a3)
{
  int v3; // [esp+1Ch] [ebp-Ch]
  int i; // [esp+20h] [ebp-8h]
  int k; // [esp+20h] [ebp-8h]
  int j; // [esp+24h] [ebp-4h]

  if ( a2 && !*a3 )
  {
    for ( i = 0; i < a2; ++i )
      **(_DWORD **)(a1 + 4 * i) = 0;
    for ( j = 0; j < *(_DWORD *)(*(_DWORD *)a1 + 12); ++j )
    {
      v3 = *(_DWORD *)(*(_DWORD *)a1 + 4 * j + 24);
      if ( sub_806E326((int)a3, 0, v3) < 0 )
      {
        for ( k = 1; k < a2; ++k )
        {
          if ( sub_806E326(*(_DWORD *)(a1 + 4 * k), 0, v3) < 0 )
            goto LABEL_14;
        }
        a3[a3[3]++ + 6] = v3;
      }
LABEL_14:
      ;
    }
  }
}

//----- (0806E94E) --------------------------------------------------------
void __cdecl sub_806E94E(int a1, int a2, _DWORD *a3)
{
  int v3; // [esp+14h] [ebp-14h]
  int v4; // [esp+18h] [ebp-10h]
  int i; // [esp+1Ch] [ebp-Ch]
  int v6; // [esp+20h] [ebp-8h]
  int j; // [esp+24h] [ebp-4h]

  if ( a2 && !*a3 )
  {
    for ( i = 0; i < a2; ++i )
    {
      v3 = *(_DWORD *)(a1 + 4 * i);
      *(_DWORD *)(v3 + 8) = a3[3];
      for ( j = 0; j < a3[3]; ++j )
      {
        v4 = a3[j + 6];
        v6 = sub_806E326(v3, j, v4);
        if ( v6 < 0 )
        {
          v6 = *(_DWORD *)(v3 + 12);
          sub_806E614(v6);
          ++*(_DWORD *)(v3 + 12);
        }
        while ( v6 > j )
        {
          *(_DWORD *)(v3 + 4 * v6 + 24) = *(_DWORD *)(v3 + 4 * v6 + 20);
          --v6;
        }
        *(_DWORD *)(v3 + 4 * j + 24) = v4;
      }
    }
  }
}

//----- (0806EA5A) --------------------------------------------------------
_DWORD *__cdecl sub_806EA5A(int a1, _DWORD *a2)
{
  _DWORD *result; // eax
  int v3; // [esp+10h] [ebp-18h]
  int v4; // [esp+14h] [ebp-14h]
  int i; // [esp+18h] [ebp-10h]

  for ( i = 0; i < a2[2] || i < *(_DWORD *)(a1 + 4); ++i )
  {
    v3 = *(_DWORD *)(a1 + 4 * i + 24);
    v4 = sub_806E326((int)a2, i, v3);
    if ( v4 < 0 )
    {
      v4 = a2[3];
      sub_806E614(v4);
      ++a2[3];
    }
    if ( v4 >= a2[2] )
      ++a2[2];
    while ( v4 > i )
    {
      a2[v4 + 6] = a2[v4 + 5];
      --v4;
    }
    a2[i + 6] = v3;
    if ( (((int)*(unsigned __int8 *)(a1 + (i >> 3) + 16) >> (i & 7)) & 1) != 0 )
      *((_BYTE *)a2 + (i >> 3) + 16) |= 1 << (i & 7);
  }
  a2[1] = *(_DWORD *)(a1 + 4);
  result = a2;
  *a2 = 0;
  return result;
}

//----- (0806EB94) --------------------------------------------------------
void __cdecl sub_806EB94(int a1, int a2, int a3)
{
  int v3; // [esp+14h] [ebp-4h]

  v3 = sub_806E36A(a1, a2, 1, a3);
  if ( v3 )
    sub_806DAD8(50, 0, 0);
  else
    sub_806DAD8(49, 0, 0);
  if ( v3 )
    sub_806DF8E(v3);
  sub_8076D92(a2, 0);
}

//----- (0806EC16) --------------------------------------------------------
_DWORD *__cdecl sub_806EC16(_DWORD *a1, int a2, _DWORD *a3)
{
  return sub_806E638(a1, a2, a3);
}

//----- (0806EC38) --------------------------------------------------------
void __cdecl sub_806EC38(int a1, int a2, int a3)
{
  unsigned __int8 v3; // [esp+14h] [ebp-4h]

  v3 = sub_806E36A(a1, a2, 1, a3);
  sub_806DAD8(51, 0, 0);
  sub_806DF8E(v3);
  sub_8076D92(a2, 0);
}

//----- (0806ECA0) --------------------------------------------------------
int __cdecl sub_806ECA0(int a1, int a2, _DWORD *a3)
{
  int result; // eax

  a3[1] = 2;
  *a3 = a1;
  result = a2;
  a3[2] = a2;
  return result;
}

//----- (0806ECC2) --------------------------------------------------------
int __cdecl sub_806ECC2(int a1, int a2)
{
  sub_806DAD8(10, 1, 0);
  sub_8076D92(a2, 1);
  sub_806DFDE(a1);
  return sub_806DA94(a1, 1u);
}
// 806DAD8: using guessed type _DWORD __cdecl sub_806DAD8(_DWORD, _DWORD, _DWORD);

//----- (0806ED18) --------------------------------------------------------
int __cdecl sub_806ED18(int a1, int a2, _DWORD *a3)
{
  int result; // eax

  a3[1] = 3;
  *a3 = a1;
  result = a2;
  a3[2] = a2;
  return result;
}

//----- (0806ED3A) --------------------------------------------------------
int __cdecl sub_806ED3A(int a1, int a2)
{
  sub_806DAD8(11, 1, 0);
  sub_8076D92(a2, 1);
  sub_806DFDE(a1);
  return sub_806DA94(a1, 1u);
}
// 806DAD8: using guessed type _DWORD __cdecl sub_806DAD8(_DWORD, _DWORD, _DWORD);

//----- (0806ED90) --------------------------------------------------------
int __cdecl sub_806ED90(int a1, int a2)
{
  int i; // [esp+14h] [ebp-4h]

  sub_806DAD8(12, 1, 0);
  sub_8076D92(a2, 1);
  for ( i = 0; i <= 2; ++i )
    sub_806DFBA(*(_DWORD *)(a1 + 4 * i));
  return RemoveRefToVector(a1);
}
// 806DAD8: using guessed type _DWORD __cdecl sub_806DAD8(_DWORD, _DWORD, _DWORD);

//----- (0806EE00) --------------------------------------------------------
void __cdecl sub_806EE00(int *a1)
{
  switch ( a1[1] )
  {
    case 0:
      sub_806E042(a1[2]);
      break;
    case 2:
      sub_806ECC2(*a1, a1[2]);
      break;
    case 3:
      sub_806ED3A(*a1, a1[2]);
      break;
    case 4:
      sub_806ED90(*a1, a1[2]);
      break;
    case 5:
      sub_806E272(*a1, a1[2]);
      break;
    case 6:
      sub_806E09C(*a1, a1[2]);
      break;
    default:
      return;
  }
}

//----- (0806EEC6) --------------------------------------------------------
char *__cdecl sub_806EEC6(int *a1)
{
  char *result; // eax
  int v2; // ecx

  if ( dword_8202A40 > 31 )
    return CompileError(a1[2], "VALUE_STACK_SIZE exceeded");
  v2 = 3 * dword_8202A40;
  dword_82028BC[v2] = *a1;
  dword_82028C0[v2] = a1[1];
  result = (char *)a1[2];
  dword_82028C4[v2] = (int)result;
  ++dword_8202A40;
  return result;
}
// 82028BC: using guessed type int dword_82028BC[];
// 82028C0: using guessed type int dword_82028C0[];
// 82028C4: using guessed type int dword_82028C4[];
// 8202A40: using guessed type int dword_8202A40;

//----- (0806EF26) --------------------------------------------------------
void sub_806EF26()
{
  --dword_8202A40;
}
// 8202A40: using guessed type int dword_8202A40;

//----- (0806EF32) --------------------------------------------------------
void __cdecl sub_806EF32(int a1)
{
  sub_806DAD8(91, 0, 0);
  sub_8076D92(a1, 0);
}

//----- (0806EF6A) --------------------------------------------------------
void __cdecl sub_806EF6A(int a1)
{
  sub_806DAD8(92, 0, 0);
  sub_8076D92(a1, 0);
}

//----- (0806EFA2) --------------------------------------------------------
void __cdecl sub_806EFA2(int a1)
{
  sub_806DAD8(93, 0, 0);
  sub_8076D92(a1, 0);
}

//----- (0806EFDA) --------------------------------------------------------
void __cdecl sub_806EFDA(int a1, int a2, int a3)
{
  sub_8071552(a1, a3);
  sub_806DAD8(118, 0, 0);
  sub_8076D92(a2, 0);
}

//----- (0806F024) --------------------------------------------------------
void __cdecl sub_806F024(int a1)
{
  sub_806DAD8(15, 1, 0);
  sub_8076D92(a1, 1);
}

//----- (0806F05C) --------------------------------------------------------
void __cdecl sub_806F05C(int a1)
{
  sub_806DAD8(16, 1, 0);
  sub_8076D92(a1, 1);
}

//----- (0806F094) --------------------------------------------------------
void __cdecl sub_806F094(int a1)
{
  sub_806DAD8(17, 1, 0);
  sub_8076D92(a1, 1);
}

//----- (0806F0CC) --------------------------------------------------------
void __cdecl sub_806F0CC(int a1)
{
  sub_806DAD8(18, 1, 0);
  sub_8076D92(a1, 1);
}

//----- (0806F104) --------------------------------------------------------
void __cdecl sub_806F104(int a1)
{
  sub_806DAD8(38, 0, 0);
  sub_8076D92(a1, 1);
}

//----- (0806F13C) --------------------------------------------------------
void __cdecl sub_806F13C(int a1)
{
  sub_806DAD8(13, 0, 0);
  sub_8076D92(a1, 1);
}

//----- (0806F174) --------------------------------------------------------
void __cdecl sub_806F174(int a1)
{
  sub_806DAD8(14, 0, 0);
  sub_8076D92(a1, 1);
}

//----- (0806F1AC) --------------------------------------------------------
void __cdecl sub_806F1AC(int a1, int a2, int a3)
{
  int v3; // [esp+10h] [ebp-8h]
  int v4; // [esp+14h] [ebp-4h]

  v4 = sub_806E36A(a1, a2, 0, a3);
  if ( v4 > 5 )
  {
    v3 = 30;
    sub_806DAD8(30, 1, 0);
  }
  else
  {
    v3 = v4 + 24;
    sub_806DAD8(v4 + 24, 1, 0);
  }
  if ( v3 == 30 )
    sub_806DF8E(v4);
  sub_8076D92(a2, 1);
}

//----- (0806F230) --------------------------------------------------------
void __cdecl sub_806F230(int a1, int a2, int a3)
{
  int v3; // [esp+14h] [ebp-4h]

  v3 = sub_806E36A(a1, a2, 1, a3);
  if ( v3 )
    sub_806DAD8(55, 0, 0);
  else
    sub_806DAD8(54, 0, 0);
  if ( v3 )
    sub_806DF8E(v3);
  sub_8076D92(a2, 1);
}

//----- (0806F2B2) --------------------------------------------------------
_DWORD *__cdecl sub_806F2B2(_DWORD *a1, int a2, _DWORD *a3)
{
  return sub_806E638(a1, a2, a3);
}

//----- (0806F2D4) --------------------------------------------------------
void __cdecl sub_806F2D4(int a1)
{
  sub_806DAD8(20, 0, 0);
  sub_8076D92(a1, 1);
}

//----- (0806F30C) --------------------------------------------------------
void __cdecl sub_806F30C(int a1, int a2)
{
  sub_806DAD8(32, -1, 0);
  sub_8076D92(a2, 0);
  sub_8076D92(a1, 1);
}

//----- (0806F356) --------------------------------------------------------
void __cdecl sub_806F356(int a1, int a2)
{
  sub_806DAD8(35, -1, 0);
  sub_8076D92(a2, 0);
  sub_8076D92(a1, 1);
}

//----- (0806F3A0) --------------------------------------------------------
void __cdecl sub_806F3A0(int a1, int a2)
{
  sub_806DAD8(36, -1, 0);
  sub_8076D92(a2, 0);
  sub_8076D92(a1, 0);
}

//----- (0806F3EA) --------------------------------------------------------
void __cdecl sub_806F3EA(int a1)
{
  sub_806DAD8(37, 1, 0);
  sub_8076D92(a1, 1);
}

//----- (0806F422) --------------------------------------------------------
int __cdecl sub_806F422(unsigned int a1, int a2)
{
  sub_806DAD8(19, 1, 0);
  sub_8076D92(a2, 1);
  sub_806DF0E(-1);
  sub_806CA94((_DWORD *)dword_8202860, a1, a2);
  return sub_806D9EC(a1);
}
// 8202860: using guessed type int dword_8202860;

//----- (0806F48C) --------------------------------------------------------
int __cdecl sub_806F48C(_DWORD *a1, int a2, int a3, int a4)
{
  sub_8071D92(a1, a3, a4);
  sub_806DAD8(42, 1, 0);
  sub_8076D92(a3, 0);
  return sub_806DA0A(a2);
}

//----- (0806F4E8) --------------------------------------------------------
int __cdecl sub_806F4E8(_DWORD *a1, int a2, int a3, int a4)
{
  sub_8071D92(a1, a3, a4);
  sub_806DAD8(46, 0, 0);
  return sub_806DA0A(a2);
}

//----- (0806F530) --------------------------------------------------------
int __cdecl sub_806F530(_DWORD *a1, int a2, int a3, int a4, int a5)
{
  sub_8071D92(a1, a3, a5);
  sub_806DAD8(47, 0, 0);
  sub_8076D92(a4, 0);
  return sub_806DA0A(a2);
}

//----- (0806F58C) --------------------------------------------------------
char *__cdecl sub_806F58C(int a1, int a2)
{
  int v3; // [esp+10h] [ebp-18h]
  int v4; // [esp+14h] [ebp-14h]
  unsigned int v5; // [esp+1Ch] [ebp-Ch]
  int v6; // [esp+20h] [ebp-8h]
  int v7; // [esp+24h] [ebp-4h]

  if ( byte_8202A64 )
    return CompileError(a2, "$ can only be used in the script debugger");
  v4 = SL_ConvertToString(a1);
  if ( *(_BYTE *)v4 == 116 )
  {
    v5 = atoi((const char *)(v4 + 1));
    if ( v5 )
    {
      if ( v5 <= 0xFFFD && !sub_807DF52((unsigned __int16)v5) )
      {
        v3 = GetVarType((unsigned __int16)v5);
        if ( v3 >= 15 && (v3 <= 18 || v3 == 23) )
        {
          sub_806DAD8(130, 1, 0);
          return (char *)sub_806DF32(v5);
        }
      }
    }
    return CompileError(a2, "bad expression");
  }
  v7 = sub_807F6F2(*(_BYTE *)v4);
  if ( v7 < 0 )
    return CompileError(a2, "bad expression");
  v6 = atoi((const char *)(v4 + 1));
  if ( !v6 && *(_BYTE *)(v4 + 1) != 48 )
    return CompileError(a2, "bad expression");
  sub_806DAD8(129, 1, 0);
  sub_806DF0E(v7);
  return (char *)sub_806DF0E(v6);
}
// 8202A64: using guessed type char byte_8202A64;

//----- (0806F6FE) --------------------------------------------------------
int sub_806F6FE()
{
  return sub_806DAD8(88, -1, 0);
}

//----- (0806F722) --------------------------------------------------------
void __cdecl sub_806F722(int a1)
{
  sub_806DAD8(89, -1, 0);
  sub_8076D92(a1, 0);
}

//----- (0806F75A) --------------------------------------------------------
void __cdecl sub_806F75A(int a1, _DWORD *a2, int a3, int a4, int a5)
{
  sub_8071B6C(a2, a5);
  sub_8071552(a1, a5);
  sub_806F30C(a3, a4);
}

//----- (0806F798) --------------------------------------------------------
void __cdecl sub_806F798(_DWORD *a1, _DWORD *a2, int a3, int a4, int a5)
{
  sub_8071B6C(a2, a5);
  sub_8071D0A(a1, a3, a5);
  sub_806F356(a3, a4);
}

//----- (0806F7DE) --------------------------------------------------------
int __cdecl sub_806F7DE(int *a1, int a2)
{
  return sub_8071D66(a1, a2);
}

//----- (0806F7F8) --------------------------------------------------------
void __cdecl sub_806F7F8(_DWORD *a1, _DWORD *a2, int a3, int a4, int a5)
{
  sub_8071B6C(a2, a5);
  sub_8071D0A(a1, a3, a5);
  sub_806F3A0(a3, a4);
}

//----- (0806F83E) --------------------------------------------------------
void __cdecl sub_806F83E(int *a1, int a2)
{
  int v2; // [esp+20h] [ebp-8h]

  v2 = *a1;
  if ( *a1 == 15 )
  {
    sub_806F48C((_DWORD *)a1[1], a1[2], a1[3], a2);
  }
  else if ( v2 > 15 )
  {
    if ( v2 == 53 )
    {
      if ( byte_8202A64 )
        CompileError(a1[2], "self field can only be used in the script debugger");
      else
        CompileError(a1[2], "self field in assignment expression not currently supported");
    }
    else if ( v2 == 79 )
    {
      sub_806F58C(a1[1], a1[2]);
    }
  }
  else if ( v2 == 4 )
  {
    sub_806F1AC(a1[1], a1[2], a2);
  }
  else if ( v2 == 13 )
  {
    sub_806F75A(a1[1], (_DWORD *)a1[2], a1[3], a1[4], a2);
  }
}
// 8202A64: using guessed type char byte_8202A64;

//----- (0806F96C) --------------------------------------------------------
int __cdecl sub_806F96C(int *a1)
{
  int v2; // [esp+0h] [ebp-8h]
  int i; // [esp+4h] [ebp-4h]

  v2 = 0;
  for ( i = *a1; i; i = *(_DWORD *)(i + 4) )
    ++v2;
  return v2;
}

//----- (0806F9A0) --------------------------------------------------------
int __cdecl sub_806F9A0(int *a1, int a2)
{
  int v3; // [esp+10h] [ebp-8h]
  int i; // [esp+14h] [ebp-4h]

  v3 = 0;
  for ( i = *a1; i; i = *(_DWORD *)(i + 4) )
  {
    sub_8071B6C(**(_DWORD ***)i, a2);
    ++v3;
  }
  return v3;
}

//----- (0806F9EA) --------------------------------------------------------
int __cdecl sub_806F9EA(int a1)
{
  if ( !*(_DWORD *)a1 )
    return 0;
  if ( *(_DWORD *)(*(_DWORD *)a1 + 4) )
    return 0;
  return *(_DWORD *)a1;
}

//----- (0806FA26) --------------------------------------------------------
_DWORD *__cdecl sub_806FA26(_DWORD *a1)
{
  _DWORD *result; // eax
  _DWORD *i; // [esp+14h] [ebp-4h]

  if ( byte_839400A )
  {
    result = (_DWORD *)*a1;
    for ( i = (_DWORD *)*a1; i; i = result )
    {
      sub_8076D92(*(_DWORD *)(*i + 4), 0);
      result = (_DWORD *)i[1];
    }
  }
  return result;
}
// 839400A: using guessed type char byte_839400A;

//----- (0806FA70) --------------------------------------------------------
int __cdecl sub_806FA70(unsigned int a1, int a2, char a3)
{
  int v3; // eax

  sub_807951E(a1);
  sub_806D9EC(a1);
  *(_WORD *)dword_82028B4 = a1;
  *(_DWORD *)(dword_82028B4 + 4) = a2;
  *(_BYTE *)(dword_82028B4 + 2) = a3;
  dword_82028B4 += 12;
  v3 = sub_807C0A8(dword_8202A4C, a1);
  return sub_807CA86(v3);
}
// 82028B4: using guessed type int dword_82028B4;
// 8202A4C: using guessed type int dword_8202A4C;

//----- (0806FADC) --------------------------------------------------------
void __cdecl sub_806FADC(_DWORD *a1, int a2)
{
  char *v2; // eax
  int v3; // eax
  int v4; // [esp+18h] [ebp-60h] BYREF
  int v5; // [esp+1Ch] [ebp-5Ch]
  int v6; // [esp+20h] [ebp-58h] BYREF
  int v7; // [esp+24h] [ebp-54h]
  int v8; // [esp+28h] [ebp-50h] BYREF
  int v9; // [esp+2Ch] [ebp-4Ch]
  int v10; // [esp+34h] [ebp-44h]
  int v11; // [esp+38h] [ebp-40h]
  int v12; // [esp+3Ch] [ebp-3Ch]
  int v13; // [esp+40h] [ebp-38h]
  bool v14; // [esp+47h] [ebp-31h]
  int v15; // [esp+48h] [ebp-30h]
  int v16; // [esp+4Ch] [ebp-2Ch]
  int v17; // [esp+50h] [ebp-28h]
  int v18; // [esp+54h] [ebp-24h]
  int v19; // [esp+58h] [ebp-20h]
  int v20; // [esp+5Ch] [ebp-1Ch]
  int v21; // [esp+60h] [ebp-18h] BYREF
  int v22; // [esp+64h] [ebp-14h]
  int v23; // [esp+68h] [ebp-10h] BYREF
  int v24; // [esp+6Ch] [ebp-Ch]

  if ( dword_8202A68 == 2 )
  {
    sub_806D9EC(a1[1]);
    if ( *a1 == 21 )
    {
      sub_806D9EC(a1[2]);
      --dword_8202A44;
    }
    return;
  }
  v20 = 0;
  if ( *a1 == 20 )
  {
    v10 = 0;
    v19 = sub_807C0A8(dword_8202868, a1[1]);
    sub_806DA94(a1[1], 2u);
    v20 = sub_807CA86(v19);
  }
  else
  {
    v10 = 1;
    v2 = (char *)SL_ConvertToString(a1[1]);
    v15 = sub_8079C2A(v2);
    sub_806D9EC(a1[1]);
    v3 = FindVariable(dword_8202A48, v15);
    sub_807C66A(&v8, v3);
    v21 = v8;
    v22 = v9;
    v14 = v9 != 0;
    v16 = sub_806FA70(v15, a2, 0);
    if ( v14 )
    {
      v19 = FindVariable(v16, a1[2]);
      if ( !v19 || GetVarType(v19) != 1 )
      {
        CompileError(a2, "unknown function");
        return;
      }
    }
    else
    {
      v19 = sub_807C0A8(v16, a1[2]);
    }
    sub_806DA94(a1[2], 2u);
    v20 = sub_807CA86(v19);
    v13 = FindVariable(v20, 1);
    if ( v13 )
    {
      sub_807C66A(&v6, v13);
      v11 = v6;
      v12 = v7;
      if ( v7 == 13 )
      {
        CompileError(a2, "unknown function");
        return;
      }
      if ( v11 )
      {
        if ( v12 == 7 || dword_8202A68 )
          sub_806E004(v11);
        else
          CompileError(a2, "normal script cannot reference a function in a /# ... #/ comment");
        return;
      }
    }
  }
  sub_806DF0E(v10);
  v18 = sub_807C0A8(v20, 0);
  sub_807C66A(&v4, v18);
  v23 = v4;
  v24 = v5;
  if ( !v5 )
  {
    v24 = 6;
    v23 = 0;
  }
  v17 = sub_807C0CC(v20, v23 + 2);
  v21 = dword_8202860;
  if ( dword_8202A68 )
    v22 = 12;
  else
    v22 = 7;
  sub_807C4C2(v17, &v21);
  ++v23;
  sub_807C45C(v18, &v23);
  sub_8076D92(a2, 0);
}
// 8202860: using guessed type int dword_8202860;
// 8202868: using guessed type int dword_8202868;
// 8202A44: using guessed type int dword_8202A44;
// 8202A48: using guessed type int dword_8202A48;
// 8202A68: using guessed type int dword_8202A68;

//----- (0806FE34) --------------------------------------------------------
void __cdecl sub_806FE34(_DWORD *a1, int a2)
{
  sub_806DAD8(21, 1, 0);
  sub_8076D92(a2, 3);
  sub_806FADC(a1, a2);
}

//----- (0806FE7E) --------------------------------------------------------
int __cdecl sub_806FE7E(int a1)
{
  int i; // [esp+14h] [ebp-4h]

  for ( i = 0; i < dword_8202A74; ++i )
  {
    if ( dword_8202A78[i] == a1 )
      return i;
  }
  if ( dword_8202A74 == 1024 )
    Com_Error(1, (char *)&byte_813ED81);
  dword_8202A78[dword_8202A74++] = a1;
  return i;
}
// 8202A74: using guessed type int dword_8202A74;
// 8202A78: using guessed type int dword_8202A78[1058];

//----- (0806FEF6) --------------------------------------------------------
void __cdecl sub_806FEF6(_DWORD *a1, int a2, char a3, int a4)
{
  if ( a3 )
    sub_806DAD8(82, -a2 - 1, 3);
  else
    sub_806DAD8(80, -a2, 3);
  sub_8076D92(a4, 3);
  sub_806FADC(a1, a4);
}

//----- (0806FF6C) --------------------------------------------------------
void __cdecl sub_806FF6C(int a1, int a2, char a3, int a4, int a5, int a6)
{
  sub_8071B6C(a1, a6);
  if ( a3 )
    sub_806DAD8(83, -a2 - 2, 3);
  else
    sub_806DAD8(81, -a2 - 1, 3);
  sub_8076D92(a5, 0);
  sub_8076D92(a4, 1);
}
// 8071B6C: using guessed type _DWORD __cdecl sub_8071B6C(_DWORD, _DWORD);

//----- (0806FFF8) --------------------------------------------------------
int __cdecl sub_806FFF8(_DWORD *a1, int a2, char a3, int a4)
{
  if ( a3 )
    sub_806DAD8(86, -a2, 2);
  else
    sub_806DAD8(84, 1 - a2, 2);
  sub_8076D92(a4, 3);
  sub_806FADC(a1, a4);
  return sub_806DF0E(a2);
}

//----- (0807007C) --------------------------------------------------------
int __cdecl sub_807007C(int a1, int a2, char a3, int a4, int a5)
{
  sub_8071B6C(a1, a5);
  if ( a3 )
    sub_806DAD8(87, -a2 - 1, 2);
  else
    sub_806DAD8(85, -a2, 2);
  sub_8076D92(a4, 1);
  return sub_806DF0E(a2);
}
// 8071B6C: using guessed type _DWORD __cdecl sub_8071B6C(_DWORD, _DWORD);

//----- (080700FE) --------------------------------------------------------
void __cdecl sub_80700FE(_DWORD *a1, int a2, char a3, int a4, int a5)
{
  if ( *a1 == 18 )
  {
    sub_806FEF6((_DWORD *)a1[1], a2, a3, a4);
  }
  else if ( *a1 == 22 )
  {
    sub_806FF6C(a1[1], a2, a3, a4, a1[2], a5);
  }
}

//----- (08070184) --------------------------------------------------------
void __cdecl sub_8070184(_DWORD *a1, int a2, char a3, int a4, int a5, int a6)
{
  if ( *a1 == 18 )
  {
    sub_806FFF8((_DWORD *)a1[1], a2, a3, a5);
  }
  else if ( *a1 == 22 )
  {
    sub_807007C(a1[1], a2, a3, a1[2], a6);
  }
  sub_8076D92(a4, 0);
}

//----- (08070216) --------------------------------------------------------
int __cdecl sub_8070216(_DWORD *a1)
{
  int result; // eax

  result = (int)a1;
  if ( *a1 == 26 )
    return sub_806DAD8(78, 1, 0);
  return result;
}

//----- (08070242) --------------------------------------------------------
void __cdecl sub_8070242(int a1, int a2, char a3, int a4)
{
  if ( *(_DWORD *)a1 == 26 )
  {
    sub_80700FE(*(_DWORD **)(a1 + 4), a2, a3, *(_DWORD *)(a1 + 8), a4);
  }
  else if ( *(_DWORD *)a1 == 30 )
  {
    sub_8070184(*(_DWORD **)(a1 + 4), a2, a3, *(_DWORD *)(a1 + 8), *(_DWORD *)(a1 + 12), a4);
  }
}

//----- (080702D8) --------------------------------------------------------
int __cdecl sub_80702D8(_DWORD *a1)
{
  _DWORD *v3; // [esp+20h] [ebp+8h]
  _DWORD *v4; // [esp+20h] [ebp+8h]

  if ( *a1 != 26 )
    return 0;
  v3 = (_DWORD *)a1[1];
  if ( *v3 != 18 )
    return 0;
  v4 = (_DWORD *)v3[1];
  if ( *v4 != 20 )
    return 0;
  if ( FindVariable(dword_8202868, v4[1]) )
    return 0;
  return v4[1];
}
// 8202868: using guessed type int dword_8202868;

//----- (0807035E) --------------------------------------------------------
_DWORD *__cdecl sub_807035E(_DWORD *a1, unsigned int *a2)
{
  _DWORD *result; // eax

  if ( dword_8202A68 )
  {
    result = a1;
    *a1 = 0;
  }
  else
  {
    if ( byte_839400B )
    {
      dword_8202A68 = 1;
    }
    else
    {
      *a2 = TempMalloc(0);
      dword_8202A68 = 2;
    }
    result = a1;
    *a1 = 1;
  }
  return result;
}
// 8202A68: using guessed type int dword_8202A68;
// 839400B: using guessed type char byte_839400B;

//----- (080703B6) --------------------------------------------------------
unsigned int __cdecl sub_80703B6(int a1, int *a2)
{
  unsigned int result; // eax

  if ( a1 == 1 )
  {
    dword_8202A68 = 0;
    if ( !byte_839400B )
      return TempMemorySetPos(*a2);
  }
  return result;
}
// 8202A68: using guessed type int dword_8202A68;
// 839400B: using guessed type char byte_839400B;

//----- (080703E6) --------------------------------------------------------
int __cdecl sub_80703E6(int a1)
{
  if ( a1 )
    return 12;
  else
    return 7;
}

//----- (0807040A) --------------------------------------------------------
_BOOL4 __cdecl sub_807040A(int a1)
{
  return a1 != 7;
}

//----- (08070430) --------------------------------------------------------
void __cdecl sub_8070430(int a1, int a2)
{
  int v2; // [esp+14h] [ebp-4h]

  if ( a1 > 5 )
  {
    v2 = 68;
    sub_806DAD8(68, 1 - a1, 1);
  }
  else
  {
    v2 = a1 + 62;
    sub_806DAD8(a1 + 62, 1 - a1, 1);
  }
  sub_8076D92(a2, 1);
  if ( v2 == 68 )
    sub_806DF8E(a1);
}

//----- (08070496) --------------------------------------------------------
void __cdecl sub_8070496(int a1, int a2)
{
  int v2; // [esp+14h] [ebp-4h]

  if ( a1 > 5 )
  {
    v2 = 75;
    sub_806DAD8(75, -a1, 1);
  }
  else
  {
    v2 = a1 + 69;
    sub_806DAD8(a1 + 69, -a1, 1);
  }
  sub_8076D92(a2, 1);
  if ( v2 == 75 )
    sub_806DF8E(a1);
}

//----- (080704FA) --------------------------------------------------------
char *__cdecl EmitCall(_DWORD *a1, int *a2, char a3, int a4)
{
  char *result; // eax
  unsigned __int16 v5; // ax
  int v6; // [esp+10h] [ebp-38h] BYREF
  int v7; // [esp+14h] [ebp-34h]
  int v8; // [esp+18h] [ebp-30h] BYREF
  int v9; // [esp+1Ch] [ebp-2Ch]
  int v10; // [esp+24h] [ebp-24h]
  int v11; // [esp+28h] [ebp-20h] BYREF
  int v12; // [esp+2Ch] [ebp-1Ch]
  int v13; // [esp+30h] [ebp-18h] BYREF
  char *v14; // [esp+34h] [ebp-14h] BYREF
  int v15; // [esp+38h] [ebp-10h]
  int v16; // [esp+3Ch] [ebp-Ch]
  int v17; // [esp+40h] [ebp-8h]
  char v18; // [esp+47h] [ebp-1h]

  v18 = a3;
  v16 = sub_80702D8(a1);
  if ( !v16 )
    goto LABEL_15;
  v14 = (char *)SL_ConvertToString(v16);
  v15 = a1[2];
  v10 = FindVariable(dword_8202A50, v16);
  if ( v10 )
  {
    sub_807C66A(&v6, v10);
    v8 = v6;
    v9 = v7;
    v13 = sub_807040A(v7);
    v12 = v8;
  }
  else
  {
    v13 = 0;
    v12 = Scr_GetFunction(&v14, &v13);
    v10 = sub_807C0CC(dword_8202A50, v16);
    v9 = sub_80703E6(v13);
    v8 = v12;
    sub_807C45C(v10, &v8);
  }
  if ( v12 )
  {
    if ( v13 == 1 && (sub_807035E(&v13, (unsigned int *)&v11), v13 == 1) && !v18 )
    {
      return CompileError(v15, "return value of developer command can not be accessed if not in a /# ... #/ comment");
    }
    else
    {
      v17 = sub_806F9A0(a2, a4);
      if ( v17 <= 255 )
      {
        sub_806D9EC(v16);
        sub_8070430(v17, v15);
        v5 = sub_806FE7E(v12);
        sub_806DF60(v5);
        sub_806FA26(a2);
        if ( v18 )
          sub_806F6FE();
        return (char *)sub_80703B6(v13, &v11);
      }
      else
      {
        return CompileError(v15, "parameter count exceeds 256");
      }
    }
  }
  else
  {
LABEL_15:
    sub_8070216(a1);
    v17 = sub_806F9A0(a2, a4);
    sub_8070242((int)a1, v17, 0, a4);
    result = (char *)sub_806FA26(a2);
    if ( v18 )
      return (char *)sub_806F6FE();
  }
  return result;
}
// 8202A50: using guessed type int dword_8202A50;

//----- (0807071E) --------------------------------------------------------
char *__cdecl EmitMethod(int a1, _DWORD *a2, _DWORD *a3, int a4, char a5, int a6)
{
  char *result; // eax
  unsigned __int16 v7; // ax
  int (__cdecl *v8)(int); // [esp+10h] [ebp-38h] BYREF
  int v9; // [esp+14h] [ebp-34h]
  int (__cdecl *v10)(int); // [esp+18h] [ebp-30h] BYREF
  int v11; // [esp+1Ch] [ebp-2Ch]
  int v12; // [esp+24h] [ebp-24h]
  int v13; // [esp+28h] [ebp-20h] BYREF
  int (__cdecl *v14)(int); // [esp+2Ch] [ebp-1Ch]
  int v15; // [esp+30h] [ebp-18h] BYREF
  char *v16; // [esp+34h] [ebp-14h] BYREF
  int v17; // [esp+38h] [ebp-10h]
  int v18; // [esp+3Ch] [ebp-Ch]
  int v19; // [esp+40h] [ebp-8h]
  char v20; // [esp+47h] [ebp-1h]

  v20 = a5;
  v18 = sub_80702D8(a2);
  if ( !v18 )
    goto LABEL_15;
  v16 = (char *)SL_ConvertToString(v18);
  v17 = a2[2];
  v12 = FindVariable(dword_8202A54, v18);
  if ( v12 )
  {
    sub_807C66A((int *)&v8, v12);
    v10 = v8;
    v11 = v9;
    v15 = sub_807040A(v9);
    v14 = v10;
  }
  else
  {
    v15 = 0;
    v14 = Scr_GetMethod(&v16, &v15);
    v12 = sub_807C0CC(dword_8202A54, v18);
    v11 = sub_80703E6(v15);
    v10 = v14;
    sub_807C45C(v12, (int *)&v10);
  }
  if ( v14 )
  {
    if ( v15 == 1 && (sub_807035E(&v15, (unsigned int *)&v13), v15 == 1) && !v20 )
    {
      return CompileError(v17, "return value of developer command can not be accessed if not in a /# ... #/ comment");
    }
    else
    {
      v19 = sub_806F9A0(a3, a6);
      sub_8071552(a1, a6);
      if ( v19 <= 255 )
      {
        sub_806D9EC(v18);
        sub_8070496(v19, v17);
        v7 = sub_806FE7E((int)v14);
        sub_806DF60(v7);
        sub_8076D92(a4, 0);
        sub_806FA26(a3);
        if ( v20 )
          sub_806F6FE();
        return (char *)sub_80703B6(v15, &v13);
      }
      else
      {
        return CompileError(v17, "parameter count exceeds 256");
      }
    }
  }
  else
  {
LABEL_15:
    sub_8070216(a2);
    v19 = sub_806F9A0(a3, a6);
    sub_8071552(a1, a6);
    sub_8070242((int)a2, v19, 1, a6);
    sub_8076D92(a4, 0);
    result = (char *)sub_806FA26(a3);
    if ( v20 )
      return (char *)sub_806F6FE();
  }
  return result;
}
// 806F9A0: using guessed type _DWORD __cdecl sub_806F9A0(_DWORD, _DWORD);
// 8202A54: using guessed type int dword_8202A54;

//----- (0807098C) --------------------------------------------------------
int __cdecl sub_807098C(int a1, _DWORD *a2, char a3)
{
  int result; // eax
  int v4[3]; // [esp+8h] [ebp-30h] BYREF
  int v5; // [esp+14h] [ebp-24h]
  int i; // [esp+18h] [ebp-20h]
  int v7; // [esp+1Ch] [ebp-1Ch]
  __int16 *v8; // [esp+20h] [ebp-18h]
  int v9; // [esp+24h] [ebp-14h]
  int v10; // [esp+28h] [ebp-10h]
  int v11; // [esp+2Ch] [ebp-Ch]
  char v12; // [esp+37h] [ebp-1h]

  v12 = a3;
  result = FindVariable(a1, 0);
  v9 = result;
  if ( result )
  {
    sub_807C66A(v4, v9);
    v10 = v4[0];
    v11 = v4[1];
    for ( i = 0; ; ++i )
    {
      result = i;
      if ( i >= v10 )
        break;
      v7 = FindVariable(a1, i + 2);
      v8 = sub_807C4FC(v7);
      v5 = GetVarType(v7);
      if ( a2[1] == 12 && v5 == 7 )
        sub_80780F6(*(const char **)v8, "normal script cannot reference a function in a /# ... #/ comment");
      if ( !a2[1] )
        sub_80780F6(*(const char **)v8, "unknown function");
      if ( !v12 && **(_DWORD **)v8 == 1 )
        sub_80780F6(*(const char **)v8, "unknown function");
      **(_DWORD **)v8 = *a2;
    }
  }
  return result;
}

//----- (08070AA8) --------------------------------------------------------
int __cdecl sub_8070AA8(int a1)
{
  int result; // eax
  int v2; // [esp+10h] [ebp-28h] BYREF
  int v3; // [esp+14h] [ebp-24h]
  int v4[2]; // [esp+18h] [ebp-20h] BYREF
  int v5[3]; // [esp+20h] [ebp-18h] BYREF
  int v6; // [esp+2Ch] [ebp-Ch]
  int v7; // [esp+30h] [ebp-8h]
  int i; // [esp+34h] [ebp-4h]

  v4[1] = 0;
  v4[0] = 0;
  result = sub_807C9CE(a1);
  for ( i = result; i; i = result )
  {
    v7 = sub_807CB1E(i);
    v6 = FindVariable(v7, 1);
    if ( v6 )
    {
      sub_807C66A(&v2, v6);
      v5[0] = v2;
      v5[1] = v3;
      if ( v3 == 13 )
        sub_807C45C(i, v4);
      else
        sub_807098C(v7, v5, 1);
    }
    else
    {
      sub_807098C(v7, v4, 1);
    }
    result = sub_807C9CE(i);
  }
  return result;
}

//----- (08070B86) --------------------------------------------------------
int __cdecl sub_8070B86(int a1, int a2, int a3, int a4)
{
  const char *v4; // eax
  const char *v5; // eax
  unsigned int v8; // [esp+20h] [ebp-18h] BYREF
  int v9; // [esp+24h] [ebp-14h]
  int v10; // [esp+28h] [ebp-10h]
  int v11; // [esp+2Ch] [ebp-Ch]
  unsigned int v12; // [esp+30h] [ebp-8h] BYREF
  int v13; // [esp+34h] [ebp-4h]

  v11 = sub_807C0A8(a1, 1u);
  sub_807C66A((int *)&v8, v11);
  v12 = v8;
  v13 = v9;
  if ( v9 )
  {
    if ( v12 )
    {
      v10 = sub_8077D5A(v12);
      v4 = (const char *)SL_ConvertToString(a2);
      CompileError(a3, "function '%s' already defined in '%s'", v4, *((const char **)dword_8283ED4 + 6 * v10 + 1));
    }
    else
    {
      v5 = (const char *)SL_ConvertToString(a2);
      CompileError(a3, "function '%s' already defined", v5);
    }
    return 0;
  }
  else
  {
    v13 = a4;
    v12 = 0;
    sub_807C4C2(v11, (int *)&v12);
    return v11;
  }
}

//----- (08070C7A) --------------------------------------------------------
unsigned int __cdecl sub_8070C7A(int a1)
{
  int v1; // eax
  __int16 *v2; // ebx
  unsigned int result; // eax

  v1 = FindVariable(a1, 1);
  v2 = sub_807C4FC(v1);
  result = TempMalloc(0);
  *(_DWORD *)v2 = result;
  return result;
}

//----- (08070CB2) --------------------------------------------------------
char *__cdecl sub_8070CB2(int a1, unsigned __int8 a2, int a3)
{
  char *result; // eax

  result = *(char **)a1;
  if ( *(_DWORD *)a1 == 23 )
    return (char *)EmitCall(*(_DWORD *)(a1 + 4), *(_DWORD *)(a1 + 8), a2, a3);
  if ( *(_DWORD *)a1 == 24 )
    return EmitMethod(*(_DWORD *)(a1 + 4), *(_DWORD **)(a1 + 8), *(_DWORD **)(a1 + 12), *(_DWORD *)(a1 + 16), a2, a3);
  return result;
}
// 80704FA: using guessed type _DWORD __cdecl EmitCall(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (08070D46) --------------------------------------------------------
void __cdecl sub_8070D46(int a1, int a2)
{
  if ( *(_DWORD *)a1 == 23 )
  {
    EmitCall(*(_DWORD **)(a1 + 4), *(int **)(a1 + 8), 0, a2);
    sub_806F722(*(_DWORD *)(a1 + 12));
  }
  else if ( *(_DWORD *)a1 == 24 )
  {
    EmitMethod(*(_DWORD *)(a1 + 4), *(_DWORD **)(a1 + 8), *(_DWORD **)(a1 + 12), *(_DWORD *)(a1 + 16), 0, a2);
    sub_806F722(*(_DWORD *)(a1 + 20));
  }
}

//----- (08070DF8) --------------------------------------------------------
char *__cdecl sub_8070DF8(int a1, char **a2)
{
  char *result; // eax
  int v3; // [esp+18h] [ebp-20h]
  int i; // [esp+1Ch] [ebp-1Ch]
  float v5[6]; // [esp+20h] [ebp-18h] BYREF

  for ( i = 0; i <= 2; ++i )
  {
    v3 = *(_DWORD *)(a1 + 12 * i + 4);
    if ( v3 == 5 )
    {
      v5[2 - i] = *(float *)(a1 + 12 * i);
    }
    else
    {
      if ( v3 != 6 )
        return CompileError(*(_DWORD *)(a1 + 12 * i + 8), "type %s is not a float", *(const char **)&off_815ABC0[4 * v3]);
      v5[2 - i] = (float)*(int *)(a1 + 12 * i);
    }
  }
  a2[1] = (char *)4;
  result = (char *)sub_807B968(v5);
  *a2 = result;
  return result;
}
// 8070DF8: using guessed type float var_18[6];

//----- (08070EE4) --------------------------------------------------------
int __cdecl sub_8070EE4(int *a1, int a2, int a3)
{
  _DWORD v5[13]; // [esp+20h] [ebp-48h] BYREF
  int v6; // [esp+54h] [ebp-14h]
  int i; // [esp+58h] [ebp-10h]
  int v8; // [esp+5Ch] [ebp-Ch]

  v8 = sub_806F96C(a1);
  if ( v8 == 1 )
    return (unsigned __int8)sub_807194E(**(_DWORD **)*a1, a3);
  if ( v8 != 3 )
    return 0;
  v6 = 0;
  for ( i = *a1; i; i = *(_DWORD *)(i + 4) )
  {
    if ( (unsigned __int8)sub_807194E(**(_DWORD **)i, &v5[3 * v6]) != 1 )
      return 0;
    ++v6;
  }
  sub_8070DF8((int)v5, (char **)a3);
  *(_DWORD *)(a3 + 8) = a2;
  return 1;
}
// 807194E: using guessed type _DWORD __cdecl sub_807194E(_DWORD, _DWORD);

//----- (08070FC0) --------------------------------------------------------
int __cdecl sub_8070FC0(int *a1, int a2, int a3, int a4)
{
  int v6[5]; // [esp+20h] [ebp-28h] BYREF
  char v7; // [esp+37h] [ebp-11h]
  _DWORD **i; // [esp+38h] [ebp-10h]
  int v9; // [esp+3Ch] [ebp-Ch]

  v9 = sub_806F96C(a1);
  if ( v9 == 1 )
    return (unsigned __int8)sub_80719D8(**(_DWORD **)*a1, a3, a4);
  if ( v9 == 3 )
  {
    v7 = 1;
    for ( i = (_DWORD **)*a1; i; i = (_DWORD **)i[1] )
    {
      if ( v7 )
      {
        v7 = sub_80719D8(**i, v6, a4);
        if ( v7 )
          sub_806EEC6(v6);
      }
      else
      {
        sub_8071B6C(**i, a4);
      }
    }
    if ( v7 )
    {
      dword_8202A40 -= 3;
      sub_8070DF8(12 * dword_8202A40 + 136325308, (char **)a3);
      *(_DWORD *)(a3 + 8) = a2;
      return 1;
    }
    else
    {
      sub_806DAD8(126, -2, 0);
      sub_8076D92(a2, 1);
      sub_806FA26(a1);
      return 0;
    }
  }
  else
  {
    CompileError(a2, "expression list must have 1 or 3 parameters");
    return 0;
  }
}
// 80719D8: using guessed type _DWORD __cdecl sub_80719D8(_DWORD, _DWORD, _DWORD);
// 8071B6C: using guessed type _DWORD __cdecl sub_8071B6C(_DWORD, _DWORD);
// 8202A40: using guessed type int dword_8202A40;
// 8070FC0: using guessed type int var_28[5];

//----- (0807112A) --------------------------------------------------------
char *__cdecl sub_807112A(int a1, int a2, int a3)
{
  _DWORD ***v4; // [esp+14h] [ebp-4h]

  v4 = (_DWORD ***)sub_806F9EA(a1);
  if ( v4 )
    return sub_8071E6A(**v4, (int)(*v4)[1], a3);
  else
    return CompileError(a2, "not an object");
}

//----- (08071180) --------------------------------------------------------
int __cdecl sub_8071180(_DWORD *a1, _DWORD *a2)
{
  int v3; // [esp+14h] [ebp-4h]

  switch ( *a1 )
  {
    case 7:
      sub_806E07A(a1[1], a1[2], a2);
      v3 = 1;
      break;
    case 8:
      sub_806E250(a1[1], a1[2], a2);
      v3 = 1;
      break;
    case 9:
      sub_806E07A(-a1[1], a1[2], a2);
      v3 = 1;
      break;
    case 0xA:
      sub_806E250(a1[1] ^ 0x80000000, a1[2], a2);
      v3 = 1;
      break;
    case 0xB:
      sub_806ECA0(a1[1], a1[2], a2);
      v3 = 1;
      break;
    case 0xC:
      sub_806ED18(a1[1], a1[2], a2);
      v3 = 1;
      break;
    case 0x1F:
      sub_806E028(a1[1], (int)a2);
      v3 = 1;
      break;
    case 0x2E:
      v3 = (unsigned __int8)sub_8070EE4((int *)a1[1], a1[2], (int)a2);
      break;
    case 0x48:
      sub_806E07A(0, a1[1], a2);
      v3 = 1;
      break;
    case 0x49:
      sub_806E07A(1, a1[1], a2);
      v3 = 1;
      break;
    default:
      v3 = 0;
      break;
  }
  return v3;
}

//----- (08071370) --------------------------------------------------------
int __cdecl sub_8071370(_DWORD *a1, _DWORD *a2, int a3)
{
  int v4; // [esp+14h] [ebp-4h]

  switch ( *a1 )
  {
    case 0x11:
      sub_806F83E(a1[1], a3);
      v4 = 0;
      break;
    case 0x12:
      sub_806FE34((_DWORD *)a1[1], a1[2]);
      v4 = 0;
      break;
    case 0x13:
      sub_8070CB2(a1[1], 0, a3);
      v4 = 0;
      break;
    case 0x20:
      sub_806F024(a1[1]);
      v4 = 0;
      break;
    case 0x22:
      sub_806F05C(a1[1]);
      v4 = 0;
      break;
    case 0x23:
      sub_806F094(a1[1]);
      v4 = 0;
      break;
    case 0x24:
      sub_806F0CC(a1[1]);
      v4 = 0;
      break;
    case 0x2E:
      v4 = (unsigned __int8)sub_8070FC0((int *)a1[1], a1[2], (int)a2, a3);
      break;
    case 0x34:
      sub_806EFDA(a1[1], a1[2], a3);
      v4 = 0;
      break;
    case 0x42:
      sub_806F3EA(a1[1]);
      v4 = 0;
      break;
    case 0x43:
      sub_806F422(a1[1], a1[2]);
      v4 = 0;
      break;
    case 0x4A:
      sub_806E2B4(a1[1]);
      v4 = 0;
      break;
    default:
      v4 = (unsigned __int8)sub_8071180(a1, a2);
      break;
  }
  return v4;
}
// 806F83E: using guessed type _DWORD __cdecl sub_806F83E(_DWORD, _DWORD);

//----- (08071552) --------------------------------------------------------
void __cdecl sub_8071552(int a1, int a2)
{
  int v2[6]; // [esp+10h] [ebp-18h] BYREF

  if ( (unsigned __int8)sub_8071370(a1, v2, a2) == 1 )
    sub_806EE00(v2);
}
// 8071370: using guessed type _DWORD __cdecl sub_8071370(_DWORD, _DWORD, _DWORD);
// 8071552: using guessed type int var_18[6];

//----- (08071586) --------------------------------------------------------
unsigned int __cdecl sub_8071586(int a1, int a2, int a3, int a4, int a5)
{
  unsigned int result; // eax
  unsigned int v6; // [esp+10h] [ebp-8h]
  _WORD *v7; // [esp+14h] [ebp-4h]

  sub_8071B6C(a1, a5);
  sub_806DAD8(97, -1, 0);
  sub_8076D92(a3, 0);
  sub_806DF60(0);
  v7 = (_WORD *)dword_8202860;
  v6 = TempMalloc(0);
  sub_8071B6C(a2, a5);
  sub_806EF32(a4);
  result = TempMalloc(0) - v6;
  *v7 = result;
  return result;
}
// 8071B6C: using guessed type _DWORD __cdecl sub_8071B6C(_DWORD, _DWORD);
// 8202860: using guessed type int dword_8202860;

//----- (0807162A) --------------------------------------------------------
unsigned int __cdecl sub_807162A(int a1, int a2, int a3, int a4, int a5)
{
  unsigned int result; // eax
  unsigned int v6; // [esp+10h] [ebp-8h]
  _WORD *v7; // [esp+14h] [ebp-4h]

  sub_8071B6C(a1, a5);
  sub_806DAD8(96, -1, 0);
  sub_8076D92(a3, 0);
  sub_806DF60(0);
  v7 = (_WORD *)dword_8202860;
  v6 = TempMalloc(0);
  sub_8071B6C(a2, a5);
  sub_806EF32(a4);
  result = TempMalloc(0) - v6;
  *v7 = result;
  return result;
}
// 8071B6C: using guessed type _DWORD __cdecl sub_8071B6C(_DWORD, _DWORD);
// 8202860: using guessed type int dword_8202860;

//----- (080716CE) --------------------------------------------------------
int __cdecl sub_80716CE(int a1, int a2, int a3, int a4, _DWORD *a5)
{
  int v5; // edx
  int v8[4]; // [esp+20h] [ebp-28h] BYREF
  int v9[6]; // [esp+30h] [ebp-18h] BYREF

  if ( (unsigned __int8)sub_807194E(a1, v9) != 1 )
    return 0;
  if ( (unsigned __int8)sub_807194E(a2, v8) != 1 )
    return 0;
  sub_807578C(v9);
  sub_807578C(v8);
  Scr_EvalBinaryOperator(a3, v9, v8);
  if ( *(_DWORD *)dword_8394010 )
  {
    CompileError(a4, "%s", *(const char **)dword_8394010);
    return 0;
  }
  else
  {
    v5 = v9[1];
    *a5 = v9[0];
    a5[1] = v5;
    a5[2] = a4;
    return 1;
  }
}
// 807194E: using guessed type _DWORD __cdecl sub_807194E(_DWORD, _DWORD);
// 80716CE: using guessed type int var_28[4];

//----- (0807179C) --------------------------------------------------------
int __cdecl sub_807179C(int a1, int a2, int a3, int a4, _DWORD *a5, int a6)
{
  int v6; // edx
  int v9[4]; // [esp+20h] [ebp-28h] BYREF
  int v10[6]; // [esp+30h] [ebp-18h] BYREF

  if ( (unsigned __int8)sub_80719D8(a1, v10, a6) != 1 )
  {
    sub_8071B6C(a2, a6);
LABEL_7:
    sub_806DAD8((char)a3, -1, 0);
    sub_8076D92(a4, 0);
    return 0;
  }
  sub_806EEC6(v10);
  if ( (unsigned __int8)sub_80719D8(a2, v9, a6) != 1 )
    goto LABEL_7;
  sub_806EF26();
  Scr_EvalBinaryOperator(a3, v10, v9);
  if ( *(_DWORD *)dword_8394010 )
  {
    CompileError(a4, "%s", *(const char **)dword_8394010);
    return 0;
  }
  else
  {
    v6 = v10[1];
    *a5 = v10[0];
    a5[1] = v6;
    a5[2] = a4;
    return 1;
  }
}
// 80719D8: using guessed type _DWORD __cdecl sub_80719D8(_DWORD, _DWORD, _DWORD);
// 8071B6C: using guessed type _DWORD __cdecl sub_8071B6C(_DWORD, _DWORD);
// 807179C: using guessed type int var_28[4];

//----- (080718AE) --------------------------------------------------------
void __cdecl sub_80718AE(int *a1, _DWORD *a2, char a3, int a4, int a5)
{
  byte_820287C = 1;
  sub_806F83E(a1, a5);
  byte_820287C = 0;
  sub_8071B6C(a2, a5);
  sub_806DAD8(a3, -1, 0);
  sub_8076D92(a4, 0);
  sub_8071BA0(a1, a5);
  sub_806E2EE(a4);
}
// 820287C: using guessed type char byte_820287C;

//----- (08071934) --------------------------------------------------------
_DWORD *__cdecl sub_8071934(int a1, _DWORD *a2)
{
  return sub_8071CB0(a1, a2);
}

//----- (0807194E) --------------------------------------------------------
int __cdecl sub_807194E(_DWORD *a1, _DWORD *a2)
{
  if ( *a1 == 6 )
    return (unsigned __int8)sub_8071180((_DWORD *)a1[1], a2);
  if ( *a1 == 49 )
    return (unsigned __int8)sub_80716CE(a1[1], a1[2], a1[3], a1[4], a2);
  return 0;
}

//----- (080719D8) --------------------------------------------------------
int __cdecl sub_80719D8(_DWORD *a1, _DWORD *a2, int a3)
{
  int v4; // [esp+24h] [ebp-4h]

  switch ( *a1 )
  {
    case 6:
      v4 = (unsigned __int8)sub_8071370((_DWORD *)a1[1], a2, a3);
      break;
    case 0x2F:
      sub_8071586(a1[1], a1[2], a1[3], a1[4], a3);
      v4 = 0;
      break;
    case 0x30:
      sub_807162A(a1[1], a1[2], a1[3], a1[4], a3);
      v4 = 0;
      break;
    case 0x31:
      v4 = (unsigned __int8)sub_807179C(a1[1], a1[2], a1[3], a1[4], a2, a3);
      break;
    case 0x32:
      sub_8071B6C(a1[1], a3);
      sub_806EF6A(a1[2]);
      v4 = 0;
      break;
    case 0x33:
      sub_8071B6C(a1[1], a3);
      sub_806EFA2(a1[2]);
      v4 = 0;
      break;
    default:
      v4 = 0;
      break;
  }
  return v4;
}
// 8071B6C: using guessed type _DWORD __cdecl sub_8071B6C(_DWORD, _DWORD);

//----- (08071B6C) --------------------------------------------------------
void __cdecl sub_8071B6C(_DWORD *a1, int a2)
{
  int v2[6]; // [esp+10h] [ebp-18h] BYREF

  if ( (unsigned __int8)sub_80719D8(a1, v2, a2) == 1 )
    sub_806EE00(v2);
}
// 8071B6C: using guessed type int var_18[6];

//----- (08071BA0) --------------------------------------------------------
void __cdecl sub_8071BA0(int *a1, int a2)
{
  int v2; // [esp+20h] [ebp-8h]

  v2 = *a1;
  if ( *a1 == 15 )
  {
    sub_806F4E8((_DWORD *)a1[1], a1[2], a1[3], a2);
  }
  else if ( v2 > 15 )
  {
    if ( v2 == 53 || v2 == 79 )
    {
      if ( byte_8202A64 )
        CompileError(a1[2], "$ and self field can only be used in the script debugger");
      else
        CompileError(a1[2], "not an lvalue");
    }
  }
  else if ( v2 == 4 )
  {
    sub_806F230(a1[1], a1[2], a2);
  }
  else if ( v2 == 13 )
  {
    sub_806F798((_DWORD *)a1[1], (_DWORD *)a1[2], a1[3], a1[4], a2);
  }
}
// 8202A64: using guessed type char byte_8202A64;

//----- (08071CB0) --------------------------------------------------------
_DWORD *__cdecl sub_8071CB0(int a1, _DWORD *a2)
{
  _DWORD *result; // eax

  result = *(_DWORD **)a1;
  if ( *(_DWORD *)a1 == 4 )
    return sub_806F2B2(*(_DWORD **)(a1 + 4), *(_DWORD *)(a1 + 8), a2);
  if ( *(_DWORD *)a1 == 13 )
    return (_DWORD *)sub_806F7DE(*(int **)(a1 + 4), (int)a2);
  return result;
}

//----- (08071D0A) --------------------------------------------------------
void __cdecl sub_8071D0A(_DWORD *a1, int a2, int a3)
{
  if ( *a1 == 17 )
  {
    sub_8071BA0(a1[1], a3);
  }
  else if ( *a1 == 35 )
  {
    sub_806F2D4(a1[1]);
  }
  else
  {
    CompileError(a2, "not an lvalue");
  }
}
// 8071BA0: using guessed type _DWORD __cdecl sub_8071BA0(_DWORD, _DWORD);

//----- (08071D66) --------------------------------------------------------
int __cdecl sub_8071D66(int *a1, int a2)
{
  int result; // eax

  result = *a1;
  if ( *a1 == 17 )
    return sub_8071CB0(a1[1], a2);
  return result;
}
// 8071CB0: using guessed type _DWORD __cdecl sub_8071CB0(_DWORD, _DWORD);

//----- (08071D92) --------------------------------------------------------
void __cdecl sub_8071D92(_DWORD *a1, int a2, int a3)
{
  switch ( *a1 )
  {
    case 0x11:
      sub_806F83E(a1[1], a3);
      sub_806F722(a1[2]);
      break;
    case 0x13:
      sub_8070D46(a1[1], a3);
      break;
    case 0x20:
      sub_806F104(a1[1]);
      break;
    case 0x22:
      sub_806F13C(a1[1]);
      break;
    case 0x24:
      sub_806F174(a1[1]);
      break;
    case 0x2E:
      sub_807112A(a1[1], a2, a3);
      break;
    default:
      CompileError(a2, "not an object");
      break;
  }
}
// 806F83E: using guessed type _DWORD __cdecl sub_806F83E(_DWORD, _DWORD);

//----- (08071E6A) --------------------------------------------------------
char *__cdecl sub_8071E6A(_DWORD *a1, int a2, int a3)
{
  if ( *a1 == 6 )
    return (char *)sub_8071D92(a1[1], a1[2], a3);
  else
    return CompileError(a2, "not an object");
}
// 8071D92: using guessed type _DWORD __cdecl sub_8071D92(_DWORD, _DWORD, _DWORD);

//----- (08071EB6) --------------------------------------------------------
int sub_8071EB6()
{
  int result; // eax
  int i; // [esp+10h] [ebp-8h]
  unsigned int v2; // [esp+14h] [ebp-4h]

  v2 = TempMalloc(0);
  result = dword_8202890;
  for ( i = dword_8202890; i; i = result )
  {
    **(_DWORD **)i = v2 - *(_DWORD *)(i + 4);
    result = *(_DWORD *)(i + 8);
  }
  return result;
}
// 8202890: using guessed type int dword_8202890;

//----- (08071EFA) --------------------------------------------------------
int sub_8071EFA()
{
  int result; // eax
  int i; // [esp+10h] [ebp-8h]
  unsigned int v2; // [esp+14h] [ebp-4h]

  v2 = TempMalloc(0);
  result = dword_8202898;
  for ( i = dword_8202898; i; i = result )
  {
    **(_DWORD **)i = v2 - *(_DWORD *)(i + 4);
    result = *(_DWORD *)(i + 8);
  }
  return result;
}
// 8202898: using guessed type int dword_8202898;

//----- (08071F3E) --------------------------------------------------------
_BOOL4 __cdecl sub_8071F3E(_DWORD *a1)
{
  return *a1 == 31;
}

//----- (08071F50) --------------------------------------------------------
int __cdecl sub_8071F50(int a1)
{
  int v2; // [esp+4h] [ebp-4h]

  v2 = 0;
  if ( *(_DWORD *)a1 == 6 && sub_8071F3E(*(_DWORD **)(a1 + 4)) )
    return 1;
  return v2;
}

//----- (08071F86) --------------------------------------------------------
int __cdecl sub_8071F86(int a1, int a2, int a3)
{
  int v4; // [esp+1Ch] [ebp-Ch]

  v4 = *(_DWORD *)a1;
  if ( *(_DWORD *)a1 == 15 )
  {
    sub_806F530(*(_DWORD **)(a1 + 4), *(_DWORD *)(a1 + 8), *(_DWORD *)(a1 + 12), a2, a3);
    return 1;
  }
  if ( v4 > 15 )
  {
    if ( v4 == 53 || v4 == 79 )
    {
      if ( byte_8202A64 )
        CompileError(*(_DWORD *)(a1 + 8), "$ and self field can only be used in the script debugger");
      else
        CompileError(*(_DWORD *)(a1 + 8), "not an lvalue");
    }
    return 1;
  }
  if ( v4 != 4 )
  {
    if ( v4 == 13 )
      sub_806F7F8(*(_DWORD **)(a1 + 4), *(_DWORD **)(a1 + 8), *(_DWORD *)(a1 + 12), *(_DWORD *)(a1 + 16), a3);
    return 1;
  }
  return 0;
}
// 8202A64: using guessed type char byte_8202A64;

//----- (08072088) --------------------------------------------------------
void __cdecl sub_8072088(int *a1, _DWORD *a2, int a3, int a4, int a5)
{
  if ( !(unsigned __int8)sub_8071F50((int)a2) || !(unsigned __int8)sub_8071F86((int)a1, a4, a5) )
  {
    sub_8071B6C(a2, a5);
    sub_8071BA0(a1, a5);
    sub_806E2EE(a3);
  }
}

//----- (080720EE) --------------------------------------------------------
_DWORD *__cdecl sub_80720EE(int a1, int a2, _DWORD *a3)
{
  return sub_8071CB0(a1, a3);
}

//----- (08072108) --------------------------------------------------------
char *__cdecl sub_8072108(int a1, int a2)
{
  return sub_8070CB2(a1, 1u, a2);
}

//----- (0807212A) --------------------------------------------------------
void __cdecl sub_807212A(_DWORD *a1, int a2, _DWORD *a3)
{
  if ( !*a3 )
    *a3 = 3;
  sub_8071B6C(a1, (int)a3);
  sub_806DEEA();
  sub_8076D92(a2, 0);
}

//----- (0807216E) --------------------------------------------------------
void __cdecl sub_807216E(int a1, _DWORD *a2)
{
  if ( !*a2 )
    *a2 = 3;
  sub_806DEC6();
  sub_8076D92(a1, 1);
}

//----- (080721A0) --------------------------------------------------------
void __cdecl sub_80721A0(_DWORD *a1, int a2, int a3, int a4)
{
  sub_8071B6C(a1, a4);
  sub_806DAD8(76, -1, 0);
  sub_8076D92(a3, 0);
  sub_8076D92(a3, 0);
  sub_8076D92(a2, 0);
}

//----- (08072210) --------------------------------------------------------
void __cdecl sub_8072210(int a1)
{
  sub_806DAD8(77, 0, 0);
  sub_8076D92(a1, 1);
  sub_8076D92(a1, 0);
}

//----- (0807225A) --------------------------------------------------------
unsigned int __cdecl sub_807225A(_DWORD *a1, int a2, int a3, unsigned __int8 a4, int a5, int a6, _DWORD **a7)
{
  unsigned int result; // eax
  unsigned int v8; // [esp+1Ch] [ebp-Ch]
  _WORD *v9; // [esp+20h] [ebp-8h]

  sub_8071B6C(a1, a6);
  sub_806DAD8(94, -1, 0);
  sub_8076D92(a3, 0);
  sub_806DF60(0);
  v9 = (_WORD *)dword_8202860;
  v8 = TempMalloc(0);
  sub_806EA5A(a6, *a7);
  sub_80742D2(a2, a4, a5, *a7);
  sub_806E59A(a4, a5, *a7);
  result = TempMalloc(0) - v8;
  *v9 = result;
  return result;
}
// 80742D2: using guessed type _DWORD __cdecl sub_80742D2(_DWORD, _DWORD, _DWORD, _DWORD);
// 8202860: using guessed type int dword_8202860;

//----- (0807233A) --------------------------------------------------------
void __cdecl sub_807233A(int a1, _DWORD *a2, size_t *a3)
{
  sub_806E69A(a2, a3);
  sub_8074842(a1, *a3);
  sub_806E94E((int)a3, 1, a2);
}
// 8074842: using guessed type _DWORD __cdecl sub_8074842(_DWORD, _DWORD);

//----- (08072382) --------------------------------------------------------
int __cdecl sub_8072382(
        _DWORD *a1,
        int a2,
        int a3,
        int a4,
        int a5,
        unsigned __int8 a6,
        int a7,
        int a8,
        int *a9,
        _DWORD **a10)
{
  _DWORD *v10; // ebx
  int v12; // [esp+1Ch] [ebp-2Ch]
  int v13[2]; // [esp+20h] [ebp-28h] BYREF
  int v14; // [esp+28h] [ebp-20h]
  unsigned int v15; // [esp+2Ch] [ebp-1Ch]
  unsigned int v16; // [esp+30h] [ebp-18h]
  _DWORD *v17; // [esp+34h] [ebp-14h]
  _WORD *v18; // [esp+38h] [ebp-10h]
  unsigned __int8 v19; // [esp+3Fh] [ebp-9h]

  v19 = a6;
  v12 = 0;
  sub_8071B6C(a1, a8);
  sub_806DAD8(94, -1, 0);
  sub_8076D92(a4, 0);
  sub_806DF60(0);
  v18 = (_WORD *)dword_8202860;
  v16 = TempMalloc(0);
  sub_806EA5A(a8, (_DWORD *)*a9);
  sub_80742D2(a2, a6, a7, *a9);
  sub_806E53A((_DWORD *)*a9, *a9);
  if ( !*(_DWORD *)*a9 )
  {
    v13[0] = *a9;
    v12 = 1;
  }
  v14 = dword_839403C;
  if ( v19 )
  {
    sub_806DEC6();
    sub_806DF0E(0);
    sub_8076D92(a7, 1);
    v17 = 0;
    v15 = 0;
  }
  else
  {
    sub_806DAD8(98, 0, 0);
    sub_8076D92(a5, 1);
    sub_806DF0E(0);
    v17 = (_DWORD *)dword_8202860;
    v15 = TempMalloc(0);
  }
  dword_839403C = v14 + 1;
  *v18 = TempMalloc(0) - v16;
  sub_806EA5A(a8, *a10);
  sub_80742D2(a3, v19, a7, *a10);
  sub_806E59A(v19, a7, *a10);
  if ( !**a10 )
    v13[v12++] = (int)*a10;
  if ( !v19 )
  {
    v10 = v17;
    *v10 = TempMalloc(0) - v15;
  }
  return sub_806E714((int)v13, v12, a8);
}
// 80742D2: using guessed type _DWORD __cdecl sub_80742D2(_DWORD, _DWORD, _DWORD, _DWORD);
// 8202860: using guessed type int dword_8202860;
// 839403C: using guessed type int dword_839403C;

//----- (080725C2) --------------------------------------------------------
void __cdecl sub_80725C2(int a1, int a2, int *a3, size_t *a4, size_t *a5)
{
  int v5; // [esp+18h] [ebp-10h]
  int v6; // [esp+1Ch] [ebp-Ch]
  int v7[2]; // [esp+20h] [ebp-8h] BYREF

  v6 = 0;
  v5 = 3;
  sub_806E69A(a3, a4);
  sub_8074842(a1, *a4);
  if ( *(int *)*a4 <= 3 )
  {
    v5 = *(_DWORD *)*a4;
    if ( !v5 )
    {
      v7[0] = *a4;
      v6 = 1;
    }
  }
  sub_806E69A(a3, a5);
  sub_8074842(a2, *a5);
  if ( *(_DWORD *)*a5 <= v5 )
  {
    v5 = *(_DWORD *)*a5;
    if ( !v5 )
      v7[v6++] = *a5;
  }
  if ( !*a3 )
    *a3 = v5;
  sub_806E846((int)v7, v6, a3);
  sub_806E94E((int)v7, v6, a3);
}
// 8074842: using guessed type _DWORD __cdecl sub_8074842(_DWORD, _DWORD);

//----- (080726C0) --------------------------------------------------------
int __cdecl sub_80726C0(_DWORD *a1)
{
  int result; // eax

  result = (int)a1;
  if ( !*a1 )
  {
    if ( dword_820289C )
    {
      sub_806E5EC(*(_DWORD *)dword_82028A0);
      *(_DWORD *)(dword_820289C + 4 * *(_DWORD *)dword_82028A0) = a1;
      result = dword_82028A0;
      ++*(_DWORD *)dword_82028A0;
    }
  }
  return result;
}
// 820289C: using guessed type int dword_820289C;
// 82028A0: using guessed type int dword_82028A0;

//----- (0807270E) --------------------------------------------------------
int __cdecl sub_807270E(_DWORD *a1)
{
  int result; // eax

  result = (int)a1;
  if ( !*a1 )
  {
    if ( dword_82028A8 )
    {
      sub_806E5EC(*(_DWORD *)dword_82028AC);
      *(_DWORD *)(dword_82028A8 + 4 * *(_DWORD *)dword_82028AC) = a1;
      result = dword_82028AC;
      ++*(_DWORD *)dword_82028AC;
    }
  }
  return result;
}
// 82028A8: using guessed type int dword_82028A8;
// 82028AC: using guessed type int dword_82028AC;

//----- (0807275C) --------------------------------------------------------
int __cdecl sub_807275C(_DWORD *a1, _DWORD *a2, int a3, int a4, int a5, int *a6)
{
  int result; // eax
  int v7; // [esp+14h] [ebp-54h]
  int v8; // [esp+18h] [ebp-50h]
  int v9; // [esp+1Ch] [ebp-4Ch]
  int v10; // [esp+20h] [ebp-48h] BYREF
  int v11; // [esp+24h] [ebp-44h]
  int v12; // [esp+28h] [ebp-40h]
  int v13; // [esp+2Ch] [ebp-3Ch]
  int v14; // [esp+30h] [ebp-38h] BYREF
  int v15; // [esp+34h] [ebp-34h]
  char v16; // [esp+43h] [ebp-25h]
  int v17; // [esp+44h] [ebp-24h]
  char v18; // [esp+4Ah] [ebp-1Eh]
  char v19; // [esp+4Bh] [ebp-1Dh]
  int v20; // [esp+4Ch] [ebp-1Ch]
  char v21; // [esp+52h] [ebp-16h]
  char v22; // [esp+53h] [ebp-15h]
  unsigned int v23; // [esp+54h] [ebp-14h]
  _WORD *v24; // [esp+58h] [ebp-10h]
  unsigned int v25; // [esp+5Ch] [ebp-Ch]

  v22 = byte_820288C;
  v21 = byte_820288D;
  v20 = dword_8202890;
  byte_820288C = 0;
  byte_820288D = 0;
  v19 = byte_8202894;
  v18 = byte_8202895;
  v17 = dword_8202898;
  byte_8202894 = 0;
  byte_8202895 = 0;
  sub_806EA5A(a5, (_DWORD *)*a6);
  sub_806E4CA(*a6);
  *(_DWORD *)(a5 + 4) = *(_DWORD *)(*a6 + 4);
  v25 = TempMalloc(0);
  v16 = 0;
  if ( (unsigned __int8)sub_80719D8(a1, &v14, a5) )
  {
    if ( v15 == 6 || v15 == 5 )
    {
      sub_807CC38((float *)&v14);
      if ( !v14 )
        CompileError(a3, "conditional expression cannot be always false");
      v16 = 1;
    }
    else
    {
      sub_806EE00(&v14);
    }
  }
  v13 = dword_820289C;
  v12 = dword_82028A0;
  v7 = dword_82028A4;
  v9 = dword_82028A8;
  v8 = dword_82028AC;
  v10 = 0;
  dword_82028A8 = 0;
  dword_82028A4 = *a6;
  if ( v16 )
  {
    v24 = 0;
    v23 = 0;
    v11 = Hunk_AllocateTempMemoryHighInternal(4096);
    dword_82028A0 = (int)&v10;
  }
  else
  {
    sub_806DAD8(94, -1, 0);
    sub_8076D92(a3, 0);
    sub_806DF60(0);
    v24 = (_WORD *)dword_8202860;
    v23 = TempMalloc(0);
    v11 = 0;
  }
  dword_820289C = v11;
  byte_820288C = 1;
  byte_820288D = dword_8202A68 != 0;
  dword_8202890 = 0;
  byte_8202894 = 1;
  byte_8202895 = dword_8202A68 != 0;
  dword_8202898 = 0;
  sub_80742D2(a2, 0, 0, *a6);
  if ( *(_DWORD *)*a6 != 3 )
    *(_DWORD *)*a6 = 0;
  byte_820288C = 0;
  byte_820288D = 0;
  byte_8202894 = 0;
  byte_8202895 = 0;
  sub_8071EFA();
  sub_806DAD8(99, 0, 0);
  sub_8076D92(a4, 0);
  if ( *a2 == 44 )
    sub_8076D92(a2[3], 1);
  sub_806DF60(0);
  *(_WORD *)dword_8202860 = TempMalloc(0) - v25;
  if ( v24 )
    *v24 = TempMalloc(0) - v23;
  sub_8071EB6();
  byte_820288C = v22;
  byte_820288D = v21;
  dword_8202890 = v20;
  byte_8202894 = v19;
  byte_8202895 = v18;
  dword_8202898 = v17;
  if ( v16 )
    sub_806E714(v11, v10, a5);
  dword_820289C = v13;
  dword_82028A0 = v12;
  dword_82028A4 = v7;
  dword_82028A8 = v9;
  result = v8;
  dword_82028AC = v8;
  return result;
}
// 80742D2: using guessed type _DWORD __cdecl sub_80742D2(_DWORD, _DWORD, _DWORD, _DWORD);
// 8202860: using guessed type int dword_8202860;
// 820288C: using guessed type char byte_820288C;
// 820288D: using guessed type char byte_820288D;
// 8202890: using guessed type int dword_8202890;
// 8202894: using guessed type char byte_8202894;
// 8202895: using guessed type char byte_8202895;
// 8202898: using guessed type int dword_8202898;
// 820289C: using guessed type int dword_820289C;
// 82028A0: using guessed type int dword_82028A0;
// 82028A4: using guessed type int dword_82028A4;
// 82028A8: using guessed type int dword_82028A8;
// 82028AC: using guessed type int dword_82028AC;
// 8202A68: using guessed type int dword_8202A68;
// 807275C: using guessed type int arg_10;

//----- (08072AE6) --------------------------------------------------------
int __cdecl sub_8072AE6(_DWORD *a1, int a2, int *a3, size_t *a4)
{
  int result; // eax
  int i; // [esp+1Ch] [ebp-4Ch]
  int v6; // [esp+20h] [ebp-48h]
  int v7; // [esp+24h] [ebp-44h]
  int v8; // [esp+28h] [ebp-40h] BYREF
  size_t v9; // [esp+2Ch] [ebp-3Ch]
  int v10; // [esp+30h] [ebp-38h] BYREF
  int v11; // [esp+34h] [ebp-34h]
  int v12; // [esp+38h] [ebp-30h]
  int v13; // [esp+3Ch] [ebp-2Ch]
  int v14; // [esp+40h] [ebp-28h] BYREF
  int v15; // [esp+44h] [ebp-24h]
  char v16; // [esp+5Bh] [ebp-Dh]
  int v17; // [esp+5Ch] [ebp-Ch]

  v16 = 0;
  if ( (unsigned __int8)sub_807194E(a1, &v14) )
  {
    if ( v15 == 6 || v15 == 5 )
    {
      sub_807CC38((float *)&v14);
      if ( v14 )
        v16 = 1;
    }
    RemoveRefToValue(&v14);
  }
  v13 = dword_820289C;
  v12 = dword_82028A0;
  v7 = dword_82028A8;
  v6 = dword_82028AC;
  v10 = 0;
  v8 = 0;
  v9 = Hunk_AllocateTempMemoryHighInternal(4096);
  dword_82028A8 = v9;
  dword_82028AC = (int)&v8;
  v17 = *a3;
  if ( v16 )
  {
    v11 = Hunk_AllocateTempMemoryHighInternal(4096);
    dword_82028A0 = (int)&v10;
  }
  else
  {
    v11 = 0;
  }
  dword_820289C = v11;
  sub_806E69A(a3, a4);
  sub_8074842(a2, *a4);
  sub_807270E((_DWORD *)*a4);
  for ( i = 0; i < v8; ++i )
    sub_806E846(v9 + 4 * i, 1, a3);
  if ( v16 )
    sub_806E846(v11, v10, a3);
  sub_806E94E((int)a4, 1, a3);
  dword_820289C = v13;
  dword_82028A0 = v12;
  dword_82028A8 = v7;
  result = v6;
  dword_82028AC = v6;
  return result;
}
// 8074842: using guessed type _DWORD __cdecl sub_8074842(_DWORD, _DWORD);
// 820289C: using guessed type int dword_820289C;
// 82028A0: using guessed type int dword_82028A0;
// 82028A8: using guessed type int dword_82028A8;
// 82028AC: using guessed type int dword_82028AC;

//----- (08072C7E) --------------------------------------------------------
int __cdecl sub_8072C7E(int a1, int a2, int a3, _DWORD *a4, int a5, int a6, int a7, int *a8, int *a9)
{
  int result; // eax
  int v10; // [esp+1Ch] [ebp-5Ch]
  int v11; // [esp+20h] [ebp-58h]
  int v12; // [esp+24h] [ebp-54h]
  int v13; // [esp+28h] [ebp-50h] BYREF
  int v14; // [esp+2Ch] [ebp-4Ch]
  int v15; // [esp+30h] [ebp-48h] BYREF
  int v16; // [esp+34h] [ebp-44h]
  int v17; // [esp+38h] [ebp-40h]
  int v18; // [esp+3Ch] [ebp-3Ch]
  int v19; // [esp+40h] [ebp-38h] BYREF
  int v20; // [esp+44h] [ebp-34h]
  char v21; // [esp+53h] [ebp-25h]
  int v22; // [esp+54h] [ebp-24h]
  char v23; // [esp+5Ah] [ebp-1Eh]
  char v24; // [esp+5Bh] [ebp-1Dh]
  int v25; // [esp+5Ch] [ebp-1Ch]
  char v26; // [esp+62h] [ebp-16h]
  char v27; // [esp+63h] [ebp-15h]
  unsigned int v28; // [esp+64h] [ebp-14h]
  _WORD *v29; // [esp+68h] [ebp-10h]
  unsigned int v30; // [esp+6Ch] [ebp-Ch]

  v27 = byte_820288C;
  v26 = byte_820288D;
  v25 = dword_8202890;
  byte_820288C = 0;
  byte_820288D = 0;
  v24 = byte_8202894;
  v23 = byte_8202895;
  v22 = dword_8202898;
  byte_8202894 = 0;
  byte_8202895 = 0;
  sub_80742D2(a1, 0, 0, a7);
  sub_806EA5A(a7, (_DWORD *)*a8);
  sub_806E4CA(*a8);
  *(_DWORD *)(a7 + 4) = *(_DWORD *)(*a8 + 4);
  sub_806EA5A(a7, (_DWORD *)*a9);
  v30 = TempMalloc(0);
  if ( *(_DWORD *)a2 == 65 )
  {
    v21 = 0;
    if ( (unsigned __int8)sub_80719D8(*(_DWORD **)(a2 + 4), &v19, a7) )
    {
      if ( v20 == 6 || v20 == 5 )
      {
        sub_807CC38((float *)&v19);
        if ( !v19 )
          CompileError(a5, "conditional expression cannot be always false");
        v21 = 1;
      }
      else
      {
        sub_806EE00(&v19);
      }
    }
  }
  else
  {
    v21 = 1;
  }
  v18 = dword_820289C;
  v17 = dword_82028A0;
  v10 = dword_82028A4;
  v12 = dword_82028A8;
  v11 = dword_82028AC;
  v15 = 0;
  v13 = 0;
  v14 = Hunk_AllocateTempMemoryHighInternal(4096);
  dword_82028A8 = v14;
  dword_82028AC = (int)&v13;
  dword_82028A4 = *a8;
  if ( v21 )
  {
    v29 = 0;
    v28 = 0;
    v16 = Hunk_AllocateTempMemoryHighInternal(4096);
    dword_82028A0 = (int)&v15;
  }
  else
  {
    sub_806DAD8(94, -1, 0);
    sub_8076D92(a5, 0);
    sub_806DF60(0);
    v29 = (_WORD *)dword_8202860;
    v28 = TempMalloc(0);
    v16 = 0;
  }
  dword_820289C = v16;
  byte_820288C = 1;
  byte_820288D = dword_8202A68 != 0;
  dword_8202890 = 0;
  byte_8202894 = 1;
  byte_8202895 = dword_8202A68 != 0;
  dword_8202898 = 0;
  sub_80742D2(a4, 0, 0, *a8);
  sub_807270E((_DWORD *)*a8);
  byte_820288C = 0;
  byte_820288D = 0;
  byte_8202894 = 0;
  byte_8202895 = 0;
  sub_8071EFA();
  sub_806E714(v14, v13, *a9);
  sub_80742D2(a3, 0, 0, *a9);
  sub_806DAD8(99, 0, 0);
  sub_8076D92(a6, 0);
  if ( *a4 == 44 )
    sub_8076D92(a4[3], 1);
  sub_806DF60(0);
  *(_WORD *)dword_8202860 = TempMalloc(0) - v30;
  if ( v29 )
    *v29 = TempMalloc(0) - v28;
  sub_8071EB6();
  byte_820288C = v27;
  byte_820288D = v26;
  dword_8202890 = v25;
  byte_8202894 = v24;
  byte_8202895 = v23;
  dword_8202898 = v22;
  if ( v21 )
    sub_806E714(v16, v15, a7);
  dword_820289C = v18;
  dword_82028A0 = v17;
  dword_82028A4 = v10;
  dword_82028A8 = v12;
  result = v11;
  dword_82028AC = v11;
  return result;
}
// 80742D2: using guessed type _DWORD __cdecl sub_80742D2(_DWORD, _DWORD, _DWORD, _DWORD);
// 8202860: using guessed type int dword_8202860;
// 820288C: using guessed type char byte_820288C;
// 820288D: using guessed type char byte_820288D;
// 8202890: using guessed type int dword_8202890;
// 8202894: using guessed type char byte_8202894;
// 8202895: using guessed type char byte_8202895;
// 8202898: using guessed type int dword_8202898;
// 820289C: using guessed type int dword_820289C;
// 82028A0: using guessed type int dword_82028A0;
// 82028A4: using guessed type int dword_82028A4;
// 82028A8: using guessed type int dword_82028A8;
// 82028AC: using guessed type int dword_82028AC;
// 8202A68: using guessed type int dword_8202A68;
// 8072C7E: using guessed type int arg_18;

//----- (080730A4) --------------------------------------------------------
int __cdecl sub_80730A4(int a1, int a2, int a3, int a4, int *a5, size_t *a6, size_t *a7)
{
  int result; // eax
  int i; // [esp+1Ch] [ebp-4Ch]
  int v9; // [esp+20h] [ebp-48h]
  int v10; // [esp+24h] [ebp-44h]
  int v11; // [esp+28h] [ebp-40h] BYREF
  size_t v12; // [esp+2Ch] [ebp-3Ch]
  int v13; // [esp+30h] [ebp-38h] BYREF
  int v14; // [esp+34h] [ebp-34h]
  int v15; // [esp+38h] [ebp-30h]
  int v16; // [esp+3Ch] [ebp-2Ch]
  int v17; // [esp+40h] [ebp-28h] BYREF
  int v18; // [esp+44h] [ebp-24h]
  char v19; // [esp+5Bh] [ebp-Dh]
  int v20; // [esp+5Ch] [ebp-Ch]

  sub_8074842(a1, a5);
  if ( *(_DWORD *)a2 == 65 )
  {
    v19 = 0;
    if ( (unsigned __int8)sub_807194E(*(_DWORD **)(a2 + 4), &v17) )
    {
      if ( v18 == 6 || v18 == 5 )
      {
        sub_807CC38((float *)&v17);
        if ( v17 )
          v19 = 1;
      }
      RemoveRefToValue(&v17);
    }
  }
  else
  {
    v19 = 1;
  }
  v16 = dword_820289C;
  v15 = dword_82028A0;
  v10 = dword_82028A8;
  v9 = dword_82028AC;
  v13 = 0;
  v11 = 0;
  v12 = Hunk_AllocateTempMemoryHighInternal(4096);
  dword_82028A8 = v12;
  dword_82028AC = (int)&v11;
  v20 = *a5;
  if ( v19 )
  {
    v14 = Hunk_AllocateTempMemoryHighInternal(4096);
    dword_82028A0 = (int)&v13;
  }
  else
  {
    v14 = 0;
  }
  dword_820289C = v14;
  sub_806E69A(a5, a6);
  sub_806E69A(a5, a7);
  sub_8074842(a4, *a6);
  sub_807270E((_DWORD *)*a6);
  for ( i = 0; i < v11; ++i )
    sub_806E846(v12 + 4 * i, 1, a5);
  sub_8074842(a3, *a7);
  sub_806E846((int)a7, 1, a5);
  sub_806E94E((int)a7, 1, a5);
  if ( v19 )
    sub_806E846(v14, v13, a5);
  sub_806E94E((int)a6, 1, a5);
  dword_820289C = v16;
  dword_82028A0 = v15;
  dword_82028A8 = v10;
  result = v9;
  dword_82028AC = v9;
  return result;
}
// 8074842: using guessed type _DWORD __cdecl sub_8074842(_DWORD, _DWORD);
// 820289C: using guessed type int dword_820289C;
// 82028A0: using guessed type int dword_82028A0;
// 82028A8: using guessed type int dword_82028A8;
// 82028AC: using guessed type int dword_82028AC;

//----- (080732BA) --------------------------------------------------------
void __cdecl sub_80732BA(int *a1, int a2, int a3)
{
  byte_82028B0 = 1;
  sub_8071BA0(a1, a3);
  byte_82028B0 = 0;
  sub_806DAD8(100, 1, 0);
  sub_8076D92(a2, 0);
  sub_806E2EE(a2);
}
// 82028B0: using guessed type char byte_82028B0;

//----- (0807331C) --------------------------------------------------------
_DWORD *__cdecl sub_807331C(int a1, _DWORD *a2)
{
  return sub_8071CB0(a1, a2);
}

//----- (08073336) --------------------------------------------------------
void __cdecl sub_8073336(int *a1, int a2, int a3)
{
  byte_82028B0 = 1;
  sub_8071BA0(a1, a3);
  byte_82028B0 = 0;
  sub_806DAD8(101, 1, 0);
  sub_8076D92(a2, 0);
  sub_806E2EE(a2);
}
// 82028B0: using guessed type char byte_82028B0;

//----- (08073398) --------------------------------------------------------
int **__cdecl sub_8073398(int **a1, int a2)
{
  int **result; // eax

  while ( 1 )
  {
    result = (int **)a1[1];
    a1 = result;
    if ( !result )
      break;
    sub_806EB94(**result, (*result)[1], a2);
  }
  return result;
}

//----- (080733DA) --------------------------------------------------------
_DWORD ***__cdecl sub_80733DA(_DWORD ***a1, _DWORD *a2)
{
  _DWORD ***result; // eax

  while ( 1 )
  {
    result = (_DWORD ***)a1[1];
    a1 = result;
    if ( !result )
      break;
    sub_806EC16(**result, (int)(*result)[1], a2);
  }
  return result;
}

//----- (0807341C) --------------------------------------------------------
int **__cdecl sub_807341C(int **a1, int a2)
{
  int **result; // eax

  while ( 1 )
  {
    result = (int **)a1[1];
    a1 = result;
    if ( !result )
      break;
    sub_806EC38(**result, (*result)[1], a2);
  }
  return result;
}

//----- (0807345E) --------------------------------------------------------
int __cdecl sub_807345E(int a1, int a2, int a3, int a4, int a5)
{
  int **v6; // [esp+14h] [ebp-4h]

  v6 = *(int ***)(*(_DWORD *)a2 + 4);
  sub_8071B6C((_DWORD *)**v6, a5);
  sub_8071552(a1, a5);
  sub_806DAD8(120, -2, 0);
  sub_8076D92(a4, 0);
  sub_8076D92(a4, 0);
  sub_8076D92(a3, 0);
  sub_8076D92((*v6)[1], 0);
  sub_807341C(v6, a5);
  return sub_806DAD8(52, 0, 0);
}

//----- (08073538) --------------------------------------------------------
_DWORD ***__cdecl sub_8073538(int a1, _DWORD *a2)
{
  return sub_80733DA(*(_DWORD ****)(*(_DWORD *)a1 + 4), a2);
}

//----- (08073560) --------------------------------------------------------
int __cdecl sub_8073560(int a1, int a2, int a3, int a4, int a5)
{
  int i; // [esp+10h] [ebp-8h]
  int v7; // [esp+14h] [ebp-4h]
  int v8; // [esp+14h] [ebp-4h]

  v7 = *(_DWORD *)(*(_DWORD *)a2 + 4);
  for ( i = 0; ; ++i )
  {
    v7 = *(_DWORD *)(v7 + 4);
    if ( !v7 )
      break;
    sub_8071B6C(**(_DWORD ***)v7, a5);
  }
  v8 = *(_DWORD *)(*(_DWORD *)a2 + 4);
  sub_8071B6C(**(_DWORD ***)v8, a5);
  sub_8071552(a1, a5);
  sub_806DAD8(119, -2 - i, 0);
  sub_8076D92(a4, 0);
  sub_8076D92(a4, 0);
  sub_8076D92(a3, 0);
  sub_8076D92(*(_DWORD *)(*(_DWORD *)v8 + 4), 0);
  while ( 1 )
  {
    v8 = *(_DWORD *)(v8 + 4);
    if ( !v8 )
      break;
    sub_8076D92(*(_DWORD *)(*(_DWORD *)v8 + 4), 0);
  }
  sub_806DF8E(i);
  return sub_806DAD8(52, 0, 0);
}

//----- (080736AC) --------------------------------------------------------
void __cdecl sub_80736AC(int a1, int *a2, int a3, int a4, int a5)
{
  int v5; // [esp+Ch] [ebp-Ch]
  int i; // [esp+10h] [ebp-8h]
  int v7; // [esp+14h] [ebp-4h]

  sub_806DAD8(123, 1, 0);
  sub_8076D92(a3, 1);
  v5 = 0;
  v7 = 0;
  for ( i = *a2; i; i = *(_DWORD *)(i + 4) )
  {
    v7 = i;
    sub_8071B6C(**(_DWORD ***)i, a5);
    ++v5;
  }
  sub_8071552(a1, a5);
  sub_806DAD8(121, -v5 - 2, 0);
  sub_8076D92(a4, 0);
  sub_8076D92(*(_DWORD *)(*(_DWORD *)v7 + 4), 0);
  sub_8076D92(a3, 0);
}

//----- (080737A2) --------------------------------------------------------
void __cdecl sub_80737A2(int a1, _DWORD *a2, int a3, int a4, int a5)
{
  sub_8071B6C(a2, a5);
  sub_8071552(a1, a5);
  sub_806DAD8(122, -2, 0);
  sub_8076D92(a4, 0);
  sub_8076D92(a3, 0);
}

//----- (08073810) --------------------------------------------------------
int __cdecl compar(_DWORD *a1, _DWORD *a2)
{
  if ( *a1 <= *a2 )
    return *a1 < *a2;
  else
    return -1;
}

//----- (0807384C) --------------------------------------------------------
int __cdecl sub_807384C(int a1)
{
  if ( !a1 )
    return 1;
  if ( byte_839400B )
    return 0;
  while ( a1 )
  {
    if ( **(_DWORD **)a1 != 45 )
      return 0;
    a1 = *(_DWORD *)(a1 + 4);
  }
  return 1;
}
// 839400B: using guessed type char byte_839400B;

//----- (080738A8) --------------------------------------------------------
void __cdecl sub_80738A8(_DWORD *a1, int a2)
{
  char *v2; // eax
  int v3; // [esp+14h] [ebp-4h]
  int v4; // [esp+14h] [ebp-4h]

  if ( *a1 == 7 )
  {
    if ( IsValidArrayIndex(a1[1]) )
    {
      v3 = sub_807BADA(a1[1]);
      sub_8074020(v3, a2);
    }
    else
    {
      v2 = va("case index %d out of range", a1[1]);
      CompileError(a2, v2);
    }
  }
  else if ( *a1 == 11 )
  {
    v4 = a1[1];
    sub_806DA94(v4, 1u);
    sub_8074020(v4, a2);
  }
  else
  {
    CompileError(a2, "case expression must be an int or string");
  }
}

//----- (08073964) --------------------------------------------------------
void __cdecl sub_8073964(int a1)
{
  sub_8074020(0, a1);
}

//----- (08073980) --------------------------------------------------------
char *__cdecl sub_8073980(int a1, char a2, int a3, int a4)
{
  char *result; // eax
  int v5; // [esp+10h] [ebp-28h]
  int v6; // [esp+14h] [ebp-24h]
  int v7; // [esp+18h] [ebp-20h]
  int v8; // [esp+1Ch] [ebp-1Ch]
  int v9; // [esp+20h] [ebp-18h] BYREF
  int v10; // [esp+24h] [ebp-14h]
  char v11; // [esp+2Bh] [ebp-Dh]
  _DWORD *v12; // [esp+2Ch] [ebp-Ch]
  _DWORD *i; // [esp+30h] [ebp-8h]
  char v14; // [esp+37h] [ebp-1h]

  v14 = a2;
  v8 = dword_820289C;
  v7 = dword_82028A0;
  v6 = dword_82028A4;
  v9 = 0;
  v10 = Hunk_AllocateTempMemoryHighInternal(4096);
  dword_820289C = v10;
  dword_82028A0 = (int)&v9;
  dword_82028A4 = 0;
  v11 = 0;
  for ( i = *(_DWORD **)(*(_DWORD *)a1 + 4); i; i = v12 )
  {
    v12 = (_DWORD *)i[1];
    if ( *(_DWORD *)*i == 61 || *(_DWORD *)*i == 62 )
    {
      if ( dword_82028A4 )
      {
        byte_820288C = 0;
        sub_806E53A((_DWORD *)dword_82028A4, dword_82028A4);
      }
      if ( *(_DWORD *)*i == 61 )
      {
        dword_82028A4 = *(_DWORD *)(*i + 12);
        sub_80738A8(*(_DWORD **)(*i + 4), *(_DWORD *)(*i + 8));
      }
      else
      {
        dword_82028A4 = *(_DWORD *)(*i + 8);
        v11 = 1;
        sub_8073964(*(_DWORD *)(*i + 4));
      }
      sub_806EA5A(a4, (_DWORD *)dword_82028A4);
      byte_820288C = 1;
    }
    else
    {
      if ( !dword_82028A4 )
        return CompileError(a3, "missing case statement");
      v5 = 0;
      if ( v14 && (unsigned __int8)sub_807384C((int)v12) )
        v5 = 1;
      sub_80742D2(*i, v5, a3, dword_82028A4);
      if ( dword_82028A4 && *(_DWORD *)dword_82028A4 )
      {
        dword_82028A4 = 0;
        byte_820288C = 0;
      }
    }
  }
  if ( dword_82028A4 )
  {
    byte_820288C = 0;
    sub_806E53A((_DWORD *)dword_82028A4, dword_82028A4);
  }
  if ( v11 )
  {
    if ( dword_82028A4 )
      sub_80726C0((_DWORD *)dword_82028A4);
    sub_806E714(v10, v9, a4);
  }
  dword_820289C = v8;
  dword_82028A0 = v7;
  result = (char *)v6;
  dword_82028A4 = v6;
  return result;
}
// 80742D2: using guessed type _DWORD __cdecl sub_80742D2(_DWORD, _DWORD, _DWORD, _DWORD);
// 820288C: using guessed type char byte_820288C;
// 820289C: using guessed type int dword_820289C;
// 82028A0: using guessed type int dword_82028A0;
// 82028A4: using guessed type int dword_82028A4;

//----- (08073BC8) --------------------------------------------------------
int __cdecl sub_8073BC8(int a1, int *a2)
{
  int result; // eax
  int v3; // [esp+10h] [ebp-28h]
  int v4; // [esp+14h] [ebp-24h]
  int v5; // [esp+18h] [ebp-20h]
  char v6; // [esp+1Fh] [ebp-19h]
  int *v7; // [esp+20h] [ebp-18h] BYREF
  int v8; // [esp+24h] [ebp-14h]
  int v9; // [esp+28h] [ebp-10h]
  int v10; // [esp+2Ch] [ebp-Ch] BYREF
  int v11; // [esp+30h] [ebp-8h]
  _DWORD *i; // [esp+34h] [ebp-4h]

  v5 = 3;
  v9 = dword_820289C;
  v8 = dword_82028A0;
  v10 = 0;
  v11 = Hunk_AllocateTempMemoryHighInternal(4096);
  dword_820289C = v11;
  dword_82028A0 = (int)&v10;
  v3 = 0;
  v7 = 0;
  v6 = 0;
  v4 = Hunk_AllocateTempMemoryHighInternal(4096);
  for ( i = *(_DWORD **)(*(_DWORD *)a1 + 4); i; i = (_DWORD *)i[1] )
  {
    if ( *(_DWORD *)*i == 61 || *(_DWORD *)*i == 62 )
    {
      v7 = 0;
      sub_806E69A(a2, (size_t *)&v7);
      if ( *(_DWORD *)*i == 61 )
      {
        *(_DWORD *)(*i + 12) = v7;
      }
      else
      {
        *(_DWORD *)(*i + 8) = v7;
        v6 = 1;
      }
    }
    else if ( v7 )
    {
      sub_8074842(*i, v7);
      if ( *v7 )
      {
        if ( *v7 == 2 )
        {
          *v7 = 0;
          v5 = 0;
          sub_806E5EC(v3);
          *(_DWORD *)(v4 + 4 * v3++) = v7;
        }
        else if ( *v7 <= v5 )
        {
          v5 = *v7;
        }
        v7 = 0;
      }
    }
  }
  if ( v6 )
  {
    if ( v7 )
    {
      sub_80726C0(v7);
      sub_806E5EC(v3);
      *(_DWORD *)(v4 + 4 * v3++) = v7;
    }
    if ( !*a2 )
      *a2 = v5;
    sub_806E846(v11, v10, a2);
    sub_806E94E(v4, v3, a2);
  }
  dword_820289C = v9;
  result = v8;
  dword_82028A0 = v8;
  return result;
}
// 8074842: using guessed type _DWORD __cdecl sub_8074842(_DWORD, _DWORD);
// 820289C: using guessed type int dword_820289C;
// 82028A0: using guessed type int dword_82028A0;

//----- (08073DBC) --------------------------------------------------------
char *__cdecl sub_8073DBC(_DWORD *a1, int a2, int a3, char a4, int a5, int a6)
{
  char *result; // eax
  int nmemb; // [esp+10h] [ebp-28h]
  unsigned int v8; // [esp+14h] [ebp-24h]
  _DWORD *base; // [esp+18h] [ebp-20h]
  _WORD *v10; // [esp+1Ch] [ebp-1Ch]
  _DWORD *v11; // [esp+20h] [ebp-18h]
  int v12; // [esp+24h] [ebp-14h]
  char v13; // [esp+2Ah] [ebp-Eh]
  char v14; // [esp+2Bh] [ebp-Dh]
  int *v15; // [esp+2Ch] [ebp-Ch]
  _DWORD *i; // [esp+2Ch] [ebp-Ch]
  int v17; // [esp+30h] [ebp-8h]
  char v18; // [esp+36h] [ebp-2h]

  v18 = byte_8202886;
  v17 = dword_8202888;
  byte_8202886 = 0;
  v14 = byte_820288C;
  v13 = byte_820288D;
  v12 = dword_8202890;
  byte_820288C = 0;
  byte_820288D = 0;
  sub_8071B6C(a1, a6);
  sub_806DAD8(124, -1, 0);
  sub_806DF0E(0);
  v11 = (_DWORD *)dword_8202860;
  v8 = TempMalloc(0);
  byte_8202886 = dword_8202A68 != 0;
  dword_8202888 = 0;
  byte_820288D = dword_8202A68 != 0;
  dword_8202890 = 0;
  sub_8073980(a2, a4, a5, a6);
  byte_8202886 = 0;
  byte_820288D = 0;
  sub_806DAD8(125, 0, 0);
  sub_8076D92(a3, 0);
  sub_806DF32(0);
  v10 = (_WORD *)dword_8202860;
  *v11 = dword_8202860 - v8;
  base = (_DWORD *)TempMallocAlignStrict(0);
  nmemb = 0;
  v15 = (int *)dword_8202888;
  while ( v15 )
  {
    sub_806DF0E(*v15);
    sub_806E004(v15[1]);
    v15 = (int *)v15[3];
    ++nmemb;
  }
  *v10 = nmemb;
  qsort(base, nmemb, 8u, (__compar_fn_t)compar);
  while ( nmemb > 1 )
  {
    if ( *base == base[2] )
    {
      for ( i = (_DWORD *)dword_8202888; i; i = (_DWORD *)i[3] )
      {
        if ( *i == *base )
          return CompileError(i[2], "duplicate case expression");
      }
    }
    --nmemb;
    base += 2;
  }
  sub_8071EB6();
  byte_8202886 = v18;
  dword_8202888 = v17;
  byte_820288C = v14;
  byte_820288D = v13;
  result = (char *)v12;
  dword_8202890 = v12;
  return result;
}
// 8202860: using guessed type int dword_8202860;
// 8202886: using guessed type char byte_8202886;
// 8202888: using guessed type int dword_8202888;
// 820288C: using guessed type char byte_820288C;
// 820288D: using guessed type char byte_820288D;
// 8202890: using guessed type int dword_8202890;
// 8202A68: using guessed type int dword_8202A68;

//----- (08074020) --------------------------------------------------------
void __cdecl sub_8074020(int a1, int a2)
{
  _DWORD *v2; // [esp+10h] [ebp-8h]

  if ( dword_8202A68 != 2 )
  {
    v2 = (_DWORD *)Hunk_AllocateTempMemoryHighInternal(16);
    *v2 = a1;
    v2[1] = TempMalloc(0);
    v2[2] = a2;
    v2[3] = dword_8202888;
    dword_8202888 = (int)v2;
  }
}
// 8202888: using guessed type int dword_8202888;
// 8202A68: using guessed type int dword_8202A68;

//----- (0807407E) --------------------------------------------------------
char *__cdecl sub_807407E(int a1, _DWORD *a2)
{
  char *result; // eax
  char *v3; // [esp+10h] [ebp-8h]

  if ( !byte_820288C || *a2 )
    return CompileError(a1, "illegal break statement");
  sub_80726C0(a2);
  sub_806E53A(a2, dword_82028A4);
  *a2 = 2;
  sub_806DAD8(98, 0, 0);
  sub_8076D92(a1, 1);
  sub_806DF0E(0);
  v3 = (char *)Hunk_AllocateTempMemoryHighInternal(12);
  *(_DWORD *)v3 = dword_8202860;
  *((_DWORD *)v3 + 1) = TempMalloc(0);
  *((_DWORD *)v3 + 2) = dword_8202890;
  result = v3;
  dword_8202890 = (int)v3;
  return result;
}
// 8202860: using guessed type int dword_8202860;
// 820288C: using guessed type char byte_820288C;
// 8202890: using guessed type int dword_8202890;
// 82028A4: using guessed type int dword_82028A4;

//----- (08074158) --------------------------------------------------------
char *__cdecl sub_8074158(int a1, _DWORD *a2)
{
  char *result; // eax
  char *v3; // [esp+10h] [ebp-8h]

  if ( !byte_8202894 || *a2 )
    return CompileError(a1, "illegal continue statement");
  sub_807270E(a2);
  sub_806E53A(a2, (int)a2);
  *a2 = 1;
  sub_806DAD8(98, 0, 0);
  sub_8076D92(a1, 1);
  sub_806DF0E(0);
  v3 = (char *)Hunk_AllocateTempMemoryHighInternal(12);
  *(_DWORD *)v3 = dword_8202860;
  *((_DWORD *)v3 + 1) = TempMalloc(0);
  *((_DWORD *)v3 + 2) = dword_8202898;
  result = v3;
  dword_8202898 = (int)v3;
  return result;
}
// 8202860: using guessed type int dword_8202860;
// 8202894: using guessed type char byte_8202894;
// 8202898: using guessed type int dword_8202898;

//----- (08074230) --------------------------------------------------------
void sub_8074230()
{
  ;
}

//----- (08074236) --------------------------------------------------------
int __cdecl sub_8074236(int a1, int a2, unsigned __int8 a3)
{
  if ( !byte_839400B )
    return sub_806D9EC(a1);
  sub_806D9EC(a1);
  sub_806DAD8(a3, 0, 0);
  return sub_806DF8E(0);
}
// 839400B: using guessed type char byte_839400B;

//----- (0807428E) --------------------------------------------------------
int __cdecl sub_807428E(int a1, int a2)
{
  return sub_8074236(a1, a2, 0x85u);
}

//----- (080742B0) --------------------------------------------------------
int __cdecl sub_80742B0(int a1, int a2)
{
  return sub_8074236(a1, a2, 0x86u);
}

//----- (080742D2) --------------------------------------------------------
void __cdecl sub_80742D2(int a1, unsigned __int8 a2, int a3, _DWORD *a4)
{
  switch ( *(_DWORD *)a1 )
  {
    case 2:
      sub_8072088(*(int **)(a1 + 4), *(_DWORD **)(a1 + 8), *(_DWORD *)(a1 + 12), *(_DWORD *)(a1 + 16), (int)a4);
      break;
    case 0x19:
      sub_8072108(*(_DWORD *)(a1 + 4), (int)a4);
      break;
    case 0x1B:
      sub_807212A(*(_DWORD **)(a1 + 4), *(_DWORD *)(a1 + 8), a4);
      break;
    case 0x1C:
      sub_807216E(*(_DWORD *)(a1 + 4), a4);
      break;
    case 0x1D:
      sub_80721A0(*(_DWORD **)(a1 + 4), *(_DWORD *)(a1 + 8), *(_DWORD *)(a1 + 12), (int)a4);
      break;
    case 0x25:
      sub_807225A(
        *(_DWORD **)(a1 + 4),
        *(_DWORD *)(a1 + 8),
        *(_DWORD *)(a1 + 12),
        a2,
        a3,
        (int)a4,
        (_DWORD **)(a1 + 16));
      break;
    case 0x26:
      sub_8072382(
        *(_DWORD **)(a1 + 4),
        *(_DWORD *)(a1 + 8),
        *(_DWORD *)(a1 + 12),
        *(_DWORD *)(a1 + 16),
        *(_DWORD *)(a1 + 20),
        a2,
        a3,
        (int)a4,
        (int *)(a1 + 24),
        (_DWORD **)(a1 + 28));
      break;
    case 0x27:
      sub_807275C(
        *(_DWORD **)(a1 + 4),
        *(_DWORD **)(a1 + 8),
        *(_DWORD *)(a1 + 12),
        *(_DWORD *)(a1 + 16),
        (int)a4,
        (int *)(a1 + 20));
      break;
    case 0x28:
      sub_8072C7E(
        *(_DWORD *)(a1 + 4),
        *(_DWORD *)(a1 + 8),
        *(_DWORD *)(a1 + 12),
        *(_DWORD **)(a1 + 16),
        *(_DWORD *)(a1 + 20),
        *(_DWORD *)(a1 + 24),
        (int)a4,
        (int *)(a1 + 28),
        (int *)(a1 + 32));
      break;
    case 0x29:
      sub_80732BA(*(int **)(a1 + 4), *(_DWORD *)(a1 + 8), (int)a4);
      break;
    case 0x2A:
      sub_8073336(*(int **)(a1 + 4), *(_DWORD *)(a1 + 8), (int)a4);
      break;
    case 0x2B:
      sub_80718AE(*(int **)(a1 + 4), *(_DWORD **)(a1 + 8), *(_DWORD *)(a1 + 12), *(_DWORD *)(a1 + 16), (int)a4);
      break;
    case 0x2C:
      sub_8074A7A(*(_DWORD *)(a1 + 4), a2, a3, a4);
      break;
    case 0x2D:
      sub_8074B7C(*(_DWORD *)(a1 + 4), *(_DWORD *)(a1 + 8), (int)a4, (int *)(a1 + 12));
      break;
    case 0x37:
      sub_807345E(*(_DWORD *)(a1 + 4), *(_DWORD *)(a1 + 8), *(_DWORD *)(a1 + 12), *(_DWORD *)(a1 + 16), (int)a4);
      break;
    case 0x38:
      sub_8073560(*(_DWORD *)(a1 + 4), *(_DWORD *)(a1 + 8), *(_DWORD *)(a1 + 12), *(_DWORD *)(a1 + 16), (int)a4);
      break;
    case 0x39:
      sub_8072210(*(_DWORD *)(a1 + 4));
      break;
    case 0x3A:
      sub_80736AC(*(_DWORD *)(a1 + 4), *(int **)(a1 + 8), *(_DWORD *)(a1 + 12), *(_DWORD *)(a1 + 16), (int)a4);
      break;
    case 0x3B:
      sub_80737A2(*(_DWORD *)(a1 + 4), *(_DWORD **)(a1 + 8), *(_DWORD *)(a1 + 12), *(_DWORD *)(a1 + 16), (int)a4);
      break;
    case 0x3C:
      sub_8073DBC(*(_DWORD **)(a1 + 4), *(_DWORD *)(a1 + 8), *(_DWORD *)(a1 + 12), a2, a3, (int)a4);
      break;
    case 0x3D:
      CompileError(*(_DWORD *)(a1 + 8), "illegal case statement");
      break;
    case 0x3E:
      CompileError(*(_DWORD *)(a1 + 4), "illegal default statement");
      break;
    case 0x3F:
      sub_807407E(*(_DWORD *)(a1 + 4), a4);
      break;
    case 0x40:
      sub_8074158(*(_DWORD *)(a1 + 4), a4);
      break;
    case 0x4B:
      sub_8074230();
      break;
    case 0x4C:
      sub_807428E(*(_DWORD *)(a1 + 4), *(_DWORD *)(a1 + 8));
      break;
    case 0x4D:
      sub_80742B0(*(_DWORD *)(a1 + 4), *(_DWORD *)(a1 + 8));
      break;
    default:
      return;
  }
}
// 8074A7A: using guessed type _DWORD __cdecl sub_8074A7A(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (08074842) --------------------------------------------------------
void __cdecl sub_8074842(size_t *a1, int *a2)
{
  switch ( *a1 )
  {
    case 2u:
      sub_80720EE(a1[1], a1[2], a2);
      break;
    case 0x1Bu:
    case 0x1Cu:
      if ( !*a2 )
        *a2 = 3;
      break;
    case 0x25u:
      sub_807233A(a1[2], a2, a1 + 4);
      break;
    case 0x26u:
      sub_80725C2(a1[2], a1[3], a2, a1 + 6, a1 + 7);
      break;
    case 0x27u:
      sub_8072AE6((_DWORD *)a1[1], a1[2], a2, a1 + 5);
      break;
    case 0x28u:
      sub_80730A4(a1[1], a1[2], a1[3], a1[4], a2, a1 + 7, a1 + 8);
      break;
    case 0x29u:
    case 0x2Au:
      sub_807331C(a1[1], a2);
      break;
    case 0x2Bu:
      sub_8071934(a1[1], a2);
      break;
    case 0x2Cu:
      sub_8074AF6(a1[1], a2);
      break;
    case 0x2Du:
      sub_8074B34(a1[1], a2, a1 + 3);
      break;
    case 0x37u:
      sub_8073538(a1[2], a2);
      break;
    case 0x3Cu:
      sub_8073BC8(a1[2], a2);
      break;
    case 0x3Fu:
      sub_80726C0(a2);
      if ( !*a2 )
        *a2 = 2;
      break;
    case 0x40u:
      sub_807270E(a2);
      if ( !*a2 )
        *a2 = 1;
      break;
    default:
      return;
  }
}
// 8074AF6: using guessed type _DWORD __cdecl sub_8074AF6(_DWORD, _DWORD);

//----- (08074A7A) --------------------------------------------------------
int *__cdecl sub_8074A7A(int a1, char a2, int a3, _DWORD *a4)
{
  int *result; // eax
  unsigned __int8 v5; // [esp+18h] [ebp-10h]
  int v6; // [esp+1Ch] [ebp-Ch]
  int *i; // [esp+20h] [ebp-8h]

  result = *(int **)(*(_DWORD *)a1 + 4);
  for ( i = result; i; i = (int *)v6 )
  {
    v6 = i[1];
    v5 = 0;
    if ( a2 )
    {
      if ( (unsigned __int8)sub_807384C(v6) )
        v5 = 1;
    }
    sub_80742D2(*i, v5, a3, a4);
    result = (int *)v6;
  }
  return result;
}

//----- (08074AF6) --------------------------------------------------------
int __cdecl sub_8074AF6(int a1, int *a2)
{
  int result; // eax
  int i; // [esp+14h] [ebp-4h]

  result = *(_DWORD *)(*(_DWORD *)a1 + 4);
  for ( i = result; i; i = result )
  {
    sub_8074842(*(size_t **)i, a2);
    result = *(_DWORD *)(i + 4);
  }
  return result;
}

//----- (08074B34) --------------------------------------------------------
void __cdecl sub_8074B34(int a1, _DWORD *a2, size_t *a3)
{
  sub_806E69A(a2, a3);
  sub_8074AF6(a1, *a3);
  sub_806E94E((int)a3, 1, a2);
}
// 8074AF6: using guessed type _DWORD __cdecl sub_8074AF6(_DWORD, _DWORD);

//----- (08074B7C) --------------------------------------------------------
char *__cdecl sub_8074B7C(int a1, int a2, int a3, int *a4)
{
  char *result; // eax
  int v5; // [esp+10h] [ebp-8h]
  int v6; // [esp+14h] [ebp-4h]

  if ( dword_8202A68 )
    return CompileError(a2, "cannot recurse /#");
  v6 = dword_839403C;
  sub_806EA5A(a3, (_DWORD *)*a4);
  if ( byte_839400B )
  {
    dword_8202A68 = 1;
    sub_8074A7A(a1, 0, 0, *a4);
    sub_806E53A((_DWORD *)*a4, *a4);
  }
  else
  {
    v5 = TempMalloc(0);
    dword_8202A68 = 2;
    sub_8074A7A(a1, 0, 0, *a4);
    TempMemorySetPos(v5);
  }
  dword_8202A68 = 0;
  result = (char *)v6;
  dword_839403C = v6;
  return result;
}
// 8074A7A: using guessed type _DWORD __cdecl sub_8074A7A(_DWORD, _DWORD, _DWORD, _DWORD);
// 8202A68: using guessed type int dword_8202A68;
// 839400B: using guessed type char byte_839400B;
// 839403C: using guessed type int dword_839403C;

//----- (08074C6A) --------------------------------------------------------
void __cdecl sub_8074C6A(int ***a1, int a2, int a3)
{
  sub_8073398(*a1, a3);
  sub_806DAD8(53, 0, 0);
  sub_8076D92(a2, 0);
}

//----- (08074CB6) --------------------------------------------------------
_DWORD ***__cdecl sub_8074CB6(_DWORD ****a1, _DWORD *a2)
{
  return sub_80733DA(*a1, a2);
}

//----- (08074CD2) --------------------------------------------------------
char *__cdecl sub_8074CD2(char **a1)
{
  char *result; // eax
  int v2; // eax
  int v3; // [esp+1Ch] [ebp-Ch]
  int v4; // [esp+24h] [ebp-4h]

  result = *a1;
  v3 = (int)*a1;
  if ( *a1 == (char *)69 )
  {
    if ( byte_820287D )
    {
      return CompileError((int)a1[1], "cannot recurse /#");
    }
    else
    {
      byte_820287D = 1;
      result = a1[1];
      dword_8202880 = (int)result;
    }
  }
  else if ( v3 > 69 )
  {
    if ( v3 == 70 )
    {
      if ( byte_820287D )
        byte_820287D = 0;
      else
        return CompileError((int)a1[1], "#/ has no matching /#");
    }
  }
  else if ( v3 == 68 && (!byte_820287D || byte_839400B) )
  {
    v2 = sub_807C0A8(dword_8202868, (unsigned int)a1[1]);
    v4 = sub_807CA86(v2);
    if ( byte_820287D )
      return (char *)sub_8070B86(v4, (int)a1[1], (int)a1[4], 12);
    else
      return (char *)sub_8070B86(v4, (int)a1[1], (int)a1[4], 7);
  }
  return result;
}
// 8202868: using guessed type int dword_8202868;
// 820287D: using guessed type char byte_820287D;
// 839400B: using guessed type char byte_839400B;

//----- (08074DEE) --------------------------------------------------------
int __cdecl sub_8074DEE(int a1, int a2, int a3, int a4, _DWORD *a5)
{
  int result; // eax

  dword_820286C = a1;
  sub_8077016(a3);
  dword_8202870 = 0;
  dword_8202874 = 0;
  dword_8202878 = 0;
  sub_806DA94(*(_DWORD *)(a2 + 4), 2u);
  sub_8074C6A(*(int ****)(a2 + 8), a3, (int)a5);
  sub_8074A7A(*(_DWORD *)(a2 + 12), 1, a4, a5);
  sub_806DEC6();
  sub_8076D92(a4, 1);
  sub_8076D92(-2, 0);
  result = dword_8202874 + 32 * dword_8202878;
  if ( result > 2047 )
    return (int)CompileError(a3, "function exceeds operand stack size");
  return result;
}
// 820286C: using guessed type int dword_820286C;
// 8202870: using guessed type int dword_8202870;
// 8202874: using guessed type int dword_8202874;
// 8202878: using guessed type int dword_8202878;
// 8074DEE: using guessed type int arg_C;

//----- (08074ED8) --------------------------------------------------------
int __cdecl sub_8074ED8(_DWORD ****a1, int a2, int **a3)
{
  byte_82028B0 = 0;
  *a3 = (int *)Hunk_AllocateTempMemoryHighInternal(280);
  **a3 = 0;
  (*a3)[1] = 0;
  (*a3)[3] = 0;
  (*a3)[2] = 0;
  memset(*a3 + 4, 0, 8u);
  sub_8074CB6(a1, *a3);
  return sub_8074AF6(a2, *a3);
}
// 82028B0: using guessed type char byte_82028B0;

//----- (08074F74) --------------------------------------------------------
void __cdecl sub_8074F74(int a1)
{
  byte_8202886 = 0;
  dword_8202888 = 0;
  byte_820288C = 0;
  byte_820288D = 0;
  dword_8202890 = 0;
  byte_8202894 = 0;
  byte_8202895 = 0;
  dword_8202898 = 0;
  dword_820289C = 0;
  dword_82028A8 = 0;
  if ( *(_BYTE *)(a1 + 136325252) )
  {
    *(_BYTE *)(a1 + 136325252) = 0;
    sub_806DEC6();
    sub_8076D92(0, 0);
    sub_8076D92(-2, 0);
  }
}
// 8202886: using guessed type char byte_8202886;
// 8202888: using guessed type int dword_8202888;
// 820288C: using guessed type char byte_820288C;
// 820288D: using guessed type char byte_820288D;
// 8202890: using guessed type int dword_8202890;
// 8202894: using guessed type char byte_8202894;
// 8202895: using guessed type char byte_8202895;
// 8202898: using guessed type int dword_8202898;
// 820289C: using guessed type int dword_820289C;
// 82028A8: using guessed type int dword_82028A8;

//----- (0807501A) --------------------------------------------------------
int __cdecl sub_807501A(int *a1, _DWORD **a2)
{
  int v2; // eax
  int v4; // [esp+14h] [ebp-4h]

  sub_8074F74(0);
  v2 = FindVariable(dword_8202868, a1[1]);
  v4 = sub_807CB1E(v2);
  sub_8070C7A(v4);
  return sub_8074DEE(v4, (int)a1, a1[4], a1[5], *a2);
}
// 8202868: using guessed type int dword_8202868;

//----- (0807509C) --------------------------------------------------------
int __cdecl sub_807509C(int *a1, _DWORD **a2)
{
  int result; // eax
  int v3; // eax
  int v4; // [esp+1Ch] [ebp-Ch]
  int v5; // [esp+20h] [ebp-8h]
  int v6; // [esp+24h] [ebp-4h]

  if ( byte_839400B )
  {
    dword_8202A68 = 1;
    sub_8074F74(1);
    v3 = FindVariable(dword_8202868, a1[1]);
    v5 = sub_807CB1E(v3);
    sub_8070C7A(v5);
    result = sub_8074DEE(v5, (int)a1, a1[4], a1[5], *a2);
  }
  else
  {
    v4 = TempMalloc(0);
    v6 = dword_839403C;
    dword_8202A68 = 2;
    sub_8074F74(1);
    sub_8074DEE(0, (int)a1, a1[4], a1[5], *a2);
    TempMemorySetPos(v4);
    result = v6;
    dword_839403C = v6;
  }
  dword_8202A68 = 0;
  return result;
}
// 8202868: using guessed type int dword_8202868;
// 8202A68: using guessed type int dword_8202A68;
// 839400B: using guessed type char byte_839400B;
// 839403C: using guessed type int dword_839403C;

//----- (080751B4) --------------------------------------------------------
char *__cdecl sub_80751B4(int a1)
{
  char *result; // eax
  char *v2; // eax
  int v3; // [esp+14h] [ebp-4h]

  result = *(char **)a1;
  v3 = *(_DWORD *)a1;
  if ( *(_DWORD *)a1 == 69 )
  {
    byte_820287D = 1;
  }
  else if ( v3 > 69 )
  {
    if ( v3 == 70 )
    {
      byte_820287D = 0;
    }
    else if ( v3 == 71 )
    {
      if ( byte_820287D )
      {
        return CompileError(*(_DWORD *)(a1 + 8), "cannot put #using_animtree inside /# ... #/ comment");
      }
      else
      {
        v2 = (char *)SL_ConvertToString(*(_DWORD *)(a1 + 4));
        sub_806D55A(v2, *(_DWORD *)(a1 + 12));
        return (char *)sub_806D9EC(*(_DWORD *)(a1 + 4));
      }
    }
  }
  else if ( v3 == 68 )
  {
    sub_8074ED8(*(_DWORD *****)(a1 + 8), *(_DWORD *)(a1 + 12), (int **)(a1 + 24));
    if ( byte_820287D )
      return (char *)sub_807509C((int *)a1, (_DWORD **)(a1 + 24));
    else
      return (char *)sub_807501A((int *)a1, (_DWORD **)(a1 + 24));
  }
  return result;
}
// 820287D: using guessed type char byte_820287D;

//----- (080752BA) --------------------------------------------------------
int *__cdecl sub_80752BA(int a1)
{
  int *result; // eax
  int i; // [esp+14h] [ebp-4h]
  int *j; // [esp+14h] [ebp-4h]

  byte_820287D = 0;
  for ( i = *(_DWORD *)(*(_DWORD *)a1 + 4); i; i = *(_DWORD *)(i + 4) )
    sub_8074CD2(*(char ***)i);
  if ( byte_820287D )
    CompileError(dword_8202880, "/# has no matching #/");
  byte_8202884 = 1;
  byte_8202885 = 1;
  result = *(int **)(*(_DWORD *)a1 + 4);
  for ( j = result; j; j = result )
  {
    sub_80751B4(*j);
    result = (int *)j[1];
  }
  return result;
}
// 820287D: using guessed type char byte_820287D;
// 8202884: using guessed type char byte_8202884;
// 8202885: using guessed type char byte_8202885;

//----- (08075354) --------------------------------------------------------
int __cdecl sub_8075354(int a1)
{
  char *v1; // eax
  int v3; // [esp+14h] [ebp-4h]

  v1 = (char *)SL_ConvertToString(*(_DWORD *)(a1 + 4));
  v3 = sub_8079C2A(v1);
  sub_806D9EC(*(_DWORD *)(a1 + 4));
  return sub_806FA70(v3, *(_DWORD *)(a1 + 8), 1);
}

//----- (080753A6) --------------------------------------------------------
int *__cdecl sub_80753A6(int a1)
{
  int *result; // eax
  int *i; // [esp+4h] [ebp-4h]

  result = *(int **)(*(_DWORD *)a1 + 4);
  for ( i = result; i; i = result )
  {
    sub_8075354(*i);
    result = (int *)i[1];
  }
  return result;
}

//----- (080753DE) --------------------------------------------------------
char *__cdecl sub_80753DE(int *a1, int a2, int a3)
{
  int v3; // eax
  const char *v4; // eax
  int v6; // eax
  __int16 *v7; // ebx
  void *v8; // [esp+1Ch] [ebp-5Ch]
  int v9; // [esp+20h] [ebp-58h] BYREF
  int v10; // [esp+24h] [ebp-54h]
  int v11; // [esp+28h] [ebp-50h]
  int v12; // [esp+2Ch] [ebp-4Ch]
  int v13[2]; // [esp+30h] [ebp-48h] BYREF
  int v14; // [esp+38h] [ebp-40h]
  unsigned __int16 v15; // [esp+3Eh] [ebp-3Ah]
  int v16[2]; // [esp+40h] [ebp-38h] BYREF
  int v17; // [esp+48h] [ebp-30h]
  int k; // [esp+4Ch] [ebp-2Ch]
  int v19; // [esp+50h] [ebp-28h]
  unsigned __int16 *v20; // [esp+54h] [ebp-24h]
  int v21; // [esp+58h] [ebp-20h]
  unsigned __int16 v22; // [esp+5Eh] [ebp-1Ah]
  int v23; // [esp+60h] [ebp-18h]
  int j; // [esp+64h] [ebp-14h]
  int i; // [esp+68h] [ebp-10h]
  void *ptr; // [esp+6Ch] [ebp-Ch]

  dword_8202868 = a2;
  byte_820287C = 0;
  dword_8202854 = 0;
  dword_8202A68 = 0;
  if ( dword_8202A44 )
    v8 = Z_MallocInternal(12 * dword_8202A44);
  else
    v8 = 0;
  ptr = v8;
  dword_82028B4 = (int)v8;
  if ( v8 )
  {
    *((_DWORD *)ptr + 2) = dword_82028B8;
    dword_82028B8 = (int)ptr;
  }
  sub_80753A6(*a1);
  sub_80752BA(a1[1]);
  dword_8202A70 = TempMalloc(0) - dword_8394048;
  Hunk_ClearTempMemoryHighInternal();
  v23 = dword_8202A44;
  for ( i = 0; i < v23; ++i )
  {
    v21 = (int)ptr + 12 * i;
    v22 = *(_WORD *)v21;
    v3 = SL_ConvertToString(v22);
    v19 = sub_8075C54(v3);
    if ( !v19 )
    {
      v4 = (const char *)SL_ConvertToString(v22);
      return CompileError(*(_DWORD *)(v21 + 4), "Could not find script '%s'", v4);
    }
    SL_RemoveRefToString(v22);
    if ( *(_BYTE *)(v21 + 2) )
    {
      for ( j = i + 1; j < v23; ++j )
      {
        v20 = (unsigned __int16 *)((char *)ptr + 12 * j);
        if ( !*((_BYTE *)v20 + 2) )
          break;
        if ( *v20 == v22 )
          return CompileError(*((_DWORD *)v20 + 1), "Duplicate #include");
      }
      *(_BYTE *)(v21 + 2) = 0;
      for ( k = sub_807C9CE(v19); k; k = sub_807C9CE(k) )
      {
        if ( GetVarType(k) == 1 )
        {
          v17 = sub_807CB1E(k);
          v14 = FindVariable(v17, 1);
          if ( v14 )
          {
            sub_807C66A(&v9, v14);
            v13[0] = v9;
            v13[1] = v10;
            if ( v10 != 13 )
            {
              v15 = GetVariableName(k);
              v6 = sub_807C0A8(a2, v15);
              v12 = sub_807CA86(v6);
              v11 = sub_8070B86(v12, v15, *(_DWORD *)(v21 + 4), 13);
              v7 = sub_807C4FC(v11);
              *(_DWORD *)v7 = *(_DWORD *)sub_807C4FC(v14);
              sub_807098C(v12, v13, 0);
            }
          }
        }
      }
    }
  }
  if ( ptr )
  {
    dword_82028B8 = *((_DWORD *)ptr + 2);
    Z_FreeInternal(ptr);
  }
  sub_8070AA8(a2);
  v16[1] = 6;
  return (char *)sub_807C45C(a3, v16);
}
// 8075C54: using guessed type _DWORD __cdecl sub_8075C54(_DWORD);
// 8202854: using guessed type int dword_8202854;
// 8202868: using guessed type int dword_8202868;
// 820287C: using guessed type char byte_820287C;
// 82028B4: using guessed type int dword_82028B4;
// 82028B8: using guessed type int dword_82028B8;
// 8202A44: using guessed type int dword_8202A44;
// 8202A68: using guessed type int dword_8202A68;
// 8202A70: using guessed type int dword_8202A70;
// 8394048: using guessed type int dword_8394048;

//----- (08075710) --------------------------------------------------------
int __cdecl sub_8075710(int a1)
{
  sub_80742D2(a1, 0, 0, 0);
  return sub_806DAD8(128, 0, 0);
}

//----- (08075758) --------------------------------------------------------
void sub_8075758()
{
  void *ptr; // [esp+4h] [ebp-4h]

  while ( dword_82028B8 )
  {
    ptr = (void *)dword_82028B8;
    dword_82028B8 = *(_DWORD *)(dword_82028B8 + 8);
    Z_FreeInternal(ptr);
  }
}
// 82028B8: using guessed type int dword_82028B8;

//----- (0807578C) --------------------------------------------------------
int __cdecl sub_807578C(int *a1)
{
  return sub_807BA14(a1[1], *a1);
}

//----- (080757AC) --------------------------------------------------------
int __cdecl RemoveRefToValue(_DWORD *a1)
{
  return RemoveRefToValueInternal(a1[1], *a1);
}
// 807BA64: using guessed type _DWORD __cdecl RemoveRefToValueInternal(_DWORD, _DWORD);

//----- (080757CC) --------------------------------------------------------
_BOOL4 __cdecl Scr_IsInOpcodeMemory(int a1)
{
  return a1 - dword_8394048 < (unsigned int)dword_8202A70;
}
// 8202A70: using guessed type int dword_8202A70;
// 8394048: using guessed type int dword_8394048;

//----- (08075828) --------------------------------------------------------
int __cdecl sub_8075828(_BYTE *a1)
{
  while ( *a1 )
  {
    if ( (*(_WORD *)(_ctype_b + 2 * (char)*a1) & 8) == 0 && *a1 != 95 )
      return 0;
    ++a1;
  }
  return 1;
}
// 8185A64: using guessed type int _ctype_b;

//----- (08075874) --------------------------------------------------------
int __cdecl sub_8075874(char *a1, char *s)
{
  int v4[2]; // [esp+10h] [ebp-38h] BYREF
  int v5; // [esp+18h] [ebp-30h]
  int v6; // [esp+1Ch] [ebp-2Ch]
  int v7; // [esp+20h] [ebp-28h]
  int v8; // [esp+24h] [ebp-24h]
  int v9; // [esp+2Ch] [ebp-1Ch]
  int v10; // [esp+30h] [ebp-18h]
  int v11; // [esp+34h] [ebp-14h]
  int v12; // [esp+38h] [ebp-10h]
  int v13; // [esp+3Ch] [ebp-Ch]
  int v14; // [esp+40h] [ebp-8h]
  int v15; // [esp+44h] [ebp-4h]

  v10 = sub_8079C2A(a1);
  v15 = FindVariable(dword_8202A4C, v10);
  SL_RemoveRefToString(v10);
  if ( !v15 )
    return 0;
  v13 = sub_807CB1E(v15);
  v12 = sub_8078CEA(s);
  if ( !v12 )
    return 0;
  v14 = FindVariable(v13, v12);
  if ( !v14 )
    return 0;
  if ( GetVarType(v14) != 1 )
    return 0;
  v6 = sub_807CB1E(v14);
  v5 = FindVariable(v6, 1);
  sub_807C66A(v4, v5);
  v7 = v4[0];
  v8 = v4[1];
  v9 = v4[0];
  if ( !Scr_IsInOpcodeMemory(v4[0]) )
    return 0;
  v11 = v9 - dword_8394048;
  return v9 - dword_8394048;
}
// 8202A4C: using guessed type int dword_8202A4C;
// 8394048: using guessed type int dword_8394048;

//----- (080759A6) --------------------------------------------------------
void *sub_80759A6()
{
  void *result; // eax

  dword_8394004 = Hunk_SetMark();
  result = Hunk_AllocInternal(0x20000u);
  dword_8202A58 = (int)result;
  word_8394008 = 0;
  return result;
}
// 8202A58: using guessed type int dword_8202A58;
// 8394004: using guessed type int dword_8394004;
// 8394008: using guessed type __int16 word_8394008;

//----- (080759D2) --------------------------------------------------------
unsigned int *sub_80759D2()
{
  dword_8202A58 = 0;
  return Hunk_ClearHigh(dword_8394004);
}
// 8202A58: using guessed type int dword_8202A58;
// 8394004: using guessed type int dword_8394004;

//----- (080759F2) --------------------------------------------------------
int __cdecl sub_80759F2(int a1)
{
  sub_80794D8(a1, 2u);
  if ( *(_WORD *)(dword_8202A58 + 2 * a1) )
    return *(unsigned __int16 *)(dword_8202A58 + 2 * a1);
  *(_WORD *)(dword_8202A58 + 2 * a1) = ++word_8394008;
  return (unsigned __int16)word_8394008;
}
// 8202A58: using guessed type int dword_8202A58;
// 8394008: using guessed type __int16 word_8394008;

//----- (08075A60) --------------------------------------------------------
int __cdecl sub_8075A60(char *s2)
{
  int v1; // edx
  int v2; // eax

  v1 = 2 * sub_8078CC6(s2);
  if ( *(_WORD *)(dword_8202A58 + v1) )
    return *(unsigned __int16 *)(dword_8202A58 + v1);
  v2 = SL_GetString(s2, 0);
  return sub_80759F2(v2);
}
// 8202A58: using guessed type int dword_8202A58;

//----- (08075ABA) --------------------------------------------------------
void sub_8075ABA()
{
  byte_8202A64 = 1;
  sub_8076B9C();
  dword_8202A48 = sub_807B658();
  dword_8202A4C = sub_807B658();
  dword_8202A50 = sub_807B658();
  dword_8202A54 = sub_807B658();
  dword_8394048 = (int)Hunk_AllocLowInternal(0);
  dword_8202A70 = 0;
  dword_839404C = 0;
  sub_80759A6();
  dword_8394000 = 0;
  dword_8202A40 = 0;
  sub_807F810();
  dword_8202A74 = 0;
  sub_8075B72(1);
  TempMemoryReset();
}
// 8202A40: using guessed type int dword_8202A40;
// 8202A48: using guessed type int dword_8202A48;
// 8202A4C: using guessed type int dword_8202A4C;
// 8202A50: using guessed type int dword_8202A50;
// 8202A54: using guessed type int dword_8202A54;
// 8202A64: using guessed type char byte_8202A64;
// 8202A70: using guessed type int dword_8202A70;
// 8202A74: using guessed type int dword_8202A74;
// 8394000: using guessed type int dword_8394000;
// 8394048: using guessed type int dword_8394048;
// 839404C: using guessed type int dword_839404C;

//----- (08075B54) --------------------------------------------------------
int sub_8075B54()
{
  int result; // eax

  byte_8202A64 = 1;
  sub_8076B9C();
  result = sub_807B658();
  dword_8202A48 = result;
  return result;
}
// 8202A48: using guessed type int dword_8202A48;
// 8202A64: using guessed type char byte_8202A64;

//----- (08075B72) --------------------------------------------------------
int __cdecl sub_8075B72(int a1)
{
  int result; // eax

  byte_8202858 = 1;
  dword_820284C[a1] = 0;
  dword_820244C[128 * a1] = 0;
  result = sub_807B658();
  dword_8202440 = result;
  dword_8202444 = 0;
  dword_8202A68 = 0;
  return result;
}
// 8202440: using guessed type int dword_8202440;
// 820244C: using guessed type int dword_820244C[128];
// 820284C: using guessed type int dword_820284C[];
// 8202858: using guessed type char byte_8202858;
// 8202A68: using guessed type int dword_8202A68;

//----- (08075BBE) --------------------------------------------------------
int __cdecl sub_8075BBE(int a1, int a2)
{
  char v2; // al
  int i; // [esp+0h] [ebp-8h]
  char v5; // [esp+7h] [ebp-1h]

  v5 = 42;
  for ( i = 0; i < a2; ++i )
  {
    v2 = *(_BYTE *)dword_8202A5C++;
    v5 = v2;
    if ( !v2 || v2 == 10 )
      break;
    *(_BYTE *)(i + a1) = v2;
  }
  if ( v5 == 10 )
  {
    *(_BYTE *)(a1 + i++) = 10;
  }
  else if ( !v5 )
  {
    if ( dword_8202A60 )
    {
      dword_8202A5C = dword_8202A60;
      dword_8202A60 = 0;
    }
    else
    {
      --dword_8202A5C;
    }
  }
  return i;
}
// 8202A5C: using guessed type int dword_8202A5C;
// 8202A60: using guessed type int dword_8202A60;

//----- (08075C54) --------------------------------------------------------
int __cdecl sub_8075C54(char *a1)
{
  const char *v1; // eax
  int v2; // ebx
  int v3; // eax
  int v4; // eax
  int v8; // [esp+1Ch] [ebp-6Ch]
  int v9; // [esp+20h] [ebp-68h]
  int v10; // [esp+24h] [ebp-64h]
  int v11; // [esp+28h] [ebp-60h]
  int v12; // [esp+2Ch] [ebp-5Ch]
  char s[68]; // [esp+30h] [ebp-58h] BYREF
  int v14; // [esp+74h] [ebp-14h]
  int *v15; // [esp+78h] [ebp-10h] BYREF
  char *v16; // [esp+7Ch] [ebp-Ch]

  v14 = sub_8079C2A(a1);
  if ( FindVariable(dword_8202A48, v14) )
  {
    SL_RemoveRefToString(v14);
    v8 = FindVariable(dword_8202A4C, v14);
    if ( v8 )
      return sub_807CB1E(v8);
    else
      return 0;
  }
  else
  {
    v10 = sub_807C0CC(dword_8202A48, v14);
    SL_RemoveRefToString(v14);
    v1 = (const char *)SL_ConvertToString(v14);
    Com_sprintf(s, 0x40u, "%s.gsc", v1);
    v11 = *(_DWORD *)dword_8283EE0;
    v2 = TempMalloc(0);
    v3 = SL_ConvertToString(v14);
    v16 = sub_807799E(v3, s, v2, 1u);
    if ( v16 )
    {
      dword_8202448 = 0;
      dword_8202A44 = 0;
      v12 = *(_DWORD *)dword_8283EDC;
      *(_DWORD *)dword_8283EDC = s;
      dword_8202A5C = (int)"+";
      dword_8202A60 = (int)v16;
      ScriptParse(&v15, 0);
      v4 = sub_807C0A8(dword_8202A4C, v14);
      v9 = sub_807CA86(v4);
      sub_80753DE(v15, v9, v10);
      *(_DWORD *)dword_8283EDC = v12;
      *(_DWORD *)dword_8283EE0 = v11;
      return v9;
    }
    else
    {
      return 0;
    }
  }
}
// 8202448: using guessed type int dword_8202448;
// 8202A44: using guessed type int dword_8202A44;
// 8202A48: using guessed type int dword_8202A48;
// 8202A4C: using guessed type int dword_8202A4C;
// 8202A5C: using guessed type int dword_8202A5C;
// 8202A60: using guessed type int dword_8202A60;

//----- (08075E10) --------------------------------------------------------
int sub_8075E10()
{
  return Hunk_ConvertTempToPermLowInternal();
}

//----- (08075E1E) --------------------------------------------------------
int sub_8075E1E()
{
  int result; // eax

  sub_80759D2();
  sub_8079910(2u);
  byte_8202A64 = 0;
  sub_807AF82(dword_8202A48);
  RemoveRefToObject(dword_8202A48);
  dword_8202A48 = 0;
  sub_807AF82(dword_8202A4C);
  RemoveRefToObject(dword_8202A4C);
  dword_8202A4C = 0;
  sub_807AF82(dword_8202A50);
  RemoveRefToObject(dword_8202A50);
  dword_8202A50 = 0;
  sub_807AF82(dword_8202A54);
  result = RemoveRefToObject(dword_8202A54);
  dword_8202A54 = 0;
  return result;
}
// 8202A48: using guessed type int dword_8202A48;
// 8202A4C: using guessed type int dword_8202A4C;
// 8202A50: using guessed type int dword_8202A50;
// 8202A54: using guessed type int dword_8202A54;
// 8202A64: using guessed type char byte_8202A64;

//----- (08075ECE) --------------------------------------------------------
int __cdecl sub_8075ECE(int (__cdecl *a1)(int), int a2)
{
  int result; // eax
  int i; // [esp+14h] [ebp-4h]

  for ( i = 1; ; ++i )
  {
    result = i;
    if ( i > dword_820284C[a2] )
      break;
    sub_806D668(i, a1, a2);
  }
  return result;
}
// 820284C: using guessed type int dword_820284C[];

//----- (08075F0E) --------------------------------------------------------
void *sub_8075F0E()
{
  void *result; // eax

  sub_807AF82(dword_8202440);
  RemoveRefToObject(dword_8202440);
  dword_8202440 = 0;
  if ( dword_8202444 )
    RemoveRefToObject(dword_8202444);
  sub_8079910(2u);
  result = Hunk_AllocLowInternal(0);
  dword_839404C = (int)result;
  byte_8202858 = 0;
  return result;
}
// 8202440: using guessed type int dword_8202440;
// 8202858: using guessed type char byte_8202858;
// 839404C: using guessed type int dword_839404C;

//----- (08075F74) --------------------------------------------------------
void sub_8075F74()
{
  if ( byte_8202A64 )
  {
    byte_8202A64 = 0;
    sub_8075E1E();
  }
  if ( byte_8202858 )
  {
    byte_8202858 = 0;
    sub_8075F0E();
  }
  sub_8079910(1u);
  sub_8076C84();
  dword_8394048 = 0;
  dword_8202A70 = 0;
  dword_839404C = 0;
  dword_839403C = 0;
}
// 8202858: using guessed type char byte_8202858;
// 8202A64: using guessed type char byte_8202A64;
// 8202A70: using guessed type int dword_8202A70;
// 839403C: using guessed type int dword_839403C;
// 8394048: using guessed type int dword_8394048;
// 839404C: using guessed type int dword_839404C;

//----- (08075FE8) --------------------------------------------------------
int __cdecl sub_8075FE8(int a1)
{
  int v1; // ebx

  if ( !a1 )
    return 0;
  v1 = sub_8075FE8(LOWORD(dword_8203B00[2 * a1]));
  return sub_8075FE8(HIWORD(dword_8203B00[2 * a1])) + v1 + 1;
}
// 8203B00: using guessed type int dword_8203B00[];

//----- (08076040) --------------------------------------------------------
void sub_8076040()
{
  int v0; // [esp+18h] [ebp-10h]
  int v1; // [esp+20h] [ebp-8h]
  int i; // [esp+24h] [ebp-4h]

  Com_Printf("********************************\n");
  v0 = *(_DWORD *)dword_8283E28;
  for ( i = 0; i <= 16; ++i )
  {
    v1 = sub_8075FE8((unsigned __int16)word_8283E00[i]);
    v0 += v1 << i;
    Com_Printf("%d subtree has %d * %d = %d free buckets\n", i, v1, 1 << i, v1 << i);
  }
  Com_Printf("********************************\n");
  Com_Printf("********************************\n");
  Com_Printf("total memory alloc buckets: %d (%d instances)\n", *(_DWORD *)dword_8283E28, dword_8283E24);
  Com_Printf("total memory free buckets: %d\n", 0xFFFF - *(_DWORD *)dword_8283E28);
  Com_Printf("********************************\n");
}
// 8283E00: using guessed type __int16 word_8283E00[18];
// 8283E24: using guessed type int dword_8283E24;

//----- (08076134) --------------------------------------------------------
int *sub_8076134()
{
  int *result; // eax
  int j; // [esp+0h] [ebp-Ch]
  int m; // [esp+0h] [ebp-Ch]
  char v3; // [esp+4h] [ebp-8h]
  char k; // [esp+4h] [ebp-8h]
  char v5; // [esp+4h] [ebp-8h]
  int i; // [esp+8h] [ebp-4h] BYREF

  for ( i = 0; i <= 255; ++i )
  {
    v3 = 0;
    for ( j = i; j; j >>= 1 )
    {
      if ( (j & 1) != 0 )
        ++v3;
    }
    *(_BYTE *)(i + 136854528) = v3;
    for ( k = 8; (i & ((1 << k) - 1)) != 0; --k )
      ;
    *(_BYTE *)(i + 136854272) = k;
    v5 = 0;
    for ( m = i; m; m >>= 1 )
      ++v5;
    *(_BYTE *)(i + 136854784) = v5;
    result = &i;
  }
  return result;
}

//----- (080761F6) --------------------------------------------------------
int __cdecl sub_80761F6(int a1)
{
  char v2; // [esp+8h] [ebp-8h]
  int v3; // [esp+18h] [ebp+8h]

  v3 = 0x10000 - a1;
  v2 = byte_8283B00[(unsigned __int8)v3];
  if ( !(_BYTE)v3 )
    v2 += byte_8283B00[BYTE1(v3)];
  return v3
       - ((unsigned __int8)byte_8283B00[BYTE1(v3) + 256]
        + (unsigned __int8)byte_8283B00[(unsigned __int8)v3 + 256])
       + (1 << v2);
}
// 8283B00: using guessed type _BYTE[512];

//----- (0807626A) --------------------------------------------------------
int __cdecl sub_807626A(int a1, int a2)
{
  int v2; // edx
  int result; // eax
  int v4; // [esp+14h] [ebp-14h]
  int v5; // [esp+18h] [ebp-10h]
  int v6; // [esp+1Ch] [ebp-Ch]
  int *v7; // [esp+20h] [ebp-8h]
  int v8; // [esp+24h] [ebp-4h]

  v7 = (int *)(2 * a2 + 136855040);
  v8 = (unsigned __int16)word_8283E00[a2];
  if ( word_8283E00[a2] )
  {
    v6 = sub_80761F6(a1);
    v5 = 0;
    v4 = 0x10000;
    while ( sub_80761F6(v8) >= v6 )
    {
      v4 >>= 1;
      if ( a1 >= v5 )
      {
        v7 = (int *)(8 * v8 + 136329986);
        v5 += v4;
      }
      else
      {
        v7 = &dword_8203B00[2 * v8];
        v5 -= v4;
      }
      v8 = *(unsigned __int16 *)v7;
      if ( !*(_WORD *)v7 )
        goto LABEL_13;
    }
    while ( 1 )
    {
      *(_WORD *)v7 = a1;
      v2 = dword_8203B04[2 * v8];
      result = dword_8203B00[2 * v8];
      dword_8203B00[2 * a1] = result;
      dword_8203B04[2 * a1] = v2;
      if ( !v8 )
        break;
      v4 >>= 1;
      if ( v8 >= v5 )
      {
        v7 = (int *)(8 * a1 + 136329986);
        v5 += v4;
      }
      else
      {
        v7 = &dword_8203B00[2 * a1];
        v5 -= v4;
      }
      a1 = v8;
      v8 = *(unsigned __int16 *)v7;
    }
  }
  else
  {
LABEL_13:
    *(_WORD *)v7 = a1;
    LOWORD(dword_8203B00[2 * a1]) = 0;
    result = a1;
    HIWORD(dword_8203B00[2 * a1]) = 0;
  }
  return result;
}
// 8203B00: using guessed type int dword_8203B00[];
// 8203B04: using guessed type int dword_8203B04[131071];
// 8283E00: using guessed type __int16 word_8283E00[18];

//----- (080763CA) --------------------------------------------------------
int __cdecl sub_80763CA(int a1, int a2)
{
  int v4; // [esp+10h] [ebp-28h]
  int v5; // [esp+14h] [ebp-24h]
  int v6; // [esp+18h] [ebp-20h]
  int v7; // [esp+1Ch] [ebp-1Ch]
  int v8; // [esp+20h] [ebp-18h]
  int v9; // [esp+24h] [ebp-14h]
  int v10; // [esp+2Ch] [ebp-Ch]
  int *v11; // [esp+30h] [ebp-8h]
  int i; // [esp+34h] [ebp-4h]
  int v13; // [esp+40h] [ebp+8h]

  v9 = 0;
  v8 = 0x10000;
  v11 = (int *)(2 * a2 + 136855040);
  for ( i = (unsigned __int16)word_8283E00[a2]; ; i = *(unsigned __int16 *)v11 )
  {
    if ( !i )
      return 0;
    if ( a1 == i )
      break;
    if ( a1 == v9 )
      return 0;
    v8 >>= 1;
    if ( a1 >= v9 )
    {
      v11 = (int *)(8 * i + 136329986);
      v9 += v8;
    }
    else
    {
      v11 = &dword_8203B00[2 * i];
      v9 -= v8;
    }
  }
  v6 = dword_8203B00[2 * a1];
  v7 = dword_8203B04[2 * a1];
  while ( (_WORD)v6 )
  {
    if ( HIWORD(v6) )
    {
      v10 = sub_80761F6((unsigned __int16)v6);
      if ( v10 >= sub_80761F6(HIWORD(v6)) )
      {
        v13 = (unsigned __int16)v6;
        *(_WORD *)v11 = v6;
        v11 = &dword_8203B00[2 * (unsigned __int16)v6];
      }
      else
      {
        v13 = HIWORD(v6);
        *(_WORD *)v11 = HIWORD(v6);
        v11 = (int *)(8 * HIWORD(v6) + 136329986);
      }
    }
    else
    {
      v13 = (unsigned __int16)v6;
      *(_WORD *)v11 = v6;
      v11 = &dword_8203B00[2 * (unsigned __int16)v6];
    }
LABEL_14:
    v4 = v6;
    v5 = v7;
    v6 = dword_8203B00[2 * v13];
    v7 = dword_8203B04[2 * v13];
    dword_8203B00[2 * v13] = v4;
    dword_8203B04[2 * v13] = v5;
  }
  v13 = HIWORD(v6);
  *(_WORD *)v11 = HIWORD(v6);
  if ( HIWORD(v6) )
  {
    v11 = (int *)(8 * HIWORD(v6) + 136329986);
    goto LABEL_14;
  }
  return 1;
}
// 8203B00: using guessed type int dword_8203B00[];
// 8203B04: using guessed type int dword_8203B04[131071];
// 8283E00: using guessed type __int16 word_8283E00[18];

//----- (080765A0) --------------------------------------------------------
int __cdecl sub_80765A0(int a1)
{
  int result; // eax
  int v2; // [esp+8h] [ebp-20h]
  int v3; // [esp+Ch] [ebp-1Ch]
  int v4; // [esp+10h] [ebp-18h]
  int v5; // [esp+14h] [ebp-14h]
  int v6; // [esp+1Ch] [ebp-Ch]
  int *v7; // [esp+20h] [ebp-8h]
  int v8; // [esp+24h] [ebp-4h]
  int v9; // [esp+24h] [ebp-4h]

  v7 = (int *)(2 * a1 + 136855040);
  v8 = (unsigned __int16)word_8283E00[a1];
  v4 = dword_8203B00[2 * v8];
  v5 = dword_8203B04[2 * v8];
  while ( (_WORD)v4 )
  {
    if ( HIWORD(v4) )
    {
      v6 = sub_80761F6((unsigned __int16)v4);
      if ( v6 >= sub_80761F6(HIWORD(v4)) )
      {
        v9 = (unsigned __int16)v4;
        *(_WORD *)v7 = v4;
        v7 = &dword_8203B00[2 * (unsigned __int16)v4];
      }
      else
      {
        v9 = HIWORD(v4);
        *(_WORD *)v7 = HIWORD(v4);
        v7 = (int *)(8 * HIWORD(v4) + 136329986);
      }
    }
    else
    {
      v9 = (unsigned __int16)v4;
      *(_WORD *)v7 = v4;
      v7 = &dword_8203B00[2 * (unsigned __int16)v4];
    }
LABEL_10:
    v2 = v4;
    v3 = v5;
    v4 = dword_8203B00[2 * v9];
    v5 = dword_8203B04[2 * v9];
    dword_8203B00[2 * v9] = v2;
    dword_8203B04[2 * v9] = v3;
  }
  v9 = HIWORD(v4);
  result = HIWORD(v4);
  *(_WORD *)v7 = HIWORD(v4);
  if ( HIWORD(v4) )
  {
    v7 = (int *)(8 * HIWORD(v4) + 136329986);
    goto LABEL_10;
  }
  return result;
}
// 8203B00: using guessed type int dword_8203B00[];
// 8203B04: using guessed type int dword_8203B04[131071];
// 8283E00: using guessed type __int16 word_8283E00[18];

//----- (080766E6) --------------------------------------------------------
int *sub_80766E6()
{
  int *result; // eax
  int i; // [esp+14h] [ebp-4h] BYREF

  dword_8283E80 = (int)dword_8203B00;
  result = sub_8076134();
  for ( i = 0; i <= 16; ++i )
  {
    word_8283E00[i] = 0;
    result = &i;
  }
  dword_8203B00[0] = 0;
  for ( i = 0; i <= 15; ++i )
  {
    sub_807626A(1 << i, i);
    result = &i;
  }
  dword_8283E24 = 0;
  *(_DWORD *)dword_8283E28 = 0;
  return result;
}
// 8203B00: using guessed type int dword_8203B00[];
// 8283E00: using guessed type __int16 word_8283E00[18];
// 8283E24: using guessed type int dword_8283E24;
// 8283E80: using guessed type int dword_8283E80;

//----- (08076776) --------------------------------------------------------
void __cdecl sub_8076776(const char *a1, int a2)
{
  sub_8076040();
  Com_Printf("%s: failed memory allocation of %d bytes for script usage\n", a1, a2);
  sub_8084DF0((int)"failed memory allocation for script usage");
}
// 8076776: using guessed type const char *arg_0;

//----- (080767AA) --------------------------------------------------------
int __cdecl sub_80767AA(int a1)
{
  int v4; // [esp+14h] [ebp-4h]

  if ( a1 > 0xFFFF )
  {
    sub_8076776("MT_GetSize: max allocation exceeded", a1);
    return 0;
  }
  else
  {
    v4 = (a1 + 7) / 8 - 1;
    if ( v4 > 255 )
      return (unsigned __int8)byte_8283D00[v4 >> 8] + 8;
    else
      return (unsigned __int8)byte_8283D00[(a1 + 7) / 8 - 1];
  }
}

//----- (0807682A) --------------------------------------------------------
int __cdecl sub_807682A(int a1)
{
  int i; // [esp+Ch] [ebp-Ch]
  int v4; // [esp+10h] [ebp-8h]
  int v5; // [esp+14h] [ebp-4h]

  v4 = sub_80767AA(a1);
  for ( i = v4; ; ++i )
  {
    if ( i > 16 )
    {
      sub_8076776("MT_AllocIndex", a1);
      return 0;
    }
    v5 = (unsigned __int16)word_8283E00[i];
    if ( word_8283E00[i] )
      break;
  }
  sub_80765A0(i);
  while ( i != v4 )
  {
    --i;
    sub_807626A(v5 + (1 << i), i);
  }
  ++dword_8283E24;
  *(_DWORD *)dword_8283E28 += 1 << v4;
  return (unsigned __int16)v5;
}
// 8283E00: using guessed type __int16 word_8283E00[18];
// 8283E24: using guessed type int dword_8283E24;

//----- (080768E2) --------------------------------------------------------
int __cdecl sub_80768E2(int a1, int a2)
{
  int v3; // [esp+10h] [ebp-8h]
  int v4; // [esp+14h] [ebp-4h]

  v3 = sub_80767AA(a2);
  --dword_8283E24;
  *(_DWORD *)dword_8283E28 -= 1 << v3;
  while ( 1 )
  {
    v4 = 1 << v3;
    if ( v3 == 16 || !(unsigned __int8)sub_80763CA(a1 ^ v4, v3) )
      break;
    a1 &= ~v4;
    ++v3;
  }
  return sub_807626A(a1, v3);
}
// 8283E24: using guessed type int dword_8283E24;

//----- (08076960) --------------------------------------------------------
int __cdecl sub_8076960(int a1)
{
  int i; // [esp+Ch] [ebp-Ch]
  int v3; // [esp+10h] [ebp-8h]
  int v4; // [esp+14h] [ebp-4h]

  v3 = 0;
  for ( i = a1; !(unsigned __int8)sub_80763CA(i, v3); i &= ~(1 << v3++) )
  {
    if ( v3 == 16 )
    {
      v3 = 0;
      i = a1;
      while ( 1 )
      {
        v4 = 1 << v3;
        if ( v3 == 16 || !(unsigned __int8)sub_80763CA(i ^ v4, v3) )
          break;
        i &= ~v4;
        ++v3;
      }
      return sub_807626A(i, v3);
    }
  }
  return sub_807626A(i, v3);
}

//----- (08076A2A) --------------------------------------------------------
int __cdecl sub_8076A2A(int a1)
{
  return 8 * (unsigned __int16)sub_807682A(a1) + 136329984;
}

//----- (08076A50) --------------------------------------------------------
int __cdecl sub_8076A50(int a1, int a2)
{
  return sub_80768E2((a1 - (int)dword_8203B00) >> 3, a2);
}
// 8203B00: using guessed type int dword_8203B00[];

//----- (08076A72) --------------------------------------------------------
void *sub_8076A72()
{
  dword_8283E24 = 0;
  *(_DWORD *)dword_8283E28 = 0;
  return Z_VirtualAllocInternal(0x2000u);
}
// 8283E24: using guessed type int dword_8283E24;

//----- (08076A9A) --------------------------------------------------------
int *__cdecl sub_8076A9A(int a1, unsigned int a2, int a3)
{
  int *result; // eax
  int v4; // [esp+4h] [ebp-14h] BYREF
  int v5; // [esp+8h] [ebp-10h]

  v5 = sub_80767AA(a3);
  ++dword_8283E24;
  v4 = 1 << v5;
  result = (int *)(1 << v5);
  *(_DWORD *)dword_8283E28 += 1 << v5;
  while ( v4 )
  {
    *(_BYTE *)((a2 >> 3) + a1) |= 1 << (a2 & 7);
    ++a2;
    result = &v4;
    --v4;
  }
  return result;
}
// 8283E24: using guessed type int dword_8283E24;

//----- (08076B14) --------------------------------------------------------
void __cdecl sub_8076B14(unsigned __int8 *ptr)
{
  int i; // [esp+4h] [ebp-4h]

  for ( i = 1; i <= 0xFFFF; ++i )
  {
    if ( (((int)ptr[i >> 3] >> (i & 7)) & 1) == 0 )
      sub_8076960(i);
  }
  Z_VirtualFreeInternal(ptr);
}

//----- (08076B6C) --------------------------------------------------------
_BOOL4 __cdecl sub_8076B6C(int a1, int a2)
{
  int v3; // [esp+4h] [ebp-4h]

  v3 = sub_80767AA(a1);
  return v3 >= sub_80767AA(a2);
}

//----- (08076B9C) --------------------------------------------------------
void sub_8076B9C()
{
  if ( byte_839400A )
  {
    dword_8283ECC = -1;
    dword_8283EA4 = 0x10000;
    dword_8283EA8 = 0;
    dword_8283EA0 = Z_MallocInternal(0x140000u);
    memset(dword_8283EA0, 0, 20 * dword_8283EA4);
    dword_8283EB0 = 0x10000;
    dword_8283EB4 = 0;
    dword_8283EAC = Z_MallocInternal(0x80000u);
    dword_8283EBC = 0;
    dword_8283EC0 = 0;
    dword_8283EB8 = 16;
    dword_8283ED8 = 0;
    dword_8283ED4 = Z_MallocInternal(0x180u);
  }
}
// 8283EA4: using guessed type int dword_8283EA4;
// 8283EA8: using guessed type int dword_8283EA8;
// 8283EB0: using guessed type int dword_8283EB0;
// 8283EB4: using guessed type int dword_8283EB4;
// 8283EB8: using guessed type int dword_8283EB8;
// 8283EBC: using guessed type int dword_8283EBC;
// 8283EC0: using guessed type int dword_8283EC0;
// 8283ECC: using guessed type int dword_8283ECC;
// 8283ED8: using guessed type int dword_8283ED8;
// 839400A: using guessed type char byte_839400A;

//----- (08076C84) --------------------------------------------------------
void sub_8076C84()
{
  unsigned int i; // [esp+4h] [ebp-4h]
  int j; // [esp+4h] [ebp-4h]

  if ( dword_8283EA0 )
  {
    Z_FreeInternal(dword_8283EA0);
    dword_8283EA0 = 0;
  }
  if ( dword_8283EAC )
  {
    Z_FreeInternal(dword_8283EAC);
    dword_8283EAC = 0;
  }
  if ( dword_8283ED4 )
  {
    for ( i = 0; i < dword_8283ED8; ++i )
      Z_FreeInternal(*((void **)dword_8283ED4 + 6 * i + 1));
    Z_FreeInternal(dword_8283ED4);
    dword_8283ED4 = 0;
  }
  if ( dword_8283EC4 )
  {
    for ( j = 0; j < dword_8283EC8; ++j )
    {
      if ( *((_DWORD *)dword_8283EC4 + 2 * j) )
        Z_FreeInternal(*((void **)dword_8283EC4 + 2 * j));
    }
    Z_FreeInternal(dword_8283EC4);
    dword_8283EC4 = 0;
  }
}
// 8283EC8: using guessed type int dword_8283EC8;
// 8283ED8: using guessed type int dword_8283ED8;

//----- (08076D92) --------------------------------------------------------
void __cdecl sub_8076D92(int a1, int a2)
{
  int v2; // [esp+14h] [ebp-14h]
  _DWORD *v3; // [esp+18h] [ebp-10h]
  _DWORD *v4; // [esp+1Ch] [ebp-Ch]
  void *v5; // [esp+20h] [ebp-8h]
  void *dest; // [esp+24h] [ebp-4h]

  if ( byte_839400A && dword_8202A68 != 2 )
  {
    if ( !byte_8202A65 )
      a2 &= ~1u;
    if ( dword_8283EA8 >= (unsigned int)dword_8283EA4 )
    {
      dword_8283EA4 *= 2;
      dest = Z_MallocInternal(20 * dword_8283EA4);
      memcpy(dest, dword_8283EA0, 20 * dword_8283EA8);
      Z_FreeInternal(dword_8283EA0);
      dword_8283EA0 = dest;
    }
    if ( dword_8283EB4 >= (unsigned int)dword_8283EB0 )
    {
      dword_8283EB0 *= 2;
      v5 = Z_MallocInternal(8 * dword_8283EB0);
      memcpy(v5, dword_8283EAC, 8 * dword_8283EB4);
      Z_FreeInternal(dword_8283EAC);
      dword_8283EAC = v5;
    }
    if ( dword_8283EBC == dword_8202A6C )
    {
      --dword_8283EA8;
      v4 = (char *)dword_8283EA0 + 20 * dword_8283EA8;
    }
    else
    {
      dword_8283EC0 = 0;
      dword_8283EBC = dword_8202A6C;
      v4 = (char *)dword_8283EA0 + 20 * dword_8283EA8;
      v4[1] = dword_8283EB4;
      *v4 = dword_8283EBC;
    }
    v2 = v4[1] + dword_8283EC0;
    v3 = (char *)dword_8283EAC + 8 * v2;
    *v3 = a1;
    if ( a1 == -1 )
    {
      dword_8283ECC = v2;
    }
    else if ( a1 == -2 )
    {
      dword_8283ED0 = v2;
    }
    else if ( dword_8283ECC >= 0 && (a2 & 1) != 0 )
    {
      *((_DWORD *)dword_8283EAC + 2 * dword_8283ECC) = a1;
      dword_8283ECC = -1;
    }
    v3[1] |= a2;
    v4[2] = ++dword_8283EC0;
    ++dword_8283EA8;
    ++dword_8283EB4;
  }
}
// 8202A65: using guessed type char byte_8202A65;
// 8202A68: using guessed type int dword_8202A68;
// 8202A6C: using guessed type int dword_8202A6C;
// 8283EA4: using guessed type int dword_8283EA4;
// 8283EA8: using guessed type int dword_8283EA8;
// 8283EB0: using guessed type int dword_8283EB0;
// 8283EB4: using guessed type int dword_8283EB4;
// 8283EBC: using guessed type int dword_8283EBC;
// 8283EC0: using guessed type int dword_8283EC0;
// 8283ECC: using guessed type int dword_8283ECC;
// 8283ED0: using guessed type int dword_8283ED0;
// 839400A: using guessed type char byte_839400A;

//----- (08076FAE) --------------------------------------------------------
int sub_8076FAE()
{
  int result; // eax

  if ( byte_839400A && dword_8202A68 != 2 )
  {
    --dword_8283EB4;
    --dword_8283EA8;
    if ( !--dword_8283EC0 )
      dword_8283EBC = 0;
    result = dword_8283EC0;
    *((_DWORD *)dword_8283EA0 + 5 * dword_8283EA8 + 2) = dword_8283EC0;
  }
  return result;
}
// 8202A68: using guessed type int dword_8202A68;
// 8283EA8: using guessed type int dword_8283EA8;
// 8283EB4: using guessed type int dword_8283EB4;
// 8283EBC: using guessed type int dword_8283EBC;
// 8283EC0: using guessed type int dword_8283EC0;
// 839400A: using guessed type char byte_839400A;

//----- (08077016) --------------------------------------------------------
_DWORD *__cdecl sub_8077016(int a1)
{
  _DWORD *result; // eax
  _DWORD *v2; // [esp+0h] [ebp-4h]

  if ( byte_839400A )
  {
    if ( dword_8202A68 != 2 )
    {
      v2 = (char *)dword_8283EAC + 8 * dword_8283ED0;
      *v2 = a1;
      result = v2;
      v2[1] = 4;
      dword_8283ED0 = -1;
    }
  }
  return result;
}
// 8202A68: using guessed type int dword_8202A68;
// 8283ED0: using guessed type int dword_8283ED0;
// 839400A: using guessed type char byte_839400A;

//----- (080773B6) --------------------------------------------------------
char *__cdecl sub_80773B6(unsigned int a1)
{
  int v3; // [esp+4h] [ebp-Ch]
  int v4; // [esp+8h] [ebp-8h]
  int v5; // [esp+Ch] [ebp-4h]

  v5 = 0;
  v4 = dword_8283EA8 - 1;
  while ( v5 <= v4 )
  {
    v3 = (v4 + v5) / 2;
    if ( a1 < *((_DWORD *)dword_8283EA0 + 5 * v3) )
    {
      v4 = v3 - 1;
    }
    else
    {
      v5 = v3 + 1;
      if ( v3 + 1 == dword_8283EA8 || a1 < *((_DWORD *)dword_8283EA0 + 5 * v5) )
        return (char *)dword_8283EA0 + 20 * v3;
    }
  }
  return 0;
}
// 8283EA8: using guessed type int dword_8283EA8;

//----- (08077474) --------------------------------------------------------
char *__cdecl sub_8077474(unsigned int a1)
{
  int v3; // [esp+4h] [ebp-Ch]
  int v4; // [esp+8h] [ebp-8h]
  int v5; // [esp+Ch] [ebp-4h]

  v5 = 0;
  v4 = dword_8283EA8 - 1;
  while ( v5 <= v4 )
  {
    v3 = (v4 + v5) / 2;
    if ( a1 < *((_DWORD *)dword_8283EA0 + 5 * v3) )
    {
      v4 = v3 - 1;
    }
    else
    {
      if ( a1 == *((_DWORD *)dword_8283EA0 + 5 * v3) )
        return (char *)dword_8283EA0 + 20 * v3;
      v5 = v3 + 1;
    }
  }
  return 0;
}
// 8283EA8: using guessed type int dword_8283EA8;

//----- (0807752A) --------------------------------------------------------
int __cdecl sub_807752A(unsigned int a1, int a2)
{
  return *((_DWORD *)dword_8283EAC + 2 * *((_DWORD *)sub_80773B6(a1) + 1) + 2 * a2);
}

//----- (08077554) --------------------------------------------------------
int __cdecl sub_8077554(_BYTE *a1, int a2, _DWORD *a3, _DWORD *a4)
{
  int v5; // [esp+0h] [ebp-4h]

  *a3 = a1;
  v5 = 0;
  while ( a2 )
  {
    if ( !*a1 )
    {
      *a3 = a1 + 1;
      ++v5;
    }
    ++a1;
    --a2;
  }
  *a4 = &a1[-*a3];
  return v5;
}

//----- (080775A6) --------------------------------------------------------
int __cdecl sub_80775A6(int a1, int a2)
{
  int v3; // [esp+10h] [ebp-8h] BYREF
  int v4; // [esp+14h] [ebp-4h] BYREF

  return sub_8077554(*((_BYTE **)dword_8283ED4 + 6 * a1 + 2), a2, &v3, &v4);
}

//----- (080775E4) --------------------------------------------------------
int __cdecl sub_80775E4(unsigned int a1, int a2, int *a3)
{
  unsigned int i; // [esp+Ch] [ebp-Ch]
  char *v6; // [esp+10h] [ebp-8h]

  v6 = sub_8077474(a1);
  if ( v6 )
  {
    for ( i = 0; i < *((_DWORD *)v6 + 2); ++i )
    {
      if ( (*((_DWORD *)dword_8283EAC + 2 * *((_DWORD *)v6 + 1) + 2 * i + 1) & a2) == a2 )
      {
        a3[2] = *((_DWORD *)dword_8283EAC + 2 * *((_DWORD *)v6 + 1) + 2 * i);
        *a3 = sub_8077D5A(a1);
        a3[1] = sub_80775A6(*a3, a3[2]);
        return 1;
      }
    }
  }
  return 0;
}

//----- (080776B8) --------------------------------------------------------
char *sub_80776B8()
{
  void *dest; // [esp+14h] [ebp-4h]

  if ( dword_8283ED8 >= (unsigned int)dword_8283EB8 )
  {
    dword_8283EB8 *= 2;
    dest = Z_MallocInternal(24 * dword_8283EB8);
    Com_Memcpy(dest, dword_8283ED4, 24 * dword_8283ED8);
    Z_FreeInternal(dword_8283ED4);
    dword_8283ED4 = dest;
  }
  return (char *)dword_8283ED4 + 24 * dword_8283ED8++;
}
// 8283EB8: using guessed type int dword_8283EB8;
// 8283ED8: using guessed type int dword_8283ED8;

//----- (08077750) --------------------------------------------------------
int __cdecl sub_8077750(char *s, int a2, char *a3, int a4, int a5, unsigned __int8 a6)
{
  int result; // eax
  char *v7; // eax
  char *v8; // edx
  int v9; // [esp+Ch] [ebp-2Ch]
  char *v10; // [esp+14h] [ebp-24h]
  char v11; // [esp+1Bh] [ebp-1Dh]
  char v12; // [esp+1Bh] [ebp-1Dh]
  int i; // [esp+1Ch] [ebp-1Ch]
  int j; // [esp+1Ch] [ebp-1Ch]
  _BYTE *v15; // [esp+24h] [ebp-14h]
  size_t v16; // [esp+2Ch] [ebp-Ch]
  char *dest; // [esp+30h] [ebp-8h]

  result = a5;
  if ( dword_8283ED4 )
  {
    v16 = strlen(s) + 1;
    dest = (char *)Z_MallocInternal(v16 + a4 + 2);
    strcpy(dest, s);
    if ( a3 )
      v9 = (int)&dest[v16];
    else
      v9 = 0;
    v10 = a3;
    v15 = (_BYTE *)v9;
    if ( (_BYTE)a5 )
    {
      for ( i = 0; i <= a4; ++i )
      {
        v11 = *v10++;
        if ( v11 == 10 || v11 == 13 && *v10 != 10 )
          *v15 = 0;
        else
          *v15 = v11;
        ++v15;
      }
    }
    else
    {
      for ( j = 0; j <= a4; ++j )
      {
        v12 = *v10++;
        *v15++ = v12;
      }
    }
    v7 = sub_80776B8();
    *(_DWORD *)v7 = a2;
    *((_DWORD *)v7 + 1) = dest;
    *((_DWORD *)v7 + 2) = v9;
    *((_DWORD *)v7 + 3) = a4;
    *((_DWORD *)v7 + 4) = -1;
    v8 = v7;
    result = a6;
    v8[20] = a6;
    if ( v9 )
    {
      result = v9;
      *(_DWORD *)dword_8283EE0 = v9;
    }
  }
  else
  {
    *(_DWORD *)dword_8283EE0 = 0;
  }
  return result;
}

//----- (080778BC) --------------------------------------------------------
int __cdecl sub_80778BC(int a1, char *s, int a3, unsigned __int8 a4)
{
  int v6; // [esp+28h] [ebp-10h] BYREF
  int v7; // [esp+2Ch] [ebp-Ch]
  int v8; // [esp+30h] [ebp-8h]
  unsigned __int8 v9; // [esp+37h] [ebp-1h]

  v9 = a4;
  v7 = FS_FOpenFileByMode(s, &v6, 0);
  if ( v7 >= 0 )
  {
    v8 = Hunk_AllocateTempMemoryHighInternal(v7 + 1);
    FS_Read(v8, v7, v6);
    *(_BYTE *)(v8 + v7) = 0;
    FS_FCloseFile(v6);
    sub_8077750(s, a3, (char *)v8, v7, 1, v9);
    return v8;
  }
  else
  {
    sub_8077750(s, a3, 0, -1, 1, v9);
    return 0;
  }
}

//----- (0807799E) --------------------------------------------------------
char *__cdecl sub_807799E(int a1, char *s, int a3, unsigned __int8 a4)
{
  char v5; // [esp+1Fh] [ebp-29h]
  char *v7; // [esp+28h] [ebp-20h]
  char *v8; // [esp+2Ch] [ebp-1Ch]
  int v9; // [esp+30h] [ebp-18h]
  char *v10; // [esp+34h] [ebp-14h]
  char v11; // [esp+3Bh] [ebp-Dh]
  int i; // [esp+3Ch] [ebp-Ch]
  char *v13; // [esp+40h] [ebp-8h]

  if ( !a4 || !dword_8283EC4 )
    return (char *)sub_80778BC(a1, s, a3, a4);
  --dword_8283EC8;
  v7 = (char *)dword_8283EC4 + 8 * dword_8283EC8;
  v9 = *((_DWORD *)v7 + 1);
  if ( v9 >= 0 )
  {
    v10 = (char *)Hunk_AllocateTempMemoryHighInternal(v9 + 1);
    v8 = *(char **)v7;
    v13 = v10;
    for ( i = 0; i < v9; ++i )
    {
      v11 = *v8++;
      v5 = v11;
      if ( !v11 )
        v5 = 10;
      *v13++ = v5;
    }
    *v13 = 0;
    if ( *(_DWORD *)v7 )
      Z_FreeInternal(*((void **)dword_8283EC4 + 2 * dword_8283EC8));
    sub_8077750(s, a3, v10, v9, 1, a4);
  }
  else
  {
    v10 = 0;
    sub_8077750(s, a3, 0, v9, 1, a4);
  }
  return v10;
}
// 8283EC8: using guessed type int dword_8283EC8;

//----- (08077AE8) --------------------------------------------------------
int __cdecl sub_8077AE8(_BYTE *a1, int a2, _DWORD *a3, int a4)
{
  char v5; // [esp+1Fh] [ebp-19h]
  char *s; // [esp+24h] [ebp-14h] BYREF
  int v7; // [esp+28h] [ebp-10h]
  char v8; // [esp+2Fh] [ebp-9h]
  int i; // [esp+30h] [ebp-8h]
  int v10; // [esp+34h] [ebp-4h]

  v7 = sub_8077554(a1, a2, &s, a3);
  v10 = strlen(s);
  if ( v10 > 1023 )
    v10 = 1023;
  for ( i = 0; i <= v10; ++i )
  {
    v8 = s[i];
    if ( v8 == 9 )
      v5 = 32;
    else
      v5 = v8;
    *(_BYTE *)(i + a4) = v5;
  }
  if ( *(_BYTE *)(a4 + v10 - 1) == 13 )
    *(_BYTE *)(a4 + v10 - 1) = 0;
  return v7;
}

//----- (08077B96) --------------------------------------------------------
void __cdecl sub_8077B96(int a1, const char *a2, _BYTE *a3, int a4)
{
  char *v4; // eax
  char *v5; // eax
  int v6; // [esp+Ch] [ebp-41Ch]
  int i; // [esp+14h] [ebp-414h]
  int v8; // [esp+18h] [ebp-410h] BYREF
  int v9; // [esp+1Ch] [ebp-40Ch]
  char v10[1032]; // [esp+20h] [ebp-408h] BYREF

  v9 = sub_8077AE8(a3, a4, &v8, (int)v10);
  v6 = v9 + 1;
  if ( dword_8283EC4 )
    v4 = va("(file '%s'%s, line %d)\n", a2, " (savegame)", v6);
  else
    v4 = va("(file '%s'%s, line %d)\n", a2, (const char *)&unk_813F86C, v6);
  Com_PrintMessage(a1, v4);
  v5 = va("%s\n", v10);
  Com_PrintMessage(a1, v5);
  for ( i = 0; i < v8; ++i )
    Com_PrintMessage(a1, " ");
  Com_PrintMessage(a1, "*\n");
}
// 8077B96: using guessed type const char *arg_4;

//----- (08077C92) --------------------------------------------------------
int __cdecl sub_8077C92(int a1, int a2, char *s, size_t maxlen)
{
  int v5; // [esp+18h] [ebp-420h]
  int v6; // [esp+28h] [ebp-410h] BYREF
  int v7; // [esp+2Ch] [ebp-40Ch]
  char v8[1032]; // [esp+30h] [ebp-408h] BYREF

  v7 = sub_8077AE8(*((_BYTE **)dword_8283ED4 + 6 * a1 + 2), a2, &v6, (int)v8);
  v5 = v7 + 1;
  if ( dword_8283EC4 )
    Com_sprintf(s, maxlen, "%s // %s%s, line %d", v8, *((const char **)dword_8283ED4 + 6 * a1 + 1), " (savegame)", v5);
  else
    Com_sprintf(
      s,
      maxlen,
      "%s // %s%s, line %d",
      v8,
      *((const char **)dword_8283ED4 + 6 * a1 + 1),
      (const char *)&unk_813F86C,
      v5);
  return v7;
}

//----- (08077D5A) --------------------------------------------------------
int __cdecl sub_8077D5A(unsigned int a1)
{
  int i; // [esp+0h] [ebp-4h]

  for ( i = dword_8283ED8 - 1;
        i > 0 && (!*((_DWORD *)dword_8283ED4 + 6 * i) || *((_DWORD *)dword_8283ED4 + 6 * i) > a1);
        --i )
  {
    ;
  }
  return i;
}
// 8283ED8: using guessed type int dword_8283ED8;

//----- (08077DBA) --------------------------------------------------------
void __cdecl Scr_PrintPrevCodePos(int a1, const char *a2, int a3)
{
  char *v3; // eax
  int v4; // eax
  char *v5; // eax
  int v6; // [esp+14h] [ebp-4h]

  if ( !a2 )
  {
    Com_PrintMessage(a1, "<frozen thread>\n");
    return;
  }
  if ( a2 == (const char *)&unk_83D4100 )
  {
    Com_PrintMessage(a1, "<removed thread>\n");
  }
  else
  {
    if ( byte_839400A )
    {
      if ( dword_8394048 && Scr_IsInOpcodeMemory((int)a2) )
      {
        v6 = sub_8077D5A((unsigned int)(a2 - 1));
        v4 = sub_807752A((unsigned int)(a2 - 1), a3);
        sub_8077B96(a1, *((const char **)dword_8283ED4 + 6 * v6 + 1), *((_BYTE **)dword_8283ED4 + 6 * v6 + 2), v4);
        return;
      }
    }
    else if ( Scr_IsInOpcodeMemory((int)(a2 - 1)) )
    {
      v3 = va("@ %d\n", &a2[-dword_8394048]);
      Com_PrintMessage(a1, v3);
      return;
    }
    v5 = va("%s\n\n", a2);
    Com_PrintMessage(a1, v5);
  }
}
// 839400A: using guessed type char byte_839400A;
// 8394048: using guessed type int dword_8394048;
// 8077DBA: using guessed type const char *arg_4;

//----- (08077EF6) --------------------------------------------------------
int __cdecl sub_8077EF6(int a1, int a2, char *s, size_t maxlen)
{
  int v5[6]; // [esp+10h] [ebp-18h] BYREF

  if ( !byte_839400A )
    return Com_sprintf(s, maxlen, "@ %d", a1 - dword_8394048);
  sub_80775E4(a1, 4, v5);
  return sub_8077C92(v5[0], v5[2], s, maxlen);
}
// 839400A: using guessed type char byte_839400A;
// 8394048: using guessed type int dword_8394048;

//----- (08077FFE) --------------------------------------------------------
char *CompileError(int a1, char *format, ...)
{
  char *result; // eax
  char s[1036]; // [esp+10h] [ebp-418h] BYREF
  __gnuc_va_list __varargs; // [esp+41Ch] [ebp-Ch]
  va_list va; // [esp+438h] [ebp+10h] BYREF

  va_start(va, format);
  va_copy(__varargs, va);
  result = (char *)vsprintf(s, format, va);
  if ( !byte_839400C )
  {
    Com_Printf("\n");
    Com_Printf("******* script compile error *******\n");
    if ( byte_839400A )
    {
      Com_Printf("%s: ", s);
      sub_8077B96(0, *(const char **)dword_8283EDC, *(_BYTE **)dword_8283EE0, a1);
    }
    else
    {
      Com_Printf("%s\n", s);
    }
    Com_Printf("************************************\n");
    Com_Error(5, (char *)&byte_813F960);
  }
  if ( !*(_DWORD *)dword_8394010 )
  {
    result = va("%s", s);
    *(_DWORD *)dword_8394010 = result;
  }
  return result;
}
// 839400A: using guessed type char byte_839400A;
// 839400C: using guessed type char byte_839400C;

//----- (080780F6) --------------------------------------------------------
void __noreturn sub_80780F6(const char *a1, char *format, ...)
{
  char s[1036]; // [esp+10h] [ebp-418h] BYREF
  __gnuc_va_list __varargs; // [esp+41Ch] [ebp-Ch]
  va_list va; // [esp+438h] [ebp+10h] BYREF

  va_start(va, format);
  Com_Printf("\n");
  Com_Printf("******* script compile error *******\n");
  va_copy(__varargs, va);
  vsprintf(s, format, va);
  Com_Printf("%s: ", s);
  Scr_PrintPrevCodePos(0, a1, 0);
  Com_Printf("************************************\n");
  Com_Error(5, (char *)&byte_813F960);
}
// 80780F6: using guessed type const char *arg_0;

//----- (0807818C) --------------------------------------------------------
void __cdecl runtimeError(int a1, const char *a2, int a3, const char *a4)
{
  char *v4; // eax
  int i; // [esp+14h] [ebp-4h]

  v4 = va("\n******* script runtime error *******\n%s: ", a4);
  Com_PrintMessage(a1, v4);
  Scr_PrintPrevCodePos(a1, a2, a3);
  if ( dword_83D7608 )
  {
    for ( i = dword_83D7608 - 1; i > 0; --i )
    {
      Com_PrintMessage(a1, "called from:\n");
      Scr_PrintPrevCodePos(a1, (const char *)dword_83D7620[6 * i], dword_83D7624[6 * i] == 0);
    }
    Com_PrintMessage(a1, "started from:\n");
    Scr_PrintPrevCodePos(a1, (const char *)dword_83D7620[0], 1);
  }
  Com_PrintMessage(a1, "************************************\n");
}
// 83D7608: using guessed type int dword_83D7608;
// 83D7620: using guessed type int dword_83D7620[];
// 83D7624: using guessed type int dword_83D7624[];

//----- (08078282) --------------------------------------------------------
void __cdecl scriptError(const char *a1, int a2, const char *a3, void *a4)
{
  const char *v4; // [esp+18h] [ebp-10h]
  void *v5; // [esp+1Ch] [ebp-Ch]
  char v6; // [esp+27h] [ebp-1h]

  if ( byte_839400A || byte_83D7616 )
  {
    if ( byte_83D7614 )
    {
      Com_Printf("%s\n", a3);
      if ( byte_83D7616 )
        goto LABEL_13;
    }
    else
    {
      v6 = 0;
      if ( byte_83D7615 || byte_83D7616 )
        v6 = 1;
      if ( v6 )
        runtimeError(0, a1, a2, a3);
      else
        runtimeError(4, a1, a2, a3);
      if ( v6 )
      {
LABEL_13:
        v5 = a4;
        if ( !a4 )
          v5 = &unk_813F86C;
        if ( a4 )
          v4 = "\n";
        else
          v4 = (const char *)&unk_813F86C;
        if ( byte_83D7616 )
          Com_Error(5, (char *)&byte_813FA00, a3, v4, v5);
        Com_Error(4, (char *)&byte_813FA00, a3, v4, v5);
      }
    }
  }
}
// 839400A: using guessed type char byte_839400A;
// 83D7614: using guessed type char byte_83D7614;
// 83D7615: using guessed type char byte_83D7615;
// 83D7616: using guessed type char byte_83D7616;
// 8078282: using guessed type const char *arg_8;

//----- (08078390) --------------------------------------------------------
_DWORD *__userpurge sub_8078390@<eax>(_DWORD *a1, int a2)
{
  *a1 = a2;
  return a1;
}

//----- (080783A2) --------------------------------------------------------
_DWORD *__userpurge sub_80783A2@<eax>(_DWORD *a1, int a2)
{
  *a1 = a2;
  return a1;
}

//----- (080783B4) --------------------------------------------------------
size_t *__userpurge sub_80783B4@<eax>(size_t *a1, int a2)
{
  *a1 = Hunk_AllocateTempMemoryHighInternal(4);
  *(_DWORD *)*a1 = a2;
  return a1;
}

//----- (080783DE) --------------------------------------------------------
int __userpurge sub_80783DE@<eax>(int a1, int a2, int a3)
{
  *(_DWORD *)a1 = Hunk_AllocateTempMemoryHighInternal(8);
  **(_DWORD **)a1 = a2;
  *(_DWORD *)(*(_DWORD *)a1 + 4) = a3;
  return a1;
}

//----- (08078412) --------------------------------------------------------
int __userpurge sub_8078412@<eax>(int a1, int a2, int a3, int a4)
{
  *(_DWORD *)a1 = Hunk_AllocateTempMemoryHighInternal(12);
  **(_DWORD **)a1 = a2;
  *(_DWORD *)(*(_DWORD *)a1 + 4) = a3;
  *(_DWORD *)(*(_DWORD *)a1 + 8) = a4;
  return a1;
}

//----- (08078450) --------------------------------------------------------
int __userpurge sub_8078450@<eax>(int a1, int a2, int a3)
{
  *(_DWORD *)a1 = Hunk_AllocateTempMemoryHighInternal(8);
  **(_DWORD **)a1 = a2;
  *(_DWORD *)(*(_DWORD *)a1 + 4) = a3;
  return a1;
}

//----- (08078484) --------------------------------------------------------
int __userpurge sub_8078484@<eax>(int a1, int a2, int a3, int a4, int a5)
{
  *(_DWORD *)a1 = Hunk_AllocateTempMemoryHighInternal(16);
  **(_DWORD **)a1 = a2;
  *(_DWORD *)(*(_DWORD *)a1 + 4) = a3;
  *(_DWORD *)(*(_DWORD *)a1 + 8) = a4;
  *(_DWORD *)(*(_DWORD *)a1 + 12) = a5;
  return a1;
}

//----- (080784CC) --------------------------------------------------------
int __userpurge sub_80784CC@<eax>(int a1, int a2, int a3, int a4)
{
  *(_DWORD *)a1 = Hunk_AllocateTempMemoryHighInternal(12);
  **(_DWORD **)a1 = a2;
  *(_DWORD *)(*(_DWORD *)a1 + 4) = a3;
  *(_DWORD *)(*(_DWORD *)a1 + 8) = a4;
  return a1;
}

//----- (0807850A) --------------------------------------------------------
int __userpurge sub_807850A@<eax>(int a1, int a2, int a3, int a4, int a5, int a6)
{
  *(_DWORD *)a1 = Hunk_AllocateTempMemoryHighInternal(20);
  **(_DWORD **)a1 = a2;
  *(_DWORD *)(*(_DWORD *)a1 + 4) = a3;
  *(_DWORD *)(*(_DWORD *)a1 + 8) = a4;
  *(_DWORD *)(*(_DWORD *)a1 + 12) = a5;
  *(_DWORD *)(*(_DWORD *)a1 + 16) = a6;
  return a1;
}

//----- (0807855C) --------------------------------------------------------
int __userpurge sub_807855C@<eax>(int a1, int a2, int a3, int a4, int a5)
{
  *(_DWORD *)a1 = Hunk_AllocateTempMemoryHighInternal(16);
  **(_DWORD **)a1 = a2;
  *(_DWORD *)(*(_DWORD *)a1 + 4) = a3;
  *(_DWORD *)(*(_DWORD *)a1 + 8) = a4;
  *(_DWORD *)(*(_DWORD *)a1 + 12) = a5;
  return a1;
}

//----- (080785A4) --------------------------------------------------------
int __userpurge sub_80785A4@<eax>(int a1, int a2, int a3, int a4, int a5, int a6, int a7)
{
  *(_DWORD *)a1 = Hunk_AllocateTempMemoryHighInternal(24);
  **(_DWORD **)a1 = a2;
  *(_DWORD *)(*(_DWORD *)a1 + 4) = a3;
  *(_DWORD *)(*(_DWORD *)a1 + 8) = a4;
  *(_DWORD *)(*(_DWORD *)a1 + 12) = a5;
  *(_DWORD *)(*(_DWORD *)a1 + 16) = a6;
  *(_DWORD *)(*(_DWORD *)a1 + 20) = a7;
  return a1;
}

//----- (08078600) --------------------------------------------------------
int __userpurge sub_8078600@<eax>(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8)
{
  *(_DWORD *)a1 = Hunk_AllocateTempMemoryHighInternal(28);
  **(_DWORD **)a1 = a2;
  *(_DWORD *)(*(_DWORD *)a1 + 4) = a3;
  *(_DWORD *)(*(_DWORD *)a1 + 8) = a4;
  *(_DWORD *)(*(_DWORD *)a1 + 12) = a5;
  *(_DWORD *)(*(_DWORD *)a1 + 16) = a6;
  *(_DWORD *)(*(_DWORD *)a1 + 20) = a7;
  *(_DWORD *)(*(_DWORD *)a1 + 24) = a8;
  return a1;
}

//----- (08078666) --------------------------------------------------------
int __userpurge sub_8078666@<eax>(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, int a9)
{
  *(_DWORD *)a1 = Hunk_AllocateTempMemoryHighInternal(32);
  **(_DWORD **)a1 = a2;
  *(_DWORD *)(*(_DWORD *)a1 + 4) = a3;
  *(_DWORD *)(*(_DWORD *)a1 + 8) = a4;
  *(_DWORD *)(*(_DWORD *)a1 + 12) = a5;
  *(_DWORD *)(*(_DWORD *)a1 + 16) = a6;
  *(_DWORD *)(*(_DWORD *)a1 + 20) = a7;
  *(_DWORD *)(*(_DWORD *)a1 + 24) = a8;
  *(_DWORD *)(*(_DWORD *)a1 + 28) = a9;
  return a1;
}

//----- (080786D6) --------------------------------------------------------
int __userpurge sub_80786D6@<eax>(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, int a9, int a10)
{
  *(_DWORD *)a1 = Hunk_AllocateTempMemoryHighInternal(36);
  **(_DWORD **)a1 = a2;
  *(_DWORD *)(*(_DWORD *)a1 + 4) = a3;
  *(_DWORD *)(*(_DWORD *)a1 + 8) = a4;
  *(_DWORD *)(*(_DWORD *)a1 + 12) = a5;
  *(_DWORD *)(*(_DWORD *)a1 + 16) = a6;
  *(_DWORD *)(*(_DWORD *)a1 + 20) = a7;
  *(_DWORD *)(*(_DWORD *)a1 + 24) = a8;
  *(_DWORD *)(*(_DWORD *)a1 + 28) = a9;
  *(_DWORD *)(*(_DWORD *)a1 + 32) = a10;
  return a1;
}

//----- (08078750) --------------------------------------------------------
int __userpurge sub_8078750@<eax>(int a1, int a2)
{
  _DWORD *v3; // [esp+10h] [ebp-8h]

  v3 = (_DWORD *)Hunk_AllocateTempMemoryHighInternal(8);
  *v3 = a2;
  v3[1] = 0;
  *(_DWORD *)a1 = Hunk_AllocateTempMemoryHighInternal(8);
  **(_DWORD **)a1 = v3;
  *(_DWORD *)(*(_DWORD *)a1 + 4) = v3;
  return a1;
}

//----- (080787A6) --------------------------------------------------------
_DWORD *__userpurge sub_80787A6@<eax>(_DWORD *a1, int a2, _DWORD *a3)
{
  _DWORD *v3; // eax

  v3 = (_DWORD *)Hunk_AllocateTempMemoryHighInternal(8);
  *v3 = a2;
  v3[1] = *a3;
  *a3 = v3;
  *a1 = a3;
  return a1;
}

//----- (080787EC) --------------------------------------------------------
_DWORD *__userpurge sub_80787EC@<eax>(_DWORD *a1, int a2, int a3)
{
  _DWORD *v3; // eax

  v3 = (_DWORD *)Hunk_AllocateTempMemoryHighInternal(8);
  *v3 = a3;
  v3[1] = 0;
  *(_DWORD *)(*(_DWORD *)(a2 + 4) + 4) = v3;
  *(_DWORD *)(a2 + 4) = v3;
  *a1 = a2;
  return a1;
}

//----- (08078878) --------------------------------------------------------
int __cdecl sub_8078878(int a1)
{
  return dword_8283E80 + 8 * a1;
}
// 8283E80: using guessed type int dword_8283E80;

//----- (0807888A) --------------------------------------------------------
int __cdecl sub_807888A(int a1)
{
  return a1 - 4;
}

//----- (08078896) --------------------------------------------------------
int __cdecl SL_ConvertToString(int a1)
{
  if ( a1 )
    return sub_8078878(a1) + 4;
  else
    return 0;
}

//----- (080788C2) --------------------------------------------------------
int __cdecl sub_80788C2(_BYTE *a1)
{
  int i; // [esp+4h] [ebp-4h]

  for ( i = (unsigned __int8)(*a1 - 1); a1[i + 4]; i += 256 )
    ;
  return i;
}

//----- (080788FC) --------------------------------------------------------
int __cdecl sub_80788FC(int a1)
{
  _BYTE *v2; // [esp+4h] [ebp-4h]

  v2 = (_BYTE *)sub_8078878(a1);
  return sub_80788C2(v2);
}

//----- (0807891E) --------------------------------------------------------
int __cdecl sub_807891E(int a1)
{
  return (a1 - dword_8283E80) / 8;
}
// 8283E80: using guessed type int dword_8283E80;

//----- (08078946) --------------------------------------------------------
int __cdecl sub_8078946(int a1)
{
  int v1; // eax

  v1 = sub_807888A(a1);
  return sub_807891E(v1);
}

//----- (08078962) --------------------------------------------------------
unsigned int __cdecl sub_8078962(char *a1, unsigned int a2)
{
  unsigned int v5; // [esp+14h] [ebp-8h]

  if ( a2 > 0xFF )
    return (a2 >> 2)
         - 0x3FFF
         * ((unsigned int)(((262161 * (unsigned __int64)(a2 >> 2)) >> 32)
                         + ((unsigned int)((a2 >> 2) - ((262161 * (unsigned __int64)(a2 >> 2)) >> 32)) >> 1)) >> 13)
         + 1;
  v5 = 0;
  while ( a2 )
  {
    v5 = *a1++ + 31 * v5;
    --a2;
  }
  return v5 % 0x3FFF + 1;
}

//----- (08078A24) --------------------------------------------------------
unsigned int sub_8078A24()
{
  unsigned int result; // eax
  unsigned int v1; // [esp+Ch] [ebp-Ch]
  unsigned int i; // [esp+14h] [ebp-4h]

  sub_80766E6();
  word_8283F00[0] = 0;
  v1 = 0;
  for ( i = 1; i <= 0x3FFF; ++i )
  {
    word_8283F00[2 * i] = 0;
    word_8283F00[2 * v1] |= i;
    word_8283F00[2 * i + 1] = v1;
    v1 = i;
  }
  result = v1;
  word_8283F02[0] = v1;
  byte_8293F00 = 1;
  return result;
}
// 8283F00: using guessed type __int16 word_8283F00[];
// 8283F02: using guessed type __int16 word_8283F02[32767];
// 8293F00: using guessed type char byte_8293F00;

//----- (08078AB2) --------------------------------------------------------
void sub_8078AB2()
{
  if ( byte_8293F00 )
    sub_8079A58();
  else
    sub_8078A24();
}
// 8293F00: using guessed type char byte_8293F00;

//----- (08078AD0) --------------------------------------------------------
void sub_8078AD0()
{
  if ( byte_8293F00 )
    byte_8293F00 = 0;
}
// 8293F00: using guessed type char byte_8293F00;

//----- (08078AE8) --------------------------------------------------------
int __cdecl sub_8078AE8(char *s2, size_t n)
{
  int v4; // [esp+18h] [ebp-20h]
  int v5; // [esp+20h] [ebp-18h]
  unsigned int v6; // [esp+24h] [ebp-14h]
  unsigned __int8 *v7; // [esp+28h] [ebp-10h]
  unsigned __int8 *v8; // [esp+28h] [ebp-10h]
  __int16 *i; // [esp+2Ch] [ebp-Ch]
  unsigned int v10; // [esp+30h] [ebp-8h]
  __int16 *v11; // [esp+34h] [ebp-4h]

  v6 = sub_8078962(s2, n);
  v11 = &word_8283F00[2 * v6];
  if ( (*v11 & 0xC000) != 0x8000 )
    return 0;
  v7 = (unsigned __int8 *)sub_8078878((unsigned __int16)v11[1]);
  if ( *v7 != (unsigned __int8)n || memcmp(v7 + 4, s2, n) )
  {
    v10 = v6;
    v5 = *v11 & 0x3FFF;
    for ( i = &word_8283F00[2 * v5]; i != v11; i = &word_8283F00[2 * v5] )
    {
      v8 = (unsigned __int8 *)sub_8078878((unsigned __int16)i[1]);
      if ( *v8 == (unsigned __int8)n && !memcmp(v8 + 4, s2, n) )
      {
        word_8283F00[2 * v10] = word_8283F00[2 * v10] & 0xC000 | *i & 0x3FFF;
        *i = *i & 0xC000 | *v11 & 0x3FFF;
        *v11 = *v11 & 0xC000 | v5;
        v4 = (unsigned __int16)i[1];
        i[1] = v11[1];
        v11[1] = v4;
        return v4;
      }
      v10 = v5;
      v5 = *i & 0x3FFF;
    }
    return 0;
  }
  return (unsigned __int16)v11[1];
}
// 8283F00: using guessed type __int16 word_8283F00[];

//----- (08078CC6) --------------------------------------------------------
int __cdecl sub_8078CC6(char *s2)
{
  size_t v1; // eax

  v1 = I_strlen(s2);
  return sub_8078AE8(s2, v1 + 1);
}

//----- (08078CEA) --------------------------------------------------------
int __cdecl sub_8078CEA(char *s)
{
  signed int n; // [esp+18h] [ebp-2010h]
  signed int i; // [esp+1Ch] [ebp-200Ch]
  char s2[8200]; // [esp+20h] [ebp-2008h] BYREF

  n = I_strlen(s) + 1;
  if ( n > 0x2000 )
    return 0;
  for ( i = 0; i < n; ++i )
    s2[i] = tolower(s[i]);
  return sub_8078AE8(s2, n);
}
// 8078CEA: using guessed type char s2[8200];

//----- (08078D94) --------------------------------------------------------
int __cdecl sub_8078D94(int a1, unsigned __int8 a2)
{
  int result; // eax

  result = (unsigned __int8)(a2 & *(_BYTE *)(a1 + 1));
  if ( (a2 & *(_BYTE *)(a1 + 1)) == 0 )
  {
    *(_BYTE *)(a1 + 1) |= a2;
    result = *(unsigned __int16 *)(a1 + 2) + 1;
    *(_WORD *)(a1 + 2) = result;
  }
  return result;
}

//----- (08078DEC) --------------------------------------------------------
int __cdecl SL_GetStringOfLen(char *s2, unsigned __int8 a2, size_t n)
{
  int v3; // ecx
  int v6; // [esp+10h] [ebp-28h]
  int v7; // [esp+10h] [ebp-28h]
  int v8; // [esp+18h] [ebp-20h]
  int v9; // [esp+18h] [ebp-20h]
  int v10; // [esp+18h] [ebp-20h]
  unsigned int v11; // [esp+1Ch] [ebp-1Ch]
  unsigned __int8 *v12; // [esp+20h] [ebp-18h]
  unsigned __int8 *v13; // [esp+20h] [ebp-18h]
  int v14; // [esp+20h] [ebp-18h]
  __int16 *j; // [esp+24h] [ebp-14h]
  __int16 *v16; // [esp+24h] [ebp-14h]
  __int16 *v17; // [esp+24h] [ebp-14h]
  int v18; // [esp+2Ch] [ebp-Ch]
  unsigned __int16 v19; // [esp+2Ch] [ebp-Ch]
  unsigned int v20; // [esp+30h] [ebp-8h]
  int i; // [esp+30h] [ebp-8h]
  __int16 *v22; // [esp+34h] [ebp-4h]

  v11 = sub_8078962(s2, n);
  v22 = &word_8283F00[2 * v11];
  if ( (*v22 & 0xC000) != 0x8000 )
  {
    if ( (*v22 & 0xC000) != 0 )
    {
      v19 = *v22 & 0x3FFF;
      for ( i = v19; (word_8283F00[2 * i] & 0x3FFF) != v11; i = word_8283F00[2 * i] & 0x3FFF )
        ;
      v10 = (unsigned __int16)word_8283F00[0];
      if ( !word_8283F00[0] )
      {
        Scr_DumpScriptThreads();
        Scr_DumpScriptVariablesDefault();
        Com_Error(1, (char *)&byte_813FA40);
      }
      v7 = (unsigned __int16)sub_807682A(n + 4);
      v17 = &word_8283F00[2 * v10];
      word_8283F00[0] = *v17 & 0x3FFF;
      word_8283F02[2 * (unsigned __int16)word_8283F00[0]] = 0;
      word_8283F00[2 * i] = word_8283F00[2 * i] & 0xC000 | v10;
      *v17 = v19 | 0x4000;
      v17[1] = v22[1];
    }
    else
    {
      v7 = (unsigned __int16)sub_807682A(n + 4);
      v18 = *v22 & 0x3FFF;
      v3 = (unsigned __int16)v22[1];
      word_8283F00[2 * v3] = word_8283F00[2 * v3] & 0xC000 | v18;
      word_8283F02[2 * v18] = v3;
    }
    *v22 = v11 | 0x8000;
LABEL_23:
    v22[1] = v7;
    v14 = sub_8078878(v7);
    memcpy((void *)(v14 + 4), s2, n);
    *(_BYTE *)(v14 + 1) = a2;
    *(_WORD *)(v14 + 2) = 1;
    *(_BYTE *)v14 = n;
    return v7;
  }
  v12 = (unsigned __int8 *)sub_8078878((unsigned __int16)v22[1]);
  if ( *v12 != (unsigned __int8)n || memcmp(v12 + 4, s2, n) )
  {
    v20 = v11;
    v8 = *v22 & 0x3FFF;
    for ( j = &word_8283F00[2 * v8]; j != v22; j = &word_8283F00[2 * v8] )
    {
      v13 = (unsigned __int8 *)sub_8078878((unsigned __int16)j[1]);
      if ( *v13 == (unsigned __int8)n && !memcmp(v13 + 4, s2, n) )
      {
        word_8283F00[2 * v20] = word_8283F00[2 * v20] & 0xC000 | *j & 0x3FFF;
        *j = *j & 0xC000 | *v22 & 0x3FFF;
        *v22 = *v22 & 0xC000 | v8;
        v6 = (unsigned __int16)j[1];
        j[1] = v22[1];
        v22[1] = v6;
        sub_8078D94((int)v13, a2);
        return v6;
      }
      v20 = v8;
      v8 = *j & 0x3FFF;
    }
    v9 = (unsigned __int16)word_8283F00[0];
    if ( !word_8283F00[0] )
    {
      Scr_DumpScriptThreads();
      Scr_DumpScriptVariablesDefault();
      Com_Error(1, (char *)&byte_813FA40);
    }
    v7 = (unsigned __int16)sub_807682A(n + 4);
    v16 = &word_8283F00[2 * v9];
    word_8283F00[0] = *v16 & 0x3FFF;
    word_8283F02[2 * (unsigned __int16)word_8283F00[0]] = 0;
    *v16 = *v22 & 0x3FFF | 0x4000;
    *v22 = *v22 & 0xC000 | v9 & 0x3FFF;
    v16[1] = v22[1];
    goto LABEL_23;
  }
  sub_8078D94((int)v12, a2);
  return (unsigned __int16)v22[1];
}
// 8283F00: using guessed type __int16 word_8283F00[];
// 8283F02: using guessed type __int16 word_8283F02[32767];

//----- (08079290) --------------------------------------------------------
int __cdecl SL_GetString(char *s, unsigned __int8 a2)
{
  size_t v2; // eax

  v2 = I_strlen(s);
  return SL_GetStringOfLen(s, a2, v2 + 1);
}

//----- (080792C4) --------------------------------------------------------
int __cdecl sub_80792C4(char *s, unsigned __int8 a2)
{
  return SL_GetString(s, a2);
}

//----- (080792E6) --------------------------------------------------------
int __cdecl sub_80792E6(const char *a1, unsigned __int8 a2, size_t n)
{
  size_t i; // [esp+1Ch] [ebp-200Ch]
  char s2[8200]; // [esp+20h] [ebp-2008h] BYREF

  if ( n > 0x2000 )
    Com_Error(1, "max string length exceeded: \"%s\"", a1);
  for ( i = 0; i < n; ++i )
    s2[i] = tolower(a1[i]);
  return SL_GetStringOfLen(s2, a2, n);
}
// 80792E6: using guessed type const char *arg_0;
// 80792E6: using guessed type char s2[8200];

//----- (0807939E) --------------------------------------------------------
int __cdecl sub_807939E(char *s, unsigned __int8 a2)
{
  size_t v2; // eax

  v2 = I_strlen(s);
  return sub_80792E6(s, a2, v2 + 1);
}

//----- (080793D2) --------------------------------------------------------
int __cdecl sub_80793D2(char *s, unsigned __int8 a2)
{
  return sub_807939E(s, a2);
}

//----- (080793F4) --------------------------------------------------------
int __cdecl sub_80793F4(int a1, unsigned __int8 a2)
{
  unsigned int n; // [esp+20h] [ebp-2018h]
  int v5; // [esp+24h] [ebp-2014h]
  int v6; // [esp+28h] [ebp-2010h]
  unsigned int i; // [esp+2Ch] [ebp-200Ch]
  char s2[8200]; // [esp+30h] [ebp-2008h] BYREF

  n = sub_80788FC(a1) + 1;
  if ( n > 0x2000 )
    return a1;
  v6 = SL_ConvertToString(a1);
  for ( i = 0; i < n; ++i )
    s2[i] = tolower(*(char *)(v6 + i));
  v5 = SL_GetStringOfLen(s2, a2, n);
  SL_RemoveRefToString(a1);
  return v5;
}
// 80793F4: using guessed type char s2[8200];

//----- (080794D8) --------------------------------------------------------
int __cdecl sub_80794D8(int a1, unsigned __int8 a2)
{
  int result; // eax
  int v3; // [esp+4h] [ebp-4h]

  v3 = sub_8078878(a1);
  if ( (a2 & *(_BYTE *)(v3 + 1)) != 0 )
  {
    result = *(unsigned __int16 *)(v3 + 2) - 1;
    *(_WORD *)(v3 + 2) = result;
  }
  else
  {
    result = a2;
    LOBYTE(result) = *(_BYTE *)(v3 + 1) | a2;
    *(_BYTE *)(v3 + 1) = result;
  }
  return result;
}

//----- (0807951E) --------------------------------------------------------
int __cdecl sub_807951E(int a1)
{
  int v1; // edx
  int result; // eax

  v1 = sub_8078878(a1);
  result = *(unsigned __int16 *)(v1 + 2) + 1;
  *(_WORD *)(v1 + 2) = result;
  return result;
}

//----- (08079544) --------------------------------------------------------
int __cdecl sub_8079544(int a1, int a2, unsigned int a3)
{
  int result; // eax
  unsigned int v4; // [esp+10h] [ebp-18h]
  int v5; // [esp+14h] [ebp-14h]
  int v6; // [esp+18h] [ebp-10h]
  unsigned int v7; // [esp+1Ch] [ebp-Ch]
  __int16 *v8; // [esp+20h] [ebp-8h]
  __int16 *v9; // [esp+24h] [ebp-4h]

  v7 = sub_8078962((char *)(a2 + 4), a3);
  v9 = &word_8283F00[2 * v7];
  sub_80768E2(a1, a3 + 4);
  v6 = *v9 & 0x3FFF;
  v8 = &word_8283F00[2 * v6];
  if ( (unsigned __int16)v9[1] == a1 )
  {
    if ( v8 == v9 )
    {
      v8 = &word_8283F00[2 * v7];
      v6 = v7;
    }
    else
    {
      *v9 = *v8 & 0x3FFF | 0x8000;
      v9[1] = v8[1];
      dword_8293F04 = (int)&word_8283F00[2 * v7];
    }
  }
  else
  {
    v4 = v7;
    while ( (unsigned __int16)v8[1] != a1 )
    {
      v4 = v6;
      v6 = *v8 & 0x3FFF;
      v8 = &word_8283F00[2 * v6];
    }
    word_8283F00[2 * v4] = word_8283F00[2 * v4] & 0xC000 | *v8 & 0x3FFF;
  }
  v5 = (unsigned __int16)word_8283F00[0];
  *v8 = word_8283F00[0];
  v8[1] = 0;
  word_8283F02[2 * v5] = v6;
  result = v6;
  word_8283F00[0] = v6;
  return result;
}
// 8283F00: using guessed type __int16 word_8283F00[];
// 8283F02: using guessed type __int16 word_8283F02[32767];
// 8293F04: using guessed type int dword_8293F04;

//----- (080796A2) --------------------------------------------------------
int __cdecl SL_RemoveRefToString(int a1)
{
  unsigned int v2; // [esp+10h] [ebp-8h]
  _BYTE *v3; // [esp+14h] [ebp-4h]

  v3 = (_BYTE *)sub_8078878(a1);
  v2 = sub_80788C2(v3) + 1;
  return sub_8079746(a1, v2);
}

//----- (080796DA) --------------------------------------------------------
int __cdecl sub_80796DA(int a1)
{
  int result; // eax
  int v2; // eax
  int v3; // [esp+14h] [ebp-4h]

  v3 = sub_8078878(a1);
  if ( (*(_BYTE *)(v3 + 1) & 4) != 0 )
  {
    *(_WORD *)(v3 + 2) = 1;
    result = v3;
    *(_BYTE *)(v3 + 1) = 4;
  }
  else
  {
    *(_WORD *)(v3 + 2) = 0;
    *(_BYTE *)(v3 + 1) = 0;
    v2 = sub_80788C2((_BYTE *)v3);
    return sub_8079544(a1, v3, v2 + 1);
  }
  return result;
}

//----- (08079746) --------------------------------------------------------
int __cdecl sub_8079746(int a1, unsigned int a2)
{
  int result; // eax

  result = sub_8078878(a1);
  if ( !--*(_WORD *)(result + 2) )
    return sub_8079544(a1, result, a2);
  return result;
}

//----- (08079790) --------------------------------------------------------
int __cdecl Scr_SetString(_WORD *a1, int a2)
{
  int result; // eax

  if ( a2 )
    sub_807951E(a2);
  if ( *a1 )
    SL_RemoveRefToString((unsigned __int16)*a1);
  result = a2;
  *a1 = a2;
  return result;
}

//----- (080797CA) --------------------------------------------------------
int __cdecl sub_80797CA(_WORD *a1, char *s)
{
  int result; // eax

  if ( *a1 )
    SL_RemoveRefToString((unsigned __int16)*a1);
  result = sub_80792C4(s, 0);
  *a1 = result;
  return result;
}

//----- (08079808) --------------------------------------------------------
int __cdecl sub_8079808(char *s)
{
  return sub_80792C4(s, 1u);
}

//----- (08079824) --------------------------------------------------------
int __cdecl sub_8079824(float a1)
{
  char s[136]; // [esp+10h] [ebp-88h] BYREF

  sprintf(s, "%g", a1);
  return SL_GetString(s, 0);
}

//----- (0807986A) --------------------------------------------------------
int __cdecl sub_807986A(int a1)
{
  char s[136]; // [esp+10h] [ebp-88h] BYREF

  sprintf(s, "%i", a1);
  return SL_GetString(s, 0);
}

//----- (080798B0) --------------------------------------------------------
int __cdecl sub_80798B0(float *a1)
{
  char s[136]; // [esp+20h] [ebp-88h] BYREF

  sprintf(s, "(%g, %g, %g)", *a1, a1[1], a1[2]);
  return SL_GetString(s, 0);
}

//----- (08079910) --------------------------------------------------------
void __cdecl sub_8079910(unsigned __int8 a1)
{
  int v1; // [esp+Ch] [ebp-Ch]
  __int16 *v2; // [esp+10h] [ebp-8h]
  unsigned int i; // [esp+14h] [ebp-4h]

  for ( i = 1; i <= 0x3FFF; ++i )
  {
    do
    {
      v2 = &word_8283F00[2 * i];
      if ( (*v2 & 0xC000) == 0 )
        break;
      v1 = sub_8078878((unsigned __int16)v2[1]);
      if ( (a1 & *(_BYTE *)(v1 + 1)) == 0 )
        break;
      *(_BYTE *)(v1 + 1) &= ~a1;
      dword_8293F04 = 0;
      SL_RemoveRefToString((unsigned __int16)v2[1]);
    }
    while ( dword_8293F04 );
  }
}
// 8283F00: using guessed type __int16 word_8283F00[];
// 8293F04: using guessed type int dword_8293F04;

//----- (080799B6) --------------------------------------------------------
void sub_80799B6()
{
  sub_8079910(1u);
}

//----- (08079A58) --------------------------------------------------------
void sub_8079A58()
{
  size_t v0; // eax
  char *s; // [esp+14h] [ebp-14h]
  unsigned __int8 *ptr; // [esp+1Ch] [ebp-Ch]
  __int16 *v3; // [esp+20h] [ebp-8h]
  unsigned int i; // [esp+24h] [ebp-4h]
  unsigned int j; // [esp+24h] [ebp-4h]

  for ( i = 1; i <= 0x3FFF; ++i )
  {
    do
    {
      if ( (word_8283F00[2 * i] & 0xC000) == 0 )
        break;
      dword_8293F04 = 0;
      sub_80796DA((unsigned __int16)word_8283F00[2 * i + 1]);
    }
    while ( dword_8293F04 );
  }
  ptr = (unsigned __int8 *)sub_8076A72();
  for ( j = 1; j <= 0x3FFF; ++j )
  {
    v3 = &word_8283F00[2 * j];
    if ( (*v3 & 0xC000) != 0 && (*(_BYTE *)(sub_8078878((unsigned __int16)v3[1]) + 1) & 4) != 0 )
    {
      s = (char *)SL_ConvertToString((unsigned __int16)v3[1]);
      v0 = I_strlen(s);
      sub_8076A9A((int)ptr, (unsigned __int16)v3[1], v0 + 5);
    }
  }
  sub_8076B14(ptr);
}
// 8283F00: using guessed type __int16 word_8283F00[];
// 8293F04: using guessed type int dword_8293F04;

//----- (08079B84) --------------------------------------------------------
_BYTE *__cdecl sub_8079B84(_BYTE *a1, char *a2, int a3)
{
  _BYTE *result; // eax
  unsigned int c; // [esp+10h] [ebp-8h]

  do
  {
    do
    {
      do
        c = *a2++;
      while ( c == 92 );
    }
    while ( c == 47 );
    while ( c > 0x1F )
    {
      *a1++ = tolower(c);
      if ( !--a3 )
        Com_Error(1, (char *)&byte_813FAC0, a2, 0);
      if ( c == 47 )
        break;
      c = *a2++;
      if ( c == 92 )
        c = 47;
    }
  }
  while ( c );
  result = a1;
  *a1 = 0;
  return result;
}
// 8079B84: using guessed type char *arg_4;

//----- (08079C2A) --------------------------------------------------------
int __cdecl sub_8079C2A(char *a1)
{
  char s[1032]; // [esp+10h] [ebp-408h] BYREF

  sub_8079B84(s, a1, 1024);
  return SL_GetString(s, 0);
}

//----- (08079C70) --------------------------------------------------------
size_t __cdecl I_strlen(char *s)
{
  return strlen(s);
}

//----- (08079C84) --------------------------------------------------------
void TempMemoryReset()
{
  dword_8293F84 = 0;
}
// 8293F84: using guessed type int dword_8293F84;

//----- (08079C94) --------------------------------------------------------
unsigned int __cdecl TempMalloc(int a1)
{
  int v2; // [esp+10h] [ebp-8h]
  unsigned int v3; // [esp+14h] [ebp-4h]

  v2 = dword_8293F84 + a1;
  v3 = dword_8293F84 + Hunk_ReallocateTempMemoryInternal(dword_8293F84 + a1);
  dword_8293F84 = v2;
  return v3;
}
// 8293F84: using guessed type int dword_8293F84;

//----- (08079CC8) --------------------------------------------------------
unsigned int __cdecl TempMallocAlign(int a1)
{
  return TempMalloc(a1);
}

//----- (08079CDC) --------------------------------------------------------
unsigned int __cdecl TempMallocAlignStrict(int a1)
{
  return TempMalloc(a1);
}

//----- (08079CF0) --------------------------------------------------------
unsigned int __cdecl TempMemorySetPos(int a1)
{
  dword_8293F84 -= TempMalloc(0) - a1;
  return Hunk_ReallocateTempMemoryInternal(dword_8293F84);
}
// 8293F84: using guessed type int dword_8293F84;

//----- (08079D48) --------------------------------------------------------
_BOOL4 __cdecl sub_8079D48(int a1)
{
  return GetVarType(a1) > 14;
}

//----- (08079D6E) --------------------------------------------------------
int __cdecl ThreadInfoCompare(_DWORD *a1, _DWORD *a2)
{
  int v4; // [esp+4h] [ebp-Ch]
  int v5; // [esp+8h] [ebp-8h]
  int i; // [esp+Ch] [ebp-4h]

  for ( i = 0; ; ++i )
  {
    if ( i >= a1[32] || i >= a2[32] )
      return a1[32] - a2[32];
    v5 = a1[i];
    v4 = a2[i];
    if ( v5 != v4 )
      break;
  }
  return v5 - v4;
}

//----- (08079DEE) --------------------------------------------------------
void Scr_DumpScriptThreads()
{
  float *v0; // ebx
  long double v1; // fst7
  int v2; // [esp+18h] [ebp-E0h]
  char v3; // [esp+1Fh] [ebp-D9h]
  _BYTE *v4; // [esp+20h] [ebp-D8h]
  _DWORD *v5; // [esp+20h] [ebp-D8h]
  int v6; // [esp+24h] [ebp-D4h]
  int v7; // [esp+28h] [ebp-D0h]
  int v8; // [esp+2Ch] [ebp-CCh]
  int v9[32]; // [esp+30h] [ebp-C8h]
  int v10; // [esp+B0h] [ebp-48h]
  float v11; // [esp+B4h] [ebp-44h]
  float v12; // [esp+B8h] [ebp-40h]
  int m; // [esp+C8h] [ebp-30h]
  unsigned int k; // [esp+CCh] [ebp-2Ch]
  char v15[4]; // [esp+D0h] [ebp-28h]
  int j; // [esp+D4h] [ebp-24h]
  int v17; // [esp+D8h] [ebp-20h]
  void *v18; // [esp+DCh] [ebp-1Ch]
  size_t nmemb; // [esp+E0h] [ebp-18h]
  void *base; // [esp+E4h] [ebp-14h]
  __int16 *v21; // [esp+E8h] [ebp-10h]
  unsigned int i; // [esp+ECh] [ebp-Ch]

  base = Z_TryMallocInternal(0x8BFEE8u);
  if ( base )
  {
    nmemb = 0;
    for ( i = 1; i <= 0xFFFD; ++i )
    {
      v21 = &word_8294000[8 * i];
      if ( (*((_DWORD *)v21 + 2) & 0x60) != 0 && (*((_DWORD *)v21 + 2) & 0x1F) == 10 )
      {
        v18 = (char *)base + 140 * nmemb++;
        v10 = 0;
        v8 = *((_DWORD *)v21 + 1);
        v7 = *(unsigned __int16 *)(v8 + 4);
        v6 = *(_DWORD *)v8;
        v4 = (_BYTE *)(v8 + 11);
        while ( v7 )
        {
          --v7;
          v3 = *v4;
          v5 = v4 + 1;
          v2 = *v5;
          v4 = v5 + 1;
          if ( v3 == 7 )
            v9[v10++] = v2;
        }
        v9[v10++] = v6;
        v0 = (float *)v18;
        v0[33] = Scr_GetThreadUsage(v8, (float *)v18 + 34);
        *((_DWORD *)v18 + 32) = v10--;
        for ( j = 0; j < *((_DWORD *)v18 + 32); ++j )
          *((_DWORD *)v18 + j) = v9[v10 - j];
      }
    }
    qsort(base, nmemb, 0x8Cu, (__compar_fn_t)ThreadInfoCompare);
    Com_Printf("********************************\n");
    v17 = 0;
    while ( v17 < (int)nmemb )
    {
      v18 = (char *)base + 140 * v17;
      *(_DWORD *)v15 = 0;
      v11 = 0.0;
      v12 = 0.0;
      do
      {
        ++*(_DWORD *)v15;
        v11 = v11 + *((float *)base + 35 * v17 + 33);
        v12 = v12 + *((float *)base + 35 * v17++ + 34);
      }
      while ( v17 < (int)nmemb && !ThreadInfoCompare(v18, (_DWORD *)base + 35 * v17) );
      Com_Printf("count: %d, var usage: %d, endon usage: %d\n", *(_DWORD *)v15, (int)v11, (int)v12);
      Scr_PrintPrevCodePos(0, *(const char **)v18, 0);
      for ( j = 1; j < *((_DWORD *)v18 + 32); ++j )
      {
        Com_Printf("called from:\n");
        Scr_PrintPrevCodePos(0, *((const char **)v18 + j), 0);
      }
    }
    Z_FreeInternal(base);
    Com_Printf("********************************\n");
    for ( k = 0; k <= 3; ++k )
    {
      if ( word_815AB82[6 * k] )
      {
        v11 = 0.0;
        *(_DWORD *)v15 = 0;
        for ( m = sub_807C9CE((unsigned __int16)word_815AB82[6 * k]); m; m = sub_807C9CE(m) )
        {
          ++*(_DWORD *)v15;
          if ( (dword_8294008[4 * m] & 0x1F) == 1 )
          {
            v1 = Scr_GetObjectUsage(dword_8294004[4 * m]);
            v11 = v1 + v11;
          }
        }
        Com_Printf("ent type '%s'... count: %d, var usage: %d\n", (&off_815AB88)[3 * k], *(_DWORD *)v15, (int)v11);
      }
    }
    Com_Printf("********************************\n");
  }
  else
  {
    Com_Printf("Cannot dump script threads: out of memory\n");
  }
}
// 815AB82: using guessed type __int16 word_815AB82[];
// 815AB88: using guessed type char *off_815AB88;
// 8294000: using guessed type __int16 word_8294000[];
// 8294004: using guessed type int dword_8294004[];
// 8294008: using guessed type int dword_8294008[];
// 8079DEE: using guessed type int var_C8[32];

//----- (0807A298) --------------------------------------------------------
void Scr_DumpScriptVariablesDefault()
{
  ;
}

//----- (0807A29E) --------------------------------------------------------
int sub_807A29E()
{
  int result; // eax
  unsigned __int16 v1; // [esp+6h] [ebp-Ah]
  __int16 *v2; // [esp+8h] [ebp-8h]
  unsigned int i; // [esp+Ch] [ebp-4h]

  v1 = 0;
  for ( i = 1; i <= 0xFFFD; ++i )
  {
    v2 = &word_8294000[8 * i];
    *((_DWORD *)v2 + 2) = 0;
    *v2 = i;
    v2[6] = i;
    LOWORD(dword_8294004[4 * v1]) = i;
    v2[1] = v1;
    v1 = i;
  }
  *(_DWORD *)&word_8294000[4] = 0;
  *(_DWORD *)&word_8294000[4] = *(_DWORD *)&word_8294000[4];
  word_8294000[0] = 0;
  word_8294000[6] = 0;
  LOWORD(dword_8294004[4 * v1]) = 0;
  result = v1;
  word_8294000[1] = v1;
  return result;
}
// 8294000: using guessed type __int16 word_8294000[];
// 8294004: using guessed type int dword_8294004[];

//----- (0807A368) --------------------------------------------------------
int *sub_807A368()
{
  int *result; // eax
  int i; // [esp+4h] [ebp-4h] BYREF

  result = (int *)sub_807A29E();
  for ( i = 0; i <= 3; ++i )
  {
    word_815AB82[6 * i] = 0;
    word_815AB80[6 * i] = 0;
    result = &i;
  }
  return result;
}
// 815AB80: using guessed type __int16 word_815AB80[];
// 815AB82: using guessed type __int16 word_815AB82[];

//----- (0807A3B6) --------------------------------------------------------
int sub_807A3B6()
{
  int result; // eax

  if ( dword_8394028 )
  {
    result = sub_807B778(dword_8394028);
    dword_8394028 = 0;
  }
  return result;
}
// 8394028: using guessed type int dword_8394028;

//----- (0807A3E8) --------------------------------------------------------
unsigned int __cdecl sub_807A3E8(int a1)
{
  return ((unsigned int)dword_8294008[4 * a1] >> 8) - 0x10000;
}
// 8294008: using guessed type int dword_8294008[];

//----- (0807A402) --------------------------------------------------------
int __cdecl sub_807A402(int a1, int a2)
{
  __int16 *v4; // [esp+4h] [ebp-14h]
  int v5; // [esp+8h] [ebp-10h]
  __int16 *i; // [esp+Ch] [ebp-Ch]
  __int16 *v7; // [esp+14h] [ebp-4h]

  v7 = &word_8294000[8 * (unsigned __int16)word_8294000[8 * a2]];
  if ( (*((_DWORD *)v7 + 2) & 0x60) != 64 )
    return 0;
  if ( *((_DWORD *)v7 + 2) >> 8 != a1 )
  {
    v5 = (unsigned __int16)v7[6];
    for ( i = &word_8294000[8 * v5]; i != &word_8294000[8 * a2]; i = &word_8294000[8 * v5] )
    {
      v4 = &word_8294000[8 * (unsigned __int16)*i];
      if ( *((_DWORD *)v4 + 2) >> 8 == a1 )
        return v5;
      v5 = (unsigned __int16)v4[6];
    }
    return 0;
  }
  return a2;
}
// 8294000: using guessed type __int16 word_8294000[];

//----- (0807A4D2) --------------------------------------------------------
int __cdecl sub_807A4D2(int a1, int a2)
{
  return sub_807A402(a2, (unsigned __int16)((a1 + a2) % 0xFFFDu + 1));
}

//----- (0807A514) --------------------------------------------------------
int __cdecl sub_807A514(int a1, unsigned int a2, int a3)
{
  int v4[3]; // [esp+10h] [ebp-38h] BYREF
  int v5; // [esp+1Ch] [ebp-2Ch]
  int v6[2]; // [esp+20h] [ebp-28h] BYREF
  __int16 *v7; // [esp+28h] [ebp-20h]
  __int16 *v8; // [esp+2Ch] [ebp-1Ch]
  unsigned __int16 v9; // [esp+30h] [ebp-18h]
  __int16 v10; // [esp+32h] [ebp-16h]
  __int16 *v11; // [esp+34h] [ebp-14h]
  unsigned __int16 i; // [esp+38h] [ebp-10h]
  unsigned __int16 v13; // [esp+3Ah] [ebp-Eh]
  unsigned __int16 v14; // [esp+3Ch] [ebp-Ch]
  unsigned __int16 v15; // [esp+3Eh] [ebp-Ah]
  __int16 *v16; // [esp+40h] [ebp-8h]
  __int16 *v17; // [esp+44h] [ebp-4h]

  v16 = &word_8294000[8 * a3];
  v17 = &word_8294000[8 * (unsigned __int16)*v16];
  v5 = *((_DWORD *)v17 + 2) & 0x60;
  if ( v5 )
  {
    if ( v5 == 64 )
    {
      if ( (*((_DWORD *)v16 + 2) & 0x60) != 0 )
      {
        a3 = LOWORD(dword_8294004[0]);
        if ( !LOWORD(dword_8294004[0]) )
          sub_8084DF0((int)"exceeded maximum number of script variables");
        v16 = &word_8294000[8 * a3];
        v8 = &word_8294000[8 * (unsigned __int16)*v16];
        v13 = v8[2];
        LOWORD(dword_8294004[0]) = v13;
        word_8294002[8 * v13] = 0;
        *((_DWORD *)v8 + 2) = 32;
        v8[6] = v17[6];
        v17[6] = a3;
      }
      else
      {
        v9 = v16[6];
        v11 = &word_8294000[8 * v9];
        v8 = v16;
        v14 = v11[1];
        v13 = v16[2];
        LOWORD(dword_8294004[4 * (unsigned __int16)word_8294000[8 * v14]]) = v13;
        word_8294002[8 * v13] = v14;
        *v11 = *v16;
        *v16 = a3;
        v11[1] = v16[1];
        word_829400E[8 * (unsigned __int16)word_8294000[8 * (unsigned __int16)v11[1]]] = v9;
        word_8294002[8 * (unsigned __int16)v17[7]] = v9;
        *((_DWORD *)v17 + 2) &= 0xFFFFFF9F;
        *((_DWORD *)v17 + 2) |= 0x20u;
        *((_DWORD *)v8 + 2) = 64;
      }
    }
    else
    {
      if ( (*((_DWORD *)v16 + 2) & 0x60) != 0 )
      {
        v9 = dword_8294004[0];
        if ( !LOWORD(dword_8294004[0]) )
          sub_8084DF0((int)"exceeded maximum number of script variables");
        v11 = &word_8294000[8 * v9];
        v8 = &word_8294000[8 * (unsigned __int16)*v11];
        v13 = v8[2];
        LOWORD(dword_8294004[0]) = v13;
        word_8294002[8 * v13] = 0;
      }
      else
      {
        v9 = v16[6];
        v11 = &word_8294000[8 * v9];
        v8 = v16;
        v14 = v11[1];
        v13 = v16[2];
        LOWORD(dword_8294004[4 * (unsigned __int16)word_8294000[8 * v14]]) = v13;
        word_8294002[8 * v13] = v14;
      }
      v15 = v17[7];
      word_829400E[8 * (unsigned __int16)word_8294000[8 * (unsigned __int16)v16[1]]] = v9;
      word_8294002[8 * v15] = v9;
      if ( v5 == 32 )
      {
        v15 = v17[6];
        for ( i = word_8294000[8 * v15];
              (unsigned __int16)word_829400C[8 * i] != a3;
              i = word_8294000[8 * (unsigned __int16)word_829400C[8 * i]] )
        {
          ;
        }
        word_829400C[8 * i] = v9;
      }
      else
      {
        v17[6] = v9;
      }
      v11[1] = v16[1];
      v10 = *v11;
      *v11 = *v16;
      *v16 = v10;
      *((_DWORD *)v8 + 2) = 64;
      v8[6] = a3;
    }
  }
  else
  {
    v9 = v16[6];
    v13 = v17[2];
    if ( v9 == *v16 || (*((_DWORD *)v16 + 2) & 0x60) != 0 )
    {
      v8 = v17;
    }
    else
    {
      word_8294000[8 * v9] = *v16;
      *v16 = a3;
      v17[6] = v9;
      v17[2] = v16[2];
      v8 = v16;
    }
    v14 = v16[1];
    LOWORD(dword_8294004[4 * (unsigned __int16)word_8294000[8 * v14]]) = v13;
    word_8294002[8 * v13] = v14;
    *((_DWORD *)v8 + 2) = 64;
    v8[6] = a3;
  }
  *((_DWORD *)v8 + 2) = *((unsigned __int8 *)v8 + 8);
  *((_DWORD *)v8 + 2) |= a2 << 8;
  v7 = &word_8294000[8 * a1];
  if ( (*((_DWORD *)v7 + 2) & 0x1F) == 22 )
  {
    ++v7[3];
    sub_807BF2C(v4, a2);
    v6[0] = v4[0];
    v6[1] = v4[1];
    sub_807578C(v6);
  }
  return a3;
}
// 8294000: using guessed type __int16 word_8294000[];
// 8294002: using guessed type __int16 word_8294002[];
// 8294004: using guessed type int dword_8294004[];
// 829400C: using guessed type __int16 word_829400C[];
// 829400E: using guessed type __int16 word_829400E[524281];

//----- (0807AA14) --------------------------------------------------------
int __cdecl sub_807AA14(int a1, unsigned int a2, int a3)
{
  int result; // eax
  __int16 *v4; // [esp+14h] [ebp-14h]
  unsigned __int16 v5; // [esp+1Eh] [ebp-Ah]

  result = sub_807A514(a1, a2, a3);
  v4 = &word_8294000[8 * a1];
  v5 = v4[7];
  word_8294000[8 * (unsigned __int16)word_8294000[8 * result] + 7] = v5;
  word_8294000[8 * v5 + 1] = result;
  word_8294000[8 * result + 1] = v4[6];
  v4[7] = result;
  return result;
}
// 8294000: using guessed type __int16 word_8294000[];

//----- (0807AAC0) --------------------------------------------------------
int __cdecl sub_807AAC0(int a1, unsigned int a2, int a3)
{
  int result; // eax
  __int16 *v4; // [esp+10h] [ebp-18h]
  __int16 *v5; // [esp+18h] [ebp-10h]
  unsigned __int16 v6; // [esp+1Eh] [ebp-Ah]

  result = sub_807A514(a1, a2, a3);
  v4 = &word_8294000[8 * (unsigned __int16)word_8294002[8 * (unsigned __int16)word_8294000[8 * a1 + 7]]];
  v6 = v4[1];
  v5 = &word_8294000[8 * (unsigned __int16)word_8294000[8 * v6]];
  word_8294000[8 * (unsigned __int16)word_8294000[8 * result] + 7] = word_8294000[8 * a1 + 6];
  v4[1] = result;
  word_8294000[8 * result + 1] = v6;
  v5[7] = result;
  return result;
}
// 8294000: using guessed type __int16 word_8294000[];
// 8294002: using guessed type __int16 word_8294002[];

//----- (0807AB96) --------------------------------------------------------
int __cdecl sub_807AB96(int a1, unsigned int a2)
{
  return sub_807AA14(a1, a2, (a1 + a2) % 0xFFFD + 1);
}

//----- (0807ABDE) --------------------------------------------------------
int __cdecl sub_807ABDE(int a1, unsigned int a2)
{
  return sub_807AAC0(a1, a2, (a1 + a2) % 0xFFFD + 1);
}

//----- (0807AC26) --------------------------------------------------------
int __cdecl sub_807AC26(int a1, unsigned int a2)
{
  int v3; // [esp+Ch] [ebp-Ch]

  v3 = sub_807A402(a2, (a1 + a2) % 0xFFFD + 1);
  if ( !v3 )
    return sub_807AA14(a1, a2, (a1 + a2) % 0xFFFD + 1);
  return v3;
}

//----- (0807AC94) --------------------------------------------------------
int __cdecl sub_807AC94(__int16 *a1, int a2)
{
  int result; // eax
  int v3[2]; // [esp+8h] [ebp-40h] BYREF
  int v4[2]; // [esp+10h] [ebp-38h] BYREF
  unsigned int v5; // [esp+18h] [ebp-30h]
  int v6; // [esp+1Ch] [ebp-2Ch]
  int v7; // [esp+20h] [ebp-28h]
  int v8; // [esp+24h] [ebp-24h]
  int v9; // [esp+28h] [ebp-20h]
  int v10; // [esp+2Ch] [ebp-1Ch]
  __int16 *v11; // [esp+30h] [ebp-18h]
  __int16 *v12; // [esp+34h] [ebp-14h]
  int v13; // [esp+38h] [ebp-10h]
  __int16 *v14; // [esp+3Ch] [ebp-Ch]
  __int16 *v15; // [esp+40h] [ebp-8h]
  int v16; // [esp+44h] [ebp-4h]

  v13 = ((char *)a1 - (char *)word_8294000) >> 4;
  v12 = &word_8294000[8 * (unsigned __int16)*a1];
  if ( (*(_DWORD *)(a2 + 8) & 0x1F) == 22 )
  {
    --*(_WORD *)(a2 + 6);
    v5 = *((_DWORD *)v12 + 2) >> 8;
    sub_807BF2C(v3, v5);
    v4[0] = v3[0];
    v4[1] = v3[1];
    RemoveRefToValue(v4);
  }
  if ( (*((_DWORD *)v12 + 2) & 0x60) == 64 )
  {
    v16 = (unsigned __int16)v12[6];
    v15 = &word_8294000[8 * v16];
    v11 = &word_8294000[8 * (unsigned __int16)*v15];
    if ( v15 != a1 )
    {
      *((_DWORD *)v11 + 2) &= 0xFFFFFF9F;
      *((_DWORD *)v11 + 2) |= 0x40u;
      v9 = (unsigned __int16)a1[1];
      v8 = (unsigned __int16)v12[7];
      v7 = (unsigned __int16)v15[1];
      v6 = (unsigned __int16)v11[7];
      word_8294002[8 * v6] = v13;
      word_829400E[8 * (unsigned __int16)word_8294000[8 * v7]] = v13;
      word_8294002[8 * v8] = v16;
      word_829400E[8 * (unsigned __int16)word_8294000[8 * v9]] = v16;
      v10 = *(_DWORD *)a1;
      *(_DWORD *)a1 = *(_DWORD *)v15;
      *(_DWORD *)v15 = v10;
      v13 = v16;
    }
  }
  else
  {
    v15 = a1;
    v11 = v12;
    do
    {
      v14 = v15;
      v16 = (unsigned __int16)v11[6];
      v15 = &word_8294000[8 * v16];
      v11 = &word_8294000[8 * (unsigned __int16)*v15];
    }
    while ( v15 != a1 );
    word_829400C[8 * (unsigned __int16)*v14] = v12[6];
  }
  *((_DWORD *)v12 + 2) &= 0xFFFFFF9F;
  *((_DWORD *)v12 + 2) |= 0x60u;
  result = v13;
  v12[6] = v13;
  return result;
}
// 8294000: using guessed type __int16 word_8294000[];
// 8294002: using guessed type __int16 word_8294002[];
// 829400C: using guessed type __int16 word_829400C[];
// 829400E: using guessed type __int16 word_829400E[524281];

//----- (0807AEBA) --------------------------------------------------------
int __cdecl sub_807AEBA(int a1)
{
  int result; // eax
  int v2; // [esp+8h] [ebp-10h]
  int i; // [esp+Ch] [ebp-Ch]
  int v4; // [esp+Ch] [ebp-Ch]
  __int16 *v5; // [esp+10h] [ebp-8h]
  __int16 *v6; // [esp+14h] [ebp-4h]

  v5 = &word_8294000[8 * a1];
  v6 = &word_8294000[8 * (unsigned __int16)v5[7]];
  for ( i = (unsigned __int16)*v6; i != a1; i = (unsigned __int16)*v6 )
  {
    sub_807AC94(v6, (int)v5);
    v6 = &word_8294000[8 * (unsigned __int16)word_829400E[8 * i]];
  }
  v4 = (unsigned __int16)word_8294000[8 * (unsigned __int16)v5[7]];
  while ( 1 )
  {
    result = v4;
    if ( v4 == a1 )
      break;
    v2 = v4;
    v4 = (unsigned __int16)word_8294000[8 * (unsigned __int16)word_829400E[8 * v4]];
    sub_807B778(v2);
  }
  return result;
}
// 807B778: using guessed type _DWORD __cdecl sub_807B778(_DWORD);
// 8294000: using guessed type __int16 word_8294000[];
// 829400E: using guessed type __int16 word_829400E[524281];

//----- (0807AF82) --------------------------------------------------------
int __cdecl sub_807AF82(int a1)
{
  AddRefToObject(a1);
  sub_807AEBA(a1);
  return sub_807B8D4(a1);
}

//----- (0807AFAC) --------------------------------------------------------
int __cdecl sub_807AFAC(int a1, int a2)
{
  int result; // eax
  __int16 *v3; // [esp+0h] [ebp-4h]

  v3 = &word_8294000[8 * a1];
  *((_DWORD *)v3 + 2) &= 0xFFFFFFE0;
  *((_DWORD *)v3 + 2) = *((unsigned __int8 *)v3 + 8);
  *((_DWORD *)v3 + 2) |= 0x10u;
  result = *((_DWORD *)v3 + 2) | (a2 << 8);
  *((_DWORD *)v3 + 2) = result;
  return result;
}
// 8294000: using guessed type __int16 word_8294000[];

//----- (0807B004) --------------------------------------------------------
int __cdecl sub_807B004(int a1)
{
  if ( (unsigned __int16)word_8294000[8 * (unsigned __int16)word_8294000[8 * a1 + 7]] != a1 )
    sub_807AEBA(a1);
  return RemoveRefToObject((unsigned __int16)word_8294000[8 * a1 + 3]);
}
// 8294000: using guessed type __int16 word_8294000[];

//----- (0807B04E) --------------------------------------------------------
int __cdecl sub_807B04E(int a1)
{
  sub_807B004(a1);
  HIWORD(dword_8294004[4 * a1]) = dword_8394024;
  return AddRefToObject(dword_8394024);
}
// 8294004: using guessed type int dword_8294004[];
// 8394024: using guessed type int dword_8394024;

//----- (0807B084) --------------------------------------------------------
int __cdecl sub_807B084(int a1)
{
  int result; // eax
  __int16 *v2; // [esp+10h] [ebp-8h]
  unsigned __int16 v3; // [esp+16h] [ebp-2h]

  v2 = &word_8294000[8 * a1];
  v3 = sub_807B110(a1);
  SL_RemoveRefToString(v3);
  *((_DWORD *)v2 + 2) &= 0xFFFFFFE0;
  result = *((_DWORD *)v2 + 2) | 0xF;
  *((_DWORD *)v2 + 2) = result;
  return result;
}
// 8294000: using guessed type __int16 word_8294000[];

//----- (0807B110) --------------------------------------------------------
int __cdecl sub_807B110(int a1)
{
  return (unsigned __int16)((unsigned int)dword_8294008[4 * a1] >> 8);
}
// 8294008: using guessed type int dword_8294008[];

//----- (0807B128) --------------------------------------------------------
int __cdecl sub_807B128(int a1, int a2)
{
  int result; // eax
  __int16 *v3; // [esp+0h] [ebp-4h]

  v3 = &word_8294000[8 * a1];
  *((_DWORD *)v3 + 2) &= 0xFFFFFFE0;
  *((_DWORD *)v3 + 2) = *((unsigned __int8 *)v3 + 8);
  *((_DWORD *)v3 + 2) |= 0x11u;
  result = dword_8294008[4 * a1] | (a2 << 8);
  dword_8294008[4 * a1] = result;
  return result;
}
// 8294000: using guessed type __int16 word_8294000[];
// 8294008: using guessed type int dword_8294008[];

//----- (0807B190) --------------------------------------------------------
int __cdecl sub_807B190(int a1)
{
  __int16 *v1; // edx
  int result; // eax

  *(_DWORD *)&word_8294000[8 * a1 + 4] &= 0xFFFFFFE0;
  v1 = &word_8294000[8 * a1];
  result = *((_DWORD *)v1 + 2) | 0xF;
  *((_DWORD *)v1 + 2) = result;
  return result;
}
// 8294000: using guessed type __int16 word_8294000[];

//----- (0807B1C8) --------------------------------------------------------
unsigned int __cdecl sub_807B1C8(int a1)
{
  return (unsigned int)dword_8294008[4 * a1] >> 8;
}
// 8294008: using guessed type int dword_8294008[];

//----- (0807B1DC) --------------------------------------------------------
unsigned int __cdecl GetParentLocalId(int a1)
{
  return (unsigned int)dword_8294008[4 * a1] >> 8;
}
// 8294008: using guessed type int dword_8294008[];

//----- (0807B1F0) --------------------------------------------------------
unsigned int __cdecl sub_807B1F0(int a1)
{
  if ( (dword_8294008[4 * a1] & 0x1F) == 18 )
    return (unsigned int)dword_8294008[4 * a1] >> 8;
  else
    return 0;
}
// 8294008: using guessed type int dword_8294008[];

//----- (0807B22A) --------------------------------------------------------
unsigned int __cdecl sub_807B22A(unsigned int a1)
{
  while ( (dword_8294008[4 * a1] & 0x1F) == 18 )
    a1 = (unsigned int)dword_8294008[4 * a1] >> 8;
  return a1;
}
// 8294008: using guessed type int dword_8294008[];

//----- (0807B25E) --------------------------------------------------------
int __cdecl sub_807B25E(int a1)
{
  int v1; // eax
  __int16 *v2; // eax
  int result; // eax
  int v4; // [esp+10h] [ebp-18h]
  int v5; // [esp+14h] [ebp-14h]
  int i; // [esp+18h] [ebp-10h]
  int v7; // [esp+1Ch] [ebp-Ch]
  __int16 *v8; // [esp+24h] [ebp-4h]

  v8 = &word_8294000[8 * a1];
  sub_807B004(a1);
  v7 = sub_807BB58(dword_8394020, a1);
  if ( v7 )
  {
    for ( i = sub_807CB1E(v7); ; sub_807C228(i, v4) )
    {
      v5 = sub_807C9CE(i);
      if ( !v5 )
        break;
      v4 = (unsigned __int16)((unsigned int)dword_8294008[4 * v5] >> 8);
      v1 = sub_807BB58(i, v4);
      v2 = sub_807C4FC(v1);
      sub_80823CE(*(_DWORD *)v2, v4);
      sub_807B360(v4);
    }
    sub_807C228(dword_8394020, a1);
  }
  *((_DWORD *)v8 + 2) &= 0xFFFFFFE0;
  result = *((_DWORD *)v8 + 2) | 0x17;
  *((_DWORD *)v8 + 2) = result;
  return result;
}
// 8294000: using guessed type __int16 word_8294000[];
// 8294008: using guessed type int dword_8294008[];
// 8394020: using guessed type int dword_8394020;

//----- (0807B360) --------------------------------------------------------
int __cdecl sub_807B360(int a1)
{
  int result; // eax
  __int16 *v2; // [esp+4h] [ebp-4h]

  v2 = &word_8294000[8 * a1];
  RemoveRefToObject((unsigned __int16)v2[3]);
  *((_DWORD *)v2 + 2) &= 0xFFFFFFE0;
  result = *((_DWORD *)v2 + 2) | 0x17;
  *((_DWORD *)v2 + 2) = result;
  return result;
}
// 8294000: using guessed type __int16 word_8294000[];

//----- (0807B3A8) --------------------------------------------------------
int sub_807B3A8()
{
  unsigned __int16 v1; // [esp+8h] [ebp-10h]
  unsigned __int16 v2; // [esp+Ah] [ebp-Eh]
  __int16 *v3; // [esp+Ch] [ebp-Ch]
  __int16 *v4; // [esp+10h] [ebp-8h]
  unsigned __int16 v5; // [esp+16h] [ebp-2h]

  v5 = dword_8294004[0];
  if ( !LOWORD(dword_8294004[0]) )
    sub_8084DF0((int)"exceeded maximum number of script variables");
  v4 = &word_8294000[8 * v5];
  v3 = &word_8294000[8 * (unsigned __int16)*v4];
  v2 = v3[2];
  if ( v4 != v3 && (*((_DWORD *)v4 + 2) & 0x60) == 0 )
  {
    v1 = v4[6];
    word_8294000[8 * v1] = *v4;
    *v4 = v5;
    v3[6] = v1;
    v3[2] = v4[2];
    v3 = &word_8294000[8 * v5];
  }
  LOWORD(dword_8294004[0]) = v2;
  word_8294002[8 * v2] = 0;
  v3[6] = v5;
  v3[7] = v5;
  v4[1] = v5;
  return (unsigned __int16)*v4;
}
// 8294000: using guessed type __int16 word_8294000[];
// 8294002: using guessed type __int16 word_8294002[];
// 8294004: using guessed type int dword_8294004[];

//----- (0807B4A0) --------------------------------------------------------
int __cdecl sub_807B4A0(int a1)
{
  int result; // eax
  unsigned __int16 v2; // [esp+2h] [ebp-Eh]
  unsigned __int16 v3; // [esp+4h] [ebp-Ch]
  unsigned __int16 v4; // [esp+6h] [ebp-Ah]
  __int16 *v5; // [esp+8h] [ebp-8h]

  v5 = &word_8294000[8 * a1];
  v2 = v5[6];
  v4 = word_8294000[8 * v2 + 1];
  v3 = v5[7];
  word_8294002[8 * v3] = v4;
  word_829400E[8 * (unsigned __int16)word_8294000[8 * v4]] = v3;
  *((_DWORD *)v5 + 2) = 0;
  v5[2] = dword_8294004[0];
  word_8294000[8 * v2 + 1] = 0;
  word_8294002[8 * LOWORD(dword_8294004[0])] = v2;
  result = v2;
  LOWORD(dword_8294004[0]) = v2;
  return result;
}
// 8294000: using guessed type __int16 word_8294000[];
// 8294002: using guessed type __int16 word_8294002[];
// 8294004: using guessed type int dword_8294004[];
// 829400E: using guessed type __int16 word_829400E[524281];

//----- (0807B562) --------------------------------------------------------
int sub_807B562()
{
  int v0; // edx
  int result; // eax

  LOWORD(result) = sub_807B3A8();
  v0 = 8 * (unsigned __int16)result;
  *(_DWORD *)&word_8294000[v0 + 4] = 96;
  *(_DWORD *)&word_8294000[v0 + 4] = *(_DWORD *)&word_8294000[v0 + 4];
  return (unsigned __int16)result;
}
// 8294000: using guessed type __int16 word_8294000[];

//----- (0807B5A0) --------------------------------------------------------
int sub_807B5A0()
{
  __int16 *v0; // edx
  int result; // eax

  LOWORD(result) = sub_807B3A8();
  *(_DWORD *)&word_8294000[8 * (unsigned __int16)result + 4] = 96;
  v0 = &word_8294000[8 * (unsigned __int16)result];
  *((_DWORD *)v0 + 2) |= 0x13u;
  v0[2] = 0;
  return (unsigned __int16)result;
}
// 8294000: using guessed type __int16 word_8294000[];

//----- (0807B5EA) --------------------------------------------------------
int __cdecl sub_807B5EA(int a1, __int16 a2)
{
  int result; // eax
  __int16 *v3; // [esp+Ch] [ebp-Ch]

  LOWORD(result) = sub_807B3A8();
  v3 = &word_8294000[8 * (unsigned __int16)result];
  *((_DWORD *)v3 + 2) = 96;
  *((_DWORD *)v3 + 2) |= 0x15u;
  *((_DWORD *)v3 + 2) |= a1 << 8;
  v3[2] = 0;
  v3[3] = a2;
  return (unsigned __int16)result;
}
// 8294000: using guessed type __int16 word_8294000[];

//----- (0807B658) --------------------------------------------------------
int sub_807B658()
{
  __int16 *v0; // edx
  int result; // eax

  LOWORD(result) = sub_807B3A8();
  *(_DWORD *)&word_8294000[8 * (unsigned __int16)result + 4] = 96;
  v0 = &word_8294000[8 * (unsigned __int16)result];
  *((_DWORD *)v0 + 2) |= 0x16u;
  v0[2] = 0;
  v0[3] = 0;
  return (unsigned __int16)result;
}
// 8294000: using guessed type __int16 word_8294000[];

//----- (0807B6AC) --------------------------------------------------------
int __cdecl AllocThread(__int16 a1)
{
  int result; // eax
  __int16 *v2; // [esp+0h] [ebp-8h]

  LOWORD(result) = sub_807B3A8();
  v2 = &word_8294000[8 * (unsigned __int16)result];
  *((_DWORD *)v2 + 2) = 96;
  *((_DWORD *)v2 + 2) |= 0xFu;
  v2[2] = 0;
  v2[3] = a1;
  return (unsigned __int16)result;
}
// 8294000: using guessed type __int16 word_8294000[];

//----- (0807B700) --------------------------------------------------------
int __cdecl sub_807B700(__int16 a1, int a2)
{
  int result; // eax
  __int16 *v3; // [esp+0h] [ebp-8h]

  LOWORD(result) = sub_807B3A8();
  v3 = &word_8294000[8 * (unsigned __int16)result];
  *((_DWORD *)v3 + 2) = 96;
  *((_DWORD *)v3 + 2) |= 0x12u;
  *((_DWORD *)v3 + 2) |= a2 << 8;
  v3[2] = 0;
  v3[3] = a1;
  return (unsigned __int16)result;
}
// 8294000: using guessed type __int16 word_8294000[];

//----- (0807B766) --------------------------------------------------------
int __cdecl sub_807B766(int a1)
{
  return HIWORD(dword_8294004[4 * a1]);
}
// 8294004: using guessed type int dword_8294004[];

//----- (0807B778) --------------------------------------------------------
int __cdecl sub_807B778(int a1)
{
  RemoveRefToValueInternal(*(_DWORD *)&word_8294000[8 * a1 + 4] & 0x1F, *(_DWORD *)&word_8294000[8 * a1 + 2]);
  return sub_807B4A0(a1);
}
// 8294000: using guessed type __int16 word_8294000[];

//----- (0807B7BA) --------------------------------------------------------
int __cdecl AddRefToObject(int a1)
{
  int result; // eax

  result = LOWORD(dword_8294004[4 * a1]) + 1;
  LOWORD(dword_8294004[4 * a1]) = result;
  return result;
}
// 8294004: using guessed type int dword_8294004[];

//----- (0807B7DC) --------------------------------------------------------
int __cdecl RemoveRefToObject(int a1)
{
  int result; // eax
  __int16 *v2; // [esp+14h] [ebp-4h]

  v2 = &word_8294000[8 * a1];
  if ( v2[2] )
  {
    --v2[2];
    result = (int)&word_8294000[8 * a1];
    if ( !v2[2] )
    {
      result = *((_DWORD *)v2 + 2) & 0x1F;
      if ( result == 21 )
      {
        result = (unsigned __int16)word_8294000[8 * (unsigned __int16)v2[7]];
        if ( result == a1 )
        {
          *((_DWORD *)v2 + 2) &= 0xFFFFFFE0;
          *((_DWORD *)v2 + 2) |= 0x14u;
          return sub_807C26C((unsigned __int16)word_815AB82[6 * (*((_DWORD *)v2 + 2) >> 8)], (unsigned __int16)v2[3]);
        }
      }
    }
  }
  else
  {
    if ( (unsigned __int16)word_8294000[8 * (unsigned __int16)v2[7]] != a1 )
      sub_807AF82(a1);
    return sub_807B4A0(a1);
  }
  return result;
}
// 815AB82: using guessed type __int16 word_815AB82[];
// 8294000: using guessed type __int16 word_8294000[];

//----- (0807B8D4) --------------------------------------------------------
int __cdecl sub_807B8D4(int a1)
{
  int result; // eax
  __int16 *v2; // [esp+4h] [ebp-4h]

  v2 = &word_8294000[8 * a1];
  if ( !v2[2] )
    return sub_807B4A0(a1);
  result = (unsigned __int16)v2[2] - 1;
  v2[2] = result;
  return result;
}
// 8294000: using guessed type __int16 word_8294000[];

//----- (0807B936) --------------------------------------------------------
_DWORD *sub_807B936()
{
  _DWORD *v0; // eax

  v0 = (_DWORD *)sub_8076A2A(16);
  *v0 = 0;
  return v0 + 1;
}

//----- (0807B968) --------------------------------------------------------
_DWORD *__cdecl sub_807B968(_DWORD *a1)
{
  _DWORD *result; // eax

  result = sub_807B936();
  *result = *a1;
  result[1] = a1[1];
  result[2] = a1[2];
  return result;
}

//----- (0807B9A6) --------------------------------------------------------
int __cdecl sub_807B9A6(int a1)
{
  int result; // eax

  result = a1 - 1;
  if ( !*(_BYTE *)(a1 - 1) )
  {
    result = *(unsigned __int16 *)(a1 - 4) + 1;
    *(_WORD *)(a1 - 4) = result;
  }
  return result;
}

//----- (0807B9CA) --------------------------------------------------------
int __cdecl RemoveRefToVector(int a1)
{
  int result; // eax

  result = a1 - 1;
  if ( !*(_BYTE *)(a1 - 1) )
  {
    if ( *(_WORD *)(a1 - 4) )
    {
      result = *(unsigned __int16 *)(a1 - 4) - 1;
      *(_WORD *)(a1 - 4) = result;
    }
    else
    {
      return sub_8076A50(a1 - 4, 16);
    }
  }
  return result;
}

//----- (0807BA14) --------------------------------------------------------
int __cdecl sub_807BA14(int a1, int a2)
{
  int result; // eax

  result = a1;
  if ( a1 > 3 )
  {
    if ( a1 == 4 )
      return sub_807B9A6(a2);
  }
  else if ( a1 >= 2 )
  {
    return sub_807951E(a2);
  }
  else if ( a1 == 1 )
  {
    return AddRefToObject(a2);
  }
  return result;
}

//----- (0807BA64) --------------------------------------------------------
int __cdecl RemoveRefToValueInternal(int a1, int a2)
{
  int result; // eax

  result = a1;
  if ( a1 > 3 )
  {
    if ( a1 == 4 )
      return RemoveRefToVector(a2);
  }
  else if ( a1 >= 2 )
  {
    return SL_RemoveRefToString(a2);
  }
  else if ( a1 == 1 )
  {
    return RemoveRefToObject(a2);
  }
  return result;
}

//----- (0807BAB4) --------------------------------------------------------
_BOOL4 __cdecl IsValidArrayIndex(int a1)
{
  return (unsigned int)(a1 + 8257538) <= 0xFE0001;
}

//----- (0807BADA) --------------------------------------------------------
int __cdecl sub_807BADA(int a1)
{
  return (a1 + 0x800000) & 0xFFFFFF;
}

//----- (0807BAEC) --------------------------------------------------------
int __cdecl sub_807BAEC(int a1, int a2)
{
  return sub_807A4D2(a1, (a2 + 0x800000) & 0xFFFFFF);
}

//----- (0807BB10) --------------------------------------------------------
int __cdecl FindArrayVariable(int a1, int a2)
{
  return (unsigned __int16)word_8294000[8 * sub_807BAEC(a1, a2)];
}
// 8294000: using guessed type __int16 word_8294000[];

//----- (0807BB34) --------------------------------------------------------
int __cdecl FindVariable(int a1, int a2)
{
  return (unsigned __int16)word_8294000[8 * sub_807A4D2(a1, a2)];
}
// 8294000: using guessed type __int16 word_8294000[];

//----- (0807BB58) --------------------------------------------------------
int __cdecl sub_807BB58(int a1, int a2)
{
  return (unsigned __int16)word_8294000[8 * sub_807A4D2(a1, a2 + 0x10000)];
}
// 8294000: using guessed type __int16 word_8294000[];

//----- (0807BB82) --------------------------------------------------------
int __cdecl sub_807BB82(int a1, int a2)
{
  return sub_807AC26(a1, (a2 + 0x800000) & 0xFFFFFF);
}

//----- (0807BBA6) --------------------------------------------------------
int __cdecl sub_807BBA6(int a1, int a2)
{
  return sub_807AB96(a1, (a2 + 0x800000) & 0xFFFFFF);
}

//----- (0807BBCA) --------------------------------------------------------
int __cdecl sub_807BBCA(int a1, int a2)
{
  char *v2; // eax
  unsigned int v5; // [esp+Ch] [ebp-Ch]
  int v6; // [esp+14h] [ebp-4h]

  v5 = *(_DWORD *)&word_8294000[8 * a1 + 4] & 0x1F;
  if ( v5 <= 0x13 )
    return sub_807C0A8(a1, a2);
  if ( v5 == 21 )
  {
    v6 = FindVariable(a1, a2);
    if ( v6 )
    {
      return v6;
    }
    else
    {
      dword_8394040 = a1;
      dword_8394044 = a2;
      return 65534;
    }
  }
  else
  {
    v2 = va("cannot set field of %s", *(const char **)&off_815ABC0[4 * v5]);
    Scr_Error((int)v2);
    return 0;
  }
}
// 8294000: using guessed type __int16 word_8294000[];
// 8394040: using guessed type int dword_8394040;
// 8394044: using guessed type int dword_8394044;

//----- (0807BC7C) --------------------------------------------------------
int *__userpurge sub_807BC7C@<eax>(int *a1, int a2, int a3)
{
  int v4; // [esp+18h] [ebp-10h]
  int v5; // [esp+24h] [ebp-4h]

  v5 = FindVariable(a2, a3);
  if ( v5 )
  {
    sub_807C66A(a1, v5);
  }
  else if ( (*(_DWORD *)&word_8294000[8 * a2 + 4] & 0x1F) == 21 )
  {
    sub_807C72C(a1, a2, a3);
  }
  else
  {
    *a1 = v4;
    a1[1] = 0;
  }
  return a1;
}
// 807BCE4: variable 'v4' is possibly undefined
// 8294000: using guessed type __int16 word_8294000[];

//----- (0807BF2C) --------------------------------------------------------
_DWORD *__userpurge sub_807BF2C@<eax>(_DWORD *a1, unsigned int a2)
{
  if ( a2 > 0xFFFF )
  {
    if ( a2 > 0x1FFFD )
    {
      a1[1] = 6;
      *a1 = a2 - 0x800000;
    }
    else
    {
      a1[1] = 1;
      *a1 = a2 - 0x10000;
    }
  }
  else
  {
    a1[1] = 2;
    *a1 = (unsigned __int16)a2;
  }
  return a1;
}

//----- (0807BF8E) --------------------------------------------------------
int __cdecl sub_807BF8E(int a1, int a2, int a3)
{
  int result; // eax
  int v4; // [esp+18h] [ebp-10h]
  __int16 *v5; // [esp+1Ch] [ebp-Ch]
  int v6; // [esp+38h] [ebp+10h]

  if ( sub_807A4D2(a1, a2) )
    return sub_807C16E(a1, a2);
  v5 = &word_8294000[8 * a1];
  result = *((_DWORD *)v5 + 2) & 0x1F;
  if ( result == 21 )
  {
    v4 = *((_DWORD *)v5 + 2) >> 8;
    result = FindArrayVariable((unsigned __int16)word_815AB80[6 * v4], a2);
    if ( result )
    {
      v6 = a3 + 8;
      *(_DWORD *)(v6 + 4) = 0;
      return sub_8084E4E(v4, (unsigned __int16)v5[3], dword_8294004[4 * result], v6);
    }
  }
  return result;
}
// 815AB80: using guessed type __int16 word_815AB80[];
// 8294000: using guessed type __int16 word_8294000[];
// 8294004: using guessed type int dword_8294004[];

//----- (0807C060) --------------------------------------------------------
int __cdecl sub_807C060(int a1, int a2)
{
  return (unsigned __int16)word_8294000[8 * sub_807BB82(a1, a2)];
}
// 8294000: using guessed type __int16 word_8294000[];

//----- (0807C084) --------------------------------------------------------
int __cdecl sub_807C084(int a1, int a2)
{
  return (unsigned __int16)word_8294000[8 * sub_807BBA6(a1, a2)];
}
// 8294000: using guessed type __int16 word_8294000[];

//----- (0807C0A8) --------------------------------------------------------
int __cdecl sub_807C0A8(int a1, unsigned int a2)
{
  return (unsigned __int16)word_8294000[8 * sub_807AC26(a1, a2)];
}
// 8294000: using guessed type __int16 word_8294000[];

//----- (0807C0CC) --------------------------------------------------------
int __cdecl sub_807C0CC(int a1, unsigned int a2)
{
  return (unsigned __int16)word_8294000[8 * sub_807AB96(a1, a2)];
}
// 8294000: using guessed type __int16 word_8294000[];

//----- (0807C0F0) --------------------------------------------------------
int __cdecl sub_807C0F0(int a1, int a2)
{
  return (unsigned __int16)word_8294000[8 * sub_807AC26(a1, a2 + 0x10000)];
}
// 8294000: using guessed type __int16 word_8294000[];

//----- (0807C11A) --------------------------------------------------------
int __cdecl sub_807C11A(int a1, int a2)
{
  return (unsigned __int16)word_8294000[8 * sub_807AB96(a1, a2 + 0x10000)];
}
// 8294000: using guessed type __int16 word_8294000[];

//----- (0807C144) --------------------------------------------------------
int __cdecl sub_807C144(int a1, int a2)
{
  return (unsigned __int16)word_8294000[8 * sub_807ABDE(a1, a2 + 0x10000)];
}
// 8294000: using guessed type __int16 word_8294000[];

//----- (0807C16E) --------------------------------------------------------
int __cdecl sub_807C16E(int a1, int a2)
{
  int v3; // [esp+Ch] [ebp-Ch]
  __int16 *v4; // [esp+14h] [ebp-4h]

  v4 = &word_8294000[8 * sub_807A4D2(a1, a2)];
  v3 = (unsigned __int16)*v4;
  sub_807AC94(v4, 16 * a1 + 136921088);
  return sub_807B778(v3);
}
// 807B778: using guessed type _DWORD __cdecl sub_807B778(_DWORD);
// 8294000: using guessed type __int16 word_8294000[];

//----- (0807C1CC) --------------------------------------------------------
int __cdecl sub_807C1CC(int a1)
{
  unsigned __int16 v2; // [esp+10h] [ebp-8h]
  __int16 *v3; // [esp+14h] [ebp-4h]

  v3 = &word_8294000[8 * (unsigned __int16)word_829400E[8 * a1]];
  v2 = *v3;
  sub_807AC94(v3, 16 * a1 + 136921088);
  return sub_807B778(v2);
}
// 8294000: using guessed type __int16 word_8294000[];
// 829400E: using guessed type __int16 word_829400E[524281];

//----- (0807C228) --------------------------------------------------------
int __cdecl sub_807C228(int a1, int a2)
{
  return sub_807C16E(a1, a2 + 0x10000);
}

//----- (0807C248) --------------------------------------------------------
int __cdecl sub_807C248(int a1, int a2)
{
  return sub_807C290(a1, (a2 + 0x800000) & 0xFFFFFF);
}

//----- (0807C26C) --------------------------------------------------------
int __cdecl sub_807C26C(int a1, int a2)
{
  return sub_807C16E(a1, (a2 + 0x800000) & 0xFFFFFF);
}

//----- (0807C290) --------------------------------------------------------
int __cdecl sub_807C290(int a1, int a2)
{
  int result; // eax
  int v3; // [esp+10h] [ebp-8h]

  result = sub_807A4D2(a1, a2);
  if ( result )
  {
    v3 = (unsigned __int16)word_8294000[8 * result];
    sub_807AC94(&word_8294000[8 * result], 16 * a1 + 136921088);
    return sub_807B778(v3);
  }
  return result;
}
// 8294000: using guessed type __int16 word_8294000[];

//----- (0807C2F6) --------------------------------------------------------
int __cdecl sub_807C2F6(int a1, int a2)
{
  int result; // eax
  int i; // [esp+8h] [ebp-20h]
  __int16 *v4; // [esp+10h] [ebp-18h]
  __int16 *v5; // [esp+14h] [ebp-14h]
  int v6; // [esp+18h] [ebp-10h]

  for ( i = (unsigned __int16)word_8294000[8 * (unsigned __int16)word_829400E[8 * a1]];
        ;
        i = (unsigned __int16)word_8294000[8 * (unsigned __int16)word_829400E[8 * i]] )
  {
    result = i;
    if ( i == a1 )
      break;
    v5 = &word_8294000[8 * i];
    v6 = *((_DWORD *)v5 + 2) & 0x1F;
    v4 = &word_8294000[8 * (unsigned __int16)word_8294000[8 * sub_807AC26(a2, *((_DWORD *)v5 + 2) >> 8)]];
    *((_DWORD *)v4 + 2) |= v6;
    if ( v6 == 1 )
    {
      if ( (dword_8294008[4 * *((_DWORD *)v5 + 1)] & 0x1F) == 22 )
      {
        *((_DWORD *)v4 + 1) = sub_807B658();
        sub_807C2F6(*((_DWORD *)v5 + 1), *((_DWORD *)v4 + 1));
      }
      else
      {
        *((_DWORD *)v4 + 1) = *((_DWORD *)v5 + 1);
        AddRefToObject(*((_DWORD *)v5 + 1));
      }
    }
    else
    {
      *((_DWORD *)v4 + 1) = *((_DWORD *)v5 + 1);
      sub_807BA14(v6, *((_DWORD *)v5 + 1));
    }
  }
  return result;
}
// 8294000: using guessed type __int16 word_8294000[];
// 8294008: using guessed type int dword_8294008[];
// 829400E: using guessed type __int16 word_829400E[524281];

//----- (0807C45C) --------------------------------------------------------
int __cdecl sub_807C45C(int a1, int *a2)
{
  int result; // eax
  __int16 *v3; // [esp+14h] [ebp-4h]

  v3 = &word_8294000[8 * a1];
  RemoveRefToValueInternal(*((_DWORD *)v3 + 2) & 0x1F, *((_DWORD *)v3 + 1));
  *((_DWORD *)v3 + 2) &= 0xFFFFFFE0;
  *((_DWORD *)v3 + 2) |= a2[1];
  result = *a2;
  *((_DWORD *)v3 + 1) = *a2;
  return result;
}
// 8294000: using guessed type __int16 word_8294000[];

//----- (0807C4C2) --------------------------------------------------------
int __cdecl sub_807C4C2(int a1, int *a2)
{
  int result; // eax

  *(_DWORD *)&word_8294000[8 * a1 + 4] |= a2[1];
  result = *a2;
  *(_DWORD *)&word_8294000[8 * a1 + 2] = *a2;
  return result;
}
// 8294000: using guessed type __int16 word_8294000[];

//----- (0807C4FC) --------------------------------------------------------
__int16 *__cdecl sub_807C4FC(int a1)
{
  return &word_8294000[8 * a1 + 2];
}
// 8294000: using guessed type __int16 word_8294000[];

//----- (0807C51C) --------------------------------------------------------
int __cdecl sub_807C51C(int a1, unsigned int a2, int *a3)
{
  int result; // eax
  int v4; // eax
  __int16 *v5; // edx
  int v6; // [esp+1Ch] [ebp-Ch]

  v6 = FindArrayVariable((unsigned __int16)word_815AB80[6 * (*(_DWORD *)&word_8294000[8 * a1 + 4] >> 8)], a2);
  if ( !v6
    || (result = sub_8084E4E(
                   *(_DWORD *)&word_8294000[8 * a1 + 4] >> 8,
                   (unsigned __int16)word_8294000[8 * a1 + 3],
                   dword_8294004[4 * v6],
                   (int)a3),
        !(_BYTE)result) )
  {
    v4 = sub_807C0CC(a1, a2);
    *(_DWORD *)&word_8294000[8 * v4 + 4] |= a3[1];
    v5 = &word_8294000[8 * v4 + 2];
    result = *a3;
    *(_DWORD *)v5 = *a3;
  }
  return result;
}
// 815AB80: using guessed type __int16 word_815AB80[];
// 8294000: using guessed type __int16 word_8294000[];
// 8294004: using guessed type int dword_8294004[];

//----- (0807C5E2) --------------------------------------------------------
unsigned int __cdecl sub_807C5E2(int a1)
{
  __int16 *v1; // edx
  unsigned int result; // eax

  RemoveRefToValueInternal(*(_DWORD *)&word_8294000[8 * a1 + 4] & 0x1F, *(_DWORD *)&word_8294000[8 * a1 + 2]);
  v1 = &word_8294000[8 * a1];
  result = *((_DWORD *)v1 + 2) & 0xFFFFFFE0;
  *((_DWORD *)v1 + 2) = result;
  return result;
}
// 8294000: using guessed type __int16 word_8294000[];

//----- (0807C628) --------------------------------------------------------
int __cdecl sub_807C628(int a1, int *a2)
{
  if ( a1 == 65534 )
    return sub_807C51C(dword_8394040, dword_8394044, a2);
  else
    return sub_807C45C(a1, a2);
}
// 8394040: using guessed type int dword_8394040;
// 8394044: using guessed type int dword_8394044;

//----- (0807C66A) --------------------------------------------------------
int *__userpurge sub_807C66A@<eax>(int *a1, int a2)
{
  a1[1] = *(_DWORD *)&word_8294000[8 * a2 + 4] & 0x1F;
  *a1 = *(_DWORD *)&word_8294000[8 * a2 + 2];
  sub_807578C(a1);
  return a1;
}
// 8294000: using guessed type __int16 word_8294000[];

//----- (0807C6AE) --------------------------------------------------------
int __cdecl sub_807C6AE(int a1)
{
  char *v1; // eax
  unsigned int v4; // [esp+10h] [ebp-8h]
  __int16 *v5; // [esp+14h] [ebp-4h]

  v5 = &word_8294000[8 * a1];
  v4 = *((_DWORD *)v5 + 2) & 0x1F;
  if ( v4 == 1 )
  {
    v4 = dword_8294008[4 * *((_DWORD *)v5 + 1)] & 0x1F;
    if ( v4 <= 0x15 )
      return *((_DWORD *)v5 + 1);
  }
  v1 = va("%s is not a field object", *(const char **)&off_815ABC0[4 * v4]);
  Scr_Error((int)v1);
  return 0;
}
// 8294000: using guessed type __int16 word_8294000[];
// 8294008: using guessed type int dword_8294008[];

//----- (0807C72C) --------------------------------------------------------
int *__userpurge sub_807C72C@<eax>(int *a1, int a2, int a3)
{
  int v3; // edx
  int v5[2]; // [esp+10h] [ebp-18h] BYREF
  int v6; // [esp+18h] [ebp-10h]
  int v7; // [esp+1Ch] [ebp-Ch]
  __int16 *v8; // [esp+20h] [ebp-8h]
  __int16 *v9; // [esp+24h] [ebp-4h]

  v8 = &word_8294000[8 * a2];
  v7 = FindArrayVariable((unsigned __int16)word_815AB80[6 * (*((_DWORD *)v8 + 2) >> 8)], a3);
  if ( v7 )
  {
    sub_8084ECA(v5, (char *)(*((_DWORD *)v8 + 2) >> 8), (unsigned __int16)v8[3], dword_8294004[4 * v7]);
    v3 = v5[1];
    *a1 = v5[0];
    a1[1] = v3;
    if ( a1[1] == 1 )
    {
      v9 = &word_8294000[8 * *a1];
      if ( (*((_DWORD *)v9 + 2) & 0x1F) == 22 )
      {
        if ( v9[2] )
        {
          v6 = *a1;
          RemoveRefToObject(v6);
          *a1 = sub_807B658();
          sub_807C2F6(v6, *a1);
        }
      }
    }
  }
  else
  {
    a1[1] = 0;
  }
  return a1;
}
// 815AB80: using guessed type __int16 word_815AB80[];
// 8294000: using guessed type __int16 word_8294000[];
// 8294004: using guessed type int dword_8294004[];

//----- (0807C83C) --------------------------------------------------------
int *__userpurge sub_807C83C@<eax>(int *a1, int a2)
{
  int v3; // [esp+10h] [ebp-18h]
  int v4; // [esp+14h] [ebp-14h]
  int v5[2]; // [esp+18h] [ebp-10h] BYREF
  int v6[2]; // [esp+20h] [ebp-8h] BYREF

  if ( a2 == 65534 )
  {
    sub_807C72C(v5, dword_8394040, dword_8394044);
    v3 = v5[0];
    v4 = v5[1];
  }
  else
  {
    sub_807C66A(v6, a2);
    v3 = v6[0];
    v4 = v6[1];
  }
  *a1 = v3;
  a1[1] = v4;
  return a1;
}
// 8394040: using guessed type int dword_8394040;
// 8394044: using guessed type int dword_8394044;

//----- (0807C8B2) --------------------------------------------------------
void __cdecl sub_807C8B2(int *a1)
{
  const char *v1; // eax
  int v2; // [esp+Ch] [ebp-1Ch]
  char *v3; // [esp+14h] [ebp-14h]
  int v4; // [esp+18h] [ebp-10h]
  int v5; // [esp+1Ch] [ebp-Ch]
  __int16 *v6; // [esp+20h] [ebp-8h]

  if ( a1[1] == 1 )
  {
    v5 = *a1;
    v6 = &word_8294000[8 * *a1];
    a1[1] = 6;
    if ( (*((_DWORD *)v6 + 2) & 0x1F) == 22 )
      v2 = (unsigned __int16)v6[3];
    else
      v2 = 1;
    *a1 = v2;
    RemoveRefToObject(v5);
  }
  else if ( a1[1] == 2 )
  {
    a1[1] = 6;
    v4 = *a1;
    v1 = (const char *)SL_ConvertToString(*a1);
    *a1 = strlen(v1);
    SL_RemoveRefToString(v4);
  }
  else
  {
    v3 = va("size cannot be applied to %s", *(const char **)&off_815ABC0[4 * a1[1]]);
    RemoveRefToValue(a1);
    a1[1] = 0;
    Scr_Error((int)v3);
  }
}
// 8294000: using guessed type __int16 word_8294000[];

//----- (0807C9AC) --------------------------------------------------------
int __cdecl sub_807C9AC(int a1)
{
  return (unsigned __int16)word_8294000[8 * a1 + 3];
}
// 8294000: using guessed type __int16 word_8294000[];

//----- (0807C9CE) --------------------------------------------------------
int __cdecl sub_807C9CE(int a1)
{
  if ( (dword_8294008[4 * (unsigned __int16)word_8294000[8 * (unsigned __int16)word_829400E[8 * a1]]] & 0x1Fu) > 0xE )
    return 0;
  else
    return (unsigned __int16)word_8294000[8 * (unsigned __int16)word_829400E[8 * a1]];
}
// 8294000: using guessed type __int16 word_8294000[];
// 8294008: using guessed type int dword_8294008[];
// 829400E: using guessed type __int16 word_829400E[524281];

//----- (0807CA16) --------------------------------------------------------
int __cdecl sub_807CA16(int a1)
{
  if ( (dword_8294008[4
                    * (unsigned __int16)word_8294000[8
                                                   * (unsigned __int16)word_8294002[8
                                                                                  * (unsigned __int16)word_8294002[8 * (unsigned __int16)word_829400E[8 * a1]]]]] & 0x1Fu) > 0xE )
    return 0;
  else
    return (unsigned __int16)word_8294000[8
                                        * (unsigned __int16)word_8294002[8
                                                                       * (unsigned __int16)word_8294002[8 * (unsigned __int16)word_829400E[8 * a1]]]];
}
// 8294000: using guessed type __int16 word_8294000[];
// 8294002: using guessed type __int16 word_8294002[];
// 8294008: using guessed type int dword_8294008[];
// 829400E: using guessed type __int16 word_829400E[524281];

//----- (0807CA72) --------------------------------------------------------
unsigned int __cdecl GetVariableName(int a1)
{
  return (unsigned int)dword_8294008[4 * a1] >> 8;
}
// 8294008: using guessed type int dword_8294008[];

//----- (0807CA86) --------------------------------------------------------
int __cdecl sub_807CA86(int a1)
{
  __int16 *v2; // [esp+0h] [ebp-8h]

  v2 = &word_8294000[8 * a1];
  if ( (*((_DWORD *)v2 + 2) & 0x1F) == 0 )
  {
    *((_DWORD *)v2 + 2) |= 1u;
    *((_DWORD *)v2 + 1) = sub_807B5A0();
  }
  return *((_DWORD *)v2 + 1);
}
// 8294000: using guessed type __int16 word_8294000[];

//----- (0807CAD2) --------------------------------------------------------
int __cdecl sub_807CAD2(int a1)
{
  __int16 *v2; // [esp+0h] [ebp-8h]

  v2 = &word_8294000[8 * a1];
  if ( (*((_DWORD *)v2 + 2) & 0x1F) == 0 )
  {
    *((_DWORD *)v2 + 2) |= 1u;
    *((_DWORD *)v2 + 1) = sub_807B658();
  }
  return *((_DWORD *)v2 + 1);
}
// 8294000: using guessed type __int16 word_8294000[];

//----- (0807CB1E) --------------------------------------------------------
int __cdecl sub_807CB1E(int a1)
{
  return *(_DWORD *)&word_8294000[8 * a1 + 2];
}
// 8294000: using guessed type __int16 word_8294000[];

//----- (0807CB3E) --------------------------------------------------------
_BOOL4 __cdecl sub_807CB3E(int a1)
{
  return (*(_DWORD *)&word_8294000[8 * a1 + 4] & 0x1Fu) <= 0x15;
}
// 8294000: using guessed type __int16 word_8294000[];

//----- (0807CBAA) --------------------------------------------------------
_BOOL4 __cdecl sub_807CBAA(int a1)
{
  _BOOL4 result; // eax

  sub_807CC38((float *)a1);
  result = a1;
  if ( *(_DWORD *)(a1 + 4) == 6 )
  {
    result = *(_DWORD *)a1 == 0;
    *(_DWORD *)a1 = result;
  }
  return result;
}

//----- (0807CBD8) --------------------------------------------------------
void __cdecl sub_807CBD8(int *a1)
{
  char *v1; // eax
  int v2; // [esp+14h] [ebp-4h]

  if ( a1[1] == 6 )
  {
    *a1 = ~*a1;
  }
  else
  {
    v2 = a1[1];
    RemoveRefToValue(a1);
    a1[1] = 0;
    v1 = va("~ cannot be applied to \"%s\"", *(const char **)&off_815ABC0[4 * v2]);
    Scr_Error((int)v1);
  }
}

//----- (0807CC38) --------------------------------------------------------
void __cdecl sub_807CC38(float *a1)
{
  char *v1; // eax
  int v2; // [esp+14h] [ebp-4h]

  if ( *((_DWORD *)a1 + 1) == 6 )
  {
    *(_DWORD *)a1 = *(_DWORD *)a1 != 0;
  }
  else if ( *((_DWORD *)a1 + 1) == 5 )
  {
    *((_DWORD *)a1 + 1) = 6;
    *(_DWORD *)a1 = 0.0 != *a1;
  }
  else
  {
    v2 = *((_DWORD *)a1 + 1);
    RemoveRefToValue(a1);
    a1[1] = 0.0;
    v1 = va("cannot cast %s to bool", *(const char **)&off_815ABC0[4 * v2]);
    Scr_Error((int)v1);
  }
}

//----- (0807CCCE) --------------------------------------------------------
int __cdecl sub_807CCCE(int *a1)
{
  int v3; // [esp+10h] [ebp-8h]

  switch ( a1[1] )
  {
    case 2:
      return 1;
    case 6:
      a1[1] = 2;
      *a1 = sub_807986A(*a1);
      return 1;
    case 5:
      a1[1] = 2;
      *a1 = sub_8079824(*(float *)a1);
      return 1;
    case 4:
      a1[1] = 2;
      v3 = *a1;
      *a1 = sub_80798B0((float *)*a1);
      RemoveRefToVector(v3);
      return 1;
    default:
      *(_DWORD *)dword_8394010 = va("cannot cast %s to string", *(const char **)&off_815ABC0[4 * a1[1]]);
      RemoveRefToValue(a1);
      a1[1] = 0;
      return 0;
  }
}

//----- (0807CDD0) --------------------------------------------------------
int __cdecl sub_807CDD0(int *a1)
{
  int result; // eax
  int v2; // eax
  int v3; // [esp+1Ch] [ebp-Ch]
  char *s; // [esp+20h] [ebp-8h]
  int v5; // [esp+24h] [ebp-4h]

  switch ( a1[1] )
  {
    case 1:
      s = *(char **)&off_815ABC0[4 * GetVarType(*a1)];
      goto LABEL_7;
    case 2:
    case 4:
    case 5:
    case 6:
      return sub_807CCCE(a1);
    case 3:
      result = (int)a1;
      a1[1] = 2;
      return result;
    case 11:
      v5 = *a1;
      v2 = Scr_GetAnims(HIWORD(*a1));
      s = sub_80BE94C(v2, (unsigned __int16)v5);
      goto LABEL_7;
    default:
      s = *(char **)&off_815ABC0[4 * a1[1]];
LABEL_7:
      v3 = SL_GetString(s, 0);
      RemoveRefToValue(a1);
      a1[1] = 2;
      result = v3;
      *a1 = v3;
      return result;
  }
}

//----- (0807CEE4) --------------------------------------------------------
int __cdecl sub_807CEE4(int a1)
{
  int result; // eax
  int i; // [esp+4h] [ebp-4h]

  for ( i = 2; i >= 0; --i )
    RemoveRefToValue((_DWORD *)(a1 + 8 * i));
  result = a1;
  *(_DWORD *)(a1 + 4) = 0;
  return result;
}

//----- (0807CF1E) --------------------------------------------------------
void __cdecl sub_807CF1E(_DWORD *a1)
{
  char *v1; // eax
  int v2; // [esp+18h] [ebp-20h]
  int i; // [esp+1Ch] [ebp-1Ch]
  float v4[6]; // [esp+20h] [ebp-18h] BYREF

  for ( i = 2; i >= 0; --i )
  {
    v2 = a1[2 * i + 1];
    if ( v2 == 5 )
    {
      v4[2 - i] = *(float *)&a1[2 * i];
    }
    else
    {
      if ( v2 != 6 )
      {
        dword_8394014 = i + 1;
        sub_807CEE4((int)a1);
        v1 = va("type %s is not a float", *(const char **)&off_815ABC0[4 * v2]);
        Scr_Error((int)v1);
        return;
      }
      v4[2 - i] = (float)(int)a1[2 * i];
    }
  }
  a1[1] = 4;
  *a1 = sub_807B968(v4);
}
// 8394014: using guessed type int dword_8394014;
// 807CF1E: using guessed type float var_18[6];

//----- (0807CFFA) --------------------------------------------------------
int __cdecl sub_807CFFA(int a1, int *a2)
{
  char *v2; // eax
  int v5[3]; // [esp+18h] [ebp-10h] BYREF
  int v6; // [esp+24h] [ebp-4h]

  v6 = a2[1];
  if ( v6 == 1 && (v6 = dword_8294008[4 * *a2] & 0x1F, v6 <= 21) )
  {
    v5[1] = 1;
    v5[0] = *a2;
    sub_807C45C(a1, v5);
    return v5[0];
  }
  else
  {
    RemoveRefToValue(a2);
    v2 = va("%s is not a field object", *(const char **)&off_815ABC0[4 * v6]);
    Scr_Error((int)v2);
    return 0;
  }
}
// 8294008: using guessed type int dword_8294008[];

//----- (0807D08C) --------------------------------------------------------
void __cdecl sub_807D08C(int *a1, int *a2)
{
  const char *v2; // ebx
  const char *v3; // eax
  char *v4; // [esp+18h] [ebp-10h]
  int v5; // [esp+1Ch] [ebp-Ch]
  int v6; // [esp+20h] [ebp-8h]

  if ( *(_DWORD *)dword_8394010 )
  {
    v4 = 0;
  }
  else
  {
    v6 = a1[1];
    v5 = a2[1];
    sub_807CDD0(a1);
    sub_807CDD0(a2);
    v2 = (const char *)SL_ConvertToString(*a2);
    v3 = (const char *)SL_ConvertToString(*a1);
    v4 = va(
           "pair '%s' and '%s' has unmatching types '%s' and '%s'",
           v3,
           v2,
           *(const char **)&off_815ABC0[4 * v6],
           *(const char **)&off_815ABC0[4 * v5]);
  }
  RemoveRefToValue(a1);
  a1[1] = 0;
  RemoveRefToValue(a2);
  a2[1] = 0;
  Scr_Error((int)v4);
}

//----- (0807D15A) --------------------------------------------------------
void __cdecl sub_807D15A(int *a1, int *a2)
{
  int v2; // [esp+10h] [ebp-8h]
  int v3; // [esp+14h] [ebp-4h]

  v3 = a1[1];
  v2 = a2[1];
  if ( v3 != v2 )
  {
    if ( v3 == 5 && v2 == 6 )
    {
      a2[1] = 5;
      *(float *)a2 = (float)*a2;
    }
    else if ( v3 == 6 && v2 == 5 )
    {
      a1[1] = 5;
      *(float *)a1 = (float)*a1;
    }
    else
    {
      sub_807D08C(a1, a2);
    }
  }
}

//----- (0807D1D4) --------------------------------------------------------
void __cdecl sub_807D1D4(int *a1, int a2)
{
  float v2; // [esp+18h] [ebp-10h]
  int v3; // [esp+18h] [ebp-10h]
  int v4; // [esp+1Ch] [ebp-Ch]
  int v5; // [esp+20h] [ebp-8h]

  v5 = a1[1];
  v4 = *(_DWORD *)(a2 + 4);
  if ( v5 != v4 )
  {
    if ( v5 < v4 )
    {
      if ( v5 == 2 )
      {
        if ( v4 == 5 )
        {
          *(_DWORD *)(a2 + 4) = 2;
          *(_DWORD *)a2 = sub_8079824(*(float *)a2);
          return;
        }
        if ( v4 > 5 )
        {
          if ( v4 == 6 )
          {
            *(_DWORD *)(a2 + 4) = 2;
            *(_DWORD *)a2 = sub_807986A(*(_DWORD *)a2);
            return;
          }
        }
        else if ( v4 == 4 )
        {
          *(_DWORD *)(a2 + 4) = 2;
          v2 = *(float *)a2;
          *(_DWORD *)a2 = sub_80798B0(*(float **)a2);
          RemoveRefToVector(SLODWORD(v2));
          return;
        }
      }
      else if ( v5 != 5 )
      {
LABEL_31:
        sub_807D08C(a1, (int *)a2);
        return;
      }
      if ( v4 == 6 )
      {
        *(_DWORD *)(a2 + 4) = 5;
        *(float *)a2 = (float)*(int *)a2;
        return;
      }
      goto LABEL_31;
    }
    if ( v4 == 2 )
    {
      if ( v5 == 5 )
      {
        a1[1] = 2;
        *a1 = sub_8079824(*(float *)a1);
        return;
      }
      if ( v5 > 5 )
      {
        if ( v5 == 6 )
        {
          a1[1] = 2;
          *a1 = sub_807986A(*a1);
          return;
        }
      }
      else if ( v5 == 4 )
      {
        a1[1] = 2;
        v3 = *a1;
        *a1 = sub_80798B0((float *)*a1);
        RemoveRefToVector(v3);
        return;
      }
    }
    else if ( v4 != 5 )
    {
      goto LABEL_31;
    }
    if ( v5 == 6 )
    {
      a1[1] = 5;
      *(float *)a1 = (float)*a1;
      return;
    }
    goto LABEL_31;
  }
}

//----- (0807D3B6) --------------------------------------------------------
void __cdecl Scr_EvalOr(int *a1, int *a2)
{
  if ( a1[1] == 6 && a2[1] == 6 )
    *a1 |= *a2;
  else
    sub_807D08C(a1, a2);
}

//----- (0807D3F4) --------------------------------------------------------
void __cdecl Scr_EvalExOr(int *a1, int *a2)
{
  if ( a1[1] == 6 && a2[1] == 6 )
    *a1 ^= *a2;
  else
    sub_807D08C(a1, a2);
}

//----- (0807D432) --------------------------------------------------------
void __cdecl Scr_EvalAnd(int *a1, int *a2)
{
  if ( a1[1] == 6 && a2[1] == 6 )
    *a1 &= *a2;
  else
    sub_807D08C(a1, a2);
}

//----- (0807D470) --------------------------------------------------------
void __cdecl Scr_EvalEquality(int *a1, int *a2)
{
  float v2; // [esp+0h] [ebp-18h]
  int v3; // [esp+Ch] [ebp-Ch]
  _BOOL4 v4; // [esp+10h] [ebp-8h]
  _BOOL4 v5; // [esp+10h] [ebp-8h]

  sub_807D15A(a1, a2);
  switch ( a1[1] )
  {
    case 0:
      a1[1] = 6;
      *a1 = 1;
      break;
    case 1:
      if ( ((dword_8294008[4 * *a1] & 0x1F) == 22 || (dword_8294008[4 * *a2] & 0x1F) == 22) && !byte_839400C )
        goto LABEL_17;
      a1[1] = 6;
      v5 = *a1 == *a2;
      RemoveRefToObject(*a1);
      RemoveRefToObject(*a2);
      *a1 = v5;
      break;
    case 2:
    case 3:
      a1[1] = 6;
      v4 = *a1 == *a2;
      SL_RemoveRefToString(*a1);
      SL_RemoveRefToString(*a2);
      *a1 = v4;
      break;
    case 4:
      a1[1] = 6;
      v3 = 0;
      if ( *(float *)*a1 == *(float *)*a2
        && *(float *)(*a1 + 4) == *(float *)(*a2 + 4)
        && *(float *)(*a1 + 8) == *(float *)(*a2 + 8) )
      {
        v3 = 1;
      }
      RemoveRefToVector(*a1);
      RemoveRefToVector(*a2);
      *a1 = v3;
      break;
    case 5:
      a1[1] = 6;
      v2 = *(float *)a1 - *(float *)a2;
      *a1 = sub_807F7F4(v2) < 0.000001;
      break;
    case 6:
      *a1 = *a1 == *a2;
      break;
    case 9:
      a1[1] = 6;
      *a1 = *a1 == *a2;
      break;
    case 11:
      a1[1] = 6;
      *a1 = *a1 == *a2;
      break;
    default:
LABEL_17:
      sub_807D08C(a1, a2);
      break;
  }
}
// 8294008: using guessed type int dword_8294008[];
// 839400C: using guessed type char byte_839400C;

//----- (0807D6D6) --------------------------------------------------------
_BOOL4 __cdecl Scr_EvalInequality(int *a1, int *a2)
{
  _BOOL4 result; // eax

  Scr_EvalEquality(a1, a2);
  result = *a1 == 0;
  *a1 = result;
  return result;
}

//----- (0807D702) --------------------------------------------------------
void __cdecl Scr_EvalLess(int *a1, int *a2)
{
  int v2; // [esp+14h] [ebp-4h]

  sub_807D15A(a1, a2);
  v2 = a1[1];
  if ( v2 == 5 )
  {
    a1[1] = 6;
    *a1 = *(float *)a2 > (long double)*(float *)a1;
  }
  else if ( v2 == 6 )
  {
    *a1 = *a1 < *a2;
  }
  else
  {
    sub_807D08C(a1, a2);
  }
}

//----- (0807D784) --------------------------------------------------------
_BOOL4 __cdecl Scr_EvalGreaterEqual(int *a1, int *a2)
{
  _BOOL4 result; // eax

  Scr_EvalLess(a1, a2);
  result = *a1 == 0;
  *a1 = result;
  return result;
}

//----- (0807D7B0) --------------------------------------------------------
void __cdecl Scr_EvalGreater(int *a1, int *a2)
{
  int v2; // [esp+14h] [ebp-4h]

  sub_807D15A(a1, a2);
  v2 = a1[1];
  if ( v2 == 5 )
  {
    a1[1] = 6;
    *a1 = *(float *)a1 > (long double)*(float *)a2;
  }
  else if ( v2 == 6 )
  {
    *a1 = *a1 > *a2;
  }
  else
  {
    sub_807D08C(a1, a2);
  }
}

//----- (0807D832) --------------------------------------------------------
_BOOL4 __cdecl Scr_EvalLessEqual(int *a1, int *a2)
{
  _BOOL4 result; // eax

  Scr_EvalGreater(a1, a2);
  result = *a1 == 0;
  *a1 = result;
  return result;
}

//----- (0807D85E) --------------------------------------------------------
void __cdecl Scr_EvalShiftLeft(int *a1, int *a2)
{
  if ( a1[1] == 6 && a2[1] == 6 )
    *a1 <<= *(_BYTE *)a2;
  else
    sub_807D08C(a1, a2);
}

//----- (0807D8A4) --------------------------------------------------------
void __cdecl Scr_EvalShiftRight(int *a1, int *a2)
{
  if ( a1[1] == 6 && a2[1] == 6 )
    *a1 >>= *(_BYTE *)a2;
  else
    sub_807D08C(a1, a2);
}

//----- (0807D8EA) --------------------------------------------------------
void __cdecl Scr_EvalPlus(int *a1, int *a2)
{
  char *v2; // eax
  int v3; // [esp+1Ch] [ebp-202Ch]
  char *v4; // [esp+20h] [ebp-2028h]
  char *src; // [esp+24h] [ebp-2024h]
  int v6; // [esp+28h] [ebp-2020h]
  int n; // [esp+2Ch] [ebp-201Ch]
  char dest[8200]; // [esp+30h] [ebp-2018h] BYREF
  float *v9; // [esp+2038h] [ebp-10h]
  int v10; // [esp+203Ch] [ebp-Ch]

  sub_807D1D4(a1, (int)a2);
  v3 = a1[1];
  if ( v3 == 4 )
  {
    v9 = (float *)sub_807B936();
    *v9 = *(float *)*a1 + *(float *)*a2;
    v9[1] = *(float *)(*a1 + 4) + *(float *)(*a2 + 4);
    v9[2] = *(float *)(*a1 + 8) + *(float *)(*a2 + 8);
    RemoveRefToVector(*a1);
    RemoveRefToVector(*a2);
    *a1 = (int)v9;
    return;
  }
  if ( v3 > 4 )
  {
    if ( v3 == 5 )
    {
      *(float *)a1 = *(float *)a1 + *(float *)a2;
      return;
    }
    if ( v3 == 6 )
    {
      *a1 += *a2;
      return;
    }
    goto LABEL_13;
  }
  if ( v3 != 2 )
  {
LABEL_13:
    sub_807D08C(a1, a2);
    return;
  }
  src = (char *)SL_ConvertToString(*a1);
  v4 = (char *)SL_ConvertToString(*a2);
  v6 = sub_80788FC(*a1);
  n = v6 + sub_80788FC(*a2) + 1;
  if ( v6 <= 0x2000 )
  {
    strcpy(dest, src);
    strcpy(&dest[v6], v4);
    v10 = SL_GetStringOfLen(dest, 0, n);
    SL_RemoveRefToString(*a1);
    SL_RemoveRefToString(*a2);
    *a1 = v10;
  }
  else
  {
    SL_RemoveRefToString(*a1);
    SL_RemoveRefToString(*a2);
    a1[1] = 0;
    a2[1] = 0;
    v2 = va("cannot concat \"%s\" and \"%s\" - max string length exceeded", src, v4);
    Scr_Error((int)v2);
  }
}
// 807D8EA: using guessed type char dest[8200];

//----- (0807DB42) --------------------------------------------------------
void __cdecl Scr_EvalMinus(int *a1, int *a2)
{
  int v2; // [esp+Ch] [ebp-Ch]
  float *v3; // [esp+10h] [ebp-8h]

  sub_807D15A(a1, a2);
  v2 = a1[1];
  if ( v2 == 5 )
  {
    *(float *)a1 = *(float *)a1 - *(float *)a2;
    return;
  }
  if ( v2 > 5 )
  {
    if ( v2 == 6 )
    {
      *a1 -= *a2;
      return;
    }
  }
  else if ( v2 == 4 )
  {
    v3 = (float *)sub_807B936();
    *v3 = *(float *)*a1 - *(float *)*a2;
    v3[1] = *(float *)(*a1 + 4) - *(float *)(*a2 + 4);
    v3[2] = *(float *)(*a1 + 8) - *(float *)(*a2 + 8);
    RemoveRefToVector(*a1);
    RemoveRefToVector(*a2);
    *a1 = (int)v3;
    return;
  }
  sub_807D08C(a1, a2);
}

//----- (0807DC40) --------------------------------------------------------
void __cdecl Scr_EvalMultiply(int *a1, int *a2)
{
  int v2; // [esp+14h] [ebp-4h]

  sub_807D15A(a1, a2);
  v2 = a1[1];
  if ( v2 == 5 )
  {
    *(float *)a1 = *(float *)a1 * *(float *)a2;
  }
  else if ( v2 == 6 )
  {
    *a1 *= *a2;
  }
  else
  {
    sub_807D08C(a1, a2);
  }
}

//----- (0807DCA6) --------------------------------------------------------
void __cdecl Scr_EvalDivide(int *a1, int *a2)
{
  int v2; // [esp+14h] [ebp-4h]

  sub_807D15A(a1, a2);
  v2 = a1[1];
  if ( v2 == 5 )
  {
    if ( *(float *)a2 == 0.0 )
    {
LABEL_7:
      *a1 = 0;
      Scr_Error((int)"divide by 0");
      return;
    }
    *(float *)a1 = *(float *)a1 / *(float *)a2;
  }
  else
  {
    if ( v2 == 6 )
    {
      a1[1] = 5;
      if ( *a2 )
      {
        *(float *)a1 = (long double)*a1 / (long double)*a2;
        return;
      }
      goto LABEL_7;
    }
    sub_807D08C(a1, a2);
  }
}

//----- (0807DD64) --------------------------------------------------------
void __cdecl Scr_EvalMod(int *a1, int *a2)
{
  if ( a1[1] == 6 && a2[1] == 6 )
  {
    if ( *a2 )
    {
      *a1 %= *a2;
    }
    else
    {
      *a1 = 0;
      Scr_Error((int)"divide by 0");
    }
  }
  else
  {
    sub_807D08C(a1, a2);
  }
}

//----- (0807DDD2) --------------------------------------------------------
void __cdecl Scr_EvalBinaryOperator(int a1, int *a2, int *a3)
{
  switch ( a1 )
  {
    case 'f':
      Scr_EvalOr(a2, a3);
      break;
    case 'g':
      Scr_EvalExOr(a2, a3);
      break;
    case 'h':
      Scr_EvalAnd(a2, a3);
      break;
    case 'i':
      Scr_EvalEquality(a2, a3);
      break;
    case 'j':
      Scr_EvalInequality(a2, a3);
      break;
    case 'k':
      Scr_EvalLess(a2, a3);
      break;
    case 'l':
      Scr_EvalGreater(a2, a3);
      break;
    case 'm':
      Scr_EvalLessEqual(a2, a3);
      break;
    case 'n':
      Scr_EvalGreaterEqual(a2, a3);
      break;
    case 'o':
      Scr_EvalShiftLeft(a2, a3);
      break;
    case 'p':
      Scr_EvalShiftRight(a2, a3);
      break;
    case 'q':
      Scr_EvalPlus(a2, a3);
      break;
    case 'r':
      Scr_EvalMinus(a2, a3);
      break;
    case 's':
      Scr_EvalMultiply(a2, a3);
      break;
    case 't':
      Scr_EvalDivide(a2, a3);
      break;
    case 'u':
      Scr_EvalMod(a2, a3);
      break;
    default:
      return;
  }
}

//----- (0807DF52) --------------------------------------------------------
_BOOL4 __cdecl sub_807DF52(int a1)
{
  return (dword_8294008[4 * a1] & 0x60) == 0;
}
// 8294008: using guessed type int dword_8294008[];

//----- (0807DF7C) --------------------------------------------------------
int __cdecl GetVarType(int a1)
{
  return dword_8294008[4 * a1] & 0x1F;
}
// 8294008: using guessed type int dword_8294008[];

//----- (0807DF90) --------------------------------------------------------
void __cdecl Scr_FreeEntityNum(int a1, int a2)
{
  __int16 *v2; // [esp+8h] [ebp-10h]
  int v3; // [esp+Ch] [ebp-Ch]
  int v4; // [esp+10h] [ebp-8h]
  int v5; // [esp+14h] [ebp-4h]

  if ( byte_8394038 )
  {
    v5 = (unsigned __int16)word_815AB82[6 * a2];
    v4 = FindArrayVariable(v5, a1);
    if ( v4 )
    {
      v3 = sub_807CB1E(v4);
      v2 = &word_8294000[8 * v3];
      *((_DWORD *)v2 + 2) &= 0xFFFFFFE0;
      *((_DWORD *)v2 + 2) |= 0x14u;
      AddRefToObject(v3);
      v2[3] = dword_8394030;
      dword_8394030 = v3;
      sub_807C26C(v5, a1);
    }
  }
}
// 815AB82: using guessed type __int16 word_815AB82[];
// 8294000: using guessed type __int16 word_8294000[];
// 8394030: using guessed type int dword_8394030;
// 8394038: using guessed type char byte_8394038;

//----- (0807E04A) --------------------------------------------------------
int sub_807E04A()
{
  int result; // eax
  int v1; // [esp+10h] [ebp-8h]
  __int16 *v2; // [esp+14h] [ebp-4h]

  while ( dword_8394030 )
  {
    v1 = dword_8394030;
    v2 = &word_8294000[8 * dword_8394030];
    dword_8394030 = (unsigned __int16)v2[3];
    v2[3] = 0;
    sub_80834DC(v1);
    if ( (unsigned __int16)word_8294000[8 * (unsigned __int16)v2[7]] != v1 )
      sub_807AEBA(v1);
    result = RemoveRefToObject(v1);
  }
  return result;
}
// 8294000: using guessed type __int16 word_8294000[];
// 8394030: using guessed type int dword_8394030;

//----- (0807E0C6) --------------------------------------------------------
unsigned int *sub_807E0C6()
{
  unsigned int *result; // eax
  __int16 *v1; // [esp+10h] [ebp-8h]
  unsigned int i; // [esp+14h] [ebp-4h] BYREF

  for ( i = 1; i <= 0xFFFD; ++i )
  {
    v1 = &word_8294000[8 * i];
    if ( (*((_DWORD *)v1 + 2) & 0x60) != 0 && ((*((_DWORD *)v1 + 2) & 0x1F) == 19 || (*((_DWORD *)v1 + 2) & 0x1F) == 20) )
    {
      sub_80834DC(i);
      sub_807AF82(i);
    }
    result = &i;
  }
  return result;
}
// 8294000: using guessed type __int16 word_8294000[];

//----- (0807E13C) --------------------------------------------------------
int __cdecl sub_807E13C(int a1)
{
  int result; // eax

  word_815AB82[6 * a1] = sub_807B658();
  result = sub_807B658();
  word_815AB80[6 * a1] = result;
  return result;
}
// 815AB80: using guessed type __int16 word_815AB80[];
// 815AB82: using guessed type __int16 word_815AB82[];

//----- (0807E182) --------------------------------------------------------
int __cdecl sub_807E182(int a1)
{
  int result; // eax

  if ( byte_8394038 )
  {
    RemoveRefToObject((unsigned __int16)word_815AB82[6 * a1]);
    word_815AB82[6 * a1] = 0;
    RemoveRefToObject((unsigned __int16)word_815AB80[6 * a1]);
    result = 12 * a1;
    word_815AB80[6 * a1] = 0;
  }
  return result;
}
// 815AB80: using guessed type __int16 word_815AB80[];
// 815AB82: using guessed type __int16 word_815AB82[];
// 8394038: using guessed type char byte_8394038;

//----- (0807E1F6) --------------------------------------------------------
int __cdecl sub_807E1F6(int a1, char *s2, unsigned __int16 a3)
{
  int v3; // eax
  int result; // eax
  int v5; // [esp+18h] [ebp-10h]
  int v6; // [esp+1Ch] [ebp-Ch]
  __int16 *v7; // [esp+20h] [ebp-8h]
  __int16 *v8; // [esp+20h] [ebp-8h]
  int v9; // [esp+24h] [ebp-4h]

  v5 = (unsigned __int16)word_815AB80[6 * a1];
  v3 = sub_8075A60(s2);
  v7 = &word_8294000[8 * sub_807C084(v5, v3)];
  *((_DWORD *)v7 + 2) &= 0xFFFFFFE0;
  *((_DWORD *)v7 + 2) |= 6u;
  *((_DWORD *)v7 + 1) = a3;
  v6 = SL_GetString(s2, 0);
  v9 = sub_807C0CC(v5, v6);
  SL_RemoveRefToString(v6);
  v8 = &word_8294000[8 * v9];
  *((_DWORD *)v8 + 2) &= 0xFFFFFFE0;
  *((_DWORD *)v8 + 2) |= 6u;
  result = a3;
  *((_DWORD *)v8 + 1) = a3;
  return result;
}
// 815AB80: using guessed type __int16 word_815AB80[];
// 8294000: using guessed type __int16 word_8294000[];

//----- (0807E2EA) --------------------------------------------------------
int __cdecl sub_807E2EA(int a1, int a2)
{
  int v2; // eax
  int v5; // [esp+10h] [ebp-8h]
  int v6; // [esp+14h] [ebp-4h]

  v5 = (unsigned __int16)word_815AB80[6 * a1];
  v2 = sub_8078946(a2);
  v6 = FindVariable(v5, v2);
  if ( v6 )
    return dword_8294004[4 * v6];
  else
    return -1;
}
// 815AB80: using guessed type __int16 word_815AB80[];
// 8294004: using guessed type int dword_8294004[];

//----- (0807E346) --------------------------------------------------------
int __cdecl sub_807E346(int a1, int a2)
{
  int v4; // [esp+10h] [ebp-8h]

  v4 = FindArrayVariable((unsigned __int16)word_815AB82[6 * a2], a1);
  if ( v4 )
    return *(_DWORD *)&word_8294000[8 * v4 + 2];
  else
    return 0;
}
// 815AB82: using guessed type __int16 word_815AB82[];
// 8294000: using guessed type __int16 word_8294000[];

//----- (0807E3A6) --------------------------------------------------------
int __cdecl sub_807E3A6(int a1, int a2)
{
  __int16 *v4; // [esp+18h] [ebp-10h]
  int v5; // [esp+1Ch] [ebp-Ch]

  v4 = &word_8294000[8 * sub_807C060((unsigned __int16)word_815AB82[6 * a2], a1)];
  if ( (*((_DWORD *)v4 + 2) & 0x1F) != 0 )
    return *((_DWORD *)v4 + 1);
  v5 = sub_807B5EA(a2, a1);
  *((_DWORD *)v4 + 2) |= 1u;
  *((_DWORD *)v4 + 1) = v5;
  return v5;
}
// 815AB82: using guessed type __int16 word_815AB82[];
// 8294000: using guessed type __int16 word_8294000[];

//----- (0807E43A) --------------------------------------------------------
int __cdecl sub_807E43A(int a1, int *a2)
{
  char *v2; // eax
  char *v3; // eax
  int v6; // [esp+14h] [ebp-4h]

  if ( a2[1] == 6 )
  {
    if ( IsValidArrayIndex(*a2) )
    {
      return sub_807C060(a1, *a2);
    }
    else
    {
      v2 = va("array index %d out of range", *a2);
      Scr_Error((int)v2);
      return 0;
    }
  }
  else if ( a2[1] == 2 )
  {
    v6 = sub_807C0A8(a1, *a2);
    SL_RemoveRefToString(*a2);
    return v6;
  }
  else
  {
    v3 = va("%s is not an array index", *(const char **)&off_815ABC0[4 * a2[1]]);
    Scr_Error((int)v3);
    return 0;
  }
}

//----- (0807E502) --------------------------------------------------------
int __cdecl Scr_FindArrayIndex(int a1, int *a2)
{
  char *v2; // eax
  char *v3; // eax
  int v6; // [esp+14h] [ebp-4h]

  if ( a2[1] == 6 )
  {
    if ( IsValidArrayIndex(*a2) )
    {
      return FindArrayVariable(a1, *a2);
    }
    else
    {
      v2 = va("array index %d out of range", *a2);
      Scr_Error((int)v2);
      AddRefToObject(a1);
      return 0;
    }
  }
  else if ( a2[1] == 2 )
  {
    v6 = FindVariable(a1, *a2);
    SL_RemoveRefToString(*a2);
    return v6;
  }
  else
  {
    v3 = va("%s is not an array index", *(const char **)&off_815ABC0[4 * a2[1]]);
    Scr_Error((int)v3);
    AddRefToObject(a1);
    return 0;
  }
}

//----- (0807E5E0) --------------------------------------------------------
void __cdecl Scr_EvalArray(int *a1, int *a2)
{
  char *v2; // eax
  char *v3; // eax
  char *v4; // eax
  char *v5; // eax
  char *v6; // eax
  int v7; // eax
  int v8; // edx
  char *v9; // eax
  int v10; // [esp+14h] [ebp-24h]
  int v11[3]; // [esp+18h] [ebp-20h] BYREF
  char s2[2]; // [esp+26h] [ebp-12h] BYREF
  char *s; // [esp+28h] [ebp-10h]
  __int16 *v14; // [esp+2Ch] [ebp-Ch]

  v10 = a1[1];
  if ( v10 == 2 )
  {
    if ( a2[1] == 6 )
    {
      if ( *a2 < 0 || (s = (char *)SL_ConvertToString(*a1), *a2 >= strlen(s)) )
      {
        v2 = va("string index %d out of range", *a2);
        Scr_Error((int)v2);
      }
      else
      {
        a2[1] = 2;
        s2[0] = s[*a2];
        s2[1] = 0;
        *a2 = SL_GetStringOfLen(s2, 0, 2u);
        SL_RemoveRefToString(*a1);
      }
    }
    else
    {
      v3 = va("%s is not a string index", *(const char **)&off_815ABC0[4 * a2[1]]);
      Scr_Error((int)v3);
    }
  }
  else if ( v10 > 2 )
  {
    if ( v10 != 4 )
      goto LABEL_21;
    if ( a2[1] == 6 )
    {
      if ( (unsigned int)*a2 > 2 )
      {
        v4 = va("vector index %d out of range", *a2);
        Scr_Error((int)v4);
      }
      else
      {
        a2[1] = 5;
        *a2 = *(_DWORD *)(*a1 + 4 * *a2);
        RemoveRefToVector(*a1);
      }
    }
    else
    {
      v5 = va("%s is not a vector index", *(const char **)&off_815ABC0[4 * a2[1]]);
      Scr_Error((int)v5);
    }
  }
  else
  {
    if ( v10 != 1 )
    {
LABEL_21:
      dword_8394014 = 1;
      v9 = va("%s is not an array, string, or vector", *(const char **)&off_815ABC0[4 * a1[1]]);
      Scr_Error((int)v9);
      return;
    }
    v14 = &word_8294000[8 * *a1];
    if ( (*((_DWORD *)v14 + 2) & 0x1F) == 22 )
    {
      v7 = Scr_FindArrayIndex(*a1, a2);
      sub_807C66A(v11, v7);
      v8 = v11[1];
      *a2 = v11[0];
      a2[1] = v8;
      RemoveRefToObject(*a1);
    }
    else
    {
      dword_8394014 = 1;
      v6 = va("%s is not an array", *(const char **)&off_815ABC0[4 * (*((_DWORD *)v14 + 2) & 0x1F)]);
      Scr_Error((int)v6);
    }
  }
}
// 8294000: using guessed type __int16 word_8294000[];
// 8394014: using guessed type int dword_8394014;

//----- (0807E856) --------------------------------------------------------
int __cdecl Scr_EvalArrayRef(int a1)
{
  __int16 *v1; // ebx
  char *v2; // eax
  char *v3; // eax
  int v6; // [esp+18h] [ebp-30h] BYREF
  int v7; // [esp+1Ch] [ebp-2Ch]
  int v8; // [esp+24h] [ebp-24h]
  int v9; // [esp+28h] [ebp-20h] BYREF
  int v10; // [esp+2Ch] [ebp-1Ch]
  int v11; // [esp+30h] [ebp-18h]
  __int16 *v12; // [esp+34h] [ebp-14h]
  __int16 *v13; // [esp+38h] [ebp-10h]
  __int16 *v14; // [esp+3Ch] [ebp-Ch]

  if ( a1 != 65534 )
  {
    v14 = &word_8294000[8 * a1];
    v10 = *((_DWORD *)v14 + 2) & 0x1F;
    if ( v10 )
    {
      v9 = *((_DWORD *)v14 + 1);
      goto LABEL_12;
    }
LABEL_10:
    *((_DWORD *)v14 + 2) |= 1u;
    v1 = v14;
    *((_DWORD *)v1 + 1) = sub_807B658();
    return *((_DWORD *)v14 + 1);
  }
  v12 = &word_8294000[8 * dword_8394040];
  v8 = FindArrayVariable((unsigned __int16)word_815AB80[6 * (*((_DWORD *)v12 + 2) >> 8)], dword_8394044);
  if ( !v8
    || (sub_8084ECA(&v6, (char *)(*((_DWORD *)v12 + 2) >> 8), (unsigned __int16)v12[3], dword_8294004[4 * v8]),
        v9 = v6,
        (v10 = v7) == 0) )
  {
    v14 = &word_8294000[8 * sub_807C0CC(dword_8394040, dword_8394044)];
    goto LABEL_10;
  }
  if ( v10 == 1 && !LOWORD(dword_8294004[4 * v9]) )
  {
    RemoveRefToValue(&v9);
    dword_8394014 = 1;
    Scr_Error((int)"read-only array cannot be changed");
    return 0;
  }
  RemoveRefToValue(&v9);
  v14 = 0;
LABEL_12:
  if ( v10 == 1 )
  {
    v13 = &word_8294000[8 * v9];
    if ( (*((_DWORD *)v13 + 2) & 0x1F) == 22 )
    {
      if ( v13[2] )
      {
        v11 = v9;
        RemoveRefToObject(v9);
        v9 = sub_807B658();
        sub_807C2F6(v11, v9);
        *((_DWORD *)v14 + 1) = v9;
      }
      return v9;
    }
    else
    {
      dword_8394014 = 1;
      v3 = va("%s is not an array", *(const char **)&off_815ABC0[4 * (*((_DWORD *)v13 + 2) & 0x1F)]);
      Scr_Error((int)v3);
      return 0;
    }
  }
  else
  {
    dword_8394014 = 1;
    if ( v10 == 2 )
    {
      Scr_Error((int)"string characters cannot be individually changed");
      return 0;
    }
    else
    {
      if ( v10 == 4 )
      {
        Scr_Error((int)"vector components cannot be individually changed");
      }
      else
      {
        v2 = va("%s is not an array", *(const char **)&off_815ABC0[4 * v10]);
        Scr_Error((int)v2);
      }
      return 0;
    }
  }
}
// 815AB80: using guessed type __int16 word_815AB80[];
// 8294000: using guessed type __int16 word_8294000[];
// 8294004: using guessed type int dword_8294004[];
// 8394014: using guessed type int dword_8394014;
// 8394040: using guessed type int dword_8394040;
// 8394044: using guessed type int dword_8394044;

//----- (0807EB00) --------------------------------------------------------
void __cdecl sub_807EB00(int a1, int *a2)
{
  char *v2; // eax
  char *v3; // eax
  char *v4; // eax
  char *v5; // eax
  int v6; // [esp+10h] [ebp-28h] BYREF
  int v7; // [esp+14h] [ebp-24h]
  int v8; // [esp+1Ch] [ebp-1Ch]
  int v9; // [esp+20h] [ebp-18h] BYREF
  int v10; // [esp+24h] [ebp-14h]
  int v11; // [esp+28h] [ebp-10h]
  __int16 *v12; // [esp+2Ch] [ebp-Ch]
  __int16 *v13; // [esp+30h] [ebp-8h]
  __int16 *v14; // [esp+34h] [ebp-4h]

  if ( a1 == 65534 )
  {
    v12 = &word_8294000[8 * dword_8394040];
    v8 = FindArrayVariable((unsigned __int16)word_815AB80[6 * (*((_DWORD *)v12 + 2) >> 8)], dword_8394044);
    if ( !v8
      || (sub_8084ECA(&v6, (char *)(*((_DWORD *)v12 + 2) >> 8), (unsigned __int16)v12[3], dword_8294004[4 * v8]),
          v9 = v6,
          (v10 = v7) == 0) )
    {
      v10 = 0;
LABEL_11:
      dword_8394014 = 1;
      v2 = va("%s is not an array", *(const char **)&off_815ABC0[4 * v10]);
      Scr_Error((int)v2);
      return;
    }
    if ( v10 == 1 && !LOWORD(dword_8294004[4 * v9]) )
    {
      RemoveRefToValue(&v9);
      dword_8394014 = 1;
      Scr_Error((int)"read-only array cannot be changed");
      return;
    }
    RemoveRefToValue(&v9);
    v14 = 0;
  }
  else
  {
    v14 = &word_8294000[8 * a1];
    v10 = *((_DWORD *)v14 + 2) & 0x1F;
    v9 = *((_DWORD *)v14 + 1);
  }
  if ( v10 != 1 )
    goto LABEL_11;
  v13 = &word_8294000[8 * v9];
  if ( (*((_DWORD *)v13 + 2) & 0x1F) == 22 )
  {
    if ( v13[2] )
    {
      v11 = v9;
      RemoveRefToObject(v9);
      v9 = sub_807B658();
      sub_807C2F6(v11, v9);
      *((_DWORD *)v14 + 1) = v9;
    }
    if ( a2[1] == 6 )
    {
      if ( IsValidArrayIndex(*a2) )
      {
        sub_807C248(v9, *a2);
      }
      else
      {
        v4 = va("array index %d out of range", *a2);
        Scr_Error((int)v4);
      }
    }
    else if ( a2[1] == 2 )
    {
      SL_RemoveRefToString(*a2);
      sub_807C290(v9, *a2);
    }
    else
    {
      v5 = va("%s is not an array index", *(const char **)&off_815ABC0[4 * a2[1]]);
      Scr_Error((int)v5);
    }
  }
  else
  {
    dword_8394014 = 1;
    v3 = va("%s is not an array", *(const char **)&off_815ABC0[4 * (*((_DWORD *)v13 + 2) & 0x1F)]);
    Scr_Error((int)v3);
  }
}
// 815AB80: using guessed type __int16 word_815AB80[];
// 8294000: using guessed type __int16 word_8294000[];
// 8294004: using guessed type int dword_8294004[];
// 8394014: using guessed type int dword_8394014;
// 8394040: using guessed type int dword_8394040;
// 8394044: using guessed type int dword_8394044;

//----- (0807ED9A) --------------------------------------------------------
int __cdecl sub_807ED9A(int a1)
{
  int v2[2]; // [esp+10h] [ebp-8h] BYREF

  v2[1] = 1;
  v2[0] = sub_807B658();
  return sub_807C45C(a1, v2);
}

//----- (0807EDC4) --------------------------------------------------------
_WORD *__userpurge sub_807EDC4@<eax>(_WORD *a1, int a2)
{
  *a1 = word_8294000[8 * a2 + 3];
  a1[1] = *(_DWORD *)&word_8294000[8 * a2 + 4] >> 8;
  return a1;
}
// 8294000: using guessed type __int16 word_8294000[];

//----- (0807EDFC) --------------------------------------------------------
int __cdecl sub_807EDFC(int a1, int a2)
{
  int result; // eax
  int v3; // [esp+10h] [ebp-18h]
  __int16 *v4; // [esp+14h] [ebp-14h]
  __int16 *v5; // [esp+18h] [ebp-10h]
  unsigned int v6; // [esp+1Ch] [ebp-Ch]
  int i; // [esp+20h] [ebp-8h]

  result = sub_807C9CE(a1);
  for ( i = result; i; i = result )
  {
    v5 = &word_8294000[8 * i];
    v6 = *((_DWORD *)v5 + 2) >> 8;
    if ( v6 != 131070 )
    {
      v4 = &word_8294000[8 * sub_807C0A8(a2, v6)];
      v3 = *((_DWORD *)v5 + 2) & 0x1F;
      *((_DWORD *)v4 + 2) |= v3;
      *((_DWORD *)v4 + 1) = *((_DWORD *)v5 + 1);
      sub_807BA14(v3, *((_DWORD *)v4 + 1));
    }
    result = sub_807C9CE(i);
  }
  return result;
}
// 8294000: using guessed type __int16 word_8294000[];

//----- (0807EECE) --------------------------------------------------------
int __cdecl sub_807EECE(int a1, int a2, int a3)
{
  int result; // eax
  int v4; // eax
  int v5; // [esp+14h] [ebp-4h]

  result = sub_807E346(a1, a3);
  v5 = result;
  if ( result )
  {
    result = sub_807C9CE(result);
    if ( result )
    {
      v4 = sub_807E3A6(a2, a3);
      return sub_807EDFC(v5, v4);
    }
  }
  return result;
}

//----- (0807EF24) --------------------------------------------------------
long double __cdecl Scr_GetEntryUsage(int a1, int a2)
{
  if ( a1 == 1 && (*(_DWORD *)&word_8294000[8 * a2 + 4] & 0x1F) == 22 )
    return (float)(Scr_GetObjectUsage(a2) / ((long double)(unsigned __int16)word_8294000[8 * a2 + 2] + 1.0));
  else
    return (float)0.0;
}
// 807F006: using guessed type double __cdecl Scr_GetObjectUsage(_DWORD);
// 8294000: using guessed type __int16 word_8294000[];

//----- (0807EF84) --------------------------------------------------------
long double __cdecl sub_807EF84(int a1)
{
  return Scr_GetEntryUsage(*(_DWORD *)(a1 + 8) & 0x1F, *(_DWORD *)(a1 + 4)) + 1.0;
}

//----- (0807EFAE) --------------------------------------------------------
long double __cdecl Scr_GetEndonUsage(int a1)
{
  int v1; // eax
  int v4; // [esp+10h] [ebp-8h]

  v4 = sub_807BB58(dword_8394020, a1);
  if ( v4 )
  {
    v1 = sub_807CB1E(v4);
    return (float)Scr_GetObjectUsage(v1);
  }
  else
  {
    return (float)0.0;
  }
}
// 8394020: using guessed type int dword_8394020;

//----- (0807F006) --------------------------------------------------------
long double __cdecl Scr_GetObjectUsage(int a1)
{
  float v2; // [esp+Ch] [ebp-Ch]
  int i; // [esp+10h] [ebp-8h]

  v2 = 1.0;
  for ( i = sub_807C9CE(a1); i; i = sub_807C9CE(i) )
    v2 = sub_807EF84(16 * i + 136921088) + v2;
  return v2;
}

//----- (0807F072) --------------------------------------------------------
long double __cdecl Scr_GetThreadUsage(int a1, float *a2)
{
  int v3; // [esp+18h] [ebp-20h]
  float v4; // [esp+1Ch] [ebp-1Ch]
  int v5; // [esp+24h] [ebp-14h]
  _BYTE *v6; // [esp+28h] [ebp-10h]
  int *v7; // [esp+28h] [ebp-10h]
  int v8; // [esp+2Ch] [ebp-Ch]

  v5 = *(unsigned __int16 *)(a1 + 4);
  v6 = (_BYTE *)(5 * v5 + a1 + 11);
  v4 = Scr_GetObjectUsage(*(unsigned __int16 *)(a1 + 8));
  *a2 = Scr_GetEndonUsage(*(unsigned __int16 *)(a1 + 8));
  v3 = *(unsigned __int16 *)(a1 + 8);
  while ( v5 )
  {
    v7 = (int *)(v6 - 4);
    v8 = *v7;
    v6 = (char *)v7 - 1;
    --v5;
    if ( *v6 == 7 )
    {
      v3 = GetParentLocalId(v3);
      v4 = Scr_GetObjectUsage(v3) + v4;
      *a2 = Scr_GetEndonUsage(v3) + *a2;
    }
    else
    {
      v4 = Scr_GetEntryUsage((unsigned __int8)*v6, v8) + v4;
    }
  }
  return v4;
}

//----- (0807F168) --------------------------------------------------------
int __cdecl sub_807F168(char *s1, _DWORD *a2)
{
  size_t v4; // [esp+Ch] [ebp-Ch]
  int v5; // [esp+10h] [ebp-8h]
  char *s; // [esp+14h] [ebp-4h]
  char *sa; // [esp+14h] [ebp-4h]

  for ( s = (char *)dword_8394000; *s; s += v4 + 3 )
  {
    v4 = strlen(s) + 1;
    if ( !strcasecmp(s1, s) )
    {
      sa = &s[v4];
      v5 = *(unsigned __int16 *)sa;
      *a2 = sa[2];
      return v5;
    }
  }
  return 0;
}
// 8394000: using guessed type int dword_8394000;

//----- (0807F1EE) --------------------------------------------------------
int __cdecl Scr_AddFieldsForFile(char *src)
{
  char *v1; // eax
  char *v2; // eax
  char *v3; // eax
  size_t v4; // eax
  char *v5; // ebx
  char v7[4]; // [esp+18h] [ebp-30h] BYREF
  int v8; // [esp+1Ch] [ebp-2Ch] BYREF
  int i; // [esp+20h] [ebp-28h]
  int v10; // [esp+24h] [ebp-24h]
  int v11; // [esp+28h] [ebp-20h]
  int v12; // [esp+2Ch] [ebp-1Ch]
  char *dest; // [esp+30h] [ebp-18h]
  char *s1; // [esp+34h] [ebp-14h]
  char *v15; // [esp+38h] [ebp-10h] BYREF
  char *v16; // [esp+3Ch] [ebp-Ch]
  int v17; // [esp+40h] [ebp-8h]

  v17 = FS_FOpenFileByMode(src, (int *)v7, 0);
  if ( v17 < 0 )
  {
    v1 = va((char *)&byte_81400D1, src);
    Com_Error(1, v1);
  }
  v16 = (char *)Hunk_AllocateTempMemoryHighInternal(v17 + 1);
  FS_Read((int)v16, v17, *(int *)v7);
  v16[v17] = 0;
  FS_FCloseFile(*(int *)v7);
  v15 = v16;
  Com_BeginParseSession("Scr_AddFields");
  while ( 1 )
  {
    s1 = Com_Parse(&v15);
    if ( !v15 )
      break;
    if ( !strcmp(s1, "float") )
    {
      v12 = 5;
    }
    else if ( !strcmp(s1, "int") )
    {
      v12 = 6;
    }
    else if ( !strcmp(s1, "string") )
    {
      v12 = 2;
    }
    else
    {
      if ( strcmp(s1, "vector") )
      {
        v2 = va((char *)&byte_81400F1, s1, src);
        Com_Error(1, v2);
      }
      v12 = 4;
    }
    s1 = Com_Parse(&v15);
    if ( !v15 )
    {
      v3 = va((char *)&byte_814010C, src);
      Com_Error(1, v3);
    }
    v4 = strlen(s1);
    v17 = v4 + 1;
    for ( i = v4; i >= 0; --i )
    {
      v5 = &s1[i];
      *v5 = tolower(s1[i]);
    }
    v11 = sub_8075A60(s1);
    if ( sub_807F168(s1, &v8) )
      Com_Error(1, (char *)&byte_8140128, s1, src);
    v10 = v17 + 3;
    dest = (char *)TempMalloc(v17 + 3);
    strcpy(dest, s1);
    dest += v17;
    *(_WORD *)dest = v11;
    dest += 2;
    *dest++ = v12;
    *dest = 0;
  }
  Com_EndParseSession();
  return Hunk_ClearTempMemoryHighInternal();
}

//----- (0807F47A) --------------------------------------------------------
int __cdecl Scr_AddFields(const char *a1, char *a2)
{
  char s[68]; // [esp+30h] [ebp-58h] BYREF
  int i; // [esp+74h] [ebp-14h]
  void *ptr; // [esp+78h] [ebp-10h]
  int v6[3]; // [esp+7Ch] [ebp-Ch] BYREF

  ptr = FS_ListFiles((int)a1, a2, 0, v6);
  TempMemoryReset();
  dword_8394000 = (int)Hunk_AllocLowInternal(0);
  *(_BYTE *)dword_8394000 = 0;
  for ( i = 0; i < v6[0]; ++i )
  {
    sprintf(s, "%s/%s", a1, *((const char **)ptr + i));
    Scr_AddFieldsForFile(s);
  }
  if ( ptr )
    FS_FreeFileList((void **)ptr);
  *(_BYTE *)TempMalloc(1) = 0;
  return Hunk_ConvertTempToPermLowInternal();
}
// 8394000: using guessed type int dword_8394000;
// 807F47A: using guessed type int var_C[3];

//----- (0807F554) --------------------------------------------------------
int __cdecl sub_807F554(int a1)
{
  return RemoveRefToObject(a1);
}

//----- (0807F568) --------------------------------------------------------
int __cdecl sub_807F568(int a1)
{
  int v3; // [esp+1Ch] [ebp-Ch]
  int i; // [esp+20h] [ebp-8h]

  if ( (*(_DWORD *)&word_8294000[8 * a1 + 4] & 0x1F) != 22 )
    return 0;
LABEL_3:
  for ( i = sub_807C9CE(a1); i; i = sub_807C9CE(i) )
  {
    v3 = *(_DWORD *)&word_8294000[8 * i + 4] >> 8;
    switch ( *(_DWORD *)&word_8294000[8 * i + 4] & 0x1F )
    {
      case 1:
        if ( !sub_807F568(*(_DWORD *)&word_8294000[8 * i + 2]) )
          goto LABEL_6;
        break;
      case 7:
      case 8:
      case 9:
      case 0xA:
      case 0xB:
LABEL_6:
        sub_807C16E(a1, v3);
        goto LABEL_3;
      default:
        continue;
    }
  }
  return 1;
}
// 8294000: using guessed type __int16 word_8294000[];

//----- (0807F64C) --------------------------------------------------------
void sub_807F64C()
{
  if ( !dword_8394028 )
  {
    dword_8394028 = sub_807B562();
    sub_807ED9A(dword_8394028);
  }
}
// 8394028: using guessed type int dword_8394028;

//----- (0807F676) --------------------------------------------------------
int __cdecl sub_807F676(int a1)
{
  int result; // eax

  if ( !a1 )
    return sub_807F568(*(_DWORD *)&word_8294000[8 * dword_8394028 + 2]);
  result = sub_807B778(dword_8394028);
  dword_8394028 = 0;
  return result;
}
// 8294000: using guessed type __int16 word_8294000[];
// 8394028: using guessed type int dword_8394028;

//----- (0807F6F2) --------------------------------------------------------
int __cdecl sub_807F6F2(char a1)
{
  int i; // [esp+4h] [ebp-8h]

  for ( i = 0; i <= 3; ++i )
  {
    if ( byte_815AB84[12 * i] == a1 )
      return i;
  }
  return -1;
}

//----- (0807F740) --------------------------------------------------------
int sub_807F740()
{
  return sub_807B658();
}

//----- (0807F74E) --------------------------------------------------------
int __cdecl sub_807F74E(int a1, char *s)
{
  int v4; // [esp+14h] [ebp-14h]
  int v5[3]; // [esp+18h] [ebp-10h] BYREF
  int v6; // [esp+24h] [ebp-4h]

  v6 = sub_80793D2(s, 0);
  if ( FindVariable(a1, v6) )
  {
    SL_RemoveRefToString(v6);
    return 0;
  }
  else
  {
    v4 = sub_807C0A8(a1, v6);
    SL_RemoveRefToString(v6);
    v5[1] = 6;
    v5[0] = 0;
    sub_807C45C(v4, v5);
    return 1;
  }
}

//----- (0807F7E0) --------------------------------------------------------
int __cdecl sub_807F7E0(int a1)
{
  return RemoveRefToObject(a1);
}

//----- (0807F7F4) --------------------------------------------------------
long double __cdecl sub_807F7F4(float a1)
{
  return (float)fabs(a1);
}

//----- (0807F810) --------------------------------------------------------
void sub_807F810()
{
  *(_DWORD *)dword_8394010 = 0;
  dword_83D5590 = 0;
  dword_8394014 = 0;
}
// 8394014: using guessed type int dword_8394014;
// 83D5590: using guessed type int dword_83D5590;

//----- (0807F834) --------------------------------------------------------
int sub_807F834()
{
  int result; // eax

  dword_83D7604 = (int)&unk_83DB918;
  dword_83D7610 = (int)&unk_83D7920;
  dword_83D7608 = 0;
  dword_83D760C = (int)dword_83D7620;
  dword_83D7600 = (int)&dword_83D5598;
  byte_839400C = 0;
  byte_83D7614 = 0;
  sub_807F810();
  byte_83D7616 = 0;
  dword_83D761C = 0;
  dword_83D7618 = 0;
  result = sub_807B562();
  dword_8394034 = result;
  dword_839401C = 0;
  dword_8394020 = 0;
  dword_8394024 = 0;
  dword_8394028 = 0;
  dword_839402C = 0;
  dword_8394030 = 0;
  dword_83D7924 = 7;
  dword_83D5594 = 0;
  return result;
}
// 839400C: using guessed type char byte_839400C;
// 839401C: using guessed type int dword_839401C;
// 8394020: using guessed type int dword_8394020;
// 8394024: using guessed type int dword_8394024;
// 8394028: using guessed type int dword_8394028;
// 839402C: using guessed type int dword_839402C;
// 8394030: using guessed type int dword_8394030;
// 8394034: using guessed type int dword_8394034;
// 83D5594: using guessed type int dword_83D5594;
// 83D5598: using guessed type int dword_83D5598;
// 83D7600: using guessed type int dword_83D7600;
// 83D7604: using guessed type int dword_83D7604;
// 83D7608: using guessed type int dword_83D7608;
// 83D760C: using guessed type int dword_83D760C;
// 83D7610: using guessed type int dword_83D7610;
// 83D7614: using guessed type char byte_83D7614;
// 83D7616: using guessed type char byte_83D7616;
// 83D7618: using guessed type int dword_83D7618;
// 83D761C: using guessed type int dword_83D761C;
// 83D7620: using guessed type int dword_83D7620[];
// 83D7924: using guessed type int dword_83D7924;

//----- (0807F8F6) --------------------------------------------------------
int sub_807F8F6()
{
  int result; // eax

  if ( dword_8394034 )
  {
    result = sub_807B778(dword_8394034);
    dword_8394034 = 0;
  }
  return result;
}
// 8394034: using guessed type int dword_8394034;

//----- (0807F91E) --------------------------------------------------------
int Scr_Init()
{
  int result; // eax

  if ( !byte_8394038 )
  {
    sub_8078AB2();
    sub_807A368();
    result = sub_807F834();
    byte_8202A64 = 0;
    byte_8202858 = 0;
    dword_8202A4C = 0;
    dword_8202A48 = 0;
    dword_8202440 = 0;
    dword_8202A54 = 0;
    dword_8202A50 = 0;
    byte_8394038 = 1;
  }
  return result;
}
// 8202440: using guessed type int dword_8202440;
// 8202858: using guessed type char byte_8202858;
// 8202A48: using guessed type int dword_8202A48;
// 8202A4C: using guessed type int dword_8202A4C;
// 8202A50: using guessed type int dword_8202A50;
// 8202A54: using guessed type int dword_8202A54;
// 8202A64: using guessed type char byte_8202A64;
// 8394038: using guessed type char byte_8394038;

//----- (0807F988) --------------------------------------------------------
bool __cdecl sub_807F988(int a1, int a2, int a3)
{
  bool result; // al

  byte_839400A = a1 != 0;
  byte_839400B = a2 != 0;
  result = a3 != 0;
  byte_83D7615 = a3 != 0;
  return result;
}
// 839400A: using guessed type char byte_839400A;
// 839400B: using guessed type char byte_839400B;
// 83D7615: using guessed type char byte_83D7615;

//----- (0807F9B2) --------------------------------------------------------
void Scr_Shutdown()
{
  if ( byte_8394038 )
  {
    byte_8394038 = 0;
    sub_807F8F6();
    sub_807A3B6();
    sub_8078AD0();
  }
}
// 8394038: using guessed type char byte_8394038;

//----- (0807F9DC) --------------------------------------------------------
void Scr_Abort()
{
  dword_839401C = 0;
  byte_8394038 = 0;
}
// 839401C: using guessed type int dword_839401C;
// 8394038: using guessed type char byte_8394038;

//----- (0807F9F2) --------------------------------------------------------
int __cdecl sub_807F9F2(int a1)
{
  int result; // eax

  result = a1;
  dword_83D5594 = a1;
  return result;
}
// 83D5594: using guessed type int dword_83D5594;

//----- (0807FA00) --------------------------------------------------------
void sub_807FA00()
{
  if ( !byte_839400C && !byte_8202A64 )
  {
    if ( byte_839400A && dword_83D5594 )
      byte_83D7616 = 1;
    if ( dword_83D7608 || byte_83D7614 )
      longjmp((struct __jmp_buf_tag *)(156 * dword_83D553C + 138232096), -1);
LABEL_11:
    Com_Error(1, (char *)&byte_8140180, *(_DWORD *)dword_8394010);
  }
  if ( byte_83D7616 )
    goto LABEL_11;
}
// 8202A64: using guessed type char byte_8202A64;
// 839400A: using guessed type char byte_839400A;
// 839400C: using guessed type char byte_839400C;
// 83D553C: using guessed type int dword_83D553C;
// 83D5594: using guessed type int dword_83D5594;
// 83D7608: using guessed type int dword_83D7608;
// 83D7614: using guessed type char byte_83D7614;
// 83D7616: using guessed type char byte_83D7616;

//----- (0807FA9C) --------------------------------------------------------
int sub_807FA9C()
{
  int result; // eax

  while ( dword_83D761C )
  {
    result = RemoveRefToValue((_DWORD *)dword_83D7610);
    dword_83D7610 -= 8;
    --dword_83D761C;
  }
  return result;
}
// 83D7610: using guessed type int dword_83D7610;
// 83D761C: using guessed type int dword_83D761C;

//----- (0807FACC) --------------------------------------------------------
int sub_807FACC()
{
  sub_807C5E2(dword_8394034);
  return sub_807CA86(dword_8394034);
}
// 8394034: using guessed type int dword_8394034;

//----- (0807FAEE) --------------------------------------------------------
int sub_807FAEE()
{
  sub_807C5E2(dword_8394034);
  return dword_8394034;
}
// 8394034: using guessed type int dword_8394034;

//----- (0807FB08) --------------------------------------------------------
int __cdecl sub_807FB08(unsigned __int8 *a1, int a2, int a3, _DWORD *a4, char *a5)
{
  int v5; // edx
  _DWORD *v6; // ecx
  int v7; // edx
  _DWORD *v8; // ecx
  int v9; // edx
  _DWORD *v10; // ebx
  _DWORD *v11; // ebx
  int *v12; // ebx
  float *v13; // ebx
  _DWORD *v14; // ebx
  _DWORD *v15; // ebx
  int *v16; // ebx
  int *v17; // ebx
  _DWORD *v18; // ebx
  int v19; // edx
  int *v20; // ebx
  int *v21; // ebx
  unsigned __int16 v22; // ax
  _DWORD *v23; // ebx
  int v24; // edx
  _DWORD *v25; // esi
  int v26; // eax
  int v27; // edx
  _DWORD *v28; // esi
  int v29; // eax
  int v30; // edx
  _DWORD *v31; // esi
  int v32; // eax
  int v33; // edx
  _DWORD *v34; // esi
  int v35; // eax
  int v36; // edx
  _DWORD *v37; // esi
  int v38; // eax
  int v39; // edx
  _DWORD *v40; // esi
  int v41; // eax
  int v42; // edx
  _DWORD *v43; // esi
  int v44; // eax
  int v45; // edx
  int v46; // eax
  int *v47; // ebx
  _DWORD *v48; // ebx
  unsigned __int16 v49; // ax
  int v50; // eax
  int v51; // edx
  _DWORD *v52; // esi
  unsigned __int16 v53; // ax
  int v54; // edx
  unsigned __int16 v55; // ax
  unsigned __int16 v56; // ax
  unsigned __int16 v57; // ax
  int v58; // eax
  int v59; // eax
  unsigned __int16 v60; // ax
  int v61; // eax
  unsigned __int16 v62; // ax
  int v63; // eax
  char *v64; // eax
  char *v65; // eax
  char *v66; // eax
  int v67; // eax
  int v68; // eax
  char *v69; // eax
  char *v70; // eax
  int v71; // eax
  int v72; // eax
  char *v73; // eax
  int v74; // eax
  int v75; // eax
  char *v76; // eax
  int v77; // eax
  _DWORD *v78; // ebx
  int v79; // edx
  char *v80; // eax
  _DWORD *v81; // ebx
  int v82; // edx
  char *v83; // eax
  int v84; // eax
  int v85; // eax
  int v86; // eax
  int v87; // eax
  int v88; // eax
  int v89; // eax
  int v90; // eax
  int v91; // eax
  int v92; // eax
  int v93; // eax
  int v94; // eax
  int v95; // eax
  int v96; // eax
  int v97; // eax
  char *v98; // eax
  char *v99; // eax
  int *v100; // ebx
  _DWORD *v101; // ebx
  _DWORD *v102; // ebx
  unsigned __int16 v103; // ax
  int v104; // eax
  int v105; // edx
  unsigned __int16 v106; // ax
  char *v107; // eax
  float v109; // [esp+0h] [ebp-128h]
  int v110; // [esp+20h] [ebp-108h]
  int v112[2]; // [esp+28h] [ebp-100h] BYREF
  int v113[2]; // [esp+30h] [ebp-F8h] BYREF
  int v114[3]; // [esp+38h] [ebp-F0h] BYREF
  int v115; // [esp+44h] [ebp-E4h] BYREF
  int v116[2]; // [esp+48h] [ebp-E0h] BYREF
  int v117[2]; // [esp+50h] [ebp-D8h] BYREF
  int v118[2]; // [esp+58h] [ebp-D0h] BYREF
  int v119[2]; // [esp+60h] [ebp-C8h] BYREF
  int v120[2]; // [esp+68h] [ebp-C0h] BYREF
  int v121[2]; // [esp+70h] [ebp-B8h] BYREF
  int v122[2]; // [esp+78h] [ebp-B0h] BYREF
  int v123[2]; // [esp+80h] [ebp-A8h] BYREF
  int v124[2]; // [esp+88h] [ebp-A0h] BYREF
  int v125[2]; // [esp+90h] [ebp-98h] BYREF
  int v126[2]; // [esp+98h] [ebp-90h] BYREF
  int v127; // [esp+A0h] [ebp-88h]
  int v128; // [esp+A4h] [ebp-84h]
  int v129; // [esp+A8h] [ebp-80h] BYREF
  int v130; // [esp+ACh] [ebp-7Ch]
  int v131; // [esp+B4h] [ebp-74h]
  unsigned __int8 *v132; // [esp+B8h] [ebp-70h]
  int v133; // [esp+BCh] [ebp-6Ch]
  int v134; // [esp+C0h] [ebp-68h]
  int v135; // [esp+C4h] [ebp-64h]
  int v136; // [esp+C8h] [ebp-60h]
  unsigned __int8 v137; // [esp+CFh] [ebp-59h]
  int v138; // [esp+D0h] [ebp-58h]
  int v139; // [esp+D4h] [ebp-54h]
  int v140; // [esp+D8h] [ebp-50h]
  int v141; // [esp+DCh] [ebp-4Ch]
  unsigned int v142; // [esp+E0h] [ebp-48h]
  int v143; // [esp+E4h] [ebp-44h]
  int v144; // [esp+E8h] [ebp-40h]
  int v145; // [esp+ECh] [ebp-3Ch]
  unsigned __int8 *v146; // [esp+F0h] [ebp-38h]
  unsigned int v147; // [esp+F4h] [ebp-34h]
  int v148; // [esp+F8h] [ebp-30h]
  int v149; // [esp+FCh] [ebp-2Ch]
  int v150; // [esp+100h] [ebp-28h] BYREF
  int v151; // [esp+104h] [ebp-24h]
  int i; // [esp+108h] [ebp-20h]
  int v153; // [esp+10Ch] [ebp-1Ch]
  int v154; // [esp+110h] [ebp-18h]
  int v155; // [esp+114h] [ebp-14h]

  v143 = 0;
  ++dword_83D553C;
  if ( __sigsetjmp((struct __jmp_buf_tag *)(156 * dword_83D553C + 138232096), 0) )
    goto LABEL_271;
  while ( 2 )
  {
    v144 = *a1++;
    switch ( v144 )
    {
      case 0:
        v142 = sub_807B1F0(a2);
        sub_807B25E(a2);
        dword_83D7600 -= 4 * a3;
        while ( a4[1] != 7 )
        {
          RemoveRefToValue(a4);
          a4 -= 2;
        }
        --dword_83D7608;
        dword_83D760C -= 24;
        if ( !v142 )
          goto LABEL_254;
        a4[1] = 0;
        goto LABEL_10;
      case 1:
        v142 = sub_807B1F0(a2);
        sub_807B25E(a2);
        dword_83D7600 -= 4 * a3;
        v5 = a4[1];
        v150 = *a4;
        v151 = v5;
        for ( a4 -= 2; a4[1] != 7; a4 -= 2 )
          RemoveRefToValue(a4);
        --dword_83D7608;
        dword_83D760C -= 24;
        if ( !v142 )
        {
          v6 = a4 + 2;
          v7 = v151;
          a4[2] = v150;
          v6[1] = v7;
          goto LABEL_255;
        }
        v8 = a4;
        v9 = v151;
        *a4 = v150;
        v8[1] = v9;
LABEL_10:
        RemoveRefToObject(a2);
        a1 = *(unsigned __int8 **)dword_83D760C;
        a3 = *(_DWORD *)(dword_83D760C + 8);
        a2 = v142;
        continue;
      case 2:
        a4 += 2;
        a4[1] = 0;
        continue;
      case 3:
        a4 += 2;
        a4[1] = 6;
        *a4 = 0;
        continue;
      case 4:
        a4 += 2;
        a4[1] = 6;
        *a4 = *a1++;
        continue;
      case 5:
        a4 += 2;
        a4[1] = 6;
        *a4 = -*a1++;
        continue;
      case 6:
        a4 += 2;
        a4[1] = 6;
        v10 = a4;
        *v10 = (unsigned __int16)sub_80851E6((_WORD **)&a1);
        continue;
      case 7:
        a4 += 2;
        a4[1] = 6;
        v11 = a4;
        *v11 = -(unsigned __int16)sub_80851E6((_WORD **)&a1);
        continue;
      case 8:
        a4 += 2;
        a4[1] = 6;
        v12 = a4;
        *v12 = sub_8085180((_DWORD **)&a1);
        continue;
      case 9:
        a4 += 2;
        a4[1] = 5;
        v13 = (float *)a4;
        *v13 = sub_8085210((_DWORD **)&a1);
        continue;
      case 10:
        a4 += 2;
        a4[1] = 2;
        v14 = a4;
        *v14 = (unsigned __int16)sub_80851E6((_WORD **)&a1);
        sub_807951E(*a4);
        continue;
      case 11:
        a4 += 2;
        a4[1] = 3;
        v15 = a4;
        *v15 = (unsigned __int16)sub_80851E6((_WORD **)&a1);
        sub_807951E(*a4);
        continue;
      case 12:
        a4 += 2;
        a4[1] = 4;
        v16 = a4;
        *v16 = sub_80851A2((int *)&a1);
        continue;
      case 13:
        v154 = dword_8394024;
        continue;
      case 14:
        v154 = dword_839402C;
        continue;
      case 15:
        a4 += 2;
        a4[1] = 1;
        v17 = a4;
        *v17 = sub_807B766(a2);
        AddRefToObject(*a4);
        continue;
      case 16:
        a4 += 2;
        a4[1] = 1;
        *a4 = dword_8394024;
        AddRefToObject(dword_8394024);
        continue;
      case 17:
        a4 += 2;
        v18 = a4;
        sub_807C66A(v126, dword_8394028);
        v19 = v126[1];
        *v18 = v126[0];
        v18[1] = v19;
        continue;
      case 18:
        a4 += 2;
        a4[1] = 1;
        *a4 = dword_839402C;
        AddRefToObject(dword_839402C);
        continue;
      case 19:
        a4 += 2;
        a4[1] = 11;
        v20 = a4;
        *v20 = sub_8085180((_DWORD **)&a1);
        continue;
      case 20:
        v155 = dword_8394028;
        continue;
      case 21:
        a4 += 2;
        a4[1] = 9;
        v21 = a4;
        *v21 = sub_8085238((_DWORD **)&a1);
        continue;
      case 22:
        dword_83D7600 += 4;
        ++a3;
        v22 = sub_80851E6((_WORD **)&a1);
        *(_DWORD *)dword_83D7600 = sub_807C0CC(a2, v22);
        continue;
      case 23:
        v137 = *a1++;
        dword_83D7600 -= 4 * v137;
        a3 -= v137;
        while ( v137 )
        {
          sub_807C1CC(a2);
          --v137;
        }
        continue;
      case 24:
        a4 += 2;
        v23 = a4;
        sub_807C66A(v125, *(_DWORD *)dword_83D7600);
        v24 = v125[1];
        *v23 = v125[0];
        v23[1] = v24;
        continue;
      case 25:
        a4 += 2;
        v25 = a4;
        v26 = sub_8085154(1);
        sub_807C66A(v124, v26);
        v27 = v124[1];
        *v25 = v124[0];
        v25[1] = v27;
        continue;
      case 26:
        a4 += 2;
        v28 = a4;
        v29 = sub_8085154(2);
        sub_807C66A(v123, v29);
        v30 = v123[1];
        *v28 = v123[0];
        v28[1] = v30;
        continue;
      case 27:
        a4 += 2;
        v31 = a4;
        v32 = sub_8085154(3);
        sub_807C66A(v122, v32);
        v33 = v122[1];
        *v31 = v122[0];
        v31[1] = v33;
        continue;
      case 28:
        a4 += 2;
        v34 = a4;
        v35 = sub_8085154(4);
        sub_807C66A(v121, v35);
        v36 = v121[1];
        *v34 = v121[0];
        v34[1] = v36;
        continue;
      case 29:
        a4 += 2;
        v37 = a4;
        v38 = sub_8085154(5);
        sub_807C66A(v120, v38);
        v39 = v120[1];
        *v37 = v120[0];
        v37[1] = v39;
        continue;
      case 30:
        a4 += 2;
        v40 = a4;
        v41 = sub_808516A(a1);
        sub_807C66A(v119, v41);
        v42 = v119[1];
        *v40 = v119[0];
        v40[1] = v42;
        ++a1;
        continue;
      case 31:
        a4 += 2;
        v43 = a4;
        v44 = sub_808516A(a1);
        sub_807C66A(v118, v44);
        v45 = v118[1];
        *v43 = v118[0];
        v43[1] = v45;
        ++a1;
        goto LABEL_49;
      case 32:
LABEL_49:
        Scr_EvalArray(a4, a4 - 2);
        goto LABEL_3;
      case 33:
        v155 = *(_DWORD *)dword_83D7600;
        goto LABEL_52;
      case 34:
        v155 = sub_808516A(a1++);
        goto LABEL_52;
      case 35:
LABEL_52:
        v46 = Scr_EvalArrayRef(v155);
        v155 = sub_807E43A(v46, a4);
        goto LABEL_3;
      case 36:
        sub_807EB00(v155, a4);
        goto LABEL_3;
      case 37:
        a4 += 2;
        a4[1] = 1;
        v47 = a4;
        *v47 = sub_807B658();
        continue;
      case 38:
        v154 = sub_807B766(a2);
        if ( sub_807CB3E(v154) )
          continue;
        goto LABEL_269;
      case 39:
        v154 = dword_8394024;
        goto LABEL_58;
      case 40:
        v154 = dword_839402C;
LABEL_58:
        a4 += 2;
        v48 = a4;
        v49 = sub_80851E6((_WORD **)&a1);
        v50 = FindVariable(v154, v49);
        sub_807C66A(v117, v50);
        v51 = v117[1];
        *v48 = v117[0];
        v48[1] = v51;
        continue;
      case 41:
        v154 = sub_807B766(a2);
        if ( sub_807CB3E(v154) )
          goto LABEL_62;
        a4 += 2;
        sub_80851E6((_WORD **)&a1);
LABEL_269:
        v140 = GetVarType(v154);
        goto LABEL_270;
      case 42:
LABEL_62:
        a4 += 2;
        v52 = a4;
        v53 = sub_80851E6((_WORD **)&a1);
        sub_807BC7C(v116, v154, v53);
        v54 = v116[1];
        *v52 = v116[0];
        v52[1] = v54;
        continue;
      case 43:
        v154 = dword_8394024;
        goto LABEL_66;
      case 44:
        v154 = dword_839402C;
        goto LABEL_66;
      case 45:
        v154 = sub_807B766(a2);
        goto LABEL_66;
      case 46:
LABEL_66:
        v55 = sub_80851E6((_WORD **)&a1);
        v155 = sub_807BBCA(v154, v55);
        continue;
      case 47:
        v56 = sub_80851E6((_WORD **)&a1);
        sub_807BF8E(v154, v56, (int)a4);
        continue;
      case 48:
        dword_83D7600 += 4;
        ++a3;
        v57 = sub_80851E6((_WORD **)&a1);
        *(_DWORD *)dword_83D7600 = sub_807C0CC(a2, v57);
        goto LABEL_69;
      case 49:
LABEL_69:
        if ( a4[1] != 8 )
          goto LABEL_70;
        continue;
      case 50:
        if ( a4[1] != 8 )
          goto LABEL_72;
        ++a1;
        continue;
      case 51:
        if ( a4[1] != 7 )
          goto LABEL_72;
        v59 = sub_808516A(a1);
        sub_807C5E2(v59);
        ++a1;
        continue;
      case 52:
        while ( a4[1] != 7 )
        {
          RemoveRefToValue(a4);
          a4 -= 2;
        }
        continue;
      case 53:
        if ( a4[1] == 8 )
        {
          a4[1] = 7;
        }
        else
        {
          Scr_Error((int)"function called with too many parameters");
LABEL_81:
          v155 = *(_DWORD *)dword_83D7600;
        }
        continue;
      case 54:
        goto LABEL_81;
      case 55:
        v155 = sub_808516A(a1++);
        continue;
      case 56:
        v60 = sub_80851E6((_WORD **)&a1);
        v61 = sub_807C0A8(dword_8394024, v60);
        sub_807C45C(v61, a4);
        goto LABEL_3;
      case 57:
        goto LABEL_85;
      case 58:
        v62 = sub_80851E6((_WORD **)&a1);
        v63 = sub_807C0A8(dword_839402C, v62);
        sub_807C45C(v63, a4);
        goto LABEL_3;
      case 59:
        v131 = (unsigned __int16)sub_80851E6((_WORD **)&a1);
        v154 = sub_807B766(a2);
        v155 = sub_807BBCA(v154, v131);
        goto LABEL_85;
      case 60:
LABEL_70:
        sub_807C45C(*(_DWORD *)dword_83D7600, a4);
        goto LABEL_3;
      case 61:
LABEL_72:
        v58 = sub_808516A(a1);
        sub_807C45C(v58, a4);
        ++a1;
        goto LABEL_3;
      case 62:
        goto LABEL_93;
      case 63:
        dword_83D761C = 1;
        goto LABEL_93;
      case 64:
        dword_83D761C = 2;
        goto LABEL_93;
      case 65:
        dword_83D761C = 3;
        goto LABEL_93;
      case 66:
        dword_83D761C = 4;
        goto LABEL_93;
      case 67:
        dword_83D761C = 5;
        goto LABEL_93;
      case 68:
        dword_83D761C = *a1++;
LABEL_93:
        dword_83D7610 = (int)a4;
        v127 = (unsigned __int16)sub_80851E6((_WORD **)&a1);
        *(_DWORD *)dword_83D760C = a1;
        ((void (*)(void))dword_8202A78[v127])();
        goto LABEL_94;
      case 69:
        goto LABEL_106;
      case 70:
        dword_83D761C = 1;
        goto LABEL_106;
      case 71:
        dword_83D761C = 2;
        goto LABEL_106;
      case 72:
        dword_83D761C = 3;
        goto LABEL_106;
      case 73:
        dword_83D761C = 4;
        goto LABEL_106;
      case 74:
        dword_83D761C = 5;
        goto LABEL_106;
      case 75:
        dword_83D761C = *a1++;
LABEL_106:
        dword_83D7610 = (int)(a4 - 2);
        v127 = (unsigned __int16)sub_80851E6((_WORD **)&a1);
        if ( a4[1] != 1 )
          goto LABEL_110;
        v154 = *a4;
        if ( GetVarType(v154) == 21 )
        {
          sub_807EDC4(&v115, v154);
          v149 = v115;
          RemoveRefToObject(v154);
          *(_DWORD *)dword_83D760C = a1;
          ((void (__cdecl *)(int))dword_8202A78[v127])(v149);
LABEL_94:
          a4 = (_DWORD *)dword_83D7610;
          a1 = *(unsigned __int8 **)dword_83D760C;
          if ( dword_83D761C )
          {
            i = dword_83D761C;
            dword_83D761C = 0;
            dword_83D7610 -= 8 * i;
            do
            {
              RemoveRefToValue(a4);
              a4 -= 2;
              --i;
            }
            while ( i );
          }
          if ( dword_83D7618 )
          {
            dword_83D7618 = 0;
          }
          else
          {
            a4 += 2;
            a4[1] = 0;
          }
          continue;
        }
        v140 = GetVarType(v154);
        RemoveRefToObject(v154);
        dword_8394014 = -1;
        v64 = va("%s is not an entity", *(const char **)&off_815ABC0[4 * v140]);
        Scr_Error((int)v64);
LABEL_110:
        v140 = a4[1];
        RemoveRefToValue(a4);
        dword_8394014 = -1;
        v65 = va("%s is not an entity", *(const char **)&off_815ABC0[4 * v140]);
        Scr_Error((int)v65);
LABEL_111:
        if ( a4[1] == 5 )
        {
          if ( *(float *)a4 < 0.0 )
            goto LABEL_124;
          v109 = *(float *)a4 * 20.0;
          v148 = sub_80850EE(v109);
          if ( !v148 )
            v148 = *(float *)a4 != 0.0;
        }
        else if ( a4[1] == 6 )
        {
          v148 = 20 * *a4;
        }
        else
        {
          dword_8394014 = 2;
          v66 = va("type %s is not a float", *(const char **)&off_815ABC0[4 * a4[1]]);
          Scr_Error((int)v66);
        }
        if ( (unsigned int)v148 > 0xFFFFFE )
        {
          dword_8394014 = 2;
          if ( v148 >= 0 )
            Scr_Error((int)"wait is too long");
LABEL_124:
          Scr_Error((int)"negative wait is not allowed");
LABEL_125:
          v130 = 10;
          v129 = sub_808244A(((char *)a4 - a5) >> 3, (int)a1, a4, a3, &a2);
          v68 = sub_807C0A8(dword_839401C, dword_8394018);
          v141 = sub_807CAD2(v68);
          v128 = sub_807C144(v141, a2);
          sub_807C4C2(v128, &v129);
          sub_807B128(a2, dword_8394018);
          goto LABEL_254;
        }
        if ( v148 )
          sub_8084FE0();
        v148 = (dword_8394018 + v148) & 0xFFFFFF;
        a4 -= 2;
        v130 = 10;
        v129 = sub_808244A(((char *)a4 - a5) >> 3, (int)a1, a4, a3, &a2);
        v67 = sub_807C0A8(dword_839401C, v148);
        v141 = sub_807CAD2(v67);
        v128 = sub_807C11A(v141, a2);
        sub_807C4C2(v128, &v129);
        sub_807B128(a2, v148);
LABEL_254:
        *((_DWORD *)a5 + 3) = 0;
LABEL_255:
        if ( v143 )
        {
          --v143;
          RemoveRefToObject(a2);
          a1 = *(unsigned __int8 **)dword_83D760C;
          a2 = *(_DWORD *)(dword_83D760C + 4);
          a3 = *(_DWORD *)(dword_83D760C + 8);
          a4 = *(_DWORD **)(dword_83D760C + 12);
          a5 = *(char **)(dword_83D760C + 16);
          a4[1] = *(_DWORD *)(dword_83D760C + 20);
          a4 += 2;
          continue;
        }
        --dword_83D553C;
        return a2;
      case 76:
        goto LABEL_111;
      case 77:
        goto LABEL_125;
      case 78:
        a4 += 2;
        a4[1] = 8;
        continue;
      case 79:
        a4 += 2;
        a4[1] = 8;
        goto LABEL_128;
      case 80:
LABEL_128:
        if ( dword_83D7608 <= 30 )
        {
          v153 = sub_807B766(a2);
          AddRefToObject(v153);
          a2 = sub_807B700(v153, a2);
          *(_DWORD *)dword_83D760C = a1;
          a1 = (unsigned __int8 *)sub_8085238((_DWORD **)dword_83D760C);
          goto LABEL_253;
        }
        Scr_Error((int)"script stack overflow (too many embedded function calls)");
LABEL_131:
        if ( a4[1] != 9 )
          goto LABEL_135;
        if ( dword_83D7608 <= 30 )
        {
          v153 = sub_807B766(a2);
          AddRefToObject(v153);
          a2 = sub_807B700(v153, a2);
          *(_DWORD *)dword_83D760C = a1;
          a1 = (unsigned __int8 *)*a4;
          a4 -= 2;
          goto LABEL_253;
        }
        dword_8394014 = 1;
        Scr_Error((int)"script stack overflow (too many embedded function calls)");
LABEL_135:
        v69 = va("%s is not a function pointer", *(const char **)&off_815ABC0[4 * a4[1]]);
        Scr_Error((int)v69);
LABEL_136:
        if ( a4[1] != 1 )
          goto LABEL_263;
        if ( dword_83D7608 <= 30 )
        {
          a2 = sub_807B700(*a4, a2);
          a4 -= 2;
          *(_DWORD *)dword_83D760C = a1;
          a1 = (unsigned __int8 *)sub_8085238((_DWORD **)dword_83D760C);
          goto LABEL_253;
        }
        Scr_Error((int)"script stack overflow (too many embedded function calls)");
LABEL_263:
        v140 = a4[1];
        goto LABEL_267;
      case 81:
        goto LABEL_131;
      case 82:
        goto LABEL_136;
      case 83:
        if ( a4[1] == 9 )
        {
          v146 = (unsigned __int8 *)*a4;
          a4 -= 2;
          if ( a4[1] != 1 )
            goto LABEL_265;
          if ( dword_83D7608 <= 30 )
          {
            a2 = sub_807B700(*a4, a2);
            a4 -= 2;
            *(_DWORD *)dword_83D760C = a1;
            a1 = v146;
            goto LABEL_253;
          }
          goto LABEL_162;
        }
        RemoveRefToValue(a4);
        a4 -= 2;
        v70 = va("%s is not a function pointer", *(const char **)&off_815ABC0[4 * a4[3]]);
        Scr_Error((int)v70);
LABEL_146:
        if ( dword_83D7608 <= 30 )
        {
          v153 = sub_807B766(a2);
          AddRefToObject(v153);
          a2 = AllocThread(v153);
          *(_DWORD *)dword_83D760C = a1;
          *(_DWORD *)(dword_83D760C + 16) = a5;
          a1 = (unsigned __int8 *)sub_8085238((_DWORD **)dword_83D760C);
          v71 = sub_8085180((_DWORD **)dword_83D760C);
          a5 = (char *)&a4[-2 * v71];
          goto LABEL_252;
        }
        dword_8394014 = 1;
        Scr_Error((int)"script stack overflow (too many embedded function calls)");
LABEL_149:
        if ( a4[1] == 9 )
        {
          if ( dword_83D7608 <= 30 )
          {
            v146 = (unsigned __int8 *)*a4;
            a4 -= 2;
            v153 = sub_807B766(a2);
            AddRefToObject(v153);
            a2 = AllocThread(v153);
            *(_DWORD *)dword_83D760C = a1;
            *(_DWORD *)(dword_83D760C + 16) = a5;
            a1 = v146;
            v72 = sub_8085180((_DWORD **)dword_83D760C);
            a5 = (char *)&a4[-2 * v72];
            goto LABEL_252;
          }
          dword_8394014 = 1;
          Scr_Error((int)"script stack overflow (too many embedded function calls)");
        }
        v73 = va("%s is not a function pointer", *(const char **)&off_815ABC0[4 * a4[1]]);
        Scr_Error((int)v73);
LABEL_154:
        if ( a4[1] != 1 )
          goto LABEL_265;
        if ( dword_83D7608 > 30 )
          goto LABEL_162;
        a2 = AllocThread(*a4);
        a4 -= 2;
        *(_DWORD *)dword_83D760C = a1;
        *(_DWORD *)(dword_83D760C + 16) = a5;
        a1 = (unsigned __int8 *)sub_8085238((_DWORD **)dword_83D760C);
        v74 = sub_8085180((_DWORD **)dword_83D760C);
        a5 = (char *)&a4[-2 * v74];
        goto LABEL_252;
      case 84:
        goto LABEL_146;
      case 85:
        goto LABEL_149;
      case 86:
        goto LABEL_154;
      case 87:
        if ( a4[1] != 9 )
        {
          RemoveRefToValue(a4);
          a4 -= 2;
          v76 = va("%s is not a function pointer", *(const char **)&off_815ABC0[4 * a4[3]]);
          Scr_Error((int)v76);
LABEL_164:
          RemoveRefToValue(a4);
          goto LABEL_3;
        }
        v146 = (unsigned __int8 *)*a4;
        a4 -= 2;
        if ( a4[1] != 1 )
          goto LABEL_265;
        if ( dword_83D7608 > 30 )
        {
LABEL_162:
          dword_8394014 = 1;
          Scr_Error((int)"script stack overflow (too many embedded function calls)");
LABEL_265:
          v140 = a4[1];
          goto LABEL_268;
        }
        a2 = AllocThread(*a4);
        a4 -= 2;
        *(_DWORD *)dword_83D760C = a1;
        *(_DWORD *)(dword_83D760C + 16) = a5;
        a1 = v146;
        v75 = sub_8085180((_DWORD **)dword_83D760C);
        a5 = (char *)&a4[-2 * v75];
LABEL_252:
        *(_DWORD *)(dword_83D760C + 12) = a5;
        *(_DWORD *)(dword_83D760C + 20) = *((_DWORD *)a5 + 1);
        *((_DWORD *)a5 + 1) = 8;
        ++v143;
LABEL_253:
        *(_DWORD *)(dword_83D760C + 8) = a3;
        a3 = 0;
        ++dword_83D7608;
        dword_83D760C += 24;
        *(_DWORD *)(dword_83D760C + 4) = a2;
        continue;
      case 88:
        goto LABEL_164;
      case 89:
        v154 = sub_807CFFA(dword_8394034, a4);
        goto LABEL_3;
      case 90:
        v77 = sub_808516A(a1);
        v154 = sub_807C6AE(v77);
        ++a1;
        continue;
      case 91:
        sub_807CC38((float *)a4);
        continue;
      case 92:
        sub_807CBAA((int)a4);
        continue;
      case 93:
        sub_807CBD8(a4);
        continue;
      case 94:
        sub_807CC38((float *)a4);
        v136 = (unsigned __int16)sub_80851E6((_WORD **)&a1);
        if ( !*a4 )
          a1 += v136;
        goto LABEL_3;
      case 95:
        sub_807CC38((float *)a4);
        v136 = (unsigned __int16)sub_80851E6((_WORD **)&a1);
        if ( *a4 )
          a1 += v136;
        goto LABEL_3;
      case 96:
        sub_807CC38((float *)a4);
        v136 = (unsigned __int16)sub_80851E6((_WORD **)&a1);
        if ( *a4 )
          goto LABEL_3;
        a1 += v136;
        continue;
      case 97:
        sub_807CC38((float *)a4);
        v136 = (unsigned __int16)sub_80851E6((_WORD **)&a1);
        if ( !*a4 )
          goto LABEL_3;
        a1 += v136;
        continue;
      case 98:
        v136 = sub_8085180((_DWORD **)&a1);
        a1 += v136;
        continue;
      case 99:
        if ( (unsigned int)(Sys_MilliSeconds() - dword_83D5598) > 0x1387 )
        {
          if ( !dword_83D5594 )
          {
            if ( !byte_83D7615 )
            {
              Com_Printf("script runtime error: potential infinite loop in script - killing thread.\n");
              Scr_PrintPrevCodePos(0, (const char *)a1, 0);
              sub_8084FE0();
              while ( 1 )
              {
                v142 = sub_807B1F0(a2);
                sub_807B25E(a2);
                dword_83D7600 -= 4 * a3;
                while ( a4[1] != 7 )
                {
                  RemoveRefToValue(a4);
                  a4 -= 2;
                }
                --dword_83D7608;
                dword_83D760C -= 24;
                if ( !v142 )
                  break;
                RemoveRefToObject(a2);
                a1 = *(unsigned __int8 **)dword_83D760C;
                a3 = *(_DWORD *)(dword_83D760C + 8);
                a2 = v142;
                a4 -= 2;
              }
              goto LABEL_254;
            }
            sub_8084DF0((int)"potential infinite loop in script");
LABEL_186:
            a4 += 2;
            v78 = a4;
            sub_807C83C(v114, v155);
            v79 = v114[1];
            *v78 = v114[0];
            v78[1] = v79;
            if ( a4[1] == 6 )
            {
              ++*a4;
              ++a1;
            }
            else
            {
              v80 = va("++ must be applied to an int (applied to %s)", *(const char **)&off_815ABC0[4 * a4[1]]);
              Scr_Error((int)v80);
LABEL_189:
              a4 += 2;
              v81 = a4;
              sub_807C83C(v113, v155);
              v82 = v113[1];
              *v81 = v113[0];
              v81[1] = v82;
              if ( a4[1] != 6 )
              {
                v83 = va(
                        "-- must be applied to an int (applied to %s)",
                        *(const char **)&off_815ABC0[4 * a4[1]]);
                Scr_Error((int)v83);
LABEL_192:
                Scr_EvalOr(a4 - 2, a4);
                goto LABEL_3;
              }
              --*a4;
              ++a1;
            }
LABEL_85:
            sub_807C628(v155, a4);
LABEL_3:
            a4 -= 2;
            continue;
          }
          Com_Printf("script runtime warning: potential infinite loop in script.\n");
          Scr_PrintPrevCodePos(0, (const char *)a1, 0);
          v136 = (unsigned __int16)sub_80851E6((_WORD **)&a1);
          a1 -= v136;
          sub_8084FE0();
        }
        else
        {
LABEL_180:
          v136 = (unsigned __int16)sub_80851E6((_WORD **)&a1);
          a1 -= v136;
        }
        continue;
      case 100:
        goto LABEL_186;
      case 101:
        goto LABEL_189;
      case 102:
        goto LABEL_192;
      case 103:
        Scr_EvalExOr(a4 - 2, a4);
        goto LABEL_3;
      case 104:
        Scr_EvalAnd(a4 - 2, a4);
        goto LABEL_3;
      case 105:
        Scr_EvalEquality(a4 - 2, a4);
        goto LABEL_3;
      case 106:
        Scr_EvalInequality(a4 - 2, a4);
        goto LABEL_3;
      case 107:
        Scr_EvalLess(a4 - 2, a4);
        goto LABEL_3;
      case 108:
        Scr_EvalGreater(a4 - 2, a4);
        goto LABEL_3;
      case 109:
        Scr_EvalLessEqual(a4 - 2, a4);
        goto LABEL_3;
      case 110:
        Scr_EvalGreaterEqual(a4 - 2, a4);
        goto LABEL_3;
      case 111:
        Scr_EvalShiftLeft(a4 - 2, a4);
        goto LABEL_3;
      case 112:
        Scr_EvalShiftRight(a4 - 2, a4);
        goto LABEL_3;
      case 113:
        Scr_EvalPlus(a4 - 2, a4);
        goto LABEL_3;
      case 114:
        Scr_EvalMinus(a4 - 2, a4);
        goto LABEL_3;
      case 115:
        Scr_EvalMultiply(a4 - 2, a4);
        goto LABEL_3;
      case 116:
        Scr_EvalDivide(a4 - 2, a4);
        goto LABEL_3;
      case 117:
        Scr_EvalMod(a4 - 2, a4);
        goto LABEL_3;
      case 118:
        sub_807C8B2(a4);
        continue;
      case 119:
      case 120:
        if ( a4[1] != 1 )
          goto LABEL_265;
        if ( !sub_807CB3E(*a4) )
          goto LABEL_266;
        v150 = *a4;
        a4 -= 2;
        if ( a4[1] == 2 )
        {
          v147 = *a4;
          a4 -= 2;
          v130 = 10;
          v129 = sub_808244A(((char *)a4 - a5) >> 3, (int)a1, a4, a3, &a2);
          v84 = sub_807C0A8(v150, 0x1FFFEu);
          v85 = sub_807CAD2(v84);
          v86 = sub_807C0A8(v85, v147);
          v141 = sub_807CAD2(v86);
          v128 = sub_807C11A(v141, a2);
          sub_807C4C2(v128, &v129);
          v151 = 1;
          v87 = sub_807B766(a2);
          v88 = sub_807C0F0(dword_8394020, v87);
          v89 = sub_807CAD2(v88);
          v90 = sub_807C11A(v89, a2);
          sub_807C4C2(v90, &v150);
          sub_807AFAC(a2, v147);
          goto LABEL_254;
        }
        a4 += 2;
        dword_8394014 = 3;
        Scr_Error((int)"first parameter of waittill must evaluate to a string");
LABEL_266:
        v140 = GetVarType(*a4);
LABEL_268:
        dword_8394014 = 2;
LABEL_270:
        v107 = va("%s is not an object", *(const char **)&off_815ABC0[4 * v140]);
        Scr_Error((int)v107);
LABEL_271:
        switch ( v144 )
        {
          case 33:
          case 34:
          case 35:
          case 36:
          case 132:
            if ( dword_8394014 < 0 )
              dword_8394014 = 1;
            break;
          case 41:
          case 42:
          case 47:
          case 57:
          case 59:
          case 100:
          case 101:
            dword_8394014 = 0;
            break;
          case 62:
          case 63:
          case 64:
          case 65:
          case 66:
          case 67:
          case 68:
            if ( dword_8394014 > 0 )
              dword_8394014 = dword_83D761C - dword_8394014 + 1;
            break;
          case 69:
          case 70:
          case 71:
          case 72:
          case 73:
          case 74:
          case 75:
            if ( dword_8394014 <= 0 )
            {
              if ( dword_8394014 < 0 )
                dword_8394014 = 1;
            }
            else
            {
              dword_8394014 = dword_83D761C - dword_8394014 + 2;
            }
            break;
          default:
            break;
        }
        scriptError((const char *)a1, dword_8394014, *(const char **)dword_8394010, (void *)dword_83D5590);
        sub_807F810();
        switch ( v144 )
        {
          case 31:
          case 32:
            RemoveRefToValue(a4);
            a4 -= 2;
            RemoveRefToValue(a4);
            a4[1] = 0;
            continue;
          case 33:
          case 34:
          case 35:
          case 132:
            v155 = sub_807FAEE();
            goto LABEL_295;
          case 36:
          case 76:
            goto LABEL_295;
          case 38:
            goto LABEL_286;
          case 41:
          case 42:
            a4[1] = 0;
            continue;
          case 45:
          case 46:
            v155 = sub_807FAEE();
            continue;
          case 47:
            if ( dword_83D761C )
              dword_83D761C = 0;
            continue;
          case 53:
            while ( a4[1] != 8 )
            {
              RemoveRefToValue(a4);
              a4 -= 2;
            }
            a4[1] = 7;
            continue;
          case 57:
            if ( dword_83D761C )
              goto LABEL_291;
            goto LABEL_296;
          case 59:
LABEL_291:
            RemoveRefToValue(a4);
            dword_83D761C = 0;
            goto LABEL_296;
          case 62:
          case 63:
          case 64:
          case 65:
          case 66:
          case 67:
          case 68:
          case 69:
          case 70:
          case 71:
          case 72:
          case 73:
          case 74:
          case 75:
            sub_807FA9C();
            a4 = (_DWORD *)(dword_83D7610 + 8);
            *(_DWORD *)(dword_83D7610 + 12) = 0;
            continue;
          case 79:
          case 80:
          case 82:
            sub_8085238((_DWORD **)&a1);
            goto LABEL_302;
          case 81:
          case 83:
LABEL_302:
            while ( a4[1] != 8 )
            {
              RemoveRefToValue(a4);
              a4 -= 2;
            }
            a4[1] = 0;
            continue;
          case 84:
          case 86:
            sub_8085238((_DWORD **)&a1);
            goto LABEL_306;
          case 85:
          case 87:
LABEL_306:
            for ( i = sub_8085180((_DWORD **)&a1); i; --i )
            {
              RemoveRefToValue(a4);
              a4 -= 2;
            }
            a4 += 2;
            a4[1] = 0;
            continue;
          case 89:
            v154 = sub_807FACC();
            goto LABEL_296;
          case 90:
            ++a1;
LABEL_286:
            v154 = sub_807FACC();
            continue;
          case 94:
          case 95:
          case 96:
          case 97:
            sub_80851E6((_WORD **)&a1);
            goto LABEL_296;
          case 99:
            goto LABEL_180;
          case 102:
          case 103:
          case 104:
          case 105:
          case 106:
          case 107:
          case 108:
          case 109:
          case 110:
          case 111:
          case 112:
          case 113:
          case 114:
          case 115:
          case 116:
          case 117:
            goto LABEL_296;
          case 119:
            ++a1;
            goto LABEL_294;
          case 120:
          case 122:
LABEL_294:
            RemoveRefToValue(a4);
            a4 -= 2;
            goto LABEL_295;
          case 121:
            while ( a4[1] != 8 )
            {
              RemoveRefToValue(a4);
              a4 -= 2;
            }
            goto LABEL_295;
          case 124:
            while ( v139 )
            {
              v133 = sub_80851FC((_DWORD **)&a1);
              v132 = (unsigned __int8 *)sub_8085238((_DWORD **)&a1);
              --v139;
            }
            if ( !v133 )
              a1 = v132;
LABEL_295:
            RemoveRefToValue(a4);
LABEL_296:
            a4 -= 2;
            break;
          default:
            continue;
        }
        continue;
      case 121:
        if ( a4[1] != 1 )
          goto LABEL_265;
        v141 = *a4;
        if ( !sub_807CB3E(v141) )
          goto LABEL_266;
        a4 -= 2;
        if ( a4[1] != 2 )
        {
          a4 += 2;
          dword_8394014 = 1;
          Scr_Error((int)"first parameter of notify must evaluate to a string");
          goto LABEL_266;
        }
        v147 = *a4;
        a4 -= 2;
        *(_DWORD *)dword_83D760C = a1;
        sub_8082F56(v141, v147, a4);
        a1 = *(unsigned __int8 **)dword_83D760C;
        RemoveRefToObject(v141);
        SL_RemoveRefToString(v147);
        while ( a4[1] != 8 )
        {
          RemoveRefToValue(a4);
          a4 -= 2;
        }
        goto LABEL_3;
      case 122:
        if ( a4[1] != 1 )
          goto LABEL_263;
        if ( !sub_807CB3E(*a4) )
          goto LABEL_264;
        if ( *(a4 - 1) == 2 )
        {
          v147 = *(a4 - 2);
          AddRefToObject(a2);
          v145 = AllocThread(a2);
          v91 = sub_807C0A8(*a4, 0x1FFFEu);
          v92 = sub_807CAD2(v91);
          v93 = sub_807C0A8(v92, v147);
          v94 = sub_807CAD2(v93);
          sub_807C0F0(v94, v145);
          RemoveRefToObject(v145);
          v151 = 1;
          v150 = *a4;
          v95 = sub_807C0F0(dword_8394020, a2);
          v96 = sub_807CAD2(v95);
          v97 = sub_807C11A(v96, v145);
          sub_807C4C2(v97, &v150);
          sub_807AFAC(v145, v147);
          a4 -= 4;
          continue;
        }
        Scr_Error((int)"first parameter of endon must evaluate to a string");
LABEL_264:
        v140 = GetVarType(*a4);
LABEL_267:
        dword_8394014 = 1;
        goto LABEL_270;
      case 123:
        a4 += 2;
        a4[1] = 8;
        continue;
      case 124:
        v136 = sub_8085180((_DWORD **)&a1);
        a1 += v136;
        v139 = (unsigned __int16)sub_80851E6((_WORD **)&a1);
        v110 = a4[1];
        if ( v110 == 2 )
          goto LABEL_232;
        if ( v110 == 6 )
        {
          if ( IsValidArrayIndex(*a4) )
          {
            v138 = sub_807BADA(*a4);
          }
          else
          {
            v98 = va("switch index %d out of range", *a4);
            Scr_Error((int)v98);
LABEL_232:
            v138 = *a4;
            SL_RemoveRefToString(*a4);
          }
        }
        else
        {
          v99 = va("cannot switch on %s", *(const char **)&off_815ABC0[4 * a4[1]]);
          Scr_Error((int)v99);
        }
        if ( !v139 )
          goto LABEL_3;
        do
        {
          v133 = sub_80851FC((_DWORD **)&a1);
          v132 = (unsigned __int8 *)sub_8085238((_DWORD **)&a1);
          if ( v133 == v138 )
          {
            a1 = v132;
            goto LABEL_3;
          }
          --v139;
        }
        while ( v139 );
        if ( !v133 )
          a1 = v132;
        goto LABEL_3;
      case 125:
        v139 = (unsigned __int16)sub_80851E6((_WORD **)&a1);
        sub_80851C2((int *)&a1, 2 * v139);
        continue;
      case 126:
        a4 -= 4;
        sub_807CF1E(a4);
        continue;
      case 127:
        continue;
      case 128:
        --dword_83D553C;
        return 0;
      case 129:
        a4 += 2;
        v135 = sub_8085180((_DWORD **)&a1);
        v134 = sub_8085180((_DWORD **)&a1);
        v100 = a4;
        *v100 = sub_807E346(v134, v135);
        if ( !*a4 )
        {
          a4[1] = 0;
          Scr_Error((int)"unknown object");
        }
        goto LABEL_245;
      case 130:
        a4 += 2;
        v101 = a4;
        *v101 = (unsigned __int16)sub_80851E6((_WORD **)&a1);
LABEL_245:
        a4[1] = 1;
        AddRefToObject(*a4);
        continue;
      case 131:
        a4 += 2;
        v102 = a4;
        v103 = sub_80851E6((_WORD **)&a1);
        v104 = FindVariable(a2, v103);
        sub_807C66A(v112, v104);
        v105 = v112[1];
        *v102 = v112[0];
        v102[1] = v105;
        continue;
      case 132:
        v106 = sub_80851E6((_WORD **)&a1);
        v155 = FindVariable(a2, v106);
        if ( v155 )
          continue;
        Scr_Error((int)"cannot create a new local variable in the debugger");
        goto LABEL_250;
      case 133:
LABEL_250:
        ++a1;
        continue;
      case 134:
        ++a1;
        continue;
      default:
        goto LABEL_252;
    }
  }
}
// 8202A78: using guessed type int dword_8202A78[1058];
// 8394014: using guessed type int dword_8394014;
// 8394018: using guessed type int dword_8394018;
// 839401C: using guessed type int dword_839401C;
// 8394020: using guessed type int dword_8394020;
// 8394024: using guessed type int dword_8394024;
// 8394028: using guessed type int dword_8394028;
// 839402C: using guessed type int dword_839402C;
// 8394034: using guessed type int dword_8394034;
// 83D553C: using guessed type int dword_83D553C;
// 83D5590: using guessed type int dword_83D5590;
// 83D5594: using guessed type int dword_83D5594;
// 83D5598: using guessed type int dword_83D5598;
// 83D7600: using guessed type int dword_83D7600;
// 83D7608: using guessed type int dword_83D7608;
// 83D760C: using guessed type int dword_83D760C;
// 83D7610: using guessed type int dword_83D7610;
// 83D7615: using guessed type char byte_83D7615;
// 83D7618: using guessed type int dword_83D7618;
// 83D761C: using guessed type int dword_83D761C;

//----- (08081F8C) --------------------------------------------------------
void *__cdecl sub_8081F8C(_DWORD *a1)
{
  void *v3; // [esp+4h] [ebp-4h]

  if ( dword_83D7608 <= 1 )
    return 0;
  v3 = *(void **)(dword_83D760C - 24);
  if ( v3 == &unk_83D4100 )
    return 0;
  *a1 = *(_DWORD *)(dword_83D760C - 24 + 4);
  return v3;
}
// 83D7608: using guessed type int dword_83D7608;
// 83D760C: using guessed type int dword_83D760C;

//----- (08081FD6) --------------------------------------------------------
char *__cdecl sub_8081FD6(int *a1, char *a2, int a3, int a4, _DWORD *a5)
{
  int v5; // edx
  int v6; // edx
  int v7; // edx
  int v9; // [esp+10h] [ebp-28h]
  int v10; // [esp+18h] [ebp-20h]
  int v11; // [esp+1Ch] [ebp-1Ch]
  int v12; // [esp+20h] [ebp-18h]
  int v13; // [esp+24h] [ebp-14h]
  int v14; // [esp+24h] [ebp-14h]
  int v15; // [esp+24h] [ebp-14h]
  int v16; // [esp+24h] [ebp-14h]
  int v17; // [esp+28h] [ebp-10h]
  int v18; // [esp+2Ch] [ebp-Ch]
  int v19; // [esp+2Ch] [ebp-Ch]
  int v20; // [esp+30h] [ebp-8h] BYREF
  int v21; // [esp+34h] [ebp-4h]

  *a5 = *(_DWORD *)(dword_83D760C + 4);
  while ( 2 )
  {
    ++a2;
    if ( a4 == 2 )
    {
      switch ( a3 )
      {
        case 'O':
        case 'P':
        case 'T':
          goto LABEL_5;
        case 'Q':
        case 'U':
          goto LABEL_8;
        case 'R':
        case 'V':
          if ( a1[1] != 1 )
            goto LABEL_11;
LABEL_5:
          if ( dword_83D7608 > 31 )
            goto LABEL_11;
          *a5 = 0;
          v10 = sub_8085238((_DWORD **)&a2);
          break;
        case 'S':
        case 'W':
          if ( *(a1 - 1) != 1 )
            goto LABEL_11;
LABEL_8:
          if ( a1[1] != 9 || dword_83D7608 > 31 )
            goto LABEL_11;
          *a5 = 0;
          v10 = *a1;
          break;
        default:
          goto LABEL_11;
      }
    }
    else
    {
LABEL_11:
      switch ( a3 )
      {
        case 0:
        case 1:
          return (char *)sub_8081F8C(a5);
        case 4:
        case 5:
        case 23:
        case 30:
        case 31:
        case 34:
        case 50:
        case 51:
        case 55:
        case 61:
        case 90:
        case 119:
        case 133:
        case 134:
          ++a2;
          goto LABEL_44;
        case 6:
        case 7:
        case 10:
        case 11:
        case 22:
        case 39:
        case 40:
        case 41:
        case 42:
        case 43:
        case 44:
        case 45:
        case 46:
        case 47:
        case 48:
        case 56:
        case 58:
        case 59:
        case 62:
        case 63:
        case 64:
        case 65:
        case 66:
        case 67:
        case 69:
        case 70:
        case 71:
        case 72:
        case 73:
        case 74:
        case 130:
        case 131:
        case 132:
          sub_80851E6((_WORD **)&a2);
          goto LABEL_44;
        case 8:
        case 9:
        case 19:
        case 21:
        case 79:
        case 80:
        case 82:
        case 85:
        case 87:
          sub_8085180((_DWORD **)&a2);
          goto LABEL_44;
        case 12:
          sub_80851A2((int *)&a2);
          goto LABEL_44;
        case 68:
        case 75:
          ++a2;
          sub_80851E6((_WORD **)&a2);
          goto LABEL_44;
        case 84:
        case 86:
        case 129:
          sub_8085180((_DWORD **)&a2);
          sub_8085180((_DWORD **)&a2);
          goto LABEL_44;
        case 94:
        case 96:
          v5 = a1[1];
          v20 = *a1;
          v21 = v5;
          sub_807578C(&v20);
          sub_807CC38((float *)&v20);
          v13 = (unsigned __int16)sub_80851E6((_WORD **)&a2);
          if ( *(_DWORD *)dword_8394010 )
            goto LABEL_44;
          if ( v20 )
            return a2;
          else
            return &a2[v13];
        case 95:
        case 97:
          v6 = a1[1];
          v20 = *a1;
          v21 = v6;
          sub_807578C(&v20);
          sub_807CC38((float *)&v20);
          v14 = (unsigned __int16)sub_80851E6((_WORD **)&a2);
          if ( *(_DWORD *)dword_8394010 )
            goto LABEL_44;
          if ( v20 )
            return &a2[v14];
          else
            return a2;
        case 98:
          v15 = sub_8085180((_DWORD **)&a2);
          return &a2[v15];
        case 99:
          v7 = (unsigned __int16)sub_80851E6((_WORD **)&a2);
          return &a2[-v7];
        case 124:
          v16 = sub_8085180((_DWORD **)&a2);
          a2 += v16;
          v18 = (unsigned __int16)sub_80851E6((_WORD **)&a2);
          v9 = a1[1];
          if ( v9 == 2 )
          {
            v17 = *a1;
          }
          else
          {
            if ( v9 != 6 )
            {
              a2 += 8 * v18;
              return a2;
            }
            if ( !IsValidArrayIndex(*a1) )
            {
              a2 += 8 * v18;
              return a2;
            }
            v17 = sub_807BADA(*a1);
          }
          if ( !v18 )
            return a2;
          break;
        case 125:
          v19 = (unsigned __int16)sub_80851E6((_WORD **)&a2);
          sub_80851C2((int *)&a2, 2 * v19);
          return a2;
        default:
LABEL_44:
          sub_807F810();
          a3 = *a2;
          if ( a3 == 57 )
            continue;
          return a2;
      }
      do
      {
        v12 = sub_80851FC((_DWORD **)&a2);
        v11 = sub_8085238((_DWORD **)&a2);
        if ( v12 == v17 )
        {
          a2 = (char *)v11;
          return (char *)v11;
        }
        --v18;
      }
      while ( v18 );
      if ( !v12 )
        return (char *)v11;
      return a2;
    }
    return (char *)v10;
  }
}
// 83D7608: using guessed type int dword_83D7608;
// 83D760C: using guessed type int dword_83D760C;

//----- (08082366) --------------------------------------------------------
int __cdecl sub_8082366(int a1, int a2, int a3, int a4, int a5)
{
  int result; // eax

  sub_807B084(a2);
  sub_807C228(a4, a2);
  result = sub_807C9AC(a4);
  if ( !result )
  {
    sub_807C16E(a3, a5);
    result = sub_807C9AC(a3);
    if ( !result )
      return sub_807C16E(a1, 131070);
  }
  return result;
}

//----- (080823CE) --------------------------------------------------------
int __cdecl sub_80823CE(int a1, int a2)
{
  int v2; // eax
  int v3; // eax
  int v5; // [esp+1Ch] [ebp-Ch]
  int v6; // [esp+20h] [ebp-8h]
  int v7; // [esp+24h] [ebp-4h]

  v2 = FindVariable(a1, 131070);
  v6 = sub_807CB1E(v2);
  v7 = (unsigned __int16)sub_807B110(a2);
  v3 = FindVariable(v6, v7);
  v5 = sub_807CB1E(v3);
  return sub_8082366(a1, a2, v6, v5, v7);
}

//----- (0808244A) --------------------------------------------------------
int __cdecl sub_808244A(int a1, int a2, _DWORD *a3, int a4, int *a5)
{
  int v6; // [esp+8h] [ebp-10h]
  _BYTE *v7; // [esp+10h] [ebp-8h]
  _DWORD *v8; // [esp+10h] [ebp-8h]
  int v9; // [esp+14h] [ebp-4h]

  v9 = sub_8076A2A(5 * a1 + 11);
  v6 = *a5;
  *(_WORD *)(v9 + 8) = *a5;
  *(_WORD *)(v9 + 4) = a1;
  *(_WORD *)(v9 + 6) = 5 * a1 + 11;
  *(_DWORD *)v9 = a2;
  *(_BYTE *)(v9 + 10) = dword_8394018;
  dword_83D7600 -= 4 * a4;
  v7 = (_BYTE *)(5 * a1 + v9 + 11);
  while ( a1 )
  {
    v8 = v7 - 4;
    if ( a3[1] == 7 )
    {
      --dword_83D7608;
      dword_83D760C -= 24;
      *v8 = *(_DWORD *)dword_83D760C;
      dword_83D7600 -= 4 * *(_DWORD *)(dword_83D760C + 8);
      v6 = GetParentLocalId(v6);
    }
    else
    {
      *v8 = *a3;
    }
    v7 = (char *)v8 - 1;
    *v7 = *((_BYTE *)a3 + 4);
    a3 -= 2;
    --a1;
  }
  --dword_83D7608;
  dword_83D760C -= 24;
  AddRefToObject(v6);
  *a5 = v6;
  return v9;
}
// 8394018: using guessed type int dword_8394018;
// 83D7600: using guessed type int dword_83D7600;
// 83D7608: using guessed type int dword_83D7608;
// 83D760C: using guessed type int dword_83D760C;

//----- (08082572) --------------------------------------------------------
int __cdecl sub_8082572(int a1)
{
  int v2; // [esp+10h] [ebp-8h]
  int i; // [esp+14h] [ebp-4h]

  v2 = 0;
  for ( i = sub_807CA16(a1); i; i = sub_807CA16(i) )
  {
    dword_83D7600 += 4;
    *(_DWORD *)dword_83D7600 = i;
    ++v2;
  }
  return v2;
}
// 83D7600: using guessed type int dword_83D7600;

//----- (080825C2) --------------------------------------------------------
int __cdecl sub_80825C2(int a1, _DWORD *a2, int a3)
{
  int v4; // [esp+10h] [ebp-18h]
  int v5; // [esp+14h] [ebp-14h]
  _DWORD *v6; // [esp+18h] [ebp-10h]
  int v7; // [esp+1Ch] [ebp-Ch]
  unsigned __int8 *v8; // [esp+20h] [ebp-8h]
  _DWORD *v9; // [esp+20h] [ebp-8h]

  *(_DWORD *)dword_83D760C = *(_DWORD *)a3;
  ++dword_83D7608;
  dword_83D760C += 24;
  v7 = *(unsigned __int16 *)(a3 + 4);
  v8 = (unsigned __int8 *)(a3 + 11);
  v6 = (_DWORD *)a2[4];
  while ( v7 )
  {
    v6 += 2;
    --v7;
    v6[1] = *v8;
    v9 = v8 + 1;
    if ( v6[1] == 7 )
    {
      *(_DWORD *)dword_83D760C = *v9;
      ++dword_83D7608;
      dword_83D760C += 24;
    }
    else
    {
      *v6 = *v9;
    }
    v8 = (unsigned __int8 *)(v9 + 1);
  }
  *a2 = *(_DWORD *)a3;
  a2[3] = v6;
  v5 = *(unsigned __int16 *)(a3 + 8);
  a2[1] = v5;
  sub_807B190(a1);
  v4 = dword_83D7608;
  while ( 1 )
  {
    dword_83D7624[6 * v4--] = v5;
    if ( !v4 )
      break;
    v5 = GetParentLocalId(v5);
  }
  while ( ++v4 != dword_83D7608 )
    dword_83D7628[6 * v4] = sub_8082572(dword_83D7624[6 * v4]);
  a2[2] = sub_8082572(a2[1]);
  if ( *(unsigned __int8 *)(a3 + 10) != (unsigned __int8)dword_8394018 )
    sub_8084FE0();
  return sub_8076A50(a3, *(unsigned __int16 *)(a3 + 6));
}
// 8394018: using guessed type int dword_8394018;
// 83D7608: using guessed type int dword_83D7608;
// 83D760C: using guessed type int dword_83D760C;
// 83D7624: using guessed type int dword_83D7624[];
// 83D7628: using guessed type int dword_83D7628[190];

//----- (08082754) --------------------------------------------------------
int __cdecl sub_8082754(int a1, int a2, int a3)
{
  int v3; // eax
  int v4; // eax
  int v6[3]; // [esp+10h] [ebp-28h] BYREF
  int v7; // [esp+1Ch] [ebp-1Ch]
  unsigned __int8 v8; // [esp+23h] [ebp-15h]
  int v9; // [esp+24h] [ebp-14h]
  int *v10; // [esp+28h] [ebp-10h]
  int v11; // [esp+2Ch] [ebp-Ch]
  unsigned int v12; // [esp+30h] [ebp-8h]
  int v13; // [esp+34h] [ebp-4h]

  v9 = *(unsigned __int16 *)(a3 + 4);
  v13 = *(unsigned __int16 *)(a3 + 8);
  v10 = (int *)(5 * v9 + a3 + 11);
  while ( v9 )
  {
    v11 = *--v10;
    v10 = (int *)((char *)v10 - 1);
    v8 = *(_BYTE *)v10;
    --v9;
    if ( v8 == 7 )
    {
      v12 = GetParentLocalId(v13);
      sub_807B25E(v13);
      RemoveRefToObject(v13);
      if ( v13 == a1 )
      {
        ++v9;
        *(_BYTE *)v10 = 0;
        sub_807B128(a2, dword_8394018);
        *(_DWORD *)a3 = v11;
        *(_WORD *)(a3 + 8) = v12;
        *(_WORD *)(a3 + 4) = v9;
        v6[1] = 10;
        v6[0] = a3;
        v3 = sub_807C0A8(dword_839401C, dword_8394018);
        v4 = sub_807CAD2(v3);
        v7 = sub_807C11A(v4, a2);
        return sub_807C4C2(v7, v6);
      }
      v13 = v12;
    }
    else
    {
      RemoveRefToValueInternal(v8, v11);
    }
  }
  sub_807B25E(v13);
  RemoveRefToObject(v13);
  return sub_8076A50(a3, *(unsigned __int16 *)(a3 + 6));
}
// 8394018: using guessed type int dword_8394018;
// 839401C: using guessed type int dword_839401C;

//----- (080828BE) --------------------------------------------------------
int __cdecl sub_80828BE(int a1, int a2, char a3)
{
  int result; // eax
  int v4; // eax
  int v5[3]; // [esp+10h] [ebp-28h] BYREF
  unsigned __int8 v6; // [esp+1Fh] [ebp-19h]
  int v7; // [esp+20h] [ebp-18h]
  int *v8; // [esp+24h] [ebp-14h]
  int v9; // [esp+28h] [ebp-10h]
  unsigned int v10; // [esp+2Ch] [ebp-Ch]
  int v11; // [esp+30h] [ebp-8h]
  char v12; // [esp+37h] [ebp-1h]

  v12 = a3;
  v7 = *(unsigned __int16 *)(a2 + 4);
  v11 = *(unsigned __int16 *)(a2 + 8);
  v8 = (int *)(5 * v7 + a2 + 11);
  while ( v7 )
  {
    v9 = *--v8;
    v8 = (int *)((char *)v8 - 1);
    v6 = *(_BYTE *)v8;
    --v7;
    if ( v6 == 7 )
    {
      if ( sub_807BB58(dword_8394020, v11) )
      {
        ++v7;
        *(_WORD *)(a2 + 8) = v11;
        *(_WORD *)(a2 + 4) = v7;
        result = sub_807B04E(v11);
        if ( !v12 )
        {
          sub_807AFAC(a1, 0);
          *(_DWORD *)a2 = 0;
          v5[1] = 10;
          v5[0] = a2;
          v4 = sub_807C0CC(a1, 0x1FFFFu);
          return sub_807C4C2(v4, v5);
        }
        return result;
      }
      v10 = GetParentLocalId(v11);
      sub_807B25E(v11);
      RemoveRefToObject(v11);
      v11 = v10;
    }
    else
    {
      RemoveRefToValueInternal(v6, v9);
    }
  }
  if ( v12 )
    sub_807C16E(a1, 0x1FFFF);
  sub_807B25E(a1);
  RemoveRefToObject(a1);
  return sub_8076A50(a2, *(unsigned __int16 *)(a2 + 6));
}
// 8394020: using guessed type int dword_8394020;

//----- (08082A4A) --------------------------------------------------------
int __cdecl sub_8082A4A(int a1)
{
  int result; // eax
  int v2; // [esp+Ch] [ebp-Ch]
  int v3; // [esp+10h] [ebp-8h]
  int v4; // [esp+14h] [ebp-4h]

  v4 = dword_83D7608;
  v3 = dword_83D7608;
  while ( 1 )
  {
    v2 = dword_83D7624[6 * v4];
    if ( v2 == a1 )
      break;
    --v4;
    if ( !sub_807B1F0(v2) )
      v3 = v4;
  }
  while ( 1 )
  {
    result = v3;
    if ( v3 < v4 )
      break;
    dword_83D7620[6 * v3--] = (int)&unk_83D4100;
  }
  return result;
}
// 83D7608: using guessed type int dword_83D7608;
// 83D7620: using guessed type int dword_83D7620[];
// 83D7624: using guessed type int dword_83D7624[];

//----- (08082AC0) --------------------------------------------------------
int __cdecl sub_8082AC0(int a1, int a2)
{
  int v2; // eax
  int v4; // [esp+18h] [ebp-10h]
  int v5; // [esp+1Ch] [ebp-Ch]
  int v6; // [esp+20h] [ebp-8h]
  int v7; // [esp+24h] [ebp-4h]

  v6 = sub_807B1C8(a2);
  sub_807B190(a2);
  v2 = FindVariable(dword_839401C, v6);
  v7 = sub_807CB1E(v2);
  v5 = sub_807BB58(v7, a2);
  v4 = *(_DWORD *)sub_807C4FC(v5);
  sub_807C228(v7, a2);
  if ( !sub_807C9AC(v7) && v6 != dword_8394018 )
    sub_807C16E(dword_839401C, v6);
  return sub_8082754(a1, a2, v4);
}
// 8394018: using guessed type int dword_8394018;
// 839401C: using guessed type int dword_839401C;

//----- (08082B7E) --------------------------------------------------------
int __cdecl sub_8082B7E(int a1)
{
  int v1; // eax
  int v2; // eax
  __int16 *v3; // eax
  int result; // eax
  int v5; // [esp+10h] [ebp-8h]
  int v6; // [esp+14h] [ebp-4h]

  v6 = sub_807B766(a1);
  v1 = sub_807BB58(dword_8394020, v6);
  v5 = sub_807CB1E(v1);
  v2 = sub_807BB58(v5, a1);
  v3 = sub_807C4FC(v2);
  sub_80823CE(*(_DWORD *)v3, a1);
  sub_807C228(v5, a1);
  result = sub_807C9AC(v5);
  if ( !result )
    return sub_807C228(dword_8394020, v6);
  return result;
}
// 8394020: using guessed type int dword_8394020;

//----- (08082C1A) --------------------------------------------------------
int __cdecl sub_8082C1A(int a1, int a2)
{
  unsigned __int16 v2; // ax
  int v3; // eax
  int v4; // eax
  int v5; // eax
  int v6; // eax
  int v8; // [esp+18h] [ebp-20h]
  int v9; // [esp+1Ch] [ebp-1Ch]
  int v10; // [esp+1Ch] [ebp-1Ch]
  int v11; // [esp+20h] [ebp-18h]
  int v12; // [esp+24h] [ebp-14h]
  int v13; // [esp+28h] [ebp-10h]
  int v14; // [esp+2Ch] [ebp-Ch]
  int v15; // [esp+30h] [ebp-8h]
  int v16; // [esp+34h] [ebp-4h]

  v2 = sub_807B110(a2);
  v14 = v2;
  if ( v2 )
  {
    v16 = sub_807B766(a2);
    v3 = sub_807BB58(dword_8394020, v16);
    v15 = sub_807CB1E(v3);
    v4 = sub_807BB58(v15, a2);
    v13 = *(_DWORD *)sub_807C4FC(v4);
    v5 = FindVariable(v13, 131070);
    v11 = sub_807CB1E(v5);
    v6 = FindVariable(v11, v14);
    v12 = sub_807CB1E(v6);
    v9 = sub_807BB58(v12, a2);
    v8 = *(_DWORD *)sub_807C4FC(v9);
    sub_8082366(v13, a2, v11, v12, v14);
    sub_807C228(v15, a2);
    if ( !sub_807C9AC(v15) )
      sub_807C228(dword_8394020, v16);
  }
  else
  {
    v10 = FindVariable(a2, 0x1FFFF);
    v8 = *(_DWORD *)sub_807C4FC(v10);
    sub_807C16E(a2, 0x1FFFF);
  }
  return sub_8082754(a1, a2, v8);
}
// 8394020: using guessed type int dword_8394020;

//----- (08082D9A) --------------------------------------------------------
int __cdecl sub_8082D9A(int a1, int a2)
{
  unsigned __int16 v2; // ax
  int v3; // eax
  int v4; // eax
  __int16 *v5; // eax
  int v6; // eax
  int v7; // eax
  int v10; // [esp+10h] [ebp-18h]
  int v11; // [esp+14h] [ebp-14h]
  int v12; // [esp+1Ch] [ebp-Ch]
  int v13; // [esp+20h] [ebp-8h]
  int v14; // [esp+24h] [ebp-4h]

  v2 = sub_807B110(a2);
  v12 = v2;
  if ( !v2 )
    return FindVariable(a2, 0x1FFFF);
  v14 = sub_807B766(a2);
  v3 = sub_807BB58(dword_8394020, v14);
  v13 = sub_807CB1E(v3);
  v4 = sub_807BB58(v13, a2);
  v5 = sub_807C4FC(v4);
  v6 = FindVariable(*(_DWORD *)v5, 131070);
  v10 = sub_807CB1E(v6);
  v7 = FindVariable(v10, v12);
  v11 = sub_807CB1E(v7);
  return sub_807BB58(v11, a2);
}
// 8394020: using guessed type int dword_8394020;

//----- (08082E74) --------------------------------------------------------
_BOOL4 __cdecl sub_8082E74(unsigned int a1)
{
  int v3; // [esp+14h] [ebp-4h]

  if ( GetVarType(a1) != 16 )
    return 0;
  if ( sub_807B22A(a1) != a1 )
    return 0;
  v3 = sub_8082D9A(a1, a1);
  return GetVarType(v3) == 0;
}

//----- (08082EE2) --------------------------------------------------------
int __cdecl sub_8082EE2(unsigned int a1)
{
  int result; // eax
  int v2; // [esp+14h] [ebp-4h]

  v2 = sub_807B22A(a1);
  result = GetVarType(v2);
  if ( result == 16 )
    return sub_8082C1A(a1, v2);
  if ( result > 16 )
  {
    if ( result == 17 )
      return sub_8082AC0(a1, v2);
  }
  else if ( result == 15 )
  {
    return sub_8082A4A(a1);
  }
  return result;
}

//----- (08082F56) --------------------------------------------------------
int __cdecl sub_8082F56(int a1, int a2, int *a3)
{
  int result; // eax
  int v4; // eax
  int v5; // edx
  int v6; // eax
  int v7; // eax
  int v8; // [esp+1Ch] [ebp-5Ch]
  int v9[2]; // [esp+20h] [ebp-58h] BYREF
  int v10; // [esp+28h] [ebp-50h] BYREF
  int v11; // [esp+2Ch] [ebp-4Ch]
  int v12[2]; // [esp+30h] [ebp-48h] BYREF
  bool v13; // [esp+3Bh] [ebp-3Dh]
  int v14; // [esp+3Ch] [ebp-3Ch]
  int v15; // [esp+40h] [ebp-38h]
  int v16; // [esp+44h] [ebp-34h]
  int v17; // [esp+48h] [ebp-30h]
  size_t n; // [esp+4Ch] [ebp-2Ch]
  int v19; // [esp+50h] [ebp-28h]
  int v20; // [esp+54h] [ebp-24h]
  unsigned __int8 *v21; // [esp+58h] [ebp-20h]
  const char **v22; // [esp+5Ch] [ebp-1Ch]
  const char **v23; // [esp+60h] [ebp-18h]
  __int16 *v24; // [esp+64h] [ebp-14h]
  int *i; // [esp+68h] [ebp-10h]
  int v26; // [esp+6Ch] [ebp-Ch]
  int v27; // [esp+70h] [ebp-8h]
  int v28; // [esp+74h] [ebp-4h]

  result = FindVariable(a1, 131070);
  v27 = result;
  if ( result )
  {
    v27 = sub_807CB1E(v27);
    result = FindVariable(v27, a2);
    v28 = result;
    if ( result )
    {
      v28 = sub_807CB1E(v28);
      AddRefToObject(v28);
      byte_839400C = 1;
      v14 = v28;
LABEL_4:
      while ( 1 )
      {
        v14 = sub_807CA16(v14);
        if ( !v14 )
          break;
        v26 = sub_807A3E8(v14);
        v16 = sub_807B766(v26);
        v4 = sub_807BB58(dword_8394020, v16);
        v15 = sub_807CB1E(v4);
        if ( GetVarType(v14) )
        {
          v24 = sub_807C4FC(v14);
          v23 = *(const char ***)v24;
          if ( *(*v23 - 1) == 119 )
          {
            v20 = **v23;
            v21 = (unsigned __int8 *)v23 + 5 * (*((unsigned __int16 *)v23 + 2) - v20) + 11;
            for ( i = a3; v20; i -= 2 )
            {
              if ( i[1] == 8 )
                goto LABEL_4;
              --v20;
              v11 = *v21;
              if ( v11 == 8 )
                break;
              v10 = *(_DWORD *)++v21;
              v21 += 4;
              sub_807578C(&v10);
              v5 = i[1];
              v12[0] = *i;
              v12[1] = v5;
              sub_807578C(v12);
              Scr_EvalEquality(&v10, v12);
              if ( *(_DWORD *)dword_8394010 )
              {
                scriptError(*v23, **v23 - v20 + 3, *(const char **)dword_8394010, (void *)dword_83D5590);
                sub_807F810();
                goto LABEL_4;
              }
              if ( !v10 )
                goto LABEL_4;
            }
            ++*v23;
            v13 = 1;
          }
          else
          {
            v13 = a3[1] == 8;
          }
          v9[1] = 10;
          v9[0] = (int)v23;
          v6 = sub_807C0A8(dword_839401C, dword_8394018);
          v7 = sub_807CAD2(v6);
          v8 = sub_807C11A(v7, v26);
          sub_807C4C2(v8, v9);
          v24 = sub_807C4FC(v8);
          sub_8082366(a1, v26, v27, v28, a2);
          sub_807C228(v15, v26);
          if ( !sub_807C9AC(v15) )
            sub_807C228(dword_8394020, v16);
          sub_807B128(v26, dword_8394018);
          if ( v13 )
          {
            v14 = v28;
          }
          else
          {
            v20 = *((unsigned __int16 *)v23 + 2);
            v19 = v20;
            i = a3;
            do
            {
              ++v19;
              i -= 2;
            }
            while ( i[1] != 8 );
            n = 5 * v20;
            v17 = 5 * v19 + 11;
            if ( !sub_8076B6C(*((unsigned __int16 *)v23 + 3), v17) )
            {
              v22 = (const char **)sub_8076A2A(v17);
              *((_WORD *)v22 + 3) = v17;
              *v22 = *v23;
              *((_WORD *)v22 + 4) = *((_WORD *)v23 + 4);
              memcpy((char *)v22 + 11, (char *)v23 + 11, n);
              sub_8076A50((int)v23, *((unsigned __int16 *)v23 + 3));
              v23 = v22;
              *(_DWORD *)v24 = v22;
            }
            *((_WORD *)v23 + 2) = v19;
            v21 = (unsigned __int8 *)v23 + n + 11;
            v19 -= v20;
            do
            {
              i += 2;
              sub_807578C(i);
              *v21++ = *((_BYTE *)i + 4);
              *(_DWORD *)v21 = *i;
              v21 += 4;
              --v19;
            }
            while ( v19 );
            v14 = v28;
          }
        }
        else
        {
          sub_8082366(a1, v26, v27, v28, a2);
          sub_807B360(v26);
          sub_807C228(v15, v26);
          if ( !sub_807C9AC(v15) )
            sub_807C228(dword_8394020, v16);
          sub_8082EE2(v16);
          v14 = v28;
        }
      }
      result = RemoveRefToObject(v28);
      byte_839400C = 0;
    }
  }
  return result;
}
// 839400C: using guessed type char byte_839400C;
// 8394018: using guessed type int dword_8394018;
// 839401C: using guessed type int dword_839401C;
// 8394020: using guessed type int dword_8394020;
// 83D5590: using guessed type int dword_83D5590;

//----- (08083426) --------------------------------------------------------
int __cdecl sub_8083426(int a1, int a2, int a3, int a4)
{
  int result; // eax
  int v5; // [esp+Ch] [ebp-Ch]
  int v6; // [esp+10h] [ebp-8h]
  int v7; // [esp+14h] [ebp-4h]
  int v8; // [esp+2Ch] [ebp+14h]

  sub_807FA9C();
  v6 = dword_83D7610 - 8 * a4;
  v8 = dword_83D7618 - a4;
  v7 = sub_807E346(a1, a2);
  if ( v7 )
  {
    v5 = *(_DWORD *)(v6 + 4);
    *(_DWORD *)(v6 + 4) = 8;
    dword_83D7618 = 0;
    sub_8082F56(v7, a3, (int *)dword_83D7610);
    *(_DWORD *)(v6 + 4) = v5;
  }
  while ( dword_83D7610 != v6 )
  {
    RemoveRefToValue((_DWORD *)dword_83D7610);
    dword_83D7610 -= 8;
  }
  result = v8;
  dword_83D7618 = v8;
  return result;
}
// 83D7610: using guessed type int dword_83D7610;
// 83D7618: using guessed type int dword_83D7618;

//----- (080834DC) --------------------------------------------------------
int __cdecl sub_80834DC(int a1)
{
  int result; // eax
  int v2; // [esp+Ch] [ebp-1Ch]
  int v3; // [esp+10h] [ebp-18h]
  int v4; // [esp+14h] [ebp-14h]
  int v5; // [esp+14h] [ebp-14h]
  int v6; // [esp+18h] [ebp-10h]
  int v7; // [esp+1Ch] [ebp-Ch]
  int v8; // [esp+20h] [ebp-8h]
  int v9; // [esp+24h] [ebp-4h]
  int v10; // [esp+24h] [ebp-4h]

  while ( 1 )
  {
    result = FindVariable(a1, 131070);
    if ( !result )
      break;
    v7 = sub_807CB1E(result);
    result = sub_807C9CE(v7);
    if ( !result )
      break;
    v8 = sub_807CB1E(result);
    result = sub_807C9CE(v8);
    v9 = result;
    if ( !result )
      break;
    v6 = sub_807A3E8(result);
    if ( GetVarType(v9) == 10 )
    {
      v4 = *(_DWORD *)sub_807C4FC(v9);
      sub_8082B7E(v6);
      sub_80828BE(v6, v4, 0);
    }
    else
    {
      AddRefToObject(v6);
      sub_8082B7E(v6);
      v3 = sub_807B766(v6);
      v2 = sub_807B22A(v3);
      v10 = FindVariable(v2, 0x1FFFF);
      if ( v10 )
      {
        v5 = *(_DWORD *)sub_807C4FC(v10);
        sub_80828BE(v2, v5, 1);
      }
      sub_807B360(v6);
      sub_807B8D4(v6);
    }
  }
  return result;
}

//----- (08083640) --------------------------------------------------------
int __cdecl sub_8083640(int a1)
{
  int v2; // [esp+Ch] [ebp-Ch]
  int v3; // [esp+10h] [ebp-8h]
  int v4; // [esp+14h] [ebp-4h]

  AddRefToObject(a1);
  while ( 1 )
  {
    v4 = sub_807C9CE(a1);
    if ( !v4 )
      break;
    v3 = sub_807A3E8(v4);
    v2 = *(_DWORD *)sub_807C4FC(v4);
    sub_807C228(a1, v3);
    sub_807B190(v3);
    sub_8082754(v3, v3, v2);
  }
  return RemoveRefToObject(a1);
}

//----- (080836CA) --------------------------------------------------------
unsigned int __cdecl sub_80836CA(int a1)
{
  int v1; // eax
  unsigned int result; // eax
  int v3; // [esp+24h] [ebp-34h]
  int v4; // [esp+28h] [ebp-30h]
  int v5; // [esp+2Ch] [ebp-2Ch]
  unsigned __int8 *v6[4]; // [esp+30h] [ebp-28h] BYREF
  char *i; // [esp+40h] [ebp-18h]

  sub_8084FE0();
  AddRefToObject(a1);
  for ( i = (char *)&unk_83D7920; ; RemoveRefToValue((_DWORD *)i + 2) )
  {
    v5 = sub_807C9CE(a1);
    if ( !v5 )
      break;
    v4 = sub_807A3E8(v5);
    v3 = *(_DWORD *)sub_807C4FC(v5);
    sub_807C228(a1, v4);
    sub_80825C2(v4, v6, v3);
    v1 = sub_807FB08(v6[0], (int)v6[1], (int)v6[2], (_DWORD *)v6[3], i);
    RemoveRefToObject(v1);
  }
  RemoveRefToObject(a1);
  result = sub_807C5E2(dword_8394034);
  dword_83D7610 = (int)&unk_83D7920;
  return result;
}
// 8394034: using guessed type int dword_8394034;
// 83D7610: using guessed type int dword_83D7610;

//----- (080837B0) --------------------------------------------------------
int sub_80837B0()
{
  int result; // eax

  sub_807FA9C();
  result = dword_83D7610;
  if ( dword_83D7610 == dword_83D7604 )
    Com_Error(1, (char *)&byte_8140CE0);
  dword_83D7610 += 8;
  ++dword_83D7618;
  return result;
}
// 83D7604: using guessed type int dword_83D7604;
// 83D7610: using guessed type int dword_83D7610;
// 83D7618: using guessed type int dword_83D7618;

//----- (080837EC) --------------------------------------------------------
int __cdecl VM_Execute(int a1, char *a2, int a3)
{
  int v5; // [esp+2Ch] [ebp-2Ch]
  int v6; // [esp+34h] [ebp-24h]
  int v7; // [esp+40h] [ebp-18h]
  int v8; // [esp+68h] [ebp+10h]

  sub_807FA9C();
  v7 = dword_83D7610 - 8 * a3;
  v8 = dword_83D7618 - a3;
  if ( dword_83D7608 > 29 )
  {
    sub_807B25E(a1);
    dword_83D7618 = v8 + 1;
    while ( v8 )
    {
      RemoveRefToValue((_DWORD *)dword_83D7610);
      dword_83D7610 -= 8;
      --v8;
    }
    dword_83D7610 += 8;
    *(_DWORD *)(dword_83D7610 + 4) = 0;
    scriptError(a2, 0, "script stack overflow (too many embedded function calls)", 0);
    return a1;
  }
  else
  {
    if ( dword_83D7608 )
    {
      ++dword_83D7608;
      dword_83D760C += 24;
      *(_DWORD *)(dword_83D760C + 4) = 0;
    }
    *(_DWORD *)dword_83D760C = a2;
    ++dword_83D7608;
    dword_83D760C += 24;
    *(_DWORD *)(dword_83D760C + 4) = a1;
    v5 = *(_DWORD *)(v7 + 4);
    *(_DWORD *)(v7 + 4) = 8;
    dword_83D7618 = 0;
    v6 = sub_807FB08((unsigned __int8 *)a2, a1, 0, (_DWORD *)dword_83D7610, (char *)v7);
    *(_DWORD *)(v7 + 4) = v5;
    dword_83D7610 = v7 + 8;
    dword_83D7618 = v8 + 1;
    sub_807C5E2(dword_8394034);
    if ( dword_83D7608 )
    {
      --dword_83D7608;
      dword_83D760C -= 24;
    }
    return v6;
  }
}
// 8394034: using guessed type int dword_8394034;
// 83D7608: using guessed type int dword_83D7608;
// 83D760C: using guessed type int dword_83D760C;
// 83D7610: using guessed type int dword_83D7610;
// 83D7618: using guessed type int dword_83D7618;

//----- (0808398E) --------------------------------------------------------
int __cdecl Scr_ExecThread(int a1, int a2)
{
  int v2; // eax
  char *v4; // [esp+10h] [ebp-8h]
  unsigned __int16 v5; // [esp+14h] [ebp-4h]

  v4 = (char *)(dword_8394048 + a1);
  if ( !dword_83D7608 )
    sub_8084FE0();
  Scr_IsInOpcodeMemory((int)v4);
  AddRefToObject(dword_8394024);
  v2 = AllocThread(dword_8394024);
  v5 = VM_Execute(v2, v4, a2);
  RemoveRefToValue((_DWORD *)dword_83D7610);
  *(_DWORD *)(dword_83D7610 + 4) = 0;
  dword_83D7610 -= 8;
  --dword_83D7618;
  return v5;
}
// 8394024: using guessed type int dword_8394024;
// 8394048: using guessed type int dword_8394048;
// 83D7608: using guessed type int dword_83D7608;
// 83D7610: using guessed type int dword_83D7610;
// 83D7618: using guessed type int dword_83D7618;

//----- (08083A1A) --------------------------------------------------------
int __cdecl sub_8083A1A(int a1, int a2, int a3, int a4)
{
  int v4; // eax
  char *v6; // [esp+Ch] [ebp-Ch]
  int v7; // [esp+10h] [ebp-8h]
  unsigned __int16 v8; // [esp+14h] [ebp-4h]

  v6 = (char *)(dword_8394048 + a3);
  if ( !dword_83D7608 )
    sub_8084FE0();
  v7 = sub_807E3A6(a1, a2);
  AddRefToObject(v7);
  v4 = AllocThread(v7);
  v8 = VM_Execute(v4, v6, a4);
  RemoveRefToValue((_DWORD *)dword_83D7610);
  *(_DWORD *)(dword_83D7610 + 4) = 0;
  dword_83D7610 -= 8;
  --dword_83D7618;
  return v8;
}
// 8394048: using guessed type int dword_8394048;
// 83D7608: using guessed type int dword_83D7608;
// 83D7610: using guessed type int dword_83D7610;
// 83D7618: using guessed type int dword_83D7618;

//----- (08083AAC) --------------------------------------------------------
int __cdecl sub_8083AAC(int a1, int a2)
{
  int v2; // eax
  int v3; // eax
  int result; // eax
  char *v5; // [esp+14h] [ebp-4h]

  v5 = (char *)(dword_8394048 + a1);
  if ( !dword_83D7608 )
    sub_8084FE0();
  AddRefToObject(dword_8394024);
  v2 = AllocThread(dword_8394024);
  v3 = VM_Execute(v2, v5, a2);
  result = RemoveRefToObject(v3);
  ++dword_83D761C;
  --dword_83D7618;
  return result;
}
// 8394024: using guessed type int dword_8394024;
// 8394048: using guessed type int dword_8394048;
// 83D7608: using guessed type int dword_83D7608;
// 83D7618: using guessed type int dword_83D7618;
// 83D761C: using guessed type int dword_83D761C;

//----- (08083B14) --------------------------------------------------------
int __cdecl sub_8083B14(int a1, int a2, int a3, int a4)
{
  int v4; // eax
  int v5; // eax
  int result; // eax
  int v7; // [esp+10h] [ebp-8h]
  char *v8; // [esp+14h] [ebp-4h]

  v8 = (char *)(dword_8394048 + a3);
  if ( !dword_83D7608 )
    sub_8084FE0();
  v7 = sub_807E3A6(a1, a2);
  AddRefToObject(v7);
  v4 = AllocThread(v7);
  v5 = VM_Execute(v4, v8, a4);
  result = RemoveRefToObject(v5);
  ++dword_83D761C;
  --dword_83D7618;
  return result;
}
// 8394048: using guessed type int dword_8394048;
// 83D7608: using guessed type int dword_83D7608;
// 83D7618: using guessed type int dword_83D7618;
// 83D761C: using guessed type int dword_83D761C;

//----- (08083B8E) --------------------------------------------------------
int __cdecl Scr_FreeThread(unsigned __int16 a1)
{
  return RemoveRefToObject(a1);
}

//----- (08083BAA) --------------------------------------------------------
int __cdecl sub_8083BAA(char *a1, int a2)
{
  int result; // eax
  int v3; // [esp+24h] [ebp+Ch]

  sub_8084FE0();
  byte_83D7614 = 1;
  if ( a2 )
  {
    result = VM_Execute(a2, a1, 0);
  }
  else
  {
    AddRefToObject(dword_8394024);
    v3 = AllocThread(dword_8394024);
    VM_Execute(v3, a1, 0);
    sub_807B25E(v3);
    result = RemoveRefToObject(v3);
  }
  byte_83D7614 = 0;
  if ( dword_83D7608 )
  {
    --dword_83D7608;
    dword_83D760C -= 24;
  }
  dword_83D7610 -= 8;
  dword_83D7618 = 0;
  return result;
}
// 8394024: using guessed type int dword_8394024;
// 83D7608: using guessed type int dword_83D7608;
// 83D760C: using guessed type int dword_83D760C;
// 83D7610: using guessed type int dword_83D7610;
// 83D7614: using guessed type char byte_83D7614;
// 83D7618: using guessed type int dword_83D7618;

//----- (08083C5C) --------------------------------------------------------
void sub_8083C5C()
{
  int v0; // eax
  int v1; // [esp+14h] [ebp-4h]

  if ( dword_839401C )
  {
    v1 = FindVariable(dword_839401C, dword_8394018);
    if ( v1 )
    {
      v0 = sub_807CB1E(v1);
      sub_80836CA(v0);
      sub_807C290(dword_839401C, dword_8394018);
    }
  }
}
// 8394018: using guessed type int dword_8394018;
// 839401C: using guessed type int dword_839401C;

//----- (08083CBA) --------------------------------------------------------
int __cdecl sub_8083CBA(int a1, int a2, int a3, char a4, int a5)
{
  int v6; // [esp+8h] [ebp-10h]
  int j; // [esp+Ch] [ebp-Ch]
  int i; // [esp+10h] [ebp-8h]

  v6 = sub_807CB1E(a2);
  for ( i = sub_807C9CE(v6); i; i = sub_807C9CE(i) )
  {
    if ( GetVarType(i) == 10 )
    {
      for ( j = *(unsigned __int16 *)(*(_DWORD *)sub_807C4FC(i) + 8); j; j = sub_807B1F0(j) )
      {
        if ( !a4 || a1 == sub_807B766(j) )
        {
          if ( a5 )
            *(_DWORD *)(a5 + 4 * a3) = j;
          ++a3;
          break;
        }
      }
    }
  }
  return a3;
}

//----- (08083D82) --------------------------------------------------------
int __cdecl sub_8083D82(int a1, int *a2, int a3)
{
  int v3; // eax
  int v5; // [esp+1Ch] [ebp-Ch]
  int v6; // [esp+20h] [ebp-8h]
  int j; // [esp+20h] [ebp-8h]
  int i; // [esp+24h] [ebp-4h]

  v5 = 0;
  if ( a3 && a1 == sub_807B766(a3) )
  {
    if ( a2 )
      *a2 = a3;
    v5 = 1;
  }
  for ( i = sub_807C9CE(dword_839401C); i; i = sub_807C9CE(i) )
    v5 = sub_8083CBA(a1, i, v5, 1, (int)a2);
  v6 = FindVariable(a1, 131070);
  if ( v6 )
  {
    v3 = sub_807CB1E(v6);
    for ( j = sub_807C9CE(v3); j; j = sub_807C9CE(j) )
      v5 = sub_8083CBA(a1, j, v5, 0, (int)a2);
  }
  return v5;
}
// 839401C: using guessed type int dword_839401C;

//----- (08083E96) --------------------------------------------------------
int sub_8083E96()
{
  int result; // eax

  dword_839401C = sub_807B5A0();
  dword_8394020 = sub_807B658();
  dword_8394024 = sub_807B5A0();
  result = sub_807B5A0();
  dword_839402C = result;
  dword_8394018 = 0;
  dword_83D553C = -1;
  return result;
}
// 8394018: using guessed type int dword_8394018;
// 839401C: using guessed type int dword_839401C;
// 8394020: using guessed type int dword_8394020;
// 8394024: using guessed type int dword_8394024;
// 839402C: using guessed type int dword_839402C;
// 83D553C: using guessed type int dword_83D553C;

//----- (08083EDA) --------------------------------------------------------
unsigned int *__cdecl sub_8083EDA(int a1, int a2)
{
  unsigned int *result; // eax
  int v3; // eax
  int v4; // eax
  int v5; // [esp+Ch] [ebp-Ch]
  int i; // [esp+10h] [ebp-8h]
  int v7; // [esp+10h] [ebp-8h]
  int v8; // [esp+10h] [ebp-8h]

  sub_8075758();
  result = (unsigned int *)sub_807E04A();
  if ( dword_839401C )
  {
    sub_807F676(a2);
    for ( i = sub_807C9CE(dword_839401C); i; i = sub_807C9CE(i) )
    {
      v3 = sub_807CB1E(i);
      sub_8083640(v3);
    }
    while ( 1 )
    {
      v7 = sub_807C9CE(dword_8394020);
      if ( !v7 )
        break;
      v4 = sub_807CB1E(v7);
      v8 = sub_807C9CE(v4);
      v5 = *(_DWORD *)sub_807C4FC(v8);
      AddRefToObject(v5);
      sub_80834DC(v5);
      RemoveRefToObject(v5);
    }
    sub_807AF82(dword_8394024);
    sub_807B8D4(dword_8394024);
    dword_8394024 = 0;
    sub_807AF82(dword_839402C);
    sub_807B8D4(dword_839402C);
    dword_839402C = 0;
    sub_807AF82(dword_839401C);
    sub_807B8D4(dword_839401C);
    dword_839401C = 0;
    sub_807B8D4(dword_8394020);
    dword_8394020 = 0;
    return sub_807E0C6();
  }
  return result;
}
// 839401C: using guessed type int dword_839401C;
// 8394020: using guessed type int dword_8394020;
// 8394024: using guessed type int dword_8394024;
// 839402C: using guessed type int dword_839402C;

//----- (08084030) --------------------------------------------------------
_BOOL4 Scr_IsSystemActive()
{
  return dword_839401C != 0;
}
// 839401C: using guessed type int dword_839401C;

//----- (0808404C) --------------------------------------------------------
int __cdecl Scr_GetInt(unsigned int a1)
{
  char *v1; // eax
  char *v2; // eax
  _DWORD *v5; // [esp+14h] [ebp-4h]

  if ( a1 >= dword_83D761C )
    goto LABEL_5;
  v5 = (_DWORD *)(dword_83D7610 - 8 * a1);
  if ( v5[1] != 6 )
  {
    dword_8394014 = a1 + 1;
    v1 = va("type %s is not an int", *(const char **)&off_815ABC0[4 * v5[1]]);
    Scr_Error((int)v1);
LABEL_5:
    v2 = va("parameter %d does not exist", a1 + 1);
    Scr_Error((int)v2);
    return 0;
  }
  return *v5;
}
// 8394014: using guessed type int dword_8394014;
// 83D7610: using guessed type int dword_83D7610;
// 83D761C: using guessed type int dword_83D761C;

//----- (080840DA) --------------------------------------------------------
unsigned __int16 *__userpurge Scr_GetAnim@<eax>(unsigned __int16 *a1, unsigned int a2, int a3)
{
  int v3; // ebx
  int v4; // eax
  const char *v5; // ebx
  int v6; // eax
  const char *v7; // esi
  int v8; // eax
  char *v9; // eax
  char *v10; // eax
  _DWORD *v12; // [esp+1Ch] [ebp-Ch]

  if ( a2 >= dword_83D761C )
    goto LABEL_8;
  v12 = (_DWORD *)(dword_83D7610 - 8 * a2);
  if ( v12[1] != 11 )
  {
    *(_DWORD *)dword_8394010 = va("type %s is not an anim", *(const char **)&off_815ABC0[4 * v12[1]]);
    goto LABEL_7;
  }
  *(_DWORD *)a1 = *v12;
  if ( a3 )
  {
    v3 = Scr_GetAnims(a1[1]);
    if ( v3 != sub_80BA87C(a3) )
    {
      v4 = sub_80BA87C(a3);
      v5 = (const char *)sub_80BEA0E(v4);
      v6 = Scr_GetAnims(a1[1]);
      v7 = (const char *)sub_80BEA0E(v6);
      v8 = Scr_GetAnims(a1[1]);
      v9 = sub_80BE94C(v8, *a1);
      *(_DWORD *)dword_8394010 = va(
                                   "anim '%s' in animtree '%s' does not belong to the entity's animtree '%s'",
                                   v9,
                                   v7,
                                   v5);
LABEL_7:
      RemoveRefToValue(v12);
      v12[1] = 0;
      dword_8394014 = a2 + 1;
      sub_807FA00();
LABEL_8:
      v10 = va("parameter %d does not exist", a2 + 1);
      Scr_Error((int)v10);
      *a1 = 0;
      a1[1] = 0;
    }
  }
  return a1;
}
// 8394014: using guessed type int dword_8394014;
// 83D7610: using guessed type int dword_83D7610;
// 83D761C: using guessed type int dword_83D761C;

//----- (0808423E) --------------------------------------------------------
_DWORD *__userpurge Scr_GetAnimTree@<eax>(_DWORD *a1, unsigned int a2)
{
  char *v2; // eax
  int *v4; // [esp+10h] [ebp-8h]
  int v5; // [esp+14h] [ebp-4h]

  if ( a2 >= dword_83D761C )
    goto LABEL_9;
  v4 = (int *)(dword_83D7610 - 8 * a2);
  if ( v4[1] != 6 )
  {
    *(_DWORD *)dword_8394010 = va("type %s is not an animtree", *(const char **)&off_815ABC0[4 * v4[1]]);
    goto LABEL_8;
  }
  v5 = *v4;
  if ( *v4 > (unsigned int)dword_8202850 || !dword_820264C[v5] )
  {
    *(_DWORD *)dword_8394010 = "bad anim tree";
LABEL_8:
    RemoveRefToValue(v4);
    v4[1] = 0;
    dword_8394014 = a2 + 1;
    sub_807FA00();
LABEL_9:
    v2 = va("parameter %d does not exist", a2 + 1);
    Scr_Error((int)v2);
    *a1 = dword_820264C[0];
    return a1;
  }
  *a1 = dword_820264C[v5];
  return a1;
}
// 820264C: using guessed type int dword_820264C[128];
// 8202850: using guessed type int dword_8202850;
// 8394014: using guessed type int dword_8394014;
// 83D7610: using guessed type int dword_83D7610;
// 83D761C: using guessed type int dword_83D761C;

//----- (08084320) --------------------------------------------------------
long double __cdecl Scr_GetFloat(unsigned int a1)
{
  char *v1; // eax
  char *v2; // eax
  int *v5; // [esp+14h] [ebp-4h]

  if ( a1 >= dword_83D761C )
    goto LABEL_7;
  v5 = (int *)(dword_83D7610 - 8 * a1);
  if ( v5[1] != 5 )
  {
    if ( v5[1] == 6 )
      return (float)*v5;
    dword_8394014 = a1 + 1;
    v1 = va("type %s is not a float", *(const char **)&off_815ABC0[4 * v5[1]]);
    Scr_Error((int)v1);
LABEL_7:
    v2 = va("parameter %d does not exist", a1 + 1);
    Scr_Error((int)v2);
    return (float)0.0;
  }
  return *(float *)v5;
}
// 8394014: using guessed type int dword_8394014;
// 83D7610: using guessed type int dword_83D7610;
// 83D761C: using guessed type int dword_83D761C;

//----- (080843C0) --------------------------------------------------------
int __cdecl Scr_GetConstString(unsigned int a1)
{
  char *v1; // eax
  int *v4; // [esp+14h] [ebp-4h]

  if ( a1 >= dword_83D761C )
    goto LABEL_5;
  v4 = (int *)(dword_83D7610 - 8 * a1);
  if ( !(unsigned __int8)sub_807CCCE(v4) )
  {
    dword_8394014 = a1 + 1;
    sub_807FA00();
LABEL_5:
    v1 = va("parameter %d does not exist", a1 + 1);
    Scr_Error((int)v1);
    return 0;
  }
  return *v4;
}
// 8394014: using guessed type int dword_8394014;
// 83D7610: using guessed type int dword_83D7610;
// 83D761C: using guessed type int dword_83D761C;

//----- (08084434) --------------------------------------------------------
int __cdecl sub_8084434(unsigned int a1)
{
  char *v1; // eax
  int v4; // [esp+20h] [ebp-2018h]
  int *v5; // [esp+24h] [ebp-2014h]
  int v6; // [esp+28h] [ebp-2010h]
  int i; // [esp+2Ch] [ebp-200Ch]
  char s[8200]; // [esp+30h] [ebp-2008h] BYREF

  if ( a1 >= dword_83D761C )
    goto LABEL_8;
  v5 = (int *)(dword_83D7610 - 8 * a1);
  if ( !(unsigned __int8)sub_807CCCE(v5) )
  {
    dword_8394014 = a1 + 1;
    sub_807FA00();
LABEL_8:
    v1 = va("parameter %d does not exist", a1 + 1);
    Scr_Error((int)v1);
    return 0;
  }
  v4 = *v5;
  v6 = SL_ConvertToString(*v5);
  for ( i = 0; ; ++i )
  {
    s[i] = tolower(*(char *)(v6 + i));
    if ( !*(_BYTE *)(v6 + i) )
      break;
  }
  *v5 = sub_80792C4(s, 0);
  SL_RemoveRefToString(v4);
  return *v5;
}
// 8394014: using guessed type int dword_8394014;
// 83D7610: using guessed type int dword_83D7610;
// 83D761C: using guessed type int dword_83D761C;
// 8084434: using guessed type char s[8200];

//----- (0808456A) --------------------------------------------------------
int __cdecl Scr_GetString(unsigned int a1)
{
  int v1; // eax

  v1 = Scr_GetConstString(a1);
  return SL_ConvertToString(v1);
}

//----- (08084586) --------------------------------------------------------
int __cdecl sub_8084586(unsigned int a1)
{
  if ( a1 >= dword_83D761C || *(_DWORD *)(dword_83D7610 - 8 * a1 + 4) )
    return Scr_GetConstString(a1);
  else
    return 0;
}
// 83D7610: using guessed type int dword_83D7610;
// 83D761C: using guessed type int dword_83D761C;

//----- (080845C8) --------------------------------------------------------
int __cdecl sub_80845C8(unsigned int a1)
{
  int v1; // eax

  v1 = Scr_GetConstString(a1);
  return SL_ConvertToString(v1);
}

//----- (080845E4) --------------------------------------------------------
int __cdecl sub_80845E4(unsigned int a1)
{
  char *v1; // eax
  int *v4; // [esp+14h] [ebp-4h]

  if ( a1 >= dword_83D761C )
  {
    v1 = va("parameter %d does not exist", a1 + 1);
    Scr_Error((int)v1);
    return 0;
  }
  else
  {
    v4 = (int *)(dword_83D7610 - 8 * a1);
    sub_807CDD0(v4);
    return SL_ConvertToString(*v4);
  }
}
// 83D7610: using guessed type int dword_83D7610;
// 83D761C: using guessed type int dword_83D761C;

//----- (0808464E) --------------------------------------------------------
int __cdecl sub_808464E(unsigned int a1)
{
  char *v1; // eax
  char *v2; // eax
  _DWORD *v5; // [esp+14h] [ebp-4h]

  if ( a1 >= dword_83D761C )
    goto LABEL_5;
  v5 = (_DWORD *)(dword_83D7610 - 8 * a1);
  if ( v5[1] != 3 )
  {
    dword_8394014 = a1 + 1;
    v1 = va("type %s is not a localized string", *(const char **)&off_815ABC0[4 * v5[1]]);
    Scr_Error((int)v1);
LABEL_5:
    v2 = va("parameter %d does not exist", a1 + 1);
    Scr_Error((int)v2);
    return 0;
  }
  return *v5;
}
// 8394014: using guessed type int dword_8394014;
// 83D7610: using guessed type int dword_83D7610;
// 83D761C: using guessed type int dword_83D761C;

//----- (080846DC) --------------------------------------------------------
int __cdecl Scr_GetIString(unsigned int a1)
{
  int v1; // eax

  v1 = sub_808464E(a1);
  return SL_ConvertToString(v1);
}

//----- (080846F8) --------------------------------------------------------
void __cdecl Scr_GetVector(unsigned int a1, _DWORD *a2)
{
  char *v2; // eax
  char *v3; // eax
  int v4; // [esp+14h] [ebp-4h]

  if ( a1 < dword_83D761C )
  {
    v4 = dword_83D7610 - 8 * a1;
    if ( *(_DWORD *)(v4 + 4) == 4 )
    {
      sub_8085124(*(_DWORD **)v4, a2);
      return;
    }
    dword_8394014 = a1 + 1;
    v2 = va("type %s is not a vector", *(const char **)&off_815ABC0[4 * *(_DWORD *)(v4 + 4)]);
    Scr_Error((int)v2);
  }
  v3 = va("parameter %d does not exist", a1 + 1);
  Scr_Error((int)v3);
}
// 8394014: using guessed type int dword_8394014;
// 83D7610: using guessed type int dword_83D7610;
// 83D761C: using guessed type int dword_83D761C;

//----- (08084788) --------------------------------------------------------
int __cdecl Scr_GetFunc(unsigned int a1)
{
  char *v1; // eax
  char *v2; // eax
  _DWORD *v5; // [esp+14h] [ebp-4h]

  if ( a1 >= dword_83D761C )
    goto LABEL_5;
  v5 = (_DWORD *)(dword_83D7610 - 8 * a1);
  if ( v5[1] != 9 )
  {
    dword_8394014 = a1 + 1;
    v1 = va("type %s is not a function", *(const char **)&off_815ABC0[4 * v5[1]]);
    Scr_Error((int)v1);
LABEL_5:
    v2 = va("parameter %d does not exist", a1 + 1);
    Scr_Error((int)v2);
    return 0;
  }
  return *v5 - dword_8394048;
}
// 8394014: using guessed type int dword_8394014;
// 8394048: using guessed type int dword_8394048;
// 83D7610: using guessed type int dword_83D7610;
// 83D761C: using guessed type int dword_83D761C;

//----- (0808481E) --------------------------------------------------------
_WORD *__userpurge Scr_GetEntityRef@<eax>(_WORD *a1, unsigned int a2)
{
  int v2; // eax
  char *v3; // eax
  char *v4; // eax
  char *v5; // eax
  int *v7; // [esp+Ch] [ebp-Ch]
  int v8; // [esp+14h] [ebp-4h]

  if ( a2 >= dword_83D761C )
    goto LABEL_7;
  v7 = (int *)(dword_83D7610 - 8 * a2);
  if ( v7[1] != 1 )
  {
LABEL_6:
    dword_8394014 = a2 + 1;
    v4 = va("type %s is not an entity", *(const char **)&off_815ABC0[4 * v7[1]]);
    Scr_Error((int)v4);
LABEL_7:
    v5 = va("parameter %d does not exist", a2 + 1);
    Scr_Error((int)v5);
    *(_DWORD *)a1 = 0;
    return a1;
  }
  v8 = *v7;
  if ( GetVarType(*v7) != 21 )
  {
    dword_8394014 = a2 + 1;
    v2 = GetVarType(v8);
    v3 = va("type %s is not an entity", *(const char **)&off_815ABC0[4 * v2]);
    Scr_Error((int)v3);
    goto LABEL_6;
  }
  sub_807EDC4(a1, v8);
  return a1;
}
// 8394014: using guessed type int dword_8394014;
// 83D7610: using guessed type int dword_83D7610;
// 83D761C: using guessed type int dword_83D761C;

//----- (0808491A) --------------------------------------------------------
int __cdecl sub_808491A(unsigned int a1)
{
  char *v1; // eax
  char *v2; // eax
  _DWORD *v5; // [esp+14h] [ebp-4h]

  if ( a1 >= dword_83D761C )
    goto LABEL_5;
  v5 = (_DWORD *)(dword_83D7610 - 8 * a1);
  if ( v5[1] != 1 )
  {
    dword_8394014 = a1 + 1;
    v1 = va("type %s is not an object", *(const char **)&off_815ABC0[4 * v5[1]]);
    Scr_Error((int)v1);
LABEL_5:
    v2 = va("parameter %d does not exist", a1 + 1);
    Scr_Error((int)v2);
    return 0;
  }
  return *v5;
}
// 8394014: using guessed type int dword_8394014;
// 83D7610: using guessed type int dword_83D7610;
// 83D761C: using guessed type int dword_83D761C;

//----- (080849A8) --------------------------------------------------------
int __cdecl Scr_GetType(unsigned int a1)
{
  char *v1; // eax

  if ( a1 < dword_83D761C )
    return *(_DWORD *)(dword_83D7610 - 8 * a1 + 4);
  v1 = va("parameter %d does not exist", a1 + 1);
  Scr_Error((int)v1);
  return 0;
}
// 83D7610: using guessed type int dword_83D7610;
// 83D761C: using guessed type int dword_83D761C;

//----- (080849F8) --------------------------------------------------------
int __cdecl sub_80849F8(unsigned int a1)
{
  char *v1; // eax

  if ( a1 < dword_83D761C )
    return *(_DWORD *)&off_815ABC0[4 * *(_DWORD *)(dword_83D7610 - 8 * a1 + 4)];
  v1 = va("parameter %d does not exist", a1 + 1);
  Scr_Error((int)v1);
  return 0;
}
// 83D7610: using guessed type int dword_83D7610;
// 83D761C: using guessed type int dword_83D761C;

//----- (08084A50) --------------------------------------------------------
int __cdecl Scr_GetPointerType(unsigned int a1)
{
  char *v1; // eax
  char *v2; // eax

  if ( a1 >= dword_83D761C )
    goto LABEL_5;
  if ( *(_DWORD *)(dword_83D7610 - 8 * a1 + 4) != 1 )
  {
    v1 = va(
           "type %s is not a pointer",
           *(const char **)&off_815ABC0[4 * *(_DWORD *)(dword_83D7610 - 8 * a1 + 4)]);
    Scr_Error((int)v1);
LABEL_5:
    v2 = va("parameter %d does not exist", a1 + 1);
    Scr_Error((int)v2);
    return 0;
  }
  return GetVarType(*(_DWORD *)(dword_83D7610 - 8 * a1));
}
// 83D7610: using guessed type int dword_83D7610;
// 83D761C: using guessed type int dword_83D761C;

//----- (08084AEE) --------------------------------------------------------
int Scr_GetNumParam()
{
  return dword_83D761C;
}
// 83D761C: using guessed type int dword_83D761C;

//----- (08084AF8) --------------------------------------------------------
int __cdecl Scr_AddBool(int a1)
{
  int result; // eax

  sub_80837B0();
  *(_DWORD *)(dword_83D7610 + 4) = 6;
  result = a1;
  *(_DWORD *)dword_83D7610 = a1;
  return result;
}
// 83D7610: using guessed type int dword_83D7610;

//----- (08084B1C) --------------------------------------------------------
int __cdecl Scr_AddInt(int a1)
{
  int result; // eax

  sub_80837B0();
  *(_DWORD *)(dword_83D7610 + 4) = 6;
  result = a1;
  *(_DWORD *)dword_83D7610 = a1;
  return result;
}
// 83D7610: using guessed type int dword_83D7610;

//----- (08084B40) --------------------------------------------------------
int __cdecl Scr_AddFloat(int a1)
{
  int result; // eax

  sub_80837B0();
  *(_DWORD *)(dword_83D7610 + 4) = 5;
  result = a1;
  *(_DWORD *)dword_83D7610 = a1;
  return result;
}
// 83D7610: using guessed type int dword_83D7610;

//----- (08084B64) --------------------------------------------------------
int __cdecl sub_8084B64(int a1)
{
  int result; // eax

  sub_80837B0();
  *(_DWORD *)(dword_83D7610 + 4) = 11;
  result = a1;
  *(_DWORD *)dword_83D7610 = a1;
  return result;
}
// 83D7610: using guessed type int dword_83D7610;

//----- (08084B88) --------------------------------------------------------
int Scr_AddUndefined()
{
  int result; // eax

  sub_80837B0();
  result = dword_83D7610;
  *(_DWORD *)(dword_83D7610 + 4) = 0;
  return result;
}
// 83D7610: using guessed type int dword_83D7610;

//----- (08084BA2) --------------------------------------------------------
int __cdecl Scr_AddObject(int a1)
{
  sub_80837B0();
  *(_DWORD *)(dword_83D7610 + 4) = 1;
  *(_DWORD *)dword_83D7610 = a1;
  return AddRefToObject(a1);
}
// 83D7610: using guessed type int dword_83D7610;

//----- (08084BD2) --------------------------------------------------------
int __cdecl Scr_AddEntityNum(int a1, int a2)
{
  int v2; // eax

  v2 = sub_807E3A6(a1, a2);
  return Scr_AddObject(v2);
}

//----- (08084BF4) --------------------------------------------------------
int sub_8084BF4()
{
  int v1; // [esp+4h] [ebp-4h]

  v1 = sub_807B5A0();
  Scr_AddObject(v1);
  return RemoveRefToObject(v1);
}

//----- (08084C1A) --------------------------------------------------------
int __cdecl Scr_AddString(char *s)
{
  _DWORD *v1; // ebx
  int result; // eax

  sub_80837B0();
  *(_DWORD *)(dword_83D7610 + 4) = 2;
  v1 = (_DWORD *)dword_83D7610;
  result = sub_80792C4(s, 0);
  *v1 = result;
  return result;
}
// 83D7610: using guessed type int dword_83D7610;

//----- (08084C54) --------------------------------------------------------
int __cdecl sub_8084C54(char *s)
{
  _DWORD *v1; // ebx
  int result; // eax

  sub_80837B0();
  *(_DWORD *)(dword_83D7610 + 4) = 3;
  v1 = (_DWORD *)dword_83D7610;
  result = sub_80792C4(s, 0);
  *v1 = result;
  return result;
}
// 83D7610: using guessed type int dword_83D7610;

//----- (08084C8E) --------------------------------------------------------
int __cdecl Scr_AddConstString(int a1)
{
  sub_80837B0();
  *(_DWORD *)(dword_83D7610 + 4) = 2;
  *(_DWORD *)dword_83D7610 = a1;
  return sub_807951E(a1);
}
// 83D7610: using guessed type int dword_83D7610;

//----- (08084CBE) --------------------------------------------------------
_DWORD *__cdecl Scr_AddVector(_DWORD *a1)
{
  _DWORD *v1; // ebx
  _DWORD *result; // eax

  sub_80837B0();
  *(_DWORD *)(dword_83D7610 + 4) = 4;
  v1 = (_DWORD *)dword_83D7610;
  result = sub_807B968(a1);
  *v1 = result;
  return result;
}
// 83D7610: using guessed type int dword_83D7610;

//----- (08084CF0) --------------------------------------------------------
int Scr_MakeArray()
{
  int *v0; // ebx
  int result; // eax

  sub_80837B0();
  *(_DWORD *)(dword_83D7610 + 4) = 1;
  v0 = (int *)dword_83D7610;
  result = sub_807B658();
  *v0 = result;
  return result;
}
// 83D7610: using guessed type int dword_83D7610;

//----- (08084D1C) --------------------------------------------------------
int Scr_AddArray()
{
  int v0; // eax
  int v2; // [esp+14h] [ebp-4h]

  dword_83D7610 -= 8;
  --dword_83D7618;
  v0 = sub_807C9AC(*(_DWORD *)dword_83D7610);
  v2 = sub_807C084(*(_DWORD *)dword_83D7610, v0);
  return sub_807C4C2(v2, (int *)(dword_83D7610 + 8));
}
// 83D7610: using guessed type int dword_83D7610;
// 83D7618: using guessed type int dword_83D7618;

//----- (08084D6E) --------------------------------------------------------
int __cdecl sub_8084D6E(unsigned int a1)
{
  int v2; // [esp+14h] [ebp-4h]

  dword_83D7610 -= 8;
  --dword_83D7618;
  v2 = sub_807C0CC(*(_DWORD *)dword_83D7610, a1);
  return sub_807C4C2(v2, (int *)(dword_83D7610 + 8));
}
// 83D7610: using guessed type int dword_83D7610;
// 83D7618: using guessed type int dword_83D7618;

//----- (08084DB4) --------------------------------------------------------
void __cdecl Scr_Error(int a1)
{
  if ( !*(_DWORD *)dword_8394010 )
    *(_DWORD *)dword_8394010 = a1;
  sub_807FA00();
}

//----- (08084DD2) --------------------------------------------------------
void __cdecl sub_8084DD2(int a1, int a2)
{
  *(_DWORD *)dword_8394010 = a1;
  dword_83D5590 = a2;
  sub_807FA00();
}
// 83D5590: using guessed type int dword_83D5590;

//----- (08084DF0) --------------------------------------------------------
void __cdecl sub_8084DF0(int a1)
{
  Scr_DumpScriptThreads();
  Scr_DumpScriptVariablesDefault();
  byte_83D7616 = 1;
  Scr_Error(a1);
}
// 83D7616: using guessed type char byte_83D7616;

//----- (08084E14) --------------------------------------------------------
void __cdecl Scr_ParamError(int a1, int a2)
{
  dword_8394014 = a1 + 1;
  Scr_Error(a2);
}
// 8394014: using guessed type int dword_8394014;

//----- (08084E30) --------------------------------------------------------
void __cdecl Scr_ObjectError(int a1)
{
  dword_8394014 = -1;
  Scr_Error(a1);
}
// 8394014: using guessed type int dword_8394014;

//----- (08084E4E) --------------------------------------------------------
int __cdecl sub_8084E4E(int a1, int a2, int a3, int a4)
{
  dword_83D761C = 1;
  dword_83D7610 = a4;
  if ( sub_81189D2(a1, a2, a3) )
  {
    if ( dword_83D761C )
    {
      RemoveRefToValue((_DWORD *)dword_83D7610);
      dword_83D7610 -= 8;
      dword_83D761C = 0;
    }
    return 1;
  }
  else
  {
    dword_83D761C = 0;
    return 0;
  }
}
// 83D7610: using guessed type int dword_83D7610;
// 83D761C: using guessed type int dword_83D761C;

//----- (08084ECA) --------------------------------------------------------
_DWORD *__userpurge sub_8084ECA@<eax>(_DWORD *a1, char *a2, int a3, int a4)
{
  int v4; // edx

  dword_83D7610 = (int)(&dword_83D5580 - 2);
  dword_83D5584 = 0;
  sub_8118BCC(a2, a3, a4);
  dword_83D7618 = 0;
  v4 = dword_83D5584;
  *a1 = dword_83D5580;
  a1[1] = v4;
  return a1;
}
// 83D5580: using guessed type int dword_83D5580;
// 83D5584: using guessed type int dword_83D5584;
// 83D7610: using guessed type int dword_83D7610;
// 83D7618: using guessed type int dword_83D7618;

//----- (08084F28) --------------------------------------------------------
int __cdecl sub_8084F28(int a1, int a2)
{
  int result; // eax
  int v3; // [esp+14h] [ebp-4h]

  v3 = sub_807BBCA(a1, a2);
  dword_83D7618 = 0;
  result = sub_807C628(v3, (int *)dword_83D7610);
  dword_83D7610 -= 8;
  return result;
}
// 83D7610: using guessed type int dword_83D7610;
// 83D7618: using guessed type int dword_83D7618;

//----- (08084F6A) --------------------------------------------------------
int __cdecl sub_8084F6A(int a1, int a2, int a3)
{
  int v4; // [esp+14h] [ebp-4h]

  v4 = sub_807E3A6(a1, a2);
  return sub_8084F28(v4, a3);
}

//----- (08084F9A) --------------------------------------------------------
int sub_8084F9A()
{
  int result; // eax

  sub_8084FD2();
  result = sub_807E04A();
  ++dword_8394018;
  dword_8394018 &= 0xFFFFFFu;
  return result;
}
// 8394018: using guessed type int dword_8394018;

//----- (08084FD2) --------------------------------------------------------
void sub_8084FD2()
{
  sub_8083C5C();
}

//----- (08084FE0) --------------------------------------------------------
int sub_8084FE0()
{
  int result; // eax

  result = Sys_MilliSeconds();
  dword_83D5598 = result;
  return result;
}
// 83D5598: using guessed type int dword_83D5598;

//----- (080850EE) --------------------------------------------------------
int __cdecl sub_80850EE(float a1)
{
  return (int)floor(a1 + 0.5);
}

//----- (08085124) --------------------------------------------------------
int __cdecl sub_8085124(_DWORD *a1, _DWORD *a2)
{
  int result; // eax

  *a2 = *a1;
  a2[1] = a1[1];
  result = a1[2];
  a2[2] = result;
  return result;
}

//----- (08085154) --------------------------------------------------------
int __cdecl sub_8085154(int a1)
{
  return *(_DWORD *)(dword_83D7600 - 4 * a1);
}
// 83D7600: using guessed type int dword_83D7600;

//----- (0808516A) --------------------------------------------------------
int __cdecl sub_808516A(unsigned __int8 *a1)
{
  return sub_8085154(*a1);
}

//----- (08085180) --------------------------------------------------------
int __cdecl sub_8085180(_DWORD **a1)
{
  return *(*a1)++;
}

//----- (080851A2) --------------------------------------------------------
int __cdecl sub_80851A2(int *a1)
{
  int v2; // [esp+0h] [ebp-4h]

  v2 = *a1;
  *a1 += 12;
  return v2;
}

//----- (080851C2) --------------------------------------------------------
int __cdecl sub_80851C2(int *a1, int a2)
{
  int v3; // [esp+0h] [ebp-4h]

  v3 = *a1;
  *a1 += 4 * a2;
  return v3;
}

//----- (080851E6) --------------------------------------------------------
int __cdecl sub_80851E6(_WORD **a1)
{
  return (unsigned __int16)sub_808524C(a1);
}

//----- (080851FC) --------------------------------------------------------
int __cdecl sub_80851FC(_DWORD **a1)
{
  return sub_8085180(a1);
}

//----- (08085210) --------------------------------------------------------
long double __cdecl sub_8085210(_DWORD **a1)
{
  return *(float *)(*a1)++;
}

//----- (08085238) --------------------------------------------------------
int __cdecl sub_8085238(_DWORD **a1)
{
  return sub_8085180(a1);
}

//----- (0808524C) --------------------------------------------------------
int __cdecl sub_808524C(_WORD **a1)
{
  return (__int16)*(*a1)++;
}

//----- (08085274) --------------------------------------------------------
int __cdecl sub_8085274(int a1)
{
  return sub_80793F4(a1, byte_83DB9C0);
}
// 83DB9C0: using guessed type char byte_83DB9C0;

//----- (080852B8) --------------------------------------------------------
int __cdecl sub_80852B8(char *s2, int a2)
{
  int result; // eax

  result = SL_GetStringOfLen(s2, 0, a2 + 1);
  dword_89BEB2C = result;
  return result;
}
// 89BEB2C: using guessed type int dword_89BEB2C;

//----- (080852E8) --------------------------------------------------------
int __cdecl sub_80852E8(const char *a1, int a2)
{
  char *v2; // eax
  int v4; // [esp+18h] [ebp-2020h]
  char s[8204]; // [esp+20h] [ebp-2018h] BYREF
  char *v7; // [esp+202Ch] [ebp-Ch]
  const char *v8; // [esp+2040h] [ebp+8h]
  int v9; // [esp+2044h] [ebp+Ch]

  if ( a2 <= 0x1FFF )
  {
    v7 = s;
    while ( 1 )
    {
      while ( 1 )
      {
        if ( !a2 )
        {
LABEL_19:
          *v7 = 0;
          dword_89BEB2C = SL_GetString(s, byte_83DB9C0);
          return 1;
        }
        if ( *a1 == 92 )
          break;
        --a2;
        v2 = (char *)a1++;
        *v7++ = *v2;
      }
      v9 = a2 - 1;
      if ( !v9 )
        goto LABEL_19;
      v8 = a1 + 1;
      v4 = *v8;
      if ( v4 == 114 )
      {
        *v7++ = 13;
        goto LABEL_18;
      }
      if ( v4 > 114 )
      {
        if ( v4 == 116 )
        {
          *v7++ = 9;
          goto LABEL_18;
        }
      }
      else if ( v4 == 110 )
      {
        *v7++ = 10;
        goto LABEL_18;
      }
      *v7++ = *v8;
LABEL_18:
      a2 = v9 - 1;
      a1 = v8 + 1;
    }
  }
  CompileError(dword_83DB9BC, "max string length exceeded: \"%s\"", a1);
  return 0;
}
// 83DB9C0: using guessed type char byte_83DB9C0;
// 89BEB2C: using guessed type int dword_89BEB2C;
// 80852E8: using guessed type const char *arg_0;

//----- (08085425) --------------------------------------------------------
int __cdecl sub_8085425(char *s)
{
  return sscanf(s, "%d", &dword_89BEB2C);
}
// 89BEB2C: using guessed type int dword_89BEB2C;

//----- (08085448) --------------------------------------------------------
int __cdecl sub_8085448(char *s)
{
  return sscanf(s, "%f", &dword_89BEB2C);
}
// 89BEB2C: using guessed type int dword_89BEB2C;

//----- (0808546B) --------------------------------------------------------
int sub_808546B()
{
  int v1; // [esp+1Ch] [ebp-2Ch]
  unsigned __int8 v4; // [esp+2Bh] [ebp-1Dh]
  int v5; // [esp+2Ch] [ebp-1Ch]
  char *v6; // [esp+30h] [ebp-18h]
  char *v7; // [esp+34h] [ebp-14h]
  int v8; // [esp+38h] [ebp-10h]
  int v10; // [esp+40h] [ebp-8h]
  int v11; // [esp+44h] [ebp-4h]

  if ( dword_815D548 )
  {
    dword_815D548 = 0;
    if ( !dword_83DB9A8 )
      dword_83DB9A8 = 1;
    if ( !stream )
      stream = (FILE *)stdin;
    if ( !dword_83DB9B0 )
      dword_83DB9B0 = stdout;
    if ( !dword_83DB9A0 )
      dword_83DB9A0 = (int)sub_8086E67(stream, 0x4000);
    sub_8086E2A();
  }
LABEL_11:
  v7 = (char *)dword_83DB9A4;
  *(_BYTE *)dword_83DB9A4 = byte_83DB9C8;
  v6 = v7;
  v8 = dword_83DB9A8;
  do
  {
LABEL_12:
    v4 = byte_81412A0[4 * (unsigned __int8)*v7];
    if ( word_81410A0[v8] )
    {
      dword_83DB9D4 = v8;
      dword_83DB9D8 = (int)v7;
    }
    while ( word_8141FC0[v4 + word_81417A0[v8]] != v8 )
    {
      v8 = word_81419C0[v8];
      if ( v8 > 255 )
        v4 = byte_81416A0[4 * v4];
    }
    v8 = word_8141BE0[v4 + word_81417A0[v8]];
    ++v7;
  }
  while ( word_81417A0[v8] != 431 );
  while ( 1 )
  {
    v5 = word_81410A0[v8];
    if ( !word_81410A0[v8] )
    {
      v7 = (char *)dword_83DB9D8;
      v5 = word_81410A0[dword_83DB9D4];
    }
    ptr = v6;
    size = v7 - v6;
    byte_83DB9C8 = *v7;
    *v7 = 0;
    dword_83DB9A4 = (int)v7;
LABEL_21:
    switch ( v5 )
    {
      case 0:
        *v7 = byte_83DB9C8;
        v7 = (char *)dword_83DB9D8;
        v8 = dword_83DB9D4;
        continue;
      case 1:
        dword_89BEB30 = dword_83DB9B8;
        dword_83DB9BC = dword_83DB9B8;
        dword_83DB9B8 += size;
        goto LABEL_11;
      case 2:
        dword_89BEB30 = dword_83DB9B8;
        dword_83DB9BC = dword_83DB9B8;
        dword_83DB9B8 += size;
        dword_83DB9A8 = 3;
        goto LABEL_11;
      case 3:
        dword_89BEB30 = dword_83DB9B8;
        dword_83DB9BC = dword_83DB9B8;
        dword_83DB9B8 += size;
        goto LABEL_11;
      case 4:
        dword_89BEB30 = dword_83DB9B8;
        dword_83DB9BC = dword_83DB9B8;
        dword_83DB9B8 += size;
        goto LABEL_11;
      case 5:
        dword_89BEB30 = dword_83DB9B8;
        dword_83DB9BC = dword_83DB9B8;
        dword_83DB9B8 += size;
        goto LABEL_11;
      case 6:
        dword_89BEB30 = dword_83DB9B8;
        dword_83DB9BC = dword_83DB9B8;
        dword_83DB9B8 += size;
        dword_83DB9A8 = 5;
        goto LABEL_11;
      case 7:
        dword_89BEB30 = dword_83DB9B8;
        dword_83DB9BC = dword_83DB9B8;
        dword_83DB9B8 += size;
        if ( sub_80852E8(ptr + 1, size - 2) )
          return 259;
        else
          return 257;
      case 8:
        dword_89BEB30 = dword_83DB9B8;
        dword_83DB9BC = dword_83DB9B8;
        dword_83DB9B8 += size;
        if ( sub_80852E8(ptr + 2, size - 3) )
          return 260;
        else
          return 257;
      case 9:
        dword_89BEB30 = dword_83DB9B8;
        dword_83DB9BC = dword_83DB9B8;
        dword_83DB9B8 += size;
        return 261;
      case 10:
        dword_89BEB30 = dword_83DB9B8;
        dword_83DB9BC = dword_83DB9B8;
        dword_83DB9B8 += size;
        return 262;
      case 11:
        dword_89BEB30 = dword_83DB9B8;
        dword_83DB9BC = dword_83DB9B8;
        dword_83DB9B8 += size;
        return 263;
      case 12:
        dword_89BEB30 = dword_83DB9B8;
        dword_83DB9BC = dword_83DB9B8;
        dword_83DB9B8 += size;
        return 264;
      case 13:
        dword_89BEB30 = dword_83DB9B8;
        dword_83DB9BC = dword_83DB9B8;
        dword_83DB9B8 += size;
        return 265;
      case 14:
        dword_89BEB30 = dword_83DB9B8;
        dword_83DB9BC = dword_83DB9B8;
        dword_83DB9B8 += size;
        return 266;
      case 15:
        dword_89BEB30 = dword_83DB9B8;
        dword_83DB9BC = dword_83DB9B8;
        dword_83DB9B8 += size;
        return 267;
      case 16:
        dword_89BEB30 = dword_83DB9B8;
        dword_83DB9BC = dword_83DB9B8;
        dword_83DB9B8 += size;
        return 268;
      case 17:
        dword_89BEB30 = dword_83DB9B8;
        dword_83DB9BC = dword_83DB9B8;
        dword_83DB9B8 += size;
        return 269;
      case 18:
        dword_89BEB30 = dword_83DB9B8;
        dword_83DB9BC = dword_83DB9B8;
        dword_83DB9B8 += size;
        return 270;
      case 19:
        dword_89BEB30 = dword_83DB9B8;
        dword_83DB9BC = dword_83DB9B8;
        dword_83DB9B8 += size;
        return 271;
      case 20:
        dword_89BEB30 = dword_83DB9B8;
        dword_83DB9BC = dword_83DB9B8;
        dword_83DB9B8 += size;
        return 272;
      case 21:
        dword_89BEB30 = dword_83DB9B8;
        dword_83DB9BC = dword_83DB9B8;
        dword_83DB9B8 += size;
        return 273;
      case 22:
        dword_89BEB30 = dword_83DB9B8;
        dword_83DB9BC = dword_83DB9B8;
        dword_83DB9B8 += size;
        return 274;
      case 23:
        dword_89BEB30 = dword_83DB9B8;
        dword_83DB9BC = dword_83DB9B8;
        dword_83DB9B8 += size;
        return 275;
      case 24:
        dword_89BEB30 = dword_83DB9B8;
        dword_83DB9BC = dword_83DB9B8;
        dword_83DB9B8 += size;
        return 276;
      case 25:
        dword_89BEB30 = dword_83DB9B8;
        dword_83DB9BC = dword_83DB9B8;
        dword_83DB9B8 += size;
        return 277;
      case 26:
        dword_89BEB30 = dword_83DB9B8;
        dword_83DB9BC = dword_83DB9B8;
        dword_83DB9B8 += size;
        return 278;
      case 27:
        dword_89BEB30 = dword_83DB9B8;
        dword_83DB9BC = dword_83DB9B8;
        dword_83DB9B8 += size;
        return 279;
      case 28:
        dword_89BEB30 = dword_83DB9B8;
        dword_83DB9BC = dword_83DB9B8;
        dword_83DB9B8 += size;
        return 280;
      case 29:
        dword_89BEB30 = dword_83DB9B8;
        dword_83DB9BC = dword_83DB9B8;
        dword_83DB9B8 += size;
        return 281;
      case 30:
        dword_89BEB30 = dword_83DB9B8;
        dword_83DB9BC = dword_83DB9B8;
        dword_83DB9B8 += size;
        return 282;
      case 31:
        dword_89BEB30 = dword_83DB9B8;
        dword_83DB9BC = dword_83DB9B8;
        dword_83DB9B8 += size;
        return 283;
      case 32:
        dword_89BEB30 = dword_83DB9B8;
        dword_83DB9BC = dword_83DB9B8;
        dword_83DB9B8 += size;
        return 284;
      case 33:
        dword_89BEB30 = dword_83DB9B8;
        dword_83DB9BC = dword_83DB9B8;
        dword_83DB9B8 += size;
        return 285;
      case 34:
        dword_89BEB30 = dword_83DB9B8;
        dword_83DB9BC = dword_83DB9B8;
        dword_83DB9B8 += size;
        return 286;
      case 35:
        dword_89BEB30 = dword_83DB9B8;
        dword_83DB9BC = dword_83DB9B8;
        dword_83DB9B8 += size;
        sub_8085425(ptr);
        return 287;
      case 36:
        dword_89BEB30 = dword_83DB9B8;
        dword_83DB9BC = dword_83DB9B8;
        dword_83DB9B8 += size;
        sub_8085448(ptr);
        return 288;
      case 37:
        dword_89BEB30 = dword_83DB9B8;
        dword_83DB9BC = dword_83DB9B8;
        dword_83DB9B8 += size;
        return 290;
      case 38:
        dword_89BEB30 = dword_83DB9B8;
        dword_83DB9BC = dword_83DB9B8;
        dword_83DB9B8 += size;
        return 289;
      case 39:
        dword_89BEB30 = dword_83DB9B8;
        dword_83DB9BC = dword_83DB9B8;
        dword_83DB9B8 += size;
        return 294;
      case 40:
        dword_89BEB30 = dword_83DB9B8;
        dword_83DB9BC = dword_83DB9B8;
        dword_83DB9B8 += size;
        return 291;
      case 41:
        dword_89BEB30 = dword_83DB9B8;
        dword_83DB9BC = dword_83DB9B8;
        dword_83DB9B8 += size;
        return 293;
      case 42:
        dword_89BEB30 = dword_83DB9B8;
        dword_83DB9BC = dword_83DB9B8;
        dword_83DB9B8 += size;
        return 292;
      case 43:
        dword_89BEB30 = dword_83DB9B8;
        dword_83DB9BC = dword_83DB9B8;
        dword_83DB9B8 += size;
        return 295;
      case 44:
        dword_89BEB30 = dword_83DB9B8;
        dword_83DB9BC = dword_83DB9B8;
        dword_83DB9B8 += size;
        return 296;
      case 45:
        dword_89BEB30 = dword_83DB9B8;
        dword_83DB9BC = dword_83DB9B8;
        dword_83DB9B8 += size;
        return 297;
      case 46:
        dword_89BEB30 = dword_83DB9B8;
        dword_83DB9BC = dword_83DB9B8;
        dword_83DB9B8 += size;
        return 298;
      case 47:
        dword_89BEB30 = dword_83DB9B8;
        dword_83DB9BC = dword_83DB9B8;
        dword_83DB9B8 += size;
        return 299;
      case 48:
        dword_89BEB30 = dword_83DB9B8;
        dword_83DB9BC = dword_83DB9B8;
        dword_83DB9B8 += size;
        return 300;
      case 49:
        dword_89BEB30 = dword_83DB9B8;
        dword_83DB9BC = dword_83DB9B8;
        dword_83DB9B8 += size;
        return 301;
      case 50:
        dword_89BEB30 = dword_83DB9B8;
        dword_83DB9BC = dword_83DB9B8;
        dword_83DB9B8 += size;
        return 302;
      case 51:
        dword_89BEB30 = dword_83DB9B8;
        dword_83DB9BC = dword_83DB9B8;
        dword_83DB9B8 += size;
        return 303;
      case 52:
        dword_89BEB30 = dword_83DB9B8;
        dword_83DB9BC = dword_83DB9B8;
        dword_83DB9B8 += size;
        return 304;
      case 53:
        dword_89BEB30 = dword_83DB9B8;
        dword_83DB9BC = dword_83DB9B8;
        dword_83DB9B8 += size;
        return 305;
      case 54:
        dword_89BEB30 = dword_83DB9B8;
        dword_83DB9BC = dword_83DB9B8;
        dword_83DB9B8 += size;
        return 306;
      case 55:
        dword_89BEB30 = dword_83DB9B8;
        dword_83DB9BC = dword_83DB9B8;
        dword_83DB9B8 += size;
        return 307;
      case 56:
        dword_89BEB30 = dword_83DB9B8;
        dword_83DB9BC = dword_83DB9B8;
        dword_83DB9B8 += size;
        return 308;
      case 57:
        dword_89BEB30 = dword_83DB9B8;
        dword_83DB9BC = dword_83DB9B8;
        dword_83DB9B8 += size;
        return 309;
      case 58:
        dword_89BEB30 = dword_83DB9B8;
        dword_83DB9BC = dword_83DB9B8;
        dword_83DB9B8 += size;
        return 310;
      case 59:
        dword_89BEB30 = dword_83DB9B8;
        dword_83DB9BC = dword_83DB9B8;
        dword_83DB9B8 += size;
        return 311;
      case 60:
        dword_89BEB30 = dword_83DB9B8;
        dword_83DB9BC = dword_83DB9B8;
        dword_83DB9B8 += size;
        return 312;
      case 61:
        dword_89BEB30 = dword_83DB9B8;
        dword_83DB9BC = dword_83DB9B8;
        dword_83DB9B8 += size;
        return 313;
      case 62:
        dword_89BEB30 = dword_83DB9B8;
        dword_83DB9BC = dword_83DB9B8;
        dword_83DB9B8 += size;
        return 314;
      case 63:
        dword_89BEB30 = dword_83DB9B8;
        dword_83DB9BC = dword_83DB9B8;
        dword_83DB9B8 += size;
        return 315;
      case 64:
        dword_89BEB30 = dword_83DB9B8;
        dword_83DB9BC = dword_83DB9B8;
        dword_83DB9B8 += size;
        return 316;
      case 65:
        dword_89BEB30 = dword_83DB9B8;
        dword_83DB9BC = dword_83DB9B8;
        dword_83DB9B8 += size;
        return 317;
      case 66:
        dword_89BEB30 = dword_83DB9B8;
        dword_83DB9BC = dword_83DB9B8;
        dword_83DB9B8 += size;
        return 318;
      case 67:
        dword_89BEB30 = dword_83DB9B8;
        dword_83DB9BC = dword_83DB9B8;
        dword_83DB9B8 += size;
        return 319;
      case 68:
        dword_89BEB30 = dword_83DB9B8;
        dword_83DB9BC = dword_83DB9B8;
        dword_83DB9B8 += size;
        return 320;
      case 69:
        dword_89BEB30 = dword_83DB9B8;
        dword_83DB9BC = dword_83DB9B8;
        dword_83DB9B8 += size;
        return 321;
      case 70:
        dword_89BEB30 = dword_83DB9B8;
        dword_83DB9BC = dword_83DB9B8;
        dword_83DB9B8 += size;
        return 322;
      case 71:
        dword_89BEB30 = dword_83DB9B8;
        dword_83DB9BC = dword_83DB9B8;
        dword_83DB9B8 += size;
        return 323;
      case 72:
        dword_89BEB30 = dword_83DB9B8;
        dword_83DB9BC = dword_83DB9B8;
        dword_83DB9B8 += size;
        return 325;
      case 73:
        dword_89BEB30 = dword_83DB9B8;
        dword_83DB9BC = dword_83DB9B8;
        dword_83DB9B8 += size;
        return 326;
      case 74:
        dword_89BEB30 = dword_83DB9B8;
        dword_83DB9BC = dword_83DB9B8;
        dword_83DB9B8 += size;
        return 327;
      case 75:
        dword_89BEB30 = dword_83DB9B8;
        dword_83DB9BC = dword_83DB9B8;
        dword_83DB9B8 += size;
        return 328;
      case 76:
        dword_89BEB30 = dword_83DB9B8;
        dword_83DB9BC = dword_83DB9B8;
        dword_83DB9B8 += size;
        return 329;
      case 77:
        dword_89BEB30 = dword_83DB9B8;
        dword_83DB9BC = dword_83DB9B8;
        dword_83DB9B8 += size;
        return 330;
      case 78:
        dword_89BEB30 = dword_83DB9B8;
        dword_83DB9BC = dword_83DB9B8;
        dword_83DB9B8 += size;
        return 331;
      case 79:
        dword_89BEB30 = dword_83DB9B8;
        dword_83DB9BC = dword_83DB9B8;
        dword_83DB9B8 += size;
        return 332;
      case 80:
        dword_89BEB30 = dword_83DB9B8;
        dword_83DB9BC = dword_83DB9B8;
        dword_83DB9B8 += size;
        return 333;
      case 81:
        dword_89BEB30 = dword_83DB9B8;
        dword_83DB9BC = dword_83DB9B8;
        dword_83DB9B8 += size;
        return 334;
      case 82:
        dword_89BEB30 = dword_83DB9B8;
        dword_83DB9BC = dword_83DB9B8;
        dword_83DB9B8 += size;
        return 335;
      case 83:
        dword_89BEB30 = dword_83DB9B8;
        dword_83DB9BC = dword_83DB9B8;
        dword_83DB9B8 += size;
        return 336;
      case 84:
        dword_89BEB30 = dword_83DB9B8;
        dword_83DB9BC = dword_83DB9B8;
        dword_83DB9B8 += size;
        return 337;
      case 85:
        dword_89BEB30 = dword_83DB9B8;
        dword_83DB9BC = dword_83DB9B8;
        dword_83DB9B8 += size;
        return 338;
      case 86:
        dword_89BEB30 = dword_83DB9B8;
        dword_83DB9BC = dword_83DB9B8;
        dword_83DB9B8 += size;
        return 339;
      case 87:
        dword_89BEB30 = dword_83DB9B8;
        dword_83DB9BC = dword_83DB9B8;
        dword_83DB9B8 += size;
        return 340;
      case 88:
        dword_89BEB30 = dword_83DB9B8;
        dword_83DB9BC = dword_83DB9B8;
        dword_83DB9B8 += size;
        return 341;
      case 89:
        dword_89BEB30 = dword_83DB9B8;
        dword_83DB9BC = dword_83DB9B8;
        dword_83DB9B8 += size;
        return 342;
      case 90:
        dword_89BEB30 = dword_83DB9B8;
        dword_83DB9BC = dword_83DB9B8;
        dword_83DB9B8 += size;
        sub_80852B8(ptr, size);
        return 258;
      case 91:
        dword_89BEB30 = dword_83DB9B8;
        dword_83DB9BC = dword_83DB9B8;
        dword_83DB9B8 += size;
        sub_80852B8(ptr, size);
        return 324;
      case 92:
        dword_89BEB30 = dword_83DB9B8;
        dword_83DB9BC = dword_83DB9B8;
        dword_83DB9B8 += size;
        CompileError(dword_83DB9BC, "bad token '%s'", ptr);
        return 257;
      case 93:
        dword_89BEB30 = dword_83DB9B8;
        dword_83DB9BC = dword_83DB9B8;
        dword_83DB9B8 += size;
        fwrite(ptr, size, 1u, dword_83DB9B0);
        goto LABEL_11;
      case 94:
        v11 = v7 - ptr - 1;
        *v7 = byte_83DB9C8;
        if ( !*(_DWORD *)(dword_83DB9A0 + 36) )
        {
          dword_83DB9CC = *(_DWORD *)(dword_83DB9A0 + 16);
          *(_DWORD *)dword_83DB9A0 = stream;
          *(_DWORD *)(dword_83DB9A0 + 36) = 1;
        }
        if ( dword_83DB9A4 <= (unsigned int)(dword_83DB9CC + *(_DWORD *)(dword_83DB9A0 + 4)) )
        {
          dword_83DB9A4 = (int)&ptr[v11];
          v8 = sub_8086AF2();
          v10 = sub_8086BCA(v8);
          v6 = ptr;
          if ( v10 )
          {
            v7 = (char *)++dword_83DB9A4;
            v8 = v10;
            goto LABEL_12;
          }
          v7 = (char *)dword_83DB9A4;
          continue;
        }
        v1 = sub_8086881();
        if ( v1 == 1 )
        {
          dword_83DB9D0 = 0;
          if ( sub_80872FC() )
          {
            dword_83DB9A4 = (int)ptr;
            v5 = (dword_83DB9A8 - 1) / 2 + 95;
            goto LABEL_21;
          }
          if ( !dword_83DB9D0 )
            sub_8086D87(stream);
          goto LABEL_11;
        }
        if ( v1 <= 1 )
        {
          if ( v1 )
            goto LABEL_11;
          dword_83DB9A4 = (int)&ptr[v11];
          v8 = sub_8086AF2();
          v7 = (char *)dword_83DB9A4;
          v6 = ptr;
          goto LABEL_12;
        }
        if ( v1 != 2 )
          goto LABEL_11;
        dword_83DB9A4 = dword_83DB9CC + *(_DWORD *)(dword_83DB9A0 + 4);
        v8 = sub_8086AF2();
        v7 = (char *)dword_83DB9A4;
        v6 = ptr;
        break;
      case 95:
      case 96:
      case 97:
        return 0;
      default:
        sub_8087193("fatal flex scanner internal error--no action found");
    }
  }
}
// 81410A0: using guessed type __int16 word_81410A0[256];
// 81417A0: using guessed type __int16 word_81417A0[272];
// 81419C0: using guessed type __int16 word_81419C0[272];
// 8141BE0: using guessed type __int16 word_8141BE0[496];
// 8141FC0: using guessed type __int16 word_8141FC0[496];
// 815D548: using guessed type int dword_815D548;
// 8185A68: using guessed type int stdin;
// 83DB9A4: using guessed type int dword_83DB9A4;
// 83DB9A8: using guessed type int dword_83DB9A8;
// 83DB9B8: using guessed type int dword_83DB9B8;
// 83DB9C8: using guessed type char byte_83DB9C8;
// 83DB9CC: using guessed type int dword_83DB9CC;
// 83DB9D0: using guessed type int dword_83DB9D0;
// 83DB9D4: using guessed type int dword_83DB9D4;
// 83DB9D8: using guessed type int dword_83DB9D8;
// 89BEB30: using guessed type int dword_89BEB30;

//----- (08086881) --------------------------------------------------------
int sub_8086881()
{
  char v0; // dl
  int v1; // eax
  int i; // [esp+Ch] [ebp-2Ch]
  int v4; // [esp+10h] [ebp-28h]
  char *v5; // [esp+14h] [ebp-24h]
  _BYTE *v6; // [esp+18h] [ebp-20h]
  int v8; // [esp+24h] [ebp-14h]
  int v9; // [esp+28h] [ebp-10h]
  int j; // [esp+2Ch] [ebp-Ch]
  int v11; // [esp+30h] [ebp-8h]

  v6 = *(_BYTE **)(dword_83DB9A0 + 4);
  v5 = ptr;
  if ( dword_83DB9A4 > (unsigned int)&v6[dword_83DB9CC + 1] )
    sub_8087193("fatal flex scanner internal error--end of buffer missed");
  if ( *(_DWORD *)(dword_83DB9A0 + 32) )
  {
    v4 = dword_83DB9A4 - (_DWORD)ptr - 1;
    for ( i = 0; i < v4; ++i )
    {
      v0 = *v5++;
      *v6++ = v0;
    }
    if ( *(_DWORD *)(dword_83DB9A0 + 36) == 2 )
    {
      dword_83DB9CC = 0;
      *(_DWORD *)(dword_83DB9A0 + 16) = 0;
    }
    else
    {
      for ( j = *(_DWORD *)(dword_83DB9A0 + 12) - v4 - 1; j <= 0; j = *(_DWORD *)(dword_83DB9A0 + 12) - v4 - 1 )
      {
        v9 = dword_83DB9A0;
        v8 = dword_83DB9A4 - *(_DWORD *)(dword_83DB9A0 + 4);
        if ( *(_DWORD *)(dword_83DB9A0 + 20) )
        {
          if ( 2 * *(_DWORD *)(dword_83DB9A0 + 12) > 0 )
            v1 = 2 * *(_DWORD *)(dword_83DB9A0 + 12);
          else
            v1 = *(_DWORD *)(dword_83DB9A0 + 12) + (*(_DWORD *)(dword_83DB9A0 + 12) >> 3);
          *(_DWORD *)(dword_83DB9A0 + 12) = v1;
          *(_DWORD *)(v9 + 4) = sub_80871D4(*(void **)(v9 + 4), *(_DWORD *)(v9 + 12) + 2);
        }
        else
        {
          *(_DWORD *)(dword_83DB9A0 + 4) = 0;
        }
        if ( !*(_DWORD *)(v9 + 4) )
          sub_8087193("fatal error - scanner input buffer overflow");
        dword_83DB9A4 = *(_DWORD *)(v9 + 4) + v8;
      }
      if ( j > 0x2000 )
        j = 0x2000;
      dword_83DB9CC = sub_8075BBE(*(_DWORD *)(dword_83DB9A0 + 4) + v4, j);
      *(_DWORD *)(dword_83DB9A0 + 16) = dword_83DB9CC;
    }
    if ( dword_83DB9CC )
    {
      v11 = 0;
    }
    else if ( v4 )
    {
      v11 = 2;
      *(_DWORD *)(dword_83DB9A0 + 36) = 2;
    }
    else
    {
      v11 = 1;
      sub_8086D87(stream);
    }
    dword_83DB9CC += v4;
    *(_BYTE *)(*(_DWORD *)(dword_83DB9A0 + 4) + dword_83DB9CC) = 0;
    *(_BYTE *)(*(_DWORD *)(dword_83DB9A0 + 4) + dword_83DB9CC + 1) = 0;
    ptr = *(char **)(dword_83DB9A0 + 4);
    return v11;
  }
  else if ( dword_83DB9A4 - (_DWORD)ptr == 1 )
  {
    return 1;
  }
  else
  {
    return 2;
  }
}
// 83DB9A4: using guessed type int dword_83DB9A4;
// 83DB9CC: using guessed type int dword_83DB9CC;

//----- (08086AF2) --------------------------------------------------------
int sub_8086AF2()
{
  unsigned __int8 v1; // [esp+3h] [ebp-9h]
  char *i; // [esp+4h] [ebp-8h]
  int v3; // [esp+8h] [ebp-4h]

  v3 = dword_83DB9A8;
  for ( i = ptr; (unsigned int)i < dword_83DB9A4; ++i )
  {
    if ( *i )
      v1 = byte_81412A0[4 * (unsigned __int8)*i];
    else
      v1 = 1;
    if ( word_81410A0[v3] )
    {
      dword_83DB9D4 = v3;
      dword_83DB9D8 = (int)i;
    }
    while ( word_8141FC0[v1 + word_81417A0[v3]] != v3 )
    {
      v3 = word_81419C0[v3];
      if ( v3 > 255 )
        v1 = byte_81416A0[4 * v1];
    }
    v3 = word_8141BE0[v1 + word_81417A0[v3]];
  }
  return v3;
}
// 81410A0: using guessed type __int16 word_81410A0[256];
// 81417A0: using guessed type __int16 word_81417A0[272];
// 81419C0: using guessed type __int16 word_81419C0[272];
// 8141BE0: using guessed type __int16 word_8141BE0[496];
// 8141FC0: using guessed type __int16 word_8141FC0[496];
// 83DB9A4: using guessed type int dword_83DB9A4;
// 83DB9A8: using guessed type int dword_83DB9A8;
// 83DB9D4: using guessed type int dword_83DB9D4;
// 83DB9D8: using guessed type int dword_83DB9D8;

//----- (08086BCA) --------------------------------------------------------
int __cdecl sub_8086BCA(int a1)
{
  unsigned __int8 v3; // [esp+7h] [ebp-5h]
  int v4; // [esp+14h] [ebp+8h]

  v3 = 1;
  if ( word_81410A0[a1] )
  {
    dword_83DB9D4 = a1;
    dword_83DB9D8 = dword_83DB9A4;
  }
  while ( word_8141FC0[v3 + word_81417A0[a1]] != a1 )
  {
    a1 = word_81419C0[a1];
    if ( a1 > 255 )
      v3 = byte_81416A0[4 * v3];
  }
  v4 = word_8141BE0[v3 + word_81417A0[a1]];
  if ( v4 == 255 )
    return 0;
  else
    return v4;
}
// 81410A0: using guessed type __int16 word_81410A0[256];
// 81417A0: using guessed type __int16 word_81417A0[272];
// 81419C0: using guessed type __int16 word_81419C0[272];
// 8141BE0: using guessed type __int16 word_8141BE0[496];
// 8141FC0: using guessed type __int16 word_8141FC0[496];
// 83DB9A4: using guessed type int dword_83DB9A4;
// 83DB9D4: using guessed type int dword_83DB9D4;
// 83DB9D8: using guessed type int dword_83DB9D8;

//----- (08086C86) --------------------------------------------------------
int sub_8086C86()
{
  int v1; // [esp+8h] [ebp-10h]
  int v3; // [esp+10h] [ebp-8h]
  int v4; // [esp+14h] [ebp-4h]

  *(_BYTE *)dword_83DB9A4 = byte_83DB9C8;
  if ( *(_BYTE *)dword_83DB9A4 )
    goto LABEL_16;
  if ( dword_83DB9A4 < (unsigned int)(dword_83DB9CC + *(_DWORD *)(dword_83DB9A0 + 4)) )
  {
    *(_BYTE *)dword_83DB9A4 = 0;
    goto LABEL_16;
  }
  v3 = dword_83DB9A4 - (_DWORD)ptr;
  ++dword_83DB9A4;
  v1 = sub_8086881();
  if ( v1 != 1 )
  {
    if ( v1 <= 1 )
    {
      if ( !v1 )
        dword_83DB9A4 = (int)&ptr[v3];
      goto LABEL_16;
    }
    if ( v1 != 2 )
    {
LABEL_16:
      v4 = *(unsigned __int8 *)dword_83DB9A4;
      *(_BYTE *)dword_83DB9A4++ = 0;
      byte_83DB9C8 = *(_BYTE *)dword_83DB9A4;
      return v4;
    }
    sub_8086D87(stream);
  }
  if ( sub_80872FC() )
    return -1;
  if ( !dword_83DB9D0 )
    sub_8086D87(stream);
  return sub_8086C86();
}
// 83DB9A4: using guessed type int dword_83DB9A4;
// 83DB9C8: using guessed type char byte_83DB9C8;
// 83DB9CC: using guessed type int dword_83DB9CC;
// 83DB9D0: using guessed type int dword_83DB9D0;

//----- (08086D87) --------------------------------------------------------
int __cdecl sub_8086D87(FILE *stream)
{
  if ( !dword_83DB9A0 )
    dword_83DB9A0 = (int)sub_8086E67(::stream, 0x4000);
  sub_8086F30((_DWORD *)dword_83DB9A0, stream);
  return sub_8086E2A();
}

//----- (08086DCB) --------------------------------------------------------
int __cdecl sub_8086DCB(int a1)
{
  int result; // eax

  result = dword_83DB9A0;
  if ( dword_83DB9A0 != a1 )
  {
    if ( dword_83DB9A0 )
    {
      *(_BYTE *)dword_83DB9A4 = byte_83DB9C8;
      *(_DWORD *)(dword_83DB9A0 + 8) = dword_83DB9A4;
      *(_DWORD *)(dword_83DB9A0 + 16) = dword_83DB9CC;
    }
    dword_83DB9A0 = a1;
    result = sub_8086E2A();
    dword_83DB9D0 = 1;
  }
  return result;
}
// 83DB9A4: using guessed type int dword_83DB9A4;
// 83DB9C8: using guessed type char byte_83DB9C8;
// 83DB9CC: using guessed type int dword_83DB9CC;
// 83DB9D0: using guessed type int dword_83DB9D0;

//----- (08086E2A) --------------------------------------------------------
int sub_8086E2A()
{
  int result; // eax

  dword_83DB9CC = *(_DWORD *)(dword_83DB9A0 + 16);
  dword_83DB9A4 = *(_DWORD *)(dword_83DB9A0 + 8);
  ptr = (char *)dword_83DB9A4;
  stream = *(FILE **)dword_83DB9A0;
  result = *(unsigned __int8 *)dword_83DB9A4;
  byte_83DB9C8 = *(_BYTE *)dword_83DB9A4;
  return result;
}
// 83DB9A4: using guessed type int dword_83DB9A4;
// 83DB9C8: using guessed type char byte_83DB9C8;
// 83DB9CC: using guessed type int dword_83DB9CC;

//----- (08086E67) --------------------------------------------------------
_DWORD *__cdecl sub_8086E67(FILE *stream, int a2)
{
  _DWORD *v3; // [esp+10h] [ebp-8h]

  v3 = sub_80871C1(0x28u);
  if ( !v3 )
    sub_8087193("out of dynamic memory in yy_create_buffer()");
  v3[3] = a2;
  v3[1] = sub_80871C1(v3[3] + 2);
  if ( !v3[1] )
    sub_8087193("out of dynamic memory in yy_create_buffer()");
  v3[5] = 1;
  sub_8086F30(v3, stream);
  return v3;
}

//----- (08086F30) --------------------------------------------------------
int __cdecl sub_8086F30(_DWORD *a1, FILE *stream)
{
  int v2; // eax
  int result; // eax
  int v4; // [esp+10h] [ebp-8h]

  sub_8086F8F((int)a1);
  *a1 = stream;
  a1[8] = 1;
  v4 = 0;
  if ( stream )
  {
    v2 = fileno(stream);
    if ( isatty(v2) > 0 )
      v4 = 1;
  }
  result = v4;
  a1[6] = v4;
  return result;
}

//----- (08086F8F) --------------------------------------------------------
int __cdecl sub_8086F8F(int a1)
{
  int result; // eax

  if ( a1 )
  {
    *(_DWORD *)(a1 + 16) = 0;
    **(_BYTE **)(a1 + 4) = 0;
    *(_BYTE *)(*(_DWORD *)(a1 + 4) + 1) = 0;
    *(_DWORD *)(a1 + 8) = *(_DWORD *)(a1 + 4);
    *(_DWORD *)(a1 + 28) = 1;
    *(_DWORD *)(a1 + 36) = 0;
    result = a1;
    if ( a1 == dword_83DB9A0 )
      return sub_8086E2A();
  }
  return result;
}

//----- (08086FEC) --------------------------------------------------------
_DWORD *__cdecl sub_8086FEC(int a1, unsigned int a2)
{
  _DWORD *v4; // [esp+14h] [ebp-4h]

  if ( a2 <= 1 || *(_BYTE *)(a1 + a2 - 2) || *(_BYTE *)(a1 + a2 - 1) )
    return 0;
  v4 = sub_80871C1(0x28u);
  if ( !v4 )
    sub_8087193("out of dynamic memory in yy_scan_buffer()");
  v4[3] = a2 - 2;
  v4[1] = a1;
  v4[2] = a1;
  v4[5] = 0;
  *v4 = 0;
  v4[4] = v4[3];
  v4[6] = 0;
  v4[7] = 1;
  v4[8] = 0;
  v4[9] = 0;
  sub_8086DCB((int)v4);
  return v4;
}

//----- (080870EE) --------------------------------------------------------
_DWORD *__cdecl sub_80870EE(int a1, int a2)
{
  int i; // [esp+8h] [ebp-10h]
  _BYTE *v4; // [esp+10h] [ebp-8h]
  _DWORD *v5; // [esp+14h] [ebp-4h]

  v4 = sub_80871C1(a2 + 2);
  if ( !v4 )
    sub_8087193("out of dynamic memory in yy_scan_bytes()");
  for ( i = 0; i < a2; ++i )
    v4[i] = *(_BYTE *)(a1 + i);
  v4[a2 + 1] = 0;
  v4[a2] = 0;
  v5 = sub_8086FEC((int)v4, a2 + 2);
  if ( !v5 )
    sub_8087193("bad buffer in yy_scan_bytes()");
  v5[5] = 1;
  return v5;
}

//----- (08087193) --------------------------------------------------------
void __cdecl __noreturn sub_8087193(const char *a1)
{
  fprintf(stderr, "%s\n", a1);
  exit(2);
}

//----- (080871C1) --------------------------------------------------------
void *__cdecl sub_80871C1(size_t size)
{
  return malloc(size);
}

//----- (080871D4) --------------------------------------------------------
void *__cdecl sub_80871D4(void *ptr, size_t size)
{
  return realloc(ptr, size);
}

//----- (080871EE) --------------------------------------------------------
void __cdecl sub_80871EE(void *ptr)
{
  free(ptr);
}

//----- (08087201) --------------------------------------------------------
int sub_8087201()
{
  if ( dword_89BFAE0 )
  {
    if ( dword_89BFAE0 != 257 )
      CompileError(dword_83DB9BC, "bad syntax");
  }
  else
  {
    CompileError(dword_83DB9BC, "unexpected end of file found");
  }
  return 0;
}
// 89BFAE0: using guessed type int dword_89BFAE0;

//----- (0808724F) --------------------------------------------------------
int __cdecl ScriptParse(_DWORD *a1, char a2)
{
  int result; // eax
  _DWORD s[15]; // [esp+10h] [ebp-48h] BYREF
  char v4; // [esp+4Fh] [ebp-9h]

  v4 = a2;
  memset(s, 0, 0x28u);
  dword_83DB9B8 = -1;
  dword_83DB9BC = 0;
  byte_83DB9C0 = v4;
  dword_83DB9C4 = 0;
  dword_815D548 = 1;
  s[3] = 0x4000;
  s[1] = &unk_83DB9E0;
  s[5] = 0;
  sub_8086F30(s, 0);
  dword_83DB9A0 = (int)s;
  dword_83DB9A8 = 3;
  yyparse();
  result = dword_83DB9B4;
  *a1 = dword_83DB9B4;
  return result;
}
// 815D548: using guessed type int dword_815D548;
// 83DB9A8: using guessed type int dword_83DB9A8;
// 83DB9B4: using guessed type int dword_83DB9B4;
// 83DB9B8: using guessed type int dword_83DB9B8;
// 83DB9C0: using guessed type char byte_83DB9C0;
// 83DB9C4: using guessed type int dword_83DB9C4;

//----- (080872FC) --------------------------------------------------------
int sub_80872FC()
{
  return 1;
}

//----- (08087306) --------------------------------------------------------
int yyparse()
{
  int v0; // ecx
  int v1; // edx
  int v2; // ecx
  int v3; // edx
  int *v4; // edx
  int v5; // eax
  int v6; // edx
  int *v7; // ebx
  int *v8; // ebx
  int *v9; // ebx
  int *v10; // ebx
  int *v11; // ebx
  int *v12; // ebx
  int *v13; // ebx
  int *v14; // ebx
  int *v15; // ebx
  int *v16; // ebx
  int *v17; // ebx
  int *v18; // ebx
  int *v19; // ebx
  int v20; // ecx
  int v21; // edx
  int v22; // ecx
  int v23; // edx
  int v25; // [esp+2Ch] [ebp-2CCh]
  int v26; // [esp+2Ch] [ebp-2CCh]
  int v27; // [esp+30h] [ebp-2C8h]
  unsigned int v28; // [esp+30h] [ebp-2C8h]
  unsigned int v29; // [esp+30h] [ebp-2C8h]
  unsigned int v30; // [esp+30h] [ebp-2C8h]
  unsigned int v31; // [esp+30h] [ebp-2C8h]
  int v32; // [esp+34h] [ebp-2C4h]
  int v33; // [esp+34h] [ebp-2C4h]
  int v35; // [esp+3Ch] [ebp-2BCh] BYREF
  int v36; // [esp+40h] [ebp-2B8h] BYREF
  int v37; // [esp+44h] [ebp-2B4h] BYREF
  int v38; // [esp+48h] [ebp-2B0h] BYREF
  int v39; // [esp+4Ch] [ebp-2ACh] BYREF
  int v40; // [esp+50h] [ebp-2A8h] BYREF
  int v41; // [esp+54h] [ebp-2A4h] BYREF
  int v42; // [esp+58h] [ebp-2A0h] BYREF
  int v43; // [esp+5Ch] [ebp-29Ch] BYREF
  int v44; // [esp+60h] [ebp-298h] BYREF
  int v45; // [esp+64h] [ebp-294h] BYREF
  _DWORD *v46; // [esp+68h] [ebp-290h] BYREF
  int v47; // [esp+6Ch] [ebp-28Ch] BYREF
  int v48; // [esp+70h] [ebp-288h] BYREF
  int v49; // [esp+74h] [ebp-284h] BYREF
  int v50; // [esp+78h] [ebp-280h] BYREF
  int v51; // [esp+7Ch] [ebp-27Ch] BYREF
  int v52; // [esp+80h] [ebp-278h] BYREF
  int v53; // [esp+84h] [ebp-274h] BYREF
  int v54; // [esp+88h] [ebp-270h] BYREF
  int v55; // [esp+8Ch] [ebp-26Ch] BYREF
  int v56; // [esp+90h] [ebp-268h] BYREF
  int v57; // [esp+94h] [ebp-264h] BYREF
  int v58; // [esp+98h] [ebp-260h] BYREF
  int v59; // [esp+9Ch] [ebp-25Ch] BYREF
  int v60; // [esp+A0h] [ebp-258h] BYREF
  int v61; // [esp+A4h] [ebp-254h] BYREF
  int v62; // [esp+A8h] [ebp-250h] BYREF
  int v63; // [esp+ACh] [ebp-24Ch] BYREF
  int v64; // [esp+B0h] [ebp-248h] BYREF
  int v65; // [esp+B4h] [ebp-244h] BYREF
  int v66; // [esp+B8h] [ebp-240h] BYREF
  int v67; // [esp+BCh] [ebp-23Ch] BYREF
  int v68; // [esp+C0h] [ebp-238h] BYREF
  int v69; // [esp+C4h] [ebp-234h] BYREF
  _DWORD *v70; // [esp+C8h] [ebp-230h] BYREF
  int v71; // [esp+CCh] [ebp-22Ch] BYREF
  int v72; // [esp+D0h] [ebp-228h] BYREF
  int v73; // [esp+D4h] [ebp-224h] BYREF
  int v74; // [esp+D8h] [ebp-220h] BYREF
  int v75; // [esp+DCh] [ebp-21Ch] BYREF
  int v76; // [esp+E0h] [ebp-218h] BYREF
  int v77; // [esp+E4h] [ebp-214h] BYREF
  int v78; // [esp+E8h] [ebp-210h] BYREF
  int v79; // [esp+ECh] [ebp-20Ch] BYREF
  int v80; // [esp+F0h] [ebp-208h] BYREF
  int v81; // [esp+F4h] [ebp-204h] BYREF
  int v82; // [esp+F8h] [ebp-200h] BYREF
  int v83; // [esp+FCh] [ebp-1FCh] BYREF
  int v84; // [esp+100h] [ebp-1F8h] BYREF
  int v85; // [esp+104h] [ebp-1F4h] BYREF
  int v86; // [esp+108h] [ebp-1F0h] BYREF
  int v87; // [esp+10Ch] [ebp-1ECh] BYREF
  int v88; // [esp+110h] [ebp-1E8h] BYREF
  int v89; // [esp+114h] [ebp-1E4h] BYREF
  int v90; // [esp+118h] [ebp-1E0h] BYREF
  int v91; // [esp+11Ch] [ebp-1DCh] BYREF
  int v92; // [esp+120h] [ebp-1D8h] BYREF
  int v93; // [esp+124h] [ebp-1D4h] BYREF
  int v94; // [esp+128h] [ebp-1D0h] BYREF
  int v95; // [esp+12Ch] [ebp-1CCh] BYREF
  int v96; // [esp+130h] [ebp-1C8h] BYREF
  int v97; // [esp+134h] [ebp-1C4h] BYREF
  int v98; // [esp+138h] [ebp-1C0h] BYREF
  int v99; // [esp+13Ch] [ebp-1BCh] BYREF
  int v100; // [esp+140h] [ebp-1B8h] BYREF
  int v101; // [esp+144h] [ebp-1B4h] BYREF
  int v102; // [esp+148h] [ebp-1B0h] BYREF
  int v103; // [esp+14Ch] [ebp-1ACh] BYREF
  int v104; // [esp+150h] [ebp-1A8h] BYREF
  int v105; // [esp+154h] [ebp-1A4h] BYREF
  int v106; // [esp+158h] [ebp-1A0h] BYREF
  int v107; // [esp+15Ch] [ebp-19Ch] BYREF
  int v108; // [esp+160h] [ebp-198h] BYREF
  int v109; // [esp+164h] [ebp-194h] BYREF
  int v110; // [esp+168h] [ebp-190h] BYREF
  int v111; // [esp+16Ch] [ebp-18Ch] BYREF
  int v112; // [esp+170h] [ebp-188h] BYREF
  int v113; // [esp+174h] [ebp-184h] BYREF
  int v114; // [esp+178h] [ebp-180h] BYREF
  int v115; // [esp+17Ch] [ebp-17Ch] BYREF
  int v116; // [esp+180h] [ebp-178h] BYREF
  int v117; // [esp+184h] [ebp-174h] BYREF
  int v118; // [esp+188h] [ebp-170h] BYREF
  int v119; // [esp+18Ch] [ebp-16Ch] BYREF
  int v120; // [esp+190h] [ebp-168h] BYREF
  int v121; // [esp+194h] [ebp-164h] BYREF
  int v122; // [esp+198h] [ebp-160h] BYREF
  int v123; // [esp+19Ch] [ebp-15Ch] BYREF
  int v124; // [esp+1A0h] [ebp-158h] BYREF
  int v125; // [esp+1A4h] [ebp-154h] BYREF
  int v126; // [esp+1A8h] [ebp-150h] BYREF
  int v127; // [esp+1ACh] [ebp-14Ch] BYREF
  int v128; // [esp+1B0h] [ebp-148h] BYREF
  int v129; // [esp+1B4h] [ebp-144h] BYREF
  int v130; // [esp+1B8h] [ebp-140h] BYREF
  int v131; // [esp+1BCh] [ebp-13Ch] BYREF
  int v132; // [esp+1C0h] [ebp-138h] BYREF
  int v133; // [esp+1C4h] [ebp-134h] BYREF
  int v134; // [esp+1C8h] [ebp-130h] BYREF
  int v135; // [esp+1CCh] [ebp-12Ch] BYREF
  int v136; // [esp+1D0h] [ebp-128h] BYREF
  int v137; // [esp+1D4h] [ebp-124h] BYREF
  int v138; // [esp+1D8h] [ebp-120h] BYREF
  int v139; // [esp+1DCh] [ebp-11Ch] BYREF
  int v140; // [esp+1E0h] [ebp-118h] BYREF
  int v141; // [esp+1E4h] [ebp-114h] BYREF
  int v142; // [esp+1E8h] [ebp-110h] BYREF
  int v143; // [esp+1ECh] [ebp-10Ch] BYREF
  int v144; // [esp+1F0h] [ebp-108h] BYREF
  int v145; // [esp+1F4h] [ebp-104h] BYREF
  int v146; // [esp+1F8h] [ebp-100h] BYREF
  int v147; // [esp+1FCh] [ebp-FCh] BYREF
  int v148; // [esp+200h] [ebp-F8h] BYREF
  int v149; // [esp+204h] [ebp-F4h] BYREF
  int v150; // [esp+208h] [ebp-F0h] BYREF
  int v151; // [esp+20Ch] [ebp-ECh] BYREF
  int v152; // [esp+210h] [ebp-E8h] BYREF
  int v153; // [esp+214h] [ebp-E4h] BYREF
  int v154; // [esp+218h] [ebp-E0h] BYREF
  int v155; // [esp+21Ch] [ebp-DCh] BYREF
  int v156; // [esp+220h] [ebp-D8h] BYREF
  int v157; // [esp+224h] [ebp-D4h] BYREF
  int v158; // [esp+228h] [ebp-D0h] BYREF
  int v159; // [esp+22Ch] [ebp-CCh] BYREF
  int v160; // [esp+230h] [ebp-C8h] BYREF
  int v161; // [esp+234h] [ebp-C4h] BYREF
  int v162; // [esp+238h] [ebp-C0h] BYREF
  int v163; // [esp+23Ch] [ebp-BCh] BYREF
  int v164; // [esp+240h] [ebp-B8h] BYREF
  int v165; // [esp+244h] [ebp-B4h] BYREF
  int v166; // [esp+248h] [ebp-B0h] BYREF
  int v167; // [esp+24Ch] [ebp-ACh] BYREF
  int v168; // [esp+250h] [ebp-A8h] BYREF
  int v169; // [esp+254h] [ebp-A4h] BYREF
  int v170; // [esp+258h] [ebp-A0h] BYREF
  int v171; // [esp+25Ch] [ebp-9Ch] BYREF
  int v172; // [esp+260h] [ebp-98h] BYREF
  int v173; // [esp+264h] [ebp-94h] BYREF
  int v174; // [esp+268h] [ebp-90h] BYREF
  int v175; // [esp+26Ch] [ebp-8Ch] BYREF
  int v176; // [esp+270h] [ebp-88h] BYREF
  int v177; // [esp+274h] [ebp-84h] BYREF
  int v178; // [esp+278h] [ebp-80h] BYREF
  int v179; // [esp+27Ch] [ebp-7Ch] BYREF
  int v180; // [esp+280h] [ebp-78h] BYREF
  int v181; // [esp+284h] [ebp-74h] BYREF
  int v182; // [esp+288h] [ebp-70h] BYREF
  int v183; // [esp+28Ch] [ebp-6Ch] BYREF
  int v184; // [esp+290h] [ebp-68h] BYREF
  int v185; // [esp+294h] [ebp-64h] BYREF
  int v186; // [esp+298h] [ebp-60h] BYREF
  int v187; // [esp+29Ch] [ebp-5Ch] BYREF
  int v188; // [esp+2A0h] [ebp-58h] BYREF
  int v189; // [esp+2A4h] [ebp-54h] BYREF
  int v190; // [esp+2A8h] [ebp-50h] BYREF
  int v191; // [esp+2ACh] [ebp-4Ch] BYREF
  int v192; // [esp+2B0h] [ebp-48h] BYREF
  int v193; // [esp+2B4h] [ebp-44h] BYREF
  int v194; // [esp+2B8h] [ebp-40h] BYREF
  int v195; // [esp+2BCh] [ebp-3Ch] BYREF
  int v196; // [esp+2C0h] [ebp-38h] BYREF
  int v197; // [esp+2C4h] [ebp-34h] BYREF
  int v198; // [esp+2C8h] [ebp-30h] BYREF
  int v199; // [esp+2CCh] [ebp-2Ch] BYREF
  int v200; // [esp+2D0h] [ebp-28h] BYREF
  int v201; // [esp+2D4h] [ebp-24h] BYREF
  int v202; // [esp+2D8h] [ebp-20h] BYREF
  int v203; // [esp+2DCh] [ebp-1Ch] BYREF
  int v204; // [esp+2E0h] [ebp-18h] BYREF
  int v205; // [esp+2E4h] [ebp-14h] BYREF
  int v206; // [esp+2E8h] [ebp-10h] BYREF
  int v207[3]; // [esp+2ECh] [ebp-Ch] BYREF

  dword_89BE730 = 0;
  dword_89BE720 = 0;
  dword_89BFAE0 = -1;
  dword_89BE72C = (int)word_89BE740;
  dword_89BE728 = (int)&unk_89BEB40;
  v25 = 0;
  word_89BE740[0] = 0;
  while ( 1 )
  {
    while ( 1 )
    {
      while ( 1 )
      {
        while ( 1 )
        {
          v27 = word_815AEA0[v25];
          if ( !word_815AEA0[v25] )
            break;
LABEL_29:
          v32 = word_815AD80[v27];
          v4 = (int *)(dword_89BE728 + 8 * (1 - v32));
          v5 = *v4;
          v6 = v4[1];
          dword_89BE734 = v5;
          dword_89BE738 = v6;
          switch ( v27 )
          {
            case 1:
              sub_8078450((int)&dword_83DB9B4, *(_DWORD *)(dword_89BE728 - 8), *(_DWORD *)dword_89BE728);
              break;
            case 2:
              sub_80783DE((int)&dword_83DB9B4, 65, *(_DWORD *)dword_89BE728);
              break;
            case 3:
            case 4:
              sub_80783DE((int)&dword_83DB9B4, 82, *(_DWORD *)dword_89BE728);
              break;
            case 5:
              sub_80783A2(v207, *(_DWORD *)(dword_89BE728 + 4));
              sub_8078412((int)&dword_89BE734, 6, *(_DWORD *)dword_89BE728, v207[0]);
              break;
            case 6:
              sub_80783A2(&v206, *(_DWORD *)(dword_89BE728 - 8 + 4));
              sub_80783A2(&v205, *(_DWORD *)(dword_89BE728 + 4));
              sub_80783A2(&v204, *(_DWORD *)(dword_89BE728 - 16 + 4));
              sub_80785A4(
                (int)&dword_89BE734,
                47,
                *(_DWORD *)(dword_89BE728 - 16),
                *(_DWORD *)dword_89BE728,
                v204,
                v205,
                v206);
              dword_89BE738 = *(_DWORD *)(dword_89BE728 - 8 + 4);
              break;
            case 7:
              sub_80783A2(&v203, *(_DWORD *)(dword_89BE728 - 8 + 4));
              sub_80783A2(&v202, *(_DWORD *)(dword_89BE728 + 4));
              sub_80783A2(&v201, *(_DWORD *)(dword_89BE728 - 16 + 4));
              sub_80785A4(
                (int)&dword_89BE734,
                48,
                *(_DWORD *)(dword_89BE728 - 16),
                *(_DWORD *)dword_89BE728,
                v201,
                v202,
                v203);
              dword_89BE738 = *(_DWORD *)(dword_89BE728 - 8 + 4);
              break;
            case 8:
              sub_80783A2(&v200, *(_DWORD *)(dword_89BE728 - 8 + 4));
              sub_8078390(&v199, 102);
              sub_807850A(
                (int)&dword_89BE734,
                49,
                *(_DWORD *)(dword_89BE728 - 16),
                *(_DWORD *)dword_89BE728,
                v199,
                v200);
              dword_89BE738 = *(_DWORD *)(dword_89BE728 - 8 + 4);
              break;
            case 9:
              sub_80783A2(&v198, *(_DWORD *)(dword_89BE728 - 8 + 4));
              sub_8078390(&v197, 103);
              sub_807850A(
                (int)&dword_89BE734,
                49,
                *(_DWORD *)(dword_89BE728 - 16),
                *(_DWORD *)dword_89BE728,
                v197,
                v198);
              dword_89BE738 = *(_DWORD *)(dword_89BE728 - 8 + 4);
              break;
            case 10:
              sub_80783A2(&v196, *(_DWORD *)(dword_89BE728 - 8 + 4));
              sub_8078390(&v195, 104);
              sub_807850A(
                (int)&dword_89BE734,
                49,
                *(_DWORD *)(dword_89BE728 - 16),
                *(_DWORD *)dword_89BE728,
                v195,
                v196);
              dword_89BE738 = *(_DWORD *)(dword_89BE728 - 8 + 4);
              break;
            case 11:
              sub_80783A2(&v194, *(_DWORD *)(dword_89BE728 - 8 + 4));
              sub_8078390(&v193, 105);
              sub_807850A(
                (int)&dword_89BE734,
                49,
                *(_DWORD *)(dword_89BE728 - 16),
                *(_DWORD *)dword_89BE728,
                v193,
                v194);
              dword_89BE738 = *(_DWORD *)(dword_89BE728 - 8 + 4);
              break;
            case 12:
              sub_80783A2(&v192, *(_DWORD *)(dword_89BE728 - 8 + 4));
              sub_8078390(&v191, 106);
              sub_807850A(
                (int)&dword_89BE734,
                49,
                *(_DWORD *)(dword_89BE728 - 16),
                *(_DWORD *)dword_89BE728,
                v191,
                v192);
              dword_89BE738 = *(_DWORD *)(dword_89BE728 - 8 + 4);
              break;
            case 13:
              sub_80783A2(&v190, *(_DWORD *)(dword_89BE728 - 8 + 4));
              sub_8078390(&v189, 107);
              sub_807850A(
                (int)&dword_89BE734,
                49,
                *(_DWORD *)(dword_89BE728 - 16),
                *(_DWORD *)dword_89BE728,
                v189,
                v190);
              dword_89BE738 = *(_DWORD *)(dword_89BE728 - 8 + 4);
              break;
            case 14:
              sub_80783A2(&v188, *(_DWORD *)(dword_89BE728 - 8 + 4));
              sub_8078390(&v187, 108);
              sub_807850A(
                (int)&dword_89BE734,
                49,
                *(_DWORD *)(dword_89BE728 - 16),
                *(_DWORD *)dword_89BE728,
                v187,
                v188);
              dword_89BE738 = *(_DWORD *)(dword_89BE728 - 8 + 4);
              break;
            case 15:
              sub_80783A2(&v186, *(_DWORD *)(dword_89BE728 - 8 + 4));
              sub_8078390(&v185, 109);
              sub_807850A(
                (int)&dword_89BE734,
                49,
                *(_DWORD *)(dword_89BE728 - 16),
                *(_DWORD *)dword_89BE728,
                v185,
                v186);
              dword_89BE738 = *(_DWORD *)(dword_89BE728 - 8 + 4);
              break;
            case 16:
              sub_80783A2(&v184, *(_DWORD *)(dword_89BE728 - 8 + 4));
              sub_8078390(&v183, 110);
              sub_807850A(
                (int)&dword_89BE734,
                49,
                *(_DWORD *)(dword_89BE728 - 16),
                *(_DWORD *)dword_89BE728,
                v183,
                v184);
              dword_89BE738 = *(_DWORD *)(dword_89BE728 - 8 + 4);
              break;
            case 17:
              sub_80783A2(&v182, *(_DWORD *)(dword_89BE728 - 8 + 4));
              sub_8078390(&v181, 111);
              sub_807850A(
                (int)&dword_89BE734,
                49,
                *(_DWORD *)(dword_89BE728 - 16),
                *(_DWORD *)dword_89BE728,
                v181,
                v182);
              dword_89BE738 = *(_DWORD *)(dword_89BE728 - 8 + 4);
              break;
            case 18:
              sub_80783A2(&v180, *(_DWORD *)(dword_89BE728 - 8 + 4));
              sub_8078390(&v179, 112);
              sub_807850A(
                (int)&dword_89BE734,
                49,
                *(_DWORD *)(dword_89BE728 - 16),
                *(_DWORD *)dword_89BE728,
                v179,
                v180);
              dword_89BE738 = *(_DWORD *)(dword_89BE728 - 8 + 4);
              break;
            case 19:
              sub_80783A2(&v178, *(_DWORD *)(dword_89BE728 - 8 + 4));
              sub_8078390(&v177, 113);
              sub_807850A(
                (int)&dword_89BE734,
                49,
                *(_DWORD *)(dword_89BE728 - 16),
                *(_DWORD *)dword_89BE728,
                v177,
                v178);
              dword_89BE738 = *(_DWORD *)(dword_89BE728 - 8 + 4);
              break;
            case 20:
              sub_80783A2(&v176, *(_DWORD *)(dword_89BE728 - 8 + 4));
              sub_8078390(&v175, 114);
              sub_807850A(
                (int)&dword_89BE734,
                49,
                *(_DWORD *)(dword_89BE728 - 16),
                *(_DWORD *)dword_89BE728,
                v175,
                v176);
              dword_89BE738 = *(_DWORD *)(dword_89BE728 - 8 + 4);
              break;
            case 21:
              sub_80783A2(&v174, *(_DWORD *)(dword_89BE728 - 8 + 4));
              sub_8078390(&v173, 115);
              sub_807850A(
                (int)&dword_89BE734,
                49,
                *(_DWORD *)(dword_89BE728 - 16),
                *(_DWORD *)dword_89BE728,
                v173,
                v174);
              dword_89BE738 = *(_DWORD *)(dword_89BE728 - 8 + 4);
              break;
            case 22:
              sub_80783A2(&v172, *(_DWORD *)(dword_89BE728 - 8 + 4));
              sub_8078390(&v171, 116);
              sub_807850A(
                (int)&dword_89BE734,
                49,
                *(_DWORD *)(dword_89BE728 - 16),
                *(_DWORD *)dword_89BE728,
                v171,
                v172);
              dword_89BE738 = *(_DWORD *)(dword_89BE728 - 8 + 4);
              break;
            case 23:
              sub_80783A2(&v170, *(_DWORD *)(dword_89BE728 - 8 + 4));
              sub_8078390(&v169, 117);
              sub_807850A(
                (int)&dword_89BE734,
                49,
                *(_DWORD *)(dword_89BE728 - 16),
                *(_DWORD *)dword_89BE728,
                v169,
                v170);
              dword_89BE738 = *(_DWORD *)(dword_89BE728 - 8 + 4);
              break;
            case 24:
              sub_80783A2(&v168, *(_DWORD *)(dword_89BE728 + 4));
              sub_8078412((int)&dword_89BE734, 50, *(_DWORD *)dword_89BE728, v168);
              break;
            case 25:
              sub_80783A2(&v167, *(_DWORD *)(dword_89BE728 + 4));
              sub_8078412((int)&dword_89BE734, 51, *(_DWORD *)dword_89BE728, v167);
              break;
            case 26:
              sub_80783DE((int)&dword_89BE734, 65, *(_DWORD *)dword_89BE728);
              break;
            case 27:
            case 94:
            case 104:
            case 112:
              sub_80783B4((size_t *)&dword_89BE734, 0);
              break;
            case 28:
            case 29:
              v7 = (int *)dword_89BE728;
              *v7 = sub_8085274(*(_DWORD *)dword_89BE728);
              dword_89BE734 = *(_DWORD *)dword_89BE728;
              break;
            case 30:
              v8 = (int *)dword_89BE728;
              *v8 = sub_8085274(*(_DWORD *)dword_89BE728);
              sub_80783A2(&v166, *(_DWORD *)(dword_89BE728 - 16 + 4));
              sub_8078484((int)&dword_89BE734, 21, *(_DWORD *)(dword_89BE728 - 16), *(_DWORD *)dword_89BE728, v166);
              ++dword_8202A44;
              break;
            case 31:
              v9 = (int *)dword_89BE728;
              *v9 = sub_8085274(*(_DWORD *)dword_89BE728);
              sub_80783A2(&v165, *(_DWORD *)(dword_89BE728 + 4));
              sub_8078412((int)&dword_89BE734, 20, *(_DWORD *)dword_89BE728, v165);
              break;
            case 32:
              v10 = (int *)dword_89BE728;
              *v10 = sub_8085274(*(_DWORD *)dword_89BE728);
              sub_80783A2(&v164, *(_DWORD *)(dword_89BE728 - 16 + 4));
              sub_8078484((int)&dword_89BE734, 21, *(_DWORD *)(dword_89BE728 - 16), *(_DWORD *)dword_89BE728, v164);
              dword_89BE738 = *(_DWORD *)(dword_89BE728 - 8 + 4);
              ++dword_8202A44;
              break;
            case 33:
              v11 = (int *)dword_89BE728;
              *v11 = sub_8085274(*(_DWORD *)dword_89BE728);
              sub_80783A2(&v163, *(_DWORD *)(dword_89BE728 - 8 + 4));
              sub_8078412((int)&dword_89BE734, 20, *(_DWORD *)dword_89BE728, v163);
              break;
            case 34:
              sub_80783A2(&v162, *(_DWORD *)(dword_89BE728 + 4));
              sub_8078412((int)&dword_89BE734, 18, *(_DWORD *)dword_89BE728, v162);
              break;
            case 35:
              sub_80783A2(&v161, *(_DWORD *)(dword_89BE728 - 16 + 4));
              sub_8078412((int)&dword_89BE734, 22, *(_DWORD *)(dword_89BE728 - 16), v161);
              break;
            case 36:
              sub_80783A2(&v160, *(_DWORD *)(dword_89BE728 + 4));
              sub_8078412((int)&dword_89BE734, 26, *(_DWORD *)dword_89BE728, v160);
              break;
            case 37:
              sub_80783A2(&v159, *(_DWORD *)(dword_89BE728 + 4));
              sub_80783A2(&v158, *(_DWORD *)(dword_89BE728 - 8 + 4));
              sub_8078484((int)&dword_89BE734, 30, *(_DWORD *)dword_89BE728, v158, v159);
              dword_89BE738 = *(_DWORD *)(dword_89BE728 + 4);
              break;
            case 38:
              sub_80783A2(&v157, *(_DWORD *)(dword_89BE728 - 16 + 4));
              sub_8078484(
                (int)&dword_89BE734,
                23,
                *(_DWORD *)(dword_89BE728 - 24),
                *(_DWORD *)(dword_89BE728 - 8),
                v157);
              dword_89BE738 = *(_DWORD *)(dword_89BE728 - 16 + 4);
              break;
            case 39:
              sub_80783A2(&v156, *(_DWORD *)(dword_89BE728 - 16 + 4));
              sub_80783A2(&v155, *(_DWORD *)(dword_89BE728 - 32 + 4));
              sub_80785A4(
                (int)&dword_89BE734,
                24,
                *(_DWORD *)(dword_89BE728 - 32),
                *(_DWORD *)(dword_89BE728 - 24),
                *(_DWORD *)(dword_89BE728 - 8),
                v155,
                v156);
              dword_89BE738 = *(_DWORD *)(dword_89BE728 - 16 + 4);
              break;
            case 40:
              sub_80783A2(&v154, *(_DWORD *)(dword_89BE728 - 16 + 4));
              sub_8078412((int)&dword_89BE734, 46, *(_DWORD *)(dword_89BE728 - 8), v154);
              break;
            case 41:
              sub_80783A2(&v153, *(_DWORD *)(dword_89BE728 + 4));
              sub_8078412((int)&dword_89BE734, 7, *(_DWORD *)dword_89BE728, v153);
              break;
            case 42:
              sub_80783A2(&v152, *(_DWORD *)(dword_89BE728 + 4));
              sub_8078412((int)&dword_89BE734, 8, *(_DWORD *)dword_89BE728, v152);
              break;
            case 43:
              sub_80783A2(&v151, *(_DWORD *)(dword_89BE728 - 8 + 4));
              sub_8078412((int)&dword_89BE734, 9, *(_DWORD *)dword_89BE728, v151);
              break;
            case 44:
              sub_80783A2(&v150, *(_DWORD *)(dword_89BE728 - 8 + 4));
              sub_8078412((int)&dword_89BE734, 10, *(_DWORD *)dword_89BE728, v150);
              break;
            case 45:
              sub_80783A2(&v149, *(_DWORD *)(dword_89BE728 + 4));
              sub_8078412((int)&dword_89BE734, 11, *(_DWORD *)dword_89BE728, v149);
              break;
            case 46:
              sub_80783A2(&v148, *(_DWORD *)(dword_89BE728 + 4));
              sub_8078412((int)&dword_89BE734, 12, *(_DWORD *)dword_89BE728, v148);
              break;
            case 47:
              sub_80783DE((int)&dword_89BE734, 19, *(_DWORD *)dword_89BE728);
              break;
            case 48:
              sub_80783A2(&v147, *(_DWORD *)(dword_89BE728 + 4));
              sub_8078412((int)&dword_89BE734, 17, *(_DWORD *)dword_89BE728, v147);
              break;
            case 49:
              sub_80783A2(&v146, *(_DWORD *)(dword_89BE728 + 4));
              sub_80783DE((int)&dword_89BE734, 31, v146);
              break;
            case 50:
              sub_80783A2(&v145, *(_DWORD *)(dword_89BE728 + 4));
              sub_80783DE((int)&dword_89BE734, 32, v145);
              break;
            case 51:
              sub_80783A2(&v144, *(_DWORD *)(dword_89BE728 + 4));
              sub_80783DE((int)&dword_89BE734, 34, v144);
              break;
            case 52:
              sub_80783A2(&v143, *(_DWORD *)(dword_89BE728 + 4));
              sub_80783DE((int)&dword_89BE734, 35, v143);
              break;
            case 53:
              sub_80783A2(&v142, *(_DWORD *)(dword_89BE728 + 4));
              sub_80783DE((int)&dword_89BE734, 36, v142);
              break;
            case 54:
              sub_80783A2(&v141, *(_DWORD *)(dword_89BE728 - 8 + 4));
              sub_8078412((int)&dword_89BE734, 52, *(_DWORD *)(dword_89BE728 - 8), v141);
              dword_89BE738 = *(_DWORD *)(dword_89BE728 + 4);
              break;
            case 55:
              sub_80783A2(&v140, *(_DWORD *)(dword_89BE728 + 4));
              sub_8078412((int)&dword_89BE734, 18, *(_DWORD *)dword_89BE728, v140);
              break;
            case 56:
              sub_80783A2(&v139, *(_DWORD *)(dword_89BE728 - 8 + 4));
              sub_80783DE((int)&dword_89BE734, 66, v139);
              break;
            case 57:
              v12 = (int *)dword_89BE728;
              *v12 = sub_8085274(*(_DWORD *)dword_89BE728);
              sub_80783A2(&v138, *(_DWORD *)(dword_89BE728 + 4));
              sub_8078412((int)&dword_89BE734, 67, *(_DWORD *)dword_89BE728, v138);
              break;
            case 58:
              sub_80783A2(&v137, *(_DWORD *)(dword_89BE728 + 4));
              sub_80783DE((int)&dword_89BE734, 72, v137);
              break;
            case 59:
              sub_80783A2(&v136, *(_DWORD *)(dword_89BE728 + 4));
              sub_80783DE((int)&dword_89BE734, 73, v136);
              break;
            case 60:
              sub_80783A2(&v135, *(_DWORD *)(dword_89BE728 + 4));
              sub_80783DE((int)&dword_89BE734, 74, v135);
              break;
            case 61:
              v13 = (int *)dword_89BE728;
              *v13 = sub_8085274(*(_DWORD *)dword_89BE728);
              sub_80783A2(&v134, *(_DWORD *)(dword_89BE728 - 16 + 4));
              sub_8078484((int)&dword_89BE734, 15, *(_DWORD *)(dword_89BE728 - 16), *(_DWORD *)dword_89BE728, v134);
              dword_89BE738 = *(_DWORD *)(dword_89BE728 + 4);
              break;
            case 62:
              sub_80783A2(&v133, *(_DWORD *)(dword_89BE728 - 8 + 4));
              sub_80783A2(&v132, *(_DWORD *)(dword_89BE728 - 24 + 4));
              sub_807850A(
                (int)&dword_89BE734,
                13,
                *(_DWORD *)(dword_89BE728 - 24),
                *(_DWORD *)(dword_89BE728 - 8),
                v132,
                v133);
              dword_89BE738 = *(_DWORD *)(dword_89BE728 - 16 + 4);
              break;
            case 63:
              v14 = (int *)dword_89BE728;
              *v14 = sub_8085274(*(_DWORD *)dword_89BE728);
              sub_80783A2(&v131, *(_DWORD *)(dword_89BE728 + 4));
              sub_8078412((int)&dword_89BE734, 4, *(_DWORD *)dword_89BE728, v131);
              break;
            case 64:
              v15 = (int *)dword_89BE728;
              *v15 = sub_8085274(*(_DWORD *)dword_89BE728);
              sub_80783A2(&v130, *(_DWORD *)(dword_89BE728 - 8 + 4));
              sub_8078412((int)&dword_89BE734, 79, *(_DWORD *)dword_89BE728, v130);
              break;
            case 65:
              sub_80783A2(&v129, *(_DWORD *)(dword_89BE728 - 16 + 4));
              sub_8078412((int)&dword_89BE734, 53, *(_DWORD *)(dword_89BE728 - 16), v129);
              dword_89BE738 = *(_DWORD *)(dword_89BE728 + 4);
              break;
            case 66:
              sub_80783A2(&v128, *(_DWORD *)(dword_89BE728 + 4));
              sub_80783A2(&v127, *(_DWORD *)(dword_89BE728 - 8 + 4));
              sub_807850A((int)&dword_89BE734, 2, *(_DWORD *)(dword_89BE728 - 16), *(_DWORD *)dword_89BE728, v127, v128);
              break;
            case 67:
              sub_80783A2(&v126, *(_DWORD *)(dword_89BE728 - 8 + 4));
              sub_8078412((int)&dword_89BE734, 27, *(_DWORD *)dword_89BE728, v126);
              break;
            case 68:
              sub_80783A2(&v125, *(_DWORD *)(dword_89BE728 + 4));
              sub_80783DE((int)&dword_89BE734, 28, v125);
              break;
            case 69:
              sub_80783A2(&v124, *(_DWORD *)(dword_89BE728 - 8 + 4));
              sub_80783A2(&v123, *(_DWORD *)(dword_89BE728 + 4));
              sub_8078484((int)&dword_89BE734, 29, *(_DWORD *)dword_89BE728, v123, v124);
              break;
            case 70:
              sub_80783A2(&v122, *(_DWORD *)(dword_89BE728 - 8 + 4));
              sub_8078412((int)&dword_89BE734, 41, *(_DWORD *)(dword_89BE728 - 8), v122);
              break;
            case 71:
              sub_80783A2(&v121, *(_DWORD *)(dword_89BE728 - 8 + 4));
              sub_8078412((int)&dword_89BE734, 42, *(_DWORD *)(dword_89BE728 - 8), v121);
              break;
            case 72:
              sub_80783A2(&v120, *(_DWORD *)(dword_89BE728 - 8 + 4));
              sub_8078390(&v119, 102);
              sub_807850A(
                (int)&dword_89BE734,
                43,
                *(_DWORD *)(dword_89BE728 - 16),
                *(_DWORD *)dword_89BE728,
                v119,
                v120);
              break;
            case 73:
              sub_80783A2(&v118, *(_DWORD *)(dword_89BE728 - 8 + 4));
              sub_8078390(&v117, 103);
              sub_807850A(
                (int)&dword_89BE734,
                43,
                *(_DWORD *)(dword_89BE728 - 16),
                *(_DWORD *)dword_89BE728,
                v117,
                v118);
              break;
            case 74:
              sub_80783A2(&v116, *(_DWORD *)(dword_89BE728 - 8 + 4));
              sub_8078390(&v115, 104);
              sub_807850A(
                (int)&dword_89BE734,
                43,
                *(_DWORD *)(dword_89BE728 - 16),
                *(_DWORD *)dword_89BE728,
                v115,
                v116);
              break;
            case 75:
              sub_80783A2(&v114, *(_DWORD *)(dword_89BE728 - 8 + 4));
              sub_8078390(&v113, 111);
              sub_807850A(
                (int)&dword_89BE734,
                43,
                *(_DWORD *)(dword_89BE728 - 16),
                *(_DWORD *)dword_89BE728,
                v113,
                v114);
              break;
            case 76:
              sub_80783A2(&v112, *(_DWORD *)(dword_89BE728 - 8 + 4));
              sub_8078390(&v111, 112);
              sub_807850A(
                (int)&dword_89BE734,
                43,
                *(_DWORD *)(dword_89BE728 - 16),
                *(_DWORD *)dword_89BE728,
                v111,
                v112);
              break;
            case 77:
              sub_80783A2(&v110, *(_DWORD *)(dword_89BE728 - 8 + 4));
              sub_8078390(&v109, 113);
              sub_807850A(
                (int)&dword_89BE734,
                43,
                *(_DWORD *)(dword_89BE728 - 16),
                *(_DWORD *)dword_89BE728,
                v109,
                v110);
              break;
            case 78:
              sub_80783A2(&v108, *(_DWORD *)(dword_89BE728 - 8 + 4));
              sub_8078390(&v107, 114);
              sub_807850A(
                (int)&dword_89BE734,
                43,
                *(_DWORD *)(dword_89BE728 - 16),
                *(_DWORD *)dword_89BE728,
                v107,
                v108);
              break;
            case 79:
              sub_80783A2(&v106, *(_DWORD *)(dword_89BE728 - 8 + 4));
              sub_8078390(&v105, 115);
              sub_807850A(
                (int)&dword_89BE734,
                43,
                *(_DWORD *)(dword_89BE728 - 16),
                *(_DWORD *)dword_89BE728,
                v105,
                v106);
              break;
            case 80:
              sub_80783A2(&v104, *(_DWORD *)(dword_89BE728 - 8 + 4));
              sub_8078390(&v103, 116);
              sub_807850A(
                (int)&dword_89BE734,
                43,
                *(_DWORD *)(dword_89BE728 - 16),
                *(_DWORD *)dword_89BE728,
                v103,
                v104);
              break;
            case 81:
              sub_80783A2(&v102, *(_DWORD *)(dword_89BE728 - 8 + 4));
              sub_8078390(&v101, 117);
              sub_807850A(
                (int)&dword_89BE734,
                43,
                *(_DWORD *)(dword_89BE728 - 16),
                *(_DWORD *)dword_89BE728,
                v101,
                v102);
              break;
            case 82:
              sub_80783A2(&v100, *(_DWORD *)(dword_89BE728 - 24 + 4));
              sub_80783A2(&v99, *(_DWORD *)(dword_89BE728 - 32 + 4));
              sub_807850A(
                (int)&dword_89BE734,
                55,
                *(_DWORD *)(dword_89BE728 - 32),
                *(_DWORD *)(dword_89BE728 - 8),
                v99,
                v100);
              break;
            case 83:
              sub_80783A2(&v98, *(_DWORD *)(dword_89BE728 - 24 + 4));
              sub_80783A2(&v97, *(_DWORD *)(dword_89BE728 - 32 + 4));
              sub_807850A(
                (int)&dword_89BE734,
                56,
                *(_DWORD *)(dword_89BE728 - 32),
                *(_DWORD *)(dword_89BE728 - 8),
                v97,
                v98);
              break;
            case 84:
              sub_80783A2(&v96, *(_DWORD *)(dword_89BE728 + 4));
              sub_80783DE((int)&dword_89BE734, 57, v96);
              break;
            case 85:
              sub_80783A2(&v95, *(_DWORD *)(dword_89BE728 - 24 + 4));
              sub_80783A2(&v94, *(_DWORD *)(dword_89BE728 - 32 + 4));
              sub_807850A(
                (int)&dword_89BE734,
                58,
                *(_DWORD *)(dword_89BE728 - 32),
                *(_DWORD *)(dword_89BE728 - 8),
                v94,
                v95);
              break;
            case 86:
              sub_80783A2(&v93, *(_DWORD *)(dword_89BE728 - 8 + 4));
              sub_80783A2(&v92, *(_DWORD *)(dword_89BE728 - 32 + 4));
              sub_807850A(
                (int)&dword_89BE734,
                59,
                *(_DWORD *)(dword_89BE728 - 32),
                *(_DWORD *)(dword_89BE728 - 8),
                v92,
                v93);
              break;
            case 87:
              sub_80783A2(&v91, *(_DWORD *)(dword_89BE728 + 4));
              sub_80783DE((int)&dword_89BE734, 63, v91);
              break;
            case 88:
              sub_80783A2(&v90, *(_DWORD *)(dword_89BE728 + 4));
              sub_80783DE((int)&dword_89BE734, 64, v90);
              break;
            case 89:
              sub_80783A2(&v89, *(_DWORD *)(dword_89BE728 + 4));
              sub_80783DE((int)&dword_89BE734, 75, v89);
              break;
            case 90:
              sub_80783A2(&v88, *(_DWORD *)(dword_89BE728 - 24 + 4));
              sub_8078412((int)&dword_89BE734, 76, *(_DWORD *)(dword_89BE728 - 8), v88);
              break;
            case 91:
              sub_80783A2(&v87, *(_DWORD *)(dword_89BE728 - 24 + 4));
              sub_8078412((int)&dword_89BE734, 77, *(_DWORD *)(dword_89BE728 - 8), v87);
              break;
            case 92:
              sub_80783DE((int)&dword_89BE734, 25, *(_DWORD *)dword_89BE728);
              break;
            case 97:
              sub_80783A2(&v86, *(_DWORD *)(dword_89BE728 + 4));
              sub_80783A2(&v85, *(_DWORD *)(dword_89BE728 - 16 + 4));
              sub_8078484((int)&dword_89BE734, 44, *(_DWORD *)(dword_89BE728 - 8), v85, v86);
              break;
            case 98:
              sub_80783A2(&v84, *(_DWORD *)(dword_89BE728 - 16 + 4));
              sub_807850A(
                (int)&dword_89BE734,
                37,
                *(_DWORD *)(dword_89BE728 - 16),
                *(_DWORD *)dword_89BE728,
                v84,
                dword_83DB9C4);
              break;
            case 99:
              sub_80783A2(&v83, *(_DWORD *)(dword_89BE728 - 8 + 4));
              sub_80783A2(&v82, *(_DWORD *)(dword_89BE728 - 32 + 4));
              sub_8078666(
                (int)&dword_89BE734,
                38,
                *(_DWORD *)(dword_89BE728 - 32),
                *(_DWORD *)(dword_89BE728 - 16),
                *(_DWORD *)dword_89BE728,
                v82,
                v83,
                dword_83DB9C4,
                dword_83DB9C4);
              break;
            case 100:
              sub_80783A2(&v81, *(_DWORD *)(dword_89BE728 - 32 + 4));
              sub_80783A2(&v80, *(_DWORD *)(dword_89BE728 - 16 + 4));
              sub_80785A4(
                (int)&dword_89BE734,
                39,
                *(_DWORD *)(dword_89BE728 - 16),
                *(_DWORD *)dword_89BE728,
                v80,
                v81,
                dword_83DB9C4);
              break;
            case 101:
              sub_80783A2(&v79, *(_DWORD *)(dword_89BE728 - 56 + 4));
              sub_80783A2(&v78, *(_DWORD *)(dword_89BE728 - 32 + 4));
              sub_80786D6(
                (int)&dword_89BE734,
                40,
                *(_DWORD *)(dword_89BE728 - 40),
                *(_DWORD *)(dword_89BE728 - 32),
                *(_DWORD *)(dword_89BE728 - 16),
                *(_DWORD *)dword_89BE728,
                v78,
                v79,
                dword_83DB9C4,
                dword_83DB9C4);
              break;
            case 102:
              sub_80783A2(&v77, *(_DWORD *)(dword_89BE728 - 32 + 4));
              sub_8078484((int)&dword_89BE734, 60, *(_DWORD *)(dword_89BE728 - 32), *(_DWORD *)(dword_89BE728 - 8), v77);
              break;
            case 103:
              sub_80783A2(&v76, *(_DWORD *)(dword_89BE728 - 16 + 4));
              sub_8078484((int)&dword_89BE734, 45, *(_DWORD *)(dword_89BE728 - 8), v76, dword_83DB9C4);
              break;
            case 105:
              sub_80783A2(&v75, *(_DWORD *)(dword_89BE728 - 16 + 4));
              sub_8078484((int)&dword_89BE734, 61, *(_DWORD *)(dword_89BE728 - 8), v75, dword_83DB9C4);
              break;
            case 106:
              sub_80783A2(&v74, *(_DWORD *)(dword_89BE728 - 8 + 4));
              sub_8078412((int)&dword_89BE734, 62, v74, dword_83DB9C4);
              break;
            case 108:
            case 126:
              sub_80787EC(&dword_89BE734, *(_DWORD *)(dword_89BE728 - 8), *(_DWORD *)dword_89BE728);
              break;
            case 109:
              sub_80783B4((size_t *)&v73, 0);
              sub_8078750((int)&dword_89BE734, v73);
              break;
            case 110:
              sub_80783A2(&v71, *(_DWORD *)(dword_89BE728 + 4));
              sub_8078450((int)&v72, *(_DWORD *)dword_89BE728, v71);
              sub_80787A6(&dword_89BE734, v72, *(_DWORD **)(dword_89BE728 - 16));
              break;
            case 111:
              sub_80783B4((size_t *)&v70, 0);
              sub_80783A2(&v68, *(_DWORD *)(dword_89BE728 + 4));
              sub_8078450((int)&v69, *(_DWORD *)dword_89BE728, v68);
              sub_80787A6(&dword_89BE734, v69, v70);
              break;
            case 113:
              v16 = (int *)dword_89BE728;
              *v16 = sub_8085274(*(_DWORD *)dword_89BE728);
              sub_80783A2(&v66, *(_DWORD *)(dword_89BE728 + 4));
              sub_8078450((int)&v67, *(_DWORD *)dword_89BE728, v66);
              sub_80787EC(&dword_89BE734, *(_DWORD *)(dword_89BE728 - 16), v67);
              break;
            case 114:
              v17 = (int *)dword_89BE728;
              *v17 = sub_8085274(*(_DWORD *)dword_89BE728);
              sub_80783A2(&v64, *(_DWORD *)(dword_89BE728 + 4));
              sub_8078450((int)&v65, *(_DWORD *)dword_89BE728, v64);
              sub_80783B4((size_t *)&v62, 0);
              sub_8078750((int)&v63, v62);
              sub_80787EC(&dword_89BE734, v63, v65);
              break;
            case 115:
              sub_80783B4((size_t *)&v61, 0);
              sub_8078750((int)&dword_89BE734, v61);
              break;
            case 116:
              v18 = (int *)dword_89BE728;
              *v18 = sub_8085274(*(_DWORD *)dword_89BE728);
              sub_80783A2(&v59, *(_DWORD *)(dword_89BE728 + 4));
              sub_8078450((int)&v60, *(_DWORD *)dword_89BE728, v59);
              sub_80787EC(&dword_89BE734, *(_DWORD *)(dword_89BE728 - 16), v60);
              break;
            case 117:
              sub_80783A2(&v57, *(_DWORD *)(dword_89BE728 + 4));
              sub_8078450((int)&v58, *(_DWORD *)dword_89BE728, v57);
              sub_80783B4((size_t *)&v55, 0);
              sub_8078750((int)&v56, v55);
              sub_80787EC(&dword_89BE734, v56, v58);
              break;
            case 118:
              sub_80783A2(&v53, *(_DWORD *)(dword_89BE728 + 4));
              sub_8078450((int)&v54, *(_DWORD *)dword_89BE728, v53);
              sub_80787EC(&dword_89BE734, *(_DWORD *)(dword_89BE728 - 16), v54);
              break;
            case 119:
              sub_80783A2(&v51, *(_DWORD *)(dword_89BE728 + 4));
              sub_8078450((int)&v52, *(_DWORD *)dword_89BE728, v51);
              sub_80783B4((size_t *)&v49, 0);
              sub_8078750((int)&v50, v49);
              sub_80787EC(&dword_89BE734, v50, v52);
              break;
            case 120:
              sub_80783A2(&v47, *(_DWORD *)(dword_89BE728 + 4));
              sub_8078450((int)&v48, *(_DWORD *)dword_89BE728, v47);
              sub_80787A6(&dword_89BE734, v48, *(_DWORD **)(dword_89BE728 - 16));
              break;
            case 121:
              sub_80783B4((size_t *)&v46, 0);
              sub_80783A2(&v44, *(_DWORD *)(dword_89BE728 + 4));
              sub_8078450((int)&v45, *(_DWORD *)dword_89BE728, v44);
              sub_80787A6(&dword_89BE734, v45, v46);
              break;
            case 122:
              v19 = (int *)(dword_89BE728 - 48);
              *v19 = sub_8085274(*(_DWORD *)(dword_89BE728 - 48));
              sub_80783A2(&v43, *(_DWORD *)(dword_89BE728 + 4));
              sub_80783A2(&v42, *(_DWORD *)(dword_89BE728 - 48 + 4));
              sub_8078600(
                (int)&dword_89BE734,
                68,
                *(_DWORD *)(dword_89BE728 - 48),
                *(_DWORD *)(dword_89BE728 - 32),
                *(_DWORD *)(dword_89BE728 - 8),
                v42,
                v43,
                dword_83DB9C4);
              break;
            case 123:
              sub_80783A2(&v41, *(_DWORD *)(dword_89BE728 - 16 + 4));
              sub_80783A2(&v40, *(_DWORD *)(dword_89BE728 - 32 + 4));
              sub_8078484((int)&dword_89BE734, 71, *(_DWORD *)(dword_89BE728 - 16), v40, v41);
              break;
            case 124:
              sub_80783A2(&v39, *(_DWORD *)(dword_89BE728 + 4));
              sub_80783DE((int)&dword_89BE734, 69, v39);
              break;
            case 125:
              sub_80783A2(&v38, *(_DWORD *)(dword_89BE728 + 4));
              sub_80783DE((int)&dword_89BE734, 70, v38);
              break;
            case 127:
              sub_80783B4((size_t *)&v37, 0);
              sub_8078750((int)&dword_89BE734, v37);
              break;
            case 128:
              sub_80783A2(&v36, *(_DWORD *)(dword_89BE728 - 8 + 4));
              sub_8078412((int)&dword_89BE734, 85, *(_DWORD *)dword_89BE728, v36);
              ++dword_8202A44;
              break;
            case 129:
              sub_80787EC(&dword_89BE734, *(_DWORD *)(dword_89BE728 - 16), *(_DWORD *)(dword_89BE728 - 8));
              break;
            case 130:
              sub_80783B4((size_t *)&v35, 0);
              sub_8078750((int)&dword_89BE734, v35);
              break;
            default:
              break;
          }
          dword_89BE72C -= 2 * v32;
          v26 = *(__int16 *)dword_89BE72C;
          dword_89BE728 -= 8 * v32;
          v33 = word_815AC60[v27];
          if ( v26 || word_815AC60[v27] )
          {
            if ( word_815B4E0[v33] && (v31 = v26 + word_815B4E0[v33], v31 <= 0x802) && word_815C540[v31] == v26 )
              v25 = word_815B520[v31];
            else
              v25 = word_815B0A0[v33];
            if ( dword_89BE72C >= (unsigned int)&unk_89BEB26 )
              goto LABEL_164;
            dword_89BE72C += 2;
            *(_WORD *)dword_89BE72C = v25;
            dword_89BE728 += 8;
            v22 = dword_89BE728;
            v23 = dword_89BE738;
            *(_DWORD *)dword_89BE728 = dword_89BE734;
            *(_DWORD *)(v22 + 4) = v23;
          }
          else
          {
            v25 = 3;
            dword_89BE72C += 2;
            *(_WORD *)dword_89BE72C = 3;
            dword_89BE728 += 8;
            v20 = dword_89BE728;
            v21 = dword_89BE738;
            *(_DWORD *)dword_89BE728 = dword_89BE734;
            *(_DWORD *)(v20 + 4) = v21;
            if ( dword_89BFAE0 < 0 )
            {
              dword_89BFAE0 = sub_808546B();
              if ( dword_89BFAE0 < 0 )
                dword_89BFAE0 = 0;
            }
            if ( !dword_89BFAE0 )
              return 0;
          }
        }
        if ( dword_89BFAE0 < 0 )
        {
          dword_89BFAE0 = sub_808546B();
          if ( dword_89BFAE0 < 0 )
            dword_89BFAE0 = 0;
        }
        if ( !word_815B0E0[v25] )
          break;
        v28 = dword_89BFAE0 + word_815B0E0[v25];
        if ( v28 > 0x802 || word_815C540[v28] != dword_89BFAE0 )
          break;
        if ( dword_89BE72C >= (unsigned int)&unk_89BEB26 )
          goto LABEL_164;
        dword_89BE72C += 2;
        v25 = word_815B520[v28];
        *(_WORD *)dword_89BE72C = v25;
        dword_89BE728 += 8;
        v0 = dword_89BE728;
        v1 = dword_89BEB30;
        *(_DWORD *)dword_89BE728 = dword_89BEB2C;
        *(_DWORD *)(v0 + 4) = v1;
        dword_89BFAE0 = -1;
        if ( dword_89BE720 > 0 )
          --dword_89BE720;
      }
      if ( word_815B2E0[v25] )
      {
        v29 = dword_89BFAE0 + word_815B2E0[v25];
        if ( v29 <= 0x802 && word_815C540[v29] == dword_89BFAE0 )
        {
          v27 = word_815B520[v29];
          goto LABEL_29;
        }
      }
      if ( !dword_89BE720 )
      {
        sub_8087201();
        ++dword_89BE730;
      }
      if ( dword_89BE720 <= 2 )
        break;
      if ( !dword_89BFAE0 )
        return 1;
      dword_89BFAE0 = -1;
    }
    dword_89BE720 = 3;
    while ( 1 )
    {
      if ( word_815B0E0[*(__int16 *)dword_89BE72C] )
      {
        v30 = word_815B0E0[*(__int16 *)dword_89BE72C] + 256;
        if ( v30 <= 0x802 && word_815C540[v30] == 256 )
          break;
      }
      if ( dword_89BE72C <= (unsigned int)word_89BE740 )
        return 1;
      dword_89BE72C -= 2;
      dword_89BE728 -= 8;
    }
    if ( dword_89BE72C >= (unsigned int)&unk_89BEB26 )
      break;
    dword_89BE72C += 2;
    v25 = word_815B520[v30];
    *(_WORD *)dword_89BE72C = v25;
    dword_89BE728 += 8;
    v2 = dword_89BE728;
    v3 = dword_89BEB30;
    *(_DWORD *)dword_89BE728 = dword_89BEB2C;
    *(_DWORD *)(v2 + 4) = v3;
  }
LABEL_164:
  sub_8087201();
  return 1;
}
// 815AC60: using guessed type __int16 word_815AC60[144];
// 815AD80: using guessed type __int16 word_815AD80[144];
// 815AEA0: using guessed type __int16 word_815AEA0[256];
// 815B0A0: using guessed type __int16 word_815B0A0[32];
// 815B0E0: using guessed type __int16 word_815B0E0[];
// 815B2E0: using guessed type __int16 word_815B2E0[];
// 815B4E0: using guessed type __int16 word_815B4E0[32];
// 815B520: using guessed type __int16 word_815B520[2064];
// 815C540: using guessed type __int16 word_815C540[];
// 8202A44: using guessed type int dword_8202A44;
// 83DB9B4: using guessed type int dword_83DB9B4;
// 83DB9C4: using guessed type int dword_83DB9C4;
// 89BE720: using guessed type int dword_89BE720;
// 89BE728: using guessed type int dword_89BE728;
// 89BE72C: using guessed type int dword_89BE72C;
// 89BE730: using guessed type int dword_89BE730;
// 89BE734: using guessed type int dword_89BE734;
// 89BE738: using guessed type int dword_89BE738;
// 89BE740: using guessed type _WORD word_89BE740[499];
// 89BEB2C: using guessed type int dword_89BEB2C;
// 89BEB30: using guessed type int dword_89BEB30;
// 89BFAE0: using guessed type int dword_89BFAE0;
// 8087306: using guessed type int var_C[3];

//----- (0808AA30) --------------------------------------------------------
char *SV_GetPlayerByName()
{
  char dest[68]; // [esp+20h] [ebp-58h] BYREF
  char v3[4]; // [esp+64h] [ebp-14h]
  int v4; // [esp+68h] [ebp-10h]
  char *v5; // [esp+6Ch] [ebp-Ch]

  if ( !*(_BYTE *)(com_sv_running + 8) )
    return 0;
  if ( SV_Cmd_Argc() > 1 )
  {
    *(_DWORD *)v3 = SV_Cmd_Argv(1u);
    v4 = 0;
    v5 = (char *)dword_841FB0C;
    while ( v4 < *(_DWORD *)(sv_maxclients + 8) )
    {
      if ( *(_DWORD *)v5 )
      {
        if ( !I_stricmp(v5 + 134216, *(char **)v3) )
          return v5;
        I_strncpyz(dest, v5 + 134216, 64);
        sub_80B587C(dest);
        if ( !I_stricmp(dest, *(char **)v3) )
          return v5;
      }
      ++v4;
      v5 += 495380;
    }
    Com_Printf("Player %s is not on the server\n", *(const char **)v3);
    return 0;
  }
  else
  {
    Com_Printf("No player specified.\n");
    return 0;
  }
}
// 819EF14: using guessed type int com_sv_running;
// 848B1CC: using guessed type int sv_maxclients;

//----- (0808AB48) --------------------------------------------------------
char *sub_808AB48()
{
  const char *nptr; // [esp+18h] [ebp-10h]
  int v3; // [esp+1Ch] [ebp-Ch]
  int i; // [esp+20h] [ebp-8h]

  if ( !*(_BYTE *)(com_sv_running + 8) )
    return 0;
  if ( SV_Cmd_Argc() > 1 )
  {
    nptr = SV_Cmd_Argv(1u);
    for ( i = 0; nptr[i]; ++i )
    {
      if ( nptr[i] <= 47 || nptr[i] > 57 )
      {
        Com_Printf("Bad slot number: %s\n", nptr);
        return 0;
      }
    }
    v3 = atoi(nptr);
    if ( v3 >= 0 && v3 < *(_DWORD *)(sv_maxclients + 8) )
    {
      if ( *((_DWORD *)dword_841FB0C + 123845 * v3) )
      {
        return (char *)dword_841FB0C + 495380 * v3;
      }
      else
      {
        Com_Printf("Client %i is not active\n", v3);
        return 0;
      }
    }
    else
    {
      Com_Printf("Bad client slot: %i\n", v3);
      return 0;
    }
  }
  else
  {
    Com_Printf("No player specified.\n");
    return 0;
  }
}
// 819EF14: using guessed type int com_sv_running;
// 848B1CC: using guessed type int sv_maxclients;

//----- (0808AC6A) --------------------------------------------------------
void *__cdecl sub_808AC6A(char *s)
{
  return sub_8065BE0(s);
}

//----- (0808AC7E) --------------------------------------------------------
void __usercall sub_808AC7E(long double a1@<st0>)
{
  char *v1; // eax
  bool v2; // [esp+1Fh] [ebp-59h]
  char dest[64]; // [esp+20h] [ebp-58h] BYREF
  char v4[4]; // [esp+60h] [ebp-18h]
  char *src; // [esp+64h] [ebp-14h]
  char *v6; // [esp+68h] [ebp-10h]
  char *s; // [esp+6Ch] [ebp-Ch]

  s = SV_Cmd_Argv(1u);
  if ( *s )
  {
    src = (char *)sub_808AC6A(s);
    I_strncpyz(dest, src, 64);
    I_strlwr(dest);
    v1 = GetBspExtension();
    *(_DWORD *)v4 = va("maps/mp/%s.%s", dest, v1);
    if ( FS_ReadFile(*(const char **)v4, 0) == -1 )
    {
      Com_Printf("Can't find map %s\n", *(const char **)v4);
    }
    else
    {
      v6 = SV_Cmd_Argv(0);
      v2 = I_stricmp(v6, "devmap") == 0;
      FS_ConvertPath(dest);
      SV_SpawnServer(a1, dest);
      Dvar_SetBool(sv_cheats, v2);
    }
  }
}
// 848B208: using guessed type int sv_cheats;

//----- (0808AD76) --------------------------------------------------------
void __usercall sub_808AD76(long double a1@<st0>, int a2)
{
  char *v2; // eax
  char *v3; // eax
  int v4; // [esp+1Ch] [ebp-5Ch]
  char dest[68]; // [esp+20h] [ebp-58h] BYREF
  char *v6; // [esp+64h] [ebp-14h]
  int v7; // [esp+68h] [ebp-10h]
  int v8[3]; // [esp+6Ch] [ebp-Ch]

  if ( *(_BYTE *)(com_sv_running + 8) )
  {
    SV_SetGametype(a1);
    I_strncpyz(byte_848B174, *(char **)(g_gametype + 8), 64);
    v4 = G_GetSavePersist();
    if ( !*(_BYTE *)(sv_maxclients + 7) && !strcasecmp(byte_848B174, *(const char **)(g_gametype + 8)) && a2 )
    {
      if ( com_frameTime != dword_842BC88 )
      {
        sub_8091B5A();
        sub_8091A70();
        dword_841FB08 ^= 4u;
        dword_841FA88 = (((_BYTE)dword_841FA88 + 1) & 0xF) + (dword_841FA88 & 0xF0);
        Dvar_SetInt(sv_serverid, (char *)dword_841FA88);
        dword_842BC88 = com_frameTime;
        dword_842BC80 = 1;
        dword_842BC84 = 1;
        SV_RestartGameProgs(a1, v4);
        for ( v8[0] = 0; v8[0] <= 2; ++v8[0] )
        {
          dword_841FB04 += 100;
          sub_8094780(a1);
        }
        for ( v8[0] = 0; v8[0] < *(_DWORD *)(sv_maxclients + 8); ++v8[0] )
        {
          v7 = (int)dword_841FB0C + 495380 * v8[0];
          if ( *(int *)v7 > 1 )
          {
            if ( v4 )
              v3 = va("%c", 110);
            else
              v3 = va("%c", 66);
            sub_8092D5C((_DWORD *)v7, 1, v3);
            v6 = (char *)ClientConnect(a1, v8[0], *(_WORD *)(v7 + 484856));
            if ( v6 )
            {
              SV_DropClient(a1, v7, v6);
              Com_Printf("SV_MapRestart_f: dropped client %i - denied!\n", v8[0]);
            }
            else if ( *(_DWORD *)v7 == 4 )
            {
              sub_808E1F0(v7, (_DWORD *)(v7 + 133156));
            }
          }
        }
        dword_842BC80 = 2;
        dword_842BC84 = 0;
      }
    }
    else
    {
      sub_8106968(0);
      v2 = (char *)Dvar_GetString("mapname");
      I_strncpyz(dest, v2, 64);
      FS_ConvertPath(dest);
      SV_SpawnServer(a1, dest);
    }
  }
  else
  {
    Com_Printf("Server is not running.\n");
  }
}
// 819EF14: using guessed type int com_sv_running;
// 819EF40: using guessed type int com_frameTime;
// 841FA88: using guessed type int dword_841FA88;
// 841FB08: using guessed type int dword_841FB08;
// 842BC80: using guessed type int dword_842BC80;
// 842BC84: using guessed type int dword_842BC84;
// 842BC88: using guessed type int dword_842BC88;
// 848B1CC: using guessed type int sv_maxclients;
// 848B1E4: using guessed type int sv_serverid;
// 808AD76: using guessed type int var_C[3];

//----- (0808AFE0) --------------------------------------------------------
void __usercall sub_808AFE0(long double a1@<st0>)
{
  sub_808AD76(a1, 0);
}

//----- (0808AFF4) --------------------------------------------------------
void __usercall sub_808AFF4(long double a1@<st0>)
{
  sub_808AD76(a1, 1);
}

//----- (0808B008) --------------------------------------------------------
char *sub_808B008()
{
  char *v2; // [esp+10h] [ebp-8h]
  char *src; // [esp+14h] [ebp-4h] BYREF

  src = *(char **)(sv_mapRotationCurrent + 8);
  v2 = Com_Parse(&src);
  if ( src )
  {
    Dvar_SetString(sv_mapRotationCurrent, src);
    return v2;
  }
  else
  {
    Dvar_SetString(sv_mapRotationCurrent, (char *)&byte_8142A4E);
    return 0;
  }
}

//----- (0808B06A) --------------------------------------------------------
void __usercall sub_808B06A(long double a1@<st0>)
{
  char *v1; // eax
  const char *s1; // [esp+14h] [ebp-4h]
  char *s1a; // [esp+14h] [ebp-4h]
  const char *s1b; // [esp+14h] [ebp-4h]

  Com_Printf("map_rotate...\n\n");
  Com_Printf("\"sv_mapRotation\" is:\"%s\"\n\n", *(const char **)(sv_mapRotation + 8));
  Com_Printf("\"sv_mapRotationCurrent\" is:\"%s\"\n\n", *(const char **)(sv_mapRotationCurrent + 8));
  if ( !**(_BYTE **)(sv_mapRotationCurrent + 8) )
    Dvar_SetString(sv_mapRotationCurrent, *(char **)(sv_mapRotation + 8));
  s1 = sub_808B008();
  if ( !s1 )
  {
    Dvar_SetString(sv_mapRotationCurrent, *(char **)(sv_mapRotation + 8));
    s1 = sub_808B008();
  }
  while ( 1 )
  {
    if ( !s1 )
    {
      Com_Printf("No map specified in sv_mapRotation - forcing map_restart.\n");
      sub_808AFF4(a1);
      return;
    }
    if ( strcasecmp(s1, "gametype") )
      break;
    s1a = sub_808B008();
    if ( !s1a )
    {
      Com_Printf("No gametype specified after 'gametype' keyword in sv_mapRotation - forcing map_restart.\n");
      sub_808AFF4(a1);
      return;
    }
    Com_Printf("Setting g_gametype: %s.\n", s1a);
    if ( *(_BYTE *)(com_sv_running + 8) )
    {
      if ( strcasecmp(*(const char **)(g_gametype + 8), s1a) )
        sub_8106968(0);
    }
    Dvar_SetString(g_gametype, s1a);
LABEL_19:
    s1 = sub_808B008();
  }
  if ( strcasecmp(s1, "map") )
  {
    Com_Printf("Unknown keyword '%s' in sv_mapRotation.\n", s1);
    goto LABEL_19;
  }
  s1b = sub_808B008();
  if ( s1b )
  {
    Com_Printf("Setting map: %s.\n", s1b);
    v1 = va("map %s\n", s1b);
    Cbuf_ExecuteText(0, v1);
  }
  else
  {
    Com_Printf("No map specified after 'map' keyword in sv_mapRotation - forcing map_restart.\n");
    sub_808AFF4(a1);
  }
}
// 819EF14: using guessed type int com_sv_running;
// 848B21C: using guessed type int sv_mapRotation;

//----- (0808B24C) --------------------------------------------------------
int __usercall sub_808B24C@<eax>(long double a1@<st0>, int a2, char *dest, int a4)
{
  int v6; // [esp+14h] [ebp-4h]

  if ( *(_DWORD *)(a2 + 452036) == 2 )
  {
    SV_SendServerCommand(0, 0, "%c \"EXE_CANNOTKICKHOSTPLAYER\"", 101);
    return 0;
  }
  else
  {
    if ( dest )
    {
      I_strncpyz(dest, (char *)(a2 + 134216), a4);
      sub_80B587C(dest);
    }
    v6 = *(_DWORD *)(a2 + 484852);
    SV_DropClient(a1, a2, "EXE_PLAYERKICKED");
    *(_DWORD *)(a2 + 134416) = dword_841FB04;
    return v6;
  }
}

//----- (0808B2F2) --------------------------------------------------------
int __usercall sub_808B2F2@<eax>(long double a1@<st0>, char *dest, int a3)
{
  char *v3; // eax
  int v6; // [esp+1Ch] [ebp-Ch]
  char *v7; // [esp+20h] [ebp-8h]
  _DWORD *v8; // [esp+20h] [ebp-8h]
  char *v9; // [esp+24h] [ebp-4h]

  if ( *(_BYTE *)(com_sv_running + 8) )
  {
    if ( SV_Cmd_Argc() == 2 )
    {
      v7 = SV_GetPlayerByName();
      if ( v7 )
      {
        return sub_808B24C(a1, (int)v7, dest, a3);
      }
      else
      {
        v3 = SV_Cmd_Argv(1u);
        if ( !I_stricmp(v3, "all") )
        {
          v6 = 0;
          v8 = dword_841FB0C;
          while ( v6 < *(_DWORD *)(sv_maxclients + 8) )
          {
            if ( *v8 )
              sub_808B24C(a1, (int)v8, 0, 0);
            ++v6;
            v8 += 123845;
          }
        }
        return 0;
      }
    }
    else
    {
      v9 = SV_Cmd_Argv(0);
      Com_Printf("Usage: %s <player name>\n%s all = kick everyone\n", v9, v9);
      return 0;
    }
  }
  else
  {
    Com_Printf("Server is not running.\n");
    return 0;
  }
}
// 819EF14: using guessed type int com_sv_running;
// 848B1CC: using guessed type int sv_maxclients;

//----- (0808B406) --------------------------------------------------------
int __usercall sub_808B406@<eax>(long double a1@<st0>, char *dest, int a3)
{
  char *v3; // eax
  char *v6; // [esp+14h] [ebp-4h]

  if ( *(_BYTE *)(com_sv_running + 8) )
  {
    if ( SV_Cmd_Argc() == 2 )
    {
      v6 = sub_808AB48();
      if ( v6 )
        return sub_808B24C(a1, (int)v6, dest, a3);
      else
        return 0;
    }
    else
    {
      v3 = SV_Cmd_Argv(0);
      Com_Printf("Usage: %s <client number>\n", v3);
      return 0;
    }
  }
  else
  {
    Com_Printf("Server is not running.\n");
    return 0;
  }
}
// 819EF14: using guessed type int com_sv_running;

//----- (0808B494) --------------------------------------------------------
int __usercall sub_808B494@<eax>(long double a1@<st0>)
{
  int result; // eax
  char dest[76]; // [esp+10h] [ebp-58h] BYREF
  int v3; // [esp+5Ch] [ebp-Ch]

  result = sub_808B2F2(a1, dest, 64);
  v3 = result;
  if ( result )
  {
    Com_Printf("%s (guid %i) was kicked for cheating\n", dest, v3);
    return sub_808C4CE(v3);
  }
  return result;
}

//----- (0808B4DE) --------------------------------------------------------
void __usercall sub_808B4DE(long double a1@<st0>)
{
  char *v1; // [esp+4h] [ebp-4h]

  if ( *(_BYTE *)(com_sv_running + 8) )
  {
    if ( SV_Cmd_Argc() == 2 )
    {
      v1 = SV_GetPlayerByName();
      if ( v1 )
        sub_808C4FA(a1, (int)v1);
    }
    else
    {
      Com_Printf("Usage: banUser <player name>\n");
    }
  }
  else
  {
    Com_Printf("Server is not running.\n");
  }
}
// 819EF14: using guessed type int com_sv_running;

//----- (0808B532) --------------------------------------------------------
void __usercall sub_808B532(long double a1@<st0>)
{
  char *v1; // [esp+4h] [ebp-4h]

  if ( *(_BYTE *)(com_sv_running + 8) )
  {
    if ( SV_Cmd_Argc() == 2 )
    {
      v1 = sub_808AB48();
      if ( v1 )
        sub_808C4FA(a1, (int)v1);
    }
    else
    {
      Com_Printf("Usage: banClient <client number>\n");
    }
  }
  else
  {
    Com_Printf("Server is not running.\n");
  }
}
// 819EF14: using guessed type int com_sv_running;

//----- (0808B586) --------------------------------------------------------
void sub_808B586()
{
  char *v0; // eax

  if ( SV_Cmd_Argc() == 2 )
  {
    v0 = SV_Cmd_Argv(1u);
    sub_808C626(v0);
  }
  else
  {
    Com_Printf("Usage: unban <client name>\n");
  }
}

//----- (0808B5BA) --------------------------------------------------------
int __usercall sub_808B5BA@<eax>(long double a1@<st0>)
{
  return sub_808B2F2(a1, 0, 0);
}

//----- (0808B5D6) --------------------------------------------------------
int __usercall sub_808B5D6@<eax>(long double a1@<st0>)
{
  return sub_808B406(a1, 0, 0);
}

//----- (0808B5F2) --------------------------------------------------------
int __usercall sub_808B5F2@<eax>(long double a1@<st0>)
{
  int result; // eax
  char dest[76]; // [esp+10h] [ebp-58h] BYREF
  int v3; // [esp+5Ch] [ebp-Ch]

  result = sub_808B406(a1, dest, 64);
  v3 = result;
  if ( result )
  {
    Com_Printf("%s (guid %i) was kicked for cheating\n", dest, v3);
    return sub_808C4CE(v3);
  }
  return result;
}

//----- (0808B63C) --------------------------------------------------------
void sub_808B63C()
{
  int v0; // eax
  int v1; // [esp+18h] [ebp-20h]
  const char *s; // [esp+20h] [ebp-18h]
  char *v3; // [esp+28h] [ebp-10h]
  int v4; // [esp+2Ch] [ebp-Ch]
  signed int v5; // [esp+2Ch] [ebp-Ch]
  int i; // [esp+30h] [ebp-8h]
  signed int j; // [esp+30h] [ebp-8h]
  int v8; // [esp+34h] [ebp-4h]

  if ( *(_BYTE *)(com_sv_running + 8) )
  {
    Com_Printf("map: %s\n", *(const char **)(mapname + 8));
    Com_Printf("num score ping guid   name            lastmsg address               qport rate\n");
    Com_Printf("--- ----- ---- ------ --------------- ------- --------------------- ----- -----\n");
    v8 = 0;
    v3 = (char *)dword_841FB0C;
    while ( v8 < *(_DWORD *)(sv_maxclients + 8) )
    {
      if ( *(_DWORD *)v3 )
      {
        Com_Printf("%3i ", v8);
        SV_GameClientNum(v8);
        v0 = sub_810698A(-1653759219 * ((v3 - (_BYTE *)dword_841FB0C) >> 2));
        Com_Printf("%5i ", v0);
        if ( *(_DWORD *)v3 == 2 )
        {
          Com_Printf("CNCT ");
        }
        else if ( *(_DWORD *)v3 == 1 )
        {
          Com_Printf("ZMBI ");
        }
        else
        {
          v1 = *((_DWORD *)v3 + 113001);
          if ( v1 > 9999 )
            v1 = 9999;
          Com_Printf("%4i ", v1);
        }
        Com_Printf("%6i ", *((_DWORD *)v3 + 121213));
        Com_Printf("%s^7", v3 + 134216);
        v4 = 16 - sub_80B5814(v3 + 134216);
        for ( i = 0; i < v4; ++i )
          Com_Printf(" ");
        Com_Printf("%7i ", dword_841FB04 - *((_DWORD *)v3 + 33604));
        s = NET_AdrToString(
              *((_DWORD *)v3 + 113009),
              *((_DWORD *)v3 + 113010),
              *((_DWORD *)v3 + 113011),
              *((_DWORD *)v3 + 113012),
              *((_DWORD *)v3 + 113013));
        Com_Printf("%s", s);
        v5 = 22 - strlen(s);
        for ( j = 0; j < v5; ++j )
          Com_Printf(" ");
        Com_Printf("%5i", *((_DWORD *)v3 + 113014));
        Com_Printf(" %5i", *((_DWORD *)v3 + 113002));
        Com_Printf("\n");
      }
      ++v8;
      v3 += 495380;
    }
    Com_Printf("\n");
  }
  else
  {
    Com_Printf("Server is not running.\n");
  }
}
// 819EF14: using guessed type int com_sv_running;
// 848B1CC: using guessed type int sv_maxclients;
// 848B1E0: using guessed type int mapname;

//----- (0808B8DC) --------------------------------------------------------
void sub_808B8DC()
{
  size_t v0; // eax
  char dest[1036]; // [esp+20h] [ebp-418h] BYREF
  char *s; // [esp+42Ch] [ebp-Ch]

  if ( *(_BYTE *)(com_sv_running + 8) )
  {
    if ( SV_Cmd_Argc() > 1 )
    {
      strcpy(dest, "console: ");
      s = Cmd_Args(1);
      if ( *s == 34 )
      {
        v0 = strlen(++s);
        s[v0 - 1] = 0;
      }
      I_strncat(dest, 1024, s);
      SV_SendServerCommand(0, 0, aC_2, 104, dest);
    }
  }
  else
  {
    Com_Printf("Server is not running.\n");
  }
}
// 819EF14: using guessed type int com_sv_running;

//----- (0808B9A2) --------------------------------------------------------
void sub_808B9A2()
{
  char *v0; // eax
  size_t v1; // eax
  int v2; // [esp+28h] [ebp-420h]
  _DWORD *v3; // [esp+2Ch] [ebp-41Ch]
  char dest[1036]; // [esp+30h] [ebp-418h] BYREF
  char *s; // [esp+43Ch] [ebp-Ch]

  if ( *(_BYTE *)(com_sv_running + 8) )
  {
    if ( SV_Cmd_Argc() > 2 )
    {
      v0 = SV_Cmd_Argv(1u);
      v2 = atoi(v0);
      if ( v2 >= 0 && v2 < *(_DWORD *)(sv_maxclients + 8) )
      {
        v3 = (char *)dword_841FB0C + 495380 * v2;
        if ( *v3 == 4 )
        {
          strcpy(dest, "console: ");
          s = Cmd_Args(2);
          if ( *s == 34 )
          {
            v1 = strlen(++s);
            s[v1 - 1] = 0;
          }
          I_strncat(dest, 1024, s);
          SV_SendServerCommand(v3, 0, aC_2, 104, dest);
        }
      }
    }
  }
  else
  {
    Com_Printf("Server is not running.\n");
  }
}
// 819EF14: using guessed type int com_sv_running;
// 848B1CC: using guessed type int sv_maxclients;

//----- (0808BACE) --------------------------------------------------------
void sub_808BACE()
{
  dword_841FB54 = 0x80000000;
}
// 841FB54: using guessed type int dword_841FB54;

//----- (0808BADE) --------------------------------------------------------
void sub_808BADE()
{
  char *v0; // eax

  Com_Printf("Server info settings:\n");
  v0 = Dvar_InfoString(0x404u);
  Info_Print(v0);
}

//----- (0808BB06) --------------------------------------------------------
void sub_808BB06()
{
  char *v0; // eax

  Com_Printf("System info settings:\n");
  v0 = Dvar_InfoString(8u);
  Info_Print(v0);
}

//----- (0808BB2E) --------------------------------------------------------
void sub_808BB2E()
{
  char *v0; // [esp+4h] [ebp-4h]

  if ( *(_BYTE *)(com_sv_running + 8) )
  {
    if ( SV_Cmd_Argc() == 2 )
    {
      v0 = SV_GetPlayerByName();
      if ( v0 )
      {
        Com_Printf("userinfo\n");
        Com_Printf("--------\n");
        Info_Print(v0 + 12);
      }
    }
    else
    {
      Com_Printf("Usage: info <userid>\n");
    }
  }
  else
  {
    Com_Printf("Server is not running.\n");
  }
}
// 819EF14: using guessed type int com_sv_running;

//----- (0808BB9E) --------------------------------------------------------
void *__usercall sub_808BB9E@<eax>(long double a1@<st0>)
{
  return Com_Shutdown(a1, "EXE_SERVERKILLED");
}

//----- (0808BBB2) --------------------------------------------------------
void sub_808BBB2()
{
  sub_8094FFC();
}

//----- (0808BBC0) --------------------------------------------------------
void sub_808BBC0()
{
  Scr_DumpScriptThreads();
}

//----- (0808BBCE) --------------------------------------------------------
void sub_808BBCE()
{
  sub_8076040();
}

//----- (0808BBDC) --------------------------------------------------------
void SV_AddOperatorCommands()
{
  if ( !dword_83DF9E8 )
  {
    dword_83DF9E8 = 1;
    Cmd_AddCommand("heartbeat", (int)sub_808BACE);
    Cmd_AddCommand("onlykick", (int)sub_808B5BA);
    Cmd_AddCommand("banUser", (int)sub_808B4DE);
    Cmd_AddCommand("banClient", (int)sub_808B532);
    Cmd_AddCommand("kick", (int)sub_808B494);
    Cmd_AddCommand("tempBanUser", (int)sub_808B494);
    Cmd_AddCommand("tempBanClient", (int)sub_808B5F2);
    Cmd_AddCommand("unbanUser", (int)sub_808B586);
    Cmd_AddCommand("clientkick", (int)sub_808B5D6);
    Cmd_AddCommand("status", (int)sub_808B63C);
    Cmd_AddCommand("serverinfo", (int)sub_808BADE);
    Cmd_AddCommand("systeminfo", (int)sub_808BB06);
    Cmd_AddCommand("dumpuser", (int)sub_808BB2E);
    Cmd_AddCommand("map_restart", (int)sub_808AFE0);
    Cmd_AddCommand("fast_restart", (int)sub_808AFF4);
    Cmd_AddCommand("map", (int)sub_808AC7E);
    Cmd_SetAutoComplete("map", (int)"maps/mp", (int)"d3dbsp");
    Cmd_AddCommand("map_rotate", (int)sub_808B06A);
    Cmd_AddCommand("gameCompleteStatus", (int)sub_808BBB2);
    Cmd_AddCommand("devmap", (int)sub_808AC7E);
    Cmd_SetAutoComplete("devmap", (int)"maps/mp", (int)"d3dbsp");
    Cmd_AddCommand("killserver", (int)sub_808BB9E);
    if ( *(_DWORD *)(com_dedicated + 8) )
      sub_808BE02();
    Cmd_AddCommand("scriptUsage", (int)sub_808BBC0);
    Cmd_AddCommand("stringUsage", (int)sub_808BBCE);
  }
}
// 83DF9E8: using guessed type int dword_83DF9E8;
// 8494204: using guessed type int com_dedicated;

//----- (0808BDFC) --------------------------------------------------------
void SV_RemoveOperatorCommands()
{
  ;
}

//----- (0808BE02) --------------------------------------------------------
void sub_808BE02()
{
  Cmd_AddCommand("say", (int)sub_808B8DC);
  Cmd_AddCommand("tell", (int)sub_808B9A2);
}

//----- (0808BE32) --------------------------------------------------------
void sub_808BE32()
{
  Cmd_RemoveCommand("say");
  Cmd_RemoveCommand("tell");
}

//----- (0808BE54) --------------------------------------------------------
void __usercall SV_GetChallenge(long double a1@<st0>, int a2, int a3, int a4, int a5, int a6)
{
  int v6; // ebx
  char *v7; // eax
  __int16 v8; // ax
  int *v9; // eax
  char *v10; // eax
  int *v11; // [esp+50h] [ebp-18h]
  int v12; // [esp+54h] [ebp-14h]
  int v13; // [esp+58h] [ebp-10h]
  int i; // [esp+5Ch] [ebp-Ch]

  v13 = 0;
  v12 = 0x7FFFFFFF;
  v11 = &dword_841FB5C;
  for ( i = 0; i <= 1023 && (v11[10] || !NET_CompareAdr(a2, a3, a4, a5, a6, *v11)); ++i )
  {
    if ( v11[6] < v12 )
    {
      v12 = v11[6];
      v13 = i;
    }
    v11 += 12;
  }
  if ( i == 1024 )
  {
    v11 = (int *)(48 * v13 + 138541916);
    v6 = rand() << 16;
    dword_841FB70[12 * v13] = dword_841FB04 ^ v6 ^ rand();
    *v11 = a2;
    v11[1] = a3;
    v11[2] = a4;
    v11[3] = a5;
    v11[4] = a6;
    v11[8] = dword_841FB04;
    v11[9] = 0;
    v11[6] = dword_841FB04;
    v11[10] = 0;
    i = v13;
  }
  if ( !*(_BYTE *)(net_lanauthorize + 8) && Sys_IsLANAddress(a2, a3) )
  {
    v11[7] = dword_841FB04;
    v7 = va("challengeResponse %i", v11[5]);
    NET_OutOfBandPrint(1, a2, a3, a4, a5, a6, v7);
    return;
  }
  if ( !(_BYTE)dword_842BB74 && dword_842BB70 != 1 )
  {
    Com_Printf("Resolving %s\n", "cod2master.activision.com");
    if ( !NET_StringToAdr("cod2master.activision.com", &dword_842BB70) )
    {
      Com_Printf("Couldn't resolve address\n");
      return;
    }
    dword_842BB78 = BigShort(20700);
    v8 = BigShort(dword_842BB78);
    Com_Printf(
      "%s resolved to %i.%i.%i.%i:%i\n",
      "cod2master.activision.com",
      (unsigned __int8)dword_842BB74,
      BYTE1(dword_842BB74),
      BYTE2(dword_842BB74),
      HIBYTE(dword_842BB74),
      v8);
  }
  if ( dword_841FB04 - v11[8] <= 5000 || (v9 = sub_8094E38(), NET_CompareAdr(a2, a3, a4, a5, a6, *v9)) )
  {
    sub_808C21C(a1, a2, a3, a4, a5, a6, dword_841FB70[12 * i]);
  }
  else
  {
    Com_DPrintf("authorize server timed out\n");
    v11[7] = dword_841FB04;
    v10 = va("challengeResponse %i", v11[5]);
    NET_OutOfBandPrint(1, *v11, v11[1], v11[2], v11[3], v11[4], v10);
  }
}
// 81F7114: using guessed type int net_lanauthorize;
// 841FB5C: using guessed type int dword_841FB5C;
// 841FB70: using guessed type int dword_841FB70[];
// 808BE54: using guessed type int arg_4;
// 808BE54: using guessed type int arg_8;

//----- (0808C21C) --------------------------------------------------------
void __usercall sub_808C21C(long double a1@<st0>, int a2, int a3, int a4, int a5, int a6, int a7)
{
  char *v7; // eax
  char *v8; // eax
  char dest[1035]; // [esp+20h] [ebp-418h] BYREF
  unsigned __int8 v10; // [esp+42Bh] [ebp-Dh]
  char *v11; // [esp+42Ch] [ebp-Ch]

  if ( dword_842BB70 != 1 )
  {
    dest[0] = 0;
    v11 = Dvar_RegisterString(a1, "fs_game", (char *)&byte_814309B, 4124);
    if ( v11 )
    {
      if ( **((_BYTE **)v11 + 2) )
        strcpy(dest, *((const char **)v11 + 2));
    }
    v7 = NET_AdrToString(a2, a3, a4, a5, a6);
    Com_DPrintf("sending getIpAuthorize for %s\n", v7);
    v10 = Dvar_GetBool("sv_allowAnonymous");
    v8 = va(
           "getIpAuthorize %i %i.%i.%i.%i %s %i",
           a7,
           (unsigned __int8)a3,
           BYTE1(a3),
           BYTE2(a3),
           HIBYTE(a3),
           dest,
           v10);
    NET_OutOfBandPrint(1, dword_842BB70, dword_842BB74, *(int *)&dword_842BB78, dword_842BB7C, dword_842BB80, v8);
  }
}

//----- (0808C34C) --------------------------------------------------------
int __cdecl sub_808C34C(int a1)
{
  unsigned int i; // [esp+4h] [ebp-4h]

  if ( !a1 )
    return 0;
  for ( i = 0; i <= 0xF; ++i )
  {
    if ( dword_842BB88[2 * i] == a1
      && (long double)(dword_841FB04 - dword_842BB8C[2 * i]) <= *(float *)(sv_kickBanTime + 8) * 1000.0 )
    {
      return 1;
    }
  }
  return 0;
}
// 842BB88: using guessed type int dword_842BB88[];
// 842BB8C: using guessed type int dword_842BB8C[61];
// 848B224: using guessed type int sv_kickBanTime;

//----- (0808C3D0) --------------------------------------------------------
int __cdecl sub_808C3D0(int a1)
{
  int v3; // [esp+14h] [ebp-14h]
  char *nptr; // [esp+1Ch] [ebp-Ch]
  char *v5; // [esp+20h] [ebp-8h] BYREF
  char *v6; // [esp+24h] [ebp-4h] BYREF

  if ( !a1 )
    return 0;
  if ( FS_ReadFile("ban.txt", &v6) < 0 )
    return 0;
  v5 = v6;
  v3 = 0;
  while ( 1 )
  {
    nptr = Com_Parse(&v5);
    if ( !*nptr )
      break;
    if ( atoi(nptr) == a1 )
    {
      v3 = 1;
      break;
    }
    Com_SkipRestOfLine(&v5);
  }
  FS_FreeFile(v6);
  return v3;
}

//----- (0808C46E) --------------------------------------------------------
unsigned int sub_808C46E()
{
  unsigned int v2; // [esp+4h] [ebp-8h]
  unsigned int i; // [esp+8h] [ebp-4h]

  v2 = 0;
  for ( i = 0; i <= 0xF; ++i )
  {
    if ( !dword_842BB88[2 * i] )
      return i;
    if ( dword_842BB8C[2 * i] < dword_842BB8C[2 * v2] )
      v2 = i;
  }
  return v2;
}
// 842BB88: using guessed type int dword_842BB88[];
// 842BB8C: using guessed type int dword_842BB8C[61];

//----- (0808C4CE) --------------------------------------------------------
int __cdecl sub_808C4CE(int a1)
{
  unsigned int v1; // eax
  unsigned int v2; // edx
  int result; // eax

  v1 = sub_808C46E();
  dword_842BB88[2 * v1] = a1;
  v2 = v1;
  result = dword_841FB04;
  dword_842BB8C[2 * v2] = dword_841FB04;
  return result;
}
// 842BB88: using guessed type int dword_842BB88[];
// 842BB8C: using guessed type int dword_842BB8C[61];

//----- (0808C4FA) --------------------------------------------------------
void __usercall sub_808C4FA(long double a1@<st0>, int a2)
{
  char dest[76]; // [esp+10h] [ebp-58h] BYREF
  int v3[3]; // [esp+5Ch] [ebp-Ch] BYREF

  if ( *(_DWORD *)(a2 + 452036) == 2 )
  {
    SV_SendServerCommand(0, 0, "%c \"EXE_CANNOTKICKHOSTPLAYER\"", 101);
  }
  else if ( *(_DWORD *)(a2 + 484852) )
  {
    if ( sub_808C3D0(*(_DWORD *)(a2 + 484852)) )
    {
      Com_Printf("This GUID (%i) is already banned\n", *(_DWORD *)(a2 + 484852));
    }
    else if ( FS_FOpenFileByMode("ban.txt", v3, 2) >= 0 )
    {
      I_strncpyz(dest, (char *)(a2 + 134216), 64);
      sub_80B587C(dest);
      FS_Printf(v3[0], "%i %s\r\n", *(_DWORD *)(a2 + 484852), dest);
      FS_FCloseFile(v3[0]);
      SV_DropClient(a1, a2, "EXE_PLAYERKICKED");
      *(_DWORD *)(a2 + 134416) = dword_841FB04;
    }
  }
  else
  {
    Com_Printf("Can't ban user, GUID is 0\n");
  }
}
// 808C4FA: using guessed type int var_C[3];

//----- (0808C626) --------------------------------------------------------
void __cdecl sub_808C626(char *a1)
{
  int v1; // [esp+1Ch] [ebp-6Ch]
  int v2; // [esp+20h] [ebp-68h]
  int v3; // [esp+28h] [ebp-60h]
  void *dest; // [esp+30h] [ebp-58h]
  void *src; // [esp+34h] [ebp-54h] BYREF
  int v6; // [esp+38h] [ebp-50h]
  int v7; // [esp+3Ch] [ebp-4Ch] BYREF
  char s[72]; // [esp+40h] [ebp-48h] BYREF

  v6 = FS_ReadFile("ban.txt", &v7);
  if ( v6 >= 0 )
  {
    I_strncpyz(s, a1, 64);
    sub_80B587C(s);
    v3 = strlen(s);
    v2 = 0;
    src = (void *)v7;
    while ( 1 )
    {
      dest = src;
      if ( !*Com_Parse((char **)&src) )
        break;
      while ( *(_BYTE *)src && *(char *)src <= 32 )
        src = (char *)src + 1;
      v1 = 0;
      if ( !sub_808FD2A(src, s, v3) && (*((_BYTE *)src + v3) == 13 || *((_BYTE *)src + v3) == 10) )
        v1 = 1;
      Com_SkipRestOfLine(&src);
      if ( v1 )
      {
        ++v2;
        memmove(dest, src, v6 - ((unsigned int)src - v7) + 1);
        v6 -= (_BYTE *)src - (_BYTE *)dest;
        src = dest;
      }
    }
    sub_809E99E("ban.txt", (char *)v7, v6);
    FS_FreeFile((_DWORD *)v7);
    if ( v2 )
      Com_Printf("unbanned %i user(s) named %s\n", v2, s);
    else
      Com_Printf("no banned user has name %s\n", s);
  }
}

//----- (0808C7CA) --------------------------------------------------------
void __cdecl sub_808C7CA(char a1, int a2, int a3, int a4, int a5)
{
  char *v5; // eax
  char *v6; // eax
  char *v7; // eax
  char s[1024]; // [esp+30h] [ebp-418h] BYREF
  char *v9; // [esp+430h] [ebp-18h]
  char *v10; // [esp+434h] [ebp-14h]
  int i; // [esp+438h] [ebp-10h]
  int v12; // [esp+43Ch] [ebp-Ch]

  if ( !NET_CompareBaseAdr(a1, a2, a3, a4, a5, dword_842BB70) )
  {
    Com_Printf("SV_AuthorizeIpPacket: not from authorize server\n");
    return;
  }
  v5 = SV_Cmd_Argv(1u);
  v12 = atoi(v5);
  for ( i = 0; i <= 1023 && dword_841FB70[12 * i] != v12; ++i )
    ;
  if ( i == 1024 )
  {
    Com_Printf("SV_AuthorizeIpPacket: challenge not found\n");
    return;
  }
  dword_841FB78[12 * i] = dword_841FB04;
  v10 = SV_Cmd_Argv(2u);
  v9 = SV_Cmd_Argv(3u);
  if ( I_stricmp(v10, "demo") )
  {
    if ( !I_stricmp(v10, "accept") )
    {
      v7 = SV_Cmd_Argv(4u);
      dword_841FB88[12 * i] = atoi(v7);
      if ( sub_808C3D0(dword_841FB88[12 * i]) )
      {
        Com_Printf("rejected connection from permanently banned GUID %i\n", dword_841FB88[12 * i]);
        NET_OutOfBandPrint(
          1,
          dword_841FB5C[12 * i],
          dword_841FB60[12 * i],
          dword_841FB64[12 * i],
          dword_841FB68[12 * i],
          dword_841FB6C[12 * i],
          aError_1);
        memset((void *)(48 * i + 138541916), 0, 0x30u);
      }
      else if ( sub_808C34C(dword_841FB88[12 * i]) )
      {
        Com_Printf("rejected connection from temporarily banned GUID %i\n", dword_841FB88[12 * i]);
        NET_OutOfBandPrint(
          1,
          dword_841FB5C[12 * i],
          dword_841FB60[12 * i],
          dword_841FB64[12 * i],
          dword_841FB68[12 * i],
          dword_841FB6C[12 * i],
          aError_2);
        memset((void *)(48 * i + 138541916), 0, 0x30u);
      }
      else if ( !dword_841FB84[12 * i] )
      {
        goto LABEL_11;
      }
      return;
    }
    if ( I_stricmp(v10, "deny") )
    {
      if ( v9 && *v9 )
      {
        sprintf(s, "error\n%s", v9);
        NET_OutOfBandPrint(
          1,
          dword_841FB5C[12 * i],
          dword_841FB60[12 * i],
          dword_841FB64[12 * i],
          dword_841FB68[12 * i],
          dword_841FB6C[12 * i],
          s);
      }
      else
      {
        NET_OutOfBandPrint(
          1,
          dword_841FB5C[12 * i],
          dword_841FB60[12 * i],
          dword_841FB64[12 * i],
          dword_841FB68[12 * i],
          dword_841FB6C[12 * i],
          "error\nEXE_ERR_BAD_CDKEY");
      }
      memset((void *)(48 * i + 138541916), 0, 0x30u);
      return;
    }
    if ( v9 && *v9 )
    {
      if ( !I_stricmp(v9, "CLIENT_UNKNOWN_TO_AUTH") || !I_stricmp(v9, "BAD_CDKEY") )
      {
        NET_OutOfBandPrint(
          1,
          dword_841FB5C[12 * i],
          dword_841FB60[12 * i],
          dword_841FB64[12 * i],
          dword_841FB68[12 * i],
          dword_841FB6C[12 * i],
          "needcdkey");
LABEL_30:
        memset((void *)(48 * i + 138541916), 0, 0x30u);
        return;
      }
      if ( I_stricmp(v9, "INVALID_CDKEY") )
      {
        I_stricmp(v9, "BANNED_CDKEY");
        NET_OutOfBandPrint(
          1,
          dword_841FB5C[12 * i],
          dword_841FB60[12 * i],
          dword_841FB64[12 * i],
          dword_841FB68[12 * i],
          dword_841FB6C[12 * i],
          "error\nEXE_ERR_BAD_CDKEY");
        goto LABEL_30;
      }
    }
    NET_OutOfBandPrint(
      1,
      dword_841FB5C[12 * i],
      dword_841FB60[12 * i],
      dword_841FB64[12 * i],
      dword_841FB68[12 * i],
      dword_841FB6C[12 * i],
      "error\nEXE_ERR_CDKEY_IN_USE");
    goto LABEL_30;
  }
  if ( (unsigned __int8)Dvar_GetBool("fs_restrict") )
  {
LABEL_11:
    v6 = va("challengeResponse %i", dword_841FB70[12 * i]);
    NET_OutOfBandPrint(
      1,
      dword_841FB5C[12 * i],
      dword_841FB60[12 * i],
      dword_841FB64[12 * i],
      dword_841FB68[12 * i],
      dword_841FB6C[12 * i],
      v6);
    return;
  }
  NET_OutOfBandPrint(
    1,
    dword_841FB5C[12 * i],
    dword_841FB60[12 * i],
    dword_841FB64[12 * i],
    dword_841FB68[12 * i],
    dword_841FB6C[12 * i],
    "error\nEXE_ERR_NOT_A_DEMO_SERVER");
  memset((void *)(48 * i + 138541916), 0, 0x30u);
}
// 841FB5C: using guessed type int dword_841FB5C[];
// 841FB60: using guessed type int dword_841FB60[];
// 841FB64: using guessed type int dword_841FB64[];
// 841FB68: using guessed type int dword_841FB68[];
// 841FB6C: using guessed type int dword_841FB6C[];
// 841FB70: using guessed type int dword_841FB70[];
// 841FB78: using guessed type int dword_841FB78[];
// 841FB84: using guessed type int dword_841FB84[];
// 841FB88: using guessed type int dword_841FB88[1343];
// 808C7CA: using guessed type int arg_4;

//----- (0808D026) --------------------------------------------------------
int __usercall sub_808D026@<eax>(long double a1@<st0>, int a2)
{
  sub_808E2BE(a2);
  if ( sub_809215C() )
    ClientDisconnect(a1, -1653759219 * ((a2 - (int)dword_841FB0C) >> 2));
  sub_8091246(-1653759219 * ((a2 - (int)dword_841FB0C) >> 2), (char *)&byte_814309B);
  return sub_8094586(a2);
}

//----- (0808D08E) --------------------------------------------------------
void __usercall SV_FreeClients(long double a1@<st0>)
{
  int *v1; // [esp+10h] [ebp-8h]
  int v2; // [esp+14h] [ebp-4h]

  v2 = 0;
  v1 = (int *)dword_841FB0C;
  while ( v2 < *(_DWORD *)(sv_maxclients + 8) )
  {
    if ( *v1 > 1 )
      sub_808D026(a1, (int)v1);
    ++v2;
    v1 += 123845;
  }
  Z_VirtualFreeInternal(dword_841FB0C);
}
// 848B1CC: using guessed type int sv_maxclients;

//----- (0808D0E6) --------------------------------------------------------
void __usercall SV_DirectConnect(long double a1@<st0>, void *a2, void *a3, void *a4, void *a5, void *a6)
{
  char *v6; // eax
  char *v7; // eax
  char *v8; // eax
  char *v9; // eax
  char *v10; // eax
  char *v11; // eax
  char *v12; // eax
  char *v13; // eax
  char *v14; // eax
  char v15; // [esp+36h] [ebp-442h]
  char v16; // [esp+37h] [ebp-441h]
  int v17; // [esp+38h] [ebp-440h]
  int v18; // [esp+3Ch] [ebp-43Ch]
  const char *v19; // [esp+40h] [ebp-438h]
  int v20; // [esp+44h] [ebp-434h]
  const char *s1; // [esp+48h] [ebp-430h]
  int v22; // [esp+4Ch] [ebp-42Ch]
  void *v23; // [esp+50h] [ebp-428h]
  int v24; // [esp+54h] [ebp-424h]
  int v25; // [esp+58h] [ebp-420h]
  _DWORD *s; // [esp+60h] [ebp-418h]
  _DWORD *v27; // [esp+64h] [ebp-414h]
  _DWORD *v28; // [esp+64h] [ebp-414h]
  char *v29; // [esp+64h] [ebp-414h]
  int v30; // [esp+68h] [ebp-410h]
  int v31; // [esp+6Ch] [ebp-40Ch]
  int i; // [esp+6Ch] [ebp-40Ch]
  int j; // [esp+6Ch] [ebp-40Ch]
  int v34; // [esp+6Ch] [ebp-40Ch]
  char dest[1032]; // [esp+70h] [ebp-408h] BYREF

  Com_DPrintf("SV_DirectConnect()\n");
  v6 = SV_Cmd_Argv(1u);
  I_strncpyz(dest, v6, 1024);
  v7 = Info_ValueForKey(dest, "protocol");
  v24 = atoi(v7);
  if ( v24 != 115 )
  {
    v8 = va(aErrorExeServer_0, "1.0");
    NET_OutOfBandPrint(1, (int)a2, (int)a3, (int)a4, (int)a5, (int)a6, v8);
    Com_DPrintf("    rejected connect from protocol version %i (should be %i)\n", v24, 115);
    return;
  }
  v9 = Info_ValueForKey(dest, "challenge");
  v22 = atoi(v9);
  v10 = Info_ValueForKey(dest, "qport");
  v23 = (void *)atoi(v10);
  v31 = 0;
  v27 = dword_841FB0C;
  while ( v31 < *(_DWORD *)(sv_maxclients + 8) )
  {
    v16 = 0;
    if ( NET_CompareBaseAdr((char)a2, (int)a3, (int)a4, (int)a5, (int)a6, v27[113009])
      && ((void *)v27[113014] == v23 || (_WORD)a4 == *((_WORD *)v27 + 226022)) )
    {
      v16 = 1;
    }
    if ( v16 )
    {
      if ( dword_841FB04 - v27[33605] < 1000 * *(_DWORD *)(sv_reconnectlimit + 8) )
      {
        v11 = NET_AdrToString((int)a2, (int)a3, (int)a4, (int)a5, (int)a6);
        Com_DPrintf("%s:reconnect rejected : too soon\n", v11);
        return;
      }
      break;
    }
    ++v31;
    v27 += 123845;
  }
  v30 = 0;
  if ( NET_IsLocalAddress((int)a2) )
    goto LABEL_32;
  for ( i = 0; i <= 1023; ++i )
  {
    if ( NET_CompareAdr((char)a2, (int)a3, (int)a4, (int)a5, (int)a6, dword_841FB5C[12 * i])
      && v22 == dword_841FB70[12 * i] )
    {
      v30 = dword_841FB88[12 * i];
      break;
    }
  }
  if ( i == 1024 )
  {
    NET_OutOfBandPrint(1, (int)a2, (int)a3, (int)a4, (int)a5, (int)a6, "error\nEXE_BAD_CHALLENGE");
    return;
  }
  if ( dword_841FB80[12 * i] )
  {
    v17 = dword_841FB80[12 * i];
  }
  else
  {
    v17 = dword_841FB04 - dword_841FB78[12 * i];
    dword_841FB80[12 * i] = v17;
  }
  v12 = NET_AdrToString((int)a2, (int)a3, (int)a4, (int)a5, (int)a6);
  Com_Printf("Client %i connecting with %i challenge ping from %s\n", i, v17, v12);
  dword_841FB84[12 * i] = 1;
  if ( Sys_IsLANAddress((int)a2, (int)a3) )
    goto LABEL_32;
  if ( *(_DWORD *)(sv_minPing + 8) && v17 < *(_DWORD *)(sv_minPing + 8) )
  {
    NET_OutOfBandPrint(1, (int)a2, (int)a3, (int)a4, (int)a5, (int)a6, "error\nEXE_ERR_HIGH_PING_ONLY");
    Com_DPrintf("Client %i rejected on a too low ping\n", i);
    return;
  }
  if ( !*(_DWORD *)(sv_maxPing + 8) || v17 <= *(_DWORD *)(sv_maxPing + 8) )
  {
LABEL_32:
    j = 0;
    v28 = dword_841FB0C;
    while ( j < *(_DWORD *)(sv_maxclients + 8) )
    {
      if ( *v28 )
      {
        v15 = 0;
        if ( NET_CompareBaseAdr((char)a2, (int)a3, (int)a4, (int)a5, (int)a6, v28[113009])
          && ((void *)v28[113014] == v23 || (_WORD)a4 == *((_WORD *)v28 + 226022)) )
        {
          v15 = 1;
        }
        if ( v15 )
        {
          v13 = NET_AdrToString((int)a2, (int)a3, (int)a4, (int)a5, (int)a6);
          Com_Printf("%s:reconnect\n", v13);
          if ( (int)*v28 > 1 )
            sub_808D026(a1, (int)v28);
          s = v28;
          memset(v28, 0, 0x78F14u);
          goto LABEL_55;
        }
      }
      ++j;
      v28 += 123845;
    }
    s1 = Info_ValueForKey(dest, "password");
    if ( !strcmp(s1, *(const char **)(sv_privatePassword + 8)) )
      v20 = 0;
    else
      v20 = *(_DWORD *)(sv_privateClients + 8);
    s = 0;
    for ( j = v20; j < *(_DWORD *)(sv_maxclients + 8); ++j )
    {
      v28 = (char *)dword_841FB0C + 495380 * j;
      if ( !*v28 )
      {
        s = (char *)dword_841FB0C + 495380 * j;
        break;
      }
    }
    if ( !s )
    {
      NET_OutOfBandPrint(1, (int)a2, (int)a3, (int)a4, (int)a5, (int)a6, "error\nEXE_SERVERISFULL");
      Com_DPrintf("Rejected a connection.\n");
      return;
    }
    v28[33284] = 0;
    v28[33283] = 0;
    memset(s, 0, 0x78F14u);
LABEL_55:
    v25 = -1653759219 * (((char *)s - (_BYTE *)dword_841FB0C) >> 2);
    s[33553] = SV_GentityNum(v25);
    *((_WORD *)s + 242428) = sub_807B658();
    s[33288] = v22;
    s[121213] = v30;
    sub_806B510((void *)1, (void **)s + 113005, a2, a3, a4, a5, a6, v23);
    s[123827] = 0;
    *((_BYTE *)s + 495376) = 1;
    I_strncpyz((char *)s + 12, dest, 1024);
    v19 = ClientConnect(a1, v25, *((_WORD *)s + 242428));
    if ( v19 )
    {
      v14 = va("error\n%s", v19);
      NET_OutOfBandPrint(1, (int)a2, (int)a3, (int)a4, (int)a5, (int)a6, v14);
      Com_DPrintf("Game rejected a connection: %s.\n", v19);
      sub_8094586((int)s);
    }
    else
    {
      Com_Printf(
        "Going from CS_FREE to CS_CONNECTED for %s (num %i guid %i)\n",
        (const char *)s + 134216,
        v25,
        s[121213]);
      *s = 2;
      s[33606] = dword_841FB04;
      s[33604] = dword_841FB04;
      s[33605] = dword_841FB04;
      sub_808EEFE((int)s);
      dword_841FB80[12 * j] = 0;
      NET_OutOfBandPrint(1, (int)a2, (int)a3, (int)a4, (int)a5, (int)a6, "connectResponse");
      s[33287] = -1;
      v18 = 0;
      v34 = 0;
      v29 = (char *)dword_841FB0C;
      while ( v34 < *(_DWORD *)(sv_maxclients + 8) )
      {
        if ( *((int *)dword_841FB0C + 123845 * v34) > 1 )
          ++v18;
        ++v34;
        v29 += 495380;
      }
      if ( v18 == 1 || v18 == *(_DWORD *)(sv_maxclients + 8) )
        sub_808BACE();
    }
  }
  else
  {
    NET_OutOfBandPrint(1, (int)a2, (int)a3, (int)a4, (int)a5, (int)a6, "error\nEXE_ERR_LOW_PING_ONLY");
    Com_DPrintf("Client %i rejected on a too high ping: %i\n", i, v17);
  }
}
// 841FB5C: using guessed type int dword_841FB5C[];
// 841FB70: using guessed type int dword_841FB70[];
// 841FB78: using guessed type int dword_841FB78[];
// 841FB80: using guessed type int dword_841FB80[];
// 841FB84: using guessed type int dword_841FB84[];
// 841FB88: using guessed type int dword_841FB88[1343];
// 848B1C4: using guessed type int sv_privatePassword;
// 848B1CC: using guessed type int sv_maxclients;
// 848B1D0: using guessed type int sv_privateClients;
// 848B1D8: using guessed type int sv_reconnectlimit;
// 848B1EC: using guessed type int sv_minPing;
// 848B1F0: using guessed type int sv_maxPing;
// 808D0E6: using guessed type void *arg_0;
// 808D0E6: using guessed type void *arg_8;

//----- (0808DC2C) --------------------------------------------------------
int sub_808DC2C()
{
  int result; // eax
  int *i; // [esp+Ch] [ebp-Ch]
  int v2; // [esp+10h] [ebp-8h]

  v2 = 0;
  for ( i = (int *)dword_841FB0C; ; i += 123845 )
  {
    result = v2;
    if ( v2 >= *(_DWORD *)(sv_maxclients + 8) )
      break;
    if ( *i > 1 )
    {
      sub_8094586((int)i);
      *((_WORD *)i + 242428) = sub_807B658();
    }
    ++v2;
  }
  return result;
}
// 848B1CC: using guessed type int sv_maxclients;

//----- (0808DC8C) --------------------------------------------------------
void __usercall SV_DropClient(long double a1@<st0>, int a2, char *a3)
{
  int *v3; // [esp+30h] [ebp-8h]
  int i; // [esp+34h] [ebp-4h]
  int j; // [esp+34h] [ebp-4h]

  if ( *(_DWORD *)a2 != 1 )
  {
    *(_DWORD *)(a2 + 8) = 0;
    sub_808D026(a1, a2);
    Com_DPrintf("Going to CS_ZOMBIE for %s\n", (const char *)(a2 + 134216));
    *(_DWORD *)a2 = 1;
    if ( !*(_DWORD *)(a2 + 134212) )
    {
      v3 = &dword_841FB5C;
      for ( i = 0; i <= 1023; ++i )
      {
        if ( NET_CompareAdr(
               *(_DWORD *)(a2 + 452036),
               *(_DWORD *)(a2 + 452040),
               *(_DWORD *)(a2 + 452044),
               *(_DWORD *)(a2 + 452048),
               *(_DWORD *)(a2 + 452052),
               *v3) )
        {
          v3[10] = 0;
          break;
        }
        v3 += 12;
      }
    }
    if ( I_stricmp(a3, "EXE_DISCONNECTED") )
      SV_SendServerCommand(0, 0, aC_3, 101, a2 + 134216, a3);
    Com_Printf("%i:%s %s\n", -1653759219 * ((a2 - (int)dword_841FB0C) >> 2), (const char *)(a2 + 134216), a3);
    SV_SendServerCommand(0, 1, "%c %d", 74, -1653759219 * ((a2 - (int)dword_841FB0C) >> 2));
    SV_SendServerCommand((_DWORD *)a2, 1, "%c \"%s\"", 119, a3);
    for ( j = 0; j < *(_DWORD *)(sv_maxclients + 8) && *((int *)dword_841FB0C + 123845 * j) <= 1; ++j )
      ;
    if ( j == *(_DWORD *)(sv_maxclients + 8) )
      sub_808BACE();
  }
}
// 841FB5C: using guessed type int dword_841FB5C;
// 848B1CC: using guessed type int sv_maxclients;

//----- (0808DEA6) --------------------------------------------------------
_DWORD *__cdecl sub_808DEA6(_DWORD *a1, _DWORD *a2)
{
  _DWORD *result; // eax

  result = a1;
  if ( *a1 != 1 )
  {
    result = a1;
    if ( !a1[2] )
    {
      result = a2;
      a1[2] = a2;
    }
  }
  return result;
}

//----- (0808DECA) --------------------------------------------------------
int __usercall sub_808DECA@<eax>(long double a1@<st0>, int a2)
{
  char *v3; // [esp+1Ch] [ebp-13Ch]
  int v4[4]; // [esp+20h] [ebp-138h] BYREF
  int v5[3]; // [esp+30h] [ebp-128h] BYREF
  _DWORD v6[5]; // [esp+3Ch] [ebp-11Ch]
  int s[62]; // [esp+50h] [ebp-108h] BYREF
  int *v8; // [esp+148h] [ebp-10h]
  int i; // [esp+14Ch] [ebp-Ch]

  LargeLocal(v4, 0x4000);
  v3 = LargeLocalGetBuf(v4);
  while ( *(_DWORD *)a2 && *(_DWORD *)(a2 + 468452) )
    SV_Netchan_TransmitNextFragment(a2 + 452020);
  Com_DPrintf("SV_SendClientGameState() for %s\n", (const char *)(a2 + 134216));
  Com_DPrintf("Going from CS_CONNECTED to CS_PRIMED for %s\n", (const char *)(a2 + 134216));
  *(_DWORD *)a2 = 3;
  *(_DWORD *)(a2 + 452016) = 0;
  *(_DWORD *)(a2 + 133148) = *(_DWORD *)(a2 + 452020);
  MSG_Init(v5, (int)v3, 0x4000);
  MSG_WriteLong(v5, *(_DWORD *)(a2 + 133184));
  SV_UpdateServerCommandsToClient(a2, v5);
  MSG_WriteByte(v5, 1);
  MSG_WriteLong(v5, *(_DWORD *)(a2 + 133132));
  for ( i = 0; i <= 2047; ++i )
  {
    if ( *(&dword_842C098)[i] )
    {
      MSG_WriteByte(v5, 2);
      MSG_WriteShort(v5, i);
      MSG_WriteBigString(v5, (&dword_842C098)[i]);
    }
  }
  memset(s, 0, 0xF0u);
  for ( i = 0; i <= 1023; ++i )
  {
    v8 = (int *)(372 * i + 138600604);
    if ( *((_DWORD *)&unk_842E09C + 93 * i) )
    {
      MSG_WriteByte(v5, 3);
      MSG_WriteDeltaEntity(v5, s, v8, 1);
    }
  }
  MSG_WriteByte(v5, 7);
  MSG_WriteLong(v5, -1653759219 * ((a2 - (int)dword_841FB0C) >> 2));
  MSG_WriteLong(v5, dword_842BC8C);
  MSG_WriteByte(v5, 7);
  Com_DPrintf("Sending %i bytes in gamestate to client: %i\n", v6[0], -1653759219 * ((a2 - (int)dword_841FB0C) >> 2));
  SV_SendMessageToClient(a1, (int)v5, a2);
  return LargeLocalDealloc(v4);
}
// 842BC8C: using guessed type int dword_842BC8C;
// 808DECA: using guessed type int var_138[4];
// 808DECA: using guessed type int s[62];
// 808DECA: using guessed type _DWORD var_11C[5];

//----- (0808E1F0) --------------------------------------------------------
int __cdecl sub_808E1F0(int a1, _DWORD *a2)
{
  int *v3; // [esp+10h] [ebp-8h]
  int v4; // [esp+14h] [ebp-4h]

  Com_DPrintf("Going from CS_PRIMED to CS_ACTIVE for %s\n", (const char *)(a1 + 134216));
  *(_DWORD *)a1 = 4;
  v4 = -1653759219 * ((a1 - (int)dword_841FB0C) >> 2);
  v3 = (int *)SV_GentityNum(v4);
  *v3 = v4;
  *(_DWORD *)(a1 + 134212) = v3;
  *(_DWORD *)(a1 + 134408) = -1;
  *(_DWORD *)(a1 + 134424) = dword_841FB04;
  *(_DWORD *)(a1 + 133156) = *a2;
  *(_DWORD *)(a1 + 133160) = a2[1];
  *(_DWORD *)(a1 + 133164) = a2[2];
  *(_DWORD *)(a1 + 133168) = a2[3];
  *(_DWORD *)(a1 + 133172) = a2[4];
  *(_DWORD *)(a1 + 133176) = a2[5];
  *(_DWORD *)(a1 + 133180) = a2[6];
  return sub_80F6954(-1653759219 * ((a1 - (int)dword_841FB0C) >> 2));
}

//----- (0808E2BE) --------------------------------------------------------
int *__cdecl sub_808E2BE(int a1)
{
  int *result; // eax
  int i; // [esp+4h] [ebp-4h] BYREF

  if ( *(_DWORD *)(a1 + 134312) )
    FS_FCloseFile(*(_DWORD *)(a1 + 134312));
  *(_DWORD *)(a1 + 134312) = 0;
  result = (int *)(a1 + 134248);
  *(_BYTE *)(a1 + 134248) = 0;
  for ( i = 0; i <= 7; ++i )
  {
    if ( *(_DWORD *)(a1 + 4 * i + 134336) )
    {
      Z_FreeInternal(*(void **)(a1 + 4 * i + 134336));
      *(_DWORD *)(a1 + 4 * i + 134336) = 0;
    }
    result = &i;
  }
  return result;
}

//----- (0808E348) --------------------------------------------------------
int *__cdecl sub_808E348(int a1)
{
  if ( *(_BYTE *)(a1 + 134248) )
    Com_DPrintf(
      "clientDownload: %d : file \"%s\" aborted\n",
      -1653759219 * ((a1 - (int)dword_841FB0C) >> 2),
      (const char *)(a1 + 134248));
  return sub_808E2BE(a1);
}

//----- (0808E398) --------------------------------------------------------
int __usercall sub_808E398@<eax>(long double a1@<st0>, int a2)
{
  Com_DPrintf("clientDownload: %s Done\n", (const char *)(a2 + 134216));
  return sub_808DECA(a1, a2);
}

//----- (0808E3C4) --------------------------------------------------------
int __cdecl sub_808E3C4(int a1)
{
  char *v1; // eax
  int result; // eax

  v1 = SV_Cmd_Argv(1u);
  result = atoi(v1);
  if ( result == *(_DWORD *)(a1 + 134324) )
  {
    result = a1;
    *(_DWORD *)(a1 + 134332) = *(_DWORD *)(a1 + 134324);
  }
  return result;
}

//----- (0808E404) --------------------------------------------------------
void __usercall sub_808E404(long double a1@<st0>, int a2)
{
  char *v2; // eax
  int v3; // [esp+24h] [ebp-4h]

  v2 = SV_Cmd_Argv(1u);
  v3 = atoi(v2);
  if ( v3 == *(_DWORD *)(a2 + 134324) )
  {
    Com_DPrintf(
      "clientDownload: %d : client acknowledge of block %d\n",
      -1653759219 * ((a2 - (int)dword_841FB0C) >> 2),
      v3);
    if ( *(_DWORD *)(a2 + 4 * (*(_DWORD *)(a2 + 134324) % 8) + 134368) )
    {
      *(_DWORD *)(a2 + 134404) = dword_841FB04;
      ++*(_DWORD *)(a2 + 134324);
    }
    else
    {
      Com_Printf(
        "clientDownload: %d : file \"%s\" completed\n",
        -1653759219 * ((a2 - (int)dword_841FB0C) >> 2),
        (const char *)(a2 + 134248));
      sub_808E2BE(a2);
    }
  }
  else
  {
    SV_DropClient(a1, a2, "broken download");
  }
}

//----- (0808E508) --------------------------------------------------------
char *__cdecl sub_808E508(int a1)
{
  char *v1; // eax

  sub_808E2BE(a1);
  v1 = SV_Cmd_Argv(1u);
  return I_strncpyz((char *)(a1 + 134248), v1, 64);
}

//----- (0808E544) --------------------------------------------------------
int __cdecl SV_WriteDownloadToClient(int a1, _DWORD *a2)
{
  int result; // eax
  int v3; // [esp+2Ch] [ebp-41Ch]
  char s[1024]; // [esp+30h] [ebp-418h] BYREF
  int v5; // [esp+430h] [ebp-18h]
  int v6; // [esp+434h] [ebp-14h] BYREF
  int v7; // [esp+438h] [ebp-10h]
  int v8; // [esp+43Ch] [ebp-Ch]

  result = a1 + 134248;
  if ( *(_BYTE *)(a1 + 134248) )
  {
    if ( *(_DWORD *)(a1 + 134312) )
    {
LABEL_15:
      while ( *(_DWORD *)(a1 + 134328) - *(_DWORD *)(a1 + 134324) <= 7
           && *(_DWORD *)(a1 + 134316) != *(_DWORD *)(a1 + 134320) )
      {
        v3 = *(_DWORD *)(a1 + 134328);
        v8 = v3 % 8;
        if ( !*(_DWORD *)(a1 + 4 * (v3 % 8) + 134336) )
          *(_DWORD *)(a1 + 4 * v8 + 134336) = Z_MallocInternal(0x800u);
        *(_DWORD *)(a1 + 4 * v8 + 134368) = FS_Read(
                                              *(_DWORD *)(a1 + 4 * v8 + 134336),
                                              0x800u,
                                              *(_DWORD *)(a1 + 134312));
        if ( *(int *)(a1 + 4 * v8 + 134368) < 0 )
        {
          *(_DWORD *)(a1 + 134320) = *(_DWORD *)(a1 + 134316);
          break;
        }
        *(_DWORD *)(a1 + 134320) += *(_DWORD *)(a1 + 4 * v8 + 134368);
        ++*(_DWORD *)(a1 + 134328);
      }
      if ( *(_DWORD *)(a1 + 134320) == *(_DWORD *)(a1 + 134316)
        && !*(_DWORD *)(a1 + 134400)
        && *(_DWORD *)(a1 + 134328) - *(_DWORD *)(a1 + 134324) <= 7 )
      {
        *(_DWORD *)(a1 + 4 * ((*(_DWORD *)(a1 + 134328))++ % 8) + 134368) = 0;
        *(_DWORD *)(a1 + 134400) = 1;
      }
      v7 = *(_DWORD *)(a1 + 452008);
      if ( *(_DWORD *)(sv_maxRate + 8) )
      {
        if ( *(int *)(sv_maxRate + 8) <= 999 )
          Dvar_SetInt(sv_maxRate, (char *)0x3E8);
        if ( *(_DWORD *)(sv_maxRate + 8) < v7 )
          v7 = *(_DWORD *)(sv_maxRate + 8);
      }
      if ( v7 )
        v6 = (*(_DWORD *)(a1 + 452012) * v7 / 1000 + 2048) / 2048;
      else
        v6 = 1;
      if ( v6 < 0 )
        v6 = 1;
      while ( 1 )
      {
        result = (int)&v6;
        if ( --v6 == -1 )
          break;
        result = *(_DWORD *)(a1 + 134324);
        if ( result == *(_DWORD *)(a1 + 134328) )
          break;
        if ( *(_DWORD *)(a1 + 134332) == *(_DWORD *)(a1 + 134328) )
        {
          result = dword_841FB04 - *(_DWORD *)(a1 + 134404);
          if ( result <= 1000 )
            return result;
          *(_DWORD *)(a1 + 134332) = *(_DWORD *)(a1 + 134324);
        }
        v8 = *(_DWORD *)(a1 + 134332) % 8;
        MSG_WriteByte(a2, 5);
        MSG_WriteShort(a2, *(_DWORD *)(a1 + 134332));
        if ( !*(_DWORD *)(a1 + 134332) )
          MSG_WriteLong(a2, *(_DWORD *)(a1 + 134316));
        MSG_WriteShort(a2, *(_DWORD *)(a1 + 4 * v8 + 134368));
        if ( *(_DWORD *)(a1 + 4 * v8 + 134368) )
          MSG_WriteData(a2, *(void **)(a1 + 4 * v8 + 134336), *(_DWORD *)(a1 + 4 * v8 + 134368));
        Com_DPrintf(
          "clientDownload: %d : writing block %d\n",
          -1653759219 * ((a1 - (int)dword_841FB0C) >> 2),
          *(_DWORD *)(a1 + 134332));
        ++*(_DWORD *)(a1 + 134332);
        *(_DWORD *)(a1 + 134404) = dword_841FB04;
      }
    }
    else
    {
      Com_Printf(
        "clientDownload: %d : begining \"%s\"\n",
        -1653759219 * ((a1 - (int)dword_841FB0C) >> 2),
        (const char *)(a1 + 134248));
      v5 = FS_iwIwd((char *)(a1 + 134248), "main");
      if ( *(_BYTE *)(sv_allowDownload + 8) )
      {
        if ( !v5 )
        {
          *(_DWORD *)(a1 + 134316) = FS_SV_FOpenFileRead((char *)(a1 + 134248), (_DWORD *)(a1 + 134312));
          if ( *(int *)(a1 + 134316) > 0 )
          {
            *(_DWORD *)(a1 + 134332) = 0;
            *(_DWORD *)(a1 + 134324) = 0;
            *(_DWORD *)(a1 + 134328) = 0;
            *(_DWORD *)(a1 + 134320) = 0;
            *(_DWORD *)(a1 + 134400) = 0;
            goto LABEL_15;
          }
        }
      }
      if ( v5 )
      {
        Com_Printf(
          "clientDownload: %d : \"%s\" cannot download iwd files\n",
          -1653759219 * ((a1 - (int)dword_841FB0C) >> 2),
          (const char *)(a1 + 134248));
        Com_sprintf(s, 0x400u, aExeCantautodlg, a1 + 134248);
      }
      else if ( *(_BYTE *)(sv_allowDownload + 8) )
      {
        Com_Printf(
          "clientDownload: %d : \"%s\" file not found on server\n",
          -1653759219 * ((a1 - (int)dword_841FB0C) >> 2),
          (const char *)(a1 + 134248));
        Com_sprintf(s, 0x400u, aExeAutodlFilen, a1 + 134248);
      }
      else
      {
        Com_Printf(
          "clientDownload: %d : \"%s\" download disabled",
          -1653759219 * ((a1 - (int)dword_841FB0C) >> 2),
          (const char *)(a1 + 134248));
        if ( *(_BYTE *)(sv_pure + 8) )
          Com_sprintf(s, 0x400u, aExeAutodlServe, a1 + 134248);
        else
          Com_sprintf(s, 0x400u, aExeAutodlServe_0, a1 + 134248);
      }
      MSG_WriteByte(a2, 5);
      MSG_WriteShort(a2, 0);
      MSG_WriteLong(a2, -1);
      MSG_WriteString(a2, s);
      result = a1 + 134248;
      *(_BYTE *)(a1 + 134248) = 0;
    }
  }
  return result;
}
// 848B1C8: using guessed type int sv_allowDownload;
// 848B1E8: using guessed type int sv_maxRate;
// 848B200: using guessed type int sv_pure;

//----- (0808EC4A) --------------------------------------------------------
void __usercall sub_808EC4A(long double a1@<st0>, int a2)
{
  SV_DropClient(a1, a2, "EXE_DISCONNECTED");
}

//----- (0808EC66) --------------------------------------------------------
int __cdecl SV_VerifyIwds_f(int a1)
{
  signed int v1; // ebx
  char *v2; // eax
  signed int v3; // ebx
  char *v4; // eax
  int result; // eax
  unsigned int v6; // [esp+0h] [ebp-2048h]
  unsigned int v7; // [esp+0h] [ebp-2048h]
  int v8; // [esp+14h] [ebp-2034h]
  char *v9; // [esp+1Ch] [ebp-202Ch]
  int v10[2049]; // [esp+20h] [ebp-2028h]
  int v11; // [esp+2024h] [ebp-24h]
  int j; // [esp+2028h] [ebp-20h]
  signed int i; // [esp+202Ch] [ebp-1Ch]
  int v14; // [esp+2030h] [ebp-18h]
  int v15; // [esp+2034h] [ebp-14h]
  int v16; // [esp+2038h] [ebp-10h]
  int v17; // [esp+203Ch] [ebp-Ch]

  v8 = 1;
  v16 = 0;
  v17 = 0;
  v15 = SV_Cmd_Argc();
  v11 = 1;
  if ( v15 > 1 )
  {
    v6 = v11++;
    if ( *SV_Cmd_Argv(v6) == 64 )
    {
      i = 0;
      while ( v11 < v15 )
      {
        v1 = i;
        v7 = v11++;
        v2 = SV_Cmd_Argv(v7);
        v10[v1 + 1024] = atoi(v2);
        ++i;
      }
      v15 = i - 1;
      for ( i = 0; i < v15; ++i )
      {
        for ( j = 0; j < v15; ++j )
        {
          if ( i != j && v10[i + 1024] == v10[j + 1024] )
          {
            v8 = 0;
            break;
          }
        }
        if ( !v8 )
          break;
      }
      if ( v8 )
      {
        v9 = FS_LoadedIwdPureChecksums();
        SV_Cmd_TokenizeString(v9);
        v14 = SV_Cmd_Argc();
        if ( v14 > 1024 )
          v14 = 1024;
        for ( i = 0; i < v14; ++i )
        {
          v3 = i;
          v4 = SV_Cmd_Argv(i);
          v10[v3] = atoi(v4);
        }
        for ( i = 0; i < v15; ++i )
        {
          for ( j = 0; j < v14 && v10[i + 1024] != v10[j]; ++j )
            ;
          if ( j >= v14 )
          {
            v8 = 0;
            break;
          }
        }
        if ( v8 )
        {
          v17 = dword_842BC8C;
          for ( i = 0; i < v15; ++i )
            v17 ^= v10[i + 1024];
          v17 ^= v15;
          if ( v17 != v10[v15 + 1024] )
            v8 = 0;
        }
      }
    }
    else
    {
      v8 = 0;
    }
  }
  else
  {
    v8 = 0;
  }
  result = a1;
  if ( v8 )
    *(_DWORD *)(a1 + 452016) = 1;
  else
    *(_DWORD *)(a1 + 452016) = 2;
  return result;
}
// 808EC9E: conditional instruction was optimized away because %var_2034.4==1
// 842BC8C: using guessed type int dword_842BC8C;

//----- (0808EEEC) --------------------------------------------------------
int __cdecl SV_ResetPureClient_f(int a1)
{
  int result; // eax

  result = a1;
  *(_DWORD *)(a1 + 452016) = 0;
  return result;
}

//----- (0808EEFE) --------------------------------------------------------
int __cdecl sub_808EEFE(int a1)
{
  char *v1; // eax
  int result; // eax
  char v3; // [esp+1Bh] [ebp-Dh]
  int v4; // [esp+1Ch] [ebp-Ch]
  const char *nptr; // [esp+20h] [ebp-8h]
  const char *nptra; // [esp+20h] [ebp-8h]
  const char *nptrb; // [esp+20h] [ebp-8h]

  v1 = Info_ValueForKey((char *)(a1 + 12), "name");
  I_strncpyz((char *)(a1 + 134216), v1, 32);
  v3 = 0;
  if ( Sys_IsLANAddress(*(_DWORD *)(a1 + 452036), *(_DWORD *)(a1 + 452040)) && *(_DWORD *)(com_dedicated + 8) != 2 )
    v3 = 1;
  if ( v3 )
  {
    *(_DWORD *)(a1 + 452008) = 99999;
  }
  else
  {
    nptr = Info_ValueForKey((char *)(a1 + 12), "rate");
    if ( *nptr )
    {
      *(_DWORD *)(a1 + 452008) = atoi(nptr);
      if ( *(int *)(a1 + 452008) > 999 )
      {
        if ( *(int *)(a1 + 452008) > 90000 )
          *(_DWORD *)(a1 + 452008) = 90000;
      }
      else
      {
        *(_DWORD *)(a1 + 452008) = 1000;
      }
    }
    else
    {
      *(_DWORD *)(a1 + 452008) = 5000;
    }
  }
  nptra = Info_ValueForKey((char *)(a1 + 12), "snaps");
  if ( *nptra )
  {
    v4 = atoi(nptra);
    if ( v4 > 0 )
    {
      if ( v4 > 30 )
        v4 = 30;
    }
    else
    {
      v4 = 1;
    }
    *(_DWORD *)(a1 + 452012) = 1000 / v4;
  }
  else
  {
    *(_DWORD *)(a1 + 452012) = 50;
  }
  nptrb = Info_ValueForKey((char *)(a1 + 12), "cl_voice");
  *(_BYTE *)(a1 + 495376) = atoi(nptrb) > 0;
  result = a1;
  if ( *(int *)(a1 + 452008) <= 4999 )
  {
    result = a1;
    *(_BYTE *)(a1 + 495376) = 0;
  }
  return result;
}
// 8494204: using guessed type int com_dedicated;

//----- (0808F0E6) --------------------------------------------------------
int __cdecl sub_808F0E6(int a1)
{
  char *v1; // eax

  v1 = SV_Cmd_Argv(1u);
  I_strncpyz((char *)(a1 + 12), v1, 1024);
  sub_808EEFE(a1);
  return ClientUserinfoChanged(-1653759219 * ((a1 - (int)dword_841FB0C) >> 2));
}

//----- (0808F13C) --------------------------------------------------------
void __cdecl sub_808F13C(int a1)
{
  char *v1; // eax
  unsigned int v2; // [esp+14h] [ebp-4h]

  v1 = SV_Cmd_Argv(1u);
  v2 = atoi(v1);
  if ( v2 < 0x41 )
    *(_BYTE *)(v2 + a1 + 495312) = 1;
  else
    Com_Printf("Invalid mute client %i\n", v2);
}

//----- (0808F18C) --------------------------------------------------------
void __cdecl sub_808F18C(int a1)
{
  char *v1; // eax
  unsigned int v2; // [esp+14h] [ebp-4h]

  v1 = SV_Cmd_Argv(1u);
  v2 = atoi(v1);
  if ( v2 < 0x41 )
    *(_BYTE *)(v2 + a1 + 495312) = 0;
  else
    Com_Printf("Invalid unmute client %i\n", v2);
}

//----- (0808F1DC) --------------------------------------------------------
void __cdecl sub_808F1DC(float *a1, float *a2)
{
  sub_81317D0(a1, a2);
}

//----- (0808F1F6) --------------------------------------------------------
void __usercall sub_808F1F6(long double a1@<st0>, int a2, char *a3, int a4)
{
  char *v4; // eax
  char **i; // [esp+14h] [ebp-4h]

  SV_Cmd_TokenizeString(a3);
  for ( i = &off_815D560; *i; i += 2 )
  {
    v4 = SV_Cmd_Argv(0);
    if ( !strcmp(v4, *i) )
    {
      ((void (__cdecl *)(int))i[1])(a2);
      break;
    }
  }
  if ( a4 && !*i && sub_809215C() )
    ClientCommand(a1, -1653759219 * ((a2 - (int)dword_841FB0C) >> 2));
}
// 815D560: using guessed type char *off_815D560;

//----- (0808F288) --------------------------------------------------------
int __usercall sub_808F288@<eax>(long double a1@<st0>, int a2, _DWORD *a3)
{
  char *v3; // eax
  int v6; // [esp+18h] [ebp-10h]
  int v7; // [esp+1Ch] [ebp-Ch]
  char *v8; // [esp+20h] [ebp-8h]
  int v9; // [esp+24h] [ebp-4h]

  v7 = 1;
  v6 = 1;
  v9 = MSG_ReadLong(a3);
  v8 = (char *)MSG_ReadCommandString(a3);
  if ( *(_DWORD *)(a2 + 133184) >= v9 )
    return 1;
  if ( *(_BYTE *)(sv_showCommands + 8) )
    Com_Printf("clientCommand: %i : %s\n", v9, v8);
  if ( v9 <= *(_DWORD *)(a2 + 133184) + 1 )
  {
    if ( !I_strncmp("team ", v8, 5) || !I_strncmp("score ", v8, 6) || !I_strncmp("mr ", v8, 3) )
      v6 = 0;
    if ( !*((_DWORD *)off_815A498 + 1)
      && *(int *)a2 > 3
      && *(_BYTE *)(sv_floodProtect + 8)
      && dword_841FB04 < *(_DWORD *)(a2 + 134412)
      && v6 )
    {
      v7 = 0;
      v3 = SV_Cmd_Argv(0);
      Com_DPrintf("client text ignored for %s: %s\n", (const char *)(a2 + 134216), v3);
    }
    if ( v6 )
      *(_DWORD *)(a2 + 134412) = dword_841FB04 + 800;
    sub_808F1F6(a1, a2, v8, v7);
    *(_DWORD *)(a2 + 133184) = v9;
    Com_sprintf((char *)(a2 + 133188), 0x400u, "%s", v8);
    return 1;
  }
  else
  {
    Com_Printf("Client %s lost %i clientCommands\n", (const char *)(a2 + 134216), v9 - *(_DWORD *)(a2 + 133184) + 1);
    SV_DropClient(a1, a2, "EXE_LOSTRELIABLECOMMANDS");
    return 0;
  }
}
// 815A498: using guessed type void *off_815A498;
// 848B204: using guessed type int sv_floodProtect;
// 848B210: using guessed type int sv_showCommands;

//----- (0808F488) --------------------------------------------------------
int __usercall SV_ClientThink@<eax>(long double a1@<st0>, char *a2, int *a3)
{
  int result; // eax

  *((_DWORD *)a2 + 33289) = *a3;
  *((_DWORD *)a2 + 33290) = a3[1];
  *((_DWORD *)a2 + 33291) = a3[2];
  *((_DWORD *)a2 + 33292) = a3[3];
  *((_DWORD *)a2 + 33293) = a3[4];
  *((_DWORD *)a2 + 33294) = a3[5];
  *((_DWORD *)a2 + 33295) = a3[6];
  result = (int)a2;
  if ( *(_DWORD *)a2 == 4 )
  {
    sub_80F2EC0(-1653759219 * ((a2 - (_BYTE *)dword_841FB0C) >> 2), *a3);
    return sub_80F3EA4(a1, -1653759219 * ((a2 - (_BYTE *)dword_841FB0C) >> 2));
  }
  return result;
}

//----- (0808F510) --------------------------------------------------------
void __usercall sub_808F510(long double a1@<st0>, int a2, _DWORD *a3, int a4)
{
  int v4; // [esp+14h] [ebp-3C4h]
  char *v5; // [esp+18h] [ebp-3C0h]
  int *v6; // [esp+1Ch] [ebp-3BCh]
  int v7[224]; // [esp+20h] [ebp-3B8h] BYREF
  char s[36]; // [esp+3A0h] [ebp-38h] BYREF
  int v9; // [esp+3C4h] [ebp-14h]
  int v10; // [esp+3C8h] [ebp-10h]
  int i; // [esp+3CCh] [ebp-Ch]
  _DWORD v12[2]; // [esp+3D0h] [ebp-8h] BYREF

  if ( a4 )
    *(_DWORD *)(a2 + 134408) = *(_DWORD *)(a2 + 133144);
  else
    *(_DWORD *)(a2 + 134408) = -1;
  if ( *(_DWORD *)(a2 + 133132) - *(_DWORD *)(a2 + 133136) <= 127 )
  {
    v9 = MSG_ReadByte(a3);
    if ( v9 > 0 )
    {
      if ( v9 <= 32 )
      {
        v10 = dword_842BC8C;
        v10 = *(_DWORD *)(a2 + 133144) ^ dword_842BC8C;
        v10 ^= sub_80AA70C(a2 + 1032 * (*(_DWORD *)(a2 + 133136) & 0x7F) + 1036, 32);
        v4 = SV_GameClientNum(-1653759219 * ((a2 - (int)dword_841FB0C) >> 2));
        MSG_SetDefaultUserCmd(v4, s);
        v5 = s;
        for ( i = 0; i < v9; ++i )
        {
          v6 = &v7[7 * i];
          MSG_ReadDeltaUsercmdKey(a3, v10, (int)v5, (int)v6);
          if ( !BG_IsWeaponValid(v4, *((unsigned __int8 *)v6 + 8)) )
            *((_BYTE *)v6 + 8) = *(_BYTE *)(v4 + 212);
          if ( !BG_IsWeaponValid(v4, *((unsigned __int8 *)v6 + 9)) )
            *((_BYTE *)v6 + 9) = *(_BYTE *)(v4 + 208);
          v5 = (char *)v6;
        }
        *(_DWORD *)(a2 + 9924 * (*(_DWORD *)(a2 + 133144) & 0x1F) + 144352) = dword_841FB04;
        if ( *(_DWORD *)a2 == 3 )
          sub_808E1F0(a2, v7);
        if ( !*(_BYTE *)(sv_pure + 8) || *(_DWORD *)(a2 + 452016) )
        {
          if ( *(_DWORD *)a2 == 4 )
          {
            for ( i = 0; i < v9; ++i )
            {
              if ( v7[7 * i] <= v12[7 * v9 - 243] && v7[7 * i] > *(_DWORD *)(a2 + 133156) )
                SV_ClientThink(a1, (char *)a2, &v7[7 * i]);
            }
          }
          else
          {
            *(_DWORD *)(a2 + 134408) = -1;
          }
        }
        else
        {
          SV_DropClient(a1, a2, "EXE_CANNOTVALIDATEPURECLIENT");
        }
      }
      else
      {
        Com_Printf("cmdCount > MAX_PACKET_USERCMDS\n");
      }
    }
    else
    {
      Com_Printf("cmdCount < 1\n");
    }
  }
}
// 842BC8C: using guessed type int dword_842BC8C;
// 848B200: using guessed type int sv_pure;
// 808F510: using guessed type int var_3B8[224];

//----- (0808F82A) --------------------------------------------------------
void __usercall SV_ExecuteClientMessage(long double a1@<st0>, int a2, _DWORD *a3)
{
  _BYTE v3[16384]; // [esp+20h] [ebp-4038h] BYREF
  _DWORD s[11]; // [esp+4020h] [ebp-38h] BYREF
  _DWORD v5[3]; // [esp+404Ch] [ebp-Ch]

  MSG_Init(s, (int)v3, 0x4000);
  s[3] = MSG_ReadBitsCompress(a3[1] + a3[4], v3, a3[3] - a3[4]);
  if ( *(_DWORD *)(a2 + 484864) == dword_841FA88 || *(_BYTE *)(a2 + 134248) )
  {
    while ( 1 )
    {
      v5[0] = MSG_ReadBits(s, 3);
      if ( v5[0] != 2 )
        break;
      if ( !sub_808F288(a1, a2, s) || *(_DWORD *)a2 == 1 )
        return;
    }
    if ( *(_BYTE *)(sv_pure + 8) && *(_DWORD *)(a2 + 452016) == 2 )
    {
      *(_DWORD *)(a2 + 134424) = -1;
      SV_DropClient(a1, a2, "EXE_UNPURECLIENTDETECTED");
      *(_DWORD *)a2 = 4;
      SV_SendClientSnapshot(a1, a2);
      *(_DWORD *)a2 = 1;
    }
    if ( v5[0] )
    {
      if ( v5[0] == 1 )
      {
        sub_808F510(a1, a2, s, 0);
      }
      else if ( v5[0] != 3 )
      {
        Com_Printf(
          "WARNING: bad command byte %i for client %i\n",
          v5[0],
          -1653759219 * ((a2 - (int)dword_841FB0C) >> 2));
      }
    }
    else
    {
      sub_808F510(a1, a2, s, 1);
    }
  }
  else if ( (*(_DWORD *)(a2 + 484864) & 0xF0) == (dword_841FA88 & 0xF0) )
  {
    if ( *(_DWORD *)a2 == 3 )
      sub_808E1F0(a2, (_DWORD *)(a2 + 133156));
  }
  else if ( *(_DWORD *)(a2 + 133144) > *(_DWORD *)(a2 + 133148) )
  {
    Com_DPrintf("%s : dropped gamestate, resending\n", (const char *)(a2 + 134216));
    sub_808DECA(a1, a2);
    if ( *(_BYTE *)(net_lanauthorize + 8) || !Sys_IsLANAddress(*(_DWORD *)(a2 + 452036), *(_DWORD *)(a2 + 452040)) )
      sub_808C21C(
        a1,
        *(_DWORD *)(a2 + 452036),
        *(_DWORD *)(a2 + 452040),
        *(_DWORD *)(a2 + 452044),
        *(_DWORD *)(a2 + 452048),
        *(_DWORD *)(a2 + 452052),
        *(_DWORD *)(a2 + 133152));
  }
}
// 81F7114: using guessed type int net_lanauthorize;
// 841FA88: using guessed type int dword_841FA88;
// 848B200: using guessed type int sv_pure;
// 808F82A: using guessed type _BYTE var_4038[16384];
// 808F82A: using guessed type _DWORD var_C[3];

//----- (0808FAC6) --------------------------------------------------------
int __usercall SV_AddTestClient@<eax>(long double a1@<st0>)
{
  _DWORD v3[10]; // [esp+40h] [ebp-458h] BYREF
  _DWORD *i; // [esp+68h] [ebp-430h]
  int v5; // [esp+6Ch] [ebp-42Ch]
  int v6; // [esp+70h] [ebp-428h] BYREF
  void *v7; // [esp+74h] [ebp-424h]
  void *v8; // [esp+78h] [ebp-420h]
  void *v9; // [esp+7Ch] [ebp-41Ch]
  void *v10; // [esp+80h] [ebp-418h]
  char s[1032]; // [esp+90h] [ebp-408h] BYREF

  v5 = 0;
  for ( i = dword_841FB0C; v5 < *(_DWORD *)(sv_maxclients + 8) && *i; i += 123845 )
    ++v5;
  if ( v5 == *(_DWORD *)(sv_maxclients + 8) )
    return 0;
  sprintf(
    s,
    "connect \"\\cg_predictItems\\1\\cl_anonymous\\0\\color\\4\\head\\default\\model\\multi\\snaps\\20\\rate\\5000\\name\\"
    "bot%d\\protocol\\%d\"",
    dword_83DF9EC,
    115);
  SV_Cmd_TokenizeString(s);
  memset(&v6, 0, 0x14u);
  v6 = 0;
  LOWORD(v8) = dword_83DF9EC++;
  SV_DirectConnect(a1, 0, v7, v8, v9, v10);
  v5 = 0;
  for ( i = dword_841FB0C;
        v5 < *(_DWORD *)(sv_maxclients + 8) && (!*i || !NET_CompareBaseAdr(v6, (int)v7, (int)v8, (int)v9, (int)v10, i[113009]));
        i += 123845 )
  {
    ++v5;
  }
  if ( v5 == *(_DWORD *)(sv_maxclients + 8) )
    return 0;
  i[121215] = 1;
  sub_808DECA(a1, (int)i);
  memset(v3, 0, 0x1Cu);
  sub_808E1F0((int)i, v3);
  return SV_GentityNum(v5);
}
// 83DF9EC: using guessed type int dword_83DF9EC;
// 848B1CC: using guessed type int sv_maxclients;
// 808FAC6: using guessed type _DWORD var_458[10];

//----- (0808FD2A) --------------------------------------------------------
int __cdecl sub_808FD2A(_BYTE *a1, _BYTE *a2, int a3)
{
  char v6; // [esp+16h] [ebp-2h]
  char v7; // [esp+17h] [ebp-1h]

  while ( a3 && *a1 )
  {
    v7 = tolower((char)*a1);
    v6 = tolower((char)*a2);
    --a3;
    ++a1;
    ++a2;
    if ( v7 < v6 )
      return -1;
    if ( v7 > v6 )
      return 1;
  }
  if ( !a3 || *a1 == *a2 )
    return 0;
  else
    return -1;
}

//----- (0808FDE4) --------------------------------------------------------
int __cdecl SV_GentityNum(int a1)
{
  return dword_848B09C + a1 * dword_848B0A0;
}
// 848B09C: using guessed type int dword_848B09C;
// 848B0A0: using guessed type int dword_848B0A0;

//----- (0808FE02) --------------------------------------------------------
int __cdecl SV_GameClientNum(int a1)
{
  return dword_848B0A8 + a1 * dword_848B0AC;
}
// 848B0A8: using guessed type int dword_848B0A8;
// 848B0AC: using guessed type int dword_848B0AC;

//----- (0808FE20) --------------------------------------------------------
int __cdecl sub_808FE20(_DWORD *a1)
{
  if ( !a1 || *a1 >= 0x400u )
    Com_Error(1, (char *)&byte_8143DA0);
  return 372 * *a1 + 138600600;
}

//----- (0808FE68) --------------------------------------------------------
int __cdecl sub_808FE68(int a1)
{
  return SV_GentityNum(1062196213 * ((a1 + -(int)&dword_842BC80 - 9240) >> 2));
}
// 842BC80: using guessed type int dword_842BC80;

//----- (0808FE96) --------------------------------------------------------
int __cdecl SV_GameSendServerCommand(int a1, int a2, const char *a3)
{
  int result; // eax

  if ( a1 == -1 )
    return SV_SendServerCommand(0, a2, "%s", a3);
  if ( a1 >= 0 )
  {
    result = a1;
    if ( a1 < *(_DWORD *)(sv_maxclients + 8) )
      return SV_SendServerCommand((_DWORD *)dword_841FB0C + 123845 * a1, a2, "%s", a3);
  }
  return result;
}
// 848B1CC: using guessed type int sv_maxclients;

//----- (0808FF0A) --------------------------------------------------------
void __usercall sub_808FF0A(long double a1@<st0>, int a2, char *a3)
{
  if ( a2 >= 0 && a2 < *(_DWORD *)(sv_maxclients + 8) )
    SV_DropClient(a1, (int)dword_841FB0C + 495380 * a2, a3);
}
// 848B1CC: using guessed type int sv_maxclients;

//----- (0808FF44) --------------------------------------------------------
int __cdecl SV_SetBrushModel(int a1)
{
  _DWORD v2[4]; // [esp+10h] [ebp-28h] BYREF
  _DWORD v3[6]; // [esp+20h] [ebp-18h] BYREF

  sub_8052518(*(_DWORD *)(a1 + 140), v3, v2);
  sub_8090E3A(v3, (_DWORD *)(a1 + 260));
  sub_8090E3A(v2, (_DWORD *)(a1 + 272));
  *(_BYTE *)(a1 + 241) = 1;
  *(_DWORD *)(a1 + 284) = -1;
  return SV_LinkEntity(a1);
}
// 808FF44: using guessed type _DWORD var_28[4];
// 808FF44: using guessed type _DWORD var_18[6];

//----- (0808FFBC) --------------------------------------------------------
_BOOL4 __cdecl sub_808FFBC(float *a1, int a2)
{
  float v4; // [esp+24h] [ebp-24h]
  char *v5; // [esp+28h] [ebp-20h]
  int i; // [esp+30h] [ebp-18h]
  int v7; // [esp+34h] [ebp-14h]
  int v8; // [esp+38h] [ebp-10h]
  int v9; // [esp+3Ch] [ebp-Ch]
  int v10; // [esp+40h] [ebp-8h]
  int v11; // [esp+44h] [ebp-4h]

  v11 = SV_GentityNum(a2);
  if ( !*(_BYTE *)(v11 + 240) )
    return 0;
  if ( *(_DWORD *)(v11 + 256) )
    return 1;
  if ( (*(_BYTE *)(v11 + 242) & 1) != 0 )
    return 0;
  if ( (*(_BYTE *)(v11 + 242) & 0x18) != 0 )
    return 1;
  v10 = sub_808FE20((_DWORD *)v11);
  v8 = sub_8058A2C(a1);
  if ( !*(_DWORD *)(v10 + 280) )
    return 0;
  v9 = sub_80524F4(v8);
  v5 = sub_8058F82(v9);
  v7 = 0;
  for ( i = 0; i < *(_DWORD *)(v10 + 280); ++i )
  {
    v7 = *(_DWORD *)(v10 + 4 * i + 284);
    if ( (((int)(unsigned __int8)v5[v7 >> 3] >> (v7 & 7)) & 1) != 0 )
      break;
  }
  if ( i != *(_DWORD *)(v10 + 280) )
    goto LABEL_23;
  if ( !*(_DWORD *)(v10 + 348) )
    return 0;
  while ( v7 <= *(_DWORD *)(v10 + 348) && (((int)(unsigned __int8)v5[v7 >> 3] >> (v7 & 7)) & 1) == 0 )
    ++v7;
  if ( v7 == *(_DWORD *)(v10 + 348) )
    return 0;
LABEL_23:
  v4 = sub_8106976();
  return v4 == 3.4028235e38 || !sub_80A831C((float *)(v11 + 288), (float *)(v11 + 300), a1, v4);
}

//----- (080901C2) --------------------------------------------------------
int __cdecl sub_80901C2(float *a1, float *a2, int a3)
{
  int s[8]; // [esp+40h] [ebp-58h] BYREF
  unsigned __int8 v6; // [esp+63h] [ebp-35h]
  float v7; // [esp+78h] [ebp-20h]
  float v8; // [esp+7Ch] [ebp-1Ch]
  int v9[3]; // [esp+80h] [ebp-18h] BYREF
  int v10; // [esp+8Ch] [ebp-Ch]

  if ( (*(_BYTE *)(a3 + 242) & 0x60) != 0 )
  {
    if ( (*(_BYTE *)(a3 + 242) & 0x20) != 0 )
    {
      if ( *(float *)(a3 + 320) < (long double)a2[2] )
      {
        if ( a1[2] < *(float *)(a3 + 320) + *(float *)(a3 + 280) )
        {
          sub_8090DE8(a1, a2, (float *)v9);
          sub_8090E14((float *)v9, 0.5, (float *)v9);
          v8 = *a2 - *(float *)v9 + *(float *)(a3 + 272);
          v7 = v8 * v8;
          return v7 > sub_80A1EA8((float *)(a3 + 312), (float *)v9);
        }
        else
        {
          return 0;
        }
      }
      else
      {
        return 0;
      }
    }
    else
    {
      sub_8090DE8(a1, a2, (float *)v9);
      sub_8090E14((float *)v9, 0.5, (float *)v9);
      v8 = *a2 - *(float *)v9 + *(float *)(a3 + 272) - 64.0;
      v7 = v8 * v8;
      return sub_80A1EA8((float *)(a3 + 312), (float *)v9) >= v7;
    }
  }
  else
  {
    v10 = sub_809A368(a3);
    sub_805B972(
      s,
      (int)flt_8145E68,
      (int)flt_8145E68,
      (int)a1,
      (int)a2,
      v10,
      -1,
      (float *)(a3 + 312),
      (float *)(a3 + 324));
    return v6;
  }
}
// 8145E68: using guessed type float flt_8145E68[3];
// 80901C2: using guessed type int s[8];

//----- (080903BC) --------------------------------------------------------
char *__cdecl SV_GetServerinfo(char *dest, int a2)
{
  char *v2; // eax

  if ( a2 <= 0 )
    Com_Error(1, (char *)&byte_8143DE0, a2);
  v2 = Dvar_InfoString(0x404u);
  return I_strncpyz(dest, v2, a2);
}

//----- (08090408) --------------------------------------------------------
void *__cdecl sub_8090408(size_t a1)
{
  if ( dword_842BC80 != 1 )
    Com_Error(1, (char *)&byte_8143E20);
  return Hunk_AllocInternal(a1);
}
// 842BC80: using guessed type int dword_842BC80;

//----- (08090438) --------------------------------------------------------
void *__cdecl sub_8090438(size_t n, int a2)
{
  if ( dword_842BC80 != 1 )
    Com_Error(1, (char *)&byte_8143E80);
  return Hunk_AllocAlignInternal(n, a2);
}
// 842BC80: using guessed type int dword_842BC80;

//----- (08090470) --------------------------------------------------------
_DWORD *__cdecl sub_8090470(size_t size)
{
  return Hunk_AllocateTempMemoryInternal(size);
}

//----- (08090484) --------------------------------------------------------
void __cdecl sub_8090484(_DWORD *ptr)
{
  Hunk_FreeTempMemory(ptr);
}

//----- (08090498) --------------------------------------------------------
int __cdecl sub_8090498(int a1, int a2, int a3, int a4, int a5)
{
  int result; // eax

  dword_848B09C = a1;
  dword_848B0A0 = a3;
  dword_848B0A4 = a2;
  dword_848B0A8 = a4;
  result = a5;
  dword_848B0AC = a5;
  return result;
}
// 848B09C: using guessed type int dword_848B09C;
// 848B0A0: using guessed type int dword_848B0A0;
// 848B0A4: using guessed type int dword_848B0A4;
// 848B0A8: using guessed type int dword_848B0A8;
// 848B0AC: using guessed type int dword_848B0AC;

//----- (080904C6) --------------------------------------------------------
int __cdecl sub_80904C6(int a1, _DWORD *a2)
{
  _DWORD *v2; // edx
  int result; // eax

  v2 = (char *)dword_841FB0C + 495380 * a1 + 133156;
  *a2 = *v2;
  a2[1] = v2[1];
  a2[2] = v2[2];
  a2[3] = v2[3];
  a2[4] = v2[4];
  a2[5] = v2[5];
  result = v2[6];
  a2[6] = result;
  return result;
}

//----- (0809050C) --------------------------------------------------------
void *__cdecl sub_809050C(size_t a1)
{
  return Hunk_AllocInternal(a1);
}

//----- (08090520) --------------------------------------------------------
void *__cdecl sub_8090520(size_t a1)
{
  return Hunk_AllocInternal(a1);
}

//----- (08090534) --------------------------------------------------------
int __cdecl SV_XModelGet(char *s1)
{
  if ( !(unsigned __int8)Com_ValidXModelName(s1) )
    Com_Error(1, (char *)&byte_8143EDA, s1);
  return XModelPrecache(s1 + 7, (int (__cdecl *)(int))sub_809050C, (int (__cdecl *)(int))sub_8090520);
}

//----- (08090584) --------------------------------------------------------
void __cdecl SV_DObjDumpInfo(int *a1)
{
  int v1; // [esp+4h] [ebp-4h]

  if ( *(_DWORD *)(com_developer + 8) )
  {
    v1 = Com_GetServerDObj(*a1);
    if ( v1 )
      sub_80B6F74(v1);
    else
      Com_Printf("no model.\n");
  }
}
// 819EEFC: using guessed type int com_developer;

//----- (080905C8) --------------------------------------------------------
unsigned int sub_80905C8()
{
  unsigned int result; // eax

  if ( !++dword_848B0B0 )
    ++dword_848B0B0;
  result = (unsigned int)&unk_83DFA8F & 0xFFFFFFF0;
  dword_841FA80 = (unsigned int)&unk_83DFA8F & 0xFFFFFFF0;
  dword_848B0B4 = 0;
  return result;
}
// 841FA80: using guessed type int dword_841FA80;
// 848B0B0: using guessed type int dword_848B0B0;
// 848B0B4: using guessed type int dword_848B0B4;

//----- (080905FA) --------------------------------------------------------
int __cdecl sub_80905FA(int a1)
{
  int v2; // [esp+14h] [ebp-4h]
  unsigned int v3; // [esp+20h] [ebp+8h]

  v3 = (a1 + 15) & 0xFFFFFFF0;
  while ( 1 )
  {
    v2 = dword_841FA80 + dword_848B0B4;
    dword_848B0B4 += v3;
    if ( (unsigned int)dword_848B0B4 <= 0x3FFF0 )
      break;
    if ( dword_841FA84 != dword_848B0B0 )
    {
      dword_841FA84 = dword_848B0B0;
      Com_Printf("^3WARNING: SV_SKEL_MEMORY_SIZE exceeded\n");
    }
    sub_80905C8();
  }
  return v2;
}
// 841FA80: using guessed type int dword_841FA80;
// 841FA84: using guessed type int dword_841FA84;
// 848B0B0: using guessed type int dword_848B0B0;
// 848B0B4: using guessed type int dword_848B0B4;

//----- (08090666) --------------------------------------------------------
int __cdecl sub_8090666(int *a1, int a2)
{
  int v4; // [esp+1Ch] [ebp-Ch]
  int v5; // [esp+20h] [ebp-8h]
  int v6; // [esp+24h] [ebp-4h]

  v6 = Com_GetServerDObj(*a1);
  if ( DObjSkelExists(v6, dword_848B0B0) )
    return sub_80B7796(v6, a2);
  v5 = sub_80B8380(v6);
  v4 = sub_80905FA(v5);
  sub_80B8424(v6, v4, (int *)dword_848B0B0);
  return 0;
}
// 848B0B0: using guessed type int dword_848B0B0;

//----- (080906EE) --------------------------------------------------------
int __cdecl sub_80906EE(int *a1, int a2)
{
  int v4; // [esp+1Ch] [ebp-Ch]
  int v5; // [esp+20h] [ebp-8h]
  int v6; // [esp+24h] [ebp-4h]

  v6 = Com_GetServerDObj(*a1);
  if ( DObjSkelExists(v6, dword_848B0B0) )
    return sub_80B77C2(v6, a2);
  v5 = sub_80B8380(v6);
  v4 = sub_80905FA(v5);
  sub_80B8424(v6, v4, (int *)dword_848B0B0);
  return 0;
}
// 848B0B0: using guessed type int dword_848B0B0;

//----- (08090776) --------------------------------------------------------
int __cdecl sub_8090776(int *a1, float a2, int a3)
{
  _DWORD **v5; // [esp+14h] [ebp-4h]

  v5 = (_DWORD **)Com_GetServerDObj(*a1);
  if ( v5 )
    return sub_80BEB76(v5, a2, a3);
  else
    return 0;
}

//----- (080907BC) --------------------------------------------------------
_DWORD **__cdecl sub_80907BC(int *a1, float a2)
{
  _DWORD **result; // eax

  result = (_DWORD **)Com_GetServerDObj(*a1);
  if ( result )
    return sub_80BEA94(result, a2);
  return result;
}

//----- (080907EE) --------------------------------------------------------
int __cdecl sub_80907EE(int *a1, int a2, int a3)
{
  int v4; // [esp+14h] [ebp-4h]

  v4 = Com_GetServerDObj(*a1);
  return sub_80B73C0(v4, a2, a3);
}

//----- (08090820) --------------------------------------------------------
int __cdecl sub_8090820(int *a1, int a2)
{
  int v3; // [esp+14h] [ebp-4h]

  v3 = Com_GetServerDObj(*a1);
  return sub_80BEC88(v3, a2);
}

//----- (0809084A) --------------------------------------------------------
int *__cdecl sub_809084A(int *a1, int a2)
{
  int v3; // [esp+14h] [ebp-4h]

  v3 = Com_GetServerDObj(*a1);
  return sub_80B7822(v3, a2);
}

//----- (08090874) --------------------------------------------------------
int __cdecl sub_8090874(int *a1)
{
  int v2; // [esp+4h] [ebp-4h]

  v2 = Com_GetServerDObj(*a1);
  return sub_80B8C0C(v2);
}

//----- (08090898) --------------------------------------------------------
int __cdecl sub_8090898(int *a1, int a2)
{
  int v4; // [esp+14h] [ebp-4h]

  v4 = Com_GetServerDObj(*a1);
  if ( v4 )
    return sub_80B8AF6(v4, a2);
  else
    return -1;
}

//----- (080908D8) --------------------------------------------------------
int __cdecl sub_80908D8(int *a1)
{
  int v2; // [esp+4h] [ebp-4h]

  v2 = Com_GetServerDObj(*a1);
  return sub_80B84D2(v2);
}

//----- (080908FC) --------------------------------------------------------
void __cdecl sub_80908FC(int *a1)
{
  int **v1; // [esp+4h] [ebp-4h]

  v1 = (int **)Com_GetServerDObj(*a1);
  if ( v1 )
    sub_80BEEE4(v1);
}

//----- (08090928) --------------------------------------------------------
int __cdecl sub_8090928(int *a1)
{
  int v2; // [esp+4h] [ebp-4h]

  v2 = Com_GetServerDObj(*a1);
  return sub_80B84D2(v2);
}

//----- (0809094C) --------------------------------------------------------
int __cdecl sub_809094C(int *a1, int a2, int a3)
{
  int v4; // [esp+14h] [ebp-4h]

  v4 = Com_GetServerDObj(*a1);
  return sub_80B858C(v4, a2, a3);
}

//----- (0809097E) --------------------------------------------------------
int __cdecl sub_809097E(int *a1, int a2, int a3)
{
  int v4; // [esp+14h] [ebp-4h]

  v4 = Com_GetServerDObj(*a1);
  return sub_80B8616(v4, a2, a3);
}

//----- (080909B0) --------------------------------------------------------
int __cdecl sub_80909B0(int *a1)
{
  int v3; // [esp+14h] [ebp-4h]

  v3 = Com_GetServerDObj(*a1);
  if ( v3 )
    return sub_80B8BB6(v3);
  else
    return 0;
}

//----- (080909E8) --------------------------------------------------------
void sub_80909E8()
{
  ;
}

//----- (080909EE) --------------------------------------------------------
_BOOL4 __cdecl SV_MapExists(char *s)
{
  char *v1; // eax
  char *v3; // [esp+10h] [ebp-8h]
  const char *v4; // [esp+14h] [ebp-4h]

  v4 = (const char *)sub_808AC6A(s);
  v1 = GetBspExtension();
  v3 = va("maps/mp/%s.%s", v4, v1);
  return FS_ReadFile(v3, 0) >= 0;
}

//----- (08090A48) --------------------------------------------------------
void *sub_8090A48()
{
  void *result; // eax

  result = sub_80524EA();
  dword_848B098 = (int)result;
  return result;
}
// 848B098: using guessed type int dword_848B098;

//----- (08090A5A) --------------------------------------------------------
_BOOL4 __cdecl SV_DObjExists(int *a1)
{
  return Com_GetServerDObj(*a1) != 0;
}

//----- (08090A82) --------------------------------------------------------
int SV_SetWeaponInfoMemory()
{
  return sub_8062676(1);
}

//----- (08090A96) --------------------------------------------------------
void Com_FreeWeaponInfoMemory()
{
  sub_8062684(1);
}

//----- (08090AAA) --------------------------------------------------------
int __cdecl sub_8090AAA(char *dest, int a2)
{
  int v3; // [esp+10h] [ebp-8h]
  char *src; // [esp+14h] [ebp-4h]

  src = Com_Parse((char **)&dword_848B098);
  I_strncpyz(dest, src, a2);
  v3 = 0;
  if ( dword_848B098 || *src )
    return 1;
  return v3;
}
// 848B098: using guessed type int dword_848B098;

//----- (08090AFE) --------------------------------------------------------
int __cdecl sub_8090AFE(int a1)
{
  if ( a1 >= 0 && a1 < *(_DWORD *)(sv_maxclients + 8) )
    return *((_DWORD *)dword_841FB0C + 123845 * a1 + 121213);
  else
    return 0;
}
// 848B1CC: using guessed type int sv_maxclients;

//----- (08090B42) --------------------------------------------------------
int __cdecl sub_8090B42(int a1)
{
  return *((_DWORD *)dword_841FB0C + 123845 * a1 + 113001);
}

//----- (08090B5E) --------------------------------------------------------
int __cdecl sub_8090B5E(int a1)
{
  return NET_IsLocalAddress(*((_DWORD *)dword_841FB0C + 123845 * a1 + 113009));
}

//----- (08090BA2) --------------------------------------------------------
void __usercall SV_ShutdownGameProgs(long double a1@<st0>)
{
  dword_842BC80 = 0;
  Com_UnloadSoundAliases(2);
  if ( gameInitialized )
  {
    G_ShutdownGame(a1, 1);
    Com_FreeWeaponInfoMemory();
    gameInitialized = 0;
  }
}
// 83DFA00: using guessed type int gameInitialized;
// 842BC80: using guessed type int dword_842BC80;

//----- (08090BE6) --------------------------------------------------------
void __usercall SV_SetGametype(long double a1@<st0>)
{
  char *v1; // ebx
  char dest[76]; // [esp+10h] [ebp-58h] BYREF
  char *i; // [esp+5Ch] [ebp-Ch]

  Dvar_RegisterString(a1, "g_gametype", "dm", 4132);
  if ( *(_BYTE *)(com_sv_running + 8) && G_GetSavePersist() )
    I_strncpyz(dest, byte_848B174, 64);
  else
    I_strncpyz(dest, *(char **)(g_gametype + 8), 64);
  for ( i = dest; *i; ++i )
  {
    v1 = i;
    *v1 = tolower(*i);
  }
  if ( !Scr_IsValidGameType(dest) )
  {
    Com_Printf("g_gametype %s is not a valid gametype, defaulting to dm\n", dest);
    strcpy(dest, "dm");
  }
  Dvar_SetString(g_gametype, dest);
}
// 819EF14: using guessed type int com_sv_running;

//----- (08090CD2) --------------------------------------------------------
void __usercall SV_InitGameVM(long double a1@<st0>, int a2, int a3)
{
  int v3; // eax
  int i; // [esp+14h] [ebp-4h]

  sub_8131328();
  dword_848B098 = (int)sub_80524EA();
  sub_80D1D86();
  v3 = sub_80D37B0();
  G_InitGame(a1, dword_841FB04, v3, a2, a3);
  sub_80D1D86();
  for ( i = 0; i < *(_DWORD *)(sv_maxclients + 8); ++i )
    *((_DWORD *)dword_841FB0C + 123845 * i + 33553) = 0;
  if ( *(_DWORD *)(com_dedicated + 8) )
    Com_DvarDump(4);
}
// 848B098: using guessed type int dword_848B098;
// 848B1CC: using guessed type int sv_maxclients;
// 8494204: using guessed type int com_dedicated;

//----- (08090D6A) --------------------------------------------------------
void __usercall SV_RestartGameProgs(long double a1@<st0>, int a2)
{
  G_ShutdownGame(a1, 0);
  com_fixedConsolePosition = 0;
  SV_InitGameVM(a1, 1, a2);
}
// 819EF54: using guessed type int com_fixedConsolePosition;

//----- (08090D9C) --------------------------------------------------------
void __usercall SV_InitGameProgs(long double a1@<st0>, int a2)
{
  gameInitialized = 1;
  SV_InitGameVM(a1, 0, a2);
}
// 83DFA00: using guessed type int gameInitialized;

//----- (08090DC2) --------------------------------------------------------
int SV_GameCommand()
{
  if ( dword_842BC80 == 2 )
    return sub_8119AD4();
  else
    return 0;
}
// 842BC80: using guessed type int dword_842BC80;

//----- (08090DE8) --------------------------------------------------------
float *__cdecl sub_8090DE8(float *a1, float *a2, float *a3)
{
  float *result; // eax

  *a3 = *a1 + *a2;
  result = a1 + 1;
  a3[1] = a1[1] + a2[1];
  return result;
}

//----- (08090E14) --------------------------------------------------------
float *__cdecl sub_8090E14(float *a1, float a2, float *a3)
{
  float *result; // eax

  *a3 = a2 * *a1;
  result = a1 + 1;
  a3[1] = a2 * a1[1];
  return result;
}

//----- (08090E3A) --------------------------------------------------------
int __cdecl sub_8090E3A(_DWORD *a1, _DWORD *a2)
{
  int result; // eax

  *a2 = *a1;
  a2[1] = a1[1];
  result = a1[2];
  a2[2] = result;
  return result;
}

//----- (08090E6C) --------------------------------------------------------
int __cdecl SV_SetConfigstring(unsigned int a1, char *s1)
{
  int result; // eax
  char s[1027]; // [esp+20h] [ebp-428h] BYREF
  char v4; // [esp+423h] [ebp-25h]
  int j; // [esp+424h] [ebp-24h]
  int v6; // [esp+428h] [ebp-20h]
  int i; // [esp+42Ch] [ebp-1Ch]
  int v8; // [esp+430h] [ebp-18h]
  size_t v9; // [esp+434h] [ebp-14h]
  int v10; // [esp+438h] [ebp-10h]
  int v11; // [esp+43Ch] [ebp-Ch]

  if ( a1 >= 0x800 )
    Com_Error(1, (char *)&byte_8143FA0, a1);
  if ( !s1 )
    s1 = (char *)&byte_8143FC3;
  result = a1;
  if ( (&dword_842C098)[a1] )
  {
    result = strcmp(s1, (&dword_842C098)[a1]);
    if ( result )
    {
      ReplaceStringInternal((char **)(4 * a1 + 138592408), s1);
      result = sub_809215C();
      if ( (_BYTE)result || dword_842BC84 )
      {
        v11 = strlen(s1);
        sprintf(s, "%i", a1);
        v9 = strlen(s) + 4;
        v8 = 1024 - v9;
        v10 = 0;
        for ( i = (int)dword_841FB0C; ; i += 495380 )
        {
          result = v10;
          if ( v10 >= *(_DWORD *)(sv_maxclients + 8) )
            break;
          if ( *(int *)i > 2 )
          {
            if ( v11 <= v8 )
            {
              SV_SendServerCommand((_DWORD *)i, 1, "%c %i %s", 100, a1, s1);
            }
            else
            {
              v6 = 0;
              for ( j = v11; j > 0; j -= v8 )
              {
                if ( v6 )
                {
                  if ( j > v8 )
                    v4 = 121;
                  else
                    v4 = 122;
                }
                else
                {
                  v4 = 120;
                }
                I_strncpyz(s, &s1[v6], v8 + 1);
                SV_SendServerCommand((_DWORD *)i, 1, "%c %i %s", v4, a1, s);
                v6 += v8;
              }
            }
          }
          ++v10;
        }
      }
    }
  }
  return result;
}
// 842BC84: using guessed type int dword_842BC84;
// 848B1CC: using guessed type int sv_maxclients;
// 8090E6C: using guessed type unsigned int arg_0;

//----- (0809107E) --------------------------------------------------------
char *__cdecl SV_GetConfigstring(unsigned int a1, char *dest, int a3)
{
  char *result; // eax

  if ( a3 <= 0 )
    Com_Error(1, (char *)&byte_8143FE0, a3);
  if ( a1 >= 0x800 )
    Com_Error(1, (char *)&byte_8144020, a1);
  if ( (&dword_842C098)[a1] )
    return I_strncpyz(dest, (&dword_842C098)[a1], a3);
  result = dest;
  *dest = 0;
  return result;
}
// 809107E: using guessed type unsigned int arg_0;

//----- (08091108) --------------------------------------------------------
const char *__cdecl SV_GetConfigstringConst(int a1)
{
  char *v2; // [esp+0h] [ebp-4h]

  v2 = (&dword_842C098)[a1];
  if ( !v2 )
    return &byte_8143FC3;
  return v2;
}

//----- (08091134) --------------------------------------------------------
char *__cdecl sub_8091134(int a1, int a2, char *s1)
{
  char *s2; // [esp+10h] [ebp-8h]
  int i; // [esp+14h] [ebp-4h]

  for ( i = 0; i < a2; ++i )
  {
    s2 = (&(&dword_842C098)[a1])[i];
    if ( !*s2 )
      return (char *)&byte_8143FC3;
    if ( !strcasecmp(s1, s2) )
      return (&(&(&dword_842C098)[i])[a1])[a2];
  }
  return (char *)&byte_8143FC3;
}

//----- (080911AA) --------------------------------------------------------
int __cdecl sub_80911AA(int a1, int a2, char *s1, char *a4)
{
  char *s2; // [esp+10h] [ebp-8h]
  int i; // [esp+14h] [ebp-4h]

  for ( i = 0; i < a2; ++i )
  {
    s2 = (&(&dword_842C098)[a1])[i];
    if ( !*s2 )
    {
      SV_SetConfigstring(a1 + i, s1);
      break;
    }
    if ( !strcasecmp(s1, s2) )
      break;
  }
  if ( i == a2 )
    Com_Error(1, (char *)&byte_8144060);
  return SV_SetConfigstring(i + a1 + a2, a4);
}

//----- (08091246) --------------------------------------------------------
char *__cdecl sub_8091246(int a1, char *src)
{
  char *v2; // eax

  if ( a1 < 0 || a1 >= *(_DWORD *)(sv_maxclients + 8) )
    Com_Error(1, (char *)&byte_81440A0, a1);
  if ( !src )
    src = (char *)&byte_8143FC3;
  I_strncpyz((char *)dword_841FB0C + 495380 * a1 + 12, src, 1024);
  v2 = Info_ValueForKey(src, "name");
  return I_strncpyz((char *)dword_841FB0C + 495380 * a1 + 134216, v2, 32);
}
// 848B1CC: using guessed type int sv_maxclients;
// 8091246: using guessed type int arg_0;

//----- (080912F0) --------------------------------------------------------
char *__cdecl SV_GetUserinfo(int a1, char *dest, int a3)
{
  if ( a3 <= 0 )
    Com_Error(1, (char *)&byte_81440E0, a3);
  if ( a1 < 0 || a1 >= *(_DWORD *)(sv_maxclients + 8) )
    Com_Error(1, (char *)&byte_8144120, a1);
  return I_strncpyz(dest, (char *)dword_841FB0C + 495380 * a1 + 12, a3);
}
// 848B1CC: using guessed type int sv_maxclients;
// 80912F0: using guessed type int arg_0;

//----- (08091372) --------------------------------------------------------
int sub_8091372()
{
  int result; // eax
  int i; // [esp+8h] [ebp-10h]
  int *v2; // [esp+Ch] [ebp-Ch]

  for ( i = 1; ; ++i )
  {
    result = i;
    if ( i >= dword_848B0A4 )
      break;
    v2 = (int *)SV_GentityNum(i);
    if ( *((_BYTE *)v2 + 240) )
    {
      *v2 = i;
      qmemcpy((char *)&unk_842E09C + 372 * i, v2, 0xF0u);
      dword_842E18C[93 * i] = *((unsigned __int8 *)v2 + 242);
      dword_842E190[93 * i] = v2[61];
      dword_842E194[93 * i] = v2[62];
      sub_80929F8(v2 + 72, (_DWORD *)(372 * i + 138600856));
      sub_80929F8(v2 + 75, (_DWORD *)(372 * i + 138600868));
    }
  }
  return result;
}
// 842E18C: using guessed type int dword_842E18C[];
// 842E190: using guessed type int dword_842E190[];
// 842E194: using guessed type int dword_842E194[95169];
// 848B0A4: using guessed type int dword_848B0A4;

//----- (0809147E) --------------------------------------------------------
void __usercall sub_809147E(long double a1@<st0>, char *a2)
{
  sv_maxclients = (int)Dvar_RegisterInt(a1, "sv_maxclients", (char *)0x14, 1, 64, 4133);
  Dvar_ClearModified(sv_maxclients);
  if ( *(_DWORD *)(sv_maxclients + 8) < (int)a2 )
    Dvar_SetInt(sv_maxclients, a2);
}
// 848B1CC: using guessed type int sv_maxclients;

//----- (080914E6) --------------------------------------------------------
void __usercall sub_80914E6(long double a1@<st0>)
{
  if ( dword_841FB00 )
    Com_Error(0, (char *)&byte_814414D);
  sub_809147E(a1, (char *)1);
  dword_841FB0C = Z_VirtualAllocInternal(495380 * *(_DWORD *)(sv_maxclients + 8));
  if ( !dword_841FB0C )
    Com_Error(0, (char *)&byte_8144180);
  if ( *(_DWORD *)(com_dedicated + 8) )
  {
    dword_841FB10 = *(_DWORD *)(sv_maxclients + 8) << 11;
    dword_841FB14 = 32 * *(_DWORD *)(sv_maxclients + 8) * *(_DWORD *)(sv_maxclients + 8);
  }
  else
  {
    dword_841FB10 = *(_DWORD *)(sv_maxclients + 8) << 8;
    dword_841FB14 = 4 * *(_DWORD *)(sv_maxclients + 8) * *(_DWORD *)(sv_maxclients + 8);
  }
  dword_841FB00 = 1;
  Dvar_SetBool(com_sv_running, 1);
}
// 819EF14: using guessed type int com_sv_running;
// 841FB00: using guessed type int dword_841FB00;
// 841FB10: using guessed type int dword_841FB10;
// 841FB14: using guessed type int dword_841FB14;
// 848B1CC: using guessed type int sv_maxclients;
// 8494204: using guessed type int com_dedicated;

//----- (080915D0) --------------------------------------------------------
int __usercall sub_80915D0@<eax>(long double a1@<st0>)
{
  int result; // eax
  unsigned int v2; // [esp+14h] [ebp-34h]
  _DWORD *v3; // [esp+18h] [ebp-30h]
  _DWORD *v4; // [esp+1Ch] [ebp-2Ch]
  unsigned int v5; // [esp+20h] [ebp-28h]
  _DWORD *v6; // [esp+24h] [ebp-24h]
  _DWORD *v7; // [esp+28h] [ebp-20h]
  int v8; // [esp+2Ch] [ebp-1Ch]
  char *v9; // [esp+2Ch] [ebp-1Ch]
  _DWORD *ptr; // [esp+30h] [ebp-18h]
  int i; // [esp+34h] [ebp-14h]
  int j; // [esp+34h] [ebp-14h]
  int k; // [esp+34h] [ebp-14h]
  int v14; // [esp+38h] [ebp-10h]

  v8 = 0;
  for ( i = 0; i < *(_DWORD *)(sv_maxclients + 8); ++i )
  {
    if ( *((int *)dword_841FB0C + 123845 * i) > 1 && i > v8 )
      v8 = i;
  }
  v9 = (char *)(v8 + 1);
  v14 = *(_DWORD *)(sv_maxclients + 8);
  sub_809147E(a1, v9);
  result = *(_DWORD *)(sv_maxclients + 8);
  if ( result != v14 )
  {
    ptr = Hunk_AllocateTempMemoryInternal(495380 * (_DWORD)v9);
    for ( j = 0; j < (int)v9; ++j )
    {
      if ( *((int *)dword_841FB0C + 123845 * j) <= 1 )
      {
        Com_Memset(&ptr[123845 * j], 0, 0x78F14u);
      }
      else
      {
        v7 = &ptr[123845 * j];
        v6 = (char *)dword_841FB0C + 495380 * j;
        v5 = 495380;
        if ( (((_BYTE)ptr + 20 * (_BYTE)j) & 4) != 0 )
        {
          *v7++ = *v6++;
          v5 = 495376;
        }
        qmemcpy(v7, v6, 4 * (v5 >> 2));
      }
    }
    Z_VirtualFreeInternal(dword_841FB0C);
    dword_841FB0C = Z_VirtualAllocInternal(495380 * *(_DWORD *)(sv_maxclients + 8));
    if ( !dword_841FB0C )
      Com_Error(0, (char *)&byte_8144180);
    Com_Memset(dword_841FB0C, 0, 495380 * *(_DWORD *)(sv_maxclients + 8));
    for ( k = 0; k < (int)v9; ++k )
    {
      if ( (int)ptr[123845 * k] > 1 )
      {
        v4 = (char *)dword_841FB0C + 495380 * k;
        v3 = &ptr[123845 * k];
        v2 = 495380;
        if ( (((_BYTE)dword_841FB0C + 20 * (_BYTE)k) & 4) != 0 )
        {
          *v4++ = *v3++;
          v2 = 495376;
        }
        qmemcpy(v4, v3, 4 * (v2 >> 2));
      }
    }
    Hunk_FreeTempMemory(ptr);
    if ( *(_DWORD *)(com_dedicated + 8) )
    {
      dword_841FB10 = *(_DWORD *)(sv_maxclients + 8) << 11;
      result = 32 * *(_DWORD *)(sv_maxclients + 8) * *(_DWORD *)(sv_maxclients + 8);
    }
    else
    {
      dword_841FB10 = *(_DWORD *)(sv_maxclients + 8) << 8;
      result = 4 * *(_DWORD *)(sv_maxclients + 8) * *(_DWORD *)(sv_maxclients + 8);
    }
    dword_841FB14 = result;
  }
  return result;
}
// 841FB10: using guessed type int dword_841FB10;
// 841FB14: using guessed type int dword_841FB14;
// 848B1CC: using guessed type int sv_maxclients;
// 8494204: using guessed type int com_dedicated;

//----- (0809188A) --------------------------------------------------------
void __cdecl sub_809188A(char *a1)
{
  char *v1; // eax
  int v2; // [esp+10h] [ebp-18h]
  char *nptr; // [esp+14h] [ebp-14h]
  const char *nptra; // [esp+14h] [ebp-14h]
  char *v5; // [esp+18h] [ebp-10h] BYREF
  void *s; // [esp+1Ch] [ebp-Ch]
  char *src; // [esp+20h] [ebp-8h]
  int v8; // [esp+24h] [ebp-4h] BYREF

  src = "hunkusage.dat";
  v2 = FS_FOpenFileByMode("hunkusage.dat", &v8, 0);
  if ( v2 >= 0 )
  {
    s = Z_MallocInternal(v2 + 1);
    memset(s, 0, v2 + 1);
    FS_Read((int)s, v2, v8);
    FS_FCloseFile(v8);
    v5 = (char *)s;
    while ( 1 )
    {
      nptr = Com_Parse(&v5);
      if ( !nptr || !*nptr )
        break;
      if ( !I_stricmp(nptr, a1) )
      {
        nptra = Com_Parse(&v5);
        if ( nptra )
        {
          if ( *nptra )
          {
            v1 = (char *)atoi(nptra);
            Dvar_SetInt(com_expectedHunkUsage, v1);
            Z_FreeInternal(s);
            return;
          }
        }
      }
    }
    Z_FreeInternal(s);
  }
}
// 819EF30: using guessed type int com_expectedHunkUsage;

//----- (08091998) --------------------------------------------------------
void *sub_8091998()
{
  int i; // [esp+14h] [ebp-4h]

  for ( i = 0; i <= 2047; ++i )
  {
    if ( (&dword_842C098)[i] )
      Z_FreeInternal((&dword_842C098)[i]);
  }
  return Com_Memset(&dword_842BC80, 0, 0x5F534u);
}
// 842BC80: using guessed type int dword_842BC80;

//----- (080919F4) --------------------------------------------------------
void *__cdecl sub_80919F4(int a1)
{
  void *result; // eax

  result = (void *)a1;
  dword_841FB28 = a1;
  if ( a1 )
  {
    if ( !dword_841FB30 )
    {
      dword_841FB48 = Z_MallocInternal(0x450000u);
      dword_841FB4C = Z_MallocInternal(0x2708000u);
      dword_841FB30 = Z_MallocInternal(0x2580u);
      dword_841FB34 = Z_MallocInternal(0x2000000u);
      result = Z_MallocInternal(0x3800u);
      dword_841FB50 = result;
    }
  }
  return result;
}
// 841FB28: using guessed type int dword_841FB28;

//----- (08091A70) --------------------------------------------------------
void sub_8091A70()
{
  dword_841FB28 = 0;
  dword_841FB2C = 0;
  dword_841FB38 = 0;
  dword_841FB3C = 0;
  dword_841FB40 = 0;
  dword_841FB44 = 0;
}
// 841FB28: using guessed type int dword_841FB28;
// 841FB2C: using guessed type int dword_841FB2C;
// 841FB38: using guessed type int dword_841FB38;
// 841FB3C: using guessed type int dword_841FB3C;
// 841FB40: using guessed type int dword_841FB40;
// 841FB44: using guessed type int dword_841FB44;

//----- (08091AB2) --------------------------------------------------------
void sub_8091AB2()
{
  if ( dword_841FB48 )
  {
    Z_FreeInternal(dword_841FB48);
    dword_841FB48 = 0;
  }
  if ( dword_841FB4C )
  {
    Z_FreeInternal(dword_841FB4C);
    dword_841FB4C = 0;
  }
  if ( dword_841FB30 )
  {
    Z_FreeInternal(dword_841FB30);
    dword_841FB30 = 0;
  }
  if ( dword_841FB34 )
  {
    Z_FreeInternal(dword_841FB34);
    dword_841FB34 = 0;
  }
  if ( dword_841FB50 )
  {
    Z_FreeInternal(dword_841FB50);
    dword_841FB50 = 0;
  }
}

//----- (08091B5A) --------------------------------------------------------
_WORD *sub_8091B5A()
{
  return sub_80B2C06();
}

//----- (08091B68) --------------------------------------------------------
int sub_8091B68()
{
  char *v0; // eax
  char *v1; // eax
  int result; // eax
  char dest[8200]; // [esp+10h] [ebp-2008h] BYREF

  v0 = Dvar_InfoString_Big(8u);
  I_strncpyz(dest, v0, 0x2000);
  dvar_modifiedFlags &= ~8u;
  SV_SetConfigstring(1u, dest);
  v1 = Dvar_InfoString(0x404u);
  SV_SetConfigstring(0, v1);
  dvar_modifiedFlags &= 0xFFFFFBFB;
  result = SV_SetConfig(142, 96, 0x100u);
  dvar_modifiedFlags &= ~0x100u;
  return result;
}
// 85178A8: using guessed type int dvar_modifiedFlags;

//----- (08091C02) --------------------------------------------------------
void __usercall SV_SpawnServer(long double a1@<st0>, char *a2)
{
  int v2; // eax
  int v3; // ebx
  int v4; // ebx
  char *v5; // eax
  int v6; // ebx
  char *v7; // eax
  char *v8; // eax
  char *v9; // eax
  char *v10; // [esp+28h] [ebp-60h]
  char *src; // [esp+2Ch] [ebp-5Ch]
  char *srca; // [esp+2Ch] [ebp-5Ch]
  char *srcb; // [esp+2Ch] [ebp-5Ch]
  char s[64]; // [esp+30h] [ebp-58h] BYREF
  int v15; // [esp+70h] [ebp-18h]
  int *v16; // [esp+74h] [ebp-14h]
  int v17; // [esp+78h] [ebp-10h] BYREF
  int i; // [esp+7Ch] [ebp-Ch]

  Scr_ParseGameTypeList();
  SV_SetGametype(a1);
  if ( *(_BYTE *)(com_sv_running + 8) )
  {
    v15 = G_GetSavePersist();
    i = 0;
    v16 = (int *)dword_841FB0C;
    while ( i < *(_DWORD *)(sv_maxclients + 8) )
    {
      if ( *v16 > 2 )
      {
        Com_sprintf(s, 0x40u, "loadingnewmap\n%s\n%s", a2, *(const char **)(g_gametype + 8));
        NET_OutOfBandPrint(1, v16[113009], v16[113010], v16[113011], v16[113012], v16[113013], s);
      }
      ++i;
      v16 += 123845;
    }
    NET_Sleep(250);
  }
  else
  {
    v15 = 0;
  }
  Dvar_SetStringByName(a1, "mapname", a2);
  SV_ShutdownGameProgs(a1);
  Com_Printf("------ Server Initialization ------\n");
  Com_Printf("Server: %s\n", a2);
  sub_8091998();
  if ( *(_DWORD *)(com_dedicated + 8) )
    FX_FreeSystem();
  FS_Shutdown();
  FS_ClearIwdReferences();
  Com_Restart(a1);
  if ( *(_BYTE *)(com_sv_running + 8) )
    sub_80915D0(a1);
  else
    sub_80914E6(a1);
  I_strncpyz(byte_848B174, *(char **)(g_gametype + 8), 64);
  v2 = sub_80D37B0();
  srand(v2);
  v3 = rand() << 16;
  v4 = rand() ^ v3;
  dword_842BC8C = v4 ^ Sys_MilliSeconds();
  FS_Restart(a1, dword_842BC8C);
  v5 = GetBspExtension();
  Com_sprintf(s, 0x40u, "maps/mp/%s.%s", a2, v5);
  sub_809188A(s);
  for ( i = 0; i <= 2047; ++i )
  {
    v6 = i;
    (&dword_842C098)[v6] = CopyStringInternal((char *)&byte_8143FC3);
  }
  sub_8091B5A();
  dword_841FB20 = (int)Hunk_AllocInternal(240 * dword_841FB10);
  dword_841FB18 = 0;
  dword_841FB24 = (int)Hunk_AllocInternal(92 * dword_841FB14);
  dword_841FB1C = 0;
  sub_8091A70();
  dword_841FB08 ^= 4u;
  Dvar_SetString(nextmap, "map_restart");
  Dvar_SetInt(cl_paused, 0);
  v7 = GetBspExtension();
  Com_sprintf(s, 0x40u, "maps/mp/%s.%s", a2, v7);
  Com_LoadBsp(s);
  CM_LoadMap(a1, s, &v17);
  Com_UnloadBsp();
  sub_805DA8E();
  dword_841FA88 = (unsigned __int8)(dword_841FA88 + 16);
  if ( (dword_841FA88 & 0xF0) == 0 )
    dword_841FA88 += 16;
  Dvar_SetInt(sv_serverid, (char *)dword_841FA88);
  dword_842BC88 = com_frameTime;
  dword_842BC80 = 1;
  v8 = GetBspExtension();
  Com_sprintf(s, 0x40u, "maps/mp/%s.%s", a2, v8);
  Com_LoadSoundAliases(s, "all_mp", 2);
  SV_InitGameProgs(a1, v15);
  if ( *(_DWORD *)(com_dedicated + 8) )
  {
    sub_812F47E(0);
    sub_8129F2C();
  }
  for ( i = 0; i <= 2; ++i )
  {
    dword_841FB04 += 100;
    sub_8094780(a1);
  }
  sub_8091372();
  for ( i = 0; i < *(_DWORD *)(sv_maxclients + 8); ++i )
  {
    if ( *((int *)dword_841FB0C + 123845 * i) > 1 )
    {
      v10 = (char *)ClientConnect(a1, i, *((_WORD *)dword_841FB0C + 247690 * i + 242428));
      if ( v10 )
        SV_DropClient(a1, (int)dword_841FB0C + 495380 * i, v10);
      else
        *((_DWORD *)dword_841FB0C + 123845 * i) = 2;
    }
  }
  if ( *(_BYTE *)(sv_pure + 8) )
  {
    src = FS_LoadedIwdChecksums();
    Dvar_SetString(sv_iwds, src);
    if ( !*src )
      Com_Printf("WARNING: sv_pure set but no IWD files loaded\n");
    srca = FS_LoadedIwdNames();
    Dvar_SetString(sv_iwdNames, srca);
  }
  else
  {
    Dvar_SetString(sv_iwds, (char *)&byte_8143FC3);
    Dvar_SetString(sv_iwdNames, (char *)&byte_8143FC3);
  }
  v9 = FS_ReferencedIwdChecksums();
  Dvar_SetString(sv_referencedIwds, v9);
  srcb = FS_ReferencedIwdNames();
  Dvar_SetString(sv_referencedIwdNames, srcb);
  sub_8091B68();
  dword_842BC80 = 2;
  sub_808BACE();
  Com_Printf("-----------------------------------\n");
}
// 819EF14: using guessed type int com_sv_running;
// 819EF28: using guessed type int cl_paused;
// 819EF40: using guessed type int com_frameTime;
// 841FA88: using guessed type int dword_841FA88;
// 841FB08: using guessed type int dword_841FB08;
// 841FB10: using guessed type int dword_841FB10;
// 841FB14: using guessed type int dword_841FB14;
// 841FB18: using guessed type int dword_841FB18;
// 841FB1C: using guessed type int dword_841FB1C;
// 841FB20: using guessed type int dword_841FB20;
// 841FB24: using guessed type int dword_841FB24;
// 842BC80: using guessed type int dword_842BC80;
// 842BC88: using guessed type int dword_842BC88;
// 842BC8C: using guessed type int dword_842BC8C;
// 848B1CC: using guessed type int sv_maxclients;
// 848B1E4: using guessed type int sv_serverid;
// 848B200: using guessed type int sv_pure;
// 8494204: using guessed type int com_dedicated;

//----- (0809215C) --------------------------------------------------------
_BOOL4 sub_809215C()
{
  return dword_842BC80 == 2;
}
// 842BC80: using guessed type int dword_842BC80;

//----- (0809216E) --------------------------------------------------------
char *__usercall SV_Init@<eax>(long double a1@<st0>)
{
  char *result; // eax

  SV_AddOperatorCommands();
  g_gametype = (int)Dvar_RegisterString(a1, "g_gametype", "dm", 4132);
  Dvar_RegisterString(a1, "sv_keywords", (char *)&byte_8143FC3, 4100);
  Dvar_RegisterInt(a1, "protocol", (char *)0x73, 115, 115, 4164);
  mapname = (int)Dvar_RegisterString(a1, "mapname", (char *)&byte_8143FC3, 4164);
  sv_privateClients = (int)Dvar_RegisterInt(a1, "sv_privateClients", 0, 0, 64, 4100);
  sv_maxclients = (int)Dvar_RegisterInt(a1, "sv_maxclients", (char *)0x14, 1, 64, 4133);
  sv_hostname = (int)Dvar_RegisterString(a1, "sv_hostname", "CoD2Host", 4101);
  sv_maxRate = (int)Dvar_RegisterInt(a1, "sv_maxRate", 0, 0, 25000, 4101);
  sv_minPing = (int)Dvar_RegisterInt(a1, "sv_minPing", 0, 0, 999, 4101);
  sv_maxPing = (int)Dvar_RegisterInt(a1, "sv_maxPing", 0, 0, 999, 4101);
  sv_floodProtect = (int)Dvar_RegisterBool(a1, "sv_floodProtect", 1, 4101);
  sv_allowAnonymous = (int)Dvar_RegisterBool(a1, "sv_allowAnonymous", 0, 4100);
  sv_showCommands = (int)Dvar_RegisterBool(a1, "sv_showCommands", 0, 4096);
  sv_disableClientConsole = (int)Dvar_RegisterBool(a1, "sv_disableClientConsole", 0, 4104);
  sv_voice = (int)Dvar_RegisterBool(a1, "sv_voice", 0, 4109);
  sv_voiceQuality = (int)Dvar_RegisterInt(a1, "sv_voiceQuality", (char *)1, 0, 9, 4104);
  sv_cheats = (int)Dvar_RegisterBool(a1, "sv_cheats", 0, 4120);
  sv_serverid = (int)Dvar_RegisterInt(a1, "sv_serverid", 0, 0x80000000, 0x7FFFFFFF, 4168);
  sv_pure = (int)Dvar_RegisterBool(a1, "sv_pure", 1, 4108);
  sv_iwds = (int)Dvar_RegisterString(a1, "sv_iwds", (char *)&byte_8143FC3, 4168);
  sv_iwdNames = (int)Dvar_RegisterString(a1, "sv_iwdNames", (char *)&byte_8143FC3, 4168);
  sv_referencedIwds = (int)Dvar_RegisterString(a1, "sv_referencedIwds", (char *)&byte_8143FC3, 4168);
  sv_referencedIwdNames = (int)Dvar_RegisterString(a1, "sv_referencedIwdNames", (char *)&byte_8143FC3, 4168);
  rcon_password = (int)Dvar_RegisterString(a1, "rcon_password", (char *)&byte_8143FC3, 4096);
  sv_privatePassword = (int)Dvar_RegisterString(a1, "sv_privatePassword", (char *)&byte_8143FC3, 4096);
  sv_fps = (int)Dvar_RegisterInt(a1, "sv_fps", (char *)0x14, 10, 1000, 4096);
  sv_timeout = (int)Dvar_RegisterInt(a1, "sv_timeout", (char *)0xF0, 0, 1800, 4096);
  sv_zombietime = (int)Dvar_RegisterInt(a1, "sv_zombietime", (char *)2, 0, 1800, 4096);
  sv_allowDownload = (int)Dvar_RegisterBool(a1, "sv_allowDownload", 1, 4097);
  sv_reconnectlimit = (int)Dvar_RegisterInt(a1, "sv_reconnectlimit", (char *)3, 0, 1800, 4097);
  sv_padPackets = (int)Dvar_RegisterInt(a1, "sv_padPackets", 0, 0, 0x7FFFFFFF, 4096);
  *((_BYTE *)off_815A498 + 221) = 0;
  sv_allowedClan1 = (int)Dvar_RegisterString(a1, "sv_allowedClan1", (char *)&byte_8143FC3, 4096);
  sv_allowedClan2 = (int)Dvar_RegisterString(a1, "sv_allowedClan2", (char *)&byte_8143FC3, 4096);
  sv_packet_info = (int)Dvar_RegisterBool(a1, "sv_packet_info", 0, 4096);
  sv_showAverageBPS = (int)Dvar_RegisterBool(a1, "sv_showAverageBPS", 0, 4096);
  sv_kickBanTime = (int)Dvar_RegisterFloat(a1, "sv_kickBanTime", (char *)0x43960000, 0, 1163984896, 4096);
  sv_mapRotation = (int)Dvar_RegisterString(a1, "sv_mapRotation", (char *)&byte_8143FC3, 4096);
  sv_mapRotationCurrent = (int)Dvar_RegisterString(a1, "sv_mapRotationCurrent", (char *)&byte_8143FC3, 4096);
  sv_debugRate = (int)Dvar_RegisterBool(a1, "sv_debugRate", 0, 4096);
  sv_debugReliableCmds = (int)Dvar_RegisterBool(a1, "sv_debugReliableCmds", 0, 4096);
  nextmap = (int)Dvar_RegisterString(a1, "nextmap", (char *)&byte_8143FC3, 4096);
  result = Dvar_RegisterInt(a1, "com_expectedHunkUsage", 0, 0, 0x7FFFFFFF, 4160);
  com_expectedHunkUsage = (int)result;
  return result;
}
// 815A498: using guessed type void *off_815A498;
// 819EF30: using guessed type int com_expectedHunkUsage;
// 848B1B4: using guessed type int sv_fps;
// 848B1B8: using guessed type int sv_timeout;
// 848B1BC: using guessed type int sv_zombietime;
// 848B1C0: using guessed type int rcon_password;
// 848B1C4: using guessed type int sv_privatePassword;
// 848B1C8: using guessed type int sv_allowDownload;
// 848B1CC: using guessed type int sv_maxclients;
// 848B1D0: using guessed type int sv_privateClients;
// 848B1D4: using guessed type int sv_hostname;
// 848B1D8: using guessed type int sv_reconnectlimit;
// 848B1DC: using guessed type int sv_padPackets;
// 848B1E0: using guessed type int mapname;
// 848B1E4: using guessed type int sv_serverid;
// 848B1E8: using guessed type int sv_maxRate;
// 848B1EC: using guessed type int sv_minPing;
// 848B1F0: using guessed type int sv_maxPing;
// 848B1F8: using guessed type int sv_debugRate;
// 848B1FC: using guessed type int sv_debugReliableCmds;
// 848B200: using guessed type int sv_pure;
// 848B204: using guessed type int sv_floodProtect;
// 848B208: using guessed type int sv_cheats;
// 848B20C: using guessed type int sv_allowAnonymous;
// 848B210: using guessed type int sv_showCommands;
// 848B214: using guessed type int sv_packet_info;
// 848B218: using guessed type int sv_showAverageBPS;
// 848B21C: using guessed type int sv_mapRotation;
// 848B224: using guessed type int sv_kickBanTime;
// 848B228: using guessed type int sv_disableClientConsole;
// 848B22C: using guessed type int sv_voice;
// 848B230: using guessed type int sv_voiceQuality;
// 848B244: using guessed type int sv_allowedClan1;
// 848B248: using guessed type int sv_allowedClan2;

//----- (080927DA) --------------------------------------------------------
int *__usercall SV_FinalMessage@<eax>(long double a1@<st0>, const char *a2)
{
  int *result; // eax
  int *v3; // [esp+1Ch] [ebp-Ch]
  int i; // [esp+20h] [ebp-8h] BYREF
  int v5; // [esp+24h] [ebp-4h]

  for ( i = 0; i <= 1; ++i )
  {
    v5 = 0;
    v3 = (int *)dword_841FB0C;
    while ( v5 < *(_DWORD *)(sv_maxclients + 8) )
    {
      if ( *v3 > 1 )
      {
        if ( v3[113009] != 2 )
        {
          SV_SendServerCommand(v3, 0, "%c \"%s\"", 101, a2);
          SV_SendServerCommand(v3, 1, "%c \"%s\"", 119, a2);
        }
        v3[33606] = -1;
        SV_SendClientSnapshot(a1, (int)v3);
      }
      ++v5;
      v3 += 123845;
    }
    result = &i;
  }
  return result;
}
// 848B1CC: using guessed type int sv_maxclients;

//----- (080928B4) --------------------------------------------------------
int __usercall SV_DisconnectAllClients@<eax>(long double a1@<st0>)
{
  int result; // eax
  int *i; // [esp+10h] [ebp-8h]
  int v3; // [esp+14h] [ebp-4h]

  v3 = 0;
  for ( i = (int *)dword_841FB0C; ; i += 123845 )
  {
    result = v3;
    if ( v3 >= *(_DWORD *)(sv_maxclients + 8) )
      break;
    if ( *i > 1 )
      SV_DropClient(a1, (int)i, "EXE_DISCONNECTED");
    ++v3;
  }
  return result;
}
// 848B1CC: using guessed type int sv_maxclients;

//----- (08092906) --------------------------------------------------------
void __usercall SV_Shutdown(long double a1@<st0>, const char *a2)
{
  bool v2; // [esp+17h] [ebp-1h]

  if ( com_sv_running && *(_BYTE *)(com_sv_running + 8) )
  {
    Com_Printf("----- Server Shutdown -----\n");
    v2 = dword_842BC80 == 1;
    if ( dword_841FB0C )
      SV_FinalMessage(a1, a2);
    SV_RemoveOperatorCommands();
    SV_MasterShutdown();
    SV_ShutdownGameProgs(a1);
    SV_DisconnectAllClients(a1);
    sub_8091998();
    if ( dword_841FB0C )
      SV_FreeClients(a1);
    sub_8091AB2();
    memset(&dword_841FB00, 0, 0xC108u);
    if ( *(_DWORD *)(com_dedicated + 8) )
      FX_FreeSystem();
    Dvar_SetBool(com_sv_running, 0);
    Com_Printf("---------------------------\n");
    if ( v2 )
    {
      Com_AbortDObj();
      DObjAbort();
      XAnimAbort();
      Scr_Abort();
      dword_855A4E0 = 0;
    }
  }
}
// 819EF14: using guessed type int com_sv_running;
// 841FB00: using guessed type int dword_841FB00;
// 842BC80: using guessed type int dword_842BC80;
// 8494204: using guessed type int com_dedicated;

//----- (080929F8) --------------------------------------------------------
int __cdecl sub_80929F8(_DWORD *a1, _DWORD *a2)
{
  int result; // eax

  *a2 = *a1;
  a2[1] = a1[1];
  result = a1[2];
  a2[2] = result;
  return result;
}

//----- (08092A28) --------------------------------------------------------
_BYTE *__cdecl sub_8092A28(_BYTE *a1)
{
  unsigned int v2; // [esp+0h] [ebp-4h]
  unsigned int v3; // [esp+0h] [ebp-4h]

  v2 = 0;
  while ( *a1 && v2 <= 0x3FC )
  {
    if ( *a1 == 10 )
    {
      *(_BYTE *)(v2 + 138981984) = 92;
      v3 = v2 + 1;
      *(_BYTE *)(v3 + 138981984) = 110;
      v2 = v3 + 1;
      goto LABEL_10;
    }
    if ( *a1 == 20 || *a1 == 21 )
    {
      ++a1;
    }
    else
    {
      byte_848B260[v2++] = *a1;
LABEL_10:
      ++a1;
    }
  }
  *(_BYTE *)(v2 + 138981984) = 0;
  return byte_848B260;
}
// 848B260: using guessed type _BYTE byte_848B260[1024];

//----- (08092AB6) --------------------------------------------------------
int __cdecl sub_8092AB6(_BYTE *a1, _BYTE *a2)
{
  int v3; // [esp+0h] [ebp-8h]

  while ( *a1 && *a2 && *a1 != 32 && *a2 != 32 )
  {
    if ( *a1 != *a2 )
      return 0;
    ++a1;
    ++a2;
  }
  v3 = 0;
  if ( (!*a1 || *a1 == 32) && (!*a2 || *a2 == 32) )
    return 1;
  return v3;
}

//----- (08092B3C) --------------------------------------------------------
int __cdecl sub_8092B3C(int a1, char *a2)
{
  int v3; // [esp+18h] [ebp-10h]
  int v4; // [esp+1Ch] [ebp-Ch]
  int i; // [esp+20h] [ebp-8h]

  for ( i = *(_DWORD *)(a1 + 133140) + 1; ; ++i )
  {
    if ( i > *(_DWORD *)(a1 + 133132) )
      return -1;
    v4 = i & 0x7F;
    if ( *(_DWORD *)(a1 + 1032 * v4 + 2064) )
    {
      if ( *a2 == *(char *)(a1 + 1032 * v4 + 1036) && (unsigned __int8)(*a2 - 120) > 2u )
        break;
    }
LABEL_12:
    ;
  }
  if ( !strcmp(a2 + 1, (const char *)(a1 + 1032 * v4 + 1037)) )
    return i;
  switch ( *a2 )
  {
    case 'C':
    case 'D':
    case 'a':
    case 'b':
    case 'o':
    case 'p':
    case 'q':
    case 'r':
    case 't':
      v3 = i;
      break;
    case 'd':
    case 'v':
      if ( !sub_8092AB6(a2 + 2, (_BYTE *)(a1 + 1032 * v4 + 1038)) )
        goto LABEL_12;
      v3 = i;
      break;
    default:
      goto LABEL_12;
  }
  return v3;
}

//----- (08092C6C) --------------------------------------------------------
int __cdecl sub_8092C6C(int a1)
{
  int result; // eax
  unsigned int v2; // [esp+0h] [ebp-24h]
  _DWORD *v3; // [esp+4h] [ebp-20h]
  _DWORD *v4; // [esp+8h] [ebp-1Ch]
  int v5; // [esp+Ch] [ebp-18h]
  int v6; // [esp+10h] [ebp-14h]
  int v7; // [esp+14h] [ebp-10h]
  int i; // [esp+18h] [ebp-Ch]

  v7 = *(_DWORD *)(a1 + 133140) + 1;
  for ( i = v7; i <= *(_DWORD *)(a1 + 133132); ++i )
  {
    v6 = i & 0x7F;
    if ( *(_DWORD *)(a1 + 1032 * v6 + 2064) )
    {
      v5 = v7 & 0x7F;
      if ( v5 != v6 )
      {
        v4 = (_DWORD *)(a1 + 1032 * v5 + 1036);
        v3 = (_DWORD *)(a1 + 1032 * v6 + 1036);
        v2 = 1032;
        if ( (((_BYTE)a1 + 8 * (_BYTE)v5 + 12) & 4) != 0 )
        {
          *v4 = *v3;
          v4 = (_DWORD *)(a1 + 1032 * v5 + 1040);
          v3 = (_DWORD *)(a1 + 1032 * v6 + 1040);
          v2 = 1028;
        }
        qmemcpy(v4, v3, 4 * (v2 >> 2));
      }
      ++v7;
    }
  }
  result = v7 - 1;
  *(_DWORD *)(a1 + 133132) = v7 - 1;
  return result;
}

//----- (08092D5C) --------------------------------------------------------
_DWORD *__cdecl sub_8092D5C(_DWORD *a1, int a2, char *s)
{
  _DWORD *result; // eax
  unsigned int v4; // [esp+24h] [ebp-24h]
  _DWORD *v5; // [esp+28h] [ebp-20h]
  _DWORD *v6; // [esp+2Ch] [ebp-1Ch]
  int i; // [esp+30h] [ebp-18h]
  int v8; // [esp+34h] [ebp-14h]
  int j; // [esp+38h] [ebp-10h]
  int v10; // [esp+3Ch] [ebp-Ch]

  result = a1;
  if ( !a1[121215] )
  {
    if ( a1[33283] - a1[33284] <= 63 && *a1 == 4 || (result = (_DWORD *)sub_8092C6C((int)a1), a2) )
    {
      v8 = sub_8092B3C((int)a1, s);
      if ( v8 < 0 )
      {
        ++a1[33283];
      }
      else
      {
        for ( i = v8 + 1; i <= a1[33283]; ++i )
        {
          v6 = &a1[258 * (v8 & 0x7F) + 259];
          v5 = &a1[258 * (i & 0x7F) + 259];
          v4 = 1032;
          if ( (((_BYTE)a1 + 8 * (v8 & 0x7F) + 12) & 4) != 0 )
          {
            *v6 = *v5;
            v6 = &a1[258 * (v8 & 0x7F) + 260];
            v5 = &a1[258 * (i & 0x7F) + 260];
            v4 = 1028;
          }
          qmemcpy(v6, v5, 4 * (v4 >> 2));
          LOBYTE(v8) = v8 + 1;
        }
      }
      if ( a1[33283] - a1[33284] == 129 )
      {
        Com_Printf("===== pending server commands =====\n");
        for ( j = a1[33284] + 1; j <= a1[33283]; ++j )
          Com_Printf("cmd %5d: %8d: %s\n", j, a1[258 * (j & 0x7F) + 515], (const char *)&a1[258 * (j & 0x7F) + 259]);
        Com_Printf("cmd %5d: %8d: %s\n", j, dword_841FB04, s);
        NET_OutOfBandPrint(1, a1[113009], a1[113010], a1[113011], a1[113012], a1[113013], "disconnect");
        sub_808DEA6(a1, "EXE_SERVERCOMMANDOVERFLOW");
        a2 = 1;
        s = va("%c \"EXE_SERVERCOMMANDOVERFLOW\"", 119);
      }
      v10 = a1[33283] & 0x7F;
      MSG_WriteReliableCommandToBuffer(s, &a1[258 * v10 + 259], 1024);
      a1[258 * v10 + 515] = dword_841FB04;
      result = (_DWORD *)a2;
      a1[258 * v10 + 516] = a2;
    }
  }
  return result;
}

//----- (0809301C) --------------------------------------------------------
int SV_SendServerCommand(_DWORD *a1, int a2, char *format, ...)
{
  const char *v4; // eax
  int v5; // [esp+14h] [ebp-34h]
  int *v6; // [esp+18h] [ebp-30h]
  char *s; // [esp+1Ch] [ebp-2Ch]
  int v8[10]; // [esp+20h] [ebp-28h] BYREF
  va_list va; // [esp+5Ch] [ebp+14h] BYREF

  va_start(va, format);
  LargeLocal(v8, 0x4000);
  s = LargeLocalGetBuf(v8);
  va_copy(&v8[7], va);
  vsprintf(s, format, va);
  if ( a1 )
  {
    sub_8092D5C(a1, a2, s);
    return LargeLocalDealloc(v8);
  }
  else
  {
    if ( *(_DWORD *)(com_dedicated + 8) && !strncmp(s, "print", 5u) )
    {
      v4 = sub_8092A28(s);
      Com_Printf("broadcast: %s\n", v4);
    }
    v5 = 0;
    v6 = (int *)dword_841FB0C;
    while ( v5 < *(_DWORD *)(sv_maxclients + 8) )
    {
      if ( *v6 > 2 )
        sub_8092D5C(v6, a2, s);
      ++v5;
      v6 += 123845;
    }
    return LargeLocalDealloc(v8);
  }
}
// 848B1CC: using guessed type int sv_maxclients;
// 8494204: using guessed type int com_dedicated;

//----- (0809315A) --------------------------------------------------------
int __cdecl sub_809315A(char a1, int a2, int a3, int a4, int a5, _DWORD *a6)
{
  int result; // eax
  int v7; // [esp+2Ch] [ebp-Ch]
  int v8; // [esp+30h] [ebp-8h]
  _WORD *i; // [esp+34h] [ebp-4h]

  v7 = MSG_ReadShort(a6);
  v8 = 0;
  for ( i = dword_841FB0C; ; i += 247690 )
  {
    result = v8;
    if ( v8 >= *(_DWORD *)(sv_maxclients + 8) )
      break;
    if ( *(_DWORD *)i && NET_CompareBaseAdr(a1, a2, a3, a4, a5, *((_DWORD *)i + 113009)) && *((_DWORD *)i + 113014) == v7 )
    {
      if ( i[226022] != (_WORD)a3 )
      {
        Com_Printf("SV_ReadPackets: fixing up a translated port\n");
        i[226022] = a3;
      }
      if ( *(_DWORD *)i != 1 )
      {
        *((_DWORD *)i + 33604) = dword_841FB04;
        if ( *(int *)i > 3 )
          sub_809A112((int)i, a6);
        else
          sub_809A1EA((int)i, a6);
      }
    }
    ++v8;
  }
  return result;
}
// 848B1CC: using guessed type int sv_maxclients;
// 809315A: using guessed type int arg_4;

//----- (08093288) --------------------------------------------------------
int __cdecl SVC_Status(int a1, int a2, int a3, int a4, int a5)
{
  char *v5; // eax
  char *v6; // eax
  char *v7; // eax
  char *v8; // eax
  char *v9; // eax
  int v11; // [esp+2Ch] [ebp-485Ch]
  char v12[1036]; // [esp+30h] [ebp-4858h] BYREF
  char v13[4]; // [esp+43Ch] [ebp-444Ch]
  char *v14; // [esp+440h] [ebp-4448h]
  _BYTE *v15; // [esp+444h] [ebp-4444h]
  int v16; // [esp+448h] [ebp-4440h]
  _BYTE *v17; // [esp+44Ch] [ebp-443Ch]
  char v18[8192]; // [esp+450h] [ebp-4438h] BYREF
  char dest[8200]; // [esp+2450h] [ebp-2438h] BYREF
  size_t v20; // [esp+4458h] [ebp-430h]
  int v21; // [esp+445Ch] [ebp-42Ch]
  int v22; // [esp+4460h] [ebp-428h]
  int v23; // [esp+4464h] [ebp-424h]
  int i; // [esp+4468h] [ebp-420h]
  char *v25; // [esp+446Ch] [ebp-41Ch]
  int v26[4]; // [esp+4470h] [ebp-418h] BYREF
  char s[1032]; // [esp+4480h] [ebp-408h] BYREF

  LargeLocal(v26, 0x4000);
  v25 = LargeLocalGetBuf(v26);
  *(_DWORD *)v13 = 0;
  v5 = Dvar_InfoString(0x404u);
  strcpy(dest, v5);
  v6 = SV_Cmd_Argv(1u);
  Info_SetValueForKey(dest, "challenge", (int)v6);
  if ( (unsigned __int8)Dvar_GetBool("fs_restrict") )
  {
    v7 = Info_ValueForKey(dest, "sv_keywords");
    Com_sprintf(v12, 0x400u, "demo %s", v7);
    Info_SetValueForKey(dest, "sv_keywords", (int)v12);
  }
  *v25 = 0;
  v21 = 0;
  for ( i = 0; i < *(_DWORD *)(sv_maxclients + 8); ++i )
  {
    v23 = (int)dword_841FB0C + 495380 * i;
    if ( *(int *)v23 > 1 )
    {
      v22 = SV_GameClientNum(i);
      if ( gameInitialized )
      {
        v11 = sub_810698A(-1653759219 * ((v23 - (int)dword_841FB0C) >> 2));
        Com_sprintf(s, 0x400u, "%i %i \"%s\"\n", v11, *(_DWORD *)(v23 + 452004), (const char *)(v23 + 134216));
      }
      else
      {
        Com_sprintf(s, 0x400u, "%i %i \"%s\"\n", 0, *(_DWORD *)(v23 + 452004), (const char *)(v23 + 134216));
      }
      v20 = strlen(s);
      if ( v21 + v20 > 0x3FFF )
        break;
      strcpy(&v25[v21], s);
      v21 += v20;
    }
  }
  v17 = Dvar_GetString("g_password");
  if ( v17 && *v17 )
    Info_SetValueForKey(dest, "pswrd", (int)"1");
  else
    Info_SetValueForKey(dest, "pswrd", (int)"0");
  v15 = Dvar_GetString("fs_game");
  if ( !*(_BYTE *)(sv_pure + 8) || v15 && *v15 )
  {
    *(_DWORD *)v13 = 1;
  }
  else
  {
    v14 = (char *)Dvar_GetString("sv_referencedIwdNames");
    if ( *v14 )
    {
      SV_Cmd_TokenizeString(v14);
      v16 = SV_Cmd_Argc();
      for ( i = 0; i < v16; ++i )
      {
        v8 = SV_Cmd_Argv(i);
        if ( !FS_iwIwd(v8, "main") )
        {
          *(_DWORD *)v13 = 1;
          break;
        }
      }
    }
  }
  v9 = va("%i", *(_DWORD *)v13);
  Info_SetValueForKey(dest, "mod", (int)v9);
  Com_sprintf(v18, 0x2000u, "statusResponse\n%s\n%s", dest, v25);
  NET_OutOfBandPrint(1, a1, a2, a3, a4, a5, v18);
  return LargeLocalDealloc(v26);
}
// 83DFA00: using guessed type int gameInitialized;
// 848B1CC: using guessed type int sv_maxclients;
// 848B200: using guessed type int sv_pure;
// 8093288: using guessed type int var_418[4];
// 8093288: using guessed type int arg_8;

//----- (080936D4) --------------------------------------------------------
int __cdecl sub_80936D4(int a1, int a2, int a3, int a4, int a5)
{
  char *v5; // eax
  char *v6; // eax
  char *v7; // eax
  int v8; // eax
  char *v9; // eax
  char v11[1024]; // [esp+30h] [ebp-C38h] BYREF
  char dest[1032]; // [esp+430h] [ebp-838h] BYREF
  size_t v13; // [esp+838h] [ebp-430h]
  int v14; // [esp+83Ch] [ebp-42Ch]
  int v15; // [esp+840h] [ebp-428h]
  int v16; // [esp+844h] [ebp-424h]
  int i; // [esp+848h] [ebp-420h]
  char *v18; // [esp+84Ch] [ebp-41Ch]
  int v19[4]; // [esp+850h] [ebp-418h] BYREF
  char s[1032]; // [esp+860h] [ebp-408h] BYREF

  LargeLocal(v19, 0x4000);
  v18 = LargeLocalGetBuf(v19);
  v5 = Dvar_InfoString(0x404u);
  strcpy(dest, v5);
  v6 = SV_Cmd_Argv(1u);
  Info_SetValueForKey(dest, "challenge", (int)v6);
  if ( (unsigned __int8)Dvar_GetBool("fs_restrict") )
  {
    v7 = Info_ValueForKey(dest, "sv_keywords");
    Com_sprintf(v11, 0x400u, "demo %s", v7);
    Info_SetValueForKey(dest, "sv_keywords", (int)v11);
  }
  *v18 = 0;
  v14 = 0;
  for ( i = 0; i < *(_DWORD *)(sv_maxclients + 8); ++i )
  {
    v16 = (int)dword_841FB0C + 495380 * i;
    if ( *(int *)v16 > 1 )
    {
      v15 = SV_GameClientNum(i);
      v8 = sub_810698A(-1653759219 * ((v16 - (int)dword_841FB0C) >> 2));
      Com_sprintf(s, 0x400u, "%i %i \"%s\"\n", v8, *(_DWORD *)(v16 + 452004), (const char *)(v16 + 134216));
      v13 = strlen(s);
      if ( v14 + v13 > 0x3FFF )
        break;
      strcpy(&v18[v14], s);
      v14 += v13;
    }
  }
  v9 = va("gameCompleteStatus\n%s\n%s", dest, v18);
  NET_OutOfBandPrint(1, a1, a2, a3, a4, a5, v9);
  return LargeLocalDealloc(v19);
}
// 848B1CC: using guessed type int sv_maxclients;
// 80936D4: using guessed type int var_418[4];
// 80936D4: using guessed type int arg_8;

//----- (08093980) --------------------------------------------------------
_BOOL4 __cdecl SVC_Info(int a1, int a2, int a3, int a4, int a5)
{
  char *v5; // eax
  char *v6; // eax
  char *v7; // eax
  char *v8; // eax
  char *v9; // eax
  char *v10; // eax
  char *v11; // eax
  char *v12; // eax
  char *v13; // eax
  char *v14; // eax
  char *v15; // eax
  char *v16; // eax
  char *v17; // eax
  char *v18; // eax
  char *v20; // [esp+2Ch] [ebp-83Ch]
  char dest[1024]; // [esp+30h] [ebp-838h] BYREF
  char src[1036]; // [esp+430h] [ebp-438h] BYREF
  char v23[4]; // [esp+83Ch] [ebp-2Ch]
  char v24[4]; // [esp+840h] [ebp-28h]
  char v25[4]; // [esp+844h] [ebp-24h]
  _BYTE *v26; // [esp+848h] [ebp-20h]
  int v27; // [esp+84Ch] [ebp-1Ch]
  int v28; // [esp+850h] [ebp-18h]
  int v29; // [esp+854h] [ebp-14h]
  char v30[4]; // [esp+858h] [ebp-10h]
  signed int i; // [esp+85Ch] [ebp-Ch]

  v29 = 0;
  for ( i = 0; i < *(_DWORD *)(sv_privateClients + 8); ++i )
  {
    if ( *((int *)dword_841FB0C + 123845 * i) > 1 )
      ++v29;
  }
  *(_DWORD *)v30 = v29;
  for ( i = *(_DWORD *)(sv_privateClients + 8); i < *(_DWORD *)(sv_maxclients + 8); ++i )
  {
    if ( *((int *)dword_841FB0C + 123845 * i) > 1 )
      ++*(_DWORD *)v30;
  }
  src[0] = 0;
  v5 = SV_Cmd_Argv(1u);
  Info_SetValueForKey(src, "challenge", (int)v5);
  v6 = va("%i", 115);
  Info_SetValueForKey(src, "protocol", (int)v6);
  Info_SetValueForKey(src, "hostname", *(_DWORD *)(sv_hostname + 8));
  Info_SetValueForKey(src, "mapname", *(_DWORD *)(mapname + 8));
  if ( *(_DWORD *)v30 )
  {
    v7 = va("%i", *(_DWORD *)v30);
    Info_SetValueForKey(src, "clients", (int)v7);
  }
  *(_DWORD *)v23 = *(_DWORD *)(sv_maxclients + 8) - (*(_DWORD *)(sv_privateClients + 8) - v29);
  if ( *(int *)v23 > 0 )
  {
    v8 = va("%i", *(_DWORD *)v23);
    Info_SetValueForKey(src, "sv_maxclients", (int)v8);
  }
  Info_SetValueForKey(src, "gametype", *(_DWORD *)(g_gametype + 8));
  if ( *(_BYTE *)(sv_pure + 8) || fs_numServerIwds )
    Info_SetValueForKey(src, "pure", (int)"1");
  if ( *(_DWORD *)(sv_minPing + 8) )
  {
    v9 = va("%i", *(_DWORD *)(sv_minPing + 8));
    Info_SetValueForKey(src, "minPing", (int)v9);
  }
  if ( *(_DWORD *)(sv_maxPing + 8) )
  {
    v10 = va("%i", *(_DWORD *)(sv_maxPing + 8));
    Info_SetValueForKey(src, "maxPing", (int)v10);
  }
  v27 = (int)Dvar_GetString("fs_game");
  if ( *(_BYTE *)v27 )
    Info_SetValueForKey(src, "game", v27);
  if ( *(_BYTE *)(sv_allowAnonymous + 8) )
  {
    v11 = va("%i", *(unsigned __int8 *)(sv_allowAnonymous + 8));
    Info_SetValueForKey(src, "sv_allowAnonymous", (int)v11);
  }
  if ( *(_BYTE *)(sv_disableClientConsole + 8) )
  {
    v12 = va("%i", *(unsigned __int8 *)(sv_disableClientConsole + 8));
    Info_SetValueForKey(src, "con_disabled", (int)v12);
  }
  v26 = Dvar_GetString("g_password");
  if ( v26 && *v26 )
    Info_SetValueForKey(src, "pswrd", (int)"1");
  *(_DWORD *)v25 = Dvar_GetInt("scr_friendlyfire");
  if ( *(_DWORD *)v25 )
  {
    v13 = va("%i", *(_DWORD *)v25);
    Info_SetValueForKey(src, "ff", (int)v13);
  }
  *(_DWORD *)v24 = Dvar_GetInt("scr_killcam");
  if ( *(_DWORD *)v24 )
  {
    v14 = va("%i", *(_DWORD *)v24);
    Info_SetValueForKey(src, "kc", (int)v14);
  }
  v15 = va("%i", 1);
  Info_SetValueForKey(src, "hw", (int)v15);
  if ( !*(_BYTE *)(sv_pure + 8) || v27 && *(_BYTE *)v27 )
  {
LABEL_43:
    v17 = va("%i", 1);
  }
  else
  {
    v20 = (char *)Dvar_GetString("sv_referencedIwdNames");
    if ( *v20 )
    {
      SV_Cmd_TokenizeString(v20);
      v28 = SV_Cmd_Argc();
      for ( i = 0; i < v28; ++i )
      {
        v16 = SV_Cmd_Argv(i);
        if ( !FS_iwIwd(v16, "main") )
          goto LABEL_43;
      }
    }
    v17 = va("%i", 0);
  }
  Info_SetValueForKey(src, "mod", (int)v17);
  v18 = va("%i", *(unsigned __int8 *)(sv_voice + 8));
  Info_SetValueForKey(src, "voice", (int)v18);
  I_strncpyz(dest, "infoResponse\n", 1024);
  I_strncat(dest, 1024, src);
  return NET_OutOfBandPrint(1, a1, a2, a3, a4, a5, dest);
}
// 848B1CC: using guessed type int sv_maxclients;
// 848B1D0: using guessed type int sv_privateClients;
// 848B1D4: using guessed type int sv_hostname;
// 848B1E0: using guessed type int mapname;
// 848B1EC: using guessed type int sv_minPing;
// 848B1F0: using guessed type int sv_maxPing;
// 848B200: using guessed type int sv_pure;
// 848B20C: using guessed type int sv_allowAnonymous;
// 848B228: using guessed type int sv_disableClientConsole;
// 848B22C: using guessed type int sv_voice;
// 848FF00: using guessed type int fs_numServerIwds;
// 8093980: using guessed type int arg_8;

//----- (08093F1E) --------------------------------------------------------
void __usercall SV_ConnectionlessPacket(long double a1@<st0>, void *a2, void *a3, void *a4, void *a5, void *a6, _DWORD *a7)
{
  char *v7; // eax
  char *v8; // [esp+20h] [ebp-8h]
  char *v9; // [esp+24h] [ebp-4h]

  MSG_BeginReading(a7);
  MSG_ReadLong(a7);
  SV_Netchan_AddOOBProfilePacket(a7[3]);
  v9 = (char *)MSG_ReadStringLine(a7);
  SV_Cmd_TokenizeString(v9);
  v8 = SV_Cmd_Argv(0);
  if ( *(_BYTE *)(sv_packet_info + 8) )
  {
    v7 = NET_AdrToString((int)a2, (int)a3, (int)a4, (int)a5, (int)a6);
    Com_Printf("SV packet %s : %s\n", v7, v8);
  }
  if ( I_stricmp(v8, "v") )
  {
    if ( I_stricmp(v8, "getstatus") )
    {
      if ( I_stricmp(v8, "getinfo") )
      {
        if ( I_stricmp(v8, "getchallenge") )
        {
          if ( I_stricmp(v8, "connect") )
          {
            if ( I_stricmp(v8, "ipAuthorize") )
            {
              if ( I_stricmp(v8, "rcon") )
                I_stricmp(v8, "disconnect");
              else
                SVC_RemoteCommand(a1, (int)a2, (int)a3, (int)a4, (int)a5, (int)a6);
            }
            else
            {
              sub_808C7CA((char)a2, (int)a3, (int)a4, (int)a5, (int)a6);
            }
          }
          else
          {
            SV_DirectConnect(a1, a2, a3, a4, a5, a6);
          }
        }
        else
        {
          SV_GetChallenge(a1, (int)a2, (int)a3, (int)a4, (int)a5, (int)a6);
        }
      }
      else
      {
        SVC_Info((int)a2, (int)a3, (int)a4, (int)a5, (int)a6);
      }
    }
    else
    {
      SVC_Status((int)a2, (int)a3, (int)a4, (int)a5, (int)a6);
    }
  }
  else
  {
    sub_809315A((char)a2, (int)a3, (int)a4, (int)a5, (int)a6, a7);
  }
}
// 848B214: using guessed type int sv_packet_info;

//----- (080941AE) --------------------------------------------------------
void __usercall SV_PacketEvent(long double a1@<st0>, void *a2, void *a3, void *a4, void *a5, void *a6, _DWORD *a7)
{
  int v7; // [esp+28h] [ebp-10h]
  _DWORD *i; // [esp+2Ch] [ebp-Ch]
  int v9; // [esp+30h] [ebp-8h]

  if ( (int)a7[3] > 3 && *(_DWORD *)a7[1] == -1 )
  {
    SV_ConnectionlessPacket(a1, a2, a3, a4, a5, a6, a7);
  }
  else
  {
    sub_80905C8();
    MSG_BeginReading(a7);
    MSG_ReadLong(a7);
    v7 = (unsigned __int16)MSG_ReadShort(a7);
    v9 = 0;
    for ( i = dword_841FB0C; ; i += 123845 )
    {
      if ( v9 >= *(_DWORD *)(sv_maxclients + 8) )
      {
        NET_OutOfBandPrint(1, (int)a2, (int)a3, (int)a4, (int)a5, (int)a6, "disconnect");
        return;
      }
      if ( *i && NET_CompareBaseAdr((char)a2, (int)a3, (int)a4, (int)a5, (int)a6, i[113009]) && i[113014] == v7 )
        break;
      ++v9;
    }
    if ( *((_WORD *)i + 226022) != (_WORD)a4 )
    {
      Com_Printf("SV_ReadPackets: fixing up a translated port\n");
      *((_WORD *)i + 226022) = (_WORD)a4;
    }
    if ( Netchan_Process((int)(i + 113005), a7) )
    {
      i[121216] = MSG_ReadByte(a7);
      i[33286] = MSG_ReadLong(a7);
      if ( (int)i[33286] >= 0 )
      {
        i[33284] = MSG_ReadLong(a7);
        if ( i[33283] - i[33284] <= 127 )
        {
          sub_80954DE((int)i, (_BYTE *)(a7[1] + a7[4]), a7[3] - a7[4]);
          if ( *i != 1 )
          {
            i[33604] = dword_841FB04;
            SV_ExecuteClientMessage(a1, (int)i, a7);
            dword_855A4E0 = 0;
          }
        }
        else
        {
          i[33284] = i[33283];
        }
      }
    }
  }
}
// 848B1CC: using guessed type int sv_maxclients;
// 80941AE: using guessed type void *arg_4;
// 80941AE: using guessed type void *arg_8;

//----- (0809443E) --------------------------------------------------------
int SV_CalcPings()
{
  int result; // eax
  int v1; // [esp+8h] [ebp-18h]
  int v2; // [esp+Ch] [ebp-14h]
  _DWORD *v3; // [esp+10h] [ebp-10h]
  int j; // [esp+14h] [ebp-Ch]
  int i; // [esp+18h] [ebp-8h]

  for ( i = 0; ; ++i )
  {
    result = i;
    if ( i >= *(_DWORD *)(sv_maxclients + 8) )
      break;
    v3 = (char *)dword_841FB0C + 495380 * i;
    if ( *v3 == 4 )
    {
      if ( v3[33553] )
      {
        v2 = 0;
        v1 = 0;
        for ( j = 0; j <= 31; ++j )
        {
          if ( (int)v3[2481 * j + 36088] > 0 )
          {
            ++v1;
            v2 += v3[2481 * j + 36088] - v3[2481 * j + 36087];
          }
        }
        if ( v1 )
        {
          v3[113001] = v2 / v1;
          if ( (int)v3[113001] > 999 )
            v3[113001] = 999;
        }
        else
        {
          v3[113001] = 999;
        }
      }
      else
      {
        v3[113001] = 999;
      }
    }
    else
    {
      v3[113001] = 999;
    }
  }
  return result;
}
// 848B1CC: using guessed type int sv_maxclients;

//----- (08094586) --------------------------------------------------------
int __cdecl sub_8094586(int a1)
{
  int result; // eax

  sub_807F554(*(unsigned __int16 *)(a1 + 484856));
  result = a1;
  *(_WORD *)(a1 + 484856) = 0;
  return result;
}

//----- (080945AC) --------------------------------------------------------
int __usercall SV_CheckTimeouts@<eax>(long double a1@<st0>)
{
  int result; // eax
  int v2; // [esp+8h] [ebp-10h]
  int v3; // [esp+Ch] [ebp-Ch]
  const char *i; // [esp+10h] [ebp-8h]
  int v5; // [esp+14h] [ebp-4h]

  v3 = dword_841FB04 - 1000 * *(_DWORD *)(sv_timeout + 8);
  v2 = dword_841FB04 - 1000 * *(_DWORD *)(sv_zombietime + 8);
  v5 = 0;
  for ( i = (const char *)dword_841FB0C; ; i += 495380 )
  {
    result = v5;
    if ( v5 >= *(_DWORD *)(sv_maxclients + 8) )
      break;
    if ( *((_DWORD *)i + 33604) > dword_841FB04 )
      *((_DWORD *)i + 33604) = dword_841FB04;
    if ( !*((_DWORD *)i + 121215) )
    {
      if ( *(_DWORD *)i == 1 && *((_DWORD *)i + 33604) < v2 )
      {
        Com_DPrintf("Going from CS_ZOMBIE to CS_FREE for %s\n", i + 134216);
        *(_DWORD *)i = 0;
      }
      else if ( *(int *)i <= 1 || *((_DWORD *)i + 33604) >= v3 )
      {
        *((_DWORD *)i + 33608) = 0;
      }
      else if ( (int)++*((_DWORD *)i + 33608) > 5 )
      {
        SV_DropClient(a1, (int)i, "EXE_TIMEDOUT");
        *(_DWORD *)i = 0;
      }
    }
    ++v5;
  }
  return result;
}
// 848B1B8: using guessed type int sv_timeout;
// 848B1BC: using guessed type int sv_zombietime;
// 848B1CC: using guessed type int sv_maxclients;

//----- (080946DA) --------------------------------------------------------
int SV_CheckPaused()
{
  int v2; // [esp+Ch] [ebp-Ch]
  int *v3; // [esp+10h] [ebp-8h]
  int v4; // [esp+14h] [ebp-4h]

  if ( !*(_DWORD *)(cl_paused + 8) )
    return 0;
  v4 = 0;
  v2 = 0;
  v3 = (int *)dword_841FB0C;
  while ( v2 < *(_DWORD *)(sv_maxclients + 8) )
  {
    if ( *v3 > 1 )
      ++v4;
    ++v2;
    v3 += 123845;
  }
  if ( v4 <= 1 )
  {
    Dvar_SetInt(sv_paused, (char *)1);
    return 1;
  }
  else
  {
    Dvar_SetInt(sv_paused, 0);
    return 0;
  }
}
// 819EF28: using guessed type int cl_paused;
// 819EF34: using guessed type int sv_paused;
// 848B1CC: using guessed type int sv_maxclients;

//----- (08094780) --------------------------------------------------------
void __usercall sub_8094780(long double a1@<st0>)
{
  sub_80905C8();
  sub_8107CA2(a1, dword_841FB04);
}

//----- (0809479A) --------------------------------------------------------
int __usercall sub_809479A@<eax>(long double a1@<st0>, int a2)
{
  int result; // eax
  int s; // [esp+20h] [ebp-28h] BYREF
  int v4; // [esp+24h] [ebp-24h]
  char v5; // [esp+28h] [ebp-20h]
  int v6; // [esp+2Ch] [ebp-1Ch]
  int v7; // [esp+30h] [ebp-18h]
  int v8; // [esp+34h] [ebp-14h]
  char v9; // [esp+38h] [ebp-10h]
  char v10; // [esp+39h] [ebp-Fh]

  result = a2;
  if ( *(_DWORD *)(a2 + 134212) )
  {
    memset(&s, 0, 0x1Cu);
    v5 = *(_BYTE *)(SV_GameClientNum(-1653759219 * ((a2 - (int)dword_841FB0C) >> 2)) + 212);
    if ( !sub_81069A6(-1653759219 * ((a2 - (int)dword_841FB0C) >> 2)) )
    {
      if ( sub_80A1410() < 0.5 )
        v4 |= 1u;
      if ( sub_80A1410() < 0.5 )
        v4 |= 0x28u;
      if ( sub_80A1410() >= 0.33000001 )
      {
        if ( sub_80A1410() < 0.5 )
          v9 = -127;
      }
      else
      {
        v9 = 127;
      }
      if ( sub_80A1410() >= 0.33000001 )
      {
        if ( sub_80A1410() < 0.5 )
          v10 = -127;
      }
      else
      {
        v10 = 127;
      }
      if ( sub_80A1410() < 0.33000001 )
        v6 = (int)(sub_80A142E() * 360.0);
      if ( sub_80A1410() < 0.33000001 )
        v7 = (int)(sub_80A142E() * 360.0);
      a1 = sub_80A1410();
      if ( a1 < 0.33000001 )
      {
        a1 = sub_80A142E() * 360.0;
        v8 = (int)a1;
      }
    }
    *(_DWORD *)(a2 + 134408) = *(_DWORD *)(a2 + 452020) - 1;
    return SV_ClientThink(a1, (char *)a2, &s);
  }
  return result;
}

//----- (08094980) --------------------------------------------------------
int __usercall sub_8094980@<eax>(long double a1@<st0>)
{
  int result; // eax
  _DWORD *i; // [esp+10h] [ebp-8h]
  int v3; // [esp+14h] [ebp-4h]

  sub_80905C8();
  v3 = 0;
  for ( i = dword_841FB0C; ; i += 123845 )
  {
    result = v3;
    if ( v3 >= *(_DWORD *)(sv_maxclients + 8) )
      break;
    if ( *i )
    {
      if ( !i[113009] )
        sub_809479A(a1, (int)i);
    }
    ++v3;
  }
  return result;
}
// 848B1CC: using guessed type int sv_maxclients;

//----- (080949DE) --------------------------------------------------------
void __usercall SV_Frame(long double a1@<st0>, int a2)
{
  char *v2; // eax
  char *v3; // eax
  char *v4; // eax
  char *v5; // eax
  char *v6; // eax
  char *v7; // eax
  char *v8; // eax
  char *v9; // eax
  char *v10; // eax
  char *v11; // eax
  char dest[76]; // [esp+20h] [ebp-58h] BYREF
  int v13; // [esp+6Ch] [ebp-Ch]

  if ( *((_BYTE *)off_815A498 + 221) )
  {
    if ( off_815A498 == (void *)-222 )
      Com_Shutdown(a1, "EXE_SERVERKILLED");
    else
      Com_Shutdown(a1, (const char *)off_815A498 + 222);
    *((_BYTE *)off_815A498 + 221) = 0;
  }
  else if ( *(_BYTE *)(com_sv_running + 8) )
  {
    if ( !SV_CheckPaused() )
    {
      v13 = 1000 / *(_DWORD *)(sv_fps + 8);
      dword_842BC90 += a2;
      if ( dword_842BC90 >= v13 )
      {
        if ( dword_841FB04 <= 1879048192 )
        {
          if ( dword_841FB18 < 2147483646 - dword_841FB10 )
          {
            if ( dword_841FB3C <= 2147467261 )
            {
              if ( dword_841FB40 <= 2147479549 )
              {
                if ( dword_841FB2C <= 2147482445 )
                {
                  if ( dword_841FB38 <= 2113929213 )
                  {
                    if ( dword_841FB44 <= 2147483133 )
                    {
                      if ( dword_841FB1C < 2147483646 - dword_841FB14 )
                      {
                        if ( (dvar_modifiedFlags & 0x404) != 0 )
                        {
                          v10 = Dvar_InfoString(0x404u);
                          SV_SetConfigstring(0, v10);
                          dvar_modifiedFlags &= 0xFFFFFBFB;
                        }
                        if ( (dvar_modifiedFlags & 8) != 0 )
                        {
                          v11 = Dvar_InfoString_Big(8u);
                          SV_SetConfigstring(1u, v11);
                          dvar_modifiedFlags &= ~8u;
                        }
                        if ( (dvar_modifiedFlags & 0x100) != 0 )
                        {
                          SV_SetConfig(142, 96, 0x100u);
                          dvar_modifiedFlags &= ~0x100u;
                        }
                        sub_8094980(a1);
                        SV_CalcPings();
                        while ( 1 )
                        {
                          dword_842BC90 -= v13;
                          dword_841FB04 += v13;
                          sub_8094780(a1);
                          sub_807F9F2(0);
                          if ( dword_842BC90 < v13 )
                            break;
                          SV_ArchiveSnapshot();
                        }
                        SV_CheckTimeouts(a1);
                        SV_SendClientMessages(a1);
                        SV_ArchiveSnapshot();
                        SV_MasterHeartbeat("COD-2");
                      }
                      else
                      {
                        I_strncpyz(dest, *(char **)(mapname + 8), 64);
                        Com_Shutdown(a1, aExeServerresta_0);
                        v9 = va("map %s\n", dest);
                        Cbuf_AddText(v9);
                      }
                    }
                    else
                    {
                      I_strncpyz(dest, *(char **)(mapname + 8), 64);
                      Com_Shutdown(a1, aExeServerresta_1);
                      v8 = va("map %s\n", dest);
                      Cbuf_AddText(v8);
                    }
                  }
                  else
                  {
                    I_strncpyz(dest, *(char **)(mapname + 8), 64);
                    Com_Shutdown(a1, aExeServerresta_2);
                    v7 = va("map %s\n", dest);
                    Cbuf_AddText(v7);
                  }
                }
                else
                {
                  I_strncpyz(dest, *(char **)(mapname + 8), 64);
                  Com_Shutdown(a1, aExeServerresta_3);
                  v6 = va("map %s\n", dest);
                  Cbuf_AddText(v6);
                }
              }
              else
              {
                I_strncpyz(dest, *(char **)(mapname + 8), 64);
                Com_Shutdown(a1, aExeServerresta_4);
                v5 = va("map %s\n", dest);
                Cbuf_AddText(v5);
              }
            }
            else
            {
              I_strncpyz(dest, *(char **)(mapname + 8), 64);
              Com_Shutdown(a1, aExeServerresta_5);
              v4 = va("map %s\n", dest);
              Cbuf_AddText(v4);
            }
          }
          else
          {
            I_strncpyz(dest, *(char **)(mapname + 8), 64);
            Com_Shutdown(a1, aExeServerresta_6);
            v3 = va("map %s\n", dest);
            Cbuf_AddText(v3);
          }
        }
        else
        {
          I_strncpyz(dest, *(char **)(mapname + 8), 64);
          Com_Shutdown(a1, "EXE_SERVERRESTARTTIMEWRAP");
          v2 = va("map %s\n", dest);
          Cbuf_AddText(v2);
        }
      }
    }
  }
}
// 815A498: using guessed type void *off_815A498;
// 819EF14: using guessed type int com_sv_running;
// 841FB10: using guessed type int dword_841FB10;
// 841FB14: using guessed type int dword_841FB14;
// 841FB18: using guessed type int dword_841FB18;
// 841FB1C: using guessed type int dword_841FB1C;
// 841FB2C: using guessed type int dword_841FB2C;
// 841FB38: using guessed type int dword_841FB38;
// 841FB3C: using guessed type int dword_841FB3C;
// 841FB40: using guessed type int dword_841FB40;
// 841FB44: using guessed type int dword_841FB44;
// 842BC90: using guessed type int dword_842BC90;
// 848B1B4: using guessed type int sv_fps;
// 848B1E0: using guessed type int mapname;
// 85178A8: using guessed type int dvar_modifiedFlags;

//----- (08094E38) --------------------------------------------------------
int *sub_8094E38()
{
  __int16 v0; // ax

  if ( !dword_848B660 )
  {
    Com_Printf("Resolving %s\n", "cod2master.activision.com");
    if ( NET_StringToAdr("cod2master.activision.com", &dword_848B660) )
    {
      if ( !strstr(":", "cod2master.activision.com") )
        word_848B668 = BigShort(20710);
      v0 = BigShort(word_848B668);
      Com_Printf(
        "cod2master.activision.com resolved to %i.%i.%i.%i:%i\n",
        (unsigned __int8)byte_848B664,
        (unsigned __int8)byte_848B665,
        (unsigned __int8)byte_848B666,
        (unsigned __int8)byte_848B667,
        v0);
    }
    else
    {
      Com_Printf("Couldn't resolve address: cod2master.activision.com\n");
    }
  }
  return &dword_848B660;
}
// 848B660: using guessed type int dword_848B660;
// 848B664: using guessed type char byte_848B664;
// 848B665: using guessed type char byte_848B665;
// 848B666: using guessed type char byte_848B666;
// 848B667: using guessed type char byte_848B667;
// 848B668: using guessed type __int16 word_848B668;

//----- (08094F02) --------------------------------------------------------
void __cdecl SV_MasterHeartbeat(const char *a1)
{
  char *v1; // eax
  int *v2; // [esp+24h] [ebp-4h]
  int *v3; // [esp+24h] [ebp-4h]

  if ( com_dedicated && *(_DWORD *)(com_dedicated + 8) == 2 )
  {
    if ( dword_841FB04 >= dword_841FB54 )
    {
      dword_841FB54 = dword_841FB04 + 180000;
      v2 = sub_8094E38();
      if ( *v2 != 1 )
      {
        Com_Printf("Sending heartbeat to cod2master.activision.com\n");
        v1 = va("heartbeat %s\n", a1);
        NET_OutOfBandPrint(1, *v2, v2[1], v2[2], v2[3], v2[4], v1);
      }
    }
    if ( dword_841FB04 >= dword_841FB58 )
    {
      dword_841FB58 = dword_841FB04 + 600000;
      v3 = sub_8094E38();
      if ( *v3 != 1 )
        SVC_Status(*v3, v3[1], v3[2], v3[3], v3[4]);
    }
  }
}
// 841FB54: using guessed type int dword_841FB54;
// 841FB58: using guessed type int dword_841FB58;
// 8494204: using guessed type int com_dedicated;

//----- (08094FFC) --------------------------------------------------------
void sub_8094FFC()
{
  int *v0; // [esp+14h] [ebp-4h]

  if ( com_dedicated && *(_DWORD *)(com_dedicated + 8) == 2 )
  {
    v0 = sub_8094E38();
    if ( *v0 != 1 )
    {
      Com_Printf("Sending gameCompleteStatus to cod2master.activision.com\n");
      sub_80936D4(*v0, v0[1], v0[2], v0[3], v0[4]);
    }
  }
}
// 8494204: using guessed type int com_dedicated;

//----- (0809505E) --------------------------------------------------------
void SV_MasterShutdown()
{
  dword_841FB54 = 0x80000000;
  SV_MasterHeartbeat("flatline");
}
// 841FB54: using guessed type int dword_841FB54;

//----- (0809507C) --------------------------------------------------------
_BOOL4 __cdecl sub_809507C(char *s)
{
  char v2[1323]; // [esp+30h] [ebp-538h] BYREF
  char v3; // [esp+55Bh] [ebp-Dh]
  int v4; // [esp+55Ch] [ebp-Ch]

  v4 = strlen(s);
  while ( v4 > 1294 )
  {
    v3 = s[1294];
    s[1294] = 0;
    Com_sprintf(v2, 0x514u, "print\n%s", s);
    NET_OutOfBandPrint(1, dword_842BB5C, dword_842BB60, *(int *)&dword_842BB64, dword_842BB68, dword_842BB6C, v2);
    v4 -= 1294;
    s += 1294;
    *s = v3;
  }
  Com_sprintf(v2, 0x514u, "print\n%s", s);
  return NET_OutOfBandPrint(1, dword_842BB5C, dword_842BB60, *(int *)&dword_842BB64, dword_842BB68, dword_842BB6C, v2);
}

//----- (080951B4) --------------------------------------------------------
int __usercall SVC_RemoteCommand@<eax>(long double a1@<st0>, int a2, int a3, int a4, int a5, int a6)
{
  int result; // eax
  char *v7; // ebx
  char *v8; // eax
  char *v9; // ebx
  char *v10; // eax
  char *v11; // eax
  char v12[16372]; // [esp+20h] [ebp-4418h] BYREF
  char *s1; // [esp+4014h] [ebp-424h]
  int v14; // [esp+4018h] [ebp-420h]
  int v15; // [esp+401Ch] [ebp-41Ch]
  char v16[1028]; // [esp+4020h] [ebp-418h] BYREF
  int v17; // [esp+4424h] [ebp-14h]
  signed int i; // [esp+4428h] [ebp-10h]
  int v19; // [esp+442Ch] [ebp-Ch]

  v17 = Com_Milliseconds();
  if ( !dword_848B674 || (result = v17 - dword_848B674, v17 - dword_848B674 > 499) )
  {
    dword_848B674 = v17;
    s1 = SV_Cmd_Argv(1u);
    if ( **(_BYTE **)(rcon_password + 8) && !strcmp(s1, *(const char **)(rcon_password + 8)) )
    {
      v19 = 1;
      v9 = SV_Cmd_Argv(2u);
      v10 = NET_AdrToString(a2, a3, a4, a5, a6);
      Com_Printf("Rcon from %s:\n%s\n", v10, v9);
    }
    else
    {
      v19 = 0;
      v7 = SV_Cmd_Argv(2u);
      v8 = NET_AdrToString(a2, a3, a4, a5, a6);
      Com_Printf("Bad rcon from %s:\n%s\n", v8, v7);
    }
    dword_842BB5C = a2;
    dword_842BB60 = a3;
    *(_DWORD *)&dword_842BB64 = a4;
    dword_842BB68 = a5;
    dword_842BB6C = a6;
    Com_BeginRedirect(v12, 16368, (int)sub_809507C);
    if ( **(_BYTE **)(rcon_password + 8) )
    {
      if ( v19 )
      {
        v15 = 0;
        v14 = 1024;
        for ( i = 2; i < SV_Cmd_Argc(); ++i )
        {
          v11 = SV_Cmd_Argv(i);
          v15 = sub_80626A8(v11, (int)v16, v15, v14, 1);
          v15 = sub_80626A8(" ", (int)v16, v15, v14, 0);
        }
        if ( v15 < v14 )
        {
          v16[v15] = 0;
          SV_Cmd_ExecuteString(a1, v16);
        }
      }
      else if ( *s1 )
      {
        Com_Printf("Invalid password.\n");
      }
      else
      {
        Com_Printf("You must log in with 'rcon login <password>' before using 'rcon'.\n");
      }
    }
    else
    {
      Com_Printf("The server must set 'rcon_password' for clients to use 'rcon'.\n");
    }
    return Com_EndRedirect();
  }
  return result;
}
// 848B1C0: using guessed type int rcon_password;
// 848B674: using guessed type int dword_848B674;
// 80951B4: using guessed type char var_4418[16372];
// 80951B4: using guessed type char var_418[1028];

//----- (0809544E) --------------------------------------------------------
void sub_809544E()
{
  ;
}

//----- (08095454) --------------------------------------------------------
int __cdecl sub_8095454(int a1, _BYTE *a2, int a3)
{
  int result; // eax
  int v4; // [esp+0h] [ebp-10h]
  _BYTE v5[5]; // [esp+7h] [ebp-9h]
  int i; // [esp+Ch] [ebp-4h]

  v4 = a1 + 133188;
  v5[4] = 0;
  *(_DWORD *)v5 = (unsigned __int8)(*(_BYTE *)(a1 + 133152) ^ *(_BYTE *)(a1 + 452020));
  for ( i = 0; ; ++i )
  {
    result = i;
    if ( i >= a3 )
      break;
    if ( !*(_BYTE *)(v4 + *(_DWORD *)&v5[1]) )
      *(_DWORD *)&v5[1] = 0;
    v5[0] ^= *(unsigned __int8 *)(v4 + (*(_DWORD *)&v5[1])++) << (i & 1);
    *a2++ ^= v5[0];
  }
  return result;
}

//----- (080954DE) --------------------------------------------------------
int __cdecl sub_80954DE(int a1, _BYTE *a2, int a3)
{
  int result; // eax
  int v4; // [esp+0h] [ebp-10h]
  _BYTE v5[5]; // [esp+7h] [ebp-9h]
  int i; // [esp+Ch] [ebp-4h]

  v4 = a1 + 1032 * (*(_DWORD *)(a1 + 133136) & 0x7F) + 1036;
  v5[4] = 0;
  *(_DWORD *)v5 = (unsigned __int8)(*(_BYTE *)(a1 + 133144) ^ *(_BYTE *)(a1 + 484864) ^ *(_BYTE *)(a1 + 133152));
  for ( i = 0; ; ++i )
  {
    result = i;
    if ( i >= a3 )
      break;
    if ( !*(_BYTE *)(v4 + *(_DWORD *)&v5[1]) )
      *(_DWORD *)&v5[1] = 0;
    v5[0] ^= *(unsigned __int8 *)(v4 + (*(_DWORD *)&v5[1])++) << (i & 1);
    *a2++ ^= v5[0];
  }
  return result;
}

//----- (0809558C) --------------------------------------------------------
_BOOL4 __cdecl SV_Netchan_TransmitNextFragment(int a1)
{
  return Netchan_TransmitNextFragment(a1);
}

//----- (080955A2) --------------------------------------------------------
_BOOL4 __cdecl sub_80955A2(int a1, _BYTE *src, int n)
{
  sub_8095454(a1, src + 4, n - 4);
  return Netchan_Transmit(a1 + 452020, n, src);
}

//----- (080955EA) --------------------------------------------------------
int __cdecl SV_Netchan_AddOOBProfilePacket(int a1)
{
  int result; // eax

  result = net_profile;
  if ( *(_DWORD *)(net_profile + 8) )
  {
    NetProf_PrepProfiling((void **)&dword_842BB84);
    return sub_806AF0A(dword_842BB84, a1, 0);
  }
  return result;
}
// 81F710C: using guessed type int net_profile;
// 842BB84: using guessed type int dword_842BB84;

//----- (08095626) --------------------------------------------------------
int __cdecl sub_8095626(size_t n, _DWORD *src, int a3, int a4, int a5, int a6, int a7)
{
  if ( *src != -1 )
    Com_Printf("SV_Netchan_SendOOBPacket used to send non-OOB packet.\n");
  NetProf_PrepProfiling((void **)&dword_842BB84);
  NET_SendPacket(1, n, src, a3, a4, a5, a6, a7);
  return SV_Netchan_AddOOBProfilePacket(n);
}
// 842BB84: using guessed type int dword_842BB84;
// 8095626: using guessed type int arg_10;

//----- (08095696) --------------------------------------------------------
int SV_Netchan_UpdateProfileStats()
{
  int result; // eax
  _DWORD **i; // [esp+10h] [ebp-8h]
  int v2; // [esp+14h] [ebp-4h]

  if ( dword_841FB0C )
  {
    if ( dword_842BB84 )
    {
      NetProf_UpdateStatistics((_DWORD *)dword_842BB84);
      NetProf_UpdateStatistics((_DWORD *)(dword_842BB84 + 752));
    }
    v2 = 0;
    for ( i = (_DWORD **)dword_841FB0C; ; i += 123845 )
    {
      result = v2;
      if ( v2 >= *(_DWORD *)(sv_maxclients + 8) )
        break;
      if ( *i )
      {
        if ( i[121212] )
        {
          NetProf_UpdateStatistics(i[121212]);
          NetProf_UpdateStatistics(i[121212] + 188);
        }
      }
      ++v2;
    }
  }
  return result;
}
// 842BB84: using guessed type int dword_842BB84;
// 848B1CC: using guessed type int sv_maxclients;

//----- (08095742) --------------------------------------------------------
int __cdecl SV_Netchan_PrintProfileStats(int a1)
{
  long double v1; // fst7
  long double v2; // fst7
  long double v3; // fst7
  long double v4; // fst7
  int result; // eax
  long double v6; // fst7
  long double v7; // fst7
  float v8; // [esp+0h] [ebp-4E8h]
  float v9; // [esp+0h] [ebp-4E8h]
  float v10; // [esp+0h] [ebp-4E8h]
  float v11; // [esp+0h] [ebp-4E8h]
  float v12; // [esp+0h] [ebp-4E8h]
  float v13; // [esp+0h] [ebp-4E8h]
  float v14; // [esp+4h] [ebp-4E4h]
  float v15; // [esp+4h] [ebp-4E4h]
  float v16; // [esp+4h] [ebp-4E4h]
  float v17; // [esp+4h] [ebp-4E4h]
  float v18; // [esp+4h] [ebp-4E4h]
  float v19; // [esp+4h] [ebp-4E4h]
  int v20; // [esp+2Ch] [ebp-4BCh]
  double v21; // [esp+30h] [ebp-4B8h]
  double v22; // [esp+60h] [ebp-488h]
  double v23; // [esp+68h] [ebp-480h]
  int v24; // [esp+74h] [ebp-474h]
  double v25; // [esp+78h] [ebp-470h]
  char s[1024]; // [esp+80h] [ebp-468h] BYREF
  char dest[40]; // [esp+480h] [ebp-68h] BYREF
  char *i; // [esp+4A8h] [ebp-40h]
  _DWORD *v29; // [esp+4ACh] [ebp-3Ch]
  int v30; // [esp+4B0h] [ebp-38h]
  int v31; // [esp+4B4h] [ebp-34h]
  int v32; // [esp+4B8h] [ebp-30h]
  int v33; // [esp+4BCh] [ebp-2Ch]
  int v34; // [esp+4C0h] [ebp-28h]
  int v35; // [esp+4C4h] [ebp-24h]
  int v36; // [esp+4C8h] [ebp-20h]
  int v37; // [esp+4CCh] [ebp-1Ch]
  int v38; // [esp+4D0h] [ebp-18h]
  int v39; // [esp+4D4h] [ebp-14h]
  char v40[4]; // [esp+4D8h] [ebp-10h]
  int v41[3]; // [esp+4DCh] [ebp-Ch]

  *(_DWORD *)v40 = 0;
  v39 = 0;
  v38 = 0;
  v37 = 0;
  v36 = 0;
  v35 = 0;
  v34 = 0;
  v33 = 9999;
  v32 = 0;
  v31 = 9999;
  if ( dword_841FB0C )
  {
    SV_Netchan_UpdateProfileStats();
    if ( a1 )
      Com_Printf("\n\n");
    Com_sprintf(s, 0x400u, "====================");
    if ( a1 )
      Com_Printf("%s\n", s);
    Com_sprintf(s, 0x400u, "Server Network Profile:");
    if ( a1 )
      Com_Printf("%s\n\n", s);
    Com_sprintf(
      s,
      0x400u,
      "                    | Sent To                | Recieved From          | Total Source Traffic   |");
    if ( a1 )
      Com_Printf("%s\n", s);
    Com_sprintf(
      s,
      0x400u,
      "              Source|   bps|  max|  min|frag%%|   bps|  max|  min|frag%%|   bps|  max|  min|frag%%|");
    if ( a1 )
      Com_Printf("%s\n", s);
    if ( dword_842BB84 )
    {
      v29 = (_DWORD *)dword_842BB84;
      *(_DWORD *)v40 += *(_DWORD *)(dword_842BB84 + 724);
      v38 += *(_DWORD *)(dword_842BB84 + 732);
      v37 += *(_DWORD *)(dword_842BB84 + 736);
      v39 += *(_DWORD *)(dword_842BB84 + 1476);
      v36 += *(_DWORD *)(dword_842BB84 + 1484);
      v35 += *(_DWORD *)(dword_842BB84 + 1488);
      if ( *(_DWORD *)(dword_842BB84 + 744) > v34 )
        v34 = v29[186];
      if ( v29[187] < v33 )
        v33 = v29[187];
      if ( v29[374] > v32 )
        v32 = v29[374];
      if ( v29[375] < v31 )
        v31 = v29[375];
    }
    v41[0] = 0;
    i = (char *)dword_841FB0C;
    while ( v41[0] < *(_DWORD *)(sv_maxclients + 8) )
    {
      if ( *(_DWORD *)i && *((_DWORD *)i + 121212) )
      {
        v29 = (_DWORD *)*((_DWORD *)i + 121212);
        *(_DWORD *)v40 += v29[181];
        v38 += v29[183];
        v37 += v29[184];
        v39 += v29[369];
        v36 += v29[371];
        v35 += v29[372];
        if ( v29[186] > v34 )
          v34 = v29[186];
        if ( v29[187] < v33 )
          v33 = v29[187];
        if ( v29[374] > v32 )
          v32 = v29[374];
        if ( v29[375] < v31 )
          v31 = v29[375];
      }
      ++v41[0];
      i += 495380;
    }
    if ( v38 + v36 <= 0 || v37 + v35 <= 0 )
      v30 = 0;
    else
      v30 = 100 * (v35 + v37) / (v36 + v38);
    v14 = (float)v31;
    v1 = (long double)v33;
    v8 = v1;
    sub_80960DE(v8, v14);
    v25 = v1;
    v15 = (float)v32;
    v2 = (long double)v34;
    v9 = v2;
    sub_80960BA(v9, v15);
    v21 = v2;
    v20 = *(_DWORD *)v40 + v39;
    if ( v36 )
      v24 = 100 * v35 / v36;
    else
      v24 = 0;
    if ( v38 )
      Com_sprintf(
        s,
        0x400u,
        "              Totals:%6i|%5i|%5i| %3i%%|%6i|%5i|%5i| %3i%%|%6i|%5i|%5i| %3i%%|",
        *(_DWORD *)v40,
        v34,
        v33,
        100 * v37 / v38,
        v39,
        v32,
        v31,
        v24,
        v20,
        LODWORD(v21),
        HIDWORD(v21),
        LODWORD(v25));
    else
      Com_sprintf(
        s,
        0x400u,
        "              Totals:%6i|%5i|%5i| %3i%%|%6i|%5i|%5i| %3i%%|%6i|%5i|%5i| %3i%%|",
        *(_DWORD *)v40,
        v34,
        v33,
        0,
        v39,
        v32,
        v31,
        v24,
        v20,
        LODWORD(v21),
        HIDWORD(v21),
        LODWORD(v25));
    if ( a1 )
      Com_Printf("%s\n", s);
    if ( dword_842BB84 )
    {
      v29 = (_DWORD *)dword_842BB84;
      if ( *(_DWORD *)(dword_842BB84 + 732) + *(_DWORD *)(dword_842BB84 + 1484) <= 0 || v29[184] + v29[372] <= 0 )
        v30 = 0;
      else
        v30 = 100 * (v29[372] + v29[184]) / (v29[371] + v29[183]);
      v16 = (float)(int)v29[375];
      v3 = (long double)(int)v29[187];
      v10 = v3;
      sub_80960DE(v10, v16);
      v23 = v3;
      v17 = (float)(int)v29[374];
      v4 = (long double)(int)v29[186];
      v11 = v4;
      sub_80960BA(v11, v17);
      Com_sprintf(
        s,
        0x400u,
        "  OutOfBand Messages: %5i|%5i|%5i| %3i%%| %5i|%5i|%5i| %3i%%| %5i|%5i|%5i| %3i%%|",
        v29[181],
        v29[186],
        v29[187],
        v29[185],
        v29[369],
        v29[374],
        v29[375],
        v29[373],
        v29[181] + v29[369],
        (unsigned int)COERCE_UNSIGNED_INT64(v4),
        (_DWORD)HIDWORD(COERCE_UNSIGNED_INT64(v4)),
        LODWORD(v23));
      if ( !a1 )
        goto LABEL_55;
    }
    else
    {
      Com_sprintf(
        s,
        0x400u,
        "  OutOfBand Messages:     0|    0|    0|   - |     0|    0|    0|   - |     0|    0|    0|   - |");
      if ( !a1 )
      {
LABEL_55:
        v41[0] = 0;
        for ( i = (char *)dword_841FB0C; ; i += 495380 )
        {
          result = v41[0];
          if ( v41[0] >= *(_DWORD *)(sv_maxclients + 8) )
            return result;
          if ( *(_DWORD *)i )
          {
            strncpy(dest, i + 134216, 0x11u);
            dest[16] = 0;
            v29 = (_DWORD *)*((_DWORD *)i + 121212);
            if ( !v29 )
            {
              Com_sprintf(
                s,
                0x400u,
                "#%2i-%16s:     0|    0|    0|   0%%|     0|    0|    0|   0%%|     0|    0|    0|   0%%|",
                v41[0],
                dest);
              if ( !a1 )
                goto LABEL_67;
LABEL_66:
              Com_Printf("%s\n", s);
              goto LABEL_67;
            }
            if ( v29[183] + v29[371] <= 0 || v29[184] + v29[372] <= 0 )
              v30 = 0;
            else
              v30 = 100 * (v29[372] + v29[184]) / (v29[371] + v29[183]);
            v18 = (float)(int)v29[375];
            v6 = (long double)(int)v29[187];
            v12 = v6;
            sub_80960DE(v12, v18);
            v22 = v6;
            v19 = (float)(int)v29[374];
            v7 = (long double)(int)v29[186];
            v13 = v7;
            sub_80960BA(v13, v19);
            Com_sprintf(
              s,
              0x400u,
              "#%2i-%16s: %5i|%5i|%5i| %3i%%| %5i|%5i|%5i| %3i%%| %5i|%5i|%5i| %3i%%|",
              v41[0],
              dest,
              v29[181],
              v29[186],
              v29[187],
              v29[185],
              v29[369],
              v29[374],
              v29[375],
              v29[373],
              v29[181] + v29[369],
              (unsigned int)COERCE_UNSIGNED_INT64(v7),
              (_DWORD)HIDWORD(COERCE_UNSIGNED_INT64(v7)),
              LODWORD(v22));
            if ( a1 )
              goto LABEL_66;
          }
LABEL_67:
          ++v41[0];
        }
      }
    }
    Com_Printf("%s\n", s);
    goto LABEL_55;
  }
  return result;
}
// 842BB84: using guessed type int dword_842BB84;
// 848B1CC: using guessed type int sv_maxclients;
// 8095742: using guessed type int var_C[3];

//----- (080960BA) --------------------------------------------------------
void __cdecl sub_80960BA(float a1, float a2)
{
  float v2; // [esp+0h] [ebp-18h]

  v2 = a1 - a2;
  sub_8096102(v2, a1, a2);
}

//----- (080960DE) --------------------------------------------------------
void __cdecl sub_80960DE(float a1, float a2)
{
  float v2; // [esp+0h] [ebp-18h]

  v2 = a2 - a1;
  sub_8096102(v2, a1, a2);
}

//----- (08096102) --------------------------------------------------------
long double __cdecl sub_8096102(float a1, float a2, float a3)
{
  if ( a1 < 0.0 )
    return a3;
  return a2;
}

//----- (0809612C) --------------------------------------------------------
int __cdecl sub_809612C(int a1, int a2, int a3, int a4, int a5, _DWORD *a6)
{
  int v7; // [esp+10h] [ebp-18h]
  int v8; // [esp+14h] [ebp-14h]
  int v9; // [esp+18h] [ebp-10h]
  int v10; // [esp+1Ch] [ebp-Ch]
  int *v11; // [esp+20h] [ebp-8h]
  int *v12; // [esp+24h] [ebp-4h]

  v11 = 0;
  v12 = 0;
  v9 = 0;
  v10 = 0;
  while ( v9 < a4 || v10 < a2 )
  {
    if ( v9 < a4 )
    {
      v11 = (int *)(dword_841FB20 + 240 * ((a5 + v9) % dword_841FB10));
      v7 = *v11;
    }
    else
    {
      v7 = 9999;
    }
    if ( v10 < a2 )
    {
      v12 = (int *)(dword_841FB20 + 240 * ((a3 + v10) % dword_841FB10));
      v8 = *v12;
    }
    else
    {
      v8 = 9999;
    }
    if ( v7 == v8 )
    {
      MSG_WriteDeltaEntity(a6, v12, v11, 0);
      ++v10;
      ++v9;
    }
    else if ( v7 >= v8 )
    {
      if ( v7 > v8 )
      {
        MSG_WriteDeltaEntity(a6, v12, 0, 1);
        ++v10;
      }
    }
    else
    {
      MSG_WriteDeltaEntity(a6, (int *)(372 * v7 + 138600604), v11, 1);
      ++v9;
    }
  }
  return MSG_WriteBits(a6, 1023, 10);
}
// 841FB10: using guessed type int dword_841FB10;
// 841FB20: using guessed type int dword_841FB20;

//----- (080962A0) --------------------------------------------------------
_DWORD *__cdecl sub_80962A0(int a1, int a2, int a3, int a4, int a5, _DWORD *a6)
{
  int v7; // [esp+10h] [ebp-18h]
  int v8; // [esp+14h] [ebp-14h]
  int v9; // [esp+18h] [ebp-10h]
  int v10; // [esp+1Ch] [ebp-Ch]
  int *v11; // [esp+20h] [ebp-8h]
  int *v12; // [esp+24h] [ebp-4h]

  v11 = 0;
  v12 = 0;
  v9 = 0;
  v10 = 0;
  while ( v9 < a4 || v10 < a2 )
  {
    if ( v9 < a4 )
    {
      v11 = (int *)(dword_841FB24 + 92 * ((a5 + v9) % dword_841FB14));
      v7 = *v11;
    }
    else
    {
      v7 = 9999;
    }
    if ( v10 < a2 )
    {
      v12 = (int *)(dword_841FB24 + 92 * ((a3 + v10) % dword_841FB14));
      v8 = *v12;
    }
    else
    {
      v8 = 9999;
    }
    if ( v7 == v8 )
    {
      MSG_WriteDeltaClient(a6, v12, v11, 0);
      ++v10;
      ++v9;
    }
    else if ( v7 >= v8 )
    {
      if ( v7 > v8 )
      {
        MSG_WriteDeltaClient(a6, v12, 0, 1);
        ++v10;
      }
    }
    else
    {
      MSG_WriteDeltaClient(a6, 0, v11, 1);
      ++v9;
    }
  }
  return MSG_WriteBit0(a6);
}
// 841FB14: using guessed type int dword_841FB14;
// 841FB24: using guessed type int dword_841FB24;

//----- (080963EC) --------------------------------------------------------
int __cdecl sub_80963EC(int a1, _DWORD *a2)
{
  int result; // eax
  int v3; // [esp+24h] [ebp-24h]
  int v4; // [esp+28h] [ebp-20h]
  char v5; // [esp+34h] [ebp-14h]
  int i; // [esp+38h] [ebp-10h]
  int v7; // [esp+3Ch] [ebp-Ch]
  int v8; // [esp+40h] [ebp-8h]
  _DWORD *v9; // [esp+44h] [ebp-4h]

  v9 = (_DWORD *)(a1 + 9924 * (*(_DWORD *)(a1 + 452020) & 0x1F) + 134436);
  if ( *(int *)(a1 + 134408) > 0 && *(_DWORD *)a1 == 4 )
  {
    if ( *(_DWORD *)(a1 + 452020) - *(_DWORD *)(a1 + 134408) <= 28 )
    {
      v8 = a1 + 9924 * (*(_DWORD *)(a1 + 134408) & 0x1F) + 134436;
      v7 = *(_DWORD *)(a1 + 452020) - *(_DWORD *)(a1 + 134408);
      if ( *(_DWORD *)(a1 + 9924 * (*(_DWORD *)(a1 + 134408) & 0x1F) + 144340) < dword_841FB18 - dword_841FB10 )
      {
        Com_DPrintf("%s: Delta request from out of date entities.\n", (const char *)(a1 + 134216));
        v8 = 0;
        LOBYTE(v7) = 0;
      }
    }
    else
    {
      Com_DPrintf("%s: Delta request from out of date packet.\n", (const char *)(a1 + 134216));
      v8 = 0;
      LOBYTE(v7) = 0;
    }
  }
  else
  {
    v8 = 0;
    LOBYTE(v7) = 0;
  }
  MSG_WriteByte(a2, 6);
  MSG_WriteLong(a2, dword_841FB04);
  MSG_WriteByte(a2, v7);
  v5 = dword_841FB08;
  if ( *(_DWORD *)(a1 + 134428) )
    v5 = dword_841FB08 | 1;
  if ( *(_DWORD *)a1 == 4 )
  {
    *(_DWORD *)(a1 + 4) = 1;
  }
  else if ( *(_DWORD *)a1 != 1 )
  {
    *(_DWORD *)(a1 + 4) = 0;
  }
  if ( !*(_DWORD *)(a1 + 4) )
    v5 |= 2u;
  MSG_WriteByte(a2, v5);
  if ( v8 )
  {
    MSG_WriteDeltaPlayerstate(a2, (char *)v8, v9);
    v4 = *(_DWORD *)(v8 + 9900);
    v3 = *(_DWORD *)(v8 + 9908);
    sub_809612C(
      -1653759219 * ((a1 - (int)dword_841FB0C) >> 2),
      *(_DWORD *)(v8 + 9896),
      *(_DWORD *)(v8 + 9904),
      v9[2474],
      v9[2476],
      a2);
  }
  else
  {
    MSG_WriteDeltaPlayerstate(a2, 0, v9);
    v4 = 0;
    v3 = 0;
    sub_809612C(-1653759219 * ((a1 - (int)dword_841FB0C) >> 2), 0, 0, v9[2474], v9[2476], a2);
  }
  sub_80962A0(-1653759219 * ((a1 - (int)dword_841FB0C) >> 2), v4, v3, v9[2475], v9[2477], a2);
  for ( i = 0; ; ++i )
  {
    result = i;
    if ( i >= *(_DWORD *)(sv_padPackets + 8) )
      break;
    MSG_WriteByte(a2, 0);
  }
  return result;
}
// 841FB08: using guessed type int dword_841FB08;
// 841FB10: using guessed type int dword_841FB10;
// 841FB18: using guessed type int dword_841FB18;
// 848B1DC: using guessed type int sv_padPackets;

//----- (080966D6) --------------------------------------------------------
int __cdecl SV_UpdateServerCommandsToClient(int a1, _DWORD *a2)
{
  int result; // eax
  int i; // [esp+14h] [ebp-4h]

  if ( *(_DWORD *)(a1 + 133136) + 1 < *(_DWORD *)(a1 + 133132) && *(_BYTE *)(sv_debugReliableCmds + 8) )
    Com_Printf("Client %s has the following un-ack'd reliable commands:\n", (const char *)(a1 + 134216));
  for ( i = *(_DWORD *)(a1 + 133136) + 1; i <= *(_DWORD *)(a1 + 133132); ++i )
  {
    MSG_WriteByte(a2, 4);
    MSG_WriteLong(a2, i);
    MSG_WriteString(a2, (char *)(a1 + 1032 * (i & 0x7F) + 1036));
    if ( *(_BYTE *)(sv_debugReliableCmds + 8) )
      Com_Printf("%i: %s\n", i - *(_DWORD *)(a1 + 133136) - 1, (const char *)(a1 + 1032 * (i & 0x7F) + 1036));
  }
  result = a1;
  *(_DWORD *)(a1 + 133140) = *(_DWORD *)(a1 + 133132);
  return result;
}
// 848B1FC: using guessed type int sv_debugReliableCmds;

//----- (080967E4) --------------------------------------------------------
int __cdecl sub_80967E4(_DWORD *a1, _DWORD *a2, signed int a3)
{
  int result; // eax
  int i; // [esp+14h] [ebp-4h]
  int v5; // [esp+14h] [ebp-4h]

  for ( i = a1[33284] + 1; i <= a1[33283] && (int)(a2[3] + strlen((const char *)&a1[258 * (i & 0x7F) + 259]) + 6) < a3; ++i )
  {
    MSG_WriteByte(a2, 4);
    MSG_WriteLong(a2, i);
    MSG_WriteString(a2, (char *)&a1[258 * (i & 0x7F) + 259]);
  }
  v5 = i - 1;
  result = v5;
  if ( v5 > a1[33285] )
  {
    result = v5;
    a1[33285] = v5;
  }
  return result;
}

//----- (080968B8) --------------------------------------------------------
void __cdecl SV_ShowClientUnAckCommands(int a1)
{
  int i; // [esp+14h] [ebp-4h]

  Com_Printf(
    "-- Unacknowledged Server Commands for client %i:%s --\n",
    -1653759219 * ((a1 - (int)dword_841FB0C) >> 2),
    (const char *)(a1 + 134216));
  for ( i = *(_DWORD *)(a1 + 133136) + 1; i <= *(_DWORD *)(a1 + 133132); ++i )
    Com_Printf(
      "cmd %5d: %8d: %s\n",
      i,
      *(_DWORD *)(a1 + 1032 * (i & 0x7F) + 2060),
      (const char *)(a1 + 1032 * (i & 0x7F) + 1036));
  Com_Printf("----------");
}

//----- (08096970) --------------------------------------------------------
_DWORD *__cdecl sub_8096970(int a1, _DWORD *a2)
{
  _DWORD *result; // eax

  result = a2;
  if ( *a2 != 1024 )
  {
    a2[*a2 + 1] = a1;
    result = a2;
    ++*a2;
  }
  return result;
}

//----- (08096996) --------------------------------------------------------
_DWORD *__cdecl sub_8096996(int a1, _DWORD *a2)
{
  _DWORD *result; // eax

  result = a2;
  if ( *a2 != 1024 )
  {
    a2[*a2 + 1] = a1;
    result = a2;
    ++*a2;
  }
  return result;
}

//----- (080969BC) --------------------------------------------------------
int __cdecl sub_80969BC(float *a1, int a2, _DWORD *a3)
{
  int result; // eax
  float v4; // [esp+10h] [ebp-28h]
  int v5; // [esp+14h] [ebp-24h]
  char *v6; // [esp+1Ch] [ebp-1Ch]
  int v7; // [esp+24h] [ebp-14h]
  int v8; // [esp+28h] [ebp-10h]
  int v9; // [esp+2Ch] [ebp-Ch]
  int j; // [esp+30h] [ebp-8h]
  int i; // [esp+34h] [ebp-4h]

  v5 = sub_8058A2C(a1);
  result = sub_80524F4(v5);
  if ( result >= 0 )
  {
    v6 = sub_8058F82(result);
    v4 = sub_8106976();
    if ( v4 == 3.4028235e38 )
      v4 = 0.0;
    for ( i = 0; ; ++i )
    {
      result = i;
      if ( i >= dword_848B0A4 )
        return result;
      v9 = SV_GentityNum(i);
      if ( *(_BYTE *)(v9 + 240) && i != a2 )
      {
        if ( *(_DWORD *)(v9 + 256) )
        {
          if ( *(int *)(v9 + 256) < 0 || *(_DWORD *)(v9 + 256) - dword_841FB04 >= 0 )
            goto LABEL_30;
          *(_DWORD *)(v9 + 256) = 0;
        }
        else if ( (*(_BYTE *)(v9 + 242) & 1) != 0 || ((*(int *)(v9 + 4 * (a2 >> 5) + 244) >> (a2 & 0x1F)) & 1) != 0 )
        {
          continue;
        }
        if ( (*(_BYTE *)(v9 + 242) & 0x18) != 0 )
          goto LABEL_30;
        v8 = sub_808FE20((_DWORD *)v9);
        if ( *(_DWORD *)(v8 + 280) )
        {
          v7 = 0;
          for ( j = 0; j < *(_DWORD *)(v8 + 280); ++j )
          {
            v7 = *(_DWORD *)(v8 + 4 * j + 284);
            if ( (((int)(unsigned __int8)v6[v7 >> 3] >> (v7 & 7)) & 1) != 0 )
              break;
          }
          if ( j != *(_DWORD *)(v8 + 280) )
            goto LABEL_34;
          if ( *(_DWORD *)(v8 + 348) )
          {
            while ( v7 <= *(_DWORD *)(v8 + 348) && (((int)(unsigned __int8)v6[v7 >> 3] >> (v7 & 7)) & 1) == 0 )
              ++v7;
            if ( v7 != *(_DWORD *)(v8 + 348) )
            {
LABEL_34:
              if ( v4 == 0.0 || !sub_80A831C((float *)(v9 + 288), (float *)(v9 + 300), a1, v4) )
              {
LABEL_30:
                sub_8096970(i, a3);
                continue;
              }
            }
          }
        }
      }
    }
  }
  return result;
}
// 848B0A4: using guessed type int dword_848B0A4;

//----- (08096C56) --------------------------------------------------------
int __cdecl sub_8096C56(int a1, int a2, float *a3, int a4, _DWORD *a5)
{
  int result; // eax
  float v6; // [esp+30h] [ebp-238h]
  int v7; // [esp+34h] [ebp-234h]
  int v8; // [esp+38h] [ebp-230h]
  int v9; // [esp+3Ch] [ebp-22Ch] BYREF
  int v10[130]; // [esp+40h] [ebp-228h] BYREF
  int v11; // [esp+248h] [ebp-20h]
  char *v12; // [esp+24Ch] [ebp-1Ch]
  int v13; // [esp+250h] [ebp-18h]
  float *v14; // [esp+254h] [ebp-14h]
  int j; // [esp+258h] [ebp-10h]
  int i; // [esp+25Ch] [ebp-Ch]

  v7 = sub_8058A2C(a3);
  result = sub_80524F4(v7);
  v13 = result;
  if ( result >= 0 )
  {
    v12 = sub_8058F82(v13);
    v6 = sub_8106976();
    if ( v6 == 3.4028235e38 )
      v6 = 0.0;
    for ( i = 0; ; ++i )
    {
      result = i;
      if ( i >= a1 )
        break;
      v14 = (float *)((char *)dword_841FB48 + 276 * ((i + a2) % 0x4000));
      if ( ((SLODWORD(v14[(a4 >> 5) + 61]) >> (a4 & 0x1F)) & 1) == 0 && *(_DWORD *)v14 != a4 )
      {
        if ( ((_DWORD)v14[60] & 0x18) != 0 )
          goto LABEL_18;
        v11 = sub_8058B66((_DWORD *)v14 + 63, (_DWORD *)v14 + 66, (int)v10, 128, &v9);
        if ( v11 )
        {
          for ( j = 0; j < v11; ++j )
          {
            v8 = sub_80524F4(v10[j]);
            if ( v8 != -1 && (((int)(unsigned __int8)v12[v8 >> 3] >> (v8 & 7)) & 1) != 0 )
              break;
          }
          if ( j != v11 && (v6 == 0.0 || !sub_80A831C(v14 + 63, v14 + 66, a3, v6)) )
LABEL_18:
            sub_8096996(i, a5);
        }
      }
    }
  }
  return result;
}
// 8096C56: using guessed type int var_228[130];

//----- (08096E9E) --------------------------------------------------------
_DWORD *__cdecl sub_8096E9E(int a1)
{
  _DWORD *v1; // ebx
  int *v3; // [esp+1Ch] [ebp-ECh]
  _DWORD *v4; // [esp+28h] [ebp-E0h]
  int *v5; // [esp+3Ch] [ebp-CCh]
  int *v6; // [esp+50h] [ebp-B8h]
  _DWORD *v7; // [esp+6Ch] [ebp-9Ch]
  char *v9; // [esp+8Ch] [ebp-7Ch]
  int v10[4]; // [esp+90h] [ebp-78h] BYREF
  int s; // [esp+A0h] [ebp-68h] BYREF
  void *dest; // [esp+A4h] [ebp-64h]
  size_t n; // [esp+ACh] [ebp-5Ch]
  int v14; // [esp+B0h] [ebp-58h]
  int v15; // [esp+C8h] [ebp-40h]
  int v16; // [esp+CCh] [ebp-3Ch]
  int v17; // [esp+D0h] [ebp-38h]
  int v18; // [esp+D4h] [ebp-34h]
  size_t v19; // [esp+D8h] [ebp-30h]
  int v20; // [esp+DCh] [ebp-2Ch]
  _DWORD *v21; // [esp+E0h] [ebp-28h]
  int v22; // [esp+E4h] [ebp-24h]
  int i; // [esp+E8h] [ebp-20h]
  int v24; // [esp+ECh] [ebp-1Ch]
  int v25; // [esp+F0h] [ebp-18h]
  void *v26; // [esp+F4h] [ebp-14h]
  int v27; // [esp+F8h] [ebp-10h]
  _DWORD *v28; // [esp+FCh] [ebp-Ch]

  LargeLocal(v10, 0x20000);
  v9 = LargeLocalGetBuf(v10);
  v21 = (char *)dword_841FB30 + 8 * (a1 % 1200);
  if ( *v21 < dword_841FB38 - 0x2000000 )
    goto LABEL_19;
  v18 = dword_841FB44 - 512;
  if ( dword_841FB44 - 512 < 0 )
    v18 = 0;
  for ( i = dword_841FB44 - 1; ; --i )
  {
    if ( i < v18 )
      goto LABEL_12;
    v28 = (char *)dword_841FB50 + 28 * (i % 512);
    if ( *v28 == a1 )
      break;
  }
  if ( v28[3] >= dword_841FB3C - 0x4000 && v28[5] >= dword_841FB40 - 4096 )
  {
LABEL_68:
    v1 = v28;
    LargeLocalDealloc(v10);
    return v1;
  }
LABEL_12:
  MSG_Init(&s, (int)v9, 0x20000);
  n = v21[1];
  v20 = *v21 % 0x2000000;
  v19 = 0x2000000 - v20;
  if ( (int)n > 0x2000000 - v20 )
  {
    memcpy(dest, (char *)dword_841FB34 + v20, v19);
    memcpy((char *)dest + v19, dword_841FB34, n - v19);
  }
  else
  {
    memcpy(dest, (char *)dword_841FB34 + v20, n);
  }
  if ( MSG_ReadBit(&s) )
  {
    v28 = (char *)dword_841FB50 + 28 * (dword_841FB44 % 512);
    *v28 = a1;
    v28[2] = 0;
    v28[3] = dword_841FB3C;
    v28[4] = 0;
    v28[5] = dword_841FB40;
    v28[6] = 0;
    v4 = v28;
    v4[1] = MSG_ReadLong(&s);
    while ( MSG_ReadBit(&s) )
    {
      v22 = MSG_ReadBits(&s, 6);
      if ( v14 > (int)n )
        Com_Error(1, (char *)&byte_8145200);
      v25 = (int)dword_841FB4C + 9992 * (dword_841FB40 % 4096);
      MSG_ReadDeltaClient(&s, 0, (void *)(v25 + 4), v22);
      v3 = (int *)v25;
      *v3 = MSG_ReadBit(&s);
      if ( *(_DWORD *)v25 )
        MSG_ReadDeltaPlayerstate(&s, 0, (char *)(v25 + 96));
      if ( ++dword_841FB40 > 2147483645 )
        Com_Error(0, (char *)&byte_8145240);
      ++v28[4];
    }
    while ( 1 )
    {
      v22 = MSG_ReadBits(&s, 10);
      if ( v22 == 1023 )
        break;
      if ( v14 > (int)n )
        Com_Error(1, (char *)&byte_8145200);
      v26 = (char *)dword_841FB48 + 276 * (dword_841FB3C % 0x4000);
      MSG_ReadDeltaArchivedEntity(&s, (void *)(372 * v22 + 138600604), v26, v22);
      if ( ++dword_841FB3C > 2147483645 )
        Com_Error(0, (char *)&byte_8145280);
      ++v28[2];
    }
    if ( ++dword_841FB44 > 2147483645 )
      Com_Error(0, (char *)&byte_81452C0);
    goto LABEL_68;
  }
  v17 = MSG_ReadLong(&s);
  if ( v17 >= dword_841FB2C - 1200 )
  {
    v21 = (char *)dword_841FB30 + 8 * (v17 % 1200);
    if ( *v21 >= dword_841FB38 - 0x2000000 )
    {
      v27 = sub_8096E9E(v17);
      if ( v27 )
      {
        v28 = (char *)dword_841FB50 + 28 * (dword_841FB44 % 512);
        *v28 = a1;
        v28[2] = 0;
        v28[3] = dword_841FB3C;
        v28[4] = 0;
        v28[5] = dword_841FB40;
        v28[6] = 1;
        v7 = v28;
        v7[1] = MSG_ReadLong(&s);
        v16 = 0;
        v24 = 0;
        if ( *(int *)(v27 + 16) > 0 )
        {
          v24 = (int)dword_841FB4C + 9992 * ((v16 + *(_DWORD *)(v27 + 20)) % 4096);
          v15 = *(_DWORD *)(v24 + 4);
        }
        else
        {
          v15 = 99999;
        }
        while ( MSG_ReadBit(&s) )
        {
          v22 = MSG_ReadBits(&s, 6);
          if ( v14 > (int)n )
            Com_Error(1, (char *)&byte_8145200);
          while ( v15 < v22 )
          {
            if ( ++v16 < *(_DWORD *)(v27 + 16) )
            {
              v24 = (int)dword_841FB4C + 9992 * ((v16 + *(_DWORD *)(v27 + 20)) % 4096);
              v15 = *(_DWORD *)(v24 + 4);
            }
            else
            {
              v15 = 99999;
            }
          }
          if ( v15 == v22 )
          {
            v25 = (int)dword_841FB4C + 9992 * (dword_841FB40 % 4096);
            MSG_ReadDeltaClient(&s, (char *)(v24 + 4), (void *)(v25 + 4), v22);
            v6 = (int *)v25;
            *v6 = MSG_ReadBit(&s);
            if ( *(_DWORD *)v25 )
              MSG_ReadDeltaPlayerstate(&s, (char *)(v24 + 96), (char *)(v25 + 96));
            if ( ++dword_841FB40 > 2147483645 )
              Com_Error(0, (char *)&byte_8145240);
            ++v28[4];
            if ( ++v16 < *(_DWORD *)(v27 + 16) )
            {
              v24 = (int)dword_841FB4C + 9992 * ((v16 + *(_DWORD *)(v27 + 20)) % 4096);
              v15 = *(_DWORD *)(v24 + 4);
            }
            else
            {
              v15 = 99999;
            }
          }
          else
          {
            v25 = (int)dword_841FB4C + 9992 * (dword_841FB40 % 4096);
            MSG_ReadDeltaClient(&s, 0, (void *)(v25 + 4), v22);
            v5 = (int *)v25;
            *v5 = MSG_ReadBit(&s);
            if ( *(_DWORD *)v25 )
              MSG_ReadDeltaPlayerstate(&s, 0, (char *)(v25 + 96));
            if ( ++dword_841FB40 > 2147483645 )
              Com_Error(0, (char *)&byte_8145240);
            ++v28[4];
          }
        }
        while ( 1 )
        {
          v22 = MSG_ReadBits(&s, 10);
          if ( v22 == 1023 )
            break;
          if ( v14 > (int)n )
            Com_Error(1, (char *)&byte_8145200);
          v26 = (char *)dword_841FB48 + 276 * (dword_841FB3C % 0x4000);
          MSG_ReadDeltaArchivedEntity(&s, (void *)(372 * v22 + 138600604), v26, v22);
          if ( ++dword_841FB3C > 2147483645 )
            Com_Error(0, (char *)&byte_8145280);
          ++v28[2];
        }
        if ( ++dword_841FB44 > 2147483645 )
          Com_Error(0, (char *)&byte_81452C0);
        goto LABEL_68;
      }
    }
  }
LABEL_19:
  LargeLocalDealloc(v10);
  return 0;
}
// 841FB2C: using guessed type int dword_841FB2C;
// 841FB38: using guessed type int dword_841FB38;
// 841FB3C: using guessed type int dword_841FB3C;
// 841FB40: using guessed type int dword_841FB40;
// 841FB44: using guessed type int dword_841FB44;
// 8096E9E: using guessed type int var_78[4];

//----- (08097A28) --------------------------------------------------------
_DWORD *__cdecl sub_8097A28(int *a1)
{
  int v1; // edx
  _DWORD *v4; // [esp+18h] [ebp-10h]
  int v5; // [esp+1Ch] [ebp-Ch]

  if ( !dword_841FB28 )
    return 0;
  if ( *a1 <= 0 )
    return 0;
  v1 = *(_DWORD *)(sv_fps + 8) * *a1 / 1000;
  v5 = dword_841FB2C - v1;
  if ( dword_841FB2C - v1 < dword_841FB2C - 1200 )
  {
    v5 = dword_841FB2C - 1200;
    *a1 = 1000 * (dword_841FB2C - (dword_841FB2C - 1200)) / *(_DWORD *)(sv_fps + 8);
  }
  if ( v5 < 0 )
  {
    v5 = 0;
    *a1 = 1000 * dword_841FB2C / *(_DWORD *)(sv_fps + 8);
  }
  while ( v5 < dword_841FB2C )
  {
    v4 = sub_8096E9E(v5);
    if ( v4 )
      return v4;
    ++v5;
  }
  *a1 = 0;
  return 0;
}
// 841FB28: using guessed type int dword_841FB28;
// 841FB2C: using guessed type int dword_841FB2C;
// 848B1B4: using guessed type int sv_fps;

//----- (08097B54) --------------------------------------------------------
int __cdecl sub_8097B54(int a1, _DWORD *a2, void *a3)
{
  if ( *((_DWORD *)dword_841FB0C + 123845 * a1) != 4 )
    return 0;
  if ( !sub_80F4696(a1, a2) )
    return 0;
  qmemcpy(a3, (const void *)sub_81069E2(a1), 0x5Cu);
  return 1;
}

//----- (08097BD0) --------------------------------------------------------
int __cdecl sub_8097BD0(int a1, int a2, int a3)
{
  long double v3; // fst7
  int v6; // [esp+30h] [ebp-2768h] BYREF
  int v7; // [esp+34h] [ebp-2764h]
  int v8; // [esp+38h] [ebp-2760h]
  int i; // [esp+3Ch] [ebp-275Ch]
  char v10[96]; // [esp+40h] [ebp-2758h] BYREF
  _DWORD v11[5]; // [esp+A0h] [ebp-26F8h] BYREF
  _BYTE v12[9898]; // [esp+B4h] [ebp-26E4h] BYREF
  char v13; // [esp+275Eh] [ebp-3Ah]
  char v14; // [esp+275Fh] [ebp-39h]
  float v15[4]; // [esp+2760h] [ebp-38h] BYREF
  float dest[4]; // [esp+2770h] [ebp-28h] BYREF
  int v17; // [esp+2780h] [ebp-18h]
  int v18; // [esp+2784h] [ebp-14h]
  float v19; // [esp+2788h] [ebp-10h]
  int j; // [esp+278Ch] [ebp-Ch]

  v8 = 1000 / *(_DWORD *)(sv_fps + 8);
  v7 = v8 * (dword_841FB04 / v8);
  v18 = v8 * (dword_815D6E0 + (v7 - a2) / v8);
  v17 = v8 * (dword_815D6E4 + (v7 - a2) / v8);
  v14 = 0;
  v13 = 0;
  v6 = v18;
  for ( i = 0; i <= 9; ++i )
  {
    if ( sub_8097EDA(a1, &v6, v11, v10) )
    {
      v14 = 1;
      v18 = v6;
      memcpy(dest, v12, 0xCu);
      break;
    }
    v6 += v8;
  }
  v6 = v17;
  for ( i = 0; i <= 9; ++i )
  {
    if ( sub_8097EDA(a1, &v6, v11, v10) )
    {
      v13 = 1;
      v17 = v6;
      memcpy(v15, v12, 0xCu);
      break;
    }
    v6 -= v8;
  }
  if ( v14 && v13 )
  {
    v19 = (long double)(a2 % v8) / (long double)(v18 - v17);
  }
  else if ( v14 )
  {
    v19 = 0.0;
    sub_8099D8A(v15);
  }
  else
  {
    if ( !v13 )
      return 0;
    v19 = 1.0;
    sub_8099D8A(dest);
  }
  for ( j = 0; j <= 2; ++j )
  {
    v3 = sub_8099D74(dest[j], v15[j], v19);
    *(float *)(a3 + 4 * j) = v3;
  }
  return 1;
}
// 815D6E0: using guessed type int dword_815D6E0;
// 815D6E4: using guessed type int dword_815D6E4;
// 848B1B4: using guessed type int sv_fps;
// 8097BD0: using guessed type _DWORD var_26F8[5];
// 8097BD0: using guessed type float dest[4];
// 8097BD0: using guessed type float var_38[4];

//----- (08097EDA) --------------------------------------------------------
int __cdecl sub_8097EDA(int a1, int *a2, _DWORD *a3, void *a4)
{
  unsigned int v5; // [esp+14h] [ebp-34h]
  _DWORD *v6; // [esp+18h] [ebp-30h]
  void *v7; // [esp+1Ch] [ebp-2Ch]
  _DWORD *v10; // [esp+30h] [ebp-18h]
  int v11; // [esp+34h] [ebp-14h]
  int i; // [esp+38h] [ebp-10h]
  unsigned int j; // [esp+38h] [ebp-10h]
  _DWORD *v14; // [esp+3Ch] [ebp-Ch]

  v14 = sub_8097A28(a2);
  if ( v14 )
  {
    v11 = dword_841FB04 - v14[1];
    for ( i = 0; ; ++i )
    {
      if ( i >= v14[4] )
        return 0;
      v10 = (char *)dword_841FB4C + 9992 * ((i + v14[5]) % 4096);
      if ( v10[1] == a1 )
        break;
    }
    if ( !*v10 )
      return 0;
    v7 = a3;
    v6 = v10 + 24;
    v5 = 9896;
    if ( ((unsigned __int8)a3 & 4) != 0 )
    {
      *a3 = *v6;
      v7 = a3 + 1;
      v6 = v10 + 25;
      v5 = 9892;
    }
    qmemcpy(v7, v6, 4 * (v5 >> 2));
    qmemcpy(a4, v10 + 1, 0x5Cu);
    if ( *a3 )
      *a3 += v11;
    if ( a3[4] )
      a3[4] += v11;
    if ( a3[17] )
      a3[17] += v11;
    if ( a3[28] )
      a3[28] += v11;
    if ( a3[63] )
      a3[63] += v11;
    if ( a3[375] )
      a3[375] += v11;
    for ( j = 0; j <= 0x1E; ++j )
    {
      if ( a3[32 * j + 1508] )
        a3[32 * j + 1508] += v11;
      if ( a3[32 * j + 1492] )
      {
        a3[32 * j + 1492] += v11;
        if ( a3[32 * j + 1492] > dword_841FB04 )
          a3[32 * j + 1492] = dword_841FB04;
      }
      if ( a3[32 * j + 1500] )
        a3[32 * j + 1500] += v11;
      if ( a3[32 * j + 1506] )
        a3[32 * j + 1506] += v11;
    }
    a3[489] += v11;
    return 1;
  }
  else if ( *a2 > 0 )
  {
    return 0;
  }
  else
  {
    return sub_8097B54(a1, a3, a4);
  }
}

//----- (0809822C) --------------------------------------------------------
int __cdecl SV_BuildClientSnapshot(char *a1)
{
  int result; // eax
  int v2; // [esp+24h] [ebp-1094h]
  unsigned int v3; // [esp+30h] [ebp-1088h]
  _DWORD *v4; // [esp+34h] [ebp-1084h]
  int v5; // [esp+38h] [ebp-1080h]
  int v6; // [esp+3Ch] [ebp-107Ch]
  int v7; // [esp+40h] [ebp-1078h] BYREF
  int v8; // [esp+44h] [ebp-1074h]
  int v9; // [esp+48h] [ebp-1070h]
  char *v10; // [esp+4Ch] [ebp-106Ch]
  _DWORD *v11; // [esp+50h] [ebp-1068h]
  float *v12; // [esp+54h] [ebp-1064h]
  unsigned int v13; // [esp+58h] [ebp-1060h]
  int v14; // [esp+5Ch] [ebp-105Ch]
  _DWORD *v15; // [esp+60h] [ebp-1058h]
  void *v16; // [esp+64h] [ebp-1054h]
  const void *v17; // [esp+68h] [ebp-1050h]
  int i; // [esp+6Ch] [ebp-104Ch]
  char v19[4]; // [esp+70h] [ebp-1048h] BYREF
  int v20[1030]; // [esp+74h] [ebp-1044h]
  char *v21; // [esp+108Ch] [ebp-2Ch]
  float v22[2]; // [esp+1090h] [ebp-28h] BYREF
  float v23; // [esp+1098h] [ebp-20h]
  int *j; // [esp+10C0h] [ebp+8h]

  v21 = &a1[9924 * (*((_DWORD *)a1 + 113005) & 0x1F) + 134436];
  *((_DWORD *)v21 + 2474) = 0;
  *((_DWORD *)v21 + 2475) = 0;
  result = *((_DWORD *)a1 + 33553);
  v14 = result;
  if ( result )
  {
    result = (int)a1;
    if ( *(_DWORD *)a1 != 1 )
    {
      *((_DWORD *)v21 + 2476) = dword_841FB18;
      result = dword_841FB1C;
      *((_DWORD *)v21 + 2477) = dword_841FB1C;
      if ( dword_842BC80 == 2 )
      {
        *(_DWORD *)v19 = 0;
        v13 = -1653759219 * ((a1 - (_BYTE *)dword_841FB0C) >> 2);
        v7 = sub_81069A6(v13);
        v11 = sub_8097A28(&v7);
        sub_81069C2(v13, v7);
        if ( v11 )
          v6 = dword_841FB04 - v11[1];
        else
          v6 = 0;
        v9 = v6;
        v12 = (float *)v21;
        v5 = (int)v21;
        v4 = (_DWORD *)SV_GameClientNum(v13);
        v3 = 9896;
        if ( (v5 & 4) != 0 )
        {
          *(_DWORD *)v5 = *v4;
          v5 += 4;
          ++v4;
          v3 = 9892;
        }
        qmemcpy((void *)v5, v4, 4 * (v3 >> 2));
        v13 = *((_DWORD *)v12 + 51);
        if ( v13 >= 0x400 )
          Com_Error(1, (char *)&byte_8145300);
        sub_8099DB4((_DWORD *)v12 + 5, v22);
        v23 = v23 + v12[62];
        sub_80B66C0(v22, *((_DWORD *)v12 + 59), v12[19], 16.0, 20.0);
        if ( v11 )
        {
          sub_8096C56(v11[2], v11[3], v22, v13, v19);
          for ( i = 0; i < *(int *)v19; ++i )
          {
            v10 = (char *)dword_841FB48 + 276 * ((v20[i] + v11[3]) % 0x4000);
            v16 = (void *)(dword_841FB20 + 240 * (dword_841FB18 % dword_841FB10));
            qmemcpy(v16, v10, 0xF0u);
            if ( *((_DWORD *)v16 + 4) )
              *((_DWORD *)v16 + 4) += v9;
            if ( *((_DWORD *)v16 + 13) )
              *((_DWORD *)v16 + 13) += v9;
            if ( *((_DWORD *)v16 + 21) )
              *((_DWORD *)v16 + 21) += v9;
            if ( *((_DWORD *)v16 + 22) )
              *((_DWORD *)v16 + 22) += v9;
            if ( ++dword_841FB18 > 2147483645 )
              Com_Error(0, (char *)&byte_8145340);
            ++*((_DWORD *)v21 + 2474);
          }
          for ( i = 0; ; ++i )
          {
            result = i;
            if ( i >= v11[4] )
              break;
            v2 = i + v11[5];
            v8 = (int)dword_841FB4C + 9992 * (v2 % 4096);
            v15 = (_DWORD *)(dword_841FB24 + 92 * (dword_841FB1C % dword_841FB14));
            qmemcpy(v15, (const void *)(v8 + 4), 0x5Cu);
            if ( ++dword_841FB1C > 2147483645 )
              Com_Error(0, (char *)&byte_8145380);
            ++*((_DWORD *)v21 + 2475);
          }
        }
        else
        {
          sub_80969BC(v22, v13, v19);
          for ( i = 0; i < *(int *)v19; ++i )
          {
            v17 = (const void *)SV_GentityNum(v20[i]);
            v16 = (void *)(dword_841FB20 + 240 * (dword_841FB18 % dword_841FB10));
            qmemcpy(v16, v17, 0xF0u);
            if ( ++dword_841FB18 > 2147483645 )
              Com_Error(0, (char *)&byte_8145340);
            ++*((_DWORD *)v21 + 2474);
          }
          i = 0;
          for ( j = (int *)dword_841FB0C; ; j += 123845 )
          {
            result = i;
            if ( i >= *(_DWORD *)(sv_maxclients + 8) )
              break;
            if ( *j > 1 )
            {
              v15 = (_DWORD *)(dword_841FB24 + 92 * (dword_841FB1C % dword_841FB14));
              qmemcpy(v15, (const void *)sub_81069E2(i), 0x5Cu);
              if ( *v15 == i )
              {
                if ( ++dword_841FB1C > 2147483645 )
                  Com_Error(0, (char *)&byte_8145380);
                ++*((_DWORD *)v21 + 2475);
              }
            }
            ++i;
          }
        }
      }
    }
  }
  return result;
}
// 841FB10: using guessed type int dword_841FB10;
// 841FB14: using guessed type int dword_841FB14;
// 841FB18: using guessed type int dword_841FB18;
// 841FB1C: using guessed type int dword_841FB1C;
// 841FB20: using guessed type int dword_841FB20;
// 841FB24: using guessed type int dword_841FB24;
// 842BC80: using guessed type int dword_842BC80;
// 848B1CC: using guessed type int sv_maxclients;
// 809822C: using guessed type float var_28[2];
// 809822C: using guessed type int var_1044[1030];

//----- (080988F4) --------------------------------------------------------
int __cdecl SV_RateMsec(int a1, int a2)
{
  int v3; // [esp+24h] [ebp-4h]

  if ( a2 > 1500 )
    a2 = 1500;
  v3 = *(_DWORD *)(a1 + 452008);
  if ( *(_DWORD *)(sv_maxRate + 8) )
  {
    if ( *(int *)(sv_maxRate + 8) <= 999 )
      Dvar_SetInt(sv_maxRate, (char *)0x3E8);
    if ( *(_DWORD *)(sv_maxRate + 8) < v3 )
      v3 = *(_DWORD *)(sv_maxRate + 8);
  }
  if ( *(_BYTE *)(sv_debugRate + 8) )
    Com_Printf(
      "It would take %ims to send %i bytes to client %s (rate %i)\n",
      (1000 * a2 + 48000) / v3,
      a2,
      (const char *)(a1 + 134216),
      *(_DWORD *)(a1 + 452008));
  return (1000 * a2 + 48000) / v3;
}
// 848B1E8: using guessed type int sv_maxRate;
// 848B1F8: using guessed type int sv_debugRate;

//----- (080989C6) --------------------------------------------------------
int __usercall SV_SendMessageToClient@<eax>(long double a1@<st0>, int a2, int a3)
{
  char *dest; // [esp+2Ch] [ebp-2Ch]
  int v5[6]; // [esp+30h] [ebp-28h] BYREF
  size_t n; // [esp+48h] [ebp-10h]
  int v7; // [esp+4Ch] [ebp-Ch]

  LargeLocal(v5, 0x4000);
  dest = LargeLocalGetBuf(v5);
  memcpy(dest, *(const void **)(a2 + 4), 4u);
  n = MSG_WriteBitsCompress((unsigned __int8 *)(*(_DWORD *)(a2 + 4) + 4), (int)(dest + 4), *(_DWORD *)(a2 + 12) - 4) + 4;
  if ( *(_DWORD *)(a3 + 8) )
    SV_DropClient(a1, a3, *(char **)(a3 + 8));
  *(_DWORD *)(a3 + 9924 * (*(_DWORD *)(a3 + 452020) & 0x1F) + 144356) = n;
  *(_DWORD *)(a3 + 9924 * (*(_DWORD *)(a3 + 452020) & 0x1F) + 144348) = dword_841FB04;
  *(_DWORD *)(a3 + 9924 * (*(_DWORD *)(a3 + 452020) & 0x1F) + 144352) = -1;
  sub_80955A2(a3, dest, n);
  if ( *(_DWORD *)(a3 + 452036) == 2 || Sys_IsLANAddress(*(_DWORD *)(a3 + 452036), *(_DWORD *)(a3 + 452040)) )
  {
    *(_DWORD *)(a3 + 134424) = dword_841FB04 - 1;
    return LargeLocalDealloc(v5);
  }
  else
  {
    v7 = SV_RateMsec(a3, n);
    if ( v7 >= *(_DWORD *)(a3 + 452012) )
    {
      *(_DWORD *)(a3 + 134428) = 1;
    }
    else
    {
      v7 = *(_DWORD *)(a3 + 452012);
      *(_DWORD *)(a3 + 134428) = 0;
    }
    *(_DWORD *)(a3 + 134424) = dword_841FB04 + v7;
    if ( *(_DWORD *)a3 != 4 && !*(_BYTE *)(a3 + 134248) && *(_DWORD *)(a3 + 134424) < dword_841FB04 + 1000 )
      *(_DWORD *)(a3 + 134424) = dword_841FB04 + 1000;
    dword_848B10C += n;
    return LargeLocalDealloc(v5);
  }
}
// 848B10C: using guessed type int dword_848B10C;
// 80989C6: using guessed type int var_28[6];

//----- (08098C0E) --------------------------------------------------------
int __usercall SV_SendClientSnapshot@<eax>(long double a1@<st0>, int a2)
{
  char *v3; // [esp+2Ch] [ebp-3Ch]
  int v4[4]; // [esp+30h] [ebp-38h] BYREF
  int s[10]; // [esp+40h] [ebp-28h] BYREF

  LargeLocal(v4, 0x20000);
  v3 = LargeLocalGetBuf(v4);
  if ( *(_DWORD *)a2 == 4 || *(_DWORD *)a2 == 1 )
    SV_BuildClientSnapshot((char *)a2);
  MSG_Init(s, (int)v3, 0x20000);
  MSG_WriteLong(s, *(_DWORD *)(a2 + 133184));
  if ( *(_DWORD *)a2 == 4 || *(_DWORD *)a2 == 1 )
  {
    SV_UpdateServerCommandsToClient(a2, s);
    sub_80963EC(a2, s);
  }
  if ( *(_DWORD *)a2 != 1 )
    SV_WriteDownloadToClient(a2, s);
  MSG_WriteByte(s, 7);
  if ( s[0] )
  {
    Com_Printf("WARNING: msg overflowed for %s, trying to recover\n", (const char *)(a2 + 134216));
    if ( *(_DWORD *)a2 == 4 || *(_DWORD *)a2 == 1 )
    {
      SV_ShowClientUnAckCommands(a2);
      MSG_Init(s, (int)v3, 0x20000);
      MSG_WriteLong(s, *(_DWORD *)(a2 + 133184));
      sub_80967E4((_DWORD *)a2, s, 0x20000);
      MSG_WriteByte(s, 7);
    }
    if ( s[0] )
    {
      Com_Printf("WARNING: client disconnected for msg overflow: %s\n", (const char *)(a2 + 134216));
      NET_OutOfBandPrint(
        1,
        *(_DWORD *)(a2 + 452036),
        *(_DWORD *)(a2 + 452040),
        *(_DWORD *)(a2 + 452044),
        *(_DWORD *)(a2 + 452048),
        *(_DWORD *)(a2 + 452052),
        "disconnect");
      SV_DropClient(a1, a2, "EXE_SERVERMESSAGEOVERFLOW");
    }
  }
  SV_SendMessageToClient(a1, (int)s, a2);
  return LargeLocalDealloc(v4);
}
// 8098C0E: using guessed type int var_38[4];

//----- (08098E3A) --------------------------------------------------------
int SV_ArchiveSnapshot()
{
  int *v0; // eax
  int *v1; // eax
  int *v3; // [esp+24h] [ebp-28A4h]
  char *v4; // [esp+4Ch] [ebp-287Ch]
  int v5[4]; // [esp+50h] [ebp-2878h] BYREF
  int s; // [esp+60h] [ebp-2868h] BYREF
  void *src; // [esp+64h] [ebp-2864h]
  size_t n; // [esp+6Ch] [ebp-285Ch]
  int v9; // [esp+88h] [ebp-2840h]
  int v10; // [esp+8Ch] [ebp-283Ch]
  int v11; // [esp+90h] [ebp-2838h]
  int v12; // [esp+94h] [ebp-2834h]
  int v13; // [esp+98h] [ebp-2830h]
  char v14[4]; // [esp+9Ch] [ebp-282Ch]
  int v15; // [esp+A0h] [ebp-2828h]
  int v16; // [esp+A4h] [ebp-2824h]
  int v17; // [esp+A8h] [ebp-2820h]
  int *v18; // [esp+ACh] [ebp-281Ch]
  _DWORD v19[2478]; // [esp+B0h] [ebp-2818h] BYREF
  size_t v20; // [esp+2768h] [ebp-160h]
  int v21; // [esp+276Ch] [ebp-15Ch]
  _DWORD *v22; // [esp+2770h] [ebp-158h]
  int *v23; // [esp+2774h] [ebp-154h]
  int i; // [esp+2778h] [ebp-150h]
  int v25; // [esp+277Ch] [ebp-14Ch]
  int v26[60]; // [esp+2780h] [ebp-148h] BYREF
  int v27; // [esp+2870h] [ebp-58h]
  int v28; // [esp+2874h] [ebp-54h]
  int v29; // [esp+2878h] [ebp-50h]
  int v30[3]; // [esp+287Ch] [ebp-4Ch] BYREF
  int v31[8]; // [esp+2888h] [ebp-40h] BYREF
  _DWORD *v32; // [esp+28A8h] [ebp-20h]
  int j; // [esp+28ACh] [ebp-1Ch]

  LargeLocal(v5, 0x20000);
  v4 = LargeLocalGetBuf(v5);
  if ( dword_842BC80 == 2 && dword_841FB28 )
  {
    MSG_Init(&s, (int)v4, 0x20000);
    v17 = dword_841FB44 - 512;
    if ( dword_841FB44 - 512 < 0 )
      v17 = 0;
    v16 = dword_841FB2C - *(_DWORD *)(sv_fps + 8);
    for ( i = dword_841FB44 - 1; i >= v17; --i )
    {
      v18 = (int *)((char *)dword_841FB50 + 28 * (i % 512));
      if ( *v18 >= v16 && !v18[6] )
      {
        if ( v18[3] >= dword_841FB3C - 0x4000 && v18[5] >= dword_841FB40 - 4096 )
        {
          MSG_WriteBit0(&s);
          MSG_WriteLong(&s, *v18);
          MSG_WriteLong(&s, dword_841FB04);
          v13 = *(_DWORD *)(sv_maxclients + 8);
          v12 = v18[4];
          v15 = 0;
          v11 = 0;
          v10 = 0;
          while ( v11 < v13 || v10 < v12 )
          {
            if ( v11 >= v13 || *((int *)dword_841FB0C + 123845 * v11) > 1 )
            {
              if ( v10 < v12 )
              {
                v15 = (int)dword_841FB4C + 9992 * ((v10 + v18[5]) % 4096);
                v9 = *(_DWORD *)(v15 + 4);
              }
              else
              {
                v9 = 9999;
              }
              if ( v11 == v9 )
              {
                v0 = (int *)sub_81069E2(v11);
                MSG_WriteDeltaClient(&s, (int *)(v15 + 4), v0, 1);
                if ( sub_80F4696(v11, v19) )
                {
                  MSG_WriteBit1(&s);
                  MSG_WriteDeltaPlayerstate(&s, (char *)(v15 + 96), v19);
                }
                else
                {
                  MSG_WriteBit0(&s);
                }
                ++v10;
                ++v11;
              }
              else if ( v11 >= v9 )
              {
                if ( v11 > v9 )
                  ++v10;
              }
              else
              {
                v1 = (int *)sub_81069E2(v11);
                MSG_WriteDeltaClient(&s, 0, v1, 1);
                if ( sub_80F4696(v11, v19) )
                {
                  MSG_WriteBit1(&s);
                  MSG_WriteDeltaPlayerstate(&s, 0, v19);
                }
                else
                {
                  MSG_WriteBit0(&s);
                }
                ++v11;
              }
            }
            else
            {
              ++v11;
            }
          }
          MSG_WriteBit0(&s);
          for ( j = 0; j < dword_848B0A4; ++j )
          {
            v32 = (_DWORD *)SV_GentityNum(j);
            if ( *((_BYTE *)v32 + 240) )
            {
              if ( v32[64]
                || (*((_BYTE *)v32 + 242) & 1) == 0
                && ((v25 = sub_808FE20(v32), (*((_BYTE *)v32 + 242) & 0x18) != 0) || *(_DWORD *)(v25 + 280)) )
              {
                qmemcpy(v26, v32, sizeof(v26));
                v27 = *((unsigned __int8 *)v32 + 242);
                if ( v32[64] )
                  v27 |= 8u;
                v28 = v32[61];
                v29 = v32[62];
                sub_8099DB4(v32 + 72, v30);
                sub_8099DB4(v32 + 75, v31);
                MSG_WriteDeltaArchivedEntity(&s, (int *)(372 * *v32 + 138600604), v26, 1);
              }
            }
          }
          goto LABEL_70;
        }
        break;
      }
    }
    MSG_WriteBit1(&s);
    MSG_WriteLong(&s, dword_841FB04);
    v18 = (int *)((char *)dword_841FB50 + 28 * (dword_841FB44 % 512));
    *v18 = dword_841FB2C;
    v18[2] = 0;
    v18[3] = dword_841FB3C;
    v18[4] = 0;
    v18[5] = dword_841FB40;
    v18[6] = 0;
    v18[1] = dword_841FB04;
    i = 0;
    v23 = (int *)dword_841FB0C;
    while ( i < *(_DWORD *)(sv_maxclients + 8) )
    {
      if ( *v23 > 1 )
      {
        v15 = (int)dword_841FB4C + 9992 * (dword_841FB40 % 4096);
        qmemcpy((void *)(v15 + 4), (const void *)sub_81069E2(i), 0x5Cu);
        MSG_WriteDeltaClient(&s, 0, (int *)(v15 + 4), 1);
        v3 = (int *)v15;
        *v3 = sub_80F4696(i, (_DWORD *)(v15 + 96));
        if ( *(_DWORD *)v15 )
        {
          MSG_WriteBit1(&s);
          MSG_WriteDeltaPlayerstate(&s, 0, (_DWORD *)(v15 + 96));
        }
        else
        {
          MSG_WriteBit0(&s);
        }
        if ( ++dword_841FB40 > 2147483645 )
          Com_Error(0, (char *)&byte_8145240);
        ++v18[4];
      }
      ++i;
      v23 += 123845;
    }
    MSG_WriteBit0(&s);
    for ( j = 0; j < dword_848B0A4; ++j )
    {
      v32 = (_DWORD *)SV_GentityNum(j);
      if ( *((_BYTE *)v32 + 240) )
      {
        if ( v32[64]
          || (*((_BYTE *)v32 + 242) & 1) == 0
          && ((v25 = sub_808FE20(v32), (*((_BYTE *)v32 + 242) & 0x18) != 0) || *(_DWORD *)(v25 + 280)) )
        {
          *(_DWORD *)v14 = (char *)dword_841FB48 + 276 * (dword_841FB3C % 0x4000);
          qmemcpy(*(void **)v14, v32, 0xF0u);
          *(_DWORD *)(*(_DWORD *)v14 + 240) = *((unsigned __int8 *)v32 + 242);
          if ( v32[64] )
            *(_DWORD *)(*(_DWORD *)v14 + 240) |= 8u;
          *(_DWORD *)(*(_DWORD *)v14 + 244) = v32[61];
          *(_DWORD *)(*(_DWORD *)v14 + 248) = v32[62];
          sub_8099DB4(v32 + 72, (_DWORD *)(*(_DWORD *)v14 + 252));
          sub_8099DB4(v32 + 75, (_DWORD *)(*(_DWORD *)v14 + 264));
          MSG_WriteDeltaArchivedEntity(&s, (int *)(372 * *v32 + 138600604), *(int **)v14, 1);
          if ( ++dword_841FB3C > 2147483645 )
            Com_Error(0, (char *)&byte_8145280);
          ++v18[2];
        }
      }
    }
    if ( ++dword_841FB44 > 2147483645 )
      Com_Error(0, (char *)&byte_81452C0);
LABEL_70:
    MSG_WriteBits(&s, 1023, 10);
    if ( s )
    {
      Com_DPrintf("SV_ArchiveSnapshot: ignoring snapshot because it overflowed.\n");
      return LargeLocalDealloc(v5);
    }
    v22 = (char *)dword_841FB30 + 8 * (dword_841FB2C % 1200);
    *v22 = dword_841FB38;
    v22[1] = n;
    v21 = dword_841FB38 % 0x2000000;
    dword_841FB38 += n;
    if ( dword_841FB38 > 2147483645 )
      Com_Error(0, (char *)&byte_81454E0);
    v20 = 0x2000000 - v21;
    if ( (int)n > 0x2000000 - v21 )
    {
      memcpy((char *)dword_841FB34 + v21, src, v20);
      memcpy(dword_841FB34, (char *)src + v20, n - v20);
    }
    else
    {
      memcpy((char *)dword_841FB34 + v21, src, n);
    }
    if ( ++dword_841FB2C > 2147483645 )
      Com_Error(0, (char *)&byte_8145520);
  }
  return LargeLocalDealloc(v5);
}
// 841FB28: using guessed type int dword_841FB28;
// 841FB2C: using guessed type int dword_841FB2C;
// 841FB38: using guessed type int dword_841FB38;
// 841FB3C: using guessed type int dword_841FB3C;
// 841FB40: using guessed type int dword_841FB40;
// 841FB44: using guessed type int dword_841FB44;
// 842BC80: using guessed type int dword_842BC80;
// 848B0A4: using guessed type int dword_848B0A4;
// 848B1B4: using guessed type int sv_fps;
// 848B1CC: using guessed type int sv_maxclients;
// 8098E3A: using guessed type int var_2878[4];
// 8098E3A: using guessed type _DWORD var_2818[2478];
// 8098E3A: using guessed type int var_148[60];
// 8098E3A: using guessed type int anonymous_0[3];
// 8098E3A: using guessed type int anonymous_1[8];

//----- (08099AF2) --------------------------------------------------------
void __usercall SV_SendClientMessages(long double a1@<st0>)
{
  float v1; // [esp+3Ch] [ebp-1Ch]
  float v2; // [esp+40h] [ebp-18h]
  float v3; // [esp+40h] [ebp-18h]
  float v4; // [esp+40h] [ebp-18h]
  float v5; // [esp+44h] [ebp-14h]
  float v6; // [esp+44h] [ebp-14h]
  float v7; // [esp+44h] [ebp-14h]
  int v8; // [esp+48h] [ebp-10h]
  _DWORD *v9; // [esp+4Ch] [ebp-Ch]
  int v10; // [esp+50h] [ebp-8h]
  int i; // [esp+50h] [ebp-8h]

  v8 = 0;
  dword_848B10C = 0;
  dword_848B164 = 0;
  v10 = 0;
  v9 = dword_841FB0C;
  while ( v10 < *(_DWORD *)(sv_maxclients + 8) )
  {
    if ( *v9 && dword_841FB04 >= v9[33606] )
    {
      ++v8;
      if ( v9[117113] )
      {
        v9[33606] = dword_841FB04 + SV_RateMsec((int)v9, v9[117115] - v9[117114]);
        SV_Netchan_TransmitNextFragment((int)(v9 + 113005));
      }
      else
      {
        SV_SendClientSnapshot(a1, (int)v9);
        SV_SendClientVoiceData((int)v9);
      }
    }
    ++v10;
    v9 += 123845;
  }
  if ( *(_BYTE *)(sv_showAverageBPS + 8) && v8 > 0 )
  {
    v5 = 0.0;
    v2 = 0.0;
    for ( i = 0; i <= 18; ++i )
    {
      dword_848B0B8[i] = dword_848B0BC[i];
      v5 = (long double)dword_848B0B8[i] + v5;
      dword_848B114[i] = dword_848B118[i];
      v2 = (long double)dword_848B114[i] + v2;
    }
    dword_848B104 = dword_848B10C;
    v6 = (long double)dword_848B10C + v5;
    dword_848B160 = dword_848B164;
    v3 = (long double)dword_848B164 + v2;
    if ( dword_848B10C >= dword_848B110 )
      dword_848B110 = dword_848B10C;
    if ( dword_848B164 >= dword_848B168 )
      dword_848B168 = dword_848B164;
    if ( ++dword_848B108 > 19 )
    {
      dword_848B108 = 0;
      v7 = v6 / 20.0;
      v4 = v3 / 20.0;
      v1 = (1.0 - v7 / v4) * 100.0;
      flt_848B16C = flt_848B16C + v1;
      Com_DPrintf(
        "bpspc(%2.0f) bps(%2.0f) pk(%i) ubps(%2.0f) upk(%i) cr(%2.2f) acr(%2.2f)\n",
        (double)(v7 / (long double)v8),
        v7,
        dword_848B110,
        v4,
        dword_848B168,
        v1,
        (double)(flt_848B16C / (long double)++dword_848B170));
    }
  }
}
// 848B0B8: using guessed type int dword_848B0B8[];
// 848B0BC: using guessed type int dword_848B0BC[18];
// 848B104: using guessed type int dword_848B104;
// 848B108: using guessed type int dword_848B108;
// 848B10C: using guessed type int dword_848B10C;
// 848B110: using guessed type int dword_848B110;
// 848B114: using guessed type int dword_848B114[];
// 848B118: using guessed type int dword_848B118[18];
// 848B160: using guessed type int dword_848B160;
// 848B164: using guessed type int dword_848B164;
// 848B168: using guessed type int dword_848B168;
// 848B16C: using guessed type float flt_848B16C;
// 848B170: using guessed type int dword_848B170;
// 848B1CC: using guessed type int sv_maxclients;
// 848B218: using guessed type int sv_showAverageBPS;

//----- (08099D74) --------------------------------------------------------
long double __cdecl sub_8099D74(float a1, float a2, float a3)
{
  return (1.0 - a3) * a1 + a2 * a3;
}

//----- (08099D8A) --------------------------------------------------------
int __cdecl sub_8099D8A(_DWORD *a1)
{
  int result; // eax

  *a1 = 0;
  a1[1] = 0;
  result = 0;
  a1[2] = 0;
  return result;
}

//----- (08099DB4) --------------------------------------------------------
int __cdecl sub_8099DB4(_DWORD *a1, _DWORD *a2)
{
  int result; // eax

  *a2 = *a1;
  a2[1] = a1[1];
  result = a1[2];
  a2[2] = result;
  return result;
}

//----- (08099DE4) --------------------------------------------------------
int __cdecl SV_WriteClientVoiceData(int a1, _DWORD *a2)
{
  int result; // eax
  int i; // [esp+14h] [ebp-4h]

  MSG_WriteByte(a2, *(_DWORD *)(a1 + 495308));
  for ( i = 0; ; ++i )
  {
    result = i;
    if ( i >= *(_DWORD *)(a1 + 495308) )
      break;
    MSG_WriteByte(a2, *(_BYTE *)(a1 + 261 * i + 484868));
    MSG_WriteByte(a2, *(_DWORD *)(a1 + 261 * i + 485125));
    MSG_WriteData(a2, (void *)(a1 + 261 * i + 484869), *(_DWORD *)(a1 + 261 * i + 485125));
  }
  return result;
}

//----- (08099EC6) --------------------------------------------------------
int __cdecl SV_SendClientVoiceData(int a1)
{
  char *v2; // [esp+2Ch] [ebp-3Ch]
  int v3[4]; // [esp+30h] [ebp-38h] BYREF
  int s[10]; // [esp+40h] [ebp-28h] BYREF

  LargeLocal(v3, 0x20000);
  v2 = LargeLocalGetBuf(v3);
  if ( *(_DWORD *)a1 == 4 && *(_DWORD *)(a1 + 495308) )
  {
    MSG_Init(s, (int)v2, 0x20000);
    MSG_WriteString(s, "v");
    SV_WriteClientVoiceData(a1, s);
    if ( s[0] )
    {
      Com_Printf("WARNING: voice msg overflowed for %s\n", (const char *)(a1 + 134216));
    }
    else
    {
      NET_OutOfBandVoiceData(
        1,
        *(_DWORD *)(a1 + 452036),
        *(_DWORD *)(a1 + 452040),
        *(_DWORD *)(a1 + 452044),
        *(_DWORD *)(a1 + 452048),
        *(_DWORD *)(a1 + 452052),
        (void *)s[1],
        s[3]);
      *(_DWORD *)(a1 + 495308) = 0;
    }
  }
  return LargeLocalDealloc(v3);
}
// 8099EC6: using guessed type int var_38[4];

//----- (0809A000) --------------------------------------------------------
int __cdecl sub_809A000(int a1)
{
  return *((unsigned __int8 *)dword_841FB0C + 495380 * a1 + 495376);
}

//----- (0809A01E) --------------------------------------------------------
int __cdecl SV_ClientHasClientMuted(int a1, int a2)
{
  return *((unsigned __int8 *)dword_841FB0C + 495380 * a1 + a2 + 495312);
}

//----- (0809A040) --------------------------------------------------------
char *__cdecl sub_809A040(char a1, int a2, int a3)
{
  char *result; // eax
  char *v4; // [esp+10h] [ebp-8h]

  v4 = (char *)dword_841FB0C + 495380 * a2;
  result = v4;
  if ( *((int *)v4 + 123827) <= 39 )
  {
    *(_DWORD *)&v4[261 * *((_DWORD *)v4 + 123827) + 485125] = *(_DWORD *)(a3 + 257);
    memcpy(&v4[261 * *((_DWORD *)v4 + 123827) + 484869], (const void *)(a3 + 1), *(_DWORD *)(a3 + 257));
    v4[261 * *((_DWORD *)v4 + 123827) + 484868] = a1;
    result = v4;
    ++*((_DWORD *)v4 + 123827);
  }
  return result;
}

//----- (0809A112) --------------------------------------------------------
void __cdecl sub_809A112(int a1, _DWORD *a2)
{
  int i; // [esp+14h] [ebp-124h]
  int v3; // [esp+18h] [ebp-120h]
  char v4; // [esp+20h] [ebp-118h] BYREF
  _BYTE v5[3]; // [esp+21h] [ebp-117h] BYREF
  size_t n; // [esp+121h] [ebp-17h]

  if ( *(_BYTE *)(sv_voice + 8) )
  {
    v3 = MSG_ReadByte(a2);
    for ( i = 0; i < v3; ++i )
    {
      n = MSG_ReadByte(a2);
      if ( (int)n <= 0 || (int)n > 256 )
      {
        Com_Printf("Received invalid voice packet of size %i from %s\n", n, (const char *)(a1 + 134216));
        return;
      }
      MSG_ReadData(a2, v5, n);
      G_BroadcastVoice(*(int **)(a1 + 134212), (int)&v4);
    }
  }
}
// 848B22C: using guessed type int sv_voice;

//----- (0809A1EA) --------------------------------------------------------
void __cdecl sub_809A1EA(int a1, _DWORD *a2)
{
  int v2; // [esp+1Ch] [ebp-12Ch]
  int j; // [esp+20h] [ebp-128h]
  int i; // [esp+24h] [ebp-124h]
  int v5; // [esp+28h] [ebp-120h]
  char v6; // [esp+30h] [ebp-118h] BYREF
  _BYTE v7[3]; // [esp+31h] [ebp-117h] BYREF
  size_t n; // [esp+131h] [ebp-17h]

  if ( *(_BYTE *)(sv_voice + 8) )
  {
    v2 = -1653759219 * ((a1 - (int)dword_841FB0C) >> 2);
    v5 = MSG_ReadByte(a2);
    for ( i = 0; i < v5; ++i )
    {
      n = MSG_ReadShort(a2);
      if ( (int)n <= 0 || (int)n > 256 )
      {
        Com_Printf("Received invalid voice packet of size %i from %s\n", n, (const char *)(a1 + 134216));
        return;
      }
      MSG_ReadData(a2, v7, n);
      for ( j = 0; j <= 63; ++j )
      {
        if ( j != v2 && *((int *)dword_841FB0C + 123845 * j) > 1 && !(unsigned __int8)SV_ClientHasClientMuted(j, v2) )
        {
          if ( (unsigned __int8)sub_809A000(j) )
            sub_809A040(v2, j, (int)&v6);
        }
      }
    }
  }
}
// 848B22C: using guessed type int sv_voice;

//----- (0809A368) --------------------------------------------------------
int __cdecl sub_809A368(int a1)
{
  if ( *(_BYTE *)(a1 + 241) )
    return *(_DWORD *)(a1 + 140);
  else
    return sub_80590DE((_DWORD *)(a1 + 260), (_DWORD *)(a1 + 272), *(_DWORD *)(a1 + 284));
}

//----- (0809A3BA) --------------------------------------------------------
int __cdecl SV_UnlinkEntity(int a1)
{
  unsigned __int16 *v2; // [esp+4h] [ebp-4h]

  v2 = (unsigned __int16 *)sub_808FE20((_DWORD *)a1);
  *(_BYTE *)(a1 + 240) = 0;
  return sub_805DAA0(v2);
}

//----- (0809A3E6) --------------------------------------------------------
void __cdecl sub_809A3E6(int a1)
{
  float v1; // [esp+Ch] [ebp-Ch]
  int v2; // [esp+10h] [ebp-8h]
  int i; // [esp+14h] [ebp-4h]

  for ( i = 0; i <= 2; ++i )
  {
    v2 = sub_809C294(*(float *)(a1 + 4 * i));
    v1 = (long double)v2 - *(float *)(a1 + 4 * i);
    if ( v1 * v1 < 0.0000010000001 )
      *(float *)(a1 + 4 * i) = (float)v2;
  }
}

//----- (0809A45E) --------------------------------------------------------
int __cdecl SV_LinkEntity(int a1)
{
  long double v1; // fst7
  unsigned __int16 *v3; // edx
  int j; // [esp+24h] [ebp-264h]
  int i; // [esp+24h] [ebp-264h]
  float v6; // [esp+28h] [ebp-260h]
  float v7; // [esp+28h] [ebp-260h]
  int v8; // [esp+2Ch] [ebp-25Ch]
  float v9[4]; // [esp+30h] [ebp-258h] BYREF
  float v10[6]; // [esp+40h] [ebp-248h] BYREF
  int v11; // [esp+58h] [ebp-230h]
  unsigned __int16 *v12; // [esp+5Ch] [ebp-22Ch]
  float *v13; // [esp+60h] [ebp-228h]
  float *v14; // [esp+64h] [ebp-224h]
  int v15; // [esp+68h] [ebp-220h] BYREF
  int v16; // [esp+6Ch] [ebp-21Ch]
  int v17; // [esp+70h] [ebp-218h]
  int k; // [esp+74h] [ebp-214h]
  int v19; // [esp+78h] [ebp-210h]
  int v20; // [esp+7Ch] [ebp-20Ch]
  int v21[130]; // [esp+80h] [ebp-208h] BYREF

  v12 = (unsigned __int16 *)sub_808FE20((_DWORD *)a1);
  if ( *(_BYTE *)(a1 + 241) )
  {
    *(_DWORD *)(a1 + 156) = 0xFFFFFF;
  }
  else if ( (*(_DWORD *)(a1 + 284) & 0x2000001) != 0 )
  {
    k = (int)*(float *)(a1 + 272);
    if ( k <= 0 )
      k = 1;
    if ( k > 255 )
      k = 255;
    v17 = (int)(1.0 - *(float *)(a1 + 268));
    if ( v17 <= 0 )
      v17 = 1;
    if ( v17 > 255 )
      v17 = 255;
    v16 = (int)(*(float *)(a1 + 280) + 32.0);
    if ( v16 <= 0 )
      v16 = 1;
    if ( v16 > 255 )
      v16 = 255;
    *(_DWORD *)(a1 + 156) = k | (v16 << 16) | (v17 << 8);
  }
  else
  {
    *(_DWORD *)(a1 + 156) = 0;
  }
  v13 = (float *)(a1 + 324);
  v14 = (float *)(a1 + 312);
  sub_809A3E6(a1 + 324);
  if ( !*(_BYTE *)(a1 + 241) || *v13 == 0.0 && v13[1] == 0.0 && v13[2] == 0.0 )
  {
    sub_809C326(v14, (float *)(a1 + 260), (float *)(a1 + 288));
    sub_809C326(v14, (float *)(a1 + 272), (float *)(a1 + 300));
  }
  else
  {
    v1 = 0.0;
    if ( *v13 == 0.0 && (v1 = 0.0, v13[2] == 0.0) )
    {
      sub_80A62FC(a1 + 260, a1 + 272);
      v7 = 0.0;
      for ( i = 0; i <= 1; ++i )
      {
        *(float *)(a1 + 4 * i + 288) = v14[i] - v7;
        *(float *)(a1 + 4 * i + 300) = v14[i] + v7;
      }
      *(float *)(a1 + 296) = v14[2] + *(float *)(a1 + 268);
      *(float *)(a1 + 308) = v14[2] + *(float *)(a1 + 280);
    }
    else
    {
      sub_80A626E(a1 + 260, a1 + 272);
      v6 = v1;
      for ( j = 0; j <= 2; ++j )
      {
        *(float *)(a1 + 4 * j + 288) = v14[j] - v6;
        *(float *)(a1 + 4 * j + 300) = v14[j] + v6;
      }
    }
  }
  *(float *)(a1 + 288) = *(float *)(a1 + 288) - 1.0;
  *(float *)(a1 + 292) = *(float *)(a1 + 292) - 1.0;
  *(float *)(a1 + 296) = *(float *)(a1 + 296) - 1.0;
  *(float *)(a1 + 300) = *(float *)(a1 + 300) + 1.0;
  *(float *)(a1 + 304) = *(float *)(a1 + 304) + 1.0;
  *(float *)(a1 + 308) = *(float *)(a1 + 308) + 1.0;
  *((_DWORD *)v12 + 70) = 0;
  *((_DWORD *)v12 + 87) = 0;
  if ( (*(_BYTE *)(a1 + 242) & 0x19) == 0 )
  {
    v19 = sub_8058B66((_DWORD *)(a1 + 288), (_DWORD *)(a1 + 300), (int)v21, 128, &v15);
    if ( !v19 )
      return sub_805DAA0(v12);
    for ( k = 0; k < v19; ++k )
    {
      v20 = sub_80524F4(v21[k]);
      if ( v20 != -1 )
      {
        v3 = v12;
        *(_DWORD *)&v12[2 * *((_DWORD *)v12 + 70) + 142] = v20;
        ++*((_DWORD *)v3 + 70);
        if ( *((_DWORD *)v12 + 70) == 16 )
          break;
      }
    }
    if ( k != v19 )
      *((_DWORD *)v12 + 87) = sub_80524F4(v15);
  }
  *(_BYTE *)(a1 + 240) = 1;
  if ( !*(_DWORD *)(a1 + 284) )
    return sub_805DAA0(v12);
  v8 = sub_809A368(a1);
  v11 = Com_GetServerDObj(*(_DWORD *)a1);
  if ( !v11 || (*(_BYTE *)(a1 + 242) & 6) == 0 )
    return sub_805E18C((int)v12, (_DWORD *)(a1 + 288), (_DWORD *)(a1 + 300), v8);
  if ( (*(_BYTE *)(a1 + 242) & 2) != 0 )
  {
    sub_809C2CA(v14, flt_815D6E8, v10);
    sub_809C2CA(v14, flt_815D6F4, v9);
  }
  else
  {
    sub_80B84A0(v11, v10, v9);
    sub_809C2CA(v14, v10, v10);
    sub_809C2CA(v14, v9, v9);
  }
  return sub_805E18C((int)v12, v10, v9, v8);
}
// 815D6E8: using guessed type float flt_815D6E8[3];
// 815D6F4: using guessed type float flt_815D6F4[489];
// 809A45E: using guessed type int var_208[130];
// 809A45E: using guessed type float var_248[6];
// 809A45E: using guessed type float var_258[4];

//----- (0809AB88) --------------------------------------------------------
void __cdecl sub_809AB88(int a1, int a2, int a3)
{
  float v3[4]; // [esp+30h] [ebp-48h] BYREF
  float v4[7]; // [esp+40h] [ebp-38h] BYREF
  float v5; // [esp+5Ch] [ebp-1Ch]
  int v6; // [esp+60h] [ebp-18h]
  float *v7; // [esp+64h] [ebp-14h]
  int v8; // [esp+68h] [ebp-10h]
  int v9; // [esp+6Ch] [ebp-Ch]

  v6 = 1062196213 * ((a2 + -(int)&dword_842BC80 - 9240) >> 2);
  v9 = SV_GentityNum(v6);
  if ( (*(_DWORD *)(a1 + 80) & *(_DWORD *)(v9 + 284)) != 0
    && (*(_DWORD *)(a1 + 72) == 1023
     || v6 != *(_DWORD *)(a1 + 72)
     && *(_DWORD *)(v9 + 336) != *(_DWORD *)(a1 + 72)
     && *(_DWORD *)(v9 + 336) != *(_DWORD *)(a1 + 76)) )
  {
    sub_809C326((float *)(v9 + 288), (float *)a1, v4);
    sub_809C326((float *)(v9 + 300), (float *)(a1 + 12), v3);
    if ( !sub_805D6DC(a1 + 36, (int)v4, (int)v3, *(float *)a3) )
    {
      v8 = sub_809A368(v9);
      v7 = (float *)(v9 + 324);
      if ( !*(_BYTE *)(v9 + 241) )
        v7 = flt_8145E68;
      v5 = *(float *)a3;
      sub_805B6F2((float *)a3, a1 + 36, a1 + 48, a1, a1 + 12, v8, *(_DWORD *)(a1 + 80), (float *)(v9 + 312), v7);
      if ( *(float *)a3 < (long double)v5 )
        *(_WORD *)(a3 + 28) = *(_WORD *)v9;
    }
  }
}
// 8145E68: using guessed type float flt_8145E68[3];
// 842BC80: using guessed type int dword_842BC80;
// 809AB88: using guessed type float var_38[7];
// 809AB88: using guessed type float var_48[4];

//----- (0809AD2C) --------------------------------------------------------
void __cdecl sub_809AD2C(int a1, int a2, int a3)
{
  float v3[9]; // [esp+30h] [ebp-C8h] BYREF
  float v4[6]; // [esp+54h] [ebp-A4h] BYREF
  float v5; // [esp+6Ch] [ebp-8Ch]
  float v6[4]; // [esp+70h] [ebp-88h] BYREF
  float v7[4]; // [esp+80h] [ebp-78h] BYREF
  int v8[2]; // [esp+90h] [ebp-68h] BYREF
  float v9[6]; // [esp+98h] [ebp-60h] BYREF
  float v10[4]; // [esp+B0h] [ebp-48h] BYREF
  float v11[7]; // [esp+C0h] [ebp-38h] BYREF
  int v12; // [esp+DCh] [ebp-1Ch]
  int v13; // [esp+E0h] [ebp-18h]
  float *v14; // [esp+E4h] [ebp-14h]
  int v15; // [esp+E8h] [ebp-10h]
  int v16; // [esp+ECh] [ebp-Ch]

  v13 = 1062196213 * ((a2 + -(int)&dword_842BC80 - 9240) >> 2);
  v16 = SV_GentityNum(v13);
  if ( (*(_DWORD *)(a1 + 44) & *(_DWORD *)(v16 + 284)) == 0
    || *(_DWORD *)(a1 + 36) != 1023
    && (v13 == *(_DWORD *)(a1 + 36)
     || *(_DWORD *)(v16 + 336) == *(_DWORD *)(a1 + 36)
     || *(_DWORD *)(v16 + 336) == *(_DWORD *)(a1 + 40)) )
  {
    return;
  }
  if ( *(_DWORD *)(a1 + 48) )
  {
    v12 = Com_GetServerDObj(*(_DWORD *)v16);
    if ( v12 )
    {
      if ( (*(_BYTE *)(v16 + 242) & 6) != 0 )
      {
        if ( (*(_BYTE *)(v16 + 242) & 4) != 0 )
        {
          if ( !sub_80B96F8(v12, *(_DWORD *)(a1 + 44)) )
            return;
          sub_809C2F6((_DWORD *)(v16 + 312), v4);
          sub_80B84A0(v12, v11, v10);
          sub_809C326(v4, v11, v11);
          sub_809C326(v4, v10, v10);
LABEL_14:
          if ( !sub_805D6DC(a1, (int)v11, (int)v10, *(float *)a3) )
          {
            sub_811BF30(v16);
            sub_80A7146((float *)(v16 + 324), (int)v3);
            sub_80A5194((float *)a1, v3, v7);
            sub_80A5194((float *)(a1 + 12), v3, v6);
            v8[0] = *(_DWORD *)a3;
            if ( (*(_BYTE *)(v16 + 242) & 4) != 0 )
              sub_80B955A(v12, v7, v6, *(_DWORD *)(a1 + 44), (int)v8);
            else
              sub_80B8CA6(v12, v7, v6, *(_DWORD *)(a1 + 52), (int)v8);
            if ( *(float *)v8 < (long double)*(float *)a3 )
            {
              *(_DWORD *)a3 = v8[0];
              *(_DWORD *)(a3 + 16) = v8[1];
              *(float *)(a3 + 30) = v9[3];
              sub_80A4E52(v9, v3, (float *)(a3 + 4));
LABEL_26:
              *(_WORD *)(a3 + 28) = *(_WORD *)v16;
              *(_DWORD *)(a3 + 20) = *(_DWORD *)(v16 + 284);
              *(_DWORD *)(a3 + 24) = 0;
              return;
            }
          }
          return;
        }
        if ( *(_DWORD *)(a1 + 52) )
        {
          sub_809C2F6((_DWORD *)(v16 + 312), v4);
          sub_809C326(v4, flt_815D6E8, v11);
          sub_809C326(v4, flt_815D6F4, v10);
          goto LABEL_14;
        }
      }
    }
  }
  if ( (*(_DWORD *)(a1 + 44) & *(_DWORD *)(a2 + 352)) != 0 && !sub_805D6DC(a1, v16 + 288, v16 + 300, *(float *)a3) )
  {
    v15 = sub_809A368(v16);
    v14 = (float *)(v16 + 324);
    if ( !*(_BYTE *)(v16 + 241) )
      v14 = flt_8145E68;
    v5 = *(float *)a3;
    sub_805B6F2(
      (float *)a3,
      a1,
      a1 + 12,
      (int)flt_8145E68,
      (int)flt_8145E68,
      v15,
      *(_DWORD *)(a1 + 44),
      (float *)(v16 + 312),
      v14);
    if ( *(float *)a3 < (long double)v5 )
    {
      *(_DWORD *)(a3 + 16) = 0;
      *(_WORD *)(a3 + 30) = 0;
      *(_WORD *)(a3 + 32) = 0;
      goto LABEL_26;
    }
  }
}
// 8145E68: using guessed type float flt_8145E68[3];
// 815D6E8: using guessed type float flt_815D6E8[3];
// 815D6F4: using guessed type float flt_815D6F4[489];
// 842BC80: using guessed type int dword_842BC80;
// 809AD2C: using guessed type float var_C8[9];
// 809AD2C: using guessed type float var_48[4];
// 809AD2C: using guessed type float var_38[7];
// 809AD2C: using guessed type float var_78[4];
// 809AD2C: using guessed type float var_88[4];

//----- (0809B1A0) --------------------------------------------------------
int __cdecl sub_809B1A0(_DWORD *a1, int a2)
{
  int v4; // [esp+38h] [ebp-10h]
  float *v5; // [esp+3Ch] [ebp-Ch]
  int v6; // [esp+40h] [ebp-8h]
  int v7; // [esp+44h] [ebp-4h]

  v4 = 1062196213 * ((a2 + -(int)&dword_842BC80 - 9240) >> 2);
  v7 = SV_GentityNum(v4);
  if ( (a1[17] & *(_DWORD *)(v7 + 284)) == 0 )
    return 0;
  if ( a1[15] != 1023 )
  {
    if ( v4 == a1[15] )
      return 0;
    if ( *(_DWORD *)(v7 + 336) == a1[15] )
      return 0;
  }
  if ( a1[16] != 1023 )
  {
    if ( v4 == a1[16] )
      return 0;
    if ( *(_DWORD *)(v7 + 336) == a1[16] )
      return 0;
  }
  v6 = sub_809A368(v7);
  v5 = (float *)(v7 + 324);
  if ( !*(_BYTE *)(v7 + 241) )
    v5 = flt_8145E68;
  if ( sub_805D124(0, (int)(a1 + 9), (int)(a1 + 12), (int)a1, (int)(a1 + 3), v6, a1[17], (float *)(v7 + 312), v5) )
    return -1;
  else
    return 0;
}
// 8145E68: using guessed type float flt_8145E68[3];
// 842BC80: using guessed type int dword_842BC80;

//----- (0809B30E) --------------------------------------------------------
int __cdecl sub_809B30E(_DWORD *a1, int a2)
{
  float v4[9]; // [esp+40h] [ebp-F8h] BYREF
  float v5[3]; // [esp+64h] [ebp-D4h] BYREF
  float v6[4]; // [esp+70h] [ebp-C8h] BYREF
  float v7[4]; // [esp+80h] [ebp-B8h] BYREF
  float v8[8]; // [esp+90h] [ebp-A8h] BYREF
  float v9[4]; // [esp+B0h] [ebp-88h] BYREF
  float v10[7]; // [esp+C0h] [ebp-78h] BYREF
  int v11; // [esp+DCh] [ebp-5Ch]
  float v12[3]; // [esp+E0h] [ebp-58h] BYREF
  float v13[12]; // [esp+ECh] [ebp-4Ch] BYREF
  int v14; // [esp+120h] [ebp-18h]
  float *v15; // [esp+124h] [ebp-14h]
  int v16; // [esp+128h] [ebp-10h]
  int v17; // [esp+12Ch] [ebp-Ch]

  v14 = 1062196213 * ((a2 + -(int)&dword_842BC80 - 9240) >> 2);
  v17 = SV_GentityNum(v14);
  if ( (a1[8] & *(_DWORD *)(v17 + 284)) != 0 )
  {
    if ( a1[6] != 1023 )
    {
      if ( v14 == a1[6] )
        return 0;
      if ( *(_DWORD *)(v17 + 336) == a1[6] )
        return 0;
    }
    if ( a1[7] != 1023 )
    {
      if ( v14 == a1[7] )
        return 0;
      if ( *(_DWORD *)(v17 + 336) == a1[7] )
        return 0;
    }
    if ( a1[9] && (v11 = Com_GetServerDObj(*(_DWORD *)v17)) != 0 && (*(_BYTE *)(v17 + 242) & 4) != 0 )
    {
      if ( !sub_80B96F8(v11, a1[8]) )
        return 0;
      sub_809C2F6((_DWORD *)(v17 + 312), v5);
      sub_80B84A0(v11, v10, v9);
      sub_809C326(v5, v10, v10);
      sub_809C326(v5, v9, v9);
      sub_809C2F6(a1, v12);
      sub_809C2F6(a1 + 3, v13);
      CM_CalcTraceExtents((int)v12);
      if ( sub_805D6DC((int)v12, (int)v10, (int)v9, 1.0) )
        return 0;
      sub_811BF30(v17);
      sub_80A7146((float *)(v17 + 324), (int)v4);
      sub_80A5194(v12, v4, v7);
      sub_80A5194(v13, v4, v6);
      v8[0] = 1.0;
      sub_80B955A(v11, v7, v6, a1[8], (int)v8);
      if ( v8[0] < 1.0 )
        return -1;
    }
    else
    {
      v16 = sub_809A368(v17);
      v15 = (float *)(v17 + 324);
      if ( !*(_BYTE *)(v17 + 241) )
        v15 = flt_8145E68;
      if ( sub_805D124(
             0,
             (int)a1,
             (int)(a1 + 3),
             (int)flt_8145E68,
             (int)flt_8145E68,
             v16,
             a1[8],
             (float *)(v17 + 312),
             v15) )
      {
        return -1;
      }
    }
    return 0;
  }
  return 0;
}
// 8145E68: using guessed type float flt_8145E68[3];
// 842BC80: using guessed type int dword_842BC80;
// 809B30E: using guessed type float var_F8[9];
// 809B30E: using guessed type float var_88[4];
// 809B30E: using guessed type float var_78[7];
// 809B30E: using guessed type float var_58[3];
// 809B30E: using guessed type float var_B8[4];
// 809B30E: using guessed type float var_C8[4];
// 809B30E: using guessed type float var_A8[8];

//----- (0809B6A8) --------------------------------------------------------
void __cdecl SV_Trace(float *s, float *a2, float *a3, float *a4, float *a5, int a6, int a7, int a8, int a9, int a10)
{
  __int16 v10; // [esp+2Ah] [ebp-BEh]
  int v11[3]; // [esp+30h] [ebp-B8h] BYREF
  int v12[3]; // [esp+3Ch] [ebp-ACh] BYREF
  float v13; // [esp+48h] [ebp-A0h] BYREF
  float v14; // [esp+4Ch] [ebp-9Ch]
  float v15; // [esp+50h] [ebp-98h]
  float v16[3]; // [esp+54h] [ebp-94h] BYREF
  float v17[7]; // [esp+60h] [ebp-88h] BYREF
  int v18; // [esp+7Ch] [ebp-6Ch]
  int v19; // [esp+80h] [ebp-68h]
  _DWORD v20[3]; // [esp+90h] [ebp-58h] BYREF
  _DWORD v21[7]; // [esp+9Ch] [ebp-4Ch] BYREF
  int v22; // [esp+B8h] [ebp-30h]
  int v23; // [esp+BCh] [ebp-2Ch]
  int v24; // [esp+C0h] [ebp-28h]
  int v25; // [esp+C4h] [ebp-24h]
  int v26[6]; // [esp+D0h] [ebp-18h] BYREF

  CM_BoxTrace(s, a2, a5, (int)a3, (int)a4, 0, a7);
  if ( *s == 1.0 )
    v10 = 1023;
  else
    v10 = 1022;
  *((_WORD *)s + 14) = v10;
  if ( *s != 0.0 )
  {
    if ( !a10 || (sub_805EA28(s, a2, a5, a7), *s != 0.0) )
    {
      if ( *a4 - *a3 + a4[1] - a3[1] + a4[2] - a3[2] == 0.0 )
      {
        v23 = a7;
        sub_809C2F6(a2, v20);
        sub_809C2F6(a5, v21);
        CM_CalcTraceExtents((int)v20);
        v21[6] = a6;
        v24 = a8;
        v25 = a9;
        if ( a6 == 1023 )
        {
          v22 = -1;
        }
        else
        {
          v22 = *(_DWORD *)(SV_GentityNum(a6) + 336);
          if ( v22 == 1023 )
            v22 = -1;
        }
        sub_805F61E(v20, s);
      }
      else
      {
        v19 = a7;
        LODWORD(v17[6]) = a6;
        if ( a6 == 1023 )
        {
          v18 = -1;
        }
        else
        {
          v18 = *(_DWORD *)(SV_GentityNum(a6) + 336);
          if ( v18 == 1023 )
            v18 = -1;
        }
        sub_809C36A(a4, a3, &v13);
        sub_809C3AE(&v13, 0.5, &v13);
        sub_809C2F6(&v13, v12);
        sub_809C3AE(&v13, -1.0, (float *)v11);
        v13 = v13 + 1.0;
        v14 = v14 + 1.0;
        v15 = v15 + 1.0;
        sub_809C326(a4, a3, (float *)v26);
        sub_809C3AE((float *)v26, 0.5, (float *)v26);
        sub_809C326(a2, (float *)v26, v16);
        sub_809C326(a5, (float *)v26, v17);
        CM_CalcTraceExtents((int)v16);
        sub_805F0A4((int)v11, s);
      }
    }
  }
}
// 809B6A8: using guessed type _DWORD var_58[3];
// 809B6A8: using guessed type int anonymous_0[3];

//----- (0809B9E2) --------------------------------------------------------
int __cdecl SV_TracePassed(float *a1, float *a2, float *a3, float *a4, int a5, int a6, int a7, int a8, int a9)
{
  int v11[3]; // [esp+30h] [ebp-98h] BYREF
  int v12[3]; // [esp+3Ch] [ebp-8Ch] BYREF
  float v13; // [esp+48h] [ebp-80h] BYREF
  float v14; // [esp+4Ch] [ebp-7Ch]
  float v15; // [esp+50h] [ebp-78h]
  float v16; // [esp+54h] [ebp-74h] BYREF
  float v17[8]; // [esp+60h] [ebp-68h] BYREF
  _DWORD v18[3]; // [esp+80h] [ebp-48h] BYREF
  int v19[9]; // [esp+8Ch] [ebp-3Ch] BYREF
  int v20[6]; // [esp+B0h] [ebp-18h] BYREF

  if ( CM_BoxSightTrace(0, (int)a1, (int)a4, (int)a2, (int)a3, 0, a7) )
    return 0;
  if ( !a9 || sub_805ED1E(a1, a4, *(float *)&a7) )
  {
    if ( *a3 - *a2 + a3[1] - a2[1] + a3[2] - a2[2] == 0.0 )
    {
      v19[5] = a7;
      sub_809C2F6(a1, v18);
      sub_809C2F6(a4, v19);
      v19[3] = a5;
      v19[4] = a6;
      v19[6] = a8;
      if ( sub_805F8C6((int)v18) )
        return 0;
    }
    else
    {
      LODWORD(v17[5]) = a7;
      LODWORD(v17[3]) = a5;
      LODWORD(v17[4]) = a6;
      sub_809C36A(a3, a2, &v13);
      sub_809C3AE(&v13, 0.5, &v13);
      sub_809C2F6(&v13, v12);
      sub_809C3AE(&v13, -1.0, (float *)v11);
      v13 = v13 + 1.0;
      v14 = v14 + 1.0;
      v15 = v15 + 1.0;
      sub_809C326(a3, a2, (float *)v20);
      sub_809C3AE((float *)v20, 0.5, (float *)v20);
      sub_809C326(a1, (float *)v20, &v16);
      sub_809C326(a4, (float *)v20, v17);
      if ( sub_805F3F6((int)v11) )
        return 0;
    }
    return 1;
  }
  return 0;
}
// 809B9E2: using guessed type _DWORD var_48[3];
// 809B9E2: using guessed type int anonymous_0[3];

//----- (0809BC5C) --------------------------------------------------------
int *__cdecl SV_SightTrace(int *a1, float *a2, float *a3, float *a4, float *a5, int a6, int a7, int a8)
{
  int *result; // eax
  int v9; // edx
  int v10[3]; // [esp+20h] [ebp-98h] BYREF
  int v11[3]; // [esp+2Ch] [ebp-8Ch] BYREF
  float v12; // [esp+38h] [ebp-80h] BYREF
  float v13; // [esp+3Ch] [ebp-7Ch]
  float v14; // [esp+40h] [ebp-78h]
  float v15; // [esp+44h] [ebp-74h] BYREF
  float v16[8]; // [esp+50h] [ebp-68h] BYREF
  _DWORD v17[3]; // [esp+70h] [ebp-48h] BYREF
  int v18[9]; // [esp+7Ch] [ebp-3Ch] BYREF
  int v19[6]; // [esp+A0h] [ebp-18h] BYREF

  *a1 = CM_BoxSightTrace(*a1, (int)a2, (int)a5, (int)a3, (int)a4, 0, a8);
  result = a1;
  if ( !*a1 )
  {
    if ( *a4 - *a3 + a4[1] - a3[1] + a4[2] - a3[2] == 0.0 )
    {
      v18[5] = a8;
      sub_809C2F6(a2, v17);
      sub_809C2F6(a5, v18);
      v18[3] = a6;
      v18[4] = a7;
      v18[6] = 0;
      v9 = sub_805F8C6((int)v17);
    }
    else
    {
      LODWORD(v16[5]) = a8;
      LODWORD(v16[3]) = a6;
      LODWORD(v16[4]) = a7;
      sub_809C36A(a4, a3, &v12);
      sub_809C3AE(&v12, 0.5, &v12);
      sub_809C2F6(&v12, v11);
      sub_809C3AE(&v12, -1.0, (float *)v10);
      v12 = v12 + 1.0;
      v13 = v13 + 1.0;
      v14 = v14 + 1.0;
      sub_809C326(a4, a3, (float *)v19);
      sub_809C3AE((float *)v19, 0.5, (float *)v19);
      sub_809C326(a2, (float *)v19, &v15);
      sub_809C326(a5, (float *)v19, v16);
      v9 = sub_805F3F6((int)v10);
    }
    result = a1;
    *a1 = v9;
  }
  return result;
}
// 809BC5C: using guessed type _DWORD var_48[3];
// 809BC5C: using guessed type int anonymous_0[3];

//----- (0809BE82) --------------------------------------------------------
int __cdecl sub_809BE82(int a1, int a2, int a3, int a4, int a5, int a6)
{
  float v8[4]; // [esp+40h] [ebp-48h]
  float v9[7]; // [esp+50h] [ebp-38h]
  float *v10; // [esp+6Ch] [ebp-1Ch]
  float *v11; // [esp+70h] [ebp-18h]
  int v12; // [esp+74h] [ebp-14h]
  int v13; // [esp+78h] [ebp-10h]
  int i; // [esp+7Ch] [ebp-Ch]

  v13 = SV_GentityNum(a5);
  if ( (a6 & *(_DWORD *)(v13 + 284)) == 0 )
    return 0;
  for ( i = 0; i <= 2; ++i )
  {
    if ( *(float *)(a4 + 4 * i) <= (long double)*(float *)(a1 + 4 * i) )
    {
      v9[i] = *(float *)(a4 + 4 * i) + *(float *)(a2 + 4 * i) - 1.0;
      v8[i] = *(float *)(a1 + 4 * i) + *(float *)(a3 + 4 * i) + 1.0;
    }
    else
    {
      v9[i] = *(float *)(a1 + 4 * i) + *(float *)(a2 + 4 * i) - 1.0;
      v8[i] = *(float *)(a4 + 4 * i) + *(float *)(a3 + 4 * i) + 1.0;
    }
  }
  if ( *(float *)(v13 + 288) > (long double)v8[0]
    || *(float *)(v13 + 292) > (long double)v8[1]
    || *(float *)(v13 + 296) > (long double)v8[2]
    || v9[0] > (long double)*(float *)(v13 + 300)
    || v9[1] > (long double)*(float *)(v13 + 304)
    || v9[2] > (long double)*(float *)(v13 + 308) )
  {
    return 0;
  }
  v12 = sub_809A368(v13);
  v11 = (float *)(v13 + 312);
  v10 = (float *)(v13 + 324);
  if ( !*(_BYTE *)(v13 + 241) )
    v10 = flt_8145E68;
  if ( sub_805D124(0, a1, a4, a2, a3, v12, a6, v11, v10) )
    return -1;
  else
    return 0;
}
// 8145E68: using guessed type float flt_8145E68[3];

//----- (0809C0CE) --------------------------------------------------------
void __cdecl sub_809C0CE(_DWORD *s, _DWORD *a2, _DWORD *a3, int a4, int a5, int a6)
{
  _DWORD v6[3]; // [esp+10h] [ebp-58h] BYREF
  _DWORD v7[15]; // [esp+1Ch] [ebp-4Ch] BYREF
  int v8; // [esp+58h] [ebp-10h]
  _DWORD *v9; // [esp+5Ch] [ebp-Ch]

  v9 = (_DWORD *)SV_GentityNum(a4);
  v8 = sub_808FE20(v9);
  memset(s, 0, 0x24u);
  *s = 1065353216;
  *((_WORD *)s + 14) = 1023;
  sub_809C2F6(a2, v6);
  sub_809C2F6(a3, v7);
  CM_CalcTraceExtents((int)v6);
  v7[6] = -1;
  v7[7] = -1;
  v7[8] = a5;
  v7[9] = 1;
  v7[10] = a6;
  sub_809AD2C((int)v6, v8, (int)s);
}
// 809C0CE: using guessed type _DWORD var_58[3];

//----- (0809C18C) --------------------------------------------------------
int __cdecl sub_809C18C(float *a1, int a2, int a3)
{
  int v4; // [esp+2Ch] [ebp-101Ch]
  int v5; // [esp+30h] [ebp-1018h]
  int v6; // [esp+34h] [ebp-1014h]
  int i; // [esp+38h] [ebp-1010h]
  int v8; // [esp+3Ch] [ebp-100Ch]
  int v9[1026]; // [esp+40h] [ebp-1008h] BYREF

  v5 = sub_8058D88(a1, 0);
  v6 = sub_805E782((int)a1, (int)a1, (int)v9, 1024, a3);
  for ( i = 0; i < v6; ++i )
  {
    if ( v9[i] != a2 )
    {
      v8 = SV_GentityNum(v9[i]);
      v4 = sub_809A368(v8);
      v5 |= sub_8058E94(a1, v4, (float *)(v8 + 312), (float *)(v8 + 324));
    }
  }
  return v5 & a3;
}
// 809C18C: using guessed type int var_1008[1026];

//----- (0809C294) --------------------------------------------------------
int __cdecl sub_809C294(float a1)
{
  return (int)floor(a1 + 0.5);
}

//----- (0809C2CA) --------------------------------------------------------
float *__cdecl sub_809C2CA(float *a1, float *a2, float *a3)
{
  float *result; // eax

  *a3 = *a1 + *a2;
  result = a1 + 1;
  a3[1] = a1[1] + a2[1];
  return result;
}

//----- (0809C2F6) --------------------------------------------------------
int __cdecl sub_809C2F6(_DWORD *a1, _DWORD *a2)
{
  int result; // eax

  *a2 = *a1;
  a2[1] = a1[1];
  result = a1[2];
  a2[2] = result;
  return result;
}

//----- (0809C326) --------------------------------------------------------
float *__cdecl sub_809C326(float *a1, float *a2, float *a3)
{
  float *result; // eax

  *a3 = *a1 + *a2;
  a3[1] = a1[1] + a2[1];
  result = a1 + 2;
  a3[2] = a1[2] + a2[2];
  return result;
}

//----- (0809C36A) --------------------------------------------------------
float *__cdecl sub_809C36A(float *a1, float *a2, float *a3)
{
  float *result; // eax

  *a3 = *a1 - *a2;
  a3[1] = a1[1] - a2[1];
  result = a1 + 2;
  a3[2] = a1[2] - a2[2];
  return result;
}

//----- (0809C3AE) --------------------------------------------------------
float *__cdecl sub_809C3AE(float *a1, float a2, float *a3)
{
  float *result; // eax

  *a3 = a2 * *a1;
  a3[1] = a2 * a1[1];
  result = a1 + 2;
  a3[2] = a2 * a1[2];
  return result;
}

//----- (0809C3E8) --------------------------------------------------------
int RefreshQuitOnErrorCondition()
{
  int result; // eax
  unsigned __int8 v1; // [esp+7h] [ebp-1h]

  result = Dvar_IsSystemActive();
  if ( (_BYTE)result )
  {
    v1 = 0;
    if ( (unsigned __int8)Dvar_GetBool("QuitOnError") || Dvar_GetInt("r_vc_compile") == 2 )
      v1 = 1;
    result = v1;
    byte_848B67C = v1;
  }
  return result;
}
// 848B67C: using guessed type char byte_848B67C;

//----- (0809C42E) --------------------------------------------------------
int QuitOnError()
{
  RefreshQuitOnErrorCondition();
  return (unsigned __int8)byte_848B67C;
}
// 848B67C: using guessed type char byte_848B67C;

//----- (0809C444) --------------------------------------------------------
_BOOL4 FS_Initialized()
{
  return fs_searchpaths != 0;
}

//----- (0809C456) --------------------------------------------------------
void FS_CheckFileSystemStarted()
{
  ;
}

//----- (0809C45C) --------------------------------------------------------
int __cdecl FS_IwdIsPure(int a1)
{
  int i; // [esp+4h] [ebp-4h]

  if ( !fs_numServerIwds )
    return 1;
  for ( i = 0; i < fs_numServerIwds; ++i )
  {
    if ( *(_DWORD *)(a1 + 772) == dword_848FF20[i] )
      return 1;
  }
  return 0;
}
// 848FF00: using guessed type int fs_numServerIwds;
// 848FF20: using guessed type int dword_848FF20[1024];

//----- (0809C4BA) --------------------------------------------------------
int FS_LoadStack()
{
  return fs_loadStack;
}
// 848B6A4: using guessed type int fs_loadStack;

//----- (0809C4C4) --------------------------------------------------------
_BOOL4 __cdecl FS_UseSearchPath(int a1)
{
  return !*(_DWORD *)(a1 + 12) || !*(_BYTE *)(fs_ignoreLocalized + 8);
}
// 848B7E4: using guessed type int fs_ignoreLocalized;

//----- (0809C4F4) --------------------------------------------------------
int __cdecl FS_LanguageHasAssets(int a1)
{
  _DWORD *i; // [esp+4h] [ebp-4h]

  for ( i = fs_searchpaths; i; i = (_DWORD *)*i )
  {
    if ( i[3] && i[4] == a1 )
      return 1;
  }
  return 0;
}

//----- (0809C53E) --------------------------------------------------------
int __cdecl FS_HashFileName(int a1, int a2)
{
  int v3; // [esp+Ch] [ebp-Ch]
  int v4; // [esp+10h] [ebp-8h]
  int i; // [esp+14h] [ebp-4h]

  v4 = 0;
  for ( i = 0; *(_BYTE *)(a1 + i); ++i )
  {
    v3 = tolower(*(char *)(a1 + i));
    if ( v3 == 46 )
      break;
    if ( v3 == 92 )
      v3 = 47;
    if ( v3 == 47 )
      v3 = 47;
    v4 += v3 * (i + 119);
  }
  return (a2 - 1) & (v4 ^ (v4 >> 10) ^ (v4 >> 20));
}

//----- (0809C5D2) --------------------------------------------------------
int __cdecl FS_HandleForFile(int a1)
{
  int v2; // [esp+1Ch] [ebp-Ch]
  int v3; // [esp+20h] [ebp-8h]
  int i; // [esp+24h] [ebp-4h]
  int j; // [esp+24h] [ebp-4h]

  if ( a1 )
  {
    v3 = 51;
    v2 = 13;
  }
  else
  {
    v3 = 1;
    v2 = 50;
  }
  for ( i = 0; ; ++i )
  {
    if ( i >= v2 )
    {
      for ( j = 1; j <= 63; ++j )
        Com_Printf("FILE %2i: '%s'\n", j);
      Com_Error(1, (char *)&byte_8145690);
    }
    if ( !dword_848B800[71 * v3 + 71 * i] )
      break;
  }
  return v3 + i;
}
// 848B800: using guessed type int dword_848B800[];

//----- (0809C690) --------------------------------------------------------
int __cdecl FS_FileForHandle(int a1)
{
  return dword_848B800[71 * a1];
}
// 848B800: using guessed type int dword_848B800[];

//----- (0809C6A4) --------------------------------------------------------
int __cdecl FS_filelength(int a1)
{
  FILE *stream; // [esp+1Ch] [ebp-Ch]
  int v4; // [esp+20h] [ebp-8h]
  int off; // [esp+24h] [ebp-4h]

  FS_CheckFileSystemStarted();
  if ( dword_848B814[71 * a1] )
    return *(_DWORD *)(dword_848B800[71 * a1] + 68);
  stream = (FILE *)FS_FileForHandle(a1);
  off = ftell(stream);
  FS_FileSeek(stream, 0, 2);
  v4 = ftell(stream);
  FS_FileSeek(stream, off, 0);
  return v4;
}
// 848B800: using guessed type int dword_848B800[];
// 848B814: using guessed type int dword_848B814[];

//----- (0809C748) --------------------------------------------------------
_BYTE *__cdecl sub_809C748(_BYTE *a1)
{
  _BYTE *result; // eax
  char v2; // [esp+3h] [ebp-9h]
  _BYTE *v3; // [esp+4h] [ebp-8h]
  _BYTE *v4; // [esp+8h] [ebp-4h]

  v2 = 0;
  v4 = a1;
  v3 = a1;
  while ( *v4 )
  {
    if ( *v4 == 47 || *v4 == 92 )
    {
      if ( !v2 )
      {
        v2 = 1;
        *v3++ = 47;
      }
    }
    else
    {
      v2 = 0;
      *v3++ = *v4;
    }
    ++v4;
  }
  result = v3;
  *v3 = 0;
  return result;
}

//----- (0809C7B4) --------------------------------------------------------
_BYTE *__cdecl FS_BuildOSPath_Internal(char *src, char *s, char *a3, char *dest, int a5)
{
  _BYTE *result; // eax
  size_t v6; // [esp+Ch] [ebp-Ch]
  size_t v7; // [esp+10h] [ebp-8h]
  size_t n; // [esp+14h] [ebp-4h]

  if ( !s || !*s )
    s = byte_848B6C0;
  n = I_strlen(src);
  v7 = I_strlen(s);
  v6 = I_strlen(a3);
  if ( (int)(v6 + n + v7 + 2) <= 255 )
  {
    memcpy(dest, src, n);
    dest[n] = 47;
    memcpy(&dest[n + 1], s, v7);
    dest[n + 1 + v7] = 47;
    memcpy(&dest[n + 2 + v7], a3, v6 + 1);
    return sub_809C748(dest);
  }
  else
  {
    if ( !a5 )
      Com_Error(0, (char *)&byte_81456C0);
    result = dest;
    *dest = 0;
  }
  return result;
}

//----- (0809C8AE) --------------------------------------------------------
_BYTE *__cdecl FS_BuildOSPath(char *src, char *s, char *a3, char *dest)
{
  return FS_BuildOSPath_Internal(src, s, a3, dest, 0);
}

//----- (0809C8DE) --------------------------------------------------------
int __cdecl FS_CreatePath(char *haystack)
{
  char *i; // [esp+14h] [ebp-4h]

  if ( strstr(haystack, "..") || strstr(haystack, "::") )
  {
    Com_Printf("WARNING: refusing to create relative path \"%s\"\n", (char)haystack);
    return 1;
  }
  else
  {
    for ( i = haystack + 1; *i; ++i )
    {
      if ( *i == 47 )
      {
        *i = 0;
        Sys_Mkdir(haystack);
        *i = 47;
      }
    }
    return 0;
  }
}

//----- (0809C974) --------------------------------------------------------
void __cdecl FS_CopyFile(char *filename, char *haystack)
{
  void *ptr; // [esp+1Ch] [ebp-Ch]
  int size; // [esp+20h] [ebp-8h]
  FILE *stream; // [esp+24h] [ebp-4h]
  FILE *streama; // [esp+24h] [ebp-4h]

  stream = FS_FileOpen(filename, "rb");
  if ( stream )
  {
    FS_FileSeek(stream, 0, 2);
    size = ftell(stream);
    FS_FileSeek(stream, 0, 0);
    ptr = malloc(size);
    if ( FS_FileRead(ptr, 1u, size, stream) != size )
      Com_Error(0, (char *)&byte_8145733);
    FS_FileClose(stream);
    if ( FS_CreatePath(haystack) || (streama = FS_FileOpen(haystack, "wb")) == 0 )
    {
      free(ptr);
    }
    else
    {
      if ( FS_FileWrite(ptr, 1u, size, streama) != size )
        Com_Error(0, (char *)&byte_8145760);
      FS_FileClose(streama);
      free(ptr);
    }
  }
}

//----- (0809CACA) --------------------------------------------------------
int __cdecl sub_809CACA(char *filename)
{
  return remove(filename);
}

//----- (0809CADE) --------------------------------------------------------
int __cdecl sub_809CADE(char *a1)
{
  char filename[268]; // [esp+20h] [ebp-118h] BYREF
  FILE *stream; // [esp+12Ch] [ebp-Ch]

  FS_BuildOSPath(*(char **)(fs_homepath + 8), byte_848B6C0, a1, filename);
  stream = FS_FileOpen(filename, "rb");
  if ( !stream )
    return 0;
  FS_FileClose(stream);
  return 1;
}
// 848B7C4: using guessed type int fs_homepath;

//----- (0809CB58) --------------------------------------------------------
int __cdecl sub_809CB58(char *a1, char *a2)
{
  int result; // eax
  char newa[256]; // [esp+10h] [ebp-208h] BYREF
  char old[264]; // [esp+110h] [ebp-108h] BYREF

  FS_CheckFileSystemStarted();
  FS_BuildOSPath(*(char **)(fs_homepath + 8), byte_848B6C0, a1, old);
  FS_BuildOSPath(*(char **)(fs_homepath + 8), byte_848B6C0, a2, newa);
  if ( *(_DWORD *)(fs_debug + 8) )
    Com_Printf("FS_Rename: %s --> %s\n", old, newa);
  result = rename(old, newa);
  if ( result )
  {
    sub_809CACA(newa);
    result = rename(old, newa);
    if ( result )
    {
      FS_CopyFile(old, newa);
      return sub_809CACA(old);
    }
  }
  return result;
}
// 848B7C0: using guessed type int fs_debug;
// 848B7C4: using guessed type int fs_homepath;

//----- (0809CC52) --------------------------------------------------------
void *__cdecl FS_FCloseFile(int a1)
{
  FILE *stream; // [esp+14h] [ebp-4h]

  FS_CheckFileSystemStarted();
  if ( dword_848B818[71 * a1] )
    sub_80D2168();
  if ( dword_848B814[71 * a1] )
  {
    sub_80D0F1A(dword_848B800[71 * a1]);
    if ( dword_848B804[71 * a1] )
      sub_80CFC62(dword_848B800[71 * a1]);
  }
  else if ( a1 )
  {
    stream = (FILE *)FS_FileForHandle(a1);
    FS_FileClose(stream);
  }
  return Com_Memset((void *)(284 * a1 + 138983424), 0, 0x11Cu);
}
// 848B800: using guessed type int dword_848B800[];
// 848B804: using guessed type int dword_848B804[];
// 848B814: using guessed type int dword_848B814[];
// 848B818: using guessed type int dword_848B818[4538];

//----- (0809CD3C) --------------------------------------------------------
int __cdecl FS_GetHandleAndOpenFile(char *src, char *filename, char *modes, int a4)
{
  FILE *v6; // [esp+10h] [ebp-8h]
  int v7; // [esp+14h] [ebp-4h]

  v6 = FS_FileOpen(filename, modes);
  if ( !v6 )
    return 0;
  v7 = FS_HandleForFile(a4);
  dword_848B814[71 * v7] = 0;
  dword_848B800[71 * v7] = (int)v6;
  I_strncpyz((char *)(284 * v7 + 138983452), src, 256);
  dword_848B808[71 * v7] = 0;
  return v7;
}
// 848B800: using guessed type int dword_848B800[];
// 848B808: using guessed type int dword_848B808[];
// 848B814: using guessed type int dword_848B814[];

//----- (0809CDDE) --------------------------------------------------------
int __cdecl FS_FOpenFileWrite(char *src)
{
  char dest[264]; // [esp+20h] [ebp-108h] BYREF

  FS_CheckFileSystemStarted();
  FS_BuildOSPath(*(char **)(fs_homepath + 8), byte_848B6C0, src, dest);
  if ( *(_DWORD *)(fs_debug + 8) )
    Com_Printf("FS_FOpenFileWrite: %s\n", dest);
  if ( FS_CreatePath(dest) )
    return 0;
  else
    return FS_GetHandleAndOpenFile(src, dest, "wb", 0);
}
// 848B7C0: using guessed type int fs_debug;
// 848B7C4: using guessed type int fs_homepath;

//----- (0809CE88) --------------------------------------------------------
int __cdecl FS_FOpenTextFileWrite(char *src)
{
  int v3; // [esp+18h] [ebp-110h]
  char filename[264]; // [esp+20h] [ebp-108h] BYREF

  FS_CheckFileSystemStarted();
  v3 = FS_HandleForFile(0);
  dword_848B814[71 * v3] = 0;
  FS_BuildOSPath(*(char **)(fs_homepath + 8), byte_848B6C0, src, filename);
  if ( *(_DWORD *)(fs_debug + 8) )
    Com_Printf("FS_FOpenFileWrite: %s\n", (char)filename);
  if ( FS_CreatePath(filename) )
    return 0;
  dword_848B800[71 * v3] = (int)FS_FileOpen(filename, "wt");
  I_strncpyz((char *)(284 * v3 + 138983452), src, 256);
  dword_848B808[71 * v3] = 0;
  if ( !dword_848B800[71 * v3] )
    return 0;
  return v3;
}
// 848B7C0: using guessed type int fs_debug;
// 848B7C4: using guessed type int fs_homepath;
// 848B800: using guessed type int dword_848B800[];
// 848B808: using guessed type int dword_848B808[];
// 848B814: using guessed type int dword_848B814[];

//----- (0809CFDA) --------------------------------------------------------
int __cdecl FS_FOpenFileAppend(char *src)
{
  int v3; // [esp+18h] [ebp-110h]
  char filename[264]; // [esp+20h] [ebp-108h] BYREF

  FS_CheckFileSystemStarted();
  v3 = FS_HandleForFile(0);
  dword_848B814[71 * v3] = 0;
  I_strncpyz((char *)(284 * v3 + 138983452), src, 256);
  FS_BuildOSPath(*(char **)(fs_homepath + 8), byte_848B6C0, src, filename);
  if ( *(_DWORD *)(fs_debug + 8) )
    Com_Printf("FS_FOpenFileAppend: %s\n", filename);
  if ( FS_CreatePath(filename) )
    return 0;
  dword_848B800[71 * v3] = (int)FS_FileOpen(filename, "at");
  dword_848B808[71 * v3] = 0;
  if ( !dword_848B800[71 * v3] )
    return 0;
  return v3;
}
// 848B7C0: using guessed type int fs_debug;
// 848B7C4: using guessed type int fs_homepath;
// 848B800: using guessed type int dword_848B800[];
// 848B808: using guessed type int dword_848B808[];
// 848B814: using guessed type int dword_848B814[];

//----- (0809D12A) --------------------------------------------------------
int __cdecl FS_FilenameCompare(char *a1, char *a2)
{
  int v4; // [esp+10h] [ebp-8h]
  int v5; // [esp+14h] [ebp-4h]

  do
  {
    v5 = *a1++;
    v4 = *a2++;
    if ( (unsigned __int8)sub_80B53C8(v5) )
      v5 -= 32;
    if ( (unsigned __int8)sub_80B53C8(v4) )
      v4 -= 32;
    if ( v5 == 92 || v5 == 58 )
      v5 = 47;
    if ( v4 == 92 || v4 == 58 )
      v4 = 47;
    if ( v5 != v4 )
      return -1;
  }
  while ( v5 );
  return 0;
}

//----- (0809D1C6) --------------------------------------------------------
int __cdecl sub_809D1C6(char *filename, char *a2)
{
  _BYTE *v4; // [esp+14h] [ebp-24h]
  _BYTE *v5; // [esp+18h] [ebp-20h]
  void *v6; // [esp+1Ch] [ebp-1Ch]
  void *ptr; // [esp+20h] [ebp-18h]
  int offa; // [esp+24h] [ebp-14h]
  int offb; // [esp+24h] [ebp-14h]
  int off; // [esp+24h] [ebp-14h]
  int size; // [esp+28h] [ebp-10h]
  int n; // [esp+2Ch] [ebp-Ch]
  FILE *v13; // [esp+30h] [ebp-8h]
  FILE *stream; // [esp+34h] [ebp-4h]

  stream = FS_FileOpen(filename, "rb");
  if ( !stream )
    Com_Error(0, (char *)&byte_81457E0, filename);
  v13 = FS_FileOpen(a2, "rb");
  if ( v13 )
  {
    offa = ftell(stream);
    FS_FileSeek(stream, 0, 2);
    n = ftell(stream);
    FS_FileSeek(stream, offa, 0);
    offb = ftell(v13);
    FS_FileSeek(v13, 0, 2);
    size = ftell(v13);
    FS_FileSeek(v13, offb, 0);
    if ( n == size )
    {
      ptr = Z_MallocInternal(n);
      if ( FS_FileRead(ptr, 1u, n, stream) != n )
        Com_Error(0, (char *)&byte_8145820);
      FS_FileClose(stream);
      v6 = Z_MallocInternal(size);
      if ( FS_FileRead(v6, 1u, size, v13) != size )
        Com_Error(0, (char *)&byte_8145820);
      FS_FileClose(v13);
      v5 = ptr;
      v4 = v6;
      for ( off = 0; off < n; ++off )
      {
        if ( *v5 != *v4 )
        {
          free(ptr);
          free(v6);
          return 0;
        }
        ++v5;
        ++v4;
      }
      free(ptr);
      free(v6);
      return 1;
    }
    else
    {
      FS_FileClose(stream);
      FS_FileClose(v13);
      return 0;
    }
  }
  else
  {
    FS_FileClose(stream);
    return 0;
  }
}

//----- (0809D424) --------------------------------------------------------
char *__cdecl sub_809D424(char *haystack, int a2, char a3)
{
  int i; // [esp+1Ch] [ebp-10Ch]
  char needle[264]; // [esp+20h] [ebp-108h] BYREF

  for ( i = 0; *(_BYTE *)(a2 + i); ++i )
    needle[i] = *(_BYTE *)(i + a2) + a3;
  needle[i] = 0;
  return strstr(haystack, needle);
}
// 809D424: using guessed type char needle[264];

//----- (0809D498) --------------------------------------------------------
_BOOL4 __cdecl FS_PureIgnoreFiles(char *s1)
{
  if ( *s1 == 46 )
    ++s1;
  if ( !strcasecmp(s1, "cfg") )
    return 1;
  if ( I_stricmp(s1, "menu") )
    return I_stricmp(s1, ".dm_NETWORK_PROTOCOL_VERSION") == 0;
  return 1;
}

//----- (0809D516) --------------------------------------------------------
_BOOL4 __cdecl sub_809D516(_BYTE *a1)
{
  return *a1 == 46 && a1[1] == 46 || *a1 == 58 && a1[1] == 58;
}

//----- (0809D55C) --------------------------------------------------------
_BOOL4 __cdecl FS_IsBackupSubStr(char a1)
{
  return a1 == 47 || a1 == 92;
}
// 809D582: conditional instruction was optimized away because %arg_0.1!=2F

//----- (0809D59E) --------------------------------------------------------
int __cdecl FS_SanitizeFilename(int a1, int a2)
{
  int v4; // [esp+10h] [ebp-8h]
  int i; // [esp+14h] [ebp-4h]

  for ( i = 0; FS_IsBackupSubStr(*(_BYTE *)(a1 + i)); ++i )
    ;
  v4 = 0;
  while ( *(_BYTE *)(a1 + i) )
  {
    if ( sub_809D516((_BYTE *)(a1 + i)) )
      return 0;
    if ( *(_BYTE *)(a1 + i) != 46 || *(_BYTE *)(a1 + i + 1) && !FS_IsBackupSubStr(*(_BYTE *)(a1 + i + 1)) )
    {
      if ( FS_IsBackupSubStr(*(_BYTE *)(a1 + i)) )
      {
        *(_BYTE *)(a2 + v4) = 47;
        while ( FS_IsBackupSubStr(*(_BYTE *)(a1 + i + 1)) )
          ++i;
      }
      else
      {
        *(_BYTE *)(v4 + a2) = *(_BYTE *)(a1 + i);
      }
      ++v4;
    }
    ++i;
  }
  *(_BYTE *)(a2 + v4) = 0;
  return 1;
}

//----- (0809D6A2) --------------------------------------------------------
int __cdecl sub_809D6A2(char *a1)
{
  size_t v1; // eax
  size_t v4; // [esp+18h] [ebp-30h]
  int i; // [esp+1Ch] [ebp-2Ch]
  char *s[10]; // [esp+20h] [ebp-28h]

  s[0] = ".hlsl";
  s[1] = ".txt";
  s[2] = ".cfg";
  s[3] = ".levelshots";
  s[4] = ".menu";
  s[5] = ".arena";
  s[6] = ".str";
  s[7] = (char *)&byte_8145895;
  v4 = I_strlen(a1);
  for ( i = 0; *s[i]; ++i )
  {
    v1 = strlen(s[i]);
    if ( !I_stricmp(&a1[v4 - v1], s[i]) )
      return 1;
  }
  return 0;
}

//----- (0809D756) --------------------------------------------------------
int __cdecl FS_FOpenFileRead_Internal(const char *a1, int *a2, int a3, int a4)
{
  int v4; // ebx
  int v5; // ebx
  char *v6; // eax
  int v8; // [esp+8h] [ebp-370h]
  char haystack[271]; // [esp+30h] [ebp-348h] BYREF
  char v11; // [esp+13Fh] [ebp-239h]
  char v12[4]; // [esp+140h] [ebp-238h]
  char *s1; // [esp+144h] [ebp-234h]
  FILE *stream; // [esp+148h] [ebp-230h]
  void *dest; // [esp+14Ch] [ebp-22Ch]
  int v16; // [esp+150h] [ebp-228h]
  void *v17; // [esp+154h] [ebp-224h]
  int v18; // [esp+158h] [ebp-220h]
  char *v19; // [esp+15Ch] [ebp-21Ch]
  char filename[256]; // [esp+160h] [ebp-218h] BYREF
  char src[268]; // [esp+260h] [ebp-118h] BYREF
  void *i; // [esp+36Ch] [ebp-Ch]

  v11 = 0;
  v16 = 0;
  FS_CheckFileSystemStarted();
  v8 = 256;
  if ( !(unsigned __int8)FS_SanitizeFilename((int)a1, (int)src) )
  {
    if ( a2 )
      *a2 = 0;
    return -1;
  }
  if ( !a2 )
  {
    for ( i = fs_searchpaths; ; i = *(void **)i )
    {
      if ( !i )
        return -1;
      if ( FS_UseSearchPath((int)i) )
      {
        if ( *((_DWORD *)i + 1) )
          v16 = FS_HashFileName((int)src, *(_DWORD *)(*((_DWORD *)i + 1) + 788));
        if ( *((_DWORD *)i + 1) && *(_DWORD *)(*(_DWORD *)(*((_DWORD *)i + 1) + 792) + 4 * v16) )
        {
          v19 = (char *)*((_DWORD *)i + 1);
          v18 = *(_DWORD *)(*((_DWORD *)v19 + 198) + 4 * v16);
          while ( FS_FilenameCompare(*(char **)(v18 + 4), src) )
          {
            v18 = *(_DWORD *)(v18 + 8);
            if ( !v18 )
              goto LABEL_21;
          }
          return 1;
        }
        if ( *((_DWORD *)i + 2) )
        {
          v17 = (void *)*((_DWORD *)i + 2);
          FS_BuildOSPath_Internal((char *)v17, (char *)v17 + 256, src, filename, a4);
          stream = FS_FileOpen(filename, "rb");
          if ( stream )
          {
            FS_FileClose(stream);
            return 1;
          }
        }
      }
LABEL_21:
      ;
    }
  }
  *a2 = FS_HandleForFile(a4);
  dword_848B804[71 * *a2] = a3;
  *(_DWORD *)v12 = 0;
  for ( i = fs_searchpaths; ; i = *(void **)i )
  {
    if ( !i )
    {
      if ( *(_DWORD *)(fs_debug + 8) && !a4 )
        Com_Printf("Can't find %s\n", a1);
      *a2 = 0;
      if ( *(_DWORD *)v12 )
      {
        v6 = va(aExeUnpureclien_0, *(_DWORD *)v12, v8);
        Com_Error(1, v6);
      }
      if ( v11 )
        return -2;
      else
        return -1;
    }
    if ( FS_UseSearchPath((int)i) )
      break;
LABEL_71:
    ;
  }
  v19 = (char *)*((_DWORD *)i + 1);
  if ( v19 )
    v16 = FS_HashFileName((int)src, *((_DWORD *)v19 + 197));
  if ( !v19 || !*(_DWORD *)(*((_DWORD *)v19 + 198) + 4 * v16) )
  {
    if ( *((_DWORD *)i + 2) )
    {
      s1 = Com_GetExtensionSubString(src);
      if ( !*(_BYTE *)(fs_restrict + 8) && !fs_numServerIwds || *((_DWORD *)i + 3) || FS_PureIgnoreFiles(s1) )
      {
        v17 = (void *)*((_DWORD *)i + 2);
        FS_BuildOSPath_Internal((char *)v17, (char *)v17 + 256, src, filename, a4);
        v5 = 71 * *a2;
        dword_848B800[v5] = (int)FS_FileOpen(filename, "rb");
        if ( dword_848B800[71 * *a2] )
        {
          if ( !*((_DWORD *)i + 3) && !FS_PureIgnoreFiles(s1) )
            *(_DWORD *)dword_848B7F0 = rand() + 1;
          I_strncpyz((char *)(284 * *a2 + 138983452), src, 256);
          dword_848B814[71 * *a2] = 0;
          if ( *(_DWORD *)(fs_debug + 8) && !a4 )
            Com_Printf("FS_FOpenFileRead: %s (found in '%s/%s')\n", src, (const char *)v17, (const char *)v17 + 256);
          if ( *(_BYTE *)(fs_copyfiles + 8) && !I_stricmp((char *)v17, *(char **)(fs_cdpath + 8)) )
          {
            FS_BuildOSPath_Internal(*(char **)(fs_basepath + 8), (char *)v17 + 256, src, haystack, a4);
            FS_CopyFile(filename, haystack);
          }
          return FS_filelength(*a2);
        }
      }
      else if ( !v11 )
      {
        v17 = (void *)*((_DWORD *)i + 2);
        FS_BuildOSPath_Internal((char *)v17, (char *)v17 + 256, src, filename, a4);
        stream = FS_FileOpen(filename, "rb");
        if ( stream )
        {
          v11 = 1;
          FS_FileClose(stream);
        }
      }
    }
    goto LABEL_71;
  }
  v18 = *(_DWORD *)(*((_DWORD *)v19 + 198) + 4 * v16);
  while ( FS_FilenameCompare(*(char **)(v18 + 4), src) )
  {
    v18 = *(_DWORD *)(v18 + 8);
    if ( !v18 )
      goto LABEL_71;
  }
  if ( !*((_DWORD *)i + 3) && !FS_IwdIsPure((int)v19) )
  {
    *(_DWORD *)v12 = v19;
    goto LABEL_71;
  }
  if ( !v19[784] && !(unsigned __int8)sub_809D6A2(src) )
    v19[784] = 1;
  if ( a3 )
  {
    v4 = 71 * *a2;
    dword_848B800[v4] = (int)sub_80CF90C(v19, *((void **)v19 + 192));
    if ( !dword_848B800[71 * *a2] )
    {
      if ( !a4 )
        Com_Error(0, (char *)&byte_8145896, v19);
      FS_FCloseFile(*a2);
      *a2 = 0;
      return -1;
    }
  }
  else
  {
    dword_848B800[71 * *a2] = *((_DWORD *)v19 + 192);
  }
  I_strncpyz((char *)(284 * *a2 + 138983452), src, 256);
  dword_848B814[71 * *a2] = (int)v19;
  dest = (void *)dword_848B800[71 * *a2];
  stream = *(FILE **)dest;
  unzSetCurrentFileInfoPosition(*((_DWORD *)v19 + 192), *(_DWORD *)v18);
  if ( dest != *((void **)v19 + 192) )
    Com_Memcpy(dest, *((void **)v19 + 192), 0x80u);
  *(_DWORD *)dest = stream;
  unzOpenCurrentFile((_DWORD *)dword_848B800[71 * *a2]);
  dword_848B810[71 * *a2] = *(_DWORD *)v18;
  if ( *(_DWORD *)(fs_debug + 8) && !a4 )
    Com_Printf("FS_FOpenFileRead: %s (found in '%s')\n", src, v19);
  return *((_DWORD *)dest + 17);
}
// 809DFF0: variable 'v8' is possibly undefined
// 848B7C0: using guessed type int fs_debug;
// 848B7D4: using guessed type int fs_cdpath;
// 848B7D8: using guessed type int fs_copyfiles;
// 848B7E0: using guessed type int fs_restrict;
// 848B800: using guessed type int dword_848B800[];
// 848B804: using guessed type int dword_848B804[];
// 848B810: using guessed type int dword_848B810[];
// 848B814: using guessed type int dword_848B814[];
// 848FF00: using guessed type int fs_numServerIwds;
// 809D756: using guessed type const char *arg_0;

//----- (0809E034) --------------------------------------------------------
int __cdecl FS_FOpenFileReadStream(const char *a1, int *a2, int a3)
{
  return FS_FOpenFileRead_Internal(a1, a2, a3, 1);
}

//----- (0809E064) --------------------------------------------------------
int __cdecl FS_FOpenFileRead(const char *a1, int *a2, int a3)
{
  dword_848B6A0 = 1;
  return FS_FOpenFileRead_Internal(a1, a2, a3, 0);
}
// 848B6A0: using guessed type int dword_848B6A0;

//----- (0809E09E) --------------------------------------------------------
int __cdecl FS_TouchFile(const char *a1)
{
  int v3; // [esp+14h] [ebp-4h] BYREF

  FS_FOpenFileRead(a1, &v3, 0);
  if ( !v3 )
    return 0;
  FS_FCloseFile(v3);
  return 1;
}

//----- (0809E0E4) --------------------------------------------------------
char *__cdecl sub_809E0E4(char *a1)
{
  FILE *stream; // [esp+18h] [ebp-120h]
  char *src; // [esp+1Ch] [ebp-11Ch]
  char filename[268]; // [esp+20h] [ebp-118h] BYREF
  int *i; // [esp+12Ch] [ebp-Ch]

  for ( i = (int *)fs_searchpaths; i; i = (int *)*i )
  {
    if ( FS_UseSearchPath((int)i) )
    {
      if ( i[2] )
      {
        src = (char *)i[2];
        FS_BuildOSPath(src, src + 256, a1, filename);
        stream = FS_FileOpen(filename, "rb");
        if ( stream )
        {
          FS_FileClose(stream);
          return va("%s/%s", src + 256, a1);
        }
      }
    }
  }
  return 0;
}

//----- (0809E1DA) --------------------------------------------------------
_BOOL4 __cdecl sub_809E1DA(char *a1)
{
  char filename[264]; // [esp+20h] [ebp-108h] BYREF

  FS_CheckFileSystemStarted();
  if ( !*a1 )
    return 0;
  FS_BuildOSPath(*(char **)(fs_homepath + 8), byte_848B6C0, a1, filename);
  return remove(filename) != -1;
}
// 848B7C4: using guessed type int fs_homepath;

//----- (0809E256) --------------------------------------------------------
_BOOL4 __cdecl sub_809E256(char *a1, int a2)
{
  __mode_t v3; // [esp+18h] [ebp-180h]
  struct stat stat_buf; // [esp+20h] [ebp-178h] BYREF
  char file[264]; // [esp+90h] [ebp-108h] BYREF

  FS_CheckFileSystemStarted();
  FS_BuildOSPath(*(char **)(fs_homepath + 8), byte_848B6C0, a1, file);
  if ( FS_stat(file, &stat_buf) == -1 )
    return 0;
  if ( a2 )
    v3 = stat_buf.st_mode & 0xFFFFFEFF;
  else
    v3 = stat_buf.st_mode | 0x100;
  stat_buf.st_mode = v3;
  return chmod(file, v3) != -1;
}
// 848B7C4: using guessed type int fs_homepath;

//----- (0809E328) --------------------------------------------------------
int __cdecl FS_Read(int a1, unsigned int a2, int a3)
{
  FILE *stream; // [esp+20h] [ebp-18h]
  int v6; // [esp+24h] [ebp-14h]
  char *ptr; // [esp+28h] [ebp-10h]
  size_t v8; // [esp+2Ch] [ebp-Ch]
  size_t v9; // [esp+30h] [ebp-8h]

  FS_CheckFileSystemStarted();
  if ( !a3 )
    return 0;
  if ( dword_848B814[71 * a3] )
    return sub_80D0AA8(dword_848B800[71 * a3], a1, a2);
  stream = (FILE *)FS_FileForHandle(a3);
  ptr = (char *)a1;
  v9 = a2;
  v6 = 0;
  while ( 1 )
  {
    if ( !v9 )
      return a2;
    v8 = FS_FileRead(ptr, 1u, v9, stream);
    if ( !v8 )
    {
      if ( v6 )
        return a2 - v9;
      v6 = 1;
    }
    if ( v8 == -1 )
      break;
    v9 -= v8;
    ptr += v8;
  }
  if ( a3 <= 50 || a3 > 63 )
    Com_Error(0, (char *)&byte_814595B);
  return -1;
}
// 848B800: using guessed type int dword_848B800[];
// 848B814: using guessed type int dword_848B814[];

//----- (0809E454) --------------------------------------------------------
size_t __cdecl FS_Write(char *a1, size_t a2, int a3)
{
  FILE *stream; // [esp+20h] [ebp-18h]
  int v6; // [esp+24h] [ebp-14h]
  size_t v8; // [esp+2Ch] [ebp-Ch]
  size_t v9; // [esp+30h] [ebp-8h]

  FS_CheckFileSystemStarted();
  if ( !a3 )
    return 0;
  stream = (FILE *)FS_FileForHandle(a3);
  v9 = a2;
  v6 = 0;
  while ( v9 )
  {
    v8 = FS_FileWrite(a1, 1u, v9, stream);
    if ( !v8 )
    {
      if ( v6 )
        return 0;
      v6 = 1;
    }
    if ( v8 == -1 )
      return 0;
    v9 -= v8;
    a1 += v8;
  }
  if ( dword_848B808[71 * a3] )
    fflush(stream);
  return a2;
}
// 848B808: using guessed type int dword_848B808[];

//----- (0809E52A) --------------------------------------------------------
size_t FS_Printf(int a1, char *format, ...)
{
  size_t v2; // eax
  char s[4108]; // [esp+10h] [ebp-1018h] BYREF
  __gnuc_va_list __varargs; // [esp+101Ch] [ebp-Ch]
  va_list va; // [esp+1038h] [ebp+10h] BYREF

  va_start(va, format);
  va_copy(__varargs, va);
  vsprintf(s, format, va);
  v2 = I_strlen(s);
  return FS_Write(s, v2, a1);
}

//----- (0809E580) --------------------------------------------------------
int __cdecl sub_809E580(int a1, int off, int a3)
{
  int v3; // eax
  FILE *stream; // [esp+14h] [ebp-14h]
  unsigned int v8; // [esp+18h] [ebp-10h]
  int v9; // [esp+1Ch] [ebp-Ch]

  FS_CheckFileSystemStarted();
  if ( dword_848B818[71 * a1] )
  {
    dword_848B818[71 * a1] = 0;
    sub_80D2194(a1, off, a3);
    dword_848B818[71 * a1] = 1;
  }
  if ( !dword_848B814[71 * a1] )
  {
    stream = (FILE *)FS_FileForHandle(a1);
    if ( a3 == 1 )
      return FS_FileSeek(stream, off, 2);
    if ( a3 > 1 )
    {
      if ( a3 != 2 )
        return 0;
      return FS_FileSeek(stream, off, 0);
    }
    else
    {
      if ( a3 )
        return 0;
      return FS_FileSeek(stream, off, 1);
    }
  }
  if ( off || a3 != 2 )
  {
    if ( off || a3 )
    {
      v9 = sub_80D0D98(dword_848B800[71 * a1]);
      if ( a3 )
      {
        if ( a3 == 1 )
        {
          if ( off + FS_filelength(a1) >= v9 )
          {
            v8 = off + FS_filelength(a1) - v9;
          }
          else
          {
            unzSetCurrentFileInfoPosition(dword_848B800[71 * a1], dword_848B810[71 * a1]);
            unzOpenCurrentFile((_DWORD *)dword_848B800[71 * a1]);
            v8 = off + FS_filelength(a1);
          }
          v3 = sub_80D0AA8(dword_848B800[71 * a1], 0, v8);
        }
        else
        {
          if ( a3 != 2 )
            return -1;
          if ( off >= v9 )
          {
            v3 = sub_80D0AA8(dword_848B800[71 * a1], 0, off - v9);
          }
          else
          {
            unzSetCurrentFileInfoPosition(dword_848B800[71 * a1], dword_848B810[71 * a1]);
            unzOpenCurrentFile((_DWORD *)dword_848B800[71 * a1]);
            v3 = sub_80D0AA8(dword_848B800[71 * a1], 0, off);
          }
        }
      }
      else if ( off >= 0 )
      {
        v3 = sub_80D0AA8(dword_848B800[71 * a1], 0, off);
      }
      else
      {
        unzSetCurrentFileInfoPosition(dword_848B800[71 * a1], dword_848B810[71 * a1]);
        unzOpenCurrentFile((_DWORD *)dword_848B800[71 * a1]);
        v3 = sub_80D0AA8(dword_848B800[71 * a1], 0, v9 + off);
      }
      if ( v3 )
        return 0;
      else
        return -1;
    }
    else
    {
      return 0;
    }
  }
  else
  {
    unzSetCurrentFileInfoPosition(dword_848B800[71 * a1], dword_848B810[71 * a1]);
    return unzOpenCurrentFile((_DWORD *)dword_848B800[71 * a1]);
  }
}
// 848B800: using guessed type int dword_848B800[];
// 848B810: using guessed type int dword_848B810[];
// 848B814: using guessed type int dword_848B814[];
// 848B818: using guessed type int dword_848B818[4538];

//----- (0809E892) --------------------------------------------------------
int __cdecl FS_ReadFile(const char *a1, _DWORD *a2)
{
  int v4; // [esp+1Ch] [ebp-Ch]
  _DWORD *v5; // [esp+20h] [ebp-8h]
  int v6; // [esp+24h] [ebp-4h] BYREF

  FS_CheckFileSystemStarted();
  if ( !a1 || !*a1 )
    Com_Error(0, (char *)&byte_8145973);
  v4 = FS_FOpenFileRead(a1, &v6, 0);
  if ( v6 )
  {
    if ( a2 )
    {
      ++fs_loadStack;
      v5 = Hunk_AllocateTempMemoryInternal(v4 + 1);
      *a2 = v5;
      FS_Read((int)v5, v4, v6);
      *((_BYTE *)v5 + v4) = 0;
    }
    FS_FCloseFile(v6);
    return v4;
  }
  else
  {
    if ( a2 )
      *a2 = 0;
    return -1;
  }
}
// 848B6A4: using guessed type int fs_loadStack;

//----- (0809E970) --------------------------------------------------------
void FS_ResetFiles()
{
  fs_loadStack = 0;
}
// 848B6A4: using guessed type int fs_loadStack;

//----- (0809E980) --------------------------------------------------------
void __cdecl FS_FreeFile(_DWORD *ptr)
{
  FS_CheckFileSystemStarted();
  --fs_loadStack;
  Hunk_FreeTempMemory(ptr);
}
// 848B6A4: using guessed type int fs_loadStack;

//----- (0809E99E) --------------------------------------------------------
int __cdecl sub_809E99E(char *src, char *a2, int a3)
{
  size_t v5; // [esp+10h] [ebp-8h]
  int v6; // [esp+14h] [ebp-4h]

  FS_CheckFileSystemStarted();
  v6 = FS_FOpenFileWrite(src);
  if ( v6 )
  {
    v5 = FS_Write(a2, a3, v6);
    FS_FCloseFile(v6);
    if ( v5 == a3 )
    {
      return 1;
    }
    else
    {
      sub_809E1DA(src);
      return 0;
    }
  }
  else
  {
    Com_Printf("Failed to open %s\n", src);
    return 0;
  }
}

//----- (0809EA28) --------------------------------------------------------
int __cdecl sub_809EA28(int a1, char *filename)
{
  FILE *stream; // [esp+24h] [ebp-114h]
  char *i; // [esp+2Ch] [ebp-10Ch]
  char v6[264]; // [esp+30h] [ebp-108h] BYREF

  if ( !(unsigned __int8)FS_SanitizeFilename(a1, (int)v6) )
    return -1;
  for ( i = (char *)fs_searchpaths; i; i = *(char **)i )
  {
    if ( FS_UseSearchPath((int)i) && !*((_DWORD *)i + 1) )
    {
      FS_BuildOSPath_Internal(*((char **)i + 2), (char *)(*((_DWORD *)i + 2) + 256), v6, filename, 0);
      stream = FS_FileOpen(filename, "rb");
      if ( stream )
      {
        FS_FileClose(stream);
        return 0;
      }
    }
  }
  return -1;
}

//----- (0809EB4A) --------------------------------------------------------
int sub_809EB4A()
{
  return 0;
}

//----- (0809EB54) --------------------------------------------------------
char *__cdecl FS_LoadZipFile(char *filename, char *a2)
{
  size_t v2; // eax
  char *v3; // ebx
  char *v4; // ebx
  char *v5; // ebx
  int v6; // eax
  char *v7; // ebx
  char *v8; // ebx
  char *v11; // [esp+28h] [ebp-190h]
  char *ptr; // [esp+2Ch] [ebp-18Ch]
  int v13; // [esp+30h] [ebp-188h]
  int v14; // [esp+34h] [ebp-184h]
  int v15; // [esp+38h] [ebp-180h]
  unsigned int i; // [esp+3Ch] [ebp-17Ch]
  int j; // [esp+3Ch] [ebp-17Ch]
  int k; // [esp+3Ch] [ebp-17Ch]
  unsigned int m; // [esp+3Ch] [ebp-17Ch]
  int v20[20]; // [esp+40h] [ebp-178h] BYREF
  char src[264]; // [esp+90h] [ebp-128h] BYREF
  unsigned int v22; // [esp+198h] [ebp-20h] BYREF
  int v23; // [esp+1A0h] [ebp-18h]
  int v24; // [esp+1A4h] [ebp-14h]
  char *dest; // [esp+1A8h] [ebp-10h]
  _DWORD *v26; // [esp+1ACh] [ebp-Ch]

  v13 = 0;
  v24 = (int)unzOpen(filename);
  v23 = unzGetGlobalInfo(v24, &v22);
  if ( v23 )
    return 0;
  *(_DWORD *)fs_packFiles += v22;
  v15 = 0;
  unzGoToFirstFile(v24);
  for ( i = 0; i < v22; ++i )
  {
    v23 = unzGetCurrentFileInfo((FILE **)v24, v20, src, 256, 0, 0, 0, 0);
    if ( v23 )
      break;
    v15 += I_strlen(src) + 1;
    unzGoToNextFile(v24);
  }
  v26 = Z_MallocInternal(v15 + 12 * v22);
  v11 = (char *)&v26[3 * v22];
  ptr = (char *)Z_MallocInternal(4 * v22);
  for ( j = 1; j <= 1024 && j <= v22; j *= 2 )
    ;
  dest = (char *)Z_MallocInternal(4 * j + 800);
  *((_DWORD *)dest + 197) = j;
  *((_DWORD *)dest + 198) = dest + 800;
  for ( k = 0; k < *((_DWORD *)dest + 197); ++k )
    *(_DWORD *)(*((_DWORD *)dest + 198) + 4 * k) = 0;
  I_strncpyz(dest, filename, 256);
  I_strncpyz(dest + 256, a2, 256);
  if ( strlen(dest + 256) > 4 )
  {
    v2 = strlen(dest + 256);
    if ( !I_stricmp(&dest[v2 + 252], ".iwd") )
    {
      v3 = dest;
      v3[strlen(dest + 256) + 252] = 0;
    }
  }
  *((_DWORD *)dest + 192) = v24;
  *((_DWORD *)dest + 195) = v22;
  unzGoToFirstFile(v24);
  for ( m = 0; m < v22; ++m )
  {
    v23 = unzGetCurrentFileInfo((FILE **)v24, v20, src, 256, 0, 0, 0, 0);
    if ( v23 )
      break;
    if ( v20[7] )
      *(_DWORD *)&ptr[4 * v13++] = LittleLong(v20[5]);
    I_strlwr(src);
    v14 = FS_HashFileName((int)src, *((_DWORD *)dest + 197));
    v26[3 * m + 1] = v11;
    strcpy((char *)v26[3 * m + 1], src);
    v11 += strlen(src) + 1;
    sub_80D0417(v24, &v26[3 * m]);
    v26[3 * m + 2] = *(_DWORD *)(*((_DWORD *)dest + 198) + 4 * v14);
    *(_DWORD *)(*((_DWORD *)dest + 198) + 4 * v14) = &v26[3 * m];
    unzGoToNextFile(v24);
  }
  v4 = dest;
  *((_DWORD *)v4 + 193) = Com_BlockChecksum(ptr, 4 * v13);
  v5 = dest;
  v6 = LittleLong(fs_checksumFeed);
  *((_DWORD *)v5 + 194) = sub_806769E(ptr, 4 * v13, v6);
  v7 = dest;
  *((_DWORD *)v7 + 193) = LittleLong(*((_DWORD *)dest + 193));
  v8 = dest;
  *((_DWORD *)v8 + 194) = LittleLong(*((_DWORD *)dest + 194));
  Z_FreeInternal(ptr);
  *((_DWORD *)dest + 199) = v26;
  return dest;
}
// 848B7F4: using guessed type int fs_checksumFeed;

//----- (0809F09C) --------------------------------------------------------
int __cdecl sub_809F09C(char *src, char *dest, _DWORD *a3)
{
  int v4; // [esp+Ch] [ebp-Ch]
  int i; // [esp+10h] [ebp-8h]
  int v6; // [esp+14h] [ebp-4h]

  v4 = 0;
  *dest = 0;
  v6 = 0;
  for ( i = 0; src[i]; ++i )
  {
    if ( src[i] == 47 || src[i] == 92 )
    {
      v6 = i;
      ++v4;
    }
  }
  strcpy(dest, src);
  dest[v6] = 0;
  if ( v6 + 1 == i )
    --v4;
  *a3 = v4;
  return v6;
}

//----- (0809F12A) --------------------------------------------------------
int __cdecl sub_809F12A(char *src, int a2, int a3)
{
  int i; // [esp+14h] [ebp-4h]

  if ( a3 == 4095 )
    return 4095;
  for ( i = 0; i < a3; ++i )
  {
    if ( !I_stricmp(src, *(char **)(a2 + 4 * i)) )
      return a3;
  }
  *(_DWORD *)(a2 + 4 * a3) = CopyStringInternal(src);
  return a3 + 1;
}

//----- (0809F1B2) --------------------------------------------------------
_DWORD *__cdecl FS_ListFilteredFiles(int a1, int a2, char *a3, int a4, int a5, int *a6)
{
  size_t v6; // eax
  char name[256]; // [esp+30h] [ebp-4398h] BYREF
  char dest[64]; // [esp+130h] [ebp-4298h] BYREF
  int v11; // [esp+170h] [ebp-4258h] BYREF
  void *ptr; // [esp+174h] [ebp-4254h]
  char *s; // [esp+178h] [ebp-4250h]
  bool v14; // [esp+17Fh] [ebp-4249h] BYREF
  char src[256]; // [esp+180h] [ebp-4248h] BYREF
  char v16[268]; // [esp+280h] [ebp-4148h] BYREF
  int v17; // [esp+38Ch] [ebp-403Ch]
  int v18; // [esp+390h] [ebp-4038h]
  int v19; // [esp+394h] [ebp-4034h]
  int v20; // [esp+398h] [ebp-4030h] BYREF
  int v21; // [esp+39Ch] [ebp-402Ch]
  int v22; // [esp+3A0h] [ebp-4028h]
  int v23; // [esp+3A4h] [ebp-4024h]
  int j; // [esp+3A8h] [ebp-4020h]
  int i; // [esp+3ACh] [ebp-401Ch]
  int v26[4098]; // [esp+3B0h] [ebp-4018h] BYREF
  _DWORD *v27; // [esp+43B8h] [ebp-10h]
  int v28; // [esp+43BCh] [ebp-Ch]

  FS_CheckFileSystemStarted();
  if ( !a2 )
  {
    *a6 = 0;
    return 0;
  }
  if ( !a3 )
    a3 = (char *)&byte_8145895;
  if ( !(unsigned __int8)FS_SanitizeFilename(a2, (int)src) )
  {
    *a6 = 0;
    return 0;
  }
  v14 = I_stricmp(a3, "/") == 0;
  v23 = I_strlen(src);
  if ( v23 && (src[v23 - 1] == 92 || src[v23 - 1] == 47) )
    --v23;
  v22 = I_strlen(a3);
  v28 = 0;
  sub_809F09C(src, v16, &v20);
  if ( src[0] )
    ++v20;
  for ( i = a1; i; i = *(_DWORD *)i )
  {
    if ( FS_UseSearchPath(i) )
    {
      if ( *(_DWORD *)(i + 4) )
      {
        if ( *(_DWORD *)(i + 12) || FS_IwdIsPure(*(_DWORD *)(i + 4)) )
        {
          v18 = *(_DWORD *)(i + 4);
          v17 = *(_DWORD *)(v18 + 796);
          for ( j = 0; j < *(_DWORD *)(v18 + 780); ++j )
          {
            s = *(char **)(v17 + 12 * j + 4);
            if ( a4 )
            {
              if ( (unsigned __int8)Com_FilterPath(a4, (int)s, 0) )
                v28 = sub_809F12A(s, (int)v26, v28);
            }
            else
            {
              ptr = (void *)sub_809F09C(s, v16, &v11);
              if ( v11 == v20 && v23 <= (int)ptr && (v23 <= 0 || s[v23] == 47) && !sub_80B550A(s, src, v23) )
              {
                if ( v14 )
                {
                  v6 = strlen(s);
                  if ( s[v6 - 1] != 47 )
                    continue;
                }
                else if ( v22 )
                {
                  v21 = I_strlen(s);
                  if ( v21 <= v22 || s[v21 - v22 - 1] != 46 || I_stricmp(&s[v21 - v22], a3) )
                    continue;
                }
                v19 = v23;
                if ( v23 )
                  ++v19;
                if ( v14 )
                {
                  strcpy(dest, &s[v19]);
                  name[strlen(dest) + 255] = 0;
                  v28 = sub_809F12A(dest, (int)v26, v28);
                }
                else
                {
                  v28 = sub_809F12A(&s[v19], (int)v26, v28);
                }
              }
            }
          }
        }
      }
      else if ( *(_DWORD *)(i + 8) && (!*(_BYTE *)(fs_restrict + 8) && !fs_numServerIwds || a5) )
      {
        FS_BuildOSPath(*(char **)(i + 8), (char *)(*(_DWORD *)(i + 8) + 256), src, name);
        ptr = Sys_ListFiles(name, a3, a4, &v11, v14);
        for ( j = 0; j < v11; ++j )
        {
          s = (char *)*((_DWORD *)ptr + j);
          v28 = sub_809F12A(s, (int)v26, v28);
        }
        Sys_FreeFileList((void **)ptr);
      }
    }
  }
  *a6 = v28;
  if ( !v28 )
    return 0;
  v27 = Z_MallocInternal(4 * v28 + 4);
  for ( j = 0; j < v28; ++j )
    v27[j] = v26[j];
  v27[j] = 0;
  return v27;
}
// 848B7E0: using guessed type int fs_restrict;
// 848FF00: using guessed type int fs_numServerIwds;
// 809F1B2: using guessed type int var_4018[4098];

//----- (0809F7B2) --------------------------------------------------------
_DWORD *__cdecl FS_ListFiles(int a1, char *a2, int a3, int *a4)
{
  return FS_ListFilteredFiles((int)fs_searchpaths, a1, a2, 0, a3, a4);
}

//----- (0809F7F2) --------------------------------------------------------
_DWORD *__cdecl sub_809F7F2(int a1, char *a2, int a3, int *a4, int a5)
{
  return sub_809F98A(a1, a2, 0, a3, a4, a5);
}

//----- (0809F830) --------------------------------------------------------
_BOOL4 __cdecl sub_809F830(char *a1, int a2)
{
  if ( a2 == 63 )
    return 1;
  if ( (a2 & 1) != 0 && !I_strncmp(a1, "main", 4) )
    return 1;
  if ( (a2 & 2) != 0 && !I_strncmp(a1, "dev", 3) )
    return 1;
  if ( (a2 & 4) != 0 && !I_strncmp(a1, "temp", 4) )
    return 1;
  if ( (a2 & 8) != 0 && !I_strncmp(a1, "raw", 3) )
    return 1;
  if ( (a2 & 0x10) == 0 || I_strncmp(a1, "raw_shared", 10) )
    return (a2 & 0x20) != 0 && !I_strncmp(a1, "devraw", 6);
  return 1;
}

//----- (0809F98A) --------------------------------------------------------
_DWORD *__cdecl sub_809F98A(int a1, char *a2, int a3, int a4, int *a5, int a6)
{
  bool v6; // al
  void **v8; // [esp+24h] [ebp-14h]
  void **v9; // [esp+24h] [ebp-14h]
  void **ptr; // [esp+28h] [ebp-10h]
  _DWORD *i; // [esp+2Ch] [ebp-Ch]
  _DWORD *v12; // [esp+30h] [ebp-8h]

  ptr = 0;
  v8 = 0;
  for ( i = fs_searchpaths; i; i = (_DWORD *)*i )
  {
    if ( i[2] )
    {
      v6 = sub_809F830((char *)(i[2] + 256), a6);
    }
    else if ( i[1] )
    {
      v6 = sub_809F830((char *)(i[1] + 512), a6);
    }
    else
    {
      v6 = sub_809F830(0, a6);
    }
    if ( v6 )
    {
      if ( ptr )
      {
        *v8 = Z_MallocInternal(0x14u);
        v8 = (void **)*v8;
      }
      else
      {
        ptr = (void **)Z_MallocInternal(0x14u);
        v8 = ptr;
      }
      *v8 = 0;
      v8[2] = (void *)i[2];
      v8[4] = (void *)i[4];
      v8[3] = (void *)i[3];
      v8[1] = (void *)i[1];
    }
  }
  v12 = FS_ListFilteredFiles((int)ptr, a1, a2, a3, a4, a5);
  while ( ptr )
  {
    v9 = (void **)*ptr;
    Z_FreeInternal(ptr);
    ptr = v9;
  }
  return v12;
}

//----- (0809FAE4) --------------------------------------------------------
void __cdecl FS_FreeFileList(void **ptr)
{
  int i; // [esp+4h] [ebp-4h]

  FS_CheckFileSystemStarted();
  if ( ptr )
  {
    for ( i = 0; ptr[i]; ++i )
      Z_FreeInternal(ptr[i]);
    Z_FreeInternal(ptr);
  }
}

//----- (0809FB40) --------------------------------------------------------
int __cdecl FS_GetFileList(char *a1, char *a2, int a3, char *dest, int a5)
{
  void **ptr; // [esp+24h] [ebp-14h]
  size_t v8; // [esp+28h] [ebp-10h]
  int v9; // [esp+2Ch] [ebp-Ch]
  int i; // [esp+30h] [ebp-8h]
  int v11; // [esp+34h] [ebp-4h] BYREF

  *dest = 0;
  v11 = 0;
  v9 = 0;
  if ( !I_stricmp(a1, "$modlist") )
    return FS_GetModList(dest, a5);
  ptr = (void **)FS_ListFiles((int)a1, a2, a3, &v11);
  for ( i = 0; i < v11; ++i )
  {
    v8 = I_strlen((char *)ptr[i]) + 1;
    if ( (int)(v9 + v8 + 1) >= a5 )
    {
      v11 = i;
      break;
    }
    strcpy(dest, (const char *)ptr[i]);
    dest += v8;
    v9 += v8;
  }
  FS_FreeFileList(ptr);
  return v11;
}

//----- (0809FC4E) --------------------------------------------------------
_BYTE *__cdecl FS_ConvertPath(_BYTE *a1)
{
  _BYTE *result; // eax

  while ( 1 )
  {
    result = a1;
    if ( !*a1 )
      break;
    if ( *a1 == 92 || *a1 == 58 )
      *a1 = 47;
    ++a1;
  }
  return result;
}

//----- (0809FC7C) --------------------------------------------------------
int __cdecl FS_PathCmp(char *a1, char *a2)
{
  int v4; // [esp+10h] [ebp-8h]
  int v5; // [esp+14h] [ebp-4h]

  do
  {
    v5 = *a1++;
    v4 = *a2++;
    if ( (unsigned __int8)sub_80B53C8(v5) )
      v5 -= 32;
    if ( (unsigned __int8)sub_80B53C8(v4) )
      v4 -= 32;
    if ( v5 == 92 || v5 == 58 )
      v5 = 47;
    if ( v4 == 92 || v4 == 58 )
      v4 = 47;
    if ( v5 < v4 )
      return -1;
    if ( v5 > v4 )
      return 1;
  }
  while ( v5 );
  return 0;
}

//----- (0809FD2A) --------------------------------------------------------
void __cdecl FS_SortFileList(char **dest, int a2)
{
  _DWORD *ptr; // [esp+10h] [ebp-18h]
  int v3; // [esp+14h] [ebp-14h]
  int k; // [esp+18h] [ebp-10h]
  int j; // [esp+1Ch] [ebp-Ch]
  int i; // [esp+20h] [ebp-8h]

  ptr = Z_MallocInternal(4 * a2 + 4);
  *ptr = 0;
  v3 = 0;
  for ( i = 0; i < a2; ++i )
  {
    for ( j = 0; j < v3 && FS_PathCmp(dest[i], (char *)ptr[j]) >= 0; ++j )
      ;
    for ( k = v3; k > j; --k )
      ptr[k] = ptr[k - 1];
    ptr[j] = dest[i];
    ++v3;
  }
  Com_Memcpy(dest, ptr, 4 * a2);
  Z_FreeInternal(ptr);
}

//----- (0809FE44) --------------------------------------------------------
void __cdecl FS_DisplayPath(int a1)
{
  int j; // [esp+10h] [ebp-8h]
  const char *i; // [esp+14h] [ebp-4h]

  if ( *(_BYTE *)(fs_ignoreLocalized + 8) )
    Com_Printf("    localized assets are being ignored\n");
  Com_Printf("Current search path:\n");
  for ( i = (const char *)fs_searchpaths; i; i = *(const char **)i )
  {
    if ( !a1 || FS_UseSearchPath((int)i) )
    {
      if ( *((_DWORD *)i + 1) )
      {
        Com_Printf("%s (%i files)\n", *((const char **)i + 1), *(_DWORD *)(*((_DWORD *)i + 1) + 780));
        if ( fs_numServerIwds )
        {
          if ( FS_IwdIsPure(*((_DWORD *)i + 1)) )
            Com_Printf("    on the pure list\n");
          else
            Com_Printf("    not on the pure list\n");
        }
      }
      else
      {
        Com_Printf("%s/%s\n", *((const char **)i + 2), (const char *)(*((_DWORD *)i + 2) + 256));
      }
    }
  }
  Com_Printf("\nFile Handles:\n");
  for ( j = 1; j <= 63; ++j )
  {
    if ( dword_848B800[71 * j] )
      Com_Printf("handle %i: %s\n", j, (const char *)(284 * j + 138983452));
  }
}
// 848B7E4: using guessed type int fs_ignoreLocalized;
// 848B800: using guessed type int dword_848B800[];
// 848FF00: using guessed type int fs_numServerIwds;

//----- (0809FF8E) --------------------------------------------------------
void FS_FullPath_f()
{
  FS_DisplayPath(0);
}

//----- (0809FFA2) --------------------------------------------------------
void FS_Path_f()
{
  FS_DisplayPath(0);
}

//----- (0809FFB6) --------------------------------------------------------
int __cdecl IwdFileLanguage(char *s)
{
  int v2; // [esp+14h] [ebp-4h]

  dword_84941C0 ^= 1u;
  if ( strlen(s) > 9 )
  {
    v2 = 10;
    memset((void *)((dword_84941C0 << 6) + 139018560), 0, 0x40u);
    while ( v2 <= 63 && s[v2] && (*(_WORD *)(_ctype_b + 2 * s[v2]) & 0x400) != 0 )
    {
      *((_BYTE *)&unk_8494136 + 64 * dword_84941C0 + v2) = s[v2];
      ++v2;
    }
  }
  else
  {
    byte_8494140[64 * dword_84941C0] = 0;
  }
  return (dword_84941C0 << 6) + 139018560;
}
// 8185A64: using guessed type int _ctype_b;
// 84941C0: using guessed type int dword_84941C0;

//----- (080A0076) --------------------------------------------------------
int __cdecl iwdsort(char **a1, char **a2)
{
  char *v4; // [esp+18h] [ebp-10h]
  char *v5; // [esp+1Ch] [ebp-Ch]
  char *v6; // [esp+20h] [ebp-8h]
  char *s; // [esp+24h] [ebp-4h]

  s = *a1;
  v6 = *a2;
  if ( I_strncmp(*a1, "          ", 10) || I_strncmp(v6, "          ", 10) )
    return FS_PathCmp(s, v6);
  v5 = (char *)IwdFileLanguage(s);
  v4 = (char *)IwdFileLanguage(v6);
  if ( I_stricmp(v5, "english") )
  {
    if ( !I_stricmp(v4, "english") )
      return 1;
    return FS_PathCmp(s, v6);
  }
  if ( !I_stricmp(v4, "english") )
    return FS_PathCmp(s, v6);
  return -1;
}

//----- (080A015C) --------------------------------------------------------
void **__cdecl FS_AddSearchPath(void **a1)
{
  void **result; // eax
  void **v2; // [esp+0h] [ebp-4h]

  v2 = &fs_searchpaths;
  if ( a1[3] )
  {
    while ( *v2 && !*((_DWORD *)*v2 + 3) )
      v2 = (void **)*v2;
  }
  *a1 = *v2;
  result = a1;
  *v2 = a1;
  return result;
}

//----- (080A01A4) --------------------------------------------------------
void __cdecl FS_AddIwdFilesForGameDirectory(char *a1, char *src)
{
  char *v2; // [esp+20h] [ebp-1128h]
  void **v3; // [esp+24h] [ebp-1124h]
  char *v4; // [esp+28h] [ebp-1120h]
  void **ptr; // [esp+2Ch] [ebp-111Ch]
  void *dest[1024]; // [esp+30h] [ebp-1118h] BYREF
  char s[256]; // [esp+1030h] [ebp-118h] BYREF
  int v8; // [esp+1130h] [ebp-18h]
  size_t nmemb; // [esp+1134h] [ebp-14h] BYREF
  void *v10; // [esp+1138h] [ebp-10h]
  int i; // [esp+113Ch] [ebp-Ch]

  FS_BuildOSPath(a1, src, (char *)&byte_8145895, s);
  *((_BYTE *)&dest[1023] + strlen(s) + 3) = 0;
  ptr = (void **)Sys_ListFiles(s, "iwd", 0, &nmemb, 0);
  if ( (int)nmemb > 1024 )
  {
    Com_Printf("WARNING: Exceeded max number of iwd files in %s/%s (%1/%1)\n", a1, src, nmemb, 1024);
    nmemb = 1024;
  }
  for ( i = 0; i < (int)nmemb; ++i )
  {
    dest[i] = ptr[i];
    if ( !I_strncmp((char *)dest[i], "localized_", 10) )
      memcpy(dest[i], "          ", 0xAu);
  }
  qsort(dest, nmemb, 4u, (__compar_fn_t)iwdsort);
  for ( i = 0; i < (int)nmemb; ++i )
  {
    if ( I_strncmp((char *)dest[i], "          ", 10) )
    {
      v8 = 0;
      v10 = 0;
LABEL_16:
      FS_BuildOSPath(a1, src, (char *)dest[i], s);
      v2 = FS_LoadZipFile(s, (char *)dest[i]);
      if ( v2 )
      {
        strcpy(v2 + 512, src);
        v3 = (void **)Z_MallocInternal(0x14u);
        v3[1] = v2;
        v3[3] = (void *)v8;
        v3[4] = v10;
        FS_AddSearchPath(v3);
      }
      continue;
    }
    memcpy(dest[i], "localized_", 0xAu);
    v8 = 1;
    v4 = (char *)IwdFileLanguage((char *)dest[i]);
    if ( !*v4 )
    {
      Com_Printf(
        "WARNING: Localized assets iwd file %s/%s/%s has invalid name (no language specified). Proper naming convention i"
        "s: localized_[language]_iwd#.iwd\n",
        a1,
        src,
        (const char *)dest[i]);
      continue;
    }
    if ( !I_stricmp(v4, "english") )
    {
      v10 = 0;
      goto LABEL_16;
    }
  }
  Sys_FreeFileList(ptr);
}

//----- (080A04B4) --------------------------------------------------------
void __cdecl FS_AddGameDirectoryInternal(char *a1, char *src, void *a3, void *a4)
{
  void **v4; // ebx
  const char *v5; // [esp+2Ch] [ebp-15Ch]
  char s[260]; // [esp+30h] [ebp-158h] BYREF
  void **v7; // [esp+134h] [ebp-54h]
  void *i; // [esp+138h] [ebp-50h]
  const char *v9; // [esp+13Ch] [ebp-4Ch]
  char dest[72]; // [esp+140h] [ebp-48h] BYREF

  if ( a3 )
  {
    v9 = "english";
    Com_sprintf(dest, 0x40u, "%s/%s", src, "english");
  }
  else
  {
    I_strncpyz(dest, src, 64);
  }
  for ( i = fs_searchpaths; i; i = *(void **)i )
  {
    if ( *((_DWORD *)i + 2)
      && !I_stricmp(*((char **)i + 2), a1)
      && !I_stricmp((char *)(*((_DWORD *)i + 2) + 256), dest) )
    {
      if ( *((void **)i + 3) != a3 )
      {
        if ( *((_DWORD *)i + 3) )
          v5 = "localized";
        else
          v5 = "non-localized";
        Com_Printf(
          "WARNING: game folder %s/%s added as both localized & non-localized. Using folder as %s\n",
          a1,
          dest,
          v5);
      }
      if ( *((_DWORD *)i + 3) )
      {
        if ( *((void **)i + 4) != a4 )
          Com_Printf("WARNING: game golder %s/%s re-added as localized folder with different language\n", a1, dest);
      }
      return;
    }
  }
  if ( a3 )
  {
    FS_BuildOSPath(a1, dest, (char *)&byte_8145895, s);
    s[strlen(s) - 1] = 0;
    if ( !Sys_DirectoryHasContents(s) )
      return;
  }
  else
  {
    I_strncpyz(byte_848B6C0, dest, 256);
  }
  v7 = (void **)Z_MallocInternal(0x14u);
  v4 = v7;
  v4[2] = Z_MallocInternal(0x200u);
  I_strncpyz((char *)v7[2], a1, 256);
  I_strncpyz((char *)v7[2] + 256, dest, 256);
  v7[3] = a3;
  v7[4] = a4;
  FS_AddSearchPath(v7);
  FS_AddIwdFilesForGameDirectory(a1, dest);
}

//----- (080A0710) --------------------------------------------------------
void __cdecl FS_AddGameDirectory(char *a1, char *src)
{
  FS_AddGameDirectoryInternal(a1, src, (void *)1, 0);
  FS_AddGameDirectoryInternal(a1, src, 0, 0);
}

//----- (080A075C) --------------------------------------------------------
void *__cdecl FS_ShutdownSearchPaths(void *ptr)
{
  void *result; // eax
  void *v2; // [esp+4h] [ebp-4h]

  while ( ptr )
  {
    v2 = *(void **)ptr;
    if ( *((_DWORD *)ptr + 1) )
    {
      sub_80CFC62(*(_DWORD *)(*((_DWORD *)ptr + 1) + 768));
      Z_FreeInternal(*(void **)(*((_DWORD *)ptr + 1) + 796));
      Z_FreeInternal(*((void **)ptr + 1));
    }
    if ( *((_DWORD *)ptr + 2) )
      Z_FreeInternal(*((void **)ptr + 2));
    Z_FreeInternal(ptr);
    result = v2;
    ptr = v2;
  }
  return result;
}

//----- (080A07DE) --------------------------------------------------------
int FS_ShutdownServerIwdNames()
{
  int result; // eax
  int i; // [esp+4h] [ebp-4h]

  for ( i = 0; ; ++i )
  {
    result = i;
    if ( i >= fs_numServerIwds )
      break;
    if ( *(&dword_8490F20 + i) )
      Z_FreeInternal(*(&dword_8490F20 + i));
    *(&dword_8490F20 + i) = 0;
  }
  fs_numServerIwds = 0;
  return result;
}
// 848FF00: using guessed type int fs_numServerIwds;

//----- (080A0838) --------------------------------------------------------
int FS_ShutdownServerReferencedIwds()
{
  int result; // eax
  int i; // [esp+4h] [ebp-4h]

  for ( i = 0; ; ++i )
  {
    result = i;
    if ( i >= dword_8491F20 )
      break;
    if ( (&dword_8492F40)[i] )
      Z_FreeInternal((&dword_8492F40)[i]);
    (&dword_8492F40)[i] = 0;
  }
  dword_8491F20 = 0;
  return result;
}
// 8491F20: using guessed type int dword_8491F20;

//----- (080A0892) --------------------------------------------------------
void FS_Shutdown()
{
  int i; // [esp+4h] [ebp-4h]

  for ( i = 1; i <= 63; ++i )
  {
    if ( dword_848B80C[71 * i] )
      FS_FCloseFile(i);
  }
  FS_ShutdownSearchPaths(fs_searchpaths);
  fs_searchpaths = 0;
  Cmd_RemoveCommand("path");
  Cmd_RemoveCommand("fullpath");
  Cmd_RemoveCommand("dir");
  Cmd_RemoveCommand("fdir");
  Cmd_RemoveCommand("touchFile");
}
// 848B80C: using guessed type int dword_848B80C[];

//----- (080A0920) --------------------------------------------------------
int __usercall FS_RegisterDvars@<eax>(long double a1@<st0>)
{
  char *v1; // eax
  char *v2; // eax
  char *v5; // [esp+24h] [ebp-4h]

  if ( fs_debug )
    return 0;
  fs_debug = (int)Dvar_RegisterInt(a1, "fs_debug", 0, 0, 2, 4096);
  fs_copyfiles = (int)Dvar_RegisterBool(a1, "fs_copyfiles", 0, 4112);
  v1 = Sys_DefaultCDPath();
  fs_cdpath = (int)Dvar_RegisterString(a1, "fs_cdpath", v1, 4112);
  v2 = Sys_DefaultInstallPath();
  fs_basepath = (int)Dvar_RegisterString(a1, "fs_basepath", v2, 4112);
  fs_basegame = (int)Dvar_RegisterString(a1, "fs_basegame", (char *)&byte_8145895, 4112);
  fs_useOldAssets = (int)Dvar_RegisterBool(a1, "fs_useOldAssets", 0, 4096);
  v5 = Sys_DefaultHomePath();
  if ( !v5 || !*v5 )
    v5 = *(char **)(fs_basepath + 8);
  fs_homepath = (int)Dvar_RegisterString(a1, "fs_homepath", v5, 4112);
  fs_gameDirVar = (int)Dvar_RegisterString(a1, "fs_game", (char *)&byte_8145895, 4124);
  fs_restrict = (int)Dvar_RegisterBool(a1, "fs_restrict", 0, 4112);
  fs_ignoreLocalized = (int)Dvar_RegisterBool(a1, "fs_ignoreLocalized", 0, 4256);
  return 1;
}
// 848B7C0: using guessed type int fs_debug;
// 848B7C4: using guessed type int fs_homepath;
// 848B7CC: using guessed type int fs_basegame;
// 848B7D0: using guessed type int fs_useOldAssets;
// 848B7D4: using guessed type int fs_cdpath;
// 848B7D8: using guessed type int fs_copyfiles;
// 848B7E0: using guessed type int fs_restrict;
// 848B7E4: using guessed type int fs_ignoreLocalized;

//----- (080A0AC4) --------------------------------------------------------
void __usercall FS_Startup(long double a1@<st0>, char *src)
{
  Com_Printf("----- FS_Startup -----\n");
  *(_DWORD *)fs_packFiles = 0;
  FS_RegisterDvars(a1);
  if ( *(_BYTE *)(fs_useOldAssets + 8) )
  {
    if ( **(_BYTE **)(fs_basepath + 8) )
      FS_AddGameDirectory(*(char **)(fs_basepath + 8), "tempcod");
    if ( **(_BYTE **)(fs_homepath + 8) )
      FS_AddGameDirectory(*(char **)(fs_homepath + 8), "tempcod");
  }
  if ( **(_BYTE **)(fs_basepath + 8) )
  {
    FS_AddGameDirectory(*(char **)(fs_basepath + 8), "devraw_shared");
    FS_AddGameDirectory(*(char **)(fs_basepath + 8), "devraw");
    FS_AddGameDirectory(*(char **)(fs_basepath + 8), "raw_shared");
    FS_AddGameDirectory(*(char **)(fs_basepath + 8), "raw");
  }
  if ( **(_BYTE **)(fs_homepath + 8) )
  {
    FS_AddGameDirectory(*(char **)(fs_homepath + 8), "devraw_shared");
    FS_AddGameDirectory(*(char **)(fs_homepath + 8), "devraw");
    FS_AddGameDirectory(*(char **)(fs_homepath + 8), "raw_shared");
    FS_AddGameDirectory(*(char **)(fs_homepath + 8), "raw");
  }
  if ( **(_BYTE **)(fs_cdpath + 8) )
  {
    FS_AddGameDirectory(*(char **)(fs_cdpath + 8), "devraw_shared");
    FS_AddGameDirectory(*(char **)(fs_cdpath + 8), "devraw");
    FS_AddGameDirectory(*(char **)(fs_cdpath + 8), "raw_shared");
    FS_AddGameDirectory(*(char **)(fs_cdpath + 8), "raw");
    FS_AddGameDirectory(*(char **)(fs_cdpath + 8), src);
  }
  if ( **(_BYTE **)(fs_basepath + 8) )
    FS_AddGameDirectory(*(char **)(fs_basepath + 8), src);
  if ( **(_BYTE **)(fs_basepath + 8) && I_stricmp(*(char **)(fs_homepath + 8), *(char **)(fs_basepath + 8)) )
    FS_AddGameDirectory(*(char **)(fs_homepath + 8), src);
  if ( **(_BYTE **)(fs_basegame + 8) && !I_stricmp(src, "main") && I_stricmp(*(char **)(fs_basegame + 8), src) )
  {
    if ( **(_BYTE **)(fs_cdpath + 8) )
      FS_AddGameDirectory(*(char **)(fs_cdpath + 8), *(char **)(fs_basegame + 8));
    if ( **(_BYTE **)(fs_basepath + 8) )
      FS_AddGameDirectory(*(char **)(fs_basepath + 8), *(char **)(fs_basegame + 8));
    if ( **(_BYTE **)(fs_homepath + 8) && I_stricmp(*(char **)(fs_homepath + 8), *(char **)(fs_basepath + 8)) )
      FS_AddGameDirectory(*(char **)(fs_homepath + 8), *(char **)(fs_basegame + 8));
  }
  if ( **(_BYTE **)(fs_gameDirVar + 8) && !I_stricmp(src, "main") && I_stricmp(*(char **)(fs_gameDirVar + 8), src) )
  {
    if ( **(_BYTE **)(fs_cdpath + 8) )
      FS_AddGameDirectory(*(char **)(fs_cdpath + 8), *(char **)(fs_gameDirVar + 8));
    if ( **(_BYTE **)(fs_basepath + 8) )
      FS_AddGameDirectory(*(char **)(fs_basepath + 8), *(char **)(fs_gameDirVar + 8));
    if ( **(_BYTE **)(fs_homepath + 8) && I_stricmp(*(char **)(fs_homepath + 8), *(char **)(fs_basepath + 8)) )
      FS_AddGameDirectory(*(char **)(fs_homepath + 8), *(char **)(fs_gameDirVar + 8));
  }
  FS_AddCommands();
  FS_Path_f();
  Dvar_ClearModified(fs_gameDirVar);
  Com_Printf("----------------------\n");
  Com_Printf("%d files in iwd files\n", *(_DWORD *)fs_packFiles);
}
// 848B7C4: using guessed type int fs_homepath;
// 848B7CC: using guessed type int fs_basegame;
// 848B7D0: using guessed type int fs_useOldAssets;
// 848B7D4: using guessed type int fs_cdpath;

//----- (080A0F06) --------------------------------------------------------
_DWORD *FS_ClearIwdReferences()
{
  _DWORD *result; // eax
  _DWORD *i; // [esp+0h] [ebp-4h]

  result = fs_searchpaths;
  for ( i = fs_searchpaths; i; i = (_DWORD *)*i )
  {
    if ( i[1] )
      *(_BYTE *)(i[1] + 784) = 0;
    result = (_DWORD *)*i;
  }
  return result;
}

//----- (080A0F3E) --------------------------------------------------------
char *__usercall FS_InitFilesystem@<eax>(long double a1@<st0>)
{
  Com_StartupVariable(a1, "fs_cdpath");
  Com_StartupVariable(a1, "fs_basepath");
  Com_StartupVariable(a1, "fs_homepath");
  Com_StartupVariable(a1, "fs_game");
  Com_StartupVariable(a1, "fs_copyfiles");
  Com_StartupVariable(a1, "fs_restrict");
  Com_StartupVariable(a1, "loc_language");
  SEH_InitLanguage(a1);
  FS_Startup(a1, "main");
  FS_SetRestrictions(a1);
  if ( FS_ReadFile("default_mp.cfg", 0) <= 0 )
    Com_Error(0, "Couldn't load %s.  Make sure Call of Duty is run from the correct folder.", "default_mp.cfg");
  I_strncpyz(&lastValidBase, *(char **)(fs_basepath + 8), 256);
  return I_strncpyz(&lastValidGame, *(char **)(fs_gameDirVar + 8), 256);
}

//----- (080A1024) --------------------------------------------------------
char *__usercall FS_Restart@<eax>(long double a1@<st0>, int a2)
{
  char *v2; // eax

  FS_Shutdown();
  fs_checksumFeed = a2;
  FS_ClearIwdReferences();
  FS_Startup(a1, "main");
  FS_SetRestrictions(a1);
  if ( FS_ReadFile("default_mp.cfg", 0) <= 0 )
  {
    if ( lastValidBase )
    {
      FS_PureServerSetLoadedIwds((char *)&byte_8145895, (char *)&byte_8145895);
      Dvar_SetString(fs_basepath, &lastValidBase);
      Dvar_SetString(fs_gameDirVar, &lastValidGame);
      lastValidBase = 0;
      lastValidGame = 0;
      Dvar_SetBool(fs_restrict, 0);
      FS_Restart(a2);
      Com_Error(1, "Invalid game folder\n");
    }
    Com_Error(0, "Couldn't load %s.  Make sure Call of Duty is run from the correct folder.", "default_mp.cfg");
  }
  if ( I_stricmp(*(char **)(fs_gameDirVar + 8), &lastValidGame) && !Com_SafeMode() )
  {
    v2 = va("exec %s\n", "config_mp_server.cfg");
    Cbuf_AddText(v2);
  }
  I_strncpyz(&lastValidBase, *(char **)(fs_basepath + 8), 256);
  return I_strncpyz(&lastValidGame, *(char **)(fs_gameDirVar + 8), 256);
}
// 848B7E0: using guessed type int fs_restrict;
// 848B7F4: using guessed type int fs_checksumFeed;

//----- (080A119C) --------------------------------------------------------
int __usercall FS_ConditionalRestart@<eax>(long double a1@<st0>, int a2)
{
  if ( *(_BYTE *)(com_sv_running + 8) )
    return 0;
  if ( !*(_BYTE *)(fs_gameDirVar + 7) && a2 == fs_checksumFeed )
    return 0;
  FS_Restart(a1, a2);
  return 1;
}
// 819EF14: using guessed type int com_sv_running;
// 848B7F4: using guessed type int fs_checksumFeed;

//----- (080A1200) --------------------------------------------------------
int __cdecl FS_FOpenFileByMode(char *src, int *a2, int a3)
{
  int v5; // [esp+20h] [ebp-8h]
  int v6; // [esp+24h] [ebp-4h]

  v5 = 0;
  if ( a3 == 1 )
  {
    *a2 = FS_FOpenFileWrite(src);
    v6 = 0;
    if ( !*a2 )
      v6 = -1;
  }
  else if ( a3 > 1 )
  {
    if ( a3 != 2 )
    {
      if ( a3 != 3 )
LABEL_14:
        Com_Error(0, (char *)&byte_8145E1D);
      v5 = 1;
    }
    *a2 = FS_FOpenFileAppend(src);
    v6 = 0;
    if ( !*a2 )
      v6 = -1;
  }
  else
  {
    if ( a3 )
      goto LABEL_14;
    v6 = FS_FOpenFileRead(src, a2, 1);
  }
  if ( !a2 )
    return v6;
  if ( *a2 )
  {
    dword_848B80C[71 * *a2] = v6;
    dword_848B818[71 * *a2] = 0;
  }
  dword_848B808[71 * *a2] = v5;
  return v6;
}
// 848B808: using guessed type int dword_848B808[];
// 848B80C: using guessed type int dword_848B80C[];
// 848B818: using guessed type int dword_848B818[4538];

//----- (080A1330) --------------------------------------------------------
int __cdecl FS_FTell(int a1)
{
  FILE *v1; // eax

  if ( dword_848B814[71 * a1] )
    return sub_80D0D98(dword_848B800[71 * a1]);
  v1 = (FILE *)FS_FileForHandle(a1);
  return ftell(v1);
}
// 848B800: using guessed type int dword_848B800[];
// 848B814: using guessed type int dword_848B814[];

//----- (080A1380) --------------------------------------------------------
int __cdecl FS_Flush(int a1)
{
  FILE *v1; // eax

  v1 = (FILE *)FS_FileForHandle(a1);
  return fflush(v1);
}

//----- (080A139C) --------------------------------------------------------
char *GetBspExtension()
{
  const char *v2; // [esp+14h] [ebp-4h]

  v2 = (const char *)Dvar_GetString("gfx_driver");
  if ( *v2 )
    return va("%sbsp", v2);
  else
    return va("d3dbsp");
}

//----- (080A13E6) --------------------------------------------------------
int __cdecl LittleLong(int a1)
{
  return a1;
}

//----- (080A13EE) --------------------------------------------------------
int __cdecl FS_stat(char *filename, struct stat *stat_buf)
{
  return __xstat(3, filename, stat_buf);
}

//----- (080A1410) --------------------------------------------------------
long double sub_80A1410()
{
  return (long double)rand() / 2147483600.0;
}

//----- (080A142E) --------------------------------------------------------
long double sub_80A142E()
{
  long double v0; // fst7

  v0 = sub_80A1410();
  return v0 + v0 - 1.0;
}

//----- (080A1442) --------------------------------------------------------
float *__cdecl sub_80A1442(float *a1, float *a2)
{
  float *result; // eax
  float v3; // [esp+8h] [ebp-10h]
  float v4; // [esp+Ch] [ebp-Ch]
  float v5; // [esp+Ch] [ebp-Ch]
  float v6; // [esp+10h] [ebp-8h]
  float v7; // [esp+14h] [ebp-4h]

  do
  {
    v7 = sub_80A142E();
    v6 = sub_80A142E();
    v4 = v7 * v7 + v6 * v6;
  }
  while ( v4 > 1.0 );
  v3 = log(v4) * -2.0 / v4;
  v5 = sub_80A8B5A(v3);
  *a1 = v7 * v5;
  result = a2;
  *a2 = v6 * v5;
  return result;
}

//----- (080A14BA) --------------------------------------------------------
float *__cdecl sub_80A14BA(float a1, float a2, float *a3)
{
  float *result; // eax
  int v4; // [esp+14h] [ebp-14h] BYREF
  int v5; // [esp+18h] [ebp-10h] BYREF
  float v6; // [esp+1Ch] [ebp-Ch]
  float v7; // [esp+20h] [ebp-8h]
  float v8; // [esp+24h] [ebp-4h]

  v8 = a1;
  v7 = sub_80A8B5A(a1);
  v6 = a2 * 6.283185307179586;
  sub_80A8C1C(v6, (float *)&v5, (float *)&v4);
  *a3 = v7 * *(float *)&v4;
  result = a3 + 1;
  a3[1] = v7 * *(float *)&v5;
  return result;
}

//----- (080A1516) --------------------------------------------------------
int __cdecl sub_80A1516(float a1, float a2, float *a3)
{
  int result; // eax
  float v4; // [esp+0h] [ebp-28h]
  int v5; // [esp+14h] [ebp-14h] BYREF
  int v6; // [esp+18h] [ebp-10h] BYREF
  float v7; // [esp+1Ch] [ebp-Ch]
  float v8; // [esp+20h] [ebp-8h]
  float v9; // [esp+24h] [ebp-4h]

  v9 = a1 + a1 - 1.0;
  v4 = 1.0 - v9 * v9;
  v8 = sub_80A8B5A(v4);
  v7 = a2 * 6.283185307179586;
  sub_80A8C1C(v7, (float *)&v6, (float *)&v5);
  *a3 = v8 * *(float *)&v5;
  a3[1] = v8 * *(float *)&v6;
  result = LODWORD(v9);
  a3[2] = v9;
  return result;
}

//----- (080A158C) --------------------------------------------------------
int __cdecl sub_80A158C(int a1, float a2, int a3)
{
  int result; // eax
  float v4; // [esp+0h] [ebp-28h]
  int v5; // [esp+14h] [ebp-14h] BYREF
  int v6; // [esp+18h] [ebp-10h] BYREF
  float v7; // [esp+1Ch] [ebp-Ch]
  float v8; // [esp+20h] [ebp-8h]
  int v9; // [esp+24h] [ebp-4h]

  v9 = a1;
  v4 = 1.0 - *(float *)&a1 * *(float *)&a1;
  v8 = sub_80A8B5A(v4);
  v7 = a2 * 6.283185307179586;
  sub_80A8C1C(v7, (float *)&v6, (float *)&v5);
  *(float *)a3 = v8 * *(float *)&v5;
  *(float *)(a3 + 4) = v8 * *(float *)&v6;
  result = v9;
  *(_DWORD *)(a3 + 8) = v9;
  return result;
}

//----- (080A15FA) --------------------------------------------------------
int __cdecl sub_80A15FA(int a1, float *a2, int a3)
{
  int result; // eax
  float v4; // [esp+4h] [ebp-24h]
  float v5; // [esp+8h] [ebp-20h]
  float v6; // [esp+Ch] [ebp-1Ch]
  float v7; // [esp+10h] [ebp-18h]
  float v8; // [esp+14h] [ebp-14h]
  float v9; // [esp+18h] [ebp-10h]
  int i; // [esp+24h] [ebp-4h]

  v9 = 1.0 / (long double)a1;
  v8 = v9 * 0.5;
  v5 = 0.0;
  v4 = 1.0;
  for ( i = 0; ; ++i )
  {
    result = i;
    if ( i >= a1 )
      break;
    v7 = sub_80A8B5A(v8);
    *a2 = v7 * v4;
    a2[1] = v7 * v5;
    v8 = v8 + v9;
    v6 = v5;
    v5 = v5 * -0.73736888 + v4 * -0.67549032;
    v4 = v4 * -0.73736888 - v6 * -0.67549032;
    a2 = (float *)((char *)a2 + a3);
  }
  return result;
}

//----- (080A16B2) --------------------------------------------------------
int __cdecl sub_80A16B2(int a1, float *a2, int a3)
{
  int result; // eax
  float v4; // [esp+0h] [ebp-38h]
  float v5; // [esp+10h] [ebp-28h]
  float v6; // [esp+14h] [ebp-24h]
  float v7; // [esp+18h] [ebp-20h]
  float v8; // [esp+1Ch] [ebp-1Ch]
  float v9; // [esp+24h] [ebp-14h]
  float v10; // [esp+28h] [ebp-10h]
  int i; // [esp+34h] [ebp-4h]

  v10 = 1.0 / (long double)a1;
  v9 = v10 * 0.5;
  v6 = 0.0;
  v5 = 1.0;
  for ( i = 0; ; ++i )
  {
    result = i;
    if ( i >= a1 )
      break;
    v4 = 1.0 - v9 * v9;
    v8 = sub_80A8B5A(v4);
    *a2 = v8 * v5;
    a2[1] = v8 * v6;
    a2[2] = v9;
    v9 = v9 + v10;
    v7 = v6;
    v6 = v6 * -0.73736888 + v5 * -0.67549032;
    v5 = v5 * -0.73736888 - v7 * -0.67549032;
    a2 = (float *)((char *)a2 + a3);
  }
  return result;
}

//----- (080A1788) --------------------------------------------------------
int __cdecl sub_80A1788(int a1, float *a2, int a3)
{
  int result; // eax
  float v4; // [esp+0h] [ebp-38h]
  float v5; // [esp+10h] [ebp-28h]
  float v6; // [esp+14h] [ebp-24h]
  float v7; // [esp+18h] [ebp-20h]
  float v8; // [esp+1Ch] [ebp-1Ch]
  float v9; // [esp+20h] [ebp-18h]
  float v10; // [esp+24h] [ebp-14h]
  float v11; // [esp+28h] [ebp-10h]
  int i; // [esp+34h] [ebp-4h]

  v11 = 1.0 / (long double)a1;
  v10 = v11 * 0.5;
  v6 = 0.0;
  v5 = 1.0;
  for ( i = 0; ; ++i )
  {
    result = i;
    if ( i >= a1 )
      break;
    v9 = v10 + v10 - 1.0;
    v4 = 1.0 - v9 * v9;
    v8 = sub_80A8B5A(v4);
    *a2 = v8 * v5;
    a2[1] = v8 * v6;
    a2[2] = v9;
    v10 = v10 + v11;
    v7 = v6;
    v6 = v6 * -0.73736888 + v5 * -0.67549032;
    v5 = v5 * -0.73736888 - v7 * -0.67549032;
    a2 = (float *)((char *)a2 + a3);
  }
  return result;
}

//----- (080A1866) --------------------------------------------------------
long double __cdecl sub_80A1866(float a1, float a2, float a3, float a4)
{
  float v5; // [esp+8h] [ebp-10h]
  float v7; // [esp+10h] [ebp-8h]
  float v8; // [esp+14h] [ebp-4h]

  v8 = a1 - a2;
  if ( v8 <= 0.0 )
    v7 = -a3 * a4;
  else
    v7 = a3 * a4;
  if ( sub_80A8B40(v8) <= 0.001 )
  {
    return a1;
  }
  else
  {
    v5 = sub_80A8B40(v8);
    if ( sub_80A8B40(v7) <= v5 )
      return (float)(a2 + v7);
    else
      return a1;
  }
}

//----- (080A1902) --------------------------------------------------------
void __cdecl sub_80A1902(float a1, float a2, float a3, float a4)
{
  float v4; // [esp+14h] [ebp-4h]

  while ( a1 - a2 > 180.0 )
    a1 = a1 - 360.0;
  while ( a1 - a2 < -180.0 )
    a1 = a1 + 360.0;
  v4 = sub_80A1866(a1, a2, a3, a4);
  sub_80A6112(v4);
}

//----- (080A1986) --------------------------------------------------------
long double __cdecl sub_80A1986(float a1, float a2, float a3, float a4)
{
  float v5; // [esp+8h] [ebp-10h]
  float v7; // [esp+10h] [ebp-8h]
  float v8; // [esp+14h] [ebp-4h]

  v8 = a1 - a2;
  v7 = a3 * v8 * a4;
  if ( sub_80A8B40(v8) <= 0.001 )
  {
    return a1;
  }
  else
  {
    v5 = sub_80A8B40(v8);
    if ( sub_80A8B40(v7) <= v5 )
      return (float)(a2 + v7);
    else
      return a1;
  }
}

//----- (080A1A02) --------------------------------------------------------
void __cdecl sub_80A1A02(float a1, float a2, float a3, float a4)
{
  float v4; // [esp+14h] [ebp-4h]

  while ( a1 - a2 > 180.0 )
    a1 = a1 - 360.0;
  while ( a1 - a2 < -180.0 )
    a1 = a1 + 360.0;
  v4 = sub_80A1986(a1, a2, a3, a4);
  sub_80A6112(v4);
}

//----- (080A1B68) --------------------------------------------------------
long double __cdecl sub_80A1B68(float a1)
{
  float v3; // [esp+14h] [ebp-4h]

  v3 = acos(a1);
  if ( v3 <= 3.141592653589793 )
  {
    if ( v3 >= -3.141592653589793 )
      return v3;
    else
      return (float)3.1415927;
  }
  else
  {
    return (float)3.1415927;
  }
}

//----- (080A1C2A) --------------------------------------------------------
int __cdecl DirToByte(float *a1)
{
  float v3; // [esp+Ch] [ebp-Ch]
  float v4; // [esp+10h] [ebp-8h]
  unsigned __int8 v5; // [esp+16h] [ebp-2h]
  unsigned __int8 i; // [esp+17h] [ebp-1h]

  if ( !a1 )
    return 0;
  v3 = 0.0;
  v5 = 0;
  for ( i = 0; i <= 0xA1u; ++i )
  {
    v4 = sub_80A8EFC(a1, (float *)(12 * i + 135649024));
    if ( v4 > (long double)v3 )
    {
      v3 = v4;
      v5 = i;
    }
  }
  return v5;
}

//----- (080A1D86) --------------------------------------------------------
void __cdecl Vec3Distance(float *a1, float *a2)
{
  float v2[6]; // [esp+10h] [ebp-18h] BYREF

  sub_80A8DE8(a2, a1, v2);
  sub_80A8F9A(v2);
}
// 80A1D86: using guessed type float var_18[6];

//----- (080A1DB2) --------------------------------------------------------
long double __cdecl sub_80A1DB2(float *a1, float *a2)
{
  float v3; // [esp+10h] [ebp-18h] BYREF
  float v4; // [esp+14h] [ebp-14h]
  float v5; // [esp+18h] [ebp-10h]

  sub_80A8DE8(a2, a1, &v3);
  return v3 * v3 + v4 * v4 + v5 * v5;
}

//----- (080A1E7C) --------------------------------------------------------
void __cdecl sub_80A1E7C(float *a1, float *a2)
{
  float v2[2]; // [esp+10h] [ebp-8h] BYREF

  sub_80A8CAC(a2, a1, v2);
  sub_80A8CFA(v2);
}
// 80A1E7C: using guessed type float var_8[2];

//----- (080A1EA8) --------------------------------------------------------
long double __cdecl sub_80A1EA8(float *a1, float *a2)
{
  float v3; // [esp+10h] [ebp-8h] BYREF
  float v4; // [esp+14h] [ebp-4h]

  sub_80A8CAC(a2, a1, &v3);
  return v3 * v3 + v4 * v4;
}

//----- (080A1ED8) --------------------------------------------------------
float *__cdecl sub_80A1ED8(float *a1, float *a2, float *a3)
{
  float *result; // eax

  *a3 = a1[1] * a2[2] - a1[2] * a2[1];
  a3[1] = a1[2] * *a2 - *a1 * a2[2];
  result = a1 + 1;
  a3[2] = *a1 * a2[1] - a1[1] * *a2;
  return result;
}

//----- (080A1FA2) --------------------------------------------------------
_DWORD *__cdecl sub_80A1FA2(float *a1, _DWORD *a2, _DWORD *a3)
{
  _DWORD *result; // eax
  float v4; // [esp+10h] [ebp-18h] BYREF
  float v5; // [esp+14h] [ebp-14h]
  float v6; // [esp+18h] [ebp-10h]

  sub_80A8E64(a1, a1, &v4);
  if ( v6 < (long double)v4 || v6 < (long double)v5 )
  {
    if ( v5 < (long double)v4 || v5 < (long double)v6 )
    {
      if ( *a1 <= 0.0 )
      {
        *a2 = 2;
        result = a3;
        *a3 = 1;
      }
      else
      {
        *a2 = 1;
        result = a3;
        *a3 = 2;
      }
    }
    else if ( a1[1] <= 0.0 )
    {
      *a2 = 0;
      result = a3;
      *a3 = 2;
    }
    else
    {
      *a2 = 2;
      result = a3;
      *a3 = 0;
    }
  }
  else if ( a1[2] <= 0.0 )
  {
    *a2 = 1;
    result = a3;
    *a3 = 0;
  }
  else
  {
    *a2 = 0;
    result = a3;
    *a3 = 1;
  }
  return result;
}

//----- (080A20C0) --------------------------------------------------------
long double __cdecl Vec3Normalize(float *a1)
{
  float v2; // [esp+10h] [ebp-8h]
  float v3; // [esp+14h] [ebp-4h]
  float v4; // [esp+14h] [ebp-4h]

  v3 = *a1 * *a1 + a1[1] * a1[1] + a1[2] * a1[2];
  v4 = sub_80A8B5A(v3);
  if ( v4 != 0.0 )
  {
    v2 = 1.0 / v4;
    *a1 = *a1 * v2;
    a1[1] = a1[1] * v2;
    a1[2] = a1[2] * v2;
  }
  return v4;
}

//----- (080A215E) --------------------------------------------------------
long double __cdecl sub_80A215E(float *a1)
{
  float v2; // [esp+10h] [ebp-8h]
  float v3; // [esp+14h] [ebp-4h]
  float v4; // [esp+14h] [ebp-4h]

  v3 = *a1 * *a1 + a1[1] * a1[1];
  v4 = sub_80A8B5A(v3);
  if ( v4 != 0.0 )
  {
    v2 = 1.0 / v4;
    *a1 = *a1 * v2;
    a1[1] = a1[1] * v2;
  }
  return v4;
}

//----- (080A21D6) --------------------------------------------------------
long double __cdecl sub_80A21D6(float *a1)
{
  float v2; // [esp+10h] [ebp-8h]
  float v3; // [esp+14h] [ebp-4h]
  float v4; // [esp+14h] [ebp-4h]

  v3 = *a1 * *a1 + a1[1] * a1[1] + a1[2] * a1[2] + a1[3] * a1[3];
  v4 = sub_80A8B5A(v3);
  if ( v4 != 0.0 )
  {
    v2 = 1.0 / v4;
    *a1 = *a1 * v2;
    a1[1] = a1[1] * v2;
    a1[2] = a1[2] * v2;
    a1[3] = a1[3] * v2;
  }
  return v4;
}

//----- (080A2298) --------------------------------------------------------
long double __cdecl sub_80A2298(float *a1, int a2)
{
  float v3; // [esp+10h] [ebp-8h]
  float v4; // [esp+14h] [ebp-4h]
  float v5; // [esp+14h] [ebp-4h]

  v4 = *a1 * *a1 + a1[1] * a1[1] + a1[2] * a1[2];
  v5 = sub_80A8B5A(v4);
  if ( v5 == 0.0 )
  {
    sub_80A8D26((_DWORD *)a2);
  }
  else
  {
    v3 = 1.0 / v5;
    *(float *)a2 = *a1 * v3;
    *(float *)(a2 + 4) = a1[1] * v3;
    *(float *)(a2 + 8) = a1[2] * v3;
  }
  return v5;
}

//----- (080A2342) --------------------------------------------------------
long double __cdecl sub_80A2342(float *a1, int a2)
{
  float v3; // [esp+10h] [ebp-8h]
  float v4; // [esp+14h] [ebp-4h]
  float v5; // [esp+14h] [ebp-4h]

  v4 = *a1 * *a1 + a1[1] * a1[1];
  v5 = sub_80A8B5A(v4);
  if ( v5 == 0.0 )
  {
    sub_80A8C78((_DWORD *)a2);
  }
  else
  {
    v3 = 1.0 / v5;
    *(float *)a2 = *a1 * v3;
    *(float *)(a2 + 4) = a1[1] * v3;
  }
  return v5;
}

//----- (080A2672) --------------------------------------------------------
float *__cdecl sub_80A2672(int a1, int a2, float *a3, float a4)
{
  float *result; // eax
  float v5; // [esp+1Ch] [ebp-13Ch]
  float v6; // [esp+20h] [ebp-138h] BYREF
  float v7; // [esp+24h] [ebp-134h]
  int v8; // [esp+28h] [ebp-130h]
  int v9[4]; // [esp+30h] [ebp-128h] BYREF
  int v10[7]; // [esp+40h] [ebp-118h] BYREF
  int i; // [esp+5Ch] [ebp-FCh] BYREF
  float v12[12]; // [esp+60h] [ebp-F8h] BYREF
  float v13[12]; // [esp+90h] [ebp-C8h] BYREF
  int s; // [esp+C0h] [ebp-98h] BYREF
  int v15[3]; // [esp+C4h] [ebp-94h] BYREF
  int v16; // [esp+D0h] [ebp-88h]
  int v17; // [esp+E0h] [ebp-78h]
  float dest[12]; // [esp+F0h] [ebp-68h] BYREF
  int src; // [esp+120h] [ebp-38h] BYREF
  int v20; // [esp+124h] [ebp-34h]
  float v21; // [esp+128h] [ebp-30h]
  int v22; // [esp+12Ch] [ebp-2Ch]
  int v23; // [esp+130h] [ebp-28h]
  float v24; // [esp+134h] [ebp-24h]
  int v25; // [esp+138h] [ebp-20h]
  int v26; // [esp+13Ch] [ebp-1Ch]
  int v27; // [esp+140h] [ebp-18h]

  v6 = *(float *)a2;
  v7 = *(float *)(a2 + 4);
  v8 = *(_DWORD *)(a2 + 8);
  sub_80A30BA((float *)a2, (float *)v10);
  sub_80A1ED8((float *)v10, &v6, (float *)v9);
  src = v10[0];
  v22 = v10[1];
  v25 = v10[2];
  v20 = v9[0];
  v23 = v9[1];
  v26 = v9[2];
  v21 = v6;
  v24 = v7;
  v27 = v8;
  memcpy(dest, &src, 0x24u);
  LODWORD(dest[1]) = v22;
  LODWORD(dest[2]) = v25;
  LODWORD(dest[3]) = v20;
  LODWORD(dest[5]) = v26;
  dest[6] = v21;
  dest[7] = v24;
  memset(&s, 0, 0x24u);
  v17 = 1065353216;
  v16 = 1065353216;
  s = 1065353216;
  v5 = a4 * 0.0174532925199433;
  sub_80A8C1C(v5, (float *)v15, (float *)&s);
  v15[2] = v15[0] ^ 0x80000000;
  v16 = s;
  sub_80A358E((float *)&src, (float *)&s, v13);
  result = sub_80A358E(v13, dest, v12);
  for ( i = 0; i <= 2; ++i )
  {
    *(float *)(a1 + 4 * i) = v12[3 * i] * *a3 + v12[3 * i + 1] * a3[1] + v12[3 * i + 2] * a3[2];
    result = (float *)&i;
  }
  return result;
}
// 80A2672: using guessed type float var_C8[12];
// 80A2672: using guessed type float var_F8[12];

//----- (080A28D8) --------------------------------------------------------
float *__cdecl sub_80A28D8(float *a1, float a2)
{
  int v3[6]; // [esp+10h] [ebp-18h] BYREF

  sub_80A30BA(a1, a1 + 3);
  if ( a2 != 0.0 )
  {
    sub_80A8D74((_DWORD *)a1 + 3, v3);
    sub_80A2672((int)(a1 + 3), (int)a1, (float *)v3, a2);
  }
  return sub_80A1ED8(a1, a1 + 3, a1 + 6);
}

//----- (080A295E) --------------------------------------------------------
float *__cdecl sub_80A295E(int a1, int a2, float *a3)
{
  float v4; // [esp+14h] [ebp-4h]

  *(_DWORD *)(a2 + 4) = *(_DWORD *)a1 ^ 0x80000000;
  *(_DWORD *)(a2 + 8) = *(_DWORD *)(a1 + 4);
  *(_DWORD *)a2 = *(_DWORD *)(a1 + 8);
  v4 = sub_80A8EFC((float *)a2, (float *)a1);
  sub_80A8EA8((float *)a2, COERCE_FLOAT(LODWORD(v4) ^ 0x80000000), (float *)a1, (float *)a2);
  Vec3Normalize((float *)a2);
  return sub_80A1ED8((float *)a2, (float *)a1, a3);
}

//----- (080A29F6) --------------------------------------------------------
long double __cdecl sub_80A29F6(float *a1)
{
  float v2; // [esp+24h] [ebp-4h]

  if ( a1[1] == 0.0 && *a1 == 0.0 )
  {
    return 0.0;
  }
  else
  {
    v2 = atan2(a1[1], *a1) * 180.0 / 3.141592653589793;
    if ( v2 < 0.0 )
      return (float)(v2 + 360.0);
  }
  return v2;
}

//----- (080A2A84) --------------------------------------------------------
long double __cdecl sub_80A2A84(float *a1)
{
  if ( a1[1] == 0.0 && *a1 == 0.0 )
    return 0.0;
  else
    return (float)(atan2(a1[1], *a1) * 180.0 / 3.141592653589793);
}

//----- (080A2AF6) --------------------------------------------------------
long double __cdecl sub_80A2AF6(float *a1)
{
  float v2; // [esp+0h] [ebp-28h]
  float v3; // [esp+20h] [ebp-8h]
  float v4; // [esp+24h] [ebp-4h]

  if ( a1[1] == 0.0 && *a1 == 0.0 )
  {
    if ( a1[2] <= 0.0 )
      return 90.0;
    else
      return 270.0;
  }
  else
  {
    v2 = *a1 * *a1 + a1[1] * a1[1];
    v4 = sub_80A8B5A(v2);
    v3 = atan2(a1[2], v4) * -180.0 / 3.141592653589793;
    if ( v3 < 0.0 )
      return (float)(v3 + 360.0);
  }
  return v3;
}

//----- (080A2BC8) --------------------------------------------------------
long double __cdecl sub_80A2BC8(float *a1)
{
  float v2; // [esp+0h] [ebp-28h]
  float v4; // [esp+24h] [ebp-4h]

  if ( a1[1] == 0.0 && *a1 == 0.0 )
  {
    if ( a1[2] <= 0.0 )
      return 90.0;
    else
      return -90.0;
  }
  else
  {
    v2 = *a1 * *a1 + a1[1] * a1[1];
    v4 = sub_80A8B5A(v2);
    return (float)(atan2(a1[2], v4) * -180.0 / 3.141592653589793);
  }
}

//----- (080A2C7E) --------------------------------------------------------
int __cdecl vectoangles(float *a1, int a2)
{
  int result; // eax
  float v3; // [esp+0h] [ebp-28h]
  float v4; // [esp+1Ch] [ebp-Ch]
  float v5; // [esp+20h] [ebp-8h]
  float v6; // [esp+24h] [ebp-4h]

  if ( a1[1] == 0.0 && *a1 == 0.0 )
  {
    v5 = 0.0;
    if ( a1[2] <= 0.0 )
      v4 = 90.0;
    else
      v4 = 270.0;
  }
  else
  {
    v5 = atan2(a1[1], *a1) * 180.0 / 3.141592653589793;
    if ( v5 < 0.0 )
      v5 = v5 + 360.0;
    v3 = *a1 * *a1 + a1[1] * a1[1];
    v6 = sub_80A8B5A(v3);
    v4 = atan2(a1[2], v6) * -180.0 / 3.141592653589793;
    if ( v4 < 0.0 )
      v4 = v4 + 360.0;
  }
  *(float *)a2 = v4;
  *(float *)(a2 + 4) = v5;
  result = 0;
  *(_DWORD *)(a2 + 8) = 0;
  return result;
}

//----- (080A2DBE) --------------------------------------------------------
int __cdecl sub_80A2DBE(float *a1, int a2)
{
  int result; // eax
  float v3; // [esp+0h] [ebp-28h]
  float v4; // [esp+1Ch] [ebp-Ch]
  float v5; // [esp+20h] [ebp-8h]
  float v6; // [esp+24h] [ebp-4h]

  if ( a1[1] == 0.0 && *a1 == 0.0 )
  {
    v5 = 0.0;
    if ( a1[2] <= 0.0 )
      v4 = 90.0;
    else
      v4 = -90.0;
  }
  else
  {
    v5 = atan2(a1[1], *a1) * 180.0 / 3.141592653589793;
    v3 = *a1 * *a1 + a1[1] * a1[1];
    v6 = sub_80A8B5A(v3);
    v4 = atan2(a1[2], v6) * -180.0 / 3.141592653589793;
  }
  *(float *)a2 = v4;
  *(float *)(a2 + 4) = v5;
  result = 0;
  *(_DWORD *)(a2 + 8) = 0;
  return result;
}

//----- (080A2EC2) --------------------------------------------------------
void __cdecl AngleVectors(float *a1, int a2, float *a3, float *a4)
{
  int v4; // [esp+1Ch] [ebp-1Ch] BYREF
  int v5; // [esp+20h] [ebp-18h] BYREF
  int v6; // [esp+24h] [ebp-14h] BYREF
  int v7; // [esp+28h] [ebp-10h] BYREF
  int v8; // [esp+2Ch] [ebp-Ch] BYREF
  int v9; // [esp+30h] [ebp-8h] BYREF
  float v10; // [esp+34h] [ebp-4h]

  v10 = a1[1] * 0.0174532925199433;
  sub_80A8C1C(v10, (float *)&v7, (float *)&v4);
  v10 = *a1 * 0.0174532925199433;
  sub_80A8C1C(v10, (float *)&v8, (float *)&v5);
  if ( a2 )
  {
    *(float *)a2 = *(float *)&v5 * *(float *)&v4;
    *(float *)(a2 + 4) = *(float *)&v5 * *(float *)&v7;
    *(_DWORD *)(a2 + 8) = v8 ^ 0x80000000;
  }
  if ( a3 || a4 )
  {
    v10 = a1[2] * 0.0174532925199433;
    sub_80A8C1C(v10, (float *)&v9, (float *)&v6);
    if ( a3 )
    {
      *a3 = -*(float *)&v9 * *(float *)&v8 * *(float *)&v4 + *(float *)&v6 * *(float *)&v7;
      a3[1] = -*(float *)&v9 * *(float *)&v8 * *(float *)&v7 + -*(float *)&v6 * *(float *)&v4;
      a3[2] = -*(float *)&v9 * *(float *)&v5;
    }
    if ( a4 )
    {
      *a4 = *(float *)&v6 * *(float *)&v8 * *(float *)&v4 + *(float *)&v9 * *(float *)&v7;
      a4[1] = *(float *)&v6 * *(float *)&v8 * *(float *)&v7 + -*(float *)&v9 * *(float *)&v4;
      a4[2] = *(float *)&v6 * *(float *)&v5;
    }
  }
}

//----- (080A303A) --------------------------------------------------------
void __cdecl sub_80A303A(float a1, int *a2, int *a3)
{
  int v3; // [esp+1Ch] [ebp-Ch] BYREF
  int v4; // [esp+20h] [ebp-8h] BYREF
  float v5; // [esp+24h] [ebp-4h]

  v5 = a1 * 0.0174532925199433;
  sub_80A8C1C(v5, (float *)&v4, (float *)&v3);
  if ( a2 )
  {
    *a2 = v3;
    a2[1] = v4;
    a2[2] = 0;
  }
  if ( a3 )
  {
    *a3 = v4;
    a3[1] = v3 ^ 0x80000000;
    a3[2] = 0;
  }
}

//----- (080A30BA) --------------------------------------------------------
void __cdecl sub_80A30BA(float *a1, float *a2)
{
  float v2; // [esp+20h] [ebp-28h]
  float v3; // [esp+24h] [ebp-24h]
  float v4; // [esp+28h] [ebp-20h]
  int v5; // [esp+3Ch] [ebp-Ch]

  v2 = *a1 * *a1;
  v3 = a1[1] * a1[1];
  v4 = a1[2] * a1[2];
  v5 = v2 > (long double)v3;
  if ( *(&v2 + v5) > (long double)v4 )
    v5 = 2;
  sub_80A8E2C(a1, COERCE_FLOAT(LODWORD(a1[v5]) ^ 0x80000000), a2);
  a2[v5] = a2[v5] + 1.0;
  Vec3Normalize(a2);
}

//----- (080A318C) --------------------------------------------------------
void __cdecl sub_80A318C(float *a1, float *a2, float *a3, float *a4)
{
  float v4[4]; // [esp+10h] [ebp-28h] BYREF
  float v5[6]; // [esp+20h] [ebp-18h] BYREF

  sub_80A8DE8(a1, a2, v5);
  Vec3Normalize(v5);
  sub_80A8DE8(a1, a3, v4);
  Vec3Normalize(v4);
  sub_80A1ED8(v5, v4, a4);
  Vec3Normalize(a4);
}
// 80A318C: using guessed type float var_18[6];
// 80A318C: using guessed type float var_28[4];

//----- (080A3416) --------------------------------------------------------
int __cdecl sub_80A3416(_DWORD *s)
{
  int result; // eax

  memset(s, 0, 0x24u);
  *s = 1065353216;
  s[4] = 1065353216;
  result = 1065353216;
  s[8] = 1065353216;
  return result;
}

//----- (080A345E) --------------------------------------------------------
void *__cdecl sub_80A345E(void *dest)
{
  return memcpy(dest, &unk_8145FA0, 0x40u);
}

//----- (080A358E) --------------------------------------------------------
float *__cdecl sub_80A358E(float *a1, float *a2, float *a3)
{
  float *result; // eax

  *a3 = *a1 * *a2 + a1[1] * a2[3] + a1[2] * a2[6];
  a3[1] = *a1 * a2[1] + a1[1] * a2[4] + a1[2] * a2[7];
  a3[2] = *a1 * a2[2] + a1[1] * a2[5] + a1[2] * a2[8];
  a3[3] = a1[3] * *a2 + a1[4] * a2[3] + a1[5] * a2[6];
  a3[4] = a1[3] * a2[1] + a1[4] * a2[4] + a1[5] * a2[7];
  a3[5] = a1[3] * a2[2] + a1[4] * a2[5] + a1[5] * a2[8];
  a3[6] = a1[6] * *a2 + a1[7] * a2[3] + a1[8] * a2[6];
  a3[7] = a1[6] * a2[1] + a1[7] * a2[4] + a1[8] * a2[7];
  result = a1 + 8;
  a3[8] = a1[6] * a2[2] + a1[7] * a2[5] + a1[8] * a2[8];
  return result;
}

//----- (080A3C8E) --------------------------------------------------------
float *__cdecl sub_80A3C8E(float *a1, float *a2, float *a3)
{
  float *result; // eax

  *a3 = *a1 * *a2 + a1[1] * a2[3] + a1[2] * a2[6];
  a3[3] = a1[3] * *a2 + a1[4] * a2[3] + a1[5] * a2[6];
  a3[6] = a1[6] * *a2 + a1[7] * a2[3] + a1[8] * a2[6];
  a3[1] = *a1 * a2[1] + a1[1] * a2[4] + a1[2] * a2[7];
  a3[4] = a1[3] * a2[1] + a1[4] * a2[4] + a1[5] * a2[7];
  a3[7] = a1[6] * a2[1] + a1[7] * a2[4] + a1[8] * a2[7];
  a3[2] = *a1 * a2[2] + a1[1] * a2[5] + a1[2] * a2[8];
  a3[5] = a1[3] * a2[2] + a1[4] * a2[5] + a1[5] * a2[8];
  a3[8] = a1[6] * a2[2] + a1[7] * a2[5] + a1[8] * a2[8];
  a3[9] = a1[9] * *a2 + a1[10] * a2[3] + a1[11] * a2[6] + a2[9];
  a3[10] = a1[9] * a2[1] + a1[10] * a2[4] + a1[11] * a2[7] + a2[10];
  result = a2 + 11;
  a3[11] = a1[9] * a2[2] + a1[10] * a2[5] + a1[11] * a2[8] + a2[11];
  return result;
}

//----- (080A442E) --------------------------------------------------------
int __cdecl sub_80A442E(_DWORD *a1, _DWORD *a2)
{
  int result; // eax

  *a2 = *a1;
  a2[1] = a1[3];
  a2[2] = a1[6];
  a2[3] = a1[1];
  a2[4] = a1[4];
  a2[5] = a1[7];
  a2[6] = a1[2];
  a2[7] = a1[5];
  result = a1[8];
  a2[8] = result;
  return result;
}

//----- (080A45BE) --------------------------------------------------------
float *__cdecl sub_80A45BE(float *a1, float *a2)
{
  float *result; // eax
  float v3; // [esp+0h] [ebp-4h]
  float v4; // [esp+0h] [ebp-4h]

  v3 = (a1[8] * a1[4] - a1[7] * a1[5]) * *a1
     - (a1[8] * a1[1] - a1[7] * a1[2]) * a1[3]
     + (a1[5] * a1[1] - a1[4] * a1[2]) * a1[6];
  v4 = 1.0 / v3;
  *a2 = (a1[8] * a1[4] - a1[7] * a1[5]) * v4;
  a2[1] = -(a1[8] * a1[1] - a1[7] * a1[2]) * v4;
  a2[2] = (a1[5] * a1[1] - a1[4] * a1[2]) * v4;
  a2[3] = -(a1[8] * a1[3] - a1[6] * a1[5]) * v4;
  a2[4] = (a1[8] * *a1 - a1[6] * a1[2]) * v4;
  a2[5] = -(a1[5] * *a1 - a1[3] * a1[2]) * v4;
  a2[6] = (a1[7] * a1[3] - a1[6] * a1[4]) * v4;
  a2[7] = -(a1[7] * *a1 - a1[6] * a1[1]) * v4;
  result = a1 + 3;
  a2[8] = (a1[4] * *a1 - a1[3] * a1[1]) * v4;
  return result;
}

//----- (080A47DE) --------------------------------------------------------
float *__cdecl sub_80A47DE(int a1, int a2)
{
  float v3[6]; // [esp+10h] [ebp-18h] BYREF

  sub_80A442E((_DWORD *)a1, (_DWORD *)a2);
  sub_80A8DE8(flt_8145E68, (float *)(a1 + 36), v3);
  return sub_80A4E52(v3, (float *)a2, (float *)(a2 + 36));
}
// 8145E68: using guessed type float flt_8145E68[3];
// 80A47DE: using guessed type float var_18[6];

//----- (080A4E52) --------------------------------------------------------
float *__cdecl sub_80A4E52(float *a1, float *a2, float *a3)
{
  float *result; // eax

  *a3 = *a1 * *a2 + a1[1] * a2[3] + a1[2] * a2[6];
  a3[1] = *a1 * a2[1] + a1[1] * a2[4] + a1[2] * a2[7];
  result = a1 + 2;
  a3[2] = *a1 * a2[2] + a1[1] * a2[5] + a1[2] * a2[8];
  return result;
}

//----- (080A5028) --------------------------------------------------------
float *__cdecl sub_80A5028(float *a1, float *a2, float *a3)
{
  float *result; // eax

  *a3 = *a1 * *a2 + a1[1] * a2[1] + a1[2] * a2[2];
  a3[1] = *a1 * a2[3] + a1[1] * a2[4] + a1[2] * a2[5];
  result = a1 + 2;
  a3[2] = *a1 * a2[6] + a1[1] * a2[7] + a1[2] * a2[8];
  return result;
}

//----- (080A50D2) --------------------------------------------------------
float *__cdecl sub_80A50D2(float *a1, float *a2, float *a3)
{
  float *result; // eax

  *a3 = *a1 * *a2 + a1[1] * a2[3] + a1[2] * a2[6] + a2[9];
  a3[1] = *a1 * a2[1] + a1[1] * a2[4] + a1[2] * a2[7] + a2[10];
  result = a2 + 11;
  a3[2] = *a1 * a2[2] + a1[1] * a2[5] + a1[2] * a2[8] + a2[11];
  return result;
}

//----- (080A5194) --------------------------------------------------------
float *__cdecl sub_80A5194(float *a1, float *a2, float *a3)
{
  float *result; // eax
  float v4; // [esp+10h] [ebp-18h] BYREF
  float v5; // [esp+14h] [ebp-14h]
  float v6; // [esp+18h] [ebp-10h]

  sub_80A8DE8(a1, a2 + 9, &v4);
  *a3 = *a2 * v4 + a2[1] * v5 + a2[2] * v6;
  a3[1] = a2[3] * v4 + a2[4] * v5 + a2[5] * v6;
  result = a2 + 8;
  a3[2] = a2[6] * v4 + a2[7] * v5 + a2[8] * v6;
  return result;
}

//----- (080A530C) --------------------------------------------------------
int __cdecl sub_80A530C(float *a1, float a2)
{
  int result; // eax
  float v3; // [esp+0h] [ebp-28h]
  float v4; // [esp+1Ch] [ebp-Ch]
  int v5; // [esp+20h] [ebp-8h] BYREF
  int v6; // [esp+24h] [ebp-4h] BYREF

  v3 = a2 * 0.0174532925199433;
  sub_80A8C1C(v3, (float *)&v5, (float *)&v6);
  v4 = *a1 * *(float *)&v6 - a1[1] * *(float *)&v5;
  a1[1] = a1[1] * *(float *)&v6 + *a1 * *(float *)&v5;
  result = LODWORD(v4);
  *a1 = v4;
  return result;
}

//----- (080A5372) --------------------------------------------------------
float *__cdecl sub_80A5372(float *a1, float *a2, float *a3)
{
  float *result; // eax

  *a3 = *a1 * a2[3] + a1[3] * *a2 + a1[2] * a2[1] - a1[1] * a2[2];
  a3[1] = a1[1] * a2[3] - a1[2] * *a2 + a1[3] * a2[1] + *a1 * a2[2];
  a3[2] = a1[2] * a2[3] + a1[1] * *a2 - *a1 * a2[1] + a1[3] * a2[2];
  result = a1 + 2;
  a3[3] = a1[3] * a2[3] - *a1 * *a2 - a1[1] * a2[1] - a1[2] * a2[2];
  return result;
}

//----- (080A5494) --------------------------------------------------------
unsigned int __cdecl sub_80A5494(_DWORD *a1, unsigned int *a2)
{
  unsigned int result; // eax

  *a2 = *a1 ^ 0x80000000;
  a2[1] = a1[1] ^ 0x80000000;
  a2[2] = a1[2] ^ 0x80000000;
  result = a1[3];
  a2[3] = result;
  return result;
}

//----- (080A54E2) --------------------------------------------------------
float *__cdecl sub_80A54E2(float *a1, float *a2)
{
  float *result; // eax
  float v3; // [esp+0h] [ebp-38h]
  float v4; // [esp+4h] [ebp-34h]
  float v5; // [esp+8h] [ebp-30h]
  float v6; // [esp+Ch] [ebp-2Ch]
  float v7; // [esp+10h] [ebp-28h]
  float v8; // [esp+14h] [ebp-24h]
  float v9; // [esp+18h] [ebp-20h]
  float v10; // [esp+18h] [ebp-20h]
  float v11; // [esp+1Ch] [ebp-1Ch]
  float v12; // [esp+20h] [ebp-18h]
  float v13; // [esp+24h] [ebp-14h]
  float v14; // [esp+24h] [ebp-14h]
  float v15; // [esp+28h] [ebp-10h]
  float v16; // [esp+2Ch] [ebp-Ch]
  float v17; // [esp+30h] [ebp-8h]
  float v18; // [esp+34h] [ebp-4h]
  float v19; // [esp+34h] [ebp-4h]

  v18 = *a1 * *a1;
  v13 = a1[1] * a1[1];
  v9 = a1[2] * a1[2];
  v7 = a1[3] * a1[3];
  v6 = v18 + v13 + v9 + v7;
  v5 = 2.0 / v6;
  v19 = v18 * v5;
  v14 = v13 * v5;
  v10 = v9 * v5;
  v4 = v5 * *a1;
  v17 = v4 * a1[1];
  v16 = v4 * a1[2];
  v15 = v4 * a1[3];
  v3 = v5 * a1[1];
  v12 = v3 * a1[2];
  v11 = v3 * a1[3];
  v8 = v5 * a1[2] * a1[3];
  *a2 = 1.0 - (v14 + v10);
  a2[1] = v17 + v8;
  a2[2] = v16 - v11;
  a2[3] = v17 - v8;
  a2[4] = 1.0 - (v19 + v10);
  a2[5] = v12 + v15;
  a2[6] = v16 + v11;
  a2[7] = v12 - v15;
  result = a2 + 8;
  a2[8] = 1.0 - (v19 + v14);
  return result;
}

//----- (080A5662) --------------------------------------------------------
long double __cdecl sub_80A5662(float *a1)
{
  float v3; // [esp+4h] [ebp-10h]
  float v4; // [esp+4h] [ebp-10h]
  float v5; // [esp+8h] [ebp-Ch]
  float v6; // [esp+8h] [ebp-Ch]
  float v7; // [esp+Ch] [ebp-8h]
  float v8; // [esp+Ch] [ebp-8h]
  float v9; // [esp+10h] [ebp-4h]
  float v10; // [esp+10h] [ebp-4h]

  v9 = *a1 * *a1;
  v7 = a1[1] * a1[1];
  v5 = a1[2] * a1[2];
  v3 = v9 + v7 + v5 + a1[3] * a1[3];
  if ( v3 == 0.0 )
  {
    return (float)0.0;
  }
  else
  {
    v4 = 1.0 / v3;
    v10 = v9 * v4;
    v8 = v7 * v4;
    v6 = v5 * v4;
    return (float)(v10 + v8 + v6);
  }
}

//----- (080A5706) --------------------------------------------------------
long double __cdecl sub_80A5706(float a1)
{
  double v3; // [esp+20h] [ebp-8h]

  v3 = sin(a1 * 0.0174532925199433);
  return (float)(v3 * v3);
}

//----- (080A5774) --------------------------------------------------------
long double __cdecl sub_80A5774(float *a1)
{
  float v3; // [esp+20h] [ebp-8h]
  float v4; // [esp+20h] [ebp-8h]
  float v5; // [esp+24h] [ebp-4h]

  v5 = *a1 * *a1;
  v3 = a1[1] * a1[1] + v5;
  v4 = 2.0 / v3;
  return (float)(atan2(*a1 * a1[1] * v4, 1.0 - v5 * v4) * 57.29577951308232);
}

//----- (080A57E8) --------------------------------------------------------
void __cdecl sub_80A57E8(float a1, int a2)
{
  float v2; // [esp+20h] [ebp+8h]

  v2 = a1 * 0.008726646259971648;
  *(_DWORD *)a2 = 0;
  *(_DWORD *)(a2 + 8) = 0;
  sub_80A8C1C(v2, (float *)(a2 + 4), (float *)(a2 + 12));
}

//----- (080A5834) --------------------------------------------------------
void __cdecl sub_80A5834(float a1, int a2)
{
  float v2; // [esp+20h] [ebp+8h]

  v2 = a1 * 0.008726646259971648;
  *(_DWORD *)a2 = 0;
  *(_DWORD *)(a2 + 4) = 0;
  sub_80A8C1C(v2, (float *)(a2 + 8), (float *)(a2 + 12));
}

//----- (080A5880) --------------------------------------------------------
void __cdecl sub_80A5880(float a1, int a2)
{
  float v2; // [esp+20h] [ebp+8h]

  v2 = a1 * 0.008726646259971648;
  *(_DWORD *)(a2 + 4) = 0;
  *(_DWORD *)(a2 + 8) = 0;
  sub_80A8C1C(v2, (float *)a2, (float *)(a2 + 12));
}

//----- (080A58CC) --------------------------------------------------------
float *__cdecl sub_80A58CC(float a1, float *a2, float *a3)
{
  float v4; // [esp+14h] [ebp-4h] BYREF
  float v5; // [esp+20h] [ebp+8h]

  v5 = a1 * 0.008726646259971648;
  sub_80A8C1C(v5, &v4, a3 + 3);
  return sub_80A8E2C(a2, v4, a3);
}

//----- (080A5918) --------------------------------------------------------
int __cdecl sub_80A5918(_DWORD *a1, float a2)
{
  int result; // eax
  float v3; // [esp+0h] [ebp-18h]
  int v4; // [esp+10h] [ebp-8h] BYREF
  int v5; // [esp+14h] [ebp-4h] BYREF

  v3 = a2 * 0.0174532925199433;
  sub_80A8C1C(v3, (float *)&v4, (float *)&v5);
  *a1 = 1065353216;
  a1[1] = 0;
  a1[2] = 0;
  a1[3] = 0;
  a1[4] = v5;
  a1[5] = v4 ^ 0x80000000;
  a1[6] = 0;
  a1[7] = v4;
  result = v5;
  a1[8] = v5;
  return result;
}

//----- (080A59B0) --------------------------------------------------------
int __cdecl sub_80A59B0(int *a1, float a2)
{
  int result; // eax
  float v3; // [esp+0h] [ebp-18h]
  int v4; // [esp+10h] [ebp-8h] BYREF
  int v5; // [esp+14h] [ebp-4h] BYREF

  v3 = a2 * 0.0174532925199433;
  sub_80A8C1C(v3, (float *)&v4, (float *)&v5);
  *a1 = v5;
  a1[1] = 0;
  a1[2] = v4;
  a1[3] = 0;
  a1[4] = 1065353216;
  a1[5] = 0;
  a1[6] = v4 ^ 0x80000000;
  a1[7] = 0;
  result = v5;
  a1[8] = v5;
  return result;
}

//----- (080A5A48) --------------------------------------------------------
int __cdecl sub_80A5A48(int *a1, float a2)
{
  int result; // eax
  float v3; // [esp+0h] [ebp-18h]
  int v4; // [esp+10h] [ebp-8h] BYREF
  int v5; // [esp+14h] [ebp-4h] BYREF

  v3 = a2 * 0.0174532925199433;
  sub_80A8C1C(v3, (float *)&v4, (float *)&v5);
  *a1 = v5;
  a1[1] = v4 ^ 0x80000000;
  a1[2] = 0;
  a1[3] = v4;
  a1[4] = v5;
  a1[5] = 0;
  a1[6] = 0;
  a1[7] = 0;
  result = 1065353216;
  a1[8] = 1065353216;
  return result;
}

//----- (080A5AE0) --------------------------------------------------------
int __cdecl sub_80A5AE0(float *s, float a2, float a3, int a4)
{
  int result; // eax

  memset(s, 0, 0x40u);
  *s = tan((90.0 - a2 * 0.5) * 0.0174532925199433) * 0.99950027;
  s[5] = tan((90.0 - a3 * 0.5) * 0.0174532925199433) * 0.99950027;
  s[10] = 0.99950027;
  s[11] = 1.0;
  result = a4;
  s[14] = -*(float *)&a4 * 0.99950027;
  return result;
}

//----- (080A5B9C) --------------------------------------------------------
int __cdecl sub_80A5B9C(float *s, float a2, float a3, float a4)
{
  int result; // eax

  memset(s, 0, 0x40u);
  *s = 2.0 / a2;
  s[5] = 2.0 / a3;
  s[10] = 0.5 / a4;
  s[14] = 0.5;
  result = 1065353216;
  s[15] = 1.0;
  return result;
}

//----- (080A5F4C) --------------------------------------------------------
long double __cdecl sub_80A5F4C(float a1)
{
  return (long double)(unsigned __int16)(int)(a1 * 182.04445) * 0.0054931641;
}

//----- (080A6000) --------------------------------------------------------
long double __cdecl sub_80A6000(float a1, float a2)
{
  float i; // [esp+4h] [ebp-4h]

  for ( i = a1 - a2; i > 180.0; i = i - 360.0 )
    ;
  while ( i < -180.0 )
    i = i + 360.0;
  return i;
}

//----- (080A6062) --------------------------------------------------------
float *__cdecl sub_80A6062(float *a1, float *a2, float *a3)
{
  long double v3; // fst7
  float *result; // eax

  *a3 = sub_80A6000(*a1, *a2);
  a3[1] = sub_80A6000(a1[1], a2[1]);
  v3 = sub_80A6000(a1[2], a2[2]);
  result = a3 + 2;
  a3[2] = v3;
  return result;
}

//----- (080A60CE) --------------------------------------------------------
long double __cdecl sub_80A60CE(float a1)
{
  return (long double)(unsigned __int16)(int)(a1 * 182.04445) * 0.0054931641;
}

//----- (080A6112) --------------------------------------------------------
long double __cdecl sub_80A6112(float a1)
{
  float v2; // [esp+14h] [ebp-4h]

  v2 = sub_80A60CE(a1);
  if ( v2 > 180.0 )
    return (float)(v2 - 360.0);
  return v2;
}

//----- (080A6154) --------------------------------------------------------
long double __cdecl sub_80A6154(float a1)
{
  if ( a1 >= 0.0 )
  {
    if ( a1 < 360.0 )
    {
      return a1;
    }
    else
    {
      do
        a1 = a1 - 360.0;
      while ( a1 >= 360.0 );
      return a1;
    }
  }
  else
  {
    do
      a1 = a1 + 360.0;
    while ( a1 < 0.0 );
    return a1;
  }
}

//----- (080A61D2) --------------------------------------------------------
long double __cdecl sub_80A61D2(float a1)
{
  if ( a1 > -180.0 )
  {
    if ( a1 <= 180.0 )
    {
      return a1;
    }
    else
    {
      do
        a1 = a1 - 360.0;
      while ( a1 > 180.0 );
      return a1;
    }
  }
  else
  {
    do
      a1 = a1 + 360.0;
    while ( a1 <= -180.0 );
    return a1;
  }
}

//----- (080A6258) --------------------------------------------------------
void __cdecl sub_80A6258(float a1, float a2)
{
  float v2; // [esp+0h] [ebp-8h]

  v2 = a1 - a2;
  sub_80A6112(v2);
}

//----- (080A626E) --------------------------------------------------------
void __cdecl sub_80A626E(int a1, int a2)
{
  float v2; // [esp+10h] [ebp-38h]
  float v3; // [esp+18h] [ebp-30h]
  float v4; // [esp+1Ch] [ebp-2Ch]
  float v5[7]; // [esp+20h] [ebp-28h] BYREF
  int i; // [esp+3Ch] [ebp-Ch]

  for ( i = 0; i <= 2; ++i )
  {
    v4 = sub_80A8B40(*(float *)(a1 + 4 * i));
    v3 = sub_80A8B40(*(float *)(a2 + 4 * i));
    if ( v4 <= (long double)v3 )
      v2 = v3;
    else
      v2 = v4;
    v5[i] = v2;
  }
  sub_80A8F9A(v5);
}
// 80A626E: using guessed type float var_28[7];

//----- (080A62FC) --------------------------------------------------------
void __cdecl sub_80A62FC(int a1, int a2)
{
  float v2; // [esp+8h] [ebp-20h]
  float v3; // [esp+10h] [ebp-18h]
  float v4; // [esp+14h] [ebp-14h]
  float v5[3]; // [esp+18h] [ebp-10h] BYREF
  int i; // [esp+24h] [ebp-4h]

  for ( i = 0; i <= 1; ++i )
  {
    v4 = sub_80A8B40(*(float *)(a1 + 4 * i));
    v3 = sub_80A8B40(*(float *)(a2 + 4 * i));
    if ( v4 <= (long double)v3 )
      v2 = v3;
    else
      v2 = v4;
    v5[i] = v2;
  }
  sub_80A8CFA(v5);
}
// 80A62FC: using guessed type float var_10[3];

//----- (080A6450) --------------------------------------------------------
void __usercall sub_80A6450(long double a1@<st0>, float *a2, float *a3)
{
  float v3; // [esp+18h] [ebp-20h]
  float v4; // [esp+1Ch] [ebp-1Ch]
  float v5[2]; // [esp+20h] [ebp-18h] BYREF
  float v6; // [esp+28h] [ebp-10h]

  sub_80A8DE8(a3, a2, v5);
  sub_80A8B7A(v5[0], v5[1]);
  v4 = a1;
  if ( v4 > (long double)v6 )
  {
    v3 = (v4 - v6) * 0.5;
    a2[2] = a2[2] - v3;
    a3[2] = a3[2] + v3;
  }
}

//----- (080A64CE) --------------------------------------------------------
void __cdecl sub_80A64CE(float *a1, float *a2)
{
  float v2; // [esp+1Ch] [ebp-1Ch]
  float v3; // [esp+1Ch] [ebp-1Ch]
  float v4; // [esp+20h] [ebp-18h] BYREF
  float v5; // [esp+24h] [ebp-14h]
  float v6; // [esp+28h] [ebp-10h]

  sub_80A8DE8(a2, a1, &v4);
  if ( v4 > (long double)v6 )
  {
    v2 = (v4 - v6) * 0.5;
    *a1 = *a1 + v2;
    *a2 = *a2 - v2;
  }
  if ( v5 > (long double)v6 )
  {
    v3 = (v5 - v6) * 0.5;
    a1[1] = a1[1] + v3;
    a2[1] = a2[1] - v3;
  }
}

//----- (080A660A) --------------------------------------------------------
void __cdecl sub_80A660A(float *a1, float *a2, float *a3)
{
  if ( *a2 > (long double)*a1 )
    *a2 = *a1;
  if ( *a1 > (long double)*a3 )
    *a3 = *a1;
  if ( a2[1] > (long double)a1[1] )
    a2[1] = a1[1];
  if ( a1[1] > (long double)a3[1] )
    a3[1] = a1[1];
  if ( a2[2] > (long double)a1[2] )
    a2[2] = a1[2];
  if ( a1[2] > (long double)a3[2] )
    a3[2] = a1[2];
}

//----- (080A6B48) --------------------------------------------------------
void __cdecl sub_80A6B48(float *a1, float *a2, float *a3, float *a4)
{
  if ( *a3 > (long double)*a1 )
    *a3 = *a1;
  if ( *a2 > (long double)*a4 )
    *a4 = *a2;
  if ( a3[1] > (long double)a1[1] )
    a3[1] = a1[1];
  if ( a2[1] > (long double)a4[1] )
    a4[1] = a2[1];
  if ( a3[2] > (long double)a1[2] )
    a3[2] = a1[2];
  if ( a2[2] > (long double)a4[2] )
    a4[2] = a2[2];
}

//----- (080A6CC8) --------------------------------------------------------
void __cdecl sub_80A6CC8(int a1, int a2, int a3, int a4)
{
  int v4; // [esp+4h] [ebp-24h]
  int v5; // [esp+8h] [ebp-20h]
  int v6; // [esp+10h] [ebp-18h]
  int i; // [esp+18h] [ebp-10h]

  for ( i = 0; i <= 2; ++i )
  {
    *(_DWORD *)(a4 + 4 * i) = *(_DWORD *)(a2 + 4 * i);
    *(_DWORD *)(a4 + 4 * i + 12) = *(_DWORD *)(a2 + 4 * i);
    if ( sub_80A8BDC(a3 + 4 * i) >= 0 )
      v6 = 0;
    else
      v6 = 12;
    *(float *)(a4 + 4 * i) = *(float *)(v6 + a1) * *(float *)(a3 + 4 * i) + *(float *)(a4 + 4 * i);
    *(float *)(a4 + 4 * i + 12) = *(float *)(a1 - v6 + 12) * *(float *)(a3 + 4 * i) + *(float *)(a4 + 4 * i + 12);
    if ( sub_80A8BDC(a3 + 4 * i + 12) >= 0 )
      v5 = 0;
    else
      v5 = 12;
    *(float *)(a4 + 4 * i) = *(float *)(a1 + v5 + 4) * *(float *)(a3 + 4 * i + 12) + *(float *)(a4 + 4 * i);
    *(float *)(a4 + 4 * i + 12) = *(float *)(a1 - v5 + 16) * *(float *)(a3 + 4 * i + 12) + *(float *)(a4 + 4 * i + 12);
    if ( sub_80A8BDC(a3 + 4 * i + 24) >= 0 )
      v4 = 0;
    else
      v4 = 12;
    *(float *)(a4 + 4 * i) = *(float *)(a1 + v4 + 8) * *(float *)(a3 + 4 * i + 24) + *(float *)(a4 + 4 * i);
    *(float *)(a4 + 4 * i + 12) = *(float *)(a1 - v4 + 20) * *(float *)(a3 + 4 * i + 24) + *(float *)(a4 + 4 * i + 12);
  }
}

//----- (080A6FE6) --------------------------------------------------------
int __cdecl sub_80A6FE6(_DWORD *a1, _DWORD *a2)
{
  sub_80A8D74(a1, a2);
  sub_80A8D74(a1 + 3, a2 + 3);
  return sub_80A8D74(a1 + 6, a2 + 6);
}

//----- (080A70C0) --------------------------------------------------------
float *__cdecl sub_80A70C0(float *a1, float a2, float a3, float a4, float *a5)
{
  float *result; // eax

  *a5 = a2 * *a1 + a3 * a1[3] + a4 * a1[6];
  a5[1] = a2 * a1[1] + a3 * a1[4] + a4 * a1[7];
  result = a1 + 8;
  a5[2] = a2 * a1[2] + a3 * a1[5] + a4 * a1[8];
  return result;
}

//----- (080A7146) --------------------------------------------------------
float *__cdecl sub_80A7146(float *a1, int a2)
{
  float v3[6]; // [esp+10h] [ebp-18h] BYREF

  AngleVectors(a1, a2, v3, (float *)(a2 + 24));
  return sub_80A8DE8(flt_8145E68, v3, (float *)(a2 + 12));
}
// 8145E68: using guessed type float flt_8145E68[3];
// 80A7146: using guessed type float var_18[6];

//----- (080A718E) --------------------------------------------------------
float *__cdecl sub_80A718E(float a1, int a2)
{
  int v3[6]; // [esp+10h] [ebp-18h] BYREF

  sub_80A303A(a1, (int *)a2, v3);
  *(_DWORD *)(a2 + 24) = 0;
  *(_DWORD *)(a2 + 28) = 0;
  *(_DWORD *)(a2 + 32) = 1065353216;
  return sub_80A8DE8(flt_8145E68, (float *)v3, (float *)(a2 + 12));
}
// 8145E68: using guessed type float flt_8145E68[3];

//----- (080A71F4) --------------------------------------------------------
int __cdecl sub_80A71F4(int a1, int a2)
{
  int result; // eax
  float v3; // [esp+20h] [ebp-38h]
  float v4; // [esp+2Ch] [ebp-2Ch]
  float v5; // [esp+30h] [ebp-28h]
  int v6; // [esp+34h] [ebp-24h] BYREF
  int v7; // [esp+38h] [ebp-20h] BYREF
  float v8; // [esp+3Ch] [ebp-1Ch]
  float v9; // [esp+40h] [ebp-18h] BYREF
  float v10; // [esp+44h] [ebp-14h]
  float v11; // [esp+48h] [ebp-10h]

  vectoangles((float *)a1, a2);
  sub_80A8D74((_DWORD *)(a1 + 12), &v9);
  v8 = -*(float *)(a2 + 4) * 0.0174532925199433;
  sub_80A8C1C(v8, (float *)&v7, (float *)&v6);
  v5 = *(float *)&v6 * v9 - *(float *)&v7 * v10;
  v10 = *(float *)&v7 * v9 + *(float *)&v6 * v10;
  v8 = -*(float *)a2 * 0.0174532925199433;
  sub_80A8C1C(v8, (float *)&v7, (float *)&v6);
  v9 = *(float *)&v7 * v11 + *(float *)&v6 * v5;
  v11 = *(float *)&v6 * v11 - *(float *)&v7 * v5;
  v4 = sub_80A2BC8(&v9);
  if ( v10 >= 0.0 )
  {
    result = a2 + 8;
    *(_DWORD *)(a2 + 8) = LODWORD(v4) ^ 0x80000000;
  }
  else
  {
    if ( v4 >= 0.0 )
      v3 = v4 + -180.0;
    else
      v3 = v4 + 180.0;
    result = a2 + 8;
    *(float *)(a2 + 8) = v3;
  }
  return result;
}

//----- (080A7338) --------------------------------------------------------
int __cdecl sub_80A7338(int a1, int a2)
{
  int result; // eax
  float v3; // [esp+20h] [ebp-38h]
  float v4; // [esp+2Ch] [ebp-2Ch]
  float v5; // [esp+30h] [ebp-28h]
  int v6; // [esp+34h] [ebp-24h] BYREF
  int v7; // [esp+38h] [ebp-20h] BYREF
  float v8; // [esp+3Ch] [ebp-1Ch]
  float v9; // [esp+40h] [ebp-18h] BYREF
  float v10; // [esp+44h] [ebp-14h]
  float v11; // [esp+48h] [ebp-10h]

  sub_80A2DBE((float *)a1, a2);
  sub_80A8D74((_DWORD *)(a1 + 12), &v9);
  v8 = -*(float *)(a2 + 4) * 0.0174532925199433;
  sub_80A8C1C(v8, (float *)&v7, (float *)&v6);
  v5 = *(float *)&v6 * v9 - *(float *)&v7 * v10;
  v10 = *(float *)&v7 * v9 + *(float *)&v6 * v10;
  v8 = -*(float *)a2 * 0.0174532925199433;
  sub_80A8C1C(v8, (float *)&v7, (float *)&v6);
  v9 = *(float *)&v7 * v11 + *(float *)&v6 * v5;
  v11 = *(float *)&v6 * v11 - *(float *)&v7 * v5;
  v4 = sub_80A2BC8(&v9);
  if ( v10 >= 0.0 )
  {
    result = a2 + 8;
    *(_DWORD *)(a2 + 8) = LODWORD(v4) ^ 0x80000000;
  }
  else
  {
    if ( v4 >= 0.0 )
      v3 = v4 + -180.0;
    else
      v3 = v4 + 180.0;
    result = a2 + 8;
    *(float *)(a2 + 8) = v3;
  }
  return result;
}

//----- (080A7CE6) --------------------------------------------------------
int __cdecl sub_80A7CE6(float *a1, float *a2, float *a3, float *a4)
{
  float v6[4]; // [esp+20h] [ebp-28h] BYREF
  float v7[6]; // [esp+30h] [ebp-18h] BYREF

  sub_80A8DE8(a3, a2, v7);
  sub_80A8DE8(a4, a2, v6);
  sub_80A1ED8(v6, v7, a1);
  if ( Vec3Normalize(a1) == 0.0 )
    return 0;
  a1[3] = sub_80A8EFC(a2, a1);
  return 1;
}
// 80A7CE6: using guessed type float var_18[6];
// 80A7CE6: using guessed type float var_28[4];

//----- (080A7D80) --------------------------------------------------------
float *__cdecl sub_80A7D80(float *a1, float *a2, float *a3)
{
  float v4; // [esp+10h] [ebp-8h]

  v4 = sub_80A8EFC(a2, a1);
  return sub_80A8EA8(a1, COERCE_FLOAT(LODWORD(v4) ^ 0x80000000), a2, a3);
}

//----- (080A7E1A) --------------------------------------------------------
int __cdecl sub_80A7E1A(float *a1, float *a2, int a3)
{
  _BOOL4 v5; // [esp+8h] [ebp-Ch]
  float v6; // [esp+Ch] [ebp-8h]
  float v7; // [esp+10h] [ebp-4h]

  if ( *(_BYTE *)(a3 + 16) > 2u )
  {
    switch ( *(_BYTE *)(a3 + 17) )
    {
      case 0:
        v7 = *(float *)a3 * *a2 + *(float *)(a3 + 4) * a2[1] + *(float *)(a3 + 8) * a2[2];
        v6 = *(float *)a3 * *a1 + *(float *)(a3 + 4) * a1[1] + *(float *)(a3 + 8) * a1[2];
        break;
      case 1:
        v7 = *(float *)a3 * *a1 + *(float *)(a3 + 4) * a2[1] + *(float *)(a3 + 8) * a2[2];
        v6 = *(float *)a3 * *a2 + *(float *)(a3 + 4) * a1[1] + *(float *)(a3 + 8) * a1[2];
        break;
      case 2:
        v7 = *(float *)a3 * *a2 + *(float *)(a3 + 4) * a1[1] + *(float *)(a3 + 8) * a2[2];
        v6 = *(float *)a3 * *a1 + *(float *)(a3 + 4) * a2[1] + *(float *)(a3 + 8) * a1[2];
        break;
      case 3:
        v7 = *(float *)a3 * *a1 + *(float *)(a3 + 4) * a1[1] + *(float *)(a3 + 8) * a2[2];
        v6 = *(float *)a3 * *a2 + *(float *)(a3 + 4) * a2[1] + *(float *)(a3 + 8) * a1[2];
        break;
      case 4:
        v7 = *(float *)a3 * *a2 + *(float *)(a3 + 4) * a2[1] + *(float *)(a3 + 8) * a1[2];
        v6 = *(float *)a3 * *a1 + *(float *)(a3 + 4) * a1[1] + *(float *)(a3 + 8) * a2[2];
        break;
      case 5:
        v7 = *(float *)a3 * *a1 + *(float *)(a3 + 4) * a2[1] + *(float *)(a3 + 8) * a1[2];
        v6 = *(float *)a3 * *a2 + *(float *)(a3 + 4) * a1[1] + *(float *)(a3 + 8) * a2[2];
        break;
      case 6:
        v7 = *(float *)a3 * *a2 + *(float *)(a3 + 4) * a1[1] + *(float *)(a3 + 8) * a1[2];
        v6 = *(float *)a3 * *a1 + *(float *)(a3 + 4) * a2[1] + *(float *)(a3 + 8) * a2[2];
        break;
      case 7:
        v7 = *(float *)a3 * *a1 + *(float *)(a3 + 4) * a1[1] + *(float *)(a3 + 8) * a1[2];
        v6 = *(float *)a3 * *a2 + *(float *)(a3 + 4) * a2[1] + *(float *)(a3 + 8) * a2[2];
        break;
      default:
        v6 = 0.0;
        v7 = 0.0;
        break;
    }
    v5 = v7 >= (long double)*(float *)(a3 + 12);
    if ( *(float *)(a3 + 12) > (long double)v6 )
      return v5 | 2;
    return v5;
  }
  else if ( a1[*(unsigned __int8 *)(a3 + 16)] < (long double)*(float *)(a3 + 12) )
  {
    if ( *(float *)(a3 + 12) < (long double)a2[*(unsigned __int8 *)(a3 + 16)] )
      return 3;
    else
      return 2;
  }
  else
  {
    return 1;
  }
}

//----- (080A81F8) --------------------------------------------------------
int __cdecl sub_80A81F8(float *a1, float a2, float *a3, float a4, float a5, float a6, float a7)
{
  float v9; // [esp+14h] [ebp-24h]
  float v10; // [esp+14h] [ebp-24h]
  float v11; // [esp+18h] [ebp-20h]
  float v12; // [esp+1Ch] [ebp-1Ch]
  float v13[6]; // [esp+20h] [ebp-18h] BYREF

  sub_80A8DE8(a1, a3, v13);
  v12 = sub_80A215E(v13);
  v11 = v12 - a2;
  if ( v11 * v11 > a4 * a4 )
    return 0;
  if ( a3[2] - a7 <= (long double)a1[2] && a1[2] <= a3[2] + a7 )
  {
    v9 = sub_80A29F6(v13);
    v10 = sub_80A60CE(v9);
    if ( a6 <= (long double)a5 )
    {
      if ( a6 > (long double)v10 || v10 > (long double)a5 )
        return 1;
    }
    else if ( a6 > (long double)v10 && v10 > (long double)a5 )
    {
      return 1;
    }
    return 0;
  }
  return 0;
}
// 80A81F8: using guessed type float var_18[6];

//----- (080A831C) --------------------------------------------------------
_BOOL4 __cdecl sub_80A831C(float *a1, float *a2, float *a3, float a4)
{
  float v5; // [esp+10h] [ebp-48h]
  float v6; // [esp+14h] [ebp-44h]
  float v7; // [esp+18h] [ebp-40h]
  float v8; // [esp+1Ch] [ebp-3Ch]
  float v9[4]; // [esp+20h] [ebp-38h] BYREF
  float v10[7]; // [esp+30h] [ebp-28h] BYREF
  int i; // [esp+4Ch] [ebp-Ch]

  sub_80A8DE8(a1, a3, v10);
  sub_80A8DE8(a2, a3, v9);
  v8 = 0.0;
  for ( i = 0; i <= 2; ++i )
  {
    if ( v10[i] * v9[i] > 0.0 )
    {
      v7 = v10[i] * v10[i];
      v6 = v9[i] * v9[i];
      if ( v7 <= (long double)v6 )
        v5 = v8 + v7;
      else
        v5 = v8 + v6;
      v8 = v5;
    }
  }
  return v8 > (long double)a4;
}
// 80A831C: using guessed type float var_28[7];
// 80A831C: using guessed type float var_38[4];

//----- (080A84C6) --------------------------------------------------------
int __cdecl sub_80A84C6(_DWORD *a1, int a2, _DWORD *a3)
{
  int v4[2]; // [esp+20h] [ebp-68h] BYREF
  int v5[2]; // [esp+28h] [ebp-60h] BYREF
  double v6; // [esp+30h] [ebp-58h]
  int i; // [esp+3Ch] [ebp-4Ch]
  int v8; // [esp+40h] [ebp-48h]
  int v9[7]; // [esp+44h] [ebp-44h]
  float v10[4]; // [esp+60h] [ebp-28h] BYREF
  float v11[6]; // [esp+70h] [ebp-18h] BYREF

  sub_80A8D74(a1, v10);
  sub_80A8D74(v10, v11);
  v8 = 1;
  v9[0] = 2;
  v9[1] = 2;
  v9[2] = 0;
  v9[3] = 0;
  v9[4] = 1;
  for ( i = 0; i <= 2; ++i )
  {
    if ( *(float *)(a2 + 4 * i) != 0.0 )
    {
      v6 = *(float *)(a2 + 4 * i) * 3.141592653589793 / 180.0;
      sub_80A8C4A(v6, (double *)v4, (double *)v5);
      v11[v9[2 * i - 1]] = v10[v9[2 * i - 1]] * *(double *)v5 - v10[v9[2 * i]] * *(double *)v4;
      v11[v9[2 * i]] = v10[v9[2 * i - 1]] * *(double *)v4 + v10[v9[2 * i]] * *(double *)v5;
    }
    sub_80A8D74(v11, v10);
  }
  return sub_80A8D74(v11, a3);
}
// 80A84C6: using guessed type float var_28[4];
// 80A84C6: using guessed type float var_18[6];

//----- (080A8610) --------------------------------------------------------
float *__cdecl sub_80A8610(float *a1, int a2, float *a3, float *a4)
{
  float v5[4]; // [esp+10h] [ebp-28h] BYREF
  float v6[6]; // [esp+20h] [ebp-18h] BYREF

  sub_80A8DE8(a1, a3, v6);
  sub_80A84C6(v6, a2, v5);
  return sub_80A8DA4(v5, a3, a4);
}
// 80A8610: using guessed type float var_18[6];
// 80A8610: using guessed type float var_28[4];

//----- (080A8664) --------------------------------------------------------
float *__cdecl sub_80A8664(float *a1, float a2, float a3)
{
  float *result; // eax
  int v4; // [esp+18h] [ebp-10h] BYREF
  int v5; // [esp+1Ch] [ebp-Ch] BYREF
  int v6; // [esp+20h] [ebp-8h] BYREF
  int v7; // [esp+24h] [ebp-4h] BYREF

  sub_80A8C1C(a3, (float *)&v7, (float *)&v6);
  sub_80A8C1C(a3, (float *)&v5, (float *)&v4);
  *a1 = a2 * *(float *)&v6 * *(float *)&v4;
  a1[1] = a2 * *(float *)&v7 * *(float *)&v4;
  result = a1 + 2;
  a1[2] = a2 * *(float *)&v5;
  return result;
}

//----- (080A86CC) --------------------------------------------------------
void __cdecl sub_80A86CC(float a1, float *a2)
{
  float v2[4]; // [esp+10h] [ebp-28h] BYREF
  int v3[6]; // [esp+20h] [ebp-18h] BYREF

  sub_80A303A(a1, v3, 0);
  sub_80A7D80((float *)v3, a2, v2);
  sub_80A2AF6(v2);
}
// 80A86CC: using guessed type float var_28[4];

//----- (080A8712) --------------------------------------------------------
int __cdecl sub_80A8712(int a1)
{
  int result; // eax

  result = a1;
  dword_815DE98 = a1;
  return result;
}
// 815DE98: using guessed type int dword_815DE98;

//----- (080A8720) --------------------------------------------------------
long double __cdecl sub_80A8720(float a1, float a2)
{
  float v3; // [esp+4h] [ebp-4h]

  dword_815DE98 = 214013 * dword_815DE98 + 2531011;
  v3 = (float)((unsigned int)dword_815DE98 >> 17);
  return (float)((a2 - a1) * v3 / 32768.0 + a1);
}
// 815DE98: using guessed type int dword_815DE98;

//----- (080A8776) --------------------------------------------------------
int __cdecl sub_80A8776(int a1, int a2)
{
  dword_815DE98 = 214013 * dword_815DE98 + 2531011;
  return a1 + ((int)(((unsigned int)dword_815DE98 >> 17) * (a2 - a1)) >> 15);
}
// 815DE98: using guessed type int dword_815DE98;

//----- (080A87D8) --------------------------------------------------------
float *__cdecl sub_80A87D8(float *a1, float *a2)
{
  float v3; // [esp+1Ch] [ebp-5Ch]
  float x; // [esp+20h] [ebp-58h]
  float v5; // [esp+24h] [ebp-54h]
  int v6; // [esp+28h] [ebp-50h]
  int i; // [esp+2Ch] [ebp-4Ch]
  float v8; // [esp+30h] [ebp-48h] BYREF
  float v9; // [esp+34h] [ebp-44h]
  float v10; // [esp+38h] [ebp-40h]
  float v11; // [esp+3Ch] [ebp-3Ch]
  float v12; // [esp+40h] [ebp-38h]
  float v13; // [esp+44h] [ebp-34h]
  float v14; // [esp+48h] [ebp-30h]
  float v15; // [esp+4Ch] [ebp-2Ch]
  float v16; // [esp+50h] [ebp-28h]
  float v17; // [esp+54h] [ebp-24h]
  float v18; // [esp+58h] [ebp-20h]
  float v19; // [esp+5Ch] [ebp-1Ch]
  float v20; // [esp+60h] [ebp-18h]
  float v21; // [esp+64h] [ebp-14h]
  float v22; // [esp+68h] [ebp-10h]
  float v23; // [esp+6Ch] [ebp-Ch]

  v8 = a1[5] - a1[7];
  v9 = a1[6] - a1[2];
  v10 = a1[1] - a1[3];
  v11 = *a1 + a1[4] + a1[8] + 1.0;
  v12 = *a1 - a1[4] - a1[8] + 1.0;
  v13 = a1[3] + a1[1];
  v14 = a1[6] + a1[2];
  v15 = v8;
  v16 = v13;
  v17 = a1[4] - *a1 - a1[8] + 1.0;
  v18 = a1[7] + a1[5];
  v19 = v9;
  v20 = v14;
  v21 = v18;
  v22 = a1[8] - a1[4] - *a1 + 1.0;
  v23 = v10;
  v6 = -1;
  x = 0.0;
  for ( i = 0; i <= 3; ++i )
  {
    v5 = sub_80A9024(&v8 + 4 * i);
    if ( x < (long double)v5 )
    {
      x = v5;
      v6 = i;
    }
  }
  v3 = 1.0 / sqrtf(x);
  return sub_80A8FD8(&v8 + 4 * v6, v3, a2);
}

//----- (080A8972) --------------------------------------------------------
void __cdecl sub_80A8972(float a1, float *a2, float *a3)
{
  float v3; // [esp+0h] [ebp-18h]

  if ( a1 < 0.0 )
    a1 = a1 + 360.0;
  if ( a1 == 0.0 )
  {
    *a3 = 1.0;
    *a2 = 0.0;
  }
  else if ( a1 == 90.0 )
  {
    *a3 = 0.0;
    *a2 = 1.0;
  }
  else if ( a1 == 180.0 )
  {
    *a3 = -1.0;
    *a2 = 0.0;
  }
  else if ( a1 == 270.0 )
  {
    *a3 = 0.0;
    *a2 = -1.0;
  }
  else
  {
    v3 = a1 * 0.0174532925199433;
    sub_80A8C1C(v3, a2, a3);
  }
}

//----- (080A8A66) --------------------------------------------------------
long double __cdecl sub_80A8A66(float a1, int a2, char a3)
{
  int v4; // [esp+8h] [ebp-Ch]
  int v5; // [esp+Ch] [ebp-8h]
  float v6; // [esp+10h] [ebp-4h]

  v4 = 1 << a3;
  v6 = a1;
  v5 = LODWORD(a1) & ((1 << a3) - 1);
  if ( v5 > a2 )
  {
    if ( v4 - v5 <= a2 )
      LODWORD(v6) = v4 - v5 + LODWORD(a1);
  }
  else
  {
    LODWORD(v6) = LODWORD(a1) - v5;
  }
  return v6;
}

//----- (080A8B40) --------------------------------------------------------
long double __cdecl sub_80A8B40(float a1)
{
  return (float)fabs(a1);
}

//----- (080A8B5A) --------------------------------------------------------
long double __cdecl sub_80A8B5A(float a1)
{
  return (float)sqrt(a1);
}

//----- (080A8B7A) --------------------------------------------------------
void __cdecl sub_80A8B7A(float a1, float a2)
{
  float v2; // [esp+0h] [ebp-18h]

  v2 = a1 - a2;
  sub_80A906A(v2, a1, a2);
}

//----- (080A8B9E) --------------------------------------------------------
long double __cdecl sub_80A8B9E(float a1, float a2, float a3)
{
  float v4; // [esp+0h] [ebp-18h]
  float v5; // [esp+0h] [ebp-18h]
  float v6; // [esp+8h] [ebp-10h]

  v4 = a1 - a3;
  v6 = sub_80A906A(v4, a3, a1);
  v5 = a2 - a1;
  return sub_80A906A(v5, a2, v6);
}

//----- (080A8BDC) --------------------------------------------------------
int __cdecl sub_80A8BDC(int a1)
{
  return *(_DWORD *)a1;
}

//----- (080A8BE6) --------------------------------------------------------
int __cdecl sub_80A8BE6(float a1)
{
  return (int)floor(a1 + 0.5);
}

//----- (080A8C1C) --------------------------------------------------------
void __cdecl sub_80A8C1C(float a1, float *a2, float *a3)
{
  *a2 = sin(a1);
  *a3 = cos(a1);
}

//----- (080A8C4A) --------------------------------------------------------
double *__cdecl sub_80A8C4A(double a1, double *a2, double *a3)
{
  long double v3; // fst7
  double *result; // eax

  *a2 = sin(a1);
  v3 = cos(a1);
  result = a3;
  *a3 = v3;
  return result;
}

//----- (080A8C78) --------------------------------------------------------
int __cdecl sub_80A8C78(_DWORD *a1)
{
  int result; // eax

  *a1 = 0;
  result = 0;
  a1[1] = 0;
  return result;
}

//----- (080A8C94) --------------------------------------------------------
int __cdecl sub_80A8C94(_DWORD *a1, int a2, int a3)
{
  int result; // eax

  *a1 = a2;
  result = a3;
  a1[1] = a3;
  return result;
}

//----- (080A8CAC) --------------------------------------------------------
float *__cdecl sub_80A8CAC(float *a1, float *a2, float *a3)
{
  float *result; // eax

  *a3 = *a1 - *a2;
  result = a1 + 1;
  a3[1] = a1[1] - a2[1];
  return result;
}

//----- (080A8CD8) --------------------------------------------------------
long double __cdecl sub_80A8CD8(float *a1, float *a2)
{
  return *a1 * *a2 + a1[1] * a2[1];
}

//----- (080A8CFA) --------------------------------------------------------
void __cdecl sub_80A8CFA(float *a1)
{
  float v1; // [esp+0h] [ebp-8h]

  v1 = *a1 * *a1 + a1[1] * a1[1];
  sub_80A8B5A(v1);
}

//----- (080A8D26) --------------------------------------------------------
int __cdecl sub_80A8D26(_DWORD *a1)
{
  int result; // eax

  *a1 = 0;
  a1[1] = 0;
  result = 0;
  a1[2] = 0;
  return result;
}

//----- (080A8D50) --------------------------------------------------------
int __cdecl sub_80A8D50(_DWORD *a1, int a2, int a3, int a4)
{
  int result; // eax

  *a1 = a2;
  a1[1] = a3;
  result = a4;
  a1[2] = a4;
  return result;
}

//----- (080A8D74) --------------------------------------------------------
int __cdecl sub_80A8D74(_DWORD *a1, _DWORD *a2)
{
  int result; // eax

  *a2 = *a1;
  a2[1] = a1[1];
  result = a1[2];
  a2[2] = result;
  return result;
}

//----- (080A8DA4) --------------------------------------------------------
float *__cdecl sub_80A8DA4(float *a1, float *a2, float *a3)
{
  float *result; // eax

  *a3 = *a1 + *a2;
  a3[1] = a1[1] + a2[1];
  result = a1 + 2;
  a3[2] = a1[2] + a2[2];
  return result;
}

//----- (080A8DE8) --------------------------------------------------------
float *__cdecl sub_80A8DE8(float *a1, float *a2, float *a3)
{
  float *result; // eax

  *a3 = *a1 - *a2;
  a3[1] = a1[1] - a2[1];
  result = a1 + 2;
  a3[2] = a1[2] - a2[2];
  return result;
}

//----- (080A8E2C) --------------------------------------------------------
float *__cdecl sub_80A8E2C(float *a1, float a2, float *a3)
{
  float *result; // eax

  *a3 = a2 * *a1;
  a3[1] = a2 * a1[1];
  result = a1 + 2;
  a3[2] = a2 * a1[2];
  return result;
}

//----- (080A8E64) --------------------------------------------------------
float *__cdecl sub_80A8E64(float *a1, float *a2, float *a3)
{
  float *result; // eax

  *a3 = *a1 * *a2;
  a3[1] = a1[1] * a2[1];
  result = a1 + 2;
  a3[2] = a1[2] * a2[2];
  return result;
}

//----- (080A8EA8) --------------------------------------------------------
float *__cdecl sub_80A8EA8(float *a1, float a2, float *a3, float *a4)
{
  float *result; // eax

  *a4 = a2 * *a3 + *a1;
  a4[1] = a2 * a3[1] + a1[1];
  result = a3 + 2;
  a4[2] = a2 * a3[2] + a1[2];
  return result;
}

//----- (080A8EFC) --------------------------------------------------------
long double __cdecl sub_80A8EFC(float *a1, float *a2)
{
  return *a1 * *a2 + a1[1] * a2[1] + a1[2] * a2[2];
}

//----- (080A8F30) --------------------------------------------------------
int __cdecl sub_80A8F30(float *a1, float *a2)
{
  int v3; // [esp+0h] [ebp-4h]

  v3 = 0;
  if ( *a1 == *a2 && a1[1] == a2[1] && a1[2] == a2[2] )
    return 1;
  return v3;
}

//----- (080A8F9A) --------------------------------------------------------
void __cdecl sub_80A8F9A(float *a1)
{
  float v1; // [esp+0h] [ebp-8h]

  v1 = *a1 * *a1 + a1[1] * a1[1] + a1[2] * a1[2];
  sub_80A8B5A(v1);
}

//----- (080A8FD8) --------------------------------------------------------
float *__cdecl sub_80A8FD8(float *a1, float a2, float *a3)
{
  float *result; // eax

  *a3 = a2 * *a1;
  a3[1] = a2 * a1[1];
  a3[2] = a2 * a1[2];
  result = a1 + 3;
  a3[3] = a2 * a1[3];
  return result;
}

//----- (080A9024) --------------------------------------------------------
long double __cdecl sub_80A9024(float *a1)
{
  return *a1 * *a1 + a1[1] * a1[1] + a1[2] * a1[2] + a1[3] * a1[3];
}

//----- (080A906A) --------------------------------------------------------
long double __cdecl sub_80A906A(float a1, float a2, float a3)
{
  if ( a1 < 0.0 )
    return a3;
  return a2;
}

//----- (080A9094) --------------------------------------------------------
float *__cdecl sub_80A9094(float *a1, float *a2, float *a3)
{
  float *result; // eax
  float v4[14]; // [esp+10h] [ebp-38h] BYREF

  sub_80A913C(a2, v4);
  *a3 = *a1 * v4[0] + a1[1] * v4[3] + a1[2] * v4[6] + a2[4];
  a3[1] = *a1 * v4[1] + a1[1] * v4[4] + a1[2] * v4[7] + a2[5];
  result = a2;
  a3[2] = *a1 * v4[2] + a1[1] * v4[5] + a1[2] * v4[8] + a2[6];
  return result;
}

//----- (080A913C) --------------------------------------------------------
float *__cdecl sub_80A913C(float *a1, float *a2)
{
  float *result; // eax
  int v3; // [esp+10h] [ebp-48h] BYREF
  float v4; // [esp+14h] [ebp-44h]
  float v5; // [esp+18h] [ebp-40h]
  float v6; // [esp+2Ch] [ebp-2Ch]
  float v7; // [esp+30h] [ebp-28h]
  float v8; // [esp+34h] [ebp-24h]
  float v9; // [esp+38h] [ebp-20h]
  float v10; // [esp+3Ch] [ebp-1Ch]
  float v11; // [esp+40h] [ebp-18h]
  float v12; // [esp+44h] [ebp-14h]
  float v13; // [esp+48h] [ebp-10h]
  float v14; // [esp+4Ch] [ebp-Ch]

  sub_80A8E2C(a1, a1[7], (float *)&v3);
  v14 = *(float *)&v3 * *a1;
  v13 = *(float *)&v3 * a1[1];
  v12 = *(float *)&v3 * a1[2];
  v11 = *(float *)&v3 * a1[3];
  v10 = v4 * a1[1];
  v9 = v4 * a1[2];
  v8 = v4 * a1[3];
  v7 = v5 * a1[2];
  v6 = v5 * a1[3];
  *a2 = 1.0 - (v10 + v7);
  a2[1] = v13 + v6;
  a2[2] = v12 - v8;
  a2[3] = v13 - v6;
  a2[4] = 1.0 - (v14 + v7);
  a2[5] = v9 + v11;
  a2[6] = v12 + v8;
  a2[7] = v9 - v11;
  result = a2 + 8;
  a2[8] = 1.0 - (v14 + v10);
  return result;
}

//----- (080A9254) --------------------------------------------------------
void __cdecl Z_FreeInternal(void *ptr)
{
  free(ptr);
}

//----- (080A9268) --------------------------------------------------------
void __cdecl Z_VirtualFreeInternal(void *ptr)
{
  free(ptr);
}

//----- (080A9290) --------------------------------------------------------
void __noreturn Sys_OutOfMemErrorInternal()
{
  sub_80D1DA6("universal/com_memory.cpp", 228);
}
// 80A9290: using guessed type void __noreturn Sys_OutOfMemErrorInternal();

//----- (080A92AC) --------------------------------------------------------
void *__cdecl MallocInternal(size_t size)
{
  return malloc(size);
}

//----- (080A92C0) --------------------------------------------------------
void *__cdecl Z_TryMallocInternal(size_t size)
{
  void *s; // [esp+14h] [ebp-4h]

  s = MallocInternal(size);
  if ( s )
    Com_Memset(s, 0, size);
  return s;
}

//----- (080A92FA) --------------------------------------------------------
void *__cdecl Z_MallocInternal(size_t size)
{
  void *v2; // [esp+4h] [ebp-4h]

  v2 = Z_TryMallocInternal(size);
  if ( !v2 )
    Sys_OutOfMemErrorInternal(size);
  return v2;
}
// 80A9290: using guessed type void __cdecl __noreturn Sys_OutOfMemErrorInternal(_DWORD);

//----- (080A9324) --------------------------------------------------------
void *__cdecl Z_MallocGarbageInternal(size_t size)
{
  void *v2; // [esp+4h] [ebp-4h]

  v2 = MallocInternal(size);
  if ( !v2 )
    Sys_OutOfMemErrorInternal(size);
  return v2;
}
// 80A9290: using guessed type void __cdecl __noreturn Sys_OutOfMemErrorInternal(_DWORD);

//----- (080A934E) --------------------------------------------------------
void *__cdecl VirtualAlloc(size_t size)
{
  return malloc(size);
}

//----- (080A9362) --------------------------------------------------------
void *__cdecl Z_VirtualAllocInternal(size_t size)
{
  void *v2; // [esp+14h] [ebp-4h]

  v2 = VirtualAlloc(size);
  if ( !v2 )
    sub_80D1DA6("universal/com_memory.cpp", 536);
  return v2;
}

//----- (080A93B0) --------------------------------------------------------
char *__cdecl CopyStringInternal(char *src)
{
  size_t v1; // eax
  char *dest; // [esp+14h] [ebp-4h]

  v1 = I_strlen(src);
  dest = (char *)Z_MallocInternal(v1 + 1);
  strcpy(dest, src);
  return dest;
}

//----- (080A93E4) --------------------------------------------------------
char *__cdecl ReplaceStringInternal(char **a1, char *src)
{
  size_t v3; // [esp+10h] [ebp-8h]
  char *s; // [esp+14h] [ebp-4h]

  v3 = I_strlen(src);
  s = *a1;
  if ( *a1 && strlen(s) < v3 )
  {
    Z_FreeInternal(s);
    s = 0;
  }
  if ( !s )
  {
    s = (char *)Z_MallocInternal(v3 + 1);
    *a1 = s;
  }
  return strcpy(s, src);
}

//----- (080A945A) --------------------------------------------------------
void Com_Meminfo_f()
{
  Com_Printf("%8i bytes total hunk\n", s_hunkTotal);
  Com_Printf("\n");
  Com_Printf("%8i low permanent\n", *(_DWORD *)dword_8515284);
  if ( *(_DWORD *)dword_8515288 != *(_DWORD *)dword_8515284 )
    Com_Printf("%8i low temp\n", *(_DWORD *)dword_8515288);
  Com_Printf("\n");
  Com_Printf("%8i high permanent\n", *(_DWORD *)dword_851528C);
  if ( *(_DWORD *)dword_8515290 != *(_DWORD *)dword_851528C )
    Com_Printf("%8i high temp\n", *(_DWORD *)dword_8515290);
  Com_Printf("\n");
  Com_Printf("%8i total hunk in use\n", *(_DWORD *)dword_8515284 + *(_DWORD *)dword_851528C);
  Com_Printf("\n");
}

//----- (080A9530) --------------------------------------------------------
void Com_TouchMemory()
{
  int v0; // [esp+14h] [ebp-14h]
  int i; // [esp+1Ch] [ebp-Ch]
  int j; // [esp+1Ch] [ebp-Ch]
  int v3; // [esp+20h] [ebp-8h]
  int v4; // [esp+24h] [ebp-4h]

  v4 = Sys_MilliSeconds();
  v0 = 0;
  for ( i = 0; i < *(int *)dword_8515284 >> 2; i += 64 )
    v0 += *(_DWORD *)(dword_8515294 + 4 * i);
  for ( j = (int)(s_hunkTotal - *(_DWORD *)dword_851528C) >> 2; j < *(int *)dword_851528C >> 2; j += 64 )
    v0 += *(_DWORD *)(dword_8515294 + 4 * j);
  v3 = Sys_MilliSeconds();
  Com_Printf("Com_TouchMemory: %i msec. Using sum: %d\n", v3 - v4, v0);
}
// 8515294: using guessed type int dword_8515294;

//----- (080A95F0) --------------------------------------------------------
void __usercall Com_InitHunkMemory(long double a1@<st0>)
{
  char *v1; // [esp+14h] [ebp-4h]

  if ( FS_LoadStack() )
    Com_Error(0, (char *)&byte_8146220);
  v1 = Dvar_RegisterInt(a1, "com_hunkMegs", (char *)0xA0, 1, 512, 4129);
  if ( *((int *)v1 + 2) > 79 )
  {
    s_hunkTotal = *((_DWORD *)v1 + 2) << 20;
  }
  else
  {
    Com_Printf("Minimum com_hunkMegs for a dedicated server is %i, allocating %i megs.\n", 80, 80);
    s_hunkTotal = 83886080;
  }
  dword_8515294 = (int)malloc(s_hunkTotal);
  if ( !dword_8515294 )
    sub_80D1DA6("universal/com_memory.cpp", 864);
  dword_8515298 = (void *)dword_8515294;
  Hunk_Clear();
  Cmd_AddCommand("meminfo", (int)Com_Meminfo_f);
}
// 8515294: using guessed type int dword_8515294;

//----- (080A96D6) --------------------------------------------------------
void *Hunk_Shutdown()
{
  free(dword_8515298);
  dword_8515294 = 0;
  dword_8515298 = 0;
  s_hunkTotal = 0;
  memset(dword_8515284, 0, 8u);
  return memset(dword_851528C, 0, 8u);
}
// 8515294: using guessed type int dword_8515294;

//----- (080A9742) --------------------------------------------------------
int __cdecl Hunk_FindDataForFileInternal(int a1, char *s2, int a3)
{
  int i; // [esp+14h] [ebp-4h]

  for ( i = com_fileDataHashTable[a3]; i; i = *(_DWORD *)(i + 4) )
  {
    if ( *(unsigned __int8 *)(i + 8) == a1 && !strcasecmp((const char *)(i + 9), s2) )
      return *(_DWORD *)i;
  }
  return 0;
}
// 8494220: using guessed type int com_fileDataHashTable[1024];

//----- (080A97A6) --------------------------------------------------------
int __cdecl Hunk_FindDataForFile(int a1, char *s2)
{
  int v3; // [esp+14h] [ebp-4h]

  v3 = FS_HashFileName((int)s2, 1024);
  return Hunk_FindDataForFileInternal(a1, s2, v3);
}

//----- (080A97DE) --------------------------------------------------------
_BOOL4 __cdecl Hunk_DataOnHunk(size_t a1)
{
  return a1 >= dword_8515294 && a1 < dword_8515294 + s_hunkTotal;
}
// 8515294: using guessed type int dword_8515294;

//----- (080A981E) --------------------------------------------------------
int __cdecl Hunk_SetDataForFile(char a1, char *src, int a3, int (__cdecl *a4)(size_t))
{
  size_t v4; // eax
  int v6; // [esp+10h] [ebp-8h]
  int v7; // [esp+14h] [ebp-4h]

  v7 = FS_HashFileName((int)src, 1024);
  v4 = I_strlen(src);
  v6 = a4(v4 + 10);
  *(_DWORD *)v6 = a3;
  *(_BYTE *)(v6 + 8) = a1;
  strcpy((char *)(v6 + 9), src);
  *(_DWORD *)(v6 + 4) = com_fileDataHashTable[v7];
  com_fileDataHashTable[v7] = v6;
  return v6 + 9;
}
// 8494220: using guessed type int com_fileDataHashTable[1024];

//----- (080A98A0) --------------------------------------------------------
int __cdecl Hunk_AddData(char a1, int a2, int (__cdecl *a3)(int))
{
  int result; // eax

  result = a3(9);
  *(_DWORD *)result = a2;
  *(_BYTE *)(result + 8) = a1;
  *(_DWORD *)(result + 4) = com_hunkData;
  com_hunkData = result;
  return result;
}
// 8495220: using guessed type int com_hunkData;

//----- (080A98DC) --------------------------------------------------------
int __cdecl Hunk_OverrideDataForFile(int a1, char *s2, int a3)
{
  int result; // eax
  int i; // [esp+10h] [ebp-8h]

  result = com_fileDataHashTable[FS_HashFileName((int)s2, 1024)];
  for ( i = result; i; i = result )
  {
    if ( *(unsigned __int8 *)(i + 8) == a1 && !strcasecmp((const char *)(i + 9), s2) )
    {
      result = a3;
      *(_DWORD *)i = a3;
      return result;
    }
    result = *(_DWORD *)(i + 4);
  }
  return result;
}
// 8494220: using guessed type int com_fileDataHashTable[1024];

//----- (080A994C) --------------------------------------------------------
unsigned int *__cdecl Hunk_ClearDataFor(unsigned int *a1, unsigned int a2, unsigned int a3)
{
  unsigned int *result; // eax
  int v4; // [esp+Ch] [ebp-Ch]
  __int16 *v5; // [esp+10h] [ebp-8h]
  unsigned int v6; // [esp+14h] [ebp-4h]

  while ( 1 )
  {
    result = a1;
    if ( !*a1 )
      break;
    v6 = *a1;
    if ( *a1 >= a2 && v6 < a3 )
    {
      *a1 = *(_DWORD *)(v6 + 4);
      v5 = *(__int16 **)v6;
      v4 = *(unsigned __int8 *)(v6 + 8);
      if ( v4 == 4 )
      {
        XModelFree((int)v5);
      }
      else if ( *(unsigned __int8 *)(v6 + 8) > 4u )
      {
        if ( v4 == 5 )
        {
          XAnimFree((int)v5);
        }
        else if ( v4 == 6 )
        {
          XAnimFreeList((int)v5);
        }
      }
      else if ( v4 == 3 )
      {
        XModelPartsFree(v5);
      }
    }
    else
    {
      a1 = (unsigned int *)(v6 + 4);
    }
  }
  return result;
}

//----- (080A9A04) --------------------------------------------------------
unsigned int *Hunk_ClearData()
{
  unsigned int i; // [esp+1Ch] [ebp-Ch]
  unsigned int v2; // [esp+20h] [ebp-8h]
  unsigned int v3; // [esp+24h] [ebp-4h]

  v3 = dword_8515294 + *(_DWORD *)dword_8515284;
  v2 = dword_8515294 + s_hunkTotal - *(_DWORD *)dword_851528C;
  for ( i = 0; i <= 0x3FF; ++i )
    Hunk_ClearDataFor((unsigned int *)&com_fileDataHashTable[i], v3, v2);
  return Hunk_ClearDataFor((unsigned int *)&com_hunkData, v3, v2);
}
// 8494220: using guessed type int com_fileDataHashTable[1024];
// 8495220: using guessed type int com_hunkData;
// 8515294: using guessed type int dword_8515294;

//----- (080A9A8E) --------------------------------------------------------
int __cdecl sub_80A9A8E(int a1, int a2, void (__cdecl *a3)(_DWORD, int), int a4)
{
  int result; // eax

  while ( a1 )
  {
    if ( *(unsigned __int8 *)(a1 + 8) == a2 && *(_BYTE *)(a1 + 8) == 4 )
      a3(*(_DWORD *)a1, a4);
    result = *(_DWORD *)(a1 + 4);
    a1 = result;
  }
  return result;
}

//----- (080A9AEC) --------------------------------------------------------
unsigned int *__cdecl sub_80A9AEC(unsigned int *a1, void (__cdecl *a2)(_DWORD, int), int a3, char a4)
{
  unsigned int *result; // eax
  unsigned int i; // [esp+20h] [ebp-8h] BYREF
  char v6; // [esp+27h] [ebp-1h]

  v6 = a4;
  result = a1;
  if ( a1 == (unsigned int *)1 )
  {
    for ( i = 0; i <= 0x3FF; ++i )
    {
      sub_80A9A8E(com_fileDataHashTable[i], 4, a2, a3);
      result = &i;
    }
  }
  return result;
}
// 8494220: using guessed type int com_fileDataHashTable[1024];

//----- (080A9B52) --------------------------------------------------------
int Hunk_SetMark()
{
  return *(_DWORD *)dword_851528C;
}

//----- (080A9B5C) --------------------------------------------------------
unsigned int *__cdecl Hunk_ClearHigh(int a1)
{
  *(_DWORD *)dword_8515290 = a1;
  *(_DWORD *)dword_851528C = a1;
  return Hunk_ClearData();
}

//----- (080A9B80) --------------------------------------------------------
unsigned int *__cdecl Hunk_ClearLow(int a1)
{
  *(_DWORD *)dword_8515288 = a1;
  *(_DWORD *)dword_8515284 = a1;
  return Hunk_ClearData();
}

//----- (080A9B9A) --------------------------------------------------------
unsigned int *Hunk_Clear()
{
  *(_DWORD *)dword_8515284 = 0;
  *(_DWORD *)dword_8515288 = 0;
  *(_DWORD *)dword_851528C = 0;
  *(_DWORD *)dword_8515290 = 0;
  return Hunk_ClearData();
}

//----- (080A9BE0) --------------------------------------------------------
void *__cdecl Hunk_AllocInternal(size_t n)
{
  return Hunk_AllocAlignInternal(n, 32);
}

//----- (080A9BFC) --------------------------------------------------------
void *__cdecl Hunk_AllocAlignInternal(size_t n, int a2)
{
  void *s; // [esp+24h] [ebp-4h]

  *(_DWORD *)dword_851528C += n;
  *(_DWORD *)dword_851528C = (a2 - 1 + *(_DWORD *)dword_851528C) & ~(a2 - 1);
  s = (void *)(dword_8515294 + s_hunkTotal - *(_DWORD *)dword_851528C);
  *(_DWORD *)dword_8515290 = *(_DWORD *)dword_851528C;
  if ( *(_DWORD *)dword_8515288 + *(_DWORD *)dword_851528C > (int)s_hunkTotal )
    Com_Error(
      1,
      (char *)&byte_81462E0,
      n,
      (int)s_hunkTotal / 0x100000,
      *(_DWORD *)dword_8515288 / 0x100000,
      *(_DWORD *)dword_8515290 / 0x100000);
  memset(s, 0, n);
  return s;
}
// 8515294: using guessed type int dword_8515294;

//----- (080A9CF0) --------------------------------------------------------
size_t __cdecl Hunk_AllocateTempMemoryHighInternal(int a1)
{
  *(_DWORD *)dword_8515290 += a1;
  *(_DWORD *)dword_8515290 = (*(_DWORD *)dword_8515290 + 15) & 0xFFFFFFF0;
  if ( *(_DWORD *)dword_8515288 + *(_DWORD *)dword_8515290 > (int)s_hunkTotal )
    Com_Error(
      1,
      (char *)&byte_8146340,
      a1,
      (int)s_hunkTotal / 0x100000,
      *(_DWORD *)dword_8515288 / 0x100000,
      *(_DWORD *)dword_8515290 / 0x100000);
  return dword_8515294 + s_hunkTotal - *(_DWORD *)dword_8515290;
}
// 8515294: using guessed type int dword_8515294;

//----- (080A9DB4) --------------------------------------------------------
int Hunk_ClearTempMemoryHighInternal()
{
  int result; // eax

  result = *(_DWORD *)dword_851528C;
  *(_DWORD *)dword_8515290 = *(_DWORD *)dword_851528C;
  return result;
}

//----- (080A9DC4) --------------------------------------------------------
void *__cdecl Hunk_AllocLowInternal(size_t n)
{
  return Hunk_AllocLowAlignInternal(n, 32);
}

//----- (080A9DE0) --------------------------------------------------------
void *__cdecl Hunk_AllocLowAlignInternal(size_t n, int a2)
{
  void *s; // [esp+24h] [ebp-4h]

  *(_DWORD *)dword_8515284 = (a2 - 1 + *(_DWORD *)dword_8515284) & ~(a2 - 1);
  s = (void *)(dword_8515294 + *(_DWORD *)dword_8515284);
  *(_DWORD *)dword_8515284 += n;
  *(_DWORD *)dword_8515288 = *(_DWORD *)dword_8515284;
  if ( *(_DWORD *)dword_8515284 + *(_DWORD *)dword_8515290 > (int)s_hunkTotal )
    Com_Error(
      1,
      (char *)&byte_81463A0,
      n,
      (int)s_hunkTotal / 0x100000,
      *(_DWORD *)dword_8515288 / 0x100000,
      *(_DWORD *)dword_8515290 / 0x100000);
  memset(s, 0, n);
  return s;
}
// 8515294: using guessed type int dword_8515294;

//----- (080A9ECE) --------------------------------------------------------
int Hunk_ConvertTempToPermLowInternal()
{
  int result; // eax

  result = *(_DWORD *)dword_8515288;
  *(_DWORD *)dword_8515284 = *(_DWORD *)dword_8515288;
  return result;
}

//----- (080A9EDE) --------------------------------------------------------
_DWORD *__cdecl Hunk_AllocateTempMemoryInternal(size_t size)
{
  int v3; // [esp+2Ch] [ebp-Ch]
  _DWORD *v4; // [esp+34h] [ebp-4h]
  size_t sizea; // [esp+40h] [ebp+8h]

  if ( !dword_8515294 )
    return Z_MallocInternal(size);
  sizea = size + 16;
  v3 = *(_DWORD *)dword_8515288;
  *(_DWORD *)dword_8515288 = (*(_DWORD *)dword_8515288 + 15) & 0xFFFFFFF0;
  v4 = (_DWORD *)(dword_8515294 + *(_DWORD *)dword_8515288);
  *(_DWORD *)dword_8515288 += sizea;
  if ( *(_DWORD *)dword_8515288 + *(_DWORD *)dword_8515290 > (int)s_hunkTotal )
    Com_Error(
      1,
      (char *)&byte_8146400,
      sizea,
      (int)s_hunkTotal / 0x100000,
      *(_DWORD *)dword_8515288 / 0x100000,
      *(_DWORD *)dword_8515290 / 0x100000,
      *(_DWORD *)dword_8515288 + *(_DWORD *)dword_8515290 - s_hunkTotal);
  *v4 = -1991018350;
  v4[1] = *(_DWORD *)dword_8515288 - v3;
  return v4 + 4;
}
// 8515294: using guessed type int dword_8515294;

//----- (080AA00A) --------------------------------------------------------
unsigned int __cdecl Hunk_ReallocateTempMemoryInternal(int a1)
{
  *(_DWORD *)dword_8515288 = (*(_DWORD *)dword_8515284 + 31) & 0xFFFFFFE0;
  *(_DWORD *)dword_8515288 += a1;
  if ( *(_DWORD *)dword_8515288 + *(_DWORD *)dword_8515290 > (int)s_hunkTotal )
    Com_Error(
      1,
      (char *)&byte_8146480,
      a1,
      (int)s_hunkTotal / 0x100000,
      *(_DWORD *)dword_8515288 / 0x100000,
      *(_DWORD *)dword_8515290 / 0x100000);
  return dword_8515294 + ((*(_DWORD *)dword_8515284 + 31) & 0xFFFFFFE0);
}
// 8515294: using guessed type int dword_8515294;

//----- (080AA0C8) --------------------------------------------------------
void __cdecl Hunk_FreeTempMemory(_DWORD *ptr)
{
  _DWORD *v1; // [esp+14h] [ebp-4h]

  if ( dword_8515294 )
  {
    v1 = ptr - 4;
    if ( *(ptr - 4) != -1991018350 )
      Com_Error(0, (char *)&byte_81464E0);
    *v1 = -1991018349;
    *(_DWORD *)dword_8515288 -= v1[1];
  }
  else
  {
    Z_FreeInternal(ptr);
  }
}
// 8515294: using guessed type int dword_8515294;

//----- (080AA124) --------------------------------------------------------
int Hunk_ClearTempMemoryInternal()
{
  int result; // eax

  if ( dword_8515294 )
  {
    result = *(_DWORD *)dword_8515284;
    *(_DWORD *)dword_8515288 = *(_DWORD *)dword_8515284;
  }
  return result;
}
// 8515294: using guessed type int dword_8515294;

//----- (080AA13C) --------------------------------------------------------
int Hunk_HideTempMemory()
{
  int v1; // [esp+0h] [ebp-4h]

  v1 = *(_DWORD *)dword_8515284;
  *(_DWORD *)dword_8515284 = *(_DWORD *)dword_8515288;
  return v1;
}

//----- (080AA15A) --------------------------------------------------------
int __cdecl Hunk_ShowTempMemory(int a1)
{
  int result; // eax

  result = a1;
  *(_DWORD *)dword_8515284 = a1;
  return result;
}

//----- (080AA194) --------------------------------------------------------
int __cdecl sub_80AA194(int a1)
{
  int v2; // [esp+0h] [ebp-4h]

  v2 = g_largeLocalPos;
  g_largeLocalPos += (a1 + 3) & 0xFFFFFFFC;
  return v2;
}
// 8495224: using guessed type int g_largeLocalPos;

//----- (080AA1BC) --------------------------------------------------------
int __cdecl sub_80AA1BC(int a1)
{
  int result; // eax

  result = a1;
  g_largeLocalPos = a1;
  return result;
}
// 8495224: using guessed type int g_largeLocalPos;

//----- (080AA1CA) --------------------------------------------------------
char *__cdecl sub_80AA1CA(int a1)
{
  return (char *)&unk_8495280 + a1;
}

//----- (080AA1F6) --------------------------------------------------------
int __cdecl LargeLocal(int *a1, int a2)
{
  int result; // eax

  result = sub_80AA194(a2);
  *a1 = result;
  return result;
}

//----- (080AA22A) --------------------------------------------------------
int __cdecl LargeLocalDealloc(int *a1)
{
  return sub_80AA1BC(*a1);
}

//----- (080AA240) --------------------------------------------------------
char *__cdecl LargeLocalGetBuf(int *a1)
{
  return sub_80AA1CA(*a1);
}

//----- (080AA256) --------------------------------------------------------
void LargeLocalReset()
{
  g_largeLocalPos = 0;
}
// 8495224: using guessed type int g_largeLocalPos;

//----- (080AA268) --------------------------------------------------------
char *__cdecl sub_80AA268(char *s, char *a2, int (__cdecl *a3)(char *, char *))
{
  size_t v3; // ebx
  signed int i; // [esp+Ch] [ebp-Ch]
  signed int v7; // [esp+10h] [ebp-8h]

  v3 = I_strlen(s);
  v7 = v3 - I_strlen(a2);
  for ( i = 0; i <= v7; ++i )
  {
    if ( !a3(s, a2) )
      return s;
    ++s;
  }
  return 0;
}

//----- (080AA2D8) --------------------------------------------------------
int __cdecl Com_Filter(char *a1, char *a2, int a3)
{
  char *v3; // eax
  int v4; // ebx
  int v5; // ebx
  int v6; // ebx
  int v7; // ebx
  int v10; // [esp+24h] [ebp-414h]
  int v11; // [esp+28h] [ebp-410h]
  char s[1032]; // [esp+30h] [ebp-408h] BYREF
  char *v13; // [esp+440h] [ebp+8h]

  while ( *a1 )
  {
    if ( *a1 == 42 )
    {
      ++a1;
      v11 = 0;
      while ( *a1 && *a1 != 42 && *a1 != 63 )
        s[v11++] = *a1++;
      s[v11] = 0;
      if ( s[0] )
      {
        if ( a3 )
          v3 = sub_80AA268(a2, s, sub_80B5642);
        else
          v3 = sub_80AA268(a2, s, I_stricmp);
        if ( !v3 )
          return 0;
        a2 = &v3[strlen(s)];
      }
    }
    else if ( *a1 == 63 )
    {
      ++a1;
      ++a2;
    }
    else if ( *a1 == 91 && a1[1] == 91 )
    {
      ++a1;
    }
    else if ( *a1 == 91 )
    {
      v13 = a1 + 1;
      v10 = 0;
      while ( *v13 && !v10 && (*v13 != 93 || v13[1] == 93) )
      {
        if ( v13[1] == 45 && v13[2] && (v13[2] != 93 || v13[3] == 93) )
        {
          if ( a3 )
          {
            if ( *a2 >= *v13 && *a2 <= v13[2] )
              v10 = 1;
          }
          else
          {
            v4 = toupper(*a2);
            if ( v4 >= toupper(*v13) )
            {
              v5 = toupper(*a2);
              if ( v5 <= toupper(v13[2]) )
                v10 = 1;
            }
          }
          v13 += 3;
        }
        else
        {
          if ( a3 )
          {
            if ( *v13 == *a2 )
              v10 = 1;
          }
          else
          {
            v6 = toupper(*v13);
            if ( v6 == toupper(*a2) )
              v10 = 1;
          }
          ++v13;
        }
      }
      if ( !v10 )
        return 0;
      while ( *v13 && (*v13 != 93 || v13[1] == 93) )
        ++v13;
      a1 = v13 + 1;
      ++a2;
    }
    else
    {
      if ( a3 )
      {
        if ( *a1 != *a2 )
          return 0;
      }
      else
      {
        v7 = toupper(*a1);
        if ( v7 != toupper(*a2) )
          return 0;
      }
      ++a1;
      ++a2;
    }
  }
  return 1;
}
// 80AA2D8: using guessed type char s[1032];

//----- (080AA618) --------------------------------------------------------
int __cdecl Com_FilterPath(int a1, int a2, int a3)
{
  char v4[64]; // [esp+10h] [ebp-98h] BYREF
  char v5[76]; // [esp+50h] [ebp-58h] BYREF
  int i; // [esp+9Ch] [ebp-Ch]

  for ( i = 0; i <= 62 && *(_BYTE *)(a1 + i); ++i )
  {
    if ( *(_BYTE *)(a1 + i) == 92 || *(_BYTE *)(a1 + i) == 58 )
      v5[i] = 47;
    else
      v5[i] = *(_BYTE *)(a1 + i);
  }
  v5[i] = 0;
  for ( i = 0; i <= 62 && *(_BYTE *)(a2 + i); ++i )
  {
    if ( *(_BYTE *)(a2 + i) == 92 || *(_BYTE *)(a2 + i) == 58 )
      v4[i] = 47;
    else
      v4[i] = *(_BYTE *)(a2 + i);
  }
  v4[i] = 0;
  return (unsigned __int8)Com_Filter(v5, v4, a3);
}
// 80AA618: using guessed type char var_58[76];
// 80AA618: using guessed type char var_98[64];

//----- (080AA70C) --------------------------------------------------------
int __cdecl sub_80AA70C(int a1, int a2)
{
  int i; // [esp+0h] [ebp-8h]
  int v4; // [esp+4h] [ebp-4h]

  v4 = 0;
  for ( i = 0; i < a2 && *(_BYTE *)(i + a1); ++i )
    v4 += *(char *)(i + a1) * (i + 119);
  return (v4 >> 20) ^ (v4 >> 10) ^ v4;
}

//----- (080AA81C) --------------------------------------------------------
void *__cdecl Com_Memcpy(void *dest, void *src, size_t n)
{
  return memcpy(dest, src, n);
}

//----- (080AA83E) --------------------------------------------------------
void *__cdecl Com_Memset(void *s, int c, size_t n)
{
  return memset(s, c, n);
}

//----- (080AA860) --------------------------------------------------------
int __cdecl sub_80AA860(_BYTE *a1)
{
  int v2; // [esp+10h] [ebp-8h]

  v2 = 0;
  while ( *a1 )
    v2 = tolower((char)*a1++) + 31337 * v2;
  return v2 & 0x3FF;
}

//----- (080AA8AA) --------------------------------------------------------
int __cdecl sub_80AA8AA(char *a1)
{
  int i; // [esp+10h] [ebp-8h]

  if ( !a1 )
    return 0;
  for ( i = dword_85152C8[sub_80AA860(a1)]; i; i = *(_DWORD *)(i + 12) )
  {
    if ( !I_stricmp(a1, *(char **)i) )
      return i;
  }
  return 0;
}
// 85152C8: using guessed type int dword_85152C8[1025];

//----- (080AA91A) --------------------------------------------------------
int __cdecl sub_80AA91A(char **a1)
{
  int i; // [esp+Ch] [ebp-Ch]
  char **v4; // [esp+10h] [ebp-8h]
  int v5; // [esp+14h] [ebp-4h]

  v5 = sub_80AA8AA(*a1);
  v4 = *(char ***)(v5 + 4);
  for ( i = 0; i < *(_DWORD *)(v5 + 8); ++i )
  {
    if ( v4 == a1 )
      return i;
    v4 += 17;
  }
  return 0;
}

//----- (080AA976) --------------------------------------------------------
int __cdecl SND_GetAliasWithOffset(char *a1, int a2)
{
  int i; // [esp+1Ch] [ebp-Ch]
  int v5; // [esp+20h] [ebp-8h]
  int v6; // [esp+24h] [ebp-4h]

  v6 = sub_80AA8AA(a1);
  v5 = *(_DWORD *)(v6 + 4);
  for ( i = 0; i < *(_DWORD *)(v6 + 8); ++i )
  {
    if ( i == a2 )
      return v5;
    v5 += 68;
  }
  if ( !*(_DWORD *)(v6 + 8) )
    Com_Error(1, "SND_GetAliasWithOffset: could not find sound alias '%s' with offset %d", a1, a2);
  return *(_DWORD *)(v6 + 4);
}
// 80AA976: using guessed type char *arg_0;

//----- (080AAA06) --------------------------------------------------------
int __cdecl sub_80AAA06(char *a1, int a2)
{
  int i; // [esp+10h] [ebp-8h]
  int v5; // [esp+14h] [ebp-4h]

  v5 = sub_80AA860(a1);
  for ( i = dword_85152C8[v5]; i; i = *(_DWORD *)(i + 12) )
  {
    if ( !I_stricmp(a1, *(char **)i) )
      return 0;
  }
  *(_DWORD *)(a2 + 12) = dword_85152C8[v5];
  dword_85152C8[v5] = a2;
  return 1;
}
// 85152C8: using guessed type int dword_85152C8[1025];

//----- (080AAA84) --------------------------------------------------------
char *__cdecl sub_80AAA84(_DWORD *a1, char *s)
{
  char *result; // eax
  size_t v3; // eax
  char *dest; // [esp+18h] [ebp-10h]
  char *v5; // [esp+1Ch] [ebp-Ch]
  int i; // [esp+20h] [ebp-8h]
  char *v7; // [esp+20h] [ebp-8h]
  int v8; // [esp+24h] [ebp-4h]

  v8 = sub_80AA860(s);
  for ( i = dword_85152C8[v8]; i; i = *(_DWORD *)(i + 12) )
  {
    if ( !I_stricmp(s, *(char **)i) )
    {
      v5 = *(char **)i;
      *(_DWORD *)i = *a1;
      *(_DWORD *)(i + 4) = a1[1];
      *(_DWORD *)(i + 8) = a1[2];
      *(_DWORD *)(i + 12) = a1[3];
      result = v5;
      *(_DWORD *)i = v5;
      return result;
    }
  }
  v7 = (char *)sub_80AB130(0x10u);
  *(_DWORD *)v7 = *a1;
  *((_DWORD *)v7 + 1) = a1[1];
  *((_DWORD *)v7 + 2) = a1[2];
  *((_DWORD *)v7 + 3) = a1[3];
  v3 = strlen(s);
  dest = (char *)sub_80AB130(v3 + 1);
  strcpy(dest, s);
  *(_DWORD *)v7 = dest;
  *((_DWORD *)v7 + 3) = dword_85152C8[v8];
  result = v7;
  dword_85152C8[v8] = (int)v7;
  return result;
}
// 85152C8: using guessed type int dword_85152C8[1025];

//----- (080AABBA) --------------------------------------------------------
void sub_80AABBA()
{
  size_t v0; // eax
  char *dest; // [esp+18h] [ebp-10h]
  int i; // [esp+1Ch] [ebp-Ch]
  char v3[4]; // [esp+20h] [ebp-8h] BYREF
  void *ptr; // [esp+24h] [ebp-4h]

  memset(dword_8516354, 0, 0x480u);
  sub_80AD920(dword_8516354);
  ptr = FS_ListFiles((int)"soundaliases", "vfcurve", 0, (int *)v3);
  if ( *(int *)v3 > 15 )
    Com_Error(1, (char *)&byte_8146580, *(_DWORD *)v3, 15, 10);
  for ( i = 0; i < *(int *)v3; ++i )
  {
    dest = (char *)((i << 6) + 139552788);
    v0 = strlen(*((const char **)ptr + i));
    I_strncpyz(dest, *((char **)ptr + i), v0 - 7);
    if ( !(unsigned __int8)sub_80AD6F6(dest, (float *)(72 * i + 139551644)) )
      Com_Error(0, (char *)&byte_81465E0, *((_DWORD *)ptr + i));
  }
  FS_FreeFileList((void **)ptr);
  byte_8516350 = 1;
}
// 8516350: using guessed type char byte_8516350;
// 8516354: using guessed type _DWORD dword_8516354[547];

//----- (080AAD12) --------------------------------------------------------
void __cdecl Com_LoadSoundAliases(char *src, char *s2, int a3)
{
  int v3; // [esp+2Ch] [ebp-5Ch]
  char dest[68]; // [esp+30h] [ebp-58h] BYREF
  int i; // [esp+74h] [ebp-14h]
  int v6; // [esp+78h] [ebp-10h] BYREF
  void *ptr; // [esp+7Ch] [ebp-Ch]

  if ( sub_80AB144(src, "maps/mp/", 8) )
  {
    if ( sub_80AB144(src, "maps/", 5) )
      strcpy(dest, src);
    else
      sub_80B4E98(src + 5, dest);
  }
  else
  {
    sub_80B4E98(src + 8, dest);
  }
  strlwr(dest);
  if ( a3 == 1 && *(_BYTE *)(com_sv_running + 8) )
  {
    dword_85162D8 = dword_85162E8;
    dword_85162DC = dword_85162EC;
    dword_85162E0 = dword_85162F0;
    dword_85162E4 = dword_85162F4;
    dword_8516300 = dword_8516308;
    dword_8516304 = dword_851630C;
  }
  else
  {
    ptr = FS_ListFiles((int)"soundaliases", "csv", 0, &v6);
    if ( !v6 )
    {
      Com_Printf("WARNING: can't find any sound alias files (soundaliases/*.csv)\n");
      return;
    }
    v3 = Hunk_HideTempMemory();
    sub_80AC22C();
    for ( i = 0; i < v6; ++i )
      sub_80AC582(dest, s2, *((char **)ptr + i));
    sub_80ACE9A(16 * a3 + 139551432, (_DWORD *)(8 * a3 + 139551480));
    Hunk_ClearTempMemoryInternal();
    Hunk_ShowTempMemory(v3);
    FS_FreeFileList((void **)ptr);
  }
  *(_BYTE *)(a3 + 139547328) = 1;
}
// 819EF14: using guessed type int com_sv_running;
// 85162D8: using guessed type int dword_85162D8;
// 85162DC: using guessed type int dword_85162DC;
// 85162E0: using guessed type int dword_85162E0;
// 85162E4: using guessed type int dword_85162E4;
// 85162E8: using guessed type int dword_85162E8;
// 85162EC: using guessed type int dword_85162EC;
// 85162F0: using guessed type int dword_85162F0;
// 85162F4: using guessed type int dword_85162F4;
// 8516300: using guessed type int dword_8516300;
// 8516304: using guessed type int dword_8516304;
// 8516308: using guessed type int dword_8516308;
// 851630C: using guessed type int dword_851630C;

//----- (080AAEDC) --------------------------------------------------------
int __cdecl Com_UnloadSoundAliases(int a1)
{
  int result; // eax

  result = a1 + 139547328;
  if ( *(_BYTE *)(a1 + 139547328) )
  {
    if ( dword_85162CC[4 * a1] )
    {
      dword_85162CC[4 * a1] = 0;
      dword_85162D0[4 * a1] = 0;
      memset(&dword_85152C8, 0, 0x1000u);
    }
    result = a1 + 139547328;
    *(_BYTE *)(a1 + 139547328) = 0;
  }
  return result;
}
// 85152C8: using guessed type int dword_85152C8;
// 85162CC: using guessed type int dword_85162CC[];
// 85162D0: using guessed type int dword_85162D0[];

//----- (080AAF4A) --------------------------------------------------------
int __cdecl sub_80AAF4A(char *a1)
{
  int v3; // [esp+14h] [ebp-4h]

  v3 = sub_80AA8AA(a1);
  if ( v3 )
    return *(_DWORD *)v3;
  else
    return 0;
}

//----- (080AAF92) --------------------------------------------------------
int __cdecl sub_80AAF92(int a1)
{
  int v3; // [esp+10h] [ebp-18h]
  int i; // [esp+10h] [ebp-18h]
  int v5; // [esp+14h] [ebp-14h]
  float v6; // [esp+18h] [ebp-10h]
  float v7; // [esp+18h] [ebp-10h]
  int v8; // [esp+1Ch] [ebp-Ch]
  int v9; // [esp+20h] [ebp-8h]
  int v10; // [esp+20h] [ebp-8h]
  int v11; // [esp+24h] [ebp-4h]

  if ( !a1 )
    return 0;
  v11 = *(_DWORD *)(a1 + 4);
  v8 = v11;
  v6 = *(float *)(v11 + 52);
  v5 = *(_DWORD *)(v11 + 16);
  v9 = v11;
  v3 = 0;
  while ( ++v3 != *(_DWORD *)(a1 + 8) )
  {
    v9 += 68;
    v6 = v6 + *(float *)(v9 + 52);
    if ( *(float *)(v9 + 52) * -2147483600.0 > (long double)sub_80AB1DC() * v6 )
      v8 = v9;
    if ( v5 < *(_DWORD *)(v9 + 16) )
      v5 = *(_DWORD *)(v9 + 16);
  }
  if ( *(int *)(a1 + 8) > 2 && v5 == *(_DWORD *)(v8 + 16) )
  {
    v7 = 0.0;
    v10 = v11;
    for ( i = 0; i < *(_DWORD *)(a1 + 8); ++i )
    {
      if ( v5 != *(_DWORD *)(v10 + 16) )
      {
        v7 = v7 + *(float *)(v10 + 52);
        if ( *(float *)(v10 + 52) * -2147483600.0 > (long double)sub_80AB1DC() * v7 )
          v8 = v10;
      }
      v10 += 68;
    }
  }
  *(_DWORD *)(v8 + 16) = v5 + 1;
  return v8;
}

//----- (080AB0E2) --------------------------------------------------------
int __cdecl sub_80AB0E2(char *a1)
{
  int v2; // [esp+4h] [ebp-4h]

  v2 = sub_80AA8AA(a1);
  return sub_80AAF92(v2);
}

//----- (080AB104) --------------------------------------------------------
int sub_80AB104()
{
  return 0;
}

//----- (080AB112) --------------------------------------------------------
void *sub_80AB112()
{
  return &unk_8516354;
}

//----- (080AB11C) --------------------------------------------------------
_DWORD *__cdecl sub_80AB11C(size_t size)
{
  return Hunk_AllocateTempMemoryInternal(size);
}

//----- (080AB130) --------------------------------------------------------
void *__cdecl sub_80AB130(size_t a1)
{
  return Hunk_AllocInternal(a1);
}

//----- (080AB144) --------------------------------------------------------
int __cdecl sub_80AB144(_BYTE *a1, _BYTE *a2, int a3)
{
  char v6; // [esp+16h] [ebp-2h]
  char v7; // [esp+17h] [ebp-1h]

  while ( a3 && *a1 )
  {
    v7 = tolower((char)*a1);
    v6 = tolower((char)*a2);
    --a3;
    ++a1;
    ++a2;
    if ( v7 < v6 )
      return -1;
    if ( v7 > v6 )
      return 1;
  }
  if ( !a3 || *a1 == *a2 )
    return 0;
  else
    return -1;
}

//----- (080AB1DC) --------------------------------------------------------
int sub_80AB1DC()
{
  dword_85152C4 = 214013 * dword_85152C4 + 2531011;
  return (dword_85152C4 >> 16) & 0x7FFF;
}
// 85152C4: using guessed type int dword_85152C4;

//----- (080AB204) --------------------------------------------------------
long double __cdecl sub_80AB204(char *s1, int a2)
{
  int i; // [esp+14h] [ebp-4h]

  for ( i = 0; ; ++i )
  {
    if ( i > 31 )
      Com_Error(1, (char *)&byte_81467C0, a2, s1);
    if ( !strcasecmp(s1, (const char *)(68 * i + 139553768)) )
      break;
  }
  return dword_8516C28[17 * i];
}
// 8516C28: using guessed type float dword_8516C28[528];

//----- (080AB28A) --------------------------------------------------------
char *__cdecl sub_80AB28A(char *dest, char *src, char *s1)
{
  char *result; // eax

  strcpy(dest, src);
  dest[64] = 0;
  dest[128] = 0;
  *((_DWORD *)dest + 49) = 0;
  dest[200] = 0;
  *((_DWORD *)dest + 48) = 0;
  *((_DWORD *)dest + 67) = 1065353216;
  *((_DWORD *)dest + 68) = 1065353216;
  *((_DWORD *)dest + 69) = 1065353216;
  *((_DWORD *)dest + 70) = 1065353216;
  *((_DWORD *)dest + 71) = 1065353216;
  *((_DWORD *)dest + 72) = 1123024896;
  *((_DWORD *)dest + 73) = 0;
  *((_DWORD *)dest + 74) = 0;
  *((_DWORD *)dest + 75) = 1;
  dest[324] = 0;
  *((_DWORD *)dest + 78) = 1065353216;
  *((_DWORD *)dest + 79) = 0;
  dest[329] = 0;
  dest[330] = strcmp(s1, "menu") != 0;
  dest[325] = 0;
  dest[326] = 0;
  dest[327] = 0;
  dest[328] = 0;
  *((_DWORD *)dest + 77) = 1065353216;
  *((_DWORD *)dest + 80) = 0;
  *((_DWORD *)dest + 76) = sub_80AB112();
  result = dest;
  *((_DWORD *)dest + 84) = 0;
  return result;
}

//----- (080AB40A) --------------------------------------------------------
int __cdecl sub_80AB40A(char *a1)
{
  char *i; // [esp+Ch] [ebp+8h]

  if ( *a1 <= 31 || (*(_WORD *)(_ctype_b + 2 * *a1) & 8) == 0 && *a1 != 95 )
    return 0;
  for ( i = a1 + 1; *i; ++i )
  {
    if ( *i <= 31 || (*(_WORD *)(_ctype_b + 2 * *i) & 8) == 0 && *i != 95 )
      return 0;
  }
  return 1;
}
// 8185A64: using guessed type int _ctype_b;

//----- (080AB496) --------------------------------------------------------
int __cdecl sub_80AB496(char *a1, const char *a2, int a3)
{
  int result; // eax
  int v4; // eax
  int v5; // eax
  int v6; // eax
  char v7[16392]; // [esp+10h] [ebp-4018h] BYREF
  int v8; // [esp+4018h] [ebp-10h]
  int i; // [esp+401Ch] [ebp-Ch]

  for ( i = 0; i <= 10; ++i )
  {
    if ( !I_stricmp(a1, off_815DF00[i]) )
    {
      result = i;
      *(_DWORD *)(a3 + 296) = i;
      return result;
    }
  }
  v8 = 0;
  for ( i = 0; i <= 10; ++i )
  {
    v4 = sprintf(&v7[v8], "%s", off_815DF00[i]);
    v8 += v4;
    if ( i > 8 )
    {
      if ( i == 9 )
      {
        v6 = sprintf(&v7[v8], " or ");
        v8 += v6;
      }
    }
    else
    {
      v5 = sprintf(&v7[v8], ", ");
      v8 += v5;
    }
  }
  Com_Printf("^1ERROR: Sound alias file %s: Unknown sound channel '%s'; should be %s\n", a2, a1, v7);
  result = a3;
  *(_BYTE *)(a3 + 329) = 1;
  return result;
}
// 815DF00: using guessed type char *off_815DF00[13];
// 80AB496: using guessed type char var_4018[16392];
// 80AB496: using guessed type const char *arg_4;

//----- (080AB5B2) --------------------------------------------------------
int __cdecl sub_80AB5B2(char *a1, const char *a2, int a3)
{
  int result; // eax

  if ( I_stricmp(a1, "streamed") )
  {
    if ( I_stricmp(a1, "primed") )
    {
      if ( I_stricmp(a1, "loaded") )
      {
        Com_Printf(
          "^1ERROR: Sound alias file %s: Unknown sound type '%s'; should be primed, streamed or loaded\n",
          a2,
          a1);
        result = a3;
        *(_BYTE *)(a3 + 329) = 1;
      }
      else
      {
        result = a3;
        *(_DWORD *)(a3 + 300) = 1;
      }
    }
    else
    {
      result = a3;
      *(_DWORD *)(a3 + 300) = 2;
    }
  }
  else
  {
    result = a3;
    *(_DWORD *)(a3 + 300) = 2;
  }
  return result;
}
// 80AB5B2: using guessed type const char *arg_4;

//----- (080AB650) --------------------------------------------------------
int __cdecl sub_80AB650(char *a1, const char *a2, int a3)
{
  int result; // eax

  if ( I_stricmp(a1, "looping") )
  {
    if ( I_stricmp(a1, "nonlooping") )
    {
      Com_Printf(
        "^1ERROR: Sound alias file %s: Unknown sound looping type '%s'; should be looping or nonlooping\n",
        a2,
        a1);
      result = a3;
      *(_BYTE *)(a3 + 329) = 1;
    }
    else
    {
      result = a3;
      *(_BYTE *)(a3 + 324) = 0;
    }
  }
  else
  {
    result = a3;
    *(_BYTE *)(a3 + 324) = 1;
  }
  return result;
}
// 80AB650: using guessed type const char *arg_4;

//----- (080AB6C2) --------------------------------------------------------
int __cdecl sub_80AB6C2(char *s, char *s2, char *src, const char *a4)
{
  unsigned __int8 v5; // [esp+13h] [ebp-4025h]
  size_t v7; // [esp+1Ch] [ebp-401Ch]
  char dest[16383]; // [esp+20h] [ebp-4018h] BYREF
  char v9; // [esp+401Fh] [ebp-19h]
  char *haystack; // [esp+4028h] [ebp-10h]
  char *v11; // [esp+402Ch] [ebp-Ch]

  v7 = strlen(s);
  v9 = 0;
  strncpy(dest, src, 0x4000u);
  if ( v9 )
  {
    Com_Printf("^1ERROR: Sound alias file %s: loadspec is > %i characters\n", a4, 0x3FFF);
    return 0;
  }
  else
  {
    strlwr(dest);
    haystack = dest;
    v5 = 0;
    if ( dest[0] != 33 || !strcmp(s, "menu") )
      v5 = 1;
    while ( 1 )
    {
      v11 = strstr(haystack, s);
      if ( !v11 )
        break;
      if ( (v11 == dest || *(v11 - 1) <= 33) && v11[v7] <= 32 )
        return v5;
      haystack = v11 + 1;
    }
    if ( !strcmp(s, "menu") || strcmp(haystack, s2) )
      return v5 ^ 1;
    else
      return v5;
  }
}

//----- (080AB830) --------------------------------------------------------
void __cdecl sub_80AB830(char *s1, const char *a2, int a3)
{
  if ( !strcasecmp(s1, "master") )
  {
    *(_BYTE *)(a3 + 325) = 1;
    *(_BYTE *)(a3 + 326) = 0;
  }
  else
  {
    *(_BYTE *)(a3 + 325) = 0;
    *(_BYTE *)(a3 + 326) = 1;
    *(float *)(a3 + 308) = atof(s1);
    if ( *(float *)(a3 + 308) < 0.0 || *(float *)(a3 + 308) > 1.0 )
    {
      Com_Printf(
        "^1ERROR: Sound alias file %s: SlavePercentage'%f' is not within the range of '%f'-'%f'.\n",
        a2,
        *(float *)(a3 + 308),
        (double)0.0,
        (double)1.0);
      *(_BYTE *)(a3 + 329) = 1;
    }
  }
}
// 80AB830: using guessed type const char *arg_4;

//----- (080AB8F4) --------------------------------------------------------
char *__cdecl sub_80AB8F4(char *haystack, char *a2)
{
  char *result; // eax

  if ( strstr(haystack, "fulldrylevel") )
    a2[327] = 1;
  result = strstr(haystack, "nowetlevel");
  if ( result )
  {
    result = a2;
    a2[328] = 1;
  }
  return result;
}

//----- (080AB93E) --------------------------------------------------------
void __cdecl Com_LoadSoundAliasField(char *a1, char *s2, const char *a3, char *s, int a5, int a6, int a7)
{
  float v7; // [esp+28h] [ebp-10h]
  size_t i; // [esp+30h] [ebp-8h]

  if ( a5 )
  {
    if ( *(_BYTE *)(a6 + a5) )
    {
      Com_Printf(
        "^1ERROR: Sound alias file %s: Duplicate entries for the '%s' column\n",
        a3,
        (const char *)dword_815DEA0[a5]);
      *(_BYTE *)(a7 + 329) = 1;
    }
    else
    {
      *(_BYTE *)(a6 + a5) = 1;
      switch ( a5 )
      {
        case 1:
          if ( strlen(s) <= 0x3E )
          {
            if ( sub_80AB40A(s) )
            {
              strcpy((char *)(a7 + 64), s);
            }
            else
            {
              Com_Printf("^1ERROR: Sound alias file %s: Alias name '%s' is invalid\n", a3, s);
              *(_BYTE *)(a7 + 329) = 1;
            }
          }
          else
          {
            Com_Printf("^1ERROR: Sound alias file %s: Alias name '%s' is longer than %i characters\n", a3, s, 63);
            *(_BYTE *)(a7 + 329) = 1;
          }
          break;
        case 2:
          *(_DWORD *)(a7 + 196) = atoi(s);
          break;
        case 3:
          if ( strlen(s) <= 0x3E )
          {
            strcpy((char *)(a7 + 200), s);
          }
          else
          {
            Com_Printf("^1ERROR: Sound alias file %s: Sound file '%s' is longer than %i characters\n", a3, s, 63);
            *(_BYTE *)(a7 + 329) = 1;
          }
          break;
        case 4:
          for ( i = 0; s[i]; ++i )
          {
            if ( s[i] < 0 )
            {
              Com_Printf(
                "^1ERROR: Sound alias file %s: Subtitle '%s' has invalid character '%c' ascii %i\n",
                a3,
                s,
                s[i],
                (unsigned __int8)s[i]);
              *(_BYTE *)(a7 + 329) = 1;
              return;
            }
          }
          *(_DWORD *)(a7 + 192) = Hunk_AllocateTempMemoryInternal(i + 1);
          memcpy(*(void **)(a7 + 192), s, i);
          *(_BYTE *)(*(_DWORD *)(a7 + 192) + i) = 0;
          break;
        case 5:
          *(float *)(a7 + 268) = atof(s);
          if ( *(float *)(a7 + 268) >= 0.0 && *(float *)(a7 + 268) <= 1.0 )
          {
            if ( !*(_BYTE *)(a6 + 6) )
              *(_DWORD *)(a7 + 272) = *(_DWORD *)(a7 + 268);
          }
          else
          {
            Com_Printf(
              "^1ERROR: Sound alias file %s: MinVolume '%f' is not within the range of '%f'-'%f'.\n",
              a3,
              *(float *)(a7 + 268),
              (double)0.0,
              (double)1.0);
            *(_BYTE *)(a7 + 329) = 1;
          }
          break;
        case 6:
          *(float *)(a7 + 272) = atof(s);
          if ( *(float *)(a7 + 272) < 0.0 || *(float *)(a7 + 272) > 1.0 )
          {
            Com_Printf(
              "^1ERROR: Sound alias file %s: MaxVolume '%f' is not within the range of '%f'-'%f'.\n",
              a3,
              *(float *)(a7 + 272),
              (double)0.0,
              (double)1.0);
            *(_BYTE *)(a7 + 329) = 1;
          }
          break;
        case 7:
          *(float *)(a7 + 276) = sub_80AB204(s, (int)a3);
          break;
        case 8:
          *(float *)(a7 + 280) = atof(s);
          if ( !*(_BYTE *)(a6 + 9) )
            *(_DWORD *)(a7 + 284) = *(_DWORD *)(a7 + 280);
          break;
        case 9:
          *(float *)(a7 + 284) = atof(s);
          break;
        case 10:
          *(float *)(a7 + 288) = atof(s);
          break;
        case 11:
          *(float *)(a7 + 292) = atof(s);
          break;
        case 12:
          sub_80AB496(s, a3, a7);
          break;
        case 13:
          sub_80AB5B2(s, a3, a7);
          break;
        case 14:
          sub_80AB650(s, a3, a7);
          break;
        case 15:
          *(float *)(a7 + 312) = atof(s);
          break;
        case 16:
          *(_BYTE *)(a7 + 330) = sub_80AB6C2(a1, s2, s, a3);
          break;
        case 17:
          sub_80AB830(s, a3, a7);
          break;
        case 18:
          if ( strlen(s) <= 0x3E )
          {
            if ( sub_80AB40A(s) )
            {
              strcpy((char *)(a7 + 128), s);
            }
            else
            {
              Com_Printf("^1ERROR: Sound alias file %s: Secondary Alias name '%s' is invalid\n", a3, s);
              *(_BYTE *)(a7 + 329) = 1;
            }
          }
          else
          {
            Com_Printf(
              "^1ERROR: Sound alias file %s: Secondary Alias name '%s' is longer than %i characters\n",
              a3,
              s,
              63);
            *(_BYTE *)(a7 + 329) = 1;
          }
          break;
        case 19:
          *(_DWORD *)(a7 + 304) = sub_80AB104();
          break;
        case 20:
          *(_DWORD *)(a7 + 320) = atoi(s);
          break;
        case 22:
          sub_80AB8F4(s, (char *)a7);
          break;
        case 23:
          v7 = atof(s);
          *(float *)(a7 + 316) = sub_80AEE5E(v7, 0.0, 1.0);
          break;
        default:
          return;
      }
    }
  }
}
// 815DEA0: using guessed type int dword_815DEA0[];
// 80AB93E: using guessed type const char *arg_8;

//----- (080ABEF8) --------------------------------------------------------
int __cdecl sub_80ABEF8(int a1)
{
  float v3; // [esp+20h] [ebp-8h]
  float v4; // [esp+20h] [ebp-8h]
  int v5; // [esp+24h] [ebp-4h]
  int v6; // [esp+24h] [ebp-4h]

  if ( *(float *)(a1 + 280) > (long double)*(float *)(a1 + 284) )
  {
    v5 = *(_DWORD *)(a1 + 284);
    *(_DWORD *)(a1 + 284) = *(_DWORD *)(a1 + 280);
    *(_DWORD *)(a1 + 280) = v5;
  }
  if ( *(float *)(a1 + 280) > 0.0 )
  {
    if ( *(float *)(a1 + 268) > (long double)*(float *)(a1 + 272) )
    {
      v6 = *(_DWORD *)(a1 + 272);
      *(_DWORD *)(a1 + 272) = *(_DWORD *)(a1 + 268);
      *(_DWORD *)(a1 + 268) = v6;
    }
    if ( *(float *)(a1 + 268) >= 0.0 )
    {
      if ( *(float *)(a1 + 292) == 0.0 )
        *(float *)(a1 + 292) = *(float *)(a1 + 288) * 5.0;
      if ( *(float *)(a1 + 288) <= (long double)*(float *)(a1 + 292) )
      {
        if ( *(float *)(a1 + 288) > 0.0 )
        {
          if ( *(float *)(a1 + 276) != 1.0 )
          {
            v3 = *(float *)(a1 + 268) * *(float *)(a1 + 276);
            if ( v3 >= 0.0 )
            {
              if ( v3 > 1.0 )
                v3 = 1.0;
            }
            else
            {
              v3 = 0.0;
            }
            *(float *)(a1 + 268) = v3;
            v4 = *(float *)(a1 + 272) * *(float *)(a1 + 276);
            if ( v4 >= 0.0 )
            {
              if ( v4 > 1.0 )
                v4 = 1.0;
            }
            else
            {
              v4 = 0.0;
            }
            *(float *)(a1 + 272) = v4;
          }
          return 1;
        }
        else
        {
          Com_Printf("^1ERROR: sound alias '%s' has dist_min %g <= 0\n", (const char *)(a1 + 64), *(float *)(a1 + 288));
          return 0;
        }
      }
      else
      {
        Com_Printf(
          "^1ERROR: sound alias '%s' has dist_min %g <= dist_max %g\n",
          (const char *)(a1 + 64),
          *(float *)(a1 + 288),
          *(float *)(a1 + 292));
        return 0;
      }
    }
    else
    {
      Com_Printf("^1ERROR: sound alias '%s' has vol_min %g < 0\n", (const char *)(a1 + 64), *(float *)(a1 + 268));
      return 0;
    }
  }
  else
  {
    Com_Printf("^1ERROR: sound alias '%s' has pitch_min %g <= 0\n", (const char *)(a1 + 64), *(float *)(a1 + 280));
    return 0;
  }
}

//----- (080AC1A8) --------------------------------------------------------
int __cdecl sub_80AC1A8(_DWORD *a1)
{
  int result; // eax
  unsigned int v2; // [esp+10h] [ebp-18h]
  const void *v3; // [esp+14h] [ebp-14h]
  void *v4; // [esp+18h] [ebp-10h]
  int v5; // [esp+1Ch] [ebp-Ch]

  v5 = (int)sub_80AB11C(0x154u);
  v4 = (void *)v5;
  v3 = a1;
  v2 = 340;
  if ( (v5 & 4) != 0 )
  {
    *(_DWORD *)v5 = *a1;
    v4 = (void *)(v5 + 4);
    v3 = a1 + 1;
    v2 = 336;
  }
  qmemcpy(v4, v3, 4 * (v2 >> 2));
  *(_DWORD *)(v5 + 336) = dword_8516BE0;
  result = v5;
  dword_8516BE0 = v5;
  ++dword_8516BE4;
  return result;
}
// 8516BE0: using guessed type int dword_8516BE0;
// 8516BE4: using guessed type int dword_8516BE4;

//----- (080AC22C) --------------------------------------------------------
void sub_80AC22C()
{
  dword_8516BE0 = 0;
  dword_8516BE4 = 0;
}
// 8516BE0: using guessed type int dword_8516BE0;
// 8516BE4: using guessed type int dword_8516BE4;

//----- (080AC246) --------------------------------------------------------
_DWORD *__cdecl Com_LoadSoundAliasFile(int a1)
{
  int i; // [esp+2Ch] [ebp-206Ch]
  unsigned int n; // [esp+30h] [ebp-2068h]
  char *src; // [esp+38h] [ebp-2060h]
  char *srca; // [esp+38h] [ebp-2060h]
  char *v6; // [esp+3Ch] [ebp-205Ch] BYREF
  char s1[8200]; // [esp+40h] [ebp-2058h] BYREF
  int v8; // [esp+2048h] [ebp-50h] BYREF
  int v9; // [esp+204Ch] [ebp-4Ch]
  char dest[72]; // [esp+2050h] [ebp-48h] BYREF

  n = strlen("VOLUMEMODGROUPS");
  strcpy(dest, "soundaliases/volumemodgroups.def");
  v9 = FS_FOpenFileRead(dest, &v8, 1);
  if ( v9 < 0 )
    Com_Error(1, "ERROR: Could not find '%s'\n", dest);
  if ( !v9 )
  {
    FS_FCloseFile(v8);
    Com_Error(1, "ERROR: '%s' is empty\n", dest);
  }
  FS_Read((int)s1, n, v8);
  s1[n] = 0;
  if ( strncmp(s1, "VOLUMEMODGROUPS", n) )
  {
    FS_FCloseFile(v8);
    Com_Error(1, "ERROR: \"%s\" does not appear to be a volumemodgroups file\n", dest);
  }
  if ( (int)(v9 - n) > 0x1FFF )
  {
    FS_FCloseFile(v8);
    Com_Error(1, "ERROR: \"%s\" Is too long of a volumemodgroups file to parse\n", dest);
  }
  memset(s1, 0, 0x2000u);
  FS_Read((int)s1, v9 - n, v8);
  s1[v9 - n] = 0;
  FS_FCloseFile(v8);
  Com_BeginParseSession(dest);
  v6 = s1;
  for ( i = 0; ; ++i )
  {
    src = Com_Parse(&v6);
    if ( !*src || *src == 125 )
      break;
    if ( i > 31 )
    {
      Com_EndParseSession();
      Com_Error(
        1,
        "ERROR: volumemodgroups parse failure on file \"%s\": groups parsed (%d) is greater than or equal to maxGroups(%d)\n",
        dest,
        i,
        32);
    }
    strcpy((char *)(a1 + 68 * i), src);
    srca = Com_Parse(&v6);
    if ( !*srca || *srca == 125 )
    {
      Com_EndParseSession();
      Com_Error(
        1,
        "ERROR: volumemodgroups parse failure on file \"%s\": groupname '%s' missing a matching value\n",
        dest,
        (const char *)(a1 + 68 * i));
    }
    *(float *)(a1 + 68 * i + 64) = atof(srca);
  }
  return Com_EndParseSession();
}
// 80AC246: using guessed type char s1[8200];

//----- (080AC576) --------------------------------------------------------
void sub_80AC576()
{
  byte_8517468 = 0;
}
// 8517468: using guessed type char byte_8517468;

//----- (080AC582) --------------------------------------------------------
_DWORD *__cdecl sub_80AC582(char *s1, char *s2, char *src)
{
  _DWORD *result; // eax
  int v4; // [esp+28h] [ebp-5F0h]
  int v5; // [esp+2Ch] [ebp-5ECh]
  char s[32]; // [esp+30h] [ebp-5E8h] BYREF
  char v7[64]; // [esp+50h] [ebp-5C8h] BYREF
  char dest[352]; // [esp+90h] [ebp-588h] BYREF
  int v9[259]; // [esp+1F0h] [ebp-428h]
  int v10; // [esp+5FCh] [ebp-1Ch]
  int i; // [esp+600h] [ebp-18h]
  char *v12; // [esp+604h] [ebp-14h]
  char *v13; // [esp+608h] [ebp-10h] BYREF
  char *v14; // [esp+60Ch] [ebp-Ch] BYREF

  Com_sprintf(v7, 0x40u, "soundaliases/%s", src);
  result = (_DWORD *)FS_ReadFile(v7, &v14);
  if ( (int)result >= 0 )
  {
    if ( !byte_8517468 )
    {
      if ( !byte_8517469 )
      {
        Cmd_AddCommand("snd_refreshVolumeModGroups", (int)sub_80AC576);
        byte_8517469 = 1;
      }
      Com_LoadSoundAliasFile((int)&unk_8516BE8);
      byte_8517468 = 1;
    }
    Com_BeginParseSession(v7);
    sub_80B3B00(1);
    v13 = v14;
    v10 = 0;
    while ( 1 )
    {
      v12 = Com_Parse(&v13);
      if ( !v13 )
        return Com_EndParseSession();
      if ( *v12 && *v12 != 35 )
      {
        if ( v10 )
        {
          memset(s, 0, 0x18u);
          sub_80AB28A(dest, src, s1);
          i = 0;
          while ( 1 )
          {
            if ( *v12 )
              Com_LoadSoundAliasField(s1, s2, src, v12, v9[i], (int)s, (int)dest);
            if ( ++i == v10 )
              break;
            v12 = Com_ParseOnLine(&v13);
          }
          if ( !s[1] || !s[3] )
          {
            Com_Printf("^1ERROR: Sound alias file %s: alias entry missing name and/or file\n", src);
            return Com_EndParseSession();
          }
          if ( dest[330] && !dest[329] && (unsigned __int8)sub_80ABEF8((int)dest) )
            sub_80AC1A8(dest);
        }
        else
        {
          v5 = 0;
          v4 = 0;
          while ( 2 )
          {
            v9[v10] = 0;
            for ( i = 1; i <= 23; ++i )
            {
              if ( !I_stricmp((char *)dword_815DEA0[i], v12) )
              {
                v9[v10] = i;
                if ( i == 1 )
                {
                  v5 = 1;
                }
                else if ( i == 3 )
                {
                  v4 = 1;
                }
                break;
              }
            }
            if ( ++v10 != 256 && v13 && *v13 != 10 )
            {
              v12 = Com_ParseOnLine(&v13);
              continue;
            }
            break;
          }
          if ( !v5 || !v4 )
          {
            Com_Printf("^1ERROR: Sound alias file %s: missing 'name' and/or 'file' columns\n", src);
            return Com_EndParseSession();
          }
        }
      }
      Com_SkipRestOfLine(&v13);
    }
  }
  return result;
}
// 815DEA0: using guessed type int dword_815DEA0[];
// 8517468: using guessed type char byte_8517468;
// 8517469: using guessed type char byte_8517469;
// 80AC582: using guessed type int var_428[259];

//----- (080AC880) --------------------------------------------------------
int __cdecl sub_80AC880(int a1, int a2)
{
  return I_stricmp((char *)(a1 + 64), (char *)(a2 + 64));
}

//----- (080AC8A0) --------------------------------------------------------
int __cdecl sub_80AC8A0(int a1, _DWORD *a2, int (__cdecl *a3)(char *, char *), unsigned __int8 a4)
{
  int v4; // eax
  int v7; // [esp+1Ch] [ebp-1Ch]
  int v8; // [esp+1Ch] [ebp-1Ch]
  int v9; // [esp+1Ch] [ebp-1Ch]
  int v10; // [esp+20h] [ebp-18h] BYREF
  int v11; // [esp+24h] [ebp-14h] BYREF
  char **v12; // [esp+28h] [ebp-10h]
  char *v13; // [esp+2Ch] [ebp-Ch]
  char *v14; // [esp+30h] [ebp-8h]
  unsigned __int8 v15; // [esp+37h] [ebp-1h]

  v15 = a4;
  if ( *a2 == 1 )
  {
    *(_DWORD *)(a1 + 336) = 0;
    return a1;
  }
  else
  {
    v11 = *a2 / 2;
    v10 = *a2 - v11;
    v7 = 0;
    v13 = (char *)a1;
    while ( v7 < v11 )
    {
      ++v7;
      v13 = (char *)*((_DWORD *)v13 + 84);
    }
    v14 = (char *)sub_80AC8A0(a1, &v11, a3, v15);
    v13 = (char *)sub_80AC8A0(v13, &v10, a3, v15);
    *a2 = 0;
    a1 = 0;
    v12 = (char **)&a1;
    while ( v11 && v10 )
    {
      v8 = a3(v14, v13);
      if ( !v15 || v8 || (v8 = *((_DWORD *)v14 + 49) - *((_DWORD *)v13 + 49)) != 0 )
      {
        if ( v8 > 0 )
        {
          *v12 = v13;
          v13 = (char *)*((_DWORD *)v13 + 84);
          --v10;
        }
        else
        {
          *v12 = v14;
          v14 = (char *)*((_DWORD *)v14 + 84);
          --v11;
        }
        ++*a2;
        v12 = (char **)(*v12 + 336);
      }
      else
      {
        v9 = I_stricmp(v14, v13);
        if ( v9 )
        {
          if ( v9 >= 0 )
          {
            v13 = (char *)*((_DWORD *)v13 + 84);
            --v10;
          }
          else
          {
            v14 = (char *)*((_DWORD *)v14 + 84);
            --v11;
          }
        }
        else
        {
          Com_Printf("^1ERROR: sound alias file %s: duplicate alias '%s'\n", v14, v14 + 64);
          v14 = (char *)*((_DWORD *)v14 + 84);
          --v11;
          v13 = (char *)*((_DWORD *)v13 + 84);
          --v10;
        }
      }
    }
    if ( v11 )
    {
      *v12 = v14;
      v4 = *a2 + v11;
    }
    else
    {
      *v12 = v13;
      v4 = *a2 + v10;
    }
    *a2 = v4;
    return a1;
  }
}
// 80AC8A0: using guessed type const char *var_8;

//----- (080ACAF4) --------------------------------------------------------
int __cdecl sub_80ACAF4(int a1, int a2)
{
  int v4; // [esp+14h] [ebp-4h]

  v4 = I_stricmp((char *)(a1 + 200), (char *)(a2 + 200));
  if ( v4 )
    return v4;
  if ( *(_DWORD *)(a1 + 300) == *(_DWORD *)(a2 + 300) )
    return sub_80AC880(a1, a2);
  return *(_DWORD *)(a1 + 300) - *(_DWORD *)(a2 + 300);
}

//----- (080ACB66) --------------------------------------------------------
void __cdecl sub_80ACB66(int a1, int a2)
{
  int v2; // [esp+1Ch] [ebp-1Ch]
  int v3; // [esp+20h] [ebp-18h]
  const char *v4; // [esp+34h] [ebp-4h]

  v3 = *(_DWORD *)(a1 + 300);
  if ( v3 == 2 )
  {
    v4 = "streamed";
  }
  else if ( v3 > 2 && v3 == 3 )
  {
    v4 = "primed";
  }
  else
  {
    v4 = "loaded";
  }
  v2 = *(_DWORD *)(a2 + 300);
  if ( v2 == 2 )
  {
    Com_Printf(
      "WARNING: sound file '%s' used as %s in alias '%s' and %s in alias '%s'\n",
      (const char *)(a1 + 200),
      v4,
      (const char *)(a1 + 64),
      "streamed",
      (const char *)(a2 + 64));
  }
  else if ( v2 > 2 && v2 == 3 )
  {
    Com_Printf(
      "WARNING: sound file '%s' used as %s in alias '%s' and %s in alias '%s'\n",
      (const char *)(a1 + 200),
      v4,
      (const char *)(a1 + 64),
      "primed",
      (const char *)(a2 + 64));
  }
  else
  {
    Com_Printf(
      "WARNING: sound file '%s' used as %s in alias '%s' and %s in alias '%s'\n",
      (const char *)(a1 + 200),
      v4,
      (const char *)(a1 + 64),
      "loaded",
      (const char *)(a2 + 64));
  }
}

//----- (080ACC2E) --------------------------------------------------------
int __cdecl sub_80ACC2E(_DWORD *a1, int a2, int a3)
{
  int result; // eax

  *a1 = a2;
  a1[1] = 0;
  result = a3;
  a1[3] = a3;
  return result;
}

//----- (080ACC4E) --------------------------------------------------------
int __cdecl sub_80ACC4E(int a1, int a2, int a3, int a4, int a5)
{
  size_t v5; // eax
  unsigned int v6; // edx
  unsigned int v7; // edx
  unsigned int v8; // edx
  unsigned int v9; // edx
  unsigned int v10; // edx
  int result; // eax

  *(_DWORD *)a2 = a3;
  if ( *(_BYTE *)(a1 + 128) )
  {
    v5 = strlen((const char *)(a1 + 128));
    *(_DWORD *)(a2 + 8) = sub_80AB130(v5 + 1);
    strcpy(*(char **)(a2 + 8), (const char *)(a1 + 128));
  }
  else
  {
    *(_DWORD *)(a2 + 8) = 0;
  }
  *(_DWORD *)(a2 + 12) = a4;
  *(_DWORD *)(a2 + 4) = a5;
  *(_DWORD *)(a2 + 16) = 0;
  *(_DWORD *)(a2 + 20) = *(_DWORD *)(a1 + 268);
  *(_DWORD *)(a2 + 24) = *(_DWORD *)(a1 + 272);
  *(_DWORD *)(a2 + 28) = *(_DWORD *)(a1 + 280);
  *(_DWORD *)(a2 + 32) = *(_DWORD *)(a1 + 284);
  *(_DWORD *)(a2 + 36) = *(_DWORD *)(a1 + 288);
  *(_DWORD *)(a2 + 40) = *(_DWORD *)(a1 + 292);
  *(_DWORD *)(a2 + 44) = *(_DWORD *)(a2 + 44) & 0xFFFFF87F | (*(_DWORD *)(a1 + 296) << 7);
  *(_DWORD *)(a2 + 44) = *(_DWORD *)(a2 + 44) & 0xFFFFFF9F | (32 * *(_DWORD *)(a1 + 300));
  *(_DWORD *)(a2 + 64) = *(_DWORD *)(a1 + 304);
  if ( *(_BYTE *)(a1 + 324) )
    v6 = *(_DWORD *)(a2 + 44) | 1;
  else
    v6 = *(_DWORD *)(a2 + 44) & 0xFFFFFFFE;
  *(_DWORD *)(a2 + 44) = v6;
  if ( *(_BYTE *)(a1 + 325) )
    v7 = *(_DWORD *)(a2 + 44) | 2;
  else
    v7 = *(_DWORD *)(a2 + 44) & 0xFFFFFFFD;
  *(_DWORD *)(a2 + 44) = v7;
  if ( *(_BYTE *)(a1 + 326) )
    v8 = *(_DWORD *)(a2 + 44) | 4;
  else
    v8 = *(_DWORD *)(a2 + 44) & 0xFFFFFFFB;
  *(_DWORD *)(a2 + 44) = v8;
  if ( *(_BYTE *)(a1 + 327) )
    v9 = *(_DWORD *)(a2 + 44) | 8;
  else
    v9 = *(_DWORD *)(a2 + 44) & 0xFFFFFFF7;
  *(_DWORD *)(a2 + 44) = v9;
  if ( *(_BYTE *)(a1 + 328) )
    v10 = *(_DWORD *)(a2 + 44) | 0x10;
  else
    v10 = *(_DWORD *)(a2 + 44) & 0xFFFFFFEF;
  *(_DWORD *)(a2 + 44) = v10;
  *(_DWORD *)(a2 + 48) = *(_DWORD *)(a1 + 308);
  *(_DWORD *)(a2 + 52) = *(_DWORD *)(a1 + 312);
  *(_DWORD *)(a2 + 56) = *(_DWORD *)(a1 + 316);
  result = *(_DWORD *)(a1 + 320);
  *(_DWORD *)(a2 + 60) = result;
  return result;
}

//----- (080ACE9A) --------------------------------------------------------
int __cdecl sub_80ACE9A(int a1, _DWORD *a2)
{
  int result; // eax
  char v3; // [esp+16h] [ebp-42h]
  char v4; // [esp+17h] [ebp-41h]
  int v5; // [esp+18h] [ebp-40h]
  void *v6; // [esp+1Ch] [ebp-3Ch]
  int v7; // [esp+20h] [ebp-38h]
  char v8; // [esp+27h] [ebp-31h]
  _DWORD *v9; // [esp+28h] [ebp-30h]
  int v10; // [esp+2Ch] [ebp-2Ch]
  size_t v11; // [esp+30h] [ebp-28h]
  size_t v12; // [esp+34h] [ebp-24h]
  size_t v13; // [esp+34h] [ebp-24h]
  char *v14; // [esp+38h] [ebp-20h]
  int v15; // [esp+40h] [ebp-18h]
  int i; // [esp+44h] [ebp-14h]
  int j; // [esp+44h] [ebp-14h]
  int k; // [esp+44h] [ebp-14h]
  char *s; // [esp+48h] [ebp-10h]
  char *v20; // [esp+4Ch] [ebp-Ch]
  char *dest; // [esp+50h] [ebp-8h]
  char *desta; // [esp+50h] [ebp-8h]
  char *destb; // [esp+50h] [ebp-8h]

  *a2 = 0;
  result = a1;
  *(_DWORD *)(a1 + 8) = 0;
  if ( dword_8516BE4 )
  {
    result = sub_80AC8A0(dword_8516BE0, &dword_8516BE4, (int (__cdecl *)(char *, char *))sub_80AC880, 1u);
    dword_8516BE0 = result;
    if ( result )
    {
      result = sub_80AC8A0(dword_8516BE0, &dword_8516BE4, (int (__cdecl *)(char *, char *))sub_80ACAF4, 0);
      dword_8516BE0 = result;
      if ( result )
      {
        v11 = 0;
        v10 = 0;
        v15 = 0;
        dest = 0;
        v5 = 0;
        for ( i = dword_8516BE0; i; i = *(_DWORD *)(i + 336) )
        {
          v12 = strlen((const char *)(i + 200)) + 1;
          v4 = 0;
          if ( v15 && *(_DWORD *)(i + 300) == *(_DWORD *)(v15 + 300) )
            v4 = 1;
          v3 = 0;
          if ( dest && !I_stricmp(dest, (char *)(i + 200)) )
            v3 = 1;
          v8 = 0;
          if ( v3 && v4 )
            v8 = 1;
          if ( dest && v8 )
          {
            v10 += v12;
            *(_DWORD *)(i + 332) = v15;
          }
          else
          {
            if ( v3 )
            {
              if ( !v4 )
                sub_80ACB66(i, v15);
            }
            v15 = i;
            dest = (char *)(i + 200);
            *(_DWORD *)(i + 332) = 0;
            v11 += v12;
            ++v5;
          }
        }
        result = sub_80AC8A0(dword_8516BE0, &dword_8516BE4, (int (__cdecl *)(char *, char *))sub_80AC880, 1u);
        dword_8516BE0 = result;
        if ( result )
        {
          desta = 0;
          for ( j = dword_8516BE0; j; j = *(_DWORD *)(j + 336) )
          {
            v13 = strlen((const char *)(j + 64)) + 1;
            if ( desta && !I_stricmp(desta, (char *)(j + 64)) )
            {
              v10 += v13;
            }
            else
            {
              v11 += v13;
              desta = (char *)(j + 64);
            }
            if ( *(_DWORD *)(j + 192) )
              v11 += strlen(*(const char **)(j + 192)) + 1;
          }
          *(_DWORD *)(a1 + 4) = sub_80AB130(68 * dword_8516BE4);
          a2[1] = sub_80AB130(16 * v5);
          v14 = (char *)sub_80AB130(v11);
          destb = 0;
          v6 = 0;
          result = dword_8516BE0;
          for ( k = dword_8516BE0; ; k = result )
          {
            if ( !k )
              return result;
            if ( !destb || I_stricmp(destb, (char *)(k + 64)) )
            {
              destb = v14;
              strcpy(v14, (const char *)(k + 64));
              v14 += strlen(v14) + 1;
            }
            if ( *(_DWORD *)(k + 192) )
            {
              s = v14;
              strcpy(v14, *(const char **)(k + 192));
              v14 += strlen(v14) + 1;
            }
            else
            {
              s = 0;
            }
            v7 = *(_DWORD *)(a1 + 4) + 68 * *(_DWORD *)(a1 + 8);
            if ( !v6 || I_stricmp(**((char ***)v6 + 1), destb) )
            {
              v6 = sub_80AB130(0x10u);
              if ( !(unsigned __int8)sub_80AAA06(destb, (int)v6) )
              {
                v6 = 0;
                Com_Printf("^1ERROR: alias '%s' already added - ignoring\n", destb);
                goto LABEL_50;
              }
              *(_DWORD *)v6 = destb;
              *((_DWORD *)v6 + 1) = v7;
            }
            if ( *(_DWORD *)(k + 332) )
            {
              v9 = *(_DWORD **)(*(_DWORD *)(k + 332) + 264);
            }
            else
            {
              v20 = v14;
              strcpy(v14, (const char *)(k + 200));
              v14 += strlen(v14) + 1;
              v9 = (_DWORD *)(a2[1] + 16 * *a2);
              sub_80ACC2E(v9, (int)v20, *(_DWORD *)(k + 300));
              ++*a2;
            }
            *(_DWORD *)(k + 264) = v9;
            sub_80ACC4E(k, v7, (int)destb, (int)v9, (int)s);
            ++*(_DWORD *)(a1 + 8);
            ++*((_DWORD *)v6 + 2);
LABEL_50:
            result = *(_DWORD *)(k + 336);
          }
        }
      }
    }
  }
  return result;
}
// 8516BE0: using guessed type int dword_8516BE0;
// 8516BE4: using guessed type int dword_8516BE4;

//----- (080AD3E6) --------------------------------------------------------
int __cdecl sub_80AD3E6(char *a1, char *src, float *a3)
{
  float *v3; // ebx
  float *v4; // esi
  float *v5; // esi
  int i; // [esp+18h] [ebp-10h]
  int v9; // [esp+18h] [ebp-10h]
  const char *nptrb; // [esp+1Ch] [ebp-Ch]
  char *nptr; // [esp+1Ch] [ebp-Ch]
  char *nptra; // [esp+1Ch] [ebp-Ch]

  Com_BeginParseSession(src);
  nptrb = Com_Parse(&a1);
  v3 = a3;
  *((_DWORD *)v3 + 1) = atoi(nptrb);
  if ( *((int *)a3 + 1) > 1 )
  {
    if ( *((int *)a3 + 1) <= 8 )
    {
      for ( i = 0; ; ++i )
      {
        nptr = Com_Parse(&a1);
        if ( !*nptr || *nptr == 125 )
          break;
        if ( i > 7 )
        {
          Com_EndParseSession();
          Com_Printf(
            "^1ERROR: sndcurve parse failure on file \"%s\": knots parsed (%d) is greater than or equal to maxKnots (%d)\n",
            src,
            i,
            8);
          return 0;
        }
        v4 = a3;
        v4[2 * i + 2] = atof(nptr);
        if ( a3[2 * i + 2] < 0.0 || a3[2 * i + 2] > 1.0 )
        {
          Com_EndParseSession();
          Com_Printf(
            "^1ERROR: sndcurve parse failure on file \"%s\": knot x-coord '%f' is not in the range 0-1.\n",
            src,
            a3[2 * i + 2]);
          return 0;
        }
        nptra = Com_Parse(&a1);
        if ( !*nptra || *nptra == 125 )
          break;
        v5 = a3;
        v5[2 * i + 3] = atof(nptra);
        if ( a3[2 * i + 3] < 0.0 || a3[2 * i + 3] > 1.0 )
        {
          Com_EndParseSession();
          Com_Printf(
            "^1ERROR: sndcurve parse failure on file \"%s\": knot x-coord '%f' is not in the range 0-1.\n",
            src,
            a3[2 * i + 3]);
          return 0;
        }
      }
      Com_EndParseSession();
      if ( i == *((_DWORD *)a3 + 1) )
      {
        v9 = i - 1;
        if ( a3[2] != 0.0 || a3[3] != 1.0 || a3[2 * v9 + 2] != 1.0 || a3[2 * v9 + 3] != 0.0 )
        {
          a3[2] = 0.0;
          a3[3] = 1.0;
          a3[2 * v9 + 2] = 1.0;
          a3[2 * v9 + 3] = 0.0;
          Com_Printf(
            "^3WARNING^7: sndcurve parse on file \"%s\": the first point must be '0.0000 1.0000' and the last point must "
            "be '1.0000 0.0000'.\n"
            "adjusting sndcurve endpoints.\n",
            src);
        }
        return 1;
      }
      else
      {
        Com_Printf(
          "^1ERROR: sndcurve parse failure on file \"%s\": knot count (%d) does not match knots parsed (%d).\n",
          src,
          *((_DWORD *)a3 + 1),
          i);
        return 0;
      }
    }
    else
    {
      Com_EndParseSession();
      Com_Printf(
        "^1ERROR: sndcurve parse failure on file \"%s\": knot count (%d) is greater than maxKnots (%d)\n",
        src,
        *((_DWORD *)a3 + 1),
        8);
      return 0;
    }
  }
  else
  {
    Com_EndParseSession();
    Com_Printf(
      "^1ERROR: sndcurve parse failure on file \"%s\": knot count (%d) is less than 2\n",
      src,
      *((_DWORD *)a3 + 1));
    return 0;
  }
}

//----- (080AD6F6) --------------------------------------------------------
int __cdecl sub_80AD6F6(const char *a1, float *a2)
{
  unsigned int n; // [esp+18h] [ebp-2060h]
  char s1[8200]; // [esp+20h] [ebp-2058h] BYREF
  int v6; // [esp+2028h] [ebp-50h] BYREF
  int v7; // [esp+202Ch] [ebp-4Ch]
  char v8[72]; // [esp+2030h] [ebp-48h] BYREF

  n = strlen("SNDCURVE");
  Com_sprintf(v8, 0x40u, "soundaliases/%s.vfcurve", a1);
  v7 = FS_FOpenFileRead(v8, &v6, 1);
  if ( v7 >= 0 )
  {
    if ( v7 )
    {
      FS_Read((int)s1, n, v6);
      s1[n] = 0;
      if ( !strncmp(s1, "SNDCURVE", n) )
      {
        if ( (int)(v7 - n) <= 0x1FFF )
        {
          memset(s1, 0, 0x2000u);
          FS_Read((int)s1, v7 - n, v6);
          s1[v7 - n] = 0;
          FS_FCloseFile(v6);
          if ( (unsigned __int8)sub_80AD3E6(s1, v8, a2) )
          {
            *(_DWORD *)a2 = a1;
            return 1;
          }
          else
          {
            return 0;
          }
        }
        else
        {
          FS_FCloseFile(v6);
          Com_Printf("^1ERROR: \"%s\" Is too long of a sndcurve file to parse\n", v8);
          return 0;
        }
      }
      else
      {
        FS_FCloseFile(v6);
        Com_Printf("^1ERROR: \"%s\" does not appear to be a sndcurve file\n", v8);
        return 0;
      }
    }
    else
    {
      FS_FCloseFile(v6);
      Com_Printf("^1ERROR: sndcurve file '%s' is empty\n", v8);
      return 0;
    }
  }
  else
  {
    Com_Printf("^1ERROR: Could not load sndcurve file '%s'\n", v8);
    return 0;
  }
}
// 80AD6F6: using guessed type const char *arg_0;
// 80AD6F6: using guessed type char s1[8200];

//----- (080AD920) --------------------------------------------------------
_DWORD *__cdecl sub_80AD920(_DWORD *a1)
{
  _DWORD *result; // eax

  *a1 = &byte_8147777;
  a1[2] = 0;
  a1[3] = 1065353216;
  a1[4] = 1065353216;
  a1[5] = 0;
  result = a1;
  a1[1] = 2;
  return result;
}

//----- (080AD964) --------------------------------------------------------
int __cdecl sub_80AD964(char *a1)
{
  int v3; // [esp+18h] [ebp-10h]
  const char *s1; // [esp+1Ch] [ebp-Ch]
  char *s1a; // [esp+1Ch] [ebp-Ch]
  char *i; // [esp+20h] [ebp-8h] BYREF
  char *v7; // [esp+24h] [ebp-4h] BYREF

  v3 = 0;
  if ( I_strncmp(a1, "SUBTITLE_", 9) )
    return 0;
  if ( FS_ReadFile("soundaliases/subtitle.st", &v7) >= 0 )
  {
    Com_BeginParseSession("soundaliases/subtitle.st");
    for ( i = v7; ; Com_SkipRestOfLine(&i) )
    {
      s1 = Com_Parse(&i);
      if ( !i )
        break;
      if ( !strcmp(s1, "REFERENCE") )
      {
        s1a = Com_ParseOnLine(&i);
        if ( !I_stricmp(a1 + 9, s1a) )
        {
          v3 = 1;
          break;
        }
      }
    }
    Com_EndParseSession();
    FS_FreeFile(v7);
    return v3;
  }
  else
  {
    Com_Printf("WARNING: Could not read local copy of StringEd file %s\n", "soundaliases/subtitle.st");
    return 0;
  }
}

//----- (080ADA6A) --------------------------------------------------------
char *__cdecl Com_GetSubtitleStringEdReference(char *a1)
{
  const char *s1; // [esp+1Ch] [ebp-Ch]
  const char *s1b; // [esp+1Ch] [ebp-Ch]
  const char *s1a; // [esp+1Ch] [ebp-Ch]
  char *s1c; // [esp+1Ch] [ebp-Ch]
  char *i; // [esp+20h] [ebp-8h] BYREF
  char *v8; // [esp+24h] [ebp-4h] BYREF

  if ( FS_ReadFile("soundaliases/subtitle.st", &v8) >= 0 )
  {
    Com_BeginParseSession("soundaliases/subtitle.st");
    for ( i = v8; ; Com_SkipRestOfLine(&i) )
    {
      s1 = Com_Parse(&i);
      if ( !i )
        break;
      if ( !strcmp(s1, "REFERENCE") )
      {
        s1b = Com_ParseOnLine(&i);
        strcpy(byte_8517480, s1b);
        Com_SkipRestOfLine(&i);
        do
        {
          s1a = Com_Parse(&i);
          if ( !i )
            Com_Error(1, (char *)&byte_8147800, "soundaliases/subtitle.st");
        }
        while ( strcmp(s1a, "LANG_ENGLISH") );
        s1c = Com_ParseOnLine(&i);
        if ( !I_stricmp(a1, s1c) )
        {
          Com_EndParseSession();
          FS_FreeFile(v8);
          return byte_8517480;
        }
      }
    }
    Com_EndParseSession();
    FS_FreeFile(v8);
    return 0;
  }
  else
  {
    Com_Printf("WARNING: Could not read local copy of StringEd file %s\n", "soundaliases/subtitle.st");
    return 0;
  }
}

//----- (080ADBCA) --------------------------------------------------------
size_t __cdecl Com_WriteStringEdReferenceToFile(char *a1, char *a2, int a3)
{
  size_t v3; // eax
  size_t v4; // eax
  size_t v5; // eax
  size_t v6; // eax
  size_t v7; // eax

  v3 = strlen("REFERENCE           ");
  FS_Write("REFERENCE           ", v3, a3);
  v4 = strlen(a1);
  FS_Write(a1, v4, a3);
  v5 = strlen("\r\nLANG_ENGLISH        \"");
  FS_Write("\r\nLANG_ENGLISH        \"", v5, a3);
  v6 = strlen(a2);
  FS_Write(a2, v6, a3);
  v7 = strlen("\"\r\n\r\n");
  return FS_Write("\"\r\n\r\n", v7, a3);
}

//----- (080ADC96) --------------------------------------------------------
void __cdecl sub_80ADC96(int a1, char *a2)
{
  size_t v2; // eax
  int v3; // [esp+1Ch] [ebp-22Ch]
  int v4; // [esp+20h] [ebp-228h]
  char *v5; // [esp+24h] [ebp-224h]
  const char *s1; // [esp+28h] [ebp-220h]
  const char *s1b; // [esp+28h] [ebp-220h]
  const char *s1a; // [esp+28h] [ebp-220h]
  char *s2; // [esp+2Ch] [ebp-21Ch]
  char dest[256]; // [esp+30h] [ebp-218h] BYREF
  char filename[260]; // [esp+130h] [ebp-118h] BYREF
  char *v12; // [esp+234h] [ebp-14h] BYREF
  char *v13; // [esp+238h] [ebp-10h] BYREF
  char *v14; // [esp+23Ch] [ebp-Ch]

  v3 = 0;
  s2 = (char *)(a1 + 9);
  v4 = FS_FOpenFileWrite("soundaliases/temp.st");
  if ( v4 )
  {
    if ( FS_ReadFile("soundaliases/subtitle.st", &v13) >= 0 )
    {
      Com_BeginParseSession("soundaliases/subtitle.st");
      v12 = v13;
      v5 = v13;
      while ( 1 )
      {
        s1 = Com_Parse(&v12);
        if ( !v12 )
          break;
        if ( !strcmp(s1, "ENDMARKER") )
        {
          if ( v5 < v12 )
          {
            v14 = (char *)(v12 - v5 - 11);
            FS_Write(v5, (size_t)v14, v4);
          }
          break;
        }
        if ( !strcmp(s1, "REFERENCE") )
        {
          s1b = Com_ParseOnLine(&v12);
          if ( !strcmp(s1b, s2) )
          {
            if ( v5 < v12 )
            {
              v14 = (char *)(v12 - v5);
              FS_Write(v5, v12 - v5, v4);
            }
            Com_WriteStringEdReferenceToFile(s2, a2, v4);
            v3 = 1;
            do
            {
              v5 = v12;
              s1a = Com_Parse(&v12);
              if ( !v12 )
              {
                v5 = 0;
                goto LABEL_20;
              }
            }
            while ( strcmp(s1a, "REFERENCE") && strcmp(s1a, "ENDMARKER") );
            Com_UngetToken();
          }
        }
LABEL_20:
        Com_SkipRestOfLine(&v12);
      }
      if ( !v3 )
        Com_WriteStringEdReferenceToFile(s2, a2, v4);
      Com_EndParseSession();
      FS_FreeFile(v13);
      v2 = strlen("\r\nENDMARKER\r\n\r\n\r\n");
      FS_Write("\r\nENDMARKER\r\n\r\n\r\n", v2, v4);
      FS_FCloseFile(v4);
      FS_BuildOSPath(*(char **)(fs_basepath + 8), byte_848B6C0, "soundaliases/temp.st", filename);
      FS_BuildOSPath(*(char **)(fs_basepath + 8), byte_848B6C0, "soundaliases/subtitle.st", dest);
      FS_CopyFile(filename, dest);
      sub_809CACA(filename);
    }
    else
    {
      Com_Printf("WARNING: Could not read local copy of StringEd file %s\n", "soundaliases/subtitle.st");
      FS_FCloseFile(v4);
    }
  }
  else
  {
    Com_Printf("WARNING: Could not open output file %s for writing\n", "soundaliases/temp.st");
  }
}

//----- (080ADFEA) --------------------------------------------------------
void __cdecl Com_ProcessSoundAliasFileLocalization(char *a1, char *s2)
{
  int v2; // [esp+24h] [ebp-6DD4h]
  int v3; // [esp+28h] [ebp-6DD0h]
  char v4[256]; // [esp+30h] [ebp-6DC8h] BYREF
  char dest[352]; // [esp+130h] [ebp-6CC8h] BYREF
  int v6[257]; // [esp+290h] [ebp-6B68h]
  FILE *stream; // [esp+694h] [ebp-6764h]
  int v8; // [esp+698h] [ebp-6760h]
  int v9; // [esp+69Ch] [ebp-675Ch]
  char s[36]; // [esp+6A0h] [ebp-6758h] BYREF
  char *v11; // [esp+6C4h] [ebp-6734h]
  char *v12; // [esp+6C8h] [ebp-6730h]
  char *src; // [esp+6CCh] [ebp-672Ch]
  char haystack[256]; // [esp+6D0h] [ebp-6728h] BYREF
  char v15[256]; // [esp+7D0h] [ebp-6628h] BYREF
  char v16[2048]; // [esp+8D0h] [ebp-6528h] BYREF
  char v17[1024]; // [esp+10D0h] [ebp-5D28h] BYREF
  char v18[2048]; // [esp+14D0h] [ebp-5928h] BYREF
  char v19[20480]; // [esp+1CD0h] [ebp-5128h] BYREF
  char filename[264]; // [esp+6CD0h] [ebp-128h] BYREF
  char *v21; // [esp+6DD8h] [ebp-20h] BYREF
  char *v22; // [esp+6DDCh] [ebp-1Ch] BYREF
  char v23[4]; // [esp+6DE0h] [ebp-18h]
  int v24; // [esp+6DE4h] [ebp-14h]
  int v25; // [esp+6DE8h] [ebp-10h]
  int i; // [esp+6DECh] [ebp-Ch]

  Com_sprintf(v4, 0x100u, "soundaliases/%s", a1);
  FS_BuildOSPath(*(char **)(fs_basepath + 8), byte_848B6C0, v4, filename);
  Com_Printf("Processing sound alias file %s..\n", filename);
  stream = FS_FileOpen(filename, "r+");
  if ( !stream )
  {
    Com_Printf("WARNING: Can not write to sound alias file %s\n", filename);
    return;
  }
  FS_FileClose(stream);
  if ( FS_ReadFile(v4, &v22) < 0 )
  {
    Com_Printf("WARNING: Could not read sound alias file %s\n", v4);
    return;
  }
  v8 = FS_FOpenFileWrite("soundaliases/temp.csv");
  if ( !v8 )
  {
    Com_Printf("WARNING: Could not open output file %s for writing\n", "soundaliases/temp.csv");
    return;
  }
  Com_BeginParseSession(v4);
  sub_80B3B00(1);
  v21 = v22;
  v25 = 0;
  *(_DWORD *)v23 = 0;
  while ( v21 )
  {
    if ( *v21 == 13 )
    {
      while ( *v21 == 13 )
        ++v21;
    }
    if ( *v21 == 10 )
    {
      ++v21;
      FS_Write("\r\n", 2u, v8);
    }
    v12 = v21;
    src = Com_Parse(&v21);
    if ( !v21 )
      break;
    if ( !I_stricmp(src, "#Chateau") )
      i = 0;
    if ( !*src || *src == 35 )
    {
      Com_SkipRestOfLine(&v21);
      if ( *v12 == 10 )
        FS_Write("\r", 1u, v8);
      goto LABEL_21;
    }
    if ( v25 )
    {
      memset(s, 0, 0x18u);
      sub_80AB28A(dest, a1, "menu");
      i = 0;
      while ( 1 )
      {
        strcpy(&v16[1024 * v6[i] + 1024], src);
        if ( *src )
          Com_LoadSoundAliasField("menu", s2, a1, src, v6[i], (int)s, (int)dest);
        if ( ++i == v25 )
          break;
        src = Com_ParseOnLine(&v21);
      }
      if ( !s[1] || !s[3] )
        Com_Error(1, (char *)&byte_8147A00, a1);
      v9 = 0;
      if ( s[4] )
      {
        v24 = strlen(v19);
        for ( i = 0; i < v24 && (v19[i] > 64 && v19[i] <= 90 || v19[i] > 47 && v19[i] <= 57 || v19[i] == 95); ++i )
          ;
        if ( i < v24 || I_strncmp(v19, "SUBTITLE_", 9) || !sub_80AD964(v19) )
          v9 = 1;
      }
      if ( v9 )
      {
        for ( i = 0; i < v25; ++i )
        {
          if ( v6[i] && s[v6[i]] )
          {
            if ( v6[i] == 4 )
            {
              src = Com_GetSubtitleStringEdReference(v19);
              if ( src )
              {
                Com_sprintf(v16, 0x400u, "%s%s", "SUBTITLE_", src);
                src = I_strupr(v16);
              }
              else
              {
                if ( s[2] )
                  Com_sprintf(v16, 0x400u, "%s%s_%s", "SUBTITLE_", v17, v18);
                else
                  Com_sprintf(v16, 0x400u, "%s%s", "SUBTITLE_", v17);
                src = I_strupr(v16);
                sub_80ADC96((int)v16, v19);
                ++*(_DWORD *)v23;
              }
            }
            else if ( i == v25 - 1 )
            {
              if ( strchr(&v16[1024 * v6[i] + 1024], 44)
                || strchr(&v16[1024 * v6[i] + 1024], 32)
                || strchr(&v16[1024 * v6[i] + 1024], 10)
                || strchr(&v16[1024 * v6[i] + 1024], 13) )
              {
                src = va("\"%s\"", &v16[1024 * v6[i] + 1024]);
              }
              else
              {
                src = va("%s", &v16[1024 * v6[i] + 1024]);
              }
            }
            else if ( strchr(&v16[1024 * v6[i] + 1024], 44)
                   || strchr(&v16[1024 * v6[i] + 1024], 32)
                   || strchr(&v16[1024 * v6[i] + 1024], 10)
                   || strchr(&v16[1024 * v6[i] + 1024], 13) )
            {
              src = va("\"%s\",", &v16[1024 * v6[i] + 1024]);
            }
            else
            {
              src = va("%s,", &v16[1024 * v6[i] + 1024]);
            }
            v24 = strlen(src);
            FS_Write(src, v24, v8);
          }
          else if ( i != v25 - 1 )
          {
            FS_Write(",", 1u, v8);
          }
        }
        FS_Write("\r\n", 2u, v8);
        Com_SkipRestOfLine(&v21);
      }
      else
      {
        Com_SkipRestOfLine(&v21);
        v11 = v21;
        FS_Write(v12, v21 - v12, v8);
      }
    }
    else
    {
      v3 = 0;
      v2 = 0;
      while ( 2 )
      {
        v6[v25] = 0;
        for ( i = 1; i <= 23; ++i )
        {
          if ( !I_stricmp((char *)dword_815DEA0[i], src) )
          {
            v6[v25] = i;
            if ( i == 1 )
            {
              v3 = 1;
            }
            else if ( i == 3 )
            {
              v2 = 1;
            }
            break;
          }
        }
        if ( ++v25 != 256 && v21 && *v21 != 10 )
        {
          src = Com_ParseOnLine(&v21);
          continue;
        }
        break;
      }
      if ( !v3 || !v2 )
        Com_Error(1, (char *)&byte_81479C0, a1);
      Com_SkipRestOfLine(&v21);
      if ( *v12 == 10 )
        FS_Write("\r", 1u, v8);
LABEL_21:
      v11 = v21;
      FS_Write(v12, v21 - v12, v8);
    }
  }
  Com_EndParseSession();
  FS_FCloseFile(v8);
  FS_BuildOSPath(*(char **)(fs_basepath + 8), byte_848B6C0, "soundaliases/temp.csv", v15);
  FS_BuildOSPath(*(char **)(fs_basepath + 8), byte_848B6C0, v4, haystack);
  if ( *(_DWORD *)v23 )
    FS_CopyFile(v15, haystack);
  sub_809CACA(v15);
  Com_Printf("Localized %i sound alias subtitles\n", *(_DWORD *)v23);
}
// 815DEA0: using guessed type int dword_815DEA0[];
// 80ADFEA: using guessed type int var_6B68[257];
// 80ADFEA: using guessed type char var_5128[20480];
// 80ADFEA: using guessed type char anonymous_0[2048];

//----- (080AEB14) --------------------------------------------------------
void __cdecl sub_80AEB14(char *filename, char *a2)
{
  void *ptr; // [esp+1Ch] [ebp-Ch]
  int size; // [esp+20h] [ebp-8h]
  FILE *stream; // [esp+24h] [ebp-4h]
  FILE *streama; // [esp+24h] [ebp-4h]

  stream = FS_FileOpen(filename, "rb");
  if ( stream )
  {
    FS_FileSeek(stream, 0, 2);
    size = ftell(stream);
    FS_FileSeek(stream, 0, 0);
    ptr = malloc(size);
    if ( FS_FileRead(ptr, 1u, size, stream) != size )
      Com_Error(0, (char *)&byte_8147AA0);
    FS_FileClose(stream);
    streama = FS_FileOpen(a2, "wb");
    if ( streama )
    {
      if ( FS_FileWrite(ptr, 1u, size, streama) != size )
        Com_Error(0, (char *)&byte_8147AE0);
      FS_FileClose(streama);
      free(ptr);
    }
    else
    {
      free(ptr);
    }
  }
}

//----- (080AEC4E) --------------------------------------------------------
void Com_WriteLocalizedSoundAliasFiles()
{
  int v0; // [esp+28h] [ebp-220h]
  FILE *stream; // [esp+2Ch] [ebp-21Ch]
  char filename[256]; // [esp+30h] [ebp-218h] BYREF
  char s[260]; // [esp+130h] [ebp-118h] BYREF
  void *ptr; // [esp+234h] [ebp-14h]
  int v5; // [esp+238h] [ebp-10h] BYREF
  int i; // [esp+23Ch] [ebp-Ch]

  FS_BuildOSPath(*(char **)(fs_homepath + 8), "../source_data/string_resources/subtitle.st", (char *)&byte_8147777, s);
  filename[strlen(s) + 255] = 0;
  stream = FS_FileOpen(s, "r+");
  if ( stream )
  {
    FS_FileClose(stream);
    FS_BuildOSPath(*(char **)(fs_basepath + 8), byte_848B6C0, "soundaliases/subtitle.st", filename);
    FS_CopyFile(s, filename);
    if ( sub_809CADE("soundaliases/subtitle.st") )
    {
      Com_Printf("Localizing sound alias subtitle text...\n");
      Com_Printf("Writing to StringEd file %s\n", s);
      ptr = FS_ListFiles((int)"soundaliases", "csv", 0, &v5);
      if ( v5 )
      {
        v0 = Hunk_HideTempMemory();
        for ( i = 0; i < v5; ++i )
        {
          Com_ProcessSoundAliasFileLocalization(*((char **)ptr + i), "all_mp");
          Hunk_ClearTempMemoryInternal();
        }
        Hunk_ShowTempMemory(v0);
        FS_FreeFileList((void **)ptr);
        sub_80AEB14(filename, s);
        sub_809CACA(filename);
        Com_Printf("done\n");
      }
      else
      {
        Com_Printf("WARNING: can't find any sound alias files (soundaliases/*.csv)\n");
      }
    }
    else
    {
      Com_Printf("WARNING: Could not make local copy of StringEd file %s\n", "soundaliases/subtitle.st");
    }
  }
  else
  {
    Com_Printf("WARNING: Can not write to StringEd file %s\n", s);
  }
}
// 848B7C4: using guessed type int fs_homepath;

//----- (080AEE5E) --------------------------------------------------------
long double __cdecl sub_80AEE5E(float a1, float a2, float a3)
{
  float v4; // [esp+0h] [ebp-18h]
  float v5; // [esp+0h] [ebp-18h]
  float v6; // [esp+8h] [ebp-10h]

  v4 = a1 - a3;
  v6 = sub_80AEE9C(v4, a3, a1);
  v5 = a2 - a1;
  return sub_80AEE9C(v5, a2, v6);
}

//----- (080AEE9C) --------------------------------------------------------
long double __cdecl sub_80AEE9C(float a1, float a2, float a3)
{
  if ( a1 < 0.0 )
    return a3;
  return a2;
}

//----- (080AEEC8) --------------------------------------------------------
int __cdecl Dvar_SetInAutoExec(unsigned __int8 a1)
{
  int result; // eax

  result = a1;
  isLoadingAutoExecGlobalFlag = a1;
  return result;
}
// 8523115: using guessed type char isLoadingAutoExecGlobalFlag;

//----- (080AEEE0) --------------------------------------------------------
int Dvar_IsSystemActive()
{
  return (unsigned __int8)isDvarSystemActive;
}
// 8523114: using guessed type char isDvarSystemActive;

//----- (080AEEEC) --------------------------------------------------------
int __cdecl generateHashValue(int a1)
{
  int v2; // [esp+10h] [ebp-8h]
  int i; // [esp+14h] [ebp-4h]

  if ( !a1 )
    Com_Error(1, (char *)&byte_8147CC0);
  v2 = 0;
  for ( i = 0; *(_BYTE *)(a1 + i); ++i )
    v2 += tolower(*(char *)(a1 + i)) * (i + 119);
  return (unsigned __int8)v2;
}

//----- (080AEF62) --------------------------------------------------------
int __cdecl sub_80AEF62(int a1)
{
  char v3; // [esp+7h] [ebp-5h]
  int i; // [esp+8h] [ebp-4h]

  if ( !a1 )
    return 0;
  for ( i = 0; *(_BYTE *)(a1 + i); ++i )
  {
    v3 = *(_BYTE *)(a1 + i);
    if ( (*(_WORD *)(_ctype_b + 2 * v3) & 8) == 0 && v3 != 95 )
      return 0;
  }
  return 1;
}
// 8185A64: using guessed type int _ctype_b;

//----- (080AEFD0) --------------------------------------------------------
char *__cdecl sub_80AEFD0(int a1)
{
  char *v2; // [esp+0h] [ebp-4h]

  if ( (unsigned int)(dword_8523110 + a1) > 0xC )
    dword_8523110 = 0;
  v2 = (char *)&unk_85230E0 + 4 * dword_8523110;
  dword_8523110 += a1;
  return v2;
}
// 8523110: using guessed type int dword_8523110;

//----- (080AF012) --------------------------------------------------------
int __cdecl sub_80AF012(int a1)
{
  int result; // eax

  *(_DWORD *)(a1 + 8) = Z_MallocInternal(12 * *(unsigned __int8 *)(a1 + 6));
  *(_DWORD *)(a1 + 12) = *(_DWORD *)(a1 + 8) + 4 * *(unsigned __int8 *)(a1 + 6);
  result = *(_DWORD *)(a1 + 12) + 4 * *(unsigned __int8 *)(a1 + 6);
  *(_DWORD *)(a1 + 16) = result;
  return result;
}

//----- (080AF06A) --------------------------------------------------------
void __cdecl Dvar_FreeString(int a1)
{
  Z_FreeInternal(*(void **)(a1 + 8));
}

//----- (080AF080) --------------------------------------------------------
char *__cdecl Dvar_CopyString(char *src)
{
  return CopyStringInternal(src);
}

//----- (080AF094) --------------------------------------------------------
void __cdecl Dvar_FreeNameString(void *ptr)
{
  Z_FreeInternal(ptr);
}

//----- (080AF0A8) --------------------------------------------------------
char *__cdecl sub_80AF0A8(char *s)
{
  size_t v3; // [esp+14h] [ebp-4h]

  if ( *s )
  {
    v3 = I_strlen(s);
    if ( s[1] )
    {
      if ( *s == 111 )
      {
        if ( v3 == 3 && s[1] == 102 && s[2] == 102 && !s[3] )
          return off_815DF2C[0];
        if ( v3 == 2 && s[1] == 110 && !s[2] )
          return off_815DF30;
      }
    }
    else if ( *s > 47 && *s <= 57 )
    {
      return (char *)&a0123456789[*s - 48];
    }
    return CopyStringInternal(s);
  }
  return (char *)&unk_8147CE0;
}
// 81482EC: using guessed type __int16 a0123456789[10];
// 815DF2C: using guessed type char *off_815DF2C[2];
// 815DF30: using guessed type char *off_815DF30;

//----- (080AF180) --------------------------------------------------------
void __cdecl sub_80AF180(char *ptr)
{
  if ( *ptr && (ptr[1] || *ptr <= 47 || *ptr > 57) && ptr != off_815DF2C[0] && ptr != off_815DF30 )
    Z_FreeInternal(ptr);
}
// 815DF2C: using guessed type char *off_815DF2C[2];
// 815DF30: using guessed type char *off_815DF30;

//----- (080AF1CE) --------------------------------------------------------
int __cdecl sub_80AF1CE(int a1)
{
  int result; // eax

  if ( *(_DWORD *)(a1 + 8) != *(_DWORD *)(a1 + 12) && *(_DWORD *)(a1 + 8) != *(_DWORD *)(a1 + 16) )
    sub_80AF180(*(char **)(a1 + 8));
  result = a1;
  *(_DWORD *)(a1 + 8) = 0;
  return result;
}

//----- (080AF20A) --------------------------------------------------------
int __cdecl sub_80AF20A(int a1)
{
  int result; // eax

  if ( *(_DWORD *)(a1 + 12) != *(_DWORD *)(a1 + 8) && *(_DWORD *)(a1 + 12) != *(_DWORD *)(a1 + 16) )
    sub_80AF180(*(char **)(a1 + 12));
  result = a1;
  *(_DWORD *)(a1 + 12) = 0;
  return result;
}

//----- (080AF246) --------------------------------------------------------
int __cdecl sub_80AF246(int a1)
{
  int result; // eax

  if ( *(_DWORD *)(a1 + 16) != *(_DWORD *)(a1 + 8) && *(_DWORD *)(a1 + 16) != *(_DWORD *)(a1 + 12) )
    sub_80AF180(*(char **)(a1 + 16));
  result = a1;
  *(_DWORD *)(a1 + 16) = 0;
  return result;
}

//----- (080AF282) --------------------------------------------------------
char *__cdecl sub_80AF282(int a1, char *s1)
{
  char *result; // eax

  if ( *(_DWORD *)(a1 + 12) && (s1 == *(char **)(a1 + 12) || !strcmp(s1, *(const char **)(a1 + 12))) )
  {
    result = (char *)a1;
    *(_DWORD *)(a1 + 8) = *(_DWORD *)(a1 + 12);
  }
  else if ( *(_DWORD *)(a1 + 16) && (s1 == *(char **)(a1 + 16) || !strcmp(s1, *(const char **)(a1 + 16))) )
  {
    result = (char *)a1;
    *(_DWORD *)(a1 + 8) = *(_DWORD *)(a1 + 16);
  }
  else
  {
    result = sub_80AF0A8(s1);
    *(_DWORD *)(a1 + 8) = result;
  }
  return result;
}

//----- (080AF316) --------------------------------------------------------
char *__cdecl sub_80AF316(int a1, char *s1)
{
  char *result; // eax

  if ( *(_DWORD *)(a1 + 8) && (s1 == *(char **)(a1 + 8) || !strcmp(s1, *(const char **)(a1 + 8))) )
  {
    result = (char *)a1;
    *(_DWORD *)(a1 + 12) = *(_DWORD *)(a1 + 8);
  }
  else if ( *(_DWORD *)(a1 + 16) && (s1 == *(char **)(a1 + 16) || !strcmp(s1, *(const char **)(a1 + 16))) )
  {
    result = (char *)a1;
    *(_DWORD *)(a1 + 12) = *(_DWORD *)(a1 + 16);
  }
  else
  {
    result = sub_80AF0A8(s1);
    *(_DWORD *)(a1 + 12) = result;
  }
  return result;
}

//----- (080AF3AA) --------------------------------------------------------
char *__cdecl sub_80AF3AA(int a1, char *s1)
{
  char *result; // eax

  if ( *(_DWORD *)(a1 + 8) && (s1 == *(char **)(a1 + 8) || !strcmp(s1, *(const char **)(a1 + 8))) )
  {
    result = (char *)a1;
    *(_DWORD *)(a1 + 16) = *(_DWORD *)(a1 + 8);
  }
  else if ( *(_DWORD *)(a1 + 12) && (s1 == *(char **)(a1 + 12) || !strcmp(s1, *(const char **)(a1 + 12))) )
  {
    result = (char *)a1;
    *(_DWORD *)(a1 + 16) = *(_DWORD *)(a1 + 12);
  }
  else
  {
    result = sub_80AF0A8(s1);
    *(_DWORD *)(a1 + 16) = result;
  }
  return result;
}

//----- (080AF43E) --------------------------------------------------------
void *__cdecl Dvar_EnumToString(_DWORD *a1)
{
  if ( a1[5] )
    return *(void **)(a1[6] + 4 * a1[2]);
  else
    return &unk_8147CE0;
}

//----- (080AF474) --------------------------------------------------------
void *__cdecl Dvar_IndexStringToEnumString(int a1, char *nptr)
{
  signed int i; // [esp+Ch] [ebp-Ch]
  signed int v5; // [esp+10h] [ebp-8h]

  if ( !*(_DWORD *)(a1 + 20) )
    return &unk_8147CE0;
  v5 = I_strlen(nptr);
  for ( i = 0; i < v5; ++i )
  {
    if ( (*(_WORD *)(_ctype_b + 2 * nptr[i]) & 0x800) == 0 )
      return &unk_8147CE0;
  }
  return *(void **)(*(_DWORD *)(a1 + 24) + 4 * atoi(nptr));
}
// 8185A64: using guessed type int _ctype_b;

//----- (080AF502) --------------------------------------------------------
char *__cdecl Dvar_ValueToString(int a1, float *a2)
{
  char *v3; // [esp+30h] [ebp-8h]
  char *v4; // [esp+34h] [ebp-4h]

  switch ( *(_BYTE *)(a1 + 6) )
  {
    case 0:
      if ( (_BYTE)a2 )
        v3 = (char *)&unk_8147CE1;
      else
        v3 = (char *)&unk_8147CE3;
      v4 = v3;
      break;
    case 1:
      v4 = va("%g", *(float *)&a2);
      break;
    case 2:
      v4 = va("%g %g", *a2, a2[1]);
      break;
    case 3:
      v4 = va("%g %g %g", *a2, a2[1], a2[2]);
      break;
    case 4:
      v4 = va("%g %g %g %g", *a2, a2[1], a2[2], a2[3]);
      break;
    case 5:
      v4 = va("%i", a2);
      break;
    case 6:
      if ( *(_DWORD *)(a1 + 20) )
        v4 = *(char **)(*(_DWORD *)(a1 + 24) + 4 * (_DWORD)a2);
      else
        v4 = (char *)&unk_8147CE0;
      break;
    case 7:
      v4 = va("%s", (const char *)a2);
      break;
    case 8:
      v4 = va(
             "%g %g %g %g",
             (double)((long double)(unsigned __int8)a2 * 0.0039215689),
             (double)((long double)BYTE1(a2) * 0.0039215689),
             (double)((long double)BYTE2(a2) * 0.0039215689),
             (double)((long double)HIBYTE(a2) * 0.0039215689));
      break;
    default:
      v4 = (char *)&unk_8147CE0;
      break;
  }
  return v4;
}

//----- (080AF6DE) --------------------------------------------------------
_BOOL4 __cdecl Dvar_StringToBool(char *nptr)
{
  return atoi(nptr) != 0;
}

//----- (080AF704) --------------------------------------------------------
int __cdecl Dvar_StringToInt(char *nptr)
{
  return atoi(nptr);
}

//----- (080AF718) --------------------------------------------------------
long double __cdecl Dvar_StringToFloat(char *nptr)
{
  return (float)atof(nptr);
}

//----- (080AF738) --------------------------------------------------------
char *__cdecl Dvar_StringToVec2(char *s)
{
  char *v2; // [esp+14h] [ebp-4h]

  v2 = sub_80AEFD0(2);
  sub_80B317C(v2);
  sscanf(s, "%g %g", v2, v2 + 4);
  return v2;
}

//----- (080AF782) --------------------------------------------------------
char *__cdecl Dvar_StringToVec3(char *s)
{
  char *v2; // [esp+14h] [ebp-4h]

  v2 = sub_80AEFD0(3);
  sub_80B321E(v2);
  sscanf(s, "%g %g %g", v2, v2 + 4, v2 + 8);
  return v2;
}

//----- (080AF7D6) --------------------------------------------------------
char *__cdecl Dvar_StringToVec4(char *s)
{
  char *v2; // [esp+24h] [ebp-4h]

  v2 = sub_80AEFD0(4);
  sub_80B3306(v2);
  sscanf(s, "%g %g %g %g", v2, v2 + 4, v2 + 8, v2 + 12);
  return v2;
}

//----- (080AF834) --------------------------------------------------------
int __cdecl Dvar_StringToEnum(int *a1, char *s1)
{
  int v4; // [esp+1Ch] [ebp-Ch]
  char *j; // [esp+20h] [ebp-8h]
  int i; // [esp+24h] [ebp-4h]
  int v7; // [esp+24h] [ebp-4h]
  int k; // [esp+24h] [ebp-4h]

  for ( i = 0; i < *a1; ++i )
  {
    if ( !strcasecmp(s1, *(const char **)(a1[1] + 4 * i)) )
      return i;
  }
  v7 = 0;
  for ( j = s1; *j; ++j )
  {
    if ( *j <= 47 || *j > 57 )
      return -1337;
    v7 = *j + 10 * v7 - 48;
  }
  if ( v7 >= 0 && v7 < *a1 )
    return v7;
  v4 = I_strlen(s1);
  for ( k = 0; k < *a1; ++k )
  {
    if ( !sub_80B3458(s1, *(_BYTE **)(a1[1] + 4 * k), v4) )
      return k;
  }
  return -1337;
}

//----- (080AF95E) --------------------------------------------------------
int __usercall Dvar_StringToColorInternal@<eax>(long double a1@<st0>, char *s, _BYTE *a3)
{
  long double v3; // fst7
  long double v4; // fst7
  long double v5; // fst7
  int result; // eax
  float v7; // [esp+0h] [ebp-38h]
  float v8; // [esp+0h] [ebp-38h]
  float v9; // [esp+0h] [ebp-38h]
  float v10; // [esp+0h] [ebp-38h]
  float v11; // [esp+4h] [ebp-34h]
  float v12; // [esp+4h] [ebp-34h]
  float v13; // [esp+4h] [ebp-34h]
  float v14; // [esp+4h] [ebp-34h]
  float v15; // [esp+20h] [ebp-18h] BYREF
  float v16; // [esp+24h] [ebp-14h] BYREF
  float v17; // [esp+28h] [ebp-10h] BYREF
  float v18; // [esp+2Ch] [ebp-Ch] BYREF

  sub_80B3306(&v15);
  sscanf(s, "%g %g %g %g", &v15, &v16, &v17, &v18);
  sub_80B3122(1.0, v15);
  v11 = a1;
  sub_80B30FE(0.0, v11);
  v3 = a1 * 255.0;
  v7 = v3;
  *a3 = sub_80B3146(v7);
  sub_80B3122(1.0, v16);
  v12 = v3;
  sub_80B30FE(0.0, v12);
  v4 = v3 * 255.0;
  v8 = v4;
  a3[1] = sub_80B3146(v8);
  sub_80B3122(1.0, v17);
  v13 = v4;
  sub_80B30FE(0.0, v13);
  v5 = v4 * 255.0;
  v9 = v5;
  a3[2] = sub_80B3146(v9);
  sub_80B3122(1.0, v18);
  v14 = v5;
  sub_80B30FE(0.0, v14);
  v10 = v5 * 255.0;
  result = sub_80B3146(v10);
  a3[3] = result;
  return result;
}

//----- (080AFA9E) --------------------------------------------------------
float *__userpurge sub_80AFA9E@<eax>(long double a1@<st0>, float *a2, char a3, int a4, int a5, char *nptr)
{
  int v7[3]; // [esp+18h] [ebp-10h] BYREF
  char v8; // [esp+27h] [ebp-1h]

  v7[0] = a4;
  v7[1] = a5;
  v8 = a3;
  switch ( a3 )
  {
    case 0:
      *(_BYTE *)a2 = Dvar_StringToBool(nptr);
      break;
    case 1:
      *a2 = Dvar_StringToFloat(nptr);
      break;
    case 2:
      *(_DWORD *)a2 = Dvar_StringToVec2(nptr);
      break;
    case 3:
      *(_DWORD *)a2 = Dvar_StringToVec3(nptr);
      break;
    case 4:
      *(_DWORD *)a2 = Dvar_StringToVec4(nptr);
      break;
    case 5:
      *(_DWORD *)a2 = Dvar_StringToInt(nptr);
      break;
    case 6:
      *(_DWORD *)a2 = Dvar_StringToEnum(v7, nptr);
      break;
    case 7:
      *(_DWORD *)a2 = nptr;
      break;
    case 8:
      Dvar_StringToColorInternal(a1, nptr, a2);
      break;
    default:
      *a2 = 0.0;
      break;
  }
  return a2;
}

//----- (080AFB8C) --------------------------------------------------------
char *__cdecl Dvar_DisplayableValue(int a1)
{
  return Dvar_ValueToString(a1, *(float **)(a1 + 8));
}

//----- (080AFBB2) --------------------------------------------------------
char *__cdecl Dvar_DisplayableResetValue(int a1)
{
  return Dvar_ValueToString(a1, *(float **)(a1 + 16));
}

//----- (080AFBD8) --------------------------------------------------------
char *__cdecl Dvar_DisplayableLatchedValue(int a1)
{
  return Dvar_ValueToString(a1, *(float **)(a1 + 12));
}

//----- (080AFBFE) --------------------------------------------------------
int __cdecl sub_80AFBFE(int a1, int a2, float a3, float a4)
{
  int result; // eax
  int i; // [esp+0h] [ebp-4h]

  for ( i = 0; ; ++i )
  {
    result = i;
    if ( i >= a2 )
      break;
    if ( a3 <= (long double)*(float *)(a1 + 4 * i) )
    {
      if ( *(float *)(a1 + 4 * i) > (long double)a4 )
        *(float *)(a1 + 4 * i) = a4;
    }
    else
    {
      *(float *)(a1 + 4 * i) = a3;
    }
  }
  return result;
}

//----- (080AFC80) --------------------------------------------------------
int __cdecl sub_80AFC80(int a1, int a2, float a3, float a4)
{
  int i; // [esp+4h] [ebp-4h]

  for ( i = 0; i < a2; ++i )
  {
    if ( a3 > (long double)*(float *)(a1 + 4 * i) )
      return 0;
    if ( *(float *)(a1 + 4 * i) > (long double)a4 )
      return 0;
  }
  return 1;
}

//----- (080AFCF6) --------------------------------------------------------
float *__userpurge sub_80AFCF6@<eax>(float *a1, char a2, int a3, int a4, float a5, float a6)
{
  switch ( a2 )
  {
    case 1:
      if ( a5 <= (long double)*(float *)&a3 )
      {
        if ( *(float *)&a3 > (long double)a6 )
          *(float *)&a3 = a6;
      }
      else
      {
        *(float *)&a3 = a5;
      }
      break;
    case 2:
      sub_80AFBFE(a3, 2, a5, a6);
      break;
    case 3:
      sub_80AFBFE(a3, 3, a5, a6);
      break;
    case 4:
      sub_80AFBFE(a3, 4, a5, a6);
      break;
    case 5:
      if ( a3 >= SLODWORD(a5) )
      {
        if ( a3 > SLODWORD(a6) )
          *(float *)&a3 = a6;
      }
      else
      {
        *(float *)&a3 = a5;
      }
      break;
    case 6:
      if ( a3 < 0 || a3 >= SLODWORD(a5) )
        a3 = a4;
      break;
    default:
      break;
  }
  *a1 = *(float *)&a3;
  return a1;
}

//----- (080AFE1A) --------------------------------------------------------
int __cdecl sub_80AFE1A(char a1, int a2, float a3, float a4)
{
  int v5; // [esp+20h] [ebp-18h]
  int v6; // [esp+24h] [ebp-14h]

  switch ( a1 )
  {
    case 0:
      v6 = 1;
      break;
    case 1:
      v6 = a3 <= (long double)*(float *)&a2 && *(float *)&a2 <= (long double)a4;
      break;
    case 2:
      v6 = (unsigned __int8)sub_80AFC80(a2, 2, a3, a4);
      break;
    case 3:
      v6 = (unsigned __int8)sub_80AFC80(a2, 3, a3, a4);
      break;
    case 4:
      v6 = (unsigned __int8)sub_80AFC80(a2, 4, a3, a4);
      break;
    case 5:
      v6 = a2 >= SLODWORD(a3) && a2 <= SLODWORD(a4);
      break;
    case 6:
      v5 = 0;
      if ( a2 >= 0 && a2 < SLODWORD(a3) || *(float *)&a2 == 0.0 )
        v5 = 1;
      v6 = v5;
      break;
    case 7:
      v6 = 1;
      break;
    case 8:
      v6 = 1;
      break;
    default:
      v6 = 0;
      break;
  }
  return v6;
}

//----- (080AFF9A) --------------------------------------------------------
int __cdecl Dvar_VectorDomainToString(int a1, int a2, int a3, char *s, size_t maxlen)
{
  if ( *(float *)&a2 == -3.4028235e38 )
  {
    if ( *(float *)&a3 == 3.4028235e38 )
      return snprintf(s, maxlen, "Domain is any %iD vector", a1);
    else
      return snprintf(s, maxlen, "Domain is any %iD vector with components %g or smaller", a1, *(float *)&a3);
  }
  else if ( *(float *)&a3 == 3.4028235e38 )
  {
    return snprintf(s, maxlen, "Domain is any %iD vector with components %g or bigger", a1, *(float *)&a2);
  }
  else
  {
    return snprintf(
             s,
             maxlen,
             "Domain is any %iD vector with components from %g to %g",
             a1,
             *(float *)&a2,
             *(float *)&a3);
  }
}

//----- (080B009A) --------------------------------------------------------
char *__cdecl Dvar_DomainToString_Internal(char a1, int a2, int a3, char *s, size_t maxlen, _DWORD *a6)
{
  int i; // [esp+2Ch] [ebp-1Ch]
  int v8; // [esp+30h] [ebp-18h]
  int v9; // [esp+30h] [ebp-18h]
  char *v10; // [esp+34h] [ebp-14h]

  v10 = &s[maxlen];
  if ( a6 )
    *a6 = 0;
  switch ( a1 )
  {
    case 0:
      snprintf(s, maxlen, "Domain is 0 or 1");
      break;
    case 1:
      if ( *(float *)&a2 == -3.4028235e38 )
      {
        if ( *(float *)&a3 == 3.4028235e38 )
          snprintf(s, maxlen, "Domain is any number");
        else
          snprintf(s, maxlen, "Domain is any number %g or smaller", *(float *)&a3);
      }
      else if ( *(float *)&a3 == 3.4028235e38 )
      {
        snprintf(s, maxlen, "Domain is any number %g or bigger", *(float *)&a2);
      }
      else
      {
        snprintf(s, maxlen, "Domain is any number from %g to %g", *(float *)&a2, *(float *)&a3);
      }
      break;
    case 2:
      Dvar_VectorDomainToString(2, a2, a3, s, maxlen);
      break;
    case 3:
      Dvar_VectorDomainToString(3, a2, a3, s, maxlen);
      break;
    case 4:
      Dvar_VectorDomainToString(4, a2, a3, s, maxlen);
      break;
    case 5:
      if ( a2 == 0x80000000 )
      {
        if ( *(float *)&a3 == NAN )
          snprintf(s, maxlen, "Domain is any integer");
        else
          snprintf(s, maxlen, "Domain is any integer %i or smaller", a3);
      }
      else if ( *(float *)&a3 == NAN )
      {
        snprintf(s, maxlen, "Domain is any integer %i or bigger", a2);
      }
      else
      {
        snprintf(s, maxlen, "Domain is any integer from %i to %i", a2, a3);
      }
      break;
    case 6:
      v8 = snprintf(s, maxlen, "Domain is one of the following:");
      if ( v8 >= 0 )
      {
        s += v8;
        for ( i = 0; i < a2; ++i )
        {
          v9 = snprintf(s, v10 - s, "\n  %2i: %s", i, *(const char **)(a3 + 4 * i));
          if ( v9 < 0 )
            break;
          if ( a6 )
            ++*a6;
          s += v9;
        }
      }
      break;
    case 7:
      snprintf(s, maxlen, "Domain is any text");
      break;
    case 8:
      snprintf(s, maxlen, "Domain is any 4-component color, in RGBA format");
      break;
    default:
      *s = 0;
      break;
  }
  *(v10 - 1) = 0;
  return s;
}

//----- (080B0410) --------------------------------------------------------
char *__cdecl sub_80B0410(char a1, int a2, int a3, char *s, size_t maxlen)
{
  return Dvar_DomainToString_Internal(a1, a2, a3, s, maxlen, 0);
}

//----- (080B045A) --------------------------------------------------------
char *__cdecl sub_80B045A(char a1, int a2, int a3, char *s, size_t maxlen, _DWORD *a6)
{
  return Dvar_DomainToString_Internal(a1, a2, a3, s, maxlen, a6);
}

//----- (080B04A4) --------------------------------------------------------
void __cdecl Dvar_PrintDomain(char a1, int a2, int a3)
{
  char *v3; // eax
  char s[1024]; // [esp+20h] [ebp-418h] BYREF
  int v5; // [esp+420h] [ebp-18h]
  int v6; // [esp+424h] [ebp-14h]
  char v7; // [esp+42Fh] [ebp-9h]

  v5 = a2;
  v6 = a3;
  v7 = a1;
  v3 = sub_80B0410(a1, a2, a3, s, 0x400u);
  Com_Printf("  %s\n", v3);
}
// 80B04A4: using guessed type char s[1024];

//----- (080B04FE) --------------------------------------------------------
int __cdecl Dvar_ValuesEqual(char a1, char *s1, char *s2)
{
  int v4; // [esp+10h] [ebp-8h]

  switch ( a1 )
  {
    case 0:
      v4 = (_BYTE)s1 == (unsigned __int8)s2;
      break;
    case 1:
      v4 = *(float *)&s2 == *(float *)&s1;
      break;
    case 2:
      v4 = (unsigned __int8)sub_80B31D0((float *)s1, (float *)s2);
      break;
    case 3:
      v4 = (unsigned __int8)sub_80B329C((float *)s1, (float *)s2);
      break;
    case 4:
      v4 = (unsigned __int8)sub_80B33AA((float *)s1, (float *)s2);
      break;
    case 5:
      v4 = s1 == s2;
      break;
    case 6:
      v4 = s1 == s2;
      break;
    case 7:
      v4 = strcmp(s1, s2) == 0;
      break;
    case 8:
      v4 = sub_80B3442(&s1, &s2);
      break;
    default:
      v4 = 0;
      break;
  }
  return v4;
}

//----- (080B0620) --------------------------------------------------------
char *__cdecl sub_80B0620(int a1, char *s1)
{
  char *result; // eax
  int v3; // [esp+14h] [ebp-4h]

  v3 = *(unsigned __int8 *)(a1 + 6);
  if ( v3 == 3 )
    return (char *)sub_80B326C(s1, *(_DWORD **)(a1 + 12));
  if ( *(unsigned __int8 *)(a1 + 6) > 3u )
  {
    if ( v3 == 4 )
      return (char *)sub_80B336A(s1, *(_DWORD **)(a1 + 12));
    if ( v3 == 7 )
    {
      sub_80AF20A(a1);
      return sub_80AF316(a1, s1);
    }
  }
  else if ( v3 == 2 )
  {
    return (char *)sub_80B31B0(s1, *(_DWORD **)(a1 + 12));
  }
  result = s1;
  *(_DWORD *)(a1 + 12) = s1;
  return result;
}

//----- (080B06C4) --------------------------------------------------------
int __cdecl Dvar_HasLatchedValue(int a1)
{
  return (unsigned __int8)Dvar_ValuesEqual(*(_BYTE *)(a1 + 6), *(char **)(a1 + 8), *(char **)(a1 + 12)) ^ 1;
}

//----- (080B06F8) --------------------------------------------------------
int __cdecl Dvar_IsAtDefaultValue(int a1)
{
  return (unsigned __int8)Dvar_ValuesEqual(*(_BYTE *)(a1 + 6), *(char **)(a1 + 8), *(char **)(a1 + 16));
}

//----- (080B072A) --------------------------------------------------------
void __cdecl Dvar_SetVariant(const char **a1, float *s1, int a3)
{
  char *v3; // eax
  char *v4; // eax
  char *v5; // eax
  int v6; // [esp+14h] [ebp-4h]

  v3 = Dvar_ValueToString((int)a1, s1);
  v4 = va("      dvar set %s %s\n", *a1, v3);
  Com_PrintMessage(4, v4);
  if ( (unsigned __int8)sub_80AFE1A(*((_BYTE *)a1 + 6), (int)s1, *((float *)a1 + 5), *((float *)a1 + 6)) != 1 )
  {
    v5 = Dvar_ValueToString((int)a1, s1);
    Com_Printf("'%s' is not a valid value for dvar '%s'\n", v5, *a1);
    Dvar_PrintDomain(*((_BYTE *)a1 + 6), (int)a1[5], (int)a1[6]);
    if ( *((_BYTE *)a1 + 6) == 6 )
      Dvar_SetVariant((int)a1, (char *)a1[4], a3);
    return;
  }
  if ( a3 != 1 && a3 != 2 )
    goto LABEL_33;
  if ( ((_WORD)a1[1] & 0x40) != 0 )
  {
    Com_Printf("%s is read only.\n", *a1);
    return;
  }
  if ( ((_WORD)a1[1] & 0x10) != 0 )
  {
    Com_Printf("%s is write protected.\n", *a1);
    return;
  }
  if ( a3 == 1 && *((char *)a1 + 4) < 0 && !*(_BYTE *)(dvar_cheats + 8) )
  {
    Com_Printf("%s is cheat protected.\n", *a1);
    return;
  }
  if ( ((_WORD)a1[1] & 0x20) == 0 )
  {
LABEL_33:
    if ( (unsigned __int8)Dvar_ValuesEqual(*((_BYTE *)a1 + 6), (char *)a1[2], (char *)s1) )
    {
      sub_80B0620((int)a1, (char *)a1[2]);
      return;
    }
    dvar_modifiedFlags |= *((unsigned __int16 *)a1 + 2);
    v6 = *((unsigned __int8 *)a1 + 6);
    if ( v6 == 3 )
    {
      sub_80B326C(s1, a1[2]);
      sub_80B326C(s1, a1[3]);
    }
    else if ( *((unsigned __int8 *)a1 + 6) > 3u )
    {
      if ( v6 == 4 )
      {
        sub_80B336A(s1, a1[2]);
        sub_80B336A(s1, a1[3]);
      }
      else
      {
        if ( v6 != 7 )
        {
LABEL_29:
          a1[2] = (const char *)s1;
          a1[3] = (const char *)s1;
          goto LABEL_30;
        }
        sub_80AF1CE((int)a1);
        sub_80AF282((int)a1, (char *)s1);
        sub_80AF20A((int)a1);
        a1[3] = a1[2];
      }
    }
    else
    {
      if ( v6 != 2 )
        goto LABEL_29;
      sub_80B31B0(s1, a1[2]);
      sub_80B31B0(s1, a1[3]);
    }
LABEL_30:
    *((_BYTE *)a1 + 7) = 1;
    return;
  }
  sub_80B0620((int)a1, (char *)s1);
  if ( (unsigned __int8)Dvar_ValuesEqual(*((_BYTE *)a1 + 6), (char *)a1[3], (char *)a1[2]) != 1 )
    Com_Printf("%s will be changed upon restarting.\n", *a1);
}
// 85178A4: using guessed type int dvar_cheats;
// 85178A8: using guessed type int dvar_modifiedFlags;

//----- (080B0A84) --------------------------------------------------------
int __cdecl Dvar_FindMalleableVar(char *a1)
{
  int i; // [esp+14h] [ebp-4h]

  for ( i = dword_8522CE0[generateHashValue((int)a1)]; i; i = *(_DWORD *)(i + 32) )
  {
    if ( !I_stricmp(a1, *(char **)i) )
      return i;
  }
  return 0;
}
// 8522CE0: using guessed type int dword_8522CE0[256];

//----- (080B0AE4) --------------------------------------------------------
int __cdecl Dvar_FindVar(char *a1)
{
  return Dvar_FindMalleableVar(a1);
}

//----- (080B0AF8) --------------------------------------------------------
int __cdecl Dvar_ClearModified(int a1)
{
  int result; // eax

  result = a1;
  *(_BYTE *)(a1 + 7) = 0;
  return result;
}

//----- (080B0BB6) --------------------------------------------------------
int __cdecl Dvar_GetBool(char *a1)
{
  int v3; // [esp+14h] [ebp-4h]

  v3 = Dvar_FindVar(a1);
  if ( !v3 )
    return 0;
  if ( *(_BYTE *)(v3 + 6) )
    return Dvar_StringToBool(*(char **)(v3 + 8));
  return *(unsigned __int8 *)(v3 + 8);
}

//----- (080B0C08) --------------------------------------------------------
int __cdecl Dvar_GetInt(char *a1)
{
  int v3; // [esp+14h] [ebp-4h]

  v3 = Dvar_FindVar(a1);
  if ( !v3 )
    return 0;
  if ( *(_BYTE *)(v3 + 6) == 5 || *(_BYTE *)(v3 + 6) == 6 )
    return *(_DWORD *)(v3 + 8);
  return Dvar_StringToInt(*(char **)(v3 + 8));
}

//----- (080B0C60) --------------------------------------------------------
long double __cdecl Dvar_GetFloat(char *a1)
{
  int v3; // [esp+14h] [ebp-4h]

  v3 = Dvar_FindVar(a1);
  if ( v3 )
  {
    if ( *(_BYTE *)(v3 + 6) == 1 )
      return *(float *)(v3 + 8);
    else
      return (float)Dvar_StringToFloat((char *)*(_DWORD *)(v3 + 8));
  }
  else
  {
    return (float)0.0;
  }
}

//----- (080B0CAC) --------------------------------------------------------
char *__cdecl Dvar_GetVec2(char *a1)
{
  int v3; // [esp+14h] [ebp-4h]

  v3 = Dvar_FindVar(a1);
  if ( !v3 )
    return (char *)&unk_8145E60;
  if ( *(_BYTE *)(v3 + 6) == 2 )
    return *(char **)(v3 + 8);
  return Dvar_StringToVec2(*(char **)(v3 + 8));
}

//----- (080B0CFA) --------------------------------------------------------
char *__cdecl Dvar_GetVec3(char *a1)
{
  int v3; // [esp+14h] [ebp-4h]

  v3 = Dvar_FindVar(a1);
  if ( !v3 )
    return (char *)flt_8145E68;
  if ( *(_BYTE *)(v3 + 6) == 3 )
    return *(char **)(v3 + 8);
  return Dvar_StringToVec3(*(char **)(v3 + 8));
}
// 8145E68: using guessed type float flt_8145E68[3];

//----- (080B0D48) --------------------------------------------------------
char *__cdecl Dvar_GetVec4(char *a1)
{
  int v3; // [esp+14h] [ebp-4h]

  v3 = Dvar_FindVar(a1);
  if ( !v3 )
    return (char *)&unk_8145E74;
  if ( *(_BYTE *)(v3 + 6) == 4 )
    return *(char **)(v3 + 8);
  return Dvar_StringToVec4(*(char **)(v3 + 8));
}

//----- (080B0D96) --------------------------------------------------------
void *__cdecl Dvar_GetString(char *a1)
{
  int v3; // [esp+14h] [ebp-4h]

  v3 = Dvar_FindVar(a1);
  if ( !v3 )
    return &unk_8147CE0;
  if ( *(_BYTE *)(v3 + 6) == 6 )
    return Dvar_EnumToString((_DWORD *)v3);
  return *(void **)(v3 + 8);
}

//----- (080B0DE0) --------------------------------------------------------
char *__cdecl Dvar_GetVariantString(char *a1)
{
  int v3; // [esp+14h] [ebp-4h]

  v3 = Dvar_FindVar(a1);
  if ( v3 )
    return Dvar_ValueToString(v3, *(float **)(v3 + 8));
  else
    return (char *)&unk_8147CE0;
}

//----- (080B0E28) --------------------------------------------------------
int __usercall Dvar_StringToColor@<eax>(long double a1@<st0>, int a2, float *a3)
{
  int result; // eax
  int v4; // [esp+14h] [ebp-4h] BYREF

  if ( *(_BYTE *)(a2 + 6) == 8 )
    sub_80B3432((_DWORD *)(a2 + 8), &v4);
  else
    Dvar_StringToColorInternal(a1, *(char **)(a2 + 8), &v4);
  *a3 = (long double)(unsigned __int8)v4 * 0.0039215689;
  a3[1] = (long double)BYTE1(v4) * 0.0039215689;
  a3[2] = (long double)BYTE2(v4) * 0.0039215689;
  result = HIBYTE(v4);
  a3[3] = (long double)HIBYTE(v4) * 0.0039215689;
  return result;
}

//----- (080B0ED2) --------------------------------------------------------
int __usercall Dvar_GetUnpackedColor@<eax>(long double a1@<st0>, char *a2, float *a3)
{
  int v4; // [esp+14h] [ebp-4h]

  v4 = Dvar_FindVar(a2);
  if ( v4 )
    return Dvar_StringToColor(a1, v4, a3);
  else
    return sub_80B336A(dword_8148660, a3);
}
// 8148660: using guessed type _DWORD dword_8148660[24];

//----- (080B0F16) --------------------------------------------------------
void *Dvar_Shutdown()
{
  int i; // [esp+14h] [ebp-4h]

  for ( i = sortedDvars; i; i = *(_DWORD *)(i + 28) )
  {
    if ( *(_BYTE *)(i + 6) == 7 )
    {
      sub_80AF1CE(i);
      sub_80AF246(i);
      sub_80AF20A(i);
    }
    else if ( *(_BYTE *)(i + 6) == 2 || *(_BYTE *)(i + 6) == 3 || *(_BYTE *)(i + 6) == 4 )
    {
      Dvar_FreeString(i);
    }
    if ( (*(_WORD *)(i + 4) & 0x4000) != 0 )
      Dvar_FreeNameString(*(void **)i);
  }
  *(_DWORD *)dword_8522CC0 = 0;
  sortedDvars = 0;
  dvar_cheats = 0;
  dvar_modifiedFlags = 0;
  isDvarSystemActive = 0;
  return memset(dword_8522CE0, 0, sizeof(dword_8522CE0));
}
// 85178A0: using guessed type int sortedDvars;
// 85178A4: using guessed type int dvar_cheats;
// 85178A8: using guessed type int dvar_modifiedFlags;
// 8522CE0: using guessed type int dword_8522CE0[256];
// 8523114: using guessed type char isDvarSystemActive;

//----- (080B0FF8) --------------------------------------------------------
void __cdecl sub_80B0FF8(int a1)
{
  char *v1; // eax
  char *v2; // eax
  void *ptr; // [esp+10h] [ebp-8h]

  if ( (*(_WORD *)(a1 + 4) & 0x4000) == 0 )
  {
    *(_WORD *)(a1 + 4) |= 0x4000u;
    *(_DWORD *)a1 = Dvar_CopyString(*(char **)a1);
  }
  if ( *(_BYTE *)(a1 + 6) != 7 )
  {
    if ( *(_BYTE *)(a1 + 6) == 2 || *(_BYTE *)(a1 + 6) == 3 || *(_BYTE *)(a1 + 6) == 4 )
      ptr = *(void **)(a1 + 8);
    else
      ptr = 0;
    v1 = Dvar_DisplayableLatchedValue(a1);
    *(_DWORD *)(a1 + 8) = sub_80AF0A8(v1);
    *(_DWORD *)(a1 + 12) = *(_DWORD *)(a1 + 8);
    v2 = Dvar_DisplayableResetValue(a1);
    sub_80AF3AA(a1, v2);
    *(_BYTE *)(a1 + 6) = 7;
    if ( ptr )
      Z_FreeInternal(ptr);
  }
}

//----- (080B10CE) --------------------------------------------------------
void __cdecl sub_80B10CE(int a1, __int16 a2)
{
  if ( (*(_WORD *)(a1 + 4) & 0x4000) == 0 )
  {
    *(_WORD *)(a1 + 4) &= ~a2;
    if ( (*(_WORD *)(a1 + 4) & 0x7000) == 0 )
      sub_80B0FF8(a1);
  }
}

//----- (080B1120) --------------------------------------------------------
int __cdecl sub_80B1120(__int16 a1)
{
  int result; // eax
  int i; // [esp+14h] [ebp-4h]

  result = sortedDvars;
  for ( i = sortedDvars; i; i = result )
  {
    if ( ((unsigned __int16)a1 & *(_WORD *)(i + 4)) != 0 )
      sub_80B10CE(i, a1);
    result = *(_DWORD *)(i + 28);
  }
  return result;
}
// 85178A0: using guessed type int sortedDvars;

//----- (080B1164) --------------------------------------------------------
char *__cdecl sub_80B1164(int a1, char *s1)
{
  char *result; // eax
  int v3; // [esp+14h] [ebp-4h]

  v3 = *(unsigned __int8 *)(a1 + 6);
  if ( v3 == 3 )
    return (char *)sub_80B326C(s1, *(_DWORD **)(a1 + 16));
  if ( *(unsigned __int8 *)(a1 + 6) > 3u )
  {
    if ( v3 == 4 )
      return (char *)sub_80B336A(s1, *(_DWORD **)(a1 + 16));
    if ( v3 == 7 )
    {
      sub_80AF246(a1);
      return sub_80AF3AA(a1, s1);
    }
  }
  else if ( v3 == 2 )
  {
    return (char *)sub_80B31B0(s1, *(_DWORD **)(a1 + 16));
  }
  result = s1;
  *(_DWORD *)(a1 + 16) = s1;
  return result;
}

//----- (080B1208) --------------------------------------------------------
char *__cdecl sub_80B1208(int a1, char *s1)
{
  return sub_80B1164(a1, s1);
}

//----- (080B1222) --------------------------------------------------------
char *__cdecl sub_80B1222(int a1, char *s1)
{
  char *result; // eax
  int v3; // [esp+14h] [ebp-4h]

  v3 = *(unsigned __int8 *)(a1 + 6);
  if ( v3 == 3 )
  {
    sub_80B326C(s1, *(_DWORD **)(a1 + 8));
    return (char *)sub_80B326C(s1, *(_DWORD **)(a1 + 12));
  }
  if ( *(unsigned __int8 *)(a1 + 6) <= 3u )
  {
    if ( v3 == 2 )
    {
      sub_80B31B0(s1, *(_DWORD **)(a1 + 8));
      return (char *)sub_80B31B0(s1, *(_DWORD **)(a1 + 12));
    }
LABEL_13:
    *(_DWORD *)(a1 + 8) = s1;
    result = s1;
    *(_DWORD *)(a1 + 12) = s1;
    return result;
  }
  if ( v3 == 4 )
  {
    sub_80B336A(s1, *(_DWORD **)(a1 + 8));
    return (char *)sub_80B336A(s1, *(_DWORD **)(a1 + 12));
  }
  if ( v3 != 7 )
    goto LABEL_13;
  if ( s1 != *(char **)(a1 + 8) )
  {
    sub_80AF1CE(a1);
    sub_80AF282(a1, s1);
  }
  result = s1;
  *(_DWORD *)(a1 + 12) = s1;
  return result;
}

//----- (080B1334) --------------------------------------------------------
int __usercall sub_80B1334@<eax>(
        long double a1@<st0>,
        int a2,
        int a3,
        char a4,
        unsigned __int16 a5,
        char *s1,
        float a7,
        float a8)
{
  float v8; // edx
  int result; // eax
  char *v10; // [esp+24h] [ebp-24h] BYREF
  char *v11; // [esp+28h] [ebp-20h] BYREF
  char *v12; // [esp+2Ch] [ebp-1Ch]
  float v13; // [esp+30h] [ebp-18h]
  float v14; // [esp+34h] [ebp-14h]
  unsigned __int16 v15; // [esp+3Ch] [ebp-Ch]
  char v16; // [esp+3Fh] [ebp-9h]

  v13 = a7;
  v14 = a8;
  v16 = a4;
  v15 = a5;
  *(_BYTE *)(a2 + 6) = a4;
  v8 = v14;
  *(float *)(a2 + 20) = v13;
  *(float *)(a2 + 24) = v8;
  if ( (v15 & 0x40) != 0 || (v15 & 0x80u) != 0 && dvar_cheats && !*(_BYTE *)(dvar_cheats + 8) )
  {
    v12 = s1;
  }
  else
  {
    sub_80AFA9E(a1, (float *)&v11, *(_BYTE *)(a2 + 6), *(_DWORD *)(a2 + 20), *(_DWORD *)(a2 + 24), *(char **)(a2 + 8));
    v12 = v11;
    sub_80AFCF6((float *)&v10, v16, (int)v11, (int)s1, v13, v14);
    v12 = v10;
  }
  if ( *(_BYTE *)(a2 + 6) != 7 )
    sub_80AF1CE(a2);
  sub_80AF20A(a2);
  sub_80AF246(a2);
  if ( *(_BYTE *)(a2 + 6) == 2 || *(_BYTE *)(a2 + 6) == 3 || *(_BYTE *)(a2 + 6) == 4 )
    sub_80AF012(a2);
  sub_80B1164(a2, s1);
  sub_80B1222(a2, v12);
  result = v15;
  dvar_modifiedFlags |= v15;
  return result;
}
// 85178A4: using guessed type int dvar_cheats;
// 85178A8: using guessed type int dvar_modifiedFlags;

//----- (080B1498) --------------------------------------------------------
_DWORD *__userpurge sub_80B1498@<eax>(_DWORD *a1, int a2, int a3)
{
  *a1 = a3;
  return a1;
}

//----- (080B14CC) --------------------------------------------------------
int __usercall sub_80B14CC@<eax>(
        long double a1@<st0>,
        int a2,
        int a3,
        char a4,
        unsigned __int16 a5,
        int a6,
        int a7,
        int a8)
{
  int result; // eax
  char *v9; // [esp+28h] [ebp-20h] BYREF
  char *s1; // [esp+2Ch] [ebp-1Ch]
  int v11; // [esp+30h] [ebp-18h]
  int v12; // [esp+34h] [ebp-14h]
  unsigned __int16 v13; // [esp+3Ch] [ebp-Ch]
  char v14; // [esp+3Fh] [ebp-9h]

  v11 = a7;
  v12 = a8;
  v14 = a4;
  v13 = a5;
  result = *(_WORD *)(a2 + 4) & 0x4000;
  if ( (*(_WORD *)(a2 + 4) & 0x4000) != 0 )
  {
    result = v13 & 0x4000;
    if ( (v13 & 0x4000) == 0 )
    {
      sub_80B1498(&v9, a2, a6);
      s1 = v9;
      sub_80B0FF8(a2);
      Dvar_FreeNameString(*(void **)a2);
      *(_DWORD *)a2 = a3;
      *(_WORD *)(a2 + 4) &= ~0x4000u;
      return sub_80B1334(a1, a2, a3, v14, v13, s1, *(float *)&v11, *(float *)&v12);
    }
  }
  return result;
}

//----- (080B15C0) --------------------------------------------------------
int __cdecl sub_80B15C0(int a1, int a2, int a3, __int16 a4, int a5, int a6, int a7)
{
  int result; // eax

  result = a4 & 0x4000;
  if ( (a4 & 0x4000) == 0 )
  {
    result = a4 & 0x1000;
    if ( (a4 & 0x1000) != 0 )
    {
      result = *(_WORD *)(a1 + 4) & 0x1000;
      if ( (*(_WORD *)(a1 + 4) & 0x1000) == 0 )
      {
        *(_DWORD *)a1 = a2;
        result = a1;
        if ( *(_BYTE *)(a1 + 6) == 6 )
        {
          result = a6;
          *(_DWORD *)(a1 + 20) = a6;
          *(_DWORD *)(a1 + 24) = a7;
        }
      }
    }
  }
  return result;
}

//----- (080B1634) --------------------------------------------------------
void __cdecl sub_80B1634(int a1)
{
  Dvar_SetVariant((const char **)a1, *(float **)(a1 + 12), 0);
}

//----- (080B165C) --------------------------------------------------------
char *__cdecl sub_80B165C(int a1)
{
  char *result; // eax

  result = (char *)Dvar_HasLatchedValue(a1);
  if ( (_BYTE)result )
    return sub_80B0620(a1, *(char **)(a1 + 8));
  return result;
}

//----- (080B168C) --------------------------------------------------------
void __usercall Dvar_Reregister(
        long double a1@<st0>,
        int a2,
        int a3,
        unsigned __int8 a4,
        unsigned __int16 a5,
        char *s1,
        int a7,
        int a8)
{
  if ( ((*(_WORD *)(a2 + 4) ^ a5) & 0x7000) != 0 )
  {
    sub_80B14CC(a1, a2, a3, a4, a5, (int)s1, a7, a8);
    sub_80B15C0(a2, a3, a4, a5, (int)s1, a7, a8);
  }
  if ( (*(_WORD *)(a2 + 4) & 0x4000) != 0 && *(_BYTE *)(a2 + 6) != a4 )
    sub_80B1334(a1, a2, a3, a4, a5, s1, *(float *)&a7, *(float *)&a8);
  *(_WORD *)(a2 + 4) |= a5;
  if ( *(char *)(a2 + 4) < 0 && dvar_cheats && !*(_BYTE *)(dvar_cheats + 8) )
  {
    Dvar_SetVariant((const char **)a2, *(float **)(a2 + 16), 0);
    sub_80B0620(a2, *(char **)(a2 + 16));
  }
  if ( (*(_WORD *)(a2 + 4) & 0x20) != 0 )
    sub_80B1634(a2);
}
// 85178A4: using guessed type int dvar_cheats;

//----- (080B180C) --------------------------------------------------------
char *__cdecl Dvar_RegisterNew(char *src, unsigned __int8 a2, __int16 a3, char *s, int a5, int a6)
{
  int v6; // eax
  const char ***i; // [esp+18h] [ebp-20h]
  char *v9; // [esp+1Ch] [ebp-1Ch]

  if ( *(int *)dword_8522CC0 > 1279 )
    Com_Error(0, "Can't create dvar '%s': %i dvars already exist", src, 1280);
  v9 = (char *)&unk_85178C0 + 36 * (*(_DWORD *)dword_8522CC0)++;
  v9[6] = a2;
  if ( (a3 & 0x4000) != 0 )
    *(_DWORD *)v9 = Dvar_CopyString(src);
  else
    *(_DWORD *)v9 = src;
  if ( a2 == 3 )
  {
    sub_80AF012((int)v9);
    sub_80B326C(s, *((_DWORD **)v9 + 2));
    sub_80B326C(s, *((_DWORD **)v9 + 3));
    sub_80B326C(s, *((_DWORD **)v9 + 4));
  }
  else if ( a2 > 3u )
  {
    if ( a2 == 4 )
    {
      sub_80AF012((int)v9);
      sub_80B336A(s, *((_DWORD **)v9 + 2));
      sub_80B336A(s, *((_DWORD **)v9 + 3));
      sub_80B336A(s, *((_DWORD **)v9 + 4));
    }
    else
    {
      if ( a2 != 7 )
      {
LABEL_16:
        *((_DWORD *)v9 + 2) = s;
        *((_DWORD *)v9 + 3) = s;
        *((_DWORD *)v9 + 4) = s;
        goto LABEL_17;
      }
      *((_DWORD *)v9 + 2) = sub_80AF0A8(s);
      *((_DWORD *)v9 + 3) = *((_DWORD *)v9 + 2);
      *((_DWORD *)v9 + 4) = *((_DWORD *)v9 + 2);
    }
  }
  else
  {
    if ( a2 != 2 )
      goto LABEL_16;
    sub_80AF012((int)v9);
    sub_80B31B0(s, *((_DWORD **)v9 + 2));
    sub_80B31B0(s, *((_DWORD **)v9 + 3));
    sub_80B31B0(s, *((_DWORD **)v9 + 4));
  }
LABEL_17:
  *((_DWORD *)v9 + 5) = a5;
  *((_DWORD *)v9 + 6) = a6;
  v9[7] = 0;
  for ( i = (const char ***)&sortedDvars; *i && strcasecmp(*(const char **)v9, **i) >= 0; i = (const char ***)(*i + 7) )
    ;
  *((_DWORD *)v9 + 7) = *i;
  *i = (const char **)v9;
  *((_WORD *)v9 + 2) = a3;
  v6 = generateHashValue((int)src);
  *((_DWORD *)v9 + 8) = dword_8522CE0[v6];
  dword_8522CE0[v6] = (int)v9;
  return v9;
}
// 85178A0: using guessed type int sortedDvars;
// 8522CE0: using guessed type int dword_8522CE0[256];

//----- (080B1AC2) --------------------------------------------------------
char *__usercall Dvar_RegisterVariant@<eax>(
        long double a1@<st0>,
        char *src,
        unsigned __int8 a3,
        __int16 a4,
        char *s1,
        int a6,
        int a7)
{
  int v9; // [esp+2Ch] [ebp-1Ch]

  v9 = Dvar_FindMalleableVar(src);
  if ( !v9 )
    return Dvar_RegisterNew(src, a3, a4, s1, a6, a7);
  Dvar_Reregister(a1, v9, (int)src, a3, a4, s1, a6, a7);
  return (char *)v9;
}

//----- (080B1B72) --------------------------------------------------------
char *__usercall Dvar_RegisterBool@<eax>(long double a1@<st0>, char *src, char a3, __int16 a4)
{
  int s[2]; // [esp+18h] [ebp-10h] BYREF
  char *s1; // [esp+20h] [ebp-8h]
  __int16 v7; // [esp+24h] [ebp-4h]
  char v8; // [esp+27h] [ebp-1h]

  v8 = a3;
  v7 = a4;
  LOBYTE(s1) = a3;
  memset(s, 0, sizeof(s));
  return Dvar_RegisterVariant(a1, src, 0, v7, s1, s[0], s[1]);
}

//----- (080B1BDA) --------------------------------------------------------
char *__usercall Dvar_RegisterInt@<eax>(long double a1@<st0>, char *src, char *a3, int a4, int a5, __int16 a6)
{
  return Dvar_RegisterVariant(a1, src, 5u, a6, a3, a4, a5);
}

//----- (080B1C2C) --------------------------------------------------------
char *__usercall Dvar_RegisterFloat@<eax>(long double a1@<st0>, char *src, char *a3, int a4, int a5, __int16 a6)
{
  return Dvar_RegisterVariant(a1, src, 1u, a6, a3, a4, a5);
}

//----- (080B1C7E) --------------------------------------------------------
char *__usercall sub_80B1C7E@<eax>(long double a1@<st0>, char *src, int a3, int a4, int a5, int a6, __int16 a7)
{
  int v8[5]; // [esp+20h] [ebp-18h] BYREF
  __int16 v9; // [esp+36h] [ebp-2h]

  v9 = a7;
  sub_80B3198(v8, a3, a4);
  v8[4] = (int)v8;
  v8[2] = a5;
  v8[3] = a6;
  return Dvar_RegisterVariant(a1, src, 2u, v9, (char *)v8, a5, a6);
}

//----- (080B1CE8) --------------------------------------------------------
char *__usercall sub_80B1CE8@<eax>(long double a1@<st0>, char *src, int a3, int a4, int a5, int a6, int a7, __int16 a8)
{
  int v9[7]; // [esp+20h] [ebp-28h] BYREF
  __int16 v10; // [esp+3Eh] [ebp-Ah]

  v10 = a8;
  sub_80B3248(v9, a3, a4, a5);
  v9[6] = (int)v9;
  v9[4] = a6;
  v9[5] = a7;
  return Dvar_RegisterVariant(a1, src, 3u, v10, (char *)v9, a6, a7);
}

//----- (080B1D5A) --------------------------------------------------------
char *__usercall sub_80B1D5A@<eax>(
        long double a1@<st0>,
        char *src,
        int a3,
        int a4,
        int a5,
        int a6,
        int a7,
        int a8,
        __int16 a9)
{
  int v10[7]; // [esp+20h] [ebp-28h] BYREF
  __int16 v11; // [esp+3Eh] [ebp-Ah]

  v11 = a9;
  sub_80B333C(v10, a3, a4, a5, a6);
  v10[6] = (int)v10;
  v10[4] = a7;
  v10[5] = a8;
  return Dvar_RegisterVariant(a1, src, 4u, v11, (char *)v10, a7, a8);
}

//----- (080B1DD2) --------------------------------------------------------
char *__usercall Dvar_RegisterString@<eax>(long double a1@<st0>, char *src, char *a3, __int16 a4)
{
  int s[2]; // [esp+18h] [ebp-10h] BYREF
  char *s1; // [esp+20h] [ebp-8h]
  __int16 v7; // [esp+26h] [ebp-2h]

  v7 = a4;
  s1 = a3;
  memset(s, 0, sizeof(s));
  return Dvar_RegisterVariant(a1, src, 7u, v7, s1, s[0], s[1]);
}

//----- (080B1E32) --------------------------------------------------------
char *__usercall sub_80B1E32@<eax>(long double a1@<st0>, char *src, int a3, char *a4, __int16 a5)
{
  int i; // [esp+18h] [ebp-10h]

  for ( i = 0; *(_DWORD *)(a3 + 4 * i); ++i )
    ;
  return Dvar_RegisterVariant(a1, src, 6u, a5, a4, i, a3);
}

//----- (080B1EA0) --------------------------------------------------------
char *__usercall sub_80B1EA0@<eax>(long double a1@<st0>, char *src, float a3, float a4, float a5, float a6, __int16 a7)
{
  long double v7; // fst7
  long double v8; // fst7
  long double v9; // fst7
  long double v10; // fst7
  float v12; // [esp+0h] [ebp-28h]
  float v13; // [esp+0h] [ebp-28h]
  float v14; // [esp+0h] [ebp-28h]
  float v15; // [esp+0h] [ebp-28h]
  float v16; // [esp+4h] [ebp-24h]
  float v17; // [esp+4h] [ebp-24h]
  float v18; // [esp+4h] [ebp-24h]
  float v19; // [esp+4h] [ebp-24h]
  int s[2]; // [esp+18h] [ebp-10h] BYREF
  char *s1; // [esp+20h] [ebp-8h]
  __int16 v22; // [esp+26h] [ebp-2h]

  v22 = a7;
  sub_80B3122(1.0, a3);
  v16 = a1;
  sub_80B30FE(0.0, v16);
  v7 = a1 * 255.0;
  v12 = v7;
  LOBYTE(s1) = sub_80B3146(v12);
  sub_80B3122(1.0, a4);
  v17 = v7;
  sub_80B30FE(0.0, v17);
  v8 = v7 * 255.0;
  v13 = v8;
  BYTE1(s1) = sub_80B3146(v13);
  sub_80B3122(1.0, a5);
  v18 = v8;
  sub_80B30FE(0.0, v18);
  v9 = v8 * 255.0;
  v14 = v9;
  BYTE2(s1) = sub_80B3146(v14);
  sub_80B3122(1.0, a6);
  v19 = v9;
  sub_80B30FE(0.0, v19);
  v10 = v9 * 255.0;
  v15 = v10;
  HIBYTE(s1) = sub_80B3146(v15);
  memset(s, 0, sizeof(s));
  return Dvar_RegisterVariant(v10, src, 8u, v22, s1, s[0], s[1]);
}

//----- (080B1FDA) --------------------------------------------------------
void __cdecl Dvar_SetBoolFromSource(int a1, char a2, int a3)
{
  float *v3; // [esp+Ch] [ebp-Ch]
  float *s1; // [esp+10h] [ebp-8h]

  if ( *(_BYTE *)(a1 + 6) )
  {
    if ( a2 )
      v3 = (float *)&unk_8147CE1;
    else
      v3 = (float *)&unk_8147CE3;
    s1 = v3;
  }
  else
  {
    LOBYTE(s1) = a2;
  }
  Dvar_SetVariant((const char **)a1, s1, a3);
}
// 80B2028: variable 's1' is possibly undefined

//----- (080B2030) --------------------------------------------------------
void __cdecl Dvar_SetIntFromSource(int a1, char *a2, int a3)
{
  char s[44]; // [esp+10h] [ebp-38h] BYREF
  char *s1; // [esp+3Ch] [ebp-Ch]

  if ( *(_BYTE *)(a1 + 6) == 5 || *(_BYTE *)(a1 + 6) == 6 )
  {
    s1 = a2;
  }
  else
  {
    Com_sprintf(s, 0x20u, "%i", a2);
    s1 = s;
  }
  Dvar_SetVariant((const char **)a1, (float *)s1, a3);
}
// 80B2030: using guessed type char *arg_4;

//----- (080B2096) --------------------------------------------------------
void __cdecl Dvar_SetFloatFromSource(int a1, char *a2, int a3)
{
  char s[44]; // [esp+20h] [ebp-38h] BYREF
  char *s1; // [esp+4Ch] [ebp-Ch]

  if ( *(_BYTE *)(a1 + 6) == 1 )
  {
    s1 = a2;
  }
  else
  {
    Com_sprintf(s, 0x20u, "%g", *(float *)&a2);
    s1 = s;
  }
  Dvar_SetVariant((const char **)a1, (float *)s1, a3);
}

//----- (080B20F0) --------------------------------------------------------
void __cdecl sub_80B20F0(int a1, int a2, int a3, int a4)
{
  char s[64]; // [esp+20h] [ebp-58h] BYREF
  _DWORD v5[3]; // [esp+60h] [ebp-18h] BYREF
  char *s1; // [esp+6Ch] [ebp-Ch]

  if ( *(_BYTE *)(a1 + 6) == 4 )
  {
    sub_80B3198(v5, a2, a3);
    s1 = (char *)v5;
  }
  else
  {
    Com_sprintf(s, 0x40u, "%g %g", *(float *)&a2, *(float *)&a3);
    s1 = s;
  }
  Dvar_SetVariant((const char **)a1, (float *)s1, a4);
}
// 80B20F0: using guessed type _DWORD var_18[3];

//----- (080B216A) --------------------------------------------------------
void __cdecl sub_80B216A(int a1, int a2, int a3, int a4, int a5)
{
  char s[96]; // [esp+30h] [ebp-88h] BYREF
  _DWORD v6[7]; // [esp+90h] [ebp-28h] BYREF
  char *s1; // [esp+ACh] [ebp-Ch]

  if ( *(_BYTE *)(a1 + 6) == 3 )
  {
    sub_80B3248(v6, a2, a3, a4);
    s1 = (char *)v6;
  }
  else
  {
    Com_sprintf(s, 0x60u, "%g %g %g", *(float *)&a2, *(float *)&a3, *(float *)&a4);
    s1 = s;
  }
  Dvar_SetVariant((const char **)a1, (float *)s1, a5);
}
// 80B216A: using guessed type _DWORD var_28[7];

//----- (080B21FC) --------------------------------------------------------
void __cdecl sub_80B21FC(int a1, int a2, int a3, int a4, int a5, int a6)
{
  char s[128]; // [esp+30h] [ebp-A8h] BYREF
  _DWORD v7[7]; // [esp+B0h] [ebp-28h] BYREF
  char *s1; // [esp+CCh] [ebp-Ch]

  if ( *(_BYTE *)(a1 + 6) == 4 )
  {
    sub_80B333C(v7, a2, a3, a4, a5);
    s1 = (char *)v7;
  }
  else
  {
    Com_sprintf(s, 0x80u, "%g %g %g %g", *(float *)&a2, *(float *)&a3, *(float *)&a4, *(float *)&a5);
    s1 = s;
  }
  Dvar_SetVariant((const char **)a1, (float *)s1, a6);
}
// 80B21FC: using guessed type _DWORD var_28[7];

//----- (080B229C) --------------------------------------------------------
void __cdecl Dvar_SetStringFromSource(int a1, char *src, int a3)
{
  char dest[1036]; // [esp+10h] [ebp-418h] BYREF
  char *s1; // [esp+41Ch] [ebp-Ch]

  if ( *(_BYTE *)(a1 + 6) == 7 )
  {
    I_strncpyz(dest, src, 1024);
    s1 = dest;
  }
  else
  {
    s1 = (char *)Dvar_StringToEnum((int *)(a1 + 20), src);
  }
  Dvar_SetVariant((const char **)a1, (float *)s1, a3);
}

//----- (080B230A) --------------------------------------------------------
void __usercall sub_80B230A(long double a1@<st0>, int a2, float a3, float a4, float a5, float a6, int a7)
{
  long double v7; // fst7
  long double v8; // fst7
  long double v9; // fst7
  float v10; // [esp+0h] [ebp-C8h]
  float v11; // [esp+0h] [ebp-C8h]
  float v12; // [esp+0h] [ebp-C8h]
  float v13; // [esp+0h] [ebp-C8h]
  float v14; // [esp+4h] [ebp-C4h]
  float v15; // [esp+4h] [ebp-C4h]
  float v16; // [esp+4h] [ebp-C4h]
  float v17; // [esp+4h] [ebp-C4h]
  char s[140]; // [esp+30h] [ebp-98h] BYREF
  char *s1; // [esp+BCh] [ebp-Ch]

  if ( *(_BYTE *)(a2 + 6) == 8 )
  {
    sub_80B3122(1.0, a3);
    v14 = a1;
    sub_80B30FE(0.0, v14);
    v7 = a1 * 255.0;
    v10 = v7;
    LOBYTE(s1) = sub_80B3146(v10);
    sub_80B3122(1.0, a4);
    v15 = v7;
    sub_80B30FE(0.0, v15);
    v8 = v7 * 255.0;
    v11 = v8;
    BYTE1(s1) = sub_80B3146(v11);
    sub_80B3122(1.0, a5);
    v16 = v8;
    sub_80B30FE(0.0, v16);
    v9 = v8 * 255.0;
    v12 = v9;
    BYTE2(s1) = sub_80B3146(v12);
    sub_80B3122(1.0, a6);
    v17 = v9;
    sub_80B30FE(0.0, v17);
    v13 = v9 * 255.0;
    HIBYTE(s1) = sub_80B3146(v13);
  }
  else
  {
    Com_sprintf(s, 0x80u, "%g %g %g %g", a3, a4, a5, a6);
    s1 = s;
  }
  Dvar_SetVariant((const char **)a2, (float *)s1, a7);
}

//----- (080B2460) --------------------------------------------------------
void __cdecl Dvar_SetBool(int a1, char a2)
{
  Dvar_SetBoolFromSource(a1, a2, 0);
}

//----- (080B248A) --------------------------------------------------------
void __cdecl Dvar_SetInt(int a1, char *a2)
{
  Dvar_SetIntFromSource(a1, a2, 0);
}

//----- (080B24AC) --------------------------------------------------------
void __cdecl Dvar_SetFloat(int a1, char *a2)
{
  Dvar_SetFloatFromSource(a1, a2, 0);
}

//----- (080B24CE) --------------------------------------------------------
void __cdecl sub_80B24CE(int a1, int a2, int a3)
{
  sub_80B20F0(a1, a2, a3, 0);
}

//----- (080B24F8) --------------------------------------------------------
void __cdecl sub_80B24F8(int a1, int a2, int a3, int a4)
{
  sub_80B216A(a1, a2, a3, a4, 0);
}

//----- (080B2528) --------------------------------------------------------
void __cdecl sub_80B2528(int a1, int a2, int a3, int a4, int a5)
{
  sub_80B21FC(a1, a2, a3, a4, a5, 0);
}

//----- (080B2560) --------------------------------------------------------
void __cdecl Dvar_SetString(int a1, char *src)
{
  Dvar_SetStringFromSource(a1, src, 0);
}

//----- (080B2582) --------------------------------------------------------
void __usercall sub_80B2582(long double a1@<st0>, int a2, float a3, float a4, float a5, float a6)
{
  sub_80B230A(a1, a2, a3, a4, a5, a6, 0);
}

//----- (080B25BA) --------------------------------------------------------
void __usercall Dvar_SetFromStringFromSource(long double a1@<st0>, const char **a2, char *src, int a4)
{
  char *v4; // [esp+2Ch] [ebp-41Ch] BYREF
  char dest[1036]; // [esp+30h] [ebp-418h] BYREF
  char *s1; // [esp+43Ch] [ebp-Ch]

  I_strncpyz(dest, src, 1024);
  sub_80AFA9E(a1, (float *)&v4, *((_BYTE *)a2 + 6), (int)a2[5], (int)a2[6], dest);
  s1 = v4;
  if ( *((_BYTE *)a2 + 6) == 6 && s1 == (char *)-1337 )
  {
    Com_Printf("'%s' is not a valid value for dvar '%s'\n", dest, *a2);
    Dvar_PrintDomain(*((_BYTE *)a2 + 6), (int)a2[5], (int)a2[6]);
    s1 = (char *)a2[4];
  }
  Dvar_SetVariant(a2, (float *)s1, a4);
}

//----- (080B269C) --------------------------------------------------------
void __usercall Dvar_SetFromString(long double a1@<st0>, const char **a2, char *src)
{
  Dvar_SetFromStringFromSource(a1, a2, src, 0);
}

//----- (080B26BE) --------------------------------------------------------
void __usercall Dvar_SetBoolByName(long double a1@<st0>, char *src, char a3)
{
  int v3; // [esp+10h] [ebp-8h]

  v3 = Dvar_FindVar(src);
  if ( v3 )
  {
    Dvar_SetBool(v3, a3);
  }
  else if ( a3 )
  {
    Dvar_RegisterString(a1, src, "1", 0x4000);
  }
  else
  {
    Dvar_RegisterString(a1, src, "0", 0x4000);
  }
}

//----- (080B2726) --------------------------------------------------------
void __usercall Dvar_SetIntByName(long double a1@<st0>, char *src, char *a3)
{
  char s[44]; // [esp+10h] [ebp-38h] BYREF
  int v4; // [esp+3Ch] [ebp-Ch]

  v4 = Dvar_FindVar(src);
  if ( v4 )
  {
    Dvar_SetInt(v4, a3);
  }
  else
  {
    Com_sprintf(s, 0x20u, "%i", a3);
    Dvar_RegisterString(a1, src, s, 0x4000);
  }
}

//----- (080B2792) --------------------------------------------------------
void __cdecl Dvar_SetFloatByName(char *src, char *a2)
{
  char *v2; // eax
  int v3; // [esp+14h] [ebp-4h]

  v3 = Dvar_FindVar(src);
  if ( v3 )
  {
    Dvar_SetFloat(v3, a2);
  }
  else
  {
    v2 = va("%g", *(float *)&a2);
    Dvar_RegisterString(*(float *)&a2, src, v2, 0x4000);
  }
}

//----- (080B27EC) --------------------------------------------------------
void __cdecl sub_80B27EC(char *src, int a2, int a3)
{
  char *v3; // eax
  int v4; // [esp+14h] [ebp-4h]

  v4 = Dvar_FindVar(src);
  if ( v4 )
  {
    sub_80B24CE(v4, a2, a3);
  }
  else
  {
    v3 = va("%g %g", *(float *)&a2, *(float *)&a3);
    Dvar_RegisterString(*(float *)&a2, src, v3, 0x4000);
  }
}

//----- (080B2854) --------------------------------------------------------
void __cdecl sub_80B2854(char *src, int a2, int a3, int a4)
{
  char *v4; // eax
  int v5; // [esp+24h] [ebp-4h]

  v5 = Dvar_FindVar(src);
  if ( v5 )
  {
    sub_80B24F8(v5, a2, a3, a4);
  }
  else
  {
    v4 = va("%g %g %g", *(float *)&a2, *(float *)&a3, *(float *)&a4);
    Dvar_RegisterString(*(float *)&a2, src, v4, 0x4000);
  }
}

//----- (080B28CA) --------------------------------------------------------
void __cdecl sub_80B28CA(char *src, int a2, int a3, int a4, int a5)
{
  char *v5; // eax
  int v6; // [esp+24h] [ebp-4h]

  v6 = Dvar_FindVar(src);
  if ( v6 )
  {
    sub_80B2528(v6, a2, a3, a4, a5);
  }
  else
  {
    v5 = va("%g %g %g %g", *(float *)&a2, *(float *)&a3, *(float *)&a4, *(float *)&a5);
    Dvar_RegisterString(*(float *)&a2, src, v5, 0x4000);
  }
}

//----- (080B294E) --------------------------------------------------------
void __usercall Dvar_SetStringByName(long double a1@<st0>, char *src, char *a3)
{
  int v3; // [esp+14h] [ebp-4h]

  v3 = Dvar_FindVar(src);
  if ( v3 )
    Dvar_SetString(v3, a3);
  else
    Dvar_RegisterString(a1, src, a3, 0x4000);
}

//----- (080B2998) --------------------------------------------------------
void __usercall sub_80B2998(
        long double a1@<st0>,
        char *src,
        unsigned __int8 a3,
        unsigned __int8 a4,
        unsigned __int8 a5,
        unsigned __int8 a6)
{
  long double v6; // fst7
  char *v7; // eax
  float v8; // [esp+4h] [ebp-24h]
  double v9; // [esp+4h] [ebp-24h]
  float v10; // [esp+8h] [ebp-20h]
  float v11; // [esp+Ch] [ebp-1Ch]
  double v12; // [esp+Ch] [ebp-1Ch]
  float v13; // [esp+10h] [ebp-18h]
  double v14; // [esp+14h] [ebp-14h]
  double v15; // [esp+1Ch] [ebp-Ch]

  HIBYTE(v15) = a3;
  BYTE6(v15) = a4;
  BYTE5(v15) = a5;
  BYTE4(v15) = a6;
  LODWORD(v15) = Dvar_FindVar(src);
  if ( LODWORD(v15) )
  {
    v13 = (float)a6;
    v11 = (float)a5;
    v10 = (float)a4;
    v6 = (long double)a3;
    v8 = v6;
    sub_80B2582(v6, SLODWORD(v15), v8, v10, v11, v13);
  }
  else
  {
    HIDWORD(v12) = a6;
    LODWORD(v12) = a5;
    HIDWORD(v9) = a4;
    LODWORD(v9) = a3;
    v7 = va("%g %g %g %g", v9, v12, v14, v15);
    Dvar_RegisterString(a1, src, v7, 0x4000);
  }
}
// 80B2A47: variable 'v14' is possibly undefined

//----- (080B2A6A) --------------------------------------------------------
char *__usercall sub_80B2A6A@<eax>(long double a1@<st0>, char *src, char *a3, int a4)
{
  const char **v5; // [esp+14h] [ebp-4h]

  v5 = (const char **)Dvar_FindVar(src);
  if ( !v5 )
    return Dvar_RegisterString(a1, src, a3, 0x4000);
  Dvar_SetFromStringFromSource(a1, v5, a3, a4);
  return (char *)v5;
}

//----- (080B2AC2) --------------------------------------------------------
char *__usercall sub_80B2AC2@<eax>(long double a1@<st0>, char *src, char *a3)
{
  return sub_80B2A6A(a1, src, a3, 0);
}

//----- (080B2AE4) --------------------------------------------------------
char *__usercall Dvar_SetCommand@<eax>(long double a1@<st0>, char *src, char *a3)
{
  char *result; // eax
  char *v4; // [esp+14h] [ebp-4h]

  result = sub_80B2A6A(a1, src, a3, 1);
  v4 = result;
  if ( result )
  {
    if ( isLoadingAutoExecGlobalFlag )
    {
      Dvar_AddFlags((int)result, 0x8000);
      return sub_80B1164((int)v4, *((char **)v4 + 2));
    }
  }
  return result;
}
// 8523115: using guessed type char isLoadingAutoExecGlobalFlag;

//----- (080B2B42) --------------------------------------------------------
int __cdecl Dvar_AddFlags(int a1, int a2)
{
  int v2; // edx
  int result; // eax

  v2 = *(unsigned __int16 *)(a1 + 4);
  result = v2 | a2;
  *(_WORD *)(a1 + 4) = v2 | a2;
  return result;
}

//----- (080B2B5A) --------------------------------------------------------
void __cdecl Dvar_Reset(int a1, int a2)
{
  Dvar_SetVariant((const char **)a1, *(float **)(a1 + 16), a2);
}

//----- (080B2B80) --------------------------------------------------------
int sub_80B2B80()
{
  int result; // eax
  int i; // [esp+14h] [ebp-4h]

  result = sortedDvars;
  for ( i = sortedDvars; i; i = result )
  {
    if ( *(char *)(i + 4) < 0 )
      Dvar_SetVariant((const char **)i, *(float **)(i + 16), 0);
    result = *(_DWORD *)(i + 28);
  }
  return result;
}
// 85178A0: using guessed type int sortedDvars;

//----- (080B2BD0) --------------------------------------------------------
void __usercall Dvar_Init(long double a1@<st0>)
{
  isDvarSystemActive = 1;
  dvar_cheats = (int)Dvar_RegisterBool(a1, "sv_cheats", 0, 4120);
  Dvar_AddCommands();
}
// 85178A4: using guessed type int dvar_cheats;
// 8523114: using guessed type char isDvarSystemActive;

//----- (080B2C06) --------------------------------------------------------
_WORD *sub_80B2C06()
{
  _WORD *result; // eax
  _WORD *i; // [esp+0h] [ebp-4h]

  for ( i = &unk_85178C0; i; i = result )
  {
    i[2] &= ~0x400u;
    result = (_WORD *)*((_DWORD *)i + 7);
  }
  return result;
}

//----- (080B2C3C) --------------------------------------------------------
int sub_80B2C3C()
{
  int i; // [esp+14h] [ebp-4h]

  for ( i = sortedDvars; i; i = *(_DWORD *)(i + 28) )
  {
    if ( (unsigned __int8)Dvar_HasLatchedValue(i) )
      return 1;
  }
  return 0;
}
// 85178A0: using guessed type int sortedDvars;

//----- (080B2C82) --------------------------------------------------------
size_t __cdecl sub_80B2C82(int a1, unsigned __int16 a2)
{
  size_t v3; // [esp+8h] [ebp-10h]
  size_t v4; // [esp+8h] [ebp-10h]
  unsigned int i; // [esp+Ch] [ebp-Ch]
  char *src; // [esp+10h] [ebp-8h]
  int j; // [esp+14h] [ebp-4h]

  v3 = 0;
  for ( i = 0; i <= 0xFF; ++i )
  {
    for ( j = dword_8522CE0[i]; j; j = *(_DWORD *)(j + 32) )
    {
      if ( (a2 & *(_WORD *)(j + 4)) != 0 )
      {
        if ( a1 )
          strcpy((char *)(a1 + v3), *(const char **)j);
        v4 = v3 + I_strlen(*(char **)j) + 1;
        src = Dvar_DisplayableValue(j);
        if ( a1 )
          strcpy((char *)(a1 + v4), src);
        v3 = v4 + I_strlen(src) + 1;
      }
    }
  }
  return v3;
}
// 8522CE0: using guessed type int dword_8522CE0[256];

//----- (080B2D56) --------------------------------------------------------
int __usercall sub_80B2D56@<eax>(long double a1@<st0>, int a2, int a3)
{
  int result; // eax
  size_t v4; // eax
  size_t v5; // eax
  float *v6; // [esp+20h] [ebp-18h] BYREF
  int v7; // [esp+24h] [ebp-14h]
  char *s1; // [esp+28h] [ebp-10h]
  char *v9; // [esp+2Ch] [ebp-Ch]
  char *s; // [esp+30h] [ebp-8h]
  int v11; // [esp+34h] [ebp-4h]

  v11 = 0;
  while ( 1 )
  {
    result = v11;
    if ( v11 >= a3 )
      break;
    s = (char *)(a2 + v11);
    v4 = I_strlen((char *)(a2 + v11));
    v11 += v4 + 1;
    v9 = (char *)(a2 + v11);
    v5 = I_strlen((char *)(a2 + v11));
    v11 += v5 + 1;
    v7 = Dvar_FindMalleableVar(s);
    if ( v7 )
    {
      sub_80AFA9E(a1, (float *)&v6, *(_BYTE *)(v7 + 6), *(_DWORD *)(v7 + 20), *(_DWORD *)(v7 + 24), v9);
      s1 = (char *)v6;
      Dvar_SetVariant((const char **)v7, v6, 0);
    }
    else
    {
      Dvar_RegisterString(a1, s, v9, 0x4000);
    }
  }
  return result;
}

//----- (080B2E34) --------------------------------------------------------
int __cdecl sub_80B2E34(unsigned __int16 a1, int a2)
{
  int result; // eax
  int i; // [esp+14h] [ebp-4h]

  result = sortedDvars;
  for ( i = sortedDvars; i; i = result )
  {
    if ( (a1 & *(_WORD *)(i + 4)) != 0 )
      Dvar_Reset(i, a2);
    result = *(_DWORD *)(i + 28);
  }
  return result;
}
// 85178A0: using guessed type int sortedDvars;

//----- (080B2E78) --------------------------------------------------------
int __cdecl sub_80B2E78(int a1, int a2, char *s, size_t maxlen)
{
  char *v6; // [esp+18h] [ebp-10h]
  const char **v7; // [esp+1Ch] [ebp-Ch]
  int v8; // [esp+20h] [ebp-8h]
  int i; // [esp+24h] [ebp-4h]

  for ( i = 0; i < a2; ++i )
  {
    v7 = (const char **)Dvar_FindVar(*(char **)(a1 + 4 * i));
    v6 = Dvar_DisplayableValue((int)v7);
    v8 = snprintf(s, maxlen, "%s \"%s\"\n", *v7, v6);
    if ( v8 < 0 )
      return 0;
    s += v8;
    maxlen -= v8;
  }
  return 1;
}

//----- (080B2F1A) --------------------------------------------------------
int __usercall sub_80B2F1A@<eax>(long double a1@<st0>, int a2, int n, char *a4, char *src)
{
  char s[16384]; // [esp+20h] [ebp-4018h] BYREF
  int v8; // [esp+4020h] [ebp-18h]
  int v9; // [esp+4024h] [ebp-14h]
  char *s1; // [esp+4028h] [ebp-10h]
  int i; // [esp+402Ch] [ebp-Ch]

  memset(s, 0, n);
  v8 = 0;
  for ( i = 0; i < n; ++i )
  {
    v9 = Dvar_FindVar(*(char **)(a2 + 4 * i));
    Dvar_Reset(v9, 0);
  }
  Com_BeginParseSession(src);
  while ( 1 )
  {
    s1 = Com_Parse(&a4);
    if ( !*s1 )
      break;
    for ( i = 0; ; ++i )
    {
      if ( i >= n )
      {
        Com_Printf("^3WARNING: unknown dvar '%s' in file '%s'\n", s1, src);
        goto LABEL_13;
      }
      if ( !strcasecmp(s1, *(const char **)(a2 + 4 * i)) )
        break;
    }
    v9 = Dvar_FindVar(*(char **)(a2 + 4 * i));
    s1 = Com_ParseOnLine(&a4);
    Dvar_SetFromString(a1, (const char **)v9, s1);
    if ( !s[i] )
    {
      s[i] = 1;
      ++v8;
    }
LABEL_13:
    Com_SkipRestOfLine(&a4);
  }
  Com_EndParseSession();
  if ( v8 == n )
    return 1;
  Com_Printf("^1ERROR: the following dvars were not specified in file '%s'\n", src);
  for ( i = 0; i < n; ++i )
  {
    if ( !s[i] )
      Com_Printf("^1  %s\n", *(const char **)(a2 + 4 * i));
  }
  return 0;
}
// 80B2F1A: using guessed type char s[16384];

//----- (080B30FE) --------------------------------------------------------
void __cdecl sub_80B30FE(float a1, float a2)
{
  float v2; // [esp+0h] [ebp-18h]

  v2 = a1 - a2;
  sub_80B34F0(v2, a1, a2);
}

//----- (080B3122) --------------------------------------------------------
void __cdecl sub_80B3122(float a1, float a2)
{
  float v2; // [esp+0h] [ebp-18h]

  v2 = a2 - a1;
  sub_80B34F0(v2, a1, a2);
}

//----- (080B3146) --------------------------------------------------------
int __cdecl sub_80B3146(float a1)
{
  return (int)floor(a1 + 0.5);
}

//----- (080B317C) --------------------------------------------------------
int __cdecl sub_80B317C(_DWORD *a1)
{
  int result; // eax

  *a1 = 0;
  result = 0;
  a1[1] = 0;
  return result;
}

//----- (080B3198) --------------------------------------------------------
int __cdecl sub_80B3198(_DWORD *a1, int a2, int a3)
{
  int result; // eax

  *a1 = a2;
  result = a3;
  a1[1] = a3;
  return result;
}

//----- (080B31B0) --------------------------------------------------------
int __cdecl sub_80B31B0(_DWORD *a1, _DWORD *a2)
{
  int result; // eax

  *a2 = *a1;
  result = a1[1];
  a2[1] = result;
  return result;
}

//----- (080B31D0) --------------------------------------------------------
int __cdecl sub_80B31D0(float *a1, float *a2)
{
  int v3; // [esp+0h] [ebp-4h]

  v3 = 0;
  if ( *a1 == *a2 && a1[1] == a2[1] )
    return 1;
  return v3;
}

//----- (080B321E) --------------------------------------------------------
int __cdecl sub_80B321E(_DWORD *a1)
{
  int result; // eax

  *a1 = 0;
  a1[1] = 0;
  result = 0;
  a1[2] = 0;
  return result;
}

//----- (080B3248) --------------------------------------------------------
int __cdecl sub_80B3248(_DWORD *a1, int a2, int a3, int a4)
{
  int result; // eax

  *a1 = a2;
  a1[1] = a3;
  result = a4;
  a1[2] = a4;
  return result;
}

//----- (080B326C) --------------------------------------------------------
int __cdecl sub_80B326C(_DWORD *a1, _DWORD *a2)
{
  int result; // eax

  *a2 = *a1;
  a2[1] = a1[1];
  result = a1[2];
  a2[2] = result;
  return result;
}

//----- (080B329C) --------------------------------------------------------
int __cdecl sub_80B329C(float *a1, float *a2)
{
  int v3; // [esp+0h] [ebp-4h]

  v3 = 0;
  if ( *a1 == *a2 && a1[1] == a2[1] && a1[2] == a2[2] )
    return 1;
  return v3;
}

//----- (080B3306) --------------------------------------------------------
int __cdecl sub_80B3306(_DWORD *a1)
{
  int result; // eax

  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  result = 0;
  a1[3] = 0;
  return result;
}

//----- (080B333C) --------------------------------------------------------
int __cdecl sub_80B333C(_DWORD *a1, int a2, int a3, int a4, int a5)
{
  int result; // eax

  *a1 = a2;
  a1[1] = a3;
  a1[2] = a4;
  result = a5;
  a1[3] = a5;
  return result;
}

//----- (080B336A) --------------------------------------------------------
int __cdecl sub_80B336A(_DWORD *a1, _DWORD *a2)
{
  int result; // eax

  *a2 = *a1;
  a2[1] = a1[1];
  a2[2] = a1[2];
  result = a1[3];
  a2[3] = result;
  return result;
}

//----- (080B33AA) --------------------------------------------------------
int __cdecl sub_80B33AA(float *a1, float *a2)
{
  int v3; // [esp+0h] [ebp-4h]

  v3 = 0;
  if ( *a1 == *a2 && a1[1] == a2[1] && a1[2] == a2[2] && a1[3] == a2[3] )
    return 1;
  return v3;
}

//----- (080B3432) --------------------------------------------------------
_DWORD *__cdecl sub_80B3432(_DWORD *a1, _DWORD *a2)
{
  _DWORD *result; // eax

  result = a2;
  *a2 = *a1;
  return result;
}

//----- (080B3442) --------------------------------------------------------
_BOOL4 __cdecl sub_80B3442(_DWORD *a1, _DWORD *a2)
{
  return *a1 == *a2;
}

//----- (080B3458) --------------------------------------------------------
int __cdecl sub_80B3458(_BYTE *a1, _BYTE *a2, int a3)
{
  char v6; // [esp+16h] [ebp-2h]
  char v7; // [esp+17h] [ebp-1h]

  while ( a3 && *a1 )
  {
    v7 = tolower((char)*a1);
    v6 = tolower((char)*a2);
    --a3;
    ++a1;
    ++a2;
    if ( v7 < v6 )
      return -1;
    if ( v7 > v6 )
      return 1;
  }
  if ( !a3 || *a1 == *a2 )
    return 0;
  else
    return -1;
}

//----- (080B34F0) --------------------------------------------------------
long double __cdecl sub_80B34F0(float a1, float a2, float a3)
{
  if ( a1 < 0.0 )
    return a3;
  return a2;
}

//----- (080B351C) --------------------------------------------------------
int __cdecl sub_80B351C(int a1, size_t n, void *src)
{
  return sub_80B3636(a1, n, src);
}

//----- (080B353E) --------------------------------------------------------
int __cdecl sub_80B353E(int a1, int a2, int a3, char a4)
{
  int result; // eax

  *(_DWORD *)a1 = a3;
  *(_DWORD *)(a1 + 4) = a2;
  *(_DWORD *)(a1 + 8) = 0;
  *(_BYTE *)(a1 + 12) = a4;
  result = a1;
  *(_BYTE *)(a1 + 13) = 0;
  return result;
}

//----- (080B35E6) --------------------------------------------------------
void *__cdecl sub_80B35E6(void *s)
{
  return memset(s, 0, 4u);
}

//----- (080B3636) --------------------------------------------------------
int __cdecl sub_80B3636(int a1, size_t n, void *src)
{
  int result; // eax

  if ( n )
  {
    result = a1;
    if ( !*(_BYTE *)(a1 + 13) )
    {
      if ( (signed int)(*(_DWORD *)(a1 + 8) + n) <= *(_DWORD *)(a1 + 4) )
      {
        memcpy((void *)(*(_DWORD *)a1 + *(_DWORD *)(a1 + 8)), src, n);
        result = *(_DWORD *)(a1 + 8) + n;
        *(_DWORD *)(a1 + 8) = result;
      }
      else
      {
        if ( *(_BYTE *)(a1 + 12) )
          Com_Error(
            1,
            "Couldn't write %i bytes to %i-byte buffer (only %i bytes free)\n",
            n,
            *(_DWORD *)(a1 + 4),
            *(_DWORD *)(a1 + 4) - *(_DWORD *)(a1 + 8));
        result = a1;
        *(_BYTE *)(a1 + 13) = 1;
      }
    }
  }
  return result;
}

//----- (080B36E4) --------------------------------------------------------
int __cdecl sub_80B36E4(int a1, char *s)
{
  size_t v2; // eax

  v2 = strlen(s);
  return sub_80B3636(a1, v2 + 1, s);
}

//----- (080B3710) --------------------------------------------------------
int __cdecl sub_80B3710(int a1, int a2)
{
  int result; // eax

  if ( a2 )
  {
    result = a1;
    if ( !*(_BYTE *)(a1 + 13) )
    {
      if ( *(_DWORD *)(a1 + 8) + a2 <= *(_DWORD *)(a1 + 4) )
      {
        result = *(_DWORD *)(a1 + 8) + a2;
        *(_DWORD *)(a1 + 8) = result;
      }
      else
      {
        if ( *(_BYTE *)(a1 + 12) )
          Com_Error(
            1,
            "Couldn't skip %i bytes from %i-byte buffer (only %i bytes left)\n",
            a2,
            *(_DWORD *)(a1 + 4),
            *(_DWORD *)(a1 + 4) - *(_DWORD *)(a1 + 8));
        result = a1;
        *(_BYTE *)(a1 + 13) = 1;
      }
    }
  }
  return result;
}

//----- (080B3796) --------------------------------------------------------
int __cdecl MemFile_ReadData(int a1, size_t n, void *dest)
{
  int result; // eax

  if ( n )
  {
    result = a1;
    if ( !*(_BYTE *)(a1 + 13) )
    {
      if ( (signed int)(*(_DWORD *)(a1 + 8) + n) <= *(_DWORD *)(a1 + 4) )
      {
        memcpy(dest, (const void *)(*(_DWORD *)a1 + *(_DWORD *)(a1 + 8)), n);
        result = *(_DWORD *)(a1 + 8) + n;
        *(_DWORD *)(a1 + 8) = result;
      }
      else
      {
        if ( *(_BYTE *)(a1 + 12) )
          Com_Error(
            1,
            "Couldn't read %i bytes from %i-byte buffer (only %i bytes left)\n",
            n,
            *(_DWORD *)(a1 + 4),
            *(_DWORD *)(a1 + 4) - *(_DWORD *)(a1 + 8));
        result = a1;
        *(_BYTE *)(a1 + 13) = 1;
      }
    }
  }
  return result;
}

//----- (080B3844) --------------------------------------------------------
void *__cdecl MemFile_ReadCString(int a1)
{
  int v3; // [esp+14h] [ebp-4h]

  if ( *(_BYTE *)(a1 + 13) )
    return &unk_81483E1;
  v3 = *(_DWORD *)(a1 + 8);
  do
  {
    if ( !*(_BYTE *)(*(_DWORD *)a1 + *(_DWORD *)(a1 + 8)) )
    {
      ++*(_DWORD *)(a1 + 8);
      return (void *)(*(_DWORD *)a1 + v3);
    }
    ++*(_DWORD *)(a1 + 8);
  }
  while ( *(_DWORD *)(a1 + 8) != *(_DWORD *)(a1 + 4) );
  if ( *(_BYTE *)(a1 + 12) )
    Com_Error(1, "End of memory file while reading string (%i bytes read)\n", *(_DWORD *)(a1 + 8) - v3);
  *(_BYTE *)(a1 + 13) = 1;
  return &unk_81483E1;
}

//----- (080B38E8) --------------------------------------------------------
void *Com_GetParseThreadInfo()
{
  return &unk_815DF80;
}

//----- (080B38F2) --------------------------------------------------------
int __cdecl Com_InitParseInfo(int a1)
{
  int result; // eax

  *(_DWORD *)(a1 + 1024) = 1;
  *(_BYTE *)(a1 + 1028) = 0;
  *(_BYTE *)(a1 + 1029) = 1;
  *(_BYTE *)(a1 + 1030) = 0;
  *(_BYTE *)(a1 + 1031) = 0;
  *(_BYTE *)(a1 + 1032) = 0;
  *(_DWORD *)(a1 + 1036) = &unk_814846A;
  *(_DWORD *)(a1 + 1040) = &unk_814846A;
  *(_DWORD *)(a1 + 1044) = 0;
  result = a1;
  *(_DWORD *)(a1 + 1048) = 0;
  return result;
}

//----- (080B396A) --------------------------------------------------------
char *__cdecl Com_BeginParseSession(char *src)
{
  int v2; // [esp+Ch] [ebp-Ch]
  const char *v3; // [esp+10h] [ebp-8h]
  int i; // [esp+14h] [ebp-4h]

  v3 = (const char *)Com_GetParseThreadInfo();
  if ( *((_DWORD *)v3 + 4464) == 15 )
  {
    Com_Printf("Already parsing:\n");
    for ( i = 0; i < *((_DWORD *)v3 + 4464); ++i )
      Com_Printf("%i. %s\n", i, &v3[1116 * i + 1052]);
    Com_Error(0, (char *)&byte_81484A0, src);
  }
  ++*((_DWORD *)v3 + 4464);
  v2 = (int)&v3[1116 * *((_DWORD *)v3 + 4464)];
  Com_InitParseInfo(v2);
  return I_strncpyz((char *)(v2 + 1052), src, 64);
}

//----- (080B3A3C) --------------------------------------------------------
_DWORD *Com_EndParseSession()
{
  _DWORD *result; // eax
  _DWORD *v1; // [esp+14h] [ebp-4h]

  v1 = Com_GetParseThreadInfo();
  if ( !v1[4464] )
    Com_Error(0, (char *)&byte_81484E0);
  result = v1;
  --v1[4464];
  return result;
}

//----- (080B3A76) --------------------------------------------------------
_DWORD *Com_ResetParseSessions()
{
  _DWORD *result; // eax

  result = Com_GetParseThreadInfo();
  result[4464] = 0;
  return result;
}

//----- (080B3B00) --------------------------------------------------------
bool __cdecl sub_80B3B00(int a1)
{
  bool result; // al
  _BYTE *v2; // [esp+4h] [ebp-4h]

  v2 = Com_GetParseThreadInfo();
  result = a1 != 0;
  v2[1116 * *((_DWORD *)v2 + 4464) + 1031] = a1 != 0;
  return result;
}

//----- (080B3B6C) --------------------------------------------------------
int sub_80B3B6C()
{
  _DWORD *v0; // eax

  v0 = Com_GetParseThreadInfo();
  return v0[279 * v0[4464] + 256];
}

//----- (080B3BFE) --------------------------------------------------------
void __noreturn Com_ScriptErrorDrop(char *format, ...)
{
  char *v1; // [esp+28h] [ebp-1020h]
  _DWORD *v2; // [esp+2Ch] [ebp-101Ch]
  char s[4108]; // [esp+30h] [ebp-1018h] BYREF
  __gnuc_va_list __varargs; // [esp+103Ch] [ebp-Ch]
  va_list va; // [esp+1054h] [ebp+Ch] BYREF

  va_start(va, format);
  v2 = Com_GetParseThreadInfo();
  v1 = (char *)&v2[279 * v2[4464]];
  va_copy(__varargs, va);
  vsprintf(s, format, va);
  if ( v2[4464] )
    Com_Error(1, (char *)&byte_8148508, *((_DWORD *)v1 + 259), v1 + 1052, *((_DWORD *)v1 + 256), s);
  Com_Error(1, (char *)&byte_8148520, s);
}

//----- (080B3CD0) --------------------------------------------------------
void Com_ScriptWarning(char *format, ...)
{
  const char **v1; // [esp+28h] [ebp-1020h]
  _DWORD *v2; // [esp+2Ch] [ebp-101Ch]
  char s[4108]; // [esp+30h] [ebp-1018h] BYREF
  __gnuc_va_list __varargs; // [esp+103Ch] [ebp-Ch]
  va_list va; // [esp+1054h] [ebp+Ch] BYREF

  va_start(va, format);
  v2 = Com_GetParseThreadInfo();
  v1 = (const char **)&v2[279 * v2[4464]];
  va_copy(__varargs, va);
  vsprintf(s, format, va);
  if ( v2[4464] )
    Com_Printf("%sFile %s, line %i: %s", v1[260], (const char *)v1 + 1052, v1[256], s);
  else
    Com_Printf("%s", s);
}

//----- (080B3D92) --------------------------------------------------------
int Com_UngetToken()
{
  int result; // eax
  _DWORD *v1; // [esp+10h] [ebp-8h]
  _DWORD *v2; // [esp+14h] [ebp-4h]

  v2 = Com_GetParseThreadInfo();
  v1 = &v2[279 * v2[4464]];
  if ( *((_BYTE *)v1 + 1028) )
    Com_ScriptErrorDrop("UngetToken called twice");
  *((_BYTE *)v1 + 1028) = 1;
  result = v2[4466];
  v2[4465] = result;
  return result;
}

//----- (080B3DEC) --------------------------------------------------------
int __cdecl Com_ParseSetMark(_DWORD *a1, _DWORD *a2)
{
  int v2; // eax
  int result; // eax
  _DWORD *v4; // [esp+4h] [ebp-4h]

  v4 = Com_GetParseThreadInfo();
  v2 = 279 * v4[4464];
  *a2 = v4[v2 + 256];
  a2[1] = *a1;
  a2[2] = LOBYTE(v4[v2 + 257]);
  a2[3] = v4[v2 + 261];
  result = v4[v2 + 262];
  a2[4] = result;
  return result;
}

//----- (080B3E58) --------------------------------------------------------
int __cdecl Com_ParseReturnToMark(_DWORD *a1, _DWORD *a2)
{
  int result; // eax
  char *v3; // [esp+0h] [ebp-8h]
  _DWORD *v4; // [esp+4h] [ebp-4h]

  v4 = Com_GetParseThreadInfo();
  v3 = (char *)&v4[279 * v4[4464]];
  *((_DWORD *)v3 + 256) = *a2;
  *a1 = a2[1];
  v3[1028] = a2[2] != 0;
  *((_DWORD *)v3 + 261) = a2[3];
  result = a2[4];
  *((_DWORD *)v3 + 262) = result;
  return result;
}

//----- (080B3EC8) --------------------------------------------------------
_BYTE *__cdecl SkipWhitespace(_BYTE *a1, _DWORD *a2)
{
  _DWORD *v2; // eax
  char *v5; // [esp+Ch] [ebp-Ch]
  int v6; // [esp+14h] [ebp-4h]

  v2 = Com_GetParseThreadInfo();
  v5 = (char *)&v2[279 * v2[4464]];
  while ( 1 )
  {
    v6 = (char)*a1;
    if ( v6 > 32 )
      break;
    if ( !*a1 )
      return 0;
    if ( v6 == 10 )
    {
      ++*((_DWORD *)v5 + 256);
      *a2 = 1;
    }
    ++a1;
  }
  return a1;
}

//----- (080B3F36) --------------------------------------------------------
int __cdecl Com_Compress(_BYTE *a1)
{
  int v2; // [esp+4h] [ebp-10h]
  char v3; // [esp+Bh] [ebp-9h]
  _BYTE *v4; // [esp+Ch] [ebp-8h]
  char *v5; // [esp+10h] [ebp-4h]

  v2 = 0;
  v4 = a1;
  v5 = a1;
  if ( a1 )
  {
    while ( 1 )
    {
      v3 = *v5;
      if ( !*v5 )
        break;
      if ( v3 == 13 || v3 == 10 )
      {
        *v4++ = v3;
        ++v2;
        ++v5;
      }
      else if ( v3 == 47 && v5[1] == 47 )
      {
        while ( *v5 && *v5 != 10 )
          ++v5;
      }
      else if ( v3 == 47 && v5[1] == 42 )
      {
        while ( *v5 && (*v5 != 42 || v5[1] != 47) )
        {
          if ( *v5 == 10 )
          {
            *v4++ = 10;
            ++v2;
          }
          ++v5;
        }
        if ( *v5 )
          v5 += 2;
      }
      else
      {
        *v4++ = v3;
        ++v2;
        ++v5;
      }
    }
  }
  *v4 = 0;
  return v2;
}
// 80B4036: conditional instruction was optimized away because %var_14.4==0

//----- (080B4072) --------------------------------------------------------
int Com_GetLastTokenPos()
{
  return *((_DWORD *)Com_GetParseThreadInfo() + 4465);
}

//----- (080B408C) --------------------------------------------------------
_BYTE *__cdecl Com_ParseCSV(_BYTE **a1, int a2)
{
  _BYTE *v4; // [esp+8h] [ebp-10h]
  _DWORD *v5; // [esp+Ch] [ebp-Ch]
  _BYTE *v6; // [esp+10h] [ebp-8h]
  _BYTE *i; // [esp+10h] [ebp-8h]
  unsigned int v8; // [esp+14h] [ebp-4h]

  v5 = Com_GetParseThreadInfo();
  v4 = &v5[279 * v5[4464]];
  v6 = *a1;
  v8 = 0;
  *v4 = 0;
  if ( a2 )
  {
    while ( *v6 == 13 || *v6 == 10 )
      ++v6;
  }
  else if ( *v6 == 13 || *v6 == 10 )
  {
    return v4;
  }
  v5[4466] = v5[4465];
  v5[4465] = v6;
  while ( *v6 && *v6 != 44 && *v6 != 10 )
  {
    if ( *v6 == 13 )
    {
      ++v6;
    }
    else if ( *v6 == 34 )
    {
      for ( i = v6 + 1; ; i += 2 )
      {
        while ( *i != 34 )
        {
          if ( v8 <= 0x3FE )
            v4[v8++] = *i;
          ++i;
        }
        if ( i[1] != 34 )
          break;
        if ( v8 <= 0x3FE )
          v4[v8++] = 34;
      }
      v6 = i + 1;
    }
    else
    {
      if ( v8 <= 0x3FE )
        v4[v8++] = *v6;
      ++v6;
    }
  }
  if ( *v6 )
  {
    if ( *v6 != 10 )
      ++v6;
    *a1 = v6;
  }
  else
  {
    *a1 = 0;
  }
  v4[v8] = 0;
  return v4;
}

//----- (080B4220) --------------------------------------------------------
char *__cdecl Com_ParseExt(char **a1, int a2)
{
  char *v2; // edx
  char *v3; // edx
  signed int j; // [esp+14h] [ebp-24h]
  signed int n; // [esp+18h] [ebp-20h]
  char *dest; // [esp+1Ch] [ebp-1Ch]
  _DWORD *v9; // [esp+20h] [ebp-18h]
  char **i; // [esp+24h] [ebp-14h]
  char *v11; // [esp+28h] [ebp-10h]
  char *v12; // [esp+28h] [ebp-10h]
  int v13; // [esp+2Ch] [ebp-Ch] BYREF
  int v14; // [esp+30h] [ebp-8h]
  char v15; // [esp+37h] [ebp-1h]

  v15 = 0;
  v13 = 0;
  v9 = Com_GetParseThreadInfo();
  dest = (char *)&v9[279 * v9[4464]];
  v11 = *a1;
  v14 = 0;
  *dest = 0;
  if ( !v11 )
  {
    *a1 = 0;
    return dest;
  }
  *((_DWORD *)dest + 261) = *((_DWORD *)dest + 256);
  *((_DWORD *)dest + 262) = *a1;
  if ( dest[1031] )
    return Com_ParseCSV(a1, a2);
  while ( 1 )
  {
    while ( 1 )
    {
      v11 = SkipWhitespace(v11, &v13);
      if ( !v11 )
      {
        *a1 = 0;
        return dest;
      }
      if ( v13 && !a2 )
        return dest;
      v15 = *v11;
      if ( v15 != 47 || v11[1] != 47 )
        break;
      while ( *v11 && *v11 != 10 )
        ++v11;
    }
    if ( v15 != 47 || v11[1] != 42 )
      break;
    while ( *v11 && (*v11 != 42 || v11[1] != 47) )
    {
      if ( *v11 == 10 )
        ++*((_DWORD *)dest + 256);
      ++v11;
    }
    if ( *v11 )
      v11 += 2;
  }
  v9[4466] = v9[4465];
  v9[4465] = v11;
  if ( v15 == 34 )
  {
    if ( dest[1030] )
      dest[v14++] = 34;
    v12 = v11 + 1;
    while ( 1 )
    {
      v2 = v12++;
      v15 = *v2;
      if ( v15 == 92 && (*v12 == 34 || *v12 == 92) )
      {
        v3 = v12++;
        v15 = *v3;
      }
      else
      {
        if ( v15 == 34 || !v15 )
        {
          if ( dest[1030] )
            dest[v14++] = 34;
          dest[v14] = 0;
          *a1 = v12;
          return dest;
        }
        if ( *v12 == 10 )
          ++*((_DWORD *)dest + 256);
      }
      if ( v14 <= 1022 )
        dest[v14++] = v15;
    }
  }
  if ( dest[1029] )
  {
    do
    {
      if ( v14 <= 1022 )
        dest[v14++] = v15;
      v15 = *++v11;
    }
    while ( v15 > 32 );
    if ( v14 == 1024 )
      v14 = 0;
    dest[v14] = 0;
    *a1 = v11;
    return dest;
  }
  else if ( v15 > 47 && v15 <= 57
         || dest[1032] && v15 == 45 && v11[1] > 47 && v11[1] <= 57
         || v15 == 46 && v11[1] > 47 && v11[1] <= 57 )
  {
    do
    {
      if ( v14 <= 1022 )
        dest[v14++] = v15;
      v15 = *++v11;
    }
    while ( v15 > 47 && v15 <= 57 || v15 == 46 );
    if ( v15 == 101 || v15 == 69 )
    {
      if ( v14 <= 1022 )
        dest[v14++] = v15;
      v15 = *++v11;
      if ( v15 == 45 || v15 == 43 )
      {
        if ( v14 <= 1022 )
          dest[v14++] = v15;
        v15 = *++v11;
      }
      do
      {
        if ( v14 <= 1022 )
          dest[v14++] = v15;
        v15 = *++v11;
      }
      while ( v15 > 47 && v15 <= 57 );
    }
    if ( v14 == 1024 )
      v14 = 0;
    dest[v14] = 0;
    *a1 = v11;
    return dest;
  }
  else if ( v15 > 96 && v15 <= 122 || v15 > 64 && v15 <= 90 || v15 == 95 || v15 == 47 || v15 == 92 )
  {
    do
    {
      if ( v14 <= 1022 )
        dest[v14++] = v15;
      v15 = *++v11;
    }
    while ( v15 > 96 && v15 <= 122 || v15 > 64 && v15 <= 90 || v15 == 95 || v15 > 47 && v15 <= 57 );
    if ( v14 == 1024 )
      v14 = 0;
    dest[v14] = 0;
    *a1 = v11;
    return dest;
  }
  else
  {
    for ( i = off_815DF40; ; ++i )
    {
      if ( !*i )
      {
        *dest = *v11;
        dest[1] = 0;
        *a1 = v11 + 1;
        return dest;
      }
      n = I_strlen(*i);
      for ( j = 0; j < n && v11[j] == (*i)[j]; ++j )
        ;
      if ( j == n )
        break;
    }
    memcpy(dest, *i, n);
    dest[n] = 0;
    *a1 = &v11[n];
    return dest;
  }
}
// 815DF40: using guessed type char *off_815DF40[14];

//----- (080B47DA) --------------------------------------------------------
char *__cdecl Com_Parse(char **a1)
{
  char *v2; // [esp+10h] [ebp-8h]
  _DWORD *v3; // [esp+14h] [ebp-4h]

  v3 = Com_GetParseThreadInfo();
  v2 = (char *)&v3[279 * v3[4464]];
  if ( v2[1028] )
  {
    v2[1028] = 0;
    *a1 = (char *)*((_DWORD *)v2 + 262);
    *((_DWORD *)v2 + 256) = *((_DWORD *)v2 + 261);
  }
  return Com_ParseExt(a1, 1);
}

//----- (080B4848) --------------------------------------------------------
char *__cdecl Com_ParseOnLine(char **a1)
{
  char *v3; // [esp+10h] [ebp-8h]
  _DWORD *v4; // [esp+14h] [ebp-4h]

  v4 = Com_GetParseThreadInfo();
  v3 = (char *)&v4[279 * v4[4464]];
  if ( !v3[1028] )
    return Com_ParseExt(a1, 0);
  v3[1028] = 0;
  if ( v3[1029] )
  {
    *a1 = (char *)*((_DWORD *)v3 + 262);
    *((_DWORD *)v3 + 256) = *((_DWORD *)v3 + 261);
    return Com_ParseExt(a1, 0);
  }
  return v3;
}

//----- (080B48D0) --------------------------------------------------------
int __cdecl Com_MatchToken(char **a1, char *s2, int a3)
{
  const char *s1; // [esp+14h] [ebp-4h]

  s1 = Com_Parse(a1);
  if ( !strcmp(s1, s2) )
    return 1;
  if ( !a3 )
    Com_ScriptErrorDrop("MatchToken: %s != %s\n", s1, s2);
  Com_ScriptWarning("MatchToken: %s != %s\n", s1, s2);
  return 0;
}

//----- (080B494C) --------------------------------------------------------
int __cdecl sub_80B494C(char **a1, int a2)
{
  int v3; // [esp+Ch] [ebp-Ch]
  int v4; // [esp+10h] [ebp-8h]
  char *v5; // [esp+14h] [ebp-4h]

  v3 = 0;
  v4 = 0;
  do
  {
    v5 = Com_Parse(a1);
    if ( !v5[1] )
    {
      if ( *v5 == 123 )
      {
        if ( v4 == a2 )
          v3 = 1;
        else
          ++v4;
      }
      else if ( *v5 == 125 )
      {
        --v4;
      }
    }
  }
  while ( v4 && *a1 );
  return v3;
}

//----- (080B49B8) --------------------------------------------------------
_BYTE *__cdecl Com_SkipRestOfLine(_DWORD *a1)
{
  _BYTE *result; // eax
  _DWORD *v2; // [esp+Ch] [ebp-Ch]
  int v3; // [esp+10h] [ebp-8h]
  _BYTE *v4; // [esp+14h] [ebp-4h]

  v2 = Com_GetParseThreadInfo();
  result = (_BYTE *)*a1;
  v4 = (_BYTE *)*a1;
  if ( *a1 )
  {
    while ( 1 )
    {
      v3 = (char)*v4;
      if ( !*v4 )
        break;
      ++v4;
      if ( v3 == 10 )
      {
        ++v2[279 * v2[4464] + 256];
        break;
      }
    }
    result = v4;
    *a1 = v4;
  }
  return result;
}

//----- (080B4A1C) --------------------------------------------------------
int __cdecl Com_GetArgCountOnLine(char **a1)
{
  _DWORD v2[10]; // [esp+10h] [ebp-38h] BYREF
  int i; // [esp+38h] [ebp-10h]
  char *v4; // [esp+3Ch] [ebp-Ch]

  Com_ParseSetMark(a1, v2);
  for ( i = 0; ; ++i )
  {
    v4 = Com_ParseOnLine(a1);
    if ( !*v4 )
      break;
  }
  Com_ParseReturnToMark(a1, v2);
  return i;
}
// 80B4A1C: using guessed type _DWORD var_38[10];

//----- (080B4A72) --------------------------------------------------------
char *__cdecl sub_80B4A72(char **a1)
{
  char *s; // [esp+Ch] [ebp-Ch]
  char *src; // [esp+14h] [ebp-4h]

  s = (char *)Com_GetParseThreadInfo() + 17868;
  *s = 0;
  while ( 1 )
  {
    src = Com_ParseOnLine(a1);
    if ( !*src )
      break;
    if ( *s )
      I_strncat(s, 1024, (char *)L" ()");
    I_strncat(s, 1024, src);
  }
  return s;
}

//----- (080B4AEE) --------------------------------------------------------
long double __cdecl sub_80B4AEE(char **a1)
{
  const char *nptr; // [esp+14h] [ebp-4h]

  nptr = Com_Parse(a1);
  return (float)atof(nptr);
}

//----- (080B4B1C) --------------------------------------------------------
long double __cdecl sub_80B4B1C(char **a1)
{
  const char *nptr; // [esp+14h] [ebp-4h]

  nptr = Com_ParseOnLine(a1);
  return (float)atof(nptr);
}

//----- (080B4B4A) --------------------------------------------------------
int __cdecl sub_80B4B4A(char **a1)
{
  const char *nptr; // [esp+4h] [ebp-4h]

  nptr = Com_Parse(a1);
  return atoi(nptr);
}

//----- (080B4B6C) --------------------------------------------------------
int __cdecl sub_80B4B6C(char **a1)
{
  const char *nptr; // [esp+4h] [ebp-4h]

  nptr = Com_ParseOnLine(a1);
  return atoi(nptr);
}

//----- (080B4B8E) --------------------------------------------------------
int __cdecl sub_80B4B8E(char **a1, int a2, int a3)
{
  int i; // [esp+18h] [ebp-10h]
  const char *nptr; // [esp+1Ch] [ebp-Ch]

  Com_MatchToken(a1, (char *)L"()", 0);
  for ( i = 0; i < a2; ++i )
  {
    nptr = Com_Parse(a1);
    *(float *)(a3 + 4 * i) = atof(nptr);
  }
  return Com_MatchToken(a1, (char *)L")", 0);
}

//----- (080B4C14) --------------------------------------------------------
int __cdecl sub_80B4C14(char **a1, int a2, int a3, int a4)
{
  int i; // [esp+14h] [ebp-4h]

  Com_MatchToken(a1, (char *)L"()", 0);
  for ( i = 0; i < a2; ++i )
    sub_80B4B8E(a1, a3, a4 + 4 * a3 * i);
  return Com_MatchToken(a1, (char *)L")", 0);
}

//----- (080B4C8E) --------------------------------------------------------
int __cdecl sub_80B4C8E(char **a1, int a2, int a3, int a4, int a5)
{
  int i; // [esp+14h] [ebp-4h]

  Com_MatchToken(a1, (char *)L"()", 0);
  for ( i = 0; i < a2; ++i )
    sub_80B4C14(a1, a3, a4, a5 + 4 * a3 * a4 * i);
  return Com_MatchToken(a1, (char *)L")", 0);
}

//----- (080B4D14) --------------------------------------------------------
int __cdecl ColorIndex(char a1)
{
  if ( (unsigned __int8)(a1 - 48) > 9u )
    return 7;
  else
    return (unsigned __int8)(a1 - 48);
}

//----- (080B4D44) --------------------------------------------------------
_BYTE *__cdecl sub_80B4D44(_BYTE *a1)
{
  _BYTE *v2; // [esp+0h] [ebp-4h]

  v2 = a1;
  while ( *a1 )
  {
    if ( *a1 == 47 )
      v2 = a1 + 1;
    ++a1;
  }
  return v2;
}

//----- (080B4D74) --------------------------------------------------------
void *__cdecl sub_80B4D74(char *src, char *s, char *a3, char *dest, int a5)
{
  size_t v6; // [esp+1Ch] [ebp-Ch]
  size_t v7; // [esp+20h] [ebp-8h]
  size_t n; // [esp+24h] [ebp-4h]
  char *desta; // [esp+3Ch] [ebp+14h]

  n = I_strlen(src);
  v7 = I_strlen(s);
  v6 = I_strlen(a3);
  if ( (int)(v6 + n + v7) >= a5 )
    Com_Error(1, "filepath '%s%s%s' is longer than %i characters", src, s, a3, a5 - 1);
  memcpy(dest, src, n);
  desta = &dest[n];
  memcpy(desta, s, v7);
  return memcpy(&desta[v7], a3, v6 + 1);
}

//----- (080B4E42) --------------------------------------------------------
_BYTE *__cdecl Com_GetExtensionSubString(_BYTE *a1)
{
  _BYTE *v2; // [esp+0h] [ebp-4h]

  v2 = 0;
  while ( *a1 )
  {
    if ( *a1 == 46 )
    {
      v2 = a1;
    }
    else if ( *a1 == 47 || *a1 == 92 )
    {
      v2 = 0;
    }
    ++a1;
  }
  if ( !v2 )
    return a1;
  return v2;
}

//----- (080B4E98) --------------------------------------------------------
_BYTE *__cdecl sub_80B4E98(_BYTE *a1, _BYTE *a2)
{
  _BYTE *v2; // eax
  _BYTE *result; // eax
  _BYTE *v4; // [esp+4h] [ebp-4h]

  v4 = Com_GetExtensionSubString(a1);
  while ( a1 != v4 )
  {
    v2 = a1++;
    *a2++ = *v2;
  }
  result = a2;
  *a2 = 0;
  return result;
}

//----- (080B4ED6) --------------------------------------------------------
char *__cdecl sub_80B4ED6(_BYTE *src, char *dest)
{
  char *result; // eax
  _BYTE *v3; // [esp+14h] [ebp-4h]

  v3 = sub_80B4D44(src);
  memcpy(dest, src, v3 - src);
  result = &dest[v3 - src];
  *result = 0;
  return result;
}

//----- (080B4F1A) --------------------------------------------------------
char *__cdecl Com_DefaultExtension(char *s, size_t maxlen, const char *a3)
{
  char *result; // eax
  char *i; // [esp+2Ch] [ebp-4Ch]
  char dest[72]; // [esp+30h] [ebp-48h] BYREF

  for ( i = &s[strlen(s) - 1]; *i != 47 && i != s; --i )
  {
    result = i;
    if ( *i == 46 )
      return result;
  }
  I_strncpyz(dest, s, 64);
  return (char *)Com_sprintf(s, maxlen, "%s%s", dest, a3);
}

//----- (080B4F9A) --------------------------------------------------------
int __cdecl BigShort(__int16 a1)
{
  return (__int16)dword_8527A40(a1);
}
// 8527A40: using guessed type int (__cdecl *dword_8527A40)(_DWORD);

//----- (080B4FB8) --------------------------------------------------------
int __cdecl sub_80B4FB8(int a1)
{
  return dword_8527A48(a1);
}
// 8527A48: using guessed type int (__cdecl *dword_8527A48)(_DWORD);

//----- (080B4FCE) --------------------------------------------------------
int __cdecl sub_80B4FCE(int a1, int a2)
{
  return dword_8527A50(a1, a2);
}
// 8527A50: using guessed type int (__cdecl *dword_8527A50)(_DWORD, _DWORD);

//----- (080B4FF6) --------------------------------------------------------
int __cdecl sub_80B4FF6(__int16 a1)
{
  return (__int16)dword_8527A44(a1);
}
// 8527A44: using guessed type int (__cdecl *dword_8527A44)(_DWORD);

//----- (080B5014) --------------------------------------------------------
int __cdecl sub_80B5014(int a1)
{
  return dword_8527A4C(a1);
}
// 8527A4C: using guessed type int (__cdecl *dword_8527A4C)(_DWORD);

//----- (080B502A) --------------------------------------------------------
int __cdecl sub_80B502A(int a1)
{
  return dword_8527A54(a1);
}
// 8527A54: using guessed type int (__cdecl *dword_8527A54)(_DWORD);

//----- (080B5040) --------------------------------------------------------
int __cdecl sub_80B5040(int a1)
{
  return dword_8527A58(a1);
}
// 8527A58: using guessed type int (__cdecl *dword_8527A58)(_DWORD);

//----- (080B5056) --------------------------------------------------------
int __cdecl sub_80B5056(__int16 a1)
{
  return (__int16)(((unsigned __int8)a1 << 8) + HIBYTE(a1));
}

//----- (080B508E) --------------------------------------------------------
int __cdecl sub_80B508E(__int16 a1)
{
  return a1;
}

//----- (080B50A2) --------------------------------------------------------
int __cdecl sub_80B50A2(int a1)
{
  return HIBYTE(a1) + (BYTE2(a1) << 8) + (BYTE1(a1) << 16) + ((unsigned __int8)a1 << 24);
}

//----- (080B50FE) --------------------------------------------------------
int __cdecl sub_80B50FE(int a1)
{
  return a1;
}

//----- (080B5106) --------------------------------------------------------
unsigned __int64 __cdecl sub_80B5106(__int64 a1)
{
  __int64 v1; // rcx
  __int64 v2; // rax
  __int64 v3; // rcx
  __int64 v4; // rcx

  LODWORD(v1) = 0;
  HIDWORD(v1) = (unsigned __int8)a1 << 24;
  LODWORD(v2) = 0;
  HIDWORD(v2) = BYTE1(a1) << 16;
  v3 = v2 + v1;
  LODWORD(v2) = 0;
  HIDWORD(v2) = BYTE2(a1) << 8;
  v4 = v2 + v3;
  HIDWORD(v2) = BYTE3(a1);
  LODWORD(v2) = 0;
  return HIBYTE(a1)
       + ((unsigned __int64)BYTE6(a1) << 8)
       + ((unsigned __int64)BYTE5(a1) << 16)
       + ((unsigned __int64)BYTE4(a1) << 24)
       + v2
       + v4;
}

//----- (080B5242) --------------------------------------------------------
__int64 __cdecl sub_80B5242(__int64 a1)
{
  return a1;
}

//----- (080B525C) --------------------------------------------------------
long double __cdecl sub_80B525C(int a1)
{
  float v2; // [esp+4h] [ebp-8h]

  LOBYTE(v2) = HIBYTE(a1);
  BYTE1(v2) = BYTE2(a1);
  BYTE2(v2) = BYTE1(a1);
  HIBYTE(v2) = a1;
  return v2;
}

//----- (080B5290) --------------------------------------------------------
void __cdecl sub_80B5290(float a1)
{
  sub_80B6D62(a1);
}

//----- (080B52A4) --------------------------------------------------------
int __cdecl sub_80B52A4(int a1)
{
  int v2; // [esp+0h] [ebp-8h]

  LOBYTE(v2) = HIBYTE(a1);
  BYTE1(v2) = BYTE2(a1);
  BYTE2(v2) = BYTE1(a1);
  HIBYTE(v2) = a1;
  return v2;
}

//----- (080B52D2) --------------------------------------------------------
int __cdecl sub_80B52D2(char a1)
{
  return sub_80B6D58((int)&a1);
}

//----- (080B52E6) --------------------------------------------------------
void sub_80B52E6()
{
  dword_8527A40 = (int (__cdecl *)(_DWORD))sub_80B5056;
  dword_8527A44 = (int (__cdecl *)(_DWORD))sub_80B508E;
  dword_8527A48 = sub_80B50A2;
  dword_8527A4C = sub_80B50FE;
  dword_8527A50 = (int (__cdecl *)(_DWORD, _DWORD))sub_80B5242;
  dword_8527A54 = (int (__cdecl *)(_DWORD))sub_80B5290;
  dword_8527A58 = (int (__cdecl *)(_DWORD))sub_80B52D2;
}
// 8527A40: using guessed type int (__cdecl *dword_8527A40)(_DWORD);
// 8527A44: using guessed type int (__cdecl *dword_8527A44)(_DWORD);
// 8527A48: using guessed type int (__cdecl *dword_8527A48)(_DWORD);
// 8527A4C: using guessed type int (__cdecl *dword_8527A4C)(_DWORD);
// 8527A50: using guessed type int (__cdecl *dword_8527A50)(_DWORD, _DWORD);
// 8527A54: using guessed type int (__cdecl *dword_8527A54)(_DWORD);
// 8527A58: using guessed type int (__cdecl *dword_8527A58)(_DWORD);

//----- (080B5332) --------------------------------------------------------
void sub_80B5332()
{
  dword_8527A40 = (int (__cdecl *)(_DWORD))sub_80B508E;
  dword_8527A44 = (int (__cdecl *)(_DWORD))sub_80B5056;
  dword_8527A48 = sub_80B50FE;
  dword_8527A4C = sub_80B50A2;
  dword_8527A50 = (int (__cdecl *)(_DWORD, _DWORD))sub_80B5106;
  dword_8527A54 = (int (__cdecl *)(_DWORD))sub_80B525C;
  dword_8527A58 = sub_80B52A4;
}
// 8527A40: using guessed type int (__cdecl *dword_8527A40)(_DWORD);
// 8527A44: using guessed type int (__cdecl *dword_8527A44)(_DWORD);
// 8527A48: using guessed type int (__cdecl *dword_8527A48)(_DWORD);
// 8527A4C: using guessed type int (__cdecl *dword_8527A4C)(_DWORD);
// 8527A50: using guessed type int (__cdecl *dword_8527A50)(_DWORD, _DWORD);
// 8527A54: using guessed type int (__cdecl *dword_8527A54)(_DWORD);
// 8527A58: using guessed type int (__cdecl *dword_8527A58)(_DWORD);

//----- (080B537E) --------------------------------------------------------
void Swap_Init()
{
  sub_80B52E6();
}

//----- (080B53C8) --------------------------------------------------------
int __cdecl sub_80B53C8(int a1)
{
  int v2; // [esp+0h] [ebp-4h]

  v2 = 0;
  if ( a1 > 96 && a1 <= 122 )
    return 1;
  return v2;
}

//----- (080B53EE) --------------------------------------------------------
int __cdecl sub_80B53EE(int a1)
{
  int v2; // [esp+0h] [ebp-4h]

  v2 = 0;
  if ( a1 > 64 && a1 <= 90 )
    return 1;
  return v2;
}

//----- (080B5414) --------------------------------------------------------
int __cdecl sub_80B5414(int a1)
{
  int v2; // [esp+0h] [ebp-4h]

  v2 = 0;
  if ( a1 > 96 && a1 <= 122 || a1 > 64 && a1 <= 90 )
    return 1;
  return v2;
}

//----- (080B5448) --------------------------------------------------------
int __cdecl sub_80B5448(int a1)
{
  int v2; // [esp+0h] [ebp-4h]

  v2 = 0;
  if ( a1 > 47 && a1 <= 57 )
    return 1;
  return v2;
}

//----- (080B546E) --------------------------------------------------------
int __cdecl sub_80B546E(int a1)
{
  int v2; // [esp+4h] [ebp-4h]

  v2 = 0;
  if ( (unsigned __int8)sub_80B5414(a1) || (unsigned __int8)sub_80B5448(a1) )
    return 1;
  return v2;
}

//----- (080B54DE) --------------------------------------------------------
char *__cdecl I_strncpyz(char *dest, char *src, int a3)
{
  char *result; // eax

  strncpy(dest, src, a3 - 1);
  result = &dest[a3 - 1];
  *result = 0;
  return result;
}

//----- (080B550A) --------------------------------------------------------
int __cdecl sub_80B550A(char *a1, char *a2, int a3)
{
  int v6; // [esp+10h] [ebp-8h]
  int v7; // [esp+14h] [ebp-4h]

  while ( 1 )
  {
    v7 = *a1++;
    v6 = *a2++;
    if ( --a3 == -1 )
      return 0;
    if ( v7 != v6 )
    {
      if ( (unsigned __int8)sub_80B53C8(v7) )
        v7 -= 32;
      if ( (unsigned __int8)sub_80B53C8(v6) )
        v6 -= 32;
      if ( v7 != v6 )
        break;
    }
    if ( !v7 )
      return 0;
  }
  if ( v7 >= v6 )
    return 1;
  else
    return -1;
}

//----- (080B55B0) --------------------------------------------------------
int __cdecl I_strncmp(char *a1, char *a2, int a3)
{
  int v6; // [esp+8h] [ebp-8h]
  int v7; // [esp+Ch] [ebp-4h]

  while ( 1 )
  {
    v7 = *a1++;
    v6 = *a2++;
    if ( --a3 == -1 )
      return 0;
    if ( v7 != v6 )
      break;
    if ( !v7 )
      return 0;
  }
  if ( v7 >= v6 )
    return 1;
  else
    return -1;
}

//----- (080B5620) --------------------------------------------------------
int __cdecl I_stricmp(char *a1, char *a2)
{
  return sub_80B550A(a1, a2, 0x7FFFFFFF);
}

//----- (080B5642) --------------------------------------------------------
int __cdecl sub_80B5642(char *a1, char *a2)
{
  return I_strncmp(a1, a2, 0x7FFFFFFF);
}

//----- (080B5664) --------------------------------------------------------
int __cdecl sub_80B5664(char *a1, char *a2)
{
  int v2; // ebx
  int v6; // [esp+1Ch] [ebp-Ch]
  char v7; // [esp+22h] [ebp-6h]
  char v8; // [esp+23h] [ebp-5h]

  while ( 1 )
  {
    v8 = *a1++;
    if ( v8 == 42 )
    {
      if ( !*a1 )
        return 0;
      if ( *a2 && !sub_80B5664(a1 - 1, a2 + 1) )
        return 0;
      goto LABEL_14;
    }
    v7 = *a2++;
    if ( v8 != v7 && v8 != 63 )
    {
      v2 = tolower(v8);
      v6 = v2 - tolower(v7);
      if ( v6 )
        break;
    }
LABEL_14:
    if ( !v8 )
      return 0;
  }
  if ( v6 >= 0 )
    return 1;
  else
    return -1;
}

//----- (080B573C) --------------------------------------------------------
_BYTE *__cdecl I_strlwr(_BYTE *a1)
{
  _BYTE *i; // [esp+4h] [ebp-4h]

  for ( i = a1; *i; ++i )
  {
    if ( (unsigned __int8)sub_80B53EE((char)*i) )
      *i += 32;
  }
  return a1;
}

//----- (080B577E) --------------------------------------------------------
_BYTE *__cdecl I_strupr(_BYTE *a1)
{
  _BYTE *i; // [esp+4h] [ebp-4h]

  for ( i = a1; *i; ++i )
  {
    if ( (unsigned __int8)sub_80B53C8((char)*i) )
      *i -= 32;
  }
  return a1;
}

//----- (080B57C0) --------------------------------------------------------
char *__cdecl I_strncat(char *s, int a2, char *src)
{
  signed int v4; // [esp+14h] [ebp-4h]

  v4 = I_strlen(s);
  if ( v4 >= a2 )
    Com_Error(0, (char *)&byte_8148700);
  return I_strncpyz(&s[v4], src, a2 - v4);
}

//----- (080B5814) --------------------------------------------------------
int __cdecl sub_80B5814(_BYTE *a1)
{
  int v2; // [esp+0h] [ebp-8h]

  v2 = 0;
  while ( *a1 )
  {
    if ( a1 && *a1 == 94 && a1[1] && a1[1] != 94 && (char)a1[1] > 47 && (char)a1[1] <= 57 )
    {
      a1 += 2;
    }
    else
    {
      ++v2;
      ++a1;
    }
  }
  return v2;
}

//----- (080B587C) --------------------------------------------------------
char *__cdecl sub_80B587C(char *a1)
{
  char v2; // [esp+3h] [ebp-9h]
  char *v3; // [esp+4h] [ebp-8h]
  char *v4; // [esp+8h] [ebp-4h]

  v3 = a1;
  v4 = a1;
  while ( 1 )
  {
    v2 = *v3;
    if ( !*v3 )
      break;
    if ( v3 && *v3 == 94 && v3[1] && v3[1] != 94 && v3[1] > 47 && v3[1] <= 57 )
    {
      ++v3;
    }
    else if ( v2 > 31 && v2 != 127 )
    {
      *v4++ = v2;
    }
    ++v3;
  }
  *v4 = 0;
  return a1;
}

//----- (080B5904) --------------------------------------------------------
int __cdecl I_CleanChar(char a1)
{
  if ( a1 == -110 )
    return 39;
  else
    return a1;
}

//----- (080B5932) --------------------------------------------------------
int Com_sprintf(char *s, size_t maxlen, char *format, ...)
{
  int result; // eax
  va_list va; // [esp+2Ch] [ebp+14h] BYREF

  va_start(va, format);
  result = vsnprintf(s, maxlen, format, va);
  s[maxlen - 1] = 0;
  return result;
}

//----- (080B5970) --------------------------------------------------------
_BOOL4 __cdecl sub_80B5970(unsigned int a1)
{
  unsigned int v3; // [esp+10h] [ebp-8h]
  char v4; // [esp+14h] [ebp-4h] BYREF

  if ( a1 >= (unsigned int)&v4 && a1 < (unsigned int)&STACK[0x2014] )
    return 0;
  v3 = Sys_GetValue(1);
  return a1 < v3 || a1 >= v3 + 3072;
}

//----- (080B59CE) --------------------------------------------------------
char *va(char *format, ...)
{
  int v1; // edx
  int v3; // [esp+18h] [ebp-10h]
  unsigned int v4; // [esp+1Ch] [ebp-Ch]
  char *s; // [esp+20h] [ebp-8h]
  va_list va; // [esp+34h] [ebp+Ch] BYREF

  va_start(va, format);
  v3 = Sys_GetValue(1);
  s = (char *)(v3 + (*(_DWORD *)(v3 + 2048) << 10));
  v1 = *(_DWORD *)(v3 + 2048) + 1;
  *(_DWORD *)(v3 + 2048) = v1 / 2;
  *(_DWORD *)(v3 + 2048) = v1 - 2 * *(_DWORD *)(v3 + 2048);
  v4 = vsnprintf(s, 0x400u, format, va);
  s[1023] = 0;
  if ( v4 >= 0x400 )
    Com_Error(1, (char *)&byte_8148720);
  return s;
}

//----- (080B5A86) --------------------------------------------------------
int __cdecl Com_InitThreadData(int a1)
{
  Sys_SetValue(1, 2052 * a1 + 139604320);
  Sys_SetValue(2, 156 * a1 + 139606400);
  return Sys_SetValue(3, 24 * a1 + 139606556);
}

//----- (080B5B30) --------------------------------------------------------
char *__cdecl Info_ValueForKey(char *s, char *a2)
{
  char *v2; // eax
  char *v3; // eax
  char *v6; // [esp+18h] [ebp-2010h]
  char *v7; // [esp+18h] [ebp-2010h]
  char *v8; // [esp+1Ch] [ebp-200Ch]
  char v9[8200]; // [esp+20h] [ebp-2008h] BYREF
  char *sa; // [esp+2030h] [ebp+8h]

  if ( !s || !a2 )
    return (char *)&unk_814874D;
  if ( strlen(s) > 0x1FFF )
    Com_Error(1, (char *)&byte_8148760);
  dword_8527A5C ^= 1u;
  if ( *s == 92 )
    ++s;
  while ( 1 )
  {
    v6 = v9;
    while ( *s != 92 )
    {
      if ( !*s )
        return (char *)&unk_814874D;
      v2 = s++;
      *v6++ = *v2;
    }
    *v6 = 0;
    sa = s + 1;
    v8 = (char *)&unk_8523A40 + 0x2000 * dword_8527A5C;
    v7 = v8;
    while ( *sa != 92 && *sa )
    {
      v3 = sa++;
      *v7++ = *v3;
    }
    *v7 = 0;
    if ( !I_stricmp(a2, v9) )
      return v8;
    if ( !*sa )
      break;
    s = sa + 1;
  }
  return (char *)&unk_814874D;
}
// 8527A5C: using guessed type int dword_8527A5C;

//----- (080B5D40) --------------------------------------------------------
char *__cdecl sub_80B5D40(char *s, char *s1)
{
  char *result; // eax
  char *v3; // eax
  char *v4; // eax
  char *v5; // [esp+1Ch] [ebp-81Ch]
  char *v6; // [esp+1Ch] [ebp-81Ch]
  char v7; // [esp+20h] [ebp-818h] BYREF
  char s2[1036]; // [esp+420h] [ebp-418h] BYREF
  char *dest; // [esp+82Ch] [ebp-Ch]

  if ( strlen(s) > 0x3FF )
    Com_Error(1, (char *)&byte_81487A0);
  result = strchr(s1, 92);
  if ( !result )
  {
    while ( 1 )
    {
      dest = s;
      if ( *s == 92 )
        ++s;
      v5 = s2;
      while ( *s != 92 )
      {
        result = s;
        if ( !*s )
          return result;
        v3 = s++;
        *v5++ = *v3;
      }
      *v5 = 0;
      ++s;
      v6 = &v7;
      while ( *s != 92 && *s )
      {
        result = s;
        if ( !*s )
          return result;
        v4 = s++;
        *v6++ = *v4;
      }
      *v6 = 0;
      if ( !strcmp(s1, s2) )
        break;
      result = s;
      if ( !*s )
        return result;
    }
    return strcpy(dest, s);
  }
  return result;
}

//----- (080B5E72) --------------------------------------------------------
char *__cdecl sub_80B5E72(char *s, char *s1)
{
  char *result; // eax
  char *v3; // eax
  char *v4; // eax
  char *v5; // [esp+1Ch] [ebp-401Ch]
  char *v6; // [esp+1Ch] [ebp-401Ch]
  char v7; // [esp+20h] [ebp-4018h] BYREF
  char s2[8204]; // [esp+2020h] [ebp-2018h] BYREF
  char *dest; // [esp+402Ch] [ebp-Ch]

  if ( strlen(s) > 0x1FFF )
    Com_Error(1, (char *)&byte_81487E0);
  result = strchr(s1, 92);
  if ( !result )
  {
    while ( 1 )
    {
      dest = s;
      if ( *s == 92 )
        ++s;
      v5 = s2;
      while ( *s != 92 )
      {
        result = s;
        if ( !*s )
          return result;
        v3 = s++;
        *v5++ = *v3;
      }
      *v5 = 0;
      ++s;
      v6 = &v7;
      while ( *s != 92 && *s )
      {
        result = s;
        if ( !*s )
          return result;
        v4 = s++;
        *v6++ = *v4;
      }
      *v6 = 0;
      if ( !strcmp(s1, s2) )
        break;
      result = s;
      if ( !*s )
        return result;
    }
    return strcpy(dest, s);
  }
  return result;
}

//----- (080B5FA4) --------------------------------------------------------
_BOOL4 __cdecl sub_80B5FA4(char *s)
{
  return !strchr(s, 34) && strchr(s, 59) == 0;
}

//----- (080B5FF6) --------------------------------------------------------
void __cdecl Info_SetValueForKey(char *s, char *s1, int a3)
{
  size_t v3; // ebx
  char v4; // [esp+23h] [ebp-815h]
  int v5; // [esp+28h] [ebp-810h]
  int i; // [esp+2Ch] [ebp-80Ch]
  char v7[1024]; // [esp+30h] [ebp-808h] BYREF
  char src[1032]; // [esp+430h] [ebp-408h] BYREF

  if ( strlen(s) <= 0x3FF )
  {
    v5 = 0;
    for ( i = 0; i <= 1022; ++i )
    {
      v4 = *(_BYTE *)(a3 + i);
      if ( !v4 )
        break;
      if ( v4 != 92 && v4 != 59 && v4 != 34 )
        v7[v5++] = v4;
    }
    v7[v5] = 0;
    if ( strchr(s1, 92) )
    {
      Com_Printf((char *)&byte_8148860, s1, a3);
    }
    else if ( strchr(s1, 59) )
    {
      Com_Printf((char *)&byte_81488A0, s1, a3);
    }
    else if ( strchr(s1, 34) )
    {
      Com_Printf((char *)&byte_81488E0, s1, a3);
    }
    else
    {
      sub_80B5D40(s, s1);
      if ( v7[0] )
      {
        if ( Com_sprintf(src, 0x400u, "\\%s\\%s", s1, v7) > 0 )
        {
          v3 = strlen(src);
          if ( strlen(s) + v3 <= 0x400 )
            strcat(s, src);
          else
            Com_Printf((char *)&byte_8148980, s1, a3, s);
        }
        else
        {
          Com_Printf((char *)&byte_8148920);
        }
      }
    }
  }
  else
  {
    Com_Printf((char *)&byte_8148820);
  }
}
// 80B5FF6: using guessed type char var_808[1024];

//----- (080B622A) --------------------------------------------------------
void __cdecl sub_80B622A(char *s, char *s1, int a3)
{
  size_t v3; // ebx
  char v4; // [esp+23h] [ebp-4015h]
  int v5; // [esp+28h] [ebp-4010h]
  int i; // [esp+2Ch] [ebp-400Ch]
  char v7[8192]; // [esp+30h] [ebp-4008h] BYREF
  char src[8200]; // [esp+2030h] [ebp-2008h] BYREF

  if ( strlen(s) <= 0x1FFF )
  {
    v5 = 0;
    for ( i = 0; i <= 8190; ++i )
    {
      v4 = *(_BYTE *)(a3 + i);
      if ( !v4 )
        break;
      if ( v4 != 92 && v4 != 59 && v4 != 34 )
        v7[v5++] = v4;
    }
    v7[v5] = 0;
    if ( strchr(s1, 92) )
    {
      Com_Printf((char *)&byte_8148860, s1, a3);
    }
    else if ( strchr(s1, 59) )
    {
      Com_Printf((char *)&byte_81488A0, s1, a3);
    }
    else if ( strchr(s1, 34) )
    {
      Com_Printf((char *)&byte_81488E0, s1, a3);
    }
    else
    {
      sub_80B5E72(s, s1);
      if ( v7[0] )
      {
        if ( Com_sprintf(src, 0x2000u, "\\%s\\%s", s1, v7) > 0 )
        {
          v3 = strlen(src);
          if ( strlen(s) + v3 <= 0x400 )
            strcat(s, src);
          else
            Com_Printf((char *)&byte_8148980, s1, a3, s);
        }
        else
        {
          Com_Printf((char *)&byte_8148920);
        }
      }
    }
  }
  else
  {
    Com_Printf((char *)&byte_8148820);
  }
}
// 80B622A: using guessed type char var_4008[8192];

//----- (080B645E) --------------------------------------------------------
_BOOL4 __cdecl sub_80B645E(
        int a1,
        int a2,
        int a3,
        char *s,
        int a5,
        int (__cdecl *a6)(int, char *, _DWORD),
        void (__cdecl *a7)(int, char *))
{
  _DWORD *v7; // ebx
  float *v8; // ebx
  _DWORD *v9; // ebx
  float v12; // [esp+24h] [ebp-14h]
  char *nptr; // [esp+2Ch] [ebp-Ch]
  int i; // [esp+30h] [ebp-8h]

  for ( i = 0; i < a3; ++i )
  {
    nptr = Info_ValueForKey(s, *(char **)a2);
    if ( *nptr )
    {
      if ( *(int *)(a2 + 8) > 7 )
      {
        if ( a5 <= 0 || *(_DWORD *)(a2 + 8) >= a5 )
          Com_Error(1, (char *)&byte_81489C4, *(_DWORD *)(a2 + 8));
        if ( !a6(a1, nptr, *(_DWORD *)(a2 + 8)) )
          return 0;
      }
      else
      {
        switch ( *(_DWORD *)(a2 + 8) )
        {
          case 0:
            a7(a1 + *(_DWORD *)(a2 + 4), nptr);
            break;
          case 1:
            I_strncpyz((char *)(a1 + *(_DWORD *)(a2 + 4)), nptr, 1024);
            break;
          case 2:
            I_strncpyz((char *)(a1 + *(_DWORD *)(a2 + 4)), nptr, 64);
            break;
          case 3:
            I_strncpyz((char *)(a1 + *(_DWORD *)(a2 + 4)), nptr, 256);
            break;
          case 4:
            *(_DWORD *)(a1 + *(_DWORD *)(a2 + 4)) = atoi(nptr);
            break;
          case 5:
            v7 = (_DWORD *)(*(_DWORD *)(a2 + 4) + a1);
            *v7 = atoi(nptr) != 0;
            break;
          case 6:
            v8 = (float *)(*(_DWORD *)(a2 + 4) + a1);
            *v8 = atof(nptr);
            break;
          case 7:
            v9 = (_DWORD *)(*(_DWORD *)(a2 + 4) + a1);
            v12 = atof(nptr);
            *v9 = (int)(v12 * 1000.0);
            break;
          default:
            break;
        }
      }
    }
    a2 += 12;
  }
  return i == a3;
}

//----- (080B6688) --------------------------------------------------------
long double __cdecl sub_80B6688(float a1)
{
  return (2.0 - sub_80B6D1E(a1)) * a1;
}

//----- (080B66A6) --------------------------------------------------------
long double __cdecl sub_80B66A6(float a1)
{
  float v2; // [esp+0h] [ebp-8h]

  v2 = 1.0 - a1;
  return 1.0 - sub_80B6D38(v2);
}

//----- (080B66C0) --------------------------------------------------------
void __cdecl sub_80B66C0(float *a1, int a2, float a3, float a4, float a5)
{
  int v5; // [esp+Ch] [ebp-3Ch]
  float v6[4]; // [esp+10h] [ebp-38h] BYREF
  int v7[7]; // [esp+20h] [ebp-28h] BYREF
  float v8; // [esp+3Ch] [ebp-Ch]

  if ( a3 != 0.0 )
  {
    v8 = sub_80B6688(a3);
    *(float *)&v5 = v8 * a4;
    sub_80B6D74(v6, 0, a2, v5);
    AngleVectors(v6, 0, (float *)v7, 0);
    v8 = v8 * a5;
    sub_80B6D98(a1, v8, (float *)v7, a1);
  }
}
// 80B66C0: using guessed type float var_38[4];

//----- (080B6758) --------------------------------------------------------
float *__cdecl sub_80B6758(float *a1, float *a2, float *a3)
{
  float *result; // eax

  *a3 = *a2 * a1[3] + *a1 + a2[1] * a1[6] + a2[2] * a1[9];
  a3[1] = *a2 * a1[4] + a1[1] + a2[1] * a1[7] + a2[2] * a1[10];
  result = a2 + 2;
  a3[2] = *a2 * a1[5] + a1[2] + a2[1] * a1[8] + a2[2] * a1[11];
  return result;
}

//----- (080B6806) --------------------------------------------------------
float *__cdecl sub_80B6806(float *a1, float *a2, float *a3)
{
  float *result; // eax

  *a3 = *a2 * a1[3] + a2[1] * a1[6] + a2[2] * a1[9];
  a3[1] = *a2 * a1[4] + a2[1] * a1[7] + a2[2] * a1[10];
  result = a2 + 2;
  a3[2] = *a2 * a1[5] + a2[1] * a1[8] + a2[2] * a1[11];
  return result;
}

//----- (080B68EE) --------------------------------------------------------
float *__cdecl sub_80B68EE(float *a1, float *a2, float *a3)
{
  float *result; // eax
  float v4; // [esp+0h] [ebp-18h]
  float v5; // [esp+4h] [ebp-14h]
  float v6; // [esp+8h] [ebp-10h]

  v4 = *a2 - *a1;
  v5 = a2[1] - a1[1];
  v6 = a2[2] - a1[2];
  *a3 = v4 * a1[3] + v5 * a1[4] + v6 * a1[5];
  a3[1] = v4 * a1[6] + v5 * a1[7] + v6 * a1[8];
  result = a1;
  a3[2] = v4 * a1[9] + v5 * a1[10] + v6 * a1[11];
  return result;
}

//----- (080B6998) --------------------------------------------------------
float *__cdecl sub_80B6998(float *a1, float *a2, float *a3)
{
  float *result; // eax

  *a3 = *a2 * a1[3] + a2[1] * a1[4] + a2[2] * a1[5];
  a3[1] = *a2 * a1[6] + a2[1] * a1[7] + a2[2] * a1[8];
  result = a2 + 2;
  a3[2] = *a2 * a1[9] + a2[1] * a1[10] + a2[2] * a1[11];
  return result;
}

//----- (080B6D1E) --------------------------------------------------------
long double __cdecl sub_80B6D1E(float a1)
{
  return (float)fabs(a1);
}

//----- (080B6D38) --------------------------------------------------------
long double __cdecl sub_80B6D38(float a1)
{
  return (float)sqrt(a1);
}

//----- (080B6D58) --------------------------------------------------------
int __cdecl sub_80B6D58(int a1)
{
  return *(_DWORD *)a1;
}

//----- (080B6D62) --------------------------------------------------------
long double __cdecl sub_80B6D62(float a1)
{
  return a1;
}

//----- (080B6D74) --------------------------------------------------------
int __cdecl sub_80B6D74(_DWORD *a1, int a2, int a3, int a4)
{
  int result; // eax

  *a1 = a2;
  a1[1] = a3;
  result = a4;
  a1[2] = a4;
  return result;
}

//----- (080B6D98) --------------------------------------------------------
float *__cdecl sub_80B6D98(float *a1, float a2, float *a3, float *a4)
{
  float *result; // eax

  *a4 = a2 * *a3 + *a1;
  a4[1] = a2 * a3[1] + a1[1];
  result = a3 + 2;
  a4[2] = a2 * a3[2] + a1[2];
  return result;
}

//----- (080B6DEC) --------------------------------------------------------
long double __cdecl sub_80B6DEC(float *a1, float *a2)
{
  return *a1 * *a2 + a1[1] * a2[1] + a1[2] * a2[2];
}

//----- (080B6E20) --------------------------------------------------------
int __cdecl sub_80B6E20(char *s1)
{
  int i; // [esp+14h] [ebp-4h]

  if ( !strcasecmp(s1, "default") )
    return 0;
  for ( i = 0; i <= 21; ++i )
  {
    if ( !strcasecmp(s1, (&off_8162960)[5 * i]) )
      return (dword_8162968[5 * i] & 0x1F00000) >> 20;
  }
  return -1;
}
// 8162960: using guessed type char *off_8162960;
// 8162968: using guessed type int dword_8162968[263];

//----- (080B6EB2) --------------------------------------------------------
const char *__cdecl sub_80B6EB2(int a1)
{
  if ( a1 <= 0 || a1 > 22 )
    return "default";
  else
    return (const char *)dword_816294C[5 * a1];
}
// 816294C: using guessed type int dword_816294C[];

//----- (080B6EE8) --------------------------------------------------------
int DObjInit()
{
  int result; // eax
  char s[40]; // [esp+10h] [ebp-28h] BYREF

  memset(s, 0, 0x14u);
  result = SL_GetStringOfLen(s, 0, 0x11u);
  dword_8527A68 = result;
  return result;
}
// 8527A68: using guessed type int dword_8527A68;

//----- (080B6F34) --------------------------------------------------------
int DObjShutdown()
{
  int result; // eax

  if ( dword_8527A68 )
  {
    result = sub_8079746(dword_8527A68, 0x11u);
    dword_8527A68 = 0;
  }
  return result;
}
// 8527A68: using guessed type int dword_8527A68;

//----- (080B6F64) --------------------------------------------------------
void DObjAbort()
{
  dword_8527A68 = 0;
}
// 8527A68: using guessed type int dword_8527A68;

//----- (080B6F74) --------------------------------------------------------
void __cdecl sub_80B6F74(int a1)
{
  const char *v1; // eax
  const char *v2; // ebx
  const char *v3; // eax
  __int16 **v4; // [esp+18h] [ebp-20h]
  unsigned __int8 *k; // [esp+1Ch] [ebp-1Ch]
  int v6; // [esp+20h] [ebp-18h]
  int v7; // [esp+24h] [ebp-14h]
  int v8; // [esp+28h] [ebp-10h]
  int i; // [esp+2Ch] [ebp-Ch]
  int j; // [esp+30h] [ebp-8h]

  if ( a1 )
  {
    Com_Printf("\nModels:\n");
    v7 = *(unsigned __int8 *)(a1 + 24);
    v6 = 0;
    for ( i = 0; i < v7; ++i )
    {
      v4 = *(__int16 ***)(a1 + 4 * i + 28);
      Com_Printf("%d: '%s'\n", v6, (const char *)v4[34]);
      v6 += **v4;
    }
    Com_Printf("\nBones:\n");
    v8 = *(unsigned __int8 *)(a1 + 25);
    for ( j = 0; j < v8; ++j )
    {
      v1 = (const char *)sub_80B8B16(a1, j);
      Com_Printf("Bone %d: '%s'\n", j, v1);
    }
    if ( *(_WORD *)(a1 + 16) )
    {
      Com_Printf("\nPart duplicates:\n");
      for ( k = (unsigned __int8 *)(SL_ConvertToString(*(unsigned __int16 *)(a1 + 16)) + 16); *k; k += 2 )
      {
        v2 = (const char *)sub_80B8B16(a1, k[1] - 1);
        v3 = (const char *)sub_80B8B16(a1, *k - 1);
        Com_Printf("%d ('%s') -> %d ('%s')\n", *k - 1, v3, k[1] - 1, v2);
      }
    }
    else
    {
      Com_Printf("\nNo part duplicates.\n");
    }
    Com_Printf("\n");
  }
  else
  {
    Com_Printf("No Dobj\n");
  }
}

//----- (080B712C) --------------------------------------------------------
int __cdecl sub_80B712C(int a1, int a2)
{
  int v4; // [esp+14h] [ebp-14h]
  __int16 **v5; // [esp+18h] [ebp-10h]
  int v6; // [esp+1Ch] [ebp-Ch]
  int i; // [esp+20h] [ebp-8h]
  int v8; // [esp+24h] [ebp-4h]

  v8 = *(unsigned __int8 *)(a1 + 24);
  v6 = 0;
  for ( i = 0; i < v8; ++i )
  {
    v5 = *(__int16 ***)(a1 + 4 * i + 28);
    v4 = sub_80C3324(v5, a2);
    if ( v4 >= 0 )
      return v6 + v4;
    v6 += **v5;
  }
  return -1;
}

//----- (080B71A8) --------------------------------------------------------
int __cdecl DObjCreateDuplicateParts(int a1)
{
  const char *v1; // eax
  int result; // eax
  int s[4]; // [esp+10h] [ebp-498h] BYREF
  int v4; // [esp+20h] [ebp-488h] BYREF
  __int16 *v5; // [esp+46Ch] [ebp-3Ch]
  int v6; // [esp+470h] [ebp-38h]
  char v7; // [esp+477h] [ebp-31h]
  int v8; // [esp+478h] [ebp-30h]
  int *v9; // [esp+47Ch] [ebp-2Ch]
  unsigned __int16 *v10; // [esp+480h] [ebp-28h]
  unsigned __int16 **v11; // [esp+484h] [ebp-24h]
  int v12; // [esp+488h] [ebp-20h]
  int i; // [esp+48Ch] [ebp-1Ch]
  int v14; // [esp+490h] [ebp-18h]
  __int16 **v15; // [esp+494h] [ebp-14h]
  int v16; // [esp+498h] [ebp-10h]
  int v17; // [esp+49Ch] [ebp-Ch]

  v9 = &v4;
  memset(s, 0, sizeof(s));
  v8 = 0;
  v16 = ***(__int16 ***)(a1 + 28);
  v17 = 1;
  while ( v17 < *(unsigned __int8 *)(a1 + 24) )
  {
    v15 = *(__int16 ***)(a1 + 4 * v17 + 28);
    if ( *(_BYTE *)(v17 + a1 + 60) == 0xFF )
    {
      v5 = *v15;
      v11 = (unsigned __int16 **)*((_DWORD *)v5 + 1);
      v10 = *v11;
      v12 = *v5;
      v7 = 0;
      v14 = -1;
      for ( i = 0; i < v12; ++i )
      {
        v14 = sub_80B712C(a1, v10[i]);
        if ( v14 != v16 + i )
        {
          if ( !i )
            v7 = 1;
          v6 = v16 + i;
          *((_BYTE *)v9 + v8) = v16 + i + 1;
          s[v6 >> 5] |= 1 << (v6 & 0x1F);
          *((_BYTE *)v9 + ++v8) = v14 + 1;
          ++v8;
        }
      }
      if ( !v7 )
      {
        v1 = (const char *)SL_ConvertToString(*v10);
        Com_Printf(
          "WARNING: Attempting to meld model, but root part '%s' of model '%s' not found in model '%s' or any of its descendants\n",
          v1,
          (const char *)v15[34],
          *(const char **)(*(_DWORD *)(a1 + 28) + 136));
      }
    }
    ++v17;
    v16 += **v15;
  }
  if ( v8 )
  {
    *((_BYTE *)v9 + v8++) = 0;
    result = SL_GetStringOfLen((char *)s, 0, v8 + 16);
    *(_WORD *)(a1 + 16) = result;
  }
  else
  {
    result = (unsigned __int16)dword_8527A68;
    *(_WORD *)(a1 + 16) = dword_8527A68;
  }
  return result;
}
// 8527A68: using guessed type int dword_8527A68;

//----- (080B73C0) --------------------------------------------------------
int __cdecl sub_80B73C0(int a1, int a2, int a3)
{
  int result; // eax
  int v4; // [esp+1Ch] [ebp-5Ch]
  int v5[8]; // [esp+20h] [ebp-58h]
  int v6; // [esp+40h] [ebp-38h]
  unsigned __int8 *k; // [esp+44h] [ebp-34h]
  int v8; // [esp+48h] [ebp-30h]
  int j; // [esp+4Ch] [ebp-2Ch]
  unsigned __int8 *v10; // [esp+50h] [ebp-28h]
  __int16 *v11; // [esp+54h] [ebp-24h]
  int i; // [esp+58h] [ebp-20h]
  int v13; // [esp+5Ch] [ebp-1Ch]

  for ( i = 0; i <= 3; ++i )
    *(_DWORD *)(a3 + 4 * i) = 0;
  v13 = *(unsigned __int8 *)(a1 + 24);
  if ( !*(_WORD *)(a1 + 16) )
    DObjCreateDuplicateParts(a1);
  v4 = SL_ConvertToString(*(unsigned __int16 *)(a1 + 16));
  v10 = (unsigned __int8 *)(v4 + 16);
  k = (unsigned __int8 *)(v4 + 16);
  v5[0] = 0;
  for ( i = 0; ; v5[i] = v6 )
  {
    v11 = **(__int16 ***)(a1 + 4 * i + 28);
    v6 = v5[i] + *v11;
    if ( v6 > a2 )
    {
      for ( j = *((_DWORD *)v11 + 1) + 4; ; a2 -= *(unsigned __int8 *)(j + v6) )
      {
        v8 = a2 - v5[i];
        while ( 1 )
        {
          *(_DWORD *)(a3 + 4 * (a2 >> 5)) |= 1 << (a2 & 0x1F);
          if ( (((unsigned __int8)(*(int *)(v4 + 4 * (a2 >> 5)) >> (a2 & 0x1F)) ^ 1) & 1) == 0 )
          {
            for ( k = v10; a2 != *k - 1; k += 2 )
              ;
            a2 = k[1] - 1;
            goto LABEL_21;
          }
          v6 = v8 - v11[1];
          if ( v6 >= 0 )
            break;
          result = *(unsigned __int8 *)(i + a1 + 60);
          a2 = result;
          if ( result == 255 )
            return result;
          do
LABEL_21:
            v8 = a2 - v5[--i];
          while ( v8 < 0 );
          v11 = **(__int16 ***)(a1 + 4 * i + 28);
          j = *((_DWORD *)v11 + 1) + 4;
        }
      }
    }
    result = ++i;
    if ( i == v13 )
      break;
  }
  return result;
}
// 80B73C0: using guessed type int var_58[8];

//----- (080B75A8) --------------------------------------------------------
int *__cdecl sub_80B75A8(int a1, int a2)
{
  int *result; // eax
  int v3; // [esp+18h] [ebp-60h]
  int v4; // [esp+1Ch] [ebp-5Ch]
  int v5[8]; // [esp+20h] [ebp-58h]
  int v6; // [esp+40h] [ebp-38h]
  unsigned __int8 *j; // [esp+44h] [ebp-34h]
  int v8; // [esp+48h] [ebp-30h]
  int i; // [esp+4Ch] [ebp-2Ch]
  unsigned __int8 *v10; // [esp+50h] [ebp-28h]
  __int16 *v11; // [esp+54h] [ebp-24h]
  int v12[8]; // [esp+58h] [ebp-20h] BYREF

  v3 = *(unsigned __int8 *)(a1 + 25) - 1;
  v12[1] = *(unsigned __int8 *)(a1 + 24);
  if ( !*(_WORD *)(a1 + 16) )
    DObjCreateDuplicateParts(a1);
  v4 = SL_ConvertToString(*(unsigned __int16 *)(a1 + 16));
  v10 = (unsigned __int8 *)(v4 + 16);
  j = (unsigned __int8 *)(v4 + 16);
  v5[0] = 0;
  for ( v12[0] = 0; ; v5[v12[0]] = v6 )
  {
    v11 = **(__int16 ***)(a1 + 4 * v12[0] + 28);
    v6 = v5[v12[0]] + *v11;
    if ( v6 > v3 )
      break;
    ++v12[0];
  }
  for ( i = *((_DWORD *)v11 + 1) + 4; ; i = *((_DWORD *)v11 + 1) + 4 )
  {
    while ( 1 )
    {
      v8 = v3 - v5[v12[0]];
      if ( v8 < 0 )
        break;
      if ( (((unsigned __int8)(*(int *)(a2 + 4 * (v3 >> 5)) >> (v3 & 0x1F)) ^ 1) & 1) != 0 )
      {
        --v3;
      }
      else
      {
        if ( (((unsigned __int8)(*(int *)(v4 + 4 * (v3 >> 5)) >> (v3 & 0x1F)) ^ 1) & 1) == 0 )
        {
          for ( j = v10; v3 != *j - 1; j += 2 )
            ;
          v6 = j[1] - 1;
          goto LABEL_21;
        }
        v6 = v8 - v11[1];
        if ( v6 >= 0 )
        {
          v6 = v3 - *(unsigned __int8 *)(i + v6);
          goto LABEL_21;
        }
        v6 = *(unsigned __int8 *)(v12[0] + a1 + 60);
        if ( v6 == 255 )
        {
          --v3;
        }
        else
        {
LABEL_21:
          *(_DWORD *)(a2 + 4 * (v6 >> 5)) |= 1 << (v6 & 0x1F);
          --v3;
        }
      }
    }
    result = v12;
    if ( --v12[0] < 0 )
      break;
    v11 = **(__int16 ***)(a1 + 4 * v12[0] + 28);
  }
  return result;
}
// 80B75A8: using guessed type int var_58[8];

//----- (080B7796) --------------------------------------------------------
int __cdecl sub_80B7796(int a1, int a2)
{
  return (*(int *)(*(_DWORD *)(a1 + 4) + 4 * (a2 >> 5) + 32) >> (a2 & 0x1F)) & 1;
}

//----- (080B77C2) --------------------------------------------------------
int __cdecl sub_80B77C2(int a1, int a2)
{
  int i; // [esp+8h] [ebp-8h]

  for ( i = 0; i <= 3; ++i )
  {
    if ( (*(_DWORD *)(a2 + 4 * i) & ~*(_DWORD *)(*(_DWORD *)(a1 + 4) + 4 * i + 32)) != 0 )
      return 0;
  }
  return 1;
}

//----- (080B7822) --------------------------------------------------------
int *__cdecl sub_80B7822(int a1, int a2)
{
  int *result; // eax
  float *v3; // ecx
  float *v4; // edx
  float *v5; // ecx
  float *v6; // edx
  int v7; // [esp+1Ch] [ebp-9Ch]
  char v8; // [esp+23h] [ebp-95h]
  int *v9; // [esp+24h] [ebp-94h]
  float *v10; // [esp+30h] [ebp-88h]
  unsigned __int8 *v11; // [esp+34h] [ebp-84h]
  int v12; // [esp+3Ch] [ebp-7Ch]
  int v13; // [esp+40h] [ebp-78h]
  int v14; // [esp+40h] [ebp-78h]
  int v15; // [esp+40h] [ebp-78h]
  int v16; // [esp+44h] [ebp-74h]
  int v17; // [esp+48h] [ebp-70h]
  int v18; // [esp+4Ch] [ebp-6Ch]
  int v19[12]; // [esp+50h] [ebp-68h]
  float *v20; // [esp+80h] [ebp-38h]
  int *v21; // [esp+84h] [ebp-34h]
  unsigned __int8 v22; // [esp+8Bh] [ebp-2Dh]
  unsigned __int8 *v23; // [esp+8Ch] [ebp-2Ch]
  __int16 *v24; // [esp+90h] [ebp-28h]
  int j; // [esp+94h] [ebp-24h]
  int i; // [esp+98h] [ebp-20h] BYREF
  float *v27; // [esp+9Ch] [ebp-1Ch]

  result = *(int **)(a1 + 4);
  v9 = result;
  v8 = 1;
  for ( i = 0; i <= 3; ++i )
  {
    v19[i + 4] = v9[i + 8] | ~*(_DWORD *)(a2 + 4 * i);
    if ( v19[i + 4] != -1 )
      v8 = 0;
    result = &i;
  }
  if ( !v8 )
  {
    if ( !*(_WORD *)(a1 + 16) )
      DObjCreateDuplicateParts(a1);
    v7 = SL_ConvertToString(*(unsigned __int16 *)(a1 + 16));
    for ( i = 0; i <= 3; ++i )
    {
      v9[i + 8] |= *(_DWORD *)(a2 + 4 * i);
      v19[i + 8] = v9[i + 4] & ~v19[i + 4];
      v19[i] = *(_DWORD *)(v7 + 4 * i) | v19[i + 8] | v19[i + 4];
    }
    for ( i = 0; i <= 3; ++i )
      v19[i + 8] |= ~v19[i];
    v12 = *(unsigned __int8 *)(a1 + 24);
    v21 = v9 + 12;
    v27 = (float *)(v9 + 12);
    v17 = 0;
    v11 = (unsigned __int8 *)(v7 + 16);
    for ( j = 0; ; ++j )
    {
      result = (int *)j;
      if ( j >= v12 )
        break;
      v24 = **(__int16 ***)(a1 + 4 * j + 28);
      v22 = *(_BYTE *)(j + a1 + 60);
      if ( v22 == 0xFF )
      {
        i = v24[1];
        while ( i )
        {
          v13 = 1 << (v17 & 0x1F);
          if ( (v19[(v17 >> 5) + 8] & v13) != 0 )
          {
            sub_80B9D76((int)v27);
          }
          else if ( v17 == *v11 - 1 )
          {
            v11 += 2;
            if ( (v19[(v17 >> 5) + 4] & v13) == 0 )
            {
              v3 = v27;
              v4 = (float *)&v21[8 * *(v11 - 1) - 8];
              *v27 = *v4;
              v3[1] = v4[1];
              v3[2] = v4[2];
              v3[3] = v4[3];
              v3[4] = v4[4];
              v3[5] = v4[5];
              v3[6] = v4[6];
              v3[7] = v4[7];
            }
          }
          --i;
          v27 += 8;
          ++v17;
        }
      }
      else
      {
        v10 = (float *)&v21[8 * v22];
        i = v24[1];
        while ( i )
        {
          v14 = 1 << (v17 & 0x1F);
          if ( (v19[(v17 >> 5) + 8] & v14) != 0 )
          {
            if ( (v14 & v19[v17 >> 5]) != 0 )
              sub_80B9FB2(v10, v27);
            else
              sub_80B9E7A(v27, v10);
            sub_80B9D76((int)v27);
            sub_80B9DC6(v27 + 4, v10);
          }
          --i;
          v27 += 8;
          ++v17;
        }
      }
      v18 = *((_DWORD *)v24 + 2);
      v20 = (float *)*((_DWORD *)v24 + 3);
      v23 = (unsigned __int8 *)(*((_DWORD *)v24 + 1) + 4);
      i = *v24 - v24[1];
      while ( i )
      {
        v16 = v17 >> 5;
        v15 = 1 << (v17 & 0x1F);
        if ( (v19[(v17 >> 5) + 8] & v15) != 0 )
        {
          if ( (v15 & v19[v16]) != 0 )
            sub_80B9FB2(&v27[-8 * *v23], v27);
          else
            sub_80B9E7A(v27, &v27[-8 * *v23]);
          sub_80B9D76((int)v27);
          sub_80B9B5C(v27 + 4, v20, v27 + 4);
          sub_80B9DC6(v27 + 4, &v27[-8 * *v23]);
        }
        else if ( v17 == *v11 - 1 )
        {
          v11 += 2;
          if ( (v19[v16 + 4] & v15) == 0 )
          {
            v5 = v27;
            v6 = (float *)&v21[8 * *(v11 - 1) - 8];
            *v27 = *v6;
            v5[1] = v6[1];
            v5[2] = v6[2];
            v5[3] = v6[3];
            v5[4] = v6[4];
            v5[5] = v6[5];
            v5[6] = v6[6];
            v5[7] = v6[7];
          }
        }
        --i;
        v27 += 8;
        v18 += 8;
        v20 += 3;
        ++v23;
        ++v17;
      }
    }
  }
  return result;
}

//----- (080B7D70) --------------------------------------------------------
_DWORD *__cdecl sub_80B7D70(_DWORD *a1, int a2)
{
  _DWORD *result; // eax
  unsigned __int8 v3; // [esp+1Bh] [ebp-Dh]
  unsigned __int8 *v4; // [esp+1Ch] [ebp-Ch]
  size_t n; // [esp+20h] [ebp-8h]

  *a1 = a2;
  if ( a2 )
  {
    n = *(_DWORD *)(*(_DWORD *)a2 + 4);
    a1[3] = a2 + 2 * n + 8;
    v4 = (unsigned __int8 *)(a1[3] + 2 * n);
    v3 = *v4 + 1;
    if ( *v4 == 0xFF )
    {
      v3 = 1;
      memset(v4 + 1, 0, n);
    }
    result = (_DWORD *)v3;
    *v4 = v3;
  }
  else
  {
    result = a1;
    a1[3] = 0;
  }
  return result;
}

//----- (080B7DFC) --------------------------------------------------------
int __cdecl sub_80B7DFC(int a1)
{
  float v2[4]; // [esp+10h] [ebp-58h] BYREF
  float v3[4]; // [esp+20h] [ebp-48h] BYREF
  float v4[4]; // [esp+30h] [ebp-38h] BYREF
  float v5[6]; // [esp+40h] [ebp-28h] BYREF
  int i; // [esp+58h] [ebp-10h]
  int v7; // [esp+5Ch] [ebp-Ch]

  v7 = *(unsigned __int8 *)(a1 + 24);
  sub_80B9B08(v3, 0, 0, 0);
  sub_80B9B08(v2, 0, 0, 0);
  for ( i = 0; i < v7; ++i )
  {
    if ( *(_DWORD *)(a1 + 4 * i + 28) )
    {
      sub_80C337C(*(_DWORD *)(a1 + 4 * i + 28), v5, v4);
      sub_80B9B5C(v3, v5, v3);
      sub_80B9B5C(v2, v4, v2);
    }
  }
  sub_80B9B2C(v3, (_DWORD *)(a1 + 76));
  return sub_80B9B2C(v2, (_DWORD *)(a1 + 88));
}
// 80B7DFC: using guessed type float var_48[4];
// 80B7DFC: using guessed type float var_58[4];
// 80B7DFC: using guessed type float var_38[4];
// 80B7DFC: using guessed type float var_28[6];

//----- (080B7EFC) --------------------------------------------------------
int __cdecl sub_80B7EFC(__int16 ***a1, unsigned int a2, int a3, int a4, __int16 a5)
{
  int v7; // [esp+20h] [ebp-38h]
  int v8; // [esp+30h] [ebp-28h]
  int v9; // [esp+34h] [ebp-24h]
  char *s2; // [esp+38h] [ebp-20h]
  __int16 **v11; // [esp+3Ch] [ebp-1Ch]
  int v12; // [esp+44h] [ebp-14h]
  int j; // [esp+48h] [ebp-10h]
  unsigned int i; // [esp+4Ch] [ebp-Ch]

  *(_DWORD *)(a4 + 4) = 0;
  *(_DWORD *)(a4 + 8) = 0;
  *(_WORD *)(a4 + 16) = 0;
  *(_BYTE *)(a4 + 26) = 0;
  sub_80B7D70((_DWORD *)a4, a3);
  if ( a3 )
    *(_WORD *)(a3 + 4) = a5;
  v7 = 0;
  v12 = 0;
  for ( i = 0; i < a2; ++i )
  {
    v11 = *a1;
    *(_DWORD *)(a4 + 4 * v7 + 28) = *a1;
    *(_BYTE *)(v7 + a4 + 60) = -1;
    *(_BYTE *)(v7 + a4 + 68) = v12;
    if ( a1[2] )
      *(_BYTE *)(a4 + 26) |= 1 << i;
    if ( i )
    {
      s2 = (char *)a1[1];
      if ( s2 )
      {
        if ( *s2 )
        {
          v9 = sub_8078CC6(s2);
          if ( v9 )
          {
            for ( j = 0; j < v7; ++j )
            {
              v8 = sub_80C3324(*(__int16 ***)(a4 + 4 * j + 28), v9);
              if ( v8 >= 0 )
              {
                *(_BYTE *)(v7 + a4 + 60) = *(_BYTE *)(j + a4 + 68) + v8;
                goto LABEL_17;
              }
            }
          }
          Com_Printf(
            "WARNING: Part '%s' not found in model '%s' or any of its descendants\n",
            s2,
            *(const char **)(*(_DWORD *)(a4 + 28) + 136));
        }
      }
    }
LABEL_17:
    if ( v11 )
    {
      if ( v12 + **v11 > 127 )
        Com_Error(1, (char *)&byte_8148D20, *(_DWORD *)(*(_DWORD *)(a4 + 28) + 136), 127);
      v12 += **v11;
    }
    ++v7;
    a1 += 3;
  }
  *(_BYTE *)(a4 + 24) = v7;
  *(_BYTE *)(a4 + 25) = v12;
  return sub_80B7DFC(a4);
}

//----- (080B812E) --------------------------------------------------------
_DWORD *__cdecl sub_80B812E(const void *a1, int a2, int a3)
{
  qmemcpy((void *)a3, a1, 0x64u);
  *(_DWORD *)(a3 + 4) = 0;
  if ( *(_WORD *)(a3 + 16) && *(unsigned __int16 *)(a3 + 16) != dword_8527A68 )
    sub_807951E(*(unsigned __int16 *)(a3 + 16));
  return sub_80B7D70((_DWORD *)a3, a2);
}
// 8527A68: using guessed type int dword_8527A68;

//----- (080B819E) --------------------------------------------------------
int __cdecl sub_80B819E(int a1)
{
  int result; // eax
  int v2; // eax
  size_t v3; // eax

  if ( *(_DWORD *)a1 )
  {
    *(_DWORD *)(a1 + 12) = 0;
    *(_DWORD *)a1 = 0;
  }
  result = a1;
  if ( *(_WORD *)(a1 + 16) )
  {
    if ( *(unsigned __int16 *)(a1 + 16) != dword_8527A68 )
    {
      v2 = SL_ConvertToString(*(unsigned __int16 *)(a1 + 16));
      v3 = I_strlen((char *)(v2 + 16));
      sub_8079746(*(unsigned __int16 *)(a1 + 16), v3 + 17);
    }
    result = a1;
    *(_WORD *)(a1 + 16) = 0;
  }
  return result;
}
// 8527A68: using guessed type int dword_8527A68;

//----- (080B821A) --------------------------------------------------------
int __cdecl sub_80B821A(unsigned __int8 *a1, _DWORD *a2, _WORD *a3, _DWORD *a4, _WORD *a5)
{
  int result; // eax
  __int16 v6; // [esp+1Ah] [ebp-1Eh]
  int v7; // [esp+20h] [ebp-18h]
  int v8; // [esp+24h] [ebp-14h]
  int j; // [esp+28h] [ebp-10h]
  int i; // [esp+2Ch] [ebp-Ch]

  *a3 = a1[24];
  *a4 = *(_DWORD *)a1;
  if ( *(_DWORD *)a1 )
    v6 = *(_WORD *)(*(_DWORD *)a1 + 4);
  else
    v6 = 0;
  *a5 = v6;
  for ( i = 0; ; ++i )
  {
    result = a1[24];
    if ( i >= result )
      break;
    *a2 = *(_DWORD *)&a1[4 * i + 28];
    a2[1] = 0;
    a2[2] = (((int)a1[26] >> i) & 1) != 0;
    if ( a1[i + 60] != 0xFF )
    {
      for ( j = i - 1; j >= 0; --j )
      {
        if ( a1[i + 60] >= a1[j + 68] )
        {
          v8 = a1[i + 60] - a1[j + 68];
          v7 = sub_80C3314(*(_DWORD *)&a1[4 * j + 28]);
          a2[1] = SL_ConvertToString(*(unsigned __int16 *)(v7 + 2 * v8));
          break;
        }
      }
    }
    a2 += 3;
  }
  return result;
}

//----- (080B8380) --------------------------------------------------------
int __cdecl sub_80B8380(int a1)
{
  return 32 * *(unsigned __int8 *)(a1 + 25) + 48;
}

//----- (080B83A2) --------------------------------------------------------
_BOOL4 __cdecl DObjSkelExists(int a1, int a2)
{
  if ( *(_DWORD *)(a1 + 8) == a2 )
    return *(_DWORD *)(a1 + 4) != 0;
  *(_DWORD *)(a1 + 4) = 0;
  return 0;
}

//----- (080B840A) --------------------------------------------------------
int __cdecl sub_80B840A(int a1)
{
  int result; // eax

  *(_DWORD *)(a1 + 8) = 0;
  result = a1;
  *(_DWORD *)(a1 + 4) = 0;
  return result;
}

//----- (080B8424) --------------------------------------------------------
int *__cdecl sub_80B8424(int a1, int a2, int *a3)
{
  int *result; // eax
  int i; // [esp+4h] [ebp-4h] BYREF

  *(_DWORD *)(a1 + 4) = a2;
  result = a3;
  *(_DWORD *)(a1 + 8) = a3;
  for ( i = 0; i <= 3; ++i )
  {
    *(_DWORD *)(a2 + 4 * i) = 0;
    *(_DWORD *)(a2 + 4 * i + 16) = 0;
    *(_DWORD *)(a2 + 4 * i + 32) = 0;
    result = &i;
  }
  return result;
}

//----- (080B8490) --------------------------------------------------------
int __cdecl sub_80B8490(int a1, int a2)
{
  return *(_DWORD *)(a1 + 4 * a2 + 28);
}

//----- (080B84A0) --------------------------------------------------------
int __cdecl sub_80B84A0(int a1, _DWORD *a2, _DWORD *a3)
{
  sub_80B9B2C((_DWORD *)(a1 + 76), a2);
  return sub_80B9B2C((_DWORD *)(a1 + 88), a3);
}

//----- (080B84D2) --------------------------------------------------------
int __cdecl sub_80B84D2(int a1)
{
  if ( *(_DWORD *)(a1 + 4) )
    return *(_DWORD *)(a1 + 4) + 48;
  else
    return 0;
}

//----- (080B858C) --------------------------------------------------------
int __cdecl sub_80B858C(int a1, int a2, int a3)
{
  int v5; // [esp+4h] [ebp-14h]
  int v6; // [esp+8h] [ebp-10h]
  int v7; // [esp+Ch] [ebp-Ch]

  v7 = a3 >> 5;
  v6 = 1 << (a3 & 0x1F);
  if ( (*(_DWORD *)(a2 + 4 * (a3 >> 5)) & v6) == 0 )
    return 0;
  v5 = *(_DWORD *)(a1 + 4);
  if ( (*(_DWORD *)(v5 + 4 * v7 + 32) & v6) != 0 )
    return 0;
  *(_DWORD *)(v5 + 4 * v7) |= v6;
  return 1;
}

//----- (080B8616) --------------------------------------------------------
int __cdecl sub_80B8616(int a1, int a2, int a3)
{
  int v5; // [esp+4h] [ebp-14h]
  int v6; // [esp+8h] [ebp-10h]
  int v7; // [esp+Ch] [ebp-Ch]

  v7 = a3 >> 5;
  v6 = 1 << (a3 & 0x1F);
  if ( (*(_DWORD *)(a2 + 4 * (a3 >> 5)) & v6) == 0 )
    return 0;
  v5 = *(_DWORD *)(a1 + 4);
  if ( (*(_DWORD *)(v5 + 4 * v7 + 32) & v6) != 0 )
    return 0;
  *(_DWORD *)(v5 + 4 * v7 + 16) |= v6;
  *(_DWORD *)(v5 + 4 * v7) |= v6;
  return 1;
}

//----- (080B8768) --------------------------------------------------------
const char *__cdecl sub_80B8768(int a1, int a2, int a3, int a4)
{
  unsigned __int16 v6; // [esp+16h] [ebp-2h]

  v6 = *(_WORD *)(*(_DWORD *)(*(_DWORD *)(a1 + 4 * a2 + 28) + 20 * a4 + 16) + 2 * a3);
  if ( v6 )
    return (const char *)SL_ConvertToString(v6);
  else
    return "DEFAULT";
}

//----- (080B87BE) --------------------------------------------------------
int __cdecl sub_80B87BE(int a1, int a2, void *s, int a4)
{
  int v4; // ebx
  const char *v5; // eax
  int v7; // [esp+20h] [ebp-58h] BYREF
  __int16 **v8; // [esp+24h] [ebp-54h]
  int v9; // [esp+28h] [ebp-50h] BYREF
  int j; // [esp+2Ch] [ebp-4Ch]
  int v11; // [esp+30h] [ebp-48h]
  int v12; // [esp+34h] [ebp-44h]
  int v13; // [esp+38h] [ebp-40h]
  int v14; // [esp+3Ch] [ebp-3Ch]
  int v15; // [esp+40h] [ebp-38h]
  __int16 **v16; // [esp+44h] [ebp-34h]
  int v17; // [esp+48h] [ebp-30h]
  _DWORD *v18; // [esp+4Ch] [ebp-2Ch]
  int k; // [esp+50h] [ebp-28h]
  int v20; // [esp+54h] [ebp-24h]
  __int16 *v21; // [esp+58h] [ebp-20h]
  int v22; // [esp+5Ch] [ebp-1Ch]
  int i; // [esp+60h] [ebp-18h]
  int v24; // [esp+64h] [ebp-14h]
  int v25; // [esp+68h] [ebp-10h]

  memset(s, 0, 0x10u);
  v25 = *(unsigned __int8 *)(a1 + 24);
  v11 = 0;
  for ( i = 0; i < v25; ++i )
  {
    if ( *(char *)(a4 + i) >= 0 )
    {
      v16 = *(__int16 ***)(a1 + 4 * i + 28);
      v8 = &v16[5 * *(char *)(a4 + i) + 1];
      v21 = v8[4];
      if ( v21 )
      {
        v17 = (**v16 - 1) >> 5;
        v22 = *((__int16 *)v8 + 4);
        if ( v11 + v22 > 64 )
        {
          Com_Printf("ERROR: models with more than %i total surfaces\n", 64);
          for ( j = 0; j < v25; ++j )
          {
            v16 = (__int16 **)sub_80B8490(a1, j);
            v4 = sub_80C5482((int)v16, &v9, *(char *)(a4 + j), &v7);
            v5 = (const char *)sub_80C5414((int)v16);
            Com_Printf("  model '%s' lod %i has %i surfaces\n", v5, *(char *)(a4 + j), v4);
          }
          Com_Error(1, "Max surfs exceeded - see console for details");
        }
        v24 = 0;
        while ( v24 < v22 )
        {
          *(_WORD *)(a2 + 4 * v11 + 2) = v24;
          *(_WORD *)(a2 + 4 * v11) = i;
          ++v24;
          ++v11;
        }
        v20 = *(unsigned __int8 *)(i + a1 + 68);
        v18 = v21 + 2;
        v12 = v20 >> 5;
        v14 = v20 & 0x1F;
        if ( (v20 & 0x1F) != 0 )
        {
          v13 = 32 - v14;
          *((_DWORD *)s + v12) |= *v18 << v14;
          v15 = v12 + 1;
          for ( k = 0; k < v17; ++k )
            *((_DWORD *)s + v15++) |= (v18[k] >> v13) | (v18[k + 1] << v14);
          *((_DWORD *)s + v15) |= v18[k] >> v13;
        }
        else
        {
          v15 = v12;
          for ( k = 0; k <= v17; ++k )
            *((_DWORD *)s + v15++) |= v18[k];
        }
      }
    }
  }
  return v11;
}

//----- (080B8AF6) --------------------------------------------------------
int __cdecl sub_80B8AF6(int a1, int a2)
{
  return sub_80B712C(a1, a2);
}

//----- (080B8B16) --------------------------------------------------------
int __cdecl sub_80B8B16(int a1, int a2)
{
  int v4; // [esp+24h] [ebp-14h]
  __int16 **v5; // [esp+28h] [ebp-10h]
  int v6; // [esp+2Ch] [ebp-Ch]
  int i; // [esp+30h] [ebp-8h]

  v6 = 0;
  for ( i = 0; i < *(unsigned __int8 *)(a1 + 24); ++i )
  {
    v5 = *(__int16 ***)(a1 + 4 * i + 28);
    v4 = **v5;
    if ( a2 - v6 < v4 )
      return SL_ConvertToString(*(unsigned __int16 *)(**((_DWORD **)*v5 + 1) + 2 * (a2 - v6)));
    v6 += v4;
  }
  return 0;
}

//----- (080B8BB6) --------------------------------------------------------
int __cdecl sub_80B8BB6(int a1)
{
  return *(_DWORD *)a1;
}

//----- (080B8BC0) --------------------------------------------------------
int __cdecl sub_80B8BC0(int a1)
{
  int i; // [esp+14h] [ebp-4h]

  for ( i = *(unsigned __int8 *)(a1 + 24) - 1; i >= 0; --i )
  {
    if ( XModelBad(*(_DWORD *)(a1 + 4 * i + 28)) )
      return 1;
  }
  return 0;
}

//----- (080B8C0C) --------------------------------------------------------
int __cdecl sub_80B8C0C(int a1)
{
  return *(unsigned __int8 *)(a1 + 25);
}

//----- (080B8C18) --------------------------------------------------------
float *__cdecl sub_80B8C18(float *a1, float *a2, float *a3)
{
  float *result; // eax
  float v4[12]; // [esp+10h] [ebp-48h] BYREF
  float v5; // [esp+40h] [ebp-18h] BYREF
  float v6; // [esp+44h] [ebp-14h]
  float v7; // [esp+48h] [ebp-10h]

  sub_80B9BA0(a1, a2 + 4, &v5);
  sub_80A913C(a2, v4);
  *a3 = v5 * v4[0] + v6 * v4[1] + v7 * v4[2];
  a3[1] = v5 * v4[3] + v6 * v4[4] + v7 * v4[5];
  result = a3 + 2;
  a3[2] = v5 * v4[6] + v6 * v4[7] + v7 * v4[8];
  return result;
}

//----- (080B8CA6) --------------------------------------------------------
void __cdecl sub_80B8CA6(int a1, float *a2, float *a3, int a4, int a5)
{
  long double v5; // fst7
  long double v6; // fst7
  float v7; // [esp+0h] [ebp-288h]
  __int16 v8[131]; // [esp+2Eh] [ebp-25Ah]
  float v9; // [esp+134h] [ebp-154h]
  unsigned __int16 v10; // [esp+13Ah] [ebp-14Eh]
  int *v11; // [esp+13Ch] [ebp-14Ch]
  unsigned __int8 v12; // [esp+143h] [ebp-145h]
  int v13; // [esp+144h] [ebp-144h]
  __int16 *v14; // [esp+148h] [ebp-140h]
  unsigned __int8 *v15; // [esp+14Ch] [ebp-13Ch]
  int v16; // [esp+150h] [ebp-138h]
  unsigned int v17; // [esp+154h] [ebp-134h]
  unsigned int v18; // [esp+158h] [ebp-130h]
  int v19; // [esp+15Ch] [ebp-12Ch]
  int v20; // [esp+160h] [ebp-128h]
  int v21; // [esp+164h] [ebp-124h]
  int v22; // [esp+168h] [ebp-120h]
  int v23; // [esp+16Ch] [ebp-11Ch]
  float v24; // [esp+170h] [ebp-118h]
  int v25; // [esp+174h] [ebp-114h]
  float v26; // [esp+178h] [ebp-110h]
  char v27; // [esp+17Eh] [ebp-10Ah]
  char v28; // [esp+17Fh] [ebp-109h]
  __int16 *i; // [esp+180h] [ebp-108h]
  int j; // [esp+184h] [ebp-104h]
  float v31; // [esp+188h] [ebp-100h]
  float v32; // [esp+18Ch] [ebp-FCh]
  float v33; // [esp+190h] [ebp-F8h]
  int v34; // [esp+194h] [ebp-F4h]
  int v35; // [esp+198h] [ebp-F0h]
  float v36; // [esp+19Ch] [ebp-ECh]
  float v37[4]; // [esp+1A0h] [ebp-E8h] BYREF
  float v38[7]; // [esp+1B0h] [ebp-D8h] BYREF
  float v39; // [esp+1CCh] [ebp-BCh]
  int v40[7]; // [esp+1D0h] [ebp-B8h] BYREF
  float v41; // [esp+1ECh] [ebp-9Ch]
  float v42[4]; // [esp+1F0h] [ebp-98h] BYREF
  int v43[4]; // [esp+200h] [ebp-88h] BYREF
  float v44[4]; // [esp+210h] [ebp-78h] BYREF
  float v45[13]; // [esp+220h] [ebp-68h] BYREF
  float *v46; // [esp+254h] [ebp-34h]
  float *v47; // [esp+258h] [ebp-30h]
  int v48; // [esp+25Ch] [ebp-2Ch]
  float v49; // [esp+260h] [ebp-28h]
  __int16 *v50; // [esp+264h] [ebp-24h]
  __int16 **v51; // [esp+268h] [ebp-20h]
  float v52; // [esp+26Ch] [ebp-1Ch]
  int v53[6]; // [esp+270h] [ebp-18h] BYREF

  *(_DWORD *)(a5 + 4) = 0;
  *(_WORD *)(a5 + 20) = 0;
  *(_WORD *)(a5 + 22) = 0;
  sub_80B9ADE((_DWORD *)(a5 + 8));
  sub_80B9BA0(a3, a2, (float *)v53);
  v9 = sub_80B9CA4((float *)v53);
  if ( v9 == 0.0 )
    return;
  v47 = (float *)sub_80B84D2(a1);
  if ( !v47 )
    return;
  v52 = 1.0 / v9;
  v18 = 2;
  v20 = *(_DWORD *)(a1 + 4);
  v15 = (unsigned __int8 *)(SL_ConvertToString(*(unsigned __int16 *)(a1 + 16)) + 16);
  v21 = 0;
  v23 = -1;
  v22 = -1;
  v24 = 0.0;
  v46 = 0;
  v34 = *(_DWORD *)a5;
  v19 = 0;
LABEL_4:
  if ( v19 < *(unsigned __int8 *)(a1 + 24) )
  {
    v51 = *(__int16 ***)(a1 + 4 * v19 + 28);
    v50 = *v51;
    v11 = (int *)*((_DWORD *)v50 + 1);
    v16 = *v11;
    v48 = *v50;
    v13 = *(unsigned __int8 *)(a1 + 26) & (1 << v19);
    v25 = 0;
    while ( 1 )
    {
      if ( v25 >= v48 )
      {
        ++v19;
        goto LABEL_4;
      }
      v10 = *(unsigned __int8 *)(*((_DWORD *)v50 + 4) + v25);
      v17 = *(unsigned __int8 *)(v10 + a4);
      if ( v21 == *v15 - 1 )
      {
        v15 += 2;
        if ( v17 == 1 )
        {
          v10 = v8[*(v15 - 1)];
          v17 = *(unsigned __int8 *)(v10 + a4);
        }
      }
      else if ( v17 == 1 )
      {
        if ( v25 >= v50[1] )
        {
          v10 = v8[v21 - *((unsigned __int8 *)v11 + v25 - v50[1] + 4) + 1];
        }
        else
        {
          v12 = *(_BYTE *)(v19 + a1 + 60);
          if ( v12 == 0xFF )
            v8[0] = 0;
          else
            v8[0] = v8[v12 + 1];
          v10 = v8[0];
        }
        v17 = *(unsigned __int8 *)(v10 + a4);
      }
      v8[v21 + 1] = v10;
      if ( !v13 )
      {
        v14 = &v51[24][20 * v25];
        if ( *((float *)v14 + 9) != 0.0 && v18 <= v17 )
        {
          sub_80A9094((float *)v14 + 6, v47, v44);
          sub_80B9BA0(a2, v44, (float *)v43);
          v5 = sub_80B9C70((float *)v43, (float *)v53);
          v41 = -v5 * v52;
          if ( v41 >= 1.0 )
          {
            sub_80B9BA0(a3, v44, v42);
            v49 = sub_80B9CA4(v42);
          }
          else if ( v41 <= 0.0 )
          {
            v49 = sub_80B9CA4((float *)v43);
          }
          else
          {
            sub_80B9C1C((float *)v43, v41, (float *)v53, (float *)v40);
            v49 = sub_80B9CA4((float *)v40);
          }
          v39 = *((float *)v14 + 9) - v49;
          if ( v39 > 0.0 )
          {
            if ( v18 != v17 || (v7 = v39 * v52, v6 = sqrtf(v7), v41 - v6 < *(float *)a5) )
            {
              sub_80B8C18(a2, v47, v38);
              sub_80B8C18(a3, v47, v37);
              v36 = 0.0;
              if ( v18 == v17 )
                v35 = *(int *)a5;
              else
                v35 = v34;
              v28 = 1;
              v27 = 1;
              v26 = -1.0;
              for ( i = v14; ; i += 6 )
              {
                for ( j = 0; j <= 2; ++j )
                {
                  v33 = (v38[j] - *(float *)&i[2 * j]) * v26;
                  v32 = (v37[j] - *(float *)&i[2 * j]) * v26;
                  if ( v33 <= 0.0 )
                  {
                    if ( v32 > 0.0 )
                    {
                      v27 = 0;
                      v31 = v33 - v32;
                      if ( v33 > *(float *)&v35 * v31 )
                      {
                        *(float *)&v35 = v33 / v31;
                        if ( v36 >= (long double)*(float *)&v35 )
                          goto LABEL_58;
                      }
                    }
                  }
                  else
                  {
                    if ( v32 > 0.0 )
                      goto LABEL_58;
                    v28 = 0;
                    v31 = v33 - v32;
                    if ( v33 > v36 * v31 )
                    {
                      v36 = v33 / v31;
                      if ( v36 >= (long double)*(float *)&v35 )
                        goto LABEL_58;
                      v24 = v26;
                      v23 = j;
                    }
                  }
                }
                if ( v26 == 1.0 )
                  break;
                v26 = 1.0;
              }
              if ( v28 )
              {
                if ( v27 && sub_80B9ABC((float *)v53, a2) <= 0.0 )
                {
                  *(_DWORD *)a5 = 0;
                  *(_WORD *)(a5 + 20) = *(_WORD *)(v16 + 2 * v25);
                  *(_WORD *)(a5 + 22) = v10;
                  if ( *(float *)v53 == 0.0 && *(float *)&v53[1] == 0.0 )
                  {
                    sub_80B9A48(*(float *)&v53[2]);
                    *(float *)(a5 + 16) = -(float)0.0;
                  }
                  else
                  {
                    sub_80B9A9C(a2, (_DWORD *)(a5 + 8));
                    sub_80A215E((float *)(a5 + 8));
                  }
                  return;
                }
              }
              else
              {
                if ( v18 == v17 )
                {
                  if ( v36 >= (long double)*(float *)a5 )
                    goto LABEL_58;
                }
                else
                {
                  v18 = v17;
                }
                *(float *)a5 = v36;
                *(_WORD *)(a5 + 20) = *(_WORD *)(v16 + 2 * v25);
                *(_WORD *)(a5 + 22) = v10;
                v22 = v23;
                v46 = v47;
              }
            }
          }
        }
      }
LABEL_58:
      ++v25;
      v47 += 8;
      ++v21;
    }
  }
  if ( v46 )
  {
    sub_80A913C(v46, v45);
    sub_80B9BE4(&v45[3 * v22], v24, (float *)(a5 + 8));
  }
}
// 80B8CA6: using guessed type float var_78[4];
// 80B8CA6: using guessed type float var_98[4];
// 80B8CA6: using guessed type float var_D8[7];
// 80B8CA6: using guessed type float var_E8[4];
// 80B8CA6: using guessed type float var_68[13];

//----- (080B955A) --------------------------------------------------------
int __cdecl sub_80B955A(int a1, float *a2, float *a3, int a4, int a5)
{
  int v6; // [esp+28h] [ebp-50h]
  int v7; // [esp+2Ch] [ebp-4Ch]
  int i; // [esp+30h] [ebp-48h]
  int v9; // [esp+34h] [ebp-44h]
  __int16 *v10; // [esp+38h] [ebp-40h]
  int v11; // [esp+3Ch] [ebp-3Ch]
  int v12; // [esp+40h] [ebp-38h] BYREF
  _DWORD v13[3]; // [esp+44h] [ebp-34h] BYREF
  int v14; // [esp+50h] [ebp-28h]

  *(_WORD *)(a5 + 20) = 0;
  *(_WORD *)(a5 + 22) = 0;
  v12 = *(_DWORD *)a5;
  v14 = 0;
  sub_80B9ADE(v13);
  v9 = sub_80B84D2(a1);
  if ( v9 )
  {
    for ( i = 0; i < *(unsigned __int8 *)(a1 + 24); ++i )
    {
      v11 = *(_DWORD *)(a1 + 4 * i + 28);
      v10 = *(__int16 **)v11;
      v7 = **(_DWORD **)(*(_DWORD *)v11 + 4);
      v6 = sub_80C33FE(v11, (int)&v12, v9, a2, a3, a4);
      if ( v6 >= 0 )
        *(_WORD *)(a5 + 20) = *(_WORD *)(v7 + 2 * v6);
      v9 += 32 * *v10;
    }
  }
  *(_DWORD *)a5 = v12;
  *(_DWORD *)(a5 + 4) = v14;
  return sub_80B9B2C(v13, (_DWORD *)(a5 + 8));
}

//----- (080B9676) --------------------------------------------------------
int __cdecl sub_80B9676(int a1, int a2, float a3)
{
  return sub_80C5556(*(_DWORD *)(a1 + 4 * a2 + 28), a3);
}

//----- (080B9698) --------------------------------------------------------
long double __cdecl sub_80B9698(int a1)
{
  float v2; // [esp+Ch] [ebp-Ch]
  float v3; // [esp+10h] [ebp-8h]
  int i; // [esp+14h] [ebp-4h]

  v2 = 0.0;
  for ( i = 0; i < *(unsigned __int8 *)(a1 + 24); ++i )
  {
    v3 = sub_80C5506(*(_DWORD *)(a1 + 4 * i + 28));
    if ( v3 > (long double)v2 )
      v2 = v3;
  }
  return v2;
}

//----- (080B96F8) --------------------------------------------------------
int __cdecl sub_80B96F8(int a1, int a2)
{
  int i; // [esp+14h] [ebp-4h]

  for ( i = 0; i < *(unsigned __int8 *)(a1 + 24); ++i )
  {
    if ( (a2 & sub_80C33CA(*(_DWORD *)(a1 + 4 * i + 28))) != 0 )
      return 1;
  }
  return 0;
}

//----- (080B9748) --------------------------------------------------------
float *__cdecl sub_80B9748(int a1, _DWORD *a2, float *a3, int a4)
{
  float *result; // eax
  float v5; // [esp+0h] [ebp-78h]
  float v6; // [esp+0h] [ebp-78h]
  float v7; // [esp+0h] [ebp-78h]
  float v8; // [esp+40h] [ebp-38h]
  float v9; // [esp+44h] [ebp-34h]
  float v10; // [esp+48h] [ebp-30h]
  float v11; // [esp+4Ch] [ebp-2Ch]
  int v12; // [esp+50h] [ebp-28h] BYREF
  float v13; // [esp+54h] [ebp-24h] BYREF
  int v14; // [esp+58h] [ebp-20h] BYREF
  float v15; // [esp+5Ch] [ebp-1Ch] BYREF
  int v16; // [esp+60h] [ebp-18h] BYREF
  float v17[2]; // [esp+64h] [ebp-14h] BYREF
  float *v18; // [esp+6Ch] [ebp-Ch]

  result = (float *)sub_80B84D2(a1);
  v18 = result;
  if ( result )
  {
    v18 += 8 * a4;
    if ( a3 )
    {
      v5 = a3[1] * 0.008726646259971648;
      sub_80B9A6E(v5, (float *)&v16, v17);
      v6 = *a3 * 0.008726646259971648;
      sub_80B9A6E(v6, (float *)&v12, &v13);
      v7 = a3[2] * 0.008726646259971648;
      sub_80B9A6E(v7, (float *)&v14, &v15);
      v8 = -*(float *)&v12 * *(float *)&v16;
      v9 = *(float *)&v12 * v17[0];
      v10 = v13 * *(float *)&v16;
      v11 = v13 * v17[0];
      *v18 = *(float *)&v14 * v11 + v15 * v8;
      v18[1] = v15 * v9 + *(float *)&v14 * v10;
      v18[2] = -*(float *)&v14 * v9 + v15 * v10;
      v18[3] = v15 * v11 - *(float *)&v14 * v8;
    }
    else
    {
      sub_80B9CD8(v18, 0, 0, 0, 1065353216);
    }
    v18[7] = 0.0;
    return (float *)sub_80B9B2C(a2, (_DWORD *)v18 + 4);
  }
  return result;
}
// 80B9748: using guessed type float var_14[2];

//----- (080B98CC) --------------------------------------------------------
int __cdecl sub_80B98CC(int a1, int a2, int a3, float *a4)
{
  int v6; // [esp+14h] [ebp-4h]

  v6 = sub_80B8AF6(a1, a3);
  if ( v6 < 0 )
    return 0;
  if ( !sub_80B8616(a1, a2, v6) )
    return 0;
  sub_80B9748(a1, flt_8145E68, a4, v6);
  return 1;
}
// 8145E68: using guessed type float flt_8145E68[3];

//----- (080B994A) --------------------------------------------------------
int __cdecl sub_80B994A(int a1, int a2, int a3, _DWORD *a4, float *a5)
{
  int v7; // [esp+14h] [ebp-4h]

  v7 = sub_80B8AF6(a1, a3);
  if ( v7 < 0 )
    return 0;
  if ( !sub_80B858C(a1, a2, v7) )
    return 0;
  sub_80B9748(a1, a4, a5, v7);
  return 1;
}

//----- (080B99C6) --------------------------------------------------------
int __cdecl sub_80B99C6(int a1, int a2, int a3, _DWORD *a4, float *a5)
{
  if ( !sub_80B858C(a1, a2, a3) )
    return 0;
  sub_80B9748(a1, a4, a5, a3);
  return 1;
}

//----- (080B9A48) --------------------------------------------------------
void __cdecl sub_80B9A48(float a1)
{
  sub_80B9D06(a1, 1.0, -1.0);
}

//----- (080B9A6E) --------------------------------------------------------
void __cdecl sub_80B9A6E(float a1, float *a2, float *a3)
{
  *a2 = sin(a1);
  *a3 = cos(a1);
}

//----- (080B9A9C) --------------------------------------------------------
int __cdecl sub_80B9A9C(_DWORD *a1, _DWORD *a2)
{
  int result; // eax

  *a2 = *a1;
  result = a1[1];
  a2[1] = result;
  return result;
}

//----- (080B9ABC) --------------------------------------------------------
long double __cdecl sub_80B9ABC(float *a1, float *a2)
{
  return *a1 * *a2 + a1[1] * a2[1];
}

//----- (080B9ADE) --------------------------------------------------------
int __cdecl sub_80B9ADE(_DWORD *a1)
{
  int result; // eax

  *a1 = 0;
  a1[1] = 0;
  result = 0;
  a1[2] = 0;
  return result;
}

//----- (080B9B08) --------------------------------------------------------
int __cdecl sub_80B9B08(_DWORD *a1, int a2, int a3, int a4)
{
  int result; // eax

  *a1 = a2;
  a1[1] = a3;
  result = a4;
  a1[2] = a4;
  return result;
}

//----- (080B9B2C) --------------------------------------------------------
int __cdecl sub_80B9B2C(_DWORD *a1, _DWORD *a2)
{
  int result; // eax

  *a2 = *a1;
  a2[1] = a1[1];
  result = a1[2];
  a2[2] = result;
  return result;
}

//----- (080B9B5C) --------------------------------------------------------
float *__cdecl sub_80B9B5C(float *a1, float *a2, float *a3)
{
  float *result; // eax

  *a3 = *a1 + *a2;
  a3[1] = a1[1] + a2[1];
  result = a1 + 2;
  a3[2] = a1[2] + a2[2];
  return result;
}

//----- (080B9BA0) --------------------------------------------------------
float *__cdecl sub_80B9BA0(float *a1, float *a2, float *a3)
{
  float *result; // eax

  *a3 = *a1 - *a2;
  a3[1] = a1[1] - a2[1];
  result = a1 + 2;
  a3[2] = a1[2] - a2[2];
  return result;
}

//----- (080B9BE4) --------------------------------------------------------
float *__cdecl sub_80B9BE4(float *a1, float a2, float *a3)
{
  float *result; // eax

  *a3 = a2 * *a1;
  a3[1] = a2 * a1[1];
  result = a1 + 2;
  a3[2] = a2 * a1[2];
  return result;
}

//----- (080B9C1C) --------------------------------------------------------
float *__cdecl sub_80B9C1C(float *a1, float a2, float *a3, float *a4)
{
  float *result; // eax

  *a4 = a2 * *a3 + *a1;
  a4[1] = a2 * a3[1] + a1[1];
  result = a3 + 2;
  a4[2] = a2 * a3[2] + a1[2];
  return result;
}

//----- (080B9C70) --------------------------------------------------------
long double __cdecl sub_80B9C70(float *a1, float *a2)
{
  return *a1 * *a2 + a1[1] * a2[1] + a1[2] * a2[2];
}

//----- (080B9CA4) --------------------------------------------------------
long double __cdecl sub_80B9CA4(float *a1)
{
  return *a1 * *a1 + a1[1] * a1[1] + a1[2] * a1[2];
}

//----- (080B9CD8) --------------------------------------------------------
int __cdecl sub_80B9CD8(_DWORD *a1, int a2, int a3, int a4, int a5)
{
  int result; // eax

  *a1 = a2;
  a1[1] = a3;
  a1[2] = a4;
  result = a5;
  a1[3] = a5;
  return result;
}

//----- (080B9D06) --------------------------------------------------------
long double __cdecl sub_80B9D06(float a1, float a2, float a3)
{
  if ( a1 < 0.0 )
    return a3;
  return a2;
}

//----- (080B9D30) --------------------------------------------------------
long double __cdecl sub_80B9D30(float *a1)
{
  return *a1 * *a1 + a1[1] * a1[1] + a1[2] * a1[2] + a1[3] * a1[3];
}

//----- (080B9D76) --------------------------------------------------------
int __cdecl sub_80B9D76(int a1)
{
  int result; // eax
  float v2; // [esp+4h] [ebp-4h]

  v2 = sub_80B9D30((float *)a1);
  if ( v2 == 0.0 )
  {
    *(_DWORD *)(a1 + 12) = 1065353216;
    result = 0x40000000;
    *(_DWORD *)(a1 + 28) = 0x40000000;
  }
  else
  {
    result = a1;
    *(float *)(a1 + 28) = 2.0 / v2;
  }
  return result;
}

//----- (080B9DC6) --------------------------------------------------------
int __cdecl sub_80B9DC6(float *a1, float *a2)
{
  int result; // eax
  float v3[14]; // [esp+10h] [ebp-48h] BYREF
  float v4; // [esp+48h] [ebp-10h]
  float v5; // [esp+4Ch] [ebp-Ch]

  sub_80A913C(a2, v3);
  v4 = *a1 * v3[0] + a1[1] * v3[3] + a1[2] * v3[6] + a2[4];
  v5 = *a1 * v3[1] + a1[1] * v3[4] + a1[2] * v3[7] + a2[5];
  a1[2] = *a1 * v3[2] + a1[1] * v3[5] + a1[2] * v3[8] + a2[6];
  *a1 = v4;
  result = LODWORD(v5);
  a1[1] = v5;
  return result;
}

//----- (080B9E7A) --------------------------------------------------------
int __cdecl sub_80B9E7A(float *a1, float *a2)
{
  int result; // eax
  float v3; // [esp+0h] [ebp-18h]
  float v4; // [esp+4h] [ebp-14h]
  float v5; // [esp+8h] [ebp-10h]

  v3 = *a1 * a2[3] + a1[3] * *a2 + a1[2] * a2[1] - a1[1] * a2[2];
  v4 = a1[1] * a2[3] - a1[2] * *a2 + a1[3] * a2[1] + *a1 * a2[2];
  v5 = a1[2] * a2[3] + a1[1] * *a2 - *a1 * a2[1] + a1[3] * a2[2];
  a1[3] = a1[3] * a2[3] - *a1 * *a2 - a1[1] * a2[1] - a1[2] * a2[2];
  *a1 = v3;
  a1[1] = v4;
  result = LODWORD(v5);
  a1[2] = v5;
  return result;
}

//----- (080B9FB2) --------------------------------------------------------
int __cdecl sub_80B9FB2(float *a1, float *a2)
{
  int result; // eax
  float v3; // [esp+0h] [ebp-18h]
  float v4; // [esp+4h] [ebp-14h]
  float v5; // [esp+8h] [ebp-10h]

  v3 = *a1 * a2[3] + a1[3] * *a2 + a1[2] * a2[1] - a1[1] * a2[2];
  v4 = a1[1] * a2[3] - a1[2] * *a2 + a1[3] * a2[1] + *a1 * a2[2];
  v5 = a1[2] * a2[3] + a1[1] * *a2 - *a1 * a2[1] + a1[3] * a2[2];
  a2[3] = a1[3] * a2[3] - *a1 * *a2 - a1[1] * a2[1] - a1[2] * a2[2];
  *a2 = v3;
  a2[1] = v4;
  result = LODWORD(v5);
  a2[2] = v5;
  return result;
}

//----- (080BA0EC) --------------------------------------------------------
bool XAnimInit()
{
  bool result; // al
  int i; // [esp+24h] [ebp-4h]

  for ( i = 0; i <= 4095; ++i )
  {
    word_8527A88[20 * i] = (i + 4095) % 4096;
    word_8527A8A[20 * i] = (i + 1) % 4096;
  }
  dword_8527A8C[0] = 0;
  dword_8527A90 = 0;
  word_8527A94 = 0;
  word_8527A96 = 0;
  g_end = SL_GetString("end", 0);
  result = *(_DWORD *)(com_developer + 8) != 0;
  g_anim_developer = result;
  return result;
}
// 819EEFC: using guessed type int com_developer;
// 8527A88: using guessed type __int16 word_8527A88[];
// 8527A8A: using guessed type __int16 word_8527A8A[];
// 8527A8C: using guessed type int dword_8527A8C[];
// 8527A90: using guessed type int dword_8527A90;
// 8527A94: using guessed type __int16 word_8527A94;
// 8527A96: using guessed type __int16 word_8527A96;
// 85500A4: using guessed type char g_anim_developer;

//----- (080BA21E) --------------------------------------------------------
int XAnimShutdown()
{
  int result; // eax

  if ( g_end )
  {
    result = SL_RemoveRefToString(g_end);
    g_end = 0;
  }
  return result;
}

//----- (080BA246) --------------------------------------------------------
void XAnimAbort()
{
  g_end = 0;
}

//----- (080BA256) --------------------------------------------------------
int __cdecl XAnimFree(int a1)
{
  int result; // eax
  __int16 v2; // [esp+6h] [ebp-12h]
  unsigned __int16 *j; // [esp+8h] [ebp-10h]
  int v4; // [esp+Ch] [ebp-Ch]
  int i; // [esp+10h] [ebp-8h]
  int v6; // [esp+14h] [ebp-4h]

  v6 = *(_DWORD *)(a1 + 16);
  v4 = *(__int16 *)(a1 + 14);
  for ( i = 0; i < v4; ++i )
    SL_RemoveRefToString(*(unsigned __int16 *)(v6 + 2 * i));
  v2 = 0;
  for ( j = *(unsigned __int16 **)(a1 + 28); ; j += 4 )
  {
    result = v2;
    if ( v2 >= (int)*(unsigned __int8 *)(a1 + 12) )
      break;
    SL_RemoveRefToString(*j);
    ++v2;
  }
  return result;
}

//----- (080BA2DE) --------------------------------------------------------
int __cdecl sub_80BA2DE(char *s2)
{
  return Hunk_FindDataForFile(5, s2);
}

//----- (080BA2FA) --------------------------------------------------------
int __cdecl sub_80BA2FA(const void *a1, int (__cdecl *a2)(int))
{
  int v3; // [esp+8h] [ebp-20h]
  __int16 v4; // [esp+Eh] [ebp-1Ah]
  unsigned __int16 *v5; // [esp+10h] [ebp-18h]
  int v6; // [esp+14h] [ebp-14h]
  int i; // [esp+18h] [ebp-10h]
  int v8; // [esp+1Ch] [ebp-Ch]

  v3 = a2(44);
  qmemcpy((void *)v3, a1, 0x2Cu);
  v8 = *(_DWORD *)(v3 + 16);
  v6 = *(__int16 *)(v3 + 14);
  for ( i = 0; i < v6; ++i )
    sub_807951E(*(unsigned __int16 *)(v8 + 2 * i));
  v4 = 0;
  v5 = *(unsigned __int16 **)(v3 + 28);
  while ( v4 < (int)*(unsigned __int8 *)(v3 + 12) )
  {
    sub_807951E(*v5);
    ++v4;
    v5 += 4;
  }
  return v3;
}

//----- (080BA3AE) --------------------------------------------------------
unsigned __int16 *__cdecl sub_80BA3AE(char *src, int (__cdecl *a2)(int))
{
  unsigned __int16 *v4; // [esp+1Ch] [ebp-Ch]
  int v5; // [esp+20h] [ebp-8h]
  unsigned __int16 *v6; // [esp+20h] [ebp-8h]

  v5 = sub_80BA2DE(src);
  if ( v5 )
    return (unsigned __int16 *)v5;
  v6 = sub_80C19AE(src, a2);
  if ( !v6 )
  {
    Com_Printf("^3WARNING: Couldn't find xanim '%s', using default xanim '%s' instead\n", src, "void");
    v4 = (unsigned __int16 *)sub_80BA2DE("void");
    if ( !v4 )
    {
      v4 = sub_80C19AE("void", a2);
      if ( !v4 )
        Com_Error(1, (char *)&byte_8148E87, "void");
      Hunk_SetDataForFile(5, "void", (int)v4, (int (__cdecl *)(size_t))a2);
    }
    v6 = (unsigned __int16 *)sub_80BA2FA(v4, a2);
    *((_BYTE *)v6 + 40) = 1;
  }
  *((_DWORD *)v6 + 9) = Hunk_SetDataForFile(5, src, (int)v6, (int (__cdecl *)(size_t))a2);
  return v6;
}

//----- (080BA4D8) --------------------------------------------------------
char *__cdecl sub_80BA4D8(int a1, int a2, char *s)
{
  char *result; // eax
  size_t v4; // eax
  char *dest; // [esp+Ch] [ebp-Ch]
  int v6; // [esp+14h] [ebp-4h]

  v6 = sub_80BA2DE(s);
  if ( !v6 )
    Com_Error(1, (char *)&byte_8148EA0, s);
  *(_WORD *)(a1 + 8 * a2 + 12) = 0;
  *(_DWORD *)(a1 + 8 * a2 + 16) = v6;
  result = (char *)a1;
  if ( *(_DWORD *)(a1 + 8) )
  {
    v4 = strlen(s);
    dest = (char *)Z_MallocInternal(v4 + 1);
    strcpy(dest, s);
    result = dest;
    *(_DWORD *)(*(_DWORD *)(a1 + 8) + 4 * a2) = dest;
  }
  return result;
}

//----- (080BA57A) --------------------------------------------------------
char *__cdecl sub_80BA57A(int a1, int a2, char *s, __int16 a4, unsigned int a5, __int16 a6)
{
  _WORD *v6; // eax
  char *result; // eax
  size_t v8; // eax
  char *dest; // [esp+Ch] [ebp-Ch]
  unsigned int i; // [esp+14h] [ebp-4h]

  v6 = (_WORD *)(a1 + 8 * a2);
  v6[6] = a5;
  v6[8] = a6;
  v6[9] = a4;
  for ( i = 0; i < a5; ++i )
    *(_WORD *)(a1 + 8 * (i + (unsigned __int16)v6[9]) + 14) = a2;
  result = (char *)a1;
  if ( *(_DWORD *)(a1 + 8) )
  {
    v8 = strlen(s);
    dest = (char *)Z_MallocInternal(v8 + 1);
    strcpy(dest, s);
    result = dest;
    *(_DWORD *)(*(_DWORD *)(a1 + 8) + 4 * a2) = dest;
  }
  return result;
}

//----- (080BA626) --------------------------------------------------------
char **__cdecl sub_80BA626(char *s, int a2, int (__cdecl *a3)(int))
{
  size_t v3; // eax
  char *dest; // [esp+1Ch] [ebp-Ch]
  char **v6; // [esp+20h] [ebp-8h]

  v6 = (char **)a3(8 * a2 + 12);
  v6[1] = (char *)a2;
  if ( g_anim_developer )
  {
    v3 = strlen(s);
    dest = (char *)Z_MallocInternal(v3 + 1);
    strcpy(dest, s);
    *v6 = dest;
    v6[2] = (char *)Z_MallocInternal(4 * a2);
  }
  if ( Hunk_DataOnHunk((size_t)v6) )
    Hunk_AddData(6, (int)v6, a3);
  return v6;
}
// 85500A4: using guessed type char g_anim_developer;

//----- (080BA6D0) --------------------------------------------------------
int __cdecl sub_80BA6D0(int a1, int (__cdecl *a2)(int, int))
{
  int v3; // [esp+14h] [ebp-4h]

  v3 = 8 * *(_DWORD *)(a1 + 4) + 12;
  XAnimFreeList(a1);
  return a2(a1, v3);
}

//----- (080BA704) --------------------------------------------------------
int __cdecl XAnimFreeList(int a1)
{
  int result; // eax
  unsigned int i; // [esp+4h] [ebp-4h]

  if ( *(_DWORD *)a1 )
  {
    Z_FreeInternal(*(void **)a1);
    *(_DWORD *)a1 = 0;
  }
  result = a1;
  if ( *(_DWORD *)(a1 + 8) )
  {
    for ( i = 0; i < *(_DWORD *)(a1 + 4); ++i )
    {
      if ( *(_DWORD *)(*(_DWORD *)(a1 + 8) + 4 * i) )
      {
        Z_FreeInternal(*(void **)(*(_DWORD *)(a1 + 8) + 4 * i));
        *(_DWORD *)(*(_DWORD *)(a1 + 8) + 4 * i) = 0;
      }
    }
    Z_FreeInternal(*(void **)(a1 + 8));
    result = a1;
    *(_DWORD *)(a1 + 8) = 0;
  }
  return result;
}

//----- (080BA7BC) --------------------------------------------------------
int __cdecl sub_80BA7BC(int a1)
{
  return 5 * a1 + 9;
}

//----- (080BA7E4) --------------------------------------------------------
_DWORD *__cdecl sub_80BA7E4(int a1, int (__cdecl *a2)(int))
{
  int n; // [esp+10h] [ebp-8h]
  _DWORD *s; // [esp+14h] [ebp-4h]

  n = sub_80BA7BC(*(_DWORD *)(a1 + 4));
  s = (_DWORD *)a2(n);
  memset(s, 0, n);
  *s = a1;
  return s;
}

//----- (080BA836) --------------------------------------------------------
int __cdecl sub_80BA836(_DWORD *a1, int (__cdecl *a2)(_DWORD *, int))
{
  int result; // eax
  int v3; // [esp+10h] [ebp-8h]
  int v4; // [esp+14h] [ebp-4h]

  v3 = *(_DWORD *)(*a1 + 4);
  result = sub_80BFA1E(a1);
  if ( a2 )
  {
    v4 = sub_80BA7BC(v3);
    return a2(a1, v4);
  }
  return result;
}

//----- (080BA87C) --------------------------------------------------------
int __cdecl sub_80BA87C(int a1)
{
  return *(_DWORD *)a1;
}

//----- (080BA886) --------------------------------------------------------
int __cdecl sub_80BA886(int a1, int a2, int a3)
{
  __int16 *v4; // [esp+18h] [ebp-D0h]
  int i; // [esp+24h] [ebp-C4h]
  int k; // [esp+24h] [ebp-C4h]
  int v7; // [esp+30h] [ebp-B8h]
  int v8; // [esp+34h] [ebp-B4h]
  int v9; // [esp+38h] [ebp-B0h]
  int v10; // [esp+3Ch] [ebp-ACh]
  int v11; // [esp+40h] [ebp-A8h]
  int m; // [esp+44h] [ebp-A4h]
  int v13; // [esp+48h] [ebp-A0h]
  int j; // [esp+4Ch] [ebp-9Ch]
  int n; // [esp+4Ch] [ebp-9Ch]
  int s2[38]; // [esp+50h] [ebp-98h] BYREF

  v11 = *(_DWORD *)(a1 + 4);
  v8 = *(_DWORD *)(v11 + 16);
  v10 = *(__int16 *)(v11 + 14);
  for ( i = 0; i <= 3; ++i )
    s2[i] = 0;
  for ( j = v10 - 1; j >= 0; --j )
    *((_BYTE *)&s2[4] + j) = 127;
  v13 = 0;
  for ( k = 0; k < a3; ++k )
  {
    v4 = **(__int16 ***)(a2 + 4 * k);
    v7 = **((_DWORD **)v4 + 1);
    v9 = *v4;
    for ( m = 0; m < v9; ++m )
    {
      for ( n = v10 - 1; n >= 0; --n )
      {
        if ( *(unsigned __int16 *)(v7 + 2 * m) == *(unsigned __int16 *)(v8 + 2 * n) )
        {
          if ( *((_BYTE *)&s2[4] + n) == 127 )
          {
            *((_BYTE *)&s2[4] + n) = v13;
            s2[v13 >> 5] |= 1 << (v13 & 0x1F);
          }
          break;
        }
      }
      ++v13;
    }
  }
  return SL_GetStringOfLen((char *)s2, 0, v10 + 16);
}

//----- (080BAACE) --------------------------------------------------------
__int16 __cdecl sub_80BAACE(float a1, int a2, int a3)
{
  __int16 result; // ax
  __int16 v4; // [esp+2h] [ebp-2h]

  *(float *)a3 = a1;
  *(_DWORD *)(a3 + 4) = a2;
  *(float *)(a3 + 8) = (long double)a2 * a1;
  result = v4 | 0xC00;
  *(_DWORD *)(a3 + 12) = (int)*(float *)(a3 + 8);
  return result;
}
// 80BAB03: variable 'v4' is possibly undefined

//----- (080BAB16) --------------------------------------------------------
__int16 *__cdecl sub_80BAB16(unsigned __int16 *a1, float a2, float *a3)
{
  __int16 *v4; // [esp+10h] [ebp-8h]

  if ( *a1 )
    v4 = (__int16 *)(4 * *a1 + *((_DWORD *)a1 + 1));
  else
    v4 = (__int16 *)(a1 + 2);
  return sub_80C150E(a3, a2, v4, a3);
}

//----- (080BAB6C) --------------------------------------------------------
__int16 *__cdecl sub_80BAB6C(unsigned __int16 *a1, float a2, float *a3)
{
  if ( *a1 )
    return sub_80C1544(a3, a2, (__int16 *)(*((_DWORD *)a1 + 1) + 8 * *a1), a3);
  else
    return sub_80C1544(a3, a2, (__int16 *)a1 + 2, a3);
}

//----- (080BABCE) --------------------------------------------------------
float *__cdecl sub_80BABCE(unsigned __int16 *a1, float a2, float *a3)
{
  if ( *a1 )
    return sub_80C11C4(a3, a2, (float *)(*((_DWORD *)a1 + 1) + 12 * *a1), a3);
  else
    return sub_80C11C4(a3, a2, (float *)a1 + 1, a3);
}

//----- (080BAC36) --------------------------------------------------------
int __cdecl sub_80BAC36(int a1, int a2, float a3, int a4, int a5)
{
  int result; // eax
  int v6; // [esp+Ch] [ebp-1Ch]
  int v7; // [esp+10h] [ebp-18h]
  int v8; // [esp+14h] [ebp-14h]
  float v9; // [esp+18h] [ebp-10h]
  unsigned __int16 **v10; // [esp+1Ch] [ebp-Ch]
  int i; // [esp+20h] [ebp-8h]
  float *v12; // [esp+24h] [ebp-4h]

  v9 = a3 * 0.000030518509;
  v6 = *(_DWORD *)(a1 + 20);
  v7 = *(__int16 *)(a1 + 14);
  for ( i = 0; ; ++i )
  {
    result = i;
    if ( i >= v7 )
      break;
    v8 = *(unsigned __int8 *)(a2 + i);
    if ( ((*(int *)(a5 + 4 * (v8 >> 5)) >> (v8 & 0x1F)) & 1) == 0 )
    {
      v12 = (float *)(a4 + 32 * v8);
      v10 = (unsigned __int16 **)(*(_DWORD *)(a1 + 24) + 8 * i);
      if ( ((*(char *)((i >> 3) + v6) >> (i & 7)) & 1) != 0 )
      {
        if ( v10[1] )
          sub_80BAB16(v10[1], v9, v12 + 2);
        else
          v12[3] = v12[3] + a3;
      }
      else
      {
        sub_80BAB6C(v10[1], v9, v12);
      }
      if ( *v10 )
        sub_80BABCE(*v10, a3, v12 + 4);
      v12[7] = v12[7] + a3;
    }
  }
  return result;
}

//----- (080BAD76) --------------------------------------------------------
int __cdecl sub_80BAD76(int a1, _DWORD *a2, int a3)
{
  int result; // eax
  int i; // [esp+4h] [ebp-4h]

  for ( i = 0; ; ++i )
  {
    result = *(unsigned __int8 *)(a1 + 25);
    if ( i >= result )
      break;
    if ( ((*(int *)(a3 + 4 * (i >> 5) + 16400) >> (i & 0x1F)) & 1) == 0 )
    {
      sub_80C1218(a2);
      a2[7] = 0;
      sub_80C1040(a2 + 4);
    }
    a2 += 8;
  }
  return result;
}

//----- (080BADE6) --------------------------------------------------------
__int16 *__cdecl sub_80BADE6(unsigned __int16 *a1, float *a2)
{
  __int16 *v3; // [esp+10h] [ebp-8h]

  if ( *a1 )
    v3 = (__int16 *)(4 * *a1 + *((_DWORD *)a1 + 1));
  else
    v3 = (__int16 *)(a1 + 2);
  return sub_80C16B4(v3, a2);
}

//----- (080BAE2E) --------------------------------------------------------
int __cdecl sub_80BAE2E(int a1, int a2)
{
  int result; // eax

  if ( *(_DWORD *)(a1 + 4) )
    return (int)sub_80BADE6(*(unsigned __int16 **)(a1 + 4), (float *)a2);
  *(_DWORD *)a2 = 0;
  result = 1191181824;
  *(_DWORD *)(a2 + 4) = 1191181824;
  return result;
}

//----- (080BAE6E) --------------------------------------------------------
int __cdecl sub_80BAE6E(unsigned __int16 *a1, _DWORD *a2)
{
  if ( *a1 )
    return sub_80C106A((_DWORD *)(*((_DWORD *)a1 + 1) + 12 * *a1), a2);
  else
    return sub_80C106A((_DWORD *)a1 + 1, a2);
}

//----- (080BAEBA) --------------------------------------------------------
int __cdecl sub_80BAEBA(unsigned __int16 **a1, _DWORD *a2)
{
  if ( *a1 )
    return sub_80BAE6E(*a1, a2);
  else
    return sub_80C1040(a2);
}

//----- (080BAEEC) --------------------------------------------------------
int __cdecl sub_80BAEEC(int a1, int a2, int a3, int *a4, float *a5)
{
  int result; // eax
  int v6; // [esp+4h] [ebp-10h]
  int v7; // [esp+4h] [ebp-10h]
  int v8; // [esp+8h] [ebp-Ch]
  int v9; // [esp+Ch] [ebp-8h]
  int v10; // [esp+10h] [ebp-4h]
  int v11; // [esp+10h] [ebp-4h]

  v9 = (int)((long double)a3 * *(float *)a1);
  v8 = *(_DWORD *)(a1 + 12);
  if ( v8 >= *(unsigned __int8 *)(a2 + v9) )
  {
    if ( v8 >= *(unsigned __int8 *)(a2 + v9 + 1) )
    {
      v11 = v9 + 1;
      v7 = a3;
      do
      {
        while ( 1 )
        {
          v9 = (v7 + v11) / 2;
          if ( v8 < *(unsigned __int8 *)(a2 + v9) )
            break;
          if ( v8 < *(unsigned __int8 *)(a2 + v9 + 1) )
            goto LABEL_15;
          v11 = v9 + 1;
        }
        v7 = (v7 + v11++) / 2;
      }
      while ( v8 >= *(unsigned __int8 *)(a2 + v11) );
      v9 = v11 - 1;
    }
  }
  else
  {
    v10 = 0;
    v6 = (int)((long double)a3 * *(float *)a1);
    while ( 1 )
    {
      while ( 1 )
      {
        v9 = (v6 + v10) / 2;
        if ( v8 >= *(unsigned __int8 *)(a2 + v9) )
          break;
        v6 = (v6 + v10) / 2;
      }
      if ( v8 < *(unsigned __int8 *)(a2 + v9 + 1) )
        break;
      v10 = v9 + 1;
      --v6;
      if ( v8 >= *(unsigned __int8 *)(a2 + v6) )
      {
        v9 = v6;
        break;
      }
    }
  }
LABEL_15:
  *a5 = (*(float *)(a1 + 8) - (long double)*(unsigned __int8 *)(a2 + v9))
      / (long double)(*(unsigned __int8 *)(a2 + v9 + 1) - *(unsigned __int8 *)(a2 + v9));
  result = v9;
  *a4 = v9;
  return result;
}

//----- (080BB060) --------------------------------------------------------
int __cdecl sub_80BB060(int a1, int a2, int a3, int *a4, float *a5)
{
  int result; // eax

  if ( a3 < *(_DWORD *)(a1 + 4) )
    return sub_80BAEEC(a1, a2, a3, a4, a5);
  *a5 = *(float *)(a1 + 8) - (long double)*(int *)(a1 + 12);
  result = *(_DWORD *)(a1 + 12);
  *a4 = result;
  return result;
}

//----- (080BB0BA) --------------------------------------------------------
__int16 *__cdecl sub_80BB0BA(__int16 *a1, float a2, int a3, float *a4)
{
  float v5; // [esp+28h] [ebp-20h] BYREF
  int v6; // [esp+2Ch] [ebp-1Ch] BYREF
  char v7[24]; // [esp+30h] [ebp-18h] BYREF

  if ( !*a1 )
    return sub_80C16B4(a1 + 2, a4);
  sub_80BAACE(a2, a3, (int)v7);
  sub_80BB060((int)v7, (int)(a1 + 4), (unsigned __int16)*a1, &v6, &v5);
  return (__int16 *)sub_80C1350(
                      (__int16 *)(*((_DWORD *)a1 + 1) + 4 * v6),
                      (__int16 *)(*((_DWORD *)a1 + 1) + 4 * v6 + 4),
                      v5,
                      a4);
}

//----- (080BB15E) --------------------------------------------------------
int __cdecl sub_80BB15E(int a1, float a2, int a3, int a4)
{
  int result; // eax

  if ( *(_DWORD *)(a1 + 4) )
    return (int)sub_80BB0BA(*(__int16 **)(a1 + 4), a2, a3, (float *)a4);
  *(_DWORD *)a4 = 0;
  result = 1191181824;
  *(_DWORD *)(a4 + 4) = 1191181824;
  return result;
}

//----- (080BB1AC) --------------------------------------------------------
float *__cdecl sub_80BB1AC(unsigned __int16 *a1, float a2, int a3, float *a4)
{
  float v5; // [esp+28h] [ebp-20h] BYREF
  int v6; // [esp+2Ch] [ebp-1Ch] BYREF
  char v7[24]; // [esp+30h] [ebp-18h] BYREF

  if ( !*a1 )
    return (float *)sub_80C106A((_DWORD *)a1 + 1, a4);
  sub_80BAACE(a2, a3, (int)v7);
  sub_80BB060((int)v7, (int)(a1 + 4), *a1, &v6, &v5);
  return sub_80C1122((float *)(*((_DWORD *)a1 + 1) + 12 * v6), (float *)(*((_DWORD *)a1 + 1) + 12 * v6 + 12), v5, a4);
}

//----- (080BB25E) --------------------------------------------------------
float *__cdecl sub_80BB25E(unsigned __int16 **a1, float a2, int a3, float *a4)
{
  if ( *a1 )
    return sub_80BB1AC(*a1, a2, a3, a4);
  else
    return (float *)sub_80C1040(a4);
}

//----- (080BB29E) --------------------------------------------------------
int __cdecl sub_80BB29E(int a1, int a2, int a3, int *a4, float *a5)
{
  int result; // eax
  int v6; // [esp+4h] [ebp-14h]
  int v7; // [esp+4h] [ebp-14h]
  int v8; // [esp+8h] [ebp-10h]
  int v9; // [esp+Ch] [ebp-Ch]
  int v10; // [esp+10h] [ebp-8h]
  int v11; // [esp+10h] [ebp-8h]

  v9 = (int)((long double)a3 * *(float *)a1);
  v8 = *(_DWORD *)(a1 + 12);
  if ( v8 >= *(unsigned __int16 *)(a2 + 2 * v9) )
  {
    if ( v8 >= *(unsigned __int16 *)(a2 + 2 * v9 + 2) )
    {
      v11 = v9 + 1;
      v7 = a3;
      do
      {
        while ( 1 )
        {
          v9 = (v7 + v11) / 2;
          if ( v8 < *(unsigned __int16 *)(a2 + 2 * v9) )
            break;
          if ( v8 < *(unsigned __int16 *)(a2 + 2 * v9 + 2) )
            goto LABEL_15;
          v11 = v9 + 1;
        }
        v7 = (v7 + v11++) / 2;
      }
      while ( v8 >= *(unsigned __int16 *)(a2 + 2 * v11) );
      v9 = v11 - 1;
    }
  }
  else
  {
    v10 = 0;
    v6 = (int)((long double)a3 * *(float *)a1);
    while ( 1 )
    {
      while ( 1 )
      {
        v9 = (v6 + v10) / 2;
        if ( v8 >= *(unsigned __int16 *)(a2 + 2 * v9) )
          break;
        v6 = (v6 + v10) / 2;
      }
      if ( v8 < *(unsigned __int16 *)(a2 + 2 * v9 + 2) )
        break;
      v10 = v9 + 1;
      --v6;
      if ( v8 >= *(unsigned __int16 *)(a2 + 2 * v6) )
      {
        v9 = v6;
        break;
      }
    }
  }
LABEL_15:
  *a5 = (*(float *)(a1 + 8) - (long double)*(unsigned __int16 *)(a2 + 2 * v9))
      / (long double)(*(unsigned __int16 *)(a2 + 2 * v9 + 2) - *(unsigned __int16 *)(a2 + 2 * v9));
  result = v9;
  *a4 = v9;
  return result;
}

//----- (080BB444) --------------------------------------------------------
int __cdecl sub_80BB444(int a1, int a2, int a3, int *a4, float *a5)
{
  int result; // eax

  if ( a3 < *(_DWORD *)(a1 + 4) )
    return sub_80BB29E(a1, a2, a3, a4, a5);
  *a5 = *(float *)(a1 + 8) - (long double)*(int *)(a1 + 12);
  result = *(_DWORD *)(a1 + 12);
  *a4 = result;
  return result;
}

//----- (080BB49E) --------------------------------------------------------
__int16 *__cdecl sub_80BB49E(__int16 *a1, float a2, int a3, float *a4)
{
  float v5; // [esp+28h] [ebp-20h] BYREF
  int v6; // [esp+2Ch] [ebp-1Ch] BYREF
  char v7[24]; // [esp+30h] [ebp-18h] BYREF

  if ( !*a1 )
    return sub_80C16B4(a1 + 2, a4);
  sub_80BAACE(a2, a3, (int)v7);
  sub_80BB444((int)v7, (int)(a1 + 4), (unsigned __int16)*a1, &v6, &v5);
  return (__int16 *)sub_80C1350(
                      (__int16 *)(*((_DWORD *)a1 + 1) + 4 * v6),
                      (__int16 *)(*((_DWORD *)a1 + 1) + 4 * v6 + 4),
                      v5,
                      a4);
}

//----- (080BB542) --------------------------------------------------------
int __cdecl sub_80BB542(int a1, float a2, int a3, int a4)
{
  int result; // eax

  if ( *(_DWORD *)(a1 + 4) )
    return (int)sub_80BB49E(*(__int16 **)(a1 + 4), a2, a3, (float *)a4);
  *(_DWORD *)a4 = 0;
  result = 1191181824;
  *(_DWORD *)(a4 + 4) = 1191181824;
  return result;
}

//----- (080BB590) --------------------------------------------------------
float *__cdecl sub_80BB590(unsigned __int16 *a1, float a2, int a3, float *a4)
{
  float v5; // [esp+28h] [ebp-20h] BYREF
  int v6; // [esp+2Ch] [ebp-1Ch] BYREF
  char v7[24]; // [esp+30h] [ebp-18h] BYREF

  if ( !*a1 )
    return (float *)sub_80C106A((_DWORD *)a1 + 1, a4);
  sub_80BAACE(a2, a3, (int)v7);
  sub_80BB444((int)v7, (int)(a1 + 4), *a1, &v6, &v5);
  return sub_80C1122((float *)(*((_DWORD *)a1 + 1) + 12 * v6), (float *)(*((_DWORD *)a1 + 1) + 12 * v6 + 12), v5, a4);
}

//----- (080BB642) --------------------------------------------------------
float *__cdecl sub_80BB642(unsigned __int16 **a1, float a2, int a3, float *a4)
{
  if ( *a1 )
    return sub_80BB590(*a1, a2, a3, a4);
  else
    return (float *)sub_80C1040(a4);
}

//----- (080BB682) --------------------------------------------------------
float *__cdecl sub_80BB682(unsigned __int16 *a1, float a2, int a3, float *a4)
{
  char v5; // [esp+1Bh] [ebp-Dh]
  unsigned __int16 **v6; // [esp+1Ch] [ebp-Ch]
  int v7; // [esp+24h] [ebp-4h]

  v6 = (unsigned __int16 **)*((_DWORD *)a1 + 8);
  v7 = *a1;
  v5 = 0;
  if ( a2 == 1.0 || !*a1 )
    v5 = 1;
  if ( v5 )
  {
    sub_80BAE2E((int)v6, a3);
    return (float *)sub_80BAEBA(v6, a4);
  }
  else if ( *a1 > 0xFFu )
  {
    sub_80BB542((int)v6, a2, v7, a3);
    return sub_80BB642(v6, a2, v7, a4);
  }
  else
  {
    sub_80BB15E((int)v6, a2, v7, a3);
    return sub_80BB25E(v6, a2, v7, a4);
  }
}

//----- (080BB77C) --------------------------------------------------------
void __cdecl sub_80BB77C(float *a1, float *a2)
{
  float v2; // [esp+0h] [ebp-10h]
  float v3; // [esp+4h] [ebp-Ch]
  float v4; // [esp+4h] [ebp-Ch]
  float v5; // [esp+8h] [ebp-8h]
  float v6; // [esp+Ch] [ebp-4h]
  float v7; // [esp+Ch] [ebp-4h]

  v6 = *a1 * *a1;
  v3 = a1[1] * a1[1] + v6;
  if ( v3 != 0.0 )
  {
    v4 = 2.0 / v3;
    v7 = v6 * v4;
    v5 = *a1 * a1[1] * v4;
    v2 = (1.0 - v7) * *a2 + v5 * a2[1];
    a2[1] = a2[1] - (v5 * *a2 + v7 * a2[1]);
    *a2 = v2;
  }
}

//----- (080BB82A) --------------------------------------------------------
float *__cdecl sub_80BB82A(int a1, float a2, float a3, float a4, float *a5, int a6)
{
  unsigned __int16 *v7; // [esp+14h] [ebp-54h]
  float v8; // [esp+1Ch] [ebp-4Ch]
  int v9[4]; // [esp+20h] [ebp-48h] BYREF
  int v10[4]; // [esp+30h] [ebp-38h] BYREF
  int v11[4]; // [esp+40h] [ebp-28h] BYREF
  int v12; // [esp+50h] [ebp-18h] BYREF
  float v13; // [esp+54h] [ebp-14h]
  float v14; // [esp+58h] [ebp-10h] BYREF
  float v15; // [esp+5Ch] [ebp-Ch]

  sub_80BB682((unsigned __int16 *)a1, a3, (int)&v12, (float *)v11);
  sub_80BB682((unsigned __int16 *)a1, a4, (int)&v14, (float *)v10);
  if ( *(_BYTE *)(a1 + 2) )
  {
    if ( a3 > (long double)a4 )
    {
      v7 = **(unsigned __int16 ***)(a1 + 32);
      if ( v7 )
      {
        if ( *v7 )
        {
          sub_80C109A((float *)v10, (float *)(*((_DWORD *)v7 + 1) + 12 * *v7), (float *)v10);
          sub_80C10DE((float *)v10, *((float **)v7 + 1), (float *)v10);
        }
      }
    }
  }
  v8 = a2 * 9.3137942e-10;
  *a5 = (v14 * v13 - v15 * *(float *)&v12) * v8 + *a5;
  a5[1] = (v14 * *(float *)&v12 + v15 * v13) * v8 + a5[1];
  sub_80C10DE((float *)v10, (float *)v11, (float *)v9);
  sub_80BB77C((float *)&v12 + 2 * a6, (float *)v9);
  a5[2] = a5[2] + a2;
  return sub_80C11C4(a5 + 3, a2, (float *)v9, a5 + 3);
}

//----- (080BB9A8) --------------------------------------------------------
float *__cdecl sub_80BB9A8(unsigned __int16 *a1, float a2, float a3, float *a4)
{
  float v5; // [esp+4h] [ebp-34h]
  int v6[6]; // [esp+10h] [ebp-28h] BYREF
  int v7[4]; // [esp+28h] [ebp-10h] BYREF

  sub_80BB682(a1, a3, (int)v7, (float *)v6);
  v5 = a2 * 0.000030518509;
  sub_80C0FE8(a4, v5, (float *)v7, a4);
  a4[2] = a4[2] + a2;
  return sub_80C11C4(a4 + 3, a2, (float *)v6, a4 + 3);
}

//----- (080BBA2E) --------------------------------------------------------
int __cdecl sub_80BBA2E(int a1)
{
  int result; // eax

  if ( *(_WORD *)(a1 + 4) )
  {
    SL_RemoveRefToString(*(unsigned __int16 *)(a1 + 4));
    *(_WORD *)(a1 + 4) = 0;
  }
  result = a1;
  *(_WORD *)(a1 + 2) = -1;
  return result;
}

//----- (080BBA62) --------------------------------------------------------
int __cdecl sub_80BBA62(int a1, int a2)
{
  int result; // eax
  char *v3; // [esp+4h] [ebp-4h]

  v3 = (char *)&unk_8527A80 + 40 * a2;
  sub_80BBA2E((int)v3);
  *((_WORD *)v3 + 4) = 0;
  *((_WORD *)v3 + 5) = word_8527A8A;
  word_8527A88[20 * (unsigned __int16)word_8527A8A] = a2;
  result = a2;
  word_8527A8A = a2;
  return result;
}
// 8527A88: using guessed type __int16 word_8527A88[];
// 8527A8A: using guessed type __int16 word_8527A8A;

//----- (080BBAD0) --------------------------------------------------------
long double __cdecl sub_80BBAD0(_DWORD *a1, int a2)
{
  float v5; // [esp+10h] [ebp-28h]
  unsigned __int16 *v6; // [esp+18h] [ebp-20h]
  float v7; // [esp+1Ch] [ebp-1Ch]
  float v8; // [esp+20h] [ebp-18h]
  float v9; // [esp+24h] [ebp-14h]
  float *v10; // [esp+28h] [ebp-10h]
  unsigned __int16 v11; // [esp+2Eh] [ebp-Ah]
  int i; // [esp+30h] [ebp-8h]
  int v13; // [esp+34h] [ebp-4h]

  v6 = (unsigned __int16 *)(*a1 + 8 * a2 + 12);
  v13 = *v6;
  if ( *v6 )
  {
    v8 = 0.0;
    v7 = 0.0;
    for ( i = 0; i < v13; ++i )
    {
      v11 = *((_WORD *)a1 + i + v6[3] + 4);
      if ( v11 )
      {
        v10 = (float *)((char *)&unk_8527A80 + 40 * v11);
        v9 = v10[8];
        if ( v9 != 0.0 )
        {
          v5 = sub_80BBAD0(a1, i + (unsigned int)v6[3]);
          if ( v5 != 0.0 )
          {
            v8 = v8 + v9;
            v7 = v5 * v9 * v10[9] + v7;
          }
        }
      }
    }
    if ( v8 == 0.0 )
      return (float)0.0;
    else
      return (float)(v7 / v8);
  }
  else
  {
    return *(float *)(*(_DWORD *)(*a1 + 8 * a2 + 16) + 8);
  }
}

//----- (080BBC06) --------------------------------------------------------
int __cdecl sub_80BBC06(int a1, float a2)
{
  int i; // [esp+0h] [ebp-18h]
  int v4; // [esp+4h] [ebp-14h]
  float v5; // [esp+8h] [ebp-10h]
  float v6; // [esp+Ch] [ebp-Ch]
  int v7; // [esp+10h] [ebp-8h]
  int v8; // [esp+14h] [ebp-4h]

  v8 = *(_DWORD *)(a1 + 4);
  v4 = 0;
  v5 = 2.0;
  v7 = *(_DWORD *)(v8 + 28);
  for ( i = 0; i < *(unsigned __int8 *)(v8 + 12); ++i )
  {
    v6 = *(float *)(v7 + 4);
    if ( a2 <= (long double)v6 && v5 > (long double)v6 )
    {
      v5 = *(float *)(v7 + 4);
      v4 = v7;
    }
    v7 += 8;
  }
  return (unsigned __int16)((v4 - *(_DWORD *)(v8 + 28)) >> 3);
}

//----- (080BBC94) --------------------------------------------------------
long double __cdecl sub_80BBC94(int a1, int a2, float a3, float a4)
{
  if ( *(float *)(a2 + 4) == 1.0 )
  {
    return (float)1.0;
  }
  else if ( *(float *)(a2 + 4) <= (long double)*(float *)a2 )
  {
    if ( (*(float *)a2 > (long double)a3 || *(float *)a2 == 1.0) && a3 >= (long double)*(float *)(a2 + 4) )
      return (float)(((long double)(*(__int16 *)(a2 + 10) - *(__int16 *)(a1 + 10)) + a3 - *(float *)(a1 + 4)) / a4);
    else
      return (float)1.0;
  }
  else if ( *(float *)a2 <= (long double)a3 )
  {
    if ( a3 < (long double)*(float *)(a2 + 4) )
      return (float)1.0;
    else
      return (float)(((long double)(*(__int16 *)(a2 + 10) - *(__int16 *)(a1 + 10)) + a3 - *(float *)(a1 + 4)) / a4);
  }
  else
  {
    return (float)(((long double)(*(__int16 *)(a2 + 10) - *(__int16 *)(a1 + 10) + 1) + a3 - *(float *)(a1 + 4)) / a4);
  }
}

//----- (080BBDC8) --------------------------------------------------------
long double __cdecl sub_80BBDC8(int a1, float *a2, int a3, int a4, int a5, float a6)
{
  int v8; // [esp+14h] [ebp-4h]

  if ( *(_WORD *)(a1 + 4) && *((_WORD *)a2 + 2) )
  {
    if ( *(_WORD *)a3 )
    {
      if ( !*(_WORD *)a2 )
        return (float)sub_80BBC94(a4, a5, 1.0, a6);
      a3 = *(_DWORD *)a1 + 8 * *(unsigned __int16 *)a2 + 12;
    }
    v8 = *(_DWORD *)(a3 + 4);
    if ( *((__int16 *)a2 + 1) >= 0 )
      return (float)sub_80BBC94(a4, a5, *(float *)(*(_DWORD *)(v8 + 28) + 8 * *((__int16 *)a2 + 1) + 4), a6);
    sub_80C0164((_DWORD *)a1, a2, (_WORD *)a3);
    if ( *((__int16 *)a2 + 1) >= 0 )
      return (float)sub_80BBC94(a4, a5, *(float *)(*(_DWORD *)(v8 + 28) + 8 * *((__int16 *)a2 + 1) + 4), a6);
    return (float)sub_80BBC94(a4, a5, 1.0, a6);
  }
  return (float)1.0;
}

//----- (080BBED6) --------------------------------------------------------
int __cdecl sub_80BBED6(int a1, int a2, float a3, int a4)
{
  int result; // eax
  int i; // [esp+Ch] [ebp-Ch]
  float *v6; // [esp+10h] [ebp-8h]
  int v7; // [esp+10h] [ebp-8h]

  for ( i = dword_85500A0 - 1; i >= 0; --i )
  {
    v6 = (float *)((char *)&unk_854FAA0 + 12 * i);
    if ( a3 >= (long double)v6[2] )
      break;
    v6[3] = *v6;
    v6[4] = v6[1];
    v6[5] = v6[2];
  }
  v7 = 12 * i + 139786924;
  dword_854FAAC[3 * i] = SL_ConvertToString(a2);
  *(float *)(v7 + 8) = a3;
  result = a4;
  *(_DWORD *)(v7 + 4) = a4;
  ++dword_85500A0;
  return result;
}
// 854FAAC: using guessed type _DWORD[381];
// 85500A0: using guessed type int dword_85500A0;

//----- (080BBF7C) --------------------------------------------------------
void __cdecl sub_80BBF7C(int a1, int a2, float a3)
{
  float v3; // [esp+8h] [ebp-20h]
  float v4; // [esp+8h] [ebp-20h]
  float v5; // [esp+8h] [ebp-20h]
  float v6; // [esp+8h] [ebp-20h]
  float v7; // [esp+8h] [ebp-20h]
  float v8; // [esp+8h] [ebp-20h]
  unsigned __int16 v9; // [esp+16h] [ebp-12h]
  float *v10; // [esp+18h] [ebp-10h]
  unsigned __int16 v11; // [esp+1Eh] [ebp-Ah]
  float *v12; // [esp+20h] [ebp-8h]
  float *i; // [esp+20h] [ebp-8h]
  int v14; // [esp+24h] [ebp-4h]

  v10 = (float *)(a1 + 12);
  v9 = *(_WORD *)(a1 + 6);
  if ( v9 )
  {
    if ( *(float *)(a1 + 16) == 1.0 )
    {
LABEL_3:
      v3 = sub_80BBC94((int)v10, (int)v10, 1.0, a3);
      sub_80BBED6(a2, g_end, v3, v9);
      return;
    }
    if ( *(_WORD *)a2 )
    {
      if ( *(float *)(a1 + 16) > (long double)*(float *)(a1 + 12) || *v10 == 1.0 )
        goto LABEL_3;
    }
    else
    {
      v14 = *(_DWORD *)(a2 + 4);
      v11 = sub_80BBC06(a2, *(float *)(a1 + 16));
      v12 = (float *)(*(_DWORD *)(v14 + 28) + 8 * v11);
      if ( *(float *)(a1 + 16) <= (long double)*(float *)(a1 + 12) )
      {
        if ( *v10 == 1.0 )
        {
          if ( *(float *)(a1 + 16) <= (long double)v12[1] )
          {
            do
            {
              v7 = sub_80BBC94((int)v10, (int)v10, v12[1], a3);
              sub_80BBED6(a2, *(unsigned __int16 *)v12, v7, v9);
              v12 += 2;
              ++v11;
            }
            while ( v11 < (unsigned int)*(unsigned __int8 *)(v14 + 12) );
          }
        }
        else if ( v12[1] < (long double)*v10 && *(float *)(a1 + 16) <= (long double)v12[1] )
        {
          do
          {
            v8 = sub_80BBC94((int)v10, (int)v10, v12[1], a3);
            sub_80BBED6(a2, *(unsigned __int16 *)v12, v8, v9);
            v12 += 2;
            ++v11;
          }
          while ( v11 < (unsigned int)*(unsigned __int8 *)(v14 + 12) && *v10 > (long double)v12[1] );
        }
      }
      else if ( *v10 <= (long double)v12[1] )
      {
        if ( *(float *)(a1 + 16) <= (long double)v12[1] )
        {
          do
          {
            v5 = sub_80BBC94((int)v10, (int)v10, v12[1], a3);
            sub_80BBED6(a2, *(unsigned __int16 *)v12, v5, v9);
            v12 += 2;
            ++v11;
          }
          while ( v11 < (unsigned int)*(unsigned __int8 *)(v14 + 12) );
          for ( i = *(float **)(v14 + 28); *v10 > (long double)i[1]; i += 4 )
          {
            v6 = sub_80BBC94((int)v10, (int)v10, i[1], a3);
            sub_80BBED6(a2, *(unsigned __int16 *)i, v6, v9);
          }
        }
      }
      else
      {
        do
        {
          v4 = sub_80BBC94((int)v10, (int)v10, v12[1], a3);
          sub_80BBED6(a2, *(unsigned __int16 *)v12, v4, v9);
          v12 += 2;
          ++v11;
        }
        while ( v11 < (unsigned int)*(unsigned __int8 *)(v14 + 12) && *v10 > (long double)v12[1] );
      }
    }
  }
}

//----- (080BC382) --------------------------------------------------------
void __cdecl sub_80BC382(_DWORD *a1, int a2, unsigned __int8 a3, int a4, float a5)
{
  unsigned __int16 *v5; // [esp+1Ch] [ebp-1Ch]
  _DWORD *v6; // [esp+20h] [ebp-18h]
  char *v7; // [esp+24h] [ebp-14h]
  unsigned __int16 v8; // [esp+2Ah] [ebp-Eh]
  int v9; // [esp+2Ch] [ebp-Ch]
  int i; // [esp+30h] [ebp-8h]

  v8 = *((_WORD *)a1 + a2 + 4);
  if ( v8 )
  {
    v7 = (char *)&unk_8527A80 + 40 * v8;
    v6 = v7 + 12;
    if ( *((float *)v7 + 8) != 0.0 )
    {
      if ( *((float *)v7 + 7) == 0.0 )
        a3 = 0;
      v5 = (unsigned __int16 *)(*a1 + 8 * a2 + 12);
      if ( *((float *)v7 + 4) != *(float *)(a4 + 4) || *((_WORD *)v7 + 11) != *(_WORD *)(a4 + 10) )
      {
        *v6 = *(_DWORD *)(a4 + 4);
        *((_WORD *)v7 + 10) = *(_WORD *)(a4 + 10);
        *((_DWORD *)v7 + 4) = *(_DWORD *)(a4 + 4);
        *((_WORD *)v7 + 11) = *(_WORD *)(a4 + 10);
        *((_WORD *)v7 + 1) = -1;
      }
      if ( a3 )
        sub_80BD2FC((int)a1, (float *)v7, (int)v5, *(float *)a4);
      *v6 = *(_DWORD *)a4;
      *((_WORD *)v7 + 10) = *(_WORD *)(a4 + 8);
      *((_WORD *)v7 + 1) = -1;
      if ( a3 )
        sub_80BBF7C((int)v7, (int)v5, a5);
      v9 = *v5;
      for ( i = 0; i < v9; ++i )
        sub_80BC382((int)a1, i + v5[3], a3, a4, a5);
    }
  }
}

//----- (080BC52E) --------------------------------------------------------
void __cdecl sub_80BC52E(_DWORD *a1, int a2, float a3, unsigned __int8 a4)
{
  __int16 v4; // [esp+22h] [ebp-26h]
  __int16 v5; // [esp+22h] [ebp-26h]
  float v6; // [esp+24h] [ebp-24h]
  float v7; // [esp+24h] [ebp-24h]
  int v8; // [esp+28h] [ebp-20h]
  unsigned __int16 *v9; // [esp+2Ch] [ebp-1Ch]
  float *v10; // [esp+30h] [ebp-18h]
  float *v11; // [esp+34h] [ebp-14h]
  unsigned __int16 v12; // [esp+3Ah] [ebp-Eh]
  int v13; // [esp+3Ch] [ebp-Ch]
  int i; // [esp+40h] [ebp-8h]
  int j; // [esp+40h] [ebp-8h]
  float v17; // [esp+58h] [ebp+10h]
  float v18; // [esp+58h] [ebp+10h]
  float v19; // [esp+58h] [ebp+10h]

  v12 = *((_WORD *)a1 + a2 + 4);
  if ( v12 )
  {
    v11 = (float *)((char *)&unk_8527A80 + 40 * v12);
    v10 = v11 + 3;
    if ( v11[8] != 0.0 )
    {
      if ( v11[7] == 0.0 )
        a4 = 0;
      v9 = (unsigned __int16 *)(*a1 + 8 * a2 + 12);
      v13 = *v9;
      if ( *v9 )
      {
        if ( (*(_WORD *)(*a1 + 8 * a2 + 16) & 3) != 0 )
        {
          v18 = sub_80BBAD0(a1, a2) * v11[9] * a3;
          if ( v18 != 0.0 )
          {
            v7 = v11[4] + v18;
            v5 = *((_WORD *)v11 + 11);
            if ( v7 >= 1.0 )
            {
              if ( (v9[2] & 2) != 0 )
              {
                v7 = 1.0;
              }
              else
              {
                do
                {
                  v7 = v7 - 1.0;
                  ++v5;
                }
                while ( v7 >= 1.0 );
              }
            }
            if ( *v10 - v7 <= (long double)(v5 - *((__int16 *)v11 + 10)) )
            {
              if ( a4 )
                sub_80BD2FC((int)a1, v11, (int)v9, v7);
              *v10 = v7;
              *((_WORD *)v11 + 10) = v5;
              *((_WORD *)v11 + 1) = -1;
              if ( a4 )
                sub_80BBF7C((int)v11, (int)v9, v18);
              for ( i = 0; i < v13; ++i )
                sub_80BC382(a1, i + v9[3], a4, (int)v10, v18);
            }
          }
        }
        else
        {
          v19 = a3 * v11[9];
          if ( v19 != 0.0 )
          {
            for ( j = 0; j < v13; ++j )
              sub_80BC52E((int)a1, j + v9[3], v19, a4);
          }
        }
      }
      else
      {
        v8 = *(_DWORD *)(*a1 + 8 * a2 + 16);
        v17 = v11[9] * *(float *)(v8 + 8) * a3;
        if ( v17 != 0.0 )
        {
          v6 = v11[4] + v17;
          v4 = *((_WORD *)v11 + 10);
          if ( v6 >= 1.0 )
          {
            if ( *(_BYTE *)(v8 + 2) )
            {
              do
              {
                v6 = v6 - 1.0;
                ++v4;
              }
              while ( v6 >= 1.0 );
            }
            else
            {
              v6 = 1.0;
            }
          }
          if ( *v10 - v6 <= (long double)(v4 - *((__int16 *)v11 + 10)) )
          {
            if ( a4 )
              sub_80BD2FC((int)a1, v11, (int)v9, v6);
            *v10 = v6;
            *((_WORD *)v11 + 10) = v4;
            *((_WORD *)v11 + 1) = -1;
            if ( a4 )
              sub_80BBF7C((int)v11, (int)v9, v17);
          }
        }
      }
    }
  }
}

//----- (080BC8C8) --------------------------------------------------------
_WORD *__cdecl sub_80BC8C8(_WORD *a1)
{
  _WORD *result; // eax

  memset(a1 + 6, 0, 0x1Cu);
  a1[2] = 0;
  a1[1] = -1;
  *a1 = 0;
  result = a1;
  a1[3] = 0;
  return result;
}

//----- (080BC912) --------------------------------------------------------
int __cdecl sub_80BC912(int a1, int a2)
{
  int result; // eax
  int v3; // [esp+18h] [ebp-10h]
  char *v4; // [esp+1Ch] [ebp-Ch]
  int v5; // [esp+20h] [ebp-8h]
  int i; // [esp+24h] [ebp-4h]

  v3 = *(_DWORD *)(*(_DWORD *)a1 + 4);
  for ( i = 0; ; ++i )
  {
    result = i;
    if ( i >= v3 )
      break;
    v5 = *(unsigned __int16 *)(a1 + 2 * i + 8);
    if ( *(_WORD *)(a1 + 2 * i + 8) )
    {
      if ( *(_WORD *)(a2 + 2 * i + 8) )
      {
        v4 = (char *)&unk_8527A80 + 40 * *(unsigned __int16 *)(a2 + 2 * i + 8);
      }
      else
      {
        v4 = (char *)sub_80BF2AE(a2, i);
        sub_80BC8C8(v4);
      }
      *((_DWORD *)v4 + 3) = dword_8527A90[10 * v5];
      *((_WORD *)v4 + 10) = word_8527A96[20 * v5];
      *((_DWORD *)v4 + 7) = dword_8527A9C[10 * v5];
      *((_DWORD *)v4 + 9) = dword_8527AA4[10 * v5];
      *((_DWORD *)v4 + 6) = *((_DWORD *)&unk_8527A98 + 10 * v5);
    }
    else if ( *(_WORD *)(a2 + 2 * i + 8) )
    {
      sub_80BBA62(a2, *(unsigned __int16 *)(a2 + 2 * i + 8));
      *(_WORD *)(a2 + 2 * i + 8) = 0;
    }
  }
  return result;
}
// 8527A90: using guessed type int dword_8527A90[];
// 8527A96: using guessed type __int16 word_8527A96[];
// 8527A9C: using guessed type int dword_8527A9C[];
// 8527AA4: using guessed type int dword_8527AA4[40951];

//----- (080BCA42) --------------------------------------------------------
int __cdecl sub_80BCA42(int a1)
{
  if ( *(float *)(a1 + 12) == 0.0 && !*(_WORD *)(a1 + 20) )
    return 0;
  *(_DWORD *)(a1 + 12) = 0;
  *(_WORD *)(a1 + 20) = 0;
  *(_DWORD *)(a1 + 16) = 0;
  *(_WORD *)(a1 + 22) = 0;
  *(_WORD *)(a1 + 2) = -1;
  return 1;
}

//----- (080BCAB4) --------------------------------------------------------
int __cdecl sub_80BCAB4(_DWORD *a1, int a2)
{
  int result; // eax
  unsigned __int16 *v3; // [esp+8h] [ebp-10h]
  unsigned __int16 v4; // [esp+Eh] [ebp-Ah]
  int v5; // [esp+10h] [ebp-8h]
  int i; // [esp+14h] [ebp-4h]

  result = *((unsigned __int16 *)a1 + a2 + 4);
  v4 = *((_WORD *)a1 + a2 + 4);
  if ( v4 )
  {
    sub_80BCA42(40 * v4 + 139623040);
    v3 = (unsigned __int16 *)(*a1 + 8 * a2 + 12);
    v5 = *v3;
    for ( i = 0; ; ++i )
    {
      result = i;
      if ( i >= v5 )
        break;
      sub_80BCAB4(a1, i + v3[3]);
    }
  }
  return result;
}

//----- (080BCB3A) --------------------------------------------------------
int __cdecl sub_80BCB3A(_DWORD *a1, int a2, int a3, float a4, char a5, _BYTE *a6, _BYTE *a7)
{
  int result; // eax
  char v8; // [esp+1Eh] [ebp-2Ah]
  char v9; // [esp+1Fh] [ebp-29h]
  _WORD v10[3]; // [esp+26h] [ebp-22h] BYREF
  int v11; // [esp+2Ch] [ebp-1Ch]
  int v12; // [esp+30h] [ebp-18h]
  int v13; // [esp+34h] [ebp-14h]
  int v14; // [esp+38h] [ebp-10h]
  int i; // [esp+3Ch] [ebp-Ch]
  char v16; // [esp+42h] [ebp-6h] BYREF
  char v17; // [esp+43h] [ebp-5h]

  v17 = a5;
  result = *((unsigned __int16 *)a1 + a2 + 4);
  v13 = result;
  if ( result )
  {
    v12 = (int)&unk_8527A80 + 40 * v13;
    v11 = v12 + 12;
    v9 = 0;
    if ( v17 && *(float *)(v11 + 20) != 0.0 )
      v9 = 1;
    HIBYTE(v10[0]) = v9;
    if ( v17 && a4 < (long double)*(float *)(v11 + 12) )
    {
      *(float *)(v11 + 20) = (*(float *)(v11 + 16) - *(float *)(v11 + 20)) * a4 / *(float *)(v11 + 12)
                           + *(float *)(v11 + 20);
      if ( *(float *)(v11 + 20) < 0.0000010000001 )
        *(float *)(v11 + 20) = *(float *)(v11 + 16) * 0.001;
      *(float *)(v11 + 12) = *(float *)(v11 + 12) - a4;
    }
    else
    {
      *(_DWORD *)(v11 + 20) = *(_DWORD *)(v11 + 16);
      *(_DWORD *)(v11 + 12) = 0;
    }
    v8 = 0;
    if ( HIBYTE(v10[0]) || *(float *)(v11 + 16) != 0.0 )
      v8 = 1;
    v16 = v8;
    *(_DWORD *)&v10[1] = *a1 + 8 * a2 + 12;
    v14 = (unsigned __int16)**(_WORD **)&v10[1];
    if ( v14 )
    {
      LOBYTE(v10[0]) = 0;
      if ( (*(_WORD *)(*(_DWORD *)&v10[1] + 4) & 4) != 0 )
        a3 = v11;
      for ( i = 0; i < v14; ++i )
        sub_80BCB3A(
          (int)a1,
          i + *(unsigned __int16 *)(*(_DWORD *)&v10[1] + 6),
          a3,
          a4,
          HIBYTE(v10[0]),
          (int)&v16,
          (int)v10);
    }
    else
    {
      LOBYTE(v10[0]) = 0.0 != *(float *)(*(_DWORD *)(*(_DWORD *)&v10[1] + 4) + 8);
    }
    if ( v16 )
    {
      if ( HIBYTE(v10[0]) && LOBYTE(v10[0]) )
      {
        *a7 = 1;
      }
      else if ( v14 && (*(_WORD *)(*(_DWORD *)&v10[1] + 4) & 4) != 0 )
      {
        if ( (unsigned __int8)sub_80BCA42(v12) )
        {
          for ( i = 0; i < v14; ++i )
            sub_80BCAB4(a1, i + *(unsigned __int16 *)(*(_DWORD *)&v10[1] + 6));
        }
      }
      else if ( *(float *)v11 != *(float *)a3 || *(_WORD *)(v11 + 8) != *(_WORD *)(a3 + 8) )
      {
        *(_DWORD *)v11 = *(_DWORD *)a3;
        *(_WORD *)(v11 + 8) = *(_WORD *)(a3 + 8);
        *(_WORD *)(v12 + 2) = -1;
      }
      *(_DWORD *)(v11 + 4) = *(_DWORD *)v11;
      *(_WORD *)(v11 + 10) = *(_WORD *)(v11 + 8);
      result = (int)a6;
      *a6 = 1;
    }
    else
    {
      sub_80BBA62((int)a1, v13);
      result = a2;
      *((_WORD *)a1 + a2 + 4) = 0;
    }
  }
  return result;
}

//----- (080BCE1C) --------------------------------------------------------
int __cdecl sub_80BCE1C(int a1, int a2, int a3)
{
  Scr_AddConstString(a3);
  return sub_8083426(*(unsigned __int16 *)(a1 + 4) - 1, 0, a2, 1);
}

//----- (080BCE56) --------------------------------------------------------
long double __cdecl sub_80BCE56(_DWORD *a1, float *a2, unsigned __int16 *a3, int a4, int a5, float a6)
{
  unsigned __int16 v7; // [esp+26h] [ebp-12h]
  int v8; // [esp+28h] [ebp-10h]
  int i; // [esp+30h] [ebp-8h]
  float v10; // [esp+34h] [ebp-4h]
  float *v11; // [esp+44h] [ebp+Ch]

  v10 = sub_80BBDC8((int)a1, a2, (int)a3, a4, a5, a6);
  for ( i = 0; i < *a3; ++i )
  {
    v8 = i + a3[3];
    v7 = *((_WORD *)a1 + v8 + 4);
    if ( v7 )
    {
      v11 = (float *)((char *)&unk_8527A80 + 40 * v7);
      if ( v11[8] != 0.0 && v11[7] != 0.0 )
      {
        sub_80BCE56((int)a1, (int)v11, *a1 + 8 * v8 + 12, a4, a5, a6);
        if ( v10 > (long double)(float)0.0 )
          v10 = 0.0;
      }
    }
  }
  return v10;
}

//----- (080BCF74) --------------------------------------------------------
long double __cdecl sub_80BCF74(_DWORD *a1, int a2, float a3)
{
  long double v3; // fst7
  int v6; // [esp+30h] [ebp-58h] BYREF
  int v7; // [esp+34h] [ebp-54h]
  __int16 v8; // [esp+38h] [ebp-50h]
  __int16 v9; // [esp+3Ah] [ebp-4Eh]
  float v10; // [esp+54h] [ebp-34h]
  float v11; // [esp+58h] [ebp-30h]
  __int16 v12; // [esp+5Eh] [ebp-2Ah]
  int v13; // [esp+60h] [ebp-28h]
  int v14; // [esp+64h] [ebp-24h]
  int v15; // [esp+68h] [ebp-20h]
  int v16; // [esp+6Ch] [ebp-1Ch]
  int v17; // [esp+70h] [ebp-18h]
  unsigned __int16 v18; // [esp+76h] [ebp-12h]
  int v19; // [esp+78h] [ebp-10h]
  int i; // [esp+7Ch] [ebp-Ch]
  float v21; // [esp+98h] [ebp+10h]
  float v22; // [esp+98h] [ebp+10h]
  float v23; // [esp+98h] [ebp+10h]

  v18 = *((_WORD *)a1 + a2 + 4);
  if ( v18 )
  {
    v17 = (int)&unk_8527A80 + 40 * v18;
    v16 = v17 + 12;
    if ( *(float *)(v17 + 32) == 0.0 || *(float *)(v16 + 16) == 0.0 )
    {
      return (float)1.0;
    }
    else
    {
      v15 = *a1 + 8 * a2 + 12;
      v19 = *(unsigned __int16 *)v15;
      if ( v19 )
      {
        if ( (*(_WORD *)(v15 + 4) & 3) != 0 )
        {
          v22 = sub_80BBAD0(a1, a2) * *(float *)(v16 + 24) * a3;
          if ( v22 == 0.0 )
          {
            return (float)1.0;
          }
          else
          {
            *(float *)&v13 = *(float *)(v16 + 4) + v22;
            v12 = *(_WORD *)(v16 + 10);
            if ( (*(_WORD *)(v15 + 4) & 2) != 0 )
            {
              if ( *(float *)&v13 >= 1.0 )
                *(float *)&v13 = 1.0;
            }
            else
            {
              while ( *(float *)&v13 >= 1.0 )
              {
                *(float *)&v13 = *(float *)&v13 - 1.0;
                ++v12;
              }
            }
            if ( *(float *)v16 - *(float *)&v13 <= (long double)(v12 - *(__int16 *)(v16 + 8)) )
            {
              v7 = *(_DWORD *)v16;
              v9 = *(_WORD *)(v16 + 8);
              v6 = v13;
              v8 = v12;
              return (float)sub_80BCE56(a1, (float *)v17, (unsigned __int16 *)v15, v16, (int)&v6, v22);
            }
            else
            {
              return (float)1.0;
            }
          }
        }
        else
        {
          v23 = a3 * *(float *)(v16 + 24);
          v3 = 0.0;
          if ( v23 == 0.0 )
          {
            return (float)1.0;
          }
          else
          {
            v10 = 1.0;
            for ( i = 0; i < v19; ++i )
            {
              sub_80BCF74((int)a1, i + *(unsigned __int16 *)(v15 + 6), v23);
              v11 = v3;
              v3 = v11;
              if ( v10 > (long double)v11 )
                v10 = v11;
            }
            return v10;
          }
        }
      }
      else
      {
        v14 = *(_DWORD *)(v15 + 4);
        v21 = *(float *)(v16 + 24) * *(float *)(v14 + 8) * a3;
        if ( v21 == 0.0 )
        {
          return (float)1.0;
        }
        else
        {
          *(float *)&v13 = *(float *)(v16 + 4) + v21;
          v12 = *(_WORD *)(v16 + 10);
          if ( *(_BYTE *)(v14 + 2) )
          {
            while ( *(float *)&v13 >= 1.0 )
            {
              *(float *)&v13 = *(float *)&v13 - 1.0;
              ++v12;
            }
          }
          else if ( *(float *)&v13 >= 1.0 )
          {
            *(float *)&v13 = 1.0;
          }
          if ( *(float *)v16 - *(float *)&v13 <= (long double)(v12 - *(__int16 *)(v16 + 8)) )
          {
            v7 = *(_DWORD *)v16;
            v9 = *(_WORD *)(v16 + 8);
            v6 = v13;
            v8 = v12;
            return (float)sub_80BBDC8((int)a1, (float *)v17, v15, v16, (int)&v6, v21);
          }
          else
          {
            return (float)1.0;
          }
        }
      }
    }
  }
  else
  {
    return (float)1.0;
  }
}

//----- (080BD2FC) --------------------------------------------------------
void __cdecl sub_80BD2FC(int a1, float *a2, int a3, float a4)
{
  int v4; // [esp+1Ch] [ebp-Ch]
  float *v5; // [esp+20h] [ebp-8h]
  float *i; // [esp+20h] [ebp-8h]
  int v7; // [esp+24h] [ebp-4h]

  if ( *(_WORD *)(a1 + 4) && *((_WORD *)a2 + 2) )
  {
    if ( a2[3] == 1.0 )
    {
LABEL_4:
      Scr_AddConstString(g_end);
      sub_8083426(*(unsigned __int16 *)(a1 + 4) - 1, 0, *((unsigned __int16 *)a2 + 2), 1);
      return;
    }
    if ( *((__int16 *)a2 + 1) >= 0 || (sub_80C0164((_DWORD *)a1, a2, (_WORD *)a3), *((__int16 *)a2 + 1) >= 0) )
    {
      if ( *(_WORD *)a3 )
        a3 = *(_DWORD *)a1 + 8 * *(unsigned __int16 *)a2 + 12;
      v7 = *(_DWORD *)(a3 + 4);
      v4 = *((__int16 *)a2 + 1);
      v5 = (float *)(*(_DWORD *)(v7 + 28) + 8 * v4);
      if ( a2[3] <= (long double)a4 )
      {
        if ( a4 == 1.0 )
        {
          if ( a2[3] <= (long double)v5[1] )
          {
            do
            {
              sub_80BCE1C(a1, *((unsigned __int16 *)a2 + 2), *(unsigned __int16 *)v5);
              v5 += 2;
              ++v4;
            }
            while ( v4 < *(unsigned __int8 *)(v7 + 12) );
          }
        }
        else if ( v5[1] < (long double)a4 && a2[3] <= (long double)v5[1] )
        {
          do
          {
            sub_80BCE1C(a1, *((unsigned __int16 *)a2 + 2), *(unsigned __int16 *)v5);
            v5 += 2;
            ++v4;
          }
          while ( v4 < *(unsigned __int8 *)(v7 + 12) && a4 > (long double)v5[1] );
        }
      }
      else if ( a4 <= (long double)v5[1] )
      {
        if ( a2[3] <= (long double)v5[1] )
        {
          do
          {
            sub_80BCE1C(a1, *((unsigned __int16 *)a2 + 2), *(unsigned __int16 *)v5);
            v5 += 2;
            ++v4;
          }
          while ( v4 < *(unsigned __int8 *)(v7 + 12) );
          for ( i = *(float **)(v7 + 28); a4 > (long double)i[1]; i += 2 )
            sub_80BCE1C(a1, *((unsigned __int16 *)a2 + 2), *(unsigned __int16 *)i);
        }
      }
      else
      {
        do
        {
          sub_80BCE1C(a1, *((unsigned __int16 *)a2 + 2), *(unsigned __int16 *)v5);
          v5 += 2;
          ++v4;
        }
        while ( v4 < *(unsigned __int8 *)(v7 + 12) && a4 > (long double)v5[1] );
      }
    }
    else if ( a2[3] > (long double)a4 || a4 == 1.0 )
    {
      goto LABEL_4;
    }
  }
}

//----- (080BD62C) --------------------------------------------------------
void __cdecl sub_80BD62C(int a1, int a2, float a3, int a4, unsigned __int8 a5, unsigned __int8 a6, int a7, int a8)
{
  int v8; // ebx
  int v9; // ebx
  float v10; // [esp+4h] [ebp-74h]
  float v11; // [esp+4h] [ebp-74h]
  float v12; // [esp+4h] [ebp-74h]
  float v13; // [esp+4h] [ebp-74h]
  int v14; // [esp+30h] [ebp-48h]
  unsigned __int16 *v15; // [esp+34h] [ebp-44h]
  int v16; // [esp+38h] [ebp-40h]
  _DWORD *v17; // [esp+3Ch] [ebp-3Ch]
  _BYTE *v18; // [esp+40h] [ebp-38h]
  unsigned __int16 *v19; // [esp+44h] [ebp-34h]
  unsigned __int16 v20; // [esp+4Ah] [ebp-2Eh]
  unsigned __int16 v21; // [esp+4Ah] [ebp-2Eh]
  unsigned __int16 v22; // [esp+4Ah] [ebp-2Eh]
  float v23; // [esp+4Ch] [ebp-2Ch]
  int v24; // [esp+4Ch] [ebp-2Ch]
  int v25; // [esp+4Ch] [ebp-2Ch]
  float *v26; // [esp+50h] [ebp-28h]
  int v27; // [esp+54h] [ebp-24h]
  int j; // [esp+58h] [ebp-20h]
  int k; // [esp+58h] [ebp-20h]
  int jj; // [esp+5Ch] [ebp-1Ch]
  int i; // [esp+5Ch] [ebp-1Ch]
  int ii; // [esp+5Ch] [ebp-1Ch]
  int m; // [esp+5Ch] [ebp-1Ch]
  int n; // [esp+5Ch] [ebp-1Ch]
  float v35; // [esp+60h] [ebp-18h]
  float v36; // [esp+64h] [ebp-14h]
  float v37; // [esp+64h] [ebp-14h]

  v17 = *(_DWORD **)a1;
  v19 = (unsigned __int16 *)(**(_DWORD **)a1 + 8 * a2 + 12);
  v27 = *v19;
  if ( *v19 )
  {
    for ( i = 0; ; ++i )
    {
      if ( i >= v27 )
      {
        if ( a5 )
          sub_80BAD76(a1, (_DWORD *)a4, a7);
        return;
      }
      v20 = *((_WORD *)v17 + i + *(unsigned __int16 *)(**(_DWORD **)a1 + 8 * a2 + 18) + 4);
      if ( v20 )
      {
        v35 = *(float *)&dword_8527AA0[10 * v20];
        if ( v35 != 0.0 )
          break;
      }
    }
    for ( j = i + 1; ; ++j )
    {
      if ( j >= v27 )
      {
        sub_80BD62C(a1, i + *(unsigned __int16 *)(**(_DWORD **)a1 + 8 * a2 + 18), a3, a4, a5, a6, a7, a8);
        return;
      }
      v21 = *((_WORD *)v17 + j + *(unsigned __int16 *)(**(_DWORD **)a1 + 8 * a2 + 18) + 4);
      if ( v21 )
      {
        v36 = *(float *)&dword_8527AA0[10 * v21];
        if ( v36 != 0.0 )
          break;
      }
    }
    if ( a5 )
    {
      v26 = (float *)a4;
      sub_80BD62C(a1, i + *(unsigned __int16 *)(**(_DWORD **)a1 + 8 * a2 + 18), v35, a4, 1, 1, a7, a8);
    }
    else
    {
      v26 = (float *)(a7 + 32 * a8);
      a8 += *(unsigned __int8 *)(a1 + 25);
      if ( a8 > 512 )
      {
        Com_Printf("MAX_CALC_ANIM_BUFFER exceeded\n");
        return;
      }
      sub_80BD62C(a1, i + *(unsigned __int16 *)(**(_DWORD **)a1 + 8 * a2 + 18), v35, (int)v26, 1, 1, a7, a8);
    }
    sub_80BD62C(a1, j + v19[3], v36, (int)v26, 0, 1, a7, a8);
    for ( k = j + 1; k < v27; ++k )
    {
      v22 = *((_WORD *)v17 + k + v19[3] + 4);
      if ( v22 )
      {
        v37 = *(float *)&dword_8527AA0[10 * v22];
        if ( v37 != 0.0 )
          sub_80BD62C(a1, k + v19[3], v37, (int)v26, 0, 1, a7, a8);
      }
    }
    if ( a6 )
    {
      if ( a5 )
      {
        for ( m = 0; m < *(unsigned __int8 *)(a1 + 25); ++m )
        {
          if ( ((*(int *)(a7 + 4 * (m >> 5) + 16400) >> (m & 0x1F)) & 1) == 0 )
          {
            *(float *)&v24 = sub_80C130A((float *)a4);
            if ( *(float *)&v24 != 0.0 )
            {
              v10 = sub_80C0F22(v24) * a3;
              sub_80C124E((float *)a4, v10, (float *)a4);
            }
            if ( *(float *)(a4 + 28) != 0.0 )
            {
              v11 = a3 / *(float *)(a4 + 28);
              sub_80C118C((float *)(a4 + 16), v11, (float *)(a4 + 16));
              *(float *)(a4 + 28) = a3;
            }
          }
          a4 += 32;
        }
      }
      else
      {
        for ( n = 0; n < *(unsigned __int8 *)(a1 + 25); ++n )
        {
          if ( ((*(int *)(a7 + 4 * (n >> 5) + 16400) >> (n & 0x1F)) & 1) == 0 )
          {
            *(float *)&v25 = sub_80C130A(v26);
            if ( *(float *)&v25 != 0.0 )
            {
              v12 = sub_80C0F22(v25) * a3;
              sub_80C129A((float *)a4, v12, v26, (float *)a4);
            }
            if ( v26[7] != 0.0 )
            {
              v13 = a3 / v26[7];
              sub_80C11C4((float *)(a4 + 16), v13, v26 + 4, (float *)(a4 + 16));
              *(float *)(a4 + 28) = *(float *)(a4 + 28) + a3;
            }
          }
          a4 += 32;
          v26 += 8;
        }
      }
    }
    else
    {
      for ( ii = 0; ii < *(unsigned __int8 *)(a1 + 25); ++ii )
      {
        if ( ((*(int *)(a7 + 4 * (ii >> 5) + 16400) >> (ii & 0x1F)) & 1) == 0 && *(float *)(a4 + 28) != 0.0 )
        {
          v23 = 1.0 / *(float *)(a4 + 28);
          sub_80C124E((float *)a4, v23, (float *)a4);
          sub_80C118C((float *)(a4 + 16), v23, (float *)(a4 + 16));
        }
        a4 += 32;
      }
    }
  }
  else
  {
    if ( a5 )
      sub_80BAD76(a1, (_DWORD *)a4, a7);
    v18 = (_BYTE *)(*(_DWORD *)(a1 + 12) + 2 * *(_DWORD *)(*v17 + 4));
    if ( *(_WORD *)(*(_DWORD *)(a1 + 12) + 2 * a2) )
    {
      if ( v18[a2 + 1] != *v18 )
      {
        v18[a2 + 1] = *v18;
        sub_8079746(*(unsigned __int16 *)(*(_DWORD *)(a1 + 12) + 2 * a2), *(__int16 *)(*((_DWORD *)v19 + 1) + 14) + 16);
        v9 = *(_DWORD *)(a1 + 12);
        *(_WORD *)(v9 + 2 * a2) = sub_80BA886((int)v19, a1 + 28, *(unsigned __int8 *)(a1 + 24));
      }
    }
    else
    {
      v18[a2 + 1] = *v18;
      v8 = *(_DWORD *)(a1 + 12);
      *(_WORD *)(v8 + 2 * a2) = sub_80BA886((int)v19, a1 + 28, *(unsigned __int8 *)(a1 + 24));
    }
    v16 = SL_ConvertToString(*(unsigned __int16 *)(*(_DWORD *)(a1 + 12) + 2 * a2));
    for ( jj = 0; jj <= 3; ++jj )
      *(_DWORD *)(a7 + 4 * jj + 0x4000) |= *(_DWORD *)(v16 + 4 * jj) & ~*(_DWORD *)(a7 + 4 * jj + 16400);
    v15 = (unsigned __int16 *)*((_DWORD *)v19 + 1);
    v14 = dword_8527A8C[10 * *((unsigned __int16 *)v17 + a2 + 4)];
    if ( *(float *)&v14 != 1.0 && *v15 )
    {
      if ( *v15 > 0xFFu )
        sub_80C0D92(v15, v16 + 16, v14, a3, a4, a7 + 16400);
      else
        sub_80C0A1E(v15, v16 + 16, v14, a3, a4, a7 + 16400);
    }
    else
    {
      sub_80BAC36((int)v15, v16 + 16, a3, a4, a7 + 16400);
    }
  }
}
// 8527A8C: using guessed type int dword_8527A8C[];
// 8527AA0: using guessed type int dword_8527AA0[];

//----- (080BDE00) --------------------------------------------------------
void __cdecl sub_80BDE00(int *a1, int a2, int a3)
{
  const char *v3; // eax
  const char *v4; // eax
  const char *v5; // eax
  float v6; // [esp+38h] [ebp-30h]
  const char *v7; // [esp+3Ch] [ebp-2Ch]
  char *v8; // [esp+40h] [ebp-28h]
  float v9; // [esp+48h] [ebp-20h]
  int v10; // [esp+4Ch] [ebp-1Ch]
  float *v11; // [esp+54h] [ebp-14h]
  unsigned __int16 *v12; // [esp+58h] [ebp-10h]
  unsigned __int16 v13; // [esp+5Eh] [ebp-Ah]
  int v14; // [esp+60h] [ebp-8h]
  int i; // [esp+64h] [ebp-4h]
  int j; // [esp+64h] [ebp-4h]

  v13 = *((_WORD *)a1 + a2 + 4);
  if ( v13 )
  {
    v12 = (unsigned __int16 *)(*a1 + 8 * a2 + 12);
    v14 = *v12;
    v11 = (float *)((char *)&unk_8527A80 + 40 * v13);
    for ( i = 0; i < a3; ++i )
      Com_Printf(" ");
    v8 = sub_80BE94C(*a1, a2);
    if ( v11[7] <= (long double)v11[8] )
    {
      if ( v11[8] <= (long double)v11[7] )
        v7 = (const char *)&unk_8148F07;
      else
        v7 = "^1";
    }
    else
    {
      v7 = "^4";
    }
    if ( v14 )
    {
      if ( *((_WORD *)v11 + 2) )
      {
        if ( (unsigned __int8)sub_80C0088(*a1, a2) )
        {
          v4 = (const char *)SL_ConvertToString(*((unsigned __int16 *)v11 + 2));
          Com_Printf(
            "%s%s: (weight) %.2f -> %.2f, (time) %.2f -> %.2f, '%s'\n",
            v7,
            v8,
            v11[8],
            v11[7],
            v11[4],
            v11[3],
            v4);
        }
        else
        {
          v5 = (const char *)SL_ConvertToString(*((unsigned __int16 *)v11 + 2));
          Com_Printf("%s%s: (weight) %.2f -> %.2f, '%s'\n", v7, v8, v11[8], v11[7], v5);
        }
      }
      else if ( (unsigned __int8)sub_80C0088(*a1, a2) )
      {
        Com_Printf("%s%s: (weight) %.2f -> %.2f, (time) %.2f -> %.2f\n", v7, v8, v11[8], v11[7], v11[4], v11[3]);
      }
      else
      {
        Com_Printf("%s%s: (weight) %.2f -> %.2f\n", v7, v8, v11[8], v11[7]);
      }
      for ( j = 0; j < v14; ++j )
        sub_80BDE00(a1, j + v12[3], a3 + 1);
    }
    else
    {
      v10 = *((_DWORD *)v12 + 1);
      v9 = v11[3] - v11[4];
      if ( v9 < 0.0 )
        v9 = v9 + 1.0;
      if ( *(float *)(v10 + 8) == 0.0 )
        v6 = 0.0;
      else
        v6 = v9 / *(float *)(v10 + 8);
      if ( *((_WORD *)v11 + 2) )
      {
        v3 = (const char *)SL_ConvertToString(*((unsigned __int16 *)v11 + 2));
        Com_Printf(
          "%s%s: (weight) %.2f -> %.2f, (time) %.2f -> %.2f, (realtimedelta) %.2f, '%s'\n",
          v7,
          v8,
          v11[8],
          v11[7],
          v11[4],
          v11[3],
          v6,
          v3);
      }
      else
      {
        Com_Printf(
          "%s%s: (weight) %.2f -> %.2f, (time) %.2f -> %.2f, (realtimedelta) %.2f\n",
          v7,
          v8,
          v11[8],
          v11[7],
          v11[4],
          v11[3],
          v6);
      }
    }
  }
}
// 80BDE00: using guessed type int arg_4;

//----- (080BE1F4) --------------------------------------------------------
void __cdecl sub_80BE1F4(int a1, int a2, float a3, unsigned __int8 a4, unsigned __int8 a5, _DWORD *a6)
{
  float v6; // [esp+4h] [ebp-94h]
  float v7; // [esp+4h] [ebp-94h]
  float v8; // [esp+4h] [ebp-94h]
  float v9; // [esp+4h] [ebp-94h]
  float v10; // [esp+4h] [ebp-94h]
  float v11; // [esp+2Ch] [ebp-6Ch]
  char *v12; // [esp+30h] [ebp-68h]
  float v13; // [esp+34h] [ebp-64h]
  float v14; // [esp+38h] [ebp-60h]
  int v15; // [esp+44h] [ebp-54h]
  unsigned __int16 *v16; // [esp+48h] [ebp-50h]
  unsigned __int16 v17; // [esp+4Eh] [ebp-4Ah]
  unsigned __int16 v18; // [esp+4Eh] [ebp-4Ah]
  unsigned __int16 v19; // [esp+4Eh] [ebp-4Ah]
  unsigned __int16 v20; // [esp+4Eh] [ebp-4Ah]
  char v21; // [esp+50h] [ebp-48h] BYREF
  float v22; // [esp+70h] [ebp-28h]
  int v23; // [esp+74h] [ebp-24h]
  int v24; // [esp+78h] [ebp-20h]
  int j; // [esp+7Ch] [ebp-1Ch]
  int i; // [esp+80h] [ebp-18h]
  float v27; // [esp+84h] [ebp-14h]
  float v28; // [esp+88h] [ebp-10h]
  unsigned __int8 v29; // [esp+8Eh] [ebp-Ah]
  unsigned __int8 v30; // [esp+8Fh] [ebp-9h]

  v30 = a4;
  v29 = a5;
  v16 = (unsigned __int16 *)(*(_DWORD *)a1 + 8 * a2 + 12);
  v24 = *v16;
  if ( v24 )
  {
    for ( i = 0; ; ++i )
    {
      if ( i >= v24 )
      {
        if ( v30 )
        {
          sub_80C0F86(a6);
          a6[2] = 0;
          sub_80C1040(a6 + 3);
        }
        return;
      }
      v18 = *(_WORD *)(a1 + 2 * (i + v16[3]) + 8);
      if ( v18 )
      {
        v14 = *(_BYTE *)(a1 + 7) ? *(float *)&dword_8527A9C[10 * v18] : *(float *)&dword_8527AA0[10 * v18];
        v27 = v14;
        if ( v14 != 0.0 )
          break;
      }
    }
    for ( j = i + 1; ; ++j )
    {
      if ( j >= v24 )
      {
        sub_80BE1F4(a1, i + v16[3], a3, v30, v29, (int)a6);
        return;
      }
      v19 = *(_WORD *)(a1 + 2 * (j + v16[3]) + 8);
      if ( v19 )
      {
        v13 = *(_BYTE *)(a1 + 7) ? *(float *)&dword_8527A9C[10 * v19] : *(float *)&dword_8527AA0[10 * v19];
        v28 = v13;
        if ( v13 != 0.0 )
          break;
      }
    }
    if ( v30 )
      v12 = (char *)a6;
    else
      v12 = &v21;
    v23 = (int)v12;
    sub_80BE1F4(a1, i + v16[3], v27, 1, 1, (int)v12);
    sub_80BE1F4(a1, j + v16[3], v28, 0, 1, v23);
    ++j;
    while ( j < v24 )
    {
      v20 = *(_WORD *)(a1 + 2 * (j + v16[3]) + 8);
      if ( v20 )
      {
        v11 = *(_BYTE *)(a1 + 7) ? *(float *)&dword_8527A9C[10 * v20] : *(float *)&dword_8527AA0[10 * v20];
        v28 = v11;
        if ( v11 != 0.0 )
          sub_80BE1F4(a1, j + v16[3], v28, 0, 1, v23);
      }
      ++j;
    }
    if ( v29 )
    {
      if ( v30 )
      {
        v22 = sub_80C101E((float *)a6);
        if ( v22 != 0.0 )
        {
          v7 = sub_80C0F22(SLODWORD(v22)) * a3;
          sub_80C0FC2((float *)a6, v7, (float *)a6);
        }
        if ( *((float *)a6 + 2) != 0.0 )
        {
          v8 = a3 / *((float *)a6 + 2);
          sub_80C118C((float *)a6 + 3, v8, (float *)a6 + 3);
          *((float *)a6 + 2) = a3;
        }
      }
      else
      {
        v22 = sub_80C101E((float *)v23);
        if ( v22 != 0.0 )
        {
          v9 = sub_80C0F22(SLODWORD(v22)) * a3;
          sub_80C0FE8((float *)a6, v9, (float *)v23, (float *)a6);
        }
        if ( *(float *)(v23 + 8) != 0.0 )
        {
          v10 = a3 / *(float *)(v23 + 8);
          sub_80C11C4((float *)a6 + 3, v10, (float *)(v23 + 12), (float *)a6 + 3);
          *((float *)a6 + 2) = *((float *)a6 + 2) + a3;
        }
      }
    }
    else if ( *((float *)a6 + 2) != 0.0 )
    {
      v6 = 1.0 / *((float *)a6 + 2);
      sub_80C118C((float *)a6 + 3, v6, (float *)a6 + 3);
    }
  }
  else
  {
    if ( v30 )
    {
      sub_80C0F86(a6);
      a6[2] = 0;
      sub_80C1040(a6 + 3);
    }
    v15 = *((_DWORD *)v16 + 1);
    if ( *(_BYTE *)(v15 + 3) )
    {
      v17 = *(_WORD *)(a1 + 2 * a2 + 8);
      if ( v17 )
      {
        if ( *(_BYTE *)(a1 + 6) )
          sub_80BB9A8((unsigned __int16 *)v15, a3, *((float *)&unk_8527A80 + 10 * v17 + 3), (float *)a6);
        else
          sub_80BB82A(
            v15,
            a3,
            *((float *)&unk_8527A80 + 10 * v17 + 4),
            *((float *)&unk_8527A80 + 10 * v17 + 3),
            (float *)a6,
            1);
      }
    }
  }
}
// 8527A9C: using guessed type int dword_8527A9C[];
// 8527AA0: using guessed type int dword_8527AA0[];

//----- (080BE760) --------------------------------------------------------
long double __cdecl sub_80BE760(int a1, int a2)
{
  return (long double)**(unsigned __int16 **)(a1 + 8 * a2 + 16) / *(float *)(*(_DWORD *)(a1 + 8 * a2 + 16) + 4);
}

//----- (080BE794) --------------------------------------------------------
int __cdecl sub_80BE794(int a1, int a2)
{
  return (int)(sub_80BE760(a1, a2) * 1000.0);
}

//----- (080BE7D2) --------------------------------------------------------
long double __cdecl sub_80BE7D2(int a1, int a2)
{
  unsigned __int16 v4; // [esp+6h] [ebp-2h]

  v4 = *(_WORD *)(a1 + 2 * a2 + 8);
  if ( v4 )
    return *(float *)&dword_8527A8C[10 * v4];
  else
    return (float)0.0;
}
// 8527A8C: using guessed type int dword_8527A8C[];

//----- (080BE816) --------------------------------------------------------
long double __cdecl sub_80BE816(int a1, int a2)
{
  unsigned __int16 v4; // [esp+6h] [ebp-2h]

  v4 = *(_WORD *)(a1 + 2 * a2 + 8);
  if ( v4 )
    return *(float *)&dword_8527AA0[10 * v4];
  else
    return (float)0.0;
}
// 8527AA0: using guessed type int dword_8527AA0[];

//----- (080BE8E4) --------------------------------------------------------
int __cdecl sub_80BE8E4(int a1, int a2)
{
  return *(unsigned __int16 *)(a1 + 8 * a2 + 12);
}

//----- (080BE8F4) --------------------------------------------------------
int __cdecl sub_80BE8F4(int a1, int a2, int a3)
{
  return a3 + *(unsigned __int16 *)(a1 + 8 * a2 + 18);
}

//----- (080BE908) --------------------------------------------------------
void *__cdecl sub_80BE908(int a1, int a2)
{
  if ( *(_WORD *)(a1 + 8 * a2 + 12) )
    return &unk_8148F07;
  else
    return *(void **)(*(_DWORD *)(a1 + 8 * a2 + 16) + 36);
}

//----- (080BE940) --------------------------------------------------------
int __cdecl sub_80BE940(int a1)
{
  return *(unsigned __int8 *)(a1 + 40);
}

//----- (080BE94C) --------------------------------------------------------
char *__cdecl sub_80BE94C(int a1, int a2)
{
  char v4; // [esp+13h] [ebp-15h]
  const char *v7; // [esp+20h] [ebp-8h]
  _WORD *v8; // [esp+24h] [ebp-4h]

  v8 = (_WORD *)(a1 + 8 * a2 + 12);
  if ( *(_DWORD *)(a1 + 8) )
  {
    v7 = *(const char **)(*(_DWORD *)(a1 + 8) + 4 * a2);
    v4 = 0;
    if ( !*v8 && (unsigned __int8)sub_80BE940(*(_DWORD *)(a1 + 8 * a2 + 16)) )
      v4 = 1;
    if ( v4 )
      return va("^3%s (missing)", v7);
    else
      return (char *)v7;
  }
  else if ( *v8 )
  {
    return va("%i", a2);
  }
  else
  {
    return *(char **)(*(_DWORD *)(a1 + 8 * a2 + 16) + 36);
  }
}

//----- (080BEA0E) --------------------------------------------------------
int __cdecl sub_80BEA0E(int a1)
{
  return *(_DWORD *)a1;
}

//----- (080BEA18) --------------------------------------------------------
int __cdecl sub_80BEA18(int a1)
{
  return *(_DWORD *)(a1 + 4);
}

//----- (080BEA24) --------------------------------------------------------
int *__cdecl sub_80BEA24(int *a1, int *a2, float a3)
{
  int *result; // eax
  int v4; // [esp+20h] [ebp-38h] BYREF
  __int16 v5; // [esp+28h] [ebp-30h]
  _BYTE v6[10]; // [esp+4Eh] [ebp-Ah] BYREF

  result = a1;
  if ( *a1 )
  {
    v4 = 0;
    v5 = 0;
    sub_80BCB3A((_DWORD *)*a2, 0, (int)&v4, a3, 1, &v6[1], v6);
    return (int *)sub_80BC912(*a1, *a2);
  }
  return result;
}
// 80BEA24: using guessed type _BYTE var_A[10];

//----- (080BEA94) --------------------------------------------------------
_DWORD **__cdecl sub_80BEA94(_DWORD **a1, float a2)
{
  _DWORD **result; // eax
  int v3; // [esp+20h] [ebp-38h] BYREF
  __int16 v4; // [esp+28h] [ebp-30h]
  _BYTE v5[10]; // [esp+4Eh] [ebp-Ah] BYREF

  result = a1;
  if ( *a1 )
  {
    v3 = 0;
    v4 = 0;
    return (_DWORD **)sub_80BCB3A(*a1, 0, (int)&v3, a2, 1, &v5[1], v5);
  }
  return result;
}
// 80BEA94: using guessed type _BYTE var_A[10];

//----- (080BEAEE) --------------------------------------------------------
void __cdecl sub_80BEAEE(_DWORD **a1, float a2)
{
  int v2; // [esp+20h] [ebp-38h] BYREF
  __int16 v3; // [esp+28h] [ebp-30h]
  _BYTE v4[10]; // [esp+4Eh] [ebp-Ah] BYREF

  dword_85500A0 = 0;
  if ( *a1 )
  {
    v2 = 0;
    v3 = 0;
    sub_80BCB3A(*a1, 0, (int)&v2, a2, 1, &v4[1], v4);
    sub_80BC52E(*a1, 0, a2, 1u);
  }
}
// 85500A0: using guessed type int dword_85500A0;
// 80BEAEE: using guessed type _BYTE var_A[10];

//----- (080BEB76) --------------------------------------------------------
int __cdecl sub_80BEB76(_DWORD **a1, float a2, int a3)
{
  float v5; // [esp+20h] [ebp-8h]
  float v6; // [esp+24h] [ebp-4h]

  if ( !*a1 )
    return 0;
  if ( a3 )
  {
    v6 = sub_80BCF74(*a1, 0, a2);
    if ( v6 == 1.0 || (v5 = a2 * v6 + 0.001, a2 < (long double)v5) )
    {
      sub_80BC52E(*a1, 0, a2, 1u);
      return 0;
    }
    else
    {
      sub_80BC52E(*a1, 0, v5, 1u);
      return 1;
    }
  }
  else
  {
    sub_80BC52E(*a1, 0, a2, 0);
    return 0;
  }
}

//----- (080BEC88) --------------------------------------------------------
int __cdecl sub_80BEC88(int a1, int a2)
{
  int result; // eax
  int v3[4103]; // [esp+20h] [ebp-4068h] BYREF
  int v4; // [esp+403Ch] [ebp-4Ch]
  char v5; // [esp+404Fh] [ebp-39h]
  int v6; // [esp+4050h] [ebp-38h]
  int v7; // [esp+4054h] [ebp-34h]
  int v8; // [esp+4058h] [ebp-30h]
  __int16 *v9; // [esp+405Ch] [ebp-2Ch]
  int j; // [esp+4060h] [ebp-28h]
  int v11; // [esp+4064h] [ebp-24h]
  int v12; // [esp+4068h] [ebp-20h]
  int i; // [esp+406Ch] [ebp-1Ch] BYREF

  result = *(_DWORD *)(a1 + 4);
  v12 = result;
  v5 = 1;
  for ( i = 0; i <= 3; ++i )
  {
    v3[i + 4096] = *(_DWORD *)(v12 + 4 * i) | ~*(_DWORD *)(a2 + 4 * i);
    if ( v3[i + 4096] != -1 )
      v5 = 0;
    result = (int)&i;
  }
  if ( !v5 )
  {
    for ( i = 0; i <= 3; ++i )
    {
      *(_DWORD *)(v12 + 4 * i) |= *(_DWORD *)(a2 + 4 * i);
      v3[i + 4100] = v3[i + 4096];
    }
    v11 = v12 + 48;
    if ( *(_DWORD *)a1 )
    {
      v4 |= 0x80000000;
      sub_80BD62C(a1, 0, 1.0, v11, 1u, 0, (int)v3, 0);
    }
    v7 = 0;
    for ( j = 0; ; ++j )
    {
      result = *(unsigned __int8 *)(a1 + 24);
      if ( j >= result )
        break;
      v9 = **(__int16 ***)(a1 + 4 * j + 28);
      i = v9[1];
      while ( i )
      {
        if ( ((v3[(v7 >> 5) + 4096] >> (v7 & 0x1F)) & 1) == 0 )
        {
          *(_DWORD *)v11 = 0;
          *(_DWORD *)(v11 + 4) = 0;
          *(_DWORD *)(v11 + 8) = 0;
          *(_DWORD *)(v11 + 12) = 1065353216;
          sub_80C1040((_DWORD *)(v11 + 16));
        }
        --i;
        v11 += 32;
        ++v7;
      }
      v8 = *((_DWORD *)v9 + 2);
      v6 = *((_DWORD *)v9 + 1);
      i = *v9 - v9[1];
      while ( i )
      {
        if ( ((v3[(v7 >> 5) + 4096] >> (v7 & 0x1F)) & 1) == 0 )
        {
          sub_80C15B4((__int16 *)v8, 0.000030518509, (float *)v11);
          sub_80C1040((_DWORD *)(v11 + 16));
        }
        --i;
        v11 += 32;
        ++v7;
        v8 += 8;
      }
    }
  }
  return result;
}

//----- (080BEEE4) --------------------------------------------------------
void __cdecl sub_80BEEE4(int **a1)
{
  if ( *a1 )
  {
    sub_80BDE00(*a1, 0, 0);
    Com_Printf("\n");
  }
  else
  {
    Com_Printf("NO TREE\n");
  }
}

//----- (080BEF2C) --------------------------------------------------------
int __cdecl sub_80BEF2C(int a1, int a2, _DWORD *a3, _DWORD *a4, char a5)
{
  int v6[3]; // [esp+20h] [ebp-38h] BYREF
  int v7[8]; // [esp+2Ch] [ebp-2Ch] BYREF
  char v8; // [esp+4Fh] [ebp-9h]

  v8 = a5;
  *(_BYTE *)(a1 + 6) = 0;
  *(_BYTE *)(a1 + 7) = v8;
  sub_80BE1F4(a1, a2, 1.0, 1u, 0, v6);
  if ( *(float *)v6 == 0.0 || *(float *)&v6[1] == 0.0 )
  {
    *a3 = 0;
    a3[1] = 1065353216;
  }
  else
  {
    sub_80C0FA2(v6, a3);
  }
  return sub_80C106A(v7, a4);
}
// 80BEF2C: using guessed type int anonymous_0[8];

//----- (080BEFE2) --------------------------------------------------------
int __cdecl sub_80BEFE2(int a1, int a2, _DWORD *a3, _DWORD *a4)
{
  int v5[3]; // [esp+20h] [ebp-28h] BYREF
  int v6[7]; // [esp+2Ch] [ebp-1Ch] BYREF

  *(_BYTE *)(a1 + 6) = 1;
  *(_BYTE *)(a1 + 7) = 1;
  sub_80BE1F4(a1, a2, 1.0, 1u, 0, v5);
  if ( *(float *)v5 == 0.0 && *(float *)&v5[1] == 0.0 )
  {
    *a3 = 0;
    a3[1] = 1065353216;
  }
  else
  {
    sub_80C0FA2(v5, a3);
  }
  return sub_80C106A(v6, a4);
}
// 80BEFE2: using guessed type int anonymous_0[7];

//----- (080BF08C) --------------------------------------------------------
int __cdecl XAnimGetRelDelta(int a1, int a2, _DWORD *a3, _DWORD *a4, float a5, float a6)
{
  int v7; // [esp+24h] [ebp-34h]
  int v8[3]; // [esp+30h] [ebp-28h] BYREF
  _DWORD v9[7]; // [esp+3Ch] [ebp-1Ch] BYREF

  if ( *(_WORD *)(a1 + 8 * a2 + 12) || (v7 = *(_DWORD *)(a1 + 8 * a2 + 16), !*(_BYTE *)(v7 + 3)) )
  {
    *a3 = 0;
    a3[1] = 1065353216;
    return sub_80C1040(a4);
  }
  else
  {
    sub_80C0F86(v8);
    v8[2] = 0;
    sub_80C1040(v9);
    sub_80BB82A(v7, 1.0, a5, a6, (float *)v8, 0);
    if ( *(float *)v8 == 0.0 && *(float *)&v8[1] == 0.0 )
    {
      *a3 = 0;
      a3[1] = 1065353216;
    }
    else
    {
      sub_80C0FA2(v8, a3);
    }
    return sub_80C106A(v9, a4);
  }
}

//----- (080BF1A4) --------------------------------------------------------
int __cdecl sub_80BF1A4(int a1, int a2, _DWORD *a3, _DWORD *a4, float a5)
{
  int v6; // [esp+14h] [ebp-34h]
  int v7[3]; // [esp+20h] [ebp-28h] BYREF
  _DWORD v8[7]; // [esp+2Ch] [ebp-1Ch] BYREF

  if ( *(_WORD *)(a1 + 8 * a2 + 12) || (v6 = *(_DWORD *)(a1 + 8 * a2 + 16), !*(_BYTE *)(v6 + 3)) )
  {
    *a3 = 0;
    a3[1] = 1065353216;
    return sub_80C1040(a4);
  }
  else
  {
    sub_80C0F86(v7);
    v7[2] = 0;
    sub_80C1040(v8);
    sub_80BB9A8((unsigned __int16 *)v6, 1.0, a5, (float *)v7);
    if ( *(float *)v7 == 0.0 && *(float *)&v7[1] == 0.0 )
    {
      *a3 = 0;
      a3[1] = 1065353216;
    }
    else
    {
      sub_80C0FA2(v7, a3);
    }
    return sub_80C106A(v8, a4);
  }
}

//----- (080BF2AE) --------------------------------------------------------
int __cdecl sub_80BF2AE(int a1, int a2)
{
  unsigned __int16 v3; // [esp+16h] [ebp-2h]

  v3 = word_8527A8A[0];
  if ( !word_8527A8A[0] )
    Com_Error(1, (char *)&byte_81490E0);
  word_8527A8A[0] = word_8527A8A[20 * (unsigned __int16)word_8527A8A[0]];
  word_8527A88[20 * (unsigned __int16)word_8527A8A[0]] = 0;
  *(_WORD *)(a1 + 2 * a2 + 8) = v3;
  return 40 * v3 + 139623040;
}
// 8527A88: using guessed type __int16 word_8527A88[];
// 8527A8A: using guessed type __int16 word_8527A8A[];

//----- (080BF346) --------------------------------------------------------
int __cdecl sub_80BF346(int a1, int a2, float a3)
{
  int result; // eax
  float *v4; // [esp+10h] [ebp-8h]
  unsigned __int16 v5; // [esp+16h] [ebp-2h]

  result = *(unsigned __int16 *)(a1 + 2 * a2 + 8);
  v5 = *(_WORD *)(a1 + 2 * a2 + 8);
  if ( v5 )
  {
    v4 = (float *)((char *)&unk_8527A80 + 40 * v5);
    if ( v4[7] == 0.0 )
    {
      if ( v4[6] > (long double)a3 )
        v4[6] = a3;
    }
    else
    {
      v4[6] = a3;
    }
    v4[7] = 0.0;
    if ( a3 == 0.0 )
      v4[8] = 0.0;
    return sub_80BBA2E((int)v4);
  }
  return result;
}

//----- (080BF3FE) --------------------------------------------------------
int __cdecl sub_80BF3FE(_DWORD *a1, int a2, float a3)
{
  int result; // eax
  unsigned __int16 *v4; // [esp+Ch] [ebp-Ch]
  int i; // [esp+10h] [ebp-8h]
  int v6; // [esp+14h] [ebp-4h]

  result = a2;
  if ( *((_WORD *)a1 + a2 + 4) )
  {
    sub_80BF346((int)a1, a2, a3);
    v4 = (unsigned __int16 *)(*a1 + 8 * a2 + 12);
    v6 = *v4;
    for ( i = 0; ; ++i )
    {
      result = i;
      if ( i >= v6 )
        break;
      sub_80BF3FE(a1, i + v4[3], LODWORD(a3));
    }
  }
  return result;
}

//----- (080BF482) --------------------------------------------------------
int __cdecl sub_80BF482(_DWORD *a1, int a2, float a3)
{
  int result; // eax
  unsigned __int16 *v4; // [esp+Ch] [ebp-Ch]
  int i; // [esp+10h] [ebp-8h]
  int v6; // [esp+14h] [ebp-4h]

  v4 = (unsigned __int16 *)(*a1 + 8 * a2 + 12);
  v6 = *v4;
  for ( i = 0; ; ++i )
  {
    result = i;
    if ( i >= v6 )
      break;
    sub_80BF3FE(a1, i + v4[3], a3);
  }
  return result;
}

//----- (080BF4DC) --------------------------------------------------------
int __cdecl sub_80BF4DC(_DWORD *a1, int a2, float a3, float a4)
{
  int result; // eax
  float v5; // [esp+0h] [ebp-48h]
  float v6; // [esp+18h] [ebp-30h]
  float v7; // [esp+1Ch] [ebp-2Ch]
  unsigned __int16 v8; // [esp+22h] [ebp-26h]
  float v9; // [esp+28h] [ebp-20h]
  float v10; // [esp+30h] [ebp-18h]
  unsigned __int16 *v11; // [esp+38h] [ebp-10h]
  int v12; // [esp+40h] [ebp-8h]
  int i; // [esp+44h] [ebp-4h]
  int j; // [esp+44h] [ebp-4h]

  if ( a2 )
  {
    v11 = (unsigned __int16 *)(*a1 + 8 * *(unsigned __int16 *)(*a1 + 8 * a2 + 14) + 12);
    v9 = 0.0;
    v12 = *v11;
    for ( i = 0; i < v12; ++i )
    {
      v8 = *((_WORD *)a1 + i + v11[3] + 4);
      if ( v8 )
        v7 = *(float *)&dword_8527AA0[10 * v8];
      else
        v7 = 0.0;
      if ( i + v11[3] == a2 )
      {
        v5 = a3 - v7;
        v6 = sub_80C0F08(v5);
      }
      else
      {
        v6 = v7;
      }
      if ( v6 > (long double)v9 )
        v9 = v6;
    }
    for ( j = 0; ; ++j )
    {
      result = j;
      if ( j >= v12 )
        break;
      if ( j + v11[3] != a2 )
      {
        v10 = v9 * a4;
        sub_80BF346((int)a1, j + v11[3], v10);
      }
    }
  }
  return result;
}
// 8527AA0: using guessed type int dword_8527AA0[];

//----- (080BF62C) --------------------------------------------------------
void __cdecl sub_80BF62C(_DWORD *a1, int a2, float a3, float a4, int a5, int a6, int a7)
{
  if ( a3 < 0.001 )
    a3 = 0.0;
  sub_80BF4DC(a1, a2, a3, a4);
  sub_80C04C6(a1, a2, a3, SLODWORD(a4), a5, a6, 0, a7);
}

//----- (080BF6AC) --------------------------------------------------------
int __cdecl sub_80BF6AC(_DWORD *a1, int a2, int a3, float a4, float a5, int a6, int a7, int a8)
{
  int v10; // [esp+24h] [ebp-4h]

  if ( a4 < 0.001 )
    a4 = 0.0;
  sub_80BF4DC(a1, a2, a4, a5);
  v10 = sub_80BFB06(a1, a2, a4, a5, a6, 0, a7, 0);
  sub_80C02D8(a1, a2, SLODWORD(a5));
  if ( a8 )
  {
LABEL_4:
    sub_80C01C8(a1, a2);
    goto LABEL_5;
  }
  while ( 1 )
  {
LABEL_5:
    if ( !a2 )
      return 1;
    a2 = *(unsigned __int16 *)(*a1 + 8 * a2 + 14);
    if ( a2 == a3 )
      return v10;
    sub_80BF4DC(a1, a2, 1.0, a5);
    sub_80BFB06(a1, a2, 1.0, a5, 1065353216, 0, 0, 0);
    if ( a8 )
      goto LABEL_4;
  }
}

//----- (080BF81E) --------------------------------------------------------
int __cdecl sub_80BF81E(_DWORD *a1, int a2, float a3, float a4, int a5, int a6, int a7)
{
  if ( a3 < 0.001 )
    a3 = 0.0;
  sub_80BF4DC(a1, a2, a3, a4);
  return sub_80C0354(a1, a2, a3, SLODWORD(a4), a5, a6, 0, a7);
}

//----- (080BF89E) --------------------------------------------------------
int __cdecl sub_80BF89E(_DWORD *a1, int a2, float a3)
{
  int result; // eax
  unsigned __int16 *v4; // [esp+Ch] [ebp-Ch]
  int v5; // [esp+10h] [ebp-8h]
  int i; // [esp+14h] [ebp-4h]

  v4 = (unsigned __int16 *)(*a1 + 8 * a2 + 12);
  v5 = *v4;
  for ( i = 0; ; ++i )
  {
    result = i;
    if ( i >= v5 )
      break;
    sub_80BF346((int)a1, i + v4[3], a3);
  }
  return result;
}

//----- (080BF8F8) --------------------------------------------------------
int __cdecl sub_80BF8F8(_DWORD *a1, int a2)
{
  int result; // eax
  unsigned __int16 *v3; // [esp+8h] [ebp-10h]
  int v4; // [esp+Ch] [ebp-Ch]
  int i; // [esp+10h] [ebp-8h]
  int v6; // [esp+14h] [ebp-4h]

  result = *((unsigned __int16 *)a1 + a2 + 4);
  v4 = result;
  if ( *((_WORD *)a1 + a2 + 4) )
  {
    v3 = (unsigned __int16 *)(*a1 + 8 * a2 + 12);
    v6 = *v3;
    for ( i = 0; i < v6; ++i )
      sub_80BF8F8(a1, i + v3[3]);
    sub_80BBA62((int)a1, v4);
    result = a2;
    *((_WORD *)a1 + a2 + 4) = 0;
  }
  return result;
}

//----- (080BF980) --------------------------------------------------------
int __cdecl sub_80BF980(int a1)
{
  int result; // eax
  int i; // [esp+18h] [ebp-10h]
  int v3; // [esp+1Ch] [ebp-Ch]
  int v4; // [esp+20h] [ebp-8h]

  v4 = *(_DWORD *)(*(_DWORD *)a1 + 4);
  v3 = a1 + 2 * v4 + 8;
  for ( i = 0; ; ++i )
  {
    result = i;
    if ( i >= v4 )
      break;
    if ( *(_WORD *)(v3 + 2 * i) )
    {
      sub_8079746(*(unsigned __int16 *)(v3 + 2 * i), *(__int16 *)(*(_DWORD *)(*(_DWORD *)a1 + 8 * i + 16) + 14) + 16);
      *(_WORD *)(v3 + 2 * i) = 0;
    }
  }
  return result;
}

//----- (080BFA1E) --------------------------------------------------------
int __cdecl sub_80BFA1E(_DWORD *a1)
{
  sub_80BF8F8(a1, 0);
  return sub_80BF980((int)a1);
}

//----- (080BFA44) --------------------------------------------------------
int __cdecl sub_80BFA44(_DWORD *a1, int a2)
{
  unsigned __int16 *v4; // [esp+Ch] [ebp-18h]
  int i; // [esp+10h] [ebp-14h]
  int v6; // [esp+14h] [ebp-10h]
  int v7; // [esp+18h] [ebp-Ch]
  float v8; // [esp+1Ch] [ebp-8h]
  float v9; // [esp+20h] [ebp-4h]

  v4 = (unsigned __int16 *)(*a1 + 8 * a2 + 12);
  if ( !*v4 )
    return a2;
  v9 = 0.0;
  v6 = 0;
  for ( i = 0; i < *v4; ++i )
  {
    v8 = *(float *)&dword_8527A9C[10 * *((unsigned __int16 *)a1 + i + v4[3] + 4)];
    if ( v9 < (long double)v8 )
    {
      v7 = sub_80BFA44(a1, i + v4[3]);
      if ( v7 )
      {
        v9 = v8;
        v6 = v7;
      }
    }
  }
  return v6;
}
// 8527A9C: using guessed type int dword_8527A9C[];

//----- (080BFB06) --------------------------------------------------------
int __cdecl sub_80BFB06(_DWORD *a1, int a2, float a3, float a4, int a5, char a6, int a7, __int16 a8)
{
  float *v10; // [esp+18h] [ebp-10h]

  if ( *((_WORD *)a1 + a2 + 4) )
  {
    v10 = (float *)((char *)&unk_8527A80 + 40 * *((unsigned __int16 *)a1 + a2 + 4));
    sub_80BBA2E((int)v10);
LABEL_7:
    if ( !a2 )
    {
      a3 = 1.0;
      a4 = 0.0;
      a5 = 1065353216;
    }
    if ( a4 == 0.0 )
    {
      v10[8] = a3;
    }
    else if ( v10[8] == 0.0 )
    {
      v10[8] = a3 * 0.001;
    }
    if ( a3 == 0.0 )
    {
      if ( v10[7] == 0.0 )
      {
        if ( v10[6] > (long double)a4 )
          v10[6] = a4;
      }
      else
      {
        v10[6] = a4;
      }
    }
    else if ( a3 < (long double)v10[8] )
    {
      v10[6] = (v10[8] - a3) * a4 / v10[8];
    }
    else
    {
      v10[6] = (a3 - v10[8]) * a4 / a3;
    }
    v10[7] = a3;
    *((_DWORD *)v10 + 9) = a5;
    *((_WORD *)v10 + 2) = a7;
    if ( a7 )
      sub_807951E(a7);
    if ( a7 && *(_WORD *)(*a1 + 8 * a2 + 12) && (*(_WORD *)(*a1 + 8 * a2 + 16) & 3) != 0 )
    {
      *(_WORD *)v10 = sub_80BFA44(a1, a2);
      if ( !*(_WORD *)v10 )
        return 2;
    }
    else
    {
      *(_WORD *)v10 = 0;
    }
    *((_WORD *)v10 + 3) = a8;
    return 0;
  }
  if ( a3 != 0.0 || a6 )
  {
    v10 = (float *)sub_80BF2AE((int)a1, a2);
    sub_80BC8C8(v10);
    goto LABEL_7;
  }
  return 0;
}

//----- (080BFD38) --------------------------------------------------------
int __cdecl sub_80BFD38(int a1, int a2, int a3)
{
  int result; // eax

  result = a3;
  dword_8527AA4[10 * *(unsigned __int16 *)(a1 + 2 * a2 + 8)] = a3;
  return result;
}
// 8527AA4: using guessed type int dword_8527AA4[40951];

//----- (080BFD6A) --------------------------------------------------------
void *__cdecl sub_80BFD6A(size_t n)
{
  return Hunk_AllocAlignInternal(n, 4);
}

//----- (080BFD86) --------------------------------------------------------
int __cdecl sub_80BFD86(_DWORD *a1, int a2, unsigned __int8 a3)
{
  int result; // eax
  char *v4; // eax
  char *v5; // eax
  char *v6; // eax
  __int16 v7; // [esp+16h] [ebp-22h]
  __int16 v8; // [esp+18h] [ebp-20h]
  int v9; // [esp+20h] [ebp-18h]
  int i; // [esp+24h] [ebp-14h]
  int v11; // [esp+28h] [ebp-10h]
  unsigned __int16 *v12; // [esp+2Ch] [ebp-Ch]

  v12 = (unsigned __int16 *)&a1[2 * a2 + 3];
  v11 = *v12;
  if ( *v12 )
  {
    if ( (a1[2 * a2 + 4] & 3) != 0 )
    {
      v9 = 0;
      do
      {
        ++v9;
        v12 = (unsigned __int16 *)&a1[2 * v12[3] + 3];
      }
      while ( *v12 );
      v6 = sub_80BE94C((int)a1, a2);
      Com_Error(1, (char *)&byte_8149220, *a1, v9, v6);
    }
    v8 = a1[2 * a2 + 4];
    if ( a3 )
      v7 = v8 | 1;
    else
      v7 = v8 | 2;
    LOWORD(a1[2 * a2 + 4]) = v7;
    for ( i = 0; ; ++i )
    {
      result = i;
      if ( i >= v11 )
        break;
      sub_80BFD86(a1, i + HIWORD(a1[2 * a2 + 4]), a3);
    }
  }
  else
  {
    result = *(unsigned __int8 *)(a1[2 * a2 + 4] + 2);
    if ( (_BYTE)result != a3 )
    {
      if ( !(unsigned __int8)sub_80BE940(a1[2 * a2 + 4]) )
      {
        if ( a3 )
        {
          v4 = sub_80BE94C((int)a1, a2);
          Com_Error(1, (char *)&byte_81491A0, v4, *a1);
        }
        v5 = sub_80BE94C((int)a1, a2);
        Com_Error(1, (char *)&byte_81491E0, v5, *a1);
      }
      sub_80BA3AE("void_loop", (int (__cdecl *)(int))sub_80BFD6A);
      a1[2 * a2 + 4] = sub_80BA2DE("void_loop");
      result = (int)&a1[2 * a2 + 3];
      if ( !a1[2 * a2 + 4] )
        Com_Error(1, (char *)&byte_8149140, "void_loop");
    }
  }
  return result;
}

//----- (080BFF8E) --------------------------------------------------------
int __cdecl sub_80BFF8E(_DWORD *a1, int a2)
{
  int result; // eax
  int v3; // [esp+18h] [ebp-10h]
  int i; // [esp+1Ch] [ebp-Ch]
  int j; // [esp+1Ch] [ebp-Ch]
  int v6; // [esp+20h] [ebp-8h]

  result = LOWORD(a1[2 * a2 + 3]);
  v6 = result;
  if ( LOWORD(a1[2 * a2 + 3]) )
  {
    v3 = a1[2 * a2 + 4] & 3;
    if ( v3 )
    {
      if ( v3 == 3 )
        Com_Error(1, (char *)&byte_8149280);
      LOWORD(a1[2 * a2 + 4]) |= 4u;
      for ( i = 0; ; ++i )
      {
        result = i;
        if ( i >= v6 )
          break;
        sub_80BFD86(a1, i + HIWORD(a1[2 * a2 + 4]), v3 == 1);
      }
    }
    else
    {
      for ( j = 0; ; ++j )
      {
        result = j;
        if ( j >= v6 )
          break;
        sub_80BFF8E(a1, j + HIWORD(a1[2 * a2 + 4]));
      }
    }
  }
  return result;
}

//----- (080C006C) --------------------------------------------------------
int __cdecl sub_80C006C(_DWORD *a1)
{
  return sub_80BFF8E(a1, 0);
}

//----- (080C0088) --------------------------------------------------------
int __cdecl sub_80C0088(int a1, int a2)
{
  int v3; // [esp+0h] [ebp-8h]

  v3 = 0;
  if ( !*(_WORD *)(a1 + 8 * a2 + 12) || (*(_WORD *)(a1 + 8 * a2 + 16) & 3) != 0 )
    return 1;
  return v3;
}

//----- (080C00CA) --------------------------------------------------------
_BOOL4 __cdecl sub_80C00CA(int a1, int a2)
{
  return *(_WORD *)(a1 + 8 * a2 + 12) == 0;
}

//----- (080C00E2) --------------------------------------------------------
char *__cdecl sub_80C00E2(int a1, int a2, int a3)
{
  char *result; // eax
  unsigned __int16 v4; // [esp+Eh] [ebp-2h]

  result = (char *)*(unsigned __int16 *)(a1 + 2 * a2 + 8);
  v4 = *(_WORD *)(a1 + 2 * a2 + 8);
  if ( v4 )
  {
    result = (char *)&unk_8527A80 + 40 * v4;
    *((_DWORD *)result + 3) = a3;
    *((_WORD *)result + 10) = 0;
    *((_DWORD *)result + 4) = a3;
    *((_WORD *)result + 11) = 0;
    *((_WORD *)result + 1) = -1;
  }
  return result;
}

//----- (080C0164) --------------------------------------------------------
void __cdecl sub_80C0164(_DWORD *a1, float *a2, _WORD *a3)
{
  if ( a2[3] != 1.0 )
  {
    if ( *a3 )
    {
      if ( !*(_WORD *)a2 )
        return;
      a3 = (_WORD *)(*a1 + 8 * *(unsigned __int16 *)a2 + 12);
    }
    *((_WORD *)a2 + 1) = sub_80BBC06((int)a3, a2[3]);
  }
}

//----- (080C01C8) --------------------------------------------------------
int __cdecl sub_80C01C8(_DWORD *a1, int a2)
{
  int result; // eax
  int j; // [esp+14h] [ebp-14h]
  int v4; // [esp+18h] [ebp-10h]
  unsigned __int16 *v5; // [esp+1Ch] [ebp-Ch]
  int i; // [esp+20h] [ebp-8h]

  for ( i = a2; i; i = *(unsigned __int16 *)(*a1 + 8 * i + 14) )
  {
    v5 = (unsigned __int16 *)(*a1 + 8 * i + 12);
    if ( *v5 && (*(_WORD *)(*a1 + 8 * i + 16) & 4) != 0 )
    {
      result = sub_80BCA42((int)&unk_8527A80 + 40 * *((unsigned __int16 *)a1 + i + 4));
      if ( (_BYTE)result )
      {
        v4 = *v5;
        for ( j = 0; ; ++j )
        {
          result = j;
          if ( j >= v4 )
            break;
          sub_80BCAB4(a1, j + v5[3]);
        }
      }
      return result;
    }
  }
  result = *(unsigned __int16 *)(*a1 + 8 * a2 + 12);
  if ( !*(_WORD *)(*a1 + 8 * a2 + 12) )
    return sub_80BCA42(40 * *((unsigned __int16 *)a1 + a2 + 4) + 139623040);
  return result;
}

//----- (080C02D8) --------------------------------------------------------
int __cdecl sub_80C02D8(_DWORD *a1, int a2, int a3)
{
  int result; // eax
  int i; // [esp+24h] [ebp-4h]

  result = a2;
  for ( i = a2; i; result = sub_80BFB06(a1, i, 0.0, *(float *)&a3, 1065353216, 1, 0, 0) )
  {
    i = *(unsigned __int16 *)(*a1 + 8 * i + 14);
    result = i;
    if ( *((_WORD *)a1 + i + 4) )
      break;
  }
  return result;
}

//----- (080C0354) --------------------------------------------------------
int __cdecl sub_80C0354(_DWORD *a1, int a2, float a3, int a4, int a5, int a6, __int16 a7, int a8)
{
  int v9; // [esp+24h] [ebp-4h]

  if ( a3 < 0.001 )
    a3 = 0.0;
  v9 = sub_80BFB06(a1, a2, a3, *(float *)&a4, a5, 0, a6, a7);
  sub_80C02D8(a1, a2, a4);
  if ( a8 )
    sub_80C01C8(a1, a2);
  return v9;
}

//----- (080C03EA) --------------------------------------------------------
int __cdecl sub_80C03EA(int a1, int a2, int a3)
{
  return sub_80BFD38(a1, a2, a3);
}

//----- (080C040C) --------------------------------------------------------
int __cdecl sub_80C040C(int a1, int a2)
{
  if ( *(_WORD *)(a1 + 8 * a2 + 12) )
    return *(_WORD *)(a1 + 8 * a2 + 16) & 1;
  else
    return *(unsigned __int8 *)(*(_DWORD *)(a1 + 8 * a2 + 16) + 2);
}

//----- (080C044E) --------------------------------------------------------
int __cdecl sub_80C044E(int a1, int a2, int a3)
{
  int i; // [esp+4h] [ebp-10h]
  unsigned __int16 *v6; // [esp+8h] [ebp-Ch]
  int v7; // [esp+Ch] [ebp-8h]

  v7 = *(_DWORD *)(a1 + 8 * a2 + 16);
  v6 = *(unsigned __int16 **)(v7 + 28);
  if ( !v6 )
    return 0;
  for ( i = 0; i < *(unsigned __int8 *)(v7 + 12); ++i )
  {
    if ( *v6 == a3 )
      return 1;
    v6 += 4;
  }
  return 0;
}

//----- (080C04C6) --------------------------------------------------------
void __cdecl sub_80C04C6(_DWORD *a1, int a2, float a3, int a4, int a5, int a6, __int16 a7, int a8)
{
  int v8; // [esp+20h] [ebp-8h]

  if ( a3 < 0.001 )
    a3 = 0.0;
  sub_80BFB06(a1, a2, a3, *(float *)&a4, a5, 0, a6, a7);
  v8 = a2;
  while ( v8 )
  {
    v8 = *(unsigned __int16 *)(*a1 + 8 * v8 + 14);
    if ( !*((_WORD *)a1 + v8 + 4) || *(float *)&dword_8527A9C[10 * *((unsigned __int16 *)a1 + v8 + 4)] == 0.0 )
      sub_80BFB06(a1, v8, 1.0, *(float *)&a4, 1065353216, 0, 0, 0);
  }
  if ( a8 )
    sub_80C01C8(a1, a2);
}
// 8527A9C: using guessed type int dword_8527A9C[];

//----- (080C05DA) --------------------------------------------------------
int __cdecl sub_80C05DA(_DWORD *a1, _DWORD *a2)
{
  int result; // eax

  *a2 = *a1;
  a2[1] = a1[1];
  a2[2] = a1[2];
  a2[3] = a1[3];
  a2[4] = a1[4];
  a2[5] = a1[5];
  a2[6] = a1[6];
  a2[7] = a1[7];
  a2[8] = a1[8];
  a2[9] = a1[9];
  result = (int)a2;
  if ( *((_WORD *)a2 + 2) )
    return sub_807951E(*((unsigned __int16 *)a2 + 2));
  return result;
}

//----- (080C063C) --------------------------------------------------------
int __cdecl sub_80C063C(int a1, int a2)
{
  int result; // eax
  int v3; // [esp+8h] [ebp-10h]
  _DWORD *v4; // [esp+Ch] [ebp-Ch]
  int v5; // [esp+10h] [ebp-8h]
  int i; // [esp+14h] [ebp-4h]

  v3 = *(_DWORD *)(*(_DWORD *)a1 + 4);
  for ( i = 0; ; ++i )
  {
    result = i;
    if ( i >= v3 )
      break;
    v5 = *(unsigned __int16 *)(a1 + 2 * i + 8);
    if ( *(_WORD *)(a1 + 2 * i + 8) )
    {
      if ( *(_WORD *)(a2 + 2 * i + 8) )
      {
        v4 = (_DWORD *)((char *)&unk_8527A80 + 40 * *(unsigned __int16 *)(a2 + 2 * i + 8));
        sub_80BBA2E((int)v4);
      }
      else
      {
        v4 = (_DWORD *)sub_80BF2AE(a2, i);
      }
      sub_80C05DA((_DWORD *)(40 * v5 + 139623040), v4);
    }
    else if ( *(_WORD *)(a2 + 2 * i + 8) )
    {
      sub_80BBA62(a2, *(unsigned __int16 *)(a2 + 2 * i + 8));
      *(_WORD *)(a2 + 2 * i + 8) = 0;
    }
  }
  return result;
}

//----- (080C072E) --------------------------------------------------------
int __cdecl sub_80C072E(_DWORD *a1, int a2)
{
  int result; // eax

  *(_DWORD *)a2 = *a1;
  *(_DWORD *)(a2 + 4) = a1[1];
  *(_DWORD *)(a2 + 8) = a1[2];
  *(_DWORD *)(a2 + 12) = a1[3];
  *(_DWORD *)(a2 + 16) = a1[4];
  *(_DWORD *)(a2 + 20) = a1[5];
  *(_DWORD *)(a2 + 24) = a1[6];
  *(_DWORD *)(a2 + 28) = a1[7];
  *(_DWORD *)(a2 + 32) = a1[8];
  *(_DWORD *)(a2 + 36) = a1[9];
  *(_WORD *)a2 = 0;
  *(_WORD *)(a2 + 2) = -1;
  result = a2;
  *(_WORD *)(a2 + 4) = 0;
  return result;
}

//----- (080C078E) --------------------------------------------------------
int __cdecl sub_80C078E(int a1, int a2)
{
  int result; // eax
  int v3; // [esp+8h] [ebp-10h]
  int v4; // [esp+Ch] [ebp-Ch]
  unsigned __int16 v5; // [esp+12h] [ebp-6h]
  int i; // [esp+14h] [ebp-4h]

  v3 = *(_DWORD *)(*(_DWORD *)a1 + 4);
  for ( i = 0; ; ++i )
  {
    result = i;
    if ( i >= v3 )
      break;
    v5 = *(_WORD *)(a1 + 2 * i + 8);
    if ( v5 )
    {
      v4 = sub_80BF2AE(a2, i);
      sub_80C072E((_DWORD *)(40 * v5 + 139623040), v4);
    }
  }
  return result;
}

//----- (080C0820) --------------------------------------------------------
void __cdecl sub_80C0820(int a1, unsigned __int16 *a2, float a3, float *a4)
{
  float v4; // [esp+20h] [ebp-8h] BYREF
  int v5; // [esp+24h] [ebp-4h] BYREF

  if ( *a2 )
  {
    sub_80BB060(a1, (int)(a2 + 4), *a2, &v5, &v4);
    sub_80C13AA(
      a4,
      a3,
      (__int16 *)(*((_DWORD *)a2 + 1) + 4 * v5),
      (__int16 *)(*((_DWORD *)a2 + 1) + 4 * v5 + 4),
      v4,
      a4);
  }
  else
  {
    sub_80C150E(a4, a3, (__int16 *)a2 + 2, a4);
  }
}

//----- (080C08C6) --------------------------------------------------------
void __cdecl sub_80C08C6(int a1, unsigned __int16 *a2, float a3, float *a4)
{
  float v4; // [esp+20h] [ebp-8h] BYREF
  int v5; // [esp+24h] [ebp-4h] BYREF

  if ( *a2 )
  {
    sub_80BB060(a1, (int)(a2 + 4), *a2, &v5, &v4);
    sub_80C1422(
      a4,
      a3,
      (__int16 *)(*((_DWORD *)a2 + 1) + 8 * v5),
      (__int16 *)(*((_DWORD *)a2 + 1) + 8 * v5 + 8),
      v4,
      a4);
  }
  else
  {
    sub_80C1544(a4, a3, (__int16 *)a2 + 2, a4);
  }
}

//----- (080C096C) --------------------------------------------------------
void __cdecl sub_80C096C(int a1, unsigned __int16 *a2, float a3, float *a4)
{
  float v4; // [esp+20h] [ebp-8h] BYREF
  int v5; // [esp+24h] [ebp-4h] BYREF

  if ( *a2 )
  {
    sub_80BB060(a1, (int)(a2 + 4), *a2, &v5, &v4);
    sub_80C1608(a4, a3, (float *)(*((_DWORD *)a2 + 1) + 12 * v5), (float *)(*((_DWORD *)a2 + 1) + 12 * v5 + 12), v4, a4);
  }
  else
  {
    sub_80C11C4(a4, a3, (float *)a2 + 1, a4);
  }
}

//----- (080C0A1E) --------------------------------------------------------
int __cdecl sub_80C0A1E(unsigned __int16 *a1, int a2, int a3, float a4, int a5, int a6)
{
  int result; // eax
  int v7[4]; // [esp+10h] [ebp-38h] BYREF
  int v8; // [esp+20h] [ebp-28h]
  int v9; // [esp+24h] [ebp-24h]
  int v10; // [esp+28h] [ebp-20h]
  int v11; // [esp+2Ch] [ebp-1Ch]
  float v12; // [esp+30h] [ebp-18h]
  unsigned __int16 **v13; // [esp+34h] [ebp-14h]
  int i; // [esp+38h] [ebp-10h]
  int v15; // [esp+3Ch] [ebp-Ch]

  v9 = *a1;
  sub_80BAACE(*(float *)&a3, v9, (int)v7);
  v12 = a4 * 0.000030518509;
  v8 = *((_DWORD *)a1 + 5);
  v10 = (__int16)a1[7];
  for ( i = 0; ; ++i )
  {
    result = i;
    if ( i >= v10 )
      break;
    v11 = *(unsigned __int8 *)(a2 + i);
    if ( ((*(int *)(a6 + 4 * (v11 >> 5)) >> (v11 & 0x1F)) & 1) == 0 )
    {
      v15 = a5 + 32 * v11;
      v13 = (unsigned __int16 **)(*((_DWORD *)a1 + 6) + 8 * i);
      if ( ((*(char *)((i >> 3) + v8) >> (i & 7)) & 1) != 0 )
      {
        if ( v13[1] )
          sub_80C0820((int)v7, v13[1], v12, (float *)(v15 + 8));
        else
          *(float *)(v15 + 12) = *(float *)(v15 + 12) + a4;
      }
      else
      {
        sub_80C08C6((int)v7, v13[1], v12, (float *)v15);
      }
      if ( *v13 )
        sub_80C096C((int)v7, *v13, a4, (float *)(v15 + 16));
      *(float *)(v15 + 28) = *(float *)(v15 + 28) + a4;
    }
  }
  return result;
}

//----- (080C0B94) --------------------------------------------------------
void __cdecl sub_80C0B94(int a1, unsigned __int16 *a2, float a3, float *a4)
{
  float v4; // [esp+20h] [ebp-8h] BYREF
  int v5; // [esp+24h] [ebp-4h] BYREF

  if ( *a2 )
  {
    sub_80BB444(a1, (int)(a2 + 4), *a2, &v5, &v4);
    sub_80C13AA(
      a4,
      a3,
      (__int16 *)(*((_DWORD *)a2 + 1) + 4 * v5),
      (__int16 *)(*((_DWORD *)a2 + 1) + 4 * v5 + 4),
      v4,
      a4);
  }
  else
  {
    sub_80C150E(a4, a3, (__int16 *)a2 + 2, a4);
  }
}

//----- (080C0C3A) --------------------------------------------------------
void __cdecl sub_80C0C3A(int a1, unsigned __int16 *a2, float a3, float *a4)
{
  float v4; // [esp+20h] [ebp-8h] BYREF
  int v5; // [esp+24h] [ebp-4h] BYREF

  if ( *a2 )
  {
    sub_80BB444(a1, (int)(a2 + 4), *a2, &v5, &v4);
    sub_80C1422(
      a4,
      a3,
      (__int16 *)(*((_DWORD *)a2 + 1) + 8 * v5),
      (__int16 *)(*((_DWORD *)a2 + 1) + 8 * v5 + 8),
      v4,
      a4);
  }
  else
  {
    sub_80C1544(a4, a3, (__int16 *)a2 + 2, a4);
  }
}

//----- (080C0CE0) --------------------------------------------------------
void __cdecl sub_80C0CE0(int a1, unsigned __int16 *a2, float a3, float *a4)
{
  float v4; // [esp+20h] [ebp-8h] BYREF
  int v5; // [esp+24h] [ebp-4h] BYREF

  if ( *a2 )
  {
    sub_80BB444(a1, (int)(a2 + 4), *a2, &v5, &v4);
    sub_80C1608(a4, a3, (float *)(*((_DWORD *)a2 + 1) + 12 * v5), (float *)(*((_DWORD *)a2 + 1) + 12 * v5 + 12), v4, a4);
  }
  else
  {
    sub_80C11C4(a4, a3, (float *)a2 + 1, a4);
  }
}

//----- (080C0D92) --------------------------------------------------------
int __cdecl sub_80C0D92(unsigned __int16 *a1, int a2, int a3, float a4, int a5, int a6)
{
  int result; // eax
  int v7[4]; // [esp+10h] [ebp-38h] BYREF
  int v8; // [esp+20h] [ebp-28h]
  int v9; // [esp+24h] [ebp-24h]
  int v10; // [esp+28h] [ebp-20h]
  int v11; // [esp+2Ch] [ebp-1Ch]
  float v12; // [esp+30h] [ebp-18h]
  unsigned __int16 **v13; // [esp+34h] [ebp-14h]
  int i; // [esp+38h] [ebp-10h]
  int v15; // [esp+3Ch] [ebp-Ch]

  v9 = *a1;
  sub_80BAACE(*(float *)&a3, v9, (int)v7);
  v12 = a4 * 0.000030518509;
  v8 = *((_DWORD *)a1 + 5);
  v10 = (__int16)a1[7];
  for ( i = 0; ; ++i )
  {
    result = i;
    if ( i >= v10 )
      break;
    v11 = *(unsigned __int8 *)(a2 + i);
    if ( ((*(int *)(a6 + 4 * (v11 >> 5)) >> (v11 & 0x1F)) & 1) == 0 )
    {
      v15 = a5 + 32 * v11;
      v13 = (unsigned __int16 **)(*((_DWORD *)a1 + 6) + 8 * i);
      if ( ((*(char *)((i >> 3) + v8) >> (i & 7)) & 1) != 0 )
      {
        if ( v13[1] )
          sub_80C0B94((int)v7, v13[1], v12, (float *)(v15 + 8));
        else
          *(float *)(v15 + 12) = *(float *)(v15 + 12) + a4;
      }
      else
      {
        sub_80C0C3A((int)v7, v13[1], v12, (float *)v15);
      }
      if ( *v13 )
        sub_80C0CE0((int)v7, *v13, a4, (float *)(v15 + 16));
      *(float *)(v15 + 28) = *(float *)(v15 + 28) + a4;
    }
  }
  return result;
}

//----- (080C0F08) --------------------------------------------------------
long double __cdecl sub_80C0F08(float a1)
{
  return (float)fabs(a1);
}

//----- (080C0F22) --------------------------------------------------------
long double __cdecl sub_80C0F22(int a1)
{
  float v3; // [esp+Ch] [ebp-8h]

  v3 = *(float *)&a1 * 0.5;
  return (float)((1.5 - v3 * COERCE_FLOAT(1597463007 - (a1 >> 1)) * COERCE_FLOAT(1597463007 - (a1 >> 1)))
               * COERCE_FLOAT(1597463007 - (a1 >> 1)));
}

//----- (080C0F86) --------------------------------------------------------
int __cdecl sub_80C0F86(_DWORD *a1)
{
  int result; // eax

  *a1 = 0;
  result = 0;
  a1[1] = 0;
  return result;
}

//----- (080C0FA2) --------------------------------------------------------
int __cdecl sub_80C0FA2(_DWORD *a1, _DWORD *a2)
{
  int result; // eax

  *a2 = *a1;
  result = a1[1];
  a2[1] = result;
  return result;
}

//----- (080C0FC2) --------------------------------------------------------
float *__cdecl sub_80C0FC2(float *a1, float a2, float *a3)
{
  float *result; // eax

  *a3 = a2 * *a1;
  result = a1 + 1;
  a3[1] = a2 * a1[1];
  return result;
}

//----- (080C0FE8) --------------------------------------------------------
float *__cdecl sub_80C0FE8(float *a1, float a2, float *a3, float *a4)
{
  float *result; // eax

  *a4 = a2 * *a3 + *a1;
  result = a3 + 1;
  a4[1] = a2 * a3[1] + a1[1];
  return result;
}

//----- (080C101E) --------------------------------------------------------
long double __cdecl sub_80C101E(float *a1)
{
  return *a1 * *a1 + a1[1] * a1[1];
}

//----- (080C1040) --------------------------------------------------------
int __cdecl sub_80C1040(_DWORD *a1)
{
  int result; // eax

  *a1 = 0;
  a1[1] = 0;
  result = 0;
  a1[2] = 0;
  return result;
}

//----- (080C106A) --------------------------------------------------------
int __cdecl sub_80C106A(_DWORD *a1, _DWORD *a2)
{
  int result; // eax

  *a2 = *a1;
  a2[1] = a1[1];
  result = a1[2];
  a2[2] = result;
  return result;
}

//----- (080C109A) --------------------------------------------------------
float *__cdecl sub_80C109A(float *a1, float *a2, float *a3)
{
  float *result; // eax

  *a3 = *a1 + *a2;
  a3[1] = a1[1] + a2[1];
  result = a1 + 2;
  a3[2] = a1[2] + a2[2];
  return result;
}

//----- (080C10DE) --------------------------------------------------------
float *__cdecl sub_80C10DE(float *a1, float *a2, float *a3)
{
  float *result; // eax

  *a3 = *a1 - *a2;
  a3[1] = a1[1] - a2[1];
  result = a1 + 2;
  a3[2] = a1[2] - a2[2];
  return result;
}

//----- (080C1122) --------------------------------------------------------
float *__cdecl sub_80C1122(float *a1, float *a2, float a3, float *a4)
{
  float *result; // eax

  *a4 = (*a2 - *a1) * a3 + *a1;
  a4[1] = (a2[1] - a1[1]) * a3 + a1[1];
  result = a2 + 2;
  a4[2] = (a2[2] - a1[2]) * a3 + a1[2];
  return result;
}

//----- (080C118C) --------------------------------------------------------
float *__cdecl sub_80C118C(float *a1, float a2, float *a3)
{
  float *result; // eax

  *a3 = a2 * *a1;
  a3[1] = a2 * a1[1];
  result = a1 + 2;
  a3[2] = a2 * a1[2];
  return result;
}

//----- (080C11C4) --------------------------------------------------------
float *__cdecl sub_80C11C4(float *a1, float a2, float *a3, float *a4)
{
  float *result; // eax

  *a4 = a2 * *a3 + *a1;
  a4[1] = a2 * a3[1] + a1[1];
  result = a3 + 2;
  a4[2] = a2 * a3[2] + a1[2];
  return result;
}

//----- (080C1218) --------------------------------------------------------
int __cdecl sub_80C1218(_DWORD *a1)
{
  int result; // eax

  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  result = 0;
  a1[3] = 0;
  return result;
}

//----- (080C124E) --------------------------------------------------------
float *__cdecl sub_80C124E(float *a1, float a2, float *a3)
{
  float *result; // eax

  *a3 = a2 * *a1;
  a3[1] = a2 * a1[1];
  a3[2] = a2 * a1[2];
  result = a1 + 3;
  a3[3] = a2 * a1[3];
  return result;
}

//----- (080C129A) --------------------------------------------------------
float *__cdecl sub_80C129A(float *a1, float a2, float *a3, float *a4)
{
  float *result; // eax

  *a4 = a2 * *a3 + *a1;
  a4[1] = a2 * a3[1] + a1[1];
  a4[2] = a2 * a3[2] + a1[2];
  result = a3 + 3;
  a4[3] = a2 * a3[3] + a1[3];
  return result;
}

//----- (080C130A) --------------------------------------------------------
long double __cdecl sub_80C130A(float *a1)
{
  return *a1 * *a1 + a1[1] * a1[1] + a1[2] * a1[2] + a1[3] * a1[3];
}

//----- (080C1350) --------------------------------------------------------
float *__cdecl sub_80C1350(__int16 *a1, __int16 *a2, float a3, float *a4)
{
  long double v4; // fst7
  float *result; // eax

  *a4 = sub_80C16D4(*a1, *a2, a3);
  v4 = sub_80C16D4(a1[1], a2[1], a3);
  result = a4 + 1;
  a4[1] = v4;
  return result;
}

//----- (080C13AA) --------------------------------------------------------
void __cdecl sub_80C13AA(float *a1, float a2, __int16 *a3, __int16 *a4, float a5, float *a6)
{
  *a6 = sub_80C16D4(*a3, *a4, a5) * a2 + *a1;
  a6[1] = sub_80C16D4(a3[1], a4[1], a5) * a2 + a1[1];
}

//----- (080C1422) --------------------------------------------------------
void __cdecl sub_80C1422(float *a1, float a2, __int16 *a3, __int16 *a4, float a5, float *a6)
{
  *a6 = sub_80C16D4(*a3, *a4, a5) * a2 + *a1;
  a6[1] = sub_80C16D4(a3[1], a4[1], a5) * a2 + a1[1];
  a6[2] = sub_80C16D4(a3[2], a4[2], a5) * a2 + a1[2];
  a6[3] = sub_80C16D4(a3[3], a4[3], a5) * a2 + a1[3];
}

//----- (080C150E) --------------------------------------------------------
__int16 *__cdecl sub_80C150E(float *a1, float a2, __int16 *a3, float *a4)
{
  __int16 *result; // eax

  *a4 = (long double)*a3 * a2 + *a1;
  result = a3 + 1;
  a4[1] = (long double)a3[1] * a2 + a1[1];
  return result;
}

//----- (080C1544) --------------------------------------------------------
__int16 *__cdecl sub_80C1544(float *a1, float a2, __int16 *a3, float *a4)
{
  __int16 *result; // eax

  *a4 = (long double)*a3 * a2 + *a1;
  a4[1] = (long double)a3[1] * a2 + a1[1];
  a4[2] = (long double)a3[2] * a2 + a1[2];
  result = a3 + 3;
  a4[3] = (long double)a3[3] * a2 + a1[3];
  return result;
}

//----- (080C15B4) --------------------------------------------------------
__int16 *__cdecl sub_80C15B4(__int16 *a1, float a2, float *a3)
{
  __int16 *result; // eax

  *a3 = (long double)*a1 * a2;
  a3[1] = (long double)a1[1] * a2;
  a3[2] = (long double)a1[2] * a2;
  result = a1 + 3;
  a3[3] = (long double)a1[3] * a2;
  return result;
}

//----- (080C1608) --------------------------------------------------------
void __cdecl sub_80C1608(float *a1, float a2, float *a3, float *a4, float a5, float *a6)
{
  *a6 = sub_80C1706(*a3, *a4, a5) * a2 + *a1;
  a6[1] = sub_80C1706(a3[1], a4[1], a5) * a2 + a1[1];
  a6[2] = sub_80C1706(a3[2], a4[2], a5) * a2 + a1[2];
}

//----- (080C16B4) --------------------------------------------------------
__int16 *__cdecl sub_80C16B4(__int16 *a1, float *a2)
{
  __int16 *result; // eax

  *a2 = (float)*a1;
  result = a1 + 1;
  a2[1] = (float)a1[1];
  return result;
}

//----- (080C16D4) --------------------------------------------------------
long double __cdecl sub_80C16D4(__int16 a1, __int16 a2, float a3)
{
  return (long double)a1 + (long double)(a2 - a1) * a3;
}

//----- (080C1706) --------------------------------------------------------
long double __cdecl sub_80C1706(float a1, float a2, float a3)
{
  return (a2 - a1) * a3 + a1;
}

//----- (080C1718) --------------------------------------------------------
int __cdecl sub_80C1718(const void **a1, __int16 *a2)
{
  long double v2; // fst7
  int result; // eax
  float v4; // [esp+0h] [ebp-38h]
  int v5; // [esp+10h] [ebp-28h]
  int v6; // [esp+1Ch] [ebp-1Ch]

  *a2 = sub_80C2C9E(a1);
  a2[1] = sub_80C2C9E(a1);
  a2[2] = sub_80C2C9E(a1);
  v6 = 1073676289 - (a2[2] * a2[2] + a2[1] * a2[1] + *a2 * *a2);
  if ( v6 <= 0 )
  {
    v5 = 0;
  }
  else
  {
    v4 = (float)v6;
    v2 = sub_80C2C4E(v4);
    v5 = (int)floor(v2 + 0.5);
  }
  result = v5;
  a2[3] = v5;
  return result;
}

//----- (080C17FA) --------------------------------------------------------
int __cdecl sub_80C17FA(const void **a1, __int16 *a2)
{
  long double v2; // fst7
  int result; // eax
  float v4; // [esp+0h] [ebp-28h]
  int v5; // [esp+10h] [ebp-18h]
  int v6; // [esp+1Ch] [ebp-Ch]

  *a2 = sub_80C2C9E(a1);
  v6 = 1073676289 - *a2 * *a2;
  if ( v6 <= 0 )
  {
    v5 = 0;
  }
  else
  {
    v4 = (float)v6;
    v2 = sub_80C2C4E(v4);
    v5 = (int)floor(v2 + 0.5);
  }
  result = v5;
  a2[1] = v5;
  return result;
}

//----- (080C1886) --------------------------------------------------------
int __cdecl sub_80C1886(int a1, char **a2, unsigned __int16 *a3, int (__cdecl *a4)(int))
{
  int result; // eax
  float v5; // [esp+18h] [ebp-20h]
  float v6; // [esp+18h] [ebp-20h]
  int v7; // [esp+20h] [ebp-18h]
  int v8; // [esp+24h] [ebp-14h]
  int i; // [esp+28h] [ebp-10h]
  int v10; // [esp+2Ch] [ebp-Ch]

  v10 = (unsigned __int8)*(*a2)++;
  *((_BYTE *)a3 + 12) = v10 + 1;
  v7 = a4(8 * *((unsigned __int8 *)a3 + 12));
  *((_DWORD *)a3 + 7) = v7;
  for ( i = 0; i < v10; ++i )
  {
    *(_WORD *)v7 = SL_GetString(*a2, 0);
    *a2 += strlen(*a2) + 1;
    v8 = (unsigned __int16)sub_80C2CD4((const void **)a2);
    if ( *a3 )
    {
      v5 = (float)v8;
      v6 = v5 / (long double)*a3;
    }
    else
    {
      v6 = 0.0;
    }
    *(float *)(v7 + 4) = v6;
    v7 += 8;
  }
  *(_WORD *)v7 = SL_GetString("end", 0);
  result = 1065353216;
  *(_DWORD *)(v7 + 4) = 1065353216;
  return result;
}

//----- (080C19AE) --------------------------------------------------------
unsigned __int16 *__cdecl sub_80C19AE(const char *a1, int (__cdecl *a2)(int))
{
  _WORD **v2; // ebx
  _WORD **v3; // ebx
  _WORD **v4; // ebx
  _WORD *v5; // ebx
  _DWORD *v6; // ebx
  _DWORD *v7; // ebx
  _DWORD *v8; // ebx
  _WORD *v9; // ebx
  long double v10; // fst7
  long double v11; // fst7
  long double v12; // fst7
  unsigned __int16 *v13; // ebx
  int v14; // ebx
  int v15; // esi
  _DWORD *v16; // ebx
  _DWORD *v17; // ebx
  _DWORD *v18; // ebx
  _DWORD *v19; // ebx
  int v20; // ebx
  int v21; // ebx
  _DWORD *v22; // ebx
  _DWORD *v23; // ebx
  _DWORD *v24; // ebx
  int v25; // ebx
  long double v26; // fst7
  long double v27; // fst7
  long double v28; // fst7
  float v30; // [esp+10h] [ebp-D8h]
  unsigned __int16 v31; // [esp+1Ah] [ebp-CEh]
  int v32; // [esp+1Ch] [ebp-CCh]
  char v34; // [esp+26h] [ebp-C2h]
  char v35; // [esp+27h] [ebp-C1h]
  char *dest; // [esp+28h] [ebp-C0h]
  __int16 *v37; // [esp+30h] [ebp-B8h]
  __int16 *v38; // [esp+34h] [ebp-B4h]
  __int16 *v39; // [esp+34h] [ebp-B4h]
  __int16 *v40; // [esp+34h] [ebp-B4h]
  int i; // [esp+38h] [ebp-B0h]
  int j; // [esp+38h] [ebp-B0h]
  int k; // [esp+38h] [ebp-B0h]
  int ii; // [esp+38h] [ebp-B0h]
  int jj; // [esp+38h] [ebp-B0h]
  int kk; // [esp+38h] [ebp-B0h]
  int mm; // [esp+38h] [ebp-B0h]
  int nn; // [esp+38h] [ebp-B0h]
  int n; // [esp+3Ch] [ebp-ACh]
  int na; // [esp+3Ch] [ebp-ACh]
  int nb; // [esp+3Ch] [ebp-ACh]
  float v52; // [esp+40h] [ebp-A8h] BYREF
  float v53; // [esp+44h] [ebp-A4h]
  float v54; // [esp+48h] [ebp-A0h]
  int v55; // [esp+50h] [ebp-98h] BYREF
  int v56; // [esp+54h] [ebp-94h]
  bool v57; // [esp+5Fh] [ebp-89h]
  unsigned __int16 v58; // [esp+60h] [ebp-88h]
  unsigned __int16 v59; // [esp+62h] [ebp-86h]
  bool v60; // [esp+65h] [ebp-83h]
  char v61; // [esp+66h] [ebp-82h]
  char v62; // [esp+67h] [ebp-81h]
  __int16 v63; // [esp+68h] [ebp-80h]
  __int16 v64; // [esp+6Ah] [ebp-7Eh]
  size_t v65; // [esp+6Ch] [ebp-7Ch]
  char s[68]; // [esp+70h] [ebp-78h] BYREF
  int m; // [esp+B4h] [ebp-34h]
  unsigned __int8 *v68; // [esp+B8h] [ebp-30h]
  void *src; // [esp+BCh] [ebp-2Ch] BYREF
  _DWORD *v70; // [esp+C0h] [ebp-28h] BYREF
  _WORD **v71; // [esp+C4h] [ebp-24h]
  _DWORD *v72; // [esp+C8h] [ebp-20h]
  unsigned __int16 v73; // [esp+CEh] [ebp-1Ah]
  unsigned __int16 v74; // [esp+D0h] [ebp-18h]
  signed __int16 v75; // [esp+D2h] [ebp-16h]
  unsigned __int16 *v76; // [esp+D4h] [ebp-14h]
  int v77; // [esp+D8h] [ebp-10h]
  int v78; // [esp+DCh] [ebp-Ch]

  if ( Com_sprintf(s, 0x40u, "xanim/%s", a1) >= 0 )
  {
    v78 = FS_ReadFile(s, &v70);
    if ( v78 >= 0 )
    {
      if ( v78 )
      {
        src = v70;
        v63 = sub_80C2C9E((const void **)&src);
        if ( v63 == 14 )
        {
          v74 = sub_80C2C9E((const void **)&src);
          v75 = sub_80C2C9E((const void **)&src);
          if ( v75 )
            v32 = a2(2 * v75);
          else
            v32 = 0;
          v77 = v32;
          v62 = *(_BYTE *)src;
          src = (char *)src + 1;
          v61 = v62 & 1;
          v60 = (v62 & 2) != 0;
          v64 = sub_80C2C9E((const void **)&src);
          v76 = (unsigned __int16 *)a2(44);
          v76[7] = v75;
          *((_DWORD *)v76 + 4) = v77;
          *((float *)v76 + 1) = (float)v64;
          *((_BYTE *)v76 + 2) = v61;
          *((_BYTE *)v76 + 3) = v60;
          if ( v61 )
            v31 = v74 + 1;
          else
            v31 = v74;
          v73 = v31;
          v57 = v31 <= 0x100u;
          *v76 = v31 - 1;
          if ( *v76 )
            v30 = *((float *)v76 + 1) / (long double)*v76;
          else
            v30 = 0.0;
          *((float *)v76 + 2) = v30;
          if ( v60 )
          {
            v71 = (_WORD **)a2(8);
            *((_DWORD *)v76 + 8) = v71;
            v59 = sub_80C2CD4((const void **)&src);
            if ( v59 )
            {
              if ( v59 == 1 )
              {
                sub_80C17FA((const void **)&src, (__int16 *)&v55);
                v2 = v71;
                v2[1] = (_WORD *)a2(8);
                *v71[1] = 0;
                *((_DWORD *)v71[1] + 1) = v55;
              }
              else
              {
                if ( v59 >= v73 )
                {
                  v4 = v71;
                  v4[1] = (_WORD *)a2(8);
                }
                else
                {
                  v3 = v71;
                  if ( v57 )
                  {
                    v3[1] = (_WORD *)a2(v59 + 8);
                    memcpy(v71[1] + 4, src, v59);
                    src = (char *)src + v59;
                  }
                  else
                  {
                    v3[1] = (_WORD *)a2(2 * v59 + 8);
                    memcpy(v71[1] + 4, src, 2 * v59);
                    src = (char *)src + 2 * v59;
                  }
                }
                *v71[1] = v59 - 1;
                v5 = v71[1];
                *((_DWORD *)v5 + 1) = a2(4 * v59);
                for ( i = 0; i < v59; ++i )
                {
                  sub_80C17FA((const void **)&src, (__int16 *)&v55);
                  *(_DWORD *)(*((_DWORD *)v71[1] + 1) + 4 * i) = v55;
                }
                for ( j = 1; j < v59; ++j )
                {
                  v38 = (__int16 *)(*((_DWORD *)v71[1] + 1) + 4 * j);
                  if ( v38[1] * *(v38 - 1) + *(v38 - 2) * *v38 < 0 )
                  {
                    *v38 = -*v38;
                    v38[1] = -v38[1];
                  }
                }
              }
            }
            else
            {
              v71[1] = 0;
            }
            v58 = sub_80C2CD4((const void **)&src);
            if ( v58 )
            {
              if ( v58 == 1 )
              {
                v52 = sub_80C2D0A((const void **)&src);
                v53 = sub_80C2D0A((const void **)&src);
                v54 = sub_80C2D0A((const void **)&src);
                v6 = v71;
                *v6 = a2(16);
                **v71 = 0;
                sub_80C2C6E(&v52, (_DWORD *)*v71 + 1);
              }
              else
              {
                if ( v58 >= v73 )
                {
                  v8 = v71;
                  *v8 = a2(8);
                }
                else
                {
                  v7 = v71;
                  if ( v57 )
                  {
                    *v7 = a2(v58 + 8);
                    n = v58;
                    memcpy(*v71 + 4, src, v58);
                  }
                  else
                  {
                    *v7 = a2(2 * v58 + 8);
                    n = 2 * v58;
                    memcpy(*v71 + 4, src, n);
                  }
                  src = (char *)src + n;
                }
                **v71 = v58 - 1;
                v9 = *v71;
                *((_DWORD *)v9 + 1) = a2(12 * v58);
                for ( k = 0; k < v58; ++k )
                {
                  v10 = sub_80C2D0A((const void **)&src);
                  *(float *)(*((_DWORD *)*v71 + 1) + 12 * k) = v10;
                  v11 = sub_80C2D0A((const void **)&src);
                  *(float *)(*((_DWORD *)*v71 + 1) + 12 * k + 4) = v11;
                  v12 = sub_80C2D0A((const void **)&src);
                  *(float *)(*((_DWORD *)*v71 + 1) + 12 * k + 8) = v12;
                }
              }
            }
            else
            {
              *v71 = 0;
            }
          }
          if ( v75 )
          {
            v65 = ((v75 - 1) >> 3) + 1;
            v68 = (unsigned __int8 *)src;
            src = (char *)src + v65;
            dest = (char *)a2(v65);
            memcpy(dest, src, v65);
            src = (char *)src + v65;
            *((_DWORD *)v76 + 5) = dest;
            v13 = v76;
            *((_DWORD *)v13 + 6) = a2(8 * v75);
          }
          else
          {
            v68 = 0;
            dest = 0;
          }
          for ( m = 0; m < v75; ++m )
          {
            v65 = strlen((const char *)src) + 1;
            v14 = 2 * m;
            v15 = v77;
            *(_WORD *)(v15 + v14) = SL_GetStringOfLen((char *)src, 0, v65);
            src = (char *)src + v65;
          }
          for ( m = 0; m < v75; ++m )
          {
            v35 = ((int)v68[m >> 3] >> (m & 7)) & 1;
            v34 = (dest[m >> 3] >> (m & 7)) & 1;
            v72 = (_DWORD *)(*((_DWORD *)v76 + 6) + 8 * m);
            v59 = sub_80C2CD4((const void **)&src);
            if ( v59 )
            {
              if ( v59 == 1 )
              {
                if ( v34 )
                {
                  sub_80C17FA((const void **)&src, (__int16 *)&v55);
                  if ( v35 )
                  {
                    LOWORD(v55) = -(__int16)v55;
                    HIWORD(v55) = -HIWORD(v55);
                  }
                  v16 = v72;
                  v16[1] = a2(8);
                  *(_DWORD *)(v72[1] + 4) = v55;
                }
                else
                {
                  sub_80C1718((const void **)&src, (__int16 *)&v55);
                  if ( v35 )
                  {
                    LOWORD(v55) = -(__int16)v55;
                    HIWORD(v55) = -HIWORD(v55);
                    LOWORD(v56) = -(__int16)v56;
                    HIWORD(v56) = -HIWORD(v56);
                  }
                  v17 = v72;
                  v17[1] = a2(12);
                  *(_DWORD *)(v72[1] + 4) = v55;
                  *(_DWORD *)(v72[1] + 8) = v56;
                }
                *(_WORD *)v72[1] = 0;
              }
              else
              {
                if ( v59 >= v73 )
                {
                  v19 = v72;
                  v19[1] = a2(8);
                }
                else
                {
                  v18 = v72;
                  if ( v57 )
                  {
                    v18[1] = a2(v59 + 8);
                    na = v59;
                    memcpy((void *)(v72[1] + 8), src, v59);
                  }
                  else
                  {
                    v18[1] = a2(2 * v59 + 8);
                    na = 2 * v59;
                    memcpy((void *)(v72[1] + 8), src, na);
                  }
                  src = (char *)src + na;
                }
                if ( v34 )
                {
                  v20 = v72[1];
                  *(_DWORD *)(v20 + 4) = a2(4 * v59);
                  sub_80C17FA((const void **)&src, (__int16 *)&v55);
                  if ( v35 )
                  {
                    LOWORD(v55) = -(__int16)v55;
                    HIWORD(v55) = -HIWORD(v55);
                  }
                  **(_DWORD **)(v72[1] + 4) = v55;
                  for ( ii = 1; ii < v59; ++ii )
                  {
                    sub_80C17FA((const void **)&src, (__int16 *)&v55);
                    *(_DWORD *)(*(_DWORD *)(v72[1] + 4) + 4 * ii) = v55;
                  }
                  for ( jj = 1; jj < v59; ++jj )
                  {
                    v39 = (__int16 *)(*(_DWORD *)(v72[1] + 4) + 4 * jj);
                    if ( v39[1] * *(v39 - 1) + *(v39 - 2) * *v39 < 0 )
                    {
                      *v39 = -*v39;
                      v39[1] = -v39[1];
                    }
                  }
                }
                else
                {
                  v21 = v72[1];
                  *(_DWORD *)(v21 + 4) = a2(8 * v59);
                  sub_80C1718((const void **)&src, (__int16 *)&v55);
                  if ( v35 )
                  {
                    LOWORD(v55) = -(__int16)v55;
                    HIWORD(v55) = -HIWORD(v55);
                    LOWORD(v56) = -(__int16)v56;
                    HIWORD(v56) = -HIWORD(v56);
                  }
                  **(_DWORD **)(v72[1] + 4) = v55;
                  *(_DWORD *)(*(_DWORD *)(v72[1] + 4) + 4) = v56;
                  for ( kk = 1; kk < v59; ++kk )
                  {
                    sub_80C1718((const void **)&src, (__int16 *)&v55);
                    *(_DWORD *)(*(_DWORD *)(v72[1] + 4) + 8 * kk) = v55;
                    *(_DWORD *)(*(_DWORD *)(v72[1] + 4) + 8 * kk + 4) = v56;
                  }
                  for ( mm = 1; mm < v59; ++mm )
                  {
                    v40 = (__int16 *)(*(_DWORD *)(v72[1] + 4) + 8 * mm);
                    v37 = v40 - 4;
                    if ( v40[1] * v37[1] + *v37 * *v40 + v40[3] * v37[3] + v37[2] * v40[2] < 0 )
                    {
                      *v40 = -*v40;
                      v40[1] = -v40[1];
                      v40[2] = -v40[2];
                      v40[3] = -v40[3];
                    }
                  }
                }
                *(_WORD *)v72[1] = v59 - 1;
              }
            }
            else
            {
              v72[1] = 0;
            }
            v58 = sub_80C2CD4((const void **)&src);
            if ( v58 )
            {
              if ( v58 == 1 )
              {
                v52 = sub_80C2D0A((const void **)&src);
                v53 = sub_80C2D0A((const void **)&src);
                v54 = sub_80C2D0A((const void **)&src);
                v22 = v72;
                *v22 = a2(16);
                *(_WORD *)*v72 = 0;
                sub_80C2C6E(&v52, (_DWORD *)(*v72 + 4));
              }
              else
              {
                if ( v58 >= v73 )
                {
                  v24 = v72;
                  *v24 = a2(8);
                }
                else
                {
                  v23 = v72;
                  if ( v57 )
                  {
                    *v23 = a2(v58 + 8);
                    nb = v58;
                    memcpy((void *)(*v72 + 8), src, v58);
                  }
                  else
                  {
                    *v23 = a2(2 * v58 + 8);
                    nb = 2 * v58;
                    memcpy((void *)(*v72 + 8), src, nb);
                  }
                  src = (char *)src + nb;
                }
                *(_WORD *)*v72 = v58 - 1;
                v25 = *v72;
                *(_DWORD *)(v25 + 4) = a2(12 * v58);
                for ( nn = 0; nn < v58; ++nn )
                {
                  v26 = sub_80C2D0A((const void **)&src);
                  *(float *)(*(_DWORD *)(*v72 + 4) + 12 * nn) = v26;
                  v27 = sub_80C2D0A((const void **)&src);
                  *(float *)(*(_DWORD *)(*v72 + 4) + 12 * nn + 4) = v27;
                  v28 = sub_80C2D0A((const void **)&src);
                  *(float *)(*(_DWORD *)(*v72 + 4) + 12 * nn + 8) = v28;
                }
              }
            }
            else
            {
              *v72 = 0;
            }
          }
          sub_80C1886((int)a1, (char **)&src, v76, a2);
          FS_FreeFile(v70);
          return v76;
        }
        else
        {
          FS_FreeFile(v70);
          Com_Printf("^1ERROR: xanim '%s' out of date (version %d, expecting %d)\n", a1, v63, 14);
          return 0;
        }
      }
      else
      {
        Com_Printf("^1ERROR: xanim '%s' has 0 length\n", a1);
        FS_FreeFile(v70);
        return 0;
      }
    }
    else
    {
      Com_Printf("^1ERROR: xanim '%s' not found\n", a1);
      return 0;
    }
  }
  else
  {
    Com_Printf("^1ERROR: filename '%s' too long\n", s);
    return 0;
  }
}
// 80C19AE: using guessed type const char *arg_0;

//----- (080C2C4E) --------------------------------------------------------
long double __cdecl sub_80C2C4E(float a1)
{
  return (float)sqrt(a1);
}

//----- (080C2C6E) --------------------------------------------------------
int __cdecl sub_80C2C6E(_DWORD *a1, _DWORD *a2)
{
  int result; // eax

  *a2 = *a1;
  a2[1] = a1[1];
  result = a1[2];
  a2[2] = result;
  return result;
}

//----- (080C2C9E) --------------------------------------------------------
int __cdecl sub_80C2C9E(const void **a1)
{
  __int16 dest; // [esp+16h] [ebp-2h] BYREF

  memcpy(&dest, *a1, sizeof(dest));
  *a1 = (char *)*a1 + 2;
  return dest;
}

//----- (080C2CD4) --------------------------------------------------------
int __cdecl sub_80C2CD4(const void **a1)
{
  unsigned __int16 dest; // [esp+16h] [ebp-2h] BYREF

  memcpy(&dest, *a1, sizeof(dest));
  *a1 = (char *)*a1 + 2;
  return dest;
}

//----- (080C2D0A) --------------------------------------------------------
long double __cdecl sub_80C2D0A(const void **a1)
{
  float dest; // [esp+14h] [ebp-4h] BYREF

  memcpy(&dest, *a1, sizeof(dest));
  *a1 = (char *)*a1 + 4;
  return dest;
}

//----- (080C2D44) --------------------------------------------------------
int __cdecl XModelBad(int a1)
{
  return *(unsigned __int8 *)(a1 + 141);
}

//----- (080C2D62) --------------------------------------------------------
int __cdecl XModelPartsFree(__int16 *a1)
{
  int result; // eax
  int v2; // [esp+8h] [ebp-10h]
  int i; // [esp+Ch] [ebp-Ch]
  int v4; // [esp+10h] [ebp-8h]

  v4 = **((_DWORD **)a1 + 1);
  v2 = *a1;
  for ( i = 0; ; ++i )
  {
    result = i;
    if ( i >= v2 )
      break;
    SL_RemoveRefToString(*(unsigned __int16 *)(v4 + 2 * i));
  }
  return result;
}

//----- (080C2DB2) --------------------------------------------------------
int *__cdecl XModelFree(int a1)
{
  int *result; // eax
  int j; // [esp+10h] [ebp-8h]
  int i; // [esp+14h] [ebp-4h] BYREF

  result = (int *)XModelBad(a1);
  if ( !result )
  {
    for ( i = 0; i <= 3; ++i )
    {
      if ( *(_DWORD *)(a1 + 20 * i + 16) )
      {
        for ( j = 0; j < *(__int16 *)(a1 + 20 * i + 12); ++j )
          SL_RemoveRefToString(*(unsigned __int16 *)(*(_DWORD *)(a1 + 20 * i + 16) + 2 * j));
        *(_DWORD *)(a1 + 20 * i + 16) = 0;
      }
      result = &i;
    }
  }
  return result;
}

//----- (080C2E74) --------------------------------------------------------
void *sub_80C2E74()
{
  dword_85500C4[0] = word_85500C0;
  *((_DWORD *)&unk_85500CC + 1) = dword_85500C4;
  *((_DWORD *)&unk_85500CC + 2) = 0;
  *((_DWORD *)&unk_85500CC + 3) = 0;
  unk_85500CC = 1;
  *((_WORD *)&unk_85500CC + 1) = 1;
  *((_DWORD *)&unk_85500CC + 4) = &byte_855016C;
  byte_855016C = 0;
  word_85500C0[0] = 0;
  return &unk_85500CC;
}
// 85500C0: using guessed type _WORD word_85500C0[2];
// 85500C4: using guessed type _DWORD dword_85500C4[2];
// 855016C: using guessed type char byte_855016C;

//----- (080C2EF2) --------------------------------------------------------
_DWORD *sub_80C2EF2()
{
  dword_8550130[0] = 0;
  return dword_8550130;
}
// 8550130: using guessed type _DWORD dword_8550130[5];

//----- (080C2F0E) --------------------------------------------------------
_DWORD *__cdecl sub_80C2F0E(int a1)
{
  _DWORD *result; // eax
  int i; // [esp+10h] [ebp-8h]

  *(_BYTE *)(a1 + 141) = 1;
  *(_DWORD *)a1 = sub_80C2E74();
  for ( i = 0; i <= 3; ++i )
  {
    *(_DWORD *)(a1 + 20 * i + 20) = 0;
    *(_DWORD *)(a1 + 20 * i + 8) = &unk_81493E0;
    *(_DWORD *)(a1 + 20 * i + 4) = 0;
    *(_WORD *)(a1 + 20 * i + 12) = 1;
    *(_DWORD *)(a1 + 20 * i + 16) = &word_855016E;
    word_855016E = 0;
  }
  *(_DWORD *)(a1 + 20) = sub_80C2EF2();
  *(_WORD *)(a1 + 124) = 1;
  *(_WORD *)(a1 + 126) = 0;
  *(_DWORD *)(a1 + 136) = "DEFAULT";
  dword_8550144[0] = -1048576000;
  dword_8550144[1] = -1048576000;
  dword_8550144[2] = -1048576000;
  dword_8550144[3] = 1098907648;
  dword_8550144[4] = 1098907648;
  dword_8550144[5] = 1098907648;
  result = dword_8550144;
  *(_DWORD *)(a1 + 96) = dword_8550144;
  return result;
}
// 8550144: using guessed type _DWORD dword_8550144[10];
// 855016E: using guessed type __int16 word_855016E;

//----- (080C306A) --------------------------------------------------------
int __cdecl sub_80C306A(int (__cdecl *a1)(int))
{
  int v2; // [esp+4h] [ebp-4h]

  v2 = a1(144);
  sub_80C2F0E(v2);
  return v2;
}

//----- (080C3090) --------------------------------------------------------
int __cdecl sub_80C3090(char *s2)
{
  return Hunk_FindDataForFile(3, s2);
}

//----- (080C30AC) --------------------------------------------------------
int __cdecl sub_80C30AC(char *src, int a2, int (__cdecl *a3)(size_t))
{
  return Hunk_SetDataForFile(3, src, a2, a3);
}

//----- (080C30D6) --------------------------------------------------------
int __cdecl sub_80C30D6(char *s2)
{
  return Hunk_FindDataForFile(2, s2);
}

//----- (080C30F2) --------------------------------------------------------
int __cdecl sub_80C30F2(char *src, int a2, int (__cdecl *a3)(size_t))
{
  return Hunk_SetDataForFile(2, src, a2, a3);
}

//----- (080C311C) --------------------------------------------------------
int __cdecl sub_80C311C(char *s2)
{
  return Hunk_FindDataForFile(4, s2);
}

//----- (080C3138) --------------------------------------------------------
int __cdecl sub_80C3138(char *src, int (__cdecl *a2)(int))
{
  int v3; // [esp+14h] [ebp-4h]

  v3 = sub_80C306A(a2);
  Hunk_SetDataForFile(4, src, v3, (int (__cdecl *)(size_t))a2);
  return v3;
}

//----- (080C3172) --------------------------------------------------------
int *__cdecl sub_80C3172(_DWORD *a1, const void *a2)
{
  int *result; // eax
  int *v3; // [esp+14h] [ebp-14h]
  int j; // [esp+18h] [ebp-10h]
  int i; // [esp+1Ch] [ebp-Ch] BYREF

  if ( XModelBad((int)a2) )
    Com_Error(1, "Could not load replacement model.");
  v3 = (int *)a1[34];
  XModelFree((int)a1);
  qmemcpy(a1, a2, 0x90u);
  result = v3;
  a1[34] = v3;
  for ( i = 0; i <= 3; ++i )
  {
    if ( a1[5 * i + 4] )
    {
      for ( j = 0; j < SLOWORD(a1[5 * i + 3]); ++j )
        sub_807951E(*(unsigned __int16 *)(a1[5 * i + 4] + 2 * j));
    }
    result = &i;
  }
  return result;
}

//----- (080C3264) --------------------------------------------------------
int __cdecl XModelPrecache(char *s2, int (__cdecl *a2)(int), int (__cdecl *a3)(int))
{
  int v5; // [esp+20h] [ebp-8h]
  int v6; // [esp+20h] [ebp-8h]

  v5 = Hunk_FindDataForFile(4, s2);
  if ( v5 )
    return v5;
  v6 = XModelLoad(s2, a2, a3);
  if ( v6 )
  {
    *(_DWORD *)(v6 + 136) = Hunk_SetDataForFile(4, s2, v6, (int (__cdecl *)(size_t))a2);
    return v6;
  }
  else
  {
    Com_Printf("^1ERROR: Cannot find xmodel '%s'.\n", s2);
    return sub_80C3138(s2, a2);
  }
}

//----- (080C3314) --------------------------------------------------------
int __cdecl sub_80C3314(int a1)
{
  return **(_DWORD **)(*(_DWORD *)a1 + 4);
}

//----- (080C3324) --------------------------------------------------------
int __cdecl sub_80C3324(__int16 **a1, int a2)
{
  int i; // [esp+10h] [ebp-4h]

  for ( i = **a1 - 1; i >= 0 && a2 != *(unsigned __int16 *)(**((_DWORD **)*a1 + 1) + 2 * i); --i )
    ;
  return i;
}

//----- (080C337C) --------------------------------------------------------
int __cdecl sub_80C337C(int a1, _DWORD *a2, _DWORD *a3)
{
  sub_80C38AC((_DWORD *)(a1 + 100), a2);
  return sub_80C38AC((_DWORD *)(a1 + 112), a3);
}

//----- (080C33CA) --------------------------------------------------------
int __cdecl sub_80C33CA(int a1)
{
  return *(_DWORD *)(a1 + 92);
}

//----- (080C33FE) --------------------------------------------------------
int __cdecl sub_80C33FE(int a1, int a2, int a3, float *a4, float *a5, int a6)
{
  long double v6; // fst7
  long double v7; // fst7
  long double v8; // fst7
  long double v9; // fst7
  long double v10; // fst7
  float v13[12]; // [esp+20h] [ebp-F8h] BYREF
  float v14[4]; // [esp+50h] [ebp-C8h] BYREF
  int j; // [esp+60h] [ebp-B8h]
  int i; // [esp+64h] [ebp-B4h]
  float v17; // [esp+68h] [ebp-B0h]
  float v18; // [esp+6Ch] [ebp-ACh]
  float v19; // [esp+70h] [ebp-A8h]
  float v20; // [esp+74h] [ebp-A4h]
  float v21; // [esp+78h] [ebp-A0h]
  float v22; // [esp+7Ch] [ebp-9Ch]
  int v23[4]; // [esp+80h] [ebp-98h] BYREF
  int v24[5]; // [esp+90h] [ebp-88h] BYREF
  float *v25; // [esp+A4h] [ebp-74h]
  _DWORD *v26; // [esp+A8h] [ebp-70h]
  int v27; // [esp+ACh] [ebp-6Ch]
  int v28[3]; // [esp+B0h] [ebp-68h] BYREF
  float v29[9]; // [esp+BCh] [ebp-5Ch] BYREF
  float v30[4]; // [esp+E0h] [ebp-38h] BYREF
  float v31[5]; // [esp+F0h] [ebp-28h] BYREF
  float *v32; // [esp+104h] [ebp-14h]
  int v33; // [esp+108h] [ebp-10h]
  int v34; // [esp+10Ch] [ebp-Ch]

  v27 = -1;
  v33 = sub_80C54CE((__int16 **)a1);
  for ( i = 0; i < *(_DWORD *)(a1 + 88); ++i )
  {
    v26 = (_DWORD *)(*(_DWORD *)(a1 + 84) + 44 * i);
    if ( (v26[9] & a6) != 0 )
    {
      v34 = v26[8];
      v32 = (float *)(a3 + 32 * v34);
      sub_80C38DC(a4, v32 + 4, v31);
      sub_80C38DC(a5, v32 + 4, v30);
      sub_80A913C(v32, v13);
      sub_80C3AB4(v31, v13, (float *)v28);
      sub_80C3AB4(v30, v13, v29);
      CM_CalcTraceExtents((int)v28);
      if ( !sub_805D6DC((int)v28, (int)(v26 + 2), (int)(v26 + 5), *(float *)a2) )
      {
        sub_80C38DC(v29, (float *)v28, (float *)v24);
        for ( j = 0; j < v26[1]; ++j )
        {
          v25 = (float *)(*v26 + 48 * j);
          v6 = sub_80C3974(v29, v25);
          v22 = v6 - v25[3];
          if ( v22 < 0.0 )
          {
            v7 = sub_80C3974((float *)v28, v25);
            v21 = v7 - v25[3];
            if ( v21 > 0.0 )
            {
              v8 = (v21 - 0.125) / (v21 - v22);
              v20 = v8;
              sub_80C3888(v20, 0.0);
              v20 = v8;
              if ( v20 < (long double)*(float *)a2 )
              {
                v19 = v21 / (v21 - v22);
                sub_80C3920((float *)v28, v19, (float *)v24, (float *)v23);
                v9 = sub_80C3974((float *)v23, v25 + 4);
                v18 = v9 - v25[7];
                if ( v18 >= -0.001 && v18 <= 1.001 )
                {
                  v10 = sub_80C3974((float *)v23, v25 + 8);
                  v17 = v10 - v25[11];
                  if ( v17 >= -0.001 && v18 + v17 <= 1.001 )
                  {
                    v27 = v34;
                    *(_BYTE *)(a2 + 35) = 0;
                    *(_BYTE *)(a2 + 34) = 0;
                    *(float *)a2 = v20;
                    *(_DWORD *)(a2 + 16) = v26[10];
                    *(_DWORD *)(a2 + 20) = v26[9];
                    sub_80C38AC(v25, (_DWORD *)(a2 + 4));
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  if ( v27 < 0 )
    return -1;
  v32 = (float *)(a3 + 32 * v27);
  sub_80A913C(v32, v13);
  sub_80C3A0A((float *)(a2 + 4), v13, v14);
  sub_80C38AC(v14, (_DWORD *)(a2 + 4));
  return v27;
}
// 80C33FE: using guessed type float var_28[5];
// 80C33FE: using guessed type float var_38[4];
// 80C33FE: using guessed type float var_F8[12];
// 80C33FE: using guessed type float var_C8[4];

//----- (080C3820) --------------------------------------------------------
int __cdecl Com_ValidXModelName(char *s1)
{
  int v2; // [esp+14h] [ebp-4h]

  v2 = 0;
  if ( !strncasecmp(s1, "xmodel", 6u) && s1[6] == 47 )
    return 1;
  return v2;
}

//----- (080C3888) --------------------------------------------------------
void __cdecl sub_80C3888(float a1, float a2)
{
  float v2; // [esp+0h] [ebp-18h]

  v2 = a1 - a2;
  sub_80C39A8(v2, a1, a2);
}

//----- (080C38AC) --------------------------------------------------------
int __cdecl sub_80C38AC(_DWORD *a1, _DWORD *a2)
{
  int result; // eax

  *a2 = *a1;
  a2[1] = a1[1];
  result = a1[2];
  a2[2] = result;
  return result;
}

//----- (080C38DC) --------------------------------------------------------
float *__cdecl sub_80C38DC(float *a1, float *a2, float *a3)
{
  float *result; // eax

  *a3 = *a1 - *a2;
  a3[1] = a1[1] - a2[1];
  result = a1 + 2;
  a3[2] = a1[2] - a2[2];
  return result;
}

//----- (080C3920) --------------------------------------------------------
float *__cdecl sub_80C3920(float *a1, float a2, float *a3, float *a4)
{
  float *result; // eax

  *a4 = a2 * *a3 + *a1;
  a4[1] = a2 * a3[1] + a1[1];
  result = a3 + 2;
  a4[2] = a2 * a3[2] + a1[2];
  return result;
}

//----- (080C3974) --------------------------------------------------------
long double __cdecl sub_80C3974(float *a1, float *a2)
{
  return *a1 * *a2 + a1[1] * a2[1] + a1[2] * a2[2];
}

//----- (080C39A8) --------------------------------------------------------
long double __cdecl sub_80C39A8(float a1, float a2, float a3)
{
  if ( a1 < 0.0 )
    return a3;
  return a2;
}

//----- (080C3A0A) --------------------------------------------------------
float *__cdecl sub_80C3A0A(float *a1, float *a2, float *a3)
{
  float *result; // eax

  *a3 = *a1 * *a2 + a1[1] * a2[3] + a1[2] * a2[6];
  a3[1] = *a1 * a2[1] + a1[1] * a2[4] + a1[2] * a2[7];
  result = a1 + 2;
  a3[2] = *a1 * a2[2] + a1[1] * a2[5] + a1[2] * a2[8];
  return result;
}

//----- (080C3AB4) --------------------------------------------------------
float *__cdecl sub_80C3AB4(float *a1, float *a2, float *a3)
{
  float *result; // eax

  *a3 = *a1 * *a2 + a1[1] * a2[1] + a1[2] * a2[2];
  a3[1] = *a1 * a2[3] + a1[1] * a2[4] + a1[2] * a2[5];
  result = a1 + 2;
  a3[2] = *a1 * a2[6] + a1[1] * a2[7] + a1[2] * a2[8];
  return result;
}

//----- (080C3B60) --------------------------------------------------------
int __cdecl sub_80C3B60(const void **a1, __int16 *a2)
{
  long double v2; // fst7
  int result; // eax
  float v4; // [esp+0h] [ebp-38h]
  int v5; // [esp+10h] [ebp-28h]
  int v6; // [esp+1Ch] [ebp-1Ch]

  *a2 = sub_80C2C9E(a1);
  a2[1] = sub_80C2C9E(a1);
  a2[2] = sub_80C2C9E(a1);
  v6 = 1073676289 - (a2[2] * a2[2] + a2[1] * a2[1] + *a2 * *a2);
  if ( v6 <= 0 )
  {
    v5 = 0;
  }
  else
  {
    v4 = (float)v6;
    v2 = sub_80C51F0(v4);
    v5 = (int)floor(v2 + 0.5);
  }
  result = v5;
  a2[3] = v5;
  return result;
}

//----- (080C3C42) --------------------------------------------------------
void *__cdecl sub_80C3C42(__int16 *a1)
{
  float v2[5]; // [esp+10h] [ebp-38h] BYREF
  unsigned __int8 *v3; // [esp+24h] [ebp-24h]
  float *v4; // [esp+28h] [ebp-20h]
  int v5; // [esp+2Ch] [ebp-1Ch]
  int v6; // [esp+30h] [ebp-18h]
  float *v7; // [esp+34h] [ebp-14h]
  __int16 *v8; // [esp+38h] [ebp-10h]
  int v9; // [esp+3Ch] [ebp-Ch]

  v6 = *((_DWORD *)a1 + 1);
  v3 = (unsigned __int8 *)(v6 + 4);
  v5 = *a1;
  v8 = (__int16 *)*((_DWORD *)a1 + 2);
  v7 = (float *)*((_DWORD *)a1 + 3);
  v4 = (float *)(a1 + 34);
  v9 = a1[1];
  while ( v9 )
  {
    sub_80C5210(v4);
    v4[3] = 1.0;
    sub_80C5210((_DWORD *)v4 + 4);
    v4[7] = 2.0;
    --v9;
    v4 += 8;
  }
  v9 = v5 - a1[1];
  while ( v9 )
  {
    v2[0] = (long double)*v8 * 0.000030518509;
    v2[1] = (long double)v8[1] * 0.000030518509;
    v2[2] = (long double)v8[2] * 0.000030518509;
    v2[3] = (long double)v8[3] * 0.000030518509;
    sub_80A5372(v2, &v4[-8 * *v3], v4);
    sub_80B9D76((int)v4);
    sub_80A9094(v7, &v4[-8 * *v3], v4 + 4);
    --v9;
    v8 += 4;
    v7 += 3;
    v4 += 8;
    ++v3;
  }
  memset(a1 + 10, 255, 0x10u);
  return memset(a1 + 26, 255, 0x10u);
}

//----- (080C3DE8) --------------------------------------------------------
__int16 *__cdecl sub_80C3DE8(int a1, const char *a2, int (__cdecl *a3)(int))
{
  __int16 *v3; // ebx
  __int16 *v4; // ebx
  __int16 *v5; // ebx
  int v8; // [esp+14h] [ebp-94h]
  __int16 *v9; // [esp+1Ch] [ebp-8Ch]
  __int16 v10; // [esp+22h] [ebp-86h]
  char v11; // [esp+24h] [ebp-84h]
  size_t n; // [esp+28h] [ebp-80h]
  float *v13; // [esp+2Ch] [ebp-7Ch]
  int v14; // [esp+30h] [ebp-78h]
  int i; // [esp+30h] [ebp-78h]
  __int16 v16; // [esp+36h] [ebp-72h]
  __int16 v17; // [esp+38h] [ebp-70h]
  __int16 v18; // [esp+3Ah] [ebp-6Eh]
  _BYTE *v19; // [esp+3Ch] [ebp-6Ch]
  int v20; // [esp+40h] [ebp-68h]
  int *v21; // [esp+44h] [ebp-64h]
  void *src; // [esp+48h] [ebp-60h] BYREF
  _DWORD *v23; // [esp+4Ch] [ebp-5Ch] BYREF
  char s[76]; // [esp+50h] [ebp-58h] BYREF
  __int16 *v25; // [esp+9Ch] [ebp-Ch]

  if ( Com_sprintf(s, 0x40u, "xmodelparts/%s", a2) >= 0 )
  {
    v8 = FS_ReadFile(s, &v23);
    if ( v8 >= 0 )
    {
      if ( v8 )
      {
        src = v23;
        v10 = sub_80C2C9E((const void **)&src);
        if ( v10 == 20 )
        {
          v16 = sub_80C2C9E((const void **)&src);
          v17 = sub_80C2C9E((const void **)&src);
          v18 = v17 + v16;
          v20 = a3(2 * (__int16)(v17 + v16));
          *(_DWORD *)(a1 + 132) += 2 * (__int16)(v17 + v16);
          if ( (__int16)(v17 + v16) <= 127 )
          {
            v21 = (int *)a3(v16 + 7);
            *(_DWORD *)(a1 + 132) += v16 + 7;
            *v21 = v20;
            v19 = v21 + 1;
            v25 = (__int16 *)a3(32 * v18 + 68);
            *(_DWORD *)(a1 + 132) += 32 * v18 + 68;
            *((_DWORD *)v25 + 1) = v21;
            if ( v16 )
            {
              v3 = v25;
              *((_DWORD *)v3 + 2) = a3(8 * v16);
              *(_DWORD *)(a1 + 132) += 8 * v16;
              v4 = v25;
              *((_DWORD *)v4 + 3) = a3(16 * v16);
              *(_DWORD *)(a1 + 132) += 16 * v16;
            }
            else
            {
              *((_DWORD *)v25 + 2) = 0;
              *((_DWORD *)v25 + 3) = 0;
            }
            v5 = v25;
            *((_DWORD *)v5 + 4) = a3(v18);
            *(_DWORD *)(a1 + 132) += v18;
            *v25 = v18;
            v25[1] = v17;
            v9 = (__int16 *)*((_DWORD *)v25 + 2);
            v13 = (float *)*((_DWORD *)v25 + 3);
            v14 = v17;
            while ( v14 < v18 )
            {
              v11 = *(_BYTE *)src;
              src = (char *)src + 1;
              *v19 = v14 - v11;
              *v13 = sub_80C2D0A((const void **)&src);
              v13[1] = sub_80C2D0A((const void **)&src);
              v13[2] = sub_80C2D0A((const void **)&src);
              sub_80C3B60((const void **)&src, v9);
              ++v14;
              v9 += 4;
              v13 += 3;
              ++v19;
            }
            for ( i = 0; i < v18; ++i )
            {
              n = I_strlen((char *)src) + 1;
              *(_WORD *)(v20 + 2 * i) = SL_GetStringOfLen((char *)src, 0, n);
              src = (char *)src + n;
            }
            memcpy(*((void **)v25 + 4), src, v18);
            src = (char *)src + v18;
            FS_FreeFile(v23);
            sub_80C3C42(v25);
            return v25;
          }
          else
          {
            FS_FreeFile(v23);
            Com_Printf("^1ERROR: xmodel '%s' has more than %d bones\n", a2, 127);
            return 0;
          }
        }
        else
        {
          FS_FreeFile(v23);
          Com_Printf("^1ERROR: xmodelparts '%s' out of date (version %d, expecting %d).\n", a2, v10, 20);
          return 0;
        }
      }
      else
      {
        Com_Printf("^1ERROR: xmodelparts '%s' has 0 length\n", a2);
        FS_FreeFile(v23);
        return 0;
      }
    }
    else
    {
      Com_Printf("^1ERROR: xmodelparts '%s' not found\n", a2);
      return 0;
    }
  }
  else
  {
    Com_Printf("^1ERROR: filename '%s' too long\n", s);
    return 0;
  }
}
// 80C3DE8: using guessed type const char *arg_4;

//----- (080C4280) --------------------------------------------------------
int __cdecl sub_80C4280(const char *a1, const void **a2, int a3)
{
  __int16 v5; // [esp+1Ah] [ebp-Eh]
  int i; // [esp+1Ch] [ebp-Ch]

  v5 = sub_80C2C9E(a2);
  if ( v5 == 20 )
  {
    *(_BYTE *)(a3 + 4140) = *(_BYTE *)*a2;
    *a2 = (char *)*a2 + 1;
    *(float *)(a3 + 4112) = sub_80C2D0A(a2);
    *(float *)(a3 + 4116) = sub_80C2D0A(a2);
    *(float *)(a3 + 4120) = sub_80C2D0A(a2);
    *(float *)(a3 + 4124) = sub_80C2D0A(a2);
    *(float *)(a3 + 4128) = sub_80C2D0A(a2);
    *(float *)(a3 + 4132) = sub_80C2D0A(a2);
    for ( i = 0; i <= 3; ++i )
    {
      *(float *)(a3 + 1028 * i + 1024) = sub_80C2D0A(a2);
      strcpy((char *)(a3 + 1028 * i), (const char *)*a2);
      *a2 = (char *)*a2 + strlen((const char *)*a2) + 1;
    }
    *(_DWORD *)(a3 + 4136) = sub_80C53E0(a2);
    return 1;
  }
  else
  {
    Com_Printf("^1ERROR: xmodel '%s' out of date (version %d, expecting %d).\n", a1, v5, 20);
    return 0;
  }
}
// 80C4280: using guessed type const char *arg_0;

//----- (080C43F4) --------------------------------------------------------
_DWORD *__cdecl sub_80C43F4(const void **a1, _DWORD *a2, int (__cdecl *a3)(int))
{
  _DWORD *result; // eax
  int j; // [esp+4h] [ebp-14h]
  int i; // [esp+8h] [ebp-10h]
  float *v6; // [esp+Ch] [ebp-Ch]
  int v7; // [esp+10h] [ebp-8h]

  a2[22] = sub_80C53E0(a1);
  result = a2;
  if ( a2[22] )
  {
    a2[21] = a3(44 * a2[22]);
    for ( i = 0; ; ++i )
    {
      result = (_DWORD *)i;
      if ( i >= a2[22] )
        break;
      v7 = a2[21] + 44 * i;
      *(_DWORD *)(v7 + 4) = sub_80C53E0(a1);
      *(_DWORD *)v7 = a3(48 * *(_DWORD *)(v7 + 4));
      for ( j = 0; j < *(_DWORD *)(v7 + 4); ++j )
      {
        v6 = (float *)(*(_DWORD *)v7 + 48 * j);
        *v6 = sub_80C2D0A(a1);
        v6[1] = sub_80C2D0A(a1);
        v6[2] = sub_80C2D0A(a1);
        v6[3] = sub_80C2D0A(a1);
        v6[4] = sub_80C2D0A(a1);
        v6[5] = sub_80C2D0A(a1);
        v6[6] = sub_80C2D0A(a1);
        v6[7] = sub_80C2D0A(a1);
        v6[8] = sub_80C2D0A(a1);
        v6[9] = sub_80C2D0A(a1);
        v6[10] = sub_80C2D0A(a1);
        v6[11] = sub_80C2D0A(a1);
      }
      *(float *)(v7 + 8) = sub_80C2D0A(a1) - 0.001;
      *(float *)(v7 + 12) = sub_80C2D0A(a1) - 0.001;
      *(float *)(v7 + 16) = sub_80C2D0A(a1) - 0.001;
      *(float *)(v7 + 20) = sub_80C2D0A(a1) + 0.001;
      *(float *)(v7 + 24) = sub_80C2D0A(a1) + 0.001;
      *(float *)(v7 + 28) = sub_80C2D0A(a1) + 0.001;
      *(_DWORD *)(v7 + 32) = sub_80C53E0(a1);
      *(_DWORD *)(v7 + 36) = sub_80C53E0(a1) & 0xDFFFFFFB;
      *(_DWORD *)(v7 + 40) = sub_80C53E0(a1);
      a2[23] |= *(_DWORD *)(v7 + 36);
    }
  }
  return result;
}

//----- (080C468A) --------------------------------------------------------
__int16 *__cdecl sub_80C468A(int a1, char *s2, int (__cdecl *a3)(int))
{
  int v5; // [esp+14h] [ebp-4h]
  __int16 *v6; // [esp+14h] [ebp-4h]

  v5 = sub_80C3090(s2);
  if ( v5 )
    return (__int16 *)v5;
  v6 = sub_80C3DE8(a1, s2, a3);
  if ( v6 )
  {
    sub_80C30AC(s2, (int)v6, (int (__cdecl *)(size_t))a3);
    return v6;
  }
  else
  {
    Com_Printf("^1ERROR: Cannot find xmodelparts '%s'.\n", s2);
    return 0;
  }
}

//----- (080C470E) --------------------------------------------------------
int __cdecl sub_80C470E(const char *a1, int (__cdecl *a2)(int), int (__cdecl *a3)(int))
{
  int v3; // ebx
  int v4; // esi
  int v5; // ebx
  _DWORD *v6; // ebx
  size_t v7; // eax
  int v8; // ebx
  int v9; // esi
  __int16 **v10; // ebx
  long double v11; // fst7
  long double v12; // fst7
  long double v13; // fst7
  long double v14; // fst7
  long double v15; // fst7
  long double v16; // fst7
  int v17; // esi
  int v20; // [esp+14h] [ebp-10F4h]
  int v21; // [esp+18h] [ebp-10F0h]
  int v22; // [esp+18h] [ebp-10F0h]
  int v23; // [esp+1Ch] [ebp-10ECh]
  float v24[6]; // [esp+20h] [ebp-10E8h] BYREF
  float *v25; // [esp+38h] [ebp-10D0h]
  float *v26; // [esp+3Ch] [ebp-10CCh]
  float *v27; // [esp+40h] [ebp-10C8h]
  int v28; // [esp+44h] [ebp-10C4h]
  char *s; // [esp+48h] [ebp-10C0h]
  _DWORD *v30; // [esp+4Ch] [ebp-10BCh] BYREF
  char v31[76]; // [esp+50h] [ebp-10B8h] BYREF
  int j; // [esp+9Ch] [ebp-106Ch]
  int i; // [esp+A0h] [ebp-1068h]
  int v34; // [esp+A4h] [ebp-1064h]
  char *dest; // [esp+A8h] [ebp-1060h]
  const void *v36[8]; // [esp+ACh] [ebp-105Ch] BYREF
  int v37; // [esp+CCh] [ebp-103Ch]
  char v38[4112]; // [esp+D0h] [ebp-1038h] BYREF
  int v39[3]; // [esp+10E0h] [ebp-28h] BYREF
  int v40[3]; // [esp+10ECh] [ebp-1Ch] BYREF
  int v41; // [esp+10F8h] [ebp-10h]
  char v42; // [esp+10FCh] [ebp-Ch]

  if ( Com_sprintf(v31, 0x40u, "xmodel/%s", a1) >= 0 )
  {
    v20 = FS_ReadFile(v31, &v30);
    if ( v20 >= 0 )
    {
      if ( v20 )
      {
        v36[0] = v30;
        if ( (unsigned __int8)sub_80C4280(a1, v36, (int)v38) )
        {
          v34 = 0;
          for ( i = 0; i <= 3; ++i )
          {
            v3 = i;
            v36[v3 + 1] = (const void *)(I_strlen(&v38[1028 * i]) + 1);
            v34 += (int)v36[i + 1];
          }
          v21 = v34 + 144;
          v37 = a2(v34 + 144);
          *(_DWORD *)(v37 + 132) = v21;
          sub_80C43F4(v36, (_DWORD *)v37, a3);
          dest = (char *)(v37 + 144);
          *(_WORD *)(v37 + 124) = 0;
          for ( i = 0; i <= 3; ++i )
          {
            strcpy(dest, &v38[1028 * i]);
            *(_DWORD *)(v37 + 20 * i + 8) = dest;
            if ( *dest )
            {
              ++*(_WORD *)(v37 + 124);
              v4 = v37;
              v5 = 20 * i;
              *(_WORD *)(v4 + v5 + 12) = sub_80C2C9E(v36);
              v22 = 2 * *(__int16 *)(v37 + 20 * i + 12);
              v6 = (_DWORD *)(v37 + 20 * i + 16);
              *v6 = a2(v22);
              *(_DWORD *)(v37 + 132) += v22;
              for ( j = 0; j < *(__int16 *)(v37 + 20 * i + 12); ++j )
              {
                s = (char *)v36[0];
                v7 = strlen((const char *)v36[0]);
                v36[0] = (char *)v36[0] + v7 + 1;
                v8 = 2 * j;
                v9 = *(_DWORD *)(v37 + 20 * i + 16);
                *(_WORD *)(v9 + v8) = SL_GetString(s, 0);
              }
            }
            else
            {
              *(_DWORD *)(v37 + 20 * i + 16) = 0;
            }
            *(_DWORD *)(v37 + 20 * i + 4) = *(_DWORD *)&v38[1028 * i + 1024];
            dest = &dest[(_DWORD)v36[i + 1]];
          }
          v10 = (__int16 **)v37;
          *v10 = sub_80C468A(v37, *(char **)(v37 + 8), a2);
          if ( *(_DWORD *)v37 )
          {
            v28 = **(__int16 **)v37;
            v23 = a2(40 * v28);
            *(_DWORD *)(v37 + 132) += 40 * v28;
            for ( i = 0; i < v28; ++i )
            {
              v27 = (float *)(v23 + 40 * i);
              v11 = sub_80C2D0A(v36);
              *v27 = v11;
              v12 = sub_80C2D0A(v36);
              v27[1] = v12;
              v13 = sub_80C2D0A(v36);
              v27[2] = v13;
              v26 = (float *)(v23 + 40 * i + 12);
              v14 = sub_80C2D0A(v36);
              *v26 = v14;
              v15 = sub_80C2D0A(v36);
              v26[1] = v15;
              v16 = sub_80C2D0A(v36);
              v26[2] = v16;
              v25 = (float *)(v23 + 40 * i + 24);
              sub_80C52D2(v27, v26, v25);
              sub_80C528E(v26, v25, v24);
              v17 = 40 * i;
              *(float *)(v23 + v17 + 36) = sub_80C532E(v24);
            }
            *(_DWORD *)(v37 + 96) = v23;
            FS_FreeFile(v30);
            sub_80C525E(v39, (_DWORD *)(v37 + 100));
            sub_80C525E(v40, (_DWORD *)(v37 + 112));
            *(_WORD *)(v37 + 126) = v41;
            *(_BYTE *)(v37 + 140) = v42;
            return v37;
          }
          else
          {
            FS_FreeFile(v30);
            XModelFree(v37);
            return 0;
          }
        }
        else
        {
          FS_FreeFile(v30);
          return 0;
        }
      }
      else
      {
        Com_Printf("^1ERROR: xmodel '%s' has 0 length\n", a1);
        FS_FreeFile(v30);
        return 0;
      }
    }
    else
    {
      Com_Printf("^1ERROR: xmodel '%s' not found\n", a1);
      return 0;
    }
  }
  else
  {
    Com_Printf("^1ERROR: filename '%s' too long\n", v31);
    return 0;
  }
}
// 80C470E: using guessed type const char *arg_0;
// 80C470E: using guessed type char var_1038[4112];
// 80C470E: using guessed type float var_10E8[6];
// 80C470E: using guessed type int anonymous_0[3];
// 80C470E: using guessed type int anonymous_1[3];

//----- (080C4E50) --------------------------------------------------------
int sub_80C4E50()
{
  return 0;
}

//----- (080C4E5A) --------------------------------------------------------
int sub_80C4E5A()
{
  return 0;
}

//----- (080C4E74) --------------------------------------------------------
int __cdecl sub_80C4E74(int a1, char *s2, int (__cdecl *a3)(size_t))
{
  int v5; // [esp+20h] [ebp-8h]
  int v6; // [esp+20h] [ebp-8h]

  v5 = sub_80C30D6(s2);
  if ( v5 )
    return v5;
  v6 = sub_80C4E5A();
  if ( v6 )
  {
    sub_80C30F2(s2, v6, a3);
    return v6;
  }
  else
  {
    Com_Printf("^1ERROR: Cannot find 'xmodelsurfs '%s'.\n", s2);
    return 0;
  }
}

//----- (080C4F0E) --------------------------------------------------------
int __cdecl sub_80C4F0E(int a1, int (__cdecl *a2)(size_t))
{
  int i; // [esp+20h] [ebp-8h]

  for ( i = 0; i <= 3 && **(_BYTE **)(a1 + 20 * i + 8); ++i )
  {
    *(_DWORD *)(a1 + 20 * i + 20) = sub_80C4E74(a1, *(char **)(a1 + 20 * i + 8), a2);
    if ( !*(_DWORD *)(a1 + 20 * i + 20) )
      return 0;
  }
  return 1;
}

//----- (080C4FAA) --------------------------------------------------------
int __cdecl XModelLoad(const char *a1, int (__cdecl *a2)(int), int (__cdecl *a3)(int))
{
  int v5; // [esp+14h] [ebp-4h]

  v5 = sub_80C470E(a1, a2, a3);
  if ( !v5 )
    return 0;
  if ( !(unsigned __int8)sub_80C4E50() || (unsigned __int8)sub_80C4F0E(v5, (int (__cdecl *)(size_t))a2) )
    return v5;
  XModelFree(v5);
  return 0;
}

//----- (080C501A) --------------------------------------------------------
int __cdecl sub_80C501A(int a1, float *a2, _DWORD *a3, _DWORD *a4)
{
  float v5; // [esp+10h] [ebp-48h]
  float v6; // [esp+14h] [ebp-44h]
  float v7; // [esp+18h] [ebp-40h]
  float v9[4]; // [esp+20h] [ebp-38h] BYREF
  float v10[4]; // [esp+30h] [ebp-28h] BYREF
  int j; // [esp+40h] [ebp-18h]
  int k; // [esp+44h] [ebp-14h]
  int i; // [esp+48h] [ebp-10h]
  float *v14; // [esp+4Ch] [ebp-Ch]

  if ( !*(_DWORD *)(a1 + 88) )
    return 0;
  sub_80C523A(a3, 2139095039, 2139095039, 2139095039);
  sub_80C523A(a4, -8388609, -8388609, -8388609);
  for ( i = 0; i < *(_DWORD *)(a1 + 88); ++i )
  {
    v14 = (float *)(*(_DWORD *)(a1 + 84) + 44 * i);
    for ( j = 0; j <= 7; ++j )
    {
      if ( (j & 1) != 0 )
        v7 = v14[2];
      else
        v7 = v14[5];
      v10[0] = v7;
      if ( (j & 2) != 0 )
        v6 = v14[3];
      else
        v6 = v14[6];
      v10[1] = v6;
      if ( (j & 4) != 0 )
        v5 = v14[4];
      else
        v5 = v14[7];
      v10[2] = v5;
      sub_80A4E52(v10, a2, v9);
      for ( k = 0; k <= 2; ++k )
      {
        if ( *(float *)&a3[k] > (long double)v9[k] )
          a3[k] = LODWORD(v9[k]);
        if ( v9[k] > (long double)*(float *)&a4[k] )
          a4[k] = LODWORD(v9[k]);
      }
    }
  }
  return 1;
}
// 80C501A: using guessed type float var_38[4];

//----- (080C51F0) --------------------------------------------------------
long double __cdecl sub_80C51F0(float a1)
{
  return (float)sqrt(a1);
}

//----- (080C5210) --------------------------------------------------------
int __cdecl sub_80C5210(_DWORD *a1)
{
  int result; // eax

  *a1 = 0;
  a1[1] = 0;
  result = 0;
  a1[2] = 0;
  return result;
}

//----- (080C523A) --------------------------------------------------------
int __cdecl sub_80C523A(_DWORD *a1, int a2, int a3, int a4)
{
  int result; // eax

  *a1 = a2;
  a1[1] = a3;
  result = a4;
  a1[2] = a4;
  return result;
}

//----- (080C525E) --------------------------------------------------------
int __cdecl sub_80C525E(_DWORD *a1, _DWORD *a2)
{
  int result; // eax

  *a2 = *a1;
  a2[1] = a1[1];
  result = a1[2];
  a2[2] = result;
  return result;
}

//----- (080C528E) --------------------------------------------------------
float *__cdecl sub_80C528E(float *a1, float *a2, float *a3)
{
  float *result; // eax

  *a3 = *a1 - *a2;
  a3[1] = a1[1] - a2[1];
  result = a1 + 2;
  a3[2] = a1[2] - a2[2];
  return result;
}

//----- (080C52D2) --------------------------------------------------------
float *__cdecl sub_80C52D2(float *a1, float *a2, float *a3)
{
  float *result; // eax

  *a3 = (*a1 + *a2) * 0.5;
  a3[1] = (a1[1] + a2[1]) * 0.5;
  result = a1 + 2;
  a3[2] = (a1[2] + a2[2]) * 0.5;
  return result;
}

//----- (080C532E) --------------------------------------------------------
long double __cdecl sub_80C532E(float *a1)
{
  return *a1 * *a1 + a1[1] * a1[1] + a1[2] * a1[2];
}

//----- (080C53E0) --------------------------------------------------------
int __cdecl sub_80C53E0(const void **a1)
{
  int dest; // [esp+14h] [ebp-4h] BYREF

  memcpy(&dest, *a1, sizeof(dest));
  *a1 = (char *)*a1 + 4;
  return dest;
}

//----- (080C5414) --------------------------------------------------------
int __cdecl sub_80C5414(int a1)
{
  return *(_DWORD *)(a1 + 136);
}

//----- (080C5432) --------------------------------------------------------
const char *__cdecl sub_80C5432(int a1, int a2, int a3)
{
  unsigned __int16 v5; // [esp+16h] [ebp-2h]

  v5 = *(_WORD *)(*(_DWORD *)(a1 + 20 * a3 + 16) + 2 * a2);
  if ( v5 )
    return (const char *)SL_ConvertToString(v5);
  else
    return "DEFAULT";
}

//----- (080C5482) --------------------------------------------------------
int __cdecl sub_80C5482(int a1, _DWORD *a2, int a3, _DWORD *a4)
{
  *a2 = **(_DWORD **)(a1 + 20 * a3 + 20);
  *a4 = *(_DWORD *)(a1 + 20 * a3 + 20) + 4;
  return *(__int16 *)(a1 + 20 * a3 + 12);
}

//----- (080C54C2) --------------------------------------------------------
int __cdecl sub_80C54C2(int a1)
{
  return *(__int16 *)(a1 + 124);
}

//----- (080C54CE) --------------------------------------------------------
int __cdecl sub_80C54CE(__int16 **a1)
{
  return **a1;
}

//----- (080C54DC) --------------------------------------------------------
int __cdecl sub_80C54DC(_DWORD *a1)
{
  return *a1 + 68;
}

//----- (080C5506) --------------------------------------------------------
long double __cdecl sub_80C5506(int a1)
{
  int v3; // [esp+14h] [ebp-4h]

  v3 = sub_80C54C2(a1) - 1;
  if ( byte_8550180[8 * v3] )
    return flt_8550184[2 * v3];
  else
    return *(float *)(a1 + 20 * v3 + 4);
}
// 8550184: using guessed type float flt_8550184[16];

//----- (080C5556) --------------------------------------------------------
int __cdecl sub_80C5556(int a1, float a2)
{
  float v3; // [esp+10h] [ebp-18h]
  int i; // [esp+1Ch] [ebp-Ch]
  int v6; // [esp+20h] [ebp-8h]

  v6 = sub_80C54C2(a1);
  for ( i = 0; i < v6; ++i )
  {
    if ( byte_8550180[8 * i] )
      v3 = flt_8550184[2 * i];
    else
      v3 = *(float *)(a1 + 4 + 20 * i);
    if ( v3 == 0.0 || v3 > (long double)a2 )
      return i;
  }
  return -1;
}
// 8550184: using guessed type float flt_8550184[16];

//----- (080C5628) --------------------------------------------------------
int __cdecl sub_80C5628(int a1, unsigned __int8 *a2, unsigned int a3)
{
  int v4; // [esp+0h] [ebp-14h]
  int v6; // [esp+8h] [ebp-Ch]
  unsigned int v7; // [esp+Ch] [ebp-8h]
  int v8; // [esp+Ch] [ebp-8h]
  int v9; // [esp+Ch] [ebp-8h]
  int v10; // [esp+Ch] [ebp-8h]
  int v11; // [esp+Ch] [ebp-8h]
  int v12; // [esp+Ch] [ebp-8h]
  int v13; // [esp+Ch] [ebp-8h]
  int v14; // [esp+Ch] [ebp-8h]
  int v15; // [esp+Ch] [ebp-8h]
  int v16; // [esp+Ch] [ebp-8h]
  int v17; // [esp+Ch] [ebp-8h]
  int v18; // [esp+Ch] [ebp-8h]
  int v19; // [esp+Ch] [ebp-8h]
  int v20; // [esp+Ch] [ebp-8h]
  int v21; // [esp+Ch] [ebp-8h]
  int v22; // [esp+Ch] [ebp-8h]
  unsigned int v23; // [esp+10h] [ebp-4h]
  int v24; // [esp+10h] [ebp-4h]
  int v25; // [esp+10h] [ebp-4h]
  int v26; // [esp+10h] [ebp-4h]
  int v27; // [esp+10h] [ebp-4h]
  int v28; // [esp+10h] [ebp-4h]
  int v29; // [esp+10h] [ebp-4h]
  int v30; // [esp+10h] [ebp-4h]
  int v31; // [esp+10h] [ebp-4h]
  int v32; // [esp+10h] [ebp-4h]
  int v33; // [esp+10h] [ebp-4h]
  int v34; // [esp+10h] [ebp-4h]
  int v35; // [esp+10h] [ebp-4h]
  int v36; // [esp+10h] [ebp-4h]
  int v37; // [esp+10h] [ebp-4h]
  int v38; // [esp+10h] [ebp-4h]

  v23 = (unsigned __int16)a1;
  v7 = HIWORD(a1);
  if ( !a2 )
    return 1;
  while ( a3 )
  {
    v4 = a3;
    if ( a3 > 0x15B0 )
      v4 = 5552;
    v6 = v4;
    a3 -= v4;
    while ( v6 > 15 )
    {
      v24 = *a2 + v23;
      v8 = v24 + v7;
      v25 = a2[1] + v24;
      v9 = v25 + v8;
      v26 = a2[2] + v25;
      v10 = v26 + v9;
      v27 = a2[3] + v26;
      v11 = v27 + v10;
      v28 = a2[4] + v27;
      v12 = v28 + v11;
      v29 = a2[5] + v28;
      v13 = v29 + v12;
      v30 = a2[6] + v29;
      v14 = v30 + v13;
      v31 = a2[7] + v30;
      v15 = v31 + v14;
      v32 = a2[8] + v31;
      v16 = v32 + v15;
      v33 = a2[9] + v32;
      v17 = v33 + v16;
      v34 = a2[10] + v33;
      v18 = v34 + v17;
      v35 = a2[11] + v34;
      v19 = v35 + v18;
      v36 = a2[12] + v35;
      v20 = v36 + v19;
      v37 = a2[13] + v36;
      v21 = v37 + v20;
      v38 = a2[14] + v37;
      v22 = v38 + v21;
      v23 = a2[15] + v38;
      v7 = v23 + v22;
      a2 += 16;
      v6 -= 16;
    }
    for ( ; v6; --v6 )
    {
      v23 += *a2++;
      v7 += v23;
    }
    v23 %= 0xFFF1u;
    v7 %= 0xFFF1u;
  }
  return v23 | (v7 << 16);
}

//----- (080C5874) --------------------------------------------------------
int __cdecl sub_80C5874(int a1, int *a2, int a3, int a4, unsigned int a5)
{
  int v6; // [esp+14h] [ebp-54h]
  int v8; // [esp+1Ch] [ebp-4Ch]
  int v9; // [esp+1Ch] [ebp-4Ch]
  int v10[4]; // [esp+20h] [ebp-48h] BYREF
  int v11; // [esp+30h] [ebp-38h]
  int v12; // [esp+34h] [ebp-34h]
  int v13; // [esp+40h] [ebp-28h]
  int v14; // [esp+44h] [ebp-24h]
  int v15; // [esp+48h] [ebp-20h]

  v10[0] = a3;
  v10[1] = a4;
  v10[3] = a1;
  v11 = *a2;
  if ( v11 != *a2 )
    return -5;
  v13 = 0;
  v14 = 0;
  v15 = 0;
  v8 = sub_80C5988(v10, a5, "1.1.4", 56);
  if ( v8 )
    return v8;
  v9 = sub_80C620B((int)v10, 4);
  if ( v9 == 1 )
  {
    *a2 = v12;
    return sub_80C65F4((int)v10);
  }
  else
  {
    sub_80C65F4((int)v10);
    v6 = v9;
    if ( !v9 )
      return -5;
    return v6;
  }
}

//----- (080C5988) --------------------------------------------------------
int __cdecl sub_80C5988(_DWORD *a1, unsigned int a2, _BYTE *a3, int a4)
{
  return sub_80C59D0(a1, a2, 8, 15, 8, 0, a3, a4);
}

//----- (080C59D0) --------------------------------------------------------
int __cdecl sub_80C59D0(_DWORD *a1, unsigned int a2, int a3, int a4, int a5, unsigned int a6, _BYTE *a7, int a8)
{
  int v10; // [esp+18h] [ebp-10h]
  int v11; // [esp+1Ch] [ebp-Ch]
  int v12; // [esp+20h] [ebp-8h]

  v11 = 0;
  if ( !a7 || *a7 != *off_8162D84 || a8 != 56 )
    return -6;
  if ( !a1 )
    return -2;
  a1[6] = 0;
  if ( !a1[8] )
  {
    a1[8] = sub_80D1096;
    a1[10] = 0;
  }
  if ( !a1[9] )
    a1[9] = sub_80D10AD;
  if ( a2 == -1 )
    a2 = 6;
  if ( a4 < 0 )
  {
    v11 = 1;
    a4 = -a4;
  }
  if ( a5 <= 0 || a5 > 9 || a3 != 8 || a4 <= 8 || a4 > 15 || a2 > 9 || a6 >= 3 )
    return -2;
  v12 = ((int (__cdecl *)(_DWORD, int, int))a1[8])(a1[10], 1, 5816);
  if ( !v12 )
    return -4;
  a1[7] = v12;
  *(_DWORD *)v12 = a1;
  *(_DWORD *)(v12 + 24) = v11;
  *(_DWORD *)(v12 + 40) = a4;
  *(_DWORD *)(v12 + 36) = 1 << *(_BYTE *)(v12 + 40);
  *(_DWORD *)(v12 + 44) = *(_DWORD *)(v12 + 36) - 1;
  *(_DWORD *)(v12 + 72) = a5 + 7;
  *(_DWORD *)(v12 + 68) = 1 << *(_BYTE *)(v12 + 72);
  *(_DWORD *)(v12 + 76) = *(_DWORD *)(v12 + 68) - 1;
  *(_DWORD *)(v12 + 80) = (*(_DWORD *)(v12 + 72) + 2) / 3u;
  *(_DWORD *)(v12 + 48) = ((int (__cdecl *)(_DWORD, _DWORD, int))a1[8])(a1[10], *(_DWORD *)(v12 + 36), 2);
  *(_DWORD *)(v12 + 56) = ((int (__cdecl *)(_DWORD, _DWORD, int))a1[8])(a1[10], *(_DWORD *)(v12 + 36), 2);
  *(_DWORD *)(v12 + 60) = ((int (__cdecl *)(_DWORD, _DWORD, int))a1[8])(a1[10], *(_DWORD *)(v12 + 68), 2);
  *(_DWORD *)(v12 + 5780) = 1 << (a5 + 6);
  v10 = ((int (__cdecl *)(_DWORD, _DWORD, int))a1[8])(a1[10], *(_DWORD *)(v12 + 5780), 4);
  *(_DWORD *)(v12 + 8) = v10;
  *(_DWORD *)(v12 + 12) = 4 * *(_DWORD *)(v12 + 5780);
  if ( *(_DWORD *)(v12 + 48) && *(_DWORD *)(v12 + 56) && *(_DWORD *)(v12 + 60) && *(_DWORD *)(v12 + 8) )
  {
    *(_DWORD *)(v12 + 5788) = v10 + 2 * (*(_DWORD *)(v12 + 5780) >> 1);
    *(_DWORD *)(v12 + 5776) = *(_DWORD *)(v12 + 8) + 3 * *(_DWORD *)(v12 + 5780);
    *(_DWORD *)(v12 + 124) = a2;
    *(_DWORD *)(v12 + 128) = a6;
    *(_BYTE *)(v12 + 29) = 8;
    return sub_80C5ECE(a1);
  }
  else
  {
    a1[6] = off_8163F58[0];
    sub_80C65F4((int)a1);
    return -4;
  }
}
// 8162D84: using guessed type char *off_8162D84;
// 8163F58: using guessed type char *off_8163F58[3];

//----- (080C5ECE) --------------------------------------------------------
int __cdecl sub_80C5ECE(_DWORD *a1)
{
  int v2; // [esp+8h] [ebp-10h]
  _DWORD *v4; // [esp+14h] [ebp-4h]

  if ( !a1 || !a1[7] || !a1[8] || !a1[9] )
    return -2;
  a1[5] = 0;
  a1[2] = 0;
  a1[6] = 0;
  a1[11] = 2;
  v4 = (_DWORD *)a1[7];
  v4[5] = 0;
  v4[4] = v4[2];
  if ( (int)v4[6] < 0 )
    v4[6] = 0;
  if ( v4[6] )
    v2 = 113;
  else
    v2 = 42;
  v4[1] = v2;
  a1[12] = 1;
  v4[8] = 0;
  sub_80CC47D((int)v4);
  sub_80C6AC0((int)v4);
  return 0;
}

//----- (080C6104) --------------------------------------------------------
int __cdecl sub_80C6104(int a1, __int16 a2)
{
  int result; // eax

  *(_BYTE *)(*(_DWORD *)(a1 + 8) + (*(_DWORD *)(a1 + 20))++) = HIBYTE(a2);
  result = (unsigned __int8)a2;
  *(_BYTE *)(*(_DWORD *)(a1 + 8) + (*(_DWORD *)(a1 + 20))++) = a2;
  return result;
}

//----- (080C613D) --------------------------------------------------------
size_t __cdecl sub_80C613D(int a1)
{
  size_t result; // eax
  size_t n; // [esp+14h] [ebp-4h]

  n = *(_DWORD *)(*(_DWORD *)(a1 + 28) + 20);
  result = n;
  if ( n > *(_DWORD *)(a1 + 16) )
  {
    result = *(_DWORD *)(a1 + 16);
    n = result;
  }
  if ( n )
  {
    memcpy(*(void **)(a1 + 12), *(const void **)(*(_DWORD *)(a1 + 28) + 16), n);
    *(_DWORD *)(a1 + 12) += n;
    *(_DWORD *)(*(_DWORD *)(a1 + 28) + 16) += n;
    *(_DWORD *)(a1 + 20) += n;
    *(_DWORD *)(a1 + 16) -= n;
    *(_DWORD *)(*(_DWORD *)(a1 + 28) + 20) -= n;
    result = *(_DWORD *)(a1 + 28);
    if ( !*(_DWORD *)(result + 20) )
    {
      result = *(_DWORD *)(*(_DWORD *)(a1 + 28) + 8);
      *(_DWORD *)(*(_DWORD *)(a1 + 28) + 16) = result;
    }
  }
  return result;
}

//----- (080C620B) --------------------------------------------------------
int __cdecl sub_80C620B(int a1, int a2)
{
  unsigned int v4; // [esp+14h] [ebp-14h]
  int v5; // [esp+14h] [ebp-14h]
  int v6; // [esp+18h] [ebp-10h]
  int v7; // [esp+1Ch] [ebp-Ch]
  int v8; // [esp+20h] [ebp-8h]

  if ( !a1 || !*(_DWORD *)(a1 + 28) || (unsigned int)a2 >= 5 )
    return -2;
  v7 = *(_DWORD *)(a1 + 28);
  if ( !*(_DWORD *)(a1 + 12) || !*(_DWORD *)a1 && *(_DWORD *)(a1 + 4) || *(_DWORD *)(v7 + 4) == 666 && a2 != 4 )
  {
    *(char **)(a1 + 24) = off_8163F50[0];
    return -2;
  }
  if ( !*(_DWORD *)(a1 + 16) )
  {
    *(char **)(a1 + 24) = off_8163F5C[0];
    return -5;
  }
  *(_DWORD *)v7 = a1;
  v8 = *(_DWORD *)(v7 + 32);
  *(_DWORD *)(v7 + 32) = a2;
  if ( *(_DWORD *)(v7 + 4) == 42 )
  {
    v4 = (*(_DWORD *)(v7 + 124) - 1) >> 1;
    if ( v4 > 3 )
      v4 = 3;
    v6 = (v4 << 6) | ((16 * (*(_DWORD *)(v7 + 40) - 8) + 8) << 8);
    if ( *(_DWORD *)(v7 + 100) )
      v6 |= 0x20u;
    *(_DWORD *)(v7 + 4) = 113;
    sub_80C6104(
      v7,
      31
    * ((unsigned int)((((unsigned int)v6 * (unsigned __int64)(unsigned int)&unk_8421085) >> 32)
                    + ((unsigned int)(v6 - (((unsigned int)v6 * (unsigned __int64)(unsigned int)&unk_8421085) >> 32)) >> 1)) >> 4)
    + 31);
    if ( *(_DWORD *)(v7 + 100) )
    {
      sub_80C6104(v7, HIWORD(*(_DWORD *)(a1 + 48)));
      sub_80C6104(v7, *(_WORD *)(a1 + 48));
    }
    *(_DWORD *)(a1 + 48) = 1;
  }
  if ( *(_DWORD *)(v7 + 20) )
  {
    sub_80C613D(a1);
    if ( !*(_DWORD *)(a1 + 16) )
    {
      *(_DWORD *)(v7 + 32) = -1;
      return 0;
    }
  }
  else if ( !*(_DWORD *)(a1 + 4) && a2 <= v8 && a2 != 4 )
  {
    *(char **)(a1 + 24) = off_8163F5C[0];
    return -5;
  }
  if ( *(_DWORD *)(v7 + 4) == 666 && *(_DWORD *)(a1 + 4) )
  {
    *(char **)(a1 + 24) = off_8163F5C[0];
    return -5;
  }
  if ( !*(_DWORD *)(a1 + 4) && !*(_DWORD *)(v7 + 108) && (!a2 || *(_DWORD *)(v7 + 4) == 666) )
    goto LABEL_50;
  v5 = funcs_80C6485[3 * *(_DWORD *)(v7 + 124)](v7, a2);
  if ( v5 == 2 || v5 == 3 )
    *(_DWORD *)(v7 + 4) = 666;
  if ( v5 && v5 != 2 )
  {
    if ( v5 == 1 )
    {
      if ( a2 == 1 )
      {
        sub_80CE10F(v7);
      }
      else
      {
        sub_80CDFE1(v7, 0, 0, 0);
        if ( a2 == 3 )
        {
          *(_WORD *)(*(_DWORD *)(v7 + 60) + 2 * *(_DWORD *)(v7 + 68) - 2) = 0;
          memset(*(void **)(v7 + 60), 0, 2 * *(_DWORD *)(v7 + 68) - 2);
        }
      }
      sub_80C613D(a1);
      if ( !*(_DWORD *)(a1 + 16) )
      {
        *(_DWORD *)(v7 + 32) = -1;
        return 0;
      }
    }
LABEL_50:
    if ( a2 != 4 )
      return 0;
    if ( *(_DWORD *)(v7 + 24) )
      return 1;
    sub_80C6104(v7, HIWORD(*(_DWORD *)(a1 + 48)));
    sub_80C6104(v7, *(_WORD *)(a1 + 48));
    sub_80C613D(a1);
    *(_DWORD *)(v7 + 24) = -1;
    return *(_DWORD *)(v7 + 20) == 0;
  }
  if ( !*(_DWORD *)(a1 + 16) )
    *(_DWORD *)(v7 + 32) = -1;
  return 0;
}
// 81497A8: using guessed type int (__cdecl *funcs_80C6485[28])(int, int);
// 8163F50: using guessed type char *off_8163F50[5];
// 8163F5C: using guessed type char *off_8163F5C[2];

//----- (080C65F4) --------------------------------------------------------
int __cdecl sub_80C65F4(int a1)
{
  int v4; // [esp+14h] [ebp-4h]

  if ( !a1 || !*(_DWORD *)(a1 + 28) )
    return -2;
  v4 = *(_DWORD *)(*(_DWORD *)(a1 + 28) + 4);
  if ( v4 != 42 && v4 != 113 && v4 != 666 )
    return -2;
  if ( *(_DWORD *)(*(_DWORD *)(a1 + 28) + 8) )
    (*(void (__cdecl **)(_DWORD, _DWORD))(a1 + 36))(*(_DWORD *)(a1 + 40), *(_DWORD *)(*(_DWORD *)(a1 + 28) + 8));
  if ( *(_DWORD *)(*(_DWORD *)(a1 + 28) + 60) )
    (*(void (__cdecl **)(_DWORD, _DWORD))(a1 + 36))(*(_DWORD *)(a1 + 40), *(_DWORD *)(*(_DWORD *)(a1 + 28) + 60));
  if ( *(_DWORD *)(*(_DWORD *)(a1 + 28) + 56) )
    (*(void (__cdecl **)(_DWORD, _DWORD))(a1 + 36))(*(_DWORD *)(a1 + 40), *(_DWORD *)(*(_DWORD *)(a1 + 28) + 56));
  if ( *(_DWORD *)(*(_DWORD *)(a1 + 28) + 48) )
    (*(void (__cdecl **)(_DWORD, _DWORD))(a1 + 36))(*(_DWORD *)(a1 + 40), *(_DWORD *)(*(_DWORD *)(a1 + 28) + 48));
  (*(void (__cdecl **)(_DWORD, _DWORD))(a1 + 36))(*(_DWORD *)(a1 + 40), *(_DWORD *)(a1 + 28));
  *(_DWORD *)(a1 + 28) = 0;
  if ( v4 == 113 )
    return -3;
  else
    return 0;
}

//----- (080C6A0C) --------------------------------------------------------
unsigned int __cdecl sub_80C6A0C(int a1, void *dest, unsigned int a3)
{
  unsigned int n; // [esp+10h] [ebp-8h]

  n = *(_DWORD *)(a1 + 4);
  if ( n > a3 )
    n = a3;
  if ( !n )
    return 0;
  *(_DWORD *)(a1 + 4) -= n;
  if ( !*(_DWORD *)(*(_DWORD *)(a1 + 28) + 24) )
    *(_DWORD *)(a1 + 48) = sub_80C5628(*(_DWORD *)(a1 + 48), *(unsigned __int8 **)a1, n);
  memcpy(dest, *(const void **)a1, n);
  *(_DWORD *)a1 += n;
  *(_DWORD *)(a1 + 8) += n;
  return n;
}

//----- (080C6AC0) --------------------------------------------------------
int __cdecl sub_80C6AC0(int a1)
{
  int result; // eax

  *(_DWORD *)(a1 + 52) = 2 * *(_DWORD *)(a1 + 36);
  *(_WORD *)(*(_DWORD *)(a1 + 60) + 2 * *(_DWORD *)(a1 + 68) - 2) = 0;
  memset(*(void **)(a1 + 60), 0, 2 * *(_DWORD *)(a1 + 68) - 2);
  *(_DWORD *)(a1 + 120) = (unsigned __int16)word_81497A2[6 * *(_DWORD *)(a1 + 124)];
  *(_DWORD *)(a1 + 132) = (unsigned __int16)word_81497A0[6 * *(_DWORD *)(a1 + 124)];
  *(_DWORD *)(a1 + 136) = (unsigned __int16)word_81497A4[6 * *(_DWORD *)(a1 + 124)];
  *(_DWORD *)(a1 + 116) = (unsigned __int16)word_81497A6[6 * *(_DWORD *)(a1 + 124)];
  *(_DWORD *)(a1 + 100) = 0;
  *(_DWORD *)(a1 + 84) = 0;
  *(_DWORD *)(a1 + 108) = 0;
  *(_DWORD *)(a1 + 112) = 2;
  *(_DWORD *)(a1 + 88) = 2;
  *(_DWORD *)(a1 + 96) = 0;
  result = a1;
  *(_DWORD *)(a1 + 64) = 0;
  return result;
}
// 81497A0: using guessed type __int16 word_81497A0[];
// 81497A2: using guessed type __int16 word_81497A2[];
// 81497A4: using guessed type __int16 word_81497A4[];
// 81497A6: using guessed type __int16 word_81497A6[];

//----- (080C6BCD) --------------------------------------------------------
int __cdecl sub_80C6BCD(_DWORD *a1, unsigned int a2)
{
  char v3; // [esp+2h] [ebp-32h]
  char v4; // [esp+3h] [ebp-31h]
  unsigned int v5; // [esp+4h] [ebp-30h]
  unsigned int v6; // [esp+8h] [ebp-2Ch]
  int v7; // [esp+Ch] [ebp-28h]
  _BYTE *v8; // [esp+10h] [ebp-24h]
  _BYTE *v9; // [esp+10h] [ebp-24h]
  _BYTE *v10; // [esp+10h] [ebp-24h]
  _BYTE *v11; // [esp+10h] [ebp-24h]
  _BYTE *v12; // [esp+10h] [ebp-24h]
  _BYTE *v13; // [esp+10h] [ebp-24h]
  _BYTE *v14; // [esp+10h] [ebp-24h]
  _BYTE *v15; // [esp+10h] [ebp-24h]
  _BYTE *v16; // [esp+10h] [ebp-24h]
  _BYTE *v17; // [esp+10h] [ebp-24h]
  _BYTE *v18; // [esp+14h] [ebp-20h]
  _BYTE *v19; // [esp+14h] [ebp-20h]
  int v21; // [esp+1Ch] [ebp-18h]
  int v22; // [esp+20h] [ebp-14h]
  int v23; // [esp+28h] [ebp-Ch]
  int v24; // [esp+2Ch] [ebp-8h]
  unsigned int v25; // [esp+30h] [ebp-4h]

  v25 = a1[29];
  v18 = (_BYTE *)(a1[25] + a1[12]);
  v24 = a1[28];
  v23 = a1[34];
  if ( a1[25] <= (unsigned int)(a1[9] - 262) )
    v6 = 0;
  else
    v6 = a1[25] - a1[9] + 262;
  v22 = a1[14];
  v21 = a1[11];
  v5 = a1[25] + a1[12] + 258;
  v4 = v18[v24 - 1];
  v3 = v18[v24];
  if ( a1[28] >= a1[33] )
    v25 >>= 2;
  if ( (unsigned int)v23 > a1[27] )
    v23 = a1[27];
  do
  {
    v8 = (_BYTE *)(a2 + a1[12]);
    if ( v8[v24] == v3 && v8[v24 - 1] == v4 && *v8 == *v18 )
    {
      v9 = v8 + 1;
      if ( *v9 == v18[1] )
      {
        v19 = v18 + 2;
        v10 = v9 + 1;
        do
        {
          ++v19;
          v11 = v10 + 1;
          if ( *v19 != *v11 )
            break;
          ++v19;
          v12 = v11 + 1;
          if ( *v19 != *v12 )
            break;
          ++v19;
          v13 = v12 + 1;
          if ( *v19 != *v13 )
            break;
          ++v19;
          v14 = v13 + 1;
          if ( *v19 != *v14 )
            break;
          ++v19;
          v15 = v14 + 1;
          if ( *v19 != *v15 )
            break;
          ++v19;
          v16 = v15 + 1;
          if ( *v19 != *v16 )
            break;
          ++v19;
          v17 = v16 + 1;
          if ( *v19 != *v17 )
            break;
          ++v19;
          v10 = v17 + 1;
          if ( *v19 != *v10 )
            break;
        }
        while ( (unsigned int)v19 < v5 );
        v7 = 258 - (v5 - (_DWORD)v19);
        v18 = (_BYTE *)(v5 - 258);
        if ( v7 > v24 )
        {
          a1[26] = a2;
          v24 = v7;
          if ( v7 >= v23 )
            break;
          v4 = v18[v7 - 1];
          v3 = v18[v7];
        }
      }
    }
    a2 = *(unsigned __int16 *)(v22 + 2 * (a2 & v21));
    if ( a2 <= v6 )
      break;
    --v25;
  }
  while ( v25 );
  if ( (unsigned int)v24 > a1[27] )
    return a1[27];
  else
    return v24;
}

//----- (080C6E57) --------------------------------------------------------
int __cdecl sub_80C6E57(int a1)
{
  int result; // eax
  __int16 v2; // [esp+10h] [ebp-48h]
  __int16 v3; // [esp+20h] [ebp-38h]
  _WORD *v4; // [esp+3Ch] [ebp-1Ch]
  _WORD *v5; // [esp+3Ch] [ebp-1Ch]
  unsigned int v6; // [esp+40h] [ebp-18h]
  unsigned int v7; // [esp+40h] [ebp-18h]
  int v8; // [esp+44h] [ebp-14h]
  size_t v9; // [esp+44h] [ebp-14h]
  size_t n; // [esp+48h] [ebp-10h]
  int v11; // [esp+4Ch] [ebp-Ch]

  n = *(_DWORD *)(a1 + 36);
  do
  {
    v11 = *(_DWORD *)(a1 + 52) - *(_DWORD *)(a1 + 108) - *(_DWORD *)(a1 + 100);
    if ( v11 || *(_DWORD *)(a1 + 100) || *(_DWORD *)(a1 + 108) )
    {
      if ( v11 == -1 )
      {
        v11 = -2;
      }
      else if ( *(_DWORD *)(a1 + 100) >= n + *(_DWORD *)(a1 + 36) - 262 )
      {
        memcpy(*(void **)(a1 + 48), (const void *)(*(_DWORD *)(a1 + 48) + n), n);
        *(_DWORD *)(a1 + 104) -= n;
        *(_DWORD *)(a1 + 100) -= n;
        *(_DWORD *)(a1 + 84) -= n;
        v8 = *(_DWORD *)(a1 + 68);
        v4 = (_WORD *)(2 * v8 + *(_DWORD *)(a1 + 60));
        do
        {
          v6 = (unsigned __int16)*--v4;
          if ( v6 < n )
            v3 = 0;
          else
            v3 = v6 - n;
          *v4 = v3;
          --v8;
        }
        while ( v8 );
        v9 = n;
        v5 = (_WORD *)(2 * n + *(_DWORD *)(a1 + 56));
        do
        {
          v7 = (unsigned __int16)*--v5;
          if ( v7 < n )
            v2 = 0;
          else
            v2 = v7 - n;
          *v5 = v2;
          --v9;
        }
        while ( v9 );
        v11 += n;
      }
    }
    else
    {
      v11 = n;
    }
    result = *(_DWORD *)a1;
    if ( !*(_DWORD *)(*(_DWORD *)a1 + 4) )
      break;
    *(_DWORD *)(a1 + 108) += sub_80C6A0C(
                               *(_DWORD *)a1,
                               (void *)(*(_DWORD *)(a1 + 108) + *(_DWORD *)(a1 + 100) + *(_DWORD *)(a1 + 48)),
                               v11);
    if ( *(_DWORD *)(a1 + 108) > 2u )
    {
      *(_DWORD *)(a1 + 64) = *(unsigned __int8 *)(*(_DWORD *)(a1 + 48) + *(_DWORD *)(a1 + 100));
      *(_DWORD *)(a1 + 64) = *(_DWORD *)(a1 + 76) & (*(unsigned __int8 *)(*(_DWORD *)(a1 + 48)
                                                                        + *(_DWORD *)(a1 + 100)
                                                                        + 1) ^ (*(_DWORD *)(a1 + 64) << *(_BYTE *)(a1 + 80)));
    }
    result = a1;
    if ( *(_DWORD *)(a1 + 108) > 0x105u )
      break;
    result = *(_DWORD *)a1;
  }
  while ( *(_DWORD *)(*(_DWORD *)a1 + 4) );
  return result;
}

//----- (080C70A8) --------------------------------------------------------
int __cdecl sub_80C70A8(int *a1, int a2)
{
  int v3; // [esp+8h] [ebp-30h]
  int v4; // [esp+8h] [ebp-30h]
  int v5; // [esp+8h] [ebp-30h]
  int v6; // [esp+Ch] [ebp-2Ch]
  unsigned int v10; // [esp+30h] [ebp-8h]
  int v11; // [esp+34h] [ebp-4h]

  v11 = 0xFFFF;
  if ( (unsigned int)(a1[3] - 5) < 0xFFFF )
    v11 = a1[3] - 5;
  while ( 1 )
  {
    if ( (unsigned int)a1[27] <= 1 )
    {
      sub_80C6E57((int)a1);
      if ( !a1[27] && !a2 )
        return 0;
      if ( !a1[27] )
        break;
    }
    a1[25] += a1[27];
    a1[27] = 0;
    v10 = a1[21] + v11;
    if ( !a1[25] || a1[25] >= v10 )
    {
      a1[27] = a1[25] - v10;
      a1[25] = v10;
      v3 = a1[25] - a1[21];
      if ( a1[21] < 0 )
        sub_80CE57D((int)a1, 0, v3, 0);
      else
        sub_80CE57D((int)a1, (_BYTE *)(a1[12] + a1[21]), v3, 0);
      a1[21] = a1[25];
      sub_80C613D(*a1);
      if ( !*(_DWORD *)(*a1 + 16) )
        return 0;
    }
    if ( a1[25] - a1[21] >= (unsigned int)(a1[9] - 262) )
    {
      v4 = a1[25] - a1[21];
      if ( a1[21] < 0 )
        sub_80CE57D((int)a1, 0, v4, 0);
      else
        sub_80CE57D((int)a1, (_BYTE *)(a1[12] + a1[21]), v4, 0);
      a1[21] = a1[25];
      sub_80C613D(*a1);
      if ( !*(_DWORD *)(*a1 + 16) )
        return 0;
    }
  }
  v6 = a2 == 4;
  v5 = a1[25] - a1[21];
  if ( a1[21] < 0 )
    sub_80CE57D((int)a1, 0, v5, v6);
  else
    sub_80CE57D((int)a1, (_BYTE *)(a1[12] + a1[21]), v5, v6);
  a1[21] = a1[25];
  sub_80C613D(*a1);
  if ( *(_DWORD *)(*a1 + 16) )
  {
    if ( a2 == 4 )
      return 3;
    else
      return 1;
  }
  else if ( a2 == 4 )
  {
    return 2;
  }
  else
  {
    return 0;
  }
}

//----- (080C8044) --------------------------------------------------------
int __cdecl sub_80C8044(int a1, int a2, _DWORD *a3)
{
  int v3; // eax
  int result; // eax

  if ( a3 )
    *a3 = *(_DWORD *)(a1 + 60);
  if ( *(_DWORD *)a1 == 4 || *(_DWORD *)a1 == 5 )
    (*(void (__cdecl **)(_DWORD, _DWORD))(a2 + 36))(*(_DWORD *)(a2 + 40), *(_DWORD *)(a1 + 12));
  if ( *(_DWORD *)a1 == 6 )
    sub_80CA538(*(_DWORD *)(a1 + 4), a2);
  *(_DWORD *)a1 = 0;
  *(_DWORD *)(a1 + 28) = 0;
  *(_DWORD *)(a1 + 32) = 0;
  v3 = *(_DWORD *)(a1 + 40);
  *(_DWORD *)(a1 + 52) = v3;
  *(_DWORD *)(a1 + 48) = v3;
  result = a1;
  if ( *(_DWORD *)(a1 + 56) )
  {
    *(_DWORD *)(a1 + 60) = (*(int (__cdecl **)(_DWORD, _DWORD, _DWORD))(a1 + 56))(0, 0, 0);
    result = *(_DWORD *)(a1 + 60);
    *(_DWORD *)(a2 + 48) = result;
  }
  return result;
}

//----- (080C8114) --------------------------------------------------------
_DWORD *__cdecl sub_80C8114(int a1, int a2, int a3)
{
  _DWORD *v5; // [esp+10h] [ebp-8h]

  v5 = (_DWORD *)(*(int (__cdecl **)(_DWORD, int, int))(a1 + 32))(*(_DWORD *)(a1 + 40), 1, 64);
  if ( !v5 )
    return 0;
  v5[9] = (*(int (__cdecl **)(_DWORD, int, int))(a1 + 32))(*(_DWORD *)(a1 + 40), 8, 1440);
  if ( v5[9] )
  {
    v5[10] = (*(int (__cdecl **)(_DWORD, int, int))(a1 + 32))(*(_DWORD *)(a1 + 40), 1, a3);
    if ( v5[10] )
    {
      v5[11] = v5[10] + a3;
      v5[14] = a2;
      *v5 = 0;
      sub_80C8044((int)v5, a1, 0);
      return v5;
    }
    else
    {
      (*(void (__cdecl **)(_DWORD, _DWORD))(a1 + 36))(*(_DWORD *)(a1 + 40), v5[9]);
      (*(void (__cdecl **)(_DWORD, _DWORD *))(a1 + 36))(*(_DWORD *)(a1 + 40), v5);
      return 0;
    }
  }
  else
  {
    (*(void (__cdecl **)(_DWORD, _DWORD *))(a1 + 36))(*(_DWORD *)(a1 + 40), v5);
    return 0;
  }
}

//----- (080C8256) --------------------------------------------------------
int __cdecl sub_80C8256(int a1, int a2, int a3)
{
  int v4; // [esp+28h] [ebp-80h]
  int v5; // [esp+2Ch] [ebp-7Ch]
  unsigned int v6; // [esp+30h] [ebp-78h]
  unsigned int v7; // [esp+34h] [ebp-74h]
  int v8; // [esp+38h] [ebp-70h]
  int v9; // [esp+3Ch] [ebp-6Ch]
  int v10; // [esp+44h] [ebp-64h]
  int v11; // [esp+48h] [ebp-60h]
  int v12; // [esp+4Ch] [ebp-5Ch]
  int v13; // [esp+50h] [ebp-58h]
  size_t v14; // [esp+58h] [ebp-50h]
  int v15; // [esp+5Ch] [ebp-4Ch]
  int v17; // [esp+64h] [ebp-44h]
  unsigned int v18; // [esp+68h] [ebp-40h] BYREF
  unsigned int v19; // [esp+6Ch] [ebp-3Ch] BYREF
  int v20; // [esp+70h] [ebp-38h] BYREF
  int v21; // [esp+74h] [ebp-34h] BYREF
  int v22; // [esp+78h] [ebp-30h] BYREF
  int v23; // [esp+7Ch] [ebp-2Ch] BYREF
  int v24; // [esp+80h] [ebp-28h] BYREF
  int v25; // [esp+84h] [ebp-24h] BYREF
  size_t v26; // [esp+88h] [ebp-20h]
  void *dest; // [esp+8Ch] [ebp-1Ch]
  size_t v28; // [esp+90h] [ebp-18h]
  void *src; // [esp+94h] [ebp-14h]
  size_t v30; // [esp+98h] [ebp-10h]
  unsigned int v31; // [esp+9Ch] [ebp-Ch]
  size_t n; // [esp+A0h] [ebp-8h]
  int v33; // [esp+B8h] [ebp+10h]
  int v34; // [esp+B8h] [ebp+10h]

  src = *(void **)a2;
  v28 = *(_DWORD *)(a2 + 4);
  v31 = *(_DWORD *)(a1 + 32);
  v30 = *(_DWORD *)(a1 + 28);
  dest = *(void **)(a1 + 52);
  if ( (unsigned int)dest >= *(_DWORD *)(a1 + 48) )
    v15 = *(_DWORD *)(a1 + 44) - (_DWORD)dest;
  else
    v15 = *(_DWORD *)(a1 + 48) - (_DWORD)dest - 1;
  v26 = v15;
  while ( 1 )
  {
    if ( *(_DWORD *)a1 > 9u )
    {
      *(_DWORD *)(a1 + 32) = v31;
      *(_DWORD *)(a1 + 28) = v30;
      *(_DWORD *)(a2 + 4) = v28;
      *(_DWORD *)(a2 + 8) += (char *)src - *(_DWORD *)a2;
      *(_DWORD *)a2 = src;
      *(_DWORD *)(a1 + 52) = dest;
      return sub_80CC278(a1, (_DWORD *)a2, -2);
    }
    switch ( *(_DWORD *)a1 )
    {
      case 0:
        while ( v30 <= 2 )
        {
          if ( !v28 )
            goto LABEL_53;
          a3 = 0;
          --v28;
          v31 |= *(unsigned __int8 *)src << v30;
          src = (char *)src + 1;
          v30 += 8;
        }
        n = v31 & 7;
        *(_DWORD *)(a1 + 24) = v31 & 1;
        v14 = n >> 1;
        if ( n >> 1 == 1 )
        {
          sub_80CC247(&v25, &v24, &v23, &v22);
          *(_DWORD *)(a1 + 4) = sub_80C9764(v25, v24, v23, v22, a2);
          if ( !*(_DWORD *)(a1 + 4) )
            goto LABEL_119;
          v31 >>= 3;
          v30 -= 3;
          *(_DWORD *)a1 = 6;
          continue;
        }
        if ( !v14 )
        {
          v31 >>= 3;
          v30 -= 3;
          n = v30 & 7;
          v31 >>= n;
          v30 -= n;
          *(_DWORD *)a1 = 1;
          continue;
        }
        if ( v14 == 2 )
        {
          v31 >>= 3;
          v30 -= 3;
          *(_DWORD *)a1 = 3;
          continue;
        }
        if ( v14 != 3 )
          continue;
        v31 >>= 3;
        v30 -= 3;
        *(_DWORD *)a1 = 9;
        *(_DWORD *)(a2 + 24) = "invalid block type";
        *(_DWORD *)(a1 + 32) = v31;
        *(_DWORD *)(a1 + 28) = v30;
        *(_DWORD *)(a2 + 4) = v28;
        *(_DWORD *)(a2 + 8) += (char *)src - *(_DWORD *)a2;
        *(_DWORD *)a2 = src;
        *(_DWORD *)(a1 + 52) = dest;
        return sub_80CC278(a1, (_DWORD *)a2, -3);
      case 1:
        while ( v30 <= 0x1F )
        {
          if ( !v28 )
            goto LABEL_53;
          a3 = 0;
          --v28;
          v31 |= *(unsigned __int8 *)src << v30;
          src = (char *)src + 1;
          v30 += 8;
        }
        if ( ~v31 >> 16 == (unsigned __int16)v31 )
        {
          *(_DWORD *)(a1 + 4) = (unsigned __int16)v31;
          v30 = 0;
          v31 = 0;
          if ( *(_DWORD *)(a1 + 4) )
          {
            v13 = 2;
          }
          else if ( *(_DWORD *)(a1 + 24) )
          {
            v13 = 7;
          }
          else
          {
            v13 = 0;
          }
          *(_DWORD *)a1 = v13;
          continue;
        }
        *(_DWORD *)a1 = 9;
        *(_DWORD *)(a2 + 24) = "invalid stored block lengths";
        *(_DWORD *)(a1 + 32) = v31;
        *(_DWORD *)(a1 + 28) = v30;
        *(_DWORD *)(a2 + 4) = v28;
        *(_DWORD *)(a2 + 8) += (char *)src - *(_DWORD *)a2;
        *(_DWORD *)a2 = src;
        *(_DWORD *)(a1 + 52) = dest;
        return sub_80CC278(a1, (_DWORD *)a2, -3);
      case 2:
        if ( !v28 )
          goto LABEL_53;
        if ( !v26 )
        {
          if ( dest == *(void **)(a1 + 44) && *(_DWORD *)(a1 + 48) != *(_DWORD *)(a1 + 40) )
          {
            dest = *(void **)(a1 + 40);
            if ( (unsigned int)dest >= *(_DWORD *)(a1 + 48) )
              v12 = *(_DWORD *)(a1 + 44) - (_DWORD)dest;
            else
              v12 = *(_DWORD *)(a1 + 48) - (_DWORD)dest - 1;
            v26 = v12;
          }
          if ( !v26 )
          {
            *(_DWORD *)(a1 + 52) = dest;
            a3 = sub_80CC278(a1, (_DWORD *)a2, a3);
            dest = *(void **)(a1 + 52);
            if ( (unsigned int)dest >= *(_DWORD *)(a1 + 48) )
              v11 = *(_DWORD *)(a1 + 44) - (_DWORD)dest;
            else
              v11 = *(_DWORD *)(a1 + 48) - (_DWORD)dest - 1;
            v26 = v11;
            if ( dest == *(void **)(a1 + 44) && *(_DWORD *)(a1 + 48) != *(_DWORD *)(a1 + 40) )
            {
              dest = *(void **)(a1 + 40);
              if ( (unsigned int)dest >= *(_DWORD *)(a1 + 48) )
                v10 = *(_DWORD *)(a1 + 44) - (_DWORD)dest;
              else
                v10 = *(_DWORD *)(a1 + 48) - (_DWORD)dest - 1;
              v26 = v10;
            }
            if ( !v26 )
              goto LABEL_53;
          }
        }
        a3 = 0;
        n = *(_DWORD *)(a1 + 4);
        if ( n > v28 )
          n = v28;
        if ( n > v26 )
          n = v26;
        memcpy(dest, src, n);
        src = (char *)src + n;
        v28 -= n;
        dest = (char *)dest + n;
        v26 -= n;
        *(_DWORD *)(a1 + 4) -= n;
        if ( !*(_DWORD *)(a1 + 4) )
        {
          if ( *(_DWORD *)(a1 + 24) )
            v9 = 7;
          else
            v9 = 0;
          *(_DWORD *)a1 = v9;
        }
        continue;
      case 3:
        break;
      case 4:
        goto LABEL_72;
      case 5:
        goto LABEL_85;
      case 6:
        goto LABEL_121;
      case 7:
        goto LABEL_129;
      case 8:
        goto LABEL_135;
      case 9:
        *(_DWORD *)(a1 + 32) = v31;
        *(_DWORD *)(a1 + 28) = v30;
        *(_DWORD *)(a2 + 4) = v28;
        *(_DWORD *)(a2 + 8) += (char *)src - *(_DWORD *)a2;
        *(_DWORD *)a2 = src;
        *(_DWORD *)(a1 + 52) = dest;
        return sub_80CC278(a1, (_DWORD *)a2, -3);
    }
    while ( v30 <= 0xD )
    {
      if ( !v28 )
        goto LABEL_53;
      a3 = 0;
      --v28;
      v31 |= *(unsigned __int8 *)src << v30;
      src = (char *)src + 1;
      v30 += 8;
    }
    n = v31 & 0x3FFF;
    *(_DWORD *)(a1 + 4) = n;
    if ( (n & 0x1F) > 0x1D || ((n >> 5) & 0x1F) > 0x1D )
    {
      *(_DWORD *)a1 = 9;
      *(_DWORD *)(a2 + 24) = "too many length or distance symbols";
      *(_DWORD *)(a1 + 32) = v31;
      *(_DWORD *)(a1 + 28) = v30;
      *(_DWORD *)(a2 + 4) = v28;
      *(_DWORD *)(a2 + 8) += (char *)src - *(_DWORD *)a2;
      *(_DWORD *)a2 = src;
      *(_DWORD *)(a1 + 52) = dest;
      return sub_80CC278(a1, (_DWORD *)a2, -3);
    }
    n = ((n >> 5) & 0x1F) + (n & 0x1F) + 258;
    *(_DWORD *)(a1 + 12) = (*(int (__cdecl **)(_DWORD, size_t, int))(a2 + 32))(*(_DWORD *)(a2 + 40), n, 4);
    if ( !*(_DWORD *)(a1 + 12) )
      goto LABEL_119;
    v31 >>= 14;
    v30 -= 14;
    *(_DWORD *)(a1 + 8) = 0;
    *(_DWORD *)a1 = 4;
LABEL_72:
    while ( *(_DWORD *)(a1 + 8) < (unsigned int)((*(_DWORD *)(a1 + 4) >> 10) + 4) )
    {
      while ( v30 <= 2 )
      {
        if ( !v28 )
          goto LABEL_53;
        a3 = 0;
        --v28;
        v31 |= *(unsigned __int8 *)src << v30;
        src = (char *)src + 1;
        v30 += 8;
      }
      *(_DWORD *)(*(_DWORD *)(a1 + 12) + 4 * dword_8149820[(*(_DWORD *)(a1 + 8))++]) = v31 & 7;
      v31 >>= 3;
      v30 -= 3;
    }
    while ( *(_DWORD *)(a1 + 8) <= 0x12u )
      *(_DWORD *)(*(_DWORD *)(a1 + 12) + 4 * dword_8149820[(*(_DWORD *)(a1 + 8))++]) = 0;
    *(_DWORD *)(a1 + 16) = 7;
    n = sub_80CBF7B(*(int **)(a1 + 12), (unsigned int *)(a1 + 16), (_DWORD *)(a1 + 20), *(_DWORD *)(a1 + 36), a2);
    if ( n )
    {
      a3 = n;
      if ( n == -3 )
      {
        (*(void (__cdecl **)(_DWORD, _DWORD))(a2 + 36))(*(_DWORD *)(a2 + 40), *(_DWORD *)(a1 + 12));
        *(_DWORD *)a1 = 9;
      }
LABEL_53:
      *(_DWORD *)(a1 + 32) = v31;
      *(_DWORD *)(a1 + 28) = v30;
      *(_DWORD *)(a2 + 4) = v28;
      *(_DWORD *)(a2 + 8) += (char *)src - *(_DWORD *)a2;
      *(_DWORD *)a2 = src;
      *(_DWORD *)(a1 + 52) = dest;
      return sub_80CC278(a1, (_DWORD *)a2, a3);
    }
    *(_DWORD *)(a1 + 8) = 0;
    *(_DWORD *)a1 = 5;
LABEL_85:
    while ( 1 )
    {
      n = *(_DWORD *)(a1 + 4);
      if ( *(_DWORD *)(a1 + 8) >= ((n >> 5) & 0x1F) + (n & 0x1F) + 258 )
        break;
      n = *(_DWORD *)(a1 + 16);
      while ( v30 < n )
      {
        if ( !v28 )
          goto LABEL_53;
        a3 = 0;
        --v28;
        v31 |= *(unsigned __int8 *)src << v30;
        src = (char *)src + 1;
        v30 += 8;
      }
      v21 = *(_DWORD *)(a1 + 20) + 8 * (v31 & dword_8163EC0[n]);
      n = *(unsigned __int8 *)(v21 + 1);
      v18 = *(_DWORD *)(v21 + 4);
      if ( v18 > 0xF )
      {
        if ( v18 == 18 )
          v8 = 7;
        else
          v8 = v18 - 14;
        v20 = v8;
        if ( v18 == 18 )
          v7 = 11;
        else
          v7 = 3;
        v19 = v7;
        while ( v30 < n + v20 )
        {
          if ( !v28 )
            goto LABEL_53;
          a3 = 0;
          --v28;
          v31 |= *(unsigned __int8 *)src << v30;
          src = (char *)src + 1;
          v30 += 8;
        }
        v31 >>= n;
        v30 -= n;
        v19 += dword_8163EC0[v20] & v31;
        v31 >>= v20;
        v30 -= v20;
        v20 = *(_DWORD *)(a1 + 8);
        n = *(_DWORD *)(a1 + 4);
        if ( v19 + v20 > ((n >> 5) & 0x1F) + (n & 0x1F) + 258 || v18 == 16 && !v20 )
        {
          (*(void (__cdecl **)(_DWORD, _DWORD))(a2 + 36))(*(_DWORD *)(a2 + 40), *(_DWORD *)(a1 + 12));
          *(_DWORD *)a1 = 9;
          *(_DWORD *)(a2 + 24) = "invalid bit length repeat";
          *(_DWORD *)(a1 + 32) = v31;
          *(_DWORD *)(a1 + 28) = v30;
          *(_DWORD *)(a2 + 4) = v28;
          *(_DWORD *)(a2 + 8) += (char *)src - *(_DWORD *)a2;
          *(_DWORD *)a2 = src;
          *(_DWORD *)(a1 + 52) = dest;
          return sub_80CC278(a1, (_DWORD *)a2, -3);
        }
        if ( v18 == 16 )
          v6 = *(_DWORD *)(*(_DWORD *)(a1 + 12) + 4 * v20 - 4);
        else
          v6 = 0;
        v18 = v6;
        do
        {
          *(_DWORD *)(*(_DWORD *)(a1 + 12) + 4 * v20++) = v18;
          --v19;
        }
        while ( v19 );
        *(_DWORD *)(a1 + 8) = v20;
      }
      else
      {
        v31 >>= n;
        v30 -= n;
        *(_DWORD *)(*(_DWORD *)(a1 + 12) + 4 * (*(_DWORD *)(a1 + 8))++) = v18;
      }
    }
    *(_DWORD *)(a1 + 20) = 0;
    v18 = 9;
    v19 = 6;
    n = *(_DWORD *)(a1 + 4);
    n = sub_80CC064(
          (n & 0x1F) + 257,
          ((n >> 5) & 0x1F) + 1,
          *(int **)(a1 + 12),
          &v18,
          &v19,
          &v20,
          &v21,
          *(_DWORD *)(a1 + 36),
          a2);
    if ( n )
    {
      if ( n == -3 )
      {
        (*(void (__cdecl **)(_DWORD, _DWORD))(a2 + 36))(*(_DWORD *)(a2 + 40), *(_DWORD *)(a1 + 12));
        *(_DWORD *)a1 = 9;
      }
      v33 = n;
      *(_DWORD *)(a1 + 32) = v31;
      *(_DWORD *)(a1 + 28) = v30;
      *(_DWORD *)(a2 + 4) = v28;
      *(_DWORD *)(a2 + 8) += (char *)src - *(_DWORD *)a2;
      *(_DWORD *)a2 = src;
      *(_DWORD *)(a1 + 52) = dest;
      return sub_80CC278(a1, (_DWORD *)a2, v33);
    }
    (*(void (__cdecl **)(_DWORD, _DWORD))(a2 + 36))(*(_DWORD *)(a2 + 40), *(_DWORD *)(a1 + 12));
    v17 = sub_80C9764(v18, v19, v20, v21, a2);
    if ( !v17 )
    {
LABEL_119:
      *(_DWORD *)(a1 + 32) = v31;
      *(_DWORD *)(a1 + 28) = v30;
      *(_DWORD *)(a2 + 4) = v28;
      *(_DWORD *)(a2 + 8) += (char *)src - *(_DWORD *)a2;
      *(_DWORD *)a2 = src;
      *(_DWORD *)(a1 + 52) = dest;
      return sub_80CC278(a1, (_DWORD *)a2, -4);
    }
    *(_DWORD *)(a1 + 4) = v17;
    *(_DWORD *)a1 = 6;
LABEL_121:
    *(_DWORD *)(a1 + 32) = v31;
    *(_DWORD *)(a1 + 28) = v30;
    *(_DWORD *)(a2 + 4) = v28;
    *(_DWORD *)(a2 + 8) += (char *)src - *(_DWORD *)a2;
    *(_DWORD *)a2 = src;
    *(_DWORD *)(a1 + 52) = dest;
    v34 = sub_80C97C9((_DWORD *)a1, (_DWORD *)a2, a3);
    if ( v34 != 1 )
      return sub_80CC278(a1, (_DWORD *)a2, v34);
    a3 = 0;
    sub_80CA538(*(_DWORD *)(a1 + 4), a2);
    src = *(void **)a2;
    v28 = *(_DWORD *)(a2 + 4);
    v31 = *(_DWORD *)(a1 + 32);
    v30 = *(_DWORD *)(a1 + 28);
    dest = *(void **)(a1 + 52);
    v5 = (unsigned int)dest >= *(_DWORD *)(a1 + 48)
       ? *(_DWORD *)(a1 + 44) - (_DWORD)dest
       : *(_DWORD *)(a1 + 48) - (_DWORD)dest - 1;
    v26 = v5;
    if ( *(_DWORD *)(a1 + 24) )
      break;
    *(_DWORD *)a1 = 0;
  }
  *(_DWORD *)a1 = 7;
LABEL_129:
  *(_DWORD *)(a1 + 52) = dest;
  a3 = sub_80CC278(a1, (_DWORD *)a2, a3);
  dest = *(void **)(a1 + 52);
  if ( (unsigned int)dest >= *(_DWORD *)(a1 + 48) )
    v4 = *(_DWORD *)(a1 + 44) - (_DWORD)dest;
  else
    v4 = *(_DWORD *)(a1 + 48) - (_DWORD)dest - 1;
  v26 = v4;
  if ( *(_DWORD *)(a1 + 48) != *(_DWORD *)(a1 + 52) )
    goto LABEL_53;
  *(_DWORD *)a1 = 8;
LABEL_135:
  *(_DWORD *)(a1 + 32) = v31;
  *(_DWORD *)(a1 + 28) = v30;
  *(_DWORD *)(a2 + 4) = v28;
  *(_DWORD *)(a2 + 8) += (char *)src - *(_DWORD *)a2;
  *(_DWORD *)a2 = src;
  *(_DWORD *)(a1 + 52) = dest;
  return sub_80CC278(a1, (_DWORD *)a2, 1);
}
// 8149820: using guessed type int dword_8149820[19];
// 8163EC0: using guessed type int dword_8163EC0[17];

//----- (080C969D) --------------------------------------------------------
int __cdecl sub_80C969D(int a1, int a2)
{
  sub_80C8044(a1, a2, 0);
  (*(void (__cdecl **)(_DWORD, _DWORD))(a2 + 36))(*(_DWORD *)(a2 + 40), *(_DWORD *)(a1 + 40));
  (*(void (__cdecl **)(_DWORD, _DWORD))(a2 + 36))(*(_DWORD *)(a2 + 40), *(_DWORD *)(a1 + 36));
  (*(void (__cdecl **)(_DWORD, int))(a2 + 36))(*(_DWORD *)(a2 + 40), a1);
  return 0;
}

//----- (080C9712) --------------------------------------------------------
int __cdecl sub_80C9712(int a1, void *src, size_t n)
{
  int result; // eax

  memcpy(*(void **)(a1 + 40), src, n);
  *(_DWORD *)(a1 + 52) = *(_DWORD *)(a1 + 40) + n;
  result = *(_DWORD *)(a1 + 52);
  *(_DWORD *)(a1 + 48) = result;
  return result;
}

//----- (080C9753) --------------------------------------------------------
_BOOL4 __cdecl sub_80C9753(_DWORD *a1)
{
  return *a1 == 1;
}

//----- (080C9764) --------------------------------------------------------
int __cdecl sub_80C9764(char a1, char a2, int a3, int a4, int a5)
{
  int v6; // [esp+14h] [ebp-4h]

  v6 = (*(int (__cdecl **)(_DWORD, int, int))(a5 + 32))(*(_DWORD *)(a5 + 40), 1, 28);
  if ( v6 )
  {
    *(_DWORD *)v6 = 0;
    *(_BYTE *)(v6 + 16) = a1;
    *(_BYTE *)(v6 + 17) = a2;
    *(_DWORD *)(v6 + 20) = a3;
    *(_DWORD *)(v6 + 24) = a4;
  }
  return v6;
}

//----- (080C97C9) --------------------------------------------------------
int __cdecl sub_80C97C9(_DWORD *a1, _DWORD *a2, int a3)
{
  _BYTE *v3; // edx
  int v5; // [esp+2Ch] [ebp-5Ch]
  int v6; // [esp+30h] [ebp-58h]
  int v7; // [esp+34h] [ebp-54h]
  int v8; // [esp+38h] [ebp-50h]
  int v9; // [esp+3Ch] [ebp-4Ch]
  int v10; // [esp+40h] [ebp-48h]
  int v11; // [esp+44h] [ebp-44h]
  int v12; // [esp+4Ch] [ebp-3Ch]
  int v13; // [esp+50h] [ebp-38h]
  int v15; // [esp+58h] [ebp-30h]
  _BYTE *i; // [esp+5Ch] [ebp-2Ch]
  unsigned int v17; // [esp+60h] [ebp-28h]
  _BYTE *v18; // [esp+64h] [ebp-24h]
  unsigned int v19; // [esp+68h] [ebp-20h]
  unsigned __int8 *v20; // [esp+6Ch] [ebp-1Ch]
  unsigned int v21; // [esp+70h] [ebp-18h]
  unsigned int v22; // [esp+74h] [ebp-14h]
  int v23; // [esp+78h] [ebp-10h]
  int v24; // [esp+78h] [ebp-10h]
  unsigned __int8 *v25; // [esp+7Ch] [ebp-Ch]
  unsigned __int8 *v26; // [esp+7Ch] [ebp-Ch]
  unsigned int v27; // [esp+80h] [ebp-8h]
  unsigned int v28; // [esp+80h] [ebp-8h]
  unsigned int v29; // [esp+80h] [ebp-8h]
  unsigned int v30; // [esp+80h] [ebp-8h]
  int v31; // [esp+98h] [ebp+10h]

  v15 = a1[1];
  v20 = (unsigned __int8 *)*a2;
  v19 = a2[1];
  v22 = a1[8];
  v21 = a1[7];
  v18 = (_BYTE *)a1[13];
  if ( (unsigned int)v18 >= a1[12] )
    v13 = a1[11] - (_DWORD)v18;
  else
    v13 = a1[12] - (_DWORD)v18 - 1;
  v17 = v13;
  while ( 2 )
  {
    if ( *(_DWORD *)v15 > 9u )
    {
      a1[8] = v22;
      a1[7] = v21;
      a2[1] = v19;
      a2[2] += &v20[-*a2];
      *a2 = v20;
      a1[13] = v18;
      return sub_80CC278((int)a1, a2, -2);
    }
    switch ( *(_DWORD *)v15 )
    {
      case 0:
        if ( v17 <= 0x101 || v19 <= 9 )
          goto LABEL_17;
        a1[8] = v22;
        a1[7] = v21;
        a2[1] = v19;
        a2[2] += &v20[-*a2];
        *a2 = v20;
        a1[13] = v18;
        a3 = sub_80CA558(
               *(unsigned __int8 *)(v15 + 16),
               *(unsigned __int8 *)(v15 + 17),
               *(_DWORD *)(v15 + 20),
               *(_DWORD *)(v15 + 24),
               a1,
               a2);
        v20 = (unsigned __int8 *)*a2;
        v19 = a2[1];
        v22 = a1[8];
        v21 = a1[7];
        v18 = (_BYTE *)a1[13];
        v12 = (unsigned int)v18 >= a1[12] ? a1[11] - (_DWORD)v18 : a1[12] - (_DWORD)v18 - 1;
        v17 = v12;
        if ( !a3 )
        {
LABEL_17:
          *(_DWORD *)(v15 + 12) = *(unsigned __int8 *)(v15 + 16);
          *(_DWORD *)(v15 + 8) = *(_DWORD *)(v15 + 20);
          *(_DWORD *)v15 = 1;
          goto LABEL_18;
        }
        if ( a3 == 1 )
          v11 = 7;
        else
          v11 = 9;
        *(_DWORD *)v15 = v11;
        continue;
      case 1:
LABEL_18:
        v27 = *(_DWORD *)(v15 + 12);
        while ( 2 )
        {
          if ( v21 < v27 )
          {
            if ( v19 )
            {
              a3 = 0;
              --v19;
              v22 |= *v20++ << v21;
              v21 += 8;
              continue;
            }
            goto LABEL_52;
          }
          break;
        }
        v25 = (unsigned __int8 *)(*(_DWORD *)(v15 + 8) + 8 * (v22 & dword_8163EC0[v27]));
        v22 >>= v25[1];
        v21 -= v25[1];
        v23 = *v25;
        if ( *v25 )
        {
          if ( (v23 & 0x10) != 0 )
          {
            *(_DWORD *)(v15 + 8) = v23 & 0xF;
            *(_DWORD *)(v15 + 4) = *((_DWORD *)v25 + 1);
            *(_DWORD *)v15 = 2;
          }
          else if ( (v23 & 0x40) != 0 )
          {
            if ( (v23 & 0x20) == 0 )
            {
              *(_DWORD *)v15 = 9;
              a2[6] = "invalid literal/length code";
              a1[8] = v22;
              a1[7] = v21;
              a2[1] = v19;
              a2[2] += &v20[-*a2];
              *a2 = v20;
              a1[13] = v18;
              return sub_80CC278((int)a1, a2, -3);
            }
            *(_DWORD *)v15 = 7;
          }
          else
          {
            *(_DWORD *)(v15 + 12) = v23;
            *(_DWORD *)(v15 + 8) = &v25[8 * *((_DWORD *)v25 + 1)];
          }
        }
        else
        {
          *(_DWORD *)(v15 + 8) = *((_DWORD *)v25 + 1);
          *(_DWORD *)v15 = 6;
        }
        continue;
      case 2:
        v28 = *(_DWORD *)(v15 + 8);
        while ( 2 )
        {
          if ( v21 < v28 )
          {
            if ( v19 )
            {
              a3 = 0;
              --v19;
              v22 |= *v20++ << v21;
              v21 += 8;
              continue;
            }
            goto LABEL_52;
          }
          break;
        }
        *(_DWORD *)(v15 + 4) += v22 & dword_8163EC0[v28];
        v22 >>= v28;
        v21 -= v28;
        *(_DWORD *)(v15 + 12) = *(unsigned __int8 *)(v15 + 17);
        *(_DWORD *)(v15 + 8) = *(_DWORD *)(v15 + 24);
        *(_DWORD *)v15 = 3;
LABEL_38:
        v29 = *(_DWORD *)(v15 + 12);
        while ( v21 < v29 )
        {
          if ( !v19 )
            goto LABEL_52;
          a3 = 0;
          --v19;
          v22 |= *v20++ << v21;
          v21 += 8;
        }
        v26 = (unsigned __int8 *)(*(_DWORD *)(v15 + 8) + 8 * (v22 & dword_8163EC0[v29]));
        v22 >>= v26[1];
        v21 -= v26[1];
        v24 = *v26;
        if ( (v24 & 0x10) != 0 )
        {
          *(_DWORD *)(v15 + 8) = v24 & 0xF;
          *(_DWORD *)(v15 + 12) = *((_DWORD *)v26 + 1);
          *(_DWORD *)v15 = 4;
        }
        else
        {
          if ( (v24 & 0x40) != 0 )
          {
            *(_DWORD *)v15 = 9;
            a2[6] = "invalid distance code";
            a1[8] = v22;
            a1[7] = v21;
            a2[1] = v19;
            a2[2] += &v20[-*a2];
            *a2 = v20;
            a1[13] = v18;
            return sub_80CC278((int)a1, a2, -3);
          }
          *(_DWORD *)(v15 + 12) = v24;
          *(_DWORD *)(v15 + 8) = &v26[8 * *((_DWORD *)v26 + 1)];
        }
        continue;
      case 3:
        goto LABEL_38;
      case 4:
        v30 = *(_DWORD *)(v15 + 8);
LABEL_49:
        if ( v21 >= v30 )
        {
          *(_DWORD *)(v15 + 12) += v22 & dword_8163EC0[v30];
          v22 >>= v30;
          v21 -= v30;
          *(_DWORD *)v15 = 5;
LABEL_54:
          for ( i = &v18[-*(_DWORD *)(v15 + 12)]; (unsigned int)i < a1[10]; i += a1[11] - a1[10] )
            ;
          while ( *(_DWORD *)(v15 + 4) )
          {
            if ( !v17 )
            {
              if ( v18 == (_BYTE *)a1[11] && a1[12] != a1[10] )
              {
                v18 = (_BYTE *)a1[10];
                if ( (unsigned int)v18 >= a1[12] )
                  v10 = a1[11] - (_DWORD)v18;
                else
                  v10 = a1[12] - (_DWORD)v18 - 1;
                v17 = v10;
              }
              if ( !v17 )
              {
                a1[13] = v18;
                v31 = sub_80CC278((int)a1, a2, a3);
                v18 = (_BYTE *)a1[13];
                if ( (unsigned int)v18 >= a1[12] )
                  v9 = a1[11] - (_DWORD)v18;
                else
                  v9 = a1[12] - (_DWORD)v18 - 1;
                v17 = v9;
                if ( v18 == (_BYTE *)a1[11] && a1[12] != a1[10] )
                {
                  v18 = (_BYTE *)a1[10];
                  if ( (unsigned int)v18 >= a1[12] )
                    v8 = a1[11] - (_DWORD)v18;
                  else
                    v8 = a1[12] - (_DWORD)v18 - 1;
                  v17 = v8;
                }
                if ( !v17 )
                {
LABEL_99:
                  a1[8] = v22;
                  a1[7] = v21;
                  a2[1] = v19;
                  a2[2] += &v20[-*a2];
                  *a2 = v20;
                  a1[13] = v18;
                  return sub_80CC278((int)a1, a2, v31);
                }
              }
            }
            a3 = 0;
            v3 = i++;
            *v18++ = *v3;
            --v17;
            if ( i == (_BYTE *)a1[11] )
              i = (_BYTE *)a1[10];
            --*(_DWORD *)(v15 + 4);
          }
          *(_DWORD *)v15 = 0;
          continue;
        }
        if ( v19 )
        {
          a3 = 0;
          --v19;
          v22 |= *v20++ << v21;
          v21 += 8;
          goto LABEL_49;
        }
LABEL_52:
        a1[8] = v22;
        a1[7] = v21;
        a2[1] = 0;
        a2[2] += &v20[-*a2];
        *a2 = v20;
        a1[13] = v18;
        return sub_80CC278((int)a1, a2, a3);
      case 5:
        goto LABEL_54;
      case 6:
        if ( !v17 )
        {
          if ( v18 == (_BYTE *)a1[11] && a1[12] != a1[10] )
          {
            v18 = (_BYTE *)a1[10];
            if ( (unsigned int)v18 >= a1[12] )
              v7 = a1[11] - (_DWORD)v18;
            else
              v7 = a1[12] - (_DWORD)v18 - 1;
            v17 = v7;
          }
          if ( !v17 )
          {
            a1[13] = v18;
            v31 = sub_80CC278((int)a1, a2, a3);
            v18 = (_BYTE *)a1[13];
            if ( (unsigned int)v18 >= a1[12] )
              v6 = a1[11] - (_DWORD)v18;
            else
              v6 = a1[12] - (_DWORD)v18 - 1;
            v17 = v6;
            if ( v18 == (_BYTE *)a1[11] && a1[12] != a1[10] )
            {
              v18 = (_BYTE *)a1[10];
              if ( (unsigned int)v18 >= a1[12] )
                v5 = a1[11] - (_DWORD)v18;
              else
                v5 = a1[12] - (_DWORD)v18 - 1;
              v17 = v5;
            }
            if ( !v17 )
              goto LABEL_99;
          }
        }
        a3 = 0;
        *v18++ = *(_BYTE *)(v15 + 8);
        --v17;
        *(_DWORD *)v15 = 0;
        continue;
      case 7:
        if ( v21 > 7 )
        {
          v21 -= 8;
          ++v19;
          --v20;
        }
        a1[13] = v18;
        v31 = sub_80CC278((int)a1, a2, a3);
        v18 = (_BYTE *)a1[13];
        if ( (_BYTE *)a1[12] != v18 )
          goto LABEL_99;
        *(_DWORD *)v15 = 8;
LABEL_105:
        a1[8] = v22;
        a1[7] = v21;
        a2[1] = v19;
        a2[2] += &v20[-*a2];
        *a2 = v20;
        a1[13] = v18;
        return sub_80CC278((int)a1, a2, 1);
      case 8:
        goto LABEL_105;
      case 9:
        a1[8] = v22;
        a1[7] = v21;
        a2[1] = v19;
        a2[2] += &v20[-*a2];
        *a2 = v20;
        a1[13] = v18;
        return sub_80CC278((int)a1, a2, -3);
    }
  }
}
// 8163EC0: using guessed type int dword_8163EC0[17];

//----- (080CA538) --------------------------------------------------------
int __cdecl sub_80CA538(int a1, int a2)
{
  return (*(int (__cdecl **)(_DWORD, int))(a2 + 36))(*(_DWORD *)(a2 + 40), a1);
}

//----- (080CA558) --------------------------------------------------------
int __cdecl sub_80CA558(int a1, int a2, int a3, int a4, _DWORD *a5, _DWORD *a6)
{
  _BYTE *v6; // edx
  _BYTE *v7; // edx
  _BYTE *v8; // edx
  _BYTE *v9; // edx
  _BYTE *v10; // edx
  _BYTE *v11; // edx
  unsigned int v13; // [esp+0h] [ebp-60h]
  unsigned int v14; // [esp+8h] [ebp-58h]
  unsigned int v15; // [esp+10h] [ebp-50h]
  unsigned int v16; // [esp+18h] [ebp-48h]
  int v17; // [esp+20h] [ebp-40h]
  _BYTE *v19; // [esp+28h] [ebp-38h]
  _BYTE *v20; // [esp+28h] [ebp-38h]
  _BYTE *v21; // [esp+28h] [ebp-38h]
  _BYTE *v22; // [esp+28h] [ebp-38h]
  int v23; // [esp+2Ch] [ebp-34h]
  unsigned int v24; // [esp+30h] [ebp-30h]
  unsigned int v25; // [esp+30h] [ebp-30h]
  unsigned int v26; // [esp+30h] [ebp-30h]
  unsigned int v27; // [esp+30h] [ebp-30h]
  int v28; // [esp+34h] [ebp-2Ch]
  int v29; // [esp+38h] [ebp-28h]
  unsigned int v30; // [esp+3Ch] [ebp-24h]
  _BYTE *v31; // [esp+40h] [ebp-20h]
  _BYTE *v32; // [esp+40h] [ebp-20h]
  _BYTE *v33; // [esp+40h] [ebp-20h]
  unsigned int v34; // [esp+44h] [ebp-1Ch]
  unsigned __int8 *v35; // [esp+48h] [ebp-18h]
  unsigned __int8 *v36; // [esp+48h] [ebp-18h]
  unsigned __int8 *v37; // [esp+48h] [ebp-18h]
  unsigned __int8 *v38; // [esp+48h] [ebp-18h]
  unsigned __int8 *v39; // [esp+48h] [ebp-18h]
  unsigned int v40; // [esp+4Ch] [ebp-14h]
  unsigned int i; // [esp+4Ch] [ebp-14h]
  unsigned int v42; // [esp+50h] [ebp-10h]
  unsigned int v43; // [esp+50h] [ebp-10h]
  int v44; // [esp+54h] [ebp-Ch]
  int v45; // [esp+54h] [ebp-Ch]
  int j; // [esp+54h] [ebp-Ch]
  unsigned int v47; // [esp+54h] [ebp-Ch]
  unsigned int v48; // [esp+54h] [ebp-Ch]
  unsigned __int8 *v49; // [esp+58h] [ebp-8h]
  unsigned __int8 *v50; // [esp+58h] [ebp-8h]

  v35 = (unsigned __int8 *)*a6;
  v34 = a6[1];
  v42 = a5[8];
  v40 = a5[7];
  v31 = (_BYTE *)a5[13];
  if ( (unsigned int)v31 >= a5[12] )
    v17 = a5[11] - (_DWORD)v31;
  else
    v17 = a5[12] - (_DWORD)v31 - 1;
  v30 = v17;
  v29 = dword_8163EC0[a1];
  v28 = dword_8163EC0[a2];
  while ( 1 )
  {
    while ( v40 <= 0x13 )
    {
      --v34;
      v42 |= *v35++ << v40;
      v40 += 8;
    }
    v49 = (unsigned __int8 *)(a3 + 8 * (v42 & v29));
    v44 = *v49;
    if ( *v49 )
      break;
    v42 >>= v49[1];
    v40 -= v49[1];
    *v31++ = v49[4];
    --v30;
LABEL_47:
    if ( v30 <= 0x101 || v34 <= 9 )
    {
      v13 = a6[1] - v34;
      if ( v13 > v40 >> 3 )
        v13 = v40 >> 3;
      v39 = &v35[-v13];
      a5[8] = v42;
      a5[7] = v40 - 8 * v13;
      a6[1] = v13 + v34;
      a6[2] += &v39[-*a6];
      *a6 = v39;
      a5[13] = v31;
      return 0;
    }
  }
  while ( 1 )
  {
    v42 >>= v49[1];
    v40 -= v49[1];
    if ( (v44 & 0x10) != 0 )
      break;
    if ( (v44 & 0x40) != 0 )
    {
      if ( (v44 & 0x20) != 0 )
      {
        v15 = a6[1] - v34;
        if ( v15 > v40 >> 3 )
          v15 = v40 >> 3;
        v37 = &v35[-v15];
        a5[8] = v42;
        a5[7] = v40 - 8 * v15;
        a6[1] = v15 + v34;
        a6[2] += &v37[-*a6];
        *a6 = v37;
        a5[13] = v31;
        return 1;
      }
      else
      {
        a6[6] = "invalid literal/length code";
        v14 = a6[1] - v34;
        if ( v14 > v40 >> 3 )
          v14 = v40 >> 3;
        v38 = &v35[-v14];
        a5[8] = v42;
        a5[7] = v40 - 8 * v14;
        a6[1] = v14 + v34;
        a6[2] += &v38[-*a6];
        *a6 = v38;
        a5[13] = v31;
        return -3;
      }
    }
    v49 += 8 * (v42 & dword_8163EC0[v44]) + 8 * *((_DWORD *)v49 + 1);
    v44 = *v49;
    if ( !*v49 )
    {
      v42 >>= v49[1];
      v40 -= v49[1];
      *v31++ = v49[4];
      --v30;
      goto LABEL_47;
    }
  }
  v45 = v44 & 0xF;
  v24 = *((_DWORD *)v49 + 1) + (v42 & dword_8163EC0[v45]);
  v43 = v42 >> v45;
  for ( i = v40 - v45; i <= 0xE; i += 8 )
  {
    --v34;
    v43 |= *v35++ << i;
  }
  v50 = (unsigned __int8 *)(a4 + 8 * (v43 & v28));
  for ( j = *v50; ; j = *v50 )
  {
    v43 >>= v50[1];
    i -= v50[1];
    if ( (j & 0x10) != 0 )
    {
      v47 = j & 0xF;
      while ( i < v47 )
      {
        --v34;
        v43 |= *v35++ << i;
        i += 8;
      }
      v23 = *((_DWORD *)v50 + 1) + (v43 & dword_8163EC0[v47]);
      v42 = v43 >> v47;
      v40 = i - v47;
      v30 -= v24;
      v19 = &v31[-v23];
      if ( (unsigned int)&v31[-v23] >= a5[10] )
      {
        *v31 = *v19;
        v33 = v31 + 1;
        v10 = v19 + 1;
        v22 = v19 + 2;
        *v33 = *v10;
        v31 = v33 + 1;
        v27 = v24 - 2;
        do
        {
          v11 = v22++;
          *v31++ = *v11;
          --v27;
        }
        while ( v27 );
      }
      else
      {
        do
          v19 += a5[11] - a5[10];
        while ( (unsigned int)v19 < a5[10] );
        v48 = a5[11] - (_DWORD)v19;
        if ( v24 <= v48 )
        {
          *v31 = *v19;
          v32 = v31 + 1;
          v8 = v19 + 1;
          v21 = v19 + 2;
          *v32 = *v8;
          v31 = v32 + 1;
          v26 = v24 - 2;
          do
          {
            v9 = v21++;
            *v31++ = *v9;
            --v26;
          }
          while ( v26 );
        }
        else
        {
          v25 = v24 - v48;
          do
          {
            v6 = v19++;
            *v31++ = *v6;
            --v48;
          }
          while ( v48 );
          v20 = (_BYTE *)a5[10];
          do
          {
            v7 = v20++;
            *v31++ = *v7;
            --v25;
          }
          while ( v25 );
        }
      }
      goto LABEL_47;
    }
    if ( (j & 0x40) != 0 )
      break;
    v50 += 8 * (v43 & dword_8163EC0[j]) + 8 * *((_DWORD *)v50 + 1);
  }
  a6[6] = "invalid distance code";
  v16 = a6[1] - v34;
  if ( v16 > i >> 3 )
    v16 = i >> 3;
  v36 = &v35[-v16];
  a5[8] = v43;
  a5[7] = i - 8 * v16;
  a6[1] = v16 + v34;
  a6[2] += &v36[-*a6];
  *a6 = v36;
  a5[13] = v31;
  return -3;
}
// 8163EC0: using guessed type int dword_8163EC0[17];

//----- (080CAC68) --------------------------------------------------------
int __cdecl sub_80CAC68(_DWORD *a1)
{
  int v2; // [esp+Ch] [ebp-Ch]

  if ( !a1 || !a1[7] )
    return -2;
  a1[5] = 0;
  a1[2] = 0;
  a1[6] = 0;
  if ( *(_DWORD *)(a1[7] + 12) )
    v2 = 7;
  else
    v2 = 0;
  *(_DWORD *)a1[7] = v2;
  sub_80C8044(*(_DWORD *)(a1[7] + 20), (int)a1, 0);
  return 0;
}

//----- (080CACFD) --------------------------------------------------------
int __cdecl sub_80CACFD(_DWORD *a1)
{
  if ( !a1 || !a1[7] || !a1[9] )
    return -2;
  if ( *(_DWORD *)(a1[7] + 20) )
    sub_80C969D(*(_DWORD *)(a1[7] + 20), (int)a1);
  ((void (__cdecl *)(_DWORD, _DWORD))a1[9])(a1[10], a1[7]);
  a1[7] = 0;
  return 0;
}

//----- (080CAD79) --------------------------------------------------------
int __cdecl sub_80CAD79(_DWORD *a1, int a2, _BYTE *a3, int a4)
{
  _DWORD *v4; // eax
  int v6; // [esp+8h] [ebp-20h]
  int v7; // [esp+1Ch] [ebp-Ch]

  if ( !a3 || *a3 != 49 || a4 != 56 )
    return -6;
  if ( !a1 )
    return -2;
  a1[6] = 0;
  if ( !a1[8] )
  {
    a1[8] = sub_80D1096;
    a1[10] = 0;
  }
  if ( !a1[9] )
    a1[9] = sub_80D10AD;
  a1[7] = ((int (__cdecl *)(_DWORD, int, int))a1[8])(a1[10], 1, 24);
  if ( !a1[7] )
    return -4;
  *(_DWORD *)(a1[7] + 20) = 0;
  *(_DWORD *)(a1[7] + 12) = 0;
  if ( a2 < 0 )
  {
    a2 = -a2;
    *(_DWORD *)(a1[7] + 12) = 1;
  }
  if ( a2 > 7 && a2 <= 15 )
  {
    *(_DWORD *)(a1[7] + 16) = a2;
    v7 = a1[7];
    v6 = 1 << a2;
    if ( *(_DWORD *)(v7 + 12) )
      v4 = sub_80C8114((int)a1, 0, v6);
    else
      v4 = sub_80C8114((int)a1, (int)sub_80C5628, v6);
    *(_DWORD *)(v7 + 20) = v4;
    if ( *(_DWORD *)(v7 + 20) )
    {
      sub_80CAC68(a1);
      return 0;
    }
    else
    {
      sub_80CACFD(a1);
      return -4;
    }
  }
  else
  {
    sub_80CACFD(a1);
    return -2;
  }
}

//----- (080CAF10) --------------------------------------------------------
int __cdecl sub_80CAF10(_DWORD *a1, _BYTE *a2, int a3)
{
  return sub_80CAD79(a1, 15, a2, a3);
}

//----- (080CAF39) --------------------------------------------------------
int __cdecl sub_80CAF39(unsigned __int8 **a1, int a2)
{
  unsigned __int8 *v2; // ecx
  int v3; // eax
  unsigned int v4; // ebx
  unsigned __int8 *v5; // ecx
  unsigned __int8 *v6; // ebx
  unsigned __int8 *v7; // ebx
  unsigned __int8 *v8; // ebx
  unsigned __int8 *v9; // ecx
  unsigned __int8 *v10; // ebx
  unsigned __int8 *v11; // ebx
  unsigned __int8 *v12; // ebx
  int v14; // [esp+14h] [ebp-14h]
  int v15; // [esp+18h] [ebp-10h]
  int v16; // [esp+1Ch] [ebp-Ch]
  int v17; // [esp+20h] [ebp-8h]

  if ( !a1 || !a1[7] || !*a1 )
    return -2;
  if ( a2 == 4 )
    v14 = -5;
  else
    v14 = 0;
  v17 = -5;
  while ( 2 )
  {
    switch ( *(_DWORD *)a1[7] )
    {
      case 0:
        if ( a1[1] )
        {
          v17 = v14;
          v2 = a1[7];
          --a1[1];
          ++a1[2];
          *((_DWORD *)v2 + 1) = **a1;
          v3 = *((_DWORD *)v2 + 1) & 0xF;
          ++*a1;
          if ( v3 != 8 )
          {
            *(_DWORD *)a1[7] = 13;
            a1[6] = "unknown compression method";
            *((_DWORD *)a1[7] + 1) = 5;
            continue;
          }
          if ( (unsigned int)((*((_DWORD *)a1[7] + 1) >> 4) + 8) > *((_DWORD *)a1[7] + 4) )
          {
            *(_DWORD *)a1[7] = 13;
            a1[6] = "invalid window size";
            *((_DWORD *)a1[7] + 1) = 5;
            continue;
          }
          *(_DWORD *)a1[7] = 1;
          goto LABEL_17;
        }
        v15 = v17;
        break;
      case 1:
LABEL_17:
        if ( a1[1] )
        {
          v17 = v14;
          --a1[1];
          ++a1[2];
          v16 = *(*a1)++;
          v4 = v16 + (*((_DWORD *)a1[7] + 1) << 8);
          if ( v4 != 31
                   * ((unsigned int)(((v4 * (unsigned __int64)(unsigned int)&unk_8421085) >> 32)
                                   + ((unsigned int)(v4 - ((v4 * (unsigned __int64)(unsigned int)&unk_8421085) >> 32)) >> 1)) >> 4) )
          {
            *(_DWORD *)a1[7] = 13;
            a1[6] = "incorrect header check";
            *((_DWORD *)a1[7] + 1) = 5;
            continue;
          }
          if ( (v16 & 0x20) == 0 )
          {
            *(_DWORD *)a1[7] = 7;
            continue;
          }
          *(_DWORD *)a1[7] = 2;
          goto LABEL_24;
        }
        v15 = v17;
        break;
      case 2:
LABEL_24:
        if ( a1[1] )
        {
          v17 = v14;
          v5 = a1[7];
          --a1[1];
          ++a1[2];
          *((_DWORD *)v5 + 2) = *(*a1)++ << 24;
          *(_DWORD *)a1[7] = 3;
          goto LABEL_27;
        }
        v15 = v17;
        break;
      case 3:
LABEL_27:
        if ( a1[1] )
        {
          v17 = v14;
          v6 = a1[7];
          --a1[1];
          ++a1[2];
          *((_DWORD *)v6 + 2) += *(*a1)++ << 16;
          *(_DWORD *)a1[7] = 4;
          goto LABEL_30;
        }
        v15 = v17;
        break;
      case 4:
LABEL_30:
        if ( a1[1] )
        {
          v17 = v14;
          v7 = a1[7];
          --a1[1];
          ++a1[2];
          *((_DWORD *)v7 + 2) += *(*a1)++ << 8;
          *(_DWORD *)a1[7] = 5;
          goto LABEL_33;
        }
        v15 = v17;
        break;
      case 5:
LABEL_33:
        if ( a1[1] )
        {
          v8 = a1[7];
          --a1[1];
          ++a1[2];
          *((_DWORD *)v8 + 2) += *(*a1)++;
          a1[12] = (unsigned __int8 *)*((_DWORD *)a1[7] + 2);
          *(_DWORD *)a1[7] = 6;
          v15 = 2;
        }
        else
        {
          v15 = v17;
        }
        break;
      case 6:
        *(_DWORD *)a1[7] = 13;
        a1[6] = "need dictionary";
        *((_DWORD *)a1[7] + 1) = 0;
        v15 = -2;
        break;
      case 7:
        v17 = sub_80C8256(*((_DWORD *)a1[7] + 5), (int)a1, v17);
        if ( v17 == -3 )
        {
          *(_DWORD *)a1[7] = 13;
          *((_DWORD *)a1[7] + 1) = 0;
          continue;
        }
        if ( !v17 )
          v17 = v14;
        if ( v17 == 1 )
        {
          v17 = v14;
          sub_80C8044(*((_DWORD *)a1[7] + 5), (int)a1, (_DWORD *)a1[7] + 1);
          if ( *((_DWORD *)a1[7] + 3) )
          {
            *(_DWORD *)a1[7] = 12;
            continue;
          }
          *(_DWORD *)a1[7] = 8;
          goto LABEL_46;
        }
        v15 = v17;
        break;
      case 8:
LABEL_46:
        if ( a1[1] )
        {
          v17 = v14;
          v9 = a1[7];
          --a1[1];
          ++a1[2];
          *((_DWORD *)v9 + 2) = *(*a1)++ << 24;
          *(_DWORD *)a1[7] = 9;
          goto LABEL_49;
        }
        v15 = v17;
        break;
      case 9:
LABEL_49:
        if ( a1[1] )
        {
          v17 = v14;
          v10 = a1[7];
          --a1[1];
          ++a1[2];
          *((_DWORD *)v10 + 2) += *(*a1)++ << 16;
          *(_DWORD *)a1[7] = 10;
          goto LABEL_52;
        }
        v15 = v17;
        break;
      case 0xA:
LABEL_52:
        if ( a1[1] )
        {
          v17 = v14;
          v11 = a1[7];
          --a1[1];
          ++a1[2];
          *((_DWORD *)v11 + 2) += *(*a1)++ << 8;
          *(_DWORD *)a1[7] = 11;
          goto LABEL_55;
        }
        v15 = v17;
        break;
      case 0xB:
LABEL_55:
        if ( a1[1] )
        {
          v17 = v14;
          v12 = a1[7];
          --a1[1];
          ++a1[2];
          *((_DWORD *)v12 + 2) += *(*a1)++;
          if ( *((_DWORD *)a1[7] + 1) != *((_DWORD *)a1[7] + 2) )
          {
            *(_DWORD *)a1[7] = 13;
            a1[6] = "incorrect data check";
            *((_DWORD *)a1[7] + 1) = 5;
            continue;
          }
          *(_DWORD *)a1[7] = 12;
          goto LABEL_60;
        }
        v15 = v17;
        break;
      case 0xC:
LABEL_60:
        v15 = 1;
        break;
      case 0xD:
        v15 = -3;
        break;
      default:
        v15 = -2;
        break;
    }
    return v15;
  }
}

//----- (080CB75C) --------------------------------------------------------
int __cdecl sub_80CB75C(
        int *a1,
        unsigned int a2,
        unsigned int a3,
        int a4,
        int a5,
        _DWORD *a6,
        unsigned int *a7,
        int a8,
        _DWORD *a9,
        int *a10)
{
  int v10; // eax
  int v11; // eax
  int v12; // ebx
  int v13; // ecx
  int v14; // edx
  int v15; // eax
  int v16; // edx
  int v17; // ebx
  int v18; // ecx
  int v19; // edx
  char v22; // [esp+7h] [ebp-121h]
  unsigned int v23; // [esp+8h] [ebp-120h]
  int v24; // [esp+Ch] [ebp-11Ch]
  int *v25; // [esp+10h] [ebp-118h]
  _DWORD *v26; // [esp+10h] [ebp-118h]
  int *v27; // [esp+10h] [ebp-118h]
  int *v28; // [esp+10h] [ebp-118h]
  int v29; // [esp+14h] [ebp-114h]
  unsigned int i; // [esp+18h] [ebp-110h]
  int v31; // [esp+18h] [ebp-110h]
  unsigned int v32; // [esp+18h] [ebp-110h]
  unsigned int m; // [esp+18h] [ebp-110h]
  unsigned int n; // [esp+18h] [ebp-110h]
  unsigned int v35; // [esp+1Ch] [ebp-10Ch]
  unsigned int j; // [esp+1Ch] [ebp-10Ch]
  unsigned int v37; // [esp+1Ch] [ebp-10Ch]
  unsigned int v38; // [esp+1Ch] [ebp-10Ch]
  unsigned int v40; // [esp+24h] [ebp-104h]
  int v41; // [esp+28h] [ebp-100h]
  int v42; // [esp+28h] [ebp-100h]
  int v43; // [esp+28h] [ebp-100h]
  _DWORD *k; // [esp+2Ch] [ebp-FCh]
  _DWORD *v45; // [esp+2Ch] [ebp-FCh]
  int v46[2]; // [esp+30h] [ebp-F8h]
  _BYTE v47[56]; // [esp+38h] [ebp-F0h] BYREF
  int v48[16]; // [esp+70h] [ebp-B8h]
  int v49; // [esp+B0h] [ebp-78h]
  unsigned int v50; // [esp+B4h] [ebp-74h]
  int v51; // [esp+B8h] [ebp-70h]
  int ii; // [esp+BCh] [ebp-6Ch]
  unsigned int v53; // [esp+C0h] [ebp-68h]
  int v54; // [esp+C4h] [ebp-64h]
  int v55; // [esp+C8h] [ebp-60h]
  unsigned int v56; // [esp+CCh] [ebp-5Ch]
  int v57; // [esp+D0h] [ebp-58h] BYREF
  _BYTE v58[72]; // [esp+D4h] [ebp-54h] BYREF
  int v59; // [esp+11Ch] [ebp-Ch]
  int v60; // [esp+134h] [ebp+Ch]

  v57 = 0;
  memset(v58, 0, 60);
  v25 = a1;
  v35 = a2;
  do
  {
    v10 = *v25++;
    ++*(_DWORD *)&v58[4 * v10 - 4];
    --v35;
  }
  while ( v35 );
  if ( v57 == a2 )
  {
    *a6 = 0;
    *a7 = 0;
    return 0;
  }
  else
  {
    v53 = *a7;
    for ( i = 1; i <= 0xF && !*(_DWORD *)&v58[4 * i - 4]; ++i )
      ;
    v29 = i;
    if ( v53 < i )
      v53 = i;
    for ( j = 15; j && !*(_DWORD *)&v58[4 * j - 4]; --j )
      ;
    v55 = j;
    if ( v53 > j )
      v53 = j;
    *a7 = v53;
    v41 = 1 << i;
    while ( i < j )
    {
      v42 = v41 - *(_DWORD *)&v58[4 * i - 4];
      if ( v42 < 0 )
        return -3;
      ++i;
      v41 = 2 * v42;
    }
    v43 = v41 - *(_DWORD *)&v58[4 * j - 4];
    if ( v43 >= 0 )
    {
      *(_DWORD *)&v58[4 * j - 4] += v43;
      v31 = 0;
      v46[1] = 0;
      v26 = v58;
      for ( k = v47; --j; ++k )
      {
        v31 += *v26++;
        *k = v31;
      }
      v27 = a1;
      v37 = 0;
      do
      {
        v11 = *v27++;
        if ( v11 )
          a10[v46[v11]++] = v37;
        ++v37;
      }
      while ( v37 < a2 );
      v60 = v46[v55];
      v38 = 0;
      v46[0] = 0;
      v28 = a10;
      v54 = -1;
      v24 = -v53;
      v48[0] = 0;
      v51 = 0;
      v40 = 0;
      while ( v29 <= v55 )
      {
        v59 = *(_DWORD *)&v58[4 * v29 - 4];
        while ( --v59 != -1 )
        {
          while ( v29 > (int)(v53 + v24) )
          {
            ++v54;
            v24 += v53;
            v23 = v55 - v24;
            if ( v55 - v24 > v53 )
              v23 = v53;
            v32 = v29 - v24;
            v56 = 1 << (v29 - v24);
            if ( v56 > v59 + 1 )
            {
              v56 = v56 - v59 - 1;
              v45 = &v58[4 * v29 - 4];
              if ( v32 < v23 )
              {
                while ( ++v32 < v23 )
                {
                  v56 *= 2;
                  if ( v56 <= *++v45 )
                    break;
                  v56 -= *v45;
                }
              }
            }
            v40 = 1 << v32;
            if ( (unsigned int)(*a9 + (1 << v32)) > 0x5A0 )
              return -3;
            v51 = a8 + 8 * *a9;
            v48[v54] = v51;
            *a9 += v40;
            if ( v54 )
            {
              v46[v54] = v38;
              BYTE1(v49) = v53;
              LOBYTE(v49) = v32;
              v50 = ((v51 - *(_DWORD *)&v47[4 * v54 + 52]) >> 3) - (v38 >> (v24 - v53));
              v12 = 8 * (v38 >> (v24 - v53));
              v13 = *(_DWORD *)&v47[4 * v54 + 52];
              v14 = v50;
              *(_DWORD *)(v13 + v12) = v49;
              *(_DWORD *)(v13 + v12 + 4) = v14;
            }
            else
            {
              *a6 = v51;
            }
          }
          BYTE1(v49) = v29 - v24;
          if ( v28 < &a10[v60] )
          {
            if ( *v28 >= a3 )
            {
              LOBYTE(v49) = *(_BYTE *)(a5 + 4 * (*v28 - a3)) + 80;
              v16 = 4 * (*v28++ - a3);
              v50 = *(_DWORD *)(a4 + v16);
            }
            else
            {
              if ( (unsigned int)*v28 <= 0xFF )
                v22 = 0;
              else
                v22 = 96;
              LOBYTE(v49) = v22;
              v15 = *v28++;
              v50 = v15;
            }
          }
          else
          {
            LOBYTE(v49) = -64;
          }
          v56 = 1 << (v29 - v24);
          for ( m = v38 >> v24; m < v40; m += v56 )
          {
            v17 = 8 * m;
            v18 = v51;
            v19 = v50;
            *(_DWORD *)(v51 + v17) = v49;
            *(_DWORD *)(v18 + v17 + 4) = v19;
          }
          for ( n = 1 << (v29 - 1); (n & v38) != 0; n >>= 1 )
            v38 ^= n;
          v38 ^= n;
          for ( ii = (1 << v24) - 1; (ii & v38) != v46[v54]; ii = (1 << v24) - 1 )
          {
            --v54;
            v24 -= v53;
          }
        }
        ++v29;
      }
      if ( !v43 || v55 == 1 )
        return 0;
      else
        return -5;
    }
    else
    {
      return -3;
    }
  }
}
// 80CB75C: using guessed type int var_B8[16];

//----- (080CBF7B) --------------------------------------------------------
int __cdecl sub_80CBF7B(int *a1, unsigned int *a2, _DWORD *a3, int a4, int a5)
{
  int *v7; // [esp+2Ch] [ebp-Ch]
  int v8; // [esp+30h] [ebp-8h] BYREF
  int v9; // [esp+34h] [ebp-4h]

  v8 = 0;
  v7 = (int *)(*(int (__cdecl **)(_DWORD, int, int))(a5 + 32))(*(_DWORD *)(a5 + 40), 19, 4);
  if ( !v7 )
    return -4;
  v9 = sub_80CB75C(a1, 0x13u, 0x13u, 0, 0, a3, a2, a4, &v8, v7);
  if ( v9 == -3 )
  {
    *(_DWORD *)(a5 + 24) = "oversubscribed dynamic bit lengths tree";
  }
  else if ( v9 == -5 || !*a2 )
  {
    *(_DWORD *)(a5 + 24) = "incomplete dynamic bit lengths tree";
    v9 = -3;
  }
  (*(void (__cdecl **)(_DWORD, int *))(a5 + 36))(*(_DWORD *)(a5 + 40), v7);
  return v9;
}

//----- (080CC064) --------------------------------------------------------
int __cdecl sub_80CC064(
        unsigned int a1,
        unsigned int a2,
        int *a3,
        unsigned int *a4,
        unsigned int *a5,
        _DWORD *a6,
        _DWORD *a7,
        int a8,
        int a9)
{
  int *v11; // [esp+2Ch] [ebp-Ch]
  int v12; // [esp+30h] [ebp-8h] BYREF
  int v13; // [esp+34h] [ebp-4h]

  v12 = 0;
  v11 = (int *)(*(int (__cdecl **)(_DWORD, int, int))(a9 + 32))(*(_DWORD *)(a9 + 40), 288, 4);
  if ( !v11 )
    return -4;
  v13 = sub_80CB75C(a3, a1, 0x101u, (int)&unk_8149A80, (int)&unk_8149B00, a6, a4, a8, &v12, v11);
  if ( !v13 && *a4 )
  {
    v13 = sub_80CB75C(&a3[a1], a2, 0, (int)&unk_8149B80, (int)&unk_8149C00, a7, a5, a8, &v12, v11);
    if ( !v13 && (*a5 || a1 <= 0x101) )
    {
      (*(void (__cdecl **)(_DWORD, int *))(a9 + 36))(*(_DWORD *)(a9 + 40), v11);
      return 0;
    }
    if ( v13 == -3 )
    {
      *(_DWORD *)(a9 + 24) = "oversubscribed distance tree";
    }
    else if ( v13 == -5 )
    {
      *(_DWORD *)(a9 + 24) = "incomplete distance tree";
      v13 = -3;
    }
    else if ( v13 != -4 )
    {
      *(_DWORD *)(a9 + 24) = "empty distance tree with lengths";
      v13 = -3;
    }
  }
  else if ( v13 == -3 )
  {
    *(_DWORD *)(a9 + 24) = "oversubscribed literal/length tree";
  }
  else if ( v13 != -4 )
  {
    *(_DWORD *)(a9 + 24) = "incomplete literal/length tree";
    v13 = -3;
  }
  (*(void (__cdecl **)(_DWORD, int *))(a9 + 36))(*(_DWORD *)(a9 + 40), v11);
  return v13;
}

//----- (080CC247) --------------------------------------------------------
int __cdecl sub_80CC247(_DWORD *a1, _DWORD *a2, _DWORD *a3, _DWORD *a4)
{
  *a1 = dword_8162DA0;
  *a2 = dword_8162DA4;
  *a3 = &unk_8162DC0;
  *a4 = &unk_8163DC0;
  return 0;
}
// 8162DA0: using guessed type int dword_8162DA0;
// 8162DA4: using guessed type int dword_8162DA4;

//----- (080CC278) --------------------------------------------------------
int __cdecl sub_80CC278(int a1, _DWORD *a2, int a3)
{
  int v3; // eax
  char *src; // [esp+14h] [ebp-14h]
  char *srca; // [esp+14h] [ebp-14h]
  char *srcb; // [esp+14h] [ebp-14h]
  char *dest; // [esp+18h] [ebp-10h]
  size_t n; // [esp+1Ch] [ebp-Ch]
  size_t na; // [esp+1Ch] [ebp-Ch]

  dest = (char *)a2[3];
  src = *(char **)(a1 + 48);
  if ( (unsigned int)src > *(_DWORD *)(a1 + 52) )
    v3 = *(_DWORD *)(a1 + 44);
  else
    v3 = *(_DWORD *)(a1 + 52);
  n = v3 - (_DWORD)src;
  if ( (unsigned int)(v3 - (_DWORD)src) > a2[4] )
    n = a2[4];
  if ( n && a3 == -5 )
    a3 = 0;
  a2[4] -= n;
  a2[5] += n;
  if ( *(_DWORD *)(a1 + 56) )
  {
    *(_DWORD *)(a1 + 60) = (*(int (__cdecl **)(_DWORD, char *, size_t))(a1 + 56))(*(_DWORD *)(a1 + 60), src, n);
    a2[12] = *(_DWORD *)(a1 + 60);
  }
  if ( dest )
  {
    memcpy(dest, src, n);
    dest += n;
  }
  srca = &src[n];
  if ( srca == *(char **)(a1 + 44) )
  {
    srcb = *(char **)(a1 + 40);
    if ( *(_DWORD *)(a1 + 52) == *(_DWORD *)(a1 + 44) )
      *(_DWORD *)(a1 + 52) = *(_DWORD *)(a1 + 40);
    na = *(_DWORD *)(a1 + 52) - (_DWORD)srcb;
    if ( na > a2[4] )
      na = a2[4];
    if ( na && a3 == -5 )
      a3 = 0;
    a2[4] -= na;
    a2[5] += na;
    if ( *(_DWORD *)(a1 + 56) )
    {
      *(_DWORD *)(a1 + 60) = (*(int (__cdecl **)(_DWORD, char *, size_t))(a1 + 56))(*(_DWORD *)(a1 + 60), srcb, na);
      a2[12] = *(_DWORD *)(a1 + 60);
    }
    if ( dest )
    {
      memcpy(dest, srcb, na);
      dest += na;
    }
    srca = &srcb[na];
  }
  a2[3] = dest;
  *(_DWORD *)(a1 + 48) = srca;
  return a3;
}

//----- (080CC478) --------------------------------------------------------
void sub_80CC478()
{
  ;
}

//----- (080CC47D) --------------------------------------------------------
int __cdecl sub_80CC47D(int a1)
{
  sub_80CC478();
  *(_DWORD *)(a1 + 2832) = a1 + 140;
  *(_DWORD *)(a1 + 2840) = &off_8163F04;
  *(_DWORD *)(a1 + 2844) = a1 + 2432;
  *(_DWORD *)(a1 + 2852) = &off_8163F18;
  *(_DWORD *)(a1 + 2856) = a1 + 2676;
  *(_DWORD *)(a1 + 2864) = &unk_8163F2C;
  *(_WORD *)(a1 + 5808) = 0;
  *(_DWORD *)(a1 + 5812) = 0;
  *(_DWORD *)(a1 + 5804) = 8;
  return sub_80CC515(a1);
}
// 8163F04: using guessed type void *off_8163F04;
// 8163F18: using guessed type void *off_8163F18;

//----- (080CC515) --------------------------------------------------------
int __cdecl sub_80CC515(int a1)
{
  int result; // eax
  int i; // [esp+0h] [ebp-4h]
  int j; // [esp+0h] [ebp-4h]
  int k; // [esp+0h] [ebp-4h]

  for ( i = 0; i <= 285; ++i )
    *(_WORD *)(a1 + 4 * i + 140) = 0;
  for ( j = 0; j <= 29; ++j )
    *(_WORD *)(a1 + 4 * j + 2432) = 0;
  for ( k = 0; k <= 18; ++k )
    *(_WORD *)(a1 + 4 * k + 2676) = 0;
  *(_WORD *)(a1 + 1164) = 1;
  *(_DWORD *)(a1 + 5796) = 0;
  *(_DWORD *)(a1 + 5792) = 0;
  result = a1;
  *(_DWORD *)(a1 + 5800) = 0;
  *(_DWORD *)(a1 + 5784) = 0;
  return result;
}

//----- (080CC5D2) --------------------------------------------------------
int __cdecl sub_80CC5D2(int a1, int a2, int a3)
{
  int result; // eax
  int i; // [esp+0h] [ebp-10h]
  int v5; // [esp+4h] [ebp-Ch]

  v5 = *(_DWORD *)(a1 + 4 * a3 + 2900);
  for ( i = 2 * a3; i <= *(_DWORD *)(a1 + 5192); i *= 2 )
  {
    if ( i < *(_DWORD *)(a1 + 5192)
      && (*(_WORD *)(a2 + 4 * *(_DWORD *)(a1 + 4 * i + 2904)) < *(_WORD *)(a2 + 4 * *(_DWORD *)(a1 + 4 * i + 2900))
       || *(_WORD *)(a2 + 4 * *(_DWORD *)(a1 + 4 * i + 2904)) == *(_WORD *)(a2 + 4 * *(_DWORD *)(a1 + 4 * i + 2900))
       && *(_BYTE *)(*(_DWORD *)(a1 + 4 * i + 2904) + a1 + 5200) <= *(_BYTE *)(*(_DWORD *)(a1 + 4 * i + 2900) + a1 + 5200)) )
    {
      ++i;
    }
    if ( *(_WORD *)(a2 + 4 * v5) < *(_WORD *)(a2 + 4 * *(_DWORD *)(a1 + 4 * i + 2900))
      || *(_WORD *)(a2 + 4 * v5) == *(_WORD *)(a2 + 4 * *(_DWORD *)(a1 + 4 * i + 2900))
      && *(_BYTE *)(v5 + a1 + 5200) <= *(_BYTE *)(*(_DWORD *)(a1 + 4 * i + 2900) + a1 + 5200) )
    {
      break;
    }
    *(_DWORD *)(a1 + 4 * a3 + 2900) = *(_DWORD *)(a1 + 4 * i + 2900);
    a3 = i;
  }
  result = v5;
  *(_DWORD *)(a1 + 4 * a3 + 2900) = v5;
  return result;
}

//----- (080CC794) --------------------------------------------------------
int *__cdecl sub_80CC794(_DWORD *a1, int a2)
{
  int *result; // eax
  int v3; // [esp+0h] [ebp-3Ch]
  unsigned __int16 v4; // [esp+6h] [ebp-36h]
  int v5; // [esp+8h] [ebp-34h]
  int i; // [esp+Ch] [ebp-30h] BYREF
  int v7; // [esp+10h] [ebp-2Ch]
  int v8; // [esp+14h] [ebp-28h]
  int *j; // [esp+18h] [ebp-24h] BYREF
  int *v10; // [esp+1Ch] [ebp-20h]
  int v11; // [esp+20h] [ebp-1Ch]
  int v12; // [esp+24h] [ebp-18h]
  int v13; // [esp+28h] [ebp-14h]
  int v14; // [esp+2Ch] [ebp-10h]
  int v15; // [esp+30h] [ebp-Ch]

  v15 = *(_DWORD *)a2;
  v14 = *(_DWORD *)(a2 + 4);
  v13 = **(_DWORD **)(a2 + 8);
  v12 = *(_DWORD *)(*(_DWORD *)(a2 + 8) + 4);
  v11 = *(_DWORD *)(*(_DWORD *)(a2 + 8) + 8);
  v10 = *(int **)(*(_DWORD *)(a2 + 8) + 16);
  v3 = 0;
  for ( i = 0; i <= 15; ++i )
    *((_WORD *)a1 + i + 1434) = 0;
  *(_WORD *)(v15 + 4 * a1[a1[1299] + 725] + 2) = 0;
  result = (int *)(a1[1299] + 1);
  for ( j = result; (int)j <= 572; j = (int *)((char *)j + 1) )
  {
    v8 = a1[(_DWORD)j + 725];
    i = *(unsigned __int16 *)(v15 + 4 * *(unsigned __int16 *)(v15 + 4 * v8 + 2) + 2) + 1;
    if ( i > (int)v10 )
    {
      i = (int)v10;
      ++v3;
    }
    *(_WORD *)(v15 + 4 * v8 + 2) = i;
    if ( v8 <= v14 )
    {
      ++*((_WORD *)a1 + i + 1434);
      v5 = 0;
      if ( v8 >= v11 )
        v5 = *(_DWORD *)(v12 + 4 * (v8 - v11));
      v4 = *(_WORD *)(v15 + 4 * v8);
      a1[1448] += v4 * (i + v5);
      if ( v13 )
        a1[1449] += v4 * (v5 + *(unsigned __int16 *)(v13 + 4 * v8 + 2));
    }
    result = (int *)&j;
  }
  if ( v3 )
  {
    do
    {
      for ( i = (int)v10 - 1; !*((_WORD *)a1 + i + 1434); --i )
        ;
      --*((_WORD *)a1 + i + 1434);
      *((_WORD *)a1 + i + 1435) += 2;
      --*((_WORD *)a1 + (_DWORD)v10 + 1434);
      v3 -= 2;
    }
    while ( v3 > 0 );
    result = v10;
    for ( i = (int)v10; i; --i )
    {
      v8 = *((unsigned __int16 *)a1 + i + 1434);
      while ( v8 )
      {
        j = (int *)((char *)j - 1);
        v7 = a1[(_DWORD)j + 725];
        if ( v7 <= v14 )
        {
          if ( *(unsigned __int16 *)(v15 + 4 * v7 + 2) != i )
          {
            a1[1448] += (i - *(unsigned __int16 *)(v15 + 4 * v7 + 2)) * *(unsigned __int16 *)(v15 + 4 * v7);
            *(_WORD *)(v15 + 4 * v7 + 2) = i;
          }
          --v8;
        }
      }
      result = &i;
    }
  }
  return result;
}

//----- (080CCAD0) --------------------------------------------------------
int __cdecl sub_80CCAD0(int a1, int a2, int a3)
{
  int result; // eax
  unsigned __int16 v4; // cx
  int v5; // [esp+10h] [ebp-38h]
  int j; // [esp+14h] [ebp-34h]
  int i; // [esp+18h] [ebp-30h]
  __int16 v8; // [esp+1Eh] [ebp-2Ah]
  __int16 v9[20]; // [esp+20h] [ebp-28h]

  v8 = 0;
  for ( i = 1; i <= 15; ++i )
  {
    v8 = 2 * (*(_WORD *)(a3 + 2 * i - 2) + v8);
    v9[i] = v8;
  }
  for ( j = 0; ; ++j )
  {
    result = j;
    if ( j > a2 )
      break;
    v5 = *(unsigned __int16 *)(a1 + 4 * j + 2);
    if ( *(_WORD *)(a1 + 4 * j + 2) )
    {
      v4 = v9[v5];
      v9[v5] = v4 + 1;
      *(_WORD *)(a1 + 4 * j) = sub_80CF2D0(v4, v5);
    }
  }
  return result;
}
// 80CCAD0: using guessed type __int16 var_28[20];

//----- (080CCB86) --------------------------------------------------------
int __cdecl sub_80CCB86(_DWORD *a1, int a2)
{
  int v2; // edx
  char v3; // al
  int v4; // edx
  int v6; // [esp+14h] [ebp-34h]
  int v7; // [esp+20h] [ebp-28h]
  int v8; // [esp+24h] [ebp-24h]
  int v9; // [esp+28h] [ebp-20h]
  int i; // [esp+2Ch] [ebp-1Ch]
  int j; // [esp+2Ch] [ebp-1Ch]
  int v12; // [esp+2Ch] [ebp-1Ch]
  int v13; // [esp+30h] [ebp-18h]
  int v14; // [esp+34h] [ebp-14h]
  int v15; // [esp+38h] [ebp-10h]

  v15 = *(_DWORD *)a2;
  v14 = **(_DWORD **)(a2 + 8);
  v13 = *(_DWORD *)(*(_DWORD *)(a2 + 8) + 12);
  v8 = -1;
  a1[1298] = 0;
  a1[1299] = 573;
  for ( i = 0; i < v13; ++i )
  {
    if ( *(_WORD *)(v15 + 4 * i) )
    {
      ++a1[1298];
      v8 = i;
      a1[a1[1298] + 725] = i;
      *((_BYTE *)a1 + i + 5200) = 0;
    }
    else
    {
      *(_WORD *)(v15 + 4 * i + 2) = 0;
    }
  }
  while ( (int)a1[1298] <= 1 )
  {
    ++a1[1298];
    if ( v8 > 1 )
      v6 = 0;
    else
      v6 = ++v8;
    a1[a1[1298] + 725] = v6;
    *(_WORD *)(v15 + 4 * v6) = 1;
    *((_BYTE *)a1 + v6 + 5200) = 0;
    --a1[1448];
    if ( v14 )
      a1[1449] -= *(unsigned __int16 *)(v14 + 4 * v6 + 2);
  }
  *(_DWORD *)(a2 + 4) = v8;
  for ( j = a1[1298] / 2; j > 0; --j )
    sub_80CC5D2((int)a1, v15, j);
  v7 = v13;
  do
  {
    v12 = a1[726];
    v2 = a1[1298];
    a1[1298] = v2 - 1;
    a1[726] = a1[v2 + 725];
    sub_80CC5D2((int)a1, v15, 1);
    v9 = a1[726];
    --a1[1299];
    a1[a1[1299]-- + 725] = v12;
    a1[a1[1299] + 725] = v9;
    *(_WORD *)(v15 + 4 * v7) = *(_WORD *)(v15 + 4 * v9) + *(_WORD *)(v15 + 4 * v12);
    if ( *((_BYTE *)a1 + v12 + 5200) < *((_BYTE *)a1 + v9 + 5200) )
      v3 = *((_BYTE *)a1 + v9 + 5200);
    else
      v3 = *((_BYTE *)a1 + v12 + 5200);
    *((_BYTE *)a1 + v7 + 5200) = v3 + 1;
    *(_WORD *)(v15 + 4 * v9 + 2) = v7;
    *(_WORD *)(v15 + 4 * v12 + 2) = *(_WORD *)(v15 + 4 * v9 + 2);
    v4 = v7++;
    a1[726] = v4;
    sub_80CC5D2((int)a1, v15, 1);
  }
  while ( (int)a1[1298] > 1 );
  a1[--a1[1299] + 725] = a1[726];
  sub_80CC794(a1, a2);
  return sub_80CCAD0(v15, v8, (int)(a1 + 717));
}

//----- (080CCF25) --------------------------------------------------------
int __cdecl sub_80CCF25(_WORD *a1, int a2, int a3)
{
  int result; // eax
  int v4; // [esp+0h] [ebp-20h]
  int v5; // [esp+4h] [ebp-1Ch]
  int v6; // [esp+8h] [ebp-18h]
  int v7; // [esp+Ch] [ebp-14h]
  int v8; // [esp+10h] [ebp-10h]
  int v9; // [esp+14h] [ebp-Ch]
  int i; // [esp+18h] [ebp-8h]

  v9 = -1;
  v7 = *(unsigned __int16 *)(a2 + 2);
  v6 = 0;
  v5 = 7;
  v4 = 4;
  if ( !*(_WORD *)(a2 + 2) )
  {
    v5 = 138;
    v4 = 3;
  }
  *(_WORD *)(a2 + 4 * a3 + 6) = -1;
  for ( i = 0; ; ++i )
  {
    result = i;
    if ( i > a3 )
      break;
    v8 = v7;
    v7 = *(unsigned __int16 *)(a2 + 4 * i + 6);
    if ( ++v6 >= v5 || v8 != v7 )
    {
      if ( v6 >= v4 )
      {
        if ( v8 )
        {
          if ( v8 != v9 )
            ++a1[2 * v8 + 1338];
          ++a1[1370];
        }
        else if ( v6 > 10 )
        {
          ++a1[1374];
        }
        else
        {
          ++a1[1372];
        }
      }
      else
      {
        a1[2 * v8 + 1338] += v6;
      }
      v6 = 0;
      v9 = v8;
      if ( v7 )
      {
        if ( v8 == v7 )
        {
          v5 = 6;
          v4 = 3;
        }
        else
        {
          v5 = 7;
          v4 = 4;
        }
      }
      else
      {
        v5 = 138;
        v4 = 3;
      }
    }
  }
  return result;
}

//----- (080CD0B8) --------------------------------------------------------
int __cdecl sub_80CD0B8(int a1, int a2, int a3)
{
  int result; // eax
  int v4; // eax
  int v5; // eax
  int v6; // eax
  int v7; // eax
  int v8; // eax
  int v9; // eax
  int v10; // eax
  int v11; // eax
  int v12; // [esp+0h] [ebp-2Ch]
  int v13; // [esp+0h] [ebp-2Ch]
  int v14; // [esp+0h] [ebp-2Ch]
  int v15; // [esp+0h] [ebp-2Ch]
  int v16; // [esp+0h] [ebp-2Ch]
  int v17; // [esp+4h] [ebp-28h]
  int v18; // [esp+4h] [ebp-28h]
  int v19; // [esp+4h] [ebp-28h]
  int v20; // [esp+4h] [ebp-28h]
  int v21; // [esp+4h] [ebp-28h]
  int v22; // [esp+8h] [ebp-24h]
  int v23; // [esp+Ch] [ebp-20h]
  int v24; // [esp+10h] [ebp-1Ch]
  int v25; // [esp+14h] [ebp-18h]
  int v26; // [esp+18h] [ebp-14h]
  int v27; // [esp+1Ch] [ebp-10h]
  int i; // [esp+20h] [ebp-Ch]

  v27 = -1;
  v25 = *(unsigned __int16 *)(a2 + 2);
  v24 = 0;
  v23 = 7;
  v22 = 4;
  if ( !*(_WORD *)(a2 + 2) )
  {
    v23 = 138;
    v22 = 3;
  }
  for ( i = 0; ; ++i )
  {
    result = i;
    if ( i > a3 )
      break;
    v26 = v25;
    v25 = *(unsigned __int16 *)(a2 + 4 * i + 6);
    if ( ++v24 >= v23 || v26 != v25 )
    {
      if ( v24 >= v22 )
      {
        if ( v26 )
        {
          if ( v26 != v27 )
          {
            v13 = *(unsigned __int16 *)(a1 + 4 * v26 + 2678);
            if ( *(_DWORD *)(a1 + 5812) <= 16 - v13 )
            {
              *(_WORD *)(a1 + 5808) |= *(unsigned __int16 *)(a1 + 4 * v26 + 2676) << *(_BYTE *)(a1 + 5812);
              v5 = *(_DWORD *)(a1 + 5812) + v13;
            }
            else
            {
              v18 = *(unsigned __int16 *)(a1 + 4 * v26 + 2676);
              *(_WORD *)(a1 + 5808) |= v18 << *(_BYTE *)(a1 + 5812);
              *(_BYTE *)(*(_DWORD *)(a1 + 8) + (*(_DWORD *)(a1 + 20))++) = *(_BYTE *)(a1 + 5808);
              *(_BYTE *)(*(_DWORD *)(a1 + 8) + (*(_DWORD *)(a1 + 20))++) = HIBYTE(*(_WORD *)(a1 + 5808));
              *(_WORD *)(a1 + 5808) = (int)(unsigned __int16)v18 >> (16 - *(_BYTE *)(a1 + 5812));
              v5 = *(_DWORD *)(a1 + 5812) + v13 - 16;
            }
            *(_DWORD *)(a1 + 5812) = v5;
            --v24;
          }
          v14 = *(unsigned __int16 *)(a1 + 2742);
          if ( *(_DWORD *)(a1 + 5812) <= 16 - v14 )
          {
            *(_WORD *)(a1 + 5808) |= *(unsigned __int16 *)(a1 + 2740) << *(_BYTE *)(a1 + 5812);
            v6 = *(_DWORD *)(a1 + 5812) + v14;
          }
          else
          {
            v19 = *(unsigned __int16 *)(a1 + 2740);
            *(_WORD *)(a1 + 5808) |= v19 << *(_BYTE *)(a1 + 5812);
            *(_BYTE *)(*(_DWORD *)(a1 + 8) + (*(_DWORD *)(a1 + 20))++) = *(_BYTE *)(a1 + 5808);
            *(_BYTE *)(*(_DWORD *)(a1 + 8) + (*(_DWORD *)(a1 + 20))++) = HIBYTE(*(_WORD *)(a1 + 5808));
            *(_WORD *)(a1 + 5808) = (int)(unsigned __int16)v19 >> (16 - *(_BYTE *)(a1 + 5812));
            v6 = *(_DWORD *)(a1 + 5812) + v14 - 16;
          }
          *(_DWORD *)(a1 + 5812) = v6;
          if ( *(int *)(a1 + 5812) <= 14 )
          {
            *(_WORD *)(a1 + 5808) |= (v24 - 3) << *(_BYTE *)(a1 + 5812);
            v7 = *(_DWORD *)(a1 + 5812) + 2;
          }
          else
          {
            *(_WORD *)(a1 + 5808) |= (v24 - 3) << *(_BYTE *)(a1 + 5812);
            *(_BYTE *)(*(_DWORD *)(a1 + 8) + (*(_DWORD *)(a1 + 20))++) = *(_BYTE *)(a1 + 5808);
            *(_BYTE *)(*(_DWORD *)(a1 + 8) + (*(_DWORD *)(a1 + 20))++) = HIBYTE(*(_WORD *)(a1 + 5808));
            *(_WORD *)(a1 + 5808) = (int)(unsigned __int16)(v24 - 3) >> (16 - *(_BYTE *)(a1 + 5812));
            v7 = *(_DWORD *)(a1 + 5812) - 14;
          }
          *(_DWORD *)(a1 + 5812) = v7;
        }
        else if ( v24 > 10 )
        {
          v16 = *(unsigned __int16 *)(a1 + 2750);
          if ( *(_DWORD *)(a1 + 5812) <= 16 - v16 )
          {
            *(_WORD *)(a1 + 5808) |= *(unsigned __int16 *)(a1 + 2748) << *(_BYTE *)(a1 + 5812);
            v10 = *(_DWORD *)(a1 + 5812) + v16;
          }
          else
          {
            v21 = *(unsigned __int16 *)(a1 + 2748);
            *(_WORD *)(a1 + 5808) |= v21 << *(_BYTE *)(a1 + 5812);
            *(_BYTE *)(*(_DWORD *)(a1 + 8) + (*(_DWORD *)(a1 + 20))++) = *(_BYTE *)(a1 + 5808);
            *(_BYTE *)(*(_DWORD *)(a1 + 8) + (*(_DWORD *)(a1 + 20))++) = HIBYTE(*(_WORD *)(a1 + 5808));
            *(_WORD *)(a1 + 5808) = (int)(unsigned __int16)v21 >> (16 - *(_BYTE *)(a1 + 5812));
            v10 = *(_DWORD *)(a1 + 5812) + v16 - 16;
          }
          *(_DWORD *)(a1 + 5812) = v10;
          if ( *(int *)(a1 + 5812) <= 9 )
          {
            *(_WORD *)(a1 + 5808) |= (v24 - 11) << *(_BYTE *)(a1 + 5812);
            v11 = *(_DWORD *)(a1 + 5812) + 7;
          }
          else
          {
            *(_WORD *)(a1 + 5808) |= (v24 - 11) << *(_BYTE *)(a1 + 5812);
            *(_BYTE *)(*(_DWORD *)(a1 + 8) + (*(_DWORD *)(a1 + 20))++) = *(_BYTE *)(a1 + 5808);
            *(_BYTE *)(*(_DWORD *)(a1 + 8) + (*(_DWORD *)(a1 + 20))++) = HIBYTE(*(_WORD *)(a1 + 5808));
            *(_WORD *)(a1 + 5808) = (int)(unsigned __int16)(v24 - 11) >> (16 - *(_BYTE *)(a1 + 5812));
            v11 = *(_DWORD *)(a1 + 5812) - 9;
          }
          *(_DWORD *)(a1 + 5812) = v11;
        }
        else
        {
          v15 = *(unsigned __int16 *)(a1 + 2746);
          if ( *(_DWORD *)(a1 + 5812) <= 16 - v15 )
          {
            *(_WORD *)(a1 + 5808) |= *(unsigned __int16 *)(a1 + 2744) << *(_BYTE *)(a1 + 5812);
            v8 = *(_DWORD *)(a1 + 5812) + v15;
          }
          else
          {
            v20 = *(unsigned __int16 *)(a1 + 2744);
            *(_WORD *)(a1 + 5808) |= v20 << *(_BYTE *)(a1 + 5812);
            *(_BYTE *)(*(_DWORD *)(a1 + 8) + (*(_DWORD *)(a1 + 20))++) = *(_BYTE *)(a1 + 5808);
            *(_BYTE *)(*(_DWORD *)(a1 + 8) + (*(_DWORD *)(a1 + 20))++) = HIBYTE(*(_WORD *)(a1 + 5808));
            *(_WORD *)(a1 + 5808) = (int)(unsigned __int16)v20 >> (16 - *(_BYTE *)(a1 + 5812));
            v8 = *(_DWORD *)(a1 + 5812) + v15 - 16;
          }
          *(_DWORD *)(a1 + 5812) = v8;
          if ( *(int *)(a1 + 5812) <= 13 )
          {
            *(_WORD *)(a1 + 5808) |= (v24 - 3) << *(_BYTE *)(a1 + 5812);
            v9 = *(_DWORD *)(a1 + 5812) + 3;
          }
          else
          {
            *(_WORD *)(a1 + 5808) |= (v24 - 3) << *(_BYTE *)(a1 + 5812);
            *(_BYTE *)(*(_DWORD *)(a1 + 8) + (*(_DWORD *)(a1 + 20))++) = *(_BYTE *)(a1 + 5808);
            *(_BYTE *)(*(_DWORD *)(a1 + 8) + (*(_DWORD *)(a1 + 20))++) = HIBYTE(*(_WORD *)(a1 + 5808));
            *(_WORD *)(a1 + 5808) = (int)(unsigned __int16)(v24 - 3) >> (16 - *(_BYTE *)(a1 + 5812));
            v9 = *(_DWORD *)(a1 + 5812) - 13;
          }
          *(_DWORD *)(a1 + 5812) = v9;
        }
      }
      else
      {
        do
        {
          v17 = *(unsigned __int16 *)(a1 + 4 * v26 + 2678);
          if ( *(_DWORD *)(a1 + 5812) <= 16 - v17 )
          {
            *(_WORD *)(a1 + 5808) |= *(unsigned __int16 *)(a1 + 4 * v26 + 2676) << *(_BYTE *)(a1 + 5812);
            v4 = *(_DWORD *)(a1 + 5812) + v17;
          }
          else
          {
            v12 = *(unsigned __int16 *)(a1 + 4 * v26 + 2676);
            *(_WORD *)(a1 + 5808) |= v12 << *(_BYTE *)(a1 + 5812);
            *(_BYTE *)(*(_DWORD *)(a1 + 8) + (*(_DWORD *)(a1 + 20))++) = *(_BYTE *)(a1 + 5808);
            *(_BYTE *)(*(_DWORD *)(a1 + 8) + (*(_DWORD *)(a1 + 20))++) = HIBYTE(*(_WORD *)(a1 + 5808));
            *(_WORD *)(a1 + 5808) = (int)(unsigned __int16)v12 >> (16 - *(_BYTE *)(a1 + 5812));
            v4 = *(_DWORD *)(a1 + 5812) + v17 - 16;
          }
          *(_DWORD *)(a1 + 5812) = v4;
          --v24;
        }
        while ( v24 );
      }
      v24 = 0;
      v27 = v26;
      if ( v25 )
      {
        if ( v26 == v25 )
        {
          v23 = 6;
          v22 = 3;
        }
        else
        {
          v23 = 7;
          v22 = 4;
        }
      }
      else
      {
        v23 = 138;
        v22 = 3;
      }
    }
  }
  return result;
}

//----- (080CDA7E) --------------------------------------------------------
int __cdecl sub_80CDA7E(int a1)
{
  int i; // [esp+10h] [ebp-8h]

  sub_80CCF25((_WORD *)a1, a1 + 140, *(_DWORD *)(a1 + 2836));
  sub_80CCF25((_WORD *)a1, a1 + 2432, *(_DWORD *)(a1 + 2848));
  sub_80CCB86((_DWORD *)a1, a1 + 2856);
  for ( i = 18; i > 2 && !*(_WORD *)(a1 + 4 * *(unsigned __int8 *)(i + 135569196) + 2678); --i )
    ;
  *(_DWORD *)(a1 + 5792) += 3 * i + 17;
  return i;
}

//----- (080CDB3D) --------------------------------------------------------
int __cdecl sub_80CDB3D(int a1, int a2, int a3, int a4)
{
  int v4; // eax
  int v5; // eax
  int v6; // eax
  int v7; // eax
  int v9; // [esp+18h] [ebp-10h]
  int i; // [esp+1Ch] [ebp-Ch]

  if ( *(int *)(a1 + 5812) <= 11 )
  {
    *(_WORD *)(a1 + 5808) |= (a2 - 257) << *(_BYTE *)(a1 + 5812);
    v4 = *(_DWORD *)(a1 + 5812) + 5;
  }
  else
  {
    *(_WORD *)(a1 + 5808) |= (a2 - 257) << *(_BYTE *)(a1 + 5812);
    *(_BYTE *)(*(_DWORD *)(a1 + 8) + (*(_DWORD *)(a1 + 20))++) = *(_BYTE *)(a1 + 5808);
    *(_BYTE *)(*(_DWORD *)(a1 + 8) + (*(_DWORD *)(a1 + 20))++) = HIBYTE(*(_WORD *)(a1 + 5808));
    *(_WORD *)(a1 + 5808) = (int)(unsigned __int16)(a2 - 257) >> (16 - *(_BYTE *)(a1 + 5812));
    v4 = *(_DWORD *)(a1 + 5812) - 11;
  }
  *(_DWORD *)(a1 + 5812) = v4;
  if ( *(int *)(a1 + 5812) <= 11 )
  {
    *(_WORD *)(a1 + 5808) |= (a3 - 1) << *(_BYTE *)(a1 + 5812);
    v5 = *(_DWORD *)(a1 + 5812) + 5;
  }
  else
  {
    *(_WORD *)(a1 + 5808) |= (a3 - 1) << *(_BYTE *)(a1 + 5812);
    *(_BYTE *)(*(_DWORD *)(a1 + 8) + (*(_DWORD *)(a1 + 20))++) = *(_BYTE *)(a1 + 5808);
    *(_BYTE *)(*(_DWORD *)(a1 + 8) + (*(_DWORD *)(a1 + 20))++) = HIBYTE(*(_WORD *)(a1 + 5808));
    *(_WORD *)(a1 + 5808) = (int)(unsigned __int16)(a3 - 1) >> (16 - *(_BYTE *)(a1 + 5812));
    v5 = *(_DWORD *)(a1 + 5812) - 11;
  }
  *(_DWORD *)(a1 + 5812) = v5;
  if ( *(int *)(a1 + 5812) <= 12 )
  {
    *(_WORD *)(a1 + 5808) |= (a4 - 4) << *(_BYTE *)(a1 + 5812);
    v6 = *(_DWORD *)(a1 + 5812) + 4;
  }
  else
  {
    *(_WORD *)(a1 + 5808) |= (a4 - 4) << *(_BYTE *)(a1 + 5812);
    *(_BYTE *)(*(_DWORD *)(a1 + 8) + (*(_DWORD *)(a1 + 20))++) = *(_BYTE *)(a1 + 5808);
    *(_BYTE *)(*(_DWORD *)(a1 + 8) + (*(_DWORD *)(a1 + 20))++) = HIBYTE(*(_WORD *)(a1 + 5808));
    *(_WORD *)(a1 + 5808) = (int)(unsigned __int16)(a4 - 4) >> (16 - *(_BYTE *)(a1 + 5812));
    v6 = *(_DWORD *)(a1 + 5812) - 12;
  }
  *(_DWORD *)(a1 + 5812) = v6;
  for ( i = 0; i < a4; ++i )
  {
    if ( *(int *)(a1 + 5812) <= 13 )
    {
      *(_WORD *)(a1 + 5808) |= *(unsigned __int16 *)(a1 + 4 * *(unsigned __int8 *)(i + 135569196) + 2678) << *(_BYTE *)(a1 + 5812);
      v7 = *(_DWORD *)(a1 + 5812) + 3;
    }
    else
    {
      v9 = *(unsigned __int16 *)(a1 + 4 * *(unsigned __int8 *)(i + 135569196) + 2678);
      *(_WORD *)(a1 + 5808) |= v9 << *(_BYTE *)(a1 + 5812);
      *(_BYTE *)(*(_DWORD *)(a1 + 8) + (*(_DWORD *)(a1 + 20))++) = *(_BYTE *)(a1 + 5808);
      *(_BYTE *)(*(_DWORD *)(a1 + 8) + (*(_DWORD *)(a1 + 20))++) = HIBYTE(*(_WORD *)(a1 + 5808));
      *(_WORD *)(a1 + 5808) = (int)(unsigned __int16)v9 >> (16 - *(_BYTE *)(a1 + 5812));
      v7 = *(_DWORD *)(a1 + 5812) - 13;
    }
    *(_DWORD *)(a1 + 5812) = v7;
  }
  sub_80CD0B8(a1, a1 + 140, a2 - 1);
  return sub_80CD0B8(a1, a1 + 2432, a3 - 1);
}

//----- (080CDFE1) --------------------------------------------------------
int *__cdecl sub_80CDFE1(int a1, _BYTE *a2, int a3, int a4)
{
  int v4; // eax

  if ( *(int *)(a1 + 5812) <= 13 )
  {
    *(_WORD *)(a1 + 5808) |= a4 << *(_BYTE *)(a1 + 5812);
    v4 = *(_DWORD *)(a1 + 5812) + 3;
  }
  else
  {
    *(_WORD *)(a1 + 5808) |= a4 << *(_BYTE *)(a1 + 5812);
    *(_BYTE *)(*(_DWORD *)(a1 + 8) + (*(_DWORD *)(a1 + 20))++) = *(_BYTE *)(a1 + 5808);
    *(_BYTE *)(*(_DWORD *)(a1 + 8) + (*(_DWORD *)(a1 + 20))++) = HIBYTE(*(_WORD *)(a1 + 5808));
    *(_WORD *)(a1 + 5808) = (int)(unsigned __int16)a4 >> (16 - *(_BYTE *)(a1 + 5812));
    v4 = *(_DWORD *)(a1 + 5812) - 13;
  }
  *(_DWORD *)(a1 + 5812) = v4;
  return sub_80CF458((_DWORD *)a1, a2, a3, 1);
}

//----- (080CE10F) --------------------------------------------------------
int __cdecl sub_80CE10F(int a1)
{
  int v1; // eax
  int v2; // eax
  int v3; // eax
  int v4; // eax
  int result; // eax

  if ( *(int *)(a1 + 5812) <= 13 )
  {
    *(_WORD *)(a1 + 5808) |= 2 << *(_BYTE *)(a1 + 5812);
    v1 = *(_DWORD *)(a1 + 5812) + 3;
  }
  else
  {
    *(_WORD *)(a1 + 5808) |= 2 << *(_BYTE *)(a1 + 5812);
    *(_BYTE *)(*(_DWORD *)(a1 + 8) + (*(_DWORD *)(a1 + 20))++) = *(_BYTE *)(a1 + 5808);
    *(_BYTE *)(*(_DWORD *)(a1 + 8) + (*(_DWORD *)(a1 + 20))++) = HIBYTE(*(_WORD *)(a1 + 5808));
    *(_WORD *)(a1 + 5808) = 2 >> (16 - *(_BYTE *)(a1 + 5812));
    v1 = *(_DWORD *)(a1 + 5812) - 13;
  }
  *(_DWORD *)(a1 + 5812) = v1;
  if ( *(int *)(a1 + 5812) <= 9 )
  {
    *(_WORD *)(a1 + 5808) = *(_WORD *)(a1 + 5808);
    v2 = *(_DWORD *)(a1 + 5812) + 7;
  }
  else
  {
    *(_WORD *)(a1 + 5808) = *(_WORD *)(a1 + 5808);
    *(_BYTE *)(*(_DWORD *)(a1 + 8) + (*(_DWORD *)(a1 + 20))++) = *(_BYTE *)(a1 + 5808);
    *(_BYTE *)(*(_DWORD *)(a1 + 8) + (*(_DWORD *)(a1 + 20))++) = HIBYTE(*(_WORD *)(a1 + 5808));
    *(_WORD *)(a1 + 5808) = 0;
    v2 = *(_DWORD *)(a1 + 5812) - 9;
  }
  *(_DWORD *)(a1 + 5812) = v2;
  sub_80CF2FE(a1);
  if ( *(_DWORD *)(a1 + 5804) - *(_DWORD *)(a1 + 5812) + 11 <= 8 )
  {
    if ( *(int *)(a1 + 5812) <= 13 )
    {
      *(_WORD *)(a1 + 5808) |= 2 << *(_BYTE *)(a1 + 5812);
      v3 = *(_DWORD *)(a1 + 5812) + 3;
    }
    else
    {
      *(_WORD *)(a1 + 5808) |= 2 << *(_BYTE *)(a1 + 5812);
      *(_BYTE *)(*(_DWORD *)(a1 + 8) + (*(_DWORD *)(a1 + 20))++) = *(_BYTE *)(a1 + 5808);
      *(_BYTE *)(*(_DWORD *)(a1 + 8) + (*(_DWORD *)(a1 + 20))++) = HIBYTE(*(_WORD *)(a1 + 5808));
      *(_WORD *)(a1 + 5808) = 2 >> (16 - *(_BYTE *)(a1 + 5812));
      v3 = *(_DWORD *)(a1 + 5812) - 13;
    }
    *(_DWORD *)(a1 + 5812) = v3;
    if ( *(int *)(a1 + 5812) <= 9 )
    {
      *(_WORD *)(a1 + 5808) = *(_WORD *)(a1 + 5808);
      v4 = *(_DWORD *)(a1 + 5812) + 7;
    }
    else
    {
      *(_WORD *)(a1 + 5808) = *(_WORD *)(a1 + 5808);
      *(_BYTE *)(*(_DWORD *)(a1 + 8) + (*(_DWORD *)(a1 + 20))++) = *(_BYTE *)(a1 + 5808);
      *(_BYTE *)(*(_DWORD *)(a1 + 8) + (*(_DWORD *)(a1 + 20))++) = HIBYTE(*(_WORD *)(a1 + 5808));
      *(_WORD *)(a1 + 5808) = 0;
      v4 = *(_DWORD *)(a1 + 5812) - 9;
    }
    *(_DWORD *)(a1 + 5812) = v4;
    sub_80CF2FE(a1);
  }
  result = a1;
  *(_DWORD *)(a1 + 5804) = 7;
  return result;
}

//----- (080CE57D) --------------------------------------------------------
int __cdecl sub_80CE57D(int a1, _BYTE *a2, int a3, int a4)
{
  int v4; // eax
  int v5; // eax
  int result; // eax
  int v7; // [esp+24h] [ebp-14h]
  unsigned int v8; // [esp+28h] [ebp-10h]
  unsigned int v9; // [esp+2Ch] [ebp-Ch]

  v7 = 0;
  if ( *(int *)(a1 + 124) <= 0 )
  {
    v8 = a3 + 5;
    v9 = a3 + 5;
  }
  else
  {
    if ( *(_BYTE *)(a1 + 28) == 2 )
      sub_80CF236(a1);
    sub_80CCB86((_DWORD *)a1, a1 + 2832);
    sub_80CCB86((_DWORD *)a1, a1 + 2844);
    v7 = sub_80CDA7E(a1);
    v9 = (unsigned int)(*(_DWORD *)(a1 + 5792) + 10) >> 3;
    v8 = (unsigned int)(*(_DWORD *)(a1 + 5796) + 10) >> 3;
    if ( v8 <= v9 )
      v9 = (unsigned int)(*(_DWORD *)(a1 + 5796) + 10) >> 3;
  }
  if ( a3 + 4 <= v9 && a2 )
  {
    sub_80CDFE1(a1, a2, a3, a4);
  }
  else if ( v8 == v9 )
  {
    if ( *(int *)(a1 + 5812) <= 13 )
    {
      *(_WORD *)(a1 + 5808) |= (a4 + 2) << *(_BYTE *)(a1 + 5812);
      v4 = *(_DWORD *)(a1 + 5812) + 3;
    }
    else
    {
      *(_WORD *)(a1 + 5808) |= (a4 + 2) << *(_BYTE *)(a1 + 5812);
      *(_BYTE *)(*(_DWORD *)(a1 + 8) + (*(_DWORD *)(a1 + 20))++) = *(_BYTE *)(a1 + 5808);
      *(_BYTE *)(*(_DWORD *)(a1 + 8) + (*(_DWORD *)(a1 + 20))++) = HIBYTE(*(_WORD *)(a1 + 5808));
      *(_WORD *)(a1 + 5808) = (int)(unsigned __int16)(a4 + 2) >> (16 - *(_BYTE *)(a1 + 5812));
      v4 = *(_DWORD *)(a1 + 5812) - 13;
    }
    *(_DWORD *)(a1 + 5812) = v4;
    sub_80CEA8B(a1, (int)&unk_8149F40, (int)&unk_814A3C0);
  }
  else
  {
    if ( *(int *)(a1 + 5812) <= 13 )
    {
      *(_WORD *)(a1 + 5808) |= (a4 + 4) << *(_BYTE *)(a1 + 5812);
      v5 = *(_DWORD *)(a1 + 5812) + 3;
    }
    else
    {
      *(_WORD *)(a1 + 5808) |= (a4 + 4) << *(_BYTE *)(a1 + 5812);
      *(_BYTE *)(*(_DWORD *)(a1 + 8) + (*(_DWORD *)(a1 + 20))++) = *(_BYTE *)(a1 + 5808);
      *(_BYTE *)(*(_DWORD *)(a1 + 8) + (*(_DWORD *)(a1 + 20))++) = HIBYTE(*(_WORD *)(a1 + 5808));
      *(_WORD *)(a1 + 5808) = (int)(unsigned __int16)(a4 + 4) >> (16 - *(_BYTE *)(a1 + 5812));
      v5 = *(_DWORD *)(a1 + 5812) - 13;
    }
    *(_DWORD *)(a1 + 5812) = v5;
    sub_80CDB3D(a1, *(_DWORD *)(a1 + 2836) + 1, *(_DWORD *)(a1 + 2848) + 1, v7 + 1);
    sub_80CEA8B(a1, a1 + 140, a1 + 2432);
  }
  result = sub_80CC515(a1);
  if ( a4 )
    return sub_80CF3C1(a1);
  return result;
}

//----- (080CEA8B) --------------------------------------------------------
int __cdecl sub_80CEA8B(int a1, int a2, int a3)
{
  int v3; // eax
  int v4; // eax
  int v5; // eax
  int v6; // eax
  int v7; // eax
  int v8; // eax
  int result; // eax
  int v10; // [esp+0h] [ebp-28h]
  int v11; // [esp+4h] [ebp-24h]
  int v12; // [esp+4h] [ebp-24h]
  int v13; // [esp+4h] [ebp-24h]
  int v14; // [esp+4h] [ebp-24h]
  int v15; // [esp+8h] [ebp-20h]
  int v16; // [esp+8h] [ebp-20h]
  int v17; // [esp+8h] [ebp-20h]
  int v18; // [esp+8h] [ebp-20h]
  int v19; // [esp+Ch] [ebp-1Ch]
  int v20; // [esp+Ch] [ebp-1Ch]
  int v21; // [esp+10h] [ebp-18h]
  unsigned int i; // [esp+14h] [ebp-14h]
  int v23; // [esp+18h] [ebp-10h]
  int v24; // [esp+18h] [ebp-10h]
  int v25; // [esp+1Ch] [ebp-Ch]
  unsigned int v26; // [esp+1Ch] [ebp-Ch]
  unsigned int v27; // [esp+1Ch] [ebp-Ch]

  for ( i = 0; i < *(_DWORD *)(a1 + 5784); ++i )
  {
    v25 = *(unsigned __int16 *)(*(_DWORD *)(a1 + 5788) + 2 * i);
    v23 = *(unsigned __int8 *)(*(_DWORD *)(a1 + 5776) + i);
    if ( v25 )
    {
      v21 = *(unsigned __int8 *)(v23 + 135571008);
      v12 = *(unsigned __int16 *)(a2 + 4 * v21 + 1030);
      if ( *(_DWORD *)(a1 + 5812) <= 16 - v12 )
      {
        *(_WORD *)(a1 + 5808) |= *(unsigned __int16 *)(a2 + 4 * v21 + 1028) << *(_BYTE *)(a1 + 5812);
        v4 = *(_DWORD *)(a1 + 5812) + v12;
      }
      else
      {
        v16 = *(unsigned __int16 *)(a2 + 4 * v21 + 1028);
        *(_WORD *)(a1 + 5808) |= v16 << *(_BYTE *)(a1 + 5812);
        *(_BYTE *)(*(_DWORD *)(a1 + 8) + (*(_DWORD *)(a1 + 20))++) = *(_BYTE *)(a1 + 5808);
        *(_BYTE *)(*(_DWORD *)(a1 + 8) + (*(_DWORD *)(a1 + 20))++) = HIBYTE(*(_WORD *)(a1 + 5808));
        *(_WORD *)(a1 + 5808) = (int)(unsigned __int16)v16 >> (16 - *(_BYTE *)(a1 + 5812));
        v4 = *(_DWORD *)(a1 + 5812) + v12 - 16;
      }
      *(_DWORD *)(a1 + 5812) = v4;
      v19 = dword_8149DE0[v21];
      if ( v19 )
      {
        v24 = v23 - dword_814A740[v21];
        if ( *(_DWORD *)(a1 + 5812) <= 16 - v19 )
        {
          *(_WORD *)(a1 + 5808) |= v24 << *(_BYTE *)(a1 + 5812);
          v5 = *(_DWORD *)(a1 + 5812) + v19;
        }
        else
        {
          *(_WORD *)(a1 + 5808) |= v24 << *(_BYTE *)(a1 + 5812);
          *(_BYTE *)(*(_DWORD *)(a1 + 8) + (*(_DWORD *)(a1 + 20))++) = *(_BYTE *)(a1 + 5808);
          *(_BYTE *)(*(_DWORD *)(a1 + 8) + (*(_DWORD *)(a1 + 20))++) = HIBYTE(*(_WORD *)(a1 + 5808));
          *(_WORD *)(a1 + 5808) = (int)(unsigned __int16)v24 >> (16 - *(_BYTE *)(a1 + 5812));
          v5 = *(_DWORD *)(a1 + 5812) + v19 - 16;
        }
        *(_DWORD *)(a1 + 5812) = v5;
      }
      v26 = v25 - 1;
      if ( v26 > 0xFF )
        v10 = (unsigned __int8)byte_814A540[v26 >> 7];
      else
        v10 = *(unsigned __int8 *)(v26 + 135570496);
      v13 = *(unsigned __int16 *)(a3 + 4 * v10 + 2);
      if ( *(_DWORD *)(a1 + 5812) <= 16 - v13 )
      {
        *(_WORD *)(a1 + 5808) |= *(unsigned __int16 *)(a3 + 4 * v10) << *(_BYTE *)(a1 + 5812);
        v6 = *(_DWORD *)(a1 + 5812) + v13;
      }
      else
      {
        v17 = *(unsigned __int16 *)(a3 + 4 * v10);
        *(_WORD *)(a1 + 5808) |= v17 << *(_BYTE *)(a1 + 5812);
        *(_BYTE *)(*(_DWORD *)(a1 + 8) + (*(_DWORD *)(a1 + 20))++) = *(_BYTE *)(a1 + 5808);
        *(_BYTE *)(*(_DWORD *)(a1 + 8) + (*(_DWORD *)(a1 + 20))++) = HIBYTE(*(_WORD *)(a1 + 5808));
        *(_WORD *)(a1 + 5808) = (int)(unsigned __int16)v17 >> (16 - *(_BYTE *)(a1 + 5812));
        v6 = *(_DWORD *)(a1 + 5812) + v13 - 16;
      }
      *(_DWORD *)(a1 + 5812) = v6;
      v20 = dword_8149E60[v10];
      if ( v20 )
      {
        v27 = v26 - dword_814A7C0[v10];
        if ( *(_DWORD *)(a1 + 5812) <= 16 - v20 )
        {
          *(_WORD *)(a1 + 5808) |= v27 << *(_BYTE *)(a1 + 5812);
          v7 = *(_DWORD *)(a1 + 5812) + v20;
        }
        else
        {
          *(_WORD *)(a1 + 5808) |= v27 << *(_BYTE *)(a1 + 5812);
          *(_BYTE *)(*(_DWORD *)(a1 + 8) + (*(_DWORD *)(a1 + 20))++) = *(_BYTE *)(a1 + 5808);
          *(_BYTE *)(*(_DWORD *)(a1 + 8) + (*(_DWORD *)(a1 + 20))++) = HIBYTE(*(_WORD *)(a1 + 5808));
          *(_WORD *)(a1 + 5808) = (int)(unsigned __int16)v27 >> (16 - *(_BYTE *)(a1 + 5812));
          v7 = *(_DWORD *)(a1 + 5812) + v20 - 16;
        }
        *(_DWORD *)(a1 + 5812) = v7;
      }
    }
    else
    {
      v15 = *(unsigned __int16 *)(a2 + 4 * v23 + 2);
      if ( *(_DWORD *)(a1 + 5812) <= 16 - v15 )
      {
        *(_WORD *)(a1 + 5808) |= *(unsigned __int16 *)(a2 + 4 * v23) << *(_BYTE *)(a1 + 5812);
        v3 = *(_DWORD *)(a1 + 5812) + v15;
      }
      else
      {
        v11 = *(unsigned __int16 *)(a2 + 4 * v23);
        *(_WORD *)(a1 + 5808) |= v11 << *(_BYTE *)(a1 + 5812);
        *(_BYTE *)(*(_DWORD *)(a1 + 8) + (*(_DWORD *)(a1 + 20))++) = *(_BYTE *)(a1 + 5808);
        *(_BYTE *)(*(_DWORD *)(a1 + 8) + (*(_DWORD *)(a1 + 20))++) = HIBYTE(*(_WORD *)(a1 + 5808));
        *(_WORD *)(a1 + 5808) = (int)(unsigned __int16)v11 >> (16 - *(_BYTE *)(a1 + 5812));
        v3 = *(_DWORD *)(a1 + 5812) + v15 - 16;
      }
      *(_DWORD *)(a1 + 5812) = v3;
    }
  }
  v14 = *(unsigned __int16 *)(a2 + 1026);
  if ( *(_DWORD *)(a1 + 5812) <= 16 - v14 )
  {
    *(_WORD *)(a1 + 5808) |= *(unsigned __int16 *)(a2 + 1024) << *(_BYTE *)(a1 + 5812);
    v8 = *(_DWORD *)(a1 + 5812) + v14;
  }
  else
  {
    v18 = *(unsigned __int16 *)(a2 + 1024);
    *(_WORD *)(a1 + 5808) |= v18 << *(_BYTE *)(a1 + 5812);
    *(_BYTE *)(*(_DWORD *)(a1 + 8) + (*(_DWORD *)(a1 + 20))++) = *(_BYTE *)(a1 + 5808);
    *(_BYTE *)(*(_DWORD *)(a1 + 8) + (*(_DWORD *)(a1 + 20))++) = HIBYTE(*(_WORD *)(a1 + 5808));
    *(_WORD *)(a1 + 5808) = (int)(unsigned __int16)v18 >> (16 - *(_BYTE *)(a1 + 5812));
    v8 = *(_DWORD *)(a1 + 5812) + v14 - 16;
  }
  *(_DWORD *)(a1 + 5812) = v8;
  result = a1;
  *(_DWORD *)(a1 + 5804) = *(unsigned __int16 *)(a2 + 1026);
  return result;
}
// 8149DE0: using guessed type int dword_8149DE0[];
// 8149E60: using guessed type int dword_8149E60[];
// 814A740: using guessed type int dword_814A740[32];
// 814A7C0: using guessed type int dword_814A7C0[30];

//----- (080CF236) --------------------------------------------------------
bool __cdecl sub_80CF236(int a1)
{
  bool result; // al
  unsigned int v2; // [esp+0h] [ebp-Ch]
  unsigned int v3; // [esp+4h] [ebp-8h]
  int v4; // [esp+8h] [ebp-4h]

  v4 = 0;
  v3 = 0;
  v2 = 0;
  while ( v4 <= 6 )
    v2 += *(unsigned __int16 *)(a1 + 4 * v4++ + 140);
  while ( v4 <= 127 )
    v3 += *(unsigned __int16 *)(a1 + 4 * v4++ + 140);
  while ( v4 <= 255 )
    v2 += *(unsigned __int16 *)(a1 + 4 * v4++ + 140);
  result = v2 <= v3 >> 2;
  *(_BYTE *)(a1 + 28) = result;
  return result;
}

//----- (080CF2D0) --------------------------------------------------------
unsigned int __cdecl sub_80CF2D0(unsigned int a1, int a2)
{
  unsigned int v3; // [esp+0h] [ebp-4h]
  int v4; // [esp+0h] [ebp-4h]

  v3 = 0;
  do
  {
    v4 = a1 & 1 | v3;
    a1 >>= 1;
    v3 = 2 * v4;
    --a2;
  }
  while ( a2 > 0 );
  return v3 >> 1;
}

//----- (080CF2FE) --------------------------------------------------------
int __cdecl sub_80CF2FE(int a1)
{
  int result; // eax

  if ( *(_DWORD *)(a1 + 5812) == 16 )
  {
    *(_BYTE *)(*(_DWORD *)(a1 + 8) + (*(_DWORD *)(a1 + 20))++) = *(_BYTE *)(a1 + 5808);
    *(_BYTE *)(*(_DWORD *)(a1 + 8) + (*(_DWORD *)(a1 + 20))++) = HIBYTE(*(_WORD *)(a1 + 5808));
    *(_WORD *)(a1 + 5808) = 0;
    result = a1;
    *(_DWORD *)(a1 + 5812) = 0;
  }
  else
  {
    result = a1;
    if ( *(int *)(a1 + 5812) > 7 )
    {
      *(_BYTE *)(*(_DWORD *)(a1 + 8) + (*(_DWORD *)(a1 + 20))++) = *(_BYTE *)(a1 + 5808);
      *(_WORD *)(a1 + 5808) >>= 8;
      result = *(_DWORD *)(a1 + 5812) - 8;
      *(_DWORD *)(a1 + 5812) = result;
    }
  }
  return result;
}

//----- (080CF3C1) --------------------------------------------------------
int __cdecl sub_80CF3C1(int a1)
{
  int result; // eax

  if ( *(int *)(a1 + 5812) <= 8 )
  {
    if ( *(int *)(a1 + 5812) > 0 )
      *(_BYTE *)(*(_DWORD *)(a1 + 8) + (*(_DWORD *)(a1 + 20))++) = *(_BYTE *)(a1 + 5808);
  }
  else
  {
    *(_BYTE *)(*(_DWORD *)(a1 + 8) + (*(_DWORD *)(a1 + 20))++) = *(_BYTE *)(a1 + 5808);
    *(_BYTE *)(*(_DWORD *)(a1 + 8) + (*(_DWORD *)(a1 + 20))++) = HIBYTE(*(_WORD *)(a1 + 5808));
  }
  *(_WORD *)(a1 + 5808) = 0;
  result = a1;
  *(_DWORD *)(a1 + 5812) = 0;
  return result;
}

//----- (080CF458) --------------------------------------------------------
int *__cdecl sub_80CF458(_DWORD *a1, _BYTE *a2, int a3, int a4)
{
  int *result; // eax
  _BYTE *v5; // ecx

  sub_80CF3C1((int)a1);
  a1[1451] = 8;
  if ( a4 )
  {
    *(_BYTE *)(a1[2] + a1[5]++) = a3;
    *(_BYTE *)(a1[2] + a1[5]++) = BYTE1(a3);
    *(_BYTE *)(a1[2] + a1[5]++) = ~(_BYTE)a3;
    *(_BYTE *)(a1[2] + a1[5]++) = (unsigned __int16)~(_WORD)a3 >> 8;
  }
  while ( 1 )
  {
    result = &a3;
    if ( --a3 == -1 )
      break;
    v5 = a2++;
    *(_BYTE *)(a1[2] + a1[5]++) = *v5;
  }
  return result;
}

//----- (080CF610) --------------------------------------------------------
int __cdecl sub_80CF610(FILE *stream, _DWORD *a2)
{
  __int16 ptr; // [esp+16h] [ebp-2h] BYREF

  FS_FileRead(&ptr, 2u, 1u, stream);
  *a2 = ptr;
  return 0;
}

//----- (080CF648) --------------------------------------------------------
int __cdecl sub_80CF648(FILE *stream, _DWORD *a2)
{
  int ptr; // [esp+14h] [ebp-4h] BYREF

  FS_FileRead(&ptr, 4u, 1u, stream);
  *a2 = ptr;
  return 0;
}

//----- (080CF67F) --------------------------------------------------------
int __cdecl sub_80CF67F(char *a1, char *a2)
{
  char *v2; // eax
  char *v3; // edx
  char v7; // [esp+Ah] [ebp-2h]
  char v8; // [esp+Bh] [ebp-1h]

  while ( 1 )
  {
    v2 = a1++;
    v8 = *v2;
    v3 = a2++;
    v7 = *v3;
    if ( *v2 > 96 && v8 <= 122 )
      v8 -= 32;
    if ( v7 > 96 && v7 <= 122 )
      v7 -= 32;
    if ( !v8 )
      break;
    if ( !v7 )
      return 1;
    if ( v8 < v7 )
      return -1;
    if ( v8 > v7 )
      return 1;
  }
  if ( v7 )
    return -1;
  else
    return 0;
}

//----- (080CF724) --------------------------------------------------------
int __cdecl sub_80CF724(char *s1, char *s2, int a3)
{
  if ( !a3 )
    a3 = 1;
  if ( a3 == 1 )
    return strcmp(s1, s2);
  else
    return sub_80CF67F(s1, s2);
}

//----- (080CF76E) --------------------------------------------------------
size_t __cdecl sub_80CF76E(FILE *stream)
{
  int v1; // edx
  size_t v3; // [esp+10h] [ebp-28h]
  size_t v5; // [esp+18h] [ebp-20h]
  int off; // [esp+1Ch] [ebp-1Ch]
  size_t v7; // [esp+24h] [ebp-14h]
  unsigned int v8; // [esp+28h] [ebp-10h]
  unsigned int v9; // [esp+2Ch] [ebp-Ch]
  unsigned int v10; // [esp+30h] [ebp-8h]
  void *ptr; // [esp+34h] [ebp-4h]

  v8 = 0xFFFF;
  v7 = 0;
  if ( FS_FileSeek(stream, 0, 2) )
    return 0;
  v10 = ftell(stream);
  if ( v10 < 0xFFFF )
    v8 = v10;
  ptr = malloc(0x404u);
  if ( !ptr )
    return 0;
  v9 = 4;
  do
  {
    if ( v9 >= v8 )
      break;
    if ( v9 + 1024 <= v8 )
      v9 += 1024;
    else
      v9 = v8;
    off = v10 - v9;
    v3 = v9;
    if ( v9 > 0x404 )
      v3 = 1028;
    if ( FS_FileSeek(stream, off, 0) || FS_FileRead(ptr, v3, 1u, stream) != 1 )
      break;
    v5 = v3 - 3;
    while ( 1 )
    {
      v1 = v5--;
      if ( v1 <= 0 )
        break;
      if ( *((_BYTE *)ptr + v5) == 80
        && *((_BYTE *)ptr + v5 + 1) == 75
        && *((_BYTE *)ptr + v5 + 2) == 5
        && *((_BYTE *)ptr + v5 + 3) == 6 )
      {
        v7 = off + v5;
        break;
      }
    }
  }
  while ( !v7 );
  free(ptr);
  return v7;
}

//----- (080CF90C) --------------------------------------------------------
_DWORD *__cdecl sub_80CF90C(char *filename, void *src)
{
  FILE *v4; // [esp+10h] [ebp-8h]
  _DWORD *dest; // [esp+14h] [ebp-4h]

  v4 = FS_FileOpen(filename, "rb");
  if ( !v4 )
    return 0;
  dest = malloc(0x80u);
  Com_Memcpy(dest, src, 0x80u);
  *dest = v4;
  dest[31] = 0;
  return dest;
}

//----- (080CF97D) --------------------------------------------------------
int *__cdecl unzOpen(char *filename)
{
  int v3; // [esp+20h] [ebp-A8h]
  int v4; // [esp+24h] [ebp-A4h] BYREF
  int v5; // [esp+28h] [ebp-A0h] BYREF
  int v6; // [esp+2Ch] [ebp-9Ch] BYREF
  FILE *stream; // [esp+30h] [ebp-98h]
  int v8; // [esp+34h] [ebp-94h] BYREF
  int off; // [esp+38h] [ebp-90h]
  int *v10; // [esp+3Ch] [ebp-8Ch]
  int v11[34]; // [esp+40h] [ebp-88h] BYREF

  v3 = 0;
  stream = FS_FileOpen(filename, "rb");
  if ( !stream )
    return 0;
  off = sub_80CF76E(stream);
  if ( !off )
    v3 = -1;
  if ( FS_FileSeek(stream, off, 0) )
    v3 = -1;
  if ( sub_80CF648(stream, &v8) )
    v3 = -1;
  if ( sub_80CF610(stream, &v6) )
    v3 = -1;
  if ( sub_80CF610(stream, &v5) )
    v3 = -1;
  if ( sub_80CF610(stream, &v11[1]) )
    v3 = -1;
  if ( sub_80CF610(stream, &v4) )
    v3 = -1;
  if ( v4 != v11[1] || v5 || v6 )
    v3 = -103;
  if ( sub_80CF648(stream, &v11[8]) )
    v3 = -1;
  if ( sub_80CF648(stream, &v11[9]) )
    v3 = -1;
  if ( sub_80CF610(stream, &v11[2]) )
    v3 = -1;
  if ( off < (unsigned int)(v11[9] + v11[8]) && !v3 )
    v3 = -103;
  if ( v3 )
  {
    FS_FileClose(stream);
    return 0;
  }
  else
  {
    v11[0] = (int)stream;
    v11[3] = off - (v11[8] + v11[9]);
    v11[7] = off;
    v11[31] = 0;
    v10 = (int *)malloc(0x80u);
    qmemcpy(v10, v11, 0x80u);
    unzGoToFirstFile((int)v10);
    return v10;
  }
}

//----- (080CFC62) --------------------------------------------------------
int __cdecl sub_80CFC62(int a1)
{
  if ( !a1 )
    return -102;
  if ( *(_DWORD *)(a1 + 124) )
    sub_80D0F1A(a1);
  FS_FileClose(*(FILE **)a1);
  free((void *)a1);
  return 0;
}

//----- (080CFCB5) --------------------------------------------------------
int __cdecl unzGetGlobalInfo(int a1, _DWORD *a2)
{
  int v2; // edx

  if ( !a1 )
    return -102;
  v2 = *(_DWORD *)(a1 + 8);
  *a2 = *(_DWORD *)(a1 + 4);
  a2[1] = v2;
  return 0;
}

//----- (080CFCED) --------------------------------------------------------
int __cdecl sub_80CFCED(int a1, int *a2)
{
  int result; // eax

  a2[3] = BYTE2(a1) & 0x1F;
  a2[4] = ((unsigned __int16)(HIWORD(a1) & 0x1E0) >> 5) - 1;
  a2[5] = ((unsigned __int16)(HIWORD(a1) & 0xFE00) >> 9) + 1980;
  a2[2] = (unsigned __int16)(a1 & 0xF800) >> 11;
  a2[1] = (unsigned __int16)(a1 & 0x7E0) >> 5;
  result = 2 * (a1 & 0x1F);
  *a2 = result;
  return result;
}

//----- (080CFD61) --------------------------------------------------------
int __cdecl sub_80CFD61(
        FILE **a1,
        int *a2,
        int *a3,
        _BYTE *ptr,
        unsigned int a5,
        void *a6,
        unsigned int a7,
        _BYTE *a8,
        unsigned int a9)
{
  int size; // [esp+1Ch] [ebp-7Ch]
  int sizea; // [esp+1Ch] [ebp-7Ch]
  int sizeb; // [esp+1Ch] [ebp-7Ch]
  int off; // [esp+20h] [ebp-78h]
  int offa; // [esp+20h] [ebp-78h]
  int v16; // [esp+24h] [ebp-74h] BYREF
  int v17; // [esp+28h] [ebp-70h]
  int v18; // [esp+2Ch] [ebp-6Ch] BYREF
  int v19[23]; // [esp+30h] [ebp-68h] BYREF
  FILE **v20; // [esp+8Ch] [ebp-Ch]

  v17 = 0;
  if ( !a1 )
    return -102;
  v20 = a1;
  if ( FS_FileSeek(*a1, (int)a1[3] + (_DWORD)a1[5], 0) )
    v17 = -1;
  if ( !v17 )
  {
    if ( sub_80CF648(*v20, &v16) )
    {
      v17 = -1;
    }
    else if ( v16 != 33639248 )
    {
      v17 = -103;
    }
  }
  if ( sub_80CF610(*v20, v19) )
    v17 = -1;
  if ( sub_80CF610(*v20, &v19[1]) )
    v17 = -1;
  if ( sub_80CF610(*v20, &v19[2]) )
    v17 = -1;
  if ( sub_80CF610(*v20, &v19[3]) )
    v17 = -1;
  if ( sub_80CF648(*v20, &v19[4]) )
    v17 = -1;
  sub_80CFCED(v19[4], &v19[14]);
  if ( sub_80CF648(*v20, &v19[5]) )
    v17 = -1;
  if ( sub_80CF648(*v20, &v19[6]) )
    v17 = -1;
  if ( sub_80CF648(*v20, &v19[7]) )
    v17 = -1;
  if ( sub_80CF610(*v20, &v19[8]) )
    v17 = -1;
  if ( sub_80CF610(*v20, &v19[9]) )
    v17 = -1;
  if ( sub_80CF610(*v20, &v19[10]) )
    v17 = -1;
  if ( sub_80CF610(*v20, &v19[11]) )
    v17 = -1;
  if ( sub_80CF610(*v20, &v19[12]) )
    v17 = -1;
  if ( sub_80CF648(*v20, &v19[13]) )
    v17 = -1;
  if ( sub_80CF648(*v20, &v18) )
    v17 = -1;
  off = v19[8];
  if ( !v17 && ptr )
  {
    if ( v19[8] >= a5 )
    {
      size = a5;
    }
    else
    {
      ptr[v19[8]] = 0;
      size = v19[8];
    }
    if ( v19[8] && a5 && FS_FileRead(ptr, size, 1u, *v20) != 1 )
      v17 = -1;
    off -= size;
  }
  if ( v17 || !a6 )
  {
    offa = v19[9] + off;
  }
  else
  {
    if ( v19[9] >= a7 )
      sizea = a7;
    else
      sizea = v19[9];
    if ( off )
    {
      if ( FS_FileSeek(*v20, off, 1) )
        v17 = -1;
      else
        off = 0;
    }
    if ( v19[9] && a7 && FS_FileRead(a6, sizea, 1u, *v20) != 1 )
      v17 = -1;
    offa = v19[9] - sizea + off;
  }
  if ( !v17 && a8 )
  {
    if ( v19[10] >= a9 )
    {
      sizeb = a9;
    }
    else
    {
      a8[v19[10]] = 0;
      sizeb = v19[10];
    }
    if ( offa && FS_FileSeek(*v20, offa, 1) )
      v17 = -1;
    if ( v19[10] && a9 && FS_FileRead(a8, sizeb, 1u, *v20) != 1 )
      v17 = -1;
  }
  if ( !v17 && a2 )
    qmemcpy(a2, v19, 0x50u);
  if ( !v17 && a3 )
    *a3 = v18;
  return v17;
}

//----- (080D0235) --------------------------------------------------------
int __cdecl unzGetCurrentFileInfo(FILE **a1, int *a2, _BYTE *ptr, int a4, void *a5, int a6, _BYTE *a7, int a8)
{
  return sub_80CFD61(a1, a2, 0, ptr, a4, a5, a6, a7, a8);
}

//----- (080D0281) --------------------------------------------------------
int __cdecl unzGoToFirstFile(int a1)
{
  int v3; // [esp+34h] [ebp-4h]

  if ( !a1 )
    return -102;
  *(_DWORD *)(a1 + 20) = *(_DWORD *)(a1 + 36);
  *(_DWORD *)(a1 + 16) = 0;
  v3 = sub_80CFD61((FILE **)a1, (int *)(a1 + 40), (int *)(a1 + 120), 0, 0, 0, 0, 0, 0);
  *(_DWORD *)(a1 + 24) = v3 == 0;
  return v3;
}

//----- (080D0329) --------------------------------------------------------
int __cdecl unzGoToNextFile(int a1)
{
  int v3; // [esp+28h] [ebp-10h]

  if ( !a1 )
    return -102;
  if ( !*(_DWORD *)(a1 + 24) )
    return -100;
  if ( *(_DWORD *)(a1 + 16) + 1 == *(_DWORD *)(a1 + 4) )
    return -100;
  *(_DWORD *)(a1 + 20) += *(_DWORD *)(a1 + 80) + *(_DWORD *)(a1 + 76) + *(_DWORD *)(a1 + 72) + 46;
  ++*(_DWORD *)(a1 + 16);
  v3 = sub_80CFD61((FILE **)a1, (int *)(a1 + 40), (int *)(a1 + 120), 0, 0, 0, 0, 0, 0);
  *(_DWORD *)(a1 + 24) = v3 == 0;
  return v3;
}

//----- (080D0417) --------------------------------------------------------
int __cdecl sub_80D0417(int a1, _DWORD *a2)
{
  if ( !a1 )
    return -102;
  *a2 = *(_DWORD *)(a1 + 20);
  return 0;
}

//----- (080D0449) --------------------------------------------------------
int __cdecl unzSetCurrentFileInfoPosition(int a1, int a2)
{
  if ( !a1 )
    return -102;
  *(_DWORD *)(a1 + 20) = a2;
  *(_DWORD *)(a1 + 24) = sub_80CFD61((FILE **)a1, (int *)(a1 + 40), (int *)(a1 + 120), 0, 0, 0, 0, 0, 0) == 0;
  return 0;
}

//----- (080D060A) --------------------------------------------------------
int __cdecl sub_80D060A(int a1, _DWORD *a2, _DWORD *a3, int *a4)
{
  int v6; // [esp+10h] [ebp-18h]
  int v7; // [esp+14h] [ebp-14h] BYREF
  int v8; // [esp+18h] [ebp-10h] BYREF
  int v9; // [esp+1Ch] [ebp-Ch] BYREF
  int v10; // [esp+20h] [ebp-8h] BYREF
  int v11; // [esp+24h] [ebp-4h] BYREF

  v6 = 0;
  *a2 = 0;
  *a3 = 0;
  *a4 = 0;
  if ( FS_FileSeek(*(FILE **)a1, *(_DWORD *)(a1 + 120) + *(_DWORD *)(a1 + 12), 0) )
    return -1;
  if ( sub_80CF648(*(FILE **)a1, &v11) )
  {
    v6 = -1;
  }
  else if ( v11 != 67324752 )
  {
    v6 = -103;
  }
  if ( sub_80CF610(*(FILE **)a1, &v10) )
    v6 = -1;
  if ( sub_80CF610(*(FILE **)a1, &v9) )
    v6 = -1;
  if ( sub_80CF610(*(FILE **)a1, &v10) )
  {
    v6 = -1;
  }
  else if ( !v6 && v10 != *(_DWORD *)(a1 + 52) )
  {
    v6 = -103;
  }
  if ( !v6 && *(_DWORD *)(a1 + 52) && *(_DWORD *)(a1 + 52) != 8 )
    v6 = -103;
  if ( sub_80CF648(*(FILE **)a1, &v10) )
    v6 = -1;
  if ( sub_80CF648(*(FILE **)a1, &v10) )
  {
    v6 = -1;
  }
  else if ( !v6 && v10 != *(_DWORD *)(a1 + 60) && (v9 & 8) == 0 )
  {
    v6 = -103;
  }
  if ( sub_80CF648(*(FILE **)a1, &v10) )
  {
    v6 = -1;
  }
  else if ( !v6 && v10 != *(_DWORD *)(a1 + 64) && (v9 & 8) == 0 )
  {
    v6 = -103;
  }
  if ( sub_80CF648(*(FILE **)a1, &v10) )
  {
    v6 = -1;
  }
  else if ( !v6 && v10 != *(_DWORD *)(a1 + 68) && (v9 & 8) == 0 )
  {
    v6 = -103;
  }
  if ( sub_80CF610(*(FILE **)a1, &v8) )
  {
    v6 = -1;
  }
  else if ( !v6 && v8 != *(_DWORD *)(a1 + 72) )
  {
    v6 = -103;
  }
  *a2 += v8;
  if ( sub_80CF610(*(FILE **)a1, &v7) )
    v6 = -1;
  *a3 = *(_DWORD *)(a1 + 120) + v8 + 30;
  *a4 = v7;
  *a2 += v7;
  return v6;
}
// 80D066B: conditional instruction was optimized away because %var_18.4==0

//----- (080D08B2) --------------------------------------------------------
int __cdecl unzOpenCurrentFile(_DWORD *a1)
{
  _DWORD *v1; // ebx
  int v4; // [esp+18h] [ebp-20h] BYREF
  int v5; // [esp+1Ch] [ebp-1Ch] BYREF
  void *ptr; // [esp+20h] [ebp-18h]
  _DWORD *v7; // [esp+24h] [ebp-14h]
  int v8; // [esp+28h] [ebp-10h] BYREF
  _BOOL4 v9; // [esp+2Ch] [ebp-Ch]
  int v10; // [esp+30h] [ebp-8h]

  v10 = 0;
  if ( !a1 )
    return -102;
  v7 = a1;
  if ( !a1[6] )
    return -102;
  if ( v7[31] )
    sub_80D0F1A((int)a1);
  if ( sub_80D060A((int)v7, &v8, &v5, &v4) )
    return -103;
  ptr = malloc(0x64u);
  if ( !ptr )
    return -104;
  v1 = ptr;
  *v1 = malloc(0x4000u);
  *((_DWORD *)ptr + 17) = v5;
  *((_DWORD *)ptr + 18) = v4;
  *((_DWORD *)ptr + 19) = 0;
  if ( *(_DWORD *)ptr )
  {
    *((_DWORD *)ptr + 16) = 0;
    if ( v7[13] && v7[13] != 8 )
      v10 = -103;
    v9 = v7[13] == 0;
    *((_DWORD *)ptr + 23) = v7[13];
    *((_DWORD *)ptr + 22) = *v7;
    *((_DWORD *)ptr + 24) = v7[3];
    *((_DWORD *)ptr + 6) = 0;
    if ( !v9 )
    {
      *((_DWORD *)ptr + 9) = 0;
      *((_DWORD *)ptr + 10) = 0;
      *((_DWORD *)ptr + 11) = 0;
      v10 = sub_80CAD79((_DWORD *)ptr + 1, -15, "1.1.4", 56);
      if ( !v10 )
        *((_DWORD *)ptr + 16) = 1;
    }
    *((_DWORD *)ptr + 20) = v7[16];
    *((_DWORD *)ptr + 21) = v7[17];
    *((_DWORD *)ptr + 15) = v7[30] + v8 + 30;
    *((_DWORD *)ptr + 2) = 0;
    v7[31] = ptr;
    return 0;
  }
  else
  {
    free(ptr);
    return -104;
  }
}

//----- (080D0AA8) --------------------------------------------------------
int __cdecl sub_80D0AA8(int a1, int a2, unsigned int a3)
{
  size_t v5; // [esp+24h] [ebp-24h]
  size_t i; // [esp+30h] [ebp-18h]
  size_t size; // [esp+34h] [ebp-14h]
  size_t sizea; // [esp+34h] [ebp-14h]
  size_t sizeb; // [esp+34h] [ebp-14h]
  int v10; // [esp+38h] [ebp-10h]
  int v11; // [esp+40h] [ebp-8h]
  int v12; // [esp+44h] [ebp-4h]

  v12 = 0;
  v11 = 0;
  if ( !a1 )
    return -102;
  v10 = *(_DWORD *)(a1 + 124);
  if ( !v10 )
    return -102;
  if ( !*(_DWORD *)v10 )
    return -100;
  if ( !a3 )
    return 0;
  *(_DWORD *)(v10 + 16) = a2;
  *(_DWORD *)(v10 + 20) = a3;
  if ( a3 > *(_DWORD *)(v10 + 84) )
    *(_DWORD *)(v10 + 20) = *(_DWORD *)(v10 + 84);
  while ( *(_DWORD *)(v10 + 20) )
  {
    if ( !*(_DWORD *)(v10 + 8) && *(_DWORD *)(v10 + 80) )
    {
      size = 0x4000;
      if ( *(_DWORD *)(v10 + 80) < 0x4000u )
        size = *(_DWORD *)(v10 + 80);
      if ( !size )
        return 0;
      if ( FS_FileSeek(*(FILE **)(v10 + 88), *(_DWORD *)(v10 + 60) + *(_DWORD *)(v10 + 96), 0) )
        return -1;
      if ( FS_FileRead(*(void **)v10, size, 1u, *(FILE **)(v10 + 88)) != 1 )
        return -1;
      *(_DWORD *)(v10 + 60) += size;
      *(_DWORD *)(v10 + 80) -= size;
      *(_DWORD *)(v10 + 4) = *(_DWORD *)v10;
      *(_DWORD *)(v10 + 8) = size;
    }
    if ( *(_DWORD *)(v10 + 92) )
    {
      sizeb = *(_DWORD *)(v10 + 24);
      v12 = sub_80CAF39((unsigned __int8 **)(v10 + 4), 2);
      v5 = *(_DWORD *)(v10 + 24) - sizeb;
      *(_DWORD *)(v10 + 84) -= v5;
      v11 += v5;
      if ( v12 == 1 )
        return v11;
      if ( v12 )
        break;
    }
    else
    {
      if ( *(_DWORD *)(v10 + 20) >= *(_DWORD *)(v10 + 8) )
        sizea = *(_DWORD *)(v10 + 8);
      else
        sizea = *(_DWORD *)(v10 + 20);
      for ( i = 0; i < sizea; ++i )
        *(_BYTE *)(i + *(_DWORD *)(v10 + 16)) = *(_BYTE *)(*(_DWORD *)(v10 + 4) + i);
      *(_DWORD *)(v10 + 84) -= sizea;
      *(_DWORD *)(v10 + 8) -= sizea;
      *(_DWORD *)(v10 + 20) -= sizea;
      *(_DWORD *)(v10 + 16) += sizea;
      *(_DWORD *)(v10 + 4) += sizea;
      *(_DWORD *)(v10 + 24) += sizea;
      v11 += sizea;
    }
  }
  if ( v12 )
    return v12;
  else
    return v11;
}

//----- (080D0D98) --------------------------------------------------------
int __cdecl sub_80D0D98(int a1)
{
  int v3; // [esp+4h] [ebp-8h]

  if ( !a1 )
    return -102;
  v3 = *(_DWORD *)(a1 + 124);
  if ( v3 )
    return *(_DWORD *)(v3 + 24);
  else
    return -102;
}

//----- (080D0F1A) --------------------------------------------------------
int __cdecl sub_80D0F1A(int a1)
{
  void **ptr; // [esp+Ch] [ebp-Ch]

  if ( !a1 )
    return -102;
  ptr = *(void ***)(a1 + 124);
  if ( !ptr )
    return -102;
  free(*ptr);
  *ptr = 0;
  if ( ptr[16] )
    sub_80CACFD(ptr + 1);
  ptr[16] = 0;
  free(ptr);
  *(_DWORD *)(a1 + 124) = 0;
  return 0;
}

//----- (080D1096) --------------------------------------------------------
void *__cdecl sub_80D1096(int a1, int a2, int a3)
{
  return Z_MallocInternal(a3 * a2);
}

//----- (080D10AD) --------------------------------------------------------
void __cdecl sub_80D10AD(int a1, void *ptr)
{
  Z_FreeInternal(ptr);
}

//----- (080D1178) --------------------------------------------------------
void sub_80D1178()
{
  ;
}

//----- (080D117E) --------------------------------------------------------
ssize_t tty_FlushIn()
{
  ssize_t result; // eax
  char buf; // [esp+17h] [ebp-1h] BYREF

  do
    result = read(0, &buf, 1u);
  while ( result != -1 );
  return result;
}

//----- (080D11A8) --------------------------------------------------------
ssize_t sub_80D11A8()
{
  char buf; // [esp+17h] [ebp-1h] BYREF

  buf = 8;
  write(1, &buf, 1u);
  buf = 32;
  write(1, &buf, 1u);
  buf = 8;
  return write(1, &buf, 1u);
}

//----- (080D120E) --------------------------------------------------------
int sub_80D120E()
{
  int result; // eax
  int i; // [esp+4h] [ebp-4h]

  if ( dword_85501D0 )
  {
    ++dword_85501D0;
  }
  else
  {
    if ( dword_8550220 > 0 )
    {
      for ( i = 0; ; ++i )
      {
        result = i;
        if ( i >= dword_8550220 )
          break;
        sub_80D11A8();
      }
    }
    ++dword_85501D0;
  }
  return result;
}
// 85501D0: using guessed type int dword_85501D0;
// 8550220: using guessed type int dword_8550220;

//----- (080D1256) --------------------------------------------------------
int sub_80D1256()
{
  int result; // eax
  int i; // [esp+14h] [ebp-4h]

  if ( !--dword_85501D0 && dword_8550220 )
  {
    for ( i = 0; ; ++i )
    {
      result = i;
      if ( i >= dword_8550220 )
        break;
      write(1, (const void *)(i + 139788856), 1u);
    }
  }
  return result;
}
// 85501D0: using guessed type int dword_85501D0;
// 8550220: using guessed type int dword_8550220;

//----- (080D12B2) --------------------------------------------------------
int Sys_ConsoleInputShutdown()
{
  int result; // eax
  char v1; // [esp+4h] [ebp-14h]

  if ( dword_85501CC )
  {
    Com_Printf("Shutdown tty console\n", v1);
    return tcsetattr(0, 1, &termios_p);
  }
  return result;
}
// 80D12C8: variable 'v1' is possibly undefined
// 85501CC: using guessed type int dword_85501CC;

//----- (080D12EC) --------------------------------------------------------
unsigned int __cdecl sub_80D12EC(_DWORD *a1)
{
  unsigned int result; // eax
  unsigned int v2; // [esp+0h] [ebp-24h]
  const void *v3; // [esp+4h] [ebp-20h]
  char *v4; // [esp+8h] [ebp-1Ch]
  unsigned int v5; // [esp+Ch] [ebp-18h]
  const void *v6; // [esp+10h] [ebp-14h]
  void *v7; // [esp+14h] [ebp-10h]
  int i; // [esp+18h] [ebp-Ch]

  for ( i = 31; i > 0; --i )
  {
    v7 = (void *)(280 * i + 139789120);
    v6 = (const void *)(280 * i + 139788840);
    v5 = 280;
    if ( ((24 * (_BYTE)i + 64) & 4) != 0 )
    {
      dword_8550340[70 * i] = *((_DWORD *)&unk_8550228 + 70 * i);
      v7 = (void *)(280 * i + 139789124);
      v6 = (const void *)(280 * i + 139788844);
      v5 = 276;
    }
    qmemcpy(v7, v6, 4 * (v5 >> 2));
  }
  v4 = (char *)dword_8550340;
  v3 = a1;
  v2 = 280;
  result = (unsigned int)dword_8550340 & 4;
  if ( ((unsigned int)dword_8550340 & 4) != 0 )
  {
    result = *a1;
    dword_8550340[0] = *a1;
    v4 = (char *)&dword_8550340[1];
    v3 = a1 + 1;
    v2 = 276;
  }
  qmemcpy(v4, v3, 4 * (v2 >> 2));
  if ( dword_8552640 <= 31 )
    ++dword_8552640;
  dword_8163F84 = -1;
  return result;
}
// 8163F84: using guessed type int dword_8163F84;
// 8550340: using guessed type _DWORD dword_8550340[2240];
// 8552640: using guessed type int dword_8552640;

//----- (080D13C8) --------------------------------------------------------
int sub_80D13C8()
{
  if ( dword_8163F84 + 1 >= dword_8552640 )
    return 0;
  ++dword_8163F84;
  return 280 * dword_8163F84 + 139789120;
}
// 8163F84: using guessed type int dword_8163F84;
// 8552640: using guessed type int dword_8552640;

//----- (080D140A) --------------------------------------------------------
int sub_80D140A()
{
  if ( dword_8163F84 >= 0 )
    --dword_8163F84;
  if ( dword_8163F84 == -1 )
    return 0;
  else
    return 280 * dword_8163F84 + 139789120;
}
// 8163F84: using guessed type int dword_8163F84;

//----- (080D144A) --------------------------------------------------------
void __cdecl __noreturn Sys_Exit(int status)
{
  Sys_ConsoleInputShutdown();
  if ( byte_8163FA0 )
  {
    sleep(1u);
    sub_80D266A(&byte_8163FA0);
    sleep(1u);
  }
  exit(status);
}

//----- (080D148E) --------------------------------------------------------
void __noreturn Sys_Quit()
{
  int v0; // eax

  Dvar_Shutdown();
  Cmd_Shutdown();
  Hunk_Shutdown();
  v0 = fcntl(0, 3, 0);
  fcntl(0, 4, v0 & 0xFFFFF7FF);
  Sys_Exit(0);
}
// 80D148E: using guessed type void __noreturn Sys_Quit();

//----- (080D14EA) --------------------------------------------------------
char *__usercall Sys_Init@<eax>(long double a1@<st0>)
{
  char *v1; // eax
  char *result; // eax

  Cmd_AddCommand("in_restart", (int)sub_80D1178);
  arch = (int)Dvar_RegisterString(a1, "arch", "linux i386", 4160);
  v1 = (char *)Sys_GetCurrentUser();
  result = Dvar_RegisterString(a1, "username", v1, 4160);
  dword_8552648 = (int)result;
  return result;
}
// 8552644: using guessed type int arch;
// 8552648: using guessed type int dword_8552648;

//----- (080D1550) --------------------------------------------------------
void __noreturn Sys_Error(char *format, ...)
{
  int v1; // eax
  char s[1036]; // [esp+10h] [ebp-418h] BYREF
  __gnuc_va_list __varargs; // [esp+41Ch] [ebp-Ch]
  va_list va; // [esp+434h] [ebp+Ch] BYREF

  va_start(va, format);
  v1 = fcntl(0, 3, 0);
  fcntl(0, 4, v1 & 0xFFFFF7FF);
  if ( dword_85501CC )
    sub_80D120E();
  va_copy(__varargs, va);
  vsprintf(s, format, va);
  fprintf(stderr, "Sys_Error: %s\n", s);
  Sys_Exit(1);
}
// 85501CC: using guessed type int dword_85501CC;

//----- (080D15F0) --------------------------------------------------------
int Sys_Warn(char *format, ...)
{
  int result; // eax
  char s[1036]; // [esp+10h] [ebp-418h] BYREF
  __gnuc_va_list __varargs; // [esp+41Ch] [ebp-Ch]
  va_list va; // [esp+434h] [ebp+Ch] BYREF

  va_start(va, format);
  va_copy(__varargs, va);
  vsprintf(s, format, va);
  if ( dword_85501CC )
    sub_80D120E();
  result = fprintf(stderr, "Warning: %s", s);
  if ( dword_85501CC )
    return sub_80D1256();
  return result;
}
// 85501CC: using guessed type int dword_85501CC;

//----- (080D1658) --------------------------------------------------------
__time_t __cdecl sub_80D1658(char *filename)
{
  struct stat stat_buf; // [esp+20h] [ebp-68h] BYREF

  if ( FS_stat(filename, &stat_buf) == -1 )
    return -1;
  else
    return stat_buf.st_mtim.tv_sec;
}

//----- (080D168C) --------------------------------------------------------
void handler()
{
  signal(8, handler);
}

//----- (080D16A8) --------------------------------------------------------
void __usercall Sys_ConsoleInputInit(long double a1@<st0>)
{
  struct termios s; // [esp+10h] [ebp-48h] BYREF

  memset(&s, 0, sizeof(s));
  signal(21, (__sighandler_t)1);
  signal(22, (__sighandler_t)1);
  ttycon = (int)Dvar_RegisterBool(a1, "ttycon", 1, 4112);
  Dvar_SetBool(ttycon, 0);
  if ( (unsigned __int8)Dvar_GetBool("ttycon") )
  {
    if ( isatty(0) == 1 )
    {
      Com_Printf("Started tty console (use +set ttycon 0 to disable)\n");
      Field_Clear(&dword_8550220);
      tcgetattr(0, &termios_p);
      dword_85501D4 = s.c_cc[2];
      dword_85501D8 = s.c_cc[4];
      qmemcpy(&s, &termios_p, sizeof(s));
      s.c_lflag &= 0xFFFFFFF5;
      s.c_iflag &= 0xFFFFFFCF;
      s.c_cc[6] = 1;
      s.c_cc[5] = 0;
      tcsetattr(0, 1, &s);
      dword_85501CC = 1;
    }
    else
    {
      Com_Printf("stdin is not a tty, tty console mode failed\n");
      Dvar_SetBool(ttycon, 0);
      dword_85501CC = 0;
    }
  }
  else
  {
    dword_85501CC = 0;
  }
}
// 85501C8: using guessed type int ttycon;
// 85501CC: using guessed type int dword_85501CC;
// 85501D4: using guessed type int dword_85501D4;
// 85501D8: using guessed type int dword_85501D8;
// 8550220: using guessed type int dword_8550220;

//----- (080D181A) --------------------------------------------------------
char *Sys_ConsoleInput()
{
  unsigned int v1; // [esp+24h] [ebp-D4h]
  int *v2; // [esp+28h] [ebp-D0h]
  int *v3; // [esp+2Ch] [ebp-CCh]
  unsigned int v4; // [esp+30h] [ebp-C8h]
  int *v5; // [esp+34h] [ebp-C4h]
  int *v6; // [esp+38h] [ebp-C0h]
  struct timeval timeout; // [esp+48h] [ebp-B0h] BYREF
  fd_set readfds; // [esp+50h] [ebp-A8h] BYREF
  ssize_t v10; // [esp+DCh] [ebp-1Ch]
  int *v11; // [esp+E0h] [ebp-18h]
  char buf; // [esp+E7h] [ebp-11h] BYREF
  ssize_t v13; // [esp+E8h] [ebp-10h]
  int i; // [esp+ECh] [ebp-Ch]

  buf = 0;
  if ( !(unsigned __int8)Dvar_GetBool("ttycon") )
  {
    if ( !dword_8163F80 )
      return 0;
    memset(&readfds, 0, sizeof(readfds));
    readfds.__fds_bits[0] |= 1u;
    timeout.tv_sec = 0;
    timeout.tv_usec = 0;
    if ( select(1, &readfds, 0, 0, &timeout) == -1 || !_bittest(readfds.__fds_bits, 0) )
      return 0;
    v10 = read(0, ::buf, 0x100u);
    if ( v10 )
    {
      if ( v10 > 0 )
      {
        *(_BYTE *)(v10 + 139798111) = 0;
        return ::buf;
      }
      else
      {
        return 0;
      }
    }
    else
    {
      dword_8163F80 = 0;
      return 0;
    }
  }
  v13 = read(0, &buf, 1u);
  if ( v13 == -1 )
    return 0;
  if ( buf == dword_85501D4 || buf == 127 || buf == 8 )
  {
    if ( dword_8550220 > 0 )
    {
      *(_BYTE *)(--dword_8550220 + 139788856) = 0;
      sub_80D11A8();
    }
    return 0;
  }
  if ( !buf || buf > 31 )
  {
    *(_BYTE *)(dword_8550220 + 139788856) = buf;
    ++dword_8550220;
    write(1, &buf, 1u);
    return 0;
  }
  if ( buf == 10 )
  {
    sub_80D12EC(&dword_8550220);
    strcpy(::buf, &byte_8550238);
    Field_Clear(&dword_8550220);
    buf = 10;
    write(1, &buf, 1u);
    return ::buf;
  }
  if ( buf == 9 )
  {
    sub_80D120E();
    sub_8060924();
    dword_8550220 = strlen(&byte_8550238);
    if ( dword_8550220 > 0 && byte_8550238 == 92 )
    {
      for ( i = 0; i <= dword_8550220; ++i )
        *(_BYTE *)(i + 139788856) = *(_BYTE *)(i + 139788857);
      --dword_8550220;
    }
    sub_80D1256();
    return 0;
  }
  v13 = read(0, &buf, 1u);
  if ( v13 == -1 || buf != 91 && buf != 79 || (v13 = read(0, &buf, 1u), v13 == -1) )
  {
LABEL_45:
    Com_DPrintf("droping ISCTL sequence: %d, tty_erase: %d\n", buf, dword_85501D4);
    tty_FlushIn();
    return 0;
  }
  if ( buf == 66 )
  {
    v11 = (int *)sub_80D140A();
    sub_80D120E();
    if ( v11 )
    {
      v3 = &dword_8550220;
      v2 = v11;
      v1 = 280;
      if ( ((unsigned int)&dword_8550220 & 4) != 0 )
      {
        dword_8550220 = *v11;
        v3 = &dword_8550220 + 1;
        v2 = v11 + 1;
        v1 = 276;
      }
      qmemcpy(v3, v2, 4 * (v1 >> 2));
    }
    else
    {
      Field_Clear(&dword_8550220);
    }
    sub_80D1256();
    tty_FlushIn();
    return 0;
  }
  if ( buf > 66 )
  {
    if ( buf == 67 )
      return 0;
    if ( buf == 68 )
      return 0;
    goto LABEL_45;
  }
  if ( buf != 65 )
    goto LABEL_45;
  v11 = (int *)sub_80D13C8();
  if ( v11 )
  {
    sub_80D120E();
    v6 = &dword_8550220;
    v5 = v11;
    v4 = 280;
    if ( ((unsigned int)&dword_8550220 & 4) != 0 )
    {
      dword_8550220 = *v11;
      v6 = &dword_8550220 + 1;
      v5 = v11 + 1;
      v4 = 276;
    }
    qmemcpy(v6, v5, 4 * (v4 >> 2));
    sub_80D1256();
  }
  tty_FlushIn();
  return 0;
}
// 8163F80: using guessed type int dword_8163F80;
// 85501D4: using guessed type int dword_85501D4;
// 8550220: using guessed type int dword_8550220;

//----- (080D1D3E) --------------------------------------------------------
void __cdecl Sys_UnloadGame(void *handle)
{
  char *v1; // [esp+14h] [ebp-4h]

  if ( handle )
  {
    dlclose(handle);
    v1 = dlerror();
    if ( v1 )
      Com_Printf("Sys_UnloadGame failed on dlclose: \"%s\"!\n", v1);
  }
  else
  {
    Com_Printf("Sys_UnloadDll(NULL)\n");
  }
}

//----- (080D1D86) --------------------------------------------------------
void sub_80D1D86()
{
  ;
}

//----- (080D1DA6) --------------------------------------------------------
void __cdecl __noreturn sub_80D1DA6(const char *a1, int a2)
{
  fprintf(stderr, "OUT OF MEMORY! ABORTING!!! (%s:%d)\n", a1, a2);
  exit(-1);
}

//----- (080D1DDC) --------------------------------------------------------
void __noreturn sub_80D1DDC()
{
  Com_Error(0, "Unable to load shared library\n");
}

//----- (080D1DF8) --------------------------------------------------------
void *__cdecl Sys_LoadDll(const char *a1, char *dest, const void **a3, int a4)
{
  char *v4; // eax
  char *v6; // [esp+1Ch] [ebp-22Ch]
  char file[256]; // [esp+20h] [ebp-228h] BYREF
  char *v8; // [esp+120h] [ebp-128h]
  void *v9; // [esp+124h] [ebp-124h]
  void *v10; // [esp+128h] [ebp-120h]
  void *src; // [esp+12Ch] [ebp-11Ch]
  char s[264]; // [esp+130h] [ebp-118h] BYREF
  void (__cdecl *v13)(int); // [esp+238h] [ebp-10h]
  void *handle; // [esp+23Ch] [ebp-Ch]

  *dest = 0;
  snprintf(s, 0x100u, "%s.mp.i386.so", a1);
  src = Sys_Cwd();
  v10 = Dvar_GetString("fs_homepath");
  v9 = Dvar_GetString("fs_basepath");
  v8 = (char *)Dvar_GetString("fs_game");
  FS_BuildOSPath((char *)src, v8, s, file);
  Com_Printf("Sys_LoadDll(%s)... ", file);
  handle = dlopen(file, 2);
  if ( handle
    || (Com_Printf("failed\n"),
        FS_BuildOSPath((char *)v10, v8, s, file),
        Com_Printf("Sys_LoadDll(%s)... ", file),
        (handle = dlopen(file, 2)) != 0) )
  {
    Com_Printf("ok\n");
  }
  else
  {
    Com_Printf("failed\n");
    FS_BuildOSPath((char *)v9, v8, s, file);
    Com_Printf("Sys_LoadDll(%s)... ", file);
    handle = dlopen(file, 2);
    if ( handle )
    {
      Com_Printf("ok\n");
    }
    else
    {
      v4 = dlerror();
      Com_Printf("\nSys_LoadDll(%s) failed:\n\"%s\"\n", file, v4);
    }
    if ( !handle )
      Com_Error(0, "Sys_LoadDll(%s) failed dlopen() completely!\n", a1);
  }
  I_strncpyz(dest, file, 64);
  v13 = (void (__cdecl *)(int))dlsym(handle, "dllEntry");
  *a3 = dlsym(handle, "vmMain");
  if ( !*a3 || !v13 )
  {
    v6 = dlerror();
    Com_Error(0, "Sys_LoadDll(%s) failed dlsym(vmMain):\n\"%s\" !\n", a1, v6);
  }
  Com_Printf("Sys_LoadDll(%s) found **vmMain** at  %p  \n", a1, *a3);
  v13(a4);
  Com_Printf("Sys_LoadDll(%s) succeeded!\n", a1);
  return handle;
}
// 80D1DF8: using guessed type const char *arg_0;

//----- (080D2168) --------------------------------------------------------
void sub_80D2168()
{
  ;
}

//----- (080D216E) --------------------------------------------------------
int __cdecl sub_80D216E(int a1, int a2, int a3, int a4)
{
  return FS_Read(a1, a3 * a2, a4);
}

//----- (080D2194) --------------------------------------------------------
int __cdecl sub_80D2194(int a1, int off, int a3)
{
  return sub_809E580(a1, off, a3);
}

//----- (080D21B6) --------------------------------------------------------
int __cdecl Sys_QueEvent(int a1, int a2, int a3, int a4, int a5, int a6)
{
  int result; // eax
  int *v7; // [esp+4h] [ebp-4h]

  v7 = &dword_8552760[6 * (unsigned __int8)dword_8553F60];
  if ( dword_8553F60 - dword_8553F64 > 255 )
  {
    Com_Printf("Sys_QueEvent: overflow\n");
    if ( v7[5] )
      Z_FreeInternal((void *)v7[5]);
    ++dword_8553F64;
  }
  ++dword_8553F60;
  if ( !a1 )
    a1 = Sys_MilliSeconds();
  *v7 = a1;
  v7[1] = a2;
  v7[2] = a3;
  v7[3] = a4;
  v7[4] = a5;
  result = a6;
  v7[5] = a6;
  return result;
}
// 8552760: using guessed type int dword_8552760[];
// 8553F60: using guessed type int dword_8553F60;
// 8553F64: using guessed type int dword_8553F64;

//----- (080D2262) --------------------------------------------------------
_DWORD *__stdcall Sys_GetEvent(_DWORD *a1)
{
  int v1; // edx
  size_t size; // [esp+28h] [ebp-80h]
  _DWORD *sizea; // [esp+28h] [ebp-80h]
  char *dest; // [esp+2Ch] [ebp-7Ch]
  char *desta; // [esp+2Ch] [ebp-7Ch]
  int v7[8]; // [esp+30h] [ebp-78h] BYREF
  char v8[4]; // [esp+50h] [ebp-58h] BYREF
  void *src; // [esp+54h] [ebp-54h]
  size_t n; // [esp+5Ch] [ebp-4Ch]
  char *s; // [esp+7Ch] [ebp-2Ch]
  int v12[10]; // [esp+80h] [ebp-28h] BYREF

  if ( dword_8553F60 > dword_8553F64 )
    goto LABEL_2;
  s = Sys_ConsoleInput();
  if ( s )
  {
    size = strlen(s) + 1;
    dest = (char *)Z_MallocInternal(size);
    strcpy(dest, s);
    Sys_QueEvent(0, 4, 0, 0, size, (int)dest);
  }
  MSG_Init(v8, (int)&unk_8553F80, 0x4000);
  if ( Sys_GetPacket(v7, (int)v8) )
  {
    desta = (char *)(n + 20);
    sizea = Z_MallocInternal(n + 20);
    *sizea = v7[0];
    sizea[1] = v7[1];
    sizea[2] = v7[2];
    sizea[3] = v7[3];
    sizea[4] = v7[4];
    memcpy(sizea + 5, src, n);
    Sys_QueEvent(0, 5, 0, 0, (int)desta, (int)sizea);
  }
  if ( dword_8553F60 > dword_8553F64 )
  {
LABEL_2:
    v1 = 6 * (unsigned __int8)dword_8553F64++;
    *a1 = dword_8552760[v1];
    a1[1] = dword_8552764[v1];
    a1[2] = dword_8552768[v1];
    a1[3] = dword_855276C[v1];
    a1[4] = dword_8552770[v1];
    a1[5] = dword_8552774[v1];
  }
  else
  {
    memset(v12, 0, 0x18u);
    v12[0] = Sys_MilliSeconds();
    *a1 = v12[0];
    a1[1] = v12[1];
    a1[2] = v12[2];
    a1[3] = v12[3];
    a1[4] = v12[4];
    a1[5] = v12[5];
  }
  return a1;
}
// 8552760: using guessed type int dword_8552760[];
// 8552764: using guessed type int dword_8552764[];
// 8552768: using guessed type int dword_8552768[];
// 855276C: using guessed type int dword_855276C[];
// 8552770: using guessed type int dword_8552770[];
// 8552774: using guessed type int dword_8552774[];
// 8553F60: using guessed type int dword_8553F60;
// 8553F64: using guessed type int dword_8553F64;
// 80D2262: using guessed type char var_58[4];

//----- (080D24F4) --------------------------------------------------------
int __cdecl sub_80D24F4(char *s)
{
  int result; // eax

  if ( dword_85501CC )
    sub_80D120E();
  result = fputs(s, stderr);
  if ( dword_85501CC )
    return sub_80D1256();
  return result;
}
// 85501CC: using guessed type int dword_85501CC;

//----- (080D252C) --------------------------------------------------------
void Sys_ConfigureFPU()
{
  ;
}

//----- (080D253E) --------------------------------------------------------
int __cdecl Sys_PrintBinVersion(const char *a1)
{
  fprintf(stdout, "\n\n%s\n", "==============================================================");
  fprintf(stdout, "Linux Quake3 Dedicated Server [%s %s]\n", "Oct 25 2005", "18:23:51");
  fprintf(stdout, " local install: %s\n", a1);
  return fprintf(stdout, "%s\n\n", "==============================================================");
}

//----- (080D25D2) --------------------------------------------------------
void __cdecl sub_80D25D2(char *file, int a2)
{
  int *v2; // eax
  int *v3; // eax
  const char *v4; // [esp+8h] [ebp-80h]
  __mode_t mode; // [esp+1Ch] [ebp-6Ch]
  struct stat stat_buf; // [esp+20h] [ebp-68h] BYREF

  if ( FS_stat(file, &stat_buf) )
  {
    v2 = __errno_location();
    Com_Printf("stat('%s')  failed: errno %d\n", file, *v2);
  }
  else
  {
    mode = stat_buf.st_mode | a2;
    if ( chmod(file, stat_buf.st_mode | a2) )
    {
      v3 = __errno_location();
      Com_Printf("chmod('%s', %d) failed: errno %d\n", file, mode, *v3);
    }
    Com_DPrintf("chmod +%d '%s'\n", file, v4);
  }
}
// 80D2663: variable 'v4' is possibly undefined

//----- (080D266A) --------------------------------------------------------
__pid_t __cdecl sub_80D266A(char *s)
{
  __pid_t result; // eax

  result = fork();
  if ( !result )
  {
    if ( strchr(s, 32) )
      system(s);
    else
      execl(s, s, 0);
    _exit(0);
  }
  return result;
}

//----- (080D26D2) --------------------------------------------------------
void __cdecl Sys_StartProcess(char *src, int a2)
{
  if ( a2 )
  {
    Com_DPrintf("Sys_StartProcess %s (delaying to final exit)\n", src);
    I_strncpyz(&byte_8163FA0, src, 1024);
    Cbuf_ExecuteText(2, "quit\n");
  }
  else
  {
    Com_DPrintf("Sys_StartProcess %s\n", src);
    sub_80D266A(src);
  }
}

//----- (080D2742) --------------------------------------------------------
void __cdecl Sys_OpenURL(const char *a1, int a2)
{
  char s[1024]; // [esp+20h] [ebp-538h] BYREF
  char name[256]; // [esp+420h] [ebp-138h] BYREF
  char dest[36]; // [esp+520h] [ebp-38h] BYREF
  char v5[4]; // [esp+544h] [ebp-14h]
  char v6[4]; // [esp+548h] [ebp-10h]
  char v7[4]; // [esp+54Ch] [ebp-Ch]

  Com_Printf("Sys_OpenURL %s\n", a1);
  I_strncpyz(dest, "openurl.sh", 20);
  *(_DWORD *)v5 = Sys_Cwd();
  Com_sprintf(name, 0x100u, "%s/%s", *(const char **)v5, dest);
  if ( access(name, 1) == -1
    && (Com_DPrintf("%s not found\n", name),
        *(_DWORD *)v6 = Dvar_GetString("fs_homepath"),
        Com_sprintf(name, 0x100u, "%s/%s", *(const char **)v6, dest),
        access(name, 1) == -1)
    && (Com_DPrintf("%s not found\n", name),
        *(_DWORD *)v7 = Dvar_GetString("fs_basepath"),
        Com_sprintf(name, 0x100u, "%s/%s", *(const char **)v7, dest),
        access(name, 1) == -1) )
  {
    Com_DPrintf("%s not found\n", name);
    Com_Printf("Can't find script '%s' to open requested URL (use +set developer 1 for more verbosity)\n", dest);
  }
  else
  {
    Com_DPrintf("URL script: %s\n", name);
    Com_sprintf(s, 0x400u, "%s '%s' &", name, a1);
    Sys_StartProcess(s, a2);
  }
}
// 80D2742: using guessed type const char *arg_0;

//----- (080D2930) --------------------------------------------------------
void __cdecl Sys_ParseArgs(int a1, const char **a2)
{
  if ( a1 == 2 && (!strcmp(a2[1], "--version") || !strcmp(a2[1], "-v")) )
  {
    Sys_PrintBinVersion(*a2);
    Sys_Exit(0);
  }
}

//----- (080D2990) --------------------------------------------------------
void __usercall __noreturn main(long double a1@<st0>, int a2, char **a3)
{
  void *v3; // esp
  __uid_t v4; // eax
  int v5; // eax
  char *dest; // [esp+Ch] [ebp-Ch]
  int i; // [esp+10h] [ebp-8h]
  int j; // [esp+10h] [ebp-8h]
  unsigned int v9; // [esp+14h] [ebp-4h]

  v3 = alloca(0);
  saved_euid = geteuid();
  v4 = getuid();
  seteuid(v4);
  sub_806283E();
  Sys_InitMainThread();
  Dvar_Init(a1);
  Sys_ParseArgs(a2, (const char **)a3);
  Sys_SetDefaultCDPath((char *)&byte_814AE9F);
  v9 = 1;
  for ( i = 1; i < a2; ++i )
    v9 += strlen(a3[i]) + 1;
  dest = (char *)operator new[](v9);
  *dest = 0;
  for ( j = 1; j < a2; ++j )
  {
    if ( j > 1 )
      strcat(dest, " ");
    strcat(dest, a3[j]);
  }
  memset(dword_8552760, 0, 0x1800u);
  memset(&unk_8553F80, 0, 0x4000u);
  Sys_MilliSeconds();
  Com_Init(a1, dest);
  Sys_ConsoleInputInit(a1);
  v5 = fcntl(0, 3, 0);
  fcntl(0, 4, v5 | 0x800);
  while ( 1 )
  {
    Sys_ConfigureFPU();
    usleep(0x1388u);
    Com_Frame(a1);
  }
}
// 85501C4: using guessed type int saved_euid;
// 8552760: using guessed type int dword_8552760[];

//----- (080D2B24) --------------------------------------------------------
void __noreturn Sys_LoadRenderer()
{
  Com_Error(0, "Sys_LoadRenderer is unimplemented\n");
}

//----- (080D2B46) --------------------------------------------------------
void __noreturn Sys_UnloadRenderer()
{
  Com_Error(0, "Sys_UnloadRenderer is unimplemented\n");
}

//----- (080D2B64) --------------------------------------------------------
int __cdecl NetadrToSockadr(int a1, _WORD *s)
{
  int result; // eax

  memset(s, 0, 0x10u);
  if ( *(_DWORD *)a1 == 3 )
  {
    *s = 2;
    s[1] = *(_WORD *)(a1 + 8);
    result = (int)(s + 2);
    *((_DWORD *)s + 1) = -1;
  }
  else
  {
    result = a1;
    if ( *(_DWORD *)a1 == 4 )
    {
      *s = 2;
      *((_DWORD *)s + 1) = *(_DWORD *)(a1 + 4);
      result = *(unsigned __int16 *)(a1 + 8);
      s[1] = result;
    }
  }
  return result;
}

//----- (080D2BE2) --------------------------------------------------------
int __cdecl SockadrToNetadr(int a1, int a2)
{
  int result; // eax

  *(_DWORD *)(a2 + 4) = *(_DWORD *)(a1 + 4);
  *(_WORD *)(a2 + 8) = *(_WORD *)(a1 + 2);
  result = a2;
  *(_DWORD *)a2 = 4;
  return result;
}

//----- (080D2C0E) --------------------------------------------------------
char *__cdecl sub_80D2C0E(int a1, int a2)
{
  Com_sprintf(byte_855A040, 0x40u, "%i.%i.%i.%i", (unsigned __int8)a2, BYTE1(a2), BYTE2(a2), HIBYTE(a2));
  return byte_855A040;
}

//----- (080D2C58) --------------------------------------------------------
int __cdecl sub_80D2C58(char *cp, _WORD *s)
{
  struct hostent *v4; // [esp+10h] [ebp-8h]

  memset(s, 0, 0x10u);
  *s = 2;
  s[1] = 0;
  if ( *cp > 47 && *cp <= 57 )
  {
    *((_DWORD *)s + 1) = inet_addr(cp);
    return 1;
  }
  v4 = gethostbyname(cp);
  if ( v4 )
  {
    *((_DWORD *)s + 1) = **(_DWORD **)v4->h_addr_list;
    return 1;
  }
  return 0;
}

//----- (080D2CF0) --------------------------------------------------------
int __cdecl sub_80D2CF0(char *cp, int a2)
{
  _WORD s[12]; // [esp+20h] [ebp-18h] BYREF

  if ( !sub_80D2C58(cp, s) )
    return 0;
  SockadrToNetadr((int)s, a2);
  return 1;
}
// 80D2CF0: using guessed type _WORD s[12];

//----- (080D2D34) --------------------------------------------------------
int __cdecl Sys_GetPacket(int *a1, int a2)
{
  char *v2; // ebx
  char *v3; // eax
  char *v4; // eax
  int v7; // [esp+30h] [ebp-38h]
  int i; // [esp+34h] [ebp-34h]
  int fd; // [esp+38h] [ebp-30h]
  socklen_t addr_len; // [esp+3Ch] [ebp-2Ch] BYREF
  struct sockaddr addr; // [esp+40h] [ebp-28h] BYREF
  ssize_t v12; // [esp+5Ch] [ebp-Ch]

  for ( i = 0; i <= 1; ++i )
  {
    if ( i )
      fd = dword_8557F9C;
    else
      fd = ::fd;
    if ( fd )
    {
      addr_len = 16;
      v12 = recvfrom(fd, *(void **)(a2 + 4), *(_DWORD *)(a2 + 8), 0, &addr, &addr_len);
      SockadrToNetadr((int)&addr, (int)a1);
      *(_DWORD *)(a2 + 16) = 0;
      if ( v12 == -1 )
      {
        v7 = *__errno_location();
        if ( v7 != 11 && v7 != 111 )
        {
          v2 = NET_AdrToString(*a1, a1[1], a1[2], a1[3], a1[4]);
          v3 = NET_ErrorString();
          Com_Printf("NET_GetPacket: %s from %s\n", v3, v2);
        }
      }
      else
      {
        if ( v12 != *(_DWORD *)(a2 + 8) )
        {
          *(_DWORD *)(a2 + 12) = v12;
          return 1;
        }
        v4 = NET_AdrToString(*a1, a1[1], a1[2], a1[3], a1[4]);
        Com_Printf("Oversize packet from %s\n", v4);
      }
    }
  }
  return 0;
}
// 8557F9C: using guessed type int dword_8557F9C;

//----- (080D2EA8) --------------------------------------------------------
int __cdecl Sys_SendPacket(size_t n, void *buf, int a3, int a4, int a5, int a6, int a7)
{
  char *v7; // ebx
  char *v8; // eax
  int fd; // [esp+2Ch] [ebp-2Ch]
  struct sockaddr addr; // [esp+30h] [ebp-28h] BYREF
  ssize_t v13; // [esp+4Ch] [ebp-Ch]

  switch ( a3 )
  {
    case 3:
      fd = ::fd;
      break;
    case 4:
      fd = ::fd;
      break;
    case 5:
      fd = dword_8557F9C;
      break;
    case 6:
      fd = dword_8557F9C;
      break;
    default:
      Com_Error(0, "NET_SendPacket: bad address type");
  }
  if ( !fd )
    return 0;
  NetadrToSockadr((int)&a3, &addr);
  v13 = sendto(fd, buf, n, 0, &addr, 0x10u);
  if ( v13 != -1 )
    return 1;
  v7 = NET_AdrToString(a3, a4, a5, a6, a7);
  v8 = NET_ErrorString();
  Com_Printf("NET_SendPacket ERROR: %s to %s\n", v8, v7);
  return 0;
}
// 8557F9C: using guessed type int dword_8557F9C;

//----- (080D2FC8) --------------------------------------------------------
int __cdecl Sys_IsLANAddress(int a1, int a2)
{
  int i; // [esp+4h] [ebp-4h]

  if ( a1 == 2 )
    return 1;
  if ( a1 == 5 )
    return 1;
  if ( a1 != 4 )
    return 0;
  if ( (_BYTE)a2 == 10 )
    return 1;
  if ( (_BYTE)a2 == 127 )
    return 1;
  if ( (_WORD)a2 == 0xFEA9 )
    return 1;
  if ( (_BYTE)a2 == 0xAC && (BYTE1(a2) & 0xF0) == 16 )
    return 1;
  if ( (_WORD)a2 == 0xA8C0 )
    return 1;
  for ( i = 0; i < dword_8557FA0; ++i )
  {
    if ( (_BYTE)a2 == byte_8557FC0[4 * i] && BYTE1(a2) == byte_8557FC1[4 * i] && BYTE2(a2) == byte_8557FC2[4 * i] )
      return 1;
  }
  return 0;
}
// 8557FA0: using guessed type int dword_8557FA0;

//----- (080D30D2) --------------------------------------------------------
int Sys_ShowIP()
{
  int result; // eax
  int i; // [esp+14h] [ebp-4h]

  for ( i = 0; ; ++i )
  {
    result = i;
    if ( i >= dword_8557FA0 )
      break;
    Com_Printf(
      "IP: %i.%i.%i.%i\n",
      (unsigned __int8)byte_8557FC0[4 * i],
      (unsigned __int8)byte_8557FC1[4 * i],
      (unsigned __int8)byte_8557FC2[4 * i],
      (unsigned __int8)byte_8557FC3[4 * i]);
  }
  return result;
}
// 8557FA0: using guessed type int dword_8557FA0;

//----- (080D313E) --------------------------------------------------------
struct hostent *NET_GetLocalAddress()
{
  struct hostent *result; // eax
  const char *v1; // edx
  int v2; // [esp+20h] [ebp-118h]
  uint32_t v3; // [esp+24h] [ebp-114h]
  char *v4; // [esp+28h] [ebp-110h]
  struct hostent *v5; // [esp+2Ch] [ebp-10Ch]
  char name[264]; // [esp+30h] [ebp-108h] BYREF

  result = (struct hostent *)gethostname(name, 0x100u);
  if ( result != (struct hostent *)-1 )
  {
    result = gethostbyname(name);
    v5 = result;
    if ( result )
    {
      Com_Printf("Hostname: %s\n", result->h_name);
      v2 = 0;
      while ( 1 )
      {
        v1 = v5->h_aliases[v2++];
        if ( !v1 )
          break;
        Com_Printf("Alias: %s\n", v1);
      }
      result = v5;
      if ( v5->h_addrtype == 2 )
      {
        dword_8557FA0 = 0;
        while ( 1 )
        {
          result = (struct hostent *)v5->h_addr_list[dword_8557FA0++];
          v4 = (char *)result;
          if ( !result || dword_8557FA0 > 15 )
            break;
          v3 = ntohl((uint32_t)result->h_name);
          byte_8557FC0[4 * dword_8557FA0] = *v4;
          byte_8557FC1[4 * dword_8557FA0] = v4[1];
          byte_8557FC2[4 * dword_8557FA0] = v4[2];
          byte_8557FC3[4 * dword_8557FA0] = v4[3];
          Com_Printf("IP: %i.%i.%i.%i\n", HIBYTE(v3), BYTE2(v3), BYTE1(v3), (unsigned __int8)v3);
        }
      }
    }
  }
  return result;
}
// 8557FA0: using guessed type int dword_8557FA0;

//----- (080D330E) --------------------------------------------------------
struct hostent *__usercall NET_OpenIP@<eax>(long double a1@<st0>)
{
  int i; // [esp+14h] [ebp-14h]
  int v3; // [esp+18h] [ebp-10h]
  char *cp; // [esp+1Ch] [ebp-Ch]
  char *v5; // [esp+20h] [ebp-8h]

  Dvar_RegisterString(a1, "net_ip", "localhost", 4112);
  v5 = Dvar_RegisterInt(a1, "net_port", (char *)0x7120, 0, 999999, 4112);
  v3 = Dvar_GetInt("net_port");
  cp = (char *)Dvar_GetString("net_ip");
  for ( i = 0; ; ++i )
  {
    if ( i > 9 )
      Com_Error(0, "Couldn't allocate IP port");
    fd = NET_IPSocket(cp, v3 + i);
    if ( fd )
      break;
  }
  Dvar_SetInt((int)v5, (char *)(v3 + i));
  return NET_GetLocalAddress();
}

//----- (080D33EC) --------------------------------------------------------
struct hostent *__usercall NET_Init@<eax>(long double a1@<st0>)
{
  struct hostent *result; // eax

  net_noudp = (int)Dvar_RegisterBool(a1, "net_noudp", 0, 4112);
  result = (struct hostent *)Dvar_GetBool("net_noudp");
  if ( !(_BYTE)result && !fd )
    return NET_OpenIP(a1);
  return result;
}
// 8557F80: using guessed type int net_noudp;

//----- (080D3438) --------------------------------------------------------
int __cdecl NET_IPSocket(char *cp, int a2)
{
  char *v2; // eax
  char *v3; // eax
  char *v4; // eax
  char *v5; // eax
  int optval; // [esp+28h] [ebp-30h] BYREF
  int v9; // [esp+2Ch] [ebp-2Ch] BYREF
  struct sockaddr addr; // [esp+30h] [ebp-28h] BYREF
  int fd; // [esp+4Ch] [ebp-Ch]

  v9 = 1;
  optval = 1;
  if ( cp )
    Com_Printf("Opening IP socket: %s:%i\n", cp, a2);
  else
    Com_Printf("Opening IP socket: localhost:%i\n", a2);
  fd = socket(2, 2, 17);
  if ( fd == -1 )
  {
    v2 = NET_ErrorString();
    Com_Printf("ERROR: UDP_OpenSocket: socket: %s", v2);
    return 0;
  }
  else if ( ioctl(fd, 0x5421u, &v9) == -1 )
  {
    v3 = NET_ErrorString();
    Com_Printf("ERROR: UDP_OpenSocket: ioctl FIONBIO:%s\n", v3);
    return 0;
  }
  else if ( setsockopt(fd, 1, 6, &optval, 4u) == -1 )
  {
    v4 = NET_ErrorString();
    Com_Printf("ERROR: UDP_OpenSocket: setsockopt SO_BROADCAST:%s\n", v4);
    return 0;
  }
  else
  {
    if ( cp && *cp && I_stricmp(cp, "localhost") )
      sub_80D2C58(cp, &addr);
    else
      *(_DWORD *)&addr.sa_data[2] = 0;
    if ( a2 == -1 )
      *(_WORD *)addr.sa_data = 0;
    else
      *(_WORD *)addr.sa_data = htons(a2);
    addr.sa_family = 2;
    if ( bind(fd, &addr, 0x10u) == -1 )
    {
      v5 = NET_ErrorString();
      Com_Printf("ERROR: UDP_OpenSocket: bind: %s\n", v5);
      close(fd);
      return 0;
    }
    else
    {
      return fd;
    }
  }
}

//----- (080D360E) --------------------------------------------------------
int sub_80D360E()
{
  int result; // eax

  if ( fd )
  {
    result = close(fd);
    fd = 0;
  }
  return result;
}

//----- (080D3636) --------------------------------------------------------
char *NET_ErrorString()
{
  int *v0; // eax

  v0 = __errno_location();
  return strerror(*v0);
}

//----- (080D3654) --------------------------------------------------------
int __cdecl NET_Sleep(int a1)
{
  fd_set readfds; // [esp+30h] [ebp-98h] BYREF
  struct timeval timeout; // [esp+B8h] [ebp-10h] BYREF

  memset(&readfds, 0, sizeof(readfds));
  if ( dword_8163F80 )
    readfds.__fds_bits[0] |= 1u;
  _bittestandset(&readfds.__fds_bits[(unsigned int)fd >> 5], fd & 0x1F);
  timeout.tv_sec = a1 / 1000;
  timeout.tv_usec = 1000 * (a1 % 1000);
  return select(fd + 1, &readfds, 0, 0, &timeout);
}
// 8163F80: using guessed type int dword_8163F80;

//----- (080D3728) --------------------------------------------------------
int Sys_MilliSeconds()
{
  struct timezone tz; // [esp+10h] [ebp-18h] BYREF
  struct timeval tv; // [esp+18h] [ebp-10h] BYREF

  gettimeofday(&tv, &tz);
  if ( dword_855A384 )
  {
    dword_855A380 = tv.tv_usec / 1000 + 1000 * (tv.tv_sec - dword_855A384);
    return dword_855A380;
  }
  else
  {
    dword_855A384 = tv.tv_sec;
    return tv.tv_usec / 1000;
  }
}
// 855A380: using guessed type int dword_855A380;
// 855A384: using guessed type int dword_855A384;

//----- (080D37B0) --------------------------------------------------------
int sub_80D37B0()
{
  struct timezone tz; // [esp+10h] [ebp-18h] BYREF
  struct timeval tv; // [esp+18h] [ebp-10h] BYREF

  gettimeofday(&tv, &tz);
  dword_855A380 = tv.tv_usec / 1000 + 1000 * tv.tv_sec;
  return tv.tv_usec / 1000 + 1000 * tv.tv_sec;
}
// 855A380: using guessed type int dword_855A380;

//----- (080D3824) --------------------------------------------------------
void __cdecl sub_80D3824(float *a1)
{
  *a1 = rint(*a1);
  a1[1] = rint(a1[1]);
  a1[2] = rint(a1[2]);
}

//----- (080D3874) --------------------------------------------------------
int __cdecl Sys_Mkdir(char *path)
{
  return mkdir(path, 0x1FFu);
}

//----- (080D3890) --------------------------------------------------------
DIR *__cdecl Sys_ListFilteredFiles(const char *a1, const char *a2, int a3, int a4, int *a5)
{
  DIR *result; // eax
  struct stat stat_buf; // [esp+20h] [ebp-378h] BYREF
  struct dirent *v7; // [esp+88h] [ebp-310h]
  DIR *dirp; // [esp+8Ch] [ebp-30Ch]
  char filename[256]; // [esp+90h] [ebp-308h] BYREF
  char s[256]; // [esp+190h] [ebp-208h] BYREF
  char name[264]; // [esp+290h] [ebp-108h] BYREF

  result = (DIR *)a5;
  if ( *a5 <= 4094 )
  {
    if ( *a2 )
      Com_sprintf(name, 0x100u, "%s/%s", a1, a2);
    else
      Com_sprintf(name, 0x100u, "%s", a1);
    result = opendir(name);
    dirp = result;
    if ( result )
    {
      while ( 1 )
      {
        v7 = readdir(dirp);
        if ( !v7 )
          break;
        Com_sprintf(filename, 0x100u, "%s/%s", name, v7->d_name);
        if ( FS_stat(filename, &stat_buf) != -1 )
        {
          if ( (stat_buf.st_mode & 0x4000) != 0 && I_stricmp(v7->d_name, ".") && I_stricmp(v7->d_name, "..") )
          {
            if ( *a2 )
              Com_sprintf(s, 0x100u, "%s/%s", a2, v7->d_name);
            else
              Com_sprintf(s, 0x100u, "%s", v7->d_name);
            Sys_ListFilteredFiles((char)a1, (char)s, a3, a4, a5);
          }
          if ( *a5 > 4094 )
            return (DIR *)closedir(dirp);
          Com_sprintf(filename, 0x100u, "%s/%s", a2, v7->d_name);
          if ( (unsigned __int8)Com_FilterPath(a3, (int)filename, 0) )
            *(_DWORD *)(a4 + 4 * (*a5)++) = CopyStringInternal(filename);
        }
      }
      return (DIR *)closedir(dirp);
    }
  }
  return result;
}
// 80D3890: using guessed type const char *arg_4;
// 80D3890: using guessed type const char *arg_0;

//----- (080D3B28) --------------------------------------------------------
_DWORD *__cdecl Sys_ListFiles(char *name, char *s, int a3, _DWORD *a4, int a5)
{
  size_t v5; // ebx
  size_t v6; // eax
  char *v7; // ebx
  size_t v8; // eax
  int v9; // ebx
  struct stat stat_buf; // [esp+30h] [ebp-4198h] BYREF
  int i; // [esp+9Ch] [ebp-412Ch]
  int v14[4098]; // [esp+A0h] [ebp-4128h] BYREF
  _DWORD *v15; // [esp+40A8h] [ebp-120h]
  int v16; // [esp+40ACh] [ebp-11Ch] BYREF
  char filename[260]; // [esp+40B0h] [ebp-118h] BYREF
  int v18; // [esp+41B4h] [ebp-14h]
  DIR *dirp; // [esp+41B8h] [ebp-10h]
  struct dirent *v20; // [esp+41BCh] [ebp-Ch]

  v18 = a5;
  if ( a3 )
  {
    v16 = 0;
    Sys_ListFilteredFiles(name, (const char *)&unk_814B1CE, a3, (int)v14, &v16);
    v14[v16] = 0;
    *a4 = v16;
    if ( v16 )
    {
      v15 = Z_MallocInternal(4 * v16 + 4);
      for ( i = 0; i < v16; ++i )
        v15[i] = v14[i];
      v15[i] = 0;
      return v15;
    }
    else
    {
      return 0;
    }
  }
  else
  {
    if ( !s )
      s = (char *)&unk_814B1CE;
    if ( *s == 47 && !s[1] )
    {
      s = (char *)&unk_814B1CE;
      v18 = 1;
    }
    strlen(s);
    v16 = 0;
    dirp = opendir(name);
    if ( dirp )
    {
      while ( 1 )
      {
        v20 = readdir(dirp);
        if ( !v20 )
          break;
        Com_sprintf(filename, 0x100u, "%s/%s", name, v20->d_name);
        if ( FS_stat(filename, &stat_buf) != -1
          && (!v18 || (stat_buf.st_mode & 0x4000) != 0)
          && (v18 || (stat_buf.st_mode & 0x4000) == 0) )
        {
          if ( !*s
            || (v5 = strlen(v20->d_name), v5 >= strlen(s))
            && (v6 = strlen(v20->d_name), v7 = (char *)v20 + v6, v8 = strlen(s), !I_stricmp(&v7[-v8 + 11], s)) )
          {
            if ( v16 == 4095 )
              break;
            v9 = v16;
            v14[v9] = (int)CopyStringInternal(v20->d_name);
            ++v16;
          }
        }
      }
      v14[v16] = 0;
      closedir(dirp);
      *a4 = v16;
      if ( v16 )
      {
        v15 = Z_MallocInternal(4 * v16 + 4);
        for ( i = 0; i < v16; ++i )
          v15[i] = v14[i];
        v15[i] = 0;
        return v15;
      }
      else
      {
        return 0;
      }
    }
    else
    {
      *a4 = 0;
      return 0;
    }
  }
}
// 80D3B28: using guessed type int var_4128[4098];

//----- (080D3EB8) --------------------------------------------------------
void __cdecl Sys_FreeFileList(void **ptr)
{
  int i; // [esp+4h] [ebp-4h]

  if ( ptr )
  {
    for ( i = 0; ptr[i]; ++i )
      Z_FreeInternal(ptr[i]);
    Z_FreeInternal(ptr);
  }
}

//----- (080D3F0E) --------------------------------------------------------
char *Sys_Cwd()
{
  getcwd(byte_855A3A0, 0xFFu);
  byte_855A49F = 0;
  return byte_855A3A0;
}
// 855A49F: using guessed type char byte_855A49F;

//----- (080D3F36) --------------------------------------------------------
char *__cdecl Sys_SetDefaultCDPath(char *src)
{
  return I_strncpyz(byte_855A080, src, 256);
}

//----- (080D3F5A) --------------------------------------------------------
char *Sys_DefaultCDPath()
{
  return byte_855A080;
}

//----- (080D3F64) --------------------------------------------------------
char *sub_80D3F64()
{
  if ( byte_855A180 )
    return &byte_855A180;
  else
    return Sys_Cwd();
}

//----- (080D3F8A) --------------------------------------------------------
char *__cdecl Sys_SetDefaultInstallPath(char *src)
{
  return I_strncpyz(&byte_855A180, src, 256);
}

//----- (080D3FAE) --------------------------------------------------------
char *Sys_DefaultInstallPath()
{
  if ( byte_855A180 )
    return &byte_855A180;
  else
    return Sys_Cwd();
}

//----- (080D3FD4) --------------------------------------------------------
char *__cdecl sub_80D3FD4(char *src)
{
  return I_strncpyz(&path, src, 256);
}

//----- (080D3FF8) --------------------------------------------------------
char *Sys_DefaultHomePath()
{
  int *v0; // ebx
  int *v1; // eax
  char *v2; // eax
  char *src; // [esp+20h] [ebp-8h]

  if ( path )
    return &path;
  src = getenv("HOME");
  if ( !src )
    return (char *)&unk_814B1CE;
  I_strncpyz(&path, src, 256);
  I_strncat(&path, 256, "/.callofduty2");
  if ( mkdir(&path, 0x1FFu) && *__errno_location() != 17 )
  {
    v0 = __errno_location();
    v1 = __errno_location();
    v2 = strerror(*v1);
    Sys_Error("Unable to create directory \"%s\", error is %s(%d)\n", &path, v2, *v0);
  }
  return &path;
}

//----- (080D40EA) --------------------------------------------------------
void sub_80D40EA()
{
  ;
}

//----- (080D40F0) --------------------------------------------------------
const char *Sys_GetCurrentUser()
{
  __uid_t v0; // eax
  struct passwd *v3; // [esp+14h] [ebp-4h]

  v0 = getuid();
  v3 = getpwuid(v0);
  if ( v3 )
    return v3->pw_name;
  else
    return "player";
}

//----- (080D4122) --------------------------------------------------------
_BYTE *__cdecl strlwr(_BYTE *a1)
{
  if ( !a1 )
    return 0;
  while ( *a1 )
  {
    *a1 = tolower((char)*a1);
    ++a1;
  }
  return a1;
}

//----- (080D416A) --------------------------------------------------------
int __cdecl Sys_DirectoryHasContents(char *s)
{
  size_t v1; // eax
  struct dirent *v3; // [esp+8h] [ebp-10h]
  DIR *dirp; // [esp+Ch] [ebp-Ch]
  int i; // [esp+10h] [ebp-8h]
  int v6; // [esp+10h] [ebp-8h]
  char *dest; // [esp+14h] [ebp-4h]

  v1 = strlen(s);
  dest = (char *)operator new[](v1 + 1);
  strcpy(dest, s);
  for ( i = 0; dest[i]; ++i )
  {
    if ( dest[i] == 92 )
      dest[i] = 47;
  }
  v6 = 0;
  dirp = opendir(dest);
  if ( dirp )
  {
    while ( 1 )
    {
      v3 = readdir(dirp);
      if ( !v3 )
        break;
      if ( strcmp(v3->d_name, ".") && strcmp(v3->d_name, "..") )
      {
        v6 = 1;
        break;
      }
    }
    closedir(dirp);
  }
  if ( dest )
    operator delete[](dest);
  return v6;
}

//----- (080D425A) --------------------------------------------------------
int __cdecl sub_80D425A(char *s)
{
  size_t v1; // eax
  size_t v2; // ebx
  struct stat stat_buf; // [esp+20h] [ebp-88h] BYREF
  char *name; // [esp+88h] [ebp-20h]
  size_t maxlen; // [esp+8Ch] [ebp-1Ch]
  struct dirent *v7; // [esp+90h] [ebp-18h]
  DIR *dirp; // [esp+94h] [ebp-14h]
  int i; // [esp+98h] [ebp-10h]
  char *dest; // [esp+9Ch] [ebp-Ch]

  v1 = strlen(s);
  dest = (char *)operator new[](v1 + 1);
  strcpy(dest, s);
  for ( i = 0; dest[i]; ++i )
  {
    if ( dest[i] == 92 )
      dest[i] = 47;
  }
  i = 1;
  dirp = opendir(dest);
  if ( dirp )
  {
    while ( 1 )
    {
      v7 = readdir(dirp);
      if ( !v7 )
        break;
      if ( strcmp(v7->d_name, ".") && strcmp(v7->d_name, "..") )
      {
        v2 = strlen(dest);
        maxlen = strlen(v7->d_name) + v2 + 2;
        name = (char *)operator new[](maxlen);
        snprintf(name, maxlen, "%s/%s", dest, v7->d_name);
        if ( FS_stat(name, &stat_buf) == -1 )
        {
          i = 0;
        }
        else if ( (stat_buf.st_mode & 0xF000) == 0x4000 )
        {
          i = sub_80D425A(name);
        }
        else
        {
          i = unlink(name) != -1;
        }
        if ( name )
          operator delete[](name);
        if ( !i )
          break;
      }
    }
    closedir(dirp);
  }
  if ( i == 1 )
    i = rmdir(dest) != -1;
  if ( dest )
    operator delete[](dest);
  return 1;
}

//----- (080D4444) --------------------------------------------------------
int Sys_InitMainThread()
{
  dword_855A4B4 = pthread_self();
  return Com_InitThreadData(0);
}
// 855A4B4: using guessed type int dword_855A4B4;

//----- (080D446C) --------------------------------------------------------
_BOOL4 Sys_IsMainThread()
{
  return pthread_self() == dword_855A4B4;
}
// 855A4B4: using guessed type int dword_855A4B4;

//----- (080D4492) --------------------------------------------------------
int __cdecl Sys_SetValue(int a1, int a2)
{
  int result; // eax

  result = a2;
  dword_855A4A0[a1] = a2;
  return result;
}
// 855A4A0: using guessed type int dword_855A4A0[5];

//----- (080D44A4) --------------------------------------------------------
int __cdecl Sys_GetValue(int a1)
{
  return dword_855A4A0[a1];
}
// 855A4A0: using guessed type int dword_855A4A0[5];

//----- (080D4560) --------------------------------------------------------
char *__usercall sub_80D4560@<eax>(long double a1@<st0>)
{
  char *result; // eax

  result = Dvar_RegisterBool(a1, "snd_errorOnMissing", 0, 4097);
  snd_errorOnMissing = (int)result;
  return result;
}
// 855A4B8: using guessed type int snd_errorOnMissing;

//----- (080D4590) --------------------------------------------------------
void sub_80D4590()
{
  ;
}

//----- (080D45C4) --------------------------------------------------------
int __cdecl BG_StringHashValue_Lwr(int a1)
{
  int v2; // [esp+10h] [ebp-8h]
  int i; // [esp+14h] [ebp-4h]

  v2 = 0;
  for ( i = 0; *(_BYTE *)(a1 + i); ++i )
    v2 += (i + 119) * (char)tolower(*(char *)(a1 + i));
  if ( v2 == -1 )
    return 0;
  return v2;
}

//----- (080D4624) --------------------------------------------------------
void __noreturn BG_AnimParseError(char *format, ...)
{
  int v1; // eax
  char s[1036]; // [esp+20h] [ebp-418h] BYREF
  __gnuc_va_list __varargs; // [esp+42Ch] [ebp-Ch]
  va_list va; // [esp+444h] [ebp+Ch] BYREF

  va_start(va, format);
  va_copy(__varargs, va);
  vsprintf(s, format, va);
  if ( *(_DWORD *)off_81643C0 )
  {
    v1 = sub_80B3B6C();
    Com_Error(1, (char *)&byte_814B63B, s, *(_DWORD *)off_81643C0, v1 + 1);
  }
  Com_Error(1, (char *)&byte_814B64E, s);
}

//----- (080D46AC) --------------------------------------------------------
int __cdecl BG_AnimationIndexForString(char *src)
{
  int i; // [esp+1Ch] [ebp-Ch]
  int v4; // [esp+1Ch] [ebp-Ch]
  int v5; // [esp+20h] [ebp-8h]
  int v6; // [esp+20h] [ebp-8h]
  int v7; // [esp+24h] [ebp-4h]
  int v8; // [esp+24h] [ebp-4h]
  int v9; // [esp+24h] [ebp-4h]

  if ( dword_855D568 )
  {
    v6 = BG_StringHashValue_Lwr((int)src);
    v4 = 0;
    v8 = dword_855D568;
    while ( v4 < *(_DWORD *)dword_855D56C )
    {
      if ( v6 == *(_DWORD *)(v8 + 4) && !I_stricmp(src, (char *)(v8 + 8)) )
        return v4;
      ++v4;
      v8 += 72;
    }
    v9 = dword_855D568 + 72 * *(_DWORD *)dword_855D56C;
    Scr_FindAnim("multiplayer", src, (_DWORD *)v9, *((_DWORD *)dword_855A4E0 + 184058));
    strcpy((char *)(v9 + 8), src);
    *(_DWORD *)(v9 + 4) = v6;
    return (*(_DWORD *)dword_855D56C)++;
  }
  else
  {
    v5 = BG_StringHashValue_Lwr((int)src);
    v7 = 0;
    for ( i = dword_855A4E4; ; i += 96 )
    {
      if ( v7 >= *(_DWORD *)(dword_855A4E4 + 49152) )
        BG_AnimParseError("BG_AnimationIndexForString: unknown player animation '%s'", src);
      if ( v5 == *(_DWORD *)(i + 76) && !I_stricmp(src, (char *)i) )
        break;
      ++v7;
    }
    return v7;
  }
}
// 855A4E4: using guessed type int dword_855A4E4;
// 855D568: using guessed type int dword_855D568;
// 855D56C: using guessed type int dword_855D56C;

//----- (080D4832) --------------------------------------------------------
int __cdecl sub_80D4832(char *a1)
{
  int i; // [esp+1Ch] [ebp-Ch]
  int v3; // [esp+20h] [ebp-8h]
  int v4; // [esp+24h] [ebp-4h]

  v3 = BG_StringHashValue_Lwr((int)a1);
  v4 = 0;
  for ( i = dword_855A4E4; ; i += 96 )
  {
    if ( v4 >= *(_DWORD *)(dword_855A4E4 + 49152) )
      Com_Error(1, (char *)&byte_814B6C0, a1);
    if ( v3 == *(_DWORD *)(i + 76) && !I_stricmp(a1, (char *)i) )
      break;
    ++v4;
  }
  return i;
}
// 855A4E4: using guessed type int dword_855A4E4;

//----- (080D48C6) --------------------------------------------------------
int __cdecl sub_80D48C6(char *a1, int *a2, int a3)
{
  int v6; // [esp+1Ch] [ebp-Ch]
  int v7; // [esp+20h] [ebp-8h]

  v6 = BG_StringHashValue_Lwr((int)a1);
  v7 = 0;
  while ( *a2 )
  {
    if ( a2[1] == -1 )
      a2[1] = BG_StringHashValue_Lwr(*a2);
    if ( v6 == a2[1] && !I_stricmp(a1, (char *)*a2) )
      return v7;
    a2 += 2;
    ++v7;
  }
  if ( !a3 )
    BG_AnimParseError("BG_IndexForString: unknown token '%s'", a1);
  return -1;
}
// 80D48C6: using guessed type char *arg_0;

//----- (080D4970) --------------------------------------------------------
char *__cdecl sub_80D4970(char *s, int a2, unsigned int a3, _DWORD *a4)
{
  char *dest; // [esp+Ch] [ebp-Ch]

  if ( *a4 + strlen(s) + 1 >= a3 )
    BG_AnimParseError("BG_CopyStringIntoBuffer: out of buffer space");
  dest = (char *)(a2 + *a4);
  strcpy(dest, s);
  *a4 += strlen(s) + 1;
  return dest;
}

//----- (080D49D8) --------------------------------------------------------
int __cdecl sub_80D49D8(int a1, int a2)
{
  int result; // eax

  dword_8575C40[2 * a1] = a2;
  result = BG_StringHashValue_Lwr(a2);
  dword_8575C44[2 * a1] = result;
  return result;
}
// 8575C40: using guessed type int dword_8575C40[];
// 8575C44: using guessed type int dword_8575C44[255];

//----- (080D4A08) --------------------------------------------------------
int sub_80D4A08()
{
  memset(dword_8575C40, 0, 0x400u);
  return sub_80F04AE();
}
// 8575C40: using guessed type int dword_8575C40[];

//----- (080D4A32) --------------------------------------------------------
unsigned __int16 *__cdecl sub_80D4A32(unsigned int a1)
{
  unsigned __int16 *v3; // [esp+20h] [ebp-8h]
  int v4; // [esp+24h] [ebp-4h]

  if ( a1 >= *(_DWORD *)(dword_855A4E4 + 49152) )
    Com_Error(1, (char *)&byte_814B780, a1, *(_DWORD *)(dword_855A4E4 + 49152));
  v4 = 0;
  v3 = (unsigned __int16 *)dword_855D568;
  while ( v4 < *(_DWORD *)dword_855D56C )
  {
    if ( a1 == *v3 )
      return v3;
    ++v4;
    v3 += 36;
  }
  return 0;
}
// 855A4E4: using guessed type int dword_855A4E4;
// 855D568: using guessed type int dword_855D568;
// 855D56C: using guessed type int dword_855D56C;

//----- (080D4ABE) --------------------------------------------------------
void *__cdecl sub_80D4ABE(int a1)
{
  void *result; // eax
  int k; // [esp+0h] [ebp-14h]
  int i; // [esp+4h] [ebp-10h]
  int j; // [esp+4h] [ebp-10h]
  int v5; // [esp+Ch] [ebp-8h]
  int *v6; // [esp+10h] [ebp-4h]

  for ( i = 0; i < *(_DWORD *)(a1 + 49152); ++i )
    *(_DWORD *)(a1 + 96 * i + 92) = 0;
  result = dword_855A4E0;
  if ( !*((_DWORD *)dword_855A4E0 + 184058) )
  {
    v6 = (int *)(a1 + 231820);
    for ( j = 0; ; ++j )
    {
      result = (void *)j;
      if ( j >= *v6 )
        break;
      v5 = v6[j + 1];
      for ( k = 0; k < *(_DWORD *)(v5 + 112); ++k )
      {
        if ( *(_WORD *)(v5 + 16 * k + 116) )
          *(_DWORD *)(a1 + 96 * *(__int16 *)(v5 + 16 * k + 120) + 92) = 1;
        if ( *(_WORD *)(v5 + 16 * k + 118) )
          *(_DWORD *)(a1 + 96 * *(__int16 *)(v5 + 16 * k + 122) + 92) = 1;
      }
    }
  }
  return result;
}

//----- (080D4BC2) --------------------------------------------------------
void *sub_80D4BC2()
{
  char *v0; // eax
  char *v1; // ebx
  long double v2; // fst7
  char *v3; // ebx
  float v5; // [esp+28h] [ebp-40h]
  unsigned __int16 *v6; // [esp+2Ch] [ebp-3Ch]
  int v7[4]; // [esp+30h] [ebp-38h] BYREF
  int v8[3]; // [esp+40h] [ebp-28h] BYREF
  int v9; // [esp+4Ch] [ebp-1Ch]
  char *dest; // [esp+50h] [ebp-18h]
  int v11; // [esp+54h] [ebp-14h]
  int v12; // [esp+58h] [ebp-10h]
  int v13; // [esp+5Ch] [ebp-Ch]

  v11 = dword_855A4E4;
  v9 = *(_DWORD *)(dword_855A4E4 + 736180);
  v12 = sub_80BEA18(v9);
  *(_DWORD *)(dword_855A4E4 + 49152) = v12;
  dest = (char *)v11;
  *(_DWORD *)(v11 + 80) |= 0x101u;
  I_strncpyz(dest, "root", 64);
  *((_DWORD *)dest + 19) = 0;
  dest += 96;
  v13 = 1;
  while ( v13 < v12 )
  {
    v6 = sub_80D4A32(v13);
    if ( v6 )
    {
      if ( sub_80C00CA(v9, v13) )
      {
        v0 = (char *)sub_80BE908(v9, v13);
        I_strncpyz(dest, v0, 64);
        v1 = dest;
        *((_DWORD *)v1 + 19) = BG_StringHashValue_Lwr((int)dest);
        if ( !*((_DWORD *)dest + 16) )
          *((_DWORD *)dest + 16) = -1;
        v5 = sub_80BE760(v9, v13);
        if ( v5 == 0.0 )
        {
          *((_DWORD *)dest + 18) = 500;
          *((_DWORD *)dest + 17) = 0;
        }
        else
        {
          v2 = v5 * 1000.0;
          *((_DWORD *)dest + 18) = (int)v2;
          XAnimGetRelDelta(v9, v13, v8, v7, 0.0, 1.0);
          v3 = dest;
          sub_80D9E26((float *)v7);
          *((float *)v3 + 17) = v2 / v5;
          if ( *((int *)dest + 18) <= 499 )
            *((_DWORD *)dest + 18) = 500;
        }
        if ( (unsigned __int8)sub_80C040C(v9, v13) )
          *((_DWORD *)dest + 20) |= 0x80u;
      }
      else
      {
        *((_DWORD *)dest + 20) |= 1u;
        I_strncpyz(dest, (char *)v6 + 8, 64);
        *((_DWORD *)dest + 19) = *((_DWORD *)v6 + 1);
        if ( !*((_DWORD *)dest + 16) )
          *((_DWORD *)dest + 16) = -1;
        *((_DWORD *)dest + 18) = 0;
        *((_DWORD *)dest + 17) = 0;
      }
    }
    else
    {
      *((_DWORD *)dest + 20) |= 0x100u;
      I_strncpyz(dest, "unused", 64);
      *((_DWORD *)dest + 19) = 0;
    }
    ++v13;
    dest += 96;
  }
  sub_80D5B94(dword_855A4E4, 0, 0);
  return sub_80D4ABE(dword_855A4E4);
}
// 80D4CCE: conditional instruction was optimized away because %var_3C.4!=0
// 855A4E4: using guessed type int dword_855A4E4;
// 80D4BC2: using guessed type int var_28[3];

//----- (080D4ED4) --------------------------------------------------------
void *__cdecl sub_80D4ED4(char **a1, int *a2, int a3, _DWORD *s)
{
  void *result; // eax
  int v5; // eax
  char *src; // [esp+18h] [ebp-60h]
  int v7; // [esp+1Ch] [ebp-5Ch]
  char v8[64]; // [esp+20h] [ebp-58h] BYREF
  int v9; // [esp+60h] [ebp-18h] BYREF
  int v10; // [esp+64h] [ebp-14h]
  int v11; // [esp+68h] [ebp-10h]
  int v12; // [esp+6Ch] [ebp-Ch]

  v12 = 0;
  v7 = 0;
  v8[0] = 0;
  memset(s, 0, sizeof(_DWORD));
  result = memset(&v9, 0, 8u);
  while ( !v12 )
  {
    src = Com_ParseOnLine(a1);
    if ( !src || !*src )
    {
      result = (void *)Com_UngetToken();
      v12 = 1;
      if ( !v8[0] )
        break;
    }
    if ( !I_stricmp(src, ",") )
      v12 = 1;
    if ( I_stricmp(src, "none") )
    {
      if ( I_stricmp(src, "none,") )
      {
        if ( !I_stricmp(src, "NOT") )
          src = "MINUS";
        if ( !v12 && I_stricmp(src, "AND") && I_stricmp(src, "MINUS") )
        {
          if ( src[strlen(src) - 1] == 44 )
          {
            v12 = 1;
            src[strlen(src) - 1] = 0;
          }
          if ( v8[0] )
            I_strncat(v8, 64, " ");
          I_strncat(v8, 64, src);
        }
        if ( !I_stricmp(src, "AND") || (result = (void *)I_stricmp(src, "MINUS")) == 0 || v12 )
        {
          if ( v8[0] )
          {
            if ( I_stricmp(v8, "all") )
            {
              v11 = sub_80D48C6(v8, (int *)((a3 << 7) + 139840608), 1);
              if ( v11 < 0 )
              {
                v11 = sub_80D48C6(v8, a2, 0);
                sub_80D9EAA((int)&v9, v11);
              }
              else
              {
                v9 = dword_855D0E0[32 * a3 + 2 * v11];
                v10 = dword_855D0E4[32 * a3 + 2 * v11];
              }
            }
            else
            {
              v9 = -1;
              v10 = -1;
            }
            if ( v7 )
            {
              *s &= ~v9;
              v5 = s[1] & ~v10;
            }
            else
            {
              *s |= v9;
              v5 = s[1] | v10;
            }
            s[1] = v5;
            v8[0] = 0;
            result = (void *)I_stricmp(src, "MINUS");
            if ( !result )
              v7 = 1;
          }
          else
          {
            if ( v12 )
              BG_AnimParseError("BG_ParseConditionBits: unexpected end of condition");
            result = (void *)I_stricmp(src, "MINUS");
            if ( result )
              BG_AnimParseError("BG_ParseConditionBits: unexpected '%s'", src);
            v7 = 1;
          }
        }
      }
      else
      {
        result = (void *)sub_80D9EAA((int)s, 0);
        v12 = 1;
      }
    }
    else
    {
      result = (void *)sub_80D9EAA((int)s, 0);
    }
  }
  return result;
}
// 855D0E0: using guessed type int dword_855D0E0[];
// 855D0E4: using guessed type int dword_855D0E4[287];

//----- (080D5250) --------------------------------------------------------
int __cdecl sub_80D5250(char **a1, _DWORD *a2)
{
  int v3; // [esp+1Ch] [ebp-1Ch]
  char *v4; // [esp+24h] [ebp-14h]
  char *v5; // [esp+24h] [ebp-14h]
  int s[3]; // [esp+28h] [ebp-10h] BYREF
  int v7; // [esp+34h] [ebp-4h]

  memset(s, 0, 8u);
  while ( 1 )
  {
    v4 = Com_ParseOnLine(a1);
    if ( !v4 || !*v4 )
      break;
    if ( !I_stricmp(v4, "default") )
      return 1;
    v7 = sub_80D48C6(v4, (int *)&off_8164760, 0);
    v3 = dword_81647C0[2 * v7];
    if ( v3 )
    {
      if ( v3 == 1 )
      {
        if ( off_81647C4[2 * v7] )
        {
          v5 = Com_ParseOnLine(a1);
          if ( !v5 || !*v5 )
            BG_AnimParseError("BG_ParseConditions: expected condition value, found end of line");
          if ( v5[strlen(v5) - 1] == 44 )
            v5[strlen(v5) - 1] = 0;
          s[0] = sub_80D48C6(v5, (int *)off_81647C4[2 * v7], 0);
        }
        else
        {
          s[0] = 1;
        }
      }
    }
    else
    {
      sub_80D4ED4(a1, (int *)off_81647C4[2 * v7], v7, s);
    }
    a2[3 * *a2 + 1] = v7;
    a2[3 * *a2 + 2] = s[0];
    a2[3 * (*a2)++ + 3] = s[1];
  }
  if ( !*a2 )
    BG_AnimParseError("BG_ParseConditions: no conditions found");
  return 1;
}
// 8164760: using guessed type char *off_8164760;
// 81647C0: using guessed type int dword_81647C0[];
// 81647C4: using guessed type int off_81647C4[17];

//----- (080D5424) --------------------------------------------------------
size_t __cdecl sub_80D5424(char **a1, _DWORD *a2, int a3)
{
  size_t result; // eax
  int v4; // esi
  __int64 v5; // rax
  int *v6; // ebx
  int v7; // edx
  char *v8; // [esp+18h] [ebp-20h]
  int v9; // [esp+1Ch] [ebp-1Ch]
  int i; // [esp+20h] [ebp-18h]
  int v11; // [esp+24h] [ebp-14h]
  _DWORD *v12; // [esp+28h] [ebp-10h]
  char *s; // [esp+2Ch] [ebp-Ch]
  char *sa; // [esp+2Ch] [ebp-Ch]
  char *sb; // [esp+2Ch] [ebp-Ch]
  char *sc; // [esp+2Ch] [ebp-Ch]
  char *sd; // [esp+2Ch] [ebp-Ch]
  char *se; // [esp+2Ch] [ebp-Ch]

  v12 = 0;
  v11 = 0;
  while ( 1 )
  {
    v8 = v11 > 0 ? Com_ParseOnLine(a1) : Com_Parse(a1);
    result = (size_t)v8;
    if ( !v8 )
      return result;
    result = (size_t)v8;
    if ( !*v8 )
      return result;
    if ( !I_stricmp(v8, "}") )
    {
      result = (size_t)&(*a1)[-strlen(v8)];
      *a1 = (char *)result;
      return result;
    }
    if ( !v11 )
    {
      if ( (int)a2[28] > 7 )
        BG_AnimParseError("BG_ParseCommands: exceeded maximum number of animations (%i)", 8);
      v12 = &a2[4 * a2[28]++ + 29];
      memset(v12, 0, sizeof(_DWORD));
    }
    *((_WORD *)v12 + v11) = sub_80D48C6(v8, (int *)&off_8164620, 1);
    if ( *((__int16 *)v12 + v11) <= 0 )
    {
      *a1 -= strlen(v8);
      goto LABEL_65;
    }
    s = Com_ParseOnLine(a1);
    if ( !s || !*s )
      BG_AnimParseError("BG_ParseCommands: expected animation");
    *((_WORD *)v12 + v11 + 2) = BG_AnimationIndexForString(s);
    *((_WORD *)v12 + v11 + 4) = *(_WORD *)(a3 + 96 * *((__int16 *)v12 + v11 + 2) + 72);
    if ( !dword_855D568 )
    {
      if ( dword_855D560 && *((_WORD *)v12 + v11) != 2 )
      {
        v4 = a3 + 96 * *((__int16 *)v12 + v11 + 2) + 80;
        v5 = 1LL << dword_855D560;
        *(_DWORD *)(a3 + 96 * *((__int16 *)v12 + v11 + 2) + 84) |= 1LL << dword_855D560;
        *(_DWORD *)(v4 + 8) |= HIDWORD(v5);
        if ( (dword_855D560 == 18 || dword_855D560 == 19)
          && *(float *)(a3 + 96 * *((__int16 *)v12 + v11 + 2) + 68) != 0.0 )
        {
          *(_DWORD *)(a3 + 96 * *((__int16 *)v12 + v11 + 2) + 80) |= 2u;
        }
        for ( i = 0; ; ++i )
        {
          if ( i >= *a2 )
            goto LABEL_32;
          if ( a2[3 * i + 1] == 8 )
            break;
        }
        if ( a2[3 * i + 2] == 1 )
        {
          *(_DWORD *)(a3 + 96 * *((__int16 *)v12 + v11 + 2) + 80) |= 0x10u;
        }
        else if ( a2[3 * i + 2] == 2 )
        {
          *(_DWORD *)(a3 + 96 * *((__int16 *)v12 + v11 + 2) + 80) |= 0x20u;
        }
      }
LABEL_32:
      switch ( dword_855D564 )
      {
        case 2:
          *(_DWORD *)(a3 + 96 * *((__int16 *)v12 + v11 + 2) + 80) |= 8u;
          *(_DWORD *)(a3 + 96 * *((__int16 *)v12 + v11 + 2) + 64) = 30;
          break;
        case 1:
          *(_DWORD *)(a3 + 96 * *((__int16 *)v12 + v11 + 2) + 68) = 0;
          *(_DWORD *)(a3 + 96 * *((__int16 *)v12 + v11 + 2) + 80) |= 0x40u;
          break;
        case 10:
          *(_DWORD *)(a3 + 96 * *((__int16 *)v12 + v11 + 2) + 68) = 0;
          break;
        default:
          if ( dword_855D560 > 20 && dword_855D560 <= 30 )
            *(_DWORD *)(a3 + 96 * *((__int16 *)v12 + v11 + 2) + 68) = 0;
          break;
      }
      goto LABEL_41;
    }
    do
    {
LABEL_41:
      v9 = 0;
      sa = Com_ParseOnLine(a1);
      if ( !sa || !*sa )
      {
LABEL_59:
        Com_UngetToken();
        continue;
      }
      if ( I_stricmp(sa, "duration") )
      {
        if ( I_stricmp(sa, "turretanim") )
        {
          if ( I_stricmp(sa, "blendtime") )
            goto LABEL_59;
          v9 = 1;
          sc = Com_ParseOnLine(a1);
          if ( !sc || !*sc )
            BG_AnimParseError("BG_ParseCommands: expected blendtime value");
          if ( !dword_855D568 )
          {
            v6 = (int *)(a3 + 96 * *((__int16 *)v12 + v11 + 2) + 64);
            *v6 = atoi(sc);
          }
        }
        else
        {
          v9 = 1;
          if ( !dword_855D568 )
            *(_DWORD *)(a3 + 96 * *((__int16 *)v12 + v11 + 2) + 80) |= 4u;
          if ( *((_WORD *)v12 + v11) != 3 )
            BG_AnimParseError("BG_ParseCommands: Turret animations can only be played on the 'both' body part");
        }
      }
      else
      {
        v9 = 1;
        sb = Com_ParseOnLine(a1);
        if ( !sb || !*sb )
          BG_AnimParseError("BG_ParseCommands: expected duration value");
        *((_WORD *)v12 + v11 + 4) = atoi(sb);
      }
    }
    while ( v9 );
    if ( *((_WORD *)v12 + v11) != 3 )
    {
      v7 = v11++;
      if ( v7 <= 0 )
        continue;
    }
LABEL_65:
    while ( 1 )
    {
      sd = Com_ParseOnLine(a1);
      if ( !sd || !*sd )
        break;
      if ( I_stricmp(sd, "sound") )
        BG_AnimParseError("BG_ParseCommands: unknown parameter '%s'", sd);
      se = Com_ParseOnLine(a1);
      if ( !se || !*se )
        BG_AnimParseError("BG_ParseCommands: expected sound");
      if ( strstr(se, ".wav") )
        BG_AnimParseError("BG_ParseCommands: wav files not supported, only sound scripts");
      v12[3] = (*(int (__cdecl **)(char *))(dword_855A4E4 + 736192))(se);
    }
    v11 = 0;
  }
}
// 8164620: using guessed type char *off_8164620;
// 855A4E4: using guessed type int dword_855A4E4;
// 855D560: using guessed type int dword_855D560;
// 855D564: using guessed type int dword_855D564;
// 855D568: using guessed type int dword_855D568;

//----- (080D5B94) --------------------------------------------------------
_DWORD *__cdecl sub_80D5B94(int a1, int a2, int a3)
{
  int v3; // ebx
  int v4; // ebx
  int v5; // ebx
  int v6; // ebx
  size_t v7; // eax
  int v8; // eax
  int v9; // ebx
  size_t v10; // eax
  int v11; // eax
  int v12; // ebx
  int v13; // ebx
  size_t v14; // eax
  int v15; // eax
  int v16; // ebx
  size_t v17; // eax
  int v18; // eax
  const char *v20; // [esp+4h] [ebp-174h]
  int v21; // [esp+14h] [ebp-164h]
  int v22; // [esp+18h] [ebp-160h] BYREF
  int v23; // [esp+1Ch] [ebp-15Ch]
  int i; // [esp+20h] [ebp-158h]
  int v25; // [esp+24h] [ebp-154h]
  int v26; // [esp+28h] [ebp-150h]
  int v27; // [esp+2Ch] [ebp-14Ch]
  int v28; // [esp+30h] [ebp-148h]
  int v29; // [esp+34h] [ebp-144h]
  int v30; // [esp+38h] [ebp-140h]
  void **v31; // [esp+4Ch] [ebp-12Ch]
  _DWORD v32[64]; // [esp+50h] [ebp-128h] BYREF
  void *s; // [esp+150h] [ebp-28h]
  int v34; // [esp+154h] [ebp-24h]
  char *v35; // [esp+158h] [ebp-20h]
  int v36[7]; // [esp+15Ch] [ebp-1Ch] BYREF

  v31 = 0;
  if ( !dword_8575C20 )
  {
    v21 = FS_FOpenFileByMode(*(char **)off_81643C0, &v22, 0);
    if ( v21 < 0 )
      Com_Error(1, (char *)&byte_814BB40, *(_DWORD *)off_81643C0);
    if ( (unsigned int)v21 > 0x1869E )
      Com_Error(1, (char *)&byte_814BB40, *(_DWORD *)off_81643C0);
    FS_Read((int)&unk_855D580, v21, v22);
    *(_BYTE *)(v21 + 139842944) = 0;
    FS_FCloseFile(v22);
    dword_8575C20 = 1;
  }
  dword_855A4E4 = a1;
  dword_855D568 = a2;
  dword_855D56C = a3;
  v34 = 0;
  sub_80D4A08();
  memset(dword_855CC60, 0, 0x480u);
  memset(&unk_855A540, 0, 0x2710u);
  memset(dword_855A500, 0, 0x24u);
  dword_855CC50 = 0;
  for ( i = 0; i <= 2; ++i )
    *(&v28 + i) = -1;
  v27 = 0;
  s = 0;
  v36[0] = (int)&unk_855D580;
  Com_BeginParseSession("BG_AnimParseAnimScript");
  while ( 1 )
  {
    v35 = Com_Parse((char **)v36);
    if ( !v35 || !*v35 )
      break;
    v25 = sub_80D48C6(v35, (int *)&off_8164820, 1);
    if ( v25 < 0 )
    {
      switch ( v34 )
      {
        case 0:
          if ( !I_stricmp(v35, "set") )
          {
            v35 = Com_ParseOnLine((char **)v36);
            if ( !v35 || !*v35 )
              BG_AnimParseError("BG_AnimParseAnimScript: expected condition type string");
            v23 = sub_80D48C6(v35, (int *)&off_8164760, 0);
            if ( dword_81647C0[2 * v23] )
              BG_AnimParseError("BG_AnimParseAnimScript: can not make a define of type '%s'", v35);
            v35 = Com_ParseOnLine((char **)v36);
            if ( !v35 || !*v35 )
              BG_AnimParseError("BG_AnimParseAnimScript: expected condition define string");
            v3 = dword_855A500[v23] + 16 * v23;
            dword_855CC60[2 * v3] = (int)sub_80D4970(v35, (int)&unk_855A540, 0x2710u, &dword_855CC50);
            v4 = dword_855A500[v23] + 16 * v23;
            dword_855CC64[2 * v4] = BG_StringHashValue_Lwr(dword_855CC60[2 * v4]);
            v35 = Com_ParseOnLine((char **)v36);
            if ( !v35 )
              BG_AnimParseError("BG_AnimParseAnimScript: expected '=', found end of line");
            if ( I_stricmp(v35, "=") )
              BG_AnimParseError("BG_AnimParseAnimScript: expected '=', found '%s'", v35);
            sub_80D4ED4(
              (char **)v36,
              (int *)off_81647C4[2 * v23],
              v23,
              (_DWORD *)(8 * (dword_855A500[v23] + 16 * v23) + 139841760));
            ++dword_855A500[v23];
          }
          break;
        case 1:
        case 2:
          if ( I_stricmp(v35, "{") )
          {
            if ( I_stricmp(v35, "}") )
            {
              if ( v27 || v28 >= 0 )
              {
                if ( v27 == 1 && v29 < 0 )
                {
                  v6 = v27;
                  *(&v28 + v6) = sub_80D48C6(v35, (int *)&off_8164420, 0);
                  if ( v34 == 1 )
                  {
                    s = (void *)(516 * v29 + a1 + 21156 * v28 + 49156);
                    dword_855D560 = v29;
                  }
                  else if ( v34 == 2 )
                  {
                    s = (void *)(516 * v29 + a1 + 21156 * v28 + 133780);
                  }
                  goto LABEL_103;
                }
                if ( v27 == 2 && v30 < 0 )
                {
                  v7 = strlen(v35);
                  v36[0] -= v7;
                  v8 = strlen(v35);
                  if ( I_strncmp((char *)v36[0], v35, v8) )
                    BG_AnimParseError("BG_AnimParseAnimScript: internal error");
                  memset(v32, 0, 0xF4u);
                  v9 = v27;
                  *(&v28 + v9) = sub_80D5250((char **)v36, v32);
                  if ( *(int *)s > 127 )
                    BG_AnimParseError("BG_AnimParseAnimScript: exceeded maximum items per script (%i)", 128);
                  if ( *(int *)(a1 + 736176) > 2047 )
                    BG_AnimParseError("BG_AnimParseAnimScript: exceeded maximum global items (%i)", 2048);
                  goto LABEL_71;
                }
                if ( v27 != 3 )
                  BG_AnimParseError("BG_AnimParseAnimScript: unexpected '%s'", v35);
                v10 = strlen(v35);
                v36[0] -= v10;
                v11 = strlen(v35);
                if ( I_strncmp((char *)v36[0], v35, v11) )
                  BG_AnimParseError("BG_AnimParseAnimScript: internal error");
                goto LABEL_75;
              }
              if ( I_stricmp(v35, "state") )
                BG_AnimParseError("BG_AnimParseAnimScript: expected 'state'");
              v35 = Com_ParseOnLine((char **)v36);
              if ( !v35 )
                BG_AnimParseError("BG_AnimParseAnimScript: expected state type");
              v5 = v27;
              *(&v28 + v5) = sub_80D48C6(v35, (int *)&off_81643E0, 0);
              v35 = Com_Parse((char **)v36);
              if ( !v35 || I_stricmp(v35, "{") )
                BG_AnimParseError("BG_AnimParseAnimScript: expected '{'");
              ++v27;
            }
            else
            {
              if ( --v27 < 0 )
                BG_AnimParseError("BG_AnimParseAnimScript: unexpected '%s'", v35);
              if ( v27 == 1 )
                s = 0;
              *(&v28 + v27) = -1;
            }
          }
          else
          {
            if ( v27 > 2 )
              BG_AnimParseError("BG_AnimParseAnimScript: unexpected '%s'", v35);
            if ( *(&v28 + v27) < 0 )
              BG_AnimParseError("BG_AnimParseAnimScript: unexpected '%s'", v35);
            ++v27;
          }
          break;
        case 3:
        case 4:
          if ( I_stricmp(v35, "{") )
          {
            if ( I_stricmp(v35, "}") )
            {
              if ( v27 || v28 >= 0 )
              {
                if ( v27 == 1 && v29 < 0 )
                {
                  v14 = strlen(v35);
                  v36[0] -= v14;
                  v15 = strlen(v35);
                  if ( I_strncmp((char *)v36[0], v35, v15) )
                    BG_AnimParseError("BG_AnimParseAnimScript: internal error");
                  memset(v32, 0, 0xF4u);
                  v16 = v27;
                  *(&v28 + v16) = sub_80D5250((char **)v36, v32);
                  if ( *(int *)s > 127 )
                    BG_AnimParseError("BG_AnimParseAnimScript: exceeded maximum items per script (%i)", 128);
                  if ( *(int *)(a1 + 736176) > 2047 )
                    BG_AnimParseError("BG_AnimParseAnimScript: exceeded maximum global items (%i)", 2048);
LABEL_71:
                  *((_DWORD *)s + *(_DWORD *)s + 1) = a1 + 244 * (*(_DWORD *)(a1 + 736176))++ + 236464;
                  v31 = (void **)*((_DWORD *)s + ++*(_DWORD *)s);
                  qmemcpy(v31, v32, 0xF4u);
                }
                else
                {
                  if ( v27 != 2 )
                    BG_AnimParseError("BG_AnimParseAnimScript: unexpected '%s'", v35);
                  v17 = strlen(v35);
                  v36[0] -= v17;
                  v18 = strlen(v35);
                  if ( I_strncmp((char *)v36[0], v35, v18) )
                    BG_AnimParseError("BG_AnimParseAnimScript: internal error");
LABEL_75:
                  sub_80D5424((char **)v36, v31, a1);
                }
              }
              else
              {
                if ( v34 == 3 )
                {
                  if ( I_stricmp(v35, "statechange") )
                    BG_AnimParseError("BG_AnimParseAnimScript: expected 'statechange', got '%s'", v35);
                  v35 = Com_ParseOnLine((char **)v36);
                  if ( !v35 )
                    BG_AnimParseError("BG_AnimParseAnimScript: expected <state type>");
                  v26 = sub_80D48C6(v35, (int *)&off_81643E0, 0);
                  v35 = Com_ParseOnLine((char **)v36);
                  if ( !v35 )
                    BG_AnimParseError("BG_AnimParseAnimScript: expected <state type>");
                  v12 = v27;
                  *(&v28 + v12) = sub_80D48C6(v35, (int *)&off_81643E0, 0);
                  s = (void *)(516 * *(&v28 + v27) + a1 + 2064 * v26 + 218404);
                  v35 = Com_Parse((char **)v36);
                  if ( !v35 || I_stricmp(v35, "{") )
                    BG_AnimParseError("BG_AnimParseAnimScript: expected '{'");
                  ++v27;
                }
                else
                {
                  v13 = v27;
                  *(&v28 + v13) = sub_80D48C6(v35, (int *)&off_8164580, 0);
                  s = (void *)(a1 + 516 * v28 + 226660);
                  dword_855D564 = *(&v28 + v27);
                }
LABEL_103:
                memset(s, 0, 0x204u);
              }
            }
            else
            {
              if ( --v27 < 0 )
                BG_AnimParseError("BG_AnimParseAnimScript: unexpected '%s'", v35);
              if ( !v27 )
                s = 0;
              *(&v28 + v27) = -1;
            }
          }
          else
          {
            if ( v27 > 2 )
              BG_AnimParseError("BG_AnimParseAnimScript: unexpected '%s'", v35);
            if ( *(&v28 + v27) < 0 )
              BG_AnimParseError("BG_AnimParseAnimScript: unexpected '%s'", v35);
            ++v27;
          }
          break;
        default:
          continue;
      }
    }
    else
    {
      if ( v27 )
        BG_AnimParseError("BG_AnimParseAnimScript: unexpected '%s'", v35);
      v34 = v25;
      dword_855D560 = 0;
      dword_855D564 = -1;
    }
  }
  if ( v27 )
    BG_AnimParseError("BG_AnimParseAnimScript: unexpected end of file: %s", v20);
  *(_DWORD *)off_81643C0 = 0;
  return Com_EndParseSession();
}
// 80D5D77: variable 'v20' is possibly undefined
// 81643E0: using guessed type char *off_81643E0;
// 8164420: using guessed type char *off_8164420;
// 8164580: using guessed type char *off_8164580;
// 8164760: using guessed type char *off_8164760;
// 81647C0: using guessed type int dword_81647C0[];
// 81647C4: using guessed type int off_81647C4[17];
// 8164820: using guessed type char *off_8164820;
// 855A4E4: using guessed type int dword_855A4E4;
// 855A500: using guessed type int dword_855A500[];
// 855CC50: using guessed type int dword_855CC50;
// 855CC60: using guessed type int dword_855CC60[];
// 855CC64: using guessed type int dword_855CC64[287];
// 855D560: using guessed type int dword_855D560;
// 855D564: using guessed type int dword_855D564;
// 855D568: using guessed type int dword_855D568;
// 855D56C: using guessed type int dword_855D56C;
// 8575C20: using guessed type int dword_8575C20;
// 80D5B94: using guessed type _DWORD var_128[64];

//----- (080D688A) --------------------------------------------------------
int __cdecl sub_80D688A(int a1, _DWORD *a2)
{
  int v3; // [esp+0h] [ebp-10h]
  _DWORD *v5; // [esp+8h] [ebp-8h]
  int v6; // [esp+Ch] [ebp-4h]

  v6 = 0;
  v5 = a2 + 1;
  while ( v6 < *a2 )
  {
    v3 = dword_81647C0[2 * *v5];
    if ( v3 )
    {
      if ( v3 == 1 && *(_DWORD *)(a1 + 8 * *v5 + 1116) != v5[1] )
        return 0;
    }
    else if ( (*(_DWORD *)(a1 + 8 * *v5 + 1116) & v5[1]) == 0 && (*(_DWORD *)(a1 + 8 * *v5 + 1120) & v5[2]) == 0 )
    {
      return 0;
    }
    ++v6;
    v5 += 3;
  }
  return 1;
}
// 81647C0: using guessed type int dword_81647C0[];

//----- (080D6944) --------------------------------------------------------
_DWORD *__cdecl sub_80D6944(int a1, _DWORD *a2)
{
  int v4; // [esp+10h] [ebp-8h]
  _DWORD **v5; // [esp+14h] [ebp-4h]

  v4 = 0;
  v5 = (_DWORD **)(a2 + 1);
  while ( v4 < *a2 )
  {
    if ( sub_80D688A((int)dword_855A4E0 + 1208 * a1 + 736252, *v5) )
      return *v5;
    ++v4;
    ++v5;
  }
  return 0;
}

//----- (080D69B2) --------------------------------------------------------
int __cdecl sub_80D69B2(_DWORD *a1, int a2, int a3, int a4, int a5, int a6, int a7)
{
  int v9; // [esp+8h] [ebp-8h]
  int v10; // [esp+Ch] [ebp-4h]

  v9 = 0;
  if ( a4 )
    v10 = a4;
  else
    v10 = *(_DWORD *)(dword_855A4E4 + 96 * a2 + 72) + 50;
  if ( a3 == 2 )
  {
LABEL_20:
    if ( (int)a1[32] <= 49 || a7 )
    {
      if ( a6 && (a1[33] & 0xFFFFFDFF) == a2 )
      {
        if ( a5 && (*(_BYTE *)(dword_855A4E4 + 96 * a2 + 80) & 0x80) != 0 )
          a1[32] = v10;
      }
      else
      {
        a1[33] = a2 | a1[33] & 0x200 ^ 0x200;
        if ( a5 )
          a1[32] = v10;
        a1[35] = v10;
      }
    }
    goto LABEL_30;
  }
  if ( a3 > 2 )
  {
    if ( a3 != 3 )
      goto LABEL_30;
  }
  else if ( a3 != 1 )
  {
    goto LABEL_30;
  }
  if ( (int)a1[30] <= 49 || a7 )
  {
    if ( a6 && (a1[31] & 0xFFFFFDFF) == a2 )
    {
      if ( a5 && (*(_BYTE *)(dword_855A4E4 + 96 * a2 + 80) & 0x80) != 0 )
        a1[30] = v10;
    }
    else
    {
      v9 = 1;
      a1[34] = v10;
      a1[31] = a2 | a1[31] & 0x200 ^ 0x200;
      if ( a5 )
        a1[30] = v10;
    }
  }
  if ( a3 == 3 )
  {
    a2 = 0;
    goto LABEL_20;
  }
LABEL_30:
  if ( v9 )
    return v10;
  else
    return -1;
}
// 855A4E4: using guessed type int dword_855A4E4;

//----- (080D6B7C) --------------------------------------------------------
int __cdecl sub_80D6B7C(_DWORD *a1, char *src, int a3, int a4, int a5, int a6)
{
  int v6; // eax

  v6 = BG_AnimationIndexForString(src);
  return sub_80D69B2(a1, v6, a3, 0, a4, a5, a6);
}

//----- (080D6BC4) --------------------------------------------------------
int __cdecl sub_80D6BC4(_DWORD *a1, __int16 *a2, int a3, int a4, int a5)
{
  _BOOL4 v7; // [esp+20h] [ebp-8h]
  int v8; // [esp+24h] [ebp-4h]

  v8 = -1;
  v7 = 0;
  if ( *a2 )
  {
    v8 = a2[4] + 50;
    if ( *a2 == 1 || *a2 == 3 )
      v7 = sub_80D69B2(a1, a2[2], *a2, v8, a3, a4, a5) >= 0;
    else
      sub_80D69B2(a1, a2[2], *a2, v8, a3, a4, a5);
  }
  if ( a2[1] )
  {
    v8 = a2[4] + 50;
    if ( *a2 == 1 || *a2 == 3 )
      v7 = sub_80D69B2(a1, a2[3], a2[1], v8, a3, a4, a5) >= 0;
    else
      sub_80D69B2(a1, a2[3], a2[1], v8, a3, a4, a5);
  }
  if ( *((_DWORD *)a2 + 3) )
    (*(void (__cdecl **)(_DWORD, _DWORD))(dword_855A4E4 + 736196))(a1[51], *((_DWORD *)a2 + 3));
  if ( v7 )
    return v8;
  else
    return -1;
}
// 855A4E4: using guessed type int dword_855A4E4;

//----- (080D6D82) --------------------------------------------------------
int __cdecl sub_80D6D82(_DWORD *a1, int a2, int a3, int a4)
{
  _DWORD *v6; // [esp+30h] [ebp-8h]

  v6 = 0;
  if ( (int)a1[1] > 5 )
    return -1;
  while ( !v6 && a2 >= 0 )
  {
    if ( *(_DWORD *)(516 * a3 + dword_855A4E4 + 21156 * a2 + 49156) )
    {
      v6 = sub_80D6944(a1[51], (_DWORD *)(516 * a3 + dword_855A4E4 + 21156 * a2 + 49156));
      if ( !v6 )
        --a2;
    }
    else
    {
      --a2;
    }
  }
  if ( !v6 )
    return -1;
  if ( !v6[28] )
    return -1;
  sub_80D70E2(a1[51], 3, a3, 1);
  return sub_80D6BC4(a1, (__int16 *)&v6[4 * (a1[51] % v6[28]) + 29], 0, a4, 0) != -1;
}
// 855A4E4: using guessed type int dword_855A4E4;

//----- (080D6EDC) --------------------------------------------------------
int __cdecl sub_80D6EDC(_DWORD *a1, int a2, int a3)
{
  __int16 *v5; // [esp+1Ch] [ebp-Ch]
  _DWORD *v6; // [esp+20h] [ebp-8h]

  if ( (int)a1[1] > 5 )
    return -1;
  if ( !*(_DWORD *)(516 * a2 + dword_855A4E4 + 2064 * a3 + 218404) )
    return -1;
  v6 = sub_80D6944(a1[51], (_DWORD *)(516 * a2 + dword_855A4E4 + 2064 * a3 + 218404));
  if ( !v6 )
    return -1;
  if ( !v6[28] )
    return -1;
  v5 = (__int16 *)&v6[4 * (rand() % v6[28]) + 29];
  return sub_80D6BC4(a1, v5, 1, 0, 0);
}
// 855A4E4: using guessed type int dword_855A4E4;

//----- (080D6FCA) --------------------------------------------------------
int __cdecl BG_AnimScriptEvent(_DWORD *a1, int a2, int a3, int a4)
{
  __int16 *v6; // [esp+1Ch] [ebp-Ch]
  _DWORD *v7; // [esp+20h] [ebp-8h]

  if ( a2 != 1 && (int)a1[1] > 5 )
    return -1;
  if ( !*(_DWORD *)(dword_855A4E4 + 516 * a2 + 226660) )
    return -1;
  v7 = sub_80D6944(a1[51], (_DWORD *)(dword_855A4E4 + 516 * a2 + 226660));
  if ( !v7 )
    return -1;
  if ( !v7[28] )
    return -1;
  v6 = (__int16 *)&v7[4 * (rand() % v7[28]) + 29];
  return sub_80D6BC4(a1, v6, 1, a3, a4);
}
// 855A4E4: using guessed type int dword_855A4E4;

//----- (080D70AA) --------------------------------------------------------
int __cdecl sub_80D70AA(int a1, unsigned int a2)
{
  if ( a2 >= *(_DWORD *)(dword_855A4E4 + 49152) )
    BG_AnimParseError("BG_GetAnimString: anim index is out of range");
  return dword_855A4E4 + 96 * a2;
}
// 855A4E4: using guessed type int dword_855A4E4;

//----- (080D70E2) --------------------------------------------------------
int __cdecl sub_80D70E2(int a1, int a2, int a3, int a4)
{
  int result; // eax

  if ( !a4 || dword_81647C0[2 * a2] )
  {
    result = a3;
    *((_DWORD *)dword_855A4E0 + 302 * a1 + 2 * a2 + 184342) = a3;
  }
  else
  {
    *((_DWORD *)dword_855A4E0 + 302 * a1 + 2 * a2 + 184342) = 0;
    *((_DWORD *)dword_855A4E0 + 302 * a1 + 2 * a2 + 184343) = 0;
    return sub_80D9EAA((int)dword_855A4E0 + 1208 * a1 + 8 * a2 + 737368, a3);
  }
  return result;
}
// 81647C0: using guessed type int dword_81647C0[];

//----- (080D7180) --------------------------------------------------------
unsigned int __cdecl sub_80D7180(int a1, int a2, int a3)
{
  unsigned int i; // [esp+10h] [ebp-8h]

  if ( !a3 || dword_81647C0[2 * a2] )
    return *(_DWORD *)(a1 + 8 * a2 + 1116);
  for ( i = 0; i <= 0x3F; ++i )
  {
    if ( (unsigned __int8)sub_80D9E84(a1 + 8 * a2 + 1116, i) )
      return i;
  }
  return 0;
}
// 81647C0: using guessed type int dword_81647C0[];

//----- (080D72B8) --------------------------------------------------------
int __cdecl sub_80D72B8(int a1, unsigned int a2)
{
  if ( a2 >= *(_DWORD *)(dword_855A4E4 + 49152) )
    Com_Error(1, (char *)&byte_814BFE0);
  return dword_855A4E4 + 96 * a2;
}
// 855A4E4: using guessed type int dword_855A4E4;

//----- (080D72F8) --------------------------------------------------------
int __cdecl sub_80D72F8(int *a1)
{
  int v1; // eax
  int v3; // [esp+10h] [ebp-8h]
  float *v4; // [esp+14h] [ebp-4h]

  v4 = (float *)*a1;
  v1 = sub_80E95EE((_DWORD *)*a1);
  v3 = BG_WeaponDefs(v1);
  sub_80D70E2(*((_DWORD *)v4 + 51), 0, *(_DWORD *)(v3 + 116), 1);
  sub_80D70E2(*((_DWORD *)v4 + 51), 1, *(_DWORD *)(v3 + 124), 1);
  if ( ((_DWORD)v4[40] & 0x40000) != 0 )
    sub_80D70E2(*((_DWORD *)v4 + 51), 7, 1, 1);
  else
    sub_80D70E2(*((_DWORD *)v4 + 51), 7, 0, 1);
  if ( ((_DWORD)v4[40] & 0x300) != 0 )
    sub_80D70E2(*((_DWORD *)v4 + 51), 2, 1, 1);
  else
    sub_80D70E2(*((_DWORD *)v4 + 51), 2, 0, 1);
  sub_80D70E2(*((_DWORD *)v4 + 51), 4, v4[58] > 0.0, 1);
  if ( (a1[2] & 1) != 0 )
    return sub_80D70E2(*((_DWORD *)v4 + 51), 6, 1, 1);
  else
    return sub_80D70E2(*((_DWORD *)v4 + 51), 6, 0, 1);
}

//----- (080D74DE) --------------------------------------------------------
_BOOL4 __cdecl sub_80D74DE(int a1, int a2)
{
  int v3; // [esp+14h] [ebp-4h]

  v3 = sub_80D72B8(*(_DWORD *)(a1 + 8), a2 & 0xFFFFFDFF);
  return (*(_DWORD *)(v3 + 88) & 0x180 | *(_DWORD *)(v3 + 84) & 0xC4) != 0;
}

//----- (080D7534) --------------------------------------------------------
_BOOL4 __cdecl sub_80D7534(int a1, int a2)
{
  return (*(_DWORD *)(sub_80D72B8(*(_DWORD *)(a1 + 8), a2 & 0xFFFFFDFF) + 84) & 0x308) != 0;
}

//----- (080D7588) --------------------------------------------------------
_BOOL4 __cdecl sub_80D7588(int a1, int a2)
{
  return (*(_DWORD *)(sub_80D72B8(*(_DWORD *)(a1 + 8), a2 & 0xFFFFFDFF) + 84) & 0x7FF00000) != 0;
}

//----- (080D75DC) --------------------------------------------------------
void __cdecl sub_80D75DC(int *a1, int *a2, int a3, int a4)
{
  _BOOL4 v4; // ebx
  _BOOL4 v5; // ebx
  float v6; // [esp+8h] [ebp-70h]
  int v7; // [esp+Ch] [ebp-6Ch]
  int v8; // [esp+Ch] [ebp-6Ch]
  int v9; // [esp+Ch] [ebp-6Ch]
  int v10; // [esp+Ch] [ebp-6Ch]
  int v11; // [esp+Ch] [ebp-6Ch]
  int v12; // [esp+Ch] [ebp-6Ch]
  int v13; // [esp+28h] [ebp-50h]
  _BOOL4 v14; // [esp+34h] [ebp-44h]
  _BOOL4 v15; // [esp+38h] [ebp-40h]
  int v16; // [esp+40h] [ebp-38h]
  int v17; // [esp+48h] [ebp-30h]
  int v18; // [esp+4Ch] [ebp-2Ch]
  _DWORD *v19; // [esp+50h] [ebp-28h]
  float v20; // [esp+58h] [ebp-20h]
  float v21; // [esp+58h] [ebp-20h]
  int v22; // [esp+5Ch] [ebp-1Ch]
  int v23; // [esp+60h] [ebp-18h]
  int v24; // [esp+68h] [ebp-10h]
  int v25; // [esp+6Ch] [ebp-Ch]
  char *v26; // [esp+70h] [ebp-8h]
  unsigned int v27; // [esp+88h] [ebp+10h]

  v24 = -1;
  v22 = 0;
  v20 = 0.0;
  v25 = a2[5];
  v23 = a2[4];
  if ( !v25 )
    v22 = 1;
  a2[4] = a3;
  v27 = a3 & 0xFFFFFDFF;
  if ( v27 >= *((_DWORD *)dword_855A4E0 + 12288) )
    Com_Error(1, (char *)&byte_814C020, *((_DWORD *)dword_855A4E0 + 12288), v27);
  v19 = (_DWORD *)a1[297];
  v18 = *((_DWORD *)dword_855A4E0 + 184045);
  if ( v27 )
  {
    v26 = (char *)dword_855A4E0 + 96 * v27;
    a2[5] = (int)v26;
    a2[6] = *((_DWORD *)v26 + 16);
    v4 = sub_80D74DE((int)a1, v27);
    v15 = v4 == sub_80D74DE((int)a1, v23);
    v5 = sub_80D7534((int)a1, v27);
    v14 = v5 == sub_80D7534((int)a1, v23);
    if ( a2 == a1 + 224 && (!v15 || !v14) )
      a1[299] = *((_DWORD *)dword_855A4E0 + 184055) + 400;
  }
  else
  {
    v26 = 0;
    a2[5] = 0;
    a2[6] = 200;
  }
  if ( v22 && a2 == a1 + 224 )
  {
    a2[6] = 0;
  }
  else
  {
    if ( !v26 || a2[6] <= 0 )
    {
      if ( !v26 || *((float *)v26 + 17) == 0.0 )
      {
        if ( !v25 || *(float *)(v25 + 68) == 0.0 )
          v24 = 170;
        else
          v24 = 250;
      }
      else
      {
        v24 = 120;
      }
    }
    if ( a1[299] - *((_DWORD *)dword_855A4E0 + 184055) > v24 )
      v24 = a1[299] - *((_DWORD *)dword_855A4E0 + 184055);
    if ( a2[6] < v24 )
      a2[6] = v24;
  }
  if ( v26 && *((float *)v26 + 17) != 0.0 && (unsigned __int8)sub_80C040C(v18, v27) )
  {
    v16 = v23 & 0xFFFFFDFF;
    if ( v25 && *(float *)(v25 + 68) != 0.0 && (unsigned __int8)sub_80C040C(v18, v16) )
    {
      v20 = sub_80BE7D2((int)v19, v16);
    }
    else
    {
      if ( sub_80C00CA(v18, v16) )
        v17 = sub_80BE794(v18, v16) + 200;
      else
        v17 = 1000;
      v21 = (long double)(*((_DWORD *)dword_855A4E0 + 184055) % v17) / (long double)v17
          + (long double)a1[2] * 0.36000001;
      v20 = v21 - (long double)(int)v21;
    }
  }
  if ( v25 )
  {
    v6 = (long double)a2[6] * 0.001;
    sub_80BF346((int)v19, v23 & 0xFFFFFDFF, v6);
  }
  if ( v27 )
  {
    if ( a2 != a1 + 224 )
    {
      a1[253] = 0;
      a1[254] = 1;
    }
    if ( (*((_DWORD *)v26 + 20) & 0x40) != 0 )
    {
      if ( (unsigned __int8)sub_80C040C(v18, v27) )
        Com_Error(1, "death animation '%s' is looping", v26);
      if ( a4 )
      {
        *(float *)&v7 = (long double)a2[6] * 0.001;
        sub_80C04C6(v19, v27, 1.0, v7, 1065353216, 0, 0, 0);
      }
      else
      {
        sub_80BF6AC(v19, v27, *((unsigned __int16 *)dword_855A4E0 + 368102), 1.0, 0.0, 1065353216, 0, 0);
        sub_80C00E2((int)v19, v27, 1065353216);
      }
    }
    else
    {
      v13 = 0;
      if ( *((float *)v26 + 17) != 0.0 && sub_80BE816((int)v19, v27) == 0.0 )
        v13 = 1;
      *(float *)&v8 = (long double)a2[6] * 0.001;
      sub_80C04C6(v19, v27, 1.0, v8, 1065353216, 0, *((_DWORD *)v26 + 23), a2 != a1 + 224);
      if ( v13 )
        sub_80C00E2((int)v19, v27, SLODWORD(v20));
    }
    if ( a2 != a1 + 224 )
    {
      *(float *)&v9 = (long double)a2[6] * 0.001;
      sub_80C04C6(v19, *((unsigned __int16 *)dword_855A4E0 + 368092), 1.0, v9, 1065353216, 0, *((_DWORD *)v26 + 23), 0);
      *(float *)&v10 = (long double)a2[6] * 0.001;
      sub_80C04C6(
        v19,
        *((unsigned __int16 *)dword_855A4E0 + 368093),
        0.0099999998,
        v10,
        1065353216,
        0,
        *((_DWORD *)v26 + 23),
        0);
    }
  }
  else if ( a2 != a1 + 224 )
  {
    *(float *)&v11 = (long double)a2[6] * 0.001;
    sub_80C04C6(v19, *((unsigned __int16 *)dword_855A4E0 + 368092), 0.0, v11, 1065353216, 0, 0, 0);
    *(float *)&v12 = (long double)a2[6] * 0.001;
    sub_80C04C6(v19, *((unsigned __int16 *)dword_855A4E0 + 368093), 1.0, v12, 1065353216, 0, 0, 0);
  }
}

//----- (080D7D06) --------------------------------------------------------
int __cdecl sub_80D7D06(int *a1, int a2, int a3, int a4)
{
  int result; // eax
  float v5; // [esp+0h] [ebp-38h]
  int v6; // [esp+14h] [ebp-24h]
  float v7; // [esp+18h] [ebp-20h]
  float v8; // [esp+1Ch] [ebp-1Ch]
  float v9; // [esp+1Ch] [ebp-1Ch]
  int v10; // [esp+24h] [ebp-14h]
  int v11; // [esp+34h] [ebp-4h]

  v6 = 0;
  if ( *(_DWORD *)(a2 + 20) && (*(_DWORD *)(*(_DWORD *)(a2 + 20) + 80) & 2) != 0 )
    v6 = 1;
  v10 = a1[297];
  if ( a3 != *(_DWORD *)(a2 + 16) || !*(_DWORD *)(a2 + 20) && (a3 & 0xFFFFFDFF) != 0 )
    sub_80D75DC(a1, (int *)a2, a3, (*(_DWORD *)(a4 + 8) >> 19) & 1);
  result = a3 & 0xFFFFFDFF;
  if ( (a3 & 0xFFFFFDFF) != 0 )
  {
    v11 = *(_DWORD *)(a2 + 20);
    if ( *(float *)(v11 + 68) == 0.0 || !*(_DWORD *)(a2 + 44) )
    {
      *(_DWORD *)(a2 + 40) = 1065353216;
      *(_DWORD *)(a2 + 44) = *((_DWORD *)dword_855A4E0 + 184056);
      sub_80D9D2A((_DWORD *)(a4 + 24), (_DWORD *)(a2 + 28));
    }
    else if ( *((_DWORD *)dword_855A4E0 + 184056) != *(_DWORD *)(a2 + 44) )
    {
      if ( v6 )
      {
        v5 = *(float *)(a2 + 36) - *(float *)(a4 + 32);
        v8 = sub_80D9C30(v5);
      }
      else
      {
        Vec3Distance((float *)(a2 + 28), (float *)(a4 + 24));
        v8 = 0.0;
      }
      v9 = v8 / ((long double)(*((_DWORD *)dword_855A4E0 + 184056) - *(_DWORD *)(a2 + 44)) * 0.001);
      *(float *)(a2 + 40) = v9 / *(float *)(v11 + 68);
      *(_DWORD *)(a2 + 44) = *((_DWORD *)dword_855A4E0 + 184056);
      sub_80D9D2A((_DWORD *)(a4 + 24), (_DWORD *)(a2 + 28));
      if ( *(float *)(a2 + 40) >= 0.1 )
      {
        if ( *(float *)(a2 + 40) > 2.0 )
        {
          if ( (*(_DWORD *)(v11 + 80) & 2) != 0 )
          {
            if ( *(float *)(a2 + 40) > 4.0 )
              *(_DWORD *)(a2 + 40) = 1082130432;
          }
          else if ( *(float *)(v11 + 68) <= 150.0 )
          {
            if ( *(float *)(v11 + 68) >= 20.0 )
            {
              v7 = 3.0 - (*(float *)(v11 + 68) - 20.0) / 130.0;
              if ( *(float *)(a2 + 40) > (long double)v7 )
                *(float *)(a2 + 40) = v7;
            }
            else if ( *(float *)(a2 + 40) > 3.0 )
            {
              *(_DWORD *)(a2 + 40) = 1077936128;
            }
          }
          else
          {
            *(_DWORD *)(a2 + 40) = 0x40000000;
          }
        }
      }
      else if ( *(float *)(a2 + 40) < 0.0099999998 && v6 )
      {
        *(_DWORD *)(a2 + 40) = 0;
      }
      else
      {
        *(_DWORD *)(a2 + 40) = 1036831949;
      }
    }
    result = a2;
    if ( *(_DWORD *)(a2 + 16) )
      return sub_80C03EA(v10, *(_DWORD *)(a2 + 16) & 0xFFFFFDFF, *(_DWORD *)(a2 + 40));
  }
  return result;
}

//----- (080D8052) --------------------------------------------------------
void __cdecl sub_80D8052(int a1, _DWORD *a2)
{
  if ( a2[4] )
  {
    if ( sub_80BE816(a1, a2[4] & 0xFFFFFDFF) == 0.0 )
    {
      a2[4] = 0;
      a2[5] = 0;
      a2[6] = 150;
    }
  }
}

//----- (080D80B8) --------------------------------------------------------
void __cdecl sub_80D80B8(float a1, float a2, float a3, float a4, float *a5, _DWORD *a6)
{
  float v6; // [esp+0h] [ebp-18h]
  float v7; // [esp+0h] [ebp-18h]
  float v8; // [esp+0h] [ebp-18h]
  float v9; // [esp+Ch] [ebp-Ch]
  float v10; // [esp+Ch] [ebp-Ch]
  float v11; // [esp+10h] [ebp-8h]
  float v12; // [esp+14h] [ebp-4h]
  float v13; // [esp+14h] [ebp-4h]
  float v14; // [esp+14h] [ebp-4h]

  if ( !*a6 )
  {
    v12 = sub_80A6000(*a5, a1);
    if ( v12 > (long double)a2 || -a2 > (long double)v12 )
      *a6 = 1;
  }
  if ( *a6 )
  {
    v13 = sub_80A6000(a1, *a5);
    v9 = sub_80D9C30(v13);
    v10 = v9 * 0.050000001;
    if ( v10 < 0.5 )
      v10 = 0.5;
    if ( v13 < 0.0 )
    {
      v11 = (long double)*((int *)dword_855A4E0 + 184057) * v10 * -a4;
      if ( v13 < (long double)v11 )
      {
        *a6 = 1;
      }
      else
      {
        v11 = v13;
        *a6 = 0;
      }
    }
    else
    {
      v11 = (long double)*((int *)dword_855A4E0 + 184057) * v10 * a4;
      if ( v11 < (long double)v13 )
      {
        *a6 = 1;
      }
      else
      {
        v11 = v13;
        *a6 = 0;
      }
    }
    v6 = *a5 + v11;
    *a5 = sub_80A5F4C(v6);
    v14 = sub_80A6000(a1, *a5);
    if ( v14 <= (long double)a3 )
    {
      if ( -a3 > (long double)v14 )
      {
        v8 = a1 + a3;
        *a5 = sub_80A5F4C(v8);
      }
    }
    else
    {
      v7 = a1 - a3;
      *a5 = sub_80A5F4C(v7);
    }
  }
}

//----- (080D82A4) --------------------------------------------------------
void __cdecl sub_80D82A4(int a1, int a2)
{
  float v2; // [esp+20h] [ebp-48h] BYREF
  float v3; // [esp+24h] [ebp-44h]
  int v4; // [esp+30h] [ebp-38h] BYREF
  float v5; // [esp+34h] [ebp-34h]
  int v6; // [esp+40h] [ebp-28h] BYREF
  float v7; // [esp+44h] [ebp-24h]
  float v8; // [esp+50h] [ebp-18h]
  float v9; // [esp+54h] [ebp-14h]
  float v10; // [esp+58h] [ebp-10h]
  float v11; // [esp+5Ch] [ebp-Ch]

  v9 = sub_80B6688(*(float *)(a2 + 996));
  v8 = *(float *)(a2 + 992);
  sub_80D9D2A((_DWORD *)(a2 + 1000), &v2);
  v3 = sub_80A5F4C(v3);
  sub_80D9CDC(&v6);
  sub_80D9CDC(&v4);
  if ( (*(_DWORD *)(a1 + 8) & 0x300) != 0 )
  {
    *(_DWORD *)(a2 + 948) = 1;
    *(_DWORD *)(a2 + 956) = 1;
    *(_DWORD *)(a2 + 900) = 1;
  }
  else if ( (sub_80D7180(a2, 3, 0) & 0xC0000) != 0 )
  {
    *(_DWORD *)(a2 + 948) = 1;
    *(_DWORD *)(a2 + 956) = 1;
    *(_DWORD *)(a2 + 900) = 1;
  }
  else if ( (*(_DWORD *)(a1 + 8) & 0x4000) != 0 )
  {
    *(_DWORD *)(a2 + 948) = 1;
    *(_DWORD *)(a2 + 956) = 1;
    *(_DWORD *)(a2 + 900) = 1;
  }
  else if ( (sub_80D7180(a2, 3, 0) & 6) != 0 )
  {
    if ( sub_80D7180(a2, 6, 1) )
    {
      *(_DWORD *)(a2 + 948) = 1;
      *(_DWORD *)(a2 + 956) = 1;
    }
  }
  else
  {
    *(_DWORD *)(a2 + 948) = 1;
    *(_DWORD *)(a2 + 956) = 1;
    *(_DWORD *)(a2 + 900) = 1;
  }
  v7 = v3 + v8;
  if ( (*(_DWORD *)(a1 + 8) & 0x20000) != 0 )
  {
    v7 = v3;
    v5 = v3;
    v10 = 90.0;
  }
  else if ( (sub_80D7180(a2, 3, 0) & 0xC0000) != 0 )
  {
    v5 = v7;
    v10 = 0.0;
  }
  else if ( (*(_DWORD *)(a1 + 8) & 0x4000) != 0 )
  {
    v5 = v3;
    v7 = v3;
    v4 = 1119092736;
    v10 = 90.0;
  }
  else if ( (*(_DWORD *)(a1 + 8) & 8) != 0 )
  {
    v5 = v3;
    v10 = 90.0;
  }
  else if ( (*(_DWORD *)(a1 + 8) & 0x40) != 0 )
  {
    v5 = v3;
    v10 = 45.0;
  }
  else
  {
    if ( (*(_DWORD *)(a1 + 8) & 0x40000) != 0 )
      v5 = v3;
    else
      v5 = v8 * 0.30000001 + v3;
    v10 = 90.0;
  }
  sub_80D80B8(v5, 0.0, v10, *(float *)(bg_swingSpeed + 8), (float *)(a2 + 944), (_DWORD *)(a2 + 948));
  v10 = 150.0;
  if ( (*(_DWORD *)(a1 + 8) & 0x20000) != 0 )
    goto LABEL_26;
  if ( (*(_DWORD *)(a1 + 8) & 8) != 0 )
  {
    *(_DWORD *)(a2 + 900) = 0;
    *(float *)(a2 + 896) = v3 + v8;
  }
  else if ( (*((_DWORD *)dword_855A4E0 + 24 * (*(_DWORD *)(a1 + 204) & 0xFFFFFDFF) + 20) & 0x30) != 0 )
  {
    *(_DWORD *)(a2 + 900) = 0;
    v7 = v3;
    sub_80D80B8(v3, 0.0, v10, *(float *)(bg_swingSpeed + 8), (float *)(a2 + 896), (_DWORD *)(a2 + 900));
  }
  else
  {
    if ( *(_DWORD *)(a2 + 900) )
    {
LABEL_26:
      sub_80D80B8(v7, 0.0, v10, *(float *)(bg_swingSpeed + 8), (float *)(a2 + 896), (_DWORD *)(a2 + 900));
      goto LABEL_33;
    }
    sub_80D80B8(v7, 40.0, v10, *(float *)(bg_swingSpeed + 8), (float *)(a2 + 896), (_DWORD *)(a2 + 900));
  }
LABEL_33:
  if ( (*(_DWORD *)(a1 + 8) & 0x300) != 0 )
  {
    *(float *)(a2 + 944) = v3;
    *(float *)(a2 + 896) = v3;
  }
  else if ( (sub_80D7180(a2, 3, 0) & 0xC0000) != 0 )
  {
    *(float *)(a2 + 944) = v3 + v8;
    *(float *)(a2 + 896) = v3 + v8;
  }
  if ( (*(_DWORD *)(a1 + 8) & 0x20000) != 0 )
  {
    v11 = 0.0;
  }
  else if ( (*(_DWORD *)(a1 + 8) & 0x300) != 0 )
  {
    v11 = 0.0;
  }
  else if ( (sub_80D7180(a2, 3, 0) & 0xC0000) != 0 )
  {
    v11 = 0.0;
  }
  else if ( *(_DWORD *)(a1 + 8) == 0x4000 )
  {
    v11 = 0.0;
  }
  else if ( v2 <= 180.0 )
  {
    v11 = v2 * 0.60000002;
  }
  else
  {
    v11 = (v2 + -360.0) * 0.60000002;
  }
  sub_80D80B8(v11, 0.0, 45.0, 0.15000001, (float *)(a2 + 952), (_DWORD *)(a2 + 956));
}
// 85760B4: using guessed type int bg_swingSpeed;

//----- (080D8882) --------------------------------------------------------
int __cdecl sub_80D8882(_DWORD *a1, int a2)
{
  int v3; // [esp+18h] [ebp-10h]
  unsigned int v4; // [esp+1Ch] [ebp-Ch]

  v3 = BG_WeaponDefs(a1[50]);
  sub_80D70E2(a1[36], 0, *(_DWORD *)(v3 + 116), 1);
  sub_80D70E2(a1[36], 1, *(_DWORD *)(v3 + 124), 1);
  if ( (a1[2] & 0x40000) != 0 )
    sub_80D70E2(a1[36], 7, 1, 1);
  else
    sub_80D70E2(a1[36], 7, 0, 1);
  if ( (a1[2] & 0x300) != 0 )
    sub_80D70E2(a1[36], 2, 1, 1);
  else
    sub_80D70E2(a1[36], 2, 0, 1);
  sub_80D70E2(a1[36], 4, *(float *)(a2 + 1000) > 0.0, 1);
  if ( (a1[2] & 4) != 0 )
    sub_80D70E2(a1[36], 5, 1, 1);
  else
    sub_80D70E2(a1[36], 5, 0, 1);
  if ( (a1[2] & 0x40) != 0 )
    sub_80D70E2(a1[36], 6, 1, 1);
  else
    sub_80D70E2(a1[36], 6, 0, 1);
  v4 = a1[51] & 0xFFFFFDFF;
  if ( *(_QWORD *)((char *)dword_855A4E0 + 96 * v4 + 84)
    && sub_80D7180(a2, 3, 0) != *(_QWORD *)((char *)dword_855A4E0 + 96 * v4 + 84) )
  {
    sub_80D70E2(a1[36], 3, *((_DWORD *)dword_855A4E0 + 24 * v4 + 21), 0);
  }
  if ( (*((_DWORD *)dword_855A4E0 + 24 * v4 + 20) & 0x10) != 0 )
    return sub_80D70E2(a1[36], 8, 1, 1);
  if ( (*((_DWORD *)dword_855A4E0 + 24 * v4 + 20) & 0x20) != 0 )
    return sub_80D70E2(a1[36], 8, 2, 1);
  return sub_80D70E2(a1[36], 8, 0, 1);
}

//----- (080D8C3E) --------------------------------------------------------
void *__cdecl sub_80D8C3E(int a1, int a2, int a3, int a4, void *s)
{
  long double v6; // fst7
  long double v7; // fst7
  float v8; // [esp+0h] [ebp-E8h]
  int i; // [esp+30h] [ebp-B8h]
  int v10; // [esp+34h] [ebp-B4h] BYREF
  int v11[2]; // [esp+38h] [ebp-B0h] BYREF
  float v12; // [esp+40h] [ebp-A8h] BYREF
  float v13; // [esp+44h] [ebp-A4h]
  float v14; // [esp+48h] [ebp-A0h]
  float v15; // [esp+50h] [ebp-98h] BYREF
  float v16; // [esp+54h] [ebp-94h]
  float v17; // [esp+58h] [ebp-90h]
  float v18; // [esp+6Ch] [ebp-7Ch]
  float v19; // [esp+70h] [ebp-78h] BYREF
  float v20; // [esp+74h] [ebp-74h]
  float v21; // [esp+80h] [ebp-68h] BYREF
  float v22; // [esp+84h] [ebp-64h]
  float v23; // [esp+88h] [ebp-60h]
  float v24; // [esp+90h] [ebp-58h] BYREF
  float v25; // [esp+94h] [ebp-54h]
  float v26; // [esp+98h] [ebp-50h]
  float v27; // [esp+9Ch] [ebp-4Ch]
  float v28; // [esp+A0h] [ebp-48h]
  float v29; // [esp+A4h] [ebp-44h]
  float v30; // [esp+A8h] [ebp-40h]
  float v31; // [esp+ACh] [ebp-3Ch]
  float v32; // [esp+B0h] [ebp-38h]
  float v33; // [esp+B4h] [ebp-34h]
  float v34; // [esp+B8h] [ebp-30h]
  int v35; // [esp+BCh] [ebp-2Ch]
  float v36; // [esp+C0h] [ebp-28h]
  float v37; // [esp+C4h] [ebp-24h]
  float v38; // [esp+C8h] [ebp-20h]
  float v39[7]; // [esp+CCh] [ebp-1Ch] BYREF

  if ( (*(_DWORD *)(a2 + 8) & 0x300) != 0 )
    return memset(s, 0, 0x60u);
  v11[1] = *(_DWORD *)(a2 + 144);
  sub_80D9CDC(&v21);
  sub_80D9CDC(&v15);
  sub_80D9D2A((_DWORD *)(a4 + 1000), &v12);
  v22 = *(float *)(a4 + 896);
  v16 = *(float *)(a4 + 944);
  if ( (sub_80D7180(a4, 3, 0) & 0xC0000) == 0 )
  {
    v15 = *(float *)(a4 + 952);
    if ( (*(_DWORD *)(a2 + 8) & 8) != 0 )
    {
      v15 = sub_80A6112(v15);
      if ( v15 <= 0.0 )
        v15 = v15 * 0.25;
      else
        v15 = v15 * 0.5;
    }
  }
  sub_80A6062(&v12, &v15, &v12);
  sub_80A6062(&v15, &v21, &v15);
  sub_80D9D06(&v19, 0, 0, *(_DWORD *)(a2 + 228));
  v18 = sub_80B6688(*(float *)(a4 + 996));
  v17 = v18 * 50.0 * 0.92500001;
  v14 = v17;
  if ( v18 != 0.0 )
  {
    if ( (*(_DWORD *)(a2 + 8) & 4) != 0 )
    {
      if ( v18 <= 0.0 )
        v20 = -v18 * 12.5 + v20;
      else
        v20 = -v18 * 2.5 + v20;
    }
    else if ( v18 <= 0.0 )
    {
      v20 = -v18 * 5.0 + v20;
    }
    else
    {
      v20 = -v18 * 2.5 + v20;
    }
  }
  if ( (*(_DWORD *)(a2 + 8) & 0x20000) == 0 )
    v22 = sub_80A6000(v22, *(float *)(a4 + 1004));
  if ( (*(_DWORD *)(a2 + 8) & 8) != 0 )
  {
    if ( v18 != 0.0 )
      v14 = v14 * 0.5;
    v21 = v21 + *(float *)(a2 + 232);
    v8 = v16 * 0.0174532925199433;
    sub_80D9CAE(v8, (float *)v11, (float *)&v10);
    v19 = (1.0 - *(float *)&v10) * -24.0 + v19;
    v20 = *(float *)v11 * -12.0 + v20;
    if ( v18 * *(float *)v11 > 0.0 )
      v20 = -v18 * (1.0 - *(float *)&v10) * 16.0 + v20;
    v24 = 0.0;
    v25 = v17 * -1.2;
    v26 = v17 * 0.30000001;
    if ( *(float *)(a2 + 232) != 0.0 || *(float *)(a2 + 236) != 0.0 )
    {
      v6 = sub_80A6000(*(float *)(a2 + 232), *(float *)(a2 + 236));
      v24 = v6 + v24;
    }
    v27 = 0.0;
    v28 = v16 * 0.1 - v17 * 0.2;
    v29 = v17 * 0.2;
    v30 = v15;
    v31 = v16 * 0.80000001 + v17;
    v32 = v17 * -0.2;
  }
  else
  {
    if ( v18 != 0.0 )
    {
      if ( (*(_DWORD *)(a2 + 8) & 4) != 0 )
      {
        if ( v18 <= 0.0 )
        {
          v17 = v17 * 1.25;
          v14 = v14 * 1.25;
        }
      }
      else
      {
        v17 = v17 * 1.25;
        v14 = v14 * 1.25;
      }
    }
    v23 = v18 * 50.0 * 0.075000003 + v23;
    v24 = v15 * 0.2;
    v25 = v16 * 0.40000001;
    v26 = v17 * 0.5;
    if ( *(float *)(a2 + 232) != 0.0 || *(float *)(a2 + 236) != 0.0 )
    {
      v7 = sub_80A6000(*(float *)(a2 + 232), *(float *)(a2 + 236));
      v24 = v7 + v24;
    }
    v27 = v15 * 0.30000001;
    v28 = v16 * 0.40000001;
    v29 = v17 * 0.5;
    v30 = v15 * 0.5;
    v31 = v16 * 0.2;
    v32 = v17 * -0.60000002;
  }
  v33 = v12 * 0.30000001;
  v34 = v13 * 0.30000001;
  v35 = 0;
  v36 = v12 * 0.69999999;
  v37 = v13 * 0.69999999;
  v38 = v14 * -0.30000001;
  sub_80D9CDC(v39);
  if ( *(float *)(a2 + 236) != 0.0 || *(float *)(a2 + 232) != 0.0 )
    v39[0] = sub_80A6000(*(float *)(a2 + 236), *(float *)(a2 + 232));
  for ( i = 0; i <= 5; ++i )
    sub_80D9D2A((_DWORD *)&v24 + 3 * i, (_DWORD *)s + 3 * i);
  sub_80D9D2A(&v21, (_DWORD *)s + 18);
  return (void *)sub_80D9D2A(&v19, (_DWORD *)s + 21);
}
// 80D8C3E: using guessed type float var_1C[7];

//----- (080D93D8) --------------------------------------------------------
int *__cdecl sub_80D93D8(int a1, float a2, int a3)
{
  int *result; // eax
  int i; // [esp+4h] [ebp-Ch] BYREF
  float v5; // [esp+8h] [ebp-8h]

  for ( i = 0; i <= 2; ++i )
  {
    v5 = *(float *)(a1 + 4 * i) - *(float *)(a3 + 4 * i);
    if ( v5 <= (long double)a2 )
    {
      if ( -a2 <= (long double)v5 )
        *(_DWORD *)(a3 + 4 * i) = *(_DWORD *)(a1 + 4 * i);
      else
        *(float *)(a3 + 4 * i) = *(float *)(a3 + 4 * i) - a2;
    }
    else
    {
      *(float *)(a3 + 4 * i) = *(float *)(a3 + 4 * i) + a2;
    }
    result = &i;
  }
  return result;
}

//----- (080D94B8) --------------------------------------------------------
void __cdecl sub_80D94B8(float *a1, float a2, float *a3)
{
  int v3; // [esp+1Ch] [ebp-1Ch]
  float v4; // [esp+1Ch] [ebp-1Ch]
  int v5[6]; // [esp+20h] [ebp-18h] BYREF

  sub_80D9D5A(a1, a3, (float *)v5);
  *(float *)&v3 = sub_80D9DF2((float *)v5);
  if ( *(float *)&v3 != 0.0 )
  {
    v4 = sub_80D9C4A(v3) * a2;
    if ( v4 >= 1.0 )
      sub_80D9D2A(a1, a3);
    else
      sub_80D9D9E(a3, v4, (float *)v5, a3);
  }
}

//----- (080D954C) --------------------------------------------------------
int __cdecl sub_80D954C(int a1, int a2, int a3, int a4, int a5)
{
  float v6; // [esp+4h] [ebp-94h]
  _DWORD s[18]; // [esp+20h] [ebp-78h] BYREF
  int v8; // [esp+68h] [ebp-30h] BYREF
  float v9; // [esp+74h] [ebp-24h] BYREF
  float v10; // [esp+88h] [ebp-10h]
  int i; // [esp+8Ch] [ebp-Ch]

  sub_80D8C3E(a1, a2, a3, a4, s);
  v10 = (long double)a5 * 0.36000001;
  for ( i = 0; i <= 5; ++i )
  {
    sub_80D93D8((int)&s[3 * i], v10, a4 + 12 * i + 1020);
    sub_80B98CC(a1, a3, **((unsigned __int16 **)&off_8164808 + i), (float *)(a4 + 12 * i + 1020));
  }
  sub_80D93D8((int)&v8, v10, a4 + 1092);
  v6 = (long double)a5 * 0.1;
  sub_80D94B8(&v9, v6, (float *)(a4 + 1104));
  return sub_80B994A(a1, a3, (unsigned __int16)word_87A2342, (_DWORD *)(a4 + 1104), (float *)(a4 + 1092));
}
// 87A2342: using guessed type __int16 word_87A2342;

//----- (080D9698) --------------------------------------------------------
int __cdecl sub_80D9698(int a1, _DWORD *a2, int *a3)
{
  int v4; // [esp+14h] [ebp-4h]

  sub_80D82A4((int)a2, (int)a3);
  sub_80D8882(a2, (int)a3);
  v4 = a3[297];
  sub_80D8052(v4, a3 + 224);
  sub_80D8052(v4, a3 + 236);
  if ( a3[253] && (a3[240] & 0xFFFFFDFF) == 0 )
  {
    a3[253] = 0;
    a3[254] = 1;
  }
  sub_80D7D06(a3, (int)(a3 + 224), a2[51], (int)a2);
  return sub_80D7D06(a3, (int)(a3 + 236), a2[52], (int)a2);
}

//----- (080D978C) --------------------------------------------------------
int __cdecl sub_80D978C(int a1, _DWORD *a2, int a3, int a4)
{
  int result; // eax
  int v5; // [esp+2Ch] [ebp-7Ch]
  _DWORD v6[2]; // [esp+30h] [ebp-78h] BYREF
  _DWORD v7[23]; // [esp+38h] [ebp-70h]
  _DWORD *v8; // [esp+94h] [ebp-14h]
  int i; // [esp+98h] [ebp-10h]
  int v10; // [esp+9Ch] [ebp-Ch]

  v10 = a2[50];
  if ( (a2[2] & 0x300) != 0 )
    v10 = 0;
  v8 = *(_DWORD **)(a3 + 1188);
  if ( !*(_DWORD *)a3 || !*(_BYTE *)(a3 + 64) )
  {
    sub_80BFA1E(v8);
    return (*((int (__cdecl **)(_DWORD))dword_855A4E0 + 184061))(*a2);
  }
  if ( a1 )
  {
    if ( *(_DWORD *)(a3 + 1192) == v10 )
    {
      result = a3;
      if ( !*(_DWORD *)(a3 + 1016) )
        return result;
    }
    (*((void (__cdecl **)(_DWORD))dword_855A4E0 + 184061))(*a2);
  }
  v6[0] = (*((int (__cdecl **)(int))dword_855A4E0 + 184059))(a3 + 64);
  v6[1] = 0;
  v7[0] = 0;
  v5 = 1;
  for ( i = 0; i <= 5; ++i )
  {
    if ( *(_BYTE *)(a3 + (i << 6) + 128) )
    {
      v6[3 * v5] = (*((int (__cdecl **)(int))dword_855A4E0 + 184059))(a3 + (i << 6) + 128);
      v6[3 * v5 + 1] = a3 + (i << 6) + 512;
      v7[3 * v5++] = (a4 >> i) & 1;
    }
  }
  *(_DWORD *)(a3 + 1192) = v10;
  (*((void (__cdecl **)(_DWORD *, _DWORD, _DWORD *, _DWORD, int))dword_855A4E0 + 184060))(
    v6,
    (unsigned __int16)v5,
    v8,
    *a2,
    a3);
  result = a3;
  *(_DWORD *)(a3 + 1016) = 0;
  return result;
}

//----- (080D99BE) --------------------------------------------------------
int sub_80D99BE()
{
  Scr_FindAnim("multiplayer", "root", (_DWORD *)dword_855A4E0 + 184051, *((_DWORD *)dword_855A4E0 + 184058));
  Scr_FindAnim("multiplayer", "torso", (_DWORD *)dword_855A4E0 + 184052, *((_DWORD *)dword_855A4E0 + 184058));
  Scr_FindAnim("multiplayer", "legs", (_DWORD *)dword_855A4E0 + 184053, *((_DWORD *)dword_855A4E0 + 184058));
  return Scr_FindAnim("multiplayer", "turning", (_DWORD *)dword_855A4E0 + 184054, *((_DWORD *)dword_855A4E0 + 184058));
}

//----- (080D9A8A) --------------------------------------------------------
_DWORD *__userpurge sub_80D9A8A@<eax>(_DWORD *a1, char *a2, int a3)
{
  int v4; // [esp+14h] [ebp-4h] BYREF

  sub_806D8CE(&v4, a2);
  *a1 = v4;
  if ( !*a1 && a3 )
    Com_Error(1, (char *)&byte_814C140, a2);
  return a1;
}
// 80D9A8A: using guessed type char *arg_4;

//----- (080D9ADE) --------------------------------------------------------
int sub_80D9ADE()
{
  _DWORD *v0; // ebx
  int result; // eax
  int v2; // [esp+10h] [ebp-8h] BYREF

  v0 = (char *)dword_855A4E0 + 736200;
  sub_80D9A8A(&v2, "multiplayer", 1);
  *v0 = v2;
  *((_DWORD *)dword_855A4E0 + 184045) = *((_DWORD *)dword_855A4E0 + 184050);
  *((_WORD *)dword_855A4E0 + 368092) = *((_WORD *)dword_855A4E0 + 368104);
  *((_WORD *)dword_855A4E0 + 368093) = *((_WORD *)dword_855A4E0 + 368106);
  result = *((unsigned __int16 *)dword_855A4E0 + 368108);
  *((_WORD *)dword_855A4E0 + 368094) = result;
  return result;
}

//----- (080D9B7E) --------------------------------------------------------
int sub_80D9B7E()
{
  char *v1; // [esp+1Ch] [ebp-2Ch]
  int v2[7]; // [esp+20h] [ebp-28h] BYREF
  int v3[3]; // [esp+3Ch] [ebp-Ch] BYREF

  LargeLocal(v2, 36864);
  v1 = LargeLocalGetBuf(v2);
  v3[0] = 0;
  sub_80D99BE();
  sub_80D5B94((int)dword_855A4E0, (int)v1, (int)v3);
  sub_8075ECE(*((int (__cdecl **)(int))dword_855A4E0 + 184062), *((_DWORD *)dword_855A4E0 + 184058));
  sub_80D9ADE();
  sub_8075F0E();
  sub_80D4BC2();
  return LargeLocalDealloc(v2);
}
// 80D9B7E: using guessed type int var_28[7];
// 80D9B7E: using guessed type int var_C[3];

//----- (080D9C30) --------------------------------------------------------
long double __cdecl sub_80D9C30(float a1)
{
  return (float)fabs(a1);
}

//----- (080D9C4A) --------------------------------------------------------
long double __cdecl sub_80D9C4A(int a1)
{
  float v3; // [esp+Ch] [ebp-8h]

  v3 = *(float *)&a1 * 0.5;
  return (float)((1.5 - v3 * COERCE_FLOAT(1597463007 - (a1 >> 1)) * COERCE_FLOAT(1597463007 - (a1 >> 1)))
               * COERCE_FLOAT(1597463007 - (a1 >> 1)));
}

//----- (080D9CAE) --------------------------------------------------------
void __cdecl sub_80D9CAE(float a1, float *a2, float *a3)
{
  *a2 = sin(a1);
  *a3 = cos(a1);
}

//----- (080D9CDC) --------------------------------------------------------
int __cdecl sub_80D9CDC(_DWORD *a1)
{
  int result; // eax

  *a1 = 0;
  a1[1] = 0;
  result = 0;
  a1[2] = 0;
  return result;
}

//----- (080D9D06) --------------------------------------------------------
int __cdecl sub_80D9D06(_DWORD *a1, int a2, int a3, int a4)
{
  int result; // eax

  *a1 = a2;
  a1[1] = a3;
  result = a4;
  a1[2] = a4;
  return result;
}

//----- (080D9D2A) --------------------------------------------------------
int __cdecl sub_80D9D2A(_DWORD *a1, _DWORD *a2)
{
  int result; // eax

  *a2 = *a1;
  a2[1] = a1[1];
  result = a1[2];
  a2[2] = result;
  return result;
}

//----- (080D9D5A) --------------------------------------------------------
float *__cdecl sub_80D9D5A(float *a1, float *a2, float *a3)
{
  float *result; // eax

  *a3 = *a1 - *a2;
  a3[1] = a1[1] - a2[1];
  result = a1 + 2;
  a3[2] = a1[2] - a2[2];
  return result;
}

//----- (080D9D9E) --------------------------------------------------------
float *__cdecl sub_80D9D9E(float *a1, float a2, float *a3, float *a4)
{
  float *result; // eax

  *a4 = a2 * *a3 + *a1;
  a4[1] = a2 * a3[1] + a1[1];
  result = a3 + 2;
  a4[2] = a2 * a3[2] + a1[2];
  return result;
}

//----- (080D9DF2) --------------------------------------------------------
long double __cdecl sub_80D9DF2(float *a1)
{
  return *a1 * *a1 + a1[1] * a1[1] + a1[2] * a1[2];
}

//----- (080D9E26) --------------------------------------------------------
void __cdecl sub_80D9E26(float *a1)
{
  float v1; // [esp+0h] [ebp-8h]

  v1 = *a1 * *a1 + a1[1] * a1[1] + a1[2] * a1[2];
  sub_80D9E64(v1);
}

//----- (080D9E64) --------------------------------------------------------
long double __cdecl sub_80D9E64(float a1)
{
  return (float)sqrt(a1);
}

//----- (080D9E84) --------------------------------------------------------
int __cdecl sub_80D9E84(int a1, int a2)
{
  return (*(int *)(a1 + 4 * (a2 >> 5)) >> (a2 & 0x1F)) & 1;
}

//----- (080D9EAA) --------------------------------------------------------
int __cdecl sub_80D9EAA(int a1, int a2)
{
  int result; // eax

  result = *(_DWORD *)(a1 + 4 * (a2 >> 5)) | (1 << (a2 & 0x1F));
  *(_DWORD *)(a1 + 4 * (a2 >> 5)) = result;
  return result;
}

//----- (080D9EE8) --------------------------------------------------------
char *__usercall Jump_RegisterDvars@<eax>(long double a1@<st0>)
{
  char *result; // eax

  jump_height = (int)Dvar_RegisterFloat(a1, "jump_height", (char *)0x421C0000, 0, 1124073472, 4480);
  jump_stepSize = (int)Dvar_RegisterFloat(a1, "jump_stepSize", (char *)0x41900000, 0, 1115684864, 4480);
  jump_slowdownEnable = (int)Dvar_RegisterBool(a1, "jump_slowdownEnable", 1, 4480);
  jump_ladderPushVel = (int)Dvar_RegisterFloat(a1, "jump_ladderPushVel", (char *)0x43000000, 0, 1149239296, 4480);
  result = Dvar_RegisterFloat(a1, "jump_spreadAdd", (char *)0x42800000, 0, 1140850688, 4480);
  jump_spreadAdd = (int)result;
  return result;
}
// 8576040: using guessed type int jump_height;
// 8576044: using guessed type int jump_stepSize;
// 8576048: using guessed type int jump_slowdownEnable;
// 857604C: using guessed type int jump_ladderPushVel;
// 8576050: using guessed type int jump_spreadAdd;

//----- (080D9FF4) --------------------------------------------------------
int __cdecl Jump_ClearState(int a1)
{
  int result; // eax

  *(_DWORD *)(a1 + 12) &= ~0x80000u;
  result = 0;
  *(_DWORD *)(a1 + 116) = 0;
  return result;
}

//----- (080DA016) --------------------------------------------------------
int __cdecl Jump_GetStepHeight(int a1, int a2, float *a3)
{
  if ( *(float *)(a1 + 116) + *(float *)(jump_height + 8) <= (long double)*(float *)(a2 + 8) )
    return 0;
  *a3 = *(float *)(jump_stepSize + 8);
  if ( *(float *)(a2 + 8) + *a3 > *(float *)(a1 + 116) + *(float *)(jump_height + 8) )
    *a3 = *(float *)(a1 + 116) + *(float *)(jump_height + 8) - *(float *)(a2 + 8);
  return 1;
}
// 8576040: using guessed type int jump_height;
// 8576044: using guessed type int jump_stepSize;

//----- (080DA0A4) --------------------------------------------------------
_BOOL4 __cdecl Jump_IsPlayerAboveMax(int a1)
{
  return *(float *)(a1 + 28) >= *(float *)(a1 + 116) + *(float *)(jump_height + 8);
}
// 8576040: using guessed type int jump_height;

//----- (080DA0CA) --------------------------------------------------------
int __cdecl Jump_ActivateSlowdown(int a1)
{
  int result; // eax

  result = a1;
  if ( !*(_DWORD *)(a1 + 16) )
  {
    *(_DWORD *)(a1 + 12) |= 0x80000u;
    result = a1;
    *(_DWORD *)(a1 + 16) = 1800;
  }
  return result;
}

//----- (080DA0F4) --------------------------------------------------------
float *__cdecl Jump_ApplySlowdown(int a1)
{
  int v2; // [esp+14h] [ebp-4h]

  v2 = 1065353216;
  if ( *(int *)(a1 + 16) <= 1800 )
  {
    if ( !*(_DWORD *)(a1 + 16) )
    {
      if ( *(float *)(a1 + 116) + 18.0 <= *(float *)(a1 + 28) )
      {
        *(_DWORD *)(a1 + 16) = 1200;
        v2 = 1056964608;
      }
      else
      {
        *(_DWORD *)(a1 + 16) = 1800;
        v2 = 1059481190;
      }
    }
  }
  else
  {
    Jump_ClearState(a1);
    v2 = 1059481190;
  }
  if ( !*(_BYTE *)(jump_slowdownEnable + 8) )
    v2 = 1065353216;
  return sub_80DA7A6((float *)(a1 + 32), *(float *)&v2, (float *)(a1 + 32));
}
// 8576048: using guessed type int jump_slowdownEnable;

//----- (080DA1A6) --------------------------------------------------------
long double __cdecl Jump_ReduceFriction(int a1)
{
  if ( *(_BYTE *)(jump_slowdownEnable + 8) )
  {
    if ( *(int *)(a1 + 16) <= 1699 )
      return (float)((long double)*(int *)(a1 + 16) * 1.5 * 0.00058823527 + 1.0);
    else
      return (float)2.5;
  }
  else
  {
    return (float)1.0;
  }
}
// 8576048: using guessed type int jump_slowdownEnable;

//----- (080DA1F8) --------------------------------------------------------
long double __cdecl sub_80DA1F8(int a1)
{
  if ( *(int *)(a1 + 16) > 1800 )
  {
    Jump_ClearState(a1);
    return 1.0;
  }
  else
  {
    return (float)Jump_ReduceFriction(a1);
  }
}

//----- (080DA238) --------------------------------------------------------
void __cdecl Jump_ClampVelocity(int a1, int a2)
{
  float v2; // [esp+0h] [ebp-18h]
  float v3; // [esp+10h] [ebp-8h]
  float v4; // [esp+14h] [ebp-4h]

  if ( *(float *)(a1 + 28) - *(float *)(a2 + 8) > 0.0 )
  {
    v4 = *(float *)(a1 + 116) + *(float *)(jump_height + 8) - *(float *)(a1 + 28);
    if ( v4 >= 0.1 )
    {
      v2 = (v4 + v4) * (long double)*(int *)(a1 + 72);
      v3 = sub_80DA70C(v2);
      if ( *(float *)(a1 + 40) > (long double)v3 )
        *(float *)(a1 + 40) = v3;
    }
    else
    {
      *(_DWORD *)(a1 + 40) = 0;
    }
  }
}
// 8576040: using guessed type int jump_height;

//----- (080DA2CA) --------------------------------------------------------
long double __cdecl sub_80DA2CA(int a1)
{
  if ( *(_BYTE *)(jump_slowdownEnable + 8) )
  {
    if ( *(int *)(a1 + 16) <= 1699 )
      return (float)((long double)*(int *)(a1 + 16) * 1.5 * 0.00058823527 + 1.0);
    else
      return (float)2.5;
  }
  else
  {
    return (float)1.0;
  }
}
// 8576048: using guessed type int jump_slowdownEnable;

//----- (080DA31C) --------------------------------------------------------
void __cdecl sub_80DA31C(int *a1, _DWORD *a2, float a3)
{
  int v3; // [esp+8h] [ebp-10h]
  float v4; // [esp+Ch] [ebp-Ch]
  float v5; // [esp+10h] [ebp-8h]

  v3 = *a1;
  v5 = (a3 + a3) * (long double)*(int *)(*a1 + 72);
  if ( (*(_DWORD *)(*a1 + 12) & 0x80000) != 0 && *(int *)(v3 + 16) <= 1800 )
  {
    v4 = sub_80DA2CA(v3);
    v5 = v5 / v4;
  }
  a2[12] = 0;
  a2[13] = 0;
  a2[11] = 0;
  *(_DWORD *)(v3 + 96) = 1023;
  *(_DWORD *)(v3 + 112) = a1[1];
  *(_DWORD *)(v3 + 116) = *(_DWORD *)(v3 + 28);
  *(_DWORD *)(v3 + 12) |= 0x80000u;
  *(_DWORD *)(v3 + 16) = 0;
  *(float *)(v3 + 40) = sub_80DA70C(v5);
  *(float *)(v3 + 1492) = *(float *)(v3 + 1492) + *(float *)(jump_spreadAdd + 8);
  if ( *(float *)(v3 + 1492) > 255.0 )
    *(_DWORD *)(v3 + 1492) = 1132396544;
}
// 8576050: using guessed type int jump_spreadAdd;

//----- (080DA424) --------------------------------------------------------
unsigned int __cdecl sub_80DA424(int a1, int *a2)
{
  unsigned int result; // eax
  float v3; // [esp+4h] [ebp-44h]
  float v4; // [esp+1Ch] [ebp-2Ch]
  float v5; // [esp+1Ch] [ebp-2Ch]
  int v6[4]; // [esp+20h] [ebp-28h] BYREF
  int v7[6]; // [esp+30h] [ebp-18h] BYREF

  *(float *)(a1 + 40) = *(float *)(a1 + 40) * 0.75;
  sub_80DA752(v6, *a2, a2[1], 0);
  Vec3Normalize((float *)v6);
  v4 = sub_80DA832((float *)(a1 + 100), (float *)a2);
  if ( v4 >= 0.0 )
  {
    sub_80DA776(v6, v7);
  }
  else
  {
    v5 = sub_80DA832((float *)v6, (float *)(a1 + 100));
    v3 = v5 * -2.0;
    sub_80DA7DE((float *)v6, v3, (float *)(a1 + 100), (float *)v7);
    Vec3Normalize((float *)v7);
  }
  sub_80DA72C((float *)v7, *(float *)(jump_ladderPushVel + 8), (float *)(a1 + 32));
  result = *(_DWORD *)(a1 + 12) & 0xFFFFFFDF;
  *(_DWORD *)(a1 + 12) = result;
  return result;
}
// 857604C: using guessed type int jump_ladderPushVel;

//----- (080DA52E) --------------------------------------------------------
int __cdecl sub_80DA52E(int a1, int a2)
{
  int result; // eax

  if ( (*(_DWORD *)(a1 + 12) & 0x20) != 0 )
    return sub_80DED2E(a1, 91);
  result = PM_GroundSurfaceType(a2);
  if ( result )
    return sub_80DED2E(a1, result + 70);
  return result;
}

//----- (080DA584) --------------------------------------------------------
int __cdecl Jump_Check(int *a1, int *a2)
{
  _DWORD *v4; // [esp+14h] [ebp-4h]

  v4 = (_DWORD *)*a1;
  if ( a1[1] - *(_DWORD *)(*a1 + 112) <= 499 )
    return 0;
  if ( (v4[3] & 0x1000) != 0 )
    return 0;
  if ( (v4[3] & 4) != 0 )
    return 0;
  if ( (int)v4[1] > 5 )
    return 0;
  if ( PM_GetEffectiveStance((int)v4) )
    return 0;
  if ( (a1[2] & 0x400) == 0 )
    return 0;
  if ( (a1[9] & 0x400) != 0 )
  {
    a1[2] &= ~0x400u;
    return 0;
  }
  else
  {
    sub_80DA31C(a1, a2, *(float *)(jump_height + 8));
    sub_80DA52E((int)v4, (int)a2);
    if ( (v4[3] & 0x20) != 0 )
      sub_80DA424((int)v4, a2);
    if ( *((char *)a1 + 28) < 0 )
      BG_AnimScriptEvent(v4, 4, 0, 1);
    else
      BG_AnimScriptEvent(v4, 3, 0, 1);
    return 1;
  }
}
// 8576040: using guessed type int jump_height;

//----- (080DA70C) --------------------------------------------------------
long double __cdecl sub_80DA70C(float a1)
{
  return (float)sqrt(a1);
}

//----- (080DA72C) --------------------------------------------------------
float *__cdecl sub_80DA72C(float *a1, float a2, float *a3)
{
  float *result; // eax

  *a3 = a2 * *a1;
  result = a1 + 1;
  a3[1] = a2 * a1[1];
  return result;
}

//----- (080DA752) --------------------------------------------------------
int __cdecl sub_80DA752(_DWORD *a1, int a2, int a3, int a4)
{
  int result; // eax

  *a1 = a2;
  a1[1] = a3;
  result = a4;
  a1[2] = a4;
  return result;
}

//----- (080DA776) --------------------------------------------------------
int __cdecl sub_80DA776(_DWORD *a1, _DWORD *a2)
{
  int result; // eax

  *a2 = *a1;
  a2[1] = a1[1];
  result = a1[2];
  a2[2] = result;
  return result;
}

//----- (080DA7A6) --------------------------------------------------------
float *__cdecl sub_80DA7A6(float *a1, float a2, float *a3)
{
  float *result; // eax

  *a3 = a2 * *a1;
  a3[1] = a2 * a1[1];
  result = a1 + 2;
  a3[2] = a2 * a1[2];
  return result;
}

//----- (080DA7DE) --------------------------------------------------------
float *__cdecl sub_80DA7DE(float *a1, float a2, float *a3, float *a4)
{
  float *result; // eax

  *a4 = a2 * *a3 + *a1;
  a4[1] = a2 * a3[1] + a1[1];
  result = a3 + 2;
  a4[2] = a2 * a3[2] + a1[2];
  return result;
}

//----- (080DA832) --------------------------------------------------------
long double __cdecl sub_80DA832(float *a1, float *a2)
{
  return *a1 * *a2 + a1[1] * a2[1] + a1[2] * a2[2];
}

//----- (080DA868) --------------------------------------------------------
char *__usercall Mantle_RegisterDvars@<eax>(long double a1@<st0>)
{
  char *result; // eax

  mantle_enable = (int)Dvar_RegisterBool(a1, "mantle_enable", 1, 4480);
  mantle_debug = (int)Dvar_RegisterBool(a1, "mantle_debug", 0, 4480);
  mantle_check_range = (int)Dvar_RegisterFloat(a1, "mantle_check_range", (char *)0x41A00000, 0, 1124073472, 4480);
  mantle_check_radius = (int)Dvar_RegisterFloat(a1, "mantle_check_radius", (char *)0x3DCCCCCD, 0, 1097859072, 4480);
  mantle_check_angle = (int)Dvar_RegisterFloat(a1, "mantle_check_angle", (char *)0x42700000, 0, 1127481344, 4480);
  result = Dvar_RegisterFloat(a1, "mantle_view_yawcap", (char *)0x42700000, 0, 1127481344, 4480);
  mantle_view_yawcap = (int)result;
  return result;
}
// 8576054: using guessed type int mantle_enable;
// 8576058: using guessed type int mantle_debug;
// 857605C: using guessed type int mantle_check_range;
// 8576060: using guessed type int mantle_check_radius;
// 8576064: using guessed type int mantle_check_angle;
// 8576068: using guessed type int mantle_view_yawcap;

//----- (080DA9B8) --------------------------------------------------------
void *__cdecl sub_80DA9B8(size_t n)
{
  return Hunk_AllocAlignInternal(n, 4);
}

//----- (080DA9D4) --------------------------------------------------------
void __cdecl Mantle_DebugPrint(const char *a1)
{
  if ( *(_BYTE *)(mantle_debug + 8) )
    Com_Printf("%s\n", a1);
}
// 8576058: using guessed type int mantle_debug;

//----- (080DA9FC) --------------------------------------------------------
int __cdecl sub_80DA9FC(int a1)
{
  return sub_80BE794(dword_857606C, dword_8164860[3 * *(_DWORD *)(a1 + 8)]);
}
// 8164860: using guessed type int dword_8164860[];

//----- (080DAA36) --------------------------------------------------------
int __cdecl sub_80DAA36(int a1)
{
  if ( ((*(_BYTE *)(a1 + 12) ^ 1) & 1) != 0 )
    return 0;
  else
    return sub_80BE794(dword_857606C, dword_8164864[3 * *(_DWORD *)(a1 + 8)]);
}
// 8164864: using guessed type int dword_8164864[];

//----- (080DAA8E) --------------------------------------------------------
int __cdecl sub_80DAA8E(int a1)
{
  int v3; // [esp+14h] [ebp-4h]

  v3 = sub_80DA9FC(a1);
  sub_80DAA36(a1);
  if ( *(_DWORD *)(a1 + 4) > v3 )
    return dword_8164864[3 * *(_DWORD *)(a1 + 8)];
  else
    return dword_8164860[3 * *(_DWORD *)(a1 + 8)];
}
// 8164860: using guessed type int dword_8164860[];
// 8164864: using guessed type int dword_8164864[];

//----- (080DAAF2) --------------------------------------------------------
int __cdecl sub_80DAAF2(int a1, int a2, float *a3)
{
  float v4; // [esp+28h] [ebp-30h]
  float v5; // [esp+28h] [ebp-30h]
  int v6; // [esp+30h] [ebp-28h]
  int v7; // [esp+34h] [ebp-24h]
  int v8[2]; // [esp+38h] [ebp-20h] BYREF
  int v9[6]; // [esp+40h] [ebp-18h] BYREF

  v7 = sub_80DA9FC(a1);
  v6 = sub_80DAA36(a1);
  if ( a2 > v7 )
  {
    v5 = (long double)(a2 - v7) / (long double)v6;
    sub_80BF1A4(dword_857606C, dword_8164860[3 * *(_DWORD *)(a1 + 8)], v8, v9, 1.0);
    sub_80BF1A4(dword_857606C, dword_8164864[3 * *(_DWORD *)(a1 + 8)], v8, a3, v5);
    sub_80DBFC2(a3, (float *)v9, a3);
  }
  else
  {
    v4 = (long double)a2 / (long double)v7;
    sub_80BF1A4(dword_857606C, dword_8164860[3 * *(_DWORD *)(a1 + 8)], v8, a3, v4);
  }
  return sub_80A530C(a3, *(float *)a1);
}
// 8164860: using guessed type int dword_8164860[];
// 8164864: using guessed type int dword_8164864[];

//----- (080DAC38) --------------------------------------------------------
int __cdecl sub_80DAC38(float a1, float a2)
{
  float v3; // [esp+0h] [ebp-18h]
  float v4; // [esp+0h] [ebp-18h]
  int v5; // [esp+4h] [ebp-14h]
  int i; // [esp+8h] [ebp-10h]
  float v7; // [esp+Ch] [ebp-Ch]
  float v8; // [esp+10h] [ebp-8h]
  float v9; // [esp+14h] [ebp-4h]

  v9 = a2 - a1;
  v5 = 0;
  v3 = flt_8164868[0] - v9;
  v7 = sub_80DBF16(v3);
  for ( i = 1; i <= 6; ++i )
  {
    v4 = flt_8164868[3 * i] - v9;
    v8 = sub_80DBF16(v4);
    if ( v7 > (long double)v8 )
    {
      v5 = i;
      v7 = v8;
    }
  }
  return v5;
}
// 8164868: using guessed type float flt_8164868[22];

//----- (080DACB8) --------------------------------------------------------
int __cdecl sub_80DACB8(int **a1, int a2)
{
  int result; // eax
  int *v3; // [esp+2Ch] [ebp-7Ch]
  int v4[4]; // [esp+30h] [ebp-78h] BYREF
  int v5[4]; // [esp+40h] [ebp-68h] BYREF
  int v6[2]; // [esp+50h] [ebp-58h] BYREF
  float v7; // [esp+58h] [ebp-50h]
  int v8[2]; // [esp+60h] [ebp-48h] BYREF
  float v9; // [esp+68h] [ebp-40h]
  float s[8]; // [esp+70h] [ebp-38h] BYREF
  char v11; // [esp+93h] [ebp-15h]

  v3 = *a1;
  if ( ((*(_BYTE *)(a2 + 48) ^ 1) & 1) != 0 )
    return sub_80DBF54((_DWORD *)(a2 + 24), (_DWORD *)(a2 + 36));
  sub_80DBF54(v3 + 347, v5);
  sub_80DBF54(v3 + 350, v4);
  v4[2] = 1112014848;
  sub_80DBF54((_DWORD *)(a2 + 24), v8);
  sub_80DC082((float *)v8, 31.0, (float *)a2, (float *)v8);
  sub_80DBF54(v8, v6);
  v7 = v7 - 18.0;
  sub_80DEBE4((int)a1, s, (int)v8, (int)v5, (int)v4, (int)v6, v3[51], (int)a1[15]);
  if ( v11 || s[0] < 1.0 )
  {
    *(_DWORD *)(a2 + 48) &= ~1u;
    return sub_80DBF54((_DWORD *)(a2 + 24), (_DWORD *)(a2 + 36));
  }
  else
  {
    sub_80DBF54(v6, (_DWORD *)(a2 + 36));
    result = a2;
    *(float *)(a2 + 44) = (v7 - v9) * s[0] + v9;
  }
  return result;
}
// 80DACB8: using guessed type float s[8];

//----- (080DAE2E) --------------------------------------------------------
int __cdecl sub_80DAE2E(int a1, int a2, int a3)
{
  int v3; // ebx
  int result; // eax
  int v5; // [esp+1Ch] [ebp-2Ch]
  float v6[7]; // [esp+20h] [ebp-28h] BYREF
  _DWORD *v7; // [esp+3Ch] [ebp-Ch]

  v7 = (_DWORD *)(a2 + 1468);
  *(float *)(a2 + 1468) = sub_80A29F6((float *)a3);
  v7[1] = 0;
  v7[2] = sub_80DAC38(*(float *)(a3 + 20), *(float *)(a3 + 32));
  v7[3] = *(_DWORD *)(a3 + 48);
  v3 = sub_80DA9FC((int)v7);
  v5 = sub_80DAA36((int)v7) + v3;
  sub_80DAAF2((int)v7, v5, v6);
  sub_80DC006((float *)(a3 + 36), v6, (float *)(a2 + 20));
  *(_DWORD *)(a2 + 12) |= 4u;
  *(_DWORD *)(a2 + 160) |= 0x4000u;
  sub_80DBF54((_DWORD *)(a3 + 36), (_DWORD *)(a1 + 232));
  *(_DWORD *)(a1 + 244) = v5;
  result = a1;
  *(_BYTE *)(a1 + 229) = 1;
  return result;
}
// 80DAE2E: using guessed type float var_28[7];

//----- (080DAF36) --------------------------------------------------------
int __cdecl sub_80DAF36(int *a1, int a2, int a3, float a4)
{
  char *v4; // eax
  int v6; // [esp+Ch] [ebp-ACh]
  _DWORD *v8; // [esp+2Ch] [ebp-8Ch]
  int v9[4]; // [esp+30h] [ebp-88h] BYREF
  int v10[4]; // [esp+40h] [ebp-78h] BYREF
  int v11[2]; // [esp+50h] [ebp-68h] BYREF
  float v12; // [esp+58h] [ebp-60h]
  int v13[2]; // [esp+60h] [ebp-58h] BYREF
  float v14; // [esp+68h] [ebp-50h]
  float s[8]; // [esp+70h] [ebp-48h] BYREF
  char v16; // [esp+93h] [ebp-25h]
  int v17; // [esp+ACh] [ebp-Ch]

  v8 = (_DWORD *)*a1;
  v17 = *(int *)(*a1 + 1400);
  v4 = va("Checking for ledge at %f units", a4);
  Mantle_DebugPrint(v4);
  sub_80DBF30(v10, v17 ^ 0x80000000, v17 ^ 0x80000000, 0);
  *(float *)&v6 = *(float *)&v17 + *(float *)&v17;
  sub_80DBF30(v9, v17, v17, v6);
  sub_80DBF54((_DWORD *)(a3 + 12), v13);
  v14 = v14 + a4;
  sub_80DC082((float *)v13, 16.0, (float *)a3, (float *)v11);
  sub_80DEBE4((int)a1, s, (int)v13, (int)v10, (int)v9, (int)v11, v8[51], a1[15]);
  if ( v16 || s[0] < 1.0 )
  {
    Mantle_DebugPrint("Mantle Failed: Ledge is too far away");
    return 0;
  }
  else
  {
    sub_80DBF54(v11, v13);
    v12 = *(float *)(a3 + 20) + 18.0;
    sub_80DEBE4((int)a1, s, (int)v13, (int)v10, (int)v9, (int)v11, v8[51], a1[15]);
    if ( v16 || s[0] == 1.0 )
    {
      Mantle_DebugPrint("Mantle Failed: Can't find ledge");
      return 0;
    }
    else if ( s[3] >= 0.69999999 )
    {
      sub_80DBF54(v11, (_DWORD *)(a3 + 24));
      *(float *)(a3 + 32) = (v12 - v14) * s[0] + v14;
      v9[2] = 1112014848;
      sub_80DEBE4((int)a1, s, a3 + 24, (int)v10, (int)v9, a3 + 24, v8[51], a1[15]);
      if ( v16 )
      {
        Mantle_DebugPrint("Mantle Failed: Player can't fit crouched on ledge");
        return 0;
      }
      else
      {
        v8[370] |= 8u;
        *(_DWORD *)(a3 + 48) |= 8u;
        Mantle_DebugPrint("Mantle available!");
        if ( (a1[2] & 0x400) != 0 )
        {
          sub_80DACB8((int **)a1, a3);
          if ( (v8[40] & 4) == 0 )
          {
            sub_80DEBE4((int)a1, s, a3 + 24, (int)(v8 + 347), (int)(v8 + 350), a3 + 24, v8[51], a1[15]);
            if ( v16 )
              *(_DWORD *)(a3 + 48) |= 2u;
            sub_80DEBE4((int)a1, s, a3 + 36, (int)(v8 + 347), (int)(v8 + 350), a3 + 36, v8[51], a1[15]);
            if ( !v16 )
              *(_DWORD *)(a3 + 48) |= 4u;
          }
          sub_80DAE2E((int)a1, (int)v8, a3);
          return 1;
        }
        else
        {
          return 1;
        }
      }
    }
    else
    {
      Mantle_DebugPrint("Mantle Failed: Ledge is too steep");
      return 0;
    }
  }
}

//----- (080DB380) --------------------------------------------------------
void __cdecl sub_80DB380(int (__cdecl *a1)(int))
{
  float v1; // [esp+0h] [ebp-58h]
  float v2; // [esp+0h] [ebp-58h]
  float v3; // [esp+0h] [ebp-58h]
  float v4; // [esp+0h] [ebp-58h]
  int j; // [esp+28h] [ebp-30h]
  int i; // [esp+2Ch] [ebp-2Ch]
  int v7; // [esp+2Ch] [ebp-2Ch]
  int v8; // [esp+2Ch] [ebp-2Ch]
  int v9[4]; // [esp+30h] [ebp-28h] BYREF
  int v10; // [esp+40h] [ebp-18h] BYREF
  float v11; // [esp+44h] [ebp-14h]
  float v12; // [esp+48h] [ebp-10h]

  if ( !dword_857606C )
  {
    dword_857606C = (int)sub_80BA626("PLAYER_MANTLE", 11, a1);
    sub_80BA57A(dword_857606C, 0, off_81648C0, 1, 0xAu, 0);
    for ( i = 1; i <= 10; ++i )
    {
      sub_80BA3AE((&off_81648C0)[i], (int (__cdecl *)(int))sub_80DA9B8);
      sub_80BA4D8(dword_857606C, i, (&off_81648C0)[i]);
    }
    for ( j = 0; j <= 6; ++j )
    {
      v7 = dword_8164860[3 * j];
      sub_80BF1A4(dword_857606C, v7, v9, &v10, 1.0);
      v1 = *(float *)&v10 - 16.0;
      if ( sub_80DBF16(v1) > 1.0 )
        Com_Error(
          1,
          "Mantle anim [%s] has X translation %f, should be %f\n",
          (&off_81648C0)[v7],
          *(float *)&v10,
          (double)16.0);
      if ( sub_80DBF16(v11) > 1.0 )
        Com_Error(1, "Mantle anim [%s] has Y translation %f, should be %f\n", (&off_81648C0)[v7], v11, (double)0.0);
      v2 = v12 - flt_8164868[3 * j];
      if ( sub_80DBF16(v2) > 1.0 )
        Com_Error(
          1,
          "Mantle anim [%s] has Z translation %f, should be %f\n",
          (&off_81648C0)[v7],
          v12,
          flt_8164868[3 * j]);
      v8 = dword_8164864[3 * j];
      sub_80BF1A4(dword_857606C, v8, v9, &v10, 1.0);
      v3 = *(float *)&v10 - 31.0;
      if ( sub_80DBF16(v3) > 1.0 )
        Com_Error(
          1,
          "Mantle anim [%s] has X translation %f, should be %f\n",
          (&off_81648C0)[v8],
          *(float *)&v10,
          (double)31.0);
      if ( sub_80DBF16(v11) > 1.0 )
        Com_Error(1, "Mantle anim [%s] has Y translation %f, should be %f\n", (&off_81648C0)[v8], v11, (double)0.0);
      v4 = v12 - -18.0;
      if ( sub_80DBF16(v4) > 1.0 )
        Com_Error(1, "Mantle anim [%s] has Z translation %f, should be %f\n", (&off_81648C0)[v8], v12, (double)-18.0);
    }
  }
}
// 8164860: using guessed type int dword_8164860[];
// 8164864: using guessed type int dword_8164864[];
// 8164868: using guessed type float flt_8164868[22];

//----- (080DB6CA) --------------------------------------------------------
void sub_80DB6CA()
{
  dword_857606C = 0;
}

//----- (080DB6DA) --------------------------------------------------------
int __cdecl sub_80DB6DA(int *a1, _DWORD *a2, float *s, unsigned int *a4)
{
  int v6; // [esp+2Ch] [ebp-7Ch]
  float v7; // [esp+30h] [ebp-78h]
  float v8; // [esp+34h] [ebp-74h]
  float v9; // [esp+38h] [ebp-70h]
  float v10; // [esp+3Ch] [ebp-6Ch]
  int v11[4]; // [esp+40h] [ebp-68h] BYREF
  int v12[4]; // [esp+50h] [ebp-58h] BYREF
  int v13[4]; // [esp+60h] [ebp-48h] BYREF
  int v14[4]; // [esp+70h] [ebp-38h] BYREF
  int v15[7]; // [esp+80h] [ebp-28h] BYREF
  float v16; // [esp+9Ch] [ebp-Ch]

  v6 = *a1;
  v16 = *(float *)(*a1 + 1400);
  sub_80DBF30(
    v15,
    *(_DWORD *)(mantle_check_radius + 8) ^ 0x80000000,
    *(_DWORD *)(mantle_check_radius + 8) ^ 0x80000000,
    *(_DWORD *)(v6 + 1396));
  sub_80DBF30(v14, *(_DWORD *)(mantle_check_radius + 8), *(_DWORD *)(mantle_check_radius + 8), *(_DWORD *)(v6 + 1408));
  v9 = v16 - *(float *)(mantle_check_radius + 8);
  v10 = *(float *)(mantle_check_range + 8) + v9;
  sub_80DBF54(a2, v11);
  v11[2] = 0;
  Vec3Normalize((float *)v11);
  sub_80DC082((float *)(v6 + 20), COERCE_FLOAT(LODWORD(v9) ^ 0x80000000), (float *)v11, (float *)v13);
  sub_80DC082((float *)(v6 + 20), v10, (float *)v11, (float *)v12);
  sub_80DEBE4((int)a1, s, (int)v13, (int)v15, (int)v14, (int)v12, *(_DWORD *)(v6 + 204), 0x1000000);
  if ( *((_BYTE *)s + 35) || *((_BYTE *)s + 34) )
  {
    Mantle_DebugPrint("Mantle Failed: Mantle brush is too thick");
    return 0;
  }
  else if ( *s == 1.0 )
  {
    Mantle_DebugPrint("Mantle Failed: No mantle surface found");
    return 0;
  }
  else if ( ((_DWORD)s[4] & 0x6000000) != 0 )
  {
    sub_80DBF84((_DWORD *)s + 1, a4);
    a4[2] = 0;
    v7 = Vec3Normalize((float *)a4);
    if ( v7 >= 0.000099999997 )
    {
      v8 = sub_80DC0D6((float *)v11, (float *)a4);
      if ( acos(v8) * 57.29577951308232 <= *(float *)(mantle_check_angle + 8) )
      {
        return 1;
      }
      else
      {
        Mantle_DebugPrint("Mantle Failed: Player is not facing mantle surface");
        return 0;
      }
    }
    else
    {
      Mantle_DebugPrint("Mantle Failed: Mantle surface has vertical normal");
      return 0;
    }
  }
  else
  {
    Mantle_DebugPrint("Mantle Failed: No mantle surface with MANTLE_ON or MANTLE_OVER found");
    return 0;
  }
}
// 857605C: using guessed type int mantle_check_range;
// 8576060: using guessed type int mantle_check_radius;
// 8576064: using guessed type int mantle_check_angle;

//----- (080DB964) --------------------------------------------------------
void __cdecl Mantle_Check(int *a1, _DWORD *a2)
{
  int *v2; // [esp+1Ch] [ebp-8Ch]
  int v3[4]; // [esp+20h] [ebp-88h] BYREF
  float v4[12]; // [esp+30h] [ebp-78h] BYREF
  _DWORD s[3]; // [esp+60h] [ebp-48h] BYREF
  int v6[9]; // [esp+6Ch] [ebp-3Ch] BYREF
  int v7; // [esp+90h] [ebp-18h]

  Mantle_DebugPrint("====== Mantle Debug ======");
  if ( *(_BYTE *)(mantle_enable + 8) )
  {
    v2 = (int *)*a1;
    sub_80DBE96(*a1);
    if ( v2[1] <= 5 )
    {
      if ( (v2[3] & 4) != 0 )
      {
        Mantle_DebugPrint("Mantle Failed: Player already mantling");
      }
      else if ( (v2[40] & 0xC) != 0 )
      {
        Mantle_DebugPrint("Mantle Failed: Player not standing");
      }
      else if ( v2[54] <= 16 || v2[54] > 22 )
      {
        if ( (unsigned __int8)sub_80DB6DA(a1, a2, v4, (unsigned int *)v3) )
        {
          memset(s, 0, 0x38u);
          sub_80DBF54(v3, s);
          sub_80DBF54(v2 + 5, v6);
          if ( (LODWORD(v4[4]) & 0x4000000) != 0 )
            v7 |= 1u;
          if ( !(unsigned __int8)sub_80DAF36(a1, (int)a2, (int)s, 60.0)
            && !(unsigned __int8)sub_80DAF36(a1, (int)a2, (int)s, 40.0) )
          {
            sub_80DAF36(a1, (int)a2, (int)s, 20.0);
          }
        }
      }
      else
      {
        Mantle_DebugPrint("Mantle Failed: Player using binoculars");
      }
    }
    else
    {
      Mantle_DebugPrint("Mantle Failed: Player is dead");
    }
  }
  else
  {
    Mantle_DebugPrint("Mantle Failed: Not enabled");
  }
}
// 8576054: using guessed type int mantle_enable;
// 80DB964: using guessed type _DWORD s[3];
// 80DB964: using guessed type int anonymous_0[9];

//----- (080DBB3C) --------------------------------------------------------
int __cdecl sub_80DBB3C(int a1, int a2, int a3)
{
  int result; // eax
  int v4; // ebx
  float v5; // [esp+4h] [ebp-54h]
  int v6; // [esp+10h] [ebp-48h]
  int v7; // [esp+14h] [ebp-44h]
  int v8; // [esp+18h] [ebp-40h]
  int v9; // [esp+1Ch] [ebp-3Ch]
  float v10[4]; // [esp+20h] [ebp-38h] BYREF
  int v11[7]; // [esp+30h] [ebp-28h] BYREF
  int v12; // [esp+4Ch] [ebp-Ch]

  result = mantle_enable;
  if ( *(_BYTE *)(mantle_enable + 8) )
  {
    v12 = a2 + 1468;
    *(_DWORD *)(a2 + 1480) &= ~8u;
    if ( (*(_DWORD *)(v12 + 12) & 2) != 0 )
      BG_AddPredictableEventToPlayerstate(141, 0, a2);
    v4 = sub_80DA9FC(v12);
    v7 = sub_80DAA36(v12) + v4;
    v9 = *(_DWORD *)(v12 + 4);
    *(_DWORD *)(v12 + 4) = v9 + *(_DWORD *)(a3 + 40);
    if ( *(_DWORD *)(v12 + 4) > v7 )
      *(_DWORD *)(v12 + 4) = v7;
    v8 = *(_DWORD *)(v12 + 4) - v9;
    sub_80DAAF2(v12, v9, v10);
    sub_80DAAF2(v12, *(_DWORD *)(v12 + 4), (float *)v11);
    v6 = sub_80DAA8E(v12);
    sub_80D6D82((_DWORD *)a2, 3, v6 + 20, 1);
    sub_80DC006((float *)v11, v10, (float *)v11);
    sub_80DBFC2((float *)v11, (float *)(a2 + 20), (float *)(a2 + 20));
    v5 = 1.0 / ((long double)v8 * 0.001);
    sub_80DC04A((float *)v11, v5, (float *)(a2 + 32));
    result = *(_DWORD *)(v12 + 4);
    if ( result == v7 )
    {
      *(_DWORD *)(a2 + 12) &= ~4u;
      *(_BYTE *)(a1 + 229) = 0;
      if ( (*(_BYTE *)(v12 + 12) & 1) != 0 )
        BG_AnimScriptEvent((_DWORD *)a2, 3, 0, 1);
      result = *(_DWORD *)(v12 + 12) & 4;
      if ( result )
      {
        BG_AddPredictableEventToPlayerstate(140, 0, a2);
        result = *(_DWORD *)(a2 + 160) & 0xFFFFBFFF;
        *(_DWORD *)(a2 + 160) = result;
      }
    }
  }
  return result;
}
// 8576054: using guessed type int mantle_enable;
// 80DBB3C: using guessed type float var_38[4];

//----- (080DBD56) --------------------------------------------------------
void __usercall sub_80DBD56(long double a1@<st0>, int a2)
{
  float v2; // [esp+0h] [ebp-28h]
  float v3; // [esp+10h] [ebp-18h]
  float v4; // [esp+20h] [ebp-8h]

  if ( *(_BYTE *)(mantle_enable + 8) )
  {
    sub_80A6258(*(float *)(a2 + 1468), *(float *)(a2 + 236));
    v4 = a1;
    if ( v4 < -*(float *)(mantle_view_yawcap + 8) || *(float *)(mantle_view_yawcap + 8) < (long double)v4 )
    {
      while ( -*(float *)(mantle_view_yawcap + 8) > (long double)v4 )
        v4 = v4 + *(float *)(mantle_view_yawcap + 8);
      while ( v4 > (long double)*(float *)(mantle_view_yawcap + 8) )
        v4 = v4 - *(float *)(mantle_view_yawcap + 8);
      v3 = *(float *)(mantle_view_yawcap + 8);
      if ( v4 > 0.0 )
        HIBYTE(v3) ^= 0x80u;
      *(_DWORD *)(a2 + 88) += (unsigned __int16)(int)(v4 * 182.04445);
      v2 = *(float *)(a2 + 1468) + v3;
      *(float *)(a2 + 236) = sub_80A6154(v2);
    }
  }
}
// 8576054: using guessed type int mantle_enable;
// 8576068: using guessed type int mantle_view_yawcap;

//----- (080DBE96) --------------------------------------------------------
int __cdecl sub_80DBE96(int a1)
{
  int result; // eax

  result = a1;
  *(_DWORD *)(a1 + 1480) &= ~8u;
  return result;
}

//----- (080DBEB0) --------------------------------------------------------
_BOOL4 __cdecl sub_80DBEB0(int a1)
{
  if ( !*(_BYTE *)(mantle_enable + 8) )
    return 0;
  if ( (*(_DWORD *)(a1 + 12) & 4) != 0 )
    return dword_8164864[3 * *(_DWORD *)(a1 + 1476)] != 10;
  return 0;
}
// 8164864: using guessed type int dword_8164864[];
// 8576054: using guessed type int mantle_enable;

//----- (080DBF16) --------------------------------------------------------
long double __cdecl sub_80DBF16(float a1)
{
  return (float)fabs(a1);
}

//----- (080DBF30) --------------------------------------------------------
int __cdecl sub_80DBF30(_DWORD *a1, int a2, int a3, int a4)
{
  int result; // eax

  *a1 = a2;
  a1[1] = a3;
  result = a4;
  a1[2] = a4;
  return result;
}

//----- (080DBF54) --------------------------------------------------------
int __cdecl sub_80DBF54(_DWORD *a1, _DWORD *a2)
{
  int result; // eax

  *a2 = *a1;
  a2[1] = a1[1];
  result = a1[2];
  a2[2] = result;
  return result;
}

//----- (080DBF84) --------------------------------------------------------
unsigned int __cdecl sub_80DBF84(_DWORD *a1, unsigned int *a2)
{
  unsigned int result; // eax

  *a2 = *a1 ^ 0x80000000;
  a2[1] = a1[1] ^ 0x80000000;
  result = a1[2] ^ 0x80000000;
  a2[2] = result;
  return result;
}

//----- (080DBFC2) --------------------------------------------------------
float *__cdecl sub_80DBFC2(float *a1, float *a2, float *a3)
{
  float *result; // eax

  *a3 = *a1 + *a2;
  a3[1] = a1[1] + a2[1];
  result = a1 + 2;
  a3[2] = a1[2] + a2[2];
  return result;
}

//----- (080DC006) --------------------------------------------------------
float *__cdecl sub_80DC006(float *a1, float *a2, float *a3)
{
  float *result; // eax

  *a3 = *a1 - *a2;
  a3[1] = a1[1] - a2[1];
  result = a1 + 2;
  a3[2] = a1[2] - a2[2];
  return result;
}

//----- (080DC04A) --------------------------------------------------------
float *__cdecl sub_80DC04A(float *a1, float a2, float *a3)
{
  float *result; // eax

  *a3 = a2 * *a1;
  a3[1] = a2 * a1[1];
  result = a1 + 2;
  a3[2] = a2 * a1[2];
  return result;
}

//----- (080DC082) --------------------------------------------------------
float *__cdecl sub_80DC082(float *a1, float a2, float *a3, float *a4)
{
  float *result; // eax

  *a4 = a2 * *a3 + *a1;
  a4[1] = a2 * a3[1] + a1[1];
  result = a3 + 2;
  a4[2] = a2 * a3[2] + a1[2];
  return result;
}

//----- (080DC0D6) --------------------------------------------------------
long double __cdecl sub_80DC0D6(float *a1, float *a2)
{
  return *a1 * *a2 + a1[1] * a2[1] + a1[2] * a2[2];
}

//----- (080DC10C) --------------------------------------------------------
char *__usercall BG_RegisterDvars@<eax>(long double a1@<st0>)
{
  player_view_pitch_up = (int)Dvar_RegisterFloat(a1, "player_view_pitch_up", (char *)0x42AA0000, 0, 1119092736, 4480);
  player_view_pitch_down = (int)Dvar_RegisterFloat(a1, "player_view_pitch_down", (char *)0x42AA0000, 0, 1119092736, 4480);
  bg_ladder_yawcap = (int)Dvar_RegisterFloat(a1, "bg_ladder_yawcap", (char *)0x42C80000, 0, 1135869952, 4480);
  bg_prone_yawcap = (int)Dvar_RegisterFloat(a1, "bg_prone_yawcap", (char *)0x42AA0000, 0, 1135869952, 4480);
  bg_foliagesnd_minspeed = (int)Dvar_RegisterFloat(a1, "bg_foliagesnd_minspeed", (char *)0x42200000, 0, 2139095039, 4480);
  bg_foliagesnd_maxspeed = (int)Dvar_RegisterFloat(a1, "bg_foliagesnd_maxspeed", (char *)0x43340000, 0, 2139095039, 4480);
  bg_foliagesnd_slowinterval = (int)Dvar_RegisterInt(a1, "bg_foliagesnd_slowinterval", (char *)0x5DC, 0, 0x7FFFFFFF, 4480);
  bg_foliagesnd_fastinterval = (int)Dvar_RegisterInt(a1, "bg_foliagesnd_fastinterval", (char *)0x1F4, 0, 0x7FFFFFFF, 4480);
  bg_foliagesnd_resetinterval = (int)Dvar_RegisterInt(a1, "bg_foliagesnd_resetinterval", (char *)0x1F4, 0, 0x7FFFFFFF, 4480);
  bg_fallDamageMinHeight = (int)Dvar_RegisterFloat(a1, "bg_fallDamageMinHeight", (char *)0x43800000, 1065353216, 2139095039, 4488);
  bg_fallDamageMaxHeight = (int)Dvar_RegisterFloat(a1, "bg_fallDamageMaxHeight", (char *)0x43F00000, 1065353216, 2139095039, 4488);
  inertiaMax = (int)Dvar_RegisterFloat(a1, "inertiaMax", (char *)0x42480000, 0, 1148846080, 4480);
  inertiaDebug = (int)Dvar_RegisterBool(a1, "inertiaDebug", 0, 4480);
  inertiaAngle = (int)Dvar_RegisterFloat(a1, "inertiaAngle", 0, -1082130432, 1065353216, 4480);
  friction = (int)Dvar_RegisterFloat(a1, "friction", (char *)0x40B00000, 0, 1120403456, 4480);
  stopspeed = (int)Dvar_RegisterFloat(a1, "stopspeed", (char *)0x42C80000, 0, 1148846080, 4480);
  bg_swingSpeed = (int)Dvar_RegisterFloat(a1, "bg_swingSpeed", (char *)0x3E4CCCCD, 0, 1065353216, 4224);
  bg_bobAmplitudeStanding = (int)Dvar_RegisterFloat(a1, "bg_bobAmplitudeStanding", (char *)0x3BE56042, 0, 1065353216, 4480);
  bg_bobAmplitudeDucked = (int)Dvar_RegisterFloat(a1, "bg_bobAmplitudeDucked", (char *)0x3BF5C28F, 0, 1065353216, 4480);
  bg_bobAmplitudeProne = (int)Dvar_RegisterFloat(a1, "bg_bobAmplitudeProne", (char *)0x3CF5C28F, 0, 1065353216, 4480);
  bg_bobMax = (int)Dvar_RegisterFloat(a1, "bg_bobMax", (char *)0x41000000, 0, 1108344832, 4480);
  bg_aimSpreadMoveSpeedThreshold = (int)Dvar_RegisterFloat(a1, "bg_aimSpreadMoveSpeedThreshold", (char *)0x41300000, 0, 1133903872, 4480);
  player_breath_hold_time = (int)Dvar_RegisterFloat(a1, "player_breath_hold_time", (char *)0x40900000, 0, 1106247680, 4480);
  player_breath_gasp_time = (int)Dvar_RegisterFloat(a1, "player_breath_gasp_time", (char *)0x3F800000, 0, 1106247680, 4480);
  player_breath_fire_delay = (int)Dvar_RegisterFloat(a1, "player_breath_fire_delay", 0, 0, 1106247680, 4480);
  player_breath_gasp_scale = (int)Dvar_RegisterFloat(a1, "player_breath_gasp_scale", (char *)0x40900000, 0, 1112014848, 4480);
  player_breath_hold_lerp = (int)Dvar_RegisterFloat(a1, "player_breath_hold_lerp", (char *)0x40800000, 0, 1112014848, 4480);
  player_breath_gasp_lerp = (int)Dvar_RegisterFloat(a1, "player_breath_gasp_lerp", (char *)0x40C00000, 0, 1112014848, 4480);
  player_breath_snd_lerp = (int)Dvar_RegisterFloat(a1, "player_breath_snd_lerp", (char *)0x40000000, 0, 1120403456, 4480);
  player_breath_snd_delay = (int)Dvar_RegisterFloat(a1, "player_breath_snd_delay", (char *)0x3F800000, 0, 0x40000000, 4480);
  player_toggleBinoculars = (int)Dvar_RegisterBool(a1, "player_toggleBinoculars", 1, 4352);
  player_scopeExitOnDamage = (int)Dvar_RegisterBool(a1, "player_scopeExitOnDamage", 0, 4480);
  player_adsExitDelay = (int)Dvar_RegisterInt(a1, "player_adsExitDelay", 0, 0, 1000, 4480);
  player_moveThreshhold = (int)Dvar_RegisterFloat(a1, "player_moveThreshhold", (char *)0x41200000, 841731191, 1101004800, 4544);
  player_footstepsThreshhold = (int)Dvar_RegisterFloat(a1, "player_footstepsThreshhold", 0, 0, 1195593728, 4544);
  player_strafeSpeedScale = (int)Dvar_RegisterFloat(a1, "player_strafeSpeedScale", (char *)0x3F4CCCCD, 0, 1101004800, 4480);
  player_backSpeedScale = (int)Dvar_RegisterFloat(a1, "player_backSpeedScale", (char *)0x3F333333, 0, 1101004800, 4480);
  player_spectateSpeedScale = (int)Dvar_RegisterFloat(a1, "player_spectateSpeedScale", (char *)0x40000000, 0, 1101004800, 4480);
  player_turnAnims = (int)Dvar_RegisterBool(a1, "player_turnAnims", 0, 4480);
  player_dmgtimer_timePerPoint = (int)Dvar_RegisterFloat(a1, "player_dmgtimer_timePerPoint", (char *)0x42C80000, 0, 2139095039, 4480);
  player_dmgtimer_maxTime = (int)Dvar_RegisterFloat(a1, "player_dmgtimer_maxTime", (char *)0x443B8000, 0, 2139095039, 4480);
  player_dmgtimer_minScale = (int)Dvar_RegisterFloat(a1, "player_dmgtimer_minScale", 0, 0, 1065353216, 4480);
  player_dmgtimer_stumbleTime = (int)Dvar_RegisterInt(a1, "player_dmgtimer_stumbleTime", (char *)0x1F4, 0, 2000, 4480);
  player_dmgtimer_flinchTime = (int)Dvar_RegisterInt(a1, "player_dmgtimer_flinchTime", (char *)0x1F4, 0, 2000, 4480);
  Jump_RegisterDvars(a1);
  return Mantle_RegisterDvars(a1);
}
// 8576074: using guessed type int player_view_pitch_up;
// 8576078: using guessed type int player_view_pitch_down;
// 857607C: using guessed type int bg_ladder_yawcap;
// 8576080: using guessed type int bg_prone_yawcap;
// 8576084: using guessed type int bg_foliagesnd_minspeed;
// 8576088: using guessed type int bg_foliagesnd_maxspeed;
// 857608C: using guessed type int bg_foliagesnd_slowinterval;
// 8576090: using guessed type int bg_foliagesnd_fastinterval;
// 8576094: using guessed type int bg_foliagesnd_resetinterval;
// 8576098: using guessed type int bg_fallDamageMinHeight;
// 857609C: using guessed type int bg_fallDamageMaxHeight;
// 85760A0: using guessed type int inertiaMax;
// 85760A4: using guessed type int inertiaDebug;
// 85760A8: using guessed type int inertiaAngle;
// 85760AC: using guessed type int stopspeed;
// 85760B0: using guessed type int friction;
// 85760B4: using guessed type int bg_swingSpeed;
// 85760B8: using guessed type int bg_bobAmplitudeStanding;
// 85760BC: using guessed type int bg_bobAmplitudeDucked;
// 85760C0: using guessed type int bg_bobAmplitudeProne;
// 85760C4: using guessed type int bg_bobMax;
// 85760C8: using guessed type int bg_aimSpreadMoveSpeedThreshold;
// 85760CC: using guessed type int player_breath_hold_time;
// 85760D0: using guessed type int player_breath_gasp_time;
// 85760D4: using guessed type int player_breath_fire_delay;
// 85760D8: using guessed type int player_breath_gasp_scale;
// 85760DC: using guessed type int player_breath_hold_lerp;
// 85760E0: using guessed type int player_breath_gasp_lerp;
// 85760E4: using guessed type int player_breath_snd_lerp;
// 85760E8: using guessed type int player_breath_snd_delay;
// 85760EC: using guessed type int player_toggleBinoculars;
// 85760F0: using guessed type int player_scopeExitOnDamage;
// 85760F4: using guessed type int player_adsExitDelay;
// 85760F8: using guessed type int player_moveThreshhold;
// 85760FC: using guessed type int player_footstepsThreshhold;
// 8576100: using guessed type int player_strafeSpeedScale;
// 8576104: using guessed type int player_backSpeedScale;
// 8576108: using guessed type int player_spectateSpeedScale;
// 857610C: using guessed type int player_turnAnims;
// 8576110: using guessed type int player_dmgtimer_timePerPoint;
// 8576114: using guessed type int player_dmgtimer_maxTime;
// 8576118: using guessed type int player_dmgtimer_minScale;
// 857611C: using guessed type int player_dmgtimer_stumbleTime;
// 8576120: using guessed type int player_dmgtimer_flinchTime;

//----- (080DCAE6) --------------------------------------------------------
int __cdecl BG_FindItemForWeapon(int a1)
{
  return 44 * a1 + 135679008;
}

//----- (080DCB02) --------------------------------------------------------
char *__cdecl sub_80DCB02(char *s1)
{
  int i; // [esp+14h] [ebp-4h]
  int v4; // [esp+14h] [ebp-4h]

  for ( i = 129; i < 131; ++i )
  {
    if ( !I_stricmp(*((char **)&unk_8164C20 + 11 * i + 5), s1) || !I_stricmp(*((char **)&unk_8164C20 + 11 * i), s1) )
      return (char *)&unk_8164C20 + 44 * i;
  }
  v4 = G_GetWeaponIndexForName(s1);
  if ( v4 )
    return (char *)(44 * v4 + 135679008);
  else
    return 0;
}

//----- (080DCBB6) --------------------------------------------------------
_BOOL4 __cdecl sub_80DCBB6(float *a1, int a2, int a3)
{
  float v5; // [esp+20h] [ebp-18h] BYREF
  float v6; // [esp+24h] [ebp-14h]
  float v7; // [esp+28h] [ebp-10h]

  BG_EvaluateTrajectory(a2 + 12, a3, (int)&v5);
  return a1[5] - v5 <= 36.0
      && a1[5] - v5 >= -36.0
      && a1[6] - v6 <= 36.0
      && a1[6] - v6 >= -36.0
      && a1[7] - v7 <= 18.0
      && a1[7] - v7 >= -88.0;
}

//----- (080DCC7A) --------------------------------------------------------
_BOOL4 __cdecl sub_80DCC7A(_DWORD *a1, _DWORD *a2, int a3)
{
  char *v3; // eax
  int v5; // [esp+Ch] [ebp-Ch]
  char *v7; // [esp+14h] [ebp-4h]

  if ( (int)a1[35] <= 0 || (int)a1[35] >= 131 )
  {
    v3 = va((char *)&byte_814DB20, a1[35], a1[1]);
    Com_Error(1, v3);
  }
  v7 = (char *)&unk_8164C20 + 44 * a1[35];
  if ( a1[36] != a2[51] )
  {
    v5 = *((_DWORD *)v7 + 7);
    if ( v5 != 1 )
    {
      if ( v5 > 1 )
      {
        if ( v5 == 2 )
        {
          if ( (unsigned __int8)sub_80D9E84((int)(a2 + 337), *((_DWORD *)v7 + 8)) )
          {
            if ( sub_80E9DE0((int)a2, *((_DWORD *)v7 + 8)) <= 0 )
              return 0;
          }
          else if ( !sub_80EACAE(*((_DWORD *)v7 + 8)) || sub_80E9DE0((int)a2, *((_DWORD *)v7 + 8)) <= 0 )
          {
            return 0;
          }
          return 1;
        }
        if ( v5 == 3 )
          return a2[75] < a2[77];
      }
      else if ( !v5 )
      {
        Com_Error(1, (char *)&byte_814DB64);
      }
      return 0;
    }
    if ( sub_80E9882(*((_DWORD *)v7 + 8)) && !(unsigned __int8)sub_80D9E84((int)(a2 + 337), *((_DWORD *)v7 + 8)) )
    {
      if ( a3 || sub_80E9DE0((int)a2, *((_DWORD *)v7 + 8)) <= 0 )
        return 0;
    }
    else if ( sub_80E9DE0((int)a2, *((_DWORD *)v7 + 8)) <= 0 )
    {
      return 0;
    }
    return 1;
  }
  return 0;
}

//----- (080DCEB0) --------------------------------------------------------
float *__cdecl BG_EvaluateTrajectory(int a1, int a2, int a3)
{
  float *result; // eax
  long double v4; // fst7
  long double v5; // fst7
  float v6; // [esp+4h] [ebp-54h]
  float v7; // [esp+4h] [ebp-54h]
  int v8[6]; // [esp+30h] [ebp-28h] BYREF
  float v9; // [esp+48h] [ebp-10h]
  float v10; // [esp+4Ch] [ebp-Ch]

  switch ( *(_DWORD *)a1 )
  {
    case 0:
    case 1:
    case 6:
      result = (float *)sub_80DE966((_DWORD *)(a1 + 12), (_DWORD *)a3);
      break;
    case 2:
      v10 = (long double)(a2 - *(_DWORD *)(a1 + 4)) * 0.001;
      result = sub_80DEA94((float *)(a1 + 12), v10, (float *)(a1 + 24), (float *)a3);
      break;
    case 3:
      if ( a2 > *(_DWORD *)(a1 + 4) + *(_DWORD *)(a1 + 8) )
        a2 = *(_DWORD *)(a1 + 4) + *(_DWORD *)(a1 + 8);
      v10 = (long double)(a2 - *(_DWORD *)(a1 + 4)) * 0.001;
      if ( v10 < 0.0 )
        v10 = 0.0;
      result = sub_80DEA94((float *)(a1 + 12), v10, (float *)(a1 + 24), (float *)a3);
      break;
    case 4:
      v10 = (long double)(a2 - *(_DWORD *)(a1 + 4)) / (long double)*(int *)(a1 + 8);
      v9 = sin(v10 * 3.141592653589793 + v10 * 3.141592653589793);
      result = sub_80DEA94((float *)(a1 + 12), v9, (float *)(a1 + 24), (float *)a3);
      break;
    case 5:
      v10 = (long double)(a2 - *(_DWORD *)(a1 + 4)) * 0.001;
      sub_80DEA94((float *)(a1 + 12), v10, (float *)(a1 + 24), (float *)a3);
      result = (float *)(a3 + 8);
      *(float *)(a3 + 8) = *(float *)(a3 + 8) - v10 * 400.0 * v10;
      break;
    case 7:
      if ( a2 > *(_DWORD *)(a1 + 4) + *(_DWORD *)(a1 + 8) )
        a2 = *(_DWORD *)(a1 + 4) + *(_DWORD *)(a1 + 8);
      v4 = (long double)(a2 - *(_DWORD *)(a1 + 4)) * 0.001;
      v10 = v4;
      sub_80DEB1C((float *)(a1 + 24));
      v9 = v4 / ((long double)*(int *)(a1 + 8) * 0.001);
      sub_80A2298((float *)(a1 + 24), a3);
      v6 = v9 * 0.5 * v10 * v10;
      result = sub_80DEA94((float *)(a1 + 12), v6, (float *)a3, (float *)a3);
      break;
    case 8:
      if ( a2 > *(_DWORD *)(a1 + 4) + *(_DWORD *)(a1 + 8) )
        a2 = *(_DWORD *)(a1 + 4) + *(_DWORD *)(a1 + 8);
      v5 = (long double)(a2 - *(_DWORD *)(a1 + 4)) * 0.001;
      v10 = v5;
      sub_80DEB1C((float *)(a1 + 24));
      v9 = v5 / ((long double)*(int *)(a1 + 8) * 0.001);
      sub_80A2298((float *)(a1 + 24), a3);
      sub_80DEA94((float *)(a1 + 12), v10, (float *)(a1 + 24), (float *)v8);
      v7 = -v9 * 0.5 * v10 * v10;
      result = sub_80DEA94((float *)v8, v7, (float *)a3, (float *)a3);
      break;
    default:
      Com_Error(1, (char *)&byte_814DBA0, *(_DWORD *)a1);
  }
  return result;
}

//----- (080DD224) --------------------------------------------------------
float *__cdecl sub_80DD224(float *a1, int a2, int a3)
{
  float *result; // eax
  float v4; // [esp+4h] [ebp-24h]
  float v5; // [esp+20h] [ebp-8h]
  float v6; // [esp+20h] [ebp-8h]
  float v7; // [esp+24h] [ebp-4h]
  float v8; // [esp+24h] [ebp-4h]
  float v9; // [esp+24h] [ebp-4h]
  float v10; // [esp+24h] [ebp-4h]

  switch ( *(_DWORD *)a1 )
  {
    case 0:
    case 1:
      goto LABEL_10;
    case 2:
      goto LABEL_5;
    case 3:
      if ( a2 > *((_DWORD *)a1 + 1) + *((_DWORD *)a1 + 2) )
        goto LABEL_10;
LABEL_5:
      result = (float *)sub_80DE966((_DWORD *)a1 + 6, (_DWORD *)a3);
      break;
    case 4:
      v7 = (long double)(a2 - *((_DWORD *)a1 + 1)) / (long double)*((int *)a1 + 2);
      v5 = cos(v7 * 3.141592653589793 + v7 * 3.141592653589793);
      v6 = v5 * 0.5;
      return sub_80DEA5C(a1 + 6, v6, (float *)a3);
    case 5:
      v8 = (long double)(a2 - *((_DWORD *)a1 + 1)) * 0.001;
      sub_80DE966((_DWORD *)a1 + 6, (_DWORD *)a3);
      result = (float *)(a3 + 8);
      *(float *)(a3 + 8) = *(float *)(a3 + 8) - v8 * 800.0;
      return result;
    case 7:
      if ( a2 > *((_DWORD *)a1 + 1) + *((_DWORD *)a1 + 2) )
        goto LABEL_10;
      v9 = (long double)(a2 - *((_DWORD *)a1 + 1)) * 0.001;
      v4 = v9 * v9;
      result = sub_80DEA5C(a1 + 6, v4, (float *)a3);
      break;
    case 8:
      if ( a2 <= *((_DWORD *)a1 + 1) + *((_DWORD *)a1 + 2) )
      {
        v10 = (long double)(a2 - *((_DWORD *)a1 + 1)) * 0.001;
        result = sub_80DEA5C(a1 + 6, v10, (float *)a3);
      }
      else
      {
LABEL_10:
        result = (float *)sub_80DE918((_DWORD *)a3);
      }
      break;
    default:
      Com_Error(1, (char *)&byte_814DC20, *(_DWORD *)a1);
  }
  return result;
}

//----- (080DD452) --------------------------------------------------------
int __usercall sub_80DD452@<eax>(long double a1@<st0>, _DWORD *a2, float *a3, _DWORD *a4)
{
  float v5; // [esp+1Ch] [ebp-2Ch]
  int v6[4]; // [esp+20h] [ebp-28h] BYREF
  int v7[6]; // [esp+30h] [ebp-18h] BYREF

  v5 = 0.30000001;
  sub_80DEB1C(a3);
  if ( a1 >= 1.0 )
    sub_80DE966(a3, v6);
  else
    sub_80DE942(v6, 0, 0, 1065353216);
  sub_80DE996(a2, (unsigned int *)v7);
  Vec3Normalize((float *)v7);
  if ( a3[2] > 0.80000001 )
    v5 = 0.69999999;
  while ( v5 > sub_80DEAE8((float *)v7, (float *)v6) )
  {
    sub_80DEA94((float *)v7, 0.5, (float *)v6, (float *)v7);
    Vec3Normalize((float *)v7);
  }
  return sub_80DE966(v7, a4);
}

//----- (080DD554) --------------------------------------------------------
int __cdecl BG_AddPredictableEventToPlayerstate(int a1, unsigned __int8 a2, int a3)
{
  int result; // eax

  if ( a1 )
  {
    *(_DWORD *)(a3 + 4 * (*(_DWORD *)(a3 + 164) & 3) + 168) = (unsigned __int8)a1;
    *(_DWORD *)(a3 + 4 * (*(_DWORD *)(a3 + 164) & 3) + 184) = a2;
    result = a3;
    ++*(_DWORD *)(a3 + 164);
  }
  return result;
}

//----- (080DD59E) --------------------------------------------------------
int __cdecl sub_80DD59E(int a1, int a2, int a3, unsigned __int8 a4)
{
  unsigned int v4; // edx
  unsigned int v5; // edx
  int result; // eax
  unsigned __int8 v7; // [esp+1Fh] [ebp-19h]
  int j; // [esp+20h] [ebp-18h]
  float v9; // [esp+24h] [ebp-14h]
  void (__cdecl *v10)(_DWORD, _DWORD); // [esp+28h] [ebp-10h]
  int i; // [esp+2Ch] [ebp-Ch]

  if ( (*(_DWORD *)(a1 + 12) & 0xC00000) != 0 )
    *(_DWORD *)(a2 + 4) = 1;
  else
    *(_DWORD *)(a2 + 4) = 5;
  *(_DWORD *)(a2 + 12) = 1;
  sub_80DE966((_DWORD *)(a1 + 20), (_DWORD *)(a2 + 24));
  if ( a3 )
  {
    *(float *)(a2 + 24) = (float)(int)*(float *)(a2 + 24);
    *(float *)(a2 + 28) = (float)(int)*(float *)(a2 + 28);
    *(float *)(a2 + 32) = (float)(int)*(float *)(a2 + 32);
  }
  *(_DWORD *)(a2 + 48) = 1;
  sub_80DE966((_DWORD *)(a1 + 232), (_DWORD *)(a2 + 60));
  if ( a3 )
  {
    *(float *)(a2 + 60) = (float)(int)*(float *)(a2 + 60);
    *(float *)(a2 + 64) = (float)(int)*(float *)(a2 + 64);
    *(float *)(a2 + 68) = (float)(int)*(float *)(a2 + 68);
  }
  *(float *)(a2 + 108) = (float)*(int *)(a1 + 156);
  *(_DWORD *)(a2 + 204) = *(_DWORD *)(a1 + 124);
  *(_DWORD *)(a2 + 208) = *(_DWORD *)(a1 + 132);
  *(_DWORD *)(a2 + 144) = *(_DWORD *)(a1 + 204);
  *(_DWORD *)(a2 + 8) = *(_DWORD *)(a1 + 160);
  if ( (*(_DWORD *)(a1 + 160) & 0x300) != 0 )
    *(_DWORD *)(a2 + 116) = *(_DWORD *)(a1 + 1428);
  if ( *(int *)(a1 + 4) <= 5 )
    v4 = *(_DWORD *)(a2 + 8) & 0xFFFDFFFF;
  else
    v4 = *(_DWORD *)(a2 + 8) | 0x20000;
  *(_DWORD *)(a2 + 8) = v4;
  if ( (*(_DWORD *)(a1 + 12) & 0x40) != 0 )
    v5 = *(_DWORD *)(a2 + 8) | 0x40000;
  else
    v5 = *(_DWORD *)(a2 + 8) & 0xFFFBFFFF;
  *(_DWORD *)(a2 + 8) = v5;
  *(_DWORD *)(a2 + 212) = *(_DWORD *)(a1 + 76);
  if ( PM_GetEffectiveStance(a1) == 1 )
  {
    if ( *(_DWORD *)(a1 + 252) )
    {
      v9 = (long double)(*(_DWORD *)a1 - *(_DWORD *)(a1 + 252))
         / (long double)sub_80E1522(a1, *(_DWORD *)(a1 + 256), *(_DWORD *)(a1 + 260));
      if ( v9 >= 0.0 )
      {
        if ( v9 > 1.0 )
          v9 = 1.0;
      }
      else
      {
        v9 = 0.0;
      }
      if ( !*(_DWORD *)(a1 + 260) )
        v9 = 1.0 - v9;
    }
    else
    {
      v9 = 1.0;
    }
    *(float *)(a2 + 228) = *(float *)(a1 + 1448) * v9;
    *(float *)(a2 + 232) = sub_80A6112(*(float *)(a1 + 1452)) * v9;
    *(float *)(a2 + 236) = sub_80A6112(*(float *)(a1 + 1456)) * v9;
  }
  else
  {
    *(_DWORD *)(a2 + 228) = 0;
    *(_DWORD *)(a2 + 232) = 0;
    *(_DWORD *)(a2 + 236) = 0;
  }
  if ( *(_DWORD *)(a1 + 1484) - *(_DWORD *)(a1 + 164) >= 0 )
  {
    *(_DWORD *)(a2 + 160) = 0;
  }
  else
  {
    if ( *(_DWORD *)(a1 + 164) - *(_DWORD *)(a1 + 1484) > 4 )
      *(_DWORD *)(a1 + 1484) = *(_DWORD *)(a1 + 164) - 4;
    *(_DWORD *)(a2 + 160) = *(unsigned __int8 *)(a1 + 4 * ((*(_DWORD *)(a1 + 1484))++ & 3) + 184);
  }
  for ( i = *(_DWORD *)(a1 + 200); i != *(_DWORD *)(a1 + 164); ++i )
  {
    v7 = *(_BYTE *)(a1 + 4 * (i & 3) + 168);
    v10 = (void (__cdecl *)(_DWORD, _DWORD))dword_8166528[3 * a4];
    if ( v10 )
      v10(*(_DWORD *)a2, v7);
    for ( j = 0; dword_814D70C[j] > 0 && dword_814D70C[j] != v7; ++j )
      ;
    if ( dword_814D70C[j] < 0 )
    {
      *(_DWORD *)(a2 + 4 * (*(_DWORD *)(a2 + 164) & 3) + 168) = v7;
      *(_DWORD *)(a2 + 4 * ((*(_DWORD *)(a2 + 164))++ & 3) + 184) = *(unsigned __int8 *)(a1 + 4 * (i & 3) + 184);
    }
  }
  *(_DWORD *)(a1 + 200) = *(_DWORD *)(a1 + 164);
  *(_DWORD *)(a2 + 200) = *(unsigned __int8 *)(a1 + 212);
  result = *(unsigned __int16 *)(a1 + 96);
  *(_DWORD *)(a2 + 124) = result;
  return result;
}
// 814D70C: using guessed type int dword_814D70C[7];
// 8166528: using guessed type int dword_8166528[];

//----- (080DDAD0) --------------------------------------------------------
int __cdecl sub_80DDAD0(
        int a1,
        float *a2,
        int a3,
        int a4,
        float a5,
        _DWORD *a6,
        float *a7,
        float *a8,
        int a9,
        int a10,
        int a11,
        unsigned __int8 a12,
        int a13,
        float a14)
{
  float v15; // [esp+0h] [ebp-148h]
  float v16; // [esp+0h] [ebp-148h]
  float v17; // [esp+4h] [ebp-144h]
  float v18; // [esp+4h] [ebp-144h]
  int v19; // [esp+8h] [ebp-140h]
  char v21; // [esp+2Bh] [ebp-11Dh]
  void (__cdecl *v22)(float *, float *, float *, float *, float *, int, int); // [esp+2Ch] [ebp-11Ch]
  float v23; // [esp+30h] [ebp-118h]
  int v24; // [esp+34h] [ebp-114h]
  float v25; // [esp+38h] [ebp-110h]
  float v26; // [esp+40h] [ebp-108h]
  float v27; // [esp+44h] [ebp-104h]
  float v28; // [esp+44h] [ebp-104h]
  float v29; // [esp+48h] [ebp-100h]
  float v30; // [esp+4Ch] [ebp-FCh]
  int v31[2]; // [esp+50h] [ebp-F8h] BYREF
  float v32; // [esp+58h] [ebp-F0h]
  int v33[2]; // [esp+60h] [ebp-E8h] BYREF
  float v34; // [esp+68h] [ebp-E0h]
  float v35[4]; // [esp+70h] [ebp-D8h] BYREF
  float v36[4]; // [esp+80h] [ebp-C8h] BYREF
  float v37[4]; // [esp+90h] [ebp-B8h] BYREF
  int v38[4]; // [esp+A0h] [ebp-A8h] BYREF
  int v39[2]; // [esp+B0h] [ebp-98h] BYREF
  float v40; // [esp+B8h] [ebp-90h]
  int v41[4]; // [esp+C0h] [ebp-88h] BYREF
  int v42[4]; // [esp+D0h] [ebp-78h] BYREF
  int v43; // [esp+E0h] [ebp-68h] BYREF
  float v44; // [esp+E4h] [ebp-64h]
  float v45; // [esp+E8h] [ebp-60h]
  int v46[2]; // [esp+F0h] [ebp-58h] BYREF
  float v47; // [esp+F8h] [ebp-50h]
  float s[3]; // [esp+100h] [ebp-48h] BYREF
  float v49; // [esp+10Ch] [ebp-3Ch]
  char v50; // [esp+122h] [ebp-26h]
  int v51; // [esp+138h] [ebp-10h]
  unsigned __int8 v52; // [esp+13Fh] [ebp-9h]

  v52 = a12;
  v24 = 0;
  v21 = 1;
  v22 = (void (__cdecl *)(float *, float *, float *, float *, float *, int, int))funcs_80DDC6A[3 * a12];
  sub_80DE942(v42, a3 ^ 0x80000000, a3 ^ 0x80000000, 0);
  sub_80DE9D4((float *)v42, a2, (float *)v42);
  sub_80DE942(v41, a3, a3, a4);
  sub_80DE9D4((float *)v41, a2, (float *)v41);
  if ( a13 )
    v51 = 8519697;
  else
    v51 = 8454161;
  if ( !a9 )
  {
    sub_80DE942(v42, a3 ^ 0x80000000, a3 ^ 0x80000000, 0);
    sub_80DE942(v41, a3, a3, a4);
    sub_80DE966(a2, v46);
    sub_80DE966(a2, &v43);
    v45 = v45 + 10.0;
    v22(s, (float *)v46, (float *)v42, (float *)v41, (float *)&v43, a1, v51);
    if ( v50 )
      return 0;
  }
  if ( a10 && a11 && *(float *)(a11 + 8) < 0.69999999 )
    return 0;
  sub_80DE942(v42, -1061158912, -1061158912, -1061158912);
  sub_80DE942(v41, 1086324736, 1086324736, 1086324736);
  *(float *)&v19 = a5 - 180.0;
  sub_80DE942(&v43, 0, v19, 0);
  AngleVectors((float *)&v43, (int)v38, v37, v36);
  v26 = *(float *)&a4 - 6.0;
  sub_80DE966(a2, v46);
  v47 = v47 + v26;
  v17 = a14 - 6.0;
  sub_80DEA94((float *)v46, v17, (float *)v38, (float *)&v43);
  v22(s, (float *)v46, (float *)v42, (float *)v41, (float *)&v43, a1, v51);
  if ( s[0] >= 1.0 )
  {
    v25 = a14;
  }
  else
  {
    if ( !a10 )
      return 0;
    v24 = 1;
    v25 = (a14 - 6.0) * s[0] + 6.0;
    if ( *(float *)&a3 + 2.0 > v25 )
      return 0;
    if ( v26 * 0.69999999 + 48.0 > v25 )
    {
      v24 = 0;
      v45 = v45 + 22.0;
      sub_80DEA18((float *)&v43, (float *)v46, (float *)v39);
      v27 = sub_80A2298((float *)v39, (int)v38);
      v22(s, (float *)v46, (float *)v42, (float *)v41, (float *)&v43, a1, v51);
      if ( s[0] >= 1.0 )
      {
        v25 = a14;
      }
      else
      {
        v24 = 1;
        v25 = s[0] * v27 + 6.0;
        if ( v26 * 0.69999999 + 48.0 > v25 )
          return 0;
      }
    }
  }
  sub_80DEB7A((float *)v46, (float *)&v43, s[0], (float *)v31);
  sub_80DEA94(a2, 48.0, (float *)v38, (float *)v46);
  v47 = v47 + v26;
  sub_80DE966(v46, &v43);
  v45 = v45 - (*(float *)&a3 * 2.5 + v26 - 6.0);
  v22(s, (float *)v46, (float *)v42, (float *)v41, (float *)&v43, a1, v51);
  if ( s[0] != 1.0 )
  {
    if ( v49 < 0.69999999 )
      return 0;
    v23 = (*(float *)&a3 * 2.5 + v26 - 6.0) * s[0] + 6.0;
    sub_80DEB7A((float *)v46, (float *)&v43, s[0], (float *)v33);
    v34 = v34 - 6.0;
    if ( !v24 )
      goto LABEL_30;
    if ( v23 * -0.75 <= v25 - v23 )
    {
      sub_80DEA18((float *)v31, (float *)v33, (float *)v39);
      sub_80DEA94((float *)v39, 6.0, (float *)v38, (float *)v39);
      v40 = v40 + 6.0;
      Vec3Normalize((float *)v39);
      v18 = a14 - 6.0 - 48.0;
      sub_80DEA94((float *)v46, v18, (float *)v39, (float *)&v43);
      *(float *)&v43 = ((a14 - 6.0) * *(float *)v38 + *a2 + *(float *)&v43) * 0.5;
      v44 = ((a14 - 6.0) * *(float *)&v38[1] + a2[1] + v44) * 0.5;
      v22(s, (float *)v46, (float *)v42, (float *)v41, (float *)&v43, a1, v51);
      if ( s[0] >= 1.0
        || (sub_80DEB7A((float *)v46, (float *)&v43, s[0], (float *)v46),
            v47 = v47 + 18.0,
            v45 = v45 + 18.0,
            v22(s, (float *)v46, (float *)v42, (float *)v41, (float *)&v43, a1, v51),
            s[0] >= 1.0) )
      {
        sub_80DEB7A((float *)v46, (float *)&v43, s[0], (float *)v31);
LABEL_30:
        sub_80DE966(v31, v46);
        sub_80DE966(v46, &v43);
        v45 = v45 - (v47 - v34 + v47 - v34 + *(float *)&a3);
        v22(s, (float *)v46, (float *)v42, (float *)v41, (float *)&v43, a1, v51);
        if ( s[0] != 1.0 )
        {
          if ( v49 < 0.69999999 )
            return 0;
          sub_80DEB7A((float *)v46, (float *)&v43, s[0], (float *)v31);
          v32 = v32 - 6.0;
          sub_80DE966(a2, v35);
          sub_80DEA18((float *)v33, v35, (float *)v39);
          v30 = sub_80A2AF6((float *)v39);
          sub_80DEA18((float *)v31, (float *)v33, (float *)v39);
          v29 = sub_80A2AF6((float *)v39);
          v28 = sub_80A6000(v29, v30);
          if ( v28 < -50.0 || v28 > 70.0 )
            v21 = 0;
          sub_80DE942(v42, 0x80000000, 0x80000000, 0x80000000);
          sub_80DE942(v41, 0, 0, 0);
          sub_80DE966(v35, v46);
          v47 = v47 + 5.0;
          sub_80DE966(v33, &v43);
          v45 = v45 + 5.0;
          v22(s, (float *)v46, (float *)v42, (float *)v41, (float *)&v43, a1, v51);
          if ( s[0] < 1.0 )
            v21 = 0;
          sub_80DE966(&v43, v46);
          sub_80DE966(v31, &v43);
          v45 = v45 + 5.0;
          v22(s, (float *)v46, (float *)v42, (float *)v41, (float *)&v43, a1, v51);
          if ( s[0] < 1.0 )
            v21 = 0;
          if ( a6 )
            *a6 = 0;
          if ( a7 )
          {
            sub_80DEA18(v35, (float *)v33, (float *)v39);
            v15 = sub_80A2AF6((float *)v39);
            *a7 = sub_80A6112(v15);
          }
          if ( a8 )
          {
            sub_80DEA18((float *)v33, (float *)v31, (float *)v39);
            v16 = sub_80A2AF6((float *)v39);
            *a8 = sub_80A6112(v16);
          }
          if ( v21 )
            return 1;
        }
      }
    }
  }
  if ( a10 )
    return 0;
  if ( a6 )
    *a6 = 0;
  if ( a7 )
    *a7 = 0.0;
  if ( a8 )
    *a8 = 0.0;
  return 1;
}
// 8166520: using guessed type int (__cdecl *funcs_80DDC6A[2])(void *s, int, int, int, int, int, int);
// 80DDAD0: using guessed type float var_C8[4];
// 80DDAD0: using guessed type float var_B8[4];
// 80DDAD0: using guessed type float var_D8[4];

//----- (080DE734) --------------------------------------------------------
int __cdecl sub_80DE734(
        int a1,
        float *a2,
        int a3,
        int a4,
        float a5,
        _DWORD *a6,
        float *a7,
        float *a8,
        int a9,
        int a10,
        int a11,
        unsigned __int8 a12,
        int a13,
        float a14)
{
  return sub_80DDAD0(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14);
}

//----- (080DE918) --------------------------------------------------------
int __cdecl sub_80DE918(_DWORD *a1)
{
  int result; // eax

  *a1 = 0;
  a1[1] = 0;
  result = 0;
  a1[2] = 0;
  return result;
}

//----- (080DE942) --------------------------------------------------------
int __cdecl sub_80DE942(_DWORD *a1, int a2, int a3, int a4)
{
  int result; // eax

  *a1 = a2;
  a1[1] = a3;
  result = a4;
  a1[2] = a4;
  return result;
}

//----- (080DE966) --------------------------------------------------------
int __cdecl sub_80DE966(_DWORD *a1, _DWORD *a2)
{
  int result; // eax

  *a2 = *a1;
  a2[1] = a1[1];
  result = a1[2];
  a2[2] = result;
  return result;
}

//----- (080DE996) --------------------------------------------------------
unsigned int __cdecl sub_80DE996(_DWORD *a1, unsigned int *a2)
{
  unsigned int result; // eax

  *a2 = *a1 ^ 0x80000000;
  a2[1] = a1[1] ^ 0x80000000;
  result = a1[2] ^ 0x80000000;
  a2[2] = result;
  return result;
}

//----- (080DE9D4) --------------------------------------------------------
float *__cdecl sub_80DE9D4(float *a1, float *a2, float *a3)
{
  float *result; // eax

  *a3 = *a1 + *a2;
  a3[1] = a1[1] + a2[1];
  result = a1 + 2;
  a3[2] = a1[2] + a2[2];
  return result;
}

//----- (080DEA18) --------------------------------------------------------
float *__cdecl sub_80DEA18(float *a1, float *a2, float *a3)
{
  float *result; // eax

  *a3 = *a1 - *a2;
  a3[1] = a1[1] - a2[1];
  result = a1 + 2;
  a3[2] = a1[2] - a2[2];
  return result;
}

//----- (080DEA5C) --------------------------------------------------------
float *__cdecl sub_80DEA5C(float *a1, float a2, float *a3)
{
  float *result; // eax

  *a3 = a2 * *a1;
  a3[1] = a2 * a1[1];
  result = a1 + 2;
  a3[2] = a2 * a1[2];
  return result;
}

//----- (080DEA94) --------------------------------------------------------
float *__cdecl sub_80DEA94(float *a1, float a2, float *a3, float *a4)
{
  float *result; // eax

  *a4 = a2 * *a3 + *a1;
  a4[1] = a2 * a3[1] + a1[1];
  result = a3 + 2;
  a4[2] = a2 * a3[2] + a1[2];
  return result;
}

//----- (080DEAE8) --------------------------------------------------------
long double __cdecl sub_80DEAE8(float *a1, float *a2)
{
  return *a1 * *a2 + a1[1] * a2[1] + a1[2] * a2[2];
}

//----- (080DEB1C) --------------------------------------------------------
void __cdecl sub_80DEB1C(float *a1)
{
  float v1; // [esp+0h] [ebp-8h]

  v1 = *a1 * *a1 + a1[1] * a1[1] + a1[2] * a1[2];
  sub_80DEB5A(v1);
}

//----- (080DEB5A) --------------------------------------------------------
long double __cdecl sub_80DEB5A(float a1)
{
  return (float)sqrt(a1);
}

//----- (080DEB7A) --------------------------------------------------------
float *__cdecl sub_80DEB7A(float *a1, float *a2, float a3, float *a4)
{
  float *result; // eax

  *a4 = (*a2 - *a1) * a3 + *a1;
  a4[1] = (a2[1] - a1[1]) * a3 + a1[1];
  result = a2 + 2;
  a4[2] = (a2[2] - a1[2]) * a3 + a1[2];
  return result;
}

//----- (080DEBE4) --------------------------------------------------------
void __cdecl sub_80DEBE4(int a1, void *s, int a3, int a4, int a5, int a6, int a7, int a8)
{
  funcs_80DDC6A[3 * *(unsigned __int8 *)(a1 + 228)](s, a3, a4, a5, a6, a7, a8);
}
// 8166520: using guessed type int (__cdecl *funcs_80DDC6A[2])(void *s, int, int, int, int, int, int);

//----- (080DEC3C) --------------------------------------------------------
void __cdecl sub_80DEC3C(int a1, unsigned __int16 *s, int a3, int a4, int a5, int a6, int a7, int a8)
{
  funcs_80DDC6A[3 * *(unsigned __int8 *)(a1 + 228)](s, a3, a4, a5, a6, a7, a8);
  if ( *((_BYTE *)s + 35) )
  {
    if ( (*((_DWORD *)s + 5) & 0x2000000) != 0 )
    {
      sub_80DED50(a1, s[14]);
      *(_DWORD *)(a1 + 60) &= ~0x2000000u;
      funcs_80DDC6A[3 * *(unsigned __int8 *)(a1 + 228)](s, a3, a4, a5, a6, a7, a8 & 0xFDFFFFFF);
    }
  }
}
// 8166520: using guessed type int (__cdecl *funcs_80DDC6A[2])(void *s, int, int, int, int, int, int);

//----- (080DED2E) --------------------------------------------------------
int __cdecl sub_80DED2E(int a1, int a2)
{
  return BG_AddPredictableEventToPlayerstate(a2, 0, a1);
}

//----- (080DED50) --------------------------------------------------------
int __cdecl sub_80DED50(int a1, int a2)
{
  int result; // eax
  int i; // [esp+0h] [ebp-4h]

  if ( a2 != 1022 )
  {
    result = a1;
    if ( *(_DWORD *)(a1 + 64) != 32 )
    {
      for ( i = 0; i < *(_DWORD *)(a1 + 64); ++i )
      {
        result = *(_DWORD *)(a1 + 4 * i + 68);
        if ( result == a2 )
          return result;
      }
      *(_DWORD *)(a1 + 4 * *(_DWORD *)(a1 + 64) + 68) = a2;
      result = a1;
      ++*(_DWORD *)(a1 + 64);
    }
  }
  return result;
}

//----- (080DEDB0) --------------------------------------------------------
float *__cdecl sub_80DEDB0(float *a1, float *a2, float *a3)
{
  float v4; // [esp+14h] [ebp-4h]
  float v5; // [esp+14h] [ebp-4h]

  v4 = sub_80E724C(a1, a2);
  v5 = v4 - sub_80E6E42(v4) * 0.001;
  return sub_80E71F8(a1, COERCE_FLOAT(LODWORD(v5) ^ 0x80000000), a2, a3);
}

//----- (080DEE0E) --------------------------------------------------------
int __cdecl PM_GetEffectiveStance(int a1)
{
  if ( *(_DWORD *)(a1 + 244) == 40 )
    return 2;
  else
    return *(_DWORD *)(a1 + 244) == 11;
}

//----- (080DEE4A) --------------------------------------------------------
int __usercall sub_80DEE4A@<eax>(long double a1@<st0>, int a2, int a3)
{
  int result; // eax
  float v4; // [esp+18h] [ebp-30h]
  float v5; // [esp+1Ch] [ebp-2Ch]
  float v6; // [esp+20h] [ebp-28h]
  float v7; // [esp+24h] [ebp-24h]
  float v8; // [esp+24h] [ebp-24h]
  float v9; // [esp+28h] [ebp-20h]
  float *v10; // [esp+2Ch] [ebp-1Ch]
  float v11[6]; // [esp+30h] [ebp-18h] BYREF

  v10 = (float *)(a2 + 32);
  sub_80E70CA((_DWORD *)(a2 + 32), v11);
  if ( *(_DWORD *)(a3 + 44) )
    v11[2] = 0.0;
  sub_80E72B4(v11);
  v9 = a1;
  if ( v9 < 1.0 )
    return sub_80E707C(v10);
  v5 = 0.0;
  if ( *(_DWORD *)(a3 + 44) && (*(_DWORD *)(a3 + 72) & 2) == 0 && (*(_DWORD *)(a2 + 12) & 0x400) == 0 )
  {
    if ( *(float *)(stopspeed + 8) <= (long double)v9 )
      v4 = a1;
    else
      v4 = *(float *)(stopspeed + 8);
    v6 = v4;
    if ( (*(_DWORD *)(a2 + 12) & 0x200) != 0 )
    {
      v6 = v4 * 0.30000001;
    }
    else if ( (*(_DWORD *)(a2 + 12) & 0x80000) != 0 )
    {
      v6 = sub_80DA1F8(a2) * v4;
    }
    v5 = v6 * *(float *)(friction + 8) * *(float *)(a3 + 36) + 0.0;
  }
  if ( *(_DWORD *)(a2 + 4) == 4 )
    v5 = v9 * 5.0 * *(float *)(a3 + 36) + v5;
  v7 = v9 - v5;
  if ( v7 < 0.0 )
    v7 = 0.0;
  v8 = v7 / v9;
  *v10 = *v10 * v8;
  *(float *)(a2 + 36) = *(float *)(a2 + 36) * v8;
  result = a2 + 40;
  *(float *)(a2 + 40) = *(float *)(a2 + 40) * v8;
  return result;
}
// 85760AC: using guessed type int stopspeed;
// 85760B0: using guessed type int friction;

//----- (080DEFE8) --------------------------------------------------------
int __cdecl sub_80DEFE8(int a1, float a2, float *a3)
{
  int v5[2]; // [esp+40h] [ebp-18h] BYREF
  float v6[3]; // [esp+48h] [ebp-10h] BYREF
  float v7; // [esp+54h] [ebp-4h]

  sub_80E6FD6((float *)(a1 + 32), a2, a3, (float *)v5);
  sub_80E6F38((_DWORD *)(a1 + 44), v6);
  sub_80A215E(v6);
  sub_80A215E((float *)v5);
  v7 = sub_80E700C(v6, (float *)v5);
  if ( v7 >= (long double)*(float *)(inertiaAngle + 8) )
    return 0;
  if ( *(_BYTE *)(inertiaDebug + 8) )
  {
    Com_Printf("angle is %f (oldVel is (%f,%f), vel is (%f, %f))\n", v7, v6[0], v6[1], *(float *)v5, *(float *)&v5[1]);
    Com_Printf("clamping acceleration from %f to %f\n", a2, *(float *)(inertiaMax + 8));
  }
  return 1;
}
// 85760A0: using guessed type int inertiaMax;
// 85760A4: using guessed type int inertiaDebug;
// 85760A8: using guessed type int inertiaAngle;

//----- (080DF0DA) --------------------------------------------------------
long double __cdecl sub_80DF0DA(int a1, float a2, float *a3)
{
  if ( *(_DWORD *)(a1 + 4) == 2 )
  {
    return a2;
  }
  else if ( *(float *)(inertiaMax + 8) < (long double)a2 )
  {
    if ( sub_80E702E((float *)(a1 + 44)) >= 0.0001 )
    {
      if ( (unsigned __int8)sub_80DEFE8(a1, a2, a3) )
        return *(float *)(inertiaMax + 8);
      else
        return a2;
    }
    else
    {
      return a2;
    }
  }
  else
  {
    return a2;
  }
}
// 85760A0: using guessed type int inertiaMax;

//----- (080DF16A) --------------------------------------------------------
void __cdecl sub_80DF16A(int a1, int a2, float *a3, float a4, float a5)
{
  float v5; // [esp+1Ch] [ebp-4Ch]
  int v6[4]; // [esp+20h] [ebp-48h] BYREF
  int v7[7]; // [esp+30h] [ebp-38h] BYREF
  float v8; // [esp+4Ch] [ebp-1Ch]
  float v9; // [esp+50h] [ebp-18h]
  float v10; // [esp+54h] [ebp-14h]
  float v11; // [esp+58h] [ebp-10h]
  float v12; // [esp+5Ch] [ebp-Ch]

  if ( (*(_DWORD *)(a1 + 12) & 0x20) != 0 )
  {
    sub_80E71C0(a3, a4, (float *)v7);
    sub_80E717C((float *)v7, (float *)(a1 + 32), (float *)v6);
    v8 = Vec3Normalize((float *)v6);
    v9 = a5 * *(float *)(a2 + 36) * a4;
    if ( v9 > (long double)v8 )
      v9 = v8;
    sub_80E71F8((float *)(a1 + 32), v9, (float *)v6, (float *)(a1 + 32));
  }
  else
  {
    v10 = sub_80E724C((float *)(a1 + 32), a3);
    v12 = a4 - v10;
    if ( v12 > 0.0 )
    {
      if ( *(float *)(stopspeed + 8) <= (long double)a4 )
        v5 = a4;
      else
        v5 = *(float *)(stopspeed + 8);
      v8 = v5;
      v11 = a5 * *(float *)(a2 + 36) * v5;
      if ( v11 > (long double)v12 )
        v11 = v12;
      v9 = sub_80DF0DA(a1, v11, a3);
      sub_80E71F8((float *)(a1 + 32), v9, a3, (float *)(a1 + 32));
    }
  }
}
// 85760AC: using guessed type int stopspeed;

//----- (080DF2DE) --------------------------------------------------------
long double __cdecl sub_80DF2DE(int a1, float a2, float a3, float a4)
{
  float v5; // [esp+0h] [ebp-18h]
  float v7; // [esp+Ch] [ebp-Ch]
  float v8; // [esp+10h] [ebp-8h]
  float v9; // [esp+14h] [ebp-4h]

  v9 = fabs(a2);
  if ( fabs(a3) > v9 )
    v9 = fabs(a3);
  if ( fabs(a4) > v9 )
    v9 = fabs(a4);
  if ( v9 == 0.0 )
  {
    return (float)0.0;
  }
  else
  {
    v5 = a2 * a2 + a3 * a3 + a4 * a4;
    v8 = sub_80E6E5C(v5);
    v7 = (long double)*(int *)(a1 + 80) * v9 / (v8 * 127.0);
    if ( (*(_DWORD *)(a1 + 12) & 0x100) != 0 || *(float *)(a1 + 76) != 0.0 )
      v7 = v7 * 0.40000001;
    if ( *(_DWORD *)(a1 + 4) == 2 )
      v7 = v7 * 3.0;
    if ( *(_DWORD *)(a1 + 4) == 3 )
      v7 = v7 * 6.0;
    if ( *(_DWORD *)(a1 + 4) == 4 )
      return (float)(v7 * *(float *)(player_spectateSpeedScale + 8));
    return v7;
  }
}
// 8576108: using guessed type int player_spectateSpeedScale;

//----- (080DF3FA) --------------------------------------------------------
long double __cdecl sub_80DF3FA(int a1, int a2)
{
  float v3; // [esp+0h] [ebp-28h]
  int v4; // [esp+Ch] [ebp-1Ch]
  int v5; // [esp+10h] [ebp-18h]
  int v6; // [esp+14h] [ebp-14h]
  float v8; // [esp+1Ch] [ebp-Ch]
  float v9; // [esp+20h] [ebp-8h]
  int v10; // [esp+24h] [ebp-4h]

  v3 = (float)(*(char *)(a2 + 25) * *(char *)(a2 + 25) + *(char *)(a2 + 24) * *(char *)(a2 + 24));
  v9 = sub_80E6E5C(v3);
  v6 = *(char *)(a2 + 24);
  if ( v6 < 0 )
    v6 = -v6;
  v10 = v6;
  v5 = *(char *)(a2 + 25);
  if ( v5 < 0 )
    v5 = -v5;
  if ( v5 > v6 )
  {
    v4 = *(char *)(a2 + 25);
    if ( v4 < 0 )
      v4 = -v4;
    v10 = v4;
  }
  if ( v10 )
  {
    v8 = (long double)*(int *)(a1 + 80) * (long double)v10 / (v9 * 127.0);
    if ( (*(_DWORD *)(a1 + 12) & 0x100) != 0 || *(float *)(a1 + 76) != 0.0 )
      v8 = v8 * 0.40000001;
    if ( *(_DWORD *)(a1 + 4) == 2 )
      v8 = v8 * 3.0;
    if ( *(_DWORD *)(a1 + 4) == 3 )
      v8 = v8 * 6.0;
    if ( *(_DWORD *)(a1 + 4) == 4 )
      return (float)(v8 * *(float *)(player_spectateSpeedScale + 8));
    return v8;
  }
  else
  {
    return (float)0.0;
  }
}
// 8576108: using guessed type int player_spectateSpeedScale;

//----- (080DF534) --------------------------------------------------------
long double __cdecl sub_80DF534(int *a1, int a2)
{
  float v3; // [esp+0h] [ebp-38h]
  float v4; // [esp+0h] [ebp-38h]
  float v5; // [esp+0h] [ebp-38h]
  int v7; // [esp+18h] [ebp-20h]
  float v8; // [esp+1Ch] [ebp-1Ch]
  float v9; // [esp+1Ch] [ebp-1Ch]
  int v10; // [esp+20h] [ebp-18h]
  float v11; // [esp+24h] [ebp-14h]
  float v12; // [esp+28h] [ebp-10h]
  float v13; // [esp+2Ch] [ebp-Ch]
  float v14; // [esp+30h] [ebp-8h]

  v10 = *a1;
  v3 = (float)(*(char *)(a2 + 25) * *(char *)(a2 + 25) + *(char *)(a2 + 24) * *(char *)(a2 + 24));
  v11 = sub_80E6E5C(v3);
  if ( *(char *)(a2 + 24) >= 0 )
    v4 = (float)*(char *)(a2 + 24);
  else
    v4 = (long double)*(char *)(a2 + 24) * *(float *)(player_backSpeedScale + 8);
  v14 = sub_80E6E42(v4);
  v5 = (long double)*(char *)(a2 + 25) * *(float *)(player_strafeSpeedScale + 8);
  v13 = sub_80E6E42(v5);
  sub_80E6E7C(v14, v13);
  if ( v13 == 0.0 )
  {
    return (float)0.0;
  }
  else
  {
    v12 = (long double)*(int *)(v10 + 80) * v13 / (v11 * 127.0);
    if ( (*(_DWORD *)(v10 + 12) & 0x100) != 0 || *(float *)(v10 + 76) != 0.0 )
      v12 = v12 * 0.40000001;
    if ( *(_DWORD *)(v10 + 4) == 2 )
    {
      v12 = v12 * 3.0;
    }
    else if ( *(_DWORD *)(v10 + 4) == 3 )
    {
      v12 = v12 * 6.0;
    }
    else
    {
      v7 = PM_GetEffectiveStance(v10);
      v8 = sub_80E168A(a1, 40, 11);
      if ( v8 == 0.0 )
      {
        v9 = sub_80E168A(a1, 11, 40);
        if ( v9 == 0.0 )
        {
          if ( v7 == 1 )
          {
            v12 = v12 * 0.15000001;
          }
          else if ( v7 == 2 )
          {
            v12 = v12 * 0.64999998;
          }
        }
        else
        {
          v12 = (v9 * 0.64999998 + (1.0 - v9) * 0.15000001) * v12;
        }
      }
      else
      {
        v12 = (v8 * 0.15000001 + (1.0 - v8) * 0.64999998) * v12;
      }
    }
    if ( *(_DWORD *)(v10 + 212) && *(float *)(BG_WeaponDefs(*(_DWORD *)(v10 + 212)) + 612) > 0.0 )
      v12 = v12 * *(float *)(BG_WeaponDefs(*(_DWORD *)(v10 + 212)) + 612);
    if ( (*(_DWORD *)(a2 + 4) & 0x800) != 0 )
      return (float)(v12 * 0.40000001);
    return v12;
  }
}
// 8576100: using guessed type int player_strafeSpeedScale;
// 8576104: using guessed type int player_backSpeedScale;

//----- (080DF7FC) --------------------------------------------------------
long double __cdecl sub_80DF7FC(int a1)
{
  float v3; // [esp+8h] [ebp-10h]
  float v4; // [esp+10h] [ebp-8h]

  if ( a1 )
  {
    v4 = *(float *)(player_dmgtimer_maxTime + 8);
    if ( v4 == 0.0 )
    {
      return (float)1.0;
    }
    else
    {
      v3 = -*(float *)(player_dmgtimer_minScale + 8) / v4;
      return (float)((long double)a1 * v3 + 1.0);
    }
  }
  else
  {
    return (float)1.0;
  }
}
// 8576114: using guessed type int player_dmgtimer_maxTime;
// 8576118: using guessed type int player_dmgtimer_minScale;

//----- (080DF868) --------------------------------------------------------
int __usercall sub_80DF868@<eax>(long double a1@<st0>, int a2, int a3)
{
  int result; // eax
  long double v4; // fst7
  long double v5; // fst7
  float v6; // [esp+0h] [ebp-68h]
  int v7; // [esp+10h] [ebp-58h]
  int v8; // [esp+14h] [ebp-54h]
  int v9; // [esp+18h] [ebp-50h]
  float v10[6]; // [esp+20h] [ebp-48h] BYREF
  int v11; // [esp+38h] [ebp-30h]
  int v12; // [esp+3Ch] [ebp-2Ch]
  float v13[7]; // [esp+40h] [ebp-28h] BYREF
  float v14; // [esp+5Ch] [ebp-Ch]

  v11 = *(_DWORD *)a2;
  if ( (*(_BYTE *)(v11 + 12) & 1) == 0 || (*(_DWORD *)(v11 + 160) & 0x300) != 0 )
  {
    if ( (*(_DWORD *)(v11 + 12) & 0x20) != 0 )
    {
      v4 = sub_80A29F6((float *)(v11 + 100)) + 180.0;
      v14 = v4;
      sub_80A6258(v14, *(float *)(v11 + 236));
      v12 = (int)v4;
      v8 = (int)v4;
      if ( (int)v4 < 0 )
        v8 = -v8;
      if ( v8 > 90 )
      {
        if ( v12 <= 0 )
          v12 = -90;
        else
          v12 = 90;
      }
      result = (char)v12;
      *(_DWORD *)(v11 + 156) = (char)v12;
    }
    else
    {
      sub_80E717C((float *)(v11 + 20), (float *)(a3 + 96), v13);
      if ( !*(_BYTE *)(a2 + 28) && !*(_BYTE *)(a2 + 29)
        || *(_DWORD *)(v11 + 96) == 1023
        || (sub_80E72B4(v13), v14 = a1, v14 == 0.0)
        || v14 <= *(float *)(a3 + 36) * 5.0 )
      {
        result = v11;
        *(_DWORD *)(v11 + 156) = 0;
      }
      else
      {
        v5 = sub_80A2298(v13, (int)v10);
        vectoangles(v10, (int)v10);
        sub_80A6258(v10[1], *(float *)(v11 + 236));
        v12 = (int)v5;
        if ( *(char *)(a2 + 28) < 0 )
        {
          v6 = (long double)v12 + 180.0;
          v12 = (int)sub_80A6112(v6);
        }
        v7 = v12;
        if ( v12 < 0 )
          v7 = -v12;
        if ( v7 > 90 )
        {
          if ( v12 <= 0 )
            v12 = -90;
          else
            v12 = 90;
        }
        result = (char)v12;
        *(_DWORD *)(v11 + 156) = (char)v12;
      }
    }
  }
  else
  {
    sub_80A6258(*(float *)(v11 + 1412), *(float *)(v11 + 236));
    v12 = (int)a1;
    v9 = (int)a1;
    if ( (int)a1 < 0 )
      v9 = -v9;
    if ( v9 > 90 )
    {
      if ( v12 <= 0 )
        v12 = -90;
      else
        v12 = 90;
    }
    result = (char)v12;
    *(_DWORD *)(v11 + 156) = (char)v12;
  }
  return result;
}
// 80DF868: using guessed type float var_28[7];

//----- (080DFAFC) --------------------------------------------------------
int __cdecl PM_GroundSurfaceType(int a1)
{
  if ( (*(_DWORD *)(a1 + 72) & 0x2000) != 0 )
    return 0;
  else
    return (*(_DWORD *)(a1 + 72) & 0x1F00000) >> 20;
}

//----- (080DFB3A) --------------------------------------------------------
void __usercall sub_80DFB3A(long double a1@<st0>, int a2, int a3)
{
  int v3; // [esp+28h] [ebp-50h]
  float v4; // [esp+2Ch] [ebp-4Ch]
  float v5; // [esp+2Ch] [ebp-4Ch]
  int v6[7]; // [esp+30h] [ebp-48h] BYREF
  float v7; // [esp+4Ch] [ebp-2Ch]
  int v8[2]; // [esp+50h] [ebp-28h] BYREF
  float v9; // [esp+58h] [ebp-20h]
  int i; // [esp+6Ch] [ebp-Ch]

  v3 = *(_DWORD *)a2;
  sub_80DEE4A(a1, *(_DWORD *)a2, a3);
  v4 = sub_80DF3FA(v3, a2 + 4);
  if ( v4 == 0.0 )
  {
    v8[0] = 0;
    v8[1] = 0;
    v9 = 0.0;
  }
  else
  {
    for ( i = 0; i <= 2; ++i )
      *(float *)&v8[i] = v4 * *(float *)(a3 + 4 * i) * (long double)*(char *)(a2 + 28)
                       + v4 * *(float *)(a3 + 4 * i + 12) * (long double)*(char *)(a2 + 29);
  }
  if ( *(_DWORD *)(v3 + 80) )
  {
    v5 = sub_80DF2DE(v3, 0.0, 0.0, 127.0);
    if ( (*(_DWORD *)(a2 + 8) & 0x40) != 0 )
      v9 = v9 - v5 * 127.0;
    if ( *(char *)(a2 + 8) < 0 )
      v9 = v5 * 127.0 + v9;
  }
  sub_80E70CA(v8, v6);
  v7 = Vec3Normalize((float *)v6);
  sub_80DF16A(v3, a3, (float *)v6, v7, 8.0);
  sub_80E7CC0((int *)a2, a3, 0);
}

//----- (080DFCD4) --------------------------------------------------------
int __usercall sub_80DFCD4@<eax>(long double a1@<st0>, int a2, int a3)
{
  long double v3; // fst7
  int v5; // [esp+2Ch] [ebp-7Ch]
  int v6[10]; // [esp+30h] [ebp-78h] BYREF
  float v7; // [esp+58h] [ebp-50h]
  float v8; // [esp+5Ch] [ebp-4Ch]
  int v9[6]; // [esp+60h] [ebp-48h] BYREF
  float v10; // [esp+78h] [ebp-30h]
  float v11; // [esp+7Ch] [ebp-2Ch]
  _DWORD v12[7]; // [esp+80h] [ebp-28h] BYREF
  int i; // [esp+9Ch] [ebp-Ch]

  v5 = *(_DWORD *)a2;
  sub_80DEE4A(a1, *(_DWORD *)a2, a3);
  v11 = (float)*(char *)(a2 + 28);
  v10 = (float)*(char *)(a2 + 29);
  v6[0] = *(_DWORD *)(a2 + 4);
  v6[1] = *(_DWORD *)(a2 + 8);
  v6[2] = *(_DWORD *)(a2 + 12);
  v6[3] = *(_DWORD *)(a2 + 16);
  v6[4] = *(_DWORD *)(a2 + 20);
  v6[5] = *(_DWORD *)(a2 + 24);
  v6[6] = *(_DWORD *)(a2 + 28);
  v7 = sub_80DF3FA(v5, (int)v6);
  *(_DWORD *)(a3 + 8) = 0;
  *(_DWORD *)(a3 + 20) = 0;
  Vec3Normalize((float *)a3);
  Vec3Normalize((float *)(a3 + 12));
  for ( i = 0; i <= 1; ++i )
    *(float *)&v12[i] = *(float *)(a3 + 4 * i) * v11 + *(float *)(a3 + 4 * i + 12) * v10;
  v12[2] = 0;
  sub_80E70CA(v12, v9);
  v8 = Vec3Normalize((float *)v9);
  v3 = v8 * v7;
  v8 = v3;
  sub_80DF16A(v5, a3, (float *)v9, v8, 1.0);
  if ( *(_DWORD *)(a3 + 48) )
    sub_80DEDB0((float *)(v5 + 32), (float *)(a3 + 60), (float *)(v5 + 32));
  sub_80E7CC0((int *)a2, a3, 1);
  return sub_80DF868(v3, a2, a3);
}

//----- (080DFE82) --------------------------------------------------------
int __usercall sub_80DFE82@<eax>(long double a1@<st0>, int a2, int a3)
{
  long double v4; // fst7
  long double v5; // fst7
  long double v6; // fst7
  int v7; // [esp+30h] [ebp-98h]
  int v8; // [esp+34h] [ebp-94h]
  float v9; // [esp+38h] [ebp-90h]
  float v10; // [esp+3Ch] [ebp-8Ch]
  int v11[10]; // [esp+40h] [ebp-88h] BYREF
  float v12; // [esp+68h] [ebp-60h]
  float v13; // [esp+6Ch] [ebp-5Ch]
  int v14[6]; // [esp+70h] [ebp-58h] BYREF
  float v15; // [esp+88h] [ebp-40h]
  float v16; // [esp+8Ch] [ebp-3Ch]
  float v17[4]; // [esp+90h] [ebp-38h] BYREF
  float v18[7]; // [esp+A0h] [ebp-28h] BYREF
  int i; // [esp+BCh] [ebp-Ch]

  v7 = *(_DWORD *)a2;
  if ( (*(_DWORD *)(*(_DWORD *)a2 + 12) & 0x80000) != 0 )
    Jump_ApplySlowdown(v7);
  if ( (unsigned __int8)Jump_Check((int *)a2, (int *)a3) )
    return sub_80DFCD4(a1, a2, a3);
  sub_80DEE4A(a1, v7, a3);
  v16 = (float)*(char *)(a2 + 28);
  v15 = (float)*(char *)(a2 + 29);
  v11[0] = *(_DWORD *)(a2 + 4);
  v11[1] = *(_DWORD *)(a2 + 8);
  v11[2] = *(_DWORD *)(a2 + 12);
  v11[3] = *(_DWORD *)(a2 + 16);
  v11[4] = *(_DWORD *)(a2 + 20);
  v11[5] = *(_DWORD *)(a2 + 24);
  v11[6] = *(_DWORD *)(a2 + 28);
  v12 = sub_80DF534((int *)a2, (int)v11);
  v4 = sub_80DF7FC(*(_DWORD *)(v7 + 144));
  v12 = v4 * v12;
  *(_DWORD *)(v7 + 144) -= (int)(*(float *)(a3 + 36) * 1000.0);
  if ( *(int *)(v7 + 144) <= 0 )
    *(_DWORD *)(v7 + 144) = 0;
  *(_DWORD *)(a3 + 8) = 0;
  *(_DWORD *)(a3 + 20) = 0;
  sub_80DEDB0((float *)a3, (float *)(a3 + 60), (float *)a3);
  sub_80DEDB0((float *)(a3 + 12), (float *)(a3 + 60), (float *)(a3 + 12));
  Vec3Normalize((float *)a3);
  Vec3Normalize((float *)(a3 + 12));
  for ( i = 0; i <= 2; ++i )
    v18[i] = *(float *)(a3 + 4 * i) * v16 + *(float *)(a3 + 4 * i + 12) * v15;
  sub_80E70CA(v18, v14);
  v13 = Vec3Normalize((float *)v14);
  v5 = v13 * v12;
  v13 = v5;
  v8 = PM_GetEffectiveStance(v7);
  if ( (*(_DWORD *)(a3 + 72) & 2) != 0 || (*(_DWORD *)(v7 + 12) & 0x400) != 0 )
  {
    v10 = 1.0;
  }
  else if ( v8 == 1 )
  {
    v10 = 19.0;
  }
  else if ( v8 == 2 )
  {
    v10 = 12.0;
  }
  else
  {
    v10 = 9.0;
  }
  if ( (*(_DWORD *)(v7 + 12) & 0x200) != 0 )
  {
    v5 = v10 * 0.25;
    v10 = v5;
  }
  sub_80DF16A(v7, a3, (float *)v14, v13, v10);
  if ( (*(_DWORD *)(a3 + 72) & 2) != 0 || (*(_DWORD *)(v7 + 12) & 0x400) != 0 )
  {
    v5 = *(float *)(v7 + 40) - (long double)*(int *)(v7 + 72) * *(float *)(a3 + 36);
    *(float *)(v7 + 40) = v5;
  }
  sub_80E72B4((float *)(v7 + 32));
  v9 = v5;
  sub_80E70CA((_DWORD *)(v7 + 32), v17);
  sub_80DEDB0((float *)(v7 + 32), (float *)(a3 + 60), (float *)(v7 + 32));
  if ( sub_80E724C((float *)(v7 + 32), v17) > 0.0 )
  {
    Vec3Normalize((float *)(v7 + 32));
    sub_80E71C0((float *)(v7 + 32), v9, (float *)(v7 + 32));
  }
  v6 = 0.0;
  if ( *(float *)(v7 + 32) != 0.0 || (v6 = 0.0, *(float *)(v7 + 36) != 0.0) )
    sub_80E7CC0((int *)a2, a3, 0);
  return sub_80DF868(v6, a2, a3);
}
// 80DFE82: using guessed type float var_28[7];
// 80DFE82: using guessed type float var_38[4];

//----- (080E02FE) --------------------------------------------------------
float *__usercall sub_80E02FE@<eax>(long double a1@<st0>, int a2, int a3)
{
  float *result; // eax
  float v4; // [esp+14h] [ebp-4h]
  float v5; // [esp+14h] [ebp-4h]

  result = (float *)a3;
  if ( *(_DWORD *)(a3 + 44) )
  {
    sub_80E72B4((float *)(a2 + 32));
    v4 = a1;
    v5 = v4 - 20.0;
    if ( v5 > 0.0 )
    {
      Vec3Normalize((float *)(a2 + 32));
      return sub_80E71C0((float *)(a2 + 32), v5, (float *)(a2 + 32));
    }
    else
    {
      return (float *)sub_80E707C((_DWORD *)(a2 + 32));
    }
  }
  return result;
}

//----- (080E037E) --------------------------------------------------------
float *__usercall sub_80E037E@<eax>(long double a1@<st0>, int a2, int a3)
{
  float v4; // [esp+20h] [ebp-68h]
  int v5; // [esp+24h] [ebp-64h]
  float v6; // [esp+28h] [ebp-60h]
  float v7; // [esp+2Ch] [ebp-5Ch]
  float v8; // [esp+2Ch] [ebp-5Ch]
  int v9[5]; // [esp+30h] [ebp-58h] BYREF
  float v10; // [esp+44h] [ebp-44h]
  float v11; // [esp+48h] [ebp-40h]
  float v12; // [esp+4Ch] [ebp-3Ch]
  float v13[6]; // [esp+50h] [ebp-38h] BYREF
  int i; // [esp+68h] [ebp-20h]
  float v15; // [esp+6Ch] [ebp-1Ch]
  float v16; // [esp+70h] [ebp-18h]
  float v17; // [esp+74h] [ebp-14h]
  float v18; // [esp+78h] [ebp-10h]
  float v19; // [esp+7Ch] [ebp-Ch]

  v5 = *(_DWORD *)a2;
  *(_DWORD *)(v5 + 244) = 60;
  sub_80E72B4((float *)(v5 + 32));
  v19 = a1;
  if ( v19 >= 1.0 )
  {
    v18 = 0.0;
    v17 = *(float *)(friction + 8) * 1.5;
    if ( *(float *)(stopspeed + 8) <= (long double)v19 )
      v4 = v19;
    else
      v4 = *(float *)(stopspeed + 8);
    v16 = v4;
    v18 = v4 * v17 * *(float *)(a3 + 36) + v18;
    v15 = v19 - v18;
    if ( v15 < 0.0 )
      v15 = 0.0;
    v15 = v15 / v19;
    sub_80E71C0((float *)(v5 + 32), v15, (float *)(v5 + 32));
  }
  else
  {
    sub_80E70CA(flt_8145E68, (_DWORD *)(v5 + 32));
  }
  v12 = (float)*(char *)(a2 + 28);
  v11 = (float)*(char *)(a2 + 29);
  v10 = 0.0;
  if ( *(char *)(a2 + 8) < 0 )
    v10 = v10 + 127.0;
  if ( (*(_DWORD *)(a2 + 8) & 0x40) != 0 )
    v10 = v10 - 127.0;
  v6 = sub_80DF2DE(v5, v12, v11, v10);
  for ( i = 0; i <= 2; ++i )
    v13[i] = *(float *)(a3 + 4 * i) * v12 + *(float *)(a3 + 4 * i + 12) * v11 + *(float *)(a3 + 4 * i + 24) * v10;
  sub_80E70CA(v13, v9);
  v7 = Vec3Normalize((float *)v9);
  v8 = v7 * v6;
  sub_80DF16A(v5, a3, (float *)v9, v8, 9.0);
  return sub_80E71F8((float *)(v5 + 20), *(float *)(a3 + 36), (float *)(v5 + 32), (float *)(v5 + 20));
}
// 8145E68: using guessed type float flt_8145E68[3];
// 85760AC: using guessed type int stopspeed;
// 85760B0: using guessed type int friction;
// 80E037E: using guessed type float var_38[6];

//----- (080E05C8) --------------------------------------------------------
float *__cdecl sub_80E05C8(int a1, int a2)
{
  long double v2; // fst7
  float v4; // [esp+2Ch] [ebp-8Ch]
  float v5[4]; // [esp+30h] [ebp-88h] BYREF
  int v6[4]; // [esp+40h] [ebp-78h] BYREF
  int i; // [esp+50h] [ebp-68h]
  int v8; // [esp+54h] [ebp-64h]
  float v9; // [esp+58h] [ebp-60h]
  float v10; // [esp+5Ch] [ebp-5Ch]
  int v11[5]; // [esp+60h] [ebp-58h] BYREF
  float v12; // [esp+74h] [ebp-44h]
  float v13; // [esp+78h] [ebp-40h]
  float v14; // [esp+7Ch] [ebp-3Ch]
  float v15[7]; // [esp+80h] [ebp-38h] BYREF
  float v16; // [esp+9Ch] [ebp-1Ch]
  float v17; // [esp+A0h] [ebp-18h]
  float v18; // [esp+A4h] [ebp-14h]
  float v19; // [esp+A8h] [ebp-10h]
  float v20; // [esp+ACh] [ebp-Ch]

  v8 = *(_DWORD *)a1;
  *(_DWORD *)(v8 + 244) = 60;
  v14 = (float)*(char *)(a1 + 28);
  v13 = (float)*(char *)(a1 + 29);
  v12 = 0.0;
  if ( *(char *)(a1 + 8) < 0 )
    v12 = v12 + 127.0;
  if ( (*(_DWORD *)(a1 + 8) & 0x40) != 0 )
    v12 = v12 - 127.0;
  v2 = 0.0;
  if ( v14 == 0.0 && (v2 = 0.0, v13 == 0.0) && (v2 = 0.0, v12 == 0.0) )
  {
    v20 = 0.0;
  }
  else
  {
    sub_80E72B4((float *)(v8 + 32));
    v20 = v2;
  }
  if ( v20 >= 1.0 )
  {
    v19 = 0.0;
    v18 = *(float *)(friction + 8) * 1.5;
    if ( *(float *)(stopspeed + 8) <= (long double)v20 )
      v4 = v20;
    else
      v4 = *(float *)(stopspeed + 8);
    v17 = v4;
    v19 = v4 * v18 * *(float *)(a2 + 36) + v19;
    v16 = v20 - v19;
    if ( v16 < 0.0 )
      v16 = 0.0;
    v16 = v16 / v20;
    sub_80E71C0((float *)(v8 + 32), v16, (float *)(v8 + 32));
  }
  else
  {
    sub_80E70CA(flt_8145E68, (_DWORD *)(v8 + 32));
  }
  v9 = sub_80DF2DE(v8, v14, v13, v12);
  v6[1] = 0;
  v6[0] = 0;
  v6[2] = 1065353216;
  sub_80A1ED8((float *)v6, (float *)(a2 + 12), v5);
  for ( i = 0; i <= 2; ++i )
    v15[i] = v5[i] * v14 + *(float *)(a2 + 4 * i + 12) * v13 + *(float *)&v6[i] * v12;
  sub_80E70CA(v15, v11);
  v10 = Vec3Normalize((float *)v11);
  v10 = v10 * v9;
  sub_80DF16A(v8, a2, (float *)v11, v10, 9.0);
  return sub_80E71F8((float *)(v8 + 20), *(float *)(a2 + 36), (float *)(v8 + 32), (float *)(v8 + 20));
}
// 8145E68: using guessed type float flt_8145E68[3];
// 85760AC: using guessed type int stopspeed;
// 85760B0: using guessed type int friction;
// 80E05C8: using guessed type float var_88[4];
// 80E05C8: using guessed type float var_38[7];

//----- (080E088C) --------------------------------------------------------
int __cdecl sub_80E088C(int a1, int a2)
{
  int v4; // [esp+14h] [ebp-4h]

  v4 = PM_GroundSurfaceType(a2);
  if ( !v4 )
    return 0;
  if ( (*(_BYTE *)(a1 + 12) & 1) != 0 )
    return v4 + 47;
  if ( (*(_DWORD *)(a1 + 12) & 0x100) != 0 || *(float *)(a1 + 76) != 0.0 )
    return v4 + 24;
  return v4 + 1;
}

//----- (080E0906) --------------------------------------------------------
int __cdecl sub_80E0906(int a1)
{
  int v3; // [esp+14h] [ebp-4h]

  v3 = PM_GroundSurfaceType(a1);
  if ( v3 )
    return v3 + 24;
  else
    return 0;
}

//----- (080E0938) --------------------------------------------------------
int __cdecl sub_80E0938(int a1)
{
  int v3; // [esp+14h] [ebp-4h]

  v3 = PM_GroundSurfaceType(a1);
  if ( v3 )
    return v3 + 1;
  else
    return 0;
}

//----- (080E0968) --------------------------------------------------------
int __cdecl sub_80E0968(int a1)
{
  return PM_GroundSurfaceType(a1) + 93;
}

//----- (080E0984) --------------------------------------------------------
int __cdecl sub_80E0984(int a1)
{
  return PM_GroundSurfaceType(a1) + 116;
}

//----- (080E09A0) --------------------------------------------------------
void __cdecl sub_80E09A0(int a1, int a2)
{
  int v2; // eax
  int v3; // eax
  int v4; // eax
  int v5; // eax
  float v6; // [esp+1Ch] [ebp-4Ch]
  float v7; // [esp+1Ch] [ebp-4Ch]
  int v8; // [esp+30h] [ebp-38h]
  int v9; // [esp+34h] [ebp-34h]
  int v10; // [esp+38h] [ebp-30h]
  float v11; // [esp+3Ch] [ebp-2Ch]
  float v12; // [esp+40h] [ebp-28h]
  float v13; // [esp+4Ch] [ebp-1Ch]
  float v14; // [esp+50h] [ebp-18h]
  float v15; // [esp+58h] [ebp-10h]
  float v16; // [esp+5Ch] [ebp-Ch]
  float v17; // [esp+60h] [ebp-8h]

  v16 = *(float *)(a2 + 104) - *(float *)(a1 + 28);
  v15 = *(float *)(a2 + 116);
  v6 = (float)*(int *)(a1 + 72);
  v13 = COERCE_FLOAT(LODWORD(v6) ^ 0x80000000) * 0.5;
  v12 = v15 * v15 - v13 * 4.0 * v16;
  if ( v12 >= 0.0 )
  {
    v14 = (-v15 - sqrt(v12)) / (v13 + v13);
    v7 = v14 * COERCE_FLOAT(LODWORD(v6) ^ 0x80000000) + v15;
    v17 = COERCE_FLOAT(LODWORD(v7) ^ 0x80000000)
        * COERCE_FLOAT(LODWORD(v7) ^ 0x80000000)
        / ((long double)*(int *)(a1 + 72) + (long double)*(int *)(a1 + 72));
    if ( *(float *)(bg_fallDamageMinHeight + 8) < (long double)*(float *)(bg_fallDamageMaxHeight + 8) )
    {
      if ( *(float *)(bg_fallDamageMinHeight + 8) >= (long double)v17 || (*(_BYTE *)(a2 + 72) & 1) != 0 || *(int *)(a1 + 4) > 5 )
      {
        v9 = 0;
      }
      else if ( v17 < (long double)*(float *)(bg_fallDamageMaxHeight + 8) )
      {
        v9 = sub_80E6EC4(
               (int)((v17 - *(float *)(bg_fallDamageMinHeight + 8))
                   / (*(float *)(bg_fallDamageMaxHeight + 8) - *(float *)(bg_fallDamageMinHeight + 8))
                   * 100.0),
               0,
               100);
      }
      else
      {
        v9 = 100;
      }
    }
    else
    {
      Com_Printf("bg_fallDamageMaxHeight must be greater than bg_fallDamageMinHeight\n");
      v9 = 0;
    }
    if ( v17 > 12.0 )
    {
      v10 = (int)((v17 - 12.0) / 26.0 * 4.0 + 4.0);
      if ( v10 > 24 )
        LOBYTE(v10) = 24;
      BG_AnimScriptEvent((_DWORD *)a1, 5, 0, 1);
    }
    else
    {
      LOBYTE(v10) = 0;
    }
    if ( v9 )
    {
      if ( v9 > 99 || (*(_DWORD *)(a2 + 72) & 2) != 0 )
      {
        sub_80E71C0((float *)(a1 + 32), 0.67000002, (float *)(a1 + 32));
      }
      else
      {
        v8 = 35 * v9 + 500;
        if ( v8 > 2000 )
          v8 = 2000;
        if ( v8 > 500 )
        {
          if ( v8 <= 1499 )
            v11 = 0.5 - ((long double)v8 - 500.0) / 1000.0 * 0.30000001;
          else
            v11 = 0.2;
        }
        else
        {
          v11 = 0.5;
        }
        *(_DWORD *)(a1 + 16) = v8;
        *(_DWORD *)(a1 + 12) |= 0x200u;
        sub_80E71C0((float *)(a1 + 32), v11, (float *)(a1 + 32));
      }
      v2 = sub_80E0984(a2);
      BG_AddPredictableEventToPlayerstate(v2, v9, a1);
    }
    else if ( v17 > 4.0 )
    {
      if ( v17 >= 8.0 )
      {
        if ( v17 >= 12.0 )
        {
          sub_80E71C0((float *)(a1 + 32), 0.67000002, (float *)(a1 + 32));
          v5 = sub_80E0968(a2);
          BG_AddPredictableEventToPlayerstate(v5, v10, a1);
        }
        else
        {
          v4 = sub_80E0938(a2);
          sub_80DED2E(a1, v4);
        }
      }
      else
      {
        v3 = sub_80E0906(a2);
        sub_80DED2E(a1, v3);
      }
    }
  }
}
// 8576098: using guessed type int bg_fallDamageMinHeight;
// 857609C: using guessed type int bg_fallDamageMaxHeight;

//----- (080E0DA2) --------------------------------------------------------
int __cdecl sub_80E0DA2(int *a1, _DWORD *a2, unsigned __int16 *s)
{
  int v5; // [esp+2Ch] [ebp-2Ch]
  int v6[7]; // [esp+30h] [ebp-28h] BYREF
  unsigned int i; // [esp+4Ch] [ebp-Ch]

  v5 = *a1;
  for ( i = 0; i <= 0x19; ++i )
  {
    sub_80E7138((float *)(v5 + 20), (float *)(12 * i + 135585920), (float *)v6);
    sub_80DEC3C((int)a1, s, (int)v6, (int)(a1 + 49), (int)(a1 + 52), (int)v6, *(_DWORD *)(v5 + 204), a1[15]);
    if ( !*((_BYTE *)s + 35) )
    {
      sub_80E70CA(v6, (_DWORD *)(v5 + 20));
      v6[0] = *(_DWORD *)(v5 + 20);
      v6[1] = *(_DWORD *)(v5 + 24);
      *(float *)&v6[2] = *(float *)(v5 + 28) - 1.0;
      sub_80DEC3C((int)a1, s, v5 + 20, (int)(a1 + 49), (int)(a1 + 52), (int)v6, *(_DWORD *)(v5 + 204), a1[15]);
      a2[14] = *(_DWORD *)s;
      a2[15] = *((_DWORD *)s + 1);
      a2[16] = *((_DWORD *)s + 2);
      a2[17] = *((_DWORD *)s + 3);
      a2[18] = *((_DWORD *)s + 4);
      a2[19] = *((_DWORD *)s + 5);
      a2[20] = *((_DWORD *)s + 6);
      a2[21] = *((_DWORD *)s + 7);
      a2[22] = *((_DWORD *)s + 8);
      sub_80DEB7A((float *)(v5 + 20), (float *)v6, *(float *)s, (float *)(v5 + 20));
      return 1;
    }
  }
  *(_DWORD *)(v5 + 96) = 1023;
  a2[12] = 0;
  a2[13] = 0;
  a2[11] = 0;
  Jump_ClearState(v5);
  return 0;
}

//----- (080E0F86) --------------------------------------------------------
_DWORD *__cdecl sub_80E0F86(int a1, _DWORD *a2)
{
  _DWORD *result; // eax
  _DWORD *v3; // [esp+2Ch] [ebp-4Ch]
  int v4[2]; // [esp+30h] [ebp-48h] BYREF
  float v5; // [esp+38h] [ebp-40h]
  float s[14]; // [esp+40h] [ebp-38h] BYREF

  v3 = *(_DWORD **)a1;
  if ( *(_DWORD *)(*(_DWORD *)a1 + 96) == 1023 )
  {
    sub_80E70CA(v3 + 5, v4);
    v5 = v5 - 1.0;
    funcs_80DDC6A[3 * *(unsigned __int8 *)(a1 + 228)](
      s,
      (int)(v3 + 5),
      a1 + 196,
      a1 + 208,
      (int)v4,
      v3[51],
      *(_DWORD *)(a1 + 60));
    a2[13] = 1.0 != s[0];
  }
  else
  {
    sub_80E70CA(v3 + 5, v4);
    v5 = v5 - 64.0;
    funcs_80DDC6A[3 * *(unsigned __int8 *)(a1 + 228)](
      s,
      (int)(v3 + 5),
      a1 + 196,
      a1 + 208,
      (int)v4,
      v3[51],
      *(_DWORD *)(a1 + 60));
    if ( s[0] == 1.0 )
    {
      if ( *(char *)(a1 + 28) < 0 )
        BG_AnimScriptEvent(v3, 4, 0, 1);
      else
        BG_AnimScriptEvent(v3, 3, 0, 1);
      a2[13] = 0;
    }
    else
    {
      a2[13] = s[0] < 0.015625;
    }
  }
  v3[24] = 1023;
  a2[12] = 0;
  result = a2;
  a2[11] = 0;
  return result;
}
// 8166520: using guessed type int (__cdecl *funcs_80DDC6A[2])(void *s, int, int, int, int, int, int);

//----- (080E117E) --------------------------------------------------------
_DWORD *__cdecl sub_80E117E(int *a1, int a2)
{
  long double v2; // fst7
  _DWORD *result; // eax
  int v4; // [esp+2Ch] [ebp-5Ch]
  float s; // [esp+30h] [ebp-58h] BYREF
  int v6; // [esp+34h] [ebp-54h] BYREF
  int v7; // [esp+38h] [ebp-50h]
  float v8; // [esp+3Ch] [ebp-4Ch]
  int v9; // [esp+40h] [ebp-48h]
  int v10; // [esp+44h] [ebp-44h]
  int v11; // [esp+48h] [ebp-40h]
  int v12; // [esp+4Ch] [ebp-3Ch]
  int v13; // [esp+50h] [ebp-38h]
  int v14[4]; // [esp+60h] [ebp-28h] BYREF
  int v15[2]; // [esp+70h] [ebp-18h] BYREF
  float v16; // [esp+78h] [ebp-10h]

  v4 = *a1;
  v15[0] = *(_DWORD *)(*a1 + 20);
  v15[1] = *(_DWORD *)(v4 + 24);
  v14[0] = *(_DWORD *)(v4 + 20);
  v14[1] = *(_DWORD *)(v4 + 24);
  if ( (*(_DWORD *)(v4 + 160) & 0x300) != 0 )
  {
    v16 = *(float *)(v4 + 28);
    v2 = *(float *)(v4 + 28) - 1.0;
  }
  else
  {
    v16 = *(float *)(v4 + 28) + 0.25;
    v2 = *(float *)(v4 + 28) - 0.25;
  }
  *(float *)&v14[2] = v2;
  sub_80DEC3C(
    (int)a1,
    (unsigned __int16 *)&s,
    (int)v15,
    (int)(a1 + 49),
    (int)(a1 + 52),
    (int)v14,
    *(_DWORD *)(v4 + 204),
    a1[15]);
  *(float *)(a2 + 56) = s;
  *(_DWORD *)(a2 + 60) = v6;
  *(_DWORD *)(a2 + 64) = v7;
  *(float *)(a2 + 68) = v8;
  *(_DWORD *)(a2 + 72) = v9;
  *(_DWORD *)(a2 + 76) = v10;
  *(_DWORD *)(a2 + 80) = v11;
  *(_DWORD *)(a2 + 84) = v12;
  *(_DWORD *)(a2 + 88) = v13;
  if ( !BYTE2(v13) || (result = (_DWORD *)sub_80E0DA2(a1, (_DWORD *)a2, (unsigned __int16 *)&s)) != 0 )
  {
    if ( HIBYTE(v13) )
    {
      v16 = *(float *)(v4 + 28) - 0.001;
      sub_80DEC3C(
        (int)a1,
        (unsigned __int16 *)&s,
        (int)v15,
        (int)(a1 + 49),
        (int)(a1 + 52),
        (int)v14,
        *(_DWORD *)(v4 + 204),
        a1[15]);
      if ( HIBYTE(v13) )
      {
        *(_DWORD *)(v4 + 96) = 1023;
        *(_DWORD *)(a2 + 48) = 0;
        *(_DWORD *)(a2 + 52) = 0;
        result = (_DWORD *)a2;
        *(_DWORD *)(a2 + 44) = 0;
        return result;
      }
      *(float *)(a2 + 56) = s;
      *(_DWORD *)(a2 + 60) = v6;
      *(_DWORD *)(a2 + 64) = v7;
      *(float *)(a2 + 68) = v8;
      *(_DWORD *)(a2 + 72) = v9;
      *(_DWORD *)(a2 + 76) = v10;
      *(_DWORD *)(a2 + 80) = v11;
      *(_DWORD *)(a2 + 84) = v12;
      *(_DWORD *)(a2 + 88) = v13;
    }
    if ( s == 1.0 )
    {
      return sub_80E0F86((int)a1, (_DWORD *)a2);
    }
    else if ( (*(_DWORD *)(v4 + 12) & 0x20) != 0
           || *(float *)(v4 + 40) <= 0.0
           || sub_80E724C((float *)(v4 + 32), (float *)&v6) <= 10.0 )
    {
      if ( v8 >= 0.69999999 )
      {
        *(_DWORD *)(a2 + 48) = 1;
        *(_DWORD *)(a2 + 52) = 1;
        *(_DWORD *)(a2 + 44) = 1;
        if ( *(_DWORD *)(v4 + 96) == 1023 )
          sub_80E09A0(v4, a2);
        *(_DWORD *)(v4 + 96) = (unsigned __int16)v12;
        return (_DWORD *)sub_80DED50((int)a1, (unsigned __int16)v12);
      }
      else
      {
        *(_DWORD *)(v4 + 96) = 1023;
        *(_DWORD *)(a2 + 48) = 1;
        *(_DWORD *)(a2 + 52) = 1;
        *(_DWORD *)(a2 + 44) = 0;
        return (_DWORD *)Jump_ClearState(v4);
      }
    }
    else
    {
      if ( *((char *)a1 + 28) < 0 )
        BG_AnimScriptEvent((_DWORD *)v4, 4, 0, 0);
      else
        BG_AnimScriptEvent((_DWORD *)v4, 3, 0, 0);
      *(_DWORD *)(a2 + 52) = 0;
      *(_DWORD *)(v4 + 96) = 1023;
      *(_DWORD *)(a2 + 48) = 0;
      result = (_DWORD *)a2;
      *(_DWORD *)(a2 + 44) = 0;
    }
  }
  return result;
}

//----- (080E1522) --------------------------------------------------------
int __cdecl sub_80E1522(int a1, int a2, int a3)
{
  if ( a2 == 11 )
    return 400;
  if ( a2 != 40 )
    return 200;
  if ( a3 )
    return 200;
  return 400;
}

//----- (080E1562) --------------------------------------------------------
long double __cdecl sub_80E1562(int a1, int a2, float *a3)
{
  float v5; // [esp+4h] [ebp-14h]
  int v6; // [esp+Ch] [ebp-Ch]
  int v7; // [esp+10h] [ebp-8h]

  if ( a1 )
  {
    v6 = a2 + 12;
    v7 = 1;
    do
    {
      if ( a1 == *(_DWORD *)v6 )
      {
        *a3 = (float)*(int *)(v6 + 8);
        return *(float *)(v6 + 4);
      }
      if ( *(_DWORD *)v6 > a1 )
      {
        v5 = (long double)(a1 - *(_DWORD *)(a2 + 12 * v7 - 12))
           / (long double)(*(_DWORD *)v6 - *(_DWORD *)(a2 + 12 * v7 - 12));
        *a3 = (long double)*(int *)(a2 + 12 * v7 - 12 + 8)
            + (long double)(*(_DWORD *)(v6 + 8) - *(_DWORD *)(a2 + 12 * v7 - 12 + 8)) * v5;
        return (float)((*(float *)(v6 + 4) - *(float *)(a2 + 12 * v7 - 12 + 4)) * v5 + *(float *)(a2 + 12 * v7 - 12 + 4));
      }
      ++v7;
      v6 = a2 + 12 * v7;
    }
    while ( *(_DWORD *)v6 != -1 );
    *a3 = (float)*(int *)(a2 + 8);
    return *(float *)(a2 + 4);
  }
  else
  {
    *a3 = (float)*(int *)(a2 + 8);
    return *(float *)(a2 + 4);
  }
}

//----- (080E168A) --------------------------------------------------------
long double __cdecl sub_80E168A(_DWORD *a1, int a2, int a3)
{
  float v5; // [esp+1Ch] [ebp-Ch]
  _DWORD *v6; // [esp+24h] [ebp-4h]

  v6 = (_DWORD *)*a1;
  if ( *(_DWORD *)(*a1 + 252) )
  {
    if ( a2 == -1 || a3 == -1 || a3 == v6[64] && (a3 != 40 || a2 == 11 && !v6[65] || a2 == 60 && v6[65]) )
    {
      v5 = (long double)(a1[1] - v6[63]) / (long double)sub_80E1522((int)v6, v6[64], v6[65]);
      if ( v5 >= 0.0 )
      {
        if ( v5 > 1.0 )
          return 1.0;
      }
      else
      {
        return 0.0;
      }
      return v5;
    }
    else
    {
      return (float)0.0;
    }
  }
  else
  {
    return (float)0.0;
  }
}

//----- (080E178C) --------------------------------------------------------
void __cdecl sub_80E178C(int *a1, int a2)
{
  int v2; // ebx
  int v3; // ebx
  int v4; // ebx
  float v5; // [esp+0h] [ebp-78h]
  int v6[4]; // [esp+30h] [ebp-48h] BYREF
  _DWORD v7[7]; // [esp+40h] [ebp-38h] BYREF
  float v8; // [esp+5Ch] [ebp-1Ch]
  float v9; // [esp+60h] [ebp-18h] BYREF
  int v10; // [esp+64h] [ebp-14h]
  int v11; // [esp+68h] [ebp-10h]
  int v12; // [esp+6Ch] [ebp-Ch]

  v12 = *a1;
  if ( *(_DWORD *)(v12 + 244) && *(float *)(v12 + 248) != 0.0 )
  {
    if ( *(float *)(v12 + 248) != (long double)*(int *)(v12 + 244) || *(_DWORD *)(v12 + 252) )
    {
      v11 = 0;
      if ( *(_DWORD *)(v12 + 244) == 11 || *(_DWORD *)(v12 + 244) == 40 || *(_DWORD *)(v12 + 244) == 60 )
      {
        if ( *(_DWORD *)(v12 + 252) )
        {
          v10 = sub_80E1522(v12, *(_DWORD *)(v12 + 256), *(_DWORD *)(v12 + 260));
          v11 = 100 * (a1[1] - *(_DWORD *)(v12 + 252)) / v10;
          if ( v11 >= 0 )
          {
            if ( v11 > 100 )
              v11 = 100;
          }
          else
          {
            v11 = 0;
          }
          if ( v11 == 100 )
          {
            *(float *)(v12 + 248) = (float)*(int *)(v12 + 256);
            *(_DWORD *)(v12 + 252) = 0;
            *(_DWORD *)(v12 + 264) = 0;
          }
          else
          {
            if ( *(_DWORD *)(v12 + 256) == 11 )
            {
              v2 = v12;
              *(float *)(v2 + 248) = sub_80E1562(v11, (int)&unk_81663E0, &v9);
            }
            else if ( *(_DWORD *)(v12 + 256) == 40 )
            {
              v3 = v12;
              if ( *(_DWORD *)(v12 + 260) )
                *(float *)(v3 + 248) = sub_80E1562(v11, (int)&unk_81662E0, &v9);
              else
                *(float *)(v3 + 248) = sub_80E1562(v11, (int)&unk_81664C0, &v9);
            }
            else
            {
              v4 = v12;
              *(float *)(v4 + 248) = sub_80E1562(v11, (int)&unk_8166360, &v9);
            }
            v5 = *(float *)(v12 + 264) - v9;
            if ( sub_80E6E42(v5) > 0.050000001 )
            {
              sub_80E70CA((_DWORD *)(v12 + 32), v7);
              v8 = v9 - *(float *)(v12 + 264);
              if ( *(_DWORD *)(v12 + 96) == 1023 )
                v8 = v8 * 0.5;
              v8 = v8 / *(float *)(a2 + 36);
              v6[0] = *(_DWORD *)a2;
              v6[1] = *(_DWORD *)(a2 + 4);
              v6[2] = 0;
              Vec3Normalize((float *)v6);
              sub_80E71C0((float *)v6, v8, (float *)(v12 + 32));
              sub_80E7CC0(a1, a2, 1);
              sub_80E70CA(v7, (_DWORD *)(v12 + 32));
              *(float *)(v12 + 264) = v9;
            }
          }
        }
        if ( *(_DWORD *)(v12 + 252) )
        {
          if ( *(_DWORD *)(v12 + 244) != *(_DWORD *)(v12 + 256)
            && (*(_DWORD *)(v12 + 244) < *(_DWORD *)(v12 + 256) && !*(_DWORD *)(v12 + 260)
             || *(_DWORD *)(v12 + 244) > *(_DWORD *)(v12 + 256) && *(_DWORD *)(v12 + 260)) )
          {
            v11 = 100 - v11;
            *(_DWORD *)(v12 + 260) ^= 1u;
            if ( *(_DWORD *)(v12 + 260) )
            {
              if ( *(_DWORD *)(v12 + 256) == 60 )
              {
                *(_DWORD *)(v12 + 256) = 40;
              }
              else if ( *(_DWORD *)(v12 + 256) == 40 )
              {
                *(_DWORD *)(v12 + 256) = 11;
              }
            }
            else if ( *(_DWORD *)(v12 + 256) == 11 )
            {
              *(_DWORD *)(v12 + 256) = 40;
            }
            else if ( *(_DWORD *)(v12 + 256) == 40 )
            {
              *(_DWORD *)(v12 + 256) = 60;
            }
            if ( v11 == 100 )
            {
              *(float *)(v12 + 248) = (float)*(int *)(v12 + 256);
              *(_DWORD *)(v12 + 252) = 0;
              *(_DWORD *)(v12 + 264) = 0;
            }
            else
            {
              v10 = sub_80E1522(v12, *(_DWORD *)(v12 + 256), *(_DWORD *)(v12 + 260));
              *(_DWORD *)(v12 + 252) = a1[1] - (int)((long double)v11 * 0.0099999998 * (long double)v10);
              if ( *(_DWORD *)(v12 + 256) == 11 )
              {
                sub_80E1562(v11, (int)&unk_81663E0, &v9);
              }
              else if ( *(_DWORD *)(v12 + 256) == 40 )
              {
                if ( *(_DWORD *)(v12 + 260) )
                  sub_80E1562(v11, (int)&unk_81662E0, &v9);
                else
                  sub_80E1562(v11, (int)&unk_81664C0, &v9);
              }
              else
              {
                sub_80E1562(v11, (int)&unk_8166360, &v9);
              }
              *(float *)(v12 + 264) = v9;
            }
          }
        }
        else if ( *(float *)(v12 + 248) != (long double)*(int *)(v12 + 244) )
        {
          *(_DWORD *)(v12 + 252) = a1[1];
          switch ( *(_DWORD *)(v12 + 244) )
          {
            case 0xB:
              *(_DWORD *)(v12 + 260) = 1;
              if ( *(float *)(v12 + 248) <= 40.0 )
                *(_DWORD *)(v12 + 256) = 11;
              else
                *(_DWORD *)(v12 + 256) = 40;
              break;
            case 0x28:
              *(_DWORD *)(v12 + 260) = *(float *)(v12 + 248) > (long double)*(int *)(v12 + 244);
              *(_DWORD *)(v12 + 256) = 40;
              break;
            case 0x3C:
              *(_DWORD *)(v12 + 260) = 0;
              if ( *(float *)(v12 + 248) >= 40.0 )
                *(_DWORD *)(v12 + 256) = 60;
              else
                *(_DWORD *)(v12 + 256) = 40;
              break;
          }
        }
      }
      else
      {
        *(_DWORD *)(v12 + 252) = 0;
        if ( (long double)*(int *)(v12 + 244) <= *(float *)(v12 + 248) )
        {
          *(float *)(v12 + 248) = *(float *)(v12 + 248) - *(float *)(a2 + 36) * 180.0;
          if ( (long double)*(int *)(v12 + 244) >= *(float *)(v12 + 248) )
            *(float *)(v12 + 248) = (float)*(int *)(v12 + 244);
        }
        else
        {
          *(float *)(v12 + 248) = *(float *)(a2 + 36) * 180.0 + *(float *)(v12 + 248);
          if ( *(float *)(v12 + 248) >= (long double)*(int *)(v12 + 244) )
            *(float *)(v12 + 248) = (float)*(int *)(v12 + 244);
        }
      }
    }
  }
  else if ( *(_DWORD *)(v12 + 4) == 4 )
  {
    *(_DWORD *)(v12 + 248) = 0;
  }
  else
  {
    *(float *)(v12 + 248) = (float)*(int *)(v12 + 244);
  }
}
// 80E178C: using guessed type _DWORD var_38[7];

//----- (080E1F20) --------------------------------------------------------
void __cdecl sub_80E1F20(int a1, int a2)
{
  unsigned int v2; // eax
  long double v3; // fst7
  float *v4; // ebx
  int v5[2]; // [esp+50h] [ebp-88h] BYREF
  float v6; // [esp+58h] [ebp-80h]
  float v7; // [esp+6Ch] [ebp-6Ch]
  int v8[2]; // [esp+70h] [ebp-68h] BYREF
  float v9; // [esp+78h] [ebp-60h]
  float *v10; // [esp+88h] [ebp-50h]
  int v11; // [esp+8Ch] [ebp-4Ch]
  float s; // [esp+90h] [ebp-48h] BYREF
  float v13; // [esp+94h] [ebp-44h] BYREF
  char v14; // [esp+B2h] [ebp-26h]
  char v15; // [esp+B3h] [ebp-25h]
  _BOOL4 v16; // [esp+C8h] [ebp-10h]
  _BOOL4 v17; // [esp+CCh] [ebp-Ch]

  v10 = *(float **)a1;
  *(_DWORD *)(a1 + 224) = 0;
  if ( *((_DWORD *)v10 + 1) == 4 )
  {
    *(_DWORD *)(a1 + 196) = -1056964608;
    *(_DWORD *)(a1 + 200) = -1056964608;
    *(_DWORD *)(a1 + 204) = -1056964608;
    *(_DWORD *)(a1 + 208) = 1090519040;
    *(_DWORD *)(a1 + 212) = 1090519040;
    *(_DWORD *)(a1 + 216) = 1098907648;
    *((_DWORD *)v10 + 3) &= 0xFFFFFFFC;
    if ( (*(_DWORD *)(a1 + 8) & 0x100) != 0 )
    {
      *(_DWORD *)(a1 + 8) &= ~0x100u;
      BG_AddPredictableEventToPlayerstate(140, 0, (int)v10);
    }
    v10[61] = 0.0;
    v10[62] = 0.0;
  }
  else
  {
    v17 = ((_BYTE)v10[3] & 1) != 0;
    v16 = ((_DWORD)v10[3] & 3) == 0;
    *(float *)(a1 + 196) = v10[347];
    *(float *)(a1 + 200) = v10[348];
    *(float *)(a1 + 208) = v10[350];
    *(float *)(a1 + 212) = v10[351];
    *(float *)(a1 + 204) = v10[349];
    if ( *((int *)v10 + 1) <= 5 )
    {
      if ( ((_DWORD)v10[40] & 0x300) != 0 )
      {
        if ( ((_DWORD)v10[40] & 0x100) == 0 || ((_DWORD)v10[40] & 0x200) != 0 )
        {
          if ( ((_DWORD)v10[40] & 0x200) == 0 || ((_DWORD)v10[40] & 0x100) != 0 )
          {
            *((_DWORD *)v10 + 3) &= 0xFFFFFFFC;
          }
          else
          {
            *((_DWORD *)v10 + 3) |= 2u;
            *((_DWORD *)v10 + 3) &= ~1u;
          }
        }
        else
        {
          *((_DWORD *)v10 + 3) |= 1u;
          *((_DWORD *)v10 + 3) &= ~2u;
        }
      }
      else if ( *((__int16 *)v10 + 6) >= 0 )
      {
        if ( ((_DWORD)v10[3] & 0x20) != 0 && (*(_DWORD *)(a1 + 8) & 0x300) != 0 )
        {
          *(_DWORD *)(a1 + 8) &= 0xFFFFFCFF;
          BG_AddPredictableEventToPlayerstate(140, 0, (int)v10);
        }
        if ( (*(_DWORD *)(a1 + 8) & 0x100) != 0 )
        {
          if ( ((_BYTE)v10[3] & 1) != 0
            || *((_DWORD *)v10 + 24) != 1023
            && sub_80DE734(
                 *((_DWORD *)v10 + 51),
                 v10 + 5,
                 *(_DWORD *)(a1 + 208),
                 1106247680,
                 v10[59],
                 (_DWORD *)v10 + 362,
                 v10 + 363,
                 v10 + 364,
                 0,
                 *((_DWORD *)v10 + 24) != 1023,
                 0,
                 *(_BYTE *)(a1 + 228),
                 0,
                 66.0) )
          {
            *((_DWORD *)v10 + 3) |= 1u;
            *((_DWORD *)v10 + 3) &= ~2u;
          }
          else if ( *((_DWORD *)v10 + 24) != 1023 )
          {
            *((_DWORD *)v10 + 3) |= 0x10000u;
            if ( (*(_DWORD *)(a1 + 8) & 0x2000) == 0 )
            {
              if ( ((_DWORD)v10[3] & 2) != 0 )
                BG_AddPredictableEventToPlayerstate(141, 0, (int)v10);
              else
                BG_AddPredictableEventToPlayerstate(140, 0, (int)v10);
            }
          }
        }
        else if ( (*(_DWORD *)(a1 + 8) & 0x200) != 0 )
        {
          if ( ((_BYTE)v10[3] & 1) != 0 )
          {
            *(_DWORD *)(a1 + 216) = 1112014848;
            funcs_80DDC6A[3 * *(unsigned __int8 *)(a1 + 228)](
              &s,
              (int)(v10 + 5),
              a1 + 196,
              a1 + 208,
              (int)(v10 + 5),
              *((_DWORD *)v10 + 51),
              *(_DWORD *)(a1 + 60) & 0xFDFFFFFF);
            if ( v14 )
            {
              if ( (*(_DWORD *)(a1 + 8) & 0x2000) == 0 )
                BG_AddPredictableEventToPlayerstate(142, 2u, (int)v10);
            }
            else
            {
              BG_AnimScriptEvent(v10, 12, 0, 0);
              *((_DWORD *)v10 + 3) &= ~1u;
              *((_DWORD *)v10 + 3) |= 2u;
            }
          }
          else
          {
            BG_AnimScriptEvent(v10, 13, 0, 0);
            *((_DWORD *)v10 + 3) |= 2u;
          }
        }
        else if ( ((_BYTE)v10[3] & 1) != 0 )
        {
          *(float *)(a1 + 216) = v10[352];
          funcs_80DDC6A[3 * *(unsigned __int8 *)(a1 + 228)](
            &s,
            (int)(v10 + 5),
            a1 + 196,
            a1 + 208,
            (int)(v10 + 5),
            *((_DWORD *)v10 + 51),
            *(_DWORD *)(a1 + 60) & 0xFDFFFFFF);
          if ( v14 )
          {
            *(_DWORD *)(a1 + 216) = 1112014848;
            funcs_80DDC6A[3 * *(unsigned __int8 *)(a1 + 228)](
              &s,
              (int)(v10 + 5),
              a1 + 196,
              a1 + 208,
              (int)(v10 + 5),
              *((_DWORD *)v10 + 51),
              *(_DWORD *)(a1 + 60) & 0xFDFFFFFF);
            if ( v14 )
            {
              if ( (*(_DWORD *)(a1 + 8) & 0x2000) == 0 )
                BG_AddPredictableEventToPlayerstate(142, 1u, (int)v10);
            }
            else
            {
              *((_DWORD *)v10 + 3) &= ~1u;
              *((_DWORD *)v10 + 3) |= 2u;
            }
          }
          else
          {
            BG_AnimScriptEvent(v10, 16, 0, 0);
            *((_DWORD *)v10 + 3) &= 0xFFFFFFFC;
          }
        }
        else if ( ((_DWORD)v10[3] & 2) != 0 )
        {
          *(float *)(a1 + 216) = v10[352];
          funcs_80DDC6A[3 * *(unsigned __int8 *)(a1 + 228)](
            &s,
            (int)(v10 + 5),
            a1 + 196,
            a1 + 208,
            (int)(v10 + 5),
            *((_DWORD *)v10 + 51),
            *(_DWORD *)(a1 + 60) & 0xFDFFFFFF);
          if ( v14 )
          {
            if ( (*(_DWORD *)(a1 + 8) & 0x2000) == 0 )
              BG_AddPredictableEventToPlayerstate(141, 1u, (int)v10);
          }
          else
          {
            BG_AnimScriptEvent(v10, 14, 0, 0);
            *((_DWORD *)v10 + 3) &= ~2u;
          }
        }
      }
      if ( !*((_DWORD *)v10 + 63) )
      {
        if ( ((_BYTE)v10[3] & 1) != 0 )
        {
          if ( *((_DWORD *)v10 + 61) == 60 )
          {
            *((_DWORD *)v10 + 61) = 40;
          }
          else if ( *((_DWORD *)v10 + 61) != 11 )
          {
            *((_DWORD *)v10 + 61) = 11;
            *(_DWORD *)(a1 + 224) = 1;
            sub_80D69B2(v10, 0, 2, 0, 0, 1, 1);
            Jump_ActivateSlowdown((int)v10);
          }
        }
        else if ( *((_DWORD *)v10 + 61) == 11 )
        {
          *((_DWORD *)v10 + 61) = 40;
          *(_DWORD *)(a1 + 224) = 1;
          sub_80D69B2(v10, 0, 2, 0, 0, 1, 1);
        }
        else if ( ((_DWORD)v10[3] & 2) != 0 )
        {
          *((_DWORD *)v10 + 61) = 40;
        }
        else
        {
          *((_DWORD *)v10 + 61) = 60;
        }
      }
      sub_80E178C((int *)a1, a2);
      v11 = PM_GetEffectiveStance((int)v10);
      if ( v11 == 1 )
      {
        *(_DWORD *)(a1 + 216) = 1106247680;
        *((_DWORD *)v10 + 40) |= 8u;
        *((_DWORD *)v10 + 40) &= ~4u;
        *((_DWORD *)v10 + 3) |= 1u;
        *((_DWORD *)v10 + 3) &= ~2u;
      }
      else
      {
        if ( v11 == 2 )
        {
          *(_DWORD *)(a1 + 216) = 1112014848;
          *((_DWORD *)v10 + 40) |= 4u;
          *((_DWORD *)v10 + 40) &= ~8u;
          *((_DWORD *)v10 + 3) |= 2u;
          v2 = (_DWORD)v10[3] & 0xFFFFFFFE;
        }
        else
        {
          *(float *)(a1 + 216) = v10[352];
          *((_DWORD *)v10 + 40) &= 0xFFFFFFF3;
          v2 = (_DWORD)v10[3] & 0xFFFFFFFC;
        }
        *((_DWORD *)v10 + 3) = v2;
      }
      if ( ((_BYTE)v10[3] & 1) != 0 && !v17 )
      {
        if ( *(_BYTE *)(a1 + 28) || *(_BYTE *)(a1 + 29) )
        {
          *((_DWORD *)v10 + 3) &= ~0x800u;
          sub_80EA53E((int)v10);
        }
        sub_80E70CA((_DWORD *)v10 + 5, v5);
        v6 = v6 + 10.0;
        funcs_80DDC6A[3 * *(unsigned __int8 *)(a1 + 228)](
          &s,
          (int)(v10 + 5),
          a1 + 196,
          a1 + 208,
          (int)v5,
          *((_DWORD *)v10 + 51),
          *(_DWORD *)(a1 + 60) & 0xFDFFFFFF);
        sub_80DEB7A(v10 + 5, (float *)v5, s, (float *)v5);
        funcs_80DDC6A[3 * *(unsigned __int8 *)(a1 + 228)](
          &s,
          (int)v5,
          a1 + 196,
          a1 + 208,
          (int)(v10 + 5),
          *((_DWORD *)v10 + 51),
          *(_DWORD *)(a1 + 60) & 0xFDFFFFFF);
        sub_80DEB7A((float *)v5, v10 + 5, s, v10 + 5);
        v10[353] = v10[59];
        sub_80E70CA((_DWORD *)v10 + 5, v8);
        v3 = v9 - 0.25;
        v9 = v3;
        funcs_80DDC6A[3 * *(unsigned __int8 *)(a1 + 228)](
          &s,
          (int)(v10 + 5),
          a1 + 196,
          a1 + 208,
          (int)v8,
          *((_DWORD *)v10 + 51),
          *(_DWORD *)(a1 + 60) & 0xFDFFFFFF);
        if ( v15 || (v3 = s, s >= 1.0) )
        {
          v10[354] = 0.0;
        }
        else
        {
          v4 = v10;
          sub_80A86CC(v10[353], &v13);
          v4[354] = v3;
        }
        sub_80A6258(v10[354], v10[58]);
        v7 = v3;
        if ( v7 >= -45.0 )
        {
          if ( v7 <= 45.0 )
            v10[355] = v10[354];
          else
            v10[355] = v10[58] + 45.0;
        }
        else
        {
          v10[355] = v10[58] - 45.0;
        }
      }
    }
    else
    {
      *(float *)(a1 + 216) = v10[352];
      *((_DWORD *)v10 + 61) = 8;
      sub_80E178C((int *)a1, a2);
    }
  }
}
// 8166520: using guessed type int (__cdecl *funcs_80DDC6A[2])(void *s, int, int, int, int, int, int);

//----- (080E2CDE) --------------------------------------------------------
char __cdecl sub_80E2CDE(int *a1, int a2, char a3, char a4, int a5)
{
  char v5; // dl
  int v6; // eax
  int v7; // eax
  float s[12]; // [esp+20h] [ebp-78h] BYREF
  int v10[4]; // [esp+50h] [ebp-48h] BYREF
  int v11; // [esp+60h] [ebp-38h] BYREF
  float v12; // [esp+64h] [ebp-34h]
  float v13; // [esp+68h] [ebp-30h]
  int v14; // [esp+70h] [ebp-28h] BYREF
  float v15; // [esp+74h] [ebp-24h]
  float v16; // [esp+78h] [ebp-20h]
  float v17; // [esp+80h] [ebp-18h]
  int v18; // [esp+84h] [ebp-14h]
  int v19; // [esp+88h] [ebp-10h]
  int v20; // [esp+8Ch] [ebp-Ch]

  v20 = *a1;
  v5 = (a4 + 64) ^ (a3 + 64);
  LOBYTE(v6) = v5 & 0x80;
  if ( v5 < 0 )
  {
    LOBYTE(v6) = v20;
    if ( *(_DWORD *)(v20 + 96) == 1023 )
    {
      if ( a5 )
      {
        v6 = *(_DWORD *)(v20 + 12) & 0x20;
        if ( v6 )
        {
          sub_80E70CA(a1 + 49, &v14);
          *(float *)&v14 = *(float *)&v14 + 6.0;
          v15 = v15 + 6.0;
          v16 = 8.0;
          sub_80E70CA(a1 + 52, &v11);
          *(float *)&v11 = *(float *)&v11 - 6.0;
          v12 = v12 - 6.0;
          if ( v16 > (long double)v13 )
            v13 = v16;
          v18 = a1[15] & 0xFDFEFFFF;
          v17 = -31.0;
          sub_80E71F8((float *)(v20 + 20), -31.0, (float *)(v20 + 100), (float *)v10);
          sub_80DEC3C(
            (int)a1,
            (unsigned __int16 *)s,
            v20 + 20,
            (int)&v14,
            (int)&v11,
            (int)v10,
            *(_DWORD *)(v20 + 204),
            v18);
          v19 = (LODWORD(s[4]) & 0x1F00000) >> 20;
          if ( s[0] == 1.0 || !v19 )
            v19 = 21;
          LOBYTE(v6) = sub_80DED2E(v20, v19 + 1);
        }
      }
    }
    else if ( a5 )
    {
      v7 = sub_80E088C(v20, a2);
      LOBYTE(v6) = sub_80DED2E(v20, v7);
    }
  }
  return v6;
}

//----- (080E2EA6) --------------------------------------------------------
_BOOL4 __cdecl sub_80E2EA6(int *a1)
{
  int v3; // [esp+Ch] [ebp-Ch]
  int v4; // [esp+10h] [ebp-8h]
  int v5; // [esp+14h] [ebp-4h]

  v3 = *a1;
  v4 = *(_DWORD *)(*a1 + 12) & 0x100;
  v5 = PM_GetEffectiveStance(*a1);
  if ( v5 == 1 || v5 == 2 )
    return 0;
  if ( *(char *)(v3 + 12) >= 0 )
  {
    if ( !v4 )
      return *((float *)a1 + 55) >= (long double)*(float *)(player_footstepsThreshhold + 8);
    return 0;
  }
  if ( v4 )
    return 0;
  return *((float *)a1 + 55) >= (long double)*(float *)(player_footstepsThreshhold + 8);
}
// 85760FC: using guessed type int player_footstepsThreshhold;

//----- (080E2F4E) --------------------------------------------------------
int __cdecl sub_80E2F4E(float a1)
{
  if ( a1 < 0.0 )
    a1 = a1 + 360.0;
  if ( a1 >= 315.0 || a1 < 45.0 )
    return 31;
  if ( a1 < 135.0 )
    return 33;
  if ( a1 >= 225.0 )
    return 34;
  return 32;
}

//----- (080E3008) --------------------------------------------------------
void __cdecl sub_80E3008(int a1, int a2)
{
  long double v2; // fst7
  long double v3; // fst7
  float v4; // [esp+0h] [ebp-68h]
  float v5; // [esp+0h] [ebp-68h]
  int v6; // [esp+14h] [ebp-54h]
  float v7; // [esp+20h] [ebp-48h]
  int v8; // [esp+28h] [ebp-40h]
  int v9; // [esp+28h] [ebp-40h]
  int v10; // [esp+2Ch] [ebp-3Ch]
  char *v11; // [esp+30h] [ebp-38h]
  int v12; // [esp+34h] [ebp-34h]
  int v13; // [esp+40h] [ebp-28h]
  int v14; // [esp+48h] [ebp-20h]
  float v15; // [esp+4Ch] [ebp-1Ch]
  float v16; // [esp+4Ch] [ebp-1Ch]
  float v17; // [esp+50h] [ebp-18h]
  int v18; // [esp+54h] [ebp-14h]
  int v19; // [esp+58h] [ebp-10h]
  int v20; // [esp+5Ch] [ebp-Ch]
  int v21; // [esp+5Ch] [ebp-Ch]
  float v22; // [esp+60h] [ebp-8h]
  float v23; // [esp+60h] [ebp-8h]

  v14 = *(_DWORD *)a1;
  if ( *(int *)(*(_DWORD *)a1 + 4) > 5 )
    return;
  if ( *(int *)(v14 + 204) > 63 )
    v11 = 0;
  else
    v11 = (char *)dword_855A4E0 + 1208 * *(_DWORD *)(v14 + 204) + 736252;
  v13 = *(_DWORD *)(v14 + 148) - *(_DWORD *)(player_dmgtimer_stumbleTime + 8);
  if ( v13 < 0 )
    v13 = 0;
  v4 = *(float *)(v14 + 32) * *(float *)(v14 + 32) + *(float *)(v14 + 36) * *(float *)(v14 + 36);
  *(float *)(a1 + 220) = sub_80E6E5C(v4);
  if ( (*(_DWORD *)(v14 + 160) & 0x300) != 0 )
  {
    if ( (*(_BYTE *)(v14 + 12) & 1) != 0 )
    {
      sub_80D6D82((_DWORD *)v14, 3, 3, 1);
      return;
    }
    if ( (*(_DWORD *)(v14 + 12) & 2) != 0 )
      goto LABEL_11;
    goto LABEL_145;
  }
  v18 = PM_GetEffectiveStance(v14);
  if ( *(_DWORD *)(v14 + 96) == 1023 && *(_DWORD *)(v14 + 4) != 1 )
  {
    if ( (*(_DWORD *)(v14 + 12) & 0x20) != 0 )
    {
      if ( *(_DWORD *)(a1 + 4) - *(_DWORD *)(v14 + 112) <= 299 )
        return;
      v7 = *(float *)(v14 + 40);
      if ( (*(_DWORD *)(v14 + 12) & 0x100) != 0 || *(float *)(v14 + 76) != 0.0 )
        v22 = v7 / (95.25 * 0.40000001) * 0.34999999;
      else
        v22 = v7 / 95.25 * 0.44999999;
      if ( v7 < 0.0 )
        sub_80D6D82((_DWORD *)v14, 3, 19, 1);
      else
        sub_80D6D82((_DWORD *)v14, 3, 18, 1);
      v20 = *(_DWORD *)(v14 + 8);
      *(_DWORD *)(v14 + 8) = (unsigned __int8)(int)((long double)v20 + (long double)*(int *)(a2 + 40) * v22);
      sub_80E2CDE((int *)a1, a2, v20, *(_DWORD *)(v14 + 8), 1);
    }
    if ( v18 == (*(_DWORD *)(v14 + 12) & 3) )
      return;
  }
  v6 = 0;
  if ( (*(_DWORD *)(v14 + 12) & 0x100) != 0 || *(float *)(v14 + 76) != 0.0 )
    v6 = 1;
  if ( *(float *)(player_moveThreshhold + 8) > (long double)*(float *)(a1 + 220) || *(_DWORD *)(v14 + 4) == 1 )
  {
    if ( *(float *)(a1 + 220) < 1.0 )
      *(_DWORD *)(v14 + 8) = 0;
    v10 = 0;
    if ( v11 && *(_BYTE *)(player_turnAnims + 8) )
    {
      if ( v11[1204] && *((_DWORD *)v11 + 300) )
        Com_DPrintf(
          "turn anim end time is %i, time is %i\n",
          *((_DWORD *)v11 + 300),
          *((_DWORD *)dword_855A4E0 + 184055));
      if ( *((_DWORD *)v11 + 225) )
      {
        if ( *((float *)v11 + 224) <= (long double)*((float *)v11 + 236) )
          v10 = 15;
        else
          v10 = 14;
        *((_DWORD *)v11 + 224) = *((_DWORD *)v11 + 236);
        v11[1204] = v10;
        if ( *((_DWORD *)v11 + 300) < *((_DWORD *)dword_855A4E0 + 184055) )
          *((_DWORD *)v11 + 300) = 0;
      }
      else
      {
        if ( *((_DWORD *)v11 + 300) > *((_DWORD *)dword_855A4E0 + 184055) )
        {
          *((_DWORD *)v11 + 224) = *((_DWORD *)v11 + 236);
          return;
        }
        if ( *((_DWORD *)v11 + 300) )
        {
          *((_DWORD *)v11 + 300) = 0;
          *((_DWORD *)v11 + 224) = *((_DWORD *)v11 + 236);
        }
      }
    }
    if ( *(_DWORD *)(v14 + 244) == 11 )
    {
      v8 = sub_80D6D82((_DWORD *)v14, 3, 3, 1);
    }
    else if ( *(_DWORD *)(v14 + 244) == 40 )
    {
      if ( v10 == 14 )
      {
        v8 = sub_80D6D82((_DWORD *)v14, 3, 16, 1);
        if ( v8 > 0 && !*((_DWORD *)v11 + 300) )
          *((_DWORD *)v11 + 300) = *((_DWORD *)dword_855A4E0 + 184055) + *(_DWORD *)(v14 + 136);
      }
      else if ( v10 == 15 )
      {
        v8 = sub_80D6D82((_DWORD *)v14, 3, 17, 1);
        if ( v8 > 0 && !*((_DWORD *)v11 + 300) )
          *((_DWORD *)v11 + 300) = *((_DWORD *)dword_855A4E0 + 184055) + *(_DWORD *)(v14 + 136);
      }
      else
      {
        v8 = sub_80D6D82((_DWORD *)v14, 3, 2, 1);
      }
    }
    else if ( v10 == 14 )
    {
      v8 = sub_80D6D82((_DWORD *)v14, 3, 14, 1);
      if ( v8 > 0 && !*((_DWORD *)v11 + 300) )
        *((_DWORD *)v11 + 300) = *((_DWORD *)dword_855A4E0 + 184055) + *(_DWORD *)(v14 + 136);
    }
    else if ( v10 == 15 )
    {
      v8 = sub_80D6D82((_DWORD *)v14, 3, 15, 1);
      if ( v8 > 0 && !*((_DWORD *)v11 + 300) )
        *((_DWORD *)v11 + 300) = *((_DWORD *)dword_855A4E0 + 184055) + *(_DWORD *)(v14 + 136);
    }
    else
    {
      if ( *(_DWORD *)(v14 + 144) > v13 )
      {
        v5 = (float)*(int *)(v14 + 152);
        v12 = sub_80E2F4E(v5);
        sub_80D6D82((_DWORD *)v14, 3, v12, 1);
        return;
      }
      v8 = sub_80D6D82((_DWORD *)v14, 3, 1, 1);
    }
    if ( v8 < 0 )
    {
      if ( *(_DWORD *)(v14 + 244) == 40 )
      {
LABEL_11:
        sub_80D6D82((_DWORD *)v14, 3, 2, 1);
        return;
      }
      if ( *(_DWORD *)(v14 + 144) <= v13 )
        goto LABEL_145;
      goto LABEL_74;
    }
    return;
  }
  v17 = (float)*(int *)(v14 + 80);
  if ( *(_BYTE *)(a1 + 28) )
  {
    if ( *(_BYTE *)(a1 + 29) )
    {
      v17 = ((*(float *)(player_strafeSpeedScale + 8) - 1.0) * 0.75 + 1.0 + 1.0) * 0.5 * v17;
      if ( *(char *)(a1 + 28) < 0 )
        v17 = (*(float *)(player_backSpeedScale + 8) + 1.0) * 0.5 * v17;
    }
    else if ( *(char *)(a1 + 28) < 0 )
    {
      v17 = v17 * *(float *)(player_backSpeedScale + 8);
    }
    sub_80D70E2(*(_DWORD *)(v14 + 204), 8, 0, 1);
  }
  else if ( *(_BYTE *)(a1 + 29) )
  {
    v17 = ((*(float *)(player_strafeSpeedScale + 8) - 1.0) * 0.75 + 1.0) * v17;
    if ( *(char *)(a1 + 29) <= 0 )
      sub_80D70E2(*(_DWORD *)(v14 + 204), 8, 1, 1);
    else
      sub_80D70E2(*(_DWORD *)(v14 + 204), 8, 2, 1);
  }
  if ( v6 )
    v17 = v17 * 0.40000001;
  v15 = sub_80E168A((_DWORD *)a1, 40, 11);
  if ( v15 == 0.0 )
  {
    v16 = sub_80E168A((_DWORD *)a1, 11, 40);
    if ( v16 == 0.0 )
    {
      if ( v18 == 1 )
      {
        v17 = v17 * 0.15000001;
      }
      else if ( v18 == 2 )
      {
        v17 = v17 * 0.64999998;
      }
    }
    else
    {
      v17 = (v16 * 0.64999998 + (1.0 - v16) * 0.15000001) * v17;
    }
  }
  else
  {
    v17 = (v15 * 0.15000001 + (1.0 - v15) * 0.64999998) * v17;
  }
  if ( v18 == 1 )
  {
    if ( v6 )
      v2 = *(float *)(a1 + 220) / v17 * 0.23999999;
    else
      v2 = *(float *)(a1 + 220) / v17 * 0.25;
    v23 = v2;
    if ( *(char *)(v14 + 12) >= 0 )
      v9 = sub_80D6D82((_DWORD *)v14, 3, 8, 1);
    else
      v9 = sub_80D6D82((_DWORD *)v14, 3, 9, 1);
  }
  else if ( v18 == 2 )
  {
    if ( v6 )
      v3 = *(float *)(a1 + 220) / v17 * 0.315;
    else
      v3 = *(float *)(a1 + 220) / v17 * 0.34;
    v23 = v3;
    if ( *(char *)(v14 + 12) >= 0 )
    {
      if ( v6 )
      {
        if ( *(_DWORD *)(v14 + 144) <= v13 )
        {
          v9 = sub_80D6D82((_DWORD *)v14, 3, 6, 1);
          goto LABEL_136;
        }
      }
      else if ( *(_DWORD *)(v14 + 144) <= v13 )
      {
        v9 = sub_80D6D82((_DWORD *)v14, 3, 12, 1);
        goto LABEL_136;
      }
      v9 = sub_80D6D82((_DWORD *)v14, 3, 39, 1);
    }
    else
    {
      if ( v6 )
      {
        if ( *(_DWORD *)(v14 + 144) <= v13 )
        {
          v9 = sub_80D6D82((_DWORD *)v14, 3, 7, 1);
          goto LABEL_136;
        }
      }
      else if ( *(_DWORD *)(v14 + 144) <= v13 )
      {
        v9 = sub_80D6D82((_DWORD *)v14, 3, 13, 1);
        goto LABEL_136;
      }
      v9 = sub_80D6D82((_DWORD *)v14, 3, 40, 1);
    }
  }
  else if ( *(char *)(v14 + 12) >= 0 )
  {
    if ( v6 )
    {
      v23 = *(float *)(a1 + 220) / v17 * 0.30500001;
      if ( *(_DWORD *)(v14 + 144) <= v13 )
        v9 = sub_80D6D82((_DWORD *)v14, 3, 4, 1);
      else
        v9 = sub_80D6D82((_DWORD *)v14, 3, 37, 1);
    }
    else
    {
      v23 = *(float *)(a1 + 220) / v17 * 0.33500001;
      if ( *(_DWORD *)(v14 + 144) <= v13 )
        v9 = sub_80D6D82((_DWORD *)v14, 3, 10, 1);
      else
        v9 = sub_80D6D82((_DWORD *)v14, 3, 35, 1);
    }
  }
  else if ( v6 )
  {
    v23 = *(float *)(a1 + 220) / v17 * 0.32499999;
    if ( *(_DWORD *)(v14 + 144) <= v13 )
      v9 = sub_80D6D82((_DWORD *)v14, 3, 5, 1);
    else
      v9 = sub_80D6D82((_DWORD *)v14, 3, 38, 1);
  }
  else
  {
    v23 = *(float *)(a1 + 220) / v17 * 0.36000001;
    if ( *(_DWORD *)(v14 + 144) <= v13 )
      v9 = sub_80D6D82((_DWORD *)v14, 3, 11, 1);
    else
      v9 = sub_80D6D82((_DWORD *)v14, 3, 36, 1);
  }
LABEL_136:
  v19 = sub_80E2EA6((int *)a1);
  v21 = *(_DWORD *)(v14 + 8);
  *(_DWORD *)(v14 + 8) = (unsigned __int8)(int)((long double)v21 + (long double)*(int *)(a2 + 40) * v23);
  if ( *(_BYTE *)(a1 + 28) || *(_BYTE *)(a1 + 29) )
  {
    if ( v9 < 0 )
      sub_80D6D82((_DWORD *)v14, 3, 1, 1);
    sub_80E2CDE((int *)a1, a2, v21, *(_DWORD *)(v14 + 8), v19);
  }
  else if ( *(float *)(a1 + 220) <= 120.0 )
  {
    if ( *(_DWORD *)(v14 + 244) == 11 )
    {
      v9 = sub_80D6D82((_DWORD *)v14, 3, 3, 1);
    }
    else if ( *(_DWORD *)(v14 + 244) == 40 )
    {
      v9 = sub_80D6D82((_DWORD *)v14, 3, 2, 1);
    }
    if ( v9 < 0 )
    {
      if ( *(_DWORD *)(v14 + 144) <= v13 )
      {
LABEL_145:
        sub_80D6D82((_DWORD *)v14, 3, 1, 1);
        return;
      }
LABEL_74:
      sub_80D6D82((_DWORD *)v14, 3, 31, 1);
    }
  }
}
// 85760F8: using guessed type int player_moveThreshhold;
// 8576100: using guessed type int player_strafeSpeedScale;
// 8576104: using guessed type int player_backSpeedScale;
// 857610C: using guessed type int player_turnAnims;
// 857611C: using guessed type int player_dmgtimer_stumbleTime;
// 8576120: using guessed type int player_dmgtimer_flinchTime;

//----- (080E4060) --------------------------------------------------------
void __cdecl sub_80E4060(int a1)
{
  int v1; // [esp+2Ch] [ebp-6Ch]
  int v2[4]; // [esp+30h] [ebp-68h] BYREF
  int v3[4]; // [esp+40h] [ebp-58h] BYREF
  unsigned __int16 s[17]; // [esp+50h] [ebp-48h] BYREF
  char v5; // [esp+73h] [ebp-25h]
  int v6; // [esp+88h] [ebp-10h]
  float v7; // [esp+8Ch] [ebp-Ch]

  v1 = *(_DWORD *)a1;
  if ( *(float *)(bg_foliagesnd_minspeed + 8) <= (long double)*(float *)(a1 + 220) )
  {
    v7 = (*(float *)(a1 + 220) - *(float *)(bg_foliagesnd_minspeed + 8))
       / (*(float *)(bg_foliagesnd_maxspeed + 8) - *(float *)(bg_foliagesnd_minspeed + 8));
    if ( v7 > 1.0 )
      v7 = 1.0;
    v6 = (int)((long double)(*(_DWORD *)(bg_foliagesnd_fastinterval + 8) - *(_DWORD *)(bg_foliagesnd_slowinterval + 8)) * v7
             + (long double)*(int *)(bg_foliagesnd_slowinterval + 8));
    if ( v6 + *(_DWORD *)(v1 + 68) < *(_DWORD *)(a1 + 4) )
    {
      sub_80E71C0((float *)(a1 + 196), 0.75, (float *)v3);
      sub_80E71C0((float *)(a1 + 208), 0.75, (float *)v2);
      *(float *)&v2[2] = *(float *)(a1 + 216) * 0.89999998;
      sub_80DEC3C(a1, s, v1 + 20, (int)v3, (int)v2, v1 + 20, *(_DWORD *)(v1 + 204), 2);
      if ( v5 )
      {
        sub_80DED2E(v1, 139);
        *(_DWORD *)(v1 + 68) = *(_DWORD *)(a1 + 4);
      }
    }
  }
  else if ( *(_DWORD *)(bg_foliagesnd_resetinterval + 8) + *(_DWORD *)(v1 + 68) < *(_DWORD *)(a1 + 4) )
  {
    *(_DWORD *)(v1 + 68) = 0;
  }
}
// 8576084: using guessed type int bg_foliagesnd_minspeed;
// 8576088: using guessed type int bg_foliagesnd_maxspeed;
// 857608C: using guessed type int bg_foliagesnd_slowinterval;
// 8576090: using guessed type int bg_foliagesnd_fastinterval;
// 8576094: using guessed type int bg_foliagesnd_resetinterval;
// 80E4060: using guessed type unsigned __int16 s[17];

//----- (080E4212) --------------------------------------------------------
_DWORD *__cdecl sub_80E4212(_DWORD *a1, int a2)
{
  _DWORD *result; // eax

  if ( a1[4] )
  {
    if ( *(_DWORD *)(a2 + 40) < a1[4] )
    {
      a1[4] -= *(_DWORD *)(a2 + 40);
    }
    else
    {
      a1[3] &= 0xFFF7F9FF;
      a1[4] = 0;
    }
  }
  if ( (int)a1[30] > 0 )
  {
    a1[30] -= *(_DWORD *)(a2 + 40);
    if ( (int)a1[30] < 0 )
      a1[30] = 0;
  }
  result = a1;
  if ( (int)a1[32] > 0 )
  {
    a1[32] -= *(_DWORD *)(a2 + 40);
    result = a1;
    if ( (int)a1[32] < 0 )
    {
      result = a1;
      a1[32] = 0;
    }
  }
  return result;
}

//----- (080E42D0) --------------------------------------------------------
void __cdecl sub_80E42D0(
        int a1,
        float a2,
        int a3,
        void (__cdecl *a4)(float *, _DWORD *, _DWORD *, _DWORD *, int *, _DWORD, int))
{
  float v4; // [esp+34h] [ebp-94h]
  float v5; // [esp+34h] [ebp-94h]
  float v6; // [esp+3Ch] [ebp-8Ch]
  float v7[14]; // [esp+40h] [ebp-88h] BYREF
  float v8; // [esp+78h] [ebp-50h]
  int v9; // [esp+7Ch] [ebp-4Ch]
  _DWORD v10[4]; // [esp+80h] [ebp-48h] BYREF
  _DWORD v11[4]; // [esp+90h] [ebp-38h] BYREF
  int v12[4]; // [esp+A0h] [ebp-28h] BYREF
  _DWORD v13[2]; // [esp+B0h] [ebp-18h] BYREF
  float v14; // [esp+B8h] [ebp-10h]

  v9 = 0;
  v8 = 0.0;
  if ( (*(_BYTE *)(a3 + 4) & 0xC0) != 0
    && *(__int16 *)(a1 + 12) >= 0
    && *(int *)(a1 + 4) <= 5
    && (*(_DWORD *)(a1 + 96) != 1023 || *(_DWORD *)(a1 + 4) == 1) )
  {
    if ( (*(_DWORD *)(a3 + 4) & 0x40) != 0 )
      --v9;
    if ( *(char *)(a3 + 4) < 0 )
      ++v9;
  }
  if ( (*(_DWORD *)(a1 + 160) & 0x300) != 0 )
    v9 = 0;
  if ( PM_GetEffectiveStance(a1) == 1 )
    v6 = 0.25;
  else
    v6 = 0.5;
  v8 = *(float *)(a1 + 76);
  if ( v9 )
  {
    if ( v9 <= 0 )
    {
      if ( v8 > -v6 )
        v8 = v8 - a2 / 350.0 * v6;
      if ( -v6 > (long double)v8 )
        LODWORD(v8) = LODWORD(v6) ^ 0x80000000;
    }
    else
    {
      if ( v6 > (long double)v8 )
        v8 = a2 / 350.0 * v6 + v8;
      if ( v8 > (long double)v6 )
        v8 = v6;
    }
  }
  else if ( v8 <= 0.0 )
  {
    if ( v8 < 0.0 )
    {
      v8 = a2 / 280.0 * v6 + v8;
      if ( v8 > 0.0 )
        v8 = 0.0;
    }
  }
  else
  {
    v8 = v8 - a2 / 280.0 * v6;
    if ( v8 < 0.0 )
      v8 = 0.0;
  }
  *(float *)(a1 + 76) = v8;
  if ( *(float *)(a1 + 76) != 0.0 )
  {
    v4 = (float)(int)sub_80E6F12(*(_DWORD *)(a1 + 76));
    sub_80E70CA((_DWORD *)(a1 + 20), v13);
    v14 = v14 + *(float *)(a1 + 248);
    sub_80E70CA(v13, v12);
    sub_80B66C0((float *)v12, *(_DWORD *)(a1 + 236), v4, 16.0, 20.0);
    sub_80E70A6(v11, -1056964608, -1056964608, -1056964608);
    sub_80E70A6(v10, 1090519040, 1090519040, 1090519040);
    a4(v7, v13, v11, v10, v12, *(_DWORD *)(a1 + 204), 42008593);
    v5 = sub_80B66A6(v7[0]);
    if ( sub_80E6E42(*(float *)(a1 + 76)) > v5 )
      *(float *)(a1 + 76) = (long double)(int)sub_80E6F12(*(_DWORD *)(a1 + 76)) * v5;
  }
}
// 80E42D0: using guessed type _DWORD var_18[2];
// 80E42D0: using guessed type _DWORD var_38[4];
// 80E42D0: using guessed type _DWORD var_48[4];
// 80E42D0: using guessed type float var_88[14];

//----- (080E4688) --------------------------------------------------------
int __usercall sub_80E4688@<eax>(long double a1@<st0>, int a2, float a3, unsigned __int8 a4)
{
  float v5; // [esp+0h] [ebp-58h]
  float v6; // [esp+44h] [ebp-14h]
  float v7; // [esp+48h] [ebp-10h]
  float v8; // [esp+4Ch] [ebp-Ch]
  float v9; // [esp+50h] [ebp-8h]

  sub_80A6258(a3, *(float *)(a2 + 236));
  v9 = a1;
  v7 = sub_80E6E42(v9) / 240.0;
  v5 = a3 - (1.0 - v7) * v9;
  v8 = sub_80A6154(v5);
  v6 = v7 * 45.0 + (1.0 - v7) * 66.0;
  return sub_80DE734(
           *(_DWORD *)(a2 + 204),
           (float *)(a2 + 20),
           *(_DWORD *)(a2 + 1400),
           1106247680,
           v8,
           (_DWORD *)(a2 + 1448),
           (float *)(a2 + 1452),
           (float *)(a2 + 1456),
           1,
           *(_DWORD *)(a2 + 96) != 1023,
           0,
           a4,
           0,
           v6);
}

//----- (080E4794) --------------------------------------------------------
void __cdecl sub_80E4794(int a1, float a2, int a3, unsigned __int8 a4)
{
  long double v4; // fst7
  long double v5; // fst7
  int k; // eax
  long double v7; // fst7
  long double v8; // fst7
  int m; // eax
  long double v10; // fst7
  long double v11; // fst7
  float v12; // [esp+0h] [ebp-88h]
  float v13; // [esp+0h] [ebp-88h]
  float v14; // [esp+0h] [ebp-88h]
  float v15; // [esp+0h] [ebp-88h]
  float v16; // [esp+0h] [ebp-88h]
  float v17; // [esp+0h] [ebp-88h]
  float v18; // [esp+0h] [ebp-88h]
  float v19; // [esp+0h] [ebp-88h]
  int v20; // [esp+44h] [ebp-44h]
  int v21; // [esp+48h] [ebp-40h]
  float v22; // [esp+4Ch] [ebp-3Ch]
  float v23; // [esp+50h] [ebp-38h]
  float v24; // [esp+54h] [ebp-34h]
  float v25; // [esp+54h] [ebp-34h]
  int v26; // [esp+58h] [ebp-30h]
  float v27; // [esp+5Ch] [ebp-2Ch]
  float v28; // [esp+60h] [ebp-28h]
  _BOOL4 v29; // [esp+64h] [ebp-24h]
  _BOOL4 v30; // [esp+64h] [ebp-24h]
  int v31; // [esp+68h] [ebp-20h]
  int v32; // [esp+68h] [ebp-20h]
  float v33; // [esp+6Ch] [ebp-1Ch]
  float v34; // [esp+6Ch] [ebp-1Ch]
  float v35; // [esp+70h] [ebp-18h]
  float v36; // [esp+70h] [ebp-18h]
  float v37; // [esp+70h] [ebp-18h]
  float v38; // [esp+70h] [ebp-18h]
  float v39; // [esp+70h] [ebp-18h]
  float v40; // [esp+70h] [ebp-18h]
  float v41; // [esp+70h] [ebp-18h]
  float v42; // [esp+70h] [ebp-18h]
  float v43; // [esp+70h] [ebp-18h]
  int i; // [esp+74h] [ebp-14h]
  int j; // [esp+74h] [ebp-14h]
  __int16 v46; // [esp+78h] [ebp-10h]

  if ( *(_DWORD *)(a1 + 4) != 5 )
  {
    if ( *(int *)(a1 + 4) > 5 )
    {
      if ( *(_DWORD *)(a1 + 304) == 999 )
        *(_DWORD *)(a1 + 304) = (int)((long double)(__int16)(*(_WORD *)(a1 + 88) + *(_WORD *)(a3 + 16)) * 0.0054931641);
LABEL_106:
      sub_80E42D0(
        a1,
        a2,
        a3,
        (void (__cdecl *)(float *, _DWORD *, _DWORD *, _DWORD *, int *, _DWORD, int))funcs_80DDC6A[3 * a4]);
      return;
    }
    v28 = *(float *)(a1 + 236);
    v21 = (unsigned __int16)(int)(*(float *)(player_view_pitch_up + 8) * 182.04445);
    v4 = *(float *)(player_view_pitch_down + 8) * 182.04445;
    v20 = (unsigned __int16)(int)v4;
    for ( i = 0; i <= 2; ++i )
    {
      v46 = *(_WORD *)(a1 + 4 * i + 84) + *(_WORD *)(a3 + 4 * i + 12);
      if ( !i )
      {
        if ( v46 <= v20 )
        {
          if ( v46 < -v21 )
          {
            *(_DWORD *)(a1 + 4 * i + 84) = -v21 - *(_DWORD *)(a3 + 4 * i + 12);
            v46 = -(__int16)v21;
          }
        }
        else
        {
          *(_DWORD *)(a1 + 4 * i + 84) = v20 - *(_DWORD *)(a3 + 4 * i + 12);
          v46 = v20;
        }
      }
      v4 = (long double)v46 * 0.0054931641;
      *(float *)(a1 + 4 * i + 232) = v4;
    }
    v27 = *(float *)(a1 + 236);
    if ( (*(_DWORD *)(a1 + 160) & 0x300) != 0 )
    {
      for ( j = 0; j <= 1; ++j )
      {
        sub_80A6258(*(float *)(a1 + 4 * j + 268), *(float *)(a1 + 4 * j + 232));
        v35 = v4;
        if ( v35 <= (long double)*(float *)(a1 + 4 * j + 276) )
        {
          v4 = v35;
          if ( -*(float *)(a1 + 4 * j + 276) <= (long double)v35 )
            continue;
        }
        if ( v35 <= (long double)*(float *)(a1 + 4 * j + 276) )
          v36 = v35 + *(float *)(a1 + 4 * j + 276);
        else
          v36 = v35 - *(float *)(a1 + 4 * j + 276);
        *(_DWORD *)(a1 + 4 * j + 84) += (unsigned __int16)(int)(v36 * 182.04445);
        if ( v36 <= 0.0 )
          v12 = *(float *)(a1 + 4 * j + 268) + *(float *)(a1 + 4 * j + 276);
        else
          v12 = *(float *)(a1 + 4 * j + 268) - *(float *)(a1 + 4 * j + 276);
        v4 = sub_80A6154(v12);
        *(float *)(a1 + 4 * j + 232) = v4;
      }
    }
    else
    {
      if ( (*(_DWORD *)(a1 + 12) & 4) != 0 )
      {
        sub_80DBD56(v4, a1);
        return;
      }
      if ( (*(_DWORD *)(a1 + 12) & 0x20) != 0 && *(_DWORD *)(a1 + 96) == 1023 )
      {
        v4 = 0.0;
        if ( *(float *)(bg_ladder_yawcap + 8) != 0.0 )
        {
          v22 = sub_80A29F6((float *)(a1 + 100)) + 180.0;
          sub_80A6258(v22, *(float *)(a1 + 236));
          if ( v22 > (long double)*(float *)(bg_ladder_yawcap + 8)
            || (v4 = v22, -*(float *)(bg_ladder_yawcap + 8) > (long double)v22) )
          {
            if ( v22 <= (long double)*(float *)(bg_ladder_yawcap + 8) )
              v37 = v22 + *(float *)(bg_ladder_yawcap + 8);
            else
              v37 = v22 - *(float *)(bg_ladder_yawcap + 8);
            *(_DWORD *)(a1 + 88) += (unsigned __int16)(int)(v37 * 182.04445);
            if ( v37 <= 0.0 )
              v13 = v22 + *(float *)(bg_ladder_yawcap + 8);
            else
              v13 = v22 - *(float *)(bg_ladder_yawcap + 8);
            v4 = sub_80A6154(v13);
            *(float *)(a1 + 236) = v4;
          }
        }
      }
      if ( (*(_BYTE *)(a1 + 12) & 1) != 0 && (*(_DWORD *)(a1 + 160) & 0x300) == 0 )
      {
        v26 = 0;
        sub_80A6258(*(float *)(a1 + 1412), *(float *)(a1 + 236));
        v38 = v4;
        if ( v38 > *(float *)(bg_prone_yawcap + 8) - 5.0
          || (v5 = v38, -(*(float *)(bg_prone_yawcap + 8) - 5.0) > v38)
          || (*(_BYTE *)(a3 + 24) || *(_BYTE *)(a3 + 25)) && (v5 = 0.0, v38 != 0.0) )
        {
          v5 = sub_80E6E42(v38);
          if ( a2 * 55.0 * 0.001 <= v5 )
          {
            if ( v38 <= 0.0 )
              v5 = a2 * 55.0 * 0.001 + *(float *)(a1 + 1412);
            else
              v5 = *(float *)(a1 + 1412) - a2 * 55.0 * 0.001;
            v33 = v5;
          }
          else
          {
            v33 = *(float *)(a1 + 236);
          }
          v29 = 1;
          for ( k = sub_80E4688(v5, a1, v33, a4); !k; k = sub_80E4688(v5, a1, v33, a4) )
          {
            if ( !v29 )
              goto LABEL_68;
            sub_80A6258(*(float *)(a1 + 1412), v33);
            v39 = v5;
            v7 = sub_80E6E42(v39);
            v29 = v7 > 1.0;
            if ( v7 <= 1.0 )
            {
              v26 = 1;
            }
            else if ( v39 <= 0.0 )
            {
              v39 = -1.0;
            }
            else
            {
              v39 = 1.0;
            }
            v14 = v33 + v39;
            v5 = sub_80A6154(v14);
            v33 = v5;
          }
          v31 = sub_80DE734(
                  *(_DWORD *)(a1 + 204),
                  (float *)(a1 + 20),
                  *(_DWORD *)(a1 + 1400),
                  1106247680,
                  *(float *)(a1 + 236),
                  0,
                  0,
                  0,
                  1,
                  *(_DWORD *)(a1 + 96) != 1023,
                  0,
                  a4,
                  0,
                  45.0);
          if ( v31 )
          {
            v31 = sub_80DE734(
                    *(_DWORD *)(a1 + 204),
                    (float *)(a1 + 20),
                    *(_DWORD *)(a1 + 1400),
                    1106247680,
                    v33,
                    0,
                    0,
                    0,
                    1,
                    *(_DWORD *)(a1 + 96) != 1023,
                    0,
                    a4,
                    0,
                    45.0);
            if ( v31 )
              *(float *)(a1 + 1412) = v33;
          }
          if ( !v31 )
            v26 = 1;
        }
LABEL_68:
        sub_80A6258(*(float *)(a1 + 1412), *(float *)(a1 + 236));
        v40 = v5;
        v8 = 0.0;
        if ( v40 != 0.0 )
        {
          v34 = *(float *)(a1 + 1412);
          v30 = 1;
LABEL_70:
          for ( m = sub_80DE734(
                      *(_DWORD *)(a1 + 204),
                      (float *)(a1 + 20),
                      *(_DWORD *)(a1 + 1400),
                      1106247680,
                      v34,
                      0,
                      0,
                      0,
                      1,
                      *(_DWORD *)(a1 + 96) != 1023,
                      0,
                      a4,
                      0,
                      45.0);
                ;
                m = sub_80DE734(
                      *(_DWORD *)(a1 + 204),
                      (float *)(a1 + 20),
                      *(_DWORD *)(a1 + 1400),
                      1106247680,
                      v34,
                      0,
                      0,
                      0,
                      1,
                      *(_DWORD *)(a1 + 96) != 1023,
                      0,
                      a4,
                      0,
                      45.0) )
          {
            v32 = m;
            if ( m )
            {
              if ( sub_80E4688(v8, a1, v34, a4) )
                break;
            }
            if ( !v30 )
              goto LABEL_81;
            v10 = sub_80E6E42(v40);
            v30 = v10 > 1.0;
            if ( v10 > 1.0 )
            {
              if ( v40 <= 0.0 )
                v40 = -1.0;
              else
                v40 = 1.0;
            }
            v26 = 1;
            *(_DWORD *)(a1 + 88) += (unsigned __int16)(int)(v40 * 182.04445);
            v15 = *(float *)(a1 + 236) + v40;
            v8 = sub_80A6154(v15);
            *(float *)(a1 + 236) = v8;
            sub_80A6258(*(float *)(a1 + 1412), *(float *)(a1 + 236));
            v40 = v8;
            if ( v32 )
              goto LABEL_70;
            v16 = v34 + v40;
            v8 = sub_80A6154(v16);
            v34 = v8;
          }
          *(float *)(a1 + 1412) = v34;
        }
LABEL_81:
        if ( v40 > (long double)*(float *)(bg_prone_yawcap + 8)
          || (v11 = v40, -*(float *)(bg_prone_yawcap + 8) > (long double)v40) )
        {
          if ( v40 <= (long double)*(float *)(bg_prone_yawcap + 8) )
            v41 = v40 + *(float *)(bg_prone_yawcap + 8);
          else
            v41 = v40 - *(float *)(bg_prone_yawcap + 8);
          *(_DWORD *)(a1 + 88) += (unsigned __int16)(int)(v41 * 182.04445);
          if ( v41 <= 0.0 )
            v17 = *(float *)(a1 + 1412) + *(float *)(bg_prone_yawcap + 8);
          else
            v17 = *(float *)(a1 + 1412) - *(float *)(bg_prone_yawcap + 8);
          v11 = sub_80A6154(v17);
          *(float *)(a1 + 236) = v11;
        }
        if ( v26 )
        {
          *(_DWORD *)(a1 + 12) |= 0x10000u;
          sub_80A6258(v28, *(float *)(a1 + 236));
          v24 = v11;
          v11 = sub_80E6E42(v24);
          if ( v11 <= 1.0 )
          {
            sub_80A6258(v27, *(float *)(a1 + 236));
            v23 = v11;
            v11 = 0.0;
            if ( v24 * v23 > 0.0 )
            {
              v25 = v24 * 0.98000002;
              v18 = *(float *)(a1 + 236) + v25;
              *(float *)(a1 + 236) = sub_80A6154(v18);
              v11 = v25 * 182.04445;
              *(_DWORD *)(a1 + 88) += (unsigned __int16)(int)v11;
            }
          }
        }
        sub_80A6258(*(float *)(a1 + 1420), *(float *)(a1 + 232));
        v42 = v11;
        if ( v42 > 45.0 || v42 < -45.0 )
        {
          if ( v42 <= 45.0 )
            v43 = v42 + 45.0;
          else
            v43 = v42 - 45.0;
          *(_DWORD *)(a1 + 84) += (unsigned __int16)(int)(v43 * 182.04445);
          if ( v43 <= 0.0 )
            v19 = *(float *)(a1 + 1420) + 45.0;
          else
            v19 = *(float *)(a1 + 1420) - 45.0;
          *(float *)(a1 + 232) = sub_80A61D2(v19);
        }
      }
      if ( *(_DWORD *)(a1 + 4) != 3 && *(_DWORD *)(a1 + 4) != 2 && *(_DWORD *)(a1 + 4) != 4 )
        goto LABEL_106;
    }
  }
}
// 8166520: using guessed type int (__cdecl *funcs_80DDC6A[2])(void *s, int, int, int, int, int, int);
// 8576074: using guessed type int player_view_pitch_up;
// 8576078: using guessed type int player_view_pitch_down;
// 857607C: using guessed type int bg_ladder_yawcap;
// 8576080: using guessed type int bg_prone_yawcap;

//----- (080E54DC) --------------------------------------------------------
void __usercall sub_80E54DC(long double a1@<st0>, _BYTE *a2, int a3)
{
  int v3; // eax
  long double v4; // fst7
  unsigned __int8 v5; // [esp+2Ch] [ebp-2Ch]
  int v6; // [esp+44h] [ebp-14h]
  float v7; // [esp+48h] [ebp-10h]
  float v8; // [esp+48h] [ebp-10h]
  float v9; // [esp+4Ch] [ebp-Ch]
  float v10; // [esp+4Ch] [ebp-Ch]

  v6 = *(_DWORD *)a2;
  if ( ((*(_BYTE *)(*(_DWORD *)a2 + 12) ^ 1) & 1) == 0 )
  {
    if ( *(_DWORD *)(v6 + 96) == 1023 )
    {
      v5 = a2[228];
      if ( *(_DWORD *)(a3 + 48) )
        v3 = sub_80DE734(
               *(_DWORD *)(v6 + 204),
               (float *)(v6 + 20),
               *(_DWORD *)(v6 + 1400),
               1106247680,
               *(float *)(v6 + 1412),
               (_DWORD *)(v6 + 1448),
               (float *)(v6 + 1452),
               (float *)(v6 + 1456),
               1,
               *(_DWORD *)(v6 + 96) != 1023,
               a3 + 60,
               v5,
               0,
               66.0);
      else
        v3 = sub_80DE734(
               *(_DWORD *)(v6 + 204),
               (float *)(v6 + 20),
               *(_DWORD *)(v6 + 1400),
               1106247680,
               *(float *)(v6 + 1412),
               (_DWORD *)(v6 + 1448),
               (float *)(v6 + 1452),
               (float *)(v6 + 1456),
               1,
               *(_DWORD *)(v6 + 96) != 1023,
               0,
               v5,
               0,
               66.0);
      if ( !v3 )
      {
        BG_AddPredictableEventToPlayerstate(141, 0, v6);
        *(_DWORD *)(v6 + 12) |= 0x10000u;
      }
    }
    else if ( *(_DWORD *)(a3 + 48) )
    {
      a1 = *(float *)(a3 + 68);
      if ( a1 < 0.69999999 )
        BG_AddPredictableEventToPlayerstate(141, 0, v6);
    }
    if ( *(_DWORD *)(a3 + 48) )
    {
      sub_80A86CC(*(float *)(v6 + 1412), (float *)(a3 + 60));
      v9 = a1;
      sub_80A6258(v9, *(float *)(v6 + 1416));
    }
    else
    {
      sub_80A6258(0.0, *(float *)(v6 + 1416));
    }
    v7 = a1;
    v4 = 0.0;
    if ( v7 != 0.0 )
    {
      if ( sub_80E6E42(v7) <= *(float *)(a3 + 36) * 70.0 )
        *(float *)(v6 + 1416) = *(float *)(v6 + 1416) + v7;
      else
        *(float *)(v6 + 1416) = (long double)(int)sub_80E6F12(LODWORD(v7)) * (*(float *)(a3 + 36) * 70.0)
                              + *(float *)(v6 + 1416);
      v4 = sub_80A61D2(*(float *)(v6 + 1416));
      *(float *)(v6 + 1416) = v4;
    }
    if ( *(_DWORD *)(a3 + 48) )
    {
      sub_80A86CC(*(float *)(v6 + 236), (float *)(a3 + 60));
      v10 = v4;
      sub_80A6258(v10, *(float *)(v6 + 1420));
    }
    else
    {
      sub_80A6258(0.0, *(float *)(v6 + 1420));
    }
    v8 = v4;
    if ( v8 != 0.0 )
    {
      if ( sub_80E6E42(v8) <= *(float *)(a3 + 36) * 70.0 )
        *(float *)(v6 + 1420) = *(float *)(v6 + 1420) + v8;
      else
        *(float *)(v6 + 1420) = (long double)(int)sub_80E6F12(LODWORD(v8)) * (*(float *)(a3 + 36) * 70.0)
                              + *(float *)(v6 + 1420);
      *(float *)(v6 + 1420) = sub_80A61D2(*(float *)(v6 + 1420));
    }
  }
}

//----- (080E5820) --------------------------------------------------------
int __cdecl sub_80E5820(int a1)
{
  int result; // eax

  result = *(_DWORD *)(a1 + 12) & 1;
  if ( (_BYTE)result )
  {
    result = a1;
    *(_DWORD *)(a1 + 12) |= 0x800u;
  }
  return result;
}

//----- (080E5844) --------------------------------------------------------
int __cdecl sub_80E5844(int **a1)
{
  int result; // eax
  int *v2; // [esp+0h] [ebp-4h]

  v2 = *a1;
  v2[3] &= ~0x100u;
  result = (int)v2;
  if ( v2[1] <= 5 )
  {
    result = (unsigned int)a1[2] & 0x1000;
    if ( result )
    {
      result = v2[3] & 1;
      if ( !(_BYTE)result )
      {
        result = v2[3] & 0x40;
        if ( result )
        {
          result = (int)v2;
          if ( v2[54] != 5 )
          {
            result = (int)v2;
            if ( v2[54] != 7 )
            {
              result = (int)v2;
              if ( v2[54] != 9 )
              {
                result = (int)v2;
                if ( v2[54] != 8 )
                {
                  result = (int)v2;
                  if ( v2[54] != 6 )
                  {
                    result = (int)v2;
                    v2[3] |= 0x100u;
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  return result;
}

//----- (080E58EE) --------------------------------------------------------
int __cdecl sub_80E58EE(int a1)
{
  int result; // eax

  result = a1;
  *(_DWORD *)(a1 + 12) |= 0x20u;
  return result;
}

//----- (080E5902) --------------------------------------------------------
int __cdecl sub_80E5902(int a1)
{
  int result; // eax

  if ( (*(_DWORD *)(a1 + 12) & 0x20) != 0 )
    *(_DWORD *)(a1 + 12) |= 0x40000u;
  result = a1;
  *(_DWORD *)(a1 + 12) &= ~0x20u;
  return result;
}

//----- (080E5936) --------------------------------------------------------
int __cdecl sub_80E5936(int a1, int *a2)
{
  int result; // eax
  int v3; // [esp+20h] [ebp-88h]
  int v4; // [esp+24h] [ebp-84h]
  int v5; // [esp+2Ch] [ebp-7Ch]
  float s; // [esp+30h] [ebp-78h] BYREF
  int v7[3]; // [esp+34h] [ebp-74h] BYREF
  int v8; // [esp+40h] [ebp-68h]
  int v9; // [esp+60h] [ebp-48h] BYREF
  float v10; // [esp+64h] [ebp-44h]
  float v11; // [esp+68h] [ebp-40h]
  int v12; // [esp+70h] [ebp-38h] BYREF
  float v13; // [esp+74h] [ebp-34h]
  float v14; // [esp+78h] [ebp-30h]
  int v15[4]; // [esp+80h] [ebp-28h] BYREF
  int v16[6]; // [esp+90h] [ebp-18h] BYREF

  v4 = *(_DWORD *)a1;
  if ( a2[11] )
    *(_DWORD *)(v4 + 12) &= ~0x40000u;
  if ( !*(_DWORD *)(v4 + 16) || (result = *(_DWORD *)(v4 + 12) & 0x600) == 0 )
  {
    if ( a2[11] )
      v5 = 1090519040;
    else
      v5 = 1106247680;
    v3 = 0;
    if ( (*(_DWORD *)(v4 + 12) & 0x20) != 0 && *(_DWORD *)(v4 + 96) == 1023 )
      v3 = 1;
    if ( v3 )
    {
      sub_80E70FA((_DWORD *)(v4 + 100), (unsigned int *)v15);
    }
    else
    {
      v15[0] = *a2;
      v15[1] = a2[1];
      v15[2] = 0;
      Vec3Normalize((float *)v15);
    }
    if ( *(int *)(v4 + 4) <= 5 )
    {
      if ( (*(_DWORD *)(v4 + 12) & 0x40000) != 0
        || PM_GetEffectiveStance(v4) == 1
        || *(_DWORD *)(a1 + 4) - *(_DWORD *)(v4 + 112) <= 299 )
      {
        return sub_80E5902(v4);
      }
      else
      {
        sub_80E70CA((_DWORD *)(a1 + 196), &v12);
        *(float *)&v12 = *(float *)&v12 + 6.0;
        v13 = v13 + 6.0;
        v14 = 8.0;
        sub_80E70CA((_DWORD *)(a1 + 208), &v9);
        *(float *)&v9 = *(float *)&v9 - 6.0;
        v10 = v10 - 6.0;
        if ( v14 > (long double)v11 )
          v11 = v14;
        sub_80E71F8((float *)(v4 + 20), *(float *)&v5, (float *)v15, (float *)v16);
        sub_80DEC3C(
          a1,
          (unsigned __int16 *)&s,
          v4 + 20,
          (int)&v12,
          (int)&v9,
          (int)v16,
          *(_DWORD *)(v4 + 204),
          *(_DWORD *)(a1 + 60));
        if ( s < 1.0
          && (v8 & 8) != 0
          && (!a2[11] || *(char *)(a1 + 28) > 0)
          && ((*(_DWORD *)(v4 + 12) & 0x20) != 0
           || (sub_80E70CA(v7, (_DWORD *)(v4 + 100)),
               sub_80E70FA((_DWORD *)(v4 + 100), (unsigned int *)v15),
               sub_80E71F8((float *)(v4 + 20), *(float *)&v5, (float *)v15, (float *)v16),
               sub_80DEC3C(
                 a1,
                 (unsigned __int16 *)&s,
                 v4 + 20,
                 (int)&v12,
                 (int)&v9,
                 (int)v16,
                 *(_DWORD *)(v4 + 204),
                 *(_DWORD *)(a1 + 60)),
               s < 1.0)
           && (v8 & 8) != 0) )
        {
          return sub_80E58EE(v4);
        }
        else
        {
          result = sub_80E5902(v4);
          if ( v3 )
            return BG_AnimScriptEvent((_DWORD *)v4, 3, 0, 1);
        }
      }
    }
    else
    {
      *(_DWORD *)(v4 + 96) = 1023;
      a2[12] = 0;
      a2[13] = 0;
      a2[11] = 0;
      return sub_80E5902(v4);
    }
  }
  return result;
}
// 80E5936: using guessed type int anonymous_0[3];

//----- (080E5D4A) --------------------------------------------------------
int __usercall sub_80E5D4A@<eax>(long double a1@<st0>, int a2, int a3)
{
  int result; // eax
  long double v4; // fst7
  float v5; // [esp+4h] [ebp-94h]
  int v6; // [esp+20h] [ebp-78h]
  float v7; // [esp+24h] [ebp-74h]
  float v8; // [esp+28h] [ebp-70h]
  int v9; // [esp+30h] [ebp-68h]
  int v10; // [esp+34h] [ebp-64h]
  float v11; // [esp+38h] [ebp-60h]
  float v12; // [esp+3Ch] [ebp-5Ch]
  float v13; // [esp+3Ch] [ebp-5Ch]
  float v14; // [esp+3Ch] [ebp-5Ch]
  int v15[3]; // [esp+40h] [ebp-58h] BYREF
  float v16; // [esp+4Ch] [ebp-4Ch]
  float v17[4]; // [esp+50h] [ebp-48h] BYREF
  int v18[4]; // [esp+60h] [ebp-38h] BYREF
  int v19[6]; // [esp+70h] [ebp-28h] BYREF
  float v20; // [esp+88h] [ebp-10h]
  float v21; // [esp+8Ch] [ebp-Ch]

  v9 = *(_DWORD *)a2;
  if ( (unsigned __int8)Jump_Check((int *)a2, (int *)a3) )
    return sub_80DFCD4(a1, a2, a3);
  v16 = (*(float *)(a3 + 8) + 0.25) * 2.5;
  if ( v16 <= 1.0 )
  {
    if ( v16 < -1.0 )
      v16 = -1.0;
  }
  else
  {
    v16 = 1.0;
  }
  *(_DWORD *)(a3 + 8) = 0;
  Vec3Normalize((float *)a3);
  *(_DWORD *)(a3 + 20) = 0;
  sub_80A2298((float *)(a3 + 12), (int)v17);
  sub_80A7D80(v17, (float *)(v9 + 100), (float *)(a3 + 12));
  v20 = sub_80DF3FA(v9, a2 + 4);
  sub_80E707C(v18);
  if ( *(_BYTE *)(a2 + 28) )
    *(float *)&v18[2] = v16 * 0.5 * v20 * (long double)*(char *)(a2 + 28);
  if ( *(_BYTE *)(a2 + 29) )
  {
    v5 = v20 * 0.2 * (long double)*(char *)(a2 + 29);
    sub_80E71F8((float *)v18, v5, (float *)(a3 + 12), (float *)v18);
  }
  v21 = sub_80A2298((float *)v18, (int)v19);
  sub_80DF16A(v9, a3, (float *)v19, v21, 9.0);
  if ( !*(_BYTE *)(a2 + 28) )
  {
    if ( *(float *)(v9 + 40) <= 0.0 )
    {
      *(float *)(v9 + 40) = (long double)*(int *)(v9 + 72) * *(float *)(a3 + 36) + *(float *)(v9 + 40);
      if ( *(float *)(v9 + 40) > 0.0 )
        *(_DWORD *)(v9 + 40) = 0;
    }
    else
    {
      *(float *)(v9 + 40) = *(float *)(v9 + 40) - (long double)*(int *)(v9 + 72) * *(float *)(a3 + 36);
      if ( *(float *)(v9 + 40) < 0.0 )
        *(_DWORD *)(v9 + 40) = 0;
    }
  }
  if ( !*(_BYTE *)(a2 + 29) )
  {
    sub_80E6F38((_DWORD *)(a3 + 12), v15);
    sub_80A215E((float *)v15);
    v12 = sub_80E700C((float *)v15, (float *)(v9 + 32));
    if ( v12 != 0.0 )
    {
      sub_80E6FD6((float *)(v9 + 32), COERCE_FLOAT(LODWORD(v12) ^ 0x80000000), (float *)v15, (float *)(v9 + 32));
      v11 = v12 * *(float *)(a3 + 36) * 16.0;
      v8 = sub_80E6E42(v12);
      if ( v8 > sub_80E6E42(v11) )
      {
        if ( sub_80E6E42(v11) < 1.0 )
          v11 = (float)(int)sub_80E6F12(LODWORD(v11));
        v13 = v12 - v11;
        sub_80E6FD6((float *)(v9 + 32), v13, (float *)v15, (float *)(v9 + 32));
      }
    }
  }
  if ( !*(_DWORD *)(a3 + 44) )
  {
    v14 = sub_80E700C((float *)(v9 + 100), (float *)(v9 + 32));
    sub_80E6FD6((float *)(v9 + 32), COERCE_FLOAT(LODWORD(v14) ^ 0x80000000), (float *)(v9 + 100), (float *)(v9 + 32));
    v7 = sub_80E702E((float *)(v9 + 32));
    if ( sub_80E6F06(*(float *)(v9 + 40)) >= v7 )
      sub_80E6FD6((float *)(v9 + 32), -50.0, (float *)(v9 + 100), (float *)(v9 + 32));
  }
  sub_80E7CC0((int *)a2, a3, 0);
  v4 = sub_80A29F6((float *)(v9 + 100)) + 180.0;
  v20 = v4;
  sub_80A6258(v20, *(float *)(v9 + 236));
  v10 = (int)v4;
  v6 = (int)v4;
  if ( (int)v4 < 0 )
    v6 = -v6;
  if ( v6 > 75 )
  {
    if ( v10 <= 0 )
      LOBYTE(v10) = -75;
    else
      LOBYTE(v10) = 75;
  }
  result = (char)v10;
  *(_DWORD *)(v9 + 156) = (char)v10;
  return result;
}
// 80E5D4A: using guessed type float var_48[4];

//----- (080E6200) --------------------------------------------------------
void __cdecl sub_80E6200(int a1)
{
  unsigned int v1; // edx
  long double v2; // fst7
  long double v3; // fst7
  long double v4; // fst7
  float v5; // [esp+0h] [ebp-E8h]
  float v6; // [esp+0h] [ebp-E8h]
  float v7; // [esp+0h] [ebp-E8h]
  float v8; // [esp+0h] [ebp-E8h]
  float v9; // [esp+4h] [ebp-E4h]
  float v10; // [esp+4h] [ebp-E4h]
  float v11; // [esp+4h] [ebp-E4h]
  float v12; // [esp+20h] [ebp-C8h]
  float v13; // [esp+24h] [ebp-C4h]
  float v14; // [esp+28h] [ebp-C0h]
  float v15; // [esp+2Ch] [ebp-BCh]
  int v16[4]; // [esp+30h] [ebp-B8h] BYREF
  int s[3]; // [esp+40h] [ebp-A8h] BYREF
  float v18; // [esp+4Ch] [ebp-9Ch] BYREF
  float v19; // [esp+58h] [ebp-90h] BYREF
  float v20; // [esp+64h] [ebp-84h]
  int v21; // [esp+68h] [ebp-80h]
  int v22; // [esp+6Ch] [ebp-7Ch]
  int v23; // [esp+70h] [ebp-78h]
  int v24; // [esp+74h] [ebp-74h]
  float v25[3]; // [esp+A0h] [ebp-48h] BYREF
  int v26[8]; // [esp+ACh] [ebp-3Ch] BYREF
  int v27; // [esp+CCh] [ebp-1Ch]
  int v28[3]; // [esp+D0h] [ebp-18h] BYREF
  int v29; // [esp+DCh] [ebp-Ch]

  v27 = *(_DWORD *)a1;
  sub_80D72F8((int *)a1);
  if ( *(__int16 *)(v27 + 12) < 0 )
  {
    *(_DWORD *)(a1 + 8) &= 0x2300u;
    *(_BYTE *)(a1 + 28) = 0;
    *(_BYTE *)(a1 + 29) = 0;
    sub_80E70A6((_DWORD *)(v27 + 32), 0, 0, 0);
  }
  if ( (*(_DWORD *)(a1 + 8) & 0x40000) != 0 )
  {
    *(_DWORD *)(a1 + 8) &= 0x43300u;
    *(_BYTE *)(a1 + 28) = 0;
    *(_BYTE *)(a1 + 29) = 0;
  }
  *(_DWORD *)(v27 + 12) &= ~0x10000u;
  if ( *(int *)(v27 + 4) > 5 )
    *(_DWORD *)(a1 + 60) &= ~0x2000000u;
  if ( (*(_BYTE *)(v27 + 12) & 1) != 0 )
  {
    if ( (*(_BYTE *)(a1 + 28) == *(_BYTE *)(a1 + 56)
       || (v5 = (float)*(char *)(a1 + 28), v13 = sub_80E6E42(v5), v6 = (float)*(char *)(a1 + 56), v13 <= sub_80E6E42(v6)))
      && (*(_BYTE *)(a1 + 29) == *(_BYTE *)(a1 + 57)
       || (v7 = (float)*(char *)(a1 + 29), v12 = sub_80E6E42(v7), v8 = (float)*(char *)(a1 + 57), v12 <= sub_80E6E42(v8))) )
    {
      if ( (*(_DWORD *)(v27 + 12) & 0x40) == 0 && (*(_DWORD *)(v27 + 216) < 3u || *(_DWORD *)(v27 + 216) == 5) )
        *(_DWORD *)(v27 + 12) &= ~0x800u;
    }
    else if ( sub_80EABAA((_DWORD *)v27) )
    {
      *(_DWORD *)(v27 + 12) &= ~0x800u;
      sub_80EA53E(v27);
    }
  }
  else
  {
    *(_DWORD *)(v27 + 12) &= ~0x800u;
  }
  v29 = PM_GetEffectiveStance(v27);
  if ( (*(_DWORD *)(v27 + 12) & 0x40) != 0 && v29 == 1 )
  {
    *(_BYTE *)(a1 + 28) = 0;
    *(_BYTE *)(a1 + 29) = 0;
  }
  if ( (*(_DWORD *)(a1 + 8) & 0x40000) != 0 )
    v1 = *(_DWORD *)(v27 + 160) | 0x200000;
  else
    v1 = *(_DWORD *)(v27 + 160) & 0xFFDFFFFF;
  *(_DWORD *)(v27 + 160) = v1;
  *(_DWORD *)(v27 + 160) &= ~0x40u;
  if ( *(_DWORD *)(v27 + 4) != 5
    && (*(_DWORD *)(v27 + 12) & 0x1000) == 0
    && (!*(_DWORD *)(v27 + 216) || *(_DWORD *)(v27 + 216) == 3)
    && sub_80EAEC8(v27)
    && (*(_BYTE *)(a1 + 8) & 1) != 0 )
  {
    *(_DWORD *)(v27 + 160) |= 0x40u;
  }
  if ( *(int *)(v27 + 4) <= 5 && (*(_DWORD *)(a1 + 8) & 0x4001) == 0 )
    *(_DWORD *)(v27 + 12) &= ~0x1000u;
  memset(s, 0, 0x7Cu);
  v21 = *(_DWORD *)(a1 + 4) - *(_DWORD *)v27;
  if ( v21 > 0 )
  {
    if ( v21 > 200 )
      v21 = 200;
  }
  else
  {
    v21 = 1;
  }
  *(_DWORD *)v27 = *(_DWORD *)(a1 + 4);
  sub_80E70CA((_DWORD *)(v27 + 20), v25);
  sub_80E70CA((_DWORD *)(v27 + 32), v26);
  v20 = (long double)v21 * 0.001;
  sub_80EC2BA((_BYTE *)a1, (int)s);
  v2 = (long double)v21;
  v9 = v2;
  sub_80E4794(v27, v9, a1 + 4, *(_BYTE *)(a1 + 228));
  AngleVectors((float *)(v27 + 232), (int)s, &v18, &v19);
  if ( *(char *)(a1 + 28) >= 0 )
  {
    if ( *(char *)(a1 + 28) > 0 || !*(_BYTE *)(a1 + 28) && *(_BYTE *)(a1 + 29) )
      *(_DWORD *)(v27 + 12) &= ~0x80u;
  }
  else
  {
    *(_DWORD *)(v27 + 12) |= 0x80u;
  }
  if ( *(int *)(v27 + 4) > 5 )
  {
    *(_BYTE *)(a1 + 28) = 0;
    *(_BYTE *)(a1 + 29) = 0;
  }
  if ( v29 == 1 && (*(_DWORD *)(v27 + 12) & 0x800) != 0 )
  {
    *(_BYTE *)(a1 + 28) = 0;
    *(_BYTE *)(a1 + 29) = 0;
  }
  sub_80DBE96(v27);
  switch ( *(_DWORD *)(v27 + 4) )
  {
    case 1:
    case 7:
      sub_80E5902(v27);
      *(_DWORD *)(v27 + 96) = 1023;
      v23 = 0;
      v24 = 0;
      v22 = 0;
      sub_80E707C((_DWORD *)(v27 + 32));
      sub_80EA40E(a1, (int)s);
      sub_80E5844((int **)a1);
      sub_80E1F20(a1, (int)s);
      sub_80E4212((_DWORD *)v27, (int)s);
      sub_80E3008(a1, (int)s);
      sub_80EDF3A(a1, (int)s);
      break;
    case 2:
      sub_80E5902(v27);
      sub_80EA40E(a1, (int)s);
      sub_80E5844((int **)a1);
      sub_80E037E(v2, a1, (int)s);
      sub_80E4212((_DWORD *)v27, (int)s);
      sub_80EA568((int *)a1, (int)s);
      break;
    case 3:
      sub_80E5902(v27);
      sub_80EA40E(a1, (int)s);
      sub_80E5844((int **)a1);
      sub_80E05C8(a1, (int)s);
      sub_80E4212((_DWORD *)v27, (int)s);
      sub_80EA568((int *)a1, (int)s);
      break;
    case 4:
      sub_80E5902(v27);
      sub_80EA40E(a1, (int)s);
      sub_80E5844((int **)a1);
      sub_80E1F20(a1, (int)s);
      sub_80DFB3A(v2, a1, (int)s);
      sub_80E4212((_DWORD *)v27, (int)s);
      sub_80EA568((int *)a1, (int)s);
      break;
    case 5:
      sub_80E5902(v27);
      sub_80EA40E(a1, (int)s);
      sub_80EA568((int *)a1, (int)s);
      break;
    default:
      if ( (*(_DWORD *)(v27 + 160) & 0x300) != 0 )
      {
        sub_80E5902(v27);
        *(_DWORD *)(v27 + 96) = 1023;
        v23 = 0;
        v24 = 0;
        v22 = 0;
        sub_80E707C((_DWORD *)(v27 + 32));
        sub_80EA40E(a1, (int)s);
        sub_80E5844((int **)a1);
        sub_80E1F20(a1, (int)s);
        sub_80E4212((_DWORD *)v27, (int)s);
        sub_80E3008(a1, (int)s);
        sub_80EE212((_DWORD *)v27);
      }
      else
      {
        if ( (*(_DWORD *)(v27 + 12) & 4) == 0 )
        {
          sub_80E1F20(a1, (int)s);
          sub_80E117E((int *)a1, (int)s);
        }
        Mantle_Check((int *)a1, s);
        if ( (*(_DWORD *)(v27 + 12) & 4) != 0 )
        {
          sub_80E5902(v27);
          *(_DWORD *)(v27 + 96) = 1023;
          v23 = 0;
          v22 = 0;
          sub_80EA40E(a1, (int)s);
          sub_80E5844((int **)a1);
          sub_80E1F20(a1, (int)s);
          sub_80DBB3C(a1, v27, (int)s);
          sub_80EDF3A(a1, (int)s);
        }
        else
        {
          sub_80EA40E(a1, (int)s);
          sub_80E5844((int **)a1);
          sub_80E54DC(v2, (_BYTE *)a1, (int)s);
          if ( *(_DWORD *)(v27 + 4) == 6 )
            sub_80E02FE(v2, v27, (int)s);
          sub_80E5936(a1, s);
          sub_80E4212((_DWORD *)v27, (int)s);
          if ( (*(_DWORD *)(v27 + 12) & 0x20) != 0 )
          {
            sub_80E5D4A(v2, a1, (int)s);
          }
          else if ( v22 )
          {
            sub_80DFE82(v2, a1, (int)s);
          }
          else
          {
            sub_80DFCD4(v2, a1, (int)s);
          }
          sub_80E117E((int *)a1, (int)s);
          sub_80E3008(a1, (int)s);
          sub_80EDF3A(a1, (int)s);
          sub_80E4060(a1);
          sub_80E717C((float *)(v27 + 20), v25, (float *)v16);
          v3 = sub_80E7280((float *)v16);
          v15 = v3 / (v20 * v20);
          v14 = sub_80E7280((float *)(v27 + 32));
          v4 = v15;
          if ( v14 * 0.25 > v15 )
          {
            v4 = 1.0 / v20;
            v10 = v4;
            sub_80E71C0((float *)v16, v10, (float *)(v27 + 32));
          }
          sub_80E6F84((float *)(v27 + 32), (float *)(v27 + 44), (float *)v28);
          sub_80E6EA0(v20, 1.0);
          v11 = v4;
          sub_80E6FB0((float *)v28, v11, (float *)v28);
          sub_80E6F58((float *)(v27 + 44), (float *)v28, (float *)(v27 + 44));
          sub_80D3824((float *)(v27 + 32));
        }
      }
      break;
  }
}
// 80E6200: using guessed type int s[3];
// 80E6200: using guessed type int anonymous_0[8];

//----- (080E6D30) --------------------------------------------------------
int __cdecl sub_80E6D30(int **a1)
{
  int result; // eax
  int v2; // [esp+Ch] [ebp-Ch]
  int *v3; // [esp+10h] [ebp-8h]
  int v4; // [esp+14h] [ebp-4h]

  v3 = *a1;
  v4 = (int)a1[1];
  result = v4;
  if ( v4 >= **a1 )
  {
    if ( v4 > *v3 + 1000 )
      *v3 = v4 - 1000;
    a1[16] = 0;
    while ( 1 )
    {
      result = *v3;
      if ( *v3 == v4 )
        break;
      v2 = v4 - *v3;
      if ( v2 > 66 )
        v2 = 66;
      a1[1] = (int *)(*v3 + v2);
      sub_80E6200((int)a1);
      a1[8] = a1[1];
      a1[9] = a1[2];
      a1[10] = a1[3];
      a1[11] = a1[4];
      a1[12] = a1[5];
      a1[13] = a1[6];
      a1[14] = a1[7];
    }
  }
  return result;
}

//----- (080E6DF4) --------------------------------------------------------
long double __usercall sub_80E6DF4@<st0>(long double a1@<st0>, int a2, int a3)
{
  if ( (*(_DWORD *)(a2 + 12) & 0x20) != 0 )
  {
    if ( a3 - *(_DWORD *)(a2 + 112) > 499 )
      return *(float *)(a2 + 40);
    else
      return (float)0.0;
  }
  else
  {
    sub_80E7050((float *)(a2 + 32));
    return (float)a1;
  }
}

//----- (080E6E42) --------------------------------------------------------
long double __cdecl sub_80E6E42(float a1)
{
  return (float)fabs(a1);
}

//----- (080E6E5C) --------------------------------------------------------
long double __cdecl sub_80E6E5C(float a1)
{
  return (float)sqrt(a1);
}

//----- (080E6E7C) --------------------------------------------------------
void __cdecl sub_80E6E7C(float a1, float a2)
{
  float v2; // [esp+0h] [ebp-18h]

  v2 = a1 - a2;
  sub_80E72F2(v2, a1, a2);
}

//----- (080E6EA0) --------------------------------------------------------
void __cdecl sub_80E6EA0(float a1, float a2)
{
  float v2; // [esp+0h] [ebp-18h]

  v2 = a2 - a1;
  sub_80E72F2(v2, a1, a2);
}

//----- (080E6EC4) --------------------------------------------------------
int __cdecl sub_80E6EC4(int a1, int a2, int a3)
{
  int v3; // eax

  v3 = sub_80E731C(a1 - a3, a3, a1);
  return sub_80E731C(a2 - a1, a2, v3);
}

//----- (080E6F06) --------------------------------------------------------
long double __cdecl sub_80E6F06(float a1)
{
  return a1 * a1;
}

//----- (080E6F12) --------------------------------------------------------
unsigned int __cdecl sub_80E6F12(unsigned int a1)
{
  return -2 * sub_80E733C(a1) + 1;
}

//----- (080E6F38) --------------------------------------------------------
int __cdecl sub_80E6F38(_DWORD *a1, _DWORD *a2)
{
  int result; // eax

  *a2 = *a1;
  result = a1[1];
  a2[1] = result;
  return result;
}

//----- (080E6F58) --------------------------------------------------------
float *__cdecl sub_80E6F58(float *a1, float *a2, float *a3)
{
  float *result; // eax

  *a3 = *a1 + *a2;
  result = a1 + 1;
  a3[1] = a1[1] + a2[1];
  return result;
}

//----- (080E6F84) --------------------------------------------------------
float *__cdecl sub_80E6F84(float *a1, float *a2, float *a3)
{
  float *result; // eax

  *a3 = *a1 - *a2;
  result = a1 + 1;
  a3[1] = a1[1] - a2[1];
  return result;
}

//----- (080E6FB0) --------------------------------------------------------
float *__cdecl sub_80E6FB0(float *a1, float a2, float *a3)
{
  float *result; // eax

  *a3 = a2 * *a1;
  result = a1 + 1;
  a3[1] = a2 * a1[1];
  return result;
}

//----- (080E6FD6) --------------------------------------------------------
float *__cdecl sub_80E6FD6(float *a1, float a2, float *a3, float *a4)
{
  float *result; // eax

  *a4 = a2 * *a3 + *a1;
  result = a3 + 1;
  a4[1] = a2 * a3[1] + a1[1];
  return result;
}

//----- (080E700C) --------------------------------------------------------
long double __cdecl sub_80E700C(float *a1, float *a2)
{
  return *a1 * *a2 + a1[1] * a2[1];
}

//----- (080E702E) --------------------------------------------------------
long double __cdecl sub_80E702E(float *a1)
{
  return *a1 * *a1 + a1[1] * a1[1];
}

//----- (080E7050) --------------------------------------------------------
void __cdecl sub_80E7050(float *a1)
{
  float v1; // [esp+0h] [ebp-8h]

  v1 = *a1 * *a1 + a1[1] * a1[1];
  sub_80E6E5C(v1);
}

//----- (080E707C) --------------------------------------------------------
int __cdecl sub_80E707C(_DWORD *a1)
{
  int result; // eax

  *a1 = 0;
  a1[1] = 0;
  result = 0;
  a1[2] = 0;
  return result;
}

//----- (080E70A6) --------------------------------------------------------
int __cdecl sub_80E70A6(_DWORD *a1, int a2, int a3, int a4)
{
  int result; // eax

  *a1 = a2;
  a1[1] = a3;
  result = a4;
  a1[2] = a4;
  return result;
}

//----- (080E70CA) --------------------------------------------------------
int __cdecl sub_80E70CA(_DWORD *a1, _DWORD *a2)
{
  int result; // eax

  *a2 = *a1;
  a2[1] = a1[1];
  result = a1[2];
  a2[2] = result;
  return result;
}

//----- (080E70FA) --------------------------------------------------------
unsigned int __cdecl sub_80E70FA(_DWORD *a1, unsigned int *a2)
{
  unsigned int result; // eax

  *a2 = *a1 ^ 0x80000000;
  a2[1] = a1[1] ^ 0x80000000;
  result = a1[2] ^ 0x80000000;
  a2[2] = result;
  return result;
}

//----- (080E7138) --------------------------------------------------------
float *__cdecl sub_80E7138(float *a1, float *a2, float *a3)
{
  float *result; // eax

  *a3 = *a1 + *a2;
  a3[1] = a1[1] + a2[1];
  result = a1 + 2;
  a3[2] = a1[2] + a2[2];
  return result;
}

//----- (080E717C) --------------------------------------------------------
float *__cdecl sub_80E717C(float *a1, float *a2, float *a3)
{
  float *result; // eax

  *a3 = *a1 - *a2;
  a3[1] = a1[1] - a2[1];
  result = a1 + 2;
  a3[2] = a1[2] - a2[2];
  return result;
}

//----- (080E71C0) --------------------------------------------------------
float *__cdecl sub_80E71C0(float *a1, float a2, float *a3)
{
  float *result; // eax

  *a3 = a2 * *a1;
  a3[1] = a2 * a1[1];
  result = a1 + 2;
  a3[2] = a2 * a1[2];
  return result;
}

//----- (080E71F8) --------------------------------------------------------
float *__cdecl sub_80E71F8(float *a1, float a2, float *a3, float *a4)
{
  float *result; // eax

  *a4 = a2 * *a3 + *a1;
  a4[1] = a2 * a3[1] + a1[1];
  result = a3 + 2;
  a4[2] = a2 * a3[2] + a1[2];
  return result;
}

//----- (080E724C) --------------------------------------------------------
long double __cdecl sub_80E724C(float *a1, float *a2)
{
  return *a1 * *a2 + a1[1] * a2[1] + a1[2] * a2[2];
}

//----- (080E7280) --------------------------------------------------------
long double __cdecl sub_80E7280(float *a1)
{
  return *a1 * *a1 + a1[1] * a1[1] + a1[2] * a1[2];
}

//----- (080E72B4) --------------------------------------------------------
void __cdecl sub_80E72B4(float *a1)
{
  float v1; // [esp+0h] [ebp-8h]

  v1 = *a1 * *a1 + a1[1] * a1[1] + a1[2] * a1[2];
  sub_80E6E5C(v1);
}

//----- (080E72F2) --------------------------------------------------------
long double __cdecl sub_80E72F2(float a1, float a2, float a3)
{
  if ( a1 < 0.0 )
    return a3;
  return a2;
}

//----- (080E731C) --------------------------------------------------------
int __cdecl sub_80E731C(int a1, int a2, int a3)
{
  if ( a1 < 0 )
    return a3;
  return a2;
}

//----- (080E733C) --------------------------------------------------------
unsigned int __cdecl sub_80E733C(unsigned int a1)
{
  return a1 >> 31;
}

//----- (080E7348) --------------------------------------------------------
int __cdecl sub_80E7348(unsigned __int8 *a1, _DWORD *a2, _DWORD *a3)
{
  int v5; // [esp+40h] [ebp-8h]
  int v6; // [esp+44h] [ebp-4h]

  v6 = *(_DWORD *)a1;
  if ( (*(_BYTE *)(*(_DWORD *)a1 + 12) & 1) == 0 )
    return 1;
  v5 = sub_80DE734(
         *(_DWORD *)(v6 + 204),
         (float *)(v6 + 20),
         *(_DWORD *)(v6 + 1400),
         1106247680,
         *(float *)(v6 + 1412),
         (_DWORD *)(v6 + 1448),
         (float *)(v6 + 1452),
         (float *)(v6 + 1456),
         1,
         1,
         0,
         a1[228],
         0,
         66.0);
  if ( !v5 )
  {
    sub_80E87AA(a2, (_DWORD *)(v6 + 20));
    sub_80E87AA(a3, (_DWORD *)(v6 + 32));
  }
  return v5;
}

//----- (080E7448) --------------------------------------------------------
long double __cdecl sub_80E7448(float *a1, int a2, int a3, _DWORD *a4)
{
  int v4; // ebx
  int j; // [esp+2Ch] [ebp-3Ch]
  float v7[11]; // [esp+30h] [ebp-38h]
  int i; // [esp+5Ch] [ebp-Ch]

  for ( i = 0; i < a2; ++i )
  {
    v4 = i;
    v7[v4] = sub_80E88AA(a1, (float *)(a3 + 12 * i));
    for ( j = i; j && v7[i] <= (long double)v7[a4[j - 1]]; --j )
      a4[j] = a4[j - 1];
    a4[j] = i;
  }
  return v7[*a4];
}
// 80E7448: using guessed type float var_38[11];

//----- (080E750E) --------------------------------------------------------
_BOOL4 __cdecl sub_80E750E(int *a1, int a2, int a3)
{
  int v5; // [esp+3Ch] [ebp-15Ch]
  int v6[4]; // [esp+40h] [ebp-158h] BYREF
  float v7[2]; // [esp+50h] [ebp-148h] BYREF
  float v8; // [esp+58h] [ebp-140h]
  float v9; // [esp+68h] [ebp-130h]
  float v10; // [esp+6Ch] [ebp-12Ch]
  int v11[4]; // [esp+70h] [ebp-128h] BYREF
  float s; // [esp+80h] [ebp-118h] BYREF
  float v13[6]; // [esp+84h] [ebp-114h] BYREF
  unsigned __int16 v14; // [esp+9Ch] [ebp-FCh]
  char v15; // [esp+A2h] [ebp-F6h]
  int m; // [esp+B4h] [ebp-E4h]
  int k; // [esp+B8h] [ebp-E0h]
  int j; // [esp+BCh] [ebp-DCh]
  int v19[4]; // [esp+C0h] [ebp-D8h] BYREF
  _DWORD v20[4]; // [esp+D0h] [ebp-C8h] BYREF
  int v21[8]; // [esp+E0h] [ebp-B8h] BYREF
  float v22[26]; // [esp+100h] [ebp-98h] BYREF
  int v23; // [esp+168h] [ebp-30h]
  float v24; // [esp+16Ch] [ebp-2Ch]
  int v25[6]; // [esp+170h] [ebp-28h] BYREF
  int v26; // [esp+188h] [ebp-10h]
  int i; // [esp+18Ch] [ebp-Ch]

  v5 = *a1;
  v26 = 4;
  sub_80E87AA((_DWORD *)(v5 + 32), v20);
  sub_80E87AA((_DWORD *)(v5 + 32), v7);
  if ( a3 )
  {
    v8 = v8 - (long double)*(int *)(v5 + 72) * *(float *)(a2 + 36);
    *(float *)(v5 + 40) = (*(float *)(v5 + 40) + v8) * 0.5;
    *(float *)&v20[2] = v8;
    if ( *(_DWORD *)(a2 + 48) )
      sub_80DEDB0((float *)(v5 + 32), (float *)(a2 + 60), (float *)(v5 + 32));
  }
  v10 = *(float *)(a2 + 36);
  if ( *(_DWORD *)(a2 + 48) )
  {
    sub_80E87AA((_DWORD *)(a2 + 60), v22);
    v23 = 1;
  }
  else
  {
    v23 = 0;
  }
  sub_80A2298((float *)(v5 + 32), (int)&v22[3 * v23++]);
  for ( i = 0; i < v26; ++i )
  {
    sub_80E8856((float *)(v5 + 20), v10, (float *)(v5 + 32), (float *)v11);
    sub_80DEC3C(
      (int)a1,
      (unsigned __int16 *)&s,
      v5 + 20,
      (int)(a1 + 49),
      (int)(a1 + 52),
      (int)v11,
      *(_DWORD *)(v5 + 204),
      a1[15]);
    if ( v15 )
    {
      *(_DWORD *)(v5 + 40) = 0;
      return 1;
    }
    if ( s > 0.0 )
      sub_80DEB7A((float *)(v5 + 20), (float *)v11, s, (float *)(v5 + 20));
    if ( s == 1.0 )
      break;
    sub_80DED50((int)a1, v14);
    v10 = v10 - v10 * s;
    if ( v23 > 7 )
    {
LABEL_15:
      sub_80E875C((_DWORD *)(v5 + 32));
      return 1;
    }
    for ( j = 0; j < v23; ++j )
    {
      if ( sub_80E88AA(v13, &v22[3 * j]) > 0.99900001 )
      {
        sub_80DEDB0((float *)(v5 + 32), v13, (float *)(v5 + 32));
        sub_80E87DA(v13, (float *)(v5 + 32), (float *)(v5 + 32));
        break;
      }
    }
    if ( j >= v23 )
    {
      sub_80E87AA(v13, &v22[3 * v23++]);
      v9 = sub_80E7448((float *)(v5 + 32), v23, (int)v22, v21);
      if ( v9 < 0.1 )
      {
        if ( -v9 > (long double)*(float *)(a2 + 92) )
          *(_DWORD *)(a2 + 92) = LODWORD(v9) ^ 0x80000000;
        sub_80DEDB0((float *)(v5 + 32), &v22[3 * v21[0]], (float *)v19);
        sub_80DEDB0(v7, &v22[3 * v21[0]], (float *)v6);
        for ( k = 1; k < v23; ++k )
        {
          if ( sub_80E88AA((float *)v19, &v22[3 * v21[k]]) < 0.1 )
          {
            sub_80DEDB0((float *)v19, &v22[3 * v21[k]], (float *)v19);
            sub_80DEDB0((float *)v6, &v22[3 * v21[k]], (float *)v6);
            if ( sub_80E88AA((float *)v19, &v22[3 * v21[0]]) < 0.0 )
            {
              sub_80A1ED8(&v22[3 * v21[0]], &v22[3 * v21[k]], (float *)v25);
              Vec3Normalize((float *)v25);
              v24 = sub_80E88AA((float *)v25, (float *)(v5 + 32));
              sub_80E881E((float *)v25, v24, (float *)v19);
              v24 = sub_80E88AA((float *)v25, v7);
              sub_80E881E((float *)v25, v24, (float *)v6);
              for ( m = 1; m < v23; ++m )
              {
                if ( m != k && sub_80E88AA((float *)v19, &v22[3 * v21[m]]) < 0.1 )
                  goto LABEL_15;
              }
            }
          }
        }
        sub_80E87AA(v19, (_DWORD *)(v5 + 32));
        sub_80E87AA(v6, v7);
      }
    }
  }
  if ( a3 )
    sub_80E87AA(v7, (_DWORD *)(v5 + 32));
  if ( *(_DWORD *)(v5 + 16) )
    sub_80E87AA(v20, (_DWORD *)(v5 + 32));
  return i != 0;
}
// 80E750E: using guessed type float var_148[2];
// 80E750E: using guessed type float var_98[26];
// 80E750E: using guessed type int var_B8[8];

//----- (080E7CC0) --------------------------------------------------------
void __cdecl sub_80E7CC0(int *a1, int a2, int a3)
{
  long double v3; // fst6
  float v4; // [esp+0h] [ebp-138h]
  float v5; // [esp+0h] [ebp-138h]
  float v6; // [esp+0h] [ebp-138h]
  int v7; // [esp+Ch] [ebp-12Ch]
  int v8; // [esp+2Ch] [ebp-10Ch]
  int v9; // [esp+30h] [ebp-108h]
  float v10; // [esp+34h] [ebp-104h]
  float v11; // [esp+40h] [ebp-F8h]
  int v12; // [esp+44h] [ebp-F4h]
  float v13; // [esp+48h] [ebp-F0h]
  float v14; // [esp+4Ch] [ebp-ECh]
  int v15; // [esp+54h] [ebp-E4h]
  int v16; // [esp+54h] [ebp-E4h]
  int v17; // [esp+54h] [ebp-E4h]
  int v18; // [esp+54h] [ebp-E4h]
  int v19; // [esp+58h] [ebp-E0h]
  int v20; // [esp+5Ch] [ebp-DCh]
  int v21[7]; // [esp+60h] [ebp-D8h] BYREF
  int v22; // [esp+7Ch] [ebp-BCh]
  float v23; // [esp+80h] [ebp-B8h]
  _BOOL4 v24; // [esp+84h] [ebp-B4h]
  int v25[2]; // [esp+88h] [ebp-B0h] BYREF
  float v26[2]; // [esp+90h] [ebp-A8h] BYREF
  float v27[2]; // [esp+98h] [ebp-A0h] BYREF
  int v28[2]; // [esp+A0h] [ebp-98h] BYREF
  float v29; // [esp+A8h] [ebp-90h]
  int v30[2]; // [esp+B0h] [ebp-88h] BYREF
  float v31; // [esp+B8h] [ebp-80h]
  float s; // [esp+C0h] [ebp-78h] BYREF
  float v33[6]; // [esp+C4h] [ebp-74h] BYREF
  unsigned __int16 v34; // [esp+DCh] [ebp-5Ch]
  _DWORD v35[4]; // [esp+F0h] [ebp-48h] BYREF
  float v36[2]; // [esp+100h] [ebp-38h] BYREF
  float v37; // [esp+108h] [ebp-30h]
  _DWORD v38[4]; // [esp+110h] [ebp-28h] BYREF
  int v39[2]; // [esp+120h] [ebp-18h] BYREF
  float v40; // [esp+128h] [ebp-10h]

  v23 = 0.0;
  v19 = *a1;
  v20 = 0;
  if ( (*(_DWORD *)(*a1 + 12) & 0x20) != 0 )
  {
    v22 = 0;
    Jump_ClearState(v19);
  }
  else if ( *(_DWORD *)(a2 + 48) )
  {
    v22 = 1;
  }
  else
  {
    v22 = 0;
    if ( (*(_DWORD *)(v19 + 12) & 0x80000) != 0 && *(_DWORD *)(v19 + 16) )
      Jump_ClearState(v19);
  }
  sub_80E87AA((_DWORD *)(v19 + 20), v39);
  sub_80E87AA((_DWORD *)(v19 + 32), v38);
  v24 = sub_80E750E(a1, a2, a3);
  if ( (*(_BYTE *)(v19 + 12) & 1) != 0 )
    v25[0] = 1092616192;
  else
    v25[0] = 1099956224;
  if ( *(_DWORD *)(v19 + 96) != 1023 )
    goto LABEL_23;
  if ( (*(_DWORD *)(v19 + 12) & 0x80000) != 0 && *(_DWORD *)(v19 + 16) )
    Jump_ClearState(v19);
  if ( v24 && (*(_DWORD *)(v19 + 12) & 0x80000) != 0 && (unsigned __int8)Jump_GetStepHeight(v19, (int)v39, (float *)v25) )
  {
    if ( *(float *)v25 < 1.0 )
      return;
    v20 = 1;
  }
  if ( v20 || (*(_DWORD *)(v19 + 12) & 0x20) != 0 && *(float *)(v19 + 40) > 0.0 )
  {
LABEL_23:
    sub_80E87AA((_DWORD *)(v19 + 20), v36);
    sub_80E87AA((_DWORD *)(v19 + 32), v35);
    sub_80E870E(v36, (float *)v39, v27);
    if ( v24 )
    {
      sub_80E87AA(v39, v30);
      v31 = *(float *)v25 + 1.0 + v31;
      sub_80DEC3C(
        (int)a1,
        (unsigned __int16 *)&s,
        (int)v39,
        (int)(a1 + 49),
        (int)(a1 + 52),
        (int)v30,
        *(_DWORD *)(v19 + 204),
        a1[15]);
      v23 = (*(float *)v25 + 1.0) * s - 1.0;
      if ( v23 >= 1.0 )
      {
        *(float *)&v7 = v40 + v23;
        sub_80E8786((_DWORD *)(v19 + 20), v30[0], v30[1], v7);
        sub_80E87AA(v38, (_DWORD *)(v19 + 32));
        sub_80E750E(a1, a2, a3);
      }
      else
      {
        v23 = 0.0;
      }
    }
    if ( v22 || v23 != 0.0 )
    {
      sub_80E87AA((_DWORD *)(v19 + 20), v28);
      v29 = v29 - v23;
      if ( v22 )
        v29 = v29 - 9.0;
      sub_80DEC3C(
        (int)a1,
        (unsigned __int16 *)&s,
        v19 + 20,
        (int)(a1 + 49),
        (int)(a1 + 52),
        (int)v28,
        *(_DWORD *)(v19 + 204),
        a1[15]);
      if ( v34 <= 0x3Fu )
        goto LABEL_32;
      if ( s >= 1.0 )
      {
        if ( v23 != 0.0 )
          *(float *)(v19 + 28) = *(float *)(v19 + 28) - v23;
      }
      else
      {
        if ( v33[2] < 0.30000001 )
        {
LABEL_32:
          sub_80E87AA(v36, (_DWORD *)(v19 + 20));
          sub_80E87AA(v35, (_DWORD *)(v19 + 32));
          return;
        }
        sub_80DEB7A((float *)(v19 + 20), (float *)v28, s, (float *)(v19 + 20));
        sub_80DEDB0((float *)(v19 + 32), v33, (float *)(v19 + 32));
      }
    }
    sub_80E870E((float *)(v19 + 20), (float *)v39, v26);
    v10 = sub_80E873A(v26, (float *)(v19 + 32));
    v3 = sub_80E873A(v27, (float *)(v19 + 32)) + 0.001;
    v25[1] = v3 >= v10;
    if ( v3 >= v10 || v20 && Jump_IsPlayerAboveMax(v19) )
    {
      sub_80E87AA(v36, (_DWORD *)(v19 + 20));
      sub_80E87AA(v35, (_DWORD *)(v19 + 32));
      v23 = 0.0;
      if ( v22 )
      {
        sub_80E87AA((_DWORD *)(v19 + 20), v28);
        v29 = v29 - 9.0;
        sub_80DEC3C(
          (int)a1,
          (unsigned __int16 *)&s,
          v19 + 20,
          (int)(a1 + 49),
          (int)(a1 + 52),
          (int)v28,
          *(_DWORD *)(v19 + 204),
          a1[15]);
        if ( s < 1.0 )
        {
          sub_80DEB7A((float *)(v19 + 20), (float *)v28, s, (float *)v21);
          v23 = *(float *)&v21[2] - *(float *)(v19 + 28);
          sub_80E87AA(v21, (_DWORD *)(v19 + 20));
          sub_80DEDB0((float *)(v19 + 32), v33, (float *)(v19 + 32));
        }
      }
    }
    if ( v20 )
      Jump_ClampVelocity(v19, (int)v36);
    if ( v22 )
    {
      if ( *(int *)(v19 + 4) <= 5 )
      {
        if ( sub_80E7348((unsigned __int8 *)a1, v39, v38) )
        {
          v4 = *(float *)(v19 + 28) - v37;
          if ( sub_80E86BE(v4) > 0.5 )
          {
            v5 = *(float *)(v19 + 28) - v37;
            v15 = sub_80E86D8(v5);
            if ( v15 )
            {
              if ( v15 >= -16 )
              {
                if ( v15 > 24 )
                  v15 = 24;
              }
              else
              {
                v15 = -16;
              }
              v16 = v15 + 128;
              BG_AddPredictableEventToPlayerstate(143, v16, v19);
              v6 = *(float *)(v19 + 28) - v40;
              v14 = sub_80E86BE(v6);
              v13 = (1.0 - v14 / *(float *)v25) * 0.80000001 + 0.19999999;
              sub_80E881E((float *)(v19 + 32), v13, (float *)(v19 + 32));
              v17 = v16 - 128;
              v9 = v17;
              if ( v17 < 0 )
                v9 = -v17;
              if ( v9 > 3 && *(_DWORD *)(v19 + 96) != 1023 && sub_80E2EA6(a1) )
              {
                v8 = v17;
                if ( v17 < 0 )
                  v8 = -v17;
                v18 = v8 / 2;
                if ( v8 / 2 > 4 )
                  v18 = 4;
                v11 = (long double)v18 * 1.25 + 7.0;
                v12 = *(_DWORD *)(v19 + 8);
                *(_DWORD *)(v19 + 8) = (unsigned __int8)(int)((long double)v12 + v11);
                sub_80E2CDE(a1, a2, v12, *(_DWORD *)(v19 + 8), 1);
              }
            }
          }
        }
      }
    }
  }
}
// 80E7CC0: using guessed type _DWORD var_28[4];
// 80E7CC0: using guessed type float var_38[2];
// 80E7CC0: using guessed type _DWORD var_48[4];
// 80E7CC0: using guessed type float var_A0[2];
// 80E7CC0: using guessed type float var_A8[2];

//----- (080E86BE) --------------------------------------------------------
long double __cdecl sub_80E86BE(float a1)
{
  return (float)fabs(a1);
}

//----- (080E86D8) --------------------------------------------------------
int __cdecl sub_80E86D8(float a1)
{
  return (int)floor(a1 + 0.5);
}

//----- (080E870E) --------------------------------------------------------
float *__cdecl sub_80E870E(float *a1, float *a2, float *a3)
{
  float *result; // eax

  *a3 = *a1 - *a2;
  result = a1 + 1;
  a3[1] = a1[1] - a2[1];
  return result;
}

//----- (080E873A) --------------------------------------------------------
long double __cdecl sub_80E873A(float *a1, float *a2)
{
  return *a1 * *a2 + a1[1] * a2[1];
}

//----- (080E875C) --------------------------------------------------------
int __cdecl sub_80E875C(_DWORD *a1)
{
  int result; // eax

  *a1 = 0;
  a1[1] = 0;
  result = 0;
  a1[2] = 0;
  return result;
}

//----- (080E8786) --------------------------------------------------------
int __cdecl sub_80E8786(_DWORD *a1, int a2, int a3, int a4)
{
  int result; // eax

  *a1 = a2;
  a1[1] = a3;
  result = a4;
  a1[2] = a4;
  return result;
}

//----- (080E87AA) --------------------------------------------------------
int __cdecl sub_80E87AA(_DWORD *a1, _DWORD *a2)
{
  int result; // eax

  *a2 = *a1;
  a2[1] = a1[1];
  result = a1[2];
  a2[2] = result;
  return result;
}

//----- (080E87DA) --------------------------------------------------------
float *__cdecl sub_80E87DA(float *a1, float *a2, float *a3)
{
  float *result; // eax

  *a3 = *a1 + *a2;
  a3[1] = a1[1] + a2[1];
  result = a1 + 2;
  a3[2] = a1[2] + a2[2];
  return result;
}

//----- (080E881E) --------------------------------------------------------
float *__cdecl sub_80E881E(float *a1, float a2, float *a3)
{
  float *result; // eax

  *a3 = a2 * *a1;
  a3[1] = a2 * a1[1];
  result = a1 + 2;
  a3[2] = a2 * a1[2];
  return result;
}

//----- (080E8856) --------------------------------------------------------
float *__cdecl sub_80E8856(float *a1, float a2, float *a3, float *a4)
{
  float *result; // eax

  *a4 = a2 * *a3 + *a1;
  a4[1] = a2 * a3[1] + a1[1];
  result = a3 + 2;
  a4[2] = a2 * a3[2] + a1[2];
  return result;
}

//----- (080E88AA) --------------------------------------------------------
long double __cdecl sub_80E88AA(float *a1, float *a2)
{
  return *a1 * *a2 + a1[1] * a2[1] + a1[2] * a2[2];
}

//----- (080E88E0) --------------------------------------------------------
void sub_80E88E0()
{
  dword_8576140 = 0;
}
// 8576140: using guessed type int dword_8576140;

//----- (080E88F0) --------------------------------------------------------
int __cdecl sub_80E88F0(int a1)
{
  _DWORD *v1; // eax
  int result; // eax
  _DWORD *v3; // [esp+10h] [ebp-8h]

  v1 = (_DWORD *)BG_WeaponDefs(a1);
  v3 = (_DWORD *)((char *)&unk_8164C20 + 44 * a1);
  v3[1] = v1[38];
  v3[2] = v1[109];
  v3[3] = 0;
  v3[4] = v1[110];
  v3[5] = v1[1];
  v3[6] = v1[112];
  v3[7] = 1;
  v3[8] = a1;
  v3[9] = v1[114];
  result = v1[116];
  v3[10] = result;
  return result;
}

//----- (080E89A8) --------------------------------------------------------
int __cdecl BG_FillInAmmoItems(void (__cdecl *a1)(int))
{
  int result; // eax
  char dest[76]; // [esp+10h] [ebp-68h] BYREF
  char *j; // [esp+5Ch] [ebp-1Ch]
  int v4; // [esp+60h] [ebp-18h]
  int v5; // [esp+64h] [ebp-14h]
  int v6; // [esp+68h] [ebp-10h]
  int i; // [esp+6Ch] [ebp-Ch]

  for ( i = 129; ; ++i )
  {
    result = i;
    if ( i >= 131 )
      break;
    v4 = (int)&unk_8164C20 + 44 * i;
    if ( *(_DWORD *)(v4 + 28) == 2 )
    {
      I_strncpyz(dest, *(char **)(v4 + 20), 64);
      for ( j = dest; *j; ++j )
      {
        if ( *j == 32 )
        {
          *j = 0;
          break;
        }
      }
      v6 = sub_80E94F0(dest, a1);
      if ( v6 )
      {
        v5 = BG_WeaponDefs(v6);
        *(_DWORD *)(v4 + 32) = v6;
        *(_DWORD *)(v4 + 36) = *(_DWORD *)(v5 + 456);
        result = *(_DWORD *)(v5 + 464);
        *(_DWORD *)(v4 + 40) = result;
        return result;
      }
      Com_Printf("^3WARNING^7: Could not find weapon for ammo item %s\n", *(const char **)(v4 + 20));
      v6 = sub_80E94F0("defaultweapon_mp", a1);
      if ( !v6 )
        Com_Error(1, (char *)&byte_814E260);
      v5 = BG_WeaponDefs(v6);
      *(_DWORD *)(v4 + 32) = 1;
      *(_DWORD *)(v4 + 36) = *(_DWORD *)(v5 + 456);
      *(_DWORD *)(v4 + 40) = *(_DWORD *)(v5 + 464);
    }
  }
  return result;
}

//----- (080E8B16) --------------------------------------------------------
int __cdecl sub_80E8B16(int a1)
{
  int result; // eax
  int v2; // [esp+28h] [ebp-10h]
  int j; // [esp+2Ch] [ebp-Ch]
  int i; // [esp+30h] [ebp-8h]
  int v5; // [esp+34h] [ebp-4h]

  v5 = BG_WeaponDefs(a1);
  for ( i = 0; ; ++i )
  {
    if ( i >= dword_8576560 )
    {
      dword_8576360[i] = v5;
      result = i;
      *(_DWORD *)(v5 + 456) = i;
      ++dword_8576560;
      return result;
    }
    if ( !strcmp(*(const char **)(dword_8576360[i] + 452), *(const char **)(v5 + 452)) )
      break;
  }
  *(_DWORD *)(v5 + 456) = i;
  result = *(_DWORD *)(dword_8576360[i] + 468);
  if ( result != *(_DWORD *)(v5 + 468) && i )
  {
    for ( j = 1; ; ++j )
    {
      result = j;
      if ( j >= a1 )
        break;
      v2 = dword_8576160[j];
      if ( !I_stricmp(*(char **)(dword_8576360[i] + 452), *(char **)(v2 + 452))
        && *(_DWORD *)(v2 + 468) == *(_DWORD *)(dword_8576360[i] + 468) )
      {
        Com_Error(
          1,
          (char *)&byte_814E2C0,
          *(_DWORD *)(v5 + 452),
          *(_DWORD *)v5,
          *(_DWORD *)(v5 + 468),
          *(_DWORD *)v2,
          *(_DWORD *)(v2 + 468));
      }
    }
  }
  return result;
}
// 8576160: using guessed type int dword_8576160[128];
// 8576360: using guessed type int dword_8576360[128];
// 8576560: using guessed type int dword_8576560;

//----- (080E8C8C) --------------------------------------------------------
_BYTE *__cdecl sub_80E8C8C(int a1)
{
  _BYTE *result; // eax
  int v2; // [esp+28h] [ebp-10h]
  int j; // [esp+2Ch] [ebp-Ch]
  _DWORD *v4; // [esp+30h] [ebp-8h]
  int i; // [esp+34h] [ebp-4h]

  v4 = (_DWORD *)BG_WeaponDefs(a1);
  v4[121] = -1;
  result = (_BYTE *)v4[120];
  if ( *result )
  {
    Com_DPrintf("%s: %s\n", (const char *)*v4, (const char *)v4[120]);
    for ( i = 0; ; ++i )
    {
      if ( i >= dword_8576780 )
      {
        dword_8576580[i] = (int)v4;
        result = (_BYTE *)i;
        v4[121] = i;
        ++dword_8576780;
        return result;
      }
      if ( !I_stricmp(*(char **)(dword_8576580[i] + 480), (char *)v4[120]) )
        break;
    }
    v4[121] = i;
    result = *(_BYTE **)(dword_8576580[i] + 488);
    if ( result != (_BYTE *)v4[122] && i )
    {
      for ( j = 1; ; ++j )
      {
        result = (_BYTE *)j;
        if ( j >= a1 )
          break;
        v2 = dword_8576160[j];
        if ( !I_stricmp(*(char **)(dword_8576580[i] + 480), *(char **)(v2 + 480))
          && *(_DWORD *)(v2 + 488) == *(_DWORD *)(dword_8576580[i] + 488) )
        {
          Com_Error(1, (char *)&byte_814E320, v4[120], *v4, v4[122], *(_DWORD *)v2, *(_DWORD *)(v2 + 488));
        }
      }
    }
  }
  return result;
}
// 8576160: using guessed type int dword_8576160[128];
// 8576580: using guessed type int dword_8576580[128];
// 8576780: using guessed type int dword_8576780;

//----- (080E8E44) --------------------------------------------------------
int __cdecl sub_80E8E44(int a1)
{
  int result; // eax
  int v2; // [esp+28h] [ebp-10h]
  int j; // [esp+2Ch] [ebp-Ch]
  int v4; // [esp+30h] [ebp-8h]
  int i; // [esp+34h] [ebp-4h]

  v4 = BG_WeaponDefs(a1);
  for ( i = 0; ; ++i )
  {
    if ( i >= dword_85769A0 )
    {
      dword_85767A0[i] = v4;
      result = i;
      *(_DWORD *)(v4 + 464) = i;
      ++dword_85769A0;
      return result;
    }
    if ( !strcmp(*(const char **)(dword_85767A0[i] + 460), *(const char **)(v4 + 460)) )
      break;
  }
  *(_DWORD *)(v4 + 464) = i;
  result = *(_DWORD *)(dword_85767A0[i] + 472);
  if ( result != *(_DWORD *)(v4 + 472) && i )
  {
    for ( j = 1; ; ++j )
    {
      result = j;
      if ( j >= a1 )
        break;
      v2 = dword_8576160[j];
      if ( !I_stricmp(*(char **)(dword_85767A0[i] + 460), *(char **)(v2 + 460))
        && *(_DWORD *)(v2 + 472) == *(_DWORD *)(dword_85767A0[i] + 472) )
      {
        Com_Error(
          1,
          (char *)&byte_814E3A0,
          *(_DWORD *)(v4 + 452),
          *(_DWORD *)v4,
          *(_DWORD *)(v4 + 472),
          *(_DWORD *)v2,
          *(_DWORD *)(v2 + 472));
      }
    }
  }
  return result;
}
// 8576160: using guessed type int dword_8576160[128];
// 85767A0: using guessed type int dword_85767A0[128];
// 85769A0: using guessed type int dword_85769A0;

//----- (080E8FBA) --------------------------------------------------------
_BYTE *__cdecl sub_80E8FBA(int a1, int a2)
{
  _BYTE *result; // eax
  _DWORD *v3; // [esp+1Ch] [ebp-Ch]
  _DWORD *v4; // [esp+20h] [ebp-8h]
  int v5; // [esp+24h] [ebp-4h]

  v4 = (_DWORD *)BG_WeaponDefs(a1);
  v4[219] = 0;
  result = (_BYTE *)v4[218];
  if ( *result )
  {
    v5 = sub_80E94F0((char *)v4[218], a2);
    if ( !v5 )
      Com_Error(1, (char *)&byte_814E400, v4[218], *v4);
    v4[219] = v5;
    v3 = (_DWORD *)dword_8576160[v5];
    if ( v4[32] != v3[32] )
      Com_Error(1, (char *)&byte_814E440, *v4, *v3);
    result = (_BYTE *)v4[34];
    if ( result != (_BYTE *)v3[34] )
      Com_Error(1, (char *)&byte_814E4A0, *v4, *v3);
  }
  return result;
}
// 8576160: using guessed type int dword_8576160[128];

//----- (080E90C8) --------------------------------------------------------
int BG_ClearWeaponDef()
{
  int i; // [esp+4h] [ebp-4h]

  dword_8576160[0] = (int)BG_LoadDefaultWeaponDef();
  dword_8576360[0] = dword_8576160[0];
  dword_8576560 = 1;
  dword_8576580[0] = dword_8576160[0];
  dword_8576780 = 1;
  dword_85767A0[0] = dword_8576160[0];
  dword_85769A0 = 1;
  for ( i = 1; i <= 128; ++i )
    dword_8164C3C[11 * i] = 0;
  BG_LoadPlayerAnimTypes();
  return sub_80D4A08();
}
// 8164C3C: using guessed type int dword_8164C3C[1449];
// 8576160: using guessed type int dword_8576160[128];
// 8576360: using guessed type int dword_8576360[128];
// 8576560: using guessed type int dword_8576560;
// 8576580: using guessed type int dword_8576580[128];
// 8576780: using guessed type int dword_8576780;
// 85767A0: using guessed type int dword_85767A0[128];
// 85769A0: using guessed type int dword_85769A0;

//----- (080E9154) --------------------------------------------------------
int __cdecl sub_80E9154(int a1)
{
  sub_80E8B16(a1);
  sub_80E8C8C(a1);
  sub_80E8E44(a1);
  return sub_80E88F0(a1);
}

//----- (080E9188) --------------------------------------------------------
int __cdecl sub_80E9188(int a1, void (__cdecl *a2)(int))
{
  int v3; // [esp+14h] [ebp-4h]

  v3 = ++dword_8576140;
  dword_8576160[dword_8576140] = a1;
  sub_80E9154(v3);
  sub_80E8FBA(v3, (int)a2);
  if ( a2 )
    a2(v3);
  return v3;
}
// 8576140: using guessed type int dword_8576140;
// 8576160: using guessed type int dword_8576160[128];

//----- (080E91DC) --------------------------------------------------------
int sub_80E91DC()
{
  int result; // eax
  int v1; // [esp+10h] [ebp-8h]
  int i; // [esp+14h] [ebp-4h]

  v1 = BG_GetNumWeapons();
  for ( i = 1; ; ++i )
  {
    result = i;
    if ( i > v1 )
      break;
    sub_80E9154(i);
  }
  return result;
}

//----- (080E9210) --------------------------------------------------------
int __cdecl sub_80E9210(int a1, int a2)
{
  int result; // eax

  result = a1;
  if ( *(int *)(a1 + 4) <= 5 )
  {
    result = a2 | *(_DWORD *)(a1 + 1488) & 0x200 ^ 0x200;
    *(_DWORD *)(a1 + 1488) = result;
  }
  return result;
}

//----- (080E9240) --------------------------------------------------------
int __cdecl sub_80E9240(int a1, int a2)
{
  int result; // eax

  result = *(_DWORD *)(a1 + 1488) & 0xFFFFFDFF;
  if ( result != a2 )
    return sub_80E9210(a1, a2);
  return result;
}

//----- (080E9270) --------------------------------------------------------
int __cdecl BG_WeaponDefs(int a1)
{
  return dword_8576160[a1];
}
// 8576160: using guessed type int dword_8576160[128];

//----- (080E9280) --------------------------------------------------------
int *__cdecl sub_80E9280(int a1)
{
  int *result; // eax
  int v2; // [esp+Ch] [ebp-Ch]
  int i; // [esp+10h] [ebp-8h] BYREF

  v2 = sub_80E958C("defaultweapon_mp");
  if ( !v2 )
    Com_Error(1, (char *)&byte_814E500);
  *(_DWORD *)(dword_8576160[a1] + 12) = *(_DWORD *)(dword_8576160[v2] + 12);
  result = *(int **)(dword_8576160[v2] + 16);
  *(_DWORD *)(dword_8576160[a1] + 16) = result;
  for ( i = 0; i <= 22; ++i )
  {
    *(_DWORD *)(dword_8576160[a1] + 4 * i + 20) = *(_DWORD *)(dword_8576160[v2] + 4 * i + 20);
    result = &i;
  }
  return result;
}
// 8576160: using guessed type int dword_8576160[128];

//----- (080E9322) --------------------------------------------------------
int BG_GetNumWeapons()
{
  return dword_8576140;
}
// 8576140: using guessed type int dword_8576140;

//----- (080E9336) --------------------------------------------------------
int __cdecl sub_80E9336(int a1)
{
  return *(_DWORD *)(dword_8576360[a1] + 468);
}
// 8576360: using guessed type int dword_8576360[128];

//----- (080E9356) --------------------------------------------------------
int __cdecl sub_80E9356(int a1)
{
  return *(_DWORD *)(dword_85767A0[a1] + 472);
}
// 85767A0: using guessed type int dword_85767A0[128];

//----- (080E936C) --------------------------------------------------------
int __cdecl sub_80E936C(int a1)
{
  return *(_DWORD *)(dword_8576580[a1] + 488);
}
// 8576580: using guessed type int dword_8576580[128];

//----- (080E93C4) --------------------------------------------------------
int __cdecl sub_80E93C4(char *a1)
{
  int i; // [esp+14h] [ebp-4h]

  for ( i = 0; i < dword_8576560; ++i )
  {
    if ( !I_stricmp(*(char **)(dword_8576360[i] + 452), a1) )
      return i;
  }
  Com_DPrintf("Couldn't find ammo type \"%s\"\n", a1);
  return 0;
}
// 8576360: using guessed type int dword_8576360[128];
// 8576560: using guessed type int dword_8576560;

//----- (080E9430) --------------------------------------------------------
int __cdecl sub_80E9430(char *a1)
{
  int i; // [esp+14h] [ebp-4h]

  for ( i = 0; i < dword_85769A0; ++i )
  {
    if ( !I_stricmp(*(char **)(dword_85767A0[i] + 460), a1) )
      return i;
  }
  Com_DPrintf("Couldn't find ammo clip \"%s\"\n", a1);
  return 0;
}
// 85767A0: using guessed type int dword_85767A0[128];
// 85769A0: using guessed type int dword_85769A0;

//----- (080E949C) --------------------------------------------------------
int __cdecl BG_FindWeaponIndexForName(char *a1)
{
  int i; // [esp+14h] [ebp-4h]

  for ( i = 1; i <= dword_8576140; ++i )
  {
    if ( !I_stricmp(a1, *(char **)dword_8576160[i]) )
      return i;
  }
  return 0;
}
// 8576140: using guessed type int dword_8576140;
// 8576160: using guessed type int dword_8576160[128];

//----- (080E94F0) --------------------------------------------------------
int __cdecl sub_80E94F0(char *s1, void (__cdecl *a2)(int))
{
  char **v4; // [esp+10h] [ebp-8h]
  int v5; // [esp+14h] [ebp-4h]

  if ( !*s1 || !strcasecmp(s1, "none") )
    return 0;
  v5 = BG_FindWeaponIndexForName(s1);
  if ( v5 )
    return v5;
  v4 = sub_80F0110("mp", s1);
  if ( v4 )
    return sub_80E9188((int)v4, a2);
  Com_DPrintf("Couldn't find weapon \"%s\"\n", s1);
  return 0;
}

//----- (080E958C) --------------------------------------------------------
int __cdecl sub_80E958C(char *s1)
{
  return sub_80E94F0(s1, 0);
}

//----- (080E95A8) --------------------------------------------------------
int sub_80E95A8()
{
  int i; // [esp+4h] [ebp-4h]

  for ( i = 1; i <= dword_8576140; ++i )
  {
    if ( *(_DWORD *)(dword_8576160[i] + 120) == 3 )
      return (unsigned __int8)i;
  }
  return 0;
}
// 8576140: using guessed type int dword_8576140;
// 8576160: using guessed type int dword_8576160[128];

//----- (080E95EE) --------------------------------------------------------
int __cdecl sub_80E95EE(_DWORD *a1)
{
  if ( (a1[3] & 0x20000) != 0 )
    return sub_80E95A8();
  if ( (a1[3] & 0x10) != 0 )
    return a1[52];
  return a1[53];
}

//----- (080E963A) --------------------------------------------------------
int __cdecl sub_80E963A(int a1, int a2)
{
  int v4; // [esp+Ch] [ebp-Ch]
  int i; // [esp+10h] [ebp-8h]

  v4 = BG_GetNumWeapons();
  for ( i = 1; i <= v4; ++i )
  {
    if ( *(_DWORD *)(BG_WeaponDefs(i) + 132) == a2 && (unsigned __int8)sub_80D9E84(a1 + 1348, i) && sub_80EACC8(a1, i) )
      return i;
  }
  return 0;
}

//----- (080E973E) --------------------------------------------------------
int __cdecl sub_80E973E(int a1)
{
  return *(_DWORD *)(BG_WeaponDefs(a1) + 812);
}

//----- (080E9758) --------------------------------------------------------
int __cdecl sub_80E9758(int a1)
{
  int v2; // [esp+4h] [ebp-4h]

  v2 = 0;
  if ( a1 >= 0 && a1 <= BG_GetNumWeapons() )
    return 1;
  return v2;
}

//----- (080E9782) --------------------------------------------------------
int __cdecl sub_80E9782(int a1)
{
  int v2; // [esp+10h] [ebp-8h]
  _DWORD *v3; // [esp+14h] [ebp-4h]

  v3 = (_DWORD *)(BG_WeaponDefs(a1) + 128);
  v2 = 0;
  if ( *v3 == 1 || *v3 == 2 )
    return 1;
  return v2;
}

//----- (080E97BE) --------------------------------------------------------
int __cdecl sub_80E97BE(int a1)
{
  int v2; // [esp+0h] [ebp-4h]

  v2 = 0;
  if ( !*(_BYTE *)(a1 + 1365) || !*(_BYTE *)(a1 + 1366) )
    return 1;
  return v2;
}

//----- (080E97F0) --------------------------------------------------------
_BOOL4 __cdecl BG_IsWeaponValid(int a1, int a2)
{
  int v3; // [esp+Ch] [ebp-Ch]
  bool v4; // [esp+17h] [ebp-1h]

  v4 = (unsigned __int8)sub_80E9758(a2) != 0;
  if ( !(unsigned __int8)sub_80D9E84(a1 + 1348, a2) )
    v4 = 0;
  v3 = BG_WeaponDefs(a2);
  if ( !*(_DWORD *)(v3 + 132) && *(char *)(a1 + 1365) != a2 && *(char *)(a1 + 1366) != a2 && *(_DWORD *)(v3 + 876) != a2 )
    return 0;
  return v4;
}

//----- (080E9882) --------------------------------------------------------
_BOOL4 __cdecl sub_80E9882(int a1)
{
  int v3; // [esp+14h] [ebp-4h]

  v3 = BG_WeaponDefs(a1);
  return *(_DWORD *)(v3 + 124) != 9 && *(_DWORD *)(v3 + 132) == 0;
}

//----- (080E98CA) --------------------------------------------------------
int __cdecl sub_80E98CA(int a1, int a2)
{
  int v4; // [esp+18h] [ebp-10h]
  _DWORD *v5; // [esp+1Ch] [ebp-Ch]
  int v6; // [esp+20h] [ebp-8h]
  int i; // [esp+24h] [ebp-4h]
  int j; // [esp+24h] [ebp-4h]

  if ( !(unsigned __int8)sub_80D9E84(a1 + 1348, a2) )
    return 0;
  v5 = (_DWORD *)BG_WeaponDefs(a2);
  v6 = sub_80E9B54(a1, a2, 1);
  if ( v6 )
  {
    if ( v5[34] )
    {
      for ( i = 1; i <= dword_8576140; ++i )
      {
        v4 = BG_WeaponDefs(a2);
        if ( *(_DWORD *)(v4 + 136)
          && *(_DWORD *)(v4 + 128) == v5[32]
          && (unsigned __int8)sub_80D9E84(a1 + 1348, i)
          && !sub_80E9B54(a1, i, 1) )
        {
          *(_BYTE *)(v6 + a1 + 1364) = i;
          break;
        }
      }
      if ( i > dword_8576140 )
        *(_BYTE *)(v6 + a1 + 1364) = 0;
    }
    else
    {
      *(_BYTE *)(v6 + a1 + 1364) = 0;
    }
  }
  sub_80F0400(a1 + 1348, a2);
  for ( j = v5[219]; j && (unsigned __int8)sub_80D9E84(a1 + 1348, j); j = *(_DWORD *)(BG_WeaponDefs(j) + 876) )
    sub_80F0400(a1 + 1348, j);
  if ( a2 == *(_DWORD *)(a1 + 212) )
    *(_DWORD *)(a1 + 212) = 0;
  return 1;
}
// 8576140: using guessed type int dword_8576140;

//----- (080E9A9E) --------------------------------------------------------
int __cdecl sub_80E9A9E(int a1, int a2, int a3)
{
  if ( !(unsigned __int8)sub_80D9E84(a1 + 1348, a3) )
    return 0;
  if ( (unsigned int)(*(_DWORD *)(BG_WeaponDefs(a3) + 128) - 1) > 1 )
    return 0;
  if ( a2 != 1 && a2 != 2 )
    return 0;
  if ( a3 != *(char *)(a2 + a1 + 1364) && a3 != *(_DWORD *)(a1 + 212) )
    *(_DWORD *)(a1 + 212) = 0;
  *(_BYTE *)(a2 + a1 + 1364) = a3;
  return 1;
}

//----- (080E9B54) --------------------------------------------------------
int __cdecl sub_80E9B54(int a1, int a2, int a3)
{
  int v5; // [esp+10h] [ebp-8h]
  int v6; // [esp+14h] [ebp-4h]

  if ( !(unsigned __int8)sub_80D9E84(a1 + 1348, a2) )
    return 0;
  v6 = a2;
  do
  {
    v5 = BG_WeaponDefs(v6);
    if ( (unsigned int)(*(_DWORD *)(v5 + 128) - 1) > 1 )
      return 0;
    if ( *(char *)(a1 + 1365) == v6 )
      return 1;
    if ( *(char *)(a1 + 1366) == v6 )
      return 2;
    if ( a3 && *(_DWORD *)(v5 + 876) )
      v6 = *(_DWORD *)(v5 + 876);
  }
  while ( v6 != a2 );
  return 0;
}

//----- (080E9C10) --------------------------------------------------------
int __cdecl sub_80E9C10(int a1, int a2)
{
  if ( (unsigned int)(*(_DWORD *)(BG_WeaponDefs(a2) + 128) - 1) > 1 )
    return 0;
  if ( *(_BYTE *)(a1 + 1365) )
  {
    if ( !*(_BYTE *)(a1 + 1366) )
      return 2;
    return 0;
  }
  return 1;
}

//----- (080E9C6A) --------------------------------------------------------
int __cdecl sub_80E9C6A(int a1, int a2, int a3)
{
  int v5; // [esp+14h] [ebp-4h]

  v5 = BG_WeaponDefs(a2);
  if ( *(_DWORD *)(v5 + 136) )
  {
    if ( (unsigned int)(*(_DWORD *)(v5 + 128) - 1) <= 1 )
    {
      if ( a3 == 1 || a3 == 2 )
      {
        if ( !*(_BYTE *)(a3 + a1 + 1364) )
          return a3;
        if ( *(_DWORD *)(BG_WeaponDefs(*(char *)(a3 + a1 + 1364)) + 136) )
          return a3;
      }
      if ( !*(_BYTE *)(a1 + 1365) )
        return 1;
      if ( *(_DWORD *)(BG_WeaponDefs(*(char *)(a1 + 1365)) + 136) )
        return 1;
      if ( !*(_BYTE *)(a1 + 1366) )
        return 2;
      if ( *(_DWORD *)(BG_WeaponDefs(*(char *)(a1 + 1366)) + 136) )
        return 2;
    }
    return 0;
  }
  return 0;
}

//----- (080E9DE0) --------------------------------------------------------
int __cdecl sub_80E9DE0(int a1, int a2)
{
  int v2; // eax
  int v3; // eax
  int v4; // eax
  int v5; // eax
  int v7[128]; // [esp+10h] [ebp-428h] BYREF
  int s[130]; // [esp+210h] [ebp-228h] BYREF
  int v9; // [esp+418h] [ebp-20h]
  int v10; // [esp+41Ch] [ebp-1Ch]
  int v11; // [esp+420h] [ebp-18h]
  int v12; // [esp+424h] [ebp-14h]
  int v13; // [esp+428h] [ebp-10h]
  int i; // [esp+42Ch] [ebp-Ch]

  memset(s, 0, 0x200u);
  memset(v7, 0, sizeof(v7));
  v13 = BG_WeaponDefs(a2);
  v10 = sub_80EAC94(a2);
  v9 = sub_80EAC7A(a2);
  if ( *(int *)(v13 + 484) < 0 )
  {
    if ( sub_80EACAE(a2) )
    {
      v4 = sub_80E9356(v9);
      return v4 - *(_DWORD *)(a1 + 4 * v9 + 836);
    }
    else
    {
      v5 = sub_80E9336(v10);
      return v5 - *(_DWORD *)(a1 + 4 * v10 + 324);
    }
  }
  else
  {
    v11 = sub_80E936C(*(_DWORD *)(v13 + 484));
    for ( i = 1; i <= dword_8576140; ++i )
    {
      if ( (unsigned __int8)sub_80D9E84(a1 + 1348, i) )
      {
        v12 = BG_WeaponDefs(i);
        if ( *(_DWORD *)(v12 + 484) == *(_DWORD *)(v13 + 484) )
        {
          if ( sub_80EACAE(i) )
          {
            if ( !v7[sub_80EAC7A(i)] )
            {
              v7[sub_80EAC7A(i)] = 1;
              v2 = sub_80EAC7A(i);
              v11 -= *(_DWORD *)(a1 + 4 * v2 + 836);
            }
          }
          else if ( !s[sub_80EAC94(i)] )
          {
            s[sub_80EAC94(i)] = 1;
            v3 = sub_80EAC94(i);
            v11 -= *(_DWORD *)(a1 + 4 * v3 + 324);
          }
        }
      }
    }
  }
  return v11;
}
// 8576140: using guessed type int dword_8576140;
// 80E9DE0: using guessed type int s[130];
// 80E9DE0: using guessed type int var_428[128];

//----- (080E9FD2) --------------------------------------------------------
int __cdecl sub_80E9FD2(int a1, int a2)
{
  int v2; // eax
  int v3; // eax
  int v5[128]; // [esp+10h] [ebp-428h] BYREF
  int s[130]; // [esp+210h] [ebp-228h] BYREF
  int v7; // [esp+418h] [ebp-20h]
  int v8; // [esp+41Ch] [ebp-1Ch]
  int v9; // [esp+420h] [ebp-18h]
  int v10; // [esp+424h] [ebp-14h]
  int v11; // [esp+428h] [ebp-10h]
  int i; // [esp+42Ch] [ebp-Ch]

  v9 = 0;
  v8 = sub_80EAC94(a2);
  v7 = sub_80EAC7A(a2);
  memset(s, 0, 0x200u);
  memset(v5, 0, sizeof(v5));
  v11 = BG_WeaponDefs(a2);
  if ( *(int *)(v11 + 484) < 0 )
  {
    if ( sub_80EACAE(a2) )
      return *(_DWORD *)(a1 + 4 * v7 + 836);
    else
      return *(_DWORD *)(a1 + 4 * v8 + 324);
  }
  else
  {
    for ( i = 1; i <= dword_8576140; ++i )
    {
      if ( (unsigned __int8)sub_80D9E84(a1 + 1348, i) )
      {
        v10 = BG_WeaponDefs(i);
        if ( *(_DWORD *)(v10 + 484) == *(_DWORD *)(v11 + 484) )
        {
          if ( sub_80EACAE(i) )
          {
            if ( !v5[sub_80EAC7A(i)] )
            {
              v5[sub_80EAC7A(i)] = 1;
              v2 = sub_80EAC7A(i);
              v9 += *(_DWORD *)(a1 + 4 * v2 + 836);
            }
          }
          else if ( !s[sub_80EAC94(i)] )
          {
            s[sub_80EAC94(i)] = 1;
            v3 = sub_80EAC94(i);
            v9 += *(_DWORD *)(a1 + 4 * v3 + 324);
          }
        }
      }
    }
  }
  return v9;
}
// 8576140: using guessed type int dword_8576140;
// 80E9FD2: using guessed type int s[130];
// 80E9FD2: using guessed type int var_428[128];

//----- (080EA198) --------------------------------------------------------
float *__cdecl sub_80EA198(int a1, int a2, float *a3, float *a4)
{
  float *result; // eax
  float v5; // [esp+10h] [ebp-8h]
  float v6; // [esp+10h] [ebp-8h]
  float *v7; // [esp+14h] [ebp-4h]

  v7 = (float *)BG_WeaponDefs(a2);
  if ( *(float *)(a1 + 248) <= 40.0 )
  {
    v6 = (*(float *)(a1 + 248) - 11.0) / 29.0;
    *a3 = (v7[164] - v7[165]) * v6 + v7[165];
    result = v7;
    *a4 = (v7[167] - v7[168]) * v6 + v7[168];
  }
  else
  {
    v5 = (*(float *)(a1 + 248) - 40.0) / 20.0;
    *a3 = (v7[163] - v7[164]) * v5 + v7[164];
    result = v7;
    *a4 = (v7[166] - v7[167]) * v5 + v7[167];
  }
  return result;
}

//----- (080EA28E) --------------------------------------------------------
int __cdecl sub_80EA28E(int a1)
{
  int v2; // [esp+0h] [ebp-4h]

  v2 = 0;
  if ( a1 == 19 || a1 == 20 )
    return 1;
  return v2;
}

//----- (080EA2B6) --------------------------------------------------------
_BOOL4 __cdecl sub_80EA2B6(_DWORD *a1, int a2)
{
  int v3; // [esp+8h] [ebp-10h]
  int v5; // [esp+10h] [ebp-8h]

  v3 = a1[1];
  if ( v3 == 1 )
  {
    if ( *(_DWORD *)(a2 + 52) )
      return 0;
  }
  else if ( v3 >= 1 && v3 <= 7 )
  {
    return 0;
  }
  v5 = sub_80E95EE(a1);
  if ( !*(_DWORD *)(BG_WeaponDefs(v5) + 812) )
    return 0;
  if ( (int)a1[54] > 11 && (int)a1[54] <= 16 )
    return 0;
  if ( a1[54] == 10 || a1[54] == 11 )
    return 0;
  if ( a1[54] == 1 || a1[54] == 2 )
    return 0;
  return (int)a1[54] <= 16 || (int)a1[54] > 22 || (unsigned __int8)sub_80EA28E(a1[54]);
}

//----- (080EA3DA) --------------------------------------------------------
int __cdecl sub_80EA3DA(int a1)
{
  int v2; // [esp+0h] [ebp-4h]

  v2 = 0;
  if ( *(_DWORD *)(a1 + 216) == 19 || *(_DWORD *)(a1 + 216) == 20 )
    return 1;
  return v2;
}

//----- (080EA40E) --------------------------------------------------------
int __cdecl sub_80EA40E(int a1, int a2)
{
  char v3; // [esp+1Fh] [ebp-9h]
  _DWORD *v4; // [esp+20h] [ebp-8h]
  bool v5; // [esp+27h] [ebp-1h]

  v4 = *(_DWORD **)a1;
  v4[3] &= ~0x40u;
  v5 = sub_80EA2B6(v4, a2);
  v3 = 0;
  if ( (*(_DWORD *)(a1 + 8) & 0x1000) != 0 || (unsigned __int8)sub_80EA3DA((int)v4) )
    v3 = 1;
  if ( v3 && v5 )
  {
    if ( (v4[3] & 1) != 0 )
    {
      if ( (*(_DWORD *)(a1 + 36) & 0x1000) == 0 || !*(_BYTE *)(a1 + 28) && !*(_BYTE *)(a1 + 29) )
      {
        v4[3] |= 0x40u;
        v4[3] |= 0x800u;
      }
    }
    else
    {
      v4[3] |= 0x40u;
    }
  }
  if ( (v4[3] & 0x40) != 0 )
    return sub_80D70E2(v4[51], 7, 1, 1);
  else
    return sub_80D70E2(v4[51], 7, 0, 1);
}

//----- (080EA53E) --------------------------------------------------------
unsigned int __cdecl sub_80EA53E(int a1)
{
  unsigned int result; // eax

  sub_80DED2E(a1, 149);
  result = *(_DWORD *)(a1 + 12) & 0xFFFFFFBF;
  *(_DWORD *)(a1 + 12) = result;
  return result;
}

//----- (080EA568) --------------------------------------------------------
void __cdecl sub_80EA568(int *a1, int a2)
{
  long double v2; // fst7
  int v3; // [esp+14h] [ebp-14h]
  char v4; // [esp+1Bh] [ebp-Dh]
  int v5; // [esp+1Ch] [ebp-Ch]
  int v6; // [esp+20h] [ebp-8h]

  v3 = *a1;
  v5 = sub_80E95EE((_DWORD *)*a1);
  v6 = BG_WeaponDefs(v5);
  if ( *(_BYTE *)(player_scopeExitOnDamage + 8) && *(_DWORD *)(v3 + 296) && *(_DWORD *)(v6 + 632) )
  {
    sub_80EA53E(v3);
    *(_DWORD *)(v3 + 220) = 0;
    *(_DWORD *)(v3 + 224) = 0;
  }
  else if ( *(_DWORD *)(v6 + 812) )
  {
    v4 = 0;
    if ( !*(_DWORD *)(v6 + 860) && *(_DWORD *)(v3 + 216) == 5 && *(_DWORD *)(v3 + 52) - *(_DWORD *)(v6 + 1316) > 0
      || *(_DWORD *)(v6 + 860)
      && (*(_DWORD *)(v3 + 216) == 5
       || *(_DWORD *)(v3 + 216) == 6
       || *(_DWORD *)(v3 + 216) == 7
       || *(_DWORD *)(v3 + 216) == 8
       || *(_DWORD *)(v3 + 216) == 9 && *(_DWORD *)(v3 + 52) - *(_DWORD *)(v6 + 1316) > 0)
      || !*(_DWORD *)(v6 + 816) && *(_DWORD *)(v3 + 216) == 4 )
    {
      v4 = 0;
    }
    else if ( (*(_DWORD *)(v3 + 12) & 0x40) != 0 )
    {
      v4 = 1;
    }
    if ( *(_DWORD *)(v6 + 840) && *(_DWORD *)(v3 + 56) && *(_DWORD *)(v3 + 216) == 3 )
      v4 = 1;
    if ( 1.0 != *(float *)(v3 + 220) || v4 || *(int *)(player_adsExitDelay + 8) <= 0 )
    {
      *(_DWORD *)(v3 + 224) = 0;
    }
    else
    {
      if ( !*(_DWORD *)(v3 + 224) )
        *(_DWORD *)(v3 + 224) = a1[1] + *(_DWORD *)(player_adsExitDelay + 8);
      if ( *(_DWORD *)(v3 + 224) <= a1[1] )
        *(_DWORD *)(v3 + 224) = 0;
      else
        v4 = 1;
    }
    if ( v4 && *(float *)(v3 + 220) != 1.0 || !v4 && *(float *)(v3 + 220) != 0.0 )
    {
      if ( v4 )
        v2 = (long double)*(int *)(a2 + 40) * *(float *)(v6 + 1416) + *(float *)(v3 + 220);
      else
        v2 = *(float *)(v3 + 220) - (long double)*(int *)(a2 + 40) * *(float *)(v6 + 1420);
      *(float *)(v3 + 220) = v2;
      *(float *)(v3 + 220) = sub_80F0220(*(float *)(v3 + 220), 0.0, 1.0);
    }
  }
  else
  {
    *(_DWORD *)(v3 + 220) = 0;
    *(_DWORD *)(v3 + 224) = 0;
  }
}
// 85760F0: using guessed type int player_scopeExitOnDamage;
// 85760F4: using guessed type int player_adsExitDelay;

//----- (080EA838) --------------------------------------------------------
int __cdecl sub_80EA838(int a1)
{
  int result; // eax

  result = a1;
  *(_DWORD *)(a1 + 12) |= 0x4000u;
  return result;
}

//----- (080EA850) --------------------------------------------------------
int __cdecl sub_80EA850(int a1)
{
  int result; // eax

  result = a1;
  *(_DWORD *)(a1 + 12) &= ~0x4000u;
  return result;
}

//----- (080EA868) --------------------------------------------------------
void __cdecl sub_80EA868(int a1)
{
  int v1; // [esp+8h] [ebp-10h]
  int v2; // [esp+Ch] [ebp-Ch]
  int v3; // [esp+14h] [ebp-4h]

  v1 = sub_80E95EE((_DWORD *)a1);
  v2 = BG_WeaponDefs(v1);
  if ( *(float *)(a1 + 220) == 1.0 && *(_DWORD *)(v2 + 632) && *(_DWORD *)(v2 + 124) != 9 )
  {
    v3 = (int)(*(float *)(player_breath_hold_time + 8) * 1000.0);
    if ( *(_DWORD *)(a1 + 1464) < v3 )
    {
      *(_DWORD *)(a1 + 1464) += (int)(*(float *)(player_breath_fire_delay + 8) * 1000.0);
      if ( *(_DWORD *)(a1 + 1464) > v3 )
        *(_DWORD *)(a1 + 1464) = v3;
    }
    sub_80EA850(a1);
  }
}
// 85760CC: using guessed type int player_breath_hold_time;
// 85760D4: using guessed type int player_breath_fire_delay;

//----- (080EA950) --------------------------------------------------------
void __cdecl sub_80EA950(int *a1, int a2)
{
  int v2; // eax
  int v3; // [esp+18h] [ebp-20h]
  int v4; // [esp+1Ch] [ebp-1Ch]
  int v5; // [esp+20h] [ebp-18h]
  float v6; // [esp+24h] [ebp-14h]
  float v7; // [esp+24h] [ebp-14h]
  float v8; // [esp+28h] [ebp-10h]
  float v9; // [esp+28h] [ebp-10h]
  int v10; // [esp+2Ch] [ebp-Ch]
  int v11; // [esp+30h] [ebp-8h]

  v3 = *a1;
  v10 = sub_80E95EE((_DWORD *)*a1);
  v11 = BG_WeaponDefs(v10);
  v5 = (int)(*(float *)(player_breath_hold_time + 8) * 1000.0);
  v4 = (int)(*(float *)(player_breath_gasp_time + 8) * 1000.0);
  if ( v5 > 0 )
  {
    if ( *(float *)(v3 + 220) == 1.0
      && *(_DWORD *)(v11 + 632)
      && *(_DWORD *)(v11 + 124) != 9
      && *((__int16 *)a1 + 4) < 0 )
    {
      if ( !*(_DWORD *)(v3 + 1464) )
        sub_80EA838(v3);
    }
    else
    {
      sub_80EA850(v3);
    }
    if ( (*(_DWORD *)(v3 + 12) & 0x4000) != 0 )
      v2 = *(_DWORD *)(v3 + 1464) + *(_DWORD *)(a2 + 40);
    else
      v2 = *(_DWORD *)(v3 + 1464) - *(_DWORD *)(a2 + 40);
    *(_DWORD *)(v3 + 1464) = v2;
    if ( *(int *)(v3 + 1464) < 0 )
      *(_DWORD *)(v3 + 1464) = 0;
    if ( (*(_DWORD *)(v3 + 12) & 0x4000) != 0 && *(_DWORD *)(v3 + 1464) > v5 )
    {
      *(_DWORD *)(v3 + 1464) = v5 + v4;
      sub_80EA850(v3);
    }
    if ( (*(_DWORD *)(v3 + 12) & 0x4000) != 0 )
    {
      v8 = 0.0;
      v6 = *(float *)(player_breath_hold_lerp + 8);
    }
    else
    {
      v7 = (long double)*(int *)(v3 + 1464) / (long double)(v5 + v4);
      v8 = (*(float *)(player_breath_gasp_scale + 8) - 1.0) * v7 + 1.0;
      v6 = *(float *)(player_breath_gasp_lerp + 8);
    }
    v9 = (v8 - 1.0) * *(float *)(v3 + 220) + 1.0;
    *(float *)(v3 + 1460) = sub_80A1986(v9, *(float *)(v3 + 1460), v6, *(float *)(a2 + 36));
  }
  else
  {
    sub_80EA850(v3);
    *(_DWORD *)(v3 + 1460) = 1065353216;
    *(_DWORD *)(v3 + 1464) = 0;
  }
}
// 85760CC: using guessed type int player_breath_hold_time;
// 85760D0: using guessed type int player_breath_gasp_time;
// 85760D8: using guessed type int player_breath_gasp_scale;
// 85760DC: using guessed type int player_breath_hold_lerp;
// 85760E0: using guessed type int player_breath_gasp_lerp;

//----- (080EABAA) --------------------------------------------------------
int __cdecl sub_80EABAA(_DWORD *a1)
{
  if ( a1[54] < 3u || a1[54] == 5 || a1[54] == 7 || a1[54] == 9 || a1[54] == 8 || a1[54] == 6 || a1[54] == 4 )
    return 1;
  if ( a1[54] == 3 || a1[54] == 11 || (int)a1[54] > 11 && (int)a1[54] <= 16 )
    return 0;
  sub_80ED212(a1);
  return 1;
}

//----- (080EAC7A) --------------------------------------------------------
int __cdecl sub_80EAC7A(int a1)
{
  return *(_DWORD *)(BG_WeaponDefs(a1) + 464);
}

//----- (080EAC94) --------------------------------------------------------
int __cdecl sub_80EAC94(int a1)
{
  return *(_DWORD *)(BG_WeaponDefs(a1) + 456);
}

//----- (080EACAE) --------------------------------------------------------
int __cdecl sub_80EACAE(int a1)
{
  return *(_DWORD *)(BG_WeaponDefs(a1) + 832);
}

//----- (080EACC8) --------------------------------------------------------
int __cdecl sub_80EACC8(int a1, int a2)
{
  int v3; // [esp+Ch] [ebp-Ch]

  v3 = sub_80EAC94(a2);
  return *(_DWORD *)(a1 + 4 * v3 + 324) + *(_DWORD *)(a1 + 4 * sub_80EAC7A(a2) + 836);
}

//----- (080EAD0C) --------------------------------------------------------
int __cdecl sub_80EAD0C(int a1)
{
  int result; // eax
  int v2; // [esp+8h] [ebp-20h]
  int v3; // [esp+Ch] [ebp-1Ch]
  int v4; // [esp+10h] [ebp-18h]
  int v5; // [esp+14h] [ebp-14h]
  int v6; // [esp+18h] [ebp-10h]
  int v7; // [esp+1Ch] [ebp-Ch]

  v7 = BG_WeaponDefs(*(_DWORD *)(a1 + 212));
  if ( *(_DWORD *)(a1 + 216) != 7 && *(_DWORD *)(a1 + 216) != 8 || (result = v7, *(_DWORD *)(v7 + 868)) )
  {
    v6 = sub_80EAC94(*(_DWORD *)(a1 + 212));
    v5 = sub_80EAC7A(*(_DWORD *)(a1 + 212));
    v4 = *(_DWORD *)(a1 + 4 * v6 + 324);
    v3 = *(_DWORD *)(a1 + 4 * v5 + 836);
    v2 = sub_80E9356(v5) - v3;
    if ( v2 > v4 )
      v2 = v4;
    if ( *(_DWORD *)(a1 + 216) == 7 || *(_DWORD *)(a1 + 216) == 8 )
    {
      result = sub_80E9356(v5);
      if ( *(_DWORD *)(v7 + 868) < result )
      {
        result = v2;
        if ( v2 > *(_DWORD *)(v7 + 868) )
        {
          result = *(_DWORD *)(v7 + 868);
          v2 = result;
        }
      }
    }
    else
    {
      result = v7;
      if ( *(_DWORD *)(v7 + 864) )
      {
        result = sub_80E9356(v5);
        if ( *(_DWORD *)(v7 + 864) < result )
        {
          result = v2;
          if ( v2 > *(_DWORD *)(v7 + 864) )
          {
            result = *(_DWORD *)(v7 + 864);
            v2 = result;
          }
        }
      }
    }
    if ( v2 )
    {
      *(_DWORD *)(a1 + 4 * v6 + 324) -= v2;
      result = *(_DWORD *)(a1 + 4 * v5 + 836) + v2;
      *(_DWORD *)(a1 + 4 * v5 + 836) = result;
    }
  }
  return result;
}

//----- (080EAE8C) --------------------------------------------------------
int __cdecl sub_80EAE8C(int a1, int a2, int a3)
{
  int v3; // ebx
  int result; // eax

  v3 = sub_80EAC7A(a2);
  result = *(_DWORD *)(a1 + 4 * v3 + 836) - a3;
  *(_DWORD *)(a1 + 4 * v3 + 836) = result;
  return result;
}

//----- (080EAEC8) --------------------------------------------------------
int __cdecl sub_80EAEC8(int a1)
{
  return *(_DWORD *)(a1 + 4 * sub_80EAC7A(*(_DWORD *)(a1 + 212)) + 836);
}

//----- (080EAEF2) --------------------------------------------------------
_BOOL4 __cdecl sub_80EAEF2(int a1)
{
  return *(_DWORD *)(a1 + 4 * sub_80EAC7A(*(_DWORD *)(a1 + 212)) + 836) == 0;
}

//----- (080EAF30) --------------------------------------------------------
int __cdecl sub_80EAF30(int a1)
{
  int result; // eax

  sub_80E9240(a1, 0);
  result = a1;
  *(_DWORD *)(a1 + 216) = 0;
  return result;
}

//----- (080EAF58) --------------------------------------------------------
int __cdecl sub_80EAF58(int a1, int a2)
{
  _DWORD *v4; // [esp+14h] [ebp-4h]

  v4 = (_DWORD *)BG_WeaponDefs(*(_DWORD *)(a1 + 212));
  if ( *(int *)(a1 + 216) > 16 && *(int *)(a1 + 216) <= 22 )
    return 0;
  if ( *(int *)(a1 + 216) <= 11 || *(int *)(a1 + 216) > 16 )
  {
    if ( v4[202] && (unsigned __int8)sub_80D9E84(a1 + 1372, *(_DWORD *)(a1 + 212)) )
    {
      if ( *(_DWORD *)(a1 + 216) == 4 )
      {
        if ( a2 )
        {
          sub_80F0400(a1 + 1372, *(_DWORD *)(a1 + 212));
          sub_80DED2E(a1, 162);
          if ( *(_DWORD *)(a1 + 52) )
            return 1;
        }
      }
      if ( !*(_DWORD *)(a1 + 52)
        || *(_DWORD *)(a1 + 216) != 3
        && *(_DWORD *)(a1 + 216) != 4
        && *(_DWORD *)(a1 + 216) != 10
        && *(_DWORD *)(a1 + 216) != 11
        && !*(_DWORD *)(a1 + 56) )
      {
        if ( *(_DWORD *)(a1 + 216) == 4 )
        {
          sub_80EAF30(a1);
        }
        else if ( !*(_DWORD *)(a1 + 216) )
        {
          if ( *(float *)(a1 + 220) <= 0.75 )
            sub_80E9210(a1, 4);
          else
            sub_80E9210(a1, 7);
          *(_DWORD *)(a1 + 216) = 4;
          *(_DWORD *)(a1 + 52) = v4[130];
          if ( v4[131] && v4[131] < v4[130] )
            *(_DWORD *)(a1 + 56) = v4[131];
          else
            *(_DWORD *)(a1 + 56) = 1;
          sub_80DED2E(a1, 161);
        }
      }
    }
    return 0;
  }
  return 0;
}

//----- (080EB180) --------------------------------------------------------
int __cdecl sub_80EB180(_DWORD *a1)
{
  int result; // eax
  int v2; // [esp+10h] [ebp-8h]
  _DWORD *v3; // [esp+14h] [ebp-4h]

  v3 = (_DWORD *)BG_WeaponDefs(a1[53]);
  if ( a1[54] == 7 || a1[54] == 8 )
  {
    if ( v3[138] )
    {
      if ( v3[138] >= v3[137] )
        v2 = v3[137];
      else
        v2 = v3[138];
    }
    else
    {
      v2 = 0;
    }
  }
  else
  {
    if ( a1[sub_80EAC7A(a1[53]) + 209] || v3[30] )
      v2 = v3[134];
    else
      v2 = v3[135];
    if ( v3[136] && v3[136] < v2 )
      v2 = v3[136];
  }
  result = (int)v3;
  if ( v3[202] && (result = sub_80D9E84((int)(a1 + 343), a1[53]), (_BYTE)result) )
  {
    if ( !v2 )
      v2 = a1[13];
    if ( v3[131] < v2 )
      v2 = v3[131];
    if ( !v2 )
      v2 = 1;
    result = v2;
    a1[14] = v2;
  }
  else if ( v2 )
  {
    result = v2;
    a1[14] = v2;
  }
  return result;
}

//----- (080EB2E8) --------------------------------------------------------
int __cdecl sub_80EB2E8(_DWORD *a1)
{
  _DWORD *v2; // [esp+14h] [ebp-4h]

  v2 = (_DWORD *)BG_WeaponDefs(a1[53]);
  if ( a1[sub_80EAC7A(a1[53]) + 209] || v2[30] )
  {
    sub_80E9210((int)a1, 11);
    a1[13] = v2[134];
    sub_80DED2E((int)a1, 150);
  }
  else
  {
    sub_80E9210((int)a1, 12);
    a1[13] = v2[135];
    sub_80DED2E((int)a1, 151);
  }
  if ( a1[54] == 8 )
    a1[54] = 6;
  else
    a1[54] = 5;
  return sub_80EB180(a1);
}

//----- (080EB3D0) --------------------------------------------------------
int __cdecl sub_80EB3D0(_DWORD *a1)
{
  int result; // eax
  int v2; // [esp+10h] [ebp-8h]

  v2 = BG_WeaponDefs(a1[53]);
  if ( !a1[54] || a1[54] == 3 || (result = (int)a1, a1[54] == 4) )
  {
    result = (int)a1;
    if ( a1[53] )
    {
      result = BG_GetNumWeapons();
      if ( a1[53] <= result )
      {
        if ( !sub_80EACAE(a1[53]) )
          BG_AnimScriptEvent(a1, 10, 0, 1);
        sub_80DED2E((int)a1, 149);
        if ( *(_DWORD *)(v2 + 860) && *(_DWORD *)(v2 + 548) )
        {
          sub_80E9210((int)a1, 13);
          a1[13] = *(_DWORD *)(v2 + 548);
          a1[54] = 7;
          sub_80DED2E((int)a1, 152);
          return sub_80EB180(a1);
        }
        else
        {
          return sub_80EB2E8(a1);
        }
      }
    }
  }
  return result;
}

//----- (080EB4FC) --------------------------------------------------------
int __cdecl sub_80EB4FC(_DWORD *a1, int a2)
{
  int result; // eax
  int v3; // edx
  int v4; // [esp+1Ch] [ebp-1Ch]
  int v5; // [esp+24h] [ebp-14h]
  _DWORD *v6; // [esp+28h] [ebp-10h]
  int v7; // [esp+2Ch] [ebp-Ch]

  if ( !a2 || (result = sub_80D9E84((int)(a1 + 337), a2), (_BYTE)result) )
  {
    result = (int)a1;
    if ( a1[54] != 2 )
    {
      a1[14] = 0;
      v5 = a1[53];
      if ( v5 && (unsigned __int8)sub_80D9E84((int)(a1 + 337), v5) && (int)a1[15] <= 0 )
      {
        v6 = (_DWORD *)BG_WeaponDefs(v5);
        v4 = 0;
        if ( a2 && a2 == v6[219] )
          v4 = 1;
        v7 = 1;
        if ( sub_80EACAE(v5) && !a1[sub_80EAC7A(v5) + 209] )
          v7 = 0;
        a1[15] = 0;
        if ( v4 )
        {
          sub_80DED2E((int)a1, 156);
          sub_80E9210((int)a1, 15);
        }
        else if ( v7 )
        {
          sub_80DED2E((int)a1, 155);
          sub_80E9210((int)a1, 9);
        }
        if ( !v4 && (a1[3] & 4) == 0 )
          BG_AnimScriptEvent(a1, 6, 0, 0);
        a1[54] = 2;
        sub_80E5820((int)a1);
        result = (int)a1;
        if ( v4 )
          v3 = v6[142];
        else
          v3 = v6[140];
        a1[13] = v3;
        if ( v4 )
        {
          result = sub_80E9B54((int)a1, v5, 1);
          if ( result )
            return sub_80E9A9E((int)a1, result, a2);
        }
      }
      else
      {
        a1[13] = 0;
        a1[54] = 2;
        a1[15] = 0;
        return sub_80E5820((int)a1);
      }
    }
  }
  return result;
}

//----- (080EB738) --------------------------------------------------------
int __cdecl sub_80EB738(unsigned __int8 *a1)
{
  char v1; // al
  int v3; // [esp+18h] [ebp-20h]
  int v4; // [esp+1Ch] [ebp-1Ch]
  float *v5; // [esp+20h] [ebp-18h]
  int v6; // [esp+24h] [ebp-14h]
  int v7; // [esp+28h] [ebp-10h]

  v5 = *(float **)a1;
  BG_WeaponDefs(*(_DWORD *)(*(_DWORD *)a1 + 212));
  if ( sub_80DBEB0((int)v5)
    || ((_DWORD)v5[3] & 0x20) != 0
    || !(unsigned __int8)sub_80D9E84((int)(v5 + 337), a1[12])
    || ((_DWORD)v5[3] & 0x4000000) != 0
    || !(unsigned __int8)sub_80D9E84((int)(v5 + 337), a1[12]) )
  {
    v6 = 0;
    v1 = sub_80D9E84((int)(v5 + 337), 0);
  }
  else
  {
    v6 = a1[12];
    if ( v6 > BG_GetNumWeapons() )
      v6 = 0;
    v1 = sub_80D9E84((int)(v5 + 337), v6);
  }
  if ( !v1 )
    v6 = 0;
  v7 = *((_DWORD *)v5 + 53);
  *((_DWORD *)v5 + 53) = (unsigned __int8)v6;
  BG_WeaponDefs(*((_DWORD *)v5 + 53));
  if ( v7 == v6 )
  {
    v5[54] = 0.0;
    return sub_80E9210((int)v5, 0);
  }
  else if ( v7 )
  {
    *((_DWORD *)v5 + 54) = 1;
    sub_80E5820((int)v5);
    v3 = 0;
    if ( v6 && v6 == *(_DWORD *)(BG_WeaponDefs(v7) + 876) )
      v3 = 1;
    if ( v3 )
    {
      v5[13] = *(float *)(BG_WeaponDefs(v6) + 572);
    }
    else
    {
      sub_80DED2E((int)v5, 154);
      v5[13] = *(float *)(BG_WeaponDefs(v6) + 564);
    }
    v4 = BG_WeaponDefs(v6);
    sub_80D70E2(*((_DWORD *)v5 + 51), 0, *(_DWORD *)(v4 + 116), 1);
    sub_80D70E2(*((_DWORD *)v5 + 51), 1, *(_DWORD *)(v4 + 124), 1);
    if ( v6 && v6 == *(_DWORD *)(BG_WeaponDefs(v7) + 876) )
    {
      if ( v5[373] < 128.0 )
        v5[373] = 128.0;
      return sub_80E9210((int)v5, 16);
    }
    else
    {
      BG_AnimScriptEvent(v5, 7, 0, 0);
      v5[373] = 255.0;
      return sub_80E9210((int)v5, 10);
    }
  }
  else
  {
    *((_DWORD *)v5 + 54) = 1;
    v5[13] = *(float *)(BG_WeaponDefs(v6) + 564);
    v5[373] = 255.0;
    sub_80E9210((int)v5, 10);
    return sub_80E5820((int)v5);
  }
}

//----- (080EBA76) --------------------------------------------------------
int __cdecl sub_80EBA76(int a1)
{
  *(_DWORD *)(a1 + 216) = 0;
  return sub_80E9210(a1, 0);
}

//----- (080EBA9E) --------------------------------------------------------
int __cdecl sub_80EBA9E(int a1)
{
  int v3; // [esp+18h] [ebp-10h]
  int v4; // [esp+1Ch] [ebp-Ch]

  v4 = BG_WeaponDefs(*(_DWORD *)(a1 + 212));
  v3 = sub_80EAC7A(*(_DWORD *)(a1 + 212));
  if ( !*(_DWORD *)(a1 + 4 * sub_80EAC94(*(_DWORD *)(a1 + 212)) + 324)
    || *(_DWORD *)(a1 + 4 * v3 + 836) >= sub_80E9356(v3) )
  {
    return 0;
  }
  if ( !*(_DWORD *)(v4 + 856) )
    return 1;
  if ( *(_DWORD *)(v4 + 864) && *(_DWORD *)(v4 + 864) < sub_80E9356(v3) )
    return sub_80E9356(v3) - *(_DWORD *)(a1 + 4 * v3 + 836) >= *(_DWORD *)(v4 + 864);
  return !*(_DWORD *)(a1 + 4 * v3 + 836);
}

//----- (080EBBA8) --------------------------------------------------------
int __cdecl sub_80EBBA8(_DWORD *a1)
{
  int result; // eax
  int v2; // [esp+Ch] [ebp-Ch]
  int v3; // [esp+10h] [ebp-8h]
  int v4; // [esp+10h] [ebp-8h]
  _DWORD *v5; // [esp+14h] [ebp-4h]

  v5 = (_DWORD *)BG_WeaponDefs(a1[53]);
  if ( !v5[202] || !(unsigned __int8)sub_80D9E84((int)(a1 + 343), a1[53]) )
    return sub_80EAD0C((int)a1);
  sub_80F0400((int)(a1 + 343), a1[53]);
  sub_80DED2E((int)a1, 162);
  if ( a1[54] != 7 && a1[54] != 8 || (result = (int)v5, v5[138]) )
  {
    if ( a1[13] )
    {
      if ( a1[54] == 7 || a1[54] == 8 )
      {
        v3 = v5[138] >= v5[137] ? v5[137] : v5[138];
      }
      else
      {
        v3 = a1[sub_80EAC7A(a1[53]) + 209] || v5[30] ? v5[134] : v5[135];
        if ( v5[136] && v5[136] < v3 )
          v3 = v5[136];
      }
      v2 = v5[131] >= v3 ? 1 : v5[131];
      v4 = v3 - v2;
      if ( v4 > 0 )
      {
        result = v4;
        a1[14] = v4;
        return result;
      }
    }
    return sub_80EAD0C((int)a1);
  }
  return result;
}

//----- (080EBD80) --------------------------------------------------------
int __cdecl sub_80EBD80(_DWORD *a1, int a2)
{
  int result; // eax
  int v3; // [esp+10h] [ebp-8h]

  v3 = BG_WeaponDefs(a1[53]);
  if ( a2 )
    sub_80EBBA8(a1);
  result = (int)a1;
  if ( !a1[13] )
  {
    if ( a1[54] == 8 && a1[sub_80EAC7A(a1[53]) + 209] || !sub_80EBA9E((int)a1) )
    {
      sub_80F0400((int)(a1 + 343), a1[53]);
      if ( *(_DWORD *)(v3 + 556) )
      {
        a1[54] = 9;
        sub_80E9210((int)a1, 14);
        a1[13] = *(_DWORD *)(v3 + 556);
        return sub_80DED2E((int)a1, 153);
      }
      else
      {
        a1[54] = 0;
        return sub_80E9210((int)a1, 0);
      }
    }
    else
    {
      return sub_80EB2E8(a1);
    }
  }
  return result;
}

//----- (080EBE96) --------------------------------------------------------
int __cdecl sub_80EBE96(_DWORD *a1, int a2)
{
  int result; // eax
  int v3; // [esp+14h] [ebp-4h]

  v3 = BG_WeaponDefs(a1[53]);
  if ( !a2 || (sub_80EBBA8(a1), result = (int)a1, !a1[13]) )
  {
    result = (int)a1;
    if ( !a1[13] )
    {
      sub_80F0400((int)(a1 + 343), a1[53]);
      if ( !*(_DWORD *)(v3 + 860) )
        goto LABEL_10;
      if ( a1[54] != 6 && sub_80EBA9E((int)a1) )
        return sub_80EB2E8(a1);
      if ( *(_DWORD *)(v3 + 556) )
      {
        a1[54] = 9;
        sub_80E9210((int)a1, 14);
        a1[13] = *(_DWORD *)(v3 + 556);
        return sub_80DED2E((int)a1, 153);
      }
      else
      {
LABEL_10:
        a1[54] = 0;
        return sub_80E9210((int)a1, 0);
      }
    }
  }
  return result;
}

//----- (080EBFC8) --------------------------------------------------------
int __cdecl sub_80EBFC8(int a1)
{
  *(_DWORD *)(a1 + 216) = 0;
  return sub_80E9210(a1, 0);
}

//----- (080EBFF0) --------------------------------------------------------
char __cdecl sub_80EBFF0(int a1)
{
  int v1; // eax
  _DWORD *v3; // [esp+20h] [ebp-18h]
  int v4; // [esp+24h] [ebp-14h]
  int v5; // [esp+28h] [ebp-10h]
  int v6; // [esp+2Ch] [ebp-Ch]
  _BOOL4 v7; // [esp+30h] [ebp-8h]
  int v8; // [esp+34h] [ebp-4h]

  v6 = 0;
  v3 = *(_DWORD **)a1;
  v8 = BG_WeaponDefs(*(_DWORD *)(*(_DWORD *)a1 + 212));
  if ( (int)v3[54] <= 16 || (LOBYTE(v1) = (_BYTE)v3, (int)v3[54] > 22) )
  {
    if ( (int)v3[54] <= 11 || (LOBYTE(v1) = (_BYTE)v3, (int)v3[54] > 16) )
    {
      v7 = (*(_DWORD *)(a1 + 8) & 0x10) != 0;
      if ( (v3[3] & 8) != 0 )
      {
        v3[3] &= ~8u;
        v7 = 1;
      }
      if ( *(_DWORD *)(v8 + 860)
        && (v3[54] == 7 || v3[54] == 5)
        && (*(_BYTE *)(a1 + 8) & 1) != 0
        && ((*(_BYTE *)(a1 + 36) ^ 1) & 1) != 0 )
      {
        if ( v3[54] == 7 )
        {
          v3[54] = 8;
        }
        else if ( v3[54] == 5 )
        {
          v3[54] = 6;
        }
      }
      v1 = v3[54];
      switch ( v1 )
      {
        case 1:
        case 2:
        case 10:
        case 11:
          return v1;
        case 5:
        case 6:
        case 7:
        case 8:
        case 9:
          LOBYTE(v1) = a1;
          if ( *(_DWORD *)(a1 + 224) )
          {
            v1 = sub_80EACAE(v3[53]);
            if ( !v1 )
              LOBYTE(v1) = BG_AnimScriptEvent(v3, 10, 0, 1);
          }
          break;
        default:
          v5 = sub_80EAC7A(v3[53]);
          v4 = sub_80EAC94(v3[53]);
          if ( v7 && sub_80EBA9E((int)v3) )
            v6 = 1;
          LOBYTE(v1) = v5;
          if ( !v3[v5 + 209] )
          {
            LOBYTE(v1) = v4;
            if ( v3[v4 + 81] )
            {
              LOBYTE(v1) = (_BYTE)v3;
              if ( v3[54] != 3 )
              {
                LOBYTE(v1) = (*((_BYTE *)v3 + 12) ^ 1) & 1;
                if ( (_BYTE)v1 || (LOBYTE(v1) = a1, !*(_BYTE *)(a1 + 28)) && (LOBYTE(v1) = a1, !*(_BYTE *)(a1 + 29)) )
                  v6 = 1;
              }
            }
          }
          if ( v6 )
            LOBYTE(v1) = sub_80EB3D0(v3);
          break;
      }
    }
  }
  return v1;
}

//----- (080EC22A) --------------------------------------------------------
int __cdecl sub_80EC22A(int a1)
{
  int result; // eax

  result = sub_80EACAE(*(_DWORD *)(a1 + 212));
  if ( result )
  {
    result = sub_80EAC7A(*(_DWORD *)(a1 + 212));
    if ( !*(_DWORD *)(a1 + 4 * result + 836) )
    {
      result = sub_80EAC94(*(_DWORD *)(a1 + 212));
      if ( !*(_DWORD *)(a1 + 4 * result + 324) )
      {
        sub_80E98CA(a1, *(_DWORD *)(a1 + 212));
        return sub_80DED2E(a1, 146);
      }
    }
  }
  return result;
}

//----- (080EC2BA) --------------------------------------------------------
void __cdecl sub_80EC2BA(_BYTE *a1, int a2)
{
  float v2; // [esp+0h] [ebp-38h]
  float v3; // [esp+0h] [ebp-38h]
  float v4; // [esp+4h] [ebp-34h]
  float v5; // [esp+10h] [ebp-28h]
  int v6; // [esp+1Ch] [ebp-1Ch]
  float v7; // [esp+20h] [ebp-18h]
  float v8; // [esp+24h] [ebp-14h]
  float v9; // [esp+28h] [ebp-10h]
  float v10; // [esp+2Ch] [ebp-Ch]
  int i; // [esp+30h] [ebp-8h]
  int j; // [esp+30h] [ebp-8h]
  float *v13; // [esp+34h] [ebp-4h]

  v6 = *(_DWORD *)a1;
  v13 = (float *)BG_WeaponDefs(*(_DWORD *)(*(_DWORD *)a1 + 212));
  v7 = v13[169];
  if ( v7 == 0.0 )
  {
    v10 = 0.0;
    v9 = 1.0;
  }
  else
  {
    if ( *(_DWORD *)(v6 + 96) != 1023 || *(_DWORD *)(v6 + 4) == 1 )
    {
      if ( (*(_DWORD *)(v6 + 160) & 8) != 0 )
      {
        v7 = v7 * v13[174];
      }
      else if ( (*(_DWORD *)(v6 + 160) & 4) != 0 )
      {
        v7 = v7 * v13[173];
      }
    }
    else
    {
      v7 = v7 * 0.5;
    }
    v9 = v7 * *(float *)(a2 + 36);
    if ( *(float *)(v6 + 220) == 1.0 )
    {
      v10 = 0.0;
    }
    else
    {
      v8 = 0.0;
      if ( v13[171] != 0.0 )
      {
        for ( i = 0; i <= 1; ++i )
        {
          v4 = (long double)*(int *)&a1[4 * i + 44] * 0.0054931641;
          v2 = (long double)*(int *)&a1[4 * i + 16] * 0.0054931641;
          v3 = sub_80A6000(v2, v4);
          v8 = sub_80F0198(v3) * 0.0099999998 * v13[171] / *(float *)(a2 + 36) + v8;
        }
      }
      if ( v13[172] != 0.0 && (a1[28] || a1[29]) )
      {
        v5 = sub_80F026A((float *)(v6 + 32));
        if ( v5 > sub_80F025E(*(float *)(bg_aimSpreadMoveSpeedThreshold + 8)) )
          v8 = v8 + v13[172];
      }
      if ( *(_DWORD *)(v6 + 96) == 1023 && *(_DWORD *)(v6 + 4) != 1 )
      {
        for ( j = 0; j <= 1; ++j )
          v8 = v8 + 1.28;
      }
      v10 = v8 * *(float *)(a2 + 36);
    }
  }
  *(float *)(v6 + 1492) = (v10 - v9) * 255.0 + *(float *)(v6 + 1492);
  if ( *(float *)(v6 + 1492) >= 0.0 )
  {
    if ( *(float *)(v6 + 1492) > 255.0 )
      *(_DWORD *)(v6 + 1492) = 1132396544;
  }
  else
  {
    *(_DWORD *)(v6 + 1492) = 0;
  }
}
// 85760C8: using guessed type int bg_aimSpreadMoveSpeedThreshold;

//----- (080EC560) --------------------------------------------------------
int __cdecl sub_80EC560(_BYTE *a1, int a2)
{
  _DWORD *v4; // [esp+Ch] [ebp-Ch]
  _DWORD *v5; // [esp+10h] [ebp-8h]

  v4 = *(_DWORD **)a1;
  v5 = (_DWORD *)BG_WeaponDefs(*(_DWORD *)(*(_DWORD *)a1 + 212));
  if ( (int)v4[16] > 0 )
  {
    v4[16] -= *(_DWORD *)(a2 + 40);
    v4[16] = sub_80F01FA(v4[16], 0);
  }
  if ( v4[13] )
  {
    v4[13] -= *(_DWORD *)(a2 + 40);
    if ( (int)v4[13] <= 0 )
    {
      if ( ((int)v4[54] <= 11 || (int)v4[54] > 16)
        && v5[201]
        && (a1[8] & 1) != 0
        && v4[53] == (unsigned __int8)a1[12]
        && sub_80EAEC8((int)v4) )
      {
        v4[13] = 1;
        if ( v4[54] == 5 || v4[54] == 7 || v4[54] == 9 || v4[54] == 8 || v4[54] == 6 )
          v4[13] = 0;
        if ( (v4[54] == 5 || v4[54] == 7 || v4[54] == 9 || v4[54] == 8 || v4[54] == 6)
          && v4[54] != 9
          && v5[215]
          && v5[137] )
        {
          v4[13] = 0;
        }
        else if ( v4[54] == 4 )
        {
          sub_80EAF30((int)v4);
        }
        else if ( v4[54] == 3 || v4[54] == 4 || v4[54] == 10 || v4[54] == 11 )
        {
          sub_80E9240((int)v4, 0);
          v4[54] = 0;
        }
      }
      else
      {
        v4[13] = 0;
      }
    }
  }
  if ( !v4[14] )
    return 0;
  v4[14] -= *(_DWORD *)(a2 + 40);
  if ( (int)v4[14] > 0 )
    return 0;
  v4[14] = 0;
  return 1;
}

//----- (080EC7D2) --------------------------------------------------------
int __cdecl sub_80EC7D2(unsigned __int8 *a1)
{
  int result; // eax
  __int16 *v2; // [esp+14h] [ebp-4h]

  v2 = *(__int16 **)a1;
  if ( *(int *)(*(_DWORD *)a1 + 216) <= 16 || (result = *(_DWORD *)a1, *((int *)v2 + 54) > 22) )
  {
    if ( *((int *)v2 + 54) <= 11 || (result = *(_DWORD *)a1, *((int *)v2 + 54) > 16) )
    {
      if ( !*((_DWORD *)v2 + 13)
        || *((_DWORD *)v2 + 54) == 5
        || *((_DWORD *)v2 + 54) == 7
        || *((_DWORD *)v2 + 54) == 9
        || *((_DWORD *)v2 + 54) == 8
        || *((_DWORD *)v2 + 54) == 6
        || *((_DWORD *)v2 + 54) == 4
        || (result = *(_DWORD *)a1, *((_DWORD *)v2 + 54) != 3)
        && (result = *(_DWORD *)a1, *((_DWORD *)v2 + 54) != 4)
        && (result = *(_DWORD *)a1, *((_DWORD *)v2 + 54) != 10)
        && (result = *(_DWORD *)a1, *((_DWORD *)v2 + 54) != 11)
        && (result = *(_DWORD *)a1, !*((_DWORD *)v2 + 14)) )
      {
        if ( sub_80DBEB0((int)v2) )
        {
          result = (int)v2;
          if ( !*((_DWORD *)v2 + 53) )
            return result;
          return sub_80EB4FC(v2, 0);
        }
        if ( (*((_DWORD *)v2 + 3) & 0x20) != 0 )
        {
          result = (int)v2;
          if ( !*((_DWORD *)v2 + 53) )
            return result;
          return sub_80EB4FC(v2, 0);
        }
        if ( (*((_DWORD *)v2 + 3) & 0x4000000) != 0 )
        {
          result = (int)v2;
          if ( !*((_DWORD *)v2 + 53) )
            return result;
          return sub_80EB4FC(v2, 0);
        }
        if ( *((_DWORD *)v2 + 53) != a1[12]
          && (v2[6] >= 0 || !*((_DWORD *)v2 + 53))
          && (!a1[12] || BG_IsWeaponValid((int)v2, a1[12])) )
        {
          return sub_80EB4FC(v2, a1[12]);
        }
        result = (int)v2;
        if ( *((_DWORD *)v2 + 53) )
        {
          result = sub_80D9E84((int)(v2 + 674), *((_DWORD *)v2 + 53));
          if ( !(_BYTE)result )
            return sub_80EB4FC(v2, 0);
        }
      }
    }
  }
  return result;
}

//----- (080ECA14) --------------------------------------------------------
int __cdecl sub_80ECA14(_BYTE *a1, int a2)
{
  int v4; // [esp+14h] [ebp-4h]

  if ( ((a1[8] ^ 1) & 1) == 0 || a2 )
    return 0;
  v4 = *(_DWORD *)a1;
  if ( *(_DWORD *)(*(_DWORD *)a1 + 216) == 3 )
    sub_80E9240(v4, 0);
  *(_DWORD *)(v4 + 216) = 0;
  return 1;
}

//----- (080ECA78) --------------------------------------------------------
int __cdecl sub_80ECA78(int a1, int a2)
{
  int v3; // [esp+20h] [ebp-8h]

  v3 = BG_WeaponDefs(*(_DWORD *)(a1 + 212));
  if ( *(_DWORD *)(v3 + 120) == 1 )
  {
    if ( !a2 )
    {
      if ( sub_80EAEC8(a1) )
      {
        *(_DWORD *)(a1 + 60) = *(_DWORD *)(v3 + 584);
        sub_80E9210(a1, 19);
        sub_80DED2E(a1, 157);
      }
      *(_DWORD *)(a1 + 56) = *(_DWORD *)(v3 + 528);
      *(_DWORD *)(a1 + 52) = 0;
    }
  }
  else
  {
    *(_DWORD *)(a1 + 56) = *(_DWORD *)(v3 + 508);
    *(_DWORD *)(a1 + 52) = *(_DWORD *)(v3 + 516);
    if ( *(_DWORD *)(v3 + 840) )
      *(_DWORD *)(a1 + 56) = (int)((1.0 - *(float *)(a1 + 220)) * (1.0 / *(float *)(v3 + 1416)));
    BG_AnimScriptEvent((_DWORD *)a1, 2, 0, 1);
    if ( *(_DWORD *)(v3 + 808) )
      sub_80D9EAA(a1 + 1372, *(_DWORD *)(a1 + 212));
    if ( *(_DWORD *)(a1 + 216) != 3 )
    {
      if ( *(float *)(a1 + 220) < 1.0 )
        *(_DWORD *)(a1 + 64) = *(_DWORD *)(v3 + 508) + *(_DWORD *)(v3 + 1216) * *(_DWORD *)(v3 + 516);
      else
        *(_DWORD *)(a1 + 64) = *(_DWORD *)(v3 + 508) + *(_DWORD *)(v3 + 1144) * *(_DWORD *)(v3 + 516);
    }
  }
  *(_DWORD *)(a1 + 216) = 3;
  return sub_80E5820(a1);
}

//----- (080ECC42) --------------------------------------------------------
int sub_80ECC42()
{
  return 1;
}

//----- (080ECC4C) --------------------------------------------------------
int __cdecl sub_80ECC4C(_DWORD *a1)
{
  int v3; // [esp+10h] [ebp-18h]
  _BOOL4 v4; // [esp+14h] [ebp-14h]
  int v5; // [esp+1Ch] [ebp-Ch]
  int v6; // [esp+20h] [ebp-8h]

  v3 = 1;
  v6 = BG_WeaponDefs(a1[53]);
  v5 = sub_80ECC42();
  if ( v5 <= sub_80EAEC8((int)a1) )
    return 1;
  v4 = v5 <= a1[sub_80EAC94(a1[53]) + 81];
  if ( *(_DWORD *)(v6 + 120) == 1 )
    v3 = 0;
  if ( v3 && !v4 )
    sub_80DED2E((int)a1, 146);
  if ( v4 )
  {
    sub_80EB3D0(a1);
  }
  else
  {
    sub_80F0400((int)(a1 + 343), a1[53]);
    sub_80E9240((int)a1, 0);
    a1[13] += 500;
  }
  return 0;
}

//----- (080ECD62) --------------------------------------------------------
int __cdecl sub_80ECD62(int a1)
{
  if ( *(float *)(a1 + 220) <= 0.75 )
  {
    if ( sub_80EAEF2(a1) )
      return sub_80E9210(a1, 3);
    else
      return sub_80E9210(a1, 2);
  }
  else if ( sub_80EAEF2(a1) )
  {
    return sub_80E9210(a1, 6);
  }
  else
  {
    return sub_80E9210(a1, 5);
  }
}

//----- (080ECDD6) --------------------------------------------------------
void __cdecl sub_80ECDD6(int a1)
{
  int v1; // [esp+4h] [ebp-4h]

  v1 = BG_WeaponDefs(*(_DWORD *)(a1 + 212));
  if ( *(float *)(a1 + 220) != 1.0 )
  {
    *(float *)(a1 + 1492) = *(float *)(v1 + 680) * 255.0 + *(float *)(a1 + 1492);
    if ( *(float *)(a1 + 1492) > 255.0 )
      *(_DWORD *)(a1 + 1492) = 1132396544;
  }
}

//----- (080ECE56) --------------------------------------------------------
int __cdecl sub_80ECE56(_DWORD *a1, int a2)
{
  int result; // eax
  int v3; // eax
  int v4; // [esp+14h] [ebp-4h]

  v4 = BG_WeaponDefs(a1[53]);
  sub_80ECA78((int)a1, a2);
  result = sub_80ECC4C(a1);
  if ( result )
  {
    result = (int)a1;
    if ( !a1[14] )
    {
      if ( sub_80EAEC8((int)a1) != -1 && (a1[40] & 0x300) == 0 )
      {
        v3 = sub_80ECC42();
        sub_80EAE8C((int)a1, a1[53], v3);
      }
      if ( *(_DWORD *)(v4 + 120) == 1 )
        a1[13] = *(_DWORD *)(v4 + 516);
      sub_80ECD62((int)a1);
      if ( sub_80EAEF2((int)a1) )
        sub_80DED2E((int)a1, 160);
      else
        sub_80DED2E((int)a1, 158);
      sub_80EA868((int)a1);
      sub_80ECDD6((int)a1);
      return sub_80EC22A((int)a1);
    }
  }
  return result;
}

//----- (080ECF70) --------------------------------------------------------
int __cdecl sub_80ECF70(_DWORD *a1)
{
  int v2; // [esp+10h] [ebp-8h]

  v2 = BG_WeaponDefs(a1[53]);
  if ( a1[13] < *(_DWORD *)(v2 + 532) - *(_DWORD *)(v2 + 512) )
    a1[13] = *(_DWORD *)(v2 + 532) - *(_DWORD *)(v2 + 512);
  sub_80DED2E((int)a1, 164);
  a1[54] = 11;
  return sub_80E5820((int)a1);
}

//----- (080ECFF2) --------------------------------------------------------
int __cdecl sub_80ECFF2(int a1)
{
  int result; // eax

  sub_80E9240(a1, 0);
  result = a1;
  *(_DWORD *)(a1 + 216) = 0;
  return result;
}

//----- (080ED01A) --------------------------------------------------------
int __cdecl sub_80ED01A(int *a1, int a2)
{
  int result; // eax
  int v3; // [esp+1Ch] [ebp-Ch]
  int v4; // [esp+20h] [ebp-8h]
  _DWORD *v5; // [esp+24h] [ebp-4h]

  v4 = *a1;
  v5 = (_DWORD *)BG_WeaponDefs(*(_DWORD *)(*a1 + 212));
  if ( *(int *)(v4 + 216) <= 16 || (result = v4, *(int *)(v4 + 216) > 22) )
  {
    if ( *(int *)(v4 + 216) <= 11 || (result = v4, *(int *)(v4 + 216) > 16) )
    {
      result = (int)v5;
      if ( v5[125] )
      {
        if ( !a2 )
        {
          if ( !*(_DWORD *)(v4 + 56)
            || *(_DWORD *)(v4 + 216) == 5
            || *(_DWORD *)(v4 + 216) == 7
            || *(_DWORD *)(v4 + 216) == 9
            || *(_DWORD *)(v4 + 216) == 8
            || (result = v4, *(_DWORD *)(v4 + 216) == 6) )
          {
            if ( (a1[2] & 4) != 0 )
            {
              result = *(_DWORD *)(v4 + 12) & 0x2000;
              if ( !result )
              {
                *(_DWORD *)(v4 + 12) |= 0x2000u;
                if ( *(float *)(v4 + 220) <= 0.0 || (result = (int)v5, !v5[158]) )
                {
                  result = *(_DWORD *)(v4 + 216);
                  v3 = result;
                  if ( result < 1 || result > 2 && (result -= 10, (unsigned int)(v3 - 10) > 1) )
                  {
                    BG_AnimScriptEvent((_DWORD *)v4, 17, 0, 1);
                    sub_80E9210(v4, 8);
                    sub_80DED2E(v4, 163);
                    if ( v5[128] )
                    {
                      *(_DWORD *)(v4 + 52) = v5[133];
                      *(_DWORD *)(v4 + 56) = v5[128];
                      *(_DWORD *)(v4 + 216) = 10;
                      return sub_80E5820(v4);
                    }
                    else
                    {
                      return sub_80ECF70((_DWORD *)v4);
                    }
                  }
                }
              }
            }
            else
            {
              result = v4;
              *(_DWORD *)(v4 + 12) &= ~0x2000u;
            }
          }
        }
      }
    }
  }
  return result;
}

//----- (080ED212) --------------------------------------------------------
int __cdecl sub_80ED212(_DWORD *a1)
{
  a1[3] &= 0xFFFFF7EF;
  if ( (int)a1[54] > 16 && (int)a1[54] <= 22 )
    sub_80ED8A6((int)a1);
  a1[13] = 0;
  a1[14] = 0;
  a1[54] = 0;
  return sub_80E9210((int)a1, 0);
}

//----- (080ED282) --------------------------------------------------------
int __cdecl sub_80ED282(_DWORD *a1)
{
  int v2; // [esp+14h] [ebp-4h]

  v2 = BG_WeaponDefs(a1[53]);
  a1[54] = 12;
  a1[13] = *(_DWORD *)(v2 + 576);
  a1[14] = 0;
  a1[3] &= ~0x10u;
  sub_80EA53E((int)a1);
  return sub_80E9210((int)a1, 17);
}

//----- (080ED2F2) --------------------------------------------------------
int __cdecl sub_80ED2F2(_DWORD *a1)
{
  int v2; // [esp+14h] [ebp-4h]

  v2 = BG_WeaponDefs(a1[52]);
  a1[54] = 13;
  a1[13] = *(_DWORD *)(v2 + 528);
  a1[14] = 0;
  a1[3] |= 0x10u;
  BG_AddPredictableEventToPlayerstate(165, a1[52], (int)a1);
  sub_80E9210((int)a1, 19);
  return sub_80E5820((int)a1);
}

//----- (080ED382) --------------------------------------------------------
int __cdecl sub_80ED382(_DWORD *a1)
{
  int v1; // eax
  int result; // eax

  v1 = BG_WeaponDefs(a1[52]);
  a1[54] = 14;
  a1[13] = 0;
  a1[14] = 0;
  a1[3] |= 0x10u;
  result = *(_DWORD *)(v1 + 584);
  a1[15] = result;
  return result;
}

//----- (080ED3DE) --------------------------------------------------------
int __cdecl sub_80ED3DE(int *a1)
{
  int result; // eax
  _DWORD *v2; // [esp+10h] [ebp-8h]
  int v3; // [esp+14h] [ebp-4h]

  v2 = (_DWORD *)*a1;
  if ( (a1[9] & 0x30000) != 0 && (a1[2] & 0x30000) != 0 )
  {
    result = *a1;
    v2[14] = 1;
  }
  else
  {
    v3 = BG_WeaponDefs(v2[52]);
    v2[54] = 15;
    v2[13] = *(_DWORD *)(v3 + 516);
    v2[14] = 0;
    v2[3] |= 0x10u;
    BG_AddPredictableEventToPlayerstate(166, v2[52], (int)v2);
    sub_80E9210((int)v2, 2);
    sub_80EAE8C((int)v2, v2[52], 1);
    BG_AnimScriptEvent(v2, 2, 0, 1);
    result = sub_80EACC8((int)v2, v2[52]);
    if ( !result )
      return sub_80DED2E((int)v2, 148);
  }
  return result;
}

//----- (080ED50A) --------------------------------------------------------
unsigned int __cdecl sub_80ED50A(_DWORD *a1)
{
  unsigned int result; // eax

  if ( a1[53] )
  {
    a1[13] = *(_DWORD *)(BG_WeaponDefs(a1[53]) + 580);
    a1[14] = 0;
    sub_80E9210((int)a1, 18);
  }
  else
  {
    a1[13] = 0;
    a1[14] = 1;
  }
  a1[54] = 16;
  result = a1[3] & 0xFFFFF7EF;
  a1[3] = result;
  return result;
}

//----- (080ED592) --------------------------------------------------------
int __cdecl sub_80ED592(int a1)
{
  return sub_80DED2E(a1, 148);
}

//----- (080ED5AE) --------------------------------------------------------
int __cdecl sub_80ED5AE(int *a1)
{
  int result; // eax
  int v2; // eax
  const char **v3; // eax
  int v4; // [esp+1Ch] [ebp-Ch]
  _DWORD *v5; // [esp+20h] [ebp-8h]

  v5 = (_DWORD *)*a1;
  result = *(_DWORD *)(*a1 + 160) & 0x300;
  if ( !result )
  {
    result = v5[3] & 0x4000000;
    if ( !result )
    {
      if ( (int)v5[54] <= 16 || (result = *a1, (int)v5[54] > 22) )
      {
        if ( (int)v5[54] <= 11 || (int)v5[54] > 16 || (result = *a1, v5[54] == 16) )
        {
          if ( (unsigned __int8)sub_80D9E84((int)(v5 + 337), *((unsigned __int8 *)a1 + 13)) )
            v5[52] = *((unsigned __int8 *)a1 + 13);
          if ( (a1[2] & 0x10000) != 0 )
          {
            v2 = sub_80E963A((int)v5, 1);
          }
          else
          {
            result = a1[2] & 0x20000;
            if ( !result )
              return result;
            v2 = sub_80E963A((int)v5, 2);
          }
          v4 = v2;
          if ( v2 )
          {
            BG_AddPredictableEventToPlayerstate(167, v2, (int)v5);
            v5[52] = v4;
            v3 = (const char **)BG_WeaponDefs(v5[52]);
            if ( v3[30] != (const char *)1 )
              Com_Error(1, "[%s] Only grenades are currently supported for off hand use\n", *v3);
            if ( !v3[33] )
              Com_Error(1, "[%s] No offhand class set\n", *v3);
            if ( v5[53] && v5[54] != 16 )
              return sub_80ED282(v5);
            else
              return sub_80ED2F2(v5);
          }
          else
          {
            return sub_80ED592((int)v5);
          }
        }
      }
    }
  }
  return result;
}

//----- (080ED780) --------------------------------------------------------
int __cdecl sub_80ED780(_DWORD *a1, int a2)
{
  int v4; // [esp+1Ch] [ebp-Ch]
  int v5; // [esp+20h] [ebp-8h]

  if ( (a1[3] & 0x10) == 0 )
    return 0;
  v4 = a1[52];
  v5 = BG_WeaponDefs(v4);
  if ( *(_DWORD *)(v5 + 120) != 1 )
    return 0;
  if ( (int)a1[15] <= 0 )
    return 0;
  if ( *(_DWORD *)(v5 + 828) )
    a1[15] -= *(_DWORD *)(a2 + 40);
  if ( (int)a1[15] > 0 )
    return 0;
  sub_80EAE8C((int)a1, v4, 1);
  sub_80DED2E((int)a1, 197);
  return 1;
}

//----- (080ED84E) --------------------------------------------------------
int __cdecl sub_80ED84E(int a1)
{
  *(_DWORD *)(a1 + 12) |= 0x20000u;
  return sub_80DED2E(a1, 168);
}

//----- (080ED87A) --------------------------------------------------------
int __cdecl sub_80ED87A(int a1)
{
  *(_DWORD *)(a1 + 12) &= ~0x20000u;
  return sub_80DED2E(a1, 169);
}

//----- (080ED8A6) --------------------------------------------------------
int __cdecl sub_80ED8A6(int a1)
{
  *(_DWORD *)(a1 + 220) = 0;
  sub_80EA53E(a1);
  return sub_80ED87A(a1);
}

//----- (080ED8D2) --------------------------------------------------------
_DWORD *__cdecl sub_80ED8D2(_DWORD *a1)
{
  _DWORD *result; // eax
  int v2; // [esp+4h] [ebp-4h]

  v2 = BG_WeaponDefs(a1[53]);
  sub_80EA53E((int)a1);
  a1[13] = 0;
  a1[14] = *(_DWORD *)(v2 + 708) + *(_DWORD *)(player_adsExitDelay + 8);
  result = a1;
  a1[54] = 17;
  return result;
}
// 85760F4: using guessed type int player_adsExitDelay;

//----- (080ED928) --------------------------------------------------------
int __cdecl sub_80ED928(_DWORD *a1)
{
  int v2; // [esp+14h] [ebp-4h]

  v2 = BG_WeaponDefs(a1[53]);
  a1[54] = 18;
  a1[13] = *(_DWORD *)(v2 + 576);
  a1[14] = 0;
  return sub_80E9210((int)a1, 17);
}

//----- (080ED97E) --------------------------------------------------------
int __cdecl sub_80ED97E(_DWORD *a1)
{
  int v2; // [esp+10h] [ebp-8h]
  int v3; // [esp+14h] [ebp-4h]

  v2 = sub_80E95A8();
  v3 = BG_WeaponDefs(v2);
  a1[54] = 19;
  a1[13] = *(_DWORD *)(v3 + 704);
  a1[14] = 0;
  sub_80ED84E((int)a1);
  return sub_80E9210((int)a1, 0);
}

//----- (080ED9E0) --------------------------------------------------------
_DWORD *__cdecl sub_80ED9E0(_DWORD *a1)
{
  _DWORD *result; // eax

  a1[54] = 20;
  a1[13] = 0;
  result = a1;
  a1[14] = 0;
  return result;
}

//----- (080EDA06) --------------------------------------------------------
int __cdecl sub_80EDA06(_DWORD *a1)
{
  int v2; // [esp+10h] [ebp-8h]
  int v3; // [esp+14h] [ebp-4h]

  v2 = sub_80E95A8();
  v3 = BG_WeaponDefs(v2);
  a1[54] = 21;
  a1[13] = *(_DWORD *)(v3 + 708) + *(_DWORD *)(player_adsExitDelay + 8);
  a1[14] = 0;
  sub_80DED2E((int)a1, 172);
  return sub_80E9210((int)a1, 0);
}
// 85760F4: using guessed type int player_adsExitDelay;

//----- (080EDA78) --------------------------------------------------------
int __cdecl sub_80EDA78(int a1)
{
  int result; // eax
  _DWORD *v2; // [esp+10h] [ebp-8h]

  v2 = *(_DWORD **)a1;
  v2[54] = 22;
  sub_80ED87A((int)v2);
  if ( *(_BYTE *)(a1 + 12) )
  {
    v2[13] = *(_DWORD *)(BG_WeaponDefs(v2[53]) + 580);
    v2[14] = 0;
    return sub_80E9210((int)v2, 18);
  }
  else
  {
    v2[13] = 0;
    result = (int)v2;
    v2[14] = 1;
  }
  return result;
}

//----- (080EDB00) --------------------------------------------------------
int __cdecl sub_80EDB00(int a1)
{
  int result; // eax
  unsigned __int8 v2; // [esp+Ch] [ebp-1Ch]
  char v3; // [esp+Dh] [ebp-1Bh]
  unsigned __int8 v4; // [esp+Eh] [ebp-1Ah]
  char v5; // [esp+Fh] [ebp-19h]
  char v6; // [esp+10h] [ebp-18h]
  char v7; // [esp+11h] [ebp-17h]
  char v8; // [esp+12h] [ebp-16h]
  char v9; // [esp+13h] [ebp-15h]
  int v10; // [esp+14h] [ebp-14h]
  unsigned __int8 v11; // [esp+1Dh] [ebp-Bh]
  char v12; // [esp+1Eh] [ebp-Ah]

  v10 = *(_DWORD *)a1;
  if ( *(int *)(*(_DWORD *)a1 + 216) > 16 && *(int *)(v10 + 216) <= 22
    || (*(float *)(v10 + 220) <= 0.0 || (result = BG_WeaponDefs(*(_DWORD *)(v10 + 212)), !*(_DWORD *)(result + 632)))
    && (result = *(_DWORD *)(a1 + 8) & 0x30015) == 0 )
  {
    result = v10;
    if ( *(_DWORD *)(v10 + 216) != 5 )
    {
      result = v10;
      if ( *(_DWORD *)(v10 + 216) != 7 )
      {
        result = v10;
        if ( *(_DWORD *)(v10 + 216) != 9 )
        {
          result = v10;
          if ( *(_DWORD *)(v10 + 216) != 8 )
          {
            result = v10;
            if ( *(_DWORD *)(v10 + 216) != 6 )
            {
              result = v10;
              if ( *(_DWORD *)(v10 + 216) != 3 )
              {
                result = v10;
                if ( *(_DWORD *)(v10 + 216) != 4 )
                {
                  result = v10;
                  if ( *(_DWORD *)(v10 + 216) != 10 )
                  {
                    result = v10;
                    if ( *(_DWORD *)(v10 + 216) != 11 )
                    {
                      result = v10;
                      if ( *(_DWORD *)(v10 + 216) != 10 )
                      {
                        result = v10;
                        if ( *(_DWORD *)(v10 + 216) != 11 )
                        {
                          result = v10;
                          if ( *(_DWORD *)(v10 + 216) != 1 )
                          {
                            result = v10;
                            if ( *(_DWORD *)(v10 + 216) != 2 )
                            {
                              if ( *(int *)(v10 + 216) <= 11 || (result = v10, *(int *)(v10 + 216) > 16) )
                              {
                                v9 = 0;
                                if ( *(_DWORD *)(v10 + 296)
                                  || *(_BYTE *)(a1 + 40) != *(_BYTE *)(a1 + 12)
                                  || *(_BYTE *)(a1 + 41) != *(_BYTE *)(a1 + 13)
                                  || (*(_DWORD *)(a1 + 8) & 0x30015) != 0 )
                                {
                                  v9 = 1;
                                }
                                if ( *(int *)(v10 + 216) > 16 && *(int *)(v10 + 216) <= 22 && v9 )
                                {
                                  sub_80ED212((_DWORD *)v10);
                                  result = *(_DWORD *)(a1 + 8) & 1;
                                  if ( (_BYTE)result )
                                  {
                                    result = v10;
                                    *(_DWORD *)(v10 + 52) = 1;
                                  }
                                }
                                else
                                {
                                  result = *(_DWORD *)(a1 + 8) & 1;
                                  if ( !(_BYTE)result )
                                  {
                                    if ( *(_DWORD *)(v10 + 216) == 20 )
                                    {
                                      v8 = 0;
                                      if ( (*(_DWORD *)(a1 + 36) & 0x28) == 0 && (*(_DWORD *)(a1 + 8) & 0x28) != 0 )
                                        v8 = 1;
                                      v7 = 0;
                                      if ( (*(_DWORD *)(a1 + 36) & 0x28) != 0 && (*(_DWORD *)(a1 + 8) & 0x28) == 0 )
                                        v7 = 1;
                                      if ( v8 )
                                      {
                                        sub_80DED2E(v10, 170);
                                      }
                                      else if ( v7 )
                                      {
                                        sub_80DED2E(v10, 171);
                                      }
                                    }
                                    if ( *(_BYTE *)(player_toggleBinoculars + 8) )
                                    {
                                      v6 = 0;
                                      if ( (*(_DWORD *)(a1 + 36) & 0x4000) == 0 && (*(_DWORD *)(a1 + 8) & 0x4000) != 0 )
                                        v6 = 1;
                                      v5 = 0;
                                      if ( v6 && (*(int *)(v10 + 216) <= 16 || *(int *)(v10 + 216) > 22) )
                                        v5 = 1;
                                      v12 = v5;
                                      v4 = 0;
                                      if ( v6 && *(int *)(v10 + 216) > 17 && *(int *)(v10 + 216) <= 20 )
                                        v4 = 1;
                                      result = v4;
                                      v11 = v4;
                                    }
                                    else
                                    {
                                      v3 = 0;
                                      if ( (*(_DWORD *)(a1 + 8) & 0x4000) != 0
                                        && (*(int *)(v10 + 216) <= 16 || *(int *)(v10 + 216) > 22) )
                                      {
                                        v3 = 1;
                                      }
                                      v12 = v3;
                                      v2 = 0;
                                      if ( (*(_DWORD *)(a1 + 8) & 0x4000) == 0
                                        && *(int *)(v10 + 216) > 17
                                        && *(int *)(v10 + 216) <= 20 )
                                      {
                                        v2 = 1;
                                      }
                                      result = v2;
                                      v11 = v2;
                                    }
                                    if ( v12 )
                                    {
                                      result = sub_80E95A8();
                                      if ( result )
                                      {
                                        if ( *(_BYTE *)(a1 + 12) )
                                        {
                                          if ( (*(_DWORD *)(a1 + 8) & 0x1000) != 0 )
                                            return (int)sub_80ED8D2((_DWORD *)v10);
                                          else
                                            return sub_80ED928((_DWORD *)v10);
                                        }
                                        else
                                        {
                                          return sub_80ED97E((_DWORD *)v10);
                                        }
                                      }
                                    }
                                    else if ( v11 )
                                    {
                                      if ( *(_DWORD *)(v10 + 216) == 18 )
                                        return sub_80EDA78(a1);
                                      else
                                        return sub_80EDA06((_DWORD *)v10);
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  return result;
}
// 85760EC: using guessed type int player_toggleBinoculars;

//----- (080EDF3A) --------------------------------------------------------
int __cdecl sub_80EDF3A(int a1, int a2)
{
  int result; // eax
  int v3; // [esp+10h] [ebp-8h]
  int v4; // [esp+14h] [ebp-4h]

  v3 = *(_DWORD *)a1;
  result = *(_DWORD *)(*(_DWORD *)a1 + 12) & 0x1000;
  if ( !result )
  {
    if ( *(int *)(v3 + 4) <= 5 )
    {
      result = *(_DWORD *)(v3 + 160) & 0x300;
      if ( !result )
      {
        sub_80EA568((int *)a1, a2);
        sub_80EA950((int *)a1, a2);
        result = sub_80ED780((_DWORD *)v3, a2);
        if ( !(_BYTE)result )
        {
          v4 = sub_80EC560((_BYTE *)a1, a2);
          sub_80EDB00(a1);
          sub_80ED5AE((int *)a1);
          sub_80EC7D2((unsigned __int8 *)a1);
          sub_80EBFF0(a1);
          sub_80ED01A((int *)a1, v4);
          result = sub_80EAF58(v3, v4);
          if ( !result )
          {
            if ( (*(_BYTE *)(v3 + 12) & 1) != 0 && (*(_BYTE *)(a1 + 28) || *(_BYTE *)(a1 + 29))
              || *(_DWORD *)(v3 + 216) == 10
              || *(_DWORD *)(v3 + 216) == 11 )
            {
              *(_DWORD *)(v3 + 1492) = 1132396544;
            }
            if ( v4 || (result = v3, !*(_DWORD *)(v3 + 52)) && (result = v3, !*(_DWORD *)(v3 + 56)) )
            {
              result = *(_DWORD *)(v3 + 216);
              switch ( result )
              {
                case 1:
                  result = sub_80EBA76(v3);
                  break;
                case 2:
                  result = sub_80EB738((unsigned __int8 *)a1);
                  break;
                case 5:
                case 6:
                  result = sub_80EBE96((_DWORD *)v3, v4);
                  break;
                case 7:
                case 8:
                  result = sub_80EBD80((_DWORD *)v3, v4);
                  break;
                case 9:
                  result = sub_80EBFC8(v3);
                  break;
                case 10:
                  result = sub_80ECF70((_DWORD *)v3);
                  break;
                case 11:
                  result = sub_80ECFF2(v3);
                  break;
                case 12:
                  result = sub_80ED2F2((_DWORD *)v3);
                  break;
                case 13:
                  result = sub_80ED382((_DWORD *)v3);
                  break;
                case 14:
                  result = sub_80ED3DE((int *)a1);
                  break;
                case 15:
                  result = sub_80ED50A((_DWORD *)v3);
                  break;
                case 16:
                case 22:
                  result = sub_80ED212((_DWORD *)v3);
                  break;
                case 17:
                  result = sub_80ED928((_DWORD *)v3);
                  break;
                case 18:
                  result = sub_80ED97E((_DWORD *)v3);
                  break;
                case 19:
                  result = (int)sub_80ED9E0((_DWORD *)v3);
                  break;
                case 20:
                  return result;
                case 21:
                  result = sub_80EDA78(a1);
                  break;
                default:
                  result = v3;
                  if ( *(_DWORD *)(v3 + 212) )
                  {
                    result = sub_80ECA14((_BYTE *)a1, v4);
                    if ( !result )
                      result = sub_80ECE56((_DWORD *)v3, v4);
                  }
                  break;
              }
            }
          }
        }
      }
    }
    else
    {
      result = *(_DWORD *)a1;
      *(_DWORD *)(v3 + 212) = 0;
    }
  }
  return result;
}

//----- (080EE212) --------------------------------------------------------
int __cdecl sub_80EE212(_DWORD *a1)
{
  return sub_80ED212(a1);
}

//----- (080EE226) --------------------------------------------------------
float *__cdecl sub_80EE226(int a1, float *a2, int a3)
{
  float *result; // eax
  float v4; // [esp+Ch] [ebp-3Ch]
  float v5; // [esp+10h] [ebp-38h]
  float v6; // [esp+14h] [ebp-34h]
  float v7; // [esp+18h] [ebp-30h]
  float v8; // [esp+1Ch] [ebp-2Ch]
  float v9; // [esp+20h] [ebp-28h]
  float v10; // [esp+24h] [ebp-24h]
  float v11; // [esp+28h] [ebp-20h]
  float v12; // [esp+2Ch] [ebp-1Ch]
  int v13; // [esp+30h] [ebp-18h]
  float v14; // [esp+34h] [ebp-14h]
  float v15; // [esp+38h] [ebp-10h]
  float v16; // [esp+38h] [ebp-10h]
  float v17; // [esp+38h] [ebp-10h]
  float v18; // [esp+38h] [ebp-10h]
  float v19; // [esp+3Ch] [ebp-Ch]
  float v20; // [esp+3Ch] [ebp-Ch]
  float v21; // [esp+3Ch] [ebp-Ch]
  float v22; // [esp+3Ch] [ebp-Ch]
  float *v23; // [esp+40h] [ebp-8h]

  v13 = sub_80E95EE((_DWORD *)a1);
  v23 = (float *)BG_WeaponDefs(v13);
  v14 = *(float *)(a1 + 220);
  v12 = 1.0;
  if ( *(int *)(a1 + 64) > 0 )
  {
    if ( v14 == 1.0 )
      v12 = v23[287] * 0.0099999998;
    else
      v12 = v23[305] * 0.0099999998;
  }
  if ( v14 == 1.0 )
  {
    v11 = v23[297] - v23[296];
    v19 = sub_80A1410() * v11 + v23[296];
    v10 = v23[299] - v23[298];
    v15 = sub_80A1410() * v10 + v23[298];
  }
  else
  {
    v9 = v23[315] - v23[314];
    v19 = sub_80A1410() * v9 + v23[314];
    v8 = v23[317] - v23[316];
    v15 = sub_80A1410() * v8 + v23[316];
  }
  v20 = v19 * v12;
  v16 = v15 * v12;
  *(_DWORD *)a3 = LODWORD(v20) ^ 0x80000000;
  *(float *)(a3 + 4) = v16;
  *(float *)(a3 + 8) = *(float *)(a3 + 4) * -0.5;
  if ( v14 <= 0.0 )
  {
    v5 = v23[307] - v23[306];
    v21 = sub_80A1410() * v5 + v23[306];
    v4 = v23[309] - v23[308];
    v17 = sub_80A1410() * v4 + v23[308];
  }
  else
  {
    v7 = v23[289] - v23[288];
    v21 = sub_80A1410() * v7 + v23[288];
    v6 = v23[291] - v23[290];
    v17 = sub_80A1410() * v6 + v23[290];
  }
  v22 = v21 * v12;
  v18 = v17 * v12;
  *a2 = *a2 + v22;
  result = a2 + 1;
  a2[1] = a2[1] + v18;
  return result;
}

//----- (080EE4AA) --------------------------------------------------------
long double __cdecl sub_80EE4AA(int a1)
{
  return (float)((long double)*(unsigned __int8 *)(a1 + 8) / 255.0 * 3.141592653589793
               + (long double)*(unsigned __int8 *)(a1 + 8) / 255.0 * 3.141592653589793
               + 6.283185307179586);
}

//----- (080EE506) --------------------------------------------------------
long double __cdecl sub_80EE506(int a1, float a2, float a3, float a4)
{
  long double v4; // fst7
  float v6; // [esp+Ch] [ebp-Ch]
  float v7; // [esp+Ch] [ebp-Ch]
  float v8; // [esp+Ch] [ebp-Ch]
  float v10; // [esp+10h] [ebp-8h]
  float v11; // [esp+14h] [ebp-4h]

  if ( *(_DWORD *)(a1 + 244) == 11 )
  {
    v11 = a3 * *(float *)(bg_bobAmplitudeProne + 8);
  }
  else
  {
    if ( *(_DWORD *)(a1 + 244) == 40 )
      v4 = a3 * *(float *)(bg_bobAmplitudeDucked + 8);
    else
      v4 = a3 * *(float *)(bg_bobAmplitudeStanding + 8);
    v11 = v4;
  }
  if ( v11 > (long double)a4 )
    v11 = a4;
  v6 = sin(a2 + a2);
  v10 = sin(a2 * 4.0 + 1.570796326794897);
  v7 = v10 * 0.2 + v6;
  v8 = 0.75 * v7;
  return (float)(v8 * v11);
}
// 85760B8: using guessed type int bg_bobAmplitudeStanding;
// 85760BC: using guessed type int bg_bobAmplitudeDucked;
// 85760C0: using guessed type int bg_bobAmplitudeProne;

//----- (080EE5C6) --------------------------------------------------------
long double __cdecl sub_80EE5C6(int a1, float a2, float a3, float a4)
{
  long double v4; // fst7
  float v6; // [esp+10h] [ebp-8h]
  float v7; // [esp+14h] [ebp-4h]

  if ( *(_DWORD *)(a1 + 244) == 11 )
  {
    v7 = a3 * *(float *)(bg_bobAmplitudeProne + 8);
  }
  else
  {
    if ( *(_DWORD *)(a1 + 244) == 40 )
      v4 = a3 * *(float *)(bg_bobAmplitudeDucked + 8);
    else
      v4 = a3 * *(float *)(bg_bobAmplitudeStanding + 8);
    v7 = v4;
  }
  if ( v7 > (long double)a4 )
    v7 = a4;
  v6 = sin(a2);
  return v6 * v7;
}
// 85760B8: using guessed type int bg_bobAmplitudeStanding;
// 85760BC: using guessed type int bg_bobAmplitudeDucked;
// 85760C0: using guessed type int bg_bobAmplitudeProne;

//----- (080EE640) --------------------------------------------------------
void __cdecl sub_80EE640(float *a1, float *a2)
{
  int v2; // [esp+14h] [ebp-34h]
  int v3; // [esp+18h] [ebp-30h]
  float *v4; // [esp+1Ch] [ebp-2Ch]
  float v5[4]; // [esp+20h] [ebp-28h] BYREF
  float v6; // [esp+30h] [ebp-18h]
  float v7; // [esp+34h] [ebp-14h]
  float v8; // [esp+38h] [ebp-10h]
  int i; // [esp+3Ch] [ebp-Ch]

  v4 = *(float **)a1;
  v2 = sub_80E95EE(*(_DWORD **)a1);
  v3 = BG_WeaponDefs(v2);
  if ( ((_DWORD)v4[40] & 8) != 0 )
  {
    v6 = *(float *)(v3 + 432);
  }
  else if ( ((_DWORD)v4[40] & 4) != 0 )
  {
    v6 = *(float *)(v3 + 428);
  }
  else
  {
    v6 = *(float *)(v3 + 424);
  }
  if ( a1[1] <= (long double)v6 || *((_DWORD *)v4 + 54) == 5 )
  {
    sub_80F028C(v5);
  }
  else
  {
    v8 = (a1[1] - v6) / ((long double)*((int *)v4 + 20) - v6);
    sub_80F01B2(0.0, v8);
    sub_80F01D6(1.0, v8);
    if ( ((_DWORD)v4[40] & 8) != 0 )
    {
      sub_80F032A((float *)(v3 + 384), v8, v5);
    }
    else if ( ((_DWORD)v4[40] & 4) != 0 )
    {
      sub_80F032A((float *)(v3 + 348), v8, v5);
    }
    else
    {
      sub_80F032A((float *)(v3 + 312), v8, v5);
    }
  }
  if ( v4[55] != 0.0 )
  {
    v7 = 1.0 - v4[55];
    sub_80F032A(v5, v7, v5);
  }
  for ( i = 0; i <= 2; ++i )
  {
    if ( a1[i + 3] != v5[i] )
    {
      if ( v4[62] == 11.0 )
        v7 = (v5[i] - a1[i + 3]) * a1[2] * *(float *)(v3 + 420);
      else
        v7 = (v5[i] - a1[i + 3]) * a1[2] * *(float *)(v3 + 416);
      if ( v5[i] <= (long double)a1[i + 3] )
      {
        if ( v7 > a1[2] * -0.1 )
          v7 = a1[2] * -0.1;
        a1[i + 3] = a1[i + 3] + v7;
        if ( v5[i] > (long double)a1[i + 3] )
          a1[i + 3] = v5[i];
      }
      else
      {
        if ( a1[2] * 0.1 > v7 )
          v7 = a1[2] * 0.1;
        a1[i + 3] = a1[i + 3] + v7;
        if ( a1[i + 3] > (long double)v5[i] )
          a1[i + 3] = v5[i];
      }
    }
  }
  if ( v4[55] == 0.0 )
  {
    sub_80F02E6(a2, a1 + 3, a2);
  }
  else if ( v4[55] < 0.5 )
  {
    v7 = 1.0 - (v4[55] + v4[55]);
    sub_80F0362(a2, v7, a1 + 3, a2);
  }
}
// 80EE640: using guessed type float var_28[4];

//----- (080EEA0C) --------------------------------------------------------
void __cdecl sub_80EEA0C(float *a1, float *a2)
{
  int v2; // [esp+8h] [ebp-10h]
  int v3; // [esp+Ch] [ebp-Ch]
  int v4; // [esp+10h] [ebp-8h]

  v4 = *(_DWORD *)a1;
  v2 = sub_80E95EE(*(_DWORD **)a1);
  v3 = BG_WeaponDefs(v2);
  if ( sub_80E973E(v2) )
    *a2 = *(float *)(v4 + 220) * *(float *)(v3 + 1132) + *a2;
  sub_80EE640(a1, a2);
}

//----- (080EEA7C) --------------------------------------------------------
float *__cdecl sub_80EEA7C(float *a1, float *a2)
{
  float *result; // eax
  float v3; // [esp+14h] [ebp-24h]
  int v4; // [esp+18h] [ebp-20h]
  float *v5; // [esp+1Ch] [ebp-1Ch]
  float v6; // [esp+24h] [ebp-14h]
  float v7; // [esp+28h] [ebp-10h]
  float v8; // [esp+28h] [ebp-10h]
  float v9; // [esp+2Ch] [ebp-Ch]
  float v10; // [esp+2Ch] [ebp-Ch]
  float v11; // [esp+2Ch] [ebp-Ch]
  int v12; // [esp+30h] [ebp-8h]

  v5 = *(float **)a1;
  v4 = sub_80E95EE(*(_DWORD **)a1);
  v12 = BG_WeaponDefs(v4);
  if ( sub_80E973E(v4) )
  {
    v7 = (*(float *)(v12 + 712) - *(float *)(v12 + 716)) * v5[55] + *(float *)(v12 + 716);
    v3 = (*(float *)(v12 + 720) - *(float *)(v12 + 724)) * v5[55] + *(float *)(v12 + 724);
  }
  else if ( *(float *)(v12 + 716) == 0.0 )
  {
    v7 = 80.0;
    v3 = 1.0;
  }
  else
  {
    v7 = *(float *)(v12 + 716);
    v3 = *(float *)(v12 + 724);
  }
  if ( ((_DWORD)v5[40] & 8) != 0 )
  {
    v6 = *(float *)(v12 + 732);
  }
  else if ( ((_DWORD)v5[40] & 4) != 0 )
  {
    v6 = *(float *)(v12 + 728);
  }
  else
  {
    v6 = 1.0;
  }
  if ( (!*(_DWORD *)(v12 + 632) || v5[55] == 0.0) && v6 != a1[6] )
  {
    if ( v6 <= (long double)a1[6] )
    {
      a1[6] = a1[6] - a1[2] * 0.5;
      if ( v6 > (long double)a1[6] )
        a1[6] = v6;
    }
    else
    {
      a1[6] = a1[2] * 0.5 + a1[6];
      if ( a1[6] > (long double)v6 )
        a1[6] = v6;
    }
  }
  v8 = v7 * a1[6];
  if ( *(_DWORD *)(v12 + 632) )
    v8 = (1.0 - v5[55]) * v8;
  **((_DWORD **)a1 + 20) += (int)(a1[2] * 1000.0 * v3);
  v9 = sin((long double)**((int **)a1 + 20) * 0.00050000002);
  a2[2] = v8 * v9 * 0.0099999998 + a2[2];
  v10 = sin((long double)**((int **)a1 + 20) * 0.00069999998);
  a2[1] = v8 * v10 * 0.0099999998 + a2[1];
  v11 = sin((long double)**((int **)a1 + 20) * 0.001);
  result = a2;
  *a2 = v8 * v11 * 0.0099999998 + *a2;
  return result;
}

//----- (080EED76) --------------------------------------------------------
float *__cdecl sub_80EED76(int *a1, float *a2)
{
  long double v2; // fst7
  float v4; // [esp+0h] [ebp-68h]
  float v5; // [esp+4h] [ebp-64h]
  float v6; // [esp+1Ch] [ebp-4Ch]
  float v7; // [esp+1Ch] [ebp-4Ch]
  int v8; // [esp+30h] [ebp-38h]
  int v9; // [esp+34h] [ebp-34h]
  int v10; // [esp+38h] [ebp-30h]
  float v11; // [esp+3Ch] [ebp-2Ch]
  int v12; // [esp+40h] [ebp-28h] BYREF
  float v13; // [esp+44h] [ebp-24h]
  float v14; // [esp+48h] [ebp-20h]
  float v15; // [esp+54h] [ebp-14h]
  float v16; // [esp+58h] [ebp-10h]
  float v17; // [esp+5Ch] [ebp-Ch]

  v10 = *a1;
  v8 = sub_80E95EE((_DWORD *)*a1);
  v9 = BG_WeaponDefs(v8);
  v11 = (long double)*(unsigned __int8 *)(v10 + 8) / 255.0 * 3.141592653589793
      + (long double)*(unsigned __int8 *)(v10 + 8) / 255.0 * 3.141592653589793
      + 6.283185307179586;
  v16 = v11 + 0.7853981633974483 + 6.283185307179586;
  v15 = *((float *)a1 + 1) * 0.16;
  v6 = sub_80EE506(v10, v16, v15, 10.0);
  v12 = LODWORD(v6) ^ 0x80000000;
  v7 = sub_80EE5C6(v10, v16, v15, 10.0);
  LODWORD(v13) = LODWORD(v7) ^ 0x80000000;
  v16 = v16 - 0.4712389167638204;
  v15 = v15 * 1.5;
  v2 = sub_80EE5C6(v10, v16, v15, 10.0);
  v4 = v2;
  sub_80F01D6(v4, 0.0);
  v14 = v2;
  v17 = *(float *)(v10 + 220);
  if ( v17 != 0.0 )
  {
    v15 = 1.0 - (1.0 - *(float *)(v9 + 644)) * v17;
    *(float *)&v12 = *(float *)&v12 * v15;
    v13 = v13 * v15;
    v14 = v14 * v15;
  }
  if ( *(_DWORD *)(v9 + 632) )
  {
    v5 = 1.0 - v17;
    sub_80F032A((float *)&v12, v5, (float *)&v12);
  }
  return sub_80F02E6(a2, (float *)&v12, a2);
}

//----- (080EEF38) --------------------------------------------------------
void __cdecl sub_80EEF38(float *a1, float *a2)
{
  float v2; // [esp+0h] [ebp-28h]
  int v3; // [esp+Ch] [ebp-1Ch]
  int v4; // [esp+10h] [ebp-18h]
  float *v5; // [esp+14h] [ebp-14h]
  float v6; // [esp+18h] [ebp-10h]
  float v7; // [esp+1Ch] [ebp-Ch]
  float v8; // [esp+20h] [ebp-8h]
  float v9; // [esp+24h] [ebp-4h]
  float v10; // [esp+24h] [ebp-4h]
  float v11; // [esp+24h] [ebp-4h]
  float v12; // [esp+24h] [ebp-4h]
  float v13; // [esp+24h] [ebp-4h]
  float v14; // [esp+24h] [ebp-4h]
  float v15; // [esp+24h] [ebp-4h]

  if ( *((_DWORD *)a1 + 8) )
  {
    v5 = *(float **)a1;
    v3 = sub_80E95EE(*(_DWORD **)a1);
    v4 = BG_WeaponDefs(v3);
    v8 = v5[55] * 0.5 + 0.5;
    v7 = v8 * 100.0;
    v6 = v8 * 400.0;
    if ( v5[55] != 0.0 && *(_DWORD *)(v4 + 632) )
      v8 = (1.0 - v5[55] * 0.75) * v8;
    v9 = (float)(*((_DWORD *)a1 + 7) - *((_DWORD *)a1 + 8));
    if ( v7 <= (long double)v9 )
    {
      v13 = 1.0 - (v9 - v7) / v6;
      if ( v13 > 0.0 )
      {
        v2 = 1.0 - v13;
        v14 = 1.0 - sub_80B6688(v2);
        v15 = v14 * v8;
        *a2 = v15 * a1[9] * 0.5 + *a2;
        a2[1] = a2[1] - v15 * a1[10];
        a2[2] = v15 * a1[10] * 0.5 + a2[2];
      }
    }
    else
    {
      v10 = v9 / v7;
      v11 = sub_80B6688(v10);
      v12 = v11 * v8;
      *a2 = v12 * a1[9] * 0.5 + *a2;
      a2[1] = a2[1] - v12 * a1[10];
      a2[2] = v12 * a1[10] * 0.5 + a2[2];
    }
  }
}

//----- (080EF12E) --------------------------------------------------------
int __cdecl sub_80EF12E(float *a1, float *a2, float a3, float a4, float a5, float a6, float a7, float a8)
{
  int v9; // [esp+14h] [ebp-4h]

  v9 = 0;
  if ( sub_80F0198(*a1) >= 0.25 || sub_80F0198(*a2) >= 1.0 )
  {
    *a1 = *a2 * a3 + *a1;
    if ( *a1 <= (long double)a4 )
    {
      if ( -a4 > (long double)*a1 )
      {
        *(_DWORD *)a1 = LODWORD(a4) ^ 0x80000000;
        if ( *a2 < 0.0 )
          *a2 = 0.0;
      }
    }
    else
    {
      *a1 = a4;
      if ( *a2 > 0.0 )
        *a2 = 0.0;
    }
    if ( *a1 <= 0.0 )
    {
      if ( *a1 < 0.0 )
        *a2 = a5 * a3 + *a2;
    }
    else
    {
      *a2 = *a2 - a5 * a3;
    }
    *a2 = *a2 - *a2 * a7 * a3;
    if ( *a2 <= 0.0 )
    {
      *a2 = a8 * a3 + *a2;
      if ( *a2 > 0.0 )
        *a2 = 0.0;
    }
    else
    {
      *a2 = *a2 - a8 * a3;
      if ( *a2 < 0.0 )
        *a2 = 0.0;
    }
    if ( *a2 <= (long double)a6 )
    {
      if ( -a6 > (long double)*a2 )
        *(_DWORD *)a2 = LODWORD(a6) ^ 0x80000000;
    }
    else
    {
      *a2 = a6;
    }
  }
  else
  {
    *a1 = 0.0;
    *a2 = 0.0;
    return 1;
  }
  return v9;
}

//----- (080EF336) --------------------------------------------------------
float *__cdecl sub_80EF336(float *a1, float *a2)
{
  float *result; // eax
  int v3; // eax
  int v4; // [esp+2Ch] [ebp-2Ch]
  float *v5; // [esp+30h] [ebp-28h]
  float *v6; // [esp+34h] [ebp-24h]
  float v7; // [esp+38h] [ebp-20h]
  float v8; // [esp+3Ch] [ebp-1Ch]
  float v9; // [esp+40h] [ebp-18h]
  float v10; // [esp+44h] [ebp-14h]
  float v11; // [esp+48h] [ebp-10h]
  int v12; // [esp+4Ch] [ebp-Ch]
  int v13; // [esp+50h] [ebp-8h]
  float v14; // [esp+54h] [ebp-4h]

  v6 = *(float **)a1;
  v4 = sub_80E95EE(*(_DWORD **)a1);
  v5 = (float *)BG_WeaponDefs(v4);
  result = (float *)sub_80E973E(v4);
  if ( result )
  {
    v7 = v6[55];
    v11 = (v5[292] - v5[310]) * v7 + v5[310];
    v10 = (v5[293] - v5[311]) * v7 + v5[311];
    v9 = (v5[294] - v5[312]) * v7 + v5[312];
    v8 = (v5[295] - v5[313]) * v7 + v5[313];
    v14 = a1[2];
    while ( v14 > 0.0 )
    {
      if ( v14 <= 0.005 )
      {
        v13 = LODWORD(v14);
        v14 = 0.0;
        v3 = sub_80EF12E(a1 + 11, a1 + 14, *(float *)&v13, v5[184], v11, v10, v9, v8);
      }
      else
      {
        v13 = 1000593162;
        v14 = v14 - 0.005;
        v3 = sub_80EF12E(a1 + 11, a1 + 14, 0.0049999999, v5[184], v11, v10, v9, v8);
      }
      v12 = v3;
      if ( sub_80EF12E(a1 + 12, a1 + 15, *(float *)&v13, v5[185], v11, v10, v9, v8) )
      {
        if ( v12 )
          break;
      }
    }
    return sub_80F02E6(a2, a1 + 11, a2);
  }
  return result;
}

//----- (080EF52C) --------------------------------------------------------
int __cdecl sub_80EF52C(float *a1, int a2)
{
  long double v2; // fst7
  int result; // eax
  float v4; // [esp+10h] [ebp-8h]
  float v5; // [esp+14h] [ebp-4h]

  v4 = *a1;
  sub_80F028C((_DWORD *)a2);
  if ( *(float *)(LODWORD(v4) + 76) != 0.0 )
  {
    v5 = sub_80B6688(*(float *)(LODWORD(v4) + 76));
    *(float *)(a2 + 8) = *(float *)(a2 + 8) - (v5 + v5);
  }
  sub_80EEA0C(a1, (float *)a2);
  sub_80EEA7C(a1, (float *)a2);
  sub_80EED76((int *)a1, (float *)a2);
  sub_80EEF38(a1, (float *)a2);
  sub_80EF336(a1, (float *)a2);
  *(float *)a2 = sub_80A6000(*(float *)a2, a1[17]);
  v2 = sub_80A6000(*(float *)(a2 + 4), a1[18]);
  result = a2 + 4;
  *(float *)(a2 + 4) = v2;
  return result;
}

//----- (080EF61E) --------------------------------------------------------
void __cdecl sub_80EF61E(float *a1, float *a2)
{
  float v2; // [esp+0h] [ebp-18h]
  int v3; // [esp+4h] [ebp-14h]
  int v4; // [esp+8h] [ebp-10h]
  float *v5; // [esp+Ch] [ebp-Ch]
  float v6; // [esp+10h] [ebp-8h]
  float v7; // [esp+14h] [ebp-4h]
  float v8; // [esp+14h] [ebp-4h]
  float v9; // [esp+14h] [ebp-4h]
  float v10; // [esp+14h] [ebp-4h]
  float v11; // [esp+14h] [ebp-4h]
  float v12; // [esp+14h] [ebp-4h]
  float v13; // [esp+14h] [ebp-4h]

  if ( *((_DWORD *)a1 + 1) )
  {
    v5 = *(float **)a1;
    v3 = sub_80E95EE(*(_DWORD **)a1);
    v4 = BG_WeaponDefs(v3);
    v6 = 1.0 - v5[55] * 0.5;
    if ( v5[55] != 0.0 && *(_DWORD *)(v4 + 632) )
      v6 = (v5[55] * 0.5 + 1.0) * v6;
    v7 = (float)(*((_DWORD *)a1 + 2) - *((_DWORD *)a1 + 1));
    if ( v7 >= 100.0 )
    {
      v11 = 1.0 - (v7 - 100.0) / 400.0;
      if ( v11 > 0.0 )
      {
        v2 = 1.0 - v11;
        v12 = 1.0 - sub_80B6688(v2);
        v13 = v12 * v6;
        *a2 = v13 * a1[3] + *a2;
        a2[2] = v13 * a1[4] + a2[2];
      }
    }
    else
    {
      v8 = v7 / 100.0;
      v9 = sub_80B6688(v8);
      v10 = v9 * v6;
      *a2 = v10 * a1[3] + *a2;
      a2[2] = v10 * a1[4] + a2[2];
    }
  }
}

//----- (080EF7AA) --------------------------------------------------------
int __cdecl sub_80EF7AA(float *a1, float *a2)
{
  int result; // eax
  float v3; // [esp+14h] [ebp-24h]
  int v4; // [esp+18h] [ebp-20h]
  float *v5; // [esp+1Ch] [ebp-1Ch]
  float v6; // [esp+24h] [ebp-14h]
  float v7; // [esp+28h] [ebp-10h]
  float v8; // [esp+28h] [ebp-10h]
  float v9; // [esp+28h] [ebp-10h]
  float v10; // [esp+28h] [ebp-10h]
  float v11; // [esp+2Ch] [ebp-Ch]
  float v12; // [esp+2Ch] [ebp-Ch]
  int v13; // [esp+30h] [ebp-8h]

  v5 = *(float **)a1;
  v4 = sub_80E95EE(*(_DWORD **)a1);
  result = BG_WeaponDefs(v4);
  v13 = result;
  if ( *(_DWORD *)(result + 632) )
  {
    if ( sub_80E973E(v4) )
    {
      v7 = (*(float *)(v13 + 712) - *(float *)(v13 + 716)) * v5[55] + *(float *)(v13 + 716);
      v3 = (*(float *)(v13 + 720) - *(float *)(v13 + 724)) * v5[55] + *(float *)(v13 + 724);
    }
    else if ( *(float *)(v13 + 716) == 0.0 )
    {
      v7 = 80.0;
      v3 = 1.0;
    }
    else
    {
      v7 = *(float *)(v13 + 716);
      v3 = *(float *)(v13 + 724);
    }
    if ( ((_DWORD)v5[40] & 8) != 0 )
    {
      v6 = *(float *)(v13 + 732);
    }
    else if ( ((_DWORD)v5[40] & 4) != 0 )
    {
      v6 = *(float *)(v13 + 728);
    }
    else
    {
      v6 = 1.0;
    }
    if ( *(_DWORD *)(v13 + 632) && v5[55] != 0.0 && v6 != a1[7] )
    {
      if ( v6 <= (long double)a1[7] )
      {
        a1[7] = a1[7] - a1[6] * 0.5;
        if ( v6 > (long double)a1[7] )
          a1[7] = v6;
      }
      else
      {
        a1[7] = a1[6] * 0.5 + a1[7];
        if ( a1[7] > (long double)v6 )
          a1[7] = v6;
      }
    }
    v8 = v7 * a1[7];
    v9 = v8 * v5[55];
    v10 = v9 * v5[365];
    **((_DWORD **)a1 + 8) += (int)(v5[365] * a1[6] * 1000.0 * v3);
    v11 = sin((long double)**((int **)a1 + 8) * 0.00069999998);
    a2[1] = v10 * v11 * 0.0099999998 + a2[1];
    v12 = sin((long double)**((int **)a1 + 8) * 0.001);
    result = (int)a2;
    *a2 = v10 * v12 * 0.0099999998 + *a2;
  }
  return result;
}

//----- (080EFA86) --------------------------------------------------------
float *__cdecl sub_80EFA86(int *a1, float *a2)
{
  float *result; // eax
  long double v3; // fst7
  float v4; // [esp+0h] [ebp-68h]
  float v5; // [esp+1Ch] [ebp-4Ch]
  float v6; // [esp+1Ch] [ebp-4Ch]
  int v7; // [esp+30h] [ebp-38h]
  float *v8; // [esp+34h] [ebp-34h]
  int v9; // [esp+38h] [ebp-30h]
  float v10; // [esp+3Ch] [ebp-2Ch]
  int v11; // [esp+40h] [ebp-28h] BYREF
  float v12; // [esp+44h] [ebp-24h]
  float v13; // [esp+48h] [ebp-20h]
  float v14; // [esp+54h] [ebp-14h]
  float v15; // [esp+58h] [ebp-10h]
  float v16; // [esp+5Ch] [ebp-Ch]

  v9 = *a1;
  v7 = sub_80E95EE((_DWORD *)*a1);
  result = (float *)BG_WeaponDefs(v7);
  v8 = result;
  if ( *((_DWORD *)result + 158) )
  {
    v10 = (long double)*(unsigned __int8 *)(v9 + 8) / 255.0 * 3.141592653589793
        + (long double)*(unsigned __int8 *)(v9 + 8) / 255.0 * 3.141592653589793
        + 6.283185307179586;
    v15 = v10 + 0.7853981633974483 + 6.283185307179586;
    v14 = *((float *)a1 + 5) * 0.16;
    v5 = sub_80EE506(v9, v15, v14, 10.0);
    v11 = LODWORD(v5) ^ 0x80000000;
    v6 = sub_80EE5C6(v9, v15, v14, 10.0);
    LODWORD(v12) = LODWORD(v6) ^ 0x80000000;
    v15 = v15 - 0.4712389167638204;
    v14 = v14 * 1.5;
    v3 = sub_80EE5C6(v9, v15, v14, 10.0);
    v4 = v3;
    sub_80F01D6(v4, 0.0);
    v13 = v3;
    v16 = *(float *)(v9 + 220);
    if ( v16 != 0.0 )
    {
      v14 = 1.0 - (1.0 - v8[161]) * v16;
      *(float *)&v11 = *(float *)&v11 * v14;
      v12 = v12 * v14;
      v13 = v13 * v14;
    }
    sub_80F032A((float *)&v11, v16, (float *)&v11);
    return sub_80F02E6(a2, (float *)&v11, a2);
  }
  return result;
}

//----- (080EFC4A) --------------------------------------------------------
void __cdecl sub_80EFC4A(_DWORD **a1, float *a2)
{
  int v2; // [esp+20h] [ebp-18h]
  int v3; // [esp+24h] [ebp-14h]
  int v4; // [esp+28h] [ebp-10h]
  float v5; // [esp+2Ch] [ebp-Ch]
  float v6; // [esp+30h] [ebp-8h]
  float v7; // [esp+30h] [ebp-8h]
  float v8; // [esp+34h] [ebp-4h]
  float v9; // [esp+34h] [ebp-4h]

  v4 = (int)*a1;
  v2 = sub_80E95EE(*a1);
  v3 = BG_WeaponDefs(v2);
  if ( (*(_DWORD *)(v4 + 160) & 0x300) == 0 && *(float *)(v4 + 220) != 0.0 && *(float *)(v3 + 648) != 0.0 )
  {
    v5 = (long double)*(unsigned __int8 *)(v4 + 8) / 255.0 * 3.141592653589793
       + (long double)*(unsigned __int8 *)(v4 + 8) / 255.0 * 3.141592653589793
       + 6.283185307179586;
    v8 = sub_80EE506(v4, v5, *((float *)a1 + 5), 45.0);
    v9 = *(float *)(v4 + 220) * *(float *)(v3 + 648) * v8;
    *a2 = *a2 - v9;
    v6 = sub_80EE5C6(v4, v5, *((float *)a1 + 5), 45.0);
    v7 = *(float *)(v4 + 220) * *(float *)(v3 + 648) * v6;
    a2[1] = a2[1] - v7;
  }
}

//----- (080EFD94) --------------------------------------------------------
void __cdecl sub_80EFD94(float *a1, float *a2)
{
  sub_80F028C(a2);
  sub_80EF61E(a1, a2);
  sub_80EF7AA(a1, a2);
  sub_80EFA86((int *)a1, a2);
  sub_80EFC4A((_DWORD **)a1, a2);
}

//----- (080EFDF0) --------------------------------------------------------
int __cdecl sub_80EFDF0(int a1, float *a2, int a3, float *a4, float a5, int a6)
{
  int result; // eax
  long double v7; // fst7
  float v8; // [esp+4h] [ebp-74h]
  int v9; // [esp+1Ch] [ebp-5Ch]
  float v10; // [esp+20h] [ebp-58h]
  float v11; // [esp+24h] [ebp-54h]
  float v12; // [esp+28h] [ebp-50h]
  float v13; // [esp+28h] [ebp-50h]
  float v14; // [esp+2Ch] [ebp-4Ch]
  float v15; // [esp+2Ch] [ebp-4Ch]
  float v16; // [esp+30h] [ebp-48h]
  float v17; // [esp+30h] [ebp-48h]
  float v18; // [esp+34h] [ebp-44h]
  float v19; // [esp+34h] [ebp-44h]
  float v20; // [esp+38h] [ebp-40h]
  float v21; // [esp+3Ch] [ebp-3Ch]
  float v22; // [esp+44h] [ebp-34h]
  float v23; // [esp+48h] [ebp-30h]
  float v24; // [esp+50h] [ebp-28h] BYREF
  float v25; // [esp+54h] [ebp-24h]
  int v26; // [esp+6Ch] [ebp-Ch]

  result = *(_DWORD *)(a1 + 220);
  v11 = *(float *)&result;
  if ( a6 )
  {
    v9 = sub_80E95EE((_DWORD *)a1);
    v26 = BG_WeaponDefs(v9);
    v10 = (long double)a6 * 0.001;
    if ( !sub_80E973E(v9) )
    {
      v21 = *(float *)(v26 + 744);
      v20 = *(float *)(v26 + 748);
      v18 = *(float *)(v26 + 752);
      v16 = *(float *)(v26 + 756);
      v14 = *(float *)(v26 + 760);
      v12 = *(float *)(v26 + 764);
      goto LABEL_7;
    }
    if ( v11 <= 0.0 || (result = v26, !*(_DWORD *)(v26 + 632)) )
    {
      v21 = (*(float *)(v26 + 772) - *(float *)(v26 + 744)) * v11 + *(float *)(v26 + 744);
      v20 = (*(float *)(v26 + 776) - *(float *)(v26 + 748)) * v11 + *(float *)(v26 + 748);
      v18 = (*(float *)(v26 + 780) - *(float *)(v26 + 752)) * v11 + *(float *)(v26 + 752);
      v16 = (*(float *)(v26 + 784) - *(float *)(v26 + 756)) * v11 + *(float *)(v26 + 756);
      v14 = (*(float *)(v26 + 788) - *(float *)(v26 + 760)) * v11 + *(float *)(v26 + 760);
      v12 = (*(float *)(v26 + 792) - *(float *)(v26 + 764)) * v11 + *(float *)(v26 + 764);
LABEL_7:
      v19 = v18 * a5;
      v17 = v16 * a5;
      v15 = v14 * a5;
      v13 = v12 * a5;
      sub_80A6062((float *)(a1 + 232), a2, &v24);
      v8 = 1.0 / (v10 * 60.0);
      sub_80F032A(&v24, v8, &v24);
      v24 = sub_80F0220(v24, COERCE_FLOAT(LODWORD(v21) ^ 0x80000000), v21);
      v25 = sub_80F0220(v25, COERCE_FLOAT(LODWORD(v21) ^ 0x80000000), v21);
      v22 = v25 * v15;
      v23 = v24 * v13;
      *(float *)(a3 + 4) = sub_80A1986(v22, *(float *)(a3 + 4), v20, v10);
      *(float *)(a3 + 8) = sub_80A1986(v23, *(float *)(a3 + 8), v20, v10);
      v24 = v24 * v19;
      v7 = v25 * v17;
      v25 = v7;
      sub_80A1A02(v24, *a4, v20, v10);
      *a4 = v7;
      sub_80A1A02(v25, a4[1], v20, v10);
      a4[1] = v7;
      return sub_80F02B6((_DWORD *)(a1 + 232), a2);
    }
  }
  return result;
}

//----- (080F0110) --------------------------------------------------------
char **__cdecl sub_80F0110(const char *a1, char *s)
{
  int v4; // [esp+14h] [ebp-4h]
  char **v5; // [esp+14h] [ebp-4h]

  if ( !*s )
    return 0;
  v4 = BG_LoadWeaponDefInternal(a1, s);
  if ( v4 )
    return (char **)v4;
  v5 = (char **)BG_LoadWeaponDefInternal(a1, "defaultweapon_mp");
  if ( !v5 )
    Com_Error(1, (char *)&byte_814E800);
  sub_80F0B8E(v5, s);
  return v5;
}
// 80F0110: using guessed type const char *arg_0;

//----- (080F0198) --------------------------------------------------------
long double __cdecl sub_80F0198(float a1)
{
  return (float)fabs(a1);
}

//----- (080F01B2) --------------------------------------------------------
void __cdecl sub_80F01B2(float a1, float a2)
{
  float v2; // [esp+0h] [ebp-18h]

  v2 = a1 - a2;
  sub_80F03B6(v2, a1, a2);
}

//----- (080F01D6) --------------------------------------------------------
void __cdecl sub_80F01D6(float a1, float a2)
{
  float v2; // [esp+0h] [ebp-18h]

  v2 = a2 - a1;
  sub_80F03B6(v2, a1, a2);
}

//----- (080F01FA) --------------------------------------------------------
int __cdecl sub_80F01FA(int a1, int a2)
{
  return sub_80F03E0(a1 - a2, a1, a2);
}

//----- (080F0220) --------------------------------------------------------
long double __cdecl sub_80F0220(float a1, float a2, float a3)
{
  float v4; // [esp+0h] [ebp-18h]
  float v5; // [esp+0h] [ebp-18h]
  float v6; // [esp+8h] [ebp-10h]

  v4 = a1 - a3;
  v6 = sub_80F03B6(v4, a3, a1);
  v5 = a2 - a1;
  return sub_80F03B6(v5, a2, v6);
}

//----- (080F025E) --------------------------------------------------------
long double __cdecl sub_80F025E(float a1)
{
  return a1 * a1;
}

//----- (080F026A) --------------------------------------------------------
long double __cdecl sub_80F026A(float *a1)
{
  return *a1 * *a1 + a1[1] * a1[1];
}

//----- (080F028C) --------------------------------------------------------
int __cdecl sub_80F028C(_DWORD *a1)
{
  int result; // eax

  *a1 = 0;
  a1[1] = 0;
  result = 0;
  a1[2] = 0;
  return result;
}

//----- (080F02B6) --------------------------------------------------------
int __cdecl sub_80F02B6(_DWORD *a1, _DWORD *a2)
{
  int result; // eax

  *a2 = *a1;
  a2[1] = a1[1];
  result = a1[2];
  a2[2] = result;
  return result;
}

//----- (080F02E6) --------------------------------------------------------
float *__cdecl sub_80F02E6(float *a1, float *a2, float *a3)
{
  float *result; // eax

  *a3 = *a1 + *a2;
  a3[1] = a1[1] + a2[1];
  result = a1 + 2;
  a3[2] = a1[2] + a2[2];
  return result;
}

//----- (080F032A) --------------------------------------------------------
float *__cdecl sub_80F032A(float *a1, float a2, float *a3)
{
  float *result; // eax

  *a3 = a2 * *a1;
  a3[1] = a2 * a1[1];
  result = a1 + 2;
  a3[2] = a2 * a1[2];
  return result;
}

//----- (080F0362) --------------------------------------------------------
float *__cdecl sub_80F0362(float *a1, float a2, float *a3, float *a4)
{
  float *result; // eax

  *a4 = a2 * *a3 + *a1;
  a4[1] = a2 * a3[1] + a1[1];
  result = a3 + 2;
  a4[2] = a2 * a3[2] + a1[2];
  return result;
}

//----- (080F03B6) --------------------------------------------------------
long double __cdecl sub_80F03B6(float a1, float a2, float a3)
{
  if ( a1 < 0.0 )
    return a3;
  return a2;
}

//----- (080F03E0) --------------------------------------------------------
int __cdecl sub_80F03E0(int a1, int a2, int a3)
{
  if ( a1 < 0 )
    return a3;
  return a2;
}

//----- (080F0400) --------------------------------------------------------
int __cdecl sub_80F0400(int a1, int a2)
{
  int result; // eax

  result = *(_DWORD *)(a1 + 4 * (a2 >> 5)) & ~(1 << (a2 & 0x1F));
  *(_DWORD *)(a1 + 4 * (a2 >> 5)) = result;
  return result;
}

//----- (080F0450) --------------------------------------------------------
int __cdecl sub_80F0450(char *s1)
{
  int i; // [esp+14h] [ebp-4h]

  for ( i = 0; i <= 2; ++i )
  {
    if ( !strcasecmp(s1, (&off_8166550)[i]) )
      return i;
  }
  return 0;
}

//----- (080F049E) --------------------------------------------------------
char *__cdecl sub_80F049E(int a1)
{
  return (&off_8166550)[a1];
}

//----- (080F04AE) --------------------------------------------------------
int sub_80F04AE()
{
  int result; // eax
  int i; // [esp+14h] [ebp-4h]

  for ( i = 0; ; ++i )
  {
    result = i;
    if ( i >= dword_8576FC4 )
      break;
    sub_80D49D8(i, (int)(&dword_8576FE0)[i]);
  }
  return result;
}

//----- (080F04EA) --------------------------------------------------------
_DWORD *BG_LoadPlayerAnimTypes()
{
  int v0; // ebx
  size_t v1; // eax
  int v3; // [esp+18h] [ebp-1020h]
  char v4[4]; // [esp+1Ch] [ebp-101Ch] BYREF
  char v5[4104]; // [esp+20h] [ebp-1018h] BYREF
  char *s; // [esp+1028h] [ebp-10h]
  char *v7; // [esp+102Ch] [ebp-Ch] BYREF

  dword_8576FC4 = 0;
  v3 = FS_FOpenFileByMode("mp/playeranimtypes.txt", (int *)v4, 0);
  if ( v3 < 0 )
    Com_Error(1, (char *)&byte_814FFCE, "mp/playeranimtypes.txt");
  if ( (unsigned int)v3 > 0xFFF )
  {
    FS_FCloseFile(*(int *)v4);
    Com_Error(1, (char *)&byte_814FFE7, "mp/playeranimtypes.txt");
  }
  FS_Read((int)v5, v3, *(int *)v4);
  v5[v3] = 0;
  FS_FCloseFile(*(int *)v4);
  v7 = v5;
  Com_BeginParseSession("BG_AnimParseAnimScript");
  while ( 1 )
  {
    s = Com_Parse(&v7);
    if ( !s || !*s )
      break;
    if ( (unsigned int)dword_8576FC4 > 0x3F )
      Com_Error(1, (char *)&byte_8150020);
    v0 = dword_8576FC4;
    v1 = strlen(s);
    (&dword_8576FE0)[v0] = (char *)Hunk_AllocLowInternal(v1 + 1);
    strcpy((&dword_8576FE0)[dword_8576FC4], s);
    ++dword_8576FC4;
  }
  return Com_EndParseSession();
}
// 80F04EA: using guessed type char var_1018[4104];

//----- (080F065E) --------------------------------------------------------
int __cdecl sub_80F065E(char *s1, int a2, int a3)
{
  int i; // [esp+14h] [ebp-4h]

  for ( i = 0; i < a3; ++i )
  {
    if ( !strcasecmp(s1, *(const char **)(a2 + 4 * i)) )
      return i;
  }
  return -1;
}

//----- (080F06B4) --------------------------------------------------------
int __cdecl sub_80F06B4(_DWORD *a1, char *s1, int a3)
{
  int v4; // [esp+20h] [ebp-8h]
  int v5; // [esp+20h] [ebp-8h]
  int v6; // [esp+20h] [ebp-8h]
  int v7; // [esp+20h] [ebp-8h]
  int v8; // [esp+20h] [ebp-8h]
  int v9; // [esp+20h] [ebp-8h]
  int v10; // [esp+20h] [ebp-8h]
  int v11; // [esp+20h] [ebp-8h]

  switch ( a3 )
  {
    case 8:
      v4 = sub_80F065E(s1, (int)off_8166540, 4);
      if ( v4 < 0 )
        Com_Error(1, (char *)&byte_8150060, s1, *a1);
      a1[30] = v4;
      break;
    case 9:
      v5 = sub_80F065E(s1, (int)off_8166580, 10);
      if ( v5 < 0 )
        Com_Error(1, (char *)&byte_81500A0, s1, *a1);
      a1[31] = v5;
      break;
    case 10:
      v6 = sub_80F065E(s1, (int)off_8166568, 5);
      if ( v6 < 0 )
        Com_Error(1, (char *)&byte_81500E0, s1, *a1);
      a1[158] = v6;
      break;
    case 11:
      v7 = sub_80F065E(s1, (int)&off_8166550, 3);
      if ( v7 < 0 )
        Com_Error(1, (char *)&byte_8150120, s1, *a1);
      a1[32] = v7;
      break;
    case 12:
      v8 = sub_80F065E(s1, (int)off_81665A8, 3);
      if ( v8 < 0 )
        Com_Error(1, (char *)&byte_8150160, s1, *a1);
      a1[35] = v8;
      break;
    case 13:
      v9 = sub_80F065E(s1, (int)off_816655C, 3);
      if ( v9 < 0 )
        Com_Error(1, (char *)&byte_81501A0, s1, *a1);
      a1[228] = v9;
      break;
    case 14:
      v10 = sub_80F065E(s1, (int)off_81665B4, 3);
      if ( v10 < 0 )
        Com_Error(1, (char *)&byte_81501E0, s1, *a1);
      a1[33] = v10;
      break;
    case 15:
      v11 = sub_80F065E(s1, (int)&dword_8576FE0, dword_8576FC4);
      if ( v11 < 0 )
        Com_Error(1, (char *)&byte_8150220, s1, *a1);
      a1[29] = v11;
      break;
    default:
      Com_Error(1, (char *)&byte_8150246, a3, *a1);
  }
  return 1;
}
// 8166540: using guessed type char *off_8166540[15];
// 816655C: using guessed type char *off_816655C[8];
// 8166568: using guessed type char *off_8166568[5];
// 8166580: using guessed type char *off_8166580[17];
// 81665A8: using guessed type char *off_81665A8[7];
// 81665B4: using guessed type char *off_81665B4[4];

//----- (080F09D6) --------------------------------------------------------
int __cdecl sub_80F09D6(int *a1)
{
  int result; // eax

  if ( a1[176] <= 0 )
    a1[354] = 995783694;
  else
    *((float *)a1 + 354) = 1.0 / (long double)a1[176];
  if ( a1[177] <= 0 )
  {
    result = 990057071;
    a1[355] = 990057071;
  }
  else
  {
    result = (int)a1;
    *((float *)a1 + 355) = 1.0 / (long double)a1[177];
  }
  return result;
}

//----- (080F0A52) --------------------------------------------------------
void __cdecl sub_80F0A52(int a1)
{
  if ( *(float *)(a1 + 1432) <= 0.0 )
    *(_DWORD *)(a1 + 1432) = 1232348144;
  if ( *(float *)(a1 + 1436) <= 0.0 )
    *(_DWORD *)(a1 + 1436) = 1232348146;
}

//----- (080F0AA6) --------------------------------------------------------
void __cdecl sub_80F0AA6(int a1)
{
  if ( (long double)*(int *)(a1 + 900) <= 0.0 )
    Com_Error(1, "Projectile speed for WeapType %s must be greater than 0.0", *(const char **)(a1 + 4));
  if ( *(float *)(a1 + 1448) >= 45.0 || *(float *)(a1 + 1448) < 0.0 )
    Com_Error(
      1,
      "Destabilization angle for for WeapType %s must be between 0 and 45 degrees",
      *(const char **)(a1 + 4));
  if ( *(float *)(a1 + 1440) <= 0.0 )
    Com_Error(1, "Destabilization base time for for WeapType %s must be positive", *(const char **)(a1 + 4));
  if ( *(float *)(a1 + 1444) <= 0.0 )
    Com_Error(1, "Destabilization reduction ratio for for WeapType %s must be positive", *(const char **)(a1 + 4));
}

//----- (080F0B8E) --------------------------------------------------------
char *__cdecl sub_80F0B8E(char **a1, char *s)
{
  char *result; // eax
  size_t v3; // eax
  char *dest; // [esp+14h] [ebp-4h]

  if ( *s )
  {
    v3 = strlen(s);
    dest = (char *)Hunk_AllocLowAlignInternal(v3 + 1, 1);
    strcpy(dest, s);
    result = dest;
    *a1 = dest;
  }
  else
  {
    result = (char *)a1;
    *a1 = (char *)&unk_81503AC;
  }
  return result;
}

//----- (080F0BE2) --------------------------------------------------------
char *__cdecl sub_80F0BE2(char **a1, char *s)
{
  return sub_80F0B8E(a1, s);
}

//----- (080F0BFC) --------------------------------------------------------
char ***__cdecl sub_80F0BFC(char ***a1)
{
  char ***result; // eax
  char **v2; // [esp+0h] [ebp-8h] BYREF
  int v3; // [esp+4h] [ebp-4h]

  result = a1;
  *a1 = (char **)&unk_81503AC;
  v3 = 0;
  v2 = &off_81665C0;
  while ( v3 <= 365 )
  {
    if ( !v2[2] )
      *(_DWORD *)&v2[1][(_DWORD)a1] = &unk_81503AC;
    ++v3;
    result = &v2;
    v2 += 3;
  }
  return result;
}
// 81665C0: using guessed type char *off_81665C0;

//----- (080F0C4E) --------------------------------------------------------
int __cdecl BG_LoadWeaponDefInternal(const char *a1, char *a2)
{
  unsigned int n; // [esp+30h] [ebp-2068h]
  int v5; // [esp+38h] [ebp-2060h] BYREF
  int v6; // [esp+3Ch] [ebp-205Ch]
  char s1[8192]; // [esp+40h] [ebp-2058h] BYREF
  char src[76]; // [esp+2040h] [ebp-58h] BYREF
  int v9; // [esp+208Ch] [ebp-Ch]

  n = strlen("WEAPONFILE");
  v6 = (int)Hunk_AllocLowInternal(0x604u);
  sub_80F0BFC((char ***)v6);
  Com_sprintf(src, 0x40u, "weapons/%s/%s", a1, a2);
  v9 = FS_FOpenFileByMode(src, &v5, 0);
  if ( v9 >= 0 )
  {
    FS_Read((int)s1, n, v5);
    s1[n] = 0;
    if ( !strncmp(s1, "WEAPONFILE", n) )
    {
      if ( (int)(v9 - n) <= 0x1FFF )
      {
        memset(s1, 0, sizeof(s1));
        FS_Read((int)s1, v9 - n, v5);
        s1[v9 - n] = 0;
        FS_FCloseFile(v5);
        if ( sub_80B5FA4(s1) )
        {
          sub_80F0B8E((char **)v6, a2);
          if ( sub_80B645E(
                 v6,
                 (int)&off_81665C0,
                 366,
                 s1,
                 16,
                 (int (__cdecl *)(int, char *, _DWORD))sub_80F06B4,
                 (void (__cdecl *)(int, char *))sub_80F0BE2) )
          {
            sub_80F09D6((int *)v6);
            sub_80F0A52(v6);
            if ( *(float *)(v6 + 608) > 15000.0 )
              Com_Error(1, "Enemy crosshair ranges should be less than %f ", (double)15000.0);
            if ( *(_DWORD *)(v6 + 120) == 2 )
              sub_80F0AA6(v6);
            if ( (unsigned __int8)sub_80F1F7E(v6) )
            {
              I_strlwr(*(_BYTE **)(v6 + 452));
              I_strlwr(*(_BYTE **)(v6 + 460));
              return v6;
            }
            else
            {
              return 0;
            }
          }
          else
          {
            return 0;
          }
        }
        else
        {
          Com_Printf("^3WARNING: \"%s\" is not a valid weapon file\n", src);
          return 0;
        }
      }
      else
      {
        Com_Printf("^3WARNING: \"%s\" Is too long of a weapon file to parse\n", src);
        FS_FCloseFile(v5);
        return 0;
      }
    }
    else
    {
      Com_Printf("^3WARNING: \"%s\" does not appear to be a weapon file\n", src);
      FS_FCloseFile(v5);
      return 0;
    }
  }
  else
  {
    Com_Printf("^3WARNING: Could not load weapon file '%s'\n", src);
    return 0;
  }
}
// 81665C0: using guessed type char *off_81665C0;
// 80F0C4E: using guessed type const char *arg_0;
// 80F0C4E: using guessed type char s1[8192];

//----- (080F0F9E) --------------------------------------------------------
void *BG_LoadDefaultWeaponDef()
{
  sub_80F0BFC((char ***)&unk_85769C0);
  unk_85769C0 = "none";
  *((_DWORD *)&unk_85769C0 + 323) = "noweapon.accu";
  *((_DWORD *)&unk_85769C0 + 324) = "noweapon.accu";
  sub_80F1F7E((int)&unk_85769C0);
  return &unk_85769C0;
}

//----- (080F0FEC) --------------------------------------------------------
float *__usercall sub_80F0FEC@<eax>(
        long double a1@<st0>,
        float *a2,
        float *a3,
        float *a4,
        float *a5,
        float a6,
        float *a7)
{
  long double v7; // fst7
  long double v8; // fst7
  long double v9; // fst7
  long double v10; // fst7
  long double v11; // fst7
  float *result; // eax
  float v13; // [esp+10h] [ebp-18h] BYREF
  float v14; // [esp+14h] [ebp-14h]
  float v15; // [esp+18h] [ebp-10h]

  sub_80DEB7A(a2, a5, a6, &v13);
  sub_80F1750(*a2, v13);
  v7 = a1 + *a3;
  *a7 = v7;
  sub_80F1750(a2[1], v14);
  v8 = v7 + a3[1];
  a7[1] = v8;
  sub_80F1750(a2[2], v15);
  v9 = v8 + a3[2];
  a7[2] = v9;
  sub_80F172C(*a2, v13);
  v10 = v9 + *a4;
  a7[3] = v10;
  sub_80F172C(a2[1], v14);
  v11 = v10 + a4[1];
  a7[4] = v11;
  sub_80F172C(a2[2], v15);
  result = a4 + 2;
  a7[5] = v11 + a4[2];
  return result;
}

//----- (080F10F4) --------------------------------------------------------
int __usercall sub_80F10F4@<eax>(
        long double a1@<st0>,
        float *a2,
        float *a3,
        float *a4,
        float *a5,
        int a6,
        int a7,
        int a8,
        int a9)
{
  int result; // eax
  long double v10; // fst7
  float v11; // [esp+3Ch] [ebp-CCh]
  float v12; // [esp+3Ch] [ebp-CCh]
  float v13; // [esp+4Ch] [ebp-BCh]
  int v14; // [esp+50h] [ebp-B8h] BYREF
  float v15; // [esp+54h] [ebp-B4h]
  float v16; // [esp+58h] [ebp-B0h]
  float v17; // [esp+5Ch] [ebp-ACh]
  float v18; // [esp+60h] [ebp-A8h]
  float v19; // [esp+64h] [ebp-A4h]
  int v20; // [esp+78h] [ebp-90h]
  int v21; // [esp+7Ch] [ebp-8Ch]
  int v22[4]; // [esp+80h] [ebp-88h] BYREF
  float v23; // [esp+90h] [ebp-78h] BYREF
  float v24; // [esp+94h] [ebp-74h]
  float v25; // [esp+98h] [ebp-70h]
  float v26; // [esp+A0h] [ebp-68h] BYREF
  float v27; // [esp+A4h] [ebp-64h]
  float v28; // [esp+A8h] [ebp-60h]
  int v29; // [esp+B8h] [ebp-50h]
  int v30; // [esp+BCh] [ebp-4Ch]
  float s; // [esp+C0h] [ebp-48h] BYREF
  int v32; // [esp+C4h] [ebp-44h]
  int v33; // [esp+C8h] [ebp-40h]
  int v34; // [esp+CCh] [ebp-3Ch]
  int v35; // [esp+D0h] [ebp-38h]
  int v36; // [esp+D4h] [ebp-34h]
  int v37; // [esp+D8h] [ebp-30h]
  int v38; // [esp+DCh] [ebp-2Ch]
  int v39; // [esp+E0h] [ebp-28h]
  int v40; // [esp+F0h] [ebp-18h]
  int v41; // [esp+F4h] [ebp-14h]
  int v42; // [esp+F8h] [ebp-10h]
  int i; // [esp+FCh] [ebp-Ch]

  sub_80F0FEC(a1, a2, a3, a4, a5, *(float *)a9, (float *)&v14);
  for ( i = 0; ; ++i )
  {
    result = i;
    if ( i >= dword_85771F8 )
      break;
    v21 = dword_8577200[i];
    v30 = v21 + 240;
    if ( *(_DWORD *)(v21 + 240) == a6 )
      continue;
    if ( *(_DWORD *)(v30 + 156) == 0xFFFFFF )
    {
      v29 = *(_DWORD *)(v30 + 140);
      v20 = sub_805919A(v29);
      if ( (v20 & a7) == 0 )
        continue;
      v13 = sub_80591BC(v29);
      if ( *(float *)(v21 + 492) - v13 >= (long double)v17
        || *(float *)(v21 + 496) - v13 >= (long double)v18
        || *(float *)&v14 >= *(float *)(v21 + 492) + v13
        || v15 >= *(float *)(v21 + 496) + v13
        || *(float *)(v21 + 500) - v13 >= (long double)v19
        || v16 >= *(float *)(v21 + 500) + v13 )
      {
        continue;
      }
      sub_80F179E((_DWORD *)(v21 + 504), v22);
    }
    else
    {
      if ( *(_DWORD *)(v30 + 4) == 1 )
        v20 = 0x2000000;
      else
        v20 = 1;
      if ( (v20 & a7) == 0 )
        continue;
      v42 = *(unsigned __int8 *)(v30 + 156);
      v41 = (unsigned __int8)BYTE1(*(_DWORD *)(v30 + 156)) - 1;
      v40 = (unsigned __int8)BYTE2(*(_DWORD *)(v30 + 156)) - 32;
      v11 = 1.0 - (long double)v42;
      v27 = v11;
      v26 = v11;
      v12 = (long double)v42 - 1.0;
      v24 = v12;
      v23 = v12;
      v28 = 1.0 - (long double)v41;
      v25 = (long double)v40 - 1.0;
      if ( *(float *)(v21 + 492) + v26 >= (long double)v17
        || *(float *)(v21 + 496) + v27 >= (long double)v18
        || *(float *)&v14 >= *(float *)(v21 + 492) + v23
        || v15 >= *(float *)(v21 + 496) + v24
        || *(float *)(v21 + 500) + v28 >= (long double)v19
        || v16 >= *(float *)(v21 + 500) + v25 )
      {
        continue;
      }
      v29 = sub_80590DE(&v26, &v23, v20);
      sub_80F1774(v22);
    }
    sub_805B972(&s, (int)a2, (int)a5, (int)a3, (int)a4, v29, a7, (float *)(v21 + 492), (float *)v22);
    v10 = s;
    if ( *(float *)a9 <= (long double)s )
    {
      if ( BYTE2(v39) )
      {
        LOWORD(v38) = *(_WORD *)v30;
        *(float *)a9 = s;
        *(_DWORD *)(a9 + 4) = v32;
        *(_DWORD *)(a9 + 8) = v33;
        *(_DWORD *)(a9 + 12) = v34;
        *(_DWORD *)(a9 + 16) = v35;
        *(_DWORD *)(a9 + 20) = v36;
        *(_DWORD *)(a9 + 24) = v37;
        *(_DWORD *)(a9 + 28) = v38;
        *(_DWORD *)(a9 + 32) = v39;
      }
      else if ( HIBYTE(v39) )
      {
        *(_BYTE *)(a9 + 35) = 1;
      }
    }
    else
    {
      LOWORD(v38) = *(_WORD *)v30;
      *(float *)a9 = s;
      *(_DWORD *)(a9 + 4) = v32;
      *(_DWORD *)(a9 + 8) = v33;
      *(_DWORD *)(a9 + 12) = v34;
      *(_DWORD *)(a9 + 16) = v35;
      *(_DWORD *)(a9 + 20) = v36;
      *(_DWORD *)(a9 + 24) = v37;
      *(_DWORD *)(a9 + 28) = v38;
      *(_DWORD *)(a9 + 32) = v39;
      sub_80F0FEC(v10, a2, a3, a4, a5, s, (float *)&v14);
    }
    result = a9;
    if ( *(_BYTE *)(a9 + 34) )
      return result;
  }
  return result;
}
// 85771F8: using guessed type int dword_85771F8;
// 8577200: using guessed type int dword_8577200[520];

//----- (080F15AA) --------------------------------------------------------
void __cdecl sub_80F15AA(float *s, float *a2, float *a3, float *a4, float *a5, int a6, int a7)
{
  __int16 v7; // [esp+22h] [ebp-6h]

  CM_BoxTrace(s, a2, a5, (int)a3, (int)a4, 0, a7);
  if ( *s == 1.0 )
    v7 = 1023;
  else
    v7 = 1022;
  *((_WORD *)s + 14) = v7;
  if ( *s != 0.0 )
    sub_80F10F4(0.0, a2, a3, a4, a5, a6, a7, 1, (int)s);
}

//----- (080F166C) --------------------------------------------------------
int __cdecl sub_80F166C(float *a1, int a2, int a3)
{
  int v4; // [esp+14h] [ebp-14h]
  int v5; // [esp+18h] [ebp-10h]
  int v6; // [esp+1Ch] [ebp-Ch]
  int i; // [esp+24h] [ebp-4h]

  v4 = sub_8058D88(a1, 0);
  for ( i = 0; i < dword_85771F8; ++i )
  {
    v6 = dword_8577200[i];
    if ( *(_DWORD *)(v6 + 240) != a2 && *(_DWORD *)(v6 + 396) == 0xFFFFFF )
    {
      v5 = *(_DWORD *)(v6 + 380);
      if ( v5 )
        v4 |= sub_8058E94(a1, v5, (float *)(v6 + 492), (float *)(v6 + 504));
    }
  }
  return v4 & a3;
}
// 85771F8: using guessed type int dword_85771F8;
// 8577200: using guessed type int dword_8577200[520];

//----- (080F172C) --------------------------------------------------------
void __cdecl sub_80F172C(float a1, float a2)
{
  float v2; // [esp+0h] [ebp-18h]

  v2 = a1 - a2;
  sub_80F17CE(v2, a1, a2);
}

//----- (080F1750) --------------------------------------------------------
void __cdecl sub_80F1750(float a1, float a2)
{
  float v2; // [esp+0h] [ebp-18h]

  v2 = a2 - a1;
  sub_80F17CE(v2, a1, a2);
}

//----- (080F1774) --------------------------------------------------------
int __cdecl sub_80F1774(_DWORD *a1)
{
  int result; // eax

  *a1 = 0;
  a1[1] = 0;
  result = 0;
  a1[2] = 0;
  return result;
}

//----- (080F179E) --------------------------------------------------------
int __cdecl sub_80F179E(_DWORD *a1, _DWORD *a2)
{
  int result; // eax

  *a2 = *a1;
  a2[1] = a1[1];
  result = a1[2];
  a2[2] = result;
  return result;
}

//----- (080F17CE) --------------------------------------------------------
long double __cdecl sub_80F17CE(float a1, float a2, float a3)
{
  if ( a1 < 0.0 )
    return a3;
  return a2;
}

//----- (080F17F8) --------------------------------------------------------
void *__cdecl sub_80F17F8(char *s, int a2)
{
  void *dest; // [esp+10h] [ebp-8h]
  size_t v4; // [esp+14h] [ebp-4h]

  v4 = strlen(s);
  if ( (int)(*(_DWORD *)(a2 + 520) + v4 + 1) > 2048 )
    Com_Error(1, (char *)&byte_8150540);
  dest = (void *)(a2 + *(_DWORD *)(a2 + 520) + 524);
  memcpy(dest, s, v4 + 1);
  *(_DWORD *)(a2 + 520) += v4 + 1;
  return dest;
}

//----- (080F187E) --------------------------------------------------------
int __cdecl G_ParseSpawnVars(int a1)
{
  int v1; // ebx
  int v2; // ebx
  char dest[1024]; // [esp+20h] [ebp-808h] BYREF
  char s[1032]; // [esp+420h] [ebp-408h] BYREF

  *(_BYTE *)a1 = 0;
  *(_DWORD *)(a1 + 4) = 0;
  *(_DWORD *)(a1 + 520) = 0;
  if ( !sub_8090AAA(dest, 1024) )
    return 0;
  if ( dest[0] != 123 )
    Com_Error(1, (char *)&byte_8150580, dest);
  while ( 1 )
  {
    if ( !sub_8090AAA(s, 1024) )
      Com_Error(1, (char *)&byte_81505C0);
    if ( s[0] == 125 )
      break;
    if ( !sub_8090AAA(dest, 1024) )
      Com_Error(1, (char *)&byte_81505C0);
    if ( dest[0] == 125 )
      Com_Error(1, (char *)&byte_8150600);
    if ( *(_DWORD *)(a1 + 4) == 64 )
      Com_Error(1, (char *)&byte_8150640);
    v1 = *(_DWORD *)(a1 + 4);
    *(_DWORD *)(a1 + 8 * v1 + 8) = sub_80F17F8(s, a1);
    v2 = *(_DWORD *)(a1 + 4);
    *(_DWORD *)(a1 + 8 * v2 + 12) = sub_80F17F8(dest, a1);
    ++*(_DWORD *)(a1 + 4);
  }
  *(_BYTE *)a1 = 1;
  return 1;
}

//----- (080F1A0A) --------------------------------------------------------
int __cdecl G_SpawnStringInternal(int a1, char *s1, int a3, _DWORD *a4)
{
  int i; // [esp+14h] [ebp-4h]

  for ( i = 0; i < *(_DWORD *)(a1 + 4); ++i )
  {
    if ( !strcmp(s1, *(const char **)(a1 + 8 * i + 8)) )
    {
      *a4 = *(_DWORD *)(a1 + 8 * i + 12);
      return 1;
    }
  }
  *a4 = a3;
  return 0;
}

//----- (080F1A74) --------------------------------------------------------
int __cdecl G_NewString(char *s)
{
  size_t v2; // [esp+14h] [ebp-4014h]
  signed int i; // [esp+18h] [ebp-4010h]
  char *v4; // [esp+1Ch] [ebp-400Ch]
  char v5[16392]; // [esp+20h] [ebp-4008h] BYREF

  v2 = strlen(s) + 1;
  if ( v2 > 0x4000 )
    Com_Error(1, (char *)&byte_8150662, v2, 0x4000);
  v4 = v5;
  for ( i = 0; i < (int)v2; ++i )
  {
    if ( s[i] == 92 && i < (int)(v2 - 1) )
    {
      if ( s[++i] == 110 )
        *v4 = 10;
      else
        *v4 = 92;
      ++v4;
    }
    else
    {
      *v4++ = s[i];
    }
  }
  return sub_80792C4(v5, 0);
}

//----- (080F1B86) --------------------------------------------------------
char *__cdecl vtos(float *a1)
{
  char *s; // [esp+24h] [ebp-4h]

  s = (char *)&unk_8577A40 + 32 * dword_8577A20;
  dword_8577A20 = ((_BYTE)dword_8577A20 + 1) & 7;
  Com_sprintf(s, 0x20u, "(%i %i %i)", (int)*a1, (int)a1[1], (int)a1[2]);
  return s;
}
// 8577A20: using guessed type int dword_8577A20;

//----- (080F1C24) --------------------------------------------------------
int __cdecl sub_80F1C24(char *a1, char *src, int a3, int *a4)
{
  int v4; // eax
  int v5; // ebx
  float *v6; // ebx
  int v9; // [esp+18h] [ebp-10h]
  const char *nptrb; // [esp+1Ch] [ebp-Ch]
  char *nptr; // [esp+1Ch] [ebp-Ch]
  char *nptra; // [esp+1Ch] [ebp-Ch]

  Com_BeginParseSession(src);
  nptrb = Com_Parse(&a1);
  v4 = atoi(nptrb);
  *a4 = v4;
  v9 = 0;
  while ( 1 )
  {
    nptr = Com_Parse(&a1);
    if ( !*nptr )
      break;
    if ( *nptr == 125 )
      break;
    v5 = a3;
    *(float *)(v5 + 8 * v9) = atof(nptr);
    nptra = Com_Parse(&a1);
    if ( !*nptra || *nptra == 125 )
      break;
    v6 = (float *)(a3 + 8 * v9 + 4);
    *v6 = atof(nptra);
    if ( ++v9 > 15 )
    {
      Com_Printf("^3WARNING: \"%s\" has too many graph knots\n", src);
      Com_EndParseSession();
      return 0;
    }
  }
  Com_EndParseSession();
  if ( v9 == *a4 )
    return 1;
  Com_Printf("^3WARNING: \"%s\" Error in parsing an ai weapon accuracy file\n", src);
  return 0;
}

//----- (080F1D3A) --------------------------------------------------------
int __cdecl G_ParseWeaponAccurayGraphs(int a1, const char *a2, const char *a3, int a4, int *a5)
{
  int v7; // [esp+14h] [ebp-2064h] BYREF
  size_t n; // [esp+18h] [ebp-2060h]
  char *s; // [esp+1Ch] [ebp-205Ch]
  char s1[8192]; // [esp+20h] [ebp-2058h] BYREF
  char src[72]; // [esp+2020h] [ebp-58h] BYREF
  int v12; // [esp+2068h] [ebp-10h] BYREF
  int v13; // [esp+206Ch] [ebp-Ch]

  s = "WEAPONACCUFILE";
  n = strlen("WEAPONACCUFILE");
  if ( *(_DWORD *)(a1 + 120) && *(_DWORD *)(a1 + 120) != 2 )
    return 1;
  if ( !*a3 )
    return 1;
  sprintf(src, "accuracy/%s/%s", a2, a3);
  v13 = FS_FOpenFileByMode(src, &v12, 0);
  if ( v13 >= 0 )
  {
    FS_Read((int)s1, n, v12);
    s1[n] = 0;
    if ( !strncmp(s1, s, n) )
    {
      if ( (int)(v13 - n) <= 0x1FFF )
      {
        memset(s1, 0, sizeof(s1));
        FS_Read((int)s1, v13 - n, v12);
        s1[v13 - n] = 0;
        FS_FCloseFile(v12);
        v7 = 0;
        if ( (unsigned __int8)sub_80F1C24(s1, src, a4, &v7) )
        {
          *a5 = v7;
          return 1;
        }
        else
        {
          return 0;
        }
      }
      else
      {
        Com_Printf("^3WARNING: \"%s\" Is too long of an ai weapon accuracy file to parse\n", src);
        FS_FCloseFile(v12);
        return 0;
      }
    }
    else
    {
      Com_Printf("^3WARNING: \"%s\" does not appear to be an ai weapon accuracy file\n", src);
      FS_FCloseFile(v12);
      return 0;
    }
  }
  else
  {
    Com_Printf("^3WARNING: Could not load ai weapon accuracy file '%s'\n", src);
    return 0;
  }
}
// 80F1D3A: using guessed type char s1[8192];

//----- (080F1F7E) --------------------------------------------------------
int __cdecl sub_80F1F7E(int a1)
{
  int i; // [esp+24h] [ebp-94h]
  int n; // [esp+28h] [ebp-90h]
  int v5; // [esp+2Ch] [ebp-8Ch] BYREF
  char s[136]; // [esp+30h] [ebp-88h] BYREF

  for ( i = 0; i <= 1; ++i )
  {
    memset(s, 0, 0x80u);
    v5 = 0;
    if ( !(unsigned __int8)G_ParseWeaponAccurayGraphs(a1, off_81676E8[i], *(const char **)(a1 + 4 * i + 1292), (int)s, &v5) )
      return 0;
    if ( v5 > 0 )
    {
      n = 8 * v5;
      *(_DWORD *)(a1 + 4 * i + 1300) = Hunk_AllocLowAlignInternal(8 * v5, 4);
      memcpy(*(void **)(a1 + 4 * i + 1300), s, n);
      *(_DWORD *)(a1 + 4 * i + 1308) = v5;
    }
  }
  return 1;
}
// 81676E8: using guessed type char *off_81676E8[2];

//----- (080F20C8) --------------------------------------------------------
int __cdecl sub_80F20C8(int a1)
{
  int result; // eax
  int v2; // ebx
  int v3; // ebx
  long double v4; // fst7
  float v5; // [esp+28h] [ebp-70h]
  float v6[3]; // [esp+30h] [ebp-68h] BYREF
  float v7; // [esp+3Ch] [ebp-5Ch] BYREF
  float v8; // [esp+6Ch] [ebp-2Ch]
  float v9[6]; // [esp+70h] [ebp-28h] BYREF
  int v10; // [esp+88h] [ebp-10h]
  int v11; // [esp+8Ch] [ebp-Ch]

  v11 = *(_DWORD *)(a1 + 344);
  result = v11;
  if ( *(int *)(v11 + 4) <= 5 )
  {
    *(_DWORD *)(v11 + 296) = 0;
    result = *(_DWORD *)(v11 + 10208);
    v10 = result;
    if ( result > 0 )
    {
      result = v11;
      if ( *(int *)(v11 + 10024) > 0 )
      {
        v10 = 100 * v10 / *(_DWORD *)(v11 + 10024);
        if ( v10 > 127 )
          v10 = 127;
        *(float *)(v11 + 1492) = (long double)v10 + *(float *)(v11 + 1492);
        if ( *(float *)(v11 + 1492) > 255.0 )
          *(_DWORD *)(v11 + 1492) = 1132396544;
        v8 = (long double)v10 * 0.2;
        if ( v8 >= 5.0 )
        {
          if ( v8 > 90.0 )
            v8 = 90.0;
        }
        else
        {
          v8 = 5.0;
        }
        if ( *(_DWORD *)(v11 + 10224) )
        {
          *(_DWORD *)(v11 + 10308) = 0;
          *(_DWORD *)(v11 + 10312) = LODWORD(v8) ^ 0x80000000;
          *(_DWORD *)(v11 + 292) = 255;
          *(_DWORD *)(v11 + 288) = 255;
          *(_DWORD *)(v11 + 10224) = 0;
        }
        else
        {
          vectoangles((float *)(v11 + 10212), (int)v9);
          sub_80A7146((float *)(v11 + 232), (int)v6);
          v2 = v11;
          LODWORD(v5) = LODWORD(v8) ^ 0x80000000;
          *(float *)(v2 + 10308) = sub_80F55E2((float *)(v11 + 10212), &v7) * v5;
          v3 = v11;
          v4 = sub_80F55E2((float *)(v11 + 10212), v6);
          *(float *)(v3 + 10312) = v4 * v8;
          *(_DWORD *)(v11 + 292) = (int)(v9[0] / 360.0 * 256.0);
          *(_DWORD *)(v11 + 288) = (int)(v9[1] / 360.0 * 256.0);
        }
        ++*(_DWORD *)(v11 + 284);
        *(_DWORD *)(v11 + 10304) = dword_859B5EC - 20;
        *(_DWORD *)(v11 + 296) = v10;
        result = v11;
        *(_DWORD *)(v11 + 10208) = 0;
      }
    }
  }
  return result;
}
// 80F20C8: using guessed type float var_68[3];

//----- (080F2350) --------------------------------------------------------
int __cdecl sub_80F2350(int a1)
{
  int result; // eax

  result = a1;
  *(_DWORD *)(a1 + 132) = 0;
  return result;
}

//----- (080F2362) --------------------------------------------------------
int __cdecl sub_80F2362(int a1, int a2)
{
  int result; // eax
  void (__cdecl *v3)(int *, int, int); // [esp+10h] [ebp-18h]
  void (__cdecl *v4)(int, int *, int); // [esp+14h] [ebp-14h]
  int *v5; // [esp+18h] [ebp-10h]
  int j; // [esp+1Ch] [ebp-Ch]
  int i; // [esp+20h] [ebp-8h]

  v4 = (void (__cdecl *)(int, int *, int))dword_816788C[10 * *(unsigned __int8 *)(a1 + 358)];
  for ( i = 0; ; ++i )
  {
    result = i;
    if ( i >= *(_DWORD *)(a2 + 64) )
      break;
    for ( j = 0; j < i && *(_DWORD *)(a2 + 4 * j + 68) != *(_DWORD *)(a2 + 4 * i + 68); ++j )
      ;
    if ( j == i )
    {
      v5 = (int *)((char *)&unk_8665480 + 560 * *(_DWORD *)(a2 + 4 * i + 68));
      if ( Scr_IsSystemActive() )
      {
        Scr_AddEntity(v5);
        Scr_Notify((int *)a1, word_87A22F2, 1);
        Scr_AddEntity((int *)a1);
        Scr_Notify(v5, word_87A22F2, 1);
      }
      v3 = (void (__cdecl *)(int *, int, int))dword_816788C[10 * *((unsigned __int8 *)v5 + 358)];
      if ( v3 )
        v3(v5, a1, 1);
      if ( v4 )
        v4(a1, v5, 1);
    }
  }
  return result;
}
// 816788C: using guessed type int dword_816788C[];
// 87A22F2: using guessed type __int16 word_87A22F2;

//----- (080F24C6) --------------------------------------------------------
int __cdecl sub_80F24C6(int a1)
{
  int result; // eax
  void (__cdecl *v2)(int *, int, int); // [esp+28h] [ebp-1050h]
  int v3; // [esp+2Ch] [ebp-104Ch]
  float v4[4]; // [esp+30h] [ebp-1048h] BYREF
  float v5[7]; // [esp+40h] [ebp-1038h] BYREF
  int *v6; // [esp+5Ch] [ebp-101Ch]
  int v7[1026]; // [esp+60h] [ebp-1018h] BYREF
  int v8; // [esp+1068h] [ebp-10h]
  int i; // [esp+106Ch] [ebp-Ch]

  result = *(_DWORD *)(a1 + 344);
  if ( *(int *)(result + 4) <= 1 )
  {
    sub_80F559E((float *)(*(_DWORD *)(a1 + 344) + 20), flt_81676F4, v5);
    sub_80F555A((float *)(*(_DWORD *)(a1 + 344) + 20), flt_81676F4, v4);
    v8 = sub_805E782((int)v5, (int)v4, (int)v7, 1024, 1079771144);
    sub_80F555A((float *)(*(_DWORD *)(a1 + 344) + 20), (float *)(a1 + 260), v5);
    sub_80F555A((float *)(*(_DWORD *)(a1 + 344) + 20), (float *)(a1 + 272), v4);
    sub_80A64CE(v5, v4);
    v3 = dword_816788C[10 * *(unsigned __int8 *)(a1 + 358)];
    for ( i = 0; ; ++i )
    {
      result = i;
      if ( i >= v8 )
        return result;
      v6 = (int *)((char *)&unk_8665480 + 560 * v7[i]);
      v2 = (void (__cdecl *)(int *, int, int))dword_816788C[10 * *((unsigned __int8 *)v6 + 358)];
      if ( v2 || v3 )
      {
        if ( v6[1] == 3 )
        {
          if ( !sub_80DCBB6(*(float **)(a1 + 344), (int)v6, dword_859B5EC) )
            continue;
        }
        else if ( !sub_80901C2(v5, v4, (int)v6) )
        {
          continue;
        }
        if ( Scr_IsSystemActive() )
        {
          Scr_AddEntity((int *)a1);
          Scr_Notify(v6, word_87A22F2, 1);
          Scr_AddEntity(v6);
          Scr_Notify((int *)a1, word_87A22F2, 1);
        }
        if ( v2 )
          v2(v6, a1, 1);
      }
    }
  }
  return result;
}
// 81676F4: using guessed type float flt_81676F4[3];
// 816788C: using guessed type int dword_816788C[];
// 87A22F2: using guessed type __int16 word_87A22F2;
// 80F24C6: using guessed type float var_1038[7];
// 80F24C6: using guessed type float var_1048[4];
// 80F24C6: using guessed type int var_1018[1026];

//----- (080F275E) --------------------------------------------------------
int __cdecl sub_80F275E(int a1, int **a2)
{
  int result; // eax
  int *v3; // [esp+1Ch] [ebp-10Ch]
  int *s[57]; // [esp+20h] [ebp-108h] BYREF
  char v5; // [esp+104h] [ebp-24h]

  v3 = *(int **)(a1 + 344);
  v3[2544] = v3[2543];
  v3[2543] = v3[2483];
  v3[2546] |= v3[2543] & ~v3[2544];
  if ( v3[2475] < 0 && sub_80F467C((int)v3, 4) && v3[2538] >= 0 && (v3[2543] & 4) != (v3[2544] & 4) )
    sub_80FCAE6((char *)a1);
  if ( (v3[2543] & 1) != 0 && ((*((_BYTE *)v3 + 10176) ^ 1) & 1) != 0 )
  {
    sub_80FCD40(a1, 1);
  }
  else if ( (v3[2543] & 0x1000) != 0 && (v3[2544] & 0x1000) == 0 )
  {
    sub_80FCD40(a1, -1);
  }
  result = v3[3] & 0x400000;
  if ( !result )
  {
    v3[1] = 4;
    if ( sub_80F467C((int)v3, 4) )
      v3[20] = 400;
    else
      v3[20] = 0;
    memset(s, 0, 0xF8u);
    s[0] = v3;
    s[1] = *a2;
    s[2] = a2[1];
    s[3] = a2[2];
    s[4] = a2[3];
    s[5] = a2[4];
    s[6] = a2[5];
    s[7] = a2[6];
    s[15] = (int *)8390673;
    v5 = 1;
    sub_80E6D30(s);
    sub_80F552A(v3 + 5, (_DWORD *)(a1 + 312));
    return SV_UnlinkEntity(a1);
  }
  return result;
}

//----- (080F29CA) --------------------------------------------------------
int __usercall sub_80F29CA@<eax>(long double a1@<st0>, int a2)
{
  char *v2; // eax

  if ( !*(_DWORD *)(g_inactivity + 8) )
  {
    *(_DWORD *)(a2 + 10240) = dword_859B5EC + 60000;
    *(_DWORD *)(a2 + 10244) = 0;
    return 1;
  }
  if ( *(_BYTE *)(a2 + 9952) || *(_BYTE *)(a2 + 9953) || (*(_DWORD *)(a2 + 9932) & 0x401) != 0 )
  {
    *(_DWORD *)(a2 + 10240) = dword_859B5EC + 1000 * *(_DWORD *)(g_inactivity + 8);
    *(_DWORD *)(a2 + 10244) = 0;
    return 1;
  }
  if ( *(_DWORD *)(a2 + 9984) )
    return 1;
  if ( dword_859B5EC <= *(_DWORD *)(a2 + 10240) )
  {
    if ( dword_859B5EC > *(_DWORD *)(a2 + 10240) - 10000 && !*(_DWORD *)(a2 + 10244) )
    {
      *(_DWORD *)(a2 + 10244) = 1;
      v2 = va("%c \"GAME_INACTIVEDROPWARNING\"", 99);
      SV_GameSendServerCommand(1682649625 * ((a2 - dword_859B400) >> 2), 0, v2);
    }
    return 1;
  }
  sub_808FF0A(a1, 1682649625 * ((a2 - dword_859B400) >> 2), "GAME_DROPPEDFORINACTIVITY");
  return 0;
}
// 859B400: using guessed type int dword_859B400;
// 8793DA8: using guessed type int g_inactivity;

//----- (080F2B22) --------------------------------------------------------
int __cdecl sub_80F2B22(int a1)
{
  int result; // eax
  _DWORD *v2; // [esp+0h] [ebp-8h]

  v2 = *(_DWORD **)(a1 + 344);
  v2[2544] = v2[2543];
  v2[2543] = v2[2483];
  result = v2[2546] | v2[2543] & ~v2[2544];
  v2[2546] = result;
  return result;
}

//----- (080F2B86) --------------------------------------------------------
int __cdecl sub_80F2B86(int *a1, int a2)
{
  int result; // eax
  int v3; // edx
  int v4[7]; // [esp+40h] [ebp-38h] BYREF
  float v5; // [esp+5Ch] [ebp-1Ch]
  _DWORD *v6; // [esp+60h] [ebp-18h]
  int v7; // [esp+64h] [ebp-14h]
  int v8; // [esp+68h] [ebp-10h]
  int i; // [esp+6Ch] [ebp-Ch]

  v6 = (_DWORD *)a1[86];
  if ( a2 < v6[41] - 4 )
    a2 = v6[41] - 4;
  for ( i = a2; ; ++i )
  {
    result = i;
    if ( i >= v6[41] )
      break;
    v8 = v6[(i & 3) + 42];
    v7 = v6[(i & 3) + 46];
    if ( v8 <= 115 || v8 > 138 )
    {
      switch ( v8 )
      {
        case 158:
        case 159:
        case 160:
        case 175:
          if ( *(_BYTE *)(g_antilag + 8) )
            sub_811E3E0((int)a1, v6[2599]);
          else
            sub_811E3E0((int)a1, dword_859B5EC);
          break;
        case 164:
          sub_811E5E0((int)a1);
          break;
        case 166:
          sub_811E586(a1);
          break;
        case 168:
          Scr_Notify(a1, word_87A2302, 0);
          break;
        case 169:
          Scr_Notify(a1, word_87A2304, 0);
          break;
        case 170:
          Scr_Notify(a1, word_87A2306, 0);
          break;
        case 171:
          Scr_Notify(a1, word_87A2308, 0);
          break;
        case 172:
          Scr_Notify(a1, word_87A230A, 0);
          break;
        case 197:
          if ( a1[86] && (a1[93] & 3) == 0 )
          {
            v3 = a1[86];
            a1[101] = 0;
            *(_DWORD *)(v3 + 300) = 0;
            sub_80FF2CA((int)a1, a1, a1, 100000, 0xCu, 0, 0, 0, 0);
          }
          break;
        default:
          continue;
      }
    }
    else
    {
      result = (int)a1;
      if ( a1[1] != 1 )
        return result;
      if ( v7 <= 99 )
        v5 = (long double)v7 * 0.0099999998;
      else
        v5 = 1.1;
      if ( v5 != 0.0 )
      {
        v5 = (long double)(int)v6[77] * v5;
        sub_80F5506(v4, 0, 0, 1065353216);
        sub_80FF7C8(a1, 0, 0, 0, 0, (int)v5, 0, 0xBu, 0, 0);
      }
    }
  }
  return result;
}
// 8793E4C: using guessed type int g_antilag;
// 87A2302: using guessed type __int16 word_87A2302;
// 87A2304: using guessed type __int16 word_87A2304;
// 87A2306: using guessed type __int16 word_87A2306;
// 87A2308: using guessed type __int16 word_87A2308;
// 87A230A: using guessed type __int16 word_87A230A;
// 80F2B86: using guessed type int var_38[7];

//----- (080F2EC0) --------------------------------------------------------
int __cdecl sub_80F2EC0(int a1, int a2)
{
  int result; // eax
  char *v3; // [esp+0h] [ebp-4h]

  v3 = (char *)&unk_8665480 + 560 * a1;
  if ( dword_859B5EC - a2 > 1000 )
    a2 = dword_859B5EC - 1000;
  if ( a2 >= *(_DWORD *)(*((_DWORD *)v3 + 86) + 10396) || (result = dword_859B5EC, dword_859B5EC <= a2) )
  {
    result = a2;
    *(_DWORD *)(*((_DWORD *)v3 + 86) + 10396) = a2;
  }
  return result;
}

//----- (080F2F2E) --------------------------------------------------------
int __cdecl sub_80F2F2E(int a1)
{
  int result; // eax

  if ( *(_DWORD *)(*(_DWORD *)(a1 + 344) + 10156) )
  {
    result = a1;
    *(_DWORD *)(a1 + 284) = 0;
  }
  else if ( *(_DWORD *)(*(_DWORD *)(a1 + 344) + 10160) )
  {
    result = a1;
    *(_DWORD *)(a1 + 284) = 0;
  }
  else
  {
    result = a1;
    if ( *(_DWORD *)(*(_DWORD *)(a1 + 344) + 9896) == 1 )
      *(_DWORD *)(a1 + 284) = 0;
    else
      *(_DWORD *)(a1 + 284) = 0x2000000;
  }
  return result;
}

//----- (080F2FA4) --------------------------------------------------------
void __cdecl sub_80F2FA4(int a1, int a2, int a3, int a4)
{
  unsigned int v4; // edx
  unsigned int v5; // edx
  float v6; // [esp+14h] [ebp-14h]
  unsigned __int8 v7; // [esp+1Bh] [ebp-Dh]
  int j; // [esp+1Ch] [ebp-Ch]
  int i; // [esp+20h] [ebp-8h]

  *(_DWORD *)(a2 + 12) = 3;
  sub_80F552A((_DWORD *)(a1 + 20), (_DWORD *)(a2 + 24));
  sub_80F552A((_DWORD *)(a1 + 32), (_DWORD *)(a2 + 36));
  *(_DWORD *)(a2 + 16) = a3;
  *(_DWORD *)(a2 + 20) = 50;
  *(_DWORD *)(a2 + 48) = 1;
  sub_80F552A((_DWORD *)(a1 + 232), (_DWORD *)(a2 + 60));
  *(float *)(a2 + 108) = (float)*(int *)(a1 + 156);
  *(_DWORD *)(a2 + 8) = *(_DWORD *)(a1 + 160);
  if ( *(_DWORD *)(a1 + 1484) - *(_DWORD *)(a1 + 164) >= 0 )
  {
    *(_DWORD *)(a2 + 160) = 0;
  }
  else
  {
    if ( *(_DWORD *)(a1 + 164) - *(_DWORD *)(a1 + 1484) > 4 )
      *(_DWORD *)(a1 + 1484) = *(_DWORD *)(a1 + 164) - 4;
    *(_DWORD *)(a2 + 160) = *(unsigned __int8 *)(a1 + 4 * ((*(_DWORD *)(a1 + 1484))++ & 3) + 184);
  }
  if ( *(_DWORD *)(a1 + 200) - *(_DWORD *)(a1 + 164) > 0 )
    *(_DWORD *)(a1 + 200) = *(_DWORD *)(a1 + 164);
  for ( i = *(_DWORD *)(a1 + 200); i != *(_DWORD *)(a1 + 164); ++i )
  {
    v7 = *(_BYTE *)(a1 + 4 * (i & 3) + 168);
    sub_80F53E0(*(_DWORD *)a2, v7);
    for ( j = 0; dword_814D70C[j] > 0 && dword_814D70C[j] != v7; ++j )
      ;
    if ( dword_814D70C[j] < 0 )
    {
      *(_DWORD *)(a2 + 4 * (*(_DWORD *)(a2 + 164) & 3) + 168) = v7;
      *(_DWORD *)(a2 + 4 * ((*(_DWORD *)(a2 + 164))++ & 3) + 184) = *(unsigned __int8 *)(a1 + 4 * (i & 3) + 184);
    }
  }
  *(_DWORD *)(a1 + 200) = *(_DWORD *)(a1 + 164);
  *(_DWORD *)(a2 + 200) = *(unsigned __int8 *)(a1 + 212);
  *(_DWORD *)(a2 + 124) = *(unsigned __int16 *)(a1 + 96);
  if ( (*(_DWORD *)(a1 + 12) & 0xC00000) != 0 )
    *(_DWORD *)(a2 + 4) = 1;
  else
    *(_DWORD *)(a2 + 4) = 5;
  if ( a4 )
  {
    *(float *)(a2 + 24) = (float)(int)*(float *)(a2 + 24);
    *(float *)(a2 + 28) = (float)(int)*(float *)(a2 + 28);
    *(float *)(a2 + 32) = (float)(int)*(float *)(a2 + 32);
    *(float *)(a2 + 60) = (float)(int)*(float *)(a2 + 60);
    *(float *)(a2 + 64) = (float)(int)*(float *)(a2 + 64);
    *(float *)(a2 + 68) = (float)(int)*(float *)(a2 + 68);
  }
  *(_DWORD *)(a2 + 204) = *(_DWORD *)(a1 + 124);
  *(_DWORD *)(a2 + 208) = *(_DWORD *)(a1 + 132);
  *(_DWORD *)(a2 + 144) = *(_DWORD *)(a1 + 204);
  if ( (*(_DWORD *)(a1 + 160) & 0x300) != 0 )
    *(_DWORD *)(a2 + 116) = *(_DWORD *)(a1 + 1428);
  if ( *(int *)(a1 + 4) <= 5 )
    v4 = *(_DWORD *)(a2 + 8) & 0xFFFDFFFF;
  else
    v4 = *(_DWORD *)(a2 + 8) | 0x20000;
  *(_DWORD *)(a2 + 8) = v4;
  if ( (*(_DWORD *)(a1 + 12) & 0x40) != 0 )
    v5 = *(_DWORD *)(a2 + 8) | 0x40000;
  else
    v5 = *(_DWORD *)(a2 + 8) & 0xFFFBFFFF;
  *(_DWORD *)(a2 + 8) = v5;
  *(_DWORD *)(a2 + 212) = *(_DWORD *)(a1 + 76);
  if ( PM_GetEffectiveStance(a1) == 1 )
  {
    v6 = (long double)(*(_DWORD *)a1 - *(_DWORD *)(a1 + 252))
       / (long double)sub_80E1522(a1, *(_DWORD *)(a1 + 256), *(_DWORD *)(a1 + 260));
    if ( v6 >= 0.0 )
    {
      if ( v6 > 1.0 )
        v6 = 1.0;
    }
    else
    {
      v6 = 0.0;
    }
    if ( !*(_DWORD *)(a1 + 260) )
      v6 = 1.0 - v6;
    *(float *)(a2 + 228) = *(float *)(a1 + 1448) * v6;
    *(float *)(a2 + 232) = sub_80A6112(*(float *)(a1 + 1452)) * v6;
    *(float *)(a2 + 236) = sub_80A6112(*(float *)(a1 + 1456)) * v6;
  }
  else
  {
    *(_DWORD *)(a2 + 228) = 0;
    *(_DWORD *)(a2 + 232) = 0;
    *(_DWORD *)(a2 + 236) = 0;
  }
}
// 814D70C: using guessed type int dword_814D70C[7];

//----- (080F34E0) --------------------------------------------------------
int __cdecl sub_80F34E0(_DWORD *a1, int a2, int a3)
{
  int result; // eax
  char *v4; // [esp+10h] [ebp-8h]
  int v5; // [esp+14h] [ebp-4h]

  v4 = (char *)&unk_8665480 + 560 * *(_DWORD *)(*(_DWORD *)a3 + 204);
  v5 = G_Spawn();
  *(_DWORD *)(v5 + 396) = v4;
  *(_DWORD *)(v5 + 336) = *(_DWORD *)(*(_DWORD *)a3 + 204);
  *(_DWORD *)(v5 + 284) = 0x10000;
  *(_DWORD *)(v5 + 388) = 0x10000;
  *(_BYTE *)(v5 + 242) = 33;
  *(_DWORD *)(v5 + 4) = 5;
  *(_BYTE *)(v5 + 358) = 19;
  sub_80F552A((_DWORD *)v4 + 65, (_DWORD *)(v5 + 260));
  sub_80F552A((_DWORD *)v4 + 68, (_DWORD *)(v5 + 272));
  sub_811CF36((_DWORD *)v5, a1);
  SV_LinkEntity(v5);
  result = *(_DWORD *)(g_mantleBlockTimeBuffer + 8) + dword_859B5EC + a2;
  *(_DWORD *)(v5 + 400) = result;
  return result;
}
// 8793DD8: using guessed type int g_mantleBlockTimeBuffer;

//----- (080F35DA) --------------------------------------------------------
int __usercall sub_80F35DA@<eax>(long double a1@<st0>, int *a2, int **a3)
{
  int result; // eax
  unsigned int v4; // edx
  float v5[12]; // [esp+20h] [ebp-278h] BYREF
  float v6[12]; // [esp+50h] [ebp-248h] BYREF
  float v7[12]; // [esp+80h] [ebp-218h] BYREF
  int v8; // [esp+B0h] [ebp-1E8h]
  float v9; // [esp+B4h] [ebp-1E4h]
  float v10; // [esp+B8h] [ebp-1E0h]
  int v11; // [esp+BCh] [ebp-1DCh]
  float v12[4]; // [esp+C0h] [ebp-1D8h] BYREF
  int v13[4]; // [esp+D0h] [ebp-1C8h] BYREF
  int v14[3]; // [esp+E0h] [ebp-1B8h] BYREF
  _DWORD v15[3]; // [esp+ECh] [ebp-1ACh] BYREF
  int v16; // [esp+F8h] [ebp-1A0h]
  int v17; // [esp+FCh] [ebp-19Ch]
  int v18; // [esp+100h] [ebp-198h]
  int v19; // [esp+104h] [ebp-194h]
  int v20; // [esp+108h] [ebp-190h]
  _DWORD v21[3]; // [esp+10Ch] [ebp-18Ch] BYREF
  _DWORD v22[3]; // [esp+118h] [ebp-180h] BYREF
  _DWORD v23[7]; // [esp+124h] [ebp-174h] BYREF
  int v24[2]; // [esp+140h] [ebp-158h] BYREF
  int v25; // [esp+148h] [ebp-150h]
  int v26; // [esp+14Ch] [ebp-14Ch]
  int v27; // [esp+150h] [ebp-148h]
  int v28; // [esp+154h] [ebp-144h]
  float v29; // [esp+158h] [ebp-140h]
  int v30; // [esp+15Ch] [ebp-13Ch]
  int v31; // [esp+160h] [ebp-138h]
  int v32; // [esp+178h] [ebp-120h]
  int v33; // [esp+17Ch] [ebp-11Ch]
  int *s[15]; // [esp+180h] [ebp-118h] BYREF
  int v35; // [esp+1BCh] [ebp-DCh]
  int v36[3]; // [esp+244h] [ebp-54h] BYREF
  int v37[5]; // [esp+250h] [ebp-48h] BYREF
  char v38; // [esp+264h] [ebp-34h]
  char v39; // [esp+265h] [ebp-33h]
  int v40[9]; // [esp+268h] [ebp-30h] BYREF
  int v41; // [esp+28Ch] [ebp-Ch]

  v41 = a2[86];
  result = v41;
  if ( *(_DWORD *)(v41 + 9924) == 2 )
  {
    if ( (int)*a3 > dword_859B5EC + 200 )
      *a3 = (int *)(dword_859B5EC + 200);
    if ( (int)*a3 < dword_859B5EC - 1000 )
      *a3 = (int *)(dword_859B5EC - 1000);
    v32 = (int)*a3 - *(_DWORD *)v41;
    if ( v32 > 0
      || (result = -1963413621 * (((char *)a2 - (char *)&unk_8665480) >> 4), *(_DWORD *)(v41 + 204) != result) )
    {
      if ( v32 > 200 )
        v32 = 200;
      if ( *(_DWORD *)(v41 + 10164) )
        v4 = *(_DWORD *)(v41 + 12) | 0x8000;
      else
        v4 = *(_DWORD *)(v41 + 12) & 0xFFFF7FFF;
      *(_DWORD *)(v41 + 12) = v4;
      if ( *(_DWORD *)(v41 + 9896) == 3 )
      {
        return sub_80F2B22((int)a2);
      }
      else if ( *(_DWORD *)(v41 + 9896) == 2 )
      {
        return sub_80F275E((int)a2, a3);
      }
      else
      {
        result = sub_80F29CA(a1, v41);
        if ( result )
        {
          v33 = *(_DWORD *)(v41 + 164);
          memset(s, 0, 0xF8u);
          s[0] = (int *)v41;
          s[1] = *a3;
          s[2] = a3[1];
          s[3] = a3[2];
          s[4] = a3[3];
          s[5] = a3[4];
          s[6] = a3[5];
          s[7] = a3[6];
          s[8] = *(int **)(v41 + 9956);
          s[9] = *(int **)(v41 + 9960);
          s[10] = *(int **)(v41 + 9964);
          s[11] = *(int **)(v41 + 9968);
          s[12] = *(int **)(v41 + 9972);
          s[13] = *(int **)(v41 + 9976);
          s[14] = *(int **)(v41 + 9980);
          if ( *(int *)(v41 + 4) <= 5 )
            v35 = 42008593;
          else
            v35 = 8454161;
          v38 = 1;
          sub_80F552A((_DWORD *)(v41 + 20), (_DWORD *)(v41 + 10188));
          *(_DWORD *)(v41 + 10176) = *(_DWORD *)(v41 + 10172);
          *(_DWORD *)(v41 + 10172) = *(_DWORD *)(v41 + 9932);
          *(_DWORD *)(v41 + 10180) = *(_DWORD *)(v41 + 10172) & ~*(_DWORD *)(v41 + 10176);
          *(_DWORD *)(v41 + 10184) |= *(_DWORD *)(v41 + 10180);
          v24[0] = v41;
          v24[1] = *(_DWORD *)(v41 + 10304);
          v25 = dword_859B5EC;
          v26 = *(_DWORD *)(v41 + 10312);
          v27 = *(_DWORD *)(v41 + 10308);
          *(float *)&v28 = sub_80E6DF4(a1, v41, dword_859B5EC);
          v29 = (long double)v32 * 0.001;
          v30 = *(_DWORD *)(v41 + 10364);
          v31 = v41 + 10392;
          sub_80EFD94((float *)v24, v12);
          sub_80F555A((float *)(v41 + 232), v12, (float *)v13);
          v11 = BG_WeaponDefs(*(_DWORD *)(v41 + 212));
          v8 = *(_DWORD *)(v41 + 1500) + *(_DWORD *)(v41 + 1504) - v25;
          if ( v8 <= 0 )
          {
            v9 = 1.0;
          }
          else
          {
            v10 = 1.0;
            if ( v8 <= 2999 )
              v10 = (long double)v8 / 3000.0;
            v10 = (3.0 - (v10 + v10)) * v10 * v10;
            v9 = (*(float *)(v11 + 768) - 1.0) * v10 + 1.0;
          }
          sub_80EFDF0(v41, (float *)(v41 + 10316), v41 + 10328, (float *)(v41 + 10340), 1.0, v32);
          v14[0] = v24[0];
          v14[1] = v28;
          *(float *)&v14[2] = (long double)v32 * 0.001;
          sub_80F552A((_DWORD *)(v41 + 10352), v15);
          v16 = *(_DWORD *)(v41 + 10364);
          v17 = v25;
          v18 = *(_DWORD *)(v41 + 10304);
          v19 = *(_DWORD *)(v41 + 10312);
          v20 = *(_DWORD *)(v41 + 10308);
          sub_80F552A((_DWORD *)(v41 + 10368), v21);
          sub_80F552A((_DWORD *)(v41 + 10380), v22);
          sub_80F552A((_DWORD *)(v41 + 10340), v23);
          v23[3] = v41 + 10392;
          sub_80EF52C((float *)v14, (int)v12);
          if ( sub_80E973E(*(_DWORD *)(v14[0] + 212)) && *(float *)(v14[0] + 220) != 0.0 && !*(_DWORD *)(v11 + 632) )
          {
            sub_80A7146(v12, (int)v7);
            sub_80A7146((float *)v13, (int)v6);
            sub_80A358E(v7, v6, v5);
            sub_80A71F4((int)v5, (int)v13);
          }
          sub_80F552A(v15, (_DWORD *)(v41 + 10352));
          *(_DWORD *)(v41 + 10364) = v16;
          sub_80F552A(v21, (_DWORD *)(v41 + 10368));
          sub_80F552A(v22, (_DWORD *)(v41 + 10380));
          *(_DWORD *)(v41 + 10200) = v13[0];
          *(_DWORD *)(v41 + 10204) = v13[1];
          sub_80E6D30(s);
          if ( v39 )
            sub_80F34E0(v40, v40[3], (int)s);
          a2[56] = (*(_DWORD *)(a2[86] + 12) & 2) != 0;
          if ( *(_DWORD *)(a2[86] + 164) != v33 )
          {
            a2[94] = dword_859B5EC;
            a2[85] = dword_859B5EC;
          }
          if ( *(_BYTE *)(g_smoothClients + 8) )
            sub_80F2FA4(a2[86], (int)a2, *(_DWORD *)a2[86], 1);
          else
            sub_80DD59E(a2[86], (int)a2, 1, 1u);
          sub_80F552A(a2 + 6, a2 + 78);
          sub_80F552A(v36, a2 + 65);
          sub_80F552A(v37, a2 + 68);
          sub_80F2B86(a2, v33);
          SV_LinkEntity((int)a2);
          if ( !*(_DWORD *)(a2[86] + 10156) )
            sub_80F24C6((int)a2);
          sub_80F552A((_DWORD *)(a2[86] + 20), a2 + 78);
          sub_80F54DC(a2 + 81);
          a2[82] = *(_DWORD *)(a2[86] + 236);
          sub_80F2362((int)a2, (int)s);
          if ( *(_DWORD *)(a2[86] + 164) != v33 )
            a2[94] = dword_859B5EC;
          return sub_811EE84(a2);
        }
      }
    }
  }
  return result;
}
// 80F38C9: inconsistent fpu stack
// 8793E0C: using guessed type int g_smoothClients;
// 80F35DA: using guessed type float var_1D8[4];
// 80F35DA: using guessed type float var_218[12];
// 80F35DA: using guessed type float var_248[12];
// 80F35DA: using guessed type float var_278[12];
// 80F35DA: using guessed type int anonymous_0[3];
// 80F35DA: using guessed type int anonymous_1[5];

//----- (080F3EA4) --------------------------------------------------------
int __usercall sub_80F3EA4@<eax>(long double a1@<st0>, int a2)
{
  _DWORD *v2; // ecx
  _DWORD *v3; // edx
  int result; // eax
  int *v5; // [esp+14h] [ebp-4h]

  v5 = (int *)((char *)&unk_8665480 + 560 * a2);
  dword_855A4E0 = &unk_859EA40;
  v2 = (_DWORD *)(v5[86] + 9956);
  v3 = (_DWORD *)(v5[86] + 9928);
  *v2 = *v3;
  v2[1] = v3[1];
  v2[2] = v3[2];
  v2[3] = v3[3];
  v2[4] = v3[4];
  v2[5] = v3[5];
  v2[6] = v3[6];
  sub_80904C6(a2, (_DWORD *)(v5[86] + 9928));
  *(_DWORD *)(v5[86] + 10168) = dword_859B5EC;
  result = g_synchronousClients;
  if ( !*(_BYTE *)(g_synchronousClients + 8) )
    result = sub_80F35DA(a1, v5, (int **)(v5[86] + 9928));
  dword_855A4E0 = 0;
  return result;
}
// 8793DC0: using guessed type int g_synchronousClients;

//----- (080F3F74) --------------------------------------------------------
int __usercall sub_80F3F74@<eax>(long double a1@<st0>, int *a2)
{
  int result; // eax
  int v3; // [esp+10h] [ebp-8h]

  if ( *(_BYTE *)(g_synchronousClients + 8) )
  {
    *(_DWORD *)(a2[86] + 9928) = dword_859B5EC;
    sub_80F35DA(a1, a2, (int **)(a2[86] + 9928));
  }
  result = a2[86];
  if ( !*(_DWORD *)(result + 10156) )
  {
    if ( a2[130] )
    {
      if ( *(_DWORD *)(a2[86] + 9896) == 1 )
        v3 = 7;
      else
        v3 = 1;
      *(_DWORD *)(a2[86] + 4) = v3;
      sub_811BD52((int)a2, 2);
      sub_811CF36(a2, a2 + 78);
      sub_811CF96(a2, a2 + 81);
      a2[3] = 1;
      a2[12] = 1;
      SV_LinkEntity((int)a2);
      return sub_80F552A(a2 + 78, (_DWORD *)(a2[86] + 20));
    }
    else if ( *(_DWORD *)(a2[86] + 4) == 1 || (result = a2[86], *(_DWORD *)(result + 4) == 7) )
    {
      result = a2[86];
      --*(_DWORD *)(result + 4);
    }
  }
  return result;
}
// 8793DC0: using guessed type int g_synchronousClients;

//----- (080F40C4) --------------------------------------------------------
int __cdecl sub_80F40C4(int a1)
{
  char *v1; // eax
  char *v2; // eax
  _DWORD *v4; // [esp+14h] [ebp-4h]

  v4 = *(_DWORD **)(a1 + 344);
  *(_BYTE *)(a1 + 242) &= ~2u;
  *(_BYTE *)(a1 + 242) |= 1u;
  *(_BYTE *)(a1 + 353) = 0;
  *(_DWORD *)(a1 + 284) = 0;
  v4[3] &= 0xFC7FFFFF;
  v4[1] = 5;
  v4[40] &= ~0x200000u;
  v4[40] &= ~0x40u;
  v4[57] = 0;
  *(_DWORD *)(a1 + 4) = 5;
  v1 = va("%i", *(_DWORD *)dword_859B600);
  SV_SetConfigstring(5u, v1);
  v2 = va("%i", *(_DWORD *)dword_859B604);
  return SV_SetConfigstring(6u, v2);
}

//----- (080F41C2) --------------------------------------------------------
_DWORD *__cdecl sub_80F41C2(int a1)
{
  _DWORD *result; // eax
  unsigned int v2; // edx
  unsigned int v3; // [esp+1Ch] [ebp-273Ch]
  int *v4; // [esp+20h] [ebp-2738h]
  _DWORD *v5; // [esp+24h] [ebp-2734h]
  int v6; // [esp+28h] [ebp-2730h] BYREF
  _DWORD *v7; // [esp+2Ch] [ebp-272Ch]
  char v8[4]; // [esp+30h] [ebp-2728h] BYREF
  int v9; // [esp+34h] [ebp-2724h]
  int v10; // [esp+90h] [ebp-26C8h] BYREF
  _DWORD v11[2477]; // [esp+94h] [ebp-26C4h] BYREF
  int v12; // [esp+2748h] [ebp-10h]
  unsigned int v13; // [esp+274Ch] [ebp-Ch]

  v7 = *(_DWORD **)(a1 + 344);
  *(_BYTE *)(a1 + 242) &= ~2u;
  *(_BYTE *)(a1 + 242) |= 1u;
  *(_BYTE *)(a1 + 353) = 0;
  *(_DWORD *)(a1 + 284) = 0;
  v7[3] &= ~0x800000u;
  *(_DWORD *)(a1 + 4) = 5;
  v7[57] = 0;
  v7[2550] = 0;
  v7[2551] = 0;
  if ( (int)v7[2475] < 0 )
  {
LABEL_10:
    if ( (int)v7[2538] < 0 && !sub_80F467C((int)v7, 4) )
      sub_80FCD40(a1, 1);
    v12 = v7[2538];
    if ( v12 < 0 || (v6 = v7[2477] + v7[2537], !sub_8097EDA(v12, &v6, &v10, v8)) || !sub_80F467C((int)v7, v9) )
    {
      sub_80FCAE6((char *)a1);
      v7[3] &= ~0x2000000u;
      if ( sub_80F467C((int)v7, 2) || sub_80F467C((int)v7, 1) || sub_80F467C((int)v7, 0) )
      {
        result = v7;
        v7[3] |= 0x1000000u;
      }
      else
      {
        result = v7;
        v7[3] &= ~0x1000000u;
      }
      return result;
    }
  }
  else
  {
    v12 = v7[2475];
    v7[2538] = v12;
    while ( 1 )
    {
      if ( (int)v7[2477] < 0 )
        v7[2477] = 0;
      v6 = v7[2477] - v7[2537];
      if ( sub_8097EDA(v7[2475], &v6, &v10, v8) )
      {
        if ( sub_80F467C((int)v7, v9) )
          break;
      }
      if ( !v7[2477] )
      {
        v7[2475] = -1;
        v7[2538] = -1;
        goto LABEL_10;
      }
      v7[2477] -= 50;
    }
  }
  v13 = v11[39] & 0xFFEFFFFF | v7[40] & 0x100000;
  v5 = v7;
  v4 = &v10;
  v3 = 9896;
  if ( ((unsigned __int8)v7 & 4) != 0 )
  {
    *v7 = v10;
    ++v5;
    v4 = v11;
    v3 = 9892;
  }
  qmemcpy(v5, v4, 4 * (v3 >> 2));
  sub_81023F2(v7, *(_DWORD *)a1, 2u);
  v7[40] = v13;
  v7[3] &= ~0x800000u;
  v7[3] |= 0x400000u;
  if ( (int)v7[2475] < 0 )
  {
    v7[3] |= 0x1000000u;
    if ( sub_80F467C((int)v7, 4) )
    {
      result = v7;
      v2 = v7[3] | 0x2000000;
    }
    else
    {
      result = v7;
      v2 = v7[3] & 0xFDFFFFFF;
    }
    v7[3] = v2;
  }
  else
  {
    result = v7;
    v7[3] &= 0xFCFFFFFF;
  }
  return result;
}
// 80F41C2: using guessed type char var_2728[4];

//----- (080F467C) --------------------------------------------------------
int __cdecl sub_80F467C(int a1, char a2)
{
  return ((unsigned __int8)(*(int *)(a1 + 10048) >> a2) ^ 1) & 1;
}

//----- (080F4696) --------------------------------------------------------
int __cdecl sub_80F4696(int a1, _DWORD *a2)
{
  unsigned int v3; // [esp+18h] [ebp-20h]
  const void *v4; // [esp+1Ch] [ebp-1Ch]
  void *v5; // [esp+20h] [ebp-18h]
  _DWORD *v7; // [esp+28h] [ebp-10h]

  v7 = (_DWORD *)*((_DWORD *)&unk_8665480 + 140 * a1 + 86);
  if ( (v7[3] & 0x800000) == 0 )
    return 0;
  v5 = a2;
  v4 = (const void *)*((_DWORD *)&unk_8665480 + 140 * a1 + 86);
  v3 = 9896;
  if ( ((unsigned __int8)a2 & 4) != 0 )
  {
    *a2 = *v7;
    v5 = a2 + 1;
    v4 = v7 + 1;
    v3 = 9892;
  }
  qmemcpy(v5, v4, 4 * (v3 >> 2));
  memset(a2 + 490, 0, 0xF80u);
  return 1;
}

//----- (080F474A) --------------------------------------------------------
int __cdecl sub_80F474A(int a1)
{
  long double v1; // fst7
  long double v2; // fst7
  float v4; // [esp+18h] [ebp-30h]
  float v5; // [esp+1Ch] [ebp-2Ch]
  int v7; // [esp+28h] [ebp-20h] BYREF
  float v8; // [esp+2Ch] [ebp-1Ch]
  float *v9; // [esp+34h] [ebp-14h]
  float v10; // [esp+38h] [ebp-10h]
  float v11; // [esp+3Ch] [ebp-Ch]
  float v12; // [esp+40h] [ebp-8h]
  int v13; // [esp+44h] [ebp-4h]

  if ( (*(_DWORD *)(*(_DWORD *)(a1 + 344) + 12) & 0x800000) == 0 )
    return 0;
  if ( *(_DWORD *)(*(_DWORD *)(a1 + 344) + 9896) )
    return 0;
  if ( *(_DWORD *)(a1 + 284) != 0x2000000 && *(_DWORD *)(a1 + 284) != 0x4000000 )
    return 0;
  v9 = (float *)&unk_8665480;
  v13 = 0;
  while ( 1 )
  {
    if ( v13 >= dword_859B5E4 )
      return 0;
    if ( *((_BYTE *)v9 + 252)
      && (*(_DWORD *)(*((_DWORD *)v9 + 86) + 12) & 0x800000) != 0
      && !*(_DWORD *)(*((_DWORD *)v9 + 86) + 9896)
      && v9 != (float *)a1
      && *((_DWORD *)v9 + 86)
      && *((int *)v9 + 101) > 0
      && (*((_DWORD *)v9 + 71) == 0x2000000 || *((_DWORD *)v9 + 71) == 0x4000000)
      && v9[72] <= (long double)*(float *)(a1 + 300)
      && *(float *)(a1 + 288) <= (long double)v9[75]
      && v9[73] <= (long double)*(float *)(a1 + 304)
      && *(float *)(a1 + 292) <= (long double)v9[76]
      && v9[74] <= (long double)*(float *)(a1 + 308)
      && *(float *)(a1 + 296) <= (long double)v9[77] )
    {
      sub_80F543C(v9 + 78, (float *)(a1 + 312), (float *)&v7);
      v12 = *(float *)(a1 + 272) + v9[68];
      v1 = sub_80F548E((float *)&v7);
      if ( v1 <= v12 * v12 )
        break;
    }
    ++v13;
    v9 += 140;
  }
  sub_80F543C(v9 + 78, (float *)(a1 + 312), (float *)&v7);
  *(float *)&v7 = sub_80A142E() + *(float *)&v7;
  v8 = sub_80A142E() + v8;
  v2 = sub_80A215E((float *)&v7);
  sub_80F54B0((float *)(*((_DWORD *)v9 + 86) + 32));
  if ( v2 <= 0.0 )
    v5 = 0.0;
  else
    v5 = (float)*(int *)(g_playerCollisionEjectSpeed + 8);
  v10 = v5;
  sub_80F54B0((float *)(*(_DWORD *)(a1 + 344) + 32));
  if ( v5 <= 0.0 )
    v4 = 0.0;
  else
    v4 = (float)*(int *)(g_playerCollisionEjectSpeed + 8);
  v11 = v4;
  if ( v10 < 0.000099999997 && v11 < 0.000099999997 )
  {
    v10 = (float)*(int *)(*((_DWORD *)v9 + 86) + 80);
    v11 = (float)*(int *)(*(_DWORD *)(a1 + 344) + 80);
  }
  sub_80F5468((float *)&v7, v10, (float *)(*((_DWORD *)v9 + 86) + 32));
  *(_DWORD *)(*((_DWORD *)v9 + 86) + 16) = 300;
  *(_DWORD *)(*((_DWORD *)v9 + 86) + 12) |= 0x200u;
  sub_80F5468((float *)&v7, COERCE_FLOAT(LODWORD(v11) ^ 0x80000000), (float *)(*(_DWORD *)(a1 + 344) + 32));
  *(_DWORD *)(*(_DWORD *)(a1 + 344) + 16) = 300;
  *(_DWORD *)(*(_DWORD *)(a1 + 344) + 12) |= 0x200u;
  return 1;
}
// 859B5E4: using guessed type int dword_859B5E4;
// 8793DC4: using guessed type int g_playerCollisionEjectSpeed;

//----- (080F4B46) --------------------------------------------------------
int __cdecl sub_80F4B46(int *a1, int a2)
{
  int v2; // eax
  int v4; // [esp+14h] [ebp-4h]

  v4 = 1208 * a1[36] + 140846652;
  dword_855A4E0 = &unk_859EA40;
  v2 = Com_GetServerDObj(*a1);
  return sub_80D954C(v2, (int)a1, a2, v4, dword_859B5F4);
}
// 859B5F4: using guessed type int dword_859B5F4;

//----- (080F4BA4) --------------------------------------------------------
int __cdecl sub_80F4BA4(int a1)
{
  int v2; // [esp+14h] [ebp-24h]
  int v3; // [esp+18h] [ebp-20h]
  int i; // [esp+1Ch] [ebp-1Ch]
  char *src; // [esp+20h] [ebp-18h]
  char *s2; // [esp+24h] [ebp-14h]
  char *s2a; // [esp+24h] [ebp-14h]
  int v8; // [esp+2Ch] [ebp-Ch]

  v2 = *(_DWORD *)(a1 + 344);
  v8 = 1208 * *(_DWORD *)(a1 + 144) + 140846652;
  v3 = 0;
  s2 = (char *)G_ModelName(*(unsigned __int8 *)(a1 + 356));
  *(_DWORD *)(v2 + 10064) = *(unsigned __int8 *)(a1 + 356);
  if ( strcmp((const char *)(v8 + 64), s2) )
  {
    v3 = 1;
    I_strncpyz((char *)(v8 + 64), s2, 64);
  }
  for ( i = 0; i <= 5; ++i )
  {
    if ( *(_BYTE *)(i + a1 + 528) )
    {
      s2a = (char *)G_ModelName(*(unsigned __int8 *)(i + a1 + 528));
      *(_DWORD *)(v2 + 4 * i + 10068) = *(unsigned __int8 *)(i + a1 + 528);
      if ( strcmp((const char *)(v8 + (i << 6) + 128), s2a) )
      {
        v3 = 1;
        I_strncpyz((char *)(v8 + (i << 6) + 128), s2a, 64);
      }
      src = (char *)SL_ConvertToString(*(unsigned __int16 *)(a1 + 2 * i + 536));
      *(_DWORD *)(v2 + 4 * i + 10092) = sub_811B13C(src);
      if ( strcmp((const char *)(v8 + (i << 6) + 512), src) )
      {
        v3 = 1;
        I_strncpyz((char *)(v8 + (i << 6) + 512), src, 64);
      }
    }
    else
    {
      *(_BYTE *)(v8 + (i << 6) + 128) = 0;
      *(_BYTE *)(v8 + (i << 6) + 512) = 0;
      *(_DWORD *)(v2 + 4 * i + 10068) = 0;
      *(_DWORD *)(v2 + 4 * i + 10092) = 0;
    }
  }
  return v3;
}

//----- (080F4DBE) --------------------------------------------------------
int __usercall sub_80F4DBE@<eax>(long double a1@<st0>, int a2)
{
  int result; // eax
  unsigned int v3; // edx
  unsigned int v4; // edx
  char v5; // [esp+17h] [ebp-61h]
  int v6; // [esp+1Ch] [ebp-5Ch]
  int v7; // [esp+2Ch] [ebp-4Ch]
  _DWORD v8[4]; // [esp+30h] [ebp-48h] BYREF
  _DWORD v9[4]; // [esp+40h] [ebp-38h] BYREF
  int v10; // [esp+50h] [ebp-28h]
  int v11; // [esp+54h] [ebp-24h]
  int v12; // [esp+58h] [ebp-20h]
  int *v13; // [esp+5Ch] [ebp-1Ch]
  float v14[6]; // [esp+60h] [ebp-18h] BYREF

  v10 = *(_DWORD *)(a2 + 344);
  *(_BYTE *)(a2 + 358) = 10;
  *(_DWORD *)(v10 + 1956) = 0;
  v11 = sub_80F4BA4(a2);
  if ( *(_DWORD *)(v10 + 9924) == 2 )
  {
    if ( *(_DWORD *)(v10 + 9896) == 3 )
    {
      sub_80F40C4(a2);
      result = *(_DWORD *)(a2 + 344);
      *(_DWORD *)(result + 10184) = 0;
    }
    else if ( *(_DWORD *)(v10 + 9896) == 2 )
    {
      sub_80F41C2(a2);
      result = *(_DWORD *)(a2 + 344);
      *(_DWORD *)(result + 10184) = 0;
    }
    else if ( *(_DWORD *)(v10 + 204) == *(_DWORD *)a2 )
    {
      *(_BYTE *)(a2 + 242) |= 2u;
      *(_BYTE *)(a2 + 242) &= ~1u;
      *(_BYTE *)(a2 + 353) = 1;
      *(_DWORD *)(v10 + 12) |= 0x800000u;
      *(_DWORD *)(v10 + 12) &= 0xFCFFFFFF;
      *(_DWORD *)(v10 + 228) = *(_DWORD *)(v10 + 10044);
      sub_80F2F2E(a2);
      *(_DWORD *)(v10 + 10268) = 0;
      if ( *(_DWORD *)(v10 + 10300) <= dword_859B5EC )
        *(_DWORD *)(v10 + 160) &= ~0x400000u;
      if ( *(_DWORD *)(v10 + 10156) )
      {
        *(_DWORD *)(v10 + 4) = 2;
      }
      else if ( *(_DWORD *)(v10 + 10160) )
      {
        *(_DWORD *)(v10 + 4) = 3;
      }
      else if ( *(_DWORD *)(v10 + 9896) == 1 )
      {
        if ( *(_DWORD *)(a2 + 520) )
          v6 = 7;
        else
          v6 = 6;
        *(_DWORD *)(v10 + 4) = v6;
        *(_BYTE *)(a2 + 242) |= 1u;
        *(_BYTE *)(a2 + 242) &= ~2u;
        *(_BYTE *)(a2 + 353) = 0;
      }
      else
      {
        *(_DWORD *)(v10 + 4) = *(_DWORD *)(a2 + 520) != 0;
      }
      *(_DWORD *)(v10 + 72) = (int)*(float *)(g_gravity + 8);
      *(_DWORD *)(v10 + 80) = *(_DWORD *)(g_speed + 8);
      *(float *)(v10 + 10256) = *(float *)(v10 + 1492) / 255.0;
      sub_811FB7A((int *)a2);
      sub_811F736(a2);
      sub_80F20C8(a2);
      if ( dword_859B5EC - *(_DWORD *)(v10 + 10168) <= 1000 )
        v3 = *(_DWORD *)(a2 + 8) & 0xFFFFFF7F;
      else
        v3 = *(_DWORD *)(a2 + 8) | 0x80;
      *(_DWORD *)(a2 + 8) = v3;
      *(_DWORD *)(v10 + 300) = *(_DWORD *)(a2 + 404);
      sub_80F2350(a2);
      if ( *(_BYTE *)(g_smoothClients + 8) )
        sub_80F2FA4(v10, a2, *(_DWORD *)v10, 1);
      else
        sub_80DD59E(v10, a2, 1, 1u);
      if ( *(int *)(a2 + 404) > 0 && sub_80F474A(a2) )
        *(_DWORD *)(a2 + 284) = 0x4000000;
      sub_80F61BE(a2, v14);
      *(_DWORD *)(v10 + 1444) = sub_80F6ED0(a2, v14, *(_DWORD *)(v10 + 10296));
      if ( *(_DWORD *)(v10 + 1444) )
      {
        *(_DWORD *)(v10 + 10296) = *(_DWORD *)(v10 + 1444) & 0x3F;
        if ( (dword_8665488[140 * *(_DWORD *)(v10 + 10296)] & 0x400000) != 0 )
          v4 = *(_DWORD *)(v10 + 160) | 0x800000;
        else
          v4 = *(_DWORD *)(v10 + 160) & 0xFF7FFFFF;
        *(_DWORD *)(v10 + 160) = v4;
      }
      else
      {
        *(_DWORD *)(v10 + 10296) = 1023;
      }
      if ( *(_DWORD *)(a2 + 4) == 1 )
      {
        if ( *(int *)(a2 + 404) <= 0 )
          v5 = 11;
        else
          v5 = 9;
        *(_BYTE *)(a2 + 358) = v5;
        v12 = *(_DWORD *)(a2 + 144);
        v13 = (int *)(1208 * v12 + 140846652);
        *((_DWORD *)&unk_8652A1C + 302 * v12) = *(_DWORD *)(a2 + 108);
        v13[249] = *(_DWORD *)(a2 + 212);
        sub_80F552A((_DWORD *)(v10 + 232), v13 + 250);
        if ( v11 )
          sub_811BEEE((int *)a2);
        v7 = Com_GetServerDObj(*(_DWORD *)a2);
        sub_80D978C(v7, (_DWORD *)a2, (int)v13, *(unsigned __int8 *)(a2 + 357));
        sub_80D9698(v7, (_DWORD *)a2, v13);
        if ( (*(_DWORD *)(v10 + 12) & 0x800000) != 0 && (*(_DWORD *)(v10 + 160) & 0x300) != 0 )
          sub_8109672((_DWORD *)(dword_859B404 + 560 * *(_DWORD *)(v10 + 1428)));
        if ( *(_BYTE *)(g_debugLocDamage + 8) )
        {
          if ( SV_DObjExists((int *)a2) )
          {
            sub_811BF30(a2);
            sub_80909E8();
          }
        }
        result = *(_DWORD *)(a2 + 344);
        *(_DWORD *)(result + 10184) = 0;
      }
      else
      {
        result = *(_DWORD *)(a2 + 344);
        *(_DWORD *)(result + 10184) = 0;
      }
    }
    else
    {
      sub_80F552A((_DWORD *)(v10 + 20), v9);
      sub_80F5506(v8, 0, *(_DWORD *)(v10 + 236), 0);
      sub_80F69B4(a1, a2, v9, v8);
      result = *(_DWORD *)(a2 + 344);
      *(_DWORD *)(result + 10184) = 0;
    }
  }
  else
  {
    result = *(_DWORD *)(a2 + 344);
    *(_DWORD *)(result + 10184) = 0;
  }
  return result;
}
// 859B404: using guessed type int dword_859B404;
// 8665488: using guessed type int dword_8665488[];
// 8793D90: using guessed type int g_speed;
// 8793D94: using guessed type int g_gravity;
// 8793E0C: using guessed type int g_smoothClients;
// 8793E34: using guessed type int g_debugLocDamage;
// 80F4DBE: using guessed type _DWORD var_38[4];
// 80F4DBE: using guessed type _DWORD var_48[4];
// 80F4DBE: using guessed type float var_18[6];

//----- (080F53E0) --------------------------------------------------------
float *__cdecl sub_80F53E0(int a1, int a2)
{
  float *result; // eax
  char v3[24]; // [esp+20h] [ebp-18h] BYREF

  result = (float *)a2;
  if ( a2 >= 158 && (a2 <= 160 || a2 == 175) )
    return sub_80EE226(dword_86655D8[140 * a1], (float *)(dword_86655D8[140 * a1] + 10380), (int)v3);
  return result;
}
// 86655D8: using guessed type int dword_86655D8[];
// 80F53E0: using guessed type char var_18[24];

//----- (080F543C) --------------------------------------------------------
float *__cdecl sub_80F543C(float *a1, float *a2, float *a3)
{
  float *result; // eax

  *a3 = *a1 - *a2;
  result = a1 + 1;
  a3[1] = a1[1] - a2[1];
  return result;
}

//----- (080F5468) --------------------------------------------------------
float *__cdecl sub_80F5468(float *a1, float a2, float *a3)
{
  float *result; // eax

  *a3 = a2 * *a1;
  result = a1 + 1;
  a3[1] = a2 * a1[1];
  return result;
}

//----- (080F548E) --------------------------------------------------------
long double __cdecl sub_80F548E(float *a1)
{
  return *a1 * *a1 + a1[1] * a1[1];
}

//----- (080F54B0) --------------------------------------------------------
void __cdecl sub_80F54B0(float *a1)
{
  float v1; // [esp+0h] [ebp-8h]

  v1 = *a1 * *a1 + a1[1] * a1[1];
  sub_80F5616(v1);
}

//----- (080F54DC) --------------------------------------------------------
int __cdecl sub_80F54DC(_DWORD *a1)
{
  int result; // eax

  *a1 = 0;
  a1[1] = 0;
  result = 0;
  a1[2] = 0;
  return result;
}

//----- (080F5506) --------------------------------------------------------
int __cdecl sub_80F5506(_DWORD *a1, int a2, int a3, int a4)
{
  int result; // eax

  *a1 = a2;
  a1[1] = a3;
  result = a4;
  a1[2] = a4;
  return result;
}

//----- (080F552A) --------------------------------------------------------
int __cdecl sub_80F552A(_DWORD *a1, _DWORD *a2)
{
  int result; // eax

  *a2 = *a1;
  a2[1] = a1[1];
  result = a1[2];
  a2[2] = result;
  return result;
}

//----- (080F555A) --------------------------------------------------------
float *__cdecl sub_80F555A(float *a1, float *a2, float *a3)
{
  float *result; // eax

  *a3 = *a1 + *a2;
  a3[1] = a1[1] + a2[1];
  result = a1 + 2;
  a3[2] = a1[2] + a2[2];
  return result;
}

//----- (080F559E) --------------------------------------------------------
float *__cdecl sub_80F559E(float *a1, float *a2, float *a3)
{
  float *result; // eax

  *a3 = *a1 - *a2;
  a3[1] = a1[1] - a2[1];
  result = a1 + 2;
  a3[2] = a1[2] - a2[2];
  return result;
}

//----- (080F55E2) --------------------------------------------------------
long double __cdecl sub_80F55E2(float *a1, float *a2)
{
  return *a1 * *a2 + a1[1] * a2[1] + a1[2] * a2[2];
}

//----- (080F5616) --------------------------------------------------------
long double __cdecl sub_80F5616(float a1)
{
  return (float)sqrt(a1);
}

//----- (080F5638) --------------------------------------------------------
void __cdecl ClientScr_ReadOnly(int a1, const char **a2)
{
  char *v2; // eax

  v2 = va("player field %s is read-only", *a2);
  Scr_Error((int)v2);
}

//----- (080F565E) --------------------------------------------------------
void __cdecl ClientScr_SetSessionTeam(int a1)
{
  const char *v1; // eax
  char *v2; // eax
  unsigned __int16 v3; // [esp+16h] [ebp-2h]

  v3 = Scr_GetConstString(0);
  if ( v3 == word_87A22A4 )
  {
    *(_DWORD *)(a1 + 10060) = 1;
  }
  else if ( v3 == word_87A22A2 )
  {
    *(_DWORD *)(a1 + 10060) = 2;
  }
  else if ( v3 == word_87A22E8 )
  {
    *(_DWORD *)(a1 + 10060) = 3;
  }
  else if ( v3 == word_87A2314 )
  {
    *(_DWORD *)(a1 + 10060) = 0;
  }
  else
  {
    v1 = (const char *)SL_ConvertToString(v3);
    v2 = va("'%s' is an illegal sessionteam string. Must be allies, axis, none, or spectator.", v1);
    Scr_Error((int)v2);
  }
  ClientUserinfoChanged(1682649625 * ((a1 - dword_859B400) >> 2));
  CalculateRanks();
}
// 859B400: using guessed type int dword_859B400;
// 87A22A2: using guessed type __int16 word_87A22A2;
// 87A22A4: using guessed type __int16 word_87A22A4;
// 87A22E8: using guessed type __int16 word_87A22E8;
// 87A2314: using guessed type __int16 word_87A2314;

//----- (080F572C) --------------------------------------------------------
int __cdecl sub_80F572C(int a1)
{
  int result; // eax

  result = *(_DWORD *)(a1 + 10060);
  if ( result == 1 )
    return Scr_AddConstString((unsigned __int16)word_87A22A4);
  if ( result > 1 )
  {
    if ( result == 2 )
    {
      return Scr_AddConstString((unsigned __int16)word_87A22A2);
    }
    else if ( result == 3 )
    {
      return Scr_AddConstString((unsigned __int16)word_87A22E8);
    }
  }
  else if ( !result )
  {
    return Scr_AddConstString((unsigned __int16)word_87A2314);
  }
  return result;
}
// 87A22A2: using guessed type __int16 word_87A22A2;
// 87A22A4: using guessed type __int16 word_87A22A4;
// 87A22E8: using guessed type __int16 word_87A22E8;
// 87A2314: using guessed type __int16 word_87A2314;

//----- (080F57A4) --------------------------------------------------------
void __cdecl sub_80F57A4(int a1)
{
  const char *v1; // eax
  char *v2; // eax
  unsigned __int16 v3; // [esp+16h] [ebp-2h]

  v3 = Scr_GetConstString(0);
  if ( v3 == word_87A2312 )
  {
    *(_DWORD *)(a1 + 9896) = 0;
  }
  else if ( v3 == word_87A2316 )
  {
    *(_DWORD *)(a1 + 9896) = 1;
  }
  else if ( v3 == word_87A22E8 )
  {
    *(_DWORD *)(a1 + 9896) = 2;
  }
  else if ( v3 == word_87A230E )
  {
    *(_DWORD *)(a1 + 160) ^= 2u;
    *(_DWORD *)(a1 + 9896) = 3;
  }
  else
  {
    v1 = (const char *)SL_ConvertToString(v3);
    v2 = va("'%s' is an illegal sessionstate string. Must be playing, dead, spectator, or intermission.", v1);
    Scr_Error((int)v2);
  }
}
// 87A22E8: using guessed type __int16 word_87A22E8;
// 87A230E: using guessed type __int16 word_87A230E;
// 87A2312: using guessed type __int16 word_87A2312;
// 87A2316: using guessed type __int16 word_87A2316;

//----- (080F5868) --------------------------------------------------------
int __cdecl sub_80F5868(int a1)
{
  int result; // eax

  result = *(_DWORD *)(a1 + 9896);
  if ( result == 1 )
    return Scr_AddConstString((unsigned __int16)word_87A2316);
  if ( result > 1 )
  {
    if ( result == 2 )
    {
      return Scr_AddConstString((unsigned __int16)word_87A22E8);
    }
    else if ( result == 3 )
    {
      return Scr_AddConstString((unsigned __int16)word_87A230E);
    }
  }
  else if ( !result )
  {
    return Scr_AddConstString((unsigned __int16)word_87A2312);
  }
  return result;
}
// 87A22E8: using guessed type __int16 word_87A22E8;
// 87A230E: using guessed type __int16 word_87A230E;
// 87A2312: using guessed type __int16 word_87A2312;
// 87A2316: using guessed type __int16 word_87A2316;

//----- (080F58E0) --------------------------------------------------------
int __cdecl sub_80F58E0(_DWORD *a1)
{
  int result; // eax

  a1[2506] = Scr_GetInt(0);
  if ( (int)a1[2506] <= 0 )
    a1[2506] = 1;
  if ( a1[75] > a1[2506] )
    a1[75] = a1[2506];
  *((_DWORD *)&unk_8665480 + 421488044 * (((int)a1 - dword_859B400) >> 2) + 101) = a1[75];
  result = a1[2506];
  a1[77] = result;
  return result;
}
// 859B400: using guessed type int dword_859B400;

//----- (080F598C) --------------------------------------------------------
void __cdecl sub_80F598C(int a1)
{
  *(_DWORD *)(a1 + 9912) = Scr_GetInt(0);
  CalculateRanks();
}

//----- (080F59B4) --------------------------------------------------------
int __cdecl sub_80F59B4(int a1)
{
  int result; // eax
  int v2; // [esp+4h] [ebp-4h]

  v2 = Scr_GetInt(0);
  if ( v2 < -1 || v2 > 63 )
    Scr_Error((int)"spectatorclient can only be set to -1, or a valid client number");
  result = v2;
  *(_DWORD *)(a1 + 9900) = v2;
  return result;
}

//----- (080F59F2) --------------------------------------------------------
int __cdecl sub_80F59F2(int a1)
{
  int result; // eax
  char *v2; // [esp+10h] [ebp-8h]

  v2 = (char *)Scr_GetString(0);
  result = GScr_GetStatusIconIndex(v2);
  *(_DWORD *)(a1 + 9904) = result;
  return result;
}

//----- (080F5A22) --------------------------------------------------------
int __cdecl sub_80F5A22(int a1)
{
  char s[1032]; // [esp+10h] [ebp-408h] BYREF

  if ( !*(_DWORD *)(a1 + 9904) )
    return Scr_AddString((char *)byte_8150A80);
  SV_GetConfigstring(*(_DWORD *)(a1 + 9904) + 22, s, 1024);
  return Scr_AddString(s);
}

//----- (080F5A7C) --------------------------------------------------------
int __cdecl sub_80F5A7C(int a1)
{
  int result; // eax
  char *v2; // [esp+Ch] [ebp-Ch]
  char *v3; // [esp+10h] [ebp-8h]

  v2 = (char *)&unk_8665480 + 1685952176 * ((a1 - dword_859B400) >> 2);
  v3 = (char *)Scr_GetString(0);
  result = GScr_GetHeadIconIndex(v3);
  *((_DWORD *)v2 + 37) = result;
  return result;
}
// 859B400: using guessed type int dword_859B400;

//----- (080F5AD2) --------------------------------------------------------
int __cdecl sub_80F5AD2(int a1)
{
  int result; // eax
  char s[1036]; // [esp+10h] [ebp-418h] BYREF
  int v3; // [esp+41Ch] [ebp-Ch]

  v3 = (int)&unk_8665480 + 1685952176 * ((a1 - dword_859B400) >> 2);
  if ( !*(_DWORD *)(v3 + 148) )
    return Scr_AddString((char *)byte_8150A80);
  result = v3;
  if ( *(int *)(v3 + 148) <= 15 )
  {
    SV_GetConfigstring(*(_DWORD *)(v3 + 148) + 30, s, 1024);
    return Scr_AddString(s);
  }
  return result;
}
// 859B400: using guessed type int dword_859B400;

//----- (080F5B5E) --------------------------------------------------------
void __cdecl ClientScr_SetHeadIconTeam(int a1)
{
  const char *v1; // eax
  char *v2; // eax
  char *v3; // [esp+10h] [ebp-8h]
  unsigned __int16 v4; // [esp+16h] [ebp-2h]

  v3 = (char *)&unk_8665480 + 1685952176 * ((a1 - dword_859B400) >> 2);
  v4 = Scr_GetConstString(0);
  if ( v4 == word_87A2314 )
  {
    *((_DWORD *)v3 + 38) = 0;
  }
  else if ( v4 == word_87A22A2 )
  {
    *((_DWORD *)v3 + 38) = 2;
  }
  else if ( v4 == word_87A22A4 )
  {
    *((_DWORD *)v3 + 38) = 1;
  }
  else if ( v4 == word_87A22E8 )
  {
    v1 = (const char *)SL_ConvertToString(v4);
    v2 = va("'%s' is an illegal head icon team string. Must be none, allies, axis, or spectator.", v1);
    Scr_Error((int)v2);
  }
  else
  {
    *((_DWORD *)v3 + 38) = 3;
  }
}
// 859B400: using guessed type int dword_859B400;
// 87A22A2: using guessed type __int16 word_87A22A2;
// 87A22A4: using guessed type __int16 word_87A22A4;
// 87A22E8: using guessed type __int16 word_87A22E8;
// 87A2314: using guessed type __int16 word_87A2314;

//----- (080F5C30) --------------------------------------------------------
int __cdecl sub_80F5C30(int a1)
{
  int v2; // [esp+10h] [ebp-8h]

  v2 = *((_DWORD *)&unk_8665480 + 421488044 * ((a1 - dword_859B400) >> 2) + 38);
  if ( v2 == 2 )
    return Scr_AddConstString((unsigned __int16)word_87A22A2);
  if ( v2 > 2 )
  {
    if ( v2 == 3 )
      return Scr_AddConstString((unsigned __int16)word_87A22E8);
  }
  else if ( v2 == 1 )
  {
    return Scr_AddConstString((unsigned __int16)word_87A22A4);
  }
  return Scr_AddConstString((unsigned __int16)word_87A2314);
}
// 859B400: using guessed type int dword_859B400;
// 87A22A2: using guessed type __int16 word_87A22A2;
// 87A22A4: using guessed type __int16 word_87A22A4;
// 87A22E8: using guessed type __int16 word_87A22E8;
// 87A2314: using guessed type __int16 word_87A2314;

//----- (080F5CC8) --------------------------------------------------------
__int16 __cdecl sub_80F5CC8(int a1)
{
  long double v1; // fst7
  __int16 result; // ax
  __int16 v3; // [esp+12h] [ebp-6h]

  v1 = Scr_GetFloat(0);
  result = v3 | 0xC00;
  *(_DWORD *)(a1 + 9908) = (int)(v1 * 1000.0);
  return result;
}
// 80F5CED: variable 'v3' is possibly undefined

//----- (080F5D08) --------------------------------------------------------
int __cdecl sub_80F5D08(int a1)
{
  int v2; // [esp+0h] [ebp-8h]

  *(float *)&v2 = (long double)*(int *)(a1 + 9908) * 0.001;
  return Scr_AddFloat(v2);
}

//----- (080F5D2A) --------------------------------------------------------
int __cdecl sub_80F5D2A(int a1)
{
  int result; // eax

  result = Scr_GetInt(0);
  *(_DWORD *)(a1 + 10148) = result;
  return result;
}

//----- (080F5D4C) --------------------------------------------------------
int __cdecl sub_80F5D4C(int a1)
{
  return Scr_AddInt(*(_DWORD *)(a1 + 9908));
}

//----- (080F5D66) --------------------------------------------------------
char **sub_80F5D66()
{
  char **result; // eax
  char **i; // [esp+14h] [ebp-4h]

  for ( i = &off_8150B80; ; i += 5 )
  {
    result = i;
    if ( !*i )
      break;
    sub_807E1F6(0, *i, (-13107 * (i - &off_8150B80)) | 0xC000);
  }
  return result;
}
// 8150B80: using guessed type char *off_8150B80;

//----- (080F5DBC) --------------------------------------------------------
int __cdecl sub_80F5DBC(int a1, int a2)
{
  char **v3; // [esp+14h] [ebp-4h]

  v3 = &(&off_8150B80)[5 * a2];
  if ( v3[3] )
    return ((int (__cdecl *)(int, char **))v3[3])(a1, v3);
  else
    return sub_81188EE(a1, (int)v3[2], (int)v3[1]);
}
// 8150B80: using guessed type char *off_8150B80;

//----- (080F5E1E) --------------------------------------------------------
int __cdecl sub_80F5E1E(int a1, int a2)
{
  char **v3; // [esp+14h] [ebp-4h]

  v3 = &(&off_8150B80)[5 * a2];
  if ( v3[4] )
    return ((int (__cdecl *)(int, char **))v3[4])(a1, v3);
  else
    return sub_8118AAC(a1, (int)v3[2], (int)v3[1]);
}
// 8150B80: using guessed type char *off_8150B80;

//----- (080F5E80) --------------------------------------------------------
int __usercall sub_80F5E80@<eax>(long double a1@<st0>, int a2, _DWORD *a3)
{
  long double v3; // fst7
  float v5; // [esp+0h] [ebp-48h]
  float v6; // [esp+0h] [ebp-48h]
  float v7; // [esp+1Ch] [ebp-2Ch]
  float v8; // [esp+1Ch] [ebp-2Ch]
  float v9; // [esp+1Ch] [ebp-2Ch]
  float v10; // [esp+1Ch] [ebp-2Ch]
  float v11; // [esp+1Ch] [ebp-2Ch]
  float v12; // [esp+1Ch] [ebp-2Ch]
  float v13; // [esp+20h] [ebp-28h] BYREF
  float v14; // [esp+24h] [ebp-24h]
  int i; // [esp+3Ch] [ebp-Ch]

  sub_80F739A(a3, &v13);
  if ( (*(_BYTE *)(*(_DWORD *)(a2 + 344) + 12) & 1) != 0 && (*(_DWORD *)(*(_DWORD *)(a2 + 344) + 160) & 0x300) == 0 )
  {
    sub_80A6258(*(float *)(*(_DWORD *)(a2 + 344) + 1412), v14);
    v7 = a1;
    v8 = sub_80A6112(v7);
    if ( v8 > 45.0 || (v3 = v8, v8 < -45.0) )
    {
      if ( v8 <= 45.0 )
        v9 = v8 + 45.0;
      else
        v9 = v8 - 45.0;
      *(_DWORD *)(*(_DWORD *)(a2 + 344) + 88) += (unsigned __int16)(int)(v9 * 182.04445);
      if ( v9 <= 0.0 )
        v5 = *(float *)(*(_DWORD *)(a2 + 344) + 1412) + 45.0;
      else
        v5 = *(float *)(*(_DWORD *)(a2 + 344) + 1412) - 45.0;
      v3 = sub_80A60CE(v5);
      v14 = v3;
    }
    sub_80A6258(*(float *)(*(_DWORD *)(a2 + 344) + 1420), v13);
    v10 = v3;
    v11 = sub_80A6112(v10);
    if ( v11 > 45.0 || v11 < -15.0 )
    {
      if ( v11 <= 45.0 )
        v12 = v11 + 15.0;
      else
        v12 = v11 - 45.0;
      *(_DWORD *)(*(_DWORD *)(a2 + 344) + 84) += (unsigned __int16)(int)(v12 * 182.04445);
      if ( v12 <= 0.0 )
        v6 = *(float *)(*(_DWORD *)(a2 + 344) + 1420) + 15.0;
      else
        v6 = *(float *)(*(_DWORD *)(a2 + 344) + 1420) - 45.0;
      v13 = sub_80A6112(v6);
    }
  }
  for ( i = 0; i <= 2; ++i )
    *(_DWORD *)(*(_DWORD *)(a2 + 344) + 4 * i + 84) = (unsigned __int16)(int)(*(&v13 + i) * 182.04445)
                                                    - *(_DWORD *)(*(_DWORD *)(a2 + 344) + 4 * i + 9940);
  sub_80F739A(&v13, (_DWORD *)(a2 + 324));
  return sub_80F739A((_DWORD *)(a2 + 324), (_DWORD *)(*(_DWORD *)(a2 + 344) + 232));
}

//----- (080F61BE) --------------------------------------------------------
void __cdecl sub_80F61BE(int a1, float *a2)
{
  long double v2; // fst7
  float v3; // [esp+20h] [ebp-38h]
  float v4; // [esp+24h] [ebp-34h]
  float v5; // [esp+28h] [ebp-30h]
  float v6; // [esp+2Ch] [ebp-2Ch]
  int v7[6]; // [esp+30h] [ebp-28h] BYREF
  int v8; // [esp+4Ch] [ebp-Ch]

  v8 = *(_DWORD *)(a1 + 344);
  if ( (*(_DWORD *)(v8 + 160) & 0x300) != 0 )
  {
    if ( !sub_811C16A((int)&unk_8665480 + 560 * *(_DWORD *)(v8 + 1428), (unsigned __int16)word_87A233A, a2) )
      Com_Error(1, (char *)&byte_8150CC0);
  }
  else
  {
    sub_80F739A((_DWORD *)(v8 + 20), a2);
    a2[2] = a2[2] + *(float *)(v8 + 248);
    v2 = sub_80EE4AA(v8);
    v4 = v2;
    v3 = sub_80E6DF4(v2, v8, dword_859B5EC);
    v6 = sub_80EE506(v8, v4, v3, *(float *)(bg_bobMax + 8));
    a2[2] = a2[2] + v6;
    v5 = sub_80EE5C6(v8, v4, v3, *(float *)(bg_bobMax + 8));
    sub_80F63A0(a1, 0, (float *)v7, 0);
    sub_80F73CA(a2, v5, (float *)v7, a2);
    sub_80B66C0(a2, *(_DWORD *)(v8 + 236), *(float *)(v8 + 76), 16.0, 20.0);
    if ( *(float *)(v8 + 28) + 8.0 > a2[2] )
      a2[2] = *(float *)(v8 + 28) + 8.0;
  }
}
// 80F6286: inconsistent fpu stack
// 85760C4: using guessed type int bg_bobMax;
// 87A233A: using guessed type __int16 word_87A233A;

//----- (080F63A0) --------------------------------------------------------
void __cdecl sub_80F63A0(int a1, int a2, float *a3, float *a4)
{
  AngleVectors((float *)(*(_DWORD *)(a1 + 344) + 232), a2, a3, a4);
}

//----- (080F63D4) --------------------------------------------------------
char *__cdecl sub_80F63D4(char *a1, char *a2, int a3)
{
  char *v3; // eax
  char *v4; // eax
  char *result; // eax
  int v6; // [esp+14h] [ebp-14h]
  char *dest; // [esp+18h] [ebp-10h]
  char v8; // [esp+1Fh] [ebp-9h]
  int v9; // [esp+20h] [ebp-8h]
  int v10; // [esp+24h] [ebp-4h]
  int v11; // [esp+38h] [ebp+10h]

  v11 = a3 - 1;
  v10 = 0;
  v9 = 0;
  dest = a2;
  *a2 = 0;
  v6 = 0;
  while ( 1 )
  {
    v3 = a1++;
    v8 = *v3;
    if ( !*v3 )
      break;
    if ( *dest || v8 != 32 )
    {
      if ( v8 == 94 )
      {
        if ( !*a1 )
          break;
        if ( (unsigned __int8)ColorIndex(*a1) )
        {
          if ( v10 > v11 - 2 )
            break;
          *a2 = 94;
          v4 = a1++;
          a2[1] = *v4;
          a2 += 2;
          v10 += 2;
        }
        else
        {
          ++a1;
        }
      }
      else if ( v8 == 32 )
      {
        if ( ++v6 <= 3 )
          goto LABEL_15;
      }
      else
      {
        v6 = 0;
LABEL_15:
        if ( v10 > v11 - 1 )
          break;
        *a2++ = v8;
        ++v9;
        ++v10;
      }
    }
  }
  *a2 = 0;
  result = dest;
  if ( !*dest || !v9 )
    return I_strncpyz(dest, "UnnamedPlayer", v11);
  return result;
}

//----- (080F6506) --------------------------------------------------------
int __cdecl ClientUserinfoChanged(int a1)
{
  int v1; // ebx
  int result; // eax
  char dest[1036]; // [esp+20h] [ebp-828h] BYREF
  int v4; // [esp+42Ch] [ebp-41Ch]
  char v5[1032]; // [esp+430h] [ebp-418h] BYREF
  char *nptr; // [esp+838h] [ebp-10h]
  int v7; // [esp+83Ch] [ebp-Ch]

  v7 = (int)&unk_8665480 + 560 * a1;
  v4 = *(_DWORD *)(v7 + 344);
  SV_GetUserinfo(a1, dest, 1024);
  if ( !sub_80B5FA4(dest) )
    strcpy(dest, "\\name\\badinfo");
  v1 = v4;
  *(_DWORD *)(v1 + 9984) = sub_8090B5E(a1);
  nptr = Info_ValueForKey(dest, "cg_predictItems");
  if ( atoi(nptr) )
    *(_DWORD *)(v4 + 9988) = 1;
  else
    *(_DWORD *)(v4 + 9988) = 0;
  if ( *(_DWORD *)(v4 + 9924) == 2 && dword_859B614 )
  {
    nptr = Info_ValueForKey(dest, "name");
    sub_80F63D4(nptr, (char *)(v4 + 9992), 32);
  }
  else
  {
    I_strncpyz(v5, (char *)(v4 + 10116), 1024);
    nptr = Info_ValueForKey(dest, "name");
    sub_80F63D4(nptr, (char *)(v4 + 10116), 32);
    I_strncpyz((char *)(v4 + 9992), (char *)(v4 + 10116), 32);
  }
  *((_DWORD *)&unk_8652644 + 302 * a1) = a1;
  I_strncpyz((char *)(1208 * a1 + 140846664), (char *)(v4 + 10116), 32);
  result = *(_DWORD *)(v4 + 10060);
  *((_DWORD *)&unk_8652668 + 302 * a1) = result;
  return result;
}
// 859B614: using guessed type int dword_859B614;
// 80F6506: using guessed type char var_418[1032];

//----- (080F6722) --------------------------------------------------------
const char *__usercall ClientConnect@<eax>(long double a1@<st0>, int a2, __int16 a3)
{
  int v5; // [esp+14h] [ebp-424h]
  _DWORD *v6; // [esp+18h] [ebp-420h]
  char *v7; // [esp+1Ch] [ebp-41Ch]
  char dest[1028]; // [esp+20h] [ebp-418h] BYREF
  void *s; // [esp+424h] [ebp-14h]
  char *s2; // [esp+428h] [ebp-10h]
  __int16 v11; // [esp+42Eh] [ebp-Ah]

  v11 = a3;
  v7 = (char *)&unk_8665480 + 560 * a2;
  s = (void *)(dword_859B400 + 10404 * a2);
  memset(s, 0, 0x28A4u);
  v6 = (_DWORD *)(1208 * a2 + 140846652);
  v5 = dword_8652AE0[302 * a2];
  memset(v6, 0, 0x4B8u);
  v6[297] = v5;
  *v6 = 1;
  v6[1] = 1;
  *((_DWORD *)s + 2481) = 1;
  *((_WORD *)s + 4960) = v11;
  *((_DWORD *)s + 2515) = 3;
  *((_DWORD *)s + 2474) = 2;
  *((_DWORD *)s + 2538) = -1;
  *((_DWORD *)s + 2475) = -1;
  G_InitGentity((int)v7);
  v7[358] = 0;
  *((_DWORD *)v7 + 86) = s;
  *((_DWORD *)s + 2572) = 1023;
  *((_DWORD *)s + 2514) = a2;
  *((_DWORD *)s + 51) = a2;
  ClientUserinfoChanged(a2);
  SV_GetUserinfo(a2, dest, 1024);
  if ( *((_DWORD *)s + 2496)
    || (s2 = Info_ValueForKey(dest, "password"), !**(_BYTE **)(g_password + 8))
    || !I_stricmp(*(char **)(g_password + 8), "none")
    || !strcmp(*(const char **)(g_password + 8), s2) )
  {
    Scr_PlayerConnect((int *)v7);
    CalculateRanks();
    return 0;
  }
  else
  {
    G_FreeEntity(a1, (int *)v7);
    return "GAME_INVALIDPASSWORD";
  }
}
// 859B400: using guessed type int dword_859B400;
// 8652AE0: using guessed type int dword_8652AE0[19048];
// 8793D84: using guessed type int g_password;
// 80F6722: using guessed type int arg_0;

//----- (080F6954) --------------------------------------------------------
int __cdecl sub_80F6954(int a1)
{
  int v2; // [esp+14h] [ebp-4h]

  v2 = dword_859B400 + 10404 * a1;
  *(_DWORD *)(v2 + 9924) = 2;
  *(_DWORD *)(v2 + 4) = 4;
  CalculateRanks();
  return Scr_Notify((int *)(560 * a1 + 140924032), word_87A230C, 0);
}
// 859B400: using guessed type int dword_859B400;
// 87A230C: using guessed type __int16 word_87A230C;

//----- (080F69B4) --------------------------------------------------------
int __usercall sub_80F69B4@<eax>(long double a1@<st0>, int a2, _DWORD *a3, _DWORD *a4)
{
  int v5; // [esp+1Ch] [ebp-11Ch]
  char v6[256]; // [esp+20h] [ebp-118h] BYREF
  int v7; // [esp+124h] [ebp-14h]
  void *s; // [esp+128h] [ebp-10h]
  int v9; // [esp+12Ch] [ebp-Ch]

  v9 = -1963413621 * ((a2 - (int)&unk_8665480) >> 4);
  s = *(void **)(a2 + 344);
  if ( (*((_DWORD *)s + 3) & 0x800000) != 0 && (*((_DWORD *)s + 40) & 0x300) != 0 )
    sub_810950C(dword_859B404 + 560 * *((_DWORD *)s + 357));
  G_EntUnlink(a1, (_DWORD *)a2);
  if ( *(_BYTE *)(a2 + 240) )
    SV_UnlinkEntity(a2);
  *(_DWORD *)(a2 + 124) = 1023;
  Scr_SetString((_WORD *)(a2 + 360), (unsigned __int16)word_87A22D2);
  *(_DWORD *)(a2 + 388) = 42008593;
  *(_BYTE *)(a2 + 242) |= 1u;
  *(_BYTE *)(a2 + 353) = 0;
  sub_80F2F2E(a2);
  *(_BYTE *)(a2 + 358) = 10;
  *(_DWORD *)(a2 + 372) = 4096;
  sub_80F739A(dword_8167700, (_DWORD *)(a2 + 260));
  sub_80F739A(dword_816770C, (_DWORD *)(a2 + 272));
  v7 = *((_DWORD *)s + 40) & 0x100002;
  qmemcpy(v6, (char *)s + 9896, sizeof(v6));
  v5 = *((_DWORD *)s + 80);
  memset(s, 0, 0x28A4u);
  qmemcpy((char *)s + 9896, v6, 0x100u);
  *((_DWORD *)s + 2538) = -1;
  *((_DWORD *)s + 2572) = 1023;
  *((_DWORD *)s + 80) = v5 + 1;
  *((_DWORD *)s + 77) = *((_DWORD *)s + 2506);
  *((_DWORD *)s + 40) = v7;
  *((_DWORD *)s + 2514) = v9;
  *((_DWORD *)s + 51) = v9;
  *((_DWORD *)s + 357) = 1023;
  sub_80904C6(1682649625 * (((int)s - dword_859B400) >> 2), (_DWORD *)s + 2482);
  *((_DWORD *)s + 40) ^= 2u;
  sub_80F739A((_DWORD *)(a2 + 260), (_DWORD *)s + 347);
  sub_80F739A((_DWORD *)(a2 + 272), (_DWORD *)s + 350);
  *((_DWORD *)s + 61) = 60;
  *((_DWORD *)s + 62) = 1114636288;
  *((_DWORD *)s + 63) = 0;
  *((_DWORD *)s + 66) = 0;
  sub_811CF36((_DWORD *)a2, a3);
  sub_80F739A(a3, (_DWORD *)s + 5);
  *((_DWORD *)s + 3) |= 0x1000u;
  sub_80F5E80(a1, a2, a4);
  *((_DWORD *)s + 2560) = dword_859B5EC + 1000 * *(_DWORD *)(g_inactivity + 8);
  *((_DWORD *)s + 2543) = *((_DWORD *)s + 2483);
  dword_859B420 = 1;
  *((_DWORD *)s + 2600) = dword_859B5EC;
  *((_DWORD *)s + 2482) = dword_859B5EC;
  *(_DWORD *)s = dword_859B5EC - 100;
  sub_80F4DBE(a2);
  sub_80F35DA(a1, (int *)a2, (int **)s + 2482);
  dword_859B420 = 0;
  return sub_80DD59E((int)s, a2, 1, 1u);
}
// 80F4DBE: using guessed type _DWORD __cdecl sub_80F4DBE(_DWORD);
// 8167700: using guessed type _DWORD dword_8167700[3];
// 816770C: using guessed type _DWORD dword_816770C[3];
// 859B400: using guessed type int dword_859B400;
// 859B404: using guessed type int dword_859B404;
// 859B420: using guessed type int dword_859B420;
// 8793DA8: using guessed type int g_inactivity;
// 87A22D2: using guessed type __int16 word_87A22D2;

//----- (080F6D74) --------------------------------------------------------
void __usercall ClientDisconnect(long double a1@<st0>, int a2)
{
  int v2; // [esp+Ch] [ebp-Ch]
  int i; // [esp+10h] [ebp-8h]
  int *s; // [esp+14h] [ebp-4h]

  v2 = dword_859B400 + 10404 * a2;
  s = (int *)((char *)&unk_8665480 + 560 * a2);
  if ( Scr_IsSystemActive() )
  {
    Scr_AddString("disconnect");
    Scr_AddString("-1");
    Scr_Notify(s, word_87A2310, 2);
  }
  for ( i = 0; i < dword_859B5E4; ++i )
  {
    if ( *(_DWORD *)(dword_859B400 + 10404 * i + 9924)
      && *(_DWORD *)(dword_859B400 + 10404 * i + 9896) == 2
      && *(_DWORD *)(dword_859B400 + 10404 * i + 10152) == a2 )
    {
      sub_80FCAE6((char *)(560 * i + 140924032));
    }
  }
  sub_8100F84(s);
  if ( Scr_IsSystemActive() )
    sub_8115EF6(s);
  G_FreeEntity(a1, s);
  *(_DWORD *)(v2 + 9924) = 0;
  memset((void *)(v2 + 10056), 0, 0x5Cu);
  CalculateRanks();
}
// 859B400: using guessed type int dword_859B400;
// 859B5E4: using guessed type int dword_859B5E4;
// 87A2310: using guessed type __int16 word_87A2310;

//----- (080F6ED0) --------------------------------------------------------
int __cdecl sub_80F6ED0(int a1, float *a2, int a3)
{
  unsigned int v4; // [esp+20h] [ebp-48h]
  int v5; // [esp+24h] [ebp-44h]
  int v6; // [esp+28h] [ebp-40h]
  int v8; // [esp+38h] [ebp-30h]
  char *v9; // [esp+3Ch] [ebp-2Ch]
  float v10; // [esp+40h] [ebp-28h]
  float v11; // [esp+44h] [ebp-24h]
  float v12[2]; // [esp+48h] [ebp-20h] BYREF
  int v13; // [esp+50h] [ebp-18h]
  int v14; // [esp+54h] [ebp-14h]
  unsigned int v15; // [esp+58h] [ebp-10h]
  int v16; // [esp+5Ch] [ebp-Ch]
  int i; // [esp+60h] [ebp-8h]
  int v18; // [esp+64h] [ebp-4h]

  v8 = *(_DWORD *)(*(_DWORD *)(a1 + 344) + 10060);
  if ( !v8 || v8 == 3 )
    return 0;
  if ( a3 == 1023 )
    v18 = 0;
  else
    v18 = a3 + 1;
  for ( i = 0; ; ++i )
  {
    if ( i > 63 )
      return 0;
    v6 = i + v18;
    v5 = i + v18 + (i + v18 < 0 ? 0x3F : 0);
    v16 = (i + v18) % 64;
    v9 = (char *)&unk_8665480 + 560 * v16;
    if ( v9[252] )
    {
      if ( *((_DWORD *)v9 + 86)
        && !*(_DWORD *)(*((_DWORD *)v9 + 86) + 9896)
        && *(_DWORD *)(*((_DWORD *)v9 + 86) + 10060) == v8
        && (char *)a1 != v9
        && !sub_808FFBC(a2, *(_DWORD *)v9) )
      {
        break;
      }
    }
  }
  v15 = *(_DWORD *)v9;
  sub_80F736E((float *)v9 + 78, a2, v12);
  v13 = (int)(v12[0] + 0.5);
  v14 = (int)(v12[1] + 0.5);
  v10 = 1.0;
  v11 = 1.0;
  if ( v13 <= 1024 )
  {
    if ( v13 < -1022 )
      v10 = -1022.0 / (long double)v13;
  }
  else
  {
    v10 = 1024.0 / (long double)v13;
  }
  if ( v14 <= 1024 )
  {
    if ( v14 < -1022 )
      v11 = -1022.0 / (long double)v14;
  }
  else
  {
    v11 = 1024.0 / (long double)v14;
  }
  if ( v10 < 1.0 || v11 < 1.0 )
  {
    if ( v11 <= (long double)v10 )
    {
      if ( v10 > (long double)v11 )
        v13 = (int)((long double)v13 * v11);
    }
    else
    {
      v14 = (int)((long double)v14 * v10);
    }
  }
  if ( v13 <= 1024 )
  {
    if ( v13 < -1022 )
      v13 = -1022;
  }
  else
  {
    v13 = 1024;
  }
  if ( v14 <= 1024 )
  {
    if ( v14 < -1022 )
      v14 = -1022;
  }
  else
  {
    v14 = 1024;
  }
  v4 = v15 & 0xFFFF803F;
  v15 = v15 & 0xFF00003F | ((((unsigned __int16)((v13 + 2) / 4) + 255) & 0x1FF) << 6) & 0x7FFF | ((((unsigned __int16)((v14 + 2) / 4)
                                                                                                  + 255) & 0x1FF) << 15);
  return (v4 | ((((unsigned __int16)((v13 + 2) / 4) + 255) & 0x1FF) << 6)) & 0x7FFF | ((((unsigned __int16)((v14 + 2) / 4)
                                                                                       + 255) & 0x1FF) << 15) & 0xFFFFFF | ((unsigned __int8)(int)(*((float *)&unk_8665480 + 140 * (v6 - (v5 >> 6 << 6)) + 82) * 0.71111113) << 24);
}

//----- (080F721C) --------------------------------------------------------
int *__cdecl G_BroadcastVoice(int *a1, int a2)
{
  int *result; // eax
  int *v3; // [esp+10h] [ebp-8h]
  int i; // [esp+14h] [ebp-4h] BYREF

  result = (int *)dword_859B5EC;
  *(_DWORD *)(a1[86] + 10248) = dword_859B5EC;
  for ( i = 0; i <= 63; ++i )
  {
    v3 = (int *)((char *)&unk_8665480 + 560 * i);
    if ( *((_BYTE *)v3 + 252)
      && v3[86]
      && (*(_BYTE *)(voice_global + 8) || sub_8119C40((int)a1, (int)v3) || !*(_DWORD *)(a1[86] + 10060))
      && (*(_DWORD *)(v3[86] + 9896) == *(_DWORD *)(a1[86] + 9896)
       || (*(_DWORD *)(v3[86] + 9896) == 1 || *(_DWORD *)(a1[86] + 9896) == 1) && *(_BYTE *)(voice_deadChat + 8))
      && (a1 != v3 || *(_BYTE *)(voice_localEcho + 8))
      && !(unsigned __int8)SV_ClientHasClientMuted(i, *a1) )
    {
      if ( (unsigned __int8)sub_809A000(i) )
        sub_809A040(*a1, i, a2);
    }
    result = &i;
  }
  return result;
}
// 8793DDC: using guessed type int voice_localEcho;
// 8793DE0: using guessed type int voice_global;
// 8793DE4: using guessed type int voice_deadChat;

//----- (080F736E) --------------------------------------------------------
float *__cdecl sub_80F736E(float *a1, float *a2, float *a3)
{
  float *result; // eax

  *a3 = *a1 - *a2;
  result = a1 + 1;
  a3[1] = a1[1] - a2[1];
  return result;
}

//----- (080F739A) --------------------------------------------------------
int __cdecl sub_80F739A(_DWORD *a1, _DWORD *a2)
{
  int result; // eax

  *a2 = *a1;
  a2[1] = a1[1];
  result = a1[2];
  a2[2] = result;
  return result;
}

//----- (080F73CA) --------------------------------------------------------
float *__cdecl sub_80F73CA(float *a1, float a2, float *a3, float *a4)
{
  float *result; // eax

  *a4 = a2 * *a3 + *a1;
  a4[1] = a2 * a3[1] + a1[1];
  result = a3 + 2;
  a4[2] = a2 * a3[2] + a1[2];
  return result;
}

//----- (080F7420) --------------------------------------------------------
int __cdecl sub_80F7420(int a1)
{
  char *v1; // eax
  int v2; // ebx
  int v3; // eax
  char *v4; // eax
  char *v5; // eax
  int result; // eax
  char *v7; // [esp+18h] [ebp-20h]
  int v8; // [esp+1Ch] [ebp-1Ch]
  int v9; // [esp+20h] [ebp-18h]
  int v10; // [esp+28h] [ebp-10h]
  char *s1; // [esp+2Ch] [ebp-Ch]
  int v12; // [esp+30h] [ebp-8h]

  if ( HIWORD(a1) )
  {
    Scr_ObjectError((int)"not an entity");
    v7 = 0;
  }
  else
  {
    v7 = (char *)&unk_8665480 + 560 * (unsigned __int16)a1;
    if ( !*((_DWORD *)v7 + 86) )
    {
      v1 = va("entity %i is not a player", (unsigned __int16)a1);
      Scr_ObjectError((int)v1);
    }
  }
  s1 = (char *)Scr_GetString(0);
  v10 = G_GetWeaponIndexForName(s1);
  v8 = *((_DWORD *)v7 + 86);
  v9 = (unsigned __int8)sub_80D9E84(v8 + 1348, v10);
  v12 = BG_WeaponDefs(v10);
  if ( sub_80E9882(v10) && !sub_80E9C10(v8, v10) )
  {
    v2 = BG_WeaponDefs(*(char *)(v8 + 1366));
    v3 = BG_WeaponDefs(*(char *)(v8 + 1365));
    v4 = va(
           "Cannot give %s weapon %s without having an empty weapon slot - player currently has a %s and a %s\n",
           (const char *)(*((_DWORD *)v7 + 86) + 10116),
           *(const char **)(v12 + 4),
           *(const char **)(v3 + 4),
           *(const char **)(v2 + 4));
    Scr_ParamError(0, (int)v4);
  }
  if ( sub_811E696(v8, v10) )
  {
    v5 = va("%c \"%i\"", 73, 1);
    SV_GameSendServerCommand(-1963413621 * ((v7 - (char *)&unk_8665480) >> 4), 0, v5);
  }
  result = *(_DWORD *)(v12 + 448) - *(_DWORD *)(v8 + 4 * *(_DWORD *)(v12 + 456) + 324);
  if ( result > 0 )
    return sub_8102704((int)v7, v10, result, v9 == 0);
  return result;
}

//----- (080F761E) --------------------------------------------------------
int __cdecl sub_80F761E(int a1)
{
  char *v1; // eax
  int v2; // ebx
  int v3; // ebx
  char *v5; // [esp+8h] [ebp-10h]
  int v6; // [esp+Ch] [ebp-Ch]
  char *s1; // [esp+10h] [ebp-8h]

  if ( HIWORD(a1) )
  {
    Scr_ObjectError((int)"not an entity");
    v5 = 0;
  }
  else
  {
    v5 = (char *)&unk_8665480 + 560 * (unsigned __int16)a1;
    if ( !*((_DWORD *)v5 + 86) )
    {
      v1 = va("entity %i is not a player", (unsigned __int16)a1);
      Scr_ObjectError((int)v1);
    }
  }
  s1 = (char *)Scr_GetString(0);
  v6 = G_GetWeaponIndexForName(s1);
  v2 = *((_DWORD *)v5 + 86);
  *(_DWORD *)(v2 + 4 * sub_80EAC94(v6) + 324) = 0;
  v3 = *((_DWORD *)v5 + 86);
  *(_DWORD *)(v3 + 4 * sub_80EAC7A(v6) + 836) = 0;
  return sub_80E98CA(*((_DWORD *)v5 + 86), v6);
}

//----- (080F76F8) --------------------------------------------------------
int __cdecl sub_80F76F8(int a1)
{
  char *v1; // eax
  int result; // eax
  int v3; // ebx
  int v4; // ebx
  char *v5; // [esp+Ch] [ebp-Ch]
  int i; // [esp+10h] [ebp-8h]

  if ( HIWORD(a1) )
  {
    Scr_ObjectError((int)"not an entity");
    v5 = 0;
  }
  else
  {
    v5 = (char *)&unk_8665480 + 560 * (unsigned __int16)a1;
    if ( !*((_DWORD *)v5 + 86) )
    {
      v1 = va("entity %i is not a player", (unsigned __int16)a1);
      Scr_ObjectError((int)v1);
    }
  }
  *(_DWORD *)(*((_DWORD *)v5 + 86) + 212) = 0;
  for ( i = 1; ; ++i )
  {
    result = BG_GetNumWeapons();
    if ( i > result )
      break;
    v3 = *((_DWORD *)v5 + 86);
    *(_DWORD *)(v3 + 4 * sub_80EAC94(i) + 324) = 0;
    v4 = *((_DWORD *)v5 + 86);
    *(_DWORD *)(v4 + 4 * sub_80EAC7A(i) + 836) = 0;
    sub_80E98CA(*((_DWORD *)v5 + 86), i);
  }
  return result;
}

//----- (080F77E2) --------------------------------------------------------
_BOOL4 __cdecl sub_80F77E2(int a1)
{
  return *(_DWORD *)(*(_DWORD *)(a1 + 344) + 9896) == 0;
}

//----- (080F77FE) --------------------------------------------------------
int __cdecl sub_80F77FE(int a1)
{
  char *v1; // eax
  char *v3; // [esp+8h] [ebp-10h]
  int v4; // [esp+Ch] [ebp-Ch]
  char **v5; // [esp+14h] [ebp-4h]

  if ( HIWORD(a1) )
  {
    Scr_ObjectError((int)"not an entity");
    v3 = 0;
  }
  else
  {
    v3 = (char *)&unk_8665480 + 560 * (unsigned __int16)a1;
    if ( !*((_DWORD *)v3 + 86) )
    {
      v1 = va("entity %i is not a player", (unsigned __int16)a1);
      Scr_ObjectError((int)v1);
    }
  }
  if ( !sub_80F77E2((int)v3) )
    return Scr_AddString("none");
  v4 = *(_DWORD *)(*((_DWORD *)v3 + 86) + 212);
  if ( v4 <= 0 )
    return Scr_AddString("none");
  v5 = (char **)BG_WeaponDefs(v4);
  return Scr_AddString(*v5);
}

//----- (080F78C4) --------------------------------------------------------
int __cdecl sub_80F78C4(int a1)
{
  char *v1; // eax
  char *v3; // [esp+10h] [ebp-8h]
  char **v4; // [esp+14h] [ebp-4h]

  if ( HIWORD(a1) )
  {
    Scr_ObjectError((int)"not an entity");
    v3 = 0;
  }
  else
  {
    v3 = (char *)&unk_8665480 + 560 * (unsigned __int16)a1;
    if ( !*((_DWORD *)v3 + 86) )
    {
      v1 = va("entity %i is not a player", (unsigned __int16)a1);
      Scr_ObjectError((int)v1);
    }
  }
  if ( !sub_80F77E2((int)v3) || *(int *)(*((_DWORD *)v3 + 86) + 208) <= 0 )
    return Scr_AddString("none");
  v4 = (char **)BG_WeaponDefs(*(_DWORD *)(*((_DWORD *)v3 + 86) + 208));
  return Scr_AddString(*v4);
}

//----- (080F798A) --------------------------------------------------------
int __cdecl sub_80F798A(int a1)
{
  char *v1; // eax
  char *v3; // [esp+Ch] [ebp-Ch]
  int v4; // [esp+10h] [ebp-8h]
  char *v5; // [esp+14h] [ebp-4h]

  if ( HIWORD(a1) )
  {
    Scr_ObjectError((int)"not an entity");
    v3 = 0;
  }
  else
  {
    v3 = (char *)&unk_8665480 + 560 * (unsigned __int16)a1;
    if ( !*((_DWORD *)v3 + 86) )
    {
      v1 = va("entity %i is not a player", (unsigned __int16)a1);
      Scr_ObjectError((int)v1);
    }
  }
  v5 = (char *)Scr_GetString(0);
  v4 = BG_FindWeaponIndexForName(v5);
  if ( v4 && (unsigned __int8)sub_80D9E84(*((_DWORD *)v3 + 86) + 1348, v4) )
    return Scr_AddBool(1);
  else
    return Scr_AddBool(0);
}

//----- (080F7A4A) --------------------------------------------------------
int __cdecl sub_80F7A4A(int a1)
{
  char *v1; // eax
  char *v2; // eax
  char *v4; // [esp+Ch] [ebp-Ch]
  int v5; // [esp+10h] [ebp-8h]
  char *s1; // [esp+14h] [ebp-4h]

  if ( HIWORD(a1) )
  {
    Scr_ObjectError((int)"not an entity");
    v4 = 0;
  }
  else
  {
    v4 = (char *)&unk_8665480 + 560 * (unsigned __int16)a1;
    if ( !*((_DWORD *)v4 + 86) )
    {
      v1 = va("entity %i is not a player", (unsigned __int16)a1);
      Scr_ObjectError((int)v1);
    }
  }
  s1 = (char *)Scr_GetString(0);
  v5 = G_GetWeaponIndexForName(s1);
  if ( !v5 )
  {
    v2 = va("unknown weapon '%s'", s1);
    Scr_ParamError(0, (int)v2);
  }
  if ( !(unsigned __int8)sub_80D9E84(*((_DWORD *)v4 + 86) + 1348, v5) )
    return Scr_AddBool(0);
  sub_811E97A((unsigned __int16)a1, v5);
  return Scr_AddBool(1);
}

//----- (080F7B40) --------------------------------------------------------
int __cdecl sub_80F7B40(int a1)
{
  char *v1; // eax
  char *v2; // eax
  char *v4; // [esp+Ch] [ebp-Ch]
  int v5; // [esp+10h] [ebp-8h]
  char *s1; // [esp+14h] [ebp-4h]

  if ( HIWORD(a1) )
  {
    Scr_ObjectError((int)"not an entity");
    v4 = 0;
  }
  else
  {
    v4 = (char *)&unk_8665480 + 560 * (unsigned __int16)a1;
    if ( !*((_DWORD *)v4 + 86) )
    {
      v1 = va("entity %i is not a player", (unsigned __int16)a1);
      Scr_ObjectError((int)v1);
    }
  }
  s1 = (char *)Scr_GetString(0);
  v5 = G_GetWeaponIndexForName(s1);
  if ( !v5 )
  {
    v2 = va("unknown weapon '%s'", s1);
    Scr_ParamError(0, (int)v2);
  }
  if ( !(unsigned __int8)sub_80D9E84(*((_DWORD *)v4 + 86) + 1348, v5) )
    return Scr_AddBool(0);
  sub_811E9B4((unsigned __int16)a1, v5);
  return Scr_AddBool(1);
}

//----- (080F7C36) --------------------------------------------------------
int __cdecl sub_80F7C36(int a1)
{
  char *v1; // eax
  int result; // eax
  char *v3; // [esp+14h] [ebp-14h]
  int v4; // [esp+1Ch] [ebp-Ch]
  char *s1; // [esp+20h] [ebp-8h]
  int v6; // [esp+24h] [ebp-4h]

  if ( HIWORD(a1) )
  {
    Scr_ObjectError((int)"not an entity");
    v3 = 0;
  }
  else
  {
    v3 = (char *)&unk_8665480 + 560 * (unsigned __int16)a1;
    if ( !*((_DWORD *)v3 + 86) )
    {
      v1 = va("entity %i is not a player", (unsigned __int16)a1);
      Scr_ObjectError((int)v1);
    }
  }
  s1 = (char *)Scr_GetString(0);
  v4 = G_GetWeaponIndexForName(s1);
  result = sub_80D9E84(*((_DWORD *)v3 + 86) + 1348, v4);
  if ( (_BYTE)result )
  {
    v6 = BG_WeaponDefs(v4);
    result = *(_DWORD *)(v6 + 448) - *(_DWORD *)(*((_DWORD *)v3 + 86) + 4 * *(_DWORD *)(v6 + 456) + 324);
    if ( result > 0 )
      return sub_8102704((int)v3, v4, result, 0);
  }
  return result;
}

//----- (080F7D32) --------------------------------------------------------
int __cdecl sub_80F7D32(int a1)
{
  char *v1; // eax
  int result; // eax
  char *v3; // [esp+14h] [ebp-14h]
  int v4; // [esp+1Ch] [ebp-Ch]
  char *s1; // [esp+20h] [ebp-8h]
  int v6; // [esp+24h] [ebp-4h]

  if ( HIWORD(a1) )
  {
    Scr_ObjectError((int)"not an entity");
    v3 = 0;
  }
  else
  {
    v3 = (char *)&unk_8665480 + 560 * (unsigned __int16)a1;
    if ( !*((_DWORD *)v3 + 86) )
    {
      v1 = va("entity %i is not a player", (unsigned __int16)a1);
      Scr_ObjectError((int)v1);
    }
  }
  s1 = (char *)Scr_GetString(0);
  v4 = G_GetWeaponIndexForName(s1);
  result = sub_80D9E84(*((_DWORD *)v3 + 86) + 1348, v4);
  if ( (_BYTE)result )
  {
    v6 = BG_WeaponDefs(v4);
    result = sub_80E9336(*(_DWORD *)(v6 + 456)) - *(_DWORD *)(*((_DWORD *)v3 + 86) + 4 * *(_DWORD *)(v6 + 456) + 324);
    if ( result > 0 )
      return sub_8102704((int)v3, v4, result, 0);
  }
  return result;
}

//----- (080F7E38) --------------------------------------------------------
int __cdecl sub_80F7E38(int a1)
{
  char *v1; // eax
  char *v3; // [esp+14h] [ebp-14h]
  int v4; // [esp+18h] [ebp-10h]
  int v5; // [esp+1Ch] [ebp-Ch]
  char *s1; // [esp+20h] [ebp-8h]
  int v7; // [esp+24h] [ebp-4h]

  if ( HIWORD(a1) )
  {
    Scr_ObjectError((int)"not an entity");
    v3 = 0;
  }
  else
  {
    v3 = (char *)&unk_8665480 + 560 * (unsigned __int16)a1;
    if ( !*((_DWORD *)v3 + 86) )
    {
      v1 = va("entity %i is not a player", (unsigned __int16)a1);
      Scr_ObjectError((int)v1);
    }
  }
  s1 = (char *)Scr_GetString(0);
  v5 = G_GetWeaponIndexForName(s1);
  if ( !(unsigned __int8)sub_80D9E84(*((_DWORD *)v3 + 86) + 1348, v5) )
    return Scr_AddFloat(1065353216);
  v7 = BG_WeaponDefs(v5);
  if ( *(int *)(v7 + 448) <= 0 )
    return Scr_AddFloat(1065353216);
  if ( *(int *)(*((_DWORD *)v3 + 86) + 4 * *(_DWORD *)(v7 + 456) + 324) <= 0 )
    return Scr_AddFloat(0);
  *(float *)&v4 = (long double)*(int *)(*((_DWORD *)v3 + 86) + 4 * *(_DWORD *)(v7 + 456) + 324)
                / (long double)*(int *)(v7 + 448);
  return Scr_AddFloat(v4);
}

//----- (080F7F72) --------------------------------------------------------
int __cdecl sub_80F7F72(int a1)
{
  char *v1; // eax
  float v3; // [esp+10h] [ebp-18h]
  char *v4; // [esp+14h] [ebp-14h]
  int v5; // [esp+18h] [ebp-10h]
  int v6; // [esp+1Ch] [ebp-Ch]
  char *s1; // [esp+20h] [ebp-8h]
  int v8; // [esp+24h] [ebp-4h]

  if ( HIWORD(a1) )
  {
    Scr_ObjectError((int)"not an entity");
    v4 = 0;
  }
  else
  {
    v4 = (char *)&unk_8665480 + 560 * (unsigned __int16)a1;
    if ( !*((_DWORD *)v4 + 86) )
    {
      v1 = va("entity %i is not a player", (unsigned __int16)a1);
      Scr_ObjectError((int)v1);
    }
  }
  s1 = (char *)Scr_GetString(0);
  v6 = G_GetWeaponIndexForName(s1);
  if ( !(unsigned __int8)sub_80D9E84(*((_DWORD *)v4 + 86) + 1348, v6) )
    return Scr_AddFloat(1065353216);
  v8 = BG_WeaponDefs(v6);
  if ( sub_80E9336(*(_DWORD *)(v8 + 456)) <= 0 )
    return Scr_AddFloat(1065353216);
  if ( *(int *)(*((_DWORD *)v4 + 86) + 4 * *(_DWORD *)(v8 + 456) + 324) <= 0 )
    return Scr_AddFloat(0);
  v3 = (float)*(int *)(*((_DWORD *)v4 + 86) + 4 * *(_DWORD *)(v8 + 456) + 324);
  *(float *)&v5 = v3 / (long double)sub_80E9336(*(_DWORD *)(v8 + 456));
  return Scr_AddFloat(v5);
}

//----- (080F80CC) --------------------------------------------------------
int __cdecl sub_80F80CC(int a1)
{
  char *v1; // eax
  char *v3; // [esp+1Ch] [ebp-1Ch]
  _DWORD v4[6]; // [esp+20h] [ebp-18h] BYREF

  if ( HIWORD(a1) )
  {
    Scr_ObjectError((int)"not an entity");
    v3 = 0;
  }
  else
  {
    v3 = (char *)&unk_8665480 + 560 * (unsigned __int16)a1;
    if ( !*((_DWORD *)v3 + 86) )
    {
      v1 = va("entity %i is not a player", (unsigned __int16)a1);
      Scr_ObjectError((int)v1);
    }
  }
  Scr_GetVector(0, v4);
  SV_UnlinkEntity((int)v3);
  sub_80FB6EE(v4, (_DWORD *)(*((_DWORD *)v3 + 86) + 20));
  *(float *)(*((_DWORD *)v3 + 86) + 28) = *(float *)(*((_DWORD *)v3 + 86) + 28) + 1.0;
  *(_DWORD *)(*((_DWORD *)v3 + 86) + 160) ^= 2u;
  sub_80DD59E(*((_DWORD *)v3 + 86), (int)v3, 1, 1u);
  sub_80FB6EE((_DWORD *)(*((_DWORD *)v3 + 86) + 20), (_DWORD *)v3 + 78);
  return SV_LinkEntity((int)v3);
}
// 80F80CC: using guessed type _DWORD var_18[6];

//----- (080F81F8) --------------------------------------------------------
int __usercall sub_80F81F8@<eax>(long double a1@<st0>, int a2)
{
  char *v2; // eax
  char *v4; // [esp+1Ch] [ebp-1Ch]
  _DWORD v5[6]; // [esp+20h] [ebp-18h] BYREF

  if ( HIWORD(a2) )
  {
    Scr_ObjectError((int)"not an entity");
    v4 = 0;
  }
  else
  {
    v4 = (char *)&unk_8665480 + 560 * (unsigned __int16)a2;
    if ( !*((_DWORD *)v4 + 86) )
    {
      v2 = va("entity %i is not a player", (unsigned __int16)a2);
      Scr_ObjectError((int)v2);
    }
  }
  Scr_GetVector(0, v5);
  return sub_80F5E80(a1, (int)v4, v5);
}
// 80F81F8: using guessed type _DWORD var_18[6];

//----- (080F8280) --------------------------------------------------------
_DWORD *__cdecl sub_80F8280(int a1)
{
  char *v1; // eax
  char *v3; // [esp+14h] [ebp-4h]

  if ( HIWORD(a1) )
  {
    Scr_ObjectError((int)"not an entity");
    v3 = 0;
  }
  else
  {
    v3 = (char *)&unk_8665480 + 560 * (unsigned __int16)a1;
    if ( !*((_DWORD *)v3 + 86) )
    {
      v1 = va("entity %i is not a player", (unsigned __int16)a1);
      Scr_ObjectError((int)v1);
    }
  }
  return Scr_AddVector((_DWORD *)(*((_DWORD *)v3 + 86) + 232));
}

//----- (080F82F8) --------------------------------------------------------
int __cdecl sub_80F82F8(int a1)
{
  char *v1; // eax
  char *v3; // [esp+14h] [ebp-4h]

  if ( HIWORD(a1) )
  {
    Scr_ObjectError((int)"not an entity");
    v3 = 0;
  }
  else
  {
    v3 = (char *)&unk_8665480 + 560 * (unsigned __int16)a1;
    if ( !*((_DWORD *)v3 + 86) )
    {
      v1 = va("entity %i is not a player", (unsigned __int16)a1);
      Scr_ObjectError((int)v1);
    }
  }
  if ( ((*(_DWORD *)(*((_DWORD *)v3 + 86) + 10184) | *(_DWORD *)(*((_DWORD *)v3 + 86) + 10172)) & 0x28) != 0 )
    return Scr_AddInt(1);
  else
    return Scr_AddInt(0);
}

//----- (080F839A) --------------------------------------------------------
int __cdecl sub_80F839A(int a1)
{
  char *v1; // eax
  char *v3; // [esp+14h] [ebp-4h]

  if ( HIWORD(a1) )
  {
    Scr_ObjectError((int)"not an entity");
    v3 = 0;
  }
  else
  {
    v3 = (char *)&unk_8665480 + 560 * (unsigned __int16)a1;
    if ( !*((_DWORD *)v3 + 86) )
    {
      v1 = va("entity %i is not a player", (unsigned __int16)a1);
      Scr_ObjectError((int)v1);
    }
  }
  if ( ((*(_BYTE *)(*((_DWORD *)v3 + 86) + 10184) | *(_BYTE *)(*((_DWORD *)v3 + 86) + 10172)) & 1) != 0 )
    return Scr_AddInt(1);
  else
    return Scr_AddInt(0);
}

//----- (080F843C) --------------------------------------------------------
int __cdecl sub_80F843C(int a1)
{
  char *v1; // eax
  char *v3; // [esp+14h] [ebp-4h]

  if ( HIWORD(a1) )
  {
    Scr_ObjectError((int)"not an entity");
    v3 = 0;
  }
  else
  {
    v3 = (char *)&unk_8665480 + 560 * (unsigned __int16)a1;
    if ( !*((_DWORD *)v3 + 86) )
    {
      v1 = va("entity %i is not a player", (unsigned __int16)a1);
      Scr_ObjectError((int)v1);
    }
  }
  if ( ((*(_DWORD *)(*((_DWORD *)v3 + 86) + 10184) | *(_DWORD *)(*((_DWORD *)v3 + 86) + 10172)) & 4) != 0 )
    return Scr_AddInt(1);
  else
    return Scr_AddInt(0);
}

//----- (080F84DE) --------------------------------------------------------
int __cdecl sub_80F84DE(int a1)
{
  char *v1; // eax
  char *v3; // [esp+14h] [ebp-4h]

  if ( HIWORD(a1) )
  {
    Scr_ObjectError((int)"not an entity");
    v3 = 0;
  }
  else
  {
    v3 = (char *)&unk_8665480 + 560 * (unsigned __int16)a1;
    if ( !*((_DWORD *)v3 + 86) )
    {
      v1 = va("entity %i is not a player", (unsigned __int16)a1);
      Scr_ObjectError((int)v1);
    }
  }
  return Scr_AddFloat(*(_DWORD *)(*((_DWORD *)v3 + 86) + 220));
}

//----- (080F8558) --------------------------------------------------------
int __cdecl sub_80F8558(int a1)
{
  char *v1; // eax
  char *v3; // [esp+14h] [ebp-4h]

  if ( HIWORD(a1) )
  {
    Scr_ObjectError((int)"not an entity");
    v3 = 0;
  }
  else
  {
    v3 = (char *)&unk_8665480 + 560 * (unsigned __int16)a1;
    if ( !*((_DWORD *)v3 + 86) )
    {
      v1 = va("entity %i is not a player", (unsigned __int16)a1);
      Scr_ObjectError((int)v1);
    }
  }
  if ( *(_DWORD *)(*((_DWORD *)v3 + 86) + 96) == 1023 )
    return Scr_AddInt(0);
  else
    return Scr_AddInt(1);
}

//----- (080F85E6) --------------------------------------------------------
int __cdecl sub_80F85E6(int a1)
{
  char *v1; // eax
  int result; // eax
  char *v3; // [esp+14h] [ebp-4h]

  if ( HIWORD(a1) )
  {
    Scr_ObjectError((int)"not an entity");
    v3 = 0;
  }
  else
  {
    v3 = (char *)&unk_8665480 + 560 * (unsigned __int16)a1;
    if ( !*((_DWORD *)v3 + 86) )
    {
      v1 = va("entity %i is not a player", (unsigned __int16)a1);
      Scr_ObjectError((int)v1);
    }
  }
  *(_DWORD *)(*((_DWORD *)v3 + 86) + 160) |= 0x400000u;
  result = dword_859B5EC + 3000;
  *(_DWORD *)(*((_DWORD *)v3 + 86) + 10300) = dword_859B5EC + 3000;
  return result;
}

//----- (080F8684) --------------------------------------------------------
int __cdecl PlayerCmd_SetViewmodel(int a1)
{
  char *v1; // eax
  int result; // eax
  char *v3; // [esp+Ch] [ebp-Ch]
  char *s2; // [esp+14h] [ebp-4h]

  if ( HIWORD(a1) )
  {
    Scr_ObjectError((int)"not an entity");
    v3 = 0;
  }
  else
  {
    v3 = (char *)&unk_8665480 + 560 * (unsigned __int16)a1;
    if ( !*((_DWORD *)v3 + 86) )
    {
      v1 = va("entity %i is not a player", (unsigned __int16)a1);
      Scr_ObjectError((int)v1);
    }
  }
  s2 = (char *)Scr_GetString(0);
  if ( !s2 || !*s2 )
    Scr_ParamError(0, (int)"usage: setviewmodel(<model name>)");
  result = G_ModelIndex(s2);
  *(_DWORD *)(*((_DWORD *)v3 + 86) + 10044) = result;
  return result;
}

//----- (080F8738) --------------------------------------------------------
int __cdecl sub_80F8738(int a1)
{
  char *v1; // eax
  char *v3; // [esp+10h] [ebp-8h]
  char *s; // [esp+14h] [ebp-4h]

  if ( HIWORD(a1) )
  {
    Scr_ObjectError((int)"not an entity");
    v3 = 0;
  }
  else
  {
    v3 = (char *)&unk_8665480 + 560 * (unsigned __int16)a1;
    if ( !*((_DWORD *)v3 + 86) )
    {
      v1 = va("entity %i is not a player", (unsigned __int16)a1);
      Scr_ObjectError((int)v1);
    }
  }
  s = (char *)G_ModelName(*(_DWORD *)(*((_DWORD *)v3 + 86) + 10044));
  return Scr_AddString(s);
}

//----- (080F87C0) --------------------------------------------------------
int __cdecl sub_80F87C0(int a1)
{
  char *v1; // eax
  char *v3; // [esp+14h] [ebp-4h]

  if ( HIWORD(a1) )
  {
    Scr_ObjectError((int)"not an entity");
    v3 = 0;
  }
  else
  {
    v3 = (char *)&unk_8665480 + 560 * (unsigned __int16)a1;
    if ( !*((_DWORD *)v3 + 86) )
    {
      v1 = va("entity %i is not a player", (unsigned __int16)a1);
      Scr_ObjectError((int)v1);
    }
  }
  return sub_80FB982((int)v3);
}

//----- (080F882E) --------------------------------------------------------
int __cdecl sub_80F882E(int a1)
{
  char *v1; // eax
  int result; // eax
  char *v3; // [esp+Ch] [ebp-Ch]
  int v4; // [esp+10h] [ebp-8h]
  char *s1; // [esp+14h] [ebp-4h]

  if ( HIWORD(a1) )
  {
    Scr_ObjectError((int)"not an entity");
    v3 = 0;
  }
  else
  {
    v3 = (char *)&unk_8665480 + 560 * (unsigned __int16)a1;
    if ( !*((_DWORD *)v3 + 86) )
    {
      v1 = va("entity %i is not a player", (unsigned __int16)a1);
      Scr_ObjectError((int)v1);
    }
  }
  s1 = (char *)Scr_GetString(0);
  v4 = G_GetWeaponIndexForName(s1);
  result = BG_IsWeaponValid(*((_DWORD *)v3 + 86), v4);
  if ( (_BYTE)result )
  {
    *(_DWORD *)(*((_DWORD *)v3 + 86) + 212) = v4;
    result = *((_DWORD *)v3 + 86);
    *(_DWORD *)(result + 216) = 0;
  }
  return result;
}

//----- (080F88EE) --------------------------------------------------------
int __cdecl sub_80F88EE(int a1)
{
  char *v1; // eax
  int *v2; // eax
  char *v4; // [esp+10h] [ebp-18h]
  char *v5; // [esp+14h] [ebp-14h]
  int *v6; // [esp+18h] [ebp-10h]
  int v7; // [esp+1Ch] [ebp-Ch]
  int v8; // [esp+20h] [ebp-8h]
  char *s1; // [esp+24h] [ebp-4h]

  if ( HIWORD(a1) )
  {
    Scr_ObjectError((int)"not an entity");
    v4 = 0;
  }
  else
  {
    v4 = (char *)&unk_8665480 + 560 * (unsigned __int16)a1;
    if ( !*((_DWORD *)v4 + 86) )
    {
      v1 = va("entity %i is not a player", (unsigned __int16)a1);
      Scr_ObjectError((int)v1);
    }
  }
  s1 = (char *)Scr_GetString(0);
  v8 = G_GetWeaponIndexForName(s1);
  if ( v8 )
  {
    if ( (unsigned int)Scr_GetNumParam() <= 1 )
    {
      v2 = (int *)sub_810404E((int)v4, v8, (unsigned __int16)word_87A2346);
    }
    else
    {
      v7 = sub_8084434(1u);
      v2 = (int *)sub_810404E((int)v4, v8, v7);
    }
    return GScr_AddEntity(v2);
  }
  else
  {
    v5 = sub_80DCB02(s1);
    if ( v5 )
    {
      v6 = (int *)sub_8103F44((int)v4, (int)v5, 0.0, 0);
      return GScr_AddEntity(v6);
    }
    else
    {
      return GScr_AddEntity(0);
    }
  }
}
// 87A2346: using guessed type __int16 word_87A2346;

//----- (080F8A04) --------------------------------------------------------
int __cdecl sub_80F8A04(int a1)
{
  char *v1; // eax
  int result; // eax
  char *v3; // eax
  char *v4; // eax
  __int16 v5; // ax
  _DWORD *v6; // eax
  _DWORD *v7; // eax
  int v8; // ebx
  float v9; // [esp+4h] [ebp-104h]
  char *v10; // [esp+44h] [ebp-C4h]
  float v11; // [esp+48h] [ebp-C0h]
  float v12; // [esp+4Ch] [ebp-BCh]
  float v13; // [esp+50h] [ebp-B8h]
  void (__cdecl *v14)(char *, int *, int, _DWORD *, int, int *, int); // [esp+58h] [ebp-B0h]
  void (__cdecl *v15)(char *, int *, int *, int, int, int, int *, int, int); // [esp+5Ch] [ebp-ACh]
  _DWORD *v16; // [esp+60h] [ebp-A8h]
  int v17; // [esp+64h] [ebp-A4h]
  int v18; // [esp+68h] [ebp-A0h]
  int v19[4]; // [esp+70h] [ebp-98h] BYREF
  int v20[4]; // [esp+80h] [ebp-88h] BYREF
  float v21; // [esp+90h] [ebp-78h]
  int v22; // [esp+94h] [ebp-74h]
  int v23; // [esp+98h] [ebp-70h]
  int v24; // [esp+9Ch] [ebp-6Ch]
  int v25; // [esp+A0h] [ebp-68h]
  int v26; // [esp+A4h] [ebp-64h]
  int v27; // [esp+A8h] [ebp-60h]
  _DWORD *v28; // [esp+ACh] [ebp-5Ch]
  _DWORD v29[7]; // [esp+B0h] [ebp-58h] BYREF
  float *v30; // [esp+CCh] [ebp-3Ch]
  _DWORD v31[6]; // [esp+D0h] [ebp-38h] BYREF
  int *v32; // [esp+E8h] [ebp-20h]
  int *v33; // [esp+ECh] [ebp-1Ch]

  v33 = &dword_86F1020;
  v32 = &dword_86F1020;
  v30 = 0;
  v28 = 0;
  if ( HIWORD(a1) )
  {
    Scr_ObjectError((int)"not an entity");
    v10 = 0;
  }
  else
  {
    v10 = (char *)&unk_8665480 + 560 * (unsigned __int16)a1;
    if ( !*((_DWORD *)v10 + 86) )
    {
      v1 = va("entity %i is not a player", (unsigned __int16)a1);
      Scr_ObjectError((int)v1);
    }
  }
  result = Scr_GetInt(2u);
  v27 = result;
  if ( result > 0 )
  {
    if ( Scr_GetType(0) && Scr_GetPointerType(0) == 21 )
      v33 = (int *)Scr_GetEntity(1u);
    if ( Scr_GetType(1u) && Scr_GetPointerType(1u) == 21 )
      v32 = (int *)Scr_GetEntity(1u);
    v26 = Scr_GetInt(3u);
    v3 = (char *)Scr_GetString(4u);
    v25 = G_IndexForMeansOfDeath(v3);
    v4 = (char *)Scr_GetString(5u);
    v24 = G_GetWeaponIndexForName(v4);
    if ( Scr_GetType(6u) )
    {
      Scr_GetVector(6u, v29);
      v28 = v29;
    }
    if ( Scr_GetType(7u) )
    {
      Scr_GetVector(7u, v31);
      v30 = (float *)v31;
    }
    v5 = Scr_GetConstString(8u);
    v23 = sub_81003F6(v5);
    v17 = Scr_GetInt(9u);
    if ( v30 )
      sub_80A2298(v30, (int)v20);
    else
      sub_80FB6C4(v20);
    if ( (*((_DWORD *)v10 + 93) & 8) != 0 || (v26 & 4) != 0 )
    {
      v22 = 0;
    }
    else
    {
      v21 = 0.30000001;
      if ( (*(_BYTE *)(*((_DWORD *)v10 + 86) + 12) & 1) != 0 )
      {
        v21 = 0.02;
      }
      else if ( (*(_DWORD *)(*((_DWORD *)v10 + 86) + 12) & 2) != 0 )
      {
        v21 = 0.15000001;
      }
      v22 = (int)((long double)v27 * v21);
      if ( v22 > 60 )
        v22 = 60;
      if ( v22 )
      {
        if ( (*(_DWORD *)(*((_DWORD *)v10 + 86) + 160) & 0x300) == 0 )
        {
          v9 = (long double)v22 * *(float *)(g_knockback + 8) / 250.0;
          sub_80FB762((float *)v20, v9, (float *)v19);
          sub_80FB71E((float *)(*((_DWORD *)v10 + 86) + 32), (float *)v19, (float *)(*((_DWORD *)v10 + 86) + 32));
          if ( !*(_DWORD *)(*((_DWORD *)v10 + 86) + 16) )
          {
            v18 = 2 * v22;
            if ( 2 * v22 <= 49 )
              v18 = 50;
            if ( v18 > 200 )
              v18 = 200;
            *(_DWORD *)(*((_DWORD *)v10 + 86) + 16) = v18;
            *(_DWORD *)(*((_DWORD *)v10 + 86) + 12) |= 0x400u;
          }
        }
      }
    }
    result = *((_DWORD *)v10 + 93) & 1;
    if ( !(_BYTE)result )
    {
      if ( v24 && !*(_DWORD *)(BG_WeaponDefs(v24) + 120) )
      {
        if ( *(_DWORD *)(BG_WeaponDefs(v24) + 796) )
          v6 = G_TempEntity(v29, 183);
        else
          v6 = G_TempEntity(v29, 182);
        v16 = v6;
        v6[40] = (unsigned __int8)DirToByte((float *)v20);
        v16[54] = (unsigned __int8)DirToByte((float *)v20);
        v16[34] = 7;
        v16[29] = *v32;
        v16[(*(int *)(*((_DWORD *)v10 + 86) + 204) >> 5) + 61] |= 1 << (*(_BYTE *)(*((_DWORD *)v10 + 86) + 204) & 0x1F);
        if ( *(_DWORD *)(BG_WeaponDefs(v24) + 796) )
          v7 = G_TempEntity(v29, 186);
        else
          v7 = G_TempEntity(v29, 185);
        v7[34] = 7;
        v7[29] = *v32;
        v7[36] = *(_DWORD *)(*((_DWORD *)v10 + 86) + 204);
        v7[61] = -1;
        v7[62] = -1;
        v7[(*(int *)(*((_DWORD *)v10 + 86) + 204) >> 5) + 61] &= ~(1 << (*(_BYTE *)(*((_DWORD *)v10 + 86) + 204) & 0x1F));
      }
      *(_DWORD *)(*((_DWORD *)v10 + 86) + 10208) += v27;
      if ( v30 )
      {
        sub_80FB6EE(v20, (_DWORD *)(*((_DWORD *)v10 + 86) + 10212));
        *(_DWORD *)(*((_DWORD *)v10 + 86) + 10224) = 0;
      }
      else
      {
        sub_80FB6EE((_DWORD *)v10 + 78, (_DWORD *)(*((_DWORD *)v10 + 86) + 10212));
        *(_DWORD *)(*((_DWORD *)v10 + 86) + 10224) = 1;
      }
      if ( (*((_DWORD *)v10 + 93) & 2) != 0 && *((_DWORD *)v10 + 101) - v27 <= 0 )
        v27 = *((_DWORD *)v10 + 101) - 1;
      v13 = *(float *)(player_dmgtimer_maxTime + 8);
      v12 = (long double)v27 * *(float *)(player_dmgtimer_timePerPoint + 8);
      *(_DWORD *)(*((_DWORD *)v10 + 86) + 144) += (int)v12;
      if ( v30 )
      {
        v8 = *((_DWORD *)v10 + 86);
        *(_DWORD *)(v8 + 152) = (int)sub_80A29F6(v30);
      }
      else
      {
        *(_DWORD *)(*((_DWORD *)v10 + 86) + 152) = 0;
      }
      v11 = *(float *)(*((_DWORD *)v10 + 86) + 236);
      if ( v11 < 0.0 )
        v11 = v11 + 360.0;
      *(_DWORD *)(*((_DWORD *)v10 + 86) + 152) -= (int)v11;
      if ( (long double)*(int *)(*((_DWORD *)v10 + 86) + 144) > v13 )
        *(_DWORD *)(*((_DWORD *)v10 + 86) + 144) = (int)v13;
      *(_DWORD *)(*((_DWORD *)v10 + 86) + 148) = *(_DWORD *)(*((_DWORD *)v10 + 86) + 144);
      *((_DWORD *)v10 + 101) -= v27;
      Scr_AddEntity(v32);
      Scr_AddInt(v27);
      Scr_Notify((int *)v10, word_87A22A8, 2);
      if ( *((int *)v10 + 101) > 0 )
      {
        v14 = (void (__cdecl *)(char *, int *, int, _DWORD *, int, int *, int))dword_8167894[10
                                                                                           * (unsigned __int8)v10[358]];
        if ( v14 )
          v14(v10, v32, v27, v28, v25, v20, v23);
      }
      else
      {
        if ( *((int *)v10 + 101) < -999 )
          *((_DWORD *)v10 + 101) = -999;
        v15 = (void (__cdecl *)(char *, int *, int *, int, int, int, int *, int, int))dword_8167898[10 * (unsigned __int8)v10[358]];
        if ( v15 )
          v15(v10, v33, v32, v27, v25, v24, v20, v23, v17);
        result = (int)v10;
        if ( !v10[252] )
          return result;
      }
      result = *((_DWORD *)v10 + 101);
      *(_DWORD *)(*((_DWORD *)v10 + 86) + 300) = result;
    }
  }
  return result;
}
// 8167894: using guessed type int dword_8167894[];
// 8167898: using guessed type int dword_8167898[];
// 8576110: using guessed type int player_dmgtimer_timePerPoint;
// 8576114: using guessed type int player_dmgtimer_maxTime;
// 86F1020: using guessed type int dword_86F1020;
// 8793D9C: using guessed type int g_knockback;
// 87A22A8: using guessed type __int16 word_87A22A8;
// 80F8A04: using guessed type _DWORD var_58[7];
// 80F8A04: using guessed type _DWORD var_38[6];

//----- (080F9448) --------------------------------------------------------
int __cdecl sub_80F9448(int a1)
{
  char *v1; // eax
  int v2; // edx
  int *v4; // [esp+24h] [ebp-4h]

  if ( HIWORD(a1) )
  {
    Scr_ObjectError((int)"not an entity");
    v4 = 0;
  }
  else
  {
    v4 = (int *)((char *)&unk_8665480 + 560 * (unsigned __int16)a1);
    if ( !v4[86] )
    {
      v1 = va("entity %i is not a player", (unsigned __int16)a1);
      Scr_ObjectError((int)v1);
    }
  }
  v4[93] &= 0xFFFFFFFC;
  v2 = v4[86];
  v4[101] = 0;
  *(_DWORD *)(v2 + 300) = 0;
  return sub_80FF2CA((int)v4, v4, v4, 100000, 0xCu, 0, 0, 0, 0);
}

//----- (080F9528) --------------------------------------------------------
int __cdecl sub_80F9528(int a1)
{
  char *v1; // eax
  char *v2; // eax
  char *v3; // eax
  char *v5; // [esp+10h] [ebp-8h]
  int v6; // [esp+14h] [ebp-4h]

  if ( HIWORD(a1) )
  {
    Scr_ObjectError((int)"not an entity");
    v5 = 0;
  }
  else
  {
    v5 = (char *)&unk_8665480 + 560 * (unsigned __int16)a1;
    if ( !*((_DWORD *)v5 + 86) )
    {
      v1 = va("entity %i is not a player", (unsigned __int16)a1);
      Scr_ObjectError((int)v1);
    }
  }
  if ( *(_DWORD *)(*((_DWORD *)v5 + 86) + 9924) != 2 )
    return Scr_AddInt(0);
  v2 = (char *)Scr_GetString(0);
  v6 = GScr_GetScriptMenuIndex(v2);
  v3 = va("%c %i", 116, v6);
  SV_GameSendServerCommand((unsigned __int16)a1, 1, v3);
  return Scr_AddInt(1);
}

//----- (080F9600) --------------------------------------------------------
int __cdecl sub_80F9600(int a1)
{
  char *v1; // eax
  char *v2; // eax
  char *v3; // eax
  char *v5; // [esp+10h] [ebp-8h]
  int v6; // [esp+14h] [ebp-4h]

  if ( HIWORD(a1) )
  {
    Scr_ObjectError((int)"not an entity");
    v5 = 0;
  }
  else
  {
    v5 = (char *)&unk_8665480 + 560 * (unsigned __int16)a1;
    if ( !*((_DWORD *)v5 + 86) )
    {
      v1 = va("entity %i is not a player", (unsigned __int16)a1);
      Scr_ObjectError((int)v1);
    }
  }
  if ( *(_DWORD *)(*((_DWORD *)v5 + 86) + 9924) != 2 )
    return Scr_AddInt(0);
  v2 = (char *)Scr_GetString(0);
  v6 = GScr_GetScriptMenuIndex(v2);
  v3 = va("%c %i 1", 116, v6);
  SV_GameSendServerCommand((unsigned __int16)a1, 1, v3);
  return Scr_AddInt(1);
}

//----- (080F96D8) --------------------------------------------------------
int __cdecl sub_80F96D8(int a1)
{
  char *v1; // eax
  char *v2; // eax

  if ( HIWORD(a1) )
  {
    Scr_ObjectError((int)"not an entity");
  }
  else if ( !*((_DWORD *)&unk_8665480 + 140 * (unsigned __int16)a1 + 86) )
  {
    v1 = va("entity %i is not a player", (unsigned __int16)a1);
    Scr_ObjectError((int)v1);
  }
  v2 = va("%c", 117);
  return SV_GameSendServerCommand((unsigned __int16)a1, 1, v2);
}

//----- (080F9766) --------------------------------------------------------
int __cdecl sub_80F9766(int a1)
{
  char *v1; // eax
  char *v2; // eax

  if ( HIWORD(a1) )
  {
    Scr_ObjectError((int)"not an entity");
  }
  else if ( !*((_DWORD *)&unk_8665480 + 140 * (unsigned __int16)a1 + 86) )
  {
    v1 = va("entity %i is not a player", (unsigned __int16)a1);
    Scr_ObjectError((int)v1);
  }
  v2 = va("%c", 75);
  return SV_GameSendServerCommand((unsigned __int16)a1, 1, v2);
}

//----- (080F97F4) --------------------------------------------------------
int __cdecl sub_80F97F4(int a1)
{
  char *v1; // eax
  char *v3; // eax
  const char *v4; // eax
  char *v5; // eax
  char *v6; // [esp+14h] [ebp-14h]
  char **v7; // [esp+18h] [ebp-10h]
  int v8; // [esp+20h] [ebp-8h]
  unsigned __int16 v9; // [esp+26h] [ebp-2h]

  if ( HIWORD(a1) )
  {
    Scr_ObjectError((int)"not an entity");
    v6 = 0;
  }
  else
  {
    v6 = (char *)&unk_8665480 + 560 * (unsigned __int16)a1;
    if ( !*((_DWORD *)v6 + 86) )
    {
      v1 = va("entity %i is not a player", (unsigned __int16)a1);
      Scr_ObjectError((int)v1);
    }
  }
  if ( !sub_80F77E2((int)v6) )
    return Scr_AddConstString((unsigned __int16)word_87A2314);
  v9 = Scr_GetConstString(0);
  v3 = (char *)SL_ConvertToString(v9);
  v8 = sub_80F0450(v3);
  if ( !v8 )
  {
    v4 = (const char *)SL_ConvertToString(v9);
    v5 = va("Unknown weaponslot name %s. Valid weaponslots are \"primary\" and \"primaryb\"", v4);
    Scr_ParamError(0, (int)v5);
  }
  if ( !*(_BYTE *)(v8 + *((_DWORD *)v6 + 86) + 1364) )
    return Scr_AddConstString((unsigned __int16)word_87A2314);
  v7 = (char **)BG_WeaponDefs(*(char *)(v8 + *((_DWORD *)v6 + 86) + 1364));
  return Scr_AddString(*v7);
}
// 87A2314: using guessed type __int16 word_87A2314;

//----- (080F991C) --------------------------------------------------------
int __cdecl sub_80F991C(int a1)
{
  char *v1; // eax
  char *v2; // eax
  const char *v3; // eax
  char *v4; // eax
  char *v5; // eax
  char *v6; // ebx
  char *v7; // eax
  char *v8; // eax
  int result; // eax
  char *v10; // [esp+1Ch] [ebp-2Ch]
  int v11; // [esp+20h] [ebp-28h]
  int v12; // [esp+24h] [ebp-24h]
  int *v13; // [esp+28h] [ebp-20h]
  char *s1; // [esp+2Ch] [ebp-1Ch]
  int v15; // [esp+34h] [ebp-14h]
  int v16; // [esp+3Ch] [ebp-Ch]
  unsigned __int16 v17; // [esp+42h] [ebp-6h]

  v11 = 0;
  if ( HIWORD(a1) )
  {
    Scr_ObjectError((int)"not an entity");
    v10 = 0;
  }
  else
  {
    v10 = (char *)&unk_8665480 + 560 * (unsigned __int16)a1;
    if ( !*((_DWORD *)v10 + 86) )
    {
      v1 = va("entity %i is not a player", (unsigned __int16)a1);
      Scr_ObjectError((int)v1);
    }
  }
  v17 = Scr_GetConstString(0);
  v2 = (char *)SL_ConvertToString(v17);
  v16 = sub_80F0450(v2);
  if ( !v16 )
  {
    v3 = (const char *)SL_ConvertToString(v17);
    v4 = va("Unknown weaponslot name %s. Valid weaponslots are \"primary\" and \"primaryb\"", v3);
    Scr_ParamError(0, (int)v4);
  }
  s1 = (char *)Scr_GetString(1u);
  if ( I_stricmp(s1, "none") )
  {
    v15 = G_GetWeaponIndexForName(s1);
    if ( !v15 )
    {
      v5 = va("Unknown weapon %s.", s1);
      Scr_ParamError(1, (int)v5);
    }
    v13 = (int *)BG_WeaponDefs(v15);
    if ( v13[32] != v16 && (v13[32] != 1 && v13[32] != 2 || v16 != 1 && v16 != 2) )
    {
      v6 = sub_80F049E(v16);
      v7 = sub_80F049E(v13[32]);
      v8 = va("Weapon %s goes in the %s weaponslot, not the %s weaponslot.", s1, v7, v6);
      Scr_ParamError(1, (int)v8);
    }
  }
  else
  {
    v15 = 0;
    v13 = 0;
  }
  result = *(char *)(v16 + *((_DWORD *)v10 + 86) + 1364);
  if ( *(_BYTE *)(v16 + *((_DWORD *)v10 + 86) + 1364) )
    result = sub_80E98CA(*((_DWORD *)v10 + 86), *(char *)(v16 + *((_DWORD *)v10 + 86) + 1364));
  if ( v15 )
  {
    if ( v16 == 2 && !*(_BYTE *)(*((_DWORD *)v10 + 86) + 1365) )
      v11 = 1;
    v12 = (unsigned __int8)sub_80D9E84(*((_DWORD *)v10 + 86) + 1348, v15);
    sub_811E696(*((_DWORD *)v10 + 86), v15);
    if ( v11 )
    {
      *(_BYTE *)(*((_DWORD *)v10 + 86) + 1366) = *(_BYTE *)(*((_DWORD *)v10 + 86) + 1365);
      *(_BYTE *)(*((_DWORD *)v10 + 86) + 1365) = 0;
    }
    result = v13[112] - *(_DWORD *)(*((_DWORD *)v10 + 86) + 4 * v13[114] + 324);
    if ( result > 0 )
      return sub_8102704((int)v10, v15, result, v12 == 0);
  }
  return result;
}

//----- (080F9C02) --------------------------------------------------------
int __cdecl sub_80F9C02(int a1)
{
  char *v1; // eax
  char *v3; // eax
  const char *v4; // eax
  char *v5; // eax
  char *v6; // [esp+14h] [ebp-14h]
  int v7; // [esp+18h] [ebp-10h]
  int v8; // [esp+18h] [ebp-10h]
  int v9; // [esp+1Ch] [ebp-Ch]
  int v10; // [esp+20h] [ebp-8h]
  unsigned __int16 v11; // [esp+26h] [ebp-2h]

  if ( HIWORD(a1) )
  {
    Scr_ObjectError((int)"not an entity");
    v6 = 0;
  }
  else
  {
    v6 = (char *)&unk_8665480 + 560 * (unsigned __int16)a1;
    if ( !*((_DWORD *)v6 + 86) )
    {
      v1 = va("entity %i is not a player", (unsigned __int16)a1);
      Scr_ObjectError((int)v1);
    }
  }
  if ( !sub_80F77E2((int)v6) )
    return Scr_AddInt(0);
  v11 = Scr_GetConstString(0);
  v3 = (char *)SL_ConvertToString(v11);
  v10 = sub_80F0450(v3);
  if ( !v10 )
  {
    v4 = (const char *)SL_ConvertToString(v11);
    v5 = va("Unknown weaponslot name %s. Valid weaponslots are \"primary\" and \"primaryb\"", v4);
    Scr_ParamError(0, (int)v5);
  }
  v9 = *(char *)(v10 + *((_DWORD *)v6 + 86) + 1364);
  if ( !*(_BYTE *)(v10 + *((_DWORD *)v6 + 86) + 1364) )
    return Scr_AddInt(0);
  if ( sub_80EACAE(v9) )
  {
    v7 = sub_80EAC7A(v9);
    return Scr_AddInt(*(_DWORD *)(*((_DWORD *)v6 + 86) + 4 * v7 + 836));
  }
  else
  {
    v8 = sub_80EAC94(v9);
    return Scr_AddInt(*(_DWORD *)(*((_DWORD *)v6 + 86) + 4 * v8 + 324));
  }
}

//----- (080F9D6C) --------------------------------------------------------
int __cdecl sub_80F9D6C(int a1)
{
  char *v1; // eax
  char *v2; // eax
  const char *v3; // eax
  char *v4; // eax
  int result; // eax
  char *v6; // [esp+10h] [ebp-18h]
  int v7; // [esp+14h] [ebp-14h]
  int v8; // [esp+14h] [ebp-14h]
  int v9; // [esp+18h] [ebp-10h]
  int v10; // [esp+1Ch] [ebp-Ch]
  int v11; // [esp+20h] [ebp-8h]
  unsigned __int16 v12; // [esp+26h] [ebp-2h]

  if ( HIWORD(a1) )
  {
    Scr_ObjectError((int)"not an entity");
    v6 = 0;
  }
  else
  {
    v6 = (char *)&unk_8665480 + 560 * (unsigned __int16)a1;
    if ( !*((_DWORD *)v6 + 86) )
    {
      v1 = va("entity %i is not a player", (unsigned __int16)a1);
      Scr_ObjectError((int)v1);
    }
  }
  v12 = Scr_GetConstString(0);
  v2 = (char *)SL_ConvertToString(v12);
  v11 = sub_80F0450(v2);
  if ( !v11 )
  {
    v3 = (const char *)SL_ConvertToString(v12);
    v4 = va("Unknown weaponslot name %s. Valid weaponslots are \"primary\" and \"primaryb\"", v3);
    Scr_ParamError(0, (int)v4);
  }
  v9 = Scr_GetInt(1u);
  result = *(char *)(v11 + *((_DWORD *)v6 + 86) + 1364);
  v10 = result;
  if ( *(_BYTE *)(v11 + *((_DWORD *)v6 + 86) + 1364) )
  {
    if ( sub_80EACAE(result) )
    {
      result = sub_80EAC7A(v10);
      v7 = result;
      if ( result )
      {
        if ( v9 >= 0 )
        {
          if ( v9 > sub_80E9356(result) )
            v9 = sub_80E9356(v7);
        }
        else
        {
          v9 = 0;
        }
        result = v9;
        *(_DWORD *)(*((_DWORD *)v6 + 86) + 4 * v7 + 836) = v9;
      }
    }
    else
    {
      result = sub_80EAC94(v10);
      v8 = result;
      if ( result )
      {
        if ( v9 >= 0 )
        {
          if ( v9 > sub_80E9336(result) )
            v9 = sub_80E9336(v8);
        }
        else
        {
          v9 = 0;
        }
        result = v9;
        *(_DWORD *)(*((_DWORD *)v6 + 86) + 4 * v8 + 324) = v9;
      }
    }
  }
  return result;
}

//----- (080F9F20) --------------------------------------------------------
int __cdecl sub_80F9F20(int a1)
{
  char *v1; // eax
  char *v2; // eax
  const char *v3; // eax
  char *v4; // eax
  char *v6; // [esp+14h] [ebp-14h]
  int v7; // [esp+18h] [ebp-10h]
  int v8; // [esp+20h] [ebp-8h]
  unsigned __int16 v9; // [esp+26h] [ebp-2h]

  if ( HIWORD(a1) )
  {
    Scr_ObjectError((int)"not an entity");
    v6 = 0;
  }
  else
  {
    v6 = (char *)&unk_8665480 + 560 * (unsigned __int16)a1;
    if ( !*((_DWORD *)v6 + 86) )
    {
      v1 = va("entity %i is not a player", (unsigned __int16)a1);
      Scr_ObjectError((int)v1);
    }
  }
  if ( !sub_80F77E2((int)v6) )
    return Scr_AddInt(0);
  v9 = Scr_GetConstString(0);
  v2 = (char *)SL_ConvertToString(v9);
  v8 = sub_80F0450(v2);
  if ( !v8 )
  {
    v3 = (const char *)SL_ConvertToString(v9);
    v4 = va("Unknown weaponslot name %s. Valid weaponslots are \"primary\" and \"primaryb\"", v3);
    Scr_ParamError(0, (int)v4);
  }
  if ( *(_BYTE *)(v8 + *((_DWORD *)v6 + 86) + 1364)
    && (v7 = sub_80EAC7A(*(char *)(v8 + *((_DWORD *)v6 + 86) + 1364))) != 0 )
  {
    return Scr_AddInt(*(_DWORD *)(*((_DWORD *)v6 + 86) + 4 * v7 + 836));
  }
  else
  {
    return Scr_AddInt(0);
  }
}

//----- (080FA064) --------------------------------------------------------
int __cdecl sub_80FA064(int a1)
{
  char *v1; // eax
  char *v2; // eax
  const char *v3; // eax
  char *v4; // eax
  int result; // eax
  char *v6; // [esp+10h] [ebp-18h]
  int v7; // [esp+14h] [ebp-14h]
  int v8; // [esp+18h] [ebp-10h]
  int v9; // [esp+20h] [ebp-8h]
  unsigned __int16 v10; // [esp+26h] [ebp-2h]

  if ( HIWORD(a1) )
  {
    Scr_ObjectError((int)"not an entity");
    v6 = 0;
  }
  else
  {
    v6 = (char *)&unk_8665480 + 560 * (unsigned __int16)a1;
    if ( !*((_DWORD *)v6 + 86) )
    {
      v1 = va("entity %i is not a player", (unsigned __int16)a1);
      Scr_ObjectError((int)v1);
    }
  }
  v10 = Scr_GetConstString(0);
  v2 = (char *)SL_ConvertToString(v10);
  v9 = sub_80F0450(v2);
  if ( !v9 )
  {
    v3 = (const char *)SL_ConvertToString(v10);
    v4 = va("Unknown weaponslot name %s. Valid weaponslots are \"primary\" and \"primaryb\"", v3);
    Scr_ParamError(0, (int)v4);
  }
  v8 = Scr_GetInt(1u);
  if ( !*(_BYTE *)(v9 + *((_DWORD *)v6 + 86) + 1364) )
    return Scr_AddInt(0);
  result = sub_80EAC7A(*(char *)(v9 + *((_DWORD *)v6 + 86) + 1364));
  v7 = result;
  if ( result )
  {
    if ( v8 < 0 )
      v8 = 0;
    if ( v8 > sub_80E9356(result) )
      v8 = sub_80E9356(v7);
    result = v8;
    *(_DWORD *)(*((_DWORD *)v6 + 86) + 4 * v7 + 836) = v8;
  }
  return result;
}

//----- (080FA1B2) --------------------------------------------------------
int __cdecl sub_80FA1B2(int a1)
{
  char *v1; // eax
  int result; // eax
  char *v3; // [esp+14h] [ebp-14h]
  int v4; // [esp+18h] [ebp-10h]
  int v5; // [esp+1Ch] [ebp-Ch]
  int v6; // [esp+20h] [ebp-8h]
  char *s1; // [esp+24h] [ebp-4h]

  if ( HIWORD(a1) )
  {
    Scr_ObjectError((int)"not an entity");
    v3 = 0;
  }
  else
  {
    v3 = (char *)&unk_8665480 + 560 * (unsigned __int16)a1;
    if ( !*((_DWORD *)v3 + 86) )
    {
      v1 = va("entity %i is not a player", (unsigned __int16)a1);
      Scr_ObjectError((int)v1);
    }
  }
  s1 = (char *)Scr_GetString(0);
  v5 = Scr_GetInt(1u);
  v6 = G_GetWeaponIndexForName(s1);
  if ( !v6 )
    return Scr_AddInt(0);
  result = sub_80EAC7A(v6);
  v4 = result;
  if ( result )
  {
    if ( v5 < 0 )
      v5 = 0;
    if ( v5 > sub_80E9356(result) )
      v5 = sub_80E9356(v4);
    result = v5;
    *(_DWORD *)(*((_DWORD *)v3 + 86) + 4 * v4 + 836) = v5;
  }
  return result;
}

//----- (080FA2AC) --------------------------------------------------------
int __cdecl sub_80FA2AC(int a1)
{
  char *v1; // eax
  char *v2; // eax

  if ( HIWORD(a1) )
  {
    Scr_ObjectError((int)"not an entity");
  }
  else if ( !*((_DWORD *)&unk_8665480 + 140 * (unsigned __int16)a1 + 86) )
  {
    v1 = va("entity %i is not a player", (unsigned __int16)a1);
    Scr_ObjectError((int)v1);
  }
  v2 = va("%c", 102);
  return sub_810E5D8((unsigned __int16)a1, v2);
}

//----- (080FA332) --------------------------------------------------------
int __cdecl sub_80FA332(int a1)
{
  char *v1; // eax
  char *v2; // eax

  if ( HIWORD(a1) )
  {
    Scr_ObjectError((int)"not an entity");
  }
  else if ( !*((_DWORD *)&unk_8665480 + 140 * (unsigned __int16)a1 + 86) )
  {
    v1 = va("entity %i is not a player", (unsigned __int16)a1);
    Scr_ObjectError((int)v1);
  }
  v2 = va("%c", 103);
  return sub_810E5D8((unsigned __int16)a1, v2);
}

//----- (080FA3B8) --------------------------------------------------------
int __usercall sub_80FA3B8@<eax>(long double a1@<st0>, int a2)
{
  char *v2; // eax
  char *v4; // [esp+1Ch] [ebp-2Ch]
  _DWORD v5[4]; // [esp+20h] [ebp-28h] BYREF
  _DWORD v6[6]; // [esp+30h] [ebp-18h] BYREF

  if ( HIWORD(a2) )
  {
    Scr_ObjectError((int)"not an entity");
    v4 = 0;
  }
  else
  {
    v4 = (char *)&unk_8665480 + 560 * (unsigned __int16)a2;
    if ( !*((_DWORD *)v4 + 86) )
    {
      v2 = va("entity %i is not a player", (unsigned __int16)a2);
      Scr_ObjectError((int)v2);
    }
  }
  Scr_GetVector(0, v6);
  Scr_GetVector(1u, v5);
  return sub_80F69B4(a1, (int)v4, v6, v5);
}
// 80FA3B8: using guessed type _DWORD var_18[6];
// 80FA3B8: using guessed type _DWORD var_28[4];

//----- (080FA45A) --------------------------------------------------------
int __cdecl sub_80FA45A(int a1)
{
  char *v1; // eax
  int v2; // ebx
  int result; // eax
  char *v4; // [esp+10h] [ebp-8h]

  if ( HIWORD(a1) )
  {
    Scr_ObjectError((int)"not an entity");
    v4 = 0;
  }
  else
  {
    v4 = (char *)&unk_8665480 + 560 * (unsigned __int16)a1;
    if ( !*((_DWORD *)v4 + 86) )
    {
      v1 = va("entity %i is not a player", (unsigned __int16)a1);
      Scr_ObjectError((int)v1);
    }
  }
  v2 = *((_DWORD *)v4 + 86);
  result = Scr_GetInt(0);
  *(_DWORD *)(v2 + 10028) = result;
  return result;
}

//----- (080FA50A) --------------------------------------------------------
int __usercall sub_80FA50A@<eax>(long double a1@<st0>, int a2)
{
  char *v2; // eax
  _DWORD *v4; // [esp+14h] [ebp-24h]
  int i; // [esp+18h] [ebp-20h]
  int v6; // [esp+1Ch] [ebp-1Ch]
  int v7; // [esp+20h] [ebp-18h]
  int v8; // [esp+24h] [ebp-14h]
  int v9; // [esp+28h] [ebp-10h]
  _DWORD *v10; // [esp+2Ch] [ebp-Ch]
  int *v11; // [esp+30h] [ebp-8h]
  int v12; // [esp+34h] [ebp-4h]

  if ( HIWORD(a2) )
  {
    Scr_ObjectError((int)"not an entity");
    v4 = 0;
  }
  else
  {
    v4 = (_DWORD *)((char *)&unk_8665480 + 560 * (unsigned __int16)a2);
    if ( !v4[86] )
    {
      v2 = va("entity %i is not a player", (unsigned __int16)a2);
      Scr_ObjectError((int)v2);
    }
  }
  v12 = Scr_GetInt(0);
  v10 = (_DWORD *)v4[86];
  v11 = sub_811C614(a1);
  v11[36] = v10[51];
  v11[2] = v10[40] & 0xFFFFFFFD | v11[2] & 2 | 0xA0000;
  sub_811CF36(v11, v10 + 5);
  sub_811CF96(v11, v4 + 81);
  v11[3] = 5;
  v11[4] = dword_859B5EC;
  sub_80FB6EE(v10 + 8, v11 + 9);
  v11[1] = 2;
  *((_BYTE *)v11 + 352) = 1;
  v9 = Com_GetServerDObj(v10[51]);
  v6 = sub_80B8BB6(v9);
  for ( i = 0; i <= 1; ++i )
  {
    a1 = *(float *)(g_clonePlayerMaxVelocity + 8);
    if ( *(float *)&v11[i + 9] > a1 )
      v11[i + 9] = *(_DWORD *)(g_clonePlayerMaxVelocity + 8);
  }
  v11[106] = dword_859B5EC;
  v8 = sub_811C87C(a1);
  v7 = 1224 * v8 + 142202936;
  dword_879D83C[306 * v8] = *v11;
  *(_DWORD *)(v7 + 8) = dword_859B5EC;
  *(_BYTE *)(v7 + 1220) = 1;
  memcpy((void *)(1224 * v8 + 142202948), (const void *)(1208 * v10[51] + 140846652), 0x4B8u);
  *(_DWORD *)(v7 + 1200) = *(_DWORD *)v7;
  sub_80C063C(v6, dword_879D838[306 * v8]);
  v11[31] = 1023;
  *((_BYTE *)v11 + 242) = 2;
  sub_80FB6EE(v4 + 65, v11 + 65);
  sub_80FB6EE(v4 + 68, v11 + 68);
  sub_80FB6EE(v4 + 72, v11 + 72);
  sub_80FB6EE(v4 + 75, v11 + 75);
  v11[51] = v10[31];
  v11[52] = v10[33];
  v11[97] = 65537;
  v11[71] = 67117056;
  SV_LinkEntity((int)v11);
  v11[100] = dword_859B5EC + v12;
  *((_BYTE *)v11 + 358) = 12;
  return GScr_AddEntity(v11);
}
// 8793DD4: using guessed type int g_clonePlayerMaxVelocity;
// 879D838: using guessed type int dword_879D838[];
// 879D83C: using guessed type int dword_879D83C[2449];

//----- (080FA820) --------------------------------------------------------
void __cdecl PlayerCmd_SetClientDvar(int a1)
{
  char *v1; // eax
  int v2; // eax
  char *v3; // eax
  char v4; // dl
  char *v5; // eax
  char v6[1024]; // [esp+30h] [ebp-828h] BYREF
  char v7[1032]; // [esp+430h] [ebp-428h] BYREF
  char *v8; // [esp+838h] [ebp-20h]
  char *s; // [esp+83Ch] [ebp-1Ch]
  char v10[4]; // [esp+840h] [ebp-18h]
  int v11; // [esp+844h] [ebp-14h]
  size_t v12; // [esp+848h] [ebp-10h]
  int v13; // [esp+84Ch] [ebp-Ch]

  if ( HIWORD(a1) )
  {
    Scr_ObjectError((int)"not an entity");
  }
  else if ( !*((_DWORD *)&unk_8665480 + 140 * (unsigned __int16)a1 + 86) )
  {
    v1 = va("entity %i is not a player", (unsigned __int16)a1);
    Scr_ObjectError((int)v1);
  }
  *(_DWORD *)v10 = Scr_GetString(0);
  v11 = Scr_GetType(1u);
  if ( v11 == 3 )
  {
    v2 = Scr_GetNumParam();
    Scr_ConstructMessageString(1, v2 - 1, "Client Dvar Value", (int)v7, 1024);
    s = v7;
  }
  else
  {
    s = (char *)Scr_GetString(1u);
  }
  v12 = strlen(s);
  if ( (unsigned __int8)sub_80AEF62(*(int *)v10) )
  {
    v8 = v6;
    memset(v6, 0, sizeof(v6));
    v13 = 0;
    while ( v13 <= 0x1FFF && s[v13] )
    {
      v4 = I_CleanChar(s[v13]);
      *v8 = v4;
      if ( *v8 == 34 )
        *v8 = 39;
      ++v13;
      ++v8;
    }
    v5 = va("%c %s \"%s\"", 118, *(const char **)v10, v6);
    SV_GameSendServerCommand((unsigned __int16)a1, 1, v5);
  }
  else
  {
    v3 = va("Dvar %s has an invalid dvar name", *(const char **)v10);
    Scr_Error((int)v3);
  }
}

//----- (080FA9EE) --------------------------------------------------------
int __cdecl sub_80FA9EE(int a1)
{
  char *v1; // eax
  char *v3; // [esp+10h] [ebp-8h]
  int v4; // [esp+14h] [ebp-4h]

  if ( HIWORD(a1) )
  {
    Scr_ObjectError((int)"not an entity");
    v3 = 0;
  }
  else
  {
    v3 = (char *)&unk_8665480 + 560 * (unsigned __int16)a1;
    if ( !*((_DWORD *)v3 + 86) )
    {
      v1 = va("entity %i is not a player", (unsigned __int16)a1);
      Scr_ObjectError((int)v1);
    }
  }
  v4 = dword_859B5EC - *(_DWORD *)(*((_DWORD *)v3 + 86) + 10248);
  if ( v4 < 0 || v4 >= *(_DWORD *)(g_voiceChatTalkingDuration + 8) )
    return Scr_AddInt(0);
  else
    return Scr_AddInt(1);
}
// 8793DE8: using guessed type int g_voiceChatTalkingDuration;

//----- (080FAA98) --------------------------------------------------------
int __cdecl sub_80FAA98(int a1)
{
  char *v1; // eax
  int v2; // ebx
  int result; // eax
  char *v4; // [esp+10h] [ebp-8h]

  if ( HIWORD(a1) )
  {
    Scr_ObjectError((int)"not an entity");
    v4 = 0;
  }
  else
  {
    v4 = (char *)&unk_8665480 + 560 * (unsigned __int16)a1;
    if ( !*((_DWORD *)v4 + 86) )
    {
      v1 = va("entity %i is not a player", (unsigned __int16)a1);
      Scr_ObjectError((int)v1);
    }
  }
  v2 = *((_DWORD *)v4 + 86);
  result = Scr_GetInt(0);
  *(_DWORD *)(v2 + 10164) = result;
  return result;
}

//----- (080FAB1A) --------------------------------------------------------
int __cdecl sub_80FAB1A(int a1)
{
  char *v1; // eax
  int result; // eax
  char *v3; // [esp+14h] [ebp-4h]

  if ( HIWORD(a1) )
  {
    Scr_ObjectError((int)"not an entity");
    v3 = 0;
  }
  else
  {
    v3 = (char *)&unk_8665480 + 560 * (unsigned __int16)a1;
    if ( !*((_DWORD *)v3 + 86) )
    {
      v1 = va("entity %i is not a player", (unsigned __int16)a1);
      Scr_ObjectError((int)v1);
    }
  }
  result = *(_DWORD *)(*((_DWORD *)v3 + 86) + 12) | 0x4000000;
  *(_DWORD *)(*((_DWORD *)v3 + 86) + 12) = result;
  return result;
}

//----- (080FAB9A) --------------------------------------------------------
unsigned int __cdecl sub_80FAB9A(int a1)
{
  char *v1; // eax
  unsigned int result; // eax
  char *v3; // [esp+14h] [ebp-4h]

  if ( HIWORD(a1) )
  {
    Scr_ObjectError((int)"not an entity");
    v3 = 0;
  }
  else
  {
    v3 = (char *)&unk_8665480 + 560 * (unsigned __int16)a1;
    if ( !*((_DWORD *)v3 + 86) )
    {
      v1 = va("entity %i is not a player", (unsigned __int16)a1);
      Scr_ObjectError((int)v1);
    }
  }
  result = *(_DWORD *)(*((_DWORD *)v3 + 86) + 12) & 0xFBFFFFFF;
  *(_DWORD *)(*((_DWORD *)v3 + 86) + 12) = result;
  return result;
}

//----- (080FAC1A) --------------------------------------------------------
void __cdecl PlayerCmd_SetReverb(int a1)
{
  char *v1; // eax
  char *v2; // eax
  unsigned int v3; // [esp+28h] [ebp-20h]
  float v4; // [esp+30h] [ebp-18h]
  float v5; // [esp+34h] [ebp-14h]
  float v6; // [esp+38h] [ebp-10h]
  const char *v7; // [esp+3Ch] [ebp-Ch]
  int v8; // [esp+40h] [ebp-8h]
  __int16 v9; // [esp+46h] [ebp-2h]

  if ( HIWORD(a1) )
  {
    Scr_ObjectError((int)"not an entity");
  }
  else if ( !*((_DWORD *)&unk_8665480 + 140 * (unsigned __int16)a1 + 86) )
  {
    v1 = va("entity %i is not a player", (unsigned __int16)a1);
    Scr_ObjectError((int)v1);
  }
  v4 = 0.0;
  v6 = 1.0;
  v5 = 0.5;
  v3 = Scr_GetNumParam();
  if ( v3 == 3 )
  {
LABEL_13:
    v6 = Scr_GetFloat(2u);
    goto LABEL_14;
  }
  if ( v3 > 3 )
  {
    if ( v3 != 4 )
    {
      if ( v3 != 5 )
      {
LABEL_20:
        Scr_Error((int)"USAGE: player setReverb(\"priority\", \"roomtype\", drylevel = 1.0, wetlevel = 0.5, fadetime = "
                         "0);\n"
                         "Valid priorities are \"snd_enveffectsprio_level\" or \"snd_enveffectsprio_shellshock\", dry lev"
                         "el is a float from 0 (no source sound) to 1 (full source sound), wetlevel is a float from 0 (no"
                         " effect) to 1 (full effect), fadetime is in sec and modifies drylevel and wetlevel\n");
        return;
      }
      v4 = Scr_GetFloat(4u);
    }
    v5 = Scr_GetFloat(3u);
    goto LABEL_13;
  }
  if ( v3 != 2 )
    goto LABEL_20;
LABEL_14:
  v7 = (const char *)Scr_GetString(1u);
  v9 = Scr_GetConstString(0);
  v8 = 1;
  if ( v9 == word_87A2322 )
  {
    v8 = 1;
  }
  else if ( v9 == word_87A2324 )
  {
    v8 = 2;
  }
  else
  {
    Scr_Error((int)"priority must be 'snd_enveffectsprio_level' or 'snd_enveffectsprio_shellshock'\n");
  }
  v2 = va("%c %i \"%s\" %g %g %g", 114, v8, v7, v6, v5, v4);
  SV_GameSendServerCommand((unsigned __int16)a1, 1, v2);
}
// 87A2322: using guessed type __int16 word_87A2322;
// 87A2324: using guessed type __int16 word_87A2324;

//----- (080FADAC) --------------------------------------------------------
void __cdecl PlayerCmd_DeactivateReverb(int a1)
{
  char *v1; // eax
  char *v2; // eax
  long double v3; // [esp+Ch] [ebp-1Ch]
  double v4; // [esp+18h] [ebp-10h]
  double v5; // [esp+20h] [ebp-8h]

  if ( HIWORD(a1) )
  {
    Scr_ObjectError((int)"not an entity");
    LODWORD(v4) = 0;
  }
  else
  {
    LODWORD(v4) = (char *)&unk_8665480 + 560 * (unsigned __int16)a1;
    if ( !*(_DWORD *)(LODWORD(v4) + 344) )
    {
      v1 = va("entity %i is not a player", (unsigned __int16)a1);
      Scr_ObjectError((int)v1);
    }
  }
  HIDWORD(v4) = 0;
  HIDWORD(v3) = Scr_GetNumParam();
  if ( HIDWORD(v3) != 1 )
  {
    if ( HIDWORD(v3) != 2 )
    {
      Scr_Error((int)"USAGE: player deactivateReverb(\"priority\", fadetime = 0);\n"
                       "Valid priorities are \"snd_enveffectsprio_level\" or \"snd_enveffectsprio_shellshock\", fadetime "
                       "is the time spent fading to the next lowest active reverb priority level in seconds\n");
      return;
    }
    *((float *)&v4 + 1) = Scr_GetFloat(1u);
  }
  HIWORD(v5) = Scr_GetConstString(0);
  LODWORD(v5) = 1;
  if ( HIWORD(v5) == word_87A2322 )
  {
    LODWORD(v5) = 1;
  }
  else if ( HIWORD(v5) == word_87A2324 )
  {
    LODWORD(v5) = 2;
  }
  else
  {
    Scr_Error((int)"priority must be 'snd_enveffectsprio_level' or 'snd_enveffectsprio_shellshock'\n");
  }
  *(double *)&v3 = *((float *)&v4 + 1);
  v2 = va(
         "%c %i \"%s\" %g %g %g",
         68,
         LODWORD(v5),
         (const char *)COERCE_UNSIGNED_INT64(*((float *)&v4 + 1)),
         *(double *)((char *)&v3 + 4),
         v4,
         v5);
  SV_GameSendServerCommand((unsigned __int16)a1, 1, v2);
}
// 80FAEA8: variable 'v5' is possibly undefined
// 87A2322: using guessed type __int16 word_87A2322;
// 87A2324: using guessed type __int16 word_87A2324;

//----- (080FAED6) --------------------------------------------------------
void __cdecl PlayerCmd_SetChannelVolumes(int a1)
{
  char *v1; // eax
  char *v2; // eax
  char *v3; // eax
  int v4; // [esp+20h] [ebp-18h]
  float v5; // [esp+28h] [ebp-10h]
  int v6; // [esp+2Ch] [ebp-Ch]
  int v7; // [esp+30h] [ebp-8h]
  __int16 v8; // [esp+36h] [ebp-2h]

  if ( HIWORD(a1) )
  {
    Scr_ObjectError((int)"not an entity");
  }
  else if ( !*((_DWORD *)&unk_8665480 + 140 * (unsigned __int16)a1 + 86) )
  {
    v1 = va("entity %i is not a player", (unsigned __int16)a1);
    Scr_ObjectError((int)v1);
  }
  v5 = 0.0;
  v4 = Scr_GetNumParam();
  if ( v4 != 2 )
  {
    if ( v4 != 3 )
    {
      Scr_Error((int)"USAGE: player setchannelvolumes(\"priority\", \"shock name\", fadetime = 0);\n"
                       "Valid priorities are \"snd_channelvolprio_holdbreath\", \"snd_channelvolprio_pain\", or \"snd_cha"
                       "nnelvolprio_shellshock\", fadetime is in sec\n");
      return;
    }
    v5 = Scr_GetFloat(2u);
  }
  v2 = (char *)Scr_GetString(1u);
  v6 = G_FindConfigstringIndex(v2, 1166, 16, 0, 0);
  v8 = Scr_GetConstString(0);
  v7 = 1;
  if ( v8 == word_87A2326 )
  {
    v7 = 1;
  }
  else if ( v8 == word_87A2328 )
  {
    v7 = 2;
  }
  else if ( v8 == word_87A232A )
  {
    v7 = 3;
  }
  else
  {
    Scr_Error((int)"priority must be 'snd_channelvolprio_holdbreath', 'snd_channelvolprio_pain', or 'snd_channelvolprio_shellshock'\n");
  }
  v3 = va("%c %i %i %g", 69, v7, v6, v5);
  SV_GameSendServerCommand((unsigned __int16)a1, 1, v3);
}
// 87A2326: using guessed type __int16 word_87A2326;
// 87A2328: using guessed type __int16 word_87A2328;
// 87A232A: using guessed type __int16 word_87A232A;

//----- (080FB054) --------------------------------------------------------
void __cdecl PlayerCmd_DeactivateChannelVolumes(int a1)
{
  char *v1; // eax
  char *v2; // eax
  long double v3; // [esp+Ch] [ebp-1Ch]
  double v4; // [esp+18h] [ebp-10h]
  double v5; // [esp+20h] [ebp-8h]

  if ( HIWORD(a1) )
  {
    Scr_ObjectError((int)"not an entity");
    LODWORD(v4) = 0;
  }
  else
  {
    LODWORD(v4) = (char *)&unk_8665480 + 560 * (unsigned __int16)a1;
    if ( !*(_DWORD *)(LODWORD(v4) + 344) )
    {
      v1 = va("entity %i is not a player", (unsigned __int16)a1);
      Scr_ObjectError((int)v1);
    }
  }
  HIDWORD(v4) = 0;
  HIDWORD(v3) = Scr_GetNumParam();
  if ( HIDWORD(v3) != 1 )
  {
    if ( HIDWORD(v3) != 2 )
    {
      Scr_Error((int)"USAGE: player deactivatechannelvolumes(\"priority\", fadetime = 0);\n"
                       "Valid priorities are \"snd_channelvolprio_holdbreath\", \"snd_channelvolprio_pain\", or \"snd_cha"
                       "nnelvolprio_shellshock\", fadetime is the time spent fading to the next lowest active reverb prio"
                       "rity level in seconds\n");
      return;
    }
    *((float *)&v4 + 1) = Scr_GetFloat(1u);
  }
  HIWORD(v5) = Scr_GetConstString(0);
  LODWORD(v5) = 1;
  if ( HIWORD(v5) == word_87A2326 )
  {
    LODWORD(v5) = 1;
  }
  else if ( HIWORD(v5) == word_87A2328 )
  {
    LODWORD(v5) = 2;
  }
  else if ( HIWORD(v5) == word_87A232A )
  {
    LODWORD(v5) = 3;
  }
  else
  {
    Scr_Error((int)"priority must be 'snd_channelvolprio_holdbreath', 'snd_channelvolprio_pain', or 'snd_channelvolprio_shellshock'\n");
  }
  *(double *)&v3 = *((float *)&v4 + 1);
  v2 = va(
         "%c %i \"%s\" %g %g %g",
         70,
         LODWORD(v5),
         (const char *)COERCE_UNSIGNED_INT64(*((float *)&v4 + 1)),
         *(double *)((char *)&v3 + 4),
         v4,
         v5);
  SV_GameSendServerCommand((unsigned __int16)a1, 1, v2);
}
// 80FB166: variable 'v5' is possibly undefined
// 87A2326: using guessed type __int16 word_87A2326;
// 87A2328: using guessed type __int16 word_87A2328;
// 87A232A: using guessed type __int16 word_87A232A;

//----- (080FB194) --------------------------------------------------------
int __cdecl ScrCmd_IsLookingAt(int a1)
{
  char *v1; // eax
  int v2; // ebx
  int v3; // eax
  char *v5; // [esp+10h] [ebp-8h]

  if ( HIWORD(a1) )
  {
    Scr_ObjectError((int)"not an entity");
    v5 = 0;
  }
  else
  {
    v5 = (char *)&unk_8665480 + 560 * (unsigned __int16)a1;
    if ( !*((_DWORD *)v5 + 86) )
    {
      v1 = va("entity %i is not a player", (unsigned __int16)a1);
      Scr_ObjectError((int)v1);
    }
  }
  v2 = *((_DWORD *)v5 + 86);
  v3 = Scr_GetEntity(0);
  return Scr_AddInt(*(_DWORD *)(v2 + 10284) == v3);
}

//----- (080FB224) --------------------------------------------------------
int __cdecl ScrCmd_PlayLocalSound(int a1)
{
  char *v1; // eax
  unsigned __int8 v2; // al
  char *v3; // eax
  char *s2; // [esp+14h] [ebp-4h]

  if ( HIWORD(a1) )
  {
    Scr_ObjectError((int)"not an entity");
  }
  else if ( !*((_DWORD *)&unk_8665480 + 140 * (unsigned __int16)a1 + 86) )
  {
    v1 = va("entity %i is not a player", (unsigned __int16)a1);
    Scr_ObjectError((int)v1);
  }
  s2 = (char *)Scr_GetString(0);
  v2 = sub_811B1D8(s2);
  v3 = va("%c %i", 115, v2);
  return SV_GameSendServerCommand((unsigned __int16)a1, 0, v3);
}

//----- (080FB2D4) --------------------------------------------------------
void __cdecl PlayerCmd_SayAll(int a1)
{
  char *v1; // eax
  int v2; // eax
  int *v3; // [esp+2Ch] [ebp-40Ch]
  char src; // [esp+30h] [ebp-408h] BYREF
  _BYTE v5[3]; // [esp+31h] [ebp-407h] BYREF

  if ( HIWORD(a1) )
  {
    Scr_ObjectError((int)"not an entity");
    v3 = 0;
  }
  else
  {
    v3 = (int *)((char *)&unk_8665480 + 560 * (unsigned __int16)a1);
    if ( !v3[86] )
    {
      v1 = va("entity %i is not a player", (unsigned __int16)a1);
      Scr_ObjectError((int)v1);
    }
  }
  v2 = Scr_GetNumParam();
  Scr_ConstructMessageString(0, v2 - 1, "Client Chat Message", (int)v5, 1023);
  src = 20;
  G_Say(v3, 0, 0, &src);
}

//----- (080FB3A4) --------------------------------------------------------
void __cdecl PlayerCmd_SayTeam(int a1)
{
  char *v1; // eax
  int v2; // eax
  int *v3; // [esp+2Ch] [ebp-40Ch]
  char src; // [esp+30h] [ebp-408h] BYREF
  _BYTE v5[3]; // [esp+31h] [ebp-407h] BYREF

  if ( HIWORD(a1) )
  {
    Scr_ObjectError((int)"not an entity");
    v3 = 0;
  }
  else
  {
    v3 = (int *)((char *)&unk_8665480 + 560 * (unsigned __int16)a1);
    if ( !v3[86] )
    {
      v1 = va("entity %i is not a player", (unsigned __int16)a1);
      Scr_ObjectError((int)v1);
    }
  }
  v2 = Scr_GetNumParam();
  Scr_ConstructMessageString(0, v2 - 1, "Client Chat Message", (int)v5, 1023);
  src = 20;
  G_Say(v3, 0, 1, &src);
}

//----- (080FB474) --------------------------------------------------------
int __cdecl PlayerCmd_AllowSpectateTeam(int a1)
{
  char *v1; // eax
  int v2; // ecx
  int result; // eax
  char *v4; // [esp+8h] [ebp-10h]
  int v5; // [esp+10h] [ebp-8h]
  __int16 v6; // [esp+16h] [ebp-2h]

  if ( HIWORD(a1) )
  {
    Scr_ObjectError((int)"not an entity");
    v4 = 0;
  }
  else
  {
    v4 = (char *)&unk_8665480 + 560 * (unsigned __int16)a1;
    if ( !*((_DWORD *)v4 + 86) )
    {
      v1 = va("entity %i is not a player", (unsigned __int16)a1);
      Scr_ObjectError((int)v1);
    }
  }
  v6 = Scr_GetConstString(0);
  v5 = 0;
  if ( v6 == word_87A22A4 )
  {
    v5 = 2;
  }
  else if ( v6 == word_87A22A2 )
  {
    v5 = 4;
  }
  else if ( v6 == word_87A2314 )
  {
    v5 = 1;
  }
  else if ( v6 == word_87A231C )
  {
    v5 = 16;
  }
  else
  {
    Scr_ParamError(0, (int)"team must be \"axis\", \"allies\", \"none\", or \"freelook\"");
  }
  if ( Scr_GetInt(1u) )
  {
    v2 = *((_DWORD *)v4 + 86);
    result = *(_DWORD *)(v2 + 10048) & ~v5;
  }
  else
  {
    v2 = *((_DWORD *)v4 + 86);
    result = *(_DWORD *)(v2 + 10048) | v5;
  }
  *(_DWORD *)(v2 + 10048) = result;
  return result;
}
// 87A22A2: using guessed type __int16 word_87A22A2;
// 87A22A4: using guessed type __int16 word_87A22A4;
// 87A2314: using guessed type __int16 word_87A2314;
// 87A231C: using guessed type __int16 word_87A231C;

//----- (080FB5B4) --------------------------------------------------------
int __cdecl PlayerCmd_GetGuid(int a1)
{
  char *v1; // eax
  int v2; // eax

  if ( HIWORD(a1) )
  {
    Scr_ObjectError((int)"not an entity");
  }
  else if ( !*((_DWORD *)&unk_8665480 + 140 * (unsigned __int16)a1 + 86) )
  {
    v1 = va("entity %i is not a player", (unsigned __int16)a1);
    Scr_ObjectError((int)v1);
  }
  if ( Scr_GetNumParam() )
    Scr_Error((int)"USAGE: self getGuid()\n");
  v2 = sub_8090AFE((unsigned __int16)a1);
  return Scr_AddInt(v2);
}

//----- (080FB640) --------------------------------------------------------
int (__cdecl *__cdecl Player_GetMethod(char **a1))(int)
{
  char *s1; // [esp+10h] [ebp-8h]
  unsigned int i; // [esp+14h] [ebp-4h]

  s1 = *a1;
  for ( i = 0; i <= 0x3A; ++i )
  {
    if ( !strcmp(s1, (&off_81518E0)[3 * i]) )
    {
      *a1 = (&off_81518E0)[3 * i];
      return off_81518E4[3 * i];
    }
  }
  return 0;
}
// 81518E0: using guessed type char *off_81518E0;
// 81518E4: using guessed type int (__cdecl *off_81518E4[183])(int);

//----- (080FB6C4) --------------------------------------------------------
int __cdecl sub_80FB6C4(_DWORD *a1)
{
  int result; // eax

  *a1 = 0;
  a1[1] = 0;
  result = 0;
  a1[2] = 0;
  return result;
}

//----- (080FB6EE) --------------------------------------------------------
int __cdecl sub_80FB6EE(_DWORD *a1, _DWORD *a2)
{
  int result; // eax

  *a2 = *a1;
  a2[1] = a1[1];
  result = a1[2];
  a2[2] = result;
  return result;
}

//----- (080FB71E) --------------------------------------------------------
float *__cdecl sub_80FB71E(float *a1, float *a2, float *a3)
{
  float *result; // eax

  *a3 = *a1 + *a2;
  a3[1] = a1[1] + a2[1];
  result = a1 + 2;
  a3[2] = a1[2] + a2[2];
  return result;
}

//----- (080FB762) --------------------------------------------------------
float *__cdecl sub_80FB762(float *a1, float a2, float *a3)
{
  float *result; // eax

  *a3 = a2 * *a1;
  a3[1] = a2 * a1[1];
  result = a1 + 2;
  a3[2] = a2 * a1[2];
  return result;
}

//----- (080FB79C) --------------------------------------------------------
int __cdecl DeathmatchScoreboardMessage(int a1)
{
  char *v1; // eax
  int v3; // [esp+20h] [ebp-9A8h]
  int v4; // [esp+24h] [ebp-9A4h]
  signed int v5; // [esp+2Ch] [ebp-99Ch]
  _DWORD *v6; // [esp+30h] [ebp-998h]
  size_t v7; // [esp+34h] [ebp-994h]
  signed int i; // [esp+38h] [ebp-990h]
  int v9; // [esp+3Ch] [ebp-98Ch]
  char v10[1408]; // [esp+40h] [ebp-988h] BYREF
  char s[1032]; // [esp+5C0h] [ebp-408h] BYREF

  v10[0] = 0;
  v9 = 0;
  v5 = nmemb;
  if ( (int)nmemb > 64 )
    v5 = 64;
  for ( i = 0; i < v5; ++i )
  {
    v4 = *(_DWORD *)&dword_859B61C[4 * i];
    v6 = (_DWORD *)(dword_859B400 + 10404 * v4);
    if ( v6[2481] == 1 )
    {
      Com_sprintf(s, 0x400u, " %i %i %i %i %i", *(_DWORD *)&dword_859B61C[4 * i], v6[2478], -1, v6[2479], v6[2476]);
    }
    else
    {
      v3 = sub_8090B42(v4);
      Com_sprintf(s, 0x400u, " %i %i %i %i %i", *(_DWORD *)&dword_859B61C[4 * i], v6[2478], v3, v6[2479], v6[2476]);
    }
    v7 = strlen(s);
    if ( (int)(v9 + v7) > 1024 )
      break;
    strcpy(&v10[v9], s);
    v9 += v7;
  }
  v1 = va("%c %i %i %i%s", 98, i, *(_DWORD *)dword_859B600, *(_DWORD *)dword_859B604, v10);
  return SV_GameSendServerCommand(-1963413621 * ((a1 - (int)&unk_8665480) >> 4), 1, v1);
}
// 859B400: using guessed type int dword_859B400;
// 80FB79C: using guessed type char var_988[1408];

//----- (080FB982) --------------------------------------------------------
int __cdecl sub_80FB982(int a1)
{
  return DeathmatchScoreboardMessage(a1);
}

//----- (080FB996) --------------------------------------------------------
int __cdecl CheatsOk(int a1)
{
  char *v1; // eax
  char *v2; // eax

  if ( *(_BYTE *)(g_cheats + 8) )
  {
    if ( *(int *)(a1 + 404) > 0 )
    {
      return 1;
    }
    else
    {
      v2 = va("%c \"GAME_MUSTBEALIVECOMMAND\"", 101);
      SV_GameSendServerCommand(-1963413621 * ((a1 - (int)&unk_8665480) >> 4), 0, v2);
      return 0;
    }
  }
  else
  {
    v1 = va("%c \"GAME_CHEATSNOTENABLED\"", 101);
    SV_GameSendServerCommand(-1963413621 * ((a1 - (int)&unk_8665480) >> 4), 0, v1);
    return 0;
  }
}
// 8793D98: using guessed type int g_cheats;

//----- (080FBA44) --------------------------------------------------------
void *__cdecl sub_80FBA44(int a1)
{
  char s[1024]; // [esp+10h] [ebp-418h] BYREF
  int v3; // [esp+410h] [ebp-18h]
  size_t n; // [esp+414h] [ebp-14h]
  int v5; // [esp+418h] [ebp-10h]
  int i; // [esp+41Ch] [ebp-Ch]

  v3 = 0;
  v5 = SV_Cmd_Argc();
  for ( i = a1; i < v5; ++i )
  {
    SV_Cmd_ArgvBuffer(i, s, 1024);
    n = strlen(s);
    if ( (int)(v3 + n) > 1022 )
      break;
    memcpy((char *)&unk_8577B60 + v3, s, n);
    v3 += n;
    if ( i != v5 - 1 )
    {
      *(_BYTE *)(v3 + 139950944) = 32;
      ++v3;
    }
  }
  *(_BYTE *)(v3 + 139950944) = 0;
  return &unk_8577B60;
}

//----- (080FBB0A) --------------------------------------------------------
_BYTE *__cdecl sub_80FBB0A(char *a1, _BYTE *a2)
{
  _BYTE *v2; // ebx
  _BYTE *result; // eax
  int v4; // [esp+0h] [ebp-8h]

  while ( *a1 )
  {
    if ( *a1 == 27 )
    {
      a1 += 2;
    }
    else if ( *a1 > 31 )
    {
      v2 = a2;
      v4 = *a1++;
      ++a2;
      *v2 = tolower(v4);
    }
    else
    {
      ++a1;
    }
  }
  result = a2;
  *a2 = 0;
  return result;
}

//----- (080FBB62) --------------------------------------------------------
int __cdecl sub_80FBB62(int a1, char *nptr)
{
  char *v2; // eax
  char *v3; // eax
  char *v4; // eax
  char s1[1024]; // [esp+20h] [ebp-818h] BYREF
  char s2[1032]; // [esp+420h] [ebp-418h] BYREF
  int v9; // [esp+828h] [ebp-10h]
  int v10; // [esp+82Ch] [ebp-Ch]

  if ( *nptr <= 47 || *nptr > 57 )
  {
    sub_80FBB0A(nptr, s2);
    v9 = 0;
    v10 = dword_859B400;
    while ( v9 < dword_859B5E4 )
    {
      if ( *(_DWORD *)(v10 + 9924) == 2 )
      {
        sub_80FBB0A((char *)(v10 + 10116), s1);
        if ( !strcmp(s1, s2) )
          return v9;
      }
      ++v9;
      v10 += 10404;
    }
    v4 = va(aCGameUsernoton, 101, nptr);
    SV_GameSendServerCommand(-1963413621 * ((a1 - (int)&unk_8665480) >> 4), 0, v4);
    return -1;
  }
  else
  {
    v9 = atoi(nptr);
    if ( v9 >= 0 && v9 < dword_859B5E4 )
    {
      v10 = dword_859B400 + 10404 * v9;
      if ( *(_DWORD *)(v10 + 9924) == 2 )
      {
        return v9;
      }
      else
      {
        v3 = va(aCGameClientnot_0, 101, v9);
        SV_GameSendServerCommand(-1963413621 * ((a1 - (int)&unk_8665480) >> 4), 0, v3);
        return -1;
      }
    }
    else
    {
      v2 = va(aCGameBadclient, 101, v9);
      SV_GameSendServerCommand(-1963413621 * ((a1 - (int)&unk_8665480) >> 4), 0, v2);
      return -1;
    }
  }
}
// 859B400: using guessed type int dword_859B400;
// 859B5E4: using guessed type int dword_859B5E4;

//----- (080FBD50) --------------------------------------------------------
void __cdecl sub_80FBD50(char *s)
{
  char v1; // [esp+3Ch] [ebp-2Ch] BYREF
  char v2; // [esp+40h] [ebp-28h] BYREF
  char v3; // [esp+44h] [ebp-24h] BYREF
  char v4; // [esp+48h] [ebp-20h] BYREF
  float v5; // [esp+54h] [ebp-14h] BYREF
  float v6; // [esp+58h] [ebp-10h] BYREF
  float v7; // [esp+5Ch] [ebp-Ch] BYREF

  SV_SetConfigstring(0xCu, s);
  dword_859D1D8 = 2139095039;
  dword_859D1DC = 2139095039;
  if ( sscanf(s, "%f %f %f %f %f %f %f", &v7, &v6, &v5, &v2, &v3, &v4, &v1) == 7 && v5 >= 1.0 )
  {
    *(float *)&dword_859D1D8 = v6 - v7 + v7;
    *(float *)&dword_859D1DC = *(float *)&dword_859D1D8 * *(float *)&dword_859D1D8;
  }
}
// 859D1D8: using guessed type int dword_859D1D8;
// 859D1DC: using guessed type int dword_859D1DC;

//----- (080FBE00) --------------------------------------------------------
void sub_80FBE00()
{
  char *v0; // eax

  v0 = (char *)sub_80FBA44(1);
  sub_80FBD50(v0);
}

//----- (080FBE1C) --------------------------------------------------------
char *__usercall sub_80FBE1C@<eax>(long double a1@<st0>, int *a2)
{
  char *result; // eax
  int v3; // [esp+18h] [ebp-20h]
  int v4; // [esp+1Ch] [ebp-1Ch]
  _DWORD *s; // [esp+20h] [ebp-18h]
  _BOOL4 v6; // [esp+24h] [ebp-14h]
  int i; // [esp+28h] [ebp-10h]
  int j; // [esp+28h] [ebp-10h]
  int k; // [esp+28h] [ebp-10h]
  int m; // [esp+28h] [ebp-10h]
  char **v11; // [esp+2Ch] [ebp-Ch]
  char *nptr; // [esp+30h] [ebp-8h]
  char *v13; // [esp+34h] [ebp-4h]

  result = (char *)CheatsOk((int)a2);
  if ( result )
  {
    nptr = (char *)sub_80FBA44(2);
    v4 = atoi(nptr);
    result = (char *)sub_80FBA44(1);
    v13 = result;
    if ( result )
    {
      if ( *result )
      {
        if ( !(v6 = I_stricmp(result, "all") == 0) && sub_80B550A(v13, "health", 6)
          || (!v4 ? (result = *(char **)(a2[86] + 308)) : (result = (char *)(a2[101] + v4)), a2[101] = (int)result, v6) )
        {
          if ( !v6 && I_stricmp(v13, "weapons") )
            goto LABEL_49;
          dword_859B41C = 1;
          v3 = *(char *)(a2[86] + 1366);
          sub_80E98CA(a2[86], *(char *)(a2[86] + 1365));
          sub_80E98CA(a2[86], *(char *)(a2[86] + 1366));
          for ( i = 1; i <= BG_GetNumWeapons(); ++i )
          {
            if ( !(unsigned __int8)sub_80E9782(i) || i > v3 && (unsigned __int8)sub_80E97BE(a2[86]) )
              sub_811E696(a2[86], i);
          }
          for ( j = 1; ; ++j )
          {
            result = (char *)sub_80E97BE(a2[86]);
            if ( !(_BYTE)result )
              break;
            result = (char *)BG_GetNumWeapons();
            if ( j > (int)result )
              break;
            if ( (unsigned __int8)sub_80E9782(j) )
              sub_811E696(a2[86], j);
          }
          dword_859B41C = 0;
          if ( v6 )
          {
LABEL_49:
            if ( !v6 && sub_80B550A(v13, "ammo", 4) )
              goto LABEL_35;
            if ( v4 )
            {
              result = (char *)a2[86];
              if ( *((_DWORD *)result + 53) )
                result = (char *)sub_8102704((int)a2, *(_DWORD *)(a2[86] + 212), v4, 1);
            }
            else
            {
              for ( k = 1; ; ++k )
              {
                result = (char *)BG_GetNumWeapons();
                if ( k > (int)result )
                  break;
                sub_8102704((int)a2, k, 998, 1);
              }
            }
            if ( v6 )
            {
LABEL_35:
              result = (char *)sub_80B550A(v13, "allammo", 7);
              if ( result )
                goto LABEL_48;
              if ( !v4 )
                goto LABEL_48;
              for ( m = 1; ; sub_8102704((int)a2, m++, v4, 1) )
              {
                result = (char *)BG_GetNumWeapons();
                if ( m > (int)result )
                  break;
              }
              if ( v6 )
              {
LABEL_48:
                if ( !v6 )
                {
                  result = sub_80DCB02(v13);
                  v11 = (char **)result;
                  if ( result )
                  {
                    dword_859B41C = 1;
                    s = (_DWORD *)G_Spawn();
                    sub_80FEE3C(a2 + 78, s + 78);
                    sub_8103CB2(v11, (_WORD *)s + 180);
                    sub_8104EB2(a1, (int)s, (int)v11);
                    *((_BYTE *)s + 354) = 1;
                    sub_810381C(a1, (unsigned __int16 *)s, a2, 1);
                    *((_BYTE *)s + 354) = 0;
                    result = (char *)s;
                    if ( *((_BYTE *)s + 252) )
                      result = (char *)G_FreeEntity(a1, s);
                    dword_859B41C = 0;
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  return result;
}

//----- (080FC25E) --------------------------------------------------------
char *__cdecl sub_80FC25E(int a1)
{
  char *result; // eax
  int v2; // ebx
  int v3; // ebx
  int v4; // ebx
  int v5; // eax
  int v6; // ebx
  int v7; // esi
  int v8; // edi
  int v9; // ebx
  int v10; // ebx
  int v11; // ebx
  int v12; // ebx
  int v13; // ebx
  int v14; // ebx
  int v15; // eax
  int v16; // ebx
  int v17; // esi
  int v18; // edi
  int v19; // ebx
  int v20; // ebx
  int v21; // ebx
  int v22; // [esp+10h] [ebp-28h]
  int v23; // [esp+14h] [ebp-24h]
  int v24; // [esp+18h] [ebp-20h]
  _BOOL4 v25; // [esp+1Ch] [ebp-1Ch]
  int i; // [esp+20h] [ebp-18h]
  int v27; // [esp+20h] [ebp-18h]
  int j; // [esp+20h] [ebp-18h]
  int k; // [esp+20h] [ebp-18h]
  char *nptr; // [esp+24h] [ebp-14h]
  char *v31; // [esp+28h] [ebp-10h]

  result = (char *)CheatsOk(a1);
  if ( result )
  {
    nptr = (char *)sub_80FBA44(2);
    v24 = atoi(nptr);
    result = (char *)sub_80FBA44(1);
    v31 = result;
    if ( result )
    {
      if ( *result )
      {
        v25 = I_stricmp(result, "all") == 0;
        if ( !v25 )
        {
          if ( sub_80B550A(v31, "health", 6) )
            goto LABEL_18;
        }
        if ( v24 )
        {
          *(_DWORD *)(a1 + 404) -= v24;
          result = (char *)a1;
          if ( *(int *)(a1 + 404) <= 0 )
          {
            result = (char *)a1;
            *(_DWORD *)(a1 + 404) = 1;
          }
        }
        else
        {
          result = (char *)a1;
          *(_DWORD *)(a1 + 404) = 1;
        }
        if ( v25 )
        {
LABEL_18:
          if ( !v25 && I_stricmp(v31, "weapons") )
            goto LABEL_29;
          for ( i = 1; i <= BG_GetNumWeapons(); ++i )
          {
            sub_80E98CA(*(_DWORD *)(a1 + 344), i);
            v2 = *(_DWORD *)(a1 + 344);
            *(_DWORD *)(v2 + 4 * sub_80EAC94(i) + 324) = 0;
            v3 = *(_DWORD *)(a1 + 344);
            *(_DWORD *)(v3 + 4 * sub_80EAC7A(i) + 836) = 0;
          }
          result = *(char **)(a1 + 344);
          if ( *((_DWORD *)result + 53) )
          {
            *(_DWORD *)(*(_DWORD *)(a1 + 344) + 212) = 0;
            result = (char *)sub_811E97A(-1963413621 * ((a1 - (int)&unk_8665480) >> 4), 0);
          }
          if ( v25 )
          {
LABEL_29:
            if ( !v25 && sub_80B550A(v31, "ammo", 4) )
              goto LABEL_30;
            if ( v24 )
            {
              result = *(char **)(a1 + 344);
              if ( *((_DWORD *)result + 53) )
              {
                v27 = *(_DWORD *)(*(_DWORD *)(a1 + 344) + 212);
                v4 = *(_DWORD *)(a1 + 344);
                v5 = sub_80EAC94(v27);
                *(_DWORD *)(v4 + 4 * v5 + 324) = *(_DWORD *)(*(_DWORD *)(a1 + 344) + 4 * v5 + 324) - v24;
                v6 = *(_DWORD *)(a1 + 344);
                result = (char *)sub_80EAC94(v27);
                if ( *(int *)(v6 + 4 * (_DWORD)result + 324) < 0 )
                {
                  v23 = *(_DWORD *)(a1 + 344);
                  v7 = sub_80EAC7A(v27);
                  v8 = *(_DWORD *)(a1 + 344);
                  *(_DWORD *)(v23 + 4 * v7 + 836) = *(_DWORD *)(v8 + 4 * v7 + 836)
                                                  + *(_DWORD *)(v8 + 4 * sub_80EAC94(v27) + 324);
                  v9 = *(_DWORD *)(a1 + 344);
                  *(_DWORD *)(v9 + 4 * sub_80EAC94(v27) + 324) = 0;
                  v10 = *(_DWORD *)(a1 + 344);
                  result = (char *)sub_80EAC7A(v27);
                  if ( *(int *)(v10 + 4 * (_DWORD)result + 836) < 0 )
                  {
                    v11 = *(_DWORD *)(a1 + 344);
                    result = (char *)sub_80EAC7A(v27);
                    *(_DWORD *)(v11 + 4 * (_DWORD)result + 836) = 0;
                  }
                }
              }
            }
            else
            {
              for ( j = 1; ; ++j )
              {
                result = (char *)BG_GetNumWeapons();
                if ( j > (int)result )
                  break;
                v12 = *(_DWORD *)(a1 + 344);
                *(_DWORD *)(v12 + 4 * sub_80EAC94(j) + 324) = 0;
                v13 = *(_DWORD *)(a1 + 344);
                *(_DWORD *)(v13 + 4 * sub_80EAC7A(j) + 836) = 0;
              }
            }
            if ( v25 )
            {
LABEL_30:
              result = (char *)sub_80B550A(v31, "allammo", 7);
              if ( !result && v24 )
              {
                for ( k = 1; ; ++k )
                {
                  result = (char *)BG_GetNumWeapons();
                  if ( k > (int)result )
                    break;
                  v14 = *(_DWORD *)(a1 + 344);
                  v15 = sub_80EAC94(k);
                  *(_DWORD *)(v14 + 4 * v15 + 324) = *(_DWORD *)(*(_DWORD *)(a1 + 344) + 4 * v15 + 324) - v24;
                  v16 = *(_DWORD *)(a1 + 344);
                  if ( *(int *)(v16 + 4 * sub_80EAC94(k) + 324) < 0 )
                  {
                    v22 = *(_DWORD *)(a1 + 344);
                    v17 = sub_80EAC7A(k);
                    v18 = *(_DWORD *)(a1 + 344);
                    *(_DWORD *)(v22 + 4 * v17 + 836) = *(_DWORD *)(v18 + 4 * v17 + 836)
                                                     + *(_DWORD *)(v18 + 4 * sub_80EAC94(k) + 324);
                    v19 = *(_DWORD *)(a1 + 344);
                    *(_DWORD *)(v19 + 4 * sub_80EAC94(k) + 324) = 0;
                    v20 = *(_DWORD *)(a1 + 344);
                    if ( *(int *)(v20 + 4 * sub_80EAC7A(k) + 836) < 0 )
                    {
                      v21 = *(_DWORD *)(a1 + 344);
                      *(_DWORD *)(v21 + 4 * sub_80EAC7A(k) + 836) = 0;
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  return result;
}

//----- (080FC74E) --------------------------------------------------------
int __cdecl Cmd_God_f(int a1)
{
  int result; // eax
  char *v2; // eax
  const char *v3; // [esp+10h] [ebp-8h]

  result = CheatsOk(a1);
  if ( result )
  {
    *(_DWORD *)(a1 + 372) ^= 1u;
    if ( (*(_BYTE *)(a1 + 372) & 1) != 0 )
      v3 = "GAME_GODMODE_ON";
    else
      v3 = "GAME_GODMODE_OFF";
    v2 = va("%c \"%s\"", 101, v3);
    return SV_GameSendServerCommand(-1963413621 * ((a1 - (int)&unk_8665480) >> 4), 0, v2);
  }
  return result;
}

//----- (080FC7E2) --------------------------------------------------------
int __cdecl Cmd_DemiGod_f(int a1)
{
  int result; // eax
  char *v2; // eax
  const char *v3; // [esp+10h] [ebp-8h]

  result = CheatsOk(a1);
  if ( result )
  {
    *(_DWORD *)(a1 + 372) ^= 2u;
    if ( (*(_DWORD *)(a1 + 372) & 2) != 0 )
      v3 = "GAME_DEMI_GODMODE_ON";
    else
      v3 = "GAME_DEMI_GODMODE_OFF";
    v2 = va("%c \"%s\"", 101, v3);
    return SV_GameSendServerCommand(-1963413621 * ((a1 - (int)&unk_8665480) >> 4), 0, v2);
  }
  return result;
}

//----- (080FC876) --------------------------------------------------------
int __cdecl Cmd_Notarget_f(int a1)
{
  int result; // eax
  char *v2; // eax

  result = CheatsOk(a1);
  if ( result )
  {
    *(_DWORD *)(a1 + 372) ^= 4u;
    if ( (*(_DWORD *)(a1 + 372) & 4) != 0 )
      v2 = va("%c \"%s\"", 101, "GAME_NOTARGETON");
    else
      v2 = va("%c \"%s\"", 101, "GAME_NOTARGETOFF");
    return SV_GameSendServerCommand(-1963413621 * ((a1 - (int)&unk_8665480) >> 4), 0, v2);
  }
  return result;
}

//----- (080FC904) --------------------------------------------------------
int __cdecl Cmd_Noclip_f(int a1)
{
  int result; // eax
  char *v2; // eax
  const char *v3; // [esp+14h] [ebp-4h]

  result = CheatsOk(a1);
  if ( result )
  {
    if ( *(_DWORD *)(*(_DWORD *)(a1 + 344) + 10156) )
      v3 = "GAME_NOCLIPOFF";
    else
      v3 = "GAME_NOCLIPON";
    *(_DWORD *)(*(_DWORD *)(a1 + 344) + 10156) = *(_DWORD *)(*(_DWORD *)(a1 + 344) + 10156) == 0;
    v2 = va("%c \"%s\"", 101, v3);
    return SV_GameSendServerCommand(-1963413621 * ((a1 - (int)&unk_8665480) >> 4), 0, v2);
  }
  return result;
}

//----- (080FC9A8) --------------------------------------------------------
int __cdecl Cmd_UFO_f(int a1)
{
  int result; // eax
  char *v2; // eax
  const char *v3; // [esp+14h] [ebp-4h]

  result = CheatsOk(a1);
  if ( result )
  {
    if ( *(_DWORD *)(*(_DWORD *)(a1 + 344) + 10160) )
      v3 = "GAME_UFOOFF";
    else
      v3 = "GAME_UFOON";
    *(_DWORD *)(*(_DWORD *)(a1 + 344) + 10160) = *(_DWORD *)(*(_DWORD *)(a1 + 344) + 10160) == 0;
    v2 = va("%c \"%s\"", 101, v3);
    return SV_GameSendServerCommand(-1963413621 * ((a1 - (int)&unk_8665480) >> 4), 0, v2);
  }
  return result;
}

//----- (080FCA4C) --------------------------------------------------------
int __cdecl sub_80FCA4C(int *a1)
{
  int result; // eax
  int v2; // edx

  result = a1[86];
  if ( !*(_DWORD *)(result + 9896) )
  {
    a1[93] &= 0xFFFFFFFC;
    v2 = a1[86];
    a1[101] = 0;
    *(_DWORD *)(v2 + 300) = 0;
    return sub_80FF2CA((int)a1, a1, a1, 100000, 0xCu, 0, 0, 0, 0);
  }
  return result;
}

//----- (080FCAE6) --------------------------------------------------------
_DWORD *__cdecl sub_80FCAE6(char *a1)
{
  _DWORD *result; // eax
  long double v2; // fst7
  float s[12]; // [esp+20h] [ebp-B8h] BYREF
  int v4[4]; // [esp+50h] [ebp-88h] BYREF
  int v5[4]; // [esp+60h] [ebp-78h] BYREF
  int v6[4]; // [esp+70h] [ebp-68h] BYREF
  int v7[4]; // [esp+80h] [ebp-58h] BYREF
  int v8[4]; // [esp+90h] [ebp-48h] BYREF
  int v9[4]; // [esp+A0h] [ebp-38h] BYREF
  float v10[7]; // [esp+B0h] [ebp-28h] BYREF
  _DWORD *v11; // [esp+CCh] [ebp-Ch]

  v11 = (_DWORD *)*((_DWORD *)a1 + 86);
  v11[2475] = -1;
  v11[2538] = -1;
  result = (_DWORD *)(v11[3] & 0x400000);
  if ( result )
  {
    sub_80F61BE((int)a1, (float *)v9);
    sub_80F63A0((int)a1, (int)v8, 0, (float *)v7);
    sub_80FEE3C(v11 + 58, v10);
    v2 = v10[0] + 15.0;
    v10[0] = v2;
    sub_80FEE6C((float *)v9, -40.0, (float *)v8, (float *)v6);
    sub_80FEE6C((float *)v6, 10.0, (float *)v7, (float *)v6);
    sub_80FEE18(v5, -1056964608, -1056964608, -1056964608);
    sub_80FEE18(v4, 1090519040, 1090519040, 1090519040);
    G_TraceCapsule(s, (float *)v9, (float *)v5, (float *)v4, (float *)v6, 1023, 8454161);
    sub_80DEB7A((float *)v9, (float *)v6, s[0], (float *)v9);
    v11[51] = -1963413621 * ((a1 - (char *)&unk_8665480) >> 4);
    v11[40] &= 0xFFFFFCFF;
    v11[356] = 0;
    v11[357] = 1023;
    v11[3] &= 0xFFBFFFBF;
    v11[55] = 0;
    sub_811CF36(a1, v9);
    sub_80FEE3C(v9, v11 + 5);
    sub_80F5E80(v2, (int)a1, v10);
    v11[374] = 0;
    v11[375] = 0;
    result = v11;
    v11[376] = 0;
  }
  return result;
}
// 80FCAE6: using guessed type float s[12];

//----- (080FCD40) --------------------------------------------------------
int __cdecl sub_80FCD40(int a1, int a2)
{
  char v4[96]; // [esp+20h] [ebp-2728h] BYREF
  int v5[2478]; // [esp+80h] [ebp-26C8h] BYREF
  int v6; // [esp+2738h] [ebp-10h]
  int v7; // [esp+273Ch] [ebp-Ch]

  if ( a2 != 1 && a2 != -1 )
    Com_Error(1, (char *)&byte_8151D60, a2);
  if ( *(_DWORD *)(*(_DWORD *)(a1 + 344) + 9896) != 2 )
    return 0;
  if ( *(int *)(*(_DWORD *)(a1 + 344) + 9900) >= 0 )
    return 0;
  v7 = *(_DWORD *)(*(_DWORD *)(a1 + 344) + 10152);
  if ( v7 < 0 )
    v7 = 0;
  v6 = v7;
  do
  {
    v7 += a2;
    if ( v7 >= dword_859B5E4 )
      v7 = 0;
    if ( v7 < 0 )
      v7 = dword_859B5E4 - 1;
    if ( sub_8097EDA(v7, (int *)(*(_DWORD *)(a1 + 344) + 9908), v5, v4) && sub_80F467C(*(_DWORD *)(a1 + 344), v4[4]) )
    {
      *(_DWORD *)(*(_DWORD *)(a1 + 344) + 10152) = v7;
      *(_DWORD *)(*(_DWORD *)(a1 + 344) + 9896) = 2;
      return 1;
    }
  }
  while ( v7 != v6 );
  return 0;
}
// 859B5E4: using guessed type int dword_859B5E4;
// 80FCD40: using guessed type int var_26C8[2478];

//----- (080FCEA8) --------------------------------------------------------
_BOOL4 __cdecl sub_80FCEA8(int a1)
{
  return *(_DWORD *)(*(_DWORD *)(a1 + 344) + 9896) == 0;
}

//----- (080FCEC4) --------------------------------------------------------
void __cdecl sub_80FCEC4(int a1, int a2, int a3, int a4, int a5, int a6)
{
  char *v6; // eax

  if ( a2
    && *(_BYTE *)(a2 + 252)
    && *(_DWORD *)(a2 + 344)
    && *(_DWORD *)(*(_DWORD *)(a2 + 344) + 9924) == 2
    && (a3 != 1 || sub_8119C40(a1, a2))
    && (*(_BYTE *)(g_deadChat + 8) || sub_80FCEA8(a1) || !sub_80FCEA8(a2)) )
  {
    if ( a3 == 1 )
      v6 = va(aC_4, 105, a5, 94, a4, a6);
    else
      v6 = va(aC_4, 104, a5, 94, a4, a6);
    SV_GameSendServerCommand(-1963413621 * ((a2 - (int)&unk_8665480) >> 4), 0, v6);
  }
}
// 8793DFC: using guessed type int g_deadChat;

//----- (080FCFC8) --------------------------------------------------------
void __cdecl G_Say(int *a1, int a2, int a3, char *src)
{
  int v4; // eax
  int v5; // eax
  int v6; // [esp+24h] [ebp-1C4h]
  void *v7; // [esp+28h] [ebp-1C0h]
  const char *v8; // [esp+2Ch] [ebp-1BCh]
  char v9[160]; // [esp+30h] [ebp-1B8h] BYREF
  char s[64]; // [esp+D0h] [ebp-118h] BYREF
  char v11[128]; // [esp+110h] [ebp-D8h] BYREF
  char dest[68]; // [esp+190h] [ebp-58h] BYREF
  int v13; // [esp+1D4h] [ebp-14h]
  int v14; // [esp+1D8h] [ebp-10h]
  int i; // [esp+1DCh] [ebp-Ch]

  if ( a3 == 1 && *(_DWORD *)(a1[86] + 10060) != 1 && *(_DWORD *)(a1[86] + 10060) != 2 )
    a3 = 0;
  I_strncpyz(dest, (char *)(a1[86] + 10116), 64);
  sub_80B587C(dest);
  v6 = *(_DWORD *)(a1[86] + 10060);
  if ( v6 == 1 )
  {
    v7 = &unk_8151D91;
  }
  else if ( v6 == 2 )
  {
    v7 = &unk_8151D8E;
  }
  else
  {
    v7 = &unk_8151D94;
  }
  if ( *(_DWORD *)(a1[86] + 10060) == 3 )
  {
    Com_sprintf(s, 0x40u, (char *)&byte_8151D95);
  }
  else if ( *(_DWORD *)(a1[86] + 9896) )
  {
    Com_sprintf(s, 0x40u, (char *)&byte_8151DA9, v7);
  }
  else
  {
    Com_sprintf(s, 0x40u, (char *)&byte_8151DBA, v7);
  }
  if ( a3 == 1 )
  {
    if ( *(_DWORD *)(a1[86] + 10060) == 1 )
      v8 = "GAME_AXIS";
    else
      v8 = "GAME_ALLIES";
    v5 = sub_8090AFE(*a1);
    G_LogPrintf("sayteam;%d;%d;%s;%s\n", v5, *a1, dest, src);
    Com_sprintf(v11, 0x80u, aS_33, s, v8, dest, "^7");
    v13 = 53;
  }
  else if ( a3 == 2 )
  {
    Com_sprintf(v11, 0x80u, "%s[%s]%s: ", s, dest, "^7");
    v13 = 51;
  }
  else
  {
    v4 = sub_8090AFE(*a1);
    G_LogPrintf("say;%d;%d;%s;%s\n", v4, *a1, dest, src);
    Com_sprintf(v11, 0x80u, "%s%s%s: ", s, dest, "^7");
    v13 = 55;
  }
  I_strncpyz(v9, src, 150);
  if ( a2 )
  {
    sub_80FCEC4((int)a1, a2, a3, v13, (int)v11, (int)v9);
  }
  else
  {
    if ( *(_DWORD *)(dedicated + 8) )
      Com_Printf("%s%s\n", v11, v9);
    for ( i = 0; i < dword_859B5E4; ++i )
    {
      v14 = (int)&unk_8665480 + 560 * i;
      sub_80FCEC4((int)a1, v14, a3, v13, (int)v11, (int)v9);
    }
  }
}
// 859B5E4: using guessed type int dword_859B5E4;
// 8793D8C: using guessed type int dedicated;

//----- (080FD38E) --------------------------------------------------------
void __cdecl sub_80FD38E(int *a1, int a2, int a3)
{
  char *src; // [esp+14h] [ebp-4h]

  if ( SV_Cmd_Argc() > 1 || a3 )
  {
    if ( a3 )
      src = (char *)sub_80FBA44(0);
    else
      src = (char *)sub_80FBA44(1);
    G_Say(a1, 0, a2, src);
  }
}

//----- (080FD3F0) --------------------------------------------------------
void __cdecl sub_80FD3F0(int *a1)
{
  int v1; // ebx
  int v2; // eax
  char v3[64]; // [esp+20h] [ebp-498h] BYREF
  char dest[64]; // [esp+60h] [ebp-458h] BYREF
  char nptr[1028]; // [esp+A0h] [ebp-418h] BYREF
  char *src; // [esp+4A4h] [ebp-14h]
  int v7; // [esp+4A8h] [ebp-10h]
  int v8; // [esp+4ACh] [ebp-Ch]

  if ( SV_Cmd_Argc() > 1 )
  {
    SV_Cmd_ArgvBuffer(1, nptr, 1024);
    v8 = atoi(nptr);
    if ( v8 >= 0 && v8 < dword_859B5E4 )
    {
      v7 = (int)&unk_8665480 + 560 * v8;
      if ( v7 )
      {
        if ( *(_BYTE *)(v7 + 252) )
        {
          if ( *(_DWORD *)(v7 + 344) )
          {
            src = (char *)sub_80FBA44(2);
            I_strncpyz(dest, (char *)(a1[86] + 10116), 64);
            sub_80B587C(dest);
            I_strncpyz(v3, (char *)(*(_DWORD *)(v7 + 344) + 10116), 64);
            sub_80B587C(v3);
            v1 = sub_8090AFE(*(_DWORD *)v7);
            v2 = sub_8090AFE(*a1);
            G_LogPrintf("tell;%d;%d;%s;%d;%d;%s;%s\n", v2, *a1, dest, v1, *(_DWORD *)v7, v3, src);
            G_Say(a1, v7, 2, src);
            G_Say(a1, (int)a1, 2, src);
          }
        }
      }
    }
  }
}
// 859B5E4: using guessed type int dword_859B5E4;

//----- (080FD5B6) --------------------------------------------------------
void __cdecl sub_80FD5B6(int *a1)
{
  char nptr[1032]; // [esp+10h] [ebp-418h] BYREF
  unsigned int v2; // [esp+418h] [ebp-10h]
  unsigned int v3; // [esp+41Ch] [ebp-Ch]

  SV_Cmd_ArgvBuffer(1, nptr, 1024);
  v3 = atoi(nptr);
  SV_Cmd_ArgvBuffer(2, nptr, 1024);
  v2 = atoi(nptr);
  if ( v3 <= 0x3F && v2 <= 6 )
  {
    G_Say(a1, 560 * v3 + 140924032, 2, (&off_8167718)[v2]);
    G_Say(a1, (int)a1, 2, (&off_8167718)[v2]);
  }
}

//----- (080FD692) --------------------------------------------------------
int __cdecl sub_80FD692(int a1)
{
  char *v1; // eax
  char *v2; // eax

  v1 = vtos((float *)(a1 + 312));
  v2 = va(aC_5, 101, v1);
  return SV_GameSendServerCommand(-1963413621 * ((a1 - (int)&unk_8665480) >> 4), 0, v2);
}

//----- (080FD6E8) --------------------------------------------------------
int __usercall Cmd_CallVote_f@<eax>(long double a1@<st0>, int *a2)
{
  char *v2; // eax
  int result; // eax
  char *v4; // eax
  char *v5; // eax
  char *v6; // eax
  char *v7; // eax
  char *v8; // eax
  char *v9; // eax
  char *v10; // eax
  char *v11; // eax
  char *v12; // eax
  char *v13; // eax
  int v14; // eax
  int v15; // eax
  int v16; // eax
  char *v17; // eax
  char *v18; // eax
  char *v19; // eax
  char *v20; // eax
  char *v21; // eax
  unsigned int v22; // [esp+24h] [ebp-354h]
  char *v23; // [esp+28h] [ebp-350h]
  int j; // [esp+28h] [ebp-350h]
  int i; // [esp+2Ch] [ebp-34Ch]
  char dest[64]; // [esp+30h] [ebp-348h] BYREF
  char v27[256]; // [esp+70h] [ebp-308h] BYREF
  char nptr[256]; // [esp+170h] [ebp-208h] BYREF
  char s[264]; // [esp+270h] [ebp-108h] BYREF

  if ( !*(_BYTE *)(g_allowVote + 8) )
  {
    v2 = va("%c \"GAME_VOTINGNOTENABLED\"", 101);
    return SV_GameSendServerCommand(-1963413621 * (((char *)a2 - (char *)&unk_8665480) >> 4), 0, v2);
  }
  if ( *(_BYTE *)(g_oldVoting + 8) )
  {
    if ( *(_DWORD *)dword_859BF1C )
    {
      v4 = va("%c \"GAME_VOTEALREADYINPROGRESS\"", 101);
      return SV_GameSendServerCommand(-1963413621 * (((char *)a2 - (char *)&unk_8665480) >> 4), 0, v4);
    }
    if ( *(int *)(a2[86] + 10036) > 2 )
    {
      v5 = va("%c \"GAME_MAXVOTESCALLED\"", 101);
      return SV_GameSendServerCommand(-1963413621 * (((char *)a2 - (char *)&unk_8665480) >> 4), 0, v5);
    }
    if ( *(_DWORD *)(a2[86] + 10060) == 3 )
    {
      v6 = va("%c \"GAME_NOSPECTATORCALLVOTE\"", 101);
      return SV_GameSendServerCommand(-1963413621 * (((char *)a2 - (char *)&unk_8665480) >> 4), 0, v6);
    }
  }
  SV_Cmd_ArgvBuffer(1, s, 256);
  SV_Cmd_ArgvBuffer(2, nptr, 256);
  SV_Cmd_ArgvBuffer(3, v27, 256);
  if ( strchr(s, 59) || strchr(nptr, 59) || strchr(v27, 59) )
  {
    v7 = va("%c \"GAME_INVALIDVOTESTRING\"", 101);
    return SV_GameSendServerCommand(-1963413621 * (((char *)a2 - (char *)&unk_8665480) >> 4), 0, v7);
  }
  if ( !*(_BYTE *)(g_oldVoting + 8) )
    return sub_81160D4(a2, s, nptr, v27);
  if ( I_stricmp(s, "map_restart")
    && I_stricmp(s, "map_rotate")
    && I_stricmp(s, "typemap")
    && I_stricmp(s, "map")
    && I_stricmp(s, "g_gametype")
    && I_stricmp(s, "kick")
    && I_stricmp(s, "clientkick")
    && I_stricmp(s, "tempBanUser")
    && I_stricmp(s, "tempBanClient") )
  {
    v8 = va("%c \"GAME_INVALIDVOTESTRING\"", 101);
    SV_GameSendServerCommand(-1963413621 * (((char *)a2 - (char *)&unk_8665480) >> 4), 0, v8);
    v9 = va(aCGameVotecomma, 101);
    return SV_GameSendServerCommand(-1963413621 * (((char *)a2 - (char *)&unk_8665480) >> 4), 0, v9);
  }
  if ( dword_859BF20 )
  {
    dword_859BF20 = 0;
    v10 = va("%s\n", byte_859B71C);
    Cbuf_ExecuteText(2, v10);
  }
  if ( !I_stricmp(s, "typemap") )
  {
    if ( !Scr_IsValidGameType(nptr) )
    {
LABEL_29:
      v11 = va("%c \"GAME_INVALIDGAMETYPE\"", 101);
      return SV_GameSendServerCommand(-1963413621 * (((char *)a2 - (char *)&unk_8665480) >> 4), 0, v11);
    }
    if ( !I_stricmp(nptr, *(char **)(sv_gametype + 8)) )
      nptr[0] = 0;
    SV_Cmd_ArgvBuffer(3, v27, 256);
    if ( !SV_MapExists(v27) )
      goto LABEL_33;
    v23 = Dvar_RegisterString(a1, "mapname", (char *)&unk_8151D94, 4164);
    if ( !I_stricmp(v27, *((char **)v23 + 2)) )
      v27[0] = 0;
    if ( !nptr[0] && !v27[0] )
    {
      v13 = va("%c \"GAME_TYPEMAP_NOCHANGE\"", 101);
      return SV_GameSendServerCommand(-1963413621 * (((char *)a2 - (char *)&unk_8665480) >> 4), 0, v13);
    }
    if ( v27[0] )
    {
      if ( nptr[0] )
        Com_sprintf(byte_859B71C, 0x400u, "g_gametype %s; map %s", nptr, v27);
      else
        Com_sprintf(byte_859B71C, 0x400u, "map %s", v27);
      if ( nptr[0] )
      {
        v14 = sub_8115DD2(nptr);
        Com_sprintf(byte_859BB1C, 0x400u, aGameVoteGamety, v14, v27);
      }
      else
      {
        Com_sprintf(byte_859BB1C, 0x400u, aGameVoteMap, v27);
      }
    }
    else
    {
      Com_sprintf(byte_859B71C, 0x400u, "g_gametype %s; map_restart", nptr);
      v15 = sub_8115DD2(nptr);
      Com_sprintf(byte_859BB1C, 0x400u, aGameVoteGamety_0, v15);
    }
    goto LABEL_82;
  }
  if ( !I_stricmp(s, "g_gametype") )
  {
    if ( !Scr_IsValidGameType(nptr) )
      goto LABEL_29;
    Com_sprintf(byte_859B71C, 0x400u, "%s %s; map_restart", s, nptr);
    v16 = sub_8115DD2(nptr);
    Com_sprintf(byte_859BB1C, 0x400u, aGameVoteGamety_0, v16);
    goto LABEL_82;
  }
  if ( !I_stricmp(s, "map_restart") )
  {
    Com_sprintf(byte_859B71C, 0x400u, "fast_restart");
    Com_sprintf(byte_859BB1C, 0x400u, "GAME_VOTE_MAPRESTART");
    goto LABEL_82;
  }
  if ( !I_stricmp(s, "map_rotate") )
  {
    Com_sprintf(byte_859B71C, 0x400u, "%s", s);
    Com_sprintf(byte_859BB1C, 0x400u, "GAME_VOTE_NEXTMAP");
LABEL_82:
    v18 = va(aCGameCalledavo, 101, a2[86] + 10116);
    SV_GameSendServerCommand(-1, 0, v18);
    *(_DWORD *)dword_859BF1C = dword_859B5EC + 30000;
    *(_DWORD *)dword_859BF24 = 1;
    *(_DWORD *)dword_859BF28 = 0;
    for ( i = 0; i < dword_859B5E4; ++i )
      *(_DWORD *)(dword_859B400 + 10404 * i + 160) &= ~0x100000u;
    *(_DWORD *)(a2[86] + 160) |= 0x100000u;
    v19 = va("%i", *(_DWORD *)dword_859BF1C);
    SV_SetConfigstring(0xFu, v19);
    SV_SetConfigstring(0x10u, byte_859BB1C);
    v20 = va("%i", *(_DWORD *)dword_859BF24);
    SV_SetConfigstring(0x11u, v20);
    v21 = va("%i", *(_DWORD *)dword_859BF28);
    return SV_SetConfigstring(0x12u, v21);
  }
  if ( !I_stricmp(s, "map") )
  {
    if ( !SV_MapExists(nptr) )
    {
LABEL_33:
      v12 = va(aC_6, 101);
      return SV_GameSendServerCommand(-1963413621 * (((char *)a2 - (char *)&unk_8665480) >> 4), 0, v12);
    }
    Com_sprintf(byte_859B71C, 0x400u, "%s %s", s, nptr);
    Com_sprintf(byte_859BB1C, 0x400u, aGameVoteMap, nptr);
    goto LABEL_82;
  }
  if ( !I_stricmp(s, "kick")
    || !I_stricmp(s, "clientkick")
    || !I_stricmp(s, "tempBanUser")
    || (result = I_stricmp(s, "tempBanClient")) == 0 )
  {
    v22 = 64;
    if ( I_stricmp(s, "kick") && I_stricmp(s, "tempBanUser") )
    {
      v22 = atoi(nptr);
      if ( (v22 || !I_stricmp(nptr, "0")) && v22 <= 0x3F && *(_DWORD *)(dword_859B400 + 10404 * v22 + 9924) == 2 )
      {
        I_strncpyz(dest, (char *)(dword_859B400 + 10404 * v22 + 10116), 64);
        sub_80B587C(dest);
      }
      else
      {
        v22 = 64;
      }
    }
    else
    {
      for ( j = 0; j <= 63; ++j )
      {
        if ( *(_DWORD *)(dword_859B400 + 10404 * j + 9924) == 2 )
        {
          I_strncpyz(dest, (char *)(dword_859B400 + 10404 * j + 10116), 64);
          sub_80B587C(dest);
          if ( !I_stricmp(dest, nptr) )
            v22 = j;
        }
      }
    }
    if ( v22 == 64 )
    {
      v17 = va("%c \"GAME_CLIENTNOTONSERVER\"", 101);
      return SV_GameSendServerCommand(-1963413621 * (((char *)a2 - (char *)&unk_8665480) >> 4), 0, v17);
    }
    if ( s[0] == 116 || s[0] == 84 )
      Com_sprintf(byte_859B71C, 0x400u, "%s \"%d\"", "tempBanClient", v22);
    else
      Com_sprintf(byte_859B71C, 0x400u, "%s \"%d\"", "clientkick", v22);
    Com_sprintf(byte_859BB1C, 0x400u, aGameVoteKick, v22, dword_859B400 + 10404 * v22 + 10116);
    goto LABEL_82;
  }
  return result;
}
// 859B400: using guessed type int dword_859B400;
// 859B5E4: using guessed type int dword_859B5E4;
// 859BF20: using guessed type int dword_859BF20;
// 8793D80: using guessed type int sv_gametype;
// 8793DF4: using guessed type int g_allowVote;
// 8793E50: using guessed type int g_oldVoting;

//----- (080FE496) --------------------------------------------------------
int __cdecl Cmd_Vote_f(int *a1)
{
  char *v1; // eax
  char *v3; // eax
  char *v4; // eax
  char *v5; // eax
  char *v6; // eax
  char *v7; // eax
  char dest; // [esp+10h] [ebp-48h] BYREF
  char v9; // [esp+11h] [ebp-47h]

  if ( *(_BYTE *)(g_oldVoting + 8) )
  {
    if ( !*(_DWORD *)dword_859BF1C )
    {
      v1 = va("%c \"GAME_NOVOTEINPROGRESS\"", 101);
      return SV_GameSendServerCommand(-1963413621 * (((char *)a1 - (char *)&unk_8665480) >> 4), 0, v1);
    }
    if ( (*(_DWORD *)(a1[86] + 160) & 0x100000) != 0 )
    {
      v3 = va("%c \"GAME_VOTEALREADYCAST\"", 101);
      return SV_GameSendServerCommand(-1963413621 * (((char *)a1 - (char *)&unk_8665480) >> 4), 0, v3);
    }
    if ( *(_DWORD *)(a1[86] + 10060) == 3 )
    {
      v4 = va("%c \"GAME_NOSPECTATORVOTE\"", 101);
      return SV_GameSendServerCommand(-1963413621 * (((char *)a1 - (char *)&unk_8665480) >> 4), 0, v4);
    }
    v5 = va("%c \"GAME_VOTECAST\"", 101);
    SV_GameSendServerCommand(-1963413621 * (((char *)a1 - (char *)&unk_8665480) >> 4), 0, v5);
    *(_DWORD *)(a1[86] + 160) |= 0x100000u;
  }
  SV_Cmd_ArgvBuffer(1, &dest, 64);
  if ( dest == 121 || v9 == 89 || v9 == 49 )
  {
    if ( *(_BYTE *)(g_oldVoting + 8) )
    {
      v6 = va("%i", ++*(_DWORD *)dword_859BF24);
      return SV_SetConfigstring(0x11u, v6);
    }
    else
    {
      return sub_811611C(a1, "yes");
    }
  }
  else if ( *(_BYTE *)(g_oldVoting + 8) )
  {
    v7 = va("%i", ++*(_DWORD *)dword_859BF28);
    return SV_SetConfigstring(0x12u, v7);
  }
  else
  {
    return sub_811611C(a1, "no");
  }
}
// 8793E50: using guessed type int g_oldVoting;

//----- (080FE6BE) --------------------------------------------------------
int __cdecl sub_80FE6BE(int a1)
{
  char *v1; // eax
  char *v3; // eax
  int i; // [esp+1Ch] [ebp-42Ch]
  char nptr[1024]; // [esp+20h] [ebp-428h] BYREF
  _DWORD v6[4]; // [esp+420h] [ebp-28h] BYREF
  float v7[2]; // [esp+430h] [ebp-18h] BYREF
  float v8; // [esp+438h] [ebp-10h]

  if ( *(_BYTE *)(g_cheats + 8) )
  {
    if ( SV_Cmd_Argc() == 5 )
    {
      sub_80FEDEE(v6);
      for ( i = 0; i <= 2; ++i )
      {
        SV_Cmd_ArgvBuffer(i + 1, nptr, 1024);
        v7[i] = atof(nptr);
      }
      SV_Cmd_ArgvBuffer(4, nptr, 1024);
      *(float *)&v6[1] = atof(nptr);
      v8 = v8 - *(float *)(*(_DWORD *)(a1 + 344) + 248);
      return sub_8108270(a1, v7, v6);
    }
    else
    {
      v3 = va(aCGameUsage, 101);
      return SV_GameSendServerCommand(-1963413621 * ((a1 - (int)&unk_8665480) >> 4), 0, v3);
    }
  }
  else
  {
    v1 = va("%c \"GAME_CHEATSNOTENABLED\"", 101);
    return SV_GameSendServerCommand(-1963413621 * ((a1 - (int)&unk_8665480) >> 4), 0, v1);
  }
}
// 8793D98: using guessed type int g_cheats;
// 80FE6BE: using guessed type float var_18[2];

//----- (080FE822) --------------------------------------------------------
void Cmd_EntityCount_f()
{
  if ( *(_BYTE *)(g_cheats + 8) )
    Com_Printf("entity count = %i\n", *(_DWORD *)dword_859B40C);
}
// 8793D98: using guessed type int g_cheats;

//----- (080FE84C) --------------------------------------------------------
int __cdecl sub_80FE84C(int *a1)
{
  int v1; // ebx
  int result; // eax
  char dest[1024]; // [esp+10h] [ebp-C18h] BYREF
  char s[1024]; // [esp+410h] [ebp-818h] BYREF
  char nptr[1036]; // [esp+810h] [ebp-418h] BYREF
  unsigned int v6; // [esp+C1Ch] [ebp-Ch]

  v6 = -1;
  if ( SV_Cmd_Argc() == 4 )
  {
    SV_Cmd_ArgvBuffer(1, nptr, 1024);
    v1 = atoi(nptr);
    result = Dvar_GetInt("sv_serverId");
    if ( v1 != result )
      return result;
    SV_Cmd_ArgvBuffer(2, s, 1024);
    v6 = atoi(s);
    if ( v6 <= 0x1F )
      SV_GetConfigstring(v6 + 1246, s, 1024);
    SV_Cmd_ArgvBuffer(3, dest, 1024);
  }
  else
  {
    s[0] = 0;
    strcpy(dest, "bad");
  }
  Scr_AddString(dest);
  Scr_AddString(s);
  return Scr_Notify(a1, word_87A2310, 2);
}
// 87A2310: using guessed type __int16 word_87A2310;

//----- (080FE98A) --------------------------------------------------------
int sub_80FE98A()
{
  return G_PrintEntities();
}

//----- (080FE998) --------------------------------------------------------
void __usercall ClientCommand(long double a1@<st0>, int a2)
{
  char *v2; // eax
  char dest[1036]; // [esp+10h] [ebp-418h] BYREF
  int *v4; // [esp+41Ch] [ebp-Ch]

  v4 = (int *)((char *)&unk_8665480 + 560 * a2);
  if ( v4[86] )
  {
    SV_Cmd_ArgvBuffer(0, dest, 1024);
    if ( I_stricmp(dest, "say") )
    {
      if ( I_stricmp(dest, "say_team") )
      {
        if ( I_stricmp(dest, "tell") )
        {
          if ( I_stricmp(dest, "score") )
          {
            if ( *(_DWORD *)(v4[86] + 4) != 5 )
            {
              if ( I_stricmp(dest, "mr") )
              {
                if ( I_stricmp(dest, "give") )
                {
                  if ( I_stricmp(dest, "take") )
                  {
                    if ( I_stricmp(dest, "god") )
                    {
                      if ( I_stricmp(dest, "demigod") )
                      {
                        if ( I_stricmp(dest, "notarget") )
                        {
                          if ( I_stricmp(dest, "noclip") )
                          {
                            if ( I_stricmp(dest, "ufo") )
                            {
                              if ( I_stricmp(dest, "kill") )
                              {
                                if ( I_stricmp(dest, "follownext") )
                                {
                                  if ( I_stricmp(dest, "followprev") )
                                  {
                                    if ( I_stricmp(dest, "where") )
                                    {
                                      if ( I_stricmp(dest, "callvote") )
                                      {
                                        if ( I_stricmp(dest, "vote") )
                                        {
                                          if ( I_stricmp(dest, "gc") )
                                          {
                                            if ( I_stricmp(dest, "setviewpos") )
                                            {
                                              if ( I_stricmp(dest, "entitycount") )
                                              {
                                                if ( I_stricmp(dest, "printentities") )
                                                {
                                                  v2 = va(aCGameUnknowncl, 101, dest);
                                                  SV_GameSendServerCommand(a2, 0, v2);
                                                }
                                                else
                                                {
                                                  sub_80FE98A();
                                                }
                                              }
                                              else
                                              {
                                                Cmd_EntityCount_f();
                                              }
                                            }
                                            else
                                            {
                                              sub_80FE6BE((int)v4);
                                            }
                                          }
                                          else
                                          {
                                            sub_80FD5B6(v4);
                                          }
                                        }
                                        else
                                        {
                                          Cmd_Vote_f(v4);
                                        }
                                      }
                                      else
                                      {
                                        Cmd_CallVote_f(a1, v4);
                                      }
                                    }
                                    else
                                    {
                                      sub_80FD692((int)v4);
                                    }
                                  }
                                  else
                                  {
                                    sub_80FCD40((int)v4, -1);
                                  }
                                }
                                else
                                {
                                  sub_80FCD40((int)v4, 1);
                                }
                              }
                              else
                              {
                                sub_80FCA4C(v4);
                              }
                            }
                            else
                            {
                              Cmd_UFO_f((int)v4);
                            }
                          }
                          else
                          {
                            Cmd_Noclip_f((int)v4);
                          }
                        }
                        else
                        {
                          Cmd_Notarget_f((int)v4);
                        }
                      }
                      else
                      {
                        Cmd_DemiGod_f((int)v4);
                      }
                    }
                    else
                    {
                      Cmd_God_f((int)v4);
                    }
                  }
                  else
                  {
                    sub_80FC25E((int)v4);
                  }
                }
                else
                {
                  sub_80FBE1C(a1, v4);
                }
              }
              else
              {
                sub_80FE84C(v4);
              }
            }
          }
          else
          {
            sub_80FB982((int)v4);
          }
        }
        else
        {
          sub_80FD3F0(v4);
        }
      }
      else
      {
        sub_80FD38E(v4, 1, 0);
      }
    }
    else
    {
      sub_80FD38E(v4, 0, 0);
    }
  }
}

//----- (080FEDEE) --------------------------------------------------------
int __cdecl sub_80FEDEE(_DWORD *a1)
{
  int result; // eax

  *a1 = 0;
  a1[1] = 0;
  result = 0;
  a1[2] = 0;
  return result;
}

//----- (080FEE18) --------------------------------------------------------
int __cdecl sub_80FEE18(_DWORD *a1, int a2, int a3, int a4)
{
  int result; // eax

  *a1 = a2;
  a1[1] = a3;
  result = a4;
  a1[2] = a4;
  return result;
}

//----- (080FEE3C) --------------------------------------------------------
int __cdecl sub_80FEE3C(_DWORD *a1, _DWORD *a2)
{
  int result; // eax

  *a2 = *a1;
  a2[1] = a1[1];
  result = a1[2];
  a2[2] = result;
  return result;
}

//----- (080FEE6C) --------------------------------------------------------
float *__cdecl sub_80FEE6C(float *a1, float a2, float *a3, float *a4)
{
  float *result; // eax

  *a4 = a2 * *a3 + *a1;
  a4[1] = a2 * a3[1] + a1[1];
  result = a3 + 2;
  a4[2] = a2 * a3[2] + a1[2];
  return result;
}

//----- (080FEEC0) --------------------------------------------------------
char *__cdecl sub_80FEEC0(char *dest, char *src)
{
  return strcpy(dest, src);
}

//----- (080FEEDA) --------------------------------------------------------
_BOOL4 sub_80FEEDA()
{
  int v0; // ebx
  _BOOL4 result; // eax
  int v2; // [esp+28h] [ebp-2110h] BYREF
  int v3; // [esp+2Ch] [ebp-210Ch]
  char s1[8192]; // [esp+30h] [ebp-2108h] BYREF
  int v5[60]; // [esp+2030h] [ebp-108h] BYREF
  size_t n; // [esp+2120h] [ebp-18h]
  char *s; // [esp+2124h] [ebp-14h]
  char *src; // [esp+2128h] [ebp-10h]
  int i; // [esp+212Ch] [ebp-Ch]

  src = "info/mp_lochit_dmgtable";
  s = "LOCDMGTABLE";
  n = strlen("LOCDMGTABLE");
  for ( i = 0; i <= 18; ++i )
  {
    dword_8577F60[i] = 1065353216;
    v5[3 * i] = (int)(&off_8167740)[i];
    v5[3 * i + 1] = 4 * i;
    v5[3 * i + 2] = 6;
    v0 = i;
    word_8577FC0[v0] = sub_8079808((&off_8167740)[i]);
  }
  dword_8577FA8 = 0;
  v3 = FS_FOpenFileByMode(src, &v2, 0);
  if ( v3 <= 0 )
    Com_Error(1, (char *)&byte_8152520, src);
  FS_Read((int)s1, n, v2);
  s1[n] = 0;
  if ( strncmp(s1, s, n) )
    Com_Error(1, (char *)&byte_8152560, src);
  if ( (int)(v3 - n) > 0x1FFF )
    Com_Error(1, (char *)&byte_81525A0, src);
  FS_Read((int)s1, v3 - n, v2);
  s1[v3 - n] = 0;
  FS_FCloseFile(v2);
  if ( !sub_80B5FA4(s1) )
    Com_Error(1, (char *)&byte_81525E0, src);
  result = sub_80B645E((int)dword_8577F60, (int)v5, 19, s1, 0, 0, (void (__cdecl *)(int, char *))sub_80FEEC0);
  if ( !result )
    Com_Error(1, (char *)&byte_8152620, src);
  return result;
}
// 8577F60: using guessed type int dword_8577F60[18];
// 8577FA8: using guessed type int dword_8577FA8;
// 8577FC0: using guessed type __int16 word_8577FC0[];
// 80FEEDA: using guessed type char s1[8192];
// 80FEEDA: using guessed type int var_108[60];

//----- (080FF17A) --------------------------------------------------------
__int16 __cdecl sub_80FF17A(int a1, int a2, int a3)
{
  __int16 result; // ax
  int v4; // ebx
  __int16 v5; // [esp+1Eh] [ebp-2Ah]
  float v6[6]; // [esp+30h] [ebp-18h] BYREF

  if ( !a3 || a3 == a1 )
  {
    if ( !a2 || a2 == a1 )
    {
      result = v5 | 0xC00;
      *(_DWORD *)(*(_DWORD *)(a1 + 344) + 304) = (int)*(float *)(a1 + 328);
      return result;
    }
    sub_81004B2((float *)(a2 + 312), (float *)(a1 + 312), v6);
  }
  else
  {
    sub_81004B2((float *)(a3 + 312), (float *)(a1 + 312), v6);
  }
  v4 = *(_DWORD *)(a1 + 344);
  *(_DWORD *)(v4 + 304) = (int)sub_80A29F6(v6);
  sub_80A29F6(v6);
  return 0;
}
// 80FF200: variable 'v5' is possibly undefined
// 80FF17A: using guessed type float var_18[6];

//----- (080FF26A) --------------------------------------------------------
int __cdecl G_IndexForMeansOfDeath(char *a1)
{
  int i; // [esp+14h] [ebp-4h]

  for ( i = 0; i <= 14; ++i )
  {
    if ( !I_stricmp(a1, (&off_81677C0)[i]) )
      return i;
  }
  Com_Printf("Unknown means of death string '%s'\n", a1);
  return 0;
}

//----- (080FF2CA) --------------------------------------------------------
int __cdecl sub_80FF2CA(int a1, int *a2, int *a3, int a4, unsigned int a5, int a6, _DWORD *a7, int a8, int a9)
{
  int result; // eax
  int v10; // [esp+34h] [ebp-44h]
  char *v11; // [esp+3Ch] [ebp-3Ch]
  _DWORD *v12; // [esp+3Ch] [ebp-3Ch]
  _DWORD v13[2]; // [esp+40h] [ebp-38h] BYREF
  float v14; // [esp+48h] [ebp-30h]
  int v15[6]; // [esp+50h] [ebp-28h] BYREF
  int v16; // [esp+68h] [ebp-10h]
  int i; // [esp+6Ch] [ebp-Ch]

  result = Com_GetServerDObj(*(_DWORD *)(*(_DWORD *)(a1 + 344) + 204));
  if ( result )
  {
    if ( !*(_DWORD *)(*(_DWORD *)(a1 + 344) + 4) || (result = *(_DWORD *)(a1 + 344), *(_DWORD *)(result + 4) == 1) )
    {
      result = *(_DWORD *)(*(_DWORD *)(a1 + 344) + 12) & 0x400000;
      if ( !result )
      {
        dword_855A4E0 = &unk_859EA40;
        if ( a3[1] == 9 && a3[84] != 1023 )
          a3 = (int *)((char *)&unk_8665480 + 560 * a3[84]);
        Scr_AddEntity(a3);
        Scr_Notify((int *)a1, word_87A22AA, 1);
        if ( a6 )
        {
          if ( a3[86] )
          {
            if ( (*(_DWORD *)(a3[86] + 160) & 0x300) != 0 )
            {
              v11 = (char *)&unk_8665480 + 560 * a3[29];
              if ( *((_DWORD *)v11 + 1) == 9 )
                a6 = *((_DWORD *)v11 + 50);
            }
          }
        }
        if ( *(_DWORD *)(*(_DWORD *)(a1 + 344) + 60) )
        {
          *(float *)v15 = sub_80A142E();
          *(float *)&v15[1] = sub_80A142E();
          *(float *)&v15[2] = sub_80A1410();
          sub_81004F6((float *)v15, 160.0, (float *)v15);
          sub_810043E((_DWORD *)(a1 + 312), v13);
          v14 = v14 + 40.0;
          sub_810C1F6(
            (_DWORD *)a1,
            v13,
            (float *)v15,
            *(_DWORD *)(*(_DWORD *)(a1 + 344) + 208),
            *(_DWORD *)(*(_DWORD *)(a1 + 344) + 60));
        }
        if ( *(_DWORD *)(*(_DWORD *)(a1 + 344) + 4) == 1 )
          v10 = 7;
        else
          v10 = 6;
        *(_DWORD *)(*(_DWORD *)(a1 + 344) + 4) = v10;
        v16 = BG_AnimScriptEvent(*(_DWORD **)(a1 + 344), 1, 0, 1);
        Scr_PlayerKilled((int *)a1, a2, a3, a4, a5, a6, a7, a8, a9, v16);
        for ( i = 0; i < dword_859B5E4; ++i )
        {
          v12 = (_DWORD *)(dword_859B400 + 10404 * i);
          if ( v12[2481] == 2 && v12[2474] == 2 && v12[2538] == *(_DWORD *)a1 )
            sub_80FB982(560 * i + 140924032);
        }
        *(_BYTE *)(a1 + 353) = 1;
        *(_DWORD *)(a1 + 284) = 0x4000000;
        *(_DWORD *)(a1 + 332) = 0;
        sub_80FF17A(a1, (int)a2, (int)a3);
        sub_810043E((_DWORD *)(a1 + 324), (_DWORD *)(*(_DWORD *)(a1 + 344) + 232));
        *(_DWORD *)(a1 + 132) = 0;
        SV_UnlinkEntity(a1);
        *(_DWORD *)(a1 + 280) = 1106247680;
        SV_LinkEntity(a1);
        *(_DWORD *)(a1 + 404) = 0;
        result = a1;
        *(_BYTE *)(a1 + 358) = 11;
      }
    }
  }
  return result;
}
// 859B400: using guessed type int dword_859B400;
// 859B5E4: using guessed type int dword_859B5E4;
// 87A22AA: using guessed type __int16 word_87A22AA;
// 80FF2CA: using guessed type _DWORD var_38[2];

//----- (080FF652) --------------------------------------------------------
long double __cdecl sub_80FF652(int a1, int a2)
{
  int v4; // [esp+14h] [ebp-4h]

  if ( a2 )
  {
    v4 = BG_WeaponDefs(a2);
    if ( v4 && !*(_DWORD *)(v4 + 120) )
      return *(float *)(v4 + 4 * a1 + 1456);
    else
      return dword_8577F60[a1];
  }
  else
  {
    return dword_8577F60[a1];
  }
}
// 8577F60: using guessed type float dword_8577F60[18];

//----- (080FF6B0) --------------------------------------------------------
__int16 __cdecl sub_80FF6B0(
        int a1,
        int *a2,
        int *a3,
        _DWORD *a4,
        _DWORD *a5,
        int a6,
        int a7,
        unsigned int a8,
        int a9,
        int a10)
{
  _DWORD *v10; // eax
  long double v11; // fst7
  float v13; // [esp+2Ch] [ebp-Ch]
  __int16 v14; // [esp+32h] [ebp-6h]
  int v15; // [esp+34h] [ebp-4h]
  int v16; // [esp+54h] [ebp+1Ch]

  LOWORD(v10) = a1;
  if ( *(_BYTE *)(a1 + 353) )
  {
    v10 = *(_DWORD **)(a1 + 344);
    if ( !v10[2539] )
    {
      v10 = *(_DWORD **)(a1 + 344);
      if ( !v10[2540] )
      {
        v10 = *(_DWORD **)(a1 + 344);
        if ( v10[2481] == 2 )
        {
          if ( a2 )
          {
            v15 = a2[50];
          }
          else if ( a3 )
          {
            v15 = a3[50];
          }
          else
          {
            v15 = 0;
          }
          v13 = (float)a6;
          v11 = sub_80FF652(a9, v15);
          LOWORD(v10) = v14 | 0xC00;
          v16 = (int)(v11 * v13);
          if ( v16 > 0 )
            LOWORD(v10) = Scr_PlayerDamage((int *)a1, a2, a3, v16, a7, a8, v15, a5, a4, a9, a10);
        }
      }
    }
  }
  return (__int16)v10;
}
// 80FF75B: variable 'v14' is possibly undefined

//----- (080FF7C8) --------------------------------------------------------
__int16 __cdecl sub_80FF7C8(
        int *a1,
        int *a2,
        int *a3,
        float *a4,
        _DWORD *a5,
        int a6,
        int a7,
        unsigned int a8,
        int a9,
        int a10)
{
  int (__cdecl *v10)(int *, int *, int *, int, unsigned int, int, char *, int, int); // eax
  char v12[24]; // [esp+40h] [ebp-18h] BYREF

  if ( a1[86] )
  {
    LOWORD(v10) = sub_80FF6B0((int)a1, a2, a3, a4, a5, a6, a7, a8, a9, a10);
  }
  else
  {
    LOWORD(v10) = (_WORD)a1;
    if ( *((_BYTE *)a1 + 353) )
    {
      if ( !a2 )
        a2 = &dword_86F1020;
      if ( !a3 )
        a3 = &dword_86F1020;
      sub_80A2298(a4, (int)v12);
      v10 = (int (__cdecl *)(int *, int *, int *, int, unsigned int, int, char *, int, int))(a1[93] & 1);
      if ( !(_BYTE)v10 )
      {
        if ( a6 <= 0 )
          a6 = 1;
        if ( (a1[93] & 2) != 0 && a1[101] - a6 <= 0 )
          a6 = a1[101] - 1;
        if ( *(_BYTE *)(g_debugDamage + 8) )
          Com_Printf("target:%i health:%i damage:%i\n", *a1, a1[101], a6);
        a1[101] -= a6;
        Scr_AddEntity(a3);
        Scr_AddInt(a6);
        Scr_Notify(a1, word_87A22A8, 2);
        if ( a1[101] > 0 )
        {
          v10 = (int (__cdecl *)(int *, int *, int *, int, unsigned int, int, char *, int, int))dword_8167894[10 * *((unsigned __int8 *)a1 + 358)];
          if ( v10 )
            LOWORD(v10) = ((int (__cdecl *)(int *, int *, int, _DWORD *, unsigned int, char *, int))v10)(
                            a1,
                            a3,
                            a6,
                            a5,
                            a8,
                            v12,
                            a9);
        }
        else
        {
          if ( a1[101] < -999 )
            a1[101] = -999;
          Scr_AddEntity(a3);
          Scr_Notify(a1, word_87A22AA, 1);
          v10 = (int (__cdecl *)(int *, int *, int *, int, unsigned int, int, char *, int, int))dword_8167898[10 * *((unsigned __int8 *)a1 + 358)];
          if ( v10 )
            LOWORD(v10) = v10(a1, a2, a3, a6, a8, a2[50], v12, a9, a10);
        }
      }
    }
  }
  return (__int16)v10;
}
// 8167894: using guessed type int dword_8167894[];
// 8167898: using guessed type int dword_8167898[];
// 86F1020: using guessed type int dword_86F1020;
// 8793DAC: using guessed type int g_debugDamage;
// 87A22A8: using guessed type __int16 word_87A22A8;
// 87A22AA: using guessed type __int16 word_87A22AA;

//----- (080FFA56) --------------------------------------------------------
long double __cdecl sub_80FFA56(int a1, float *a2)
{
  int v4; // [esp+18h] [ebp-A0h]
  float v5; // [esp+1Ch] [ebp-9Ch]
  float v6[4]; // [esp+20h] [ebp-98h] BYREF
  int v7[4]; // [esp+30h] [ebp-88h] BYREF
  int v8[2]; // [esp+40h] [ebp-78h] BYREF
  int v9; // [esp+48h] [ebp-70h]
  int i; // [esp+5Ch] [ebp-5Ch]
  float v11[3]; // [esp+60h] [ebp-58h] BYREF
  float v12; // [esp+6Ch] [ebp-4Ch] BYREF
  float v13; // [esp+70h] [ebp-48h]
  float v14; // [esp+74h] [ebp-44h]
  float v15; // [esp+78h] [ebp-40h] BYREF
  float v16; // [esp+7Ch] [ebp-3Ch]
  float v17; // [esp+80h] [ebp-38h]
  float v18; // [esp+84h] [ebp-34h] BYREF
  float v19; // [esp+88h] [ebp-30h]
  float v20; // [esp+8Ch] [ebp-2Ch]
  float v21; // [esp+90h] [ebp-28h] BYREF
  float v22; // [esp+94h] [ebp-24h]
  float v23; // [esp+98h] [ebp-20h]
  int v24; // [esp+ACh] [ebp-Ch]

  v24 = 1097859072;
  if ( *(_DWORD *)(a1 + 344) )
  {
    sub_80F61BE(a1, v6);
    v5 = (v6[2] - *(float *)(a1 + 320)) * 0.5;
    sub_81004B2(a2, (float *)(a1 + 312), (float *)v8);
    v9 = 0;
    Vec3Normalize((float *)v8);
    v7[0] = v8[1] ^ 0x80000000;
    v7[1] = v8[0];
    v7[2] = v9;
    sub_810046E(v6, (float *)(a1 + 312), v11);
    sub_81004F6(v11, 0.5, v11);
    sub_810052E(v11, 15.0, (float *)v7, &v12);
    v14 = v14 + v5;
    sub_810052E(v11, 15.0, (float *)v7, &v15);
    v17 = v17 - v5;
    sub_810052E(v11, -15.0, (float *)v7, &v18);
    v20 = v20 + v5;
    sub_810052E(v11, -15.0, (float *)v7, &v21);
    v23 = v23 - v5;
    v4 = 0;
    for ( i = 0; i <= 4; ++i )
    {
      if ( G_LocationalTracePassed(a2, &v11[3 * i], *(_DWORD *)a1, 8398993) )
        ++v4;
    }
    if ( v4 )
    {
      if ( v4 <= 3 )
        return (float)((long double)v4 / 3.0);
      else
        return (float)1.0;
    }
    else
    {
      return (float)0.0;
    }
  }
  else
  {
    sub_810046E((float *)(a1 + 288), (float *)(a1 + 300), v11);
    sub_81004F6(v11, 0.5, v11);
    sub_810043E(v11, &v12);
    v12 = v12 + 15.0;
    v13 = v13 + 15.0;
    sub_810043E(v11, &v15);
    v15 = v15 + 15.0;
    v16 = v16 - 15.0;
    sub_810043E(v11, &v18);
    v18 = v18 - 15.0;
    v19 = v19 + 15.0;
    sub_810043E(v11, &v21);
    v21 = v21 - 15.0;
    v22 = v22 - 15.0;
    for ( i = 0; i <= 4; ++i )
    {
      if ( G_LocationalTracePassed(&v11[3 * i], a2, *(_DWORD *)a1, 8398993) )
        return (float)1.0;
    }
    return (float)0.0;
  }
}
// 80FFA56: using guessed type float var_58[3];

//----- (080FFE10) --------------------------------------------------------
int __cdecl G_RadiusDamage(float *a1, int *a2, int *a3, float a4, float a5, float a6, int *a7, int a8)
{
  long double v8; // fst7
  int v11[4]; // [esp+40h] [ebp-10C8h] BYREF
  float s[12]; // [esp+50h] [ebp-10B8h] BYREF
  int v13[4]; // [esp+80h] [ebp-1088h] BYREF
  float v14; // [esp+90h] [ebp-1078h]
  int v15; // [esp+94h] [ebp-1074h]
  int j; // [esp+98h] [ebp-1070h]
  int i; // [esp+9Ch] [ebp-106Ch]
  float v18[2]; // [esp+A0h] [ebp-1068h] BYREF
  float v19; // [esp+A8h] [ebp-1060h]
  float v20[4]; // [esp+B0h] [ebp-1058h] BYREF
  float v21[4]; // [esp+C0h] [ebp-1048h] BYREF
  float v22[7]; // [esp+D0h] [ebp-1038h] BYREF
  int v23; // [esp+ECh] [ebp-101Ch]
  int v24[1024]; // [esp+F0h] [ebp-1018h] BYREF
  float *v25; // [esp+10F0h] [ebp-18h]
  float v26; // [esp+10F4h] [ebp-14h]
  float v27; // [esp+10F8h] [ebp-10h]
  float v28; // [esp+10FCh] [ebp-Ch]

  v15 = 0;
  if ( !a3 )
    return 0;
  if ( a6 < 1.0 )
    a6 = 1.0;
  v8 = a6 * 1.4142135;
  v14 = v8;
  for ( i = 0; i <= 2; ++i )
  {
    v22[i] = a1[i] - v14;
    v8 = a1[i] + v14;
    v21[i] = v8;
  }
  v23 = sub_805E782((int)v22, (int)v21, (int)v24, 1024, -1);
  for ( j = 0; j < v23; ++j )
  {
    v25 = (float *)((char *)&unk_8665480 + 560 * v24[j]);
    if ( v25 != (float *)a7 && *((_BYTE *)v25 + 353) )
    {
      if ( *((_BYTE *)v25 + 241) )
      {
        for ( i = 0; i <= 2; ++i )
        {
          if ( v25[i + 72] <= (long double)a1[i] )
          {
            v8 = v25[i + 75];
            if ( a1[i] <= v8 )
            {
              v20[i] = 0.0;
            }
            else
            {
              v8 = a1[i] - v25[i + 75];
              v20[i] = v8;
            }
          }
          else
          {
            v8 = v25[i + 72] - a1[i];
            v20[i] = v8;
          }
        }
      }
      else
      {
        sub_81004B2(v25 + 78, a1, v20);
      }
      sub_8100582(v20);
      v27 = v8;
      v8 = a6;
      if ( v27 < (long double)a6 && (!*((_DWORD *)v25 + 86) || !dword_859E9F4) )
      {
        v28 = (a4 - a5) * (1.0 - v27 / a6) + a5;
        v26 = sub_80FFA56((int)v25, a1);
        if ( v26 <= 0.0 )
        {
          sub_810046E(v25 + 72, v25 + 75, (float *)v11);
          sub_81004F6((float *)v11, 0.5, (float *)v11);
          sub_810043E(v11, v13);
          G_TraceCapsule(s, a1, flt_8145E68, flt_8145E68, (float *)v13, 1023, 2065);
          v8 = s[0];
          if ( s[0] < 1.0 )
          {
            sub_81004B2((float *)v13, a1, (float *)v13);
            sub_8100582((float *)v13);
            v27 = v8;
            v8 = v27;
            if ( a6 * 0.2 > v27 )
            {
              if ( sub_811E2C2((int)v25, (int)a3) )
                v15 = 1;
              sub_81004B2(v25 + 78, a1, v18);
              v19 = v19 + 24.0;
              v8 = v28 * 0.1;
              sub_80FF7C8((int *)v25, a2, a3, v18, a1, (int)v8, 1, a8, 0, 0);
            }
          }
        }
        else
        {
          if ( sub_811E2C2((int)v25, (int)a3) )
            v15 = 1;
          sub_81004B2(v25 + 78, a1, v18);
          v19 = v19 + 24.0;
          v8 = v28 * v26;
          sub_80FF7C8((int *)v25, a2, a3, v18, a1, (int)v8, 1, a8, 0, 0);
        }
      }
    }
  }
  return v15;
}
// 8145E68: using guessed type float flt_8145E68[3];
// 859E9F4: using guessed type int dword_859E9F4;
// 80FFE10: using guessed type float var_1038[7];
// 80FFE10: using guessed type float var_1048[4];
// 80FFE10: using guessed type int var_1018[1024];
// 80FFE10: using guessed type float var_1058[4];
// 80FFE10: using guessed type float var_1068[2];
// 80FFE10: using guessed type float s[12];

//----- (081003E6) --------------------------------------------------------
int __cdecl G_GetHitLocationString(int a1)
{
  return (unsigned __int16)word_8577FC0[a1];
}
// 8577FC0: using guessed type __int16 word_8577FC0[];

//----- (081003F6) --------------------------------------------------------
int __cdecl sub_81003F6(__int16 a1)
{
  int i; // [esp+4h] [ebp-8h]

  for ( i = 0; i <= 18; ++i )
  {
    if ( word_8577FC0[i] == a1 )
      return i;
  }
  return 0;
}
// 8577FC0: using guessed type __int16 word_8577FC0[];

//----- (0810043E) --------------------------------------------------------
int __cdecl sub_810043E(_DWORD *a1, _DWORD *a2)
{
  int result; // eax

  *a2 = *a1;
  a2[1] = a1[1];
  result = a1[2];
  a2[2] = result;
  return result;
}

//----- (0810046E) --------------------------------------------------------
float *__cdecl sub_810046E(float *a1, float *a2, float *a3)
{
  float *result; // eax

  *a3 = *a1 + *a2;
  a3[1] = a1[1] + a2[1];
  result = a1 + 2;
  a3[2] = a1[2] + a2[2];
  return result;
}

//----- (081004B2) --------------------------------------------------------
float *__cdecl sub_81004B2(float *a1, float *a2, float *a3)
{
  float *result; // eax

  *a3 = *a1 - *a2;
  a3[1] = a1[1] - a2[1];
  result = a1 + 2;
  a3[2] = a1[2] - a2[2];
  return result;
}

//----- (081004F6) --------------------------------------------------------
float *__cdecl sub_81004F6(float *a1, float a2, float *a3)
{
  float *result; // eax

  *a3 = a2 * *a1;
  a3[1] = a2 * a1[1];
  result = a1 + 2;
  a3[2] = a2 * a1[2];
  return result;
}

//----- (0810052E) --------------------------------------------------------
float *__cdecl sub_810052E(float *a1, float a2, float *a3, float *a4)
{
  float *result; // eax

  *a4 = a2 * *a3 + *a1;
  a4[1] = a2 * a3[1] + a1[1];
  result = a3 + 2;
  a4[2] = a2 * a3[2] + a1[2];
  return result;
}

//----- (08100582) --------------------------------------------------------
void __cdecl sub_8100582(float *a1)
{
  float v1; // [esp+0h] [ebp-8h]

  v1 = *a1 * *a1 + a1[1] * a1[1] + a1[2] * a1[2];
  sub_81005C0(v1);
}

//----- (081005C0) --------------------------------------------------------
long double __cdecl sub_81005C0(float a1)
{
  return (float)sqrt(a1);
}

//----- (081005E0) --------------------------------------------------------
void sub_81005E0()
{
  ;
}

//----- (081005E6) --------------------------------------------------------
void __cdecl sub_81005E6(float *a1, int a2, int a3, float a4)
{
  float v4; // [esp+0h] [ebp-C8h]
  float v5; // [esp+24h] [ebp-A4h]
  float v6[6]; // [esp+30h] [ebp-98h] BYREF
  int v7; // [esp+48h] [ebp-80h] BYREF
  int v8[27]; // [esp+4Ch] [ebp-7Ch] BYREF
  int j; // [esp+B8h] [ebp-10h]
  int i; // [esp+BCh] [ebp-Ch]

  v4 = a4 * 0.0174532925199433;
  sub_8100C02(v4, (float *)v8, (float *)&v7);
  for ( i = 0; i <= 7; ++i )
  {
    for ( j = 0; j <= 2; ++j )
    {
      if ( ((i >> j) & 1) != 0 )
        v5 = *(float *)(a3 + 4 * j);
      else
        v5 = *(float *)(a2 + 4 * j);
      *(float *)&v8[3 * i + 1 + j] = v5;
    }
    v6[0] = *(float *)&v8[3 * i + 1] * *(float *)&v7 - *(float *)&v8[3 * i + 2] * *(float *)v8;
    v6[1] = *(float *)&v8[3 * i + 1] * *(float *)v8 + *(float *)&v8[3 * i + 2] * *(float *)&v7;
    sub_8100C30(v6, &v8[3 * i + 1]);
    sub_8100CA4((float *)&v8[3 * i + 1], a1, (float *)&v8[3 * i + 1]);
  }
  for ( i = 0; (unsigned int)i <= 0xB; ++i )
    sub_81005E0();
}

//----- (081007DE) --------------------------------------------------------
float *__cdecl sub_81007DE(float *a1, float a2, int a3, int a4, int a5)
{
  float v6[2]; // [esp+20h] [ebp-28h] BYREF
  float v7; // [esp+28h] [ebp-20h]
  int v8[6]; // [esp+30h] [ebp-18h] BYREF

  if ( a5 )
  {
    sub_8100C50(v8, 0, 0, 1065353216);
  }
  else
  {
    sub_8100C74((_DWORD *)(dword_859B400 + 20), v6);
    v7 = v7 + *(float *)(dword_859B400 + 248);
    sub_8100CE8(a1, v6, (float *)v8);
  }
  return sub_8100884(a1, a2, (float *)v8);
}
// 859B400: using guessed type int dword_859B400;
// 81007DE: using guessed type float var_28[2];

//----- (08100884) --------------------------------------------------------
float *__cdecl sub_8100884(float *a1, float a2, float *a3)
{
  float *result; // eax
  float v4; // [esp+2Ch] [ebp-10Ch] BYREF
  float v5[2]; // [esp+30h] [ebp-108h] BYREF
  float v6; // [esp+38h] [ebp-100h]
  unsigned int i; // [esp+3Ch] [ebp-FCh] BYREF
  int v8[4]; // [esp+40h] [ebp-F8h] BYREF
  int v9[4]; // [esp+50h] [ebp-E8h] BYREF
  float v10[54]; // [esp+60h] [ebp-D8h] BYREF

  sub_80A2298(a3, (int)v10);
  sub_80A30BA(v10, (float *)v9);
  result = sub_80A1ED8(v10, (float *)v9, (float *)v8);
  for ( i = 0; i <= 0xF; ++i )
  {
    v6 = (long double)(int)i * 0.3926990816987241;
    sub_8100C02(v6, v5, &v4);
    v5[0] = v5[0] * a2;
    v4 = v4 * a2;
    sub_8100D2C(a1, v5[0], (float *)v8, &v10[3 * i + 4]);
    sub_8100D2C(&v10[3 * i + 4], v4, (float *)v9, &v10[3 * i + 4]);
    result = (float *)&i;
  }
  for ( i = 0; i <= 0xF; ++i )
  {
    sub_81005E0();
    result = (float *)&i;
  }
  return result;
}
// 8100884: using guessed type float var_108[2];

//----- (08100A5A) --------------------------------------------------------
void __cdecl sub_8100A5A(float *a1, float a2, float a3, float a4)
{
  int v4; // [esp+28h] [ebp-E0h] BYREF
  float v5[2]; // [esp+2Ch] [ebp-DCh] BYREF
  float v6; // [esp+34h] [ebp-D4h]
  float v7; // [esp+38h] [ebp-D0h]
  unsigned int i; // [esp+3Ch] [ebp-CCh]
  float v9[48]; // [esp+40h] [ebp-C8h]

  v7 = (a4 - a3) / 15.0;
  if ( v7 < 0.0 )
  {
    a3 = a3 - 360.0;
    v7 = (a4 - a3) / 15.0;
  }
  for ( i = 0; i <= 0xF; ++i )
  {
    v6 = ((long double)(int)i * v7 + a3) * 0.0174532925199433;
    sub_8100C02(v6, v5, (float *)&v4);
    v9[3 * i] = *(float *)&v4 * a2 + *a1;
    v9[3 * i + 1] = v5[0] * a2 + a1[1];
    v9[3 * i + 2] = a1[2];
  }
  for ( i = 0; i <= 0xE; ++i )
    sub_81005E0();
}
// 8100A5A: using guessed type float var_DC[2];
// 8100A5A: using guessed type float var_C8[48];

//----- (08100C02) --------------------------------------------------------
void __cdecl sub_8100C02(float a1, float *a2, float *a3)
{
  *a2 = sin(a1);
  *a3 = cos(a1);
}

//----- (08100C30) --------------------------------------------------------
int __cdecl sub_8100C30(_DWORD *a1, _DWORD *a2)
{
  int result; // eax

  *a2 = *a1;
  result = a1[1];
  a2[1] = result;
  return result;
}

//----- (08100C50) --------------------------------------------------------
int __cdecl sub_8100C50(_DWORD *a1, int a2, int a3, int a4)
{
  int result; // eax

  *a1 = a2;
  a1[1] = a3;
  result = a4;
  a1[2] = a4;
  return result;
}

//----- (08100C74) --------------------------------------------------------
int __cdecl sub_8100C74(_DWORD *a1, _DWORD *a2)
{
  int result; // eax

  *a2 = *a1;
  a2[1] = a1[1];
  result = a1[2];
  a2[2] = result;
  return result;
}

//----- (08100CA4) --------------------------------------------------------
float *__cdecl sub_8100CA4(float *a1, float *a2, float *a3)
{
  float *result; // eax

  *a3 = *a1 + *a2;
  a3[1] = a1[1] + a2[1];
  result = a1 + 2;
  a3[2] = a1[2] + a2[2];
  return result;
}

//----- (08100CE8) --------------------------------------------------------
float *__cdecl sub_8100CE8(float *a1, float *a2, float *a3)
{
  float *result; // eax

  *a3 = *a1 - *a2;
  a3[1] = a1[1] - a2[1];
  result = a1 + 2;
  a3[2] = a1[2] - a2[2];
  return result;
}

//----- (08100D2C) --------------------------------------------------------
float *__cdecl sub_8100D2C(float *a1, float a2, float *a3, float *a4)
{
  float *result; // eax

  *a4 = a2 * *a3 + *a1;
  a4[1] = a2 * a3[1] + a1[1];
  result = a3 + 2;
  a4[2] = a2 * a3[2] + a1[2];
  return result;
}

//----- (08100D80) --------------------------------------------------------
_DWORD *__cdecl sub_8100D80(_DWORD *a1)
{
  _DWORD *result; // eax

  a1[13] = 0;
  a1[14] = 0;
  a1[15] = 0;
  a1[20] = 0;
  a1[21] = 0;
  a1[22] = 0;
  a1[23] = 0;
  a1[16] = 0;
  a1[17] = 0;
  a1[18] = 0;
  a1[19] = 0;
  a1[26] = 0;
  a1[27] = 0;
  a1[28] = 0;
  result = a1;
  a1[29] = 0;
  return result;
}

//----- (08100E1E) --------------------------------------------------------
_DWORD *__cdecl sub_8100E1E(_DWORD *a1)
{
  *a1 = 1;
  a1[1] = 0;
  a1[2] = 0;
  a1[3] = 0;
  a1[4] = 1065353216;
  a1[5] = 0;
  a1[6] = 0;
  a1[7] = 0;
  a1[8] = -1;
  a1[9] = 0;
  a1[10] = 0;
  a1[11] = 0;
  a1[12] = 0;
  a1[30] = 0;
  a1[31] = 0;
  a1[34] = 1;
  return sub_8100D80(a1);
}

//----- (08100EDA) --------------------------------------------------------
int __cdecl sub_8100EDA(int a1, int a2)
{
  unsigned int i; // [esp+14h] [ebp-4h]

  for ( i = 0; i <= 0x3FF; ++i )
  {
    if ( !dword_8578000[35 * i] )
    {
      sub_8100E1E((_DWORD *)(140 * i + 139952128));
      dword_8578080[35 * i] = a1;
      dword_8578084[35 * i] = a2;
      return 140 * i + 139952128;
    }
  }
  return 0;
}
// 8578000: using guessed type int dword_8578000[];
// 8578080: using guessed type int dword_8578080[];
// 8578084: using guessed type int dword_8578084[35807];

//----- (08100F68) --------------------------------------------------------
_DWORD *__cdecl sub_8100F68(_DWORD *a1)
{
  _DWORD *result; // eax

  Scr_FreeHudElem((int)a1);
  result = a1;
  *a1 = 0;
  return result;
}

//----- (08100F84) --------------------------------------------------------
int *__cdecl sub_8100F84(_DWORD *a1)
{
  int *result; // eax
  unsigned int i; // [esp+4h] [ebp-4h] BYREF

  for ( i = 0; i <= 0x3FF; ++i )
  {
    if ( dword_8578000[35 * i] )
    {
      if ( dword_8578080[35 * i] == *a1 )
        sub_8100F68((_DWORD *)(140 * i + 139952128));
    }
    result = (int *)&i;
  }
  return result;
}
// 8578000: using guessed type int dword_8578000[];
// 8578080: using guessed type int dword_8578080[];

//----- (08100FE6) --------------------------------------------------------
void *sub_8100FE6()
{
  unsigned int i; // [esp+14h] [ebp-4h]

  for ( i = 0; i <= 0x3FF; ++i )
  {
    if ( dword_8578000[35 * i] )
      sub_8100F68((_DWORD *)(140 * i + 139952128));
  }
  return memset(dword_8578000, 0, 0x23000u);
}
// 8578000: using guessed type int dword_8578000[];

//----- (0810104E) --------------------------------------------------------
void __cdecl sub_810104E(int a1, int a2, int a3, int a4)
{
  char *v4; // eax
  _DWORD *v5; // [esp+1Ch] [ebp-81Ch]
  char s[2056]; // [esp+20h] [ebp-818h] BYREF
  char *v7; // [esp+828h] [ebp-10h]
  int i; // [esp+82Ch] [ebp-Ch]

  v5 = (_DWORD *)(a1 + *(_DWORD *)(a2 + 4));
  v7 = (char *)Scr_GetString(0);
  for ( i = 0; i < a4; ++i )
  {
    if ( !I_stricmp(v7, *(char **)(a3 + 4 * i)) )
    {
      *v5 &= ~(*(_DWORD *)(a2 + 12) << *(_BYTE *)(a2 + 16));
      *v5 |= i << *(_BYTE *)(a2 + 16);
      return;
    }
  }
  sprintf(s, "\"%s\" is not a valid value for hudelem field \"%s\"\nShould be one of:", v7, *(const char **)a2);
  for ( i = 0; i < a4; ++i )
  {
    v4 = va(" %s", *(const char **)(a3 + 4 * i));
    strncat(s, v4, 0x800u);
    s[2047] = 0;
  }
  Scr_Error((int)s);
}

//----- (08101188) --------------------------------------------------------
int __cdecl sub_8101188(int a1, int a2, int a3)
{
  return Scr_AddString(*(char **)(a3
                              + 4 * (*(_DWORD *)(a2 + 12) & (*(int *)(a1 + *(_DWORD *)(a2 + 4)) >> *(_BYTE *)(a2 + 16)))));
}

//----- (081011D0) --------------------------------------------------------
int *__cdecl sub_81011D0(int a1, int a2)
{
  int v2; // edx
  int *result; // eax
  char *s2; // [esp+10h] [ebp-8h]

  s2 = (char *)Scr_GetIString(0);
  v2 = G_LocalizedStringIndex(s2);
  result = (int *)((char *)*(&off_8152E40 + 7 * a2 + 1) + a1);
  *result = v2;
  return result;
}
// 8152E40: using guessed type __int16 *off_8152E40;

//----- (0810121A) --------------------------------------------------------
int __cdecl sub_810121A(int a1, int a2)
{
  int result; // eax

  result = Scr_GetInt(0);
  *(_DWORD *)((char *)*(&off_8152E40 + 7 * a2 + 1) + a1) = result;
  return result;
}
// 8152E40: using guessed type __int16 *off_8152E40;

//----- (0810125C) --------------------------------------------------------
int __usercall sub_810125C@<eax>(long double a1@<st0>, _BYTE *a2)
{
  long double v2; // fst7
  long double v3; // fst7
  int result; // eax
  float v5; // [esp+0h] [ebp-28h]
  float v6; // [esp+0h] [ebp-28h]
  float v7; // [esp+0h] [ebp-28h]
  float v8; // [esp+4h] [ebp-24h]
  float v9; // [esp+4h] [ebp-24h]
  float v10; // [esp+4h] [ebp-24h]
  float v11[6]; // [esp+10h] [ebp-18h] BYREF

  Scr_GetVector(0, v11);
  sub_8102580(1.0, v11[0]);
  v8 = a1;
  sub_810255C(0.0, v8);
  v2 = a1 * 255.0;
  v5 = v2;
  a2[32] = sub_81025A4(v5);
  sub_8102580(1.0, v11[1]);
  v9 = v2;
  sub_810255C(0.0, v9);
  v3 = v2 * 255.0;
  v6 = v3;
  a2[33] = sub_81025A4(v6);
  sub_8102580(1.0, v11[2]);
  v10 = v3;
  sub_810255C(0.0, v10);
  v7 = v3 * 255.0;
  result = sub_81025A4(v7);
  a2[34] = result;
  return result;
}

//----- (0810132E) --------------------------------------------------------
_DWORD *__cdecl sub_810132E(unsigned __int8 *a1)
{
  float v2[6]; // [esp+10h] [ebp-18h] BYREF

  v2[0] = (long double)a1[32] * 0.0039215689;
  v2[1] = (long double)a1[33] * 0.0039215689;
  v2[2] = (long double)a1[34] * 0.0039215689;
  return Scr_AddVector(v2);
}

//----- (08101390) --------------------------------------------------------
int __cdecl sub_8101390(int a1)
{
  long double v1; // fst7
  int result; // eax
  float v3; // [esp+0h] [ebp-18h]
  float v4; // [esp+4h] [ebp-14h]
  float v5; // [esp+10h] [ebp-8h]

  v1 = Scr_GetFloat(0);
  v5 = v1;
  sub_8102580(1.0, v5);
  v4 = v1;
  sub_810255C(0.0, v4);
  v3 = v1 * 255.0;
  result = sub_81025A4(v3);
  *(_BYTE *)(a1 + 35) = result;
  return result;
}

//----- (081013E8) --------------------------------------------------------
int __cdecl sub_81013E8(int a1)
{
  int v2; // [esp+0h] [ebp-8h]

  *(float *)&v2 = (long double)*(unsigned __int8 *)(a1 + 35) * 0.0039215689;
  return Scr_AddFloat(v2);
}

//----- (08101410) --------------------------------------------------------
int __cdecl sub_8101410(int a1)
{
  char *v1; // eax
  int result; // eax
  float v3; // [esp+14h] [ebp-4h]

  v3 = Scr_GetFloat(0);
  if ( v3 <= 0.0 )
  {
    v1 = va("font scale was %g; should be > 0", v3);
    Scr_Error((int)v1);
  }
  result = LODWORD(v3);
  *(float *)(a1 + 16) = v3;
  return result;
}

//----- (0810145A) --------------------------------------------------------
void __cdecl sub_810145A(int a1, int a2)
{
  sub_810104E(a1, 28 * a2 + 135605824, (int)off_8167800, 3);
}
// 8167800: using guessed type char *off_8167800[9];

//----- (08101494) --------------------------------------------------------
int __cdecl sub_8101494(int a1, int a2)
{
  return sub_8101188(a1, 28 * a2 + 135605824, (int)off_8167800);
}
// 8167800: using guessed type char *off_8167800[9];

//----- (081014CE) --------------------------------------------------------
void __cdecl sub_81014CE(int a1, int a2)
{
  sub_810104E(a1, 28 * a2 + 135605824, (int)off_816780C, 3);
}
// 816780C: using guessed type char *off_816780C[6];

//----- (08101508) --------------------------------------------------------
int __cdecl sub_8101508(int a1, int a2)
{
  return sub_8101188(a1, 28 * a2 + 135605824, (int)off_816780C);
}
// 816780C: using guessed type char *off_816780C[6];

//----- (08101542) --------------------------------------------------------
void __cdecl sub_8101542(int a1, int a2)
{
  sub_810104E(a1, 28 * a2 + 135605824, (int)off_8167818, 3);
}
// 8167818: using guessed type char *off_8167818[3];

//----- (0810157C) --------------------------------------------------------
int __cdecl sub_810157C(int a1, int a2)
{
  return sub_8101188(a1, 28 * a2 + 135605824, (int)off_8167818);
}
// 8167818: using guessed type char *off_8167818[3];

//----- (081015B6) --------------------------------------------------------
void __cdecl sub_81015B6(int a1, int a2)
{
  sub_810104E(a1, 28 * a2 + 135605824, (int)off_8167840, 8);
}
// 8167840: using guessed type char *off_8167840[16];

//----- (081015F0) --------------------------------------------------------
int __cdecl sub_81015F0(int a1, int a2)
{
  return sub_8101188(a1, 28 * a2 + 135605824, (int)off_8167840);
}
// 8167840: using guessed type char *off_8167840[16];

//----- (0810162A) --------------------------------------------------------
void __cdecl sub_810162A(int a1, int a2)
{
  sub_810104E(a1, 28 * a2 + 135605824, (int)off_8167860, 8);
}
// 8167860: using guessed type char *off_8167860[8];

//----- (08101664) --------------------------------------------------------
int __cdecl sub_8101664(int a1, int a2)
{
  return sub_8101188(a1, 28 * a2 + 135605824, (int)off_8167860);
}
// 8167860: using guessed type char *off_8167860[8];

//----- (0810169E) --------------------------------------------------------
int __cdecl sub_810169E(int a1, int a2)
{
  int *v3; // [esp+10h] [ebp-8h]
  __int16 **v4; // [esp+14h] [ebp-4h]

  v4 = &(&off_8152E40)[7 * a2];
  v3 = &dword_8578000[35 * a1];
  if ( v4[6] )
    return ((int (__cdecl *)(int *, int))v4[6])(v3, a2);
  else
    return sub_8118AAC((int)v3, (int)v4[2], (int)v4[1]);
}
// 8152E40: using guessed type __int16 *off_8152E40;
// 8578000: using guessed type int dword_8578000[];

//----- (08101716) --------------------------------------------------------
int __cdecl sub_8101716(int a1, int a2)
{
  int *v3; // [esp+10h] [ebp-8h]
  __int16 **v4; // [esp+14h] [ebp-4h]

  v4 = &(&off_8152E40)[7 * a2];
  v3 = &dword_8578000[35 * a1];
  if ( v4[5] )
    return ((int (__cdecl *)(int *, int))v4[5])(v3, a2);
  else
    return sub_81188EE((int)v3, (int)v4[2], (int)v4[1]);
}
// 8152E40: using guessed type __int16 *off_8152E40;
// 8578000: using guessed type int dword_8578000[];

//----- (0810178E) --------------------------------------------------------
__int16 **__cdecl Scr_FreeHudElemConstStrings(int a1)
{
  __int16 **result; // eax
  __int16 **i; // [esp+14h] [ebp-4h]

  for ( i = &off_8152E40; ; i += 7 )
  {
    result = i;
    if ( !*i )
      break;
    if ( i[2] == (__int16 *)3 )
      Scr_SetString((__int16 *)((char *)i[1] + a1), 0);
  }
  return result;
}
// 8152E40: using guessed type __int16 *off_8152E40;

//----- (081017D2) --------------------------------------------------------
int sub_81017D2()
{
  int v1; // [esp+14h] [ebp-4h]

  v1 = sub_8100EDA(1023, 0);
  if ( !v1 )
    Scr_Error((int)"out of hudelems");
  return Scr_AddHudElem(v1);
}

//----- (0810180E) --------------------------------------------------------
int sub_810180E()
{
  int *v1; // [esp+10h] [ebp-8h]
  int v2; // [esp+14h] [ebp-4h]

  v1 = (int *)Scr_GetEntity(0);
  if ( !v1[86] )
    Scr_ParamError(0, (int)"not a client");
  v2 = sub_8100EDA(*v1, 0);
  if ( !v2 )
    Scr_Error((int)"out of hudelems");
  return Scr_AddHudElem(v2);
}

//----- (0810187A) --------------------------------------------------------
int sub_810187A()
{
  int v0; // eax
  const char *v1; // eax
  char *v2; // eax
  __int16 v4; // [esp+12h] [ebp-6h]
  int v5; // [esp+14h] [ebp-4h]

  v4 = Scr_GetConstString(0);
  if ( v4 == word_87A22A2 )
  {
    v0 = sub_8100EDA(1023, 2);
  }
  else if ( v4 == word_87A22A4 )
  {
    v0 = sub_8100EDA(1023, 1);
  }
  else if ( v4 == word_87A22E8 )
  {
    v0 = sub_8100EDA(1023, 3);
  }
  else
  {
    v1 = (const char *)Scr_GetString(0);
    v2 = va("team \"%s\" should be \"allies\", \"axis\", or \"spectator\"", v1);
    Scr_ParamError(0, (int)v2);
    v0 = sub_8100EDA(1023, 0);
  }
  v5 = v0;
  if ( !v0 )
    Scr_Error((int)"out of hudelems");
  return Scr_AddHudElem(v5);
}
// 87A22A2: using guessed type __int16 word_87A22A2;
// 87A22A4: using guessed type __int16 word_87A22A4;
// 87A22E8: using guessed type __int16 word_87A22E8;

//----- (0810193A) --------------------------------------------------------
char **sub_810193A()
{
  char **result; // eax
  char **i; // [esp+14h] [ebp-4h]

  for ( i = (char **)&off_8152E40; ; i += 7 )
  {
    result = i;
    if ( !*i )
      break;
    sub_807E1F6(1, *i, 28087 * (((char *)i - (char *)&off_8152E40) >> 2));
  }
  return result;
}
// 8152E40: using guessed type __int16 *off_8152E40;

//----- (08101988) --------------------------------------------------------
int __cdecl sub_8101988(int a1)
{
  if ( HIWORD(a1) == 1 )
    return 140 * (unsigned __int16)a1 + 139952128;
  Scr_ObjectError((int)"not a hud element");
  return 0;
}

//----- (081019C2) --------------------------------------------------------
int __cdecl sub_81019C2(int a1)
{
  int result; // eax
  _DWORD *v2; // [esp+Ch] [ebp-Ch]
  char *s2; // [esp+10h] [ebp-8h]

  v2 = (_DWORD *)sub_8101988(a1);
  s2 = (char *)Scr_GetIString(0);
  sub_8100D80(v2);
  *v2 = 1;
  result = G_LocalizedStringIndex(s2);
  v2[29] = result;
  return result;
}

//----- (08101A12) --------------------------------------------------------
void __cdecl HECmd_SetPlayerNameString(int a1)
{
  int v1; // [esp+10h] [ebp-8h]
  int *v2; // [esp+14h] [ebp-4h]

  v1 = sub_8101988(a1);
  v2 = (int *)Scr_GetEntity(0);
  if ( v2 )
  {
    if ( v2[86] )
    {
      sub_8100D80((_DWORD *)v1);
      *(_DWORD *)v1 = 3;
      *(float *)(v1 + 112) = (float)*v2;
    }
    else
    {
      Com_Printf("Invalid entity passed to hudelem setplayernamestring(), entity is not a client\n");
    }
  }
  else
  {
    Com_Printf("Invalid entity passed to hudelem setplayernamestring()\n");
  }
}

//----- (08101A84) --------------------------------------------------------
void __cdecl HECmd_SetGameTypeString(int a1)
{
  _DWORD *v1; // [esp+10h] [ebp-8h]
  char *s1; // [esp+14h] [ebp-4h]

  v1 = (_DWORD *)sub_8101988(a1);
  s1 = (char *)Scr_GetString(0);
  if ( s1 )
  {
    if ( sub_8115DD2(s1) )
    {
      SV_SetConfigstring(0x14u, s1);
      sub_8100D80(v1);
      *v1 = 5;
      v1[28] = 1101004800;
    }
    else
    {
      Com_Printf("Invalid gametype '%s'\n", s1);
    }
  }
  else
  {
    Com_Printf("Invalid entity passed to hudelem setgametypestring()\n");
  }
}

//----- (08101B14) --------------------------------------------------------
void __cdecl HECmd_SetMapNameString(int a1)
{
  _DWORD *v1; // [esp+10h] [ebp-8h]
  char *s; // [esp+14h] [ebp-4h]

  v1 = (_DWORD *)sub_8101988(a1);
  s = (char *)Scr_GetString(0);
  if ( s )
  {
    if ( SV_MapExists(s) )
    {
      SV_SetConfigstring(0x13u, s);
      sub_8100D80(v1);
      *v1 = 4;
    }
    else
    {
      Com_Printf("Invalid map name passed to hudelem setmapnamestring(), map not found\n");
    }
  }
  else
  {
    Com_Printf("Invalid mapname passed to hudelem setmapnamestring()\n");
  }
}

//----- (08101B92) --------------------------------------------------------
int __cdecl HECmd_SetShader(int a1)
{
  char *v1; // eax
  char *v2; // eax
  char *v3; // eax
  int result; // eax
  int v5; // [esp+14h] [ebp-14h]
  int v6; // [esp+18h] [ebp-10h]
  int v7; // [esp+1Ch] [ebp-Ch]
  int v8; // [esp+20h] [ebp-8h]
  _DWORD *v9; // [esp+24h] [ebp-4h]

  v9 = (_DWORD *)sub_8101988(a1);
  v8 = Scr_GetNumParam();
  if ( v8 != 1 && v8 != 3 )
    Scr_Error((int)"USAGE: <hudelem> setShader(\"shadername\"[, optional_width, optional_height]);");
  v1 = (char *)Scr_GetString(0);
  v5 = sub_811AFBA(v1);
  if ( v8 == 1 )
  {
    v7 = 0;
    v6 = 0;
  }
  else
  {
    v7 = Scr_GetInt(1u);
    if ( v7 < 0 )
    {
      v2 = va("width %i < 0", v7);
      Scr_ParamError(1, (int)v2);
    }
    v6 = Scr_GetInt(2u);
    if ( v6 < 0 )
    {
      v3 = va("height %i < 0", v6);
      Scr_ParamError(2, (int)v3);
    }
  }
  sub_8100D80(v9);
  *v9 = 6;
  v9[15] = v5;
  v9[13] = v7;
  result = v6;
  v9[14] = v6;
  return result;
}

//----- (08101C94) --------------------------------------------------------
int __cdecl HECmd_SetTimer_Internal(int a1, int a2, const char *a3)
{
  char *v3; // eax
  char *v4; // eax
  int result; // eax
  float v6; // [esp+0h] [ebp-18h]
  int v7; // [esp+10h] [ebp-8h]
  _DWORD *v8; // [esp+14h] [ebp-4h]

  v8 = (_DWORD *)sub_8101988(a1);
  if ( Scr_GetNumParam() != 1 )
  {
    v3 = va("USAGE: <hudelem> %s(time_in_seconds);\n", a3);
    Scr_Error((int)v3);
  }
  v6 = Scr_GetFloat(0) * 1000.0;
  v7 = sub_81025DA(v6);
  if ( v7 <= 0 && a2 != 8 )
  {
    v4 = va("time %g should be > 0", (double)((long double)v7 * 0.001));
    Scr_ParamError(0, (int)v4);
  }
  sub_8100D80(v8);
  *v8 = a2;
  result = dword_859B5EC + v7;
  v8[26] = dword_859B5EC + v7;
  return result;
}

//----- (08101D48) --------------------------------------------------------
int __cdecl HECmd_SetClock_Internal(int a1, int a2, const char *a3)
{
  char *v3; // eax
  char *v4; // eax
  char *v5; // eax
  char *v6; // eax
  char *v7; // eax
  char *v8; // eax
  int result; // eax
  float v10; // [esp+0h] [ebp-28h]
  float v11; // [esp+0h] [ebp-28h]
  int v12; // [esp+Ch] [ebp-1Ch]
  int v13; // [esp+10h] [ebp-18h]
  int v14; // [esp+14h] [ebp-14h]
  int v15; // [esp+18h] [ebp-10h]
  int v16; // [esp+1Ch] [ebp-Ch]
  int v17; // [esp+20h] [ebp-8h]
  _DWORD *v18; // [esp+24h] [ebp-4h]

  v18 = (_DWORD *)sub_8101988(a1);
  v17 = Scr_GetNumParam();
  if ( v17 != 3 && v17 != 5 )
  {
    v3 = va(
           "USAGE: <hudelem> %s(time_in_seconds, total_clock_time_in_seconds, shadername[, width, height]);\n",
           a3);
    Scr_Error((int)v3);
  }
  v10 = Scr_GetFloat(0) * 1000.0;
  v16 = sub_81025DA(v10);
  if ( v16 <= 0 && a2 != 12 )
  {
    v4 = va("time %g should be > 0", (double)((long double)v16 * 0.001));
    Scr_ParamError(0, (int)v4);
  }
  v11 = Scr_GetFloat(1u) * 1000.0;
  v15 = sub_81025DA(v11);
  if ( v15 <= 0 )
  {
    v5 = va("duration %g should be > 0", (double)((long double)v15 * 0.001));
    Scr_ParamError(1, (int)v5);
  }
  v6 = (char *)Scr_GetString(2u);
  v14 = sub_811AFBA(v6);
  if ( v17 == 3 )
  {
    v13 = 0;
    v12 = 0;
  }
  else
  {
    v13 = Scr_GetInt(3u);
    if ( v13 < 0 )
    {
      v7 = va("width %i < 0", v13);
      Scr_ParamError(3, (int)v7);
    }
    v12 = Scr_GetInt(4u);
    if ( v12 < 0 )
    {
      v8 = va("height %i < 0", v12);
      Scr_ParamError(4, (int)v8);
    }
  }
  sub_8100D80(v18);
  *v18 = a2;
  v18[26] = dword_859B5EC + v16;
  v18[27] = v15;
  v18[15] = v14;
  v18[13] = v13;
  result = v12;
  v18[14] = v12;
  return result;
}

//----- (08101F16) --------------------------------------------------------
int __cdecl sub_8101F16(int a1)
{
  return HECmd_SetTimer_Internal(a1, 7, "setTimer");
}

//----- (08101F3A) --------------------------------------------------------
int __cdecl sub_8101F3A(int a1)
{
  return HECmd_SetTimer_Internal(a1, 8, "setTimerUp");
}

//----- (08101F5E) --------------------------------------------------------
int __cdecl sub_8101F5E(int a1)
{
  return HECmd_SetTimer_Internal(a1, 9, "setTenthsTimer");
}

//----- (08101F82) --------------------------------------------------------
int __cdecl sub_8101F82(int a1)
{
  return HECmd_SetTimer_Internal(a1, 10, "setTenthsTimerUp");
}

//----- (08101FA6) --------------------------------------------------------
int __cdecl sub_8101FA6(int a1)
{
  return HECmd_SetClock_Internal(a1, 11, "setClock");
}

//----- (08101FCA) --------------------------------------------------------
int __cdecl sub_8101FCA(int a1)
{
  return HECmd_SetClock_Internal(a1, 12, "setClockUp");
}

//----- (08101FEE) --------------------------------------------------------
int __cdecl sub_8101FEE(int a1)
{
  int result; // eax
  int v2; // [esp+10h] [ebp-8h]
  float v3; // [esp+14h] [ebp-4h]

  v2 = sub_8101988(a1);
  v3 = Scr_GetFloat(0);
  sub_8100D80((_DWORD *)v2);
  *(_DWORD *)v2 = 2;
  result = LODWORD(v3);
  *(float *)(v2 + 112) = v3;
  return result;
}

//----- (08102030) --------------------------------------------------------
int __cdecl sub_8102030(int a1)
{
  int result; // eax
  int v2; // [esp+10h] [ebp-8h]
  int v3; // [esp+14h] [ebp-4h]

  v3 = sub_8101988(a1);
  v2 = Scr_GetInt(0);
  *(_DWORD *)v3 = 13;
  result = v3;
  *(float *)(v3 + 112) = (float)v2;
  return result;
}

//----- (08102068) --------------------------------------------------------
int __cdecl sub_8102068(int a1)
{
  char *v1; // eax
  char *v2; // eax
  int result; // eax
  float v4; // [esp+0h] [ebp-18h]
  float v5; // [esp+Ch] [ebp-Ch]
  _DWORD *v6; // [esp+10h] [ebp-8h]

  v6 = (_DWORD *)sub_8101988(a1);
  v5 = Scr_GetFloat(0);
  if ( v5 > 0.0 )
  {
    if ( v5 > 60.0 )
    {
      v2 = va("fade time %g > 60", v5);
      Scr_ParamError(0, (int)v2);
    }
  }
  else
  {
    v1 = va("fade time %g <= 0", v5);
    Scr_ParamError(0, (int)v1);
  }
  v6[10] = dword_859B5EC;
  v4 = v5 * 1000.0;
  v6[11] = sub_81025A4(v4);
  result = v6[8];
  v6[9] = result;
  return result;
}

//----- (0810212C) --------------------------------------------------------
int __cdecl HECmd_ScaleOverTime(int a1)
{
  char *v1; // eax
  char *v2; // eax
  int result; // eax
  float v4; // [esp+0h] [ebp-28h]
  int v5; // [esp+14h] [ebp-14h]
  int v6; // [esp+18h] [ebp-10h]
  float v7; // [esp+1Ch] [ebp-Ch]
  _DWORD *v8; // [esp+20h] [ebp-8h]

  v8 = (_DWORD *)sub_8101988(a1);
  if ( Scr_GetNumParam() != 3 )
    Scr_Error((int)"hudelem scaleOverTime(time_in_seconds, new_width, new_height)");
  v7 = Scr_GetFloat(0);
  if ( v7 > 0.0 )
  {
    if ( v7 > 60.0 )
    {
      v2 = va("scale time %g > 60", v7);
      Scr_ParamError(0, (int)v2);
    }
  }
  else
  {
    v1 = va("scale time %g <= 0", v7);
    Scr_ParamError(0, (int)v1);
  }
  v6 = Scr_GetInt(1u);
  v5 = Scr_GetInt(2u);
  v8[18] = dword_859B5EC;
  v4 = v7 * 1000.0;
  v8[19] = sub_81025A4(v4);
  v8[16] = v8[13];
  v8[17] = v8[14];
  v8[13] = v6;
  result = v5;
  v8[14] = v5;
  return result;
}

//----- (08102242) --------------------------------------------------------
int __cdecl HECmd_MoveOverTime(int a1)
{
  char *v1; // eax
  char *v2; // eax
  int result; // eax
  float v4; // [esp+0h] [ebp-18h]
  float v5; // [esp+Ch] [ebp-Ch]
  _DWORD *v6; // [esp+10h] [ebp-8h]

  v6 = (_DWORD *)sub_8101988(a1);
  v5 = Scr_GetFloat(0);
  if ( v5 > 0.0 )
  {
    if ( v5 > 60.0 )
    {
      v2 = va("move time %g > 60", v5);
      Scr_ParamError(0, (int)v2);
    }
  }
  else
  {
    v1 = va("move time %g <= 0", v5);
    Scr_ParamError(0, (int)v1);
  }
  v6[24] = dword_859B5EC;
  v4 = v5 * 1000.0;
  v6[25] = sub_81025A4(v4);
  v6[20] = v6[1];
  v6[21] = v6[2];
  v6[22] = v6[6];
  result = v6[7];
  v6[23] = result;
  return result;
}

//----- (0810232A) --------------------------------------------------------
_DWORD *__cdecl sub_810232A(int a1)
{
  _DWORD *v2; // [esp+4h] [ebp-4h]

  v2 = (_DWORD *)sub_8101988(a1);
  return sub_8100E1E(v2);
}

//----- (0810234C) --------------------------------------------------------
_DWORD *__cdecl sub_810234C(int a1)
{
  _DWORD *v2; // [esp+4h] [ebp-4h]

  v2 = (_DWORD *)sub_8101988(a1);
  return sub_8100F68(v2);
}

//----- (0810236E) --------------------------------------------------------
int (__cdecl *__cdecl HudElem_GetMethod(char **a1))(int)
{
  char *s1; // [esp+10h] [ebp-8h]
  unsigned int i; // [esp+14h] [ebp-4h]

  s1 = *a1;
  for ( i = 0; i <= 0x11; ++i )
  {
    if ( !strcmp(s1, (&off_81530E0)[3 * i]) )
    {
      *a1 = (&off_81530E0)[3 * i];
      return off_81530E4[3 * i];
    }
  }
  return 0;
}
// 81530E0: using guessed type char *off_81530E0;
// 81530E4: using guessed type int (__cdecl *off_81530E4[55])(int);

//----- (081023F2) --------------------------------------------------------
int **__cdecl sub_81023F2(_DWORD *a1, int a2, unsigned __int8 a3)
{
  int **result; // eax
  int *v4; // [esp+Ch] [ebp-1Ch] BYREF
  int *v5; // [esp+10h] [ebp-18h]
  int v6; // [esp+14h] [ebp-14h]
  int v7; // [esp+18h] [ebp-10h]
  unsigned int v8; // [esp+1Ch] [ebp-Ch]

  if ( (a3 & 1) != 0 )
    memset(a1 + 1482, 0, 0xF80u);
  result = (int **)(a3 & 2);
  if ( (a3 & 2) != 0 )
    result = (int **)memset(a1 + 490, 0, 0xF80u);
  v7 = 0;
  v6 = 0;
  v4 = &dword_8578000;
  v8 = 0;
  while ( v8 <= 0x3FF )
  {
    if ( *v4 && (!v4[33] || v4[33] == a1[2515]) && (v4[32] == 1023 || v4[32] == a2) )
    {
      if ( v4[34] )
      {
        if ( ((a3 ^ 1) & 1) == 0 )
        {
          v5 = &a1[32 * v7++ + 1482];
          if ( v7 <= 31 )
            goto LABEL_18;
        }
      }
      else if ( (a3 & 2) != 0 )
      {
        v5 = &a1[32 * v6++ + 490];
        if ( v6 <= 31 )
LABEL_18:
          qmemcpy(v5, v4, 0x80u);
      }
    }
    ++v8;
    result = &v4;
    v4 += 35;
  }
  return result;
}
// 8578000: using guessed type int dword_8578000;

//----- (0810255C) --------------------------------------------------------
void __cdecl sub_810255C(float a1, float a2)
{
  float v2; // [esp+0h] [ebp-18h]

  v2 = a1 - a2;
  sub_8102608(v2, a1, a2);
}

//----- (08102580) --------------------------------------------------------
void __cdecl sub_8102580(float a1, float a2)
{
  float v2; // [esp+0h] [ebp-18h]

  v2 = a2 - a1;
  sub_8102608(v2, a1, a2);
}

//----- (081025A4) --------------------------------------------------------
int __cdecl sub_81025A4(float a1)
{
  return (int)floor(a1 + 0.5);
}

//----- (081025DA) --------------------------------------------------------
int __cdecl sub_81025DA(float a1)
{
  return (int)ceil(a1);
}

//----- (08102608) --------------------------------------------------------
long double __cdecl sub_8102608(float a1, float a2, float a3)
{
  if ( a1 < 0.0 )
    return a3;
  return a2;
}

//----- (08102634) --------------------------------------------------------
int __cdecl sub_8102634(int a1, int a2)
{
  int result; // eax
  int v3; // [esp+Ch] [ebp-1Ch]
  int v4; // [esp+10h] [ebp-18h]
  int v5; // [esp+14h] [ebp-14h]
  int v6; // [esp+1Ch] [ebp-Ch]

  v4 = sub_80EAC94(a2);
  result = sub_80EAC7A(a2);
  v3 = result;
  if ( a2 > 0 )
  {
    result = BG_GetNumWeapons();
    if ( a2 <= result )
    {
      v6 = *(_DWORD *)(a1 + 4 * v3 + 836);
      v5 = sub_80E9356(v3) - v6;
      result = v5;
      if ( v5 > *(_DWORD *)(a1 + 4 * v4 + 324) )
      {
        result = *(_DWORD *)(a1 + 4 * v4 + 324);
        v5 = result;
      }
      if ( v5 )
      {
        *(_DWORD *)(a1 + 4 * v4 + 324) -= v5;
        result = *(_DWORD *)(a1 + 4 * v3 + 836) + v5;
        *(_DWORD *)(a1 + 4 * v3 + 836) = result;
      }
    }
  }
  return result;
}

//----- (08102704) --------------------------------------------------------
int __cdecl sub_8102704(int a1, int a2, int a3, int a4)
{
  int v4; // esi
  int v5; // esi
  int v6; // esi
  int v7; // esi
  int v10; // [esp+Ch] [ebp-1Ch]
  int v11; // [esp+10h] [ebp-18h]
  int v12; // [esp+14h] [ebp-14h]
  int v13; // [esp+18h] [ebp-10h]
  int v14; // [esp+1Ch] [ebp-Ch]
  int v15; // [esp+38h] [ebp+10h]

  v14 = sub_80EAC94(a2);
  v13 = sub_80EAC7A(a2);
  v12 = 0;
  v11 = *(_DWORD *)(*(_DWORD *)(a1 + 344) + 4 * v14 + 324);
  v10 = *(_DWORD *)(*(_DWORD *)(a1 + 344) + 4 * v13 + 836);
  *(_DWORD *)(*(_DWORD *)(a1 + 344) + 4 * v14 + 324) = v11 + a3;
  if ( sub_80EACAE(a2) )
  {
    sub_811E696(*(_DWORD *)(a1 + 344), a2);
    v12 = 1;
  }
  if ( a4 || v12 )
    sub_8102634(*(_DWORD *)(a1 + 344), a2);
  if ( v12 )
  {
    *(_DWORD *)(*(_DWORD *)(a1 + 344) + 4 * v14 + 324) = 0;
  }
  else
  {
    v4 = *(_DWORD *)(a1 + 344);
    if ( *(_DWORD *)(v4 + 4 * v14 + 324) > sub_80E9336(v14) )
    {
      v5 = *(_DWORD *)(a1 + 344);
      *(_DWORD *)(v5 + 4 * v14 + 324) = sub_80E9336(v14);
    }
  }
  v6 = *(_DWORD *)(a1 + 344);
  if ( *(_DWORD *)(v6 + 4 * v13 + 836) > sub_80E9356(v13) )
  {
    v7 = *(_DWORD *)(a1 + 344);
    *(_DWORD *)(v7 + 4 * v13 + 836) = sub_80E9356(v13);
  }
  if ( *(int *)(BG_WeaponDefs(a2) + 484) < 0 )
    return *(_DWORD *)(*(_DWORD *)(a1 + 344) + 4 * v13 + 836)
         - v10
         + *(_DWORD *)(*(_DWORD *)(a1 + 344) + 4 * v14 + 324)
         - v11;
  v15 = sub_80E9DE0(*(_DWORD *)(a1 + 344), a2);
  if ( v15 >= 0 )
    return *(_DWORD *)(*(_DWORD *)(a1 + 344) + 4 * v13 + 836)
         - v10
         + *(_DWORD *)(*(_DWORD *)(a1 + 344) + 4 * v14 + 324)
         - v11;
  if ( !sub_80EACAE(a2) )
  {
    *(_DWORD *)(*(_DWORD *)(a1 + 344) + 4 * v14 + 324) += v15;
    if ( *(int *)(*(_DWORD *)(a1 + 344) + 4 * v14 + 324) < 0 )
      *(_DWORD *)(*(_DWORD *)(a1 + 344) + 4 * v14 + 324) = 0;
    return *(_DWORD *)(*(_DWORD *)(a1 + 344) + 4 * v13 + 836)
         - v10
         + *(_DWORD *)(*(_DWORD *)(a1 + 344) + 4 * v14 + 324)
         - v11;
  }
  *(_DWORD *)(*(_DWORD *)(a1 + 344) + 4 * v13 + 836) += v15;
  if ( *(int *)(*(_DWORD *)(a1 + 344) + 4 * v13 + 836) > 0 )
    return *(_DWORD *)(*(_DWORD *)(a1 + 344) + 4 * v13 + 836)
         - v10
         + *(_DWORD *)(*(_DWORD *)(a1 + 344) + 4 * v14 + 324)
         - v11;
  *(_DWORD *)(*(_DWORD *)(a1 + 344) + 4 * v13 + 836) = 0;
  sub_80E98CA(*(_DWORD *)(a1 + 344), a2);
  return 0;
}

//----- (081029D4) --------------------------------------------------------
int __cdecl sub_81029D4(int a1, int *a2)
{
  int v2; // eax
  int v3; // eax
  char *v4; // eax
  int v5; // eax
  char *v6; // eax
  char *v9; // [esp+1Ch] [ebp-Ch]

  v9 = (char *)&unk_8164C20 + 44 * *(unsigned __int16 *)(a1 + 428);
  if ( *(_DWORD *)(a1 + 416) )
    v2 = sub_8102704((int)a2, *((_DWORD *)v9 + 8), *(_DWORD *)(a1 + 416), 0);
  else
    v2 = sub_8102704((int)a2, *((_DWORD *)v9 + 8), *((_DWORD *)v9 + 6), 0);
  if ( !v2 )
    return 0;
  if ( sub_80EACAE(*((_DWORD *)v9 + 8)) )
  {
    v3 = BG_WeaponDefs(*((_DWORD *)v9 + 8));
    v4 = va(aCGamePickupCli, 102, *(_DWORD *)(v3 + 4));
  }
  else
  {
    v5 = BG_WeaponDefs(*((_DWORD *)v9 + 8));
    v4 = va(aCGamePickupAmm, 102, *(_DWORD *)(v5 + 4));
  }
  SV_GameSendServerCommand(-1963413621 * (((char *)a2 - (char *)&unk_8665480) >> 4), 0, v4);
  Scr_AddEntity(a2);
  Scr_Notify((int *)a1, word_87A22F4, 1);
  if ( *(_DWORD *)(BG_WeaponDefs(*((_DWORD *)v9 + 8)) + 132) )
    v6 = va("%c \"%i\"", 73, 4);
  else
    v6 = va("%c \"%i\"", 73, 1);
  SV_GameSendServerCommand(-1963413621 * (((char *)a2 - (char *)&unk_8665480) >> 4), 0, v6);
  return 1;
}
// 87A22F4: using guessed type __int16 word_87A22F4;

//----- (08102BE2) --------------------------------------------------------
int __cdecl sub_8102BE2(int a1, int *a2, _DWORD *a3, int a4)
{
  int v4; // eax
  int v5; // eax
  int v6; // eax
  int v7; // eax
  int v8; // eax
  int v9; // eax
  unsigned __int8 v10; // al
  int v11; // eax
  int v12; // eax
  char *v13; // eax
  char *v14; // eax
  int v15; // eax
  int v16; // eax
  int v17; // eax
  int v18; // ebx
  char *v19; // eax
  float v21; // [esp+0h] [ebp-58h]
  int v22; // [esp+14h] [ebp-44h]
  float v23; // [esp+1Ch] [ebp-3Ch]
  int v25; // [esp+24h] [ebp-34h]
  int v26; // [esp+28h] [ebp-30h]
  int v27; // [esp+2Ch] [ebp-2Ch]
  int i; // [esp+2Ch] [ebp-2Ch]
  int v29; // [esp+30h] [ebp-28h]
  int v30; // [esp+30h] [ebp-28h]
  _DWORD *v31; // [esp+38h] [ebp-20h]
  float *v32; // [esp+3Ch] [ebp-1Ch]
  int v33; // [esp+40h] [ebp-18h]
  int v34; // [esp+44h] [ebp-14h]
  int v35; // [esp+48h] [ebp-10h]
  int v36; // [esp+4Ch] [ebp-Ch]
  int v37; // [esp+50h] [ebp-8h]
  int v38; // [esp+50h] [ebp-8h]

  v32 = 0;
  v34 = *((_DWORD *)&unk_8164C20 + 11 * *(unsigned __int16 *)(a1 + 428) + 8);
  v31 = (_DWORD *)BG_WeaponDefs(v34);
  if ( *(int *)(a1 + 416) >= 0 )
  {
    if ( !*(_DWORD *)(a1 + 416) )
    {
      v27 = v31[221];
      v29 = v31[220];
      if ( v27 < v29 )
      {
        v27 = v31[220];
        v29 = v31[221];
      }
      if ( v27 || v29 )
      {
        if ( v27 >= 0 )
        {
          if ( v27 == v29 )
            v22 = v29;
          else
            v22 = rand() % (v27 - v29) + v29;
          *(_DWORD *)(a1 + 416) = v22;
          if ( *(int *)(a1 + 416) <= 0 )
            *(_DWORD *)(a1 + 416) = 0;
        }
        else
        {
          *(_DWORD *)(a1 + 416) = 0;
        }
      }
      else
      {
        v23 = (sub_80A1410() + 1.0) * 0.5;
        v4 = sub_80EAC7A(v34);
        v21 = (long double)(sub_80E9356(v4) - 1) * v23;
        *(_DWORD *)(a1 + 416) = sub_8105D5E(v21) + 1;
      }
    }
    v5 = sub_80EAC94(v34);
    if ( *(_DWORD *)(a1 + 416) > sub_80E9336(v5) )
    {
      v6 = sub_80EAC94(v34);
      *(_DWORD *)(a1 + 416) = sub_80E9336(v6);
    }
    v37 = *(_DWORD *)(a1 + 416);
  }
  else
  {
    v37 = 0;
  }
  if ( *(int *)(a1 + 424) >= 0 )
  {
    if ( !*(_DWORD *)(a1 + 424) )
    {
      if ( *(int *)(a1 + 416) >= 0 )
      {
        v7 = sub_80EAC7A(v34);
        *(_DWORD *)(a1 + 424) = sub_80E9356(v7);
        if ( *(_DWORD *)(a1 + 424) > *(_DWORD *)(a1 + 416) )
          *(_DWORD *)(a1 + 424) = *(_DWORD *)(a1 + 416);
        *(_DWORD *)(a1 + 416) -= *(_DWORD *)(a1 + 424);
        v37 = *(_DWORD *)(a1 + 416);
      }
      else
      {
        *(_DWORD *)(a1 + 424) = 0;
      }
    }
    v8 = sub_80EAC7A(v34);
    if ( *(_DWORD *)(a1 + 424) > sub_80E9356(v8) )
    {
      v9 = sub_80EAC7A(v34);
      *(_DWORD *)(a1 + 424) = sub_80E9356(v9);
    }
    v36 = *(_DWORD *)(a1 + 424);
  }
  else
  {
    v36 = 0;
  }
  v10 = sub_80D9E84(a2[86] + 1348, v34);
  v35 = v10;
  if ( !v10 )
  {
    if ( sub_80E9882(v34) )
    {
      if ( *(_DWORD *)(a2[86] + 212) )
      {
        if ( !(unsigned __int8)sub_80D9E84(a2[86] + 1348, *(_DWORD *)(a2[86] + 212)) )
          return 0;
        if ( !sub_80E9B54(a2[86], *(_DWORD *)(a2[86] + 212), 1) )
        {
          v11 = BG_WeaponDefs(*(_DWORD *)(a2[86] + 212));
          if ( !sub_80E9C6A(a2[86], *(_DWORD *)(a2[86] + 212), *(_DWORD *)(v11 + 128)) && !sub_80E9C10(a2[86], v34) )
          {
            Com_Printf("WARNING: cannot swap out a debug weapon (can result from too many weapons given to the player)\n");
            return 0;
          }
        }
      }
      if ( !sub_80E9C10(a2[86], v34) )
      {
        v12 = BG_WeaponDefs(*(_DWORD *)(a2[86] + 212));
        if ( !sub_80E9C6A(a2[86], v34, *(_DWORD *)(v12 + 128)) )
        {
          if ( v31[32] == *(_DWORD *)(BG_WeaponDefs(*(_DWORD *)(a2[86] + 212)) + 128) )
          {
            v32 = sub_810404E((int)a2, *(_DWORD *)(a2[86] + 212), 0);
          }
          else
          {
            for ( i = 1; i <= 2; ++i )
            {
              v30 = *(char *)(i + a2[86] + 1364);
              v26 = sub_80EAC94(v34);
              v25 = sub_80EAC7A(v34);
              if ( !*(_DWORD *)(a2[86] + 4 * v26 + 324) && !*(_DWORD *)(a2[86] + 4 * v25 + 836) )
              {
                v32 = sub_810404E((int)a2, v30, 0);
                break;
              }
            }
            if ( i > 2 )
            {
              v13 = va("%c \"GAME_CANT_GET_PRIMARY_WEAP_MESSAGE\"", 102);
              SV_GameSendServerCommand(-1963413621 * (((char *)a2 - (char *)&unk_8665480) >> 4), 0, v13);
              return 0;
            }
          }
          if ( !v32 )
            return 0;
          v32[92] = *(float *)(a1 + 368);
          v32[31] = *(float *)(a1 + 124);
          sub_811CF36(v32, (_DWORD *)(a1 + 312));
          sub_811CF96(v32, (_DWORD *)(a1 + 324));
          SV_LinkEntity((int)v32);
        }
      }
      sub_811E696(a2[86], v34);
      if ( !a4 )
        sub_811E97A(-1963413621 * (((char *)a2 - (char *)&unk_8665480) >> 4), v34);
    }
    else
    {
      sub_811E696(a2[86], v34);
    }
  }
  if ( v35 )
  {
    *a3 = 145;
    v38 = v36 + v37;
    v33 = sub_8102704((int)a2, v34, v38, 0);
    if ( v33 )
    {
      if ( sub_80EACAE(v34) )
        v14 = va(aCGamePickupCli, 102, v31[1]);
      else
        v14 = va(aCGamePickupAmm, 102, v31[1]);
      SV_GameSendServerCommand(-1963413621 * (((char *)a2 - (char *)&unk_8665480) >> 4), 0, v14);
    }
    if ( v33 != v38 )
    {
      *(_DWORD *)(a1 + 416) -= v33;
      if ( *(int *)(a1 + 416) <= 0 )
      {
        *(_DWORD *)(a1 + 424) += *(_DWORD *)(a1 + 416);
        *(_DWORD *)(a1 + 416) = -1;
        if ( *(int *)(a1 + 424) <= 0 )
          *(_DWORD *)(a1 + 424) = -1;
      }
      if ( (*(int *)(a1 + 416) > 0 || *(int *)(a1 + 424) > 0) && *(_BYTE *)(g_weaponAmmoPools + 8) )
        return 0;
    }
  }
  else
  {
    if ( v36 >= 0 )
    {
      v15 = sub_80EAC7A(v34);
      if ( v36 > sub_80E9356(v15) )
      {
        v16 = sub_80EAC7A(v34);
        v37 += v36 - sub_80E9356(v16);
        v17 = sub_80EAC7A(v34);
        v36 = sub_80E9356(v17);
      }
      v18 = a2[86];
      *(_DWORD *)(v18 + 4 * sub_80EAC7A(v34) + 836) = v36;
    }
    sub_8102704((int)a2, v34, v37, v36 == -1);
  }
  if ( v32 )
    Scr_AddEntity((int *)v32);
  else
    Scr_AddUndefined();
  Scr_AddEntity(a2);
  Scr_Notify((int *)a1, word_87A22F4, 2);
  if ( v31[33] )
    v19 = va("%c \"%i\"", 73, 4);
  else
    v19 = va("%c \"%i\"", 73, 1);
  SV_GameSendServerCommand(-1963413621 * (((char *)a2 - (char *)&unk_8665480) >> 4), 0, v19);
  return 1;
}
// 8793DB4: using guessed type int g_weaponAmmoPools;
// 87A22F4: using guessed type __int16 word_87A22F4;

//----- (08103530) --------------------------------------------------------
int __cdecl sub_8103530(int a1, int *a2)
{
  char *v2; // eax
  char *v3; // eax
  int v5; // [esp+1Ch] [ebp-1Ch]
  int v6; // [esp+1Ch] [ebp-1Ch]
  int v7; // [esp+20h] [ebp-18h]
  char *v8; // [esp+24h] [ebp-14h]
  int v9; // [esp+28h] [ebp-10h]
  int v10; // [esp+2Ch] [ebp-Ch]
  int v11; // [esp+30h] [ebp-8h]

  v8 = (char *)&unk_8164C20 + 44 * *(unsigned __int16 *)(a1 + 428);
  if ( *((_DWORD *)v8 + 6) == 5 || *((_DWORD *)v8 + 6) == 100 )
    v11 = 2 * *(_DWORD *)(a2[86] + 308);
  else
    v11 = *(_DWORD *)(a2[86] + 308);
  if ( *(_DWORD *)(a1 + 416) )
    v10 = *(_DWORD *)(a1 + 416);
  else
    v10 = *((_DWORD *)v8 + 6);
  v9 = a2[101];
  a2[101] = v9 + (int)((long double)v10 * (long double)*(int *)(a2[86] + 308) * 0.0099999998);
  if ( a2[101] <= v11 )
  {
    v7 = (int)((long double)(100 * a2[101]) / (long double)*(int *)(a2[86] + 308));
    if ( v7 > 0 )
    {
      if ( v7 > 100 )
        v7 = 100;
    }
    else
    {
      v7 = 1;
    }
    v5 = (int)((long double)(100 * v9) / (long double)*(int *)(a2[86] + 308));
    if ( v5 <= 0 )
      v5 = 1;
    v6 = v10 + v5;
    if ( v6 > 100 )
      v6 = 100;
    if ( v7 != v6 )
      a2[101] = *(_DWORD *)(a2[86] + 308) * v6 / 100;
  }
  else
  {
    a2[101] = v11;
  }
  *(_DWORD *)(a2[86] + 300) = a2[101];
  v2 = va(aCGamePickupHea, 102, v10);
  SV_GameSendServerCommand(-1963413621 * (((char *)a2 - (char *)&unk_8665480) >> 4), 0, v2);
  v3 = va("%c \"%i\"", 73, 0);
  SV_GameSendServerCommand(-1963413621 * (((char *)a2 - (char *)&unk_8665480) >> 4), 0, v3);
  Scr_AddEntity(a2);
  Scr_Notify((int *)a1, word_87A22F4, 1);
  return 1;
}
// 87A22F4: using guessed type __int16 word_87A22F4;

//----- (081037F0) --------------------------------------------------------
int __usercall sub_81037F0@<eax>(long double a1@<st0>, int a2, int *a3, int a4)
{
  *(_BYTE *)(a2 + 354) = 1;
  return sub_810381C(a1, (unsigned __int16 *)a2, a3, a4);
}

//----- (0810381C) --------------------------------------------------------
int __usercall sub_810381C@<eax>(long double a1@<st0>, unsigned __int16 *s, int *a3, int a4)
{
  int result; // eax
  int v5; // eax
  char *v6; // eax
  int v7; // eax
  bool v8; // cf
  char *v9; // eax
  const char **v10; // ebx
  int v11; // eax
  int v12; // eax
  char *v13; // [esp+2Ch] [ebp-5Ch]
  char dest[72]; // [esp+30h] [ebp-58h] BYREF
  int v15; // [esp+78h] [ebp-10h] BYREF
  int v16; // [esp+7Ch] [ebp-Ch]

  v15 = 144;
  result = (int)s;
  if ( *((_BYTE *)s + 354) )
  {
    *((_BYTE *)s + 354) = 0;
    result = (int)a3;
    if ( a3[86] )
    {
      result = (int)a3;
      if ( a3[101] > 0 && !dword_859B420 )
      {
        v13 = (char *)&unk_8164C20 + 44 * s[214];
        result = sub_80DCC7A(s, (_DWORD *)a3[86], a4);
        if ( result )
        {
          I_strncpyz(dest, (char *)(a3[86] + 10116), 64);
          sub_80B587C(dest);
          if ( *((_DWORD *)v13 + 7) == 1 )
          {
            v10 = (const char **)BG_WeaponDefs(*((_DWORD *)v13 + 8));
            v11 = sub_8090AFE(*a3);
            G_LogPrintf("Weapon;%d;%d;%s;%s\n", v11, *a3, dest, *v10);
          }
          else
          {
            v12 = sub_8090AFE(*a3);
            G_LogPrintf("Item;%d;%d;%s;%s\n", v12, *a3, dest, *(const char **)v13);
          }
          result = *((_DWORD *)v13 + 7);
          if ( result == 2 )
          {
            result = sub_81029D4((int)s, a3);
            v16 = result;
          }
          else if ( result > 2 )
          {
            if ( result != 3 )
              return result;
            result = sub_8103530((int)s, a3);
            v16 = result;
          }
          else
          {
            if ( result != 1 )
              return result;
            result = sub_8102BE2((int)s, a3, &v15, a4);
            v16 = result;
          }
          if ( v16 )
          {
            if ( *(_DWORD *)(a3[86] + 9988) )
              G_AddPredictableEvent((int)a3, v15, *((_DWORD *)s + 35));
            else
              G_AddEvent(a3, v15, *((_DWORD *)s + 35));
            return G_FreeEntity(a1, (int *)s);
          }
        }
        else if ( !a4 )
        {
          result = *((_DWORD *)s + 36);
          if ( result != *a3 )
          {
            result = *((_DWORD *)v13 + 7);
            if ( result == 1 )
            {
              if ( (unsigned __int8)sub_80D9E84(a3[86] + 1348, *((_DWORD *)v13 + 8)) )
              {
                v5 = BG_WeaponDefs(*((_DWORD *)v13 + 8));
                v6 = va(aCGamePickupCan, 102, *(_DWORD *)(v5 + 4));
                return SV_GameSendServerCommand(-1963413621 * (((char *)a3 - (char *)&unk_8665480) >> 4), 0, v6);
              }
              else
              {
                v7 = *(_DWORD *)(BG_WeaponDefs(*((_DWORD *)v13 + 8)) + 128);
                v8 = v7 == 1;
                result = v7 - 1;
                if ( v8 || result == 1 )
                {
                  v9 = va("%c \"GAME_CANT_GET_PRIMARY_WEAP_MESSAGE\"", 102);
                  return SV_GameSendServerCommand(-1963413621 * (((char *)a3 - (char *)&unk_8665480) >> 4), 0, v9);
                }
              }
            }
          }
        }
      }
    }
  }
  return result;
}
// 859B420: using guessed type int dword_859B420;

//----- (08103B6A) --------------------------------------------------------
int __usercall sub_8103B6A@<eax>(long double a1@<st0>)
{
  int v3; // [esp+14h] [ebp-24h]
  float *s; // [esp+1Ch] [ebp-1Ch]
  float v5; // [esp+20h] [ebp-18h]
  float v6; // [esp+24h] [ebp-14h]
  float v7; // [esp+28h] [ebp-10h]
  int v8; // [esp+2Ch] [ebp-Ch]
  int j; // [esp+30h] [ebp-8h]
  int i; // [esp+34h] [ebp-4h]

  v8 = 0;
  v5 = -1.0;
  v3 = *(_DWORD *)(g_maxDroppedWeapons + 8);
  for ( i = 0; i < v3; ++i )
  {
    s = (float *)dword_859D158[i];
    if ( !s )
      return i;
    v7 = 9.9999803e11;
    for ( j = 0; j < dword_859B5E4; ++j )
    {
      if ( *(_DWORD *)(dword_859B400 + 10404 * j + 9924) == 2 && !*(_DWORD *)(dword_859B400 + 10404 * j + 9896) )
      {
        v6 = sub_80A1DB2((float *)(560 * j + 140924344), s + 78);
        if ( v7 > (long double)v6 )
          v7 = v6;
      }
    }
    a1 = v5;
    if ( v7 > (long double)v5 )
    {
      v5 = v7;
      v8 = i;
    }
  }
  G_FreeEntity(a1, (int *)dword_859D158[v8]);
  dword_859D158[v8] = 0;
  return v8;
}
// 859B400: using guessed type int dword_859B400;
// 859B5E4: using guessed type int dword_859B5E4;
// 859D158: using guessed type int dword_859D158[32];
// 8793DB8: using guessed type int g_maxDroppedWeapons;

//----- (08103CB2) --------------------------------------------------------
int __cdecl sub_8103CB2(char **a1, _WORD *a2)
{
  char s[264]; // [esp+10h] [ebp-118h] BYREF
  const char **v4; // [esp+118h] [ebp-10h]
  int v5; // [esp+11Ch] [ebp-Ch]

  v5 = -1171354717 * (((char *)a1 - (char *)&unk_8164C20) >> 2);
  if ( v5 > BG_GetNumWeapons() )
    return sub_811D098(a2, *a1);
  v4 = (const char **)BG_WeaponDefs(v5);
  Com_sprintf(s, 0x100u, "weapon_%s", *v4);
  return sub_811D098(a2, s);
}

//----- (08103D3C) --------------------------------------------------------
int __usercall sub_8103D3C@<eax>(long double a1@<st0>, int a2, _DWORD *a3, _DWORD *a4, int a5)
{
  int v6; // [esp+10h] [ebp-8h]
  int v7; // [esp+14h] [ebp-4h]

  v7 = -1171354717 * ((a2 - (int)&unk_8164C20) >> 2);
  sub_8104C84(v7, 1);
  v6 = G_Spawn();
  dword_859D158[sub_8103B6A(a1)] = v6;
  *(_DWORD *)(v6 + 4) = 3;
  *(_DWORD *)(v6 + 140) = v7;
  sub_8103CB2((char **)a2, (_WORD *)(v6 + 360));
  *(_WORD *)(v6 + 428) = v7;
  if ( *(_DWORD *)(a2 + 28) == 1 )
  {
    sub_8105DBE((_DWORD *)(v6 + 260), -1082130432, -1082130432, -1082130432);
    sub_8105DBE((_DWORD *)(v6 + 272), 1065353216, 1065353216, 1065353216);
  }
  else
  {
    sub_8105DBE((_DWORD *)(v6 + 260), -1082130432, -1082130432, 0);
    sub_8105DBE((_DWORD *)(v6 + 272), 1065353216, 1065353216, 0x40000000);
  }
  *(_DWORD *)(v6 + 284) = 1079771400;
  if ( *(_DWORD *)(a2 + 28) != 2 )
    *(_DWORD *)(v6 + 284) |= 0x200000u;
  *(_DWORD *)(v6 + 144) = a5;
  sub_811B3EA(v6, *(char **)(a2 + 8));
  sub_811B20E(a1, v6);
  *(_BYTE *)(v6 + 358) = 15;
  sub_811CF36((_DWORD *)v6, a3);
  *(_DWORD *)(v6 + 12) = 5;
  *(_DWORD *)(v6 + 16) = dword_859B5EC;
  sub_8105DE2(a4, (_DWORD *)(v6 + 36));
  *(_DWORD *)(v6 + 400) = dword_859B5EC + 1000;
  *(_DWORD *)(v6 + 372) = 16;
  SV_LinkEntity(v6);
  return v6;
}
// 859D158: using guessed type int dword_859D158[32];

//----- (08103F44) --------------------------------------------------------
int __cdecl sub_8103F44(int a1, int a2, float a3, int a4)
{
  int v4; // ebx
  long double v5; // fst7
  _DWORD v7[2]; // [esp+10h] [ebp-38h] BYREF
  float v8; // [esp+18h] [ebp-30h]
  int v9; // [esp+20h] [ebp-28h] BYREF
  float v10; // [esp+24h] [ebp-24h]
  int v11; // [esp+28h] [ebp-20h]
  int v12[2]; // [esp+30h] [ebp-18h] BYREF
  float v13; // [esp+38h] [ebp-10h]

  sub_8105DE2((_DWORD *)(a1 + 324), &v9);
  v10 = v10 + a3;
  v9 = 0;
  v11 = 0;
  if ( a4 )
  {
    sub_8105D94(v12);
  }
  else
  {
    AngleVectors((float *)&v9, (int)v12, 0, 0);
    sub_8105EF6((float *)v12, *(float *)(g_dropForwardSpeed + 8), (float *)v12);
    v4 = g_dropUpSpeedBase;
    v13 = sub_80A142E() * *(float *)(g_dropUpSpeedRand + 8) + *(float *)(v4 + 8) + v13;
  }
  sub_8105DE2((_DWORD *)(a1 + 312), v7);
  v5 = (*(float *)(a1 + 280) - *(float *)(a1 + 268)) * 0.5 + v8;
  v8 = v5;
  return sub_8103D3C(v5, a2, v7, v12, *(_DWORD *)a1);
}
// 8793DC8: using guessed type int g_dropForwardSpeed;
// 8793DCC: using guessed type int g_dropUpSpeedBase;
// 8793DD0: using guessed type int g_dropUpSpeedRand;
// 8103F44: using guessed type _DWORD var_38[2];

//----- (0810404E) --------------------------------------------------------
float *__cdecl sub_810404E(int a1, int a2, int a3)
{
  int v3; // eax
  float v5; // [esp+0h] [ebp-118h]
  float v6; // [esp+0h] [ebp-118h]
  int v7; // [esp+4h] [ebp-114h]
  int v8; // [esp+38h] [ebp-E0h]
  int v9; // [esp+3Ch] [ebp-DCh]
  int v10; // [esp+40h] [ebp-D8h]
  int v11; // [esp+44h] [ebp-D4h]
  float v12; // [esp+48h] [ebp-D0h]
  float s[12]; // [esp+50h] [ebp-C8h] BYREF
  int v15[4]; // [esp+80h] [ebp-98h] BYREF
  _DWORD v16[2]; // [esp+90h] [ebp-88h] BYREF
  float v17; // [esp+98h] [ebp-80h]
  float v18[9]; // [esp+A0h] [ebp-78h] BYREF
  float v19[3]; // [esp+C4h] [ebp-54h] BYREF
  _DWORD v20[7]; // [esp+D0h] [ebp-48h] BYREF
  int v21; // [esp+ECh] [ebp-2Ch]
  int v22; // [esp+F0h] [ebp-28h]
  int v23; // [esp+F4h] [ebp-24h]
  int v24; // [esp+F8h] [ebp-20h]
  float *v25; // [esp+FCh] [ebp-1Ch]
  int v26; // [esp+100h] [ebp-18h]
  int v27; // [esp+104h] [ebp-14h]
  int v28; // [esp+108h] [ebp-10h]
  int v29; // [esp+10Ch] [ebp-Ch]

  v24 = (int)&unk_8164C20 + 44 * a2;
  if ( *(_DWORD *)(a1 + 344) && !(unsigned __int8)sub_80D9E84(*(_DWORD *)(a1 + 344) + 1348, a2)
    || (v27 = sub_80EAC94(a2), v26 = sub_80EAC7A(a2), *(_DWORD *)(BG_WeaponDefs(a2) + 832))
    && !*(_DWORD *)(*(_DWORD *)(a1 + 344) + 4 * v26 + 836) )
  {
    sub_80E98CA(*(_DWORD *)(a1 + 344), a2);
    return 0;
  }
  else
  {
    v25 = (float *)sub_8103F44(a1, v24, 0.0, 0);
    if ( *(_DWORD *)(a1 + 344) )
    {
      v29 = *(_DWORD *)(*(_DWORD *)(a1 + 344) + 4 * v27 + 324);
      *(_DWORD *)(*(_DWORD *)(a1 + 344) + 4 * v27 + 324) = 0;
      v28 = *(_DWORD *)(*(_DWORD *)(a1 + 344) + 4 * v26 + 836);
      *(_DWORD *)(*(_DWORD *)(a1 + 344) + 4 * v26 + 836) = 0;
      sub_80E98CA(*(_DWORD *)(a1 + 344), a2);
    }
    else
    {
      v22 = *(_DWORD *)(BG_WeaponDefs(a2) + 884);
      v21 = *(_DWORD *)(BG_WeaponDefs(a2) + 880);
      if ( v22 < v21 )
      {
        v22 = v21;
        v21 = *(_DWORD *)(BG_WeaponDefs(a2) + 884);
      }
      if ( v22 || v21 )
      {
        if ( v22 >= 0 )
        {
          if ( v22 == v21 )
            v11 = v21;
          else
            v11 = rand() % (v22 - v21) + v21;
          v29 = v11;
          if ( v11 > 0 )
          {
            v23 = sub_80E9356(v26);
            if ( v23 )
              v10 = rand() % v23;
            else
              v10 = 0;
            v28 = v10;
            if ( v10 < v29 )
            {
              v29 -= v28;
            }
            else
            {
              v28 = v29;
              v29 = 0;
            }
          }
          else
          {
            v29 = 0;
            v28 = 0;
          }
        }
        else
        {
          v29 = 0;
          v28 = 0;
        }
      }
      else
      {
        v12 = (sub_80A1410() + 1.0) * 0.5;
        v5 = (long double)(sub_80E9356(v26) - 1) * v12;
        v29 = sub_8105D5E(v5) + 1;
        v6 = (sub_80A1410() * 0.5 + 0.25) * (long double)v29;
        v28 = sub_8105D5E(v6);
        v29 -= v28;
      }
    }
    *((_DWORD *)v25 + 104) = v29;
    *((_DWORD *)v25 + 106) = v28;
    if ( !*((_DWORD *)v25 + 104) )
      v25[104] = NAN;
    if ( !*((_DWORD *)v25 + 106) )
      v25[106] = NAN;
    if ( !v29 && !v28 )
      *((_DWORD *)v25 + 71) &= ~0x200000u;
    if ( a3 )
    {
      if ( sub_811C0B2(a1, a3, v18) )
      {
        sub_8105E9A((float *)(a1 + 260), (float *)(a1 + 272), (float *)v15);
        sub_8105E12((float *)v15, (float *)(a1 + 312), (float *)v15);
        v3 = sub_8105FEA((int)v25);
        G_TraceCapsule(s, (float *)v15, v25 + 65, v25 + 68, v19, *(_DWORD *)a1, v3);
        sub_80DEB7A((float *)v15, v19, s[0], v25 + 6);
        sub_8105DE2((_DWORD *)v25 + 6, (_DWORD *)v25 + 78);
        *((_DWORD *)v25 + 4) = dword_859B5EC;
        sub_80A71F4((int)v18, (int)v16);
      }
      else
      {
        sub_8105DE2((_DWORD *)(a1 + 324), v16);
      }
      v17 = v17 + 90.0;
      sub_811CF96(v25, (_DWORD *)(a1 + 324));
      *(float *)&v9 = sub_80A142E() * 60.0;
      *(float *)&v8 = sub_80A142E() * 40.0;
      *(float *)&v7 = sub_80A142E() * 50.0;
      sub_8105DBE(v20, v7, v8, v9);
      *((_DWORD *)v25 + 12) = 2;
      *((_DWORD *)v25 + 13) = dword_859B5EC;
      sub_8105DE2(v20, (_DWORD *)v25 + 18);
    }
    return v25;
  }
}
// 810404E: using guessed type float var_78[9];
// 810404E: using guessed type float s[12];
// 810404E: using guessed type _DWORD var_88[2];
// 810404E: using guessed type _DWORD var_48[7];

//----- (08104600) --------------------------------------------------------
int __cdecl FinishSpawningItem(_DWORD *a1)
{
  long double v1; // fst7
  char *v2; // ebx
  const char *v3; // eax
  int v5; // [esp+Ch] [ebp-FCh]
  int v6; // [esp+Ch] [ebp-FCh]
  float v7[3]; // [esp+20h] [ebp-E8h] BYREF
  float v8[3]; // [esp+2Ch] [ebp-DCh] BYREF
  float v9[6]; // [esp+38h] [ebp-D0h] BYREF
  _DWORD v10[2]; // [esp+50h] [ebp-B8h] BYREF
  float v11; // [esp+58h] [ebp-B0h]
  int v12; // [esp+6Ch] [ebp-9Ch]
  int v13[4]; // [esp+70h] [ebp-98h] BYREF
  int v14[2]; // [esp+80h] [ebp-88h] BYREF
  float v15; // [esp+88h] [ebp-80h]
  int v16; // [esp+9Ch] [ebp-6Ch]
  int v17[4]; // [esp+A0h] [ebp-68h] BYREF
  int v18[4]; // [esp+B0h] [ebp-58h] BYREF
  int v19[4]; // [esp+C0h] [ebp-48h] BYREF
  float s; // [esp+D0h] [ebp-38h] BYREF
  int v21[6]; // [esp+D4h] [ebp-34h] BYREF
  unsigned __int16 v22; // [esp+ECh] [ebp-1Ch]
  char v23; // [esp+F3h] [ebp-15h]

  *((_BYTE *)a1 + 358) = 17;
  if ( (a1[92] & 1) != 0 )
  {
    sub_811CF36(a1, a1 + 78);
  }
  else
  {
    v16 = (int)&unk_8164C20 + 44 * *((unsigned __int16 *)a1 + 214);
    if ( *(_DWORD *)(v16 + 28) == 1 )
    {
      sub_8105DBE(v18, -1082130432, -1082130432, -1082130432);
      sub_8105DBE(v17, 1065353216, 1065353216, 1065353216);
    }
    else
    {
      sub_8105DBE(v18, -1082130432, -1082130432, 0);
      sub_8105DBE(v17, 1065353216, 1065353216, 0x40000000);
    }
    v12 = sub_8105FEA((int)a1);
    sub_8105DE2(a1 + 78, v14);
    v1 = *((float *)a1 + 80) - 4096.0;
    *(float *)&v5 = v1;
    sub_8105DBE(v19, a1[78], a1[79], v5);
    G_TraceCapsule(&s, (float *)v14, (float *)v18, (float *)v17, (float *)v19, *a1, v12);
    if ( v23 )
    {
      sub_8105DE2(a1 + 78, v14);
      v15 = v15 - 15.0;
      v1 = *((float *)a1 + 80) - 4096.0;
      *(float *)&v6 = v1;
      sub_8105DBE(v19, a1[78], a1[79], v6);
      G_TraceCapsule(&s, (float *)v14, (float *)v18, (float *)v17, (float *)v19, *a1, v12);
    }
    if ( v23 )
    {
      v2 = vtos((float *)a1 + 78);
      v3 = (const char *)SL_ConvertToString(*((unsigned __int16 *)a1 + 180));
      Com_Printf("FinishSpawningItem: %s startsolid at %s\n", v3, v2);
      return G_FreeEntity(v1, a1);
    }
    a1[31] = v22;
    sub_80DEB7A((float *)v14, (float *)v19, s, (float *)v13);
    sub_811CF36(a1, v13);
    if ( s < 1.0 )
    {
      sub_8105DE2(v21, v9);
      AngleVectors((float *)a1 + 81, (int)v7, 0, 0);
      sub_80A1ED8(v9, v7, v8);
      sub_80A1ED8(v8, v9, v7);
      sub_80A71F4((int)v7, (int)v10);
      if ( dword_8164C3C[11 * a1[35]] == 1 )
        v11 = v11 + 90.0;
      sub_811CF96(a1, v10);
    }
  }
  return SV_LinkEntity((int)a1);
}
// 8164C3C: using guessed type int dword_8164C3C[1449];
// 8104600: using guessed type float var_E8[3];
// 8104600: using guessed type _DWORD var_B8[2];
// 8104600: using guessed type int anonymous_0[6];

//----- (08104A02) --------------------------------------------------------
void *ClearRegisteredItems()
{
  void *result; // eax

  result = memset(&dword_859B000, 0, 0x400u);
  dword_859B000 = 1;
  return result;
}
// 859B000: using guessed type int dword_859B000;

//----- (08104A30) --------------------------------------------------------
int sub_8104A30()
{
  char **v1; // [esp+18h] [ebp-2010h]
  int i; // [esp+1Ch] [ebp-200Ch]
  char s1[8200]; // [esp+20h] [ebp-2008h] BYREF

  dword_859E9FC = 0;
  s1[0] = 0;
  v1 = 0;
  for ( i = 1; i <= BG_GetNumWeapons(); ++i )
  {
    if ( v1 )
      I_strncat(s1, 0x2000, " ");
    v1 = (char **)BG_WeaponDefs(i);
    I_strncat(s1, 0x2000, *v1);
  }
  return SV_SetConfigstring(7u, s1);
}
// 859E9FC: using guessed type int dword_859E9FC;

//----- (08104AEC) --------------------------------------------------------
int sub_8104AEC()
{
  char v1; // [esp+13h] [ebp-135h]
  char *v2; // [esp+14h] [ebp-134h]
  char v3; // [esp+1Bh] [ebp-12Dh]
  char *v4; // [esp+1Ch] [ebp-12Ch]
  int v5; // [esp+20h] [ebp-128h]
  int v6; // [esp+24h] [ebp-124h]
  int v7; // [esp+28h] [ebp-120h]
  int i; // [esp+2Ch] [ebp-11Ch]
  char s1[280]; // [esp+30h] [ebp-118h] BYREF

  dword_859EA00 = 0;
  v7 = 0;
  v6 = 0;
  v5 = 0;
  for ( i = 0; i < 131; ++i )
  {
    if ( dword_859B000[i] )
      v6 += 1 << v5;
    if ( ++v5 == 4 )
    {
      v4 = &s1[v7++];
      if ( v6 > 9 )
        v3 = v6 + 87;
      else
        v3 = v6 + 48;
      *v4 = v3;
      v6 = 0;
      v5 = 0;
    }
  }
  if ( v5 )
  {
    v2 = &s1[v7++];
    if ( v6 > 9 )
      v1 = v6 + 87;
    else
      v1 = v6 + 48;
    *v2 = v1;
  }
  s1[v7] = 0;
  return SV_SetConfigstring(8u, s1);
}
// 859B000: using guessed type int dword_859B000[];
// 859EA00: using guessed type int dword_859EA00;

//----- (08104C84) --------------------------------------------------------
int __cdecl sub_8104C84(int a1, int a2)
{
  int result; // eax
  char *v3; // eax
  const char *v4; // [esp+14h] [ebp-4h]

  result = a1;
  if ( !dword_859B000[a1] )
  {
    if ( !dword_859B41C )
    {
      v4 = (const char *)dword_8164C34[11 * a1];
      if ( !v4 || !*v4 )
        v4 = "<<unknown>>";
      v3 = va("game tried to register the item '%s' after initialization finished\n", v4);
      Scr_Error((int)v3);
    }
    dword_859B000[a1] = 1;
    if ( dword_8164C28[11 * a1] )
      G_ModelIndex((char *)dword_8164C28[11 * a1]);
    result = 44 * a1;
    if ( dword_8164C2C[11 * a1] )
      result = G_ModelIndex((char *)dword_8164C2C[11 * a1]);
    if ( a2 )
      dword_859EA00 = 1;
  }
  return result;
}
// 8164C28: using guessed type int dword_8164C28[];
// 8164C2C: using guessed type int dword_8164C2C[];
// 8164C34: using guessed type int dword_8164C34[];
// 859B000: using guessed type int dword_859B000[];
// 859EA00: using guessed type int dword_859EA00;

//----- (08104D86) --------------------------------------------------------
int __cdecl G_RegisterWeapon(int a1)
{
  int v2; // [esp+10h] [ebp-8h]
  int v3; // [esp+14h] [ebp-4h]

  dword_859B000[a1] = 1;
  dword_859EA00 = 1;
  dword_859E9FC = 1;
  v2 = BG_WeaponDefs(a1);
  if ( **(_BYTE **)(v2 + 1388) && !sub_810FFAA((_DWORD *)(v2 + 1396), *(char **)(v2 + 1388)) )
    Com_Error(1, (char *)&byte_8153420, 32);
  if ( **(_BYTE **)(v2 + 1392) && !sub_810FFAA((_DWORD *)(v2 + 1400), *(char **)(v2 + 1392)) )
    Com_Error(1, (char *)&byte_8153420, 32);
  v3 = G_ModelIndex(*(char **)(v2 + 436));
  if ( v3 && G_XModelBad(v3) )
    G_OverrideModel(v3, "xmodel/defaultweapon");
  return G_ModelIndex(*(char **)(v2 + 908));
}
// 859B000: using guessed type int dword_859B000[];
// 859E9FC: using guessed type int dword_859E9FC;
// 859EA00: using guessed type int dword_859EA00;

//----- (08104EA2) --------------------------------------------------------
int __cdecl IsItemRegistered(int a1)
{
  return dword_859B000[a1];
}
// 859B000: using guessed type int dword_859B000[];

//----- (08104EB2) --------------------------------------------------------
int __usercall sub_8104EB2@<eax>(long double a1@<st0>, int a2, int a3)
{
  int result; // eax

  sub_8104C84(-1171354717 * ((a3 - (int)&unk_8164C20) >> 2), 0);
  *(_WORD *)(a2 + 428) = -29789 * ((a3 - (int)&unk_8164C20) >> 2);
  sub_811B3EA(a2, *(char **)(a3 + 8));
  if ( *(_DWORD *)(a3 + 28) == 1 )
  {
    sub_8105DBE((_DWORD *)(a2 + 260), -1082130432, -1082130432, -1082130432);
    sub_8105DBE((_DWORD *)(a2 + 272), 1065353216, 1065353216, 1065353216);
  }
  else
  {
    sub_8105DBE((_DWORD *)(a2 + 260), -1082130432, -1082130432, 0);
    sub_8105DBE((_DWORD *)(a2 + 272), 1065353216, 1065353216, 0x40000000);
  }
  *(_DWORD *)(a2 + 284) = 1079771400;
  if ( *(_DWORD *)(a3 + 28) != 2 )
    *(_DWORD *)(a2 + 284) |= 0x200000u;
  *(_DWORD *)(a2 + 4) = 3;
  *(_DWORD *)(a2 + 140) = *(unsigned __int16 *)(a2 + 428);
  sub_811B20E(a1, a2);
  *(_DWORD *)(a2 + 144) = 1022;
  *(_DWORD *)(a2 + 372) |= 0x1000u;
  if ( byte_859C748 )
  {
    sub_811CF96((_DWORD *)a2, (_DWORD *)(a2 + 324));
    *(_DWORD *)(a2 + 400) = dword_859B5EC + 100;
    result = a2;
    *(_BYTE *)(a2 + 358) = 16;
  }
  else
  {
    *(_BYTE *)(a2 + 358) = 17;
    if ( ((*(_BYTE *)(a2 + 368) ^ 1) & 1) != 0 )
    {
      *(_DWORD *)(a2 + 124) = 1023;
      if ( *(_DWORD *)(a3 + 28) == 1 )
        *(float *)(a2 + 332) = *(float *)(a2 + 332) + 90.0;
    }
    sub_811CF96((_DWORD *)a2, (_DWORD *)(a2 + 324));
    sub_811CF36((_DWORD *)a2, (_DWORD *)(a2 + 312));
    return SV_LinkEntity(a2);
  }
  return result;
}
// 859C748: using guessed type char byte_859C748;

//----- (081050FE) --------------------------------------------------------
int __cdecl sub_81050FE(int a1, int a2, int a3, _DWORD *a4)
{
  int result; // eax
  _DWORD v5[4]; // [esp+10h] [ebp-48h] BYREF
  float v6[3]; // [esp+20h] [ebp-38h] BYREF
  float v7[3]; // [esp+2Ch] [ebp-2Ch] BYREF
  float v8[8]; // [esp+38h] [ebp-20h] BYREF

  sub_8105D94((_DWORD *)(a1 + 36));
  if ( *(_BYTE *)(a3 + 34) || *(float *)(a3 + 12) > 0.0 )
  {
    *(_BYTE *)(a2 + 1220) = 0;
    *(_DWORD *)(a1 + 12) = 1;
    sub_8105DE2(a4, (_DWORD *)(a1 + 24));
    *(_DWORD *)(a1 + 16) = 0;
    *(_DWORD *)(a1 + 20) = 0;
    sub_8105D94((_DWORD *)(a1 + 36));
    *(_DWORD *)(a1 + 124) = *(unsigned __int16 *)(a3 + 28);
    if ( *(_BYTE *)(a3 + 34) )
    {
      sub_811CF96((_DWORD *)a1, (_DWORD *)(a1 + 324));
    }
    else
    {
      sub_8105DE2((_DWORD *)(a3 + 4), v8);
      AngleVectors((float *)(a1 + 324), (int)v6, 0, 0);
      sub_80A1ED8(v8, v6, v7);
      sub_80A1ED8(v7, v8, v6);
      sub_80A71F4((int)v6, (int)v5);
      sub_811CF96((_DWORD *)a1, v5);
    }
    return SV_LinkEntity(a1);
  }
  else
  {
    sub_8105E12((float *)(a1 + 312), (float *)(a3 + 4), (float *)(a1 + 312));
    sub_8105DE2((_DWORD *)(a1 + 312), (_DWORD *)(a1 + 24));
    result = dword_859B5EC;
    *(_DWORD *)(a1 + 16) = dword_859B5EC;
  }
  return result;
}
// 81050FE: using guessed type float var_38[3];
// 81050FE: using guessed type _DWORD var_48[4];

//----- (081052AA) --------------------------------------------------------
int __cdecl sub_81052AA(int a1, int a2)
{
  _DWORD v3[2]; // [esp+10h] [ebp-48h] BYREF
  float v4; // [esp+18h] [ebp-40h]
  float v5[3]; // [esp+20h] [ebp-38h] BYREF
  float v6[3]; // [esp+2Ch] [ebp-2Ch] BYREF
  float v7[8]; // [esp+38h] [ebp-20h] BYREF

  sub_8105DE2((_DWORD *)(a2 + 4), v7);
  AngleVectors((float *)(a1 + 324), (int)v5, 0, 0);
  sub_80A1ED8(v7, v5, v6);
  sub_80A1ED8(v6, v7, v5);
  sub_80A71F4((int)v5, (int)v3);
  if ( dword_8164C3C[11 * *(_DWORD *)(a1 + 140)] == 1 )
    v4 = v4 + 90.0;
  return sub_811CF96((_DWORD *)a1, v3);
}
// 8164C3C: using guessed type int dword_8164C3C[1449];
// 81052AA: using guessed type float var_38[3];
// 81052AA: using guessed type _DWORD var_48[2];

//----- (08105382) --------------------------------------------------------
int __cdecl sub_8105382(int a1, int *a2, _DWORD *a3)
{
  int v4[6]; // [esp+20h] [ebp-18h] BYREF

  return sub_80BEF2C(*a2, 0, v4, a3, 1);
}
// 8105382: using guessed type int var_18[6];

//----- (081053B6) --------------------------------------------------------
int *__cdecl sub_81053B6(float *a1)
{
  int *result; // eax
  int v2; // eax
  char v3; // [esp+2Eh] [ebp-CAh]
  int v4[4]; // [esp+30h] [ebp-C8h] BYREF
  int v5[4]; // [esp+40h] [ebp-B8h] BYREF
  int v6[4]; // [esp+50h] [ebp-A8h] BYREF
  float v7; // [esp+60h] [ebp-98h] BYREF
  float v8; // [esp+64h] [ebp-94h]
  int *v9; // [esp+78h] [ebp-80h]
  int v10; // [esp+7Ch] [ebp-7Ch]
  int v11[2]; // [esp+80h] [ebp-78h] BYREF
  float v12; // [esp+88h] [ebp-70h]
  int v13[6]; // [esp+90h] [ebp-68h] BYREF
  int v14; // [esp+A8h] [ebp-50h]
  int v15; // [esp+ACh] [ebp-4Ch]
  float s[8]; // [esp+B0h] [ebp-48h] BYREF
  char v17; // [esp+D2h] [ebp-26h]
  char v18; // [esp+D3h] [ebp-25h]
  int v19[2]; // [esp+E0h] [ebp-18h] BYREF
  float v20; // [esp+E8h] [ebp-10h]

  v10 = sub_811C830(a1);
  v9 = (int *)(1224 * v10 + 142202936);
  sub_8105382((int)a1, v9, &v7);
  v3 = 0;
  if ( !*((_BYTE *)v9 + 1220) && sub_8105FB6(&v7) > 1.0 )
    v3 = 1;
  result = v9;
  if ( *((_BYTE *)v9 + 1220) || v3 )
  {
    BG_EvaluateTrajectory((int)(a1 + 3), dword_859B5EC, (int)v19);
    if ( v3 )
    {
      AngleVectors(a1 + 81, (int)v6, (float *)v5, 0);
      sub_8105EF6((float *)v5, -1.0, (float *)v4);
      Vec3Normalize((float *)v6);
      Vec3Normalize((float *)v4);
      sub_8105F2E((float *)v19, v7, (float *)v6, (float *)v19);
      sub_8105F2E((float *)v19, v8, (float *)v4, (float *)v19);
    }
    v14 = *((_DWORD *)a1 + 97);
    G_TraceCapsule(s, a1 + 78, a1 + 65, a1 + 68, (float *)v19, *((_DWORD *)a1 + 84), v14);
    sub_80DEB7A(a1 + 78, (float *)v19, s[0], (float *)v13);
    sub_8105DE2(v13, (_DWORD *)a1 + 78);
    if ( v18 )
      s[0] = 0.0;
    SV_LinkEntity((int)a1);
    sub_81079C8((int)a1);
    result = (int *)a1;
    if ( *((_BYTE *)a1 + 252) )
    {
      if ( s[0] == 1.0 )
      {
        result = v9;
        if ( !*((_BYTE *)v9 + 1220) )
        {
          if ( v3 )
          {
            *((_DWORD *)a1 + 3) = 1;
            sub_8105DE2(v13, (_DWORD *)a1 + 6);
            a1[4] = 0.0;
            a1[5] = 0.0;
            sub_8105D94((_DWORD *)a1 + 9);
            v20 = v20 - 1.0;
            result = (int *)G_TraceCapsuleComplete(a1 + 78, a1 + 65, a1 + 68, (float *)v19, *((_DWORD *)a1 + 84), v14);
            if ( result )
            {
              *((_BYTE *)v9 + 1220) = 1;
              *((_DWORD *)a1 + 3) = 5;
              sub_8105DE2(v13, (_DWORD *)a1 + 6);
              sub_8105D94((_DWORD *)a1 + 9);
              sub_8105F2E(a1 + 9, v7, (float *)v6, a1 + 9);
              sub_8105F2E(a1 + 9, v8, (float *)v4, a1 + 9);
              *((_DWORD *)a1 + 4) = dword_859B5EC;
              result = (int *)a1;
              a1[5] = 0.0;
            }
          }
        }
      }
      else
      {
        v2 = sub_809C18C(a1 + 78, -1, 0x80000000);
        v15 = v2;
        if ( v2 )
        {
          return (int *)G_FreeEntity(1.0, (int *)a1);
        }
        else
        {
          result = v9;
          if ( *((_BYTE *)v9 + 1220) )
          {
            if ( v17 )
            {
              sub_8105DE2((_DWORD *)a1 + 78, v11);
              v12 = v12 + 64.0;
              G_TraceCapsule(s, (float *)v11, a1 + 65, a1 + 68, a1 + 78, *((_DWORD *)a1 + 84), v14 & 0xFFFEFFFF);
              if ( !v17 )
              {
                sub_80DEB7A((float *)v11, a1 + 78, s[0], (float *)v13);
                sub_8105DE2(v13, (_DWORD *)a1 + 78);
              }
            }
            return (int *)sub_81050FE((int)a1, (int)v9, (int)s, v13);
          }
        }
      }
    }
  }
  return result;
}

//----- (081058A0) --------------------------------------------------------
int __cdecl sub_81058A0(int *a1)
{
  int v1; // eax
  int result; // eax
  int v3; // [esp+1Ch] [ebp-Ch]

  v3 = 1224 * sub_811C830(a1) + 142202936;
  v1 = Com_GetServerDObj(*a1);
  sub_80D978C(v1, a1, v3 + 12, 0);
  result = Com_GetServerDObj(*a1);
  if ( result )
    return sub_80D9698(result, a1, (int *)(v3 + 12));
  return result;
}

//----- (0810592C) --------------------------------------------------------
int __cdecl sub_810592C(float *a1)
{
  sub_81053B6(a1);
  sub_81058A0((int *)a1);
  return sub_81079C8((int)a1);
}

//----- (08105956) --------------------------------------------------------
void __cdecl sub_8105956(_DWORD *a1)
{
  long double v1; // fst7
  float v2[7]; // [esp+20h] [ebp-88h] BYREF
  float v3; // [esp+3Ch] [ebp-6Ch]
  int v4[6]; // [esp+40h] [ebp-68h] BYREF
  int v5; // [esp+58h] [ebp-50h]
  int v6; // [esp+5Ch] [ebp-4Ch]
  float s; // [esp+60h] [ebp-48h] BYREF
  float v8[2]; // [esp+64h] [ebp-44h] BYREF
  float v9; // [esp+6Ch] [ebp-3Ch]
  unsigned __int16 v10; // [esp+7Ch] [ebp-2Ch]
  char v11; // [esp+83h] [ebp-25h]
  int v12[2]; // [esp+90h] [ebp-18h] BYREF
  float v13; // [esp+98h] [ebp-10h]

  if ( (a1[31] == 1023 || *(_DWORD *)(dword_859B404 + 560 * a1[31] + 12))
    && a1[3] != 5
    && ((*((_BYTE *)a1 + 368) ^ 1) & 1) != 0 )
  {
    a1[3] = 5;
    a1[4] = dword_859B5EC;
    sub_8105DE2(a1 + 78, a1 + 6);
    sub_8105D94(a1 + 9);
  }
  if ( !a1[3] || a1[3] == 6 || a1[130] )
  {
    sub_81079C8((int)a1);
  }
  else
  {
    BG_EvaluateTrajectory((int)(a1 + 3), dword_859B5EC + 50, (int)v12);
    v5 = sub_8105FEA((int)a1);
    if ( sub_80A1DB2((float *)a1 + 78, (float *)v12) < 0.1 )
      v13 = v13 - 1.0;
    G_TraceCapsule(&s, (float *)a1 + 78, (float *)a1 + 65, (float *)a1 + 68, (float *)v12, a1[84], v5);
    if ( s >= 1.0 )
    {
      sub_8105DE2(v12, a1 + 78);
    }
    else
    {
      sub_80DEB7A((float *)a1 + 78, (float *)v12, s, (float *)v4);
      if ( !v11 && s < 0.0099999998 && v9 < 0.5 )
      {
        sub_8105E56((float *)v12, (float *)a1 + 78, v2);
        v3 = 1.0 - sub_8105F82(v2, v8);
        sub_8105F2E((float *)v12, v3, v8, (float *)v12);
        G_TraceCapsule(&s, (float *)v4, (float *)a1 + 65, (float *)a1 + 68, (float *)v12, a1[84], v5);
        sub_80DEB7A((float *)v4, (float *)v12, s, (float *)v4);
      }
      a1[3] = 3;
      a1[4] = dword_859B5EC;
      a1[5] = 50;
      sub_8105DE2(a1 + 78, a1 + 6);
      sub_8105E56((float *)v4, (float *)a1 + 78, (float *)a1 + 9);
      sub_8105EF6((float *)a1 + 9, 20.0, (float *)a1 + 9);
      sub_8105DE2(v4, a1 + 78);
    }
    SV_LinkEntity((int)a1);
    sub_81079C8((int)a1);
    if ( *((_BYTE *)a1 + 252) && s < 0.0099999998 )
    {
      v1 = v9;
      if ( v9 <= 0.0 || (v6 = sub_809C18C((float *)a1 + 78, -1, 0x80000000)) != 0 )
      {
        G_FreeEntity(v1, a1);
      }
      else
      {
        sub_81052AA((int)a1, (int)&s);
        sub_811CF36(a1, v4);
        a1[31] = v10;
        SV_LinkEntity((int)a1);
      }
    }
  }
}
// 859B404: using guessed type int dword_859B404;
// 8105956: using guessed type float var_88[7];

//----- (08105D5E) --------------------------------------------------------
int __cdecl sub_8105D5E(float a1)
{
  return (int)floor(a1 + 0.5);
}

//----- (08105D94) --------------------------------------------------------
int __cdecl sub_8105D94(_DWORD *a1)
{
  int result; // eax

  *a1 = 0;
  a1[1] = 0;
  result = 0;
  a1[2] = 0;
  return result;
}

//----- (08105DBE) --------------------------------------------------------
int __cdecl sub_8105DBE(_DWORD *a1, int a2, int a3, int a4)
{
  int result; // eax

  *a1 = a2;
  a1[1] = a3;
  result = a4;
  a1[2] = a4;
  return result;
}

//----- (08105DE2) --------------------------------------------------------
int __cdecl sub_8105DE2(_DWORD *a1, _DWORD *a2)
{
  int result; // eax

  *a2 = *a1;
  a2[1] = a1[1];
  result = a1[2];
  a2[2] = result;
  return result;
}

//----- (08105E12) --------------------------------------------------------
float *__cdecl sub_8105E12(float *a1, float *a2, float *a3)
{
  float *result; // eax

  *a3 = *a1 + *a2;
  a3[1] = a1[1] + a2[1];
  result = a1 + 2;
  a3[2] = a1[2] + a2[2];
  return result;
}

//----- (08105E56) --------------------------------------------------------
float *__cdecl sub_8105E56(float *a1, float *a2, float *a3)
{
  float *result; // eax

  *a3 = *a1 - *a2;
  a3[1] = a1[1] - a2[1];
  result = a1 + 2;
  a3[2] = a1[2] - a2[2];
  return result;
}

//----- (08105E9A) --------------------------------------------------------
float *__cdecl sub_8105E9A(float *a1, float *a2, float *a3)
{
  float *result; // eax

  *a3 = (*a1 + *a2) * 0.5;
  a3[1] = (a1[1] + a2[1]) * 0.5;
  result = a1 + 2;
  a3[2] = (a1[2] + a2[2]) * 0.5;
  return result;
}

//----- (08105EF6) --------------------------------------------------------
float *__cdecl sub_8105EF6(float *a1, float a2, float *a3)
{
  float *result; // eax

  *a3 = a2 * *a1;
  a3[1] = a2 * a1[1];
  result = a1 + 2;
  a3[2] = a2 * a1[2];
  return result;
}

//----- (08105F2E) --------------------------------------------------------
float *__cdecl sub_8105F2E(float *a1, float a2, float *a3, float *a4)
{
  float *result; // eax

  *a4 = a2 * *a3 + *a1;
  a4[1] = a2 * a3[1] + a1[1];
  result = a3 + 2;
  a4[2] = a2 * a3[2] + a1[2];
  return result;
}

//----- (08105F82) --------------------------------------------------------
long double __cdecl sub_8105F82(float *a1, float *a2)
{
  return *a1 * *a2 + a1[1] * a2[1] + a1[2] * a2[2];
}

//----- (08105FB6) --------------------------------------------------------
long double __cdecl sub_8105FB6(float *a1)
{
  return *a1 * *a1 + a1[1] * a1[1] + a1[2] * a1[2];
}

//----- (08105FEA) --------------------------------------------------------
int __cdecl sub_8105FEA(int a1)
{
  int v2; // [esp+0h] [ebp-4h]

  v2 = *(_DWORD *)(a1 + 388);
  if ( !v2 )
    return 1169;
  return v2;
}

//----- (08106014) --------------------------------------------------------
char *__usercall G_RegisterDvars@<eax>(long double a1@<st0>)
{
  g_cheats = (int)Dvar_RegisterBool(a1, "sv_cheats", 0, 4096);
  Dvar_RegisterString(a1, "gamename", "Call of Duty 2", 4164);
  Dvar_RegisterString(a1, "gamedate", "Oct 24 2005", 4160);
  Dvar_RegisterString(a1, "sv_mapname", (char *)&byte_81534F7, 4164);
  sv_gametype = (int)Dvar_RegisterString(a1, "g_gametype", "dm", 4132);
  g_maxclients = (int)Dvar_RegisterInt(a1, "sv_maxclients", (char *)0x14, 1, 64, 4133);
  g_synchronousClients = (int)Dvar_RegisterBool(a1, "g_synchronousClients", 0, 4104);
  g_log = (int)Dvar_RegisterString(a1, "g_log", "games_mp.log", 4097);
  g_logSync = (int)Dvar_RegisterBool(a1, "g_logSync", 0, 4097);
  g_password = (int)Dvar_RegisterString(a1, "g_password", (char *)&byte_81534F7, 4096);
  g_banIPs = (int)Dvar_RegisterString(a1, "g_banIPs", (char *)&byte_81534F7, 4097);
  dedicated = (int)Dvar_RegisterInt(a1, "dedicated", 0, 0, 2, 4128);
  if ( *(_DWORD *)(dedicated + 8) )
    Dvar_RegisterInt(a1, "dedicated", 0, 0, 2, 4160);
  g_speed = (int)Dvar_RegisterInt(a1, "g_speed", (char *)0xBE, 0x80000000, 0x7FFFFFFF, 4096);
  g_gravity = (int)Dvar_RegisterFloat(a1, "g_gravity", (char *)0x44480000, 1065353216, 2139095039, 4096);
  g_knockback = (int)Dvar_RegisterFloat(a1, "g_knockback", (char *)0x447A0000, -8388609, 2139095039, 4096);
  g_weaponAmmoPools = (int)Dvar_RegisterBool(a1, "g_weaponAmmoPools", 0, 4096);
  g_maxDroppedWeapons = (int)Dvar_RegisterInt(a1, "g_maxDroppedWeapons", (char *)0x10, 1, 32, 4096);
  g_inactivity = (int)Dvar_RegisterInt(a1, "g_inactivity", 0, 0, 0x7FFFFFFF, 4096);
  g_debugDamage = (int)Dvar_RegisterBool(a1, "g_debugDamage", 0, 4224);
  g_debugBullets = (int)Dvar_RegisterInt(a1, "g_debugBullets", 0, -3, 6, 4224);
  g_motd = (int)Dvar_RegisterString(a1, "g_motd", (char *)&byte_81534F7, 4096);
  g_playerCollisionEjectSpeed = (int)Dvar_RegisterInt(a1, "g_playerCollisionEjectSpeed", (char *)0x19, 0, 32000, 4097);
  g_dropForwardSpeed = (int)Dvar_RegisterFloat(a1, "g_dropForwardSpeed", (char *)0x41200000, 0, 1148846080, 4097);
  g_dropUpSpeedBase = (int)Dvar_RegisterFloat(a1, "g_dropUpSpeedBase", (char *)0x41200000, 0, 1148846080, 4097);
  g_dropUpSpeedRand = (int)Dvar_RegisterFloat(a1, "g_dropUpSpeedRand", (char *)0x40A00000, 0, 1148846080, 4097);
  g_clonePlayerMaxVelocity = (int)Dvar_RegisterFloat(a1, "g_clonePlayerMaxVelocity", (char *)0x42A00000, 0, 2139095039, 4097);
  voice_global = (int)Dvar_RegisterBool(a1, "voice_global", 0, 4097);
  voice_localEcho = (int)Dvar_RegisterBool(a1, "voice_localEcho", 0, 4097);
  voice_deadChat = (int)Dvar_RegisterBool(a1, "voice_deadChat", 0, 4097);
  g_allowVote = (int)Dvar_RegisterBool(a1, "g_allowVote", 1, 4096);
  g_listEntity = (int)Dvar_RegisterBool(a1, "g_listEntity", 0, 4096);
  g_deadChat = (int)Dvar_RegisterBool(a1, "g_deadChat", 0, 4097);
  g_voiceChatTalkingDuration = (int)Dvar_RegisterInt(a1, "g_voiceChatTalkingDuration", (char *)0x1F4, 0, 10000, 4097);
  g_ScoresBanner_Allies = (int)Dvar_RegisterString(a1, "g_ScoresBanner_Allies", "mpflag_american", 4352);
  g_ScoresBanner_Axis = (int)Dvar_RegisterString(a1, "g_ScoresBanner_Axis", "mpflag_german", 4352);
  g_ScoresBanner_None = (int)Dvar_RegisterString(a1, "g_ScoresBanner_None", "mpflag_none", 4352);
  g_ScoresBanner_Spectators = (int)Dvar_RegisterString(a1, "g_ScoresBanner_Spectators", "mpflag_spectator", 4352);
  g_TeamName_Allies = (int)Dvar_RegisterString(a1, "g_TeamName_Allies", "GAME_ALLIES", 4352);
  g_TeamName_Axis = (int)Dvar_RegisterString(a1, "g_TeamName_Axis", "GAME_AXIS", 4352);
  g_TeamColor_Allies = (int)sub_80B1EA0(a1, "g_TeamColor_Allies", 0.5, 0.5, 1.0, 1.0, 4352);
  g_TeamColor_Axis = (int)sub_80B1EA0(a1, "g_TeamColor_Axis", 1.0, 0.5, 0.5, 1.0, 4352);
  g_smoothClients = (int)Dvar_RegisterBool(a1, "g_smoothClients", 1, 4096);
  g_antilag = (int)Dvar_RegisterBool(a1, "g_antilag", 1, 4101);
  g_oldVoting = (int)Dvar_RegisterBool(a1, "g_oldVoting", 1, 4097);
  g_voteAbstainWeight = (int)Dvar_RegisterFloat(a1, "g_voteAbstainWeight", (char *)0x3F000000, 0, 1065353216, 4097);
  g_no_script_spam = (int)Dvar_RegisterBool(a1, "g_no_script_spam", 0, 4096);
  g_debugLocDamage = (int)Dvar_RegisterBool(a1, "g_debugLocDamage", 0, 4224);
  g_friendlyfireDist = (int)Dvar_RegisterFloat(a1, "g_friendlyfireDist", (char *)0x43800000, 0, 1181376512, 4224);
  g_friendlyNameDist = (int)Dvar_RegisterFloat(a1, "g_friendlyNameDist", (char *)0x466A6000, 0, 1181376512, 4224);
  player_meleeRange = (int)Dvar_RegisterFloat(a1, "player_meleeRange", (char *)0x42800000, 0, 1148846080, 4224);
  player_meleeWidth = (int)Dvar_RegisterFloat(a1, "player_meleeWidth", (char *)0x41200000, 0, 1148846080, 4224);
  player_meleeHeight = (int)Dvar_RegisterFloat(a1, "player_meleeHeight", (char *)0x41200000, 0, 1148846080, 4224);
  g_dumpAnims = (int)Dvar_RegisterInt(a1, "g_dumpAnims", (char *)0xFFFFFFFF, -1, 1023, 4224);
  g_useholdtime = (int)Dvar_RegisterInt(a1, "g_useholdtime", 0, 0, 0x7FFFFFFF, 4096);
  g_useholdspawndelay = (int)Dvar_RegisterInt(a1, "g_useholdspawndelay", (char *)1, 0, 10, 4225);
  g_mantleBlockTimeBuffer = (int)Dvar_RegisterInt(a1, "g_mantleBlockTimeBuffer", (char *)0x1F4, 0, 60000, 4224);
  return BG_RegisterDvars(a1);
}
// 8793D80: using guessed type int sv_gametype;
// 8793D84: using guessed type int g_password;
// 8793D88: using guessed type int g_maxclients;
// 8793D8C: using guessed type int dedicated;
// 8793D90: using guessed type int g_speed;
// 8793D94: using guessed type int g_gravity;
// 8793D98: using guessed type int g_cheats;
// 8793D9C: using guessed type int g_knockback;
// 8793DA0: using guessed type int g_useholdtime;
// 8793DA4: using guessed type int g_useholdspawndelay;
// 8793DA8: using guessed type int g_inactivity;
// 8793DAC: using guessed type int g_debugDamage;
// 8793DB0: using guessed type int g_debugBullets;
// 8793DB4: using guessed type int g_weaponAmmoPools;
// 8793DB8: using guessed type int g_maxDroppedWeapons;
// 8793DBC: using guessed type int g_motd;
// 8793DC0: using guessed type int g_synchronousClients;
// 8793DC4: using guessed type int g_playerCollisionEjectSpeed;
// 8793DC8: using guessed type int g_dropForwardSpeed;
// 8793DCC: using guessed type int g_dropUpSpeedBase;
// 8793DD0: using guessed type int g_dropUpSpeedRand;
// 8793DD4: using guessed type int g_clonePlayerMaxVelocity;
// 8793DD8: using guessed type int g_mantleBlockTimeBuffer;
// 8793DDC: using guessed type int voice_localEcho;
// 8793DE0: using guessed type int voice_global;
// 8793DE4: using guessed type int voice_deadChat;
// 8793DE8: using guessed type int g_voiceChatTalkingDuration;
// 8793DEC: using guessed type int g_log;
// 8793DF0: using guessed type int g_logSync;
// 8793DF4: using guessed type int g_allowVote;
// 8793DFC: using guessed type int g_deadChat;
// 8793E00: using guessed type int g_listEntity;
// 8793E0C: using guessed type int g_smoothClients;
// 8793E10: using guessed type int g_ScoresBanner_Allies;
// 8793E14: using guessed type int g_ScoresBanner_Axis;
// 8793E18: using guessed type int g_ScoresBanner_None;
// 8793E1C: using guessed type int g_ScoresBanner_Spectators;
// 8793E20: using guessed type int g_TeamName_Allies;
// 8793E24: using guessed type int g_TeamName_Axis;
// 8793E28: using guessed type int g_TeamColor_Allies;
// 8793E2C: using guessed type int g_TeamColor_Axis;
// 8793E30: using guessed type int g_no_script_spam;
// 8793E34: using guessed type int g_debugLocDamage;
// 8793E38: using guessed type int g_friendlyfireDist;
// 8793E3C: using guessed type int g_friendlyNameDist;
// 8793E40: using guessed type int player_meleeRange;
// 8793E44: using guessed type int player_meleeWidth;
// 8793E48: using guessed type int player_meleeHeight;
// 8793E4C: using guessed type int g_antilag;
// 8793E50: using guessed type int g_oldVoting;
// 8793E54: using guessed type int g_voteAbstainWeight;
// 8793E58: using guessed type int g_dumpAnims;

//----- (0810695E) --------------------------------------------------------
int G_GetSavePersist()
{
  return dword_859D154;
}
// 859D154: using guessed type int dword_859D154;

//----- (08106968) --------------------------------------------------------
int __cdecl sub_8106968(int a1)
{
  int result; // eax

  result = a1;
  dword_859D154 = a1;
  return result;
}
// 859D154: using guessed type int dword_859D154;

//----- (08106976) --------------------------------------------------------
long double sub_8106976()
{
  return *(float *)&dword_859D1DC;
}
// 859D1DC: using guessed type int dword_859D1DC;

//----- (0810698A) --------------------------------------------------------
int __cdecl sub_810698A(int a1)
{
  return *(_DWORD *)(dword_859B400 + 10404 * a1 + 9912);
}
// 859B400: using guessed type int dword_859B400;

//----- (081069A6) --------------------------------------------------------
int __cdecl sub_81069A6(int a1)
{
  return *(_DWORD *)(dword_859B400 + 10404 * a1 + 9908);
}
// 859B400: using guessed type int dword_859B400;

//----- (081069C2) --------------------------------------------------------
int __cdecl sub_81069C2(int a1, int a2)
{
  int result; // eax

  result = a2;
  *(_DWORD *)(dword_859B400 + 10404 * a1 + 9908) = a2;
  return result;
}
// 859B400: using guessed type int dword_859B400;

//----- (081069E2) --------------------------------------------------------
int __cdecl sub_81069E2(int a1)
{
  return dword_859B400 + 10404 * a1 + 10056;
}
// 859B400: using guessed type int dword_859B400;

//----- (081069FC) --------------------------------------------------------
int __usercall sub_81069FC@<eax>(long double a1@<st0>)
{
  int result; // eax
  int *s; // [esp+10h] [ebp-8h]
  int i; // [esp+14h] [ebp-4h]

  s = (int *)&unk_8665480;
  for ( i = 0; ; ++i )
  {
    result = i;
    if ( i >= *(int *)dword_859B40C )
      break;
    if ( *((_BYTE *)s + 252) )
      G_FreeEntity(a1, s);
    s += 140;
  }
  if ( byte_86F111C )
    result = G_FreeEntity(a1, &dword_86F1020);
  *(_DWORD *)dword_859B40C = 0;
  dword_859B410 = 0;
  dword_859B414 = 0;
  return result;
}
// 859B410: using guessed type int dword_859B410;
// 859B414: using guessed type int dword_859B414;
// 86F1020: using guessed type int dword_86F1020;
// 86F111C: using guessed type char byte_86F111C;

//----- (08106A7C) --------------------------------------------------------
int __cdecl G_CreateDObj(__int16 ***a1, unsigned __int16 a2, int a3, int a4)
{
  return sub_8062A66(a1, a2, a3, a4);
}

//----- (08106AAC) --------------------------------------------------------
int *sub_8106AAC()
{
  int *result; // eax
  int v1; // ebx
  int v2; // ebx
  int v3; // [esp+Ch] [ebp-Ch]
  int v4[2]; // [esp+10h] [ebp-8h] BYREF

  result = (int *)dword_8652608;
  v3 = dword_8652608;
  for ( v4[0] = 0; v4[0] <= 63; ++v4[0] )
  {
    v1 = 302 * v4[0];
    dword_8652AE0[v1] = (int)sub_80BA7E4(v3, (int (__cdecl *)(int))Hunk_AllocXAnimServer);
    result = v4;
  }
  for ( v4[0] = 0; v4[0] <= 7; ++v4[0] )
  {
    v2 = 306 * v4[0];
    dword_879D838[v2] = (int)sub_80BA7E4(v3, (int (__cdecl *)(int))Hunk_AllocXAnimServer);
    result = v4;
  }
  return result;
}
// 8652608: using guessed type int dword_8652608;
// 8652AE0: using guessed type int dword_8652AE0[19048];
// 879D838: using guessed type int dword_879D838[];

//----- (08106B36) --------------------------------------------------------
int *sub_8106B36()
{
  int *result; // eax
  int i; // [esp+14h] [ebp-4h] BYREF

  for ( i = 0; i <= 63; ++i )
  {
    if ( dword_8652AE0[302 * i] )
    {
      sub_80BA836((_DWORD *)dword_8652AE0[302 * i], 0);
      dword_8652AE0[302 * i] = 0;
    }
    result = &i;
  }
  for ( i = 0; i <= 7; ++i )
  {
    if ( dword_879D838[306 * i] )
    {
      sub_80BA836((_DWORD *)dword_879D838[306 * i], 0);
      dword_879D838[306 * i] = 0;
    }
    result = &i;
  }
  return result;
}
// 8652AE0: using guessed type int dword_8652AE0[19048];
// 879D838: using guessed type int dword_879D838[];

//----- (08106BF2) --------------------------------------------------------
void *__cdecl Hunk_AllocXAnimServer(size_t a1)
{
  return Hunk_AllocLowInternal(a1);
}

//----- (08106C06) --------------------------------------------------------
int __usercall G_InitGame@<eax>(long double a1@<st0>, int a2, unsigned int seed, int a4, int a5)
{
  char dest[1024]; // [esp+20h] [ebp-818h] BYREF
  char s1[1032]; // [esp+420h] [ebp-418h] BYREF
  int i; // [esp+828h] [ebp-10h]
  int j; // [esp+82Ch] [ebp-Ch]

  Com_Printf("------- Game Initialization -------\n");
  Com_Printf("gamename: %s\n", "Call of Duty 2");
  Com_Printf("gamedate: %s\n", "Oct 24 2005");
  Swap_Init();
  memset(&dword_859B400, 0, 0x3624u);
  dword_859B41C = 1;
  dword_859B5EC = a2;
  *(_DWORD *)dword_859B5F8 = a2;
  dword_859EA04 = -1;
  srand(seed);
  sub_80A8712(seed);
  sub_811E8E4();
  if ( !a4 || !a5 )
    G_RegisterDvars(a1);
  G_ProcessIPBans();
  dword_865262C = (int)SV_XModelGet;
  dword_8652630 = (int)G_CreateDObj;
  dword_8652634 = (int)Com_SafeServerDObjFree;
  dword_8652638 = (int)Hunk_AllocXAnimServer;
  dword_8652628 = 1;
  if ( **(_BYTE **)(g_log + 8) )
  {
    if ( *(_BYTE *)(g_logSync + 8) )
      FS_FOpenFileByMode(*(char **)(g_log + 8), &dword_859B418, 3);
    else
      FS_FOpenFileByMode(*(char **)(g_log + 8), &dword_859B418, 2);
    if ( dword_859B418 )
    {
      SV_GetServerinfo(dest, 1024);
      G_LogPrintf("------------------------------------------------------------\n");
      G_LogPrintf("InitGame: %s\n", dest);
    }
    else
    {
      Com_Printf("WARNING: Couldn't open logfile: %s\n", *(const char **)(g_log + 8));
    }
  }
  else
  {
    Com_Printf("Not logging to disk.\n");
  }
  for ( i = 0; i <= 0; ++i )
  {
    dword_859EA08[i] = -1;
    *(&dword_859EA0C + i) = 0;
    memset((void *)(20 * i + 140110352), 0, 0x14u);
  }
  sub_80DB380((int (__cdecl *)(int))Hunk_AllocXAnimServer);
  dword_855A4E0 = &unk_859EA40;
  if ( !a4 )
  {
    memset(dword_855A4E0, 0, 0xB3BC8u);
    *((_DWORD *)dword_855A4E0 + 184048) = sub_80AA8AA;
    *((_DWORD *)dword_855A4E0 + 184049) = sub_811CEFE;
    GScr_LoadScripts(a1);
    sub_80D9B7E();
    sub_8106AAC();
  }
  sub_8120068();
  SV_GetConfigstring(0x16u, s1, 1024);
  Info_SetValueForKey(s1, "winner", (int)"0");
  SV_SetConfigstring(0x16u, s1);
  memset(&unk_8665480, 0, 0x8C000u);
  dword_859B404 = (int)&unk_8665480;
  dword_859B5E4 = *(_DWORD *)(g_maxclients + 8);
  memset(&unk_86F1480, 0, 0xA2900u);
  dword_859B400 = (int)&unk_86F1480;
  for ( j = 0; j < dword_859B5E4; ++j )
    dword_86655D8[140 * j] = dword_859B400 + 10404 * j;
  *(_DWORD *)dword_859B40C = 72;
  dword_859B410 = 0;
  dword_859B414 = 0;
  sub_8090498(dword_859B404, 72, 560, dword_859B400, 10404);
  sub_80FEEDA();
  sub_81083B2();
  G_SpawnEntitiesFromString(a1);
  sub_80FBD50("0");
  sub_811030E();
  sub_807E04A();
  Com_Printf("-----------------------------------\n");
  sub_8083E96();
  sub_807F9F2(1);
  sub_807F64C();
  G_LoadStructs();
  sub_8115E66();
  sub_810DD38();
  sub_8115E94();
  for ( j = 0; j <= 7; ++j )
    dword_879D83C[306 * j] = -1;
  dword_855A4E0 = 0;
  dword_859B41C = 0;
  sub_8104A30();
  return sub_8104AEC();
}
// 859B400: using guessed type int dword_859B400;
// 859B404: using guessed type int dword_859B404;
// 859B410: using guessed type int dword_859B410;
// 859B414: using guessed type int dword_859B414;
// 859B418: using guessed type int dword_859B418;
// 859B5E4: using guessed type int dword_859B5E4;
// 859EA04: using guessed type int dword_859EA04;
// 859EA08: using guessed type int dword_859EA08[];
// 8652628: using guessed type int dword_8652628;
// 865262C: using guessed type int dword_865262C;
// 8652630: using guessed type int dword_8652630;
// 8652634: using guessed type int dword_8652634;
// 8652638: using guessed type int dword_8652638;
// 86655D8: using guessed type int dword_86655D8[];
// 8793D88: using guessed type int g_maxclients;
// 8793DEC: using guessed type int g_log;
// 8793DF0: using guessed type int g_logSync;
// 879D83C: using guessed type int dword_879D83C[2449];

//----- (08107058) --------------------------------------------------------
unsigned int *__usercall G_ShutdownGame@<eax>(long double a1@<st0>, int a2)
{
  unsigned int *result; // eax
  int i; // [esp+14h] [ebp-4h] BYREF

  Com_Printf("==== ShutdownGame ====\n");
  if ( dword_859B418 )
  {
    G_LogPrintf("ShutdownGame:\n");
    G_LogPrintf("------------------------------------------------------------\n");
    FS_FCloseFile(dword_859B418);
  }
  dword_855A4E0 = 0;
  sub_81069FC(a1);
  sub_8100FE6();
  if ( Scr_IsSystemActive() && !dword_859D154 )
    sub_808DC2C();
  result = sub_8083EDA(1, dword_859D154 == 0);
  if ( a2 )
  {
    sub_80DB6CA();
    sub_810E010();
    sub_8075F74();
    sub_8106B36();
    result = Hunk_ClearLow(0);
  }
  for ( i = 0; i <= 0; ++i )
  {
    if ( *(&dword_859EA0C + i) )
      Z_FreeInternal(*(&dword_859EA0C + i));
    *(&dword_859EA0C + i) = 0;
    if ( dword_859EA08[i] >= 0 )
      FS_FCloseFile(dword_859EA08[i]);
    dword_859EA08[i] = -1;
    result = (unsigned int *)&i;
  }
  return result;
}
// 859B418: using guessed type int dword_859B418;
// 859D154: using guessed type int dword_859D154;
// 859EA08: using guessed type int dword_859EA08[];

//----- (08107186) --------------------------------------------------------
int sub_8107186()
{
  int result; // eax
  int i; // [esp+14h] [ebp-4h]

  if ( dword_859B610 )
  {
    for ( i = 0; ; ++i )
    {
      result = i;
      if ( i >= dword_859B5E4 )
        break;
      if ( *(_DWORD *)(dword_859B400 + 10404 * i + 9924) == 2 && *(_DWORD *)(dword_859B400 + 10404 * i + 4) == 5 )
        DeathmatchScoreboardMessage(560 * i + 140924032);
    }
    dword_859B610 = 0;
  }
  return result;
}
// 859B400: using guessed type int dword_859B400;
// 859B5E4: using guessed type int dword_859B5E4;
// 859B610: using guessed type int dword_859B610;

//----- (081071FE) --------------------------------------------------------
int __cdecl SortRanks(_DWORD *a1, _DWORD *a2)
{
  _DWORD *v4; // [esp+4h] [ebp-8h]
  _DWORD *v5; // [esp+8h] [ebp-4h]

  v5 = (_DWORD *)(dword_859B400 + 10404 * *a1);
  v4 = (_DWORD *)(dword_859B400 + 10404 * *a2);
  if ( v5[2481] == 1 )
    return 1;
  if ( v4[2481] == 1 )
    return -1;
  if ( v5[2515] == 3 && v4[2515] == 3 )
  {
    if ( v5 >= v4 )
      return v5 > v4;
    else
      return -1;
  }
  else if ( v5[2515] == 3 )
  {
    return 1;
  }
  else if ( v4[2515] == 3 )
  {
    return -1;
  }
  else if ( v5[2478] <= v4[2478] )
  {
    if ( v5[2478] >= v4[2478] )
    {
      if ( v5[2479] >= v4[2479] )
        return v5[2479] > v4[2479];
      else
        return -1;
    }
    else
    {
      return 1;
    }
  }
  else
  {
    return -1;
  }
}
// 859B400: using guessed type int dword_859B400;

//----- (08107356) --------------------------------------------------------
void CalculateRanks()
{
  int i; // [esp+14h] [ebp-4h]

  nmemb = 0;
  dword_859BF2C = 0;
  for ( i = 0; i < dword_859B5E4; ++i )
  {
    if ( *(_DWORD *)(dword_859B400 + 10404 * i + 9924) )
    {
      *(_DWORD *)&dword_859B61C[4 * nmemb++] = i;
      if ( *(_DWORD *)(dword_859B400 + 10404 * i + 10060) != 3 && *(_DWORD *)(dword_859B400 + 10404 * i + 9924) == 2 )
        ++dword_859BF2C;
    }
  }
  qsort(dword_859B61C, nmemb, 4u, (__compar_fn_t)SortRanks);
  dword_859B610 = 1;
}
// 859B400: using guessed type int dword_859B400;
// 859B5E4: using guessed type int dword_859B5E4;
// 859B610: using guessed type int dword_859B610;
// 859BF2C: using guessed type int dword_859BF2C;

//----- (08107428) --------------------------------------------------------
void ExitLevel()
{
  int i; // [esp+14h] [ebp-4h]
  int j; // [esp+14h] [ebp-4h]

  Cbuf_ExecuteText(2, "map_rotate\n");
  *(_DWORD *)dword_859B600 = 0;
  *(_DWORD *)dword_859B604 = 0;
  for ( i = 0; i < *(_DWORD *)(g_maxclients + 8); ++i )
  {
    if ( *(_DWORD *)(dword_859B400 + 10404 * i + 9924) == 2 )
      *(_DWORD *)(dword_859B400 + 10404 * i + 9912) = 0;
  }
  for ( j = 0; j < *(_DWORD *)(g_maxclients + 8); ++j )
  {
    if ( *(_DWORD *)(dword_859B400 + 10404 * j + 9924) == 2 )
      *(_DWORD *)(dword_859B400 + 10404 * j + 9924) = 1;
  }
  G_LogPrintf("ExitLevel: executed\n");
}
// 859B400: using guessed type int dword_859B400;
// 8793D88: using guessed type int g_maxclients;

//----- (08107502) --------------------------------------------------------
void G_LogPrintf(char *format, ...)
{
  size_t v1; // eax
  char s[1024]; // [esp+30h] [ebp-818h] BYREF
  char v3[1036]; // [esp+430h] [ebp-418h] BYREF
  __gnuc_va_list __varargs; // [esp+83Ch] [ebp-Ch]
  va_list va; // [esp+854h] [ebp+Ch] BYREF

  va_start(va, format);
  if ( dword_859B418 )
  {
    va_copy(__varargs, va);
    vsprintf(s, format, va);
    Com_sprintf(
      v3,
      0x400u,
      "%3i:%i%i %s",
      dword_859B5EC / 1000 / 60,
      dword_859B5EC / 1000 % 60 / 10,
      dword_859B5EC / 1000 % 60 % 10,
      s);
    v1 = strlen(v3);
    FS_Write(v3, v1, dword_859B418);
  }
}
// 859B418: using guessed type int dword_859B418;

//----- (08107644) --------------------------------------------------------
void CheckVote()
{
  char *v0; // eax
  char *v1; // eax
  char *v2; // eax
  double v3; // [esp+18h] [ebp-20h]
  int v4; // [esp+28h] [ebp-10h]
  int v5; // [esp+30h] [ebp-8h]

  if ( dword_859BF20 )
  {
    if ( dword_859BF20 < dword_859B5EC )
    {
      dword_859BF20 = 0;
      v0 = va("%s\n", byte_859B71C);
      Cbuf_ExecuteText(2, v0);
    }
  }
  if ( *(_DWORD *)dword_859BF1C )
  {
    if ( dword_859B5EC - *(_DWORD *)dword_859BF1C < 0 )
    {
      v4 = dword_859BF2C / 2 + 1;
      if ( *(int *)dword_859BF24 >= v4 )
        goto LABEL_7;
      if ( *(int *)dword_859BF28 <= dword_859BF2C - v4 )
        return;
    }
    else
    {
      v5 = *(_DWORD *)dword_859BF24;
      v3 = (double)*(int *)dword_859BF28;
      if ( v5 > (int)(ceil(
                        (long double)(dword_859BF2C - (*(_DWORD *)dword_859BF24 + *(_DWORD *)dword_859BF28))
                      * *(float *)(g_voteAbstainWeight + 8))
                    + v3) )
      {
LABEL_7:
        v1 = va("%c \"GAME_VOTEPASSED\"", 101);
        SV_GameSendServerCommand(-1, 0, v1);
        dword_859BF20 = dword_859B5EC + 3000;
LABEL_12:
        *(_DWORD *)dword_859BF1C = 0;
        SV_SetConfigstring(0xFu, (char *)&byte_81534F7);
        return;
      }
    }
    v2 = va("%c \"GAME_VOTEFAILED\"", 101);
    SV_GameSendServerCommand(-1, 0, v2);
    goto LABEL_12;
  }
}
// 859BF20: using guessed type int dword_859BF20;
// 859BF2C: using guessed type int dword_859BF2C;
// 8793E54: using guessed type int g_voteAbstainWeight;

//----- (08107848) --------------------------------------------------------
int sub_8107848()
{
  int result; // eax
  _DWORD *v1; // ecx
  int v2; // [esp+0h] [ebp-18h]
  int v3; // [esp+4h] [ebp-14h]
  int j; // [esp+Ch] [ebp-Ch]
  int v5; // [esp+10h] [ebp-8h]
  int i; // [esp+14h] [ebp-4h]

  for ( i = 0; ; ++i )
  {
    result = i;
    if ( i >= dword_859B5E4 )
      break;
    v5 = dword_859B404 + 560 * i;
    if ( *(_BYTE *)(v5 + 252) )
    {
      v3 = *(_DWORD *)(v5 + 344);
      v2 = *(_DWORD *)(v3 + 10060);
      for ( j = 0; j <= 15; ++j )
      {
        if ( dword_859B424[7 * j] && (!dword_859B424[7 * j + 5] || dword_859B424[7 * j + 5] == v2) )
        {
          v1 = (_DWORD *)(v3 + 28 * j + 1508);
          *v1 = dword_859B424[7 * j];
          v1[1] = dword_859B424[7 * j + 1];
          v1[2] = dword_859B424[7 * j + 2];
          v1[3] = dword_859B424[7 * j + 3];
          v1[4] = dword_859B424[7 * j + 4];
          v1[5] = dword_859B424[7 * j + 5];
          v1[6] = dword_859B424[7 * j + 6];
        }
        else
        {
          *(_DWORD *)(v3 + 28 * j + 1508) = 0;
        }
      }
    }
  }
  return result;
}
// 859B404: using guessed type int dword_859B404;
// 859B424: using guessed type _DWORD[112];
// 859B5E4: using guessed type int dword_859B5E4;

//----- (08107962) --------------------------------------------------------
int sub_8107962()
{
  int result; // eax
  int i; // [esp+14h] [ebp-4h]

  for ( i = 0; ; ++i )
  {
    result = i;
    if ( i >= dword_859B5E4 )
      break;
    if ( *(_BYTE *)(dword_859B404 + 560 * i + 252) )
      sub_81023F2(*(_DWORD **)(dword_859B404 + 560 * i + 344), *(_DWORD *)(dword_859B404 + 560 * i), 3u);
  }
  return result;
}
// 859B404: using guessed type int dword_859B404;
// 859B5E4: using guessed type int dword_859B5E4;

//----- (081079C8) --------------------------------------------------------
int __cdecl sub_81079C8(int a1)
{
  int result; // eax
  int (__cdecl *v2)(int); // [esp+10h] [ebp-8h]
  int v3; // [esp+14h] [ebp-4h]

  result = *(_DWORD *)(a1 + 400);
  v3 = result;
  if ( result > 0 )
  {
    result = *(_DWORD *)(a1 + 400);
    if ( v3 <= dword_859B5EC )
    {
      *(_DWORD *)(a1 + 400) = 0;
      v2 = (int (__cdecl *)(int))dword_8167880[10 * *(unsigned __int8 *)(a1 + 358)];
      if ( !v2 )
        Com_Error(1, (char *)&byte_8153A87);
      return v2(a1);
    }
  }
  return result;
}
// 8167880: using guessed type int dword_8167880[];

//----- (08107A40) --------------------------------------------------------
void sub_8107A40()
{
  if ( *(int *)(g_dumpAnims + 8) >= 0 )
  {
    Com_Printf("server:\n");
    sub_80908FC((int *)(dword_859B404 + 560 * *(_DWORD *)(g_dumpAnims + 8)));
  }
}
// 859B404: using guessed type int dword_859B404;
// 8793E58: using guessed type int g_dumpAnims;

//----- (08107A7C) --------------------------------------------------------
int __cdecl sub_8107A7C(int a1)
{
  int result; // eax

  while ( 1 )
  {
    result = a1;
    if ( !*(_BYTE *)(a1 + 252) )
      break;
    result = *(_DWORD *)(a1 + 372) & 0x2000;
    if ( result )
      break;
    result = sub_811BF04((int *)a1, 1);
    if ( !result )
      break;
    sub_8084FD2();
  }
  return result;
}

//----- (08107AC4) --------------------------------------------------------
void __usercall sub_8107AC4(long double a1@<st0>, int *s)
{
  unsigned int v2; // edx

  if ( s[98] != dword_859B5E8 )
  {
    s[98] = dword_859B5E8;
    if ( !s[86] )
    {
      if ( (s[93] & 0x800) != 0 )
        v2 = s[2] | 0x20;
      else
        v2 = s[2] & 0xFFFFFFDF;
      s[2] = v2;
    }
    if ( s[2] == 0x10000 && dword_859B5EC > s[22] )
      goto LABEL_9;
    if ( dword_859B5EC - s[94] > 300 )
    {
      if ( s[95] )
      {
LABEL_9:
        G_FreeEntity(a1, s);
        return;
      }
      if ( s[96] )
      {
        s[96] = 0;
        SV_UnlinkEntity((int)s);
      }
    }
    if ( !s[95] )
    {
      switch ( s[1] )
      {
        case 4:
          sub_810BC36((unsigned __int8 *)s);
          return;
        case 3:
          if ( s[130] )
          {
            sub_811BE86(s);
            sub_81079C8((int)s);
            return;
          }
LABEL_24:
          sub_8105956(s);
          return;
        case 2:
          sub_810592C((float *)s);
          return;
      }
      if ( *((_BYTE *)s + 352) )
        goto LABEL_24;
      if ( s[1] == 6 )
      {
        sub_810D966(s);
      }
      else if ( s[86] )
      {
        sub_80F3F74(a1, s);
      }
      else
      {
        if ( !s[1] )
        {
          if ( s[130] )
            sub_811BE86(s);
        }
        sub_81079C8((int)s);
      }
    }
  }
}
// 859B5E8: using guessed type int dword_859B5E8;

//----- (08107CA2) --------------------------------------------------------
void __usercall sub_8107CA2(long double a1@<st0>, int a2)
{
  int v2; // ecx
  int v3; // edx
  const char *v4; // eax
  float v5; // [esp+4h] [ebp-434h]
  char s[1028]; // [esp+10h] [ebp-428h] BYREF
  int v7; // [esp+414h] [ebp-24h]
  int v8; // [esp+418h] [ebp-20h]
  char v9[5]; // [esp+41Fh] [ebp-19h]
  int *v10; // [esp+424h] [ebp-14h]
  int *v11; // [esp+428h] [ebp-10h]
  int v12[3]; // [esp+42Ch] [ebp-Ch]

  ++dword_859B5E8;
  dword_859B5F0 = dword_859B5EC;
  dword_859B5EC = a2;
  dword_859B5F4 = a2 - dword_859B5F0;
  dword_865261C = a2;
  dword_8652620 = a2;
  dword_8652624 = a2 - dword_859B5F0;
  dword_855A4E0 = &unk_859EA40;
  v11 = (int *)&unk_8665480;
  v12[0] = 0;
  while ( v12[0] < *(int *)dword_859B40C )
  {
    if ( *((_BYTE *)v11 + 252) )
    {
      a1 = (long double)dword_859B5F4 * 0.001;
      v5 = a1;
      sub_80907BC(v11, v5);
    }
    ++v12[0];
    v11 += 140;
  }
  memset(s, 0, 0x400u);
  v9[0] = 0;
  Com_Memcpy(dword_859DDE8, &unk_859D1E8, 12 * dword_859E9E8);
  dword_859E9EC = dword_859E9E8;
  dword_859E9E8 = 0;
  do
  {
    v9[4] = 0;
    *(_DWORD *)v9 = (unsigned __int8)(v9[0] + 1);
    for ( v12[0] = 0; v12[0] < dword_859E9EC; ++v12[0] )
    {
      v8 = 12 * v12[0] + 140107240;
      v7 = LOWORD(dword_859DDE8[3 * v12[0]]);
      v11 = (int *)((char *)&unk_8665480 + 560 * v7);
      if ( v11[138] == dword_859DDEC[3 * v12[0]] )
      {
        v10 = (int *)((char *)&unk_8665480 + 560 * *(unsigned __int16 *)(v8 + 2));
        if ( v10[138] == *(_DWORD *)(v8 + 8) )
        {
          if ( s[v7] == v9[0] )
          {
            *(_DWORD *)&v9[1] = 1;
            continue;
          }
          s[v7] = v9[0];
          Scr_AddEntity(v10);
          Scr_Notify(v11, word_87A22F4, 1);
        }
      }
      --dword_859E9EC;
      --v12[0];
      v2 = v8;
      v3 = 3 * dword_859E9EC;
      *(_DWORD *)v8 = dword_859DDE8[3 * dword_859E9EC];
      *(_DWORD *)(v2 + 4) = dword_859DDEC[v3];
      *(_DWORD *)(v2 + 8) = dword_859DDF0[v3];
    }
    sub_8084FD2();
  }
  while ( *(_DWORD *)&v9[1] );
  v11 = (int *)&unk_8665480;
  v12[0] = 0;
  while ( v12[0] < *(int *)dword_859B40C )
  {
    sub_8107A7C((int)v11);
    ++v12[0];
    v11 += 140;
  }
  sub_8084F9A();
  v11 = (int *)&unk_8665480;
  dword_859EA04 = 0;
  while ( dword_859EA04 < *(int *)dword_859B40C )
  {
    if ( *((_BYTE *)v11 + 252) )
    {
      if ( v11[130] )
        sub_8107AC4(a1, *(int **)v11[130]);
      sub_8107AC4(a1, v11);
    }
    ++dword_859EA04;
    v11 += 140;
  }
  dword_859EA04 = -1;
  sub_8107848();
  sub_8107962();
  v11 = (int *)&unk_8665480;
  v12[0] = 0;
  while ( v12[0] < dword_859B5E4 )
  {
    if ( *((_BYTE *)v11 + 252) )
      sub_80F4DBE(a1, (int)v11);
    ++v12[0];
    v11 += 140;
  }
  sub_8119EF2();
  if ( *(_BYTE *)(g_oldVoting + 8) )
    CheckVote();
  sub_8107186();
  if ( *(_BYTE *)(g_listEntity + 8) )
  {
    for ( v12[0] = 0; v12[0] <= 1023; ++v12[0] )
    {
      v4 = (const char *)SL_ConvertToString((unsigned __int16)word_86655E8[280 * v12[0]]);
      Com_Printf("%4i: %s\n", v12[0], v4);
    }
    Dvar_SetBool(g_listEntity, 0);
  }
  if ( dword_859E9FC )
    sub_8104A30();
  if ( dword_859EA00 )
    sub_8104AEC();
  sub_8107A40();
  dword_855A4E0 = 0;
}
// 859B5E4: using guessed type int dword_859B5E4;
// 859B5E8: using guessed type int dword_859B5E8;
// 859B5F0: using guessed type int dword_859B5F0;
// 859B5F4: using guessed type int dword_859B5F4;
// 859DDE8: using guessed type int dword_859DDE8[];
// 859DDEC: using guessed type int dword_859DDEC[];
// 859DDF0: using guessed type int dword_859DDF0[];
// 859E9E8: using guessed type int dword_859E9E8;
// 859E9EC: using guessed type int dword_859E9EC;
// 859E9FC: using guessed type int dword_859E9FC;
// 859EA00: using guessed type int dword_859EA00;
// 859EA04: using guessed type int dword_859EA04;
// 865261C: using guessed type int dword_865261C;
// 8652620: using guessed type int dword_8652620;
// 8652624: using guessed type int dword_8652624;
// 86655E8: using guessed type __int16 word_86655E8[];
// 8793E00: using guessed type int g_listEntity;
// 8793E50: using guessed type int g_oldVoting;
// 87A22F4: using guessed type __int16 word_87A22F4;
// 8107CA2: using guessed type int var_C[3];
// 8107CA2: using guessed type char s[1028];

//----- (08108090) --------------------------------------------------------
void __cdecl G_TraceCapsule(float *s, float *a2, float *a3, float *a4, float *a5, int a6, int a7)
{
  SV_Trace(s, a2, a3, a4, a5, a6, a7, 0, 0, 0);
}

//----- (081080E6) --------------------------------------------------------
int __cdecl G_TraceCapsuleComplete(float *a1, float *a2, float *a3, float *a4, int a5, int a6)
{
  return SV_TracePassed(a1, a2, a3, a4, a5, 1023, a6, 0, 0);
}

//----- (08108134) --------------------------------------------------------
void __cdecl G_LocationalTrace(float *s, float *a2, float *a3, int a4, int a5, int a6)
{
  SV_Trace(s, a2, flt_8145E68, flt_8145E68, a3, a4, a5, 1, a6, 1);
}
// 8145E68: using guessed type float flt_8145E68[3];

//----- (0810818A) --------------------------------------------------------
int __cdecl G_LocationalTracePassed(float *a1, float *a2, int a3, int a4)
{
  return SV_TracePassed(a1, flt_8145E68, flt_8145E68, a2, a3, 1023, a4, 1, 1);
}
// 8145E68: using guessed type float flt_8145E68[3];

//----- (081081DA) --------------------------------------------------------
int *__cdecl G_SightTrace(int *a1, float *a2, float *a3, int a4, int a5)
{
  return SV_SightTrace(a1, a2, flt_8145E68, flt_8145E68, a3, a4, 1023, a5);
}
// 8145E68: using guessed type float flt_8145E68[3];

//----- (08108222) --------------------------------------------------------
void G_AddDebugString()
{
  ;
}

//----- (08108228) --------------------------------------------------------
int __usercall sub_8108228@<eax>(long double a1@<st0>, int *s)
{
  return G_FreeEntity(a1, s);
}

//----- (0810823C) --------------------------------------------------------
int __cdecl sub_810823C(_DWORD *a1)
{
  return sub_811CF36(a1, a1 + 78);
}

//----- (0810825C) --------------------------------------------------------
int __usercall sub_810825C@<eax>(long double a1@<st0>, int *s)
{
  return G_FreeEntity(a1, s);
}

//----- (08108270) --------------------------------------------------------
int __cdecl sub_8108270(int a1, _DWORD *a2, _DWORD *a3)
{
  long double v3; // fst7
  int result; // eax
  int v5; // [esp+14h] [ebp-4h]

  v5 = *(unsigned __int8 *)(a1 + 240);
  SV_UnlinkEntity(a1);
  sub_810A912(a2, (_DWORD *)(*(_DWORD *)(a1 + 344) + 20));
  v3 = *(float *)(*(_DWORD *)(a1 + 344) + 28) + 1.0;
  *(float *)(*(_DWORD *)(a1 + 344) + 28) = v3;
  *(_DWORD *)(*(_DWORD *)(a1 + 344) + 160) ^= 2u;
  sub_80F5E80(v3, a1, a3);
  sub_80DD59E(*(_DWORD *)(a1 + 344), a1, 1, 1u);
  result = sub_810A912((_DWORD *)(*(_DWORD *)(a1 + 344) + 20), (_DWORD *)(a1 + 312));
  if ( v5 )
    return SV_LinkEntity(a1);
  return result;
}

//----- (08108354) --------------------------------------------------------
int __usercall sub_8108354@<eax>(long double a1@<st0>, int *s)
{
  return G_FreeEntity(a1, s);
}

//----- (08108368) --------------------------------------------------------
int __cdecl sub_8108368(int a1)
{
  if ( *(_BYTE *)(a1 + 240) )
    return SV_UnlinkEntity(a1);
  *(_BYTE *)(a1 + 354) = 0;
  return SV_LinkEntity(a1);
}

//----- (0810839E) --------------------------------------------------------
int __usercall sub_810839E@<eax>(long double a1@<st0>, int *s)
{
  return G_FreeEntity(a1, s);
}

//----- (081083B2) --------------------------------------------------------
int *sub_81083B2()
{
  int *result; // eax
  int i; // [esp+0h] [ebp-4h] BYREF

  for ( i = 0; i <= 31; ++i )
  {
    dword_8793E60[17 * i] = 0;
    result = &i;
  }
  return result;
}
// 8793E60: using guessed type int dword_8793E60[552];

//----- (081083E8) --------------------------------------------------------
float *__cdecl sub_81083E8(int a1, int a2, int a3)
{
  int v3; // eax
  float v5; // [esp+2Ch] [ebp-5Ch]
  float v6[4]; // [esp+30h] [ebp-58h] BYREF
  int v7[4]; // [esp+40h] [ebp-48h] BYREF
  float v8[9]; // [esp+50h] [ebp-38h] BYREF
  float v9; // [esp+74h] [ebp-14h] BYREF

  if ( !sub_811C0B2(a1, (unsigned __int16)word_87A232C, v8) )
  {
    v3 = SL_ConvertToString(*(unsigned __int16 *)(a1 + 360));
    Com_Error(1, (char *)&byte_8153AE0, "tag_flash", *(_DWORD *)a1, v3);
  }
  sub_80F61BE(a2, (float *)v7);
  sub_80F63A0(a2, a3, (float *)(a3 + 12), (float *)(a3 + 24));
  sub_810A912((_DWORD *)a3, (_DWORD *)(a3 + 48));
  sub_810A986(&v9, (float *)v7, v6);
  v5 = Vec3Normalize(v6);
  return sub_810A9CA((float *)v7, v5, (float *)a3, (float *)(a3 + 36));
}
// 87A232C: using guessed type __int16 word_87A232C;
// 81083E8: using guessed type float var_38[9];
// 81083E8: using guessed type float var_58[4];

//----- (081084EA) --------------------------------------------------------
int __cdecl sub_81084EA(int a1, int *a2)
{
  int *v3; // [esp+24h] [ebp-54h]
  int v4[15]; // [esp+30h] [ebp-48h] BYREF
  int v5; // [esp+6Ch] [ebp-Ch]

  if ( a2 == (int *)&unk_86F1250 )
    v3 = &dword_86F1020;
  else
    v3 = a2;
  sub_81083E8(a1, (int)v3, (int)v4);
  v5 = BG_WeaponDefs(*(_DWORD *)(a1 + 200));
  if ( *(_DWORD *)(v5 + 120) )
    sub_811E18A((float *)a1, 0.0, (int)v4);
  else
    sub_811DFF4(v3, *(float *)(*(_DWORD *)(a1 + 348) + 56), (int)v4, (int *)a1, dword_859B5EC);
  return G_AddEvent((_DWORD *)a1, 175, *v3);
}
// 86F1020: using guessed type int dword_86F1020;

//----- (081085B8) --------------------------------------------------------
void __cdecl sub_81085B8(int a1, int a2)
{
  char *v2; // eax
  char *v3; // eax
  long double v4; // fst7
  long double v5; // fst7
  long double v6; // fst7
  long double v7; // fst7
  long double v8; // fst7
  long double v9; // fst7
  long double v10; // fst7
  float v11; // [esp+0h] [ebp-208h]
  float v12; // [esp+0h] [ebp-208h]
  float v13; // [esp+0h] [ebp-208h]
  float v14; // [esp+0h] [ebp-208h]
  float v15; // [esp+0h] [ebp-208h]
  float v16; // [esp+0h] [ebp-208h]
  float v17; // [esp+0h] [ebp-208h]
  float v18; // [esp+8h] [ebp-200h]
  float v19; // [esp+8h] [ebp-200h]
  float v20; // [esp+8h] [ebp-200h]
  float v21; // [esp+8h] [ebp-200h]
  int v22; // [esp+20h] [ebp-1E8h]
  int v23; // [esp+24h] [ebp-1E4h]
  int v24; // [esp+28h] [ebp-1E0h]
  int v25; // [esp+2Ch] [ebp-1DCh]
  int v26; // [esp+30h] [ebp-1D8h]
  int v27; // [esp+34h] [ebp-1D4h]
  int v28; // [esp+38h] [ebp-1D0h]
  int v29[4]; // [esp+40h] [ebp-1C8h] BYREF
  float s[12]; // [esp+50h] [ebp-1B8h] BYREF
  int v31[2]; // [esp+80h] [ebp-188h] BYREF
  float v32; // [esp+88h] [ebp-180h]
  int v33[2]; // [esp+90h] [ebp-178h] BYREF
  float v34; // [esp+98h] [ebp-170h]
  float v35[5]; // [esp+A0h] [ebp-168h] BYREF
  int v36; // [esp+B4h] [ebp-154h]
  int v37; // [esp+B8h] [ebp-150h]
  int v38; // [esp+BCh] [ebp-14Ch]
  int v39; // [esp+C0h] [ebp-148h]
  int v40; // [esp+C4h] [ebp-144h]
  int v41; // [esp+C8h] [ebp-140h]
  float *v42; // [esp+CCh] [ebp-13Ch]
  float v43[12]; // [esp+D0h] [ebp-138h] BYREF
  float v44[9]; // [esp+100h] [ebp-108h] BYREF
  int v45[3]; // [esp+124h] [ebp-E4h] BYREF
  int v46[9]; // [esp+130h] [ebp-D8h] BYREF
  float v47[6]; // [esp+154h] [ebp-B4h] BYREF
  float v48; // [esp+16Ch] [ebp-9Ch]
  float v49[6]; // [esp+170h] [ebp-98h] BYREF
  float v50; // [esp+188h] [ebp-80h] BYREF
  float v51[3]; // [esp+194h] [ebp-74h] BYREF
  int v52[2]; // [esp+1A0h] [ebp-68h] BYREF
  float v53; // [esp+1A8h] [ebp-60h]
  float v54[3]; // [esp+1B0h] [ebp-58h] BYREF
  float v55; // [esp+1BCh] [ebp-4Ch]
  float v56; // [esp+1C0h] [ebp-48h]
  float v57; // [esp+1C4h] [ebp-44h]
  float v58; // [esp+1C8h] [ebp-40h]
  float v59; // [esp+1CCh] [ebp-3Ch]
  float v60; // [esp+1D0h] [ebp-38h]
  float v61; // [esp+1D4h] [ebp-34h]
  float v62; // [esp+1D8h] [ebp-30h]
  int v63; // [esp+1DCh] [ebp-2Ch]
  int v64; // [esp+1E0h] [ebp-28h]
  int v65; // [esp+1E4h] [ebp-24h]
  int v66; // [esp+1E8h] [ebp-20h]
  int v67; // [esp+1ECh] [ebp-1Ch]
  int v68; // [esp+1F0h] [ebp-18h]
  int v69; // [esp+1F4h] [ebp-14h]
  int v70; // [esp+1F8h] [ebp-10h]
  int v71; // [esp+1FCh] [ebp-Ch]

  v70 = *(_DWORD *)(a1 + 144);
  v65 = 1208 * v70 + 140846652;
  v64 = 1208 * v70 + 140847548;
  if ( *((_DWORD *)&unk_86529CC + 302 * v70)
    && *(_DWORD *)(v64 + 20)
    && (*(_DWORD *)(*(_DWORD *)(v64 + 20) + 80) & 4) != 0 )
  {
    v42 = (float *)sub_811C056((int *)a2, (unsigned __int16)word_87A2338);
    if ( v42 )
    {
      v63 = BG_WeaponDefs(*(_DWORD *)(a2 + 200));
      v41 = *(_DWORD *)(v65 + 1188);
      v40 = dword_86525F4;
      v39 = *(_DWORD *)(v64 + 16) & 0xFFFFFDFF;
      sub_80A913C(v42, v43);
      v62 = sub_80A2A84(v43);
      sub_80A7146((float *)(a2 + 324), (int)v49);
      sub_810A912((_DWORD *)(a2 + 312), v51);
      sub_810A986((float *)(a1 + 312), v51, v35);
      v48 = sub_810AA1E(v35, &v50);
      v61 = v48 - v42[6];
      sub_80BF482((_DWORD *)v41, v39, 0.0);
      v69 = sub_80BE8E4(v40, v39);
      v60 = 0.0;
      v59 = 0.0;
      v67 = 0;
      v37 = 0;
      if ( !v69 )
      {
        v2 = sub_80BE94C(v40, v39);
        Com_Error(1, (char *)&byte_8153B80, v2);
      }
      v71 = 0;
      do
      {
        v36 = sub_80BE8F4(v40, v39, v71);
        sub_80C0354((_DWORD *)v41, v36, 1.0, 1065353216, 1065353216, 0, 0, 0);
        v68 = sub_80BE8E4(v40, v36);
        if ( !v68 )
        {
          v3 = sub_80BE94C(v40, v36);
          Com_Error(1, (char *)&byte_8153B80, v3);
        }
        v57 = (long double)v68 * 0.5 - v62 / *(float *)(v63 + 1380);
        if ( v57 >= 0.0 )
        {
          if ( v57 >= (long double)(v68 - 1) )
            v57 = (float)(v68 - 1);
        }
        else
        {
          v57 = 0.0;
        }
        v66 = (int)v57;
        v57 = v57 - (long double)v66;
        v38 = sub_80BE8F4(v40, v36, v66);
        v18 = 1.0 - v57;
        sub_80C0354((_DWORD *)v41, v38, v18, 1065353216, 1065353216, 0, 0, 0);
        if ( v57 != 0.0 )
        {
          v37 = sub_80BE8F4(v40, v36, v66 + 1);
          sub_80C0354((_DWORD *)v41, v37, v57, 1065353216, 1065353216, 0, 0, 0);
        }
        sub_80BEFE2(v41, v36, v54, v52);
        if ( v53 >= (long double)v61 )
          break;
        v60 = v53;
        v67 = v66;
        v59 = v57;
        ++v71;
      }
      while ( v71 < v69 );
      sub_80BF482((_DWORD *)v41, v39, 0.0);
      v4 = sub_80BE816(v41, v38);
      v11 = v4 - (1.0 - v57);
      v56 = sub_810A840(v11) * (1000.0 / (long double)dword_859B5F4);
      if ( v56 <= 0.0 )
        *(float *)&v28 = 0.0;
      else
        *(float *)&v28 = 1.0 / v56;
      v19 = 1.0 - v57;
      sub_80C0354((_DWORD *)v41, v38, v19, v28, 1065353216, 0, 0, 0);
      if ( v57 != 0.0 )
      {
        v5 = sub_80BE816(v41, v37);
        v12 = v5 - v57;
        v56 = sub_810A840(v12) * (1000.0 / (long double)dword_859B5F4);
        if ( v56 <= 0.0 )
        {
          sub_80C0354((_DWORD *)v41, v37, v57, COERCE_INT(0.0), 1065353216, 0, 0, 0);
        }
        else
        {
          *(float *)&v27 = 1.0 / v56;
          sub_80C0354((_DWORD *)v41, v37, v57, v27, 1065353216, 0, 0, 0);
        }
      }
      if ( v71 && v71 != v69 )
      {
        v55 = (v61 - v60) / (v53 - v60);
        v6 = sub_80BE816(v41, v36);
        v14 = v6 - v55;
        v56 = sub_810A840(v14) * (1000.0 / (long double)dword_859B5F4);
        if ( v56 <= 0.0 )
        {
          sub_80C0354((_DWORD *)v41, v36, v55, COERCE_INT(0.0), 1065353216, 0, 0, 0);
        }
        else
        {
          *(float *)&v25 = 1.0 / v56;
          sub_80C0354((_DWORD *)v41, v36, v55, v25, 1065353216, 0, 0, 0);
        }
        v36 = sub_80BE8F4(v40, v39, v71 - 1);
        v7 = sub_80BE816(v41, v36);
        v15 = v7 - (1.0 - v55);
        v56 = sub_810A840(v15) * (1000.0 / (long double)dword_859B5F4);
        if ( v56 <= 0.0 )
          *(float *)&v24 = 0.0;
        else
          *(float *)&v24 = 1.0 / v56;
        v20 = 1.0 - v55;
        sub_80C0354((_DWORD *)v41, v36, v20, v24, 1065353216, 0, 0, 0);
        v38 = sub_80BE8F4(v40, v36, v67);
        v8 = sub_80BE816(v41, v38);
        v16 = v8 - (1.0 - v59);
        v56 = sub_810A840(v16) * (1000.0 / (long double)dword_859B5F4);
        if ( v56 <= 0.0 )
          *(float *)&v23 = 0.0;
        else
          *(float *)&v23 = 1.0 / v56;
        v21 = 1.0 - v59;
        sub_80C0354((_DWORD *)v41, v38, v21, v23, 1065353216, 0, 0, 0);
        if ( v59 != 0.0 )
        {
          v37 = sub_80BE8F4(v40, v36, v67 + 1);
          v9 = sub_80BE816(v41, v37);
          v17 = v9 - v59;
          v56 = sub_810A840(v17) * (1000.0 / (long double)dword_859B5F4);
          if ( v56 <= 0.0 )
          {
            sub_80C0354((_DWORD *)v41, v37, v59, COERCE_INT(0.0), 1065353216, 0, 0, 0);
          }
          else
          {
            *(float *)&v22 = 1.0 / v56;
            sub_80C0354((_DWORD *)v41, v37, v59, v22, 1065353216, 0, 0, 0);
          }
        }
      }
      else
      {
        v13 = sub_80BE816(v41, v36) - 1.0;
        v56 = sub_810A840(v13) * (1000.0 / (long double)dword_859B5F4);
        if ( v56 <= 0.0 )
        {
          sub_80C0354((_DWORD *)v41, v36, 1.0, COERCE_INT(0.0), 1065353216, 0, 0, 0);
        }
        else
        {
          *(float *)&v26 = 1.0 / v56;
          sub_80C0354((_DWORD *)v41, v36, 1.0, v26, 1065353216, 0, 0, 0);
        }
      }
      sub_80BEFE2(v41, v39, v54, v52);
      sub_80A530C((float *)v52, v62);
      sub_810A898((float *)v52, v42 + 4, v47);
      v47[2] = v48;
      v10 = sub_80A5774(v54);
      v58 = v10 + v62;
      sub_80A718E(v58, (int)v46);
      sub_80A3C8E((float *)v46, v49, v44);
      sub_810A912(v45, (_DWORD *)(*(_DWORD *)(a1 + 344) + 20));
      sub_810A912((_DWORD *)(*(_DWORD *)(a1 + 344) + 20), v33);
      sub_810A912((_DWORD *)(*(_DWORD *)(a1 + 344) + 20), v31);
      v34 = v34 + *(float *)(*(_DWORD *)(a1 + 344) + 248);
      v32 = v32 - 60.0;
      G_TraceCapsule(s, (float *)v33, flt_8145E68, flt_8145E68, (float *)v31, *(_DWORD *)a1, 42008593);
      if ( s[0] < 1.0 )
      {
        sub_80DEB7A((float *)v33, (float *)v31, s[0], (float *)v29);
        *(_DWORD *)(*(_DWORD *)(a1 + 344) + 28) = v29[2];
      }
      sub_80DD59E(*(_DWORD *)(a1 + 344), a1, 1, 1u);
      sub_810A912((_DWORD *)(*(_DWORD *)(a1 + 344) + 20), (_DWORD *)(a1 + 312));
      sub_80A71F4((int)v44, a1 + 324);
      SV_LinkEntity(a1);
    }
    else
    {
      Com_Printf("WARNING: aborting player positioning on turret since 'tag_weapon' does not exist\n");
    }
  }
}
// 8145E68: using guessed type float flt_8145E68[3];
// 859B5F4: using guessed type int dword_859B5F4;
// 86525F4: using guessed type int dword_86525F4;
// 87A2338: using guessed type __int16 word_87A2338;
// 81085B8: using guessed type float var_138[12];
// 81085B8: using guessed type float var_98[6];
// 81085B8: using guessed type float var_168[5];
// 81085B8: using guessed type float var_58[3];
// 81085B8: using guessed type float var_108[9];
// 81085B8: using guessed type float s[12];
// 81085B8: using guessed type int anonymous_0[3];

//----- (08109236) --------------------------------------------------------
int __cdecl sub_8109236(int a1, int a2)
{
  int result; // eax
  int v3; // [esp+Ch] [ebp-Ch]
  int v4; // [esp+10h] [ebp-8h]

  v4 = *(_DWORD *)(a1 + 348);
  v3 = *(_DWORD *)(a2 + 344);
  *(_DWORD *)(v3 + 1424) = 1;
  *(_DWORD *)(v3 + 1428) = *(_DWORD *)a1;
  *(float *)(a1 + 104) = sub_80A6000(*(float *)(v3 + 232), *(float *)(a1 + 324));
  *(float *)(a1 + 104) = sub_810A85A(*(float *)(a1 + 104), *(float *)(v4 + 12), *(float *)(v4 + 20));
  *(float *)(a1 + 108) = sub_80A6000(*(float *)(v3 + 236), *(float *)(a1 + 328));
  *(float *)(a1 + 108) = sub_810A85A(*(float *)(a1 + 108), *(float *)(v4 + 16), *(float *)(v4 + 24));
  *(_DWORD *)(a1 + 112) = 0;
  result = *(_DWORD *)(v4 + 4) & 0x800;
  if ( result )
  {
    *(_DWORD *)(v4 + 4) &= ~0x800u;
    result = *(_DWORD *)(a1 + 8) ^ 2;
    *(_DWORD *)(a1 + 8) = result;
  }
  return result;
}

//----- (08109348) --------------------------------------------------------
int *__cdecl sub_8109348(int a1, int *a2)
{
  int v2; // ebx
  int *result; // eax

  v2 = *(_DWORD *)(a1 + 348);
  *(_DWORD *)(v2 + 40) = 3 * *(_DWORD *)(BG_WeaponDefs(*(_DWORD *)(a1 + 200)) + 516);
  result = a2;
  if ( a2[86] )
  {
    sub_81084EA(a1, a2);
    result = (int *)a2[86];
    result[356] = 2;
  }
  return result;
}

//----- (081093B8) --------------------------------------------------------
int __cdecl sub_81093B8(_DWORD *a1, int *a2)
{
  int result; // eax
  int v3; // [esp+10h] [ebp-8h]
  int v4; // [esp+14h] [ebp-4h]

  v4 = a1[87];
  sub_8109236((int)a1, (int)a2);
  sub_81085B8((int)a2, (int)a1);
  v3 = BG_WeaponDefs(a1[50]);
  *(_DWORD *)(a2[86] + 1424) = 1;
  a1[2] &= ~0x40u;
  *(_DWORD *)(v4 + 8) -= 50;
  result = v4;
  if ( *(int *)(v4 + 8) <= 0 )
  {
    *(_DWORD *)(v4 + 8) = 0;
    result = *(_DWORD *)(a2[86] + 10172) & 1;
    if ( (_BYTE)result )
    {
      *(_DWORD *)(v4 + 8) = *(_DWORD *)(v3 + 516);
      sub_8109348((int)a1, a2);
      result = a1[2] | 0x40;
      a1[2] = result;
    }
  }
  return result;
}

//----- (0810948E) --------------------------------------------------------
int __cdecl sub_810948E(_DWORD *a1)
{
  int result; // eax
  int v2; // [esp+14h] [ebp-4h]

  v2 = a1[87];
  a1[33] = 0;
  result = v2;
  if ( *(int *)(v2 + 40) > 0 )
  {
    a1[33] = *(unsigned __int8 *)(v2 + 64);
    *(_DWORD *)(v2 + 40) -= 50;
    result = v2;
    if ( *(int *)(v2 + 40) <= 0 )
    {
      result = v2;
      if ( *(_BYTE *)(v2 + 66) )
      {
        a1[33] = 0;
        return sub_811CE9E(a1, *(unsigned __int8 *)(v2 + 66));
      }
    }
  }
  return result;
}

//----- (0810950C) --------------------------------------------------------
unsigned int __cdecl sub_810950C(int a1)
{
  unsigned int result; // eax
  _DWORD *v2; // [esp+10h] [ebp-8h]
  char *v3; // [esp+14h] [ebp-4h]

  v2 = *(_DWORD **)(a1 + 348);
  v3 = (char *)&unk_8665480 + 560 * *(_DWORD *)(a1 + 336);
  v2[10] = 0;
  *(_DWORD *)(a1 + 132) = 0;
  if ( v2[9] != -1 )
  {
    if ( v2[9] == 2 )
    {
      G_AddEvent(v3, 142, 0);
    }
    else if ( v2[9] == 1 )
    {
      G_AddEvent(v3, 141, 0);
    }
    else
    {
      G_AddEvent(v3, 140, 0);
    }
    v2[9] = -1;
  }
  sub_8108270((int)v3, v2 + 11, (_DWORD *)v3 + 81);
  *(_DWORD *)(*((_DWORD *)v3 + 86) + 160) &= 0xFFFFFCFF;
  *(_DWORD *)(*((_DWORD *)v3 + 86) + 1424) = 0;
  *(_DWORD *)(*((_DWORD *)v3 + 86) + 1428) = 1023;
  v3[354] = 0;
  *((_DWORD *)v3 + 29) = 0;
  *(_BYTE *)(a1 + 354) = 0;
  *(_DWORD *)(a1 + 336) = 1023;
  result = v2[1] & 0xFFFFF7FF;
  v2[1] = result;
  return result;
}

//----- (08109672) --------------------------------------------------------
int __cdecl sub_8109672(_DWORD *a1)
{
  char *v2; // [esp+14h] [ebp-4h]

  v2 = (char *)&unk_8665480 + 560 * a1[84];
  if ( v2[354] != 1 || *(_DWORD *)(*((_DWORD *)v2 + 86) + 9896) )
    return sub_810950C((int)a1);
  sub_81093B8(a1, (int *)v2);
  return sub_810948E(a1);
}

//----- (081096DE) --------------------------------------------------------
int __cdecl sub_81096DE(int a1, int a2, int a3)
{
  long double v3; // fst7
  float v5; // [esp+1Ch] [ebp-2Ch]
  float v6; // [esp+20h] [ebp-28h]
  int v7; // [esp+24h] [ebp-24h]
  int v8; // [esp+28h] [ebp-20h]
  float v9; // [esp+2Ch] [ebp-1Ch]
  float v10; // [esp+2Ch] [ebp-1Ch]
  float v11; // [esp+30h] [ebp-18h]
  int v12; // [esp+34h] [ebp-14h]
  int i; // [esp+3Ch] [ebp-Ch]

  v8 = *(_DWORD *)(a1 + 348);
  v7 = 1;
  v6 = *(float *)(a1 + 104);
  *(float *)(a1 + 104) = v6 + *(float *)(a1 + 112);
  if ( a3 )
  {
    v11 = *(float *)(BG_WeaponDefs(*(_DWORD *)(a1 + 200)) + 1356);
    v12 = *(_DWORD *)(BG_WeaponDefs(*(_DWORD *)(a1 + 200)) + 1360);
  }
  else
  {
    v11 = 200.0;
    v12 = 1128792064;
  }
  if ( (*(_DWORD *)(v8 + 4) & 0x200) != 0 && (*(_DWORD *)(v8 + 4) & 0x100) != 0 && v11 < 360.0 )
    v11 = 360.0;
  for ( i = 0; i <= 1; ++i )
  {
    *(&v11 + i) = *(&v11 + i) * 0.050000001;
    v9 = sub_80A6000(*(float *)(a2 + 4 * i), *(float *)(a1 + 4 * i + 104));
    if ( v9 <= (long double)*(&v11 + i) )
    {
      if ( -*(&v11 + i) > (long double)v9 )
      {
        v7 = 0;
        LODWORD(v9) = *((_DWORD *)&v11 + i) ^ 0x80000000;
      }
    }
    else
    {
      v7 = 0;
      v9 = *(&v11 + i);
    }
    *(float *)(a1 + 4 * i + 104) = *(float *)(a1 + 4 * i + 104) + v9;
  }
  v5 = *(float *)(a1 + 104);
  *(float *)(a1 + 112) = v5;
  if ( (*(_DWORD *)(v8 + 4) & 0x200) != 0 )
  {
    if ( (*(_DWORD *)(v8 + 4) & 0x400) != 0 )
    {
      if ( *(float *)(v8 + 60) > (long double)*(float *)(a1 + 104) )
        goto LABEL_18;
      *(_DWORD *)(v8 + 4) &= ~0x100u;
    }
    else
    {
      if ( *(float *)(a1 + 104) > (long double)*(float *)(v8 + 60) )
      {
LABEL_18:
        v3 = sub_80A6000(*(float *)(v8 + 60), v6);
        goto LABEL_23;
      }
      *(_DWORD *)(v8 + 4) &= ~0x100u;
    }
  }
  v3 = sub_80A6000(v5, v6);
LABEL_23:
  v10 = v3;
  if ( v10 <= (long double)v11 )
  {
    if ( -v11 > (long double)v10 )
    {
      v7 = 0;
      LODWORD(v10) = LODWORD(v11) ^ 0x80000000;
    }
  }
  else
  {
    v7 = 0;
    v10 = v11;
  }
  *(float *)(a1 + 104) = v6 + v10;
  *(float *)(a1 + 112) = *(float *)(a1 + 112) - *(float *)(a1 + 104);
  return v7;
}

//----- (08109984) --------------------------------------------------------
int __cdecl sub_8109984(int a1, int a2)
{
  float v3; // [esp+14h] [ebp-14h]
  float v4[3]; // [esp+18h] [ebp-10h] BYREF
  int v5; // [esp+24h] [ebp-4h]

  v5 = *(_DWORD *)(a1 + 348);
  if ( a2 )
    v3 = 0.0;
  else
    v3 = *(float *)(v5 + 28);
  v4[0] = v3;
  v4[1] = 0.0;
  return sub_81096DE(a1, (int)v4, a2);
}

//----- (081099D6) --------------------------------------------------------
char *__cdecl sub_81099D6(_DWORD *a1)
{
  char *result; // eax

  a1[100] = dword_859B5EC + 50;
  if ( a1[130] )
    sub_811BE86(a1);
  result = (char *)&unk_8665480 + 560 * a1[84];
  if ( !*((_DWORD *)result + 86) )
  {
    sub_810948E(a1);
    a1[2] &= ~0x40u;
    return (char *)sub_8109984((int)a1, 0);
  }
  return result;
}

//----- (08109A68) --------------------------------------------------------
int __cdecl sub_8109A68(int a1)
{
  int result; // eax
  int i; // [esp+2Ch] [ebp-FCh] BYREF
  float s[12]; // [esp+30h] [ebp-F8h] BYREF
  int v4[4]; // [esp+60h] [ebp-C8h] BYREF
  int v5[4]; // [esp+70h] [ebp-B8h] BYREF
  float v6[4]; // [esp+80h] [ebp-A8h] BYREF
  float v7[4]; // [esp+90h] [ebp-98h] BYREF
  float v8[4]; // [esp+A0h] [ebp-88h] BYREF
  float v9[12]; // [esp+B0h] [ebp-78h] BYREF
  float v10[9]; // [esp+E0h] [ebp-48h] BYREF
  int v11[3]; // [esp+104h] [ebp-24h] BYREF
  int v12; // [esp+110h] [ebp-18h]
  int v13; // [esp+114h] [ebp-14h]
  int v14; // [esp+118h] [ebp-10h]
  int v15; // [esp+11Ch] [ebp-Ch]

  v15 = 30;
  v14 = *(_DWORD *)(a1 + 348);
  *(_BYTE *)(a1 + 358) = 14;
  *(_DWORD *)(a1 + 400) = dword_859B5EC + 50;
  result = sub_811C056((int *)a1, (unsigned __int16)word_87A233E);
  v13 = result;
  if ( result )
  {
    result = sub_811C056((int *)a1, (unsigned __int16)word_87A2344);
    v12 = result;
    if ( result )
    {
      sub_80A7146((float *)(a1 + 324), (int)v10);
      sub_810A912((_DWORD *)(a1 + 312), v11);
      sub_810A986((float *)(v12 + 16), (float *)(v13 + 16), v7);
      result = (int)sub_80A50D2((float *)(v13 + 16), v10, (float *)v5);
      for ( i = 0; i <= 30; ++i )
      {
        v8[0] = (long double)i * -3.0;
        v8[1] = 0.0;
        v8[2] = 0.0;
        sub_80A7146(v8, (int)v9);
        sub_80A4E52(v7, v9, v6);
        sub_810A942((float *)(v13 + 16), v6, v6);
        sub_80A50D2(v6, v10, (float *)v4);
        G_LocationalTrace(s, (float *)v5, (float *)v4, *(_DWORD *)a1, 2065, (int)&unk_816778C);
        if ( s[0] < 1.0 )
        {
          result = LODWORD(v8[0]);
          *(float *)(v14 + 28) = v8[0];
          return result;
        }
        result = (int)&i;
      }
    }
  }
  return result;
}
// 87A233E: using guessed type __int16 word_87A233E;
// 87A2344: using guessed type __int16 word_87A2344;
// 8109A68: using guessed type float var_48[9];
// 8109A68: using guessed type float var_98[4];
// 8109A68: using guessed type float var_78[12];
// 8109A68: using guessed type float var_A8[4];
// 8109A68: using guessed type float s[12];
// 8109A68: using guessed type int anonymous_0[3];

//----- (08109C76) --------------------------------------------------------
int __cdecl sub_8109C76(int *a1, int a2)
{
  int v3; // [esp+1Ch] [ebp-1Ch]
  int v4; // [esp+20h] [ebp-18h] BYREF
  int v5; // [esp+24h] [ebp-14h]
  int v6; // [esp+28h] [ebp-10h]

  v5 = a1[27];
  v4 = a1[26];
  v6 = 0;
  v3 = Com_GetServerDObj(*a1);
  sub_80B98CC(v3, a2, (unsigned __int16)word_87A233E, (float *)&v4);
  sub_80B98CC(v3, a2, (unsigned __int16)word_87A2340, (float *)&v4);
  v4 = a1[28];
  v5 = 0;
  return sub_80B98CC(v3, a2, (unsigned __int16)word_87A232C, (float *)&v4);
}
// 87A232C: using guessed type __int16 word_87A232C;
// 87A233E: using guessed type __int16 word_87A233E;
// 87A2340: using guessed type __int16 word_87A2340;

//----- (08109D26) --------------------------------------------------------
_BOOL4 __cdecl sub_8109D26(int a1, int a2)
{
  float v3; // [esp+0h] [ebp-68h]
  float v4; // [esp+0h] [ebp-68h]
  float v5; // [esp+10h] [ebp-58h]
  float v6; // [esp+1Ch] [ebp-4Ch]
  float v7; // [esp+20h] [ebp-48h]
  float v8; // [esp+24h] [ebp-44h]
  float v9; // [esp+28h] [ebp-40h]
  float v10; // [esp+2Ch] [ebp-3Ch]
  int v11[4]; // [esp+30h] [ebp-38h] BYREF
  float v12[7]; // [esp+40h] [ebp-28h] BYREF
  int v13; // [esp+5Ch] [ebp-Ch]

  v13 = *(_DWORD *)(a1 + 348);
  v10 = *(float *)(a1 + 328) + *(float *)(v13 + 16);
  v5 = sub_810A840(*(float *)(v13 + 16));
  v9 = (sub_810A840(*(float *)(v13 + 24)) + v5) * 0.5;
  v3 = v10 + v9;
  v8 = sub_80A6112(v3);
  sub_80A303A(v8, v11, 0);
  Vec3Normalize((float *)v11);
  sub_810A986((float *)(a1 + 312), (float *)(a2 + 312), v12);
  v12[2] = 0.0;
  Vec3Normalize(v12);
  v7 = sub_810AA1E((float *)v11, v12);
  v4 = sub_810A85A(v7, -1.0, 1.0);
  v6 = sub_80A1B68(v4) * 57.29577951308232;
  return v6 <= (long double)v9;
}

//----- (08109E54) --------------------------------------------------------
int __cdecl sub_8109E54(int a1)
{
  int result; // eax

  if ( *((_DWORD *)&unk_8665480 + 140 * *(_DWORD *)(a1 + 336) + 86) )
    sub_810950C(a1);
  *(_BYTE *)(a1 + 354) = 0;
  **(_DWORD **)(a1 + 348) = 0;
  result = a1;
  *(_DWORD *)(a1 + 348) = 0;
  return result;
}

//----- (08109EC0) --------------------------------------------------------
_BOOL4 __cdecl sub_8109EC0(int a1, int a2)
{
  if ( *(_BYTE *)(a1 + 354) || !*(_DWORD *)(a1 + 348) )
    return 0;
  if ( !sub_8109D26(a1, a2) )
    return 0;
  if ( *(_DWORD *)(*(_DWORD *)(a2 + 344) + 60) )
    return 0;
  return *(_DWORD *)(*(_DWORD *)(a2 + 344) + 96) != 1023;
}

//----- (08109F46) --------------------------------------------------------
void __cdecl sub_8109F46(int a1, int a2)
{
  float v2; // [esp+0h] [ebp-18h]
  float v3; // [esp+0h] [ebp-18h]
  int v4; // [esp+Ch] [ebp-Ch]
  int v5; // [esp+10h] [ebp-8h]

  v5 = *(_DWORD *)(a1 + 348);
  v4 = *(_DWORD *)(a2 + 344);
  *(_BYTE *)(a2 + 354) = 1;
  *(_BYTE *)(a1 + 354) = 1;
  *(_DWORD *)(a1 + 336) = *(_DWORD *)a2;
  *(_DWORD *)(v4 + 1424) = 1;
  *(_DWORD *)(v4 + 1428) = *(_DWORD *)a1;
  *(_DWORD *)(v5 + 4) |= 0x800u;
  sub_810A912((_DWORD *)(a2 + 312), (_DWORD *)(v5 + 44));
  *(_DWORD *)(a2 + 116) = *(_DWORD *)a1;
  *(_DWORD *)(a1 + 116) = *(_DWORD *)a2;
  if ( (*(_BYTE *)(v4 + 12) & 1) != 0 )
    *(_DWORD *)(v5 + 36) = 2;
  else
    *(_DWORD *)(v5 + 36) = (*(_DWORD *)(v4 + 12) & 2) != 0;
  if ( *(_DWORD *)(v5 + 32) == 2 )
  {
    *(_DWORD *)(v4 + 160) |= 0x100u;
    *(_DWORD *)(v4 + 160) &= ~0x200u;
  }
  else if ( *(_DWORD *)(v5 + 32) == 1 )
  {
    *(_DWORD *)(v4 + 160) |= 0x200u;
    *(_DWORD *)(v4 + 160) &= ~0x100u;
  }
  else
  {
    *(_DWORD *)(v4 + 160) |= 0x300u;
  }
  *(float *)(a1 + 104) = sub_80A6000(*(float *)(v4 + 232), *(float *)(a1 + 324));
  *(float *)(a1 + 104) = sub_810A85A(*(float *)(a1 + 104), *(float *)(v5 + 12), *(float *)(v5 + 20));
  *(float *)(a1 + 108) = sub_80A6000(*(float *)(v4 + 236), *(float *)(a1 + 328));
  *(float *)(a1 + 108) = sub_810A85A(*(float *)(a1 + 108), *(float *)(v5 + 16), *(float *)(v5 + 24));
  *(_DWORD *)(a1 + 112) = 0;
  *(float *)(v4 + 276) = sub_80A6000(*(float *)(v5 + 20), *(float *)(v5 + 12)) * 0.5;
  *(float *)(v4 + 268) = *(float *)(a1 + 324) + *(float *)(v5 + 20);
  v2 = *(float *)(v4 + 268) - *(float *)(v4 + 276);
  *(float *)(v4 + 268) = sub_80A6154(v2);
  *(float *)(v4 + 280) = sub_80A6000(*(float *)(v5 + 24), *(float *)(v5 + 16)) * 0.5;
  *(float *)(v4 + 272) = *(float *)(a1 + 328) + *(float *)(v5 + 24);
  v3 = *(float *)(v4 + 272) - *(float *)(v4 + 280);
  *(float *)(v4 + 272) = sub_80A6154(v3);
}

//----- (0810A21A) --------------------------------------------------------
int __cdecl G_SpawnTurret(int a1, char *s1)
{
  char *v2; // eax
  char *v3; // eax
  long double v4; // fst7
  int i; // [esp+18h] [ebp-10h]
  int *s; // [esp+1Ch] [ebp-Ch]
  int v8; // [esp+20h] [ebp-8h]

  s = 0;
  for ( i = 0; i <= 31; ++i )
  {
    s = &dword_8793E60[17 * i];
    if ( !*s )
      break;
  }
  if ( i == 32 )
    Com_Error(1, (char *)&byte_8153BE0, 32);
  memset(s, 0, 0x44u);
  *(_DWORD *)(a1 + 348) = s;
  *s = 1;
  *(_DWORD *)(a1 + 200) = G_GetWeaponIndexForName(s1);
  if ( !*(_DWORD *)(a1 + 200) )
    Com_Error(1, (char *)&byte_8153C20, s1);
  v8 = BG_WeaponDefs(*(_DWORD *)(a1 + 200));
  if ( *(_DWORD *)(v8 + 124) != 7 )
  {
    v2 = va(
           "G_SpawnTurret: weapon '%s' isn't a turret. This usually indicates that the weapon failed to load.",
           s1);
    Scr_Error((int)v2);
  }
  if ( !dword_859B41C && !IsItemRegistered(*(_DWORD *)(a1 + 200)) )
  {
    v3 = va("turret '%s' not precached", s1);
    Scr_Error((int)v3);
  }
  s[2] = 0;
  s[8] = *(_DWORD *)(v8 + 140);
  s[9] = -1;
  s[10] = 0;
  if ( *(_DWORD *)(v8 + 176) && **(_BYTE **)(v8 + 176) )
    *((_BYTE *)s + 64) = sub_811B1D8(*(char **)(v8 + 176));
  else
    *((_BYTE *)s + 64) = 0;
  if ( *(_DWORD *)(v8 + 180) && **(_BYTE **)(v8 + 180) )
    *((_BYTE *)s + 65) = sub_811B1D8(*(char **)(v8 + 180));
  else
    *((_BYTE *)s + 65) = 0;
  if ( *(_DWORD *)(v8 + 184) && **(_BYTE **)(v8 + 184) )
    *((_BYTE *)s + 66) = sub_811B1D8(*(char **)(v8 + 184));
  else
    *((_BYTE *)s + 66) = 0;
  if ( *(_DWORD *)(v8 + 188) && **(_BYTE **)(v8 + 188) )
    *((_BYTE *)s + 67) = sub_811B1D8(*(char **)(v8 + 188));
  else
    *((_BYTE *)s + 67) = 0;
  if ( !byte_859C748 || !sub_8117F76("rightarc", (int)&unk_8153CDC, (float *)s + 4) )
    s[4] = *(_DWORD *)(v8 + 1324);
  s[4] ^= 0x80000000;
  if ( *((float *)s + 4) > 0.0 )
    s[4] = 0;
  if ( !byte_859C748 || !sub_8117F76("leftarc", (int)&unk_8153CDC, (float *)s + 6) )
    s[6] = *(_DWORD *)(v8 + 1320);
  if ( *((float *)s + 6) < 0.0 )
    s[6] = 0;
  if ( !byte_859C748 || !sub_8117F76("toparc", (int)&unk_8153CDC, (float *)s + 3) )
    s[3] = *(_DWORD *)(v8 + 1328);
  s[3] ^= 0x80000000;
  if ( *((float *)s + 3) > 0.0 )
    s[3] = 0;
  if ( !byte_859C748 || !sub_8117F76("bottomarc", (int)&unk_8153CDC, (float *)s + 5) )
    s[5] = *(_DWORD *)(v8 + 1332);
  if ( *((float *)s + 5) < 0.0 )
    s[5] = 0;
  s[7] = -1028390912;
  if ( !*(_DWORD *)(a1 + 404) )
    *(_DWORD *)(a1 + 404) = 100;
  if ( !byte_859C748 || !sub_8117FB2("damage", (int)"0", (int *)(a1 + 412)) )
    *(_DWORD *)(a1 + 412) = *(_DWORD *)(v8 + 492);
  if ( *(int *)(a1 + 412) < 0 )
    *(_DWORD *)(a1 + 412) = 0;
  if ( !byte_859C748 || !sub_8117F76("playerSpread", (int)"1", (float *)s + 14) )
    s[14] = *(_DWORD *)(v8 + 1344);
  v4 = *((float *)s + 14);
  if ( v4 < 0.0 )
    s[14] = 0;
  s[1] = 3;
  *(_DWORD *)(a1 + 388) = 1;
  *(_DWORD *)(a1 + 284) = 2097156;
  *(_BYTE *)(a1 + 242) = 0;
  *(_DWORD *)(a1 + 4) = 9;
  *(_DWORD *)(a1 + 372) |= 0x1000u;
  sub_811B20E(v4, a1);
  sub_810A8EE((_DWORD *)(a1 + 260), -1040187392, -1040187392, 0);
  sub_810A8EE((_DWORD *)(a1 + 272), 1107296256, 1107296256, 1113587712);
  sub_811CF36((_DWORD *)a1, (_DWORD *)(a1 + 312));
  sub_811CF96((_DWORD *)a1, (_DWORD *)(a1 + 324));
  sub_810A8C4((_DWORD *)(a1 + 104));
  *(_BYTE *)(a1 + 358) = 13;
  *(_DWORD *)(a1 + 400) = dword_859B5EC + 50;
  *(_DWORD *)(a1 + 48) = 3;
  *(_BYTE *)(a1 + 353) = 0;
  return SV_LinkEntity(a1);
}
// 859C748: using guessed type char byte_859C748;
// 8793E60: using guessed type int dword_8793E60[552];

//----- (0810A7F2) --------------------------------------------------------
int __cdecl sub_810A7F2(int a1)
{
  char v2[4]; // [esp+14h] [ebp-4h] BYREF

  if ( !sub_8117F4C("weaponinfo", (int)&unk_8153CDC, v2) )
    Com_Error(1, (char *)&byte_8153D40);
  return G_SpawnTurret(a1, *(char **)v2);
}

//----- (0810A840) --------------------------------------------------------
long double __cdecl sub_810A840(float a1)
{
  return (float)fabs(a1);
}

//----- (0810A85A) --------------------------------------------------------
long double __cdecl sub_810A85A(float a1, float a2, float a3)
{
  float v4; // [esp+0h] [ebp-18h]
  float v5; // [esp+0h] [ebp-18h]
  float v6; // [esp+8h] [ebp-10h]

  v4 = a1 - a3;
  v6 = sub_810AA52(v4, a3, a1);
  v5 = a2 - a1;
  return sub_810AA52(v5, a2, v6);
}

//----- (0810A898) --------------------------------------------------------
float *__cdecl sub_810A898(float *a1, float *a2, float *a3)
{
  float *result; // eax

  *a3 = *a1 + *a2;
  result = a1 + 1;
  a3[1] = a1[1] + a2[1];
  return result;
}

//----- (0810A8C4) --------------------------------------------------------
int __cdecl sub_810A8C4(_DWORD *a1)
{
  int result; // eax

  *a1 = 0;
  a1[1] = 0;
  result = 0;
  a1[2] = 0;
  return result;
}

//----- (0810A8EE) --------------------------------------------------------
int __cdecl sub_810A8EE(_DWORD *a1, int a2, int a3, int a4)
{
  int result; // eax

  *a1 = a2;
  a1[1] = a3;
  result = a4;
  a1[2] = a4;
  return result;
}

//----- (0810A912) --------------------------------------------------------
int __cdecl sub_810A912(_DWORD *a1, _DWORD *a2)
{
  int result; // eax

  *a2 = *a1;
  a2[1] = a1[1];
  result = a1[2];
  a2[2] = result;
  return result;
}

//----- (0810A942) --------------------------------------------------------
float *__cdecl sub_810A942(float *a1, float *a2, float *a3)
{
  float *result; // eax

  *a3 = *a1 + *a2;
  a3[1] = a1[1] + a2[1];
  result = a1 + 2;
  a3[2] = a1[2] + a2[2];
  return result;
}

//----- (0810A986) --------------------------------------------------------
float *__cdecl sub_810A986(float *a1, float *a2, float *a3)
{
  float *result; // eax

  *a3 = *a1 - *a2;
  a3[1] = a1[1] - a2[1];
  result = a1 + 2;
  a3[2] = a1[2] - a2[2];
  return result;
}

//----- (0810A9CA) --------------------------------------------------------
float *__cdecl sub_810A9CA(float *a1, float a2, float *a3, float *a4)
{
  float *result; // eax

  *a4 = a2 * *a3 + *a1;
  a4[1] = a2 * a3[1] + a1[1];
  result = a3 + 2;
  a4[2] = a2 * a3[2] + a1[2];
  return result;
}

//----- (0810AA1E) --------------------------------------------------------
long double __cdecl sub_810AA1E(float *a1, float *a2)
{
  return *a1 * *a2 + a1[1] * a2[1] + a1[2] * a2[2];
}

//----- (0810AA52) --------------------------------------------------------
long double __cdecl sub_810AA52(float a1, float a2, float a3)
{
  if ( a1 < 0.0 )
    return a3;
  return a2;
}

//----- (0810AAB4) --------------------------------------------------------
void __cdecl sub_810AAB4(int a1, float *a2, int a3, int a4)
{
  long double v4; // fst7
  long double v5; // fst7
  float v6; // [esp+0h] [ebp-58h]
  float v7; // [esp+0h] [ebp-58h]
  float v8; // [esp+0h] [ebp-58h]
  float v9; // [esp+1Ch] [ebp-3Ch]
  int v10[4]; // [esp+30h] [ebp-28h] BYREF
  float v11; // [esp+40h] [ebp-18h]
  float v12; // [esp+44h] [ebp-14h]
  float v13; // [esp+48h] [ebp-10h]
  int v14; // [esp+4Ch] [ebp-Ch]

  v14 = dword_859B5F0 + (int)((long double)(dword_859B5EC - dword_859B5F0) * *a2);
  BG_EvaluateTrajectory(a1 + 48, v14, a3);
  sub_810C716((_DWORD *)a3, v10);
  if ( a2[3] <= 0.1 )
  {
    if ( !a4 )
    {
      v8 = (long double)((rand() & 0x7F) - 63) + *(float *)(a1 + 72);
      *(float *)(a1 + 72) = sub_80A60CE(v8);
    }
  }
  else
  {
    sub_80A86CC(*(float *)(a3 + 4), a2 + 1);
    v13 = 0.1;
    v12 = sub_80A6000(0.1, *(float *)a3);
    v11 = sub_810C6D2(v12);
    if ( !a4 )
    {
      sub_810C716((_DWORD *)a3, (_DWORD *)(a1 + 60));
      *(_DWORD *)(a1 + 52) = v14;
      if ( v11 >= 80.0 )
      {
        *(float *)(a1 + 72) = (sub_80A1410() * 0.30000001 + 0.85000002) * *(float *)(a1 + 72);
      }
      else
      {
        v9 = (sub_80A1410() * 0.30000001 + 0.85000002) * *(float *)(a1 + 72);
        *(_DWORD *)(a1 + 72) = LODWORD(v9) ^ 0x80000000;
      }
    }
    *(float *)a3 = sub_80A6112(*(float *)a3);
    if ( a4 || v11 < 45.0 )
    {
      if ( sub_810C6D2(*(float *)a3) <= 90.0 )
      {
        v4 = sub_80A60CE(v13);
      }
      else
      {
        v6 = v13 + 180.0;
        v4 = sub_80A60CE(v6);
      }
      *(float *)a3 = v4;
    }
    else
    {
      if ( v11 >= 80.0 )
      {
        v5 = sub_80A60CE(*(float *)a3);
      }
      else
      {
        v7 = v12 * 0.25 + *(float *)a3;
        v5 = sub_80A60CE(v7);
      }
      *(float *)a3 = v5;
    }
  }
}
// 859B5F0: using guessed type int dword_859B5F0;
// 810AAB4: using guessed type int var_28[4];

//----- (0810AD10) --------------------------------------------------------
_BOOL4 __cdecl sub_810AD10(int a1, int a2)
{
  float v3; // [esp+4h] [ebp-84h]
  int v5; // [esp+2Ch] [ebp-5Ch]
  int v6; // [esp+30h] [ebp-58h]
  float v7; // [esp+38h] [ebp-50h]
  float v8; // [esp+3Ch] [ebp-4Ch]
  float v9; // [esp+3Ch] [ebp-4Ch]
  _DWORD v10[4]; // [esp+40h] [ebp-48h] BYREF
  int v11[2]; // [esp+50h] [ebp-38h] BYREF
  float v12; // [esp+58h] [ebp-30h]
  int v13[7]; // [esp+60h] [ebp-28h] BYREF
  int v14; // [esp+7Ch] [ebp-Ch]

  v14 = BG_WeaponDefs(*(_DWORD *)(a1 + 200));
  v6 = sub_809C18C((float *)(a1 + 312), -1, 32);
  v5 = (*(_DWORD *)(a2 + 16) & 0x1F00000) >> 20;
  sub_80DD224(
    (float *)(a1 + 12),
    dword_859B5F0 + (int)((long double)(dword_859B5EC - dword_859B5F0) * *(float *)a2),
    (int)v13);
  v8 = sub_810C85A((float *)v13, (float *)(a2 + 4));
  v3 = v8 * -2.0;
  sub_810C806((float *)v13, v3, (float *)(a2 + 4), (float *)(a1 + 36));
  if ( *(float *)(a2 + 12) > 0.7 )
    *(_DWORD *)(a1 + 124) = *(unsigned __int16 *)(a2 + 28);
  if ( (*(_DWORD *)(a1 + 8) & 0x1000000) == 0 )
    goto LABEL_10;
  sub_810C88E((float *)v13);
  if ( (float)0.7 > 0.0 && v8 <= 0.0 )
  {
    v9 = v8 / -(float)0.7;
    v7 = (*(float *)(v14 + 4 * v5 + 1020) - *(float *)(v14 + 4 * v5 + 928)) * v9 + *(float *)(v14 + 4 * v5 + 928);
    sub_810C7CE((float *)(a1 + 36), v7, (float *)(a1 + 36));
  }
  if ( *(float *)(a2 + 12) > 0.7 && (sub_810C88E((float *)(a1 + 36)), 0.7 < 20.0) )
  {
    sub_811CF36((_DWORD *)a1, (_DWORD *)(a1 + 312));
    sub_810AAB4(a1, (float *)a2, (int)v10, 1);
    sub_811CF96((_DWORD *)a1, v10);
    return 0;
  }
  else
  {
LABEL_10:
    sub_810C7CE((float *)(a2 + 4), 0.1, (float *)v11);
    if ( v12 > 0.0 )
      v12 = 0.0;
    sub_810C746((float *)(a1 + 312), (float *)v11, (float *)(a1 + 312));
    sub_810C716((_DWORD *)(a1 + 312), (_DWORD *)(a1 + 24));
    *(_DWORD *)(a1 + 16) = dword_859B5EC;
    sub_810AAB4(a1, (float *)a2, (int)v10, 0);
    sub_810C716(v10, (_DWORD *)(a1 + 60));
    *(_DWORD *)(a1 + 52) = dword_859B5EC;
    if ( v6 )
    {
      return 0;
    }
    else
    {
      sub_810C78A((float *)(a1 + 36), (float *)v13, (float *)v13);
      sub_810C88E((float *)v13);
      return (float)0.0 > 100.0;
    }
  }
}
// 859B5F0: using guessed type int dword_859B5F0;
// 810AD10: using guessed type _DWORD var_48[4];

//----- (0810B07A) --------------------------------------------------------
int __usercall sub_810B07A@<eax>(long double a1@<st0>, int a2, int a3, int a4, float *a5)
{
  int result; // eax
  _DWORD *v6; // [esp+4h] [ebp-84h]
  int v7; // [esp+8h] [ebp-80h]
  int v8; // [esp+Ch] [ebp-7Ch]
  float v9; // [esp+Ch] [ebp-7Ch]
  _DWORD *v10; // [esp+10h] [ebp-78h]
  float v11; // [esp+10h] [ebp-78h]
  int v12; // [esp+14h] [ebp-74h]
  float v13; // [esp+14h] [ebp-74h]
  int v14; // [esp+40h] [ebp-48h]
  int v15; // [esp+50h] [ebp-38h]
  int *v16; // [esp+54h] [ebp-34h]
  float v17[6]; // [esp+60h] [ebp-28h] BYREF
  int v18; // [esp+78h] [ebp-10h]
  int v19; // [esp+7Ch] [ebp-Ch]

  v18 = 0;
  v19 = (int)&unk_8665480 + 560 * *(unsigned __int16 *)(a3 + 28);
  *(_DWORD *)(a2 + 136) = (*(_DWORD *)(a3 + 16) & 0x1F00000) >> 20;
  if ( *(_BYTE *)(v19 + 353) || (*(_DWORD *)(a2 + 8) & 0x1000000) == 0 )
  {
    v16 = (int *)BG_WeaponDefs(*(_DWORD *)(a2 + 200));
    v15 = dword_81678A0[10 * *(unsigned __int8 *)(a2 + 358)];
    if ( *(_BYTE *)(v19 + 353) )
    {
      if ( !*(_DWORD *)(a2 + 412) )
      {
        if ( *(_DWORD *)(v19 + 344) && !*(_DWORD *)(a3 + 16) )
          *(_DWORD *)(a3 + 16) = 7340032;
        result = sub_810AD10(a2, a3);
        if ( result )
        {
          result = a3;
          if ( !*(_BYTE *)(a3 + 35) )
            return G_AddEvent((_DWORD *)a2, 187, (*(_DWORD *)(a3 + 16) & 0x1F00000) >> 20);
        }
        return result;
      }
      if ( sub_811E2C2(v19, 560 * *(_DWORD *)(a2 + 336) + 140924032) )
        v18 = 1;
      sub_80DD224((float *)(a2 + 12), dword_859B5EC, (int)v17);
      sub_810C88E(v17);
      if ( a1 == 0.0 )
        v17[2] = 1.0;
      v12 = *(_DWORD *)(a2 + 412);
      v10 = (_DWORD *)(a2 + 312);
      if ( *(_DWORD *)(a2 + 336) == 1023 )
        sub_80FF7C8((int *)v19, (int *)a2, 0, v17, v10, v12, 0, v15, 0, 0);
      else
        sub_80FF7C8(
          (int *)v19,
          (int *)a2,
          (int *)(560 * *(_DWORD *)(a2 + 336) + 140924032),
          v17,
          v10,
          v12,
          0,
          v15,
          0,
          0);
    }
    if ( *(_DWORD *)(a2 + 412) )
    {
      v8 = *(_DWORD *)(a2 + 412);
      v6 = (_DWORD *)(a2 + 312);
      if ( *(_DWORD *)(a2 + 336) == 1023 )
        sub_811AA18(&dword_86F1020, v6, a5, v8, v15);
      else
        sub_811AA18((int *)(560 * *(_DWORD *)(a2 + 336) + 140924032), v6, a5, v8, v15);
    }
    v14 = 0;
    if ( v18 || *(_WORD *)(a3 + 30) )
      v14 = 1;
    v7 = (unsigned __int8)DirToByte((float *)(a3 + 4));
    if ( v14 )
      G_AddEvent((_DWORD *)a2, 190, v7);
    else
      G_AddEvent((_DWORD *)a2, 189, v7);
    *(_DWORD *)(a2 + 136) = (*(_DWORD *)(a3 + 16) & 0x1F00000) >> 20;
    *(_DWORD *)(a2 + 380) = 1;
    *(_DWORD *)(a2 + 4) = 0;
    *(_DWORD *)(a2 + 8) ^= 2u;
    *(_DWORD *)(a2 + 8) |= 0x20u;
    *(_DWORD *)(a2 + 372) |= 0x800u;
    sub_811D53A((int)a5, a2 + 24);
    sub_811CF36((_DWORD *)a2, a5);
    if ( v16[223] )
    {
      v13 = (float)v16[222];
      v11 = (float)v16[224];
      v9 = (float)v16[223];
      G_RadiusDamage(
        a5,
        (int *)a2,
        *(int **)(a2 + 396),
        v9,
        v11,
        v13,
        (int *)v19,
        dword_81678A4[10 * *(unsigned __int8 *)(a2 + 358)]);
    }
    return SV_LinkEntity(a2);
  }
  result = sub_810AD10(a2, a3);
  if ( result )
  {
    result = a3;
    if ( !*(_BYTE *)(a3 + 35) )
      return G_AddEvent((_DWORD *)a2, 187, (*(_DWORD *)(a3 + 16) & 0x1F00000) >> 20);
  }
  return result;
}
// 81678A0: using guessed type int dword_81678A0[];
// 81678A4: using guessed type int dword_81678A4[191];
// 86F1020: using guessed type int dword_86F1020;

//----- (0810B4D8) --------------------------------------------------------
int __cdecl sub_810B4D8(int a1)
{
  int result; // eax
  long double v2; // fst7
  unsigned __int8 v3; // al
  unsigned __int8 v4; // al
  float v5; // [esp+Ch] [ebp-9Ch]
  float v6; // [esp+10h] [ebp-98h]
  float v7; // [esp+14h] [ebp-94h]
  _DWORD *v8; // [esp+2Ch] [ebp-7Ch]
  float s; // [esp+30h] [ebp-78h] BYREF
  float v10[12]; // [esp+34h] [ebp-74h] BYREF
  int v11; // [esp+64h] [ebp-44h]
  int v13; // [esp+6Ch] [ebp-3Ch]
  int v14[2]; // [esp+70h] [ebp-38h] BYREF
  float v15; // [esp+78h] [ebp-30h]
  float v16; // [esp+80h] [ebp-28h] BYREF
  float v17; // [esp+84h] [ebp-24h]
  float v18; // [esp+88h] [ebp-20h]
  int v19; // [esp+90h] [ebp-18h]
  int v20; // [esp+94h] [ebp-14h]
  int v21; // [esp+98h] [ebp-10h]

  v8 = (_DWORD *)BG_WeaponDefs(*(_DWORD *)(a1 + 200));
  if ( v8[33] == 2 && *(_DWORD *)(a1 + 124) == 1023 )
  {
    result = a1;
    *(_DWORD *)(a1 + 400) = 50;
  }
  else
  {
    BG_EvaluateTrajectory(a1 + 12, dword_859B5EC, (int)&v16);
    v16 = (float)(int)v16;
    v17 = (float)(int)v17;
    v18 = (float)(int)v18;
    sub_811CF36((_DWORD *)a1, &v16);
    v20 = 0;
    v19 = 0;
    v21 = 1065353216;
    v13 = *(_DWORD *)(a1 + 4);
    *(_DWORD *)(a1 + 4) = 0;
    *(_DWORD *)(a1 + 8) |= 0x20u;
    *(_DWORD *)(a1 + 372) |= 0x800u;
    *(_BYTE *)(a1 + 242) |= 8u;
    sub_810C716((_DWORD *)(a1 + 312), v14);
    v2 = v15 - 16.0;
    v15 = v2;
    G_TraceCapsule(&s, (float *)(a1 + 312), flt_8145E68, flt_8145E68, (float *)v14, *(_DWORD *)a1, 2065);
    if ( v8[228] == 2 )
    {
      v3 = DirToByte(v10);
      G_AddEvent((_DWORD *)a1, 191, v3);
    }
    else
    {
      v4 = DirToByte(v10);
      G_AddEvent((_DWORD *)a1, 188, v4);
    }
    if ( sub_809C18C((float *)(a1 + 312), -1, 32) )
      *(_DWORD *)(a1 + 136) = 20;
    else
      *(_DWORD *)(a1 + 136) = (LODWORD(v10[3]) & 0x1F00000) >> 20;
    if ( v8[229] && *(_BYTE *)v8[229] )
    {
      *(_DWORD *)(a1 + 8) |= 0x10000u;
      sub_812F34E();
      v11 = sub_8129F6A(v8[229]);
      *(_DWORD *)(a1 + 84) = dword_859B5EC;
      sub_812F544(v11);
      *(_DWORD *)(a1 + 88) = dword_859B5EC + (int)(v2 + 1.0);
    }
    else
    {
      *(_DWORD *)(a1 + 380) = 1;
    }
    if ( v8[223] )
    {
      v7 = (float)(int)v8[222];
      v6 = (float)(int)v8[224];
      v5 = (float)(int)v8[223];
      G_RadiusDamage(
        (float *)(a1 + 312),
        (int *)a1,
        *(int **)(a1 + 396),
        v5,
        v6,
        v7,
        (int *)a1,
        dword_81678A4[10 * *(unsigned __int8 *)(a1 + 358)]);
    }
    return SV_LinkEntity(a1);
  }
  return result;
}
// 8145E68: using guessed type float flt_8145E68[3];
// 81678A4: using guessed type int dword_81678A4[191];
// 810B4D8: using guessed type float s;

//----- (0810B894) --------------------------------------------------------
void __cdecl sub_810B894(float *s, float *a2, float *a3, int a4, int a5)
{
  float v5[6]; // [esp+20h] [ebp-18h] BYREF

  G_LocationalTrace(s, a2, a3, a4, a5, (int)&unk_816778C);
  if ( *((_BYTE *)s + 35) )
  {
    *s = 0.0;
    sub_810C78A(a2, a3, v5);
    sub_80A2298(v5, (int)(s + 1));
  }
}
// 810B894: using guessed type float var_18[6];

//----- (0810B90E) --------------------------------------------------------
int __cdecl sub_810B90E(float *s, int a2, int a3, float *a4)
{
  int result; // eax
  int v5; // [esp+20h] [ebp-8h]

  v5 = *((_DWORD *)&unk_8665480 + 140 * a2 + 71);
  *((_DWORD *)&unk_8665480 + 140 * a2 + 71) = 0;
  sub_810B894(s, (float *)(a3 + 312), a4, *(_DWORD *)(a3 + 336), *(_DWORD *)(a3 + 388));
  result = v5;
  *((_DWORD *)&unk_8665480 + 140 * a2 + 71) = v5;
  return result;
}

//----- (0810B988) --------------------------------------------------------
long double __cdecl sub_810B988(float a1)
{
  float v3; // [esp+14h] [ebp-4h]

  v3 = a1 * 0.0174532925199433;
  return (float)tan(v3);
}

//----- (0810B9B6) --------------------------------------------------------
int __cdecl sub_810B9B6(int a1)
{
  int result; // eax
  long double v2; // fst7
  float v3; // [esp+4h] [ebp-54h]
  int v4; // [esp+24h] [ebp-34h]
  float v5; // [esp+28h] [ebp-30h]
  int i; // [esp+2Ch] [ebp-2Ch]
  float v7[4]; // [esp+30h] [ebp-28h] BYREF
  int v8[6]; // [esp+40h] [ebp-18h] BYREF

  result = *(_DWORD *)(a1 + 16) + (int)*(float *)(a1 + 424);
  if ( result < dword_859B5EC )
  {
    v4 = BG_WeaponDefs(*(_DWORD *)(a1 + 200));
    sub_810C716((_DWORD *)(a1 + 36), v8);
    Vec3Normalize((float *)v8);
    v5 = sub_810B988(*(float *)(v4 + 1448));
    for ( i = 0; i <= 2; ++i )
      v7[i] = sub_80A8720(-1.0, 1.0);
    sub_810C7CE(v7, v5, v7);
    sub_810C746((float *)v8, v7, (float *)v8);
    Vec3Normalize((float *)v8);
    v3 = (float)*(int *)(v4 + 900);
    sub_810C7CE((float *)v8, v3, (float *)(a1 + 36));
    sub_810C716((_DWORD *)(a1 + 312), (_DWORD *)(a1 + 24));
    vectoangles((float *)v8, a1 + 324);
    sub_811CF96((_DWORD *)a1, (_DWORD *)(a1 + 324));
    *(_DWORD *)(a1 + 16) = dword_859B5EC;
    if ( (*(_DWORD *)(a1 + 372) & 0x10000) != 0 )
      v2 = *(float *)(a1 + 424) * *(float *)(v4 + 1444);
    else
      v2 = *(float *)(v4 + 1440) * 1000.0;
    *(float *)(a1 + 424) = v2;
    result = a1;
    *(_DWORD *)(a1 + 372) |= 0x10000u;
  }
  return result;
}
// 810B9B6: using guessed type float var_28[4];

//----- (0810BB8C) --------------------------------------------------------
int __cdecl sub_810BB8C(float *a1, int a2)
{
  int result; // eax
  _DWORD *v3; // [esp+1Ch] [ebp-1Ch]
  float v4[2]; // [esp+20h] [ebp-18h] BYREF
  float v5; // [esp+28h] [ebp-10h]

  sub_80A2298(a1 + 9, (int)v4);
  if ( v5 < 0.0 )
    HIBYTE(v5) ^= 0x80u;
  v3 = G_TempEntity((_DWORD *)a1 + 78, 182);
  v3[40] = (unsigned __int8)DirToByte((float *)(a2 + 4));
  v3[54] = (unsigned __int8)DirToByte(v4);
  v3[34] = (*(_DWORD *)(a2 + 16) & 0x1F00000) >> 20;
  result = *(_DWORD *)a1;
  v3[29] = *(_DWORD *)a1;
  return result;
}
// 810BB8C: using guessed type float var_18[2];

//----- (0810BC36) --------------------------------------------------------
unsigned __int8 *__cdecl sub_810BC36(unsigned __int8 *a1)
{
  unsigned __int8 *result; // eax
  int v2; // [esp+2Ch] [ebp-BCh]
  int v3[7]; // [esp+30h] [ebp-B8h] BYREF
  int v4; // [esp+4Ch] [ebp-9Ch]
  _DWORD v5[4]; // [esp+50h] [ebp-98h] BYREF
  float v6[7]; // [esp+60h] [ebp-88h] BYREF
  int v7; // [esp+7Ch] [ebp-6Ch]
  int v8; // [esp+80h] [ebp-68h]
  float s[3]; // [esp+90h] [ebp-58h] BYREF
  float v10; // [esp+9Ch] [ebp-4Ch]
  float v11; // [esp+A0h] [ebp-48h]
  float v12; // [esp+A4h] [ebp-44h]
  float v13; // [esp+A8h] [ebp-40h]
  int v14; // [esp+ACh] [ebp-3Ch]
  int v15; // [esp+B0h] [ebp-38h]
  float v16[4]; // [esp+C0h] [ebp-28h] BYREF
  int v17[2]; // [esp+D0h] [ebp-18h] BYREF
  float v18; // [esp+D8h] [ebp-10h]

  if ( !*((_DWORD *)a1 + 3) && *((_DWORD *)a1 + 31) != 1022 )
  {
    sub_810C716((_DWORD *)a1 + 78, v17);
    v18 = v18 - 1.5;
    sub_810B894(s, (float *)a1 + 78, (float *)v17, *((_DWORD *)a1 + 84), *((_DWORD *)a1 + 97));
    if ( s[0] == 1.0 )
    {
      *((_DWORD *)a1 + 3) = 5;
      *((_DWORD *)a1 + 4) = dword_859B5EC;
      *((_DWORD *)a1 + 5) = 0;
      sub_810C716((_DWORD *)a1 + 78, (_DWORD *)a1 + 6);
      sub_810C6EC((_DWORD *)a1 + 9);
    }
  }
  sub_810C716((_DWORD *)a1 + 78, v5);
  BG_EvaluateTrajectory((int)(a1 + 12), dword_859B5EC, (int)v17);
  sub_810C78A((float *)v17, (float *)a1 + 78, v16);
  if ( Vec3Normalize(v16) < 0.001 )
    return (unsigned __int8 *)sub_81079C8((int)a1);
  if ( sub_810C6D2(*((float *)a1 + 11)) <= 30.0 || sub_809C18C((float *)a1 + 78, -1, 32) )
    sub_810B894(s, (float *)a1 + 78, (float *)v17, *((_DWORD *)a1 + 84), *((_DWORD *)a1 + 97));
  else
    sub_810B894(s, (float *)a1 + 78, (float *)v17, *((_DWORD *)a1 + 84), *((_DWORD *)a1 + 97) | 0x20);
  if ( (LODWORD(v11) & 0x1F00000) == 20971520 )
  {
    sub_810BB8C((float *)a1, (int)s);
    sub_810B894(s, (float *)a1 + 78, (float *)v17, *((_DWORD *)a1 + 84), *((_DWORD *)a1 + 97));
  }
  v4 = dword_81678A0[10 * a1[358]];
  if ( v4 == 3 && word_86655F4[280 * (unsigned __int16)v14] < 0 )
    sub_810B90E(s, (unsigned __int16)v14, (int)a1, (float *)v17);
  sub_80DEB7A((float *)a1 + 78, (float *)v17, s[0], (float *)v3);
  sub_810C716(v3, (_DWORD *)a1 + 78);
  if ( (*((_DWORD *)a1 + 2) & 0x1000000) != 0 && (s[0] == 1.0 || s[0] < 1.0 && v10 > 0.69999999) )
  {
    sub_810C716((_DWORD *)a1 + 78, v17);
    v18 = v18 - 1.5;
    sub_810B894(v6, (float *)a1 + 78, (float *)v17, *((_DWORD *)a1 + 84), *((_DWORD *)a1 + 97));
    if ( v6[0] != 1.0 && (_WORD)v7 == 1022 )
    {
      s[0] = v6[0];
      s[1] = v6[1];
      s[2] = v6[2];
      v10 = v6[3];
      v11 = v6[4];
      v12 = v6[5];
      v13 = v6[6];
      v14 = v7;
      v15 = v8;
      sub_80DEB7A((float *)a1 + 78, (float *)v17, v6[0], (float *)v3);
      *((float *)a1 + 8) = *(float *)&v3[2] + 1.5 - *((float *)a1 + 80) + *((float *)a1 + 8);
      sub_810C716(v3, (_DWORD *)a1 + 78);
      *((float *)a1 + 80) = *((float *)a1 + 80) + 1.5;
    }
  }
  SV_LinkEntity((int)a1);
  v2 = BG_WeaponDefs(*((_DWORD *)a1 + 50));
  if ( v4 == 3 )
    sub_811AC06((int *)a1, v5, (float *)a1 + 78, *(_DWORD *)(v2 + 892), 3);
  if ( s[0] == 1.0 )
  {
    sub_810C88E((float *)a1 + 9);
    if ( 1.0 != 0.0 )
    {
      *((_DWORD *)a1 + 31) = 1023;
      if ( *(_DWORD *)(v2 + 120) == 2 && (*((_DWORD *)a1 + 93) & 0x20000) == 0 )
        sub_810B9B6((int)a1);
    }
    return (unsigned __int8 *)sub_81079C8((int)a1);
  }
  if ( (LOBYTE(v11) & 0x10) != 0 )
    return (unsigned __int8 *)G_FreeEntity(1.0, (int *)a1);
  sub_810B07A(1.0, (int)a1, (int)s, (int)v16, (float *)v3);
  result = a1;
  if ( *((_DWORD *)a1 + 1) == 4 )
    return (unsigned __int8 *)sub_81079C8((int)a1);
  return result;
}
// 81678A0: using guessed type int dword_81678A0[];
// 86655F4: using guessed type __int16 word_86655F4[];
// 810BC36: using guessed type _DWORD var_98[4];
// 810BC36: using guessed type float var_28[4];

//----- (0810C1F6) --------------------------------------------------------
int __cdecl sub_810C1F6(_DWORD *a1, _DWORD *a2, float *a3, int a4, int a5)
{
  float v6; // [esp+0h] [ebp-28h]
  int v7; // [esp+1Ch] [ebp-Ch]
  int v8; // [esp+20h] [ebp-8h]

  v8 = G_Spawn();
  if ( a1[86] && *(_DWORD *)(a1[86] + 60) )
  {
    *(_DWORD *)(v8 + 400) = dword_859B5EC + *(_DWORD *)(a1[86] + 60);
    *(_DWORD *)(a1[86] + 60) = 0;
  }
  else
  {
    *(_DWORD *)(v8 + 400) = dword_859B5EC + a5;
  }
  if ( a1[86] )
    *(_DWORD *)(a1[86] + 60) = 0;
  *(_BYTE *)(v8 + 358) = 7;
  *(_DWORD *)(v8 + 4) = 4;
  *(_BYTE *)(v8 + 242) = 8;
  *(_DWORD *)(v8 + 200) = a4;
  *(_DWORD *)(v8 + 336) = *a1;
  *(_DWORD *)(v8 + 396) = a1;
  v7 = BG_WeaponDefs(a4);
  Scr_SetString((_WORD *)(v8 + 360), (unsigned __int16)word_87A22BA);
  *(_DWORD *)(v8 + 412) = *(_DWORD *)(v7 + 492);
  *(_DWORD *)(v8 + 8) = 0x1000000;
  *(_DWORD *)(v8 + 388) = 41953425;
  *(_DWORD *)(v8 + 84) = dword_859B5EC + 50;
  *(_DWORD *)(v8 + 12) = 5;
  *(_DWORD *)(v8 + 16) = dword_859B5EC;
  sub_810C716(a2, (_DWORD *)(v8 + 24));
  sub_810C716(a3, (_DWORD *)(v8 + 36));
  *(float *)(v8 + 36) = (float)(int)*(float *)(v8 + 36);
  *(float *)(v8 + 40) = (float)(int)*(float *)(v8 + 40);
  *(float *)(v8 + 44) = (float)(int)*(float *)(v8 + 44);
  *(_DWORD *)(v8 + 48) = 2;
  *(_DWORD *)(v8 + 52) = dword_859B5EC;
  vectoangles(a3, v8 + 60);
  v6 = *(float *)(v8 + 60) - 120.0;
  *(float *)(v8 + 60) = sub_80A60CE(v6);
  *(float *)(v8 + 72) = sub_80A8720(-45.0, 45.0) + 720.0;
  *(_DWORD *)(v8 + 76) = 0;
  *(float *)(v8 + 80) = sub_80A8720(-45.0, 45.0) + 360.0;
  sub_810C716(a2, (_DWORD *)(v8 + 312));
  sub_810C716((_DWORD *)(v8 + 60), (_DWORD *)(v8 + 324));
  return v8;
}
// 87A22BA: using guessed type __int16 word_87A22BA;

//----- (0810C4A0) --------------------------------------------------------
int __cdecl sub_810C4A0(_DWORD *a1, _DWORD *a2, float *a3)
{
  float v4; // [esp+4h] [ebp-24h]
  _DWORD *v5; // [esp+20h] [ebp-8h]
  int v6; // [esp+24h] [ebp-4h]

  Vec3Normalize(a3);
  v5 = (_DWORD *)BG_WeaponDefs(a1[50]);
  v6 = G_Spawn();
  Scr_SetString((_WORD *)(v6 + 360), (unsigned __int16)word_87A22DE);
  *(_DWORD *)(v6 + 400) = dword_859B5EC + 30000;
  *(_BYTE *)(v6 + 358) = 8;
  *(_DWORD *)(v6 + 4) = 4;
  *(_DWORD *)(v6 + 8) |= 0x400u;
  *(_BYTE *)(v6 + 242) = 8;
  *(_DWORD *)(v6 + 200) = a1[50];
  *(_DWORD *)(v6 + 336) = *a1;
  *(_DWORD *)(v6 + 396) = a1;
  *(_DWORD *)(v6 + 412) = v5[123];
  *(_DWORD *)(v6 + 388) = 41953425;
  *(_DWORD *)(v6 + 84) = dword_859B5EC + 50;
  *(_DWORD *)(v6 + 12) = 2;
  *(_DWORD *)(v6 + 16) = dword_859B5EC - 50;
  sub_810C716(a2, (_DWORD *)(v6 + 24));
  v4 = (float)(int)v5[225];
  sub_810C7CE(a3, v4, (float *)(v6 + 36));
  *(float *)(v6 + 36) = (float)(int)*(float *)(v6 + 36);
  *(float *)(v6 + 40) = (float)(int)*(float *)(v6 + 40);
  *(float *)(v6 + 44) = (float)(int)*(float *)(v6 + 44);
  sub_810C716(a2, (_DWORD *)(v6 + 312));
  vectoangles(a3, v6 + 324);
  sub_811CF96((_DWORD *)v6, (_DWORD *)(v6 + 324));
  *(float *)(v6 + 424) = (long double)(int)v5[363] / (long double)(int)v5[225] * 1000.0;
  *(_DWORD *)(v6 + 372) |= a1[93] & 0x20000;
  return v6;
}
// 87A22DE: using guessed type __int16 word_87A22DE;

//----- (0810C6D2) --------------------------------------------------------
long double __cdecl sub_810C6D2(float a1)
{
  return (float)fabs(a1);
}

//----- (0810C6EC) --------------------------------------------------------
int __cdecl sub_810C6EC(_DWORD *a1)
{
  int result; // eax

  *a1 = 0;
  a1[1] = 0;
  result = 0;
  a1[2] = 0;
  return result;
}

//----- (0810C716) --------------------------------------------------------
int __cdecl sub_810C716(_DWORD *a1, _DWORD *a2)
{
  int result; // eax

  *a2 = *a1;
  a2[1] = a1[1];
  result = a1[2];
  a2[2] = result;
  return result;
}

//----- (0810C746) --------------------------------------------------------
float *__cdecl sub_810C746(float *a1, float *a2, float *a3)
{
  float *result; // eax

  *a3 = *a1 + *a2;
  a3[1] = a1[1] + a2[1];
  result = a1 + 2;
  a3[2] = a1[2] + a2[2];
  return result;
}

//----- (0810C78A) --------------------------------------------------------
float *__cdecl sub_810C78A(float *a1, float *a2, float *a3)
{
  float *result; // eax

  *a3 = *a1 - *a2;
  a3[1] = a1[1] - a2[1];
  result = a1 + 2;
  a3[2] = a1[2] - a2[2];
  return result;
}

//----- (0810C7CE) --------------------------------------------------------
float *__cdecl sub_810C7CE(float *a1, float a2, float *a3)
{
  float *result; // eax

  *a3 = a2 * *a1;
  a3[1] = a2 * a1[1];
  result = a1 + 2;
  a3[2] = a2 * a1[2];
  return result;
}

//----- (0810C806) --------------------------------------------------------
float *__cdecl sub_810C806(float *a1, float a2, float *a3, float *a4)
{
  float *result; // eax

  *a4 = a2 * *a3 + *a1;
  a4[1] = a2 * a3[1] + a1[1];
  result = a3 + 2;
  a4[2] = a2 * a3[2] + a1[2];
  return result;
}

//----- (0810C85A) --------------------------------------------------------
long double __cdecl sub_810C85A(float *a1, float *a2)
{
  return *a1 * *a2 + a1[1] * a2[1] + a1[2] * a2[2];
}

//----- (0810C88E) --------------------------------------------------------
void __cdecl sub_810C88E(float *a1)
{
  float v1; // [esp+0h] [ebp-8h]

  v1 = *a1 * *a1 + a1[1] * a1[1] + a1[2] * a1[2];
  sub_810C8CC(v1);
}

//----- (0810C8CC) --------------------------------------------------------
long double __cdecl sub_810C8CC(float a1)
{
  return (float)sqrt(a1);
}

//----- (0810C8EC) --------------------------------------------------------
int __cdecl sub_810C8EC(int a1, float *a2)
{
  int v4; // [esp+2Ch] [ebp-3Ch]
  float s[7]; // [esp+30h] [ebp-38h] BYREF
  unsigned __int16 v6; // [esp+4Ch] [ebp-1Ch]
  char v7; // [esp+52h] [ebp-16h]
  char v8; // [esp+53h] [ebp-15h]

  if ( *(_DWORD *)(a1 + 388) )
  {
    if ( (*(_DWORD *)(a1 + 284) & 0x4000000) != 0 )
      return 0;
    v4 = *(_DWORD *)(a1 + 388);
  }
  else
  {
    v4 = 2065;
  }
  if ( *(_DWORD *)(a1 + 4) == 4 )
    G_TraceCapsule(s, a2, (float *)(a1 + 260), (float *)(a1 + 272), a2, *(_DWORD *)(a1 + 336), v4);
  else
    G_TraceCapsule(s, a2, (float *)(a1 + 260), (float *)(a1 + 272), a2, *(_DWORD *)a1, v4);
  if ( v8 || v7 )
    return 560 * v6 + 140924032;
  else
    return 0;
}
// 810C8EC: using guessed type float s[7];

//----- (0810C9F0) --------------------------------------------------------
unsigned int __cdecl sub_810C9F0(float *a1, int a2)
{
  AngleVectors(a1, a2, (float *)(a2 + 12), (float *)(a2 + 24));
  return sub_810DC22((_DWORD *)(a2 + 12));
}

//----- (0810CA2C) --------------------------------------------------------
int *__cdecl sub_810CA2C(int a1, int a2)
{
  int *result; // eax
  int j; // [esp+0h] [ebp-Ch]
  int i; // [esp+4h] [ebp-8h] BYREF

  for ( i = 0; i <= 2; ++i )
  {
    for ( j = 0; j <= 2; ++j )
      *(_DWORD *)(a2 + 4 * (j + 3 * i)) = *(_DWORD *)(a1 + 4 * (i + 3 * j));
    result = &i;
  }
  return result;
}

//----- (0810CA98) --------------------------------------------------------
int __cdecl sub_810CA98(int a1, float *a2)
{
  long double v2; // fst7
  int result; // eax
  float v4[6]; // [esp+10h] [ebp-18h] BYREF

  sub_810DBF2((_DWORD *)a1, v4);
  *(float *)a1 = sub_810DCE8(a2, v4);
  *(float *)(a1 + 4) = sub_810DCE8(a2 + 3, v4);
  v2 = sub_810DCE8(a2 + 6, v4);
  result = a1 + 8;
  *(float *)(a1 + 8) = v2;
  return result;
}
// 810CA98: using guessed type float var_18[6];

//----- (0810CB04) --------------------------------------------------------
int __cdecl sub_810CB04(int a1, int a2, float *a3, float *a4)
{
  float v6[6]; // [esp+20h] [ebp-D8h] BYREF
  int i; // [esp+38h] [ebp-C0h]
  float v8; // [esp+3Ch] [ebp-BCh]
  int k; // [esp+40h] [ebp-B8h]
  float v10; // [esp+44h] [ebp-B4h]
  int j; // [esp+48h] [ebp-B0h]
  float v12; // [esp+4Ch] [ebp-ACh]
  char v13[48]; // [esp+50h] [ebp-A8h] BYREF
  float v14[15]; // [esp+80h] [ebp-78h] BYREF
  int v15; // [esp+BCh] [ebp-3Ch]
  float v16[4]; // [esp+C0h] [ebp-38h] BYREF
  float v17[4]; // [esp+D0h] [ebp-28h] BYREF
  float v18[6]; // [esp+E0h] [ebp-18h] BYREF

  sub_810DC60((float *)(a1 + 312), a3, v6);
  sub_810C9F0(a4, (int)v13);
  sub_810CA2C((int)v13, (int)v14);
  sub_810DCA4(v6, (float *)(a2 + 312), v18);
  sub_810DBF2(v18, v17);
  sub_810CA98((int)v17, v14);
  sub_810DCA4(v17, v18, v16);
  sub_810DC60(v6, v16, v6);
  v15 = sub_810C8EC(a1, v6);
  if ( v15 )
  {
    if ( *(float *)(a1 + 272) / 2.0 <= 4.0 )
      goto LABEL_33;
    sub_810DBF2(v6, v18);
    v8 = 0.0;
LABEL_9:
    if ( *(float *)(a1 + 272) / 2.0 <= v8 )
    {
LABEL_33:
      v15 = sub_810C8EC(a1, (float *)(a1 + 312));
      if ( v15 )
      {
        return 0;
      }
      else
      {
        *(_DWORD *)(a1 + 124) = 1023;
        return 1;
      }
    }
    else
    {
      for ( i = LODWORD(v8) ^ 0x80000000; ; *(float *)&i = v8 + v8 + *(float *)&i )
      {
        if ( v8 < (long double)*(float *)&i )
        {
LABEL_32:
          v8 = v8 + 4.0;
          goto LABEL_9;
        }
        v12 = 4.0;
LABEL_13:
        if ( *(float *)(a1 + 272) / 2.0 > v12 )
          break;
        if ( *(float *)&i == 0.0 )
          goto LABEL_32;
      }
      for ( j = LODWORD(v12) ^ 0x80000000; ; *(float *)&j = v12 + v12 + *(float *)&j )
      {
        if ( v12 < (long double)*(float *)&j )
        {
          v12 = v12 + 4.0;
          goto LABEL_13;
        }
        v10 = 4.0;
LABEL_17:
        if ( *(float *)(a1 + 272) / 2.0 > v10 )
          break;
      }
      for ( k = LODWORD(v10) ^ 0x80000000; ; *(float *)&k = v10 + v10 + *(float *)&k )
      {
        if ( v10 < (long double)*(float *)&k )
        {
          v10 = v10 + 4.0;
          goto LABEL_17;
        }
        sub_810DBCE(v16, j, k, i);
        sub_810DC60(v18, v16, v17);
        v15 = sub_810C8EC(a1, v17);
        if ( !v15 )
          break;
      }
      if ( *(_DWORD *)(a1 + 124) != *(_DWORD *)a2 )
        *(_DWORD *)(a1 + 124) = 1023;
      sub_810DBF2(v17, (_DWORD *)(a1 + 312));
      sub_810DBF2(v17, (_DWORD *)(a1 + 24));
      if ( *(_DWORD *)(a1 + 344) )
      {
        *(_DWORD *)(*(_DWORD *)(a1 + 344) + 88) += (unsigned __int16)(int)(a4[1] * 182.04445);
        sub_810DBF2(v17, (_DWORD *)(*(_DWORD *)(a1 + 344) + 20));
      }
      dword_879C700 += 32;
      return 1;
    }
  }
  else
  {
    if ( *(_DWORD *)(a1 + 124) != *(_DWORD *)a2 )
      *(_DWORD *)(a1 + 124) = 1023;
    sub_810DBF2(v6, (_DWORD *)(a1 + 312));
    sub_810DBF2(v6, (_DWORD *)(a1 + 24));
    if ( *(_DWORD *)(a1 + 344) )
    {
      *(_DWORD *)(*(_DWORD *)(a1 + 344) + 88) += (unsigned __int16)(int)(a4[1] * 182.04445);
      sub_810DBF2(v6, (_DWORD *)(*(_DWORD *)(a1 + 344) + 20));
    }
    dword_879C700 += 32;
    return 1;
  }
}
// 879C700: using guessed type int dword_879C700;
// 810CB04: using guessed type float var_D8[6];
// 810CB04: using guessed type float var_78[15];
// 810CB04: using guessed type float var_18[6];
// 810CB04: using guessed type float var_28[4];
// 810CB04: using guessed type float var_38[4];

//----- (0810D058) --------------------------------------------------------
int __cdecl sub_810D058(int a1, float *a2, float *a3, _DWORD *a4)
{
  long double v4; // fst7
  unsigned __int8 v6; // [esp+3Bh] [ebp-206Dh]
  float v7; // [esp+3Ch] [ebp-206Ch]
  float v8[4]; // [esp+40h] [ebp-2068h] BYREF
  float v9[6]; // [esp+50h] [ebp-2058h] BYREF
  int v10; // [esp+68h] [ebp-2040h]
  int v11; // [esp+6Ch] [ebp-203Ch]
  int v12[1024]; // [esp+70h] [ebp-2038h]
  int v13[1024]; // [esp+1070h] [ebp-1038h] BYREF
  float v14[4]; // [esp+2070h] [ebp-38h]
  float v15[5]; // [esp+2080h] [ebp-28h]
  int *v16; // [esp+2094h] [ebp-14h]
  int j; // [esp+2098h] [ebp-10h]
  int i; // [esp+209Ch] [ebp-Ch]

  *a4 = 0;
  v6 = 1;
  v4 = 0.0;
  if ( *(float *)(a1 + 324) == 0.0
    && (v4 = 0.0, *(float *)(a1 + 328) == 0.0)
    && (v4 = 0.0, *(float *)(a1 + 332) == 0.0)
    && (v4 = 0.0, *a3 == 0.0)
    && (v4 = 0.0, a3[1] == 0.0)
    && (v4 = 0.0, a3[2] == 0.0) )
  {
    for ( i = 0; i <= 2; ++i )
    {
      v15[i] = *(float *)(a1 + 4 * i + 288) + a2[i];
      v14[i] = *(float *)(a1 + 4 * i + 300) + a2[i];
    }
    sub_810DBF2((_DWORD *)(a1 + 288), v9);
    sub_810DBF2((_DWORD *)(a1 + 300), v8);
  }
  else
  {
    sub_80A626E(a1 + 260, a1 + 272);
    v7 = v4;
    for ( i = 0; i <= 2; ++i )
    {
      v15[i] = *(float *)(a1 + 4 * i + 312) - v7 + a2[i];
      v14[i] = *(float *)(a1 + 4 * i + 312) + v7 + a2[i];
      v9[i] = *(float *)(a1 + 4 * i + 312) - v7;
      v8[i] = *(float *)(a1 + 4 * i + 312) + v7;
    }
  }
  for ( i = 0; i <= 2; ++i )
  {
    if ( a2[i] <= 0.0 )
      v9[i] = v9[i] + a2[i];
    else
      v8[i] = v8[i] + a2[i];
  }
  SV_UnlinkEntity(a1);
  v11 = sub_805E782((int)v9, (int)v8, (int)v13, 1024, 33554816);
  sub_810DC60((float *)(a1 + 312), a2, (float *)(a1 + 312));
  sub_810DC60((float *)(a1 + 324), a3, (float *)(a1 + 324));
  SV_LinkEntity(a1);
  v10 = 0;
  for ( j = 0; j < v11; ++j )
  {
    v16 = (int *)((char *)&unk_8665480 + 560 * v13[j]);
    if ( (v16[1] == 4 || v16[1] == 3 || v16[1] == 1 || *((_BYTE *)v16 + 352))
      && (v16[31] == *(_DWORD *)a1
       || *((float *)v16 + 72) < (long double)v14[0]
       && *((float *)v16 + 73) < (long double)v14[1]
       && *((float *)v16 + 74) < (long double)v14[2]
       && v15[0] < (long double)*((float *)v16 + 75)
       && v15[1] < (long double)*((float *)v16 + 76)
       && v15[2] < (long double)*((float *)v16 + 77)
       && sub_810C8EC((int)v16, (float *)v16 + 78) == a1) )
    {
      v12[v10++] = v13[j];
    }
  }
  for ( j = 0; j < v10; ++j )
  {
    v16 = (int *)((char *)&unk_8665480 + 560 * v12[j]);
    SV_UnlinkEntity((int)v16);
  }
  for ( j = 0; j < v10; ++j )
  {
    v16 = (int *)((char *)&unk_8665480 + 560 * v12[j]);
    *(_DWORD *)dword_879C700 = v16;
    sub_810DBF2(v16 + 78, (_DWORD *)(dword_879C700 + 4));
    *(float *)(dword_879C700 + 28) = a3[1];
    if ( sub_810CB04((int)v16, a1, a2, a3) || v16[1] == 3 )
    {
      SV_LinkEntity((int)v16);
    }
    else if ( *(_DWORD *)(a1 + 12) == 4 || *(_DWORD *)(a1 + 48) == 4 )
    {
      sub_80FF7C8(v16, (int *)a1, (int *)a1, 0, 0, 99999, 0, 9u, 0, 0);
    }
    else
    {
      *a4 = v16;
      v6 = 0;
    }
  }
  for ( j = 0; j < v10; ++j )
  {
    v16 = (int *)((char *)&unk_8665480 + 560 * v12[j]);
    SV_LinkEntity((int)v16);
  }
  return v6;
}
// 879C700: using guessed type int dword_879C700;
// 810D058: using guessed type float var_2058[6];
// 810D058: using guessed type float var_2068[4];
// 810D058: using guessed type int var_1038[1024];
// 810D058: using guessed type int var_2038[1024];

//----- (0810D672) --------------------------------------------------------
int (__cdecl *__cdecl sub_810D672(int a1))(int)
{
  int (__cdecl *result)(int); // eax
  void (__cdecl *v2)(int); // [esp+20h] [ebp-68h]
  unsigned int i; // [esp+28h] [ebp-60h]
  int v4; // [esp+2Ch] [ebp-5Ch]
  float v5[4]; // [esp+30h] [ebp-58h] BYREF
  float v6[7]; // [esp+40h] [ebp-48h] BYREF
  int v7; // [esp+5Ch] [ebp-2Ch] BYREF
  float v8[4]; // [esp+60h] [ebp-28h] BYREF
  float v9[6]; // [esp+70h] [ebp-18h] BYREF

  v7 = 0;
  dword_879C700 = (int)&unk_8794700;
  BG_EvaluateTrajectory(a1 + 12, dword_859B5EC, (int)v6);
  BG_EvaluateTrajectory(a1 + 48, dword_859B5EC, (int)v5);
  sub_810DCA4(v6, (float *)(a1 + 312), v9);
  sub_810DCA4(v5, (float *)(a1 + 324), v8);
  if ( (unsigned __int8)sub_810D058(a1, v9, v8, &v7) )
  {
    if ( *(_DWORD *)(a1 + 12) )
    {
      if ( dword_859B5EC >= *(_DWORD *)(a1 + 16) + *(_DWORD *)(a1 + 20) )
      {
        v2 = (void (__cdecl *)(int))dword_8167884[10 * *(unsigned __int8 *)(a1 + 358)];
        if ( v2 )
          v2(a1);
      }
    }
    result = (int (__cdecl *)(int))a1;
    if ( *(_DWORD *)(a1 + 48) )
    {
      result = (int (__cdecl *)(int))(*(_DWORD *)(a1 + 52) + *(_DWORD *)(a1 + 56));
      if ( dword_859B5EC >= (int)result )
      {
        result = (int (__cdecl *)(int))dword_8167884[10 * *(unsigned __int8 *)(a1 + 358)];
        if ( result )
          return (int (__cdecl *)(int))result(a1);
      }
    }
  }
  else
  {
    for ( i = dword_879C700 - 32; i >= (unsigned int)&unk_8794700; i -= 32 )
    {
      v4 = *(_DWORD *)i;
      sub_810DBF2((_DWORD *)(i + 4), (_DWORD *)(*(_DWORD *)i + 312));
      sub_810DBF2((_DWORD *)(i + 4), (_DWORD *)(v4 + 24));
      if ( *(_DWORD *)(v4 + 344) )
      {
        *(_DWORD *)(*(_DWORD *)(v4 + 344) + 88) -= (unsigned __int16)(int)(*(float *)(i + 28) * 182.04445);
        sub_810DBF2((_DWORD *)(i + 4), (_DWORD *)(*(_DWORD *)(v4 + 344) + 20));
      }
      SV_LinkEntity(v4);
    }
    *(_DWORD *)(a1 + 16) += dword_859B5EC - dword_859B5F0;
    *(_DWORD *)(a1 + 52) += dword_859B5EC - dword_859B5F0;
    BG_EvaluateTrajectory(a1 + 12, dword_859B5EC, a1 + 312);
    BG_EvaluateTrajectory(a1 + 48, dword_859B5EC, a1 + 324);
    SV_LinkEntity(a1);
    result = (int (__cdecl *)(int))dword_8167888[10 * *(unsigned __int8 *)(a1 + 358)];
    if ( result )
      return (int (__cdecl *)(int))((int (__cdecl *)(int, int))result)(a1, v7);
  }
  return result;
}
// 8167884: using guessed type int dword_8167884[];
// 8167888: using guessed type int dword_8167888[];
// 859B5F0: using guessed type int dword_859B5F0;
// 879C700: using guessed type int dword_879C700;
// 810D672: using guessed type float var_48[7];
// 810D672: using guessed type float var_58[4];
// 810D672: using guessed type float var_18[6];
// 810D672: using guessed type float var_28[4];

//----- (0810D966) --------------------------------------------------------
int __cdecl sub_810D966(_DWORD *a1)
{
  if ( a1[130] )
  {
    sub_811BE86(a1);
  }
  else if ( a1[3] || a1[12] )
  {
    sub_810D672((int)a1);
  }
  return sub_81079C8((int)a1);
}

//----- (0810D9B8) --------------------------------------------------------
int __cdecl sub_810D9B8(int a1)
{
  int result; // eax
  char s2[1032]; // [esp+10h] [ebp-418h] BYREF
  char *s1; // [esp+418h] [ebp-10h] BYREF
  unsigned int i; // [esp+41Ch] [ebp-Ch] BYREF

  SV_SetBrushModel(a1);
  SV_LinkEntity(a1);
  *(_DWORD *)(a1 + 436) = 1023;
  *(_DWORD *)(a1 + 12) = 0;
  sub_810DBF2((_DWORD *)(a1 + 312), (_DWORD *)(a1 + 24));
  *(_DWORD *)(a1 + 284) = 0x200000;
  *(_BYTE *)(a1 + 242) = 1;
  *(_BYTE *)(a1 + 358) = 18;
  *(_DWORD *)(a1 + 220) = 2;
  if ( sub_8117F4C("cursorhint", (int)&unk_8153DE0, &s1) )
  {
    if ( I_stricmp(s1, "HINT_INHERIT") )
    {
      for ( i = 1; i <= 5; ++i )
      {
        if ( !I_stricmp(s1, *(char **)&off_8167BA0[4 * i]) )
        {
          *(_DWORD *)(a1 + 220) = i;
          break;
        }
      }
    }
    else
    {
      *(_DWORD *)(a1 + 220) = -1;
    }
  }
  *(_DWORD *)(a1 + 216) = 255;
  result = sub_8117F4C("hintstring", (int)&unk_8153DE0, &s1);
  if ( result )
  {
    for ( i = 0; (int)i <= 31; ++i )
    {
      SV_GetConfigstring(i + 1278, s2, 1024);
      if ( !s2[0] )
      {
        SV_SetConfigstring(i + 1278, s1);
        result = (unsigned __int8)i;
        *(_DWORD *)(a1 + 216) = (unsigned __int8)i;
        break;
      }
      if ( !strcmp(s1, s2) )
      {
        result = (unsigned __int8)i;
        *(_DWORD *)(a1 + 216) = (unsigned __int8)i;
        break;
      }
      result = (int)&i;
    }
    if ( i == 32 )
      Com_Error(1, (char *)&byte_8153E60, 32);
  }
  return result;
}

//----- (0810DBA6) --------------------------------------------------------
int __cdecl sub_810DBA6(int a1)
{
  return sub_810D9B8(a1);
}

//----- (0810DBBA) --------------------------------------------------------
int __cdecl sub_810DBBA(int a1)
{
  return sub_810D9B8(a1);
}

//----- (0810DBCE) --------------------------------------------------------
int __cdecl sub_810DBCE(_DWORD *a1, int a2, int a3, int a4)
{
  int result; // eax

  *a1 = a2;
  a1[1] = a3;
  result = a4;
  a1[2] = a4;
  return result;
}

//----- (0810DBF2) --------------------------------------------------------
int __cdecl sub_810DBF2(_DWORD *a1, _DWORD *a2)
{
  int result; // eax

  *a2 = *a1;
  a2[1] = a1[1];
  result = a1[2];
  a2[2] = result;
  return result;
}

//----- (0810DC22) --------------------------------------------------------
unsigned int __cdecl sub_810DC22(_DWORD *a1)
{
  unsigned int result; // eax

  *a1 ^= 0x80000000;
  a1[1] ^= 0x80000000;
  result = a1[2] ^ 0x80000000;
  a1[2] = result;
  return result;
}

//----- (0810DC60) --------------------------------------------------------
float *__cdecl sub_810DC60(float *a1, float *a2, float *a3)
{
  float *result; // eax

  *a3 = *a1 + *a2;
  a3[1] = a1[1] + a2[1];
  result = a1 + 2;
  a3[2] = a1[2] + a2[2];
  return result;
}

//----- (0810DCA4) --------------------------------------------------------
float *__cdecl sub_810DCA4(float *a1, float *a2, float *a3)
{
  float *result; // eax

  *a3 = *a1 - *a2;
  a3[1] = a1[1] - a2[1];
  result = a1 + 2;
  a3[2] = a1[2] - a2[2];
  return result;
}

//----- (0810DCE8) --------------------------------------------------------
long double __cdecl sub_810DCE8(float *a1, float *a2)
{
  return *a1 * *a2 + a1[1] * a2[1] + a1[2] * a2[2];
}

//----- (0810DD1C) --------------------------------------------------------
int __cdecl sub_810DD1C(char *s)
{
  return sub_8079808(s);
}

//----- (0810DD38) --------------------------------------------------------
void sub_810DD38()
{
  unsigned __int16 v0; // [esp+16h] [ebp-2h]

  if ( dword_879C780 )
  {
    v0 = Scr_ExecThread(dword_879C780, 0);
    Scr_FreeThread(v0);
  }
}
// 879C780: using guessed type int dword_879C780;

//----- (0810DD70) --------------------------------------------------------
int __cdecl Scr_GetFunctionHandle(char *a1, char *s, int a3)
{
  int v4; // [esp+14h] [ebp-4h]

  if ( !sub_8075C54(a1) && a3 )
    Com_Error(1, (char *)&byte_8153EC0, a1);
  v4 = sub_8075874(a1, s);
  if ( !v4 && a3 )
    Com_Error(1, (char *)&byte_8153EE0, s, a1);
  return v4;
}
// 810DD70: using guessed type char *arg_0;

//----- (0810DDEE) --------------------------------------------------------
int GScr_LoadGameTypeScript()
{
  int result; // eax
  char s[72]; // [esp+10h] [ebp-48h] BYREF

  Com_sprintf(s, 0x40u, "maps/mp/gametypes/%s", *(const char **)(sv_gametype + 8));
  dword_879C788 = Scr_GetFunctionHandle(s, "main", 1);
  dword_879C78C = Scr_GetFunctionHandle("maps/mp/gametypes/_callbacksetup", "CodeCallback_StartGameType", 1);
  dword_879C790 = Scr_GetFunctionHandle("maps/mp/gametypes/_callbacksetup", "CodeCallback_PlayerConnect", 1);
  dword_879C794 = Scr_GetFunctionHandle("maps/mp/gametypes/_callbacksetup", "CodeCallback_PlayerDisconnect", 1);
  dword_879C798 = Scr_GetFunctionHandle("maps/mp/gametypes/_callbacksetup", "CodeCallback_PlayerDamage", 1);
  result = Scr_GetFunctionHandle("maps/mp/gametypes/_callbacksetup", "CodeCallback_PlayerKilled", 1);
  dword_879C79C = result;
  return result;
}
// 8793D80: using guessed type int sv_gametype;
// 879C788: using guessed type int dword_879C788;
// 879C78C: using guessed type int dword_879C78C;
// 879C790: using guessed type int dword_879C790;
// 879C794: using guessed type int dword_879C794;
// 879C798: using guessed type int dword_879C798;
// 879C79C: using guessed type int dword_879C79C;

//----- (0810DEE2) --------------------------------------------------------
int __usercall sub_810DEE2@<eax>(long double a1@<st0>)
{
  int result; // eax
  char *v2; // [esp+1Ch] [ebp-4Ch]
  char s[72]; // [esp+20h] [ebp-48h] BYREF

  v2 = Dvar_RegisterString(a1, "mapname", (char *)&byte_8153FCE, 4164);
  Com_sprintf(s, 0x40u, "maps/mp/%s", *((const char **)v2 + 2));
  result = Scr_GetFunctionHandle(s, "main", 0);
  dword_879C780 = result;
  return result;
}
// 879C780: using guessed type int dword_879C780;

//----- (0810DF4E) --------------------------------------------------------
int sub_810DF4E()
{
  int i; // [esp+4h] [ebp-4h]

  for ( i = 0; i <= 3; ++i )
    sub_807E13C(i);
  sub_81187B8();
  sub_810193A();
  return GScr_AddFieldsForRadiant();
}

//----- (0810DF86) --------------------------------------------------------
int __usercall GScr_LoadScripts@<eax>(long double a1@<st0>)
{
  sub_8075ABA();
  dword_879D82C = Scr_GetFunctionHandle("codescripts/delete", "main", 1);
  dword_879D830 = Scr_GetFunctionHandle("codescripts/struct", "initstructs", 1);
  dword_879D834 = Scr_GetFunctionHandle("codescripts/struct", "createstruct", 1);
  GScr_LoadGameTypeScript();
  sub_810DEE2(a1);
  sub_8075E10();
  sub_810DF4E();
  return sub_8075E1E();
}
// 879D82C: using guessed type int dword_879D82C;
// 879D830: using guessed type int dword_879D830;
// 879D834: using guessed type int dword_879D834;

//----- (0810E010) --------------------------------------------------------
int *sub_810E010()
{
  int *result; // eax
  int i; // [esp+4h] [ebp-4h] BYREF

  for ( i = 0; i <= 3; ++i )
  {
    sub_807E182(i);
    result = &i;
  }
  return result;
}

//----- (0810E03A) --------------------------------------------------------
int __cdecl Scr_EntityForRef(int a1)
{
  if ( !HIWORD(a1) )
    return 560 * (unsigned __int16)a1 + 140924032;
  Scr_ObjectError((int)"not an entity");
  return 0;
}

//----- (0810E074) --------------------------------------------------------
int __cdecl GetPlayerEntity(int a1)
{
  const char *v1; // eax
  char *v2; // eax
  const char *v4; // [esp+30h] [ebp-8h]
  int v5; // [esp+34h] [ebp-4h]

  v5 = Scr_EntityForRef(a1);
  if ( !*(_DWORD *)(v5 + 344) )
  {
    if ( *(_WORD *)(v5 + 364) )
      v4 = (const char *)SL_ConvertToString(*(unsigned __int16 *)(v5 + 364));
    else
      v4 = "<undefined>";
    v1 = (const char *)SL_ConvertToString(*(unsigned __int16 *)(v5 + 360));
    v2 = va(
           "only valid on players; called on entity %i at %.0f %.0f %.0f classname %s targetname %s\n",
           (unsigned __int16)a1,
           *(float *)(v5 + 312),
           *(float *)(v5 + 316),
           *(float *)(v5 + 320),
           v1,
           v4);
    Scr_Error((int)v2);
  }
  return v5;
}

//----- (0810E128) --------------------------------------------------------
int sub_810E128()
{
  return Scr_AddString("0");
}

//----- (0810E13C) --------------------------------------------------------
int sub_810E13C()
{
  return Scr_AddString((char *)&byte_8153FCE);
}

//----- (0810E150) --------------------------------------------------------
int sub_810E150()
{
  return Scr_AddString((char *)&byte_8153FCE);
}

//----- (0810E164) --------------------------------------------------------
int sub_810E164()
{
  return Scr_AddString((char *)&byte_8153FCE);
}

//----- (0810E178) --------------------------------------------------------
int sub_810E178()
{
  return Scr_AddString((char *)&byte_8153FCE);
}

//----- (0810E18C) --------------------------------------------------------
int sub_810E18C()
{
  int result; // eax
  const char *v1; // eax
  signed int i; // [esp+10h] [ebp-8h]
  int v3; // [esp+14h] [ebp-4h]

  result = g_no_script_spam;
  if ( !*(_BYTE *)(g_no_script_spam + 8) )
  {
    v3 = Scr_GetNumParam();
    for ( i = 0; ; ++i )
    {
      result = i;
      if ( i >= v3 )
        break;
      v1 = (const char *)sub_80845E4(i);
      Com_Printf("%s", v1);
    }
  }
  return result;
}
// 8793E30: using guessed type int g_no_script_spam;

//----- (0810E1DC) --------------------------------------------------------
void sub_810E1DC()
{
  if ( !*(_BYTE *)(g_no_script_spam + 8) )
  {
    sub_810E18C();
    Com_Printf("\n");
  }
}
// 8793E30: using guessed type int g_no_script_spam;

//----- (0810E202) --------------------------------------------------------
void __cdecl __noreturn sub_810E202(int a1, char *format)
{
  Com_Error(6, format);
}

//----- (0810E21E) --------------------------------------------------------
void __cdecl sub_810E21E(int a1, const char *a2, int a3)
{
  char *v3; // eax
  int i; // [esp+14h] [ebp-4h]

  if ( a3 > 1 )
  {
    for ( i = 0; i < a3; ++i )
    {
      if ( (*(_WORD *)(_ctype_b + 2 * a2[i]) & 8) == 0 && a2[i] != 95 )
      {
        v3 = va(
               "Illegal localized string reference: %s must contain only alpha-numeric characters and underscores",
               a2);
        Scr_ParamError(a1, (int)v3);
      }
    }
  }
}
// 8185A64: using guessed type int _ctype_b;
// 810E21E: using guessed type const char *arg_4;

//----- (0810E290) --------------------------------------------------------
int __cdecl Scr_ConstructMessageString(signed int a1, signed int a2, const char *a3, int a4, int a5)
{
  char *v5; // eax
  char *v6; // eax
  char *v7; // eax
  char *v8; // eax
  char *v9; // eax
  int result; // eax
  int v11; // [esp+18h] [ebp-20h]
  char v12; // [esp+1Fh] [ebp-19h]
  const char *s; // [esp+20h] [ebp-18h]
  int v14; // [esp+24h] [ebp-14h]
  int v15; // [esp+28h] [ebp-10h]
  int v16; // [esp+2Ch] [ebp-Ch]
  int i; // [esp+34h] [ebp-4h]
  int j; // [esp+34h] [ebp-4h]

  v12 = 1;
  v16 = 0;
  while ( a1 <= a2 )
  {
    v14 = Scr_GetType(a1);
    if ( v14 == 3 )
    {
      s = (const char *)Scr_GetIString(a1);
      v15 = strlen(s);
      sub_810E21E(a1, s, v15);
      if ( v16 + v15 + 1 >= a5 )
      {
        v5 = va("%s is too long. Max length is %i\n", a3, a5);
        Scr_ParamError(a1, (int)v5);
      }
      if ( v16 )
        *(_BYTE *)(a4 + v16++) = 20;
      v12 = 1;
    }
    else if ( v14 == 1 && Scr_GetPointerType(a1) == 21 )
    {
      v11 = Scr_GetEntity(a1);
      if ( !*(_DWORD *)(v11 + 344) )
        Scr_ParamError(a1, (int)"Entity is not a player");
      s = va("%s^7", (const char *)(*(_DWORD *)(v11 + 344) + 10116));
      v15 = strlen(s);
      if ( v16 + v15 + 1 >= a5 )
      {
        v6 = va("%s is too long. Max length is %i\n", a3, a5);
        Scr_ParamError(a1, (int)v6);
      }
      if ( v12 )
        *(_BYTE *)(a4 + v16++) = 21;
      v12 = 0;
    }
    else
    {
      s = (const char *)Scr_GetString(a1);
      v15 = strlen(s);
      for ( i = 0; i < v15; ++i )
      {
        if ( s[i] == 20 || s[i] == 21 || s[i] == 22 )
        {
          v7 = va("bad escape character (%i) present in string", s[i]);
          Scr_ParamError(a1, (int)v7);
        }
        if ( (*(_WORD *)(_ctype_b + 2 * s[i]) & 0x400) != 0 )
        {
          if ( *(_BYTE *)(loc_warningsAsErrors + 8) )
          {
            v8 = va("non-localized %s strings are not allowed to have letters in them: \"%s\"", a3, s);
            sub_810E202(a1, v8);
          }
          Com_Printf(
            "^3WARNING: Non-localized %s string is not allowed to have letters in it. Must be changed over to a localized"
            " string: \"%s\"\n",
            a3,
            s);
          break;
        }
      }
      if ( v16 + v15 + 1 >= a5 )
      {
        v9 = va("%s is too long. Max length is %i\n", a3, a5);
        Scr_ParamError(a1, (int)v9);
      }
      if ( v12 )
        *(_BYTE *)(a4 + v16++) = 21;
      v12 = 0;
    }
    for ( j = 0; j < v15; ++j )
    {
      if ( s[j] == 20 || s[j] == 21 || s[j] == 22 )
        *(_BYTE *)(a4 + v16) = 46;
      else
        *(_BYTE *)(v16 + a4) = s[j];
      ++v16;
    }
    ++a1;
  }
  result = a4 + v16;
  *(_BYTE *)(a4 + v16) = 0;
  return result;
}
// 8185A64: using guessed type int _ctype_b;
// 8523150: using guessed type int loc_warningsAsErrors;
// 810E290: using guessed type const char *arg_8;

//----- (0810E5D8) --------------------------------------------------------
int __cdecl sub_810E5D8(int a1, const char *a2)
{
  int v2; // eax
  char *v3; // eax
  char v5[1032]; // [esp+20h] [ebp-408h] BYREF

  v2 = Scr_GetNumParam();
  Scr_ConstructMessageString(0, v2 - 1, "Game Message", (int)v5, 1024);
  v3 = va("%s \"%s\"", a2, v5);
  return SV_GameSendServerCommand(a1, 0, v3);
}

//----- (0810E64A) --------------------------------------------------------
int sub_810E64A()
{
  char *v0; // eax

  v0 = va("%c", 102);
  return sub_810E5D8(-1, v0);
}

//----- (0810E676) --------------------------------------------------------
int sub_810E676()
{
  char *v0; // eax

  v0 = va("%c", 103);
  return sub_810E5D8(-1, v0);
}

//----- (0810E6A2) --------------------------------------------------------
void sub_810E6A2()
{
  unsigned int v0; // [esp+18h] [ebp-50h]
  _DWORD v1[4]; // [esp+20h] [ebp-48h] BYREF
  int v2[3]; // [esp+30h] [ebp-38h] BYREF
  float v3; // [esp+3Ch] [ebp-2Ch]
  int v4; // [esp+4Ch] [ebp-1Ch]
  int v5[6]; // [esp+50h] [ebp-18h] BYREF

  v2[0] = 1065353216;
  v2[1] = 1065353216;
  v2[2] = 1065353216;
  v3 = 1.0;
  v0 = Scr_GetNumParam();
  if ( v0 == 3 )
    goto LABEL_8;
  if ( v0 > 3 )
  {
    if ( v0 == 4 )
    {
LABEL_7:
      v3 = Scr_GetFloat(3u);
LABEL_8:
      Scr_GetVector(2u, v1);
      Scr_VectorCopy(v1, v2);
      goto LABEL_9;
    }
LABEL_6:
    Scr_GetFloat(4u);
    goto LABEL_7;
  }
  if ( v0 != 2 )
    goto LABEL_6;
LABEL_9:
  v4 = Scr_GetString(1u);
  Scr_GetVector(0, v5);
  G_AddDebugString();
}
// 810E6A2: using guessed type _DWORD var_48[4];
// 810E6A2: using guessed type int var_18[6];

//----- (0810E780) --------------------------------------------------------
void assertCmd()
{
  if ( !Scr_GetInt(0) )
    Scr_Error((int)"assert fail");
}

//----- (0810E7A6) --------------------------------------------------------
void assertexCmd()
{
  const char *v0; // eax
  char *v1; // eax

  if ( !Scr_GetInt(0) )
  {
    v0 = (const char *)Scr_GetString(1u);
    v1 = va("assert fail: %s", v0);
    Scr_Error((int)v1);
  }
}

//----- (0810E7E4) --------------------------------------------------------
void assertmsgCmd()
{
  const char *v0; // eax
  char *v1; // eax

  v0 = (const char *)Scr_GetString(0);
  v1 = va("assert fail: %s", v0);
  Scr_Error((int)v1);
}

//----- (0810E810) --------------------------------------------------------
int GScr_IsDefined()
{
  int v1; // [esp+10h] [ebp-8h]
  int v2; // [esp+14h] [ebp-4h]
  int v3; // [esp+14h] [ebp-4h]

  v2 = Scr_GetType(0);
  if ( v2 != 1 )
    return Scr_AddInt(v2 != 0);
  v3 = Scr_GetPointerType(0);
  v1 = 0;
  if ( v3 <= 22 && v3 != 20 )
    v1 = 1;
  return Scr_AddInt(v1);
}

//----- (0810E876) --------------------------------------------------------
int GScr_IsString()
{
  int v0; // eax

  v0 = Scr_GetType(0);
  return Scr_AddInt(v0 == 2);
}

//----- (0810E89C) --------------------------------------------------------
int GScr_IsAlive()
{
  if ( Scr_GetType(0) == 1 && Scr_GetPointerType(0) == 21 && *(int *)(Scr_GetEntity(0) + 404) > 0 )
    return Scr_AddInt(1);
  else
    return Scr_AddInt(0);
}

//----- (0810E918) --------------------------------------------------------
int GScr_GetDvar()
{
  char *s; // [esp+10h] [ebp-8h]
  char *v2; // [esp+14h] [ebp-4h]

  v2 = (char *)Scr_GetString(0);
  s = Dvar_GetVariantString(v2);
  return Scr_AddString(s);
}

//----- (0810E948) --------------------------------------------------------
int GScr_GetDvarInt()
{
  int v0; // eax
  const char *nptr; // [esp+10h] [ebp-8h]
  char *v3; // [esp+14h] [ebp-4h]

  v3 = (char *)Scr_GetString(0);
  nptr = Dvar_GetVariantString(v3);
  v0 = atoi(nptr);
  return Scr_AddInt(v0);
}

//----- (0810E980) --------------------------------------------------------
int GScr_GetDvarFloat()
{
  int v1; // [esp+Ch] [ebp-Ch]
  const char *nptr; // [esp+10h] [ebp-8h]
  char *v3; // [esp+14h] [ebp-4h]

  v3 = (char *)Scr_GetString(0);
  nptr = Dvar_GetVariantString(v3);
  *(float *)&v1 = atof(nptr);
  return Scr_AddFloat(v1);
}

//----- (0810E9BE) --------------------------------------------------------
void __usercall GScr_SetDvar(long double a1@<st0>)
{
  int v1; // eax
  size_t v2; // eax
  char v3; // al
  char *v4; // eax
  int v5; // [esp+2Ch] [ebp-82Ch]
  int v6; // [esp+34h] [ebp-824h]
  char *s; // [esp+38h] [ebp-820h]
  char *src; // [esp+3Ch] [ebp-81Ch]
  char v9[1024]; // [esp+40h] [ebp-818h] BYREF
  char v10[1024]; // [esp+440h] [ebp-418h] BYREF
  char *v11; // [esp+840h] [ebp-18h]
  int v12; // [esp+844h] [ebp-14h]
  size_t v13; // [esp+848h] [ebp-10h]
  int v14; // [esp+84Ch] [ebp-Ch]

  src = (char *)Scr_GetString(0);
  v12 = Scr_GetType(1u);
  if ( v12 == 3 )
  {
    v1 = Scr_GetNumParam();
    Scr_ConstructMessageString(1, v1 - 1, "Dvar Value", (int)v10, 1024);
    s = v10;
    v2 = strlen(v10);
  }
  else
  {
    s = (char *)Scr_GetString(1u);
    v2 = strlen(s);
  }
  v13 = v2;
  v11 = v9;
  memset(v9, 0, sizeof(v9));
  v14 = 0;
  while ( v14 <= 0x1FFF && s[v14] )
  {
    v3 = I_CleanChar(s[v14]);
    *v11 = v3;
    if ( *v11 == 34 )
      *v11 = 39;
    ++v14;
    ++v11;
  }
  if ( (unsigned __int8)sub_80AEF62((int)src) )
  {
    v5 = 0;
    if ( (unsigned int)Scr_GetNumParam() > 2 && Scr_GetInt(2u) )
      v5 = 1;
    sub_80B2AC2(a1, src, s);
    if ( v5 )
    {
      v6 = Dvar_FindVar(src);
      Dvar_AddFlags(v6, 1024);
    }
  }
  else
  {
    v4 = va("Dvar %s has an invalid dvar name", src);
    Scr_Error((int)v4);
  }
}

//----- (0810EB8A) --------------------------------------------------------
int sub_810EB8A()
{
  return Scr_AddInt(dword_859B5EC);
}

//----- (0810EBA0) --------------------------------------------------------
unsigned int sub_810EBA0()
{
  unsigned int result; // eax
  unsigned int v1; // [esp+14h] [ebp-4h]

  result = Scr_GetInt(0);
  v1 = result;
  if ( result <= 0x3FF )
  {
    result = (unsigned int)&unk_8665480 + 560 * result;
    if ( *(_BYTE *)(result + 252) )
      return Scr_AddEntity((int *)&unk_8665480 + 140 * v1);
  }
  return result;
}

//----- (0810EBF0) --------------------------------------------------------
int Scr_GetWeaponModel()
{
  char *v0; // eax
  int v2; // eax
  int v3; // [esp+10h] [ebp-8h]
  char *s1; // [esp+14h] [ebp-4h]

  s1 = (char *)Scr_GetString(0);
  v3 = G_GetWeaponIndexForName(s1);
  if ( v3 )
  {
    v2 = BG_WeaponDefs(v3);
    return Scr_AddString(*(char **)(v2 + 436));
  }
  else
  {
    if ( *s1 )
    {
      if ( I_stricmp(s1, "none") )
      {
        v0 = va("unknown weapon '%s' in getWeaponModel\n", s1);
        Com_Printf(v0);
      }
    }
    return Scr_AddString((char *)&byte_8153FCE);
  }
}

//----- (0810EC7C) --------------------------------------------------------
int __cdecl sub_810EC7C(int a1)
{
  int v2; // eax
  int v3; // [esp+Ch] [ebp-Ch]
  int v4; // [esp+10h] [ebp-8h]
  char *s1; // [esp+14h] [ebp-4h]

  v3 = GetPlayerEntity(a1);
  s1 = (char *)Scr_GetString(0);
  v4 = G_GetWeaponIndexForName(s1);
  if ( !v4 )
    return Scr_AddInt(0);
  v2 = sub_80EACC8(*(_DWORD *)(v3 + 344), v4);
  return Scr_AddInt(v2);
}

//----- (0810ECE4) --------------------------------------------------------
int GScr_GetAnimLength()
{
  int v1; // [esp+0h] [ebp-18h]
  int v2; // [esp+Ch] [ebp-Ch] BYREF
  int v3; // [esp+10h] [ebp-8h]
  int v4; // [esp+14h] [ebp-4h]

  Scr_GetAnim((unsigned __int16 *)&v2, 0, 0);
  v4 = v2;
  v3 = Scr_GetAnims(HIWORD(v2));
  if ( !sub_80C00CA(v3, (unsigned __int16)v4) )
    Scr_ParamError(0, (int)"non-primitive animation has no concept of length");
  *(float *)&v1 = sub_80BE760(v3, (unsigned __int16)v4);
  return Scr_AddFloat(v1);
}

//----- (0810ED66) --------------------------------------------------------
int GScr_AnimHasNotetrack()
{
  int v0; // eax
  unsigned __int8 v1; // al
  int v3; // [esp+Ch] [ebp-Ch] BYREF
  unsigned __int16 v4; // [esp+12h] [ebp-6h]
  int v5; // [esp+14h] [ebp-4h]

  Scr_GetAnim((unsigned __int16 *)&v3, 0, 0);
  v5 = v3;
  v4 = Scr_GetConstString(1u);
  v0 = Scr_GetAnims(HIWORD(v5));
  v1 = sub_80C044E(v0, (unsigned __int16)v5, v4);
  return Scr_AddBool(v1);
}
// 810ED66: using guessed type int var_C;

//----- (0810EDD4) --------------------------------------------------------
_DWORD *sub_810EDD4()
{
  int v1; // [esp+1Ch] [ebp-1Ch]
  int v2[6]; // [esp+20h] [ebp-18h] BYREF

  v1 = Scr_GetEntity(0);
  sub_811623A((float *)(v1 + 288), (float *)(v1 + 300), (float *)v2);
  sub_81162C2((float *)v2, 0.5, (float *)v2);
  return Scr_AddVector(v2);
}

//----- (0810EE34) --------------------------------------------------------
void __usercall GScr_Spawn(long double a1@<st0>)
{
  const char *v1; // eax
  char *v2; // eax
  int v3; // [esp+18h] [ebp-30h]
  int v4; // [esp+1Ch] [ebp-2Ch]
  _DWORD v5[7]; // [esp+20h] [ebp-28h] BYREF
  unsigned __int16 v6; // [esp+3Eh] [ebp-Ah]

  v6 = Scr_GetConstString(0);
  Scr_GetVector(1u, v5);
  if ( (unsigned int)Scr_GetNumParam() <= 2 )
    v3 = 0;
  else
    v3 = Scr_GetInt(2u);
  v4 = G_Spawn();
  Scr_SetString((_WORD *)(v4 + 360), v6);
  Scr_VectorCopy(v5, (_DWORD *)(v4 + 312));
  *(_DWORD *)(v4 + 368) = v3;
  if ( G_CallSpawnEntity(a1, v4) )
  {
    Scr_AddEntity((int *)v4);
  }
  else
  {
    v1 = (const char *)SL_ConvertToString(v6);
    v2 = va("unable to spawn \"%s\" entity", v1);
    Scr_Error((int)v2);
  }
}
// 810EE34: using guessed type _DWORD var_28[7];

//----- (0810EF04) --------------------------------------------------------
int GScr_SpawnTurret()
{
  char *v1; // [esp+18h] [ebp-30h]
  int v2; // [esp+1Ch] [ebp-2Ch]
  _DWORD v3[7]; // [esp+20h] [ebp-28h] BYREF
  unsigned __int16 v4; // [esp+3Eh] [ebp-Ah]

  v4 = Scr_GetConstString(0);
  Scr_GetVector(1u, v3);
  v1 = (char *)Scr_GetString(2u);
  v2 = G_Spawn();
  Scr_SetString((_WORD *)(v2 + 360), v4);
  Scr_VectorCopy(v3, (_DWORD *)(v2 + 312));
  G_SpawnTurret(v2, v1);
  return Scr_AddEntity((int *)v2);
}
// 810EF04: using guessed type _DWORD var_28[7];

//----- (0810EF92) --------------------------------------------------------
int GScr_PrecacheTurret()
{
  char *s1; // [esp+4h] [ebp-4h]

  if ( !dword_859B41C )
    Scr_Error((int)"precacheTurret must be called before any wait statements in the level script\n");
  s1 = (char *)Scr_GetString(0);
  return G_GetWeaponIndexForName(s1);
}

//----- (0810EFCA) --------------------------------------------------------
void __usercall ScrCmd_attach(long double a1@<st0>, int a2)
{
  const char *v2; // eax
  char *v3; // eax
  int v4; // [esp+10h] [ebp-18h]
  int v5; // [esp+14h] [ebp-14h]
  char *s2; // [esp+20h] [ebp-8h]
  int v7; // [esp+24h] [ebp-4h]

  v7 = Scr_EntityForRef(a2);
  s2 = (char *)Scr_GetString(0);
  if ( (unsigned int)Scr_GetNumParam() <= 1 )
    v5 = (unsigned __int16)word_87A22A0;
  else
    v5 = sub_8084434(1u);
  if ( (unsigned int)Scr_GetNumParam() <= 2 )
    v4 = 0;
  else
    v4 = Scr_GetInt(2u);
  if ( sub_811B528(a1, v7, s2, v5) )
  {
    v2 = (const char *)SL_ConvertToString(v5);
    v3 = va("model '%s' already attached to tag '%s'", s2, v2);
    Scr_Error((int)v3);
  }
  if ( !sub_811B470(a1, v7, s2, v5, v4) )
    Scr_Error((int)"maximum attached models exceeded");
}
// 87A22A0: using guessed type __int16 word_87A22A0;

//----- (0810F0BA) --------------------------------------------------------
void __usercall ScrCmd_detach(long double a1@<st0>, int a2)
{
  const char *v2; // ebx
  const char *v3; // eax
  const char *v4; // eax
  char *v5; // eax
  int v6; // [esp+10h] [ebp-18h]
  int i; // [esp+14h] [ebp-14h]
  char *s2; // [esp+1Ch] [ebp-Ch]
  int v9; // [esp+20h] [ebp-8h]

  v9 = Scr_EntityForRef(a2);
  s2 = (char *)Scr_GetString(0);
  if ( (unsigned int)Scr_GetNumParam() <= 1 )
    v6 = (unsigned __int16)word_87A22A0;
  else
    v6 = sub_8084434(1u);
  if ( !sub_811B528(a1, v9, s2, v6) )
  {
    Com_Printf("Current attachments:\n");
    for ( i = 0; i <= 6; ++i )
    {
      if ( *(_BYTE *)(i + v9 + 528) )
      {
        if ( *(_WORD *)(v9 + 2 * i + 536) )
        {
          v2 = (const char *)SL_ConvertToString(*(unsigned __int16 *)(v9 + 2 * i + 536));
          v3 = G_ModelName(*(unsigned __int8 *)(i + v9 + 528));
          Com_Printf("model: '%s', tag: '%s'\n", v3, v2);
        }
      }
    }
    v4 = (const char *)SL_ConvertToString(v6);
    v5 = va("failed to detach model '%s' from tag '%s'", s2, v4);
    Scr_Error((int)v5);
  }
}
// 87A22A0: using guessed type __int16 word_87A22A0;

//----- (0810F1E4) --------------------------------------------------------
_DWORD *__usercall sub_810F1E4@<eax>(long double a1@<st0>, int a2)
{
  int v3; // [esp+4h] [ebp-4h]

  v3 = Scr_EntityForRef(a2);
  return sub_811B6C2(a1, v3);
}

//----- (0810F206) --------------------------------------------------------
int __cdecl sub_810F206(int a1)
{
  int v2; // [esp+10h] [ebp-8h]
  int i; // [esp+14h] [ebp-4h]

  v2 = Scr_EntityForRef(a1);
  for ( i = 0; i <= 6 && *(_BYTE *)(i + v2 + 528); ++i )
    ;
  return Scr_AddInt(i);
}

//----- (0810F250) --------------------------------------------------------
int __cdecl ScrCmd_GetAttachModelName(int a1)
{
  char *v1; // eax
  int v3; // [esp+10h] [ebp-8h]
  unsigned int v4; // [esp+14h] [ebp-4h]

  v3 = Scr_EntityForRef(a1);
  v4 = Scr_GetInt(0);
  if ( v4 > 6 || !*(_BYTE *)(v4 + v3 + 528) )
    Scr_ParamError(0, (int)"bad index");
  v1 = (char *)G_ModelName(*(unsigned __int8 *)(v4 + v3 + 528));
  return Scr_AddString(v1);
}

//----- (0810F2BE) --------------------------------------------------------
int __cdecl ScrCmd_GetAttachTagName(int a1)
{
  int v2; // [esp+10h] [ebp-8h]
  unsigned int v3; // [esp+14h] [ebp-4h]

  v2 = Scr_EntityForRef(a1);
  v3 = Scr_GetInt(0);
  if ( v3 > 6 || !*(_BYTE *)(v3 + v2 + 528) )
    Scr_ParamError(0, (int)"bad index");
  return Scr_AddConstString(*(unsigned __int16 *)(v2 + 2 * v3 + 536));
}

//----- (0810F324) --------------------------------------------------------
int __cdecl ScrCmd_GetAttachIgnoreCollision(int a1)
{
  int v2; // [esp+10h] [ebp-8h]
  unsigned int v3; // [esp+14h] [ebp-4h]

  v2 = Scr_EntityForRef(a1);
  v3 = Scr_GetInt(0);
  if ( v3 > 6 || !*(_BYTE *)(v3 + v2 + 528) )
    Scr_ParamError(0, (int)"bad index");
  return Scr_AddBool(((int)*(unsigned __int8 *)(v2 + 357) >> v3) & 1);
}

//----- (0810F392) --------------------------------------------------------
void __usercall ScrCmd_LinkTo(long double a1@<st0>, int a2)
{
  const char *v2; // eax
  char *v3; // eax
  const char *v4; // eax
  char *v5; // eax
  const char *v6; // ebx
  const char *v7; // eax
  char *v8; // eax
  float v9[4]; // [esp+20h] [ebp-38h] BYREF
  _DWORD v10[4]; // [esp+30h] [ebp-28h] BYREF
  int v11; // [esp+40h] [ebp-18h]
  int v12; // [esp+44h] [ebp-14h]
  int *v13; // [esp+48h] [ebp-10h]
  int *v14; // [esp+4Ch] [ebp-Ch]

  v14 = (int *)Scr_EntityForRef(a2);
  if ( Scr_GetType(0) != 1 || Scr_GetPointerType(0) != 21 )
    Scr_ParamError(0, (int)"not an entity");
  if ( (v14[93] & 0x1000) == 0 )
  {
    v2 = (const char *)SL_ConvertToString(*((unsigned __int16 *)v14 + 180));
    v3 = va("entity (classname: '%s') does not currently support linkTo", v2);
    Scr_ObjectError((int)v3);
  }
  v13 = (int *)Scr_GetEntity(0);
  v11 = Scr_GetNumParam();
  v12 = 0;
  if ( v11 > 1 )
  {
    v12 = sub_8084434(1u);
    if ( !*(_BYTE *)SL_ConvertToString(v12) )
      v12 = 0;
  }
  if ( v11 > 2 )
  {
    Scr_GetVector(2u, v10);
    Scr_GetVector(3u, v9);
    if ( sub_811B8BA(a1, v14, v13, v12, v10, v9) )
      return;
  }
  else if ( sub_811B86E(a1, v14, v13, v12) )
  {
    return;
  }
  if ( !SV_DObjExists(v13) )
  {
    if ( !*((_BYTE *)v13 + 356) )
      Scr_Error((int)"failed to link entity since parent has no model");
    v4 = G_ModelName(*((unsigned __int8 *)v13 + 356));
    v5 = va("failed to link entity since parent model '%s' is invalid", v4);
    Scr_Error((int)v5);
  }
  if ( v12 )
  {
    if ( sub_8090898(v13, v12) < 0 )
    {
      SV_DObjDumpInfo(v13);
      v6 = G_ModelName(*((unsigned __int8 *)v13 + 356));
      v7 = (const char *)SL_ConvertToString(v12);
      v8 = va("failed to link entity since tag '%s' does not exist in parent model '%s'", v7, v6);
      Scr_Error((int)v8);
    }
  }
  Scr_Error((int)"failed to link entity due to link cycle");
}
// 810F392: using guessed type _DWORD var_28[4];
// 810F392: using guessed type float var_38[4];

//----- (0810F5A8) --------------------------------------------------------
int __usercall ScrCmd_Unlink@<eax>(long double a1@<st0>, int a2)
{
  _DWORD *v3; // [esp+4h] [ebp-4h]

  v3 = (_DWORD *)Scr_EntityForRef(a2);
  return G_EntUnlink(a1, v3);
}

//----- (0810F5CA) --------------------------------------------------------
int __cdecl ScrCmd_EnableLinkTo(int a1)
{
  const char *v1; // eax
  char *v2; // eax
  int result; // eax
  int v4; // [esp+14h] [ebp-4h]

  v4 = Scr_EntityForRef(a1);
  if ( (*(_DWORD *)(v4 + 372) & 0x1000) != 0 )
    Scr_ObjectError((int)"entity already has linkTo enabled");
  if ( *(_DWORD *)(v4 + 4) || *(_BYTE *)(v4 + 352) )
  {
    v1 = (const char *)SL_ConvertToString(*(unsigned __int16 *)(v4 + 360));
    v2 = va("entity (classname: '%s') does not currently support enableLinkTo", v1);
    Scr_ObjectError((int)v2);
  }
  result = v4;
  *(_DWORD *)(v4 + 372) |= 0x1000u;
  return result;
}

//----- (0810F658) --------------------------------------------------------
_DWORD *__cdecl sub_810F658(int a1)
{
  _DWORD v2[7]; // [esp+10h] [ebp-28h] BYREF
  int v3; // [esp+2Ch] [ebp-Ch]

  v3 = Scr_EntityForRef(a1);
  Scr_VectorCopy((_DWORD *)(v3 + 312), v2);
  return Scr_AddVector(v2);
}
// 810F658: using guessed type _DWORD var_28[7];

//----- (0810F690) --------------------------------------------------------
_DWORD *__cdecl sub_810F690(int a1)
{
  _DWORD v2[2]; // [esp+10h] [ebp-28h] BYREF
  float v3; // [esp+18h] [ebp-20h]
  int v4; // [esp+2Ch] [ebp-Ch]

  v4 = Scr_EntityForRef(a1);
  Scr_VectorCopy((_DWORD *)(v4 + 312), v2);
  v3 = v3 + 40.0;
  return Scr_AddVector(v2);
}
// 810F690: using guessed type _DWORD var_28[2];

//----- (0810F6D6) --------------------------------------------------------
int (__cdecl *__cdecl sub_810F6D6(int a1))(int, int *, int *)
{
  int (__cdecl *result)(int, int *, int *); // eax
  int *v2; // [esp+10h] [ebp-8h]
  int v3; // [esp+14h] [ebp-4h]

  v3 = Scr_EntityForRef(a1);
  v2 = (int *)Scr_GetEntity(0);
  Scr_AddEntity(v2);
  Scr_Notify((int *)v3, word_87A22F4, 1);
  result = (int (__cdecl *)(int, int *, int *))dword_8167890[10 * *(unsigned __int8 *)(v3 + 358)];
  if ( result )
    return (int (__cdecl *)(int, int *, int *))result(v3, v2, v2);
  return result;
}
// 8167890: using guessed type int dword_8167890[];
// 87A22F4: using guessed type __int16 word_87A22F4;

//----- (0810F760) --------------------------------------------------------
int __usercall sub_810F760@<eax>(long double a1@<st0>, int a2)
{
  int v3; // [esp+1Ch] [ebp-3Ch]
  float v4[4]; // [esp+20h] [ebp-38h] BYREF
  float v5[5]; // [esp+30h] [ebp-28h] BYREF
  int v6; // [esp+44h] [ebp-14h]
  int v7; // [esp+48h] [ebp-10h]
  int v8; // [esp+4Ch] [ebp-Ch]

  v8 = Scr_EntityForRef(a2);
  if ( *(_BYTE *)(v8 + 241) || (*(_BYTE *)(v8 + 242) & 0x60) != 0 )
  {
    v6 = v8;
    v8 = Scr_GetEntity(0);
    if ( *(_BYTE *)(v8 + 241) || (*(_BYTE *)(v8 + 242) & 0x60) != 0 )
      Scr_Error((int)"istouching cannot be called on 2 brush/cylinder entities");
    v7 = v6;
  }
  else
  {
    v7 = Scr_GetEntity(0);
  }
  sub_811623A((float *)(v8 + 312), (float *)(v8 + 260), v5);
  sub_811623A((float *)(v8 + 312), (float *)(v8 + 272), v4);
  sub_80A6450(a1, v5, v4);
  v3 = sub_80901C2(v5, v4, v7);
  return Scr_AddInt(v3);
}
// 810F760: using guessed type float var_28[5];
// 810F760: using guessed type float var_38[4];

//----- (0810F872) --------------------------------------------------------
int sub_810F872()
{
  int v0; // eax
  char *v2; // [esp+4h] [ebp-4h]

  v2 = (char *)Scr_GetString(0);
  v0 = sub_80AA8AA(v2);
  return Scr_AddBool(v0 != 0);
}

//----- (0810F8A4) --------------------------------------------------------
int __cdecl sub_810F8A4(int a1)
{
  _DWORD *v1; // eax
  _DWORD *v2; // edx
  int result; // eax
  unsigned __int8 v4; // [esp+Fh] [ebp-9h]
  char *s2; // [esp+10h] [ebp-8h]
  int v6; // [esp+14h] [ebp-4h]

  v6 = Scr_EntityForRef(a1);
  s2 = (char *)Scr_GetString(0);
  v4 = sub_811B1D8(s2);
  v1 = G_TempEntity((_DWORD *)(v6 + 312), 179);
  *((_BYTE *)v1 + 242) |= 8u;
  v2 = v1;
  result = v4;
  v2[40] = v4;
  return result;
}

//----- (0810F914) --------------------------------------------------------
int __cdecl sub_810F914(int a1)
{
  _DWORD *v1; // eax
  _DWORD *v2; // edx
  int result; // eax
  unsigned __int8 v4; // [esp+Fh] [ebp-9h]
  char *s2; // [esp+10h] [ebp-8h]
  int v6; // [esp+14h] [ebp-4h]

  v6 = Scr_EntityForRef(a1);
  s2 = (char *)Scr_GetString(0);
  v4 = sub_811B1D8(s2);
  v1 = G_TempEntity((_DWORD *)(v6 + 312), 180);
  *((_BYTE *)v1 + 242) |= 8u;
  v2 = v1;
  result = v4;
  v2[40] = v4;
  return result;
}

//----- (0810F984) --------------------------------------------------------
int __cdecl sub_810F984(int a1)
{
  int result; // eax
  char *s2; // [esp+10h] [ebp-8h]
  int v3; // [esp+14h] [ebp-4h]

  v3 = Scr_EntityForRef(a1);
  s2 = (char *)Scr_GetString(0);
  LOBYTE(result) = sub_811B1D8(s2);
  *(_DWORD *)(v3 + 256) = -1;
  result = (unsigned __int8)result;
  *(_DWORD *)(v3 + 132) = (unsigned __int8)result;
  return result;
}

//----- (0810F9D2) --------------------------------------------------------
int __cdecl sub_810F9D2(int a1)
{
  int result; // eax

  result = Scr_EntityForRef(a1);
  *(_DWORD *)(result + 256) = dword_859B5EC + 300;
  *(_DWORD *)(result + 132) = 0;
  return result;
}

//----- (0810FA1A) --------------------------------------------------------
int __usercall sub_810FA1A@<eax>(long double a1@<st0>, int a2)
{
  int *s; // [esp+14h] [ebp-4h]

  s = (int *)Scr_EntityForRef(a2);
  if ( s[86] )
    Scr_Error((int)"Cannot delete a client entity");
  if ( dword_859EA04 == *s )
    Scr_Error((int)"Cannot delete entity during its think");
  Scr_Notify(s, word_87A22AA, 0);
  return G_FreeEntity(a1, s);
}
// 859EA04: using guessed type int dword_859EA04;
// 87A22AA: using guessed type __int16 word_87A22AA;

//----- (0810FA8A) --------------------------------------------------------
int __usercall sub_810FA8A@<eax>(long double a1@<st0>, int a2)
{
  char *s2; // [esp+10h] [ebp-8h]
  int v4; // [esp+14h] [ebp-4h]

  v4 = Scr_EntityForRef(a2);
  s2 = (char *)Scr_GetString(0);
  sub_811B3EA(v4, s2);
  sub_811B20E(a1, v4);
  return SV_LinkEntity(v4);
}

//----- (0810FAD8) --------------------------------------------------------
int __cdecl sub_810FAD8(int a1)
{
  int v2; // [esp+0h] [ebp-8h]
  int v3; // [esp+0h] [ebp-8h]
  int v4; // [esp+4h] [ebp-4h]

  v4 = Scr_EntityForRef(a1);
  if ( *(_DWORD *)(v4 + 344) )
  {
    if ( *(_DWORD *)(v4 + 404) )
    {
      *(float *)&v2 = (long double)*(int *)(v4 + 404) / (long double)*(int *)(*(_DWORD *)(v4 + 344) + 10024);
      return Scr_AddFloat(v2);
    }
    else
    {
      return Scr_AddFloat(0);
    }
  }
  else
  {
    *(float *)&v3 = (float)*(int *)(v4 + 404);
    return Scr_AddFloat(v3);
  }
}

//----- (0810FB4A) --------------------------------------------------------
void __cdecl ScrCmd_SetNormalHealth(int a1)
{
  char *v1; // eax
  float v2; // [esp+0h] [ebp-28h]
  int v3; // [esp+1Ch] [ebp-Ch]
  float v4; // [esp+20h] [ebp-8h]
  char *v5; // [esp+24h] [ebp-4h]

  v5 = (char *)Scr_EntityForRef(a1);
  v4 = Scr_GetFloat(0);
  if ( v4 > 1.0 )
    v4 = 1.0;
  if ( *((_DWORD *)v5 + 86) )
  {
    v2 = (long double)*(int *)(*((_DWORD *)v5 + 86) + 10024) * v4;
    v3 = floorf(v2);
    v1 = va("%c \"%i\"", 73, 0);
    SV_GameSendServerCommand(-1963413621 * ((v5 - (char *)&unk_8665480) >> 4), 0, v1);
  }
  else if ( *((_DWORD *)v5 + 102) )
  {
    v3 = (int)((long double)*((int *)v5 + 102) * v4);
  }
  else
  {
    v3 = (int)v4;
  }
  if ( v3 > 0 )
    *((_DWORD *)v5 + 101) = v3;
  else
    Com_Printf("ERROR: Cannot setnormalhealth to 0 or below.\n");
}

//----- (0810FC60) --------------------------------------------------------
_DWORD *__cdecl sub_810FC60(int a1)
{
  _DWORD *result; // eax

  result = (_DWORD *)Scr_EntityForRef(a1);
  result[93] &= ~0x800u;
  result[61] = 0;
  result[62] = 0;
  return result;
}

//----- (0810FCA8) --------------------------------------------------------
_DWORD *__cdecl sub_810FCA8(int a1)
{
  _DWORD *result; // eax

  result = (_DWORD *)Scr_EntityForRef(a1);
  result[93] |= 0x800u;
  result[61] = -1;
  result[62] = -1;
  return result;
}

//----- (0810FCF0) --------------------------------------------------------
void __cdecl ScrCmd_ShowToPlayer(int a1)
{
  int *v1; // [esp+4h] [ebp-14h]
  int v2; // [esp+8h] [ebp-10h]

  v2 = Scr_EntityForRef(a1);
  v1 = (int *)Scr_GetEntity(0);
  if ( *v1 <= 63 )
  {
    *(_DWORD *)(v2 + 372) &= ~0x800u;
    *(_DWORD *)(v2 + 4 * (*v1 >> 5) + 244) &= ~(1 << (*(_BYTE *)v1 & 0x1F));
  }
  else
  {
    Scr_Error((int)"showToClient error: param must be a client entity\n");
  }
}

//----- (0810FD84) --------------------------------------------------------
int __cdecl sub_810FD84(int a1)
{
  int v2; // [esp+10h] [ebp-8h]
  int v3; // [esp+14h] [ebp-4h]

  v3 = Scr_EntityForRef(a1);
  v2 = Scr_GetInt(0);
  Scr_AddInt(*(_DWORD *)(v3 + 284));
  *(_DWORD *)(v3 + 284) = v2;
  return SV_LinkEntity(v3);
}

//----- (0810FDD2) --------------------------------------------------------
int __cdecl Scr_SetStableMissile(int a1)
{
  int result; // eax
  unsigned int v2; // edx
  int v3; // [esp+10h] [ebp-8h]
  int v4; // [esp+14h] [ebp-4h]

  v4 = Scr_EntityForRef(a1);
  v3 = Scr_GetInt(0);
  if ( *(_DWORD *)(v4 + 4) != 1 )
    Scr_Error((int)"Type should be a player");
  result = v4;
  if ( v3 )
    v2 = *(_DWORD *)(v4 + 372) | 0x20000;
  else
    v2 = *(_DWORD *)(v4 + 372) & 0xFFFDFFFF;
  *(_DWORD *)(v4 + 372) = v2;
  return result;
}

//----- (0810FE44) --------------------------------------------------------
void __cdecl GScr_SetCursorHint(int a1)
{
  char *v1; // eax
  char *v2; // [esp+Ch] [ebp-Ch]
  int v3; // [esp+10h] [ebp-8h]
  int i; // [esp+14h] [ebp-4h]
  int j; // [esp+14h] [ebp-4h]

  v3 = Scr_EntityForRef(a1);
  v2 = (char *)Scr_GetString(0);
  if ( (*(_WORD *)(v3 + 360) == word_87A22F6 || *(_WORD *)(v3 + 360) == word_87A22F8)
    && !I_stricmp(v2, "HINT_INHERIT") )
  {
    *(_DWORD *)(v3 + 220) = -1;
  }
  else
  {
    for ( i = 1; i <= 132 && *(_DWORD *)&off_8167BA0[4 * i]; ++i )
    {
      if ( !I_stricmp(v2, *(char **)&off_8167BA0[4 * i]) )
      {
        *(_DWORD *)(v3 + 220) = i;
        return;
      }
    }
    Com_Printf("List of valid hint type strings\n");
    if ( *(_WORD *)(v3 + 360) == word_87A22F6 || *(_WORD *)(v3 + 360) == word_87A22F8 )
      Com_Printf("HINT_INHERIT (for trigger_use or trigger_use_touch entities only)\n");
    for ( j = 1; j <= 132 && *(_DWORD *)&off_8167BA0[4 * j]; ++j )
      Com_Printf("%s\n", *(const char **)&off_8167BA0[4 * j]);
    v1 = va("%s is not a valid hint type. See above for list of valid hint types\n", v2);
    Scr_Error((int)v1);
  }
}
// 87A22F6: using guessed type __int16 word_87A22F6;
// 87A22F8: using guessed type __int16 word_87A22F8;

//----- (0810FFAA) --------------------------------------------------------
int __cdecl sub_810FFAA(_DWORD *a1, char *s1)
{
  char s2[1036]; // [esp+20h] [ebp-418h] BYREF
  int i; // [esp+42Ch] [ebp-Ch]

  for ( i = 0; i <= 31; ++i )
  {
    SV_GetConfigstring(i + 1278, s2, 1024);
    if ( !s2[0] )
    {
      SV_SetConfigstring(i + 1278, s1);
      *a1 = i;
      return 1;
    }
    if ( !strcmp(s1, s2) )
    {
      *a1 = i;
      return 1;
    }
  }
  *a1 = -1;
  return 0;
}

//----- (0811006E) --------------------------------------------------------
int __cdecl GScr_SetHintString(int a1)
{
  char *v1; // eax
  int result; // eax
  int v3; // eax
  char *v4; // eax
  char s1[1028]; // [esp+20h] [ebp-418h] BYREF
  int v6; // [esp+424h] [ebp-14h]
  int v7; // [esp+428h] [ebp-10h]
  int v8[3]; // [esp+42Ch] [ebp-Ch] BYREF

  v6 = Scr_EntityForRef(a1);
  if ( *(_WORD *)(v6 + 360) != word_87A22F6 && *(_WORD *)(v6 + 360) != word_87A22F8 )
    Scr_Error((int)"The setHintString command only works on trigger_use or trigger_use_touch entities.\n");
  v7 = Scr_GetType(0);
  if ( v7 != 2 || (v1 = (char *)Scr_GetString(0), I_stricmp(v1, (char *)&byte_8153FCE)) )
  {
    v3 = Scr_GetNumParam();
    Scr_ConstructMessageString(0, v3 - 1, "Hint String", (int)s1, 1024);
    if ( !sub_810FFAA(v8, s1) )
    {
      v4 = va("Too many different hintstring values. Max allowed is %i different strings", 32);
      Scr_Error((int)v4);
    }
    result = LOBYTE(v8[0]);
    *(_DWORD *)(v6 + 216) = LOBYTE(v8[0]);
  }
  else
  {
    result = v6;
    *(_DWORD *)(v6 + 216) = 255;
  }
  return result;
}
// 87A22F6: using guessed type __int16 word_87A22F6;
// 87A22F8: using guessed type __int16 word_87A22F8;
// 811006E: using guessed type int var_C[3];

//----- (08110172) --------------------------------------------------------
int __cdecl sub_8110172(int a1)
{
  int *v2; // [esp+4h] [ebp-4h]

  v2 = (int *)Scr_EntityForRef(a1);
  return Scr_AddInt(*v2);
}

//----- (08110196) --------------------------------------------------------
int __cdecl GScr_EnableGrenadeTouchDamage(int a1)
{
  int result; // eax
  int v2; // [esp+4h] [ebp-4h]

  v2 = Scr_EntityForRef(a1);
  if ( *(_WORD *)(v2 + 360) != word_87A22FA )
    Scr_Error((int)"Currently on supported on damage triggers");
  result = v2;
  *(_DWORD *)(v2 + 372) |= 0x4000u;
  return result;
}
// 87A22FA: using guessed type __int16 word_87A22FA;

//----- (081101E4) --------------------------------------------------------
int __cdecl GScr_DisableGrenadeTouchDamage(int a1)
{
  int result; // eax
  int v2; // [esp+4h] [ebp-4h]

  v2 = Scr_EntityForRef(a1);
  if ( *(_WORD *)(v2 + 360) != word_87A22FA )
    Scr_Error((int)"Currently on supported on damage triggers");
  result = v2;
  *(_DWORD *)(v2 + 372) &= ~0x4000u;
  return result;
}
// 87A22FA: using guessed type __int16 word_87A22FA;

//----- (08110232) --------------------------------------------------------
unsigned int __cdecl sub_8110232(int a1)
{
  int v1; // edx
  unsigned int result; // eax

  v1 = Scr_EntityForRef(a1);
  result = *(_DWORD *)(v1 + 372) & 0xFFFF7FFF;
  *(_DWORD *)(v1 + 372) = result;
  return result;
}

//----- (08110260) --------------------------------------------------------
int __cdecl sub_8110260(int a1)
{
  int v1; // edx
  int result; // eax

  v1 = Scr_EntityForRef(a1);
  result = *(_DWORD *)(v1 + 372) | 0x8000;
  *(_DWORD *)(v1 + 372) = result;
  return result;
}

//----- (0811028E) --------------------------------------------------------
int __cdecl GScr_EnableAimAssist(int a1)
{
  int result; // eax
  int v2; // [esp+4h] [ebp-4h]

  v2 = Scr_EntityForRef(a1);
  if ( !*(_BYTE *)(v2 + 241) )
    Scr_Error((int)"Currently only supported on entities with brush models");
  result = v2;
  *(_DWORD *)(v2 + 8) |= 0x800u;
  return result;
}

//----- (081102CE) --------------------------------------------------------
int __cdecl GScr_DisableAimAssist(int a1)
{
  int result; // eax
  int v2; // [esp+4h] [ebp-4h]

  v2 = Scr_EntityForRef(a1);
  if ( !*(_BYTE *)(v2 + 241) )
    Scr_Error((int)"Currently only supported on entities with brush models");
  result = v2;
  *(_DWORD *)(v2 + 8) &= ~0x800u;
  return result;
}

//----- (0811030E) --------------------------------------------------------
int *sub_811030E()
{
  int *result; // eax
  int i; // [esp+4h] [ebp-4h] BYREF

  for ( i = 0; i <= 15; ++i )
  {
    sub_8110408((_DWORD *)(28 * i + 140096548));
    result = &i;
  }
  return result;
}

//----- (08110346) --------------------------------------------------------
int __cdecl sub_8110346(_DWORD *a1, int a2)
{
  if ( a2 == (unsigned __int16)word_87A22B0 )
  {
    *a1 = 0;
    return 1;
  }
  if ( a2 == (unsigned __int16)word_87A22BE )
  {
    *a1 = 2;
    return 1;
  }
  if ( a2 == (unsigned __int16)word_87A22A6 )
  {
    *a1 = 4;
    return 1;
  }
  *a1 = 0;
  return 0;
}
// 87A22A6: using guessed type __int16 word_87A22A6;
// 87A22B0: using guessed type __int16 word_87A22B0;
// 87A22BE: using guessed type __int16 word_87A22BE;

//----- (081103B0) --------------------------------------------------------
int __cdecl sub_81103B0(int a1)
{
  int result; // eax
  char *v2; // [esp+0h] [ebp-4h]

  result = a1;
  if ( *(_DWORD *)(a1 + 16) != 1023 )
  {
    v2 = (char *)&unk_8665480 + 560 * *(_DWORD *)(a1 + 16);
    if ( v2[252] )
      v2[242] &= ~0x10u;
    result = a1;
    *(_DWORD *)(a1 + 16) = 1023;
  }
  return result;
}

//----- (08110408) --------------------------------------------------------
_DWORD *__cdecl sub_8110408(_DWORD *a1)
{
  _DWORD *result; // eax

  *a1 = 0;
  sub_81161BC(a1 + 1);
  a1[4] = 1023;
  a1[5] = 0;
  result = a1;
  a1[6] = 0;
  return result;
}

//----- (08110446) --------------------------------------------------------
int __cdecl SetObjectiveIcon(int a1, unsigned int a2)
{
  char *v2; // eax
  char *v3; // eax
  int result; // eax
  char *src; // [esp+1Ch] [ebp-Ch]
  int i; // [esp+20h] [ebp-8h]

  src = (char *)Scr_GetString(a2);
  for ( i = 0; src[i]; ++i )
  {
    if ( src[i] <= 31 || src[i] == 127 )
    {
      v2 = va(
             "Illegal character '%c'(ascii %i) in objective icon name: %s\n",
             src[i],
             (unsigned __int8)src[i],
             src);
      Scr_ParamError(3, (int)v2);
    }
  }
  if ( i > 63 )
  {
    v3 = va("Objective icon name is too long (> %i): %s\n", 63, src);
    Scr_ParamError(3, (int)v3);
  }
  result = sub_811AFBA(src);
  *(_DWORD *)(a1 + 24) = result;
  return result;
}

//----- (08110514) --------------------------------------------------------
int Scr_Objective_Add()
{
  char *v0; // eax
  const char *v1; // eax
  char *v2; // eax
  int result; // eax
  int v4; // [esp+14h] [ebp-14h] BYREF
  unsigned __int16 v5; // [esp+1Ah] [ebp-Eh]
  int v6; // [esp+1Ch] [ebp-Ch]
  char v7[4]; // [esp+20h] [ebp-8h]
  int v8; // [esp+24h] [ebp-4h]

  v8 = Scr_GetNumParam();
  if ( v8 <= 1 )
    Scr_Error((int)"objective_add needs at least the first two parameters out of its parameter list of: index state [st"
                     "ring] [position]\n");
  *(_DWORD *)v7 = Scr_GetInt(0);
  if ( *(_DWORD *)v7 >= 0x10u )
  {
    v0 = va("index %i is an illegal objective index. Valid indexes are 0 to %i\n", *(_DWORD *)v7, 15);
    Scr_ParamError(0, (int)v0);
  }
  v6 = 28 * *(_DWORD *)v7 + 140096548;
  sub_81103B0(v6);
  v5 = Scr_GetConstString(1u);
  if ( !sub_8110346(&v4, v5) )
  {
    v1 = (const char *)SL_ConvertToString(v5);
    v2 = va("Illegal objective state \"%s\". Valid states are \"empty\", \"invisible\", \"current\"\n", v1);
    Scr_ParamError(1, (int)v2);
  }
  *(_DWORD *)v6 = v4;
  if ( v8 > 2 )
  {
    Scr_GetVector(2u, (_DWORD *)(v6 + 4));
    *(float *)(v6 + 4) = (float)(int)*(float *)(v6 + 4);
    *(float *)(v6 + 8) = (float)(int)*(float *)(v6 + 8);
    *(float *)(v6 + 12) = (float)(int)*(float *)(v6 + 12);
    *(_DWORD *)(v6 + 16) = 1023;
    if ( v8 > 3 )
      SetObjectiveIcon(v6, 3u);
  }
  result = v6;
  *(_DWORD *)(v6 + 20) = 0;
  return result;
}
// 8110514: using guessed type int var_14;

//----- (081106B6) --------------------------------------------------------
_DWORD *Scr_Objective_Delete()
{
  char *v0; // eax
  unsigned int v2; // [esp+14h] [ebp-4h]

  v2 = Scr_GetInt(0);
  if ( v2 >= 0x10 )
  {
    v0 = va("index %i is an illegal objective index. Valid indexes are 0 to %i\n", v2, 15);
    Scr_ParamError(0, (int)v0);
  }
  sub_81103B0(28 * v2 + 140096548);
  return sub_8110408((_DWORD *)(28 * v2 + 140096548));
}

//----- (0811073A) --------------------------------------------------------
int Scr_Objective_State()
{
  char *v0; // eax
  const char *v1; // eax
  char *v2; // eax
  int result; // eax
  unsigned __int16 v4; // [esp+1Ah] [ebp-Eh]
  int v5; // [esp+1Ch] [ebp-Ch] BYREF
  _DWORD *v6; // [esp+20h] [ebp-8h]
  char v7[4]; // [esp+24h] [ebp-4h]

  *(_DWORD *)v7 = Scr_GetInt(0);
  if ( *(_DWORD *)v7 >= 0x10u )
  {
    v0 = va("index %i is an illegal objective index. Valid indexes are 0 to %i\n", *(_DWORD *)v7, 15);
    Scr_ParamError(0, (int)v0);
  }
  v6 = (_DWORD *)(28 * *(_DWORD *)v7 + 140096548);
  v4 = Scr_GetConstString(1u);
  if ( !sub_8110346(&v5, v4) )
  {
    v1 = (const char *)Scr_GetString(1u);
    v2 = va("Illegal objective state \"%s\". Valid states are \"empty\", \"invisible\", \"current\"\n", v1);
    Scr_ParamError(1, (int)v2);
  }
  result = v5;
  *v6 = v5;
  if ( !v5 || v5 == 2 )
    return sub_81103B0((int)v6);
  return result;
}

//----- (08110814) --------------------------------------------------------
int Scr_Objective_Icon()
{
  char *v0; // eax
  unsigned int v2; // [esp+14h] [ebp-4h]

  v2 = Scr_GetInt(0);
  if ( v2 >= 0x10 )
  {
    v0 = va("index %i is an illegal objective index. Valid indexes are 0 to %i\n", v2, 15);
    Scr_ParamError(0, (int)v0);
  }
  return SetObjectiveIcon(28 * v2 + 140096548, 1u);
}

//----- (08110886) --------------------------------------------------------
int sub_8110886()
{
  char *v0; // eax
  int result; // eax
  float *v2; // [esp+20h] [ebp-8h]
  unsigned int v3; // [esp+24h] [ebp-4h]

  v3 = Scr_GetInt(0);
  if ( v3 >= 0x10 )
  {
    v0 = va("index %i is an illegal objective index. Valid indexes are 0 to %i\n", v3, 15);
    Scr_ParamError(0, (int)v0);
  }
  v2 = (float *)(28 * v3 + 140096548);
  sub_81103B0((int)v2);
  Scr_GetVector(1u, (_DWORD *)(28 * v3 + 140096552));
  v2[1] = (float)(int)v2[1];
  v2[2] = (float)(int)v2[2];
  result = (int)*(float *)&dword_859B424[7 * v3 + 3];
  v2[3] = (float)result;
  return result;
}
// 859B424: using guessed type _DWORD dword_859B424[112];

//----- (0811097C) --------------------------------------------------------
int sub_811097C()
{
  char *v0; // eax
  int result; // eax
  int v2; // [esp+Ch] [ebp-Ch]
  unsigned int v3; // [esp+14h] [ebp-4h]

  v3 = Scr_GetInt(0);
  if ( v3 >= 0x10 )
  {
    v0 = va("index %i is an illegal objective index. Valid indexes are 0 to %i\n", v3, 15);
    Scr_ParamError(0, (int)v0);
  }
  sub_81103B0(28 * v3 + 140096548);
  v2 = Scr_GetEntity(1u);
  *(_BYTE *)(v2 + 242) |= 0x10u;
  result = *(_DWORD *)v2;
  dword_859B424[7 * v3 + 4] = *(_DWORD *)v2;
  return result;
}
// 859B424: using guessed type _DWORD dword_859B424[112];

//----- (08110A1C) --------------------------------------------------------
char *sub_8110A1C()
{
  char *result; // eax
  char *v1; // eax
  int s[16]; // [esp+10h] [ebp-58h] BYREF
  _DWORD *v3; // [esp+50h] [ebp-18h]
  char v4[4]; // [esp+54h] [ebp-14h] BYREF
  char *v5; // [esp+58h] [ebp-10h]
  char *i; // [esp+5Ch] [ebp-Ch]

  v5 = (char *)Scr_GetNumParam();
  memset(s, 0, sizeof(s));
  for ( i = 0; ; ++i )
  {
    result = i;
    if ( (int)i >= (int)v5 )
      break;
    *(_DWORD *)v4 = Scr_GetInt((unsigned int)i);
    if ( *(_DWORD *)v4 >= 0x10u )
    {
      v1 = va("index %i is an illegal objective index. Valid indexes are 0 to %i\n", *(_DWORD *)v4, 15);
      Scr_ParamError((int)i, (int)v1);
    }
    s[*(_DWORD *)v4] = 1;
  }
  *(_DWORD *)v4 = 0;
  while ( *(int *)v4 <= 15 )
  {
    v3 = (_DWORD *)(28 * *(_DWORD *)v4 + 140096548);
    if ( s[*(_DWORD *)v4] )
    {
      *v3 = 4;
    }
    else if ( *v3 == 4 )
    {
      *v3 = 1;
    }
    result = v4;
    ++*(_DWORD *)v4;
  }
  return result;
}
// 8110A1C: using guessed type int s[16];

//----- (08110B02) --------------------------------------------------------
void GScr_Objective_Team()
{
  char *v0; // eax
  const char *v1; // eax
  char *v2; // eax
  unsigned __int16 v3; // [esp+Eh] [ebp-Ah]
  unsigned int v4; // [esp+14h] [ebp-4h]

  v4 = Scr_GetInt(0);
  if ( v4 >= 0x10 )
  {
    v0 = va("index %i is an illegal objective index. Valid indexes are 0 to %i\n", v4, 15);
    Scr_ParamError(0, (int)v0);
  }
  v3 = Scr_GetConstString(1u);
  if ( v3 == word_87A22A2 )
  {
    dword_859B424[7 * v4 + 5] = 2;
  }
  else if ( v3 == word_87A22A4 )
  {
    dword_859B424[7 * v4 + 5] = 1;
  }
  else if ( v3 == word_87A2314 )
  {
    dword_859B424[7 * v4 + 5] = 0;
  }
  else
  {
    v1 = (const char *)SL_ConvertToString(v3);
    v2 = va("Illegal team string '%s'. Must be allies, axis, or none.", v1);
    Scr_ParamError(1, (int)v2);
  }
}
// 859B424: using guessed type _DWORD dword_859B424[112];
// 87A22A2: using guessed type __int16 word_87A22A2;
// 87A22A4: using guessed type __int16 word_87A22A4;
// 87A2314: using guessed type __int16 word_87A2314;

//----- (08110BEE) --------------------------------------------------------
void GScr_LogPrint()
{
  char *s; // [esp+1Ch] [ebp-41Ch]
  char format[1024]; // [esp+20h] [ebp-418h] BYREF
  size_t v2; // [esp+420h] [ebp-18h]
  int v3; // [esp+424h] [ebp-14h]
  int v4; // [esp+428h] [ebp-10h]
  signed int i; // [esp+42Ch] [ebp-Ch]

  format[0] = 0;
  v3 = 0;
  v4 = Scr_GetNumParam();
  for ( i = 0; i < v4; ++i )
  {
    s = (char *)Scr_GetString(i);
    v2 = strlen(s);
    if ( (int)(v3 + v2) > 1023 )
      break;
    I_strncat(format, 1024, s);
    v3 += v2;
  }
  G_LogPrintf(format);
}

//----- (08110C8C) --------------------------------------------------------
int GScr_WorldEntNumber()
{
  return Scr_AddInt(1022);
}

//----- (08110CA0) --------------------------------------------------------
int GScr_Obituary()
{
  int result; // eax
  _DWORD *v1; // [esp+10h] [ebp-18h]
  int v2; // [esp+14h] [ebp-14h]
  int v3; // [esp+18h] [ebp-10h]
  char *v4; // [esp+1Ch] [ebp-Ch]
  char *s1; // [esp+20h] [ebp-8h]
  _DWORD *v6; // [esp+24h] [ebp-4h]

  s1 = (char *)Scr_GetString(2u);
  v3 = G_GetWeaponIndexForName(s1);
  v4 = (char *)Scr_GetString(3u);
  v2 = G_IndexForMeansOfDeath(v4);
  v6 = (_DWORD *)Scr_GetEntity(0);
  v1 = G_TempEntity(flt_8145E68, 198);
  v1[29] = *v6;
  if ( Scr_GetType(1u) == 1 && Scr_GetPointerType(1u) == 21 )
    v1[30] = *(_DWORD *)Scr_GetEntity(1u);
  else
    v1[30] = 1022;
  *((_BYTE *)v1 + 242) = 8;
  if ( v2 == 7 || v2 == 8 || v2 == 12 || v2 == 11 || v2 == 9 )
  {
    result = v2 | 0x80;
    v1[40] = v2 | 0x80;
  }
  else
  {
    result = v3;
    v1[40] = v3;
  }
  return result;
}
// 8145E68: using guessed type float flt_8145E68[3];

//----- (08110DA4) --------------------------------------------------------
int sub_8110DA4()
{
  float v1[4]; // [esp+20h] [ebp-1058h] BYREF
  float v2[4]; // [esp+30h] [ebp-1048h] BYREF
  float v3[7]; // [esp+40h] [ebp-1038h] BYREF
  int v4; // [esp+5Ch] [ebp-101Ch]
  int v5[1026]; // [esp+60h] [ebp-1018h] BYREF
  int v6; // [esp+1068h] [ebp-10h]
  int i; // [esp+106Ch] [ebp-Ch]

  Scr_GetVector(0, v1);
  sub_811623A(v1, (float *)dword_8167700, v3);
  sub_811623A(v1, (float *)dword_816770C, v2);
  v6 = sub_805E782((int)v3, (int)v2, (int)v5, 1024, 0x2000000);
  for ( i = 0; i < v6; ++i )
  {
    v4 = (int)&unk_8665480 + 560 * v5[i];
    if ( *(_DWORD *)(v4 + 344) && *(int *)(*(_DWORD *)(v4 + 344) + 4) <= 5 )
      return Scr_AddInt(1);
  }
  return Scr_AddInt(0);
}
// 8167700: using guessed type _DWORD dword_8167700[3];
// 816770C: using guessed type _DWORD dword_816770C[3];
// 8110DA4: using guessed type float var_1058[4];
// 8110DA4: using guessed type float var_1038[7];
// 8110DA4: using guessed type float var_1048[4];
// 8110DA4: using guessed type int var_1018[1026];

//----- (08110EAC) --------------------------------------------------------
int sub_8110EAC()
{
  return Scr_AddInt(*(int *)dword_859B5F8);
}

//----- (08110EC2) --------------------------------------------------------
void GScr_PrecacheMenu()
{
  char *v0; // eax
  char dest[1032]; // [esp+10h] [ebp-418h] BYREF
  char *s1; // [esp+418h] [ebp-10h]
  int i; // [esp+41Ch] [ebp-Ch]

  s1 = (char *)Scr_GetString(0);
  for ( i = 0; i <= 31; ++i )
  {
    SV_GetConfigstring(i + 1246, dest, 1024);
    if ( !I_stricmp(dest, s1) )
    {
      Com_DPrintf("Script tried to precache the menu '%s' more than once\n", s1);
      return;
    }
  }
  for ( i = 0; i <= 31; ++i )
  {
    SV_GetConfigstring(i + 1246, dest, 1024);
    if ( !dest[0] )
      break;
  }
  if ( i == 32 )
  {
    v0 = va("Too many menus precached. Max allowed menus is %i", 32);
    Scr_Error((int)v0);
  }
  SV_SetConfigstring(i + 1246, s1);
}

//----- (08110FC2) --------------------------------------------------------
int __cdecl GScr_GetScriptMenuIndex(char *a1)
{
  char *v1; // eax
  char dest[1036]; // [esp+20h] [ebp-418h] BYREF
  int i; // [esp+42Ch] [ebp-Ch]

  for ( i = 0; i <= 31; ++i )
  {
    SV_GetConfigstring(i + 1246, dest, 1024);
    if ( !I_stricmp(dest, a1) )
      return i;
  }
  v1 = va("Menu '%s' was not precached\n", a1);
  Scr_Error((int)v1);
  return 0;
}

//----- (08111054) --------------------------------------------------------
void GScr_PrecacheStatusIcon()
{
  char *v0; // eax
  char dest[1032]; // [esp+10h] [ebp-418h] BYREF
  char *s1; // [esp+418h] [ebp-10h]
  int i; // [esp+41Ch] [ebp-Ch]

  s1 = (char *)Scr_GetString(0);
  for ( i = 0; i <= 7; ++i )
  {
    SV_GetConfigstring(i + 23, dest, 1024);
    if ( !I_stricmp(dest, s1) )
    {
      Com_DPrintf("Script tried to precache the player status icon '%s' more than once\n", s1);
      return;
    }
  }
  for ( i = 0; i <= 7; ++i )
  {
    SV_GetConfigstring(i + 23, dest, 1024);
    if ( !dest[0] )
      break;
  }
  if ( i == 8 )
  {
    v0 = va("Too many player status icons precached. Max allowed is %i", 8);
    Scr_Error((int)v0);
  }
  SV_SetConfigstring(i + 23, s1);
}

//----- (0811114A) --------------------------------------------------------
int __cdecl GScr_GetStatusIconIndex(char *a1)
{
  char *v1; // eax
  char dest[1036]; // [esp+20h] [ebp-418h] BYREF
  int i; // [esp+42Ch] [ebp-Ch]

  if ( !*a1 )
    return 0;
  for ( i = 0; i <= 7; ++i )
  {
    SV_GetConfigstring(i + 23, dest, 1024);
    if ( !I_stricmp(dest, a1) )
      return i + 1;
  }
  v1 = va("Status icon '%s' was not precached\n", a1);
  Scr_Error((int)v1);
  return 0;
}

//----- (081111F2) --------------------------------------------------------
void GScr_PrecacheHeadIcon()
{
  char *v0; // eax
  char dest[1032]; // [esp+10h] [ebp-418h] BYREF
  char *s1; // [esp+418h] [ebp-10h]
  int i; // [esp+41Ch] [ebp-Ch]

  s1 = (char *)Scr_GetString(0);
  for ( i = 0; i <= 14; ++i )
  {
    SV_GetConfigstring(i + 31, dest, 1024);
    if ( !I_stricmp(dest, s1) )
    {
      Com_DPrintf("Script tried to precache the player head icon '%s' more than once\n", s1);
      return;
    }
  }
  for ( i = 0; i <= 14; ++i )
  {
    SV_GetConfigstring(i + 31, dest, 1024);
    if ( !dest[0] )
      break;
  }
  if ( i == 15 )
  {
    v0 = va("Too many player head icons precached. Max allowed is %i", 15);
    Scr_Error((int)v0);
  }
  SV_SetConfigstring(i + 31, s1);
}

//----- (081112E8) --------------------------------------------------------
int __cdecl GScr_GetHeadIconIndex(char *a1)
{
  char *v1; // eax
  char dest[1036]; // [esp+20h] [ebp-418h] BYREF
  int i; // [esp+42Ch] [ebp-Ch]

  if ( !*a1 )
    return 0;
  for ( i = 0; i <= 14; ++i )
  {
    SV_GetConfigstring(i + 31, dest, 1024);
    if ( !I_stricmp(dest, a1) )
      return i + 1;
  }
  v1 = va("Head icon '%s' was not precached\n", a1);
  Scr_Error((int)v1);
  return 0;
}

//----- (08111390) --------------------------------------------------------
int sub_8111390()
{
  char *v0; // eax
  float v2[4]; // [esp+20h] [ebp-98h] BYREF
  int v3[7]; // [esp+30h] [ebp-88h] BYREF
  int v4; // [esp+4Ch] [ebp-6Ch]
  float s; // [esp+50h] [ebp-68h] BYREF
  _DWORD v6[6]; // [esp+54h] [ebp-64h] BYREF
  unsigned __int16 v7; // [esp+6Ch] [ebp-4Ch]
  int v8; // [esp+80h] [ebp-38h]
  int v9; // [esp+84h] [ebp-34h]
  int *v10; // [esp+88h] [ebp-30h]
  int v12[4]; // [esp+90h] [ebp-28h] BYREF
  int v13[6]; // [esp+A0h] [ebp-18h] BYREF

  v10 = 0;
  v9 = 1023;
  v8 = 41953329;
  Scr_GetVector(0, v13);
  Scr_GetVector(1u, v12);
  if ( !Scr_GetInt(2u) )
    v8 &= ~0x2000000u;
  if ( Scr_GetType(3u) == 1 && Scr_GetPointerType(3u) == 21 )
  {
    v10 = (int *)Scr_GetEntity(3u);
    v9 = *v10;
  }
  G_LocationalTrace(&s, (float *)v13, (float *)v12, v9, v8, 0);
  Scr_MakeArray();
  Scr_AddFloat(SLODWORD(s));
  sub_8084D6E((unsigned __int16)word_87A22B6);
  sub_80DEB7A((float *)v13, (float *)v12, s, (float *)v3);
  Scr_AddVector(v3);
  sub_8084D6E((unsigned __int16)word_87A22D4);
  if ( v7 == 1023 || v7 == 1022 )
    Scr_AddUndefined();
  else
    Scr_AddEntity((int *)(560 * v7 + 140924032));
  sub_8084D6E((unsigned __int16)word_87A22B2);
  if ( s >= 1.0 )
  {
    sub_811627E((float *)v12, (float *)v13, v2);
    Vec3Normalize(v2);
    Scr_AddVector(v2);
    sub_8084D6E((unsigned __int16)word_87A22CC);
    Scr_AddConstString((unsigned __int16)word_87A2314);
    return sub_8084D6E((unsigned __int16)word_87A22EC);
  }
  else
  {
    Scr_AddVector(v6);
    sub_8084D6E((unsigned __int16)word_87A22CC);
    v4 = (v6[3] & 0x1F00000) >> 20;
    v0 = (char *)sub_80B6EB2(v4);
    Scr_AddString(v0);
    return sub_8084D6E((unsigned __int16)word_87A22EC);
  }
}
// 87A22B2: using guessed type __int16 word_87A22B2;
// 87A22B6: using guessed type __int16 word_87A22B6;
// 87A22CC: using guessed type __int16 word_87A22CC;
// 87A22D4: using guessed type __int16 word_87A22D4;
// 87A22EC: using guessed type __int16 word_87A22EC;
// 87A2314: using guessed type __int16 word_87A2314;
// 8111390: using guessed type float var_98[4];

//----- (081115C2) --------------------------------------------------------
int sub_81115C2()
{
  int v0; // eax
  int v2; // [esp+10h] [ebp-38h]
  int v3; // [esp+14h] [ebp-34h]
  float v4[4]; // [esp+20h] [ebp-28h] BYREF
  float v5[6]; // [esp+30h] [ebp-18h] BYREF

  v3 = 1023;
  v2 = 41953329;
  Scr_GetVector(0, v5);
  Scr_GetVector(1u, v4);
  if ( !Scr_GetInt(2u) )
    v2 = 8398897;
  if ( Scr_GetType(3u) == 1 && Scr_GetPointerType(3u) == 21 )
    v3 = *(_DWORD *)Scr_GetEntity(3u);
  v0 = G_LocationalTracePassed(v5, v4, v3, v2);
  return Scr_AddBool(v0);
}
// 81115C2: using guessed type float var_18[6];
// 81115C2: using guessed type float var_28[4];

//----- (08111684) --------------------------------------------------------
int __usercall sub_8111684@<eax>(long double a1@<st0>)
{
  int v2; // [esp+2Ch] [ebp-3Ch] BYREF
  int v3; // [esp+30h] [ebp-38h]
  int v4; // [esp+34h] [ebp-34h]
  int *v5; // [esp+38h] [ebp-30h]
  float v7[4]; // [esp+40h] [ebp-28h] BYREF
  float v8[6]; // [esp+50h] [ebp-18h] BYREF

  v5 = 0;
  v4 = 1023;
  v3 = 41949187;
  Scr_GetVector(0, v8);
  Scr_GetVector(1u, v7);
  if ( !Scr_GetInt(2u) )
    v3 &= ~0x2000000u;
  if ( Scr_GetType(3u) == 1 && Scr_GetPointerType(3u) == 21 )
  {
    v5 = (int *)Scr_GetEntity(3u);
    v4 = *v5;
  }
  G_SightTrace(&v2, v8, v7, v4, v3);
  if ( !v2 )
  {
    sub_808F1DC(v8, v7);
    if ( a1 < 0.2 )
      v2 = 1;
  }
  return Scr_AddBool(v2 == 0);
}
// 8111684: using guessed type float var_18[6];
// 8111684: using guessed type float var_28[4];

//----- (08111786) --------------------------------------------------------
_DWORD *sub_8111786()
{
  float s[12]; // [esp+20h] [ebp-68h] BYREF
  int v2[4]; // [esp+50h] [ebp-38h] BYREF
  int v3[4]; // [esp+60h] [ebp-28h] BYREF
  int v4[6]; // [esp+70h] [ebp-18h] BYREF

  Scr_GetVector(0, v4);
  Scr_GetVector(1u, v3);
  G_TraceCapsule(s, (float *)v4, flt_8145E68, flt_8145E68, (float *)v3, 1023, 8519697);
  sub_80DEB7A((float *)v4, (float *)v3, s[0], (float *)v2);
  return Scr_AddVector(v2);
}
// 8145E68: using guessed type float flt_8145E68[3];
// 8111786: using guessed type float s[12];

//----- (0811181C) --------------------------------------------------------
void Scr_RandomInt()
{
  int v0; // eax
  int v1; // [esp+14h] [ebp-4h]

  v1 = Scr_GetInt(0);
  if ( v1 > 0 )
  {
    v0 = sub_80A8776(0, v1);
    Scr_AddInt(v0);
  }
  else
  {
    Com_Printf("RandomInt parm: %d  ", v1);
    Scr_Error((int)"RandomInt parm must be positive integer.\n");
  }
}

//----- (08111876) --------------------------------------------------------
int sub_8111876()
{
  int v1; // [esp+0h] [ebp-18h]
  float v2; // [esp+14h] [ebp-4h]

  v2 = Scr_GetFloat(0);
  *(float *)&v1 = sub_80A8720(0.0, v2);
  return Scr_AddFloat(v1);
}

//----- (081118AA) --------------------------------------------------------
int Scr_RandomIntRange()
{
  int v0; // eax
  int v2; // [esp+10h] [ebp-8h]
  int v3; // [esp+14h] [ebp-4h]

  v3 = Scr_GetInt(0);
  v2 = Scr_GetInt(1u);
  if ( v2 <= v3 )
  {
    Com_Printf("RandomIntRange parms: %d %d ", v3, v2);
    Scr_Error((int)"RandomIntRange range must be positive integer.\n");
  }
  v0 = sub_80A8776(v3, v2);
  return Scr_AddInt(v0);
}

//----- (08111918) --------------------------------------------------------
int Scr_RandomFloatRange()
{
  int v1; // [esp+0h] [ebp-28h]
  float v2; // [esp+20h] [ebp-8h]
  float v3; // [esp+24h] [ebp-4h]

  v3 = Scr_GetFloat(0);
  v2 = Scr_GetFloat(1u);
  if ( v3 >= (long double)v2 )
  {
    Com_Printf(
      "Scr_RandomFloatRange parms: %d %d ",
      (unsigned int)COERCE_UNSIGNED_INT64(v3),
      (_DWORD)HIDWORD(COERCE_UNSIGNED_INT64(v3)));
    Scr_Error((int)"Scr_RandomFloatRange range must be positive float.\n");
  }
  *(float *)&v1 = sub_80A8720(v3, v2);
  return Scr_AddFloat(v1);
}

//----- (0811198E) --------------------------------------------------------
int GScr_sin()
{
  long double v0; // fst7
  int v2; // [esp+14h] [ebp-4h]

  v0 = Scr_GetFloat(0);
  *(float *)&v2 = sin(v0 * 0.0174532925199433);
  return Scr_AddFloat(v2);
}

//----- (081119C0) --------------------------------------------------------
int GScr_cos()
{
  long double v0; // fst7
  int v2; // [esp+14h] [ebp-4h]

  v0 = Scr_GetFloat(0);
  *(float *)&v2 = cos(v0 * 0.0174532925199433);
  return Scr_AddFloat(v2);
}

//----- (081119F2) --------------------------------------------------------
int GScr_tan()
{
  int v1; // [esp+0h] [ebp-18h]
  float v2; // [esp+Ch] [ebp-Ch]
  int v3; // [esp+10h] [ebp-8h] BYREF
  int v4; // [esp+14h] [ebp-4h] BYREF

  v2 = Scr_GetFloat(0) * 0.0174532925199433;
  sub_811618E(v2, (float *)&v4, (float *)&v3);
  if ( *(float *)&v3 == 0.0 )
    Scr_Error((int)"divide by 0");
  *(float *)&v1 = *(float *)&v4 / *(float *)&v3;
  return Scr_AddFloat(v1);
}

//----- (08111A56) --------------------------------------------------------
int GScr_asin()
{
  char *v0; // eax
  float v2; // [esp+10h] [ebp-8h]
  int v3; // [esp+10h] [ebp-8h]
  float v4; // [esp+14h] [ebp-4h]

  v4 = Scr_GetFloat(0);
  if ( v4 < -1.0 || v4 > 1.0 )
  {
    v0 = va("%g out of range", v4);
    Scr_Error((int)v0);
  }
  v2 = asin(v4);
  *(float *)&v3 = v2 * 57.29577951308232;
  return Scr_AddFloat(v3);
}

//----- (08111AD0) --------------------------------------------------------
int GScr_acos()
{
  char *v0; // eax
  float v2; // [esp+10h] [ebp-8h]
  int v3; // [esp+10h] [ebp-8h]
  float v4; // [esp+14h] [ebp-4h]

  v4 = Scr_GetFloat(0);
  if ( v4 < -1.0 || v4 > 1.0 )
  {
    v0 = va("%g out of range", v4);
    Scr_Error((int)v0);
  }
  v2 = acos(v4);
  *(float *)&v3 = v2 * 57.29577951308232;
  return Scr_AddFloat(v3);
}

//----- (08111B4A) --------------------------------------------------------
int GScr_atan()
{
  long double v0; // fst7
  float v2; // [esp+14h] [ebp-4h]
  int v3; // [esp+14h] [ebp-4h]

  v0 = Scr_GetFloat(0);
  v2 = atan(v0);
  *(float *)&v3 = v2 * 57.29577951308232;
  return Scr_AddFloat(v3);
}

//----- (08111B82) --------------------------------------------------------
void GScr_CastInt()
{
  int v0; // eax
  const char *v1; // eax
  int v2; // eax
  const char *v3; // eax
  char *v4; // eax
  int v5; // [esp+Ch] [ebp-Ch]
  int v6; // [esp+10h] [ebp-8h]

  v5 = Scr_GetType(0);
  if ( v5 == 5 )
  {
    v6 = (int)Scr_GetFloat(0);
    Scr_AddInt(v6);
    return;
  }
  if ( v5 > 5 )
  {
    if ( v5 == 6 )
    {
      v0 = Scr_GetInt(0);
      Scr_AddInt(v0);
      return;
    }
  }
  else if ( v5 == 2 )
  {
    v1 = (const char *)Scr_GetString(0);
    v2 = atoi(v1);
    Scr_AddInt(v2);
    return;
  }
  v3 = (const char *)sub_80849F8(0);
  v4 = va("cannot cast %s to int", v3);
  Scr_ParamError(0, (int)v4);
}

//----- (08111C46) --------------------------------------------------------
int __usercall Scr_Distance@<eax>(long double a1@<st0>)
{
  int v2; // [esp+0h] [ebp-38h]
  float v3[4]; // [esp+10h] [ebp-28h] BYREF
  float v4[6]; // [esp+20h] [ebp-18h] BYREF

  Scr_GetVector(0, v4);
  Scr_GetVector(1u, v3);
  Vec3Distance(v4, v3);
  *(float *)&v2 = a1;
  return Scr_AddFloat(v2);
}
// 8111C46: using guessed type float var_18[6];
// 8111C46: using guessed type float var_28[4];

//----- (08111C8E) --------------------------------------------------------
int Scr_DistanceSquared()
{
  int v1; // [esp+0h] [ebp-38h]
  float v2[4]; // [esp+10h] [ebp-28h] BYREF
  float v3[6]; // [esp+20h] [ebp-18h] BYREF

  Scr_GetVector(0, v3);
  Scr_GetVector(1u, v2);
  *(float *)&v1 = sub_80A1DB2(v3, v2);
  return Scr_AddFloat(v1);
}
// 8111C8E: using guessed type float var_18[6];
// 8111C8E: using guessed type float var_28[4];

//----- (08111CD6) --------------------------------------------------------
int __usercall sub_8111CD6@<eax>(long double a1@<st0>)
{
  int v2; // [esp+0h] [ebp-28h]
  float v3[6]; // [esp+10h] [ebp-18h] BYREF

  Scr_GetVector(0, v3);
  sub_8116362(v3);
  *(float *)&v2 = a1;
  return Scr_AddFloat(v2);
}
// 8111CD6: using guessed type float var_18[6];

//----- (08111D04) --------------------------------------------------------
int sub_8111D04()
{
  int v1; // [esp+0h] [ebp-28h]
  float v2[6]; // [esp+10h] [ebp-18h] BYREF

  Scr_GetVector(0, v2);
  *(float *)&v1 = sub_811632E(v2);
  return Scr_AddFloat(v1);
}
// 8111D04: using guessed type float var_18[6];

//----- (08111D32) --------------------------------------------------------
int sub_8111D32()
{
  float v1; // [esp+18h] [ebp-40h]
  float v2; // [esp+1Ch] [ebp-3Ch]
  float v3[4]; // [esp+20h] [ebp-38h] BYREF
  float v4[4]; // [esp+30h] [ebp-28h] BYREF
  float v5[6]; // [esp+40h] [ebp-18h] BYREF

  Scr_GetVector(0, v5);
  Scr_GetVector(1u, v4);
  Scr_GetVector(2u, v3);
  v2 = sub_80A1DB2(v4, v5);
  v1 = sub_80A1DB2(v3, v5);
  return Scr_AddInt(v1 > (long double)v2);
}
// 8111D32: using guessed type float var_18[6];
// 8111D32: using guessed type float var_28[4];
// 8111D32: using guessed type float var_38[4];

//----- (08111DB8) --------------------------------------------------------
int sub_8111DB8()
{
  int v1; // [esp+0h] [ebp-38h]
  float v2[4]; // [esp+10h] [ebp-28h] BYREF
  float v3[6]; // [esp+20h] [ebp-18h] BYREF

  Scr_GetVector(0, v3);
  Scr_GetVector(1u, v2);
  *(float *)&v1 = sub_81162FA(v3, v2);
  return Scr_AddFloat(v1);
}
// 8111DB8: using guessed type float var_18[6];
// 8111DB8: using guessed type float var_28[4];

//----- (08111E00) --------------------------------------------------------
_DWORD *sub_8111E00()
{
  float v1[4]; // [esp+10h] [ebp-28h] BYREF
  _DWORD v2[6]; // [esp+20h] [ebp-18h] BYREF

  Scr_GetVector(0, v2);
  Scr_VectorCopy(v2, v1);
  Vec3Normalize(v1);
  return Scr_AddVector(v1);
}
// 8111E00: using guessed type _DWORD var_18[6];
// 8111E00: using guessed type float var_28[4];

//----- (08111E46) --------------------------------------------------------
_DWORD *Scr_VectorToAngles()
{
  _DWORD v1[4]; // [esp+10h] [ebp-28h] BYREF
  float v2[6]; // [esp+20h] [ebp-18h] BYREF

  Scr_GetVector(0, v2);
  vectoangles(v2, (int)v1);
  return Scr_AddVector(v1);
}
// 8111E46: using guessed type float var_18[6];
// 8111E46: using guessed type _DWORD var_28[4];

//----- (08111E7E) --------------------------------------------------------
_DWORD *Scr_AnglesToUp()
{
  float v1[4]; // [esp+10h] [ebp-28h] BYREF
  float v2[6]; // [esp+20h] [ebp-18h] BYREF

  Scr_GetVector(0, v2);
  AngleVectors(v2, 0, 0, v1);
  return Scr_AddVector(v1);
}
// 8111E7E: using guessed type float var_18[6];
// 8111E7E: using guessed type float var_28[4];

//----- (08111EC6) --------------------------------------------------------
_DWORD *Scr_AnglesToRight()
{
  float v1[4]; // [esp+10h] [ebp-28h] BYREF
  float v2[6]; // [esp+20h] [ebp-18h] BYREF

  Scr_GetVector(0, v2);
  AngleVectors(v2, 0, v1, 0);
  return Scr_AddVector(v1);
}
// 8111EC6: using guessed type float var_18[6];
// 8111EC6: using guessed type float var_28[4];

//----- (08111F0E) --------------------------------------------------------
_DWORD *Scr_AnglesToForward()
{
  _DWORD v1[4]; // [esp+10h] [ebp-28h] BYREF
  float v2[6]; // [esp+20h] [ebp-18h] BYREF

  Scr_GetVector(0, v2);
  AngleVectors(v2, (int)v1, 0, 0);
  return Scr_AddVector(v1);
}
// 8111F0E: using guessed type float var_18[6];
// 8111F0E: using guessed type _DWORD var_28[4];

//----- (08111F56) --------------------------------------------------------
int Scr_IsSubStr()
{
  const char *v0; // ebx
  const char *v1; // eax
  char *v2; // eax

  v0 = (const char *)Scr_GetString(1u);
  v1 = (const char *)Scr_GetString(0);
  v2 = strstr(v1, v0);
  return Scr_AddBool(v2 != 0);
}

//----- (08111F9A) --------------------------------------------------------
int Scr_GetSubStr()
{
  int v1; // [esp+14h] [ebp-424h]
  char v2; // [esp+1Bh] [ebp-41Dh]
  int i; // [esp+1Ch] [ebp-41Ch]
  int v4; // [esp+20h] [ebp-418h]
  int v5; // [esp+28h] [ebp-410h]
  int v6; // [esp+2Ch] [ebp-40Ch]
  char s[1032]; // [esp+30h] [ebp-408h] BYREF

  v6 = Scr_GetString(0);
  v5 = Scr_GetInt(1u);
  if ( (unsigned int)Scr_GetNumParam() <= 2 )
    v1 = 0x7FFFFFFF;
  else
    v1 = Scr_GetInt(2u);
  v4 = v5;
  for ( i = 0; v4 < v1; ++i )
  {
    if ( i > 1023 )
      Scr_Error((int)"string too long");
    v2 = *(_BYTE *)(v6 + v4);
    if ( !v2 )
      break;
    s[i] = v2;
    ++v4;
  }
  s[i] = 0;
  return Scr_AddString(s);
}
// 8111F9A: using guessed type char s[1032];

//----- (081120A2) --------------------------------------------------------
void Scr_ToLower()
{
  char v0; // [esp+17h] [ebp-411h]
  int i; // [esp+18h] [ebp-410h]
  char *v2; // [esp+1Ch] [ebp-40Ch]
  char s[1032]; // [esp+20h] [ebp-408h] BYREF

  v2 = (char *)Scr_GetString(0);
  for ( i = 0; i <= 1023; ++i )
  {
    v0 = tolower(*v2);
    s[i] = v0;
    if ( !v0 )
    {
      Scr_AddString(s);
      return;
    }
    ++v2;
  }
  Scr_Error((int)"string too long");
}
// 81120A2: using guessed type char s[1032];

//----- (0811213C) --------------------------------------------------------
int Scr_StrTok()
{
  int result; // eax
  signed int j; // [esp+14h] [ebp-424h]
  char v2; // [esp+1Bh] [ebp-41Dh]
  int v3; // [esp+1Ch] [ebp-41Ch]
  int i; // [esp+20h] [ebp-418h]
  signed int v5; // [esp+24h] [ebp-414h]
  char *s; // [esp+28h] [ebp-410h]
  int v7; // [esp+2Ch] [ebp-40Ch]
  char v8[1032]; // [esp+30h] [ebp-408h] BYREF

  v7 = Scr_GetString(0);
  s = (char *)Scr_GetString(1u);
  v5 = strlen(s);
  v3 = 0;
  Scr_MakeArray();
  for ( i = 0; ; ++i )
  {
    result = *(unsigned __int8 *)(v7 + i);
    v2 = *(_BYTE *)(v7 + i);
    if ( !v2 )
      break;
    for ( j = 0; j < v5; ++j )
    {
      if ( v2 == s[j] )
      {
        if ( v3 )
        {
          v8[v3] = 0;
          Scr_AddString(v8);
          Scr_AddArray();
          v3 = 0;
        }
        goto LABEL_11;
      }
    }
    v8[v3] = v2;
    if ( ++v3 > 1023 )
      Scr_Error((int)"string too long");
LABEL_11:
    ;
  }
  if ( v3 )
  {
    v8[v3] = 0;
    Scr_AddString(v8);
    return Scr_AddArray();
  }
  return result;
}
// 811213C: using guessed type char var_408[1032];

//----- (081122AC) --------------------------------------------------------
int Scr_MusicPlay()
{
  const char *v0; // eax
  char *v1; // eax

  v0 = (const char *)Scr_GetString(0);
  v1 = va("%c %s", 111, v0);
  return SV_GameSendServerCommand(-1, 1, v1);
}

//----- (081122F0) --------------------------------------------------------
void Scr_MusicStop()
{
  char *v0; // eax
  char *v1; // eax
  char *v2; // eax
  float v3; // [esp+0h] [ebp-18h]
  int v4; // [esp+10h] [ebp-8h]
  int v5; // [esp+14h] [ebp-4h]

  v4 = Scr_GetNumParam();
  if ( v4 )
  {
    if ( v4 != 1 )
    {
      v0 = va("USAGE: musicStop([fadetime]);\n");
      Scr_Error((int)v0);
      return;
    }
    v3 = Scr_GetFloat(0) * 1000.0;
    v5 = floorf(v3);
  }
  else
  {
    v5 = 0;
  }
  if ( v5 < 0 )
  {
    v1 = va("musicStop: fade time must be >= 0\n");
    Scr_Error((int)v1);
  }
  v2 = va("%c %i", 112, v5);
  SV_GameSendServerCommand(-1, 1, v2);
}

//----- (0811239C) --------------------------------------------------------
int Scr_SoundFade()
{
  char *v0; // eax
  int v2; // [esp+20h] [ebp-8h]
  float v3; // [esp+24h] [ebp-4h]

  v3 = Scr_GetFloat(0);
  if ( (unsigned int)Scr_GetNumParam() <= 1 )
    v2 = 0;
  else
    v2 = (int)(Scr_GetFloat(1u) * 1000.0);
  v0 = va("%c %f %i\n", 113, v3, v2);
  return SV_GameSendServerCommand(-1, 1, v0);
}

//----- (0811242C) --------------------------------------------------------
int Scr_PrecacheModel()
{
  char *v0; // eax

  if ( !dword_859B41C )
    Scr_Error((int)"precacheModel must be called before any wait statements in the gametype or level script\n");
  v0 = (char *)Scr_GetString(0);
  return G_ModelIndex(v0);
}

//----- (0811245E) --------------------------------------------------------
int Scr_PrecacheShellShock()
{
  char *v0; // eax

  if ( !dword_859B41C )
    Scr_Error((int)"precacheShellShock must be called before any wait statements in the gametype or level script\n");
  v0 = (char *)Scr_GetString(0);
  return G_ShellShockIndex(v0);
}

//----- (08112490) --------------------------------------------------------
int Scr_PrecacheItem()
{
  char *v0; // eax
  char *v2; // [esp+10h] [ebp-8h]
  char *v3; // [esp+14h] [ebp-4h]

  if ( !dword_859B41C )
    Scr_Error((int)"precacheItem must be called before any wait statements in the gametype or level script\n");
  v3 = (char *)Scr_GetString(0);
  v2 = sub_80DCB02(v3);
  if ( !v2 )
  {
    v0 = va("unknown item '%s'", v3);
    Scr_ParamError(0, (int)v0);
  }
  return sub_8104C84(-1171354717 * ((v2 - (char *)&unk_8164C20) >> 2), 1);
}

//----- (0811251A) --------------------------------------------------------
int Scr_PrecacheShader()
{
  char *src; // [esp+14h] [ebp-4h]

  if ( !dword_859B41C )
    Scr_Error((int)"precacheShader must be called before any wait statements in the gametype or level script\n");
  src = (char *)Scr_GetString(0);
  if ( !*src )
    Scr_ParamError(0, (int)"Shader name string is empty");
  return sub_811AFBA(src);
}

//----- (0811256E) --------------------------------------------------------
char *Scr_PrecacheString()
{
  char *result; // eax

  if ( !dword_859B41C )
    Scr_Error((int)"precacheString must be called before any wait statements in the gametype or level script\n");
  result = (char *)Scr_GetIString(0);
  if ( *result )
    return (char *)G_LocalizedStringIndex(result);
  return result;
}

//----- (081125B4) --------------------------------------------------------
void Scr_AmbientPlay()
{
  char *v0; // eax
  char *v1; // eax
  char *v2; // eax
  char *v3; // eax
  float v4; // [esp+0h] [ebp-18h]
  int v5; // [esp+Ch] [ebp-Ch]
  const char *v6; // [esp+10h] [ebp-8h]
  int v7; // [esp+14h] [ebp-4h]

  v7 = 0;
  v5 = Scr_GetNumParam();
  if ( v5 != 1 )
  {
    if ( v5 != 2 )
    {
      v0 = va("USAGE: ambientPlay(alias_name, <fadetime>);\n");
      Scr_Error((int)v0);
      return;
    }
    v4 = Scr_GetFloat(1u) * 1000.0;
    v7 = floorf(v4);
  }
  v6 = (const char *)Scr_GetString(0);
  if ( !*v6 )
  {
    v1 = va("ambientPlay: alias name cannot be the empty string... use stop or fade version\n");
    Scr_Error((int)v1);
  }
  if ( v7 < 0 )
  {
    v2 = va("ambientPlay: fade time must be >= 0\n");
    Scr_Error((int)v2);
  }
  v3 = va("n\\%s\\t\\%i", v6, dword_859B5EC + v7);
  SV_SetConfigstring(3u, v3);
}

//----- (0811268C) --------------------------------------------------------
void Scr_AmbientStop()
{
  char *v0; // eax
  char *v1; // eax
  char *v2; // eax
  float v3; // [esp+0h] [ebp-18h]
  int v4; // [esp+10h] [ebp-8h]
  int v5; // [esp+14h] [ebp-4h]

  v4 = Scr_GetNumParam();
  if ( v4 )
  {
    if ( v4 != 1 )
    {
      v0 = va("USAGE: ambientStop(<fadetime>);\n");
      Scr_Error((int)v0);
      return;
    }
    v3 = Scr_GetFloat(0) * 1000.0;
    v5 = floorf(v3);
  }
  else
  {
    v5 = 0;
  }
  if ( v5 < 0 )
  {
    v1 = va("ambientStop: fade time must be >= 0\n");
    Scr_Error((int)v1);
  }
  v2 = va("t\\%i", dword_859B5EC + v5);
  SV_SetConfigstring(3u, v2);
}

//----- (0811272E) --------------------------------------------------------
int sub_811272E()
{
  int result; // eax
  float s[15]; // [esp+20h] [ebp-88h] BYREF
  _DWORD *v2; // [esp+5Ch] [ebp-4Ch]
  int v3[2]; // [esp+60h] [ebp-48h] BYREF
  float v4; // [esp+68h] [ebp-40h]
  int v5[2]; // [esp+70h] [ebp-38h] BYREF
  float v6; // [esp+78h] [ebp-30h]
  float v7[4]; // [esp+80h] [ebp-28h] BYREF
  _DWORD v8[6]; // [esp+90h] [ebp-18h] BYREF

  Scr_GetVector(0, v8);
  Scr_VectorCopy(v8, v5);
  v6 = v6 + 1.0;
  v2 = G_TempEntity(v5, 188);
  sub_81161E6(v7, 0, 0, 1065353216);
  v2[40] = (unsigned __int8)DirToByte(v7);
  Scr_VectorCopy(v5, v3);
  v4 = v4 - 17.0;
  G_TraceCapsule(s, (float *)v5, flt_8145E68, flt_8145E68, (float *)v3, 1023, 2065);
  result = (LODWORD(s[4]) & 0x1F00000) >> 20;
  v2[34] = result;
  return result;
}
// 8145E68: using guessed type float flt_8145E68[3];
// 811272E: using guessed type _DWORD var_18[6];
// 811272E: using guessed type float var_28[4];

//----- (08112836) --------------------------------------------------------
int GScr_RadiusDamage()
{
  int result; // eax
  float v1; // [esp+24h] [ebp-24h]
  float v2; // [esp+28h] [ebp-20h]
  float v3; // [esp+2Ch] [ebp-1Ch]
  int v4[6]; // [esp+30h] [ebp-18h] BYREF

  Scr_GetVector(0, v4);
  v3 = Scr_GetFloat(1u);
  v2 = Scr_GetFloat(2u);
  v1 = Scr_GetFloat(3u);
  dword_859E9F4 = dword_859E9F8;
  result = G_RadiusDamage((float *)v4, 0, &dword_86F1020, v2, v1, v3, 0, 14);
  dword_859E9F4 = 0;
  return result;
}
// 859E9F4: using guessed type int dword_859E9F4;
// 859E9F8: using guessed type int dword_859E9F8;
// 86F1020: using guessed type int dword_86F1020;

//----- (081128D2) --------------------------------------------------------
int GScr_SetPlayerIgnoreRadiusDamage()
{
  int result; // eax

  result = Scr_GetInt(0);
  dword_859E9F8 = result;
  return result;
}
// 859E9F8: using guessed type int dword_859E9F8;

//----- (081128EC) --------------------------------------------------------
_DWORD *GScr_GetMoveDelta()
{
  int v0; // eax
  int v2; // [esp+20h] [ebp-38h]
  int v3; // [esp+24h] [ebp-34h] BYREF
  float v4; // [esp+28h] [ebp-30h]
  float v5; // [esp+2Ch] [ebp-2Ch]
  int v6[4]; // [esp+30h] [ebp-28h] BYREF
  int v7[3]; // [esp+40h] [ebp-18h] BYREF
  int v8; // [esp+4Ch] [ebp-Ch]

  v5 = 0.0;
  v4 = 1.0;
  v2 = Scr_GetNumParam();
  if ( v2 != 1 )
  {
    if ( v2 != 2 )
    {
      v4 = Scr_GetFloat(2u);
      if ( v4 < 0.0 || v4 > 1.0 )
        Scr_ParamError(2, (int)"end time must be between 0 and 1");
    }
    v5 = Scr_GetFloat(1u);
    if ( v5 < 0.0 || v5 > 1.0 )
      Scr_ParamError(1, (int)"start time must be between 0 and 1");
  }
  Scr_GetAnim((unsigned __int16 *)&v3, 0, 0);
  v8 = v3;
  v0 = Scr_GetAnims(HIWORD(v3));
  XAnimGetRelDelta(v0, (unsigned __int16)v8, v7, v6, v5, v4);
  return Scr_AddVector(v6);
}
// 81128EC: using guessed type int var_18[3];

//----- (08112A04) --------------------------------------------------------
int GScr_GetAngleDelta()
{
  int v0; // eax
  int v2; // [esp+0h] [ebp-58h]
  int v3; // [esp+20h] [ebp-38h]
  int v4; // [esp+24h] [ebp-34h] BYREF
  float v5; // [esp+28h] [ebp-30h]
  float v6; // [esp+2Ch] [ebp-2Ch]
  int v7[4]; // [esp+30h] [ebp-28h] BYREF
  int v8[3]; // [esp+40h] [ebp-18h] BYREF
  int v9; // [esp+4Ch] [ebp-Ch]

  v6 = 0.0;
  v5 = 1.0;
  v3 = Scr_GetNumParam();
  if ( v3 != 1 )
  {
    if ( v3 != 2 )
    {
      v5 = Scr_GetFloat(2u);
      if ( v5 < 0.0 || v5 > 1.0 )
        Scr_ParamError(2, (int)"end time must be between 0 and 1");
    }
    v6 = Scr_GetFloat(1u);
    if ( v6 < 0.0 || v6 > 1.0 )
      Scr_ParamError(1, (int)"start time must be between 0 and 1");
  }
  Scr_GetAnim((unsigned __int16 *)&v4, 0, 0);
  v9 = v4;
  v0 = Scr_GetAnims(HIWORD(v4));
  XAnimGetRelDelta(v0, (unsigned __int16)v9, v8, v7, v6, v5);
  *(float *)&v2 = sub_80A5774((float *)v8);
  return Scr_AddFloat(v2);
}
// 8112A04: using guessed type int var_28[4];

//----- (08112B24) --------------------------------------------------------
int GScr_GetNorthYaw()
{
  int v1; // [esp+1Ch] [ebp-2Ch]
  char nptr[40]; // [esp+20h] [ebp-28h] BYREF

  SV_GetConfigstring(0xBu, nptr, 32);
  *(float *)&v1 = atof(nptr);
  return Scr_AddFloat(v1);
}

//----- (08112B60) --------------------------------------------------------
int Scr_LoadFX()
{
  char *s2; // [esp+10h] [ebp-8h]
  int v2; // [esp+14h] [ebp-4h]

  s2 = (char *)Scr_GetString(0);
  v2 = G_EffectIndex(s2);
  if ( !v2 && !dword_859B41C )
    Scr_Error((int)"loadFx must be called before any wait statements in the gametype or level script, or on an already loaded effect\n");
  return Scr_AddInt(v2);
}

//----- (08112BAC) --------------------------------------------------------
void __cdecl sub_8112BAC(const char *a1, int a2)
{
  char *v2; // eax
  char dest[1032]; // [esp+10h] [ebp-408h] BYREF

  if ( a2 )
    SV_GetConfigstring(a2 + 846, dest, 1024);
  else
    strcpy(dest, "not successfully loaded");
  v2 = va("%s (effect = %s)\n", a1, dest);
  Scr_Error((int)v2);
}
// 8112BAC: using guessed type const char *arg_0;

//----- (08112C1C) --------------------------------------------------------
int __usercall Scr_PlayFX@<eax>(long double a1@<st0>)
{
  int result; // eax
  long double v2; // fst7
  long double v3; // fst7
  float v4; // [esp+4h] [ebp-64h]
  float v5; // [esp+4h] [ebp-64h]
  float v6; // [esp+4h] [ebp-64h]
  int v7[3]; // [esp+10h] [ebp-58h] BYREF
  float v8[3]; // [esp+1Ch] [ebp-4Ch] BYREF
  float v9[6]; // [esp+28h] [ebp-40h] BYREF
  _DWORD v10[4]; // [esp+40h] [ebp-28h] BYREF
  float v11; // [esp+50h] [ebp-18h]
  int v12; // [esp+54h] [ebp-14h]
  int v13; // [esp+58h] [ebp-10h]
  _DWORD *v14; // [esp+5Ch] [ebp-Ch]

  v12 = Scr_GetNumParam();
  if ( v12 <= 1 || v12 > 4 )
    Scr_Error((int)"Incorrect number of parameters");
  v13 = Scr_GetInt(0);
  Scr_GetVector(1u, v10);
  v14 = G_TempEntity(v10, 194);
  v14[40] = (unsigned __int8)v13;
  if ( v12 == 2 )
  {
    result = -1028390912;
    v14[15] = -1028390912;
  }
  else
  {
    Scr_GetVector(2u, v7);
    sub_8116362((float *)v7);
    v11 = a1;
    if ( v11 == 0.0 )
      sub_8112BAC("playFx called with (0 0 0) forward direction", v13);
    v2 = 1.0 / v11;
    v4 = v2;
    sub_81162C2((float *)v7, v4, (float *)v7);
    if ( v12 == 3 )
    {
      return vectoangles((float *)v7, (int)(v14 + 15));
    }
    else
    {
      Scr_GetVector(3u, v9);
      sub_8116362(v9);
      v11 = v2;
      if ( v11 == 0.0 )
        sub_8112BAC("playFx called with (0 0 0) up direction", v13);
      v3 = 1.0 / v11;
      v5 = v3;
      sub_81162C2(v9, v5, v9);
      sub_80A1ED8(v9, (float *)v7, v8);
      sub_8116362(v8);
      v11 = v3;
      if ( v11 >= 0.001 )
      {
        if ( v11 < 0.99900001 )
        {
          v6 = 1.0 / v11;
          sub_81162C2(v8, v6, v8);
          sub_80A1ED8((float *)v7, v8, v9);
        }
      }
      else
      {
        sub_8112BAC("playFx called an up direction 0 or 180 degrees from forward", v13);
      }
      return sub_80A71F4((int)v7, (int)(v14 + 15));
    }
  }
  return result;
}
// 8112C1C: using guessed type _DWORD var_28[4];

//----- (08112E4E) --------------------------------------------------------
int Scr_PlayFXOnTag()
{
  char *v0; // eax
  const char *v1; // eax
  const char *v2; // eax
  char *v3; // eax
  const char *v4; // eax
  char *v5; // eax
  const char *v7; // [esp+18h] [ebp-10h]
  int v8; // [esp+1Ch] [ebp-Ch]
  int v9; // [esp+20h] [ebp-8h]
  int v10; // [esp+24h] [ebp-4h]

  if ( Scr_GetNumParam() != 3 )
    Scr_Error((int)"USAGE: playFxOnTag <effect id from loadFx> <entity> <tag name>");
  v10 = Scr_GetInt(0);
  if ( v10 <= 0 || v10 > 63 )
  {
    v0 = va("effect id %i is invalid\n", v10);
    Scr_ParamError(0, (int)v0);
  }
  v8 = Scr_GetEntity(1u);
  if ( !*(_BYTE *)(v8 + 356) )
    Scr_ParamError(1, (int)"cannot play fx on entity with no model");
  v7 = (const char *)sub_8084434(2u);
  v1 = (const char *)SL_ConvertToString((int)v7);
  if ( strchr(v1, 34) )
    Scr_ParamError(2, (int)"cannot use \" characters in tag names\n");
  if ( sub_8090898((int *)v8, (int)v7) < 0 )
  {
    SV_DObjDumpInfo((int *)v8);
    v2 = G_ModelName(*(unsigned __int8 *)(v8 + 356));
    v3 = va("tag '%s' does not exist on entity with model '%s'", v7, v2);
    Scr_ParamError(2, (int)v3);
  }
  v4 = (const char *)SL_ConvertToString((int)v7);
  v5 = va("%02d%s", v10, v4);
  v9 = G_FindConfigstringIndex(v5, 910, 256, 1, 0);
  return G_AddEvent((_DWORD *)v8, 195, v9);
}

//----- (08112FDE) --------------------------------------------------------
int Scr_PlayLoopedFX()
{
  char *v0; // eax
  char *v1; // eax
  char *v2; // eax
  int *v3; // ebx
  float v5; // [esp+0h] [ebp-478h]
  double v6; // [esp+4h] [ebp-474h]
  unsigned int v7; // [esp+1Ch] [ebp-45Ch]
  char dest[1032]; // [esp+20h] [ebp-458h] BYREF
  char v9[4]; // [esp+428h] [ebp-50h]
  float v10; // [esp+42Ch] [ebp-4Ch]
  float v11[4]; // [esp+430h] [ebp-48h] BYREF
  float v12[4]; // [esp+440h] [ebp-38h] BYREF
  _DWORD v13[6]; // [esp+450h] [ebp-28h] BYREF
  int v14; // [esp+468h] [ebp-10h]
  int *v15; // [esp+46Ch] [ebp-Ch]

  if ( (unsigned int)Scr_GetNumParam() <= 2 || (unsigned int)Scr_GetNumParam() > 6 )
    Scr_Error((int)"USAGE: playLoopedFx <effect id from loadFx> <repeat delay> <vector position of effect> <optional cu"
                     "ll distance (0 = never cull)> <optional forward vector> <optional up vector>");
  sub_81161BC(v12);
  sub_81161BC(v11);
  v10 = 0.0;
  v14 = Scr_GetInt(0);
  v7 = Scr_GetNumParam();
  if ( v7 == 5 )
  {
LABEL_14:
    Scr_GetVector(4u, v12);
    if ( Vec3Normalize(v12) == 0.0 )
    {
      if ( v14 )
        SV_GetConfigstring(v14 + 846, dest, 1024);
      else
        strcpy(dest, "not successfully loaded");
      v1 = va("playLoopedFx called with (0 0 0) forward direction (effect = %s)\n", dest);
      Scr_Error((int)v1);
    }
    goto LABEL_19;
  }
  if ( v7 > 5 )
  {
    if ( v7 != 6 )
      goto LABEL_20;
    Scr_GetVector(5u, v11);
    if ( Vec3Normalize(v11) == 0.0 )
    {
      if ( v14 )
        SV_GetConfigstring(v14 + 846, dest, 1024);
      else
        strcpy(dest, "not successfully loaded");
      v0 = va("playLoopedFx called with (0 0 0) up direction (effect = %s)\n", dest);
      Scr_Error((int)v0);
    }
    goto LABEL_14;
  }
  if ( v7 == 4 )
LABEL_19:
    v10 = Scr_GetFloat(3u);
LABEL_20:
  Scr_GetVector(2u, v13);
  v5 = Scr_GetFloat(1u) * 1000.0;
  *(_DWORD *)v9 = floorf(v5);
  if ( *(int *)v9 <= 0 )
  {
    LODWORD(v6) = *(_DWORD *)v9;
    v2 = va("playLoopedFx called with %f s repeat (should be >= 0.0005s)\n", v6);
    Scr_Error((int)v2);
  }
  v15 = (int *)G_Spawn();
  v15[1] = 8;
  *((_BYTE *)v15 + 242) |= 8u;
  v15[54] = (unsigned __int8)v14;
  sub_811CF36(v15, v13);
  Scr_VectorCopy(v12, v15 + 23);
  v3 = v15;
  v3[40] = (unsigned __int8)DirToByte(v11);
  *((float *)v15 + 26) = v10;
  *((float *)v15 + 27) = (float)*(int *)v9;
  SV_LinkEntity((int)v15);
  return Scr_AddEntity(v15);
}
// 81131E3: variable 'v6' is possibly undefined
// 8112FDE: using guessed type float var_38[4];
// 8112FDE: using guessed type float var_48[4];
// 8112FDE: using guessed type _DWORD var_28[6];

//----- (08113294) --------------------------------------------------------
void __cdecl Scr_SetFog(const char *a1, float a2, float a3, float a4, float a5, float a6, float a7, float a8)
{
  char *v8; // eax
  char *v9; // eax
  char *v10; // eax
  char *v11; // eax
  char *v12; // eax

  if ( a2 < 0.0 )
  {
    v8 = va("%s: near distance must be >= 0", a1);
    Scr_Error((int)v8);
  }
  if ( a2 >= (long double)a3 )
  {
    v9 = va("%s: near distance must be less than far distance", a1);
    Scr_Error((int)v9);
  }
  if ( a5 < 0.0 || a5 > 1.0 || a6 < 0.0 || a6 > 1.0 || a7 < 0.0 || a7 > 1.0 )
  {
    v10 = va("%s: red/green/blue color components must be in the range [0, 1]", a1);
    Scr_Error((int)v10);
  }
  if ( a8 < 0.0 )
  {
    v11 = va("%s: transition time must be >= 0 seconds", a1);
    Scr_Error((int)v11);
  }
  v12 = va("%g %g %g %g %g %g %.0f", a2, a3, a4, a5, a6, a7, (double)(a8 * 1000.0));
  sub_80FBD50(v12);
}
// 8113294: using guessed type const char *arg_0;

//----- (081133D0) --------------------------------------------------------
void Scr_SetLinearFog()
{
  float v0; // [esp+20h] [ebp-18h]
  float v1; // [esp+24h] [ebp-14h]
  float v2; // [esp+28h] [ebp-10h]
  float v3; // [esp+2Ch] [ebp-Ch]
  float v4; // [esp+30h] [ebp-8h]
  float v5; // [esp+34h] [ebp-4h]

  if ( Scr_GetNumParam() != 6 )
    Scr_Error((int)"USAGE: setCullFog(near distance, far distance, red, green, blue, transition time);\n");
  v5 = Scr_GetFloat(0);
  v4 = Scr_GetFloat(1u);
  v3 = Scr_GetFloat(2u);
  v2 = Scr_GetFloat(3u);
  v1 = Scr_GetFloat(4u);
  v0 = Scr_GetFloat(5u);
  Scr_SetFog("setCullFog", v5, v4, 1.0, v3, v2, v1, v0);
}

//----- (08113488) --------------------------------------------------------
void Scr_SetExponentialFog()
{
  float v0; // [esp+24h] [ebp-14h]
  float v1; // [esp+28h] [ebp-10h]
  float v2; // [esp+2Ch] [ebp-Ch]
  float v3; // [esp+30h] [ebp-8h]
  float v4; // [esp+34h] [ebp-4h]

  if ( Scr_GetNumParam() != 5 )
    Scr_Error((int)"USAGE: setExpFog(density, red, green, blue, transition time);\n"
                     "Density must be greater than 0 and less than 1, and typically less than .001.  For example, .0002 m"
                     "eans the fog gets .02%% more dense for every 1 unit of distance (about 1%% thicker every 50 units of distance)\n");
  v4 = Scr_GetFloat(0);
  v3 = Scr_GetFloat(1u);
  v2 = Scr_GetFloat(2u);
  v1 = Scr_GetFloat(3u);
  v0 = Scr_GetFloat(4u);
  if ( v4 <= 0.0 || v4 >= 1.0 )
    Scr_Error((int)"setExpFog: distance must be greater than 0 and less than 1");
  Scr_SetFog("setExpFog", 0.0, 1.0, v4, v3, v2, v1, v0);
}

//----- (0811355A) --------------------------------------------------------
int GScr_IsPlayer()
{
  if ( Scr_GetType(0) == 1 && Scr_GetPointerType(0) == 21 && *(_DWORD *)(Scr_GetEntity(0) + 344) )
    return Scr_AddInt(1);
  else
    return Scr_AddInt(0);
}

//----- (081135BA) --------------------------------------------------------
int GScr_IsPlayerNumber()
{
  if ( (unsigned int)Scr_GetInt(0) < 0x40 )
    return Scr_AddInt(1);
  else
    return Scr_AddInt(0);
}

//----- (081135FA) --------------------------------------------------------
int GScr_SetWinningPlayer()
{
  char *v0; // eax
  int result; // eax
  char s1[1032]; // [esp+20h] [ebp-418h] BYREF
  int v3; // [esp+428h] [ebp-10h]
  _DWORD v4[3]; // [esp+42Ch] [ebp-Ch]

  v4[0] = *(_DWORD *)Scr_GetEntity(0) + 1;
  SV_GetConfigstring(0x16u, s1, 1024);
  v3 = (int)va("%i", v4[0]);
  v0 = Info_ValueForKey(s1, "winner");
  result = I_stricmp(v0, (char *)v3);
  if ( result )
  {
    Info_SetValueForKey(s1, "winner", v3);
    return SV_SetConfigstring(0x16u, s1);
  }
  return result;
}
// 81135FA: using guessed type _DWORD var_C[3];

//----- (081136B8) --------------------------------------------------------
void GScr_SetWinningTeam()
{
  const char *v0; // eax
  char *v1; // eax
  char *v2; // eax
  char s1[1028]; // [esp+10h] [ebp-418h] BYREF
  int v4; // [esp+414h] [ebp-14h]
  int v5; // [esp+418h] [ebp-10h]
  unsigned __int16 v6; // [esp+41Eh] [ebp-Ah]

  v6 = Scr_GetConstString(0);
  if ( v6 == word_87A22A2 )
  {
    v5 = -2;
  }
  else if ( v6 == word_87A22A4 )
  {
    v5 = -1;
  }
  else
  {
    if ( v6 != word_87A2314 )
    {
      v0 = (const char *)SL_ConvertToString(v6);
      v1 = va("Illegal team string '%s'. Must be allies, axis, or none.", v0);
      Scr_ParamError(0, (int)v1);
      return;
    }
    v5 = 0;
  }
  SV_GetConfigstring(0x16u, s1, 1024);
  v4 = (int)va("%i", v5);
  v2 = Info_ValueForKey(s1, "winner");
  if ( I_stricmp(v2, (char *)v4) )
  {
    Info_SetValueForKey(s1, "winner", v4);
    SV_SetConfigstring(0x16u, s1);
  }
}
// 87A22A2: using guessed type __int16 word_87A22A2;
// 87A22A4: using guessed type __int16 word_87A22A4;
// 87A2314: using guessed type __int16 word_87A2314;
// 81136B8: using guessed type _DWORD var_10;

//----- (081137DA) --------------------------------------------------------
int GScr_Announcement()
{
  int v0; // eax
  char *v1; // eax
  char v3[1032]; // [esp+20h] [ebp-408h] BYREF

  v0 = Scr_GetNumParam();
  Scr_ConstructMessageString(0, v0 - 1, "Announcement", (int)v3, 1024);
  v1 = va("%c \"%s\" 2", 99, v3);
  return SV_GameSendServerCommand(-1, 0, v1);
}

//----- (0811384E) --------------------------------------------------------
int GScr_ClientAnnouncement()
{
  int v0; // eax
  char *v1; // eax
  char v3[1036]; // [esp+20h] [ebp-418h] BYREF
  int *v4; // [esp+42Ch] [ebp-Ch]

  v4 = (int *)Scr_GetEntity(0);
  v0 = Scr_GetNumParam();
  Scr_ConstructMessageString(1, v0 - 1, "Announcement", (int)v3, 1024);
  v1 = va("%c \"%s\" 2", 99, v3);
  return SV_GameSendServerCommand(*v4, 0, v1);
}

//----- (081138D2) --------------------------------------------------------
int GScr_GetTeamScore()
{
  const char *v0; // eax
  char *v1; // eax
  unsigned __int16 v3; // [esp+16h] [ebp-2h]

  v3 = Scr_GetConstString(0);
  if ( v3 != word_87A22A2 && v3 != word_87A22A4 )
  {
    v0 = (const char *)SL_ConvertToString(v3);
    v1 = va("Illegal team string '%s'. Must be allies, or axis.", v0);
    Scr_Error((int)v1);
  }
  if ( v3 == word_87A22A2 )
    return Scr_AddInt(*(int *)dword_859B604);
  else
    return Scr_AddInt(*(int *)dword_859B600);
}
// 87A22A2: using guessed type __int16 word_87A22A2;
// 87A22A4: using guessed type __int16 word_87A22A4;

//----- (08113952) --------------------------------------------------------
int GScr_SetTeamScore()
{
  const char *v0; // eax
  char *v1; // eax
  char *v2; // eax
  int result; // eax
  int v4; // [esp+10h] [ebp-8h]
  unsigned __int16 v5; // [esp+16h] [ebp-2h]

  v5 = Scr_GetConstString(0);
  if ( v5 != word_87A22A2 && v5 != word_87A22A4 )
  {
    v0 = (const char *)SL_ConvertToString(v5);
    v1 = va("Illegal team string '%s'. Must be allies, or axis.", v0);
    Scr_Error((int)v1);
  }
  v4 = Scr_GetInt(1u);
  if ( v5 == word_87A22A2 )
  {
    *(_DWORD *)dword_859B604 = v4;
    v2 = va("%c %i", 72, v4);
  }
  else
  {
    *(_DWORD *)dword_859B600 = v4;
    v2 = va("%c %i", 71, v4);
  }
  result = SV_GameSendServerCommand(-1, 0, v2);
  dword_859B610 = 1;
  return result;
}
// 859B610: using guessed type int dword_859B610;
// 87A22A2: using guessed type __int16 word_87A22A2;
// 87A22A4: using guessed type __int16 word_87A22A4;

//----- (08113A4A) --------------------------------------------------------
void GScr_SetClientNameMode()
{
  __int16 v0; // [esp+6h] [ebp-2h]

  v0 = Scr_GetConstString(0);
  if ( v0 == word_87A2318 )
  {
    dword_859B614 = 0;
  }
  else if ( v0 == word_87A231A )
  {
    dword_859B614 = 1;
  }
  else
  {
    Scr_Error((int)"Unknown mode");
  }
}
// 859B614: using guessed type int dword_859B614;
// 87A2318: using guessed type __int16 word_87A2318;
// 87A231A: using guessed type __int16 word_87A231A;

//----- (08113AA0) --------------------------------------------------------
int GScr_UpdateClientNames()
{
  int result; // eax
  int v1; // [esp+1Ch] [ebp-3Ch]
  char dest[44]; // [esp+20h] [ebp-38h] BYREF
  int i; // [esp+4Ch] [ebp-Ch]

  if ( !dword_859B614 )
    Scr_Error((int)"Only works in [manual_change] mode");
  v1 = 0;
  for ( i = dword_859B400; ; i += 10404 )
  {
    result = v1;
    if ( v1 >= dword_859B5E4 )
      break;
    if ( *(_DWORD *)(i + 9924) == 2 )
    {
      if ( strcmp((const char *)(i + 10116), (const char *)(i + 9992)) )
      {
        I_strncpyz(dest, (char *)(i + 10116), 32);
        I_strncpyz((char *)(i + 10116), (char *)(i + 9992), 32);
        ClientUserinfoChanged(v1);
      }
    }
    ++v1;
  }
  return result;
}
// 859B400: using guessed type int dword_859B400;
// 859B5E4: using guessed type int dword_859B5E4;
// 859B614: using guessed type int dword_859B614;
// 8113AA0: using guessed type char dest[44];

//----- (08113B6E) --------------------------------------------------------
int GScr_GetTeamPlayersAlive()
{
  const char *v0; // eax
  char *v1; // eax
  char *v3; // [esp+14h] [ebp-14h]
  int i; // [esp+18h] [ebp-10h]
  int v5; // [esp+1Ch] [ebp-Ch]
  int v6; // [esp+20h] [ebp-8h]
  unsigned __int16 v7; // [esp+26h] [ebp-2h]

  v7 = Scr_GetConstString(0);
  if ( v7 != word_87A22A2 && v7 != word_87A22A4 )
  {
    v0 = (const char *)SL_ConvertToString(v7);
    v1 = va("Illegal team string '%s'. Must be allies, or axis.", v0);
    Scr_Error((int)v1);
  }
  if ( v7 == word_87A22A2 )
    v5 = 2;
  else
    v5 = 1;
  v6 = 0;
  for ( i = 0; i < *(_DWORD *)(g_maxclients + 8); ++i )
  {
    v3 = (char *)&unk_8665480 + 560 * i;
    if ( v3[252] && *(_DWORD *)(*((_DWORD *)v3 + 86) + 10060) == v5 && *((int *)v3 + 101) > 0 )
      ++v6;
  }
  return Scr_AddInt(v6);
}
// 8793D88: using guessed type int g_maxclients;
// 87A22A2: using guessed type __int16 word_87A22A2;
// 87A22A4: using guessed type __int16 word_87A22A4;

//----- (08113C58) --------------------------------------------------------
int sub_8113C58()
{
  char *v0; // eax
  int v1; // eax
  __int16 **v3; // [esp+4h] [ebp-4h]

  v0 = (char *)Scr_GetString(0);
  v3 = (__int16 **)SV_XModelGet(v0);
  v1 = sub_80C54CE(v3);
  return Scr_AddInt(v1);
}

//----- (08113C8A) --------------------------------------------------------
int GScr_GetPartName()
{
  char *v0; // eax
  char *v1; // eax
  unsigned __int16 v3; // [esp+Ah] [ebp-Eh]
  unsigned int v4; // [esp+Ch] [ebp-Ch]
  unsigned int v5; // [esp+10h] [ebp-8h]
  __int16 **v6; // [esp+14h] [ebp-4h]

  v0 = (char *)Scr_GetString(0);
  v6 = (__int16 **)SV_XModelGet(v0);
  v5 = Scr_GetInt(1u);
  v4 = sub_80C54CE(v6);
  if ( v5 >= v4 )
  {
    v1 = va("index out of range (0 - %d)", v4 - 1);
    Scr_ParamError(1, (int)v1);
  }
  v3 = *(_WORD *)(sub_80C3314((int)v6) + 2 * v5);
  if ( !v3 )
    Scr_ParamError(0, (int)"bad model");
  return Scr_AddConstString(v3);
}

//----- (08113D32) --------------------------------------------------------
int GScr_Earthquake()
{
  int result; // eax
  float v1; // [esp+0h] [ebp-48h]
  float v2; // [esp+1Ch] [ebp-2Ch]
  _DWORD v3[5]; // [esp+20h] [ebp-28h] BYREF
  int v4; // [esp+34h] [ebp-14h]
  float v5; // [esp+38h] [ebp-10h]
  float *v6; // [esp+3Ch] [ebp-Ch]

  v5 = Scr_GetFloat(0);
  v1 = Scr_GetFloat(1u) * 1000.0;
  v4 = floorf(v1);
  Scr_GetVector(2u, v3);
  v2 = Scr_GetFloat(3u);
  if ( v5 <= 0.0 )
    Scr_ParamError(0, (int)"Scale must be greater than 0");
  if ( v4 <= 0 )
    Scr_ParamError(1, (int)"duration must be greater than 0");
  if ( v2 <= 0.0 )
    Scr_ParamError(3, (int)"Radius must be greater than 0");
  v6 = (float *)G_TempEntity(v3, 196);
  v6[26] = v5;
  *((_DWORD *)v6 + 21) = v4;
  result = LODWORD(v2);
  v6[27] = v2;
  return result;
}
// 8113D32: using guessed type _DWORD var_28[5];

//----- (08113E1A) --------------------------------------------------------
void __cdecl GScr_ShellShock(int a1)
{
  char *v1; // eax
  char *v2; // eax
  float v3; // [esp+0h] [ebp-428h]
  char s1[1024]; // [esp+10h] [ebp-418h] BYREF
  char *s2; // [esp+410h] [ebp-18h]
  unsigned int v6; // [esp+414h] [ebp-14h]
  int i; // [esp+418h] [ebp-10h]
  int v8; // [esp+41Ch] [ebp-Ch]

  v8 = GetPlayerEntity(a1);
  if ( Scr_GetNumParam() != 2 )
    Scr_Error((int)"USAGE: <player> shellshock(<shellshockname>, <duration>)\n");
  s2 = (char *)Scr_GetString(0);
  for ( i = 1; ; ++i )
  {
    if ( i > 15 )
    {
      v2 = va("shellshock '%s' was not precached\n", s2);
      Scr_Error((int)v2);
      return;
    }
    SV_GetConfigstring(i + 1166, s1, 1024);
    if ( !strcasecmp(s1, s2) )
      break;
  }
  v3 = Scr_GetFloat(1u) * 1000.0;
  v6 = floorf(v3);
  if ( v6 >= 0xEA61 )
  {
    v1 = va("duration %g should be >= 0 and <= 60", (double)((long double)(int)v6 * 0.001));
    Scr_ParamError(1, (int)v1);
  }
  *(_DWORD *)(*(_DWORD *)(v8 + 344) + 1496) = i;
  *(_DWORD *)(*(_DWORD *)(v8 + 344) + 1500) = dword_859B5EC;
  *(_DWORD *)(*(_DWORD *)(v8 + 344) + 1504) = v6;
  if ( *(int *)(v8 + 404) > 0 )
  {
    dword_855A4E0 = &unk_859EA40;
    BG_AnimScriptEvent(*(_DWORD **)(v8 + 344), 18, 0, 1);
  }
}

//----- (08113FA2) --------------------------------------------------------
int __cdecl GScr_StopShellShock(int a1)
{
  int result; // eax
  int v2; // [esp+4h] [ebp-4h]

  v2 = GetPlayerEntity(a1);
  if ( Scr_GetNumParam() )
    Scr_Error((int)"USAGE: <player> stopshellshock()\n");
  *(_DWORD *)(*(_DWORD *)(v2 + 344) + 1496) = 0;
  *(_DWORD *)(*(_DWORD *)(v2 + 344) + 1500) = 0;
  result = *(_DWORD *)(v2 + 344);
  *(_DWORD *)(result + 1504) = 0;
  return result;
}

//----- (08114006) --------------------------------------------------------
float *__cdecl GScr_ViewKick(int a1)
{
  int v1; // ebx
  long double v2; // fst7
  char *v3; // eax
  float v5[7]; // [esp+10h] [ebp-28h] BYREF
  int v6; // [esp+2Ch] [ebp-Ch]

  v6 = GetPlayerEntity(a1);
  if ( Scr_GetNumParam() != 2 )
    Scr_Error((int)"USAGE: <player> viewkick <force 0-127> <source position>\n");
  v1 = *(_DWORD *)(v6 + 344);
  *(_DWORD *)(v1 + 10208) = (*(_DWORD *)(v6 + 408) * Scr_GetInt(0) + 50) / 100;
  if ( *(int *)(*(_DWORD *)(v6 + 344) + 10208) < 0 )
  {
    v2 = Scr_GetFloat(0);
    v3 = va("viewkick: damage %g < 0\n", (double)v2);
    Scr_Error((int)v3);
  }
  Scr_GetVector(1u, v5);
  return sub_811627E((float *)(*(_DWORD *)(v6 + 344) + 20), v5, (float *)(*(_DWORD *)(v6 + 344) + 10212));
}
// 8114006: using guessed type float var_28[7];

//----- (081140EC) --------------------------------------------------------
_DWORD *__cdecl sub_81140EC(int a1)
{
  float v2[12]; // [esp+10h] [ebp-68h] BYREF
  float v3[4]; // [esp+40h] [ebp-38h] BYREF
  float v4[7]; // [esp+50h] [ebp-28h] BYREF
  int v5; // [esp+6Ch] [ebp-Ch]

  v5 = Scr_EntityForRef(a1);
  Scr_GetVector(0, v4);
  sub_80A7146((float *)(v5 + 324), (int)v2);
  sub_80A4E52(v4, v2, v3);
  sub_811623A(v3, (float *)(v5 + 312), v3);
  return Scr_AddVector(v3);
}
// 81140EC: using guessed type float var_28[7];
// 81140EC: using guessed type float var_68[12];
// 81140EC: using guessed type float var_38[4];

//----- (0811416E) --------------------------------------------------------
void __cdecl sub_811416E(int a1)
{
  float v1; // [esp+8h] [ebp-10h]
  int v2; // [esp+Ch] [ebp-Ch]

  v2 = *(_DWORD *)(Scr_EntityForRef(a1) + 348);
  if ( !v2 )
    Scr_Error((int)"entity is not a turret");
  v1 = Scr_GetFloat(0);
  *(_DWORD *)(v2 + 16) = LODWORD(v1) ^ 0x80000000;
  if ( *(float *)(v2 + 16) > 0.0 )
    *(_DWORD *)(v2 + 16) = 0;
}

//----- (081141E2) --------------------------------------------------------
void __cdecl sub_81141E2(int a1)
{
  int v1; // [esp+Ch] [ebp-Ch]

  v1 = *(_DWORD *)(Scr_EntityForRef(a1) + 348);
  if ( !v1 )
    Scr_Error((int)"entity is not a turret");
  *(float *)(v1 + 24) = Scr_GetFloat(0);
  if ( *(float *)(v1 + 24) < 0.0 )
    *(_DWORD *)(v1 + 24) = 0;
}

//----- (0811424A) --------------------------------------------------------
void __cdecl sub_811424A(int a1)
{
  float v1; // [esp+8h] [ebp-10h]
  int v2; // [esp+Ch] [ebp-Ch]

  v2 = *(_DWORD *)(Scr_EntityForRef(a1) + 348);
  if ( !v2 )
    Scr_Error((int)"entity is not a turret");
  v1 = Scr_GetFloat(0);
  *(_DWORD *)(v2 + 12) = LODWORD(v1) ^ 0x80000000;
  if ( *(float *)(v2 + 12) > 0.0 )
    *(_DWORD *)(v2 + 12) = 0;
}

//----- (081142BE) --------------------------------------------------------
void __cdecl sub_81142BE(int a1)
{
  int v1; // [esp+Ch] [ebp-Ch]

  v1 = *(_DWORD *)(Scr_EntityForRef(a1) + 348);
  if ( !v1 )
    Scr_Error((int)"entity is not a turret");
  *(float *)(v1 + 20) = Scr_GetFloat(0);
  if ( *(float *)(v1 + 20) < 0.0 )
    *(_DWORD *)(v1 + 20) = 0;
}

//----- (08114326) --------------------------------------------------------
int __cdecl GScr_PlaceSpawnPoint(int a1)
{
  int v2[2]; // [esp+30h] [ebp-68h] BYREF
  float v3; // [esp+38h] [ebp-60h]
  int v4[4]; // [esp+40h] [ebp-58h] BYREF
  float s[7]; // [esp+50h] [ebp-48h] BYREF
  unsigned __int16 v6; // [esp+6Ch] [ebp-2Ch]
  char v7; // [esp+72h] [ebp-26h]
  int *v8; // [esp+8Ch] [ebp-Ch]

  v8 = (int *)Scr_EntityForRef(a1);
  Scr_VectorCopy(v8 + 78, v4);
  Scr_VectorCopy(v8 + 78, v2);
  v3 = v3 + 128.0;
  G_TraceCapsule(s, (float *)v4, (float *)dword_8167700, (float *)dword_816770C, (float *)v2, *v8, 42008593);
  sub_80DEB7A((float *)v4, (float *)v2, s[0], (float *)v4);
  Scr_VectorCopy(v4, v2);
  v3 = v3 - 262144.0;
  G_TraceCapsule(s, (float *)v4, (float *)dword_8167700, (float *)dword_816770C, (float *)v2, *v8, 42008593);
  v8[31] = v6;
  sub_80DEB7A((float *)v4, (float *)v2, s[0], (float *)v4);
  G_TraceCapsule(s, (float *)v4, (float *)dword_8167700, (float *)dword_816770C, (float *)v4, *v8, 42008593);
  if ( v7 )
    Com_Printf(
      "WARNING: Spawn point entity %i is in solid at (%i, %i, %i)\n",
      *v8,
      (int)*((float *)v8 + 78),
      (int)*((float *)v8 + 79),
      (int)*((float *)v8 + 80));
  return sub_811CF36(v8, v4);
}
// 8167700: using guessed type _DWORD dword_8167700[3];
// 816770C: using guessed type _DWORD dword_816770C[3];

//----- (0811451A) --------------------------------------------------------
int __cdecl GScr_UpdateScores(int a1)
{
  char *v1; // eax
  char *v2; // eax
  int v4; // [esp+14h] [ebp-4h]

  v4 = Scr_EntityForRef(a1);
  v1 = va("%c %i", 72, *(_DWORD *)dword_859B604);
  SV_GameSendServerCommand(-1963413621 * ((v4 - (int)&unk_8665480) >> 4), 0, v1);
  v2 = va("%c %i", 71, *(_DWORD *)dword_859B600);
  return SV_GameSendServerCommand(-1963413621 * ((v4 - (int)&unk_8665480) >> 4), 0, v2);
}

//----- (081145B4) --------------------------------------------------------
void GScr_MapRestart()
{
  if ( dword_859E9F0 )
  {
    if ( dword_859E9F0 == 1 )
      Scr_Error((int)"map_restart already called");
    else
      Scr_Error((int)"exitlevel already called");
  }
  dword_859E9F0 = 1;
  dword_859D154 = 0;
  if ( Scr_GetNumParam() )
    dword_859D154 = Scr_GetInt(0);
  Cbuf_ExecuteText(2, "fast_restart\n");
}
// 859D154: using guessed type int dword_859D154;
// 859E9F0: using guessed type int dword_859E9F0;

//----- (0811462C) --------------------------------------------------------
void GScr_LoadMap()
{
  char *v0; // eax
  char *s; // [esp+14h] [ebp-4h]

  if ( Scr_GetNumParam() )
  {
    s = (char *)Scr_GetString(0);
    if ( SV_MapExists(s) )
    {
      if ( dword_859E9F0 )
      {
        if ( dword_859E9F0 == 2 )
          Scr_Error((int)"map already called");
        else
          Scr_Error((int)"exitlevel already called");
      }
      dword_859E9F0 = 2;
      dword_859D154 = 0;
      if ( (unsigned int)Scr_GetNumParam() > 1 )
        dword_859D154 = Scr_GetInt(1u);
      v0 = va("map %s\n", s);
      Cbuf_ExecuteText(2, v0);
    }
  }
}
// 859D154: using guessed type int dword_859D154;
// 859E9F0: using guessed type int dword_859E9F0;

//----- (081146E2) --------------------------------------------------------
void GScr_ExitLevel()
{
  if ( dword_859E9F0 )
  {
    if ( dword_859E9F0 == 1 )
      Scr_Error((int)"map_restart already called");
    else
      Scr_Error((int)"exitlevel already called");
  }
  dword_859E9F0 = 3;
  dword_859D154 = 0;
  if ( Scr_GetNumParam() )
    dword_859D154 = Scr_GetInt(0);
  sub_809544E();
  ExitLevel();
}
// 859D154: using guessed type int dword_859D154;
// 859E9F0: using guessed type int dword_859E9F0;

//----- (08114750) --------------------------------------------------------
int *__usercall GScr_AddTestClient@<eax>(long double a1@<st0>)
{
  int *result; // eax

  result = (int *)SV_AddTestClient(a1);
  if ( result )
    return (int *)Scr_AddEntity(result);
  return result;
}

//----- (08114772) --------------------------------------------------------
char *__usercall GScr_MakeDvarServerInfo@<eax>(long double a1@<st0>)
{
  int v2; // eax
  size_t v3; // eax
  char v4; // al
  int v5; // [esp+24h] [ebp-824h]
  char *s; // [esp+28h] [ebp-820h]
  char *src; // [esp+2Ch] [ebp-81Ch]
  char v8; // [esp+30h] [ebp-818h] BYREF
  char v9[1024]; // [esp+430h] [ebp-418h] BYREF
  char *v10; // [esp+830h] [ebp-18h]
  int v11; // [esp+834h] [ebp-14h]
  size_t v12; // [esp+838h] [ebp-10h]
  unsigned int v13; // [esp+83Ch] [ebp-Ch]

  src = (char *)Scr_GetString(0);
  v5 = Dvar_FindVar(src);
  if ( v5 )
    return (char *)Dvar_AddFlags(v5, 256);
  v11 = Scr_GetType(1u);
  if ( v11 == 3 )
  {
    v2 = Scr_GetNumParam();
    Scr_ConstructMessageString(1, v2 - 1, "Dvar Value", (int)v9, 1024);
    s = v9;
    v3 = strlen(v9);
  }
  else
  {
    s = (char *)Scr_GetString(1u);
    v3 = strlen(s);
  }
  v12 = v3;
  v10 = &v8;
  v13 = 0;
  while ( v13 <= 0x3FE && s[v13] )
  {
    v4 = I_CleanChar(s[v13]);
    *v10 = v4;
    if ( *v10 == 34 )
      *v10 = 39;
    ++v13;
    ++v10;
  }
  *v10 = 0;
  return Dvar_RegisterString(a1, src, s, 16640);
}

//----- (081148C4) --------------------------------------------------------
int GScr_AllClientsPrint()
{
  int result; // eax
  char *v1; // eax
  const char *v2; // [esp+14h] [ebp-4h]

  result = Scr_GetNumParam();
  if ( result )
  {
    v2 = (const char *)Scr_GetString(0);
    v1 = va("%c \"%s\"", 101, v2);
    return SV_GameSendServerCommand(-1, 0, v1);
  }
  return result;
}

//----- (0811491A) --------------------------------------------------------
int GScr_MapExists()
{
  int result; // eax
  char *s; // [esp+4h] [ebp-4h]

  result = Scr_GetNumParam();
  if ( result )
  {
    s = (char *)Scr_GetString(0);
    if ( SV_MapExists(s) )
      return Scr_AddInt(1);
    else
      return Scr_AddInt(0);
  }
  return result;
}

//----- (08114966) --------------------------------------------------------
int GScr_IsValidGameType()
{
  int result; // eax
  char *v1; // [esp+4h] [ebp-4h]

  result = Scr_GetNumParam();
  if ( result )
  {
    v1 = (char *)Scr_GetString(0);
    if ( Scr_IsValidGameType(v1) )
      return Scr_AddInt(1);
    else
      return Scr_AddInt(0);
  }
  return result;
}

//----- (081149B2) --------------------------------------------------------
int GScr_SetVoteString()
{
  int result; // eax
  char *v1; // eax
  char *v2; // eax
  char *v3; // eax
  char *s1; // [esp+14h] [ebp-4h]

  result = Scr_GetNumParam();
  if ( result )
  {
    s1 = (char *)Scr_GetString(0);
    SV_SetConfigstring(0x10u, s1);
    v1 = va("%i", *(_DWORD *)dword_859BF1C);
    SV_SetConfigstring(0xFu, v1);
    v2 = va("%i", *(_DWORD *)dword_859BF24);
    SV_SetConfigstring(0x11u, v2);
    v3 = va("%i", *(_DWORD *)dword_859BF28);
    return SV_SetConfigstring(0x12u, v3);
  }
  return result;
}

//----- (08114A5A) --------------------------------------------------------
int GScr_SetVoteTime()
{
  int result; // eax
  char *v1; // eax
  char *v2; // eax
  char *v3; // eax
  int v4; // [esp+14h] [ebp-4h]

  result = Scr_GetNumParam();
  if ( result )
  {
    v4 = Scr_GetInt(0);
    v1 = va("%i", v4);
    SV_SetConfigstring(0xFu, v1);
    v2 = va("%i", *(_DWORD *)dword_859BF24);
    SV_SetConfigstring(0x11u, v2);
    v3 = va("%i", *(_DWORD *)dword_859BF28);
    return SV_SetConfigstring(0x12u, v3);
  }
  return result;
}

//----- (08114AEA) --------------------------------------------------------
int GScr_SetVoteYesCount()
{
  int result; // eax
  char *v1; // eax
  char *v2; // eax
  int v3; // [esp+14h] [ebp-4h]

  result = Scr_GetNumParam();
  if ( result )
  {
    v3 = Scr_GetInt(0);
    v1 = va("%i", v3);
    SV_SetConfigstring(0x11u, v1);
    v2 = va("%i", *(_DWORD *)dword_859BF28);
    return SV_SetConfigstring(0x12u, v2);
  }
  return result;
}

//----- (08114B54) --------------------------------------------------------
int GScr_SetVoteNoCount()
{
  int result; // eax
  char *v1; // eax
  int v2; // [esp+14h] [ebp-4h]

  result = Scr_GetNumParam();
  if ( result )
  {
    v2 = Scr_GetInt(0);
    v1 = va("%i", v2);
    return SV_SetConfigstring(0x12u, v1);
  }
  return result;
}

//----- (08114B9A) --------------------------------------------------------
void GScr_KickPlayer()
{
  char *v0; // eax
  int v1; // [esp+14h] [ebp-4h]

  if ( Scr_GetNumParam() )
  {
    v1 = Scr_GetInt(0);
    v0 = va("tempBanClient %i\n", v1);
    Cbuf_ExecuteText(2, v0);
  }
}

//----- (08114BE0) --------------------------------------------------------
void GScr_BanPlayer()
{
  char *v0; // eax
  int v1; // [esp+14h] [ebp-4h]

  if ( Scr_GetNumParam() )
  {
    v1 = Scr_GetInt(0);
    v0 = va("banClient %i\n", v1);
    Cbuf_ExecuteText(2, v0);
  }
}

//----- (08114C26) --------------------------------------------------------
int GScr_ClientPrint()
{
  int result; // eax
  char *v1; // eax
  const char *v2; // [esp+10h] [ebp-8h]
  int v3; // [esp+14h] [ebp-4h]

  result = Scr_GetNumParam();
  if ( result )
  {
    v3 = Scr_GetEntity(0);
    v2 = (const char *)Scr_GetString(1u);
    v1 = va("%c \"%s\"", 101, v2);
    return SV_GameSendServerCommand(-1963413621 * ((v3 - (int)&unk_8665480) >> 4), 0, v1);
  }
  return result;
}

//----- (08114C98) --------------------------------------------------------
unsigned int GScr_OpenFile()
{
  unsigned int result; // eax
  char *v1; // eax
  char *v2; // eax
  char *v3; // eax
  int v4; // [esp+18h] [ebp-20h]
  int i; // [esp+1Ch] [ebp-1Ch]
  int v6; // [esp+24h] [ebp-14h] BYREF
  int v7; // [esp+28h] [ebp-10h]
  char *s1; // [esp+2Ch] [ebp-Ch]
  char *src; // [esp+30h] [ebp-8h]

  v7 = 0;
  result = Scr_GetNumParam();
  if ( result > 1 )
  {
    src = (char *)Scr_GetString(0);
    s1 = (char *)Scr_GetString(1u);
    for ( i = 0; i <= 0; ++i )
    {
      if ( dword_859EA08[i] < 0 )
      {
        v7 = 4 * i + 140110344;
        break;
      }
    }
    if ( !v7 )
    {
      Com_Printf("OpenFile failed.  %i files already open\n", 1);
      return Scr_AddInt(-1);
    }
    if ( !strcmp(s1, "read") )
    {
      v1 = va("%s/%s", "scriptdata", src);
      v4 = FS_FOpenFileByMode(v1, &v6, 0);
      if ( v4 >= 0 )
      {
        *(&dword_859EA0C + i) = Z_MallocInternal(v4 + 1);
        FS_Read((int)*(&dword_859EA0C + i), v4, v6);
        FS_FCloseFile(v6);
        *((_BYTE *)*(&dword_859EA0C + i) + v4) = 0;
        Com_BeginParseSession(src);
        sub_80B3B00(1);
        dword_859EA10[5 * i] = 0;
        return Scr_AddInt(i);
      }
      return Scr_AddInt(-1);
    }
    if ( !strcmp(s1, "write") )
    {
      v2 = va("%s/%s", "scriptdata", src);
      if ( FS_FOpenFileByMode(v2, (int *)v7, 1) >= 0 )
        return Scr_AddInt(i);
      return Scr_AddInt(-1);
    }
    if ( !strcmp(s1, "append") )
    {
      v3 = va("%s/%s", "scriptdata", src);
      if ( FS_FOpenFileByMode(v3, (int *)v7, 2) >= 0 )
        return Scr_AddInt(i);
      return Scr_AddInt(-1);
    }
    Com_Printf("Valid openfile modes are 'write', 'read', and 'append'\n");
    return Scr_AddInt(-1);
  }
  return result;
}
// 859EA08: using guessed type int dword_859EA08[];
// 859EA10: using guessed type int dword_859EA10[];

//----- (08114F2C) --------------------------------------------------------
int GScr_CloseFile()
{
  int result; // eax
  unsigned int v1; // [esp+14h] [ebp-4h]

  result = Scr_GetNumParam();
  if ( result )
  {
    v1 = Scr_GetInt(0);
    if ( v1 >= 2 )
    {
      Com_Printf("CloseFile failed, invalid file number %i\n", v1);
      return Scr_AddInt(-1);
    }
    if ( dword_859EA08[v1] <= 0 )
    {
      if ( !*(&dword_859EA0C + v1) )
      {
        Com_Printf("CloseFile failed, file number %i was not open\n", v1);
        return Scr_AddInt(-1);
      }
      Com_EndParseSession();
      Z_FreeInternal(*(&dword_859EA0C + v1));
      *(&dword_859EA0C + v1) = 0;
    }
    else
    {
      FS_FCloseFile(dword_859EA08[v1]);
      dword_859EA08[v1] = -1;
    }
    return Scr_AddInt(1);
  }
  return result;
}
// 859EA08: using guessed type int dword_859EA08[];

//----- (08115014) --------------------------------------------------------
int GScr_FPrintln()
{
  size_t v1; // eax
  int v2; // eax
  char *s; // [esp+Ch] [ebp-Ch]
  unsigned int i; // [esp+10h] [ebp-8h]
  unsigned int v5; // [esp+14h] [ebp-4h]

  if ( (unsigned int)Scr_GetNumParam() > 1 )
  {
    v5 = Scr_GetInt(0);
    if ( v5 < 2 )
    {
      if ( dword_859EA08[v5] >= 0 )
      {
        for ( i = 1; i < Scr_GetNumParam(); ++i )
        {
          s = (char *)Scr_GetString(i);
          v1 = strlen(s);
          FS_Write(s, v1, dword_859EA08[v5]);
          FS_Write(",", 1u, dword_859EA08[v5]);
        }
        v2 = Scr_GetNumParam();
        return Scr_AddInt(v2 - 1);
      }
      else
      {
        Com_Printf("FPrintln failed, file number %i was not open for writing\n", v5);
        return Scr_AddInt(-1);
      }
    }
    else
    {
      Com_Printf("FPrintln failed, invalid file number %i\n", v5);
      return Scr_AddInt(-1);
    }
  }
  else
  {
    Com_Printf("fprintln requires at least 2 parameters (file, output)\n");
    return Scr_AddInt(-1);
  }
}
// 859EA08: using guessed type int dword_859EA08[];

//----- (08115138) --------------------------------------------------------
int GScr_FReadLn()
{
  int v1; // eax
  int v2; // eax
  char *v3; // [esp+Ch] [ebp-Ch] BYREF
  _BOOL4 v4; // [esp+10h] [ebp-8h]
  char v5[4]; // [esp+14h] [ebp-4h]

  if ( Scr_GetNumParam() )
  {
    *(_DWORD *)v5 = Scr_GetInt(0);
    if ( *(_DWORD *)v5 < 2u )
    {
      if ( *(&dword_859EA0C + *(_DWORD *)v5) )
      {
        v3 = (char *)*(&dword_859EA0C + *(_DWORD *)v5);
        if ( dword_859EA10[5 * *(_DWORD *)v5] )
        {
          Com_ParseReturnToMark(&v3, (_DWORD *)(20 * *(_DWORD *)v5 + 140110352));
          Com_SkipRestOfLine(&v3);
          Com_ParseSetMark(&v3, (_DWORD *)(20 * *(_DWORD *)v5 + 140110352));
          v4 = *Com_Parse(&v3) == 0;
          Com_ParseReturnToMark(&v3, (_DWORD *)(20 * *(_DWORD *)v5 + 140110352));
          if ( v4 )
          {
            return Scr_AddInt(-1);
          }
          else
          {
            v2 = Com_GetArgCountOnLine(&v3);
            return Scr_AddInt(v2);
          }
        }
        else
        {
          Com_ParseSetMark(&v3, (_DWORD *)(20 * *(_DWORD *)v5 + 140110352));
          v1 = Com_GetArgCountOnLine(&v3);
          return Scr_AddInt(v1);
        }
      }
      else
      {
        Com_Printf("freadln failed, file number %i was not open for reading\n", *(_DWORD *)v5);
        return Scr_AddInt(-1);
      }
    }
    else
    {
      Com_Printf("freadln failed, invalid file number %i\n", *(_DWORD *)v5);
      return Scr_AddInt(-1);
    }
  }
  else
  {
    Com_Printf("freadln requires a parameter - the file to read from\n");
    return Scr_AddInt(-1);
  }
}
// 859EA10: using guessed type int dword_859EA10[];

//----- (081152F0) --------------------------------------------------------
int GScr_FGetArg()
{
  char *v1; // [esp+14h] [ebp-14h] BYREF
  char *s; // [esp+18h] [ebp-10h]
  int i; // [esp+1Ch] [ebp-Ch]
  char v4[4]; // [esp+20h] [ebp-8h]
  char v5[4]; // [esp+24h] [ebp-4h]

  if ( (unsigned int)Scr_GetNumParam() > 1 )
  {
    *(_DWORD *)v5 = Scr_GetInt(0);
    *(_DWORD *)v4 = Scr_GetInt(1u);
    if ( *(_DWORD *)v5 < 2u )
    {
      if ( *(int *)v4 >= 0 )
      {
        if ( *(&dword_859EA0C + *(_DWORD *)v5) )
        {
          s = 0;
          v1 = (char *)*(&dword_859EA0C + *(_DWORD *)v5);
          Com_ParseReturnToMark(&v1, (_DWORD *)(20 * *(_DWORD *)v5 + 140110352));
          for ( i = 0; i <= *(int *)v4; ++i )
          {
            s = Com_ParseOnLine(&v1);
            if ( !*s )
            {
              Com_Printf(
                "freadline failed, there aren't %i arguments on this line, there are only %i arguments\n",
                *(_DWORD *)v4 + 1,
                i);
              return Scr_AddString((char *)&byte_8153FCE);
            }
          }
          return Scr_AddString(s);
        }
        else
        {
          Com_Printf("freadline failed, file number %i was not open for reading\n", *(_DWORD *)v5);
          return Scr_AddString((char *)&byte_8153FCE);
        }
      }
      else
      {
        Com_Printf("freadline failed, invalid argument number %i\n", *(_DWORD *)v4);
        return Scr_AddString((char *)&byte_8153FCE);
      }
    }
    else
    {
      Com_Printf("freadline failed, invalid file number %i\n", *(_DWORD *)v5);
      return Scr_AddString((char *)&byte_8153FCE);
    }
  }
  else
  {
    Com_Printf("freadline requires at least 2 parameters (file, string)\n");
    return Scr_AddString((char *)&byte_8153FCE);
  }
}

//----- (08115462) --------------------------------------------------------
void *sub_8115462()
{
  int v0; // eax

  v0 = Scr_GetInt(0);
  return sub_80919F4(v0);
}

//----- (08115490) --------------------------------------------------------
int sub_8115490()
{
  return Scr_AddInt(0);
}

//----- (081154B6) --------------------------------------------------------
void __cdecl GScr_SetTeamForTrigger(int a1)
{
  const char *v1; // ebx
  const char *v2; // eax
  char *v3; // eax
  const char *v4; // esi
  const char *v5; // ebx
  const char *v6; // eax
  char *v7; // eax
  __int16 v8; // [esp+1Ah] [ebp-Eh]
  int v9; // [esp+1Ch] [ebp-Ch]

  v9 = Scr_EntityForRef(a1);
  if ( *(_WORD *)(v9 + 360) != word_87A22F6 && *(_WORD *)(v9 + 360) != word_87A22F8 )
  {
    v1 = (const char *)SL_ConvertToString((unsigned __int16)word_87A22F8);
    v2 = (const char *)SL_ConvertToString((unsigned __int16)word_87A22F6);
    v3 = va("setteamfortrigger: trigger entity must be of type %s or %s", v2, v1);
    Scr_Error((int)v3);
  }
  v8 = Scr_GetConstString(0);
  if ( v8 == word_87A22A2 )
  {
    *(_BYTE *)(v9 + 359) = 2;
  }
  else if ( v8 == word_87A22A4 )
  {
    *(_BYTE *)(v9 + 359) = 1;
  }
  else if ( v8 == word_87A2314 )
  {
    *(_BYTE *)(v9 + 359) = 0;
  }
  else
  {
    v4 = (const char *)SL_ConvertToString((unsigned __int16)word_87A2314);
    v5 = (const char *)SL_ConvertToString((unsigned __int16)word_87A22A4);
    v6 = (const char *)SL_ConvertToString((unsigned __int16)word_87A22A2);
    v7 = va("setteamfortrigger: invalid team used must be %s, %s or %s", v6, v5, v4);
    Scr_Error((int)v7);
  }
}
// 87A22A2: using guessed type __int16 word_87A22A2;
// 87A22A4: using guessed type __int16 word_87A22A4;
// 87A22F6: using guessed type __int16 word_87A22F6;
// 87A22F8: using guessed type __int16 word_87A22F8;
// 87A2314: using guessed type __int16 word_87A2314;

//----- (081155E4) --------------------------------------------------------
int __cdecl GScr_ClientClaimTrigger(int a1)
{
  const char *v1; // ebx
  const char *v2; // eax
  char *v3; // eax
  int result; // eax
  int v5; // [esp+Ch] [ebp-Ch]
  int v6; // [esp+10h] [ebp-8h]

  v6 = Scr_EntityForRef(a1);
  if ( !*(_DWORD *)(v6 + 344) )
    Scr_Error((int)"clientclaimtrigger: claimer must be a client.");
  v5 = Scr_GetEntity(0);
  if ( *(_WORD *)(v5 + 360) != word_87A22F6 && *(_WORD *)(v5 + 360) != word_87A22F8 )
  {
    v1 = (const char *)SL_ConvertToString((unsigned __int16)word_87A22F8);
    v2 = (const char *)SL_ConvertToString((unsigned __int16)word_87A22F6);
    v3 = va("clientclaimtrigger: trigger entity must be of type %s or %s", v2, v1);
    Scr_Error((int)v3);
  }
  if ( *(_DWORD *)(v5 + 436) == 1023
    || (result = *(_DWORD *)(v5 + 436), result == *(_DWORD *)(*(_DWORD *)(v6 + 344) + 204)) )
  {
    result = *(_DWORD *)(*(_DWORD *)(v6 + 344) + 204);
    *(_DWORD *)(v5 + 436) = result;
  }
  return result;
}
// 87A22F6: using guessed type __int16 word_87A22F6;
// 87A22F8: using guessed type __int16 word_87A22F8;

//----- (081156CC) --------------------------------------------------------
int __cdecl GScr_ClientReleaseTrigger(int a1)
{
  const char *v1; // ebx
  const char *v2; // eax
  char *v3; // eax
  int result; // eax
  int v5; // [esp+Ch] [ebp-Ch]
  int v6; // [esp+10h] [ebp-8h]

  v6 = Scr_EntityForRef(a1);
  if ( !*(_DWORD *)(v6 + 344) )
    Scr_Error((int)"clientreleasetrigger: releaser must be a client.");
  v5 = Scr_GetEntity(0);
  if ( *(_WORD *)(v5 + 360) != word_87A22F6 && *(_WORD *)(v5 + 360) != word_87A22F8 )
  {
    v1 = (const char *)SL_ConvertToString((unsigned __int16)word_87A22F8);
    v2 = (const char *)SL_ConvertToString((unsigned __int16)word_87A22F6);
    v3 = va("clientreleasetrigger: trigger entity must be of type %s or %s", v2, v1);
    Scr_Error((int)v3);
  }
  result = *(_DWORD *)(v5 + 436);
  if ( result == *(_DWORD *)(*(_DWORD *)(v6 + 344) + 204) )
  {
    result = v5;
    *(_DWORD *)(v5 + 436) = 1023;
  }
  return result;
}
// 87A22F6: using guessed type __int16 word_87A22F6;
// 87A22F8: using guessed type __int16 word_87A22F8;

//----- (0811579A) --------------------------------------------------------
int __cdecl GScr_ReleaseClaimedTrigger(int a1)
{
  const char *v1; // ebx
  const char *v2; // eax
  char *v3; // eax
  int result; // eax
  int v5; // [esp+10h] [ebp-8h]

  v5 = Scr_EntityForRef(a1);
  if ( *(_WORD *)(v5 + 360) != word_87A22F6 && *(_WORD *)(v5 + 360) != word_87A22F8 )
  {
    v1 = (const char *)SL_ConvertToString((unsigned __int16)word_87A22F8);
    v2 = (const char *)SL_ConvertToString((unsigned __int16)word_87A22F6);
    v3 = va("releaseclaimedtrigger: trigger entity must be of type %s or %s", v2, v1);
    Scr_Error((int)v3);
  }
  result = v5;
  *(_DWORD *)(v5 + 436) = 1023;
  return result;
}
// 87A22F6: using guessed type __int16 word_87A22F6;
// 87A22F8: using guessed type __int16 word_87A22F8;

//----- (08115824) --------------------------------------------------------
int __cdecl Scr_GetFunction(char **a1, _DWORD *a2)
{
  char *s1; // [esp+10h] [ebp-8h]
  unsigned int i; // [esp+14h] [ebp-4h]

  s1 = *a1;
  for ( i = 0; i <= 0x8F; ++i )
  {
    if ( !strcmp(s1, (&off_8167BC0)[3 * i]) )
    {
      *a1 = (&off_8167BC0)[3 * i];
      *a2 = dword_8167BC8[3 * i];
      return (int)*(&off_8167BC4 + 3 * i);
    }
  }
  return 0;
}
// 8167BC0: using guessed type char *off_8167BC0;
// 8167BC4: using guessed type int (*off_8167BC4)();
// 8167BC8: using guessed type int dword_8167BC8[];

//----- (081158C2) --------------------------------------------------------
int __cdecl Script_GetMethod(char **a1, _DWORD *a2)
{
  char *s1; // [esp+10h] [ebp-8h]
  unsigned int i; // [esp+14h] [ebp-4h]

  s1 = *a1;
  for ( i = 0; i <= 0x3A; ++i )
  {
    if ( !strcmp(s1, (&off_8168280)[3 * i]) )
    {
      *a1 = (&off_8168280)[3 * i];
      *a2 = dword_8168288[3 * i];
      return (int)*(&off_8168284 + 3 * i);
    }
  }
  return 0;
}
// 8168280: using guessed type char *off_8168280;
// 8168284: using guessed type int (__cdecl *off_8168284)(int);
// 8168288: using guessed type int dword_8168288[];

//----- (0811595C) --------------------------------------------------------
int (__cdecl *__cdecl Scr_GetMethod(char **a1, _DWORD *a2))(int)
{
  int (__cdecl *v3)(int); // [esp+10h] [ebp-8h]
  int v4; // [esp+10h] [ebp-8h]
  int (__cdecl *v5)(int); // [esp+10h] [ebp-8h]
  int (__cdecl *v6)(int); // [esp+14h] [ebp-4h]

  *a2 = 0;
  v6 = Player_GetMethod(a1);
  v3 = ScriptEnt_GetMethod(a1);
  if ( !v6 )
    v6 = v3;
  v4 = Script_GetMethod(a1, a2);
  if ( !v6 )
    v6 = (int (__cdecl *)(int))v4;
  v5 = HudElem_GetMethod(a1);
  if ( !v6 )
    return v5;
  return v6;
}

//----- (081159D4) --------------------------------------------------------
int __cdecl sub_81159D4(int a1)
{
  int result; // eax
  _DWORD v2[6]; // [esp+10h] [ebp-18h] BYREF

  Scr_GetVector(0, v2);
  sub_811CF36((_DWORD *)a1, v2);
  result = a1;
  if ( *(_BYTE *)(a1 + 240) )
    return SV_LinkEntity(a1);
  return result;
}
// 81159D4: using guessed type _DWORD var_18[6];

//----- (08115A18) --------------------------------------------------------
int __cdecl sub_8115A18(_DWORD *a1)
{
  _DWORD v2[6]; // [esp+10h] [ebp-18h] BYREF

  Scr_GetVector(0, v2);
  return sub_811CF96(a1, v2);
}
// 8115A18: using guessed type _DWORD var_18[6];

//----- (08115A46) --------------------------------------------------------
int __cdecl sub_8115A46(_DWORD *a1)
{
  int result; // eax
  int v2; // [esp+4h] [ebp-4h]

  v2 = Scr_GetInt(0);
  if ( a1[86] )
  {
    a1[101] = v2;
    result = v2;
    *(_DWORD *)(a1[86] + 300) = v2;
  }
  else
  {
    a1[102] = v2;
    result = v2;
    a1[101] = v2;
  }
  return result;
}

//----- (08115AA2) --------------------------------------------------------
_DWORD *__cdecl GScr_AddVector(_DWORD *a1)
{
  if ( a1 )
    return Scr_AddVector(a1);
  else
    return (_DWORD *)Scr_AddUndefined();
}

//----- (08115AC2) --------------------------------------------------------
int __cdecl GScr_AddEntity(int *a1)
{
  if ( a1 )
    return Scr_AddEntity(a1);
  else
    return Scr_AddUndefined();
}

//----- (08115AE2) --------------------------------------------------------
int Scr_ParseGameTypeList()
{
  char *v0; // eax
  char *v1; // eax
  int result; // eax
  size_t v3; // [esp+28h] [ebp-1440h]
  int v4; // [esp+2Ch] [ebp-143Ch] BYREF
  char v5[4096]; // [esp+30h] [ebp-1438h] BYREF
  char s[1036]; // [esp+1030h] [ebp-438h] BYREF
  char *v7; // [esp+143Ch] [ebp-2Ch]
  char *dest; // [esp+1440h] [ebp-28h]
  char *v9; // [esp+1444h] [ebp-24h]
  char *v10; // [esp+1448h] [ebp-20h] BYREF
  int v11; // [esp+144Ch] [ebp-1Ch]
  int v12; // [esp+1450h] [ebp-18h]
  int v13; // [esp+1454h] [ebp-14h]
  int i; // [esp+1458h] [ebp-10h]
  char *src; // [esp+145Ch] [ebp-Ch]

  memset(s, 0, 0x400u);
  v12 = 0;
  memset(&unk_879C7AC, 0, 0x1080u);
  v11 = FS_GetFileList("maps/mp/gametypes", "gsc", 0, v5, 4096);
  src = v5;
  for ( i = 0; i < v11; ++i )
  {
    dest = (char *)(132 * v12 + 142198700);
    v3 = strlen(src);
    if ( *src == 95 )
    {
      src += v3 + 1;
    }
    else
    {
      if ( !I_stricmp(&src[v3 - 4], ".gsc") )
        src[v3 - 4] = 0;
      if ( v12 == 32 )
      {
        Com_Printf("Too many game type scripts found! Only loading the first %i\n", 31);
        break;
      }
      I_strncpyz(dest, src, 64);
      strlwr(dest);
      v7 = va("maps/mp/gametypes/%s.txt", src);
      v13 = FS_FOpenFileByMode(v7, &v4, 0);
      if ( v13 > 0 && v13 <= 1023 )
      {
        FS_Read((int)s, v13, v4);
        v10 = s;
        v9 = Com_Parse(&v10);
        I_strncpyz(dest + 64, v9, 64);
        v9 = Com_Parse(&v10);
        *((_DWORD *)dest + 32) = v9 && !I_stricmp(v9, "team");
      }
      else
      {
        if ( v13 > 0 )
        {
          v1 = va("maps/mp/gametypes/%s.txt", src);
          Com_Printf("WARNING: GameType description file %s is too big to load.\n", v1);
        }
        else
        {
          v0 = va("maps/mp/gametypes/%s.txt", src);
          Com_Printf("WARNING: Could not load GameType description file %s for gametype %s\n", v0, src);
        }
        I_strncpyz(dest + 64, dest, 64);
        *((_DWORD *)dest + 32) = 0;
      }
      ++v12;
      if ( v13 > 0 )
        FS_FCloseFile(v4);
      src += v3 + 1;
    }
  }
  result = v12;
  dword_879C7A8 = v12;
  return result;
}
// 879C7A8: using guessed type int dword_879C7A8;

//----- (08115DD2) --------------------------------------------------------
int __cdecl sub_8115DD2(char *a1)
{
  int i; // [esp+14h] [ebp-4h]

  for ( i = 0; i < dword_879C7A8; ++i )
  {
    if ( !I_stricmp((char *)(132 * i + 142198700), a1) )
      return 132 * i + 142198764;
  }
  return 0;
}
// 879C7A8: using guessed type int dword_879C7A8;

//----- (08115E3C) --------------------------------------------------------
_BOOL4 __cdecl Scr_IsValidGameType(char *a1)
{
  return sub_8115DD2(a1) != 0;
}

//----- (08115E66) --------------------------------------------------------
int sub_8115E66()
{
  unsigned __int16 v1; // [esp+16h] [ebp-2h]

  v1 = Scr_ExecThread(dword_879C788, 0);
  return Scr_FreeThread(v1);
}
// 879C788: using guessed type int dword_879C788;

//----- (08115E94) --------------------------------------------------------
int sub_8115E94()
{
  unsigned __int16 v1; // [esp+16h] [ebp-2h]

  v1 = Scr_ExecThread(dword_879C78C, 0);
  return Scr_FreeThread(v1);
}
// 879C78C: using guessed type int dword_879C78C;

//----- (08115EC2) --------------------------------------------------------
int __cdecl Scr_PlayerConnect(int *a1)
{
  unsigned __int16 v2; // [esp+16h] [ebp-2h]

  v2 = Scr_ExecEntThread(a1, dword_879C790, 0);
  return Scr_FreeThread(v2);
}
// 879C790: using guessed type int dword_879C790;

//----- (08115EF6) --------------------------------------------------------
int __cdecl sub_8115EF6(int *a1)
{
  unsigned __int16 v2; // [esp+16h] [ebp-2h]

  v2 = Scr_ExecEntThread(a1, dword_879C794, 0);
  return Scr_FreeThread(v2);
}
// 879C794: using guessed type int dword_879C794;

//----- (08115F2A) --------------------------------------------------------
int __cdecl Scr_PlayerDamage(
        int *a1,
        int *a2,
        int *a3,
        int a4,
        int a5,
        unsigned int a6,
        int a7,
        _DWORD *a8,
        _DWORD *a9,
        int a10,
        int a11)
{
  unsigned __int16 v11; // ax
  char **v12; // eax
  unsigned __int16 v14; // [esp+16h] [ebp-2h]

  Scr_AddInt(a11);
  v11 = G_GetHitLocationString(a10);
  Scr_AddConstString(v11);
  GScr_AddVector(a9);
  GScr_AddVector(a8);
  v12 = (char **)BG_WeaponDefs(a7);
  Scr_AddString(*v12);
  if ( a6 < 0xF )
    Scr_AddString((&off_81677C0)[a6]);
  else
    Scr_AddString("badMOD");
  Scr_AddInt(a5);
  Scr_AddInt(a4);
  GScr_AddEntity(a3);
  GScr_AddEntity(a2);
  v14 = Scr_ExecEntThread(a1, dword_879C798, 10);
  return Scr_FreeThread(v14);
}
// 879C798: using guessed type int dword_879C798;

//----- (08116004) --------------------------------------------------------
int __cdecl Scr_PlayerKilled(
        int *a1,
        int *a2,
        int *a3,
        int a4,
        unsigned int a5,
        int a6,
        _DWORD *a7,
        int a8,
        int a9,
        int a10)
{
  unsigned __int16 v10; // ax
  char **v11; // eax
  unsigned __int16 v13; // [esp+16h] [ebp-2h]

  Scr_AddInt(a10);
  Scr_AddInt(a9);
  v10 = G_GetHitLocationString(a8);
  Scr_AddConstString(v10);
  GScr_AddVector(a7);
  v11 = (char **)BG_WeaponDefs(a6);
  Scr_AddString(*v11);
  if ( a5 < 0xF )
    Scr_AddString((&off_81677C0)[a5]);
  else
    Scr_AddString("badMOD");
  Scr_AddInt(a4);
  GScr_AddEntity(a3);
  GScr_AddEntity(a2);
  v13 = Scr_ExecEntThread(a1, dword_879C79C, 9);
  return Scr_FreeThread(v13);
}
// 879C79C: using guessed type int dword_879C79C;

//----- (081160D4) --------------------------------------------------------
int __cdecl sub_81160D4(int *a1, char *a2, char *a3, char *s)
{
  Scr_AddString(s);
  Scr_AddString(a3);
  Scr_AddString(a2);
  return Scr_Notify(a1, word_87A231E, 3);
}
// 87A231E: using guessed type __int16 word_87A231E;

//----- (0811611C) --------------------------------------------------------
int __cdecl sub_811611C(int *a1, char *s)
{
  Scr_AddString(s);
  return Scr_Notify(a1, word_87A2320, 1);
}
// 87A2320: using guessed type __int16 word_87A2320;

//----- (08116158) --------------------------------------------------------
int __cdecl floorf(float a1)
{
  return (int)floor(a1 + 0.5);
}

//----- (0811618E) --------------------------------------------------------
void __cdecl sub_811618E(float a1, float *a2, float *a3)
{
  *a2 = sin(a1);
  *a3 = cos(a1);
}

//----- (081161BC) --------------------------------------------------------
int __cdecl sub_81161BC(_DWORD *a1)
{
  int result; // eax

  *a1 = 0;
  a1[1] = 0;
  result = 0;
  a1[2] = 0;
  return result;
}

//----- (081161E6) --------------------------------------------------------
int __cdecl sub_81161E6(_DWORD *a1, int a2, int a3, int a4)
{
  int result; // eax

  *a1 = a2;
  a1[1] = a3;
  result = a4;
  a1[2] = a4;
  return result;
}

//----- (0811620A) --------------------------------------------------------
int __cdecl Scr_VectorCopy(_DWORD *a1, _DWORD *a2)
{
  int result; // eax

  *a2 = *a1;
  a2[1] = a1[1];
  result = a1[2];
  a2[2] = result;
  return result;
}

//----- (0811623A) --------------------------------------------------------
float *__cdecl sub_811623A(float *a1, float *a2, float *a3)
{
  float *result; // eax

  *a3 = *a1 + *a2;
  a3[1] = a1[1] + a2[1];
  result = a1 + 2;
  a3[2] = a1[2] + a2[2];
  return result;
}

//----- (0811627E) --------------------------------------------------------
float *__cdecl sub_811627E(float *a1, float *a2, float *a3)
{
  float *result; // eax

  *a3 = *a1 - *a2;
  a3[1] = a1[1] - a2[1];
  result = a1 + 2;
  a3[2] = a1[2] - a2[2];
  return result;
}

//----- (081162C2) --------------------------------------------------------
float *__cdecl sub_81162C2(float *a1, float a2, float *a3)
{
  float *result; // eax

  *a3 = a2 * *a1;
  a3[1] = a2 * a1[1];
  result = a1 + 2;
  a3[2] = a2 * a1[2];
  return result;
}

//----- (081162FA) --------------------------------------------------------
long double __cdecl sub_81162FA(float *a1, float *a2)
{
  return *a1 * *a2 + a1[1] * a2[1] + a1[2] * a2[2];
}

//----- (0811632E) --------------------------------------------------------
long double __cdecl sub_811632E(float *a1)
{
  return *a1 * *a1 + a1[1] * a1[1] + a1[2] * a1[2];
}

//----- (08116362) --------------------------------------------------------
void __cdecl sub_8116362(float *a1)
{
  float v1; // [esp+0h] [ebp-8h]

  v1 = *a1 * *a1 + a1[1] * a1[1] + a1[2] * a1[2];
  sub_81163A0(v1);
}

//----- (081163A0) --------------------------------------------------------
long double __cdecl sub_81163A0(float a1)
{
  return (float)sqrt(a1);
}

//----- (081163C0) --------------------------------------------------------
int __cdecl sub_81163C0(int a1, int a2, float a3, float a4, float a5, float *a6, float *a7, float *a8)
{
  int v10; // [esp+1Ch] [ebp-2Ch]
  int v11[7]; // [esp+20h] [ebp-28h] BYREF
  float v12; // [esp+3Ch] [ebp-Ch]

  v10 = (int)(a4 * 1000.0);
  if ( *(_DWORD *)a1 == 7 && v10 > 0 )
  {
    *(_DWORD *)(a1 + 4) = dword_859B5EC;
    *(_DWORD *)(a1 + 8) = v10;
    sub_8117DEE(a6, (_DWORD *)(a1 + 12));
    sub_8117E1E(a7, a6, (float *)v11);
    v12 = 1000.0 / (long double)v10;
    sub_8117E62((float *)v11, v12, (float *)(a1 + 24));
    *(_DWORD *)a1 = 3;
    return 0;
  }
  if ( (*(_DWORD *)a1 == 7 && v10 <= 0 || *(_DWORD *)a1 == 3) && a5 > 0.0 )
  {
    *(_DWORD *)(a1 + 4) = dword_859B5EC;
    *(_DWORD *)(a1 + 8) = (int)(a5 * 1000.0);
    sub_8117DEE(a7, (_DWORD *)(a1 + 12));
    sub_8117E1E(a8, a7, (float *)v11);
    Vec3Normalize((float *)v11);
    sub_8117E62((float *)v11, a3, (float *)v11);
    sub_8117DEE(v11, (_DWORD *)(a1 + 24));
    *(_DWORD *)a1 = 8;
    return 0;
  }
  if ( *(_DWORD *)a1 == 5 )
    BG_EvaluateTrajectory(a1, dword_859B5EC, a1 + 12);
  else
    sub_8117DEE(a8, (_DWORD *)(a1 + 12));
  *(_DWORD *)(a1 + 4) = dword_859B5EC;
  *(_DWORD *)a1 = 0;
  return 1;
}

//----- (081165A0) --------------------------------------------------------
int __cdecl sub_81165A0(int a1)
{
  int result; // eax
  int v2; // [esp+20h] [ebp-8h]
  int v3; // [esp+20h] [ebp-8h]

  if ( *(_DWORD *)(a1 + 12) )
  {
    if ( *(_DWORD *)(a1 + 16) + *(_DWORD *)(a1 + 20) <= dword_859B5EC )
    {
      v2 = sub_81163C0(
             a1 + 12,
             a1 + 312,
             *(float *)(a1 + 432),
             *(float *)(a1 + 440),
             *(float *)(a1 + 424),
             (float *)(a1 + 448),
             (float *)(a1 + 460),
             (float *)(a1 + 472));
      BG_EvaluateTrajectory(a1 + 12, dword_859B5EC, a1 + 312);
      SV_LinkEntity(a1);
      if ( v2 )
        Scr_Notify((int *)a1, word_87A22C8, 0);
    }
  }
  result = a1;
  if ( *(_DWORD *)(a1 + 48) )
  {
    result = *(_DWORD *)(a1 + 52) + *(_DWORD *)(a1 + 56);
    if ( result <= dword_859B5EC )
    {
      v3 = sub_81163C0(
             a1 + 48,
             a1 + 324,
             *(float *)(a1 + 436),
             *(float *)(a1 + 444),
             *(float *)(a1 + 428),
             (float *)(a1 + 484),
             (float *)(a1 + 496),
             (float *)(a1 + 508));
      BG_EvaluateTrajectory(a1 + 48, dword_859B5EC, a1 + 324);
      result = SV_LinkEntity(a1);
      if ( v3 )
      {
        *(float *)(a1 + 324) = sub_80A6112(*(float *)(a1 + 324));
        *(float *)(a1 + 328) = sub_80A60CE(*(float *)(a1 + 328));
        *(float *)(a1 + 332) = sub_80A6112(*(float *)(a1 + 332));
        return Scr_Notify((int *)a1, word_87A22E0, 0);
      }
    }
  }
  return result;
}
// 87A22C8: using guessed type __int16 word_87A22C8;
// 87A22E0: using guessed type __int16 word_87A22E0;

//----- (081167BA) --------------------------------------------------------
float *__cdecl sub_81167BA(
        int a1,
        float *a2,
        float a3,
        float a4,
        float a5,
        float *a6,
        float *a7,
        float *a8,
        float *a9,
        float *a10,
        float *a11,
        _DWORD *a12)
{
  long double v13; // fst7
  int v14[4]; // [esp+20h] [ebp-38h] BYREF
  int v15[6]; // [esp+30h] [ebp-28h] BYREF
  float v16; // [esp+48h] [ebp-10h]
  float v17; // [esp+4Ch] [ebp-Ch]

  sub_8117E1E(a2, a6, (float *)v15);
  if ( *(_DWORD *)a1 )
    BG_EvaluateTrajectory(a1, dword_859B5EC, (int)a6);
  if ( a4 == 0.0 && a5 == 0.0 )
  {
    *(_DWORD *)(a1 + 4) = dword_859B5EC;
    *(_DWORD *)(a1 + 8) = (int)(a3 * 1000.0);
    *a8 = a3;
    *a9 = 0.0;
    sub_8117DEE(a2, a12);
    sub_8117DEE(a6, (_DWORD *)(a1 + 12));
    v16 = 1000.0 / (long double)*(int *)(a1 + 8);
    sub_8117E62((float *)v15, v16, (float *)(a1 + 24));
    *(_DWORD *)a1 = 3;
    return BG_EvaluateTrajectory(a1, dword_859B5EC, (int)a6);
  }
  else
  {
    v13 = a3 - a4 - a5;
    *a8 = v13;
    *a9 = a5;
    sub_8117EEE((float *)v15);
    v17 = v13;
    *a7 = (v17 + v17) / (a3 + a3 - a4 - a5);
    sub_80A2298((float *)v15, (int)v14);
    sub_8117E62((float *)v14, *a7, (float *)v14);
    if ( a4 == 0.0 )
    {
      sub_8117DEE(a6, a10);
      if ( *a8 == 0.0 )
      {
        *(_DWORD *)(a1 + 4) = dword_859B5EC;
        *(_DWORD *)(a1 + 8) = (int)(*a9 * 1000.0);
        sub_8117DEE(a6, (_DWORD *)(a1 + 12));
        sub_8117DEE(v14, (_DWORD *)(a1 + 24));
        *(_DWORD *)a1 = 8;
      }
      else
      {
        *(_DWORD *)(a1 + 4) = dword_859B5EC;
        *(_DWORD *)(a1 + 8) = (int)(*a8 * 1000.0);
        sub_8117DEE(a6, (_DWORD *)(a1 + 12));
        sub_8117E62((float *)v14, *a8, (float *)v15);
        v16 = 1000.0 / (long double)*(int *)(a1 + 8);
        sub_8117E62((float *)v15, v16, (float *)(a1 + 24));
        *(_DWORD *)a1 = 3;
      }
    }
    else
    {
      *(_DWORD *)(a1 + 4) = dword_859B5EC;
      *(_DWORD *)(a1 + 8) = (int)(a4 * 1000.0);
      sub_8117DEE(a6, (_DWORD *)(a1 + 12));
      sub_8117DEE(v14, (_DWORD *)(a1 + 24));
      *(_DWORD *)a1 = 7;
      BG_EvaluateTrajectory(a1, dword_859B5EC + *(_DWORD *)(a1 + 8), (int)a10);
    }
    sub_8117E9A(a10, *a8, (float *)v14, a11);
    sub_8117DEE(a2, a12);
    return BG_EvaluateTrajectory(a1, dword_859B5EC, (int)a6);
  }
}

//----- (08116B6E) --------------------------------------------------------
float *__cdecl sub_8116B6E(
        _DWORD *a1,
        float *a2,
        float a3,
        float a4,
        float a5,
        _DWORD *a6,
        float *a7,
        float *a8,
        float *a9,
        float *a10,
        float *a11,
        _DWORD *a12)
{
  long double v13; // fst7
  int v14[2]; // [esp+20h] [ebp-38h] BYREF
  int v15; // [esp+28h] [ebp-30h]
  int v16[3]; // [esp+2Ch] [ebp-2Ch] BYREF
  int v17[8]; // [esp+38h] [ebp-20h] BYREF

  if ( *a1 )
    BG_EvaluateTrajectory((int)a1, dword_859B5EC, (int)a6);
  if ( a4 == 0.0 && a5 == 0.0 )
  {
    a1[1] = dword_859B5EC;
    a1[2] = (int)(a3 * 1000.0);
    *a8 = a3;
    *a9 = 0.0;
    sub_8117DEE(a6, a1 + 3);
    sub_8117DEE(a2, a1 + 6);
    *a1 = 3;
    BG_EvaluateTrajectory((int)a1, dword_859B5EC, (int)a6);
    return BG_EvaluateTrajectory((int)a1, dword_859B5EC + a1[2], (int)a12);
  }
  else
  {
    v13 = a3 - a4 - a5;
    *a8 = v13;
    *a9 = a5;
    sub_8117EEE(a2);
    *a7 = v13;
    if ( a4 == 0.0 )
    {
      sub_8117DEE(a6, a10);
      if ( *a8 == 0.0 )
      {
        a1[1] = dword_859B5EC;
        a1[2] = (int)(*a9 * 1000.0);
        sub_8117DEE(a6, a1 + 3);
        sub_8117DEE(a2, a1 + 6);
        *a1 = 8;
      }
      else
      {
        a1[1] = dword_859B5EC;
        a1[2] = (int)(*a8 * 1000.0);
        sub_8117DEE(a6, a1 + 3);
        sub_8117DEE(a2, a1 + 6);
        *a1 = 3;
      }
    }
    else
    {
      a1[1] = dword_859B5EC;
      a1[2] = (int)(a4 * 1000.0);
      sub_8117DEE(a6, a1 + 3);
      sub_8117DEE(a2, a1 + 6);
      *a1 = 7;
      BG_EvaluateTrajectory((int)a1, dword_859B5EC + a1[2], (int)a10);
    }
    sub_8117E9A(a10, *a8, a2, a11);
    if ( *a9 == 0.0 )
    {
      sub_8117DEE(a11, a12);
    }
    else
    {
      v14[0] = 8;
      v14[1] = dword_859B5EC;
      v15 = (int)(*a9 * 1000.0);
      sub_8117DEE(a11, v16);
      sub_8117DEE(a2, v17);
      BG_EvaluateTrajectory((int)v14, dword_859B5EC + v15, (int)a12);
    }
    return BG_EvaluateTrajectory((int)a1, dword_859B5EC, (int)a6);
  }
}
// 8116B6E: using guessed type int anonymous_0[3];
// 8116B6E: using guessed type int anonymous_1[8];

//----- (08116F18) --------------------------------------------------------
int __cdecl sub_8116F18(int a1, float *a2, float a3, float a4, float a5)
{
  sub_81167BA(
    a1 + 12,
    a2,
    a3,
    a4,
    a5,
    (float *)(a1 + 312),
    (float *)(a1 + 432),
    (float *)(a1 + 440),
    (float *)(a1 + 424),
    (float *)(a1 + 448),
    (float *)(a1 + 460),
    (_DWORD *)(a1 + 472));
  return SV_LinkEntity(a1);
}

//----- (08116FAA) --------------------------------------------------------
int __cdecl sub_8116FAA(_DWORD *a1, _DWORD *a2, float a3)
{
  a1[4] = dword_859B5EC;
  a1[5] = (int)(a3 * 1000.0);
  sub_8117DEE(a1 + 78, a1 + 6);
  sub_8117DEE(a2, a1 + 9);
  a1[3] = 5;
  BG_EvaluateTrajectory((int)(a1 + 3), dword_859B5EC, (int)(a1 + 78));
  return SV_LinkEntity((int)a1);
}

//----- (08117050) --------------------------------------------------------
int __cdecl sub_8117050(int a1, float *a2, float a3, float a4, float a5)
{
  sub_81167BA(
    a1 + 48,
    a2,
    a3,
    a4,
    a5,
    (float *)(a1 + 324),
    (float *)(a1 + 436),
    (float *)(a1 + 444),
    (float *)(a1 + 428),
    (float *)(a1 + 484),
    (float *)(a1 + 496),
    (_DWORD *)(a1 + 508));
  return SV_LinkEntity(a1);
}

//----- (081170E2) --------------------------------------------------------
int __cdecl sub_81170E2(int a1, float *a2, float a3, float a4, float a5)
{
  sub_8116B6E(
    (_DWORD *)(a1 + 48),
    a2,
    a3,
    a4,
    a5,
    (_DWORD *)(a1 + 324),
    (float *)(a1 + 436),
    (float *)(a1 + 444),
    (float *)(a1 + 428),
    (float *)(a1 + 484),
    (float *)(a1 + 496),
    (_DWORD *)(a1 + 508));
  return SV_LinkEntity(a1);
}

//----- (08117174) --------------------------------------------------------
int __cdecl sub_8117174(int a1)
{
  int result; // eax
  int v2; // [esp+18h] [ebp-40h]
  int v3; // [esp+1Ch] [ebp-3Ch]
  int v4; // [esp+20h] [ebp-38h]
  int v5; // [esp+24h] [ebp-34h]
  int v6; // [esp+28h] [ebp-30h]
  int v7; // [esp+2Ch] [ebp-2Ch]
  int v8[7]; // [esp+30h] [ebp-28h] BYREF
  float v9[3]; // [esp+4Ch] [ebp-Ch] BYREF

  if ( byte_859C748 )
  {
    v7 = sub_8117F76("light", (int)&unk_8157110, v9);
    v6 = sub_8117FEC("color", (int)"1 1 1", v8);
    if ( v7 || v6 )
    {
      v5 = (int)(*(float *)v8 * 255.0);
      if ( v5 > 255 )
        v5 = 255;
      v4 = (int)(*(float *)&v8[1] * 255.0);
      if ( v4 > 255 )
        v4 = 255;
      v3 = (int)(*(float *)&v8[2] * 255.0);
      if ( v3 > 255 )
        v3 = 255;
      v2 = (int)(v9[0] / 4.0);
      if ( v2 > 255 )
        v2 = 255;
      *(_DWORD *)(a1 + 128) = (v3 << 16) | v5 | (v4 << 8) | (v2 << 24);
    }
  }
  *(_BYTE *)(a1 + 358) = 5;
  *(_BYTE *)(a1 + 242) = 0;
  *(_DWORD *)(a1 + 4) = 6;
  sub_8117DEE((_DWORD *)(a1 + 312), (_DWORD *)(a1 + 24));
  *(_DWORD *)(a1 + 12) = 0;
  sub_8117DEE((_DWORD *)(a1 + 324), (_DWORD *)(a1 + 60));
  *(_DWORD *)(a1 + 48) = 0;
  result = *(_DWORD *)(a1 + 372) | 0x1000;
  *(_DWORD *)(a1 + 372) = result;
  return result;
}
// 859C748: using guessed type char byte_859C748;
// 8117174: using guessed type float var_C[3];

//----- (08117316) --------------------------------------------------------
int __cdecl sub_8117316(int a1)
{
  SV_SetBrushModel(a1);
  sub_8117174(a1);
  *(_DWORD *)(a1 + 284) = 1;
  return SV_LinkEntity(a1);
}

//----- (0811734C) --------------------------------------------------------
int __usercall sub_811734C@<eax>(long double a1@<st0>, int a2)
{
  sub_811B20E(a1, a2);
  sub_8117174(a2);
  *(_BYTE *)(a2 + 242) |= 4u;
  *(_DWORD *)(a2 + 284) = 8320;
  return SV_LinkEntity(a2);
}

//----- (08117398) --------------------------------------------------------
int __cdecl sub_8117398(int a1)
{
  int result; // eax

  sub_8117174(a1);
  *(_DWORD *)(a1 + 284) = 0;
  SV_LinkEntity(a1);
  result = a1;
  if ( *(_DWORD *)(a1 + 128) )
    *(_DWORD *)(a1 + 8) |= 0x20u;
  else
    *(_BYTE *)(a1 + 242) |= 1u;
  return result;
}

//----- (081173F6) --------------------------------------------------------
void __cdecl sub_81173F6(float *a1, float *a2, float *a3)
{
  int v3; // [esp+14h] [ebp-4h]

  *a1 = Scr_GetFloat(1u);
  if ( *a1 <= 0.0 )
    Scr_ParamError(1, (int)"total time must be positive");
  v3 = Scr_GetNumParam();
  if ( v3 <= 2 )
  {
    *a2 = 0.0;
    *a3 = 0.0;
  }
  else
  {
    *a2 = Scr_GetFloat(2u);
    if ( *a2 < 0.0 )
      Scr_ParamError(2, (int)"accel time must be nonnegative");
    if ( v3 <= 3 )
    {
      *a3 = 0.0;
    }
    else
    {
      *a3 = Scr_GetFloat(3u);
      if ( *a3 < 0.0 )
        Scr_ParamError(3, (int)"decel time must be nonnegative");
    }
  }
  if ( *a2 + *a3 > (long double)*a1 )
    Scr_Error((int)"accel time plus decel time is greater than total time");
}

//----- (081174FA) --------------------------------------------------------
int __cdecl sub_81174FA(int a1)
{
  char *v1; // eax
  char *v3; // [esp+2Ch] [ebp-2Ch]
  int v4[5]; // [esp+30h] [ebp-28h] BYREF
  float v5; // [esp+44h] [ebp-14h] BYREF
  float v6; // [esp+48h] [ebp-10h] BYREF
  float v7[3]; // [esp+4Ch] [ebp-Ch] BYREF

  if ( HIWORD(a1) )
  {
    Scr_ObjectError((int)"not an entity");
    v3 = 0;
  }
  else
  {
    v3 = (char *)&unk_8665480 + 560 * (unsigned __int16)a1;
    if ( *((_WORD *)v3 + 180) != word_87A22E2
      && *((_WORD *)v3 + 180) != word_87A22E4
      && *((_WORD *)v3 + 180) != word_87A22E6 )
    {
      v1 = va("entity %i is not a script_brushmodel, script_model, or script_origin", (unsigned __int16)a1);
      Scr_ObjectError((int)v1);
    }
  }
  Scr_GetVector(0, v4);
  sub_81173F6(v7, &v6, &v5);
  return sub_8116F18((int)v3, (float *)v4, v7[0], v6, v5);
}
// 87A22E2: using guessed type __int16 word_87A22E2;
// 87A22E4: using guessed type __int16 word_87A22E4;
// 87A22E6: using guessed type __int16 word_87A22E6;
// 81174FA: using guessed type float var_C[3];

//----- (081175DC) --------------------------------------------------------
int __cdecl sub_81175DC(int a1)
{
  char *v1; // eax
  char *v3; // [esp+1Ch] [ebp-2Ch]
  int v4[7]; // [esp+20h] [ebp-28h] BYREF
  float v5; // [esp+3Ch] [ebp-Ch]

  if ( HIWORD(a1) )
  {
    Scr_ObjectError((int)"not an entity");
    v3 = 0;
  }
  else
  {
    v3 = (char *)&unk_8665480 + 560 * (unsigned __int16)a1;
    if ( *((_WORD *)v3 + 180) != word_87A22E2
      && *((_WORD *)v3 + 180) != word_87A22E4
      && *((_WORD *)v3 + 180) != word_87A22E6 )
    {
      v1 = va("entity %i is not a script_brushmodel, script_model, or script_origin", (unsigned __int16)a1);
      Scr_ObjectError((int)v1);
    }
  }
  Scr_GetVector(0, v4);
  v5 = Scr_GetFloat(1u);
  return sub_8116FAA(v3, v4, v5);
}
// 87A22E2: using guessed type __int16 word_87A22E2;
// 87A22E4: using guessed type __int16 word_87A22E4;
// 87A22E6: using guessed type __int16 word_87A22E6;

//----- (081176A6) --------------------------------------------------------
int __cdecl sub_81176A6(int a1, int a2)
{
  char *v2; // eax
  char *v4; // [esp+2Ch] [ebp-2Ch]
  float v5[4]; // [esp+30h] [ebp-28h] BYREF
  float v6; // [esp+40h] [ebp-18h] BYREF
  float v7; // [esp+44h] [ebp-14h] BYREF
  float v8; // [esp+48h] [ebp-10h] BYREF
  float v9; // [esp+4Ch] [ebp-Ch]

  if ( HIWORD(a1) )
  {
    Scr_ObjectError((int)"not an entity");
    v4 = 0;
  }
  else
  {
    v4 = (char *)&unk_8665480 + 560 * (unsigned __int16)a1;
    if ( *((_WORD *)v4 + 180) != word_87A22E2
      && *((_WORD *)v4 + 180) != word_87A22E4
      && *((_WORD *)v4 + 180) != word_87A22E6 )
    {
      v2 = va("entity %i is not a script_brushmodel, script_model, or script_origin", (unsigned __int16)a1);
      Scr_ObjectError((int)v2);
    }
  }
  v9 = Scr_GetFloat(0);
  sub_81173F6(&v8, &v7, &v6);
  sub_8117DEE((_DWORD *)v4 + 78, v5);
  v5[a2] = v5[a2] + v9;
  return sub_8116F18((int)v4, v5, v8, v7, v6);
}
// 87A22E2: using guessed type __int16 word_87A22E2;
// 87A22E4: using guessed type __int16 word_87A22E4;
// 87A22E6: using guessed type __int16 word_87A22E6;
// 81176A6: using guessed type float var_28[4];

//----- (081177AC) --------------------------------------------------------
int __cdecl sub_81177AC(int a1)
{
  return sub_81176A6(a1, 0);
}

//----- (081177C8) --------------------------------------------------------
int __cdecl sub_81177C8(int a1)
{
  return sub_81176A6(a1, 1);
}

//----- (081177E4) --------------------------------------------------------
int __cdecl sub_81177E4(int a1)
{
  return sub_81176A6(a1, 2);
}

//----- (08117800) --------------------------------------------------------
int __cdecl sub_8117800(int a1)
{
  char *v1; // eax
  int v2; // esi
  int v3; // ebx
  char *v5; // [esp+2Ch] [ebp-4Ch]
  float v6[4]; // [esp+30h] [ebp-48h] BYREF
  float v7[4]; // [esp+40h] [ebp-38h] BYREF
  float v8; // [esp+50h] [ebp-28h] BYREF
  float v9; // [esp+54h] [ebp-24h] BYREF
  float v10; // [esp+58h] [ebp-20h] BYREF
  int i; // [esp+5Ch] [ebp-1Ch]

  if ( HIWORD(a1) )
  {
    Scr_ObjectError((int)"not an entity");
    v5 = 0;
  }
  else
  {
    v5 = (char *)&unk_8665480 + 560 * (unsigned __int16)a1;
    if ( *((_WORD *)v5 + 180) != word_87A22E2
      && *((_WORD *)v5 + 180) != word_87A22E4
      && *((_WORD *)v5 + 180) != word_87A22E6 )
    {
      v1 = va("entity %i is not a script_brushmodel, script_model, or script_origin", (unsigned __int16)a1);
      Scr_ObjectError((int)v1);
    }
  }
  Scr_GetVector(0, v7);
  sub_81173F6(&v10, &v9, &v8);
  for ( i = 0; i <= 2; ++i )
  {
    v2 = i;
    v3 = i;
    v6[v2] = sub_80A6000(v7[i], *(float *)&v5[4 * i + 324]) + *(float *)&v5[4 * v3 + 324];
  }
  return sub_8117050((int)v5, v6, v10, v9, v8);
}
// 87A22E2: using guessed type __int16 word_87A22E2;
// 87A22E4: using guessed type __int16 word_87A22E4;
// 87A22E6: using guessed type __int16 word_87A22E6;
// 8117800: using guessed type float var_38[4];
// 8117800: using guessed type float var_48[4];

//----- (08117938) --------------------------------------------------------
int __cdecl sub_8117938(int a1, int a2)
{
  char *v2; // eax
  char *v4; // [esp+2Ch] [ebp-2Ch]
  float v5[4]; // [esp+30h] [ebp-28h] BYREF
  float v6; // [esp+40h] [ebp-18h] BYREF
  float v7; // [esp+44h] [ebp-14h] BYREF
  float v8; // [esp+48h] [ebp-10h] BYREF
  float v9; // [esp+4Ch] [ebp-Ch]

  if ( HIWORD(a1) )
  {
    Scr_ObjectError((int)"not an entity");
    v4 = 0;
  }
  else
  {
    v4 = (char *)&unk_8665480 + 560 * (unsigned __int16)a1;
    if ( *((_WORD *)v4 + 180) != word_87A22E2
      && *((_WORD *)v4 + 180) != word_87A22E4
      && *((_WORD *)v4 + 180) != word_87A22E6 )
    {
      v2 = va("entity %i is not a script_brushmodel, script_model, or script_origin", (unsigned __int16)a1);
      Scr_ObjectError((int)v2);
    }
  }
  v9 = Scr_GetFloat(0);
  sub_81173F6(&v8, &v7, &v6);
  sub_8117DEE((_DWORD *)v4 + 81, v5);
  v5[a2] = v5[a2] + v9;
  return sub_8117050((int)v4, v5, v8, v7, v6);
}
// 87A22E2: using guessed type __int16 word_87A22E2;
// 87A22E4: using guessed type __int16 word_87A22E4;
// 87A22E6: using guessed type __int16 word_87A22E6;
// 8117938: using guessed type float var_28[4];

//----- (08117A3E) --------------------------------------------------------
int __cdecl sub_8117A3E(int a1)
{
  return sub_8117938(a1, 0);
}

//----- (08117A5A) --------------------------------------------------------
int __cdecl sub_8117A5A(int a1)
{
  return sub_8117938(a1, 1);
}

//----- (08117A76) --------------------------------------------------------
int __cdecl sub_8117A76(int a1)
{
  return sub_8117938(a1, 2);
}

//----- (08117A92) --------------------------------------------------------
int __cdecl sub_8117A92(int a1)
{
  char *v1; // eax
  char *v3; // [esp+2Ch] [ebp-2Ch]
  int v4[5]; // [esp+30h] [ebp-28h] BYREF
  float v5; // [esp+44h] [ebp-14h] BYREF
  float v6; // [esp+48h] [ebp-10h] BYREF
  float v7[3]; // [esp+4Ch] [ebp-Ch] BYREF

  if ( HIWORD(a1) )
  {
    Scr_ObjectError((int)"not an entity");
    v3 = 0;
  }
  else
  {
    v3 = (char *)&unk_8665480 + 560 * (unsigned __int16)a1;
    if ( *((_WORD *)v3 + 180) != word_87A22E2
      && *((_WORD *)v3 + 180) != word_87A22E4
      && *((_WORD *)v3 + 180) != word_87A22E6 )
    {
      v1 = va("entity %i is not a script_brushmodel, script_model, or script_origin", (unsigned __int16)a1);
      Scr_ObjectError((int)v1);
    }
  }
  Scr_GetVector(0, v4);
  sub_81173F6(v7, &v6, &v5);
  return sub_81170E2((int)v3, (float *)v4, v7[0], v6, v5);
}
// 87A22E2: using guessed type __int16 word_87A22E2;
// 87A22E4: using guessed type __int16 word_87A22E4;
// 87A22E6: using guessed type __int16 word_87A22E6;
// 8117A92: using guessed type float var_C[3];

//----- (08117B74) --------------------------------------------------------
void __cdecl ScriptEntCmd_Solid(int a1)
{
  char *v1; // eax
  char *v2; // [esp+14h] [ebp-4h]

  if ( HIWORD(a1) )
  {
    Scr_ObjectError((int)"not an entity");
    v2 = 0;
  }
  else
  {
    v2 = (char *)&unk_8665480 + 560 * (unsigned __int16)a1;
    if ( *((_WORD *)v2 + 180) != word_87A22E2
      && *((_WORD *)v2 + 180) != word_87A22E4
      && *((_WORD *)v2 + 180) != word_87A22E6 )
    {
      v1 = va("entity %i is not a script_brushmodel, script_model, or script_origin", (unsigned __int16)a1);
      Scr_ObjectError((int)v1);
    }
  }
  if ( *((_WORD *)v2 + 180) == word_87A22E6 )
  {
    Com_DPrintf("cannot use the solid/notsolid commands on a script_origin entity( number %i )\n", *(_DWORD *)v2);
  }
  else
  {
    if ( *((_WORD *)v2 + 180) == word_87A22E4 )
    {
      *((_DWORD *)v2 + 71) = 8320;
    }
    else
    {
      *((_DWORD *)v2 + 71) = 1;
      *((_DWORD *)v2 + 2) &= ~1u;
    }
    SV_LinkEntity((int)v2);
  }
}
// 87A22E2: using guessed type __int16 word_87A22E2;
// 87A22E4: using guessed type __int16 word_87A22E4;
// 87A22E6: using guessed type __int16 word_87A22E6;

//----- (08117C76) --------------------------------------------------------
void __cdecl ScriptEntCmd_NotSolid(int a1)
{
  char *v1; // eax
  char *v2; // [esp+14h] [ebp-4h]

  if ( HIWORD(a1) )
  {
    Scr_ObjectError((int)"not an entity");
    v2 = 0;
  }
  else
  {
    v2 = (char *)&unk_8665480 + 560 * (unsigned __int16)a1;
    if ( *((_WORD *)v2 + 180) != word_87A22E2
      && *((_WORD *)v2 + 180) != word_87A22E4
      && *((_WORD *)v2 + 180) != word_87A22E6 )
    {
      v1 = va("entity %i is not a script_brushmodel, script_model, or script_origin", (unsigned __int16)a1);
      Scr_ObjectError((int)v1);
    }
  }
  if ( *((_WORD *)v2 + 180) == word_87A22E6 )
  {
    Com_DPrintf("cannot use the solid/notsolid commands on a script_origin entity( number %i )\n", *(_DWORD *)v2);
  }
  else
  {
    *((_DWORD *)v2 + 71) = 0;
    if ( *((_WORD *)v2 + 180) != word_87A22E4 )
      *((_DWORD *)v2 + 2) |= 1u;
    SV_LinkEntity((int)v2);
  }
}
// 87A22E2: using guessed type __int16 word_87A22E2;
// 87A22E4: using guessed type __int16 word_87A22E4;
// 87A22E6: using guessed type __int16 word_87A22E6;

//----- (08117D6A) --------------------------------------------------------
int (__cdecl *__cdecl ScriptEnt_GetMethod(char **a1))(int)
{
  char *s1; // [esp+10h] [ebp-8h]
  unsigned int i; // [esp+14h] [ebp-4h]

  s1 = *a1;
  for ( i = 0; i <= 0xB; ++i )
  {
    if ( !strcmp(s1, (&off_8157300)[3 * i]) )
    {
      *a1 = (&off_8157300)[3 * i];
      return off_8157304[3 * i];
    }
  }
  return 0;
}
// 8157300: using guessed type char *off_8157300;
// 8157304: using guessed type int (__cdecl *off_8157304[39])(int);

//----- (08117DEE) --------------------------------------------------------
int __cdecl sub_8117DEE(_DWORD *a1, _DWORD *a2)
{
  int result; // eax

  *a2 = *a1;
  a2[1] = a1[1];
  result = a1[2];
  a2[2] = result;
  return result;
}

//----- (08117E1E) --------------------------------------------------------
float *__cdecl sub_8117E1E(float *a1, float *a2, float *a3)
{
  float *result; // eax

  *a3 = *a1 - *a2;
  a3[1] = a1[1] - a2[1];
  result = a1 + 2;
  a3[2] = a1[2] - a2[2];
  return result;
}

//----- (08117E62) --------------------------------------------------------
float *__cdecl sub_8117E62(float *a1, float a2, float *a3)
{
  float *result; // eax

  *a3 = a2 * *a1;
  a3[1] = a2 * a1[1];
  result = a1 + 2;
  a3[2] = a2 * a1[2];
  return result;
}

//----- (08117E9A) --------------------------------------------------------
float *__cdecl sub_8117E9A(float *a1, float a2, float *a3, float *a4)
{
  float *result; // eax

  *a4 = a2 * *a3 + *a1;
  a4[1] = a2 * a3[1] + a1[1];
  result = a3 + 2;
  a4[2] = a2 * a3[2] + a1[2];
  return result;
}

//----- (08117EEE) --------------------------------------------------------
void __cdecl sub_8117EEE(float *a1)
{
  float v1; // [esp+0h] [ebp-8h]

  v1 = *a1 * *a1 + a1[1] * a1[1] + a1[2] * a1[2];
  sub_8117F2C(v1);
}

//----- (08117F2C) --------------------------------------------------------
long double __cdecl sub_8117F2C(float a1)
{
  return (float)sqrt(a1);
}

//----- (08117F4C) --------------------------------------------------------
int __cdecl sub_8117F4C(char *s1, int a2, _DWORD *a3)
{
  return G_SpawnStringInternal((int)&byte_859C748, s1, a2, a3);
}
// 859C748: using guessed type char byte_859C748;

//----- (08117F76) --------------------------------------------------------
int __cdecl sub_8117F76(char *s1, int a2, float *a3)
{
  int v4; // [esp+1Ch] [ebp-Ch]
  char *nptr; // [esp+20h] [ebp-8h] BYREF

  v4 = sub_8117F4C(s1, a2, &nptr);
  *a3 = atof(nptr);
  return v4;
}

//----- (08117FB2) --------------------------------------------------------
int __cdecl sub_8117FB2(char *s1, int a2, int *a3)
{
  int v4; // [esp+10h] [ebp-8h]
  char *nptr; // [esp+14h] [ebp-4h] BYREF

  v4 = sub_8117F4C(s1, a2, &nptr);
  *a3 = atoi(nptr);
  return v4;
}

//----- (08117FEC) --------------------------------------------------------
int __cdecl sub_8117FEC(char *s1, int a2, _DWORD *a3)
{
  int v4; // [esp+20h] [ebp-8h]
  char *s; // [esp+24h] [ebp-4h] BYREF

  v4 = sub_8117F4C(s1, a2, &s);
  sub_81193A8(a3);
  sscanf(s, "%f %f %f", a3, a3 + 1, a3 + 2);
  return v4;
}

//----- (0811804C) --------------------------------------------------------
void sub_811804C()
{
  Scr_Error((int)"Tried to set a read only entity field");
}

//----- (08118060) --------------------------------------------------------
int __cdecl sub_8118060(char *s1, char *nptr)
{
  int v2; // eax
  int v5; // [esp+2Ch] [ebp-2Ch]
  int v6; // [esp+30h] [ebp-28h] BYREF
  char v7; // [esp+34h] [ebp-24h] BYREF
  char v8; // [esp+38h] [ebp-20h] BYREF
  int v9; // [esp+48h] [ebp-10h]
  int v10[3]; // [esp+4Ch] [ebp-Ch] BYREF

  v9 = sub_807F168(s1, v10);
  if ( !v9 )
    return 0;
  if ( v10[0] == 4 )
  {
    sub_81193A8(&v6);
    sscanf(nptr, "%f %f %f", &v6, &v7, &v8);
    Scr_AddVector(&v6);
  }
  else if ( v10[0] > 4 )
  {
    if ( v10[0] == 5 )
    {
      *(float *)&v5 = atof(nptr);
      Scr_AddFloat(v5);
    }
    else if ( v10[0] == 6 )
    {
      v2 = atoi(nptr);
      Scr_AddInt(v2);
    }
  }
  else if ( v10[0] == 2 )
  {
    Scr_AddString(nptr);
  }
  return v9;
}
// 8118060: using guessed type int var_C[3];

//----- (08118148) --------------------------------------------------------
int __cdecl sub_8118148(char *s1, char *nptr, int *a3)
{
  int result; // eax

  result = sub_8118060(s1, nptr);
  if ( result )
    return sub_81190B6(a3, result);
  return result;
}

//----- (08118180) --------------------------------------------------------
void __cdecl sub_8118180(char *s1, char *s, int *a3)
{
  _WORD *v3; // ebx
  float *v4; // ebx
  int v5; // [esp+30h] [ebp-28h] BYREF
  int v6; // [esp+34h] [ebp-24h] BYREF
  int v7; // [esp+38h] [ebp-20h] BYREF
  int *v8; // [esp+48h] [ebp-10h]
  char **i; // [esp+4Ch] [ebp-Ch]

  for ( i = &off_8157780; ; i += 4 )
  {
    if ( !*i )
    {
      sub_8118148(s1, s, a3);
      return;
    }
    if ( !I_stricmp(*i, s1) )
      break;
  }
  v8 = a3;
  switch ( (unsigned int)i[2] )
  {
    case 0u:
      *(_DWORD *)&i[1][(_DWORD)v8] = atoi(s);
      break;
    case 1u:
      v4 = (float *)((char *)v8 + (_DWORD)i[1]);
      *v4 = atof(s);
      break;
    case 3u:
      Scr_SetString(&i[1][(_DWORD)v8], 0);
      v3 = (_WORD *)((char *)v8 + (_DWORD)i[1]);
      *v3 = G_NewString(s);
      break;
    case 4u:
      sub_81193A8(&v5);
      sscanf(s, "%f %f %f", &v5, &v6, &v7);
      *(int *)((char *)v8 + (_DWORD)i[1]) = v5;
      *(_DWORD *)&i[1][(_DWORD)v8 + 4] = v6;
      *(_DWORD *)&i[1][(_DWORD)v8 + 8] = v7;
      break;
    case 8u:
      if ( *s == 42 )
        a3[35] = (unsigned __int16)atoi(s + 1);
      else
        sub_811B3EA((int)a3, s);
      break;
    default:
      return;
  }
}
// 8157780: using guessed type char *off_8157780;

//----- (08118320) --------------------------------------------------------
int __cdecl sub_8118320(int *a1)
{
  int i; // [esp+14h] [ebp-4h]

  for ( i = 0; i < dword_859C74C; ++i )
    sub_8118180((&dword_859C750)[2 * i], (&nptr)[2 * i], a1);
  sub_811CF36(a1, a1 + 78);
  return sub_811CF96(a1, a1 + 81);
}
// 859C74C: using guessed type int dword_859C74C;

//----- (08118398) --------------------------------------------------------
int sub_8118398()
{
  int result; // eax
  int v1; // [esp+Ch] [ebp-Ch]
  int v2; // [esp+10h] [ebp-8h]
  int i; // [esp+14h] [ebp-4h]

  sub_8083AAC(dword_879D834, 0);
  v1 = sub_808491A(0);
  for ( i = 0; ; ++i )
  {
    result = i;
    if ( i >= dword_859C74C )
      break;
    v2 = sub_8118060((&dword_859C750)[2 * i], (&nptr)[2 * i]);
    if ( v2 )
      sub_8084F28(v1, v2);
  }
  return result;
}
// 859C74C: using guessed type int dword_859C74C;
// 879D834: using guessed type int dword_879D834;

//----- (0811841C) --------------------------------------------------------
char **__cdecl sub_811841C(int a1, int a2)
{
  char **result; // eax
  char **i; // [esp+14h] [ebp-4h]

  for ( i = &off_8157780; ; i += 4 )
  {
    result = i;
    if ( !*i )
      break;
    switch ( (unsigned int)i[2] )
    {
      case 0u:
        *(_DWORD *)&i[1][a1] = *(_DWORD *)&i[1][a2];
        break;
      case 1u:
        *(_DWORD *)&i[1][a1] = *(_DWORD *)&i[1][a2];
        break;
      case 3u:
        Scr_SetString(&i[1][a1], *(unsigned __int16 *)&i[1][a2]);
        break;
      case 4u:
        sub_81193D2(&i[1][a2], &i[1][a1]);
        break;
      case 8u:
        i[1][a1] = i[1][a2];
        break;
      default:
        continue;
    }
  }
  return result;
}
// 8157780: using guessed type char *off_8157780;

//----- (08118504) --------------------------------------------------------
int __cdecl sub_8118504(int *a1, int *a2)
{
  return sub_807EECE(*a2, *a1, 0);
}

//----- (0811852A) --------------------------------------------------------
int __cdecl sub_811852A(char *s1)
{
  int i; // [esp+18h] [ebp-10h]
  int v4; // [esp+20h] [ebp-8h]

  if ( !strncmp(s1, "weapon_", 7u) && (v4 = G_GetWeaponIndexForName(s1 + 7)) != 0 )
  {
    BG_WeaponDefs(v4);
    return BG_FindItemForWeapon(v4);
  }
  else
  {
    for ( i = 129; i < 131; ++i )
    {
      if ( !strcmp(*((const char **)&unk_8164C20 + 11 * i), s1) )
        return (int)&unk_8164C20 + 44 * i;
    }
    return 0;
  }
}

//----- (081185EA) --------------------------------------------------------
void __usercall G_CallSpawn(long double a1@<st0>)
{
  char *s2; // [esp+18h] [ebp-10h] BYREF
  int *v2; // [esp+1Ch] [ebp-Ch]
  int v3; // [esp+20h] [ebp-8h]
  char **i; // [esp+24h] [ebp-4h]

  sub_8117F4C("classname", (int)&byte_8157544, &s2);
  if ( s2 )
  {
    v3 = sub_811852A(s2);
    if ( v3 )
    {
      v2 = (int *)G_Spawn();
      sub_8118320(v2);
      sub_8104EB2(a1, (int)v2, v3);
    }
    else
    {
      for ( i = &off_8168560; ; i += 2 )
      {
        if ( !*i )
        {
          v2 = (int *)G_Spawn();
          sub_8118320(v2);
          return;
        }
        if ( !strcmp(*i, s2) )
          break;
      }
      if ( i[1] != (char *)G_FreeEntity )
      {
        v2 = (int *)G_Spawn();
        sub_8118320(v2);
        ((void (__cdecl *)(int *))i[1])(v2);
      }
    }
  }
  else
  {
    Com_Printf("G_CallSpawn: NULL classname\n");
  }
}
// 8168560: using guessed type char *off_8168560;

//----- (081186D2) --------------------------------------------------------
int __usercall G_CallSpawnEntity@<eax>(long double a1@<st0>, int a2)
{
  const char *v2; // eax
  char *s2; // [esp+Ch] [ebp-Ch]
  int v6; // [esp+10h] [ebp-8h]
  char **i; // [esp+14h] [ebp-4h]

  if ( *(_WORD *)(a2 + 360) )
  {
    s2 = (char *)SL_ConvertToString(*(unsigned __int16 *)(a2 + 360));
    v6 = sub_811852A(s2);
    if ( v6 )
    {
      sub_8104EB2(a1, a2, v6);
      return 1;
    }
    else
    {
      for ( i = &off_8168560; *i; i += 2 )
      {
        if ( !strcmp(*i, s2) )
        {
          ((void (__cdecl *)(int))i[1])(a2);
          return 1;
        }
      }
      v2 = (const char *)SL_ConvertToString(*(unsigned __int16 *)(a2 + 360));
      Com_Printf("%s doesn't have a spawn function\n", v2);
      return 0;
    }
  }
  else
  {
    Com_Printf("G_CallSpawnEntity: NULL classname\n");
    return 0;
  }
}
// 8168560: using guessed type char *off_8168560;

//----- (081187B8) --------------------------------------------------------
char **sub_81187B8()
{
  char **i; // [esp+14h] [ebp-4h]

  for ( i = &off_8157780; *i; i += 4 )
    sub_807E1F6(0, *i, ((char *)i - (char *)&off_8157780) >> 4);
  return sub_80F5D66();
}
// 8157780: using guessed type char *off_8157780;

//----- (08118806) --------------------------------------------------------
int GScr_AddFieldsForRadiant()
{
  return Scr_AddFields("radiant", "txt");
}

//----- (08118822) --------------------------------------------------------
int __cdecl sub_8118822(int a1, int a2)
{
  char *v4; // [esp+10h] [ebp-8h]
  char **v5; // [esp+14h] [ebp-4h]

  v4 = (char *)&unk_8665480 + 560 * a1;
  if ( (a2 & 0xC000) == 49152 )
  {
    if ( *((_DWORD *)v4 + 86) )
    {
      sub_80F5DBC(*((_DWORD *)v4 + 86), a2 & 0xFFFF3FFF);
      return 1;
    }
    else
    {
      return 0;
    }
  }
  else
  {
    v5 = &(&off_8157780)[4 * a2];
    if ( v5[3] )
      ((void (__cdecl *)(char *, int))v5[3])(v4, a2);
    else
      sub_81188EE((int)v4, (int)v5[2], (int)v5[1]);
    return 1;
  }
}
// 8157780: using guessed type char *off_8157780;

//----- (081188EE) --------------------------------------------------------
int __cdecl sub_81188EE(int a1, int a2, int a3)
{
  int result; // eax
  int v4; // eax
  long double v5; // fst7
  int v6; // [esp+10h] [ebp-18h] BYREF
  int v7; // [esp+14h] [ebp-14h]
  int v8; // [esp+18h] [ebp-10h]

  result = a2;
  switch ( a2 )
  {
    case 0:
      result = Scr_GetInt(0);
      *(_DWORD *)(a1 + a3) = result;
      break;
    case 1:
      v5 = Scr_GetFloat(0);
      result = a1 + a3;
      *(float *)(a1 + a3) = v5;
      break;
    case 3:
      v4 = sub_8084586(0);
      result = Scr_SetString((_WORD *)(a1 + a3), v4);
      break;
    case 4:
      Scr_GetVector(0, &v6);
      *(_DWORD *)(a3 + a1) = v6;
      *(_DWORD *)(a1 + a3 + 4) = v7;
      result = v8;
      *(_DWORD *)(a1 + a3 + 8) = v8;
      break;
    case 5:
      result = Scr_GetEntity(0);
      *(_DWORD *)(a1 + a3) = result;
      break;
    case 6:
      Scr_GetVector(0, &v6);
      result = v7;
      *(_DWORD *)(a3 + a1) = v7;
      break;
    default:
      return result;
  }
  return result;
}

//----- (081189D2) --------------------------------------------------------
int __cdecl sub_81189D2(int a1, int a2, int a3)
{
  if ( !a1 )
    return sub_8118822(a2, a3);
  if ( a1 == 1 )
    sub_8101716(a2, a3);
  return 1;
}

//----- (08118A22) --------------------------------------------------------
char *__cdecl sub_8118A22(int a1, int a2)
{
  char *result; // eax
  char *v3; // [esp+10h] [ebp-8h]

  v3 = (char *)&unk_8665480 + 560 * a1;
  if ( (a2 & 0xC000) != 49152 )
    return (char *)sub_8118AAC((int)v3, (int)(&off_8157780)[4 * a2 + 2], (int)(&off_8157780)[4 * a2 + 1]);
  result = (char *)&unk_8665480 + 560 * a1;
  if ( *((_DWORD *)v3 + 86) )
    return (char *)sub_80F5E1E(*((_DWORD *)v3 + 86), a2 & 0xFFFF3FFF);
  return result;
}
// 8157780: using guessed type char *off_8157780;

//----- (08118AAC) --------------------------------------------------------
int __cdecl sub_8118AAC(int a1, int a2, int a3)
{
  int result; // eax
  char *v4; // eax
  unsigned __int16 v5; // [esp+1Eh] [ebp-2Ah]
  int v6[6]; // [esp+20h] [ebp-28h] BYREF
  unsigned __int16 v7; // [esp+3Ah] [ebp-Eh]
  char *s; // [esp+3Ch] [ebp-Ch]

  result = a2;
  switch ( a2 )
  {
    case 0:
      result = Scr_AddInt(*(_DWORD *)(a1 + a3));
      break;
    case 1:
      result = Scr_AddFloat(*(_DWORD *)(a1 + a3));
      break;
    case 2:
      s = (char *)(a1 + a3);
      result = Scr_AddString((char *)(a1 + a3));
      break;
    case 3:
      result = *(unsigned __int16 *)(a1 + a3);
      v7 = *(_WORD *)(a1 + a3);
      if ( v7 )
        result = Scr_AddConstString(v7);
      break;
    case 4:
      result = (int)Scr_AddVector((_DWORD *)(a1 + a3));
      break;
    case 5:
      result = a1 + a3;
      if ( *(_DWORD *)(a1 + a3) )
        result = Scr_AddEntity(*(int **)(a1 + a3));
      break;
    case 6:
      v6[0] = 0;
      v6[1] = *(_DWORD *)(a1 + a3);
      v6[2] = 0;
      result = (int)Scr_AddVector(v6);
      break;
    case 7:
      result = *(unsigned __int16 *)(a1 + a3);
      v5 = *(_WORD *)(a1 + a3);
      if ( v5 )
        result = Scr_AddObject(v5);
      break;
    case 8:
      v4 = (char *)G_ModelName(*(unsigned __int8 *)(a1 + a3));
      result = Scr_AddString(v4);
      break;
    default:
      return result;
  }
  return result;
}

//----- (08118BCC) --------------------------------------------------------
char *__cdecl sub_8118BCC(char *a1, int a2, int a3)
{
  char *result; // eax

  result = a1;
  if ( !a1 )
    return sub_8118A22(a2, a3);
  if ( a1 == (char *)1 )
    return (char *)sub_810169E(a2, a3);
  return result;
}

//----- (08118C0E) --------------------------------------------------------
int *__cdecl sub_8118C0E(int a1)
{
  int *result; // eax
  int v2[2]; // [esp+Ch] [ebp-Ch] BYREF
  char **i; // [esp+14h] [ebp-4h]

  for ( i = &off_8157780; ; i += 4 )
  {
    result = (int *)i;
    if ( !*i )
      break;
    if ( i[2] == (char *)3 )
    {
      v2[1] = a1;
      Scr_SetString(&i[1][a1], 0);
    }
  }
  for ( v2[0] = 0; v2[0] <= 6; ++v2[0] )
  {
    *(_BYTE *)(v2[0] + a1 + 528) = 0;
    Scr_SetString((_WORD *)(a1 + 2 * v2[0] + 536), 0);
    result = v2;
  }
  return result;
}
// 8157780: using guessed type char *off_8157780;

//----- (08118C98) --------------------------------------------------------
void __cdecl sub_8118C98(int *a1)
{
  sub_8118C0E((int)a1);
  Scr_FreeEntityNum(*a1, 0);
}

//----- (08118CC0) --------------------------------------------------------
int __cdecl Scr_AddEntity(int *a1)
{
  return Scr_AddEntityNum(*a1, 0);
}

//----- (08118CDE) --------------------------------------------------------
int __cdecl Scr_GetEntity(unsigned int a1)
{
  int v3; // [esp+10h] [ebp-8h] BYREF
  int v4; // [esp+14h] [ebp-4h]

  Scr_GetEntityRef(&v3, a1);
  v4 = v3;
  if ( !HIWORD(v3) )
    return 560 * (unsigned __int16)v4 + 140924032;
  Scr_ParamError(a1, (int)"not an entity");
  return 0;
}

//----- (08118D3A) --------------------------------------------------------
void __cdecl Scr_FreeHudElem(int a1)
{
  Scr_FreeHudElemConstStrings(a1);
  Scr_FreeEntityNum(-1963413621 * ((a1 - (int)&dword_8578000) >> 2), 1);
}
// 8578000: using guessed type int dword_8578000;

//----- (08118D6E) --------------------------------------------------------
int __cdecl Scr_AddHudElem(int a1)
{
  return Scr_AddEntityNum(-1963413621 * ((a1 - (int)dword_8578000) >> 2), 1);
}
// 8578000: using guessed type int dword_8578000[];

//----- (08118D98) --------------------------------------------------------
int __cdecl sub_8118D98(unsigned int a1)
{
  int v3; // [esp+10h] [ebp-8h] BYREF
  int v4; // [esp+14h] [ebp-4h]

  Scr_GetEntityRef(&v3, a1);
  v4 = v3;
  if ( HIWORD(v3) == 1 )
    return 140 * (unsigned __int16)v4 + 139952128;
  Scr_ParamError(a1, (int)"not a hudelem");
  return 0;
}

//----- (08118DF4) --------------------------------------------------------
int __cdecl Scr_ExecEntThread(int *a1, int a2, int a3)
{
  return (unsigned __int16)sub_8083A1A(*a1, 0, a2, a3);
}

//----- (08118E22) --------------------------------------------------------
int __cdecl sub_8118E22(int *a1, int a2, int a3)
{
  return sub_8083B14(*a1, 0, a2, a3);
}

//----- (08118E4E) --------------------------------------------------------
int __cdecl Scr_Notify(int *a1, unsigned __int16 a2, int a3)
{
  return sub_8083426(*a1, 0, a2, a3);
}

//----- (08118E82) --------------------------------------------------------
int Scr_GetEnt()
{
  int result; // eax
  int v1; // [esp+8h] [ebp-20h]
  int *v2; // [esp+Ch] [ebp-1Ch]
  int v3; // [esp+10h] [ebp-18h]
  __int16 v4; // [esp+14h] [ebp-14h]
  __int16 v5; // [esp+16h] [ebp-12h]
  int v6; // [esp+18h] [ebp-10h]
  void *i; // [esp+20h] [ebp-8h]

  v4 = Scr_GetConstString(0);
  v6 = Scr_GetString(1u);
  result = sub_807E2EA(0, v6);
  v3 = result;
  if ( result >= 0 )
  {
    result = (int)&(&off_8157780)[4 * result];
    if ( *(_DWORD *)(result + 8) == 3 )
    {
      v2 = 0;
      v1 = 0;
      for ( i = &unk_8665480; ; i = (char *)i + 560 )
      {
        result = v1;
        if ( v1 >= *(int *)dword_859B40C )
          break;
        if ( *((_BYTE *)i + 252) )
        {
          v5 = *(_WORD *)&(&off_8157780)[4 * v3 + 1][(_DWORD)i];
          if ( v5 )
          {
            if ( v5 == v4 )
            {
              if ( v2 )
                Scr_Error((int)"getent used with more than one entity");
              v2 = (int *)i;
            }
          }
        }
        ++v1;
      }
      if ( v2 )
        return Scr_AddEntity(v2);
    }
  }
  return result;
}
// 8157780: using guessed type char *off_8157780;

//----- (08118F7E) --------------------------------------------------------
int sub_8118F7E()
{
  int result; // eax
  int v1; // [esp+Ch] [ebp-1Ch]
  int v2; // [esp+Ch] [ebp-1Ch]
  int v3; // [esp+10h] [ebp-18h]
  __int16 v4; // [esp+14h] [ebp-14h]
  __int16 v5; // [esp+16h] [ebp-12h]
  int v6; // [esp+18h] [ebp-10h]
  int *j; // [esp+20h] [ebp-8h]
  void *i; // [esp+20h] [ebp-8h]

  if ( Scr_GetNumParam() )
  {
    v4 = Scr_GetConstString(0);
    v6 = Scr_GetString(1u);
    result = sub_807E2EA(0, v6);
    v3 = result;
    if ( result >= 0 )
    {
      result = (int)&(&off_8157780)[4 * result];
      if ( *(_DWORD *)(result + 8) == 3 )
      {
        Scr_MakeArray();
        v2 = 0;
        for ( i = &unk_8665480; ; i = (char *)i + 560 )
        {
          result = v2;
          if ( v2 >= *(int *)dword_859B40C )
            break;
          if ( *((_BYTE *)i + 252) )
          {
            v5 = *(_WORD *)&(&off_8157780)[4 * v3 + 1][(_DWORD)i];
            if ( v5 )
            {
              if ( v5 == v4 )
              {
                Scr_AddEntity((int *)i);
                Scr_AddArray();
              }
            }
          }
          ++v2;
        }
      }
    }
  }
  else
  {
    Scr_MakeArray();
    v1 = 0;
    for ( j = (int *)&unk_8665480; ; j += 140 )
    {
      result = v1;
      if ( v1 >= *(int *)dword_859B40C )
        break;
      if ( *((_BYTE *)j + 252) )
      {
        Scr_AddEntity(j);
        Scr_AddArray();
      }
      ++v1;
    }
  }
  return result;
}
// 8157780: using guessed type char *off_8157780;

//----- (081190B6) --------------------------------------------------------
int __cdecl sub_81190B6(int *a1, int a2)
{
  return sub_8084F6A(*a1, 0, a2);
}

//----- (081190DA) --------------------------------------------------------
int SP_worldspawn()
{
  char *v0; // eax
  char *v1; // eax
  int result; // eax
  float v3; // [esp+10h] [ebp-8h]
  char *nptr; // [esp+14h] [ebp-4h] BYREF

  sub_8117F4C("classname", (int)&byte_8157544, &nptr);
  if ( I_stricmp(nptr, "worldspawn") )
    Com_Error(1, (char *)&byte_81576A0);
  SV_SetConfigstring(2u, "cod");
  v0 = va("%i", *(_DWORD *)dword_859B5F8);
  SV_SetConfigstring(0xDu, v0);
  sub_8117F4C("ambienttrack", (int)&byte_8157544, &nptr);
  if ( *nptr )
  {
    v1 = va("n\\%s", nptr);
    SV_SetConfigstring(3u, v1);
  }
  else
  {
    SV_SetConfigstring(3u, (char *)&byte_8157544);
  }
  sub_8117F4C("message", (int)&byte_8157544, &nptr);
  SV_SetConfigstring(4u, nptr);
  SV_SetConfigstring(0xEu, *(char **)(g_motd + 8));
  sub_8117F4C("gravity", (int)"800", &nptr);
  v3 = atof(nptr);
  Dvar_SetFloat(g_gravity, (char *)LODWORD(v3));
  sub_8117F4C("northyaw", (int)&byte_8157544, &nptr);
  if ( *nptr )
    SV_SetConfigstring(0xBu, nptr);
  else
    SV_SetConfigstring(0xBu, "0");
  sub_8117F4C("spawnflags", (int)"0", &nptr);
  dword_86F1190 = atoi(nptr);
  dword_86F1020 = 1022;
  result = Scr_SetString(word_86F1188, (unsigned __int16)word_87A2300);
  byte_86F111C = 1;
  return result;
}
// 86F1020: using guessed type int dword_86F1020;
// 86F111C: using guessed type char byte_86F111C;
// 86F1188: using guessed type _WORD word_86F1188[4];
// 86F1190: using guessed type int dword_86F1190;
// 8793D94: using guessed type int g_gravity;
// 8793DBC: using guessed type int g_motd;
// 87A2300: using guessed type __int16 word_87A2300;

//----- (081192E0) --------------------------------------------------------
int __usercall G_SpawnEntitiesFromString@<eax>(long double a1@<st0>)
{
  int result; // eax

  if ( !G_ParseSpawnVars((int)&byte_859C748) )
    Com_Error(1, (char *)&byte_8157717);
  SP_worldspawn();
  while ( 1 )
  {
    result = G_ParseSpawnVars((int)&byte_859C748);
    if ( !result )
      break;
    G_CallSpawn(a1);
  }
  return result;
}
// 859C748: using guessed type char byte_859C748;

//----- (0811932A) --------------------------------------------------------
void *G_LoadStructs()
{
  char *s2; // [esp+10h] [ebp-8h] BYREF
  unsigned __int16 v2; // [esp+16h] [ebp-2h]

  v2 = Scr_ExecThread(dword_879D830, 0);
  Scr_FreeThread(v2);
  while ( G_ParseSpawnVars((int)&byte_859C748) )
  {
    sub_8117F4C("classname", (int)&byte_8157544, &s2);
    if ( !strcmp("script_struct", s2) )
      sub_8118398();
  }
  return sub_8090A48();
}
// 859C748: using guessed type char byte_859C748;
// 879D830: using guessed type int dword_879D830;

//----- (081193A8) --------------------------------------------------------
int __cdecl sub_81193A8(_DWORD *a1)
{
  int result; // eax

  *a1 = 0;
  a1[1] = 0;
  result = 0;
  a1[2] = 0;
  return result;
}

//----- (081193D2) --------------------------------------------------------
int __cdecl sub_81193D2(_DWORD *a1, _DWORD *a2)
{
  int result; // eax

  *a2 = *a1;
  a2[1] = a1[1];
  result = a1[2];
  a2[2] = result;
  return result;
}

//----- (08119404) --------------------------------------------------------
int __cdecl sub_8119404(const char *a1, _DWORD *a2)
{
  char *v2; // eax
  _BYTE *v3; // ebx
  int v6; // [esp+20h] [ebp-98h] BYREF
  int v7; // [esp+24h] [ebp-94h] BYREF
  int v8; // [esp+28h] [ebp-90h]
  int i; // [esp+2Ch] [ebp-8Ch]
  char nptr[136]; // [esp+30h] [ebp-88h] BYREF

  for ( i = 0; i <= 3; ++i )
  {
    *((_BYTE *)&v7 + i) = 0;
    *((_BYTE *)&v6 + i) = 0;
  }
  for ( i = 0; i <= 3; ++i )
  {
    if ( *a1 <= 47 || *a1 > 57 )
    {
      Com_Printf("Bad filter address: %s\n", a1);
      return 0;
    }
    v8 = 0;
    while ( *a1 > 47 && *a1 <= 57 )
    {
      v2 = (char *)a1++;
      nptr[v8++] = *v2;
    }
    nptr[v8] = 0;
    v3 = (char *)&v7 + i;
    *v3 = atoi(nptr);
    if ( *((_BYTE *)&v7 + i) )
      *((_BYTE *)&v6 + i) = -1;
    if ( !*a1 )
      break;
    ++a1;
  }
  *a2 = v6;
  a2[1] = v7;
  return 1;
}
// 8119404: using guessed type const char *arg_0;

//----- (0811956E) --------------------------------------------------------
void sub_811956E()
{
  size_t v0; // esi
  size_t v1; // eax
  char s[1032]; // [esp+20h] [ebp-418h] BYREF
  int i; // [esp+428h] [ebp-10h]
  int v4; // [esp+42Ch] [ebp-Ch]

  s[0] = 0;
  for ( i = 0; i < dword_87A1E80; ++i )
  {
    if ( dword_879FE84[2 * i] != -1 )
    {
      v4 = dword_879FE84[2 * i];
      v0 = 1024 - strlen(s);
      v1 = strlen(s);
      Com_sprintf(&s[v1], v0, "%i.%i.%i.%i ", (unsigned __int8)v4, BYTE1(v4), BYTE2(v4), HIBYTE(v4));
    }
  }
  Dvar_SetString(g_banIPs, s);
}
// 879FE84: using guessed type int dword_879FE84[2047];
// 87A1E80: using guessed type int dword_87A1E80;
// 811956E: using guessed type char s[1032];

//----- (08119642) --------------------------------------------------------
void __cdecl sub_8119642(const char *a1)
{
  int i; // [esp+14h] [ebp-4h]

  for ( i = 0; i < dword_87A1E80 && dword_879FE84[2 * i] != -1; ++i )
    ;
  if ( i == dword_87A1E80 )
  {
    if ( dword_87A1E80 == 1024 )
    {
      Com_Printf("IP filter list is full\n");
      return;
    }
    ++dword_87A1E80;
  }
  if ( !sub_8119404(a1, (_DWORD *)(8 * i + 142212736)) )
    dword_879FE84[2 * i] = -1;
  sub_811956E();
}
// 879FE84: using guessed type int dword_879FE84[2047];
// 87A1E80: using guessed type int dword_87A1E80;

//----- (081196D0) --------------------------------------------------------
char *G_ProcessIPBans()
{
  char *result; // eax
  char dest[1032]; // [esp+10h] [ebp-418h] BYREF
  char *i; // [esp+418h] [ebp-10h]
  char *s; // [esp+41Ch] [ebp-Ch]

  dword_87A1E80 = 0;
  I_strncpyz(dest, *(char **)(g_banIPs + 8), 1024);
  s = dest;
  for ( i = dest; ; i = s )
  {
    result = i;
    if ( !*i )
      break;
    result = strchr(s, 32);
    s = result;
    if ( !result )
      break;
    while ( *s == 32 )
      *s++ = 0;
    if ( *i )
      sub_8119642(i);
  }
  return result;
}
// 87A1E80: using guessed type int dword_87A1E80;

//----- (08119772) --------------------------------------------------------
void sub_8119772()
{
  char dest[1032]; // [esp+10h] [ebp-408h] BYREF

  if ( SV_Cmd_Argc() > 1 )
  {
    SV_Cmd_ArgvBuffer(1, dest, 1024);
    sub_8119642(dest);
  }
  else
  {
    Com_Printf("Usage:  addip <ip-mask>\n");
  }
}

//----- (081197C2) --------------------------------------------------------
void sub_81197C2()
{
  char dest[1028]; // [esp+10h] [ebp-418h] BYREF
  int i; // [esp+414h] [ebp-14h]
  char v2[4]; // [esp+418h] [ebp-10h] BYREF
  int v3; // [esp+41Ch] [ebp-Ch]

  if ( SV_Cmd_Argc() > 1 )
  {
    SV_Cmd_ArgvBuffer(1, dest, 1024);
    if ( sub_8119404(dest, v2) )
    {
      for ( i = 0; i < dword_87A1E80; ++i )
      {
        if ( dword_879FE80[2 * i] == *(_DWORD *)v2 && dword_879FE84[2 * i] == v3 )
        {
          dword_879FE84[2 * i] = -1;
          Com_Printf("Removed.\n");
          sub_811956E();
          return;
        }
      }
      Com_Printf("Didn't find %s.\n", dest);
    }
  }
  else
  {
    Com_Printf("Usage:  sv removeip <ip-mask>\n");
  }
}
// 879FE80: using guessed type int dword_879FE80[];
// 879FE84: using guessed type int dword_879FE84[2047];
// 87A1E80: using guessed type int dword_87A1E80;

//----- (08119892) --------------------------------------------------------
int Svcmd_EntityList_f()
{
  int result; // eax
  const char *v1; // eax
  _DWORD *v2; // [esp+10h] [ebp-8h]
  int i; // [esp+14h] [ebp-4h]

  v2 = &unk_86656B0;
  for ( i = 1; ; ++i )
  {
    result = i;
    if ( i >= *(int *)dword_859B40C )
      break;
    if ( *((_BYTE *)v2 + 252) )
    {
      Com_Printf("%3i:", i);
      switch ( v2[1] )
      {
        case 0:
          Com_Printf("ET_GENERAL          ");
          break;
        case 1:
          Com_Printf("ET_PLAYER           ");
          break;
        case 3:
          Com_Printf("ET_ITEM             ");
          break;
        case 4:
          Com_Printf("ET_MISSILE          ");
          break;
        case 5:
          Com_Printf("ET_INVISIBLE        ");
          break;
        case 6:
          Com_Printf("ET_SCRIPTMOVER      ");
          break;
        default:
          Com_Printf("%3i                 ", v2[1]);
          break;
      }
      if ( *((_WORD *)v2 + 180) )
      {
        v1 = (const char *)SL_ConvertToString(*((unsigned __int16 *)v2 + 180));
        Com_Printf("%s", v1);
      }
      Com_Printf("\n");
    }
    v2 += 140;
  }
  return result;
}

//----- (081199B4) --------------------------------------------------------
int __cdecl sub_81199B4(char *nptr)
{
  int v3; // [esp+Ch] [ebp-Ch]
  int i; // [esp+10h] [ebp-8h]
  int v5; // [esp+14h] [ebp-4h]

  if ( *nptr <= 47 || *nptr > 57 )
  {
    for ( i = 0; i < dword_859B5E4; ++i )
    {
      v5 = dword_859B400 + 10404 * i;
      if ( *(_DWORD *)(v5 + 9924) && !I_stricmp((char *)(v5 + 10116), nptr) )
        return v5;
    }
    Com_Printf("User %s is not on the server\n", nptr);
    return 0;
  }
  else
  {
    v3 = atoi(nptr);
    if ( v3 >= 0 && v3 < dword_859B5E4 )
    {
      if ( *(_DWORD *)(dword_859B400 + 10404 * v3 + 9924) )
      {
        return dword_859B400 + 10404 * v3;
      }
      else
      {
        Com_Printf("Client %i is not connected\n", v3);
        return 0;
      }
    }
    else
    {
      Com_Printf("Bad client slot: %i\n", v3);
      return 0;
    }
  }
}
// 859B400: using guessed type int dword_859B400;
// 859B5E4: using guessed type int dword_859B5E4;

//----- (08119AD4) --------------------------------------------------------
int sub_8119AD4()
{
  void *v0; // eax
  char *v1; // eax
  char dest[1032]; // [esp+20h] [ebp-408h] BYREF

  SV_Cmd_ArgvBuffer(0, dest, 1024);
  if ( I_stricmp(dest, "entitylist") )
  {
    if ( I_stricmp(dest, "addip") )
    {
      if ( I_stricmp(dest, "removeip") )
      {
        if ( I_stricmp(dest, "listip") )
        {
          if ( !*(_DWORD *)(dedicated + 8) || I_stricmp(dest, "say") )
          {
            return 0;
          }
          else
          {
            v0 = sub_80FBA44(1);
            v1 = va(aCGameServer, 101, v0);
            SV_GameSendServerCommand(-1, 0, v1);
            return 1;
          }
        }
        else
        {
          Cbuf_ExecuteText(1, "g_banIPs\n");
          return 1;
        }
      }
      else
      {
        sub_81197C2();
        return 1;
      }
    }
    else
    {
      sub_8119772();
      return 1;
    }
  }
  else
  {
    Svcmd_EntityList_f();
    return 1;
  }
}
// 8793D8C: using guessed type int dedicated;

//----- (08119C40) --------------------------------------------------------
_BOOL4 __cdecl sub_8119C40(int a1, int a2)
{
  if ( !*(_DWORD *)(a1 + 344) || !*(_DWORD *)(a2 + 344) )
    return 0;
  if ( *(_DWORD *)(*(_DWORD *)(a1 + 344) + 10060) )
    return *(_DWORD *)(*(_DWORD *)(a1 + 344) + 10060) == *(_DWORD *)(*(_DWORD *)(a2 + 344) + 10060);
  return 0;
}

//----- (08119CB8) --------------------------------------------------------
int __cdecl sub_8119CB8(int a1)
{
  int result; // eax
  float s[7]; // [esp+30h] [ebp-78h] BYREF
  unsigned __int16 v3; // [esp+4Ch] [ebp-5Ch]
  int v4[4]; // [esp+60h] [ebp-48h] BYREF
  int v5[2]; // [esp+70h] [ebp-38h] BYREF
  float v6; // [esp+78h] [ebp-30h]
  int v7[6]; // [esp+80h] [ebp-28h] BYREF
  int v8; // [esp+98h] [ebp-10h]
  int v9; // [esp+9Ch] [ebp-Ch]

  if ( *(_DWORD *)(*(_DWORD *)(a1 + 344) + 9896) )
  {
    sub_80F61BE(a1, (float *)v5);
    sub_80F63A0(a1, (int)v7, 0, 0);
    if ( *(float *)(*(_DWORD *)(a1 + 344) + 248) < 8.0 )
      v6 = 8.0 - *(float *)(*(_DWORD *)(a1 + 344) + 248) + v6;
    sub_8119F76((float *)v5, 8192.0, (float *)v7, (float *)v4);
  }
  else
  {
    if ( !*(_DWORD *)(*(_DWORD *)(a1 + 344) + 10060) )
    {
      *(_DWORD *)(*(_DWORD *)(a1 + 344) + 312) = -1;
      result = *(_DWORD *)(a1 + 344);
      *(_DWORD *)(result + 316) = 0;
      return result;
    }
    sub_80F61BE(a1, (float *)v5);
    sub_80F63A0(a1, (int)v7, 0, 0);
    sub_8119F76((float *)v5, 8192.0, (float *)v7, (float *)v4);
  }
  G_TraceCapsule(s, (float *)v5, flt_8145E68, flt_8145E68, (float *)v4, *(_DWORD *)(*(_DWORD *)(a1 + 344) + 204), 33554433);
  v9 = v3;
  if ( v3 <= 0x3Fu
    && dword_86655D8[140 * v9]
    && (!sub_80FCEA8(a1) || *(_DWORD *)(dword_86655D8[140 * v9] + 10060) == *(_DWORD *)(*(_DWORD *)(a1 + 344) + 10060)) )
  {
    v8 = dword_8665614[140 * v9];
  }
  else
  {
    v9 = -1;
    v8 = 0;
  }
  *(_DWORD *)(*(_DWORD *)(a1 + 344) + 312) = v9;
  result = v8;
  *(_DWORD *)(*(_DWORD *)(a1 + 344) + 316) = v8;
  return result;
}
// 8145E68: using guessed type float flt_8145E68[3];
// 86655D8: using guessed type int dword_86655D8[];
// 8665614: using guessed type int dword_8665614[];
// 8119CB8: using guessed type float s[7];

//----- (08119EF2) --------------------------------------------------------
int sub_8119EF2()
{
  int result; // eax
  char *v1; // [esp+10h] [ebp-8h]
  int i; // [esp+14h] [ebp-4h]

  result = dword_859B5EC - dword_859B60C;
  if ( dword_859B5EC - dword_859B60C > 0 )
  {
    dword_859B60C = dword_859B5EC;
    for ( i = 0; ; ++i )
    {
      result = i;
      if ( i >= *(_DWORD *)(g_maxclients + 8) )
        break;
      v1 = (char *)&unk_8665480 + 560 * i;
      if ( v1[252] )
      {
        if ( (*(_DWORD *)(*((_DWORD *)v1 + 86) + 12) & 0x400000) == 0 )
          sub_8119CB8((int)v1);
      }
    }
  }
  return result;
}
// 859B60C: using guessed type int dword_859B60C;
// 8793D88: using guessed type int g_maxclients;

//----- (08119F76) --------------------------------------------------------
float *__cdecl sub_8119F76(float *a1, float a2, float *a3, float *a4)
{
  float *result; // eax

  *a4 = a2 * *a3 + *a1;
  a4[1] = a2 * a3[1] + a1[1];
  result = a3 + 2;
  a4[2] = a2 * a3[2] + a1[2];
  return result;
}

//----- (08119FCC) --------------------------------------------------------
int __cdecl sub_8119FCC(int *a1, int *a2)
{
  int result; // eax
  int v3; // [esp+14h] [ebp-4h]

  result = Scr_IsSystemActive();
  if ( result )
  {
    if ( dword_859E9E8 == 256 )
    {
      Scr_AddEntity(a2);
      return Scr_Notify(a1, word_87A22F4, 1);
    }
    else
    {
      v3 = 12 * dword_859E9E8++ + 140104168;
      *(_WORD *)v3 = *(_WORD *)a1;
      *(_WORD *)(v3 + 2) = *(_WORD *)a2;
      *(_DWORD *)(v3 + 4) = a1[138];
      result = a2[138];
      *(_DWORD *)(v3 + 8) = result;
    }
  }
  return result;
}
// 859E9E8: using guessed type int dword_859E9E8;
// 87A22F4: using guessed type __int16 word_87A22F4;

//----- (0811A074) --------------------------------------------------------
int __cdecl sub_811A074(int a1)
{
  int result; // eax

  SV_SetBrushModel(a1);
  *(_DWORD *)(a1 + 284) = 1079771144;
  *(_BYTE *)(a1 + 242) = 1;
  result = *(_DWORD *)(a1 + 8) | 1;
  *(_DWORD *)(a1 + 8) = result;
  return result;
}

//----- (0811A0AE) --------------------------------------------------------
void __cdecl sub_811A0AE(int a1, int a2)
{
  int v2; // [esp+14h] [ebp-4h] BYREF

  if ( byte_859C748 && sub_8117F76("wait", (int)&unk_8157A40, (float *)&v2) && *(float *)&v2 <= 0.0 )
    *(_DWORD *)(a1 + 368) |= a2;
}
// 859C748: using guessed type char byte_859C748;

//----- (0811A106) --------------------------------------------------------
int __cdecl sub_811A106(int a1)
{
  int result; // eax

  *(_DWORD *)(a1 + 284) = 0;
  if ( (*(_DWORD *)(a1 + 368) & 8) == 0 )
    *(_DWORD *)(a1 + 284) |= 0x40000000u;
  if ( (*(_BYTE *)(a1 + 368) & 1) != 0 )
    *(_DWORD *)(a1 + 284) |= 0x40000u;
  if ( (*(_DWORD *)(a1 + 368) & 2) != 0 )
    *(_DWORD *)(a1 + 284) |= 0x80000u;
  result = *(_DWORD *)(a1 + 368) & 4;
  if ( result )
  {
    result = a1;
    *(_DWORD *)(a1 + 284) |= 0x100000u;
  }
  return result;
}

//----- (0811A1B8) --------------------------------------------------------
int __cdecl sub_811A1B8(int *a1)
{
  int result; // eax

  result = a1[92] & 0x10;
  if ( result )
    return sub_811CB00(a1);
  return result;
}

//----- (0811A1DE) --------------------------------------------------------
int __cdecl sub_811A1DE(int *a1, int *a2)
{
  sub_8119FCC(a1, a2);
  return sub_811A1B8(a1);
}

//----- (0811A20A) --------------------------------------------------------
int __cdecl sub_811A20A(int a1)
{
  *(_BYTE *)(a1 + 358) = 1;
  sub_811A0AE(a1, 16);
  sub_811A074(a1);
  sub_811A106(a1);
  return SV_LinkEntity(a1);
}

//----- (0811A250) --------------------------------------------------------
int __cdecl sub_811A250(int a1)
{
  char *v1; // eax
  char *v2; // eax
  char v4[4]; // [esp+20h] [ebp-8h] BYREF
  char v5[4]; // [esp+24h] [ebp-4h] BYREF

  if ( byte_859C748 )
  {
    if ( !sub_8117F76("radius", (int)&unk_8157A40, (float *)v5) )
    {
      v1 = va(
             "radius not specified for trigger_radius at (%g %g %g)",
             *(float *)(a1 + 312),
             *(float *)(a1 + 316),
             *(float *)(a1 + 320));
      Com_Error(1, v1);
    }
    if ( !sub_8117F76("height", (int)&unk_8157A40, (float *)v4) )
    {
      v2 = va(
             "height not specified for trigger_radius at (%g %g %g)",
             *(float *)(a1 + 312),
             *(float *)(a1 + 316),
             *(float *)(a1 + 320));
      Com_Error(1, v2);
    }
  }
  else
  {
    if ( (unsigned int)Scr_GetNumParam() <= 4 )
      Scr_Error((int)"USAGE: spawn( \"trigger_radius\", <origin>, <spawnflags>, <radius>, <height> )");
    *(float *)v5 = Scr_GetFloat(3u);
    *(float *)v4 = Scr_GetFloat(4u);
  }
  *(_BYTE *)(a1 + 358) = 1;
  *(_DWORD *)(a1 + 260) = *(_DWORD *)v5 ^ 0x80000000;
  *(_DWORD *)(a1 + 264) = *(_DWORD *)v5 ^ 0x80000000;
  *(_DWORD *)(a1 + 268) = 0;
  *(float *)(a1 + 272) = *(float *)v5;
  *(float *)(a1 + 276) = *(float *)v5;
  *(float *)(a1 + 280) = *(float *)v4;
  *(_BYTE *)(a1 + 242) = 33;
  sub_811A0AE(a1, 16);
  sub_811A106(a1);
  return SV_LinkEntity(a1);
}
// 859C748: using guessed type char byte_859C748;

//----- (0811A3F0) --------------------------------------------------------
int __cdecl sub_811A3F0(int a1)
{
  char *v1; // eax
  char v3[4]; // [esp+24h] [ebp-4h] BYREF

  if ( !sub_8117F76("radius", (int)&unk_8157A40, (float *)v3) )
  {
    v1 = va(
           "radius not specified for trigger_radius at (%g %g %g)",
           *(float *)(a1 + 312),
           *(float *)(a1 + 316),
           *(float *)(a1 + 320));
    Com_Error(1, v1);
  }
  *(_BYTE *)(a1 + 358) = 1;
  *(float *)v3 = *(float *)v3 + 64.0;
  *(_DWORD *)(a1 + 260) = *(_DWORD *)v3 ^ 0x80000000;
  *(_DWORD *)(a1 + 264) = *(_DWORD *)v3 ^ 0x80000000;
  *(_DWORD *)(a1 + 268) = -943501312;
  *(float *)(a1 + 272) = *(float *)v3;
  *(float *)(a1 + 276) = *(float *)v3;
  *(_DWORD *)(a1 + 280) = 1203982336;
  *(_BYTE *)(a1 + 242) = 65;
  sub_811A0AE(a1, 16);
  sub_811A106(a1);
  return SV_LinkEntity(a1);
}

//----- (0811A4FC) --------------------------------------------------------
int __cdecl sub_811A4FC(int a1, int a2)
{
  int result; // eax

  result = a2;
  if ( *(_BYTE *)(a2 + 353) )
  {
    result = *(_DWORD *)(a1 + 432);
    if ( result <= dword_859B5EC )
    {
      sub_8119FCC((int *)a1, (int *)a2);
      if ( (*(_DWORD *)(a1 + 368) & 0x10) != 0 )
        *(_DWORD *)(a1 + 432) = dword_859B5EC + 1000;
      else
        *(_DWORD *)(a1 + 432) = dword_859B5EC + 50;
      if ( (*(_DWORD *)(a1 + 368) & 8) != 0 )
        sub_80FF7C8((int *)a2, (int *)a1, (int *)a1, 0, 0, *(_DWORD *)(a1 + 412), 16, 0xDu, 0, 0);
      else
        sub_80FF7C8((int *)a2, (int *)a1, (int *)a1, 0, 0, *(_DWORD *)(a1 + 412), 0, 0xDu, 0, 0);
      result = *(_DWORD *)(a1 + 368) & 0x20;
      if ( result )
      {
        result = a1;
        *(_BYTE *)(a1 + 358) = 2;
      }
    }
  }
  return result;
}

//----- (0811A62A) --------------------------------------------------------
int __cdecl SP_trigger_hurt(int a1)
{
  int result; // eax
  int v2; // [esp+14h] [ebp-4h] BYREF

  sub_811A074(a1);
  sub_8117F4C("sound", (int)"world_hurt_me", &v2);
  if ( !*(_DWORD *)(a1 + 412) )
    *(_DWORD *)(a1 + 412) = 5;
  *(_DWORD *)(a1 + 284) = 1079771144;
  result = a1;
  if ( ((*(_BYTE *)(a1 + 368) ^ 1) & 1) != 0 )
    *(_BYTE *)(a1 + 358) = 3;
  else
    *(_BYTE *)(a1 + 358) = 2;
  return result;
}

//----- (0811A6A6) --------------------------------------------------------
int __cdecl sub_811A6A6(int a1)
{
  *(_BYTE *)(a1 + 358) = 1;
  *(_DWORD *)(a1 + 368) |= 0x10u;
  sub_811A074(a1);
  sub_811A106(a1);
  return SV_LinkEntity(a1);
}

//----- (0811A6EE) --------------------------------------------------------
_BOOL4 __cdecl sub_811A6EE(int a1, int a2)
{
  if ( (*(_BYTE *)(a1 + 368) & 1) != 0 && a2 == 1 )
    return 0;
  if ( (*(_DWORD *)(a1 + 368) & 2) != 0 && a2 == 2 )
    return 0;
  if ( (*(_DWORD *)(a1 + 368) & 4) != 0 && (unsigned int)(a2 - 3) <= 3 )
    return 0;
  if ( (*(_DWORD *)(a1 + 368) & 8) != 0 && a2 >= 3 && (a2 <= 6 || a2 == 14) )
    return 0;
  if ( (*(_DWORD *)(a1 + 368) & 0x10) != 0 && (a2 == 4 || a2 == 6) )
    return 0;
  if ( (*(_DWORD *)(a1 + 368) & 0x20) != 0 && a2 == 7 )
    return 0;
  return (*(_DWORD *)(a1 + 368) & 0x100) == 0 || a2 && (a2 < 0 || (unsigned int)(a2 - 9) > 4);
}

//----- (0811A826) --------------------------------------------------------
int __cdecl sub_811A826(int *a1, int *a2, int a3, int a4)
{
  int result; // eax

  if ( a1[106] <= 0 || (result = a3, a3 >= a1[106]) )
  {
    result = sub_811A6EE((int)a1, a4);
    if ( result )
    {
      if ( !a1[107] || (result = (int)a1, 32000 - a1[101] >= a1[107]) )
      {
        if ( a4 != -1 )
          sub_8119FCC(a1, a2);
        a1[101] = 32000;
        result = a1[92] & 0x200;
        if ( result )
          return sub_811CB00(a1);
      }
    }
  }
  return result;
}

//----- (0811A8D2) --------------------------------------------------------
int __cdecl sub_811A8D2(int *a1, int *a2)
{
  return sub_811A826(a1, a2, a1[107] + 1, -1);
}

//----- (0811A902) --------------------------------------------------------
int *__cdecl sub_811A902(int *a1, int *a2, int a3, int a4, int a5)
{
  int *result; // eax

  sub_811A826(a1, a2, a3, a5);
  result = a1;
  if ( !a1[107] )
  {
    result = a1;
    a1[101] = 32000;
  }
  return result;
}

//----- (0811A944) --------------------------------------------------------
int *__cdecl sub_811A944(int *a1, int a2, int *a3, int a4, int a5)
{
  int *result; // eax

  sub_811A826(a1, a3, a4, a5);
  result = a1;
  if ( !a1[107] )
  {
    result = a1;
    a1[101] = 32000;
  }
  return result;
}

//----- (0811A986) --------------------------------------------------------
int __cdecl SP_trigger_damage(int a1)
{
  sub_8117FB2("accumulate", (int)"0", (int *)(a1 + 428));
  sub_8117FB2("threshold", (int)"0", (int *)(a1 + 424));
  *(_DWORD *)(a1 + 404) = 32000;
  *(_BYTE *)(a1 + 353) = 1;
  *(_BYTE *)(a1 + 358) = 4;
  sub_811A0AE(a1, 512);
  sub_811A074(a1);
  return SV_LinkEntity(a1);
}

//----- (0811AA18) --------------------------------------------------------
int __cdecl sub_811AA18(int *a1, _DWORD *a2, float *a3, int a4, int a5)
{
  int result; // eax
  float *v6; // [esp+2Ch] [ebp-105Ch]
  float v7[4]; // [esp+30h] [ebp-1058h] BYREF
  float v8[4]; // [esp+40h] [ebp-1048h] BYREF
  float v9[4]; // [esp+50h] [ebp-1038h] BYREF
  float v10[4]; // [esp+60h] [ebp-1028h] BYREF
  int v11[1026]; // [esp+70h] [ebp-1018h] BYREF
  int v12; // [esp+1078h] [ebp-10h]
  int i; // [esp+107Ch] [ebp-Ch]

  sub_811ADFA(a2, v10);
  sub_811ADFA(a2, v9);
  sub_80A660A(a3, v10, v9);
  v12 = sub_805E782((int)v10, (int)v9, (int)v11, 1024, 0x400000);
  for ( i = 0; ; ++i )
  {
    result = i;
    if ( i >= v12 )
      break;
    v6 = (float *)((char *)&unk_8665480 + 560 * v11[i]);
    if ( *((_WORD *)v6 + 180) == word_87A22FA )
    {
      sub_811AE2A(v6 + 78, v6 + 65, v8);
      sub_811AE2A(v6 + 78, v6 + 68, v7);
      if ( sub_809BE82((int)a2, (int)flt_8145E68, (int)flt_8145E68, (int)a3, *(_DWORD *)v6, -1) )
      {
        Scr_AddEntity(a1);
        Scr_AddInt(a4);
        Scr_Notify((int *)v6, word_87A22A8, 2);
        sub_811A826((int *)v6, a1, a4, a5);
        if ( !*((_DWORD *)v6 + 107) )
          *((_DWORD *)v6 + 101) = 32000;
      }
    }
  }
  return result;
}
// 8145E68: using guessed type float flt_8145E68[3];
// 87A22A8: using guessed type __int16 word_87A22A8;
// 87A22FA: using guessed type __int16 word_87A22FA;
// 811AA18: using guessed type float var_1028[4];
// 811AA18: using guessed type float var_1038[4];
// 811AA18: using guessed type int var_1018[1026];
// 811AA18: using guessed type float var_1048[4];
// 811AA18: using guessed type float var_1058[4];

//----- (0811AC06) --------------------------------------------------------
int __cdecl sub_811AC06(int *a1, _DWORD *a2, float *a3, int a4, int a5)
{
  int result; // eax
  int *v6; // [esp+2Ch] [ebp-103Ch]
  float v7[4]; // [esp+30h] [ebp-1038h] BYREF
  float v8[4]; // [esp+40h] [ebp-1028h] BYREF
  int v9[1026]; // [esp+50h] [ebp-1018h] BYREF
  int v10; // [esp+1058h] [ebp-10h]
  int i; // [esp+105Ch] [ebp-Ch]

  sub_811ADFA(a2, v8);
  sub_811ADFA(a2, v7);
  sub_80A660A(a3, v8, v7);
  v10 = sub_805E782((int)v8, (int)v7, (int)v9, 1024, 0x400000);
  for ( i = 0; ; ++i )
  {
    result = i;
    if ( i >= v10 )
      break;
    v6 = (int *)((char *)&unk_8665480 + 560 * v9[i]);
    if ( *((_WORD *)v6 + 180) == word_87A22FA
      && (v6[93] & 0x4000) != 0
      && sub_809BE82((int)a2, (int)flt_8145E68, (int)flt_8145E68, (int)a3, *v6, -1) )
    {
      Scr_AddEntity(a1);
      Scr_AddInt(a4);
      Scr_Notify(v6, word_87A22A8, 2);
      sub_811A826(v6, a1, a4, a5);
      if ( !v6[107] )
        v6[101] = 32000;
    }
  }
  return result;
}
// 8145E68: using guessed type float flt_8145E68[3];
// 87A22A8: using guessed type __int16 word_87A22A8;
// 87A22FA: using guessed type __int16 word_87A22FA;
// 811AC06: using guessed type float var_1028[4];
// 811AC06: using guessed type float var_1038[4];
// 811AC06: using guessed type int var_1018[1026];

//----- (0811ADB6) --------------------------------------------------------
int __cdecl sub_811ADB6(int a1)
{
  SV_SetBrushModel(a1);
  *(_DWORD *)(a1 + 284) = 0x20000000;
  *(_BYTE *)(a1 + 242) = 1;
  *(_DWORD *)(a1 + 8) |= 1u;
  return SV_LinkEntity(a1);
}

//----- (0811ADFA) --------------------------------------------------------
int __cdecl sub_811ADFA(_DWORD *a1, _DWORD *a2)
{
  int result; // eax

  *a2 = *a1;
  a2[1] = a1[1];
  result = a1[2];
  a2[2] = result;
  return result;
}

//----- (0811AE2A) --------------------------------------------------------
float *__cdecl sub_811AE2A(float *a1, float *a2, float *a3)
{
  float *result; // eax

  *a3 = *a1 + *a2;
  a3[1] = a1[1] + a2[1];
  result = a1 + 2;
  a3[2] = a1[2] + a2[2];
  return result;
}

//----- (0811AE70) --------------------------------------------------------
int __cdecl G_FindConfigstringIndex(char *s2, int a2, int a3, int a4, const char *a5)
{
  char *v5; // eax
  char *v6; // eax
  char *s1; // [esp+10h] [ebp-8h]
  int i; // [esp+14h] [ebp-4h]

  if ( !s2 || !*s2 )
    return 0;
  for ( i = 1; i < a3; ++i )
  {
    s1 = (char *)SV_GetConfigstringConst(a2 + i);
    if ( !*s1 )
      break;
    if ( !strcasecmp(s1, s2) )
      return i;
  }
  if ( a4 )
  {
    if ( i == a3 )
    {
      v6 = va((char *)&byte_8157B80, a2, s2);
      Com_Error(1, v6);
    }
    SV_SetConfigstring(a2 + i, s2);
    return i;
  }
  else
  {
    if ( a5 )
    {
      v5 = va("%s \"%s\" not precached", a5, s2);
      Scr_Error((int)v5);
    }
    return 0;
  }
}
// 811AE70: using guessed type _DWORD arg_4;

//----- (0811AF6E) --------------------------------------------------------
int __cdecl G_LocalizedStringIndex(char *s2)
{
  if ( *s2 )
    return G_FindConfigstringIndex(s2, 1310, 256, dword_859B41C, "localized string");
  else
    return 0;
}

//----- (0811AFBA) --------------------------------------------------------
int __cdecl sub_811AFBA(char *src)
{
  char dest[72]; // [esp+20h] [ebp-48h] BYREF

  strcpy(dest, src);
  I_strlwr(dest);
  return G_FindConfigstringIndex(dest, 1566, 128, dword_859B41C, "shader");
}

//----- (0811B00C) --------------------------------------------------------
int __cdecl G_ModelIndex(char *s2)
{
  char *v1; // eax
  char *s1; // [esp+Ch] [ebp-Ch]
  int i; // [esp+10h] [ebp-8h]

  if ( !*s2 )
    return 0;
  for ( i = 1; i <= 255; ++i )
  {
    s1 = (char *)SV_GetConfigstringConst(i + 334);
    if ( !*s1 )
      break;
    if ( !strcasecmp(s1, s2) )
      return i;
  }
  if ( !dword_859B41C )
  {
    v1 = va("model '%s' not precached", s2);
    Scr_Error((int)v1);
  }
  if ( i == 256 )
    Com_Error(1, (char *)&byte_8157BDF);
  dword_87A1EA0[i] = SV_XModelGet(s2);
  SV_SetConfigstring(i + 334, s2);
  return i;
}
// 87A1EA0: using guessed type int dword_87A1EA0[256];

//----- (0811B0F8) --------------------------------------------------------
int __cdecl SV_XModelForIndex(int a1)
{
  return dword_87A1EA0[a1];
}
// 87A1EA0: using guessed type int dword_87A1EA0[256];

//----- (0811B108) --------------------------------------------------------
int __cdecl G_XModelBad(int a1)
{
  int v1; // eax

  v1 = SV_XModelForIndex(a1);
  return XModelBad(v1);
}

//----- (0811B124) --------------------------------------------------------
const char *__cdecl G_ModelName(int a1)
{
  return SV_GetConfigstringConst(a1 + 334);
}

//----- (0811B13C) --------------------------------------------------------
int __cdecl sub_811B13C(char *s2)
{
  return G_FindConfigstringIndex(s2, 110, 32, 1, 0);
}

//----- (0811B170) --------------------------------------------------------
int __cdecl G_EffectIndex(char *s2)
{
  return G_FindConfigstringIndex(s2, 846, 64, dword_859B41C, "effect");
}

//----- (0811B1A4) --------------------------------------------------------
int __cdecl G_ShellShockIndex(char *s2)
{
  return G_FindConfigstringIndex(s2, 1166, 16, 1, 0);
}

//----- (0811B1D8) --------------------------------------------------------
int __cdecl sub_811B1D8(char *s2)
{
  return (unsigned __int8)G_FindConfigstringIndex(s2, 590, 256, 1, 0);
}

//----- (0811B20E) --------------------------------------------------------
_DWORD *__usercall sub_811B20E@<eax>(long double a1@<st0>, int a2)
{
  _DWORD *result; // eax
  int i; // [esp+18h] [ebp-80h]
  int v4; // [esp+1Ch] [ebp-7Ch]
  __int16 **v5[2]; // [esp+20h] [ebp-78h] BYREF
  _DWORD v6[24]; // [esp+28h] [ebp-70h]
  __int16 **v7; // [esp+88h] [ebp-10h]
  int v8; // [esp+8Ch] [ebp-Ch]

  result = (_DWORD *)a2;
  if ( !*(_DWORD *)(a2 + 344) )
  {
    sub_811BEEE((int *)a2);
    v8 = *(unsigned __int8 *)(a2 + 356);
    if ( v8 )
    {
      v7 = (__int16 **)SV_XModelForIndex(v8);
      v5[0] = v7;
      v5[1] = 0;
      v6[0] = 0;
      v4 = 1;
      if ( !*(_DWORD *)(a2 + 4) || *(_DWORD *)(a2 + 4) == 6 || *(_DWORD *)(a2 + 4) == 9 )
        *(_DWORD *)(a2 + 140) = v8;
      for ( i = 0; i <= 6; ++i )
      {
        v8 = *(unsigned __int8 *)(i + a2 + 528);
        if ( v8 )
        {
          v5[3 * v4] = (__int16 **)SV_XModelForIndex(v8);
          v5[3 * v4 + 1] = (__int16 **)SL_ConvertToString(*(unsigned __int16 *)(a2 + 2 * i + 536));
          v6[3 * v4++] = ((int)*(unsigned __int8 *)(a2 + 357) >> i) & 1;
        }
      }
      sub_8062A66(v5, v4, 0, *(_DWORD *)a2);
      return sub_811BAF4(a1, a2, 1);
    }
    else
    {
      return sub_811BAF4(a1, a2, 0);
    }
  }
  return result;
}

//----- (0811B3EA) --------------------------------------------------------
int __cdecl sub_811B3EA(int a1, char *s2)
{
  int result; // eax
  unsigned __int8 v3; // [esp+4h] [ebp-4h]

  if ( *s2 )
  {
    v3 = G_ModelIndex(s2);
    result = v3;
    *(_BYTE *)(a1 + 356) = v3;
  }
  else
  {
    result = a1;
    *(_BYTE *)(a1 + 356) = 0;
  }
  return result;
}

//----- (0811B422) --------------------------------------------------------
int __cdecl G_OverrideModel(int a1, char *s1)
{
  int v3; // [esp+10h] [ebp-8h]
  const char *v4; // [esp+14h] [ebp-4h]

  v4 = G_ModelName(a1);
  v3 = SV_XModelGet(s1);
  dword_87A1EA0[a1] = v3;
  return Hunk_OverrideDataForFile(4, (char *)v4 + 7, v3);
}
// 87A1EA0: using guessed type int dword_87A1EA0[256];

//----- (0811B470) --------------------------------------------------------
int __usercall sub_811B470@<eax>(long double a1@<st0>, int a2, char *s2, int a4, int a5)
{
  int i; // [esp+10h] [ebp-8h]

  for ( i = 0; ; ++i )
  {
    if ( i > 6 )
      return 0;
    if ( !*(_BYTE *)(i + a2 + 528) )
      break;
  }
  *(_BYTE *)(i + a2 + 528) = G_ModelIndex(s2);
  Scr_SetString((_WORD *)(a2 + 2 * i + 536), a4);
  if ( a5 )
    *(_BYTE *)(a2 + 357) |= 1 << i;
  sub_811B20E(a1, a2);
  return 1;
}

//----- (0811B528) --------------------------------------------------------
int __usercall sub_811B528@<eax>(long double a1@<st0>, int a2, char *s2, int a4)
{
  const char *v4; // eax
  char v5; // al
  int i; // [esp+10h] [ebp-8h]

  for ( i = 0; ; ++i )
  {
    if ( i > 6 )
      return 0;
    if ( *(unsigned __int16 *)(a2 + 2 * i + 536) == a4 )
    {
      v4 = G_ModelName(*(unsigned __int8 *)(i + a2 + 528));
      if ( !strcasecmp(v4, s2) )
        break;
    }
  }
  *(_BYTE *)(i + a2 + 528) = 0;
  Scr_SetString((_WORD *)(a2 + 2 * i + 536), 0);
  while ( i <= 5 )
  {
    *(_BYTE *)(i + a2 + 528) = *(_BYTE *)(i + a2 + 529);
    *(_WORD *)(a2 + 2 * i + 536) = *(_WORD *)(a2 + 2 * i + 538);
    if ( (((int)*(unsigned __int8 *)(a2 + 357) >> (i + 1)) & 1) != 0 )
      v5 = *(_BYTE *)(a2 + 357) | (1 << i);
    else
      v5 = *(_BYTE *)(a2 + 357) & ~(unsigned __int8)(1 << i);
    *(_BYTE *)(a2 + 357) = v5;
    ++i;
  }
  *(_BYTE *)(i + a2 + 528) = 0;
  *(_WORD *)(a2 + 2 * i + 536) = 0;
  *(_BYTE *)(a2 + 357) &= ~(unsigned __int8)(1 << i);
  sub_811B20E(a1, a2);
  return 1;
}

//----- (0811B6C2) --------------------------------------------------------
_DWORD *__usercall sub_811B6C2@<eax>(long double a1@<st0>, int a2)
{
  int i; // [esp+14h] [ebp-4h]

  for ( i = 0; i <= 6; ++i )
  {
    *(_BYTE *)(i + a2 + 528) = 0;
    Scr_SetString((_WORD *)(a2 + 2 * i + 536), 0);
  }
  *(_BYTE *)(a2 + 357) = 0;
  return sub_811B20E(a1, a2);
}

//----- (0811B720) --------------------------------------------------------
int __usercall sub_811B720@<eax>(long double a1@<st0>, int *a2, int *a3, int a4)
{
  int v6; // [esp+1Ch] [ebp-Ch]
  int *i; // [esp+20h] [ebp-8h]
  int v8; // [esp+24h] [ebp-4h]

  G_EntUnlink(a1, a2);
  if ( a4 )
  {
    if ( !SV_DObjExists(a3) )
      return 0;
    v6 = sub_8090898(a3, a4);
    if ( v6 < 0 )
      return 0;
  }
  else
  {
    v6 = -1;
  }
  for ( i = a3; ; i = *(int **)i[130] )
  {
    if ( i == a2 )
      return 0;
    if ( !i[130] )
      break;
  }
  v8 = sub_8076A2A(112);
  *(_DWORD *)v8 = a3;
  *(_WORD *)(v8 + 8) = 0;
  Scr_SetString((_WORD *)(v8 + 8), a4);
  *(_DWORD *)(v8 + 4) = a3[131];
  *(_DWORD *)(v8 + 12) = v6;
  memset((void *)(v8 + 16), 0, 0x30u);
  a3[131] = (int)a2;
  a2[130] = v8;
  memset((void *)(v8 + 64), 0, 0x30u);
  return 1;
}

//----- (0811B86E) --------------------------------------------------------
int __usercall sub_811B86E@<eax>(long double a1@<st0>, int *a2, int *a3, int a4)
{
  if ( !sub_811B720(a1, a2, a3, a4) )
    return 0;
  sub_811BC88((int)a2, 0);
  return 1;
}

//----- (0811B8BA) --------------------------------------------------------
int __usercall sub_811B8BA@<eax>(long double a1@<st0>, int *a2, int *a3, int a4, _DWORD *a5, float *a6)
{
  int v8; // [esp+14h] [ebp-4h]

  if ( !sub_811B720(a1, a2, a3, a4) )
    return 0;
  v8 = a2[130];
  sub_80A7146(a6, v8 + 16);
  sub_811D0FC(a5, (_DWORD *)(v8 + 52));
  return 1;
}

//----- (0811B928) --------------------------------------------------------
int __usercall G_EntUnlink@<eax>(long double a1@<st0>, _DWORD *a2)
{
  int result; // eax
  _DWORD v3[4]; // [esp+10h] [ebp-28h] BYREF
  _DWORD *v4; // [esp+20h] [ebp-18h]
  _DWORD *i; // [esp+24h] [ebp-14h]
  int v6; // [esp+28h] [ebp-10h]
  int v7; // [esp+2Ch] [ebp-Ch]

  result = a2[130];
  v7 = result;
  if ( result )
  {
    sub_811CF36(a2, a2 + 78);
    sub_811CF96(a2, a2 + 81);
    if ( a2[86] )
    {
      sub_811D0FC((_DWORD *)(a2[86] + 232), v3);
      v3[2] = 0;
      sub_80F5E80(a1, (int)a2, v3);
    }
    v6 = *(_DWORD *)v7;
    v4 = 0;
    for ( i = *(_DWORD **)(v6 + 524); i != a2; i = *(_DWORD **)(i[130] + 4) )
      v4 = i;
    if ( v4 )
      *(_DWORD *)(v4[130] + 4) = *(_DWORD *)(v7 + 4);
    else
      *(_DWORD *)(v6 + 524) = *(_DWORD *)(v7 + 4);
    a2[130] = 0;
    Scr_SetString((_WORD *)(v7 + 8), 0);
    return sub_8076A50(v7, 112);
  }
  return result;
}

//----- (0811BA8A) --------------------------------------------------------
int __usercall sub_811BA8A@<eax>(long double a1@<st0>, _DWORD *a2, int a3)
{
  int result; // eax
  int v4; // [esp+10h] [ebp-8h]

  v4 = a2[130];
  if ( *(_WORD *)(v4 + 8) )
  {
    if ( !a3 )
      return G_EntUnlink(a1, a2);
    *(_DWORD *)(v4 + 12) = sub_8090898(*(int **)v4, *(unsigned __int16 *)(v4 + 8));
    result = v4;
    if ( *(int *)(v4 + 12) < 0 )
      return G_EntUnlink(a1, a2);
  }
  else
  {
    result = a2[130];
    *(_DWORD *)(v4 + 12) = -1;
  }
  return result;
}

//----- (0811BAF4) --------------------------------------------------------
_DWORD *__usercall sub_811BAF4@<eax>(long double a1@<st0>, int a2, int a3)
{
  _DWORD *result; // eax
  _DWORD *v4; // [esp+10h] [ebp-8h]
  _DWORD *i; // [esp+14h] [ebp-4h]

  result = *(_DWORD **)(a2 + 524);
  for ( i = result; i; i = v4 )
  {
    v4 = *(_DWORD **)(i[130] + 4);
    sub_811BA8A(a1, i, a3);
    result = v4;
  }
  return result;
}

//----- (0811BB3A) --------------------------------------------------------
float *__cdecl sub_811BB3A(int a1, int a2)
{
  int v2; // eax
  float *v4; // [esp+1Ch] [ebp-7Ch]
  float v5[12]; // [esp+20h] [ebp-78h] BYREF
  float v6[9]; // [esp+50h] [ebp-48h] BYREF
  int v7[5]; // [esp+74h] [ebp-24h] BYREF
  float *v8; // [esp+88h] [ebp-10h]
  int v9; // [esp+8Ch] [ebp-Ch]

  v9 = *(_DWORD *)(a1 + 520);
  v8 = *(float **)v9;
  if ( *(int *)(v9 + 12) < 0 )
  {
    sub_80A7146(v8 + 81, a2);
    return (float *)sub_811D0FC((_DWORD *)v8 + 78, (_DWORD *)(a2 + 36));
  }
  else
  {
    sub_80A7146(v8 + 81, (int)v6);
    sub_811D0FC((_DWORD *)v8 + 78, v7);
    sub_811BFC4((int)v8, *(_DWORD *)(v9 + 12));
    v2 = sub_80908D8((int *)v8);
    v4 = (float *)(32 * *(_DWORD *)(v9 + 12) + v2);
    sub_80A913C(v4, v5);
    sub_80A358E(v5, v6, (float *)a2);
    return sub_80A50D2(v4 + 4, v6, (float *)(a2 + 36));
  }
}
// 811BB3A: using guessed type float var_48[9];
// 811BB3A: using guessed type float var_78[12];
// 811BB3A: using guessed type int anonymous_0[5];

//----- (0811BC46) --------------------------------------------------------
float *__cdecl sub_811BC46(int a1, float *a2)
{
  int v3; // [esp+1Ch] [ebp-3Ch]
  float v4[14]; // [esp+20h] [ebp-38h] BYREF

  v3 = *(_DWORD *)(a1 + 520);
  sub_811BB3A(a1, (int)v4);
  return sub_80A3C8E((float *)(v3 + 64), v4, a2);
}
// 811BC46: using guessed type float var_38[14];

//----- (0811BC88) --------------------------------------------------------
float *__cdecl sub_811BC88(int a1, int a2)
{
  float v3[12]; // [esp+10h] [ebp-A8h] BYREF
  _DWORD v4[12]; // [esp+40h] [ebp-78h] BYREF
  float v5[9]; // [esp+70h] [ebp-48h] BYREF
  int v6[6]; // [esp+94h] [ebp-24h] BYREF
  int v7; // [esp+ACh] [ebp-Ch]

  sub_811BB3A(a1, (int)v4);
  sub_80A7146((float *)(a1 + 324), (int)v5);
  v7 = *(_DWORD *)(a1 + 520);
  if ( a2 )
  {
    sub_80A442E(v4, v3);
    return sub_80A358E(v5, v3, (float *)(v7 + 16));
  }
  else
  {
    sub_80A47DE((int)v4, (int)v3);
    sub_811D0FC((_DWORD *)(a1 + 312), v6);
    return sub_80A3C8E(v5, v3, (float *)(v7 + 16));
  }
}
// 811BC88: using guessed type _DWORD var_78[12];
// 811BC88: using guessed type float var_48[9];
// 811BC88: using guessed type float var_A8[12];
// 811BC88: using guessed type int anonymous_0[6];

//----- (0811BD52) --------------------------------------------------------
void __cdecl sub_811BD52(int a1, int a2)
{
  float v2[12]; // [esp+20h] [ebp-78h] BYREF
  float v3[9]; // [esp+50h] [ebp-48h] BYREF
  float v4[6]; // [esp+74h] [ebp-24h] BYREF
  int v5; // [esp+8Ch] [ebp-Ch]

  sub_811BB3A(a1, (int)v2);
  v5 = *(_DWORD *)(a1 + 520);
  if ( a2 == 1 )
  {
    sub_80A3C8E((float *)(v5 + 16), v2, v3);
    sub_811D0FC(v4, (_DWORD *)(a1 + 312));
    *(float *)(a1 + 328) = sub_80A29F6(v3);
  }
  else if ( a2 > 1 )
  {
    if ( a2 == 2 )
    {
      sub_80A50D2((float *)(v5 + 52), v2, v4);
      sub_811D0FC(v4, (_DWORD *)(a1 + 312));
    }
  }
  else if ( !a2 )
  {
    sub_80A3C8E((float *)(v5 + 16), v2, v3);
    sub_811D0FC(v4, (_DWORD *)(a1 + 312));
    sub_80A71F4((int)v3, a1 + 324);
  }
}
// 811BD52: using guessed type float var_78[12];
// 811BD52: using guessed type float var_48[9];

//----- (0811BE86) --------------------------------------------------------
int __cdecl sub_811BE86(_DWORD *a1)
{
  sub_811BD52((int)a1, 0);
  sub_811CF36(a1, a1 + 78);
  sub_811CF96(a1, a1 + 81);
  a1[3] = 1;
  a1[12] = 1;
  return SV_LinkEntity((int)a1);
}

//----- (0811BEEE) --------------------------------------------------------
int __cdecl sub_811BEEE(int *a1)
{
  return Com_SafeServerDObjFree(*a1);
}

//----- (0811BF04) --------------------------------------------------------
int __cdecl sub_811BF04(int *a1, int a2)
{
  float v3; // [esp+4h] [ebp-14h]

  v3 = (long double)dword_859B5F4 * 0.001;
  return sub_8090776(a1, v3, a2);
}
// 859B5F4: using guessed type int dword_859B5F4;

//----- (0811BF30) --------------------------------------------------------
int *__cdecl sub_811BF30(int a1)
{
  int *result; // eax
  char s[28]; // [esp+10h] [ebp-28h] BYREF
  void (__cdecl *v3)(int, char *); // [esp+2Ch] [ebp-Ch]

  memset(s, 255, 0x10u);
  result = (int *)sub_80906EE((int *)a1, (int)s);
  if ( !result )
  {
    sub_8090820((int *)a1, (int)s);
    v3 = (void (__cdecl *)(int, char *))dword_816789C[10 * *(unsigned __int8 *)(a1 + 358)];
    if ( v3 )
      v3(a1, s);
    return sub_809084A((int *)a1, (int)s);
  }
  return result;
}
// 816789C: using guessed type int dword_816789C[];

//----- (0811BFC4) --------------------------------------------------------
int *__cdecl sub_811BFC4(int a1, int a2)
{
  int *result; // eax
  char v3[28]; // [esp+10h] [ebp-28h] BYREF
  void (__cdecl *v4)(int, char *); // [esp+2Ch] [ebp-Ch]

  result = (int *)sub_8090666((int *)a1, a2);
  if ( !result )
  {
    sub_80907EE((int *)a1, a2, (int)v3);
    sub_8090820((int *)a1, (int)v3);
    v4 = (void (__cdecl *)(int, char *))dword_816789C[10 * *(unsigned __int8 *)(a1 + 358)];
    if ( v4 )
      v4(a1, v3);
    return sub_809084A((int *)a1, (int)v3);
  }
  return result;
}
// 816789C: using guessed type int dword_816789C[];

//----- (0811C056) --------------------------------------------------------
int __cdecl sub_811C056(int *a1, int a2)
{
  int v4; // [esp+10h] [ebp-8h]

  v4 = sub_8090898(a1, a2);
  if ( v4 < 0 )
    return 0;
  sub_811BFC4((int)a1, v4);
  return sub_80908D8(a1) + 32 * v4;
}

//----- (0811C0B2) --------------------------------------------------------
int __cdecl sub_811C0B2(int a1, int a2, float *a3)
{
  float v5[12]; // [esp+20h] [ebp-78h] BYREF
  float v6[9]; // [esp+50h] [ebp-48h] BYREF
  int v7[6]; // [esp+74h] [ebp-24h] BYREF
  float *v8; // [esp+8Ch] [ebp-Ch]

  v8 = (float *)sub_811C056((int *)a1, a2);
  if ( !v8 )
    return 0;
  sub_80A7146((float *)(a1 + 324), (int)v6);
  sub_811D0FC((_DWORD *)(a1 + 312), v7);
  sub_80A913C(v8, v5);
  sub_80A358E(v5, v6, a3);
  sub_80A50D2(v8 + 4, v6, a3 + 9);
  return 1;
}
// 811C0B2: using guessed type float var_48[9];
// 811C0B2: using guessed type float var_78[12];
// 811C0B2: using guessed type int anonymous_0[6];

//----- (0811C16A) --------------------------------------------------------
int __cdecl sub_811C16A(int a1, int a2, float *a3)
{
  float v5[9]; // [esp+20h] [ebp-48h] BYREF
  int v6[6]; // [esp+44h] [ebp-24h] BYREF
  int v7; // [esp+5Ch] [ebp-Ch]

  v7 = sub_811C056((int *)a1, a2);
  if ( !v7 )
    return 0;
  sub_80A7146((float *)(a1 + 324), (int)v5);
  sub_811D0FC((_DWORD *)(a1 + 312), v6);
  sub_80A50D2((float *)(v7 + 16), v5, a3);
  return 1;
}
// 811C16A: using guessed type float var_48[9];
// 811C16A: using guessed type int anonymous_0[6];

//----- (0811C1EE) --------------------------------------------------------
char *__cdecl sub_811C1EE(int a1, int a2, __int16 a3)
{
  __int16 v5; // [esp+4h] [ebp-4h]
  char *v6; // [esp+10h] [ebp+8h]

  if ( a1 )
    v6 = (char *)(a1 + 560);
  else
    v6 = (char *)&unk_8665480;
  while ( (unsigned int)v6 < 560 * *(_DWORD *)dword_859B40C + 140924032 )
  {
    if ( v6[252] )
    {
      v5 = *(_WORD *)&v6[a2];
      if ( v5 )
      {
        if ( v5 == a3 )
          return v6;
      }
    }
    v6 += 560;
  }
  return 0;
}

//----- (0811C272) --------------------------------------------------------
char *__cdecl sub_811C272(int a1, int a2, char *a3)
{
  char *v5; // [esp+14h] [ebp-4h]
  char *v6; // [esp+20h] [ebp+8h]

  if ( a1 )
    v6 = (char *)(a1 + 560);
  else
    v6 = (char *)&unk_8665480;
  while ( (unsigned int)v6 < 560 * *(_DWORD *)dword_859B40C + 140924032 )
  {
    if ( v6[252] )
    {
      v5 = *(char **)&v6[a2];
      if ( v5 )
      {
        if ( !I_stricmp(v5, a3) )
          return v6;
      }
    }
    v6 += 560;
  }
  return 0;
}

//----- (0811C2FA) --------------------------------------------------------
int __cdecl G_PickTarget(unsigned __int16 a1)
{
  const char *v1; // eax
  int v4[33]; // [esp+30h] [ebp-98h]
  int v5; // [esp+B4h] [ebp-14h]
  char *v6; // [esp+B8h] [ebp-10h]
  unsigned __int16 v7; // [esp+BEh] [ebp-Ah]

  v7 = a1;
  v6 = 0;
  v5 = 0;
  if ( !a1 )
    return 0;
  do
  {
    v6 = sub_811C1EE((int)v6, 364, v7);
    if ( !v6 )
      break;
    v4[v5++] = (int)v6;
  }
  while ( v5 != 32 );
  if ( v5 )
    return v4[rand() % v5];
  v1 = (const char *)SL_ConvertToString(v7);
  Com_Printf("G_PickTarget: target %s not found\n", v1);
  return 0;
}
// 811C2FA: using guessed type int var_98[33];

//----- (0811C3CC) --------------------------------------------------------
int __cdecl G_InitGentity(int a1)
{
  int result; // eax

  *(_DWORD *)(a1 + 556) = 0;
  *(_BYTE *)(a1 + 252) = 1;
  Scr_SetString((_WORD *)(a1 + 360), (unsigned __int16)word_87A22CA);
  *(_DWORD *)a1 = -1963413621 * ((a1 - (int)&unk_8665480) >> 4);
  *(_DWORD *)(a1 + 336) = 1023;
  *(_DWORD *)(a1 + 376) = 0;
  result = a1;
  *(_DWORD *)(a1 + 380) = 0;
  return result;
}
// 87A22CA: using guessed type __int16 word_87A22CA;

//----- (0811C444) --------------------------------------------------------
int G_PrintEntities()
{
  int result; // eax
  const char *v1; // [esp+30h] [ebp-8h]
  int i; // [esp+34h] [ebp-4h]

  for ( i = 0; ; ++i )
  {
    result = i;
    if ( i >= *(int *)dword_859B40C )
      break;
    if ( word_86655E8[280 * i] )
      v1 = (const char *)SL_ConvertToString((unsigned __int16)word_86655E8[280 * i]);
    else
      v1 = (const char *)&unk_8157C43;
    Com_Printf(
      "%4i: '%s', origin: %f %f %f\n",
      i,
      v1,
      flt_86655B8[140 * i],
      flt_86655BC[140 * i],
      flt_86655C0[140 * i]);
  }
  return result;
}
// 86655B8: using guessed type float flt_86655B8[];
// 86655BC: using guessed type float flt_86655BC[];
// 86655C0: using guessed type float flt_86655C0[];
// 86655E8: using guessed type __int16 word_86655E8[];

//----- (0811C4F8) --------------------------------------------------------
_BOOL4 __cdecl sub_811C4F8(int a1)
{
  return a1 && (dword_859B5EC - *(_DWORD *)(a1 + 376) > 499 || *(int *)dword_859B40C > 1021);
}

//----- (0811C546) --------------------------------------------------------
int G_Spawn()
{
  int v1; // [esp+14h] [ebp-4h]

  v1 = dword_859B410;
  if ( sub_811C4F8(dword_859B410) )
  {
    dword_859B410 = *(_DWORD *)(dword_859B410 + 556);
    if ( !dword_859B410 )
      dword_859B414 = 0;
    *(_DWORD *)(v1 + 556) = 0;
  }
  else
  {
    if ( *(_DWORD *)dword_859B40C == 1022 )
    {
      G_PrintEntities();
      Com_Error(1, (char *)&byte_8157C61);
    }
    v1 = dword_859B404 + 560 * (*(_DWORD *)dword_859B40C)++;
    sub_8090498(dword_859B404, *(int *)dword_859B40C, 560, dword_859B400, 10404);
  }
  G_InitGentity(v1);
  return v1;
}
// 859B400: using guessed type int dword_859B400;
// 859B404: using guessed type int dword_859B404;
// 859B410: using guessed type int dword_859B410;
// 859B414: using guessed type int dword_859B414;

//----- (0811C614) --------------------------------------------------------
int *__usercall sub_811C614@<eax>(long double a1@<st0>)
{
  int v2; // [esp+10h] [ebp-8h]
  int *s; // [esp+14h] [ebp-4h]

  s = (int *)(dword_859B404 + 560 * dword_859D1E4 + 35840);
  dword_859D1E4 = (dword_859D1E4 + 1) % 8;
  v2 = s[2] & 2 ^ 2;
  if ( *((_BYTE *)s + 252) )
    G_FreeEntity(a1, s);
  G_InitGentity((int)s);
  s[2] = v2;
  return s;
}
// 859B404: using guessed type int dword_859B404;
// 859D1E4: using guessed type int dword_859D1E4;

//----- (0811C6AE) --------------------------------------------------------
int *__cdecl sub_811C6AE(int *a1)
{
  int *result; // eax
  _DWORD *v2; // [esp+0h] [ebp-10h]
  int v3; // [esp+4h] [ebp-Ch]
  int i; // [esp+8h] [ebp-8h] BYREF
  int v5; // [esp+Ch] [ebp-4h]

  v3 = *a1;
  for ( i = 0; ; ++i )
  {
    result = (int *)i;
    if ( i >= *(int *)dword_859B40C )
      break;
    v5 = (int)&unk_8665480 + 560 * i;
    if ( *(_BYTE *)(v5 + 252) )
    {
      if ( *(int **)(v5 + 396) == a1 )
        *(_DWORD *)(v5 + 396) = 0;
      if ( *(_DWORD *)(v5 + 336) == v3 )
      {
        *(_DWORD *)(v5 + 336) = 1023;
        if ( *(_DWORD *)(v5 + 4) == 9 )
          *(_BYTE *)(v5 + 354) = 0;
      }
      if ( *(_DWORD *)(v5 + 124) == v3 )
        *(_DWORD *)(v5 + 124) = 1023;
    }
  }
  for ( i = 0; i <= 63; ++i )
  {
    v5 = (int)&unk_8665480 + 560 * i;
    if ( *(_BYTE *)(v5 + 252) )
    {
      v2 = *(_DWORD **)(v5 + 344);
      if ( (int *)v2[2571] == a1 )
        v2[2571] = 0;
      if ( v2[2572] == v3 )
        v2[2572] = 1023;
      if ( v2[360] == v3 )
        v2[360] = 1023;
    }
    result = &i;
  }
  for ( i = 0; i <= 31; ++i )
  {
    if ( (int *)dword_859D158[i] == a1 )
      dword_859D158[i] = 0;
    result = &i;
  }
  return result;
}
// 859D158: using guessed type int dword_859D158[32];

//----- (0811C830) --------------------------------------------------------
int __cdecl sub_811C830(_DWORD *a1)
{
  int i; // [esp+4h] [ebp-8h]

  for ( i = 0; i <= 7; ++i )
  {
    if ( dword_879D83C[306 * i] == *a1 )
      return i;
  }
  return 0;
}
// 879D83C: using guessed type int dword_879D83C[2449];

//----- (0811C87C) --------------------------------------------------------
int __usercall sub_811C87C@<eax>(long double a1@<st0>)
{
  int v3; // [esp+1Ch] [ebp-2Ch]
  float v4[4]; // [esp+20h] [ebp-28h] BYREF
  float v5; // [esp+30h] [ebp-18h]
  float v6; // [esp+34h] [ebp-14h]
  void *s; // [esp+38h] [ebp-10h]
  int i; // [esp+3Ch] [ebp-Ch]

  v5 = -1.0;
  v3 = 0;
  s = sub_811C1EE(0, 360, word_87A22D2);
  sub_811D0FC((_DWORD *)s + 6, v4);
  for ( i = 0; i <= 7; ++i )
  {
    if ( dword_879D83C[306 * i] == -1 )
      return i;
    s = (void *)(dword_859B404 + 560 * dword_879D83C[306 * i]);
    v6 = sub_80A1DB2((float *)s + 78, v4);
    a1 = v5;
    if ( v6 > (long double)v5 )
    {
      v5 = v6;
      v3 = i;
    }
  }
  s = (void *)(dword_859B404 + 560 * dword_879D83C[306 * v3]);
  G_FreeEntity(a1, (int *)s);
  dword_879D83C[306 * v3] = -1;
  return v3;
}
// 859B404: using guessed type int dword_859B404;
// 879D83C: using guessed type int dword_879D83C[2449];
// 87A22D2: using guessed type __int16 word_87A22D2;
// 811C87C: using guessed type float var_28[4];

//----- (0811C996) --------------------------------------------------------
int __cdecl sub_811C996(_DWORD *a1)
{
  int result; // eax

  result = 306 * sub_811C830(a1);
  dword_879D83C[result] = -1;
  return result * 4;
}
// 879D83C: using guessed type int dword_879D83C[2449];

//----- (0811C9C0) --------------------------------------------------------
int __usercall G_FreeEntity@<eax>(long double a1@<st0>, int *s)
{
  int result; // eax
  _DWORD *v3; // [esp+10h] [ebp-8h]
  _DWORD *v4; // [esp+14h] [ebp-4h]

  G_EntUnlink(a1, s);
  while ( s[131] )
    G_EntUnlink(a1, (_DWORD *)s[131]);
  SV_UnlinkEntity((int)s);
  v3 = (_DWORD *)sub_80909B0(s);
  if ( v3 )
    sub_80BFA1E(v3);
  Com_SafeServerDObjFree(*s);
  sub_811C6AE(s);
  if ( s[87] )
    sub_8109E54((int)s);
  if ( s[1] == 2 )
    sub_811C996(s);
  sub_8118C98(s);
  v4 = (_DWORD *)s[138];
  memset(s, 0, 0x230u);
  s[94] = dword_859B5EC;
  if ( -1963413621 * (((int)s - dword_859B404) >> 4) > 71 )
  {
    if ( dword_859B414 )
      *(_DWORD *)(dword_859B414 + 556) = s;
    else
      dword_859B410 = (int)s;
    dword_859B414 = (int)s;
    s[139] = 0;
  }
  result = (int)v4 + 1;
  s[138] = (int)v4 + 1;
  return result;
}
// 859B404: using guessed type int dword_859B404;
// 859B410: using guessed type int dword_859B410;
// 859B414: using guessed type int dword_859B414;

//----- (0811CB00) --------------------------------------------------------
int __cdecl sub_811CB00(int *a1)
{
  unsigned __int16 v2; // [esp+16h] [ebp-2h]

  v2 = Scr_ExecEntThread(a1, dword_879D82C, 0);
  return Scr_FreeThread(v2);
}
// 879D82C: using guessed type int dword_879D82C;

//----- (0811CB34) --------------------------------------------------------
_DWORD *__cdecl G_TempEntity(_DWORD *a1, int a2)
{
  float v3; // [esp+20h] [ebp-28h] BYREF
  float v4; // [esp+24h] [ebp-24h]
  float v5; // [esp+28h] [ebp-20h]
  _DWORD *v6; // [esp+3Ch] [ebp-Ch]

  v6 = (_DWORD *)G_Spawn();
  v6[1] = a2 + 10;
  Scr_SetString((_WORD *)v6 + 180, (unsigned __int16)word_87A22F0);
  v6[94] = dword_859B5EC;
  v6[85] = dword_859B5EC;
  v6[95] = 1;
  sub_811D0FC(a1, &v3);
  v3 = (float)(int)v3;
  v4 = (float)(int)v4;
  v5 = (float)(int)v5;
  sub_811CF36(v6, &v3);
  SV_LinkEntity((int)v6);
  return v6;
}
// 87A22F0: using guessed type __int16 word_87A22F0;

//----- (0811CC24) --------------------------------------------------------
int __cdecl sub_811CC24(int a1)
{
  int result; // eax
  float v2[4]; // [esp+30h] [ebp-1048h] BYREF
  float v3[7]; // [esp+40h] [ebp-1038h] BYREF
  int *v4; // [esp+5Ch] [ebp-101Ch]
  int v5[1026]; // [esp+60h] [ebp-1018h] BYREF
  int v6; // [esp+1068h] [ebp-10h]
  int i; // [esp+106Ch] [ebp-Ch]

  sub_811D12C((float *)(*(_DWORD *)(a1 + 344) + 20), (float *)(a1 + 260), v3);
  sub_811D12C((float *)(*(_DWORD *)(a1 + 344) + 20), (float *)(a1 + 272), v2);
  v6 = sub_805E782((int)v3, (int)v2, (int)v5, 1024, 0x2000000);
  for ( i = 0; ; ++i )
  {
    result = i;
    if ( i >= v6 )
      break;
    v4 = (int *)((char *)&unk_8665480 + 560 * v5[i]);
    if ( v4[86] )
    {
      if ( *((_BYTE *)v4 + 240) )
        sub_80FF7C8(v4, (int *)a1, (int *)a1, 0, 0, 100000, 16, 0xAu, 0, 0);
    }
  }
  return result;
}
// 811CC24: using guessed type float var_1038[7];
// 811CC24: using guessed type float var_1048[4];
// 811CC24: using guessed type int var_1018[1026];

//----- (0811CD6C) --------------------------------------------------------
int __cdecl G_AddPredictableEvent(int a1, int a2, unsigned __int8 a3)
{
  int result; // eax

  result = a1;
  if ( *(_DWORD *)(a1 + 344) )
    return BG_AddPredictableEventToPlayerstate(a2, a3, *(_DWORD *)(a1 + 344));
  return result;
}

//----- (0811CDA2) --------------------------------------------------------
int __cdecl G_AddEvent(_DWORD *a1, int a2, int a3)
{
  int result; // eax

  if ( a1[86] )
  {
    *(_DWORD *)(a1[86] + 4 * (*(_DWORD *)(a1[86] + 164) & 3) + 168) = a2;
    *(_DWORD *)(a1[86] + 4 * ((*(_DWORD *)(a1[86] + 164))++ & 3) + 184) = a3;
  }
  else
  {
    a1[(a1[41] & 3) + 42] = a2;
    a1[(a1[41]++ & 3) + 46] = a3;
  }
  a1[94] = dword_859B5EC;
  result = dword_859B5EC;
  a1[85] = dword_859B5EC;
  return result;
}

//----- (0811CE66) --------------------------------------------------------
int __cdecl sub_811CE66(_DWORD *a1, int a2)
{
  int result; // eax
  _DWORD *v3; // edx

  result = a2;
  if ( (_BYTE)a2 )
  {
    v3 = G_TempEntity(a1, 179);
    result = (unsigned __int8)a2;
    v3[40] = (unsigned __int8)a2;
  }
  return result;
}

//----- (0811CE9E) --------------------------------------------------------
int __cdecl sub_811CE9E(_DWORD *a1, int a2)
{
  int result; // eax

  result = a2;
  if ( (_BYTE)a2 )
    return G_AddEvent(a1, 179, (unsigned __int8)a2);
  return result;
}

//----- (0811CEFE) --------------------------------------------------------
int __cdecl sub_811CEFE(int a1, char **a2)
{
  unsigned __int8 v2; // al

  v2 = sub_811B1D8(*a2);
  sub_811CE9E((_DWORD *)(560 * a1 + 140924032), v2);
  return 0;
}

//----- (0811CF36) --------------------------------------------------------
int __cdecl sub_811CF36(_DWORD *a1, _DWORD *a2)
{
  sub_811D0FC(a2, a1 + 6);
  a1[3] = 0;
  a1[4] = 0;
  a1[5] = 0;
  sub_811D0D2(a1 + 9);
  return sub_811D0FC(a2, a1 + 78);
}

//----- (0811CF96) --------------------------------------------------------
int __cdecl sub_811CF96(_DWORD *a1, _DWORD *a2)
{
  sub_811D0FC(a2, a1 + 15);
  a1[12] = 0;
  a1[13] = 0;
  a1[14] = 0;
  sub_811D0D2(a1 + 18);
  return sub_811D0FC(a2, a1 + 81);
}

//----- (0811CFF6) --------------------------------------------------------
_BOOL4 __cdecl sub_811CFF6(int a1, int a2)
{
  float v3[7]; // [esp+20h] [ebp-38h] BYREF
  float v4; // [esp+3Ch] [ebp-1Ch]
  float v5[6]; // [esp+40h] [ebp-18h] BYREF

  AngleVectors((float *)(a1 + 324), (int)v3, 0, 0);
  sub_811D170((float *)(a2 + 312), (float *)(a1 + 312), v5);
  Vec3Normalize(v5);
  v4 = sub_811D1B4(v5, v3);
  return v4 > 0.0;
}
// 811CFF6: using guessed type float var_38[7];
// 811CFF6: using guessed type float var_18[6];

//----- (0811D098) --------------------------------------------------------
int __cdecl sub_811D098(_WORD *a1, char *s)
{
  int result; // eax

  Scr_SetString(a1, 0);
  result = sub_80792C4(s, 0);
  *a1 = result;
  return result;
}

//----- (0811D0D2) --------------------------------------------------------
int __cdecl sub_811D0D2(_DWORD *a1)
{
  int result; // eax

  *a1 = 0;
  a1[1] = 0;
  result = 0;
  a1[2] = 0;
  return result;
}

//----- (0811D0FC) --------------------------------------------------------
int __cdecl sub_811D0FC(_DWORD *a1, _DWORD *a2)
{
  int result; // eax

  *a2 = *a1;
  a2[1] = a1[1];
  result = a1[2];
  a2[2] = result;
  return result;
}

//----- (0811D12C) --------------------------------------------------------
float *__cdecl sub_811D12C(float *a1, float *a2, float *a3)
{
  float *result; // eax

  *a3 = *a1 + *a2;
  a3[1] = a1[1] + a2[1];
  result = a1 + 2;
  a3[2] = a1[2] + a2[2];
  return result;
}

//----- (0811D170) --------------------------------------------------------
float *__cdecl sub_811D170(float *a1, float *a2, float *a3)
{
  float *result; // eax

  *a3 = *a1 - *a2;
  a3[1] = a1[1] - a2[1];
  result = a1 + 2;
  a3[2] = a1[2] - a2[2];
  return result;
}

//----- (0811D1B4) --------------------------------------------------------
long double __cdecl sub_811D1B4(float *a1, float *a2)
{
  return *a1 * *a2 + a1[1] * a2[1] + a1[2] * a2[2];
}

//----- (0811D220) --------------------------------------------------------
int __cdecl sub_811D220(int *a1, float *a2, int a3, float a4, float a5, float a6, float *s, float *a8)
{
  float v9; // [esp+4h] [ebp-44h]
  float v10; // [esp+4h] [ebp-44h]
  int v11; // [esp+20h] [ebp-28h]
  int i; // [esp+2Ch] [ebp-1Ch]
  int v14[6]; // [esp+30h] [ebp-18h] BYREF

  if ( a5 > 0.0 || a6 > 0.0 )
    v11 = 5;
  else
    v11 = 1;
  for ( i = 0; i < v11; ++i )
  {
    sub_811EADE(a2 + 9, a4, a2, (float *)v14);
    v9 = a5 * flt_8157C80[2 * i];
    sub_811EADE((float *)v14, v9, a2 + 3, (float *)v14);
    v10 = a6 * flt_8157C84[2 * i];
    sub_811EADE((float *)v14, v10, a2 + 6, (float *)v14);
    G_LocationalTrace(s, a2 + 9, (float *)v14, *a1, 41953329, (int)&unk_816778C);
    sub_80DEB7A(a2 + 9, (float *)v14, *s, a8);
    if ( !i )
      sub_811AA18(a1, (_DWORD *)a2 + 9, a8, a3, 7);
    if ( ((_DWORD)s[4] & 0x10) == 0 && *s != 1.0 )
      return 1;
  }
  return 0;
}
// 8157C80: using guessed type float flt_8157C80[];
// 8157C84: using guessed type float flt_8157C84[9];

//----- (0811D3B4) --------------------------------------------------------
__int16 __cdecl sub_811D3B4(int *a1, float *a2, float a3, float a4, float a5)
{
  int v5; // eax
  _DWORD *v6; // ebx
  int v7; // eax
  int v9[5]; // [esp+30h] [ebp-58h] BYREF
  int v10; // [esp+44h] [ebp-44h]
  _DWORD *v11; // [esp+48h] [ebp-40h]
  int *v12; // [esp+4Ch] [ebp-3Ch]
  float s; // [esp+50h] [ebp-38h] BYREF
  float v14; // [esp+54h] [ebp-34h] BYREF
  unsigned __int16 v15; // [esp+6Ch] [ebp-1Ch]
  unsigned __int16 v16; // [esp+70h] [ebp-18h]

  v10 = *(_DWORD *)(BG_WeaponDefs(a1[50]) + 500);
  LOWORD(v5) = sub_811D220(a1, a2, v10, a3, a4, a5, &s, (float *)v9);
  if ( (_BYTE)v5 )
  {
    v12 = (int *)((char *)&unk_8665480 + 560 * v15);
    if ( v12[86] )
      v11 = G_TempEntity(v9, 173);
    else
      v11 = G_TempEntity(v9, 174);
    v11[29] = v15;
    v6 = v11;
    v6[40] = (unsigned __int8)DirToByte(&v14);
    v5 = a1[50];
    v11[50] = v5;
    if ( v15 != 1022 )
    {
      LOWORD(v5) = (_WORD)v12;
      if ( *((_BYTE *)v12 + 353) )
      {
        v7 = rand();
        LOWORD(v5) = sub_80FF7C8(v12, a1, a1, a2, v9, v10 + v7 % 5, 0, 7u, v16, 0);
      }
    }
  }
  return v5;
}
// 811D3B4: using guessed type float s;

//----- (0811D53A) --------------------------------------------------------
int *__cdecl sub_811D53A(int a1, int a2)
{
  int v2; // ebx
  int *result; // eax
  int i; // [esp+Ch] [ebp-Ch] BYREF

  for ( i = 0; i <= 2; ++i )
  {
    v2 = 4 * i;
    if ( *(float *)(a1 + 4 * i) < (long double)*(float *)(a2 + 4 * i) )
      *(float *)(a1 + v2) = ceil(*(float *)(a1 + 4 * i));
    else
      *(float *)(a1 + v2) = floor(*(float *)(a1 + 4 * i));
    result = &i;
  }
  return result;
}

//----- (0811D5E0) --------------------------------------------------------
float *__cdecl sub_811D5E0(float *a1, float *a2)
{
  float *result; // eax
  float v3; // [esp+0h] [ebp-28h]
  int v4; // [esp+18h] [ebp-10h] BYREF
  int v5; // [esp+1Ch] [ebp-Ch] BYREF
  float v6; // [esp+20h] [ebp-8h]
  float v7; // [esp+24h] [ebp-4h]

  v7 = sub_80A1410() * 360.0;
  v6 = sub_80A1410();
  v3 = v7 * 0.0174532925199433;
  sub_811EA04(v3, (float *)&v5, (float *)&v4);
  *a1 = v6 * *(float *)&v4;
  result = a2;
  *a2 = v6 * *(float *)&v5;
  return result;
}

//----- (0811D638) --------------------------------------------------------
float *__cdecl sub_811D638(float a1, float *a2, float *a3, float a4)
{
  float v5; // [esp+18h] [ebp-10h]
  float v6; // [esp+1Ch] [ebp-Ch]
  float v7; // [esp+20h] [ebp-8h] BYREF
  float v8; // [esp+24h] [ebp-4h] BYREF

  v5 = tan(a1 * 0.0174532925199433);
  v6 = v5 * a4;
  sub_811D5E0(&v8, &v7);
  v8 = v8 * v6;
  v7 = v7 * v6;
  sub_811EADE(a3 + 9, a4, a3, a2);
  sub_811EADE(a2, v8, a3 + 3, a2);
  return sub_811EADE(a2, v7, a3 + 6, a2);
}

//----- (0811D6EC) --------------------------------------------------------
int __cdecl sub_811D6EC(int a1, float a2)
{
  float v3; // [esp+0h] [ebp-28h]
  float v4; // [esp+4h] [ebp-24h]
  float v5; // [esp+1Ch] [ebp-Ch]
  float v6; // [esp+20h] [ebp-8h]

  if ( *(float *)(*(_DWORD *)(a1 + 60) + 1432) > (long double)a2 )
    return *(_DWORD *)(*(_DWORD *)(a1 + 60) + 492);
  if ( *(float *)(*(_DWORD *)(a1 + 60) + 1436) <= (long double)a2 )
    return *(_DWORD *)(*(_DWORD *)(a1 + 60) + 1424);
  v6 = *(float *)(*(_DWORD *)(a1 + 60) + 1436) - *(float *)(*(_DWORD *)(a1 + 60) + 1432);
  if ( v6 == 0.0 )
    return *(_DWORD *)(*(_DWORD *)(a1 + 60) + 492);
  v5 = (a2 - *(float *)(*(_DWORD *)(a1 + 60) + 1432)) / v6;
  v4 = (float)*(int *)(*(_DWORD *)(a1 + 60) + 1424);
  v3 = (float)*(int *)(*(_DWORD *)(a1 + 60) + 492);
  return (int)sub_811E9EE(v3, v4, v5);
}

//----- (0811D7E6) --------------------------------------------------------
int __cdecl sub_811D7E6(int a1, char *s)
{
  int result; // eax
  char src[24]; // [esp+20h] [ebp-28h] BYREF
  int v4; // [esp+38h] [ebp-10h]
  int i; // [esp+3Ch] [ebp-Ch]

  result = g_antilag;
  if ( *(_BYTE *)(g_antilag + 8) )
  {
    memset(s, 0, 0x340u);
    result = 1000 / *(_DWORD *)(sv_fps + 8);
    if ( dword_859B5EC - a1 > result )
    {
      for ( i = 0; ; ++i )
      {
        result = i;
        if ( i >= dword_859B5E4 )
          break;
        if ( *(_DWORD *)(dword_859B400 + 10404 * i + 9924) == 2 && !*(_DWORD *)(dword_859B400 + 10404 * i + 9896) )
        {
          if ( (unsigned __int8)sub_8097BD0(i, a1, (int)src) )
          {
            v4 = a1;
            memcpy(&s[12 * i], (const void *)(560 * i + 140924344), 0xCu);
            SV_UnlinkEntity(560 * i + 140924032);
            memcpy((void *)(560 * i + 140924344), src, 0xCu);
            SV_LinkEntity(560 * i + 140924032);
            s[i + 768] = 1;
          }
        }
      }
    }
  }
  return result;
}
// 848B1B4: using guessed type int sv_fps;
// 859B400: using guessed type int dword_859B400;
// 859B5E4: using guessed type int dword_859B5E4;
// 8793E4C: using guessed type int g_antilag;

//----- (0811D95C) --------------------------------------------------------
int __cdecl sub_811D95C(int a1)
{
  int result; // eax
  int i; // [esp+14h] [ebp-4h]

  result = g_antilag;
  if ( *(_BYTE *)(g_antilag + 8) )
  {
    for ( i = 0; ; ++i )
    {
      result = i;
      if ( i >= dword_859B5E4 )
        break;
      if ( *(_BYTE *)(i + a1 + 768) )
      {
        SV_UnlinkEntity(560 * i + 140924032);
        memcpy((void *)(560 * i + 140924344), (const void *)(a1 + 12 * i), 0xCu);
        SV_LinkEntity(560 * i + 140924032);
      }
    }
  }
  return result;
}
// 859B5E4: using guessed type int dword_859B5E4;
// 8793E4C: using guessed type int g_antilag;

//----- (0811DA00) --------------------------------------------------------
void __cdecl sub_811DA00(int *a1, int *a2, float *a3, float *a4, float a5, int a6, int a7, _DWORD *a8, int a9)
{
  long double v9; // fst7
  _DWORD *v10; // eax
  int v11; // ebx
  float v12; // [esp+10h] [ebp-F8h]
  float v13; // [esp+3Ch] [ebp-CCh]
  float v14; // [esp+4Ch] [ebp-BCh]
  int v15; // [esp+50h] [ebp-B8h]
  float v16; // [esp+6Ch] [ebp-9Ch]
  int v17[7]; // [esp+70h] [ebp-98h] BYREF
  int v18; // [esp+8Ch] [ebp-7Ch]
  int v19[4]; // [esp+90h] [ebp-78h] BYREF
  unsigned int v20; // [esp+A0h] [ebp-68h]
  int v21; // [esp+A4h] [ebp-64h]
  int v22; // [esp+A8h] [ebp-60h]
  float v23; // [esp+ACh] [ebp-5Ch]
  float v24[6]; // [esp+B0h] [ebp-58h] BYREF
  int *v25; // [esp+C8h] [ebp-40h]
  _DWORD *v26; // [esp+CCh] [ebp-3Ch]
  float s; // [esp+D0h] [ebp-38h] BYREF
  float v28[3]; // [esp+D4h] [ebp-34h] BYREF
  int v29; // [esp+E0h] [ebp-28h]
  int v30; // [esp+E4h] [ebp-24h]
  unsigned __int16 v31; // [esp+ECh] [ebp-1Ch]
  unsigned __int16 v32; // [esp+F0h] [ebp-18h]

  v21 = 0;
  if ( a6 <= 12 )
  {
    if ( *(_DWORD *)(*(_DWORD *)(a7 + 60) + 796) )
    {
      v20 = 2;
      v21 = 32;
    }
    else
    {
      v20 = 1;
    }
    if ( *(_DWORD *)(*(_DWORD *)(a7 + 60) + 800) )
      v21 |= 2u;
    if ( *(_DWORD *)(*(_DWORD *)(a7 + 60) + 796) )
      G_LocationalTrace(&s, a3, a4, *a1, 41953329, (int)&unk_816779F);
    else
      G_LocationalTrace(&s, a3, a4, *a1, 41953329, (int)&unk_816778C);
    sub_80DEB7A(a3, a4, s, (float *)v19);
    sub_811AA18(a2, a3, (float *)v19, *(_DWORD *)(*(_DWORD *)(a7 + 60) + 492), v20);
    v25 = (int *)((char *)&unk_8665480 + 560 * v31);
    sub_811EA62(a4, a3, (float *)v17);
    Vec3Normalize((float *)v17);
    v9 = sub_811EB32((float *)v17, v28) * -2.0;
    v16 = v9;
    sub_811EADE((float *)v17, v16, v28, (float *)v17);
    if ( (v29 & 4) == 0 && !v25[86] )
    {
      v9 = s;
      if ( s < 1.0 )
      {
        if ( *(_DWORD *)(*(_DWORD *)(a7 + 60) + 124) == 3 )
        {
          v18 = 181;
        }
        else if ( *(_DWORD *)(*(_DWORD *)(a7 + 60) + 796) )
        {
          v18 = 183;
        }
        else
        {
          v18 = 182;
        }
        if ( *(_DWORD *)(*(_DWORD *)(a7 + 60) + 796) )
          v10 = G_TempEntity(v19, 183);
        else
          v10 = G_TempEntity(v19, 182);
        v26 = v10;
        v10[40] = (unsigned __int8)DirToByte(v28);
        v11 = (int)v26;
        *(_DWORD *)(v11 + 216) = (unsigned __int8)DirToByte((float *)v17);
        if ( v25[1] == 2 )
          v15 = 7;
        else
          v15 = (v29 & 0x1F00000) >> 20;
        v26[34] = v15;
        v26[29] = *a8;
      }
    }
    if ( (v30 & 0x10) != 0 )
    {
      sub_811EA62(a4, a3, (float *)v17);
      Vec3Normalize((float *)v17);
      v13 = sub_811EB32(v28, (float *)v17);
      if ( COERCE_FLOAT(LODWORD(v13) ^ 0x80000000) < 0.125 )
        v14 = 0.0;
      else
        v14 = 0.25 / COERCE_FLOAT(LODWORD(v13) ^ 0x80000000);
      sub_811EADE((float *)v19, v14, (float *)v17, a3);
      sub_811DA00(a1, (char)a2, a3, a4, LODWORD(a5), a6 + 1, a7, a8, a9);
    }
    else if ( *((_BYTE *)v25 + 353) )
    {
      if ( v25 != a2 )
      {
        sub_811EA62(a3, (float *)v19, v24);
        sub_811EB66(v24);
        v23 = v9;
        v22 = (int)((long double)sub_811D6EC(a7, v23) * a5);
        sub_80FF7C8(v25, a2, a2, (float *)a7, v19, v22, v21, v20, v32, dword_859B5EC - a9);
        if ( v25[86] )
        {
          if ( (v21 & 0x20) != 0 && (Dvar_GetInt("scr_friendlyfire") || !sub_8119C40((int)v25, (int)a2)) )
          {
            v12 = a5 * 0.5;
            sub_811DA00(v25, (char)a2, v19, a4, LODWORD(v12), a6 + 1, a7, a8, a9);
          }
        }
      }
    }
  }
  else
  {
    Com_DPrintf("Bullet_Fire_Extended: Too many resursions, bullet aborted\n");
  }
}
// 811DA00: using guessed type int *arg_4;
// 811DA00: using guessed type float var_58[6];

//----- (0811DF44) --------------------------------------------------------
int __cdecl sub_811DF44(int *a1, int *a2, int a3, int a4, float a5)
{
  int result; // eax
  int i; // [esp+3Ch] [ebp-2Ch]
  float v7[4]; // [esp+40h] [ebp-28h] BYREF
  int v8[6]; // [esp+50h] [ebp-18h] BYREF

  sub_811EA32((_DWORD *)(a3 + 36), v7);
  for ( i = 0; ; ++i )
  {
    result = i;
    if ( i >= *(_DWORD *)(*(_DWORD *)(a3 + 60) + 476) )
      break;
    sub_811D638(a5, (float *)v8, (float *)a3, *(float *)(*(_DWORD *)(a3 + 60) + 1436));
    sub_811DA00(a1, a2, v7, (float *)v8, 1.0, 0, a3, a1, a4);
  }
  return result;
}
// 811DF44: using guessed type float var_28[4];

//----- (0811DFF4) --------------------------------------------------------
int __cdecl sub_811DFF4(int *a1, float a2, int a3, int *a4, int a5)
{
  char s[832]; // [esp+30h] [ebp-358h] BYREF
  int v7[6]; // [esp+370h] [ebp-18h] BYREF

  sub_811D7E6(a5, s);
  if ( *(_DWORD *)(*(_DWORD *)(a3 + 60) + 124) == 3 )
  {
    sub_811DF44(a4, a1, a3, a5, a2);
  }
  else
  {
    sub_811D638(a2, (float *)v7, (float *)a3, 8192.0);
    sub_811DA00(a4, a1, (float *)(a3 + 36), (float *)v7, 1.0, 0, a3, a4, a5);
  }
  return sub_811D95C((int)s);
}

//----- (0811E0C2) --------------------------------------------------------
int __cdecl sub_811E0C2(_DWORD *a1, int a2, int a3)
{
  float v4; // [esp+4h] [ebp-54h]
  float v5; // [esp+2Ch] [ebp-2Ch]
  int v6[2]; // [esp+30h] [ebp-28h] BYREF
  float v7; // [esp+38h] [ebp-20h]
  int v8; // [esp+4Ch] [ebp-Ch]

  v4 = (float)*(int *)(*(_DWORD *)(a3 + 60) + 900);
  sub_811EAA6((float *)a3, v4, (float *)v6);
  v7 = (long double)*(int *)(*(_DWORD *)(a3 + 60) + 904) + v7;
  v8 = sub_810C1F6(a1, (_DWORD *)(a3 + 36), (float *)v6, a2, *(_DWORD *)(*(_DWORD *)(a3 + 60) + 584));
  Vec3Normalize((float *)v6);
  v5 = sub_811EB32((float *)(a1[86] + 32), (float *)v6);
  sub_811EADE((float *)(v8 + 36), v5, (float *)v6, (float *)(v8 + 36));
  return v8;
}

//----- (0811E18A) --------------------------------------------------------
float *__cdecl sub_811E18A(float *a1, float a2, int a3)
{
  float *result; // eax
  float v4; // [esp+18h] [ebp-40h]
  _DWORD v5[4]; // [esp+20h] [ebp-38h] BYREF
  int v6[4]; // [esp+30h] [ebp-28h] BYREF
  float v7; // [esp+40h] [ebp-18h]
  float v8; // [esp+44h] [ebp-14h] BYREF
  float v9[4]; // [esp+48h] [ebp-10h] BYREF

  v9[1] = 16.0;
  v4 = tan(a2 * 0.0174532925199433);
  v7 = v4 * 16.0;
  sub_811D5E0(v9, &v8);
  v9[0] = v9[0] * v7;
  v8 = v8 * v7;
  sub_811EAA6((float *)a3, 16.0, (float *)v6);
  sub_811EADE((float *)v6, v9[0], (float *)(a3 + 12), (float *)v6);
  sub_811EADE((float *)v6, v8, (float *)(a3 + 24), (float *)v6);
  Vec3Normalize((float *)v6);
  sub_811EA32((_DWORD *)(a3 + 36), v5);
  sub_810C4A0(a1, v5, (float *)v6);
  result = a1;
  if ( *((_DWORD *)a1 + 86) )
    return sub_811EADE((float *)(*((_DWORD *)a1 + 86) + 32), -64.0, (float *)a3, (float *)(*((_DWORD *)a1 + 86) + 32));
  return result;
}
// 811E18A: using guessed type _DWORD var_38[4];

//----- (0811E2C2) --------------------------------------------------------
_BOOL4 __cdecl sub_811E2C2(int a1, int a2)
{
  if ( !*(_BYTE *)(a1 + 353) )
    return 0;
  if ( a1 == a2 )
    return 0;
  if ( !*(_DWORD *)(a1 + 344) )
    return 0;
  if ( !*(_DWORD *)(a2 + 344) )
    return 0;
  if ( *(int *)(*(_DWORD *)(a1 + 344) + 4) <= 5 )
    return !sub_8119C40(a1, a2);
  return 0;
}

//----- (0811E35C) --------------------------------------------------------
void __cdecl sub_811E35C(int a1, float *a2)
{
  int v2[6]; // [esp+10h] [ebp-18h] BYREF

  sub_811EA32((_DWORD *)(*(_DWORD *)(a1 + 344) + 232), v2);
  v2[0] = *(_DWORD *)(*(_DWORD *)(a1 + 344) + 10200);
  v2[1] = *(_DWORD *)(*(_DWORD *)(a1 + 344) + 10204);
  AngleVectors((float *)v2, (int)a2, a2 + 3, a2 + 6);
  sub_80F61BE(a1, a2 + 9);
}

//----- (0811E3E0) --------------------------------------------------------
float *__cdecl sub_811E3E0(int a1, int a2)
{
  float *result; // eax
  float v3; // [esp+20h] [ebp-58h] BYREF
  float v4; // [esp+24h] [ebp-54h] BYREF
  float v5; // [esp+28h] [ebp-50h]
  float v6; // [esp+2Ch] [ebp-4Ch]
  int v7[15]; // [esp+30h] [ebp-48h] BYREF
  int v8; // [esp+6Ch] [ebp-Ch]

  if ( (*(_DWORD *)(*(_DWORD *)(a1 + 344) + 160) & 0x300) == 0 || (result = (float *)a1, !*(_BYTE *)(a1 + 354)) )
  {
    v8 = BG_WeaponDefs(*(_DWORD *)(a1 + 200));
    sub_811E35C(a1, (float *)v7);
    v6 = *(float *)(*(_DWORD *)(a1 + 344) + 10256);
    sub_80EA198(*(_DWORD *)(a1 + 344), *(_DWORD *)(a1 + 200), &v4, &v3);
    if ( *(float *)(*(_DWORD *)(a1 + 344) + 220) == 1.0 )
      v5 = (v3 - *(float *)(v8 + 1212)) * v6 + *(float *)(v8 + 1212);
    else
      v5 = (v3 - v4) * v6 + v4;
    if ( *(_DWORD *)(v8 + 120) )
    {
      if ( *(_DWORD *)(v8 + 120) == 1 )
      {
        return (float *)sub_811E0C2((_DWORD *)a1, *(_DWORD *)(a1 + 200), (int)v7);
      }
      else
      {
        if ( *(_DWORD *)(v8 + 120) != 2 )
          Com_Error(1, (char *)&byte_8157D40, *(_DWORD *)(v8 + 120), *(_DWORD *)v8);
        return sub_811E18A((float *)a1, v5, (int)v7);
      }
    }
    else
    {
      return (float *)sub_811DFF4((int *)a1, v5, (int)v7, (int *)a1, a2);
    }
  }
  return result;
}

//----- (0811E56A) --------------------------------------------------------
float *__cdecl sub_811E56A(int a1)
{
  return sub_811E3E0(a1, dword_859B5EC);
}

//----- (0811E586) --------------------------------------------------------
int __cdecl sub_811E586(_DWORD *a1)
{
  float v2[18]; // [esp+10h] [ebp-48h] BYREF

  LODWORD(v2[15]) = BG_WeaponDefs(*(_DWORD *)(a1[86] + 208));
  sub_811E35C((int)a1, v2);
  return sub_811E0C2(a1, *(_DWORD *)(a1[86] + 208), (int)v2);
}

//----- (0811E5E0) --------------------------------------------------------
__int16 __cdecl sub_811E5E0(int a1)
{
  __int16 result; // ax
  int v2[3]; // [esp+20h] [ebp-48h] BYREF
  float v3; // [esp+2Ch] [ebp-3Ch] BYREF
  float v4; // [esp+38h] [ebp-30h] BYREF
  float v5[9]; // [esp+44h] [ebp-24h] BYREF

  if ( (*(_DWORD *)(*(_DWORD *)(a1 + 344) + 160) & 0x300) == 0 || (result = a1, !*(_BYTE *)(a1 + 354)) )
  {
    LODWORD(v5[6]) = BG_WeaponDefs(*(_DWORD *)(a1 + 200));
    sub_80F61BE(a1, v5);
    sub_80F63A0(a1, (int)v2, &v3, &v4);
    return sub_811D3B4(
             (int *)a1,
             (float *)v2,
             *(float *)(player_meleeRange + 8),
             *(float *)(player_meleeWidth + 8),
             *(float *)(player_meleeHeight + 8));
  }
  return result;
}
// 8793E40: using guessed type int player_meleeRange;
// 8793E44: using guessed type int player_meleeWidth;
// 8793E48: using guessed type int player_meleeHeight;

//----- (0811E696) --------------------------------------------------------
int __cdecl sub_811E696(int a1, int a2)
{
  int v4; // [esp+18h] [ebp-10h]
  int i; // [esp+1Ch] [ebp-Ch]
  int v6; // [esp+20h] [ebp-8h]
  _DWORD *v7; // [esp+24h] [ebp-4h]

  if ( (unsigned __int8)sub_80D9E84(a1 + 1348, a2) )
    return 0;
  v7 = (_DWORD *)BG_WeaponDefs(a2);
  if ( v7[31] == 7 )
    return 0;
  if ( v7[31] == 8 )
    return 0;
  sub_80D9EAA(a1 + 1348, a2);
  sub_80F0400(a1 + 1372, a2);
  if ( v7[31] == 9 )
    return 1;
  if ( v7[33] )
  {
    if ( *(_DWORD *)(a1 + 208) )
    {
      if ( sub_80EACC8(a1, *(_DWORD *)(a1 + 208)) <= 0 )
      {
        v6 = BG_WeaponDefs(*(_DWORD *)(a1 + 208));
        v4 = sub_80E963A(a1, *(_DWORD *)(v6 + 132));
        if ( v4 )
          *(_DWORD *)(a1 + 208) = v4;
        else
          *(_DWORD *)(a1 + 208) = a2;
        sub_811E9B4(*(_DWORD *)(a1 + 204), *(_DWORD *)(a1 + 208));
      }
    }
    else
    {
      *(_DWORD *)(a1 + 208) = a2;
      sub_811E9B4(*(_DWORD *)(a1 + 204), *(_DWORD *)(a1 + 208));
    }
    return 1;
  }
  else
  {
    if ( (unsigned int)(v7[32] - 1) <= 1 )
    {
      if ( *(_BYTE *)(a1 + 1365) )
      {
        if ( !*(_BYTE *)(a1 + 1366) )
          *(_BYTE *)(a1 + 1366) = a2;
      }
      else
      {
        *(_BYTE *)(a1 + 1365) = a2;
      }
    }
    for ( i = v7[219]; i && !(unsigned __int8)sub_80D9E84(a1 + 1348, i); i = *(_DWORD *)(BG_WeaponDefs(i) + 876) )
    {
      sub_80D9EAA(a1 + 1348, i);
      sub_80F0400(a1 + 1372, a2);
    }
    return 1;
  }
}

//----- (0811E8E4) --------------------------------------------------------
void sub_811E8E4()
{
  Com_DPrintf("----------------------\n");
  Com_DPrintf("Game: G_SetupWeaponDef\n");
  if ( !dword_8576140 )
  {
    SV_SetWeaponInfoMemory();
    ClearRegisteredItems();
    BG_ClearWeaponDef();
    BG_FillInAmmoItems((void (__cdecl *)(int))G_RegisterWeapon);
    G_GetWeaponIndexForName("defaultweapon_mp");
  }
  Com_DPrintf("----------------------\n");
}
// 8576140: using guessed type int dword_8576140;

//----- (0811E940) --------------------------------------------------------
int __cdecl G_GetWeaponIndexForName(char *s1)
{
  if ( dword_859B41C )
    return sub_80E94F0(s1, (void (__cdecl *)(int))G_RegisterWeapon);
  else
    return BG_FindWeaponIndexForName(s1);
}

//----- (0811E97A) --------------------------------------------------------
int __cdecl sub_811E97A(int a1, int a2)
{
  char *v2; // eax

  v2 = va("%c %i", 97, a2);
  return SV_GameSendServerCommand(a1, 1, v2);
}

//----- (0811E9B4) --------------------------------------------------------
int __cdecl sub_811E9B4(int a1, int a2)
{
  char *v2; // eax

  v2 = va("%c %i", 67, a2);
  return SV_GameSendServerCommand(a1, 1, v2);
}

//----- (0811E9EE) --------------------------------------------------------
long double __cdecl sub_811E9EE(float a1, float a2, float a3)
{
  return (1.0 - a3) * a1 + a2 * a3;
}

//----- (0811EA04) --------------------------------------------------------
void __cdecl sub_811EA04(float a1, float *a2, float *a3)
{
  *a2 = sin(a1);
  *a3 = cos(a1);
}

//----- (0811EA32) --------------------------------------------------------
int __cdecl sub_811EA32(_DWORD *a1, _DWORD *a2)
{
  int result; // eax

  *a2 = *a1;
  a2[1] = a1[1];
  result = a1[2];
  a2[2] = result;
  return result;
}

//----- (0811EA62) --------------------------------------------------------
float *__cdecl sub_811EA62(float *a1, float *a2, float *a3)
{
  float *result; // eax

  *a3 = *a1 - *a2;
  a3[1] = a1[1] - a2[1];
  result = a1 + 2;
  a3[2] = a1[2] - a2[2];
  return result;
}

//----- (0811EAA6) --------------------------------------------------------
float *__cdecl sub_811EAA6(float *a1, float a2, float *a3)
{
  float *result; // eax

  *a3 = a2 * *a1;
  a3[1] = a2 * a1[1];
  result = a1 + 2;
  a3[2] = a2 * a1[2];
  return result;
}

//----- (0811EADE) --------------------------------------------------------
float *__cdecl sub_811EADE(float *a1, float a2, float *a3, float *a4)
{
  float *result; // eax

  *a4 = a2 * *a3 + *a1;
  a4[1] = a2 * a3[1] + a1[1];
  result = a3 + 2;
  a4[2] = a2 * a3[2] + a1[2];
  return result;
}

//----- (0811EB32) --------------------------------------------------------
long double __cdecl sub_811EB32(float *a1, float *a2)
{
  return *a1 * *a2 + a1[1] * a2[1] + a1[2] * a2[2];
}

//----- (0811EB66) --------------------------------------------------------
void __cdecl sub_811EB66(float *a1)
{
  float v1; // [esp+0h] [ebp-8h]

  v1 = *a1 * *a1 + a1[1] * a1[1] + a1[2] * a1[2];
  sub_811EBA4(v1);
}

//----- (0811EBA4) --------------------------------------------------------
long double __cdecl sub_811EBA4(float a1)
{
  return (float)sqrt(a1);
}

//----- (0811EBC4) --------------------------------------------------------
int __cdecl sub_811EBC4(int *a1, int a2)
{
  int result; // eax
  void (__cdecl *v3)(int, int *, _DWORD); // [esp+10h] [ebp-8h]
  void (__cdecl *v4)(int, int *, int *); // [esp+14h] [ebp-4h]

  v4 = (void (__cdecl *)(int, int *, int *))dword_8167890[10 * *(unsigned __int8 *)(a2 + 358)];
  v3 = (void (__cdecl *)(int, int *, _DWORD))dword_816788C[10 * *(unsigned __int8 *)(a2 + 358)];
  if ( *(_DWORD *)(a2 + 4) == 3 )
  {
    Scr_AddEntity(a1);
    Scr_Notify((int *)a2, word_87A22F2, 1);
    *(_BYTE *)(a2 + 354) = 1;
    if ( v3 )
      v3(a2, a1, 0);
  }
  else if ( *(_DWORD *)(a2 + 4) != 9 || sub_8109EC0(a2, (int)a1) )
  {
    Scr_AddEntity(a1);
    Scr_Notify((int *)a2, word_87A22F4, 1);
    if ( v4 )
      v4(a2, a1, a1);
  }
  result = a1[86];
  *(_DWORD *)(result + 10288) = 1023;
  return result;
}
// 816788C: using guessed type int dword_816788C[];
// 8167890: using guessed type int dword_8167890[];
// 87A22F2: using guessed type __int16 word_87A22F2;
// 87A22F4: using guessed type __int16 word_87A22F4;

//----- (0811ECE4) --------------------------------------------------------
int __cdecl sub_811ECE4(int a1)
{
  if ( !Scr_IsSystemActive() )
    return 0;
  *(_DWORD *)(*(_DWORD *)(a1 + 344) + 10288) = 1023;
  if ( *(_BYTE *)(a1 + 354) )
  {
    if ( (*(_DWORD *)(*(_DWORD *)(a1 + 344) + 160) & 0x300) != 0 )
      *(_BYTE *)(a1 + 354) = 2;
    else
      *(_BYTE *)(a1 + 354) = 0;
    return 1;
  }
  else if ( (*(_DWORD *)(*(_DWORD *)(a1 + 344) + 12) & 4) != 0 )
  {
    return 1;
  }
  else if ( *(_DWORD *)(*(_DWORD *)(a1 + 344) + 1440) == 1023 )
  {
    return 0;
  }
  else
  {
    *(_DWORD *)(*(_DWORD *)(a1 + 344) + 10288) = *(_DWORD *)(*(_DWORD *)(a1 + 344) + 1440);
    *(_DWORD *)(*(_DWORD *)(a1 + 344) + 10292) = dword_859B5EC;
    return 1;
  }
}

//----- (0811EDD4) --------------------------------------------------------
int __cdecl sub_811EDD4(int *a1)
{
  int result; // eax

  result = Scr_IsSystemActive();
  if ( result )
  {
    result = a1[86];
    if ( *(_DWORD *)(result + 10288) != 1023 )
    {
      result = g_useholdspawndelay;
      if ( dword_859B5EC - *(_DWORD *)(a1[86] + 10400) >= *(_DWORD *)(g_useholdspawndelay + 8) )
      {
        result = g_useholdtime;
        if ( dword_859B5EC - *(_DWORD *)(a1[86] + 10292) >= *(_DWORD *)(g_useholdtime + 8) )
          return sub_811EBC4(a1, (int)&unk_8665480 + 560 * *(_DWORD *)(a1[86] + 10288));
      }
    }
  }
  return result;
}
// 8793DA0: using guessed type int g_useholdtime;
// 8793DA4: using guessed type int g_useholdspawndelay;

//----- (0811EE84) --------------------------------------------------------
int __cdecl sub_811EE84(int *a1)
{
  int result; // eax
  char v2; // [esp+7h] [ebp-1h]

  *(_DWORD *)(a1[86] + 12) &= ~8u;
  if ( *(int *)(a1[86] + 216) <= 16 || (result = a1[86], *(int *)(result + 216) > 22) )
  {
    v2 = 0;
    if ( *(_DWORD *)(a1[86] + 10288) == 1023
      || (*(_DWORD *)(a1[86] + 10176) & 0x20) == 0
      || (*(_DWORD *)(a1[86] + 10172) & 0x20) != 0 )
    {
      if ( (*(_DWORD *)(a1[86] + 10180) & 0x28) != 0 )
        v2 = sub_811ECE4((int)a1);
      if ( *(_DWORD *)(a1[86] + 10288) != 1023 || v2 )
      {
        result = *(_DWORD *)(a1[86] + 10172) & 0x28;
        if ( result )
          return sub_811EDD4(a1);
      }
      else
      {
        result = *(_DWORD *)(a1[86] + 10180) & 0x20;
        if ( result )
        {
          result = *(_DWORD *)(a1[86] + 12) | 8;
          *(_DWORD *)(a1[86] + 12) = result;
        }
      }
    }
    else
    {
      result = *(_DWORD *)(a1[86] + 12) | 8;
      *(_DWORD *)(a1[86] + 12) = result;
    }
  }
  return result;
}

//----- (0811EFC8) --------------------------------------------------------
int __cdecl sub_811EFC8(float *a1, float *a2)
{
  return (int)(a1[1] - a2[1]);
}

//----- (0811F004) --------------------------------------------------------
int __cdecl sub_811F004(float *a1, _DWORD *base)
{
  float v3; // [esp+24h] [ebp-10C4h]
  int v4; // [esp+28h] [ebp-10C0h]
  float v5[4]; // [esp+30h] [ebp-10B8h] BYREF
  float v6[4]; // [esp+40h] [ebp-10A8h] BYREF
  int v7; // [esp+50h] [ebp-1098h]
  int i; // [esp+54h] [ebp-1094h]
  size_t nmemb; // [esp+58h] [ebp-1090h]
  int v10; // [esp+5Ch] [ebp-108Ch]
  int v11[1026]; // [esp+60h] [ebp-1088h] BYREF
  float v12; // [esp+1068h] [ebp-80h]
  float v13; // [esp+106Ch] [ebp-7Ch]
  float v14[4]; // [esp+1070h] [ebp-78h] BYREF
  int v15[4]; // [esp+1080h] [ebp-68h] BYREF
  float v16[4]; // [esp+1090h] [ebp-58h] BYREF
  float v17[4]; // [esp+10A0h] [ebp-48h] BYREF
  float v18[4]; // [esp+10B0h] [ebp-38h] BYREF
  float v19[6]; // [esp+10C0h] [ebp-28h] BYREF
  float *v20; // [esp+10D8h] [ebp-10h]
  int v21; // [esp+10DCh] [ebp-Ch]
  int v22; // [esp+10F0h] [ebp+8h]

  v4 = 0;
  v21 = *((_DWORD *)a1 + 86);
  sub_80F61BE((int)a1, v16);
  sub_80F63A0((int)a1, (int)v19, 0, 0);
  sub_811FEEA((float *)(v21 + 20), (float *)(v21 + 1388), v6);
  sub_811FEEA((float *)(v21 + 20), (float *)(v21 + 1400), v5);
  sub_811FF2E(v16, flt_8157DAC, v18);
  sub_811FEEA(v16, flt_8157DAC, v17);
  v10 = sub_805E782((int)v18, (int)v17, (int)v11, 1024, 0x200000);
  nmemb = 0;
  for ( i = 0; i < v10; ++i )
  {
    v20 = (float *)((char *)&unk_8665480 + 560 * v11[i]);
    if ( a1 != v20 && (*((_DWORD *)v20 + 1) == 3 || ((_DWORD)v20[71] & 0x200000) != 0) )
    {
      if ( *((_WORD *)v20 + 180) == word_87A22F8 )
      {
        if ( v20[72] <= (long double)v5[0]
          && v6[0] <= (long double)v20[75]
          && v20[73] <= (long double)v5[1]
          && v6[1] <= (long double)v20[76]
          && v20[74] <= (long double)v5[2]
          && v6[2] <= (long double)v20[77] )
        {
          if ( sub_80901C2(v6, v5, (int)v20) )
          {
            base[2 * nmemb + 1] = -1015021568;
            base[2 * nmemb++] = v20;
          }
        }
      }
      else
      {
        sub_811FEEA(v20 + 72, v20 + 75, (float *)v15);
        sub_811FF72((float *)v15, 0.5, (float *)v15);
        sub_811FF2E((float *)v15, v16, v14);
        v13 = Vec3Normalize(v14);
        if ( v13 <= 128.0 )
        {
          v3 = sub_811FFFE(v14, v19);
          v12 = 1.0 - (v3 + 1.0) * 0.5;
          *(float *)&base[2 * nmemb + 1] = v12 * 256.0;
          if ( *((_WORD *)v20 + 180) == word_87A22F6 )
            *(float *)&base[2 * nmemb + 1] = *(float *)&base[2 * nmemb + 1] - 256.0;
          if ( *((_DWORD *)v20 + 1) == 3 && !sub_80DCC7A(v20, *((_DWORD **)a1 + 86), 0) )
          {
            *(float *)&base[2 * nmemb + 1] = *(float *)&base[2 * nmemb + 1] + 10000.0;
            ++v4;
          }
          base[2 * nmemb] = v20;
          *(float *)&base[2 * nmemb + 1] = *(float *)&base[2 * nmemb + 1] + v13;
          ++nmemb;
        }
      }
    }
  }
  qsort(base, nmemb, 8u, (__compar_fn_t)sub_811EFC8);
  nmemb -= v4;
  v7 = 0;
  for ( i = 0; i < (int)nmemb; ++i )
  {
    v22 = base[2 * i];
    if ( *(_WORD *)(v22 + 360) != word_87A22F8 )
    {
      sub_811FEEA((float *)(v22 + 288), (float *)(v22 + 300), (float *)v15);
      sub_811FF72((float *)v15, 0.5, (float *)v15);
      if ( *(_DWORD *)(v22 + 4) == 9 )
        sub_811C16A(v22, (unsigned __int16)word_87A233E, (float *)v15);
      if ( !G_TraceCapsuleComplete(v16, flt_8145E68, flt_8145E68, (float *)v15, *(_DWORD *)(v21 + 204), 17) )
      {
        *(float *)&base[2 * i + 1] = *(float *)&base[2 * i + 1] + 10000.0;
        ++v7;
      }
    }
  }
  qsort(base, nmemb, 8u, (__compar_fn_t)sub_811EFC8);
  return nmemb - v7;
}
// 8145E68: using guessed type float flt_8145E68[3];
// 8157DAC: using guessed type float flt_8157DAC[3];
// 87A22F6: using guessed type __int16 word_87A22F6;
// 87A22F8: using guessed type __int16 word_87A22F8;
// 87A233E: using guessed type __int16 word_87A233E;
// 811F004: using guessed type float var_58[4];
// 811F004: using guessed type float var_28[6];
// 811F004: using guessed type float var_38[4];
// 811F004: using guessed type float var_48[4];
// 811F004: using guessed type int var_1088[1026];
// 811F004: using guessed type float var_78[4];

//----- (0811F61A) --------------------------------------------------------
int __cdecl sub_811F61A(int a1, int a2)
{
  int v3; // [esp+10h] [ebp-8h]
  char *v4; // [esp+14h] [ebp-4h]

  v4 = (char *)&unk_8164C20 + 44 * *(unsigned __int16 *)(a2 + 428);
  v3 = 0;
  if ( *((_DWORD *)v4 + 7) == 1
    && *(_DWORD *)(BG_WeaponDefs(*((_DWORD *)v4 + 8)) + 120) != 1
    && !(unsigned __int8)sub_80D9E84(a1 + 1348, *((_DWORD *)v4 + 8)) )
  {
    return *((_DWORD *)v4 + 8) + 4;
  }
  return v3;
}

//----- (0811F6A6) --------------------------------------------------------
_BYTE *__cdecl sub_811F6A6(int a1)
{
  _BYTE *result; // eax
  _DWORD *v2; // [esp+Ch] [ebp-Ch]
  int v3; // [esp+10h] [ebp-8h]

  v2 = *(_DWORD **)(a1 + 344);
  v3 = dword_859B404 + 560 * v2[357];
  result = *(_BYTE **)(BG_WeaponDefs(*(_DWORD *)(v3 + 200)) + 1392);
  if ( *result )
  {
    v2[360] = 1023;
    v2[358] = *(_DWORD *)(v3 + 200) + 4;
    result = *(_BYTE **)(BG_WeaponDefs(*(_DWORD *)(v3 + 200)) + 1400);
    v2[359] = result;
  }
  return result;
}
// 859B404: using guessed type int dword_859B404;

//----- (0811F736) --------------------------------------------------------
int *__cdecl sub_811F736(int a1)
{
  int *result; // eax
  int v2; // [esp+10h] [ebp-2028h]
  int *i; // [esp+14h] [ebp-2024h]
  int *v4; // [esp+18h] [ebp-2020h]
  int v5; // [esp+1Ch] [ebp-201Ch]
  int v6; // [esp+20h] [ebp-2018h]
  int v7; // [esp+24h] [ebp-2014h]
  int v8; // [esp+28h] [ebp-2010h]
  int *v9; // [esp+2Ch] [ebp-200Ch]
  _DWORD base[2050]; // [esp+30h] [ebp-2008h] BYREF

  v9 = *(int **)(a1 + 344);
  v9[358] = 0;
  v9[359] = -1;
  v9[360] = 1023;
  result = (int *)a1;
  if ( *(int *)(a1 + 404) > 0 )
  {
    if ( *(int *)(*(_DWORD *)(a1 + 344) + 216) <= 16 || (result = *(int **)(a1 + 344), result[54] > 22) )
    {
      if ( *(_BYTE *)(a1 + 354) )
      {
        result = (int *)(v9[40] & 0x300);
        if ( result )
          return (int *)sub_811F6A6(a1);
      }
      else
      {
        result = (int *)(*(_DWORD *)(*(_DWORD *)(a1 + 344) + 12) & 4);
        if ( !result )
        {
          result = (int *)sub_811F004((float *)a1, base);
          v4 = result;
          if ( result )
          {
            v7 = 0;
            v5 = -1;
            for ( i = 0; ; i = (int *)((char *)i + 1) )
            {
              result = i;
              if ( (int)i >= (int)v4 )
                return result;
              v8 = base[2 * (_DWORD)i];
              v2 = *(_DWORD *)(v8 + 4);
              if ( v2 == 3 )
              {
                v6 = sub_811F61A(*(_DWORD *)(a1 + 344), v8);
                if ( v6 )
                {
                  v7 = v6;
LABEL_31:
                  v9[360] = *(_DWORD *)v8;
                  v9[358] = v7;
                  v9[359] = v5;
                  result = v9;
                  if ( !v9[358] )
                  {
                    result = v9;
                    v9[360] = 1023;
                  }
                  return result;
                }
              }
              else if ( v2 > 3 )
              {
                if ( v2 == 9 && sub_8109EC0(v8, a1) )
                {
                  v7 = *(_DWORD *)(v8 + 200) + 4;
                  if ( **(_BYTE **)(BG_WeaponDefs(*(_DWORD *)(v8 + 200)) + 1388) )
                    v5 = *(_DWORD *)(BG_WeaponDefs(*(_DWORD *)(v8 + 200)) + 1396);
                  goto LABEL_31;
                }
              }
              else if ( !v2 )
              {
                if ( *(_WORD *)(v8 + 360) != word_87A22F6 && *(_WORD *)(v8 + 360) != word_87A22F8 )
                  goto LABEL_31;
                if ( (!*(_BYTE *)(v8 + 359)
                   || *(unsigned __int8 *)(v8 + 359) == *(_DWORD *)(*(_DWORD *)(a1 + 344) + 10060))
                  && (*(_DWORD *)(v8 + 436) == 1023 || *(_DWORD *)(v8 + 436) == *(_DWORD *)(*(_DWORD *)(a1 + 344) + 204)) )
                {
                  v7 = *(_DWORD *)(v8 + 220);
                  if ( v7 && *(_DWORD *)(v8 + 216) != 255 )
                    v5 = *(_DWORD *)(v8 + 216);
                  goto LABEL_31;
                }
              }
            }
          }
        }
      }
    }
  }
  return result;
}
// 87A22F6: using guessed type __int16 word_87A22F6;
// 87A22F8: using guessed type __int16 word_87A22F8;
// 811F736: using guessed type _DWORD base[2050];

//----- (0811FABE) --------------------------------------------------------
int __cdecl sub_811FABE(float *s, float *a2, float *a3, int a4, int a5, int a6, float *a7)
{
  long double v7; // fst7
  float v9; // [esp+4h] [ebp-44h]
  float v11; // [esp+2Ch] [ebp-1Ch]
  int v12[6]; // [esp+30h] [ebp-18h] BYREF

  G_LocationalTrace(s, a2, a3, a4, a5, a6);
  if ( *((_WORD *)s + 14) > 0x3FDu )
    return 0;
  v7 = *s * 15000.0;
  v9 = v7;
  sub_811FFAA(a2, v9, a7, (float *)v12);
  sub_808F1DC(a2, (float *)v12);
  v11 = v7;
  if ( v11 >= 0.2 )
    return 560 * *((unsigned __int16 *)s + 14) + 140924032;
  else
    return 0;
}

//----- (0811FB7A) --------------------------------------------------------
void __cdecl sub_811FB7A(int *a1)
{
  float v1; // [esp+20h] [ebp-98h]
  float v2; // [esp+24h] [ebp-94h]
  float v3; // [esp+28h] [ebp-90h]
  void *v4; // [esp+2Ch] [ebp-8Ch]
  float v5[4]; // [esp+30h] [ebp-88h] BYREF
  int v6[4]; // [esp+40h] [ebp-78h] BYREF
  int v7[4]; // [esp+50h] [ebp-68h] BYREF
  int v8[4]; // [esp+60h] [ebp-58h] BYREF
  float s[4]; // [esp+70h] [ebp-48h] BYREF
  int v10; // [esp+80h] [ebp-38h]
  float *v11; // [esp+A4h] [ebp-14h]
  _DWORD *v12; // [esp+A8h] [ebp-10h]
  int v13; // [esp+ACh] [ebp-Ch]

  v12 = (_DWORD *)a1[86];
  v12[3] &= 0xFFCFFFFF;
  *(_DWORD *)(a1[86] + 10284) = 0;
  sub_80F61BE((int)a1, (float *)v8);
  sub_80F63A0((int)a1, (int)v6, 0, 0);
  if ( (v12[40] & 0x300) != 0 )
    v13 = BG_WeaponDefs(dword_8665548[140 * v12[357]]);
  else
    v13 = BG_WeaponDefs(*(_DWORD *)(a1[86] + 212));
  if ( *(_DWORD *)(a1[86] + 212) && *(_DWORD *)(v13 + 796) )
    v4 = &unk_816779F;
  else
    v4 = &unk_816778C;
  sub_811FFAA((float *)v8, 15000.0, (float *)v6, (float *)v7);
  v11 = (float *)sub_811FABE(s, (float *)v8, (float *)v7, *a1, 578824193, (int)v4, (float *)v6);
  if ( v11 )
  {
    if ( *((_WORD *)v11 + 180) != word_87A22FC
      || (*(_DWORD *)(a1[86] + 10284) = v11,
          sub_8119FCC((int *)v11, a1),
          (v11 = (float *)sub_811FABE(s, (float *)v8, (float *)v7, *a1, 41953281, (int)v4, (float *)v6)) != 0) )
    {
      if ( *((_DWORD *)v11 + 1) == 1 && (v10 & 0x10) == 0 )
      {
        sub_811FF2E(v11 + 78, (float *)v8, v5);
        if ( *(_DWORD *)(*((_DWORD *)v11 + 86) + 10060) == *(_DWORD *)(a1[86] + 10060) && *(_DWORD *)(a1[86] + 10060) )
        {
          v3 = sub_8120032(v5);
          if ( sub_811FEDE(*(float *)(g_friendlyNameDist + 8)) > v3 && !*(_DWORD *)(a1[86] + 10284) )
            *(_DWORD *)(a1[86] + 10284) = v11;
          v2 = sub_8120032(v5);
          if ( sub_811FEDE(*(float *)(g_friendlyfireDist + 8)) > v2 )
            v12[3] |= 0x100000u;
        }
        else
        {
          v1 = sub_8120032(v5);
          if ( sub_811FEDE(*(float *)(v13 + 608)) > v1 )
          {
            if ( !*(_DWORD *)(a1[86] + 10284) )
              *(_DWORD *)(a1[86] + 10284) = v11;
            v12[3] |= 0x200000u;
          }
        }
      }
    }
  }
}
// 8665548: using guessed type int dword_8665548[];
// 8793E38: using guessed type int g_friendlyfireDist;
// 8793E3C: using guessed type int g_friendlyNameDist;
// 87A22FC: using guessed type __int16 word_87A22FC;
// 811FB7A: using guessed type float s[4];
// 811FB7A: using guessed type float var_88[4];

//----- (0811FEDE) --------------------------------------------------------
long double __cdecl sub_811FEDE(float a1)
{
  return a1 * a1;
}

//----- (0811FEEA) --------------------------------------------------------
float *__cdecl sub_811FEEA(float *a1, float *a2, float *a3)
{
  float *result; // eax

  *a3 = *a1 + *a2;
  a3[1] = a1[1] + a2[1];
  result = a1 + 2;
  a3[2] = a1[2] + a2[2];
  return result;
}

//----- (0811FF2E) --------------------------------------------------------
float *__cdecl sub_811FF2E(float *a1, float *a2, float *a3)
{
  float *result; // eax

  *a3 = *a1 - *a2;
  a3[1] = a1[1] - a2[1];
  result = a1 + 2;
  a3[2] = a1[2] - a2[2];
  return result;
}

//----- (0811FF72) --------------------------------------------------------
float *__cdecl sub_811FF72(float *a1, float a2, float *a3)
{
  float *result; // eax

  *a3 = a2 * *a1;
  a3[1] = a2 * a1[1];
  result = a1 + 2;
  a3[2] = a2 * a1[2];
  return result;
}

//----- (0811FFAA) --------------------------------------------------------
float *__cdecl sub_811FFAA(float *a1, float a2, float *a3, float *a4)
{
  float *result; // eax

  *a4 = a2 * *a3 + *a1;
  a4[1] = a2 * a3[1] + a1[1];
  result = a3 + 2;
  a4[2] = a2 * a3[2] + a1[2];
  return result;
}

//----- (0811FFFE) --------------------------------------------------------
long double __cdecl sub_811FFFE(float *a1, float *a2)
{
  return *a1 * *a2 + a1[1] * a2[1] + a1[2] * a2[2];
}

//----- (08120032) --------------------------------------------------------
long double __cdecl sub_8120032(float *a1)
{
  return *a1 * *a1 + a1[1] * a1[1] + a1[2] * a1[2];
}

//----- (08120068) --------------------------------------------------------
int sub_8120068()
{
  int result; // eax

  word_87A22A0 = sub_810DD1C((char *)&byte_8157DD0);
  word_87A22A2 = sub_810DD1C("allies");
  word_87A22A4 = sub_810DD1C("axis");
  word_87A22A6 = sub_810DD1C("current");
  word_87A22A8 = sub_810DD1C("damage");
  word_87A22AA = sub_810DD1C("death");
  word_87A22AC = sub_810DD1C("dlight");
  word_87A22AE = sub_810DD1C("done");
  word_87A22B0 = sub_810DD1C("empty");
  word_87A22B2 = sub_810DD1C("entity");
  word_87A22B4 = sub_810DD1C("failed");
  word_87A22B6 = sub_810DD1C("fraction");
  word_87A22B8 = sub_810DD1C("goal");
  word_87A22BA = sub_810DD1C("grenade");
  word_87A22BC = sub_810DD1C("info_notnull");
  word_87A22BE = sub_810DD1C("invisible");
  word_87A22C0 = sub_810DD1C("key1");
  word_87A22C2 = sub_810DD1C("key2");
  word_87A22C4 = sub_810DD1C("killanimscript");
  word_87A22C6 = sub_810DD1C("left");
  word_87A22C8 = sub_810DD1C("movedone");
  word_87A22CA = sub_810DD1C("noclass");
  word_87A22CC = sub_810DD1C("normal");
  word_87A22CE = sub_810DD1C("pistol");
  word_87A22D0 = sub_810DD1C("plane_waypoint");
  word_87A22D2 = sub_810DD1C("player");
  word_87A22D4 = sub_810DD1C("position");
  word_87A22D6 = sub_810DD1C("primary");
  word_87A22D8 = sub_810DD1C("primaryb");
  word_87A22DA = sub_810DD1C("prone");
  word_87A22DC = sub_810DD1C("right");
  word_87A22DE = sub_810DD1C("rocket");
  word_87A22E0 = sub_810DD1C("rotatedone");
  word_87A22E2 = sub_810DD1C("script_brushmodel");
  word_87A22E4 = sub_810DD1C("script_model");
  word_87A22E6 = sub_810DD1C("script_origin");
  word_87A22E8 = sub_810DD1C("spectator");
  word_87A22EA = sub_810DD1C("stand");
  word_87A22EC = sub_810DD1C("surfacetype");
  word_87A22EE = sub_810DD1C("target_script_trigger");
  word_87A22F0 = sub_810DD1C("tempEntity");
  word_87A22F2 = sub_810DD1C("touch");
  word_87A22F4 = sub_810DD1C("trigger");
  word_87A22F6 = sub_810DD1C("trigger_use");
  word_87A22F8 = sub_810DD1C("trigger_use_touch");
  word_87A22FA = sub_810DD1C("trigger_damage");
  word_87A22FC = sub_810DD1C("trigger_lookat");
  word_87A22FE = sub_810DD1C("truck_cam");
  word_87A2300 = sub_810DD1C("worldspawn");
  word_87A2302 = sub_810DD1C("binocular_enter");
  word_87A2304 = sub_810DD1C("binocular_exit");
  word_87A2306 = sub_810DD1C("binocular_fire");
  word_87A2308 = sub_810DD1C("binocular_release");
  word_87A230A = sub_810DD1C("binocular_drop");
  word_87A230C = sub_810DD1C("begin");
  word_87A230E = sub_810DD1C("intermission");
  word_87A2310 = sub_810DD1C("menuresponse");
  word_87A2312 = sub_810DD1C("playing");
  word_87A2314 = sub_810DD1C("none");
  word_87A2316 = sub_810DD1C("dead");
  word_87A2318 = sub_810DD1C("auto_change");
  word_87A231A = sub_810DD1C("manual_change");
  word_87A231C = sub_810DD1C("freelook");
  word_87A231E = sub_810DD1C("call_vote");
  word_87A2320 = sub_810DD1C("vote");
  word_87A2322 = sub_810DD1C("snd_enveffectsprio_level");
  word_87A2324 = sub_810DD1C("snd_enveffectsprio_shellshock");
  word_87A2326 = sub_810DD1C("snd_channelvolprio_holdbreath");
  word_87A2328 = sub_810DD1C("snd_channelvolprio_pain");
  word_87A232A = sub_810DD1C("snd_channelvolprio_shellshock");
  word_87A232C = sub_810DD1C("tag_flash");
  word_87A232E = sub_810DD1C("tag_flash_11");
  word_87A2330 = sub_810DD1C("tag_flash_2");
  word_87A2332 = sub_810DD1C("tag_flash_22");
  word_87A2334 = sub_810DD1C("tag_brass");
  word_87A2336 = sub_810DD1C("j_head");
  word_87A2338 = sub_810DD1C("tag_weapon");
  word_87A233A = sub_810DD1C("tag_player");
  word_87A233C = sub_810DD1C("tag_camera");
  word_87A233E = sub_810DD1C("tag_aim");
  word_87A2340 = sub_810DD1C("tag_aim_animated");
  word_87A2342 = sub_810DD1C("tag_origin");
  word_87A2344 = sub_810DD1C("tag_butt");
  word_87A2346 = sub_810DD1C("tag_weapon_right");
  word_87A2348 = sub_810DD1C("back_low");
  word_87A234A = sub_810DD1C("back_mid");
  word_87A234C = sub_810DD1C("back_up");
  word_87A234E = sub_810DD1C("neck");
  word_87A2350 = sub_810DD1C("head");
  result = sub_810DD1C("pelvis");
  word_87A2352 = result;
  return result;
}
// 87A22A0: using guessed type __int16 word_87A22A0;
// 87A22A2: using guessed type __int16 word_87A22A2;
// 87A22A4: using guessed type __int16 word_87A22A4;
// 87A22A6: using guessed type __int16 word_87A22A6;
// 87A22A8: using guessed type __int16 word_87A22A8;
// 87A22AA: using guessed type __int16 word_87A22AA;
// 87A22AC: using guessed type __int16 word_87A22AC;
// 87A22AE: using guessed type __int16 word_87A22AE;
// 87A22B0: using guessed type __int16 word_87A22B0;
// 87A22B2: using guessed type __int16 word_87A22B2;
// 87A22B4: using guessed type __int16 word_87A22B4;
// 87A22B6: using guessed type __int16 word_87A22B6;
// 87A22B8: using guessed type __int16 word_87A22B8;
// 87A22BA: using guessed type __int16 word_87A22BA;
// 87A22BC: using guessed type __int16 word_87A22BC;
// 87A22BE: using guessed type __int16 word_87A22BE;
// 87A22C0: using guessed type __int16 word_87A22C0;
// 87A22C2: using guessed type __int16 word_87A22C2;
// 87A22C4: using guessed type __int16 word_87A22C4;
// 87A22C6: using guessed type __int16 word_87A22C6;
// 87A22C8: using guessed type __int16 word_87A22C8;
// 87A22CA: using guessed type __int16 word_87A22CA;
// 87A22CC: using guessed type __int16 word_87A22CC;
// 87A22CE: using guessed type __int16 word_87A22CE;
// 87A22D0: using guessed type __int16 word_87A22D0;
// 87A22D2: using guessed type __int16 word_87A22D2;
// 87A22D4: using guessed type __int16 word_87A22D4;
// 87A22D6: using guessed type __int16 word_87A22D6;
// 87A22D8: using guessed type __int16 word_87A22D8;
// 87A22DA: using guessed type __int16 word_87A22DA;
// 87A22DC: using guessed type __int16 word_87A22DC;
// 87A22DE: using guessed type __int16 word_87A22DE;
// 87A22E0: using guessed type __int16 word_87A22E0;
// 87A22E2: using guessed type __int16 word_87A22E2;
// 87A22E4: using guessed type __int16 word_87A22E4;
// 87A22E6: using guessed type __int16 word_87A22E6;
// 87A22E8: using guessed type __int16 word_87A22E8;
// 87A22EA: using guessed type __int16 word_87A22EA;
// 87A22EC: using guessed type __int16 word_87A22EC;
// 87A22EE: using guessed type __int16 word_87A22EE;
// 87A22F0: using guessed type __int16 word_87A22F0;
// 87A22F2: using guessed type __int16 word_87A22F2;
// 87A22F4: using guessed type __int16 word_87A22F4;
// 87A22F6: using guessed type __int16 word_87A22F6;
// 87A22F8: using guessed type __int16 word_87A22F8;
// 87A22FA: using guessed type __int16 word_87A22FA;
// 87A22FC: using guessed type __int16 word_87A22FC;
// 87A22FE: using guessed type __int16 word_87A22FE;
// 87A2300: using guessed type __int16 word_87A2300;
// 87A2302: using guessed type __int16 word_87A2302;
// 87A2304: using guessed type __int16 word_87A2304;
// 87A2306: using guessed type __int16 word_87A2306;
// 87A2308: using guessed type __int16 word_87A2308;
// 87A230A: using guessed type __int16 word_87A230A;
// 87A230C: using guessed type __int16 word_87A230C;
// 87A230E: using guessed type __int16 word_87A230E;
// 87A2310: using guessed type __int16 word_87A2310;
// 87A2312: using guessed type __int16 word_87A2312;
// 87A2314: using guessed type __int16 word_87A2314;
// 87A2316: using guessed type __int16 word_87A2316;
// 87A2318: using guessed type __int16 word_87A2318;
// 87A231A: using guessed type __int16 word_87A231A;
// 87A231C: using guessed type __int16 word_87A231C;
// 87A231E: using guessed type __int16 word_87A231E;
// 87A2320: using guessed type __int16 word_87A2320;
// 87A2322: using guessed type __int16 word_87A2322;
// 87A2324: using guessed type __int16 word_87A2324;
// 87A2326: using guessed type __int16 word_87A2326;
// 87A2328: using guessed type __int16 word_87A2328;
// 87A232A: using guessed type __int16 word_87A232A;
// 87A232C: using guessed type __int16 word_87A232C;
// 87A232E: using guessed type __int16 word_87A232E;
// 87A2330: using guessed type __int16 word_87A2330;
// 87A2332: using guessed type __int16 word_87A2332;
// 87A2334: using guessed type __int16 word_87A2334;
// 87A2336: using guessed type __int16 word_87A2336;
// 87A2338: using guessed type __int16 word_87A2338;
// 87A233A: using guessed type __int16 word_87A233A;
// 87A233C: using guessed type __int16 word_87A233C;
// 87A233E: using guessed type __int16 word_87A233E;
// 87A2340: using guessed type __int16 word_87A2340;
// 87A2342: using guessed type __int16 word_87A2342;
// 87A2344: using guessed type __int16 word_87A2344;
// 87A2346: using guessed type __int16 word_87A2346;
// 87A2348: using guessed type __int16 word_87A2348;
// 87A234A: using guessed type __int16 word_87A234A;
// 87A234C: using guessed type __int16 word_87A234C;
// 87A234E: using guessed type __int16 word_87A234E;
// 87A2350: using guessed type __int16 word_87A2350;
// 87A2352: using guessed type __int16 word_87A2352;

//----- (08120708) --------------------------------------------------------
int __cdecl sub_8120708(int a1)
{
  int result; // eax

  *(_DWORD *)a1 = 0;
  *(_BYTE *)(a1 + 4) = 0;
  *(_BYTE *)(a1 + 5) = 0;
  *(_DWORD *)(a1 + 8) = 0;
  *(_DWORD *)(a1 + 20) = 0;
  *(_DWORD *)(a1 + 12) = 0;
  result = a1;
  *(_DWORD *)(a1 + 16) = 0;
  return result;
}

//----- (0812074C) --------------------------------------------------------
int __cdecl sub_812074C(int a1, int a2)
{
  int result; // eax

  *(_DWORD *)a1 = a2;
  *(_BYTE *)(a1 + 4) = 1;
  *(_BYTE *)(a1 + 5) = 0;
  *(_DWORD *)(a1 + 8) = 0;
  *(_DWORD *)(a1 + 20) = *(_DWORD *)(*(_DWORD *)a1 + 8);
  *(_DWORD *)(a1 + 12) = 0;
  result = a1;
  *(_DWORD *)(a1 + 16) = 0;
  return result;
}

//----- (08120794) --------------------------------------------------------
int __cdecl sub_8120794(int a1, int a2)
{
  int result; // eax

  *(_DWORD *)a1 = a2;
  *(_BYTE *)(a1 + 4) = 0;
  *(_BYTE *)(a1 + 5) = 1;
  *(_DWORD *)(a1 + 8) = 0;
  *(_DWORD *)(a1 + 20) = *(_DWORD *)(*(_DWORD *)a1 + 8);
  *(_DWORD *)(a1 + 12) = 0;
  result = a1;
  *(_DWORD *)(a1 + 16) = 0;
  return result;
}

//----- (081207DC) --------------------------------------------------------
int __cdecl sub_81207DC(int *a1)
{
  char s[64]; // [esp+20h] [ebp-98h] BYREF
  char v4[79]; // [esp+60h] [ebp-58h] BYREF
  unsigned __int8 v5; // [esp+AFh] [ebp-9h]

  v5 = sub_8121100(a1);
  if ( !v5 || v5 > 0x3Fu )
    return 0;
  sub_8120968(a1, v4, v5);
  v4[v5] = 0;
  Com_sprintf(s, 0x40u, "fx/%s", v4);
  return sub_8129F6A((int)s);
}
// 81207DC: using guessed type char var_58[79];

//----- (08120872) --------------------------------------------------------
int __cdecl sub_8120872(int *a1)
{
  char v3[79]; // [esp+20h] [ebp-58h] BYREF
  unsigned __int8 v4; // [esp+6Fh] [ebp-9h]

  v4 = sub_8121100(a1);
  if ( !v4 || v4 > 0x3Fu )
    return 0;
  sub_8120968(a1, v3, v4);
  v3[v4] = 0;
  return sub_812F0DE();
}
// 8120872: using guessed type char var_58[79];

//----- (081208D4) --------------------------------------------------------
int __cdecl sub_81208D4(int *a1)
{
  char s1[79]; // [esp+20h] [ebp-58h] BYREF
  unsigned __int8 v4; // [esp+6Fh] [ebp-9h]

  v4 = sub_8121100(a1);
  if ( !v4 || v4 > 0x3Fu )
    return 0;
  sub_8120968(a1, s1, v4);
  s1[v4] = 0;
  return sub_812F0E8(s1);
}
// 81208D4: using guessed type char s1[79];

//----- (08120936) --------------------------------------------------------
int __cdecl sub_8120936(int *a1, int a2)
{
  int result; // eax

  *(_DWORD *)(a2 + 4) = 0;
  *(float *)(a2 + 8) = sub_8121126(a1);
  result = a2;
  *(_DWORD *)a2 = 0;
  return result;
}

//----- (08120968) --------------------------------------------------------
_BYTE **__cdecl sub_8120968(int *a1, _BYTE *a2, int a3)
{
  char v3; // dl
  _BYTE **result; // eax
  char v5; // al
  _BYTE *v6; // [esp+14h] [ebp-4h] BYREF

  a1[2] += a3;
  v6 = a2;
  do
  {
    while ( !a1[3] )
    {
      while ( a1[4] && a3 )
      {
        --a1[4];
        --a3;
        *v6 = 0;
        result = &v6;
        ++v6;
        if ( !a3 )
          return result;
      }
      v5 = sub_81210DA(*a1);
      if ( (v5 & 0xC0) == 64 )
      {
        a1[3] = 2;
        a1[4] = (v5 & 0x3F) + 1;
      }
      else if ( (v5 & 0xC0u) > 0x40 )
      {
        if ( (v5 & 0xC0) == 128 )
        {
          a1[3] = 4;
          a1[4] = (v5 & 0x3F) + 1;
        }
        else
        {
LABEL_18:
          a1[3] = (v5 & 0x3F) + 1;
          a1[4] = 0;
        }
      }
      else
      {
        if ( (v5 & 0xC0) != 0 )
          goto LABEL_18;
        a1[3] = 1;
        a1[4] = (v5 & 0x3F) + 1;
      }
    }
    --a1[3];
    --a3;
    v3 = sub_81210DA(*a1);
    *v6 = v3;
    result = &v6;
    ++v6;
  }
  while ( a3 );
  return result;
}

//----- (08120AA2) --------------------------------------------------------
int __cdecl sub_8120AA2(int *a1, const char **a2)
{
  size_t v2; // eax
  int result; // eax
  char *s; // [esp+10h] [ebp-8h]
  int v5; // [esp+14h] [ebp-4h]

  if ( a2 )
  {
    s = (char *)*a2;
    v2 = strlen(*a2);
  }
  else
  {
    s = byte_81581A2;
    v2 = strlen(byte_81581A2);
  }
  v5 = v2;
  result = sub_8121152(a1, v2);
  if ( v5 )
    return sub_8120BFA(a1, s, v5);
  return result;
}

//----- (08120B02) --------------------------------------------------------
int __cdecl sub_8120B02(int *a1, int a2)
{
  size_t v2; // eax
  int result; // eax
  char *s; // [esp+10h] [ebp-8h]
  int v5; // [esp+14h] [ebp-4h]

  if ( a2 )
  {
    s = (char *)sub_812ADD4();
    v2 = strlen(s);
  }
  else
  {
    s = byte_81581A2;
    v2 = strlen(byte_81581A2);
  }
  v5 = v2;
  result = sub_8121152(a1, v2);
  if ( v5 )
    return sub_8120BFA(a1, s, v5);
  return result;
}

//----- (08120B70) --------------------------------------------------------
int __cdecl sub_8120B70(int *a1, int a2)
{
  int result; // eax
  char *v3; // [esp+Ch] [ebp-Ch]
  size_t v4; // [esp+14h] [ebp-4h]

  if ( a2 )
    v3 = (char *)sub_80C5414(a2);
  else
    v3 = byte_81581A2;
  v4 = strlen(v3);
  result = sub_8121152(a1, v4);
  if ( v4 )
    return sub_8120BFA(a1, v3, v4);
  return result;
}

//----- (08120BDC) --------------------------------------------------------
int __cdecl sub_8120BDC(int *a1, int a2)
{
  return sub_812117A(a1, *(_DWORD *)(a2 + 8));
}

//----- (08120BFA) --------------------------------------------------------
int __cdecl sub_8120BFA(int *a1, char *a2, int a3)
{
  int result; // eax
  _BYTE *v4; // eax
  int v5; // [esp+Ch] [ebp-Ch]
  int v6; // [esp+10h] [ebp-8h]
  char *v7; // [esp+14h] [ebp-4h]

  a1[2] += a3;
  v7 = a2;
  if ( a1[5] == *(_DWORD *)(*a1 + 8) )
  {
    sub_81210B2(*a1, 192);
    sub_81210B2(*a1, *a2);
    v7 = a2 + 1;
    --a3;
  }
  v6 = 0;
LABEL_4:
  while ( 1 )
  {
    result = v6;
    if ( v6 >= a3 )
      return result;
    v5 = *(_BYTE *)(*(_DWORD *)*a1 + a1[5]) & 0xC0;
    if ( v5 == 64 )
      goto LABEL_10;
    if ( (*(_BYTE *)(*(_DWORD *)*a1 + a1[5]) & 0xC0u) <= 0x40 )
    {
      if ( (*(_BYTE *)(*(_DWORD *)*a1 + a1[5]) & 0xC0) == 0 )
        goto LABEL_10;
      while ( 1 )
      {
LABEL_15:
        if ( v6 >= a3 )
          goto LABEL_4;
        if ( (*(_BYTE *)(*(_DWORD *)*a1 + a1[5]) & 0x3F) != 0 )
        {
          switch ( *(_BYTE *)(*(_DWORD *)*a1 + a1[5]) & 0x3F )
          {
            case 1:
              if ( !v7[v6] )
              {
                *(_BYTE *)(*(_DWORD *)*a1 + a1[5]) = 64;
                ++v6;
                goto LABEL_4;
              }
              break;
            case 3:
              if ( !v7[v6] )
              {
                *(_BYTE *)(*(_DWORD *)*a1 + a1[5]) = 0x80;
                ++v6;
                goto LABEL_4;
              }
              break;
            case 63:
              a1[5] = *(_DWORD *)(*a1 + 8);
              sub_81210B2(*a1, 192);
              sub_81210B2(*a1, v7[v6++]);
              continue;
            default:
              if ( (*(_BYTE *)(*(_DWORD *)*a1 + a1[5]) & 0x3Fu) > 5
                && !v7[v6]
                && !*(_BYTE *)(*(_DWORD *)*a1 + *(_DWORD *)(*a1 + 8) - 2)
                && !*(_BYTE *)(*(_DWORD *)*a1 + *(_DWORD *)(*a1 + 8) - 1) )
              {
                *(_BYTE *)(a1[5] + *(_DWORD *)*a1) = *(_BYTE *)(*(_DWORD *)*a1 + a1[5]) - 3;
                *(_BYTE *)(*(_DWORD *)*a1 + *(_DWORD *)(*a1 + 8) - 2) = *(_BYTE *)(*(_DWORD *)*a1
                                                                                 + *(_DWORD *)(*a1 + 8)
                                                                                 - 3);
                *(_BYTE *)(*(_DWORD *)*a1 + *(_DWORD *)(*a1 + 8) - 3) = 2;
                a1[5] = *(_DWORD *)(*a1 + 8) - 3;
                --*(_DWORD *)(*a1 + 8);
                ++v6;
                goto LABEL_4;
              }
              break;
          }
        }
        else if ( !v7[v6] )
        {
          *(_BYTE *)(*(_DWORD *)*a1 + a1[5]) = 0;
          ++v6;
          goto LABEL_4;
        }
        v4 = (_BYTE *)(*(_DWORD *)*a1 + a1[5]);
        ++*v4;
        sub_81210B2(*a1, v7[v6++]);
      }
    }
    if ( v5 != 128 )
      goto LABEL_15;
LABEL_10:
    while ( v6 < a3 )
    {
      if ( v7[v6] || (*(_BYTE *)(*(_DWORD *)*a1 + a1[5]) & 0x3F) == 63 )
      {
        a1[5] = *(_DWORD *)(*a1 + 8);
        sub_81210B2(*a1, 192);
        sub_81210B2(*a1, v7[v6++]);
        goto LABEL_4;
      }
      ++*(_BYTE *)(*(_DWORD *)*a1 + a1[5]);
      ++v6;
    }
  }
}

//----- (08120F84) --------------------------------------------------------
_BYTE **__cdecl sub_8120F84(int a1, char *a2, int a3)
{
  if ( *(_BYTE *)(a1 + 4) )
    return sub_8120968((int *)a1, a2, a3);
  else
    return (_BYTE **)sub_8120BFA((int *)a1, a2, a3);
}

//----- (08120FCA) --------------------------------------------------------
int __cdecl sub_8120FCA(int a1, const char ***a2)
{
  int result; // eax

  if ( !*(_BYTE *)(a1 + 4) )
    return sub_8120AA2((int *)a1, *a2);
  result = sub_81207DC((int *)a1);
  *a2 = (const char **)result;
  return result;
}

//----- (08121006) --------------------------------------------------------
int __cdecl sub_8121006(int a1, int *a2)
{
  int v2; // edx
  int result; // eax

  if ( !*(_BYTE *)(a1 + 4) )
    return sub_8120B02((int *)a1, *a2);
  v2 = sub_8120872((int *)a1);
  result = (int)a2;
  *a2 = v2;
  return result;
}

//----- (08121040) --------------------------------------------------------
int __cdecl sub_8121040(int a1, int *a2)
{
  int v2; // edx
  int result; // eax

  if ( !*(_BYTE *)(a1 + 4) )
    return sub_8120B70((int *)a1, *a2);
  v2 = sub_81208D4((int *)a1);
  result = (int)a2;
  *a2 = v2;
  return result;
}

//----- (0812107A) --------------------------------------------------------
int __cdecl sub_812107A(int a1, int a2)
{
  if ( *(_BYTE *)(a1 + 4) )
    return sub_8120936((int *)a1, a2);
  else
    return sub_8120BDC((int *)a1, a2);
}

//----- (081210B2) --------------------------------------------------------
int __cdecl sub_81210B2(int a1, char a2)
{
  char src; // [esp+17h] [ebp-1h] BYREF

  src = a2;
  return sub_80B3636(a1, 1u, &src);
}

//----- (081210DA) --------------------------------------------------------
int __cdecl sub_81210DA(int a1)
{
  unsigned __int8 dest; // [esp+17h] [ebp-1h] BYREF

  MemFile_ReadData(a1, 1u, &dest);
  return dest;
}

//----- (08121100) --------------------------------------------------------
int __cdecl sub_8121100(int *a1)
{
  unsigned __int8 v2; // [esp+17h] [ebp-1h] BYREF

  sub_8120968(a1, &v2, 1);
  return v2;
}

//----- (08121126) --------------------------------------------------------
long double __cdecl sub_8121126(int *a1)
{
  float v2; // [esp+14h] [ebp-4h] BYREF

  sub_8120968(a1, &v2, 4);
  return v2;
}

//----- (08121152) --------------------------------------------------------
int __cdecl sub_8121152(int *a1, char a2)
{
  char v3; // [esp+17h] [ebp-1h] BYREF

  v3 = a2;
  return sub_8120BFA(a1, &v3, 1);
}

//----- (0812117A) --------------------------------------------------------
int sub_812117A(int *a1, ...)
{
  va_list va; // [esp+24h] [ebp+Ch] BYREF

  va_start(va, a1);
  return sub_8120BFA(a1, (char *)va, 4);
}

//----- (0812119C) --------------------------------------------------------
int __cdecl sub_812119C(_DWORD *a1, int a2, int a3, int a4)
{
  int i; // [esp+18h] [ebp-60h]
  int src[22]; // [esp+20h] [ebp-58h] BYREF

  src[19] = 2;
  src[0] = 0;
  src[a2 + 1] = 1065353216;
  for ( i = 0; i != a2; ++i )
  {
    src[i + 1] = a3;
    src[i + 2 + a2] = a4;
  }
  *a1 = sub_8121AAC((float *)src, a2, 2);
  return sub_812F15A(a1 + 1, 1065353216, 1065353216);
}

//----- (0812123C) --------------------------------------------------------
int __cdecl sub_812123C(int *a1, int *a2)
{
  int v2; // edx
  int result; // eax

  *a2 = sub_8121C40(*a1);
  v2 = a1[2];
  result = a1[1];
  a2[1] = result;
  a2[2] = v2;
  return result;
}

//----- (08121272) --------------------------------------------------------
_DWORD *__cdecl sub_8121272(_DWORD *a1, int a2, int a3, int a4)
{
  _DWORD *result; // eax
  int i; // [esp+18h] [ebp-50h]
  int src[18]; // [esp+20h] [ebp-48h] BYREF

  src[0] = 0;
  src[a2 + 1] = 1065353216;
  for ( i = 0; i != a2; ++i )
  {
    src[i + 1] = *(_DWORD *)(a3 + 4 * i);
    src[i + 2 + a2] = *(_DWORD *)(a4 + 4 * i);
  }
  result = sub_8121AAC((float *)src, a2, 2);
  *a1 = result;
  return result;
}

//----- (08121304) --------------------------------------------------------
_DWORD *__cdecl sub_8121304(_DWORD *a1, int a2, int a3, int a4, int a5)
{
  _DWORD *result; // eax
  int i; // [esp+18h] [ebp-70h]
  int v7; // [esp+1Ch] [ebp-6Ch]
  int src[26]; // [esp+20h] [ebp-68h] BYREF

  v7 = a2 + 1;
  src[0] = 0;
  src[a2 + 1] = a5;
  src[2 * a2 + 2] = 1065353216;
  for ( i = 0; i != a2; ++i )
  {
    src[i + 1] = *(_DWORD *)(a3 + 4 * i);
    src[i + 1 + v7] = *(_DWORD *)(a3 + 4 * i);
    src[2 * v7 + 1 + i] = *(_DWORD *)(a4 + 4 * i);
  }
  result = sub_8121AAC((float *)src, a2, 3);
  *a1 = result;
  return result;
}

//----- (081213C4) --------------------------------------------------------
_DWORD *__cdecl sub_81213C4(_DWORD *a1, int a2, char a3, int a4, int a5, float a6, float a7)
{
  _DWORD *result; // eax
  float v8; // [esp+1Ch] [ebp-22Ch]
  float v9; // [esp+20h] [ebp-228h]
  float v10; // [esp+20h] [ebp-228h]
  float v11; // [esp+24h] [ebp-224h]
  int i; // [esp+28h] [ebp-220h]
  int v13; // [esp+30h] [ebp-218h]
  float v14; // [esp+34h] [ebp-214h]
  int v15; // [esp+38h] [ebp-210h]
  float v16; // [esp+3Ch] [ebp-20Ch]
  float src[130]; // [esp+40h] [ebp-208h] BYREF

  v13 = a2 + 1;
  v15 = 0;
  v16 = 0.0;
  while ( v15 != 16 )
  {
    if ( v16 > 1.0 )
      v16 = 1.0;
    v11 = 1.0;
    v9 = 1.0;
    if ( (a3 & 1) != 0 )
      v11 = 1.0 - v16;
    switch ( a3 & 0xC )
    {
      case 4:
        if ( v16 > (long double)a6 )
          v9 = 1.0 - (v16 - a6) / (1.0 - a6);
        if ( (a3 & 1) != 0 )
          v11 = v11 * 0.5 + v9 * 0.5;
        else
          v11 = v9;
        break;
      case 8:
        v8 = cos(v16 * a7);
        v11 = v8 * v11;
        break;
      case 12:
        if ( a6 <= (long double)v16 )
          v10 = 0.0;
        else
          v10 = (a6 - v16) / a6;
        if ( (a3 & 1) != 0 )
          v11 = v11 * 0.5 + v10 * 0.5;
        else
          v11 = v10;
        break;
    }
    src[v13 * v15] = v16;
    for ( i = 0; i != a2; ++i )
    {
      v14 = *(float *)(a4 + 4 * i) * v11 + (1.0 - v11) * *(float *)(a5 + 4 * i);
      if ( v14 >= 0.0 )
      {
        if ( v11 > 1.0 )
          v14 = 1.0;
      }
      else
      {
        v14 = 0.0;
      }
      if ( (a3 & 2) != 0 )
        v14 = sub_80A8720(0.0, v14);
      src[v13 * v15 + 1 + i] = v14;
    }
    ++v15;
    v16 = v16 + 0.06666667;
  }
  result = sub_8121AAC(src, a2, 16);
  *a1 = result;
  return result;
}
// 81213C4: using guessed type float src[130];

//----- (081216CE) --------------------------------------------------------
_DWORD *__cdecl sub_81216CE(int a1, int a2, float a3, char a4, _DWORD *a5)
{
  long double v5; // fst7
  long double v6; // fst7
  long double v7; // fst7
  long double v8; // fst7
  float v10; // [esp+0h] [ebp-88h]
  int v11; // [esp+4h] [ebp-84h]
  int v12; // [esp+8h] [ebp-80h]
  float v13; // [esp+2Ch] [ebp-5Ch]
  int i; // [esp+3Ch] [ebp-4Ch]
  int v15; // [esp+40h] [ebp-48h]
  float v16; // [esp+44h] [ebp-44h]
  int v17; // [esp+48h] [ebp-40h]
  float v18; // [esp+4Ch] [ebp-3Ch]
  float v19[4]; // [esp+50h] [ebp-38h] BYREF
  float v20[4]; // [esp+60h] [ebp-28h] BYREF
  float v21; // [esp+70h] [ebp-18h]
  float v22; // [esp+74h] [ebp-14h]
  float v23; // [esp+78h] [ebp-10h]
  char v24; // [esp+7Fh] [ebp-9h]

  v24 = a4;
  v23 = 1.0;
  if ( !a4 )
  {
    v13 = sub_812F1B8((float *)(a1 + 24), 0.5);
    v5 = sub_812F1B8((float *)a1, 0.5);
    v10 = v5;
    sub_81218EE(v10, v13);
    v23 = v5 * 1.3333334;
  }
  if ( v23 < 1.0 )
    v23 = 1.0;
  v21 = (*(float *)(a1 + 4) - *(float *)a1) / 2.0;
  *(float *)&v12 = v23 + v21;
  *(float *)&v11 = v23 - v21;
  sub_812F15A(a5 + 1, v11, v12);
  v22 = 1.0 / v23;
  v18 = 0.0;
  for ( i = 0; i != a2; ++i )
  {
    v6 = sub_812F1B8((float *)(a1 + 8 * i), 0.5);
    v20[i] = v6 * v22;
    v7 = sub_812F1B8((float *)(a1 + 8 * i + 24), 0.5);
    v19[i] = v7 * v22;
    v8 = sub_812F1B8((float *)(a1 + 48), 0.5);
    v18 = v8 * v22;
  }
  *(float *)&v17 = v18 * 0.0099999998;
  v15 = *(_DWORD *)(a1 + 56);
  if ( (v15 & 1) != 0 && (v15 & 0xC) == 0 )
    return sub_8121272(a5, a2, (int)v20, (int)v19);
  if ( (((unsigned __int8)v15 ^ 1) & 1) != 0 && (*(_DWORD *)(a1 + 56) & 0xC) == 4 )
    return sub_8121304(a5, a2, (int)v20, (int)v19, v17);
  v16 = v18 * 0.003141593 * a3;
  return sub_81213C4(a5, a2, v15, (int)v20, (int)v19, *(float *)&v17, v16);
}
// 81216CE: using guessed type float var_28[4];
// 81216CE: using guessed type float var_38[4];

//----- (081218EE) --------------------------------------------------------
void __cdecl sub_81218EE(float a1, float a2)
{
  float v2; // [esp+0h] [ebp-18h]

  v2 = a1 - a2;
  sub_8121912(v2, a1, a2);
}

//----- (08121912) --------------------------------------------------------
long double __cdecl sub_8121912(float a1, float a2, float a3)
{
  if ( a1 < 0.0 )
    return a3;
  return a2;
}

//----- (0812193C) --------------------------------------------------------
_DWORD *__cdecl sub_812193C(_DWORD *a1, int a2)
{
  _DWORD *result; // eax

  *a1 = a2;
  result = a1;
  a1[1] = 0;
  return result;
}

//----- (08121962) --------------------------------------------------------
long double __cdecl sub_8121962(float a1, float a2, float a3, float a4)
{
  return (a3 + a4) * 0.5 * (a2 - a1);
}

//----- (0812197E) --------------------------------------------------------
long double __cdecl sub_812197E(_DWORD *a1, float a2)
{
  float *v3; // [esp+20h] [ebp-18h]
  float *v4; // [esp+24h] [ebp-14h]
  float v5; // [esp+28h] [ebp-10h]
  int v6; // [esp+2Ch] [ebp-Ch]
  float v7; // [esp+34h] [ebp-4h]

  v6 = *a1 + 1;
  v3 = (float *)(a1 + 2);
  v4 = (float *)&a1[v6 + 2];
  v7 = 0.0;
  while ( a2 > (long double)*v4 )
  {
    v7 = sub_8121962(*v3, *v4, v3[1], v4[1]) + v7;
    v3 = v4;
    v4 += v6;
  }
  v5 = sub_8121A60(v3, a2);
  return (float)(sub_8121962(*v3, a2, v3[1], v5) + v7);
}

//----- (08121A60) --------------------------------------------------------
long double __cdecl sub_8121A60(float *a1, float a2)
{
  return (a2 - *a1) * (a1[3] - a1[1]) / (a1[2] - *a1) + a1[1];
}

//----- (08121AAC) --------------------------------------------------------
_DWORD *__cdecl sub_8121AAC(float *src, int a2, int a3)
{
  int v4; // [esp+18h] [ebp-20h]
  int v5; // [esp+1Ch] [ebp-1Ch]
  int v6; // [esp+20h] [ebp-18h]
  _DWORD *v7; // [esp+24h] [ebp-14h]
  int i; // [esp+28h] [ebp-10h]
  int j; // [esp+28h] [ebp-10h]
  int v10; // [esp+2Ch] [ebp-Ch]
  int v11; // [esp+2Ch] [ebp-Ch]
  bool v12; // [esp+36h] [ebp-2h]
  bool v13; // [esp+37h] [ebp-1h]

  v6 = a2 + 1;
  v13 = 0.0 != *src;
  v12 = 1.0 != *(float *)((char *)src + (a2 + 1) * (4 * a3 - 4));
  v5 = a3;
  if ( 0.0 != *src )
    v5 = a3 + 1;
  v4 = v5;
  if ( 1.0 != *(float *)((char *)src + (a2 + 1) * (4 * a3 - 4)) )
    v4 = v5 + 1;
  v7 = Hunk_AllocAlignInternal(4 * v4 * v6 + 8, 4);
  *v7 = a2;
  v10 = 0;
  if ( v13 )
  {
    v7[2] = 0;
    for ( i = 0; i != a2; ++i )
      v7[i + 3] = LODWORD(src[i + 1]);
    v10 = 1;
  }
  memcpy(&v7[v6 * v10 + 2], src, 4 * v6 * a3);
  v11 = a3 + v10;
  if ( v12 )
  {
    v7[v6 * v11 + 2] = 1065353216;
    for ( j = 0; j != a2; ++j )
      v7[j + 3 + v6 * v11] = LODWORD(src[j + 1]);
  }
  v7[1] = a3;
  return v7;
}

//----- (08121C40) --------------------------------------------------------
int __cdecl sub_8121C40(int a1)
{
  return a1;
}

//----- (08121C48) --------------------------------------------------------
unsigned int *FxMem_Init()
{
  unsigned int *result; // eax
  unsigned int i; // [esp+0h] [ebp-8h] BYREF
  _DWORD *v2; // [esp+4h] [ebp-4h]

  v2 = &unk_87A2380;
  for ( i = 0; i <= 0x1FFFFF; i += 0x8000 )
  {
    v2[8188] = -1;
    v2 += 0x2000;
    result = &i;
  }
  return result;
}

//----- (08121C8A) --------------------------------------------------------
int *__cdecl sub_8121C8A(int a1, int a2, int a3)
{
  unsigned int i; // [esp+10h] [ebp-8h]
  int j; // [esp+10h] [ebp-8h]
  int *v7; // [esp+14h] [ebp-4h]

  v7 = (int *)&unk_87A2380;
  for ( i = 0; ; i += 0x8000 )
  {
    if ( i > 0x1FFFFF )
    {
      Com_DPrintf("^1Out of effects memory!\n");
      return 0;
    }
    if ( v7[8188] < 0 )
      break;
    v7 += 0x2000;
  }
  if ( dword_89A2380 < (int)(i + 0x8000) )
    dword_89A2380 = i + 0x8000;
  v7[8188] = a2;
  for ( j = 0; j < a2 - 1; ++j )
    *(int *)((char *)v7 + a3 * j) = (int)v7 + a3 * (j + 1);
  *(int *)((char *)v7 + a3 * j) = 0;
  v7[8189] = (int)v7;
  if ( a1 )
    *(_DWORD *)(a1 + 32764) = v7;
  v7[8190] = a1;
  v7[0x1FFF] = 0;
  return v7;
}
// 89A2380: using guessed type int dword_89A2380;

//----- (08121D9A) --------------------------------------------------------
int __cdecl sub_8121D9A(int a1)
{
  int result; // eax

  if ( *(_DWORD *)(a1 + 32764) )
    *(_DWORD *)(*(_DWORD *)(a1 + 32764) + 32760) = *(_DWORD *)(a1 + 32760);
  if ( *(_DWORD *)(a1 + 32760) )
    *(_DWORD *)(*(_DWORD *)(a1 + 32760) + 32764) = *(_DWORD *)(a1 + 32764);
  *(_DWORD *)(a1 + 32764) = 0;
  result = a1;
  *(_DWORD *)(a1 + 32760) = 0;
  return result;
}

//----- (08121E02) --------------------------------------------------------
int __cdecl sub_8121E02(int a1)
{
  int result; // eax

  sub_8121D9A(a1);
  result = a1;
  *(_DWORD *)(a1 + 32752) = -1;
  return result;
}

//----- (08121E22) --------------------------------------------------------
char *__cdecl sub_8121E22(char *a1)
{
  char *v1; // edx

  *(_DWORD *)a1 = *(_DWORD *)((char *)&unk_87A2380 + ((a1 - (char *)&unk_87A2380) & 0xFFFF8000) + 32756);
  v1 = (char *)&unk_87A2380 + ((a1 - (char *)&unk_87A2380) & 0xFFFF8000);
  *((_DWORD *)v1 + 8189) = a1;
  ++*((_DWORD *)v1 + 8188);
  return v1;
}

//----- (08121E7C) --------------------------------------------------------
void __cdecl sub_8121E7C(int a1, int a2)
{
  int i; // [esp+20h] [ebp-8h]

  for ( i = 0; i <= 2; ++i )
    *(_BYTE *)(i + a2) = sub_8127000((int)(*(float *)(a1 + 4 * i) * 255.0), 0, 255);
}

//----- (08121EF6) --------------------------------------------------------
_DWORD *__userpurge sub_8121EF6@<eax>(_DWORD *a1, _DWORD *a2)
{
  int *v3; // [esp+20h] [ebp-8h]
  _DWORD *i; // [esp+24h] [ebp-4h]

  for ( i = (_DWORD *)dword_89A2388; i; i = (_DWORD *)i[14] )
  {
    if ( i[15] == *a2 && i[16] == a2[1] )
    {
      sub_8127798(a1, i);
      return a1;
    }
  }
  v3 = sub_8127752(68);
  sub_81220BE(v3, a2);
  sub_8127798(a1, v3);
  return a1;
}
// 89A2388: using guessed type int dword_89A2388;

//----- (08121FB2) --------------------------------------------------------
int __cdecl sub_8121FB2(int a1)
{
  int result; // eax
  int *i; // [esp+4h] [ebp-4h]

  --*(_DWORD *)a1;
  result = a1;
  if ( !*(_DWORD *)a1 )
  {
    for ( i = &dword_89A2388; *i; i = (int *)(*i + 56) )
    {
      if ( *i == a1 )
      {
        *i = *(_DWORD *)(a1 + 56);
        return sub_812776E((char *)a1);
      }
    }
    return sub_812776E((char *)a1);
  }
  return result;
}
// 89A2388: using guessed type int dword_89A2388;

//----- (08122008) --------------------------------------------------------
_DWORD *__cdecl sub_8122008(_DWORD *a1)
{
  if ( (int)a1[15] < 0 )
    return 0;
  if ( a1[1] == dword_848B0B0 )
    return a1 + 2;
  a1[1] = dword_848B0B0;
  if ( (unsigned __int8)FX_GetBoneOrientation() )
    return a1 + 2;
  a1[15] = -1;
  a1[16] = -1;
  return 0;
}
// 848B0B0: using guessed type int dword_848B0B0;

//----- (081220BE) --------------------------------------------------------
_DWORD *__cdecl sub_81220BE(_DWORD *a1, _DWORD *a2)
{
  int v2; // edx
  _DWORD *result; // eax

  *a1 = 0;
  a1[1] = 0;
  v2 = a2[1];
  a1[15] = *a2;
  a1[16] = v2;
  a1[14] = dword_89A2388;
  result = a1;
  dword_89A2388 = (int)a1;
  return result;
}
// 89A2388: using guessed type int dword_89A2388;

//----- (081220FC) --------------------------------------------------------
_DWORD *__cdecl sub_81220FC(int *a1, int *a2)
{
  int v3[6]; // [esp+20h] [ebp-28h] BYREF
  int v4[3]; // [esp+38h] [ebp-10h] BYREF

  if ( (unsigned __int8)sub_8127A4A((int)a2) )
  {
    v4[0] = sub_8127A56(a2);
    if ( v4[0] < 0 )
    {
      return sub_8127840(a1, 0);
    }
    else
    {
      v4[1] = sub_8127A56(a2);
      sub_8121EF6(v3, v4);
      sub_81277D4(a1, v3);
      return (_DWORD *)sub_81277B6(v3);
    }
  }
  else if ( *a1 )
  {
    sub_8127A7C(a2, *(_DWORD *)(*a1 + 60));
    return (_DWORD *)sub_8127A7C(a2, *(_DWORD *)(*a1 + 64));
  }
  else
  {
    return (_DWORD *)sub_8127A7C(a2, -1);
  }
}
// 81220FC: using guessed type int var_28[6];

//----- (081221F2) --------------------------------------------------------
void *__cdecl sub_81221F2(size_t a1)
{
  return Hunk_AllocInternal(a1);
}

//----- (08122206) --------------------------------------------------------
int __cdecl sub_8122206(char *s2)
{
  return XModelPrecache(s2, (int (__cdecl *)(int))sub_81221F2, (int (__cdecl *)(int))sub_81221F2);
}

//----- (0812222A) --------------------------------------------------------
_DWORD *__cdecl sub_812222A(_DWORD *a1)
{
  *a1 = off_81584A8;
  return sub_812778A(a1 + 48);
}
// 81584A8: using guessed type int (__cdecl *off_81584A8[2])(int);

//----- (0812226E) --------------------------------------------------------
int __cdecl sub_812226E(_DWORD *a1)
{
  *a1 = off_81584A8;
  sub_81277B6(a1 + 48);
  return 0;
}
// 81584A8: using guessed type int (__cdecl *off_81584A8[2])(int);

//----- (081222A6) --------------------------------------------------------
int __cdecl sub_81222A6(_DWORD *a1)
{
  *a1 = off_81584A8;
  sub_81277B6(a1 + 48);
  return 0;
}
// 81584A8: using guessed type int (__cdecl *off_81584A8[2])(int);

//----- (081222DE) --------------------------------------------------------
int __cdecl sub_81222DE(int a1)
{
  *(_DWORD *)a1 = off_81584A8;
  sub_81277B6((int *)(a1 + 192));
  return sub_81278B0((char *)a1);
}
// 81584A8: using guessed type int (__cdecl *off_81584A8[2])(int);

//----- (08122316) --------------------------------------------------------
void sub_8122316()
{
  ;
}

//----- (0812231C) --------------------------------------------------------
int sub_812231C()
{
  return 0;
}

//----- (08122326) --------------------------------------------------------
void sub_8122326()
{
  ;
}

//----- (0812232C) --------------------------------------------------------
_BOOL4 __cdecl sub_812232C(int a1, _DWORD *a2)
{
  _DWORD *v2; // eax
  _BOOL4 v4; // [esp+4h] [ebp-4h]

  v4 = 1;
  if ( sub_812782E((_DWORD *)(a1 + 192)) )
  {
    v2 = (_DWORD *)sub_812787E(a1 + 192);
    *a2 = sub_8122008(v2);
    if ( !*a2 )
      return 0;
  }
  return v4;
}

//----- (08122382) --------------------------------------------------------
int __cdecl sub_8122382(int a1)
{
  if ( (*(_DWORD *)(a1 + 168) & 0x2000000) != 0 )
    return sub_8126F9C(5, *(_DWORD *)(off_8168620 + 128));
  else
    return *(_DWORD *)(off_8168620 + 128);
}

//----- (081223CE) --------------------------------------------------------
int __cdecl sub_81223CE(int a1)
{
  if ( *(_DWORD *)(a1 + 184) > *(_DWORD *)(off_8168620 + 4) )
    return 0;
  *(float *)(a1 + 60) = (long double)(*(_DWORD *)(off_8168620 + 4) - *(_DWORD *)(a1 + 184))
                      / (long double)sub_8127896(a1);
  if ( *(float *)(a1 + 60) > 1.0 )
    *(_DWORD *)(a1 + 60) = 1065353216;
  if ( *(float *)(a1 + 60) < 0.0 )
    *(_DWORD *)(a1 + 60) = 0;
  return 1;
}

//----- (08122472) --------------------------------------------------------
int __cdecl sub_8122472(int a1, int a2, int a3)
{
  int result; // eax

  *(_DWORD *)(a1 + 184) = a2;
  result = a3;
  *(_DWORD *)(a1 + 188) = a3;
  return result;
}

//----- (08122490) --------------------------------------------------------
int __cdecl sub_8122490(int a1)
{
  return *(_DWORD *)(off_8168620 + 4) - *(_DWORD *)(a1 + 184);
}

//----- (081224B2) --------------------------------------------------------
_DWORD *__cdecl sub_81224B2(int a1, _DWORD *a2)
{
  return sub_81277D4((int *)(a1 + 192), a2);
}

//----- (081224D2) --------------------------------------------------------
int sub_81224D2()
{
  return 0;
}

//----- (081224DC) --------------------------------------------------------
int __cdecl sub_81224DC(int a1, int *a2)
{
  int result; // eax

  sub_8127B04((int)a2, (char *)(a1 + 4));
  sub_8127AC0((int)a2, (char *)(a1 + 184));
  sub_8127AC0((int)a2, (char *)(a1 + 188));
  sub_8127AC0((int)a2, (char *)(a1 + 168));
  sub_8127AC0((int)a2, (char *)(a1 + 16));
  sub_8127B04((int)a2, (char *)(a1 + 20));
  sub_8127B04((int)a2, (char *)(a1 + 32));
  sub_8120FCA((int)a2, (const char ***)(a1 + 44));
  sub_8120FCA((int)a2, (const char ***)(a1 + 48));
  sub_8120F84((int)a2, (char *)(a1 + 64), 104);
  sub_8120FCA((int)a2, (const char ***)(a1 + 52));
  sub_8127AC0((int)a2, (char *)(a1 + 56));
  sub_8121006((int)a2, (int *)(a1 + 64));
  sub_8121040((int)a2, (int *)(a1 + 180));
  sub_81220FC((int *)(a1 + 192), a2);
  result = sub_8127A4A((int)a2);
  if ( (_BYTE)result )
  {
    *(_DWORD *)(a1 + 172) = sub_8130F90((float *)(a1 + 124));
    return sub_8133348(a1);
  }
  return result;
}

//----- (08122668) --------------------------------------------------------
void sub_8122668()
{
  ;
}

//----- (0812266E) --------------------------------------------------------
void __cdecl sub_812266E(int a1, int a2)
{
  int s; // [esp+10h] [ebp-88h] BYREF
  int v3; // [esp+14h] [ebp-84h]
  _DWORD v4[10]; // [esp+24h] [ebp-74h] BYREF
  int v5[3]; // [esp+4Ch] [ebp-4Ch] BYREF
  _DWORD v6[4]; // [esp+58h] [ebp-40h] BYREF
  char v7; // [esp+68h] [ebp-30h]
  char v8; // [esp+69h] [ebp-2Fh]
  char v9; // [esp+6Ah] [ebp-2Eh]
  char v10; // [esp+6Bh] [ebp-2Dh]
  int v11; // [esp+70h] [ebp-28h]
  int v12; // [esp+74h] [ebp-24h]
  int v13; // [esp+78h] [ebp-20h]
  int v14; // [esp+7Ch] [ebp-1Ch]

  memset(&s, 0, 0x74u);
  s = a2;
  v6[3] = *(_DWORD *)(a1 + 64);
  v14 = *(_DWORD *)(a1 + 68);
  sub_80A6FE6((_DWORD *)(a1 + 72), v4);
  sub_8127108((_DWORD *)(a1 + 124), v5);
  v12 = *(_DWORD *)(a1 + 136);
  v13 = *(_DWORD *)(a1 + 140);
  v7 = *(_BYTE *)(a1 + 144);
  v8 = *(_BYTE *)(a1 + 145);
  v9 = *(_BYTE *)(a1 + 146);
  v10 = *(_BYTE *)(a1 + 147);
  v11 = *(_DWORD *)(a1 + 148);
  v4[9] = *(_DWORD *)(a1 + 152);
  sub_8127108((_DWORD *)(a1 + 156), v6);
  if ( (*(_BYTE *)(a1 + 168) & 1) != 0 )
    v3 |= 8u;
  if ( (*(_DWORD *)(a1 + 168) & 0x4000000) != 0 )
    v3 |= 0x80u;
  sub_812ADC0();
}
// 812266E: using guessed type int anonymous_0[3];

//----- (081227C4) --------------------------------------------------------
int __cdecl sub_81227C4(_DWORD *a1)
{
  sub_812222A(a1);
  *a1 = off_8158468;
  return sub_81270BA(a1 + 49);
}
// 8158468: using guessed type int (__cdecl *off_8158468[6])(int);

//----- (081227F0) --------------------------------------------------------
int __cdecl sub_81227F0(_DWORD *a1)
{
  sub_812222A(a1);
  *a1 = off_8158468;
  return sub_81270BA(a1 + 49);
}
// 8158468: using guessed type int (__cdecl *off_8158468[6])(int);

//----- (0812281C) --------------------------------------------------------
int __cdecl sub_812281C(_DWORD *a1)
{
  *a1 = off_8158468;
  sub_812226E(a1);
  return 0;
}
// 8158468: using guessed type int (__cdecl *off_8158468[6])(int);

//----- (08122850) --------------------------------------------------------
int __cdecl sub_8122850(_DWORD *a1)
{
  *a1 = off_8158468;
  sub_812226E(a1);
  return 0;
}
// 8158468: using guessed type int (__cdecl *off_8158468[6])(int);

//----- (08122884) --------------------------------------------------------
int __cdecl sub_8122884(char *a1)
{
  *(_DWORD *)a1 = off_8158468;
  sub_812226E(a1);
  return sub_812795A(a1);
}
// 8158468: using guessed type int (__cdecl *off_8158468[6])(int);

//----- (081228B8) --------------------------------------------------------
void __cdecl sub_81228B8(int a1)
{
  int v1; // esi
  long double v2; // fst7
  int v3; // [esp+4h] [ebp-44h]
  float v4; // [esp+4h] [ebp-44h]
  int v5; // [esp+1Ch] [ebp-2Ch]
  int v6; // [esp+1Ch] [ebp-2Ch]
  float v7; // [esp+2Ch] [ebp-1Ch]
  int v8[6]; // [esp+30h] [ebp-18h] BYREF

  if ( (*(_DWORD *)(a1 + 168) & 0x200) != 0 && (*(_DWORD *)(a1 + 168) & 0x400) == 0 && *(_DWORD *)(a1 + 48) )
  {
    *(float *)&v5 = sub_80A8720(-1.0, 1.0);
    v1 = v5;
    *(float *)&v6 = sub_80A8720(-1.0, 1.0);
    v2 = sub_80A8720(-1.0, 1.0);
    *(float *)&v3 = v2;
    sub_81270E4(v8, v3, v6, v1);
    sub_812734C((float *)v8);
    v7 = v2;
    if ( v7 >= 0.000001 )
    {
      v4 = 1.0 / v7;
      sub_81271EE((float *)v8, v4, (float *)v8);
    }
    else
    {
      sub_81270E4(v8, 0, 0, 1065353216);
    }
    sub_8128900((int *)dword_89A2814, *(_DWORD *)(a1 + 48), (float *)(a1 + 4), v8);
  }
}

//----- (081229F0) --------------------------------------------------------
int __cdecl sub_81229F0(int a1)
{
  int v1; // eax

  v1 = sub_8122382(a1);
  return (unsigned __int8)sub_812AB74(off_8168620, (float *)(a1 + 124), *(float *)(a1 + 136), v1);
}

//----- (08122A2E) --------------------------------------------------------
void __cdecl sub_8122A2E(int a1)
{
  if ( *(float *)(a1 + 136) != 0.0 && *(float *)(a1 + 140) != 0.0 )
    sub_812266E(a1, 4);
}

//----- (08122A76) --------------------------------------------------------
int __cdecl sub_8122A76(float *a1)
{
  float *v3; // [esp+14h] [ebp-4h] BYREF

  v3 = 0;
  if ( !(unsigned __int8)sub_81223CE((int)a1) )
    return 0;
  if ( !sub_812232C((int)a1, &v3) )
    return 0;
  if ( !(unsigned __int8)sub_81232B2((int)a1, v3) )
    return 0;
  if ( v3 )
    sub_80B6758(v3, a1 + 1, a1 + 31);
  else
    sub_8127108((_DWORD *)a1 + 1, (_DWORD *)a1 + 31);
  sub_8123F5C((int)a1);
  if ( a1[34] == 0.0 )
    return 1;
  sub_8123FE0((int)a1);
  if ( a1[35] != 0.0 )
  {
    sub_8124080((int)a1);
    sub_812410E((int)a1);
    sub_812427C((int)a1);
    sub_812430C((int)a1);
  }
  return 1;
}

//----- (08122BB2) --------------------------------------------------------
int __cdecl sub_8122BB2(_DWORD *a1, _DWORD *a2)
{
  sub_8127138(a2, a1 + 52);
  sub_8127138(a2 + 3, a1 + 55);
  return sub_8127138(a2 + 6, a1 + 58);
}

//----- (08122C06) --------------------------------------------------------
void __cdecl sub_8122C06(int a1, int a2)
{
  sub_812193C((_DWORD *)a2, *(_DWORD *)a1);
  *(float *)(a2 + 8) = sub_812F170((float *)(a1 + 4));
}

//----- (08122C3C) --------------------------------------------------------
void __cdecl sub_8122C3C(int a1, int a2)
{
  sub_8122C06(a2 + 256, a1 + 324);
  sub_8122C06(a2 + 268, a1 + 336);
  sub_8122C06(a2 + 280, a1 + 348);
  sub_8122C06(a2 + 292, a1 + 360);
  sub_8122C06(a2 + 304, a1 + 372);
  sub_8122C06(a2 + 316, a1 + 384);
  sub_8122C06(a2 + 328, a1 + 396);
  sub_8122C06(a2 + 340, a1 + 408);
  sub_8122C06(a2 + 376, a1 + 420);
  sub_8122C06(a2 + 388, a1 + 432);
  sub_8122C06(a2 + 400, a1 + 444);
  sub_8122C06(a2 + 412, a1 + 456);
  sub_8122C06(a2 + 424, a1 + 468);
  sub_8122C06(a2 + 436, a1 + 480);
  sub_8122C06(a2 + 448, a1 + 492);
  sub_8122C06(a2 + 460, a1 + 504);
  sub_8122C06(a2 + 472, a1 + 516);
  sub_8122C06(a2 + 484, a1 + 528);
  sub_8122C06(a2 + 496, a1 + 540);
  sub_8122C06(a2 + 508, a1 + 552);
  sub_8122C06(a2 + 520, a1 + 564);
  sub_8122C06(a2 + 532, a1 + 576);
}

//----- (08122EAC) --------------------------------------------------------
int __cdecl sub_8122EAC(int a1, int a2, int a3, int a4)
{
  return sub_81270E4((_DWORD *)(a1 + 300), a2, a3, a4);
}

//----- (08122EDA) --------------------------------------------------------
int __cdecl sub_8122EDA(int a1, int a2, int a3, int a4)
{
  return sub_81270E4((_DWORD *)(a1 + 312), a2, a3, a4);
}

//----- (08122F08) --------------------------------------------------------
long double __cdecl sub_8122F08(int a1, float *a2, float *a3, float a4)
{
  float v5; // [esp+0h] [ebp-48h]
  float v7; // [esp+18h] [ebp-30h]
  float v8; // [esp+1Ch] [ebp-2Ch]
  int v9[4]; // [esp+20h] [ebp-28h] BYREF
  float v10[6]; // [esp+30h] [ebp-18h] BYREF

  sub_81271AA((float *)(a1 + 124), a2, v10);
  v8 = sub_812727A(v10, a3);
  v5 = v8 - a4;
  if ( sub_8126F5E(v5) <= a4 )
  {
    sub_8127226(a2, v8, a3, (float *)v9);
    v7 = sub_80A1DB2((float *)(a1 + 124), (float *)v9);
    if ( *(float *)(a1 + 136) * *(float *)(a1 + 136) <= (long double)v7 )
      return (float)1.0;
    else
      return (float)(1.0 - (long double)*(unsigned __int8 *)(a1 + 147) * 0.0039215689);
  }
  else
  {
    return (float)1.0;
  }
}
// 8122F08: using guessed type float var_18[6];

//----- (08122FEA) --------------------------------------------------------
int __cdecl sub_8122FEA(int a1)
{
  int result; // eax
  float *v2; // [esp+14h] [ebp-4h]

  v2 = (float *)((char *)&unk_89AD700 + 20 * dword_89AD6A0++);
  sub_8127108((_DWORD *)(a1 + 124), v2);
  v2[3] = *(float *)(a1 + 136) * *(float *)(a1 + 136);
  result = *(unsigned __int8 *)(a1 + 147);
  v2[4] = 1.0 - (long double)result * 0.0039215689;
  return result;
}
// 89AD6A0: using guessed type int dword_89AD6A0;

//----- (08123068) --------------------------------------------------------
long double __cdecl sub_8123068(int a1, float a2, float a3)
{
  float v4; // [esp+4h] [ebp-4h]

  v4 = a2 / a3;
  if ( v4 > 1.0 )
    return 1.0;
  return v4;
}

//----- (0812309A) --------------------------------------------------------
_BOOL4 __cdecl sub_812309A(float *a1, int a2, float a3)
{
  return *(float *)(a2 + 8) > 0.0 && sub_8127318(a1) < 16.0 || a3 == 0.0;
}

//----- (08123100) --------------------------------------------------------
int __cdecl sub_8123100(int a1)
{
  int result; // eax

  *(_DWORD *)(a1 + 168) &= 0xFFFFF7DF;
  result = *(_DWORD *)(a1 + 168) | 0x1000000;
  *(_DWORD *)(a1 + 168) = result;
  return result;
}

//----- (08123134) --------------------------------------------------------
float *__cdecl sub_8123134(int a1, float *a2, float a3, float *a4, float a5, float *a6)
{
  float v7; // [esp+4h] [ebp-54h]
  float v8[7]; // [esp+10h] [ebp-48h] BYREF
  float v9; // [esp+2Ch] [ebp-2Ch]
  int v10[4]; // [esp+30h] [ebp-28h] BYREF
  int v11[6]; // [esp+40h] [ebp-18h] BYREF

  if ( sub_812309A(a4, (int)a6, a5) )
    return (float *)sub_8123100(a1);
  if ( a2 )
    sub_80B6998(a2, a6, (float *)v11);
  else
    sub_8127108(a6, v11);
  sub_8123EA4(a1, a3, (float *)v10, a2);
  sub_81271AA((float *)v10, (float *)(a1 + 196), v8);
  sub_81271EE((float *)v10, *(float *)(a1 + 256), (float *)v10);
  sub_81271AA((float *)v10, v8, (float *)(a1 + 196));
  v9 = sub_812727A((float *)v10, (float *)v11);
  v7 = v9 * -2.0;
  return sub_8127226((float *)(a1 + 196), v7, (float *)v11, (float *)(a1 + 196));
}
// 8123134: using guessed type float var_48[7];

//----- (0812325E) --------------------------------------------------------
_BOOL4 __cdecl sub_812325E(int a1)
{
  if ( *(_BYTE *)(a1 + 35) )
    return 0;
  if ( *(_BYTE *)(a1 + 34) )
    return 0;
  return *(float *)a1 != 1.0;
}

//----- (081232B2) --------------------------------------------------------
int __cdecl sub_81232B2(int a1, float *a2)
{
  float v3; // [esp+4h] [ebp-E4h]
  float v5; // [esp+30h] [ebp-B8h]
  float v6; // [esp+34h] [ebp-B4h]
  float v7; // [esp+38h] [ebp-B0h]
  float v8; // [esp+38h] [ebp-B0h]
  float v9; // [esp+3Ch] [ebp-ACh]
  int v10[4]; // [esp+40h] [ebp-A8h] BYREF
  int v11[4]; // [esp+50h] [ebp-98h] BYREF
  int v12[4]; // [esp+60h] [ebp-88h] BYREF
  int v13[4]; // [esp+70h] [ebp-78h] BYREF
  int v14[4]; // [esp+80h] [ebp-68h] BYREF
  int v15[4]; // [esp+90h] [ebp-58h] BYREF
  int v16[4]; // [esp+A0h] [ebp-48h] BYREF
  float s; // [esp+B0h] [ebp-38h] BYREF
  float v18[13]; // [esp+B4h] [ebp-34h] BYREF

  if ( (*(_DWORD *)(a1 + 168) & 0x1000000) != 0 )
    return 1;
  if ( !*(_DWORD *)(off_8168620 + 12) )
    return 1;
  v9 = (long double)*(int *)(off_8168620 + 12) * 0.001;
  v5 = (long double)sub_8122490(a1) * 0.001;
  v6 = (long double)sub_8127896(a1) * 0.001;
  v7 = sub_8123068(a1, v5, v6);
  sub_8123EA4(a1, v7, (float *)v15, a2);
  sub_8127226((float *)(a1 + 4), v9, (float *)v15, (float *)v16);
  if ( (*(_DWORD *)(a1 + 168) & 0x20) == 0 )
    goto LABEL_18;
  if ( a2 )
  {
    sub_80B6758(a2, (float *)(a1 + 4), (float *)v12);
    sub_80B6758(a2, (float *)v16, (float *)v11);
  }
  else
  {
    sub_8127108((_DWORD *)(a1 + 4), v12);
    sub_8127108(v16, v11);
  }
  if ( (*(_DWORD *)(a1 + 168) & 0x40) != 0 )
  {
    sub_8127108((_DWORD *)(a1 + 20), v14);
    sub_8127108((_DWORD *)(a1 + 32), v13);
    sub_812AD4E(off_8168620, &s, (float *)v12, (int)v14, (int)v13, (float *)v11, -1, 1);
  }
  else
  {
    sub_812AD4E(off_8168620, &s, (float *)v12, (int)flt_8145E68, (int)flt_8145E68, (float *)v11, -1, 1);
  }
  if ( sub_812325E((int)&s) )
  {
    if ( (*(_DWORD *)(a1 + 168) & 0x800) != 0 )
    {
      sub_80DEB7A((float *)v12, (float *)v11, s, (float *)v10);
      sub_8128900((int *)dword_89A2814, *(_DWORD *)(a1 + 44), (float *)v10, v18);
    }
    if ( (*(_DWORD *)(a1 + 168) & 0x400) != 0 )
    {
      return 0;
    }
    else
    {
      v3 = v9 * s + v5;
      v8 = sub_8123068(a1, v3, v6);
      sub_8123134(a1, a2, v8, (float *)v15, s, v18);
      sub_80DEB7A((float *)(a1 + 4), (float *)v16, s, (float *)(a1 + 4));
      return 1;
    }
  }
  else
  {
LABEL_18:
    sub_8127108(v16, (_DWORD *)(a1 + 4));
    return 1;
  }
}
// 8145E68: using guessed type float flt_8145E68[3];

//----- (08123660) --------------------------------------------------------
float *__cdecl sub_8123660(int a1, float a2, float *a3, float *a4)
{
  float v5; // [esp+20h] [ebp-18h] BYREF
  float v6; // [esp+24h] [ebp-14h]
  float v7; // [esp+28h] [ebp-10h]

  if ( (*(_DWORD *)(a1 + 168) & 0x80000) != 0 )
  {
    v5 = sub_8127604(a1 + 444, (_DWORD *)(a1 + 480), *(float *)(a1 + 300), a2);
    v6 = sub_8127604(a1 + 456, (_DWORD *)(a1 + 492), *(float *)(a1 + 304), a2);
    v7 = sub_8127604(a1 + 468, (_DWORD *)(a1 + 504), *(float *)(a1 + 308), a2);
  }
  else
  {
    v5 = sub_81275A6(a1 + 444, a2);
    v6 = sub_81275A6(a1 + 456, a2);
    v7 = sub_81275A6(a1 + 468, a2);
  }
  if ( (*(_DWORD *)(a1 + 168) & 0x200000) != 0 )
  {
    if ( a4 )
      return sub_80B6998(a4, &v5, a3);
    return (float *)sub_8127108(&v5, a3);
  }
  if ( a4 )
    return (float *)sub_8127108(&v5, a3);
  return sub_80A70C0((float *)(a1 + 208), v5, v6, v7, a3);
}

//----- (081237F4) --------------------------------------------------------
float *__cdecl sub_81237F4(int a1, float a2, float *a3, float *a4)
{
  float v5; // [esp+20h] [ebp-18h] BYREF
  float v6; // [esp+24h] [ebp-14h]
  float v7; // [esp+28h] [ebp-10h]

  if ( (*(_DWORD *)(a1 + 168) & 0x100000) != 0 )
  {
    v5 = sub_8127604(a1 + 516, (_DWORD *)(a1 + 552), *(float *)(a1 + 312), a2);
    v6 = sub_8127604(a1 + 528, (_DWORD *)(a1 + 564), *(float *)(a1 + 316), a2);
    v7 = sub_8127604(a1 + 540, (_DWORD *)(a1 + 576), *(float *)(a1 + 320), a2);
  }
  else
  {
    v5 = sub_81275A6(a1 + 516, a2);
    v6 = sub_81275A6(a1 + 528, a2);
    v7 = sub_81275A6(a1 + 540, a2);
  }
  if ( (*(_DWORD *)(a1 + 168) & 0x400000) != 0 )
  {
    if ( a4 )
      return sub_80B6998(a4, &v5, a3);
    return (float *)sub_8127108(&v5, a3);
  }
  if ( a4 )
    return (float *)sub_8127108(&v5, a3);
  return sub_80A70C0((float *)(a1 + 208), v5, v6, v7, a3);
}

//----- (08123988) --------------------------------------------------------
float *__cdecl sub_8123988(int a1, float a2, float *a3, float *a4)
{
  int v5; // [esp-4h] [ebp-3Ch]
  float v6[6]; // [esp+20h] [ebp-18h] BYREF

  v5 = sub_8127896(a1);
  sub_8123D1E(a1, (int)((long double)v5 * a2), (int)v6);
  if ( a4 )
    return sub_80B6998(a4, v6, a3);
  else
    return (float *)sub_8127108(v6, a3);
}
// 8123988: using guessed type float var_18[6];

//----- (08123A0A) --------------------------------------------------------
float *__cdecl sub_8123A0A(int a1, float a2, float *a3)
{
  float v4; // [esp+4h] [ebp-34h]
  float v5; // [esp+20h] [ebp-18h] BYREF
  float v6; // [esp+24h] [ebp-14h]
  float v7; // [esp+28h] [ebp-10h]

  if ( (*(_DWORD *)(a1 + 168) & 0x80000) != 0 )
  {
    v5 = sub_8127702(a1 + 444, (_DWORD **)(a1 + 480), *(float *)(a1 + 300), a2);
    v6 = sub_8127702(a1 + 456, (_DWORD **)(a1 + 492), *(float *)(a1 + 304), a2);
    v7 = sub_8127702(a1 + 468, (_DWORD **)(a1 + 504), *(float *)(a1 + 308), a2);
  }
  else
  {
    v5 = sub_81276E0(a1 + 444, a2);
    v6 = sub_81276E0(a1 + 456, a2);
    v7 = sub_81276E0(a1 + 468, a2);
  }
  if ( (*(_DWORD *)(a1 + 168) & 0x200000) != 0 )
    sub_8127108(&v5, a3);
  else
    sub_80A70C0((float *)(a1 + 208), v5, v6, v7, a3);
  v4 = (long double)sub_8127896(a1) * 0.001;
  return sub_81271EE(a3, v4, a3);
}

//----- (08123B94) --------------------------------------------------------
float *__cdecl sub_8123B94(int a1, float a2, float *a3)
{
  float v4; // [esp+4h] [ebp-34h]
  float v5; // [esp+20h] [ebp-18h] BYREF
  float v6; // [esp+24h] [ebp-14h]
  float v7; // [esp+28h] [ebp-10h]

  if ( (*(_DWORD *)(a1 + 168) & 0x80000) != 0 )
  {
    v5 = sub_8127702(a1 + 516, (_DWORD **)(a1 + 552), *(float *)(a1 + 312), a2);
    v6 = sub_8127702(a1 + 528, (_DWORD **)(a1 + 564), *(float *)(a1 + 316), a2);
    v7 = sub_8127702(a1 + 540, (_DWORD **)(a1 + 576), *(float *)(a1 + 320), a2);
  }
  else
  {
    v5 = sub_81276E0(a1 + 516, a2);
    v6 = sub_81276E0(a1 + 528, a2);
    v7 = sub_81276E0(a1 + 540, a2);
  }
  if ( (*(_DWORD *)(a1 + 168) & 0x400000) != 0 )
    sub_8127108(&v5, a3);
  else
    sub_80A70C0((float *)(a1 + 208), v5, v6, v7, a3);
  v4 = (long double)sub_8127896(a1) * 0.001;
  return sub_81271EE(a3, v4, a3);
}

//----- (08123D1E) --------------------------------------------------------
int __cdecl sub_8123D1E(int a1, int a2, int a3)
{
  int result; // eax

  *(_DWORD *)a3 = 0;
  *(_DWORD *)(a3 + 4) = 0;
  result = a1;
  *(float *)(a3 + 8) = (long double)a2 * *(float *)(a1 + 244) * 0.001;
  return result;
}

//----- (08123D56) --------------------------------------------------------
float *__cdecl sub_8123D56(int a1, int a2, float *a3)
{
  float v4; // [esp+4h] [ebp-64h]
  float v5; // [esp+1Ch] [ebp-4Ch]
  float v6; // [esp+1Ch] [ebp-4Ch]
  int v7[4]; // [esp+20h] [ebp-48h] BYREF
  int v8[4]; // [esp+30h] [ebp-38h] BYREF
  int v9[6]; // [esp+40h] [ebp-28h] BYREF
  float v10; // [esp+58h] [ebp-10h]
  int v11; // [esp+5Ch] [ebp-Ch]

  v11 = sub_8127896(a1);
  if ( a2 >= v11 )
  {
    v6 = 1.0;
  }
  else
  {
    v5 = (float)a2;
    v6 = v5 / (long double)v11;
  }
  v10 = v6;
  sub_8123A0A(a1, v6, (float *)v9);
  sub_8123B94(a1, v10, (float *)v8);
  sub_8123D1E(a1, a2, (int)v7);
  v4 = (long double)a2 * 0.001;
  sub_81271EE((float *)v7, v4, (float *)v7);
  sub_8127166((float *)v9, (float *)v8, a3);
  return sub_8127166(a3, (float *)v7, a3);
}

//----- (08123E30) --------------------------------------------------------
float *__cdecl sub_8123E30(int a1, float *a2)
{
  _DWORD *v2; // eax
  float *v4; // [esp+14h] [ebp-4h]

  if ( sub_812782E((_DWORD *)(a1 + 192)) )
  {
    v2 = (_DWORD *)sub_812787E(a1 + 192);
    v4 = (float *)sub_8122008(v2);
    if ( !v4 )
      return (float *)sub_81270BA(a2);
  }
  else
  {
    v4 = 0;
  }
  return sub_8123EA4(a1, 0.0, a2, v4);
}

//----- (08123EA4) --------------------------------------------------------
float *__cdecl sub_8123EA4(int a1, float a2, float *a3, float *a4)
{
  int v5[4]; // [esp+10h] [ebp-38h] BYREF
  int v6[4]; // [esp+20h] [ebp-28h] BYREF
  int v7[6]; // [esp+30h] [ebp-18h] BYREF

  sub_8123660(a1, a2, (float *)v7, a4);
  sub_81237F4(a1, a2, (float *)v6, a4);
  sub_8123988(a1, a2, (float *)v5, a4);
  sub_8127166((float *)v7, (float *)v6, a3);
  sub_8127166(a3, (float *)v5, a3);
  return sub_8127166(a3, (float *)(a1 + 196), a3);
}

//----- (08123F5C) --------------------------------------------------------
void __cdecl sub_8123F5C(int a1)
{
  if ( *(__int16 *)(a1 + 168) >= 0 )
    *(float *)(a1 + 136) = sub_81275A6(a1 + 372, *(float *)(a1 + 60));
  else
    *(float *)(a1 + 136) = sub_8127604(a1 + 372, (_DWORD *)(a1 + 384), *(float *)(a1 + 288), *(float *)(a1 + 60));
}

//----- (08123FE0) --------------------------------------------------------
void __cdecl sub_8123FE0(int a1)
{
  if ( *(_BYTE *)(a1 + 260) )
  {
    if ( (*(_DWORD *)(a1 + 168) & 0x10000) != 0 )
      *(float *)(a1 + 140) = sub_8127604(a1 + 396, (_DWORD *)(a1 + 408), *(float *)(a1 + 292), *(float *)(a1 + 60));
    else
      *(float *)(a1 + 140) = sub_81275A6(a1 + 396, *(float *)(a1 + 60));
  }
  else
  {
    *(_DWORD *)(a1 + 140) = *(_DWORD *)(a1 + 136);
  }
}

//----- (08124080) --------------------------------------------------------
void __cdecl sub_8124080(int a1)
{
  int v1[6]; // [esp+20h] [ebp-18h] BYREF

  if ( (*(_DWORD *)(a1 + 168) & 0x2000) != 0 )
    sub_8127650(a1 + 324, (_DWORD *)(a1 + 336), *(float *)(a1 + 280), (float *)v1, *(float *)(a1 + 60));
  else
    sub_81275C6(a1 + 324, (float *)v1, *(float *)(a1 + 60));
  sub_8121E7C((int)v1, a1 + 144);
}

//----- (0812410E) --------------------------------------------------------
int __cdecl sub_812410E(int a1)
{
  int result; // eax
  float v2; // [esp+24h] [ebp-4h]
  float v3; // [esp+24h] [ebp-4h]

  if ( (*(_DWORD *)(a1 + 168) & 0x4000) != 0 )
    v2 = sub_8127604(a1 + 348, (_DWORD *)(a1 + 360), *(float *)(a1 + 284), *(float *)(a1 + 60));
  else
    v2 = sub_81275A6(a1 + 348, *(float *)(a1 + 60));
  v3 = sub_8126FC2(v2, 0.0, 1.0);
  if ( *(char *)(a1 + 168) >= 0 )
  {
    *(_BYTE *)(a1 + 144) = (__int16)((long double)*(unsigned __int8 *)(a1 + 144) * v3);
    *(_BYTE *)(a1 + 145) = (__int16)((long double)*(unsigned __int8 *)(a1 + 145) * v3);
    *(_BYTE *)(a1 + 146) = (__int16)((long double)*(unsigned __int8 *)(a1 + 146) * v3);
    result = a1;
    *(_BYTE *)(a1 + 147) = -1;
  }
  else
  {
    result = (unsigned __int16)(__int16)(v3 * 255.0);
    *(_BYTE *)(a1 + 147) = result;
  }
  return result;
}

//----- (0812427C) --------------------------------------------------------
int __cdecl sub_812427C(int a1)
{
  int result; // eax
  float v2; // [esp+14h] [ebp-4h]

  if ( (*(_DWORD *)(a1 + 168) & 0x40000) != 0 )
    v2 = sub_8127604(a1 + 420, (_DWORD *)(a1 + 432), *(float *)(a1 + 296), *(float *)(a1 + 60));
  else
    v2 = sub_81275A6(a1 + 420, *(float *)(a1 + 60));
  result = off_8168620;
  *(float *)(a1 + 68) = (long double)*(int *)(off_8168620 + 12) * 0.0099999998 * v2 + *(float *)(a1 + 68);
  return result;
}

//----- (0812430C) --------------------------------------------------------
int __cdecl sub_812430C(int a1)
{
  int result; // eax
  int v2; // edx
  int v3; // edx
  int v4; // [esp+1Ch] [ebp-Ch]

  v4 = sub_812AE52();
  if ( v4 == 1 )
  {
    result = a1;
    *(_DWORD *)(a1 + 148) = 0;
  }
  else
  {
    *(_DWORD *)(a1 + 148) = *(_DWORD *)(a1 + 264)
                          + (int)((long double)(*(_DWORD *)(off_8168620 + 4) - *(_DWORD *)(a1 + 184))
                                * *(float *)(a1 + 268));
    if ( *(_DWORD *)(a1 + 272) )
    {
      result = a1;
      if ( *(_DWORD *)(a1 + 272) == 1 )
      {
        if ( *(int *)(a1 + 276) <= 0 )
        {
          result = *(_DWORD *)(a1 + 148);
          if ( result >= v4 )
          {
            result = v4 - 1;
            *(_DWORD *)(a1 + 148) = v4 - 1;
          }
        }
        else
        {
          result = *(_DWORD *)(a1 + 148);
          if ( result >= v4 )
          {
            if ( *(_DWORD *)(a1 + 148) < v4 * (*(_DWORD *)(a1 + 276) + 1) )
            {
              v3 = *(_DWORD *)(a1 + 148);
              result = v3 / v4;
              *(_DWORD *)(a1 + 148) = v3 % v4;
            }
            else
            {
              *(_DWORD *)(a1 + 276) = 0;
              result = v4 - 1;
              *(_DWORD *)(a1 + 148) = v4 - 1;
            }
          }
        }
      }
    }
    else
    {
      result = *(_DWORD *)(a1 + 148);
      if ( result >= v4 )
      {
        v2 = *(_DWORD *)(a1 + 148);
        result = v2 / v4;
        *(_DWORD *)(a1 + 148) = v2 % v4;
      }
    }
  }
  return result;
}

//----- (0812447E) --------------------------------------------------------
int sub_812447E()
{
  return 1;
}

//----- (08124488) --------------------------------------------------------
_BYTE **__cdecl sub_8124488(char *a1, int *a2)
{
  sub_81224DC((int)a1, a2);
  sub_8127B04((int)a2, a1 + 196);
  sub_8127B04((int)a2, a1 + 208);
  sub_8127B04((int)a2, a1 + 220);
  sub_8127B04((int)a2, a1 + 232);
  sub_8127AE2((int)a2, a1 + 256);
  sub_8127A9E((int)a2, a1 + 260);
  sub_812107A((int)a2, (int)(a1 + 324));
  sub_812107A((int)a2, (int)(a1 + 336));
  sub_812107A((int)a2, (int)(a1 + 348));
  sub_812107A((int)a2, (int)(a1 + 360));
  sub_812107A((int)a2, (int)(a1 + 372));
  sub_812107A((int)a2, (int)(a1 + 384));
  sub_812107A((int)a2, (int)(a1 + 396));
  sub_812107A((int)a2, (int)(a1 + 408));
  sub_812107A((int)a2, (int)(a1 + 420));
  sub_812107A((int)a2, (int)(a1 + 432));
  sub_812107A((int)a2, (int)(a1 + 444));
  sub_812107A((int)a2, (int)(a1 + 456));
  sub_812107A((int)a2, (int)(a1 + 468));
  sub_812107A((int)a2, (int)(a1 + 480));
  sub_812107A((int)a2, (int)(a1 + 492));
  sub_812107A((int)a2, (int)(a1 + 504));
  sub_812107A((int)a2, (int)(a1 + 516));
  sub_812107A((int)a2, (int)(a1 + 528));
  sub_812107A((int)a2, (int)(a1 + 540));
  sub_812107A((int)a2, (int)(a1 + 552));
  sub_812107A((int)a2, (int)(a1 + 564));
  sub_812107A((int)a2, (int)(a1 + 576));
  sub_8127AC0((int)a2, a1 + 264);
  sub_8127AE2((int)a2, a1 + 268);
  sub_8127AC0((int)a2, a1 + 272);
  sub_8127AC0((int)a2, a1 + 276);
  sub_8127AE2((int)a2, a1 + 280);
  sub_8127AE2((int)a2, a1 + 284);
  sub_8127AE2((int)a2, a1 + 288);
  sub_8127AE2((int)a2, a1 + 292);
  sub_8127AE2((int)a2, a1 + 296);
  sub_8127B04((int)a2, a1 + 300);
  return sub_8127B04((int)a2, a1 + 312);
}

//----- (08124824) --------------------------------------------------------
int __cdecl sub_8124824(_DWORD *a1, _DWORD *a2)
{
  int result; // eax

  sub_8122668();
  a1[81] = a2[64];
  a1[84] = a2[67];
  a1[87] = a2[70];
  a1[90] = a2[73];
  a1[93] = a2[76];
  a1[96] = a2[79];
  a1[99] = a2[82];
  a1[102] = a2[85];
  a1[105] = a2[94];
  a1[108] = a2[97];
  a1[111] = a2[100];
  a1[114] = a2[103];
  a1[117] = a2[106];
  a1[120] = a2[109];
  a1[123] = a2[112];
  a1[126] = a2[115];
  a1[129] = a2[118];
  a1[132] = a2[121];
  a1[135] = a2[124];
  a1[138] = a2[127];
  a1[141] = a2[130];
  result = a2[133];
  a1[144] = result;
  return result;
}

//----- (081249E6) --------------------------------------------------------
_DWORD *__cdecl sub_81249E6(_DWORD *a1)
{
  _DWORD *result; // eax

  sub_81227C4(a1);
  result = a1;
  *a1 = off_8158428;
  return result;
}
// 8158428: using guessed type int (__cdecl *off_8158428[6])(int);

//----- (08124A02) --------------------------------------------------------
int __cdecl sub_8124A02(_DWORD *a1)
{
  *a1 = off_8158428;
  sub_812281C(a1);
  return 0;
}
// 8158428: using guessed type int (__cdecl *off_8158428[6])(int);

//----- (08124A36) --------------------------------------------------------
int __cdecl sub_8124A36(_DWORD *a1)
{
  *a1 = off_8158428;
  sub_812281C(a1);
  return 0;
}
// 8158428: using guessed type int (__cdecl *off_8158428[6])(int);

//----- (08124A6A) --------------------------------------------------------
int __cdecl sub_8124A6A(char *a1)
{
  *(_DWORD *)a1 = off_8158428;
  sub_812281C(a1);
  return sub_81279AE(a1);
}
// 8158428: using guessed type int (__cdecl *off_8158428[6])(int);

//----- (08124A9E) --------------------------------------------------------
int __cdecl sub_8124A9E(int a1)
{
  int v1; // eax

  v1 = sub_8122382(a1);
  return (unsigned __int8)sub_812AB74(off_8168620, (float *)(a1 + 124), *(float *)(a1 + 136), v1);
}

//----- (08124ADC) --------------------------------------------------------
void __cdecl sub_8124ADC(int a1)
{
  sub_812266E(a1, 7);
}

//----- (08124AF8) --------------------------------------------------------
int __cdecl sub_8124AF8(float *a1)
{
  float *v3; // [esp+14h] [ebp-4h] BYREF

  v3 = 0;
  if ( !(unsigned __int8)sub_81223CE((int)a1) )
    return 0;
  if ( !sub_812232C((int)a1, &v3) )
    return 0;
  if ( !(unsigned __int8)sub_81232B2((int)a1, v3) )
    return 0;
  sub_8123F5C((int)a1);
  sub_8123FE0((int)a1);
  sub_8124080((int)a1);
  sub_812410E((int)a1);
  sub_812427C((int)a1);
  sub_812430C((int)a1);
  if ( v3 )
  {
    sub_80B6758(v3, a1 + 1, a1 + 31);
    sub_80B6806(v3, a1 + 147, a1 + 18);
  }
  else
  {
    sub_8127108((_DWORD *)a1 + 1, (_DWORD *)a1 + 31);
    sub_8127108((_DWORD *)a1 + 147, (_DWORD *)a1 + 18);
  }
  return 1;
}

//----- (08124C2C) --------------------------------------------------------
int sub_8124C2C()
{
  return 7;
}

//----- (08124C36) --------------------------------------------------------
_BYTE **__cdecl sub_8124C36(char *a1, int *a2)
{
  sub_8124488(a1, a2);
  return sub_8127B04((int)a2, a1 + 588);
}

//----- (08124C68) --------------------------------------------------------
void __cdecl sub_8124C68(_DWORD *a1)
{
  sub_81227C4(a1);
  *a1 = off_81583E8;
  sub_8124E0C((int)a1);
}
// 81583E8: using guessed type int (__cdecl *off_81583E8[2])(int);

//----- (08124CB6) --------------------------------------------------------
void __cdecl sub_8124CB6(_DWORD *a1)
{
  sub_81227C4(a1);
  *a1 = off_81583E8;
  sub_8124E0C((int)a1);
}
// 81583E8: using guessed type int (__cdecl *off_81583E8[2])(int);

//----- (08124D04) --------------------------------------------------------
int __cdecl sub_8124D04(_DWORD *a1)
{
  *a1 = off_81583E8;
  sub_812281C(a1);
  return 0;
}
// 81583E8: using guessed type int (__cdecl *off_81583E8[2])(int);

//----- (08124D38) --------------------------------------------------------
int __cdecl sub_8124D38(_DWORD *a1)
{
  *a1 = off_81583E8;
  sub_812281C(a1);
  return 0;
}
// 81583E8: using guessed type int (__cdecl *off_81583E8[2])(int);

//----- (08124D6C) --------------------------------------------------------
int __cdecl sub_8124D6C(char *a1)
{
  *(_DWORD *)a1 = off_81583E8;
  sub_812281C(a1);
  return sub_8127976(a1);
}
// 81583E8: using guessed type int (__cdecl *off_81583E8[2])(int);

//----- (08124DA0) --------------------------------------------------------
void sub_8124DA0()
{
  ;
}

//----- (08124DA6) --------------------------------------------------------
int __usercall sub_8124DA6@<eax>(long double a1@<st0>, float *a2)
{
  int v2; // esi
  float v4; // [esp+8h] [ebp-10h]

  v2 = sub_8122382((int)a2);
  sub_8126F78(a2[34], a2[35]);
  v4 = a1 + a2[38];
  return (unsigned __int8)sub_812AB74(off_8168620, a2 + 31, v4, v2);
}

//----- (08124E0C) --------------------------------------------------------
void __cdecl sub_8124E0C(int a1)
{
  int j; // [esp+14h] [ebp-14h]
  int i; // [esp+18h] [ebp-10h]
  float v3; // [esp+1Ch] [ebp-Ch]

  for ( i = 0; i != 4; ++i )
  {
    for ( j = 0; j != 3; ++j )
      *(float *)(a1 + 4 * j + 588) = sub_80A8720(-1.0, 1.0);
    v3 = sub_8127318((float *)(a1 + 588));
    if ( v3 >= 0.0099999998 && v3 <= 1.0 )
    {
      Vec3Normalize((float *)(a1 + 588));
      return;
    }
  }
  *(_DWORD *)(a1 + 588) = 1065353216;
  *(_DWORD *)(a1 + 592) = 0;
  *(_DWORD *)(a1 + 596) = 0;
}

//----- (08124EE4) --------------------------------------------------------
void __cdecl sub_8124EE4(int a1)
{
  sub_812266E(a1, 6);
}

//----- (08124F00) --------------------------------------------------------
void __cdecl sub_8124F00(int a1, int a2)
{
  sub_8122C3C(a1, a2);
  sub_8122C06(a2 + 352, a1 + 612);
  sub_8122C06(a2 + 364, a1 + 624);
}

//----- (08124F52) --------------------------------------------------------
void __cdecl sub_8124F52(int a1)
{
  if ( *(_BYTE *)(a1 + 604) )
  {
    if ( (*(_DWORD *)(a1 + 168) & 0x20000) != 0 )
      *(float *)(a1 + 600) = sub_8127604(a1 + 612, (_DWORD *)(a1 + 624), *(float *)(a1 + 608), *(float *)(a1 + 60));
    else
      *(float *)(a1 + 600) = sub_81275A6(a1 + 612, *(float *)(a1 + 60));
  }
}

//----- (08124FE0) --------------------------------------------------------
int __cdecl sub_8124FE0(int a1)
{
  float v2; // [esp+14h] [ebp-44h]
  _DWORD v4[4]; // [esp+20h] [ebp-38h] BYREF
  int v5[7]; // [esp+30h] [ebp-28h] BYREF
  float *v6; // [esp+4Ch] [ebp-Ch] BYREF

  v6 = 0;
  if ( !(unsigned __int8)sub_81223CE(a1) )
    return 0;
  if ( !sub_812232C(a1, &v6) )
    return 0;
  sub_8127108((_DWORD *)(a1 + 4), v4);
  if ( !(unsigned __int8)sub_81232B2(a1, v6) )
    return 0;
  sub_8123F5C(a1);
  sub_8123FE0(a1);
  sub_8124F52(a1);
  sub_8124080(a1);
  sub_812410E(a1);
  sub_812427C(a1);
  sub_80A58CC(*(float *)(a1 + 68), (float *)(a1 + 588), (float *)v5);
  sub_80A54E2((float *)v5, (float *)(a1 + 72));
  *(_DWORD *)(a1 + 152) = *(_DWORD *)(a1 + 136);
  *(_DWORD *)(a1 + 136) = *(_DWORD *)(a1 + 140);
  if ( *(_BYTE *)(a1 + 604) )
    v2 = *(float *)(a1 + 600);
  else
    v2 = *(float *)(a1 + 136);
  *(float *)(a1 + 140) = v2;
  if ( v6 )
    sub_80B6758(v6, (float *)(a1 + 4), (float *)(a1 + 124));
  else
    sub_8127108((_DWORD *)(a1 + 4), (_DWORD *)(a1 + 124));
  sub_8127108(v4, (_DWORD *)(a1 + 156));
  return 1;
}
// 8124FE0: using guessed type _DWORD var_38[4];

//----- (08125198) --------------------------------------------------------
int sub_8125198()
{
  return 12;
}

//----- (081251A2) --------------------------------------------------------
_BYTE **__cdecl sub_81251A2(char *a1, int *a2)
{
  sub_8124488(a1, a2);
  sub_8127B04((int)a2, a1 + 588);
  sub_812107A((int)a2, (int)(a1 + 612));
  sub_812107A((int)a2, (int)(a1 + 624));
  sub_8127AE2((int)a2, a1 + 608);
  return sub_8127A9E((int)a2, a1 + 604);
}

//----- (08125230) --------------------------------------------------------
int __cdecl sub_8125230(_DWORD *a1, _DWORD *a2)
{
  int result; // eax

  sub_8124824(a1, a2);
  a1[153] = a2[88];
  result = a2[91];
  a1[156] = result;
  return result;
}

//----- (0812528A) --------------------------------------------------------
_DWORD *__cdecl sub_812528A(_DWORD *a1)
{
  _DWORD *result; // eax

  sub_81227C4(a1);
  result = a1;
  *a1 = off_81583A8;
  return result;
}
// 81583A8: using guessed type int (__cdecl *off_81583A8[2])(int);

//----- (081252A6) --------------------------------------------------------
int __cdecl sub_81252A6(_DWORD *a1)
{
  *a1 = off_81583A8;
  sub_812281C(a1);
  return 0;
}
// 81583A8: using guessed type int (__cdecl *off_81583A8[2])(int);

//----- (081252DA) --------------------------------------------------------
int __cdecl sub_81252DA(_DWORD *a1)
{
  *a1 = off_81583A8;
  sub_812281C(a1);
  return 0;
}
// 81583A8: using guessed type int (__cdecl *off_81583A8[2])(int);

//----- (0812530E) --------------------------------------------------------
int __cdecl sub_812530E(char *a1)
{
  *(_DWORD *)a1 = off_81583A8;
  sub_812281C(a1);
  return sub_8127992(a1);
}
// 81583A8: using guessed type int (__cdecl *off_81583A8[2])(int);

//----- (08125342) --------------------------------------------------------
void sub_8125342()
{
  ;
}

//----- (08125348) --------------------------------------------------------
int __cdecl sub_8125348(float *a1)
{
  int v1; // eax

  v1 = sub_8122382((int)a1);
  return (unsigned __int8)sub_812AC82(off_8168620, a1 + 31, a1 + 39, a1[34], a1[34], v1);
}

//----- (081253A0) --------------------------------------------------------
void __cdecl sub_81253A0(int a1)
{
  sub_812266E(a1, 8);
}

//----- (081253BC) --------------------------------------------------------
int __cdecl sub_81253BC(float *a1)
{
  float *v3; // [esp+14h] [ebp-4h] BYREF

  v3 = 0;
  if ( !(unsigned __int8)sub_81223CE((int)a1) )
    return 0;
  if ( !sub_812232C((int)a1, &v3) )
    return 0;
  if ( v3 )
  {
    sub_80B6758(v3, a1 + 1, a1 + 31);
    sub_80B6758(v3, a1 + 147, a1 + 39);
  }
  else
  {
    sub_8127108((_DWORD *)a1 + 1, (_DWORD *)a1 + 31);
    sub_8127108((_DWORD *)a1 + 147, (_DWORD *)a1 + 39);
  }
  sub_8123F5C((int)a1);
  sub_8124080((int)a1);
  sub_812410E((int)a1);
  return 1;
}

//----- (081254B2) --------------------------------------------------------
int sub_81254B2()
{
  return 2;
}

//----- (081254BC) --------------------------------------------------------
_BYTE **__cdecl sub_81254BC(char *a1, int *a2)
{
  sub_8124488(a1, a2);
  return sub_8127B04((int)a2, a1 + 588);
}

//----- (081254EE) --------------------------------------------------------
_DWORD *__cdecl sub_81254EE(_DWORD *a1)
{
  _DWORD *result; // eax

  sub_81227C4(a1);
  result = a1;
  *a1 = off_8158368;
  return result;
}
// 8158368: using guessed type int (__cdecl *off_8158368[6])(int);

//----- (0812550A) --------------------------------------------------------
_DWORD *__cdecl sub_812550A(_DWORD *a1)
{
  _DWORD *result; // eax

  sub_81227C4(a1);
  result = a1;
  *a1 = off_8158368;
  return result;
}
// 8158368: using guessed type int (__cdecl *off_8158368[6])(int);

//----- (08125526) --------------------------------------------------------
int __cdecl sub_8125526(_DWORD *a1)
{
  *a1 = off_8158368;
  sub_812281C(a1);
  return 0;
}
// 8158368: using guessed type int (__cdecl *off_8158368[6])(int);

//----- (0812555A) --------------------------------------------------------
int __cdecl sub_812555A(_DWORD *a1)
{
  *a1 = off_8158368;
  sub_812281C(a1);
  return 0;
}
// 8158368: using guessed type int (__cdecl *off_8158368[6])(int);

//----- (0812558E) --------------------------------------------------------
int __cdecl sub_812558E(char *a1)
{
  *(_DWORD *)a1 = off_8158368;
  sub_812281C(a1);
  return sub_81279CA(a1);
}
// 8158368: using guessed type int (__cdecl *off_8158368[6])(int);

//----- (081255C2) --------------------------------------------------------
void __usercall sub_81255C2(long double a1@<st0>, float *a2)
{
  sub_81257C8((int)a2);
  sub_8125848(a1, a2, 0);
}

//----- (081255E8) --------------------------------------------------------
int __cdecl sub_81255E8(float *a1)
{
  int v1; // eax

  v1 = sub_8122382((int)a1);
  return (unsigned __int8)sub_812AC82(off_8168620, a1 + 31, a1 + 39, a1[34], a1[34], v1);
}

//----- (08125640) --------------------------------------------------------
void __cdecl sub_8125640(int a1, int a2)
{
  sub_8122C3C(a1, a2);
  sub_8122C06(a2 + 352, a1 + 608);
  sub_8122C06(a2 + 364, a1 + 620);
}

//----- (08125692) --------------------------------------------------------
void __cdecl sub_8125692(int a1)
{
  sub_812266E(a1, 8);
}

//----- (081256AE) --------------------------------------------------------
int __usercall sub_81256AE@<eax>(long double a1@<st0>, int a2)
{
  float *v4; // [esp+14h] [ebp-4h] BYREF

  v4 = 0;
  if ( !(unsigned __int8)sub_81223CE(a2) )
    return 0;
  if ( !sub_812232C(a2, &v4) )
    return 0;
  sub_8127108((_DWORD *)(a2 + 4), (_DWORD *)(a2 + 588));
  if ( !(unsigned __int8)sub_81232B2(a2, v4) )
    return 0;
  if ( v4 )
    sub_80B6758(v4, (float *)(a2 + 4), (float *)(a2 + 124));
  else
    sub_8127108((_DWORD *)(a2 + 4), (_DWORD *)(a2 + 124));
  sub_8123F5C(a2);
  sub_81257C8(a2);
  sub_8124080(a2);
  sub_812410E(a2);
  sub_812430C(a2);
  sub_8125848(a1, (float *)a2, v4);
  return 1;
}

//----- (081257C8) --------------------------------------------------------
void __cdecl sub_81257C8(int a1)
{
  if ( (*(_DWORD *)(a1 + 168) & 0x20000) != 0 )
    *(float *)(a1 + 600) = sub_8127604(a1 + 608, (_DWORD *)(a1 + 620), *(float *)(a1 + 604), *(float *)(a1 + 60));
  else
    *(float *)(a1 + 600) = sub_81275A6(a1 + 608, *(float *)(a1 + 60));
}

//----- (08125848) --------------------------------------------------------
void __usercall sub_8125848(long double a1@<st0>, float *a2, float *a3)
{
  float v3; // [esp+4h] [ebp-34h]
  int v4[7]; // [esp+10h] [ebp-28h] BYREF
  float v5; // [esp+2Ch] [ebp-Ch]

  sub_81271AA(a2 + 147, a2 + 1, (float *)v4);
  sub_812734C((float *)v4);
  v5 = a1;
  if ( v5 > 0.0 )
  {
    v3 = 1.0 / v5;
    sub_81271EE((float *)v4, v3, (float *)v4);
    if ( a3 )
    {
      sub_8127226(a2 + 1, a2[150], (float *)v4, (float *)v4);
      sub_80B6758(a3, (float *)v4, a2 + 39);
    }
    else
    {
      sub_8127226(a2 + 1, a2[150], (float *)v4, a2 + 39);
    }
  }
}

//----- (0812592A) --------------------------------------------------------
int sub_812592A()
{
  return 3;
}

//----- (08125934) --------------------------------------------------------
_BYTE **__cdecl sub_8125934(char *a1, int *a2)
{
  sub_8124488(a1, a2);
  sub_8127B04((int)a2, a1 + 588);
  sub_812107A((int)a2, (int)(a1 + 608));
  sub_812107A((int)a2, (int)(a1 + 620));
  return sub_8127AE2((int)a2, a1 + 604);
}

//----- (081259AA) --------------------------------------------------------
int __cdecl sub_81259AA(_DWORD *a1, _DWORD *a2)
{
  int result; // eax

  sub_8124824(a1, a2);
  a1[152] = a2[88];
  result = a2[91];
  a1[155] = result;
  return result;
}

//----- (08125A04) --------------------------------------------------------
_DWORD *__cdecl sub_8125A04(_DWORD *a1)
{
  _DWORD *result; // eax

  sub_81254EE(a1);
  result = a1;
  *a1 = off_8158328;
  return result;
}
// 8158328: using guessed type int (__cdecl *off_8158328[6])(int);

//----- (08125A20) --------------------------------------------------------
int __cdecl sub_8125A20(_DWORD *a1)
{
  *a1 = off_8158328;
  sub_8125526(a1);
  return 0;
}
// 8158328: using guessed type int (__cdecl *off_8158328[6])(int);

//----- (08125A54) --------------------------------------------------------
int __cdecl sub_8125A54(_DWORD *a1)
{
  *a1 = off_8158328;
  sub_8125526(a1);
  return 0;
}
// 8158328: using guessed type int (__cdecl *off_8158328[6])(int);

//----- (08125A88) --------------------------------------------------------
int __cdecl sub_8125A88(char *a1)
{
  *(_DWORD *)a1 = off_8158328;
  sub_8125526(a1);
  return sub_81279E6(a1);
}
// 8158328: using guessed type int (__cdecl *off_8158328[6])(int);

//----- (08125ABC) --------------------------------------------------------
int __cdecl sub_8125ABC(float *a1)
{
  int v1; // eax

  v1 = sub_8122382((int)a1);
  return (unsigned __int8)sub_812AC82(off_8168620, a1 + 31, a1 + 39, a1[35], a1[34], v1);
}

//----- (08125B14) --------------------------------------------------------
void __cdecl sub_8125B14(int a1)
{
  sub_812266E(a1, 9);
}

//----- (08125B30) --------------------------------------------------------
int __cdecl sub_8125B30(float *a1)
{
  int v3[7]; // [esp+20h] [ebp-28h] BYREF
  float *v4; // [esp+3Ch] [ebp-Ch] BYREF

  v4 = 0;
  if ( !(unsigned __int8)sub_81223CE((int)a1) )
    return 0;
  if ( !sub_812232C((int)a1, &v4) )
    return 0;
  sub_8123F5C((int)a1);
  sub_8123FE0((int)a1);
  sub_81257C8((int)a1);
  sub_8124080((int)a1);
  sub_812410E((int)a1);
  if ( v4 )
  {
    sub_80B6758(v4, a1 + 1, a1 + 31);
    sub_8127226(a1 + 1, a1[150], a1 + 18, (float *)v3);
    sub_80B6758(v4, (float *)v3, a1 + 39);
  }
  else
  {
    sub_8127108((_DWORD *)a1 + 1, (_DWORD *)a1 + 31);
    sub_8127226(a1 + 1, a1[150], a1 + 18, a1 + 39);
  }
  return 1;
}

//----- (08125C78) --------------------------------------------------------
int sub_8125C78()
{
  return 4;
}

//----- (08125C82) --------------------------------------------------------
_BYTE **__cdecl sub_8125C82(char *a1, int *a2)
{
  return sub_8125934(a1, a2);
}

//----- (08125CB8) --------------------------------------------------------
_DWORD *__cdecl sub_8125CB8(_DWORD *a1)
{
  _DWORD *result; // eax

  sub_81227C4(a1);
  result = a1;
  *a1 = off_81582E8;
  return result;
}
// 81582E8: using guessed type int (__cdecl *off_81582E8[4])(int);

//----- (08125CD4) --------------------------------------------------------
int __cdecl sub_8125CD4(_DWORD *a1)
{
  *a1 = off_81582E8;
  sub_812281C(a1);
  return 0;
}
// 81582E8: using guessed type int (__cdecl *off_81582E8[4])(int);

//----- (08125D08) --------------------------------------------------------
int __cdecl sub_8125D08(_DWORD *a1)
{
  *a1 = off_81582E8;
  sub_812281C(a1);
  return 0;
}
// 81582E8: using guessed type int (__cdecl *off_81582E8[4])(int);

//----- (08125D3C) --------------------------------------------------------
int __cdecl sub_8125D3C(char *a1)
{
  *(_DWORD *)a1 = off_81582E8;
  sub_812281C(a1);
  return sub_8127A2E(a1);
}
// 81582E8: using guessed type int (__cdecl *off_81582E8[4])(int);

//----- (08125D70) --------------------------------------------------------
int sub_8125D70()
{
  return 0;
}

//----- (08125D7A) --------------------------------------------------------
void __cdecl sub_8125D7A(int a1)
{
  if ( (*(_DWORD *)(a1 + 168) & 0x10) != 0 && *(float *)(a1 + 152) != 0.0 )
    sub_812266E(a1, 1);
}

//----- (08125DBE) --------------------------------------------------------
int __cdecl sub_8125DBE(int a1)
{
  float v2; // [esp+4h] [ebp-84h]
  int i; // [esp+1Ch] [ebp-6Ch]
  float v5[12]; // [esp+20h] [ebp-68h] BYREF
  int v6[4]; // [esp+50h] [ebp-38h] BYREF
  float v7[7]; // [esp+60h] [ebp-28h] BYREF
  float *v8; // [esp+7Ch] [ebp-Ch] BYREF

  v8 = 0;
  if ( !(unsigned __int8)sub_81223CE(a1) )
    return 0;
  if ( !sub_812232C(a1, &v8) )
    return 0;
  sub_8127108((_DWORD *)(a1 + 4), v7);
  if ( !(unsigned __int8)sub_81232B2(a1, v8) )
    return 0;
  if ( (unsigned __int8)sub_81272AE(v7, (float *)(a1 + 4)) )
    sub_81271EE((float *)(a1 + 644), 0.69999999, (float *)(a1 + 644));
  sub_81265F4(a1);
  sub_8123F5C(a1);
  if ( v8 )
    sub_81270BA(v6);
  if ( (*(_DWORD *)(a1 + 168) & 0x10) != 0 )
  {
    if ( v8 )
    {
      sub_80B6758(v8, (float *)(a1 + 4), (float *)(a1 + 124));
      for ( i = 0; i <= 2; ++i )
      {
        sub_8127108((_DWORD *)(a1 + 12 * i + 72), &v5[3 * i]);
        sub_80B6806(v8, &v5[3 * i], (float *)(a1 + 12 * i + 72));
      }
      *(_DWORD *)(a1 + 152) = *(_DWORD *)(a1 + 136);
      if ( *(_DWORD *)(a1 + 624) < *(_DWORD *)(off_8168620 + 4) )
      {
        sub_81271AA(v8, (float *)(a1 + 612), (float *)v6);
        v2 = (long double)(*(_DWORD *)(off_8168620 + 4) - *(_DWORD *)(a1 + 624)) * 0.001;
        sub_81271EE((float *)v6, v2, (float *)v6);
      }
    }
    else
    {
      sub_8127108((_DWORD *)(a1 + 4), (_DWORD *)(a1 + 124));
      *(_DWORD *)(a1 + 152) = *(_DWORD *)(a1 + 136);
    }
  }
  sub_8126034(a1, (float *)v6, v8);
  return 1;
}
// 8125DBE: using guessed type float var_28[7];
// 8125DBE: using guessed type float var_68[12];

//----- (08126034) --------------------------------------------------------
int __cdecl sub_8126034(int a1, float *a2, float *a3)
{
  int result; // eax
  long double v4; // fst7
  int v5; // eax
  float v6; // [esp+0h] [ebp-F8h]
  float v7; // [esp+4h] [ebp-F4h]
  float v8; // [esp+4h] [ebp-F4h]
  float v9; // [esp+4h] [ebp-F4h]
  float v10; // [esp+4h] [ebp-F4h]
  float v11; // [esp+4h] [ebp-F4h]
  int v12; // [esp+28h] [ebp-D0h]
  float v13; // [esp+2Ch] [ebp-CCh]
  float v14; // [esp+30h] [ebp-C8h]
  float v15; // [esp+34h] [ebp-C4h]
  float v16; // [esp+38h] [ebp-C0h]
  float v17; // [esp+3Ch] [ebp-BCh]
  float v18[6]; // [esp+40h] [ebp-B8h] BYREF
  float v19; // [esp+58h] [ebp-A0h]
  float v20; // [esp+5Ch] [ebp-9Ch]
  float v21; // [esp+60h] [ebp-98h]
  float v22; // [esp+64h] [ebp-94h]
  float v23; // [esp+68h] [ebp-90h]
  int v24; // [esp+6Ch] [ebp-8Ch]
  int v25; // [esp+70h] [ebp-88h]
  int i; // [esp+74h] [ebp-84h]
  float v27; // [esp+78h] [ebp-80h]
  float v28; // [esp+7Ch] [ebp-7Ch]
  int v29[4]; // [esp+80h] [ebp-78h] BYREF
  int v30[4]; // [esp+90h] [ebp-68h] BYREF
  float v31[4]; // [esp+A0h] [ebp-58h] BYREF
  float v32[4]; // [esp+B0h] [ebp-48h] BYREF
  int v33[3]; // [esp+C0h] [ebp-38h] BYREF
  _DWORD v34[3]; // [esp+CCh] [ebp-2Ch] BYREF
  float v35[8]; // [esp+D8h] [ebp-20h] BYREF

  result = *(_DWORD *)(a1 + 168) & 0x100;
  if ( result )
  {
    result = off_8168620;
    if ( *(_DWORD *)(off_8168620 + 12) )
    {
      v27 = *(float *)(a1 + 628) * *(float *)(a1 + 628);
      v24 = 0;
      v23 = 0.0;
      v25 = *(_DWORD *)(a1 + 624);
      v22 = (long double)sub_8122490(a1) * 0.001;
      v21 = (long double)sub_8127896(a1) * 0.001;
      while ( 1 )
      {
        result = v25;
        if ( v25 >= *(_DWORD *)(off_8168620 + 4) )
          break;
        v24 += 12;
        v28 = (long double)v24 * 0.001;
        sub_8127166((float *)(a1 + 588), (float *)(a1 + 612), v31);
        v7 = v22 + v23;
        v20 = sub_8123068(a1, v7, v21);
        sub_8123EA4(a1, v20, (float *)v29, a3);
        sub_8127226((float *)(a1 + 588), v28, (float *)v29, v32);
        if ( a3 )
        {
          for ( i = 0; i <= 2; ++i )
            v32[i] = v28 * a2[i] + v32[i];
        }
        v4 = sub_80A1DB2(v32, v31);
        if ( v27 <= v4 )
        {
          if ( a3 )
          {
            sub_80B6758(a3, v32, v18);
            v5 = sub_812787E(a1 + 192);
            sub_8128ACC((int *)dword_89A2814, *(_DWORD *)(a1 + 656), v18, 0, (int *)(v5 + 60));
          }
          else
          {
            sub_812734C((float *)v29);
            v19 = v4;
            if ( v19 <= 0.0 )
            {
              sub_8127108((_DWORD *)(a1 + 72), v33);
              sub_8127108((_DWORD *)(a1 + 84), v34);
              sub_8127108((_DWORD *)(a1 + 96), v35);
            }
            else
            {
              v8 = 1.0 / v19;
              sub_81271EE((float *)v29, v8, (float *)v33);
              sub_80A295E((int)v33, (int)v34, v35);
            }
            sub_8128ACC((int *)dword_89A2814, *(_DWORD *)(a1 + 656), v32, v33, 0);
          }
          v17 = sub_812727A((float *)v29, (float *)v29);
          v16 = (long double)v24 * 0.001;
          v14 = (v17 + v17) * v16;
          if ( v14 != 0.0 )
          {
            v15 = v16 * v16;
            v13 = v17 * v15 - v27;
            v6 = v13 / v14 * 1000.0;
            v12 = sub_8127084(v6);
            v24 -= v12;
            if ( v24 < v25 - *(_DWORD *)(a1 + 624) )
              v24 = v25 - *(_DWORD *)(a1 + 624);
            v28 = (long double)v24 * 0.001;
            v9 = v22 + v23 + v28;
            v20 = sub_8123068(a1, v9, v21);
            sub_8123EA4(a1, v20, (float *)v29, a3);
            sub_8127226((float *)(a1 + 588), v28, (float *)v29, v32);
          }
          v10 = v22 + v23 + v28;
          v20 = sub_8123068(a1, v10, v21);
          sub_8123EA4(a1, v20, (float *)v30, a3);
          sub_8127108(v32, (_DWORD *)(a1 + 588));
          sub_8127108(v30, (_DWORD *)(a1 + 600));
          if ( a3 )
          {
            v11 = (long double)v24 * 0.001;
            sub_8127226((float *)(a1 + 612), v11, a2, (float *)(a1 + 612));
          }
          *(_DWORD *)(a1 + 624) += v24;
          v23 = v23 + v28;
          v24 = 0;
          v25 = *(_DWORD *)(a1 + 624);
          sub_8127A02((float *)a1);
          v27 = *(float *)(a1 + 628) * *(float *)(a1 + 628);
        }
        else
        {
          v25 += 12;
        }
      }
    }
  }
  return result;
}
// 8126034: using guessed type float var_58[4];
// 8126034: using guessed type float var_48[4];
// 8126034: using guessed type float var_B8[6];

//----- (081265F4) --------------------------------------------------------
float *__cdecl sub_81265F4(int a1)
{
  float v2; // [esp+4h] [ebp-14h]

  v2 = (long double)*(int *)(off_8168620 + 12) * 0.0099999998;
  sub_8127226((float *)(a1 + 632), v2, (float *)(a1 + 644), (float *)(a1 + 632));
  return sub_80A7146((float *)(a1 + 632), a1 + 72);
}

//----- (08126652) --------------------------------------------------------
int sub_8126652()
{
  return 5;
}

//----- (0812665C) --------------------------------------------------------
int __cdecl sub_812665C(int a1, int *a2)
{
  int result; // eax

  sub_8124488((char *)a1, a2);
  sub_8127B04((int)a2, (char *)(a1 + 588));
  sub_8127B04((int)a2, (char *)(a1 + 600));
  sub_8127B04((int)a2, (char *)(a1 + 612));
  sub_8127AC0((int)a2, (char *)(a1 + 624));
  sub_8127AE2((int)a2, (char *)(a1 + 628));
  sub_8127B04((int)a2, (char *)(a1 + 632));
  sub_8127B04((int)a2, (char *)(a1 + 644));
  sub_8120FCA((int)a2, (const char ***)(a1 + 656));
  sub_8127AE2((int)a2, (char *)(a1 + 660));
  sub_8127AE2((int)a2, (char *)(a1 + 664));
  result = a1;
  if ( !*(_DWORD *)(a1 + 180) )
  {
    result = a1;
    *(_DWORD *)(a1 + 168) &= ~0x10u;
  }
  return result;
}

//----- (0812677E) --------------------------------------------------------
_DWORD *__cdecl sub_812677E(_DWORD *a1)
{
  _DWORD *result; // eax

  sub_812222A(a1);
  result = a1;
  *a1 = off_81582A8;
  return result;
}
// 81582A8: using guessed type int (__cdecl *off_81582A8[2])(int);

//----- (0812679A) --------------------------------------------------------
_DWORD *__cdecl sub_812679A(_DWORD *a1)
{
  _DWORD *result; // eax

  sub_812222A(a1);
  result = a1;
  *a1 = off_81582A8;
  return result;
}
// 81582A8: using guessed type int (__cdecl *off_81582A8[2])(int);

//----- (081267B6) --------------------------------------------------------
int __cdecl sub_81267B6(_DWORD *a1)
{
  *a1 = off_81582A8;
  sub_812226E(a1);
  return 0;
}
// 81582A8: using guessed type int (__cdecl *off_81582A8[2])(int);

//----- (081267EA) --------------------------------------------------------
int __cdecl sub_81267EA(_DWORD *a1)
{
  *a1 = off_81582A8;
  sub_812226E(a1);
  return 0;
}
// 81582A8: using guessed type int (__cdecl *off_81582A8[2])(int);

//----- (0812681E) --------------------------------------------------------
int __cdecl sub_812681E(char *a1)
{
  *(_DWORD *)a1 = off_81582A8;
  sub_812226E(a1);
  return sub_81278CC(a1);
}
// 81582A8: using guessed type int (__cdecl *off_81582A8[2])(int);

//----- (08126852) --------------------------------------------------------
void __cdecl sub_8126852(int a1, int a2)
{
  sub_8122C06(a2 + 256, a1 + 204);
  sub_8122C06(a2 + 268, a1 + 216);
  sub_8122C06(a2 + 304, a1 + 228);
  sub_8122C06(a2 + 316, a1 + 240);
}

//----- (081268CA) --------------------------------------------------------
int __cdecl sub_81268CA(int a1)
{
  int v1; // eax

  v1 = sub_8122382(a1);
  return (unsigned __int8)sub_812AB74(off_8168620, (float *)(a1 + 124), *(float *)(a1 + 136), v1);
}

//----- (08126908) --------------------------------------------------------
void sub_8126908()
{
  sub_812AE66();
}

//----- (08126952) --------------------------------------------------------
int __cdecl sub_8126952(int a1)
{
  float *v3; // [esp+14h] [ebp-4h] BYREF

  v3 = 0;
  if ( !(unsigned __int8)sub_81223CE(a1) )
    return 0;
  if ( !sub_812232C(a1, &v3) )
    return 0;
  sub_81269F8(a1);
  sub_8126A7C(a1);
  if ( v3 )
    sub_80B6758(v3, (float *)(a1 + 4), (float *)(a1 + 124));
  else
    sub_8127108((_DWORD *)(a1 + 4), (_DWORD *)(a1 + 124));
  return 1;
}

//----- (081269F8) --------------------------------------------------------
void __cdecl sub_81269F8(int a1)
{
  if ( *(__int16 *)(a1 + 168) >= 0 )
    *(float *)(a1 + 136) = sub_81275A6(a1 + 228, *(float *)(a1 + 60));
  else
    *(float *)(a1 + 136) = sub_8127604(a1 + 228, (_DWORD *)(a1 + 240), *(float *)(a1 + 200), *(float *)(a1 + 60));
}

//----- (08126A7C) --------------------------------------------------------
float *__cdecl sub_8126A7C(int a1)
{
  if ( (*(_DWORD *)(a1 + 168) & 0x2000) != 0 )
    return sub_8127650(a1 + 204, (_DWORD *)(a1 + 216), *(float *)(a1 + 196), (float *)(a1 + 108), *(float *)(a1 + 60));
  else
    return sub_81275C6(a1 + 204, (float *)(a1 + 108), *(float *)(a1 + 60));
}

//----- (08126AFA) --------------------------------------------------------
int sub_8126AFA()
{
  return 9;
}

//----- (08126B04) --------------------------------------------------------
_BYTE **__cdecl sub_8126B04(int a1, int *a2)
{
  sub_81224DC(a1, a2);
  sub_812107A((int)a2, a1 + 204);
  sub_812107A((int)a2, a1 + 216);
  sub_812107A((int)a2, a1 + 228);
  sub_812107A((int)a2, a1 + 240);
  sub_8127AE2((int)a2, (char *)(a1 + 196));
  return sub_8127AE2((int)a2, (char *)(a1 + 200));
}

//----- (08126BA8) --------------------------------------------------------
int __cdecl sub_8126BA8(_DWORD *a1, _DWORD *a2)
{
  int result; // eax

  sub_8122668();
  a1[51] = a2[64];
  a1[54] = a2[67];
  a1[57] = a2[76];
  result = a2[79];
  a1[60] = result;
  return result;
}

//----- (08126C0A) --------------------------------------------------------
int __cdecl sub_8126C0A(int a1)
{
  if ( !(unsigned __int8)sub_81223CE(a1) )
    return 0;
  sub_8126A7C(a1);
  return 1;
}

//----- (08126C40) --------------------------------------------------------
int __cdecl sub_8126C40(int a1)
{
  int result; // eax
  float v2; // [esp+18h] [ebp-20h]
  float v3; // [esp+1Ch] [ebp-1Ch]
  float v4; // [esp+1Ch] [ebp-1Ch]
  float v5[6]; // [esp+20h] [ebp-18h] BYREF

  sub_81271AA((float *)(a1 + 4), (float *)(off_8168620 + 20), v5);
  v2 = Vec3Normalize(v5);
  v3 = sub_812727A(v5, (float *)(off_8168620 + 32));
  if ( v2 <= 600.0 && (v3 >= 0.5 || v2 <= 100.0) )
  {
    if ( v3 < 0.5 && v2 <= 100.0 )
      v3 = v3 + 1.1;
  }
  else
  {
    v3 = 0.0;
  }
  v4 = (1.0 - v2 * v2 / 360000.0) * v3;
  result = a1;
  *(float *)(a1 + 212) = *(float *)(a1 + 212) * v4;
  return result;
}
// 8126C40: using guessed type float var_18[6];

//----- (08126D3C) --------------------------------------------------------
void __cdecl sub_8126D3C(int a1)
{
  int v1; // ebx
  float v2[7]; // [esp+10h] [ebp-28h] BYREF
  int i; // [esp+2Ch] [ebp-Ch]

  for ( i = 0; i <= 2; ++i )
  {
    v1 = i;
    v2[v1] = sub_8127042(*(float *)(a1 + 4 * i + 108), 0.0, 1.0);
  }
  v2[3] = 1.0;
  sub_812738A(v2, (_BYTE *)(a1 + 144));
  sub_8127108((_DWORD *)(off_8168620 + 20), (_DWORD *)(a1 + 124));
  sub_8127226((float *)(a1 + 124), 8.0, (float *)(off_8168620 + 32), (float *)(a1 + 124));
  *(_DWORD *)(a1 + 136) = 1094713344;
  *(_DWORD *)(a1 + 140) = *(_DWORD *)(a1 + 136);
  sub_812266E(a1, 4);
}

//----- (08126E24) --------------------------------------------------------
int sub_8126E24()
{
  return 11;
}

//----- (08126E2E) --------------------------------------------------------
_BYTE **__cdecl sub_8126E2E(int a1, int *a2)
{
  return sub_8126B04(a1, a2);
}

//----- (08126E48) --------------------------------------------------------
_DWORD *__cdecl sub_8126E48(int a1, int a2)
{
  _DWORD *result; // eax

  if ( a2 == 0xFFFF && a1 == 1 )
    result = sub_8127B26(dword_89A238C);
  if ( a2 == 0xFFFF && a1 == 1 )
    result = sub_8127B3E(dword_89A2394);
  if ( a2 == 0xFFFF && a1 == 1 )
    result = sub_8127B56(dword_89A239C);
  if ( a2 == 0xFFFF && a1 == 1 )
    result = sub_8127B6E(dword_89A23A4);
  if ( a2 == 0xFFFF && a1 == 1 )
    result = sub_8127B86(dword_89A23AC);
  if ( a2 == 0xFFFF && a1 == 1 )
    result = sub_8127B9E(dword_89A23B4);
  if ( a2 == 0xFFFF && a1 == 1 )
    result = sub_8127BB6(dword_89A23BC);
  if ( a2 == 0xFFFF && a1 == 1 )
    result = sub_8127BCE(dword_89A23C4);
  if ( a2 == 0xFFFF && a1 == 1 )
    result = sub_8127BE6(dword_89A23CC);
  if ( a2 == 0xFFFF && a1 == 1 )
    return sub_8127BFE(dword_89A23D4);
  return result;
}
// 89A238C: using guessed type _DWORD dword_89A238C[2];
// 89A2394: using guessed type _DWORD dword_89A2394[2];
// 89A239C: using guessed type _DWORD dword_89A239C[2];
// 89A23A4: using guessed type _DWORD dword_89A23A4[2];
// 89A23AC: using guessed type _DWORD dword_89A23AC[2];
// 89A23B4: using guessed type _DWORD dword_89A23B4[2];
// 89A23BC: using guessed type _DWORD dword_89A23BC[2];
// 89A23C4: using guessed type _DWORD dword_89A23C4[2];
// 89A23CC: using guessed type _DWORD dword_89A23CC[2];
// 89A23D4: using guessed type int dword_89A23D4[3];

//----- (08126F5E) --------------------------------------------------------
long double __cdecl sub_8126F5E(float a1)
{
  return (float)fabs(a1);
}

//----- (08126F78) --------------------------------------------------------
void __cdecl sub_8126F78(float a1, float a2)
{
  float v2; // [esp+0h] [ebp-18h]

  v2 = a1 - a2;
  sub_8127490(v2, a1, a2);
}

//----- (08126F9C) --------------------------------------------------------
int __cdecl sub_8126F9C(int a1, int a2)
{
  return sub_81274DA(a2 - a1, a1, a2);
}

//----- (08126FC2) --------------------------------------------------------
long double __cdecl sub_8126FC2(float a1, float a2, float a3)
{
  float v4; // [esp+0h] [ebp-18h]
  float v5; // [esp+0h] [ebp-18h]
  float v6; // [esp+8h] [ebp-10h]

  v4 = a1 - a3;
  v6 = sub_8127490(v4, a3, a1);
  v5 = a2 - a1;
  return sub_8127490(v5, a2, v6);
}

//----- (08127000) --------------------------------------------------------
int __cdecl sub_8127000(int a1, int a2, int a3)
{
  int v3; // eax

  v3 = sub_81274DA(a1 - a3, a3, a1);
  return sub_81274DA(a2 - a1, a2, v3);
}

//----- (08127042) --------------------------------------------------------
long double __cdecl sub_8127042(float a1, float a2, float a3)
{
  if ( a2 <= (long double)a1 )
  {
    if ( a1 <= (long double)a3 )
      return a1;
    else
      return a3;
  }
  else
  {
    return a2;
  }
}

//----- (08127084) --------------------------------------------------------
int __cdecl sub_8127084(float a1)
{
  return (int)floor(a1 + 0.5);
}

//----- (081270BA) --------------------------------------------------------
int __cdecl sub_81270BA(_DWORD *a1)
{
  int result; // eax

  *a1 = 0;
  a1[1] = 0;
  result = 0;
  a1[2] = 0;
  return result;
}

//----- (081270E4) --------------------------------------------------------
int __cdecl sub_81270E4(_DWORD *a1, int a2, int a3, int a4)
{
  int result; // eax

  *a1 = a2;
  a1[1] = a3;
  result = a4;
  a1[2] = a4;
  return result;
}

//----- (08127108) --------------------------------------------------------
int __cdecl sub_8127108(_DWORD *a1, _DWORD *a2)
{
  int result; // eax

  *a2 = *a1;
  a2[1] = a1[1];
  result = a1[2];
  a2[2] = result;
  return result;
}

//----- (08127138) --------------------------------------------------------
int __cdecl sub_8127138(_DWORD *a1, _DWORD *a2)
{
  if ( a1 )
    return sub_8127108(a1, a2);
  else
    return sub_81270BA(a2);
}

//----- (08127166) --------------------------------------------------------
float *__cdecl sub_8127166(float *a1, float *a2, float *a3)
{
  float *result; // eax

  *a3 = *a1 + *a2;
  a3[1] = a1[1] + a2[1];
  result = a1 + 2;
  a3[2] = a1[2] + a2[2];
  return result;
}

//----- (081271AA) --------------------------------------------------------
float *__cdecl sub_81271AA(float *a1, float *a2, float *a3)
{
  float *result; // eax

  *a3 = *a1 - *a2;
  a3[1] = a1[1] - a2[1];
  result = a1 + 2;
  a3[2] = a1[2] - a2[2];
  return result;
}

//----- (081271EE) --------------------------------------------------------
float *__cdecl sub_81271EE(float *a1, float a2, float *a3)
{
  float *result; // eax

  *a3 = a2 * *a1;
  a3[1] = a2 * a1[1];
  result = a1 + 2;
  a3[2] = a2 * a1[2];
  return result;
}

//----- (08127226) --------------------------------------------------------
float *__cdecl sub_8127226(float *a1, float a2, float *a3, float *a4)
{
  float *result; // eax

  *a4 = a2 * *a3 + *a1;
  a4[1] = a2 * a3[1] + a1[1];
  result = a3 + 2;
  a4[2] = a2 * a3[2] + a1[2];
  return result;
}

//----- (0812727A) --------------------------------------------------------
long double __cdecl sub_812727A(float *a1, float *a2)
{
  return *a1 * *a2 + a1[1] * a2[1] + a1[2] * a2[2];
}

//----- (081272AE) --------------------------------------------------------
int __cdecl sub_81272AE(float *a1, float *a2)
{
  int v3; // [esp+0h] [ebp-4h]

  v3 = 0;
  if ( *a1 == *a2 && a1[1] == a2[1] && a1[2] == a2[2] )
    return 1;
  return v3;
}

//----- (08127318) --------------------------------------------------------
long double __cdecl sub_8127318(float *a1)
{
  return *a1 * *a1 + a1[1] * a1[1] + a1[2] * a1[2];
}

//----- (0812734C) --------------------------------------------------------
void __cdecl sub_812734C(float *a1)
{
  float v1; // [esp+0h] [ebp-8h]

  v1 = *a1 * *a1 + a1[1] * a1[1] + a1[2] * a1[2];
  sub_81274BA(v1);
}

//----- (0812738A) --------------------------------------------------------
int __cdecl sub_812738A(float *a1, _BYTE *a2)
{
  int v2; // eax
  int v3; // eax
  int v4; // eax
  int v5; // eax
  int v6; // eax
  int v7; // eax
  int v8; // eax
  int v9; // eax
  int result; // eax
  float v11; // [esp+0h] [ebp-18h]
  float v12; // [esp+0h] [ebp-18h]
  float v13; // [esp+0h] [ebp-18h]
  float v14; // [esp+0h] [ebp-18h]

  v11 = *a1 * 255.0;
  v2 = sub_8127084(v11);
  v3 = sub_8126F9C(255, v2);
  *a2 = sub_81274FA(0, v3);
  v12 = a1[1] * 255.0;
  v4 = sub_8127084(v12);
  v5 = sub_8126F9C(255, v4);
  a2[1] = sub_81274FA(0, v5);
  v13 = a1[2] * 255.0;
  v6 = sub_8127084(v13);
  v7 = sub_8126F9C(255, v6);
  a2[2] = sub_81274FA(0, v7);
  v14 = a1[3] * 255.0;
  v8 = sub_8127084(v14);
  v9 = sub_8126F9C(255, v8);
  result = sub_81274FA(0, v9);
  a2[3] = result;
  return result;
}

//----- (08127490) --------------------------------------------------------
long double __cdecl sub_8127490(float a1, float a2, float a3)
{
  if ( a1 < 0.0 )
    return a3;
  return a2;
}

//----- (081274BA) --------------------------------------------------------
long double __cdecl sub_81274BA(float a1)
{
  return (float)sqrt(a1);
}

//----- (081274DA) --------------------------------------------------------
int __cdecl sub_81274DA(int a1, int a2, int a3)
{
  if ( a1 < 0 )
    return a3;
  return a2;
}

//----- (081274FA) --------------------------------------------------------
int __cdecl sub_81274FA(int a1, int a2)
{
  return sub_81274DA(a1 - a2, a1, a2);
}

//----- (08127520) --------------------------------------------------------
float *__cdecl sub_8127520(float *a1, float *a2, float a3, float *a4)
{
  float *result; // eax

  *a4 = (*a2 - *a1) * a3 + *a1;
  a4[1] = (a2[1] - a1[1]) * a3 + a1[1];
  result = a2 + 2;
  a4[2] = (a2[2] - a1[2]) * a3 + a1[2];
  return result;
}

//----- (0812758A) --------------------------------------------------------
_DWORD *ctor_001()
{
  return sub_8126E48(1, 0xFFFF);
}

//----- (081275A6) --------------------------------------------------------
long double __cdecl sub_81275A6(int a1, float a2)
{
  return sub_8127C16((_DWORD *)a1, a2) * *(float *)(a1 + 8);
}

//----- (081275C6) --------------------------------------------------------
float *__cdecl sub_81275C6(int a1, float *a2, float a3)
{
  sub_8127C62((_DWORD *)a1, a2, a3);
  return sub_81271EE(a2, *(float *)(a1 + 8), a2);
}

//----- (08127604) --------------------------------------------------------
long double __cdecl sub_8127604(int a1, _DWORD *a2, float a3, float a4)
{
  float v5; // [esp+10h] [ebp-8h]
  float v6; // [esp+10h] [ebp-8h]
  float v7; // [esp+14h] [ebp-4h]

  v5 = sub_8127C16((_DWORD *)a1, a4);
  v7 = sub_8127C16(a2, a4);
  v6 = (v7 - v5) * a3 + v5;
  return v6 * *(float *)(a1 + 8);
}

//----- (08127650) --------------------------------------------------------
float *__cdecl sub_8127650(int a1, _DWORD *a2, float a3, float *a4, float a5)
{
  int v6[4]; // [esp+10h] [ebp-28h] BYREF
  int v7[6]; // [esp+20h] [ebp-18h] BYREF

  sub_8127C62((_DWORD *)a1, a4, a5);
  sub_8127C62(a2, (float *)v7, a5);
  sub_81271AA((float *)v7, a4, (float *)v6);
  sub_8127226(a4, a3, (float *)v6, a4);
  return sub_81271EE(a4, *(float *)(a1 + 8), a4);
}

//----- (081276E0) --------------------------------------------------------
long double __cdecl sub_81276E0(int a1, float a2)
{
  return sub_812197E((_DWORD *)*(_DWORD *)a1, a2) * *(float *)(a1 + 8);
}

//----- (08127702) --------------------------------------------------------
long double __cdecl sub_8127702(int a1, _DWORD **a2, float a3, float a4)
{
  float v5; // [esp+10h] [ebp-8h]
  float v6; // [esp+10h] [ebp-8h]
  float v7; // [esp+14h] [ebp-4h]

  v5 = sub_812197E((_DWORD *)*(_DWORD *)a1, a4);
  v7 = sub_812197E(*a2, a4);
  v6 = (v7 - v5) * a3 + v5;
  return v6 * *(float *)(a1 + 8);
}

//----- (08127752) --------------------------------------------------------
int *__cdecl sub_8127752(int a1)
{
  return sub_8127CB8((int *)&unk_89A238C, a1);
}

//----- (0812776E) --------------------------------------------------------
int __cdecl sub_812776E(char *a1)
{
  return sub_8127DDE((int *)&unk_89A238C, a1);
}

//----- (0812778A) --------------------------------------------------------
_DWORD *__cdecl sub_812778A(_DWORD *a1)
{
  _DWORD *result; // eax

  result = a1;
  *a1 = 0;
  return result;
}

//----- (08127798) --------------------------------------------------------
_DWORD *__cdecl sub_8127798(_DWORD *a1, _DWORD *a2)
{
  _DWORD *result; // eax

  result = sub_8127CAA(a2);
  *a1 = result;
  return result;
}

//----- (081277B6) --------------------------------------------------------
int __cdecl sub_81277B6(int *a1)
{
  int result; // eax

  result = (int)a1;
  if ( *a1 )
    return sub_8121FB2(*a1);
  return result;
}

//----- (081277D4) --------------------------------------------------------
_DWORD *__cdecl sub_81277D4(int *a1, _DWORD *a2)
{
  _DWORD *result; // eax

  result = (_DWORD *)*a1;
  if ( *a1 != *a2 )
  {
    if ( *a1 )
    {
      sub_8121FB2(*a1);
      *a1 = 0;
    }
    result = (_DWORD *)sub_812782E(a2);
    if ( (_BYTE)result )
    {
      result = sub_8127CAA((_DWORD *)*a2);
      *a1 = (int)result;
    }
  }
  return result;
}

//----- (0812782E) --------------------------------------------------------
_BOOL4 __cdecl sub_812782E(_DWORD *a1)
{
  return *a1 != 0;
}

//----- (08127840) --------------------------------------------------------
_DWORD *__cdecl sub_8127840(int *a1, _DWORD *a2)
{
  _DWORD *result; // eax

  result = (_DWORD *)*a1;
  if ( (_DWORD *)*a1 != a2 )
  {
    if ( *a1 )
      sub_8121FB2(*a1);
    result = sub_8127CAA(a2);
    *a1 = (int)result;
  }
  return result;
}

//----- (0812787E) --------------------------------------------------------
int __cdecl sub_812787E(int a1)
{
  return *(_DWORD *)a1;
}

//----- (08127888) --------------------------------------------------------
long double sub_8127888()
{
  return 1.0;
}

//----- (08127890) --------------------------------------------------------
void sub_8127890()
{
  ;
}

//----- (08127896) --------------------------------------------------------
int __cdecl sub_8127896(int a1)
{
  return *(_DWORD *)(a1 + 188) - *(_DWORD *)(a1 + 184);
}

//----- (081278B0) --------------------------------------------------------
int __cdecl sub_81278B0(char *a1)
{
  return sub_8127E76((int *)&unk_89A2394, a1);
}

//----- (081278CC) --------------------------------------------------------
int __cdecl sub_81278CC(char *a1)
{
  return sub_8127F0E((int *)&unk_89A239C, a1);
}

//----- (081278E8) --------------------------------------------------------
int __cdecl sub_81278E8(_DWORD *a1)
{
  *a1 = off_8158268;
  sub_81267B6(a1);
  return 0;
}
// 8158268: using guessed type int (__cdecl *off_8158268[2])(int);

//----- (0812791C) --------------------------------------------------------
int __cdecl sub_812791C(char *a1)
{
  *(_DWORD *)a1 = off_8158268;
  sub_81267B6(a1);
  return sub_81278CC(a1);
}
// 8158268: using guessed type int (__cdecl *off_8158268[2])(int);

//----- (08127950) --------------------------------------------------------
int sub_8127950()
{
  return 0;
}

//----- (0812795A) --------------------------------------------------------
int __cdecl sub_812795A(char *a1)
{
  return sub_8127FA6((int *)&unk_89A23A4, a1);
}

//----- (08127976) --------------------------------------------------------
int __cdecl sub_8127976(char *a1)
{
  return sub_812803E(dword_89A23D4, a1);
}
// 89A23D4: using guessed type int dword_89A23D4[3];

//----- (08127992) --------------------------------------------------------
int __cdecl sub_8127992(char *a1)
{
  return sub_81280D6((int *)&unk_89A23AC, a1);
}

//----- (081279AE) --------------------------------------------------------
int __cdecl sub_81279AE(char *a1)
{
  return sub_812816E((int *)&unk_89A23B4, a1);
}

//----- (081279CA) --------------------------------------------------------
int __cdecl sub_81279CA(char *a1)
{
  return sub_8128206((int *)&unk_89A23BC, a1);
}

//----- (081279E6) --------------------------------------------------------
int __cdecl sub_81279E6(char *a1)
{
  return sub_812829E((int *)&unk_89A23C4, a1);
}

//----- (08127A02) --------------------------------------------------------
float *__cdecl sub_8127A02(float *a1)
{
  long double v1; // fst7
  float *result; // eax

  v1 = sub_80A142E();
  result = a1;
  a1[157] = v1 * a1[166] + a1[165];
  return result;
}

//----- (08127A2E) --------------------------------------------------------
int __cdecl sub_8127A2E(char *a1)
{
  return sub_8128336((int *)&unk_89A23CC, a1);
}

//----- (08127A4A) --------------------------------------------------------
int __cdecl sub_8127A4A(int a1)
{
  return *(unsigned __int8 *)(a1 + 4);
}

//----- (08127A56) --------------------------------------------------------
int __cdecl sub_8127A56(int *a1)
{
  int v2; // [esp+14h] [ebp-4h] BYREF

  sub_8120968(a1, &v2, 4);
  return v2;
}

//----- (08127A7C) --------------------------------------------------------
int sub_8127A7C(int *a1, ...)
{
  va_list va; // [esp+24h] [ebp+Ch] BYREF

  va_start(va, a1);
  return sub_8120BFA(a1, (char *)va, 4);
}

//----- (08127A9E) --------------------------------------------------------
_BYTE **__cdecl sub_8127A9E(int a1, char *a2)
{
  return sub_8120F84(a1, a2, 1);
}

//----- (08127AC0) --------------------------------------------------------
_BYTE **__cdecl sub_8127AC0(int a1, char *a2)
{
  return sub_8120F84(a1, a2, 4);
}

//----- (08127AE2) --------------------------------------------------------
_BYTE **__cdecl sub_8127AE2(int a1, char *a2)
{
  return sub_8120F84(a1, a2, 4);
}

//----- (08127B04) --------------------------------------------------------
_BYTE **__cdecl sub_8127B04(int a1, char *a2)
{
  return sub_8120F84(a1, a2, 12);
}

//----- (08127B26) --------------------------------------------------------
_DWORD *__cdecl sub_8127B26(_DWORD *a1)
{
  _DWORD *result; // eax

  *a1 = 481;
  result = a1;
  a1[1] = 0;
  return result;
}

//----- (08127B3E) --------------------------------------------------------
_DWORD *__cdecl sub_8127B3E(_DWORD *a1)
{
  _DWORD *result; // eax

  *a1 = 167;
  result = a1;
  a1[1] = 0;
  return result;
}

//----- (08127B56) --------------------------------------------------------
_DWORD *__cdecl sub_8127B56(_DWORD *a1)
{
  _DWORD *result; // eax

  *a1 = 129;
  result = a1;
  a1[1] = 0;
  return result;
}

//----- (08127B6E) --------------------------------------------------------
_DWORD *__cdecl sub_8127B6E(_DWORD *a1)
{
  _DWORD *result; // eax

  *a1 = 55;
  result = a1;
  a1[1] = 0;
  return result;
}

//----- (08127B86) --------------------------------------------------------
_DWORD *__cdecl sub_8127B86(_DWORD *a1)
{
  _DWORD *result; // eax

  *a1 = 54;
  result = a1;
  a1[1] = 0;
  return result;
}

//----- (08127B9E) --------------------------------------------------------
_DWORD *__cdecl sub_8127B9E(_DWORD *a1)
{
  _DWORD *result; // eax

  *a1 = 54;
  result = a1;
  a1[1] = 0;
  return result;
}

//----- (08127BB6) --------------------------------------------------------
_DWORD *__cdecl sub_8127BB6(_DWORD *a1)
{
  _DWORD *result; // eax

  *a1 = 51;
  result = a1;
  a1[1] = 0;
  return result;
}

//----- (08127BCE) --------------------------------------------------------
_DWORD *__cdecl sub_8127BCE(_DWORD *a1)
{
  _DWORD *result; // eax

  *a1 = 51;
  result = a1;
  a1[1] = 0;
  return result;
}

//----- (08127BE6) --------------------------------------------------------
_DWORD *__cdecl sub_8127BE6(_DWORD *a1)
{
  _DWORD *result; // eax

  *a1 = 49;
  result = a1;
  a1[1] = 0;
  return result;
}

//----- (08127BFE) --------------------------------------------------------
_DWORD *__cdecl sub_8127BFE(_DWORD *a1)
{
  _DWORD *result; // eax

  *a1 = 51;
  result = a1;
  a1[1] = 0;
  return result;
}

//----- (08127C16) --------------------------------------------------------
long double __cdecl sub_8127C16(_DWORD *a1, float a2)
{
  sub_8128426(a1, a2);
  return (float)sub_8121A60((float *)(*a1 + 8 * a1[1] + 8), a2);
}

//----- (08127C62) --------------------------------------------------------
float *__cdecl sub_8127C62(_DWORD *a1, float *a2, float a3)
{
  sub_8128426(a1, a3);
  return sub_81283CE((float *)(*a1 + 16 * a1[1] + 8), a3, a2);
}

//----- (08127CAA) --------------------------------------------------------
_DWORD *__cdecl sub_8127CAA(_DWORD *a1)
{
  ++*a1;
  return a1;
}

//----- (08127CB8) --------------------------------------------------------
int *__cdecl sub_8127CB8(int *a1, int a2)
{
  int *i; // [esp+10h] [ebp-8h]
  int *s; // [esp+14h] [ebp-4h]

  for ( i = (int *)a1[1]; i; i = (int *)i[8190] )
  {
    if ( i[8189] )
    {
      if ( i != (int *)a1[1] )
        sub_8127D96((int)a1, (int)i);
      break;
    }
  }
  if ( i )
    goto LABEL_11;
  i = sub_8121C8A(a1[1], *a1, a2);
  if ( i )
  {
    a1[1] = (int)i;
LABEL_11:
    s = (int *)i[8189];
    i[8189] = *s;
    --i[8188];
    Com_Memset(s, 0, 0x44u);
    return s;
  }
  return 0;
}

//----- (08127D96) --------------------------------------------------------
int __cdecl sub_8127D96(int a1, int a2)
{
  int result; // eax

  sub_8121D9A(a2);
  *(_DWORD *)(a2 + 32764) = 0;
  *(_DWORD *)(a2 + 32760) = *(_DWORD *)(a1 + 4);
  *(_DWORD *)(*(_DWORD *)(a1 + 4) + 32764) = a2;
  result = a2;
  *(_DWORD *)(a1 + 4) = a2;
  return result;
}

//----- (08127DDE) --------------------------------------------------------
int __cdecl sub_8127DDE(int *a1, char *a2)
{
  int result; // eax
  char *v3; // [esp+14h] [ebp-4h]

  v3 = sub_8121E22(a2);
  if ( !*(_DWORD *)(a1[1] + 32756) )
    return sub_8127D96((int)a1, (int)v3);
  result = *((_DWORD *)v3 + 8188);
  if ( result >= *a1 )
  {
    if ( v3 != (char *)a1[1] )
      return sub_8121E02((int)v3);
    result = (int)v3;
    if ( *((_DWORD *)v3 + 8190) )
    {
      result = *((_DWORD *)v3 + 8190);
      if ( *(_DWORD *)(result + 32752) )
      {
        a1[1] = *((_DWORD *)v3 + 8190);
        return sub_8121E02((int)v3);
      }
    }
  }
  return result;
}

//----- (08127E76) --------------------------------------------------------
int __cdecl sub_8127E76(int *a1, char *a2)
{
  int result; // eax
  char *v3; // [esp+14h] [ebp-4h]

  v3 = sub_8121E22(a2);
  if ( !*(_DWORD *)(a1[1] + 32756) )
    return sub_81284AE((int)a1, (int)v3);
  result = *((_DWORD *)v3 + 8188);
  if ( result >= *a1 )
  {
    if ( v3 != (char *)a1[1] )
      return sub_8121E02((int)v3);
    result = (int)v3;
    if ( *((_DWORD *)v3 + 8190) )
    {
      result = *((_DWORD *)v3 + 8190);
      if ( *(_DWORD *)(result + 32752) )
      {
        a1[1] = *((_DWORD *)v3 + 8190);
        return sub_8121E02((int)v3);
      }
    }
  }
  return result;
}

//----- (08127F0E) --------------------------------------------------------
int __cdecl sub_8127F0E(int *a1, char *a2)
{
  int result; // eax
  char *v3; // [esp+14h] [ebp-4h]

  v3 = sub_8121E22(a2);
  if ( !*(_DWORD *)(a1[1] + 32756) )
    return sub_81284F6((int)a1, (int)v3);
  result = *((_DWORD *)v3 + 8188);
  if ( result >= *a1 )
  {
    if ( v3 != (char *)a1[1] )
      return sub_8121E02((int)v3);
    result = (int)v3;
    if ( *((_DWORD *)v3 + 8190) )
    {
      result = *((_DWORD *)v3 + 8190);
      if ( *(_DWORD *)(result + 32752) )
      {
        a1[1] = *((_DWORD *)v3 + 8190);
        return sub_8121E02((int)v3);
      }
    }
  }
  return result;
}

//----- (08127FA6) --------------------------------------------------------
int __cdecl sub_8127FA6(int *a1, char *a2)
{
  int result; // eax
  char *v3; // [esp+14h] [ebp-4h]

  v3 = sub_8121E22(a2);
  if ( !*(_DWORD *)(a1[1] + 32756) )
    return sub_812853E((int)a1, (int)v3);
  result = *((_DWORD *)v3 + 8188);
  if ( result >= *a1 )
  {
    if ( v3 != (char *)a1[1] )
      return sub_8121E02((int)v3);
    result = (int)v3;
    if ( *((_DWORD *)v3 + 8190) )
    {
      result = *((_DWORD *)v3 + 8190);
      if ( *(_DWORD *)(result + 32752) )
      {
        a1[1] = *((_DWORD *)v3 + 8190);
        return sub_8121E02((int)v3);
      }
    }
  }
  return result;
}

//----- (0812803E) --------------------------------------------------------
int __cdecl sub_812803E(int *a1, char *a2)
{
  int result; // eax
  char *v3; // [esp+14h] [ebp-4h]

  v3 = sub_8121E22(a2);
  if ( !*(_DWORD *)(a1[1] + 32756) )
    return sub_8128586((int)a1, (int)v3);
  result = *((_DWORD *)v3 + 8188);
  if ( result >= *a1 )
  {
    if ( v3 != (char *)a1[1] )
      return sub_8121E02((int)v3);
    result = (int)v3;
    if ( *((_DWORD *)v3 + 8190) )
    {
      result = *((_DWORD *)v3 + 8190);
      if ( *(_DWORD *)(result + 32752) )
      {
        a1[1] = *((_DWORD *)v3 + 8190);
        return sub_8121E02((int)v3);
      }
    }
  }
  return result;
}

//----- (081280D6) --------------------------------------------------------
int __cdecl sub_81280D6(int *a1, char *a2)
{
  int result; // eax
  char *v3; // [esp+14h] [ebp-4h]

  v3 = sub_8121E22(a2);
  if ( !*(_DWORD *)(a1[1] + 32756) )
    return sub_81285CE((int)a1, (int)v3);
  result = *((_DWORD *)v3 + 8188);
  if ( result >= *a1 )
  {
    if ( v3 != (char *)a1[1] )
      return sub_8121E02((int)v3);
    result = (int)v3;
    if ( *((_DWORD *)v3 + 8190) )
    {
      result = *((_DWORD *)v3 + 8190);
      if ( *(_DWORD *)(result + 32752) )
      {
        a1[1] = *((_DWORD *)v3 + 8190);
        return sub_8121E02((int)v3);
      }
    }
  }
  return result;
}

//----- (0812816E) --------------------------------------------------------
int __cdecl sub_812816E(int *a1, char *a2)
{
  int result; // eax
  char *v3; // [esp+14h] [ebp-4h]

  v3 = sub_8121E22(a2);
  if ( !*(_DWORD *)(a1[1] + 32756) )
    return sub_8128616((int)a1, (int)v3);
  result = *((_DWORD *)v3 + 8188);
  if ( result >= *a1 )
  {
    if ( v3 != (char *)a1[1] )
      return sub_8121E02((int)v3);
    result = (int)v3;
    if ( *((_DWORD *)v3 + 8190) )
    {
      result = *((_DWORD *)v3 + 8190);
      if ( *(_DWORD *)(result + 32752) )
      {
        a1[1] = *((_DWORD *)v3 + 8190);
        return sub_8121E02((int)v3);
      }
    }
  }
  return result;
}

//----- (08128206) --------------------------------------------------------
int __cdecl sub_8128206(int *a1, char *a2)
{
  int result; // eax
  char *v3; // [esp+14h] [ebp-4h]

  v3 = sub_8121E22(a2);
  if ( !*(_DWORD *)(a1[1] + 32756) )
    return sub_812865E((int)a1, (int)v3);
  result = *((_DWORD *)v3 + 8188);
  if ( result >= *a1 )
  {
    if ( v3 != (char *)a1[1] )
      return sub_8121E02((int)v3);
    result = (int)v3;
    if ( *((_DWORD *)v3 + 8190) )
    {
      result = *((_DWORD *)v3 + 8190);
      if ( *(_DWORD *)(result + 32752) )
      {
        a1[1] = *((_DWORD *)v3 + 8190);
        return sub_8121E02((int)v3);
      }
    }
  }
  return result;
}

//----- (0812829E) --------------------------------------------------------
int __cdecl sub_812829E(int *a1, char *a2)
{
  int result; // eax
  char *v3; // [esp+14h] [ebp-4h]

  v3 = sub_8121E22(a2);
  if ( !*(_DWORD *)(a1[1] + 32756) )
    return sub_81286A6((int)a1, (int)v3);
  result = *((_DWORD *)v3 + 8188);
  if ( result >= *a1 )
  {
    if ( v3 != (char *)a1[1] )
      return sub_8121E02((int)v3);
    result = (int)v3;
    if ( *((_DWORD *)v3 + 8190) )
    {
      result = *((_DWORD *)v3 + 8190);
      if ( *(_DWORD *)(result + 32752) )
      {
        a1[1] = *((_DWORD *)v3 + 8190);
        return sub_8121E02((int)v3);
      }
    }
  }
  return result;
}

//----- (08128336) --------------------------------------------------------
int __cdecl sub_8128336(int *a1, char *a2)
{
  int result; // eax
  char *v3; // [esp+14h] [ebp-4h]

  v3 = sub_8121E22(a2);
  if ( !*(_DWORD *)(a1[1] + 32756) )
    return sub_81286EE((int)a1, (int)v3);
  result = *((_DWORD *)v3 + 8188);
  if ( result >= *a1 )
  {
    if ( v3 != (char *)a1[1] )
      return sub_8121E02((int)v3);
    result = (int)v3;
    if ( *((_DWORD *)v3 + 8190) )
    {
      result = *((_DWORD *)v3 + 8190);
      if ( *(_DWORD *)(result + 32752) )
      {
        a1[1] = *((_DWORD *)v3 + 8190);
        return sub_8121E02((int)v3);
      }
    }
  }
  return result;
}

//----- (081283CE) --------------------------------------------------------
float *__cdecl sub_81283CE(float *a1, float a2, float *a3)
{
  float v4; // [esp+8h] [ebp-20h]

  v4 = (a2 - *a1) / (a1[4] - *a1);
  return sub_8127520(a1 + 1, a1 + 5, v4, a3);
}

//----- (08128426) --------------------------------------------------------
void __cdecl sub_8128426(_DWORD *a1, float a2)
{
  int v2; // [esp+0h] [ebp-8h]
  float *v3; // [esp+4h] [ebp-4h]

  v2 = *(_DWORD *)*a1 + 1;
  v3 = (float *)(*a1 + 4 * v2 * a1[1] + 8);
  if ( *v3 > (long double)a2 )
  {
    a1[1] = 0;
    v3 = (float *)(*a1 + 8);
  }
  while ( a2 > (long double)v3[v2] )
  {
    ++a1[1];
    v3 += v2;
  }
}

//----- (081284AE) --------------------------------------------------------
int __cdecl sub_81284AE(int a1, int a2)
{
  int result; // eax

  sub_8121D9A(a2);
  *(_DWORD *)(a2 + 32764) = 0;
  *(_DWORD *)(a2 + 32760) = *(_DWORD *)(a1 + 4);
  *(_DWORD *)(*(_DWORD *)(a1 + 4) + 32764) = a2;
  result = a2;
  *(_DWORD *)(a1 + 4) = a2;
  return result;
}

//----- (081284F6) --------------------------------------------------------
int __cdecl sub_81284F6(int a1, int a2)
{
  int result; // eax

  sub_8121D9A(a2);
  *(_DWORD *)(a2 + 32764) = 0;
  *(_DWORD *)(a2 + 32760) = *(_DWORD *)(a1 + 4);
  *(_DWORD *)(*(_DWORD *)(a1 + 4) + 32764) = a2;
  result = a2;
  *(_DWORD *)(a1 + 4) = a2;
  return result;
}

//----- (0812853E) --------------------------------------------------------
int __cdecl sub_812853E(int a1, int a2)
{
  int result; // eax

  sub_8121D9A(a2);
  *(_DWORD *)(a2 + 32764) = 0;
  *(_DWORD *)(a2 + 32760) = *(_DWORD *)(a1 + 4);
  *(_DWORD *)(*(_DWORD *)(a1 + 4) + 32764) = a2;
  result = a2;
  *(_DWORD *)(a1 + 4) = a2;
  return result;
}

//----- (08128586) --------------------------------------------------------
int __cdecl sub_8128586(int a1, int a2)
{
  int result; // eax

  sub_8121D9A(a2);
  *(_DWORD *)(a2 + 32764) = 0;
  *(_DWORD *)(a2 + 32760) = *(_DWORD *)(a1 + 4);
  *(_DWORD *)(*(_DWORD *)(a1 + 4) + 32764) = a2;
  result = a2;
  *(_DWORD *)(a1 + 4) = a2;
  return result;
}

//----- (081285CE) --------------------------------------------------------
int __cdecl sub_81285CE(int a1, int a2)
{
  int result; // eax

  sub_8121D9A(a2);
  *(_DWORD *)(a2 + 32764) = 0;
  *(_DWORD *)(a2 + 32760) = *(_DWORD *)(a1 + 4);
  *(_DWORD *)(*(_DWORD *)(a1 + 4) + 32764) = a2;
  result = a2;
  *(_DWORD *)(a1 + 4) = a2;
  return result;
}

//----- (08128616) --------------------------------------------------------
int __cdecl sub_8128616(int a1, int a2)
{
  int result; // eax

  sub_8121D9A(a2);
  *(_DWORD *)(a2 + 32764) = 0;
  *(_DWORD *)(a2 + 32760) = *(_DWORD *)(a1 + 4);
  *(_DWORD *)(*(_DWORD *)(a1 + 4) + 32764) = a2;
  result = a2;
  *(_DWORD *)(a1 + 4) = a2;
  return result;
}

//----- (0812865E) --------------------------------------------------------
int __cdecl sub_812865E(int a1, int a2)
{
  int result; // eax

  sub_8121D9A(a2);
  *(_DWORD *)(a2 + 32764) = 0;
  *(_DWORD *)(a2 + 32760) = *(_DWORD *)(a1 + 4);
  *(_DWORD *)(*(_DWORD *)(a1 + 4) + 32764) = a2;
  result = a2;
  *(_DWORD *)(a1 + 4) = a2;
  return result;
}

//----- (081286A6) --------------------------------------------------------
int __cdecl sub_81286A6(int a1, int a2)
{
  int result; // eax

  sub_8121D9A(a2);
  *(_DWORD *)(a2 + 32764) = 0;
  *(_DWORD *)(a2 + 32760) = *(_DWORD *)(a1 + 4);
  *(_DWORD *)(*(_DWORD *)(a1 + 4) + 32764) = a2;
  result = a2;
  *(_DWORD *)(a1 + 4) = a2;
  return result;
}

//----- (081286EE) --------------------------------------------------------
int __cdecl sub_81286EE(int a1, int a2)
{
  int result; // eax

  sub_8121D9A(a2);
  *(_DWORD *)(a2 + 32764) = 0;
  *(_DWORD *)(a2 + 32760) = *(_DWORD *)(a1 + 4);
  *(_DWORD *)(*(_DWORD *)(a1 + 4) + 32764) = a2;
  result = a2;
  *(_DWORD *)(a1 + 4) = a2;
  return result;
}

//----- (0812873E) --------------------------------------------------------
int __cdecl sub_812873E(int a1)
{
  int v2; // [esp+14h] [ebp-4h] BYREF

  sub_812875E(&v2, a1);
  return v2;
}

//----- (0812875E) --------------------------------------------------------
_DWORD *__userpurge sub_812875E@<eax>(_DWORD *a1, int a2)
{
  if ( *(_WORD *)(a2 + 4) )
    *a1 = *(_DWORD *)(*(_DWORD *)a2 + 4 * sub_80A8776(0, *(unsigned __int16 *)(a2 + 4)));
  else
    *a1 = 0;
  return a1;
}

//----- (081287D0) --------------------------------------------------------
int __cdecl sub_81287D0(int a1)
{
  int result; // eax

  *(_DWORD *)(a1 + 4) = 0;
  result = a1;
  *(_DWORD *)(a1 + 8) = 0;
  return result;
}

//----- (081287EA) --------------------------------------------------------
int __cdecl sub_81287EA(int a1, char a2, int a3)
{
  int result; // eax
  int v4; // [esp+10h] [ebp-8h]

  while ( *(_DWORD *)(a1 + 4) )
  {
    v4 = *(_DWORD *)(a1 + 4);
    *(_DWORD *)(a1 + 4) = *(_DWORD *)(v4 + 76);
    sub_8129BF4((char *)v4);
  }
  result = a1;
  *(_DWORD *)(a1 + 8) = 0;
  if ( a2 )
    return sub_81298BC(a3);
  return result;
}

//----- (08128844) --------------------------------------------------------
void sub_8128844()
{
  sub_812F0A2("FxScheduler::PlayEffect called with invalid effect\n");
}

//----- (08128858) --------------------------------------------------------
void __cdecl sub_8128858(int *a1, int a2, float *a3)
{
  _DWORD v3[3]; // [esp+20h] [ebp-38h] BYREF
  int v4[3]; // [esp+2Ch] [ebp-2Ch] BYREF
  int v5[8]; // [esp+38h] [ebp-20h] BYREF

  sub_8129A02(v3, 0, 0, 1065353216);
  sub_8129A02(v4, 1065353216, 0, 0);
  sub_8129A02(v5, 0, 1065353216, 0);
  sub_8128ACC(a1, a2, a3, v3, 0);
}
// 8128858: using guessed type _DWORD var_38[3];
// 8128858: using guessed type int anonymous_0[3];
// 8128858: using guessed type int anonymous_1[8];

//----- (08128900) --------------------------------------------------------
void __cdecl sub_8128900(int *a1, int a2, float *a3, _DWORD *a4)
{
  _DWORD v4[3]; // [esp+20h] [ebp-38h] BYREF
  int v5; // [esp+2Ch] [ebp-2Ch] BYREF
  float v6; // [esp+38h] [ebp-20h] BYREF

  sub_8129A26(a4, v4);
  sub_80A295E((int)v4, (int)&v5, &v6);
  sub_8128ACC(a1, a2, a3, v4, 0);
}
// 8128900: using guessed type _DWORD var_38[3];

//----- (08128962) --------------------------------------------------------
void __cdecl sub_8128962(int *a1, int a2, float *a3, _DWORD *a4, _DWORD *a5)
{
  float v5[3]; // [esp+20h] [ebp-38h] BYREF
  float v6; // [esp+2Ch] [ebp-2Ch] BYREF
  float v7[8]; // [esp+38h] [ebp-20h] BYREF

  sub_8129A26(a4, v5);
  sub_8129A26(a5, v7);
  sub_80A1ED8(v5, v7, &v6);
  sub_8128ACC(a1, a2, a3, v5, 0);
}
// 8128962: using guessed type float var_38[3];

//----- (081289D8) --------------------------------------------------------
_BOOL4 __cdecl sub_81289D8(int a1, float *a2)
{
  float v4; // [esp+18h] [ebp-10h]
  float v5; // [esp+18h] [ebp-10h]
  float v6; // [esp+1Ch] [ebp-Ch]
  float v7; // [esp+1Ch] [ebp-Ch]
  char v8; // [esp+23h] [ebp-5h]
  float v9; // [esp+24h] [ebp-4h]

  v8 = 0;
  v9 = 0.0;
  if ( *(float *)(a1 + 96) != 0.0 )
  {
    v8 = 1;
    v9 = sub_80A1DB2(a2, (float *)(off_8168620 + 20));
    v6 = *(float *)(a1 + 96) * *(float *)(off_8168620 + 248);
    v7 = v6 * v6;
    if ( v7 > (long double)v9 )
      return 0;
  }
  if ( *(float *)(a1 + 100) == 0.0 )
    return 1;
  if ( !v8 )
    v9 = sub_80A1DB2(a2, (float *)(off_8168620 + 20));
  v4 = *(float *)(a1 + 100) * *(float *)(off_8168620 + 248);
  v5 = v4 * v4;
  return v9 <= (long double)v5;
}

//----- (08128ACC) --------------------------------------------------------
void __cdecl sub_8128ACC(int *a1, int a2, float *a3, _DWORD *a4, int *a5)
{
  long double v5; // fst7
  int *v6; // ebx
  int v7; // eax
  int *v8; // ecx
  int v9; // edx
  float v10; // [esp+0h] [ebp-88h]
  int j; // [esp+28h] [ebp-60h]
  int v12; // [esp+2Ch] [ebp-5Ch]
  float v13[3]; // [esp+30h] [ebp-58h] BYREF
  _DWORD v14[11]; // [esp+3Ch] [ebp-4Ch] BYREF
  float v15; // [esp+68h] [ebp-20h]
  int *v16; // [esp+6Ch] [ebp-1Ch]
  int v17; // [esp+70h] [ebp-18h]
  int v18; // [esp+74h] [ebp-14h]
  int i; // [esp+78h] [ebp-10h]
  int v20; // [esp+7Ch] [ebp-Ch]

  i = 0;
  v18 = 0;
  v17 = 0;
  v15 = 0.0;
  *a1 = sub_812AE78(off_8168620);
  sub_80A8712(*a1);
  if ( !a2 )
  {
    sub_812ADC6(off_8168620, 1);
    a2 = sub_8129F6A((int)"fx/error.efx");
    sub_812ADC6(off_8168620, 0);
    if ( !a2 )
    {
      sub_8128844();
      return;
    }
  }
  if ( !*(_BYTE *)(dword_89A2C98 + 8) && *(_BYTE *)(dword_89A2C80 + 8) )
  {
    if ( a5 )
    {
      if ( *a5 < 0 || !(unsigned __int8)FX_GetBoneOrientation() )
        return;
    }
    else
    {
      if ( a3 )
        sub_8129A26(a3, v13);
      else
        sub_81299D8(v13);
      sub_80A6FE6(a4, v14);
    }
    v12 = 0;
    for ( i = 0; i < *(_DWORD *)(a2 + 4); ++i )
    {
      v20 = *(_DWORD *)(a2 + 4 * i + 8);
      if ( sub_81289D8(v20, a3)
        && ((*(_DWORD *)(v20 + 148) & 0x400) == 0
         || !(unsigned __int8)sub_812ABF4(off_8168620, a3, *(float *)(v20 + 672))) )
      {
        v18 = (int)(sub_812F170((float *)(v20 + 80)) + 0.5);
        if ( v18 )
        {
          if ( (*(_DWORD *)(v20 + 148) & 0x200) != 0 )
          {
            v10 = *(float *)(v20 + 76) - *(float *)(v20 + 72);
            v5 = sub_812997C(v10);
            v15 = v5 / (long double)v18;
          }
          v12 += v18;
          for ( j = 0; j < v18; ++j )
          {
            if ( (*(_DWORD *)(v20 + 148) & 0x200) != 0 )
              v17 = (int)((long double)j * v15);
            else
              v17 = (int)sub_812F170((float *)(v20 + 72));
            if ( v17 > 0 )
            {
              v16 = sub_8129BD8(80);
              if ( v16 )
              {
                v16[2] = *(_DWORD *)(off_8168620 + 4) + v17;
                *v16 = a2;
                v16[1] = i;
                v16[18] = j;
                v6 = v16;
                v7 = sub_812AE78(off_8168620);
                v6[17] = 57266229 * i + v7;
                if ( a5 )
                {
                  v8 = v16 + 3;
                  v9 = a5[1];
                  v16[3] = *a5;
                  v8[1] = v9;
                }
                else
                {
                  v16[3] = -1;
                  v16[4] = -1;
                }
                sub_8129A26(v13, v16 + 5);
                sub_80A6FE6(v14, v16 + 8);
                v16[19] = a1[1];
                a1[1] = (int)v16;
                ++a1[2];
              }
            }
            else
            {
              sub_8129488((int)a1, a2, v20, a5, v13, v14, -v17, j);
            }
          }
        }
      }
    }
  }
}
// 89A2C80: using guessed type int dword_89A2C80;
// 89A2C98: using guessed type int dword_89A2C98;
// 8128ACC: using guessed type float var_58[3];

//----- (08128E8A) --------------------------------------------------------
long double __cdecl sub_8128E8A(int a1, int a2)
{
  float v3; // [esp+4h] [ebp-14h]
  float v4; // [esp+8h] [ebp-10h]
  float v5; // [esp+Ch] [ebp-Ch]
  int i; // [esp+10h] [ebp-8h]
  int v7; // [esp+14h] [ebp-4h]

  v3 = 0.0;
  for ( i = 0; i < *(_DWORD *)(a2 + 4); ++i )
  {
    v7 = *(_DWORD *)(a2 + 4 * i + 8);
    v5 = *(float *)(v7 + 76);
    v4 = *(float *)(v7 + 92);
    if ( v4 + v5 > (long double)v3 )
      v3 = v4 + v5;
  }
  return v3;
}

//----- (08128EFA) --------------------------------------------------------
float *__cdecl sub_8128EFA(int a1, int a2, float *a3)
{
  int v4[4]; // [esp+20h] [ebp-38h] BYREF
  int v5[7]; // [esp+30h] [ebp-28h] BYREF
  float v6; // [esp+4Ch] [ebp-Ch]

  sub_8122C06(a2 + 256, (int)v5);
  if ( (*(_DWORD *)(a2 + 144) & 0x2000) == 0 )
    return sub_81275C6((int)v5, a3, 0.0);
  v6 = sub_80A8720(0.0, 1.0);
  sub_8122C06(a2 + 268, (int)v4);
  return sub_8127650((int)v5, v4, v6, a3, 0.0);
}

//----- (08128FA2) --------------------------------------------------------
void __cdecl sub_8128FA2(int a1, int a2)
{
  float v2; // [esp+1Ch] [ebp-3Ch]
  int v3[4]; // [esp+20h] [ebp-38h] BYREF
  int v4[7]; // [esp+30h] [ebp-28h] BYREF
  float v5; // [esp+4Ch] [ebp-Ch]

  sub_8122C06(a2 + 280, (int)v4);
  if ( (*(_DWORD *)(a2 + 144) & 0x4000) != 0 )
  {
    v5 = sub_80A8720(0.0, 1.0);
    sub_8122C06(a2 + 292, (int)v3);
    v2 = sub_8127604((int)v4, v3, v5, 0.0);
  }
  else
  {
    v2 = sub_81275A6((int)v4, 0.0);
  }
  sub_8129996(v2, 0.0, 1.0);
}

//----- (0812905E) --------------------------------------------------------
long double __cdecl sub_812905E(int a1, int a2)
{
  int v4[4]; // [esp+20h] [ebp-38h] BYREF
  int v5[7]; // [esp+30h] [ebp-28h] BYREF
  float v6; // [esp+4Ch] [ebp-Ch]

  sub_8122C06(a2 + 304, (int)v5);
  if ( *(__int16 *)(a2 + 144) >= 0 )
  {
    return (float)sub_81275A6((int)v5, 0.0);
  }
  else
  {
    v6 = sub_80A8720(0.0, 1.0);
    sub_8122C06(a2 + 316, (int)v4);
    return (float)sub_8127604((int)v5, v4, v6, 0.0);
  }
}

//----- (08129104) --------------------------------------------------------
void sub_8129104()
{
  ;
}

//----- (0812910A) --------------------------------------------------------
_BOOL4 __cdecl sub_812910A(int a1, int *a2, int *a3)
{
  _DWORD *v3; // eax
  int v6[5]; // [esp+20h] [ebp-18h] BYREF

  if ( (*(_DWORD *)(a1 + 144) & 2) == 0 || !a2 || *a2 < 0 )
    return 1;
  sub_8121EF6(v6, a2);
  sub_81277D4(a3, v6);
  sub_81277B6(v6);
  if ( !sub_812782E(a3) )
    return 0;
  v3 = (_DWORD *)sub_812787E((int)a3);
  return sub_8122008(v3) != 0;
}
// 812910A: using guessed type int var_18[5];

//----- (081291DE) --------------------------------------------------------
float *__cdecl sub_81291DE(int a1, float *a2, int a3)
{
  float *result; // eax
  float v4; // [esp+Ch] [ebp-Ch]

  result = (float *)(*(_DWORD *)(a1 + 148) & 0x100);
  if ( result )
  {
    v4 = sub_80A8720(0.0, 360.0);
    sub_80A2672((int)(a2 + 3), (int)a2, (float *)(a3 + 12), v4);
    return sub_80A1ED8(a2, a2 + 3, a2 + 6);
  }
  return result;
}

//----- (08129250) --------------------------------------------------------
void __cdecl sub_8129250(int *a1, float *a2, float *a3, int a4, int a5)
{
  switch ( *(_DWORD *)(a1[1] + 64) )
  {
    case 1:
      sub_81337F2(a1, a2, a3, a4, a5);
      break;
    case 2:
      sub_813392A(a1, a2, a3);
      break;
    case 3:
      sub_8133C04(a1, a2, a3, a4, a5);
      break;
    case 4:
      sub_8133D9E(a1, a2, a3, a4, a5);
      break;
    case 5:
      sub_8133F44(a1, a2, a3, a4);
      break;
    case 6:
      sub_813431A((int)a1, a2, a3);
      break;
    case 7:
      sub_8134642(a1, a2, a3, a4, a5);
      break;
    case 8:
      sub_8134368((int)a1, a2, a3);
      break;
    case 9:
      sub_81344EE(a1, a2, a3);
      break;
    case 0xA:
      sub_8134432((int)a1, a2, a3);
      break;
    case 0xB:
      sub_81347FC(a1, (int)a2, a3);
      break;
    case 0xC:
      sub_813493C(a1, a2, a3, a4, a5);
      break;
    default:
      return;
  }
}

//----- (08129488) --------------------------------------------------------
int __cdecl sub_8129488(int a1, int a2, int a3, int *a4, float *a5, _DWORD *a6, int a7, int a8)
{
  int v9[2]; // [esp+30h] [ebp-48h] BYREF
  int v10; // [esp+38h] [ebp-40h] BYREF
  float v11[14]; // [esp+40h] [ebp-38h] BYREF

  sub_8129BAC((int)v9);
  sub_80A6FE6(a6, v11);
  sub_81291DE(a3, v11, (int)a6);
  if ( sub_812910A(a3, a4, &v10) )
  {
    v9[0] = a2;
    v9[1] = a3;
    sub_8129250(v9, v11, a5, a7, a8);
  }
  return sub_8129BC2((int)v9);
}
// 8129488: using guessed type float var_38[14];

//----- (08129558) --------------------------------------------------------
int *__cdecl sub_8129558(int a1, int *a2)
{
  int *result; // eax
  int *v3; // [esp+10h] [ebp-8h]
  int j; // [esp+10h] [ebp-8h]
  int *i; // [esp+14h] [ebp-4h] BYREF

  if ( (unsigned __int8)sub_8127A4A((int)a2) )
  {
    *(_DWORD *)(a1 + 4) = 0;
    *(_DWORD *)(a1 + 8) = 0;
    result = (int *)sub_8127A56(a2);
    for ( i = result; i; i = (int *)((char *)i - 1) )
    {
      v3 = sub_8129BD8(80);
      sub_812966C((int)v3, (int)a2);
      if ( *v3 && v3[1] >= 0 && v3[1] < *(_DWORD *)(*v3 + 4) && *(_DWORD *)(*v3 + 4 * v3[1] + 8) )
      {
        v3[19] = *(_DWORD *)(a1 + 4);
        *(_DWORD *)(a1 + 4) = v3;
        ++*(_DWORD *)(a1 + 8);
      }
      else
      {
        sub_8129BF4((char *)v3);
      }
      result = (int *)&i;
    }
  }
  else
  {
    sub_8127A7C(a2, *(_DWORD *)(a1 + 8));
    result = (int *)*((_DWORD *)dword_89A2814 + 1);
    for ( j = (int)result; j; j = (int)result )
    {
      sub_812966C(j, (int)a2);
      result = *(int **)(j + 76);
    }
  }
  return result;
}

//----- (0812966C) --------------------------------------------------------
_BYTE **__cdecl sub_812966C(int a1, int a2)
{
  sub_8120FCA(a2, (const char ***)a1);
  sub_8127AC0(a2, (char *)(a1 + 4));
  sub_8127AC0(a2, (char *)(a1 + 8));
  sub_8120F84(a2, (char *)(a1 + 12), 8);
  sub_8127B04(a2, (char *)(a1 + 20));
  sub_8127B04(a2, (char *)(a1 + 32));
  sub_8127B04(a2, (char *)(a1 + 44));
  sub_8127B04(a2, (char *)(a1 + 56));
  return sub_8127AC0(a2, (char *)(a1 + 68));
}

//----- (08129736) --------------------------------------------------------
void sub_8129736()
{
  dword_89A2800 = 0;
}
// 89A2800: using guessed type int dword_89A2800;

//----- (08129746) --------------------------------------------------------
const char **__cdecl sub_8129746(char *s2)
{
  const char **v3; // [esp+10h] [ebp-8h]
  int i; // [esp+14h] [ebp-4h]

  for ( i = 0; i < dword_89A2800; ++i )
  {
    v3 = (const char **)dword_89A2400[i];
    if ( !strcmp(*v3, s2) )
      return v3;
  }
  return 0;
}
// 89A2400: using guessed type int dword_89A2400[];
// 89A2800: using guessed type int dword_89A2800;

//----- (081297A0) --------------------------------------------------------
int __cdecl sub_81297A0(int a1)
{
  if ( dword_89A2800 == 256 )
  {
    sub_812F0A2("^1Max effect templates of '%i' exceeded\n", 256);
    return 0;
  }
  else
  {
    dword_89A2400[dword_89A2800++] = a1;
    return 1;
  }
}
// 89A2400: using guessed type int dword_89A2400[];
// 89A2800: using guessed type int dword_89A2800;

//----- (081297F2) --------------------------------------------------------
char **__cdecl sub_81297F2(char *s2)
{
  const char **v1; // ebx
  char **v2; // ebx
  int v5[18]; // [esp+20h] [ebp-58h] BYREF
  char **v6; // [esp+68h] [ebp-10h]
  const char **v7; // [esp+6Ch] [ebp-Ch]

  sub_8130CD6((int)v5);
  v7 = sub_8129746(s2);
  if ( v7 )
  {
    v1 = v7;
    sub_8130D4E((int)v5);
    return (char **)v1;
  }
  else
  {
    v6 = sub_812A0D2((int)v5, s2);
    if ( v6 && (unsigned __int8)sub_81297A0((int)v6) )
    {
      v2 = v6;
      sub_8130D4E((int)v5);
      return v2;
    }
    else
    {
      sub_8130D4E((int)v5);
      return 0;
    }
  }
}

//----- (081298BC) --------------------------------------------------------
int __cdecl sub_81298BC(int a1)
{
  int result; // eax
  int v2; // [esp+Ch] [ebp-Ch]
  char v3; // [esp+13h] [ebp-5h]
  int i; // [esp+14h] [ebp-4h]

  v3 = 0;
  for ( i = 0; ; ++i )
  {
    result = i;
    if ( i >= dword_89A2800 )
      break;
    v2 = dword_89A2400[i];
    if ( v2 == a1 )
    {
      v3 = 1;
    }
    else
    {
      sub_8129E1C(v2);
      dword_89A2400[i] = 0;
    }
  }
  dword_89A2800 = 0;
  if ( v3 )
  {
    result = a1;
    dword_89A2400[dword_89A2800++] = a1;
  }
  return result;
}
// 89A2400: using guessed type int dword_89A2400[];
// 89A2800: using guessed type int dword_89A2800;

//----- (0812993E) --------------------------------------------------------
_DWORD *__cdecl sub_812993E(int a1, int a2)
{
  _DWORD *result; // eax

  if ( a2 == 0xFFFF && a1 == 1 )
    result = sub_8129C10(dword_89A23E0);
  if ( a2 == 0xFFFF && a1 == 1 )
    return sub_8129C28(dword_89A2804);
  return result;
}
// 89A23E0: using guessed type _DWORD dword_89A23E0[8];
// 89A2804: using guessed type _DWORD dword_89A2804[2];

//----- (0812997C) --------------------------------------------------------
long double __cdecl sub_812997C(float a1)
{
  return (float)fabs(a1);
}

//----- (08129996) --------------------------------------------------------
long double __cdecl sub_8129996(float a1, float a2, float a3)
{
  if ( a2 <= (long double)a1 )
  {
    if ( a1 <= (long double)a3 )
      return a1;
    else
      return a3;
  }
  else
  {
    return a2;
  }
}

//----- (081299D8) --------------------------------------------------------
int __cdecl sub_81299D8(_DWORD *a1)
{
  int result; // eax

  *a1 = 0;
  a1[1] = 0;
  result = 0;
  a1[2] = 0;
  return result;
}

//----- (08129A02) --------------------------------------------------------
int __cdecl sub_8129A02(_DWORD *a1, int a2, int a3, int a4)
{
  int result; // eax

  *a1 = a2;
  a1[1] = a3;
  result = a4;
  a1[2] = a4;
  return result;
}

//----- (08129A26) --------------------------------------------------------
int __cdecl sub_8129A26(_DWORD *a1, _DWORD *a2)
{
  int result; // eax

  *a2 = *a1;
  a2[1] = a1[1];
  result = a1[2];
  a2[2] = result;
  return result;
}

//----- (08129B90) --------------------------------------------------------
_DWORD *ctor_002()
{
  return sub_812993E(1, 0xFFFF);
}

//----- (08129BAC) --------------------------------------------------------
_DWORD *__cdecl sub_8129BAC(int a1)
{
  return sub_812778A((_DWORD *)(a1 + 8));
}

//----- (08129BC2) --------------------------------------------------------
int __cdecl sub_8129BC2(int a1)
{
  return sub_81277B6((int *)(a1 + 8));
}

//----- (08129BD8) --------------------------------------------------------
int *__cdecl sub_8129BD8(int a1)
{
  return sub_8129C40((int *)&unk_89A2804, a1);
}

//----- (08129BF4) --------------------------------------------------------
int __cdecl sub_8129BF4(char *a1)
{
  return sub_8129D66((int *)&unk_89A2804, a1);
}

//----- (08129C10) --------------------------------------------------------
_DWORD *__cdecl sub_8129C10(_DWORD *a1)
{
  _DWORD *result; // eax

  *a1 = 48;
  result = a1;
  a1[1] = 0;
  return result;
}

//----- (08129C28) --------------------------------------------------------
_DWORD *__cdecl sub_8129C28(_DWORD *a1)
{
  _DWORD *result; // eax

  *a1 = 409;
  result = a1;
  a1[1] = 0;
  return result;
}

//----- (08129C40) --------------------------------------------------------
int *__cdecl sub_8129C40(int *a1, int a2)
{
  int *i; // [esp+10h] [ebp-8h]
  int *s; // [esp+14h] [ebp-4h]

  for ( i = (int *)a1[1]; i; i = (int *)i[8190] )
  {
    if ( i[8189] )
    {
      if ( i != (int *)a1[1] )
        sub_8129D1E((int)a1, (int)i);
      break;
    }
  }
  if ( i )
    goto LABEL_11;
  i = sub_8121C8A(a1[1], *a1, a2);
  if ( i )
  {
    a1[1] = (int)i;
LABEL_11:
    s = (int *)i[8189];
    i[8189] = *s;
    --i[8188];
    Com_Memset(s, 0, 0x50u);
    return s;
  }
  return 0;
}

//----- (08129D1E) --------------------------------------------------------
int __cdecl sub_8129D1E(int a1, int a2)
{
  int result; // eax

  sub_8121D9A(a2);
  *(_DWORD *)(a2 + 32764) = 0;
  *(_DWORD *)(a2 + 32760) = *(_DWORD *)(a1 + 4);
  *(_DWORD *)(*(_DWORD *)(a1 + 4) + 32764) = a2;
  result = a2;
  *(_DWORD *)(a1 + 4) = a2;
  return result;
}

//----- (08129D66) --------------------------------------------------------
int __cdecl sub_8129D66(int *a1, char *a2)
{
  int result; // eax
  char *v3; // [esp+14h] [ebp-4h]

  v3 = sub_8121E22(a2);
  if ( !*(_DWORD *)(a1[1] + 32756) )
    return sub_8129D1E((int)a1, (int)v3);
  result = *((_DWORD *)v3 + 8188);
  if ( result >= *a1 )
  {
    if ( v3 != (char *)a1[1] )
      return sub_8121E02((int)v3);
    result = (int)v3;
    if ( *((_DWORD *)v3 + 8190) )
    {
      result = *((_DWORD *)v3 + 8190);
      if ( *(_DWORD *)(result + 32752) )
      {
        a1[1] = *((_DWORD *)v3 + 8190);
        return sub_8121E02((int)v3);
      }
    }
  }
  return result;
}

//----- (08129E00) --------------------------------------------------------
void *__cdecl sub_8129E00(size_t n)
{
  return Hunk_AllocAlignInternal(n, 4);
}

//----- (08129E1C) --------------------------------------------------------
int __cdecl sub_8129E1C(int a1)
{
  int result; // eax
  int i; // [esp+4h] [ebp-4h]

  for ( i = 0; ; ++i )
  {
    result = i;
    if ( i >= *(_DWORD *)(a1 + 4) )
      break;
    sub_812B566(*(_DWORD *)(a1 + 4 * i + 8));
  }
  return result;
}

//----- (08129E52) --------------------------------------------------------
int __cdecl sub_8129E52(int a1, const char *a2)
{
  char *v4; // [esp+1Ch] [ebp-5Ch] BYREF
  char s[68]; // [esp+20h] [ebp-58h] BYREF
  void *ptr; // [esp+64h] [ebp-14h]
  int v7; // [esp+68h] [ebp-10h] BYREF
  int v8; // [esp+6Ch] [ebp-Ch]

  sprintf(s, "fx/%s.efx", a2);
  v8 = FS_FOpenFileByMode(s, &v7, 0);
  if ( v8 >= 0 )
  {
    ptr = Hunk_AllocateTempMemoryInternal(v8 + 1);
    FS_Read((int)ptr, v8, v7);
    FS_FCloseFile(v7);
    *((_BYTE *)ptr + v8) = 0;
    v4 = (char *)ptr;
    sub_8130D92(a1, &v4, 1, 0);
    Hunk_FreeTempMemory(ptr);
    return 1;
  }
  else
  {
    sub_812F0A2("Effect file load failed: %s: file not found\n", s);
    return 0;
  }
}

//----- (08129F2C) --------------------------------------------------------
char **sub_8129F2C()
{
  char **result; // eax

  result = sub_81297F2("misc/missing_fx");
  dword_89A2818 = (int)result;
  if ( !result )
    Com_Error(1, "^1ERROR: could not load default effect file '%s'", "misc/missing_fx");
  return result;
}
// 89A2818: using guessed type int dword_89A2818;

//----- (08129F6A) --------------------------------------------------------
int __cdecl sub_8129F6A(int a1)
{
  char s2[76]; // [esp+20h] [ebp-58h] BYREF
  int v4; // [esp+6Ch] [ebp-Ch]

  if ( *(_BYTE *)a1 == 47 || *(_BYTE *)a1 == 92 )
    ++a1;
  if ( sub_812A552((_BYTE *)a1, "fx/", 3) )
  {
    sub_812F0A2("Effect file '%s' must start with fx/.\n", (const char *)a1);
    v4 = 0;
    goto LABEL_8;
  }
  sub_812A52C((_BYTE *)(a1 + 3), s2);
  v4 = sub_81297F2(s2);
  if ( !v4 )
  {
LABEL_8:
    v4 = dword_89A2818;
    return dword_89A2818;
  }
  return v4;
}
// 89A2818: using guessed type int dword_89A2818;

//----- (0812A004) --------------------------------------------------------
void __cdecl sub_812A004(int a1, int a2)
{
  int v2; // [esp+4h] [ebp-4h]

  v2 = *(_DWORD *)(a1 + 4);
  if ( v2 <= 23 )
  {
    *(_DWORD *)(a1 + 4 * v2 + 8) = a2;
    ++*(_DWORD *)(a1 + 4);
  }
  else
  {
    sub_812F0A2("FxScheduler:  Error--too many primitives in an effect\n");
  }
}

//----- (0812A03C) --------------------------------------------------------
_BOOL4 __cdecl sub_812A03C(int a1)
{
  return !byte_8168610 || *(_WORD *)(a1 + 108) != 0;
}
// 8168610: using guessed type char byte_8168610;

//----- (0812A074) --------------------------------------------------------
int __cdecl sub_812A074(int a1)
{
  if ( *(_DWORD *)(a1 + 64) != 1 && *(_DWORD *)(a1 + 64) != 7 && *(_DWORD *)(a1 + 64) != 3 || sub_812A03C(a1) )
    return 1;
  sub_812F0A2("^1FX Error, no materials defined for primitive template of type '%i'\n", *(_DWORD *)(a1 + 64));
  return 0;
}

//----- (0812A0D2) --------------------------------------------------------
char **__cdecl sub_812A0D2(int a1, char *s)
{
  const char *v2; // eax
  int v5; // [esp+14h] [ebp-24h]
  int v6; // [esp+18h] [ebp-20h]
  size_t n; // [esp+1Ch] [ebp-1Ch]
  int v8; // [esp+20h] [ebp-18h]
  char **v9; // [esp+24h] [ebp-14h]
  char *s1; // [esp+28h] [ebp-10h]
  char *dest; // [esp+2Ch] [ebp-Ch]
  int v12; // [esp+30h] [ebp-8h]

  if ( !(unsigned __int8)sub_8129E52(a1, s) )
    return 0;
  v6 = sub_812A60C(a1);
  v9 = (char **)sub_8129E00(0x68u);
  n = strlen(s) + 1;
  *v9 = (char *)sub_8129E00(n);
  strcpy(*v9, s);
  v12 = sub_812A600(v6);
  v5 = 0;
  while ( v12 )
  {
    s1 = (char *)sub_812A5EA(v12);
    if ( !strcasecmp(s1, "particle") )
    {
      v8 = 1;
    }
    else if ( !strcasecmp(s1, "line") )
    {
      v8 = 2;
    }
    else if ( !strcasecmp(s1, "tail") )
    {
      v8 = 3;
    }
    else if ( !strcasecmp(s1, "cylinder") )
    {
      v8 = 4;
    }
    else if ( !strcasecmp(s1, "emitter") )
    {
      v8 = 5;
    }
    else if ( !strcasecmp(s1, "decal") )
    {
      v8 = 6;
    }
    else if ( !strcasecmp(s1, "orientedparticle") )
    {
      v8 = 7;
    }
    else if ( !strcasecmp(s1, "fxrunner") )
    {
      v8 = 8;
    }
    else if ( !strcasecmp(s1, "light") )
    {
      v8 = 9;
    }
    else if ( !strcasecmp(s1, "cameraShake") )
    {
      v8 = 10;
    }
    else if ( !strcasecmp(s1, "flash") )
    {
      v8 = 11;
    }
    else if ( !strcasecmp(s1, "cloud") )
    {
      v8 = 12;
    }
    else
    {
      v8 = 0;
    }
    if ( v8 )
    {
      dest = (char *)sub_8129E00(0x2A4u);
      sub_812B004(dest);
      *((_DWORD *)dest + 16) = v8;
      *((_DWORD *)dest + 17) = v5;
      if ( !(unsigned __int8)sub_812F060(dest, v12) )
      {
        sub_812B566((int)dest);
        sub_8129E1C((int)v9);
        v2 = (const char *)sub_812A5EA(v12);
        sub_812F0A2("^1FX Error while parsing segment type '%s'\n", v2);
        return 0;
      }
      if ( !(unsigned __int8)sub_812A074((int)dest) )
      {
        sub_812B566((int)dest);
        sub_8129E1C((int)v9);
        sub_812F0A2("^1FX Error, invalid primitive template for effect '%s'\n", s);
        return 0;
      }
      sub_812A004((int)v9, (int)dest);
    }
    v12 = sub_812A5F4(v12);
    ++v5;
  }
  return v9;
}

//----- (0812A418) --------------------------------------------------------
int __cdecl sub_812A418(int a1)
{
  int result; // eax

  result = a1;
  if ( *(_DWORD *)a1 )
  {
    Z_FreeInternal(*(void **)a1);
    *(_DWORD *)a1 = 0;
    *(_WORD *)(a1 + 4) = 0;
    result = a1;
    *(_WORD *)(a1 + 6) = 0;
  }
  return result;
}

//----- (0812A452) --------------------------------------------------------
int __cdecl sub_812A452(int a1, int a2)
{
  int result; // eax
  void *dest; // [esp+14h] [ebp-4h]

  if ( *(_WORD *)(a1 + 4) == *(_WORD *)(a1 + 6) )
  {
    if ( *(_WORD *)(a1 + 6) )
      *(_WORD *)(a1 + 6) *= 2;
    else
      *(_WORD *)(a1 + 6) = 4;
    dest = Z_MallocInternal(4 * *(unsigned __int16 *)(a1 + 6));
    if ( *(_DWORD *)a1 )
    {
      memcpy(dest, *(const void **)a1, 4 * *(unsigned __int16 *)(a1 + 4));
      Z_FreeInternal(*(void **)a1);
    }
    *(_DWORD *)a1 = dest;
  }
  *(_DWORD *)(*(_DWORD *)a1 + 4 * *(unsigned __int16 *)(a1 + 4)) = a2;
  result = *(unsigned __int16 *)(a1 + 4) + 1;
  *(_WORD *)(a1 + 4) = result;
  return result;
}

//----- (0812A50C) --------------------------------------------------------
int __cdecl sub_812A50C(int a1, int a2)
{
  return sub_812A452(a1, a2);
}

//----- (0812A52C) --------------------------------------------------------
_BYTE *__cdecl sub_812A52C(_BYTE *a1, _BYTE *a2)
{
  sub_80B4E98(a1, a2);
  return strlwr(a2);
}

//----- (0812A552) --------------------------------------------------------
int __cdecl sub_812A552(_BYTE *a1, _BYTE *a2, int a3)
{
  char v6; // [esp+16h] [ebp-2h]
  char v7; // [esp+17h] [ebp-1h]

  while ( a3 && *a1 )
  {
    v7 = tolower((char)*a1);
    v6 = tolower((char)*a2);
    --a3;
    ++a1;
    ++a2;
    if ( v7 < v6 )
      return -1;
    if ( v7 > v6 )
      return 1;
  }
  if ( !a3 || *a1 == *a2 )
    return 0;
  else
    return -1;
}

//----- (0812A5EA) --------------------------------------------------------
int __cdecl sub_812A5EA(int a1)
{
  return *(_DWORD *)a1;
}

//----- (0812A5F4) --------------------------------------------------------
int __cdecl sub_812A5F4(int a1)
{
  return *(_DWORD *)(a1 + 4);
}

//----- (0812A600) --------------------------------------------------------
int __cdecl sub_812A600(int a1)
{
  return *(_DWORD *)(a1 + 28);
}

//----- (0812A60C) --------------------------------------------------------
int __cdecl sub_812A60C(int a1)
{
  return a1;
}

//----- (0812A642) --------------------------------------------------------
_DWORD *__cdecl sub_812A642(_DWORD *a1)
{
  _DWORD *result; // eax

  a1[1] = 0;
  a1[2] = 0;
  a1[3] = 0;
  result = a1;
  a1[4] = 0;
  return result;
}

//----- (0812A670) --------------------------------------------------------
_DWORD *__cdecl sub_812A670(_DWORD *a1)
{
  _DWORD *result; // eax

  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  a1[3] = 0;
  a1[4] = 0;
  result = a1;
  a1[61] = 0;
  return result;
}

//----- (0812A6B4) --------------------------------------------------------
int __cdecl sub_812A6B4(_DWORD *a1, int a2)
{
  int result; // eax

  if ( *(_BYTE *)(dword_89A2C98 + 8) )
  {
    a1[3] = 0;
  }
  else
  {
    if ( *a1 )
    {
      a1[3] = a2 - *a1;
      if ( (int)a1[3] >= 0 )
      {
        if ( (int)a1[3] > 200 )
          a1[3] = 200;
      }
      else
      {
        a1[3] = 0;
      }
    }
    else
    {
      a1[3] = 0;
    }
    a1[2] = a1[1];
    a1[1] += a1[3];
  }
  *a1 = a2;
  a1[61] = *a1;
  result = 112;
  qmemcpy(a1 + 33, a1 + 5, 0x70u);
  return result;
}
// 89A2C98: using guessed type int dword_89A2C98;

//----- (0812A776) --------------------------------------------------------
int __cdecl sub_812A776(int *a1, int a2)
{
  int result; // eax
  int v3; // [esp+4h] [ebp-4h]

  if ( *(_BYTE *)(dword_89A2C98 + 8) )
  {
    a1[3] = 0;
  }
  else if ( *a1 )
  {
    a1[2] = a1[1];
    v3 = a2 - a1[1];
    if ( v3 >= 0 )
    {
      a1[3] = 0;
      while ( v3 > 200 )
      {
        a1[3] = 200;
        sub_8134AAE();
        sub_81324A6();
        sub_81323E6();
        a1[2] = a1[1];
        a1[1] += a1[3];
        v3 -= 200;
      }
      a1[3] = v3;
      sub_8134AAE();
      sub_81324A6();
      sub_81323E6();
      a1[1] += a1[3];
    }
    else
    {
      a1[1] = a2;
    }
  }
  else
  {
    a1[3] = 0;
  }
  *a1 = a2;
  result = *a1;
  a1[61] = *a1;
  return result;
}
// 89A2C98: using guessed type int dword_89A2C98;

//----- (0812A882) --------------------------------------------------------
void __cdecl sub_812A882(int a1, int a2, float a3)
{
  float *v3; // ebx
  float v4; // [esp+14h] [ebp-14h] BYREF
  float v5; // [esp+18h] [ebp-10h] BYREF
  float v6; // [esp+1Ch] [ebp-Ch]
  int i; // [esp+20h] [ebp-8h]

  sub_812AED6((_DWORD *)(a2 + 36), (_DWORD *)(a1 + 32));
  v6 = *(float *)(a2 + 16) * 0.008726646259971648;
  sub_812AEA8(v6, &v5, &v4);
  sub_812AF44((float *)(a2 + 36), v5, (float *)(a1 + 48));
  sub_812AF7C((float *)(a1 + 48), v4, (float *)(a2 + 48), (float *)(a1 + 48));
  sub_812AF44((float *)(a2 + 36), v5, (float *)(a1 + 64));
  sub_812AF7C((float *)(a1 + 64), COERCE_FLOAT(LODWORD(v4) ^ 0x80000000), (float *)(a2 + 48), (float *)(a1 + 64));
  v6 = *(float *)(a2 + 20) * 0.008726646259971648;
  sub_812AEA8(v6, &v5, &v4);
  sub_812AF44((float *)(a2 + 36), v5, (float *)(a1 + 80));
  sub_812AF7C((float *)(a1 + 80), v4, (float *)(a2 + 60), (float *)(a1 + 80));
  sub_812AF44((float *)(a2 + 36), v5, (float *)(a1 + 96));
  sub_812AF7C((float *)(a1 + 96), COERCE_FLOAT(LODWORD(v4) ^ 0x80000000), (float *)(a2 + 60), (float *)(a1 + 96));
  *(_DWORD *)(a1 + 128) = 5;
  if ( a3 > 0.0 )
  {
    sub_812AF06((_DWORD *)(a2 + 36), (unsigned int *)(a1 + 112));
    *(_DWORD *)(a1 + 128) = 6;
  }
  for ( i = 0; i < *(_DWORD *)(a1 + 128); ++i )
  {
    v3 = (float *)(a1 + 16 * i + 44);
    *v3 = sub_812AFD0((float *)(a1 + 20), (float *)(a1 + 16 * i + 32));
  }
  if ( a3 > 0.0 )
    *(float *)(a1 + 124) = *(float *)(a1 + 124) - a3;
}

//----- (0812AAD2) --------------------------------------------------------
void __cdecl sub_812AAD2(int a1, int a2, float a3)
{
  double v3; // [esp+10h] [ebp-18h]

  sub_812AED6((_DWORD *)(a2 + 24), (_DWORD *)(a1 + 20));
  sub_812A882(a1, a2, a3);
  if ( *(float *)(a2 + 16) == 80.0 )
  {
    *(_DWORD *)(a1 + 248) = 1065353216;
  }
  else
  {
    v3 = tan(0.6981317007977318);
    *(float *)(a1 + 248) = v3 / tan(*(float *)(a2 + 16) * 0.5 * 0.0174532925199433);
  }
}

//----- (0812AB74) --------------------------------------------------------
int __cdecl sub_812AB74(int a1, float *a2, float a3, int a4)
{
  float v6; // [esp+10h] [ebp-8h]
  int i; // [esp+14h] [ebp-4h]

  for ( i = 0; i < a4; ++i )
  {
    v6 = sub_812AFD0((float *)(off_8168620 + 16 * i + 32), a2) - *(float *)(off_8168620 + 16 * i + 44);
    if ( -a3 > (long double)v6 )
      return 1;
  }
  return 0;
}

//----- (0812ABF4) --------------------------------------------------------
int __cdecl sub_812ABF4(int a1, float *a2, float a3)
{
  float v5; // [esp+10h] [ebp-8h]
  int i; // [esp+14h] [ebp-4h]

  for ( i = 0; i < *(_DWORD *)(off_8168620 + 240); ++i )
  {
    v5 = sub_812AFD0((float *)(off_8168620 + 16 * i + 144), a2) - *(float *)(off_8168620 + 16 * i + 156);
    if ( -a3 > (long double)v5 )
      return 1;
  }
  return 0;
}

//----- (0812AC82) --------------------------------------------------------
int __cdecl sub_812AC82(int a1, float *a2, float *a3, float a4, float a5, int a6)
{
  float v8; // [esp+10h] [ebp-8h]
  float v9; // [esp+10h] [ebp-8h]
  int i; // [esp+14h] [ebp-4h]

  for ( i = 0; i < a6; ++i )
  {
    v8 = sub_812AFD0((float *)(off_8168620 + 16 * i + 32), a2) - *(float *)(off_8168620 + 16 * i + 44);
    if ( v8 <= -a4 )
    {
      v9 = sub_812AFD0((float *)(off_8168620 + 16 * i + 32), a3) - *(float *)(off_8168620 + 16 * i + 44);
      if ( v9 <= -a5 )
        return 1;
    }
  }
  return 0;
}

//----- (0812AD4E) --------------------------------------------------------
int __cdecl sub_812AD4E(int a1, float *s, float *a3, int a4, int a5, float *a6, int a7, int a8)
{
  int result; // eax
  unsigned __int16 v9; // [esp+22h] [ebp-6h]

  CM_BoxTrace(s, a3, a6, a4, a5, 0, a8);
  if ( *s == 1.0 )
    v9 = 1023;
  else
    v9 = 1022;
  result = v9;
  *((_WORD *)s + 14) = v9;
  return result;
}

//----- (0812ADC0) --------------------------------------------------------
void sub_812ADC0()
{
  ;
}

//----- (0812ADC6) --------------------------------------------------------
int __cdecl sub_812ADC6(int a1, int a2)
{
  return a2;
}

//----- (0812ADD4) --------------------------------------------------------
int sub_812ADD4()
{
  return 0;
}

//----- (0812ADDE) --------------------------------------------------------
int __cdecl sub_812ADDE(int a1, int a2)
{
  int result; // eax

  sub_8127AC0(a2, (char *)(a1 + 4));
  sub_8127AC0(a2, (char *)(a1 + 8));
  sub_8127AC0(a2, (char *)(a1 + 12));
  sub_8127AC0(a2, (char *)(a1 + 16));
  result = sub_8127A4A(a2);
  if ( (_BYTE)result )
  {
    result = a1;
    *(_DWORD *)a1 = 0;
  }
  return result;
}

//----- (0812AE52) --------------------------------------------------------
int sub_812AE52()
{
  return 0;
}

//----- (0812AE5C) --------------------------------------------------------
int sub_812AE5C()
{
  return 0;
}

//----- (0812AE66) --------------------------------------------------------
void sub_812AE66()
{
  ;
}

//----- (0812AE72) --------------------------------------------------------
void sub_812AE72()
{
  ;
}

//----- (0812AE78) --------------------------------------------------------
int __cdecl sub_812AE78(int a1)
{
  int v2; // [esp+0h] [ebp-4h]

  v2 = *(_DWORD *)(a1 + 244);
  *(_DWORD *)(a1 + 244) = 57266229 * v2;
  return v2;
}

//----- (0812AEA8) --------------------------------------------------------
void __cdecl sub_812AEA8(float a1, float *a2, float *a3)
{
  *a2 = sin(a1);
  *a3 = cos(a1);
}

//----- (0812AED6) --------------------------------------------------------
int __cdecl sub_812AED6(_DWORD *a1, _DWORD *a2)
{
  int result; // eax

  *a2 = *a1;
  a2[1] = a1[1];
  result = a1[2];
  a2[2] = result;
  return result;
}

//----- (0812AF06) --------------------------------------------------------
unsigned int __cdecl sub_812AF06(_DWORD *a1, unsigned int *a2)
{
  unsigned int result; // eax

  *a2 = *a1 ^ 0x80000000;
  a2[1] = a1[1] ^ 0x80000000;
  result = a1[2] ^ 0x80000000;
  a2[2] = result;
  return result;
}

//----- (0812AF44) --------------------------------------------------------
float *__cdecl sub_812AF44(float *a1, float a2, float *a3)
{
  float *result; // eax

  *a3 = a2 * *a1;
  a3[1] = a2 * a1[1];
  result = a1 + 2;
  a3[2] = a2 * a1[2];
  return result;
}

//----- (0812AF7C) --------------------------------------------------------
float *__cdecl sub_812AF7C(float *a1, float a2, float *a3, float *a4)
{
  float *result; // eax

  *a4 = a2 * *a3 + *a1;
  a4[1] = a2 * a3[1] + a1[1];
  result = a3 + 2;
  a4[2] = a2 * a3[2] + a1[2];
  return result;
}

//----- (0812AFD0) --------------------------------------------------------
long double __cdecl sub_812AFD0(float *a1, float *a2)
{
  return *a1 * *a2 + a1[1] * a2[1] + a1[2] * a2[2];
}

//----- (0812B004) --------------------------------------------------------
int __cdecl sub_812B004(_DWORD *a1)
{
  int result; // eax

  sub_812F15A(a1 + 22, 1065353216, 1065353216);
  sub_812F15A(a1 + 20, 1065353216, 1065353216);
  sub_812F15A(a1 + 58, 1065353216, 1065353216);
  sub_812F15A(a1 + 60, 1065353216, 1065353216);
  sub_812119C(a1 + 64, 3, 1065353216, 0);
  sub_812119C(a1 + 67, 3, 1065353216, 0);
  sub_812119C(a1 + 70, 1, 1065353216, 0);
  sub_812119C(a1 + 73, 1, 1065353216, 0);
  sub_812119C(a1 + 76, 1, 1065353216, 0);
  sub_812119C(a1 + 79, 1, 1065353216, 0);
  sub_812119C(a1 + 82, 1, 1065353216, 0);
  sub_812119C(a1 + 85, 1, 1065353216, 0);
  sub_812119C(a1 + 88, 1, 1065353216, 0);
  sub_812119C(a1 + 91, 1, 1065353216, 0);
  sub_812119C(a1 + 94, 1, 0, 0);
  sub_812119C(a1 + 97, 1, 0, 0);
  sub_812119C(a1 + 100, 1, 0, 0);
  sub_812119C(a1 + 103, 1, 0, 0);
  sub_812119C(a1 + 106, 1, 0, 0);
  sub_812119C(a1 + 109, 1, 0, 0);
  sub_812119C(a1 + 112, 1, 0, 0);
  sub_812119C(a1 + 115, 1, 0, 0);
  sub_812119C(a1 + 118, 1, 0, 0);
  sub_812119C(a1 + 121, 1, 0, 0);
  sub_812119C(a1 + 124, 1, 0, 0);
  sub_812119C(a1 + 127, 1, 0, 0);
  sub_812119C(a1 + 130, 1, 0, 0);
  sub_812119C(a1 + 133, 1, 0, 0);
  sub_812F15A(a1 + 156, 1065353216, 1065353216);
  sub_812F15A(a1 + 158, 1065353216, 1065353216);
  sub_812F15A(a1 + 154, 1065353216, 1065353216);
  sub_812F15A(a1 + 152, 1092616192, 1092616192);
  a1[162] = 0;
  a1[163] = 1;
  a1[164] = 0;
  a1[165] = 1065353216;
  a1[166] = 0;
  a1[167] = 1;
  result = 0;
  a1[168] = 0;
  return result;
}

//----- (0812B566) --------------------------------------------------------
int __cdecl sub_812B566(int a1)
{
  sub_812A418(a1 + 104);
  sub_812A418(a1 + 112);
  sub_812A418(a1 + 120);
  sub_812A418(a1 + 128);
  return sub_812A418(a1 + 136);
}

//----- (0812B5B6) --------------------------------------------------------
int *__cdecl sub_812B5B6(int a1, void *s)
{
  int *result; // eax
  int j; // [esp+10h] [ebp-8h]
  int i; // [esp+14h] [ebp-4h] BYREF

  result = (int *)memset(s, 0, 0x600u);
  for ( i = 0; i != 24; ++i )
  {
    for ( j = 0; j != 3; ++j )
    {
      sub_812F15A((_DWORD *)s + 16 * i + 2 * j, 1065353216, 1065353216);
      sub_812F15A((_DWORD *)s + 16 * i + 2 * j + 6, 1065353216, 1065353216);
      sub_812F15A((_DWORD *)s + 16 * i + 12, 1065353216, 1065353216);
    }
    result = &i;
  }
  return result;
}

//----- (0812B68C) --------------------------------------------------------
int *__cdecl sub_812B68C(int a1, int a2)
{
  int *result; // eax
  float v3; // [esp+8h] [ebp-20h]
  int i; // [esp+1Ch] [ebp-Ch] BYREF
  int v5; // [esp+20h] [ebp-8h]
  char v6; // [esp+27h] [ebp-1h]

  for ( i = 0; i != 24; ++i )
  {
    if ( *(_BYTE *)(a2 + (i << 6) + 60) )
    {
      v6 = 0;
      v5 = 1;
      if ( i == 2 )
        v6 = 1;
      if ( !i )
        v5 = 3;
      v3 = sub_812F1B8((float *)(a1 + 88), 0.5);
      sub_81216CE(a2 + (i << 6), v5, v3, v6, (_DWORD *)(a1 + 12 * i + 256));
    }
    result = &i;
  }
  return result;
}

//----- (0812B73A) --------------------------------------------------------
int __cdecl sub_812B73A(int a1, char *s, _DWORD *a3, _DWORD *a4)
{
  int v6; // [esp+14h] [ebp-4h]

  if ( !a3 || !a4 )
    return 0;
  v6 = sscanf(s, "%f %f", a3, a4);
  if ( !v6 )
    return 0;
  if ( v6 == 1 )
    *a4 = *a3;
  return 1;
}

//----- (0812B7A4) --------------------------------------------------------
int __cdecl sub_812B7A4(int a1, char *s, _DWORD *a3, _DWORD *a4)
{
  int v6; // [esp+24h] [ebp-4h]

  if ( !a3 || !a4 )
    return 0;
  v6 = sscanf(s, "%f %f %f   %f %f %f", a3, a3 + 1, a3 + 2, a4, a4 + 1, a4 + 2);
  if ( v6 <= 2 || v6 == 4 || v6 == 5 )
    return 0;
  if ( v6 == 3 )
    sub_812F232(a3, a4);
  return 1;
}

//----- (0812B850) --------------------------------------------------------
int __cdecl sub_812B850(int a1, char *s, _DWORD *a3)
{
  int i; // [esp+24h] [ebp-94h]
  int v6; // [esp+28h] [ebp-90h]
  unsigned __int8 v7; // [esp+2Fh] [ebp-89h]
  char dest[32]; // [esp+30h] [ebp-88h] BYREF
  char v9; // [esp+50h] [ebp-68h] BYREF
  char v10; // [esp+70h] [ebp-48h] BYREF
  char v11; // [esp+90h] [ebp-28h] BYREF

  memcpy(dest, &unk_8158CD6, 0x80u);
  v7 = 1;
  v6 = sscanf(s, "%s %s %s %s", dest, &v9, &v10, &v11);
  *a3 = 0;
  for ( i = 0; i <= 3; ++i )
  {
    if ( i + 1 > v6 )
      return 1;
    if ( !strcasecmp(&dest[32 * i], "linear") )
    {
      *a3 |= 1u;
    }
    else if ( !strcasecmp(&dest[32 * i], "nonlinear") )
    {
      *a3 |= 4u;
    }
    else if ( !strcasecmp(&dest[32 * i], "wave") )
    {
      *a3 |= 8u;
    }
    else if ( !strcasecmp(&dest[32 * i], "random") )
    {
      *a3 |= 2u;
    }
    else if ( !strcasecmp(&dest[32 * i], "clamp") )
    {
      *a3 |= 0xCu;
    }
    else
    {
      v7 = 0;
    }
  }
  return v7;
}
// 812B850: using guessed type char dest[32];

//----- (0812BA42) --------------------------------------------------------
int __cdecl sub_812BA42(int a1, char *s)
{
  int v4[6]; // [esp+20h] [ebp-18h] BYREF

  if ( (unsigned __int8)sub_812B7A4(a1, s, v4, v4) != 1 )
    return 0;
  sub_812F232(v4, (_DWORD *)(a1 + 160));
  *(_DWORD *)(a1 + 144) |= 0x60u;
  return 1;
}

//----- (0812BAAE) --------------------------------------------------------
int __cdecl sub_812BAAE(int a1, char *s)
{
  int v4[6]; // [esp+20h] [ebp-18h] BYREF

  if ( (unsigned __int8)sub_812B7A4(a1, s, v4, v4) != 1 )
    return 0;
  sub_812F232(v4, (_DWORD *)(a1 + 172));
  *(_DWORD *)(a1 + 144) |= 0x60u;
  return 1;
}

//----- (0812BB1A) --------------------------------------------------------
int __cdecl sub_812BB1A(int a1, char *s)
{
  int v4; // [esp+20h] [ebp-8h] BYREF
  int v5; // [esp+24h] [ebp-4h] BYREF

  if ( !(unsigned __int8)sub_812B73A(a1, s, &v5, &v4) )
    return 0;
  sub_812F15A((_DWORD *)(a1 + 88), v5, v4);
  return 1;
}

//----- (0812BB76) --------------------------------------------------------
int __cdecl sub_812BB76(int a1, char *s)
{
  int v4; // [esp+20h] [ebp-8h] BYREF
  int v5; // [esp+24h] [ebp-4h] BYREF

  if ( !(unsigned __int8)sub_812B73A(a1, s, &v5, &v4) )
    return 0;
  if ( *(float *)&v5 > (long double)*(float *)&v4 )
    return 0;
  sub_812F15A((_DWORD *)(a1 + 96), v5, v4);
  return 1;
}

//----- (0812BBEC) --------------------------------------------------------
int __cdecl sub_812BBEC(int a1, char *s)
{
  int v4; // [esp+20h] [ebp-8h] BYREF
  int v5; // [esp+24h] [ebp-4h] BYREF

  if ( !(unsigned __int8)sub_812B73A(a1, s, &v5, &v4) )
    return 0;
  sub_812F15A((_DWORD *)(a1 + 72), v5, v4);
  return 1;
}

//----- (0812BC48) --------------------------------------------------------
int __cdecl sub_812BC48(int a1, char *s)
{
  int v4; // [esp+20h] [ebp-8h] BYREF
  int v5; // [esp+24h] [ebp-4h] BYREF

  if ( !(unsigned __int8)sub_812B73A(a1, s, &v5, &v4) )
    return 0;
  sub_812F15A((_DWORD *)(a1 + 80), v5, v4);
  return 1;
}

//----- (0812BCA4) --------------------------------------------------------
int __cdecl sub_812BCA4(int a1, char *s)
{
  int v4; // [esp+20h] [ebp-8h] BYREF
  int v5; // [esp+24h] [ebp-4h] BYREF

  if ( !(unsigned __int8)sub_812B73A(a1, s, &v5, &v4) )
    return 0;
  if ( *(float *)&v5 > (long double)*(float *)&v4 )
    return 0;
  if ( *(float *)&v5 < 0.0 )
    return 0;
  if ( *(float *)&v5 > 1.0 )
    return 0;
  if ( *(float *)&v4 < 0.0 )
    return 0;
  if ( *(float *)&v4 > 1.0 )
    return 0;
  sub_812F15A((_DWORD *)(a1 + 640), v5, v4);
  *(_DWORD *)(a1 + 144) |= 0x20u;
  return 1;
}

//----- (0812BD9A) --------------------------------------------------------
int __cdecl sub_812BD9A(_DWORD *a1, char *s)
{
  int v4[4]; // [esp+20h] [ebp-28h] BYREF
  int v5[6]; // [esp+30h] [ebp-18h] BYREF

  if ( (unsigned __int8)sub_812B7A4((int)a1, s, v5, v4) != 1 )
    return 0;
  sub_812F15A(a1 + 46, v5[0], v4[0]);
  sub_812F15A(a1 + 48, v5[1], v4[1]);
  sub_812F15A(a1 + 50, v5[2], v4[2]);
  return 1;
}

//----- (0812BE34) --------------------------------------------------------
int __cdecl sub_812BE34(_DWORD *a1, char *s)
{
  int v4[4]; // [esp+20h] [ebp-28h] BYREF
  int v5[6]; // [esp+30h] [ebp-18h] BYREF

  if ( (unsigned __int8)sub_812B7A4((int)a1, s, v5, v4) != 1 )
    return 0;
  sub_812F15A(a1 + 52, v5[0], v4[0]);
  sub_812F15A(a1 + 54, v5[1], v4[1]);
  sub_812F15A(a1 + 56, v5[2], v4[2]);
  return 1;
}

//----- (0812BECE) --------------------------------------------------------
int __cdecl sub_812BECE(int a1, char *s)
{
  int v4; // [esp+20h] [ebp-8h] BYREF
  int v5; // [esp+24h] [ebp-4h] BYREF

  if ( !(unsigned __int8)sub_812B73A(a1, s, &v5, &v4) )
    return 0;
  sub_812F15A((_DWORD *)(a1 + 232), v5, v4);
  return 1;
}

//----- (0812BF2C) --------------------------------------------------------
int __cdecl sub_812BF2C(int a1, char *s)
{
  int v4; // [esp+20h] [ebp-8h] BYREF
  int v5; // [esp+24h] [ebp-4h] BYREF

  if ( !(unsigned __int8)sub_812B73A(a1, s, &v5, &v4) )
    return 0;
  sub_812F15A((_DWORD *)(a1 + 240), v5, v4);
  return 1;
}

//----- (0812BF8A) --------------------------------------------------------
int __cdecl sub_812BF8A(int a1, char *s)
{
  int v4; // [esp+20h] [ebp-8h] BYREF
  int v5; // [esp+24h] [ebp-4h] BYREF

  if ( !(unsigned __int8)sub_812B73A(a1, s, &v5, &v4) )
    return 0;
  sub_812F15A((_DWORD *)(a1 + 248), v5, v4);
  return 1;
}

//----- (0812BFE8) --------------------------------------------------------
int __cdecl sub_812BFE8(int a1, char *s)
{
  int v4; // [esp+20h] [ebp-8h] BYREF
  int v5; // [esp+24h] [ebp-4h] BYREF

  if ( !(unsigned __int8)sub_812B73A(a1, s, &v5, &v4) )
    return 0;
  sub_812F15A((_DWORD *)(a1 + 544), v5, v4);
  return 1;
}

//----- (0812C046) --------------------------------------------------------
long double __cdecl sub_812C046(int a1, float a2, float a3)
{
  if ( a3 <= fabs(a2) )
    return (float)fabs(a2);
  else
    return a3;
}

//----- (0812C07A) --------------------------------------------------------
int __cdecl sub_812C07A(int a1, float a2, float a3, float a4, int a5, int a6)
{
  float v7; // [esp+14h] [ebp-C4h]
  float v8; // [esp+18h] [ebp-C0h]
  float v9; // [esp+18h] [ebp-C0h]
  int i; // [esp+1Ch] [ebp-BCh]
  float src[46]; // [esp+20h] [ebp-B8h] BYREF

  LODWORD(src[43]) = 20;
  for ( i = 0; i <= 19; ++i )
  {
    src[2 * i] = (long double)i / 19.0;
    if ( i )
    {
      v7 = a4 / 20.0;
      v8 = v7 * 0.00065;
      v9 = sub_812F1F4(v8, 0.0, 1.0);
      src[2 * i + 1] = (1.0 - v9) * src[2 * i - 1];
    }
    else if ( a3 == 0.0 )
    {
      src[2 * i + 1] = a2;
    }
    else
    {
      src[2 * i + 1] = a2 / a3;
    }
  }
  *(_DWORD *)(a1 + 12 * a5 + 256) = sub_8121AAC(src, 1, 20);
  return sub_812F15A((_DWORD *)(a1 + 12 * a5 + 260), a6, a6);
}

//----- (0812C1E6) --------------------------------------------------------
int __cdecl sub_812C1E6(int a1, float a2, float a3, int a4, int a5)
{
  int src; // [esp+10h] [ebp-28h] BYREF
  float v7; // [esp+14h] [ebp-24h]
  int v8; // [esp+18h] [ebp-20h]
  float v9; // [esp+1Ch] [ebp-1Ch]
  int v10; // [esp+2Ch] [ebp-Ch]

  v10 = 2;
  src = 0;
  if ( a3 == 0.0 )
    v7 = 0.0;
  else
    v7 = a2 / a3;
  v8 = 1065353216;
  v9 = v7;
  *(_DWORD *)(a1 + 12 * a4 + 256) = sub_8121AAC((float *)&src, 1, 2);
  return sub_812F15A((_DWORD *)(a1 + 12 * a4 + 260), a5, a5);
}

//----- (0812C294) --------------------------------------------------------
int __cdecl sub_812C294(int a1, float a2, float a3, float a4, int a5, int a6)
{
  int src[3]; // [esp+10h] [ebp-28h] BYREF
  float v8; // [esp+1Ch] [ebp-1Ch]
  int v9; // [esp+2Ch] [ebp-Ch]

  v9 = 2;
  src[0] = 0;
  src[1] = 0;
  src[2] = 1065353216;
  v8 = a2 * a4 * 0.001;
  if ( a3 == 0.0 )
    v8 = 0.0;
  else
    v8 = v8 / a3;
  *(_DWORD *)(a1 + 12 * a5 + 256) = sub_8121AAC((float *)src, 1, 2);
  return sub_812F15A((_DWORD *)(a1 + 12 * a5 + 260), a6, a6);
}

//----- (0812C354) --------------------------------------------------------
int __cdecl sub_812C354(int a1, char *s)
{
  float v4; // [esp+1Ch] [ebp-Ch]
  int v5; // [esp+1Ch] [ebp-Ch]
  float v6; // [esp+20h] [ebp-8h] BYREF
  float v7; // [esp+24h] [ebp-4h] BYREF

  if ( !(unsigned __int8)sub_812B73A(a1, s, &v7, &v6) )
    return 0;
  if ( v7 > (long double)v6 )
    sub_812F2F6((int *)&v7, (int *)&v6);
  v4 = sub_812C046(a1, v7, v6);
  *(float *)&v5 = v4 + v4;
  sub_812C07A(a1, v7, *(float *)&v5, *(float *)(a1 + 88), 10, v5);
  if ( v7 != v6 )
  {
    *(_DWORD *)(a1 + 144) |= 0x40000u;
    sub_812C07A(a1, v6, *(float *)&v5, *(float *)(a1 + 92), 11, 1065353216);
  }
  return 1;
}

//----- (0812C46E) --------------------------------------------------------
int __cdecl sub_812C46E(_DWORD *a1, char *s)
{
  int v4[4]; // [esp+20h] [ebp-28h] BYREF
  int v5[6]; // [esp+30h] [ebp-18h] BYREF

  if ( (unsigned __int8)sub_812B7A4((int)a1, s, v5, v4) != 1 )
    return 0;
  sub_812F15A(a1 + 138, v5[0], v4[0]);
  sub_812F15A(a1 + 140, v5[1], v4[1]);
  sub_812F15A(a1 + 142, v5[2], v4[2]);
  return 1;
}

//----- (0812C508) --------------------------------------------------------
int __cdecl sub_812C508(_DWORD *a1, char *s)
{
  int v4[4]; // [esp+20h] [ebp-28h] BYREF
  int v5[6]; // [esp+30h] [ebp-18h] BYREF

  if ( (unsigned __int8)sub_812B7A4((int)a1, s, v5, v4) != 1 )
    return 0;
  sub_812F15A(a1 + 144, v5[0], v4[0]);
  sub_812F15A(a1 + 146, v5[1], v4[1]);
  sub_812F15A(a1 + 148, v5[2], v4[2]);
  return 1;
}

//----- (0812C5A2) --------------------------------------------------------
int __cdecl sub_812C5A2(int a1, char *s)
{
  float v4; // [esp+2Ch] [ebp-3Ch]
  float v5; // [esp+30h] [ebp-38h]
  float v6; // [esp+30h] [ebp-38h]
  float v7; // [esp+34h] [ebp-34h]
  float v8; // [esp+34h] [ebp-34h]
  float v9; // [esp+38h] [ebp-30h]
  float v10; // [esp+38h] [ebp-30h]
  float v11; // [esp+40h] [ebp-28h] BYREF
  float v12; // [esp+44h] [ebp-24h] BYREF
  float v13[2]; // [esp+48h] [ebp-20h] BYREF
  float v14; // [esp+50h] [ebp-18h] BYREF
  float v15; // [esp+54h] [ebp-14h] BYREF
  float v16[4]; // [esp+58h] [ebp-10h] BYREF

  if ( (unsigned __int8)sub_812B7A4(a1, s, &v14, &v11) != 1 )
    return 0;
  if ( v14 > (long double)v11 )
    sub_812F2F6((int *)&v14, (int *)&v11);
  if ( v15 > (long double)v12 )
    sub_812F2F6((int *)&v15, (int *)&v12);
  if ( v16[0] > (long double)v13[0] )
    sub_812F2F6((int *)v16, (int *)v13);
  v5 = sub_812C046(a1, v14, v11);
  v7 = sub_812C046(a1, v15, v12);
  v9 = sub_812C046(a1, v16[0], v13[0]);
  v6 = v5 + v5;
  v8 = v7 + v7;
  v10 = v9 + v9;
  sub_812F1D0(v6, v8);
  sub_812F1D0(v10, v10);
  v4 = v10;
  sub_812C1E6(a1, v14, v4, 12, SLODWORD(v4));
  sub_812C1E6(a1, v15, v4, 13, SLODWORD(v4));
  sub_812C1E6(a1, v16[0], v4, 14, SLODWORD(v4));
  if ( !(unsigned __int8)sub_812F262(&v14, &v11) )
  {
    *(_DWORD *)(a1 + 144) |= 0x80000u;
    sub_812C1E6(a1, v11, v10, 15, 1065353216);
    sub_812C1E6(a1, v12, v10, 16, 1065353216);
    sub_812C1E6(a1, v13[0], v10, 17, 1065353216);
  }
  return 1;
}
// 812C5A2: using guessed type float var_10[4];
// 812C5A2: using guessed type float var_20[2];

//----- (0812C812) --------------------------------------------------------
int __cdecl sub_812C812(int a1, char *s2, int a3, int a4)
{
  int v6; // [esp+10h] [ebp-8h]
  int i; // [esp+14h] [ebp-4h]

  for ( i = 0; i < a4; ++i )
  {
    v6 = a3 + 12 * i;
    if ( !strcasecmp(*(const char **)v6, s2) )
    {
      *(_DWORD *)(a1 + 144) |= *(_DWORD *)(v6 + 4);
      *(_DWORD *)(a1 + 148) |= *(_DWORD *)(v6 + 8);
      return 1;
    }
  }
  return 0;
}

//----- (0812C8A0) --------------------------------------------------------
int __cdecl sub_812C8A0(int a1, char *s, int a3, int a4)
{
  unsigned __int8 v6; // [esp+23h] [ebp-15h]
  size_t v7; // [esp+24h] [ebp-14h]
  signed int v8; // [esp+28h] [ebp-10h]
  signed int size; // [esp+2Ch] [ebp-Ch]
  char *v10; // [esp+30h] [ebp-8h]
  char *s2; // [esp+34h] [ebp-4h]

  size = strlen(s);
  if ( !size )
    return 0;
  s2 = (char *)Hunk_AllocateTempMemoryInternal(size);
  v10 = s;
  v8 = 0;
  v6 = 1;
  while ( v8 < size )
  {
    if ( sscanf(v10, "%s", s2) != 1 )
    {
      v6 = 0;
      break;
    }
    v7 = strlen(s2);
    if ( !(unsigned __int8)sub_812C812(a1, s2, a3, a4) )
    {
      v6 = 0;
      break;
    }
    v8 += v7 + 1;
    v10 = &s[v8];
  }
  Hunk_FreeTempMemory(s2);
  return v6;
}

//----- (0812C978) --------------------------------------------------------
int __cdecl sub_812C978(int a1, char *s)
{
  return (unsigned __int8)sub_812C8A0(a1, s, (int)&off_8158A40, 24);
}
// 8158A40: using guessed type char *off_8158A40;

//----- (0812C9A6) --------------------------------------------------------
int __cdecl sub_812C9A6(int a1, char *s)
{
  return (unsigned __int8)sub_812C8A0(a1, s, (int)&off_8158C20, 13);
}
// 8158C20: using guessed type char *off_8158C20;

//----- (0812C9D4) --------------------------------------------------------
int __cdecl sub_812C9D4(int a1, char *s)
{
  int v4; // [esp+28h] [ebp-40h]
  float v5; // [esp+2Ch] [ebp-3Ch]
  float v6; // [esp+30h] [ebp-38h]
  float v7; // [esp+30h] [ebp-38h]
  float v8; // [esp+34h] [ebp-34h]
  float v9; // [esp+34h] [ebp-34h]
  float v10; // [esp+38h] [ebp-30h]
  float v11; // [esp+38h] [ebp-30h]
  float v12; // [esp+40h] [ebp-28h] BYREF
  float v13; // [esp+44h] [ebp-24h] BYREF
  float v14[2]; // [esp+48h] [ebp-20h] BYREF
  float v15; // [esp+50h] [ebp-18h] BYREF
  float v16; // [esp+54h] [ebp-14h] BYREF
  float v17[4]; // [esp+58h] [ebp-10h] BYREF

  if ( (unsigned __int8)sub_812B7A4(a1, s, &v15, &v12) != 1 )
    return 0;
  if ( v15 > (long double)v12 )
    sub_812F2F6((int *)&v15, (int *)&v12);
  if ( v16 > (long double)v13 )
    sub_812F2F6((int *)&v16, (int *)&v13);
  if ( v17[0] > (long double)v14[0] )
    sub_812F2F6((int *)v17, (int *)v14);
  v5 = *(float *)(a1 + 92);
  v6 = sub_812C046(a1, v15, v12);
  v8 = sub_812C046(a1, v16, v13);
  v10 = sub_812C046(a1, v17[0], v14[0]);
  v7 = v6 + v6;
  v9 = v8 + v8;
  v11 = v10 + v10;
  sub_812F1D0(v7, v9);
  sub_812F1D0(v11, v11);
  *(float *)&v4 = v5 * 0.001 * v11;
  sub_812C294(a1, v15, *(float *)&v4, v5, 18, v4);
  sub_812C294(a1, v16, *(float *)&v4, v5, 19, v4);
  sub_812C294(a1, v17[0], *(float *)&v4, v5, 20, v4);
  if ( !(unsigned __int8)sub_812F262(&v15, &v12) )
  {
    *(_DWORD *)(a1 + 144) |= 0x100000u;
    sub_812C294(a1, v12, *(float *)&v4, v5, 21, 1065353216);
    sub_812C294(a1, v13, *(float *)&v4, v5, 22, 1065353216);
    sub_812C294(a1, v14[0], *(float *)&v4, v5, 23, 1065353216);
  }
  return 1;
}
// 812C9D4: using guessed type float var_10[4];
// 812C9D4: using guessed type float var_20[2];

//----- (0812CC8A) --------------------------------------------------------
int __cdecl sub_812CC8A(int a1, char *s)
{
  int v4; // [esp+20h] [ebp-8h] BYREF
  int v5; // [esp+24h] [ebp-4h] BYREF

  if ( !(unsigned __int8)sub_812B73A(a1, s, &v5, &v4) )
    return 0;
  sub_812F15A((_DWORD *)(a1 + 600), v5, v4);
  return 1;
}

//----- (0812CCE8) --------------------------------------------------------
int __cdecl sub_812CCE8(int a1, char *s)
{
  int v4; // [esp+20h] [ebp-8h] BYREF
  int v5; // [esp+24h] [ebp-4h] BYREF

  if ( !(unsigned __int8)sub_812B73A(a1, s, &v5, &v4) )
    return 0;
  sub_812F15A((_DWORD *)(a1 + 608), v5, v4);
  return 1;
}

//----- (0812CD46) --------------------------------------------------------
int __cdecl sub_812CD46(int a1, char *s)
{
  int v4; // [esp+20h] [ebp-8h] BYREF
  int v5; // [esp+24h] [ebp-4h] BYREF

  if ( !(unsigned __int8)sub_812B73A(a1, s, &v5, &v4) )
    return 0;
  sub_812F15A((_DWORD *)(a1 + 616), v5, v4);
  return 1;
}

//----- (0812CDA4) --------------------------------------------------------
int __cdecl sub_812CDA4(int a1, char *nptr)
{
  unsigned int v4; // [esp+14h] [ebp-4h]

  v4 = atoi(nptr);
  if ( v4 >= 3 )
    return 0;
  *(_DWORD *)(a1 + 648) = v4;
  return 1;
}

//----- (0812CDE8) --------------------------------------------------------
_BOOL4 __cdecl sub_812CDE8(int a1, char *nptr)
{
  *(_DWORD *)(a1 + 652) = atoi(nptr);
  return *(_DWORD *)(a1 + 652) > 0;
}

//----- (0812CE28) --------------------------------------------------------
int __cdecl sub_812CE28(int a1, char *nptr)
{
  unsigned int v4; // [esp+14h] [ebp-4h]

  v4 = atoi(nptr);
  if ( v4 >= 2 )
    return 0;
  *(_DWORD *)(a1 + 656) = v4;
  return 1;
}

//----- (0812CE6C) --------------------------------------------------------
_BOOL4 __cdecl sub_812CE6C(int a1, char *nptr)
{
  *(float *)(a1 + 660) = atof(nptr);
  return *(float *)(a1 + 660) >= 0.0;
}

//----- (0812CEB4) --------------------------------------------------------
int __cdecl sub_812CEB4(int a1, char *nptr)
{
  unsigned int v4; // [esp+14h] [ebp-4h]

  v4 = atoi(nptr);
  if ( v4 >= 2 )
    return 0;
  *(_DWORD *)(a1 + 664) = v4;
  return 1;
}

//----- (0812CEF8) --------------------------------------------------------
_BOOL4 __cdecl sub_812CEF8(int a1, char *nptr)
{
  *(_DWORD *)(a1 + 668) = atoi(nptr);
  return *(_DWORD *)(a1 + 668) >= 0;
}

//----- (0812CF38) --------------------------------------------------------
int __cdecl sub_812CF38(int a1, char *nptr)
{
  float v4; // [esp+14h] [ebp-4h]

  v4 = atof(nptr);
  if ( v4 < 0.0 )
    return 0;
  *(float *)(a1 + 672) = v4;
  return 1;
}

//----- (0812CF7C) --------------------------------------------------------
int __cdecl sub_812CF7C(int a1, int a2, char *s, int a4)
{
  int i; // [esp+1Ch] [ebp-2Ch]
  int v7[4]; // [esp+20h] [ebp-28h] BYREF
  int v8[6]; // [esp+30h] [ebp-18h] BYREF

  if ( !(unsigned __int8)sub_812B7A4(a1, s, v8, v7) )
    return 0;
  for ( i = 0; i != 3; ++i )
    sub_812F15A((_DWORD *)(a2 + 8 * (i + 8 * a4)), v8[i], v7[i]);
  *(_BYTE *)(a2 + (a4 << 6) + 60) = 1;
  return 1;
}
// 812CF7C: using guessed type int var_28[4];
// 812CF7C: using guessed type int var_18[6];

//----- (0812D010) --------------------------------------------------------
int __cdecl sub_812D010(int a1, int a2, char *s, int a4)
{
  int i; // [esp+1Ch] [ebp-2Ch]
  int v7[4]; // [esp+20h] [ebp-28h] BYREF
  int v8[6]; // [esp+30h] [ebp-18h] BYREF

  if ( !(unsigned __int8)sub_812B7A4(a1, s, v8, v7) )
    return 0;
  for ( i = 0; i != 3; ++i )
    sub_812F15A((_DWORD *)(a2 + 8 * (i + 8 * a4) + 24), v8[i], v7[i]);
  *(_BYTE *)(a2 + (a4 << 6) + 60) = 1;
  return 1;
}
// 812D010: using guessed type int var_28[4];
// 812D010: using guessed type int var_18[6];

//----- (0812D0A8) --------------------------------------------------------
int __cdecl sub_812D0A8(int a1, int a2, char *s, int a4)
{
  int v6; // [esp+20h] [ebp-8h] BYREF
  int v7; // [esp+24h] [ebp-4h] BYREF

  if ( !(unsigned __int8)sub_812B73A(a1, s, &v7, &v6) )
    return 0;
  if ( *(float *)&v7 > (long double)*(float *)&v6 )
    sub_812F2F6(&v7, &v6);
  sub_812F15A((_DWORD *)(a2 + (a4 << 6)), v7, v6);
  *(_BYTE *)(a2 + (a4 << 6) + 60) = 1;
  return 1;
}

//----- (0812D13C) --------------------------------------------------------
int __cdecl sub_812D13C(int a1, int a2, char *s, int a4)
{
  int v6; // [esp+20h] [ebp-8h] BYREF
  int v7; // [esp+24h] [ebp-4h] BYREF

  if ( !(unsigned __int8)sub_812B73A(a1, s, &v7, &v6) )
    return 0;
  if ( *(float *)&v7 > (long double)*(float *)&v6 )
    sub_812F2F6(&v7, &v6);
  sub_812F15A((_DWORD *)(a2 + (a4 << 6) + 24), v7, v6);
  *(_BYTE *)(a2 + (a4 << 6) + 60) = 1;
  return 1;
}

//----- (0812D1D2) --------------------------------------------------------
int __cdecl sub_812D1D2(int a1, int a2, char *s, int a4)
{
  int v6; // [esp+20h] [ebp-8h] BYREF
  int v7; // [esp+24h] [ebp-4h] BYREF

  if ( !(unsigned __int8)sub_812B73A(a1, s, &v7, &v6) )
    return 0;
  sub_812F15A((_DWORD *)(a2 + (a4 << 6) + 48), v7, v6);
  *(_BYTE *)(a2 + (a4 << 6) + 60) = 1;
  return 1;
}

//----- (0812D246) --------------------------------------------------------
int __cdecl sub_812D246(int a1, int a2, char *s, int a4)
{
  int v6; // [esp+14h] [ebp-4h] BYREF

  if ( !(unsigned __int8)sub_812B850(a1, s, &v6) )
    return 0;
  *(_DWORD *)(a2 + (a4 << 6) + 56) |= v6;
  *(_BYTE *)(a2 + (a4 << 6) + 60) = 1;
  return 1;
}

//----- (0812D2B4) --------------------------------------------------------
int __cdecl sub_812D2B4(int a1, int a2)
{
  int i; // [esp+Ch] [ebp-Ch]
  int v5; // [esp+10h] [ebp-8h]
  int v6; // [esp+10h] [ebp-8h]

  if ( byte_8168610 )
  {
    if ( sub_812FD7E(a2) )
    {
      for ( i = sub_812F330(a2); i; i = sub_812F318(i) )
      {
        sub_812A5EA(i);
        v5 = sub_812F0DE();
        sub_812A452(a1 + 104, v5);
      }
    }
    else
    {
      if ( !sub_812FDB4(a2) )
      {
        sub_812F0A2("PrimitiveTemplate::ParseMaterials called with an empty list!\n");
        return 0;
      }
      v6 = sub_812F0DE();
      sub_812A452(a1 + 104, v6);
    }
    return 1;
  }
  return 1;
}
// 8168610: using guessed type char byte_8168610;

//----- (0812D392) --------------------------------------------------------
int __cdecl sub_812D392(int a1, int a2)
{
  int i; // [esp+Ch] [ebp-Ch]
  int v5; // [esp+10h] [ebp-8h]
  int v6; // [esp+10h] [ebp-8h]
  char *s1; // [esp+14h] [ebp-4h]

  if ( sub_812FD7E(a2) )
  {
    for ( i = sub_812F330(a2); i; i = sub_812F318(i) )
    {
      s1 = (char *)sub_812A5EA(i);
      v5 = sub_812F0E8(s1);
      if ( !v5 )
        goto LABEL_5;
      sub_812A452(a1 + 104, v5);
    }
    return 1;
  }
  s1 = (char *)sub_812FDB4(a2);
  if ( s1 )
  {
    v6 = sub_812F0E8(s1);
    if ( v6 )
    {
      sub_812A452(a1 + 104, v6);
      return 1;
    }
LABEL_5:
    sub_812F0A2("PrimitiveTemplate::ParseModels, could not register model '%s'\n", s1);
    return 0;
  }
  else
  {
    sub_812F0A2("PrimitiveTemplate::ParseModels called with an empty list!\n");
    return 0;
  }
}

//----- (0812D4A0) --------------------------------------------------------
int __cdecl sub_812D4A0(int a1, int a2)
{
  int i; // [esp+Ch] [ebp-Ch]
  int v5; // [esp+10h] [ebp-8h]
  int v6; // [esp+10h] [ebp-8h]
  int v7; // [esp+14h] [ebp-4h]
  int v8; // [esp+14h] [ebp-4h]

  if ( sub_812FD7E(a2) )
  {
    for ( i = sub_812F330(a2); i; i = sub_812F318(i) )
    {
      v7 = sub_812A5EA(i);
      v5 = sub_8129F6A(v7);
      if ( !v5 )
        goto LABEL_6;
      sub_812A50C(a1 + 112, v5);
    }
    goto LABEL_12;
  }
  v8 = sub_812FDB4(a2);
  if ( v8 )
  {
    v6 = sub_8129F6A(v8);
    if ( v6 )
    {
      sub_812A50C(a1 + 112, v6);
LABEL_12:
      *(_DWORD *)(a1 + 144) |= 0x820u;
      return 1;
    }
LABEL_6:
    sub_812F0A2("FxTemplate: Impact effect file not found.\n");
    return 0;
  }
  else
  {
    sub_812F0A2("PrimitiveTemplate::ParseImpactFxStrings called with an empty list!\n");
    return 0;
  }
}

//----- (0812D5BC) --------------------------------------------------------
int __cdecl sub_812D5BC(int a1, int a2)
{
  int i; // [esp+Ch] [ebp-Ch]
  int v5; // [esp+10h] [ebp-8h]
  int v6; // [esp+10h] [ebp-8h]
  int v7; // [esp+14h] [ebp-4h]
  int v8; // [esp+14h] [ebp-4h]

  if ( sub_812FD7E(a2) )
  {
    for ( i = sub_812F330(a2); i; i = sub_812F318(i) )
    {
      v7 = sub_812A5EA(i);
      v5 = sub_8129F6A(v7);
      if ( !v5 )
        goto LABEL_6;
      sub_812A50C(a1 + 120, v5);
    }
    goto LABEL_12;
  }
  v8 = sub_812FDB4(a2);
  if ( v8 )
  {
    v6 = sub_8129F6A(v8);
    if ( v6 )
    {
      sub_812A50C(a1 + 120, v6);
LABEL_12:
      *(_DWORD *)(a1 + 144) |= 0x200u;
      return 1;
    }
LABEL_6:
    sub_812F0A2("FxTemplate: Death effect file not found.\n");
    return 0;
  }
  else
  {
    sub_812F0A2("PrimitiveTemplate::ParseDeathFxStrings called with an empty list!\n");
    return 0;
  }
}

//----- (0812D6D8) --------------------------------------------------------
int __cdecl sub_812D6D8(int a1, int a2)
{
  int i; // [esp+Ch] [ebp-Ch]
  int v5; // [esp+10h] [ebp-8h]
  int v6; // [esp+10h] [ebp-8h]
  int v7; // [esp+14h] [ebp-4h]
  int v8; // [esp+14h] [ebp-4h]

  if ( sub_812FD7E(a2) )
  {
    for ( i = sub_812F330(a2); i; i = sub_812F318(i) )
    {
      v7 = sub_812A5EA(i);
      v5 = sub_8129F6A(v7);
      if ( !v5 )
        goto LABEL_6;
      sub_812A50C(a1 + 128, v5);
    }
    goto LABEL_12;
  }
  v8 = sub_812FDB4(a2);
  if ( v8 )
  {
    v6 = sub_8129F6A(v8);
    if ( v6 )
    {
      sub_812A50C(a1 + 128, v6);
LABEL_12:
      *(_DWORD *)(a1 + 144) |= 0x100u;
      return 1;
    }
LABEL_6:
    sub_812F0A2("FxTemplate: Emitter effect file not found.\n");
    return 0;
  }
  else
  {
    sub_812F0A2("PrimitiveTemplate::ParseEmitterFxStrings called with an empty list!\n");
    return 0;
  }
}

//----- (0812D7F4) --------------------------------------------------------
int __cdecl sub_812D7F4(int a1, int a2)
{
  int i; // [esp+Ch] [ebp-Ch]
  int v5; // [esp+10h] [ebp-8h]
  int v6; // [esp+10h] [ebp-8h]
  int v7; // [esp+14h] [ebp-4h]
  int v8; // [esp+14h] [ebp-4h]

  if ( sub_812FD7E(a2) )
  {
    for ( i = sub_812F330(a2); i; i = sub_812F318(i) )
    {
      v7 = sub_812A5EA(i);
      v5 = sub_8129F6A(v7);
      if ( !v5 )
        goto LABEL_6;
      sub_812A50C(a1 + 136, v5);
    }
    return 1;
  }
  v8 = sub_812FDB4(a2);
  if ( v8 )
  {
    v6 = sub_8129F6A(v8);
    if ( v6 )
    {
      sub_812A50C(a1 + 136, v6);
      return 1;
    }
LABEL_6:
    sub_812F0A2("FxTemplate: Effect file not found.\n");
    return 0;
  }
  else
  {
    sub_812F0A2("PrimitiveTemplate::ParsePlayFxStrings called with an empty list!\n");
    return 0;
  }
}

//----- (0812D8FC) --------------------------------------------------------
void __cdecl sub_812D8FC(int a1, int a2, int a3)
{
  const char *v3; // eax
  float *ptr; // [esp+24h] [ebp-14h]
  int v5; // [esp+28h] [ebp-10h]
  int v6; // [esp+28h] [ebp-10h]
  int i; // [esp+2Ch] [ebp-Ch]
  int j; // [esp+2Ch] [ebp-Ch]
  int v9; // [esp+30h] [ebp-8h]

  v9 = sub_812F330(a2);
  v5 = 0;
  for ( i = v9; i; i = sub_812F318(i) )
    ++v5;
  ptr = (float *)Hunk_AllocateTempMemoryInternal(16 * v5);
  v6 = 0;
  for ( j = v9; j; j = sub_812F318(j) )
  {
    v3 = (const char *)sub_812A5EA(j);
    sscanf(v3, "%f %f %f %f", &ptr[4 * v6], &ptr[4 * v6 + 1], &ptr[4 * v6 + 2], &ptr[4 * v6 + 3]);
    ++v6;
  }
  *(_DWORD *)(a1 + 12 * a3 + 256) = sub_8121AAC(ptr, 3, v6);
  Hunk_FreeTempMemory(ptr);
}

//----- (0812DA14) --------------------------------------------------------
void __cdecl sub_812DA14(int a1, int a2, int a3)
{
  const char *v3; // eax
  float *ptr; // [esp+14h] [ebp-14h]
  int v5; // [esp+18h] [ebp-10h]
  int v6; // [esp+18h] [ebp-10h]
  int i; // [esp+1Ch] [ebp-Ch]
  int j; // [esp+1Ch] [ebp-Ch]
  int v9; // [esp+20h] [ebp-8h]

  v9 = sub_812F330(a2);
  v5 = 0;
  for ( i = v9; i; i = sub_812F318(i) )
    ++v5;
  ptr = (float *)Hunk_AllocateTempMemoryInternal(8 * v5);
  v6 = 0;
  for ( j = v9; j; j = sub_812F318(j) )
  {
    v3 = (const char *)sub_812A5EA(j);
    sscanf(v3, "%f %f", &ptr[2 * v6], &ptr[2 * v6 + 1]);
    ++v6;
  }
  *(_DWORD *)(a1 + 12 * a3 + 256) = sub_8121AAC(ptr, 1, v6);
  Hunk_FreeTempMemory(ptr);
}

//----- (0812DB0C) --------------------------------------------------------
int __cdecl sub_812DB0C(int a1, char *s, int a3)
{
  int result; // eax
  int v4; // [esp+10h] [ebp-8h] BYREF
  int v5; // [esp+14h] [ebp-4h] BYREF

  result = sub_812B73A(a1, s, &v5, &v4);
  if ( (_BYTE)result )
    return sub_812F15A((_DWORD *)(a1 + 12 * a3 + 260), v5, v4);
  return result;
}

//----- (0812DB62) --------------------------------------------------------
int __cdecl sub_812DB62(int a1, int a2, int a3, unsigned int a4)
{
  char *s; // [esp+1Ch] [ebp-Ch]
  char *s1; // [esp+20h] [ebp-8h]
  int i; // [esp+24h] [ebp-4h]

  for ( i = sub_812F33C(a3); i; i = sub_812F324(i) )
  {
    s1 = (char *)sub_812A5EA(i);
    s = (char *)sub_812FDB4(i);
    if ( !strcasecmp(s1, "curve") )
    {
      if ( a4 > 1 )
        sub_812DA14(a1, i, a4);
      else
        sub_812D8FC(a1, i, a4);
    }
    else if ( !strcasecmp(s1, "scale") )
    {
      sub_812DB0C(a1, s, a4);
    }
    else if ( !strcasecmp(s1, "start") )
    {
      if ( a4 > 1 )
        sub_812D0A8(a1, a2, s, a4);
      else
        sub_812CF7C(a1, a2, s, a4);
    }
    else if ( !strcasecmp(s1, "end") )
    {
      if ( a4 > 1 )
        sub_812D13C(a1, a2, s, a4);
      else
        sub_812D010(a1, a2, s, a4);
    }
    else if ( !strcasecmp(s1, "parm") || !strcasecmp(s1, "parms") )
    {
      sub_812D1D2(a1, a2, s, a4);
    }
    else if ( !strcasecmp(s1, "flags") || !strcasecmp(s1, "flag") )
    {
      sub_812D246(a1, a2, s, a4);
    }
    else
    {
      sub_812F0A2("Unknown key parsing a channel: %s\n", s1);
    }
  }
  return 1;
}

//----- (0812DDDE) --------------------------------------------------------
int __cdecl sub_812DDDE(int a1, char *src)
{
  I_strncpyz((char *)(a1 + 32), src, 32);
  return 1;
}

//----- (0812DE08) --------------------------------------------------------
int __cdecl sub_812DE08(char *dest, void *s, int a3)
{
  char *nptr; // [esp+24h] [ebp-14h]
  char *s1; // [esp+28h] [ebp-10h]
  int v7; // [esp+2Ch] [ebp-Ch]
  int v8; // [esp+30h] [ebp-8h]

  v7 = sub_812F33C(a3);
  s1 = 0;
  sub_812B5B6((int)dest, s);
  while ( v7 )
  {
    s1 = (char *)sub_812A5EA(v7);
    nptr = (char *)sub_812FDB4(v7);
    if ( !strcasecmp(s1, "count") )
    {
      if ( !(unsigned __int8)sub_812BC48((int)dest, nptr) )
        break;
    }
    else if ( !strcasecmp(s1, "shaders") || !strcasecmp(s1, "shader") )
    {
      if ( !(unsigned __int8)sub_812D2B4((int)dest, v7) )
        break;
    }
    else if ( !strcasecmp(s1, "models") || !strcasecmp(s1, "model") )
    {
      if ( !(unsigned __int8)sub_812D392((int)dest, v7) )
        break;
    }
    else if ( !strcasecmp(s1, "impactfx") )
    {
      if ( !(unsigned __int8)sub_812D4A0((int)dest, v7) )
        break;
    }
    else if ( !strcasecmp(s1, "deathfx") )
    {
      if ( !(unsigned __int8)sub_812D5BC((int)dest, v7) )
        break;
    }
    else if ( !strcasecmp(s1, "emitfx") )
    {
      if ( !(unsigned __int8)sub_812D6D8((int)dest, v7) )
        break;
    }
    else if ( !strcasecmp(s1, "playfx") )
    {
      if ( !(unsigned __int8)sub_812D7F4((int)dest, v7) )
        break;
    }
    else if ( !strcasecmp(s1, "life") )
    {
      if ( !(unsigned __int8)sub_812BB1A((int)dest, nptr) )
        break;
    }
    else if ( !strcasecmp(s1, "cullrange") )
    {
      *((float *)dest + 25) = atof(nptr);
    }
    else if ( !strcasecmp(s1, "spawnRange") )
    {
      if ( !(unsigned __int8)sub_812BB76((int)dest, nptr) )
        break;
    }
    else if ( !strcasecmp(s1, "delay") )
    {
      if ( !(unsigned __int8)sub_812BBEC((int)dest, nptr) )
        break;
    }
    else if ( !strcasecmp(s1, "bounce") || !strcasecmp(s1, "intensity") )
    {
      if ( !(unsigned __int8)sub_812BCA4((int)dest, nptr) )
        break;
    }
    else if ( !strcasecmp(s1, "min") )
    {
      if ( !(unsigned __int8)sub_812BA42((int)dest, nptr) )
        break;
    }
    else if ( !strcasecmp(s1, "max") )
    {
      if ( !(unsigned __int8)sub_812BAAE((int)dest, nptr) )
        break;
    }
    else if ( !strcasecmp(s1, "angle") || !strcasecmp(s1, "angles") )
    {
      if ( !(unsigned __int8)sub_812C46E(dest, nptr) )
        break;
    }
    else if ( !strcasecmp(s1, "angleDelta") )
    {
      if ( !(unsigned __int8)sub_812C508(dest, nptr) )
        break;
    }
    else if ( !strcasecmp(s1, "velocity") || !strcasecmp(s1, "vel") )
    {
      if ( !(unsigned __int8)sub_812C5A2((int)dest, nptr) )
        break;
    }
    else if ( !strcasecmp(s1, "acceleration") || !strcasecmp(s1, "accel") )
    {
      if ( !(unsigned __int8)sub_812C9D4((int)dest, nptr) )
        break;
    }
    else if ( !strcasecmp(s1, "gravity") )
    {
      if ( !(unsigned __int8)sub_812CC8A((int)dest, nptr) )
        break;
    }
    else if ( !strcasecmp(s1, "density") )
    {
      if ( !(unsigned __int8)sub_812CCE8((int)dest, nptr) )
        break;
    }
    else if ( !strcasecmp(s1, "variance") )
    {
      if ( !(unsigned __int8)sub_812CD46((int)dest, nptr) )
        break;
    }
    else if ( !strcasecmp(s1, "origin") )
    {
      if ( !(unsigned __int8)sub_812BD9A(dest, nptr) )
        break;
    }
    else if ( !strcasecmp(s1, "origin2") )
    {
      if ( !(unsigned __int8)sub_812BE34(dest, nptr) )
        break;
    }
    else if ( !strcasecmp(s1, "radius") )
    {
      if ( !(unsigned __int8)sub_812BECE((int)dest, nptr) )
        break;
    }
    else if ( !strcasecmp(s1, "height") )
    {
      if ( !(unsigned __int8)sub_812BF2C((int)dest, nptr) )
        break;
    }
    else if ( !strcasecmp(s1, "wind") )
    {
      if ( !(unsigned __int8)sub_812BF8A((int)dest, nptr) )
        break;
    }
    else if ( !strcasecmp(s1, "rotation") )
    {
      if ( !(unsigned __int8)sub_812BFE8((int)dest, nptr) )
        break;
    }
    else if ( I_stricmp(s1, "rotationDelta") )
    {
      if ( !strcasecmp(s1, "flags") || !strcasecmp(s1, "flag") )
      {
        if ( !(unsigned __int8)sub_812C978((int)dest, nptr) )
          break;
      }
      else if ( !strcasecmp(s1, "spawnFlags") || !strcasecmp(s1, "spawnFlag") )
      {
        if ( !(unsigned __int8)sub_812C9A6((int)dest, nptr) )
          break;
      }
      else if ( !strcasecmp(s1, "nonUniformScale") )
      {
        dest[156] = atoi(nptr) != 0;
      }
      else if ( !strcasecmp(s1, "useLength") )
      {
        dest[157] = atoi(nptr) != 0;
      }
      else if ( !strcasecmp(s1, "name") )
      {
        if ( !nptr )
          break;
        I_strncpyz(dest, nptr, 32);
      }
      else if ( !strcasecmp(s1, "shaderImpact") )
      {
        if ( !(unsigned __int8)sub_812DDDE((int)dest, nptr) )
          break;
      }
      else if ( !strcasecmp(s1, "sequenceStartFrameMode") )
      {
        if ( !(unsigned __int8)sub_812CDA4((int)dest, nptr) )
          break;
      }
      else if ( !strcasecmp(s1, "sequenceFixedFrameValue") )
      {
        if ( !sub_812CDE8((int)dest, nptr) )
          break;
      }
      else if ( !strcasecmp(s1, "sequencePlayRateMode") )
      {
        if ( !(unsigned __int8)sub_812CE28((int)dest, nptr) )
          break;
      }
      else if ( !strcasecmp(s1, "sequenceFixedFpsValue") )
      {
        if ( !sub_812CE6C((int)dest, nptr) )
          break;
      }
      else if ( !strcasecmp(s1, "sequenceLoopMode") )
      {
        if ( !(unsigned __int8)sub_812CEB4((int)dest, nptr) )
          break;
      }
      else if ( !strcasecmp(s1, "sequenceLoopTimes") )
      {
        if ( !sub_812CEF8((int)dest, nptr) )
          break;
      }
      else
      {
        if ( strcasecmp(s1, "spawnFrustumCullRadius") )
        {
          sub_812F0A2("Unknown key parsing an effect primitive: %s\n", s1);
          return 0;
        }
        if ( !(unsigned __int8)sub_812CF38((int)dest, nptr) )
          break;
      }
    }
    else if ( !(unsigned __int8)sub_812C354((int)dest, nptr) )
    {
      break;
    }
    v7 = sub_812F324(v7);
    s1 = 0;
  }
  if ( !s1 )
  {
    if ( *((float *)dest + 40) > (long double)*((float *)dest + 43)
      || *((float *)dest + 41) > (long double)*((float *)dest + 44)
      || *((float *)dest + 42) > (long double)*((float *)dest + 45) )
    {
      sub_812F0A2("^1FX bounding box mins / maxs invalid for effect '%s'\n", dest);
      return 0;
    }
    if ( *((float *)dest + 43) - *((float *)dest + 40) > *((float *)dest + 45) - *((float *)dest + 42)
      || *((float *)dest + 44) - *((float *)dest + 41) > *((float *)dest + 45) - *((float *)dest + 42) )
    {
      sub_812F0A2("^1FX bounding box width or depth is larger than height for effect '%s'\n", dest);
      return 0;
    }
    v8 = sub_812A600(a3);
    while ( v8 )
    {
      s1 = (char *)sub_812A5EA(v8);
      if ( !strcasecmp(s1, "rgb") )
      {
        if ( !(unsigned __int8)sub_812DB62((int)dest, (int)s, v8, 0) )
          break;
      }
      else if ( !strcasecmp(s1, "rgb2") || !strcasecmp(s1, "rgbRand") )
      {
        if ( !(unsigned __int8)sub_812DB62((int)dest, (int)s, v8, 1u) )
          break;
      }
      else if ( !strcasecmp(s1, "alpha") )
      {
        if ( !(unsigned __int8)sub_812DB62((int)dest, (int)s, v8, 2u) )
          break;
      }
      else if ( !strcasecmp(s1, "alphaRand") )
      {
        if ( !(unsigned __int8)sub_812DB62((int)dest, (int)s, v8, 3u) )
          break;
      }
      else if ( !strcasecmp(s1, "size") || !strcasecmp(s1, "width") )
      {
        if ( !(unsigned __int8)sub_812DB62((int)dest, (int)s, v8, 4u) )
          break;
      }
      else if ( !strcasecmp(s1, "sizeRand") )
      {
        if ( !(unsigned __int8)sub_812DB62((int)dest, (int)s, v8, 5u) )
          break;
      }
      else if ( !strcasecmp(s1, "size2") || !strcasecmp(s1, "width2") )
      {
        if ( !(unsigned __int8)sub_812DB62((int)dest, (int)s, v8, 6u) )
          break;
      }
      else if ( !strcasecmp(s1, "size2Rand") )
      {
        if ( !(unsigned __int8)sub_812DB62((int)dest, (int)s, v8, 7u) )
          break;
      }
      else if ( !strcasecmp(s1, "length") || !strcasecmp(s1, "height") )
      {
        if ( !(unsigned __int8)sub_812DB62((int)dest, (int)s, v8, 8u) )
          break;
      }
      else if ( !strcasecmp(s1, "lengthRand") )
      {
        if ( !(unsigned __int8)sub_812DB62((int)dest, (int)s, v8, 9u) )
          break;
      }
      else if ( !strcasecmp(s1, "rotationDelta") )
      {
        if ( !(unsigned __int8)sub_812DB62((int)dest, (int)s, v8, 0xAu) )
          break;
      }
      else if ( !strcasecmp(s1, "rotationDeltaRand") )
      {
        if ( !(unsigned __int8)sub_812DB62((int)dest, (int)s, v8, 0xBu) )
          break;
      }
      else if ( !strcasecmp(s1, "velocityX") )
      {
        if ( !(unsigned __int8)sub_812DB62((int)dest, (int)s, v8, 0xCu) )
          break;
      }
      else if ( !strcasecmp(s1, "velocityY") )
      {
        if ( !(unsigned __int8)sub_812DB62((int)dest, (int)s, v8, 0xDu) )
          break;
      }
      else if ( !strcasecmp(s1, "velocityZ") )
      {
        if ( !(unsigned __int8)sub_812DB62((int)dest, (int)s, v8, 0xEu) )
          break;
      }
      else if ( !strcasecmp(s1, "velocityXRand") )
      {
        if ( !(unsigned __int8)sub_812DB62((int)dest, (int)s, v8, 0xFu) )
          break;
      }
      else if ( !strcasecmp(s1, "velocityYRand") )
      {
        if ( !(unsigned __int8)sub_812DB62((int)dest, (int)s, v8, 0x10u) )
          break;
      }
      else if ( !strcasecmp(s1, "velocityZRand") )
      {
        if ( !(unsigned __int8)sub_812DB62((int)dest, (int)s, v8, 0x11u) )
          break;
      }
      else if ( !strcasecmp(s1, "velocity2X") )
      {
        if ( !(unsigned __int8)sub_812DB62((int)dest, (int)s, v8, 0x12u) )
          break;
      }
      else if ( !strcasecmp(s1, "velocity2Y") )
      {
        if ( !(unsigned __int8)sub_812DB62((int)dest, (int)s, v8, 0x13u) )
          break;
      }
      else if ( !strcasecmp(s1, "velocity2Z") )
      {
        if ( !(unsigned __int8)sub_812DB62((int)dest, (int)s, v8, 0x14u) )
          break;
      }
      else if ( !strcasecmp(s1, "velocity2XRand") )
      {
        if ( !(unsigned __int8)sub_812DB62((int)dest, (int)s, v8, 0x15u) )
          break;
      }
      else if ( !strcasecmp(s1, "velocity2YRand") )
      {
        if ( !(unsigned __int8)sub_812DB62((int)dest, (int)s, v8, 0x16u) )
          break;
      }
      else
      {
        if ( strcasecmp(s1, "velocity2ZRand") )
        {
          sub_812F0A2("Unknown group key parsing a particle: %s\n", s1);
          return 0;
        }
        if ( !(unsigned __int8)sub_812DB62((int)dest, (int)s, v8, 0x17u) )
          break;
      }
      v8 = sub_812A5F4(v8);
      s1 = 0;
    }
    if ( !s1 )
    {
      sub_812B68C((int)dest, (int)s);
      return 1;
    }
  }
  sub_812F0A2("^1FX Error while parsing key '%s'\n", s1);
  return 0;
}

//----- (0812F060) --------------------------------------------------------
int __cdecl sub_812F060(char *dest, int a2)
{
  _DWORD *ptr; // [esp+10h] [ebp-8h]
  unsigned __int8 v4; // [esp+17h] [ebp-1h]

  ptr = Hunk_AllocateTempMemoryInternal(0x600u);
  v4 = sub_812DE08(dest, ptr, a2);
  Hunk_FreeTempMemory(ptr);
  return v4;
}

//----- (0812F0A2) --------------------------------------------------------
void sub_812F0A2(char *format, ...)
{
  char s[1036]; // [esp+10h] [ebp-418h] BYREF
  __gnuc_va_list __varargs; // [esp+41Ch] [ebp-Ch]
  va_list va; // [esp+434h] [ebp+Ch] BYREF

  va_start(va, format);
  va_copy(__varargs, va);
  vsprintf(s, format, va);
  Com_Printf(s);
}

//----- (0812F0DE) --------------------------------------------------------
int sub_812F0DE()
{
  return 0;
}

//----- (0812F0E8) --------------------------------------------------------
int __cdecl sub_812F0E8(char *s1)
{
  if ( (unsigned __int8)Com_ValidXModelName(s1) )
    return sub_8122206(s1 + 7);
  else
    return 0;
}

//----- (0812F15A) --------------------------------------------------------
int __cdecl sub_812F15A(_DWORD *a1, int a2, int a3)
{
  int result; // eax

  *a1 = a2;
  result = a3;
  a1[1] = a3;
  return result;
}

//----- (0812F170) --------------------------------------------------------
long double __cdecl sub_812F170(float *a1)
{
  if ( *a1 == a1[1] )
    return *a1;
  else
    return (float)sub_80A8720(*a1, a1[1]);
}

//----- (0812F1B8) --------------------------------------------------------
long double __cdecl sub_812F1B8(float *a1, float a2)
{
  return (a1[1] - *a1) * a2 + *a1;
}

//----- (0812F1D0) --------------------------------------------------------
void __cdecl sub_812F1D0(float a1, float a2)
{
  float v2; // [esp+0h] [ebp-18h]

  v2 = a1 - a2;
  sub_812F2CC(v2, a1, a2);
}

//----- (0812F1F4) --------------------------------------------------------
long double __cdecl sub_812F1F4(float a1, float a2, float a3)
{
  float v4; // [esp+0h] [ebp-18h]
  float v5; // [esp+0h] [ebp-18h]
  float v6; // [esp+8h] [ebp-10h]

  v4 = a1 - a3;
  v6 = sub_812F2CC(v4, a3, a1);
  v5 = a2 - a1;
  return sub_812F2CC(v5, a2, v6);
}

//----- (0812F232) --------------------------------------------------------
int __cdecl sub_812F232(_DWORD *a1, _DWORD *a2)
{
  int result; // eax

  *a2 = *a1;
  a2[1] = a1[1];
  result = a1[2];
  a2[2] = result;
  return result;
}

//----- (0812F262) --------------------------------------------------------
int __cdecl sub_812F262(float *a1, float *a2)
{
  int v3; // [esp+0h] [ebp-4h]

  v3 = 0;
  if ( *a1 == *a2 && a1[1] == a2[1] && a1[2] == a2[2] )
    return 1;
  return v3;
}

//----- (0812F2CC) --------------------------------------------------------
long double __cdecl sub_812F2CC(float a1, float a2, float a3)
{
  if ( a1 < 0.0 )
    return a3;
  return a2;
}

//----- (0812F2F6) --------------------------------------------------------
int __cdecl sub_812F2F6(int *a1, int *a2)
{
  int result; // eax
  int v3; // [esp+0h] [ebp-4h]

  v3 = *a1;
  *a1 = *a2;
  result = v3;
  *a2 = v3;
  return result;
}

//----- (0812F318) --------------------------------------------------------
int __cdecl sub_812F318(int a1)
{
  return *(_DWORD *)(a1 + 4);
}

//----- (0812F324) --------------------------------------------------------
int __cdecl sub_812F324(int a1)
{
  return *(_DWORD *)(a1 + 4);
}

//----- (0812F330) --------------------------------------------------------
int __cdecl sub_812F330(int a1)
{
  return *(_DWORD *)(a1 + 16);
}

//----- (0812F33C) --------------------------------------------------------
int __cdecl sub_812F33C(int a1)
{
  return *(_DWORD *)(a1 + 16);
}

//----- (0812F348) --------------------------------------------------------
void sub_812F348()
{
  ;
}

//----- (0812F34E) --------------------------------------------------------
void sub_812F34E()
{
  int i; // [esp+4h] [ebp-4h]

  for ( i = 0; i <= 0; ++i )
  {
    if ( dword_89A280C[i] )
    {
      sub_812F348();
      return;
    }
  }
}
// 89A280C: using guessed type int dword_89A280C[];

//----- (0812F386) --------------------------------------------------------
int __cdecl sub_812F386(int a1, int a2)
{
  int v2; // eax
  int v5; // [esp+14h] [ebp-4h]

  v2 = sub_806C8C0();
  v5 = sub_8062844(a1, v2);
  if ( v5 )
    return sub_80B8AF6(v5, a2);
  else
    return -1;
}

//----- (0812F3CC) --------------------------------------------------------
void __cdecl sub_812F3CC(int a1, float *a2)
{
  sub_8128858((int *)dword_89A2814, a1, a2);
}

//----- (0812F3F0) --------------------------------------------------------
void __cdecl sub_812F3F0(int a1, float *a2, _DWORD *a3)
{
  sub_8128900((int *)dword_89A2814, a1, a2, a3);
}

//----- (0812F41A) --------------------------------------------------------
void __cdecl sub_812F41A(int a1, float *a2, _DWORD *a3, _DWORD *a4)
{
  sub_8128962((int *)dword_89A2814, a1, a2, a3, a4);
}

//----- (0812F44C) --------------------------------------------------------
void __cdecl sub_812F44C(int a1, float *a2, _DWORD *a3, int *a4)
{
  sub_8128ACC((int *)dword_89A2814, a1, a2, a3, a4);
}

//----- (0812F47E) --------------------------------------------------------
int __cdecl sub_812F47E(char a1)
{
  return sub_8131338(a1);
}

//----- (0812F498) --------------------------------------------------------
int FX_FreeSystem()
{
  return FX_Free(1);
}

//----- (0812F4AC) --------------------------------------------------------
int FX_FreeActive()
{
  return FX_Free(0);
}

//----- (0812F4C0) --------------------------------------------------------
void __cdecl FX_AdjustCamera(int a1, float a2)
{
  sub_812AAD2(off_8168620, a1, a2);
  dword_89A2828 = 1;
}
// 89A2828: using guessed type int dword_89A2828;

//----- (0812F4EE) --------------------------------------------------------
int __cdecl FX_AdjustTime(int a1)
{
  int result; // eax

  dword_89A2828 = 0;
  sub_812A6B4((_DWORD *)off_8168620, a1);
  dword_89B63AC = dword_89B63A0;
  result = dword_89B63A4;
  dword_89B63B0 = dword_89B63A4;
  return result;
}
// 89A2828: using guessed type int dword_89A2828;
// 89B63A0: using guessed type int dword_89B63A0;
// 89B63A4: using guessed type int dword_89B63A4;
// 89B63AC: using guessed type int dword_89B63AC;
// 89B63B0: using guessed type int dword_89B63B0;

//----- (0812F528) --------------------------------------------------------
int __cdecl FX_WarpTime(int a1)
{
  return sub_812A776((int *)off_8168620, a1);
}

//----- (0812F544) --------------------------------------------------------
void __cdecl sub_812F544(int a1)
{
  sub_8128E8A((int)dword_89A2814, a1);
}

//----- (0812F560) --------------------------------------------------------
char *__cdecl sub_812F560(char **a1, char a2, char a3)
{
  char *v3; // edx
  char v5; // [esp+1Ah] [ebp-Eh]
  char v6; // [esp+1Bh] [ebp-Dh]
  char v7; // [esp+1Bh] [ebp-Dh]
  char v8; // [esp+1Bh] [ebp-Dh]
  signed int n; // [esp+1Ch] [ebp-Ch]
  char *v10; // [esp+20h] [ebp-8h]

  v10 = *a1;
  n = 0;
  byte_89A2840[0] = 0;
  if ( v10 )
  {
    while ( 1 )
    {
      while ( 1 )
      {
        v5 = 0;
        while ( 1 )
        {
          v6 = *v10;
          if ( *v10 > 32 )
            break;
          if ( !v6 )
          {
            *a1 = 0;
            return byte_89A2840;
          }
          if ( v6 == 10 )
            v5 = 1;
          ++v10;
        }
        if ( v5 && !a2 )
        {
          *a1 = v10;
          return byte_89A2840;
        }
        v7 = *v10;
        if ( *v10 != 47 || v10[1] != 47 )
          break;
        for ( v10 += 2; *v10 && *v10 != 10; ++v10 )
          ;
      }
      if ( v7 != 47 || v10[1] != 42 )
        break;
      for ( v10 += 2; *v10 && (*v10 != 42 || v10[1] != 47); ++v10 )
        ;
      if ( *v10 )
        v10 += 2;
    }
    if ( v7 != 34 || a3 )
    {
      if ( a3 )
      {
        while ( v7 != 10 && v7 != 13 && (v7 != 47 || v10[1] != 47 && v10[1] != 42) )
        {
          if ( n <= 1023 )
            byte_89A2840[n++] = v7;
          v7 = *++v10;
        }
        while ( n && *(char *)(n + 144320575) <= 31 )
          --n;
      }
      else
      {
        while ( v7 > 32 )
        {
          if ( n <= 1023 )
            byte_89A2840[n++] = v7;
          v7 = *++v10;
        }
      }
    }
    else
    {
      ++v10;
      while ( 1 )
      {
        v3 = v10++;
        v8 = *v3;
        if ( *v3 == 34 || !v8 )
          break;
        if ( n <= 1023 )
          byte_89A2840[n++] = v8;
      }
    }
    if ( byte_89A2840[0] == 34 )
    {
      memmove(byte_89A2840, &unk_89A2841, --n);
      if ( n )
      {
        if ( *(_BYTE *)(n + 144320575) == 34 )
          --n;
      }
    }
    if ( n > 1023 )
      n = 0;
    *(_BYTE *)(n + 144320576) = 0;
    *a1 = v10;
  }
  return byte_89A2840;
}

//----- (0812F7FC) --------------------------------------------------------
void *__cdecl sub_812F7FC(_DWORD *a1, int a2)
{
  void *result; // eax

  a1[1] = 0;
  a1[2] = a2;
  a1[3] = 0;
  result = Z_MallocInternal(a1[2]);
  *a1 = result;
  return result;
}

//----- (0812F83A) --------------------------------------------------------
void *__cdecl sub_812F83A(_DWORD *a1, int a2)
{
  void *result; // eax

  a1[1] = 0;
  a1[2] = a2;
  a1[3] = 0;
  result = Z_MallocInternal(a1[2]);
  *a1 = result;
  return result;
}

//----- (0812F878) --------------------------------------------------------
void __cdecl sub_812F878(void **a1)
{
  Z_FreeInternal(*a1);
}

//----- (0812F88E) --------------------------------------------------------
void __cdecl sub_812F88E(void **a1)
{
  Z_FreeInternal(*a1);
}

//----- (0812F8A4) --------------------------------------------------------
size_t __cdecl sub_812F8A4(_DWORD *a1, char *s, unsigned __int8 a3, int *a4)
{
  _DWORD *ptr; // [esp+20h] [ebp-18h]
  size_t v6; // [esp+24h] [ebp-14h]
  size_t v7; // [esp+28h] [ebp-10h]

  v7 = strlen(s);
  if ( a3 )
    v6 = v7 + 1;
  else
    v6 = v7;
  if ( (signed int)(a1[3] + v6 + 1) <= a1[2] )
  {
    strcpy((char *)(*a1 + a1[3]), s);
    a1[3] += v6;
    *(_BYTE *)(*a1 + a1[3]) = 0;
    return *a1 + a1[3] - v6;
  }
  else if ( a4 )
  {
    ptr = sub_8130EDA(0x10u);
    sub_812F83A(ptr, a1[2]);
    sub_8130ECC(*a4, (int)ptr);
    *a4 = sub_8130EC0(*a4);
    return sub_812F8A4(*a4, s, a3, 0);
  }
  else
  {
    return 0;
  }
}

//----- (0812F9F8) --------------------------------------------------------
void __cdecl sub_812F9F8(void **a1)
{
  int v1; // [esp+14h] [ebp-4h]

  while ( a1 )
  {
    v1 = sub_8130EC0((int)a1);
    sub_812F88E(a1);
    sub_8130EEE(a1);
    a1 = (void **)v1;
  }
}
// 812FA1F: conditional instruction was optimized away because %arg_0.4!=0

//----- (0812FA42) --------------------------------------------------------
_DWORD *__cdecl sub_812FA42(_DWORD *a1, int a2)
{
  _DWORD *result; // eax

  *a1 = a2;
  a1[1] = 0;
  a1[2] = 0;
  result = a1;
  a1[3] = 0;
  return result;
}

//----- (0812FA6E) --------------------------------------------------------
_DWORD *__cdecl sub_812FA6E(_DWORD *a1, int a2)
{
  _DWORD *result; // eax

  *a1 = a2;
  a1[1] = 0;
  a1[2] = 0;
  result = a1;
  a1[3] = 0;
  return result;
}

//----- (0812FA9A) --------------------------------------------------------
int __cdecl sub_812FA9A(int a1, int *a2, char *s)
{
  if ( !strchr(s, 32) && *s )
  {
    sub_812F8A4((_DWORD *)*a2, s, 0, a2);
  }
  else
  {
    sub_812F8A4((_DWORD *)*a2, (char *)asc_8159580, 0, a2);
    sub_812F8A4((_DWORD *)*a2, s, 0, a2);
    sub_812F8A4((_DWORD *)*a2, (char *)asc_8159580, 0, a2);
  }
  return 1;
}

//----- (0812FB56) --------------------------------------------------------
_DWORD *__cdecl sub_812FB56(_DWORD *a1, int a2, char *s)
{
  _DWORD *result; // eax

  sub_812FA42(a1, a2);
  result = a1;
  a1[4] = 0;
  if ( s )
    return (_DWORD *)sub_812FDE2((int)a1, s, 0);
  return result;
}

//----- (0812FB9A) --------------------------------------------------------
_DWORD *__cdecl sub_812FB9A(_DWORD *a1, int a2, char *s)
{
  _DWORD *result; // eax

  sub_812FA42(a1, a2);
  result = a1;
  a1[4] = 0;
  if ( s )
    return (_DWORD *)sub_812FDE2((int)a1, s, 0);
  return result;
}

//----- (0812FBDE) --------------------------------------------------------
int __cdecl sub_812FBDE(int a1)
{
  int result; // eax
  int v2; // [esp+4h] [ebp-4h]

  while ( 1 )
  {
    result = a1;
    if ( !*(_DWORD *)(a1 + 16) )
      break;
    v2 = sub_812F318(*(_DWORD *)(a1 + 16));
    sub_8130F4C(*(void **)(a1 + 16));
    *(_DWORD *)(a1 + 16) = v2;
  }
  return result;
}

//----- (0812FC1C) --------------------------------------------------------
int __cdecl sub_812FC1C(int a1)
{
  int result; // eax
  int v2; // [esp+4h] [ebp-4h]

  while ( 1 )
  {
    result = a1;
    if ( !*(_DWORD *)(a1 + 16) )
      break;
    v2 = sub_812F318(*(_DWORD *)(a1 + 16));
    sub_8130F4C(*(void **)(a1 + 16));
    *(_DWORD *)(a1 + 16) = v2;
  }
  return result;
}

//----- (0812FC5A) --------------------------------------------------------
_DWORD *__cdecl sub_812FC5A(int a1, int *a2)
{
  char *v2; // eax
  _DWORD *ptr; // [esp+28h] [ebp-10h]
  char *s; // [esp+2Ch] [ebp-Ch]
  char *sa; // [esp+2Ch] [ebp-Ch]
  int i; // [esp+30h] [ebp-8h]

  if ( a2 )
    s = (char *)sub_812F8A4((_DWORD *)*a2, *(char **)a1, 1u, a2);
  else
    s = *(char **)a1;
  ptr = sub_8130F38(0x14u);
  sub_812FB9A(ptr, (int)s, 0);
  for ( i = *(_DWORD *)(a1 + 16); i; i = sub_812F318(i) )
  {
    if ( a2 )
    {
      v2 = (char *)sub_812A5EA(i);
      sa = (char *)sub_812F8A4((_DWORD *)*a2, v2, 1u, a2);
    }
    else
    {
      sa = (char *)sub_812A5EA(i);
    }
    sub_812FDE2((int)ptr, sa, 0);
  }
  return ptr;
}

//----- (0812FD7E) --------------------------------------------------------
_BOOL4 __cdecl sub_812FD7E(int a1)
{
  return *(_DWORD *)(a1 + 16) && sub_812F318(*(_DWORD *)(a1 + 16));
}

//----- (0812FDB4) --------------------------------------------------------
int __cdecl sub_812FDB4(int a1)
{
  if ( *(_DWORD *)(a1 + 16) )
    return sub_812A5EA(*(_DWORD *)(a1 + 16));
  else
    return 0;
}

//----- (0812FDE2) --------------------------------------------------------
int __cdecl sub_812FDE2(int a1, char *s, int *a3)
{
  _DWORD *v3; // ebx
  _DWORD *v5; // ebx
  int v6; // eax
  int v7; // eax
  int v8; // eax

  if ( a3 )
    s = (char *)sub_812F8A4((_DWORD *)*a3, s, 1u, a3);
  if ( *(_DWORD *)(a1 + 16) )
  {
    v5 = sub_8130F38(0x10u);
    sub_812FA6E(v5, (int)s);
    v6 = sub_8130F10(*(_DWORD *)(a1 + 16));
    sub_8130F02(v6, (int)v5);
    v7 = sub_8130F10(*(_DWORD *)(a1 + 16));
    v8 = sub_812F318(v7);
    return sub_8130F1C(*(_DWORD *)(a1 + 16), v8);
  }
  else
  {
    v3 = sub_8130F38(0x10u);
    sub_812FA6E(v3, (int)s);
    *(_DWORD *)(a1 + 16) = v3;
    return sub_8130F1C(*(_DWORD *)(a1 + 16), *(_DWORD *)(a1 + 16));
  }
}

//----- (0812FEC2) --------------------------------------------------------
int __cdecl sub_812FEC2(int a1, char **a2, int *a3)
{
  char *s; // [esp+20h] [ebp-8h]
  char *s1; // [esp+24h] [ebp-4h]

  while ( 1 )
  {
    s1 = sub_812F560(a2, 1, 1);
    if ( !*s1 )
      return 0;
    if ( !strcasecmp(s1, &asc_8159580[2]) )
      break;
    s = (char *)sub_812F8A4((_DWORD *)*a3, s1, 1u, a3);
    sub_812FDE2(a1, s, 0);
  }
  return 1;
}

//----- (0812FF62) --------------------------------------------------------
int __cdecl sub_812FF62(int a1, int *a2, int a3)
{
  char *v3; // eax
  char *v4; // eax
  int k; // [esp+20h] [ebp-8h]
  int i; // [esp+24h] [ebp-4h]
  int j; // [esp+24h] [ebp-4h]
  int m; // [esp+24h] [ebp-4h]
  int n; // [esp+24h] [ebp-4h]

  if ( *(_DWORD *)(a1 + 16) )
  {
    for ( i = 0; i < a3; ++i )
      sub_812F8A4((_DWORD *)*a2, (char *)&asc_8159580[4], 0, a2);
    sub_812FA9A(a1, a2, *(char **)a1);
    if ( sub_812F318(*(_DWORD *)(a1 + 16)) )
    {
      sub_812F8A4((_DWORD *)*a2, "\r\n", 0, a2);
      for ( j = 0; j < a3; ++j )
        sub_812F8A4((_DWORD *)*a2, (char *)&asc_8159580[4], 0, a2);
      sub_812F8A4((_DWORD *)*a2, "[\r\n", 0, a2);
      for ( k = *(_DWORD *)(a1 + 16); k; k = sub_812F318(k) )
      {
        for ( m = 0; m < a3 + 1; ++m )
          sub_812F8A4((_DWORD *)*a2, (char *)&asc_8159580[4], 0, a2);
        v4 = (char *)sub_812A5EA(k);
        sub_812FA9A(*(_DWORD *)(a1 + 16), a2, v4);
        sub_812F8A4((_DWORD *)*a2, "\r\n", 0, a2);
      }
      for ( n = 0; n < a3; ++n )
        sub_812F8A4((_DWORD *)*a2, (char *)&asc_8159580[4], 0, a2);
      sub_812F8A4((_DWORD *)*a2, "]\r\n", 0, a2);
    }
    else
    {
      sub_812F8A4((_DWORD *)*a2, "\t\t", 0, a2);
      v3 = (char *)sub_812A5EA(*(_DWORD *)(a1 + 16));
      sub_812FA9A(*(_DWORD *)(a1 + 16), a2, v3);
      sub_812F8A4((_DWORD *)*a2, "\r\n", 0, a2);
    }
  }
  return 1;
}

//----- (0813025C) --------------------------------------------------------
int __cdecl sub_813025C(int a1, int a2, int a3)
{
  int result; // eax

  sub_812FA42((_DWORD *)a1, a2);
  *(_DWORD *)(a1 + 16) = 0;
  *(_DWORD *)(a1 + 20) = 0;
  *(_DWORD *)(a1 + 24) = 0;
  *(_DWORD *)(a1 + 28) = 0;
  *(_DWORD *)(a1 + 32) = 0;
  *(_DWORD *)(a1 + 36) = 0;
  *(_DWORD *)(a1 + 40) = a3;
  result = a1;
  *(_BYTE *)(a1 + 44) = 0;
  return result;
}

//----- (081302C2) --------------------------------------------------------
int __cdecl sub_81302C2(int a1)
{
  return sub_8130352(a1);
}

//----- (081302D6) --------------------------------------------------------
int __cdecl sub_81302D6(int a1)
{
  return sub_8130352(a1);
}
// 8130352: using guessed type _DWORD __cdecl sub_8130352(_DWORD);

//----- (08130352) --------------------------------------------------------
int __cdecl sub_8130352(int a1)
{
  int result; // eax
  void *v2; // [esp+Ch] [ebp-Ch]
  void *ptr; // [esp+10h] [ebp-8h]

  while ( *(_DWORD *)(a1 + 16) )
  {
    *(_DWORD *)(a1 + 24) = sub_812F324(*(_DWORD *)(a1 + 16));
    ptr = *(void **)(a1 + 16);
    if ( ptr )
    {
      sub_812FC1C((int)ptr);
      sub_8130F4C(ptr);
    }
    *(_DWORD *)(a1 + 16) = *(_DWORD *)(a1 + 24);
  }
  while ( *(_DWORD *)(a1 + 28) )
  {
    *(_DWORD *)(a1 + 36) = sub_812A5F4(*(_DWORD *)(a1 + 28));
    v2 = *(void **)(a1 + 28);
    if ( v2 )
    {
      sub_81302D6((int)v2);
      sub_8130F4C(v2);
    }
    *(_DWORD *)(a1 + 28) = *(_DWORD *)(a1 + 36);
  }
  *(_DWORD *)(a1 + 24) = 0;
  *(_DWORD *)(a1 + 20) = 0;
  *(_DWORD *)(a1 + 16) = 0;
  *(_DWORD *)(a1 + 36) = 0;
  *(_DWORD *)(a1 + 32) = 0;
  *(_DWORD *)(a1 + 28) = 0;
  *(_DWORD *)(a1 + 40) = 0;
  result = a1;
  *(_BYTE *)(a1 + 44) = 0;
  return result;
}

//----- (08130452) --------------------------------------------------------
int *__cdecl sub_8130452(int a1, int *a2)
{
  int *v2; // ebx
  char *v4; // [esp+1Ch] [ebp-1Ch]
  int j; // [esp+20h] [ebp-18h]
  _DWORD *v6; // [esp+24h] [ebp-14h]
  int v7; // [esp+28h] [ebp-10h]
  int i; // [esp+2Ch] [ebp-Ch]

  if ( a2 )
    v4 = (char *)sub_812F8A4((_DWORD *)*a2, *(char **)a1, 1u, a2);
  else
    v4 = *(char **)a1;
  v2 = (int *)sub_8130F38(0x30u);
  sub_813025C((int)v2, (int)v4, 0);
  for ( i = *(_DWORD *)(a1 + 28); i; i = sub_812A5F4(i) )
  {
    v7 = sub_8130452(i, a2);
    sub_81307D4(v2, v7);
  }
  for ( j = *(_DWORD *)(a1 + 16); j; j = sub_812F324(j) )
  {
    v6 = sub_812FC5A(j, a2);
    sub_8130726(v2, (int)v6);
  }
  return v2;
}

//----- (0813055A) --------------------------------------------------------
int __cdecl sub_813055A(int a1, int a2, int *a3, int *a4, int *a5)
{
  const char *v5; // ebx
  const char *v6; // eax
  int result; // eax
  int v8; // [esp+Ch] [ebp-Ch]
  int v9; // [esp+10h] [ebp-8h]

  if ( *a3 )
  {
    sub_8130F02(*a5, a2);
    v9 = *a4;
    v8 = 0;
    while ( v9 )
    {
      v5 = (const char *)sub_812A5EA(v9);
      v6 = (const char *)sub_812A5EA(a2);
      if ( strcasecmp(v6, v5) < 0 )
        break;
      v8 = v9;
      v9 = sub_8130F10(v9);
    }
    if ( v9 )
    {
      sub_8130F2A(v9, a2);
      sub_8130F1C(a2, v9);
    }
    if ( v8 )
    {
      sub_8130F1C(v8, a2);
      sub_8130F2A(a2, v8);
    }
    else
    {
      *a4 = a2;
    }
  }
  else
  {
    *a4 = a2;
    *a3 = a2;
  }
  result = a2;
  *a5 = a2;
  return result;
}

//----- (08130652) --------------------------------------------------------
_DWORD *__cdecl sub_8130652(int *a1, char *s, char *a3, int *a4)
{
  _DWORD *ptr; // [esp+20h] [ebp-8h]

  if ( a4 )
  {
    s = (char *)sub_812F8A4((_DWORD *)*a4, s, 1u, a4);
    if ( a3 )
      a3 = (char *)sub_812F8A4((_DWORD *)*a4, a3, 1u, a4);
  }
  ptr = sub_8130F38(0x14u);
  sub_812FB9A(ptr, (int)s, a3);
  sub_8130726(a1, (int)ptr);
  return ptr;
}

//----- (08130726) --------------------------------------------------------
int __cdecl sub_8130726(int *a1, int a2)
{
  return sub_813055A((int)a1, a2, a1 + 4, a1 + 5, a1 + 6);
}

//----- (0813075E) --------------------------------------------------------
void *__cdecl sub_813075E(int *a1, char *s, int *a3)
{
  void *v3; // ebx

  if ( a3 )
    s = (char *)sub_812F8A4((_DWORD *)*a3, s, 1u, a3);
  v3 = sub_8130F38(0x30u);
  sub_813025C((int)v3, (int)s, 0);
  sub_81307D4(a1, (int)v3);
  return v3;
}

//----- (081307D4) --------------------------------------------------------
int __cdecl sub_81307D4(int *a1, int a2)
{
  return sub_813055A((int)a1, a2, a1 + 7, a1 + 8, a1 + 9);
}

//----- (0813080C) --------------------------------------------------------
int __cdecl sub_813080C(int a1, char *s1)
{
  const char *v2; // eax
  int i; // [esp+14h] [ebp-4h]

  for ( i = *(_DWORD *)(a1 + 28); i; i = sub_812A5F4(i) )
  {
    v2 = (const char *)sub_812A5EA(i);
    if ( !strcasecmp(s1, v2) )
      return i;
  }
  return 0;
}

//----- (08130866) --------------------------------------------------------
_BOOL4 __cdecl sub_8130866(int a1, char **a2, int *a3)
{
  _DWORD *v5; // [esp+18h] [ebp-420h]
  void *v6; // [esp+1Ch] [ebp-41Ch]
  char dest[1036]; // [esp+20h] [ebp-418h] BYREF
  char *s1; // [esp+42Ch] [ebp-Ch]

  while ( 1 )
  {
    s1 = sub_812F560(a2, 1, 0);
    if ( !*s1 )
      break;
    if ( !strcasecmp(s1, asc_8159594) )
      return 1;
    I_strncpyz(dest, s1, 1024);
    s1 = sub_812F560(a2, 1, 1);
    if ( !strcasecmp(s1, &asc_8159594[2]) )
    {
      v6 = sub_813075E((int *)a1, dest, a3);
      sub_8130F60((int)v6, *(_BYTE *)(a1 + 44));
      if ( !(unsigned __int8)sub_8130866(v6, a2, a3) )
        return 0;
    }
    else if ( !strcasecmp(s1, &asc_8159594[4]) )
    {
      v5 = sub_8130652((int *)a1, dest, 0, a3);
      if ( !(unsigned __int8)sub_812FEC2((int)v5, a2, a3) )
        return 0;
    }
    else
    {
      sub_8130652((int *)a1, dest, s1, a3);
    }
  }
  return !*(_DWORD *)(a1 + 40);
}

//----- (08130A3A) --------------------------------------------------------
int __cdecl sub_8130A3A(int a1, int *a2, int a3)
{
  int v4; // [esp+1Ch] [ebp-Ch]
  int v5; // [esp+20h] [ebp-8h]
  int i; // [esp+24h] [ebp-4h]
  int j; // [esp+24h] [ebp-4h]
  int k; // [esp+24h] [ebp-4h]

  v5 = *(_DWORD *)(a1 + 16);
  v4 = *(_DWORD *)(a1 + 28);
  if ( a3 >= 0 )
  {
    for ( i = 0; i < a3; ++i )
      sub_812F8A4((_DWORD *)*a2, (char *)&asc_8159580[4], 0, a2);
    sub_812FA9A(a1, a2, *(char **)a1);
    sub_812F8A4((_DWORD *)*a2, "\r\n", 0, a2);
    for ( j = 0; j < a3; ++j )
      sub_812F8A4((_DWORD *)*a2, (char *)&asc_8159580[4], 0, a2);
    sub_812F8A4((_DWORD *)*a2, "{\r\n", 0, a2);
  }
  while ( v5 )
  {
    sub_812FF62(v5, a2, a3 + 1);
    v5 = sub_812F324(v5);
  }
  while ( v4 )
  {
    sub_8130A3A(v4, a2, a3 + 1);
    v4 = sub_812A5F4(v4);
  }
  if ( a3 >= 0 )
  {
    for ( k = 0; k < a3; ++k )
      sub_812F8A4((_DWORD *)*a2, (char *)&asc_8159580[4], 0, a2);
    sub_812F8A4((_DWORD *)*a2, "}\r\n", 0, a2);
  }
  return 1;
}

//----- (08130C0A) --------------------------------------------------------
int __cdecl sub_8130C0A(int a1, char *s2)
{
  const char *v2; // eax
  int i; // [esp+14h] [ebp-4h]

  for ( i = *(_DWORD *)(a1 + 16); i; i = sub_812F324(i) )
  {
    v2 = (const char *)sub_812A5EA(i);
    if ( !strcasecmp(v2, s2) )
      return i;
  }
  return 0;
}

//----- (08130C66) --------------------------------------------------------
int __cdecl sub_8130C66(int a1, char *s2, int a3)
{
  int v5; // [esp+14h] [ebp-4h]

  v5 = sub_8130C0A(a1, s2);
  if ( v5 )
    return sub_812FDB4(v5);
  else
    return a3;
}

//----- (08130CD6) --------------------------------------------------------
int __cdecl sub_8130CD6(int a1)
{
  int result; // eax

  sub_813025C(a1, (int)"Top Level", 0);
  *(_DWORD *)(a1 + 48) = 0;
  result = a1;
  *(_BYTE *)(a1 + 52) = 0;
  return result;
}

//----- (08130D0A) --------------------------------------------------------
int __cdecl sub_8130D0A(int a1)
{
  sub_8130E6E(a1);
  return sub_81302D6(a1);
}

//----- (08130D4E) --------------------------------------------------------
int __cdecl sub_8130D4E(int a1)
{
  sub_8130E6E(a1);
  return sub_81302D6(a1);
}

//----- (08130D92) --------------------------------------------------------
_BOOL4 __cdecl sub_8130D92(int a1, char **a2, char a3, unsigned __int8 a4)
{
  _DWORD *ptr; // [esp+28h] [ebp-10h]
  int v6; // [esp+30h] [ebp-8h] BYREF
  unsigned __int8 v7; // [esp+36h] [ebp-2h]
  char v8; // [esp+37h] [ebp-1h]

  v8 = a3;
  v7 = a4;
  if ( a3 )
    sub_8130E6E(a1);
  if ( !*(_DWORD *)(a1 + 48) )
  {
    ptr = sub_8130EDA(0x10u);
    sub_812F83A(ptr, 10240);
    *(_DWORD *)(a1 + 48) = ptr;
  }
  sub_8130F78(a1, v7);
  sub_8130F60(a1, v7);
  v6 = *(_DWORD *)(a1 + 48);
  return sub_8130866(a1, a2, &v6);
}
// 8130D92: using guessed type int var_8;

//----- (08130E6E) --------------------------------------------------------
int __cdecl sub_8130E6E(int a1)
{
  int result; // eax

  sub_8130352(a1);
  sub_812F9F8(*(void ***)(a1 + 48));
  result = a1;
  *(_DWORD *)(a1 + 48) = 0;
  return result;
}

//----- (08130E9A) --------------------------------------------------------
int sub_8130E9A(int a1, ...)
{
  va_list va; // [esp+24h] [ebp+Ch] BYREF

  va_start(va, a1);
  return (unsigned __int8)sub_8130A3A(a1, (int *)va, -1);
}

//----- (08130EC0) --------------------------------------------------------
int __cdecl sub_8130EC0(int a1)
{
  return *(_DWORD *)(a1 + 4);
}

//----- (08130ECC) --------------------------------------------------------
int __cdecl sub_8130ECC(int a1, int a2)
{
  int result; // eax

  result = a2;
  *(_DWORD *)(a1 + 4) = a2;
  return result;
}

//----- (08130EDA) --------------------------------------------------------
void *__cdecl sub_8130EDA(size_t size)
{
  return Z_MallocInternal(size);
}

//----- (08130EEE) --------------------------------------------------------
void __cdecl sub_8130EEE(void *ptr)
{
  Z_FreeInternal(ptr);
}

//----- (08130F02) --------------------------------------------------------
int __cdecl sub_8130F02(int a1, int a2)
{
  int result; // eax

  result = a2;
  *(_DWORD *)(a1 + 4) = a2;
  return result;
}

//----- (08130F10) --------------------------------------------------------
int __cdecl sub_8130F10(int a1)
{
  return *(_DWORD *)(a1 + 8);
}

//----- (08130F1C) --------------------------------------------------------
int __cdecl sub_8130F1C(int a1, int a2)
{
  int result; // eax

  result = a2;
  *(_DWORD *)(a1 + 8) = a2;
  return result;
}

//----- (08130F2A) --------------------------------------------------------
int __cdecl sub_8130F2A(int a1, int a2)
{
  int result; // eax

  result = a2;
  *(_DWORD *)(a1 + 12) = a2;
  return result;
}

//----- (08130F38) --------------------------------------------------------
void *__cdecl sub_8130F38(size_t size)
{
  return Z_MallocInternal(size);
}

//----- (08130F4C) --------------------------------------------------------
void __cdecl sub_8130F4C(void *ptr)
{
  Z_FreeInternal(ptr);
}

//----- (08130F60) --------------------------------------------------------
int __cdecl sub_8130F60(int a1, unsigned __int8 a2)
{
  int result; // eax

  result = a2;
  *(_BYTE *)(a1 + 44) = a2;
  return result;
}

//----- (08130F78) --------------------------------------------------------
int __cdecl sub_8130F78(int a1, unsigned __int8 a2)
{
  int result; // eax

  result = a2;
  *(_BYTE *)(a1 + 52) = a2;
  return result;
}

//----- (08130F90) --------------------------------------------------------
size_t __cdecl sub_8130F90(float *a1)
{
  float v3; // [esp+10h] [ebp-8h]
  signed int i; // [esp+14h] [ebp-4h]

  for ( i = 0; i < (int)dword_89A9D80; ++i )
  {
    v3 = sub_80A1DB2(a1, (float *)off_8168614 + 4 * i);
    if ( v3 < 131072.0 )
    {
      ++*((_DWORD *)off_8168614 + 4 * i + 3);
      return i;
    }
  }
  sub_8134DC8(a1, (_DWORD *)off_8168614 + 4 * dword_89A9D80);
  *((_DWORD *)off_8168614 + 4 * dword_89A9D80++ + 3) = 1;
  return dword_89A9D80 - 1;
}
// 8168614: using guessed type void *off_8168614;

//----- (08131042) --------------------------------------------------------
void *__cdecl sub_8131042(void *a1)
{
  void *result; // eax
  int v2; // esi
  char *v3; // ebx
  size_t v4; // ecx
  char *v5; // edx
  int i; // [esp+0h] [ebp-Ch]
  int j; // [esp+0h] [ebp-Ch]

  --*((_DWORD *)off_8168614 + 4 * (_DWORD)a1 + 3);
  result = off_8168614;
  if ( *((int *)off_8168614 + 4 * (_DWORD)a1 + 3) <= 0 )
  {
    --dword_89A9D80;
    result = a1;
    if ( a1 != (void *)dword_89A9D80 )
    {
      v2 = 16 * (_DWORD)a1;
      v3 = (char *)off_8168614;
      v4 = 16 * dword_89A9D80;
      v5 = (char *)off_8168614;
      *(_DWORD *)((char *)off_8168614 + v2) = *((_DWORD *)off_8168614 + 4 * dword_89A9D80);
      *(_DWORD *)&v3[v2 + 4] = *(_DWORD *)&v5[v4 + 4];
      *(_DWORD *)&v3[v2 + 8] = *(_DWORD *)&v5[v4 + 8];
      *(_DWORD *)&v3[v2 + 12] = *(_DWORD *)&v5[v4 + 12];
      for ( i = 0; i < dword_89B63A0; ++i )
      {
        if ( *(_DWORD *)(*((_DWORD *)off_8168618 + i) + 172) == dword_89A9D80 )
          *(_DWORD *)(*((_DWORD *)off_8168618 + i) + 172) = a1;
      }
      for ( j = 0; ; ++j )
      {
        result = (void *)j;
        if ( j >= dword_89B63A4 )
          break;
        if ( *(_DWORD *)(*((_DWORD *)off_816861C + j) + 172) == dword_89A9D80 )
          *(_DWORD *)(*((_DWORD *)off_816861C + j) + 172) = a1;
      }
    }
  }
  return result;
}
// 8168614: using guessed type void *off_8168614;
// 8168618: using guessed type void *off_8168618;
// 816861C: using guessed type void *off_816861C;
// 89B63A0: using guessed type int dword_89B63A0;
// 89B63A4: using guessed type int dword_89B63A4;

//----- (08131180) --------------------------------------------------------
int sub_8131180()
{
  int result; // eax
  int i; // [esp+4h] [ebp-4h]
  int j; // [esp+4h] [ebp-4h]

  for ( i = 0; i < dword_89B63A0; ++i )
  {
    if ( *((_DWORD *)off_8168618 + i) )
      (*(void (__cdecl **)(_DWORD))(**((_DWORD **)off_8168618 + i) + 4))(*((_DWORD *)off_8168618 + i));
  }
  for ( j = 0; ; ++j )
  {
    result = j;
    if ( j >= dword_89B63A4 )
      break;
    if ( *((_DWORD *)off_816861C + j) )
      (*(void (__cdecl **)(_DWORD))(**((_DWORD **)off_816861C + j) + 4))(*((_DWORD *)off_816861C + j));
  }
  dword_89B63A0 = 0;
  dword_89B63A4 = 0;
  *(_DWORD *)dword_89B63A8 = 0;
  dword_89B63CC = 0;
  dword_89A9D80 = 0;
  return result;
}
// 8168618: using guessed type void *off_8168618;
// 816861C: using guessed type void *off_816861C;
// 89B63A0: using guessed type int dword_89B63A0;
// 89B63A4: using guessed type int dword_89B63A4;
// 89B63CC: using guessed type int dword_89B63CC;

//----- (0813127A) --------------------------------------------------------
int __cdecl FX_Free(char a1)
{
  int result; // eax

  result = sub_8131180();
  if ( dword_89A2814 )
  {
    result = sub_81287EA((int)dword_89A2814, a1, 0);
    if ( a1 )
    {
      sub_81355DC(dword_89A2814);
      dword_89A2814 = 0;
      result = sub_806C8C0();
      dword_89A280C[result] = 0;
    }
  }
  return result;
}
// 89A280C: using guessed type int dword_89A280C[];

//----- (081312E4) --------------------------------------------------------
int sub_81312E4()
{
  sub_8131180();
  return sub_81287EA((int)dword_89A2814, 0, 0);
}

//----- (0813130E) --------------------------------------------------------
int FX_GetBoneOrientation()
{
  printf("FX_GetBoneOrientation called!\n");
  return 0;
}

//----- (08131328) --------------------------------------------------------
void sub_8131328()
{
  dword_89AD6A0 = 0;
}
// 89AD6A0: using guessed type int dword_89AD6A0;

//----- (08131338) --------------------------------------------------------
int __cdecl sub_8131338(char a1)
{
  void *ptr; // [esp+20h] [ebp-8h]

  if ( !dword_89B64DC[sub_806C8C0()] )
  {
    dword_89B64DC[sub_806C8C0()] = 1;
    dword_89B63A0 = 0;
    dword_89B63A4 = 0;
    *(_DWORD *)dword_89B63A8 = 0;
    dword_89B63CC = 0;
    dword_89A9D80 = 0;
  }
  FX_Free(1);
  byte_8168610 = a1;
  ptr = sub_81355C8();
  sub_81287D0((int)ptr);
  dword_89A2814 = ptr;
  sub_8129736();
  dword_89A280C[sub_806C8C0()] = (int)dword_89A2814;
  sub_812A670((_DWORD *)off_8168620);
  return 1;
}
// 8168610: using guessed type char byte_8168610;
// 89A280C: using guessed type int dword_89A280C[];
// 89B63A0: using guessed type int dword_89B63A0;
// 89B63A4: using guessed type int dword_89B63A4;
// 89B63CC: using guessed type int dword_89B63CC;
// 89B64DC: using guessed type int dword_89B64DC[];

//----- (0813142A) --------------------------------------------------------
int __cdecl sub_813142A(_DWORD *a1, char a2)
{
  int result; // eax

  if ( a2 )
    (*(void (__cdecl **)(_DWORD *))(*a1 + 8))(a1);
  result = a1[42] & 0x1000;
  if ( result )
    --dword_89B63CC;
  return result;
}
// 89B63CC: using guessed type int dword_89B63CC;

//----- (08131468) --------------------------------------------------------
int __cdecl sub_8131468(int a1, char a2)
{
  _DWORD *v3; // [esp+10h] [ebp-8h]

  v3 = (_DWORD *)*((_DWORD *)off_8168618 + a1);
  sub_8134F7E(a1, --dword_89B63AC);
  return sub_813142A(v3, a2);
}
// 8168618: using guessed type void *off_8168618;
// 89B63AC: using guessed type int dword_89B63AC;

//----- (081314B8) --------------------------------------------------------
int __cdecl sub_81314B8(int a1, char a2)
{
  _DWORD *v3; // [esp+10h] [ebp-8h]

  v3 = (_DWORD *)*((_DWORD *)off_816861C + a1);
  sub_8134FDC(a1, --dword_89B63B0);
  return sub_813142A(v3, a2);
}
// 816861C: using guessed type void *off_816861C;
// 89B63B0: using guessed type int dword_89B63B0;

//----- (08131508) --------------------------------------------------------
void sub_8131508()
{
  ;
}

//----- (0813150E) --------------------------------------------------------
char *sub_813150E()
{
  ++*(_DWORD *)dword_89B63A8;
  if ( *(int *)dword_89B63A8 > 1800 )
  {
    --*(_DWORD *)dword_89B63A8;
    return 0;
  }
  else
  {
    ++dword_89B63A0;
    return (char *)off_8168618 + 4 * dword_89B63A0 - 4;
  }
}
// 8168618: using guessed type void *off_8168618;
// 89B63A0: using guessed type int dword_89B63A0;

//----- (0813155A) --------------------------------------------------------
char *sub_813155A()
{
  ++*(_DWORD *)dword_89B63A8;
  if ( *(int *)dword_89B63A8 > 1800 )
  {
    --*(_DWORD *)dword_89B63A8;
    return 0;
  }
  else
  {
    ++dword_89B63A4;
    return (char *)off_816861C + 4 * dword_89B63A4 - 4;
  }
}
// 816861C: using guessed type void *off_816861C;
// 89B63A4: using guessed type int dword_89B63A4;

//----- (081315A6) --------------------------------------------------------
long double __cdecl sub_81315A6(float *a1, float *a2)
{
  float v4; // [esp+14h] [ebp-34h]
  float v5; // [esp+18h] [ebp-30h]
  float v6; // [esp+1Ch] [ebp-2Ch]
  float v7[6]; // [esp+20h] [ebp-28h] BYREF
  int i; // [esp+38h] [ebp-10h]
  _DWORD *v9; // [esp+3Ch] [ebp-Ch]

  if ( dword_89B63CC )
  {
    sub_8134E3C(a2, a1, v7);
    v6 = Vec3Normalize(v7);
    if ( *(float *)(dword_89A2CA0 + 8) <= (long double)v6 )
    {
      v5 = v6 * 0.5;
      v4 = 1.0;
      for ( i = 0; i < dword_89B63A4; ++i )
      {
        v9 = (_DWORD *)*((_DWORD *)off_816861C + i);
        if ( (v9[42] & 0x1000) != 0 )
          v4 = ((long double (__cdecl *)(_DWORD *, float *, float *, _DWORD))*(_DWORD *)(*v9 + 24))(
                 v9,
                 a1,
                 v7,
                 LODWORD(v5))
             * v4;
      }
      for ( i = 0; i < dword_89B63A0; ++i )
      {
        v9 = (_DWORD *)*((_DWORD *)off_8168618 + i);
        if ( (v9[42] & 0x1000) != 0 )
          v4 = ((long double (__cdecl *)(_DWORD *, float *, float *, _DWORD))*(_DWORD *)(*v9 + 24))(
                 v9,
                 a1,
                 v7,
                 LODWORD(v5))
             * v4;
      }
      return v4;
    }
    else
    {
      return (float)1.0;
    }
  }
  else
  {
    return (float)1.0;
  }
}
// 8168618: using guessed type void *off_8168618;
// 816861C: using guessed type void *off_816861C;
// 89A2CA0: using guessed type int dword_89A2CA0;
// 89B63A0: using guessed type int dword_89B63A0;
// 89B63A4: using guessed type int dword_89B63A4;
// 89B63CC: using guessed type int dword_89B63CC;
// 81315A6: using guessed type float var_28[6];

//----- (08131708) --------------------------------------------------------
int sub_8131708()
{
  int result; // eax
  int i; // [esp+10h] [ebp-8h]
  int j; // [esp+10h] [ebp-8h]
  _DWORD *v3; // [esp+14h] [ebp-4h]
  _DWORD *v4; // [esp+14h] [ebp-4h]

  dword_89AD6A0 = 0;
  if ( dword_89B63CC )
  {
    for ( i = 0; i < dword_89B63A4; ++i )
    {
      v3 = (_DWORD *)*((_DWORD *)off_816861C + i);
      if ( (v3[42] & 0x1000) != 0 )
        (*(void (__cdecl **)(_DWORD *))(*v3 + 28))(v3);
    }
    for ( j = 0; ; ++j )
    {
      result = j;
      if ( j >= dword_89B63A0 )
        break;
      v4 = (_DWORD *)*((_DWORD *)off_8168618 + j);
      if ( (v4[42] & 0x1000) != 0 )
        (*(void (__cdecl **)(_DWORD *))(*v4 + 28))(v4);
    }
  }
  return result;
}
// 8168618: using guessed type void *off_8168618;
// 816861C: using guessed type void *off_816861C;
// 89AD6A0: using guessed type int dword_89AD6A0;
// 89B63A0: using guessed type int dword_89B63A0;
// 89B63A4: using guessed type int dword_89B63A4;
// 89B63CC: using guessed type int dword_89B63CC;

//----- (081317D0) --------------------------------------------------------
long double __cdecl sub_81317D0(float *a1, float *a2)
{
  long double v2; // fst7
  float v4; // [esp+0h] [ebp-78h]
  float v6; // [esp+18h] [ebp-60h]
  float v7; // [esp+1Ch] [ebp-5Ch]
  int v8[4]; // [esp+20h] [ebp-58h] BYREF
  float v9[4]; // [esp+30h] [ebp-48h] BYREF
  float *v10; // [esp+40h] [ebp-38h]
  float v11; // [esp+44h] [ebp-34h]
  float v12; // [esp+48h] [ebp-30h]
  float v13; // [esp+4Ch] [ebp-2Ch]
  int v14[7]; // [esp+50h] [ebp-28h] BYREF
  int i; // [esp+6Ch] [ebp-Ch]

  if ( dword_89AD6A0 )
  {
    sub_8134E3C(a2, a1, (float *)v14);
    v13 = Vec3Normalize((float *)v14);
    if ( *(float *)(dword_89A2CA0 + 8) <= (long double)v13 )
    {
      v12 = v13 * 0.5;
      v11 = 1.0;
      for ( i = 0; i < dword_89AD6A0; ++i )
      {
        v10 = (float *)((char *)&unk_89AD700 + 20 * i);
        sub_8134E3C(v10, a1, v9);
        v7 = sub_8134F0C(v9, (float *)v14);
        v4 = v7 - v12;
        v2 = sub_8134D5C(v4);
        if ( v2 <= v12 )
        {
          sub_8134EB8(a1, v7, (float *)v14, (float *)v8);
          v6 = sub_80A1DB2(v10, (float *)v8);
          if ( v6 < (long double)v10[3] )
            v11 = v11 * v10[4];
        }
      }
      return v11;
    }
    else
    {
      return (float)1.0;
    }
  }
  else
  {
    return (float)1.0;
  }
}
// 89A2CA0: using guessed type int dword_89A2CA0;
// 89AD6A0: using guessed type int dword_89AD6A0;
// 81317D0: using guessed type float var_48[4];

//----- (08131926) --------------------------------------------------------
int sub_8131926()
{
  int result; // eax
  int i; // [esp+Ch] [ebp-Ch]
  void **v2; // [esp+10h] [ebp-8h]

  for ( i = dword_89B63AC; ; ++i )
  {
    result = i;
    if ( i >= dword_89B63B4 )
      break;
    v2 = (void **)*((_DWORD *)off_8168618 + i);
    sub_8131042(v2[43]);
    if ( v2 )
      (*((void (__cdecl **)(void **))*v2 + 1))(v2);
    --dword_89B63A0;
    *((_DWORD *)off_8168618 + i) = *((_DWORD *)off_8168618 + dword_89B63A0);
    --*(_DWORD *)dword_89B63A8;
  }
  return result;
}
// 8168618: using guessed type void *off_8168618;
// 89B63A0: using guessed type int dword_89B63A0;
// 89B63AC: using guessed type int dword_89B63AC;
// 89B63B4: using guessed type int dword_89B63B4;

//----- (081319C4) --------------------------------------------------------
int sub_81319C4()
{
  int result; // eax
  int i; // [esp+Ch] [ebp-Ch]
  void **v2; // [esp+10h] [ebp-8h]

  for ( i = dword_89B63B0; ; ++i )
  {
    result = i;
    if ( i >= dword_89B63B8 )
      break;
    v2 = (void **)*((_DWORD *)off_816861C + i);
    sub_8131042(v2[43]);
    if ( v2 )
      (*((void (__cdecl **)(void **))*v2 + 1))(v2);
    --dword_89B63A4;
    *((_DWORD *)off_816861C + i) = *((_DWORD *)off_816861C + dword_89B63A4);
    --*(_DWORD *)dword_89B63A8;
  }
  return result;
}
// 816861C: using guessed type void *off_816861C;
// 89B63A4: using guessed type int dword_89B63A4;
// 89B63B0: using guessed type int dword_89B63B0;
// 89B63B8: using guessed type int dword_89B63B8;

//----- (08131A62) --------------------------------------------------------
int __cdecl sub_8131A62(int a1)
{
  int v2; // [esp+14h] [ebp-4h]
  int v3; // [esp+14h] [ebp-4h]

  dword_89B63AC = dword_89B63A0;
  dword_89B63B4 = dword_89B63A0;
  v2 = 0;
  while ( v2 < dword_89B63AC )
  {
    if ( sub_81351DE(*((_DWORD *)off_8168618 + v2)) <= a1 )
      ++v2;
    else
      sub_8131468(v2, 0);
  }
  sub_8131926();
  dword_89B63B0 = dword_89B63A4;
  dword_89B63B8 = dword_89B63A4;
  v3 = 0;
  while ( v3 < dword_89B63B0 )
  {
    if ( sub_81351DE(*((_DWORD *)off_816861C + v3)) <= a1 )
      ++v3;
    else
      sub_81314B8(v3, 0);
  }
  sub_81319C4();
  return sub_81287EA((int)dword_89A2814, 0, 0);
}
// 8168618: using guessed type void *off_8168618;
// 816861C: using guessed type void *off_816861C;
// 89B63A0: using guessed type int dword_89B63A0;
// 89B63A4: using guessed type int dword_89B63A4;
// 89B63AC: using guessed type int dword_89B63AC;
// 89B63B0: using guessed type int dword_89B63B0;
// 89B63B4: using guessed type int dword_89B63B4;
// 89B63B8: using guessed type int dword_89B63B8;

//----- (08131B58) --------------------------------------------------------
int __cdecl sub_8131B58(_DWORD *a1, int *a2)
{
  char v2; // al

  v2 = (*(int (__cdecl **)(_DWORD *))(*a1 + 36))(a1);
  sub_8121152(a2, v2);
  sub_8127A7C(a2, a1[47]);
  return (*(int (__cdecl **)(_DWORD *, int *))(*a1 + 40))(a1, a2);
}

//----- (08131BB6) --------------------------------------------------------
int __cdecl sub_8131BB6(int a1)
{
  int i; // [esp+1Ch] [ebp-2Ch]
  int j; // [esp+1Ch] [ebp-2Ch]
  int v4[10]; // [esp+20h] [ebp-28h] BYREF

  sub_8120708((int)v4);
  sub_8120794((int)v4, a1);
  sub_812ADDE(off_8168620, (int)v4);
  sub_8129558((int)dword_89A2814, v4);
  for ( i = 0; i < dword_89B63A0; ++i )
    sub_8131B58(*((_DWORD **)off_8168618 + i), v4);
  for ( j = 0; j < dword_89B63A4; ++j )
    sub_8131B58(*((_DWORD **)off_816861C + j), v4);
  sub_8121152(v4, 0);
  return sub_81355BA((int)v4);
}
// 8168618: using guessed type void *off_8168618;
// 816861C: using guessed type void *off_816861C;
// 89B63A0: using guessed type int dword_89B63A0;
// 89B63A4: using guessed type int dword_89B63A4;
// 8131BB6: using guessed type int var_28[10];

//----- (08131CA6) --------------------------------------------------------
int __cdecl sub_8131CA6(int a1, int a2)
{
  if ( a2 < *(_DWORD *)(a1 + 4) )
    return *(_DWORD *)(a1 + 4 * a2 + 8);
  else
    return 0;
}

//----- (08131CD8) --------------------------------------------------------
int __cdecl sub_8131CD8(int a1)
{
  unsigned __int8 v1; // al
  int v2; // ebx
  int v3; // eax
  int *v5; // [esp+24h] [ebp-A4h]
  int *v6; // [esp+30h] [ebp-98h]
  int *v7; // [esp+3Ch] [ebp-8Ch]
  int *v8; // [esp+48h] [ebp-80h]
  int *v9; // [esp+54h] [ebp-74h]
  int *v10; // [esp+60h] [ebp-68h]
  int *v11; // [esp+6Ch] [ebp-5Ch]
  int *v12; // [esp+78h] [ebp-50h]
  int *v13; // [esp+88h] [ebp-40h]
  int v14; // [esp+8Ch] [ebp-3Ch]
  int v15[8]; // [esp+90h] [ebp-38h] BYREF
  int *v16; // [esp+B0h] [ebp-18h]
  int v17; // [esp+B4h] [ebp-14h]
  int v18; // [esp+B8h] [ebp-10h]
  int i; // [esp+BCh] [ebp-Ch]

  sub_8120708((int)v15);
  FX_Free(0);
  sub_812074C((int)v15, a1);
  sub_812ADDE(off_8168620, (int)v15);
  sub_8129558((int)dword_89A2814, v15);
  for ( i = 0; ; ++i )
  {
    v1 = sub_8121100(v15);
    v18 = v1;
    if ( !v1 )
      break;
    v17 = sub_8127A56(v15);
    switch ( v18 )
    {
      case 1:
        v13 = sub_813537E(588);
        sub_81227F0(v13);
        v16 = v13;
        goto LABEL_13;
      case 2:
        v12 = sub_81353D6(600);
        sub_812528A(v12);
        v16 = v12;
        goto LABEL_13;
      case 3:
        v11 = sub_813544E(632);
        sub_812550A(v11);
        v16 = v11;
        goto LABEL_13;
      case 4:
        v10 = sub_8135488(632);
        sub_8125A04(v10);
        v16 = v10;
        goto LABEL_13;
      case 5:
        v9 = sub_813559E(668);
        sub_8125CB8(v9);
        v16 = v9;
        goto LABEL_13;
      case 7:
        v8 = sub_8135412(600);
        sub_81249E6(v8);
        v16 = v8;
        goto LABEL_13;
      case 9:
        v7 = sub_8135228(252);
        sub_812679A(v7);
        v16 = v7;
        goto LABEL_13;
      case 11:
        v6 = sub_8135228(252);
        sub_8135244(v6);
        v16 = v6;
        goto LABEL_13;
      case 12:
        v5 = sub_813539A(636);
        sub_8124CB6(v5);
        v16 = v5;
LABEL_13:
        (*(void (__cdecl **)(int *, int *))(*v16 + 40))(v16, v15);
        v2 = sub_81351F8((int)v16);
        v3 = sub_81351EC((int)v16);
        v14 = sub_8131CA6(v3, v2);
        if ( v14 )
        {
          (*(void (__cdecl **)(int *, int))(*v16 + 44))(v16, v14);
          if ( (v16[42] & 0x1000) != 0 )
            ++dword_89B63CC;
          if ( sub_812782E(v16 + 48) )
            *((_DWORD *)off_8168618 + dword_89B63A0++) = v16;
          else
            *((_DWORD *)off_816861C + dword_89B63A4++) = v16;
          ++*(_DWORD *)dword_89B63A8;
        }
        else if ( v16 )
        {
          (*(void (__cdecl **)(int *))(*v16 + 4))(v16);
        }
        break;
      default:
        continue;
    }
  }
  return sub_81355BA((int)v15);
}
// 8168618: using guessed type void *off_8168618;
// 816861C: using guessed type void *off_816861C;
// 89B63A0: using guessed type int dword_89B63A0;
// 89B63A4: using guessed type int dword_89B63A4;
// 89B63CC: using guessed type int dword_89B63CC;
// 8131CD8: using guessed type int var_38[8];

//----- (081321D6) --------------------------------------------------------
int __cdecl sub_81321D6(float *a1, float *a2)
{
  int v5; // [esp+10h] [ebp-18h]
  int v6; // [esp+14h] [ebp-14h]

  v5 = *(_DWORD *)a1;
  v6 = *(_DWORD *)a2;
  if ( *(_DWORD *)(*(_DWORD *)a1 + 176) != *(_DWORD *)(*(_DWORD *)a2 + 176) )
    return *(_DWORD *)(*(_DWORD *)a1 + 176) - *(_DWORD *)(*(_DWORD *)a2 + 176);
  if ( *(_DWORD *)(dword_89A9D88 + 4 * *(_DWORD *)(v5 + 172)) != *(_DWORD *)(dword_89A9D88 + 4 * *(_DWORD *)(v6 + 172)) )
    return *(_DWORD *)(dword_89A9D88 + 4 * *(_DWORD *)(v5 + 172))
         - *(_DWORD *)(dword_89A9D88 + 4 * *(_DWORD *)(v6 + 172));
  if ( *(_DWORD *)(v5 + 64) != *(_DWORD *)(v6 + 64) )
    return *(_DWORD *)(v5 + 64) - *(_DWORD *)(v6 + 64);
  if ( a2[1] <= (long double)a1[1] )
    return -1;
  else
    return 1;
}
// 89A9D88: using guessed type int dword_89A9D88;

//----- (081322B8) --------------------------------------------------------
int __cdecl sub_81322B8(float *a1, float *a2)
{
  if ( a2[1] <= (long double)a1[1] )
    return -1;
  else
    return 1;
}

//----- (081322F4) --------------------------------------------------------
void __cdecl sub_81322F4(void *a1, size_t nmemb)
{
  int v2; // ebx
  int v3[1800]; // [esp+10h] [ebp-5478h] BYREF
  int base[3603]; // [esp+1C30h] [ebp-3858h] BYREF
  int i; // [esp+547Ch] [ebp-Ch]

  for ( i = 0; i < (int)dword_89A9D80; ++i )
  {
    base[2 * i] = i;
    v2 = i;
    *(float *)&base[2 * v2 + 1] = sub_80A1DB2((float *)off_8168614 + 4 * i, (float *)(off_8168620 + 20));
  }
  qsort(base, dword_89A9D80, 8u, (__compar_fn_t)sub_81322B8);
  for ( i = 0; i < (int)dword_89A9D80; ++i )
    v3[base[2 * i]] = i;
  dword_89A9D88 = (int)v3;
  qsort(a1, nmemb, 8u, (__compar_fn_t)sub_81321D6);
  dword_89A9D88 = 0;
}
// 8168614: using guessed type void *off_8168614;
// 89A9D88: using guessed type int dword_89A9D88;
// 81322F4: using guessed type int var_5478[1800];

//----- (081323E6) --------------------------------------------------------
int sub_81323E6()
{
  _DWORD *v1; // [esp+10h] [ebp-8h]
  int v2; // [esp+14h] [ebp-4h]

  dword_89B63AC = dword_89B63A0;
  dword_89B63B4 = dword_89B63A0;
  v2 = 0;
  while ( v2 < dword_89B63AC )
  {
    v1 = (_DWORD *)*((_DWORD *)off_8168618 + v2);
    if ( *(_DWORD *)(off_8168620 + 4) <= v1[47] )
    {
      if ( (*(unsigned __int8 (__cdecl **)(_DWORD *))(*v1 + 12))(v1) )
        ++v2;
      else
        sub_8131468(v2, 1);
    }
    else
    {
      sub_81350CE((int)v1, 1024);
      sub_8131468(v2, 1);
    }
  }
  return sub_8131926();
}
// 8168618: using guessed type void *off_8168618;
// 89B63A0: using guessed type int dword_89B63A0;
// 89B63AC: using guessed type int dword_89B63AC;
// 89B63B4: using guessed type int dword_89B63B4;

//----- (081324A6) --------------------------------------------------------
int sub_81324A6()
{
  _DWORD *v1; // [esp+10h] [ebp-8h]
  int v2; // [esp+14h] [ebp-4h]

  dword_89B63B0 = dword_89B63A4;
  dword_89B63B8 = dword_89B63A4;
  v2 = 0;
  while ( v2 < dword_89B63B0 )
  {
    v1 = (_DWORD *)*((_DWORD *)off_816861C + v2);
    if ( *(_DWORD *)(off_8168620 + 4) <= v1[47] )
    {
      if ( (*(unsigned __int8 (__cdecl **)(_DWORD *))(*v1 + 12))(v1) )
        ++v2;
      else
        sub_81314B8(v2, 1);
    }
    else
    {
      sub_81350CE((int)v1, 1024);
      sub_81314B8(v2, 1);
    }
  }
  return sub_81319C4();
}
// 816861C: using guessed type void *off_816861C;
// 89B63A4: using guessed type int dword_89B63A4;
// 89B63B0: using guessed type int dword_89B63B0;
// 89B63B8: using guessed type int dword_89B63B8;

//----- (08132566) --------------------------------------------------------
int __cdecl sub_8132566(int a1)
{
  int result; // eax
  _DWORD *v3; // [esp+14h] [ebp-4h]

  dword_89B63B4 = dword_89B63AC;
  while ( 1 )
  {
    result = a1;
    if ( a1 >= dword_89B63AC )
      break;
    v3 = (_DWORD *)*((_DWORD *)off_8168618 + a1);
    if ( *(_DWORD *)(off_8168620 + 4) <= v3[47] )
    {
      if ( (*(unsigned __int8 (__cdecl **)(_DWORD *))(*v3 + 12))(v3) )
        ++a1;
      else
        sub_8131468(a1, 1);
    }
    else
    {
      sub_81350CE((int)v3, 1024);
      sub_8131468(a1, 1);
    }
  }
  return result;
}
// 8168618: using guessed type void *off_8168618;
// 89B63AC: using guessed type int dword_89B63AC;
// 89B63B4: using guessed type int dword_89B63B4;

//----- (0813261C) --------------------------------------------------------
int sub_813261C()
{
  int v0; // ebx
  int result; // eax
  int i; // [esp+Ch] [ebp-Ch]
  float *v3; // [esp+10h] [ebp-8h]

  for ( i = dword_89B63C4; i < dword_89B63AC; ++i )
  {
    v3 = (float *)*((_DWORD *)off_8168618 + i);
    if ( !*(_BYTE *)(dword_89A2C88 + 8) || !(*(unsigned __int8 (__cdecl **)(float *))(*(_DWORD *)v3 + 16))(v3) )
    {
      dword_89B9D40[2 * dword_89BD580] = (int)v3;
      v0 = dword_89BD580;
      flt_89B9D44[2 * v0] = sub_80A1DB2(v3 + 31, (float *)(off_8168620 + 20));
      ++dword_89BD580;
    }
  }
  result = dword_89B63AC;
  dword_89B63C4 = dword_89B63AC;
  return result;
}
// 8168618: using guessed type void *off_8168618;
// 89A2C88: using guessed type int dword_89A2C88;
// 89B63AC: using guessed type int dword_89B63AC;
// 89B63C4: using guessed type int dword_89B63C4;
// 89B9D40: using guessed type int dword_89B9D40[];
// 89B9D44: using guessed type float flt_89B9D44[3599];
// 89BD580: using guessed type int dword_89BD580;

//----- (081326C8) --------------------------------------------------------
int __cdecl sub_81326C8(int a1)
{
  int result; // eax
  _DWORD *v3; // [esp+14h] [ebp-4h]

  dword_89B63B8 = dword_89B63B0;
  while ( 1 )
  {
    result = a1;
    if ( a1 >= dword_89B63B0 )
      break;
    v3 = (_DWORD *)*((_DWORD *)off_816861C + a1);
    if ( *(_DWORD *)(off_8168620 + 4) <= v3[47] )
    {
      if ( (*(unsigned __int8 (__cdecl **)(_DWORD *))(*v3 + 12))(v3) )
        ++a1;
      else
        sub_81314B8(a1, 1);
    }
    else
    {
      sub_81350CE((int)v3, 1024);
      sub_81314B8(a1, 1);
    }
  }
  return result;
}
// 816861C: using guessed type void *off_816861C;
// 89B63B0: using guessed type int dword_89B63B0;
// 89B63B8: using guessed type int dword_89B63B8;

//----- (0813277E) --------------------------------------------------------
int sub_813277E()
{
  int result; // eax
  size_t v1; // ebx
  int i; // [esp+Ch] [ebp-Ch]
  float *v3; // [esp+10h] [ebp-8h]

  result = dword_89A2828;
  if ( dword_89A2828 )
  {
    for ( i = dword_89B63C8; i < dword_89B63B0; ++i )
    {
      v3 = (float *)*((_DWORD *)off_816861C + i);
      if ( !*(_BYTE *)(dword_89A2C88 + 8) || !(*(unsigned __int8 (__cdecl **)(float *))(*(_DWORD *)v3 + 16))(v3) )
      {
        dword_89B64E0[2 * dword_89B9D20] = (int)v3;
        v1 = dword_89B9D20;
        flt_89B64E4[2 * v1] = sub_80A1DB2(v3 + 31, (float *)(off_8168620 + 20));
        ++dword_89B9D20;
      }
    }
    result = dword_89B63B0;
    dword_89B63C8 = dword_89B63B0;
  }
  return result;
}
// 816861C: using guessed type void *off_816861C;
// 89A2828: using guessed type int dword_89A2828;
// 89A2C88: using guessed type int dword_89A2C88;
// 89B63B0: using guessed type int dword_89B63B0;
// 89B63C8: using guessed type int dword_89B63C8;
// 89B64E0: using guessed type int dword_89B64E0[];
// 89B64E4: using guessed type float flt_89B64E4[3599];

//----- (08132838) --------------------------------------------------------
void sub_8132838()
{
  size_t v0; // ecx
  float v1; // edx
  int i; // [esp+14h] [ebp-4h]
  signed int j; // [esp+14h] [ebp-4h]

  sub_813277E();
  sub_813261C();
  for ( i = 0; i < dword_89BD580; ++i )
  {
    v0 = dword_89B9D20;
    v1 = flt_89B9D44[2 * i];
    dword_89B64E0[2 * dword_89B9D20] = dword_89B9D40[2 * i];
    flt_89B64E4[2 * v0] = v1;
    ++dword_89B9D20;
  }
  sub_8131708();
  if ( *(_BYTE *)(dword_89A2C8C + 8) )
    sub_81322F4(dword_89B64E0, dword_89B9D20);
  if ( *(_BYTE *)(dword_89A2C84 + 8) )
  {
    for ( j = 0; j < (int)dword_89B9D20; ++j )
      (*(void (__cdecl **)(int))(*(_DWORD *)dword_89B64E0[2 * j] + 20))(dword_89B64E0[2 * j]);
  }
  if ( *(_BYTE *)(dword_89A2C90 + 8) )
  {
    sub_812F0A2("Active    FX: %i\n", *(_DWORD *)dword_89B63A8);
    sub_812F0A2("Drawn     FX: %i\n", dword_89B9D20);
    sub_812F0A2("Scheduled FX: %i\n", *((_DWORD *)dword_89A2814 + 2));
  }
}
// 89A2C84: using guessed type int dword_89A2C84;
// 89A2C8C: using guessed type int dword_89A2C8C;
// 89A2C90: using guessed type int dword_89A2C90;
// 89B64E0: using guessed type int dword_89B64E0[];
// 89B64E4: using guessed type float flt_89B64E4[3599];
// 89B9D40: using guessed type int dword_89B9D40[];
// 89B9D44: using guessed type float flt_89B9D44[3599];
// 89BD580: using guessed type int dword_89BD580;

//----- (08132948) --------------------------------------------------------
float *__cdecl sub_8132948(int a1, float *a2, float *a3, float *a4)
{
  int v4; // esi
  float v5; // esi
  long double v6; // fst7
  long double v7; // fst7
  _DWORD *v8; // eax
  int v10; // [esp+4h] [ebp-C4h]
  float v11; // [esp+4h] [ebp-C4h]
  int v12; // [esp+4h] [ebp-C4h]
  float v13; // [esp+4h] [ebp-C4h]
  float v14; // [esp+4h] [ebp-C4h]
  int v15; // [esp+8h] [ebp-C0h]
  int v16; // [esp+Ch] [ebp-BCh]
  float v17; // [esp+Ch] [ebp-BCh]
  int v18; // [esp+2Ch] [ebp-9Ch]
  int v19; // [esp+2Ch] [ebp-9Ch]
  float v20; // [esp+2Ch] [ebp-9Ch]
  float v21; // [esp+2Ch] [ebp-9Ch]
  float v22; // [esp+30h] [ebp-98h]
  int v23; // [esp+38h] [ebp-90h]
  float *v24; // [esp+3Ch] [ebp-8Ch]
  int v25[4]; // [esp+40h] [ebp-88h] BYREF
  int v26[6]; // [esp+50h] [ebp-78h] BYREF
  float v27; // [esp+68h] [ebp-60h]
  float v28; // [esp+6Ch] [ebp-5Ch]
  int v29[4]; // [esp+70h] [ebp-58h] BYREF
  int v30[7]; // [esp+80h] [ebp-48h] BYREF
  float v31; // [esp+9Ch] [ebp-2Ch]
  int v32; // [esp+A0h] [ebp-28h] BYREF
  int v33; // [esp+A4h] [ebp-24h] BYREF
  int v34; // [esp+A8h] [ebp-20h] BYREF
  int v35; // [esp+ACh] [ebp-1Ch] BYREF
  float v36; // [esp+B0h] [ebp-18h]
  float v37; // [esp+B4h] [ebp-14h]
  float v38; // [esp+B8h] [ebp-10h]
  float v39; // [esp+BCh] [ebp-Ch]

  v26[0] = 0;
  v26[1] = 0;
  v26[2] = 1065353216;
  v23 = *(_DWORD *)(a1 + 4);
  if ( (*(_DWORD *)(v23 + 148) & 0x40) != 0 )
  {
    *(float *)&v18 = sub_812F170((float *)(v23 + 200));
    v4 = v18;
    *(float *)&v19 = sub_812F170((float *)(v23 + 192));
    *(float *)&v10 = sub_812F170((float *)(v23 + 184));
    sub_8134DA4(v25, v10, v19, v4);
  }
  else
  {
    v20 = sub_812F170((float *)(v23 + 200));
    v5 = v20;
    v21 = sub_812F170((float *)(v23 + 192));
    v11 = sub_812F170((float *)(v23 + 184));
    sub_80A70C0(a4, v11, v21, v5, (float *)v25);
  }
  sub_8134DF8((float *)v25, a3, (float *)v25);
  if ( (*(_BYTE *)(v23 + 148) & 1) != 0 )
  {
    v39 = sub_80A8720(0.0, 360.0) * 0.0174532925199433;
    sub_8134D76(v39, (float *)&v35, (float *)&v34);
    v38 = sub_80A8720(0.0, 180.0) * 0.0174532925199433;
    sub_8134D76(v38, (float *)&v33, (float *)&v32);
    v37 = sub_812F170((float *)(v23 + 232));
    v36 = sub_812F170((float *)(v23 + 240));
    *(float *)&v16 = *(float *)&v32 * v36;
    *(float *)&v15 = *(float *)&v34 * v37 * *(float *)&v33;
    v6 = *(float *)&v35 * v37 * *(float *)&v33;
    *(float *)&v12 = v6;
    sub_8134DA4(v30, v12, v15, v16);
    sub_8134DF8((float *)v25, (float *)v30, (float *)v25);
    if ( (*(_DWORD *)(v23 + 148) & 2) != 0 )
    {
      sub_8134F40((float *)v30);
      v31 = v6;
      if ( v31 != 0.0 )
      {
        v13 = 1.0 / v31;
        sub_8134E80((float *)v30, v13, a4);
        sub_80A295E((int)a4, (int)(a4 + 3), a4 + 6);
      }
    }
  }
  else if ( (*(_DWORD *)(v23 + 148) & 4) != 0 )
  {
    v22 = sub_80A8720(-0.5, 0.5);
    v27 = sub_812F170((float *)(v23 + 240)) * v22;
    v28 = sub_812F170((float *)(v23 + 232));
    sub_8134E80(a4 + 3, v28, (float *)v29);
    sub_8134EB8((float *)v29, v27, a4, (float *)v29);
    v7 = sub_80A8720(0.0, 360.0);
    v17 = v7;
    sub_80A2672((int)v30, (int)a4, (float *)v29, v17);
    sub_8134DF8((float *)v25, (float *)v30, (float *)v25);
    if ( (*(_DWORD *)(v23 + 148) & 2) != 0 )
    {
      sub_8134F40((float *)v30);
      v31 = v7;
      if ( v31 != 0.0 )
      {
        v14 = 1.0 / v31;
        sub_8134E80((float *)v30, v14, a4);
        if ( sub_8134D5C(a4[2]) >= 0.99900001 )
          sub_8134DA4(v26, 0, 1065353216, 0);
        sub_80A1ED8((float *)v26, a4, a4 + 3);
        Vec3Normalize(a4 + 3);
        sub_80A1ED8(a4, a4 + 3, a4 + 6);
      }
    }
  }
  if ( !sub_812782E((_DWORD *)(a1 + 8)) )
    return (float *)sub_8134DC8(v25, a2);
  v8 = (_DWORD *)sub_812787E(a1 + 8);
  v24 = (float *)sub_8122008(v8);
  return sub_80B68EE(v24, (float *)v25, a2);
}

//----- (08132E4E) --------------------------------------------------------
float *__cdecl sub_8132E4E(int a1, float *a2, float *a3, float *a4, float *a5)
{
  int v5; // esi
  float v6; // esi
  float *result; // eax
  int v8; // eax
  int v9; // esi
  float v10; // esi
  int v11; // [esp+4h] [ebp-84h]
  float v12; // [esp+4h] [ebp-84h]
  int v13; // [esp+4h] [ebp-84h]
  float v14; // [esp+4h] [ebp-84h]
  int v15; // [esp+2Ch] [ebp-5Ch]
  int v16; // [esp+2Ch] [ebp-5Ch]
  float v17; // [esp+2Ch] [ebp-5Ch]
  float v18; // [esp+2Ch] [ebp-5Ch]
  int v19; // [esp+2Ch] [ebp-5Ch]
  int v20; // [esp+2Ch] [ebp-5Ch]
  float v21; // [esp+2Ch] [ebp-5Ch]
  float v22; // [esp+2Ch] [ebp-5Ch]
  int v23[4]; // [esp+30h] [ebp-58h] BYREF
  int v24[4]; // [esp+40h] [ebp-48h] BYREF
  float s; // [esp+50h] [ebp-38h] BYREF
  int v26; // [esp+54h] [ebp-34h] BYREF

  if ( (*(_DWORD *)(a1 + 148) & 8) != 0 )
  {
    sub_8134EB8(a2, 16384.0, a5, (float *)v24);
    if ( (*(_DWORD *)(a1 + 148) & 0x20) != 0 )
    {
      if ( *(char *)(a1 + 148) >= 0 )
      {
        v17 = sub_812F170((float *)(a1 + 224));
        v6 = v17;
        v18 = sub_812F170((float *)(a1 + 216));
        v12 = sub_812F170((float *)(a1 + 208));
        sub_80A70C0(a5, v12, v18, v6, (float *)v23);
        sub_8134DF8((float *)v24, (float *)v23, (float *)v24);
      }
      else
      {
        *(float *)&v15 = sub_812F170((float *)(a1 + 224));
        v5 = v15;
        *(float *)&v16 = sub_812F170((float *)(a1 + 216));
        *(float *)&v11 = sub_812F170((float *)(a1 + 208));
        sub_8134DA4(a3, v11, v16, v5);
        sub_8134DF8(a3, (float *)v24, (float *)v24);
      }
    }
    sub_812AD4E(off_8168620, &s, a2, (int)flt_8145E68, (int)flt_8145E68, (float *)v24, -1, 1);
    sub_80DEB7A(a2, (float *)v24, s, a3);
    result = (float *)(*(_DWORD *)(a1 + 148) & 0x10);
    if ( result )
    {
      v8 = sub_812873E(a1 + 112);
      return (float *)sub_8128900(dword_89A2814, v8, a3, &v26);
    }
  }
  else
  {
    if ( *(char *)(a1 + 148) >= 0 )
    {
      v21 = sub_812F170((float *)(a1 + 224));
      v10 = v21;
      v22 = sub_812F170((float *)(a1 + 216));
      v14 = sub_812F170((float *)(a1 + 208));
      sub_80A70C0(a5, v14, v22, v10, a3);
    }
    else
    {
      *(float *)&v19 = sub_812F170((float *)(a1 + 224));
      v9 = v19;
      *(float *)&v20 = sub_812F170((float *)(a1 + 216));
      *(float *)&v13 = sub_812F170((float *)(a1 + 208));
      sub_8134DA4(a3, v13, v20, v9);
    }
    return sub_8134DF8(a3, a4, a3);
  }
  return result;
}
// 8128900: using guessed type _DWORD __cdecl sub_8128900(_DWORD, _DWORD, _DWORD, _DWORD);
// 8145E68: using guessed type float flt_8145E68[3];

//----- (08133120) --------------------------------------------------------
float *__cdecl sub_8133120(int a1, int a2, float *a3, int a4)
{
  float *result; // eax
  float v5; // [esp+1Ch] [ebp-1Ch]
  int v6[6]; // [esp+20h] [ebp-18h] BYREF

  if ( a4 > 0 )
  {
    v5 = (long double)a4 * 0.001;
    sub_8123D56(a2, a4, (float *)v6);
    return sub_8134EB8(a3, v5, (float *)v6, a3);
  }
  return result;
}

//----- (08133176) --------------------------------------------------------
int __cdecl sub_8133176(int *a1, _DWORD *a2, float *a3)
{
  int v3; // ebx
  int v4; // eax
  int v5; // eax
  int v8; // [esp+10h] [ebp-18h]
  size_t v9; // [esp+18h] [ebp-10h]
  int v10; // [esp+1Ch] [ebp-Ch]
  char *v11; // [esp+20h] [ebp-8h]

  v10 = a1[1];
  if ( sub_812782E(a1 + 2) )
    v11 = sub_813150E();
  else
    v11 = sub_813155A();
  v9 = sub_8130F90(a3);
  if ( v11 )
  {
    if ( (*(_DWORD *)(v10 + 144) & 0x1000) != 0 )
      ++dword_89B63CC;
    *(_DWORD *)v11 = a2;
    sub_8135186((int)a2, *(_DWORD *)(v10 + 144));
    v3 = off_8168620;
    v8 = (int)sub_812F170((float *)(v10 + 88));
    sub_8122472((int)a2, *(_DWORD *)(off_8168620 + 4), *(_DWORD *)(v3 + 4) + v8);
    sub_81351C2((int)a2, *a1);
    sub_81351D0((int)a2, *(_DWORD *)(v10 + 68));
    sub_8135198((int)a2, *(_DWORD *)(v10 + 152));
    sub_81350EA((int)a2, (_DWORD *)(v10 + 160));
    sub_813511E((int)a2, (_DWORD *)(v10 + 172));
    v4 = sub_812873E(v10 + 120);
    sub_81351B4((int)a2, v4);
    v5 = sub_812873E(v10 + 112);
    sub_81351A6((int)a2, v5);
    (*(void (__cdecl **)(_DWORD *, int))(*a2 + 32))(a2, v10);
    sub_81224B2((int)a2, a1 + 2);
    a2[43] = v9;
    return 1;
  }
  else
  {
    sub_8131508();
    return 0;
  }
}
// 89B63CC: using guessed type int dword_89B63CC;

//----- (08133348) --------------------------------------------------------
int __cdecl sub_8133348(int a1)
{
  int result; // eax

  *(_DWORD *)(a1 + 176) = 0;
  result = a1;
  if ( *(_DWORD *)(a1 + 64) )
  {
    result = sub_812AE5C();
    if ( (_BYTE)result )
    {
      result = a1;
      *(_DWORD *)(a1 + 176) = -1;
    }
  }
  return result;
}

//----- (0813338E) --------------------------------------------------------
int __cdecl sub_813338E(int a1, int a2, int a3, int a4)
{
  int v5; // [esp+14h] [ebp-14h] BYREF
  float v6; // [esp+18h] [ebp-10h]
  int v7; // [esp+1Ch] [ebp-Ch]
  int v8; // [esp+20h] [ebp-8h]
  int v9; // [esp+24h] [ebp-4h]

  sub_812875E(&v5, a1 + 104);
  v9 = v5;
  if ( v5 )
  {
    v8 = sub_812AE52();
    if ( v8 == 1 )
    {
      v7 = 0;
      v6 = 0.0;
    }
    else
    {
      if ( *(_DWORD *)(a1 + 648) )
      {
        if ( *(_DWORD *)(a1 + 648) == 1 )
        {
          v7 = sub_80A8776(0, v8);
        }
        else if ( *(_DWORD *)(a1 + 648) == 2 )
        {
          v7 = a4;
        }
        else
        {
          v7 = 0;
        }
      }
      else
      {
        v7 = *(_DWORD *)(a1 + 652) - 1;
      }
      if ( *(_DWORD *)(a1 + 656) )
      {
        if ( *(_DWORD *)(a1 + 656) == 1 )
          v6 = (long double)v8 / (long double)a3;
        else
          v6 = 0.0;
      }
      else
      {
        v6 = *(float *)(a1 + 660) / 1000.0;
      }
    }
  }
  else
  {
    v7 = 0;
    v6 = 0.0;
  }
  sub_81352CA(a2, v7);
  sub_81352DC(a2, SLODWORD(v6));
  sub_81352EE(a2, *(_DWORD *)(a1 + 664));
  sub_8135300(a2, *(_DWORD *)(a1 + 668));
  sub_813526E(a2, v9);
  return sub_8133348(a2);
}

//----- (0813350E) --------------------------------------------------------
int __cdecl sub_813350E(int a1, _DWORD *a2, float *a3, float *a4, float *a5)
{
  int v5; // esi
  int v6; // esi
  int v8; // [esp+4h] [ebp-24h]
  int v9; // [esp+4h] [ebp-24h]
  int v10; // [esp+4h] [ebp-24h]
  int v11; // [esp+4h] [ebp-24h]
  int v12; // [esp+4h] [ebp-24h]
  int v13; // [esp+4h] [ebp-24h]
  int v14; // [esp+4h] [ebp-24h]
  int v15; // [esp+4h] [ebp-24h]
  int v16; // [esp+4h] [ebp-24h]
  int v17; // [esp+4h] [ebp-24h]
  int v18; // [esp+4h] [ebp-24h]
  int v19; // [esp+18h] [ebp-10h]
  int v20; // [esp+18h] [ebp-10h]
  int v21; // [esp+18h] [ebp-10h]
  int v22; // [esp+18h] [ebp-10h]
  int v23; // [esp+1Ch] [ebp-Ch]

  v23 = *(_DWORD *)(a1 + 4);
  if ( (*(_DWORD *)(v23 + 144) & 0x2000) != 0 )
  {
    *(float *)&v8 = sub_80A8720(0.0, 1.0);
    sub_8135312((int)a2, v8);
  }
  if ( (*(_DWORD *)(v23 + 144) & 0x4000) != 0 )
  {
    *(float *)&v9 = sub_80A8720(0.0, 1.0);
    sub_8135324((int)a2, v9);
  }
  if ( *(__int16 *)(v23 + 144) < 0 )
  {
    *(float *)&v10 = sub_80A8720(0.0, 1.0);
    sub_8135336((int)a2, v10);
  }
  if ( (*(_DWORD *)(v23 + 144) & 0x10000) != 0 )
  {
    *(float *)&v11 = sub_80A8720(0.0, 1.0);
    sub_8135348((int)a2, v11);
  }
  if ( (*(_DWORD *)(v23 + 144) & 0x40000) != 0 )
  {
    *(float *)&v12 = sub_80A8720(0.0, 1.0);
    sub_813535A((int)a2, v12);
  }
  if ( (*(_DWORD *)(v23 + 144) & 0x80000) != 0 )
  {
    *(float *)&v19 = sub_80A8720(0.0, 1.0);
    v5 = v19;
    *(float *)&v20 = sub_80A8720(0.0, 1.0);
    *(float *)&v13 = sub_80A8720(0.0, 1.0);
    sub_8122EAC((int)a2, v13, v20, v5);
  }
  if ( (*(_DWORD *)(v23 + 144) & 0x100000) != 0 )
  {
    *(float *)&v21 = sub_80A8720(0.0, 1.0);
    v6 = v21;
    *(float *)&v22 = sub_80A8720(0.0, 1.0);
    *(float *)&v14 = sub_80A8720(0.0, 1.0);
    sub_8122EDA((int)a2, v14, v22, v6);
  }
  *(float *)&v15 = sub_812F170((float *)(v23 + 600));
  sub_813527C((int)a2, v15);
  *(float *)&v16 = sub_812F170((float *)(v23 + 248));
  sub_813536C((int)a2, v16);
  sub_8132948(a1, a3, a4, a5);
  sub_8122BB2(a2, a5);
  sub_81352AE((int)a2, *(_BYTE *)(v23 + 156));
  *(float *)&v17 = sub_812F170((float *)(v23 + 640));
  sub_813529C((int)a2, v17);
  *(float *)&v18 = sub_812F170((float *)(v23 + 544));
  return sub_813528E((int)a2, v18);
}

//----- (081337F2) --------------------------------------------------------
int __cdecl sub_81337F2(int *a1, float *a2, float *a3, int a4, int a5)
{
  int result; // eax
  int v6; // eax
  int *v7; // [esp+38h] [ebp-30h]
  float v8[7]; // [esp+40h] [ebp-28h] BYREF
  int *v9; // [esp+5Ch] [ebp-Ch]

  v7 = sub_813537E(588);
  sub_81227F0(v7);
  result = (int)v7;
  v9 = v7;
  if ( v7 )
  {
    if ( (unsigned __int8)sub_8133176(a1, v9, a3) )
    {
      sub_813350E((int)a1, v9, v8, a3, a2);
      v6 = sub_8127896((int)v9);
      sub_813338E(a1[1], (int)v9, v6, a5);
      sub_8133120(a1[1], (int)v9, v8, a4);
      return sub_8135152((int)v9, v8);
    }
    else
    {
      return (*(int (__cdecl **)(int *))(*v9 + 4))(v9);
    }
  }
  return result;
}
// 813387A: conditional instruction was optimized away because %var_C.4!=0
// 81337F2: using guessed type float var_28[7];

//----- (0813392A) --------------------------------------------------------
int __cdecl sub_813392A(int *a1, float *a2, float *a3)
{
  int result; // eax
  _DWORD *v4; // eax
  int v5; // [esp+4h] [ebp-A4h]
  int v6; // [esp+4h] [ebp-A4h]
  int v7; // [esp+4h] [ebp-A4h]
  int v8; // [esp+4h] [ebp-A4h]
  int *v9; // [esp+2Ch] [ebp-7Ch]
  int v10; // [esp+30h] [ebp-78h] BYREF
  int v11; // [esp+34h] [ebp-74h]
  float *v13; // [esp+3Ch] [ebp-6Ch]
  float v14[4]; // [esp+40h] [ebp-68h] BYREF
  float v15[4]; // [esp+50h] [ebp-58h] BYREF
  _DWORD v16[4]; // [esp+60h] [ebp-48h] BYREF
  float v17[4]; // [esp+70h] [ebp-38h] BYREF
  float v18[6]; // [esp+80h] [ebp-28h] BYREF
  int v19; // [esp+98h] [ebp-10h]
  int *v20; // [esp+9Ch] [ebp-Ch]

  v9 = sub_81353D6(600);
  sub_812528A(v9);
  result = (int)v9;
  v20 = v9;
  if ( v9 )
  {
    if ( (unsigned __int8)sub_8133176(a1, v20, a3) )
    {
      sub_8132948((int)a1, v18, a3, a2);
      sub_8122BB2(v20, a2);
      v11 = a1[1];
      sub_8132E4E(v11, v18, v17, a3, a2);
      sub_8134DC8(v18, v16);
      sub_8134DC8(v17, v15);
      sub_812875E(&v10, v11 + 104);
      v19 = v10;
      if ( sub_812782E(a1 + 2) )
      {
        v4 = (_DWORD *)sub_812787E((int)(a1 + 2));
        v13 = (float *)sub_8122008(v4);
        sub_80B68EE(v13, v15, v14);
        sub_81353B6((int)v20, v14);
      }
      else
      {
        sub_81353B6((int)v20, v15);
      }
      sub_8135152((int)v20, v16);
      sub_813526E((int)v20, v19);
      if ( (*(_DWORD *)(v11 + 144) & 0x2000) != 0 )
      {
        *(float *)&v5 = sub_80A8720(0.0, 1.0);
        sub_8135312((int)v20, v5);
      }
      if ( (*(_DWORD *)(v11 + 144) & 0x4000) != 0 )
      {
        *(float *)&v6 = sub_80A8720(0.0, 1.0);
        sub_8135324((int)v20, v6);
      }
      if ( *(__int16 *)(v11 + 144) < 0 )
      {
        *(float *)&v7 = sub_80A8720(0.0, 1.0);
        sub_8135336((int)v20, v7);
      }
      if ( (*(_DWORD *)(v11 + 144) & 0x10000) != 0 )
      {
        *(float *)&v8 = sub_80A8720(0.0, 1.0);
        sub_8135348((int)v20, v8);
      }
      return sub_8133348((int)v20);
    }
    else
    {
      return (*(int (__cdecl **)(int *))(*v20 + 4))(v20);
    }
  }
  return result;
}
// 81339C7: conditional instruction was optimized away because %var_C.4!=0
// 813392A: using guessed type float var_28[6];
// 813392A: using guessed type float var_38[4];
// 813392A: using guessed type _DWORD var_48[4];
// 813392A: using guessed type float var_58[4];
// 813392A: using guessed type float var_68[4];

//----- (08133C04) --------------------------------------------------------
void __cdecl sub_8133C04(int *a1, float *a2, float *a3, int a4, int a5)
{
  int v5; // eax
  float *v6; // ebx
  long double v7; // fst7
  int *v8; // [esp+38h] [ebp-40h]
  int v9[4]; // [esp+40h] [ebp-38h] BYREF
  int v10[7]; // [esp+50h] [ebp-28h] BYREF
  float *v11; // [esp+6Ch] [ebp-Ch]

  v8 = sub_813544E(632);
  sub_812550A(v8);
  v11 = (float *)v8;
  if ( v8 )
  {
    if ( (unsigned __int8)sub_8133176(a1, v11, a3) )
    {
      sub_813350E((int)a1, v11, (float *)v10, a3, a2);
      v5 = sub_8127896((int)v11);
      sub_813338E(a1[1], (int)v11, v5, a5);
      sub_8133120(a1[1], (int)v11, (float *)v10, a4);
      sub_8134EB8((float *)v10, -1.0, a2, (float *)v9);
      sub_8135152((int)v11, v10);
      sub_813542E((int)v11, v9);
      v6 = v11;
      v7 = sub_80A8720(0.0, 1.0);
      v6[151] = v7;
      sub_81255C2(v7, v11);
    }
    else
    {
      (*(void (__cdecl **)(float *))(*(_DWORD *)v11 + 4))(v11);
    }
  }
}
// 8133C8D: conditional instruction was optimized away because %var_C.4!=0

//----- (08133D9E) --------------------------------------------------------
int __cdecl sub_8133D9E(int *a1, float *a2, float *a3, int a4, int a5)
{
  int result; // eax
  int v6; // eax
  _DWORD *v7; // eax
  int *v8; // [esp+34h] [ebp-64h]
  float *v9; // [esp+3Ch] [ebp-5Ch]
  float v10[4]; // [esp+40h] [ebp-58h] BYREF
  float v11[4]; // [esp+50h] [ebp-48h] BYREF
  _DWORD v12[4]; // [esp+60h] [ebp-38h] BYREF
  float v13[7]; // [esp+70h] [ebp-28h] BYREF
  int *v14; // [esp+8Ch] [ebp-Ch]

  v8 = sub_8135488(632);
  sub_8125A04(v8);
  result = (int)v8;
  v14 = v8;
  if ( v8 )
  {
    if ( (unsigned __int8)sub_8133176(a1, v14, a3) )
    {
      sub_813350E((int)a1, v14, v13, a3, a2);
      v6 = sub_8127896((int)v14);
      sub_813338E(a1[1], (int)v14, v6, a5);
      sub_8134DC8(v13, v12);
      sub_8134DC8(a2, v11);
      if ( sub_812782E(a1 + 2) )
      {
        v7 = (_DWORD *)sub_812787E((int)(a1 + 2));
        v9 = (float *)sub_8122008(v7);
        sub_80B6998(v9, v11, v10);
        sub_813546A((int)v14, v10);
      }
      else
      {
        sub_813546A((int)v14, v11);
      }
      return sub_8135152((int)v14, v12);
    }
    else
    {
      return (*(int (__cdecl **)(int *))(*v14 + 4))(v14);
    }
  }
  return result;
}
// 8133E29: conditional instruction was optimized away because %var_C.4!=0
// 8133D9E: using guessed type float var_28[7];
// 8133D9E: using guessed type _DWORD var_38[4];
// 8133D9E: using guessed type float var_48[4];
// 8133D9E: using guessed type float var_58[4];

//----- (08133F44) --------------------------------------------------------
float *__cdecl sub_8133F44(int *a1, float *a2, float *a3, int a4)
{
  float *result; // eax
  int v5; // esi
  int v6; // esi
  _DWORD *v7; // eax
  int v8; // [esp+4h] [ebp-C4h]
  int v9; // [esp+4h] [ebp-C4h]
  int v10; // [esp+2Ch] [ebp-9Ch]
  int v11; // [esp+2Ch] [ebp-9Ch]
  int v12; // [esp+2Ch] [ebp-9Ch]
  int v13; // [esp+2Ch] [ebp-9Ch]
  int *v14; // [esp+3Ch] [ebp-8Ch]
  int v15; // [esp+40h] [ebp-88h] BYREF
  float *v16; // [esp+44h] [ebp-84h]
  _DWORD *v18; // [esp+4Ch] [ebp-7Ch]
  float v19[4]; // [esp+50h] [ebp-78h] BYREF
  float v20[4]; // [esp+60h] [ebp-68h] BYREF
  float v21[4]; // [esp+70h] [ebp-58h] BYREF
  _DWORD v22[4]; // [esp+80h] [ebp-48h] BYREF
  float v23[7]; // [esp+90h] [ebp-38h] BYREF
  int v24; // [esp+ACh] [ebp-1Ch]
  int v25; // [esp+B0h] [ebp-18h]
  int v26; // [esp+B4h] [ebp-14h]
  int v27; // [esp+B8h] [ebp-10h]
  float *v28; // [esp+BCh] [ebp-Ch]

  v14 = sub_813559E(668);
  sub_8125CB8(v14);
  result = (float *)v14;
  v28 = (float *)v14;
  if ( v14 )
  {
    if ( (unsigned __int8)sub_8133176(a1, v28, a3) )
    {
      sub_813350E((int)a1, v28, v20, a3, a2);
      v16 = (float *)a1[1];
      sub_8133120((int)v16, (int)v28, v20, a4);
      *(float *)&v10 = sub_812F170(v16 + 142);
      v5 = v10;
      *(float *)&v11 = sub_812F170(v16 + 140);
      *(float *)&v8 = sub_812F170(v16 + 138);
      sub_8134DA4(v23, v8, v11, v5);
      vectoangles(a2, (int)v21);
      sub_8134DF8(v23, v21, v23);
      *(float *)&v12 = sub_812F170(v16 + 148);
      v6 = v12;
      *(float *)&v13 = sub_812F170(v16 + 146);
      *(float *)&v9 = sub_812F170(v16 + 144);
      sub_8134DA4(v22, v9, v13, v6);
      sub_812875E(&v15, (int)(v16 + 26));
      v24 = v15;
      v27 = sub_812873E((int)(v16 + 32));
      *(float *)&v26 = sub_812F170(v16 + 152);
      *(float *)&v25 = sub_812F170(v16 + 154);
      if ( sub_812782E(a1 + 2) )
      {
        v7 = (_DWORD *)sub_812787E((int)(a1 + 2));
        v18 = sub_8122008(v7);
        sub_813557E((int)v28, v18);
      }
      else
      {
        sub_813557E((int)v28, 0);
      }
      if ( !v24 )
        sub_81350CE((int)v28, 16);
      sub_8123E30((int)v28, v19);
      sub_8135152((int)v28, v20);
      sub_813553E((int)v28, v20);
      sub_813555E((int)v28, v19);
      sub_81354B6((int)v28, v23);
      sub_81354D6((int)v28, v22);
      sub_81354A4((int)v28, v24);
      sub_81354F6((int)v28, v27);
      sub_8135508((int)v28, v26);
      sub_813551A((int)v28, v25);
      sub_813552C((int)v28, *(_DWORD *)(off_8168620 + 4));
      return sub_8127A02(v28);
    }
    else
    {
      return (float *)(*(int (__cdecl **)(float *))(*(_DWORD *)v28 + 4))(v28);
    }
  }
  return result;
}
// 8133FF5: conditional instruction was optimized away because %var_C.4!=0
// 8133F44: using guessed type float var_68[4];
// 8133F44: using guessed type float var_38[7];
// 8133F44: using guessed type float var_58[4];
// 8133F44: using guessed type _DWORD var_48[4];
// 8133F44: using guessed type float var_78[4];

//----- (0813431A) --------------------------------------------------------
void __cdecl sub_813431A(int a1, float *a2, float *a3)
{
  float v3[6]; // [esp+10h] [ebp-18h] BYREF

  sub_8132948(a1, v3, a3, a2);
  sub_8129104();
}
// 813431A: using guessed type float var_18[6];

//----- (08134368) --------------------------------------------------------
int __cdecl sub_8134368(int a1, float *a2, float *a3)
{
  int v3; // ebx
  int v4; // eax
  int v6; // eax
  int v7; // [esp+2Ch] [ebp-1Ch]
  float v8[6]; // [esp+30h] [ebp-18h] BYREF

  sub_8132948(a1, v8, a3, a2);
  v7 = *(_DWORD *)(a1 + 4);
  if ( sub_812782E((_DWORD *)(a1 + 8)) )
  {
    v3 = sub_812787E(a1 + 8) + 60;
    v4 = sub_812873E(v7 + 136);
    return sub_8128ACC(dword_89A2814, v4, v8, 0, v3);
  }
  else
  {
    v6 = sub_812873E(v7 + 136);
    return sub_8128ACC(dword_89A2814, v6, v8, a2, 0);
  }
}
// 8128ACC: using guessed type _DWORD __cdecl sub_8128ACC(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 8134368: using guessed type float var_18[6];

//----- (08134432) --------------------------------------------------------
void __cdecl sub_8134432(int a1, float *a2, float *a3)
{
  float *v3; // [esp+2Ch] [ebp-1Ch]
  float v4[6]; // [esp+30h] [ebp-18h] BYREF

  sub_8132948(a1, v4, a3, a2);
  v3 = *(float **)(a1 + 4);
  sub_812F170(v3 + 22);
  sub_812F170(v3 + 58);
  sub_812F170(v3 + 160);
  sub_812AE72();
}
// 8134432: using guessed type float var_18[6];

//----- (081344EE) --------------------------------------------------------
int __cdecl sub_81344EE(int *a1, float *a2, float *a3)
{
  int result; // eax
  int v4; // [esp+4h] [ebp-54h]
  int v5; // [esp+4h] [ebp-54h]
  int *v6; // [esp+24h] [ebp-34h]
  int v7; // [esp+28h] [ebp-30h]
  float v8[7]; // [esp+30h] [ebp-28h] BYREF
  int *v9; // [esp+4Ch] [ebp-Ch]

  v6 = sub_8135228(252);
  sub_812679A(v6);
  result = (int)v6;
  v9 = v6;
  if ( v6 )
  {
    if ( (unsigned __int8)sub_8133176(a1, v9, a3) )
    {
      sub_8132948((int)a1, v8, a3, a2);
      sub_8135152((int)v9, v8);
      v7 = a1[1];
      if ( (*(_DWORD *)(v7 + 144) & 0x2000) != 0 )
      {
        *(float *)&v4 = sub_80A8720(0.0, 1.0);
        sub_8135204((int)v9, v4);
      }
      result = *(_WORD *)(v7 + 144) & 0x8000;
      if ( *(__int16 *)(v7 + 144) < 0 )
      {
        *(float *)&v5 = sub_80A8720(0.0, 1.0);
        return sub_8135216((int)v9, v5);
      }
    }
    else
    {
      return (*(int (__cdecl **)(int *))(*v9 + 4))(v9);
    }
  }
  return result;
}
// 8134576: conditional instruction was optimized away because %var_C.4!=0
// 81344EE: using guessed type float var_28[7];

//----- (08134642) --------------------------------------------------------
int __cdecl sub_8134642(int *a1, float *a2, float *a3, int a4, int a5)
{
  int result; // eax
  int v6; // eax
  _DWORD *v7; // eax
  int *v8; // [esp+30h] [ebp-58h]
  int v9; // [esp+34h] [ebp-54h]
  float *v10; // [esp+3Ch] [ebp-4Ch]
  float v11[4]; // [esp+40h] [ebp-48h] BYREF
  float v12[4]; // [esp+50h] [ebp-38h] BYREF
  float v13[7]; // [esp+60h] [ebp-28h] BYREF
  int *v14; // [esp+7Ch] [ebp-Ch]

  v8 = sub_8135412(600);
  sub_81249E6(v8);
  result = (int)v8;
  v14 = v8;
  if ( v8 )
  {
    if ( (unsigned __int8)sub_8133176(a1, v14, a3) )
    {
      sub_813350E((int)a1, v14, v13, a3, a2);
      v9 = a1[1];
      v6 = sub_8127896((int)v14);
      sub_813338E(v9, (int)v14, v6, a5);
      sub_8133120(v9, (int)v14, v13, a4);
      sub_8134DC8(a2, v12);
      if ( sub_812782E(a1 + 2) )
      {
        v7 = (_DWORD *)sub_812787E((int)(a1 + 2));
        v10 = (float *)sub_8122008(v7);
        sub_80B6998(v10, v12, v11);
        sub_81353F2((int)v14, v11);
      }
      else
      {
        sub_81353F2((int)v14, v12);
      }
      return sub_8135152((int)v14, v13);
    }
    else
    {
      return (*(int (__cdecl **)(int *))(*v14 + 4))(v14);
    }
  }
  return result;
}
// 81346CD: conditional instruction was optimized away because %var_C.4!=0
// 8134642: using guessed type float var_28[7];
// 8134642: using guessed type float var_38[4];
// 8134642: using guessed type float var_48[4];

//----- (081347FC) --------------------------------------------------------
int __cdecl sub_81347FC(int *a1, int a2, float *a3)
{
  int result; // eax
  int v4; // [esp+4h] [ebp-34h]
  int *v5; // [esp+20h] [ebp-18h]
  int v6; // [esp+24h] [ebp-14h] BYREF
  int v7; // [esp+28h] [ebp-10h]
  int v9; // [esp+30h] [ebp-8h]
  int *v10; // [esp+34h] [ebp-4h]

  v5 = sub_8135228(252);
  sub_8135244(v5);
  result = (int)v5;
  v10 = v5;
  if ( v5 )
  {
    if ( (unsigned __int8)sub_8133176(a1, v10, a3) )
    {
      v7 = a1[1];
      sub_812875E(&v6, v7 + 104);
      v9 = v6;
      sub_8135152((int)v10, a3);
      sub_8135260((int)v10, v9);
      if ( (*(_DWORD *)(v7 + 144) & 0x2000) != 0 )
      {
        *(float *)&v4 = sub_80A8720(0.0, 1.0);
        sub_8135204((int)v10, v4);
      }
      sub_8133348((int)v10);
      return sub_8126C40((int)v10);
    }
    else
    {
      return (*(int (__cdecl **)(int *))(*v10 + 4))(v10);
    }
  }
  return result;
}
// 8134884: conditional instruction was optimized away because %var_4.4!=0

//----- (0813493C) --------------------------------------------------------
int __cdecl sub_813493C(int *a1, float *a2, float *a3, int a4, int a5)
{
  int result; // eax
  int v6; // eax
  float *v7; // ebx
  int *v8; // [esp+34h] [ebp-34h]
  int v9; // [esp+38h] [ebp-30h]
  float v10[7]; // [esp+40h] [ebp-28h] BYREF
  int *v11; // [esp+5Ch] [ebp-Ch]

  v8 = sub_813539A(636);
  sub_8124CB6(v8);
  result = (int)v8;
  v11 = v8;
  if ( v8 )
  {
    if ( (unsigned __int8)sub_8133176(a1, v11, a3) )
    {
      sub_813350E((int)a1, v11, v10, a3, a2);
      v9 = a1[1];
      v6 = sub_8127896((int)v11);
      sub_813338E(v9, (int)v11, v6, a5);
      sub_8133120(v9, (int)v11, v10, a4);
      sub_8135152((int)v11, v10);
      v7 = (float *)v11;
      v7[152] = sub_80A8720(0.0, 1.0);
      result = *(unsigned __int8 *)(v9 + 157);
      *((_BYTE *)v11 + 604) = result;
    }
    else
    {
      return (*(int (__cdecl **)(int *))(*v11 + 4))(v11);
    }
  }
  return result;
}
// 81349C5: conditional instruction was optimized away because %var_C.4!=0
// 813493C: using guessed type float var_28[7];

//----- (08134AAE) --------------------------------------------------------
int sub_8134AAE()
{
  int result; // eax
  int v1; // [esp+20h] [ebp-48h]
  int v2; // [esp+24h] [ebp-44h]
  int *v3; // [esp+28h] [ebp-40h]
  int i; // [esp+2Ch] [ebp-3Ch]
  float v5[3]; // [esp+30h] [ebp-38h] BYREF
  int v6[11]; // [esp+3Ch] [ebp-2Ch] BYREF

  result = dword_89A2C80;
  if ( *(_BYTE *)(dword_89A2C80 + 8) )
  {
    v3 = (int *)((char *)dword_89A2814 + 4);
    result = *((_DWORD *)dword_89A2814 + 1);
    for ( i = result; i; i = *v3 )
    {
      if ( *(_DWORD *)(i + 8) <= *(_DWORD *)(off_8168620 + 4) )
      {
        v2 = *(_DWORD *)i;
        v1 = *(_DWORD *)(*(_DWORD *)i + 4 * *(_DWORD *)(i + 4) + 8);
        sub_80A8712(*(_DWORD *)(i + 68));
        *v3 = *(_DWORD *)(i + 76);
        --*((_DWORD *)dword_89A2814 + 2);
        if ( *(int *)(i + 12) < 0 )
        {
          sub_8129488(
            (int)dword_89A2814,
            v2,
            v1,
            (int *)(i + 12),
            (float *)(i + 20),
            (_DWORD *)(i + 32),
            *(_DWORD *)(off_8168620 + 4) - *(_DWORD *)(i + 8),
            *(_DWORD *)(i + 72));
        }
        else if ( (unsigned __int8)FX_GetBoneOrientation() )
        {
          sub_8129488(
            (int)dword_89A2814,
            v2,
            v1,
            (int *)(i + 12),
            v5,
            v6,
            *(_DWORD *)(off_8168620 + 4) - *(_DWORD *)(i + 8),
            *(_DWORD *)(i + 72));
        }
        sub_8129BF4((char *)i);
      }
      else
      {
        v3 = (int *)(i + 76);
      }
      result = *v3;
    }
  }
  return result;
}
// 89A2C80: using guessed type int dword_89A2C80;
// 8134AAE: using guessed type float var_38[3];
// 8134AAE: using guessed type int anonymous_0[11];

//----- (08134C2A) --------------------------------------------------------
int sub_8134C2A()
{
  int result; // eax

  result = dword_89A2C80;
  if ( *(_BYTE *)(dword_89A2C80 + 8) )
  {
    dword_89B63C8 = 0;
    dword_89B9D20 = 0;
    sub_81326C8(0);
    return sub_813277E();
  }
  return result;
}
// 89A2C80: using guessed type int dword_89A2C80;
// 89B63C8: using guessed type int dword_89B63C8;

//----- (08134C64) --------------------------------------------------------
int sub_8134C64()
{
  int result; // eax

  result = dword_89A2C80;
  if ( *(_BYTE *)(dword_89A2C80 + 8) )
  {
    dword_89B63C4 = 0;
    dword_89BD580 = 0;
    sub_8132566(0);
    return sub_813261C();
  }
  return result;
}
// 89A2C80: using guessed type int dword_89A2C80;
// 89B63C4: using guessed type int dword_89B63C4;
// 89BD580: using guessed type int dword_89BD580;

//----- (08134C9E) --------------------------------------------------------
void sub_8134C9E()
{
  int v0; // [esp+4h] [ebp-4h]
  int v1; // [esp+4h] [ebp-4h]

  if ( *(_BYTE *)(dword_89A2C80 + 8) )
  {
    sub_81319C4();
    sub_8131926();
    sub_8134AAE();
    v0 = dword_89B63B0;
    dword_89B63B0 = dword_89B63A4;
    sub_81326C8(v0);
    sub_81319C4();
    v1 = dword_89B63AC;
    dword_89B63AC = dword_89B63A0;
    sub_8132566(v1);
    sub_8131926();
    sub_8132838();
  }
}
// 89A2C80: using guessed type int dword_89A2C80;
// 89B63A0: using guessed type int dword_89B63A0;
// 89B63A4: using guessed type int dword_89B63A4;
// 89B63AC: using guessed type int dword_89B63AC;
// 89B63B0: using guessed type int dword_89B63B0;

//----- (08134D0C) --------------------------------------------------------
int *__cdecl sub_8134D0C(int a1, int a2)
{
  int *result; // eax
  int i; // [esp+Ch] [ebp-Ch] BYREF
  _DWORD *v4; // [esp+10h] [ebp-8h]
  void *v5; // [esp+14h] [ebp-4h]

  if ( a2 == 0xFFFF && a1 == 1 )
  {
    v5 = &unk_89B63E0;
    v4 = &unk_89B63E0;
    for ( i = 0; i != -1; --i )
    {
      sub_812A642(v4);
      v4 += 63;
      result = &i;
    }
  }
  return result;
}

//----- (08134D5C) --------------------------------------------------------
long double __cdecl sub_8134D5C(float a1)
{
  return (float)fabs(a1);
}

//----- (08134D76) --------------------------------------------------------
void __cdecl sub_8134D76(float a1, float *a2, float *a3)
{
  *a2 = sin(a1);
  *a3 = cos(a1);
}

//----- (08134DA4) --------------------------------------------------------
int __cdecl sub_8134DA4(_DWORD *a1, int a2, int a3, int a4)
{
  int result; // eax

  *a1 = a2;
  a1[1] = a3;
  result = a4;
  a1[2] = a4;
  return result;
}

//----- (08134DC8) --------------------------------------------------------
int __cdecl sub_8134DC8(_DWORD *a1, _DWORD *a2)
{
  int result; // eax

  *a2 = *a1;
  a2[1] = a1[1];
  result = a1[2];
  a2[2] = result;
  return result;
}

//----- (08134DF8) --------------------------------------------------------
float *__cdecl sub_8134DF8(float *a1, float *a2, float *a3)
{
  float *result; // eax

  *a3 = *a1 + *a2;
  a3[1] = a1[1] + a2[1];
  result = a1 + 2;
  a3[2] = a1[2] + a2[2];
  return result;
}

//----- (08134E3C) --------------------------------------------------------
float *__cdecl sub_8134E3C(float *a1, float *a2, float *a3)
{
  float *result; // eax

  *a3 = *a1 - *a2;
  a3[1] = a1[1] - a2[1];
  result = a1 + 2;
  a3[2] = a1[2] - a2[2];
  return result;
}

//----- (08134E80) --------------------------------------------------------
float *__cdecl sub_8134E80(float *a1, float a2, float *a3)
{
  float *result; // eax

  *a3 = a2 * *a1;
  a3[1] = a2 * a1[1];
  result = a1 + 2;
  a3[2] = a2 * a1[2];
  return result;
}

//----- (08134EB8) --------------------------------------------------------
float *__cdecl sub_8134EB8(float *a1, float a2, float *a3, float *a4)
{
  float *result; // eax

  *a4 = a2 * *a3 + *a1;
  a4[1] = a2 * a3[1] + a1[1];
  result = a3 + 2;
  a4[2] = a2 * a3[2] + a1[2];
  return result;
}

//----- (08134F0C) --------------------------------------------------------
long double __cdecl sub_8134F0C(float *a1, float *a2)
{
  return *a1 * *a2 + a1[1] * a2[1] + a1[2] * a2[2];
}

//----- (08134F40) --------------------------------------------------------
void __cdecl sub_8134F40(float *a1)
{
  float v1; // [esp+0h] [ebp-8h]

  v1 = *a1 * *a1 + a1[1] * a1[1] + a1[2] * a1[2];
  sub_813503A(v1);
}

//----- (08134F7E) --------------------------------------------------------
int __cdecl sub_8134F7E(int a1, int a2)
{
  int result; // eax
  int v3; // [esp+0h] [ebp-8h]

  v3 = *((_DWORD *)off_8168618 + a1);
  *((_DWORD *)off_8168618 + a1) = *((_DWORD *)off_8168618 + a2);
  result = v3;
  *((_DWORD *)off_8168618 + a2) = v3;
  return result;
}
// 8168618: using guessed type void *off_8168618;

//----- (08134FDC) --------------------------------------------------------
int __cdecl sub_8134FDC(int a1, int a2)
{
  int result; // eax
  int v3; // [esp+0h] [ebp-8h]

  v3 = *((_DWORD *)off_816861C + a1);
  *((_DWORD *)off_816861C + a1) = *((_DWORD *)off_816861C + a2);
  result = v3;
  *((_DWORD *)off_816861C + a2) = v3;
  return result;
}
// 816861C: using guessed type void *off_816861C;

//----- (0813503A) --------------------------------------------------------
long double __cdecl sub_813503A(float a1)
{
  return (float)sqrt(a1);
}

//----- (0813505A) --------------------------------------------------------
int __cdecl sub_813505A(_DWORD *a1)
{
  int result; // eax

  *a1 = 0;
  a1[1] = 0;
  result = 0;
  a1[2] = 0;
  return result;
}

//----- (08135084) --------------------------------------------------------
int __cdecl sub_8135084(_DWORD *a1, _DWORD *a2)
{
  if ( a1 )
    return sub_8134DC8(a1, a2);
  else
    return sub_813505A(a2);
}

//----- (081350B2) --------------------------------------------------------
int *ctor_003()
{
  return sub_8134D0C(1, 0xFFFF);
}

//----- (081350CE) --------------------------------------------------------
int __cdecl sub_81350CE(int a1, int a2)
{
  int result; // eax

  result = *(_DWORD *)(a1 + 168) & ~a2;
  *(_DWORD *)(a1 + 168) = result;
  return result;
}

//----- (081350EA) --------------------------------------------------------
int __cdecl sub_81350EA(int a1, _DWORD *a2)
{
  if ( a2 )
    return sub_8134DC8(a2, (_DWORD *)(a1 + 20));
  else
    return sub_813505A((_DWORD *)(a1 + 20));
}

//----- (0813511E) --------------------------------------------------------
int __cdecl sub_813511E(int a1, _DWORD *a2)
{
  if ( a2 )
    return sub_8134DC8(a2, (_DWORD *)(a1 + 32));
  else
    return sub_813505A((_DWORD *)(a1 + 32));
}

//----- (08135152) --------------------------------------------------------
int __cdecl sub_8135152(int a1, _DWORD *a2)
{
  if ( a2 )
    return sub_8134DC8(a2, (_DWORD *)(a1 + 4));
  else
    return sub_813505A((_DWORD *)(a1 + 4));
}

//----- (08135186) --------------------------------------------------------
int __cdecl sub_8135186(int a1, int a2)
{
  int result; // eax

  result = a2;
  *(_DWORD *)(a1 + 168) = a2;
  return result;
}

//----- (08135198) --------------------------------------------------------
int __cdecl sub_8135198(int a1, int a2)
{
  int result; // eax

  result = a2;
  *(_DWORD *)(a1 + 16) = a2;
  return result;
}

//----- (081351A6) --------------------------------------------------------
int __cdecl sub_81351A6(int a1, int a2)
{
  int result; // eax

  result = a2;
  *(_DWORD *)(a1 + 44) = a2;
  return result;
}

//----- (081351B4) --------------------------------------------------------
int __cdecl sub_81351B4(int a1, int a2)
{
  int result; // eax

  result = a2;
  *(_DWORD *)(a1 + 48) = a2;
  return result;
}

//----- (081351C2) --------------------------------------------------------
int __cdecl sub_81351C2(int a1, int a2)
{
  int result; // eax

  result = a2;
  *(_DWORD *)(a1 + 52) = a2;
  return result;
}

//----- (081351D0) --------------------------------------------------------
int __cdecl sub_81351D0(int a1, int a2)
{
  int result; // eax

  result = a2;
  *(_DWORD *)(a1 + 56) = a2;
  return result;
}

//----- (081351DE) --------------------------------------------------------
int __cdecl sub_81351DE(int a1)
{
  return *(_DWORD *)(a1 + 184);
}

//----- (081351EC) --------------------------------------------------------
int __cdecl sub_81351EC(int a1)
{
  return *(_DWORD *)(a1 + 52);
}

//----- (081351F8) --------------------------------------------------------
int __cdecl sub_81351F8(int a1)
{
  return *(_DWORD *)(a1 + 56);
}

//----- (08135204) --------------------------------------------------------
int __cdecl sub_8135204(int a1, int a2)
{
  int result; // eax

  result = a2;
  *(_DWORD *)(a1 + 196) = a2;
  return result;
}

//----- (08135216) --------------------------------------------------------
int __cdecl sub_8135216(int a1, int a2)
{
  int result; // eax

  result = a2;
  *(_DWORD *)(a1 + 200) = a2;
  return result;
}

//----- (08135228) --------------------------------------------------------
int *__cdecl sub_8135228(int a1)
{
  return sub_81355F0((int *)&unk_89A239C, a1);
}

//----- (08135244) --------------------------------------------------------
_DWORD *__cdecl sub_8135244(_DWORD *a1)
{
  _DWORD *result; // eax

  sub_812677E(a1);
  result = a1;
  *a1 = off_8158268;
  return result;
}
// 8158268: using guessed type int (__cdecl *off_8158268[2])(int);

//----- (08135260) --------------------------------------------------------
int __cdecl sub_8135260(int a1, int a2)
{
  int result; // eax

  result = a2;
  *(_DWORD *)(a1 + 64) = a2;
  return result;
}

//----- (0813526E) --------------------------------------------------------
int __cdecl sub_813526E(int a1, int a2)
{
  int result; // eax

  result = a2;
  *(_DWORD *)(a1 + 64) = a2;
  return result;
}

//----- (0813527C) --------------------------------------------------------
int __cdecl sub_813527C(int a1, int a2)
{
  int result; // eax

  result = a2;
  *(_DWORD *)(a1 + 244) = a2;
  return result;
}

//----- (0813528E) --------------------------------------------------------
int __cdecl sub_813528E(int a1, int a2)
{
  int result; // eax

  result = a2;
  *(_DWORD *)(a1 + 68) = a2;
  return result;
}

//----- (0813529C) --------------------------------------------------------
int __cdecl sub_813529C(int a1, int a2)
{
  int result; // eax

  result = a2;
  *(_DWORD *)(a1 + 256) = a2;
  return result;
}

//----- (081352AE) --------------------------------------------------------
int __cdecl sub_81352AE(int a1, unsigned __int8 a2)
{
  int result; // eax

  result = a2;
  *(_BYTE *)(a1 + 260) = a2;
  return result;
}

//----- (081352CA) --------------------------------------------------------
int __cdecl sub_81352CA(int a1, int a2)
{
  int result; // eax

  result = a2;
  *(_DWORD *)(a1 + 264) = a2;
  return result;
}

//----- (081352DC) --------------------------------------------------------
int __cdecl sub_81352DC(int a1, int a2)
{
  int result; // eax

  result = a2;
  *(_DWORD *)(a1 + 268) = a2;
  return result;
}

//----- (081352EE) --------------------------------------------------------
int __cdecl sub_81352EE(int a1, int a2)
{
  int result; // eax

  result = a2;
  *(_DWORD *)(a1 + 272) = a2;
  return result;
}

//----- (08135300) --------------------------------------------------------
int __cdecl sub_8135300(int a1, int a2)
{
  int result; // eax

  result = a2;
  *(_DWORD *)(a1 + 276) = a2;
  return result;
}

//----- (08135312) --------------------------------------------------------
int __cdecl sub_8135312(int a1, int a2)
{
  int result; // eax

  result = a2;
  *(_DWORD *)(a1 + 280) = a2;
  return result;
}

//----- (08135324) --------------------------------------------------------
int __cdecl sub_8135324(int a1, int a2)
{
  int result; // eax

  result = a2;
  *(_DWORD *)(a1 + 284) = a2;
  return result;
}

//----- (08135336) --------------------------------------------------------
int __cdecl sub_8135336(int a1, int a2)
{
  int result; // eax

  result = a2;
  *(_DWORD *)(a1 + 288) = a2;
  return result;
}

//----- (08135348) --------------------------------------------------------
int __cdecl sub_8135348(int a1, int a2)
{
  int result; // eax

  result = a2;
  *(_DWORD *)(a1 + 292) = a2;
  return result;
}

//----- (0813535A) --------------------------------------------------------
int __cdecl sub_813535A(int a1, int a2)
{
  int result; // eax

  result = a2;
  *(_DWORD *)(a1 + 296) = a2;
  return result;
}

//----- (0813536C) --------------------------------------------------------
int __cdecl sub_813536C(int a1, int a2)
{
  int result; // eax

  result = a2;
  *(_DWORD *)(a1 + 248) = a2;
  return result;
}

//----- (0813537E) --------------------------------------------------------
int *__cdecl sub_813537E(int a1)
{
  return sub_81356CE((int *)&unk_89A23A4, a1);
}

//----- (0813539A) --------------------------------------------------------
int *__cdecl sub_813539A(int a1)
{
  return sub_81357AC(dword_89A23D4, a1);
}
// 89A23D4: using guessed type int dword_89A23D4[3];

//----- (081353B6) --------------------------------------------------------
int __cdecl sub_81353B6(int a1, _DWORD *a2)
{
  return sub_8134DC8(a2, (_DWORD *)(a1 + 588));
}

//----- (081353D6) --------------------------------------------------------
int *__cdecl sub_81353D6(int a1)
{
  return sub_813588A((int *)&unk_89A23AC, a1);
}

//----- (081353F2) --------------------------------------------------------
int __cdecl sub_81353F2(int a1, _DWORD *a2)
{
  return sub_8134DC8(a2, (_DWORD *)(a1 + 588));
}

//----- (08135412) --------------------------------------------------------
int *__cdecl sub_8135412(int a1)
{
  return sub_8135968((int *)&unk_89A23B4, a1);
}

//----- (0813542E) --------------------------------------------------------
int __cdecl sub_813542E(int a1, _DWORD *a2)
{
  return sub_8134DC8(a2, (_DWORD *)(a1 + 588));
}

//----- (0813544E) --------------------------------------------------------
int *__cdecl sub_813544E(int a1)
{
  return sub_8135A46((int *)&unk_89A23BC, a1);
}

//----- (0813546A) --------------------------------------------------------
int __cdecl sub_813546A(int a1, _DWORD *a2)
{
  return sub_8134DC8(a2, (_DWORD *)(a1 + 72));
}

//----- (08135488) --------------------------------------------------------
int *__cdecl sub_8135488(int a1)
{
  return sub_8135B24((int *)&unk_89A23C4, a1);
}

//----- (081354A4) --------------------------------------------------------
int __cdecl sub_81354A4(int a1, int a2)
{
  int result; // eax

  result = a2;
  *(_DWORD *)(a1 + 180) = a2;
  return result;
}

//----- (081354B6) --------------------------------------------------------
int __cdecl sub_81354B6(int a1, _DWORD *a2)
{
  return sub_8135084(a2, (_DWORD *)(a1 + 632));
}

//----- (081354D6) --------------------------------------------------------
int __cdecl sub_81354D6(int a1, _DWORD *a2)
{
  return sub_8135084(a2, (_DWORD *)(a1 + 644));
}

//----- (081354F6) --------------------------------------------------------
int __cdecl sub_81354F6(int a1, int a2)
{
  int result; // eax

  result = a2;
  *(_DWORD *)(a1 + 656) = a2;
  return result;
}

//----- (08135508) --------------------------------------------------------
int __cdecl sub_8135508(int a1, int a2)
{
  int result; // eax

  result = a2;
  *(_DWORD *)(a1 + 660) = a2;
  return result;
}

//----- (0813551A) --------------------------------------------------------
int __cdecl sub_813551A(int a1, int a2)
{
  int result; // eax

  result = a2;
  *(_DWORD *)(a1 + 664) = a2;
  return result;
}

//----- (0813552C) --------------------------------------------------------
int __cdecl sub_813552C(int a1, int a2)
{
  int result; // eax

  result = a2;
  *(_DWORD *)(a1 + 624) = a2;
  return result;
}

//----- (0813553E) --------------------------------------------------------
int __cdecl sub_813553E(int a1, _DWORD *a2)
{
  return sub_8135084(a2, (_DWORD *)(a1 + 588));
}

//----- (0813555E) --------------------------------------------------------
int __cdecl sub_813555E(int a1, _DWORD *a2)
{
  return sub_8135084(a2, (_DWORD *)(a1 + 600));
}

//----- (0813557E) --------------------------------------------------------
int __cdecl sub_813557E(int a1, _DWORD *a2)
{
  return sub_8135084(a2, (_DWORD *)(a1 + 612));
}

//----- (0813559E) --------------------------------------------------------
int *__cdecl sub_813559E(int a1)
{
  return sub_8135C02((int *)&unk_89A23CC, a1);
}

//----- (081355BA) --------------------------------------------------------
int __cdecl sub_81355BA(int a1)
{
  return *(_DWORD *)(*(_DWORD *)a1 + 8);
}

//----- (081355C8) --------------------------------------------------------
void *sub_81355C8()
{
  return Z_MallocInternal(0xCu);
}

//----- (081355DC) --------------------------------------------------------
void __cdecl sub_81355DC(void *ptr)
{
  Z_FreeInternal(ptr);
}

//----- (081355F0) --------------------------------------------------------
int *__cdecl sub_81355F0(int *a1, int a2)
{
  int *i; // [esp+10h] [ebp-8h]
  int *s; // [esp+14h] [ebp-4h]

  for ( i = (int *)a1[1]; i; i = (int *)i[8190] )
  {
    if ( i[8189] )
    {
      if ( i != (int *)a1[1] )
        sub_81284F6((int)a1, (int)i);
      break;
    }
  }
  if ( i )
    goto LABEL_11;
  i = sub_8121C8A(a1[1], *a1, a2);
  if ( i )
  {
    a1[1] = (int)i;
LABEL_11:
    s = (int *)i[8189];
    i[8189] = *s;
    --i[8188];
    Com_Memset(s, 0, 0xFCu);
    return s;
  }
  return 0;
}

//----- (081356CE) --------------------------------------------------------
int *__cdecl sub_81356CE(int *a1, int a2)
{
  int *i; // [esp+10h] [ebp-8h]
  int *s; // [esp+14h] [ebp-4h]

  for ( i = (int *)a1[1]; i; i = (int *)i[8190] )
  {
    if ( i[8189] )
    {
      if ( i != (int *)a1[1] )
        sub_812853E((int)a1, (int)i);
      break;
    }
  }
  if ( i )
    goto LABEL_11;
  i = sub_8121C8A(a1[1], *a1, a2);
  if ( i )
  {
    a1[1] = (int)i;
LABEL_11:
    s = (int *)i[8189];
    i[8189] = *s;
    --i[8188];
    Com_Memset(s, 0, 0x24Cu);
    return s;
  }
  return 0;
}

//----- (081357AC) --------------------------------------------------------
int *__cdecl sub_81357AC(int *a1, int a2)
{
  int *i; // [esp+10h] [ebp-8h]
  int *s; // [esp+14h] [ebp-4h]

  for ( i = (int *)a1[1]; i; i = (int *)i[8190] )
  {
    if ( i[8189] )
    {
      if ( i != (int *)a1[1] )
        sub_8128586((int)a1, (int)i);
      break;
    }
  }
  if ( i )
    goto LABEL_11;
  i = sub_8121C8A(a1[1], *a1, a2);
  if ( i )
  {
    a1[1] = (int)i;
LABEL_11:
    s = (int *)i[8189];
    i[8189] = *s;
    --i[8188];
    Com_Memset(s, 0, 0x27Cu);
    return s;
  }
  return 0;
}

//----- (0813588A) --------------------------------------------------------
int *__cdecl sub_813588A(int *a1, int a2)
{
  int *i; // [esp+10h] [ebp-8h]
  int *s; // [esp+14h] [ebp-4h]

  for ( i = (int *)a1[1]; i; i = (int *)i[8190] )
  {
    if ( i[8189] )
    {
      if ( i != (int *)a1[1] )
        sub_81285CE((int)a1, (int)i);
      break;
    }
  }
  if ( i )
    goto LABEL_11;
  i = sub_8121C8A(a1[1], *a1, a2);
  if ( i )
  {
    a1[1] = (int)i;
LABEL_11:
    s = (int *)i[8189];
    i[8189] = *s;
    --i[8188];
    Com_Memset(s, 0, 0x258u);
    return s;
  }
  return 0;
}

//----- (08135968) --------------------------------------------------------
int *__cdecl sub_8135968(int *a1, int a2)
{
  int *i; // [esp+10h] [ebp-8h]
  int *s; // [esp+14h] [ebp-4h]

  for ( i = (int *)a1[1]; i; i = (int *)i[8190] )
  {
    if ( i[8189] )
    {
      if ( i != (int *)a1[1] )
        sub_8128616((int)a1, (int)i);
      break;
    }
  }
  if ( i )
    goto LABEL_11;
  i = sub_8121C8A(a1[1], *a1, a2);
  if ( i )
  {
    a1[1] = (int)i;
LABEL_11:
    s = (int *)i[8189];
    i[8189] = *s;
    --i[8188];
    Com_Memset(s, 0, 0x258u);
    return s;
  }
  return 0;
}

//----- (08135A46) --------------------------------------------------------
int *__cdecl sub_8135A46(int *a1, int a2)
{
  int *i; // [esp+10h] [ebp-8h]
  int *s; // [esp+14h] [ebp-4h]

  for ( i = (int *)a1[1]; i; i = (int *)i[8190] )
  {
    if ( i[8189] )
    {
      if ( i != (int *)a1[1] )
        sub_812865E((int)a1, (int)i);
      break;
    }
  }
  if ( i )
    goto LABEL_11;
  i = sub_8121C8A(a1[1], *a1, a2);
  if ( i )
  {
    a1[1] = (int)i;
LABEL_11:
    s = (int *)i[8189];
    i[8189] = *s;
    --i[8188];
    Com_Memset(s, 0, 0x278u);
    return s;
  }
  return 0;
}

//----- (08135B24) --------------------------------------------------------
int *__cdecl sub_8135B24(int *a1, int a2)
{
  int *i; // [esp+10h] [ebp-8h]
  int *s; // [esp+14h] [ebp-4h]

  for ( i = (int *)a1[1]; i; i = (int *)i[8190] )
  {
    if ( i[8189] )
    {
      if ( i != (int *)a1[1] )
        sub_81286A6((int)a1, (int)i);
      break;
    }
  }
  if ( i )
    goto LABEL_11;
  i = sub_8121C8A(a1[1], *a1, a2);
  if ( i )
  {
    a1[1] = (int)i;
LABEL_11:
    s = (int *)i[8189];
    i[8189] = *s;
    --i[8188];
    Com_Memset(s, 0, 0x278u);
    return s;
  }
  return 0;
}

//----- (08135C02) --------------------------------------------------------
int *__cdecl sub_8135C02(int *a1, int a2)
{
  int *i; // [esp+10h] [ebp-8h]
  int *s; // [esp+14h] [ebp-4h]

  for ( i = (int *)a1[1]; i; i = (int *)i[8190] )
  {
    if ( i[8189] )
    {
      if ( i != (int *)a1[1] )
        sub_81286EE((int)a1, (int)i);
      break;
    }
  }
  if ( i )
    goto LABEL_11;
  i = sub_8121C8A(a1[1], *a1, a2);
  if ( i )
  {
    a1[1] = (int)i;
LABEL_11:
    s = (int *)i[8189];
    i[8189] = *s;
    --i[8188];
    Com_Memset(s, 0, 0x29Cu);
    return s;
  }
  return 0;
}

//----- (08135CE0) --------------------------------------------------------
unsigned int Language_UpdateCurrentAsian()
{
  unsigned int result; // eax

  result = *(_DWORD *)(loc_language + 8) - 8;
  g_currentAsian = result <= 4;
  return result;
}
// 8523140: using guessed type int loc_language;
// 89BD5A0: using guessed type int g_currentAsian;

//----- (08135D0C) --------------------------------------------------------
int sub_8135D0C()
{
  return *(_DWORD *)(loc_language + 8);
}
// 8523140: using guessed type int loc_language;

//----- (08135D1A) --------------------------------------------------------
unsigned int __usercall SEH_InitLanguage@<eax>(long double a1@<st0>)
{
  loc_language = (int)Dvar_RegisterInt(a1, "loc_language", 0, 0, 13, 4129);
  loc_forceEnglish = (int)Dvar_RegisterBool(a1, "loc_forceEnglish", 0, 4129);
  loc_translate = (int)Dvar_RegisterBool(a1, "loc_translate", 1, 4128);
  loc_warnings = (int)Dvar_RegisterBool(a1, "loc_warnings", 0, 4096);
  loc_warningsAsErrors = (int)Dvar_RegisterBool(a1, "loc_warningsAsErrors", 0, 4096);
  return Language_UpdateCurrentAsian();
}
// 8523140: using guessed type int loc_language;
// 8523144: using guessed type int loc_forceEnglish;
// 8523148: using guessed type int loc_translate;
// 852314C: using guessed type int loc_warnings;
// 8523150: using guessed type int loc_warningsAsErrors;

//----- (08135DDC) --------------------------------------------------------
int __usercall SEH_UpdateLanguageInfo@<eax>(long double a1@<st0>)
{
  int result; // eax
  int v2; // [esp+20h] [ebp-8h]
  int i; // [esp+24h] [ebp-4h]
  signed int j; // [esp+24h] [ebp-4h]

  Dvar_RegisterInt(a1, *(char **)loc_language, 0, 0, 13, 4129);
  Dvar_RegisterBool(a1, *(char **)loc_forceEnglish, 0, 4129);
  Language_UpdateCurrentAsian();
  v2 = 0;
  for ( i = 0; i <= 13; ++i )
  {
    if ( FS_LanguageHasAssets(i) )
    {
      g_languages[2 * i] = 1;
      ++v2;
    }
    else
    {
      g_languages[2 * i] = 0;
    }
  }
  if ( v2 <= 0 )
    Com_Printf("^1ERROR: No languages available because no localized assets were found\n");
  result = SEH_StringEd_SetLanguageStrings(*(_DWORD *)(loc_language + 8));
  if ( !result )
  {
    for ( j = 0; j <= 13; ++j )
    {
      Dvar_SetInt(loc_language, (char *)j);
      Language_UpdateCurrentAsian();
      result = SEH_StringEd_SetLanguageStrings(j);
      if ( result )
        return result;
    }
    Dvar_SetInt(loc_language, 0);
    return Language_UpdateCurrentAsian();
  }
  return result;
}
// 8168644: using guessed type int g_languages[];
// 8523140: using guessed type int loc_language;
// 8523144: using guessed type int loc_forceEnglish;

//----- (08135FAE) --------------------------------------------------------
int sub_8135FAE()
{
  return sub_8138336();
}

//----- (08135FBC) --------------------------------------------------------
void sub_8135FBC()
{
  sub_813839E();
}

//----- (08135FCA) --------------------------------------------------------
int __cdecl SEH_StringEd_SetLanguageStrings(unsigned int a1)
{
  char *v1; // eax
  char *v2; // eax
  char *v5; // [esp+14h] [ebp-4h]

  if ( !g_languages[2 * a1] )
    return 0;
  v5 = sub_81383EC(*(_BYTE *)(loc_forceEnglish + 8));
  if ( !v5 )
    return 1;
  if ( !*(_BYTE *)(fs_ignoreLocalized + 8) && *(_BYTE *)(loc_warnings + 8) )
  {
    if ( *(_BYTE *)(loc_warningsAsErrors + 8) )
    {
      v1 = sub_8136D72(a1);
      Com_Error(6, "Could not load localization strings for %s: %s", v1, v5);
    }
    v2 = sub_8136D72(a1);
    Com_Printf("^3WARNING: Could not load localization strings for %s: %s\n", v2, v5);
  }
  return 0;
}
// 8168644: using guessed type int g_languages[];
// 848B7E4: using guessed type int fs_ignoreLocalized;
// 8523144: using guessed type int loc_forceEnglish;
// 852314C: using guessed type int loc_warnings;
// 8523150: using guessed type int loc_warningsAsErrors;

//----- (0813608C) --------------------------------------------------------
int __cdecl sub_813608C(_BYTE *a1)
{
  if ( !loc_translate || !*(_BYTE *)(loc_translate + 8) )
    return (int)a1;
  if ( *a1 && a1[1] )
    return sub_813821E((int)a1);
  return (int)a1;
}
// 8523148: using guessed type int loc_translate;

//----- (081360E2) --------------------------------------------------------
char *__cdecl sub_81360E2(char *src)
{
  int v2; // [esp+14h] [ebp-4h]

  v2 = sub_813608C(src);
  if ( !v2 )
  {
    if ( *(_BYTE *)(loc_warnings + 8) )
    {
      if ( *(_BYTE *)(loc_warningsAsErrors + 8) )
        Com_Error(6, "Could not translate exe string \"%s\"", src);
      Com_Printf("^3WARNING: Could not translate exe string \"%s\"\n", src);
      strcpy(byte_89BD5C0, "^1UNLOCALIZED(^7");
      I_strncat(byte_89BD5C0, 1024, src);
      I_strncat(byte_89BD5C0, 1024, "^1)^7");
    }
    else
    {
      I_strncpyz(byte_89BD5C0, src, 1024);
    }
    return byte_89BD5C0;
  }
  return (char *)v2;
}
// 852314C: using guessed type int loc_warnings;
// 8523150: using guessed type int loc_warningsAsErrors;

//----- (081361BE) --------------------------------------------------------
int __cdecl sub_81361BE(char *dest, _BYTE *a2, const char *a3, int a4)
{
  const char *src; // [esp+14h] [ebp-4h]

  src = (const char *)sub_813608C(a2);
  if ( src )
    goto LABEL_12;
  if ( loc_warnings && *(_BYTE *)(loc_warnings + 8) )
  {
    if ( loc_warningsAsErrors && *(_BYTE *)(loc_warningsAsErrors + 8) && a4 != 1 )
      Com_Error(6, "Could not translate part of %s: \"%s\"", a3, a2);
    Com_Printf("^3WARNING: Could not translate part of %s: \"%s\"\n", a3, a2);
    src = va("^1UNLOCALIZED(^7%s^1)^7", a2);
  }
  else
  {
    src = va("%s", a2);
  }
  if ( a4 == 1 )
    return 0;
LABEL_12:
  strcpy(dest, src);
  return 1;
}
// 852314C: using guessed type int loc_warnings;
// 8523150: using guessed type int loc_warningsAsErrors;
// 81361BE: using guessed type _BYTE *arg_4;
// 81361BE: using guessed type const char *arg_8;

//----- (081362A4) --------------------------------------------------------
int __cdecl sub_81362A4(const char *a1, const char *a2, int a3)
{
  int v3; // edx
  int v6; // [esp+20h] [ebp-838h]
  int v7; // [esp+24h] [ebp-834h]
  int v8; // [esp+28h] [ebp-830h]
  int v9; // [esp+2Ch] [ebp-82Ch]
  int v10; // [esp+30h] [ebp-828h]
  int v11; // [esp+34h] [ebp-824h]
  char *v12; // [esp+38h] [ebp-820h]
  char *src; // [esp+3Ch] [ebp-81Ch]
  char dest[1024]; // [esp+40h] [ebp-818h] BYREF
  char s[1024]; // [esp+440h] [ebp-418h] BYREF
  int v16; // [esp+840h] [ebp-18h]
  size_t v17; // [esp+844h] [ebp-14h]
  int v18; // [esp+848h] [ebp-10h]
  int i; // [esp+84Ch] [ebp-Ch]

  v3 = dword_89BD9C0 + 1;
  dword_89BD9C0 = (dword_89BD9C0 + 1) / 2;
  dword_89BD9C0 = v3 - 2 * dword_89BD9C0;
  memset((void *)((dword_89BD9C0 << 10) + 144431584), 0, 0x400u);
  v16 = (int)&unk_89BD9E0 + 1024 * dword_89BD9C0;
  v18 = 0;
  v11 = 1;
  v10 = 1;
  v9 = 0;
  v7 = 1;
  v8 = 0;
  src = (char *)a1;
  v12 = (char *)a1;
  while ( *src )
  {
    if ( !*v12 || *v12 == 20 || *v12 == 21 || *v12 == 22 )
    {
      if ( v12 > src )
      {
        v17 = v12 - src;
        I_strncpyz(s, src, v12 - src + 1);
        if ( v11 )
        {
          if ( !sub_81361BE(s, s, a2, a3) )
            return 0;
          v17 = strlen(s);
        }
        if ( v18 + v17 > 0x3FF )
        {
          if ( loc_warnings
            && *(_BYTE *)(loc_warnings + 8)
            && loc_warningsAsErrors
            && *(_BYTE *)(loc_warningsAsErrors + 8)
            && a3 != 1 )
          {
            Com_Error(1, "%s too long when translated: \"%s\"", a2, a1);
          }
          Com_Printf("%s too long when translated: \"%s\"\n", a2, a1);
        }
        for ( i = 0; i < (int)(v17 - 2); ++i )
        {
          if ( !strncmp(&s[i], "&&", 2u) && (*(_WORD *)(_ctype_b + 2 * s[i + 2]) & 0x800) != 0 )
          {
            if ( v10 )
            {
              ++v9;
            }
            else
            {
              s[i] = 22;
              v8 = 1;
            }
          }
        }
        if ( v9 <= 0 || v18 <= 0 )
        {
          strcpy((char *)(v16 + v18), s);
        }
        else
        {
          for ( i = 0; i < v18 - 2; ++i )
          {
            if ( !strncmp((const char *)(v16 + i), "&&", 2u)
              && (*(_WORD *)(_ctype_b + 2 * *(char *)(v16 + i + 2)) & 0x800) != 0 )
            {
              v6 = *(char *)(v16 + i + 2) - 48;
              if ( *(_BYTE *)(v16 + i + 2) == 48 )
                Com_Printf("%s cannot have &&0 as conversion format: \"%s\"\n", a2, a1);
              if ( v6 == v7 )
              {
                strcpy(dest, (const char *)(v16 + i + 3));
                *(_BYTE *)(v16 + i) = 0;
                ++v7;
                break;
              }
            }
          }
          strcpy((char *)(v16 + i), s);
          strcpy((char *)(v16 + i + v17), dest);
          v18 -= 3;
          --v9;
        }
        v18 += v17;
      }
      v10 = 1;
      if ( *v12 == 20 )
      {
        v11 = 1;
        ++v12;
      }
      else if ( *v12 == 21 )
      {
        v11 = 0;
        ++v12;
      }
      if ( *v12 == 22 )
      {
        v10 = 0;
        ++v12;
      }
      src = v12;
    }
    else
    {
      ++v12;
    }
  }
  if ( v8 )
  {
    for ( i = 0; i < v18; ++i )
    {
      if ( *(_BYTE *)(v16 + i) == 22 )
        *(_BYTE *)(v16 + i) = 37;
    }
  }
  return v16;
}
// 8185A64: using guessed type int _ctype_b;
// 852314C: using guessed type int loc_warnings;
// 8523150: using guessed type int loc_warningsAsErrors;
// 89BD9C0: using guessed type int dword_89BD9C0;
// 81362A4: using guessed type const char *arg_4;

//----- (081367A0) --------------------------------------------------------
_BOOL4 __cdecl sub_81367A0(__int16 a1)
{
  return (HIBYTE(a1) > 0xA0u && HIBYTE(a1) <= 0xC6u || HIBYTE(a1) > 0xC8u && HIBYTE(a1) <= 0xF9u)
      && ((unsigned __int8)a1 > 0x3Fu && (unsigned __int8)a1 <= 0x7Eu || (unsigned __int8)a1 > 0xA0u
                                                                      && (_BYTE)a1 != 0xFF);
}

//----- (08136800) --------------------------------------------------------
_BOOL4 __cdecl sub_8136800(unsigned int a1)
{
  return a1 > 0xA13F && a1 <= 0xA153;
}

//----- (0813688A) --------------------------------------------------------
_BOOL4 __cdecl sub_813688A(unsigned __int8 a1, char a2)
{
  return (a1 > 0x80u && a1 <= 0x9Fu || a1 > 0xDFu && a1 <= 0xEFu)
      && ((unsigned __int8)a2 > 0x3Fu && (unsigned __int8)a2 <= 0x7Eu || a2 <= -4);
}

//----- (081368E6) --------------------------------------------------------
_BOOL4 __cdecl sub_81368E6(unsigned int a1)
{
  return a1 > 0x813F && a1 <= 0x8151;
}

//----- (08136980) --------------------------------------------------------
int __cdecl sub_8136980(unsigned __int8 a1, unsigned __int8 a2)
{
  int v3; // [esp+0h] [ebp-8h]

  v3 = 0;
  if ( a1 > 0xA0u && a1 <= 0xF7u && a2 > 0xA0u && a2 != 0xFF )
    return 1;
  return v3;
}

//----- (081369BE) --------------------------------------------------------
_BOOL4 __cdecl sub_81369BE(unsigned int a1)
{
  return a1 > 0xA1A0 && a1 <= 0xA1AD;
}

//----- (08136A38) --------------------------------------------------------
int __cdecl sub_8136A38(unsigned __int8 **a1, _DWORD *a2)
{
  int v3; // [esp+14h] [ebp-24h]
  int v4; // [esp+1Ch] [ebp-1Ch]
  int v6; // [esp+2Ch] [ebp-Ch]
  unsigned int v7; // [esp+2Ch] [ebp-Ch]
  unsigned int v8; // [esp+2Ch] [ebp-Ch]
  unsigned int v9; // [esp+2Ch] [ebp-Ch]
  int v10; // [esp+2Ch] [ebp-Ch]
  unsigned __int8 *v11; // [esp+30h] [ebp-8h]

  v11 = *a1;
  if ( !Language_IsAsian() )
    goto LABEL_25;
  v4 = sub_8135D0C();
  if ( v4 == 9 )
  {
    if ( !sub_81367A0(v11[1] + (*v11 << 8)) )
      goto LABEL_25;
    v7 = v11[1] + (*v11 << 8);
    *a1 += 2;
    if ( a2 )
      *a2 = sub_8136800(v7);
    return v7;
  }
  else
  {
    if ( v4 <= 9 )
    {
      if ( v4 == 8 && (unsigned __int8)sub_8136E02(*v11, v11[1]) )
      {
        v6 = v11[1] + (*v11 << 8);
        *a1 += 2;
        if ( a2 )
          *a2 = 0;
        return v6;
      }
      goto LABEL_25;
    }
    if ( v4 != 10 )
    {
      if ( v4 == 11 && (unsigned __int8)sub_8136E88(v11[1] + (*v11 << 8)) )
      {
        v9 = v11[1] + (*v11 << 8);
        *a1 += 2;
        if ( a2 )
          *a2 = sub_81369BE(v9);
        return v9;
      }
LABEL_25:
      v10 = *v11;
      ++*a1;
      if ( a2 )
      {
        v3 = 0;
        if ( v10 == 33 || v10 == 63 || v10 == 44 || v10 == 46 || v10 == 59 || v10 == 58 )
          v3 = 1;
        *a2 = v3;
      }
      return v10;
    }
    if ( !sub_813688A(*v11, v11[1]) )
      goto LABEL_25;
    v8 = v11[1] + (*v11 << 8);
    *a1 += 2;
    if ( a2 )
      *a2 = sub_81368E6(v8);
    return v8;
  }
}

//----- (08136CB4) --------------------------------------------------------
int Language_IsAsian()
{
  return g_currentAsian;
}
// 89BD5A0: using guessed type int g_currentAsian;

//----- (08136CE6) --------------------------------------------------------
int __cdecl sub_8136CE6(unsigned __int8 *a1)
{
  char *v3; // [esp+Ch] [ebp-Ch] BYREF
  int v4; // [esp+10h] [ebp-8h]
  int v5; // [esp+14h] [ebp-4h]

  if ( !a1 )
    return 0;
  v5 = 0;
  v3 = (char *)a1;
  while ( *v3 )
  {
    v4 = sub_8136A38((unsigned __int8 **)&v3, 0);
    if ( v4 == 94 && v3 && *v3 != 94 && *v3 > 47 && *v3 <= 57 )
    {
      ++v3;
    }
    else if ( v4 != 10 && v4 != 13 )
    {
      ++v5;
    }
  }
  return v5;
}

//----- (08136D72) --------------------------------------------------------
char *__cdecl sub_8136D72(unsigned int a1)
{
  if ( a1 < 0xE )
    return (&off_8168640)[2 * a1];
  else
    return off_8168640;
}
// 8168640: using guessed type char *off_8168640;

//----- (08136DA2) --------------------------------------------------------
int __cdecl sub_8136DA2(char *a1, int *a2)
{
  int i; // [esp+14h] [ebp-4h]

  for ( i = 0; i <= 13; ++i )
  {
    if ( !I_stricmp(a1, (&off_8168640)[2 * i]) )
    {
      *a2 = i;
      return 1;
    }
  }
  *a2 = 0;
  return 0;
}
// 8168640: using guessed type char *off_8168640;

//----- (08136E02) --------------------------------------------------------
int __cdecl sub_8136E02(unsigned __int8 a1, unsigned __int8 a2)
{
  int v3; // [esp+0h] [ebp-8h]

  v3 = 0;
  if ( a1 > 0xAFu && a1 <= 0xC8u && a2 > 0xA0u && a2 != 0xFF )
    return 1;
  return v3;
}

//----- (08136E40) --------------------------------------------------------
int __cdecl sub_8136E40(__int16 a1)
{
  return (unsigned __int8)sub_8136E02(HIBYTE(a1), a1);
}

//----- (08136E64) --------------------------------------------------------
_BOOL4 __cdecl sub_8136E64(__int16 a1)
{
  return sub_813688A(HIBYTE(a1), a1);
}

//----- (08136E88) --------------------------------------------------------
int __cdecl sub_8136E88(__int16 a1)
{
  return (unsigned __int8)sub_8136980(HIBYTE(a1), a1);
}

//----- (08136EAC) --------------------------------------------------------
int __cdecl sub_8136EAC(const char *a1)
{
  int v3; // [esp+14h] [ebp-4h] BYREF

  if ( FS_ReadFile(a1, &v3) <= 0 )
    return 0;
  else
    return v3;
}

//----- (08136EE2) --------------------------------------------------------
void __cdecl sub_8136EE2(_DWORD *a1)
{
  FS_FreeFile(a1);
}

//----- (08136EF6) --------------------------------------------------------
void __cdecl sub_8136EF6(char *a1, const char *a2, int a3)
{
  char s[76]; // [esp+20h] [ebp-68h] BYREF
  int v4; // [esp+6Ch] [ebp-1Ch] BYREF
  int i; // [esp+70h] [ebp-18h]
  int v6; // [esp+74h] [ebp-14h] BYREF
  void *v7; // [esp+78h] [ebp-10h]
  void *ptr; // [esp+7Ch] [ebp-Ch]

  v7 = FS_ListFiles((int)a2, "/", 0, &v4);
  for ( i = 0; i < v4; ++i )
  {
    if ( **((_BYTE **)v7 + i) )
    {
      if ( **((_BYTE **)v7 + i) != 46 )
      {
        sprintf(s, "%s/%s", a2, *((const char **)v7 + i));
        sub_8136EF6(a1, (int)s, a3);
      }
    }
  }
  ptr = FS_ListFiles((int)a2, a1, 0, &v6);
  for ( i = 0; i < v6; ++i )
  {
    sprintf(s, "%s/%s", a2, *((const char **)ptr + i));
    std::string::operator+=(a3, s);
    std::string::operator+=(a3, 59);
    ++dword_89BE1E0;
  }
  FS_FreeFileList((void **)ptr);
  FS_FreeFileList((void **)v7);
}
// 804A090: using guessed type int __cdecl std::string::operator+=(_DWORD, _DWORD);
// 804A380: using guessed type int __cdecl std::string::operator+=(_DWORD, _DWORD);
// 89BE1E0: using guessed type int dword_89BE1E0;

//----- (0813707E) --------------------------------------------------------
int __cdecl sub_813707E(const char *a1, int a2)
{
  dword_89BE1E0 = 0;
  std::string::operator=(a2, &unk_8159A3C);
  sub_8136EF6("str", a1, a2);
  return dword_89BE1E0;
}
// 8049C10: using guessed type int __cdecl std::string::operator=(_DWORD, _DWORD);
// 89BE1E0: using guessed type int dword_89BE1E0;

//----- (081370C4) --------------------------------------------------------
int __cdecl sub_81370C4(_DWORD *a1)
{
  sub_8138892((int)(a1 + 4));
  *a1 = 0;
  std::string::operator=(a1 + 1, &unk_8159A60);
  return std::string::operator=(a1 + 2, &unk_8159A60);
}
// 8049C10: using guessed type int __cdecl std::string::operator=(_DWORD, _DWORD);

//----- (08137110) --------------------------------------------------------
char *__cdecl sub_8137110(int a1, char *src)
{
  char *v3; // [esp+18h] [ebp-10h]
  char *v4; // [esp+24h] [ebp-4h]

  I_strncpyz(byte_89BE220, src, 64);
  v4 = sub_8138700(byte_89BE220, 92);
  v3 = sub_8138700(byte_89BE220, 47);
  if ( v3 < v4 )
    v3 = v4;
  if ( v3 )
    *v3 = 0;
  return byte_89BE220;
}

//----- (0813718C) --------------------------------------------------------
char *__cdecl sub_813718C(int a1, char *src)
{
  char *v3; // [esp+Ch] [ebp-Ch]
  char *v4; // [esp+10h] [ebp-8h]
  char *v5; // [esp+14h] [ebp-4h]

  strcpy(byte_89BE260, src);
  v5 = sub_8138700(byte_89BE260, 46);
  v4 = sub_8138700(byte_89BE260, 92);
  v3 = sub_8138700(byte_89BE260, 47);
  if ( v5 && (!v4 || v5 > v4) && (!v3 || v5 > v3) )
    *v5 = 0;
  return byte_89BE260;
}
// 81371FA: conditional instruction was optimized away because %var_8.4!=0
// 8137210: conditional instruction was optimized away because %var_C.4!=0

//----- (0813722A) --------------------------------------------------------
char *__cdecl sub_813722A(int a1, char *a2)
{
  char *src; // [esp+14h] [ebp-4h]

  src = a2;
  while ( *a2 )
  {
    if ( *a2 == 47 || *a2 == 92 )
      src = a2 + 1;
    ++a2;
  }
  strcpy(byte_89BE2A0, src);
  return byte_89BE2A0;
}

//----- (0813727A) --------------------------------------------------------
char *__cdecl sub_813727A(int a1, char *src)
{
  char *v2; // eax

  v2 = sub_8137110(a1, src);
  return sub_813722A(a1, v2);
}

//----- (081372A4) --------------------------------------------------------
int __cdecl sub_81372A4(int a1, char *src)
{
  char *v2; // eax
  char *v3; // eax
  char dest[72]; // [esp+10h] [ebp-48h] BYREF

  v2 = sub_813718C(a1, src);
  v3 = sub_813722A(a1, v2);
  strcpy(dest, v3);
  I_strupr(dest);
  return std::string::operator=(a1 + 12, dest);
}
// 8049C10: using guessed type int __cdecl std::string::operator=(_DWORD, _DWORD);

//----- (081372FC) --------------------------------------------------------
int __cdecl sub_81372FC(int a1, char *s, const char **a3)
{
  size_t v3; // eax

  v3 = strlen(s);
  if ( strncasecmp(s, *a3, v3) )
    return 0;
  for ( *a3 += strlen(s); **a3 == 9 || **a3 == 32; ++*a3 )
    ;
  return 1;
}

//----- (08137378) --------------------------------------------------------
int __cdecl sub_8137378(int a1, char *haystack)
{
  int v4; // [esp+1Ch] [ebp-2Ch]
  char s[28]; // [esp+20h] [ebp-28h] BYREF
  char *i; // [esp+3Ch] [ebp-Ch]

  memset(s, 0, 9u);
  for ( i = strstr(haystack, "&&"); i; i = strstr(i, "&&") )
  {
    i += 2;
    if ( !isdigit(*i) )
      return 0;
    v4 = *i - 48;
    if ( s[--v4] )
      return 0;
    s[v4] = 1;
    ++i;
  }
  return 1;
}
// 8137378: using guessed type char s[28];

//----- (08137430) --------------------------------------------------------
std::string *__stdcall sub_8137430(std::string *a1, int a2, int a3)
{
  int v4; // [esp+20h] [ebp-8h]

  std::string::string(a1);
  std::string::operator=(a1, a3);
  while ( 1 )
  {
    v4 = std::string::find(a1, "\\n", 0);
    if ( v4 == -1 )
      break;
    *(_BYTE *)std::string::operator[](a1, v4) = 10;
    std::string::erase(a1, v4 + 1, 1u);
  }
  return a1;
}
// 8049E90: using guessed type int __cdecl std::string::operator=(_DWORD, _DWORD);
// 8049EE0: using guessed type int __cdecl std::string::operator[](_DWORD, _DWORD);

//----- (081374D8) --------------------------------------------------------
char *__cdecl sub_81374D8(int a1, char *a2)
{
  char *result; // eax
  char *j; // [esp+14h] [ebp-14h] BYREF
  int v4; // [esp+18h] [ebp-10h]
  int i; // [esp+1Ch] [ebp-Ch]
  char *v6; // [esp+20h] [ebp-8h]
  char *s; // [esp+24h] [ebp-4h]

  s = a2;
  for ( i = 0; ; i = v4 )
  {
    result = sub_813871A(s, "//");
    v6 = result;
    if ( !result )
      break;
    v4 = i;
    for ( j = 0; (int)j < v6 - s; ++j )
    {
      if ( j[(_DWORD)s] == 34 )
        ++v4;
    }
    if ( (((unsigned __int8)v4 ^ 1) & 1) != 0 )
    {
      *v6 = 0;
      result = s;
      if ( *s )
      {
        result = (char *)(strlen(s) - 1);
        for ( j = result; (int)j >= 0; --j )
        {
          result = (char *)isspace(j[(_DWORD)s]);
          if ( !result )
            break;
          j[(_DWORD)s] = 0;
          result = (char *)&j;
        }
      }
      return result;
    }
    s = v6 + 1;
  }
  return result;
}

//----- (081375AC) --------------------------------------------------------
int __cdecl sub_81375AC(int a1, const char **a2, char *dest)
{
  size_t na; // [esp+18h] [ebp-10h]
  signed int n; // [esp+18h] [ebp-10h]
  char *v7; // [esp+1Ch] [ebp-Ch]

  if ( !**a2 )
    return 0;
  v7 = strchr(*a2, 10);
  if ( v7 )
  {
    na = v7 - *a2;
    strncpy(dest, *a2, na);
    dest[na] = 0;
    for ( *a2 += na; **a2 && strchr("\r\n", **a2); ++*a2 )
      ;
  }
  else
  {
    strcpy(dest, *a2);
    *a2 += strlen(*a2);
  }
  if ( *dest )
  {
    for ( n = strlen(dest) - 1; n >= 0 && isspace(dest[n]); --n )
      dest[n] = 0;
    sub_81374D8(a1, dest);
  }
  return 1;
}

//----- (081376E8) --------------------------------------------------------
std::string *__stdcall sub_81376E8(std::string *a1, int a2, _BYTE *a3)
{
  const char *v3; // eax
  const char *v4; // eax
  const char *v5; // eax
  size_t v6; // eax
  const char *v7; // eax
  const char *v8; // eax
  size_t v9; // eax
  int v11; // [esp+18h] [ebp-10h]
  int v12; // [esp+1Ch] [ebp-Ch]
  int v13; // [esp+20h] [ebp-8h]

  std::string::string(a1);
  std::string::operator=(a1, &unk_8159A60);
  while ( *a3 == 32 || *a3 == 9 )
    ++a3;
  if ( *a3 == 34 )
    ++a3;
  std::string::operator=(a1, a3);
  if ( *a3 )
  {
    while ( 1 )
    {
      v13 = std::string::c_str(a1);
      v3 = (const char *)std::string::c_str(a1);
      if ( *(_BYTE *)(strlen(v3) + v13 - 1) != 32 )
      {
        v12 = std::string::c_str(a1);
        v4 = (const char *)std::string::c_str(a1);
        if ( *(_BYTE *)(strlen(v4) + v12 - 1) != 9 )
          break;
      }
      v5 = (const char *)std::string::c_str(a1);
      v6 = strlen(v5);
      std::string::erase(a1, v6 - 1, 1u);
    }
    v11 = std::string::c_str(a1);
    v7 = (const char *)std::string::c_str(a1);
    if ( *(_BYTE *)(strlen(v7) + v11 - 1) == 34 )
    {
      v8 = (const char *)std::string::c_str(a1);
      v9 = strlen(v8);
      std::string::erase(a1, v9 - 1, 1u);
    }
  }
  return a1;
}
// 8049C10: using guessed type int __cdecl std::string::operator=(_DWORD, _DWORD);

//----- (0813785C) --------------------------------------------------------
char *__cdecl sub_813785C(_DWORD *a1, char *s2, char a3)
{
  const char *v3; // eax
  const char *v4; // eax
  size_t v5; // eax
  char *v6; // eax
  const char *v7; // eax
  char *v8; // eax
  _BOOL4 v10; // [esp+1Ch] [ebp-45Ch]
  char v11[28]; // [esp+20h] [ebp-458h] BYREF
  size_t n; // [esp+3Ch] [ebp-43Ch]
  char dest[1032]; // [esp+40h] [ebp-438h] BYREF
  char *i; // [esp+448h] [ebp-30h]
  char v15[4]; // [esp+44Ch] [ebp-2Ch]
  char v16[24]; // [esp+450h] [ebp-28h] BYREF
  char *v17; // [esp+468h] [ebp-10h]
  char v18; // [esp+46Fh] [ebp-9h]

  v18 = a3;
  v17 = 0;
  if ( s2 )
  {
    if ( sub_81372FC((int)a1, "VERSION", (const char **)&s2) )
    {
      sub_81376E8((std::string *)v16, (int)a1, s2);
      v3 = (const char *)std::string::c_str((std::string *)v16);
      *(_DWORD *)v15 = atoi(v3);
      if ( *(_DWORD *)v15 != 1 )
        v17 = va("Unexpected version number %d, expecting %d!\n", *(_DWORD *)v15, 1);
      std::string::~string((std::string *)v16);
    }
    else if ( !sub_81372FC((int)a1, "CONFIG", (const char **)&s2)
           && !sub_81372FC((int)a1, "FILENOTES", (const char **)&s2)
           && !sub_81372FC((int)a1, "NOTES", (const char **)&s2)
           && !sub_81372FC((int)a1, "FLAGS", (const char **)&s2) )
    {
      if ( sub_81372FC((int)a1, "REFERENCE", (const char **)&s2) )
      {
        sub_81376E8((std::string *)v16, (int)a1, s2);
        v4 = (const char *)std::string::c_str((std::string *)v16);
        sub_8137CE8((int)a1, v4);
        std::string::~string((std::string *)v16);
      }
      else if ( sub_81372FC((int)a1, "ENDMARKER", (const char **)&s2) )
      {
        *a1 = 1;
      }
      else if ( !strncasecmp("LANG_", s2, 5u) )
      {
        *(_DWORD *)v15 = sub_8137CD2((int)a1);
        if ( **(_BYTE **)v15 )
        {
          s2 += 5;
          for ( i = s2; *i && *i != 32 && *i != 9; ++i )
            ;
          memset(dest, 0, 0x400u);
          n = i - s2;
          if ( (unsigned int)(i - s2) > 0x3FF )
            n = 1023;
          strncpy(dest, s2, n);
          v5 = strlen(dest);
          s2 += v5;
          sub_81376E8((std::string *)v11, (int)a1, s2);
          sub_8137430((std::string *)v16, (int)a1, (int)v11);
          std::string::~string((std::string *)v11);
          v6 = (char *)std::string::c_str((std::string *)v16);
          if ( !(unsigned __int8)sub_8137378((int)a1, v6) )
          {
            v7 = (const char *)std::string::c_str((std::string *)v16);
            v17 = va("Illegal string format \"%s\"\n", v7);
          }
          v10 = strcasecmp(dest, "english") == 0;
          if ( !v17 && (v10 || !v18) )
          {
            v8 = (char *)std::string::c_str((std::string *)v16);
            sub_8137EEC((int)a1, *(const char **)v15, v8, v10);
          }
          std::string::~string((std::string *)v16);
        }
        else
        {
          return "Error parsing file: Unexpected \"LANG_\"\n";
        }
      }
      else
      {
        return va("Unknown keyword at linestart: \"%s\"\n", s2);
      }
    }
  }
  return v17;
}

//----- (08137CD2) --------------------------------------------------------
int __cdecl sub_8137CD2(int a1)
{
  return std::string::c_str((std::string *)(a1 + 4));
}

//----- (08137CE8) --------------------------------------------------------
int __cdecl sub_8137CE8(int a1, const char *a2)
{
  const char *v2; // eax
  char *v3; // eax
  const char *v4; // eax
  char *v5; // eax
  int v6; // eax
  char v8[16]; // [esp+20h] [ebp-58h] BYREF
  char v9[16]; // [esp+30h] [ebp-48h] BYREF
  _DWORD v10[4]; // [esp+40h] [ebp-38h] BYREF
  char v11[16]; // [esp+50h] [ebp-28h] BYREF
  int v12[5]; // [esp+60h] [ebp-18h] BYREF

  std::allocator<char>::allocator(v10);
  v2 = (const char *)std::string::c_str((std::string *)(a1 + 12));
  v3 = va("%s_%s", v2, a2);
  std::string::string(v11, v3, v10);
  sub_81384A6(v12, a1 + 16, (std::string *)v11);
  std::string::~string((std::string *)v11);
  std::allocator<char>::~allocator(v10);
  sub_81384D2(v10, a1 + 16);
  if ( sub_8138490(v12, v10) )
  {
    std::string::string((std::string *)v11);
    std::allocator<char>::allocator(v8);
    v4 = (const char *)std::string::c_str((std::string *)(a1 + 12));
    v5 = va("%s_%s", v4, a2);
    std::string::string(v9, v5, v8);
    v6 = sub_81384F8(a1 + 16, (std::string *)v9);
    std::string::operator=(v6, v11);
    std::string::~string((std::string *)v9);
    std::allocator<char>::~allocator(v8);
    std::string::~string((std::string *)v11);
  }
  return std::string::operator=(a1 + 4, a2);
}
// 8049C10: using guessed type int __cdecl std::string::operator=(_DWORD, _DWORD);
// 8049C80: using guessed type int __cdecl std::allocator<char>::allocator(_DWORD);
// 8049D80: using guessed type int __cdecl std::string::string(_DWORD, _DWORD, _DWORD);
// 8049E90: using guessed type int __cdecl std::string::operator=(_DWORD, _DWORD);
// 804A1B0: using guessed type int __cdecl std::allocator<char>::~allocator(_DWORD);
// 8137CE8: using guessed type int var_18[5];
// 8137CE8: using guessed type _DWORD var_38[4];

//----- (08137EEC) --------------------------------------------------------
int __cdecl sub_8137EEC(int a1, const char *a2, char *s1, int a4)
{
  const char *v4; // eax
  char *v5; // eax
  int v7; // [esp+1Ch] [ebp-3Ch]
  char v8[16]; // [esp+20h] [ebp-38h] BYREF
  char v9[16]; // [esp+30h] [ebp-28h] BYREF
  int v10[5]; // [esp+40h] [ebp-18h] BYREF

  std::allocator<char>::allocator(v8);
  v4 = (const char *)std::string::c_str((std::string *)(a1 + 12));
  v5 = va("%s_%s", v4, a2);
  std::string::string(v9, v5, v8);
  sub_81384A6(v10, a1 + 16, (std::string *)v9);
  std::string::~string((std::string *)v9);
  std::allocator<char>::~allocator(v8);
  v7 = sub_8138676(v10) + 4;
  if ( a4 )
  {
    std::string::operator=(v7, s1);
    return std::string::operator=(a1 + 8, s1);
  }
  else if ( !strcasecmp(s1, "#same") )
  {
    return std::string::operator=(v7, a1 + 8);
  }
  else
  {
    return std::string::operator=(v7, s1);
  }
}
// 8049C10: using guessed type int __cdecl std::string::operator=(_DWORD, _DWORD);
// 8049C80: using guessed type int __cdecl std::allocator<char>::allocator(_DWORD);
// 8049D80: using guessed type int __cdecl std::string::string(_DWORD, _DWORD, _DWORD);
// 8049E90: using guessed type int __cdecl std::string::operator=(_DWORD, _DWORD);
// 804A1B0: using guessed type int __cdecl std::allocator<char>::~allocator(_DWORD);
// 8137EEC: using guessed type int var_18[5];

//----- (0813803A) --------------------------------------------------------
char *__cdecl sub_813803A(std::string *a1)
{
  const char *v1; // eax
  char *v4; // [esp+14h] [ebp-4h]

  if ( !*(_BYTE *)std::string::c_str(a1) )
    return 0;
  v1 = (const char *)std::string::c_str(a1);
  strncpy(byte_89BE2E0, v1, 0x3Fu);
  byte_89BE31F = 0;
  v4 = sub_81386E6(byte_89BE2E0, 59);
  if ( v4 )
  {
    *v4 = 0;
    std::string::erase(a1, 0, (unsigned int)&v4[1 - (_DWORD)byte_89BE2E0]);
  }
  else
  {
    std::string::erase(a1, 0, 0xFFFFFFFF);
  }
  return byte_89BE2E0;
}
// 89BE31F: using guessed type char byte_89BE31F;

//----- (081380F6) --------------------------------------------------------
char *__cdecl sub_81380F6(char *src, char a2)
{
  int v4; // [esp+14h] [ebp-4024h] BYREF
  _DWORD *v5; // [esp+18h] [ebp-4020h]
  char *v6; // [esp+1Ch] [ebp-401Ch]
  char dest[16399]; // [esp+20h] [ebp-4018h] BYREF
  char v8; // [esp+402Fh] [ebp-9h]

  v8 = a2;
  v6 = 0;
  v5 = (_DWORD *)sub_8136EAC(src);
  if ( !v5 )
    return va("Unable to load \"%s\"!", src);
  v4 = (int)v5;
  sub_81372A4(dword_89BE200, src);
  while ( !v6 && sub_81375AC(dword_89BE200, (const char **)&v4, dest) )
  {
    if ( dest[0] )
      v6 = sub_813785C((_DWORD *)dword_89BE200, dest, v8);
  }
  sub_8136EE2(v5);
  if ( !v6 && !sub_8138888(dword_89BE200) )
    return va("Truncated file, failed to find \"%s\" at file end!", "ENDMARKER");
  return v6;
}

//----- (0813821E) --------------------------------------------------------
int __cdecl sub_813821E(int a1)
{
  std::string *v3; // [esp+1Ch] [ebp-3Ch]
  _DWORD v4[4]; // [esp+20h] [ebp-38h] BYREF
  char v5[16]; // [esp+30h] [ebp-28h] BYREF
  int v6[5]; // [esp+40h] [ebp-18h] BYREF

  std::allocator<char>::allocator(v4);
  std::string::string(v5, a1, v4);
  sub_81384A6(v6, dword_89BE200 + 16, (std::string *)v5);
  std::string::~string((std::string *)v5);
  std::allocator<char>::~allocator(v4);
  sub_81384D2(v4, dword_89BE200 + 16);
  if ( !sub_813868A(v6, v4) )
    return 0;
  v3 = (std::string *)(sub_8138676(v6) + 4);
  return std::string::c_str(v3);
}
// 8049C80: using guessed type int __cdecl std::allocator<char>::allocator(_DWORD);
// 8049D80: using guessed type int __cdecl std::string::string(_DWORD, _DWORD, _DWORD);
// 804A1B0: using guessed type int __cdecl std::allocator<char>::~allocator(_DWORD);
// 813821E: using guessed type int var_18[5];
// 813821E: using guessed type _DWORD var_38[4];

//----- (08138320) --------------------------------------------------------
int sub_8138320()
{
  return sub_81370C4((_DWORD *)dword_89BE200);
}

//----- (08138336) --------------------------------------------------------
int sub_8138336()
{
  _DWORD *ptr; // [esp+24h] [ebp-4h]

  ptr = sub_8138860();
  sub_8138734((int)ptr);
  dword_89BE200 = (int)ptr;
  return sub_81370C4(ptr);
}

//----- (0813839E) --------------------------------------------------------
void sub_813839E()
{
  void *ptr; // [esp+4h] [ebp-4h]

  if ( dword_89BE200 )
  {
    sub_81370C4((_DWORD *)dword_89BE200);
    ptr = (void *)dword_89BE200;
    if ( dword_89BE200 )
    {
      sub_81387C6(dword_89BE200);
      sub_8138874(ptr);
    }
    dword_89BE200 = 0;
  }
}

//----- (081383EC) --------------------------------------------------------
char *__cdecl sub_81383EC(char a1)
{
  char *v1; // ebx
  char *src; // [esp+1Ch] [ebp-2Ch]
  char v4[24]; // [esp+20h] [ebp-28h] BYREF
  char *v5; // [esp+38h] [ebp-10h]
  char v6; // [esp+3Fh] [ebp-9h]

  v6 = a1;
  v5 = 0;
  std::string::string((std::string *)v4);
  sub_8138320();
  sub_813707E("localizedstrings", (int)v4);
  while ( 1 )
  {
    src = sub_813803A((std::string *)v4);
    if ( !src || v5 )
      break;
    v5 = sub_81380F6(src, v6);
  }
  v1 = v5;
  std::string::~string((std::string *)v4);
  return v1;
}

//----- (08138490) --------------------------------------------------------
_BOOL4 __cdecl sub_8138490(_DWORD *a1, _DWORD *a2)
{
  return *a1 == *a2;
}

//----- (081384A6) --------------------------------------------------------
int *__userpurge sub_81384A6@<eax>(int *a1, int a2, std::string *a3)
{
  sub_8138BC4(a1, a2, a3);
  return a1;
}

//----- (081384D2) --------------------------------------------------------
_DWORD *__userpurge sub_81384D2@<eax>(_DWORD *a1, int a2)
{
  sub_8138B9E(a1, a2);
  return a1;
}

//----- (081384F8) --------------------------------------------------------
int __cdecl sub_81384F8(int a1, std::string *a2)
{
  std::string *v2; // ebx
  char v4; // [esp+1Fh] [ebp-79h]
  int v5[4]; // [esp+20h] [ebp-78h] BYREF
  char v6[16]; // [esp+30h] [ebp-68h] BYREF
  char v7[16]; // [esp+40h] [ebp-58h] BYREF
  int v8[7]; // [esp+50h] [ebp-48h] BYREF
  int v9[4]; // [esp+6Fh] [ebp-29h] BYREF
  int v10[5]; // [esp+80h] [ebp-18h] BYREF

  sub_8138CD6(v10, a1, a2);
  v4 = 0;
  sub_81384D2((int *)((char *)v9 + 1), a1);
  if ( sub_8138490(v10, (int *)((char *)v9 + 1))
    || (v2 = (std::string *)sub_8138D96(v10), sub_8138DA4((int)v9), (unsigned __int8)sub_8138B62((int)v9, a2, v2)) )
  {
    v4 = 1;
  }
  if ( v4 )
  {
    std::string::string((std::string *)v6);
    sub_8138DD4((std::string *)v7, a2, (std::string *)v6);
    sub_81389BC(v5, v10);
    sub_81386A0(v8, a1, v5, (std::string *)v7);
    v10[0] = v8[0];
    sub_8138926((std::string *)v7);
    std::string::~string((std::string *)v6);
  }
  return sub_8138D96(v10) + 4;
}
// 81384F8: using guessed type int var_48[7];
// 81384F8: using guessed type int var_78[4];

//----- (08138676) --------------------------------------------------------
int __cdecl sub_8138676(_DWORD *a1)
{
  return sub_8138D96(a1);
}

//----- (0813868A) --------------------------------------------------------
_BOOL4 __cdecl sub_813868A(_DWORD *a1, _DWORD *a2)
{
  return *a1 != *a2;
}

//----- (081386A0) --------------------------------------------------------
int *__userpurge sub_81386A0@<eax>(int *a1, int a2, int *a3, std::string *a4)
{
  int v5[5]; // [esp+10h] [ebp-18h] BYREF

  sub_81389BC(v5, a3);
  sub_8138E2A(a1, a2, v5, a4);
  return a1;
}
// 81386A0: using guessed type int var_18[5];

//----- (081386E6) --------------------------------------------------------
char *__cdecl sub_81386E6(char *s, int c)
{
  return strchr(s, c);
}

//----- (08138700) --------------------------------------------------------
char *__cdecl sub_8138700(char *s, int c)
{
  return strrchr(s, c);
}

//----- (0813871A) --------------------------------------------------------
char *__cdecl sub_813871A(char *haystack, char *needle)
{
  return strstr(haystack, needle);
}

//----- (08138734) --------------------------------------------------------
int __cdecl sub_8138734(int a1)
{
  std::string::string((std::string *)(a1 + 4));
  std::string::string((std::string *)(a1 + 8));
  std::string::string((std::string *)(a1 + 12));
  return sub_81389DA(a1 + 16);
}

//----- (081387C6) --------------------------------------------------------
void __cdecl sub_81387C6(int a1)
{
  sub_81393A2(a1 + 16);
  std::string::~string((std::string *)(a1 + 12));
  std::string::~string((std::string *)(a1 + 8));
  std::string::~string((std::string *)(a1 + 4));
}

//----- (08138860) --------------------------------------------------------
void *sub_8138860()
{
  return Z_MallocInternal(0x20u);
}

//----- (08138874) --------------------------------------------------------
void __cdecl sub_8138874(void *ptr)
{
  Z_FreeInternal(ptr);
}

//----- (08138888) --------------------------------------------------------
int __cdecl sub_8138888(int a1)
{
  return *(_DWORD *)a1;
}

//----- (08138892) --------------------------------------------------------
int __cdecl sub_8138892(int a1)
{
  return sub_81388A6(a1);
}

//----- (081388A6) --------------------------------------------------------
int __cdecl sub_81388A6(int a1)
{
  int result; // eax
  char **v2; // eax

  result = a1;
  if ( *(_DWORD *)(a1 + 8) )
  {
    v2 = (char **)sub_8138918(a1);
    sub_8138948(a1, *v2);
    *(_DWORD *)sub_81389A0(a1) = *(_DWORD *)(a1 + 4);
    *(_DWORD *)sub_8138918(a1) = 0;
    *(_DWORD *)sub_81389AE(a1) = *(_DWORD *)(a1 + 4);
    result = a1;
    *(_DWORD *)(a1 + 8) = 0;
  }
  return result;
}

//----- (08138918) --------------------------------------------------------
int __cdecl sub_8138918(int a1)
{
  return *(_DWORD *)(a1 + 4) + 4;
}

//----- (08138926) --------------------------------------------------------
void __cdecl sub_8138926(std::string *a1)
{
  std::string::~string((std::string *)((char *)a1 + 4));
  std::string::~string(a1);
}

//----- (08138948) --------------------------------------------------------
void __cdecl sub_8138948(int a1, char *ptr)
{
  void **v2; // eax
  char *v3; // [esp+14h] [ebp-4h]

  while ( ptr )
  {
    v2 = (void **)sub_81393B6((int)ptr);
    sub_8138948(a1, *v2);
    v3 = *(char **)sub_8138B2E((int)ptr);
    sub_8138B3A(a1, ptr);
    ptr = v3;
  }
}

//----- (081389A0) --------------------------------------------------------
int __cdecl sub_81389A0(int a1)
{
  return *(_DWORD *)(a1 + 4) + 8;
}

//----- (081389AE) --------------------------------------------------------
int __cdecl sub_81389AE(int a1)
{
  return *(_DWORD *)(a1 + 4) + 12;
}

//----- (081389BC) --------------------------------------------------------
int __cdecl sub_81389BC(int *a1, int *a2)
{
  int result; // eax

  sub_81392FE();
  result = *a2;
  *a1 = *a2;
  return result;
}

//----- (081389DA) --------------------------------------------------------
int __cdecl sub_81389DA(int a1)
{
  sub_8138A06();
  return sub_8138A0C(a1);
}

//----- (08138A06) --------------------------------------------------------
void sub_8138A06()
{
  ;
}

//----- (08138A0C) --------------------------------------------------------
int __cdecl sub_8138A0C(int a1)
{
  sub_8138A3C(a1);
  *(_DWORD *)(a1 + 8) = 0;
  return sub_8138ACE(a1);
}

//----- (08138A3C) --------------------------------------------------------
void *__cdecl sub_8138A3C(int a1)
{
  void *result; // eax

  sub_8138A6C(a1);
  result = sub_8138A96(a1);
  *(_DWORD *)(a1 + 4) = result;
  return result;
}

//----- (08138A6C) --------------------------------------------------------
int __cdecl sub_8138A6C(int a1)
{
  int result; // eax

  sub_8138A90();
  result = a1;
  *(_DWORD *)(a1 + 4) = 0;
  return result;
}

//----- (08138A90) --------------------------------------------------------
void sub_8138A90()
{
  ;
}

//----- (08138A96) --------------------------------------------------------
void *__cdecl sub_8138A96(int a1)
{
  return sub_8138AB2(a1, 1);
}

//----- (08138AB2) --------------------------------------------------------
void *__cdecl sub_8138AB2(int a1, int a2)
{
  return malloc(24 * a2);
}

//----- (08138ACE) --------------------------------------------------------
int __cdecl sub_8138ACE(int a1)
{
  _DWORD *v1; // edx
  int result; // eax

  *(_DWORD *)sub_8138B26(*(_DWORD *)(a1 + 4)) = 0;
  *(_DWORD *)sub_8138918(a1) = 0;
  *(_DWORD *)sub_81389A0(a1) = *(_DWORD *)(a1 + 4);
  v1 = (_DWORD *)sub_81389AE(a1);
  result = *(_DWORD *)(a1 + 4);
  *v1 = result;
  return result;
}

//----- (08138B26) --------------------------------------------------------
int __cdecl sub_8138B26(int a1)
{
  return a1;
}

//----- (08138B2E) --------------------------------------------------------
int __cdecl sub_8138B2E(int a1)
{
  return a1 + 8;
}

//----- (08138B3A) --------------------------------------------------------
void __cdecl sub_8138B3A(int a1, char *ptr)
{
  sub_813943C((std::string *)(ptr + 16));
  sub_81393C2(a1, ptr);
}

//----- (08138B62) --------------------------------------------------------
int __cdecl sub_8138B62(int a1, std::string *a2, std::string *a3)
{
  return (unsigned __int8)sub_8138B80(a2, a3);
}

//----- (08138B80) --------------------------------------------------------
int __cdecl sub_8138B80(std::string *a1, std::string *a2)
{
  return std::string::compare(a1, a2) >> 31;
}

//----- (08138B9E) --------------------------------------------------------
_DWORD *__userpurge sub_8138B9E@<eax>(_DWORD *a1, int a2)
{
  sub_8139486(a1, *(_DWORD *)(a2 + 4));
  return a1;
}

//----- (08138BC4) --------------------------------------------------------
int *__userpurge sub_8138BC4@<eax>(int *a1, int a2, std::string *a3)
{
  std::string *v3; // eax
  std::string *v4; // eax
  _DWORD v6[4]; // [esp+10h] [ebp-38h] BYREF
  int v7[6]; // [esp+20h] [ebp-28h] BYREF
  int v8; // [esp+38h] [ebp-10h]
  int v9; // [esp+3Ch] [ebp-Ch]

  v9 = *(_DWORD *)(a2 + 4);
  v8 = *(_DWORD *)sub_8138918(a2);
  while ( v8 )
  {
    v3 = (std::string *)sub_8139450(v8);
    if ( (unsigned __int8)sub_8138B62(a2 + 12, v3, a3) )
    {
      v8 = *(_DWORD *)sub_81393B6(v8);
    }
    else
    {
      v9 = v8;
      v8 = *(_DWORD *)sub_8138B2E(v8);
    }
  }
  sub_8139486(v7, v9);
  sub_8138B9E(v6, a2);
  if ( sub_8138490(v7, v6) || (v4 = (std::string *)sub_81394A2(v7[0]), (unsigned __int8)sub_8138B62(a2 + 12, a3, v4)) )
    sub_8138B9E(a1, a2);
  else
    sub_81389BC(a1, v7);
  return a1;
}
// 8138BC4: using guessed type _DWORD var_38[4];

//----- (08138CD6) --------------------------------------------------------
_DWORD *__userpurge sub_8138CD6@<eax>(_DWORD *a1, int a2, std::string *a3)
{
  sub_8138D02(a1, a2, a3);
  return a1;
}

//----- (08138D02) --------------------------------------------------------
_DWORD *__userpurge sub_8138D02@<eax>(_DWORD *a1, int a2, std::string *a3)
{
  std::string *v3; // eax
  int v5; // [esp+10h] [ebp-8h]
  int v6; // [esp+14h] [ebp-4h]

  v6 = *(_DWORD *)(a2 + 4);
  v5 = *(_DWORD *)sub_8138918(a2);
  while ( v5 )
  {
    v3 = (std::string *)sub_8139450(v5);
    if ( (unsigned __int8)sub_8138B62(a2 + 12, v3, a3) )
    {
      v5 = *(_DWORD *)sub_81393B6(v5);
    }
    else
    {
      v6 = v5;
      v5 = *(_DWORD *)sub_8138B2E(v5);
    }
  }
  sub_8139486(a1, v6);
  return a1;
}

//----- (08138D96) --------------------------------------------------------
int __cdecl sub_8138D96(_DWORD *a1)
{
  return *a1 + 16;
}

//----- (08138DA4) --------------------------------------------------------
int __stdcall sub_8138DA4(int a1)
{
  sub_8138DCA(a1);
  return a1;
}

//----- (08138DCA) --------------------------------------------------------
int __stdcall sub_8138DCA(int a1)
{
  return a1;
}

//----- (08138DD4) --------------------------------------------------------
int __cdecl sub_8138DD4(std::string *a1, std::string *a2, std::string *a3)
{
  std::string::string(a1, a2);
  return std::string::string((std::string *)((char *)a1 + 4), a3);
}

//----- (08138E2A) --------------------------------------------------------
int *__userpurge sub_8138E2A@<eax>(int *a1, int a2, int *a3, std::string *a4)
{
  std::string *v4; // ebx
  std::string *v5; // eax
  std::string *v6; // ebx
  int *v7; // eax
  std::string *v8; // eax
  int *v9; // eax
  std::string *v10; // ebx
  std::string *v11; // eax
  std::string *v12; // ebx
  std::string *v13; // eax
  char v15; // [esp+2Fh] [ebp-49h]
  int v16[7]; // [esp+30h] [ebp-48h] BYREF
  char v17; // [esp+4Dh] [ebp-2Bh] BYREF
  char v18; // [esp+4Eh] [ebp-2Ah] BYREF
  char v19; // [esp+4Fh] [ebp-29h] BYREF
  int v20[7]; // [esp+50h] [ebp-28h] BYREF
  char v21[5]; // [esp+6Fh] [ebp-9h] BYREF

  if ( *a3 == *(_DWORD *)(*(_DWORD *)(a2 + 4) + 8) )
  {
    if ( sub_81394CC(a2)
      && (v4 = (std::string *)sub_81394A2(*a3),
          v5 = (std::string *)sub_81394C4((int)v21, (int)a4),
          (unsigned __int8)sub_8138B62(a2 + 12, v5, v4)) )
    {
      sub_81394D8(a1, a2, *a3, *a3, a4);
    }
    else
    {
      sub_81390FA((int)v20, a2, a4);
      sub_81389BC(a1, v20);
    }
  }
  else if ( *a3 == *(_DWORD *)(a2 + 4) )
  {
    v6 = (std::string *)sub_81394C4((int)&v19, (int)a4);
    v7 = (int *)sub_81389AE(a2);
    v8 = (std::string *)sub_8139450(*v7);
    if ( (unsigned __int8)sub_8138B62(a2 + 12, v8, v6) )
    {
      v9 = (int *)sub_81389AE(a2);
      sub_81394D8(a1, a2, 0, *v9, a4);
    }
    else
    {
      sub_81390FA((int)v20, a2, a4);
      sub_81389BC(a1, v20);
    }
  }
  else
  {
    sub_81389BC(v20, a3);
    sub_81392DC((int)v20);
    v15 = 0;
    v10 = (std::string *)sub_81394C4((int)&v18, (int)a4);
    v11 = (std::string *)sub_81394A2(v20[0]);
    if ( (unsigned __int8)sub_8138B62(a2 + 12, v11, v10) )
    {
      v12 = (std::string *)sub_81394A2(*a3);
      v13 = (std::string *)sub_81394C4((int)&v17, (int)a4);
      if ( (unsigned __int8)sub_8138B62(a2 + 12, v13, v12) )
        v15 = 1;
    }
    if ( v15 )
    {
      if ( *(_DWORD *)sub_81392F2(v20[0]) )
        sub_81394D8(a1, a2, *a3, *a3, a4);
      else
        sub_81394D8(a1, a2, 0, v20[0], a4);
    }
    else
    {
      sub_81390FA((int)v16, a2, a4);
      sub_81389BC(a1, v16);
    }
  }
  return a1;
}
// 8138E2A: using guessed type char var_9[5];
// 8138E2A: using guessed type int var_48[7];

//----- (081390FA) --------------------------------------------------------
int __userpurge sub_81390FA@<eax>(int a1, int a2, std::string *a3)
{
  std::string *v3; // ebx
  std::string *v4; // eax
  std::string *v5; // ebx
  std::string *v6; // eax
  int v8; // [esp+28h] [ebp-50h]
  unsigned __int8 v9; // [esp+2Ch] [ebp-4Ch] BYREF
  unsigned __int8 v10; // [esp+2Dh] [ebp-4Bh] BYREF
  char v11; // [esp+2Eh] [ebp-4Ah] BYREF
  unsigned __int8 v12; // [esp+2Fh] [ebp-49h] BYREF
  int v13[4]; // [esp+30h] [ebp-48h] BYREF
  _DWORD v14[4]; // [esp+40h] [ebp-38h] BYREF
  int v15[5]; // [esp+50h] [ebp-28h] BYREF
  char v16; // [esp+66h] [ebp-12h] BYREF
  char v17; // [esp+67h] [ebp-11h]
  int v18; // [esp+68h] [ebp-10h]
  int v19; // [esp+6Ch] [ebp-Ch]

  v19 = *(_DWORD *)(a2 + 4);
  v18 = *(_DWORD *)sub_8138918(a2);
  v17 = 1;
  while ( v18 )
  {
    v19 = v18;
    v3 = (std::string *)sub_8139450(v18);
    v4 = (std::string *)sub_81394C4((int)&v16, (int)a3);
    v17 = sub_8138B62(a2 + 12, v4, v3);
    if ( v17 )
      v8 = *(_DWORD *)sub_8138B2E(v18);
    else
      v8 = *(_DWORD *)sub_81393B6(v18);
    v18 = v8;
  }
  sub_8139486(v15, v19);
  if ( v17 )
  {
    sub_8139682(v14, a2);
    if ( sub_8138490(v15, v14) )
    {
      sub_81394D8(v13, a2, v18, v19, a3);
      v12 = 1;
      sub_81396B0(a1, v13, &v12);
      return a1;
    }
    sub_81392DC((int)v15);
  }
  v5 = (std::string *)sub_81394C4((int)&v11, (int)a3);
  v6 = (std::string *)sub_81394A2(v15[0]);
  if ( (unsigned __int8)sub_8138B62(a2 + 12, v6, v5) )
  {
    sub_81394D8(v13, a2, v18, v19, a3);
    v10 = 1;
    sub_81396B0(a1, v13, &v10);
  }
  else
  {
    v9 = 0;
    sub_81396B0(a1, v15, &v9);
  }
  return a1;
}
// 81390FA: using guessed type _DWORD var_38[4];
// 81390FA: using guessed type int var_48[4];

//----- (081392DC) --------------------------------------------------------
int __cdecl sub_81392DC(int a1)
{
  sub_8139304(a1);
  return a1;
}

//----- (081392F2) --------------------------------------------------------
int __cdecl sub_81392F2(int a1)
{
  return a1 + 12;
}

//----- (081392FE) --------------------------------------------------------
void sub_81392FE()
{
  ;
}

//----- (08139304) --------------------------------------------------------
int __cdecl sub_8139304(int a1)
{
  int result; // eax
  int i; // [esp+0h] [ebp-4h]
  int j; // [esp+0h] [ebp-4h]

  if ( **(_DWORD **)a1 || *(_DWORD *)(*(_DWORD *)(*(_DWORD *)a1 + 4) + 4) != *(_DWORD *)a1 )
  {
    if ( *(_DWORD *)(*(_DWORD *)a1 + 8) )
    {
      for ( i = *(_DWORD *)(*(_DWORD *)a1 + 8); *(_DWORD *)(i + 12); i = *(_DWORD *)(i + 12) )
        ;
      result = i;
      *(_DWORD *)a1 = i;
    }
    else
    {
      for ( j = *(_DWORD *)(*(_DWORD *)a1 + 4); *(_DWORD *)a1 == *(_DWORD *)(j + 8); j = *(_DWORD *)(j + 4) )
        *(_DWORD *)a1 = j;
      result = j;
      *(_DWORD *)a1 = j;
    }
  }
  else
  {
    result = *(_DWORD *)(*(_DWORD *)a1 + 12);
    *(_DWORD *)a1 = result;
  }
  return result;
}

//----- (081393A2) --------------------------------------------------------
void __cdecl sub_81393A2(int a1)
{
  sub_81393F8(a1);
}

//----- (081393B6) --------------------------------------------------------
int __cdecl sub_81393B6(int a1)
{
  return a1 + 12;
}

//----- (081393C2) --------------------------------------------------------
void __cdecl sub_81393C2(int a1, void *ptr)
{
  sub_81393E4(a1, ptr);
}

//----- (081393E4) --------------------------------------------------------
void __cdecl sub_81393E4(int a1, void *ptr)
{
  free(ptr);
}

//----- (081393F8) --------------------------------------------------------
void __cdecl sub_81393F8(int a1)
{
  sub_81388A6(a1);
  sub_813988E(a1);
}

//----- (0813943C) --------------------------------------------------------
void __cdecl sub_813943C(std::string *a1)
{
  sub_8138926(a1);
}

//----- (08139450) --------------------------------------------------------
int __cdecl sub_8139450(int a1)
{
  int v1; // eax
  char v3; // [esp+17h] [ebp-1h] BYREF

  v1 = sub_8139472(a1);
  return sub_813947E((int)&v3, v1);
}

//----- (08139472) --------------------------------------------------------
int __cdecl sub_8139472(int a1)
{
  return a1 + 16;
}

//----- (0813947E) --------------------------------------------------------
int __cdecl sub_813947E(int a1, int a2)
{
  return a2;
}

//----- (08139486) --------------------------------------------------------
int __cdecl sub_8139486(_DWORD *a1, int a2)
{
  int result; // eax

  sub_81392FE();
  result = a2;
  *a1 = a2;
  return result;
}

//----- (081394A2) --------------------------------------------------------
int __cdecl sub_81394A2(int a1)
{
  int v1; // eax
  char v3; // [esp+17h] [ebp-1h] BYREF

  v1 = sub_8139472(a1);
  return sub_813947E((int)&v3, v1);
}

//----- (081394C4) --------------------------------------------------------
int __cdecl sub_81394C4(int a1, int a2)
{
  return a2;
}

//----- (081394CC) --------------------------------------------------------
int __cdecl sub_81394CC(int a1)
{
  return *(_DWORD *)(a1 + 8);
}

//----- (081394D8) --------------------------------------------------------
_DWORD *__userpurge sub_81394D8@<eax>(_DWORD *a1, int a2, int a3, int a4, std::string *a5)
{
  std::string *v5; // ebx
  std::string *v6; // eax
  _DWORD *v7; // eax
  _DWORD *v8; // eax
  _DWORD *v9; // eax
  _DWORD *v10; // eax
  _DWORD *v11; // eax
  _DWORD *v12; // eax
  _DWORD *v13; // eax
  _DWORD *v14; // eax
  _DWORD *v15; // eax
  char v17; // [esp+17h] [ebp-11h] BYREF
  _DWORD *v18; // [esp+18h] [ebp-10h]
  int v19; // [esp+1Ch] [ebp-Ch]
  int v20; // [esp+20h] [ebp-8h]

  v20 = a3;
  v19 = a4;
  if ( a4 == *(_DWORD *)(a2 + 4)
    || v20
    || (v5 = (std::string *)sub_8139450(v19),
        v6 = (std::string *)sub_81394C4((int)&v17, (int)a5),
        (unsigned __int8)sub_8138B62(a2 + 12, v6, v5)) )
  {
    v18 = sub_81398AC(a2, a5);
    v7 = (_DWORD *)sub_8138B2E(v19);
    *v7 = v18;
    if ( v19 == *(_DWORD *)(a2 + 4) )
    {
      v8 = (_DWORD *)sub_8138918(a2);
      *v8 = v18;
      v9 = (_DWORD *)sub_81389AE(a2);
      *v9 = v18;
    }
    else
    {
      v10 = (_DWORD *)sub_81389A0(a2);
      if ( v19 == *v10 )
      {
        v11 = (_DWORD *)sub_81389A0(a2);
        *v11 = v18;
      }
    }
  }
  else
  {
    v18 = sub_81398AC(a2, a5);
    v12 = (_DWORD *)sub_81393B6(v19);
    *v12 = v18;
    v13 = (_DWORD *)sub_81389AE(a2);
    if ( v19 == *v13 )
    {
      v14 = (_DWORD *)sub_81389AE(a2);
      *v14 = v18;
    }
  }
  v15 = (_DWORD *)sub_8139676((int)v18);
  *v15 = v19;
  *(_DWORD *)sub_8138B2E((int)v18) = 0;
  *(_DWORD *)sub_81393B6((int)v18) = 0;
  sub_81396D6(v18, (_DWORD *)(*(_DWORD *)(a2 + 4) + 4));
  ++*(_DWORD *)(a2 + 8);
  sub_8139486(a1, (int)v18);
  return a1;
}

//----- (08139676) --------------------------------------------------------
int __cdecl sub_8139676(int a1)
{
  return a1 + 4;
}

//----- (08139682) --------------------------------------------------------
_DWORD *__userpurge sub_8139682@<eax>(_DWORD *a1, int a2)
{
  int *v2; // eax

  v2 = (int *)sub_81389A0(a2);
  sub_8139486(a1, *v2);
  return a1;
}

//----- (081396B0) --------------------------------------------------------
int __cdecl sub_81396B0(int a1, int *a2, unsigned __int8 *a3)
{
  int result; // eax

  sub_81389BC((int *)a1, a2);
  result = *a3;
  *(_BYTE *)(a1 + 4) = result;
  return result;
}

//----- (081396D6) --------------------------------------------------------
_DWORD *__cdecl sub_81396D6(_DWORD *a1, _DWORD *a2)
{
  _DWORD *result; // eax
  _DWORD *v3; // [esp+14h] [ebp-4h]
  _DWORD *v4; // [esp+14h] [ebp-4h]

  *a1 = 0;
  while ( a1 != (_DWORD *)*a2 && !*(_DWORD *)a1[1] )
  {
    if ( a1[1] == *(_DWORD *)(*(_DWORD *)(a1[1] + 4) + 8) )
    {
      v3 = *(_DWORD **)(*(_DWORD *)(a1[1] + 4) + 12);
      if ( !v3 || *v3 )
      {
        if ( a1 == *(_DWORD **)(a1[1] + 12) )
        {
          a1 = (_DWORD *)a1[1];
          sub_81399AA((int)a1, a2);
        }
        *(_DWORD *)a1[1] = 1;
        **(_DWORD **)(a1[1] + 4) = 0;
        sub_8139A36(*(_DWORD *)(a1[1] + 4), a2);
      }
      else
      {
        *(_DWORD *)a1[1] = 1;
        *v3 = 1;
        **(_DWORD **)(a1[1] + 4) = 0;
        a1 = *(_DWORD **)(a1[1] + 4);
      }
    }
    else
    {
      v4 = *(_DWORD **)(*(_DWORD *)(a1[1] + 4) + 8);
      if ( !v4 || *v4 )
      {
        if ( a1 == *(_DWORD **)(a1[1] + 8) )
        {
          a1 = (_DWORD *)a1[1];
          sub_8139A36((int)a1, a2);
        }
        *(_DWORD *)a1[1] = 1;
        **(_DWORD **)(a1[1] + 4) = 0;
        sub_81399AA(*(_DWORD *)(a1[1] + 4), a2);
      }
      else
      {
        *(_DWORD *)a1[1] = 1;
        *v4 = 1;
        **(_DWORD **)(a1[1] + 4) = 0;
        a1 = *(_DWORD **)(a1[1] + 4);
      }
    }
  }
  result = (_DWORD *)*a2;
  *(_DWORD *)*a2 = 1;
  return result;
}

//----- (0813988E) --------------------------------------------------------
void __cdecl sub_813988E(int a1)
{
  sub_81393C2(a1, *(void **)(a1 + 4));
}

//----- (081398AC) --------------------------------------------------------
void *__cdecl sub_81398AC(int a1, std::string *a2)
{
  void *ptr; // [esp+20h] [ebp-8h]

  ptr = sub_8138A96(a1);
  sub_8139920((int)ptr + 16, a2);
  return ptr;
}

//----- (08139920) --------------------------------------------------------
std::string *__cdecl sub_8139920(int a1, std::string *a2)
{
  std::string *result; // eax

  result = (std::string *)sub_813999C(8, a1);
  if ( result )
    return (std::string *)sub_8139AC2(result, a2);
  return result;
}

//----- (0813999C) --------------------------------------------------------
int __cdecl sub_813999C(int a1, int a2)
{
  return a2;
}

//----- (081399A4) --------------------------------------------------------
void sub_81399A4()
{
  ;
}

//----- (081399AA) --------------------------------------------------------
int __cdecl sub_81399AA(int a1, _DWORD *a2)
{
  int result; // eax
  int v3; // [esp+0h] [ebp-4h]

  v3 = *(_DWORD *)(a1 + 12);
  *(_DWORD *)(a1 + 12) = *(_DWORD *)(v3 + 8);
  if ( *(_DWORD *)(v3 + 8) )
    *(_DWORD *)(*(_DWORD *)(v3 + 8) + 4) = a1;
  *(_DWORD *)(v3 + 4) = *(_DWORD *)(a1 + 4);
  if ( a1 == *a2 )
  {
    *a2 = v3;
  }
  else if ( a1 == *(_DWORD *)(*(_DWORD *)(a1 + 4) + 8) )
  {
    *(_DWORD *)(*(_DWORD *)(a1 + 4) + 8) = v3;
  }
  else
  {
    *(_DWORD *)(*(_DWORD *)(a1 + 4) + 12) = v3;
  }
  *(_DWORD *)(v3 + 8) = a1;
  result = v3;
  *(_DWORD *)(a1 + 4) = v3;
  return result;
}

//----- (08139A36) --------------------------------------------------------
int __cdecl sub_8139A36(int a1, _DWORD *a2)
{
  int result; // eax
  int v3; // [esp+0h] [ebp-4h]

  v3 = *(_DWORD *)(a1 + 8);
  *(_DWORD *)(a1 + 8) = *(_DWORD *)(v3 + 12);
  if ( *(_DWORD *)(v3 + 12) )
    *(_DWORD *)(*(_DWORD *)(v3 + 12) + 4) = a1;
  *(_DWORD *)(v3 + 4) = *(_DWORD *)(a1 + 4);
  if ( a1 == *a2 )
  {
    *a2 = v3;
  }
  else if ( a1 == *(_DWORD *)(*(_DWORD *)(a1 + 4) + 12) )
  {
    *(_DWORD *)(*(_DWORD *)(a1 + 4) + 12) = v3;
  }
  else
  {
    *(_DWORD *)(*(_DWORD *)(a1 + 4) + 8) = v3;
  }
  *(_DWORD *)(v3 + 12) = a1;
  result = v3;
  *(_DWORD *)(a1 + 4) = v3;
  return result;
}

//----- (08139AC2) --------------------------------------------------------
int __cdecl sub_8139AC2(std::string *a1, std::string *a2)
{
  std::string::string(a1, a2);
  return std::string::string((std::string *)((char *)a1 + 4), (std::string *)((char *)a2 + 4));
}

//----- (08139B20) --------------------------------------------------------
int sub_8139B20()
{
  void (__cdecl **v0)(); // ebx
  void (__cdecl *v1)(); // eax
  int v3; // [esp+0h] [ebp-8h]

  v0 = (void (__cdecl **)())&off_8185784;
  v1 = (void (__cdecl *)())off_8185784;
  if ( off_8185784 != (int (*)())-1 )
  {
    do
    {
      --v0;
      v1();
      v1 = *v0;
    }
    while ( *v0 != (void (__cdecl *)())-1 );
  }
  return v3;
}
// 8139B4C: variable 'v3' is possibly undefined
// 8185784: using guessed type int (*off_8185784)();

//----- (08139B50) --------------------------------------------------------
void term_proc(void)
{
  deregister_frame_info();
}

// nfuncs=4891 queued=4608 decompiled=4608 lumina nreq=0 worse=0 better=0
// ALL OK, 4608 function(s) have been successfully decompiled
